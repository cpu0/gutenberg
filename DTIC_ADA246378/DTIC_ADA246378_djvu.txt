AD-A246 378 




NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



DTIC 

ELECTE 
FEB 181992 

D 




THESiS 


AN ADA OBJECT ORIENTED 
MISSILE FLIGHT SIMULATION 

by 

John V. Waite 
September 1991 

Thesis Advisor; Yuh-jeng Lee 


Approved for public release; distribution unlimited 


92-03981 


92 2 j-4 A45 






REPORT DOCUMENTATION PAGE 


1». REPORT security CLASSIFICATION 

UNCLASSIFIED 


2a. SECURITY CLASSIFICATION AUTHORITY 


2b. DECLASSIFICATION/DOWNGRADING SCHEDULE 


4. PERFORMING ORGANIZATION REPORT NUMBER(S) 


1b RESTRICTIVE MARKINGS 


3. DISTRIBUTION/AVAILABILITY OF REPORT 

Approved for public release; distribution is 

uniimited 


S. MONITORING ORGANIZATION REPORT NUMBER(S) 


6a. NAME OF PERFORMING ORGANIZATION 

Naval Postgraduate School 


6<. ADDRESS (Cty, State, and ZIP Code) 

Monterey, CA 93943-5000 


6b. OFFICE SYMBOL 
(If applicable) 

Code CS 


7a. NAME OF MONITORING ORGANIZATION 

Naval Postgraduate School 


7b. address (City, State, and ZIP Code) 

Monterey, CA 93943-5000 


8a. NAME OF FUNDING/SPONSORING 
ORGANIZATION 


8b. OFFICE SYMBOL 
(If applicable) 


9. PROCUREMENT INSTRUMENT IDENTIFICATION NUMiER 


8c. ADDRESS (City, State, and ZIP Code) 


10 SOURCE OF FUNDING NUMBERS 


PROGRAM 
ELEMENT NO. 


PROJECT 

TASK 

NO. 

NO. 


WORK UNIT 


11% TITLE (Include Security Claudication) 

An Ada Object Oriented Missile Flight Simulation 


12. personal AUTHOR(SJ . ,, 


John V. Waite 


13a. TYPE OF REPORT 




13b. TIME COVERED 
FROM TO 


14. DATE OF REPORT (Year, Month, Oay) ll$. PAGE COUNT 

^ September 1991 1 195 _ 


16 . supplementary NOTATION The views expressed in this thesis are those of the author and do not 
reflect the official policy or position of the Department of Defense or the U.S. Government. 


17. COSATI codes _ I 18. SUBJECT TERMS (Continue on reverse if necesury end identify by bloek number) 

I GROUP I SUB-GROUP | ^^ Software Engineering, Object Oriented, Simulation 


19. ABSTRACT (Continue on reverse it necessary end identify by block number) 

This thesis uses the Ada programming language in the design and development of an 
air-to-air missile flight simulation with object oriented techniques and sound software 
engineering principles. The simulation is designed to be more understandable, modifiable, 
efficient and reliable than earlier FORTRAN simulations. The principles of abstraction, 
information hiding, modularity, high cohesion and low coupling are used to achieve these 
goals. The resulting simulation is an accurate mapping of the problem space into software. 
The simulation is a three Degree-of-Freedom (3-DOF) model of RF/IR guided air-to-air 
missile. Two targets are also modeled. The simulation is primarily intended to study 
missile kinematics. • 


20. DISTRIBUTION/AVAILABILITY OF ABSTRACT 

GQ UNCLASSIFIEOAJNLIMITEO □ SAME AS RPT. □ OTIC USERS 

21. ABSTRACT SECURITY CLASSIFICATION 

UNCLASSIFIED 

22a. NAME OF RESPONSIBLE INDIVIDUAL 

Professor Yuh-jeng Lee 

22b. TELEPHONE (Include Area Code) 1 

(408) 646-2361 ! 

<2c. OFFICE SYMBOL 

Code.CS 


DO FORM 1473. B4 MAR 


83 APR edition may be used until evhauited. 
All other edition! are obsolete 


JRITY CLASSIFICATION OF THU PAGE 

eu,!: e»»»»m—■« »»»■!■■ eina*. i»»i «»• ■«. 


UNCLASSIFIED 


































Approved for public release; distribution is unlimited. 


AN ADA OBJECT ORIENTED MISSILE FLIGHT SIMULATION 


by 

John V. Waite 

B.S., Wayne State University, 1983 

Submitted in partial fulfillment 
of the requirements for the degree of 

MASTER OF SCIENCE IN COMPUTER SCIENCE 


Author: 


Approved by: 


from the 

NAVAL POSTGRADUATE SCHOOL 


leptember 1991 

\ John V. Waite 



Robert B. McGhee, Chairman 
Department of Computer Science 


4 


% 


11 






ABSTRACT 


This thesis uses the Ada programming language in the design and development 
of an air-to-air missile flight simulation with object oriented techniques and sound 
software engineering principles. The simulation is designed to be more 
understandable, modifiable, efficient and reliable than earlier FORTRAN 
simulations. The principles of abstraction, information hiding, modularity, high 
cohesion and low coupling are used to achieve these goals. The resulting simulation 
is an accurate mapping of the problem space into software. The simulation is a three 
Degree-of-Freedom (3-DOF) model of RF/IR guided air-to-air missile. Two targets 
are also modeled. The simulation is primarily intended to study missile kinematics. 


Accesion For j 

Nils 

CRA&I 


DTiC 

TaR 

n 

U .a 

o:i. Cud 

r ■' 

1 Jijstificat'o.) 


1 



8y __ 1 

Di. t lb 

• tio.-i/ 



V Code:- 

Di;t 

cl tw* / Of 

/l-l 





Ill 


o 








TABLE OF CONTENTS 


I. INTRODUCTION .1 

A. BACKGROUND .1 

B. CURRENT PRACTICES: PROBLEMS AND UMITATIONS .3 

C. MOTIVATION AND GOALS .5 

D. THESIS ORGANIZATION .5 

II. OBJECT ORIENTED TECHNIQUES WITH ADA .6 

A. OBJECTIVES OF OBJECT ORIENTED TECHNIQUES .6 

1. Understandability .6 

2. Modifiability .6 

3. Efficiency .7 

4. Reliability .7 

5. Reusability .7 

B. OBJECT ORIENTED PRINCIPLES .8 

1. Abstraction .8 

» 

2. Information Hiding .9 

3. Modularity .9 

4. Cohesion and Coupling .10 

5. Inheritance .11 


IV 























C. OBJECT ORIENTED METHODOLOGY WITH ADA 


11 


1. Ada Packages .11 

2. Methodology .12 

III. THE PROBLEM SPACE .14 

A. INTRODUCTION .14 

B. THE AIR-TO-AIR GUIDED MISSILE .16 

1. The Airframe .16 

2. Kinematics: Missile Dynamics.18 

3. Kinematics: Missile-Target Geometry .21 

4. Missile Guidance.21 

5. The Autopilot .23 

6. The Target .23 

7. The Atmosphere .24 

C. SUMMARY .24 

IV. THE USER'S VIEW OF THE SIMULATION.26 

A. INTRODUCTION. 26 

B. SIMULATION OPERATION .27 

1. Launch Aircraft and Missile Parameters .32 

2. Target Parameters.32 

3. SOJ and Target ECM Parameters.36 


V 

























V. THE CONTROL AND SUPPORT OBJECTS 


42 


A. INTRODUCTION .42 

B. BASIC METHODOLOGY .42 

C. OBJECT MESSAGES AND IMPLEMENTATION .43 

D. THE CONTROL OBJECTS .44 

1. The EXECUTIVE .44 

2. The APPUCATION .44 

3. The USER INTERFACE .48 

E. THE SUPPORT OBJECTS .51 

1. SYSTEM SPECIFIC .51 

2. INTEGRATION .53 

3. MATH .55 

4. REAL MATRIX .56 

VI. THE MISSILE, LAUNCHER, AND TARGETS .58 

A. INTRODUCTION . 58 

B. THE MISSILE .58 

1. MISSILE Messages .59 

2. The COMPUTE Message .60 

C. KINEMATICS .62 

D. THE AIRFRAME .64 

E. THE AUTOPILOT .65 

F. GUIDANCE .66 


VI 



























G. THE RF AND IR SEEKERS.67 

H. THE LAUNCHER .69 

I. THE TARGETS .70 

J. THE ENVIRONMENT.72 

VIL CONCLUSIONS AND RECOMMENDATIONS .73 

A. CONCLUSIONS .73 

B. RECOMMENDATIONS AND FUTURE WORK .74 

APPENDIX A CONTROL AND SUPPORT OBJECT DIAGRAMS .76 

APPENDIX B PROBLEM SPACE OBJECT DIAGRAMS .83 

APPENDIX C CONTROL OBJECT SOURCE CODE LISTINGS .94 

APPENDIX D PROBLEM SPACE OBJECT SOURCE CODE LISTINGS 143 

UST OF REFERENCES . 184 

INITIAL DISTRIBUTION UST . 186 

K 


Vll 

















I. INTRODUCTION 


A. BACKGROUND 

The ever increasing cost and complexity of modem weapon systems forces new 
demands on the test and evaluation (T&E) process. More extensive testing is 
required with fewer resources. This thesis explores one aspect of the T&E process 
as it relates to air-to-air guided missiles. 

In the early days of missile T&E {circa late 1940s), missile performance capability 
was determined solely through flight test, that is, actual missile launches. The 
realization that all the T&E data requirements could not be met with a limited 
number of launches led to captive-carry flight test, laboratory testing, and simulation 
to complement the missile launches. Today’s data requirements have grown in 
response to the increased missile sophistication and mission complexity. It is not 
unusual for a single flight test to cost more than a million dollars. Due to the 
increased data requirements and increased cost of flight test, missile flight simulation 
is receiving more and more attention. 

There are three levels of missile flight simulation in terms of cost and complexity. 
Real-time hardware-in-the-loop (HIL) simulation integrates actual missile hardware 
with special test and instrumentation equipment in a laboratory environment. The 
simulation software typically runs on a high-speed special purpose computer that 
drives the test equipment and missile hardware. The real-time HIL simulation 


1 





requires a major development effort of approximately thirty-five to forty man years 
and costs from five to ten million dollars [Ref. 1]. The second level of simulation is 
the all digital six-degree-of-freedom (6-IX)F) missile flight simulation. Six-degree-of- 
freedom indicates that the simulation computes forces and moments for all three 
axes. The 6-DOF simulation incorporates sophisticated models for various missile 
subsystems and runs on a mainframe class computer. The 6-DOF runs many times 
slower than real-time. For example, an actual missile flight that might take thirty 
seconds to complete in real-time might take eighteen hours to run to completion 
using a 6-DOF simulation. The 6-DOF simulation requires a development effort of 
4-6 man years. 

This thesis will concentrate on the third level of simulation, the fast analytical 
simulation (FAS). Simulations of this class are a rapid and inexpensive tool allowing 
missile systems analysts to study overall missile response or capability expeditiously. 
The FAS is a three degree-of-freedom (3-DOF) simulation, usually the forces are 
computed for all three axes (the moments are ignored) and a three dimensional 
space is represented. Alternately, a 3-DOF might represent a planar two 
c’Jmensional view where forces acting on two axes are computed while moments are 
computed about the remaining axis. The FAS is intended to be easily accessible via 
personal computers to provide results in a timely fashion. A user enters initial 
conditions and results are presented within a few minutes. 


2 






B. CURRENT PRACTICES: PROBLEMS AND LIMITATIONS 

The same problems are common to all three levels of missile flight simulation. 
Tae basic problems are that the simulations are extremely difficult to understand and 
to modify. The causes of these problems stem from the methods (or more accurately 
the lack of methods) and language used to implement the simulations. The difficulty 
in understanding and modifying the simulations introduces problems with efficiency 
and reliability. 

The simulations are usually developed by physicists or aerospace engineers using 
the FORTRAN programming language. Their main goal is "just to get something up 
and running". Typically these people have little or no training in modern software 
engineering principles. The resulting simulations are poorly structured and violate 
most commonly accepted programming principles. Typical characteristics of these 
simulations are: 

1. The simulations are monolithic pieces of code using many GOTO statements. 

2. Most variables are treated as global. 

3. Common data areas are used for communication between subroutines. 

4. Cryptic variable names are used (FORTRAN variable names are limited to six 
characters). 

5. The simulations are limited to very simple data structures (multi-dimensional 
arrays are usually the most sophisticated data structures found). 

6. Programming through side is common. 

7. The simulations have little or no comments or formal documentation. 


3 





The new analyst will usually require at least six months to gain a basic 
understanding of how the simulation works, even if he or she has an excellent 
understanding of missile systems. An understanding of the simulation is critical if 
results are to be interpreted correctly. It is not uncommon for the original 
developers of a simulation to move on to other jobs, leaving the analysts responsible 
for maintaining and modifying the simulation. Changes in the production missile's 
software or hardware, regularly occurring events, must be accurately reflected in the 
simulation code. Changes or patches introduced to the simulation code invariably 
make the code more obscure and, more often than not, produce undesirable side 
affects or bugs. Debugging these types of problems is incredibly time consuming and 
difficult. 

After numerous patches have been applied the simulation software becomes 
unreliable and inefficient. Wildly different results are obtained for slightly different 
initial conditions. The real-time HIL simulations no longer run in real-time. The 
6-DOF simulations may take days to solve a problem and the 3-DOF FAS 
simulations take hours - what once required hours and minutes respectively. Disk 
and main-memory capacity become issues. What was once a tool enabling scientists 
and engineers to analyze complex systems has become an unwieldy demanding 
burden of questionable value. 


4 





C. MOTIVATION AND GOALS 

Current missile flight simulations are difficult to understand and modify, hence 
inevitably become inefficient and unreliable. What is needed is a method that more 
closely represents the problem space allowing simulations to be developed that are 
easy to understand and modify. This thesis will explore the use of object oriented 
techniques using the Ada programming language, in conjunction with contemporary 
software engineering principles, to implement a missile flight simulation. This 
simulation should be easily understood in a reasonable amount of time and readily 
accommodate change. Additional goals include producing code that is efficient and 
reliable, 

D. THESIS ORGANIZATION 

Chapter II presents a brief view of object oriented development philosophy and 
technique using Ada. Chapter III discusses the problem space, the flight simulation 
of an air-to-air guided missile. Chapter IV presents a user-level view of the 
simulation. Chapter V concentrates on the simulation control and support objects, 
while Chapter VI discusses the missile, launcher, and target objects. Thesis 
conclusions and recommendations are presented in Chapter VII. 


5 





II. OBJECT ORIENTED TECHNIQUES WITH ADA 


A. OBJECTIVES OF OBJECT ORIENTED TECHNIQUES 

The goal of object oriented techniques is to produce software that is 
understandable, easy to modify, efficient, reliable and reusability. Object oriented 
techniques build on sound software engineering principles to encapsulate data and 
procedures into objects. Object oriented techniques, which capture the real world 
problem space, map well into the Ada programming language. 

1. Understandability 

Understandability is critical to the management of complex software systems. 
It is, without a doubt, the most important factor of a simulation to an analyst or 
person responsible for maintaining the simulation. The software solution, that is the 
simulation, should be an accurate model of the real world problem. Software can 
be thought of as being understandable on both a micro and macro level. Code at the 
micro level should have a style that is very readable. At the macro level data 
structures and algorithms should be able to be identified as mapping from the real 
world problem space. Understandability also tends to be tied to the programming 
language used and its richness of expression. 

2. Modifiability 

Well designed software should readily permit change. Modification is usually 
required due to a change in requirements or to correct to an error. Changes in 


6 






missile simulation code are required to explore new concepts, or as a result of missile 
hardware or software upgrades. Many changes are not planned. Ideally changes 
should not alter the fundamental architecture of the software solution. 

3. Efficiency 

Eff^iciency is the optimal use of two fundamental computer resources - storage 
space and execution time. Both of these resources are dependent underlying 
hardware, yet both resources are equally dependent on the software. An efficient 
missile simulation should provide better user response and more functionality than 
an inefficient simulation. 

4. Reliability 

The goal of reliability is to prevent failure, and to some extent, recover from 
failure in a graceful manner. Failure in a missile simulation might be defined as 
anything from a program that crashes to a program that produces results that do not 
agree with flight test data or produces inconsistent results. A reliable missile 
simulation will provide results that are consistent with real world experiences and 
give meaningful indications when potential problems might arise (e.g., limits 
exceeded or incorrect user input). 

5. Reusability 

The goal of reusability is to provide software components to build software 
much the same way hardware engineers build circuits from standard off-the-shelf 
components. The development of software systems can be dramatically reduced by 
using software components that have already been debugged and tested. These 


7 





components can form libraries of commonly used objects. Systems may be 
constructed from these libraries. These systems then may be added to the library. 

B. OBJECT ORIENTED PRINCIPLES 

Through abstraction, information hiding and modularity, object oriented 
techniques encapsulates data and procedural abstractions to form objects. Objects 
modularize both information and processing, rather than processing alone. Object 
oriented techniques establish a mechanism for (1) a representation of data structures, 
(2) the specification of process and (3) the invocation procedure. An object is an 
element of the real world mapped into the software domain. The object consists of 
operations which act on data structures in response to messages sent to that object 
from other objects. The operations and data structures are hidden, that is the 
implementation details are unknown to the user of the object. The interface to the 
object is the only portion visible to the user. The interface is a set of well defined 
messages that specify what operation on the object is desired. Object oriented 
techniques can aid sound software engineering principles. These principles include 
abstraction, information hiding, modularity, loose coupling, and strong cohesion [Ref. 
2 ]. 

1. Abstraction 

Many of the problems found with the missile flight simulations are due to their 
complexity. Abstraction is a powerful concept that helps one deal with complexity. 
Abstraction concentrates on the essential aspects of a problem, while omitting the 


8 





details. There may be many levels of abstraction constructed when solving a 
problem. At the top level of a missile simulation, abstraction would reveal the 
essential entities - the missile, target, and environment. Moving to the next lower 
level of abstraction within the missile, this level might be thought of as being 
composed of various subsystems, such as the seeker, the guidance section, the 
autopilot, and the airframe. Moving to the next lower level of abstraction, arbitrarily 
choosing the missile seeker for example, would reveal the data structures and 
procedures used to model the seeker. Only the lower levels of abstraction expose 
the specific details of a solution. 

2. Information Hiding 

Information hiding conceals the implementation details of a solution that 
should not affect other parts of a system. Through information hiding only the 
essential aspects of a solution are visible, while the implementation details or "how" 
of a solution are hidden. Hiding low level design decisions prevents the higher levels 
of abstraction from being dependent on implementation details. This approach aids 
abstraction and increase the modifiability of the solution. 

3. Modularity 

The importance of modularity in software design has been recognized for some 
time. According to Myers [Ref. 3], "Modularity is the single attribute of software that 
allows a program to be intellectually manageable." In monolithic software, such as 
the missile simulations, the number of control paths, number of variables and the 
overall complexity make understanding difficult. Ideally, software is decomposed into 


9 





modules along logically and functionally independent lines. Modularity supports our 
notion of abstraction. High-level modules specify "what" is to be done. Low-level 
modules specify "how" that action is to take place. 

3. Cohesion and Coupling 

Modules in software systems can be thought of as having two important 
characteristics, cohesion and coupling. Cohesion attempts to characterize to what 
degree a module performs a single function or serves a single purpose. A highly 
cohesive module would be one in which the module performs a single task that 
requires little or no interaction with other modules in a program. A module 
exhibiting low cohesion would perform many different functions and interact with a 
large number of other modules. Modules that are highly cohesive are easier to 
understand and are more amenable to change than modules exhibiting low cohesion. 

Coupling is measure of interconnection among modules in a program. Modules 
with high coupling have a complex interfaces and make use of data or control 
information found in other modules. Modules with low coupling have relatively 
simple interfaces and make use of only the data or control information presented by 
the interfaces of other modules. Changes made to modules with low coupling are 
less likely to cause unwanted effects in other modules, that is the ripple effect is 
minimized, like modules that are highly cohesive, modules with low coupling are 
easier to understand and modify. 


10 






4. Inheritance 


Inheritance is an object oriented concept that permits the organization, 
building and reuse of software [Ref. 4]. In a limited view of this concept, new objects 
may be defined to inherit the capability and functionality of other previously defined 
objects. The new objects may extend the capability and functionality of the original 
object by adding new capabilities and functionalities. Conversely the new object may 
be defined to eliminate or limit certain capabilities of the original object. Once an 
object has been developed, it may be reused with minimal effort through inheritance, 
reducing development time. 

C. OBJECT ORIENTED METHODOLOGY WITH ADA 
1. Ada Packages 

The object oriented philosophy maps well into the Ada programming language. 
Ada has a wide set of constructs for providing primitive objects and operations. 
These constructs serve to build the implementation level of the objects. Ada's 
packaging concept is conceptually similar to objects and provides the means to 
encapsulate objects. According to Booch [Ref. 5], "A package is a collection of 
computational resources, which may encapsulate data types, data objects, 
subprograms, tasks or even other packages." An Ada package consists of a 
specification and a body [Ref. 6]. The specification identifies the information that 
is visible to the user of that package. The package body contains the implementation 
details of the package which should (and can) remain physically and logically hidden 


11 






from the user. The specification and body may be compiled separately to enforce 
the separation of the specification or interface from the body with its implementation 
details. The specification can serve to define the messages associated with an object. 
The object responds in the appropriate manner to these messages. These messages 
might map to function or procedure calls and their input or output variables. 

Ada packages can be used to provide reusable software components. Packages 
of commonly required objects can form libraries where they may be withdrawn and 
reused. Ada's generic unit feature supports, in a limited way, the object oriented 
principle of inheritance. A generic package serves as a template for an object [Ref. 
7]. The generic object can then be instantiated with all the features of the generic 
object, along with any additional features required of that particular instantiation. 
For example, a generic stack or list object might be instantiated for each occurrence 
of a different data type, along with the additional capabilities that make sense for 
that particular data type. 

2. Methodology 

This thesis uses an object-oriented development technique similar to that 
advocated by Booch [Ref. 5] and first proposed by Abbott [Ref. 8]. The development 
process involves five steps. First, identify the objects and their characteristics or 
attributes as they exist in the problem space. Often a concise problem statement is 
useful in identifying objects. The nouns of the problem statement serve to identify 
potential objects. The second step is to identify the operations that characterize the 
behavior of the objects identified in the first step. These should be meaningful 


12 




operations that can be performed on the object. Verbs associated with an object 
noun in the problem statement can aid in the identification of meaningful operations. 
During this step time and space constraints are formed to define the dynamic 
behavior of the objects. The scope and ordering of operations might be defined for 
example. The third step is to establish the visibility of the objects with relation to 
one another. This step attempts to specify what objects "see", and what are "seen" 
by a given object. This serves to map the problem space into the objects. The fourth 
step is to define the interfaces to the objects. To do this an object specification is 
produced which "forms the boundary between the outside view and the inside view 
of an object." This maps directly into the Ada package specification construct. The 
final step is to implement each object by designing suitable data structures and 
algorithms and to implement the corresponding interface from the fourth step. Also 
at this step it is important to remain aware of the software engineering principles of 
modularity, high cohesion and low coupling. Note that this whole process can be 
recursive, that is, an object might further be decomposed into subordinate objects. 

The key point of this method is the accurate mapping of the problem space into 
software. This mapping preserves the real world view of the problem, and if done 
properly, tends to produce code that is easily understood. Object oriented techniques 
also lend themselves well to the software engineering principles discussed earlier. 
Through object oriented techniques and sound software engineering principles, our 
goals of producing a missile flight simulation that is easy to understand, easy to 
modify, efficient and reliable can be realized. 


13 




III. THE PROBLEM SPACE 


A. INTRODUCTION 

An air-to-air guided missile is designed to be carried on an aircraft and launched 
at an airborne target. After launch the missile guides, using its sensors, on the target 
to intercept. Air-to-air missile sensors may be radar, infrared or a combination of 
both types. Once the missile detects the target, it tracks and guides on the target by 
generating steering commands that will set a course to intercept the target. The 
missile flight simulation attempts to represent or model the missile and its 
environment. 

The missile flight simulation models a subset of the missile systems, the kinematics 
- consisting of the missile dynamics and the missile-target geometry, and the target. 
At the top level view, the simulation computes the forces acting on the missile (e.g., 
thrust, drag, and gravity) and from these forces derives accelerations to compute the 
missile's spatial trajectory from launch to target intercept. Figure 3.1 is a top-level 
block diagram of a missile flight simulation indicating the relationships of the various 
models. The missile subsystems are represented by the Autopilot, Airframe, and 
Guidance blocks. The blocks labeled Missile Dynamics and Missile-Target Geometry 
compute the kinematics. The Target block here represents a single target, but in 
most simulations more than one target is modeled. The missile airframe model, 
given its achieved accelerations, computes the forces acting on it for use in the 


14 





Achieved 

Accelerations 


Autopilot 


Commanded 

Accelerations 



Guidance Data Missile 
Guidance ^ Target 

Geometry 


Figure 3.1 Missile Flight Simulation 


15 















target geometry, which is passed to the guidance model. Acceleration commands, 
which will enable the missile to intercept the target, are computed by the guidance 
model and provided to the autopilot. The autopilot responds with the achieved 
accelerations, which are passed to the airframe model. 

B. THE AIR-TO-AIR GUIDED MISSILE 

The missile consists of a number of subsystems. These typically are the airframe, 
flight control, guidance, warhead, propulsion, data link and telemetry. The 
subsystems modeled in a simulation are the airframe, autopilot, guidance, and 
propulsion [Ref. 1]. In addition, the atmosphere and kinematics are modeled. 

1. The Airframe 

The missile airframe actuates or deflects the control surfaces which steer the 
missile. The missile is modeled as a rigid body and, as such, body and control 
surface bendings are not represented. The airframe is represented in terms of a 
reference axes system. Figure 3.2 illustrates the missile reference axes systems where 
X, y, and z are the primary missile reference or body axis system and the axes with 
the a subscript represent the missile autopilot or inertial axis system. 

Roll (4) is angular motion about the x-axis, pitch (ff) is angular motion about 
the y-axis, and yaw (^) is angular motion about the z-axis. The missile’s angle of 
attack, alpha (a), is the angle between the missile's velocity vector (V) and its x-axis. 


16 





Figure 3J Missile Reference Axes 

Three force equations describe the forces experienced by the missile along 
each axis. There is one force equation for each axis as follows: 

E F, = m • a, 

E Fy = m • ay 
E F^ = m • a^ 

These represent Newton's classic relation that force is the product of mass and 
acceleration. Here we resolve the forces into components along each missile axis. 

These force equations describe the dynamics of the airframe. Aerodynamics 
is the science applied to predicting these forces. These forces are expanded in terms 


17 





of aerodynamic parameters and coefficients [Ref. 9]. For example, the x-axis 
equation becomes: 

E F, = m • a, = Fp + (Cd„ • aq • S) + (Cdg • 6 * q • S) 

The first term in the above equation is the propulsion force. The second term 
is the product of the drag coefficient for a given angle of attack (Cd^), the angle of 
attack (a), and the missile reference area (S). The third term is the product of the 
drag coefficient for a given control surface deflection (Cd^), the control surface 
deflection (5), the aerodynamic pressure (q), and the missile reference area (S). The 
aerodynamic coefficients are a function of angle of attack, control surface deflection, 
roll angle and mach number. The aerodynamic parameters and forces are provided 
to the airframe model by the missile dynamics model, and the autopilot model 
provides the commanded accelerations as input. The airframe model computes the 
forces it is "experiencing" and sends these values to the kinematics model (see Figure 
3.3). 


2. Kinematics: Missile Dynamics 

The kinematics model serves two functions: to compute missile dynamics and 
to compute the missile-target geometry (see Figures 3.4 and 3.5). Inputs to the 
missile dynamics function are the airframe forces computed in the airframe model. 
From these values, and from initial conditions, the dynamics model derives 


18 






AIRFRAME 


Autopilot 

- Thrust & Mass 

Kinematics 


- Aero Coefficients 


Achieved 

- Angle of Attack 

Thrust & Aero 

Accels 


Data 

1 

Aerodynamic Parameter 

s 


Figure 3 J Airframe Model 


acceleration, velocity, position data, and flight-path variables. Angles, angular rates, 
and accelerations represent the inertial quantities. These inertial quantities simulate 
the inertial sensor measurements the missile would experience. 

Aerodynamic parameters, such as mach and velocity, are fed back to the 
airframe model. The derived acceleration, velocity, and position variables are sent 
to the missile-target geometry model. The kinematics model also transforms data 
between the two reference coordinate systems, that is, between the airframe 
reference system, known as the body coordinate system (x,y,z) and the autopilot 
reference system known as the inertial coordinate system (Xa,Ya,Za). 


19 







KINEMATICS 


Missile Dynamics 

Missile 

Airframe . , ir , 

— Acceleration, Velocity. 

Target 


Geometry 

^ - Position, Flight Path 


Thrust ic Aero 

Inertial 

Data ~ Angle Transformations 

Data 

1 Aero Data 


▼ 

Airframe 


Figure 3.4 Kinematics: Missile Dynamics 



KINEMATICS 


Missile 

Missile-Target Geometry 


Dynamics 

- Range Rate (Vc) 

- Range 

- Line of Sight (LOS) 

Guidance 

Inertial 

- LOS rate 

Guidance 

Data 

- Time of Flight 

Data 


\ 

Target Parameters 



Figure 3.5 Kinematics: Missile«Target Geometiy 


20 











3. Kinematics: Missile-Target Geometiy 

The primary purpose of the missile-target geometry portion of the kinematics 
model is to compute the missile-target engagement geometry parameters. These 
values are sent to the missile guidance model to steer the missile to the target. 
Inputs to the missile-target geometry model are missile acceleration, velocity, and 
position data from the missile dynamics model, and target acceleration, velocity, and 
position from the target model. These inputs are used to compute range rate 
(closing velocity), missile to target range, line-of-sight (LOS) rate, LOS, and time of 
flight. The simulation is terminated on range or time constraints determined by this 
model. The computed information is sent to the missile guidance model. 

4. Missile Guidance 

The guidance model represents the missile guidance law (see Figure 3.6). The 
guidance law determines what trajectory will cause the missile to intercept the target. 
Missile guidance can be classified by the type of sensor is used to provide target 
information. Common sensors are RF (radar), or infrared (IR). A missile may use 
a combination of RF and IR seekers. The actual missile guidance section is very 
complex and sophisticated, hence, extremely difficult to model. Most simple 
simulations assume a perfect guidance section that uses a modified proportional 
guidance law. 

An important parameter in guidance is the line-of-sight (LOS). The line-of- 
sight is the direction the missile "looks" in order to "see" the target. This is an 


21 






GUIDANCE 


Kinematics 


Figure 3.6 Guidance Model 

imaginaiy line from the missile's seeker to the centroid of the target. It has been 
proven that, given constant target and missile velocities, if the LOS angle between 
the target and the missile remains constant an optimum trajectory will be achieved, 
resulting in a minimum miss distance [Ref 1]. If the LOS angle is to remain constant 
then the LOS rate must be zero. The LOS rate is computed in the guidance section 
and multiplied by the navigation ratio N and sent to the autopilot as commanded 
accelerations proportional to the LOS rate; hence, the term proportional guidance. 

The commanded accelerations will change the missile velocity relative to the 
target velocity, driving the LOS rate to zero. The response of the guidance system 
is determined by the value chosen for the navigation ratio N. Most modem missiles 
improve upon the pure proportional guidance law by using the target related 
information available through improved sensors and increased on board computing 


Guidance 

Data 



22 








power. Target related parameters used in addition to LOS include target range, 
velocity, acceleration and time to intercept. Given guidance data, the guidance 
model computes the commanded accelerations required to intercept the target. 

5. The Autopilot 

The autopilot functions to give the missile stable and controlled flight. The 
autopilot has its own axes reference system (Xa, Ya, Za). The airframe motions 
about the autopilot axes are controlled by the autopilot. Motions about the Ya and 
Xa axes determine missile direction. The autopilots for these axes are termed the 
pitch and yaw autopilots, respectively. 

The autopilot receives commanded accelerations as input and responds with 
achieved accelerations as output (see Figure 3.7). The achieved accelerations are 
based on the characteristics of the autopilot and other missile subsystems. 

6. Target 

The target model represents a simple maneuvering target. Inputs are 
positional, heading, velocity, and type of maneuver initial conditions. Inertial data 
are derived from this data and output to the missile-target geometry model. More 
sophisticated target models might include multiple targets and targets capable of 
complex maneuvers. 


23 






7. The Atmosphere 

The Earth's atmosphere is a dynamically changing system, within which the 
missile must operate. The pressure, density and temperature of the atmosphere 
depend on altitude, location on the globe, the time of day and the season. In order 
to have a common reference atmosphere, a standard atmosphere has been defined 
by the U.S. Air Force [Ref. 9]. The standard atmosphere gives mean values of 
pressure, density, and temperature as a function of altitude. Most missile flight 
simulations model the standard atmosphere. 


C. SUMMARY 

The models described above become the Ada objects in the object oriented 
approach. The relations between the models are represented by messages between 
the objects. These messages can request actions of objects or be in response to 


24 





message requests for action. Objects may be constructed from other objects. A 
missile composed of objects that represent subsystems for example. This approach 
results in a simulation that accurately maps the problem space to software, as the 
next chapter illustrates. 


25 






CHAPTER IV. THE USERS VIEW OF THE SIMULATION 


A. INTRODUCTION 

This chapter briefly discusses general simulation principles, and contains a basic 
user-level overview of the simulation. The brief discussion of simulation principles 
is intended to provide a rudimentary understanding and insight into some aspects of 
the simulation's implementation and operation. The user-level overview of the 
missile flight simulation operation provides basic concepts that will aid in 
understanding the missile, launcher, and targets objects presented in Chapter VI. 

This missile flight simulation falls under the category of nonlinear continuous 
dynamic systems [Ref. 10]. Other simulations or applications in this category include 
simulations of spring-damper systems, automotive drive trains, power plants, and 
chemical processing plants. In keeping with the principle of abstraction, the top-level 
of the simulation is generic in the sense that it is not designed for a specific 
simulation, it is application independent. The application could be any of the 
previously mentioned simulations. The principle common to all these simulations is 
that the application specific models (e.g., a power plant or a missile) produce a set 
variables that represent the "state" of the model. Typically the state variables are 
time-dependent variables that represent rates, such as flow rates in a power plant or 
accelerations in a missile. The specific application models the system of interest over 
a period of time. This might be hours or days for a power plant, or seconds or 


26 






minutes for a missile. The time periods are divided into discrete units of time called 
time steps. A time step for a power plant might be an hour, while a missile's time 
step might be a tenth of a second. The state variables are computed once each time 
step by the models. These state variables are then mathematically integrated each 
time step using numerical integration methods [Ref. 11]. The integrated variables 
are then fed-back to the models where they are used, along with other equations 
representing characteristics of the model, to compute the state variables for the next 
time step [Ref. 12]. 


B. SIMULATION OPERATION 

The simulation is a 3 Degree-of-Freedom (3-DOF) simulation representing 
translational motion in three dimensional space. The missile is a dual mode, guided 
air-to-air missile. Dual mode indicates that the missile utilizes both radar and 
infraied sensors (also known as seekers) to guide to or track the target. The missile 
is carried on a launch aircraft and is launched at the target. The function of the 
missile is to guide to and intercept one of the two targets. The targets may fly a 
constant nonmaneuvering flight path or the user may enable target maneuvering. 
The targets are capable of both turn and weave maneuvers. In addition to the two 
targets, it is possible to have two other targets active which act as stand off jammers 
(SOJs). The role of the SOJs is to use electronic counter measures (ECM) to 
degrade or confuse the missile's radar to prevent the missile from guiding on the 
target. 


27 




An inertial coordinate system is used to describe the launch aircraft, missile, 
target and SOJ positions in three dimensional space. This is a north, east, down 
coordinate system (north, east, down) that is referenced to the missile's position at 
launch (i.e., ( 0, 0, -launch aircraft altitude)). An object's position and velocity in 
inertial space are described by its state vector. In addition to the inertial coordinate 
system, the missile uses the missile body coordinate system and the seeker coordinate 
system. The missile body coordinate system is referenced to the airframe or body 
of the missile and is used to compute forces acting on the missile. The seeker 
coordinate system is referenced to the missile's seeker and is used to describe where 
the seeker is pointing with respect to the missile body and the other objects in 
inertial space. 

Sample planar views of a typical launch profile are provided in Figure 4.1, a top 
view, and Figure 4.2, a side view. All the parameters required to establish a default 
launch profile are read from a data file when the simulation is first brought up. The 
user enters SIM at the DOS prompt to bring up the simulation. An introduction 
screen is displayed, and any key stroke will then display the Simulation Main Menu 
(see Figure 4.3). 

This menu's choices are; File Operations Menu, Launch Aircraft Parameter Menu, 
Target Parameter Menu, Start Simulation or Quit Program. The File Operations 
Menu, shown in Figure 4.4, permits the loading and saving of data files that establish 
the simulation's initial conditions. This menu also has a selection that allows the 
data generated by the simulation to be logged to a file and the selection of the log 


28 






Figure 4.2 North>Down Planar View 


29 










30 


Figure 4.3 Simulation Main Menu 










31 


Figure 4.4 File Operations Menu 








interval. The user may then modify the launch profile by interactively changing the 
launch aircraft, missile, target, or SOJ parameters. The user does this from their 
individual menus. 

1. Launch Aircraft and Missile Parameters 

Launch aircraft parameters that may be modified interactively from the Launch 
Aircraft Parameter Menu (Figure 4.5) are aircraft type, launcher type, altitude, 
velocity, heading angle and guidance mode. The launch aircraft's altitude, velocity 
and heading angle become initial conditions for the missile. The aircraft type, which 
can be F-14, F-15, or F-18, establishes radar characteristics that will determine when 
the missile's radar acquires the target. Launcher type specifies whether the missile 
is launched off a rail station of the launch aircraft or whether the missile is ejected 
off an ordnance station of the launch aircraft. The guidance modes available to the 
launch aircraft are the pursuit mode, in which case the launch aircraft maneuvers 
towards the target after launch or the nonmaneuvering mode, in which case the 
launch aircraft continues on its original flight path after missile launch. 

2. Target Parameters 

It is assumed that there is always at least one target. The user must enable the 
second target to simulate a two target formation. The target parameters that may 
be modified fi'om the Target Parameter Menu (Figure 4.6) can be divided into three 
categories: general, maneuver, and ECM. The general parameters are altitude, 
velocity, aspect angle, slant range, radar cross section (RCS), and infrared (IR) 


32 






33 


Figure 4.5 Launch Aircraft Parameter Menu 








o o o o o 

O »£> O O O XI 

d o o d csi 3 

K> GO — 


3 z 
uj o 


o n o 
P t- P 

04 X O 
to *- 


o o o o 
o o o o 
d — d d 

— — 04 


cn .. 

O) — •*-' 

TO Z ^ 
. 2 £ 


(_) ^ 
a> 

0> 


ir 



o 

TO 

O) 

c 

CT> 

t_ 

TO 

U 



TO 

Q. 

cn 

ex 

<u 

E 

TO 


Z} 

O" 

CO 



4-> 

oT 

z? 

z> 

*0 

TO 


■*-> 

L- 

fn 


a> 


L- 



rj 

TO 

CJ 

1 1 


■O 

Q. 

6S 

TO 

lo 


■»-> 

CD 

CD 

/— 


CO 

>- 


4-» 

> 


4-> 

<D 

Q. 

a. 

(O 

03 

to 

u 

cc 

4-> 

u 

o> 

tn 

i_ 

4-> 

_Q 

L- 

TO 

cn 

TO 

cn 

CE 


CD 

<i> 

CD 

CO 

O) 


■t-' 

j-» 

4-> 

4-> 


> 

> 

> 

4-> 

> 

<u 

CD 

CD 

<u 

CD 

<l> 

ZD 


r? 

(/) 


co> 

o> 

CO> 

o> 

CD 

o> 

CD 

Cl> 

CD 


0.) 

(_ 

t_ 

(_ 


L. 

c_ 

c 

c 

C 

c 

d 

TO 

TO 

TO 


TO 

CO 

TO 

CO 

TO 

CO 

CO 

t— 

(— 

1— 

K“ 

1— 

1— 

n 


21 

t: 

n 


a> <1^ £= 

2 21 CL 5 
^ o (X o 
^ LU UJ X 



34 


Figure 4.6 Target Parameter Menu 







radiance. Aspect angle is the angle defined counter-clockwise from the target's tail 
to the missile's line-of-sight (LOS). Hence, an aspect angle of zero degrees is a tail 
shot (i.e., the target and launch aircraft have the same heading, with the launch 
aircraft following the target), and an aspect angle of 180 degrees is a head shot (i.e., 
the target and missile flying directly at one another). The LOS vector is the vector 
from the missile's seeker to the target. The slant range is the three dimensional 
range from the target to the missile. The missile may use its own radar or infrared 
sensors to provide target information. RCS is a parameter that indicates the targets 
size in terms of how much radar energy is reflected off the target. A target with a 
large RCS will be acquired by the missile's radar in a shorter period of time (or 
similarly acquired at a longer range) than a target with a small RCS. IR radiance 
is the infrared spectrum's counterpart to RCS, except the IR energy is emitted from 
the target's engine exhaust (and other IR "hot" spots), rather than being energy 
reflected off it. The target maneuver parameters control the target's flight path. 

The target can be either a nonmaneuvering target, a turning target, or a weaving 
target depending on the parameter maneuver type. Parameters associated with both 
the turning target and weaving target are maneuver g's, buildup time, and the 
maneuver start parameter. Target g's are the number of g's the target is going to 
achieve executing the maneuver, and build up time is the time it takes to achieve the 
commanded g's. The maneuver start parameter selects what condition initiates the 
maneuver. The user can select whether the maneuver starts on flight time (time 
since the start of the simulation), time remaining (estimated time to intercept), or 


35 







range-to-go (missile-to-target range). Specific to turn maneuver is the parameter 
angle to turn through, which is simply how many degrees the target is to turn through 
before the turn is terminated and the target resumes straight and level flight. A 
weaving targets flight path resembles a sinusoidal wave form in the north-east plane. 
That is, looking down on the target, its flight path would resemble a sine wave. The 
weave specific parameter weave period determines the time (in seconds) it takes the 
target to complete one cycle or period of the weave. If target two is enabled, the 
user may define the second targets altitude, the second target's range to target one 
and the second target's echelon angle (see Figure 4.7). 

3. SOJ and Target ECM Parameters 

The user also has the option to enable the SOJs and set their range from the 
launch aircraft, look angle to the target (the angle between the launch aircraft's LOS 
to the target and the LOS to the SOJ, see Figure 4.8), and modify their ECM 
parameters (see Figure 4.9). The ECM parameter associated with both targets is 
ECM technique. The ECM techniques available are none, repeater, and barrage 
noise. Associated with the repeater ECM technique is the parameter loop gain and 
associated with the barrage noise ECM technique is the parameter effective radiated 
power density (ERPD). The repeater technique is intended to deceive the missile 
by receiving the missile's radar signal, altering it, and retransmitting it back to the 
missile. The intent is to make the missile "see" the target at a different range or 
vei'-Hty than the target's actual range or velocity. The user may modify the loop 
gain, effectively controlling the power of the repeater. The barrage noise technique 


36 







Figure 4.7 Multiple Targets 



Figure 4.8 SOJ Look Angle 


37 











38 


Figure 4.9 SOJ Parameter Menu 









is a cruder technique in which the target transmits broad band noise in an attempt 
to over-power the missile's radar receiver and deny it any target information. The 
user may modify the ERPD of the barrage noise. Similar ECM options are available 
for the SOJs if they are enabled. Basically the ECM is a function of the technique 
used and the geometry in which the ECM platform (i.e., either target or SOJ) 
encounters the missile. In all cases just minimal or skeleton code is implemented for 
ECM due to security classification issues and developmental time constraints. The 
ECM area falls under the future work category discussed in the last chapter. 

To start the simulation, the user selects Start Simulation Run from the main 
menu. The run-time display is then shown indicating key geometric and kinematic 
parameters (see Figure 4.10). The user may halt or abort the simulation while it is 
running Halting the simulation permits careful examination of parameters during 
a run, while terminating the simulation allows a quick turn around if the user is not 
satisfied with the run (e.g., initial conditions set incorrectly). At the end of a 
simulation run the terminal condition display is shown, which is the runtime display 
with the final parameter values and the reason for termination (see Figure 4.11). 


39 






40 


Figure 4.10 Simulation Runtime Display 





















= NPS Simulation Runtime Display — —= 

Elapsed Time, sec 11.35 Ms I Mach 2.12 

Flight Time, sec : 21.67 Msl Velocity, ft/sec 2156.6 


O' O' o 00 o 
in 1 ^ P S o 
o S o 
o ro <N 


(n 

<1> 

^ a> CD ^ 

<1) TO c c ^ 

■O CC < TO 


< < CL Q. O O 
v) Tn V) oi To 7n 

z z: z: z z z 


0^ O GO 
h- O <N 

o in 
— o <N 
d d o 


01 01 O) 

CT> Ol 0> 


a> a> <i> 
o o o 
(J o o 
< < < 
01 O) 01 

XXX 
< < < 
X >- D4 

01 "oi 01 
Z Z Z 


o \r o o o o 


O CNJ 


in o o 
o 00 
^ o — 
ho o 

I CM 


— a> \ 

Z CD 

Z c ^ 

CC I a> 3 .b 

-^Z, cr> 

o c x: TO 

TO — a> 

*7 ^ Z cc < X 

— 3 *-> 4-> +-> *-> 

}£> TO 01 CD 0> 0> 

Z —I I— I— I— h— 


w in (N 

clC^ M" 

d 00 


X o O' o m 

^ ^ o 00 o m 

^ d CM P 

■0^1 0-7 

TO I— 7* 

rr\ * . » 


S' ^ ^ 

^ ^ ^ s 

^ <u oT ^ S' 

E o S'? ^ 

n Z < < oT 


4> ^ 

<u <u 
a> <1^ 


•E E 

^ r\ 


cn ^ o ; o -I 




.— 
< LjJ 


< UJ 


01 01 01 01 01 01 
Z Z Z Z Z Z 


— o o 
TO o in 

C O CM 
P O CM 

E d d 


o E S 

Z o 5 
<1^ X — 

i s s 

“^ < 
I? DJ _ 
O < UJ 

oi 01 7/i 
Z Z Z 


Z7 01 
Q. ^ 
O C. 
L_ JT 
CL I— 

To To 

z z 


o o o 
O o o 
d d d 

O I 

ho 


CD 

<L> Ol 

"o ai 
^ "O 

o a> 

TO — 
in ^ 

in {- 

a < < 

- P CL 

o — 


oJ c 
^ 

01 To To 

z z z 


41 


Figure 4.11 Simulation Termination Display 





















V. THE CONTROL AND SUPPORT OBJECTS 

A. INTRODUCTION 

This chapter presents three of the top-level objects that control the simulation and 
their support objects (see Figure A.1 of Appendix A). The discussion of the top-level 
objects will follow the basic development methodology presented earlier and 
illustrates how the objects demonstrate important features of object oriented 
principles and software engineering principles. This discussion is not intended to be 
a line by line detailed functional description of the code, but is intended to provide 
a basic understanding of how the simulation works (the reader is referred to 
Appendix C and >^pendix D for a complete listing of the simulation). 

B. BASIC METHODOLOGY 

Objects and their messages will appear in capitol letters by convention through 
the remainder of this document The methodology presented in Chapter II will be 
used to develop the three top-level objects presented in this chapter. These top-level 
objects, and their support objects, will be discussed here to provide a framework for 
presenting the MISSILE and TARGET objects in the next chapter. 

At this the highest level of abstraction, we wish to keep the simulation application 
independent. We might wish to simulate a power plant or missile - our upper most 
level should not reflect what particular application we are using. Objects are 


42 









necessary to control or manage the simulation. By controlling or managing the 
simulation we mean things like getting user input, initialization, starting and stopping 
the simulation, and presenting data. The objects necessary for these operations are 
identified as the EXECUTIVE, APPLICATION, and USER_INTERFACE. The 
EXECUTIVE has no knowledge of what type of simulation is running, it just sees 
the APPLICATION and USER_IN 1 ERFACE objects and stimulates them with the 
appropriate messages. The APPLICATION object has the knowledge of the specific 
details of the application in terms of what objects exist and their interfaces. The 
USER_INTERFACE object is required for user input and output. The 
APPLICATION will have to be visible to the USER_INTERFACE and the 
USER^INTERFACE must be visible to the APPLICATION. The reasons for this 
will become clear when we examine each object's interface or messages. So far we 
have identified the objects, formed a general characterization of their behavior and 
established their visibility. The next steps of the development methodology, defining 
the interfaces and implementing the objects, will be discussed in more detail in the 
following sections. 

C. OBJECT MESSAGES AND IMPLEMENTATION 

Each object's messages are presented in more detail because they are key to 
understanding an object's capabilities. The Ada with clause allows a package (or 
object) to access or view another package's specification. Package specifications 
define the interface to the package in terms of data structures, function calls and 


43 





procedure calls available to the users of the package. In our object oriented view, 
package specifications define the external messages that an object can respond to by 
eliciting some type of action or providing the sender with information. Internal 
messages are the functions and procedures that are in the body and not in the 
package specification, and therefor are for the exclusive use of that object. Appendbc 
A provides figures that illustrate the objects indicating which objects they "with" and 
their messages. 

D. THE CONTROL OBJECTS 

1. The EXECUTIVE 

The simulation EXECUTIVE is a procedure that forms the upper or outer¬ 
most layer of the simulation (Figure A.2). This is highest level of abstraction for the 
simulation. The simulation EXECUTIVE contains a context clause that "withes" the 
APPUCATION object and the USERJNTERFACE object. The EXECUTIVE 
sends a message to APPLICATION to initialize the system and a message to the 
USER^INTERFACE to turn over control of the simulation to the user. 

2. The APPLICATION 

The APPLICATION also resides at the simulation's highest level of 
abstraction. The APPLICATION object contains or defines the application specific 
messages or actions for a specific simulation. The APPLICATION might represent 
one of any number of simulations. The APPLICATION object has the following 
messages as shown in Figure A.3: INITIALIZE_SYSTEM, 


44 





INITIALIZE_SIMULATION, NUMBEROFSTATEVARIABLES, 
GET STATES, PUT STATES, COMPUTE DERIVATTVES, LOG_DATA, 
END CONDITION MET, END OF RUN, CHECK PAUSE, and 
SIMULATION_MAIN. The internal INITIALIZE SYSTEM message sends a 
message to the SYSTEM_SPECIFIC object to initialize the video display and sends 
a message to the USER_1NTERFACE to display the initial title screen to the user. 
INrnALIZE_SIMULATION ,an internal message, signals the objects that make up 
the specific application to initialize themselves. This message also frees memory by 
instantiating Ada's UNCHECKED_DEALLC)CATION to create a procedure called 
FREE. FREE deallocates memory that was used for storing the previous runs data. 
INITIALIZE^SIMULATION will also create an output data file if the simulation is 
logging data to disk. The external COMPUTE_DERIVATIVES message is invoked 
which in turn sends COMPUTE messages to the MISSILE and TARGET objects 
telling them to compute the mathematical derivatives that characterize them. These 
are used as initial values for computing the state variables in the first time step. An 
example of sending or invoking the INniAIJZE_S YSTEM from another object (e.g., 
as is done in the body of EXECUTIVE for this particular message) is as follows: 


APPLICA'nON.INlTIALIZE SYSTEM 


45 





When this statement is encountered in the body of EXECUTIVE the 
INrnALIZE_SYSTEM message or procedure defined in APPLICATION will be 
executed. The messages are intended to be self-descriptive. 

GET DERIVATIVES is an external message that provides the values of the 
MISSILE and TARGET derivatives by sending a GET DERIVATIVES messages 
to these objects. The external NUMBER_OF_STATE_VARIABLES message 
returns the number of state variables possessed by a specific application. This 
message is used to correctly size the data structures in the INTEGRATION object. 
The external message GET_STATES solicits the appropriate objects for their state 
variables while PUT STATES provides those objects with updated state variables. 

The internal LOG_DATA message tells the simulation to output data to the 
screen and, if desired, save data to a disk file. The internal CHECK_PAUSE 
message checks to see if the user has paused the simulation run or has decided to 
terminate the run. The internal END_CONDrnON_MET message signals that the 
appropriate conditions have been satisfied and the simulation can be terminated. 

The external message SIMULATION_MAIN is the heart of the 
APPLICATION object. The first action SIMULATION_MAIN takes is to set the 
Boolean variable LOGGING_TO_DISK according to the value found in 
SETUP VALUES. If LOGGING_TO_DISK is true, data generated by the 
simulation will be written to a file on disk. SIMULATION_MAIN then tells the 
objects to set themselves up by sending a SETUP message to the missile and aircraft 
objects. There is a distinction in the simulation between setup and initialize. Setup 


46 







refers to collecting data, either interactively from the user or from default values, 
while initialize refers to using these values to compute initial conditions or initialize 
data structures. After the MISSILE and TARGET have been setup, a message is 
passed to the ENVIRONMENT object to set the time to zero. This is the reference 
time at which the simulation starts. Following this a message is sent to the 
INTEGRATION object establishing the TIME_STEP_SIZE to be used for the 
numeric integration. The NEXT_LOGGING_FRAME and FRAME_NUMBER are 
then set to initial values. Then the simulation is initialized followed by the 
INTEGRATION object. At this point the main loop is entered. This body of code 
will be repeatedly executed until the simulation stops, either by reaching normal end 
conditions or through user intervention. Within the loop the INTEGRATION object 
is told to ADVANCE_TIME. This is the message that drives the computation of 
state variables and hence most of the computations or activity taking place in the 
simulation.' Also within the loop, the screen is updated and data logged to disk if 
required. The loop is repeatedly executed until END_CONDrnON_MET is true. 
END_CONDrnON_MET sends a message to the MISSILE to see if the MISSILE 
specific END_CONDrnON_MET is true (e.g., TARGET intercept has occurred, the 
MISSILE has flown into the ground, etc.) or checks to see if the user has terminated 
the run. Once END_CONDrnON_MET is true, the run-time screen is updated for 
the last time and the internal SHOW_TERMINAL_CONDrnONS message displays 
the terminal conditions of the flight to the user. Finally, the internal END_OF_RUN 
message is invoked to close the output data hie if the simulation was logging data to 


47 









disk. The user then can return to the main menu. At this point the simulation may 
be run again or parameters may be modified. 


3. The USER INTERFACE 

The USER_INTERFACE object, shown in Figure A.4, allows the user to the 
user to control the simulation through keyboard input, along with presenting run-time 
displays and simulation status information to the user. The USER_INTERFACE is 
designed as a standard interface regardless of what model computer hosts the 
simulation. USER_INTERFACE is menu driven to provide a more 
"user/programmer friendly" interface than previous FORTRAN simulations. 
USER_INTERFACE uses some of Ada's modem language features that are not 
found in FORTRAN. For example, access types (pointers) and records are used to 
form linked lists. The linked lists that form the menus, submenus, and individual 
items are quite easily modified to accommodate growth (i.e., more menus ,submenus, 
or items). Recursion is used to traverse the lists. Recursion makes the code easier 
to read and understand. Ada's variant records simplified the design and building of 
the linked lists. 

The MATH, APPLICATION and SYSTEM_SPECIFIC objects are made 
visible to USER_INTERFACE by with clauses. USER_INTERFACE also "withes" 
the Ada predefined packages TEXT_IO and REAL_IO. USER_INTERFACE 
provides the following external messages to its users; MAIN, 
SHOW TITLE SCREEN, DRAW RUNTIME BORDER, and 


48 







SETUP_RUNnME_SCREEN. The MAIN message passes an access type to the 
MAIN_MENU as a parameter to the internal MANAGE_MENU object, the heart 
of USER_INTERFACE. MANAGE_MENU navigates through the various menus, 
submenus, and individual items. MANAGE_MENU allows the user to interactively 
enter or modify data. The menus allow the user to build a "missile launch scenario" 
by entering or selecting missile and target parameters. The user may enter a value 
for the missile’s launch altitude by typing it at the keyboard, for example. Where 
data takes the form of an enumerated type, for example the launcher type is either 
F-14, F-15, or F-18, the user can cycle through the choices by striking the enter key. 
This is implemented by using the FRED (for predecessor) or SUCC (for successor) 
attributes of enumerated types. 

The user can initiate three actions from USER_INTERFACE: 
IjOAD_DATA_FILE, save data file, or START_RUN. LOAD_DATA_FILE 
provides the missile launch scenario parameters from a disk file. 
SAVE_DATA_FILE will save the current missile launch scenario, possibly 
customized by the user, to a disk file for later use. The intent here is to enable the 
quick setup of missile launch scenarios that vary from the default scenario. 
START_RUN will gather all the missile/target parameters from the various menus. 
These values become the appropriate object's setup values. At this point 
START_RUN sends a message to APPLICATION (i.e., 
APPLICATION.MAIN(SETUP_VALUES)) that starts the simulation. 


49 









The SHOW_TrrLE_SCREEN external message clears the user’s screen, turns 
off the cursor and displays the initial welcome text. DRAW_RUNnME_BORDER 
draws the screen border for the runtime screen and displays a text instruction. The 
message SETUP_RUNTIME_SCREEN clears the screen and signals 
DRAW_RUNTIME_BORDER. Then DRAW_RUNTIME_SCREEN displays a 
template of the text portion of the simulation data, with the appropriate imits, that 
is presented during runtime. For example, "Elapsed time, sec:" is displayed. The 
actual run-time data values are displayed from the APPLICATION object. 

Other important internal messages are: DISPLAY_MENU, 

SETUP_MENU_DATA, GET TEXT, and GET REAL. DISPLAY MENU is a 
message that displays the individual items in a menu or submenu. This message uses 
the SYSTEM_SPECIFIC object, which will be discussed shortly, for low-level 10. 
SETUP_MENU_DATA establishes all the default values for the MISSILE and 
TARGET parameters found in the menus. GET_TEXT is used to display a prompt 
for text input and then input and validate the user's response. GET TEXT also uses 
the SYSTEM_SPECIFIC object for much of its low-level lO. GET_REAL is used 
to read real values input by the user. This message provides a more flexible and 
user-friendly me^od for inputting real numbers than Ada’s predefined REAL_IO 
package. SETUP_MENU_DATA, SHOWTITLESCREEN, and 
SETUP_RUNTIME_SCREEN are implemented as separate compilation subunits of 
the main USER_INTERFACE package. This division was made because these units 
contain mostly textual information that tended to clutter and obscure the main 


50 





USER_INTERFACE package. Also, modifications are easier and compilations are 
faster when these messages are implemented as subunits of the USER_INTERFACE 
package. Editing is easier with smaller modules and the corresponding compilation 
faster. 

E. THE SUPPORT OBJECTS 
1. SYSTEM_SPECIFIC 

Modular design and information hiding allow the simulation to be machine 
independent. The simulation was developed and implemented on an IBM AT 
compatible machine. In the future the simulation will be modified to run on an 
Apple Macintosh computer and possibly other systems. To aid this process, all the 
machine dependent code is implemented (hidden) in the SYSTEM__SPECIF1C object 
(see Figure AS). Most of this code is associated with the IBM video display. By 
rewriting SYSTEM_SPECIFIC for the Apple Macintosh, and keeping the original 
message names, the porting process should consist simply of a recompile of 
SYSTEM SPECIFIC and a link of the simulation. Also by working at a lower 
system-specific level all screen displays are output in the most efficient manner 
providing very fast screen updates. This prevents the user from perceiving a delay 
as the screen is updated or the next menu is displayed (problems experienced in 
earlier FORTRAN simulations). 


51 






SYSTEM_SPECinC is visible to APPUCATION and USER INTERFACE. A 
number of packages providing DOS environmental support are included with 
Meridian's Ada compiler [Ref. 13]. These include: SYSTEM, 

PROGRAM CONTROL, INTERRUPT, COMMON DISPLAY TYPES, TTY and 
BOX. The SYSTEM package is used to provide an address expression which is a 32 
bit segmented memory address. The address expressions are used for monochrome 
and color video addresses. The PROGRAM_CONTROL package is used to 
terminate the simulation. PROGRAM_CONTROL's QUIT procedure terminates 
the calling program and returns control to DOS. The package INTERRUPT allows 
calls to DOS interrupt vectors. COMMON_DISPLAY_TYPES contains declarations 
for the various packages that handle display operations, such as TTY and BOX. The 
package TTY provides operations on the terminal display and keyboard. TTY links 
in faster than TEXT_IO and calls to the TTY subprograms run faster. The TTY 
subprograms used are GET, PUT, and CHAR_READY. CHAR_READY 
determines if a character is ready to be read from the keyboard. Package BOX 
provides procedures for drawing boxes on the text screen. Also, a Meridian supplied 
package, BrT_OPS, is used for bit-level logical operations [Ref. 14]. 

All of these vendor supplied packages are used in the SYSTEM SPECIFIC 
to provide the following external messages: INn'_VIDEO, DRAW_BOX, 
CLEARSCREEN, REVERSEVIDEOON, REVERSE_VIDEO_OFF, 
MOVE_CURSOR,TURN_CURSOR ON,TURN_CURSOR_OFF,PUT STRING, 
PUTREAL, INPUTSTRING, KEYAVAILABLE, GETKEY, 


52 










GET_MENU_COMMAND. INIT_VIDEO determines whether the host system has 
a monochrome or EGA display and sets variables accordingly. DRAW_BOX is used 
to draw the screen border. CLEAR_SCREEN clears the video display. 
REVERSE_VIDEO_ON and REVERSE_VIDEO_OFF control whether text is 
output in reverse video. MOVE_CURSOR moves the cursor to the desired row and 
column of the video display. TURN_CURSOR_ON and TURN_CURSOR_OFF 
control whether the cursor is displayed. PIJT_STRING outputs a character string to 
the video display in normal or reverse video. PUT_REAL outputs a real number to 
the screen. INPUT_STRING inputs text strings from the user. KEY_AVAILABLE 
indicates if a keyboard key has been pressed and GET_KEY returns the scan code 
of the key pressed. GET MENU COMMAND uses KEY AVAILABLE and 
GET_KEY to decode the keyboard input into UP_ARROW, DOWN ARROW and 
ENTER commands. The implementation details involve advanced DOS 
programming and the reader is referred to Young [Ref. 15] for further information. 

2. INTEGRATION 

The INTEGRATION (see Figure A.6) object performs the numerical 
integration of the MISSILE and TARGET state variables. INTEGRATION is visible 
to the APPLICATION object. Objects visible to INTEGRATION are MATH, 
ENVIRONMENT, and APPLICATION. The integration of the state variables each 
time step drives the MISSILE and TARGET in the simulation. Each TIME_STEP 
time units, the state variables are integrated and fed back to the appropriate objects 
and, along with other computations, are used to form the subsequent TIME_STEPs 


53 






state variables. For example, INTEGRATE requests the MISSILE'S derivatives, 
which are the MISSILE'S accelerations and velocities. These accelerations and 
velocities are computed by the MISSILE using the previous TIME_STEPs state 
variables (along with other computations). INTEGRATION then integrates the 
MISSILE'S accelerations and velocities to obtain the MISSILE'S velocities and 
position, which form the MISSILE'S current state variables. These state variables are 
then provided to the MISSILE for use during the next TIME_STEP, time is 
advanced TIME_STEP units, and the whole process is repeated. 

The external messages that make all this possible are TIME_STEP_SIZE, 
SET_TIME_STEP_SIZE, INITIALIZE, and ADVANCE_TIME. These messages 
form a standard interface regardless of the specific application. TIME_STEP_SIZE 
provides the sender with the current value INTEGRATION is using for 
TIME STEP. SET TIME STEP SIZE permits INTEGRATION'S TIME STEP 
value to be changed. INITIALIZE requests that APPLICATION return the 
application specific object's derivatives and state variables. These values are used 
as initial conditions by INTEGRATION. ADVANCE_TIME is the heart of 
INTEGRATION, as it signals the correct integration method to execute. There are 
numerous methods to perform numeric integration, for example, Hanna, Euler, 
Adams-Bashforth, to name just a few. These methods offer trade offs in terms of 
accuracy and execution speed. By having the method visible only to 
ADVANCE_TIME, changing the particular method used is relatively easy. At this 
time only the Hanna method is implemented [Ref. 16]. The Hanna method is a 


54 









predictor/corrector numeric integration technique. A temporary state or predictor, 
which is the previous TIME_STEPs state variables, multiplied by its derivatives and 
TIME_STEP, is computed. Next the ENVIRONMENT object, which keeps track of 
time, is signalled to increment the current time by TIME_STEP units by the 
SET_TIME message. Then INTEGRATION sends MISSILE and TARGET their 
temporary state variables via a message to APPLICATION. INTEGRATION then 
signals MISSILE and TARGET to compute their derivatives via another message to 
APPLICATION. MISSILE and TARGET use their temporary state variables to 
compute their current derivatives. INTEGRATION then requests these derivatives 
to correct the state variables. Finally the current set of derivatives is saved for the 
next TIME^STEP. This process is repeated each time INTEGRATION is sent the 
ADVANCE^TIME message by APPLICATION until APPLICATION stops the 
simulation. 

3. MATH 

The MATH object, shown in Figure A.7, provides external messages that 
perform all the basic mathematical operations required by the simulation. MATH 
also defines all the physical constants used in the simulation, such as PI, E, and the 
gravitational constant G. MATH is visible to most of the upper-level objects. 
MATH withes Meridian's MATH_IJB to provide trigonometric functions such as 
SIN, COS, TAN and their inverses. All these functions have been embedded in 
functions that perform a type conversion of the operands to the real type, as the 
Meridian MATH_LIB is instantiated for the float type. MATH instantiates the real 


55 








types. Operations, in addition to those provided by MATH_LIB, include LOG, 
LIMIT, • *, MIN, MAX and a variety of matrix and vector operations. LOG provides 
the base 10 logarithm of a number. The overloaded LIMIT compares a real variable 
against a lower and upper limit, and returns either the upper limit if the variable is 
greater than it, the lower limit if the variable is less than it, or the variable, if it falls 
between the two limits. The other LIMIT compares a real variable with the positive 
and negative values of a single limit and returns the appropriate value. The ** 
message provides exponentiation. MIN returns the minimum of two variables while 
MAX returns the maximum of two variables. MATH also instantiates 
REAL_MATRIX from the generic unit MATRIX_AND_VECTOR to provide 
mathematical operations on matrices and vectors. 

4. REAL MATRIX 

REAL_MATRIX (see Figure A-7) is an instantiation of the generic unit 
MATRIX_AND_VECrOR and illustrates Ada's limited implementation of the object 
oriented inheritance concept. MATRIX_AND_VECTOR is a generic unit that acts 
as a template for packages and provides the means to build reusable software 
components. MATRIX_AND_VECTOR provides all the basic mathematical 
operations for matrices and vectors without specifying what data type make up these 
structures. REAL_MATRIX is the MATRIX_AND_VECTOR object instantiated 
for the real data type. Future requirements may call for the instantiation of 
MATRIX_AND_VECTOR for complex numbers. 


56 







REAL_MATRIX provides a number of messages for operations on matrices 
and vectors because many of the quantities encountered in the simulation, such as 
forces, are best expressed in terms of vectors or arrays. REAL_MATRIX defines the 
vector type as a one dimensional array of real numbers and the matrix type as a two 
dimensional array of real numbers. The basic operations on matrices are overloaded 
to deal with both single and two dimensional matrices. Ada’s attributes for array 
types were very useful in coding these operations. The RANGE attribute provided 
an easy and flexible method for specifying array index constraints. The LAST 
attribute proved valuable for specifying the upper bound on the control variable of 
for loops. The overloaded * and /, provide for the addition, subtraction, 
multiplication and division of arrays respectively. These messages also contribute to 
the readability of the code. MAGNITUDE returns the magnitude of a vector and 
CROSS_PRODUCr provides the cross product of two vectors. The matrix messages 
TRANSPOSE, IDENTITY, DETERMINANT, and INVERSE provide the services 
that their names suggest [Ref. 17]. 


57 





VI. THE MISSILE, LAUNCHER AND TARGETS OBJECTS 


A. INTRODUCTION 

This chapter discusses the missile, laimcher, and target objects. One of our major 
software engineering goals, understandability, is achieved by implementing and 
discussing the core of the simulation in terms of modular objects. This approach also 
serves to accurately map the real-world problem space (see Figure 3.1) into the 
objects that form the software solution, illustrated in Figure B.l of y^pendix B. 


B. THE MISSILE 

The MISSILE object or package withes the LAUNCHER, TARGETS, missile 
subsystem objects and support objects (see Figure B.2). The LAUNCHER object 
provides the missile with launch aircraft information and TARGETS provides target 
information. Missile subsystem objects are the AIRFRAME, AUTOPILOT, 
RF_SEEKER, IR_SEEKER, and GUIDANCE. The AIRFRAME contains further 
subsystems such as the AERO and THRUST. The missile subsystems serve as a good 
example of abstraction, modularity, low coupling and high cohesion. The support 
objects are MATH, INTEGRATION, KINEMATICS, and ENVIRONMENT. 
MISSILE uses the time keeping messages of ENVIRONMENT. 


58 











1. MISSILE Messages 

MISSILE messages include SETUP, INITIALIZE, PUT_STATES, 
GET STATES, GET DERIVATIVES, LOG DATA, MANEUVER_VALUE, 
END_CONDmONS_MET, TERMINAL CONDmONS, and COMPUTE. SETUP 
establishes the launch type, number of targets, number of SOJs and ECM power . 
SETUP also signals the RF_SEEKER and KINEMATIC objects to proceed with 
their SETUP routines. The INITIALIZE message establishes initial conditions for 
many of the missile's physical characteristics such as missile mass, drag, thrust, and 
initial phase of flight. Also during initialization geometric initial conditions such as 
ranges and heading angle are computed. AIRFRAME, GUIDANCE, RF SEEKER, 
and IR_SEEKER are also signaled to initialize. 

The message PUT_STATES accepts the new states (i.e, missile position and 
velocity) when signaled by the APPLICATION object. GET_STATES presents the 
caller with the current missile states and GET_DERIVATrVES presents the 
derivatives of the current states (i.e., missile velocity and acceleration). 

The LOG_DATA message provides all the missile data, approximately forty 
two items, that are logged to disk or presented on screen to the user. 
MANEUVER_START_VALUE returns the time since launch, time-to-go or range- 
to-go, which is used to initiate the target maneuver. END_CONDrnONS_MET 
provides a Boolean value indicating whether the appropriate conditions (e.g, target 
intercept, missile physical limits exceeded, out of energy, flew into the ground) have 
been met to terminate missile flight. TERMINAL_CONDrnONS supplies the 


59 





reason for flight termination plus terminal data items of interest such as miss 
distance (defined as the point of closest approach), time of flight and missile altitude. 
These are key items for evaluating missile performance. They are displayed on the 
terminal display. 

2. Hie COMPUTE Message 

The COMPUTE message really drives MISSILE. The following sequence of 
events occurs every time MISSILE is sent the COMPUTE message. COMPUTE 
requests target velocity and position data. Then COMPUTE sends this information, 
along with missile position and velocity to KINEMATICS. KINEMATICS replies 
with missile-to-target range, LOS rate, range-rate and time-to-go. LAUNCHER is 
then signaled to provide the ran.i from the launch aircraft to the target. This 
information is then sent to the RF_SEEKER to determine which RF phase the 
missile is in and to determine the signal-to-noise ratio (SNR) of the signal the 
missile's radar receiver is receiving. COMPUTE then calculates A-pole, defined as 
the range fi-om the launch aircraft to the target when the missile's radar enters the 
K-band acquisition mode (RF phases and modes are discussed in the RF_SEEKER 
section). If the missile is within range to use its IR seeker, IR SEEKER is signaled 
to determine the.IR phase and whether or not the radome has been ejected. 

Next a series of computations and messages are executed resulting in the 
missile's current acceleration vector. First, COMPUTE gives KINEMATICS the 
missile's azimuth (az) and elevation (el) angles, and KINEMATICS returns the 
corresponding direction cosine matrix. Direction cosine matrices are used to 


60 






trarisform vectors between different coordinate systems [Ref. 18]. In this case 
KINEMATICS returns the inertial to body coordinate system direction cosine matrix 
(TIB matrix, for transform inertial to body). This matrix is then multiplied by the 
missile-to-target range vector (which is in inertial coordinates) resulting in a missile- 
to-target range vector in missile body coordinates. This operation is also carried out 
on the other range vectors (i.e., second target and SOJs) if appropriate. The range 
vector in missile body coordinates is then sent to RF_SEEKER, which returns the 
seeker gimbal angle in missile body coordinates. COMPUTE then calculates total 
seeker angles (Psi and Theta) by summing the az and el angles with the seeker 
gimbal angles. KINEMATICS is sent these angles to use in computing the direction 
cosine matrix for the inertial to seeker coordinate system transformations (TIS). 

The vector representing LOS rate in inertial coordinates is then transformed into 
seeker coordinates for use by GUIDANCE. COMPUTE also calculates missile 
altitude, and altitude rate which are used along with the LOS rate in seeker 
coordinates by GUIDANCE. GUIDANCE is sent these values, along with time-to- 
go and target position information and returns the guidance phase and commanded 
acceleration. Simply stated, given missile and target position and velocity 
information, GUIDANCE determines the required acceleration commands for the 
missile to intercept the target. COMPUTE then signals AUTOPILOT.COMPUTE 
with the commanded accelerations and receives back the achieved accelerations. 
KINEMATICS then, given the missile's altitude and velocity, returns the missile's 
mach number. COMPUTE signals THRUST with the missile's mach and altitude 


61 








and receives assorted information such as missile mass, propulsion phase, and thrust. 
The achieved accelerations provided by AUTOPILOT.COMPUTE, along with missile 
mach and altitude, are sent to AIRFRAME.AERO which returns the missile's 
coefficient of drag and angle of attack. These values, along with missile position, 
velocity, and acceleration, are sent to KINEMATICS (equations of motion) which 
returns updated missile velocity information, pitch and dynamic pressure (Q). Finally 
the achieved accelerations provided by AUTOPILOT.COMPUTE are transformed 
from body to inertial coordinates. At this point COMPUTE has completed updating 
the missile's state. 

C. KINEMATICS 

The KINEMATICS, shown in Figure B.3, object calculates direction cosine 
matrices, missile acceleration, velocity, position and flight path data. KINEMATICS 
has the following messages: SETUP, INITIALIZE, MACH NO, DIR COS, 
COMPUTE, and EOM. 

SETUP establishes the number of targets and the number of SOJs. INITIALIZE 
initializes ranges, range rates, and LOS rate. MACH_NO, given missile altitude and 
velocity, returns the missile's mach number. DIR COS, given two reference angles 
between two different coordinate systems, returns the corresponding direction cosine 
matrix. This matrix is then used to transform vectors from one coordinate system to 
the other [Ref. 18]. 


62 










The COMPUTE message calculates velocity, range, LOS rate and time-to-go. 
COMPUTE calculates missile-to-target velocity as the difference between target and 
missile velocity. The missile-to-target range vector is calculated as the difference 
between target position and missile position. Both a total range vector and unit 
range vector are also calculated. The range rate, defined as the rate of change of the 
missile-to-target range vector, is computed as the vector dot product of the range unit 
vector and the missile-to-target velocity vector. The LOS rate is then calculated as 
the vector cross product of the range unit vector and the missile-to-target velocity 
divided by total range. Range calculations are then performed for the SOJs if 
appropriate. Finally time-to-go, the estimated time to target intercept, is calculated. 
Time-to-go is computed, depending on various conditions, as either range to point 
of closest approach (miss distance) divided by range rate or target range divided by 
range rate. Care has to be taken to account for possible opening ranges immediately 
after missile launch , to avoid inaccurate miss distance calculations during initial 
flight phases, and to account for range rate becoming less than or equal to zero 
during the final phase of flight. 

KINEMATICS' equations-of-motion message, EOM, calculates the missile's axial 
acceleration vector, pitch and heading. First pitch and heading are determined 
through trigonometric relations of angle-of-attack and velocity. Then a message is 
sent to ENVIRONMENT to get the air density. The air density, along with missile 
velocity, is used to compute the dynamic pressure (Q). Missile drag is then 
computed as the product of dynamic pressure, the missile's coefficient of drag and 


63 









reference area (sref). Finally, the missile's axial acceleration vector is calculated and 
returned to the caller. This completes the description of KINEMATICS. 

D. THE AIRFRAME 

The AIRFRAME models the missile's aerodynamic characteristics and thrust 
characteristics. AIRFRAME'S messages are INITIALIZE, AERO, and THRUST as 
shown in Figure B.4. 

INITIALIZE initializes the propulsion phase, and various physical constants. The 
AERO message, given missile achieved acceleration, mach, altitude, dynamic 
pressure (Q), and the dome condition, returns the missile's coefficient of drag and 
angle-of-attack (AOA or Alpha). The AOA is the difference between the missile's 
velocity vector and its body vector. The drag coefficient is represented as a series 
of equations that are a function of missile mach. These equations represent a curve 
fit of data found through wind tunnel testing of the missile. In order for the missile's 
IR seeker to function, the radome, or dome, is ejected or blown off in the final phase 
of flight, increasing the drag coefficient. 

THRUST uses missile mach, altitude, fuel mass, and missile mass to provide the 
thrust force and propulsion phase. The missile is modeled as having a solid fuel 
rocket motor. The rocket motor is fired at launch for a rail launch, or shortly after 
ejection for an eject launch. The initial propulsion phase is termed the boost phase. 
After the fuel is exhausted the missile enters the coast propulsion phase. 


64 


E. THE AUTOPILOT 


AUTOPILOT accepts commanded accelerations and returns achieved accelerations 
dependent on the body responses of the missile. AUTOPILOTS messages are 
INITIAUZE, UPDATE DIFF EQS, COMPUTE, and ACCELERATIONS (see 
Figure B.5). INITIALIZE establishes initial values for autopilot constants. The 
autopilot has been modeled by differential equations which have been implemented 
as difference equations to avoid the instabilities caused by round-off error [Ref. 10]. 
UPDATE_DIFF_EQS updates the achieved accelerations through the difference 
equations. COMPUTE, given the commanded accelerations, returns the achieved 
accelerations, while ACCELERATIONS returns the instantaneous accelerations 
being experienced by the missile. AUTOPILOT serves as a good example of an 
object with a simple, well defined interface. This interface can be thought of as a 
standard interface in that, regardless of how the autopilot is modelled, this interface 
can remain unchanged. AUTOPILOT also serves as a good example of an object 
or a module that would be an excellent candidate to go into a library of missile 
subsystems. As production missiles mature, subsystems with new designs are 
incorporated. A library of various subsystems would allow the analyst to easily 
configure the simulation to match any production version of the missile. This would 
also permit the experimentation of new configurations with untested subsystem 
models. 


65 






F. GUIDANCE 


The function of GUIDANCE is to guide the missile to the target. GUIDANCE 
withes the MATH object. Figure B.6 indicates GUIDANCE'S messages are 
INTTIAUZE and COMPUTE. 

INITIALIZE, given missile altitude, target altitude, range, and velocity computes 
initial values for a number of guidance parameters. Guidance parameters such as 
guidance phase, horizontal target range, velocity, aspect angles and time estimates. 
COMPUTE, given time-to-go, missile altitude, altitude rate, velocity, axial 
acceleration, pitch,seeker gimbal angles, LOS rate, and target position and velocity, 
returns the guidance phase and acceleration commands. These commanded 
accelerations will guide the missile to intercept the target. 

There are five guidance modes or phases: null commands,load bias, variable arc, 
altitude hold, and terminal. Immediately following launch the missile is in the null 
commands phase. The purpose of this phase is to ensure that no guidance 
commands are generated until the missile is safely clear of the launch aircraft. The 
load bias phase commands a five g pull-up maneuver until the missile achieves a 20 
degree nose up attitude. The missile then enters the variable arc phase where it is 
commanded to climb to a predetermined altitude. Once reaching the predetermined 
altitude, the missile will remain at that altitude throughout the altitude hold phase. 
This enables the missile to dive on the target in the terminal phase, maximizing its 
available energy to provide maximum range. The missile uses proportional 
navigation with acceleration compensation to compensate for missile and target 


66 








accelerations [Ref. 19]. Horizontal, or azimuth proportional navigation is used in all 
guidance phases except null commands, while vertical proportional navigation is used 
only in the terminal phase. 

Messages internal to COMPUTE are GUIDANCE_MODE, 
ALTrnjDE_HOLD_CMD, and GUIDANCE COMMANDS. GUIDANCE MODE 
replies with the current guidance phase. AL'lTrUDE_HOLD_COMMAND 
commands the missile to hold a constant altitude. GUIDANCE_COMMANDS 
calculates the commanded accelerations or guidance commands. 

G. THE RF AND IR SEEKERS 

The missile uses its RF or IR seeker to get information about the target [Ref. 20]. 
At longer ranges, the missile simply receives the RF energy reflected off the target 
from the launch airaaft's radar. This is known as the semi-active phase. The launch 
aircraft's radar operates in the X-band frequency range. Initially the aircraft's radar 
is in the X-band acquisition mode and upon acquiring the target enters the X-band 
track mode. At medium ranges, the missile's on-board radar activates to provide 
target information. This is known as the active phase. The missile's radar operates 
in the K-band frequency range. The missile's radar is initially in the K-band 
acquisition phase and enters the K-band track mode upon acquiring the target. At 
short ranges, the missile activates its IR seeker to acquire and track the target in the 
terminal phase of flight. Like the RF seeker, the IR seeker has an initial acquisition 
mode that is followed by a track mode once the target is acquired. In summary, at 


67 








long ranges the launch aircraft's more powerful radar provides the best target 
information, while at medium ranges the missile's own radar provides the best target 
information, and at short ranges the missile's IR sensor provides the best target 
information. Modeling missile seekers is very complex and involves security issues. 
The seekers modeled here are rudimentary and future seeker work is discussed in 
Chapter VII. 

The RF_SEEKER's external messages are SETUP, INITIALIZE, GIMBAL, and 
DETECTION (see Figure B.7). SETUP establishes the number of targets and SOJs, 
ECM techniques and power, and the target's RCS. INITIALIZE initializes the RF 
phase and radar power levels. GIMBAL, given the missile-to-target range vector, 
replies with the seeker gimbal angles. DETECTION, given missile*to-target range 
and launch aircraft-to-target range, responds with the RF phase, SNR, the selected 
target number, and bore sight error (BSE). The missile's BSE in this simulation is 
the same as the LOS, an imaginary line from the missile's seeker to the target. The 
BSE to target two is the angle between the BSE to target one and the LOS to target 
two. This parameter affects power levels received by the missile's radar. 

RF_SEEKER's internal messages are BORESIGHT_ERROR , 
MSL_ANT_GAINS_SA, MSLANTGAINSA, SAPOWERS, APOWERS, 
SA PHASE, A PHASE, SA DETECT, and A DETECT. BORESIGHT ERROR 
calculates the bore sight error to the targets and SOJs. This defines the encounter 
geometry for the radar system and affects the corresponding power levels of the 
targets and SOJs seen by the radar system. MSL_ANT_GAINS_SA and 


68 






MSL_ANT_GAINS_A calculate the appropriate gain of the missile's radar antenna 
depending on the RF phase. SA_POWERS and A_POWERS calculates the power 
received by the missile's radar receiver based on the classic radar range equation 
[Ref. 21]. SA_MODE and A_MODE determine the RF mode, acquisition or track, 
for the semi-active and active RF phases. The SA_DETECT and A DETECT 
determine whether or not the missile can detect a target given the power level 
received. 

IR_SEEKER's messages are INITLALIZE and DETECTION as shown in Figure 
B.8. INITIALIZE establishes the IR phase and initializes search, acquisition and 
track times. DETECTION, given missile-to-target range, replies with the IR phase 
and Boolean RADOME_OFF, indicating the state of the radome. 

H. THE LAUNCHER 

The LAUNCHER object represents the aircraft that carries and launches the 
missile. LAUNCHER withes MATH for math operations and ENVIRONMENT for 
its SPEED_OF_SOUND message (see Figure B.9). LAUNCHER'S messages are 
INITIAUZE, MSL INIT, SETUP, LOG DATA, GET STATES, PUT STATES, 
GET DERIVATIVES, POLE and COMPUTE. 

INITIALIZE initializes the launch aircraft's velocity and position. MSL INIT 
provides launch aircraft initialization information for use by the missile. This 
message provides the missile with the launch aircraft's velocity and position, and 
certain radar characteristics based on the launch aircraft type. SETUP establishes 


69 








the launch aircraft's guidance phase, lead angle, mach, and altitude. LC>G_DATA 
provides the launch aircraft's position to the sender. GET_STATES returns the 
launch aircraft's state vector, while PUT_STATES updates the launch aircraft's state 
vector. The derivatives of the launch aircraft's state vector are supplied with 
GET_DERrVATIVES. POLE provides the distance from the launch aircraft to the 
target. The COMPUTE message provides the launch aircraft's velocity if the launch 
aircraft is in the pursuit guidance mode. 


I. THE TARGETS 

The TARGETS object models the aircraft that the missile is to intercept. The 
Ada package TARGETS is made up of four targets. Two of these targets, target one 
and target two, are treated as the primary targets, and targets three and four are 
treated as stand off jammers (SOJs). TARGETS withes MATH, ENVIRONMENT, 
and MISSILE, as shown if Figure B.IO. TARGETS withes MATH for mathematical 
operations and uses ENVIRONMENT for its time keeping services and its 
SPEED_OF_SOUND message. TARGETS uses the MISSILE message 
MANEUVER_VALUE to coordinate target maneuvers. 

TARGETS' messages are SETUP, INITIALIZE, LOG DATA, GET STATES, 
PUT STATES, GET DERTVATTVES, TGT DATA, and COMPUTE. SETUP sets 
up the user entered target parameters. INITIALIZE computes the initial position 
and velocity parameters for the targets. INITIALIZE also calculates the final turn 
angle and weave period if appropriate. LOG_DATA provides the targets' position, 


70 








velocity and heading data for data logging. GET_STATES and PUT_STATES put 
and get the targets' state vector (position), respectively. GET_DERIVATrVES 
provides the derivatives of the targets' state vector (velocity). TGT_DATA provides 
both target position and velocity data to the sender. TGT_ASPECT provides the 
sender with the target one's aspect angle. 

COMPUTE is the heart of TARGETS. COMPUTE calculates the targets' 
position, velocity and heading angle dependent on target maneuver. Appropriate 
conditions are checked resulting in the setting of flags and the times for the 
corresponding target maneuver. Then the build-up time must be considered. The 
build-up time is the time from the initiation of the maneuver until the desired 
number of g's is achieved. This models the real world condition that commanded 
maneuvers are not achieved instantaneously. The rate of change of the target's 
heading is then calculated along with the number of g's the target is experiencing. 
The current target heading angle is then compared with the final desired turn angle. 
The target velocity vector and mach are then computed. Finally, the second target's 
position is computed based on its geometric relation with the first target. To 
summarize, the target heading angle is calculated based on maneuver type. Because 
the targets have a constant velocity, the target heading angle is required to compute 
the velocity vector, which in turn permits the computation of the targets' position 
vector. 


71 








J. THE ENVIRONMENT 

The ENVIRONMENT provides atmospheric and time information. 
ENVIRONMENTS messages are SET TIME, TIME, AIR DENSITY, and 
SPEED_OF_SOUND (see Figure B.ll). ENVIRONMENT is the simulation's time 
keeper. SET_TIME allows the system time to initialized and incremented. The 
TIME message provides the current system time. AIR_DENSITY provides the air 
density for a given altitude, while SPEED_OF_SOUND provides the speed of sound 
at a given altitude [Ref. 9]. 


72 



VII. CONCLUSIONS AND RECOMMENDATIONS 


A. CONCLUSIONS 

This thesis has explored using object oriented techniques and software engineering 
principles in conjunction with the Ada programming language to develop a missile 
flight simulation. By using these techniques and principles the problem space is 
accurately mapped into software. This, along with the principles of abstraction, 
information hiding, modularity, loose coupling, and strong cohesion produced a 
simulation that is easily understood, modifiable, efficient and reliable. 

Although understandability can be very subjective, all of the missile analysts who 
reviewed the simulation agreed that the code is much more easily understood than 
previous FORTRAN versions. Modularity, high cohesion, and loose coupling 
permitted the simulation to be modified in easily. Modules were designed to serve 
a single purpose and to make use of only the data or control information presented 
by the interfaces of other modules. All the interfaces are well defined and are 
standard for that particular module. A good example is the abstraction of the missile 
airframe subsystem. By being modular and having a standard well defined interface, 
this subsystem evolved from a program stub to a fairly complex model with minimal 
programming effort. Also by having a standard well defined interface between 
objects or modules, a library of different models can be built to explore different 
missile and target configurations. The simulation is simply relinked with the desired 


73 








module. This allows a number of different models to be built relatively quickly. 
These models then can be used for comparison studies. 

Through abstraction, information hiding, and modularity a very efficient user 
interface was developed. The simulation has also proven itself to be highly reliable, 
producing consistent results that agree with missile system expert's predictions. The 
simulation has also proven to be quite robust, surviving the most mischievous users 
without crashing. 


B. RECOMMENDATIONS AND FUTURE WORK 

This thesis has laid the ground work for a generic missile flight simulation that 
will evolve to model existing classified missile systems. The continued improvement 
of the various models used in the simulation is highly recommended. Future work 
includes consulting local Pacific Missile Test Center missile system experts to 
improve and validate models. This will involve modifying the generic MISSILE to 
model a specific missile system. Work could then progress on the classified aspects 
of the missile's radar system and the electronic countermeasures aspects of the 
simulation. This might include modifying the ENVIRONMENT to model IR 
environmental concerns such as fog and haze, and radar environmental concerns such 
as ground clutter. The objects or modules will permit the experts to concentrate on 
the detailed level of their particular area of expertise, isolated, if desired, from the 
programming details of the other objects. Drivers will be developed to permit these 
objects to be tested stand-alone as individual components. 


74 








Work is also underway on the SYSTEM SPECIFIC and LOW LEVEL objects 
for the Apple Macintosh computer. Once these objects are developed the simulation 
will run on the Macintosh computer. A particularly good area for future work 
involves the data the simulation generates. The simulation is capable of generating 
large amounts of data that must be interpreted by analysts. Work is progressing on 
a object or package that will plot the data sets. Future work might include an expert 
system that reviews the data to assist the analyst in identifying problem areas in 
missile performance. 


75 








APPENDIX A 


CONTROL AND SUPPORT OBJECT DIAGRAMS 



76 































78 









Figure A.4 The USERJNTERFACE 


79 






















80 






















81 


















MATH 


Withes 

MATH_LIB 


Messages 

External 

LOG 

LIMIT 

MIN 

MAX 

Instantiates 

REAL-MATRIX 

Messages 

External 


it 

/ 

MAGNITUDE 

CROSS-PRODUCT 

TRANSPOSE 

IDENTITY 

DETERMINANT 

INVERSE 














APPENDIX B 

PROBLEM SPACE OBJECT DIAGRAMS 


OBJECTS REPRESENTING THE 
THE PROBLEM SPACE 



Figure B.l The Software Mapping of the Problem Space 

83 





















84 



























85 













Figure B.4 The AIRFRAME 


86 

















87 
















Figure B.6 GUIDANCE 


88 













RF_SEEKER 


Withes 

MATH 

REAL_MATRIX 

ENVIRONMENT 

Messages 

External 

EXTERNAL 

SETUP 

GIMBAL 

DETECTION 

Internal 

BORESIGHT_ERROR 

M5L_ANT_GAINS 

POWERS 

PHASE 

DETECT 


Figure B.7 The RF_SEEKER 


89 












IR_SEEKER 



Figure B.8 The IR_SEEKER 


90 






















TARGETS 


___I 

Withes 

MATH 

REAL-MATRIX 
ENVIRONMENT 
LAUNCHER 
MISSILE 


Messages 

External 

SETUP 

INITIALIZE 

LOG-DATA 

GET-STATES 

PUT-STATES 

GET-DERIVATIVES 

TGT-DATA 

COMPUTE 


Figure B.IO The TARGETS 


92 







ENVIRONMENT 


Withes 

MATH 

REAL-MATRIX 


Messages 

External 

SET-TIME 

TIME 

AIR-DENSITY 

SPEED-OF-SOUND 


Figure B.ll The ENVIRONMENT 


93 






APPEIBIX C 


CONTROL OBJECT SOURCE CODE LISTING 


-- Simulation Executive Procedure 

'■ This is the top level procedure for the simulation. 


with APPLICATION; 
with USER_INTERFACE; 

procedure SIH is 
begin 

APPLICATION.IMITIALI2E_SYSTEN; 

USER INTERFACE.HAIN; 
end SIM;~ 


-- Appl ication Package Specification 

-- This package contains the application specific functions called by the 
-- general Executive Package. 


with MATH; use MATH; 

with REAL MATRIX; use REAL MATRIX; 

with MOOEL_TYPES; use MOOEL_TYPES; 

package APPLICATION is 

function NUMBER_OF_STATE_VARIABLES 
return integer; 

function ENO_CONOITION_MET 
return boolean; 

procedure INITIALIZE_SYSTEM; 

procedure SIMULATION MAIN( 

SETUP_VALUES : in SETUP_VALUES_TYPE); 

procedure GET DERIVATIVES ( 

DERIVATIVES : out VECTOR); 

procedure GET STATES ( 

STATES : out VECTOR); 

procedure PUT STATES ( 

STATES ; In VECTOR); 

procedure COMPUTE.DERIVATIVES; 

procedure LOG_DATA; 

procedure ENO_OF_RUN; 

procedure GET_TIMES(TIME_ARRAY : out VECTOR; NUMBER_OF_VALUES : out 
integer);” 

procedure GET VARIABLEfUHICH VARIABLE : in integer; RETURN_VARIABLE : 
out VECTOR; NUMBER_OF_VALUES : out integer); 

end APPLICATION; 


94 









-■ Application Package Body 

-- This package contains the application specific functions called by the 
■■ general Executive Package. 


with MATH; use MATH; 

with MODEL TYPES; use MODEL_TyPES; 

with REAL MATRIX; use REAL MATRIX; 

with ENVIRONMENT; 

with SYSTEM SPECIFIC; 

with USER INTERFACE; 

with MISsTlE; 

with LAUNCHER; 

with TARGETS; 

with Calendar; use Calendar; 

with Text io; 

with REAL~IO; 

with INTEGRATION; 

with LOW LEVEL GRAPHICS; 

with UNCHECKED'dEALLOCATION; 

package body APPLICATION is 
LOGGING TO DISK : boolean; 

MEMORY.FULL : boolean; 

LOG INTERVAL : integer; -* Frames between data logging 
LOG^RECORD ; LOG_RECORO_TYPE; 

type LOGGED DATA; 

type LOGGED~DATA PTR TYPE is access LOGGED DATA; 

type L0GGED3DATA“is ” 

record 

time : real; 

DATA : LOG RECORD TYPE; 

NEXT_RECORO ; LOGGED_DATA_PTR_TYPE; 
end record; ” ~ 

pragma PACK(LOGGED_OATA}; 

FIRST DATA RECORD : LOGGED DATA PTR TYPE := null; 
CURRENT_OATA_RECORO : LOGGED_OATA_PTR_TYPE; 

TERMINATE_FLAG : boolean; 

START_TIME : Time; 

LOG DATA FILE : Text_io.File type; 

MISSILE STATES ; VECTORd..6); 

LAUNCHER STATES : VECTORd. ,3); 

TARGET_STATES : VECTORd..3); 

procedure LOG_DATA is separate; 


procedure SHOW TERMINAL CONDITIONS is 
A POLE ; REAL; 
mTsS DISTANCE: REAL; 

TIME“0F FLIGHT: REAL; 

ALTITUDE: REAL; 

RDOT: REAL; 

STOP_CONDITION: STOP_CONDITION_TYPE; 
begin 

MISSILE.TERMINAL CONDITIONSIA POLE, MISS DISTANCE, TIME OF FLIGHT, 
ALTITUDE,RDOT,STOP_CONDItToN); 

SYSTEM SPECIFIC.PUT REAL( 2,29, TIME OF FLIGHT); 
SYSTEM~SPECIFIC.PUtIrEAL( 3,67,ALTITU0e7 1); -- Altitude 


95 








SYSTEM SPECIFIC.PUT REAL( 15.67,MISS DISTANCE/ FEET_PER NMI , 1); 
jSYSTEM_SPECI FIC. PUT“rEAL{ 16,67, ROOT ,~1) ; 

SYSTEM SPECIFIC.PUT“sTRING( 21,41, "Reason for termination 
SYSTEM_SPECIFIC.PUT3 sTRING(21,68, STOP_REASON(STOP_CONOITION)); 

if MISS DISTANCE < 10 000.0 then 

SYSTEM SPECIFIC.PUT STRING(22,41, "Hiss Distance, ft :"); 

SYSTEM_SPECIFIC.PUT“REAL(22,67,M1SS_DISTANCE,2>; -- Miss-Dist, ft 
end if; 

if MISSILE.IS ACTIVE then 

SYSTEM SPECIFIC.PUT STRING(23,41, "A-Pole, NMI ;"); 

SYSTEM”sPECIFIC.PUtIreAL( 23,67, A_P0LE / FEET_PER_NMI); -- A-Pole 
end if; ~ 

end SHOW_TERNINAL_CONDITIONS; 


procedure INITIALIZE SIMULATION(OUTPUT FILE : in string) is 
procedure FrIe is new UNCHECKED DEALLOCATIONf 
LOGGED_DATA, LOGGED_DATA_PTR_TYPE); 

PREV_DATA_RECORO : L06GE0_DATA_PTR_TYPE; 
begin 

if FIRST OATA_RECORO /= null then 

CURRENT DATA RECORD := FIRST DATA RECORD; 
while CURRENT DATA RECORD.NEXT_RECORD /= null loop 
PREV DATA~RECORO := CURRENT DATA RECORD; 

CURRENT DATA RECORD :> CURRENT DATA RECORD.NEXT RECORD; 
FREE(PREV_DATA_RECORO); 
end loop; 

FREE(CURRENT_DATA RECORD); 

FIRST_0ATA_REC0RD~:= nulI; 
end if; 

TERMINATE FLAG :» false; 

LAUNCHER.TnITIALIZE; 

TARGETS.INITIALIZE; 

MISSILE.INITIALIZE; 

USER INTERFACE.SETUP RUNTIME SCREEN; 

STARf_TIME := Clock;" 

MEMORY FULL :« false; 
if LOGGING_TO_OISK then 

Text io.Create!LOG_OATA FILE, Text io.Out_file, OUTPOT_FILE); 
Text_io.Put<LOG 0ATA_FILE , 

"Time 7n8l Po8_M ,M8l Pos E ,Altitude ,R LAC Tgt ,"); 
Text_io.Put(LOG_DATA_FILE , ” “ 

"Velocity ,Msl Head A,Pitch Ang ,Msl Mach ,Range Tgt ,"); 
Text_io.Put(LOG_OATA_FILE , “ ~ 

"Range Rate,Time To Go,Skr TotAng,Skr_El Ang,Skr Az_Ang,"); 
TextJo.Put<LOG_DATA7FILE , " 

"El Rate T1,Az Rate T1,Alt Rate ,Az Acc Cmd,El Acc Cmd,"); 
Text_io7Put<L00_0ATA_FILE , “ 

"X Axis Acc7az Acc Ach,El Acc Ach,Msl Hass ,Thrust ,"); 
Text_io.Put<LOG_OATA_FTLE , ~ ~ 

"Tot Alpha ,Alpha ,Beta ,SNR ,Drag Coef ,"); 

Text io.Put(LOG DATA FILE , 

"Tgt Type 7T9t T BSE ,Tgt 2 BSE ,T 9 t 3 BSE ,Tgt 4 BSE ,"); 
Text io.Put(LOG DATA FILE , 

"LAC Pos N 7 lAC Pos E ,LAC Alt ,T1 Pos M ,T1 Pos E ,"); 

Text io.PutlLOG DATA FILE , ~ 

"T1 Alt 7 t2 P 08 N ,T2 Pos E ,T2 Alt ,T1 Vel ,"); 

Text_io.Put(LOG_DATA_FTLE , 

"T1 Mach ,T1 H^ Ang,Guid Phase,M8l_Phase ,RF Phase ,"); 
Text_io7Put<LOG_OATA_F7LE , 

"IR Phase ,Radam Off ,Prop Phase"); 

Text_i o7New_line(L0G_DATA_FILE)7 
end If; 


COMPUTE DERIVATIVES 









end INITIALIZE SIMULATION 


procedure CHECK PAUSE is 
KEY_AVAILABLE : booleen; 

KEY~: character; 
begin 

USER INTERFACE.KEYBOARD HANDLER.KEY AVAILABLE(KEY AVAILABLE); 
if not END_CONDITION_MET and not KEY_AVAILABLE then 
return; 
end if; 

USER_INTERFACE.KEYBOARD_HANOLER.GET KEY NOWAIT(KEY, KEY_AVAILABLE); 
if END CONDITION NET or else (KEY AVAILABLE and KEY = • •) then 
SYST EM_SPECIFIC.REVERSE_VIDEO“ON; 

if END CONDITION MET then 

SYSTEH_SPECIFIC.PUT_STRING(24, 12, 

■' Run completed. Press space bar to return to main menu "); 

else 

SYSTEM_SPECIFIC.PUT_STRIMG(24, 15. 

“ Press space bar to continue run, T to terminate "); 

end if; 

SYSTEM_SPECIFIC.REVERSE_VIDE0_0F F; 
loop 

USER_INTERFACE.KEYBOARD_HANDLER.GET_KEY_WA1T(KEY); 

if KEY = • ■ then 

if not END CONDITION MET then 

USER_INTER FACE.DRAU_RUNTIME_BOROER; 
end if; 
exit; 
end if; 

if KEY = 't* or KEY * 'T' then 
TERMINATE.FLAG :> true; 
exit; 
end if; 
end loop; 
end if; 

end CHECK PAUSE; 


procedure SIMULATION MAIN(SETUP VALUES : in SETUP VALUES_TYPE) is 

FRAME NUMBER ;“integer; 

MEXT_LOGGING_FRAME ; integer; 
begin 

LOGGI MG_T0_01SK : = boo I can' va I ( YES_NO_T YPE • pos{ SE TUP_VALUES. L0G_D AT A)) ; 

LAUNCHER.SETUP(SETUP VALUES.INT_GUIDANCE, 

DEG TO RAD*SETUP~VALUES.INT LEAD ANGLE_IC, 

SETUP values.intIwch IC, 

1000.0*SETUP VALUES.INT ALTITUDE IC, 

SETUP_VALUESTiNT_TYPE_IC); 

TARGETS.SETUP(DEG TO RAO*SETUP VALUES.TGT_ASPECT_IC, 

SETUP VALUES.TGT2 ANGLE IC, 

SETUP'VALUES.TGT MACH IC, 

SETUP“vALUES.TGT“tURN“g IC, 

SETUP VALUES.TGT WEAVE PER IC, 

SETUP VALUES.TGT TURNON VALUE IC. 

DEG TO RAD*SETUP“vALUESTtCT TURN_AMG IC, 

SETUP VALUES.TGt“bUILDUP TIME IC, 

SETUP VALUES.TGT RANGE IC, 

SETUP~VALUES.TGT~ALTITUOE IC, 

SETUP'VALUES.SOJ ANGLE_IC7 
SETUP'VALUES.MANEUVER KINO, 


97 









SETUP VALIAS.TGT TWO IC, 

SETUP VALUES.SOJ ONE 1C, 

SETUP VALUES.SOJ TUO IC, 

SETUP_VALUES.TURN_ON_PARAMETER); 

MISSILE.SETUP!SETUP VALUES.LAUNCH TYPE, 

SETUP VALUES.TGT RCS 1C, 

setup”values.tctT ir“size, 

SETUP“VALUES.TGT2“lR SIZE, 

SETUP VALUES.TGT TUO~IC, 

SETUP“VALUES.S0J“0NE“iC, 

SETUP'VALUES.SOJ“two"1C, 

setupIvalues.tgt'ecm'pouer IC, 

SETUP VALUES.TGT ECM TECH Tc, 

SETUpIvALUES.SOjIecm“tECH j C); 

LOG INTERVAL SETUP VALUES.LOG INTERVAL; 

ENVIRONMENT.SET TIME(O.O); 

INTEGRATION.SET~TIME STEP SIZE(SETUP VALUES.FRAME TIME); 

NEXT LOGGING FRAME :» 1; “ 

FRAME NUMBER~:= 0; 

INITIALIZE SINULATION(SETUP VALUES.OUTPUT_FILE); 

INTEGRATION.INITIALIZE; 

uhile not END CONDITION MET loop 

FRAME_NUMiER FRAME_NUMBER > 1; 

If FRAME NUMBER - NEXT LOGGING FRAME then 
LOG DATA; 

NEXT_LOGGING_FRAME := NEXT_LOGGING_FRAME ♦ LOG_INTERVAL; 
end if; 

1NTEGRATION.ADVANCE.TIME; 

if END CONDITION MET then 
LOG DATA; 

sho5_termiNAL_C0NDIT1ONS; 

end if; 

CHECK_PAUSE; 

end loop; 

END OF RUN; 
end SIMULATION_MAIN; 


function NUMBER_OF_STATE_VARIABLES 
return integer is 
begin 

return 14; 

end NUMBER.OF.STATE.VARIABLES; 


function END_C0N0IT10N_NET 
return boolean is ~ 
begin 

if TERMINATE_FLAG or MISSILE.EN0_C0N0ITI0NS_MET then 
return true; 

else 

return false; 
end if; 

end END CONDITION NET; 


procedure INITIALIZE_SYSTEM is 
begin 

SYSTEM SPECIFIC.INIT VIDEO; 
USER_INTERFACE.SHOU_TITLE_SCREEN; 


98 











end INITIALIZE SYSTEM 


procedure GET DERIVATIVES ( 

DERIVATIVES : out VECTOR) is 
begin 

DERIVATIVES(1..6) MISSILE.GET DERIVATIVES; 
DERIVATIVES(7..9} := LAUNCHER.GET'DERIVAT IVES; 
DERIVATIVES(10..12) ;» TARGETS.GET DERIVATIVES; 
end GET DERIVATIVES; 


procedure GET STATES ( 

STATES : out VECTOR) is 
begin 

STATES(1..6) := MISSILE.GET STATES; 
STATES(7..9) := LAUNCHER.GET STATES; 
STATES<10..12) := TARGETS.GET STATES; 
end GET STATES; 


procedure PUT STATES ( 

STATES : Tn VECTOR) is 
begin 

MISSILE STATES := STATESd . .6 ); 
MISSILETpUT STATES(M1SSILE STATES); 
LAUNCHER STATES := STATES(7..9); 
TARGET_STATES := STATESdO. .12); 
LAUNCHER.PUT STATES(LAUNCHER STATES); 
TARGETS.PUT STATES(TARGET_STATES); 
end PUT STATES;' 


procedure COMPUTE.DERIVATIVES is 
begin 

LAUNCHER.COMPUTE; 
TARGETS.CQMPUTE; 

MISSILE.COMPUTE; 
end COMPUTE DERIVATIVES; 


procedure EMD^OF_RUN is 
begin 

if LOGGING TO DISK then 

TeKt_i o.cTosef LOG_DATA_FILE); 
end if; 

end EMD_OF_RUN; 


procedure GET_TIMES<TIME_ARRAY : out VECTOR; NUMBER_OF_VALUES : out 
integer) Is ' 

NUMBER VARIABLES : integer; 

DATA_RECORD : L06GED_OATA_PTR_TYPE; 
begin ' 

DATA RECORD :> FIRST DATA RECORD; 

NUMBER_VARIABLES T; 

while (DATA RECORD /< null) loop 

TIME ARRAY(NUMBER VARIABLES) :> DATA RECORD.Time; 
DATA'rECORD :> DATA RECORD.NEXT RECORD; 

NUM8ER_VARIABLES :>~NUMBER_VARIABLES * 1; 
end loop; 

NUMBER OF VALUES NUMBER VARIABLES - 1; 
end GET TIMEsJ 


procedure GET VARIABLE(WHICH VARIABLE : in integer; RETURN VARIABLE : 
out VECTOR; NUMBER OF VALUES : out integer) is 
NUMBER VARIABLES :~integer; 

DATA RECORD : LOGGED_DATA PTR TYPE; 


99 













begin 

DATA RECORD FIRST DATA RECORD; 

NUMBER VARIABLES := T; 
ubile (DATA RECORD /= null) loop 
if (UHICH_VARIABLE »= SO) then 

RETURN VARIABLE(NUHBER VARIABLES) := 

DATA_RECORO.OATA.LAUNCHER OATA.REAL_VALUE(WHICH VARIABLE-50); 
-- M! FIX LAUNCHER_DATA“aIso see PLOT.ADA 

else 

RETURN VARIABLE(NUHBER VARIABLES) := 

OATA_RECORD.DATA.MISSILE_DATA.REAL_VALUE(WHICH_VARIABLE); 
end if; 

DATA RECORD := DATA RECORD.NEXT_RECORD; 

NUMBER_VARIABLES :=~NUMBER_VARIABLES * 1; 
end loop; 

NUMBER OF VALUES := NUMBER VARIABLES - 1; 
end GET VARIABLE; 
end APPLICATION; 


-- Application Package Subunit 

-- This package contains the application specific functions called by the 
-- general Executive Package. 


separate (APPLICATION) 


procedure LOG_DATA is 
begin 

LOG RECORD.MISSILE DATA := MISSILE.LOG DATA; 

LOG'rECORD.LAUNCHER DATA := LAUNCHER.LOG DATA; 

LOgIrECORD.TARGET_OATA := TARGETS.LOG_DATA; 

begin 

if not MEMORY FULL then 

if FIRST DATA RECORD * null then 
FIRST_DATA_RECORD ;= new 
LOGGED_DATA'(time => environment.time, 

DATA => LOG RECORD, NEXT RECORD => null); 

CURRENT_DATA~ RECORD := FIRST_DATA_RECORD; 

else 

CURRENT_DATA_RECORD.NEXT_RECORD := new 
LOGGED DATA'Ttime => environment.time, 

DATA »> LOG RECORD, NEXT RECORD => null); 

CURRENT_DATA~RECORD ;= CURRENT_DATA_RECORD.MEXT_RECORD; 
end if; 
end if; 
exception 

when STORAGE ERROR => 

MEMORY FULL true; 

SYSTEM'sPECIFIC.REVERSE video ON; 

SYSTEM_SPECI FIC.PUT_STR7nG(207 41 , 

■Hlata memory full at time : "); 

SYSTEM SPECIFIC.PUT REAL(^0,6^ ENVIRONMENT.Time); 

SYSTEM^SPEC IFIC. REVERSE_VI DE0_O.''F; 

end; 

if LOGGING TO DISK then 

REAL IO.Put(LOG DATA FILE, ENVIRONMENT.Time, AFT => 3); 

TextJ o.Put(LO gIdATA^FILE, ","); 

for I in 1..34 loop 

REAL IO.Put(LOG DATA FILE, LOG RECORO.MISSILE_DATA.REAL VALUE(I), 
AFT => 3); 

Text_i o. Put ( L0G_DAT A_F I LE, •',••); 
end loopj 


100 








for I in 1..12 loop 

REAL lO.PutdOG 0ATA_FILE, LOG RECORD.LAUNCHER DATA.REAL VALUEd), 
AFT => 3); “ ■ 

Text_i o. Put ( LOG_DATA_F ILE, 
end loop; 

Text io.Put(LOG_DATA FILE. integer'imageCGUIOANCE PHASE TTPE'posC 
LOG_RECORO.MISSILE_DATA.GU1DAHCE_PHASE))); “ 

Text_i 0 .Put { LOG_DATA_F I LE, ". •■) ; 

Text io.Put(LCG DATA FILE, integer*image(RF PHASE TYPE1'pos( 
LOgIrECORD.MISSILE_DATA.RF PHASE_1)))7 
Text_io.Put(LOG_DATA_FILE, '*."); 

Text io.Put(LOG DATA FILE, integer*iiiiage(RF_PHASE_TYPE2'pos( 
LOG~RECORO.MISSILE DATA.RF PHASE_2))); 
TextJo.PutlLOG^OATAJILE. **,**); 

Text io.PutlLOG DATA FILE, integer*image(IR PHASE TYPE*pos( 

LOG“rECORO.MISSILE DATA.IR_PHASE))); “ 

Text_i o. Put { LOG^DAT A_F I LE. **,**); 

Text io.Put(LOG DATA FILE, integer *ifflage(boolean*pos( 

LOG~RECORO.MISSILE DATA.RADOME_OFF))); 

Text_i o. Put <LOg7dATA_F I LE, **, **) ; 

Text io.PutlLOG DATA FILE, integer*iniage(PROPUL_TYPE*pos( 

LOG_RECORO.MISSILE_0ATA.PROPULSION_PHASE))); 

Text_i0.Meu_line(LOG_OATA_F1LE); 
end if; 

SYSTEM SPECIFIC.PUT REAL( 1,29, REAL(Clock - START TIME)); 
SYSTEM“sPECIFIC.PUT~REAL( 2,29, ENVIRONMENT.Time);" 
SYSTEM“sPECIFIC.PUT"rEAL( 3,29, 

LOG RECORD.MISSILE DATA.REAL VALUE(II)); •• Time to go 
SYSTEM SPECIFIC.PUT STRlNGf 5,30, 

RF~MOOE(LOG RECORD.MISSILE DATA.RF PHASE 2)); -• RF seeker mode 
SYSTEM SPECIFIC.PUT STRINGf 6,30, 

Ir7mOOE(LOG_RECORO.M 1SSILE_OATA.IR PHASE)); -• IR seeker mode 
SYSTEM_SPECIFIC.PUT_REAL(7,29, LOG_RECORD.MISSILE_DATA.REAL_VALUE(14)); 

-* Az Gimbal Angle 

SYSTEM_SPECIFIC.PUT_REAL( 8,29, L0C_REC0R0.MISSILE_DATA.REAL_VALUE(13)); 

-- El GiniMl Angle 

SYSTEM SPECIFIC.PUT REAL( 9,29, LIMIT(LOG RECORD.MISSILE DATA. 

" REAL VALUE(16),9999.9999), 4); --“az LOS Rate 
SYSTEM SPECIFIC.PUT REAL(10,29, LtMIT(LOG RECORD.MISSILE DATA. 
REAL_VALUE(T5),9999.9999), 4); - El LOS Rate 

SYSTEM SPECIFIC.PUT STRING(12,30, GUIDANCE MOOE( 

LOG RECORD.MISSILE DATA.GUIDANCE PHASE)); — Guidance mode 
SYSTEM SPECIFIC.PUT REAL(13,29, 

LOG RECORD.MISSTlE DATA.REAL VALUE(18) / G, 4); •• Az Acc Cmd 
SYSTEM SPECIFIC.PUT REAL(14,29, ~ 

L0G_REC0RD.MISs7lE_DATA.REAL_VALUE( 19) / G. 4); -- El Acc Cmd 

SYSTEM SPECIFIC.PUT STRING(16,30, PROPULSION MOOE( 

LOG RECORD.MISSILE DATA.PROPULSION PHASE)); ■- Propulsion mode 
SYSTEM SPECIFIC.PUT REAL(17,29, 

L0C_REC0RD.MISsIlE_DATA.REAL_VALUE( 24), 1); -- Thrust 

SYSTEM SPECIFIC.PUT REAL(19,29, 

LOG RECORD.MISsIlE DATA.REAL VALUE(23)); — Msl Weight 
SYSTEM_SPECIFIC.PUT_REAL(20,29, LOG_RECORD.MISSILE_DATA.REAL_VALUE(26)); 

-- Msl Alpha 

SYSTEM SPECIFIC.PUT_REAL(21,29, L0G_REC0RD.MISSILE_DATA.REAL_VALUE(27)); 

-- MsrBeta 

SYSTEM_SPECIFIC.PUT_REAL( 1,67, 


101 







-- Mach 


LOG RECO(tD.NISSlLE_OATA.REAL VALUE(8), 3) 

SYSTEM SPECIFIC.PUT REAL( 2,67, ~ 

LOG RECORD.MISSTlE_DATA.REAL VALUE(5), 1); -- Velocity 
SYSTEM SPECIFIC.PUT REAL( 3,67, “ 

LOG RECORD.MISSTlE DATA.REAL VALUE(3), 1); — Altitude 
SYSTEM SPECIFIC.PUT REAL( 4,67, “ 

LOG RECORD.MISSTlE DATA.REAL VALUE(17)); - Altitude Rate 
SYSTEM_SPECIFIC.PUT_REAL( 5,67, LOG_RECORD.MISSILE_DATA.REAL_VALUE(7)); 

-- Pitch Angle 

SYSTEM_SPECIFIC.PUT_REAL{ 6,67, LOG_RECORD.MISSILE_DATA.REAL_VALUE(6)); 

-- Yaw Angle 

SYSTEM SPECIFIC,PUT REAL( 7,67, LOG RECORD. 

MISSILE DATA.REAL VALUEd) / FEET PER NMI , 1);-- Msl Downrange 
SYSTEM SPECTfIC.PUT_REAL< 8,67, LOG_RECORO. 

MISSILE_DATA.REAL VALUE<2) / FEET PER NMI , 1); - Msl Crossrange 
SYSTEM SPECIFIC.PUT REAL{10,67, 

LOG RECORD.MISSTlE DATA.REAL VALUE(20) / G, 4); — X Axis Accel 
SYSTEN_SPECIFIC.PUT_REAL(11,67, “ 

LOG RECORD.MISSILE DATA.REAL VALUE(21) / G, 4); -- Y Axis Accel 
SYSTEM SPECIFIC.PUT REAL(12,67, " 

LOG_RECORD.MISsTlE_DATA.REAL_VALUE( 22) / G, 4); -- Z Axis Accel 

SYSTEM SPECIFIC.PUT REAL(15,67, LOG_RECORD. 

MISSILE_0ATA.REAL_VALUE(9) / FE£T_PER_NMI . 1); -- Msl-Tgt Range 

SYSTEM SPECIFIC.PUT REAL(14,67, LOG RECORD. 

MISSILE_DATA.REAL VALUE(4) / FEET PER NMI , 1); — Lnchr-Tgt Range 
SYSTEM SPECIFIC.PUT_REAL(17,67, 

LOG RECORD.LAUNCHER DATA.REAL VALUE(II), 3); — Tgt Mach 
SYSTEM SPECIFIC.PUT REAL(16,67, 

LOG RECORD.MISSTlE_OATA.REAL VALUE(IO), 1); •• Tgt Range Rate 
SYSTEM SPECIFIC.PUT REAL(18,67, “ 

LOG RECORD.LAUNCHER DATA.REAL VALUE(6), 1); — Tgt Altitude 
SYSTEM SPECIFIC.PUT REAL<19,67, LOG RECORD.LAUNCHER DATA. 

REAL VALUE(12), 1); •• Tgt heading ang 
end L0G_DATA7 

-- User Interface Package Specification 

■■ This package contains all the procedures that perform input/output between 
-- the program and the user via the screen and keyboard. 


with MATH; use MATH; 

package USER_INTERFACE is 
procedure MAIN; 
procedure SHOW_TITLE_SCREEN; 
procedure ORAU_RUNTIMG_BOROER; 
procedure S£TUP_RUNTIME_SCREEN; 
task KEYBOARD HANDLER is 

entry KEY_AVAILABLE(KEY_IN_BUFFER : out boolean); 

entry GET_KEY_UAIT<KEY : out character); 

entry GET KEY NOUAIT(KEY : out character; KEY_VALIO : out boolean); 
end KEYBOARO.HANOLER; 

end USERJNTERFACE; 

*' User Interface Package Body 

-- This package contains all the procedures that perform input/output between 


102 















- the program and the user vfa the screen and keyboard. 


with MATH; use MATH; 

with MOOEL_TYPES; use MODEL TYPES; 

with SYSTEM SPECIFIC; 

with APPLICATION; 

with MISSILE; 

with PLOT; 

with Text_io; 

with REAL_IO; 

package body USER_INTERFACE is 

MESSAGE_DISPLAYED : boolean := false; -- Message on at screen bottom 
MENU_START_ROW : constant := 6; 

DATA COLIRW : constant := 42; 

ITEM'tEXT size : constant := 30; 

MEMU~TEXT“sIZE : constant := 30; 

STRING_SIZE : constant 60; 

type STRING_ARRAY is arraylpositive range <>) of stringd. .STRING_SIZE); 

TEMP_STRIMG ; stringd..ITEM_TEXT_SIZE); 

QUIT STRING : stringd..MENU TEXT SIZE) := "Quit program 
RETUHM_STRIMG : stringd..MENU_TEXT S12E):=“Return to previous menu 
BLANK_STRING : stringd..STRING_SIZE) : = 

II “ "" M • 

i 


type MENU ITEM KINO is (SUBMENU. DATA ITEM, ACTION); 
type DATA~ITEM~KIND is (NONE. TEXT. FLOATING PT. YES NO. INT GUIDANCE. 
TGT IR SIZE. MANEUVER. MANEUVER START. aTrCRAFT KIND. LAUNCHER. 

SSJ ECM. SOJ ECM); 

type ACTION TYPE~is (LOAD DATA. SAVE DATA. START RUN. GRP1 GRAPH). 

GRP1 GRAPH2. GRP1 GRAPH3. GRP1 GRAPH4. GRP1 GRAPHS. GRP1 GRAPH6. 

GRprGRAPHZ. GRP2 "gRAPH1. GRP2“gRAPH2. GRPZ'gRAPHS, GRP2“gRAPH4. 

GRP2~GRAPH5. GRP3~GRAPH1. GRP3_GRAPH2, GRP3~GRAPH3, GRP4 GRAPH), 

GRP4“gRAPH2. GRP4~GRAPH3, GRP4“gRAPH4, GRP4“gRAPH5, GRP4“gRAPH6, 

CRPA^GRAPH/); 

type MENU TYPE; 

type MENU~POINTER is access HENU_TYPE; 

type MENU ITEM TYPEdTEM KINO : MENU ITEM_KIN0; 

DATA TYPE T DATA ITEM KINO); 
type MENU_ITEM_POINTER is“access MEMU_ITEM_TYPE; 

type MENU_TYPE is 
record 

TITLE : stringd..STRING SIZE); 

FIRST_ITEM ; MENU_ITEM^p6iNTER; 

ROWS_BETWEEN_ITEMS : positive; -- ) a no gap, 2 = ) blank line, etc. 
end record; 

type MENU ITEM TYPEdTEM KINO : MENU ITEM KIND; DATA TYPE : 

DATA_TtEM_KIND) is 
record 

TITLE : stringd..MENU TEXT SIZE); 

NEXT_ITEM ; MENU_ITEM_POINTER; 

case ITEM KINO is 
when SUBMENU » 

NEXT MENU : MENU POINTER; 
when DATA ITEM *> 

PROMPT : stringd..MENU TEXT SIZE); 


)03 











case OATA_TYPE is 
when NONE => 
null; 

when TEXT => 

TEXT_VALUE : string<1..MENU_TEXT_SIZE); 
when FLOATING PT » 

REAL VALUE : REAL; 

MAX VALUE : REAL; 

MIN~VALUE : REAL; 
when YES NO => 

YES_NO VALUE : YES_NO TYPE; 
when INT GUIDANCE => 

INT_GUIOANCE VALUE : INT_GUIOANCE TYPE; 
when TGT IR SI2E~=> 

TGT 7r_SIZE_VALUE : TGT IR SIZE TYPE; 
when MANEUVER => 

MANEUVER VALUE : MANEUVER TYPE; 
when MANEUVER START => 

MANEUVER START_VALUE : MANEUVER_START_TYPE; 
when AIRCRAFT KIND => 

AIRCRAFT KIND VALUE : AIRCRAFT_TYPE; 
when LAUNCHER => ~ 

LAUNCHER_VALUE : LAUNCHER.TYPE; 
when SSJ ECM => 

SSJ_ECM_VALUE : SSJ_ECM_TYPE; 
when SOJ ECM => 

SOJ_ECM_VALUE : SOJ_ECM_TVPE; 
end case; 
when ACTION »> 

ACTION_KIND : ACTION_TYPE; 
end case; 
end record; 


MAIN MENU. FILE MENU, LAUNCHER MENU, TGT MENU, GRAPH MENU : MENU POINTER; 
GRAPH GRP1 MENU, GRAPH GRP2 MENU, GRAPH GRP3 MENU, GRAPH GRP4 MENU, 

TGT1 MENU, TGT2 MENU, SOJI MENU, S0J2 MENU :~MENU POINTER; 


type MEMU_ITEM_ARRAY is array (positive range o) of MENU_ITEM_POINTER; 


MAIN MENU ITEMS : MENU ITEM ARRAY(1..5); 
FILE“mENU“iTEMS : MEMu“iTEM“aRRAY<1..7); 
LAUNCHER MENU ITEMS : MENU TtEM ARRAY(1..6) 
TGT_MENU_ITEMi : MENUJTEM ARRAY<1..7); 

MENU ITEM ARRAY<1..15); 
MENU ITEM"aRRAY<1..7); 
MENU”ITEM“aRRAY(1..13); 
MENU“ITEM”aRRAY( 1,.13); 
MENU ITEM ARRAY(1..4); 
MENU ITEM ARRAYd. 
MENU ITEM ARRAYd. 


TGT1_MEMU_ITEMS 
TGT2 MENU ITEMS 
SOjrMEMU“lTEMS 
SOJ2 MENU ITEMS 
GRAPH MENU ITEMS 
GRAPH GRP1 MENU ITEMS 
GRAPH GRP2 MENU ITEMS 


GRAPH GRP3 MENU ITEMS 

graph“grp4"memu”iTEMS 


MENU ITEM ARRAYd. 
MENUjTEM~ARRAYd. 


. 8 ); 

.5); 

. 3 ); 

.7); 


procedure SHOW_TITLE_SCREEN is separate; 


procedure GET TEXT(PROMPT STRING : in string; TEXT STRING : in out string)is 
TEMP STRING : string(TEXT STRING'range); 

INPUT_VALID : boolean :> false; 
begin 

for I in TEMP STRING*range loop 
TEMP_STRING<I) :» ' '; 
end loop; 

SYSTEM SPECIFIC.PUT STRING(22, 10, PR0MPT_STRING); 

SYSTEM_SPECIFIC.M0VE_CURS0R(22,DATA_COLUMN); 


104 










SYSTEM_SPECIFIC.TURN CURSOR ON; 

SYSTEM SPECIFIC.INPUT STRING(TEMP STRING); 

SYSTEM SPECIFIC.TURN OJRSOR OFF; 
SYSTEM_SPECIFIC.PUT_STRING(22, 10. BLANIC_STRING); 
for I in TEMP STRING'range loop 
if TEMP STRING(I) /= • ' then 
INPUT_VALIO := true; 
end if; 
end loop; 

if INPUT VALID then 

TEXT'sTRING := TEMP_STRING; 
end if; 
end GET_TEXT; 


procedure GET REAKPROMPT STRING : in string; NUMBER : in out REAL) is 
TEMP NUMBER : REAL; 

EXPONENT : REAL; 

CURRENT : positive; 

SIGN : integer; 
begin 

REAL IO.Put(TEMP STRING,NUMBER.AFT=>10,EXP=>0); 

GET_TEXT(PROMPT_STRING, TEMP_STRING); 

TEMP NUMBER 0.0; 

CURRENT TEMP STRING'first; 

SIGN ;= 1; 

for I in TEMP STRING'range loop -- Skip tabs and spaces 

if TEMP_STRING(I) /= • ' and TEMP_STRIMG(I) /= Ascii.HT then 
exit; 
end if; 

CURRENT CURRENT * 1; 

end loop; 

if TEMP STRING(CURRENT) * '♦• then 
CURRENT CURRENT *■ 1; 

end if; 

if TEMP_STRING(CURRENT) = •-' then 
SIGN :» -1; 

CURRENT :* CURRENT ♦ 1; 
end if; 

Mhile TEMP_STRINC<CURRENT) >= 'O' and TEMP STRIMC(CURRENT) <= '9' loop 
TEMP_NUMBER := TEMP_NUMBER * 10.0; 

TEMP_NUMBER TEMP.NUMBER * REAL( 

character'po8(TEMP STRING(CURRENT)) - character'pos('O')); 
CURRENT CURRENT * l7 

end loop; 

if TEMP STRING(CURRENT) = '.' then 
CURRENT :> CURRENT ♦ 1; 

EXPONENT :> 0.1; 

while TENP_STRING(CURRENT) >= 'O' and TENP_STRING(CURRENT) <= '9' 
loop 

TEMP_NUMBER :> TEMP NUMBER * REAL( 

character'poslTEMP STRING(CURRENT)) - 
character'posCO')) * EXPONENT; 

EXPONENT EXPONENT / 10.0; 

CURRENT :> CURRENT * 1; 
end loop; 
end if; 

NUMBER :> TEMP_NUMBER * REAL(SIGN); 

exception 

when others » 


105 








return; 
end GET_REAL; 


function SAVE_DATA_FILE 
return boolean is 

DATA_FILE : Text_io.File_type; 

procedure OUTPUT MENUCMENU : in HENU POINTER) is 
ITEM ; MEMU_TtEM_POINTER ;= MEMuTf 1RST_1TEM; 
begin 

while ITEM /= null loop 

if ITEM.ITEM KIND = DATA ITEM then 
case ITEM.DATA TYPE 7s 
when NONE => 
null; 

when TEXT => 

Text io.Put linefDATA FILE, ITEM.TEXT VALUE); 
when FLOATING pf => " 

REAL_I0.Put<DATA_FILE, ITEM.REAL_VALUE); 

Text io.New line(DATA_FILE); 
when YES“mO => ' 

Text“io.Put line(DATA_FILE. YES_NO TYPE’imagef 
ITEM.YES NO VALUE)); 
when INT GUIDANCE =>“ 

Text~io.Put linelDATA FILE, INT GUIDANCE TYPE'imageC 
ITEM.INT GUIDANCE_VALUE)); 
when TGT IR SIZE => 

Text'ioTPut line(OATA_FILE, TGT IR SIZE TYPE'imagef 
ITEM.TGT IR SIZE VALUE)); ~ 
when MANEUVER => 

Text io.Put line(DATA FILE, MANEUVER TYPE'image( 
ITEM.MANEUVER~VALUE)); 
when MANEUVER_START 

Text io.Put line(DATA FILE, 

MANEUVER START TYPE'imageC 

ITEM.MANEUVER START VALUE)); 
when AIRCRAFT KIND » 

Text io.PutJine(DATA FILE, 

AIRCRAFT TYPE'imaiel 

ITEmTaIRCRAFT KIND VALUE)); 
when LAUNCHER »> 

Text_io.Put line(DATA FILE, 

LAUNCHER TYPE'imagef 

ItemTlauncher.value)); 

when SSJ ECM » 

Text~io.Put lineCDATA FILE, 

SSJ ECM“TYPE'i(«age<ITEM.SSJ_ECM VALUE)); 
when SOJ ECM *>“ 

Text“io.Put lineLDATA FILE, 

SO J_ECM_T YPE' inisge( ITEM. SO J_ECM_VALUE ) ) ; 

end case; 

elsif ITEM. ITEM KINO = SUBMENU then 
OUTPUT.MENU?ITEM.NEXT_MENU); 
end if; ~ 

ITEM :> ITEM.NEXTJTEM; 
end loop; 
end OUTPUT_MENU; 

begin 

Text io.Create(DATA FILE, Text io.Out_file, 

FILE MENU ITEMS(1).TEXT VALUE); 

Text_io.Put_lTne(OATA_FILE, MISSILE.I0_STRING); 

OUTPUT MENULMAIN MENU); 

TextJ o. C1 08 e(DATA_F I LE ) ; 
return true; 


106 







exception 

when others » 

SYSTEM SPECIFIC.PtJT_STRING(22, 10, “ERROR during file save"); 
MESSAGE_DISPLAYED := true; 
if Text io.Is_open(DATA FILE) then 
Text_io.CIose(DATA_FILE}; 
end if; 
return false; 
end SAVE 0ATA_FILE; 


function LOAD_OATA_FILE 
return boolean is 

DATA_FILE ; TextJo.File_type; 

I0_mTsMATCH : exception; 

procedure INPUT MENU(HENU : in MENU POINTER) is 
ITEM : MENU'ITEM POINTER := MENU.FIRST ITEM; 

TEMP_LINE :~string<1..MENU_TEXT_SIZE);' 

LAST : natural; 
begin 

while ITEM /= null loop 

if ITEM.ITEM_KIN0 = DATA ITEM then 
case ITEM.0ATA_TYPE Ts 
when NONE => 
null; 

when TEXT => 

Text_io.Get_line<OATA_FILE, ITEM.TEXT_VALUE, LAST); 
Text io.Skip line(0ATA FILE); 
when FLOATING PT“=> 

REAL_I0.Get(0ATA_FILE, ITEM.REAL_VALUE); 

Text io.Skip line(DATA FILE); 
when YES“nO => ” 

Text“io.Get line(DATA FILE, TEMP LINE, LAST); 

ITEM.YES NO~VALUE " 

YES NO TYPE'valuefTEMP LINE(1..LAST)); 
when INT GUIDANCE -> 

Text~io.Get line(DATA FILE, TEMP LINE, LAST); 

itemTint guidance value := 

INT GUIDANCE TYPE~value(TEMP LINE(1..LAST)); 
when TGT_IR SIZE“=> 

Text“ioTGet line(DATA FILE, TEMP LINE, LAST); 

itemTtgt ir“size value ;= 

TGT_IR sTzE"TYPE~value(TEMP_LINE{1..LAST)); 
when MANEU^R »> 

Text io.Get_line<DATA_FILE, TEMP_LINE, LAST); 
ITEmTmANEUVER value := 

MANEUVER TYPEWalue<TEMP_LINE{1..LAST)); 
when MANEUVER START »> 

Text io.Get_line(DATA_FILE, TEMP_LINE, LAST); 

itemTmaneuver start value := 

MANEUVER START_TYPE~value(TEMP LINE(1..LAST)); 
when AIRCRAFT KIND «> 

Text io.Get line(DATA_FILE, TEMP LINE, LAST); 

itemTaircraft kind value ;= 

AIRCRAFT TYPE“value(TEMP_LINE(1..LAST)); 
when LAUNCHER “> 

Text io.Get line(DATA FILE, TEMP LINE, LAST); 
ITEmTlAUNCHER VALUE 

LAUNCHEH_TYPE“value(TEMP_LINE{1..LAST)); 
when SSJ ECM~»> 

Text“io.Get line<DATA_FILE, TEMP LINE, LAST); 
ITEmTsSJ ECM VALUE := 

SSJ_ECM_TYPE”v8lue(TEMP_LINE(1..LAST)); 
when SOJ_ECM *> 

Text'io.Get line(0ATA FILE, TEMP LINE, LAST); 
ITEmTsOJ ECM VALUE 

SOJ ECM TYPE'value(TEI«> LINE(1..LAST)); 


107 







end case; 

elsif ITEM.ITEM KINO = SUBMENU then 
INPUT_MENU(TtEM.NEXT_MENU); 
end if; 

ITEM := ITEM.NEXT_ITEM; 
end loop; 
end INPUT_MENU; 

begin 

Text_io.Open(OATA_FILE, Text_io.In_file, FILE_MEMU_ITEMS(1).TEXT_VALUE); 

Text_io.Get(DATA_FILE, TEMP STRING); 

Text_i o. Sk i p_H ne(DATA_F ILE ) ; 

for 1 in MISSILE.ID STRING'range loop 

if MISSILE.ID STRING(I) /= TEMP STRING(I) then 
raise ID_MISMATCH; 
end if; 
end loop; 

INPUT_MENU(MAIN_MENU); 

Text_io.CIose<0ATA_FILE); 
return true; 

exception 

when others => 

SYSTEM_SPECIFIC.PUT STRING<22, 10. "ERROR during file load"}; 
MESSAGE_0ISPLAYED := true; 
if Text io.Is open(DATA_FILE) then 
Text_io.cTose<0ATA_FILE); 
end if; 
return false; 
end LOAD DATA FILE; 


procedure START RUN is 

SETUP VALUES ; SETUP VALUES TYPE; 

TEMP_REAL : REAL; --“Needed for Meridian V4.0 bug 
begin 

-- File operations parameters 

SETUP VALUES.OUTPUT FILE := FILE_MENU ITEMS<4).TEXT_VALUE; 
SETUP~VALUES.LOG DATA FILE MENU ITEMS<5).YES NO VALUE; 
setup'VALUES.FRAME TIME FiIe_MENU ITEMS<6).REAL~VALUE; 
SETUp3vALUES.L0G_1NTERVAL :» 1NTEGERLF1LEJ«NU_ITEMS(7).REAL_VALUE); 

Launch aircraft parameters: 

SETUP VALUES.INT_TYPE IC:"LAUNCHER MENU ITEMS(1).AIRCRAFT KIND VALUE; 
SETUP'VALUES.LAUNCH TYPE :> LAUNCHER MENU ITEMS(2).LAUNCHER VALUE; 

TEMP REAL := LAUNCHER MENU ITENS(3).REAL VALUE; 

SETUP VALUES.INT ALTITUDE Tc :< TEMP REAL; 

SETUP'VALUES.INT MACH IC LAUNCHER MENU 1TEMS(4).REAL_VALUE; 
SETUP'VALUES.INT LEAo'aNGLE IC LAUNCHER MENU ITEMS(5).REAL VALUE; 
SETUP'VALUES.INT_CUIDANCE ;= LAUNCHER_MENU_ITEMS(6 ).INT_GUIOANCE_VALUE; 

Target paramters: 

SETUP VALUES.TGT TWO IC:«TGT MENU ITEMS(2).YES NO VALUE; 

SETUP VALUES.SOJ ONE IC:-TGT MENU ITEMS(4).YES NO'vALUE; 

SETUP VALUES.SOJ TW0“iC:»TGT"mENU“iTEMS(6).YES NO'vALUE; 

TEMP REAL TGTT MENU ITENS(1).REAL VALUE; 

SETUP VALUES.TGT ALTITUDE IC<1) :» l500.0*TEMP REAL; 

TEMP REAL :> TGT2 MENU ITEMSCD.REAL VALUE; 

SETUP VALUES.TGT ALTITUDE IC(2} :■ 1000.0*TEMP_REAL; 

TEMP REAL :« SOjT MENU ITEMS(1).REAL VALUE; 

SETUP VALUES.TGT ALTITUDE 1C(3) ;» 1000.0*TEMP REAL; 

TEMP REAL :« SOJ2 MENU ITENS(1).REAL VALUE; 


108 





SETUP VALUES.TGT ALTITUDE IC(4) ;= 1000.0*TEMP_REAL; 

SETUP VALUES.SOJ ANGLE IC(1):=SOJ1_MENU ITEMS(3).REAL VALUE; 

SETUP VALUES.SOJ ANGLE~IC(2):=SOJ2_NENU_ITENS<3).REAL VALUE; 
SETUP”VALUES.TGT~MACH Tc := TGT1 NENU_ITEMS(2).REAL VALUE; 
SETUpIvALUES.TGT'aSPECT IC ;= TGT1_MEMU_ITENS(3).REAL_VALUE; 

SETUP VALUES.TGT'rANGE Tc(1) := FEET PER NMl* 

TGT1 HENU ITEMS(4).REAL VALUE; 

SETUP VALUES.TGT RANGE Tc<2) TGT2 MENU ITENS(2).REAL VALUE; 
SETUp“vALUES.TGT~RANGE“iC{3) := FEET>ER NMI* 

SOJ1 MENU_ITEMS(2).REAL VALUE; 

SETUP VALUES.TGT RANGE Tc(4) := FEET PER NMI* 

SOJ2 MENU ITEMS(2).REAL VALUE; 

SETUP VALUES.TGT2 ANGLE~IC:=TGT2 MENU 1TENS(3).REAL VALUE; 

TEMP REAL:=TGT1 MENU ITEMSCID.REAL VALUE; 

SETUP VALUES.TGT BUILDUP TIME IC :=TEMP_REAL; 

SETUP~VALUES.TGT~RCS IC(T) :=~10.76*TGT1 MENU ITEMS(5).REAL VALUE; 
SETUP~VALUE3.TGT“rCS“ic<2) := 10.76*TGT2~MENU~1TEMS(4).REAL~VALUE; 
SETUP~VALUES.TGT“eCM“TECH IC(1);*TGT1 MENU_ITEMS(14).SSJ ECM_VALUE; 
SETUP VALUES.TGT~ECm"tECh“iC(2):=TGT2“mENU ITEMS(6).SSJ ECM VALUE; 
SETUP~VALUES.SOJ~ECM”teCh“iC(1);=SOJI'mENU"! TEMS(4).SOj"eCM“VALUE; 
SETUP'VALUES.SOj“eCm“tECh“iC< 2):=SOJ2~MENU~ITEMS(4).SOj"eCM“vALUE; 
SETUP“vALUES.TGT~ECM“P0WER IC(1):=TGTT_MENU ITEMS!15).real VALUE; 
SETUP'VALUES.TGT ECm“P0UER~IC(2):=TGT2_MEMU~ITEMS(7).REAL VALUE; 
SETUP~VALUES.TGT“eCM“P0WER“iC( 3):=SOJ1 MENU“lTEMS(5).REAL~VALUE; 
SETUP~VALUES.TGT ECM”POgER~IC(4):=SOJ2“MENU“lTEMS(5).REAL“vALUE; 
SETUP~VALUES.TGTT 1 R“sIZE 7= TGT1 MENU“lTEMS(6).TGT IR SIZE VALUE; 
SETUP~VALUES.TGT2 IR“sIZE :* TGT2“mENU“iTEMS(S).TGT~IR“sIZE“vALUE; 
SETUp'vALUES.MANEUVER KINO :• TGtT MENU ITEMS(7).MANEUVER VALUE; 
SETUP~VALUES.TGT TURn“g IC ;= TGTrMENu“lTEMS(8).REAL VALUE; 
SETUP'VALUES.TURN ON PARAMETER ~ 

TGT1_MENU !TEMS(9).MANEUVER START VALUE; 

SETUP VALUES.TGT TURNON VALUE IC T- TGT1 MENU ITEMS!10).REAL VALUE; 
SETUP~VALUES.TGT"tURM ANG IC 7= TGT1 MENU ITEMS!12).REAL VALUE; 
SETUP~VALUES.TGT“uEAVE per IC ;= TGTT menu ITEMS!13).real VALUE; 
APPLICATION.SIMULATION MAIN!SETUP VALUES); 
end START RUN; 


function 01SPLAr_MEMUtMENU ; MENU_POINTER; ITEM_NUM : integer) 
return integer is 

ITEM ! MEMU_ITEM_POINTER; 

ROW : integer; 

NUM_ITENS : integer; 
begin 

SYSTEM SPECIFIC.CLEAR SCREEN; 

SYSTEM^SPECIFIC.ORAU_BbX; 

SYSTEM_SPECIFIC.PUT_STRING! 2, 10, MENU.TITLE); 
if MENU s MAIN MENU then 

SYSTEM_SPECIFIC.PUT_STRING!22, 5. "Use the up and down « & 
"arrow keys to move the cursor and then press ENTER"); 

end if; 

ITEM :> MENU.FIRST ITEM; 

ROW :> MENU START ROU; 

NUM.ITEMS :> 0; 
while ITEM /a null loop 

if NUM ITEMS « ITEM NUM then 

SYSTEM_SPECIFIcTrEVERSE_VIDEO_ON; 
end if; 

SYSTEM_SPECIFIC.PUT_STRIMG! ROW, 10, ITEM.TITLE); 
if NUM ITEMS * ITEM NUM then 

system_specific7reverse_vioeo_off; 

end if; 


109 







if ITEM.ITEM KINO ^ DATA ITEM then 
case ITEH.DATA_TYPE is 
when NONE => 
null; 

uhen TEXT => 

SYSTEM SPECIFIC.PUT STRING( ROU, DATA COLUMN, 

ITEN.TEXT VALUE); 
when FLOATING PT => 

SYSTEM SPECIFIC.PUT_REAL< ROW, DATA COLUMN, 

ITEM.REAL VALUE); 
when YES NO => 

SYSTEM_SPECIFIC.PUT_STRING( ROW, DATA_COLLIMN, 

YES NO TYPE'imaged TEN. YES NO_VALUE)); 
when INT_GuTdANCE => 

SYSTEM SPECIFIC.PUT STRING( ROW, DATA COLUMN, 

INT GUIDANCE_TYPE'ifflagedTEN.INT_^IDANCE VALUE)); 
when TGT IR SIZE «> 

SYSTEN_SPECIFIC.PUT_STRING( ROW, DATA COLUMN, 

TGT IR SI ZE_TYPE'imaged TEN. TGT IR SIZE VALUE)); 
when MANEUVER »> 

SYSTEM SPECIFIC.PUT_STRING( ROW, DATA COLUMN, 

MANEUVER TYPE'imagedTEN.MANEUVERiVALUE)); 
when MANEUVER START => 

SYSTEM SPECIFIC.PUT_STRIHG( ROW, DATA COLUMN, 

MANEUVER START TYPE'imagef 

ITEMTmANEUVER start VALUE)); 
when AIRCRAFT KIND ~ ~ 

SYSTEM SPECIFIC.PUT STRIHG< ROW, DATA COLUMN, 

AIRCRAFT TYPE'image( 

ITEMTaIRCRAFT_KIND VALUE)); 
when LAUNCHER -> 

SYSTEM SPECIFIC.PUT STRING< ROW, DATA COLUMN, 

LAUNCHER TYPE'imagef 

ITEmTlAUNCHER VALl«)); 
when SSJ ECM » 

SYSTEM SPECIFIC.PUT STRINGL ROW, DATA COLUMN, 

SSJ ECM TYPE'imagedTEN.SSJ ECM VALUE)); 
when SOJ ECM »> 

SYSTEM SPECIFIC.PUT STRIMG< ROW, DATA COLUMN, 

SOJ_ECM_TYPE'image(ITEN.SOJ_ECM_VALUE)); 
end case; ~ 

end if; 

ROW := ROW * MENU.ROWS BETWEEN ITEMS; 

ITEM := ITEM.NEXT ITEmJ 
NUM_ITEMS := NUMJTEMS ♦ 1; 
end loop; 

if MENU 3 main menu then 

SYSTEM_SPECIFIC.PUT_STRING( ROW, 10, QUIT_STRING); 

else 

SYSTEM_SPECIFIC.PUT_STRING( ROW, 10, RETURN_STRING); 
end if; 

return NUN ITEMS; 
end DISPLAY_MENU; 


procedure MANAGE NENU(NENU : MENU POINTER) is 
ITEM : MENUJTEM_POINTER; 

ROW : integer; 

ITEM NUM : integer :« 0; 

NUM Items : integer; 

COMMAND : SYSTEN_SPECIFIC.MENU_COMMAND; 
STATUS_0K : boolean; 
begin 

NUM_ITEMS :« DISPLAY_MENU(NENU, ITEN_NUN); 
ROW :» MENU_START^ROW; 


110 







ITEM ;= MEMU.FIRST_ITEM; 
loop 

COMMWIO ;= SYSTEM_SPECIFIC.GET_MEMU_CQMMAMO; 

if MESSAGE DISPLAYED then 

SYSTEM'sPECIFIC.PUT STRING(22. 10, BLANK_STRING>; 
MESSAGE_DISPLAYED := false; 
end if; 


case COMMAND is 


Mhen SYSTEM SPECIF IC.UP ARROW => 
if ITEM~NLIM » NUM ITEMS then 
if MENU = MAIN MENU then 

SYSTEM_SPECIFIC.PUT_STRING( ROW, 10, QUIT_STR1NG); 

else 

SYSTEM_SPECIFIC.PUT_STRING( ROW, 10, RETURN_STRING) 
end if; 

ROW := ROW - MENU.ROWS BETWEENJTEMS; 

ITEM NUM := ITEM NUM -“l; 

ITEM := MENU.FIRST ITEM; 
for I in 0..ITEM NUM-1 loop 
ITEM := ITEm7mEXT_ITEM; 
end loop; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 

SYSTEm'sPECIFIC.PUT STrTnGC row, 10, ITEM.TITLE); 
SYSTEM~SPECIFIC.REVERSE VIDEO OFF; 
elsif ITEm“nuM = 0 then 

SYSTEM'SPECIFIC.PUT STRINGf ROW, 10, ITEM.TITLE); 

ROW :»"mENU_START row ♦ NUM_ITEMS * 

MENU.ROWS BETWEEn'iTEMS; 

ITEM NUM := NUM ITEMS; 

SYSTEM SPECIFIcTreVERSE VIDEO ON; 
if MENU = MAIN MENU then 

SYSTEM_SPECIfIC.PUT_STRING( ROW, 10, OUIT_STRIMG); 

else 


SYSTEM_SPECIFIC.PUT_STRING( ROW, 10, RETURN.STRING) 
end if; 

SYSTEM_SPECIFIC.REVERSE_VIDEO_OFF; 

else 

SYSTEM SPECIFIC.PUT STRINGf ROM, 10, ITEM.TITLE); 

ROW :3*'roW • MENU.ROWS BETWEEN ITEMS; 

ITEM NUM := ITEM_NUM -"l; 

ITEM~;s MENU.FIRST ITEM; 
for I in 0..ITEM NUM-1 loop 
ITEM ITEM.NEXTJTEM; 
end loop; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 

SYSTEM'SPECIFIC.PUT STRTnG( ROW, 10, ITEM.TITLE); 
SYSTEm'sPECIFIC.RE vfRSE_VIOEO_OF F; 
end if; ' 


when SYSTEM SPECIFIC.DOWN ARROW » 
if ITEM NUM < NUM ITEMS-1 then 

SYSTEM SPECIFIC.PUT STRING! ROM, 10, ITEM.TITLE); 

ROW :>'rOW ♦ MENU.ROM BETWEEN ITEMS; 

ITEM NUM ITEM NUM > 1; 

ITEM~:s ITEM.NEXT ITEM; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 

SYSTEM'SPECIFIC.PUT STrTnG! ROM, 10, ITEM.TITLE); 
SYSTEm'SPECIFIC.REVERSE VIDEO OFF; 
elsif ITEm'nUM < NUM ITEMS-! then' 

SYSTEM'SPECIFIC.PUT STRING! ROM, 10, ITEM.TITLE); 

ROW :«~ROU *■ MENU.ROWS BETWEEN ITEMS; 

ITEM IftJM :» ITEM NUM ♦“l; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 
if MENU ■ MAIN MENU then 

SYSTEM_SPECIFIC.PUT_STRING! ROW, 10, QUIT_STRING); 

else 

SYSTEM_SPECIFIC.PUT_STRING! ROW, 10, RETURN_STRING) 


111 







end if; 

SYSTEM SPECIFIC.REVERSE_V10EO_OFF; 
else -- ITEM NUM - NUM_1TEMS 
if MENU = MAIN MENU then 

SYSTEM_SPECIFIC.PUT_STRING( ROU, 10, QUIT_STRING); 

else 

SYSTEM_SPECIFIC.PUT_STRING( ROW, 10, RETURN_STR1NG); 
end if; 

ROU := MENU START_ROU; 

ITEM := MENU.FIRST ITEM; 

1TEM_NUM := 0; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 

SYSTEM'sPECIFIC.PUT STrTnG( ROM, 10, ITEM.TITLE); 
SYSTEM“sPECIFIC.REVERSE_VIDEO_OFF; 
end if; 

when SYSTEM SPECIFIC.ENTER KEY => 
if ITEM NUM a nuM ITEMS then 
if MENU = MAIN MENU then 

SYSTEM_SPECIFIC.OUIT_PROGRAM; 

else 

return; 
end if; 

else 

case ITEM.ITEM KINO is 
when SUBMENU -> 

MANAGE MENUCITEM.NEXT MENU); 

NUM ITEMS ::: DISPLAY_i^NU(MENU, 1TEM_NUM); 
when DATA ITEM => 

case TtEM.DATA type is 
when NONE => 
null; 

when TEXT » 

GET TEXTCITEM.PROMPT, ITEM.TEXT VALUE); 
SYSTEM SPECIFIC.PUT STRINGIROU, 

DATA COLINW, ITEM.TEXT VALUE); 
when FLOATING PT »> 

GET REALUTEM.PROMPT, ITEM.REAL VALUE); 
SYSTEM SPECIFIC.PUT REAL{ ROU, 
OATA_CaUMM, !TEM.REAL_VALUE); 
when YES MO => 

if ITEM.YES_NO_VALUE /= YES_NO_TYPE'last 
then 

ITEM.YES NO VALUE := 

YES_NO TYPE”succ( 

ITEM.YES_MO_VALUE); 

else 

ITEM.YES NO VALUE := 
YES_NO_TYPE'first; 
end if; ” 

SYSTEM SPECIFIC.PUT STRINGl ROU, 

DATA COLUMN, BLANK STRING( 

T..YES NO TYPE”width)); 

SYSTEM SPECIFIC.PUT STRINGC ROU, 

DATA COLUMN, YES NO TYPE'imagel 
TtEM.YES NO_VALUE)); 
when INT GUIDANCE 

if ITEM.INT_GUIDANCE VALUE /= 

INT GUIDANCE TYPE'last then 
"ITEM.INT^GUIDANCE VALUE := 

INT GUIDANCE TVPE~succ( 

“item.int3guidance_value); 

else 

ITEM.INT GUIDANCE VALUE :> 
INT_GUIOANCE_TVPE“first; 
end if; 

SYSTEM SPECIFIC.PUT STRING! ROU, 

DATA COLUMN, BLANK STRING! 

T..INT GUIDANCE TYPE'width)); 


112 





SYSTEM_SPECIFIC.PUT_STRING( ROW, 
DATA_COLtJMM, 

INT_GUIDAMCE_TYPE'imageC 

ITEH.INT_GU1DANCE_VALUE}); 
when TGT IR SIZE => 

if itemTtgt IR_SIZE_VALUE /= 

TGT lR_SIZE_TYPE'last then 
"item.TGT IR SIZE VALUE := 

TGT IR sTze“tYPE’SUCC( 

“item.TGT_IR_SIZE_VALUE); 

else 

ITEM.TGT IR_SIZE_VALUE := 
TGT_IR_sTzE_TYPE• first; 
end if; 

SYSTEM SPECIFIC.PUT_STRING( ROW, 
OATA_COLUHN, BLANK STRINGC 

1..TGT IR SIZE“TYPE'width)); 
SYSTEM SPECIFIC.pGt_STRING( ROW, 

DATA COLUMN. 

TGT_Tr SlZE_TYPE‘iinBge( 

ITEN.TGT IR_SIZE VALUE)); 
when MANEUVER -> ~ 

if ITEM.MANEUVER_VALUE /= 
MANEUVER_TYPEUast then 
ITEM.MANEUVER VALUE := 

MANEUVER TYPE~succ( 

ITEMTmANEUVER_VALUE); 

else 

ITEM.MANEUVER VALUE 
MANEUVER_TYPE“first; 
end if; 

SYSTEM SPECIFIC.PUT STRING! ROW, 

DATA COLUMN, BLANK STRING! 

T. .MANEUVER TYPE'width)); 
SYSTEM SPECIFIC.PUT"sTRING! ROW, 

DATA COLUMN, MANEUVER TYPE'image! 
TtEM.MANEUVER VALUE)); 
when MANEUVER START » 

if ITEM.MANEUVER START_VALUE /* 
MANEUVER START TYPE'last then 

itemTmaneuver start value 

MANEUVER START TYPE“succ! 

I temTmaneu^r_start..value ) ; 

else 

ITEir.NANEUVER_START VALUE : = 
MANEUVER_START_TYPE“first; 
end if; 

SYSTEM SPECIFIC.PUT STRING! ROW, 

DATA COLUWl, BLANK STRING! 

T..MANEUVER START TYPE'width)) 
SYSTEM SPECIFIC.PUT^STRINC! ROM, 

DATA COLUMN, 

MANEUVER START TYPE'image! 

ITEMTmANEU^R start VALUE)); 
when AIRCRAFT_KINO » 

if ITEM.AIRCRAFT KINO VALUE /= 
AIRCRAFT TYPE* last thm 

itemTaircraft KIN0_VALUE := 
AIRCRAFT TYPE'succ! 

ItemTaIRCRa F T_KIN0_VALUE); 

else 

1TEM.AIRCRAFT_KIN0_VALUE := 

AIRCRAFT_TYPE'first; 
end if; 

SYSTEM SPECIFIC.PUT STRING! ROW, 

DATA COLUMN, BLANK STRING! 

T.. AIRCRAFT TYPE'width)); 
SYSTEM SPECIFIC.PUT'sTRING! ROM, 

DATA COLUMN, 


113 






AIRCRAFT TYPE'imageC 

1TEM. AI RCRAFT_IC I ND_VALUE )) ; 
when LAUNCHER => 

if ITEM.LAUNCHER_VALUE 
LAUNCHER_TYPE'l8St then 
ITEM.LAUNCHER_VALUE := 

LAUNCHER TYPE*succ( 

1 TE»»TlAONCHER_VALUE ) ; 

else 

ITEH.LAUNCHER_VALUE := 
LAUNCHER_TYPE'first; 
end if; 

SYSTEM SPECIF1C.PUT_STR1NG( ROW, 
DAfA_COLlMN, BLANK STRING( 

1..LAUNCHER TYPE'width)); 
SYSTEM SPECIFIC.PUT_STRIMG{ ROW, 

DATA COLUMN. 

LAUNCHER TYPE*image! 

ITEmTlAUNCHER VALUE)); 
when SSJ ECM »> 

if item.ssj_ecm value /= 

SSJ ECM TYPE‘last then 
"lTEM.SSJ_ECM VALUE := 
SSJ_ECM_TYPE'succ( 

ITEM.SSJ_ECM_VALUE); 

else 

ITEM.SSJ_ECM_VALUE := 

SSJ_ECM_TYPE'first; 
end if; 

SYSTEM SPECIFIC.PUT STRING! ROW, 

DATA COLUMN. BLANK_STRING! 

T..SSJ ECM TYPE'width)); 

SYSTEM SPECIFIC.PUT STRING! ROW, 

DATA COLUMN, 

SSJ ECM TYPE*image! 

"ITEM.SSJ ECM VALUE)); 
when SOJ ECM <:> 

if ITEM.SOJ ECM.VALUE /= 

SOJ ECM TYPf'last then 
"item.SOJ ECM_VALUE := 

SOJ ECM TYPE'succ! 

~I TEM.SOJ_ECM_VALUE); 

else 

ITEM.SOJ_ECM_VALUE := 
SOJ_ECM_TYPE*first; 
end if;~ 

SYSTEM SPECIFIC.PUT_STRING! ROW, 

DATA COLUMN, BLANK STRING! 

T..SOJ ECM TYPE'width)); 

SYSTEM SPECIFIC.PUT_STRIMG! ROW, 

DATA COLUMN, 

SOJ ECM TYPE*image! 

~ITEM.SOJ_ECM_VALUE)); 

end case; 
when ACTION => 

case ITEM.ACTION_KINO is 
when LOAO_OATA *> 

STATUS OK ;= LOAD_DATA_FILE; 
if STATUS_OK then 

NUN ITEMS :> OISPLAY_MENU!NENU, 

“item NUM); 

SYSTEM_SPECIFIC.PUT_STRING!22, 10, 
"File loaded successfully"); 
MESSAGE_D1SPLAYED :* true; 
end if; 

when SAVE DATA *> 

STATUS OK :» SAVE DATA FILE; 
if STATUS OK then 

SYSTEM SPECIFIC.PUT STRING!22, 10, 


114 


"File saved successfully"); 

NESSAGE.DISPLAYED true; 
end if; 

when START RUN -> 

START_RUM; 

NUM_ITEMS 01SPLAY_HENU(HENU, 

"item MUM)* " 

when GRP1 GRAPHI => -- Elev. View of Traj 
PLOf.OO GRAPH(21); 

NUM ITEMS*DISPLAY MENU(MENU. 
“ITEM_NIJM); 

when GRP1_GRAPH2 => -- Plan View of Traj 
PLOT.OO_GRAPH{22); 

NUM ITEMS := DISPLAY_MENU(MENU, 
“lTEM_MUM); 

when GRP1_GRAPN3 => -- Msl-Tgt Range Rate 
PLOT.OO_GRAPH(r); 

NUM_ITEMS := DISPLAY_MENU(MENU, 

~1TEM NUM)* 

when GRP1_GRAPH4 »> — Msl-Tgt Range 
PLOT.00 GRAPH(6); 

NUM ITEMS*DISPLAY MENUCMENU, 

*ITEM MUM); 

when GRP1_GRAPH5 => -- LOS Angle Rates 
PLOT.OO GRAPHdO); 

NUM ITEMS DISPLAY_MENU(MENU, 
~ITEM_MUM); 

when GRP1 GRAPH6 => -* Tgt Heading Angle 
PLOf.OO GRAPM(25); 

NUM ITEMS DISPLAY MENU(MENU, 
*ITEM_NUM); 

when GRP1 GRAPH7 => -- Launch A/C-Tgt Range 
PLOf.DO GRAPH(I); 

NUM_ITEMS*OISPLAY_MENU(MENU, 

*ITEM NUM)* 

when GRP2 GRAPHI => -• Msl. Mach 
PLOf.OO GRAPH(S); 

NUM ITEMS* :> DISPLAY MENUCMENU, 

*ITEM NUM); 

when GRP2 GRAPH2 "> -- Msl. Velocity 
PLOf.DO GRAPH(2); 

NUM ITEMS := DISPLAY_MENU(MENU, 

*ITEM NUM); 

when GRP2 GRAPHS "> -- Msl. Alt. Rate 
PLOf.DO GRAPH(II); 

NUM ITEMS := DISPLAY_MENU(MENU, 
*ITEM_IWM); 

when GRP2 GRAPH4 *> -- Msl. Pitch Angle 
PLOf.DO GRAPH(4); 

NUN ITEMS* ;= DISPLAY_MENU(MEMU, 
*ITEM_NUM); 

when GRP2 GRAPHS »> -- Msl. Yaw Angle 
PLOf.OO GRAPH(3); 

NUM ITEMS* :> DISPLAY_MENU(MENU. 
*ITEM_MUM); 

when GRP3 GRAPHI => -- Msl. Thrust 
PLOf.DO GRAPH(16); 

NUM ITEMS* :> DISPLAY MENUCMENU, 

*ITEM NUM); 

when GRP3 GRAPH2 » -• Msl. Fuel Mass 
PLOf.OO_GRAPHC14),* 

NUM ITEMS OISPLAY_MENUCMENU, 
*ITEM_MUM),* 

when GRP3 GRAPHS => -- Msl. Fuel Rate . 
PLOf.OO GRAPHC17); 

NUM ITEMS :« OISPLAY_MENUCMENU, 

*ITEM NUM); 

when GRP4 GRAPHI » -- Msl. Acc. Cmds. 
PLOf.OO GRAPHC12); 


115 







NUN ITENS DISPLAY HENU(HENU, 
ITEH_NUN); 

uhen GRP4 GRAPH2 » -- hsI. Ach. Acc. 
PL0f.D0_GRAPH(13); 

NUM_tTEMS~DISPLAY NENU(MENU, 
ITEM_NUN); 

uhen GRP4_GRAPH3 => -- Msl. Alpha 
PL0T.D0_GRAPH(18>; 

NUNJTENS DISPLAY HENU(MENU, 
ITEN_MUN); 

when GRP4_GRAPH4 => -- Msl. Weight 
PL0T.D0_GRAPH<15); 

NUH ITEMS :s DISPLAY_MENU(MENU, 
■lTEM_NUM); 

uhen GRP4 GRAPHS » •- hsI. Skr. Angles 
PLOf.DO GRAPH(9); 

NUM_ITEMS :* DISPLAY MENUIMENU, 

ITEM NUN); 

when GRP4_GRAPH6 => — Msl. RF SNR 
PL0T.D0_GRAPH(19>; 

NUM items' :« DISPLAY MENUIMENU, 
ITEM_NUN); 

when GRP4 GRAPH? => -- Msl. Drag Coef. 
PLOf.OO_GRAPH(20); 

NUM ITEMS :* DISPLAY MENUIMENU, 
ITEM_NUN); 

end case; 
end case; 
end if; 

when others => 
null; 
end case; 
end loop; 
end MANAGE_MENU; 


procedure MAIN is 
begin 

MANAGE MENU(MAIN MENU); 
end MAIN; 


procedure DRAW_RUNTINE_BORDER is 
begin 

SYSTEM_SPECIFIC.DRAW_BOX; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 

SYSTEM SPECIFIC.PUT STrTnG( 0, 19, MISSILE.RUNTIME TITLE); 
SYSTEm“sPECIFIC.PUT_STRIMG( 24, 25," Press space bar to pause run "); 
SYSTEM SPECIFIC.REVERSE VIOEO_OFF; 
end DRAW RUNTIME BORDER; 


procedure SETUP_RUNTIME_SCREEN is separate; 


procedure SETUP_NENU_DATA is separate; 


task body KEYBOARD_HANOLER is separate; 
begin 

SETUP MENU DATA; 
end USERJNTERFACE; 

-- User Interface Package Subunit 

-- This subunit contains all the data describing the user interface. 


116 

















separate (USER_INTERFACE) 


procedure SETUP_MENU_DATA is 
begin 


■■ Graph Group 4 Main Menu 

GRAPH_GRP4_HENU_ITEMS(7) := new HENU_ITEM_TYPE'(ITEM_KIND => ACTION, 
TITLE => "Msl Drag Coefficient ", 

DATA_TYPE => NONE, NEXT_ITEM => null, ACT10N_ICIND => GRP4_GRAPH7); 

GRAPH_GRP4 MENU_ITEMS(6) := new MENU ITEM_TYPE'(ITEM KIND => ACTION, 
TITLE => "Msl RF S/N Ratio ~ ", 

DATA TYPE => NONE, NEXT ITEM => GRAPH_GRP4_MENU_ITEMS(7), 
ACTIOM_KINO => GRP4_GRAPH6); 

GRAPH_GRP4_MENU_ITEMS(5) := new MENU_ITEM_TYPE'(ITEM_KIND => ACTION, 
tTtlE => "Msl Seeker GinR>al Angles ", 

DATA TYPE => NONE, NEXT ITEM => GRAPH_GRP4_MENU ITEMS(6>, 
ACTION_KIND => GRP4_GRAPH5); 

GRAPH GRP4_MENU ITEMS(4) := new MENU ITEM TYPE'(ITEM_KIND => ACTION, 
tTtlE => "Msl Weight ~ “ ", 

DATA TYPE => NONE, NEXT_ITEH => GRAPH GRP4 MENU ITEMSlS), 
ACTION_KINO => GRP4_GRAPH4); 

GRAPH GRP4 MENU ITEMS(3} := new MENU ITEM TYPE'dTEM KIND => ACTION, 
tTtLE => "Msl Angle of Attack ~ 

DATA TYPE => NONE, NEXT ITEM => GRAPH GRP4 MENU ITEMS(4), 
ACTi5n_KIN0 *> GRP4_GRAPH3); 

GRAPH_GRP4_MENU_ITEMS(2) :* new MENU_ITEM_TYPE'<ITEM_KIND => ACTION, 
tTtle a> "Msl Achieved AcceleratTon ~ ", 

DATA TYPE »> HONE, NEXT ITEM => GRAPH GRP4 MENU ITEMS(3), 
ACTION_KIND *> GRP4_GRAPH2); 

GRAPH_GRP4_MEMU_ITEMS<1) := new MENU_ITEM_TYPE'(ITEM_KINO => ACTION, 
tTtle => "MsI Acceleration Commands ", 

DATA TYPE » NONE, NEXT ITEM »> GRAPH GRP4 MENU_ITEMS(2), 
ACTtON_KIND => GRP4_GRAPH1); 

GRAPH_GRP4_MENU ;= new MEMU_TYPE’(TITLE => 

" Msl Parameter Graph Menu ", 

FIRST_1TEM => GRAPH_GRP4_MENU_ITEMS<1), ROWS_BETWEEN_ITEMS => 2); 

-- Graph Group 3 Main Menu 

GRAPH GRP3_MENU ITEMS(3} :> new MENU ITEM TYPE'(ITEM_KIND => ACTION, 
tTtle -> "MsI Fuel Flow Rate ~ “ ", 

0ATA_TYPE »> NONE, NEXT_ITEM => null, ACTION_KIND => GRP3_GRAPH3); 

GRAPH GRP3 MENU ITENS(2) new MENU ITEM TYPE>(ITEN_KIND => ACTION, 
tTtLE »> "Msl Fuel Weight ~ “ 

DATA TYPE <> NONE, NEXT ITEM => GRAPH GRP3_MENU ITEMS(3), 
ACTIOM_KIND «> GRP3_CRAPH2); 

GRAPH GRP3 MENU ITENS(I) :> new MENUJTEM TYPE'CITEM KINO » ACTION, 
tTtle »> "msI Thrust ~ ", 

OATA_TYPE » NONE, NEXT ITEM ■» GRAPH GRP3_MENU ITEMS(2), 
ACTION_KIND => GRP3_GRAPH1); 

GRAPH_GRP3_MENU new l«NU_TYPE'(TITLE => 

" Msl Propulsion Graph Menu ", 

FIRST_ITEM => GRAPH_GRP3_MEMU_ITEMS(1), ROWS_BETWEEN_ITEMS »> 2); 


117 










-- Graph Group 2 Main Menu 

GRAPH GRP2 MENU ITEMS(5) new MENU_ITEM TYPE'dTEM KINO => ACTION. 
TITLE => "Msl Yaw Angle “ 

DATATYPE => NONE. NEXT_ITEM => null, ACTION_KINO => GRP2_GRAPH5); 

GRAPH GRP2 MENU_ITEMS(4) := new MENU ITEM_TYPE>(ITEM KIND => ACTION, 
tTtLE => “Msl Pitch Angle “ “ 

DATA TYPE -> NONE, NEXT ITEM » GRAPH GRP2 MENU ITEMSCS), 
ACTION_KIND => GRP2_GRAPH4); 

GRAPH GRP2 MENU ITEMS(3) := new MENU ITEM TYPE'dTEM KIND => ACTION, 
tTtlE *> "Msl Altitude Rate “ “ 

DATA TYPE => NONE, NEXT ITEM => GRAPN_GRP2 NENU_ITENS(4>, 
ACTIOM_KIND => GRP2_CRAPH3); 

GRAPH GRP2 MENU ITENS(2) := new NENU_ITEN TYPE'dTEM KIND => ACTION, 
tTtlE => “Msl Velocity ~ “, 

DATA TYPE => NONE, NEXT ITEM => GRAPH GRP2 MENU_ITEMS(3), 
ACTIOM_KIMD »> GRP2_GRAPH2); 

GRAPH GRP2_MENU ITEMSd) := new MENU ITEM_TYPE'dTEM_KIND ACTION. 
tTtLE => “Msl Mach Nunter “ “, 

DATA TYPE => NONE, NEXT ITEM => GRAPH GRP2 MENU_ITEMS(2), 
ACTi5n_KIND => GRP2_GRAPH1); 

GRAPH_GRP2_MEMU := new MEMU_TYPE'(TITLE => 

Msl Kinematics Graph Menu ”, 

FIRST_ITEM GRAPH_GRP2_MENU_ITEMSd), R0US_8ETUEEN_1TEMS »> 2>; 

■■ Graph Group 1 Main Menu 

GRAPH_GRP1_MENU_ITEMS<7) new MEMU_ITEM_TYPE'dTEM_KIMO => ACTION, 
tTtLE => “Launch A/C-Tgt Range ~ 

DATATYPE => NONE, NEXT_ITEM => null, ACTION.KINO » GRP1_GRAPH7); 

GRAPH GRP1 MENU 1TEMS(6) new MENU ITEM TYPE'dTEM KIND «> ACTION, 
TITLE «> "Tgt Heading Angle “ “ 

DATA TYPE » NONE, NEXT ITEM => GRAPH GRP1 MENU ITEMS(7), 
ACTIOM_KINO => GRP1_GRAPH6); 

GRAPH_GRP1_MENU_ITEMS<5) ;» new MENU ITEM TYPE'dTEM KIND => ACTION, 
tTtLE => “Msl-Tgt LOS Angle Rates " ", 

DATA TYPE «> NONE, NEXT ITEM => GRAPH GRP1 MENU ITEMS(6). 
ACTION_KINO => GRP1_GRAPH5); 

GRAPH GRP1 MENU ITENS(4) new MENU ITEM TYPE'dTEM KINO => ACTION, 
tTtle => "Msl-Tgt Range “ ", 

DATA TYPE » NONE, NEXT ITEM -> GRAPH GRP1 MENU ITEMS(5), 
ACTION_KIHO => GRP1_GRAPH4); 

GRAPH GRP1 MENU ITEMS(3) := new MENU ITEM TYPE'dTEM_KIND => ACTION, 
tTtle »> "Msl-Tgt Range Rate " ", 

DATA TYPE => NONE. NEXT ITEM » GRAPH GRP1 MENU ITEMS(4), 
ACTIOH_KIND »> GRP1_CRAPH3); 

GRAPH_GRP1_MENU_ITEMS(2) :■ new MENU_ITEM_TYPE'dTEM_KIND => ACTION, 
tTtle »> "PTan view of trajectory ~ ", 

DATA TYPE » NONE, NEXT ITEM » GRAPH GRP1_NENU ITENS(3), 
ACTION.KINO «> GRP1_GRAPN2); 

GRAPH_GRP1_MEMU_ITEMS(1) :« new MEMU_ITEM_TYPE'dTEM_KINO => ACTION, 
tTtle *> "Elevation view of trajectory ", 

DATA TYPE » NONE, NEXT ITEM » GRAPH_GRP1 MENU ITEMS(2), 
ACTION_KINO »> GRP1_GRAPH1); 

GRAPH_GRP1_MENU :« new MENU_TYPE'(TITLE »> 

" Msl-Tgt Geometry Graph Menu ”, 

FIRST_ITEM «> GRAPH_GRP1_MENU_ITEMS(1), ROWS_BETWEEM_ITEMS *> 2); 


118 







-- Graph Main Menu 

GRAPH_MEMUJTEMS(4) := new MEMU_ITEM_TYPE'(ITEM_KIMO => SUBMENU, TITLE => 
"Msl Parameter Graph Menu ~ "7 

DATA_TYPE => NONE, NEXT_ITEM => null, NEXT_MENU => GRAPH_GRP4_MENU); 

GRAPH_MENU_ITEMS(3) ;= new MENU_ITEM_TYPE‘(ITEM_XIND => SUBMENU, TITLE => 
"Msl Propulsion Graph Menu "7 

DATA TYPE => NONE, NEXT ITEM => GRAPH MENU tTEMS(4). NEXT MENU => 
GRAPH_GRP3_MENU); 

GRAPH_MENU_ITEMS(2) := new MENU_ITEM_TYPE'(1TEM_KIN0 => SUBMENU, TITLE => 
"Msl Kinematics Graph Menu ", 

DATA TYPE NONE, NEXT ITEM => GRAPH MENU ITEMS(3), NEXT MENU => 
GRAPH_GRP2_MENU); 

GRAPH_MEMU_ITEMS<1) := new MENU_ITEM_TYPE'(ITEM_KINO => SUBMENU, TITLE => 
"Msl-Tgt Geometry Graph Menu "7 

DATA_TYPE => NONE, NEXT ITEM => GRAPH_MENU_ITEMS(2), NEXT MENU => 
GRAPH_GRP1_MEHU); 

GRAPH_MENU := new MENU_TYPE'(TITLE => 

" Graph Menus ", 

FIRST_ITEM => GRAPH_MENU_ITEMS(1), ROUS_BETWEEM_ITEMS => 2); 

-- SOJ 2 Parameter Menu 

SOJ2 MENU ITEMS(5) new MENU ITEM TYPE•(ITEM KIND » DATA ITEM, 

TITLE s> "SOJ ERPD, dBW/MHz: "7 

PROMPT 3> "Enter SOJ ERPO (dBU/MHz): ", 

REAL VALUE "> 30.0, MAX VALUE -> 200.0, MIN VALUE "> 0.0, 

DATA_TYPE => FLOATIMG_PT, NEXT_ITEM => null); 

SOJ2 MENU ITEMS(4) new MENU ITEM TYPE'dTEM KIND => DATA ITEM, 

TITLE »> "SOJ ECM technique: ",” 

SOJ ECM VALUE «> BARRAGE NOISE, 

PROMPT »> " ", 

DATATYPE => SOJ_ElM, NEXT_ITEM => SOJ2_MEMU_ITEMS(5)>; 

S0J2_MEMU_ITEMS<3) := new MEMU_ITEM_TYPE‘<ITEM_KIND => DATA_ITEM, 

TITLE s> "Look angle rel. to LAC, deg: ", 

PROMPT => "Enter angle (deg}(>right}: ", 

REAL VALUE => 0.0, MAX VALUE => 90.0, MIN VALUE => -90.0, 

DATA_TYPE => FLOATING_PT, MEXT_ITEM => SOJ2_t«NUJTEMS(4)); 

S0J2 MENU ITEMS(2) := new MENU ITEM TYPE'(ITEM_KIN0 » DATA ITEM, 

TITLE => "Range from launch A/C, NMI: ", 

PROMPT *> "Enter distance (NMI): ", 

REAL VALUE => 150.0, MAX VALUE » 500.0, MIN VALUE => 0.0, 

0ATA_TVPE => FLOATING_PT, NEXT_ITEM => SOJ2_MEMU_ITEMS{3)); 

SOJ2 MENU ITEMSd) := new MENU ITEM TYPE'(ITEM_KIND => DATA ITEM, 

TITLE“»> "SOJ altitude, kft: ” ", 

PROMPT »> "Enter altitude (kft): ", 

REAL VALUE "> 30.0, MAX VALUE » 150.0, MIN VALUE => 0.0, 

0ATA_TYPE "> FLaATINC_PT, NEXT_ITEM »> S0J2_MEMU_1TEMS(2)); 

SOJ2_MENU :> new NENU_TYPE'(TITLE "> 

" SOJ 2 Parameter Menu ", 

FIRST_ITEM => SOJ2_MENU_ITEMS(1), ROUS_BETWEEN_ITEMS => 2); 

-- SOJ 1 Parameter Menu 

SOJ1 MENU ITEMS(5) :> new MENU ITEM TYPE'CITEM KIND => DATA ITEM, 

TITLE »> "SOJ ERPO, dBW/MHz: ” 

PROMPT » "Enter SOJ ERPO (dBW/MHz): ", 

REAL VALUE » 30.0, MAX_VALUE » 200.0, MIN VALUE » 0.0, 

DATA'tYPE ■> FLOATING PT, NEXT ITEM *> null); 


119 







S0J1 MENU ITENS{4) :> new MENU ITEM TYPE‘(ITEN KINO »> DATA ITEM, 

TITLE «> "SOJ ECM technique; 

SOJ ECM VALUE -> BARRAGE_NOISE, 

PROMPT »> " 

0ATA_TYPE => SOJ_ECM, NEXT_ITEM »> SOJ1_MEMU_ITEMS(5»; 

S0J1_MENU_ITEMS{3) := new NEMU_ITEM_TYPE'<ITEM_KIND => DATA_ITEM, 

TITLE “> “Look angle rel. to LAC, deg: 

PROMPT => "Enter angle (degTl-right): ", 

REAL VALUE => 0.0, MAX VALUE => 90.0, MIN_VALUE => -90.0, 

0ATA_TYPE => FLOATIMG_PT, NEXT_ITEM => SOJ1_MEMU_ITEMS(4)); 

S0J1_MEMU_ITEMS(2) ;= new MENU_1TEM_TYPE'<ITEM_KIM0 => 0ATA_ITEM, 

TITLE »> "Range from launch A/C, NMl: ",~ 

PROMPT s> "Enter distance <NMI}: ", 

REAL VALUE => 1S0.0, MAX VALUE -> 500.0, MIN_VALUE => 0.0, 
DATA_TYPE => FLOATINO_PT, NEXT_ITEM => SOJ1_MENU_ITEMS(3»; 

SOJ1 MENU ITEMS(I) := new MENU ITEM TYPE‘(ITEM KIND »> DATA_ITEM, 

TITLE => "SOJ altitude, kft; ", 

PROMPT *> "Enter altitude <kft): ", 

REAL VALUE » 30.0, NAX_VALUE => 150.0, MIN_VALUE »> 0.0, 

0ATA_TYPE => FLOATING_PT, NEXT_ITEM »> SOJ1_MENU_ITEMS(2)); 

SOJI MENU new MENU TYPE'(TITLE » 

" ~ SOJ 1 Parameter Menu ", 

FIRST_ITEM => SOJ1_MEHU_ITEMS(1), ROWS_BETWEEN_ITEMS => 2); 

-* Target 2 Paramter Menu 

TGT2_MEHU ITEMS(7) new MENU ITEM TYPE'dTEM KINO => DATA ITEM, 

TITLE "> "ERPO, dBU/Mhz; LG, dsT ", 

PROMPT «> "Enter ERPO/LG <dBW/Mhz:dB): ", 

REAL VALUE "> 30.0, MAX VALUE "> 200.0, MIN VALUE "> 0.0, 

OATA.TYPE «> FLOATING.PT, NEXT_ITEM => null); 

TGT2 MENU ITEMS(6) new MENU ITEM TYPE'dTEM KIND DATA ITEM, 

TITLE »> "ECM technique; ", 

SSJ ECM VALUE » NONE, 

PROMPT => " ", 

DATA_TYPE => SSJ_ECM, MEXT_ITEM => TGT2_KENU_ITEHS(7)); 

TGT2_MENU_ITEMS<5) ;= new MENU_ITEM_TYPE'dTEM_KINO => DATA_ITEM, 
TITLE~=> “Target IR radiance: ~ 

TGT IR SIZE VALUE » MEDIUM, 

PROMPT » " ", 

0ATA_TYPE *> TGT_IR_SIZE, NEXTJTEM => TGT2_MEMU_ITEMS(6)); 

TGT2_MENU_ITEMS<4) := new MEMOJTEM_TYPE'dTEM_KH« => DATA_ITEM, 

TITLE »> "Target RCS, square meters: ",~ 

PROMPT «> "Enter RCS (square meters): ", 

REAL VALUE » 2.0, MAX VALUE => 100.0, MIN VALUE => 0.0, 

0ATA”tYPE «> FLOATIMG_PT, MEXT_ITEM => TGT2_MENU_ITEMS(5)); 

TGT2_MENUJTEMS(3) := new MEMUJTEM_TYPE'(ITEM_KINO => DATA_ITEM, 

TITLE «> "Echelon angle, d^ (90 trail):",” 

PROMPT » "Enter echelon angle, (deg): ", 

REAL VALUE "> 0.0, MAX VALUE » 180.0, MIN_VALUE » -180.0, 
DATA^TYPE »> FLOATIMG_PT, NEXTJTEM «> TGT2_MENU_ITEMS(4)); 

TGT2_MEMUJTEMS(2) ;■ new MENU_ITEMJYPE'(ITEM_KIND »> DATA_ITEM, 

TITLE «> "Range to target T, feet: 

PROMPT ■> "Enter range (feet): ", 

REAL VALUE » 100.0, MAX VALUE -> 100000.0, MIN VALUE -100000.0, 
DATAJYPE ■> FLOATING_PT, MEXT_ITEM »> TCT2_MENU_ITEHS(3)); 

TGT2_MENU_ITEMS(1) :» new MEMUJTEMJYPE'(ITEM_KINO *> 0ATA_ITEM, 

TITLE ■» "Target altitude, kft: ",” 

PROMPT » "Enter altitude (kft): ", 


120 






REAL VALUE 30.0, MAX VALUE => 150.0, NIN VALUE -> 0.0, 
OATA_TYPE => FLOATIMG_PT, MEXT_ITEM => TGT2_MEMU_ITEMS(2)); 

TGT2_MEMU :» new MENU_TYPE'{TITLE => 

'* Target 2 Parameter Menu ", 

FIRST_ITEM => TGT2_MENU_ITEMS(1), ROgS_BETMEEM_ITEMS => 2); 

-- Target 1 Parameter Menu 

TGT1_MEMU ITEMSdS) := new MENU ITEM TYPE'dTEM KINO => DATA_ITEM, 
TITLE => "ERPO, dBU/Mhz; Loop gain, dB: ", 

PROMPT -> "Enter ERPO/LG (dBU/Nhz:dB) : ", 

REAL VALUE => 30.0, MAX VALUE => 200.0, MIN VALUE => 0.0, 
DATA^TYPE => FLOATING_Pf, MEXT_ITEM => null); 

TGT1 MENU ITEMS(U) := new MENU ITEM TYPE'dTEM KIND => DATAJTEM, 
TITLE“=> "ECM technique: ~ ~ 

SSJ ECM_VALUE => NONE, 

PROMPT => " ", 

DATA_TYPE => SSJ_ECM, NEXT_ITEM => TGT1_MENU_ITEMS(15)); 

TGT1_MEMU_ITEMSd3) ;= new MENU_ITEM_TYPE'dTEM_KINO => DATA_ITEM, 
TITLE => "Weave period, sec: ", 

PROMPT => "Enter weave period (sec): ", 

REAL VALUE => 20.0, MAX VALUE => 100.0, MIN VALUE »> 1.0, 
DATATYPE => FLOATING_PT, NEXT_ITEM => TGT1~MENU_ITEMS{14)); 

TGT1_MENU_ITEMS(12) :* new MENU_ITEM_TYPE'dTEM_KIND => DATA_ITEM, 
TITLE”»> "Angle to turn, deg c+rlght): ", 

PROMPT “» "Enter angle to turn (deg): ", 

REAL VALUE => 10.0, MAX_VALUE » 3600.0, MIN_VALUE » -3600.0, 
DATA'tyPE => FLOATIMG_PT, NEXT_ITEM => TGT1_MENU_ITEMS(13)); 

TGT1_MENU_ITEMS(11) :» new MENU_ITEM_TYPE'(ITEM_KIN0 => DATA_ITEM, 
TITLE”=> "Maneuver buildup time,~sec: ", 

PROMPT *> "Enter buildup time (sec): ", 

REAL VALUE »> 1.0, MAX VALUE » 10.0, MIN VALUE «> 0.0, 
0ATA_TYPE a> FLOATING_PT, NEXT_ITEM => TGT1_MENU_ITEMS(12>); 

TGT1_MENU_ITEMS(10) := new MENU_ITEM_TYPE'(ITEM_KIND => DATA_ITEM, 
TITLE => "Man. start value, sec or NMI: ", 

PROMPT => "Enter start value (see / NMI):", 

REAL VALUE » 10.0, MAX VALUE => 500.0, MIN VALUE => 0.0, 
0ATA“tYPE => FLOATING_PT, MEXT_ITEM => TGT13mENU_ITEMS(11)); 

TGT1_MENU_ITEMS(9) := new MENU_ITEM_TYPE'(ITEM_KIND => DATA_ITEM, 
TITLE => "Maneuver start parameter: ", 

MANEUVER START VALUE »> FLIGHT TIME, 

PROMPT » " " “ ", 

0ATA_TVPE »> MANEUVER_START, NEXT_ITEM => TGT1_MEMU_ITEMS(10)); 

TGT1_MENU_ITEMS(8) := new MENU_ITEM_TYPE'(ITEM_KIM0 => DATA_ITEM, 
TITLE => "Maneuver g's: ", 

PROMPT »> "Enter maneuver g's; ", 

REAL VALUE » 2.0, MAX VALUE » 12.0, MIN VALUE => 0.0, 
DATA_TYPE » FLOATINGJPT, NEXT_ITEM => TGT1_MENU_ITEMS(9)>; 

TGT1 MENU ITEMS(7) new MENU ITEM TYPE'dTEM KIND -> DATA_ITEM, 
flTLE”»> "Maneuver type; “ “ ",~ 

MANEUVER VALUE «> NONE, 

PROMPT «> " ", 

DATA_TYPE »> MANEUVER, NEXT_ITEM »> TGT1_MENU_ITEMS(8)); 

TGT1_MENU_ITEMS(6) ;» new MENU_ITEM_TVPE'(ITEM_KIN0 => DATA_ITEM, 
TITLE a> "Target IR radiance: ", 

T6T IR SIZE VALUE «> MEDIUM, 

PR0MPT~«> "” ", 

DATA TYPE » TGT IR SIZE, NEXT ITEM » TGT1 MENU ITEMS(7)),‘ 


121 







TGT1_NEIIUJTEHS<5) := new l«IIU_ITEM_TYPE'(ITEH_KIMO »> DATA_ITEM, 

TITLE ■> "Tarjet RCS, square meters: ", 

PROMPT »> "Enter RCS (square meters): ", 

REAL VALUE » 2.0, MAX VALUE » 100.0, MIN VALUE » 0.0, 

OATAJYPE *> FLOATIMC_PT, NEXTJTEM => TGTl_MEIiU_ITEMS(6)>; 

TGT1_MEMU_ITEMS(4) := new MEMU_ITEM_TYPE'(ITEM_ri»IO => DATA_ITEM, 
TITLE”»> "Target slant range, NHI: ", 

PROMPT »> "Enter range (MMI): ", 

REAL VALUE »> 20.0, MAX VALUE »> 500.0, MIN VALUE => 0.0, 

OATA'TYPE »> FLOATIMG_PT, MEXT_1TEM => TGT1~MEMU_1TEMS(5)); 

TGT1_MEMU_ITEMS(3) := new MEMU_ITEM_TYPE'<ITEM_KIND => DATA_ITEM, 
flTLE~»> "Target aspect angle, deg: ", 

PROMPT => "Enter aspect angle (deg): ", 

REAL VALUE »> 180.0, MAX VALUE » 300.0, MIN VALUE => *360.0, 
OATA^TYPE => FLQAT1MG_PT, MEXT_ITEN => TGT1_iiEHUJTEMS(4)); 

TGT1_MEMU_ITEMS(2) := new MEMU_ITEM_TYPE'(ITEM_KIND »> DATA_ITEM, 
TITLE”s> "Target speed, mach: ", 

PROMPT »> "Enter mach nuiRter: ", 

REAL VALUE »> 0.9, MAX VALUE »> 4.0, MIN VALUE => 0.0, 

0ATA“tYPE => FLOATINC_PT, NEXT_ITEM => TGT1_MENU_ITEMS(3)); 

TGT1 MENU ITENS(I) ;= new MENU ITEM TYPE*(ITEM_KIND s> DATA_1TEM, 
TITLE“=> "Target altitude, kft: ", 

PROMPT » "Enter altitude (kft): ", 

REAL VALUE => 30.0, MAX VALUE => 150.0, MIN VALUE => 0.0, 

DATA^TYPE => FL0AT1NG_PT, NEXT_1TEM => TGT1~MENUJTEMS(2)); 

TGT1_MENU :* new MENU_TYPE'(TITLE » 

" ~ Target 1 Parameter Menu ", 

FIRST_ITEM => TGT1_MENU_ITEMS(1), ROUS_BETUEENJTEMS => 1); 

-- Target Parameter Menus 

TGT_MEMU_ITEMS(7) :» new MEMUJTEM_TYPE'(ITEM_K1N0 «> SUBMENU, TITLE => 
”"S0J”2 Parameter Menu ", 

DATA TYPE «> NONE, MEXT_ITEM »> null, NEXT_MENU »> 

SOJ22nENU); 

TGT_MEMU ITEMS(6) :« new MEMUJTEM_TYPE'(ITEM_KIND => DATA_ITEM, 

TITLE => "Enable SOJ 2 : ", 

YES MO VALUE => MO, PROMPT «> " ", 

0ATA_TYPE => YES_MO, NEXT_ITEM => TGT_MENU_ITEMS(7)); 

TGT_MEMU_ITEMS(5) :» new MENU_ITEM_TYPE'(ITEM_KINO => SUBMENU, TITLE => 
”"SOj”l Parameter Menu ", 

DATA TYPE » NONE, NEXT ITEM »> TGT MENU ITENS(6), NEXT_MENU => 
SOJijiENU); 

TGT MENU ITEMS(4) :» new MENU ITEM TYPE'(ITEM KIND »> DATA_ITEM, 

"title ■> "Enable SOJ 1; ", 

YES NO VALUE »> MO, PROMPT »> " ", 

DATATYPE »> YES_MO, NEXT_ITEM => TGT_MENU_ITEMS(5)); 

TGT_MENUJTEMS(3) new MENU_ITEM_TYPE'(ITEM_KINO => SUBMENU, TITLE => 
""Target 2 Parameter Menu ", 

DATA TYPE «> NONE, NEXT ITEM a> TGT MENU ITENS(4), NEXT_MEMU => 
TGT2~MENU); 

TGT_MEMU_ITEMS(2) :* new MENU_ITEM_TYPE'(ITEM_KINO »> 0ATA_1TEM, 

"title *> "Enable target 2: ", 

YES NO VALUE «> MO, PROMPT »> " ", 

DATA_TYPE »> YES_MO, MEXT_ITEM »> T0T_1«NUJTEMS(3)); 

TGT_MEMUJTEMS(1) :« new MEMUJTEM_TYPE'(ITEM_KlNO »> SUBMENU, TITLE => 
""Target 1 Parameter Menu ", 

DATATYPE »> NONE, NEXTJTEM »> T0T_MEMUJTEMS(2), MEXT_MEMU => 


122 





TCT1_MEMU); 

TGT_HEMU := new MEMU_TYPE'(TITLE => 

" ~ Target Parameter Menus ", 

FIRSTJTEM => TGT_MENU_1TEMS<1), ROUS_BETWEEM_ITEMS => 2); 

■■ Launch Aircraft Parameter Menu 

LAUNCHER_MENU_1TEHS(6) := new MENU_ITEM_TYPE'<1TEM_KIMD => DATA_ITEM, 
TITLE -> "Launch A/C guidance mode: ", ~ 

INT GUIDANCE VALUE » NON MANEUVERING, 

PROMPT => " " “ ", 

0ATA_TYPE => INT_GUIDANCE, NEXT_ITEM => null); 

LAUNCHER_MENU_ITEMS(5) := new MENU_ITEM_TYPE'(ITEM_KIND => DATA_ITEM, 
TITLE => "Launch A/C lead angle, deg: ", 

PROMPT => "Enter lead angle (deg): ", 

REAL_VALUE » 0.0, MAX VALUE => 90.0, MIN VALUE => -90.0, 
0ATA_TYPE => FLOATING_PT, MEXT_ITEM => LAUMCHER_MENU_ITEMS(6)); 

LAUNCHER_MEMU_ITEMS(4) := new MENU_ITEM_TYPE*(ITEM_KIND => DATA_ITEM, 
TITLE "Launch A/C speed, mach: ", 

PROMPT => "Enter mach number: ", 

REAL VALUE => 0.9, MAX VALUE => 3.0, MIN VALUE => 0.0, 

OATA'tYPE => FLOATING_PT, NEXT_ITEM => LAUNCHER_MEMU_ITEMS(5)); 

LAUNCHER MENU ITENS(3) := new MENU ITEM_TYPE*(ITEM tCINO » DATA ITEM, 
TITLE => "Launch A/C altitude,~kft: ", 

PROMPT *> "Enter altitude (kft): ", 

REAL VALUE => 30.0, MAX VALUE => 70.0, MIN VALUE => 0.0, 

DATATYPE => FLOATING_PT, NEXT_ITEM => LAUNCHER_MENU_ITEMS(4)); 

LAUNCMER_MENU_ITEMS(2) := new MENU_ITEM_TYPE'(ITEM_KIND => 0ATA_ITEM, 
TITLE »> "Launcher type: ~ ", ” 

LAUNCHER VALUE » RAIL, PROMPT «> " 

0ATA_TYPE => LAUNCHER, MEXT_ITEM »> LAUNCHER_MENU_ITEMS(3)); 

LAUMCHER_MEHU_ITEMS(1) :» new MENU_ITEM_TYPE'(ITEM_KIHD *> DATA_ITEM, 
TITLE »> "Launch A/C type: ", ” 

AIRCRAFT KINO VALUE => F 14, PROMPT => « 

DATATYPE => AIRCRAFT_KIm6, MEXT_ITEM => LAUNCHER_MENU_ITEMS(2)); 

LAUNCHER.MENU := new MENU_TYPE'(TITLE » 

" ~ Launch Aircraft Parameter Menu ", 

FIRST_ITEM *> LAUNCHER_MEMU_ITEMS(1), ROUS_BETWEEN_ITEMS => 2); 

-- File Operations Menu 

FILE_MENU_ITEMS(7) ;» new MENU_ITEM_TYPE'(ITEM_KINO => DATA_ITEM, 
TITLE”»> "Data log interval, frames: 

PROMPT => "Enter log interval (frames): ", 

REAL VALUE => 4.0, MAX VALUE => 100.0, MIN VALUE -> 1.0, 

DATATYPE »> FLOATIMGJPT, NEXT_ITEM »> null); 

FILE_MEMU_ITEMS(6) :« new MENU_ITEM_TYPE'(ITEM_KINO => 0ATA_ITEM, 
TITLE » "Simulation frame time, sec: ", 

PROMPT »> "Enter frame time (sec): ", 

REAL.VALUE » 0.25, MAX VALUE » 10.0, MIN VALUE => 0.01, 
DATA_TYPE »> FLOATIMG_PT, NEXTJTEM => FILE_MEMU_ITEMS(7)); 

FILE_MEMUJTEMS(5) :» new MEMUJTEM_TYPE'(ITEM_KIMO «> DATA_ITEM, 
TITLE ■» "Write output data to file: ", 

YES NO VALUE »> MO, PROMPT *> « ", 

0ATA_TYPE a> YES_MO, MEXT_ITEM => FILE_MENUJTEMS(6)); 

FILE_MEMUJTEMS(4) :» new MENU_ITEM_TYPE'(ITEM_KIMO => 0ATA_ITEM, 
TITLE *> "Name of output data file: ", 

PROMPT a> "Enter name of output file: ", 

TEXT_VALUE » MISSILE.OUTFILE, 


123 






DATA.TYPe *> TEXT, MEXTJTEH => FILE_MENU_ITEMS<5)); 

F1LE_MEMUJTEMS(3) ;* new MEMU_1TEM_TYPE*<ITEM_KIN0 *> ACTION, 

TITLE »> "Save scenario data file 

DATA TYPE » NONE, NEXT ITEM » FILE_NENU ITENS(4>, 

ACTION_KIMO s> SAVE_DATA>; 

FILE_NENU_ITEMS(2) := new NENU_ITEH_TYPE'(ITEM_KIND => ACTION, 

TITLE => “Load scenario data file 

DATA TYPE => NONE, NEXT ITEH => FILE_MENU ITEHS(3>, 

ACTi5n_KIND => LOAO_DATA); 

FILE_NeNU_ITEMS(1) new MENU_ITEM_TYPE'(ITEH_KIND => DATA_ITEH, 

TITLE » "Name of scenario data file: ", 

PROMPT s> "Enter name of scerwrio file: ", 

TEXT VALUE -> MISSILE.DATFILE, 

OATA_TYPE => TEXT, NEXT_ITEM => FILE_MENO_ITEMS<2»; 

FILE_MENU :» new MENU_TYPE'(TITLE => 

" "File Operations Menu ", 

FIRSTJTEM => FILE_MENU_ITEMS<1), ROUS_BETUEEN_ITEMS => 2); 

-- Main Menu 

MAIM_MENU_ITEMS(5) :» new MENU_ITEM_TYPE'(ITEM_KIMD => SUBMENU, TITLE => 
"Graph Data from Previous Run ", 

0ATA_TYPE => NONE, NEXT_ITEN >> null, NEXT_MENU => GRAPH_NENU); 

MAIN_MENU_ITEMS(4) new MENU_ITEM_TYPE*(ITEM_KIMD *> ACTION, TITLE => 
"Start Simulation Run " ", 

DATA TYPE » NONE, NEXT ITEM MAIN MENU ITEMSCS), 

ACTION_KIND => START_RUN); 

MAIM_MENU_ITEMS<3> :» new MEMU_ITEM_TYPE'(ITEM_KIND => SUBMENU, TITLE => 
“Target Parameter Menus ", ~ 

DATA TYPE "> NONE. NEXT ITEM "> MAIN MENU ITEMS(4), NEXT MENU -> 
TGT_MENU); 

MAIN_MENU_ITEMS<2) :« new MENU_ITEM_TYPE'<ITEM_ICINO => SUBMENU, TITLE => 
"Launch Aircraft Parameter Menu", ~ 

DATA TYPE => NONE, NEXT ITEM » MAIN MENU ITEMS(3), NEXT MENU "> 
LAUNCHER_MENU); 

MAIN_MENU_ITEMS<1) :* new MENU ITEM TYPE'dTEM KINO => SUBMENU, TITLE => 
"File Operations Menu ", 

DATA TYPE » NONE, NEXT ITEM » MAIN MENU ITEMS(2), NEXT MENU => 
FILE_MENU); 

MAIN MENU :> new MENU TYPE'CTITLE -> MISSILE.MAIN MENU TITLE. 

FIRST_ITEM »> MAIN_MENO_ITEMS<1), ROWS_BETWEEN_ITEMS => 2); 

end SETUP_MENU_DATA; 


separate (USERJNTERFACE) 


procedure SETUP_RUNTIME_SCREEN is 
begin ~ 

SYSTEM SPECIFIC.CLEAR SCREEN; 
ORAU.RUNTIME.BOROER; ~ 

SYSTEM SPECIFIC.PUT STRING( 1, 
system'specific.put STRING( 2, 
system'specific.put STRING( 3, 
SYSTEM SPECIFIC.PUT STRIN6( 4, 


SYSTEM SPECIFIC.PUT STRINGf 5, 
SYSTEM_SPECIFIC.PUT_STRING( 6, 


3, "Elapsed Time, sec :"); 

3, "Flight Time, sec :"); 

3, "Msl Time to Go, sec 
3, 

.); 

3, "Msl RF Seeker Node :»); 

3, "Msl IR Seeker Mode 


124 











SYSTEM SPECIFIC.PUT STRING! 7, 3, "Msl Az Ginbal Angle, deg 

SYSTEM SPECIFIC.PUT~STRING( 8. 3. "Msl El Ginbal Angle, deg :»); 

SYSTEM SPECIFIC.PUT STRING! 9, 3, "Msl Az LOS Rate, deg/sec 

SYSTEM SPECIFIC.PUT~STRING!10, 3, "Msl El LOS Rate, deg/sec :"); 

SYSTEM_SPECIFIC.PUT_STRING!11, 3, 

n.r. ...........T. ..........._.....If j. 

SYSTEM SPECIFIC.PUT STRING!12, 3, "Msl Guidance Node :"); 

SYSTEM SPECIFIC.PUT STRING!13, 3, "Msl Az Accel Cmd, g's :"); 

SYSTEM SPECIFIC.PUT_STRIMC!14, 3, "Msl El Accel Cmd, g's :"); 

SYSTEM_SPECIFIC.PUT_STRIMC!15, 3, 

II. r............T..............._11 

SYSTEM SPECIFIC.PUT STRING!16, 3, "Msl Propulsion Node :"); 
SYSTEM~SPECIFIC.PUT“stRING! 17, 3, "Msl Thrust, lbs 
SYSTEM_SPECIFIC.PUT_STRING!18, 3, 

n.....................-...-- nj. 

SYSTEM SPECIFIC.PUT_STRINC!19, 3, "Msl Weight* lbs 
SYSTEN'sPECIFIC.PUT STRING!20, 3, "Msl Angle of Attack, deg :»); 
SYSTEM~SPECIFIC.PUT~STRING!21, 3, "Msl Sideslip Angle, deg :"); 
SYSTEM_SPECIFIC.PUT_STRIMG!22, 3, 

H........ ......................... 

SYSTEM_SPECIFIC.PUT STRING! 1,41, "Msl Mach * :">; 

SYSTEM SPECIFIC.PUT STRING! 2,41, "Msl Velocity, ft/sec ;"); 

SYSTEM SPECIFIC.PUT_STRING! 3,41, "Msl Altitude, ft :"); 

SYSTEM SPECIFIC.PUT STRING! 4,41, "Msl Altitude Rate, ft/sec:»); 

SYSTEM SPECIFIC.PUT_STRING! 5,41, "Msl Pitch Angle, deg :"); 

SYSTEM SPECIFIC.PUT_STRIMG! 6,41, "Msl Heading Angle, deg :"); 

SYSTEM_SPECIFIC.PUT_STRING! 7,41, "Msl Oownrange Pos, NMI 
SYSTEM SPECIFIC.PUT STRING! 8,41, "Msl Crossrange Pos, NMI :«); 
SYSTEM_SPECIFIC.POt“sTRING! 9,41, 

H..............r......................11^. 

SYSTEM SPECIFIC.PUT STRIMG!10,41, "Msl X Axis Accel, g's 

SYSTEM SPECIFIC.PUT STRING!11,41, "Msl Y Axis Accel, ... 

SYSTEM SPECIFIC.PUT"stRING! 12,41, "Msl Z Axis Accel, g's 
SYSTEM_SPECIFIC.PUT_STRING!13,41, 

II.....................................II j. 

SYSTEM SPECIFIC.PUT STRING!14,41, "Launcher-Tgt Range, NMI 
SYSTEM SPECIFIC.PUT STRING!15,41, "Msl-Tgt Range, NMI :«); 

SYSTEM SPECIFIC.PUT"stRING! 16,41, "Msl-Tgt Range Rate,ft/sec:"); 
SYSTEM SPECIFIC.PUT STRING!17,41, "Tgt Mach 
SYSTEM SPECIFIC.PUT*STRING!18,41, "Tgt Altitude, ft 
SYSTEM SPECIFIC.PUT STRINC!19,41, "Tgt Heading Angle, deg 
SYSTEM_SPECIFIC.PUT_STRING!20,41, 

."); 

end SETUP_RUNTINE_SCREEN; 


separate !USER_INTERFACE) 



125 


















ENJOYI 


H 

n 

H 


II 

f 

H 



CHAR : character; 

ROW : integer; 
begin 

SYSTEM SPECIFIC.CLEAR_SCREEN; 
SYSTEM~SPECIF1C.TURM CURSOR OFF; 
S YSTEM'sPEC IFIC. ORAw“bOX ; 


ROU 2; 

for I in 1..NUN TITLE SCREEN LINES loop 

SYSTEM SPECIFIC.PUT STRING<ROW, 10, TITLE SCREEN TEXT(I)); 

ROW ;»~ROW ♦ 1; 
end loop; 

SYSTEM SPECIFIC.REVERSE VIDEO ON; 

SYSTEM'spECIFIC.PUT STrTng< 24,25, " Press the space bar to begin "); 
SYSTEM SPECIFIC.REVISE VIDEO OFF; 

KEYBOARD_HANDLER.GET KEY UAIT(CHAR); 
end SNOW TITLE SCREEN; 


separate (USER.INTERFACE) 


task body KEYBOARD HANDLER is 

BUFFER.SIZE : constant 100; 

BUFFER : array<1..BUFFER SIZE) of character; 

HEAD INDEX : integer := T; 

TAIl“index ; integer ;= 1; 

KEYS_IN_BUFFER : integer := 0; 

begin 

loop 

while SYSTEM SPECIFIC.KEY AVAILABLE and 
KEYS_IN^BUFFER < BUFFER_sTzE loop 

BUFFERfHEAD INDEX) ;= SYSTEM_SPECIFIC.GET KEY; 
HEAD.INOEX (HEAD INDEX mod BUFFER SIZE) * 1; 
KEYsjN_BUFFER := KEYS_IN_BUFFER + ij 
end loop; 

select 

accept KEY AVAILABLEfKEY IN SUFFER : out boolean) do 
if KEYS IN BUFFER > 0 then 
KEYjN^BUFFER := true; 

else 

KEY_IN_BUFFER :» false; 
end if;” 

end KEY_AVAILABLE; 
or 

when KEYS IN BUFFER > 0 » 

accept GET_KEY_UAIT(KEY : out character) do 

KEY :* BUFFER(TAIL INDEX); 

TAIL INDEX :> (TAIL INDEX mod BUFFER.SIZE) * 1; 

KEYS IN BUFFER :> KEYS IN BUFFER • 1; 
end GET_KEY_WAIT; 
or 

accept GET KEY NOWAIT(KEY : out character; 

KEY_VALID T out boolean) do 

if KEYS IN BUFFER > 0 then 
key";«”bUFFER(TAIL INDEX); 

TAIL INDEX :> (TAIL INDEX mod BUFFER SIZE) ♦ 1; 
KEYS'lN BUFFER KEYS IN BUFFER - 1; 


126 










KEY_VALID ;» true; 

els* 

ICEY_VALID :> false; 
end if;~ 

end CET_KEY_NOgAIT: 

else 

null; 

end select; 
end loop; 

end KEYBOARO_HANDLER; 


-■ System Specific Package Specification 

■- This package contains the routines that are specific to the particular 
-- computer system that it is running on. 


with NATH; use NATH; 

package SYSTEN SPECIFIC is 
type NENU CGNNANO is ( 
UP_ARROU, 

DOUN ARROW, 

EMTER_KEY); 

procedure INIT_VIOEO; 

function IS_NONOCHRONE 
return boolean; 

procedure CLEAR_SCREEN; 

procedure REVERSE_V10E0_0N; 

procedure REVERSE_V10EO_OFF; 

procedure NOVE.CURSOR ( 

ROW : integer; 

COLUNN : integer); 

procedure TURN_CURSOR_ON; 

procedure TURH_CURSOR_OFF; 

procedure PUT STRING ( 

SCREEN ROW : integer; 
SCREEN COLUNN ; integer; 
TEXT.STRING : string); 

procedure PUT.REAL ( 

ROW : integer; 

COLUNN : integer; 

HUNBER : REAL; 

AFTER : integer 2); 

procedure INPUT STRING ( 

TEXT_STRING~: out string); 

function GET.KEY 
return character; 

function KEY.AVAILABLE 
return boolean; 

function GET NENU CONNANO 
return NENU.CONNANO; 

procedure DRAU.BOX; 


127 







procedure QUIT_PROGltAM; 
end SYSTEII_S«»ECIFIC; 

-- System Specific Peckage Body 

-- This package contains the routines that are specific to the particular 
-- computer system that it is running on. 


with MATH; use NATH; 

uith BIT OPS; use BIT OPS; 

with COMMOM_DISPLAy_TYPES; 

with System; 

with PROGRAM CONTROL; 

with INTERRUPT; 

with TEXTJO; 

with REAL 10; 

with TTY;“ 

with BOX; 

with EQUIPMENT; 

package body SYSTEM SPECIFIC is 

MONOCHROME : boolean; 

REVERSE_VIDEO : boolean := false; 

FAST_VIDEO ; boolean := true; 

EGA FLAG : boolean; 

COPROCESSOR.FLAG : boolean; 

-- Set up video buffer as an array 

MONO_BUFFER_AOOR : System.Address := Systeni.Address(16W000_0000«); 

COLOR_SUFFER_AOOR : System.Address Systeffl.Address(16#B800_0000#); 

type byte is range 0..16iFF#; 

type SCREEN_CHAR_TYPE is 

record 

CHAR : byte; 

ATTRIBUTE : byte; 

end record; 

pragma PACK(SCREEN_CHAR_TYPE); 

MONO_BUFFER : array (0..24, 0..79) of SCREEM_CHAR_TyPE; 

COLOR_BUFFER : array (0..24, 0..79) of SCREEM_CHAR_TYPE; 

for MONO BUFFER use at MONO BUFFER AOOR; 

for COLOR.BUFFER use et COLOR_8UFFER_AI>OR; 


procedure INIT VIDEO is 

REGISTER 7 INTERRUPT.REGISTERS; 

TEST BITS : integer; 

EQUIP : EaUIPMENT.EaUIPNENT_LIST; 
begin 

REGISTER.AX 16#0F00#; -■ Return current video state 
INTERRUPT.VECT0R(16#10«, REGISTER); 
if (REGISTER.AX and 16#FF«) > 7 then 
MONOCHROME true; 

else 

MONOCHROME :> false; 
end if; 

REGISTER.AX :> 16«1200«; -- Code to return EGA info 
REGISTER.BX :« 16«7F10«; 

REGISTER.CX :« 16M0FFB; 

INTERRUPT.VECTOR(16«10#, REGISTER); 


128 











TEST BITS (REGISTER.BX and 16#7F00#) or (REGISTER.CX and 16#00F0#); 

if TEST BITS /- 0 then 
EGA_FLAG := false; 

else 

EGA_FLAG := true; 
end if; 

EQUIP := EOUIPMENT.LIST; 
if EQUIP.MATH C0PR(X:ESSCIR then 
COPR(X:ESs5r_FLAG true; 

else 

COPR(X:ESSOR_FLAG := false; 

text_io.put~line("ERROR; No 80x87 math coprocessor found."); 
text~io.put line("This program requires a math coprocessor."); 
PR0GRAM_C0NfR0L. QUI T( 0 ) ; 
end if; 

end INIT_VIOEO; 


procedure DRAU_B0X is 
begin 

BOX.0RAU(0, 0, 24, 79, BOX.DOUBLE SIDED); 
end DRAW_BOX; 


function IS_MONOCHRQME 
return boolean is 
begin 

return MONOCHROME; 
end IS MONOCHROME; 


procedure CLEAR SCREEN is 

REGISTER TiNTERRUPT.REGISTERS; 
begin 

REGISTER.AX :> 16«0600#; 

if IS MONOCHROME then 

REGISTER.BX :« 16#0700#; 

else 

REGISTER.BX := 16)110700#; 
end if; 

REGISTER.CX 16«0000#; 

REGISTER.OX ;= 16#100# • 24 ♦ 79; 

INTERRUPT.VECTOR(16#10#, REGISTER); 
end CLEAR SCREEN; 


procedure REVERSE_VIOEO_ON is 
begin 

REVERSE VIDEO true; 
end REVERSE~VIDEO_ON; 


procedure REVERSE_VIDEO_OFF is 
begin 

REVERSE VIDEO :* false; 
end REVERSE'vIDEO OFF; 


procedure MOVE_CURSOR ( 

ROW : integer; 

COLUMN : integer) is 

REGISTER : INTERRUPT.REGISTERS; 
begin 

REGISTER.AX :■ 16#0200#; 
REGISTER.BX :« 16#0000#; 


129 




















RE6ISTER.DX 16«100« * ROW COLUMN; 

INTERRUPT.VECTOR(16#10#, REGISTER); 
end NOVE_CURSOR; 


procedure TURN CURSOR_ON is 

REGISTER : INTERRUPT.REGISTERS; 
begin 

REGISTER.AX := 16#0100#; -- Set cursor type 
if IS.NONOCHROME then 

REGISTER.CX 16ilK)COO#; -- Cursor start & stop lines 

else 

REGISTER.CX := 16M607if; 
end if; 

INTERRUPT.VECT0R(16#10#, REGISTER); 
end TURN_CURSOR_ON; 


procedure TURN CURSOR OFF is 

REGISTER 7 INTERRUPT.REGISTERS; 
begin 

REGISTER.AX := 16*0100#; -- Set cursor type 
REGISTER.CX 16#2020#; -- Cursor start & stop lines 

INTERRUPT.VECT0R(16#10#, REGISTER); 
end TURN CURSOR OFF; 


procedure PUT_STR1NG ( 

SCREEN ROW : integer; 

SCREEN~COLUMN : integer; 

TEXT_STR1NG ; String) is 

COLUMN : integer; 
begin 

if FAST VIDEO then 

COLUMN :> SCREEN COLUMN; 
if IS MONOCHROME then 

for I in TEXT STRING*range loop 

MONO BUFFERfSCREEN ROW, COLUMN).CHAR := 
byte<character'pos(TEXT STRING(I))); 
if REVERSE VIDEO then 

NONO_BUFFER(SCREEN_ROU, COLUMN).ATTRIBUTE := 16#70#; 

else 

MONO_BUFFER<SCREEH_ROU, COLUMN).ATTRIBUTE := 16#07#; 
end if; 

COLUMN :> COLUMN 1; 
end loop; 

else 

for I in TEXT STRING'range loop 

COLOR BUFFER(SCREEN ROW, COLUMN).CHAR 
byte(character•pos(TEXT_STRING(I))); 
if REVERSE VIDEO then 

COLORjiUFFER(SCREEH_ROW, tOLUMN).ATTRIBUTE := 16#17#; 
else 

COLOR_BUFFER(SCREEN_ROU, COLUMN).ATTRIBUTE 16#07#; 
end if; 

COLUMN :> COLUMN * 1; 
end loop; 
end if; 

else 

TTY.Put(COMMON DISPLAY TYPES.ROW RANGEfSCREEN ROW), 

COMMON DISPLAY TYPES.COLUMN RANGE(SCREEN COLUMN), 

TEXT_STRING, REVERSE_VIDEO => REVERSE_VIDEO); 

end if; 

end PUT_STRING; 


procedure PUT_REAL ( 


130 











ROW : integer; 

COLUMN : integer; 

NUmER : REAL; 

AFTER : integer i* 2) is 

REAL_STRING : string(1..10); 
begin 

REAL iO.Put<REAL STRING, NUMBER, AFT => AFTER, EXP => 0); 
PUT STRING(ROU, COLUMN, REAL STRING); 
end PUT"REAL; 


procedure INPUT_STRING ( 

TEXT_STRIMG~; out string) is 
LAST : natural; 
begin 

LAST TEXT STRING*last; 
TTY.Get(TEXT”STRlMG, LAST); 
end INPUT STRING; 


function GET_KEY 

return character is 
SCAN_COOE : COMMON_OISPLAY_TYPES.byte; 
CHAR : character; 
begin 

TTY.Get(SCAN_COOE. CHAR); 
return CHAR; 
end GET_ICEY; 


function KEY_AVAILABLE 
return bMlean is 
begin 

return TTY.CHAR READY; 
end KEY AVAILABLE; 


function GET MENU COMMAND 
return MENU.COlWANO is 

CHAR : character; 

SCAN CODE : COMMON DISPLAY TYPES.byte; 
NEW_HENU_CCMNAND :~MENU_C0MMAN0; 
begin 
loop 

TTY.Get(SCAN_COOE, CHAR); 

case SCAN_CCOE is 
uhen 72 »> 

NEU_MENU_COMMAND := UP_ARROW; 
exft; 
when 80 => 

NEU_MENU_COMNANO OOUN_ARROW; 
exit; 
when 28 •> 

NEW_NENU_CGMNANO ENTER.KEY; 
exft; 

when others » 
null; 
end case; 
end loop; 

return NEW MENU COMMAND; 
end GET MENU CONMANO; 


procedure QUIT PROGRAM is 
DUMMY : integer; 
begin 


131 











CLEAR SCREEN; 

MOVE CURS0R(0, 0); 

TURN CURSOR ON; 

PROGRAM CONTROL.QUITCO); 
end QUIT PROGRAM; 


end SYSTEM_SPECIFIC; 


- Integration Package Specification 

- This package contains the limited private data type for state variables and 

- the integration initialization and update procedures used on the states. 


with MATH; use MATH; 

package INTEGRATION is 

procedure INITIALIZE; 

procedure AOVANCE_TIME; 

procedure SET TIME STEP SIZE ( 

NEW_TIME_STEP_SIZE T in REAL); 

function STEP_SIZE 
return REAL; 

end INTEGRATION; 

Integration Package Body 

-- This package performs integration of the state variables. 


with MATH; use NATH; 

with REAL MATRIX; use REAL MATRIX; 

with APPLICATION; 

with ENVIRONMENT; 

package body INTEGRATION is 
TIME_STEP_SIZE ; REAL; 

STATE : VECTOR(1..APPLICATION.NUMBER OF STATE VARIABLES); 

TEMP STATE : VECT0R<1..APPLICATION.NUMBER_OF_STATE VARIABLES); 
DERIVATIVE! : VECTORd..APPLICATION.NUMBER OF_STATE VARIABLES); 
OERIVATIVEZ : VECTORd..APPLICATION.NUMBER~OF STATE~VARIABLES); 


procedure SET TIME STEP SIZE ( 

MEW_TIME_STEP_SIZE 7 in REAL) is 
begin 

TINE STEP SIZE :> NEU TIME STEP SIZE; 
end SET_TIME_STEP_SIZE; 


procedure HANNA is 
begin 

TEMP STATE ;» STATE ♦ OERIVATIVEZ * TIME STEP SIZE; -- Euler step 
ENVIRONMENT.SET TIMEfENVIRONNENT.Time ♦ TIME_STEP SIZE); -• Update time 
APPLICATION.PUT~STATES(TEMP STATE); 

APPLICATION.COHWTE OERIVAtTvES; 

APPLICATION.GET.DERTvATIVES(DERIVATIVF1); 

-- Trapezoidal step 

STATE :■ STATE ♦ (DERIVATIVEI ♦ OERIVATIVEZ) * 0.5*TIME STEP_SIZE; 
OERIVATIVEZ :> DERIVATIVEI; -- Save derivatives for next step 


13Z 















end HANNA; 


procedure INITIALIZE Is 
begin 

APPLICATION.GET DERIVATIVES(DERIVATIVE2); 
APPLICATION.GET STATES(STATE); 
end INITIALIZE; 


procedure AOVANCE_TINE is 
begin 

HANNA; 

end AOVANCE_TIME; 

function STEP_SIZE 
return REAL is 
begin 

return TINE STEP SIZE; 
end STEP_SIZE; " 

end INTEGRATION; 


-- Math Package Specification 


with NATH_LIB; 
package MATH is 

type REAL is digits 15; -- Use this for all floating point values 

PI : constant MATH_LIB.PI; ■* Dimensionless 

E : constant MATH_LIB.E; -- Dimensionless 

DEG TO RAD : constant":^ PI / 180.0; -• Deg 

RAO“TOj>£G ; constant ;» 1.0 / DEG_I0_RAD; •• 1 / Deg 

G T constant ;* 32.174; -- Gravity, feet / sec**2 

C ; constant :» 983_569_000.0; -- Light speed, feet / sec 

GAMMA : constant ;= T.4;~ •• Air specific heat ratio 

R ; constant := 1718.0; --Air gas constant, foot-lb / (slug-R> 

R_EARTH ; constant := 20_925_626.0; -- Earth radius, feet 

BOLTZNANN_K s constant := 1.38E-23; -• Boltzmann's constant, uatt-sec/deg K 

FEET_PER_NMI: constant :» 6076.115; -- Feet / NMI 

MENU_SYSTEM : constant boolean true; 

function SIGN ( 

ARG : in REAL) 
return REAL; 

function SIN ( 

ARG : in REAL) 
return REAL; 

function COS ( 

ARG : in REAL) 
return REAL; 

function TAN ( 

ARG : in REAL) 
return REAL; 

function ASIN ( 

ARG : in REAL) 
return REAL; 

function ACOS ( 

ARG : in REAL) 
return REAL; 


133 









function ATAN ( 

ARG : in REAL) 
return REAL; 

function ATAN2 ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL; 

function EXP ( 

ARG : in REAL) 
return REAL; 

function SORT ( 

ARG : in REAL) 
return REAL; 

function LN ( 

ARG : in REAL) 
return REAL; 

function LOG ( 

ARG : in REAL) 
return REAL; 

procedure SEED_RAN ( 

ARG : in REAL); 

function RAN 
return REAL; 

function GAUSSIAN ( 

MEAN : in REAL; 
STO_OEVIATION : in REAL) 
return REAL; 

function LIMIT ( 

VARIABLE : in REAL; 

LOWER LIMIT : in REAL; 
UPPER~LIMIT : in REAL) 
return REAL; 

function LIMIT ( 

VARIABLE : in REAL; 
LIMIT.MAGNITUDE : in REAL) 
return REAL; 

function ’•**" ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL; 

function MIN ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL; 

function MAX ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL; 

function MAX3 ( 

LEFT : in REAL; 

MID : in REAL; 

RIGHT : in REAL) 
return REAL; 
end MATH; 


134 




*■ BeloM are instantiations of generic packages 

with NATH; use NATH; 
with Text_io; use Text_io; 

package REAL_IO is new Float_io(REAL); 

with Text_io; 

package LONG_IO is new Text_io.Integer_io(long_integer); 

-■ Define a package of 'glue' routines needed for REAL_HATR1X 

with Text_io; use Text_io; 
with REAL~IO; use REAL~IO; 
with NAThJ use HATH; 

package REAL NATRIX_GLUE is 

function~NAGNITUOE(ELENENT : REAL) return REAL; 
function TO FLOAT(ELENENT : REAL) return float; 
function FRON_FLOAT(ELENENT : float) return REAL; 

procedure GET ELENENT(FILE : in File type; ELENEHT : out REAL); 
procedure GET'elENEHT(ELENEHT : out REAL); 
procedure PUT~ELENEHT(FILE : in File type; ELEICNT : in REAL); 
procedure PUT~ELENENT(ELENENT : in REAL); 

pragma IHLIHE (HAGMITUOE, TO FLOAT, FRON FLOAT); 
end REAL_NATRIX_GLUE; 

package body REAL NATRIX_GLUE is 

function NAGnTtloE (ELENEHT : REAL) return REAL is 
begin 

return abs(ELENEHT); 
end NAGNITUOE; 

function TO.FLOAT (ELENEHT : REAL) return float is 
begin 

return float(ELEHENT); 
end TO.FLOAT; 

function FRON.FLOAT (ELENEHT : float) return REAL is 
begin 

return REAL(ELEHEHT); 
end FRON_FLOAT; 

procedure GET_ELENEHT(FILE : in File_type; ELENEHT : out REAL) is 
begin 

Get(FILE, ELENEHT); 
end GET_ELENEHT; 

procedure GET_ELENEHT(ELENEHT : out REAL) is 
begin 

Get(ELENEHT); 
end GET.ELENEHT; 

procedure PUT_ELENEHT(FILE : in File_type; ELENEHT : in REAL) is 
begin 

Put(FILE, ELENEHT); 

Hew (ine(FILE); 
end POT~ELENEHT; 

procedure PUT_ELENEHT(ELENEHT : in REAL) is 
begin 

Put(ELENEHT); 

Hew line; 
end PUT'eleNEHT; 
end REAL_NATRIX_GLUE; 

■■ Instantiate the NATR1X_AHD_VECT0R package for type REAL using 


135 






-- the REAL_NATRIX_GLUE routines 

with MATRIX AND VECTOR; 
with MATH; use NATH; 

with REAL MATRIX GLUE; use REAL MATRIX_GLUE; 
package REAL MATRIX is new MATrTx AND_VECT0R(REAL); 


-- Math Package Body 


with MATH_LIB; use MATH_LIB; 
package body NATH is 

RANOOM_NUNBER : REAL 0.5; -- Default seed value 
EXTRA GAUSS : boolean := false; 

GAUSS'l : REAL; 

GAUSS 2 : REAL; 

GAUSS~MAG : REAL; 

GAUSS FACTOR : REAL; 


function SIGN ( 

ARG : in REAL) 
return REAL is 
begin 

if ARG > 0.0 then 
return 1.0; 
elsif ARG < 0.0 then 
return -1.0; 

else 

return 0.0; 
end if; 
end SIGN; 


function SIN ( 

ARG : in REAL) 
return REAL is 
begin 

return REAL(SIN(float(ARG))); 
end SIN; 


function COS ( 

ARG : in REAL) 
return REAL is 
begin 

return REAL(COS(float<ARG))); 
end COS; 


function TAN ( 


ARG : in REAL) 

4 

return REAL is 


begin 


return SIN(ARG) / COS(ARG); 


end TAN; 



function ASIN ( 

ARG : in REAL) 
return REAL is 
begin 

if ARG s 1.0 then 
return 0.5*PI; 

else 

return REAL(ATAN(float(ARG / SQRTd.O - ARG*ARG)))); 


136 















end if; 
end ASIN; 


function ACOS ( 

ARG : in REAL) 
return REAL is 
begin 

if ARG - 0.0 then 
return 0.5*PI; 

else 

return REAL(ATAN(floatlSQRTd.0 - ARG*ARG) / ARG))); 
end if; 
end ACOS; 


function ATAN ( 

ARG : in REAL) 
return REAL is 
begin 

return REAL(ATAH(float(ARG))); 
end ATAN; 


function ATAN2 ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL is 

RESULT : REAL; 
begin 

if RIGHT /= 0.0 then 

RESULT := ATAN(LEFT / RIGHT); 
elsif LEFT > 0.0 then 
return 0.5*PI; 

else 

return -0.5*PI; 
end if; 

if RIGHT < 0.0 then 
if LEFT > 0.0 then 

RESULT i- RESULT + PI; 

else 

RESULT RESULT - PI; 
end if; 
end if; 

return RESULT; 
end ATAN2; 


function EXP ( 

ARG : in REAL) 
return REAL is 
begin 

return REAL(EXP(floet(ARG))); 
end EXP; 


function SORT ( 

ARG : in REAL) 
return REAL is 
begin 

if ARG < 0.0 then 

rsise Constraint_error; 
end if; 

return REAL(SORT(float(ARG))); 
end SORT; 


137 

















function LN ( 

ARC : in REAL) 
return REAL is 
begin 

return REAL(LN(float(ARG})); 
end LN; 


function LOG ( 

ARC : in REAL) 
return REAL is 
begin 

return LN(ARG) / LN(10.0); 
end LOG; 


procedure SEED RAN ( 

ARG : in REAL) is 
begin 

RANDCH NUMBER := absLARG); 
end SEED RAN; 


function RAN 

return REAL is 


Notes on this function: Using the default seed (0.5) - 

Using a multiplier of 257.874562956093 a pattern of dots created 
on an EGA (640x350) screen by randomly generating x and y point 
coordinates had visible line patterns. 

Using a multiplier of 19257.874562956093 the random nunter sequence 
began repeating after about 2 million calls. 

Using the current value (1257.874562956093) the sequence will 
go at least 4 million calls without repeating & appears random on 
the EGA. 


begin 

RANOOH.NUNSER (RANDOM NUMBER * 0.18568271032) * 1257.874562956093; 
RANDOM NUMBER RANDOM NUMBER - REAL(integer(RANDOM NUMBER-0.5)); 
return RAM00M_MUMBER; 
end RAN; 



function GAUSSIAN ( 

MEAN : in REAL; 

STD_0EVIATI0N : in REAL) 
return REAL is 
begin 

if not EXTRA.GAUSS then 
loop 

GAUSS 1 -.3 2.0 « RAN - 1.0; 

GAUSS~2 2.0 • RAN - 1.0; 

GAUSS_MAG :» GAUSSJ**2 + GAUSS_2**2; 
exit when GAUSS_MAG <1.0; 
end loop; 

GAUSS FACTOR :« SQRT(-2.0 * LN(GAUSS NAG) / GAUSS NAG); 
GAUSSj :« MEAN ♦ STD_DEVIATION * GAUSSJ * GAUSS^FACTOR; 

EXTRA.GAUSS true; 
return GAUSS_1; 

else 

GAUSS_2 :« MEAN * STD_DEVIATION * GAUSS_2 * GAUSS_FACT0R; 


138 





















EXTRA_GAUSS false; 
return GAUSS_2; 
end if; 
end GAUSSIAN; 


function UNIT ( 

VARIABLE : in REAL; 

LOWER_LIHIT : in REAL; 

UPPER_LINIT : in REAL) 
return REAL is 
begin 

if VARIABLE > UPPER LIMIT then 
return UPPER LIMIT; 
elsif VARIABLE < LOWER LIMIT then 
return LOWER_LIMIT; 

else 

return VARIABLE; 
end if; 
end LIMIT; 


function LIMIT ( 

VARIABLE : in REAL; 

LINIT_MAGNITUDE : in REAL) 
return REAL is 
begin 

if VARIABLE > LIMIT MAGNITUDE then 
return LIMIT MAGNITUDE; 
elsif VARIABLE < -LIMIT MAGNITUDE then 
return -LIMIT^MAGNITUDE; 
else ^ 

return VARIABLE; 
end if; 
end LIMIT; 


function ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL is 

SIGN : REAL; 
begin 

if LEFT = 0.0 then 
return 0.0; 

elsif RIGHT > REAL(integer(RIGHT)) and LEFT < 0.0 then 

if RIGHT > 2.0 * REAL(integer(RIGHT / 2.0)) then — Even power 
SIGN :> 1.0; 
else -- Odd power 
SIGN := -1.0; 
end if; 

' return SIGN * EXP(RIGHT • LN(abs(LEFT))); 

else 

return EXP(RIGHT • LN(LEFT)); 

« end if; 

end '•**"; 


function MIN ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL is 
begin 

if LEFT < RIGHT then 
return LEFT; 

else 

return RIGHT; 


139 













end if; 
end NIN; 


function MAX ( 

LEFT : in REAL; 

RIGHT : in REAL) 
return REAL is 
begin 

if LEFT > RIGHT then 
return LEFT; 

else 

return RIGHT; 
end if; 
end MAX; 


function MAX3 ( 

LEFT : in REAL; 

MID : in REAL; 

RIGHT : in REAL) 
return REAL is 
begin 

return HAX(NAX(LEFT, MID). RIGHT); 
end MAX3; 
end MATH; 


Model Data Types Package Specification 

This package contains the data types for application specific variables 
that need to be defined in several places in the simulation 


with MATH; use MATH; 

with REAL.MATRIX; use REAL.MATRIX; 

package MODEL TYPES is 

type YES_HO_TYPE is (HO, YES); 

type SUPER_^CTOR is array (positive range <>) of VECT0R(1..3); 
type THREED is array (positive range <>,positive range <>. positive 
range <>) of REAL; 

type IR_PHASE_TYPE is (NOM_ACTIVE, IR_SEARCH, IR_ACOUISITION, IR_TRACK); 

type RF PHASE TYPE1 is (MIDCXXJRSE.HPRF ACQUISTION.MPRF ACOUISTION,TERMINAL); 
type RF~PHASE~TYPE2 is (NON ACTIVE.MIOCOURSE.X BAND_ACGUISITION, 

X_BANO_TRACK,K_BAN0_A(MUISITION,K_BANO_TRACK); 

type AIRCRAFT TYPE is (F U.F 15,F 18,SIXOOF); 
type LAUNCHER_TYPE is (RAIL, EJECT); 

type SSJ ECM TYPE is (NONE,REPEATER.BARRAGE NOISE); 
type SOJ ECM TYPE is (BARRAGE NOISE.RSN.PRN); 
type SSJ ECM TECHNIQUE is array (1..2) of SSJ ECM_TYPE; 
type SOJ_ECM“tECHNIOUE is array (1..2) of SOJ_ECM_TYPE; 

type GUIDANCE PHASE TYPE is (NULL COMMANDS, HOLD.PATH, LOAD BIAS, 
VARIABLE.ARC, ALTITUDE_HOLD. TURN_DOWN, TERMINAL); 

type GU1D_SELECTI0N_TYPE is (LAC_CUE,TGTJ,TGT_2,SOJJ,SOJ_2); 

type PROPUL_TYPE is (BOOST,COAST,FLAMEOUT); 

type INT_GUIDANCE_TYPE is (NON_MANEUVERING, PURSUIT); 

type TGT IR SIZE TYPE is (SMALL. MEDIUM, LARGE); 
type MANEUVER TYPE is (NONE,TURN,WEAVE); 

type NANEUVER'START type is (FLIGHT TIME,TIME REMAINING,RANGE TO_GO); 


140 











type STOP CQNOITION TYPE is (AZ GIMBAL.EL GIMBAL.TOTAL GIMBAL.RANGE RATE, 
CROSSOVER,H1T_GROUNO.NAX_TIME_OF_FL1GHT); 

type SETUP_VALUES_TtPE is 
record 

FRAME TIME : REAL; 

LOG INTERVAL : INTEGER; 

INT'alTITUOEJC : REAL; 

INT”haCH IC T REAL; 

INT LEAO^^ANGLE IC : REAL; 

LAUNCH TYPE ~ ; LAUNCHER TYPE; 

TGT_ALflTUOE IC : VECTORd .74); 

SOJ ANGLE IC~ : VECTORd. .2); 

TGT MACH 1C : REAL; 

TGT“asPECT IC ; REAL; 

TGT2 ANGLE IC : REAL; 

TGT_RAHGE_1C : VECTORd..4); 

TGT RCS IC : vectord..2); 

TGT“tuRH G IC : REAL; 

TGT_TURNON VALUE IC : REAL; 

TGT BUILDUP.TIME IC : REAL; 

TGT TURN ANG IC T REAL; 

TGT WEAVE PER IC : REAL; 

TGT'twO IC “ : YES NO TYPE; 

SOJ OHE'IC ; YES'nO^TYPE; 

SOJ TW0~1C : YES''nO_TYPE; 

TGT~ECM“pOUER_IC: VEClORd. .4); 

TGT ECM'TECH IC: SSJ ECM TECHNIQUE; 

SOJ ECM TECH IC: SOJ ECM TECHNIQUE; 

INT TYPE 1C “: AIRCRAFT "TYPE; 

LOG “data": yes no TYPE; 

INT GUIDANCE :~INT GUIDANCE TYPE; 

TGTT IR size ; TGT"iR SIZE TYPE; 

TGT2"ir"sIZE ; TGT"ir"sIZE"tYPE; 

MANEUVER KINO : MANEU^R TYPE; 

TURN ON PARAMETER : MANEUVER START TYPE; 

OUTPUT_FILE : stringd..30);" 
end record; 

type MSL_LOG_DATA_TYPE is 
record 

REAL_VALUE ; VECTORd. .34); 

GUIDANCE PHASE : GUIDANCE PHASE TYPE; 

RF PHASE"1 : RF PHASE TYPE1; 

RF PHASE~2 : RF PHASE TYPE2; 

IR phase": IR PHASE TYPE; 

RAOOME OFF : boolean; 

PR0PULS10N_PMASE ; PROPUL_TYPE; 
end record; " " 

praone PACK(MSL_LOGJ>ATA_TYPE); 

type LAUNCHER_LOG_DATA_TYPE is 
record 

REAL_VALUE : VECTORd..3); 
end reco^; 

pragma PACK(LAUNCHER_LOG_DATA_TYPE); 

type TARGET_LOG_OATA_TYPE is 
record " 

REAL.VALUE : VECTORd. .9); 
end record; 

pragma PACK(TARGET_LOG_DATA_TYPE); 

type LOG_RECORD_TYPE is 
record 


141 




MISSILE DATA : MSL_LOG DATA TYPE; 

LAUNCHER DATA : LAUNCHER LOG DATA TYPE; 

TARGETJDATA ; TARGET_LOG~DATATYPE; 

end record; 

pragma PACK(LOG_RECORD_TYPE}; 

RF_MOOE : array (RF_PHASE_TYPE2) of string(1..9) := ( 
"Inactive ", 

"Midcourse", 

"XBand Acq", 

"XBand Trk", 

"XBand Acq", 

"XBand Trk"); 

IR_MOOE : array (IR_PHAS£_TYPE) of string{1..9) := < 
"Inactive ", 

"IR Search". 

"IR Acq ", 

"IR Track "); 

PROPULSION NODE : array <PROPUL_TYPE) of str{ng(1..9) := ( 
"Boost" ", 

"Coast "); 

GUIDANCE NODE : array (GUIDAHCE.PHASE TYPE) of string(1..9) 
"NuU Cmds", 

"Hold Path", 

"Load Bias", 

"Var. Arc ", 

"Alt. Hold", 

"Turn Down", 

"Terminal "); 

STOP REASON . array (STOP CONDITION TYPE) of string(1..9) : 
"Az GimtMl", 

"El Gimbal", 

"Tot Gil*.", 

"Rangerate", 

"Crossover", 

"Hit Grnd.", 

"Max TOP "); 

end MOOEL_TYPES; 


U2 






APfEIBIX D 


PROBLEM SPACE OBJEa SOUMX CODE LISTINGS 


-- Launcher package 

-- This package contains the procedure calls which will initialize, 
-- setup, computes and get and put the missile state vector as well 
-- as calculating the necessary parameters to calculate the state 
-- vector. 


with NATH; use MATH; 

with REAL_MATRIX; use REAL MATRIX; 

with MOOEL_TYPES; use MOOEL_TYPES; 

package LAUNCHER is 

procedure SETUP<LAC_GUtO IN: in INT GUIDANCE TYPE; 

LEAD IN, “ 

LAC_MACH IN, 

LAC ALT rN:in REAL; 

LAC”tyPE_IN: in AIRCRAFT_TYPE); 

procedure PUT_STATES(STATES: in VECTOR); 

function GET_DERIVATIVES return VECTOR; 

function GET_STATES return VECTOR; 

function LOC_DATA return LAUNCHER_LOG_OATA_TYPE; 

function POLEd: in INTEGER) return REAL; 

procedure INITIALIZE; 

function LAC_POS return VECTOR; 

procedure MSL INIT(LAC_VEL,LAC_POSITION: out VECTOR; LAC_GAIN, 

LAC_TRANS_PWR, LAC_BEAMW1DTH: out REAL); 


procedure COMPUTE; 
end LAUNCHER; 


-- Launcher package 

-- This package contains the procedure calls which will initialize, 
-- setup, computes and get and put the missile state vector as well 
-- as computing the necessary parameters to calculate the state 
-- vector. 


I 


with MODEL TYPES; use MODEL TYPES; 
with NATH;~use NATH; 
with ENVIRONMENT; 

with REAL MATRIX; use REAL MATRIX; 
with MISSTlE; 
with T'TGETS; 

WITH •|eXT_IO;UITH REALJO; 
package body LAUNCHER is 


H3 











LAC GUID 
LEAD 

LAC NACH 
LAC'VEL NED 

lac'pos'med 

LOGGED DATA 
DERIVATIVES 
STATE 
LAC TYPE 


INT_GUIDANCE_TYPE; — Launch Aircraft Guidance Mode 
REAL; -- Launch Aircraft Lead Angle 

REAL; -- Launch Aircraft Mach 

VECTOR (1..3); -- Launch Aircraft Velocity Vector 

VECTOR <1..3); -- Launch Aircraft Position Vector 

LAUNCHER LOG DATA TYPE ; -- Output Vector 

VECT0R(1T.3)7 
VECTOR<1..3); -- 
AIRCRAFT TYPE; 


procedure SETUP(LAC GUID_IN: in INT_GUIDANCE TYPE; 
LEAD IN, 

LAC MACH IN, 

LAC ALT.fN: in REAL; 

LAC~TYPE IN: in AIRCRAFT TYPE) is 


begin 

LAC_GUID := LAC_GUIO_IN; -- Launch Aircraft Guidance Mode 
LEAD := LEAD IN; -- Launch Aircraft Lead Angle (rad) 
LAC.MACH := LAC_MACH_IN; — Launch Aircraft Mach 
LAC POS NED(3):s -LAC ALT IN;-- Launch aircraft altitude (feet) 
LAC~TYPE:=LAC TYPE InJ 
end SETUP; 


procedure PUT_STATES(STATES: in VECTOR) is 
begin 

LAC POS NED:sSTATES(1..3); 
end PUT'staTES; 


function GET.DERIVATIVES return VECTOR is 
begin 

0ER(VATIVES(1..3):>LAC VEL NED; 
return DERIVATIVES; 
end GET DERIVATIVES; 


function GET.STATES return VECTOR is 
begin 

STATEd. .3) :=LAC_POS_NEO; 
return STATE; 
end GET_STATES; 


function LOG_DATA return LAUNCHER_LOG_DATA_TYPE is 
begin 

LOGGED DATA.REAL VALUE(1):« LAC POS NE0(1); 
LOGGED DATA.REAL VALUE(2):> LAC POS NE0(2); 
LOGGED DATA.REAL VALUE(3):« -LAC POS NED(3); 
return LOGGED DATA; 
end LOG DATA; 


function POLEd: in INTEGER) return REAL is 

TGT_POS_NED : SUPER_VECT0Rd..3); 

begTn 

TGT POS NEO:«TARGETS.TGT POS; 
return NAGNITUDE(TGT POS NED(I) - LAC POS NED); 
end POLE; 


function LAC_POS return VECTOR is 
begin 

return LAC POS NED; 
end LAC POS; 




















U5 















with NATH; us* NATH; 

with REAL NATRIX; us* REAL NATRIX; 

with NOOEL.TTPES; us* NOOEL_TYPES; 

packsg* NISSILE is 

ID STRING : string(1..30) :s "NPS Nissit* Flight Sisulstion “; 
RUNTINE_TITLE : stringd..42) := 

" NPS Simulstion Runtime Displsy 
OUTFILE : stringd..30) oSIN.OUT »; 

OATFILE : stringd..30) :> "SIN.OAT »; 

NAIN_NENU_TITLE : strir«d..60) :« 

"NPS 3-DOF Nissile Flight Simulation Nain Nenu ■■; 

TITLE_SCREEN_LINE : stringd..60) :« 

" NPS 3-DOF Air-to-Air Nissile Flight Simulation "; 

IS_ACTIVE : boolean :■ true; -- If true this is an active missile 


procedure SETUP(LAUNCH TYPE IN: 
RCS: 

TGT1 IR SIGNATURE: 
TGT2“ir“sIGNATURE: 
TGT THO: 

SOj''ONE: 

SOJ~TUO: 

ECN~POUER: 

SSJ~ECN TECH: 

soj“ecn“tech: 


in LAUHCHER_TYPE; 
in VECTOR; 

in TGT IR_SIZE TYPE; 
in TGT_IR SI2 E“tyPE; 
in YES NO TYPE; 
in YES~N0 “typE; 
in YES“no~TYPE; 
in VECTOR; 

in SSJ ECM_TECHNIOUE; 
in SOJ_EOt_TECHNIOUE); 


procedure INITIALIZE; 


procedure CONPUTE; 


procedure PUT_STATES(STATE: in VECTOR); 


procedure NANEUVER VALUE(TURN ON PARAMETER: in MANEUVER START TYPE; 
NANEUVER_START_VALUE; out rIaL); 

function GET_0ERIVATIVES return VECTOR; 

function GET_STATES return VECTOR; 

function LOG_OATA return NSL_LOG_OATA_TYPE; 

function ENO_CONDITIONS_MET return boolean; 


procedure TERMINAL CONDITIONS (A_POLE OUT, MISS DISTANCE OUT, 

TIME_OF_FLIGHT,~altitude" RDOT: out REAL; 
STOP REASON OUT: out STOP CONDITION TYPE) 


end NISSILE; 


-- Missile peckage body 

-- This package contains the procedure calls which will initialize, 
-- setup, compute and get and put the missile state vector, as well 
" as computing the necessary parameters to calculate the state 
-- vector. 


with NATH; use NATH; 

with MODEL TYPES; use MODEL TYPES; 

with REAL NATRIX; use REAL MATRIX; 

with LAUNCHER; 

with TARGETS; 

with AIRFRAME; 

with AUTOPILOT; 

with ENVIRONMENT; 


146 












with GUIDANCE; 
with INTEGRATION; 
with KINEMATICS; 
with RF SEEKER; 
with IR SEEKER; 


package body MISSILE is 


MSL ACC NED 

msl”vel“med 

MSL POS NED 
LAUNCH TYPE 
NTGTS “ 
NSOJS 
TGTTYP 


VECTOR<1..3); 
VECTOR(1..3); 
VECTOR(1..3}; 
LAUNCNER TYPE; 
INTEGER;" 
INTEGER; 
INTEGER; 


BORE_SIGNT_ERROR:VECTOR(1..4);-- Bore sight errors 


-- Missile acceleration vector 
-- Missile velocity vector 
-- Missile position vector 

Nunber of targets 

Number of active stand off jaoiners 

Type of target (skin.range deception, etc.) 


MSL DATA 

derTv 

STATE OUT : 
TGT m NED : 

tgt"pos"ned 

IR ACQ MNGE : 
ANGLE OF ATTACK 
COEF DRAG 
MSL mass 
THRUST 
MSL VEL 
MSL'hEADING A2 
PITCH 

RANGE VEC NED 
OMEGA NED 
TGT RANGE 
RDOT 

TIME TO GO 
RANGE VEC BOO 
GMB ANG SKR 
MSL PHASE 
RF PHASE 
ir"phase 

PROmLSION PHASE: 
RADOME off" 

F pole" 

a"pole 

RANGE TGT LAC 


MSL_LOG_OATA_TYPE; -- Missile object output record 
VECTOR(1..6); -- Derivative array vector 
VECT0R(1..6); -- State variable output vector 
VECTOR(1..3); -- Target velocity vectors, ft/sec 

SUPEH_WECT0R<1..4); -- Target position vectors, ft 
REAL; -- Range at which IR acquisition is enabled 
: VECT0 rH.. 3); --Missile b<xfy angle vector 
: REAL; -- Missile drag coefficient 
: REAL; -- Missile mass 
: REAL; -- Missile thrust, tbs 
: REAL; -- Missile velocity, ft/sec 
: REAL; -- Missile azimuth heading angle, rad 
: REAL; -- Missile pitch angle, rad 
SUPER_VECTOR(1..4); -- Missile to target range vectors 
VECTOR(1..3); -- Missile to target LOS rates 

VECTOR(1..4); -- Missile to target ranges, ft 

VECT0R(1..2); -- Missile to target range rates, fps 

REAL; -- Estimated time to go in flight, sec 

SUPER_VECT0R<1..4); --Missile to target one range vector, 
VECTOR7 i.. 3); -- Seeker gimbal angle vector, rad 


RF PHASE TYPE1; 
RF PHASE TYPE2; 
ir"phase_type; 

PROPUL.TYPE; 

boolean; 

REAL; 

REAL; 

VECT0R(1..4); -• 


Missile phase of flight 
- Phase that RF is in 
IR phase 

-- RadosK off flag 


Range from the targets to the 
launch aircraft 


SNR 

MSL AXIAL ACC : 
(meCA SKR 
GUID PHASE 
ACC COM BOO 

acc"ach"boo 

Q 

MSL MACH 
STOP REASON 
MISS DISTANCE NED 
MISS DISTANCE : 
RDOT OLD 
TINE"tO go OLD: 
ALTITUDE OLD : 


REAL; -- Signal to noise ratio, dB 
REAL; -- Missile axial acceleration in body axis 
VECT0R(1..3); -- Missile to targets LOS rate vectors 
GUIOANCE_PHASE_TYPE; — Guidance phase 
VECT0R<2T.3); -- Commanded acceleration vector 

VECTOR(1..3}; -- Achieved acceleration vector- body 

REAL; -- Dynamic pressure 

REAL; 

STOP CONDITION TYPE; -- Reason simulation stopped 
VECT0R<1..3); 

REAL; 

REAL; -- Range rate value from prior pass 
REAL; 

REAL; 


procedure SETUP(LAUNCH_TYPE_IN: 
RCS: 

TGT1 IR SIGNATURE: 
TGT2 IR"SIGNATURE: 
TGT TWO: 

SOJ ONE: 

SOJ"tWO: 

ECM"P0WER: 

SSJ ECM TECH: 


in LAUNCHER TYPE; 
in VECTOR; " 
in TGT IR SIZE TYPE; 
in TGT"irIsIZE"tyPE; 
in YES HO TYPE; 
in YES"ho"tyPE; 
in YES"mO TYPE; 
in VECTOR; 

in SSJ ECM TECHNtOUE; 


147 















in SOJ_ECM_TECHNIQUE) is 


SOJ ECM TECH: 

TEW»_ECII_POUER: ■vECT0R(1..4); 

begin 

LAUNCH TYPE:-LAUNCH TYPE IN; 

TENP EOi P(MER:sECM~POUER; 
if TGT TUO « NO then 
NTGTS:*1; 
else 

NTGTS:=2; 
end if; 

if SOJ ONE s NO end SOJ TWO s NO then 
NSOJS:*0; 

elsif SOJ ONE > YES end SOJ TUO > NO then 
NSOJsT=1; 

elsif SOJ ONE > NO end SOJ TWO > YES then 
NSOJsT=1; 

TENP ECM P(MER(3):>TENP ECN P0UER(4); 
elsif SOJ ONE « YES end SOJ TWO > YES then 
NSOJS:-3; 
end if; 

RF_SEEKER.SETUP(NTGTS,NSOJS,RCS,TEMP_ECN_POUER.SSJ_ECN_TECH, 
” SOJ ECN TECH)* ~ ~ 

IR SEEKER.SETUPlTGTfIR S1GNATURE,TGT2 IR SIGNATURE); 
KINENATICS.SETUP(NTGTS,NSOJS); 
end SETUP; 


procedure INITIALIZE is 
GAIN REAL; 

POWER REAL; 

BEANUIOTH REAL; 

begin 

NSL NASS:>400.0; 

COE? 0RAG:«0.7S; 

THRUST:>0.0; 

ANGLE OF ATTACK:«<0.0,0.0,0.0); 

ACC ACH ioD := (0.0,0.0,0.0); 

PITCH :« 0.0; 

NSL PHASE:«NI0C0URSE; 

RF PHASE:sNON ACTIVE; 

IR~PHASE:>NON ACTIVE; 

PROPULSION PNASE:=COAST; 

RAOONE OFFlsfelse; 

Q:>2600.0; 

IS_ACTIVE:=FALSE; 
f^ I in 1..4 loop 

RANGE TGT LAC(I):>LAUNCHER.POLE(I); 

TGT.RANGEI I):«RANGE_TGT_LAC<I); 
end loop; 

A POLE:«RANGE TGT LAC(1); 

SNR:«1.0; 

TINE TO GO:>SOO.O; 

TARGETS.TGT OATA(TGT VEL NED,TGT POS NED); 

LAUNCHER.NSL_INIT(NSL VEL NED,NSL PCS NED,GAIN,POWER, 

BEANWIDTH); 

GUIDANCE.INITIALIZE(*NSL POS NE0(3),-TGT POS NED(1)(3), 

TGT POS NED(1),TGT VElJnED); 

AIRFRANE.INITIALIZE; 

AUTOPILOT.INITIALIZE; 

RF SEEKER.INITIALIZE(GAIN,POWER,BEANWIDTH); 

IR~SEEKER.INITIALIZE(-TGT POS NE0(1)(3),-NSL POS NED(3),IR ACO RANGE); 
NSL HEADING AZ:>>ATAN(NSL ^L NEO(2)/NSL_VEL NED(1)); 
if LAUNCH TYPE » EJECT then “ 

NSL_VEL_NEO<3):«NSL_VEL_NED<3)+20.0; 
end if;~ 
end INITIALIZE; 


148 










procedure COMPUTE Is 

EIB : MATRIX(1..3,1..3) 

EIS NATRIX(1..3,1..3) 

EBI MATRIX(1..3.1..3) 

THETA SKR : REAL; 

PSI.SKR : REAL; 

beflin -- COMPUTE 

TINE TO GO OLO:-TINE TO GO; 
ROOT~OLD:=ROOT<1); 


-- Inertiel to body direction cos nwt. 
-- Inertiel to seeker dir. cos matrix 
-- Trensform of EIB 
-- Seeker pitch angle, rad 
*- Seeker yew angle, rad 


TARGETS.TGT DATA(TGT VEL NEO.TGT POS_NED); 

KINEMATICS.COMPUTEfNSL POS NEO,NSL VEL NED,TGT VEL NED, 

TGT POS NED,RANGE VEC NED,OMEGA NED,TGT RANGE,RDOT, 
MISS DISTANCE NEdTtII^ TO GO,NISS DISTANCE); 


for I in 1..NTGTS loop 

RANGE_TGT_LAC(I):=LAUNCHER.POLE(I); 
end loop;' 


for I in 1.. NSOJS loop 

RANGE_TGT_LAC( I «2 ): ^LAUNCHER. POLE (I '»2) ; 
end loop; 


RF SEEKER.OETECTION(TGT_RANGE,RANGE TGT_LAC,RF PHASE,SNR, 
TGTTYP,BORE_SiGHT_ERROR); 


case RF PHASE is 

when K BAND ACQUISITION «> 
if not Ts_ACTIVE then 

A_POLE;=HAMGE_TGT_LAC<1); 

IS_ACTIVE;=true; 
end if; 

when others -> 
null; 
end case; 

if TGT RANGE(I) < IR ACQ RANGE then 
RADOME_OFF:»TRUE; 

IR_SEEKER.DETECTION(TGT_RANGE(1},IR.PHASE); 
end if; 

KINEMATICS.OIR_COS((MSL_HEADING_AZ+ANCLE_OF_ATTACK<3»,PITCH,EIB); 

for I in 1..NTGTS loop 

RANGE_VEC_BOO(I):^EIB*RANGE_VEC_NED(I); 
end loop; 

for I in 1..NSOJS loop 

RANGE_VEC_BOO( I-»2) :>EIB*RANGE_VEC_NED(I^2); 
end loop; 

R F.SEEKER.GIMBAL(RANGE_VEC_BQO,GMB_ANG_SKR); 

PSI SKR:>ANGLE OF ATTACK(3)^SL HEADING AZ+GMB ANG SKR(3); 

THETA SKR:>PITCH^m ANG SKR(2); 

KINEMATICS.DIR_COS(PSI_Si(R,THETA_SKR,EIS); 

OMEGA SKR:«EIS*OMEGA NED: 

GUIDANCE.CGMPUTEITIME TO GO,-NSL POS NED(3),-MSL_VEL NED(3), 

MSL VEL,ACC ACH raO),PITCH,TGT RANGE(1),RDOT(1), 

GMB'ANG SKR,0MEGA SKR,GUID PHASETaCC com BOO); 

AUTOPILOT.c5|PUTE(ACC COM BOO,ACC ACH BOD(2..3)); 

AUTOPILOT.UPOATE OIFF”EOS'; 

KINEMATICS.MACH NOf-MSL POS NED(3),NSL_VEL NED,MSL MACH); 

AIRFRAME.THRUSTIMSL MASS,THRUST,PROPULSION~PHASE);~ 
AIRFRAME.AEROfNSL MACH,0,RAOaME OFF, 

COEF DRAG,ANGLE OF ATTACK); 

KINEMATICS.EOMIMSL'ras NED,MSL''vEL NED,ANGLE_0F ATTACK, 


149 








COEF DRAG.NSL NASS.THRUST,ACC ACH 800(1), 
NSL m.NSL HEADING A2,PITCH.Q); ~ 

EBI :> TRANSPOSE(EIB); 

NSL ACC NED EBI * ACC ACH BOO; 
NSL~ACC~NED(3) :■ NSL ACC NED(3) * G; 
end CONPUTE; 


procedure PUT_STATES(STATE: in VECTOR) is 
begin 

ALTITUDE OLD:>-NSL POS HE0(3); 

NSL VEL NED:>STATEri..3); 

NSL POS NED:>STATE(A..6); 
end PUT'sTATES; 


procedure NANEUVER VALUE(TURN ON PARANETER: in NANEUVER START TYPE; 

NANEUVER_START_VALUE: out REAL) is 
begin 

if TURN ON PARANETER > FLIGHT TINE then 

NANEU^R START VALUE:>EHVIRONNENT.Tiine; 
elsif TURN ON PARANETER > TINE RENAINING then 
NANEUVER START VALUE:>TIHE~TO GO; 
elsif TURN ON PARANETER = RANGE_TO.GO then 

NANEUVER_ST*RT_VALUE:=TGT_RAH0E<1) / FEET_PER_NNI; 
end if; 

end NANEUVER.VALUE; 


function GET_OERIVATIVES return VECTOR is 
begin 

0ER1V(1..3):=NSL_ACC NEO; 

DERIV(4..6):-NSL_VElInED; 
return OERIV; 
end GET.OERIVATIVES; 


function GET_STATES return VECTOR is 
begin ” 

STATE 0UT(1..3):*NSL VEL NEO; 
STATE_0UT<4. .6) :^SlIpOS~NED; 
return STATE OUT; 
end GET_STATES; 


function L0G_DATA return NSL_LOC_OATA_TYPE is 
begin ~ - - - 

NSL DATA.REAL VALUE(1):« NSL POS NED(1); 

NSL DATA.REAL VALUE(2):a NSL POS NE0(2); 

NSL DATA.REAL VALUE(3):>-NSL POS_NEO(3); 
NSL~DATA.REAL~VALUE(4):«RANGE TGT LAC(1); 
NSL~DATA.REAL~VALUE(5):>NSL VEL; ~ 

NSL DATA.REAL VALUE(6):>NSL HEADING AZ*RAO TO_DEG; 
NSL~DATA.REAL~VALUG(7):sPITCH*RA0 TO DEG; " 

NSL DATA.REAL VALUE(8):«NSL NACH; 

NSL DATA.REAL VALUE(9):-TGT RANGE(I); 

NSL'dATA.REAL VALUE(10):«R0OT(1); 
NSL~DATA.REAL~VALUE(11):«TINE TO GO; 

NSL DATA.REAL VALUE(12..14):>^ ANG_SKR*RAD TO DEG; 

NSL DATA.REAL VALUEdS. .16):>0HEGA SKR(2..3)*RA0 TO DEG; 
NSL DATA.REAL VALUE(17):>-NSL VEL NE0(3); 

NSL DATA.REAL VALUE(18..19):>ACC CON BOD; 

NSL DATA.REAL VALUE(20..22):>ACC ACH BOO; 

NSL DATA.REAL VALUE(23):aNSL NASS; 

NSL DATA.REAL VALUE(24):>THRUST; 

NSL DATA.REAL VALUE(25..27):-ANGLE OF ATTACK*RAO_TO DEG; 
NSL DATA.REAL VALUE(28):-SNR; 
NSL~DATA.REAL~VALUE(29):«C0EF DRAG; 

NSL~ DATA.REAL~ VALUE(30):-REAL'(TGTTYP); 


150 














NSL DATA.REAL VALUE(31..34):sB0RE SIGHT ERROR; 
NSL DATA.GUIOMICE PHASE :■ GUID PHASE; 

NSL OATA.RF PHASE 1 :> NSL PHASE; 
NSL"DATA,RrPHASE"2 ;» RF PHASE; 

NSL OATA.IR PHASE IR PHASE; 

NSl'DATA.RAOONE off :> RAOONE_OFF; 
NSL_OATA.PROPULSION_PHASE := PROPULSION_PHASE; 
return NSL_DATA; ~ 

end LOG_DATA; 


function ENO_CONDITIONS_NET return boolean is 
begin ~ 

if ab6(GNB_ANG_SKR<2)) >=0.95993 then -- AziMUth gimbal angle 

STQP_REASON:=EL_GINBAL; 
return true; ~ 

elsif abeCGNB ANG $KR(3)) >= 0.95993 then -- Elevation ginbal angle 
STOP.REASON:«A2_GINBAL; 
return true; 

elsif abelGNB ANG_SKR(1)) » 0.95993 then - Total ginbal angle 
STOP.REASON: =T0T AL_G IN8AL ; 
return true; 

elsif ENVIRONNEHT.TINE > 7.0 and ROOT(1) >= 0.0 then 

if MAGNITUDE (NSL POS NED) » NAGN1TUDE(TGT_P0S NED(1» then 
ST0P_REAS0N:=CR(KSOVER; 

else 

STOP_REASON:=RANGE_RATE; 
end if; 
return true; 

elsif -NSL POS NED(3) <= 0.0 then - Altitude 

STOP.REASON:>HIT.GROUND; 
return true; ~ 

elsif ENVIRONNEHT.TINE >= 500.0 then 
STOP_REASOH;*NAX_TINE_OF_F LIGHT; 
return true; 

else 

return false; 
end if; 

end ENO CONDITIONS NET; 


procedure TERNIHAL_COHOITIOHS (A_POLE_OUT, NISS DISTANCE OUT, 

TINE OF FLIGHT ."altitude” RDOT: out REAL; 
STOP REASON OUT: out STOP CONDITION TYPE) is 

TENP: REAL; 
begin 

A POLE OUT := A POLE; 
mOT:*KOOT OLD; 

STPT REASON OUT :> STOP REASON; 
if STOP REASON > CROSSO^R then 

NISS DISTANCE OUT:=MISS DISTANCE; 

TINE OF FLIGHT:>ENVIROIMENT.TINE-INTEGRATION.STEP SIZE'^ 

TINE TO GO OLD; 

ALTITUOE:=ALTITUDE OLO-fd-NSL POS NED(3)-ALTITUDE OLD)* 

TINE_TO_GO_OLD/INTEGRATION.STEP_SIZE); " 

else 

NISS DISTANCE 0UT:>TGT RANGE(I); 

TINE OF FLIGHT:-ENVIRONNENT.TINE; 

ALTITUDE:>-NSL_POS_NED(3); 
end if; 

end TERNINAL_CONDITIONS; 
end NISSILE; 


-- Airframe procedures 

-- These procedures consist of routines for the aero 
-- and thrust andels. 


151 









with NATH; UM NATH; 

uith NGOEL TYPES; use NOOEL TYPES; 

with REAlJmTRIX; use REAL_NATRIX; 

psckage AIRFRAME is 

procedure INITIALIZE; 

procedure AERO(NSL_NACH,Q: in REAL; 

RADOME OFF: in boolean; 

COEF DRAG: in out REAL; 

AMGLE_OF_ATTACK_OUT: out VECTOR); 

procedure THRUSTINSL NASS,THRUST: out REAL; 

PRdWLSION_PHASE_OUT: out PROPUL_TYPE); 


end AIRFRAME; 


-- Airframe procedures 

-- These procedures consist of routines for the aero and 
-- thrust models. 


with NATH; use NATH; 

with NGOEL TYPES; use NGOEL TYPES; 

with REAL MATRIX; use REAL MATRIX; 

with ENVIRONMENT; 

with INTEGRATION: 

with AUTOPILOT; 


package body AIRFRAME is 

TIME.BOOSTER: constant :> 4.00; 

T_B06st_INIT: constant :» 0.0; --1.0;-- time before booster ignited 
NSL NASS DRY: constant :> 300.0; 

ROCKET MASS INIT: constant := 100.0; 

PROPULSION PHASE: PROPUL TYPE; 

ACC ACH: VECT0R(2..3); 

BOOST FUEL RATE, EXP DECAY: real; 

NSL MASS, ROCKET NASS: real; 

ANGLE OF ATTACK: VECT0R(1..3); 


procedure INITIALIZE is 
begin 

MSL.NASS :- NSL_MASS_0RY * ROCKET_NASS_INIT; 

PROWLSION PHASE* := ^ST; --initiaf coast before booster ignition 
BOOST FUEL'RATE :* ROCKET NASS INIT/(REAL(INTEG£R 

((Tlli BOKTER/INTEGRATION. STEP SIZE) * 0.5)) • INTEGRA) I ON. STEP SIZE); 
end INITIALIZE; 


procedure AEROfNSL NACH,a: 
RADGME_OFF: 

COEF DRAG: 

ANGLE OF ATTACK OUT: 


in REAL; 

in boolewi; 
in out REAL; 
out VECTOR) is 


CD ZERO,CO INOUCED,AOA ALPHA, 
AdA_BETA,AM_TOTAL: REAL; 


begin 

* * C<3lllpUt€ AOA 

ACC.ACH ;> AUTOPILOT.ACCELERATIONS; 


152 














AM ALPHA :> -2.09 • ACC ACH(3) / Q; 
if abs(AM ALPHA) > 0.5236 then 

AM_ALPHA :« SIGH(AM_ALPHA) * 0.5236; 
end if; 

AM BCTA :> 2.09 * ACC ACH(2) / Q; 
if ^(AM BETA) > 0.5236 then 

AM_BETA SIGH(AM_BETA) * 0.5236; 
end if; 

AM TOTAL SQRT(AM ALPHA * AM ALPHA * AM BETA * AM BETA); 

ANGLE OF ATTACICd) := AM TOTAL ; 

ANGLE~0F~ATTACK(2) := AM ALPHA; 

ANGLE~0F“aTTACK(3) AM BETA; 

AHGLE_OF~ATTACK_OOT ;= AHGLE_OF_ATTACK; 

-- compute drag coefficient 
if NSL MACH < 1.2 then 

CO ZERO :* 0.75 * MSL MACH - 0.02; 
elsif MSL MACH » 1.2 and MSL MACH < 1.8 then 

CD_ZER0 ;= 2.346 - MSL_MACH * ((1.346-0.253 * HSL_MACH) * MSL_MACH-2.472) 

else 

C0_ZER0 := 1.3 * EXP(-0.287 * MSL_MACH); 
end if; 

--10X increase after IR dome is remved 
if RAOOME OFF then 

C0_ZER0 := 1.1 * CO_2ERO; 
end if; 

CO IMOUCEO ;= 7.0 * (AM T0TAL**2); 

C0EF_0RAG ;= 0.97 * CD_2ERO ♦ CD_IHOUCED; 

end AERO; 


procedure THRUST(MSL MASS,THRUST: out REAL; 

PROPOLSIOM_PHASE_OUT: out PROPUL_TYPE) is 

THRUST.BOOST: constant := 11000.0; 

begin 

if ENVIRONMENT.Time < T BOOST INIT then 
PROPULSION PHASE CMST; 

THRUST 0.0; 

MSL MASS := NSL MASS ORY * ROCKET MASS; 
elsif ENVIRONMENT.Time TINE BOOSTER ■* T BOOSTJNIT then 
PROPULSION PHASE :« BOOST;' 

THRUST THRUST BOOST * TIME BOOSTER/(REAL(INTEGER((T1NE_BOOSTER/ 
INTEGMTION.STEP SIZE) - 0.5)) * INTEGRATION.STEP SIZE); 
ROCKET NASS :> ROCKET NASS 1nIT - BOOST_FUEL RATE * ENVIRONMENT.TIME; 
MSL NASS :* NSL NASS DRY > ROCKET NASS; 
elsif ENVIRONMENT.Time > TIME BOOSTER * T_BOOST INIT then 
NSL NASS NSL.NASS DRY; 

PROmLSION PHASE :* COAST; 

THRUST :» 0.0; 
end if; 

PROPULSION PHASE OUT :* PROPULSION PHASE; 
end THRUST; 

end AIRFRAME; 


- Autopilot Specification 

- These procedures consist of routines for modelling the autopilot. 


with MATH; use MATH; 

with MODEL TYPES; use MODEL TYPES; 

with REAL MATRIX; use REAL MATRIX; 


153 











package AUTOPILOT is 


procedure INITIALIZE; 
procedure OPOATE_OIfF_EOS; 

procedure CONPUTE(ACC_COMNANDEO: in VECTOR; ACC.ACHIEVED: out VECTOR); 
function ACCELERATIONS return VECTOR; 
end AUTOPILOT; 

■■ Autopilot Package 

-- These procedures consist of routines for modelling the autopilot. 


with NATH; use MATH; 

with MODEL TYPES; use MODEL TYPES; 

with ENVIRONMENT; 

with INTEGRATION; 

with REAL.NATRIX; use REAL_NATRIX; 

package body AUTOPILOT is 

AP_NAT_FREQ : constant := 0.80; -- Hertz 
AP DAMP RATIO : constant 0.75; 

AP"C1, AP C2, AP_C3 : REAL; 

ACC_C0M, ACC_ACH, ACC_ACH_2 ; VECTOR(2..3); 


procedure INITIALIZE is 
begin 

AP Cl ;* 2.0 * EXP<-AP DAMP RATIO * AP NAT FREO * 2.0 * PI * 
INTECRATION.STEP sTZE) * COS<AP NAT FrIo * 2.0 * PI * 
INTEGRATION.STEP.SIZE * SORT<1.0 - AP_DAMP_RATI0**2»; 

AP C2 :« -EXP<-2.0 • AP DAMP RATIO * AP NAT FREO * 2.0 * PI * 
INTEGRATION.STEP.SIZE); 

AP C3 :« 1.0 • AP Cl - AP C2; 

ACC ACH :» (O.OTO.O); 

ACC~ACH 2 (0.0,0.0); 

end INITIAlTzE; 


procedure UPOATE_DIFF_EaS is 
begin 

ACC ACH<2) ;» AP C1*ACC ACH<2) ♦ AP C2*ACC ACH_2{2) + AP C3*ACC C0M(2); 
ACC ACH(3) :■ AP C1*ACC ACH(3) ♦ AP~C2*ACC ACH 2(3) ♦ AP~C3*ACC"C0M{3); 
ACC ACH 2;»ACC ACH; 
end UPDATE DIFF EOS; 


procedure COMPUTE(ACC_COMNANDEO: in VECTOR; ACC_ACHIEVED: out VECTOR) is 
begin 

ACC C0M:-ACC COMMANDED; 

ACC ACHIEVED:>ACC ACH; 
end COMmTE; 


function ACCELERATIONS return VECTOR is 
begin 

return ACC ACH; 
end ACCELERATIONS; 

end AUTOPILOT; 


154 





















-- RF S««k«r package 

-- This package is the governing routine which estimates RF 
-- acquistion tisies. Seeker calculates a missile seeker giabal angles. 

-- It will be assumed that the antenna point directly along the LOS vector. 


with HATH; use NATH; 


in IHTEGER; 
in VECTOR; 
in VECTOR; 

in SSJ ECM TECHNIQUE; 
in SOJ e5( TECHNIQUE); 


LAC TRANS PUR_IN. 

LAC_BEANUIDTH_IN: in REAL); 

procedure GIMBAL(RANGE_VEC BOO INIT: in SUPER VECTOR; 

GIMBAL.ANGLE 7 in out VECTOR); 

procedure DETECTION(TGT RANGE_IN, 

RANGE TGT_LAC IN: in 
RF PHASE OUT:~ out 

SNR OUT:~ out 

TGTTYP a’; out 

BSE OUT: out 


VECTOR; 

RF PHASE TYPE2; 
REAL; 

INTEGER; 

VECTOR); 


with MODEL TYPES; use NOOEL TYPES; 
with REAL_HATRIX; use REAL.NATRIX; 

package RF_SEEKER is 

procedure SETUP(NUN OF_TGTS INIT, 
NUN"0F_S0JS“INIT; 
RCS“lNIT: 

ECM'pOUER INIT: 
SsAcH tech INIT: 
SOj_ECH_TECH_INIT: 

procedure INITIALI2E(LAC_GAIN_IN, 


end RF.SEEKER; 


■ RF_Seeker package 

- This package is the governing routine which estimates RF 

■ acquistion times. Seeker calculates a missile rf seeker ginixal angles. 

- It will be assvmed that the antenna points directly along the LOS vector. 


with MATH; use MATH; 
with MODEL TYPES; use NOOEL TYPES; 
with REAL.MATRIX; use REAL MATRIX; 
with ENVIRONMENT; 

package body RF_SEEKER is 


RF PHASE 

RF PHASE TYPE2; 

LAC TYPE 

AIRCRAFT TYPE; 

SEL TGT 

GUIO SELECTION TYPE 

SSJ ECM TECH 

SSJ ECM TECHNIQUE; 

SOJ ecm'tech 

SOJ'eCM TECHNIQUE; 

RCS“ 

VECTORS..2); 

ECM POUER 

VECTOR(1..4); 

SNR 

REAL; 

K ACQ TIME 

REAL; 

X acq'tine 

REAL; 

LAC TRANS PUR 

REAL; 

lac”gain " 

REAL; 

LAC 8EAMUIDTH 

REAL; 

TGT RANGE 

VECT0R(1..4); 

RANGE TGT LAC 

VECTOR(1..4); 


155 










NUN OF TGTS : INTEGER; 

NUM'oF~SOJS : INTEGER; 

RANGE BOO: SUPER VECTOR(1..A); 
SELTGT ■ : INTEGER; 

TGTTYP : INTEGER; 

BSE : VECTOR(1..4); 

TGT POWER : VECTOR!1..2); 

REPEAT POWER : VECTOR!1..2); 

NOISE POWER : VECTOR!1..4); 


procedure SETUP!NUM.OF TGTS INIT. 

NUM OF SOJS INIT: 
RCSJNIT: 

ECN POWER INIT: 

SSJ ECM TECH_INIT: 
SOJ ECM TECH INIT 


in INTEGER; 
in VECTOR; 
in VECTOR; 

in SSJ ECM TECHNIQUE; 
in SoJ ECM TECHNIQUE) is 


begin 

RCS :> RCS INIT; 

SSJ ECM TECH :> SSJ ECM TECH INIT; 
SOJ'eCM-TECH := SOj“eCM TECH INIT; 
ECM^POWER :> ECM POWER TnIT; 

NUM^OF TGTS := NUN OF TGTS INIT; 

num~of“sojs := num”of”sojs“init; 

end SETUP;" 


procedure INITIALI2E!LAC GAIN IN, LAC TRANS_PWR IN. 

LAC_BEAMUIDTH_IN: in REAL) is 

begin 

I! ACQ TIME:3 -10.0; 

X ACQ"tIME:> -10.0; 

SNR:«“-U0.0; 

RF PHASE:- NON ACTIVE; 

LAC GAIN:«LAC GAIN IN; 

LAC'tRANS PWRT«LAC~TRANS pur IN; 

LAC'bEAMwToTH: «LAC"BEAMUrDTH~I N; 

TGT~POUER :- !-200.0,-200.0); 

REPEAT POWER :- !-200.0,-200.0); 

NOISE POWER :- !-200.0,-200.0,-200.0,-200.0); 
SELTGT:- 0; 

TGTTTP;- 0; 

BSE :- !0.0,0.0,0.0,0.0); 
end INITIALIZE; 


procedure GIMBAL!RANGE VEC BOO INIT : in SUPER VECTOR; 

GIMBAL ANGLE T in out VECTOR)~is 


begin 

RANGE VEC BOO:- RANGE VEC BOO INIT; 
if SELTGT"- 0 then 
SELTGT :- 1; 
end if; 

if RANGE VEC B00!SELTGT)!1) - 0.0 then 

GIMML ANGLE!3) :- ATAN!RANGE VEC B00!SELTGT)!2)/ 

RANGE VEC BOO!SEfTGT)!3)); 

GIMBAL ANGLE!2) :* ATAN!-RANGE VEC BOO!SELTGT)!3)/0.001); 
GIMBAL_ANGLE!1) :- ACOS!COS!GINBAL_ANGLE!2))*COS!GIMBAL_ANGLE!3))); 

else 

GIMBAL ANGLE!3) :- ATAN!RANGE VEC B00!SELTGT)!2)/ 

SORT!RANGE VEC B00!SEItCt1!1)**2*RANGE VEC B00!SELTGT)!3)»*2)); 
GIMBAL ANGLE!2) :- ATAN!-RANGE VEC B00!SELTGT)!3)/ 

RANGE VEC B00!SELfGT)!1)); 

GIMBAL ANGLE!)) :- AC(K!C!»!GIMBAL ANGLE!2))*COS!GIMBAL ANGLE!3})); 
end if; 
end GIMBAL; 


156 











procedure BORESIGHT_ERROii U 
begin 

BSE(SELTGT) GAUSS1AN(0.0,0.1); 
for I in SELTGT'»1..NUM OF TGTS loop 
if RANGE VEC 800(0(1} » 0.0 then 
BSE(T) ;= 0.0; 

else 

BSE(I) := ACOS(DOT PRODUCT(RANGE_VEC BOO(SELTGT>.RANGE VEC BOO(I))/ 
(MAGNfTUOElRANGE VEC_BOO(SELTGT»* 

NAGNI TIDE ( RANGE_^C_BOO( I) ) ) ) ; 

end if; 
end loop; 

-- Calculate the boresight error targets less than the selected target 
for I in 1..SELTGT-1 loop 

if RANGE VEC B00(I)(1) = 0.0 then 
BSE(T) := 0.0; 

else 

BSE(I) ACOS(DOT PRGOUCT(RANGE VEC_BOO(SELTGT).RANGE VEC BOO(I))/ 
(MAGNrTUDE(RANGE_VEC_BOO(SELTGT))* 

HAGNI TIDE(RANGE_VEC_BOO(1»)); 

end if; 
end loop; 

for I in SELTGT+1..NIM OF SOJS loop 
if RANGE VEC BOOdldl = 0.0 then 
BSE(T) := 0.0; 

else 

BSE(I) ;= ACOS(DOT PRODUCT(RANGE_VEC BODfSELTGT),RANGE VEC B0D(I})/ 
(MAGNTtUDEIRANGE VEC BOO{SELTGT»* 

HAGNlTUDE(RANGE_VEC_BOD(I)))); 

end if; 
end loop; 

-■ Calculate the boresight error targets less than the selected target 
for I in 1..SELTGT-1 loop 

if RANGE VEC B0D(I)(1) » 0.0 then 
BSE(T) 0.0; 

else 

BSE(I) :3 ACOS(DOT PR00UCT(RANGE VEC BaO(SELTGT), 

RANGE~VEC B00(l>1))7(HAGNtTUDE(RANGE VEC BODISELTGT))* 
HAGNITU0E(RANCE_VEC_B00(1+1))>); 

end if; 
end loop; 

end BORESIGHT ERROR; 


procedure HSL ANT GAINS_SA (BSE: in REAL; SUM_GAIN.DELTA GAIN: out REAL) is 
ABS BSE: REAL; “ 

SI:~ REAL; 

begin 

ABS_BSE :> ABS(BSE); 
if ABS BSE <3 38.0 then 

SI :» 35.0*((ABS(COS(BSE*ABS BSE)))**0.7)-13.0; 
if ABS BSE > 30.0 then 

SI 7= SI* (ABS_BSE-30.0)*0.625; 
end if; 

else 

S1:«U.6*EXP(-(ABS_BSE-38.0)/30.0>-25.0; 
end if; 

SUM GAIN:>S1; 

if ABS BSE >- 20.0 then 

DELTA_GAIN:*31.0*SORT(SIN(ABS_BSE*7.66))-13.0; 

else 

0ELTA_GAIN:=7.82*25.0*EXP(-(ABS_BSE-20.0)/30.0)-25.0; 
end if; 

end MSL_ANT_0AINS_SA; 



157 













procedure NSL ANT GAINS A (BSE: in REAL; SUN GAIN.OELTA GAIN: out REAL) is 
ABS BSE: REAL; " “ 

S1: REAL; 

begin 

ABS BSE :> ABS(BSE); 
if ABS BSE <> 38.0 then 

Sf:« 46.0*((ABS((»S(BSE*ABS BSE)))**0.7)-13.0; 
if ABS BSE > 30.0 then 

Si" := SH (ABS_BSE-30.0)*0.625; 
end if; 
else 

S1:=U.6*EXP('(ABS_BSE-38.0)/30.0)-25.0; 
end if; 

SUN_GAIN:sS1; 

if ABS BSE » 20.0 then 

0ElTA_GAIN:=31.0*SaRT(SIN(ABS_BSE*7.66»-13.0; 

else 

DELTA_GAIN:s7.82«25.0*EXP(-(ABS_BSE-20.0)/30.0)-2S.0; 
end if; ” 
end NSL_ANT_GAINS_A; 


procedure SA POWERS is 

LOOP_GAIN, ERPO, NSL_GAIN, DELTA.GAIN : REAL; 
begin 

for 1 in 1..NUN OF TGTS loop 

NSL ANT GAINS SA(BSE(n,NSL GAIN.OELTA GAIN); 

TGT~POUER(I) r= -S3.0I- LAC fRANS PURnAC_GAIN'H4SL GAIN«10.0*log(RCS(I)) 
-20.0*log(RANGE TGT LAC(I)) 

-20.0*log(TGT MNGfd)); 
case SSJ_ECN_TECH<I) is 
when REPEATER «> 

LOOP GAIN :> ECN POUER(I); 

REPEAT POUER(I) :» -84.0 ♦ LAC TRANS PUR LAC GAIN + 

NSL UIN^LOOP GAIN-20.0*log(RANGE TGT LAC(I))- 
20.0*log<TGT RANGE(I)); 
when BARRAGE NOISE 

ERPO :* ECN POUER(I); 

NOISE POUER(I) :« -78.2 * LAC TRANS PWR * LAC GAIN * 

NSL_GAIN ♦ ERPO •“20.0*log(fGT_RANGE(I)); 
uhen others »> ” 

null; 
end case; 
end loop; 

if NUN OF SOJS /> 0 then 

for rin 1..NUN OF SOJS loop 

NSL_ANT_GAINS_SA(BSE(I>2),NSL_GAIN,0ELTA_GAIN); 

case SOJ ECN TECH(I) is 
HhefTBARMGE NOISE «> 

ERP0:>ECN P0WER(I>2); 

NOISE P0UER(I'»2):>-88.0+ERP0'H«SL GAIN-20.0*L0G( 
TGT_RANGE(d2)); 

uhen others »> 

NOISE_P0UER(I+2):>-166.0; 
end case; 
end loop; 
end if; 

end SA POWERS; 


procedure SA_0ETECT is 

THERN NOTsE.FLOOR : constant:*-166.0; -- in db/filter 
FALSEIalARn'thRESHOLO : constant:s6.0; - in db 
NOISE~THRESh6lO constant:>8.0; -- in db 


158 










begin 

SA POWERS; 

if NUM OF TGTS = 1 then 

if" fGT_POUER(1) >= REPEAT_POUER(1) and TCT_POWER(1) >= MOISE_POWER(1) 
then 

SNR TGT POUERd) - THERM NOISE FLOOR; 

if TGT POUERd) > THERM NOISE FLOOR * FALSE_ALARM_THRESHOLD then 
SEItGT := 1; 

TGTTYP := 3; 

else 

SELTGT ;= 0; 

TGTTYP ;= 0; 
end if; 

elsif REPEAT POUERd) > TGT_POUERd) and 
REPEAT POUER(I) > NOISE POUERd) then 

SNR REPEAT POUER(I) - THERM NOISE^FLOOR; 

if REPEAT POUERd) > THERM NoTsE FLOOR ♦ FALSE_ALARM_THRESHOLD then 
SELTGT ;= 1; 

TGTTYP ;= 2; 

else 

SELTGT := 0; 

TGTTYP ;= 0; 
end if; 
else 

SNR := NOISE POUERd) - THERM NOISE FLOOR; 

if NOISE_POUER<2) > THERM NOISE_FLOOR ♦ FALSE_ALARM_THRESHOLD then 
SELTGT ;= 1; 

TGTTYP := 2; 

else 

SELTGT ;= 0; 

TGTTYP j= 0; 
end if; 
end if; 

else 

if TGT POUERd) >* TGT POUER(2) and TGT POUERd) >» REPEAT_POUER<2) 
and TGT POUERd) >» REPEAT POUERd) and"TGT_POUERd) >* M01SE_P0UERd> 
and TGT"pOUERd) >= NOISE ^R(2) then 

SNR :» TGT POUERd)"- THERM_NOISE FLOOR; 

if TGT POUERd) > THERM NOISE FLOOR ♦ FALSE_ALARM_THRESHOLD then 
SEItGT :* 1; 

TGTTYP ;s 3; 

else 

SELTGT := 0; 

TGTTYP ;s 0; 
end if; 

elsif TGT POUER(2) > TGT POUERd) and TGT POWER(2) >= REPEAT_POUER(2) 
and TGT POUER(2) >= REPEAT POUERd) 
and TGT"pOWER( 2) >= NOISE POUERd) 
and TGT"pOUER( 2) » NOISE POUER(2) then 

SNR :> TGT POUER(2) - THERM NOISE FLOOR; 

if TGT POWER(2) > THERM_NOISE_FLOOR ♦ FALSE_ALARM_THRESHOLD then 
SELTGT := 2; 

TGTTYP :« 3; 
else 

SELTGT 0; 

TGTTYP ;= 0; 
end if; 

elsif REPEAT POUER(2) > TGT POUERd) and REPEAT_POWER(2)>TGT_POWER(2) 

and REPEAT POUER<2)>REPEAT POUERd) and REPEAT_POUER(2)>NOISE_POWERd) 
and REPEAT"poUER( 2) > NOISE POWER{2) then 

SNR REPEAT POUER(2) - THERM_NOISE_FLCIOR; 

if REPEAT POUER(2) > THERM_NOISE_FLOOR ♦ FALSE_ALARM_THRESHOLD then 
SELTGT :« 2; 

TGTTYP :■ 2; 

else 

SELTGT :* 0; 

TGTTYP :* 0; 
end if; 

elsif REPEAT_POWER<1) > TGT_POWERd) and REPEAT_POWER(1) > TGT_POUER(2) 


159 




and REPEAT P(WER(1)>REPEAT POUER(I) and REPEAT P(MER(1)>NOISE POWER(I) 
and REPEAT~POUER(1) > NOISE POUER<2) then 

SNR :> REPEAT POUER(1) • TNERM_NOISE FLOOR; 

if REPEAT POUER(I) > THERM NOISE FLOOR FALSE ALARM_THRESHOLD then 
SELTGT :» 1; 

TGTTYP :» 2; 

else 

SELTGT :> 0; 

TGTTYP :» 0; 
end if; 

elsif NOISE POWER(1)>TGT POUER(t) and NOISE POUER(1)>TGT POWER(2) 
and NOISE POUERd) > REPEAT POUER(I) 
and NOISE POUERd) > REPEAT POUER(2) 
and NOISElPOUERd) > NOISE POUER(2) then 

SNR NOISE POUERd)' THERM_NOISE_FLOOR; 

if NOISE POUERd) > THERM NOISE FLOOR * FALSE ALARM THRESHOLD then 
SELTGT := 1; 

TGTTYP 2; 
else 

SELTGT :> 0; 

TGTTYP 0; 
end if; 

else 

SNR NOISE POUER(2) - THERM NOISE FLOOR; 

if NOISE_POUER(2) > THERM NOlSE FLOOR * FALSE ALARM THRESHOLD then 
SELTGT ;a 2; 

TGTTYP ;» 2; 

else 

SELTGT !» 0; 

TGTTYP :* 0; 
end if; 
end if; 
end if; 

-- determine if the soj power is detectable 
for I in 1..NUM_Of_SOJS loop 

case SOJ ECM TECH(I) is 
when'BARRAGE NOISE => 

if TGT F^R(I) > THERM NOISE FLOOR * FALSE ALARM THRESHOLD 
and TGT_POUER(I) > NOISE.POUERd) then 
'null; 

elsif NOISE POUERd) > THERM NOISE FLOOR *■ 

FALSE ALARM THRESHOLD then 

SELTGT ;= 1; 

TGTTYP ;» 1; 

SNR ;» NOISE_POUER<I) - THERM_NOISE_FLOOR; 

else 

SELTGT :» 1; 

TGTTYP ;■ 0; 

if TGT POUERd) > NOISE POUERd) then 

SNR !« TGT_POUERd) - THERM_NOISE_FLOOR; 

else 

SNR :> NOISE_POUERd) - THERM_NOISE_FLOOR; 
end if; 

end if; 

when others ■> 

SELTGT ;« 1; 

TGTTYP ;» 0; 

SNR ;» TGT_POUERd) - THERM_NOISE_FLOOR; 
end case; 
end loop; 
end SA_DETECT; 


procedure SA_NOOE is 

X_ACO_DELAY : CONSTANT :« 5.0; -- X band acq to track delay time 


160 











begin 

case RF PHASE is 

Hhm NIDCOURSE|NON ACTIVE » 

if SELTGT = 1 or SELTGT » 2 then 
RF PHASE:sX BAND ACQUISITION; 
if X ACQ_TIME » -lO.O then 

X_ACQ_TIHE:=ENVIRONHENT.Time; 
end if; 
end if; 

when X_BAND_ACaUISITION -> 

if~ENVIRONMENT.Time >= X ACQ TIME+X ACQ_DELAY then 
RF_PHASE:=X_BAMO_TRACK;~ 
end if; 

when others => 
nuU; 
end case; 
end SA_HODE; 


procedure A_POUERS is 

THERN_NOISE FLOOR : CONSTANT :> -150.0; — in db/filter 
MSL POWER TcONSTANT := 30.0; 

LOOP GAIN : REAL; — in db 
ERP0“; REAL; -- in db 
MSL_GAIN, DELTA_GAIN : REAL; 

begin 

for I in 1..NUM OF_TGTS loop 

MSL_ANT_GAINS_A(BSE(I),MSL GAIN,OELTA_GAIN); 

TGT POUERd) ;= -63.45> MSL POUER+2.0*HSL GAIN*10.0*L06{RCS(I))-40.0* 
log<TGT_RANGE<I))r 

case SSJ ECM TECH(I) is 
Hhen“REPEATER => 

LOOP GAIN ;* ECM POWEfid); 

REPEAT POUERd) -105.0 HAC TRANS PUR HAC GAIN *HSl GAIN 
LOOP.GAIN - 40.0*log(TGT RANGEd));" 

when BARRAGE NOISE -> 

ERPO :="ecm POUERd); 

NOISE POUERLI) := -88.65 + lAC TRANS PUR * LAC GAIN * HSL GAIN 
♦ ERPO - 20.^log{tGT_RANGEd)); 

when others *> 
null; 

end case; 
end loop; 

if NUM_OF SOJS /> 0 then 

for rin 1..NUM OF SOJS loop 

HSL_ANT_GAINS_A<BSEd+2),HSL_GAIN,DELTA_GAIN); 

case SOJ ECN TECHCI) is 
when BARRAGE NOISE -> 

ERPO:«ECM POUERd*2); 

NOISE_P0UERd♦2):=-100.0+ERPO*HSL_GAIN-20.0*LOG(TGT_RANGE(I+2)); 
when others => 

NOISE_POUER(1^2):= THERM_NOISE_FLOOR; 
end case; 
end loop; 
end if; 
end A_POUERS; 


procedure A_0ETECT is 

THERM_NOISE_FLOOR ; CONSTANT ;» -150.0; -- in db/filter 

-- assune a 1000 hz/filter BW 
FALSE ALARM THRESHOLD : CONSTANT 6.0; — in db 

NOISeItnRESHOLO : CONSTANT 8.0; -- in db 

begin 


161 











Calculate Power Levels 
A POUERS; 

i? NUM OF TGTS > 1 then 

if TOT POWERd) > REPEAT POUER(I) and TGT POWER(I) > NOISE POWER(I) then 
SNR :« TGT_POWER(1) ” THERH NOISE FLOOR; 

if TGT POUER(I) > THERM NOISE FLOOR * FALSE ALARM THRESHOLD then 
SELTGT :« 1; 

TGTTYP ;« 5; 
end if; 

elsif REPEAT POWER(1)>TGT POUER(I) and REPEAT_POUER(1)>NOISE POUER(I) then 
SNR REPEAT POUER(I) - THERM NOISE FLOOR; 

if REPEAT POUER(I) > THERM NOTSE FLOOR > FALSE ALARM_THRESHOLD then 
SELTGT ;» 1; 

TGTTYP := 4; 
end if; 
else 

SNR NOISE POUER(I) - THERM NOISE.FLOOR; 

if NOISE POUER(2) > THERM NOlSE.FLOOR > FALSE.ALARM THRESHOLD then 
SELTGT :« 1; 

TGTTYP := 4; 
end if; 
end if; 

else 

if TGT POUER(I) > TGT POUER(2) and TGT_POWER(1) > REPEAT POgER(2) and 
TGT_POUER(1} > REPEAT POUER(I) and TGT_POUER(1) > NOlSE POUER(1) and 
TGT POUERd) > NOISE PbuER(2) then 

SNR TGT.POUERID - THERM NOISE FLOOR; 

if TGT POUERd) > THERM NOISE FLOOR « FALSE ALARM THRESHOLD then 
SELTGT ;= 1; 

TGTTYP := 4; 
end if; 

elsif TGT_POUER(2) > TGT POUERd) and TGT POUER(2) > REPEAT POUER(2) and 
TGT POUER(2) > REPEAT POUERd) and TGT POUER(2) > NOISE~POUERd) and 
TGT'pOUER<2) > NOISE PbUER(2) then 

~SNR :s TGT POUER<2) • THERM NOISE FLOOR; 
if TGT P0UER(2) > THERM NOISE FLOOR « FALSE ALARM THRESHOLD then 
SELTGT :» 2; 

TGTTYP :a 5; 
end if; 

elsif REPEAT POUER(2) > TGT POUERd) and REPEAT POUER(2) > 

TGT POUER(2) and REPEAT_POUER(2)>REPEAT POUERd) and 
REPEAT_POUE3<2)>NOISE_POgERd) and REPEAT_POUER(2) > NOISE_POgER(2) 
then 

SNR :« REPEAT POUER(2) • THERM NOISE FLOOR; 

if REPEAT P0UER(2) > THERM NOTSE.FLOOR * FALSE ALARM THRESHOLD then 
SELTGT“;» 2; ~ 

TGTTYP ;= 4; 

end if; 

elsif REPEAT POUERd)>TGT POUERd) and REPEAT POUERd)>TGT POUER(2) 
and REPEAT POUERd)>REPEAT POUERd) and ~ 

REPEAT_POUER<1)>MOlSE_POUERd) and REPEAT_POUERd) > NOISE_POUER(2) 
then 

SNR :> REPEAT POUERd) - THERM NOISE_FLOOR; 

if REPEAT POUERd) > THERM NOTSE.FLOOR * FALSE_ALARM THRESHOLD then 
SELTGT := 1; 

TGTTYP :* 4; 
end if; 

elsif NOISE POUERd)>TGT POUER<1) and NOISE POUERd)>TGT POUER(2) 
and NOIK POUERd)>REPEAT POUERd) and NOISE POUERd)~> 

NOISE POUERd) and NOISE ^Rd) > NOISE POUER(2) then 
SNR NOISE POUERd) - THERM NOISE FLOOR; 

if NOISE POUERd) > THERM HOlSE FLOOR ♦ FALSE ALARM THRESHOLD then 
SELTGT :» 1; 

TGTTYP :» 4; 
end if; 

else 

SNR NOISE POUER(2) - THERM NOISE_FLOOR; 

if NOISE POUER(2) > THERM NOTsE FLOOR « FALSE ALARM THRESHOLD then 
SELTGT :« 2; 


162 









TGTTYP ;» 4; 
end if; 
end if; 
end if; 

-- deteneine if the soj power is detectable 
for I in 1..NUM_0F_S0JS loop 

case SOJ ECH TECH(I) is 

ii^en~BARRAGE NOISE => 

if TGT POUERd) > THERN NOISE_FLOOft * FALSE ALARM THRESHOLD and 
TGT“p 0UER(I) > M01SE~P0UER(I) then 
null; 

elsif NOISE POUERd) > THERM_NOISE FLOOR * FALSE_ALARN THRESHOLD then 
SELTGT ;= 1; 

TGTTYP := 1; 

SNR NOISE_POUERd) - THERM_NOISE_FLOOR; 
else 

SELTGT != 1; 

TGTTYP ;= 0; 

if TGT POUERd) > NOISE POUERd) then 

SNR ;= TGT_POUERdr - THERM_MOISE_FLOOR; 

else 

SNR ;= NOISE_POUERd) - THERM_MOtSE_FLOOR; 
end if; 
end if; 

when others -> 

SELTGT := 1; 

TGTTYP := 0; 

SNR TGT_POUERd) - THERM_NOISE_FLOOR; 
end case; 
end loop; 
end A_DETECT; 


procedure A MODE is 

K_ACQ_DELAY ; CONSTANT;* 5.0; 

begin 

case RF PHASE is 

uhm X BAND TRACK|NON_ACTIVE *> 
if~ TGTfYP in 4..5 then 

RF PHASE:*I( band acquisition; 
if K ACa_TIME « -lO.O then 

i(_ACQ_T I ME: *ENVI RONMENT. T ime; 
end if; 
end if; 

when k_band acquisition => 

if ENVIRONMENT.Time >* K_ACQ TIHE-^K ACQ_DELAY then 
RF_PHASE;=K_BAMD_TRACK;~ 
end if; 

when others *> 
null; 
end case; 
end A MODE; 


procedure DETECTIOHfTGT RANGE IN, 

RANGE TGf UC IN 
RF PHASE OUT 
SNR OUT 
TGfTYP OUT 
BSE OUT 


in VECTOR; 
out RF_PHASE_TYPE2; 
out REAL; 
out INTEGER; 
out VECTOR) is 


begin 

TGT RANGE:>TGT RANGE IN; 

RAMCE_TGT_LAC:=RANGeItGT_LAC_IN; 

-- Determine if we heve ^ired the target in S/A X-band, Ka band or are 
-- still in midcourse 


163 














if RF PHASE /> K BAND ACQUISITION or RF PHASE /» K BAND TRACK then 
SA DETECT; 

SA'nOOE; 
end if; 

A DETECT; 

A_MOOE; 

SNR OUT:>SNR; 

RF PHASE OUT:>RF PHASE; 

BSE QUT:=BSE; 

TGTTYP OUT:=TGTTYP; 
end DETECTION; 

end RF.SEEKER; 


-- Packege IR.SEEKER 


with MATH; use MATH; 

with MODEL TYPES; use MODEL TYPES; 

with REAL_MATRIX; use REAL_MATRIX; 

package IR_SEEKER is 

procedure SETUPdR TGT1 SIGNATURE IN, IR_TGT2 SIGNATURE IN: 
in TGTJR_SI2E_TYPE); 

procedure INITIALIZE(TGT ALTITUDE, MSL ALTITUDE: in REAL; 

IR^ACQ.RANGE: out REAL); 

procedure DETECTION (RANGE! : in REAL; IR PHASE OUT : out 
IR_PHASE_TYPE); 


end IR.SEEKER; 


*■ Package IR^SEEKER body 


with MATH; use MATH; 
with MODEL TYPES; use MODEL TYPES; 
with REAL.MATRIX; use REAL MATRIX; 
with ENVIRONMENT; 

package body IR_SEEKER is 

IR PHASE: IR PHASE TYPE; 

IR SEARCH TINE: REAL; 

IR ACQ TIME : REAL; 

IR“tRK~TIME : REAL; 

IR"tGtT signature : TGT IR SIZE TYPE; 
IR TGT2 SIGNATURE : TGT IR SIZE TYPE; 


procedure SETUPdR TGT! SIGNATURE IN, IR TGT2 SIGNATURE IN: 
in TGT_IR_SIZE_TYPE) is 

begin 

IR TGT! SIGNATURE:«IR TGT! SIGNATURE IN; 

IR TGT2 SIGNATURE:siR~TGT2 SIGNATURE IN; 

IR PHASE:* NON ACTIVE; 

IR SEARCH TINE:sO.O; 

IR~ACO TINE:*0.0; 

IR“trK~TIME:» 0.0; 
end SETUP; 


164 















proceduriB IM1TIALIZE(TGT ALTITUDE, NSL ALTITUDE: 

IrJaCO.RANGE: out REAL) is 

begin 

if TGT_ALTITUDE > 70 000.0 then 

if IR TGT1 SIGNATURE > SMALL then 
I R_ACO~RANGE: >200000.0; 

else 


IR_ACa_RANGE:=400000.0; 
end if; 

elsif TGT ALTITUDE > 10 000.0 then 
if IR TGT1 SIGNATURE « SMALL then 
IR_ACQ~RANGE:=100000.0; 
elsif Tr TGT1 SIGNATURE = MEDIUM then 
IR AGO RANGE:=200000.0; 
elsif Tr_TGT1 signature = LARGE then 
I R_ACQ_RANGE: =350000.0; 
end if; 

else 


if IR TGT1 SIGNATURE = SMALL then 
IR AGO RANGE:*6000.0; 
elsif Tr TGTI signature = MEDIUM then 
IR_ACO RANGE:=100000.0; 
elsif IR TGTI SIGNATURE = LARGE then 
IR_ACQ_RANGE:=150000.0; 
end if; 
end if; 

end INITIALIZE; 


in REAL; 


procedure OETEGTION (RANGE1 : in REAL; IR_PHASE_OUT : out 



IR_PHASE_TYPE) is 


SEARCH DELAY 

: constant := 5.0; 

-- delay from 

ACQ DELAY 

: constant := 1.0; 

from 

TRK^DELAY 

: constant := 1.0; 

-- from 

DELTA SEARCH 

: REAL; -- local 

variables 

DELTA ACQ 

: REAL; 


DELTA TRK 

: REAL; 



radome off until IR SEARGH 
IR SEARGH until IR AGQUISITION 
IR~AG0UISIT0N until IR TRAGK 


begin 


case IR PHASE is 
when NON AGTIVE => 

if IR SEARGH TIME = 0.0 then 

iOeARCH_TIME := ENVIRONMENT.Time; 
end if; 

DELTA SEARGH := ENVIRONMENT.Time - IR SEARGH TIME; 
if DELTA SEARGH >» SEARCH DELAY then “ 

IR_PHASE:= IR_SEARCH;~ 
end if; 

when IR SEARCH => 

if 1 r ago time = 0.0 then 

ENVIRONMENT.Time; 

end ifj 

DELTA AGO :> ENVIRONMENT.Time • IR AGO TIME; 
if DELTA AGO » AGO DELAY then 
IR_PHASE:- IR_ACOUISITION; 
end if; 

when IR ACQUISITION => 

if 1 r TRK time > 0.0 then 

IR.TaOiME :> ENVIRONMENT.Time; 
end if; 

DELTA TRK :* ENVIRONMENT.Time • IR TRK TIME; 
if DELTA TRK >» TRK DELAY then 
IR_PHASE:« IR_TRACK; 
end if; 

when IR_TRACK => 

null; -- Once in IR_TRACK always in IR_TRACK 

end case; 


IR_PHASE_OUT :» IR_PHASE; 


165 












end DETECTION; 
end IR_SEEICER; 


-- Guidence Peckage Specification 

-- This package contains the data types and subprograms used in modeling the 
-- guidance subsystem. 


with MATH; use MATH; 

with REAL MATRIX; use REAL MATRIX; 

with MOOEL_TYPES; use MOOEL_TYPES; 

package GUIDANCE is 

procedure INITIALIZE ( 

ALTITUDE : in REAL; 

TGT ALTITUDE : in REAL; 

TGT RANGE : in VECTOR; 

TGT_VEL ; in VECTOR); 

procedure COMPUTE ( 

TIME TO GO : in REAL; 

ALTITUDE : in REAL; 

ALTITUDE RATE : in REAL; 
velocity" : in REAL; 

AXIAL ACC : in REAL; 

PITCH'BQO : in REAL; 

TGT RANGE : in REAL; 

TGT'rANGE rate : in REAL; 

SKR^GIMSAL.ANGLE : in VECTOR; 

CMEfiAl SICR * in VECTOR* 

GUIOANK PHASE OUT : out GUIDANCE PHASE TYPE; 
ACCjmJOD ; out VECTOR); 

end GUIDANCE; 


* Guidance Package Body 

* This package contains the data types and subprograms used in modeling the 
- guidance subsystem. 


with NATH; use MATH; 
with MODEL TYPES; use MODEL TYPES; 
with REAL MATRIX; use REAL MATRIX; 
with ENVIRONMENT; 

package body GUIDANCE is 


-- Mode selection constants 


GUIDANCE INITIATE TIME : constant :> 0.8; — Sec 
TURN00UN~GIM8AL ANGLE : constant :« AO.O • DEC TO RAO; -- Rad 
TRANS ClTnB angle : constant :« 20.0 • DEG TO RAO; — Rad 


-- Altitude hold algorithm constants 


DESIRED ALTITUDE : constant :« 70000.0; -- Feet 
ALTITUDE.OELTA : constant :« 50.0; -- Feet 
ALTITUDE~GAIN : constant :■ 0.1; -- Ft/Sec / Ft 
ALTITUOEIrATE_OAIN : constant ;» 0.3; -- Ft/Sec^2 / Ft/Sec 


166 





















r 


ALTITl»E_ACC_HNIT ; constant :■ 160.0; -- Ft/Sec*2 


- Guidance algorithm constants 


LOAD BIAS FACTOR : constant -5.0 * G; - Ft/Sec^Z 
ACCEL LImTt ; constant :» 35.0 * G; -- Ft/See*2 
CRUISE ALPHA EST : constant := 10.0 • DEG TO RAD; - Rad 


Data definitions 


GUIDANCE PHASE : GUIDANCE PHASE TYPE; 

PREV GUIDANCE PHASE : GUIDANCE PHASE_TYPE; 
COS TOT GINBAL ANG : REAL; 

COS~TURNDOWN gTnBAL ANGLE : REAL; 

CLIMB ANGLE REAL? 

AXIAL~ACC COMP : REAL; 

PIT ACC cib : REAL; 

YAW ACC CMO : REAL; 

ALtTtUDE_RATE LIMIT : REAL; 

ALT RATE LIMIT SET : boolean; 

LOS_BIAS": REAL; 

HOLD PATH TIME : REAL; 

TERmTnAL TGO THRESHOLD : REAL; 

LONG RANGE :~boolean; 

ALT SWITCH, ALT RATE SWITCH : REAL; 

PIT~ACC COMP enabled': boolean; 


procedure INITIALIZE ( 

ALTITUDE : in REAL; 

TGT ALTITUDE : in REAL; 

TGT RANGE : in VECTOR; 

TGT_VEL : in VECTOR) is 

RANGE_HORIZ : REAL; 

TGT VEL HORIZ : REAL; 

REL VEL NOSE, REL VEL TAIL, REL VEL : REAL; 

HORIZ_ASPECT_ANGLE : REAL; 

DT SEP, DX SEP, OT HOLD, DX HOLD : REAL; 

R SG BIAS,~X 5G BIAS, H 5G BIAS, T 5G BIAS : REAL; 

R VAR ARC, DX VAR ARC, DT VAR ARC : REAL; 

X alt'hold, t'alt'hold : realJ 

DX TGT : REAL; 

a» ASPECT ANGLE, SIN ASPECT ANGLE : REAL; 

GIM_PITCH0VR_RNG, delta height : REAL; 

TGO PITCHOVR RNG, TGO pTtCHOVR RNG NOSE, TGO_PITCHOVR RNG TAIL : REAL; 
DISCRIMINANT : REAL; 

LOS PITCHOVR RNG, LOS PITCHOVR RNG NOSE, LOS_PITCHOVR RNG TAIL : REAL; 
PITCHOVR_RNG“nOSE, PITCHOVR RNG_TATl : REAL; 

RNG.NOSE, RNG_TAIL, DELTA.RNG, RADIUS, THRESHOLD_RANGE : REAL; 
begin 

GUIDANCE PHASE NULL COMMANDS; 

ALT RATE LIMIT SET := false; 

PIT ACC COMP ENABLED :« false; 

COS_TURNDOUN~GINBAL_ANGLE := COS(TURNDOWN_GIHBAL_ANGLE); 

-- LOS rate bias and time-to-go threshold based on tgt altitude 

if TGT ALTITUDE <* 50000.0 then 
LOS BIAS :> 0.0025; 

TERMINAL_TGO_THRESHOLO :» 40.0; 

else 

LOS BIAS :> 0.001; 

TERMINAL TGO THRESHOLD :> 15.0 * TGT ALTITUOE*0.0005; 


167 

















end if 


-- Horizontal tgt range and relative velocity 

RANGE HORIZ := SQRT(TGT RANGE<1)**2 * TGT RANGE(2)**2); 

TGT_VEL_HORI2 ;a SORT{TGT_VEL(1 )**2 + TgOeL(2>**2>; 

" Altitude hold mode rel. vel. for nose & tail aspect 

REL VEL NOSE 3000.0 * TGT VEL HORIZ; 

REL“vEL”taIL ;= 3000.0 - TGT'vElIhORIZ; 

-- Horizontal aspect angle 

SIN ASPECT ANGLE (TGT VEL(2)*TGT_RANGE(1) - 

“TGT VEL(1)*TGT RANGE(2)) / (RANGE HORIZ * TGT_VEL HORIZ); 

COS_ASPECT ANGLE (TGT VEL(1)*TGT RANGE(I) * 

TGT_VEL(2)*TGT_RANGE(2)) / (RANGE_HORIZ * TGT_VEL_HORIZ); 

HORIZ_ASPECT_ANGLE :> ATAH2(SIN_ASPECT_ANGLE. COS_ASPECT_ANGLE); 

-- Time to hold before Sg bias dint) 

if TGT ALTITUDE > 70000.0 then 
if~ALTITU0E > 20000.0 then 

if MAGNITU0E(TGT RANGE) < 110.0*FEET_PER_NHI then 
DT HOLD 20.0; 

elsif NAGNITUDE(TGT RANGE) > 120.0*FEET PER NNI then 
0T_H0LD ;» 10.Oj 

else 

DT NOLO := 20.0 * (HAGNtTUDE(TGT RANGE)-110.0*FEET PER NHI)* 
(10.0-20.0) / ((120.0-110.0)*FEET_PER_NHI); 
end if; - - 

HOLD PATH TIME :> ((TGT ALTITUDE-DESIRED ALTITUDE) / 
(90000.0-0ESIRE0 ALTITUDE)) * ((ALTITUDE-20000.0) / 
(30000.0-20000.0)) • 20.0; 

if HOLD PATH TINE > OT NOLO then 
HOLD_PATH_TINE !» OT_HOLO; 
end if; 

else 

HOL0_PATH_TIME := 0.8; 
end if; 

else 

HOL0_PATH_TIME 0.8; 
end if; 

-- Estimated missile travel, separation phase 

DT SEP 0.8; 

OX^SEP ;« 1000.0 • 0T_SEP; 

-- Estimated missile travel, flight path hold phase 

OT HOLD HOLD PATH TIME - OT SEP; 

OX_HOLO ;• (dOM.O ♦ 2600.0) 7 2.0) * OT_HOLD; 

-- Estimated missile travel, Sg bias phase 

R SG BIAS :» (2600.0 ** 2) / (-LOAO_BIAS FACTOR); 

X SG BIAS :> OX SEP ♦ OX HOLD « R SG BIAS * SIN(TRANS CLIMB ANGLE); 

H SG~BIAS :> ALTITUDE R SG BIAS~* (1.0 - COS(TRANS CLIMB_ANGLE)); 

T SG~BIAS :> TRANS CLIMB ANGLE * 2600.0 / (-LOAD BIAS FACTOR) « OT SEP * 
OT_HOLD; 

-- Estimated missile travel, variable arc phase 
R_VAR_ARC ;« (OESIRED_ALTITUOE - H_SG_BIAS) / 


168 










(1.0 - (»S(TRANS CLIMB ANGLE)); 

DX VAR ARC :> R VAR ARC * SIN(TRANS CLINB_ANGLE); 

0T_VAR“aRC :» TRANS_CLIMB_ANOLE • R_VAH_ARC / ((2600.0 ♦ 3000.0) / 2.0); 

-- Estinated missile travel, altitude hold phase 

X ALT HOLD :> X 5G BIAS * OX VAR ARC * 3000.0*20.0; 

T_ALT_HOLO :« T_5G_BIAS ♦ 0T_VAR_ARC ♦ 20.0; 

-- Estimated target travel 

0X_TGT := TGT_VEL_HORI2 * T_ALT_HOLD; 

-- Gifflbal angle pitchover range 

DELTA HEIGHT DESIRE0_ALTITUDE - TGT ALTITUDE; 

GIN pTtCHOVR RNG abs(DELTA HEIGHT) 7 TAN(TURNDOUN_GIMBAL_ANGLE - 
"CRUISE_ALPHA_EST*SIGH(DELTA_HEIGHT)); 

-- Time to go pitchover range 

REL_VEL := REL_VEL_HOSE; 
for I in 1..2 loop 

TGO PITCHOVR RNG NOSE TGO PITCHOVR RNG; 
discriminant":* (REL VEL*TERMINAL TGO^THRESHOLD) ** 2 - 
4.0 * (0ELTA_HEIGHT ** 2); 

if DISCRIMINANT >* 0.0 then 

TGO PITCHOVR RNG :* (REL_VEL*TERHINAL_TGO THRESHOLD * 
~SORT(DISCRIMINANT)) / 2.0; 

else 

TGO_PITCHOVR_RNG ;= 0.0; 
end if;” 

•* LOS rate pitchover range 

LOS PITCHOVR RNG NOSE :* LOS PITCHOVR RNG; 

DISCRIMINANT :« (REL VEL / (O.S*DEG TO RAD)) - abs(DELTA HEIGHT); 
if DISCRIMINANT > 0.0 then 

LOS_PITCHOVR_RNG :* SQRT(abs(0ELTA_HEIGHT) * DISCRIMINANT); 

else 

LOS_PITCHOVR_RNG ;= 0.0; 
end if; 

REL_VEL :* REL_VEL_TAIL; 
end loop; 

if REL VEL TAIL > 0.0 then 

TGO PITCHOVR RNG TAIL :* TGO_PITCHOVR RNG; 

losIpitchovr”rmg“tail ;» los_pitchovr”rng; 

else 

TGO_PITCHOVR RNG TAIL :* 0.0; 

LOS_PITCHOVR_RNG_TAIL :* 0.0; 
end if; 

PITCHOVR RNG NOSE :* MAX3(GIM PITCHOVR RNG. TGO PITCHOVR RNG_NOSE, 

LOS PITCHOVR RNG NOSE); 

PITCHOVR RNG TAIL :*~NAX3(GIN PITCHOVR RNG. TGO PITCHOVR_RNG TAIL, 

LOSjPITCHOVR_RNG_TAIL); 

-- Coapute algorithm selection threshold range 

RNG NOSE :> X ALT_HOLD * PITCHOVR RNG_NOSE « DX TGT; 

RNG^TAIL :» x"ALT_HOLO ♦ PITCHOVR"rnG_TAIL - DX^TOT; 

DELTA RNG :* (RNG NOSE - RNG TAIL) / 2.0; 

RADIui (RNG.NOSE * RNG.TaTl) / 2.0; 

THRESHOLD_RANGE :> SQRT(RA0IUS**2 - (0ELTA_RNG*SIN_ASPECT_ANGLE)**2) - 


169 






DELTA_RMG*COS_ASPECT_AMGLE; 

-- Deterwfne if 'long* or 'short* range flight A set parameters 

if RANGE NORIZ < THRESHOLD RANGE then 
LONG RANGE false; 

ALT SWITCH := 60000.0; 

ALtIraTE_SWITCH 600.0; 
else 

LONG RANGE ::: true; 

ALT SWITCH 69000.0; 

ALTIraTE_SW 1TCH := 0.0; 
end if; 

end INITIALIZE; 


procedure COMPUTE ( 

TIME_TO_GO : in REAL; -- Midcourse estimated time to go 
ALTITUDE ; in REAL; -- Msl altitude above round earth 
ALTITUDE.RATE : in REAL; -- Derivative of altitude 
VELOCITY : in REAL; -- Velocity magnitude 
AXIAL_ACC : in REAL; -- INS measured axis 1 accel. 

PITCH_B00 ; in REAL; -- Pitch relative to earth 

TGT_RANGE : in REAL; -- Estimated range to tgt 

TGT~RANGE RATE : in REAL; -- Derivative of TGT RANGE 
SKR~GINSAL_ANGLE : in VECTOR; -- Seeker LOS angles 
QMEGA1 SKR : in VECTOR; ■■ Seeker LOS angle rates 
GUIDANCE_PHASE_0UT : out GUI0ANCE_PHASE_TYPE; 

ACC_CM0_B00 : out VECTOR) is -- Body acceleration cmds 


procedure GUIDANCE MODE is 

TOTAL LOS rate": REAL; 

TOTAL GIMBAL ANG : REAL; 

VEL_lTmIT : REAL; 
begin 

PREV_GU1DANCE_PHASE t» GUIDANCE.PHASE; 

COS.TOT GIMBAL ANG :« COS(SKR GIMBAL ANGLE(2» • 

COSfSKR GIMBAL ANGLE(3)); 

TOTAL gTmBAL ANG :> ACOS(COS_TOT GIMBAL ANG); 

TOTAL_LOS_RATE SQRT<0MEGA1_SKR(2)**2"* 0MEGA1_SICR(3)**2); 

if ENVIRONMENT.Time » GUIDANCE INITIATE.TIME then 
if PREV GUIDANCE_PHASE = TERMINAL or 
TIME TO'gO TERMINAL_TGO THRESHOLD then 
^IOANCE_PHASE :> TERmTnaL; 

etsif PREV GUIDANCE.PHASE = TURN_D0WN then 

GUIDANCE_PHASE := TERMINAL; -- Incomplete in 6DOF 

elsif PREV GUIDANCE PHASE = ALTITUDE HOLD then 
if TOTAL LOS_RATE >« 0.5*0EG TO_RAO or 
COSJOT GIMBAL ANG <= COS TURNDOWN_GIMBAL ANGLE then 
''gUI 0ANCE_PHASE :» TERMINAL; 
else 

OUIDANCE_PHASE :> ALTITUOE_HOLD; 
end if; 

elsif PREV GUIDANCE PHASE - VARIABLE_ARC then 
if TOTAL LOS RATE >» 0.5*0EG TO RAD then 
GUIDANCE~PHASE :« TERMINAL;" 
elsif ALTITUDE » ALT SWITCH and 
ALTITUDE RATE » ALT RATE SWITCH then 
OUIDAHCE_PHASE :* ALtTtUOE_HOLD; 
else " 

GUIDANCE_PHASE := VARIABLE.ARC; 
etri if; 


170 













elsif PREV_GUIDANCE PHASE = LOAD BIAS then 

CLIMB_ANGLE := ASIN<ALTITUDE_RATE / VELOCITY); 

if CLIMB_ANGLE >= TRANS CLIMB ANGLE then 
GUIDANCE_PHASE := VARIABLE_ARC; 

else 

GUIDANCE_PHASE LOAO_BIAS; 
end if; 

elsif PREV GUIDANCE PHASE = HOLD_PATH then 
if ALTTtUDE « 30000.0 then 

VEL LIMIT := 2900.0 ♦ 0.0225*ALTITU0E; 
elsif ALTITUDE <= 70000.0 then 

VEL_L1MIT := 3500.0 ♦ 0.00725*(ALTITUOE-30000.0); 

else 

VEL_LIMIT := 3800.0; 
end if; 

if VELOCITY >= (VEL LIMIT-150.0) then 
GUIDANCE PHASE LOAD_BIAS; 

elsif ENVIRONMENT.Time > HOLD PATH TIME then 
GUtDANCE_PHASE := LOAD_BIAS; 

else 

GU1DANCE_PHASE := H0L0_PATH; 
end if; 

elsif PREV GUIDANCE PHASE = NULL COMMANDS then 
if HOLD PATH TIME 0.8 then 
GUIDANCE~PHASE := LOAO_BIAS; 
else ~ 

GUI0ANCE_PHASE := HOLD_PATH; 
end if; 
end if; 
end if; 

end GUIDANCE MCnP; 


function ALTITU0E_HOLD_CMD 
return REAL is 

ALTITUDE RATE CMD : REAL; 

ALTITUOE"ACC_a® : REAL; 
begin 

if not ALT RATE LIMIT SET then 

ALTITUDE RATE LImTt abs(ALTITUDE RATE); 

ALT_RATE_LIMIT_SET :* true; 
end if; 

ALTITUDE RATE CMD :* -ALTITUDE GAIN * (ALTITUDE - DESIRED ALTITUDE); 
ALTITUDeIrATE^CMD := LIMIT(ALTITUDE_RATE_CMD. ALTITUDE_RATE_LIMIT); 

ALTITUDE ACC CMD :» ALTITUDE RATE_GAIH • (ALTITUDE RATE - 
ALTITUDE RATE CMD); 

ALTITIJDE_ACCICI® Tx LIMIT(ALTITUDE_ACC_CMD, ALTITUDE_ACC_LIMIT); 

return ALTITUDE ACC CMD; 
end ALTITUDE_HOLD_CMD; “ 


procedure GUIDANCE COMMANDS is 
TOTAL ACC CMD 7 REAL; 
GUIDANCE_MIN : REAL; 
begin 

if GUIDANCE PHASE > TERMINAL then 
GUIDANCE GAIN ;> 3.0; 
PIT_ACC_COMP_ENABLED :* true; 

else 

GUIOANCE.GAIN 40; 
end if; 


171 











-- Yaw acceleration conmand 

case GUIDANCE PHASE is 
when NULL~CONNANOS => 

YAW_ACC_CHD := 0.0; 

Mhen others => 

AXIAL_ACC_C0NP := AXIAL_ACC - 6»SIN(PITCH_BOO); 

-- axial_acc_comp used for pitch conmand also 

YAU_ACC CMO -GUIDANCE_GAIN * TGT_RANGE RATE * 
(0HEGArSKR(2) * TAN(SICR_GIMBAL ANGLE(2)r* 

TAN(SKR_GINSAL ANGLE(3» * CWGA1_SKR(3) / 

COS(SKR_GINBAlIaNGLE(3))); 

YAW_ACC cm := YAW ACC_C»I0 ♦ AXIAL ACC COMP * 
TAN(SKR~GIMBAL_ANGLE(3)) / COS(SKR~GIhIaL_ANGLE( 2)); 
end case; 

-- Prop. Nav. Pitch acceleration conmand 

PIT ACC CND GUIDANCE GAIN • TGT RANGE_RATE * 

0MEGA1_SKR(2) / COS(SKR~GINBAL_ANGLE(2)); 

if PIT ACC COMP ENABLED then 

PIT ACC CMD“:= PIT ACC CMD - AXIAL_ACC_COMP * 

TAN< SKr"gIMBAL_ANGLE( 2)); 
end if; 

-- Pitch acceleration conmand 

case GUIDANCE PHASE is 
when NULL'cOMHANDS => 

PIT_ACC_CMD :» 0.0; 

when HOLD PATH >> 

PIT_ACC_CM0 :» 0.0; 

when LOAD BIAS » 

if LONG RANGE then 

PIT“aCC_CMD := LOAO_BIAS_FACTOR; 
else ~ ~ ~ 

PIT_ACC_CMD ;» PIT_ACC_CMD + LOAD_BIAS_FACTOR; 
end if; ~ 

when VARIABLE ARC => 
if LONG RANGE then 

CLIMB ANGLE ;= ASIN(ALTITUOE_RATE / VELOCITY); 

PIT ACC CMD .-3 (1.0 - COSfCLIMB ANGLE)} * 

(VELXITY •• 2) / ((DESIRED ALTTtUOE ♦ ALTITUDE DELTA) 
- ALTITUDE); 

else 

PIT ACC CMD PIT ACC CMD * GUIDANCE GAIN • 
TGT“rANGE_RATE * LOS_bTaS / COS(PITCH~BOO); 
end if; 

when ALTITUDE HOLD «> 

PIT_ACC_CMD ;» ALTITUDE_HOLO_CMD / COS(PITCH_BOO); 

when TURN_DOUN » 

null; -- Use Prop. Nav. conmand 

when TERMINAL » 

null; -- Use Prop. Nav. conmand 
end case; 

Compensate for gravity 

PIT_ACC_CMD :» PIT_ACC_CMD - G * COS(PITCH_BOD); 


172 










Limit acceleration coanands 

TOTAL_ACC_C» := SORT{YAU_ACC_CMD**2 ♦ PIT_ACC_C»C**2); 

if TOTAL ACC CMD > ACCEL LIMIT then 

PIT ACC a® :* ACCEL“lIMIT*<PIT_ACC_CMD / TOTAL ACC CMD); 
YAW'aCcIcMD ;= ACCElIlIMIT*<YAW_ACC_CMD / TOTAL_ACC_CMO); 
end if; ~ 

end GUIDANCE_COMMANDS; 

begin 

GUIDANCE MODE; 

GUIDANCE'cOMMANDS; 

GUIDANCE_PHASE OUT := GUIDANCE PHASE; 

ACC CMD BOO(2)~:> YAW ACC CMD;~ 

ACC“CMO~BOO<3) ;= PIT~ACC"CMO; 
eixl COHNTE; 
end GUIDANCE; 


■■ Kinematics package 

-- This package contains the procedures which will initialize 

-- and then perform the necessary calculations to determine the kinematic 

-- variables that are required to perform the simulation. 


with MATH; use MATH; 

with REAL MATRIX; use REAL MATRIX; 

with MOOEL_TYPES; use MOOEL_TYPES; 

package KINEMATICS is 

procedure SETUP(NTGTS_IN,NSOJS_IN: in INTEGER); 

procedure COMPUTEIMSL POS, MSL VEL, TGT VEL: in VECTOR; TGT POS: 

in ^PER VECfoR; RANGE VEC: in out SUPER VECTOR; 

OMEGA: out VECTOR; TGT RANGE, RDOT, MISS_DISTANCE NED: 
in out VECTOR; TIME_TO_GO, MISS_DISTANCE: in out REAL); 

procedure EOMfMSL POS, MSL VEL VEC, ANGLE_0_ATTACK: in VECTOR; COEF DRAG, 
MSL MASS, THRUST: in REAlJ MSL X ACC BOD: out REAL; 

MSL“vEL, MSL_HEADING_AZ, PITCH,“q 7 in out REAL); 

procedure MACH NO(ALTITUDE: in REAL; MISSILE VEL: in VECTOR; 

MACH: out~REAL); 

procedure OIR_COS(PSI, THETA: in REAL; EIB: out MATRIX); 
end KINEMATICS; 


-- Kinematics package 

-- This package contains the procedures which will initialize 

-- and then perform the necessary calculations to determine the kinematic 

-- variables that are required to perform the simulation. 


with ENVIRONMENT; 

with MATH; use MATH; 

with REAL_MATRIX; use REAL_MATRIX; 

package body KINEMATICS is 

-- List of variables that are global to the KINEMATICS package. 

SREF constant REAL:* 0.492; -- Missile reference area, ft**2 


173 









NTGTS 

NSOJS 


INTEGER; 

INTEGER; 


procedure SETUP(NTGTS_IN, NSOJS_IN: in INTEGER) is 
bepin 

NTGTStsNTGTS IN; 

NSOJS:sNSOJS~ IN; 
end SETUP; 


procedure COMPUTE(MSL POS, MSL VEL, TGT VEL: in VECTOR; 

TGT“pOS: in“sUPER VECTOR; RANGE VEC: 
in out SUPER VECTOR; OMEGA: out~VECT0R; 

TGT RANGE, ROOT, MISS OISTANCE_NEO: in out VECTOR; 
TIHE_TO_GO, NISS_OISTANCE: in out REAL) is 

RHO: SUPER_VECTOR(1..4); -- Missile to target vectors unit vector 

MSL TGT VEL: -- Missile to target one velocity vector 
VECT0R<T..3); 

begin 

-- Calculate MSL_TGT VEL 
MSL_TGT_VEL:=TGT_VEL“mSL_VEL; 

for I in 1..NTGTS loop 

-- Calculate the missile to target range vector 
RANGE_VEC(I):*TGT_POS(I)-MSL_POS; 

-• Calculate the missile to target range 
TGT_RANGE(I):=MAGNITUDE(RANGE_VEC(I)); 

•• Calculate the unit vector of the range vector 
RHO(I):sRANGE_VEC(I)/TGT_RANGE(I); 

-- Calculate RDOT(l) 

RDOTlI);* OOT_PROOUCT(RHO(1),MSL_TGT_VEL); 
end loop; 

for I in 1..NS04S loop 

RANGE_VEC(I*2);»TGT POS<I*2)-MSL POS; 

TGT.RANGE>MAGNITUDE< RANGE_VEC(I«2)); 
end loop; ~ 

** Calculate the Line of sight <LOS) vector OMEGA 
OMEGA:*CROSS_PROOUCT<RHO<1),MSL_TGT_VEL)/TGT_RAMGE{1); 

-■ Calculate~the estimate of the time to go ~ 
if RDOT(I) s 0.0 then 
ROOT(1):30.001; 
end if; 

MISS DISTANCE NE0:-RANGE VEC(1)-MSL TGT VEL* 

“dot HIOOUCTIRANCE VEC(1),MSL_TGT VEL) 

/MAGNITUDE(MSL TGT_VEL)/MAGNITUDE(HSL TGT VEL); 

MISS_DISTANCE:>MAGNITUDE(MISS_DISTANCE_NED); 

if TIME TO GO 4.0 then 

TIME TO GO:*(-SQRT(TGT RANGE<1)*TGT RANGE(1)-MISS DISTANCE* 

“ MISS_DISTANCE r)/RD0T(1); 

else 

TIME_TO_GO:>-TGT_RANGE(1)/RDOT(1); 
end if; 

if TIME TO GO >« 1000.0 or (ENVIRONMENT.TIME < 2.0 and 
TIME TO GO < 0.0) then 
TIME TO G0:*1000.0; 
elsif TIME TO GO < 0.0 then 
TIME_TO_GO:«0.0; 
end if; 
end COMPUTE; 


174 













procedure EGM(MSL POS, MSL VEL VEC, ANGLE 0 ATTACK: in VECTOR; COEF DRAG, 
NSL_NASS, THRUST: in REAL; NSL X ACC M: out REAL; 

NSL_VEL, MSL_HEADING_AZ. PITChT Q: In out REAL) is 

-- This procedure calculates the missile axial acceleration 
-- vector from the inputs. This vector is returned to the 
-- MISSILE.COMPUTE procedure, where it is made available to 
-- the applications package for integration. 

DRAG : REAL; 

begin 

-- Calculate the missile heading angles 

PITCH:=AMGLE_0 ATTACK(2)+ATAM(-MSL_VEL_VEC(3)/SORT(MSL VEL VEC(1)**2.0 
♦MSL VEL VEC(2)**2.0)); 

MSL_HEAOIMC_A2:=ATAN(MSL_VEL_VEC(2)/MSL_VEL_VEC<1)); 

-- Determine the missile velocity 
MSL.VEL:>MAGN1TUDE(MSL_VEL_VEC); 

-- Calculate the dynamic pressure 

Q:*0.5*EMVIR0NMENT.AIR_DENSITY<-MSL_POS(3))*MSL_VEL*MSL_VEL; 

-- Calculate the drag on the missile ~ ~ 

DRAG:=g*CQE F_DRAG*SREF; 

-- Calculate~the missile x acceleration 
MSL X ACC BOO:= (THRUST-DRAG)*G/MSL MASS; 
end EON; ~ ~ 


procedure MACH NO(ALTITUDE: in REAL; MISSILE VEL: in VECTOR; 

MACH: out REAL) is 
begin 

MACH:=MAGN1TU0E(MISSILE VEL)/ENVIRONNENT.SPEED OF SOUNO(ALTITUDE); 
end MACH NO; 


procedure DIR COS(PSI,THETA: in REAL; EIB: out MATRIX) is 
CPSI, -- CoslPSI) 

SPSl, •• Sin(PS}) 

CTHE, -- COS(THETA) 

STHE; -- SinlTHETA) 

REAL; 

begin 

CPS1;= COS(PSI); 

SPSI:> SINIPSI); 

CTHE:s COS(THETA); 

STHE:> SINITHETA); 

EIB{1,1):« CTME»CPSI; 

EIB(1,2):> CTHE*SPSI; 

EIB(1,3):> -STHE; 

EIB(2,1):< -SPSI; 

EIB(2,2):- CPSI; 

E1B(2,3):= 0.0; 

EIB(3,1):> STHE*CPSI; 

EIB(3,2):> STHE*SPSI; 

V EIB(3,3):> CTHE; 

end DIR_COS; 

end KINEMATICS; 


-• Targets package 

-- This package contains the procedure calls which will initialize, 
-- setup, computes and get and put the missile state vector as well 
-- as calculating the necessary parameters to calculate the state 
-- vector. 


with MATH; use MATH; 

with REAL MATRIX; use REAL MATRIX; 

with MODEL TYPES; use MODEL TYPES; 


175 










package TARGETS is 

procedure SETUP(ASPECT IN, 

TGT2 ANGLE IN, 

TGT MACH IN, 

NO OF GS IN. 

ueave'pericd in, 

TURN ON VALUE IN, 

turn'angle in7 

BUILDUP TINE IN: in REAL; 

TGT RANGE In7 

tgt'alt in, 

SOJ~ANGLE IN: in VECTOR; 

NANEUVER Tn: in MANEUVER.TYPE; 

TGT TWO Th. 

SOJ ONE IN, 

SOJ TWO IN: in YES NO TYPE; 
TURN_ON”PARANETER_INr Tn NANEUVER_START_TYPE); 

procedure PUT_STATES(STATES: in VECTOR); 

function GET_DERIVATIVES return VECTOR; 

function GET_STATES return VECTOR; 

function LOG_OATA return TARG£T_LOG_OATA_TYP£; 

procedure INITIALIZE; 

procedure TGT 0ATA(TGT VEL_OUT: out VECTOR; 

“ TGT_POS_OUT: out SUPER_VECTOR); 

function TGT_POS return SUPER_VECTOR; 

procedure COMPUTE; 

function TGT_ASPECT(RANGE_VEC: in VECTOR) return REAL; 
end TARGETS; 


-- Targets package 

*■ This package contains the procedure calls which will initialize, 
-* seti^, computes and get and put the missile state vector as well 
-- as calculating the necessary paratseters to calculate the state 
-- vector. 


with MODEL TYPES; use MODEL TYPES, 

with MATH; use NATH; 

with ENVIRONMENT; 

with REAL MATRIX; use REAL MATRIX; 

with LAUNCHER; 

with MISSILE; 

WITH TEXT_IO;WITH REAL.IO; 
package body TARGETS is 


LOGGED DATA 

aspect" 

TGT2 ANGLE 
TGT MACH 
TGT HEAD DOT 
TGT~HEAD~ANGLE 
TGT"vEL NED 

tgt"pos"meo 

TGT VEL 


TARGET_LOG_OATA_TYPE ; -- Output Vector 

VECT0R(1..2); Target Aspects 
REAL; Relative angle of tgt 2 to tgtl 

REAL; -- Target Machs 

REAL; -- Target one heading angle rate 

REAL; -- Target one heading angle 

VECTOR (1..3); -- Target Velocity Vector 

SUPER_VECTOR {1..4); -- Target Position Vectors 

RRAL; -- Magnitude of Target Velocity 


176 















NO OF GS REAL; -* Number of g's pulled in maneuver 

WEAVE'pERIOO REAL; -- Period of target weave 

TURN_ON_VALUE REAL; -- Time maneuver begins 

TURN'anGLE REAL; -- Angle turned through (turn and run) 

BUILDUP TINE REAL; -- Exponential buildup time 

TGT RANK VECT0R(1..4); — LOS Range to the targets 

SOJ~ANGLE : VECTORd..2); — Angle to SOJS relative to LAC az 

MANEUVER MANEUVER TYPE; -- Type of maneuver 

TURN_ON_PARAMETER: MANEUVER^START_TYPE; 

NSOJS INTEGERJ ~ -- Nmber of stand off janners 

NTGTS INTEGER; -- Nutber of Targets 

DERIVATIVES VECTORd. .6); -- 

STATE VECTORd..6); -- 

G_HORZ REAL; -- Horizontal g's pulled in weave 

OMEGA REAL; -* Freqency of the weave 

FSTART_NANEUVER : boolean; -- Maneuver start flag 

START_TIHE : REAL; -- Maneuver start time 

FINAL~HEAO_ANGLE: REAL; -- Final heading angle after turn 


procedure SETUP(ASPECT IN. 

TGT2 ANGLE.!N, 

TGT MACH_IN, 

NO OF GS IN. 

UEAVE_PERIOO_IN. 

TURN ON_VALUE IN. 

TURN'aNGLE IN. 

BUILDUP TIME IN: in REAL; 

TGT RANGE In7 
TGT~ALT IN. 

SOJ~ANGLE IN: in VECTOR; 

MANEUVER Tn: in MANEUVER TYPE; 

TGT TWO Tn. 

SOj'ONE IN. 

SOJ'tWO IN: in YES NO TYPE; 

TURN ON PARAMETER IN: fn MANEUVER START TYPE> is 

TEMP; REAL; 
begin 

ASPECTd) := OEG_TO_RAD*REAL(integer<ASPECT_IN»RAO_TO_OE6) mod 360); 
■* Initial Target 1 Aspect (rad) 

TGT2 ANGLE:«TGT2 ANGLE IN; -• Tgt 2 angle relative to tgt 1 

TGT MACH TGT MACH IN; •• Initial Target Mach 
NO OF GS :> NO~OF GS IN; 

UEAVE~PERI00:=UEAVE~PERI00 IN; 

TURN ON VALUE:=TURN~ON VALUE IN; 

TURN~ANGLE:- TURN_ANGfE IN; 

BUILDUP TINE:<BUILDUP TIME IN; 

TGT RANGE :- TGT MNGE~IN; •• LOS Range (feet) 

S0j~ANGLE SOJ ANGLE IN;~ 

MANEUVER :> NANEUVER~IN; 
if TGT TWO IN - NO thm 
NTGTS:=1; 

else 

Y NTGTS;*2; 

end if; 

if SOJ ONE IN > NO and SOJ TWO IN = NO then 
i NSOJS:-0; 

elsif SOJ ONE IN * YES and SOJ TWO IN = NO then 
NS0 Js7«1;” 

elsif SOJ ONE IN s NO and SOJ_TWO IN - YES then 
NSOJsT»1;“ 

TGT RANGE(3):«TGT RANGE(4); 

S0J~ANGLE(1) :>SOJ~ANGLE(2): 
elsif SOJ 0NE_IN « YES and SOJ TWO IN ^ YES then 
NS0JST*2;“ 
end if; 

TURN_ON_PARAMETER:*TURN_ON_PARAMETER_IN; 
for I in 1..4 loop 

TGT_POS_NED( I) ( 3 ):=- TGT_ALT_I N( I) ; 


177 












procedure PUT_STATES(STATES: in VECTOR) is 


begin 

TGT POS NED(1):>STATES(1..3); 
end PUT"sTATES; 



function GET DERIVATIVES return VECTOR is 


begin 

DERIVATIVES(1..3):=TGT VEL NED; 
return DERIVATIVES; 
end GET DERIVATIVES; 


function GET_STATES return VECTOR is 
begin 

STATE< 1.. 3 ):=TGT_POS_NEO (1) ; 
return STATE; 
end GET_STATES; 


function LOG_DATA return TAROET_LOG_DATA_TYPE is 
begin 

LOGGED DATA.REAL VALUE(1):> TGT_POS NED(1)(1); 

LOGGED DATA.REAL~VALUE(2):« TGT POS~NED(1)(2); 

LOGGED DATA.REAL“vALUE<3):a -TGT"POS''nED(1)(3); 

LOGGED 0ATA.REAL~VALUe<4)!» TGT"P0S~MED(2>(1>; 

LOGGED DATA.REAL'VALUECSTro TGT~POS HED(2)<2); 
LOGGEDIdATA.REAL'vACUECG):* -TGT~P0S~MED(2)(3); 

LOGGED DATA.REAL'vALUE(7):» TGT ^L; 

LOGGED DATA.REAL'vALUEIG)::: TGT'mACH; 

LOGGED DATA.REAL VALUE(9):« TGT HEAD ANGLE*RAD TO DEG; 
return LOGGED DATA; 
end LOG DATA; 


procedure INITIALIZE is 
TGT2 TEMP ANGLE: REAL; 

UC_POS_NED : VECTORd. .3); 

begin 

START TINE:>0.0; 

FSTARf NANEUVER:>fa(se; 

LAC P(X NED:>LAUNCHER.LAC POS; 

TGT VEL:>TGT NACN*ENVIRONNENT.SPEED OF SOUND(-TGT POS NED(1)(3)); 

TGT“vEL NED(T):»TGT VEL*C0S<ASPECT(T))7 

TGT“vEL~NC0<2):«TGT"vEL*SIN(ASPECT<1)); ' 

TGT VEL NE0(3):-0.0; 

TGT POS .iE0(1)(1):«SQRT(TGT RANGE(1)*TGT RANGEd}-(-LAC POS NED(3)4- 

“TGf POS NEOd)(3})*(-LAC POS NEO(3)+TGT_POS NEDd)(3»); i. 

TGT POS NEDd)(2):>0.0; 

TGT HEAD DOT:«0.0; 

TGT~MEAO“ANGLE:«ASPECTd ); 

TGT2 TEMP ANGLE:-TGT2 ANGLE'»TGT HEAD ANGLE-PI; 
if NTGTS * 2 then 

TGT POS NE0(2)d):>TGT POS NEDd)d)«SIN(TGT2 TEMP ANGLE)* 

TGf RANGE(2); 

TGT POS NED(2)(2):>TGT POS NED<1)(2)-COS(TGT2 TEMP_ANGLE)* 

TGf RANGE(2); 
if TGT POS NED(2)(2) /*~0.0 then 

ASPECT(2):-OEG TO RAD*REAL<INTEGER(RAD TO DEG*(ASPECTd)- 
ATANfTGT POS_NEO(2)(2)/TGT POS NED<2)d)))) 


178 














Mod 360); 

else 

ASPECT(2):>ASPECT(1); 

end if; 

else 

TGT POS NED(2)(1):-0.0; 

TGT“P0S“hED ( 2 ) ( 2 ): *0.0 ; 

ASPECT{2):*0.0; 

end if; 

if NSOJS > 1 then 

TGT POS_NED(3)(1):>COS(SOJ ANGLE(1))*SCHiT(TGT RANGE(3)* 
TGT_RAirGE(3)-(-LAC POS NED(3)> 

* TGT POS NED(3)(3))*(-LAC POS NE0(3)4' 

TGT“P0s“nED<3)(3))); 

TGT POS ME0(3)(2):-SIN<^J AMG(.E(1))*SQRT(TGT RANGE(3)* 

V ■ “ TGT RANGE(3)-(-LAC_POS IIED(3)+ 

TGT~POS NE0(3)(3))*(*LAC POS NED(3>'»^ 
TGT”pOS“nED<3)(3))); 

if NSOJS * 1 then 

TGT POS NE0(4)(1):«0.0; 

TGT~POS~MEO<4)(2);*0.0; 

end if; 

elsif NSOJS > 2 then 

TGT_POS_NED<3)(1):=COS(SOJ ANGLE(1))*SORT<TGT RANGE(3)* 
TGT RANGE(3)-<-LAC POS NED(3)« 
TGT~POS NE0(3)(3))*(-LAC POS NED{3)* 
TGTIpOS"nEO(3)(3))); 

TGT POS NEO(3)(2):=S1N(SOJ ANGLE(1))*SQRT(TGT RANGE(3)* 
TGT RANGE(3)-(-LAC POS_NEO<3)+ 
TGT“pOS NED<3)(3))*{-LAC POS NED(3)+ 
TGT“pOS"nEO(3)(3>»; 

TGT POS NED(4)(1):=C0S<»)J ANGt.E(2))*SQRT(TGT RANGE(4)* 
TGT RANGE(4)-<-LAC POS NED{3)* 

TGT POS NED(4)(3»*(-LAC POS NED(3)+ 

tgt’pos 

TGT POS NED(4)(2):»SIN(S0J ANGLE(2»*SQRT(TGT RANGE(4)* 
TGT RANGE<4)-(-LAC POS NED(3)+ 
TGT“pOS NED<4)(3))*(-LAC POS NED(3)+ 
TGT_POS_NED<4)(3))); 

else 

TGT POS_NED<3)(1):=0.0; 

TGT”pOS NED(3)(2):=0.0; 

TGT”P0S"nED(4 ) (1): =0.0; 

TGt3pOs3nEO(4)<2):=0.0; 

end if; 

if MANEUVER > TURN then 

FINAL HEAD ANGLE:=0EG TO RAD*REAL(integer((ASPECT(1)> 
TURN ANGLE)*RAO_TO_OEG) mod 360); 

elsif MANEUVER = WEAVE then “ 

OMEGA;»2.0*PI/UEAVE_PERI00; 

end if; 

t end INITIALIZE; 


procedure TGT 0ATA(TGT VEL OUT: out VECTOR; 

TGT_P0S_0UT : out SUPER_VECTOR) is 


begin 

TGT VEL 0UT:>TGT VEL NED; 
TGT POS“OUT:»TGT POS NED; 
end TGT“dATA; 


function TGT_POS return SUPER.VECTOR is 
begin 

return TGT_POS_NEO; 


179 









end TCT_POS; 


procedure COMPUTE is 

BUILDUP FACTOR: REAL; 

MANEUVER START VALUE: REAL; 

TEMP GS:“ REAL? 

TGT2_TEMP_AMGLE: REAL; 

begin 

if not FSTART MANEUVER then 

MISSILE.MANEUVER_VALUE(TURN_ON_PARAMETER,NANEUVER_START^VALUE); 
end if; 

if TURN ON PARAMETER /- FLIGHT TIME and MANEUVER START VALUE <= 
TURN 6 n_VALUE then 
if nol FSTART MANEUVER then 

START_T IME:>ENVIRONMENT.Time; 

FSTART_NANEUVER:^t rue; 
end if; 

elsif TURN_ON PARAMETER ^ FLIGHT TINE and MANEUVER START VALUE >= 
TURN ON VALUE then 
if not FSTART MANEUVER then 

START_T IME:-ENVIRONMENT.Time; 

FSTART_HANEUVER:=t rue; 
end if; 
end if; 

if FSTART MANEUVER and ENVIRONMENT.Tinie<=(START_TIME« 

BUILDUP TIME) then 
if BU1L0UP_TIME = 0.0 then 

TGT HEAD OOT:xSIGN(TURN ANGLE)*G*SQRT(NO OF GS*NO OF GS- 

“i.0)7tgt VEL; 

G.HORZ:aTAN(ACOS<1.0/NO_0F_GS)); 
else ” 

BUILDUP FACTOR:«1.0-EXP((ENVIRONMENT.Time-START TIME)* 
<-4.60517)/BUILDUP TIME); 
if MANEUVER > TURN then 

TEMP GS:>NO OF GS*8U1L0UP FACTOR; 
if TEMP GS < 1.0 then 
TEMP_GS:=1.0; 
end if; 

TGT HEAD DOT:sSIGN(TURN ANGLE)*G*SORT(TEMP GS*TEMP GS* 
~1.0)7tGT VEL; 
elsif MANEUVER >~UEAVE then 

G_HORZ:»BUILDUP_FACTOR*TAN(ACOS(1.0/NO_OF_GS)); 
end if; 
end if; 
end if; 

if MANEUVER > TURN and FSTART MANEUVER then 
if (ASPECT(1)>TURN ANGLE)<0.000 then 

if TGT HEAD ANGLE>ASPECT(1) and TGT HEAD ANGLE <= 

FINAL HEAD ANGLE then 

TGT_HEAD_ANGLE:=FINAL_HEAD_ANGLE; 

else 

TGT HEAD ANGLE:>ASPECT(1)4^(ENVIR0NHENT.Time-START TIME) 
•TGT_HEAD_DOT; 
end if; 

elsif (ASPECTLD-^TURN ANGLE) >>2.0 * PI then 

if TGT HEAD ANGLE<ASPECT(1) and TGT_HEAD ANGLE >- 
FINAL HEAD ANGLE then 

TGT_HEAb_ANGLE:=FINAL_HEAD_ANGLE; 

else 

IGT HEAD_ANGLE:>ASPECT(1)4’(ENVIR0NMENT.Time-START TIME) 
*TGT_HEAD_OOT; 
end if; 

elsif SIGNLTURN ANGLE)<0.0 then 

if FINAL HEAO_ANGLE > 0.0 and TGT_HEAO ANGLE >::6.20 then 
TGT.HEAO ANGLE:<FINAL_HEAO ANGLE; 


180 












elsif TGT HEM) ANGLE<>FtMAL HEAD ANGLE then 
TGT_H W_ANGLE:=FIN AL_HEAO_AHGLE ; 
else 

TGT HEM) ANGLE:>ASPECT(1)«(ENVIR0NNENT.Titiie-START TINE)* 
TGT“hEA0Id0T; 
end if;~ 

else 

if TGT HEAD ANGLE>=F1NAL HEAO.ANGLE then 
TGT" head" ANGLE: »f I HAL“ HEAO_ANGLE ; 
else 

TGT HEAD ANGLE:=ASPECT(1)*(ENVIRONMENT.Tiine-START_TIHE)* 
TGT“hEAD" 0OT; 
end if; 
end if; 

elsif MANEUVER » WEAVE and FSTART MANEUVER then 
TGT HEAD ANGLE:=ASPECT(1)-G*G~HORZ*COS(OMEGA* 

“(ENVIRONMENT.Tiflie-START_TTME))/TGT_VEL/OMeCA; 
end if; ~ 

if TGT HEAD ANGLE < 0.0 or TGT_HEA0 ANGLE » 2.0*PI then 
TGT HEAD ANGLE:4EG TO RAD*REAL(integer(TGT HEAD ANGLE 
*RAO_TO_DEG) si^ 360); 

end if; 

TGT VEL NED(1):sTGT VEL*COS(TGT HEA0_ANGLE); 

TGT“vEL“nED(2):=TGT“vEL*SIN(TGT“hEAD ANGLE); 

TGT“vElT*MAGN1TU0E<TGT VEL NE0)7 

TGT_HACH;»TGT_VEL/ENVIRONMENT.SPEEO_OF_SOUND(-TGT_POS_NED(1)(3)); 
if NTGTS * 2 then 

if MANEUVER > TURN then 

TGT2 TEMP ANGLE:«TGT HEAD_ANGLE*TGT2 ANGLE-PI; 

TGT POS NED(2)(1):=TGT POS NED(1>(1)«S1N(TGT2 TEMP ANGLE)* 
TGf RA)rGE(2); 

TGT POS NE0(2)(2):sTGT POS NED(1)(2)-COS(TGT2 TEMP ANGLE)* 
TGf_RANGE(2); 

else 

TGT POS NED(2)(1):aTGT POS NED(1)(1)*SIN(TGT2 ANGLE)* 

TGf RANGE(2); 

TGT POS NED(2)<2):»TGT POS NEO<1)(2)-COS(TGT2 ANGLE)* 
TGf_RANGE(2); 

end if; 
end if; 
end COMPUTE; 


function TGT_ASPECT(RANGE_VEC: in VECTOR) return REAL is 

ASPECT : REAL; 
begin 

if RANGE VEC(2) /> 0.0 then 

ASPECT:=0EG TO RAO*REAL(INTEGER(RAO_TO DEG*(TGT HEAD ANGLE- 
ATAN(RANGE_VEC(2)/RANGE_VEC'(1)»)n»d~360)1 

else 

ASPECT:sTGT_HEAO_ANGLE; 
end if; 

t return ASPECT; 

end TGT_ASPECT; 

4 end TARGETS; 


Environment Package 

This package contains procedures to set atmospheric conditions 
according to altitude. It uses standard temperature and pressure 
for each altitude zone. 


with NATH; use HATH; 


181 














package ENVIRONMENT is 


procedure SET TINE( 

NEU_TIME T in REAL); 

function Tiaie 
return REAL; 

function A1R_DENSITY(ALTITUDE : in REAL) 
return REAL; 

function SPEED_OF_SOUNO(ALTITUDE : in REAL) 
return REAL; 

end ENVIRONMENT; 


-■ Environment Package 

-- This package contains procedures to set the time, return the time, 
-- compute position and gravity vectors due to the earth's curvature, 
-- and set ataiospheric conditions according to altitude. 


with MATH; use MATH; 

with REAL_MATRIX; use REAL_MATRIX; 

package body ENVIRONMENT is 

SYSTEM_TINE : REAL 0.0; 


procedure SET TIME( 

NEU_TIME T in REAL) is 
begin 

SYSTEM TIME NEW TINE; 
end SET_TIME; 


function TIME return REAL is 
begin 

return SYSTEM_TIME; 
end Tisie; 


function AIR_OENSITY( 

ALTITUDE~ ; in REAL) return REAL is 

TO : constant 518.69; 

RHOO : constant 2.3769E-3; 

HI : constant :> 36500.0; 

T1 : constant 389.99; 'k 

RH01 : constant ;« 6.9443E-4; 

H2 : constant :> 82000.0; i 

T2 : constant :■ 389.99; 

RH02 : constant :■ 7.8931E-5; 

H3 : constant :« 156000.0; 

T3 : constant :* 508.79; 

A1 ; constant :■ <T1 - TO) /HI; 

A3 : constant (T3 - T2) / (H3 - H2); 

INV TO : constant :« 1.0 / TO; 

EXP"0 : constant :» -<G / <A1 * R) ♦1.0); 


182 
















EXP_COEFJ : constant :» -G / (R * T1); 

IRV T2 : constant := 1.0 / T2; 

EXP_2 : constant :» -(G / (A3 *R) ♦ 1.0); 

RHO : REAL; 

TEMP : REAL; 

begin 

if ALTITUDE < HI then 

TEMP := TO ♦ ALTITUDE * A1; 

RHO := RHOO * REAL(TEMP * INV TO) *• REAL(EXP_0); 
elsif (ALTITUDE >= HI) and (ALTITUDE < H2) then 

RHO := RH01 * EXP(EXP COEF 1 * (ALTITUDE - HD); 
elsif ALTITUDE » H2 then 

TEMP ;= T2 ♦ (ALTITUDE - H2) * A3; 

RHO := RH02 * REAL(TENP * IMV_T2)**REAL(EXP_2); 
end if; 
return RHO; 
end AIR DENSITY; 


function SPEED_OF_SOUND( 

ALTITUDE : in REAL) return REAL is 

TO : constant := 518.69; 

HI : constant 36500.0; 

T1 ; constant := 389.99; 

H2 : constant 82000.0; 

T2 : constant := 389.99; 

H3 : constant := 156000.0; 

T3 ; constant ;* 508.79; 

A1 : constant :* (T1 - TO) / Hi; 

A3 : constant (T3 - T2) / (H3 - H2); 

TEMP : REAL; 

SOUNO.SPEED : REAL; 

begin 

if ALTITUDE < HI then 

TEMP :» TO ♦ ALTITUDE * A1; 

SOUND SPEED := SORT(GAMMA * R * TEMP); 
elsif (ALTITUDE >= HI) and (ALTITUDE < H2) then 
TEMP ;= T1; 

SOUND SPEED SQRT(GAMMA * R • TEMP); 
elsif ALtTtudE >= H2 then 

TEMP := T2 ♦ (ALTITUDE - H2) * A3; 
SOUND.SPEED SQRT(GAMHA * R * TEMP); 
end if; 

t return SOUND_SPEED; 

end SPEED_OF_SOUND; 

1 end ENVIRONMENT; 


183 








LIST OF REFERENCES 


1. Pacific Missile Test Center, Test and Evaluation of an Air-to-Air RF Guided 
Missile, by EJ, Eichblatt, 1 July 1981 

2. Pressman, R.S., Software Engineering: A Practitioner's Approach, McGraw-Hill 
Book Company, 1987 

3. Myers,G., Composite Structured Design, Van Nordstrand Inc., 1978 

4. Cox,B.J., Object Oriented Programming: An Evolutionary Approach, Addison- 
Wesley Publishing Co., 1987 

5. Booch, G., Software Engineering with Ada, The Benjamin/Cumrnings Publishing 
Company, Inc., 1986 

6. .4NSI/MIL-STD-1815A, Ada Programming Language, 22 January 1983 

7. Cohen,N.H., Ada as a Second Language, McGraw-Hill, Inc., 1986 

8. Abbot, R.,"Program Design by Informal English Description,” Communications of 
the ACM, 1983 

9. Anderson, J.D., Introduction to Flight, McGraw-Hill Inc., 1987 

10. Smith, J.M., Mathematical Modeling and Digital Simulation for Engineers and 
Scientists, John Wiley & Sons, Inc., 1987 

11. Gerald,C.F., and 'V/heaXley,V.O., Applied Numerical Analysis, Addison-Wesley 
Publishing Co., 1984 

12. Howe,R.M., Dynamics of Real-Time Simulation, Applied Dynamics International, 
1987 

13. Meridian Software Systems Inc., Meridian AdaVantage DOS Environment Library 
User's Guide, Meridian Inc. 

14. Meridian Software Systems Inc., Meridian AdaVantage Compiler User's Guide 
For PC-DOS Self-Targeted Configurations, Meridian Inc. 


184 






15. Young,MJ,, MS DOS Advanced Programming, SYBEX Inc., 1988 


16. Hanna, O.T., The Improved Euler Extrapolation Integration Algorithm for Use 
in Digital Simulation, Integrated System Analysts Inc., 1990 

17. Konvisser,M.W., Elementary Linear Algebra with Applications, Prindle, Weber, 
and Schmidt, 1981 

18. Air Force Flight Dynamics Laboratory Report RTD-TDR-64-1, Six-Degree-of- 
Freedom Flight-Path Generalized Computer Program, by R.C. Brown, R.V. 
Brulle, A.E. Combs and G.D. Giffm, October 1964 

19. Criel, H.E. and Murtaugh, S.A.,"Fundamentals of Proportional Navigation," IEEE 
Spectrum, December 1964 

20. Friedman,D.R., Principles of Naval Weapons Systems, Naval Institute Press, 
1986 

21. Stimson,.G.W., Introduction to Airborne Radar, Hughes Aircraft Company, 1983 


185 




INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center 2 

Cameron Station 

Alexandria, VA 22304-6145 

2. Library, Code 52 2 

Naval Postgraduate School 

Monterey, CA 93943-5002 

3. Professor Y. Lee, Code CS/Le 2 

Naval Postgraduate School 

Monterey, CA 93943-50000 

4. Mr. John V. Waite, Code 1051 2 

Pacific Missile Test Center 

Point Mugu, CA 93042 


V 

n 


186 



