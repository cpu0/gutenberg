AD-A224 364 


AVF Control Number: AVF-VSR-90502/67 




Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: #900125N1.10257 
R R Software Inc 
IntegrAda 4.2.0 

Unisys 386 under SCO Unix 3J2.0 


Completion of On-Site Testing: 
25 January 1990 


DTIC 

ELECTE 
J U L 0 G 1990 



Prepared By: 

Testing Services 

The National Computing Centre Limited 
Oxford Road 
Manchester Ml TED 
England 


Prepared For 
Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 


Validation Summafy Rqiort 
K K Software lac. IntegrAda 4.2.0 

£L-, r: 'u ^K 

Appitn ' iubUc 

Dl«t' • jUfntimi 


AVF-VSR-90502«>7 


Page i of ii 









JUL 05 ’^>0 14: ;0 I IT RE'iEfiPCH IHET 

KtPORT DOCUMENTATION PAGE 


lCr0704-0i 



1. AOCNCV UK 0(«.r (UMv MV 





t.f»>ORT(UTE 


I. fEVORT TfFE AM> OKICt OOWEREO 

Final 25 Jan 1990 to 25 Jan 1991 


cnOEAlOftmiTiE Ada Compiler Validation Sumnar'.^^porc: AMCMONUMBERS 

l.R. Software Inc., IntegrAda 4.2.0, Unisys 386 under SCO Unix 
1.2.0 (Host &.Target), 900125N1.10257 

CMITHORtS) . ' ii .- 

National Computing Centre Limited 
Manchester, UNITED KINGDOM 


r PCKoi»«n oMAMinoi MMCtE M) 

National Computing Centre Limited 
Oxford Road 
Manchester MI 7ED 
UNITED KINGDOM 


• KONSORMdWSNnORMQ AKNCY l«AiyC(S) AIC> AaOREStREft) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C.*20301*'3081 


. Kivaniiff« ORcuMZKnoN 
KPOfTTMUMKR 


AVF-VSR-90502/67 


10. KOMOMNOAOeTOMNe AGENCY 
NEPOOn-NUMBER 



iSeOttTRKniONiMMABaJTYrATEMENT tIO. OKTWmON OCOE 

Approved for . uolic release; distribution unlimited. 


1». ABSTHACT BtetamOQO w*; 

R.R. Software Inc., IntegrAda 4.2.0, Manchester England, Unidyd 386 under SCO Unix 3.2.0 
(Host & Target), ACVC 1.10. 


14.KBCCTTEIBB Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A, Ada Joint Program Office _ 


unclassified I UNCLASSIFIED 


Till 


It. NUMBER VRAQES 



». UMTOOTON OF AR6™«T 


























TABLE OF CONTENTS 


TABLE OF CONTENTS 

CHAPTER 1 

INTRODUCTION . 1 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT 

1.3 REFERENCES. 

1.4 DEFINITION OF TERMS . 3 

1.5 ACVC TEST CLASSES . 4 

CHAPTER 2 

CONFIGURATION INFORMATION . 1 

2.1 CONFIGURATION TESTED. 1 

2.2 IMPLEMENTATION CHARACTERISTICS . 1 

CHAPTER 3 

TEST INFORMATION. 1 

3.1 TEST RESULTS. 1 

3.2 SUMMARY OF TEST RESULTS BY CLASS. 1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER . 1 

3.4 WITHDRAWN TESTS. 1 

3.5 BNAPPUCABLE TESTS. 2 

3.6 TEST, PROCESSDVG, AND EVALUATION MODIFICATIONS . . 6 

3.7 ADDITIONAL TESTING INFORMATION. 7 

APPENDIX A 

DECLARATION OF CONFORMANCE . 1 

APPENDIX B 

APPENDIX F OF THE Ada STANDARD . 1 

APPENDIX C 

TEST PARAMETERS . 1 

APPENDIX D 

WITHDRAWN TESTS. 1 


AVF-VSR-90502/67 


Vaiidatioa Summaiy Repoft 
R R Software Inc. loicgrAda 4.2.0 


Table of Contents - Page i of i 


ri ri 



























Ada Compiler Validation Summary Report; 

Compiler Name: IntegrAda 4.2.0 
Certificate Number: #900125N1.10257 

Host: Unisys 386 under SCO Unix 3.2.0 
t arget: Unisys 386 under SCO Unix 3.2.0 

Testing Completed 25 January 1990 Using ACVC 1.10 

This report has been reviewed and is approved. 


_ V V- _ 

Jane Pink 

Testing Services Manager 

The National Computing Centre Limited 

Oxford Road 

Manchester Ml 7ED 

England 


f'' j ' ^ ' 

Ada Validation,Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 
Alexandria VA 22311 


^ ^-4 

Ada^oint Program Office 
Dr. John Solomond 
Director AJPO 
Department of Defense 
Washington DC 20301 



Accession Pop 

NTIS" GRA&I 
DTIC TAB 
Uiieiuic'.'.rioiid 



Justlf ic'jt.ica 


By_ 

AvcIIjA:I ty Codes 


Dl3t i 



Valklatioa Sununary Report 


AVF-VSR-90502/67 


R R Software Inc. IntegrAda 4.2.0 


Page ii of ii 


□ □ 









INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


This Validation Summary Report (VSR) describes the extent to which a specific Ada compiler 
conforms to the Ada Standard, ANSI/MIL-STD-1815A. This report explains all technical terms 
used within it and thoroughly reports the results of testing this compiler using the Ada Compiler 
Validation Capability.(ACVC). An Ada compiler must be implemented according to the Ada 
Standard, and any implementation-dependent features must conform to the requirements of the 
Ada Standard. The Ada Standard must be implemented in its entirety, and nothing can be 
implemented that is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it must be understood that 
some differences do exist between implementations. The Ada Standard permits some 
implementation dependencies - for example, the maximum length of identifiers or the maximum 
values of integer types. Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All the dependencies 
observed during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced during validation testing. 
The validation process includes submitting a suite of standardized tests, the ACVC, as inputs to an 
Ada compiler and evaluating the results. The purpose of validating is to ensure conformity of the 
compiler to the Ada Standard by testing that the compiler properly implements legal language 
constructs and that it identifies and rejects illegal language constructs. The testing also identifies 
behavior that is implementation dependent, but is permitted by the Ada Standard. Six classes of 
tests are used. These tests are designed to perform checks at compile time, at link time, and 
during execution. 


U PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR documents the results of the validation testmg performed on an Ada compiler. Testing 
was carried out for the following purposes: 

o To attempt to identify any language constructs supported by the compiler that do 
not conform to the Ada Standard 

o To attempt to identify any language constructs not supported by the compiler but 
required by the Ada Standard 

o To determine that the implementation-dependent behavior is allowed by the Ada 
Standard 


Testing of this compiler was conducted by The National Computer Centre Limited according to 
procedures established by the Ada Joint Program Office and administered by the Ada Validation 


Validatioa Smnniaiy Report AVF-VSR-90502/67 

R R Software loc IntegrAda 4.Z0 Chapterl - Page 1 of 5 









INTRODUCTION 


Organization (AVO). On-site testing was completed 25 January 1990 at The Numerical Algorithms 
Group Limited, W ilkins on House, Jordan Hill Road, Oxford, United Kingdom, 0X2 SDR. 


L2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may make full and free 
public disclosure of this report. In the United States, this is provided in accordance with the 
"Freedom of Information Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not represent or warrant 
that all statements set forth in this report are accurate and complete, or that the subject compiler 
has no nonconformities to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 


Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 
Washington DC 20301-3081 


or from: 


Testing Services 

The National Computing Centre Limited 
Oxford Road 
Manchester Ml TED 
England 


Questions regarding this report or the validation test results should be directed to the AVF listed 
above or to: 


Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


L3 REFERENCES 

1. Reference Manual for the Ada Proeramming Language. 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines . 

Ada Joint Program Office, 1 January 1987. 


AVF-VSR-9050Z/67 


Validatioa Sumnufy Report 
R R Software Inc. InIcgrAda 4.2.0 


Chapterl - Page 2 of 5 








INTRODUCTION 


3. Ada Compiler Validation Capability Implementers’ Guide . 
SofTech, Inc., December 1986. 

4. Ada Compiler Validation Capability User’s Guide . 
December 1986. 


L4 DEFINrnON OF TERMS 

ACVC The Ada Compiler Validation Capability. The set of Ada programs 

that tests the conformity of an Ada compiler to the Ada 
programming language. 

Ada Commentary An Ada Commentary contains all information relevant to the point 

addressed by a comment on the Ada Standard. These c<^mments 
are given a unique identification number having the form Al-ddddd. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

The agency requesting validation. 

The Ada Validation Facility. The AVF is responsible for 
conducting compiler validations according to procedures contained 
in the Ada Compiler Validation Procedures and Guidelines . 

The Ada Validation Organization. The AVO has oversight 
authority over all AVF practices for the purpose of maintaining a 
uniform process for validation of Ada compilers. The AVO 
provides administrative and technical support for Ada validi tions to 
ensure consistent practices. 

A processor for the Ada language. In the context of this report, 
a compiler is any language processor, including cross-compilers, 
translators, and interpreters. 

An ACVC test for which the compiler generates a result that 
demonstrates nonconformity to the Ada Standard. 

The computer on which the compiler resides. 


Ada Standard 

Applicant 

AVF 

AVO 

Compiler 

Failed test 

Host 


Inapplicable test An ACVC test that uses features of the language that a compiler 

is not required to support or may legitimately support in a way 
other than the one expected by the test. 


Passed test 


An ACVC test for which a compiler generates the expected result. 


Validatioa Summaty Report AVF-VSR-90502/67 

R R Software Inc. InlcgrAda 4J2.0 Chapterl - Page 3 of 5 









INTRODUCTION 


Target The computer which executes the code generated by the compiler. 

Test A program that checks a compiler’s conformity regarding a 

particular feature or a combination of features to the Ada Standard. 
In the context of this report, the term is used to designate a single 
test, which may comprise one or more files. 

Withdrawn test An ACVC test found to be incorrect and not used to check 

conformity to the Ada Standard. A test may be incorrect because 
it has an invalid test objective, fails to meet its test objective, or 
contains illegal or erroneous use of the language. 


L5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC contains both legal and 
illegal Ada programs structured into six test classes: A, B, C, D, E, and L. The first letter of a 
lest name identifies the class to which it belongs. Class A, C, D, and E tests are executable, and 
special program units are used to report their results during execution. Class B tests are expected 
to produce compilation errors. Class L tests are expected to produce errors because of the way 
in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal Ada programs with certain 
language constructs which cannot be verified at run time. There are no explicit program 
components in a Class A test to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada language) are not treated 
as reserved words by an Ada compiler. A Class A test is passed if no errors are detected at 
compile time and the program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. Class B tests are not executable. 
Each test in this class is compiled and the resulting compilation listing is examined to verify that 
every syntax or semantic error in the test is detected. A Class B test is passed if every illegal 
construct that it contains is detected by the compiler. 

Class C tests check the run time system to ensure that legal Ada programs can be correctly 
compiled and executed. Each Class C test is self-checking and produces a PASSED, FAILED, or 
NOT APPLICABLE message indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. Since there are no 
capacity requirements placed on a compiler by the Ada Standard for some parameters - for 
example, the number of identifiers permitted in a compilation or the number of units in a library - 
- a compiler may refuse to compile a Class D test and still be a conforming compiler. Therefore, 
if a Class D test fails to compile because the capacity of the compiler is exceeded, the test is 
classified as inapplicable. If a Class D test compiles successfully, it is self-checking and produces 
a PASSED or FAILED message during execution. 


Validatioa Summary Report • AVF-VSR-90502/67 

R R Software luc. IntcsrArSa 4^0 Chapierl - Page 4 of 5 









INTRODUCTION 


Class E tests are expected to execute successfully and check implementation-dependent options and 
resolutions of ambiguities in the Ada Standard. Each Class E test is self-checking and produces 
a NOT APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs containing some features 
addressed by Class E tests during compilation. Therefore, a Class E test is passed by a compiler 
if it is compiled successfully and executes to produce a PASSED message, or if it is rejected by the 
compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving multiple, separately compiled 
units are detected and not allowed to execute. Class L tests are compiled separately and execution 
is attempted. A Class L test passes if it is rejected at link time — that is, an attempt to execute 
the main program must generate an error message before any declarations in the main program 
or any units referenced by the main program are elaborated. In some cases, an implementation 
may legitimately detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure CHECK FILE, support the self¬ 
checking features of the executable tests. The package REPORT provides the mechanism by which 
executable tests report PASSED, FAILED, or NOT APPLICABLE results. It also provides a set 
of identity functions used to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These tests produce 
messages that are examined to verify that the units are operating correctly. If these units are not 
operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to ensure that the tests 
are reasonably portable without modification. For example, the tests make use of only the basic 
set of 55 characters, contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all implementations in separate tests. 
However, some tests contain values that require the test to be customized according to 
implementation-specific values - for example, an illegal file name. A list of the values used for 
this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and demonstrate conformity to the 
Ada Standard by either meeting the pass criteria given for the test or by showing that the test is 
inapplicable to the implementation. The applicability of a test to an implementation is considered 
each time the implementation is validated. A test that is inapplicable for one validation is not 
necessarily inapplicable for a subsequent validation. Any test that was determined to contain an 
illegal language construct or an erroneous language construct is withdrawn from the ACVC and, 
therefore, is not used in testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


AVF-VSR-90502/S7 


Valklalioa Summary Report 
R R Software Inc. IntegrAda 4.2.0 


Chaplerl - Page 5 of 5 






CONFIGURATION INFORMATION 


CHAPTER 2 

CONHGURATION INFORMATION 

2A CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under the following configuration: 
Compiler; IntegrAda 4.2.0 

ACVC Version: 1.10 

Certificate Number; #900125N1.10257 


Host Computer; 

Machine: 

Operating System: 
Memory Size: 


BeU 3S6 
Ms-Dos 4 
4 Mbytes 


Target Computer: 
Machine; 

Operating System; 
Memory Size: 


BeU 386 
Ms-Dos 4 
4 Mbytes 


22 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior of a compiler in those 
areas of the Ada Standard that permit implementations to differ. Class D and E tests specifically 
check for such implementation differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 723 variables in the 
same declarative part. (See test D29002K.) 


Validatioa Sununaiy Report AVF-VSR-90502/67 

R R Software Inc. IntegrAda 4.2.0 Chapter 2 - Page 1 of 5 










CONFIGURATION INFORMATION 


(2) The compiler correctly processes tests containing loop statements nested to 17 
levels. (See tests D55A03A..H (8 tests).) 

(3) The compiler rejects tests containing block statements nested to 65 levels. (See test 
D56001B.) 

(4) The compiler correctly processes tests containing recursive procedures separately 
compiled as subunits nested to six levels. (See tests D64005E..G (3 tests).) 

b. Predefined types. 

(1) This implementation supports the additional predefined types LONG_INTEGER, 
and LONG_Fl,OAT, in the package STANDARD. (See tests B86001T..Z (7 tests).) 

c. Expression evaluation. 

The order in which expressions are evaluated and the time at which constraints are checked 
are not defined by the language. While the ACVC tests do not specifically attempt to 
determine the order of evaluation of expressions, test results indicate the following: 

(1) None of the default initialization expressions for record components are evaluated 
before any value is checked for membership in a component’s subtype. (See test 
C32117A.) 

(2) Assignments for subtypes are performed with the same precision as the base type. 
(See test C35712B.) 

(3) This implementation uses no extra bits for extra precision and uses no extra bits 
for extra range. (See test C35903A.) 

(4) No exception is raised when an integer literal operand in a comparison or 
membership test is outside the range of the base type. (See test C45232A.) 

(5) No exception is raised when a literal operand in a fixed-point comparison or 
membership test is outside the range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A..Z (26 tests).) 

d. Rounding. 

The method by which values are rounded in type conversions is not defined by the 
language. While the ACVC tests do not specifically attempt to determine the method of 
rounding, the test results indicate the following: 

(1) The method used for rounding to integer is round away from zero. (See tests 
C46012A..Z (26 tests).) 


VaiiUatioo Sunmiaiy Rqport AVF-VSR-90502/67 

R R Software Inc. loIe^Ada 4.2.0 Chapter 2 - Page 2 of 5 


I 








CONFIGURATION INFORMATION 


(2) The method used for rounding to longest integer is round away from zero. (See 
tests C46012A..Z (26 tests).) 

(3) The method used for rounding to integer in static universal real expressions is 
round away from zero. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or CONSTRAINT_ERROR 

for an array having a ’LENGTH that exceeds STANDARD.INTEGER’LAST and/or 

SYSTEM.MAX_INT. For this implementation: 

(1) Declaration of an array type or subtype declaration with more than 
SYSTEM.MAX_INT components raises no exception. (See test C36003A.) 

t^2) CONSTRAINT_ERROR is raised when ’I.ENGTH is applied to an array type with 
INTEGER’LAST + 2 components. (See test C36202A.) 

(3) NUMERIC_ERROR is raised when ’LENGTH is applied to an array type with 
SYSTEM.MAX_INT + 2 components. (See test C36202B.) 

(4) A packed BOOLEAN array having a ’LENGTH exceeding INTEGER’L AST raises 
no exception when the array objects are declared. (See test C52103X) 

(5) A packed two-dimensional BOOLEAN array with more than INTEGER’LAST 
components raises CONSTRAINT_ERROR when the length of a dimension is 
calculated and exceeds INTEGER’LAST. (See test C52104Y.) 

(6) In assigning one-dimensional array types, the expression is evaluated in its entirety 
before CONSTRAINT ERROR is raised when checking whether the expression’s 
subtype is compatible with the target’s subtype. (See test C52013A.) 

(7) In assigning two-dimensional array types, the expression is evaluated in its entirety 
before CONSTRAINT ERROR is raised when checking whether the expression’s 
subtype is compatible with the target’s subtype. (See test C52013A.) 

f. A null array with one dimension of length greater than INTEGER’LAST may raise 

NUMERIC_ERROR or CONSTRAINT_ERROR either when declared or assigned. 

Alternatively, an implementation may accept the declaration. However, lengths must match 

in array slice assignments. This implementation raises no exception. (See test E52103Y.) 

g. Discriminated types. 


ValkUtioo Sununaiy Report AVF-VSR 90502/67 

R R Software Inc. IntegrAda 4.Z0 Chapter 2 - Page 3 of S 








CONHCURATION INFORMATION 


(1) In assigning record types with discriminants, the expression is evaluated in its 
entirety before CONSTRAINT_ERROR is raised when checking whether the 
expression’s subtype is compatible with the target’s subtype. (See test C520L1A.) 

h. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the test results indicate that 
the order in which choices are evaluated and index subtype checks are made 
depends upon the aggregate itself. (See tests C43207A and C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, not all choices are 
evaluated before being checked for identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised after all choices are evaluated when a bound 
in a non-null range of a non-null aggregate does not belong to an index subt'pe. 
(See test E43211B.) 

i. Pragmas. 

(1) The pragma INLINE is not supported for functions or procedures. (See tests 
LA3004A..B (2 tests), EA3004C..D (2 tests), and CA3004E..F (2 tests).) 

j. Generics. 

(1) Generic specifications and bodies can be compiled in separate compilations. (See 
tests CA1012A, CA2009C, CA2009F. BC3204C, and BC3205D.) 

(2) Generic subprogram declarations and bodies can be compiled in separate 
compilations. (See tests CA10f2A and CA2009F.) 

(3) Generic library subprogram specifications and bodies can be compiled in separate 
compilations. (See test CA1012A.) 

(4) Generic non-library package bodies as subunits can be compiled in separate 
compilations. (See test CA2009C.) 

(5) Generic non-library subprogram bodies can be compiled in separate compilations 
from their stubs. (See test CA2009F.) 

(6) Generic unit bodies and their subunits can be compiled in separate compilations. 
(See test CA3011A.) 

(7) Generic package declarations and bodies can be compiled in separate compilations. 
(See tests CA2009C, BC3204C, and BC3205D.) 

(8) Generic library package specifications and bodies can be compiled in separate 
compilations. (See tests BC3204C and BC3205D.) 


AVF-VSR-90502/67 


Validation Summary Report 
R R Software Inc. Intep'Arla 4.2.0 


Chapter 2 - Page 4 of 5 








CONFIGURATION INFORMATION 


(9) Generic unit bodies and their subunits can be compiled in separate compilations. 
(See test CA3011A.) 

k. Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with unconstrained array types 
and record types with discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.) 

(2) The package DIRECT_IO can be instantiated with unconstrained array types and 
record types with discriminants without defaults. (See tests AE2101H, EE2401D, 
and EE2401G.) 

(3) RESET and DELETE operations are supported for SEQUENTIAL_IO. (See tests 
CE2102G and CE2102X.) 

(4) RESET and DELETE operations are supported for DIRECT_IO. (See tests 
CE2102K and CE2102Y.) 

(5) RESET and DELETE operations are supported for text files. (See tests 
CE3102F..G (2 tests). CE3104C, CE3110A and CE3114A.) 

(6) Overwriting to a sequential file does not truncate the file. (See test CE2208B). 

(7) Temporary sequential files are given names and not deleted when closed. (See 
test CE2108A.) 

(8) Temporary direct files are given names and not deleted when closed. (See test 
CE2108C.) 

(9) Temporary text files are given names and not deleted when closed. (See test 
CE3112A.) 

(10) Only one internal file can be associated with each external file for sequential files 
when reading only. (See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 
CE2111D.) 

(11) Only one internal file can be associated with each external file for direct files when 
reading only. (See tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(12) Only one internal file can be associated with each external file for text files when 
reading only. (See tests CE3111A..E (5 tests), CE3114B, and CE3115A.) 


ValiUatioa Summaiy Report AVF-VSR-90502/67 

K R Software Inc. IntcgrAda 4SL0 Chapter 2 - Page S of 5 










TEST INFORMATION 


CHAPTER 3 
TEST INFORMATION 

3J. TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was tested, 44 tests had 
been withdrawm because of test errors. The AVF determined that 405 tests were inapplicable to 
this implementation. All inapplicable tests were processed during validation testing except for 201 
executable tests that use floating-point precision exceeding that supported by the implementation. 
Modifications to the code, processing, or grading for 37 tests were required to successfully 
demonstrate the test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable conformity to the Ada Standard. 

3 2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 


A 

_ 

B 

TEST CLASS 

C D E 


L 

TOTAL 



Passed 


128 


1131 

1933 


10 22 


44 


3268 



Inapplicable 


1 


7 

382 


7 6 


2 


405 



Withdrawn 


1 


2 

35 


0 6 


0 


44 



TOTAL 


130 


1140 

2350 


17 34 


46 


3717 



3.3 SUMMARY OF TEST RESULTS BY CHAPTER 







RESULT 

2 

3 

4 

5 

6 

CHAPTER 

7 8 9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

198 

576 

544 

240 

170 

99 

160 331 

131 

36 

252 

252 

279 

3268 

Inapp 

14 

73 

136 

8 

2 

0 

6 1 

6 

0 

0 

117 

42 

405 

Withdrawn 

1 

1 

0 

0 

0 

0 

0 2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 334 

137 

36 

253 

404 

325 

3717 

3.4 WITHDRAWN TESTS 











AVF-VSR-90502/67 


Vatidatioa Summary Report 

R SoTtwaic Inc. IntcgrAda 4.2.0 


Chapter 3 - Page 1 of 9 














TEST INFORMATION 


The following 44 tests were withdrawn from ACVC Version 1.10 at the time of this validation: 


E2S005C 

A39005G 

B97102E 

C97116A 

BC3009B 

CD2A63A..D 

CD2A66A..D 

CD2A73A..D 

CD2A7(>A..D 

CD2A81G 

CD2A84N&M 

CD5011O 

CD2B15C 

CD7205C 

CD2D11B 

ED7004B 

ED7005C&D 

ED7006C&D 

CD7105A 

CD7203B 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 


CD2A62D 

CD2A83G 

CD5007B 

CD7204B 


3 5 INAPPLICABLE TESTS 


Some tests do not apply to all compilers because they make use of features that a compiler is not 
required by the Ada Standard to support. Others may depend on the result of another test that 
is either ina>' licable or withdrawn. The applicability of a test to an implementation is considered 
each time - .alidation is attempted. A test that is inapplicable for one validation attempt is not 
necessarily inapplicable for a subsequent attempt. For this validation attempt, 405 tests were 
inapplicable for the reasons indicated; 


a. 


b. 


c. 


The following 201 tests are not applicable because they have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGrrS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


C35702A and B86001T are not applicable because this implementation supports no 
predefined type SHORT_FLOAT. 

The following 30 tests are inapplicable because this implementation does not support 
’STORAGE_SIZE representation clauses for access types 


A39005C C87B62B CD1009J 

CD1009R..S (2 tests) CD1C03C CD2A83A..C (3 tests) 

CD2A83E..F( 2 tests) CD2A84B..I (8 tests) CD2A84K..L (2 tests) 
ED2A86A CD2B11B..G (6 tests) CD2B15B 

CD2B16A 


d. The following 16 tests are not applicable because this implementation does not support a 
predefined type SHORT_INTEGER; 


C45231B 

C45304B 

C45502B 

C45503B 

C45504B 

C45504E 

C45611B 

C45613B 

C45614B 

C45631B 

C45632B 

B52004E 

C55B07B 

B55B09D 

B86001V 


CD7I01E 


Valkiatioo Summary Report AVF-VSR-90502/67 

K R Software Uic. IntcgrAda 4^0 Chapter 3 - Page 2 of 9 











TEST INFORMATION 


e. C45531M..P (4 tests) and C45532M..P (4 tests) are inapplicable because the size of a 
mantissa of a fixed point type is limited to 31 bits. 

1. D55A03E..H (4 tests) use 31 or more levels of loop nesting which exceeds the capacity of 

the compiler. 

g. D56001B uses 65 levels of block nesting which exceeds the capacity of the compiler. 

h. D64005F..G (2 tests) are not applicable because this implementation does not support 
nesting 10 levels of recursive procedure calls. 

i. B86001X, C45231D, and CD7101G are not applicable because this implementation does 
not support any predefined integer type with a name other than INTEGER. 
LONGJNTEGER, or SHORT_INTEGER. 

j. B86001Y is not applicable because this implementation supports no predefined fixed-point 
type other than DURATION. 

k. B86001Z is not applicable because this implementation supports no predefined floating¬ 
point type with a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT. 

l. C96005B is not applicable because there are no values of type DURATION’BASE that are 
outside the range of DURATION. 

m. LA3004A, LA3004B, EA3004C, EA3004D, CA3004E, and CA3004F are not applicable 
because this implementation does not support pragma INLINE. 

m. The following 16 tests are not applicable because this implementation does not support 
’SIZE representation clauses for floating-point types. 

CD1009C CD2A41A..E (5 tests) CD2A42A..J (10 tests) 

o. The following 25 tests are inapplicable because ’SIZE representation clauses for array types 
are not supported. 

CD1009E..F (2 tests) CD2A61A..L (12 tests)CD2A62A..C (3 tests) 

CD2A64A..D (4 tests) CD2A65A..D (4 tests) 

p. The following 17 tests are not applicable because ’SIZE representation clauses for record 
types are not supported. 

CD1009G CD2A71A..D (4 tests) CD2A72A..D (4 tests) 

CD2A74A..D (4 tests) CD2A75A..D (4 tests) 

q. CD1009H is not applicable for this implementation because ’SIZE representation clauses 
for private types are not supported. 


Validalioa Summaiy Report 


AVF-VSR-90502/67 


K R Software Inc. InlegrAda 4.2.0 


Chapter 3 - Page 3 of 9 








TEST INFORMATION 


r. CD 10091 is not applicable for this implementation because 'SIZE representation clauses for 
limited private types are not supported. 

s. The following 14 are inapplicable because this implementation does not support record 
representation clauses 

CD1009N CD1009X..Z (3 tests) CD1C03H 

CD1C04E ED1D04A CD4031A 

CD4041A CD4051A..D (4 tests) CD7204C 

t. CD2A81A..F (6 tests) and CD2A87A are not applicable because 'SIZE representation 
clauses for access types are not supported. 

u. CD2A91A..E (5 tests) and CD2A95A are not applicable because ’SIZE representation 
clauses for task types are not supported. 

V. CE2102D is inapplicable because this implementation supports CREATE with IN_FILE 
mode for SEQUENTIALJO. 

w. CE2102E is inapplicable because this implementation supports CREATE with OUT FILE 
mode for SEQUENTIALJO. 

X. CE2102F is inapplicable because this implementation supports CREATE with INOUT FILE 
mode for DIRECT_rO. 

y. CE2102I is inapplicable because this implementation supports CREATE with IN_FILE 
mode for DIRECT_IO. 

z. CE2102J is inapplicable because this implementation supports CREATE with OUT FILE 
mode for DIRECT_IO. 

aa. CE2102N is inapplicable because this implementation supports OPEN with IN FILE mode 
for SEQUENTIAL_IO. 

ab. CE2102O is inapplicable because this implementation supports RESET with IN_FILE mode 
for SEQUENTIAL_IO. 

ac. CE2102P is inapplicable because this implementation supports OPEN with OUT_FILE 
mode for SEQUENTIALJO. 

ad. CE2102Q is inapplicable because this implementation supports RESET with OUT_FILE 
mode for SEQUENTIAL_IO. 

ae. CE2102R is inapplicable because this implementation supports OPEN with INOUT_FILE 
mode for DIRECT_IO. 


Validation S ummar y Report AVF-VSR-90502^7 

R R Software Inc. IntcgrAda 42,0 Chapter 3 - Page 4 of 9 










TEST INFORMATION 


af. CE2102S is inapplicable because this implementation supports RESET with INOUT_FlLE 
mode for DIRECT_IO. 

ait. CE2102T is inapplicable because this implementation supports OPEN with IN_FILE mode 
for DIRECTJO. 

ah. CE2102U is inapplicable because this implementation supports RESET with IN_FILE mode 
for DIRECT_IO. 

ai. CE2102V is inapplicable because this implementation supports OPEN with OUT_FILE 
mode for DIRECT_IO. 

aj. CE2102W is inapplicable because this implementation supports RESET with OUT_FILE 
mode for DIRECTJO. 

ak. CE2107A..E (5 tests), CE2107L, CE2110B, and CE2111D are not applicable because 
multiple internal files cannot be associated with the same external file for sequential files. 
The proper exception is raised when multiple access is attempted. 

al. CE2107F..H (3 tests), CE2110D, and CE2111H are not applicable because multiple internal 
files cannot be associated with the same external file for direct files. The proper exception 
is raised when multiple access is attempted. 

am. EE2201D and EE2401D are inapplicable because this implementation does not support 
sequential and direct I/O for unconstrained array types. 

an. CE3102E is inapplicable because text file CREATE with 1N_FILE mode is supported by 
this implementation. 

ao. CE3102F is inapplicable because text file RESET is supported by this implementation. 

ap. CE3102G is inapplicable because text file deletion of an external file is supported by this 
implementation. 

aq. CE3102I is inapplicable because text file CREATE with OUT_FlLE mode is supported by 
this implementation. 

ar. CE3102J is inapplicable because text file OPEN with IN_FILE mode is supported by this 
implementation. 

as. CE3102K is inapplicable because text file OPEN with OUT_FILE mode is not supported 
by this implementation. 

at. CE3111A..B (2 tests), CE3111D..E (2 tests) CE3114B, and CE3115A are not applicable 
because multiple internal files cannot be associated with the same ^.xternal file for text files. 
The proper exception is raised when multiple access is attempted. 


Validalioo Sumniaiy Report AVF-VSR-90582AS7 


R R Softwuc Ibc. lotcgrAda 4.2.0 


Chapter 3 - Page 5 of 9 













TEST INFORMATION 


T6 TEST. PROCESSING. AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, processing, or evaluation in order 
to compensate for legitimate implementation behaviour. Modifications are made by the AVF in 
cases where legitimate implementation behaviour prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: adding a length clause to alter 
the default size of a collection; splitting a Class B test into subtests so that all errors are detected; 
and confirming that messages produced by an executable test demonstrate conforming behaviour 
that was not anticipated by the test (such as raising one exception instead of another). 

Modifications were required for 37 tests. 


The following tests were split because syntax errors at one point resulted in the compiler not 
detecting other errors in the test: 


B22003A 

B49003A 

B63001A 

BAIIOIE 

BA3008B 


B24007A 

B49005A 

B63001B 

BA3006A 

BA3013A 


B24009A 

B51001A 

B91001H 

BA3006B 

BC2001D 


B29001A 

B52003A 

BAIIOIA 

BA3007B 

BC2001E 


B37106A 

B55A01A 

BAIIOIC 

BA3008A 

BC3005B 


The following tests were passed as a result of modification of code and/or evaluation criteria as 
follows: 


C34006D This test checks that a derived type inherits various properties from the parent; the 
’SIZE attribute is used in this test under assumptions that are not fully supported 
by the Ada standard, and are subject to ARG review. The test outputs 
"INCORRECT OBJECT ’SIZE" on execution. 

C39005A "PRAGMA ELABORATE (REPORT);" is needed between lines 17 and 18 to 
prevent "TEST" from raising PROGRAM_ERROR. 

CE2108A..B (2 tests) CE2108C..D (2 tests) CE3112A..B (2 tests) 

These tests have been modified by commenting out the lines in the second test of 
each of these three pairs that create a temporary file. The lines commented out 
were 45..64 in CE2108B, 45..64 in CE2108D and 40..48 in CE3112B. This ensures 
that a NEW temporary file is not generated with the same name as that generated 
in the 1st test. 

CC1223A The expression "2**T’MANTISSA-1" on line 262 was changed to an equivalent form 
'’(2**(T’MANTISSA-1)-1+2**(T’MANT1SSA-1))" in order to avoid generating the 
exception-raising value 2**31. On execution the test outputs the message 
"INCORRECT VALUE FOR <STR-type>’AFT", generated by the generic check 
lines 256ff. 


Validatioa Simuiiary Report AVF-VSR-90502/67 

R R Software Inc. IntegrAda 4.2.0 Chapter 3 - Page 6 of 9 








TEST INFORMATION 


CC3601A This test was split because the original code, when compiled, ijencrates more than 
32K of code. 

CD2C11A..B (2 tests) 

These tests have been modified to include initialisation of W (in its declaration, 
lines 41 and 44 respectively) to avoid PROGRAM-ERROR being raised when 
procedure Test_Task is called, with W as an actual parameter. 


3J ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 


Prior to validation, a set of test results for ACVC Version 1.10 produced by the IntegrAda 4.2.0 
was submitted to the AVF by the applicant for review. Analysis of these results demonstrated 
that the compiler successfully passed all applicable tests, and the compiler exhibited the expected 
behaviour on all inapplicable tests. 


3.7.2 Test Method 


Testing of the IntegrAda 4.2.0 using ACVC Version 1.10 was conducted on-site by a validation 
team from the AVF. The configuration in which the testing was performed is described by the 
following designations of hardware and software components: 


Host computer 

Host operating system 

Target computer 

Target operating system 

Compiler 

Pre-linker 

Linker 

Loader/Downloader 
Runtime System 


Unisys 386 
SCO Unix 3.2.0 
Unisys 386 
SCO Unix 32.0 
IntegrAda 4.2.0 
None 

IntegrAda 4.2.0 
None 

IntegrAda 4.2.0 


A set of floppy diskettes containing all tests except for withdrawn tests and tests requiring 
unsupported floating-point precisions was taken on-site by the validation team for processing. Tests 
that make use of implementation-specific values were customized before being written to the 
floppy diskettes. Tests requiring modifications during the prevalidation testing were not included 
in their modified form on the floppy diskettes. 


The contents of the floppy diskettes were loaded directly onto the host computer. 


After the test files were loaded to disk, the full set of tests was compiled {, linked, and all 
executable tests were run on the Unisys 386. Results were printed from the host computer. 


Valkiatioa S ummar y Report AVF-VSR-90502/67 

R R Software Inc. IntegrAda 4JZ.0 Chapter 3 - Page 7 of 9 













TEST INFORMATION 


The compiler was tested using command scripts provided by R R Software Inc and reviewed by the 

validation team. The compiler was tested using all default option settings except for the following: 

OPTION EFFECT 

, Q Quiet error messages - suppresses user prompting on errors. Necessary for running 

B-Tests; otherwise every error would have to be responded to. 

AV Warnings off - warnings were suppressed mainly because of the many confusing 

warnings the validation tests produce. Many validation tests have intentional errors 
(such as an expression which always raises an exception, use of null ranges, 
unreachable code, etc. The large volume of warnings produced made it difficult to 
grade the B-Tests in particular, so they were suppressed. 

fT Trimming code on - this directs the compiler to generate code which allows the 

linker to trim unused subprograms. This is necessary in order to have a few large 
tests be small enough to run. 

/D Debugging code off - this directs the compiler to not generate any debugging code 

(generally line numbers and walkbacks). This was also used to cut the space used 
by the tests. 

/BS Brief Statistics. This was also used to cut the amount of output produced by the 

compiler during compile time. 

Then, all of the non-B-Tests were linked with the options: 

/Q Quiet error messages - suppresses user prompting on errors. Necessary for running 

L-Tests; otherwise every error would have to be responded to. 

/T Trim unused code - this option directs the linker to remove unused subroutines 

from the result file. This can make as much as a 30K space saving in the result 
file. 

/B Brief Statistics. This was also used to cut the amount of output produced by the 

Linker during compile time. 

Tests were compiled, linked, and executed (as appropriate) using a single computer. Test output, 

compilation listings, and job logs were captured on floppy diskettes and archived at the AVF. The 

listings examined on-site by the validation team were also archived. 


3.7.3 Test Site 


AVF-VSR-90502/67 


Validatiaa Saminary Report 
R R Software Inc IntegrAda 4.2.0 


Chapter 3 - Page 8 of 9 






TEST INFORMATION 


Testing was conducted at The Numerical Algorithms Group Limited, Wilkinson House, Jordan Hill 
Road, Oxford, United Kingdom, 0X2 SDR and was completed on 25 January 1990. 


Validatioo Suminaiy Rq;xin 
R R Software Inc. IntegrAda 4.2.0 


AVF-VSR-90502/67 
Chapter 3 - Page 9 of 9 









DECLAIUTION OF CONFORMANCE 


APPENDIX A 

DECLARATION OF CONFORXUNCE 


R.R. Software, Inc has submilted the following Declaration of Conformance 
concerning the IntegrAda 4.2.0 compiler. 


\’jlidalion Summary Report 
R.R. Sutlware. Inc IntegrAda 4.2.0 


AVF-VSR-90S02/67 
Appendix A • Page I of 3 









DECLARATION OF CONFORAUNCE 


DECLARATION OF CONFORMANCE 


Compiler Implementor; R.R. Software, Inc 

Ada Validation Facility: The National Computing Centre Limited, 

Oxford Road, 

Manchester, 

Ml 7ED. 

United Kingdom 

Ada Compiler Validation Capability (ACVC) Version: 1.10 

Base Configuration 

Base Compiler Name: 

Host Architecture: 

Host OS and Version: 

Target Architecture: 

Target OS and Version; 


Implementor’s Declaration 

I, the undersigned, representing R.R. Software, Inc have implemented no deliberate 
extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the compiler(s) listed 
in this declaration. I declare that AETECII, Inc is the owner of record of the Ada language 
compiler(s) listed above and, as such, is responsible for maintaining said compiler(s) in 
conformance to ANSI/MIL-STD-1815A. All certificates and registrations for Ada language 
compiler(s) listed in this declaration shall be made only in the owner’s corporate name. 


IntegrAda 4.2.0 

Unisys 386 
SCO Unix 3.2.0 

Same as Host 
Same as Host 



Validulion Summary Report 


AVF-VSR-90S0Z/67 


K.R. Software. Inc IntegrAda 4.2.0 


Appendix A - Page 2 of 3 





DLCLARATION OF CONFORMANCE 


Owner’s Declanition 

I, the undersigned, representing AETECII, Inc, take full responsibility for implementation 
and maintenance of the Ada compiler(s) listed above, and agree to the public disclosure 
of the final Validation Summary Report. I declare that all of the Ada language compilers 
listed, and their host/target performance, are in compliance with the Ada Language 
Standard /^^SI/MIL-STD-1815A. 

/ 

Date : 

President, 

AETECII, Inc 



S'lilUlullon Summary Report 


AVF-VSR-90S02/67 


K.R. SoTtware, Inc InlegrAda 4.2.0 


Appendix A - Page 3 of 3 





APPENDIX F 


APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation-dependent pragmas, 
to certain machine-dependent conventions as mentioned in chapter 13 of the Ada Standard, and 
to certain allowed restrictions on representation clauses. The implementation-dependent 
characteristics of the IntegrAda 4.2.0 compiler, as described in this Appendix, are provided by R 
R Software, Inc. Unless specifically noted otherwise, references in this appendix are to compiler 
documentation and not to this report. Implementation-specific portions of the package 
STANDARD, which are not a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -32768..32767; 

type LONGJNTEGER is range -2147483648..2147483647 

type FLOAT is digits 6 range -((2.0** 128) - (2.0** 104)).. 

-((2.0**128) - (2.0**104)); 

type LONG_FLOAT is digits 15 range-((2.0**1024) - (2.0**971) 

-((2.0**1024) - (2.0**971)); 

type DURATION is delta 0.00025 range -((2.0**31) - l)/4096.0.. 

((2.0**31) - l)/4096.0; 


end STANDARD; 


AVF-VSR-90502/67 


Vatidatioa Summaiy Report 
R R Software Inc. lotegrAda 4.2.0 


Appendix B 








Appendix I': Implemenlalion Dependencies 


F Implementation Dependencies 

This appendix specifies certain system-dependent characteristics of the IntegrAda, version 4.2.0 386 
SCO Unix compiler. 

F.l Implementation Dependent Pragmas 

In addition to the required Ada pragmas, IntegrAda also provides several others. Some of these 
pragmas have a textual range. Such pragmas set some value of importance to the compiler, usually 
a flag that may be On or Off. The value to be used by the compiler at a given point in a program 
depends on the parameter of the most recent relevant pragma in the text of the program. For flags, 
if the parameter is the identifier On, then the flag is on; if the parameter is the identifier Off, then 
the flag is off; if no such pragma has occurred, then a default value is used. 

The range of a pragma - even a pragma that usually has a textual range - may vary if the pragma 
is not inside a compilation unit. This matters only if you put multiple compilation units in a file. 
The following rules apply; 

1) If a pragma is inside a compilation unit, it affects only that unit. 

2) If a pragma is outside a compilation unit, it affects all following compilation units 
in the compilation. 

Certain required Ada pragmas, such as INLINE, would follow different rules; however, as it turns 
out, IntegrAda ignores all pragmas that would follow different rules. 

The following system-dependent pragmas are defined by IntegrAda. Unless otherwise stated, they 
may occur anywhere that a pragma may occur. 

ALL_CHECKS Takes one of two identifiers On or Off as its argument, and has a textual 

range. If the argument is Off, then th’s pragma causes suppression of 
arithmetic checking (like pragma ARITHCHECK - see below), range 
checking (like pragma RANGECHECK - see below), storage error checking, 
and elaboration checking. If the argument is On, then these checks are all 
performed as usual. Note that pragma ALL_CHECKS does not affect the 
status of the DEBUG pragma; for the fastest run time code (and the worst 
run time checking), both ALL_CHECKS and DEBUG should be turned Off 
and the pragma OPTIMIZE (Time) should be used. Note also that 
ALL_CHECKS does not affect the status of the ENUMTAB pragma. 
Combining check suppression using the pragma ALL_CHECKS and using 
the pragma SUPPRESS may cause unexpected results; it should not be 
done. However, ALL_CHECKS may be combined with the IntegrAda 
pragmas ARITHCHECK and RANGECHECK; whichever relevant pragma 
has occurred most recently will determine whether a given check is 
performed. ALL_CHECKS is on by default. Turning any checks off may 
cause unpredictable results if exection would have caused the corresponding 
assumption to be violated. Checks should be off only in fully debugged and 
tested programs. After checks are turned off, full testing should again be 


F-l 


Copynght 1989. R.R, Software. Inc. 


Revision 4.6 











Appendix F: Implementation Dependencies 


ARITHCHECK 


CLEANUP 


DEBUG 


done, since any program that handles an exception may expect results that 
will not occur if no checking is done. 

Takes one of the two identifiers On or Off as its argument, and has a 
textual range. Where ARITHCHECK is on, the compiler is permitted to 
(and generally does) not generate checks for situations where it is permitted 
to raise NUMERIC_ERROR; these checks include overflow checking and 
checking for division by zero. Combining check suppression using the 
pragma ARITHCHECK and using the pragma SUPPRESS may cause 
unexpected results; it should not be done. However, ARITHCHECK may 
be combined with the IntegrAda pragma ALL_CHECKS; whichever pragma 
has occurred most recently will be effective. ARITHCHECK is on by 
default. Turning any checks off may cause unpredictable results if execution 
would have caused the corresponding assumption to be violated. Checks 
should be off only in fully debugged and tested programs. After checks are 
turned off, full testing should again be done, since any program that handies 
an exception may expect results that will not occur if no checking is done. 

Takes an integer literal in the range 0..3 as its argument, and has a textual 
range. Using this pragma allows the IntegrAda run-time system to be less 
than meticulous about recovering temporary memory space it uses. This 
pragma can allow for smaller and faster code, but can be dangerous; certain 
constructs can cause memory to be used up very quickly. The smaller the 
parameter, the more danger is permitted. A value of 3 -the default value- 
causes the run-time system to be its usual immaculate self. A value of 0 
causes no reclamation of temporary space. Values of 1 and 2 allow 
compromising between "cleanliness" and speed. Using values other than 3 
adds some risk of your program running out of memory, especially in loops 
which contain certain constructs. 

Takes one of the two identifiers On or Off as its argument, and has a 
textual range. This pragma controls the generation of line number code and 
procedure name code. When DEBUG is on, such code is generated. When 
DEBUG is off, no line number code or procedure names are generated. 
This information is used by the walkback which is generated after a run¬ 
time error (e.g., an unhandled exception). The walkback is still generated 
when DEBUG is off, but the line numbers will be incorrect, and no 
subprogram names will be printed. DEBUG’s initial state can be set by the 
command line; if no explicit option is given, then DEBUG is initially on. 
Turning DEBUG off saves space, but causes the loss of much of IntegrAda’s 
power in describing run time errors. 

Notes: 

DEBUG should only be turned off when the program has no errors. The 
information provided on an error when DEBUG is off is not very useful. 

If DEBUG is on at the beginning of a subprogram or package specification, 
then it must be on at the end of the specification. Conversely, if DEBUG 
is off at the beginning of such a specification, it must be off at the end. If 
you want DEBUG to be off for an entire compilation, then you can either 


F-2 


CopvTight 1989. R.R. Software. Inc. 


Revision 4.6 





Appendix F: Implemenialion Dependencies 


put a DEBUG pragma in the context clause of the compilation or you can 
use the appropriate compiler option. 

ENUMTAB Takes one of the two identifiers On or Off as its argument, and has a 

textual range. This pragma controls the generation of enumeration tables. 
Enumeration tables are used for the attributes IMAGE, VALUE, and 
WIDTH, and hence to input and output enumeration values. The tables are 
generated when ENUMTAB is on. The state of the ENUMTAB flag is 
significant only at enumeration type definitions. If this pragma is used to 
prevent generation of a type’s enumeration tables, then using the three 
mentioned attributes causes an erroneous program, with unpredictable 
results; furthermore, the type should not be used as a generic actual discrete 
type, and in particular TEXT_IO.ENUMERATION_IO should not be 
instantiated for the type. If the enumeration type is not needed for any of 
these purposes, the tables, which use a lot of space, are unnecessary. 
ENUMTAB is on by default. 

PAGE_LENGTH This pragma takes a single integer literal as its argument. It says that a page 
break should be added to the listing after each occurrence of the given 
number of lines. The default page length is 32000, so that no page breaks 
are generated for most programs. Each page starts with a header that looks 
like the following; 

IntegrAda Version 4.2.0 compiling file on date at time 

RANGECHECK Takes one of the two identifiers On or Off as its argument, and has a 
textual range. Where RANGECHECK is off, the compiler is permitted to 
(and generally does) not generate checks for situations where it is expected 
to raise CONSTRAINT_ERROR; these checks include null pointer 
checking, discriminant checking, index checking, array length checking, and 
range checking. Combining check suppression using the pragma 
RANGECHECK and using the pragma SUPPRESS may cause unexpected 
results; it should not be done. However, RANGECHECK may be combined 
with the IntegrAda pragma ALL_CHECKS; whichever pragma has occurred 
most recently will be effective. RANGECHECK is on by default. Turning 
any checks off may cause unpredictable results if execution would have 
caused the corresponding assumption to be violated. Checks should be off 
only in fully debugged and tested programs. After checks are turned off, full 
testing should again be done, since any program that handles an exception 
may expect results that will not occur if no checking is done. 

SYSLIB This pragma tells the compiler that the current unit is one of the standard 

IntegrAda system libraries. It takes as a parameter an integer literal in the 
range 1 .. 15; only the values 1 through 4 are currently used. For example, 
system library number 2 provides floating point support. Do not use this 
pragma unless you are writing a package to replace one of the standard 
IntegrAda system libraries. 

VERBOSE Takes On or Off as its argument, and has a textual range. VERBOSE 

controls the amount of output on an error. If VERBOSE is on, the two 


F-3 


Copyright 1989, R.R. Software, Inc. 


Revision 4.6 








Appendix F: Implemenialion Dependencies 


lines preceding the error are printed, with an arrow pointing at the error. 
If VERBOSE is off, only the line number is printed. 

VERBOSE(Off): 

Line 16 at Position 5 

*ERROR* Identifier is not defined 

VERBOSE(On): 

15; if X = 10 then 
16: Z := 10; 


*ERROR* Identifier is not defined 

The reason for this option is that an error message with VERBOSE on can 
take a long time to be generated, especially in a large program. VERBOSE’s 
initial condition can be set by the compiler command line. 

Several required Ada pragmas may have surprising effects in IntegrAda. The PRIORITY pragma 
may only take the value 0, since that is the only value in the range System.Priority. Specifying any 
OPTIMIZE pragma turns on optimization; otherwise, optimization is only done if specified on the 
compiler’s command line. The SUPPRESS pragma is ignored unless it only has one parameter. 
Also, the following pragmas are always ignored: CONTROLLED, INLINE, MEMORY_SIZE, 
PACK, SHARED, STORAGE_UNIT, and SYSTEM_NAME. Pragma CONTROLLED is "always 
ignored because IntegrAda does no automatic garbage collection; thus, the effect of pragma 
CONTROLLED already applies to all access types. Pragma SHARED is similarly ignored: 
IntegrAda’s non-preemptive task scheduling gives the appropriate effect to all variables. The 
pragmas INLINE, PACK, and SUPPRESS (with two parameters) all provide recommendations to 
the compiler; as Ada allows, the recommendations are ignored. The pragmas MEMORY_SIZE, 
STORAGE_UNIT, and SYSTEM_NAME all attempt to make changes to constants in the System 
package; in each case, IntegrAda allows only one value, so that the pragma is ignored. 

F,2 Implementation Dependent Attributes 

IntegrAda does not provide any attributes other than the required Ada attributes. 

F.3 Specification of the Package SYSTEM 

The package System for IntegrAda has the following definition. 

package System is 

— System package for IntegrAda 

— Types to define type Address, 
type Offset_Type is new Long_Integer; 
type Word is range 0 .. 65536; 
for Word'Size use 16; 
type Address is record 


F-4 


Copynght 1989, R.R. Software, Inc. 


Revision 4.6 











Appendix Iniplememation Dependencies 


Offset : Offset_Type; 

Segment : Word; 
end record; 

Function "+" (Left : Address; Right : Offset_Type) Return 

Address; 

Function (Left ; Offset_Type; Right ; Address) Return 

Address; 

Function (Left : Address; Right : Offset_Type) Return 

Address; 

Function (Left, Right : Address) Return Offset_Type; 

type Name is (UNIX); 

System_Name ; constant Name := UNIX; 

Storage_Unit ; constant := 8; 

Memory_Size ; constant := 65536; 

— Note: The actual memory size of a program is 

— determined dynamically; this is the maximum number 

— of bytes in the data segment. 

— System Dependent Named Numbers: 

Min_Int : constant := -2_147_483_648; 

Max_Int : constant := 2_147_483_647; 

Max_Digits : constant := 15; 

Max_Mantissa : constant := 31; 

Fine_Delta : constant := 2#1.0#E-31; 

— equivalently, 4.656612873077392578125E-10 
Tick : constant := 0.01; — Some machines have less 

— accuracy; for example, the IBM PC actually ticks 

— about every 0.06 seconds. 

— Other System Dependent Declarations 
subtype Priority is Integer range 0.,0; 

type Byte is range 0 .. 255; 
for Byte'Size use 8; 

end System; 

The type Byte in the System package corresponds to the 8-bit machine byte. The type Word is a 
16-bit Unsigned Integer type, corresponding to a machine word. 

F.4 Restrictions on Representation Qauses 

If T is a discrete type, or a fixed point type, then the size expression can give any value between 
1 and 1000 bits (subject, of course, to allowing enough bits for every possible value). For other 
types, the expression must give the default size for T. 

A length clause that specifies T’STORAGE_SIZE for an access type is not supported; IntegrAda 
uses a single large common heap. 

F-5 


C'npynghi 1989, R.R. Software, Inc. 


Revision 4.6 





Appendix F: Implcmenlalion Dependencies 


A length clause that specifies T'STORAGE_SIZE for a task type T is supported. Any integer 
value can be specified. Values smaller than 256 will be rounded up to 256 (the minimum 
T'Slorage Size), as the Ada standard does not allow raising an exception in this case. 

.\ length clause that specifies T’SMALL for a fixed point type must give a value (subject to the 
.Ada restrictions) in the range 

2.0 ** (-99) . . 2.0 ** 99, 


inclusive. 


.An enumeration representation clause for a type T may give any integer values within the range 
Svstem.Min lnt .. System.Max_Int. If a size length clause is not given for the type, the type’s size 
is determined from the literals given. (If all of the literals fit in a byte, then Byte’Size is used; 
similarly for Integer and Long_Integer). 

The expression in an alignment clause in a record representation clause must equal 1. 

A component clause must give a storage place that is equivalent to the default value of the 
POSITION attribute for such a component. 

A component clause must give a range that starts at zero and extends to one less than the size of 
ihc component. 

IntegrAda supports address clauses on most objects. Address clauses are not allowed on parameters, 
generic formal parameters, and renamed objects. The address given for an object address clause 
may be any legal value of type System.Address. It will be interpreted as an absolute machine 
address, using the segment part as a selector if in the protected mode. It is the user’s responsibility 
to ensure that the value given makes sense (i.e., points at memory, does not overlay other objects, 
etc.) No other address clauses are supported. 

F.5 Implementation Defined Names 

IntegrAda uses no implementation generated names. 

F.6 Address Qause Expressions 

The address given for an object address clause may be any legal value of type System.Address. It 
will be interpreted as an absolute machine address, using the segment part as a selector if in the 
protected mode. It is the user’s responsibility to ensure that the value given makes sense (i.e., 
points at memory, does not overlay other objects, etc.) 

F.7 Unchecked_Conversion Restrictions 

We first make the following definitions: 

A type or subtype is said to be a simple type or a simple subtype (respectively) if it is a scalar 
(sub)type, an access (sub)type, a task (sub)type, or if it satisfies the following two conditions: 

F-6 


Cnpvnght 1989. R.R. Software. Inc. 


Revision 4.6 






Appendix F: Implementation Dependencies 


1) If it is an array type or subtype, then it is constrained and its index constraint is 
static; and 

2) If it is a composite type or subtype, then all of its subcomponents have a simple 
subtype. 

A (sub)type which does not meet these conditions is called non-simple. Discriminated records can 
be simple; variant records can be simple. However, constraints which depend on discriminants are 
non-simple (because they are non-static). 

IntegrAda imposes the following restriction on instantiations of Unchecked_Conversion: for such 
an instantiation to be legal, both the source actual subtype and the target actual subtype must be 
simple subtypes, and they must have the same size. 

F.8 Implementation Dependencies of I/O 


The syntax of an external file name depends on the operating system being used. Some external 
files do not really specify disk files; these are called devices. Devices are specified by special file 
names, and are treated specially by some of the I/O routines. 

The syntax of an UNIX filename is: 

[path]filename 

where "path" is an optional path consisting of directory names, each followed by a foreslash: 
"filename" is the filename (maximum 14 characters). See your UNIX manual for a complete 
description. In addition, the following special device names are recognized: 


/dev/sti 

/dev/sto 

/dev/err 

/dev/ekbd 


/dev/kbd 


UNIX standard input. The same as Standard_Input. Input is buffered by 
lines, and all UNIX line editing characters may be used. Can only be read. 
UNIX standard output. The same as Standard_Output. Can only be written. 
UNIX standard error. The output to this device cannot be redirected. Can 
only be written. 

The current terminal input device. Single character input with echoing. Due 
to the design of UNIX, this device can be redirected. Can be read and 
written. 

The current terminal input device. No character interpretation is performed, 
and there is no character echo. Again, the input to this device can be 
redirected, so it does not always refer to the physical keyboard. 


The UNIX device files may also be used. 


The UNIX I/O system will do a search of the default search path (set by the environment 
PATH variable) if the following conditions are met: 


1) No path is present in the file name; and 

2) The name is not that of a device. 


F-7 


Cfipynght 1989. R.R. Software. Inc. 


Revision 4.6 






Appendix F: Implemenlalion Dependencies 


Alternatively, you may think of the search being done if the file name does not contain any 
of the characters or 7’. 

The default search path cannot be changed while the program is running, as the path is 
copied by the IntegrAda program when it starts running. 

Note; 

Creates will never cause a path search as they must work in the current directory. 

Upon normal completion of a program, any open external files are closed. Nevertheless, to provide 
portability, we recommend explicitly closing any files that are used. 

Sharing external files between multiple file objects causes the corresponding external file to be 
opened multiple times by the operating system. The effects of this are defined by your operating 
system. This external file sharing is only allowed if all internal files associated with a single 
external file are opened only for reading (mode ln_File), and no internal file is Created. 
Use Error is raised if these requirements are violated. A Reset to a writing mode of a file already 
opened for reading also raise Use_Error if the external file also is shared by another internal file. 

Binary I/O of values of access types will give meaningless results and should not be done. Binary 
1, 0 of types which are not simple types (see definition in Section F.7, above) will raise Use_Error 
when the file is opened. Such types require specification of the block size in the form, a capability 
which is not yet supported. 

The form parameter for Sequential_IO and Direct_10 is always expected to be the null string. 

The type Count in the generic package Direct_IO is defined to have the range 0 .. 2_147_483_647. 

Ada specifies the existence of special markers called terminators in a text file. IntegrAda defines 
the line terminator to be <LF> (line feed), with or without an additional <CR> (carriage return). 
The page terminator is the <FF> (form feed) character; if it is not preceded by a <LF>, a line 
terminator is also assumed. 

The file terminator is the end-of-file returned by the host operating system. If no line and/or page 
terminator directly precedes the file terminator, they are assumed. The only legal form for text 
files is "" (the null string). All other forms raise USE_ERROR. 

Output of control characters does not affect the layout that Text_IO generates. In particular, output 
of a <LF> before a New_Page does not suppress the New_Line caused by the New_Page. 

The character <LF> is written to represent the line terminator. 

The type Text_IO.Count has the range 0 .. 32767; the type Text_IO.Field also has the range 0 .. 
32767. 

IO_Exceptions.USE_ERROR is raised if something cannot be done because of the external file 
system; such situations arise when one attempts: 

to create or open an external file for writing when the external file is already open 
(via a different internal file). 


F-8 


Copyright 1989, R.R. Software, Inc. 


Revision 4.6 










Appcnaw 1': Impicmontalion Dependencies 


to create or open an external file when the external file is already open for writing 
(via a different internal file). 

to reset a file to a writing mode when the external file is already open (via a 

different internal file). 

to write to a full de\ ice (Write, Close); 

to create a file in a full directory (Create); 

to have more files open than the OS allows (Open, Create); 

to open a device with an illegal mode; 

to create, reset, or delete a device; 

to create a file where a protected file (i.e., a directory or read-only file) already 
exists; 

to delete a protected file; 

to use an illegal form (Open, Create); or 

to open a file for a non-simple type without specifying the block size; 
to open a device for direct I/O. 

IO_Exceptions.DEVICE_ERROR is raised if a hardware error other than those covered by 
USE ERROR occurs. These situations should never occur, but may on rare occasions. For 
example, DEVICE_ERROR is raised when: 

a file is not found in a Close or a Delete; 
a seek error occurs on a direct Read or Write; or 
a seek error occurs on a sequential End_Of_File. 

The subtypes Standard.Positive and Standard.Natural, used by some I/O routines, have the 
maximum value .12767. 

No package Low_Level_IO is provided. 

F.9 Running the compiler and linker 

The IntegrAda compiler is invoked using the following format: 

COMPILE filename (-option) 

where filename is an UNIX file name with optional compiler options {-option}. 

The compiler options are: 

B Brief error messages. The line in error is not printed (equivalent to turning off pragma 
VERBOSE). 

BS Brief statistics. Few compiler statistics are printed. 

D Don’t generate debugging code (equivalent to turning off pragma DEBUG) 

F Use in-line 80387 instructions for Floating point operations. By default the compiler 
generates library calls for floating point operations. The 80387 may be used to execute the 
library calls. A floating point support library is still required, even though this option is 
used. 

L Create a listing file with name filename.PRN on the same disk as filename. The listing file 
will be a listing of only the last compilation unit in a file. 


F-9 


Copyright 1989. R.R. Software. Inc. 


Revision 4.6 








Appc-ndLX T; Implemcnlalion Dependc-ncics 


Ox Object code memorx' model. X is 0 for the 80386 system. Other memory models are not 
supported. (Since this model 'limits’ a program to 4 Gigabytes of Code and 4 Gigabytes 
of Data, this is not a concern). Memory model 0 is assumed if this option is not given. 

Q Quiet error messages. This option causes the compiler not to wail for the user to interact 
after an error. In the usual mode, the compiler will prompt the user after each error to 
ask if the compilation should be aborted. This option is useful if the user wants to take a 
coffee break while the compiler is working, since all user prompts are suppressed. The 
errors (if any) will not stay on the screen when this option is used; therefore, the console 
traffic should be sent to the printer or to a file. Be warned that certain syntax ..rrors can 
cause the compiler to print many error messages for each and every line in the program. 

T Generate information which allows trimming unused subprograms from the code. This 
option tells the compiler to generate information which can be used by the remove 
subprograms from the final code. This option increases the size of the .JRL files produced. 
We recommend that it be used on reusable libraries of code (like trig, libraries or stack 
packages) - that is those compilations for which it is likely that some subprograms are not 
called. 

W Don’t print any warning messages. For more control of warning messages, use the following 
option form (Wx). 

\Vx Print only warnings of level less than the specified digit ’x’. The given value of x may be 
from 1 to 9. The more warnings you are willing to see, the higher the number you should 
give. 

.X Handle eXtra symbol table information. This is for the use of debuggers and other future 
tools. This option requires large quantities of memory and disk space, and thus should be 
avoided if possible. 

Z Turn on optimization. This has the same effect as if the pragma OPTIMIZE were set to 
SPACE throughout your compilation. 

The default values for the command line options are: 

B Error messages are verbose. 

BS Statistics are verbose. 

D Debug code is generated. 

F Library calls are generated for floating point operations. 

L No listing file is generated. 

O Memory model 0 is used. 

Q The compiler prompts for abort after every error. 

T No trimming code is produced. 

W All warnings are printed. 

X Extra symbol table information is not generated. 

Z Optimization is done only where so specified by pragmas. 

Leading spaces are disregarded between the filename and the call to COMPILE. Spaces are 

otherwise not recommended on the command line. The presence of blanks to separate the options 

will be ignored. 

Examples: 

COMPILE test-Q-L 
COMPILE test.run-W4 
COMPILE test 

COMPILE test .run -B -W-L 

F-io 


Ccipyright 1989, R.R. Software. Inc. 


Revision 4.6 




Appendix F: Implementation Dependencies 


The compiler produces a SYM (SYMbol table information) file when a specification is compiled, 
and a SRL or JRL (Specification RcLocatable or Janus ReLocatable) file when a body is compiled. 
To make an executable program, the appropriate SRL and JRL files must be linked (combined) 
with the run-time libraries. This is accomplished by running the IntegrAda linker, BIND. 

The IntegrAda linker is invoked using the following format: 

BIND filename {-option} 

Here "filename" is the name of the SRL or JRL file created when the main program was compiled 
(without the .SRL or .JRL extension) with optional linker options {-option}. The filename usually 
corresponds to the first fourteen letters of the name of your main program. See the linker manual 
for more detailed directions. We summarize here, however, a few of the most commonly used 
linking options: 

FO Use software floating point (the default). 

F2 Use hardware (80387) floating point. 

L Display lots of •’formation about the loading process. 

OO Use memory model 0 (the default); see the description of the /O option in the compiler, 
above. 

Q Use quiet error messages; i.e., don’t wait for the user to interact after an error. 

B Use brief statistics. 

T Trim unused subprograms from the code. This option tells the linker to remove 
subprograms which are never called from the final output file. This option reduces space 
usage of the final file by as much as 30K. 

Examples: 

BIND test 
BIND test -Q-L 
BIND test-L-F2 

Note that if you do not have a hardware floating point chip, then you generally will not need to 
use any linker options. 


F-ll 


CopvTighl 1989. R R. Software. Inc. 


Revision 4.6 










TEST PARAMETERS 


APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such as the maximum 
length of an input line and invalid file names. A test that makes use of such values is identified 
by the extension .TST in its file name. Actual values to be substituted are represented by names 
that begin with a dollar sign. A value must be substituted tor each of these names before the test 
is run. The values used for this validation are given below; 

Name and Meaning Value 


$ACC_SIZE 

An integer literal whose value is the 
number of bits sufficient to hold any value 
of an access type. 

SBIGJDl 

An identifier the size of the maximum input 
line length which is identical to $BIG_ID2 
except for the last character. 

$BIG_ID2 

An identifier the size of the maximum input 
line length which is identical to $BIG_ID1 
except for the last character. 

SBIG_ID3 

At identifier the size of the maximum input 
line length which is identical to $BIG_ID4 
except for a character near the middle. 

$BIG_ID4 

An identifier the size of the maximum input 
line length which is identical to $BIG_ID3 
except for a character near the middle. 

$BIG_INT_LIT 

An integer literal of value 298 with enough 
leading zeroes so that it is the size of the 
maximum line length. 

$BIG_REAL_LIT 

A universal real literal of value 690.0 with 
enough leading zeroes to be the size of the 
maximum line length. 


32 


(1..199=>’A’,200=>T’) 


(1..199=>’A’,200=>’2’) 


(1..100=>’AM01 = >’3M 02..200= >’A’) 


(1..100=>’AM01 = >’4M02..200 = >’A’) 


(1..197=>’OM98..200=>’298’) 


(1..194=>’OM95..200= >’69.0E1’) 


AVF-VSR-90502/67 


Validatioa Sammaiy Report 
R R Software Inc. InlegrAJa 4.2.0 


Appendix C - Page 1 of 6 






TEST PARAMETERS 


SBIG_STRING1 

A string literal which when catenated with 
BIG_STR[NG2 yields the image of 
BIG_IDl. 

$BIG_STRING2 

A string literal which when catenated to the 
end of B1G_STRING1 yields the image of 
BIGJDl. 

SBLANKS 

A sequence of blanks twenty characters less 
than the size of the maximum line length. 

SCOUNT_LAST 

A universal integer literal whose value is 
TEXT_IO.COUNT’LAST. 

SDEFAULT_MEM_SIZE 

An integer iteral whose value is 

SYSTEM.MEMORY_SIZE. 

SDEFAULT_STOR_UNIT 

An integer literal whose value is 

SYSTEM.STORAGE_UNIT. 

$DEFAULT_SYS_NAME 

The value of the constant 

SYSTEM.SYSTEM_NAME. 

$DELTA_DOC 

A real literal whose value is 
SYSTEM.FINE_DELTA. 

$FIELD_LAST 

A universal integer literal whose value is 
TEXTIO.FIEL D’LAST. 

D_LAST> 

$FIXED_NAME 

The name of a predefined fixed-point type 
other than DURATIOhT. 


("l..I()0=>’A'") 


('T..99=>’AM00=>r") 


(1..180=>’ ’) 


32 767 


65536 


8 


UNIX 


2#1.0#E-31 


32 767 


NOT_APPLICABLE 


VaJidatioa Summary Rqx)f1 
R R Software Inc. Inte^Ada 4.2.0 


AVF-VSR-90502/67 
Appendix C - Page 2 of 6 










TEST PARAMETERS 


$FLOAT_NAME 

The name of a predefined floating-point 
tvpe other than FLOAT, SHORT_FLOAT, 
or LONG_FLOAT. 

SGREATER_THAN_DURATION 
A universal real literal that lies between 
DURATION’BASE’LAST and 
DURATION’LAST or any value in the 
range of DURATION. 

$GREATER_THAN_DURATION_BASE 

_LAST 

A universal real literal that is greater than 
DURATION’BASE’LAST. 

$HIGH_PRIORITY 

An integer literal whose value is the upper 
bound of the range for the subtype 
SYSTEM.PRIORIT^'. 

$ILLEGAL_EXTERNAL_FILE_NAME1 
An external file name which contains invalid 
characters. 

$ ILLEGAL_EXTERN AL_FILE_N AME2 
An external file name which is too long. 

$INTEGER_FIRST 

A universal integer literal whose value is 
INTEGER’RRST. 

SINTEGER_LAST 

A universal integer literal whose value is 
INTEGER’LAST. 

$INTEGER_LAST_PLUS_1 
A universal integer literal whose value is 
INTEGER’LAST + 1. 

$LESS_THAN_DURATION 
A universal real literal that lies between 
DURATION’BASE’FIRST and 
DURATION’FIRST or any value in the 
range DURATION. 


NOT_APPLICABLE 

300_000.0 

1.0E6 

0 

/NODIRECTORY/FILENAME 

<BAD| ^ 

-32768 

32767 

32768 

-305 000.0 


VaiiUatioa Simmuiy Report AVF-VSR-90502/67 

R R Software Inc. InlegrAda 4i0 Appendix C - Page 3 of 6 







TEST PARAMETERS 


SLESS_THAN_DURATION_BASE_FIRST 
A universal real literal that is less than 
DL'RATION'BASE’FIRST. 

SLOW_PRIORITY 

An integer literal whose value is the lower 
bound of the range for the subtype 
SYSTEM.PRIORITY. 

SMANTISSA_DOC 

An integer literal whose value is 
SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 

Maximum digits supported for floating-point 
tvpes. 

$MAX_IN_LEN 

Maximum input line length permitted by the 
implementation. 

$MAX_INT 

A universal integer literal whose value is 
SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 

A universal integer literal whose value is 
S YSTEM.MAX_INT+1. 

$MAX_LEN_INT_BASED_LITERAL 
A universal integer based literal whose value 
is 2#11# with enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_LEN_REAL_BASED_LITERAL 
A universal real based literal whose value 
is 16;F.E: with enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

SMAX_STRING_LITERAL 
A string literal of size MAX_IN_LEN, 
including the quote characters. 

SMINJNT 

A universal integer literal whose value is 
SYSTEM.MIN INT. 


-1.0E6 


0 


31 


15 


200 


2147483647 


2147483648 


(1..2=>’2’,3..197=>’0M98..200=>’11;’) 


(1..3 = >T6:’,4..196 = >’0M97..200= >’F.E:’) 


(1 = > ”",2.. 199 = > ’A’,200=>’"’) 


-2147483648 


AVF-VSR-90502/67 


Validation Summaiy Report 
R R Software Inc. IntegrAda 4.2.0 


Appendix C - Page 4 of 6 








TEST PARAMETERS 


$MIN_TASK_SIZE 

.Aji integer literal whose value is the 
number of bits required to hold a task 
object which has no entries, no declarations, 
and "NULL;" as the only statement in its 
body. 

SNAME 

A name of a predefined numeric type other 
than FLOAT, INTEGER, SHORT_FLOAT. 
SHORT_INTEGER. LONG_FLOAT, or 
LONG_INTEGER. 

SNAME_LIST 

A list of enumeration literals in the type 
SYSTEM.NAME, separated by commas. 

$NEG_BASED_INT 

A based integer literal whose highest order 
nonzero bit falls in the sign bit position of 
the representation for SYSTEM.MAX_INT. 

SNEW_MEM_SIZE 

An integer literal whose value is a permitted 
argument for pragma MEMORY SIZE, 
other than $DEFAULT_MEM_SIZ~E. If 
there is no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEW_STOR_UNIT 

An integer literal whose value is a permitted 
argument for pragma STORAGE_UNIT, 
other than $DEFAULT_STOR_UNIT. If 
there is no other permitted value, then use 
value of SYSTEM.STORAGE_UNIT. 

$NEW_SYS_NAME 

A value of the type SYSTEM.NAME, other 
than $DEFAULT_SYS_NAME. If there 
is only one value of that type, then use that 
value. 

$TASK_SIZE 

An integer literal whose value is the 
number of bits required to hold a task 
object which has a single entry with one ’IN 
OUT’ parameter. 


."52 


NOT_APPLICABLE 


UNIX 


16#FFFF FFFF# 


65536 


8 


UNIX 


32 


AVF-VSR-90502/67 


Validatioa Summaiy Report 
R R Software Inc IntegrAda 4.2.0 


Appendix C - Page 5 of 6 








TEST PARAMETERS 


STICK 0.01 

A real literal whose value is 
SYSTEM.TICK. 


Validation Summaiy Report AVF-VSR-90502/67 

R R Software Inc. IntegrAda 4i0 Appendix C - Page 6 of 6 







WITHDRAWN TESTS 


APPENDDC D 
WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to the Ada Standard. 

The following 44 tests had been withdrawn at the time of validation testing for the reasons 

indicated. A reference of the form Al-ddddd is to an Ada Commentary. 

E28005C This test expects that the string TOP OF PAGE. --63" of line 204 will appear 
at the top of the listing page due to a pragma PAGE in line 203; but line 203 
contains text that follows the pragma, and it is this that must appear at the top of 
the page. 

A39005G This test unreasonably expects a component clause to pack an array component into 
a minimum size (line 30). 

B97102E This test contains an unitended illegality: a select statement contains a null 
statement at the place of a selective wait alternative (line 31). 

C97116A This test contains race conditions, and it assumes that guards are evaluated 
indivisibly. A conforming implementation may use interleaved execution in such 
a way that the evaluation of the guards at lines 50 & 54 and the execution of task 
CHANGING_OF_THE_GUARD results in a call to REPORT.FAILED at one of 
lines 52 or 56. 

BC3009B This test wrongly expects that circular instantiations will be detected in several 
compilation units even though none of the units is illegal with respect to the units 
it depends on; by AI-00256, the illegality need not be detected until execution is 
attempted (line 95). 

CD2A62D This test wrongly requires that an array object’s size be no greater than 10 although 
its subtype’s size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A.D, CD2A73A..D, CD2A76A.D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived type (for 
which a ’SIZE length clause is given) by passing them to a derived subprogram 
(which implicitly converts them to the parent type (Ada standard 3.4:14)). 
Additionally, they use the ’SIZE length clause and attribute, whose interpretation 
is considered problematic by the WG9 ARG. 

CD2A81G, CD2A83G, CD2A84N & M, & CD5011O (5 tests] 

These tests assume that dependent tasks will terminate while the main program 
executes a loop that simply tests for task termination; this is not the case, and the 
main program may loop indeBnitely (lines 74, 85, 86 «& %, 86 & %, and 58, resp.). 

CD2B15C & CD7205C 


Validatiaa Summaiy Report AVF-VSR-90S02/67 


R R Software Inc. InlesrAda 4.2.0 


Appendix D - Page 1 of 2 







WITHDRAWN TESTS 


These tests expect that a ’STORAGE_SIZE length clause provides precise control 
over the number of designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

CD2D11B This test gives a SMALL representation clause for a derived fixed-point type (at 
line 30) that defines a set of model numbers that are not necessarily represented 
in the parent type; by Commentary AI-00099, all model numbers of a derived 
fixed-point type must be representable values of the parent type. 

CD5007B This test wrongly expects an implicitly declared subprogram to be at the the address 
that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM pragmas; the 
AVO withdraws these tests as being inappropriate for validation. 

CD7105A This test requires that successive calls to CALENDAR.CLOCK change by at least 
SYSTEM.TICK; however, by Commentary AI-0020L it is only the expected 
frequency of change that must be at least SYSTEM.TlCK-particular instances of 
change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the ’SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 

CD7205D This test checks an invalid test objective: it treats the specification of storage to 
be reserved for a task’s activation as though it were like the specification of storage 
for a collection. 

CE2107I This test requires that objects of two similar scalar types be distinguished when read 
from a file-DATA_ERROR is expected to be raised by an attempt to read one 
object as of the other type. However, it is not clear exactly how the Ada standard 
14.2.4:4 is to be interpreted; thus, this test objective is not considered valid, (line 
90) 

CE3111C This test requires certain behavior, when two files are associated with the same 
external file, that is not required by the Ada standard. 

CE3301A This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer to 
STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 

CE3411B This test requires that a text file’s column number be set to COUNT’L.AlST in order 
to check that LAYOUT_ERROR is raised by a subsequent PUT operation. But 
the former operation will generally raise an exception due to a lack of available disk 
space, and the test would thus encumber validation testing. 


Valklatioa S ummar y Report AVF-VSR-90502/67 


R R Software Inc. IntegrAda 4.2.0 


Appendix D - Page 2 of 2 








NCC VSR ADDENDUM 


« 


This Addendum to the ACVC 1.10 VSR clarifies some items which are contained within the 
standard pre-forma Validation Summary Report as supplied by the Ada Maintenance Office 
(AMO). 

In line with AJPO regulations the contents of the VSR have not been altered in order to keep 
consistency between the different AVF's. 

The points raised in this addendum are being addressed by the AMO in future issues of the VSR. 


1 The last paragraph of Chapter 1 contains the following statement ’Any test that was 
determined to contain an illegal language construct or an erroneous language construct is 
withdrawn from the ACVC...’ 

This is incorrect since illegal constructs are legitimately contained within Class B tests. 


Both the terms ’inapplicable’ and ’not applicable’ are used within the VSR These terms 
are identical. 


3 Chapter 1 of the VSR does not indicate how ’inapplicable’ tests are to be analysed. The 
analysis is undertaken as follows: 

’Each inapplicable test is checked to ensure that this behaviour is consistent with the given 
reasons for its inapplicability’. 






