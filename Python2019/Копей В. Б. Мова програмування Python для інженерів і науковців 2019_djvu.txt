МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКР АЇНИ 

Івано-Франківський національний технічний 
університет нафти і газу 


Кафедра комп’ютеризованого машинобудування 


В. Б. Копей 


МОВА ПРОГРАМУВАННЯ Р¥ТНОN 
ДЛЯ ІНЖЕНЕРІВ І НАУКОВЦІВ 


НАВЧАЛЬ НИЙ ПОСІБНИК 


Івано-Франківськ 

2019 



УДК 004.43 

К 65 


Рецензент: 

Панчук В. Г., доктор технічних наук, професор, 
завідувач кафедри комп’ютеризованого 

машинобудування Івано-Франківського національного 
технічного університету нафти і газу 


К65 Копей В. Б. Мова програмування РуїЬоп для інженерів і 
науковців: Навчальний посібник / В. Б. Копей - Івано- 
Франківськ: ІФНТУНГ, 2019. - 275 с. 


Навчальний посібник містить приклади програм мовою РуїЬоп 
з коментарями. Розглянуто основи програмування, стандартну 
бібліотеку та зовнішні бібліотеки для технічних та наукових 
обчислень. Розроблено відповідно до робочих програм дисциплін 
"Основи програмування" та "Об’єктно-орієнтоване програмування" 
для підготовки бакалаврів за спеціальністю 131 - Прикладна 
механіка. 


УДК 004.43 


©Копей В. Б., 2019 
©ІФНТУНГ, 2019 



ЗМІСТ 


ВСТУП.9 

РОЗДІЛ 1. МОВА РУТРКЖ ТА її СТАНДАРТНА 

БІБЛІОТЕКА.12 

Найпростіша програма.12 

Програма для додавання двох чисел.12 

Числові типи даних.12 

Оператори числових типів.13 

Оператор умови іґ.15 

Оператор циклу їог.15 

Оператор циклу \уїп1е.15 

Оператори Ьгеак і соиііиие.16 

Послідовність кортеж. Оператори для усіх послідовностей.. 16 

Послідовність рядок.17 

Юнікод-рядки.19 

Юнікод-літерали в РуІЇюи 2.20 

Послідовність список.20 

Словник. Оператори для словників.21 

Множина.22 

Функції.23 

Функції з довільним числом аргументів.24 

ІатЬйа-функцїї.24 

Рекурсивні функції.24 

Замикання.25 

Обробка виняткових ситуацій.25 

Файли.26 

Модулі.28 

Файл с:\1\таіи.ру:.28 

Файл с:\1\тосІи1е1.ру:.29 

Файл с:\1\раска§е1\_іий_.ру:.ЗО 

Файл с:\1\раска§е1\то(іи1е1.ру:.ЗО 

Файл с:\1\раска£е1\тосІи1е2.ру:.ЗО 

З 
































Математичні функції.ЗО 

Вбудовані функції для роботи з послідовностями.32 

Генератори.33 

Співпрограми.34 

Ітератори.34 

Об’єкти.35 

Класи.36 

Клас з конструктором.36 

Успадкування і поліморфізм.37 

Атрибути класу і атрибути екземпляра.38 

Статичні методи та методи класу.40 

Властивості.41 

Перевантаження операторів.41 

Контейнери.42 

Менеджери контексту І Інструкція \¥ІЇІ 1 .44 

Метакласи.45 

Декоратори.46 

Декоратори з аргументом.47 

Декоратори класу.47 

Інтроспекція.48 

іпзресі - перегляд об’єктів часу виконання.51 

сору - копії об’єктів.52 

ІІЄЙООІ8 - функції для ефективних ітерацій.53 

ге - операції з використанням регулярних виразів.55 

йесітаї - дійсні числа довільної точності.62 

їіше - визначення і конвертування значень часу.63 

йаіеіїте - робота з датою і часом.64 

саіепйаг - робота з календарем.66 

рйЬ - відлагоджувач РуЙюп.66 

їішеії - тривалість виконання невеликих частин коду.67 

І 0 ££Іп§ - ведення журналу.68 

ріскіе - серіалізація об’єктів РуЙюп.69 

зйеіуе - збереження об’єктів РуЙюп.69 

4 




































апусІЬт - універсальний доступ до БВМ баз даних.70 

8^1йеЗ - БВ-АРІ 2.0 інтерфейс для баз даних 8С)Іл1:е.71 

С8У - читання і запис файлів С8У.72 

ІагШе - читання і запис файлів архіву іаг.73 

гірШе - робота з 2ІР-архівами.74 

2 ІіЬ - сумісне з § 2 Ір стиснення даних.75 

8у8 - системні параметри і функції.75 

08 - файлова система.76 

8Йи1і1 - високорівневі операції з файлами.78 

08 - створення і керування процесами.78 

8иЬргосе88 - керування підпроцесами.79 

8иЬргосе88 - міжпроцесова взаємодія.80 

шаіп.ру - модуль клієнта.80 

8егуег.ру - модуль сервера.81 

Йігеасі - створення багатьох потоків керування.82 

їЬгеа(ііп§ - високорівневий інтерфейс потоків.83 

ши1їіргосе88Іп§ - підтримка багатох процесів.84 

ши1йргосе88Іп§ - запуск паралельних задач.86 

ши1гіргосе88Іп§ - міжпроцесова взаємодія.86 

80 скеІ - низькорівневий мережевий інтерфейс.87 

8егуег.ру - модуль сервера.87 

сііепі.ру - модуль клієнта.89 

80скеіРі1еІО.ру - читання і запис об’єктів Руїйоп через сокет 

.89 

8оскеї8егуег - каркас для мережевих серверів.90 

СОІ НТТР сервер.91 

СОІ-програма зітріе.ру - генерація форми запиту.93 

СОІ-програма §еї_ро5І:.ру - обробка запитів ОЕТ і Р08Т.94 

3¥80І сервер.95 

иг11іЬ2 - запити до НТТР серверів.98 

хті.бот.тіпісіот - мінімальна реалізація БОМ.99 

хтІ.сІгсс.ЕІстепіТгсс - ЕІешепїТгее ХМЕ АРІ.103 

НТМЕРагеег - простий парсер НТМЕ і ХНТМЕ.105 

5 



































Ткіпісг - проста програма з графічним інтерфейсом.107 

Ткіпісг - основні класи.108 

Мк.Тгееуіе\у - дерево елементів.112 

Вбудовування інтерпретатора РуїНоп у С++ програму.116 

сіурев - ВИКЛИК зовнішніх С-функцій.117 

Розширення РуІЇюп мовою С++.119 

РОЗДІЛ 2. СТОРОННІ БІБЛІОТЕКИ РУТНОИ.121 

ІРуІЇюп - інтерактивна командна оболонка.121 

Лируїег ІЧоІеЬоок - інтерактивні документи.124 

МаірІоіІіЬ - процедурний АРІ руріоі.126 

МаірІоіІіЬ - об’єктно-орієнтований АРІ.127 

МаірІоіІіЬ - додаткові параметри графіків.128 

МаірІоіІіЬ - інші типи діаграм.130 

МаірІоіІіЬ - інтерактивна побудова графіків.134 

ВокеЬ - інтерактивна візуалізація.136 

ВокеЬ - серверна програма.137 

питру - робота з масивами.138 

питру.1іпа1§ - лінійна алгебра.143 

питру .гапбот - генератори випадкових чисел.144 

питру - поліноми.145 

8сіру.VЄСІОГІ 2 Є - векторизація функцій.145 

8сіру - похідна і первісна функції.146 

8сіру.іпіе£гаіе - інтегрування.147 

8СІру.іпІс§гаІс.ос1сіпІ - звичайні диференціальні рівняння.... 148 

8СІру.іпіе£гаіе.осІеіпІ - модель польоту снаряду.149 

8сіру.іп1с§гаіс.0(1сіп1 - модель коливань, що згасають.150 

зсіру.іпіегроіаіе - інтерполяція.152 

8СІру.оріітІ2еТ80ІУе - розв’язування рівнянь.154 

8СІру.оріітІ2е.гооі - розв’язування систем рівнянь.155 

8СІру.орІітІ2е.сигуе_іїі - регресійний аналіз.155 

8СІру.ор{ітІ2е.сигуе_Ш - множинна регресія.158 

8 СІру.оріітІ 2 еТтіпЬоип(і - оптимізація функції однієї змінної з 
границями.160 


6 


































8 С і ру. орі і т і /е. Оті і пЬоипсІ - локальна оптнмізація невідомої 

функції.162 

8 сіру.орІІ ті/с. Гт і п _1 _Ь з_Ь - оптнмізація з границями 

методом Ь-ВР08-В.163 

8СІру.орІіті/с.(1ііїегепІіа1_е\'о1иІіоп - диференціальна еволюція 

.165 

8СІру.орІітІ2е.Ьа8Іп1юрріп§ - комбінований метод глобальної 

оптимізації.166 

8 сіру .8іаі8 - випадкові величини.169 

8 СІру.8ІаІ8 - підгонка кривих і перевірка статистичних гіпотез 

.172 

8 сіру.8іа1:8.кбе - ядрова оцінка густини розподілу.176 

8 СІру.Шраек дискретне перетворення Фур’є.177 

8 СІру.Шраек - обернене дискретне перетворення Фур’є.179 

8 сіру.с1и8іег - кластеризація.181 

рашіа8 - аналіз даних.183 

8 сікй-1еагп - машинне навчання.188 

КеВуогкХ - графи.190 

КеІшогкХ - орієнтовані графи, алгоритми на графах.194 

руВаІаІо^ - логічне програмування в РуЙюп.197 

Зв’язок з інтерпретатором Рго1о§.198 

капгеп - логічне програмування в РуЙюп.199 

руїіюп-сошігаіпі - задачі виконання обмежень.201 

РІЬ (Рі11о\у) - робота з растровою графікою.202 

РуОрепОЬ - прив’язка до ОрепОЬ.203 

ру§1еІ - кросплатформна віконна і мультимедійна бібліотека 

.208 

руІЇюпОСС - прив’язка до геометричного ядра Ореп 

САЗСАБЕ Тес1пюІ0£у.211 

РгееСАО - вільна САПР з РуЙюп АРІ.213 

АЬас|и8/САЕ - моделювання методом скінченних елементів217 

8 утРу - символьна математика.220 

Взаємодія з Маріє.223 


7 




























ОМРуЙюп - інтерфейс ОрепМойеІіса РуЙюп.224 

х1\уі - створення електронних таблиць Ехсеї.227 

ру\уіп32 - інтерфейс до \уіп32 СІЛ АРІ.227 

\уіп32сот.с1іепІ - об’єкти Ехсеї.229 

\¥Іп32сот.с1іепІ - об’єкти Ехсеї з обробкою подій.230 

\уіп32сот.с1іепІ - об'єкти 80ЕГОЗ\ЮКК8.233 

рувегіаі - доступ до послідовного порту.233 

руЕігтаїа - комунікація комп’ютера та Агйиіпо.234 

сопсиггепі.іиіигез - запуск паралельних задач.236 

Иазк - розподілені обчислення на чистій РуЙюп.237 

Оазк.ОізІхіЬиІесІ - розподілені обчислення.239 

Ру(Д4 - фреймворк (Зі в РуЙюп.240 

РуС)ї4 - елементи керування СДОиі.242 

РуСД4 - створення елемента керування.247 

РуРагзіп^ - зручний синтаксичний аналіз.250 

рушогрйу2 - морфологічний аналізатор.253 

ру^тепіз - під світка синтаксису.254 

ру§шепІ8 - підсвітка синтаксису в Ткіпісг.256 

Іхті - простий і швидкий парсинг ХМЕ і НТМЕ.258 

Іхті - Х8ЕТ трансформації.259 

ВоІЙе - легкий ЗУ80І веб-фреймворк.260 

РОЗДІЛ 3. ЗАДАЧІ.263 

ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ.271 


8 


























ВСТУП 


РуїЬоп - це популярна високорівнева мова програмування 
загального призначення з акцентом на продуктивність розробки. 
РуїЬоп працює майже на усіх відомих платформах, є відкритим і 
вільним програмним забезпеченням, виконується шляхом 
інтерпретації байт-коду, підтримує кілька парадигм програмування 
(у тому числі об'єктно-орієнтоване), код програм компактний і 
легко читається (рис. 1). Мові характерні динамічна типізація, повна 
інтроспекція, зручні структури даних (кортежі, списки, словники, 
множини), велика стандартна бібліотека та велика кількість 
сторонніх бібліотек різноманітного призначення. Інтерпретатор 
РуїЬоп має інтерактивний режим роботи, при якому введені з 
клавіатури оператори відразу ж виконуються, а результат 
виводиться на екран. Наприклад: 

>>> а=1 
>>> Ь=2 
>>> а+Ь 
В 

>>> 


Завдяки цим перевагам РуїЬоп широко застосовується 
прикладними програмістами, зокрема інженерами і науковцями. 

Основна мета цього посібника - швидке ознайомлення з 
основними можливостями РуїЬоп для створення прикладного 
програмного забезпечення в галузі науки і техніки. Книга також 
може бути використана як довідник з РуїЬоп і її пакетів. Посібник 
призначено для тих, хто уже володіє основами програмування 
якою-небудь алгоритмічною мовою. Паралельно з посібником автор 
рекомендує використовувати літературу [1-58] для глибшого 
освоєння матеріалу. Початківцям у першу чергу слід ознайомитись 
з книгами [16, 19, 21, 56, 58, 5] для вивчення основ РуїЬоп та її 
стандартної бібліотеки. 


9 




Автор намагався продемонструвати максимум можливостей 
РуїЬоп на мінімальному за обсягом коді, тому більшість прикладів є 
дещо штучними. Приклади програм містять коментарі, що 
надруковані курсивом після символу #. Ці коментарі не 
виконуються інтерпретатором. Код програм і результати їх 
виведення надруковані моноширинним шрифтом так: 


код програми _ 

текст виведення програми в консолі 

Вихідний код усіх прикладів доступний для вільного 
завантаження на §іІЇіиЬ.сот (ЬЦр8://§і(1шЬ.сот/укореу/Ру1:Ьоп-:Гог- 
еп§іпеег8-апсі-8сіеЩІ8І8). Цей код розмічений спеціальним чином і 
містить МагксІо\уп-текст в рядкових РуїЬоп-літералах що 

дозволяє генерувати з коду документи у форматах .Іируісг ІЧоїеЬоок, 
НТМЬ та М8 \Уогс1 2007. Детальніше про це 

ЬПр8://§і(ЬиЬ.сот/укореу/ру2пЬ. 


10 



В прикладах використовується версія РуЛоп 2.7. Ви можете 
завантажити інтерпретатор РуїЬоп 2.7 з офіційного сайту 
(ЬЦр://руіЬоп.ог§), або один зі сторонніх дистрибутивів РуїЬоп 2.7 
(Апасопсіа [ Ьпр://\\'\\'\\'.апасопс1а.сот ], \УіпРуіЬоп 

[Ннр://\\'іпру[Ноп.ігіЙіиЬ.іо], Руйюп(х,у) [ЬЦр://ру(Ьоп-ху.£ЦЬиЬ.іо]), 
які містять велику кількість пакетів. Якщо потрібного пакету немає, 
то його можна установити за допомогою менеджера пакетів, 
наприклад так: 

рір іпзііаіі <назва пакету> 

Для аналізу прикладів та розв’язування задач зручно 
користуватись простим і невимогливим середовищем розробки Руго 
(Ьир://\у\у\¥.ру 20 .ог£), який має підказку коду з інтерактивним 
показом рядка документації. З електронної версії посібника ви 
можете копіювати приклади, які обведені рамкою, прямо в редактор 
коду. Під час копіювання дотримуйтесь правил відступів в РуіЬоп. 
Один відступ складається з чотирьох пробілів, два - з восьми і т.д. 
Для уникнення проблем з кодуванням символів кожна програма 
повинна починатись з рядка: 

# сос!іп§: иіі-р-8 -*- 

Автор буде вдячний читачам за зроблені зауваження і 
побажання, які можна залишити на сайті проекту 
(ЬЦр8://§ііЬиЬ.сот/укореу/РуіЬоп-їог-еп£Іпеег8-апсі-8сіепй8І8). 


11 



РОЗДІЛ 1. МОВА Р¥ТНОN ТА її СТАНДАРТНА БІБЛІОТЕКА 
Найпростіша програма 

ргіпі "Неііо ІлІогІсИ" # вивести на екран "НеНо 
Іліогід!" 

Неііо іліогісі! 


Програма для додавання двох чисел 

Функція іприї: чекає введення РуЛоп-виразу з консолі і 
повертає значення цього виразу. Для введення тільки рядків 
використовуйте функцію гаи/_іприі. 

а = іприі("Введіть перше число: ") # ввести а 
Ь = іприї ("Введіть друге число: ") # ввести Ь 
с=а+Ь # присвоїти с значення виразу а+Ь 
ргіпі с # вивести на екран с 


Введіть перше число: 2 
Введіть друге число: а+1 
5 


Числові типи даних 

До числових типів даних належать: цілі, дійсний, булевий і 
комплексний. В РуїЬоп застосовується динамічна типізація - тип 
змінної визначається під час операції присвоювання. Тип змінної 
можна дізнатись за допомогою функції іуре. 

а=16 # ціле десяткове іпї 
Ь=020 # ціле вісімкове іпї 
с=0х10 # ціле шістнадцяткове іпї 
сІ=є=16І_ # довге ціле іопд 
ргіпі а^Ь^с^сI^е^іуре(е) 
х=5 .71 # дійсне /іоаі 


12 







у=-3.95е+3 # дійсне ^іоаі 
ргіпі: х,у 

і=Тгие # булеве Ьооі 

ргіпі: і 

сп1=1+1] # комплексне сотріех 

ргіпі спі 


16 16 16 16 16 <іуре 
5.71 -3950.0 


Тгие 

( 1 + 1 ]) 


'1оп§'> 


Оператори числових типів 

Приклад показує використання найбільш уживаних операторів 
для числових типів. В складних виразах дотримуйтесь пріоритету 
операторів. Наприклад у виразі 1+х*2 спочатку виконується 
множення, а потім додавання. В наступному списку пріоритет 
операторів зменшується зверху вниз: 

• ; [•••] {•••} • . .' - створення кортежу, списку, словника, 

конвертація рядка 

• з[і] з[і:]] з.аііг Б(...) - індексування, зрізи, атрибути, 
виклик функції 

• +х - х ~х - унарні оператори 

• х **у - степінь 

• х*у х/у х%у - множення, ділення, остача від ділення 

• х+у х-у - додавання, віднімання 

• х<<у х>>у - побітовий зсув 

• х&у - побітове І 

• х Л у - побітове Х(Ж (виключне АБО) 

• х | у - побітове АБО 

• х<у х<=у х>у х>=у х==у х!=у хоу -порівняння 

• X І5 у X І5 ПОІ у - ідентичність 

• X ІП 5 X поі: ІП 5 -членство 


13 






• поі х - булеве заперечення 

• х а псі у - булеве І 

• х ог у -булеве АБО 

• ІатЬсІа аг§з: ехрг - безіменна функція 

а=іп1:("7") # перетворення в ціле 
Ь=1оп§(9.7) # перетворення в довге ціле 
х=-Р1оа1:( "3 .14 м ) # перетворення в дійсне 
сп1=сотр1ех(1,1) # перетворення в комплексне 
сп2=(1+2])/сп1 # ділення комплексних чисел 
т=аЬ5(сп2) # модуль комплексного числа 
і=Ьоо1(2>1) # перетворення в булеве 

у=аЬ5(-1.2) #модуль у=(-1.2). _ аЬз _ () 

рг і пі: а,Ь,х,сп2,сп2. геаі, сп2. іта^ггь і;У 

2 =(-х*у+1)/у**2 # вираз з операторами: унарний мінус, 

множення, додавання, ділення, степінь 

г=9/5 # ділення цілих г=(9). _с/гі/_ (5) 

и=9//5 # цілочисельне ділення 

у=9%5 # остача від ділення 

\л/=сІІутос1 (9, 5) # кортеж 9//5, 9%5 

]=2>1 апсі 1<=0 апсі паЬ(1==1 ог 1 ! =0 ог Раїзе) # 

логічний вираз 

к=гоипсІ(2.91754,2) # заокруглити до 2 знаків після 
коми 

• вивести допомогу по функції: беір(гоипд) 

ргіпі: т., г, и, у, VI, ], к 

ргіпі: еуа1("а+Ь") # значення динамічно побудованого 
виразу 

ехес г"ргіп1: а+Ь" # виконти РуіЬоп-код (див. також 
ехес/ Не) 


7 9 3.14 (1.5+0.5]) 1.5 0.5 1.58113883008 Тгие 1.2 
-1.92222222222 1 1 4 (1, 4) Раізе 2.92 
16 
16 


14 



Оператор умови ІГ 


Інструкція і-р виконує певні команди тоді, коли значення 
логічного виразу рівне Тгие (істина). Інструкція і-р може 
застосовуватись з еіі-р та/або еізе. Якщо значення логічного 
виразу після і-р рівне Раїзе (не істина), то виконується інструкція 
еІІ-Р, або, якщо її немає, виконується еізе. Послідовних інструкцій 
еІІ-Р може бути довільна кількість. 

х = 2 # присвоїти х 2 
і-р х<0: # якщо х<0 то 
у=1 # присвоїти у 1 
рпіпі: "х<0, у=" ,у # вивести на екран 
еіі-р х>1 ог х==0: # інакше, якщо х>0 або х=0 то 
у=2 # присвоїти у 2 
ргіпі: "х>0, у=" ^у # вивести на екран 
еІ5е: # інакше 

у=0 # присвоїти у 0 

рпіпі: "x=0^ у=" ^у # вивести на екран 


х>0, у= 2 


Оператор циклу Гог 

Інструкція -Рог повторює виконання певних команд, для 
кожного елемента послідовності. 

■Рог х іп гап§е(0,11): # для х в діапазоні [0,11) 
ргіпі х**2, # вивести на екран квадрат х 


0 1 4 9 16 25 36 49 64 81 100 

Оператор циклу \тЬі1е 

Інструкція и/РііІе повторює виконання певних команд, поки 
значення логічного виразу рівне Тгие. 


15 




х=0 # присвоїти х 0 

мЬНе х<=10: # поки х менше рівне 10 

ргіпі х**2, # вивести на екран квадрат х 
х=х+1 # збільшити х 


0 1 4 9 16 25 36 49 64 81 100 

Оператори Ьгеак і сопііпие 

Інструкція Ьпеак негайно завершує виконання циклу, а 
інструкція сопііпие негайно переходить до наступної ітерації 
циклу. 

х=0 # присвоїти х 0 
мЬіІе х<=10: # поки х менше рівне 10 
у=х**2 

х+=1 # збільшити х 
і і у >50: # якщо у>50 

Ьгеак # перервати цикл 
еІі-Р 10<у<30: # якщо 10<у<30 

ргіпі: # вивести на екран "*" 

сопіііпие # перейти до наступної ітерації 
ргіпі у ^ # вивести на екран у 


0 1 4 9 * * 36 49 

Послідовність кортеж. Оператори для усіх послідовностей 

Кортеж - це об’єкт-контейнер типу іиріе, ЯКИЙ містить 
незмінну послідовність елементів довільного типу. Нижче показані 
спільні для усіх послідовностей (Шріе, 1І8І, 8ІГ, ипісосіе) оператори. 

а = (1,2,3,4,5) # кортеж 

Ь = "а", 5, 3.07 # кортеж з різнотипними елементами 
х,у=3,5 # використання кортежу в операторі 
присвоювання 

ргіпі з, 1еп(а ), ЬДеп(Ь) # вивести кортежі і їх 


16 







довжини 

# вивести елементи [індекс першого:індекс 
останнього:крок] 
ргіпі а[0],а[-1],а[1:4:2],а[: :2] 
рг і пі: тіп(Ь),тах(Ь) # мінімальне і максимальне 
ргіпі: а+Ь # об'єднання 
ргіпі 2*а # об'єднані 2 копії 
ргіпі "а" іп Ь # чи "а" належить Ь 
■Рог х іп а: # для кожного х у а 
ргіпі х , # вивести х 


(1, 2, З, А, Б) Б ('а'. Б, 3.07) З 
1 5 (2, 4) (1, З, 5) 

3.07 а 

(1, 2, З, А, Б, 'а'. Б, 3.07) 

(1, 2, З, А, Б, 1, 2, 3, 4, 5) 

Тгие 

1 2 3 4 5 


Послідовність рядок 

Рядок - це об’єкт-контейнер типу 5ІГ, який містить незмінну 
послідовність символів. Для створення літерала рядка його потрібно 
взяти в апострофи, лапки або потрійні апострофи чи лапки. 
Кодування символів літерала рядка відповідає кодуванню символів 
файлу програми (тут це ІІТР-8). Кодування символів (А8СІІ, ШТ-8, 
СР1251, СР866 та ін.) - це таблиця, у якій кожен символ кодується 
одним або більшою кількістю байтів. 

5І = " Рядокі " # рядок 

52= '"5ігіп§"2\п 1 # рядок з спецсимволом переводу 

рядка 

53=’ ''Біг 

іп§3''' # рядок з переводом рядка 
54=г"Бігіп§\і4\п" # необроблюваний рядок 
5Б=и"Бігіп§5" # ІІпісоде рядок 


17 








5б=иг"Бігіп§6\п" # ііпісоде необроблюваний рядок 

рг і пі: зі, 52., 53,54., 55., 5бДеп(зб) # вивести рядки і 
довжину рядка з б 

ргіпі 5І+" "*5+5іг(3 . 14)+" "+герг(3.14) # об'єднання 
рядків 

ргіпі: 5 і[2],5і[:2],5і[2:],5і[-2] # зрізи рядка 
ргіпі "я" іп 5І # чи "я" належить зі 
■Рог х іп $1: ра55 # для кожного символу х у зі 
виконати пусту команду 

ргіпі "х= %*. *-р%з"%(5 ,2 ,51 .2935, "тт" ) # форматування 
рядка 

ргіпі "х= %4сІ %о %х"%(16Д6Д6) # форматування рядка 
ргіпі "х= {0} {ипіі}" Догтаі( ’ііує , ипіі='тт') # 
форматування рядка 

ргіпі " Ьеііо " .зігір() # видалити пробіли на 
початку і в кінці 

ргіпі "Ьеііо ілюгісі!" ДіпсІ("11" ,0,4) # знайти 
входження підрядка на проміжку 

ргіпі "Иеііо" .гер1асе("Н"/'Н" Д) # замінити 1 раз "Ь" 
на "Н" 

1зі="а, Ь, с" .зрііі( "," ) # розбити рядок на список 
(розділювач ", ") 

5І= "" # пустий рядок 

ргіпі 5іДоіп(І5і) # об'єднати список в рядок 
ргіпі осі(1бД Ьех(16) # вивести рядкове 
представлення вісімкового і шістнадцяткового числа 
ргіпі огсі ( ' А' ), сИг(65 ), ипісЬг(65) ; ипісосІе( АВС'Диіі- 
8' ) # вивести код символу, символ за кодом, символ 
ііпісоде за кодом, об'єкт в заданому кодуванні 


Рядокі "5ігіп§"2 
Біг 

іп§3 5ігіп§\і4\п 5ігіп§5 5ігіп§б\п 9 
Рядокі 3.14 3.14 
ДхсІІ' Р ядокі ' \хЬа ' 


18 





Тгие 

х= Б1.29тт 
х= 16 20 10 
х= ііує тт 
Ьеііо 
2 

Неііо 

аЬс 

020 0x10 
65 А А АВС 


Юнікод-рядки 

Юнікод-рядок (ипісосіе) - це ПОСЛІДОВНІСТЬ символів Юнікоду. 
Для створення літерала юнікод-рядка перед лапками потрібно 
поставити символ и. Рядки ипісосіе і 8Іг підтримують однакові 
операції. 

5='звичайний рядок' 

115 = 11 ' ЮНІКОД-рЯДОК ' 

ргіпі іуре(з)Д5Іп5іапсе(5; 5іг) # <іуре ’5±г'> Тгие 
рг і пі: іуре(из) Дзіп5іапсе(и5., ипісосіе) # <іуре 

'ипісосіе '> Тгие 

52=и5. епсосІе( ' иі-р-8 ' ) # кодує в звичайний рядок иі^-8 
и$2=5.сіесосіе( ' иіі-8 ' ) # декодує звичайний рядок иі^-8 
в юнікод-рядок 

из2=ипісосіе(5 , 'иі-р-8 ) # або так 
ргіпі іуре(з2) # <±уре 'зіг '> 
ргіпі іуре(и52) # <іуре 'ипісоде'> 

ргіпі Іеп('рядок') # 10 ^ бо кодується иі^-8 (символи 
кодуються 1-6 байтами) 
ргіпі 1еп(и 'рядок' ) # 5 


19 



Юнікод-літерали в Руійоп 2 


В РуїЬоп 2 використовувати юнікод-літерали без застосування 
символу и можна так: 

Ргот _Риіиге_ ітрогі ипісобе_1ііегаІ5 

ргіпі Ііуре( 'текст' ) # <їуре ' ипісоде'>, а не <їуре 

' 5ІГ' > 

ргіпі: іуре(и 'текст' ) # <іуре 'ипісосіе'> 


Послідовність СПИСОК 

Список - це об’єкт-контейнер типу Іізі:, який містить 
послідовність елементів довільного типу. Ця послідовність може 
змінюватися. 


а = [1,2,3,4,5] # список 

Ь=[1.0/х Роп х іп гап§е(1,4) ІР х ! =2 ] # генератор 
списку 

с=1І5і( '5ігіп§") # список з рядка 

сІ=гап§е(5) # список з прогресії 

е=[1, "аЬс'Ц2. 3, (1+1;і),а] # список з різнотипними 

елементами 

ргіпі а ^ 1еп(а ), ЬДеп(Ь) # вивести списки і їх довжини 
ргіпі е[4] # вивести елемент з індексом 4 (список а) 
ргіпі а[0],а[-1],а[1:4:2],а[::2] # вивести елементи 
[індекс першого‘.індекс останнього: крок] 
ргіпі тіп(а),тах(а) # мінімальне і максимальне 
ргіпі а+[6,7] # об'єднання 
ргіпі 2*а # об'єднані 2 копії 
ргіпі 3 іп а # чи 3 належить а 

а[0]=2 # присвоїти значення елементу з індексом 0 
а[::2]=[0,0,0] # непарним елементам присвоїти 0 
сієї а[4] # видалити елемент з індексом 4 
а.аррепсІ(5) # додати в кінець 5 
а.ехіепсЦ [6,7]) # розширити список 


20 






ргіпі: а.соип1:(0) # кількість елементів рівних 0 
рг і пі: а.іпсІех(5) # мінімальний індекс елемента зі 
значенням 5 

а.іп5ег1:(1,9) # вставити в позицію 1 

ргіпі: а.рор(І) # вивести елемент з індексом 1 і 

видалити 

а.пеуегБе() # обернути список 
а.зог1:() # сортувати за зростанням 
■Рог х іп а[:]: # для кожного х у копії а 
ргіпі: х, # вивести х 


[ 1 , 2, З, 4, 5] Б [1.0, 0.3333333333333333] 2 
[1, 2, 3, 4, Б] 

1 5 [2, 4] [1, З, 5] 

1 5 

[1, 2, 3, 4, Б, б, 7] 

[1, 2, 3, 4, Б, 1, 2, 3, 4, 5] 

Тгие 

2 
4 
9 

0 0 2 4 5 6 7 

Словник. Оператори для словників 

Словник (бісі) - це асоціативний масив, який містить 
сукупність пар (ключ, значення). Значеннями можуть бути об’єкти 
будь-якого типу, а ключами - об’єкти, які не змінюються (числа, 
рядки, кортежі). 

сі1={ 1 : "Іванов",2: "Петров",3: "Коваль"} # словник 
62=сііс 1:( [("Іванов",1982), ("Петров",1980), ("Коваль",19 
78)]) # словник 

сІЗ=сІіс1:(х=1.5,у=5. 2,2=3.0) # словник 

сІ2[ "Іванов" ] =1983 # зміна значення за ключем "Іванов" 

сієї сІ2[ "Іванов" ] # видалити елемент за ключем 


21 








ргіпі "Петров" іп 62 # чи є ключ "Петров" у словнику 
62 

■Рог іп 62 . ііегііетз (): ргіпі: к.,у, # цикл за 

елементами 

ргіпі 

■Рог к іп СІ2 Діегкеуз() гразз # цикл за ключами 
■Рог V іп СІ2 ДіегуаІиезО :ра55 # цикл за значеннями 
13=сІ2.ііет5() # список з елементів-пар 
(ключ,значення) 

11=сІ2.кеуз() # список з ключів 
12=сІ2.уа1ие5() # список зі значень 

ргіпі сІ2.§еі( "Петров" ,0) # значення за ключем, якщо 
немає - в 

64=61 .-Рготкеуз ( [1, 2, 3] /'Маїе" ) # новий словник з 
ключів 61 

ргіпі 64 # вивести словник 


Тгие 

Коваль 1978 Петров 1980 
1980 

{1: 'Ма1е', 2: 'Маїе', 3: ’МаІе'} 

Множина 

Множина - це об’єкт-контейнер типу зеі, який містить 
невпорядковану сукупність елементів, які не повторюються. 

з1={1 ,1 , 2 ,3,2 ,Е> ,3 ,1 ,5} # множина 
з2=зеі( [7,7, 8,9,1, 2] ) # множина зі списку 
53=5еі("Ііе11о") # множина з рядка 

ргіпі 5ІДеп(5І)^52Деп(з2) # вивести множини і їх 

довжини 

ргіпі 2 поі іп зі # чи 2 не в множині зі? 

■Рог х іп зі: разз # для кожного в множині виконати 
пусту команду 

зі. асісі( 7 ) # додати елемент 


22 








з1.петоуе(7) # видалити елемент 
5І. сіізсагсі( 7 ) # видалити елемент, якщо він є 
ргіпі зі. рор() # вивести довільний і видалити його 
ргіпі зі.І55иЬзеі(з2) # чи кожен у зі є у з2 (зі <= 
52) 

ргіпі: зі.іззирег5еі(52) # чи кожен у з2 є у зі (зі >= 

52) 

ргіпі: зі.ипіоп(з2) # об'єднання (зі / з2) 
ргіпі зі.іпіегзесііоп(з2) # перетин (зі & з2) 
ргіпі зі.сііііегепсе(52) # різниця (зі ■ 
ргіпі зі.зуттеігіс_с)іііегепсе(з2) # симетрична 

різниця (зі Л з2) 


зеі([1, 2, З, 
Раізе 
1 

Раізе 

Раізе 

зеі([1, 2, З, 
зеі([2]) 
зеі([В, 5]) 
5ЄІ([1, 3, 5, 


Б]) 4 зеі([8, 

5, 1, 8, 9]) 
1, 8, 9]) 


9, 2, 1, 7]) 5 


Функції 

Функція - це частина коду програми (підпрограма), до якого 
можна звернутись з інших місць програми. Визначити функцію 
можна за допомогою інструкції беі. Функція може повертати певне 

значення за допомогою інструкції геіигп. Атрибут _ бос_ 

містить документацію функції. 

бе-р зит(а,Ь=0): # визначити функцію з параметрами а, 

Ь 

"Повертає суму двох чисел" # рядок документації 
с=а+Ь 

геіигп с # функція повертає значення с 


23 








ргіпі 5ііт(2,2), # вивести значення функції (а=2, Ь=2) 
рг і пі: 5ит(а=2, Ь=2) , # або так 

рг і пі: зит(2) # вивести значення функції (а=2, Ь=0) 
рг і пі: зит.сіос # вивести документацію 


4 4 2 

Повертає суму двох чисел 

Функції з довільним числом аргументів 

Наступна функція має один обов’язковий аргумент а, довільну 
кількість неіменованих аргументів *Ь, і довільну кількість 
іменованих аргументів **с. 

Сіе-Р Р(а,*Ь,**с): 

ргіпі: а,Ь,с # тут Ь - кортеж, с - словник 
Р(1,2,3,х=4,у=5) # а=1 Ь=(2, 3) с={ 'у': 5, 'х': 4} 

Р(а=1,Ь=2,с=3,х=4,у=5) # а=1 Ь=() с={'у': 5, 'х': 4, 

'с': З, 'Ь': 2} 


1 (2, 3) {'у': 5, -X і : 4} 

1 () {'у 1 : Б, 1 х’: 4, ’с': 3, ’Ь’: 2} 

ІатЬсІа-функцїї 

Невеликі анонімні функції у вигляді одного виразу можуть 
бути описані за допомогою ключового слова ІатЬсІа. 

■Р = ІатЬсІа х, у: х + у # визначення функції за 
допомогою виразу 

ргіпі: -Р(2,3) # вивести значення функції (х=2,у=3) 


Б 


Рекурсивні функції 

Рекурсивна функція викликає саму себе. Існує обмеження на 
глибину рекурсїї. 


24 







сіе-р Ьіп(п): # рекурсивна функція 

"Повертає список з двійковим поданням числа" 
і-р п == 0: геіигп [] # якщо п == 0, повертає 
пустий список 

псі = сІіутосІ(п, 2) #або п=п//2; д=п%2 
геіигп Ьіп(п) + [сі] # повертає Ьіп(п) + [д] 
ргіпі Ьіп(5) # виклик функції 


[ 1 , 0 , 1 ] 


Замикання 

Замикання (сіомлге) — це функція, яка визначена в тілі іншої 
функції і в якій є посилання на змінні, що оголошені зовні. 

а=0 # глобальна змінна 
сіе-р -Рипс(Ь): # функція 

сіе-ґ -Рп(с): # внутрішня функція (замикання) 

§1оЬа1 а # звертання до глобальної змінної 
а=1 # зміна значення глобальної змінної 
ргіпі: а,Ь,с # вивести а,Ь,с 
ргіпі 'Рипс' 

геіигп -Рп # повернути функцію 
-Р=-Рипс(2) # аргумент Ь=2, виведе: '/ ипс' 

■р(З) # аргумент с=3 ^ виведе: 123 

ргіпі а # 1 - значення глобальної змінної змінилось 


■Рипс 
12 3 
1 


Обробка виняткових ситуацій 

Інструкції ігу і ехсері дозволяють перехоплювати і 
обробляти виняткові ситуації - помилки, що виникають під час 
виконання програми. Якщо помилка виникає в блоці ігу, то 


25 




керування передається тому блоку ехсері:, який відповідає типу 
помилки. 


ітрогі зуз # імпорт модуля зуз 

■Рог х іп - 1 , 0^ "0. 2" , 1е1000: # повторити наступні 
команди для різних значень змінної х 

■ргу: # перехоплювати помилки виконання 

аззегі: х>=0 # якщо х менше 0, генерувати 
АззегїіопЕггог 

у=іп1:(х) # помилка \/аїиеЕггог 
г=1/х # помилка ІегоОі\/І5ІопЕггог 
ехсері: 2 єго0іуі5іопЕггог : # якщо ділення на нуль 
рпіпі: х/'Помилка! Ділення на нуль" 
ехсері:: # якщо інші помилки 

ргіпі х^ зуз. ехс_1:уре # вивести тип помилки 


-1 сіуре 'ехсерііопз.АззегііопЕпгог'> 

0 Помилка! Ділення на нуль 

0.2 сіуре 'ехсерііопз.УаІиеЕппог'> 

іігР <1:уре ' ехсерііопз .Оуєг-РіомЕггог ' > 

Файли 

Файл - це інформаційний об’єкт, який містить послідовність 
байтів і розміщений у файловій системі на носію інформації. Усі 
файли є бінарними, але якщо для файлу застосовується кодування 
символів (А8СІІ, ШТ-8, СР1251 або інше), то його називають 
текстовим. Наприклад файл з кодом РуїЬоп програми (.ру) є 
текстовим. В бінарних файлах кодування символів не 
застосовується. Для роботи з файлом його відкривають функцією 
ореп, яка створює файловий об’єкт, що має методи запису, читання 
і закриття файлу. 

Рі=ореп( "Рііеі.1:х1:", "їді") # відкрити текстовий файл 
для запису 

Рі.іл/гііеС'ІіпеїХп") # записати рядок (' \п ' - символ 


26 






кінця рядка) 

■р 1. сіозе () # закрити файл 

Р2=ореп( "-Рііеі.іхі:" , "а") # відкрити текстовий файл 
для добавлення 

■Р2.1л/^і1;е1іпе5(("^іпе2\п"^"^іпеЗ\п ,, )) # записати 

послідовність рядків 

Р2.сіозе() # закрити файл 

РЗ=ореп( "-Рііеі .їх!", "г+") # відкрити текстовий файл 

для читання і запису 

ргіпі: Р3.геас1() # читати весь файл 

-Р3.зеек(0) # установити позицію на початок файлу 

ргі пі: -РЗ.пеасЛіпе()^-Р3.1:е11() # читати рядок, вивести 

поточну позицію 

ргіпі: -РЗ. геасіїіпез () # читати список рядків до кінця 
-Р3.5еек(0) # установити позицію на початок файлу 
■Рог Ііпе іп -РЗ: # для кожного рядку у файлі 
ра55 # виконати пусту команду 
РЗ.сіозе() # закрити файл 

Р4=ореп( "Рііеі.РхР " , "гЬ") # відкрити бінарний файл 
для читання 

# спробуйте також відкрити цей файл як текстовий "г" 
Р4.5еек(7) # установити позицію після байта 7 
іл/Ніїе Тгие: # читає файл побайтово 
Ь=Р4.геасі(1) # читати байт 

і-р поі: Ь: Ьгеак # перервати цикл, якщо байтів 
немає 

ргіпі: огсІ(Ь), # числове подання Юнікод-символу 
#зверніть увагу на два байти (13 їв), які в текстових 
файлах Ілііпдомз використовуються для позначення кінця 
рядка 

-Р4.сі05є() # закрити файл 


27 





Ипеї 

Ипе2 

І_іпеЗ 

І_іпе1 

7 

[ 1 І_іпе2\п ', ' І_іпеЗ\п 1 ] 

76 105 110 101 50 13 10 76 105 110 101 51 13 10 

Модулі 

Модулем є будь-який файл з вихідним кодом РуіЬоп. Команда 
ітрогі імпортує модуль в програму, тобто код модуля виконується 
в окремому просторі імен і створюється об’єкт модуля, який містить 
об’єкти з цього простору імен. Команда ігот працює аналогічно, 
але імпортує тільки визначені імена. Пакети містять кілька модулів. 
Щоб створити пакет, створіть папку з його іменем і розмістіть в ній 

файл _іпіі_.ру. Він виконується під час імпорту пакета. Для 

прикладу створіть нову папку проекту с:\1. В ній створіть файли 
таіп.ру, тосіиіеі.ру та папку раска§е1. В папці раска§е1 

створіть файли _іпії:_. ру, тосіиіеі.ру, тосІи1е2.ру. 

Виконайте модуль таіп.ру. 

Файл с:\1\таіп.ру: 

ітрогі зуз # імпортує модуль (і тільки 1 раз) 
ітрогі тосіиіеі аз т # імпортувати модуль і змінити 
його ім‘я на т 

-Ргот раска§е1 ітрогі * # імпортувати з пакету все 
#або 

#^гот раскадеі.тодиіеі ітрогі * # імпортувати з 
модуля все 

#^гот раскаде1.тодиіе2 ітрогі * # імпортувати з 
модуля все 

і-Р _ _пате == ' таіп 1 :# якщо модуль виконується , 

а не імпортується 


28 





ргіпі _пате_ , _іііе_ # ім'я і файл модуля 

#ргіпї зуз.раїб # шляхи пошуку модулів 
зуз. раіН. аррепсІ( "с: \5отеРо1сІег" ) # додати шлях 
пошуку модулів 

ргіпі: т._сіос_ # рядок документації модуля 

ргіпі т._сіісЬ_.кеуз() # список імен 

т.а= 1 а_' 

т.-Р() # виведе 'а_ ' 

ргіпі а,Ь,с 

геіоасі(т) # повторно завантажити модуль 
ргіпі т.а # виведе 'а' 


тосіиіеі С:\1\тосІи1е1. рус 

раска§е1 С:\1\раска§е1\_іпіі_.рус 

раска§е1. тосіиіеі С: \1\раска§е1\тосІи1е1. рус 
раска§е1. тосіи1е2 С: \1\раска§е1\тосІи1е2. рус 
а 
Ь 

_таіп_ С:\1\таіп.ру 

тосіиіеі сіос 

['а', " -Р", '_Ьиііііпз_ ', ' _іііе_ ', ' _раска§е_ ', 

' _пате_ ', ' _сіос_' ] 

а_ 

а Ь с 

тосіиіеі С:\1\тосІи1е1. рус 
а 

Файл с:\1\тосІіі1е1.ру: 

''"тодиіеі бос''' # рядок документації модуля 

ргіпі _ пате_ , _ іііе_ 

а= 'а' # атрибут модуля 
сіе-р і(): # атрибут модуля 

ргіпі а 


29 






Файл с:\1\раска§е1\_іші_.ру: 


# цей файл виконується під час імпорту пакета 

рпіпі _пате_ , _іііе_ 

■Рпот тосіиіеі ітрогі * 

■Рпот тосІи1е2 ітропі: * 


Файл с:\1\раска§е1\тосіи1е1.ру: 

ргіпі _ пате_ , _ іііе_ 

а= 'а' # атрибут модуля 

■Ргот тосІи1е2 ітропі Ь # з модуля копіювати Ь 
# зверніть увагу на порядок інструкцій і будьте 
уважні з рекурсивним імпортом 

рпіпі Ь 


Файл с:\1\раска§е1\тоскі1е2.ру: 

рпіпі _пате_ , _ іііе_ 

Ь= 'Ь' # атрибут модуля 
с= 'с' # атрибут модуля 

сЛ= ' сі' # не буде імпортуватись інструкцією / гот * 
_е='_е' # не буде імпортуватись інструкцією / гот * 
-Рпот тосіиіеі ітропі * # зверніть увагу на порядок 
інструкцій 

рпіпі а 

_а11_ =[Ь,с] # список імен, які імпортуються 

інструкцією /гот * 


Математичні функції 

Стандартний модуль таїЬ містить математичні функції і 
константи. Наприклад, якщо модуль імпортується так: ітропі 
таіН, то функції потрібно викликати так: таіЬ. зіп(х). 


ЗО 





-Ргот таІіИ ітрогі: * # імпортувати усе з модуля таіЬ 

х,У=1,1 

асоз(х) # арккосинус х 
азіп(х) # арксинус х 
а1:ап(х) # арктангенс х 

а1:ап2(у;Х) # аіап(у/х) 

сеіі(х) # найменше ціле, більше або рівне х 

соз(х) # косинус х 

созИ(х) # гіперболічний косинус х 

е # константа е 

ехр(х) # експонента (е**х) 

■РаЬ$(х) # абсолютне значення х 

-Ріоог(х) # найбільше ціле, менше або рівне х 

■Ртосі(х^у) # остача від ділення х на у 

■Ргехр(х) # мантиса і порядок х як пара (т, і), де т - 

число з плаваючою комою, а і - ціле, таке, що х = т * 

2.**і. Якщо х=в, то повертає (0,0), інакше 0.5 <= 

аЬз(т) < 1.0 

Ьуроіі(х^у) # 5<7 гі(х*х + у*у) 

Ісіехр(х^у) # х * (2**у) 

1о§(х) # натуральний логарифм х 

1о§10(х) # десятковий логарифм х 

тосі-р(х) # пара (у,р) - ціла та дробова частина х. 

Обидві частини мають знак х 

рі # константа пі 

ро\л/(х^у) # х в степені у (або х**у) 

5Іп(х) # синус х 

5ІпЬ(х) # гіперболічний синус х 

5Яп1:(х) # корінь квадратний від х 

1:ап(х) # тангенс х 

1:апЬ(х) # гіперболічний тангенс х 


0.7615941559557649 


31 



Вбудовані функції для роботи з послідовностями 

Для полегшення роботи з послідовностями існують вбудовані 
функції: 

• ііііег - фільтрує послідовність за допомогою заданої 
функції; 

• тар - застосовує функцію для кожного елемента; 

• гесіисе - застосовує до елементів функцію двох аргументів 
кумулятивно зліва направо; 

• гір - об’єднує послідовності в список кортежів; 

• епитегаіе - генерує пронумеровану послідовність; 

• 50ГІЄСІ - сортує послідовність. 

а=[1,2,3,4,5] # список 

сІе-Р -Рпі(х): геіигп х!=3 # функція повертає істину, 
якщо х не З 

ргіпі -Рі11:ег(-Рп1^а) # відфільтрований функцією /пі 
список 

#ргіпі ф : іііег( ІатЬда х:х!=3,а) # або так 

#ргіпі [х /ог х іп а і/ х!=3] # або так 

сІе-Р -Рп2(х): геіигп х**2 # функція повертає квадрат 

числа 

ргіпі: тар(-Рп2,а) # застосовує £п2 до кожного елемента 
сІе-Р іпЗ(х,у): геіигп х+у # функція повертає суму двох 
чисел 

ргіпі: тар(іпЗ,а, [1,2,3,4,5]) # сума списків 
#ргіпі тар(іатЬда х,у:х+у, а, [1,2, 3,4,5]) # або так 
#ргіпі [х+у /і ог х,у іп гір(а, [1,2,3,4,5] ) ] # або так 
ргіпі гесІисе^пЗ, а) # підрахувати (((1+2)+3)+4)+5 
#ргіпі гедисе(ІатЬда х, у: х + у, а) # або так 
ргіпі 2 Ір( [1,2,3],[4,5,6]) # об'єднати списки 
ргіпі [і -Рог і іп епитегаіе( аЬс")] # пронумерований 
список 


32 





ргіпі 50 Гіесі( [(1,2), (2,1), (3,3)], кеу=1атЬсІа х: х[1]) 

# сортувати за елементами з індексом 1 


[1, 2, 4, 5] 

[1, 4, 9, 16, 25] 

[2, 4, 6, 8, 10] 

15 

[(1, 4), (2, 5), (3, 6)] 

[(0, 'а'), (1, * 1 Ь 1 ), (2, ’с')] 

[(2, 1), (1, 2), (З, 3)] 

Генератори 

Генератор створюється функцією, яка використовує інструкцію 
уіеісі. Застосовуються для генерування послідовностей. Виклик 
метода пехі генератора виконує цю функцію, поки не досягнуто 
наступної інструкції уіеісі, повертає значення після інструкції 
уіеісі і зупиняє виконання функції. Наступний виклик метода пехі 
продовжує виконання функції з наступної за уіеісі інструкції. 

сіе-р §епегаіог(п): # функція генератора (генерує 
послідовність) 

иііііе п< 3 : 

уіеісі п # генерувати значення п 
п+=1 

§епОЬ]=§епегаіог(0) # створити об'єкт генератора , 
який має можливість ітерації (є ітератором) 

ргіпі: §епОЬ] . пехі(), §епОЬ].пехі(), ^епОЬ].пехі() # 0 

1 2 

#ргіпї депОЬ].пехї() # помилка: Зїоріїегаїіоп 

■Рог х іп §епегаіог(0): # або так 
ргіпі х, # виведе: 012 

ргіпі 

сіе-р §епегаіог2(п): # функція генератора з кількома 
інструкціями уіеід 

мііііє п<3: 


33 








уіеісі п # генерувати значення п 
уіеісі п # генерувати значення п 
п+=1 

■Рог х іп §епега1юг2(0): 

ргіпі х, # виведе: 001122 


0 12 
0 12 

0 0 112 2 


Співпрограми 

Співпрогама - це функція генератора, яка містить вираз 
(уіеісі). Метод зєпсі об’єкта співпрограми передає їй дані, які 
повертаються виразом (уіеісі). 

сіе-р согои1:іпе(): # співпрограма обробляє 
послідовність вхідних даних 

иііііе Тгие: 

х=(уіе1сІ) # отримати дані через вепд() 
уіеісі 2*х # генерувати значення 2*х 
сопОЬ]=согои1;іпе() # створити об'єкт генератора 
■Рог х іп [1,2,3]: # виведе: 2 4 6 

согОЬ] . пех1:() # переміститись до першої 
інструкції (уіеід) 

ргіпі: сопОЬ]. зепсі(х), # передати дані 
співпрограмі через вираз (уіеід), отримати значення 
після другої інструкції уіеід 
согОЬ].с1озе() # завершити роботу з согОЬ^ 


2 4 6 


Ітератори 

Ітератор - це об’єкт, який призначений для обходу елементів 
певного контейнера. Ітератори використовуються в інструкції -Рог. 
Ітератор реалізує метод пехі:, який повертає наступний елемент 

34 






контейнера, або викликає виняткову ситуацію Біорііепаііоп, 
якщо елементів більше немає. 


і±=і1:ег([1, 2, 3]) # ітератор 

Роп і іп іі: рпіпі і, # вивести 12 3 

рпіпі 

сіе-р -Р(1= [ ]): # функція 

І.аррепб(І) # додати в список 1 
пеіипп 1 # повертає список 
іі=ііеп(Р,[1,1,1]) # ітератор, який викликає / поки 
нею не буде повернуто [1,1,1] 

■Рог і іп іі: рпіпі і. 


12 3 

[ 1 ] [ 1 , 1 ] 


Об’єкти 

РуїЬоп володіє потужними об’єктно-орієнтованими можливостями. 
Наприклад, усі змінні, функції і класи є об’єктам і володіють 
атрибутами і методами. 

а=1 # створити змінну (об'єкт класу іпі) і присвоїти 
їй 1 

рпіпі а._с1а55_ # атрибут _ (клас об'єкта) 

рпіпі а._сіазз_._ пате_ # тип також є об'єктом і 

має атрибут _ пате _ (ім'я) 

Ь=а. _асісі_ (2) # метод _ адд _ повертає суму а+2 

Ь=а+2 # або так 

х=а. _-Ріоаі_ () # метод повертає дійсне число 

х=£Іоаі(а) 

рпіпі а. _зіп_ () # метод повертає рядок зїг(а) 


сіуре ' іпі'> 

іпі 

1 


35 




Класи 


Об’єктно-орієнтоване програмування (ООП) основане на 
використанні об’єктів, які є абстрактними моделями реальних 
об’єктів. Об’єкти створюються за допомогою спеціальних типів 
даних - класів. Кожен клас описує множину об’єктів певного типу. 
Основними принципами ООП є інкапсуляція, успадкування і 
поліморфізм. Інкапсуляція - об’єднання даних (атрибутів) і функцій 
їх опрацювання (методів) в класі. Наприклад, в класі А об’єднано 
атрибут а і метод Н Ідентифікатор зеїі використовується в класах 
як посилання на об’єкт цього класу. Методи об’єктів повинні мати 
перший аргумент 5еИ\ 

сіазз А: # визначення класу А 
а=5 # атрибут-дане а 
сіе-р -Р(5е1-Р): # атрибут-метод / 

геіигп 5ЄІ-Р.а**2 # повертає квадрат а 
оЬ]=А() # створення об'єкта (екземпляра) об] класу А 
оЬ].а=2 # зміна атрибута-даного а 
ргіпі оЬ].-Р() # виклик методу / 


4 


Клас з конструктором 

Конструктор - це спеціальний метод, який має назву_іпіі:_ 

і викликається під час створення об’єкта. Часто використовується 
для ініціалізації атрибутів-даних об’єкта. В прикладі також 
показано можливість визначення методу поза класом. 

сІе-Р ^(зеї-р^х^) : # визначення методу поза класом 
зе1-р.а=а # присвоїти атрибуту-даному значення 
аргументу а 

ргіпі: 5ЄІ-Р.-Р(х) # виклик методу / 
сіазз А: # визначення класу А 

"Клас А" # рядок документації 
а=0 # атрибут-дане 


36 






сіе-р_ іпіі:_ (зеї-р^а): # конструктор 

зе1-р.а=а # присвоїти атрибуту-даному значення 
аргументу а 

сіе-р ^(зеїідх): # атрибут-метод / 

геіигп 5е1-р.а**х # повертає а в степені х 
-Р2=-Р2 # атрибут-метод ^2, визначений поза класом 
оЬ]=А(3) # створення об'єкта обу класу А, виклик 
конструктора (а=3) 
оЬ].а=2 # зміна атрибута-даного а 
ргіпі: оЬ].-( : (2) # виклик методу / 

ргіпі: оЬ] ._сіос_ # вивести рядок документації 

ро\л/=оЬ].-Р # об ' єкт-метод об 

ргіпі: ро\л/(3) # вивести значення ром(З) 

оЬ].-Р2(5,2) # виклик методу /2 


4 

Клас А 
8 

25 


Успадкування і поліморфізм 

Успадкування - це можливість створення похідних класів 
шляхом успадкування ними членів базового класу. Наприклад, 
атрибут а класу В успадкований від класу А. Поліморфізм - 
здатність методів з однаковою специфікацією мати різну 
реалізацію. Наприклад, функції і класів А і В мають одну назву, але 
різну реалізацію. 

сіазз А(оЬ]'ес1:): # визначення класу А, успадкованого 
від об^есі 

а=0 # атрибут-дане 

сіе-р _ іпіі_ (зе1-Р,а): # конструктор 

зе1-р.а=а # присвоїти атрибуту значення 
аргументу а 

сіе-р І(5е1і,х): # атрибут-метод / 


37 








геіигп зеІЕ.а+х # повертає а+х 
сіе-р -Р2(5е1-Р): # атрибут-метод /2 
геіигп зеІЕ.а+2 # повертає а+2 
сіазз В(А): # визначення класу В успадкованого від А 
Ь=0 # атрибут-дане 

сіе-р _іпіі_ (5ЄІ-Р,а,Ь): # конструктор 

А._ іпіі:_ (зеї-р^а) # виклик конструктора 

базового класу 

#зирег(В, зеІ£) . _ іпіі _ (а) # або так 

зе1-Р.Ь=Ь #присвогти атрибуту значення 
аргументу Ь 

сіе-р -Р(5ЄІ-Р,х): # атрибут-метод / 
геіигп 5е1"Р . Ь+х # повертає Ь+х 
оЬ]=В(1,2) # створення об'єкта оЬз класу В, виклик 
конструктора (а=1^ Ь=2) 

рг і пі: оЬ].а, оЬ].Ь # вивести значення атрибутів 
рг і пі: оЬ].-Р(2) # виклик методу описаного в класі В 
рг і пі: А.Е(оЬ],2) # виклик методу описаного в класі 
А 

ргіпі: оЬ].-Р2() # виклик методу /2 

сієї оЬ] # знищити об'єкт 

#ргіпі оЬз.а # помилка! Об'єкта не існує 


1 2 
4 
З 
З 


Атрибути класу і атрибути екземпляра 

Важливо розрізняти атрибути класу і атрибути об’єкта цього 
класу. Екземпляр успадковує значення атрибутів класу. Для 

перегляду атрибутів застосовуйте атрибут_бісі_, який містить 

словник з атрибутами об’єкта, і функцію біг, яка повертає список 
атрибутів об’єкта. 


38 





сіазз А(): # клас А 

а=0 # атрибут класу 
сіазз В(А): # клас В 
Ь=0 # атрибут класу 
А.а=1 # зміна значення атрибута класу 
А.х=2 # створення нового атрибута класу та зміна його 
значення 

рг і пі: А._сіісі_ # {'а': 1 } ’х': 2 } '_ тосіиіе _': 

' таіп ' бос Л/опе } 

оЬ]=А() # створити екземпляр класу А 

ргіпі оЬ]. а # 1 
ргіпі: оЬ] .х # 2 

A. а=3 # зміна значення атрибута класу 
оЬ].а=4 # зміна значення атрибута екземпляра 

ргіпі: А._сіісі:_ # {'а': З, 'х‘: 2 } '_ тосіиіе _ 

' таіп ' бос Мопе} 

ргіпі оЬ] ._сіісі:_ # {'а': 4} 

ргіпі В._сіісі_ # {' _ тобиіе _'_ таіп _ ‘Ь‘: 0, 

'_ бос _Л/опе| 

ргіпі сііг(В) # [ '_ бос _ ' _ тобиіе _ 'а', ’Ь', 

'х'] 

ргіпі В.а # З 

B. а=5 # зміна значення атрибута класу 

ргіпі В.а # 5 
ргіпі А.а # З 


{'а': 1^ ’х': 2, '_тосіиіе_'_таіп_ ' _сіос_' 

Мопе} 

1 

2 

{'а': 3, ’х': 2, '__тосIи1е_ , : '_таіп_' :1 '_сіос_' 

ІМопе} 

{'а': 4} 

{' _тосіиіе_'_таіп_' Ь' : 0, ' _сіос_ІЧопе} 

[ , _сIос_^ '_тосіиіе_' ^ ’а’, ’Ь', ' х 1 ] 


39 



з 

5 

З 


Статичні методи та методи класу 

Статичний метод - це функція, яка визначена в класі, але не 
належить класу чи екземпляру. Метод класу - це метод, який 
належить класу, а не екземпляру. Метод класу має перший аргумент 
СІ5 (клас), а не зеї-р (екземпляр). Статичні методи і методи класу 
визначаються за допомогою декораторів @5І:а"1:істе"1:ІдосІ і 
(ЗсІаззтеІіРіосІ. 

сіазз А: # визначення класу А 
а=0 # атрибут класу 

сіе-р І=(5е1-Р, х): # метод екземпляра 
геіигп зеї-р.а+х 

(Ззіаііістеїіі'іосі # декоратор 
сіе-р -Р2(х): # статичний метод 

геіигп 1+х 

@с1а5зте1:ЬосІ # декоратор 
сіе-р "РЗ(сіз^ х): # метод класу 
геїигп сіз.а+х 

оЬ]'=А() # створити об'єкт (екземпляр) 
оЬ].а=2 # атрибут екземпляра (не класу!) 
ргіїгЬ оЬ].-Р(1) # виклик методу екземпляра 
ргіпі: А.-р(оЬ], 1) # або 
ргіпі: А.-Р2(1) # виклик статичного методу 
ргіпі: А.-РЗ(І) # виклик методу класу 


З 

З 

2 

1 


40 



Властивості 


Властивість - це атрибут, який володіє методами читання, 
запису і знищення значення. Під час присвоювання властивості 
значення викликається метод запису, а під час отримання значення 
властивості - метод читання. Властивості можна створювати в 
класах, які успадковані від оЬ]ЄСі:, за допомогою функції 
ргорегіу або за допомогою декоратора @рпорег1:у. 

сіазз А(оЬ]ес1:): # клас А успадкований від оЬ^есі 

_ х=0 # приватний атрибут _х 

сіе-р §е1:х(5ЄІ-Р): геїигп зеї-р. _х # метод читання 

сіе-р зе1:х(5е1-Р, х): # метод запису 
і-р х>0: # якщо х>0 

зеї-р. _х = х # присвоїти х 

еізе: зеї-Р. _ х=0 # інакше присвоїти 0 

х = ргорегїу^еїх, зеїх, ІМопе, "Ргорегіу х") # 
властивість х з методами читання, запису і рядком 
документації 

а=А() # створити об'єкт класу А 

а.х=-2 # присвоїти властивості х значення 

ргіпі; а.х # вивести значення властивості х 


0 


Перевантаження операторів 

Перевантаження (перевнзначення) операторів - це можливість 
зміни функціонування стандартних операторів (+ , - , ==, () та ін.) 
для об’єктів користувача. Для цього в класах цих об’єктів 

створюються реалізації відповідних методів (_асі б_, _зиЬ_, 

_ер_,_саіі_та ін.) 

сіазз А(оЬ]ЄСІ:): # клас А 

х=0 # атрибут-дане х 

бе-Р _іпії:_ (зе1-Р;Х=0): # конструктор 

зеї-Р. х=х 


41 






сіе-р _ асісі_(5ЄІ-Р, оЬ]): # метод перевантажує 

оператор + 

геіигп А(бє1-Р.х+оЬ] .х) # повертає об'єкт 

класу А 

сіе-р _ея_(5ЄІ-Р, оЬ□): # метод перевантажує 

оператор == 

геіигп 5е1-Р.х==оЬ] .х # повертає значення 
логічного виразу 

сіе-р _ саіі _ (бє11Дх=0): # метод перевантажує 

оператор () 

геїигп А(х) # повертає об'єкт класу А 

сіе-р _Біг _(бєі-Р): # метод повертає рядкове 

відображення об'єкта 

геїигп "%5 "%бє1-Р.х 

а=А(2); Ь=А(2) # створити об'єкти а і Ь класу А 
с=а+Ь # виклик перевантаженого оператора + 
ргіпі: 1:уре(с) # тип об'єкта с 

ргіпі; а==Ь # виклик перевантаженого оператора == 
ргіпі: а(3)+Ь(2) # виклик перевантажених операторів () 
і + 

ргіпі: с # виклик методу зіг 


<с1а55 '_таіп_ .А’> 

Тгие 

5 

4 


Контейнери 

Контейнер - це структура даних, яка зберігає інші об’єкти в 
організованому вигляді. Як правило клас контейнера містить 

методи _ііег_, пехі._деіііет_. Приклад показує створення 

класу контейнера Сопіаіпег і його використання. Див. також 
модуль соіієсііопб. 


42 





с1а55 СогтІ:аіпег(оЬ]ес1:): # клас контейнера, 
успадкований від оЬ^есі 

сіе-р _ іпіі:_(зеї-Р, І5Ї): # конструктор 

зеї-Р. І5І:=І5І: # атрибут-дане список 
зеї-р. сигпеп1:=-1 # поточний індекс 

сіе-р _ іііег_ ( зеї-р) : # метод повертає ітератор 

геіигп зеї-р 

сіе-р пех1:( зеї-р) : # повертає наступний елемент 
контейнера 

# якщо індекс наступного елемента менший 
довжини контейнера 

і-р зеї-р. сиггеп1:+і<1еп(5е1-Р.Із!): 

зеї-р. сиггеп1:=5ЄІ-р.сиггепі+І # збільшити 
індекс поточного 

геіигп зеї-р . 1з1:[ зеї-Р. сиггепі:] # повернути 

поточний 

еізе: # інакше 

гаізе БІорІ-рега-ріоп # генерувати 
Зіорііегаііоп 

сіе-р _§е1:і-|:ет_(зеї-р, і): # метод повертає елемент 

за індексом 'і' 

геіигп зеї-р. І5І:[і] 

с=Соп1:аіпег( [1, 2,3,4, 5]) # створити об'єкт контейнера 
■Рог і іп с: # для кожного елемента в контейнері 
ргіпі: і, # вивести його 

рг і пі: 

ргіпі: с[ 0 ] # вивести перший елемент (або сЛ5і[0]) 
іі:=іі:ег(с) # створити об'єкт ітератор (або так: 
с. _ ііег _ () ) 

с. сиггеп1:=0 # установити поточний індекс 

ргіпі: іі:.пехі:(),іі:.пехі:(),с[3] # вивести два наступні 

та четвертий 


43 



1 2 3 4 5 
1 

2 3 4 


Менеджери контексту і інструкція №ІЇЬ 

Менеджер контексту - це об’єкт, який визначає контекст 
(середовище) виконання інструкцій всередині блоку (л/ІІРі. Містить 

методи_ епіег _та_ ехіі _, які автоматично викликаються на 

початку і вкінці блоку и/ііЬ. Часто використовується під час роботи 
з файлами. Приклад показує створення і використання класу 
менеджера контексту. 

»ліі1:ід ореп(_ -Рііе_ ,'г ) аз -Р: # закриє файл 

автоматично 

ргіпі -Р.геасІ(І) 

сіазз А(оЬ]'есі): # клас реалізує власний спосіб 
керування контекстом 

сіе-р іпіі (зеї-Р, а): 

зеї-р. а=а 

сіе-р _епіег_(зеї-р): # викликається під час входу 

в 'міііі' 

ргіпі 'іл/ііИ епіег’ 
геіигп зеї-Р # оЬ^=зє 

сіе-р ехії (зеіі^іуре^уаІие^іЬ): # викликається 

під час виходу з 'ілііііі' 

ргіпі ' \л/ІіЬ ехіі' 
геіигп Раізе 

іл/ііИ А(1) аз оЬ]: # тут викликається _ епіег_ 

ргіпі оЬ]. а 

# тут викликається _ ехіі _ 


# 

и/ііЬ епіег 


44 



1 

\л/і1:И ехіі 


Метакласи 


Метакласи - це об’єкти, які створюють класи. Відомим 
метакласом є функція "Ьуре. Метакласи використовуються для 
створення класів на етапі виконання. Нижче показані різні способи 
використання метакласів. 

сІе-Р с1з_-Рас1югу(а, -Рп) : # функція створює новий клас з 
атрибутами ' а', '//і' 

сіагз С(оЬ]ес1;) : ра55 # пустий клас, успадкований 
від оЬ^есі 

зеіа1:1:г(С, а ,а) # установити атрибут а 

зе-Ьа-Ь-Ьг ( С-Рп. _пате_ , -Рп) # установити атрибут 

Уп' 

геіигп С # повернути клас 

сіе-р теїііпосії ( з еі-р ): # метод класу 

ргіпі зеї-р.а # вивести значення атрибута 'а' 

Сіаззі = с1з_-Рас1:огу(1,теіііобі) # створити клас 
Сіаззі 

оЬ]1 = С1азз1() # створити об'єкт оЬ^І 
оЬ]1.те1:ЬосІ1() # викликати метод теіііоді 

#створити клас за допомогою метакласу буре 

С1азз2 = іуре( С1азз2\, (оЬ^есІ:,)., { 1 а ’ : 2, теіЬобІ' : 
теіРюбІ}) 

оЬ]2=С1азз2( ) # створити об'єкт оЬ^2 
оЬ]2.те1:ИосІ1() # викликати метод теібоді 

сіагз Му_Туре(1;уре) : # створити метаклас ^ який 
успадковує буре 

СІе-Р _ _пе\л/_ (сіз^ пате; Ьазез., бісі:): # метод 

створення класу 

геіигп іуре. _пеи/_ (сіз., пате., Ьазез, бісі) # 


45 





виклик _ пем _ базового класу 

сіе-р _ іпії:_ (сІз л пате^ Ьазез., сіісі:): # метод 

ініціалізації класу 

геіигп іуре._ іпії:_ (сіз., пате., Ьазез., сіісі:) 

# виклик _ іпії _ базового класу 

# створити клас за допомогою метакласу 

СІаззЗ = Му_Туре( СІаззЗ , (об^есі^); 

{ ' а ' : 3, ' теіИосІІ' : теіЬосЛ}) 
оЬ]3=С1а553() # створити об'єкт оЬ^З 
оЬ]3.те1:ІіосІ1() # викликати метод теїїіосії 


1 

2 

З 


Декоратори 

Декоратор - це функція-обгортка, яка отримує і повертає іншу 
функцію, метод чи клас. Використовуються для розширення їх 
можливостей. 


сІе'Р сіесогаііог(-рп): # функція-обгортка, яка отримує і 
повертає /п 

ргіпі 'у= 1 , # додані нові можливості 
геіигп -Рп # повертає функцію /п 
сІе-Р -Рипс1:іоп(х): # функція, яка обгортається 

геіигп х*х 

1юпсііоп=сіесога1:ог (-Рипсііоп) # обгорнути функцію 
ргіпі -Рипс1:іоп(2) # виклик обгорнутої функції 

# те саме, але з застосуванням декоратора @десогаїог 
@сІесопа1:ог 

сІе-Р -Рипс1:іоп(х): # функція, яка обгортається 

геіигп х*х 

ргіпі -Рипс1:іоп(2) # виклик обгорнутої функції 


46 






У= 4 
у= 4 


Декоратори з аргументом 

Декоратор може мати довільні аргументи. В прикладі 
декоратор має аргумент аг§, значення якого виводиться перед 
викликом функції, що обгортається. 

сІе-Р сіесогаіог (аг§): # функція отримує аргумент і 
повертає внутрішню функцію / 

сіе-р -Р(-Рп): # внутрішня функція-обгортка 
рпіпі аг§^ # додані нові можливості 
геіигп -Рп # повертає функцію //і 
геіигп -Р 

сІе-Р -РипсРіопСх): # функція, яка обгортається 

геїигп х*х 

1:етр=сІесога'1;ог( ' у=' ) # отримати аргумент і повернути 
функцію / 

-Рипс1:іоп=1;етр(-Рипс1:іоп) # обгорнути функцію 
ргіпі: -Рипс1:іоп(2) # виклик обгорнутої функції 

# те саме, але з застосуванням декоратора @десогаїог 
з аргументом 
@сіесопа1:ог( ’у=' ) 

сІе-Р ■Рипс‘1;іоп(х): # функція, яка обгортається 

геїигп х*х 

ргіпі: -Рипс1:іоп(2) # виклик обгорнутої функції 


у= 4 
у= 4 


Декоратори класу 

За тим самим принципом можна обгортати класи. Приклад 
показує як за допомогою декоратора класу автоматично змінювати 
значення його атрибута_ пате_. 

47 



сіе-р бесогаіог(аг§) : # функція отримує аргумент і 
повертає внутрішню функцію / 

беР -Р(сІ5): # внутрішня функція-обгортка отримує 
і повертає клас 

сіз. _пате_ =ап§ # змінити значення атрибута 

класу 

геіигп сіз # повертає клас 

геіигп і 

# застосування декоратора класу з аргументом 
@бесогаіог( 'Мій клас ) 
сіазз А(оЬ]ЄСі): # клас 
а=1 

ргіпі А._ пате_ 


Мій клас 


Інтроспекція 

Інтроспекція в РуїЬоп - це можливість отримати всю 
інформацію про структуру будь-якого об’єкта під час виконання. 
Найбільш відомим засобом для інтроспекції в РуїЬоп є функція біг, 
яка повертає список імен атрибутів переданого їй об’єкта. Функція 

іуре або атрибут _сіазз_ дозволяють отримати тип об’єкта. 

Функція уагБ або атрибут_бісі_дозволяють отримати словник 

з парами атрибут:значення об’єкта. Функції Ьазаііг, §еіаііг і 
зеіаііг дозволяють відповідно перевірити наявність у об’єкта 
заданого атрибута, повернути його і змінити значення. Функція 
І55иЬс1а55 дає змогу визначити чи успадковується один клас від 

іншого, а метод _5иЬс1а55Є5_повертає список підкласів. 

Кортеж базових класів та їх ієрархію можна отримати за допомогою 
атрибутів_Ьазез_і_тго_. 

сіазз А(оЬ]'есі): # успадкований від оЬ^есі клас А 
' ' 'Клас А' '' # рядок документації 

бе-Р _ іпіі_ (зе1-Р,а): # конструктор 

5е1і.а=а # атрибут а 


48 






сіе-р і(зеі-р): # метод / 

'''Повертає веі^.а''' # рядок документації 

геіигп зеї-Р.а 

с1а55 В(А): # успадкований від А клас В 
' ' 'Клас В''' # рядок документації 

сіе-р _ іпіі_ (зе1-Р,а,Ь): # конструктор 

зирег(В; зеїі) ._ іпіі_ (а) # виклик 

конструктора базового класу 
зеї-Р. Ь=Ь # атрибут Ь 
сіе-р і(зеі-р): # метод / 

'''Повертає суму зеї/.о+зеї/.Ь ' ' ' # рядок 
документації 

геіигп зеї-Р. а+зеї-Р.Ь 

оЬ]=В(0,2) # створення об'єкта класу В, виклик 
конструктора 

оЬ].а=1 # зміна значення атрибута а 
оЬ].-Р() # виклик методу / 

ргіпі сііг(В) # список імен атрибутів класу В 
ргіпі сііг(оЬ]) # список імен атрибутів об'єкта об] 
ргіпі: ісі(оЬз) # унікальний ідентифікатор об'єкта 

ргіпі оЬ] ._зігео-Р_() # розмір об'єкта в пам'яті в 

байтах 

ргіпі В._сіос_ # рядок документації класу В 

ргіпі оЬ].-Р._сіос_ # рядок документації методу / 

ргіпі В. _пате_ # ім'я класу В 

ргіпі _пате_ # ім'я модуля 

ргіпі іуре(оЬ]) # тип (клас) об'єкта 063 

# або оЬз. _ сіазз _ 

ргіпі оЬ]._сіазз_. _пате_ # ім'я типу об'єкта 063 

ргіпі уагз(оЬ]) # словник з парами атрибут:значення 

# або 063 ._ бісі _ 

ргіпі Ьазаііг(оЬ ], 'а’ ) # чи є атрибут 'а' у об'єкта 
оЬз ? 


49 




зеіаііг(оЬ] , 'а' ^ В) # зміна значення (3) атрибута 
'а' об'єкта оЬд 

# або оЬд. _зеіаііг_ ('а',3) 

ргіпі §еіаііг(оЬ;і, 'а') # значення атрибута 'а' 
об'єкта оЬд 

# або оЬд. _ деіаіігіЬиіе _ ('а') 

# або оЬд. _ вісі _ ['а'] 

ргіпі: са11аЬ1е(оЬ] .-Р) # чи атрибут / є методом? 
ргіпі ізіпзіапсе(оЬ ], В) # чи оЬд є екземпляром В? 
ргіпі І55иЬс1а55(А^ оЬ^есі) # чи А є підкласом 
оЬдесі? 

ргіпі А._зиЬсІаззез_() # підкласи А 

ргіпі В._Ьазез_ # кортеж базових класів 

ргіпі В.тго # кортеж з ієрархією базових класів 


['_сіазз_' , '_сіеіаііг_' , 1 _сіісі_ 1 л '__бос__', ' 

_іогтаі_ ' _§еіаіігіЬиіе_ ' _ЬазЬ_ ', ' _іпіі_ 

, ' _тосіиіе_ ', ' _пеи/_ ', '_гесіисе_ ', ' _гес!исе_ 

ех_ ', ' _герг_' у ' _зеіаііг_ ', ' _зігеоі_ ', ' _зі 

г_ ' _зиЬсІаззНоок_ ' _и/еакгеі_ 'і'] 

['_с1а55_', '_сіеіаііг_ ', ' _дісі_', ' __дос__', ' 

_іогтаі_ ' _§еіаіігіЬиіе_ ' _Назії_ ', ' _іпіі_ 

, ' _тосіиіе_ ', ' _пеи/_ ', '_гесіисе_ ', ' _гесІисе_ 

ех_ ', ' _герг_ ' _зеіаііг_ ', ' _зігеоі_ ', '_зі 

г_ ', ' _зиЬсІаззИоок_ ', ' _и/еакгеі_ ', ' а’Ь^ 'і 

'] 

101226368 

32 

Клас В 

Повертає суму зеїі.а+зеїі.Ь 
В 

_таіп_ 

<с1азз '_таіп_ .В’> 

В 

{'а': 1, 'Ь': 2} 


50 





Тгие 

З 

Тгие 

Тгие 

Тгие 

[<с1аз5 '_таіп_ .В'>] 

(<с1аз5 '_таіп_ .А’>,) 

(<с1аз5 '_таіп_ .В’>, ссіазз '_таіп_.А ’>, сіуре 'о 

Ь]ес1: 1 >) 


іпкресі - перегляд об’єктів часу виконання 

Модуль іП8рсс1 містить додаткові функції, які допомагають 
отримати інформацію про об’єкти часу виконання (модулі, класи, 
методи, функції, об’єкти трасування, кадрів виконання і коду). 

ітрогі іпзресі 
# клас А 

с1а55 А(): разз 

ргіпі іпзресі:.§еітпо(А) # кортеж з ієрархією базових 
класів 

ргіпі іп5ресі.§е1:тетЬеп5(А) # повертає список пар 
(ім'я, значення) членів об'єкта 

ргіпі іпзресі:.^еісоттепіз(А) # коментар перед класом 

А 

#ргіпі іпзресі.деізоигсе(А) # текст вихідного коду 
класу А 

ргіпі іпзресі.І5с1а55(А) # чи А є класом? 

сіе-р Т(а; Ь=0, *аг§5., **к\л/аг§з): 

с-р=іп5рес1:.сиггеп1:-Ргате() # об'єкт поточного 

кадру виконання 

#с/=5у5 ._де±^гате() # або 

#с^.^_Ьаск # попередній кадр стеку (який викликав 

Г) 

ргіпі сТ.-Р_1іпепо, сТ.-Р_Ьаск.-Р_1іпепо # поточний 

51 





рядок коду і рядок, який викликав / 

ргіпі: с-Р.-Р_1осаІ5 # локальні імена / 
#ргіпі с/. ^_Ьаск.^_соде.со_^ііепате # файл 
модуля, що викликав / 

ргіпі: іпзресі:. ізтеїіИосІ (-Р) # чи / є методом? 
ргіпі іпзресі. із-Рипсііоп(-Р) # чи / є функцією? 
ргіпі іп5ресі.§еіаг§5рес(і) # імена аргументів 
функції 

і(1, 2,3, х=4) # виклик функції 


(<сіа55_таіп_.А аі 0x0000000005Р6Ю68>,) 

[('_сіос_ ', І\Іопе)^ ('_тосіиіе_ ', ' _таіп_')] 

ІМопе 

Тгие 

Раізе 

Тгие 

Аг§5рес(аг§з=['а'; ’Ь'], уагаг§з='аг§з '; кеуи/огс1з=' ки/ 
аг§з'^ сІеіаи1і5 = (0,)) 

14 21 

{'а': 1, ' аг§з': (З,)., ' Ь 1 : 2, 'сі': с-Ргате оЬ^есі аі 
0х0000000005Р50930>, ' к\л/аг§5 ' : { ' х' : 4}} 

сору - КОПІЇ об’єктів 

Модуль сору призначений для створення поверхневих і 
глибоких копій складених об’єктів. Функція сору створює 
поверхневу копію шляхом копіювання посилань на атрибути 
об’єкта. Функція беерсору створює глибоку копію шляхом 
рекурсивного створення окремих копій атрибутів об’єкта. 

ітрогі сору 

сіазз А(оЬ]есі): разз # клас А 
сіазз В(оЬ]есі): разз # клас В 
а=А() # об'єкт а 
Ь=В() # об'єкт Ь 


52 








a. х=Ь # атрибут х 

b. у=5 # атрибут у 

сору_а=сору.сору(а) # поверхнева копія об'єкта 

ргіпі а ^ а.Х; а.х.у 

ргіпі сору_а^ сору_а.х, сору_а.х.у 

сору_а=сору.сіеерсору(а) # повністю незалежна глибока 

копія об'єкта 

ргіпі: сору а^ сору а.Х; сору а.х.у 


< _таіп_.А оЬ^есі аі 0х03653490> <_таіп_.В оЬ^есі 

аі 0х03653810> 5 

< _таіп_.А оЬДесі аі 0х03653АО0> <_таіп_.В оЬ^есі 

аі 0х03653810> 5 

< _таіп_.А оЬ^есі аі 0х03653А70> <_таіп_.В оЬ^есі 

аі 0х03653В10> Б 

ІІЄГІООІ8 - функції для ефективних ітерацій 

Модуль ІІЄГІООІ8 містить функції, які створюють ітератори і 
призначені для ефективних ітерацій по даним. Для економії пам’яті 
ітератори застосовуються з оператором іог, але в прикладі вони 
передані функції 1І5І. Це зроблено тільки для змен ш ення об’єму 
коду прикладу. 

■Ргот орегаіог ітрогі асісі # бінарний оператор + 

Ргот ііегіооіз ітрогі * 

ргіпі 1І5і(І2Ір( ' аЬ ' , ' ссі )) # зшиває перший з 
першим, другий з другим і т.д. 

# соипі - послідовні значення, сусіе - повторює 
послідовність нескінченно 

Рог п,і іп ііір(соипі (), сусіе( аЬс )): 
і-р п>5: Ьгеак 
ргіпі (пД), 
ргіпі 

ргіпі 1І5і(сЬаіп( аЬ , ссі )) # об'єднує в один 
ргіпі 1І5і(сотрге55( 'аЬссІ , [1,0, 1,0] )) # тільки ті 


53 








елементи, яким відповідає 1 

рг і пі: 1ізі(сігор(л/Ііі1е(1атЬсІа х: х! = ' с ' ’аЬссІ )) # 

відкидати поки Тгие 

ргіпі 1і5і(іакеіл/Ні1е(1атЬсІа х: х!='с', ’аЬссІ )) # 

приймати поки Тгие 

ргіпі: [(к,1ізі(§)) -Рог к, § іп §гоирЬу( 'аааЬЬас' )] # 

групує 

ргіпі 1і5і(ііі1іег(1атЬсІа х: х іп ' ЬсІ' ’аЬссГ)) # 

фільтрує 

ргіпі 1І5і(ітар(асІсІ, (1,2,3), (4,5,6))) # адд(1,4), 
адд(2, 5), ... 

#ргіпі ІІ5±(ітар(ІатЬда х,у: х+у, (1,2,3), (4,5,6))) 

# або 

ргіпі 1І5і(зіагтар(асІсІ, [(1,2), (4,5)])) # адд(1,2), 

адд(4,5), ... 

ргіпі [Іізі(і) -Рог і іп іее( аЬс',3)] # створює З 

незалежні ітератори 

ргіпі "Комбінаторні генератори:" 

ргіпі 1і5і(ргосІисі( ’аЬ' , 'ссГ )) # декортів добуток 

ргіпі 1ізі(ргос)исі(' аЬ' ,гереаі=2)) # декортів добуток 

з собою 

#ргіпі іізі (ргодисі('аЬ ', ’аЬ')) # або 

ргіпі 1І5і(регтиіаііоп5( 'аЬс' ,2)) # усі можливі 
перестановки з двох елементів 
ргіпі 1і5і(сотЬіпаііоп5( 'аЬс' ,2)) # усі можливі 
комбінації з двох елементів 

ргіпі 1і5і(сотЬіпаііоп5_\л/ііЬ_гер1асетепі( аЬс',2)) # 

тут дозволені повтори 


[('а', ’С) 
(0, 'а') (1 
['а', 'Ь', 
['а', ’С] 
[’С, 'сі'] 
['а', ’Ь'] 


, (' Ь', 'сі')] 

, ’Ь') (2, 'о') 
’С, 'б'] 


(З, 


'а') (4, 


’Ь') (5, 


■С) 


54 





[('а'. 

[' а ', 

'а', ' 

а']). 

('Ь', 

['Ь', 

■Ь']), 

('а' 

, ['а 

']), (' 

с, [' 

с'])] 







['Ь', ' 

сі'] 








[5, 7, 

9] 








[3, 9] 









[['а'. 

'Ь', ' 

С], [ 

’а’. 

'Ь', ' 

с], [ 

' а', ’Ь 

’с 

']] 

Комбінаторні 

генератори: 






[('а'. 

'О, 

('а'. 

'сі'). 

('Ь', 

’С), 

('Ь', 

’сі')] 


[('а'. 

'а'). 

('а'. 

’Ь'), 

(’Ь', 

’а’). 

(’Ь', 

’Ь')] 


[('а'. 

’Ь'), 

('а'. 

'О, 

('Ь', 

'а'). 

(’Ь', 

’С), 

(’С 

, 'а'). 

(’С, 

'Ь')] 







[('а'. 

’Ь'), 

('а'. 

'О, 

('Ь', 

■с')] 




[('а'. 

'а'). 

('а'. 

■ь-). 

('а'. 

'О, 

('Ь', 

’Ь'), 

(' Ь' 

, 'О, 

(’С, 

■с)] 








ге - операції з використанням регулярних виразів 

Модуль ге забезпечує операції з використанням регулярних 
виразів. Регулярний вираз (РВ) - це послідовність символів 
(шаблон), яка відповідає певній множині рядків [28]. Зазвичай 
використовуються для операцій пошуку чи заміни рядків. 
Наприклад, шаблону ‘.о’ в рядку ‘Неііо \Уог1сГ відповідають рядки 
‘1о’ та ‘\Уо’. РВ може містити звичайні (як ‘о’) і спеціальні (як V) 
символи. Для прикладу, спеціальний символ V означає будь-який 
символ окрім символу нового рядка. Спеціальні символи 
сприймаються як звичайні, якщо перед ними стоїть символ ‘V. 
Шаблони і рядки для пошуку можуть бути 8-бітними рядками або 
Юнікод-радками. Створення РВ можна суттєво спростити за 
допомогою таких програм як Косіоз, КсіюхВікІсІу або ге§ех101.сот. 

-Ргот _Риіиге_ ітрогі: рпіп1:_-Рипс1:іоп 

ітрогі ге 

5= ' Неііо іліогісі ' # рядок для операцій 

то=ге. 5еагсй( ’ІлІогІсГ , з) # знаходить у 5 першу 
відповідність шаблону 


55 





ргіїтЦто .§гоир(0)) 

#ІлІогід 

то=ге.таїсЬ ( " Неііо 1 , б) # знаходить на початку з 
першу відповідність шаблону 
ргіїтЦто .§гоир(0)) 

#НеІІо 

ро=ге.сотрі1е( ’о’ ) # компілює шаблон в об'єкт 
регулярного виразу 

то=ро.5еагсІі(5) # знаходить у з першу відповідність 
шаблону 

ргіп1:(то.§гоир(0 ), то.зрап()) # вміст знайденого 
(групи), початок і кінець 
#о (4, 5) 

# функції об'єктів регулярного виразу мають параметри 
роз і епдроз: 

то=ро.5еагсЬ(5,ро5= ,епфо5=10) # знаходить у з першу 
відповідність шаблону (шукає з 7 по 10) 
ргіп1:(то.§гоир(0 ), то.зрап()) # вміст знайденого 
(групи), початок і кінець 
#о (7, 8) 

то=пе.5еагсМ( 1 (Н).*(ІлІ) 1 , з) # пошук за шаблоном з 
групами 

ргіп1:(то.§гоир5()) # усі групи 
#('Н', '14') 

ргіп1:(то.§гоир(0)) # група 0 (рядок, що відповідає 
повному шаблону) 

#Неііо 14 

ргіп1:(то.§поир(1)) # група 1 (рядок, що відповідає Н) 
#Н 

ргіп1:(то.§гоир(2)) # група 2 (рядок, що відповідає 14) 
#14 

ргіпфто .§гоир(1, 2)) 


56 




#('н ', 'и') 

ргіітІ:(то.5І:аг1:()^то.епсІ()) # початок і кінець групи 0 

#0 7 

ргіггЦто.5І:аг1:(2),то.епсІ(2)) # початок і кінець групи 
2 

#6 7 

ргіп1:(то.5рап(2)) # або 

#(6, 7) 

ргіп1:(то.ехрапсІ(г ' \1е11о \2ог1сГ)) # підставляє вміст 
груп 1 і 2 
#Неііо Йогів 

то=ге.5еагсИ( ' (?Р<пате1>Н).*(?Р<пате2>Іл1)' , з) # пошук 
за шаблоном з іменованими групами 
ргіп1:(то.§гоирсІіс1:()) # словник груп 
#{ ' пате2 ': 'ілі', ’патеї': 'Н'} 

ргіп1:(ге.-РіпсІа11( 'о' , з)) # усі відповідності, що не 

перекриваються 

#Г°', 'о '] 

■Рог то іп ге.-Ріпсііііеп( о',з): # те саме, але ітератор 
ргіп1:(то.§гоир(0)) 

#о 

#о 

ргіїтЦге.зр1і1:( , з)) # розділює за шаблоном 

#['НеИо', 'Іліогід'] 

ргіп1:(ге.зиЬ( з)) # заміна за шаблоном 

#Неііо_Шгід 

ргіпі:(ге.5иЬп( ' ' , '_',з)) # або показувати кількість 
зроблених замін 
#( ’Неііо_Шгід1) 


57 




ргіїгЦге.зиЬКг' "(.*?)"' ,г' <а Ьге-Р="\§<1>">\§<1х/а>' , 
г' "сіігХ^ііє.І тЬтІ" ' )) # заміна з використанням груп 

(\д<і>) 

#<а бге^="діг\і : ііе. біті "хііг^ііе.Ьїті</а> 

сіе-р гері(то): # повертає новий рядок, яким замінює 
ге.зиЬ 

ра1;И=то.§поир(1) # рядок знайденої групи 

геїигп м ["+ра1:1і+ ,, ] м 

ра!1:егп=ге. сотрі1е(и ' <іт§ 5гс = "(.*?)" /> ) # що 

заміняти 

ргіп1:(ге.зиЬ(ра1:1:егп^ гері, и'***<іт§ 5гс="1.рп§" 

/>***•)) # замінити все 
^***^ _ рпд] *** 

ргіггЦге. езсаре(з)) # екранує не алфавітно-цифрові 

символи 

#Неііо\ Іліогід 

ргіп1;(ге.-Ріпс!а11( ' . ' , ' Неііо')) # будь-який символ 
#['Н', 'е', ' і ', Ч', 'о'] 

ргіїтЦге.-Ріпсіа 11 ( 1 л . , 'Не1\п1о')) # символ на 

початку рядка 

#[-н-] 

ргіпі:(ге.-Ріпсіа 11 ( л . , ' Не1\п1о' ; ге.МІЛТІИИЕ)) 

#['Н'г ’і'] 

ргіп1:(ге.-РіпсІа11( 1 'Не1\п1о')) # символ вкінці 

рядка 

#['о'] 

ргіп1:(ге. -Ріпсіа 11 ( ' Не1\п1о' ; ге .МШТІНМЕ)) 

'о'] 

ргіп1:(ге.-РіпсІа11( І.', 'НЕНО')) # символ і 

#[Ч', Ч'] 

ргіп1:(ге.-РіпсІа11( ' І_* : , ’НЕНО )) # 0 і більше і 


58 




#Г', ", 'О-', ", "] 

ргіїтЦге.-Ріпсіа 11 ( І.+ ' у ’НЕНО )) # 1 і більше і. 

#[Чі ■] 

ргіїтЦге.-Ріпсіа 11 ( И? , 1 НЕНО )) # 0 або 1 і 

#['И '] 

ргіп1:(ге.-РіпсІа11( 1{2}' , 'НЕНО')) # 2 і 

#[Чі ’] 

ргіп1;(ге.-Ріпсіа 11 ( 1 і{2, 5} 1 , 'НЕНО')) # від 2 до 5 і 
#[Чі-] 

# те саме } але шукають і поглинають мінімальну 
кількість символів: 

ргіїтЦге.-Ріпсіа 11 ( І.*?', 'НЕНО )) 

#[ ", г ' ' } ' ' } ' 1 ] 

ргіпИ(ге.-РіпсІа11( І_+? , ' НЕНО )) 

ргіп1:(ге.-Ріпсіа 11 ( И.??', 'НЕНО')) 

#['Г, Ч'] 

ргіп1:(ге.-Ріпсіа 11 ( І_{2}?', 'НЕНО')) 

#[ 41 . '] 

ргіггЦге.-Ріпсіа 11 ( 1_{2;5}? , 'НЕНО )) 

#['и'] 

ргіп1:(ге.-РіпсІа11( ' [ЕО] ' , 'НЕНО')) # символи Е або О 
#['Е' } 'О'] 

ргіп1:(ге.-РіпсІа11( ' [а-гА-20-9] ' , 'НЕНО')) # усі букви 
і цифри 

'Е', Ч\ Ч', 'О'] 

ргіп1:(ге.-РіпсІа11( ' [ л ЕО] ' , 'НЕНО')) # не символи Е 
або О 

Ч', Ч'] 

ргіп1:(ге.-Ріпсіа 11 ( \*\?\+\|\(\) ; '*?+ІО')) # 
екранування спеціальних символів 
#['*?+!()'] 


59 






ргіпі(ге. -Ріпсіа 11 ( г ' \\ ’ л г' ' + ' ) 

#['\\'] 

ргіпі(ге. 5еагсЬ(г ' (Е). *(0)\1' ^ ' НЕНОЕ ' ) .§гоир(0)) # 

\1 - вміст першої групи 
#ЕІІОЕ 

ргіпі(ге. зеагсІі(г ' (?Р<пате>Е). *(0) (?Р=пате)' , 

1 НЕНОЕ ' ) .§гоир(0)) # або (?Р=пате) - вміст групи 
(?Р<пате>Е) 

#ЕІІОЕ 

ргіпі:(ге.-РіпсІа11( ' Е |0" ^ 'НЕНО')) # знайти Е або О 
#['Е' } 'О'] 

ргіпі(ге.-Ріпсіа 11 ( ЕО , ’НЕНО )) # знайти ЕО 

#[] 

ргіпі(ге.5еагсН('(Е)\, ’НЕНО ).§гоир(1)) # вміст 

першої групи (Е) 

#Е 

ргіпі:(ге. 5еагсЬ( ' (?Р<пате>Е) ' , ' НЕНО' ) .§гоир(1)) # 

вміст групи (?Р<пате>Е) 

#Е 

ргіпі(ге.зеагсИ( '(?Р<пате>Е )' , 

’НЕНО ).§гоир( 'пате )) # або 

#Е 

ргіпі(ге.зеагсЬ( ' (? : Е )' , 'НЕНО' ) .§гоир(0)) # не 

створює групу 
#Е 

ргіпі(ге.-РіпсІа11( ' Е(?=І_)' , 'НЕНО')) # якщо наступний 

символ і 

#['Е'] 

ргіпі(ге.-Ріпсіа 11 ( ' Е( ? ! і)' , 'НЕНО')) # якщо наступний 
символ не і 
#[] 


60 




ргіпі(ге .ііпсІа11( '(?< = І_)Е , ’НЕНО )) # якщо 
попередній символ і 
#[] 

ргіпі(ге .ііпсІа11( ( ?< ! Ь)Е ’НЕНО )) # якщо 

попередній символ не і 

#['Е'] 

ргіпі:(ге.-РіпсІа11( ' Е(?#соттепі) 'НЕНО')) # коментар 
(?#соттепі) 

#['Е’] 

ргіпі: (ге .зеагсН(г'(<)(\сІ*)(?(1)>)', 

'хх<12>хх' ).§гоир(2)) # якщо група 1 містить <, то 
шукати > 

#12 

# флагі режиму: 

ргіпі (ге. ііпсІа11( ' (?з). ' , 'НЕІЛпіО')) # враховувати 
символ \п 

#['Н', 1 Е', Ч', ’\п‘, 'і', 'О'] 

ргіпі (ге.-РіпсІа11( ' . ' , 'НЕІЛпЮ')) # те саме без (?з) 
#['Н', 'Е' } Ч' } Ч’ } 'О'] 

ргіпі(ге.ііпсІа11( 1 (?і)Е ' , 'НеНО')) # не чутливий до 

регістру 

#[ ’е'] 

ргіпі(ге.ііпсІа11(и ' Е , и'НеНО , ге. ІСІМОКЕСА5Е | 
ге. ІІІМІССЮЕ)) # або так для ііпісоде 

#[и 'е ' ] 

ргіпі(ге.ііпсІа11( (?х) Е ; 'НЕНО')) # не 

чутливий до пробілів 
#['Е'] 

# спеціальні послідовності: 

ргіпі(ге .-РіпсІа11(г ' \А' , 1 НЕНО')) # початок рядка 
#["] 

ргіпі(ге.ііпсІа11(г ' \2 , 'НЕНО )) # кінець рядка 


61 




#["] 

ргіп1:(ге.-РіпсІа11(г 'НЕІДЬ ' , 'НЕіЛпІО')) # пустий рядок 
на границі слова 
#['НЕі'] 

ргіп1:(ге.-Ріпгіа11(г ’НЕІДВ' , ’НЕіЛпШ')) # пустий рядок 
не на границі слова 
#[] 

ргіпі:(ге.-Ріпсіаіі( г ’\с!’ л '123')) # будь-яка десяткова 
цифра 

'2 ' } 'З'] 

ргіп1:(ге.-РіпсІа11(г ' \0' , '123')) # не цифра 

#[] 

ргіпі(ге.-РіпсІа11(г ' \5 1 д 1 \і\п\г\-Р\у' )) # будь-який 
пробільний символ 

#Г '\ї', ' \п'\г' } '\хвс', '\х0Ь'] 

ргіпі(ге.-РіпсІа11(г 1 \5 ' , ' \і\п\г\-Р\у 1 )) # будь-який 
не пробільний символ 
#[] 

ргіпі(ге.-Ріпсіа 11 ( г 1 \\л/ , 'НЕНО )) # будь-який 
алфавітно-цифровий символ 
1 Е', 'і', Ч', 'О'] 

ргіпі(ге .-РіпсІа11(г ' \ІлҐ, 1 НЕНО')) # будь-який не 
алфавітно-цифровий символ 
#[] 


сіесітаї - дійсні числа довільної точності 

На відміну від типу даних -Ріоаі:, модуль сіесітаї дозволяє 
точно подавати дробові десяткові значення. 

ітрогі зуз 

ітрогі сіесітаї # модуль для арифметики довільної 
точності 

ргіпі: 0.1*7==0.7 # Еаізе 

ргіпі сіесітаї.0есіта1( 0.1 )*7 == 
сіесітаї.йесіта1( '0.7 ) # Тгие 


62 








рг і пі: зуз .-Р1оаі_іп-Ро # інформація про тип /іоаі 
х=1 .7976931348623157е+308 # найбільше ф=іоаї 
ргіпі 2*х # результат: іпф 2 

Х=с1есіта1.0есіта1( ’1.7976931348623157е+308' ) # дійсне 
довільної точності 

ргіпі: х.аз_іир1е() # кортеж у вигляді (знак, мантиса, 
порядок) 

ргіпі 2*х # результат: 3.5953862697246314Е+308 


Раїзе 

Тпие 

зуз . і1оаі_іп-Ро(тах=1.7976931348623157Є+308., тах_ехр=1 
024^ тах_10_ехр=308, тіп=2.2250738585072014е-308; тіп 
_ехр=-1021, тіп_10_ехр=-307, с!і§=15_, тапі_сІі§=53; ерз 
і1оп=2.220446049250313Є-16., гасІіх=2; гоипсІ5=1) 
іпі 

□есітаІТир1е(зі§п=0, с1і§і1:5=(1_, 7, 9, 7, 6 , 9, 3; 1, 

З, 4, 8; 6, 2, 3, 1, 5; 7), ехропепі=292) 

З.5953862697246314Е+308 

Ііте - визначення і конвертування значень часу 

Функції для визначення і конвертування значень часу. Дивись 
також модулі сіаіеііте і саіепсіаг. 

ітрогі ііте 

ргіпі ііте.с1оск() # час СРІІ в секундах з часу 
першого запуску цієї функції 

ііте.з1еер(1.0) # зупинити виконання на 1 секунду 
ргіпі ііте.с1оск() # буде приблизно 1 
ргіпі ііте.ііте() # кількість секунд з початку Епохи 
(1.1.1970 р.) 

ргіпі ііте.1оса1ііте() # поточний час (зі:гис±_ііте) 

ргіпі ііте.1оса1ііте()[0] # поточний рік 

ргіпі '*' ,ііте. 1оса1ііте(1424196030) # заданий час 

(зїгисї_їіте) 


63 








ргіпі ііте.іітегопе # зона часу як зміщення в 
секундах 


1.6364630143Є-06 

1.00987850899 

1535381596.49 

ііте. 5ігисі_ііте(іт_уеаг=2018, іт_топ=8, іт_тсІау=27, 
іт_Ьоиг=17, іт_тіп=53, іт_5ес=16, іт_\л/сІау=0, 1:т_усІау= 
239, 1:т_І5СІ5І:=1) 

2018 

* ііте. 5ігисі_ііте(іт_уеаг=2015, іт_топ=2, іт_тс)ау=17 
, іт_Ііоиг=20, іт_тіп=0, іт_5ес=30, іт_\л/сІау=1, іт_ус)ау 
=48, іт_І5СІ5і=0) 

-7200 


еіаіеііте - робота з датою і часом 

Класи для роботи з датою і часом. Містить класи баіе (дата), 
ііте (час), сіаіеііте (дата і час), іітесіеііа (період часу), ігіпіо 
(абстрактний клас для роботи з часовими поясами). Дозволяє 
виконувати різноманітні математичні операції над значеннями дати 
і часу. 

ітрогі сіаіеііте, Іііте 

сІ0=сІаіеііте. сіаіеііте. поіл/() # поточна дата (даіеііте) 
сІ1=сІаіеііте.сІаіеііте(2015,2,17,0,0,0,0) # задана дата 
(даіеііте) 

ргіпі: сІ0.уеаг, сІ0.топіІі, сІ0.сІау, сІ0.6оиг, сІ0.тіпиіе, 
сі0. зєсопсі, сІ0.тісго5есопсІ, сІО.ігіпіо # атрибути 

даіеііте 

5і=сІ0.іітеіир1е() # об'єкт (ііте . зігисі_ііте) 
ргіпі ііте.ткііте(5і) # кількість секунд з початку 
Епохи 

ргіпі сіаіеііте. сіаіеііте. 5ігрііте( "Моп Арг 26 11:31:53 
2010 м , "%а %Ь %сІ %Н:%М: %5 %У" ) . 5Ігіііте( "%сІ%М%У" ) # 

конвертація з формату в формат 


64 








ргіпі сЮ. ізоиеексіау() # 150 день тиждня (1 ■ 

понеділок) 

ргіпі; сії.гер1асе(уеаг=2014) # дозволяє змінити певні 
атрибути дати 

# тут місяців і років нема є ^ бо вони можуть мати 
різну к-сть днів 

1:сІ1=сІа1:е1:іте.1:ітесІе11:а(\л/еекз = 1 ^с1ау5=2^ Ьоиг5=1) 
ргіпі ісіі.сіауз^ ісіі. зесопсіз., ісіі. тісгозесопсіз 
ргіпі сіі+ісіі # додати до дати період (даїеїіте) 
ргіпі сІ1+ісІ1*2-аЬ5(-ісіі) # допустимі операції 

(даїеїіте) 

ісІ2=сІ0-сІ1 # різниця дат (даїеїіте) 
ргіпі сІ0>сІ1 # порівняння дат 
ргіпі ісІ1>ісі2 # порівняння періодів 

# даїеїіте знає про високосні роки: 

ргіпі сіаіеііте. сІаіеііте(2016,3^ 1) - 
сІаіеііте.сІаіеііте(2016,2,28) # результат 2 дня 
#ргіпї даїеїіте.даїеїіте(2015 ^ 2, 29) # помилка! 


2018 8 27 18 Б 13 543000 ІМопе 
1535382313.0 
26312010 
1 

2014- 02-17 00:00:00 
9 3600 0 

2015- 02-26 01:00:00 
2015-02-26 01:00:00 
Тгие 

Раізе 

2 сіауз, 0:00:00 


65 





саіепсіаг - робота з календарем 


Функції для виведення календаря і роботи з ним. За 
замовчуванням першим днем тиждня є понеділок, а останнім - 
неділя. 


ітрогі: саіепсіаг 

с=са1епсІаг.Са1епсІаг(са1епсІаг .МОІ\ЮАУ) # календар (або 
саіепдаг.Саіепдаг()) 

ргіпі: [сі -Рог сі іп с. іііегтопіііісіаііез (2016, 2 ) ] [: 2 ] # 

ітератор на дні місяця даіеііте.даіе (цілі тиждні) 

ргіпі: саіепсіаг .\л/еекс)ау(2016, 2^ 29) # день тиждня 
ргіпі: саіепсіаг .топ1:І'ігап§е(2016, 2) # день тиждня 

першого дня місяця і кількість днів в місяці 

саіепсіаг . Тех1:Са1епсІаг(са1епсІаг .МОІ\ЮАУ) .-Рогта1:тоітІ:І'і(20 

16, 2) # повертає текстовий календар на місяць 

саіепсіаг. І_оса1еТех1:Са1епсІаг(са1епсІаг .МОІ\ЮАУ, ' ІІкпаіпіа 
п_11кгаіпе' ) .■Рогта'1:топ'1:Іі(2016, 2) # повертає текстовий 
календар на місяць (українська мова) 
саіепсіаг . НТМІ-Са1епсіаг(са1епсІаг .МОІ\ЮАУ) .-Рогта1:тоітІ:Іі(20 

16, 2) # повертає біті календар на місяць 


[сіаіеіііте. сІа1:е(2016, 2, 1), сіаііеіііте. сІа1:е(201б_, 2, 2) 

] 

0 

(0, 29) 


рсІЬ - відлагоджувач РуІЇюп 

рбЬ - інтерактивний відлагоджувач (сіеЬи§§ег) вихідного коду 
РуІЇюп-програм, який дозволяє установлення точок зупинки, 
виконання в покроковому режимі, обчислення довільних РуїЬоп- 
виразів, перегляд кадрів стеку та поставарійне відлагодження. 
Виконайте програму так: 

руїіЬоп таіп.ру 


66 



І введіть послідовно наступні команди відлагожувача: 
п (виконувати до наступного рядка) 

5 (виконати рядок і зупинитись в функції, що викликається) 
а (вивести аргументи функції) 
р х (вивести значення х) 

! х (або так) 

! х=2 (змінити значення х) 
г (виконувати до виходу з функції) 
с (продовжити до точки зупинки) 

Відлагоджувач можна також викликати командою: 

руіИоп -т рсІЬ таіп.ру 

Щоб вийти з відлагоджувача введіть команду я. Для 
ознайомлення з поставарійним відлагодженням закоментуйте рядок 
ітрогі рсІЬ; рсІЬ. зеі_ігасе( ) і введіть в консолі команди: 

руіНоп 

>>> ітрогі: таіп # тут виникне 2 єго0іуізіопЕггог 

>>> ітрогі рсІЬ; рсІЬ.рт() 
х 
Я 

>>> ехіі() 


Сіе-Р і(х): 

геіигп 1.0/х 

ітрогі рсІЬ; рсІЬ.5Єі_ігасе() # точка зупинки (ввійти в 

відлагоджувач) 

ргіпі і( 1 ) 

ргіпі і( 0 ) 


іітеіі - тривалість виконання невеликих частин коду 

Модуль іітеіі дозволяє просто визначати тривалість 
виконання невеликих частин коду. Для великих частин коду 


67 



використовуйте модуль Ііте. З прикладу видно, що 5Іп(х) 
виконується швидше ніж таіЬ. зіп(х). 

ітрогі іітеіі 

ргіпі іітеіі.іітеіі( 'таіЬ.5Іп(х) ' , зеіир= ’ ітрогі 
таіЬ; х = 1‘, питЬег=1000000) # час виконання 
1000000 раз (секунд) 

ргіпі: іітеіі.іітеіі( ’зіп(х)’ , зеіир= ’ ігот таіЬ ітрогі 
зіп; х = 1 , питЬег=1000000) 


0.262688315981 

0.192319588135 


1о§§іп§ - ведення журналу 

В цьому модулі визначені функції і класи, які реалізують 
гнучку систему реєстрації подій для прикладних програм і 
бібліотек. Нижче показано найпростіший спосіб використання 
модуля. Приклад створює файл ту1о§. 1о§ з журналом подій. 

ітрогі 1о§§іп§ 

1о§§іп§. Ьа5ІсСоп-Рі§(іогтаі= ’ %(1еуе1пате) -8з 
[%(азсііте)5] %(те55а§е)з 1 , 1 єує1=1о§§іп§. 0ЕВІІС, 
іі1епате='ту1о§.1о§’, іі1етосІе='\л/') # конфігурування 
системи реєстрації подій 

1о§§іп§.сІеЬи§( 'Повідомлення налагоджувана' ) 

1о§§іп§.іпіо( Інформаційне повідомлення ) 
1о§§іп§.\л/агпіп§( 'Попередження ) 

1о§§іп§.еггог( Помилка') 

1о§§іп§.сгіііса!( Критичне повідомлення ) 


йЕВІІС [2018-08-31 14:56:40,039] Повідомлення нала 

годжувача 

ІМРО [2018-08-31 14:56:40,039] Інформаційне пові 

домлення 

ІлІАКМІІМС [2018-08-31 14:56:40,039] Попередження 


68 




ЕККОК [2018-08-31 14:56:40,039] Помилка 

СКІТІСАЬ [2018-08-31 14:56:40,039] Критичне повідомл 

ення 


ріскіе - серіалізація об’єктів РуїЬоп 

Серіалізація - це процес перетворення якої-небудь структури 
даних в послідовність бітів. Часто використовується для передачі 
об’єктів по мережі або для збереження їх у файли. Модуль ріскіе 
реалізує алгоритми для серіалізації і десеріалізації об’єктів РуїЬоп. 

ітрогі ріскіе 

«І1:Ь ореп( 'бака.ркі' , ' \л/Ь' ) аз -Р: # відкрити бінарний 
файл для запису 

ріскіе.сіитр( [1, 2, 3], -Р) # серіалізувати список у 

файл 

ріскіе .битр( [4, 5, 6], -р) 

иікЬ ореп( 'бака.ркі' , ' гЬ' ) аз -Р: # відкрити бінарний 
файл для читання 

ргіпк ріскіе.ІоасІ(-Р) # десеріалізувати список 

рпіпк ріскіе.Іоаб(-Р) 

з=ріск1е.битрз( [7, 8,9] ) # серіалізувати список в 
рядок 

ргіпі: ріскіе. 1оасІ5(5) # десеріалізувати список 


[ 1 , 2 , 3 ] 

[4, 5, 6] 

[7, 8, 9] 

зЬєіує - збереження об’єктів РуїЬоп 

Модуль 8 Йє1ує (полиця) призначений для збереження у 
постійній пам’яті РуїЬоп-об’єктів (які може зберігати ріскіе) в 
об’єкті, подібному на словник. 

ітрогі зЬєіує 

сІ=зЬеІУЄ.ореп("-Рі1е.сІа1:") # відкрити файл полиці 


69 






сІ["1"] = [1,2,3] # записати у полицю об'єкт під ключем 

п ^ п 

СІ["2"] = [4,5,6] 

сі . сІозе() # закрити файл полиці 

сі = зЬеІУЄ.ореп( "Бііе.сіаі: ) 
і Б сі.Иаз_кеу( 2"): # якщо є ключ "2" 

сієї сі["2"] # видалити об'єкт під ключем "2" 
сІ.5упс() # зберегти усі зміни на диску 
ргіпі: сІ.кеуз() # вивести список усіх ключів 
і-Р сІ.Иа5_кеу( 1 ): ргіпі: сІ["1"] # об'єкт під ключем 

її^ п 

СІ . СІ05Є( ) 


[’!'] 

[1, 2, 3] 

апусІЬт - універсальний доступ до БВМ баз даних 

Модуль апусІЬт реалізує універсальний доступ до різних БВМ 
баз даних (БД). Для доступу до бази даних використовується 
подібний на словник інтерфейс. На відміну від зЬєіує, ключі і 
значення словника повинні бути рядками. 

ітрогі апусІЬт 

сІЬ=апусІЬт.ореп("тусІЬт.сІЬ", "с") # відкрити БД для 
читання і запису } створити } якщо не існує 
сІЬ[ "Іванов" ] = "1990" # записати у БД (зверніть увагу ■ 
рядки!) 

СІЬ[ "Петров" ] = "1992" 

Бог к^у іп СІЬ. ііегііетз (): # вивести усі записи бази 
даних 

ргіпі к^у # ключ і значення 

сІЬ.сІ05е() # закрити БД 


70 






Петров 1992 
Іванов 1990 

8С|1іІеЗ - ВВ-ЛРІ 2.0 інтерфейс для баз даних 8(}Іліе 

80ЬіІе - це бібліотека, яка реалізує систему керування 
реляційними базами даних. Підтримує транзакції, не потребує 
інсталяції, створена мовою С, швидка, не залежить від платформи. 
Взаємодія з базою даних відбувається мовою 8()Ь. Модуль зцІіїеЗ є 
інтерфейсом РуїЬоп до ЗСДлІе. 

ітрогі зяІіІіеЗ 

сопп = бяііієЗ. соппес!( 'тузяїіІіеЗ.сіЬ' ) # об'єкт бази 
даних 

сиг = сопп.сиг50г() # об'єкт курсор - виконує запити 
і отримує результати 

# виконати команду 5яка створює таблицю з полями 
пате і сопіепі 

сип.ехеси!е( 'СКЕАТЕ ТАВІ.Е ІР N01 ЕХІ5Т5 ра§ев(пате 

ТЕХТ, сопіепі: ТЕХТ)') 

сопп.сотті1() # зберегти зміни 

# база даних блокується поки транзакція не 
виконається 

пате=и"Іванов" 

соп!еп1=и"1990" 

# виконати команду яка додає рядок з даними 

пате } сопіепі в таблицю 

сиг.ехеси!е( ' ^5ЕКТ ^ТО ра§ез (пате,сопіепі) 
ї/АШЕ5( ?^ ?) , (пате,сопіепі)) 
сопп.сотті!() # зберегти зміни 

# виконати команду 5^^^ яка оновлює дані 

сиг.ехеси!е( ' ІІРОАТЕ ра§ез БЕТ соп!еп!=? ІлІНЕКЕ 

пате=? , (сопіепі,пате)) 

сопп.сотті!() # зберегти зміни 


71 





# виконати команду 5 яка отримує результати запиту 
сип.ехеси1:е( ' 5ЕІ.ЕСТ сопїепі: РКОМ ра§ез ІлІНЕКЕ пате=?', 
(пате,)) 

#ргіпі сиг.^еісііопе() # отримати наступний рядок 
множини результату запиту } або 

ргіпі: сиг .-Ре1:сНа11() # отримати усі рядки множини 
результату запиту 

сиг.сІозеО # закрити курсор 
сопп.сіозє() # закрити базу даних 


[(и'1990’,)] 


С8У - читання і запис файлів С8У 

С8У (Сотта Зерагаїесі Уаіиез) - це розповсюджений текстовий 
формат імпорту і експорту електронних таблиць і баз даних 
(наприклад з Ехсеї). Модуль С5V реалізує класи для читання і 
запису табличних даних в форматі С8У. 

ітрогі: сзу 

с5У_-Рі1е=ореп("5оте.с5У м , "(л/Ь") # відкрити файл для 
запису 

и/гі1:еп = сзу.\л/гі1:єг(с5у_-Рі1Є; беїітіїїег = ) # 

об'єкт для запису 

мгіїїег. уугііієгоуу ( [0 . 1,0. 2,0. 3]) # записати рядок 
\л/гі1:ег.\л/гі1:его\л/( [0.4,0.5,0.6] ) # ще один 
сзу_-Рі1е.сІ05е() # закрити файл 

с5У_-Рі1е=ореп("5оте.с5У", "пЬ") # відкрити файл для 
читання 

геасІег=с5У.геасІег(сзу_-Рі1е^е1іті1:ег = # об'єкт 

для читання 

■Рог по\л/ іп геасіег: 


72 








ргіпі ПО\л/ [ 0 ] ^ Г0\л/[ 1 ] л ПО\л/[ 2 ] 
С5У-Рі1е. с1озе() # закрити файл 


0.1 0.2 0.3 
0.4 0.5 0.6 

іагїїіе - читання і запис файлів архіву іаг 

Модуль "Ьап-Ріїе дозволяє читати і записувати Іаг-архіви з 
підтримкою стиснення даних §хір або Ь/2. Приклад створює новий 
каталог, запаковує його в архів і розпаковує цей архів в інший 
каталог. 


ітрогі іагіііе^ зуз, оз 

епсосНп§=5уз. §еі-Рі1езузіетепсосііп§() # кодування в 

файловій системі (у Ілііпдоіліз 7 - тЬсз) 
тусІіг=иг" Каталог" 
тус!іг2=иг"Каталог2" 

05.тксііг(тубіг); 05.тксііг(тусііг2) # створити каталоги 
іаг = іагіііе . 0 реп(иг"іезі_агс 1 ііуе .1:аг " , тосіе='а , 
іогтаі=іаг-Рі1е. РАХ_РОКМАТ) # відкрити архів для 
додання 

іаг .асісі(тусііг) # додати в архів 
іаг.с1озе() # закрити файл архіву 

іаг = іагіііе .0реп(иг"іе5і_агс1ііуе .іаг " , тосІе='г\, 
іогтаі=іаг-Рі1е. РАХ_РОРМАТ) # відкрити архів для 
читання 

іаг. ехіїгасіїаіі (раї: И=тусі і п2. епсосіе(епсосІіп §), 

тетЬегз=І\Іопе) # розпакувати все 

■Рог х іп іаг.§еітетЬегз(): # для кожного елемента 

архіву 

ргіпі: х.пате.с!есосІе(епсосЛп§) # вивести його ім'я 

ргіпі х.зіге # розмір в байтах 

ргіпі х.тііте # час останньої модифікації 


73 








ргіпі: х.ізсІіг() # чи це каталог? 
Іаг.сІ05е() # закрити файл архіву 


Каталог 

0 

1533569368.09 

Тгие 


гірШе - робота з 2ІР-архівами 

Модуль хірйіе містить іструменти для створення, читання і 
запису 2ІР-архівів. Приклад створює новий каталог, запаковує його 
в архів і розпаковує цей архів в інший каталог. 

ітрогі: гір-Ріїе; об 
тусІіг=ип" Каталог" 
тусііг2=иг"Каталог2" 

05.тксііг(тусііг); 05.тксііг(тусііг2) # створити каталоги 
2 -Р = 2Ір-Рі1е.2ірРі1е(ип"1:е5І:_агсЬІУЄ.2Ір'^ тосІе='\л/^ 
сотрге55Іоп=2Ір-Рі1е. 2ІР_5Т0КЕ0) # відкрити архів для 
додання без компресії (2ІР_0ЕРЇАТЕ0 - з компрессією) 
■Рог гооіі; сіігз., -Рііез іп 05.\л/а1І<(тусііг): 

2 -Р.\л/гі 1 :е(гоо 1 :) # додати в архів каталог 
■Рог -Рііе іп -Рііез: # для кожного файлу 

2-Р.іл/пі1:е(о5.ра1:Іі.]оіп(поо'1:^ -Рііе)) # додати в 
архів файл 

2 "Р. сіозе () # закрити файл архіву 

2 -Р = 2Ір-Рі1е.2ірРі1е(иг"‘1;е5'1:_агсРііУе.2Ір'^ ' г' ) # 
відкрити архів для читання 

2 -Р.ехіїгасіїаіі(ра1:И=тусІіг2^ тетЬег5=І\Іопе, рмсІ=Мопе) # 

розпакувати все (підтримуються паролі рмд тільки на 
розпакування і тільки ІІР2.0) 

2 "Р. сіозе () # закрити файл архіву 


74 






2 ІІЬ - сумісне з § 2 Ір стиснення даних 

Модуль 2 ІІЬ містить функції для стиснення та декомпресії 
даних з використанням бібліотеки /ІіЬ. 

ітрогі гІіЬ 

5= "хххххххххххххххххххххххххххххххххххххххххххххххххх 
ххххххххх" 

с= 2 ІіЬ.сотрге55(з, 9) # стиснути дані з найвищим 
рівнем 

#с=з. єпсодє( ' гііЬ ') # або так 

5=2ІіЬ.сіесотрге5з(с) # виконати декомпрессію 

#5=с . десодє( ' і і і Ь ') # або так 

ргіпі: 1еп(з) ^ 1еп(с) # довжина даних до і після 

стиснення 


59 12 


8у§ - системні параметри і функції 

Модуль 8у8 містить змінні та функції, які мають відношення до 
інтерпретатора РуїЬоп та його середовища. 

ітрогі: зуз 

ргіпі: зуз . ріаі-Рогт # платформа 

ргіпі зуз.уегзіоп # версія інтерпретатора 

ргіпі 5уз.аг§у # аргументи командного рядка 

зуз . Ьиііііп_тос)и1е_пате5 # вбудовані модулі 

зуз. тосіиіез # модулі що завантажуються 

ргіпі зуз .§еі5І2ео-Р(іпі()) # розмір об'єкта в байтах 

зуз.раііі # шлях до пошуку модулів 

#5 у5.раіЬ.аррепд('0:\\') # додати шлях пошуку модулів 
#ргіпі зуз.зідіп.геадііпе() # читати рядок з 
стандартного потоку введення (тут програма буде 
чекати введення) 

ргіпі зуз . зісііп. ізаііу() # чи стандартний потік є 

консоллю 


75 






зуз . зісіоиі. іл/гііе ( 'Ьєііо зіс)оиі\п" ) # запис в 
стандартний потік виведення 

зуз . зісіоиі=ореп( ' іетр.сіаі' , 'іл/' ) # перенаправлення 
виведення у файл 

ргіпі "Ьеііо -Рііе" # виведення у файл 

зуз . зісІоііі=5у5. _зісіоиі_ # відміна перенаправлення 

ргіпі; "Ьеііо сопзоіе" # виведення знову на консоль 
ігу: гаізе ІпсІехЕггог # генерувати виняткову ситуацію 
ехсері: ргіпі зуз.ехс_іпіо() # інформація про 
виняткову ситуацію 
#5 уз.ехіі() # завершення програми 


и/іп32 

2.7.14 |АпасопсІа сизіот (64-Ьіі:) | (сіе-раиіі;^ Осі 15 20 
17; 03:34:40) [М5С у.1500 64 Ьіі (АМ064)] 

['Е:\\РуіЬоп_ргозесіз\\таіп.ру'] 

24 

Тгие 

Ьеііо зісіоиі 
Иеііо сопзоіе 

(<іуре ' ехсерііопз. ІпсІехЕггог' >; ІпсІехЕггог(); <ігасе 
Ьаск оЬ]ЄСі аі 0х0000000005177Е88>) 

08 - файлова система 

Модуль 08 забезпечує переносимий спосіб використання 
функціональності, пов’язаної з операційною системою. В прикладі 
показані функції для роботи з файловою системою. Цю програму 
слід виконувати так: 

руійоп.ехе таіп.ру 


ітрогі 05;5уз 

оз.тксЦ^г'іетр') # створити каталог 
иіііі ореп(г'іетр\іетр.сІаі /VI') аз і: 
■р.мгііе( 1 йе11о\п' ) # створити файл 


76 








рг і пі: оз . раіН. ізсііг(г ' с : \іетр' ) # чи каталог 
ргіпі оз.раіН.І5іі1е(г 'с:\іетр ) # чи файл 
ргіпі оз .раіЬ.ехізіз(г 'іетр\іетр. сіаі' ) # чи існує 

шлях 

ргіпі: оз . раів .§еі5І2е(г ' іетр\іетр. сіаі' ) # розмір в 
байтах 

ргіпі 05 . раііі. зр1іі(г 'іетр\іетр. сіаі' ) # розбити на 
шлях і ім'я 

#05. петоие(п ' іетр \ іетр. даі ') # видалити файл 
#05.гтдіг(г ' ієтр ') # видалити каталог 
#ргіпі 05.епиігоп # змінні середовища (можна 
змінювати) 

Тс^зуз.зісІоиі.-РіІепоО # файловий дискриптор (1) 

05 . игііе(-РсІ, ' Не11о\п' ) # запис в стандартний потік як 
у файл 

ргіпі 05 . §еіс\л/сІ() # поточний каталог 

05. сМіг(г 'іетр' ) # змінити поточний каталог 

с\л/сІ=05.§еіс\л/сІи() # поточний каталог (ипісоде рядок) 

ргіпі 05.1ізісііг(сіл/сі) # список елементів каталогу 
Тог гооі; сіігз., -Рііез іп 05.\л/а1І<(сілкі): # або за 

допомогою генератора оз.маік 

РГІПІ ГООІ, СІІГ5 ТІІЄ5 


Ьеііо 

Тгие 

Раїзе 

Тгие 

7 

('іетр', 'іетр.сіаі') 
е:\руіЬоп_рго]есіз 
[и'іетр.сіаі' ] 

е:\руіЬоп_рго]есі5\іетр [] [и'іетр.сіаі'] 


77 





8ІШІІ1 - високорівневі операції з файлами 

Модуль зЬиІіІ містить високорівневі функції для операцій з 
файлами (копіювання, переміщення, архівування). 

ітрогі оз , зііиііі 

оз.тксІіг( ітр'); оз.тксІіг( ' 1:тр/1:тр2 ) # створити 

каталоги 

зЬиііІ. сору-Рі1е( 'таіп. ру' ^ ' ітр/ітр2/таіп. ру ) # 

копіювати файл 

5Ьиіі1.тоуе( ' 1:тр/1:тр2' ^ # перемістити каталог в 

поточний 

зЬиііІ.соруігее( 'ітр2' , ' ітрЗ') # копіювати каталог 
ргіпі зЬиііІ. таке_агсіііуе( 'ітр/іезі-агсЬіуе.гір' , 
Ьазе-СІіг^ітрг') # архівувати каталог 


Ітр/іе5і_агс1ііуе. гір. гір 

оз - створення і керування процесами 

В цьому прикладі показані функції модуля оз для створення і 
керування процесами. Ознайомтесь також з більш новим модулем 
81 іЬрГОСЄ 88 . 

ітрогі: оз 

ргіпі: оз.§еіріс!() # ідентифікатор процесу 

оз. зузіет( г 1 зіагі саіс.ехе') # виконує команду 

оболонки 

ргіпі оз.5у5іет(г 'есЬо Ьеііо') # виконує команду 
оболонки 

ргіпі оз . рореп(г ' есИо ілюгісГ ) .геасІ() # читати 

результати команди оболонки 

ісі = оз. 5раіл/пу(оз. Р_І\ІОІлІАІТ^ 

' с:\\1лІіпсІоиу5\\МоіерасІ. ехе ,[г' 

с:\Руііюп27\КЕА0МЕ.іхі' ]) # виконує програму без 
очікування виходу з неї 

зіаіиз = оз.маіірісі(ісі^ 0) # але тут чекає завершення 

78 






процесу ІСІ 

ргіпі ' 5І:а1:и5=' 5іаіи5 

05. 5іагі"Рі1е ( г 1 с : \Руііюп27\КЕА0МЕ . іхі ' ) # виконує 

файл відповідним застосуванням 

05. ехесі ( г' с: \ІлІіпсІоіл/5\І\ІоіерасІ. ехе' , 1 

с: \Руііюп27\КЕА0МЕ.іхі' ) # виконує файл, замінює 

поточний процес 

ргіпі; "ііеііо" # ця команда вже не виконається 


5144 

Ьеііо 

0 

и/огісі 

5іаіи5= (820., 0) 

8иЬргосе88 - керування підпроцесамн 

Процес - це об’єкт операційної системи, який описує програму, 
що виконується. Процес є контейнером, який містить такі ресурси 
як ідентифікатор процесу, образ виконуваного машинного коду 
програми, пам’ять, дескриптори ресурсів ОС, атрибути безпеки, 
стан процесора, потоки процесу. Модуль 8иЬргосе88 дозволяє 
створювати нові процеси, під’єднуватись до їх іприі/оШриі/сггог 
каналів та отримувати їхні коди завершення. Цей модуль 
призначений для заміни кількох старих модулів і функцій 
(05.5у5іет., 05.5раіл/п*; 05.рореп*, рореп2.*; 

соттапсІ5. *). 

ІтрОГІ 51іЬрГОСЄ55 
р=5иЬргосе55. Рореп( [ ' поіерасі' , 

г ■ с :\Ру1:Ноп27\КЕА0МЕ.-Схі:' ]) # повертає об'єкт Рореп, 
який являє собою новий процес 

ргіпі р.іл/аіі() # чекає його завершення, повертає код 
завершення 


79 








#ргіпї зиЬргосезз.саіі(г 'поїерад 
с:\РуїЬоп27\НЕАОМЕ.іхі') # те саме 

ргіпі зиЬрпосезз.са11( мег ' , зЬе11=Тгие) # те саме в 

консолі 

ргіпі: зиЬрпосезз. сЬеск_оиіриі( ' руіЬоп -с "х=1\пргіпі 

х"' ) # виконує команду і повертає її виведення 
# або 

р = зиЬрпосезз.Рореп( 'руіЬоп -с "ргіпі: 1+1" , 
5іс1ои1:=5иЬргосе5 5. РІРЕ) 
ргіпі р. зіЬоиІ:. геасІ() 

р = зиЬрпосезз . Рореп( ' руіЬоп ' , 5ісІіп=5иЬргосе55. РІРЕ , 
5І:Ьои1:=5иЬргосе55. РІРЕ, 5ісІегг=5иЬргосе55. РІРЕ) # 

новий процес 

ои1: ^ егг = р. соттипісаіе("ргіп1: 1+2') # посилає дані 
в зїдіп процесу 

ргіпі ои^ егг # і читає дані з зїдоиї і зіс/егг 


0 

МІСГОЗОІІ ІЛІІПСІОІл/5 [\/ЄГ5ІОП 6.1.7601] 
0 
1 
2 
з 


зиЬргосезз - міжпроцесова взаємодія 
таіп.ру - модуль клієнта 

Міжпроцесова взаємодія (англ. ІРС) - це обмін даними між 
процесами. Як правило реалізується засобами ОС. До методів ІРС 
належать: файли, неіменовані і іменовані канали, черги 
повідомлень, сигнали, спільна пам’ять, сокети і файли, що 
відображаються в пам’ять. В прикладі створюється канал між 
стандартними потоками введення/виведення/помилок 


80 





(«Ісііп/кісіоиі/8ІСІЄГГ) процесів. Цей модуль створює новий процес 
8егуег.ру, відсилає йому дані на 8Іс1іп та отримує дані з його 8ЙоиІ. 

ітрогі зиЬргосезз^ ріскіе 
сІа1:а=[ ' А' , ' В' , 'С' ] # дані 

з = ріскіе.сіитр5(сІа1:а) # серіалізувати список в рядок 
5=5 . епсосіе ( " 5ігіп§_є5сарє" ) # перетворити в рядковий 
літерал Руіііоп (без "\п") 

р=5иЬргосе55. Рореп( [ " руіііоп ", "зе г\/еп. ру" ]5ІІСІіп = 
5иЬргосе55. РІРЕ, 5ісІоиі= зиЬргосезз. РІРЕ, 5ісІегг= 
5иЬргосе55. РІРЕ) # створити процес 
зісіоиі; зісіегг = р.соттипісаіе(іприі=5) # надіслати 

дані в 5ідіп і отримати дані з зідоиі, чекати 
завершення процесу 

5=5ісІоиі.сІесосІе("5ігіп§_е5саре") # перетворити з 
рядкового літералу Руіііоп 

ргіпі ріскіе. 1оасІ5 (б) # перетворити в список 


[ ’ А 1 л ’В 1 , ’С, ' 0 '] 


8ЄГУЄГ.РУ - модуль сервера 

Модуль отримує дані від клієнта через 8Єсііп та відсилає їх назад 
через 8І(1оиі 

ітрогі ріскіе^уз 

# / тут заборонено використовувати ргіпі 

5=5у5.5І:сііп.геасі(). сієсосіє( '5ігіп§_е5саре' ) # 
перетворити з рядкового літералу Руіііоп 

сіаіа = ріскіе.Іоасіз (б) # перетворити в список 
сіаіа. аррепсІ( 'Р' ) # додати дані 

5=ріск1е.сІитр5 (сіаіа) # серіалізувати список в рядок 
5=5 . епсосіе( " 5ігіп§_е5сарє" ) # перетворити в рядковий 
літерал Руіііоп (без "\п") 

5у5 . зісіоиі. \л/піі:е (5) # записати в зідоиі 


81 




ІЬгеай - створення багатьох потоків керування 


Потоком виконання називають частину процесу, яка може 
виконуватись паралельно з ін ш ими потоками цього процесу і 
використовувати спільні з ними ресурси. Синхронізація потоків і 
процесів - це механізм, який перешкоджає одночасному їх 
зверненню до спільно використовуваних ресурсів. Модуль іЬгеасІ 
забезпечує низькорівневі (на відміну від 1:1ігеасііп§) примітиви для 
роботи з багатьма потоками. В прикладі створюються 4 потоки, які 
виконують функцію -р. Звернення потоків до спільного списку А 
синхронізовано за допомогою простого об’єкта блокування 
а11оса1:е_1оск. Нижче показані результати роботи програми з 
цим об’єктом і без нього. Зауважте, що в СРуіЬоп існує глобальне 
блокування інтерпретатора ОІоЬаІ ІпГегргсГсг Ьоск (СІЬ), яке являє 
собою механізм синхронізації потоків, що не дозволяє в один 
момент часу виконуватись більше ніж одному потоку. Тому 
застосовуйте модуль ти 11 :іргосез 2 Іп§, якщо програмі потрібно 
задіяти для обчислень кілька процесорів. А багатопотоковість 
краще застосовувати у випадку багатьох одночасних задач 
введення-виведення. 


ітрогі: ІіИгеасІ^ -Сіте 

сІе-Р -Р(і): # функція виконується в окремому потоці 

тиігех.асриіпе() # блокувати (лише один потік може 
виконуватись в один і той самий момент часу) 

А.аррепсІ(і) 
кіте.зіеер(і) 

А.аррепсі(і) 

тиііех. ге1еа5е() # розблокувати 
Т[і]=1 # повідомити головному потоку, що потік 
завершився 

А=[] # глобальний список 

Т=[0, 0,0,0] # глобальний список (якщо потік 'і' 


82 





завершився, то Т[і]=1) 

тиііех = іЬгеасІ.а11оса1:е_1оск( ) # створити блокуючий 
об' єкт 

■Рог і іп пап§е(4): # створити 4 потоки 

ІіИгеасІ.5І:аг1:_пеіл/(-Р, (і, )) # стартувати потік 'і' 
иііііе 0 іп Т : # поки усі потоки не приєднаються 

разз # тут головний потік може робити щось своє 

рг і пі: А 


[ 0 , в, 1, 1, 2, 2, З, 3 ] 

[ 0 , 1, 2 , З, 1, 3, 2 , 0 ] 

ІЬгеас1іп§ - високорівневий інтерфейс потоків 

Цей модуль створює високорівневі інтерфейси потоків на 
основі низькорівневого модуля ЦігеасІ. Потоки описуються 
нащадком класу іЬгеасІіп§.ТЬгеасІ, а їх активність 
перевизначеним методом піп. В прикладі створюються 4 потоки, 
які виконуюють код в методі піп. Звернення потоків до спільного 
списку А синхронізовано за допомогою простого об’єкта 
блокування ЦіпеасІіп§. І_оск. Нижче показані результати роботи 
програми з цим об’єктом і без нього. Додатково створюється потік, 
який стартує через 2 секунди і додає в список А рядок ‘Іітег’. 

ітрогі НігеасІіп§, Ште 

с1а55 ТЬгеасІ(1:ІігеасІіп§.ТЬгеасІ): # успадкований від 

ібгеадіпд.Тбгеад 

сіе-р _ іпії:_(БЄІ-Р, і): # конструктор 

5 е1-Р.і=і # ідентифікатор потоку 

НігеасІіпб.ТИгеасІ._ іпії:_(зеї-р) # виклик 

конструктора базового класу 

Сіе-Р гип(БеІ-Р): # забезпечує логіку потоку 

тиіех.ас^иі^е() # блокувати (лише один потік 
може виконуватись в один і той самий момент часу) 
#зетарбоге.асриіге() # або так 

83 








А.аррепб(БЄІ-р.і) 

Піше. 5Іеер(1) 

А.аррепсІ(БеІ-Р.і) 

тиНех.ге1еа5е() # розблокувати 

#зетарбоге.геіеазе() # або так 

тиНех = НІігеасІіп§. І_оск() # те саме що 

ібгеад. аііоса±е_іоск() 

#5етарЬоге=±Ьгеадіпд.5етарЬоге(1) # або семафор 
(тільки 1 потік одночасно) 

А= [] # глобальний список 
Т=[] # список потоків 
■Рог і іп гап§е(4): # створити 4 потоки 
1:=ТИгеас1 ( і ) # створити потік 
И.БНагНО # виконати метод гип в потоці 
Т.аррепсІ(И) # додати в список потоків 
і: = НЬгеасІіп§.Тітег(2.0, ІатЬсІа: А.аррепб( Нітеп )) # 
створити потік, 

1:. 5І:а пі: () # який стартує через 2 с 

Т . аррепсі (1: ) 

■Рог X. іп Т: 

И.;]’оіп() # поки усі потоки не приєднаються 
ргіпН А 


[0, 0, 1, Чітег ', 1, 2, 2, З, 3] 

[0, 1, 2, 3, 2, 3, 1, 0, 'Пітер'] 

тиКіргосе88Іп§ - підтримка багатох процесів 

тиШрГОСЄ88ІП§ - це пакет, який підтримує створення процесів з 
використанням АРІ, який подібний на АРІ модуля іЬгеас!іп§. 
Забезпечує локальний і віддалений паралелізм, ефективно долає 
СІЬ шляхом використання підпроцесів замість потоків. В приклад 
розпаралелюється задача знаходження квадратів 50 матриць 
1000x1000 за допомогою класу Роїі і його методу тар. Зауважте, 
що виграш в продуктивності буде досягнуто тільки на 

84 





багатопроцесорній системі. Виконайте програму послідовно в 
паралельному і звичайному режимах так: 

руіЬоп таіп.ру 
руійоп таіп.ру з 

Для визначення продуктивності програми використано модуль 
іітеіі:. В \Уіпс1о\У8 можна також використати команду: 

есйо %ііте% & таіп.ру & саіі есйо % Л ііте% 


ітрогі питру аз пр 

-Ргот ти1іірпосе55іп§ ітрогі Рооі # задіяти багато 

процесів 

#^гот тиіііргосеззіпд.сіитту ітрогі Рооі # або задіяти 
багато потоків 

ітрогі зуЗ; іітеіі 

сІе-Р -Р(х): # функція,, яка виконується в кожному 
процесі 

геіигп х*х 

і-р _пате_ == '_таіп_' : 

ііте = іітеіі. сІе-Раи11:_1:ітег() 

Х=[пр.та1:гіх(пр. гапсіот. гапс!(1000, 1000) ) іог і іп 
гап§е(50)] # 50 матриць 1000x1000 

і-р 'з' іп зуз.аг§у: 

У=тар(-Р,Х) # застосувати / для кожного у X 
(тільки 1 процес) 

еізе: 

р=Роо1(4) # створити пул 4-х процесів 
У=р.тар(-р., X) # задіяти 4 процеси 

ргіпі Ііітеіі:. с!е-Раи11:_1:ітег() - ііте 


9.77497753973 

15.1325679658 


85 



тиШргосе88Іп§ - запуск паралельних задач 

Аналог прикладу сопсиггепіТиШгек на основі тиШргосе88Іп§. 
Тут функціям Ргосе55Роо1Ехеси1:оп, зиЬтіІ:, гезиіі:, тар 
відповідають Рооі, арр1у_азупс, §е1і, тар. 

ітрогі ііте 

■Ргот ти11:іргосе55Іп§ ітрогі: Рооі 

сіе-р Т(х): # функція,, яка буде виконуватись в окремих 
процесах 

ііте.5Іеер(х) # затримка (тільки для тестування 
паралельності) 

геіигп х 

і-р _пате_ == '_таіп_' : 

рооі = Роо1() # пул процесів 

а = рооі. арр1у_азупс (-Р, [4]) # АзупсКезиіі 

Ь = рооі.арр1у_азупс(-Р^ [2]) 

мііііе апу([а,Ь]): # отримати результати 

асинхронно 

і-Р а апсі а.геасІу(): ргіпі а.§еі(); а=РаІ5е 
і-Р Ь апсі Ь.геасІу(): ргіпі Ь.§еі(); Ь=РаІ5е 

#ргіпі рооі .тар(ф : } [1^]) # або чекати усі 
результати 


2, 4 


тиШргосе88Іп§ - міжпроцесова взаємодія 

Для обміну об’єктами між процесами можна використовувати 
черги (()иеие), канали (Ріре), спільну пам’ять (\/а1ие, Аггау). Клас 
Мапа§ег створює об’єкт, що контролює серверний процес, який 
зберігає об’єкти РуїЬоп і дозволяє іншим процесам використовувати 
їх. Використання об’єктів Мапа§ег більш гнучке, ніж об’єктів 
спільної пам’яті, так як вони можуть підтримувати об’єкти 
довільних типів. Але вони більш повільні. У прикладі за допомогою 


86 



Мапа§ег створюється список, у який базовий і дочірній процес 
паралельно додають елементи. 


■Ргот ти11:ірпосе55Іп§ ітрогі: РгосезЗ; Мапа§ег 

сіе-р -Р(Ь) : # функція, що виконується в окремому 
процесі 

І_.аррепсІ(4) 

ІР _ пате_ == ' _таіп_' : 

тапа§ег = Мапа§еп() # менеджер 
І = тапа§ег.1ізР([1,2]) # спільний для процесів 
список 

р = Ргосе55(1:аг§е1:=Р, аг§5=(1_, )) # новий процес 
р.5І;аг1;() # стартувати процес (робота з і 
розпаралелюється) 

І-.аррепсІ(З) 

р.]ОІп() # приєднати процес 

ргіпР 1. 


[1, 2, 3, 4] 

яоскеі - низькорівневий мережевий інтерфейс 
яегуег.ру - модуль сервера 

Модуль ьоскеї: забезпечує доступ до АРІ сокетів В5Ю. 
Доступний для багатьох сучасних ОС. Найчастіше 
використовуються такі функції як ьоскеї: (створити кінцеву точку 
з’єднання), Ьіпсі (присвоїти сокету адресу), Іізіїеп (режим 
очікування вхідних повідомлень), ассері: (прийняти з’єднання), 
соппесі: (установлює з’єднання), зепсі (надсилає дані), гєсу 
(приймає дані). Нижче наведено модуль однопотокового сервера з 
адресою ‘ 127.0.0. Г і портом 50007. Сервер отримує дані через 
мережу від клієнтів та відсилає їх назад. Для виконання прикладу не 
потрібно наявності віддаленої машини, так як сервер і клієнт будуть 
виконуватись на одній ма ш ині (адреса ‘ 127.0.0.Г або МосаІЬоМ’ або 
” означає цей комп’ютер). Виконайте цей модуль командою 


87 



руіНоп 5ЄГУЄГ. ру, а в іншому консольному вікні введіть руіНоп 
сііепі. ру. 

ітрогі: зоскеї: 

■Ргот зоскеіРіїеІО ітрогі: уупіііє геасі 
з = зоскеї:.зоске1:(50ске1:.АР_]ЖТ, зоскеї:. 50СК_5ТКЕАМ) 

# відкрити сокет типу ТСР/ІР 

з.ЬіпсІ(( 1 ІосаІЬозІ: 1 , 50007)) # зв'язати сокет з 
локальною адресою і портом 

з.1із1:еп(1) # дозволити не більше 1 з'єднання з 
клієнтом 

мРіііє Тгие: # цикл 

зос, асИг = з.ассеріО # чекає з'єднання з 
клієнтом, повертає об'єкт сокета та адресу і порт 
клієнта 

ргіпі 'Бєгуєг із соппесіесі іо сііепі:^ асісіг 
х=зос.гесV( 255 ) # отримати з сокета рядок 
довжиною не більше 255 
#х=геад(вос) # або 
ргіпі: ' Сііепі: ' , х 
зос. зепсіаіі(х) # надіслати рядок 
#шгііе(зос,х) # або 

зос.сІозеО # закрити з'єднання з клієнтом 
і-р х== ' Епсі' : Ьгеак # якщо отримано такий рядок, 
то завершити цикл 


Бєгуєг із соппесіесі ІО СІІЄПІ 
Сііепі: А 

Бєгуєг із соппесіесі ІО СІІЄПІ 
Сііепі: В 

Бєгуєг із соппесіесі іо сііепі: 
Сііепі: С 

Бєгуєг із соппесіесі іо сііепі: 
СНепі: Епсі 


(’127.0.0.1’, 
(’127.0.0.1’, 
('127.0.0.1', 
('127.0.0.1', 


50827) 

50828) 

50829) 

50830) 


88 



сііепі.ру - модуль клієнта 

Надсилає дані через мережу серверу з адресою ‘ 127.0.0. Г і 
портом 50007 та отримує їх назад. 

ітрогі зоскеі 

ігот зоскеіРіїеІО ітрогі: игііЄ; геасі 

■Рог х іп ['А','В ^ С , ЕпсГ ]: # дані ^ що будуть 

відсилатись 

з = зоскеі. 50скеі(50скеі. АР_]ЖТ, 
5Оскеі.50СК_5ТКЕАМ) # відкрити сокет типу ТСР/ІР 

5. соппесі(( '127.0.0.1' , 50007)) # з'єднати сокет 
з сервером 

5. зепсіаіі(х) # надіслати рядок 
#мгііе(з,х) # або 
х=5 .гєсу(255) # отримати рядок 
#х=геад(з) # або 

ргіпі ' Бєгуєг: ' , х 
з.СІ05Є() # закрити сокет 


Зєгуєг: А 
Бєгуєг: В 
Зєгуєг: С 
Зєгуєг: ЕпсІ 

яоскеїГіїеІО.ру - читання і запис об’єктів РуІЇюп через сокет 

Нижче наведено код модуля зоскеіРіїеІО.ру з функціями 
мгііе і геасі, які дозволяють відсилати чи отримувати об’єкти 
Руїйоп по мережі через сокети. В модулях зєгуєг .ру і сііепіі.ру 
розкоментуйте виклики цих функцій і закоментуйте виклики 
зепсіаіі та пєсу. 


ітрогі ріскіе 

сіе-р \л/гііе(50с., оЬ]): 


89 






"Відсилає об'єкт оЬз через сокет зос" 

-р = 50с.таке-Рі1е( ’іл/Ь' ) # створити файл ) 
асоційований з сокетом 

ріскіе.с!итр(оЬ ], і, ріскіе.НІСНЕ5Т_РК0Т0С0І.) # 

серіалізувати оЬ] в файлі 

■р. СІ05Є() # закрити файл 

сіе-р пеасі(50с): 

"Повертає об'єкт, отриманий з сокета з ос" 

-р = 50с .такеРі1е( ' гЬ' ) # створити файл, 
асоційований з сокетом 

оЬ] = ріскіе.ІоасІ(-Р) # десеріалізувати оЬ ^ з 
файлу 

■р. сіозе() # закрити файл 

геіигп оЬ] 


8оскеі8егуег - каркас для мережевих серверів 

Високорівневий модуль 5оске1:5егуеп спрощує задачі 
створення мережевих серверів. Для створення власного обробника 
мережевих запитів потрібно успадкувати клас 
ВазеКериезІїНапсІІег і перевизначити метод ІіапсІІе. В прикладі 
на основі 5оске1:5егуег створено багатопотоковий сервер з 
адресою ‘ 127.0.0. Г і портом 50007. Сервер отримує дані через 
мережу від клієнтів та відсилає їх назад. Для тестування 
багатопотоковості запустіть цей сервер руіЬоп зегуепї.ру і 
кілька клієнтів руійоп сііепі:. ру. В диспетчері завдань \УіпсІо\У8 
7 можна побачити, як змінюється кількість потоків процесу сервера. 

ітрогі 5оске1:5егуег, ііте 

■Ргот зоскеіРіІеІО ітрогі уупіііє пеасі # якщо потрібно 
сіазз 

МуСІіепіНапсІІег (БоскеіВегуег.ВазеКериезіНапсІІег): # 

клас обробника запитів 

сіе-р ЬапсИе(5е1-Р): # обробляє запити 


90 








(перевизначений) 

рпіпі: зеї-р .с1іеп1:_асІсІге55 # показати адресу 

клієнта 

х=5ЄІР. гериезі:. гєсу(255) # отримати рядок 
#х=геад(зеі^.гериезі) # або 

ргіпі: ' Сііепі:: ' , х 

Ріте.5Іеер(10) # затримка (для тестування 
багатопотоковості) 

зеї-р. пеяиезі:. зепсіаіі(х) # надіслати рядок 

#\лгі±е(зеі^.гериезі,х) # або 

зеї-р. гериезі:. с1озе( ) # закрити з'єднання з 

клієнтом 

# створити багатопотоковий ТСР сервер з обробником 
МуСііепіНапдіег 

зєгуєг = 5оске1:5егуег .ТбгеасІіп§ТСР5егуег( ( , 50007); 

МуСНепІНапсІІеп) # порт 50007 або порт 0 (довільний 

незайнятий порт) 

їгу: 

5єгуєг.5єгує_-Рогєуєг() # обробляти запити вічно 
ехсері: КеуЬоагсІІітІїеггирІ: : # якщо натиснуто Сігі-С 
5ЄГУЄГ.зЬи1:сіои/п() # зупинити сервер 


ССІНТТР сервер 

Веб-сервер — це програма, яка приймає НТТР-запити від 
клієнтів (зазвичай веб-браузерів) і видає їм НТТР-відповіді, як 
правило, з НТМЬ-сторінкою. Протокол передачі гіпертексту НТТР 
описує НТТР-повідомлення, які складаються з стартового рядка 
(тип повідомлення), заголовків (параметри транзакції НТТР) і 
необов’язкового тіла (наприклад з даними НТМЬ). НТТР- 
повідомлення можна переглянути, наприклад, в браузері Рігеїох 61 
в меню веб-розробка/мережа. Приклад НТТР-запиту типу СЕТ до 
ресурсу /ЬеІІо.ЬітІ. 


91 





СЕТ /Иеііо.ЬЕтІ НТТР/1.1 
Нозі:: ІосаІИозЕ 
(пустий рядок) 

Метод СЕТ використовується для запиту вмісту вказаного 
ресурсу, а метод Р08Т - для передачі даних вказаному ресурсу. 
Приклад НТТР-відповіді сервера з кодом стану 200 (виконано): 

НТТР/1.0 200 ОК 
СопЕепЕ-Еуре: ЕехЕ/ЬЕтІ 
(пустий рядок) 

< Ітііт 1 > < Ьосіу >Не 11о< / Ьосіу > < / ИЕтІ > 

В прикладі створено ВазеНТТРБегуег.НТТРБ єгуєг сервер з 
підтримкою запитів СЕТ, НЕАО, Р08Т і СОІ-програм. В даному 
випадку усі ССІ-програми повинні бути розташовані в каталозі с§і 
поряд з сервером. Запустіть сервер та в адресному рядку браузера 
введіть: 

ЬЕЕр: //ІосаПіозЕ/ЬеНо. ЬЕтІ 


ітрогЕ 05 , зуз 

ІтрогЕ ВазеНТТРБегуег, ССІНТТРБєгуєг 

іл/іЕіі ореп('ііе11о.ІіЕт1 , 'и ) аз Е: # створити 

документ НТМІ 

Т.іл/гіЕе( " <ЬЕт1>< Ьосіу >Не11о</Ьосіу ></бЕт1>" ) 
сіазз НапсІ1ег(ССІНТТР5егуег.ССІНТТРКериезЕНапсЛег): # 

обробник запитів 

с§і_біпесЕогіез = ["/с§і"] # каталог з С6І- 

програмами 

згугасісіг = ( ' ІосаІІюзЕ' , 80) # ім'я хоста, номер 
порто 

згугоЬ] = ВазеНТТРБегуег. НТТРБєгуєг (згугасісіг, 

НапсІІег) # сервер 

згугоЬ]. зепуе_Еогеуег() # обслуговувати клієнтів до 
завершення 


92 



© ІосаІИозІ/ИеІІо.ИїтІ 




Неііо 

Рисунок 2 - Результати роботи сервера 

ССІ-програма зітріе.ру - генерація форми запиту 

ССІ (Соттоп Са[с\\ау Ітсгїасс) - стандартний протокол для 
взаємодії програми веб-сервера із зовнішньою консольною 
програмою (ССІ-програмою або шлюзом). Після запиту клієнта 
ССІ-програма виконується сервером в окремому процесі, обробляє 
дані запиту і генерує відповідь сервера. Будь-яка ССІ-програма 
повертає в стандартний потік виведення заголовок НТТР, пустий 
рядок і дані. Запустіть сервер та в адресному рядку браузера 
введіть: 

ІтЬІір: //Іоса Ніобії/ с§і/з ітріе. ру 

Для тестування методу СЕТ справте нижче теСюс^" розі" на 
те1:ЬосІ="§е1:". 


Иііт1= .< Піїті ><Ьосіу> 

с-Рогт ас1ііоп="/с§і/£е1і_ро5Іі.ру" те1:ПосІ="роз1:"> 

Рігзіі №те: сіприіі 1іуре="1іех1і" пате="-Рігз1і_пате"><Ьг 
/> 

Базі: №те: <іприї: 1уре='Чехії" пате="1аз1і_пате" /> 
<іпри1: 1:уре="зиЬті1:" уа1ие="5иЬті1і" /></-Рогт> 
</ЬосІух/Міт1>.. 

ргігтС'СопІіепІі-Ііуре : 1іех1і/Пііт1\г"# заголовок 
ргіп1Т'\г"# пустий рядок 
ргіпії Ітіті # дані 


93 






<- -> е <& 


© ІосаІЬо5І/сді/5ітрІе.ру 


Уоіосіутуг 


Ріг$1 Кате: 


Ьазі Кате: |кореу 


БиЬтії 


Рисунок 3 - Результати роботи ССІ-програми зітріе.ру 

ССІ-програма §еІ_ро$1.ру - обробка запитів СЕТ і Р08Т 

ССІ-програма може отримати доступ до рядка запиту (даних 
форми) за допомогою с§і. Ріе1сІ51:ога§е. Запустіть сервер та в 
адресному рядку браузера введіть для тестування методів СЕТ і 
Р08Т, відповідно: 

ІтСЬр: //1оса1Ьо5І:/с§і/§е1:_ро5І:. ру ?-Рігз1:_пате=\/о1осіутуг 
&1аз1:_пате=Кореу 

ІтЬІір: //1оса1Ьо5І:/с§і/§е1:_ро5І:. ру' 

Або, якщо форма розташована у файлах НТМЬ, відповідно: 

ІтЬіір://1оса1Ио5І:/СЕТ. НЕтІ 
Иі:і:р: //ІосаІНозІї/РОБТ. ЬЕтІ 


ітрогі: с§і # модуль для обробки сді 

■Ропт = с§і.Ріе1сІ51:ога§е() # об'єкт РіеідЗіогаде 
■Ріг5І:_пате = -Рогт.§е1:уа1ие( -Ріг5І:_пате ’ ) # дані з 

першого поля 

1аз1:_пате = -Рогт.§е1:уа1ие( Іаз^пате’) # дані з 
другого поля 

ргіп1:"Соп1:еп1:-1:уре : їехї/ІтІ:т1\г\п\г\п"# заголовок, 
пустий рядок 

рпіігІ:"<Ь2>Не11о %5%5</Ь2>"% (-Ріг5І:_пате, 1а5І:_пате) 

дані 


94 










<Г -> Є <ї> 


© ІосаІИо5І/сді/деі_розі.ру 


Неііо Уоіосіутуг Кореу 

Рисунок 4 - Результати роботи СОІ-програми §е1_ро8йру 

ДУ8СІ сервер 

\¥8СІ (\УсЬ 8єгуєг Саіешау Іпіегіасе) - стандарт взаємодії між 
РуїЬоп-програмою і самим веб-сервером. За стандартом \¥8СІ веб- 
програма повинна бути об’єктом, що викликається, і приймати два 
параметра: словник змінних середовища (єпуігоп) і обробник запиту 
(8ІаЙ_ГЄ8рОП8Є). Модуль \л/5§ігеР. 5Ітр1е_зегуег реалізує 
простий НТТР-сервер, який виконує одну \У80І-програму. 
Запустіть сервер та в адресному рядку браузера введіть: 

Ьіір: //Іосаійозі/ ?пате=\/о1ос1утуг 
Ьіір: //Іосаійозі 


-Ргот \л/5§ігеР. 5Ітр1е_зегуег ітрогі таке_5егуег 
ігот с§і ітрогі: рагзе_я5, езсаре 
ігот РИ ітрогі Іта§е 
ітрогі 5ігіп§10 

Ьіт1= .<Ьіт1хЬосіу><1 : огт теііюсІ="ро5і"> 

№те: <іприі іуре="іехі" пате="пате"> 

<іприі іуре="зиЬтіі" уа1ие="5иЬтіі" 
/></іогт></ЬосІу></іііт1>.. 

сіе-р арр1ісаііоп(епуігоп, 5іагі_ге5ропзе): 

# вивести вміст деяких змінних середовища 

ргіпі ’(21ІЕКУ_5ТКІІ\ІС: ' , єпуігоп[ ’(21ІЕКУ_5ТКІІ\ІС 1 ] 
ргіпі ’КЕ(21ІЕ5Т_МЕТНСЮ: , 
єпуігоп[ 1 РЕ(}ІІЕ5Т_МЕТНСЮ 1 ] 

ргіпі ’РАТІ-МЖО: єпуігоп [’ РАТН_]ЖО ’ ] 

ргіпі 1 НТТР_АССЕРТ: 1 , єпуігоп [’ НТТР_АССЕРТ’ ] 


95 








ге5роп5е_Ьеасіег5=[ ( СопРепР-Туре ' , 'РехР/МРтІ )] 

# заголовки 

ІР єпуігоп[ '^УЕЗТ^ЕТНСЮ' ] == 'СЕТ': # якщо 
запит СЕТ 

рагатеРег5=раг5Є_р5(епуігоп[ ' (21ІЕКУ_5ТКІІ\ІС' ]) 

# парам, з рядка запиту 

ІР ' пате' іп рагатеРегз: # якщо в запиті є 
параметр 'пате' 

пате = е5саре(рагатеРег5[' пате' ][0]) # 

його значення 

гезроп5Є_Ьос1у="<Ь2>Не11о %з </И2>" % 
(пате) # тіло відп. 

еІіР єпуігоп[ ' РАТН_INРО , ]=="/ріс .рп§" : # якщо 
запит на рисунок 

іта§е = Іта§е. пе\л/( ' КСВ , (10; 10); (0; 
255; 0)) # рисунок 

оиР=5Ргіп§І0.5Ргіп§І0() 

іта§е.зауе(оиР; РогтаР='РІ\ІС ) # зберегти 

в пам'ять 

гезроп5Є_Ііеасіег5 = [(' СопРепР-Туре' ; 

' іта§е/рп§ ' )] # заголовки 

гезроп5е_Ьосіу=оиР.§еруа1ие() # тіло відп. 

(дані рисунка) 

еізе: # якщо інший запит 

ге5ропзе_Ьосіу=ІіРт1 # тіло відп. (документ 
НТМй з формою) 

ІР єпуігоп[ '(^^БІ^ЕТНСЮ 1 ] == 'Р05Т' : # якщо 
запит Р05Т 

Ргу : # змінна СОІ\ІТЕІ\ІТ_ІЕІ\ІСТН може бути пуста 
або відсутня 

геяиезР_Ьосіу_5І2Є = 
іпР(епуігоп.§еР( 'СО^Ет^І-ЕГ^ІСТИ' ; 0)) 
ехсерр (УаІиеЕгпог) : 


96 




геяиез1:_Ьос1у_5І2Є = 0 
геяие5І:_Ьос)у = 

єпуігоп[ ' іл/5§і. іприї:' ]. геасі(пеяие5І:_Ьосіу_5І2е) # тіло 

запиту, передане через форму 

рагатеїіегз = раг5е_рз(герие5І:_Ьос1у) # словник 

параметрів форми 

пате = е5саре(рагате1:ег5 [' пате ' ] [0]) # 

значення параметра 'пате' 

ге5ропзе_Ьос)у=' <И2><Іт§ 5ГС="рІС . рп§" 
а11;="ріс" >Не11о %5 </И2>' % (пате) # тіло відповіді 

5І:аг1:_пезроп5е( '200 ОКУ, гезропзе_ІіеасІег5) 
геїигп [гезропзе_Ьосіу] 

ІгЬіірсІ = таке_зегуег( 1 ІосаІИозІ: , 80^ арріісаіііоп) # 

ІЛІ5СІ сервер 

ІгЬіірсІ. 5ЄГУЄ-рОГЄУЄГ ( ) 


()ІІЕКУ_5ТКІІ\ІС: пате=\/о1осіутуп 
КЕ()ІІЕ5Т_МЕТРІ(Ю: СЕТ 
РАТН_ІМРО: / 

НТТР_АССЕРТ: Ііехі:/ІтЬт 1 арріісаіііоп/хітіїті+хті,арріісаі: 
іоп/хт!;я=0.9,*/*;я=0.8 


С й © ІосаЖой ?пате=УоІосІутуг 


Неііо УоІоДутуг 

Рисунок 5 - Відповідь на запит СЕТ 


(21ІЕКУ_5ТК]Ж: 

РЕ()ІІЕ5Т_МЕТНСЮ: СЕТ 
РАТН_INРО: / 

НТТР_АССЕРТ: ТехТ/ЬТтІ, аррИсаТіоп/хІїІітІ+хтІ, арріісаі: 
іоп/хт!;я=0.9^*/*;я=0.8 


97 









<- -> с ^ ® ІосаІМой 


N81116: |\/оІос 1 утуг 5 иЬт№ | 

Рисунок 6 - Форма для запиту Р08Т 


(21ІЕКУ_5ТК]Ж: 

РЕ(21ІЕ5Т_МЕТНСЮ: Р05Т 
РАТН_ІМРО: / 

НТТР_АССЕРТ: їехї/ІтЕтІ, арр1іса1:іоп/хітІ:т1+хт1, арріісаї: 
іоп/хт1;я=0.9,*/*;я=0.8 


(21ІЕКУ_5ТКІІ\ІС: 
КЕ(21ІЕ5Т_МЕТНСЮ: СЕТ 
РАТН_ІМРО: /ріс.рп§ 
НТТР_АССЕРТ: */* 


<г -> С їй 


© ІосаІІіоїІ 


Неііо Уоіосіутуг 


Рисунок 7 - Відсилання рисунку 


иг11іЬ2 - запити до НТТР серверів 

шТНЬ2 модуль містить функції і класи, які допомагають 
отримувати інформацію за ТЖЬ переважно від НТТР серверів. 
Підтримується аутентифікація, переадресація, соокіе, проксі- 
сервера та інше. 

ітрогі: игІІіЬ, иг11іЬ2 

иг1="Ьі:1:р: //ик.и/ікіресііа .ог§/и/ікі/%О0%9А%О0%ВЕ%О1%81% 
О1%9б%О0%В2" 

иг1=ип11іЬ2.ипяио1:е(иг1).сіесосіе( и1;-р-8") # 

перетворити І)КІ в легкий для читання формат 

ргіпі: игі 


98 












рг і пі: иг11іЬ2.яио1:е(иг1.епсос1е( ' иіі-р - 
8"),за-Ре="%/:=&?~#+!$, ;'(ЙО^]") # перетворити назад 

гезропзе = 

иг11іЬ2. иг1ореп( ' Іііір: //НііІірЬіп .оп§/§е1:?пате=ЗоІіп' ) # 
отримати відповідь за НТТР СЕТ запитом з параметром 
пате=йоТіп 

#ргіпі гезропзеЛп^о() # заголовки відповіді у 
вигляді словника 

ргіпі гезропзе. іігРо()[' Сопіепі-Туре ' ] # тип тіла 

відповіді 

ргіпі: гезропзе.геасі(і) # читати 1 байт тіла відповіді 

гезропзе.с1озе() # закрити файл 

іогт_сІаіа = игШЬ. иг1епсосІе({ ' пате г : 1 Зоїіп' }) # дані 

для відправлення 

ЬеасІег5={ ' ІІзег-А§епі' : 'Могіїїа 5.0'} # заголовки 
запиту 

гериезі = иг11іЬ2. Кериезі( ' біір://ИіірЬіп.ог§/розі' , 
іогт_сІаіа, беасіегз) # НТТР Р05Т запит з даними 
/ огт_даіа і заголовками ііеадегз 

гезропзе = иг11іЬ2.иг1ореп(геяиезі) # отримати 

відповідь 

ргіпі гезропзе.геасі(і) # читати 1 байт тіла відповіді 


Ьіір: //ик.и/ікіресііа . ог§/\л/ікі/Косів 

Ьіір: //ик.и/ікіресііа . ог§/\л/ікі/%О0%9А%О0%ВЕ%О1%81%О1%96 
%Р0%В2 

арріісаііоп/^зоп 

{ 

{ 


хті.сіот.тіпкіот - мінімальна реалізація БОМ 

ХМЬ - це стандарт побудови мов розмітки (мов, що 
використовують спеціальні анотації для розмітки тексту) ієрархічно 


99 





структурованих даних. БОМ (Ооситепі ОЬ]ссІ: Мосіеі) - це 
незалежний від мови програмування програмний інтерфейс, який 
дозволяє створювати, читати і змінювати ХМЬ документи. БОМ 
подає ХМЬ документи як деревовидну структуру, де кожен вузол є 
об’єктом, що відповідає частині документу, хіпі. йот. тім кіот - це 
мінімальна реалізація інтерфейсу БОМ, який подібний на ті, що 
використовуються в ін ш их мовах. Вона простіша ніж повний БОМ і 
суттєво менша. 

-Ргот хті.сіот ітрогі тіпійот 

################# Ооситепі ОЬ^есіз 
(тіпідот.Ооситепі()) ########## 

# створити ХМй документ з кореневим тегом 'іііті ' 

йос=тіпійот.§е1:0СШтр1етеп1:а1:іоп().сгеа1:е0оситеп1:(І\Іоп 
е, ' ІтЬтІ ’ ІМопе) 

Ьіт1=йос .йоситепіЕІетепІ: # кореневий елемент 

# або створити ХМІ документ так: 

#дос=тіпідот.Ооситепі() # ХМІ документ 

#іііті=дос. сгеаіеЕіетепі("біті")# створити кореневий 

елемент (тільки один) 

#дос. аррепдСіііід(іііті) # додати дочірній вузол (тут 
дос - вузол) 

Ьойу = йос. сгеаІіеЕІетеп'Ц ’ Ьойу 1 ) # створити елемент 
Ніші.аррепйСЬі1й(Ьойу) # додати дочірній вузол до 
іііті 

йіу = йос . сгеаіеЕІетегтЦ 1 йіу ’ ) # створити елемент 
1:х1:І\Іойе=йос.сгеа1:еТех1:І\Іойе( Техі’) # створити 

текстовий вузол 

#ргіпі іхіИоде.даіа # вміст текстового вузла 

йіу .аррепйСЬі!й(1:х1:І\Іойе) # додати дочірній вузол до 


100 





с/х V/ 

ЬосІу.аррепсІСІііІсІ(сІіу) # додати дочірній вузол до Ьоду 

################## Еіетепі ОЬдесі 5 
(тіпідот. Еіетепі()) ########### 

е1етеп1:5=сІос.§е1:ЕІетеп1:5ВуТа§№те ( 'сііу ' ) # знайти усі 
елементи з тегом дій 

#ргіпі еіетепіз[0].іохті() # вивести перший з них в 

форматі ХМІ 

є1=сііу # елемент ді\/ 

Яргіпі еіЛадМате # ім'я тегу 
еі. зе-ЬА-ЬІ:гіЬиІіе ( ' ісі ' , ' 1' ) # задати атрибути 
еі. 5ЄІ:ІсІА1:1:гіЬи1:е( ' ісі' ) # задати 10 атрибут (для 
деіЕіетепіВуІд()) 

#ргіпі еі.ЬазАіігіЬиіе( 'ід') # чи має атрибут 'ід' 
#ргіпі еі.де±АіігіЬиіе('ід') # значення атрибута 'ід' 
#ргіпі еі.деіАіігіЬиіеМоде('ід') # вузол атрибута 

еі. гетоуеА1:1:гіЬи1:е (' ісі' ) 
еі. зе1:А1:1:гіЬи1:е ( ' ісі' ' 1' ) 

е1=сІос .§е1:Е1етеп1:ВуІ(1( 1') # знайти елемент з 10=' 1' 

################# Л/ос/е ОЬдесіз (тіпідот.Йоде()) 
################## 

посіє=сііу # вузол елемента діу 

#ргіпі поде.подеМате # ім'я вузла (дій) 

#ргіпі поде.подеТуре # тип вузла (1 - Е^ЕМЕNТ_NО^Е) 
#ргіпі поде. поде\/аіие # текстове значення вузла 
#ргіпі поде. ЬазСЬіідМодезО # чи має підвузли 
#ргіпі поде.рагепіМоде # батьківський вузол 
#ргіпі поде.пехіЗіЬііпд # наступний споріднений 
#ргіпі поде.ргеиіоизЗібііпд # попередній споріднений 
#ргіпі поде. сЬіідМодез # дочірні вузли 
#ргіпі поде.^ігзіСдіід # перший дочірній 


101 




Яргіпі посіє. іазіСбіід # останній дочірній 
#ргіпі поде.ба5АіігібиіЄ5() # чи має атрибути 
#ргіпі посіє. аіігіЬиіез[ 'ід']. поде\/аіие # значення 
атрибута ід 

#ргіпі подеЛз5атеМоде(ді\/) # чи це той самий вузол 

с1оп=посІе. сІопеІМосІе(Тгие) # клонувати з підвузлами 
Ьосіу.іпзегІїВе-Роге^ІоП; сііу ) # вставити дочірній 
перед дій 

Ьосіу. гетоуеСЬіІсІ(сІоп) # видалити дочірній сіоп 
Ьосіу.аррепсІСЬі1с)(с1оп) # додати дочірній 
Ьосіу. петоуеСЬіІсі(сІоп) 

######################## хті.дот.тіпідот 
########################### 

ргіпі: сіос .1:орге1:1:ухт1( ) # вивести в форматі з 

відступами 

•р=ореп("ту. Іг£тГ , ,"м") # відкрити файл для запису 
-р.\л/пі1:е(сіос .1:орге1:1:ухт1( )) # зберегти документ 

"Р. СІ05Є ( ) 

досі = тіпісіот.рагзе( 'ту-ІтЬтІ' ) # читати ХМІ документ 
з файлу 

сІосЗ=тіпісіот. рап5е51:гіп§( ' <А>х</А> ) # читати ХМІ 

документ з рядка 

#ргіпі досЗЛохті() # вивести документ в форматі ХМІ 


<?хт1 уєг5іоп="1.0" ?> 
<Ь1:т1> 

< Ьосіу > 

< сі і V іс)="1" >Т ехі: </сі іу> 

< / Ьосіу > 

</ІтЬтІ > 


102 





хтІ.еІгее.ЕІетепіТгее - ЕІешепіТгее ХМЬ АРІ 


Модуль містить визначення типу Еіетепі - гнучкого 
контейнера, який призначений для зберігання ієрархічних структур 
даних в пам’яті. Використовується для роботи з ХМЬ і ін ш ими 
деревовидними даними. Кожен елемент має такі властивості як тег, 
набір атрибутів, тестовий рядок, хвостовий рядок, дочірні елементи. 

ітрогі хтІ.еігее.ЕІетепіТгее аз ЕТ 

#ЕТ. VЕК5I0N # версія бібліотеки 

гооі: = ЕТ.ЕІетепіС'гооІ:") # створити кореневий 

елемент 

#гооі = ЕТ.ХМІ("<гооіх/гоо1:>") # або створити з 
тексту 

ргіпі: ЕТ.1 :о5і:гіп§(гоо1:) # текст елемента 

( "<гоо1:></гооі> ") 

ргіпі: гооі.1:а§ # тег елемента 

гооі:.аррепсІ(ЕТ. Еіетепі:( "опе" )) # додати піделемент з 
таким тегом 

1:\л/о=ЕТ.5иЬЕ1етеп1:(гоо1:, "іию") # або так 
ііл/о.аіігіЬІУ'-ЕігзІ:"] = "I м # створити атрибут елемента 
ііл/о.іехі: = "іехі:" # текст в елементі 
і\л/о_опе=ЕТ.5иЬЕ1етеп1:(1:\лЮ; "1:\л/о_опе' ) # додати 
піделемент 

1:іл/о_опе.1:аі1="1:ех1:" # текст після елемента 

гооі:. іпзег1:( 0, ЕТ. Еіетепі:( "гего" )) # вставити елемент 

в позицію 

гооі:. гетоуе(гоо1: .ТіпсІ ( ’іего" )) # знайти перший 
піделемент з таким тегом і видалити його 
ез=гоо1:.1 : іпсІа11("опе") # знайти всі піделементи з 
таким тегом 

ез=гоо1:.1 : іпсІа11(" .//опе") # знайти за шаблоном: 

#'іад' - відповідає елементам верхнього рівня з тегом 
іад 

#'рагепі/іад' - відповідає елементам з тегом іад } 
якщо вони дочірні для рагепі 

103 





- будь-які дочірні елементи 
' - починає пошук з поточного вузла 
#'//' - відповідає всім вкладеним елементам на всіх 
рівнях нижче рівня вказаного елемента 
іхі=гооі.-РіпсІіехі( "і\л/о" ) # знайти текст першого 
піделемента з таким тегом 
рг і пі: Іеп(гооі) # кількість піделементів 
ргіпі гооі[1] .іа§ # тег другого елемента 
рг і пі: гооі[1]. аіігіЬ # атрибути другого елемента 
(словник) 

посієб = гооі[:] # усі піделементи або 
гооі. деісіііідгеп() 

■Рог посіє іп гооі: # цикл по піделементам 

ргіпі: посіє.іа§ 

ргіпі ЕТ.і05ігіп§(гооі) # вивести як ХМІ 

ігее = ЕТ.ЕІетепіТгее(гооі) # дерево елементів 
ігее.\л/гііе("ра§е.хт1") # зберегти у файл 

ігее2 = ЕТ.Е1етепіТгее() # або відразу 
ЕТ.ЕіетепіТгее("раде.хті") 

ігее2.рагзе( 'ра§е.хтГ ) # читати з файлу 
5иЬе1=ігее2.§еігооі() [0] # перший піделемент 
5ііЬігее=ЕТ.Е1етепіТгее(5иЬе1) # піддерево 

■Рог рагепі іп ігее2.§еіііегаіог(): # показати все 
дерево 

#або деіііегаіог("іадпате") - для заданих тегів 
ргіпі рагепі.іа§^ 

# /ог сЬіід іп рагепі: 

# ргіпі ' ' *5+сЬіід.іад 


<гооі /> 
гооі 


104 





2 

ІПл/О 

{ , -Рі^51: , : ' 1' } 

опе 

ІПл/О 

сгооііхопе /хіил/о Рігз1:="1">1:ех1:<1:\л/о_опе />1:ех1:</1ил/о> 
</поо1:> 

гооі: опе РілЮ 1плю_опе 

НТМЬРагзег - простий парсер НТМЬ і ХНТМЬ 

Цей модуль визначає клас НТМЬРагзег, який служить як основа 
для синтаксичного аналізу файлів НТМЬ і ХНТМЬ. Для парсингу 
необхідно створити похідний від НТМЬРагзег клас і перевизначити 
його методи. У РуїЬоп 2.7 працює також з некоректними Ьіті. Для 
високопродуктивного парсингу використовуйте Іхті (з ЕІетепіТгее 
АРІ) або Веаийіиі 8оир. 

-Ргот НТМІ-Рагзег ітрогі: НТМІ-Рагзег 

сіазз МуНТМІ-Рагзег(НТМІ-Рагзег): # успадковує 
НТМІ-Рагзег і перевизначає його методи^ шукає дані 
усіх тегів <р> 

сіе-р _іпії:_ (зеї-Р): # конструктор 

НТМІ-Рагзег._ іпіЬ_ (зеї-Р) 

5е1Р.іп1:а§ = Раїзе # в середині тегу? 
зеї-Р.сІаРа = [] # список знайдених даних 
сіе-р ЬапсЛе_5І:аг1:1:а§(зе1-Р1:а§, аРЬгз): 

"Викликається коли знайдено початковий тег 
(наприклад <р>)" 

ргіпі: "Початковий тег'Д 1:а§ 
ргіпЬ "Атрибути'^ аЬЬгБ 
ІР 1:а§== ' р ' : # якщо тег р 

зеІТ. іп1;а§=Тгие # знаходимось всередині 

тегу 

сіе-р НапсІ1е_епсІ1:а§(5е1-Р; 1:а§): 


105 





"Викликається коли знайдено кінцевий тег 
(наприклад </р>)" 

ргіпі "Кінцевий тег:", іа§ 
і-р 1:а§== ' р ' : # якщо тег р 

5е1"Р. іпіа§=РаІ5Є # знаходимось поза тегом 
Р 

сіе-р ЬапсІ1е_с1а1:а(5е1-Р, баіа): 

"Викликається коли знайдено дані ... 
(наприклад <р>...</р>)" 

ргіпі "Дані: , сіаіа 

і-р 5ЄІ"Р . іпіа§: # якщо в середині тегу р 

зеї-р.сіаііа.аррепсІ(сІа1:а) # додати в список 

результатів дані 

рагзеп = МуНТМІ-Раг5Єг() # об'єкт класу 
Ьі:т1=" "" < Иііті >< Ьосіу > 

<р аіі§п="]и5І:і-ру">Текст</р> 

<а Ьге-Р="іпс)ех. Іі1:т1">Індекс</а> 

</ЬосІу></Іт(:т1>""" # документ Р/7Ж для парсингу 
рагзег .-Рееб(ІгІ:т1) # виконати парсинг 
рагзеп.с1озе() 

ргіпі "\пЗнайдені дані:', рагзег.сіаііа[0] 

#рагзег. Ьапдіе 5±аг±±ад( ' а ', /“("Дге/', "іпдех.біті")]) 


Початковий тег біті 
Атрибути [] 

Початковий тег Ьосіу 
Атрибути [] 

Дані: 

Початковий тег р 

Атрибути [('а1і§п', ' зизіі-ру') ] 

Дані: Текст 

Кінцевий тег: р 

Дані: 


106 





Початковий тег а 

Атрибути [('Ьге-Р', 1 іпсіех. Ніші') ] 

Дані: Індекс 
Кінцевий тег: а 
Дані: 

Кінцевий тег: Ьосіу 
Кінцевий тег: біті 

Знайдені дані: Текст 

Ткіпіег - проста програма з графічним інтерфейсом 

Модуль Ткіпіег - це інтерфейс до Тсі/Тк (скриптової мови Тсі 
та її бібліотеки Тк) для мови РуїЬоп. Використовується для 
створення кросплатформних програм з графічним інтерфейсом 
(ОШ). Якщо не потрібно, щоб програма показувала Б08 вікно, 
змініть її розширення з .ру на ,ру\\’. 

■Ргот Ткіпіег ітрогі * # імпортувати все з модуля 
Ткіпїег 

сіе-р Виі1:оп1С1іск(): # функція ^ яка викликається під 
час натиску на Виїіопі 

х=-Р1оа1:(5.§еі:()) # присвоїти х' значення 'з' 
5.зе1:(х**2) # установити 'з' значення х**2 
пооі: = Тк() # головне вікно програми 

гооі:.і:іі:1е( 'Бітріе СІЛ арр') # надпис на вікні 
гооі. пе5І2аЬ1е(\л/ісІ1:Ь=ТКк)Е_, Ьеі§ІтІ:=РАІ-5Е) # дозволити 
зміну розміру вікна по ширині 
гооі.^еотеІігуС'гОбхІБО+О+б") # розмір вікна 
Ви1:1:оп1=Ви1:1:оп(гоо1:, 1:ех1:="5(2К", 

соттапсІ=Ви1:1:оп1С1іск) # створити кнопку^ пов'язати з 
функцією соттапді 

Виііопі. ріасе(геіх=0.6, геіу=0.5, ге1\л/ісі1:И=0 .3 ^ 
ге1Ьеі§Ьі:=0.1) # розташувати на вікні 


107 





#Виііоп1 .раск(зіде=ВІСНТ) # або розташувати на вікні 
справа 

з=51;гіп§\/аг() # створити рядкову змінну 

Епіігуі = Еп1:гу(гоо1:,1:ех1:уагіаЬ1е=5. ( \л/ісІ1:[і=10) # 

створити поле вводу, пов'язати зі змінною з 

Еп1:гу1.р1асе(ге1х=0.1, ге1у=0.5, пе1\л/ісІ1:Іп=0 . 3^ 

пе1Ьеі§Іі1:=0.1) # розташувати на вікні 

5.5е1:(0) # установити рядковій змінній значення 0 

поо1:.таіп1оор() # головний цикл програми (для обробки 

подій) 


5іпірІе СІЯ арр - І□ І х| 




іов І 


Рисунок 8 - Вікно програми 

Ткіпіег - основні класи 

В прикладі показано використання основних класів Ткіпііеп 
для створення програм з графічним інтерфейсом. Використано такі 
класи як Тк (головне вікно), Ргате (фрейм або прямокутна область 
на екрані), Виїїоп (кнопка), І_аЬе1 (надпис), ЕгтЬгу (текстове 
поле), СЬескЬи1:1:оп (прапорець), ВасІіоЬи1:1:оп (перемикач), 
ИзііЬох (список), Сапуаз (канва або область для рисування), 
Бсаіе (шкала), Мепи (меню), 51:гіп§\/аг (текстова змінна), ІпІіУаг 
(ціла змінна), ВооІеагЛ/аг (булева змінна), ОоиЬІеУаг (дійсна 
змінна). 

■Ргот Ткіпііег ітрогі: * 

с1а55 МуРгате(Ргате): # клас, успадкований від Ргате 


108 












сіе-р _ іпіі_(зеі-Р, таз1:ег=І\Іопе): # конструктор 

Ргате._ іпії:_(зеі-р., тазіег) # виклик 

конструктора базового класу 

зеі-Р . §гісІ () # розмістити фрейм 
зеі-р. Ьиіііопі = Ви1:1:оп( зеі-р ^ іехі^'ВиіІіоп" , 
соттапсІ=5ЄІ-Р. соттапсії) # створити кнопку, встановити 
її властивості 

# або встановити властивості так: 
5ЄІ-Р.Ьи1:1:оп1["1:ех1:"] = "Виіііоп" # надпис 
зеі-р. Ьи1:1:оп1["соттапсІ"] = зеі-р. соттапсії # 

метод для виконання 

# або встановити властивості так: 

зеі-р. Ьиііопі. соп-Рі§(1:ех1:="Ви1:-|:оп"; соттапсІ=5е1-Р. соттап 
сії) 

зеі-р. Ьи1:1:оп1.§гісІ(го\л/=0, со1итп=0) # 

розмістити в рядку 0 і стовпчику 0 

зеі-р. 1аЬе11=ІаЬе1(зе1-Р^ех1:="ІаЬе1") # 

створити надпис 

зеі-р. 1аЬе11.§гісІ(го\л/=0; со1итп=1) # 

розмістити 

зеі-р. 1:у=5-|:гіп§\/аг() # створити рядкову змінну 
зеі-р. еп1:гу1=Е пі гу^еИ^іехІїуа гіаЬ1е=зеі-Р .іу) 

# створити текстове поле, пов'язати з змінною іу 

зеі-р. епігуі.іпзегі(0, 3.14) # вставити текст 
(або так: зеі/. іу. зеї("3.14")) 

зеі-р. епігу1.§гісІ(гои/=0; соіитп=2) # 

розмістити 

зеі-р. Ьу=Вооіеап\/ап() # створити булеву змінну 

зеі-р. сЬес к1=СЬескЬиііоп( зеі-р ^уагіаЬ1е= зеі-р. Ьу) # 

створити прапорець, пов 'язати зі змінною Ьу 

зеі-р. сІіеск1.§гісІ(го\л/=0; соіитп=3) # 

розмістити 

зеі-р. іу=ІпіУаг() # створити цілу змінну 

109 




зеН. гасІіо1=КасІіоЬи11оп(5ЄІН 
і:ех1:=' Касііоі ' , уагіаЬ1е=зе1-Р. ІУ; уа1ие=1) # створити 

перемикач> пов'язати з змінною іу 

зеї-Р. гасІіо1.§гісІ(го\л/=П со1итп=0) # 

розмістити 

зеї-Р. гас!іо2=КасІіоЬи11оп(5е1Н 
1ех1= ' Касііо2 , уагіаЬ1е=зе1-Р. ІУ; уа1ие=2) # створити 

перемикач } пов'язати зі змінною іу 

зеї-р. гасІіо2.§гісІ(го\л/=П со1итп=1) # 

розмістити 

зеН. іу. зе!(2) # установити значення 2 

(включити другий перемикач) 

зеї-р. 1І5І1=1_ізіЬох(зе1-р) # створити список 
зеї-Р. Іізії .§гісІ (го\л/=1, 

со1итп=2, го\л/зрап=5, со1итпзрап=1) # розмістити 

■Рог х іп [ ,, КесI ,, ^"В1ие"^"С^ееп ,, ] : # заповнити 

список 


0 


зеї-р. 1із1:1. іпзег!(ЕШ;Х) 
зеї-р. Іізії. зе1ес1іоп_зе1(0) # вибрати елемент 


зеї-р. 1 і зі: 1. ЬіпсІ ( "<0оиЬ1е-Ви11оп-1 >" , 
зеї-р. єуєп12) # пов'язати подію з методом 

зеї-р. сапуазі = Сапуаз(гооП \л/ісІ1:И=200, 
Иеі§ІгІ:=1б0^ Ь§= ’ \л/Иі-Ье ’ ) # створити канву 


зеї-р. 1іпе1=зе1-Р. сапуазі.сгеа!е_1іпе(0, 0^ 100, 100, 
іл/ісН:Рі=5) # створити лінію на канві 

зеН. сапуазі.§гісІ(го\л/=2, со1итп=0) # 

розмістити 

зеї-р. сапуазі . Ьіпсі( '<Мо1іоп>' , зеї-р. єує пі 1) # 
пов'язати подію з методом 

зеї-р. сІУ=0оиЬ1е\/аг() # створити дійсну змінну 
зеї-р. зсаіеі = 5са1е(зе1-Р, -Ргот_=-10.0, 
1о=10.0, гезо1и1іоп=0.5, 1аЬе1=' Бсаіе' , 
огіеп1=Н0КІ20І\ІТАІ-, уагіаЬ1е=зе1-р. сіу) # створити 


110 




шкалу , пов'язати зі змінною січ 

зеї-р. зса1е1.§гісІ(го\л/=2, со1итп=1) # 

розмістити 

тепиі = Мепи( зеї-р) # створити меню 

тазіїег. соп-Рі§(тепи=тепи1) # установити меню 

для вікна 

тепиіі = Мепи(тепиі) # створити підменю 
тепиі. асІсІ_са5сасІе(1аЬе1=' Мепи ' , тепи=тепи11) 

# додати підменю 

тепиіі. асИ_соттапс1 (1аЬе1= ' Ехії , соттапсІ=5у5 . ехії) # 

додати елемент меню 

Сіе-Р соттапсЩзеї-Р) : # метод соттапді 

х=-Р1оа1:(5ЄІ-р.1:у.§е1:() ) # присвоїти х' 

значення 1у 

зеї-р. "Ьу. зеІ(х**2) # установити ви значення 

х**2 

ргіпі: зеї-р. Ьу.§є1:() # вивести значення Ьу 
ргіпі: зеї-р. іу.§є1:() # вивести значення іу 
ргіпі: зеї-р. сіу.§є1:() # вивести значення би 
ргіпі: 

зеї-р. 1із1:1.§е1:(5ЄІ-р.1І5І:1.сиг5ЄІес1:іоп()) # вивести 

вибраний у списку елемент 

сіе-р еуеп1:1( зеї-р, єуєпі:) : # метод еиепії (обробник 
події) 

зеї-р. іу.зєі: (єуєпі:. х) # установити їй значення 
координати миші 'х' 

зеї-р. сапуазі . соогсіз( зеї-р. Ііпеї, (єуєпі: .х, 
єуєпі:. у, єуєпі: .х+50, єуєпі: .у+50) ) # змінити 

координати лінії ііпеї 

сіе-р єуєп1:2 (зеї-р, єуєпі:): # метод еиепї2 (обробник 
події) 

єуєпі: . місіте"! [ "-р§" ] = " гесі" # змінити значення 
властивості /д віджета, що викликав подію 

зеї-р. соттапсЩ) # виклик методу соттапді 


111 




пооі: = Тк() # створити головне вікно 

арр = МуРгате(та5І:ег=гоо1:) # створити наш фрейм на 
вікні 

арр.таіп1оор() # головний цикл обробки подій 

пооі:. сіЄ5І:гоу() # знищити вікно 



Рисунок 9 - Вікно програми 

їік.Тгее\іе\у - дерево елементів 

Модуль 1:1: к містить класи, які дозволяють використання 
віджетів Тк з підтримкою тем оформлення. Клас Ик.Тгееуіеи/ 
дозволяє відображати ієрархічну колекцію (дерево) елементів. 
Кожний елемент може мати текстовий надпис, рисунок і список 
значень даних. 

ітрогі: ТкіїгЬег, 1:1:к 
сіе-р Ьі:п1С1іск(еуеп1:): 

'''Обробник події відпускання кнопки 1 миші ' ' ' 

112 















ігее = єуєпі .іл/ісідеі # віджет, що викликав подію 
посіє = ігее.іосизО # вибраний елемент дерева 
(його ід) 

ргіпі посіє # ід 

ргіпі ігее. ііет(посіе) # словник опцій вузла; 
#{‘їехї':", ’ітаде ': 'иаіиез':", ’ореп':в, 

’їадз ': ' '} 

ргіпі: ігее. ііет(посІЄ; ’іехі ) # текст вибраного 

елемента 

# або ргіпі ігееЛіет(поде)[ ’іехі '] 

ргіпі: ігее.рагепі(посіе) # предок 

ргіпі ігее.іпсіех(посіе) # індекс елемента в списку 

споріднених 

ргіпі ігее. ргеу(посіе) # попередній споріднений 

ргіпі ігее.пехі(посіе) # наступний споріднений 
ргіпі ігее.§еі_сІіі1сІгеп(посІе) # список дочірніх 
ргіпі ігее.зеі(посіе) # словник зі значеннями 

колонок 

ргіпі ігее.ехІ5із(посІе) # чи існує елемент? 
сіе-р сІЬ1_Ьіп1С1іск(еуепі): 

' ' 'обробник події подвійного натиску кнопки 1 
миші ' ' ' 

ргіпі 1 сІЬІСІіскесІ 1 

сіе-р ЬіпЗСІіск(еуепі): 

' ' 'обробник події натиску кнопки 3 миші ' ' ' 

ргіпі 1 ЬіпЗСІіскесГ 
сіе-р іа§С1іскесІ (єуєпі) : 

' ' 'Обробник подій натиску мишею на тезі ' ' ' 

ргіпі ’іа^СІіскесГ 
сіе-р ігееОрепСІозе(еуепі): 

' ' 'Обробник подій відкриття і закриття 
піддерева' ' ' 

ргіпі ’орепесі/сіозесі 1 
сіе-р ігееБеІесі(еуепі): 

11 'Обробник події вибору елемента' 1 ' 


113 




ргіпії ' зеїесіїесі' 

гооіі = Ткіпііег .Тк() # створити головне вікно 

іт§ = Ткіп 1 :ег.РІ 10 ■^:оIта§е(■Рі 1 е= , ■I : о 1 сIег.§і■Р , ) # рисунок 
зЬаг_у = 1і'Іік.5сго11Ьаг(огіеп1і="уег1іісаГ') # створити 

вертикальну смугу прокручування 

зЬаг_х = £1ік.5сго11Ьаг(огіеп1і="1югІ20ПІіа1") # 

створити горизонтальну смугу прокручування 
Іігее = 1:1:к.Тпееуіе\л/(Ііеі§Іт1:=10) # створити дерево 
1гее[ 1 зеїесіїтосіе 1 ]=Ткіп1іег.ЕХТЕШЕй # дозволити вибір 
багатьох елементів 

# або так: 

Іігее.соп-Рі§(5ЄІес1ітосІе=Ткіп1іег.І\І0І\ІЕ) # заборонити 
вибір елементів 

#ігее.5іаіе((’дізаЬіед)) # заблокувати ігее 
1ігее[ 1 соїитпз ’ ] = ( 1 зїаііе " , ) # додати колонки 
Ігее. со1итп( 1 зііаііе ’ , \л/ісІ1:Ь=100^ апсЬог= ’ сепііег 1 ) # 
параметри колонки ’зіаіе ' 

1ігее[ 1 сіізріаусоїитпз ' ]= ' зііаііе' # показувати колонку 
Іігее. ЬеасІіп§( #0 , 1іех1і= ' Непі Дта§е=іт§) # надпис на 
колонці в 

Іігее. ЬеасІіп§( зііаііе ' 1:ехї= ' 5і:аі;е ' ) # надпис на 
колонці 1 зіаіе' 

зЬаг_у [' соттапсі' ] = Іігее .ууіеи/ # під час 

прокручування змінювати положення дерева 

5Ьаг_х[' соттапсі' ] = Іігее.хуіеи/ 

1ігее[ 'узсгоІІсоттапсГ ] = зЬаг_у. зеї # значення 

повзунка смуги прокручування 

1ігее[ 'хзсгоіісоттапсі' ] = зЬаг_х. зеїі 

# розмістити віджети 

зЬаг_у. раск(зісіе=Ткіп1іег.КІСНД -Рі11=Ткіп1іег.У) 
зЬаг_х. раск(зісІе=Ткіп1іег.ВОТТОМ., -Рі11=Ткіп1іег.Х) 

Іігее.раск(зісІе=Ткіп1іег. І.ЕРТ, -Рі11=Ткіп1іег.У) 


114 




# прив'язки до обробників подій 

ігее. ЬіпсІ( ' <Ви1і1іопКе1еазе-1 >' , ЬіпІСІіск) 
ігее. ЬіпсІ( ' <0оиЬ1е-Ви1і1іоп-1 >' , сІЬ1_Ьііп1С1іск) 
іігее. ЬіпсІ ( ' <Виііііоп-3> : , ЬііпЗСІіск) 
іігее. ЬіпсІ(' <<Тгееуіеіл/5е1есіі>> , іігееБеїесії) # 

обробник події вибору 

іігее. ЬіпсІ( ' <<Тгееуіе\л/Ореп >>' , іігееОрепСІозе) # 

обробник події відкриття піддерева 

іігее. ЬіпсІ( ' <<Тгееуіе\л/С1озе >>' , іігееОрепСІозе) # 

обробник події закриття піддерева 

іігее. іпзегіі( , в, 1 -рігзі; , ііех1:=' іііет 1 , іта§е=іт§) 

# додати перший елемент ’^ігзі’ після кореневого '' 
іігее. ііет( ' -Рігзі:' , іехі:= ' ііет 1!' д ореп=1) # змінити 
опції елемента '^ігзї' 

іігее.зеіі( '^ігзі:" у ' зііаііе' л '***') # значення для 
'/ ігзї' в колонці 'зїаїе' 

ісІ=іігее.іп5егіі( ; ’ епсГ, ііехіі=' ііет 2') # додати 
другий елемент після '' 

Іс1=іігее.іп5егіі(іс1, ' епсі' ^ ііехіі= ' ііет 

21' д 1;а§5=( Чаді ' , )) # додати дочірні до ід 

іігее .іа§_соп-Рі§иге( 'ііа§1' ; -Роге§гоипсІ= ' Ьіие ' ) # колір 

тегу 

іігее .іа§_ЬіпсІ( 1:а§1' ’<3> \, іа§С1іскесІ); # вказати 

обробник події натиску на праву кнопку миші 

іігее. іпзегіі( ' іігзії' , ' епсі' ^ 'сЬіїсГ, іехі= ' СЬіїсІ' ) # 

додати дочірній 'сбіід' до ’^ігзї' в кінець 

іігее. іпзегіі( ' сІїіїсГ , ' епсі' , ііехі:= *СИіїсІ' ) # додати 

дочірній до ’сЬіід' 

ігее . ІП5ЄГІі( ' ІІГ5ІІ ' , ' епсі , 

іехіі= 1 СЬіїсІ 1 , Уа1ие5=( 1 *** 1 , )) # додати дочірній до 
'/ІГ5І ' 

іігее.тоуе( 1 сЬіїсГ , 'епсі') # перемістити 'сЬіід' 

разом з дочірніми в кінець кореня 

# або 


115 




#ігее. деіасб( 'сЬіід') # відділити від дерева (зі 
збереженням в пам'яті) 

#ігее.геаііасб( ' сбіід ', ’епд’) # знову прикріпити 

до дерева (предок позиція ’епд') 

#ігее.деіеіе( 1 сбіід ’) # повністю видалити 
#ігее. зеі_сІііідгеп( ’ сЬіід', ід, '/і гзі 1 ) # замінює 
дитину елемента ’сЬіід' новими дітьми (ід, '/ ігзі') 
1гее.-Роси5( ’-Рігзі; 1 ) # установити фокус на перший 
елемент 

Іігее. зе1ес1:іоп_5ЄІ:( ( 1 Рігбі: ' , )) # вибрати елементи 
ргіпі: Іігее.5ЄІес1ііоп() # вибрані елементи 
Іігее. зее( 1 -РІГ5І; 1 ) # прокрутити дерево до елемента, 
щоб він став у полі зору 

гоо1:.таіп1оор()# головний цикл обробки подій 



Рисунок 10 - Дерево елементів 

Вбудовування інтерпретатора РуІЬоп у С++ програму 

Нижче показано приклад програми мовою С++, яка має 
можливість звернення до інтерпретатора РуїЬоп. Якщо 
використовується середовище розробки Собе::В1оск8 16.01 та 
компілятор Сг>Ш ССС Сотріїег, то в опціях проекту (РічцесІ Ьиіїсі 

116 




















оріїопз) потрібно вказати шлях до заголовних файлів (ЗеагсН 
бігесіогіез) С:\Ру[Ьоп27\іпсІисіс та під’єднати усі бібліотеки (Ьіпк 
ИЬгагіез) з С:\РуіЬоп27\1іЬ8. Якщо використовується середовище 
розробки Вогіапб С++ Виіібег 6, то: 

• Виконайте конвертацію бібліотеки: соРР2отР. ехе 
ру1:Ііоп27. ІіЬ ру1:Ііоп27_. ІіЬ. 

• Скопіюйте рутЬоп27_. 1ІЬ в папку з проектом і переіменуйте 
його в руіЬоп27.1іЬ. 

• Виберіть меню Рпцесі/Орііопз.. ./Оігесіогіез та додайте в 
Іпсіибс раїН С:\РуіЬоп27\іпс1ибе 

• Додайте до проекту руіЬоп27.ИЬ та РуїЬоп.Н 

#іпс1исІе "РуЬИоп.Ь" 
таіп(іп1: ап§с^ сЬап **аг§у) 

{ 

Ру_5е1:Рго§гатМате(аг§у[0] ) ; // передає агди[0] 

інтерпретатору 

Ру_Іпі1:іа1І2е( ); // ініціалізація інтерпретатора 
// виконання команд Руіііоп (ніби модуль _ таіп _ ) 

РуКип_5ітр1е51:піп§( "ітрогі: 1:іте\п" ); 

РуКип_5ітр1е51:гіп§( ''ргіпї 

кіте. Іосаііііте (кіте. 1:іте()) \п" ); 

Ру_Ріпа1І2е( ); // закінчення роботи інтерпретатора 
} 


сіуре8 - виклик зовнішніх С-функцій 

сіурез - це бібліотека для поступу до зовні ш ніх С-функцій, яка 
забезпечує сумісні з С типи даних і дозволяє виклик функцій з ОЬЬ 
або розподілюваних бібліотек ІМх. Наступна С-функція С отримує 
три аргументи (змінну п та вказівники х і А) і повертає вказівник В. 
Зауважте, що функція змінює значення за адресами х і А. 

#іпс1исіе <5І:сІ1іЬ.Ь> 

-Ріоаі: * _бесІ5рес(сі11ехрог1:) Р(-Р1оаі:* X; іпі: п. 


117 






Ріоаі* А) 

{ 

Ріоаі *В = (-Р1оа-Ь*)та11ос(5І2ео-Р(-Р1оа1:) * п); 
і пі: і; 

■Рог(і=0; і<п; і++) 

{В[і]=А[і]+*х; А[і]-=*х;} 

*х=А[1]-А[0]; 
геіигп В; 

} 


Для компіляції цього коду в бібліотеку БЬЬ застосовано 
команди ССС 4.9.2 (ісіт-1): 

тіп§\л/32-§сс.ехе -02 -с таіп.с -о таіп.о 
тіп§\л/32-§сс.ехе -зНагесІ таіп.о -о тусіїї.сііі -з 

Тепер до бібліотеки тусіїї.сіїї можна звернутись з РуіЬоп: 


-Ргот сіурез ітрогі: * 

тусИ1=ссІ11.1_оасП-іЬгагу( тусіїї.сііі") # завантажити 

бібліотеку О/, і 

■РІоаіЗ = с_Т1оа1: * 3 # тип масиву з 3 елем. С- 
сумісного типу /іоаі 

А=-Р1оа1:3(1; 2, 3) # масив 

тус111.1 : .аг§1:уре5=[Р0ІІ\ІТЕК(с_-Р1оа1:), с_іп1:, РІоаіЗ] # 

типи аргументів 

тусіїї.-р. гез1:уре=Р0ІМТЕК(с_-Р1оа1:) # тип результату 
х=с_Т1оа1:(1) # змінна С-сумісного типу /іоаі 
В=тусі11. Р(Х; 3^ А) # виклик функції (х, А - 
вказівники) 

# або В=тусШ .ф : (Ьугеф : (х)> З, А) 

■Рог а іп А: ргіпі з, # вивести масив А 

ргіпі ' \п' л В[0], В[1], В[2] # вивести масив В (але 

не В[3] !) 

ргіпі: х.уаіие # значення змінної х 


118 






0.0 1.0 2.0 
2.0 3.0 4.0 
1.0 


Розширення РуїЬоп мовою С++ 


Нижче наведено послідовність дій для створення мовою С++ 
РуїЬоп-модуля ЕхРезР, який містить функцію Рас, що повертає 
факторіал числа. Створення модулів розширення мовою С++ 
дозволяє вирішити проблему низької продуктивності РуїЬоп. 

1.Вихідний код модуля розширення мовою С++ (таіп.срр): 

іпР Рас(іпР п) // рекурсивна функція, повертає 
факторіал 
{ 

ІР (п < 2) геРигп(І); 
геРигп (п)*Рас(п-1); 

} 

#іпс1исіе "РуРйоп.Іі" // під’єднати файл Руіііоп.іі 
// функція повертає об’єкт Руіііоп типу іпі 

зРаРіс РуОЬ^есР *ЕхРезР_Рас(РуОЬ]ЄсР *зе1Р, РуОЬ^есР 
*аг§з) 

{ 

іпР пит; 

// конвертує дане Руііюп типу іпі в С++ типу іпі 

іР (!РуАг§_РагзеТир1е(аг§з, "і", &пит)) 
геРигп N1)11; 

// конвертує дане С++ типу іпі в Руібоп типу іпі 

геРипп (РуОЬ]есР*)Ру_Виі1сі\/а1ие( 'і" Рас(пит)); 

} 

// масив методів, які експортує модуль 

зРаРіс РуМеРЬосЮеР ЕхРезРМеРЬосіз [ ] = 

{{ "Рас", ЕхРезР_Рас, МЕТІ-М/АКАКЄ5 }, { N111.1-, N111.1- 

}Л; 


119 





уоісі іпгЬЕхїезїО // функція ініціалізації модуля 

{ 

Ру_Іпі1:Мос)и1е( Ехіїезі:", ЕхіезЬМеіЬосІз); 

} 


2.Модуль РуїЬоп, який створює і установлює модуль 
розширення за допомогою сІізІїиЬіІз (зеїир.ру): 

■Ргот сіізіїиііііз. сопе ітрогі зеїіир, Ехіепзіоп 
зе1:ир(пате= ' Ехіїезі:' , ех1і_тосіи1Є5= [Ех1іеп5Іоп( ' Ехіїезі :' , 
зоигсез= ['таіп.срр'])]) 


3. В командному рядку введіть (для РуїЬоп 2.5 необхідне 
установлене М8 Уізиаі С++ 2003): 

зеіир.ру Ьиіїсі 
зеіир.ру іпзіаіі 

4. Перевірка роботи модуля в РуїЬоп: 

ітрогі: Ехіїезі: 

Ехіїезі:. Рас (7) # 5040 


120 







РОЗДІЛ 2. СТОРО ННІ БІБЛІОТЕКИ Р¥ТНОN 

ІРуіЬоп - інтерактивна командна оболонка 

ІРуїЬоп 5-Х (Ьїїр8://іру(Ьоп.геа<ііЬесІос8.іо/еп/5.х/) - це командна 
оболонка для інтерактивних обчислень на багатьох мовах 
програмування, яка забезпечує інтроспекцію, мультимедіа, доступ 
до системної оболонки, автодоповнення коду та історію команд. 
Початково розроблена для РуІЇюп і є ядром більш масштабного 
проекту Ліруіег. Широко використовується в екосистемі ЗсіРу. 
Запускається командою іруНіоп або зируїіег-ріісопзоіе. 


Команди 

Коментар 

Іп [1]: х=1 

Після запрошення І п [ 1 ]: 
введіть потрібну команду. 

Іп [2]: х=х+1;х=х+2 

Або кілька команд. 

Іп [3]: х 

Оиі; [3]: 4 

Вивести значення змінної. 

Іп [4]: х; 

Результат не виводити. 

Іп [5]: _ 

Оиі: [5]: 4 

Змінна _ містить 
попередній результат. 

Іп [б]: Іп 

Оиі: [6] : [", и’х=1', 
и'х=х+1;х=х+2' , и'х', и'х;'^ 
и '_’ и ' Іп' ] 

Змінна І п містить список 
комірок введення. 

Іп [7]: Ои-Ь 

0иї[7]: {3: 4, 5: 4, 6: , 

и'х=1'; и’х=х+1;х=х+2 ' , и'х'^ 
и'х; и'_', и'Іп', и'ОиИ']} 

Змінна Оиі: містить словник 
комірок виведення. 

Іп [8]: зи<ТаЬ> 
зит Бирег 

Автодоповнення клавішею 
< Т а Ь > . Використовуйте 
також клавіші ї і { для 
пошуку команд в історії та 
комбінацію Сігі-г для 
відкриття вікна пошуку. 

Іп [8]: зит? 

Інформація про об’єкт. 


121 




0ос5І:гіп§ : 

зит(і1:егаЬ1е[ , зііагі:]) -> 
уаіие 

Кеііипп іРіе зит о-р ап іііепаЬІе 
оп зериепсе о-р питЬегз ... 


Іп [9]: зит?? 

Детальна інформація про 
об’єкт. 

Іп [10]: ! ссі 
е: \АпасопсІа2\5сгір1:5 

Іп [11]: ! ! ссі 

0и1[11]: 

[ ' е : \\АпасопсІа2\\5сгір1:5 ' ] 

Для доступу до команд 
системної оболонки 
використовуйте символи "!" 
або"!!". 

Іп [12]: ! ссі <ТаЬ> 

Автодоповнення елементів 
каталогу клавішею <ТаЬ>. 

Іп [13]: -Рі1ез=!сІіп /В 

Присвоїти змінній -Рііез 
список файлів поточного 
каталогу. 

Іп [14]: -Рі1е="таіп.ру" 

Іп [15] : !сііг $-Рі1е 

Передати значення змінної 
-рііе команді сі і г . 

Іп [16]: !сііг {-Рііе} 

Або так. 

Іп [17]: %риіскге-р 

Магічна команда 
%риіскпе-р. Магічні 
команди починаються з "%" 
(рядкові команди)або 
"%%" (коміркові команди) і 
можуть мати аргументи. 

Іп [18]: %1зта§іс 

0и1[18] : 

АуаіІаЬІе Ііпе та§ісз: 

%а1іаз %а1іаз_та§іс %аиі:оса11 

АуаіІаЬІе сеіі та§ісз: 

%%! %%НТМІ. %%5УЄ %%ЬазЬ ... 

Список усіх магічних 
команд. 

Іп [19]: /брзеагсЬ з* 

Зеї 

Шукати усі об'єкти, що 
починаються з "з". 


122 




зеіаііг 


Іп [20]: ?б* 

Або так. 

Іп [21]: %%\л/гі1:е-Рі1е таіп.ру 
...: ргіпі 

5ит(гап§е(100)) 

1лІпіі:іп§ таіп.ру 

Створити файл з наступним 
вмістом: 

ргіпі зит(пап§е(100)) 

Іп [22]: %гип таіп.ру 

4950 

Виконати програму в 

ІРуїЬоп. 

Іп [23]: /бесііі: 

Викликати зовнішній 
текстовий редактор і 
виконати введений код. 

Іп [24]: %іітеі1: 

5ит(пап§е(100)) 

100000 Іоорз ^ Ьезі: о-р 3: 2.1 
рз реп Іоор 

Іп [25]: %ііте 
б ит(гап§е(100000)) 

Іліаіі ііте: 8 тз 

Ои±[25] : 49999500001 

Визначити тривалість 
виконання коду. 

Іп [26]: %ЬІ5І:опу 
х=1 

х=х+1;х=х+2 

Вивести усі введені 
команди. 

Іп [27]: %ЬІ5І:огу --Р 
туРіізіогу. ру 

Зберегти усі введені 
команди у файл. 

Іп [28]: %ру1аЬ 

Імпортувати модулі питру 
та таірІоіІіЬ. 

Іп [29]: 

ріі. р1оі(пр. Ііпзрасе (0, 1)**2) 

0иі[29]: 

[<та1:р1оі1іЬ. Ііпез. І_іпе20 аі 
0х8сс)2сісІ8 > ] 

Побудувати графік функції 


123 




Іируїег МоїеЬоок - інтерактивні документи 


.Іируїег МоїеЬоок - це вільна веб-програма, яка дозволяє 
створювати і поширювати інтерактивні документи, які містять 
живий програмний код, формули, візуалізацію і форматований 
текст (ЬИр 8 ://]ируІег.ог§). МоїеЬоок підтримує більше 40 мов 
програмування, у тому числі РуїЬоп. Код може створювати 
мультимедійне інтерактивне виведення: НТМЬ, рисунки, відео, 
ЬаТеХ і довільні МІМЕ-типи. Іируїег N 010600 к широко 
застосовується для інтерактивних обчислень в різних галузях науки 
і техніки. Форматований текст в МоїеЬоок можна створювати мовою 
розмітки Магкс1о\¥п (Ьіф8://багіп£ҐігеЬа11.пеІ/рго]есІ8/тагкс1о\¥п). Це 
мова розмітки, яка орієнтована на легкість створення і читання 
документу з подальшим його перетворенням у НТМЬ. Зокрема, 
текст курсивом повинен знаходитись між символами *, жирний 
текст - між символами **, ЬаТеХ формула - між символами $ або 
$$, заголовок повинен починатись з символу # з наступним 
пробілом. Іируїег МоїеЬоок запускається командою зируЬег- 
поЬеЬоок. Нижче показані приклади документів Магкс1о\\'п та 
Іируїег МоїеЬоок. 


# Заголовок 

Магксіомп текст: *курсив* **жирний** 'програмний код 
[Посилання] (ІтЬкрз://вирубег.оп§) 

! [рисунок] (ітЬІірз ://]иру1:еп.оп§/аз5е1:5/пау_1о§о. зу§) 

>>> а=2 # програмний код 
>>> а**2 

ЬаТеХ формула: $а л {і\рі}_{1<} + 1 = 
\-Рпас{\зрг1:{х+1}}{\5Іп х}$ 

ІА |В |С І 


1 2 З 


124 





Заголовок 

Магксіоімп текст: курсив жирний програмний код Посилання 


рисунок 

»> а=2 # програмний код 
»> а**2 


І_аТеХ формула: + 



КІП X 


А В С 


1 2 З 


Іп [1] : %та'Ср1о'СІіЬ поСеЬоок 
ітрогі пшпру аз пр 
ітрогі таіріоіііь.руріоі: аз ріс 
£гот ірумісІдеРз ілірогЬ * # елементи керування 
х = пр.Ііпзрасе(1, 9); Ііпе, = рІР.рІоТ х, пр.зіп(х)/х # крива 
сіе£ ирсіаіє (А= (0,2, 0 . 1), В="1.0", С=[0,1,2], Б=Га1зе): 

Ііпе. зеС_усіаСа ( (-1 і£ Б еізе 1)*А*пр.зіп(£1оаР(В) *х+С) /х) 
рІС.зЬомО # оновити графік 
іпіегасС (ирсіаіе); # інтерактивний режим 



1.00 


В 

С 


1.0 


0 V 


г 0 


125 










Іп [2] : ргіпі "неформатований текст" 

£гот ІРуТЬоп.йізрІау ітрогї йізріау, НТМЬ, Магксіоип, 5УЄ 
# візуалізація «оду мовами НТМЬ, Магксіоьт, ВУЄ 
сіізріау (НТМЬ (и"НТМЬ <Ь>жирний</Ь> текст")) 

Дізріау(Магксіоип (и"Магк<іоип **жирний** текст")) 

Дізріау(5УЄ ("""<зуд хт1п5="ЬССр://'нии. н3.огд/2000/5уд" иісИ;Ь="‘ 
<сігс1е г="10" сх="50%" су="50%" Гі11="д^ееп"/x/зVд>""") ) 

лі_ І ш 

неформатований текст 

НТМІ_ жирний текст 
Магксіои/п жирний текст 


Рисунок 11 - Вигляд документа .Іируїсг ІМоІсЬоок 

МаїрІоШЬ - процедурний АРІ руріоі 

МаїрІоШЬ (ЬИр://таІр1оіИЬ.ог§) є бібліотекою для побудови 
різноманітних 2Г> діаграм у різних форматах і для різних 
інтерактивних середовищ. таІірІоЬІіЬ. рурІоЬ - це її простий у 
використанні інтерфейс у стилі МАТЬ А В. Нижче показано приклад 
створення графіка з лінією між точками (0,0) і (1,1) за допомогою 
МаїрІоШЬ 2.1.1. 

ітрогі: таЬрІоІіІіЬ. рурІоЬ аз рІЬ # імпортувати модуль 

таіріоШЬ. руріоі як ріі 

ріі:.ріоі:([0^1]^ [0^1]^ ’о-к’) # створити лінію 
ріі:. 5 Ноїл/ () # показати рисунок 


126 




10 


08 

06 у' 

04 _ 

02 ■ у— 

00 ' * 

00 02 04 06 08 10 

Рисунок 12 - Приклад використання таІрІоШЬ.рурІоІ 

МаірІоШЬ - об’єктно-орієнтований АРІ 

Об’єктно-орієнтований інтерфейс програмування МаІрІоШЬ 
використовує об’єкти (таких класів як Рі§иге. Рі§ипе, 
ахез ._зиЬр1о1:5. АхезБиЬрІоІ:, Ііпез. І_іпе20) і їх методи для 
побудови графіків. Складніший у використанні ніж процедурний 
інтерфейс руріоі, але має більше можливостей для налаштування 
графіків. 

ітрогі таірІоіІіЬ. руріоі аз ріі: 

-Рі§^ ах = рИ .зиЬр1о1;5( ) # створити об'єкти рисунка і 
системи координат 

#?ід, ах = рії.^ідигеО, рії. ахез(узсаіе= ' іод ') # або 
з логарифмічною шкалою 0у 

Ііпе, =ах. р1о1:( [0,2] , [0, 1]) # створити лінію в системі 
координат 

Ііпе. зе1:_1іпе\л/ісИ:Іп( 2 ) # ширина лінії 

Ііпе.зе1:_со1ог( ' г' ) # колір лінії (або 'гед', або 

(1.0,0.2,0.3), або '0.7') 

1іпе.зе1:_1іпе5І:у1е( ) # стиль лінії (або '- 

, , . , ) 

Ііпе. зе1:_тагкег( ' з ' ) # маркери точок (або один з 
символів .,ои Л <>12345р*вН+х0д/_) 


127 






1іпе.5е1:_тагкег5І2е(10) # розміри точок 

ах.ахіз( ' ериаі ' ) # однаковий масштаб осей 

рії. 5іїоіл/( ) # показати рисунок (або ^ід. зіюілі() ) 


12 
10 
08 
06 
04 
02 
00 
- 0.2 

Рисунок 13 - Приклад використання об’єктно-орієнтованого АРІ 

МаїрІоШЬ 

МаїрІоШЬ - додаткові параметри графіків 

В прикладі показно створення вкладених графіків (зиЬрІо!) і 
використання їх додаткових параметрів, таких як назви і масштаб 
осей, заголовок, сітка, надписи. Можливо налаштувати деякі 
параметри за замовчування в словнику ріі. гсРагатз. 

ітрогі питру аз пр # імпортувати модуль питру як пр 

ітрогі таїрІоІІіЬ. руріоі аз ріі # імпортувати модуль 
таіріоіііЬ.руріоі як ріі 
# параметри графіків за замовчуванням: 

ріі:. псРагатз [' Ііпез . соїог' ] = ' к' 

#рії.гсРагатз['ітаде.азресї'] = 'едиаі' # але це не 
працює у версії 2.1.1 

#рії.гсРагатз.кеуз() # список усіх параметрів 

1=1атЬсІа х: пр.соз(пр.рі*х)*х # функція повертає 
х*соз(рі*х) 



ТоО 025 050 075 ІОО 125 150 175 20о" 


128 









хі = пр.агап§е(0.0, 5.0, 0.1) # масив з прогресії 
х2= пр.агап§е(0.0, 5.0, 0.02) # масив з прогресії 
ріі.5иЬр1о1(2, 1,1) #діаграма 1 (рядків 2, колонок 1, 
номер 1) 

р11.р1о1:(х1,-Р(х1), Ьо ,х2,1(х2), к ) # криві 
ріі.Ііііііе( ' Рі§иге1' ) # заголовок 
ріі.5иЬр1о1(2, 1, 2) # діаграма 2 (рядків 2, колонок 
номер 2) 

Ііпеї, 1іпе2=р11:. ріоі: ([1,2,3],[2,4,8], г- 
1 , [1,2,3],[1,2,1], 'Ь- 1 ) # криві Ііпе1,ііпе2 
ІіпеЗ, =р11.р1о1( [1, 2, 3], [1 . 5, 3,4. 5], ) # крива 

ііпеЗ 

ріі.5ЄІр((Ііпеї, 1іпе2), 1іпе\л/ісі1:Іі=2.0) # властивості 

кривих Ііпе1 Л Ііпе2 

ріі.ііііііе( ' Рі§ипе2 ' ) # заголовок 

ріі.х1аЬе1( ’х' ); ріі.у1аЬе1( у ) # надпис осей х і у 
р1£.1ех£(2, 2, г'$\зі§та=2/б$' ) # іаТеХ текст на 
діаграмі 

ріі.ахіз([1, 3, 0, 10]) # розміри осей х,у 
# рії.ахіз( 'ериаі') # однаковий масштаб осей 
р11.§гісІ(Тгие) # сітка 
рії. зИо\л/() # показати графік 


129 





Рідигеї 



Рисунок 14 - Створення вкладених графіків 

МаїрІоШЬ - інші типи діаграм 

В прикладі показано створення діаграм розсіювання, гістограм, 
контурних діаграм та тривимірних графіків. Інші приклади 
використання МаїрІоІІіЬ для створення діаграм різного типу можна 
подивитись тут (Нпр://та[р1о[ІІЬ.ог«/«а11сгу/іпс1сх.Ь[т1#). 

ітрогС питру аз пр 

ітрогС таСрІоСНЬ. рурІоС аз ріс 

# діаграма розсіювання 

х= [0, 1, 2, 1] # координати точок 

у=[0, 1 , 4, 5] 

со1огз=[0.1, 0.4, 0.7, 0.8] # колір точок 
зІ2Є5=[20,40, 60,80] # розміри точок 

ріс.зсаССег(х, у, с=со1огз, з=зІ2Є5, а1рЬа=0.7) 
рІС.х1аЬе1( 'х' );ріс.у1аЬе1( у );ріс.§гісі(); ріс.зИои/() 


130 











рг і пі: "Рисунок - Діаграма розсіювання" 

# гістограми 

х1=пр.гапсіот.погта1(0, 1.0, 100) # випадкова величина 
х2=пр. гапсіот. погтаі(2, 1.0, 100) # випадкова величина 
р11:.-Рі§ипе() 

ріі.ИІ5І:(х1, а1рІіа=0.5, Ьіпз=7) # гістограма 
ріі. ЬІ5і:(х2, аірІіа=0.5, Ьіпз=7) # гістограма 
ріі.х1аЬеі( ’х' );ріі.уіаЬеі( у );ріі.§гіс)(); ріі.5Ііо\л/() 
ргіпі "Рисунок - Гістограми" 

# контурна діаграма для даних X , V, 2 

X, У = пр.тезИ§гісі(пр.1іп5расе(0, 9), пр.1іпзрасе(0, 

9 )) 

2 = х**2+У**2 

р11:.-Рі§иге() 

ріі. сопі:оип(Х, У, 2, 5, соіогз= ’іл/Ьіііе' ) # без 

заповнення 

ріі.соп1:оип-р(Х, У, 2, 5, стар=р11:.ст.§пау) #з 

заповненням 

# або відображення зображень 

#рІ±.іт5Ьом(Х } еxіепі=[в ^ 9, 0, 9], огідіп=' іомег ', 
стар=ріі.ст.дгау) 

#ріі.ахіз(азресі= 'ітаде ') # пропорції осей 

ріі.соіогЬаг() # смуга зі значеннями 2 

ріі.х1аЬеі( 'х' );ріі.у1аЬеі( у );ріі.зИо\л/() 
ргіпі "Рисунок - Контурна діаграма" 

# тривимірні графіки 

-Ргот тр1_іоо1І<і1:5. трІоіЗсІ ітрогі АхезЗй 

-Рі§ = р11:.-Рі§иге() # рисунок 

ах = Ахез30(-Рі§) # система координат 

ах. 5саі1:ег30( [0,10], [0, 10] , [0, 200] , 5=200) # точки 

ах.р1оі30([10,0],[0,10],[0,200], ' ко: ; ) # лінії 

#ах.ріоі_\ліігеф : гате(Х } У, 7.) # каркасна поверхня 


131 




ах. р1оі_5иг-Расе(Х., V; І) # поверхня 

ах. 5Єі_х1аЬе1( 'х );ах.5Єі_у1аЬе1( 'у ); ах.5Єі_2ІаЬе1( 

2 ); ріі. 5Ію\л/() 

рг і пі: "Рисунок - Тривимірний графік" 



х 

Рисунок 15 - Діаграма розсіювання 


132 






2Б 


20 - 

15 ■ 

10 - 

5 ■ 


0 


-2 


-1 


-Г 

0 






12 3 4 


х 


Рисунок 16 - Гістограми 



133 












Рисунок 18 - Тривимірний графік 


МаірІоШЬ - інтерактивна побудова графіків 

В прикладі графік інтерактивно перебудовується під час 
натиску клавіш “стрілка вгору” і “стрілка вниз”. Для цього подія 
кеу_рге55_еуепі пов’язується з функцією обробки події 
кеуРгезз. Цю програму бажано виконувати так: руїЬоп.ехе таіп.ру 

ітрогі таірІоіІіЬ.руріоі аз ріі 
■Ргот гапсіот ітрогі га псі і пі: 

сІе-Р кеуРге55(еУеп1:): # функція обробки подій 

ії єуєіті; . кеу== ' ир' : # якщо натиснута стрілка 
вгору 

Х.аррепсі(гапсІіітІ:(0,10)) # додати в список X 
випадкове число 

У.аррепсІ(гапсІіп1:(0Д0)) # додати в список У 


134 







випадкове число 

і-р єуєпі; . кеу== ' сіомп ' : # якщо натиснута стрілка 

вниз 

і-р X: Х.рор() # вилучити зі списку X останнє 

число 

і-р V: У.рор() # вилучити зі списку У останнє 

число 

1п. 5еі_сІа1:а(Х,V) # установити дані для полілініг 
ріі. сІгаіл/() #іп.^ідиге. сапиаз. дгаілі() # 
перерисувати 

Х=[] # список координат х 
У=[] # список координат у 

1п,=р1і.р1оі(Х, У; 'к-о') # полілінія 
ріі.§сР(). сапуаз . тр1_соппес1:( ' кеу_ргез5_еуеп1 : 1 , 
кеуРгезз) # пов'язати подію натиску клавіш з функцією 
обробки подій 

ріі. ахіз ( [0, 1<д, 0^ 10]) # шкала осей 

р11:.х1аЬе1("х");р11:.у1аЬе1( у );ріі.зИои/() 
ргіпі: "Рисунок - Інтерактивний графік" 


135 






Рисунок 19 - Інтерактивний графік 

ВокеЬ - інтерактивна візуалізація 

ВокеЬ 0.13 (Ьі(р://ЬокеЬ.русіаІа.ог§) - це бібліотека для 
інтерактивної і високопродуктивної візуалізацїї в сучасних 
браузерах. Використовується для створення інтерактивних програм 
для візуалізації даних. Цей приклад створює графік, який 
розташований в незалежному Ьіті-документі з даха^січрГ- 
сценаріями. 

ітрогк питру аз пр 

■Ргот ЬокеЬ. р1ок1:іп§ ітрогк -Рі§ипе^ збои/, оикрик^ііе 
х = пр.1іпзрасе( -1,1,1000) # дані для візуалізації 
у = пр.зіп( 1/ х) 

бу= пр.гапс!от.погта1(0, 0.2, 1еп(х)) 


136 











оиіриі_-Рі1е("р1оі.Ьіт1") # документ для виведення 
ріоі = іі§иге(р1оі_Ьеі§Ьі=200, 
оиіриі_Ьаскепсі="меЬ§Г ) # рисунок 
р1оі.1іпе(х, у , 1іпе_\л/ісІіЬ=3) # крива 
р1оі.сігс1е(х[: :100]; у[::100], -Рі11_со1ог="іл/Иі1:е\ 
1іпе_со1ог="гесІ", 5І2е=10) # точки на кривій 
ріоі.зсаііег(Х; у+сіу^ а1рЬа=0.5) # випадкові точки 
зИохл/(ріоі:) # показати рисунок в браузері 



Рисунок 20 - Вигляд графіка в браузері 


ВокеЬ - серверна програма 

За допомогою сервера застосувань ВокеЬ можуть бути створені 
клієнтські Ьіші-документи, які взаємодіють з серверною РуїЬоп- 
програмою. Для виконання прикладу введіть в консолі: 

е:/апасопсІа2/5сгірі5/ЬокеЬ зєгує --зЬои/ таіп.ру 


ітрогі питру аз пр 

■Ргот ЬокеЬ.іо ітрогі: сигсіос 

■Ргот ЬокеЬ.Іауоиіз ітрогі гои^ и/ісІ§еіЬох 

■Ргот ЬокеЬ.тосіеІз ітрогі СоїитгЮаіаБоигсе 

■Ргот ЬокеЬ.тосіеІз.\л/ісІ§еі5 ітрогі Біісіег 

■Ргот ЬокеЬ.р1оіііп§ ітрогі -Рі§иге 

сіе-р ирсІаіе(аіігпате^ оісі^ пеи/): # викликається під 

час прокручування 

у=пр.зіп(5ІісІег.уа1ие*х) # нові значення 

137 











5оигсе.сіа1:а=сііс1:(х=х, у=у) # установити нові дані 
N = 100 # кількість точок 

х = пр.1іп5расе(0, 4*пр.рі., 14) 
у = пр.5Іп(х) 

зоигсе = Со1итгЮа1:а5оигсе(сІа1:а=сііс1:(х=Х; у=у)) # 

початкові дані 

ріоі: = -Рі§иге(р1о1:_Ііеі§ІтІ:=200; р1о1:_\л/ісІ1:Іп=400^ 
х_гап§е=[0; 4*пр.рі]; у_гап§е=[-2, 2], 
ои1:ри1:_ЬаскепсІ="\л/еЬ§Г ) # рисунок 
ріоі:. 1іпе( 'х 1 ; 'у' , 5оигсе=5оигсЄ; 1іпе_и/ісІ1:И=3) # 

крива 

зіісіег = 51ісіег(1:і1:1е="частота , уа1ие=1.0, 

5І:аг1:=0.1, епсІ=3.0, $1;ер=0.1) # віджет повзунок 
зіісіег .оп_сііап§е( ' уаіие ' , ирсІаТе) # пов'язати подію з 
функцією 

и/Ь = и/ісІ§е1:Ьох(5ІісІеп) # контейнер з віджетом 
сипсіос().асІсІ_гоо1:(го\л/(\л/Ь_, ріої)) # розмістити на 

документі в ряд 


С ф 


О, ІосаІЬо5Ї:5006/таіп 


О, Поиск 


частота: 1.90 


1.90 



Рисунок 21 - (ШІ програми в браузері 


О 

;р 

0Р 

0 


питру - робота з масивами 

N и т Ру (Ь П р: //\у \у \у. питру. сг§, Ьі1р://8сіру.ог§) - вільна 
бібліотека РуІЇтоп для високопродуктивних операцій з 
багатовимірними масивами (у тому числі матрицями). ІМитРу є 
основою таких бібліотек для роботи з даними як 8сіРу, МаїрІоШЬ, 

138 















рапсіаз, зсікії-іеагп та багатьох інших. Часто застосовується разом з 
бібліотекою 8сіРу, яка містить багато зручних і ефективних 
чисельних процедур (для інтегрування, оптимізації, інтерполяції, 
статистики, обробки сигналів та іншого) [14, 31]. МитРу та 8сіРу 
можна розглядати як вільну альтернативу МАТЬАВ. В прикладах 
використовується МитРу 1.13.3 та 8сіРу 0.19.1. В цьому прикладі 
показані базові операції з масивами: створення, властивості, доступ 
до частин масиву (зрізи), зміна форми, арифметичні операції, 
математичні функції, способи індексації, збереження у файлах, 
створення масивів з різнотипними елементами. 

ітрогі: питру аз пр 

#ргіпї питру.іоок^ог("сгеаіе аггау") # шукати "сгеаіе 
аггау" серед документації 

# створення масивів: 

пр.аггау([1 .0,2.0, 3 .0,4.0] ) # одновимірний масив 
пр. аггау([1, 2, 3,4], сІ1:уре=іп1:) # одновимірний масив 
цілих чисел 

пр.аггау([[1 . 0, 2] ,\ 3,4] ]) # двовимірний масив дійсних 
чисел 

ргіпі пр.аггау(гап§е(6) ) # одновимірний масив з 
прогресії 

пр.агап§е(6) # або так 

ргіпі: пр.1іпзрасе(з1:аг1:=0.,5І:ор=10,пит=5) # масив з 

рівномірно розподіленими значеннями 

пр. 2ЄГОЗ( (2, 2) ) # двовимірний нульовий масив 

пр.опез(2) # одновимірний масив з одиниць 

пр.Ри11(2, 1) # або так 

пр. ісіепіііііу (2) # одинична матриця 

пр. гапсіот. гапс!от(5) # масив з випадковими значеннями 

пр.гапбот.погта1(1ос=5, зса1е=1, зіге=5) # масив з 
випадковими значеннями (нормальний закон) 

а=пр.аггау([[1,2,3], [4,5,6]]) 


139 





а.псііт # кількість вимірів масиву 
а.зїіаре # розмір кожного виміру 
а.зіге # загальний розмір 
а. сіііуре # тип даних 
а.ІюІізіО # перетворити у список 

# зрізи над масивом у форматі: а[початок:кінець:крок] 

ргіп-Ь а[0,1], а[0][1], а[0], а[-1], а[:,0], 
а[0:2:2,0:3:2] 

а[0 л 0]=1.2 #змінити елемент з індексами 0,0 
#Увага! а[0,0]==1 бо масив цілого типу 
а[0]=пр.аггау([1,2,3]) #змінити рядок з індексом 0 
а0=а[0] # це не окрема копія першого рядка масиву а 
а0[0]=2 #Увага! Масив а зміниться! 

а0=а[0].сору() # це окрема копія першого рядка масиву 
а 

ргіпі; а . гезЬаре( (3, 2)) # повертає масив зі зміненою 
формою 

а.5іїаре=(3,2) # або змінити форму масиву 
а.гезІ 2 е((3,3)) # змінити форму масиву і заповнити 
нові комірки нулями 

а.1:гап5ро5е() # транспонувати (або а.Т) 

пр.опез(2) [:, пр. пеїл/ахіз] # перетворити в вектор- 

стовпчик 

пр.опез(2) .гезІіаре((2,1)) # або так 

пр. сопса1:епа1:е( [а^ а]) # об'єднати масиви по 

вертикалі 

пр.У5І:аск([а, а]) # або так 

пр. сопса1:епа1:е( [а, а],ахІ5=1) # об'єднати масиви по 
горизонталі 

пр. Нз1:аск( [а, а]) # або так 

пр. 5р1і1:(а, [1]) # розбити масиви по вертикалі 
#див. також пр.изрііі, пр.Ьзрііі 


140 




# арифметичні операції над масивами 

а+1 # додати 1 до кожного елемента 

пр. 5яг1:(а+1) # застосування математичних функцій 

а+а # поелементне додавання 

ргіпі пр.аггау([1,2])+пр.аггау([[1,2], [3,4]]) # 

додавання масивів різного розміру 

пр.зит(а) # сума елементів 

пр.5ит(а, ахіз=0) # суми в стовпцях 

пр.асісі.гесіисе(а, ахіз=0) # або так 

пр.сит5ит(а) # накопичувальна сума 

пр.теап(а) # середнє 

пр.5І:сІ(а) # стандартне відхилення 

пр.тіп(а) ^ пр.тах(а) # мінімальне, максимальне 

пр.ап§тіп(а) # індекс найменшого елемента 

пр. зогІ:(пр.аггау( [3,2,7, 1] )) # сортувати 

ргіпі: пр.аг§зог1:(пр.аггау( [3, 2, 7, 1] )) # індекси для 

сортування 

а=пр.аггау([1, 2, 3,4]) 

а [[!^ 2 ]] # масив елементів з індексами 1,2 
а[пр.апгау([1,2])] # або так 

а[[1,2]]=[2,3] # можна також змінювати масив 'а' 

а[пр.аггау( [Раїзе, Тпие, Тгие, Раїзе])] # або так 
пр.аггау([[1,2],[4,5]])[1,[0, 1] ] # комбінована 

індексація 

Ь=а<4 # масив з результатами логічного виразу 
(діуре=Ьооі) 

Ь=(а > 2) & (а < 4) #або складні логічні вирази 

а[Ь] # масив елементів з індексами Ь 

ргіпі пр.іл/Ьеге(а<4) # масив індексів, де виконується 

умова 

пр.апу(а<4) # чи будь-який елемент 


141 




пр.а11(а<4) # чи усі елементи 

# збереження у файлах 
#а.іоф : ііе("туф : ііе") # зберегти у файл 

#а=пр.^гот^ііеС'ту^Не" } діуре=іпі) # прочитати з 
файлу 

# або 

#пр. заиеС'ту^ііе.пру",а) # зберегти у файл 
#а=пр.іоад("туф : ііе.пру") # прочитати з файлу 

а = пр. 2 егоз( 2 , сН:уре= ( 1 І4,-Р4,а10' )) # масив з 
різними типами 

а[0]=(1, 10.0, 'А') # перший елемент 
а[1]=(2, 20.0, 'В') # другий елемент 

# або 

а = пр. 2 Єгоз( 2 , 

сіііуре={ ' патез ' : ( ' і ' , ’х' , ' пате' )/ -Рогтаїїз ' : ( ' І4' , ' -Р4 ’ , 
'310')}) 

а[0]=(1 л 10.0, 'А') # перший елемент 
а[1]=(2, 20.0, 'В' ) # другий елемент 
а ['пате'] # стовпчик 'пате' 

а[ 'пате' ] = [ 'а' , 'Ь' ] # змінити значення стовпчика 

ргіпі: а 

ргіпі а[а['х'] < 20] # ті елементи ^ де х<20 


[0123 

[ 0- 
2 2 [1 2 
[[2 2 ] 

[З 4] 

[5 6]] 

[[2 4] 

[4 6]] 
[ 3102 ] 
(агпау( [в, 


4 5] 
2.5 
3] [4 


5. 

5 6] 


7.5 
[1 4] 


10 . ] 
[[1 3 ]] 


1, 2], сН:уре=іп1:64),) 


142 





[(1, 10., 'а') (2, 20., 'Ь')] 

[(1, 10., 'а')] 


питру.1іпа1§ - лінійна алгебра 

Модуль містить базові інструменти лінійної алгебри: для 
декомпозиції матриць, розрахунку власних значень, визначника, 
норми матриці, розв’язування систем лінійних рівнянь та 
інвертування матриць. В прикладі також показано відмінність типів 
таПЇх і псіаггау. Модуль зсіру. 1іпа1§ містить функції 
питру. 1іпа1§ та деякі додаткові функції, але може бути 
швидшим. 


ітрогі питру аз пр 

А = пр.та1:гіх( [ [З, 1], [1, 2]]) # матриця 
ргіпі А*А # множення матриць 

ргіпі пр.1іпа1§.сІеі(А) # визначник матриці (якщо не 
0, то існує обернена матриця до А) 

ІлІ,\/=пр.1іпа1§.еі§(А) # власні значення і власні 
вектори 

ргіпі; ІлІ[0] ,\/[:, 0] # перше власне значення і 

відповідний власний вектор 

ргіпі: А*V[:, 0 ] - ІлІ[0]*\/[: ,0] # перевірка 

А*У[:,і]=Н[і]*У[:,і] 

# розв'язування систем лінійних рівнянь АХ=В (А>В - 
матриці) 

А = пр.та1:гіх( [[3, 1], [1, 2]]) # матриця 
В = пр.та1:гіх([[9], [8]]) # матриця 
X = пр.1іпа1§.зоІУе(А, В) # розв'язати систему 

# X = А**(-1)*В # або шляхом інвертування матриці А 

# А*Х-В # перевірка (нульова матриця) 
ргіпі: X 


143 





# розв'язування систем лінійних рівнянь АХ=В (А, В - 
масиви) 

А = пр.аггау([[З, 1]; [1, 2]]) # масив 

В = пр.аггау([9, 8]) # масив 

X = пр.1іпа1§.зоІУе(А, В) # розв'язати систему 

# X = пр.ііпаід.іпи(А).доі(В) # або шляхом 
інвертування матриці А 

# пр.доі(А, X) - В # перевірка (нульовий масив) 


[[10 5] 

[ 5 5]] 

5.0 

3.61803398875 [[ 0.85065081] 
[ 0.52573111]] 

[[ 0.00000000Є+00] 

[ 2.22044605Є-16] ] 

[[ 2 .] 

[ 3 .]] 


питру.гапйош - генератори випадкових чисел 

Модуль питру. гапсіот містить функції для генерації 
випадкових чисел з різними розподілами ймовірностей. 

ітрогі: питру аз пр 

ргіпі: пр.гапсіот.гапсіот(З) # випадкова вибірка з 
інтервалу [0.0, 1.0) рівноімовірного розподілу 
Х=пр. гапсіот. ипі-Рогт(10, 20,1000) # випадкова вибірка з 
рівноімовірного розподілу (ліва границя 10, права 
границя 20) 

ргі пі: Х.теап(), Х.з1:сІ(), Х.уаг() # середнє, 
середньоквадратичне відхилення, дисперсія 
#або пр.теап(Х), пр.зід(Х), пр.иаг(Х) 

Х=пр.гапсіот.1:гіап§и1аг(10,15,20,1000) # випадкова 
вибірка з трикутного розподілу (ліва границя 10, 
середнє 15, права границя 20) 


144 








рг і пі: Х.теап(); X. зііс) () _, Х.уаг() 

Х=пр.гапсІот.погта1(15ДД000) # випадкова вибірка з 
нормального розподілу (середнє 15 } 
середньоквадратичне відхилення 1) 

ргіпі Х.теап(); X. 5І:с1 () л Х.уаг() 


[ 0.8374071 0.30127402 0.74989105] 

15.101728332 2.93002837893 8.58506630134 
14.9962835669 2.08557855706 4.34963791765 
14.9576149223 0.973514441406 0.947730367627 

питру - поліноми 

В прикладі показано роботу з поліномами в МитРу: створення, 
отримання коренів, апроксимація поліномом. 


ітрогі питру аз пр 

р = пр.ро1у1сІ( [3, 2, -1]) # поліном з*х**2 + 2*х - 
ргіпі: р( 10 ) # значення полінома для х=10 
ргіпі р.гооіз # корені 

х, у = пр.аггау([0,1,2]) , пр.аггау([0, 2, 8]) # дані 
ргіпі пр. ро1у-Ріі(х, у ^ 2) # коеф. полінома 2 СI , пепеня ^ 
що апроксимує ці дані 


319 

[-1. 0.33333333] 

[ 2.00000000Є+00 -1.18450880Є-15 1.17986445Є-16] 

зсіру.уесіогіхе - векторизація функцій 

Функція зсіру.уесіогіге визначає векторизовану функцію, 
яка отримує послідовність або масив питру і повертає один або 
кортеж масивів питру. Використовується для перетворення 
звичайних функцій в їх векторизований варіант. 


145 






■Ргот зсіру ітрогі уесіогіге 

сіе-р -Р(х): геіигп х+2 # звичайна функція 

#ргіпі ^([1]2, 3]) # буде помилка! 

1л/=уєсіогі2є(-Р) # векторизована функція (приймає та 
повертає вектори) 

рг і пі: 1л/( [1,2,3]) # повертає масив пдаггау 


[З 4 5] 


зсіру - похідна і первісна функції 

В прикладі дано функцію у = х 2 + 4х. Шляхом чисельного 
диференціювання знаходиться її похідна у = сіу/сіх = 2х + 4. 
Шляхом кумулятивного інтегрування знаходиться первісна У = 
/ усіх = х 3 /3 + 2х 2 + сопзі (дивись документацію функції 
зсіру. іпіе§гаіе. ситігарг). 

Похідна і первісна можуть бути використані для пошуку 
екстремумів функції та для розв’язування рівнянь. Для пошуку 
екстремуму у потрібно розв’язати рівняння сіу/сіх = 0. А для 
пошуку кореня потрібно шукати екстремум первісної У. 

ітрогі питру аз пр 

ітрогі таірІоіІіЬ.руріоі аз ріі 

ігот зсіру.іпіе§гаіе ітрогі ситігар 2 

Х=пр.1іпзрасе(-5,3) 

У=Х**2+4*Х # функція 

р1і.р1оі(Х,У, к- ) 

У1=пр.бііі(У)/пр.сІііі(Х) # похідна 
ріі.ріоі(Х[:-1],У1,' к-- ) 

У1=пр.§гасІіепі(У,Х[1]-Х[0]) # або 
ріі.р1оі(Х,У1,' к-- ) 

У_іпі=ситігар 2 (У, X, іпіііаі=0) # первісна 
ріі.р!оі(Х,У_іпі, к: ) 


146 







-5-4-3-2-10 1 2 З 


х 

Рисунок 22 - Функція у = х 2 + 4х (-), її похідна (—) і первісна (..) 

8СІру.іпіе§гаіе - інтегрування 

Модуль зсіру. іпїеегаїе містить функції для інтегрування, у 
тому числі для інтегрування звичайних диференціальних рівнянь. В 
прикладі дано функцію у = х 2 . Розраховується визначений 
інтеграл \\ 3 усіх. 

ітрогі питру аз пр 

-Ргот зсіру. Іп1:е§га1:е ітрогі яиасі 

-р = ІатЬсІа х,а: х**а # функція 

ргіпі яиасІ(-Р, -З, 3, аг§з=(2,)) # результат 

інтегрування і оцінка абсолютної похибки результату 

х=пр.аггау([-3,-2, -1,0,1,2,3]) 

ргіпі пр.ігар 2 (-р(х, 2 ),х) # інтегрувати задану масивом 
функцію методом трапецій 


147 








(18.0, 1.9984014443252818Є-13) 

19.0 

8СІру.іпіе§гаіе.осіеіпІ - звичайні диференціальні рівняння 

Функція зсіру. іпіе^гаіе. осіеіпі: розв’язує систему 
звичайних диференціальних рівнянь з початковою умовою. В 
прикладі розв’язується просте диференціальне рівняння з 
початковою умовою у(0) = 0: 


^У = г 2 
<и 

-Ргот зсіру.іпіе^гаіе ітрогі осіеіпі: 

ітрогі питру аз пр 

ітрогі таірІоіІіЬ.руріоі аз ріі 

сіе-Р сІегіу(у,і:): # функція повертає похідну ду/сіі в 
точці і 

геїигп 1**2 # значення правої частини рівняння 
і = пр.1іпзрасе(0, 1, 100) # час 

у = осіеіпі: (сієпіу, у0=0, 1=1:) # інтегрує диф. рівняння 
р11:.р1о1:(1:,у, к- ) # рисує залежність у (і) 

ріі.х!аЬеі( 'і' );ріі.уіаЬеі( у ); ріі.§гісІ(); ріі. зИои/() 


148 




Рисунок 23 - Розв’язок диференціального рівняння 

8СІру.іпІе§гаІе.О(1етІ - модель польоту снаряду 


Модель польоту снаряду, випущеного під кутом 45 градусів до 
горизонту. Систему диференціальних рівнянь другого порядку 

сі 2 х/сіі 2 = 0, 

сі 2 у/сіі 2 = —9.8 


перетворимо в систему диференціальних рівнянь першого порядку 

сіх'/сіі = 0, 

(Іх/йі = X і , 
сіу'/сіі = —9.8, 
сіу/сіі = у', 

де х, у - переміщення; х \ у’ - швидкості. Початкові умови: д-0, 
х =50, у=0, у -50. Знайти функції х, х у, у 

-Ргот зсіру. Іп1:е§па1:е ітрогі: осіеіпі: 
ітропі: питру аз пр 


149 




ітрогі: таіірІо'ЬІіЬ.руріоі: аз ріі: 
сіе-р сіегіу(ху^): 

х=ху[0] # переміщення по X 
х_=ху[1] # швидкість по х 
у=ху[2] # переміщення по у 
у_=ху[3] # швидкість по у 

геііігп пр.атау([х_, 0.0, у_, -9.8]) # повертає 
значення функцій дх/ді } дх'/д± } ду/д± } ду'/ді 
± = пр.1іпзрасе(0.0, 10.0, 100) # час 
іпії: = пр.апгау( [0.0, 50.0, 0.0, 50.0]) # початкові 
умови для х, х', у, у' 

ху = осієіп1:(сієгіу, іпії;, і) # інтегруємо систему диф. 
рівнянь , отримуємо масив [х> х', у, у'] 

ріі. р1оі:(ху [:, 0] , ху[:,2]) # траєкторія 

ріі. х!аЬе!( "х 1 ); ріі .у!аЬе!( 'у" ); ріі .§гіс)(); ріі:. зИои/() 



Рисунок 24 - Траєкторія переміщення у(х) 


8СІру.іпІе§гаіе.ос1еіпІ - модель коливань, що згасають 

Модель коливань пружини з масою т, жорсткістю ] та 
коефіцієнтом демпфування с описується диференціальним 
рівнянням другого порядку 


150 







й 2 у , йу . . _ 

т—- + с - V іу = 0. 

аі 2 лі ^ 


Спочатку його необхідно перетворити 
диференціальних рівнянь першого порядку 

Ау 

ТГ У ’ 


систему 


(Іу' —]у — су' 
йі т 


де у - переміщення, у ’ - швидкість, сіу ’/сіі - прискорення. Початкові 
умови: у=1, у’=0. Знайти функції у та у 

-Ргот зсіру.іпіе^гаіе ітрогі осіеіпі: 

ітрогі: питру аз пр 

ітрогі: таіріоіііь.руріоі: аз ріі 

сіе-р сієгіу(уД) : 

т=1.0; з=1.0; с=0.1 

геіигп [у[і], (-]*У[0]-с*у[1])/т] # повертає 
значення функцій ду/ді та ду'/ді 
і = пр.1іпзрасе(0.0, 10. 0; 100) # час 
уіпіі = пр.аггау( [1.0, 0.0]) # початкові умови для 
'у' та 'у 1 ' 

у = осіеіпі: (сієгіу, уіпіі, і) # інтегруємо систему диф. 
рівнянь, повертає двовимірний масив зі значеннями 'у' 
та 'у 1 ' 

ріі.р1оі(1:, у[:,0], ’к-', і, у[:,1], ’к--’) # 

переміщення і швидкість 

ріі.х1аЬе1( "і" );ріі.у1аЬе1( у, 
у’ );ріі.§гіс!();ріі.зйо\л/() 


151 





Рисунок 25 - Функції переміщення у (-) і швидкості у ’ (-) 

зсіру.іпіегроіаіе - інтерполяція 

Інтерполяція - це спосіб знаходження проміжних значень 
величини за її відомим дискретним набором значень. Для 
інтерполяції і апроксимації сплайнами застосовують функції з 
модуля зсіру. іпіепроіаііе (іпіегрісі, ІІпіуагіаіеБрІіпе, 
Іпі:егр2с1, 5тооі:ІіВІуагіа1:е5р1іпе та інші). Сплайн - це 
функція, область визначення якої розбита на частини, на кожній з 
яких функція є певним поліномом. 

ітрогі питру аз пр 

-Ргот зсіру. іпіегроіаііе ітрогі: іпіегрісі, 
ІІпіуагіаіеБрІіпе, Іп1:егр2с1 
Р=1атЬсІа х: х**х # функція 
х = пр.агап§е(4) 

У = *(х) 

ргіпі х,у # дискретний набір значень 

уі = іпіегріб (X; у, кіпсІ= ' Ііпеаг' ) # лінійна 

інтерполяція 

у2 = іпіегріб(х, у, кіпсІ= 1 яиасігаїїіс ' ) # інтерполяція 
квадратичним сплайном 


152 






у2 = 11піуагіа1:е5р1іпе(х, у, к=2, 5=0) # або (з ■ 

коеф. згладжування) 

І<п=у2.§е1:_кпо1:5() # вузли сплайна 

ргіпі: у1(2.5), у2(2.5), -р(2.5) # інтерпольовані і 

дійсне значення в точці х=2.5 

ітрогі таірІоІіІіЬ. руріоі аз ріі 
х=пр.1іп5расе(0,х.тах(), 100) 

ріі. р1о1:(х,-Р(х) , 'к-' ,х,у1(х), ' к- -' ,х,у2(х), ' к: ) # 

графіки 

ріі.5са1:1:ег(кп,у2(кп)) # вузли кв. сплайна 

ріі .х1аЬе1( ' х' ), ріі: .у1аЬе1( у' ) ^ ріі:. ^гісі () ^ ріі. 5Ію\л/() 

ї ІатЬсІа х,у: х**2+у**2 # функція двох змінних 

х=пр.аггау([0,1,2]) 

у=пр.аггау([0,1,2]) 

хх, УУ = пр.те5Іі§гісІ(х,у) # сітка 

2 =-Р(хх,уу) # значення функції у вузлах сітки 

7.1 = Іп1:егр2с1 (х, у, 7 , кіпсІ= ' Ііпеаг ) # двовимірна 

лінійна інтерполяція даних х,у,г 

ргіпі; 21(0.5,0.5), ^(0. 5,0.5) # інтерпольоване і 

дійсне значення в точці 0.5, 0.5 


[0 1 2 3] [ 1 1 4 27] 

15.5 12.6458333333 9.88211768803 


153 





25 








/.7 

/.•/ 

/;/ 

/:/ 








/ / / 

/ ,* / 

/ ; / 

/ / 







і 

/ 

/ • 
/ • 

/ _• 








/ ; / 
/ .•/ 

/ .•/ 














Г** 









о'о 0.5 ТО Т5 20 2.5 3.0 


х 

Рисунок 26 - Функція (-) та її лінійна (--) і квадратична (..) 
інтерполяції сплайнами 

[ 1.] 0.5 

зсіру.оріітіхе.ізоіуе - розв’язування рівнянь 

Для розв’язування нелінійного рівняння чисельним методом 
застосовують функцію зсіру.оріітіхе.Р зоіує. Для 
розв’язування систем нелінійних рівнянь див. 
зсіру. оріітіхе. гооі:. В прикладі розв’язується рівняння 
х 2 - 2 = 0. 


ітрогі питру аз пр 
■Ргот зсіру.оріітіхе ітрогі: Рзоіує 
сіє-Р Р(х,а): # функція (х - вектор, а - константа) 
геіигп х**2-а # повертає ліву частину рівняння 
х0 = ■Рзо1ує( 1 : ^ пр. агпау ([ -10, 10]) , аг§з=(2,)) # 
розв'язати рівняння з початковими значеннями коренів 
х0=[-10,10] 

ргіпі Х0 # корені рівняння 


[-1.41421356 1.41421356] 


154 





зсіру.оріітіхе.гооі - розв’язування систем рівнянь 

Для розв’язування систем нелінійних рівнянь чисельними 
методами застосовують функцію зсіру. оріїітіге. гооі:. Її 
необов’язковий параметр теІіРіосІ визначає метод розв’язування 
системи (ЬуЬп, 1т, сі-р-запе, Ьпоусіепі, Ьгоусіеп2, апсіегзоп, 
1іпеагтіхіп§, сІіа§Ьпоусіеп, ехсі1:іп§тіхіп§, кпуіоу). За 
замовчуванням використовується РіуЬг. В прикладі розв’язується 
система: 


2x1 + 2 % = 0 ; 
х 0 — 2 = 0. 

■Ргот зсіру .оріїітіге ітрогі гооі 
сіе-р -Р(Х; а ^ Ь ^ с): # векторна функція 
геіигп [а*х[0]**2 + Ь*х[1]; 

х[0]-с] # список лівих частин рівнянь 

зої = гоо1:(-р., [0, 0]; аг§з=(2, 2, 2)) # розв'язати 
систему рівнянь з початковими значеннями коренів 
хв=[в ) в] 

ргіпі: зої.х # корені 


[ 2. -4.] 


8СІру.оріітІ2е.сигуе_Ш - регресійннй аналіз 

Регресійний аналіз (Ьіір://еп.\¥Ікіредіаюг§/\уікі/ 

Ке§ге88Іоп_апа1узІ8) - це статистичний метод дослідження впливу 
однієї або декількох незалежних змінних х на залежну змінну у. Для 
пошуку функціональної залежності /(х), яка найкраще описує 
емпіричну залежність у від х, застосовують метод найменших 
квадратів (МНК). МНК оснований на мінімізації суми квадратів 
відхилень значень функції Дх) від значень у. 

ітрогі питру аз пр 

■Ргот зсіру.оріітіхе ітрогі сигуе_-Рі1:, Іеазізя 


155 






ітрогі таірІоіІіЬ. руріоі аз ріі # для побудови 

графіків 

х=пр.аггау([0, 1, 2, 3]) # емпіричні значення х 
у=пр.аггау([1, 1.5, 3, 4]) # емпіричні значення у 

# за допомогою зсіру . орїітіге . сиг^е_^іі: 
сІе-Р і(х, а, Ь): # модель - лінійна залежність 
у=а*х+Ь" 

геіигп а*х+Ь # тут можна змінити модель на іншу 
функцію 

рорі, рсоу = сигуе_-Рі1:(-І : , х, у) # апроксимувати дані 
залежністю / за допомогою нелінійного МНК 
ргіпі рорі # знайдені значення параметрів 'а' і 'Ь' 
ргіпі рсоу # коваріаційна матриця для 'а' і 'Ь' 
ргіпі: пр.зргі(пр.с1іа§(рсоу)) # стандартні відхилення 
для 'а' і 'Ь' 

гезісіиаіз = у - і(х,*рорі) # відхилення 

ргіпі "РМ5Е , (пр.5ит(ге5ІсІиаІ5**2)/(ге5ІсІиаІ5.зііе 

2))**0.5 # стандартна помилка (гоої-теап-зциаге еггог 
(КМ5Е)) 

утеап = пр.теап(у) # середнє у' 

55_гез = пр.сІоі(ге5ІсІиаІ5, гезісіиаіз) 
зз_іоі = пр.сіоі:((у утеап), (у утеап)) 
ргіпі "К л 2: ", 1 55_гез/55_іоі # коефіцієнт 

детермінації (К-квадрат) 

ргіпі "К л 2: , пр.соггсоеі(у, і(х,*рорі))[0, 1]**2 # 

або так 

ха=пр.1іпзрасе(0,3,100) # 100 значень на проміжку 
0..3 

уа=і(ха, *рорі) # масив значень / з параметрами 
а=рорї[0 ], Ь=рорї[1] 

р1і.р1оі(х, у, ’ко--') # нарисувати емпіричну 
залежність 

р!і.р!оі(ха, уа, 'к- 1 ) # нарисувати апроксимовану 


156 




залежність 

рІі.хІаЬеЦ ’х' ); ріі.уіаЬеі( у'); ріі. 5Ію\л/() 

рг і пі: "Рисунок - Лінійна регресія" 

# або за допомогою зсіру.орїітіїе . іеазізр: 

Сіе-Р гезісІиаІ5_(р,х,у): #р - кортеж параметрів 

ге'Ьигп у - -Р(х, р [в], р[1]) # повертає відхилення 
ап5=1еаз1:5р(-Рипс=ге5ІсІиаІ5_^ х0=(1 , 1 ), аг§5=(Х;у ), -Ри11_ 
ои1:ри1;=Тгие) # мінімізує суму квадратів 
ргіпі: апз[0] # знайдені значення параметрів 'а' і 'Ь' 

# або за допомогою зсіру . зїаїз.ііпгедгезз (тільки 
лінійна регресія): 

-Ргот зсіру.зіаіз ітрогі 1іпге§гезз 
зіоре., іпіегсері, г_уаіиЄ; р_уаіие, 

5ІСІ_ЄГГ=1ІПГЄ§ГЄ55 (X; у) 

ргіпі: зіоре, іпіегсері # знайдені значення параметрів 
лінійної залежності 

ргіпі: "К л 2:", г_уа1ие**2 # коефіцієнт детермінації 
(7?- квадрат) 


[1.05 0.8 ] 

[[ 0.0175 -0.02625] 

[-0.02625 0.06125]] 

[ 0.13228757 0.24748738] 

КМ5Е 0.295803989155 
К л 2: 0.969230769231 
К л 2: 0.969230769231 


157 





40 


35 

10 

15 

10 

15 

10 



То 05 10 15 10 15 

х 


ЗО 


Рисунок 27 - Лінійна регресія 


[1.05 0.8 ] 

1.05 0.8 

К л 2: 0.969250769231 


8СІру.орІітіхе.сигуе_Ш - множинна регресія 

Функція зсіру. оріітіїе. сигуе_-Рі1: може бути використана 
для апроксимації даних функцією багатьох змінних. 

Таблиця 1 - Експеримент альні дані - залеж ність у від хО і хі 


^\х() 

хі"\ 

0 

1 

2 

0 

0 

1 

2 

1 

1 

2 

3 

2 

2 

3 

7 


ітрогі питру аз пр 

■Ргот зсіру.оріітіїе ітрогі сигуе_Еі1: 

■Ргот зкіеагп. теігісз ітрогі п2_зсоге 

сІе-Р Т(х, а^ Ь, с): # модель - функція двох змінних 

158 













х[0] і х[1] 

геіигп а + Ь*х[0] + с*х[1] 

# експериментальні дані: 
х = 

пр.аггау([[0,1,2,0,1,2,0,1,2,],[0,0,0,1,1,1,2,2,2]]) 

# х0 } х1 

у = пр.аггау([0,1,2,1,2,3,2,3,7]) #у 
#у = пр.а^^ау([0 ^ 1 ^ 2 ^ 1 ^ 2 ^ 3 ^ 2 ^ 3 ^ 4]) # спробуйте також 
рорі:рсоу = сигуе_-Рі1:(-р, X; у) # апроксимувати 
нелінійним МНК 

ргіпі рорі: # знайдені значення параметрів а, Ь, с 

# рисуємо тривимірні графіки 

-Ргот тр1_іоо1кі1:5. трІоІіЗсІ ітрогі: ахезЗсІ # для 
рисування ЗО графіків 

ітрогі: таірІоіІіЬ.руріоі аз ріі 

-Рі§ = р1і.-Рі§иге() # створити фігуру 

ах = -Рі§. асІсІ_5иЬр1о1: (111^ рго]ес1:іоп= ' Зеї ) # додати 

ЗО графік 

# змінити форму масивів: 

# 

х0, х1=пр.тезІідгід( пр.аггау( [0 ^ 1^ 2] ), пр.аггау( [0 ^ 1 ^ 2]) 

) 

# або так: 

х0=х[0].гезЬаре((3,3)) # [[0 1 2] } [0 1 2] } [0 1 2]] 
х1=х[1].гезИаре((3,3)) # [[в 0 07, [1 1 1]/[2 2 2]] 
у=у.гезНаре((3,3)) # [[в 1 2],[1 2 3],[2 3 7]] 
ргіпі: "К2=", г2_зсоге(у; і((х0;ХІ)ЛроріО) # 
коефіцієнт детермінації (7?- квадрат) 
ах. зсаі1:ег(х0, хі, у) # показати емпіричні точки 
хх0 , ххі = пр.тезН§гісі(пр.1іп5расе(0, 2, 10) ^ 
пр.1іпзрасе(0, 2, 10)) 

уу=-Р((хх0,хх1),*Рор1:) # апроксимовані значення 

ах. р1оі_\л/іге-Ргате(хх0, ххі., уу; гзігісІе=1, С5ігіс1е=1) 


159 




# показати поверхню 

#ах.р1о±_зиг£асе(хх0 } ххі, уу } Г5±гіде=1 } сзігісІе=1) 

# або 

ах. 5е1:_х1аЬе1 ( х0' );ах. зеі:_у1аЬе1 ( 'хі' );ах. зеі:_2ІаЬе1 
( 1 у' ); ріп. зЬо\л/() 


[-0.66666667 1.5 1.5 ] 

К2= 0.678571428571 



7 

6 

5 


2 

1 

О 

-1 


2.00 0.00 

Рисунок 28 - Множинна регресія 


8сіру.орІітІ2Є.ГтіпЬоипс1 - оптимізація функції однієї змінної з 

границями 

В математиці оптимізацією називають задачу знаходження 
екстремуму (мінімуму або максимуму) функції Дх) в деякій області 
значень х. Оптимізація буває 

• локальна - для пошуку локального екстремуму; 

• глобальна - для пошуку глобального екстремуму. 

Методи оптимізації поділяються на 


160 





• детерміновані; 

• стохастичні; 

• комбіновані. 

За порядком похідної, що обчислюється, поділяються на 

• прямі (обчислюються тільки значення функції); 

• першого порядку (градієнтні); 

• другого порядку. 

Інтерфейсом для оптимізації функції однієї змінної різними 
методами є тіпітІ2Є_2са1аг. Розглянемо локальну оптимізацію 
скалярної функції (однієї змінної) /(х) = 5Іп(х ) + соз(х 2 ) методом 
Брента. 

ітрогі питру аз пр 

Ргот зсіру.орРітІ 2 Є ітрогі: тіпітІ2Є_зса1аг, РтіпЬоипсІ 
сІе-Р Р(х): # функція однієї змінної (цільова функція) 
геРигп пр.зіп(х)+пр.соз(х**2) 
гез = тіпітІ2Є_зса1аг(Р, Ьоипбз=(-3, 3), 
теї:ИосІ= ' ЬоипсІесІ' ) # знайти мінімум ?(х) в заданих 
границях. Критерій пошуку - мінімум } допустима 
множина х від -3 до З 
рг і пі: "аг§тіп=", пез .х 

аг§тіп = РтіпЬоипсІ(Р; -3, 3) # або так 
ргіпР "аг§тіп='^ аг§тіп 

аг§тах = РтіпЬоипсІ (ІатЬсІа х: -Р(х), -З, 3) # знайти 

максимум /(х) в заданих границях 

ргіпР "аг§тах="; аг§тах 

ітрогі таРріоРІіЬ.руріор аз рІР 

х=пр.1іпзрасе( -З, 3 ,100) 

рІР. р1оР(х^Р(х) , ' І<' ) # графік 

рІР.зсаРРег([аг§тіП;аг§тах], [Р(аг§тіп),Р(аг§тах )], 


161 





1іпе\л/ісІ1:ІП5=[З л 3]) # локальні екстремуми 

рГЬ.х1аЬе1( 'х' );ріі: .у1аЬе1( у ); ріі.§гісі(); ріі. 5Ііо\л/() 


аг§тіп= -1.75748900285 
аг§тіп= -1.75748900285 
аг§тах= 0.730978404712 



X 


Рисунок 29 - Графік функції і знайдені локальні екстремуми 

8СІру.орІітІ2е.ГтіпЬоипс1 - локальна оптимізація невідомої 

функції 

В цьому прикладі Дх) не розраховує значення наперед відомої 
функції і для кожного значення х користувач повинен ввести 
відповідне значення у, отримане, наприклад, експериментом. Для 
прикладу у = х 2 , тоді на запит х=2 користувач повинен ввести у=4. 
Користувач вводить у поки різниця нового і попереднього х є 
великою. 


ітрогі: питру аз пр 

Ггот зсіру.орГітіге ітрогі: РтіпЬоипсІ 

і=0 # лічильник ітерацій 

Сіе-Р Г(х): 

§1оЬа1 і # глобальна змінна 

162 















і+=1 # збільшити лічильник 

у=іприі("І1:ега1:іоп %б х=%Р у="%(і,х)) # вивести 
'х' і ввести відповідне 'у' 

геіигп у 

аг§тіп = РтіпЬоипсІ(Р, -1, 1) # знайти мінімум 
ргіпі аг§тіп 


Ііегаііоп 1 х=-0.236068 у=0.055728 
Ііегаііоп 2 х=0.236068 у=0.055728 
Ііегаііоп 3 х=0.527864 у=0.278640 
Ііегаііоп 4 х=-0.000000 у=0.000000 
Ііегаііоп 5 х=0.000003 у=0.000000 
Ііегаііоп 6 х=0.000007 у=0.000000 

8СІру.оріітіге.Гтіп_1_ЬГ§8_Ь - оптимізація з границями методом 

Ь-ВГ08-В 

Локальна оптимізація векторної функції (двох змінних) 
популярним квазі-ньютонівським методом Ь-ВР08-В, який 
призначений для нелінійних задач з великою кількістю невідомих 
(Ннр://сп.\\їкірссііа.ог«/\\їкі/ЬітіІ;есі-тетоі'у_ВРС5). Інтерфейсом 
для оптимізації функції однієї або багатьох змінних різними 
методами є тіпітіїе. В прикладі шукається мінімум функції 
у = Хд + х\ в межах значень [-5, 5] змінних х 0 і х г . 

ітрогі питру аз пр 

Ргот зсіру.оріітіїе ітрогі тіпітіїе, Ртіп_1_ЬР§з_Ь 
сіе-р Р(х): # функція двох змінних 

геіигп х[0]**2+х[1]**2 

гез=тіпітІ 2 е(Р, х0=[1.0, 1.0], теіІіосІ="І--ВРС5-В", 
ЬоипсІ5=[(-5,5), (-5,5)]) 
ргіпі: гез.х 

аг§тіп = Ртіп_1_ЬР§з_Ь(Р, х0=[1.0, 1.0], ЬоипсІ5=[( 
5,5), (-5,5)], арргох_§гасІ=Тгие) # або так 
ргіпі аг§тіп[0] 


163 








ітрогі таірІоіІіЬ. руріоі аз ріі 

Ргот тр1_1:оо1І<і1:5. трІоіЗсІ ітрогі: АхезЗй 

ах=АхезЗО(р11:.1 : і§иге()) # система координат 

X, V = пр.те5Іі§гісІ(пр.1іп5расе(-5,5), пр.1іпзрасе(- 

5,5)); 2=Р( [X, V] ) 

ах. р1о1:_\л/іпе1 : пате(Х, У, 7.) # каркасна поверхня 
ах. 5саі1:ег(ге5 .х[0], гез.х[1], гез.Рип, с=’І< ) # 

мінімум 

ах. зе1:_х1аЬе1 ( Х0 ’ ), ах. 5еі_у1аЬе1 ( ’ XI ’ ), ах. 5еі_2ІаЬе1 
( ’У ); ріі. зИо\л/() 


[ -5.01107818Є-09 -5.01107818Є-09] 

[ -5.01107818Є-09 -5.01107818Є-09] 



Рисунок ЗО - Графік функції 


164 








8СІру.орІітІ2е.с1ійегепІіа1_еуоІиііоп - диференціальна еволюція 

Диференціальна еволюція - це метод глобальної оптимізації 
функції однієї або багатьох змінних, який відноситься до 
стохастичних методів оптимізації з границями. Не використовує 
градієнтні методи, але потребує більшої кількості ітерацій. 
Моделює такі процеси біологічної еволюції як розмноження, 
мутація, рекомбінація і відбір. Доступні різні еволюційні стратегії 
(Ннр://сіось.8СІру.ог§/с1ос/8сіру/геї'егспсс/2спсга[ссі/8сіру.орПтІ7,е.сііїїег 
епНаІ_е\'о1иЦоп.Ьнп1). В прикладі шукається мінімум функції хзіпх 2 
в межах [1, 4.5]. 

ітрогі: питру аз пр 

■Ргот зсіру.оріітіге ітрогі: сІі-р-Регеп1:іа1_еуо1и1:іоп 

■р=1атЬсІа х: х*пр.зіп(х**2) # функція однієї змінної 

ге з = сІі-р-Регеп1:іа1_еУ01и1:іоп(-Р, ЬоипсІ5 = [(1, 4.5)]) # 

знайти мінімум 

ргіпі гез 

ітрогі таірІоіІіЬ.руріоі аз ріі 

х=пр.1іпзрасе(1,5, 200) 

ріі . р1оі(х^1 : (х) , ' І< ’ ) # графік 

р1і.зса1:1:ег(ге5[ ’х’ ], гез[ ’-Рип ’ ], 1іпе\л/ісІ1:ІД5 = [З л 3]) # 

мінімум 

р14.х1аЬеі( 1 х ’ ); ріі.у!аЬеі( у’);р11:.§гісІ(); р14. зИо\л/( ) 


іип: аггау([-4.15851032]) 

^ас: аггау([ 4.79616347е-0б]) 
тезза§е: ’Оріітігаііоп іегтіпаіесі зиссезз-риііу. ’ 
п-Рєу: 158 
піі: 9 

зиссезз: Тгие 

х: аггау([ 4.16024526]) 


165 




Рисунок 31 - Графік функції і знайдений мінімум в межах [1, 4.5] 

8 СІру.оріітІ 2 е.Ьа 8 ІпЬорріп§ - комбінований метод глобальної 

оптимізацн 

Функція зсіру.орІїітіге.ЬазіпІіорріп^ реалізує 
комбінований метод глобальної багатомірної оптимізації. В кожній 
ітерації є етапи: 

• Випадкове збурення координат. 

• Локальна мінімізація. 

• Прийняття або відхилення нових координати, основане на 
мінімізованому значенні функції. 

Метод не гарантує знаходження мінімуму, оскільки алгоритм 
стохастичний. Алгоритм має багато параметрів, серед яких: 

• х0 - початкові значення мінімумів; 

• піГег - кількість ітерацій алгоритму; 

• Т - параметр для прийняття чи відхилення критерію; 

• зГерзіге- початковий розмір кроку для випадкових зміщень; 


166 



• тіпітІ2ЄГ_к\л/аг§5 - аргументи, які передаються локальному 
мінімізатору. Для пришвидшення можна також передавати 
мінімізатору похідні функції (Якобіан, Гессіан); 

• 1:аке_5І:ер - замінює функцію кроку за замовчуванням; 

• ассері_іез1: - визначає тест, який використовується для 
прийняття або відхилення кроку; 

• саІІЬаск - функція, яка викликається, коли знайдено 
локальний мінімум. 

ітрогі питру аз пр 

-Ргот зсіру.оріітіге ітрогі: ЬазіпЬорріп§ 

сіе-р -Р(х): # функція двох змінних 
у = пр.соз(14.5*х[0]- 
0.3)+(х[1]+0.2)*х[1]+(х[0]+0.2)*х[0] 

#у=1 + 2*х[0] + 2*х[1] # (тільки для тестування 
ассері_іезі. Див. нижче) 

геіигп у # для пришвидшення пошуку мінімуму 
функція разом зі значенням може також повертати 
градієнт (див. документацію) 

геї: = ЬазіпЬорріп^-Рипс^, х0=[0.0, 0.0]) # знайти 

мінімум 

ргіпі геі['х'], геї: [' -Рип ' ] 

сіазз МуВоипсІз (оЬ^'есі): # реалізує границі проблеми 

сіе-р іпіі (зеї-Р, хтах=[1.1, 1.1], хтіп=[-1.1, 

1 . 1 ] ): ' 

зеї-р.хтах = пр.аггау(хтах) # максимум для х 
зеї-Р.хтіп = пр.аггау(хтіп) # мінімум для х 

сіе-р саіі (зеї-Р, **1<\л/аг§з): 

х = к\л/ап§з [ "х_пе\л/" ] 

ітах = Ьоо1(пр.а11(х <= зеї-р.хтах)) # Тгие, 

якщо х менше рівне максимуму 

ітіп = Ьоо1(пр.а11(х >= зеїі.хтіп)) # Тгие } 


167 





якщо х більше рівне мінімуму 

геіигп ітах апсі ітіп # якщо Раізе (за 
границями), то мінімум не приймається 

сіе-р ргіп1:_-Рип(х, і, ассеріїесі): # викликається, коли 

знайдено лок. мінімум 

ргіпі: "і-ос. тіп. , х , Р, ассеріїесі # координати, 
значення функції, чи мінімум приймається 

геї: = Ьа5ІпРюрріп§(-Рипс=-р, х0=[0.0, 0.0], пі1:ег=5, 
5І:ер5І2е=0. 1, тіпітІ2еп_кіл/ап§5 = {"теїНосІ": "І.-ВРС5- 
В"}, ассер1;_1;е5І:=МуВоипсІз(), са11Ьаск=ргіп1:_-Рип) # 

знайти мінімум 

ргіпі: геї:[ 'х' ]^ геї:[' -Рип'] 

ітрогі таірІоІіІіЬ. руріоі аз ріі 

■Ргот тр1_1:сю1кі1:з. трІоіЗсІ ітрогі АхезЗй 

ах=АхезЗО(р11:.-Рі§иге()) # система координат 

X, У = пр.те5рі§гісІ(пр.1іп5расе(-1,1), пр.1іпзрасе(- 

1,1)); 2=-Р([Х,У]) 

ах. р1о1:_\л/іге-Ргате(Х, У, 2) # каркасна поверхня 
ах. зса1:1:ег(ге1:[ 'х' ] [0], геї:[ ’х' ] [1], геї:[ ’-Рип' ], 

с = 1 к 1 ) # мінімум 

ах. зе1:_х1аЬе1 ( Х0' ),ах. зе1:_у1аЬе1 ( ' XI' ), ах. зе1:_2ІаЬе1 
( 'У );ріі.зРіо\л/() 


[-0.19506755 -0.10000001] -1.01087618444 

І_ос. тіп. [-1.05352142 -0.09999747] -0.102110348616 Т 

гие 

І_ос. тіп. [-0.19506756 -0.1 ] -1.01087618444 Тг 

ие 

І_ос. тіп. [-0.19506756 -0.1 ] -1.01087618444 Тг 

ие 

І_ос. тіп. [ 0.23417127 -0.10000023] -0.907266719691 Т 
гие 


168 





І_ос. (ПІП. [ 0.23417128 -0.10000001] -0.907266719691 Т 
гие 

[-0.19506756 -0.1 ] -1.01087618444 



Рисунок 32 - Графік функції 


8СІру.8ІаІ8 - випадкові величини 

Модуль зсіру.зіаііз містить велику кількість дискретних і 
неперервних розподілів імовірності і бібліотеку статистичних 
функцій. Випадкова величина (ВВ) - це величина, значення якої є 
результатом випадкового явища. Розподіл ймовірностей - це закон, 
який описує область значень випадкової величини і імовірності їх 
появи. В прикладі показані функції для роботи з ВВ. 

ітрогі питру аз пр 

ітрогі таірІоіІіЬ. руріоі аз ріі 

Ггот зсіру ітрогі: зіаіз 


169 










СІІ5І = зіаііз. погт(1ос=15, зса1е=1) # ВВ з нормальним 
розподілом 

X = пр.1іпзрасе(10,20,100) # область значень ВВ 
Хз=сІІ5І:. гуз(зІ2Є=1000) # випадкова вибірка значень ВВ 
розміром 1000 

ргіпі: Хз.теап(); Хз.5І:сІ()_, Хз.уаг() # середнє, 

середньоквадратичне відхилення, дисперсія 

ріі.Ніз1:(Х5, Ьіпз=20; погтесІ=Тгие, со1ог='у') # 

гістограма вибірки 

ріі. р1оі(Х., сіізі:.рсИ(Х ), ' к' ) # функція густини 
імовірності розподілу ВВ 

р11.р1о1(Хд сіізі. ссІ-Р(Х) , ' к-- ' ) # функція розподілу ВВ 
(імовірність того, що ВВ буде мати значення менше або 
рівне х) 

ргі пі: сіізі. ссИ(15)-сіізі. ссИ(0) # імовірність 

попадання в інтервал значень (0,15) 

р1і.х1аЬе1( 'х' );ріі.у1аЬе1( у, 

У );ріі.§гісі(); ріі. зііо\л/() 

ргі пі: "Рисунок - Гістограма, функція густини 
імовірностей у(х) (-) та функція розподілу У(х) 

р1і.-Рі§иге() 

У=пр.1іпзрасе(0, 1,100) # область значень функції 
розподілу 

ріі:. ріоі(У_, сіізі. рр-р(У ), ' І< ) # квантільна функція 

(інверсна до сд^) 

ргіпі сІіз1:.рр-Р(0.5) # значення ВВ, якому відповідає 
сс//=0.5 

ссіі1=5ІаІ5. попт(). ссИ(З) # 0.998650101968 
ссН^зіаіз. погт(). ссІ-Р(-З) # 0.00134989803163 
ргіпі ссі-Рі-ссі-Р2 # імовірність попадання в інтервал (- 
3*зїд, +3*зїд) 

# квантілі стандартного нормального розподілу: 

ргіпі зіаіз.погтО .рр-Р(сс)-Рі) # з рівнем сд^І 
ргіпі 5Іа1з.погт() ,рр-р(0.5) # з рівнем 0.5 


170 




рІГ.хІаЬеЦ 'У' );р11:.у1аЬе1( х );ріі.§гісі();рІГ.5Йои/() 

рг і пі: "Рисунок - Квантільна функція х(У)" 


14.9819184126 0.984759375625 0.969751027882 
0.5 



ОС — І і "* 8 - 1 - І - — т 

10 12 14 16 18 20 


х 

Рисунок 33 - Гістограма, функція густини ймовірностей у(х) (-) 
та функція розподілу У(х) (—) 


15.0 

0.997300203937 

3.0 

0.0 


171 







17 


16 

* 15 

14 

13 


0.0 02 04 Об 08 10 

У 

Рисунок 34 - Квантільна функція х(У) 

8сіру.8іаІ8 - підгонка кривих і перевірка статистичних гіпотез 

Дано вибірку з N значеннями випадкової величини. Потрібно 
вияснити чи підлягає ця випадкова величина нормальному 
розподілу. Це можна зробити за допомогою: 

• візуального порівняння емпіричної гістограми і кривої 
нормального розподілу; 

• функції погтаїіезі:; 

• функції кзіезі:; 

• функції сНізриаге. 

ітрогі питру аз пр 

Ргот зсіру ітрогі: зіаіз 

ітрогі: таіріоіііь.руріоі: аз р14 

сіізі: = зіаіз.погт(1ос=15, зса1е=0.5) # нормальний 

розподіл 

#дізі=5іа±5. ипі^огт(іос=14 і зсаіе=2) # рівномірний 
розподіл (для порівняння) 

N=1000 # розмір вибірки 


172 






Х=сіі5і:.гу5(5І2Є=і\і) # випадкова вибірка з цього 
розподілу 

теап,5І:сІ = зїаїз.погт.-РіІ^Х) # підігнати криву норм, 
розп. і отримати її параметри 

к2;руа1ие = зііаііз. погта11:е5І:(Х) # тест на нормальний 
розподіл (к2 - сума квадратів коефіцієнтів асиметрії 
і ексцесу) 

ргіпі: к2,руа1ие # наприклад, якщо риаіие < 0.05, то 
це не нормальний розподіл 

сІ,руа1ие = зіаіз.кзііезі:(Х л сіізі:.ссі-р) # тест 
Колмогорова- Смірнова 

#або зїаїз.кзїЄ5ї(Х, ’погт', агдз=(15, 0.5)) 
ргіпі: с^руаіие # якщо риаіие < 0.05, то ці розподіли 
не ідентичні 

# побудова емпіричної гістограми і теоретичної 
кривої: 

п,х=пр.Иіз1:о§гат(Х, Ьіпз=10) # кількість значень в 
кожному інтервалі, інтервали 
хтіп=х[:-1] # масив мінімумів інтервалів 
сіх=х[1] -х[0] # ширина інтервалу 
у=п/(І\І*сІх) # емпірична приведена частота 

# площа одного прямокутника гістограми дорівнює 
відносній частоті: р=п/N=дx*п/(N*дx) 
хтісІ=хтіп+сІх/2 # масив центрів інтервалів 

ріі. Ьаг(хтісі, у, ууісіі:И= сІх_, со1ог='у ) # нарисувати 

емпіричну гістограму приведених частот 

сіі5і: 2 = зіаіз. погт(1ос=теап, зса1е=5І:сІ) # нормальний 

розподіл з параметрами після підгонки 

ріі:. ріоі:(хтісісІІ5І:2. рсН 2 (хтісі ), 1 ко ) # нарисувати 

точки теоретичної кривої 

Х1=пр.1іп5расе(13,17,100) # аргументи для побудови 
теоретичної кривої 

ріі:. ріоі:(XI сіІ5і: 2 . рсі-р(XI) , к- ) # нарисувати 
теоретичну криву густини імовірності 


173 




ріі.х1аЬе1( 'х' );ріі:.у1аЬе1( у );ріі.§гіб();ріі:.5Іюи/() 
рг і пі: "Рисунок - Гістограма і функція густини 
розподілу" 

# перебірка: 

ргіпі пр. 5ит(сІх*у) # суло площ прямокутників: 1.0 
,або зит(п/И) 

ргіпі пр.1:гар2(с1із1:2.рсі-р (XI)_, XI) # інтеграл рд /: 1.0 

# порівнюємо емпіричні і теоретичні абсолютні частоти 
п1=пр.сІі-р-р(сІІ5І:2. ссі-р(х) # теоретичні абсолютні 
частоти - це площі криволінійних трапецій на кожному 
інтервалі. Без множення на N буде близько 1.0 

ріі. -Рі§иге() 

р1і;.р1оі;(п д ' к5-- 1 дПІд ' ко- 1 ) # емпіричні і теоретичні 
абсолютні частоти 

ріі. х1аЬе1(и ' інтервал ); ріі .у1аЬе1( ' п' ); ріі .§пісі(); рі 
і:. зИо\л/() 

ргіпі "Рисунок - Емпіричні (--) і теоретичні (-) 
абсолютні частоти" 

сЬібц, р_уа1ие = зіаііз.сЬІ5циаге(П; пі) # хи-квадрат 
тест гіпотези подібності частот п і пі 
ргіпі сЬізц, р_уа1ие # гіпотеза приймається, якщо 
р\/аіие більше заданого (0.05) 


6.18744549283 0.0453328770782 
0.0245207935549 0.584607787303 


174 






X 

Рисунок 35 - Гістограма і функція густини розподілу 


1.0 

0.999957666033 



Рисунок 36 - Емпіричні (—) і теоретичні (-) абсолютні частоти 

16.4635646646 0.0578098854704 


175 








8СІру.8ІаІ8.кс1е - ядрова оцінка густини розподілу 


Ядрова оцінка густини розподілу - це непараметричний метод 
оцінки функції густини випадкової величини за вибіркою 
(Ьнр://сплуікіресІіа.ог£/\уікі/Ксгпс]_с1сп8ІІу_С8ПтаІіоп). Задається 
формулою 


п 



і= 1 


де X; - значення незалежних і однаково-розподілених випадкових 
величин; Н - параметр згладжування; К - статистичне ядро - 
симетрична, але не обов’язково додатна функція з інтегралом 
рівним одиниці. В прикладі використовується Гаусове ядро: 



ітрогі питру аз пр 

■Ргот зсіру. зіаіз ітрогі: кбе 

ітрогі таірІоіІіЬ.рурІоі аз ріі 

хі = пр. гапсіот. погта1(0, 3^ 50) # вибірка з 

нормального розподілу розміром 50^ т=0> зід=3 

х2 = пр.гапбот.погта1(4, 1, 50) # вибірка з 

нормального розподілу розміром 50^ т=4> зід=1 

х = пр. сопсаіепаіе( [х1.,х2]) # об'єднати дані 
сіепзііу = кбе. §аиззіап_ксіе(Х; Ь\л/_теіІ'іосІ=І\Іопе) # 

функція щільності. Можна також визначити свій метод 
згладжування Ьм_теібод . Може бути багатовимірна . 

х§гісІ = пр.1іп5расе(х.тіп(); х.тах()^ 100) 
ріі. Ьізі(Х; Ьіпз=8, погтесІ=Тгие, со1ог='у’) # 

гістограма 

ріі. ріоі:(х§гіс!бепзііу(х§гісі ), 'к- ) # функція 

щільності 

ріі.х!аЬе!( 'х' );ріі .у!аЬе!( у ); ріі.§гісі(); ріі. зІпои/() 


176 






Рисунок 37 - Ядрова оцінка густини розподілу 


зсіру.Шраск дискретне перетворення Фур’є 

Перетворення Фур’є — інтегральне перетворення однієї 
комплекснозначної функції дійсної змінної на іншу. Розкладає 
функцію на осциляторні функції, тобто подає сигнал у вигляді суми 
гармонічних коливань. Використовується для розрахунку спектра 
частот сигналів, які змінні у часі. Для дискретних функцій 
застосовують дискретне перетворення Фур’є. Модуль 
зсіру. РРРраск використовує швидкі алгоритми прямого і 
оберненого дискретного перетворення Фур’є (РРТ). 

ітрогР питру аз пр 

Ргот зсіру.РРРраск ітрогР РРі 

ітрогР таРрІоРІіЬ.руріор аз ріі 

N = 600 # кількість точок 

Т = 1.0 / 800.0 # проміжки часу 

А1=1.0; А2=0 .5 # амплітуди 

Р1=10.0; Р2=100.0 # лінійні частоти 

оте§а1=Рі*2.0*пр.рі; оте§а2=Р2*2.0*пр.рі # циклічні 

частоти 

х = пр.1іпзрасе(0.0, М*Т, N) # час 


177 









у = А1*пр.5Іп(оте§а1*х) + А2*пр.5Іп(оте§а2*х) # 

сигнал (лінійна комбінація синусоїдальних сигналів) 

р11:.р1о1:(х,у, к ) # нарисувати сигнал 

ріі .х1аЬе1( ' 1:' );ріі: .у1аЬе1( у ); ріі.§гісІ(); ріі. 5Ію\л/() 
ргіпі "Рисунок - Сигнал" 

у-р = -р-Ріі(у) # розрахувати спектр частот для сигналів 
змінних у часі за допомогою дискретного перетворення 
Фур'є. Декомпозиція сигналу на частоти і амплітуди. 
х-р = пр. 1іп5расе(0.0; 1.0/ (2 . 0*Т ), N/2) # частоти 
у-р_=2.0^ * пр.аЬ5(у-р[0:І\І/2]) # амплітуди 
р11:.-Рі§иге() 

ріі:. ріоі: (х-Р, у-р_ л ' к' ) # нарисувати спектр 

ріі.хіаЬе1(' -Р' );ріі.у1аЬе1( А');р11:.§гіс1(); ріі. 5Ііо\л/() 
ргіпі; "Рисунок - Амплітудно-частотна характеристика 
сигналу" 



Рисунок 38 - Сигнал 


178 






06 


0 5 
04 
4 03 
02 
0.1 
00 

0 50 100 150 200 250 300 350 400 

І 

Рисунок 39 - Амплітудно-частотна характеристика сигналу 

зсіру.Шраск - обернене дискретне перетворення Фур’є 

Обернене дискретне перетворення Фур’є повертає сигнал за 
спектром його частот. В прикладі показано застосування прямого і 
оберненого дискретного перетворення Фур’є для частотного 
фільтрування сигналу. 

ітрогі питру аз пр 

-Ргот зсіру.-р-Ріраск ітрогі: г-р-Рі:іг-р-Рі^ -Р-Рі-Ргер 
ітрогі таірІоіІіЬ.руріоі аз ріі 
ііте = пр.1іпзрасе(0,2,2000) # час 
зі§па1 = пр.соз(5*пр.рі*ііте) + 

2*пр.соз(7*пр.рі*ііте) # сигнал 

ІЛІ = і-Рі-Ргер(5І§па1 .зііЄ; сІ=ііте[1]-ііте[0]) # частоти 
■Р_зі§па1 = г-р-Рі(5і§па1) # спектр (дискретне 

перетворення Фур'є для дійсних) 

сиі_-Р_зі§па1 = і_зі§па1. сору() # копія сигналу 
сиі_-р_5і§па1[ (Ілкб) ] = 0 # фільтруємо сигнал 
(відкидаємо частоти<6) 

сиі_зі§па1 = Іг-Р-Рі:(си1:_-Р_5і§па1) # відфільтрований 

сигнал (обернене дискретне перетворення Фур'є для 










































V 

> 









і -1-1-І-1-І-1-г 


179 












дійсних) 

ріі. 5иЬр1о1:(121); ріі. ріоі:(1:іте л 5І§па1); 
рІ-Ь.хІаЬеІ( Ч' ); р1і:.у1аЬе1( 'у ) 
ріі:. зиЬр1оі:(122); ріі:. р1о1:(1:іте, си1:_5І§па1); 
ріі: .х1аЬе1( 4 ' ) 

ріі:.зИо\л/(); ргіпі: "Рисунок - Початковий і 
відфільтрований сигнал" 

р11:.-Рі§иге() 

ріі. зиЬр1о1:(121); ріі. р1о1:(1лІ^-р_5І§па1); 
р1-Ь.х1іт(0,10); рІі.хІаЬеЦ і ); рГі.уІаЬеЦ ’А’ ) 
ріі. зиЬр1о1:(122); ріі. р1оі(ІлІ, си^^зі^паї); 
р1і:.х1іт(0,10); ріі.х1аЬе1( і ) 

ріі.5Ііоіл/(); рпіпі "Рисунок - Спектр початкового і 
відфільтрованого сигналу" 



Рисунок 40 - Початковий і відфільтрований сигнал 


180 































Рисунок 41 - Спектр початкового і відфільтрованого сигналу 

зсіру.сіизіег - кластеризація 

Кластеризація (кластерний аналіз) - задача розбиття множини 
об’єктів на групи (кластери) подібних об’єктів. В прикладі показана 
кластеризація методом к-середніх, який оснований на мінімізації 
сумарного квадратичного відхилення точок кластерів від центрів 
цих кластерів. Спробуйте також потужній алгоритм кластеризації 
даних з наявністю шуму зкіеагп. сіизкег. 0В5САІМ. 

ітрогк питру 

■Ргот зсіру. сіизкег ітрогк ур 
ітрогк такрІокІіЬ.руріок аз рік 

# масиви випадкових точок з координатами х,у 

сі = питру. гапсіот. гапс!п(100, 2) + 5 
с2 = питру. гапсіот. гапс!п(30, 2) - 5 
сВ = питру. гапсіот. гапс!п(50, 2) 

сіака = питру.уз1:аск( [сі., с2^ с 3 ]) # об'єднати дані 

іл/Ьі1:еп=ур.мМікіеп(сіакіа) # нормалізувати дані 
сепкгоісіз ДаЬе1з=ур. ктеапз2(\л/1іі1:еп, 3) # центроїди і 


181 


















мітки 3-х кластерів 

#рії. 5саііег(даїа[: ,0] , даїа[: } 1] , с=іаЬеіз); 
рії.зкоіл/( ) 

# або 

сепігоісіз, сіізіогііоп = уя .ктеапз(сіаіа , 3) # 

сепїгоідз - центроїди 3-х кластерів методом к- 
середніх, дізїогїіоп - сума квадратів відстаней між 
точками і відповідною центроїдою 

ісіепііііесі, сіізіапсе = уя.уя(с!аіа, сепігоісіз) # масив 
для ідентифікації та масив з відстанями до центроїди 

# координати точок та відстані до центроїди в кожному 
кластері 

УЯСІ,СІ1 = с!аіа[іс1епіі-Ріес1 == 0], сІізіапсе[іс1епіі-Ріес1 
== 0] 

УЯс2,сІ2 = сіаіа [ісіепііііесі == 1 ]^ сІізіапсе[іс1епіі-Ріес1 
== 1] 

УЯсЗ,сІЗ = сіаіа [ісіепііііесі == 2], сІІ5І:апсе[ісіепііі-ріесі 
== 2] 

р1і.іі§иге() 

ріі. зсаііег(урс1[ :,0],УЯСІ[:,1],с= , г',з=с11*20) # 

точки кластера 1 

ріі. зсаііег(урс2[:,0],уяс2[:,1],с='§',з=сІ2*20) # 

точки кластера 2 

ріі. зсаііег(урсЗ[ :,0 ],уясЗ[:,1],с='Ь',5=сіЗ*20) # 

точки кластера З 

ріі. з саііег( сепігоісіз [: ,0] , сепігоісіз [: ,1 ] , 
тагкег='о', 5=10000, с='к , а1рЬа=0.2) # центроїди 
ріі .х!аЬе!( "х" );ріі .у!аЬе!( ’у" ); ріі.§гіс!(); ріі. зЬои/() 


182 

















ь 

г •*;. 


» 



/\ * ^ 

* 




» • ’ « 

• - 

• 









-8 -6 -4 -2 


4 


8 


X 

Рисунок 42 - Результати кластеризації 

рапсіаз - аналіз даних 

рапсіаз (Ьнр://рапс1акрусІаГа.ог«) - бібліотека, яка базується на 
МитРу і містить високопродуктивні та зручні у використанні 
структури даних та інструменти обробки і аналізу даних. За 
функціональністю рапсіаз подібна на табличний процесор Ехсеї. 
Основними структурами даних є Бегіез (одновимірний масив 
псіаїтау з мітками осі) та ОаіаРгате (таблиця з мітками осей (рядків 
і стовпців)). Приклад описує основні можливості рапсіаз 0.20.3. 

ітрогі питру аз пр 

ітрогі таірІоіІіЬ. руріоі аз ріі 

ітрогі: рапсіаз аз реї 

_= 1 \п■ 

XI = [0, 2, 2, 3, 9] 

х2 = [ 12 , 12 , ІМопе, 20, 31] 

сІаіаБеі = іір(х1,х2) # підготувати дані 

ді = реї.ОаіаРгате(сіаіа = сІа1:а5е1:^ со1итпз=[ ’ХІ' , 

'Х2' ]) # об'єкт йаваРгате 

зг = рсі.5егіез( [1, 3, пр. пап, 7,9]) # об'єкт Зегіез 
ргіпі сН 2 „_ # вивести таблицю 


183 






#ргіпі д^.ііеадО # вивести початок таблиці 

#с//. іо_сзу( 'годБіаіз. сзи ' г іпдех=Раіве> ііеадег=Раізе) # 

зберегти у файл сзи 

#сУ/ = рд.геад_сзи('годЗіаіз. сзи ' } патез=[ 'XI' } 'Х2']) 

# прочитати з файлу сзу 

ргіпі сіі.сііурез.^ # типи даних колонок 
ргіпі вміст колонки (Зегіез) 

#д^[ 'XI' ] # або 

ргіпі: сі-р[ 'Х1‘ ] ,ипірие(),_ # унікальні значення 
колонки 

сі-р [0:2] # перші 2 рядка (ОаіаРгате) 

ргіпі: (1-Р.1ос[:/Х1'],_ # індексування (Бегіез містить 

тільки XI) 

#д^[['XI']] # або (йаіаРгате містить тільки XI) 
ргіпі (*[(*[' ХГ] == 0] д _ # умовне індексування 
(ОаіаРгате) 

# або: 

сі-РС (сИ=[ ’XI' ] == 0) & (сІ-Р[ ’Х2' ] > 0)] # / - ог, & - 

апд, ~ - поі 

сН=[ ’Х2' ] [сИ=[ ’ XI' ] == 0] # (Бегіез) 

ргіпі сі-р[ 'XI' ].уа1ие$,_ # конвертація в питру.пдаггау 
сІ-Р.сІгорпа() # відкинути рядки з відсутніми даними 
(Мопе) (див. також ^іііпа) 

сіі. 50гі_іпсІех(ахІ5=1) # сортувати за колонками (1) 
або рядками (в) 

сі-р. зогі_уа1иез( [ ’ХІ' ], азсепсІіп§=РаІ5е) # сортувати 

за XI (за спаданням) 

сі-р[ ’ ХЗ' ] = пр. зргі(сі-р[' XI' ]**2+сі-р[ ’Х2' ]**2) # додати 

нову колонку 

ргіпі сН 2 [ ’ХЗ' ] .тар(1агпЬсІа х: х+1)^_ # застосувати 
функцію для кожного елемента 5 егіез (див. також арріу 
і арріутар для ОаіаРгате) 

ргіпі сіі . §гоирЬу(сІ-Р[ ’ХІ' ]) .теап () # групувати за XI 


184 




і знайти середнє в групах 
ргіпі сІ-р.рІУ0І:(іпсІех= , Х1 со1итпз= ’Х2 ' , 
уа1ие5='ХЗ' ),_ # звідна таблиця, де XI - рядки, Х2 ■ 
колонки, ХЗ - значення (див. також рд.ріиої_їабіе) 
ргіпі: с)-р.5іаск(),_ # ієрархічне представлення даних 
(див. також ипзіаск, Миііііпдех - ієрархічний індекс) 
ргіпі реї. сго55іаЬ(сН : [ ’ХІ' ], сІ-р['Х2 ']),_ # таблиця 
частот факторів XI,Х2 

ргіпі сІі.сІезсгіЬеО ,_ # статистика для кожної колонки 
(див. також теап, від, ...) 

ргіпі сі-Р.соу(),_ # коваріація (математичне сподівання 
добутків відхилень випадкових величин) 
ргіпі сІ-Р.согг() # кореляція (коеф. корел. Пірсона = 
соуХУ/ (5х*5у)) 

#с//. ріої(кіпд= 'Ьаг *) # візуалізація 
#с//.ріоі(х= 'XI ', у='Х2') 

Ярії.збом() 


XI Х2 
0 0 12.0 

1 2 12.0 

2 2 

В 3 20.0 

4 9 31.0 

XI ІПІ64 

Х2 і1оаіб4 
сііуре: оЬ]есі 

0 0 

1 2 

2 2 

З З 


185 





4 9 

Мате: XI, сіііуре: Іп1:б4 

[ 0239 ] 

0 0 

1 2 

2 2 

3 З 

4 9 

Мате: XI, сіііуре: іп1:64 

XI Х2 
0 0 12.0 

[ 02239 ] 

0 13.000000 

1 13.165525 

2 МаМ 

3 21.223748 

4 33.280025 

Мате: ХЗ, сіііуре: -Р1оа1:64 

XI Х2 ХЗ 

XI 

0 0 12.0 12.000000 

2 2 12.0 12.165525 

3 3 20.0 20.223748 

9 9 31.0 32.280025 


Х2 

МаМ 

12.0 

20.0 

31.0 

XI 

0 

МаМ 

12.000000 

МаМ 

МаМ 

2 

МаМ 

12.165525 

МаМ 

МаМ 


186 



в 

9 




^ 20.223748 №М 

32.280025 


0 

XI 

0.000000 


Х2 

12.000000 


ХЗ 

12.000000 

1 

XI 

2.000000 


Х2 

12.000000 


ХЗ 

12.165525 

2 

XI 

2.000000 

3 

XI 

3.000000 


Х2 

20.000000 


ХЗ 

20.223748 

4 

XI 

9.000000 


Х2 

31.000000 


ХЗ 

32.280025 

сіііуре: -Р1оа1:64 

Х2 

12.0 

20.0 31 

XI 



0 

1 

0 

2 

1 

0 

3 

0 

1 

9 

0 

0 



XI 

Х2 

ХЗ 

соипі: 

5.000000 

4.000000 

4.000000 

теап 

3.200000 

18.750000 

19.167325 

5ІІСІ 

3.420526 

8.995369 

9.547333 

тіп 

0.000000 

12.000000 

12.000000 

25% 

2.000000 

12.000000 

12.124144 

50% 

2.000000 

16.000000 

16.194637 

75% 

3.000000 

22.750000 

23.237818 

тах 

9.000000 

31.000000 

32.280025 


187 




XI 

Х2 

ХЗ 

XI 

11.700000 

33.500000 

35.726658 

Х2 

33.500000 

80.916667 

85.864232 

ХЗ 

35.726658 

85.864232 

91.151559 


XI 

Х2 

ХЗ 

XI 

1.000000 

0.961568 

0.966195 

Х2 

0.961568 

1.000000 

0.999796 

ХЗ 

0.966195 

0.999796 

1.000000 


ксікк-іеагп - машинне навчання 

Бібліотека 8сікіі-1еагп (ЬЦр://8сікіІ-1еат.ог§) містить зручні для 
використання алгоритми машинного навчання з учителем (регресія, 
класифікація) і без учителя (кластеризація, зменшення розмірності), 
а також засоби для підготовки даних і вибору найкращої моделі 
даних [43]. В прикладі за допомогою 8сікіі-1еат 0.19.1 розв’язується 
задача бінарної класифікації. Необхідно навчити класифікатор 
КапсІотРогезІїСІаззі-Ріег розпізнавати класи у нових даних хі, 
х2. Для цього модель навчається на даних для навчання. Тестові 
дані використовуються для перевірки правильності роботи моделі 
на нових даних. Як видно, ця модель правильно визначає класи 
100% тестових даних. 

Але така однократна процедура не є надійною. Для надійної 
перевірки правильності в прикладі застосовується 3-х блокова 
перехресна перевірка моделі. Вона виконується шляхом поділу усіх 
даних на 3 частини ( хуі, ху2, хуЗ). Далі для кожної частини функція 
сгозз_уа1_зсоге виконує навчання моделі і розрахунок 
правильності на незадіяних для навчання частинах. Тепер середнє 
значення правильності - 85 %. 

Окремою проблемою є визначення оптимальних значень 

параметрів моделі п_ез1:іта1:ог5 і тах_сіері:Ь. Якщо кількість їх 

варіантів не велика, то можна виконати цю програму для різних 
значень і подивитись, у якому випадку правильність найвища. 


188 



ітрогі питру аз пр 

ітрогі таірІоіІіЬ. руріоі аз ріі 

■Ргот зкіеагп. тосІе1_5е1есііоп ітрогі: ігаіп_іезі_зр1іі 
■Ргот зкіеагп.епзетЬІе ітрогі КапсІотРогезіСІаззі-Ріег 

х=пр.аггау( [[0,1,1,2,2,3,2,3,1,3, 
6,5,6,7,7,8,7,7,8,5], 

[1,1,3,1,2,2,3,4,4,8, 

5.7.6.7.6.7.5.8.8.1] ]) # дві ознаки класів 
у=пр.аггау( [0,0,0,0,0,0,0,0,0,0, 

1.1.1.1. 1. 1.1.1.1. 1] ) # мітки класів (бінарна 
класифікація) 

х=х.Т 

ріі. зсаііег(х[: ,0 ], х[:,1], с=у , з=100) # 

візуалізація класів 

ріі.х1аЬе1( 'х0' ); ріі.у1аЬе1( 'хі' ); ріі. зРю\л/() 
ргіпі "Рисунок - Два класи даних" 

# розбити дані (дані для навчання і тестові дані для 
перевірки) 

х_ігаігі; х_1:е5І:у_ігаіП; у_іезі = 
ігаіп_іезі_зр1іі(Х;У, іезі_зІ2е=0.5) 

тосІе1=КапсІотРоге5іС1а5 5І-Ріег(п_е5іітаіог5=5; 
тах_сіеріРі=3) # модель - випадковий ліс (п_езіітаіог5 
- кількість дерев^ тах_деріЬ - глибина дерева) 

тос!е1.-Ріі(х_ігаіП; у_ігаіп) # виконати навчання 
ргіпі у_іезі # фактичні тестові класи 

ргіпі тосІе1.ргесІісі(х_іе5і) # прогнозовані тестові 
класи 

ргіпі тосіеі.зсоге(х_іезі; у_іезі) # правильність 

класифікатора 

# перехресна перевірка (удосконалення 
ігаіп_±ез±_5ріі± + зсоге) 

■Ргот зкіеагп. тос1е1_5е1есііоп ітрогі сгозз_уа1_зсоге 


189 





5 = СГ055_Уа1_5С0ГЄ(іТЮСІЄІ, X, у, СУ = 3 ) 

рг і пі: з, з.теап() # правильність класифікатора на 
кожній ітерації і її середнє значення 



012345678 

Х0 

Рисунок 43 - Два класи даних 


[1 00010001 1 ] 

[1 00010001 1 ] 

1.0 

[ 0.875 1. 0.66666667] 0.847222222222 

ІЧеІУУОгкХ - графи 

КеІууогкХ (Ннр://псП\'огкх.«ІЙіиЬ.іо) - це пакет для створення, 
маніпуляції і вивчення структури, динаміки і функціонування 
комплексних графів. Граф - це абстрактний математичний об’єкт, 
який являє собою множину вершин і ребер, які з’єднують пари 
вершин. В прикладі показані основи створення і використання 
неорієнтованих графів за допомогою №і\УОгкХ 2.0. 

ітрогі: пеіил/опкх аз пх 

ітрогі: таірІоіІіЬ.руріоі аз ріі 


190 









С=пх .Старії () # створити неорієнтований граф 

(5. асІсІ_посІе (1) # додати вузол 

С.асІсІ_посІе( ’А' ) # додати вузол (вузлом може бути 
будь-який об'єкт) 

<3.асІсІ_посіЄ5_-( : гот( [2, 3,4 ]) # додати вузли 
С.асІсІ_есІ§е(1,2) # додати ребро 
С.асІсІ_есІ§Є5_ігот([(2;3),(3,4),(4,2),(2, 'А' )]) # 

додати ребра 

ргіпі С.питЬег_о-Р_посІе5(), С.питЬег_о-Р_есІ§е5() # 

кількість вузлів і ребер 

ргіпі: ' посіез', С.посіез # вузли 

ргіпі: ' есІ§ез’, С.есІ§е5 # ребра 

ргіпі 'асі] , Є.асі□ # сусіди вершин 

ргіпі 'сІе§гее', С.сІе§гее # степені вершин (кількість 

ребер вершин) 

ргіпі С.єсІ§Є5( [ ' А' , 2, 3]) # усі ребра вершин ' А' ,2,3 
ргіпі С[2] # сусіди вершини 2, або С.адд[2] 
ргіпі С.сІе§гее( [ ' А' , 2, 3]) # степені вершин 'А' ,2,3 

С. посІе[ ' А' ] [ ' а ' ] = "уа11" # змінити значення атрибута 
'а' вузла 'А' 

ргіпі С.посІЄ5[ 1 А' ] # словник атрибутів вузла 

6[1][2][ "со1ог"]="Ь1ие" # змінити значення атрибута 
’соіог’ ребра 1,2 

# або С.едде5[1,2]["соіог"]="Ьіие" 

С[1] [2] [ ’іл/еі§Иі ' ] = 4 # спеціальний атрибут зважених 
графів 

ргіпі С[1][2] # словник атрибутів ребра 1,2 

# ітерація по кортежам (поде, пеідЬЬогз), де 
пеідЬЬогз - словник: 

■Рог посієм пеі§НЬогз іп 6.асі] .ііетз(): 


191 




ргіпі "Сусіди вузла " , посіє 

-Рог пеі§НЬог, есі§е_а1:1:г іп пеі§НЬог5.і1:ет5(): # 

для кожного сусіда 

ргіпі ; пеі§НЬоГ; есІ§е_аі1:г # сусід, 

властивості ребра 

#пх.дгаілі(С, іл/ііІі_іаЬеІ5 = Тгие) # рисувати граф за 
допомогою таіріоіііЬ 

пх.сІга\л/_сігси1аг(С; \л/і1:Іп_1аЬе1з = Тгие) # інші 

способи візуалізації графа 

#пх. дгам_зресігаі(С, мііТі_іаЬеІ5 = Тгие) 

ріі. 5Ііоіл/(); ргіпі "Рисунок - Візуалізація графа" 

#якщо СгарТіиіі і РуСгарТіиіг (пх_адгарТі) або рудоі 
(пх_рудоі) установлені, то можна рисувати, зберігати 
і читати граф у форматі доі. Підтримуються також інші 
формати. 

#пх.дгам(С, роз=пх.пх_адгарЬ.дгарЬиіг_іауоиі(С)) # 
рисувати 

#пх.дгаміпд.пх_адгарб.мгі±е_до±(С, "тувгарТі. доі") # 
зберегти 

#С=пх. дгаміпд. пх_адгаріі. геад_доі( "туСгарії. доі") # 
прочитати 


5 5 

посіез ['А', 1, 2, 3, 4] 

е9§ез [('А', 2), (1, 2), (2, 3), (2, 4), (3, 4)] 
асі] {'А 1 : {2: {}}, 1: {2: {}}, 2: {'А': {}, 1: {}, 3: 
{}, 4: {}}, 3: {2: {}, 4: {}}, 4: {2: {}, 3: {}}} 
с!є§гее [('А', 1), (1, 1), (2, 4), {3, 2), (4, 2)] 
[('А', 2), {2, 1), {2, 3), {2, 4), (3, 4)] 

{'А': {Ь 1: {Ь 3: {}, 4: {}} 

[('А', 1), (2, 4 ), (3, 2)] 

{'а': 'уаіі'} 

{'соїог': ' Ьіие', '\л/еі§ІгІ:' : 4} 


192 





Сусіди вузла А 

2 {} 

Сусіди вузла 1 

2 {'соїог': ’ЬІие', ’\л/еі§ІтІ:' : 4} 
Сусіди вузла 2 

А {} 

1 {'соїог': ' Ьіие ', '\л/еі§Іі1:' : 4} 

3 {} 

4 {} 

Сусіди вузла З 

2 {} 

4 {} 

Сусіди вузла 4 
2 {} 

З {} 



Рисунок 44 - Візуалізація графа 


193 



№ілгогкХ - орієнтовані графи, алгоритми на графах 

Ребра графа, які мають напрямок, називають дугами. 
Неорієнтований граф містить тільки ребра, а орієнтований граф 
містить тільки дуги. В КеІ^огкХ орієнтовані графи створюються за 
допомогою класу ОіСгарЬ. В прикладі показані операції з 
орієнтованими графами і розповсюджені алгоритми на графах 
(Ьир://пе1^огкх.§ііЬііЬ.іо/боситепІаЦоп/8ІаЬ1е/геїегепсе/а1§огііЬт8/іпб 
ех.ЬітІ). 

ітрогі: пеіил/огкх аз пх 

ітрогі такрІоіНЬ. руріок аз рік 

С=пх.йіСгаріі() # створити орієнтований граф 

0.абб_меі§НкесІ_ес1§Є5_-Ргот( [(1,2,0. 5), (1,3,0. 5), 

(3,4,0.25)]) # додати ребра з вагами 

ргіпк ' зис , 1із1:(С. зиссе550гз(1) ) # вузли-нащадки 
ргіпк 'рге', 1із1:(Є. ргесІесе550Г5(1) ) # вузли-предки 
ргіпк ’пеі , 1із1:(С.пеі§ИЬоп5(1)) # вузли-сусіди 
ргіпк ’оик , С.оик_есІ§Є5(1) # вихідні ребра 
ргіпк 'іп', С.іп_есі§е5(1) # вхідні ребра 

ргіпк С.сІе§гее(1) # кількість ребер цього вузла. Але: 

ргіпк С.сІе§гее(1, и/еі§1і1:= 'іл/еі§Ьі:' ) # сума ваг ребер 

цього вузла 

ргіпк С.оик_сІе§пее(1, (л/еі§іг1:= 'іл/еі§Ітк' ) # сума ваг 
вихідних ребер цього вузла 
С2=С. геуегзе( ) # обернений граф 
С2=С. зиЬ§гарЬ( [1, 3,4] ) # підграф 
# див. також функції ипіоп , діз^оіпі_ипіоп } 
сагїе5Іап_ргодисі } сотрозе , сотріетепі 
ргіпк С. Ьаз_есІ§е(1, 2) # чи граф має ребро 1,2 
ргіпк Є. Наз_посІе(1) # чи граф має вузол 1 
ргіпк С. Ьаз_ргесІесе550г (2, 1) # чи вузол 2 має предка 
1 

ргіпк С.Ьаз_зиссе550г(1, 2) # чи вузол 1 має нащадка 2 

194 





рг і пі: 1ізі(0. посІЄ5_\л/ііІі_5ЄІ-Р1оор5()) # вузли з 

ребрами, які виходять і входять в цей вузол 

ргіпі 1ізі(0. зе1і1оор_есІ§е5()) # ребра з однаковим 

вузлом на двох кінцях 

пх.сІга\л/_зресіга1(С; и/ііЬ_1аЬе1з=Тгие) # нарисувати 

граф 

ріі.зНо\л/(); ргіпі: "Рисунок - Візуаяізація 
орієнтованого графа" 

# Алгоритми на графах: 

ргіпі пх.із_ігее(С) # чи це дерево? 
ігу: ргіпі пх.ііпсІ_сус1е(С) # чи є цикли? 
ехсері: ргіпі "N 0 сусіе іоипсі" 

ргіпі Іізі(пх. сН"5_ес)§е5 (С л 1 )) # ітерація по ребрам 

для пошуку в глибину 

ргіпі 1ізі(пх. Ьіз_есІ§Є5 (С,1)) # для пошуку в ширину 

(починати зі) 

ргіпі с)ісі(пх.а11_раіг5_5Иогіе5і_раіЬ(С)) # 

найкоротший шлях між усіма вузлами 

ргіпі пх. зЬогіезі_раі1і(Є, 1,4) # найкоротший шлях від 

1 до 4 

ргіпі пх.сІізкзіга-раіЬ^І^) # або 

ргіпі 'Ра§еКапк , пх.ра§егапк(Є; а1рЬа=0.9) # 

алгоритм ранжування РадеКапк 

ргіпі 'НІТ5', пх.Иііз(С) # алгоритм ранжування НІТ5 
повертає вузли, які посилаються на авторитетні вузли 
і ці авторитетні вузли 


зис [2, 3] 
рге [] 
пеі [2, 3] 

оиі [(1, 2), (1, 3)] 
іп [] 

2 


195 





1.0 

1.0 

Тгие 

Тгие 

Тгие 

Тгие 

[] 

[] 



Рисунок 45 - Візуалізація орієнтованого графа 

Тгие 

N 0 сусіе ТоипсІ 

[(1, 2), (1, 3), (3, 4)] 

[(1, 2), (1, 3), (3, 4)] 

{1: {1: [1], 2: [1, 2], 3: [1, 3], 4: [1, 3, 4]}, 2: 
{2: [2]}, 3: {3: [3], 4: [3, 4]}, 4: {4: [4]}} 

[1, 3, 4] 

[1, 3, 4] 

Ра§еКапІ< {1: 0.16116025883844023, 2: 0.23368249652134 
615, 3: 0.23368249652134615, 4: 0.3714747481188674} 

196 


НІТ5 ({1: 0.9999999990686774, 2: 0.0, 3: 9.3132257374 
81168Є-10, 4: 0.0}, {1: 0.0, 2: 0.4999999990686774, З 
: 0.4999999990686774, 4: 1.8626451457615ІЄ-09}) 

руОаІакщ - логічне програмування в РуІЇїоп 

Логічне програмування основане на виведенні нових фактів з 
існуючих відповідно правил логічного виведення. руБаІа1о§ 0.17.1 
(ЬіІр://8ІІе8.§оо§1е.сот/8ІІе/русіаІа1о§) - пакет, який додає парадигму 
логічного програмуавання в РуїЬоп. БаІа1о§ - повністю 
декларативна підмножина мови логічного програмування Рго1о§. В 
декларативному програмуванні програма описує що потрібно 
досягти, а в імперативному - як. Програма мовою Оаіаіо» містить 
факти, правила логічного виведення і запити. Наприклад, фактом є 
твердження “Іван є батьком Петра”, правило логічного виведення - 
“якщо У батько X, то X дитина У”, а запит - “знайти усіх дітей 
Петра”. 

Ргот _Риіиге_ ітрогі: ипісос1е_1і1:егаІ5 

Ргот ру0аРа1о§ ітрогі: ру0аРаіо§ 

ру0аРа1о§.сгеаРе_Регт5("ізРагепР, ізСбіІсІ, і$5іЬ1іп§, 
X, У, 2, с") # Оаїаіод-терми (змінні з великої букви) 
+І5РагепР("Іуап", "РеРго") # додати факт (ізРагепї 
предикат) 

+І5Рагеп1:("Іуап", "Бііерап") # предикати можуть бути 
кирилицею: діоЬаіз()['назва'] 

# правила логічного виведення ("<=" - "якщо, то"): 
ізСЬі1с!(Х,У) <= І5Рагеп1:(У,Х) # якщо У батько X, то X 
дитина У 

із5іЬ1іп§(Х,У) <= ізРагеп1:(2,Х) & І5Рагеп1:(2,У) & 
~(Х==У) 

# запити: 

ргіпі: І5Сбі1сІ("Ре1:го", Х).сІа1:а # знайти батька Петра 
ргіпі: ізСЬіїсІ(X, "Іуап 1 ).сіаііа # знайти усіх дітей 
Івана 

ргіпі: із5іЬ1іп§(Х,У) .сіаіа # знайти усіх братів 


197 





(с[Х]==1еп_(У)) <= (ізРагепі(Х;У)) 

ргіпі (с [Х]==У) .сіаіа # знайти кількість дітей батька 
X 

руйаіа1о§.с1еаг() # очистити базу даних 

ру0аіа1о§.сгеаіе_іегт5( аЬз., і, §") # аЬв - вбудована 

функція 

ргіпі: ( (Х==[1, 2 , -В]) & (У==аЬ5(Х[2])+1)) .сіаіа # 

знайти X, У 

ргіпі (X.іп_(гап§е(5)) & У.іп_(гап§е(5)) & (2==Х+У) & 
(2<2)).сіаіа # знайти Х,У 
Р["Іуап"]=2 # факт (/ - предикат) 

-р["Реіго"]=0 

#+(^[ 'Реіго '] == в) # або 

ргіпі ((і 2 [X] ==У) & (У>0)).сіаіа # знайти Х,У 

сієї Р["Іуап"] # видалити 

(§[Х]==3) <= (Х=="Іуап' ) 

ргіпі ((§[Х]==У)).сіаіа # знайти Х,У 


[(и'Іуап 1 ,)] 

[(и'Реіго ',), (и'Зіерап',)] 

[(и'Реіго'^ и'Біерап')^ (и'Зіерап 1 , и'Реіго')] 
[(и'Іуап 1 , 2)] 

[((1, 2, -3), 4)] 

[( 0 , 1 , 1 ), ( 1 , 0 , 1 ), ( 0 , 0 , 0 )] 

[(и'Іуап ', 2)] 

[(и'Іуап ', 3)] 

Зв’язок з інтерпретатором Рго1о§ 

В прикладі показано спосіб взаємодії РуїЬоп програми з 
інтерпретатором Рго1о§ (3\УІ-РгоІо§) за допомогою 
зиЬргосезБ. Рореп. Більш тісний зв’язок з 8\¥І-Рго1о§ реалізує 
пакет Ру5\\їр (Ьйр://§ііЬиЬ.сот/уисе/ру8\уір). 


198 





■Ргот зиЬргосезз ітрогі: Рореп, РІРЕ, 5ТО01ІТ 

ілііі:И ореп( '-Ратіїу.рі' , ’іл/') аз Т: # створити Ргоіод- 

програму 

Т.игі1:е( ' ізРагепіЦ"Іуап", "Реііго"). ізСЬі1сІ(Х,У) 

: - ізРагеп1:(У,Х). ) 
р = Рореп(г' "с:\Рго§гат Рііез 

(х86)\зіл/ір1\Ьіп\зіл/ір1.ехе" -я Татіїу.рі', зІіе11=Тгие, 
5І:сІіп=РІРЕ^ з1:сІои1:=РІРЕ, з1:сІегг=5Т001Л) 
ргіпі р. соттипіса1:е( ' ізСЬі1сІ(Х, "Іуап"). ' ) # надіслати 
запит і отримати результат 


('\г\пХ = "Реіго".\г\п\г\п\г\п', ІМопе) 

капгеп - логічне програмування в РуІЬоп 

капгеп 0.2.3 (ЬЦр8://£І(ЬиЬ.сот/10£ру/1о§ру) - це реалізація 
вбудованої предметно-орієнтованої мови логічного програмування 
тіпіКапгеп (Ьі1р://тіпікапгеп.ог§). тіпіКапгеп спроектована для 
легкої модифікації і розширення для різних видів логічного 
програмування, капгеп використовує бібліотеку ипііісаііоп для 
уніфікації - розширеної форми зіставлення з взірцем. Типи, які 
можуть бути уніфіковані, можуть застосовуватись також для 
логічного програмування. Наступний код знаходить значення х: 

>>> -Ргот ипі-Рісакіоп ітрогі: * 

>>> х = уаг(’х') 

>>> ипі1=у((1,х,3), (1,2,3)) 

{~х: 2} 

Де (1,х,3), (1,2,3) - два терми (дерево, листки якого є 
константами або змінними), х - логічна змінна, {~х: 2} - 

підстановка, ипі-ру - функція, яка повертає підстановку за двома 
термами. 

Ціль - це функція з підстановки в потік підстановок: 

»> §оа1=ея((1,х,3), (1,2,3)) 

>>> -Рог з іп §оа!({}): 


199 



ргіпі з 


{~х: 2} 

Ціль створюється за допомогою конструктора цілі (ер, 
тетЬего, сопсіе та інших). Логічна програма виконується 
функцією гип(п, х, *§оаіз), де п - кількість розв’язків, х - 
змінна, *§оаІ5 - послідовність цілей. 

■Ргот каппеп ітрогі: * 

пе = §оа1з.поі_ериа1о # конструктор цілі "не рівні" 
#пе = доаіі^у( іатЬсІа х,у: х!=у) # або створити з 
функції 

#ітрогї орегаіог; пе = доаііф : у(орегаІог.пе) # або 
створити з оператора 

рагепі = КеІаііопО # відношення між термами 

-Расі: (ра ге пі:, "Іван", "Петро") # факт - Іван батько 
Петра 

■РасіЦрагепІ:, "Іван", "Василь") 

-Расі:(рагепі:, "Петро", "Марія ) 
х,у = уап(),уаг() # логічні змінні 
сІе-Р 5ІЬ1іпд(х, у): # відношення "рідні" (брат або 
сестра) 

2 = уап() 

# (і батько х) і (т. батько у) і (х,у не рівні) 

# сопде - конструктор цілі для логічного І та АБО 

геіигп сопсІе( (рагепі( 2 , х), рагепіЦг, у), 

(пе,(х,у),Тгие)) ) 

■Рог х,у іп гип(0, (х, у), зіЬ1іп§(х, у)): 
ргіпі х,у # вивести усі пари рідних 

х,у = уаг(),уаг() 

■Рог х іп гип(0, х, сопсІе( (рагепі(х, "Петро ),), 
(рагепі( 'Петро", х),) )): 

ргіпі х # вивести усіх батьків або дітей Петра 


200 



Петро Василь 
Василь Петро 
Іван 
Марія 


руїЬоп-сошігаіпі - задачі виконання обмежень 

руіїюп-сошігаіпі 1.3.1 (Ьйр://рурі.ог§/рго]ес(/руіЬоп-соп8ІгаіпІ) - 
модуль для розв’язування задач виконання обмежень, ціллю яких є 
знаходження значень змінних, які відповідають заданим 
обмеженням. Щоб сформулювати таку задачу потрібно визначити 
змінні, множину їх значень і обмеження. Модуль може бути 
використаний для програмування в обмеженнях, яке є видом 
декларативного програмування. В модулі доступні такі види 
обмежень: РипсііопСопзІїгаіітІ:, АІІОі-р-РегеггЬСопзїгаіпі:, 
АІІЕриаІСопзІігаіітІ:, ЕхасіБитСопзІїгаіпІ:, 

МахБитСопзІігаіпІ:, МіпБитСопзІїгаіпі:, ІпБеіСопзІтаіпі:, 
ІЧоіІпБеІїСопзІїгаіпІ:, БотеІпБеіСопзІїгаіпІ:, 

5 о т е N о 1:1 п 5 е 1: С о п 51: г а і п 1:. 


■Ргот соп зі па і пі ітрогі * 

ргоЬІет = РгоЬ1ет() # створити задачу 

ргоЬІет.асІсІУагіаЬІе( 'а ' , [1,2,3]) # додати змінну і 

множину її значень 

ргоЬІет.асІсІУагіаЬІе( ' Ь 1 , [1,2,4]) 

ргіпі ргоЬІет. §еі5о1и1:іоп5() # розв'язати задачу 

(обмежень немає) 

# додати обмеження (розкоментуйте потрібні): 

ргоЬІет.абсІСоп5І:гаіп1:(1атЬсІа а,Ь: а+Ь>3, ( а , ’Ь )) 

# а+Ь>3 

#ргобіет. аддСоп5їгаіпї(АІІОі) : ^егепїСоп5їгаіпї()) # а 
і Ь різні 

#ргоЬіет. аддСопз1:гаіпі(АІІЕриаІСоп5ігаіпі()) # а і Ь 
однакові 

#ргоЬіет. аддСоп5±гаіпі(Іп5еіСоп5±гаіп1:([2 і З])) # а і 
Ь в множині {2 ,3| 


201 





ргіпі: ргоЬ1ет.§е1:5о1и1:іоп5() # розв'язати задачу - 
знайти значення а і Ь, які відповідають обмеженням 


[{'а': З, •Ь 1 : 4}, {'а': З, 'Ь 1 : 2}, {'а': З, 'Ь 1 : 1} 
, {'а': 2., 'Ь': 4}, {'а': 2, 'Ь': 2}, {'а': 2, 'Ь': 1 
Ь {'а 1 : 1, 'Ь': 4}, {'а': 1, 'Ь': 2}, {'а': 1, 'Ь': 
1 }] 

[{'а': З, •Ь 1 : 4}, {'а': З, 1 Ь 1 : 2}, {'а': З, 'Ь 1 : 1} 
, {'а': 2, 'Ь': 4}, {'а': 2, 'Ь': 2}, {'а': 1, 'в': 4 
}] 


РІЬ (РіПоуу ) - робота з растровою графікою 

Рі11о\¥ 4.2.1 (РуїЬоп Іта§іп§ ЬіЬгагу) - це бібліотека для роботи 
з растровою графікою (Ніір ://рі 11о\\. геасІїЬескіс^. іо). Підтримує 
велику кількість форматів, їх конвертацію, різні операції з 
зображенням. 

Ргот РИ ітрогі: Іта§е, Іта§еОга\л/, Іта§еРоп1:, 
Іта§еРі11:еп 

іта§е = Іта§е.пе\л/( КСВА', (50, 40), (0, 0, 0, 0)) # 

зображення з заданою колірною моделлю } розміром і 
фоном 

сігаїл/ = Іта§еОгаіл/.Ргаіл/(іта§е) # простий інтерфейс для 
20 рисування 
-Рпі: = 

Іта§еРоп1: .1:гие1:уре(г ' с: \ІлІіпсІоіл/5\Роп1:5\1:іте5 .ИіР' , 28) 
# шрифт 

сіга\л/.Ііехі:(( Б ^ 5); "РИ", -Роп1:=-Рп1:^ 

Рі11=(0,255,0,255)) # рисувати текст в заданих 
координатах 

іта§е2=іта§е. по1:а1:е(20) # повернути на 20 градусів 
Іта§е2=іта§е2.Рі11:ег(Іта§еРі11:ег.5М00ТН) # згладити 
зображення 

іта§е=Іта§е.а1рЬа_сотро5І1:е(іта§е,ігпа§е2) # об'єднати 
іта§е = іта§е.сгор( [1, 1, 49, 39]) # обрізати 


202 








іта§е. сопуєгЬ( ' КОВ ' ) # конвертувати в модель НСВ 

#ітаде . ваие("ріі . рпд") # зберегти 

іта§е. 5Ііоіл/( ) # показати у зовнішній програмі 



Рисунок 46 - Растровий рисунок 

РуОрепОЬ - прив’язка до ОрепСЬ 

ОрепСЬ - це незалежний від мови програмування і платформи 
АРІ для рендерингу 20 і ЗО векторної графіки. Найчасті ш е 
використовується з графічним процесором в програмах для 
візуалізації, САПР, іграх. РуОрепОЬ 3.1.0 

(Ьир://руореп§1.8оигсе1ог§е.пеІ) - це прив’язка РуіЬоп до ОрепСЬ 
VI. 1-4.4, яка створена за допомогою сіурез. Підтримує багато ОЬП- 
бібліотек та пов’язаних з ОрепСЬ бібліотек (ОЬЕ8, ОЬЬІ, ЕОЬ, 
\УОЬ, ОЬХ, РгееСЬЬТ, ОЬЕ). РгееСЬЬТ 

(ЬЦр://1гее§1и1.8оигсеґог§е.пеІ) - це бібліотека, яка призначена для 
таких системних задач, як створення вікон, ініціалізація контексту 
ОрепСЬ і обробка подій. Для роботи програми знадобиться ігее§1иі 
3.0.0 М8УС Раскаос 

(Ннр://\\'\\'\\'.П'ап8іпІ88Іоп7,сго.со.ик/80ії\\'аге/іїес§1иІ-с1с\'с]). Для 

вивчення РуОрепОЬ може бути використана офіційна документація 
(Ьі1р://\у\¥\у.ореп§1.ог§/8СІк/(1ос8/тап2) та 

(Ьйр://&ее§1иЬ8оигсеґог§е.пеі/с1ос8/арі.рЬр). Існує також інша 
прив’язка до ОрепСЬ, яка є частиною ру§1еЬ 

-Ргот ОрепСЬ.СШТ ітрогЬ * 

Ьгот ОрепСЬ.СЬ ІтрогЬ * 

-Ргот ОрепСЬ.ОЬЬ) ІтрогЬ * 

Т=[0,0,0] # вектор переміщень 
К=[0,0,1,0] # вектор повороту 

сіе-р сіізріау( ): # функція відображення Орепбі ■ 

рисує об'єкти 


203 









§1С1еаг(ЄІ__С0І_0К_ВІІРРЕК_ВІТ | 

СЬ_ОЕРТН_ВІІР РЕК_ВІТ) # очистити буфери кольору і 

глибини 

§1Со1огЗ-Р(0, 0, 0) # установити колір РСВ 
(чорний) 

§1Ма1:гіхМосІе(СІ-_МСЮЕІ-\/ІЕІл1) # режим матриці 

вигляду 

§1 ЬоасЛсІеггЬіІіу () # одинична матриця 
§1Тпап5Іа1:е-р(Т[0], Т[1], Т[2]) # множить поточну 
матрицю на матрицю переміщення 

§1Ко1:а1:е-р(К[0], К[1], К[ 2 ]_, К[3]) # множить 
поточну матрицю на матрицю повороту навколо вектора 

# створює кольорові трикутники 
§ІВе§іп(СІ-_ТКІАІ\І0І-Е_5ТКІР) # розмежовує вершини 
примітива (дозволено С^_Р0INТ5^ Сі_ІШЕ5> 
СІ_ІШЕ_5ТНІР ) СІ_ІШЕ_ІООР } 6І_ТНІАМ6ІЕ5, 
ві_ТРІАМ6ІЕ_5ТРІР } СІ_ТНІАМ6ІЕ_ЕАМ } СІ_(2І)А05, 
Є/._<21МО_577?ІР, а_Р0ІУ60И) 

§1\/ег1:ехЗ-р(0.5, 0.5, 0.5) # перша вершина 
трикутника 

§1Со1огЗ-Р(0.9, 0.9, 0.9) # колір наступних вершин 
§1\/ег1:ехЗ-Р(-0.5, -0. 5, 0) # друга вершина 
§1Со1огЗ-Р(0.1, 0.1, 0.1) # колір наступних вершин 
§1\/ег1:ехЗ-р(0.5, -0.5, 0) # третя вершина 
§1\/ег1:ехЗ-р(0.5, 0.5, -0.5) # вершина другого 
трикутника 

§ІЕпсІ() # завершити список вершин примітива 

£ІРоіп1:5І2е(3) # розмір точки 
§1Ве§іп(СІ._Р0ІМТ5) # точка 
§1\/ег1:ехЗ-р (0,0,0) 

§1ЕпсІ () 

§1Ве§іп(СІ-_І-]Ж5) # рисуємо 3 лінії - 


204 




координат X, У, 2 

р1=0,0,0 

# для кожного кольору і другої точки лінії 

-Рог с, р2 іп [[(1, 0, 0),(1, 0, 0)М(0, 1, 0),(0^ 

1, 0)],[(0, 0, 1Ь(0, 0, 1)]]: 

§1Со1огЗ-р(*с) 

§1\/ег1:ехЗ-р(*р1) 

§1\/ег1:ехЗ-р(*р2) 

§1ЕпсІ() # завершити рисування 

§1и1:1лІігеСиЬе(1) # нарисувати куб 

§Иіпе1лІісІ1:Ь(2) # ширина ліній 

§ІРи5НМа1:гіх() # запам'ятати глобальну систему 
координат 

§ІТгап5Іа1:е-Р(0, 0.5, 0) # перемістити систему 
координат вздовж У 

§1Ко1:а1:е-р(45, 0, 0, 1) # повернути в новій 
системі координат навколо осі 2 

# спробуйте поміняти дві попередні команди 
місцями 

§1и1:ІлІіпеСиЬе(0 . 5) # нарисувати куб 

§ІРорМа1:піх() # відновити глобальну систему 
координат 

§ІТгап5Іа1:е-Р(0, -0.5, 0) # перемістити систему 
координат вздовж У 

# спробуйте закоментувати попередні команди 
діРизШаїгіх і діРорМаїгіх 

§1и1:ІлІігеСиЬе(0. 25) # нарисувати куб 

#діР іизЬ() # виконати 6і команди 

§1и1:5іл/арВи-р-Рег5 () ереключити буфери в режимі 
подвійної буферизації 


205 




сіе-р 5ресіа1КеуРге55ес1(кеу; х, у): # переміщує або 
повертає, якщо натиснуті спеціальні клавіші 

£ІоЬа1 Т,Р 

І-Р кеу == ЄШТ_КЕУ_І_ЕРТ: Т[0] -= 0.1 
еіі-р кеу == ЄШТ_КЕУ_КІСНТ: Т[0] += 0.1 
еіі-р кеу == ЄШТ_КЕУ_001лІМ: Т[ 1] -= 0.1 
еіі-р кеу == ЄШТ_КЕУ_ІІР: Т[1] += 0.1 
еіі-р кеу == СШТ_КЕУ_РАСЕ_ООШ: К[0] += 5 
еіі-р кеу == СШТ_КЕУ_РАСЕ_ІІР: К[0] += -5 
§1и1:Ро5І:КесІІ5р1ау() 

бІиїІпііО # функція ініціалізації діиі: 

£Іи-£Іпі-ШІ5р1ауМосІе(СШТ_5ІІ\ІСІ-Е | СШТ_КСВ) # режим 

відображення 

§1и1:Іпі1:ІлІіпсІо\л/5І2е(250, 250) # розмір вікна 
§1и1:Іпі1:\лІіпсІо\л/РоБІ1:іоп( 100 ^ 100) # позиція вікна 
§1и1:Спеа1:еІлІіпсІоіл/( "Му РуОрепСІ. Рето") # створити вікно 
§1и1:5ресіа1Рипс (зресіаІКеуРгеззесІ) 

§1С1еагСо1ог(255, 255, 255, 0) # визначає НСВА колір, 
який буде використовувати діСіеаг 
§15ЬасІеМосІе1(СІ-_5М00ТРІ) # модель затінення 6і_ЕЕАТ 
або Сї 5М00ТН 


# параметри матеріалів і освітлення (розкоментуйте 
щоб завіяти) 

і і і 

діМаїегіаі^(а_Р^Т, бі_А№ІЕМТ, [0.2, 0.2, 0.2, 

1 . 0 ]) 

діМаїегіаі^(а_Р^Т, а_0іті5Е, [0.8, 0.8, 0.8, 
1 . 0 ]) 

діМаїегіаі^(а_Р80МТ, СІ_5РЕС11ІАВ, [1.0, 0.0, 1.0, 

1 . 0 ]) 

діМаїегіаі^(а_Е^Т, ві_5НШШЕ55, 50.0) 
дПідбір(СІ_ІІ6НТ0, С^_АМВIЕNТ, [0.0, 1.0, 0.0, 
1 . 0 ]) 


206 




дІіідЬі^и (С\-_ІІСНТ0, а_0ІЕЕІІ5Е, [1.0, 1.0, 1.0, 

1 . 0 ]) 

диідЬ1^(СІ_ИСНТ0, 6І_5РЕСІ)ІАК, [1.0, 1.0, 1.0, 

1 . 0 ]) 

дііідЬі:] : \/(6і_ІІ6НТ0, 6/__Р05І7Т0Л/, [1.0, 1.0, 1.0, 
0 . 0 ]); 

д^^ідЬіМоде^^ : \;(6^_^I^НТ_МО^Е^_АМВIЕNТ, [0.2, 0.2, 
0.2, 1.0]) 

діЕпаЬіе(СІ_і І6НТШС ) 
діЕпаЬіе(Сі_іІ6НТ0) 
дШеріїїЕипс (Сі_ІЕ55 ) 

ііі 

§ІЕпаЬ1е(СІ._0ЕРТН_ТЕ5Т) # активізувати перевірку 
глибини (не показувати невидимі поверхні) 

§1и1:0І5р1ауРипс(сіізріау) # вказати функцію 
відображення 

§1и1:МаіпІ-Оор() # головний цикл програми 


13 Му РуОрепСІ. Рето 


П х| 



Рисунок 47 - Вікно програми 


207 



















ру§1еі - кросплатформна віконна і мультимедійна бібліотека 

ру§1е! 1.3.2 (Ьі(р://ЬііЬиске1.ог§/ру§1еІ/ру§1еІ) - це віконна і 
мультимедійна бібліотека, яка призначена для розробки ігор та 
інших візуально багатих програм. Підтримує обробку вікон, 
обробку подій СІЛ, графіку ОрепСЬ, завантаження зображень і 
відео, а також відтворення звуків и музики. Працює на \Уіпс1о\¥8, 08 
X і Ьіпих. В прикладі показано простий переглядач ЗО об’єктів 
ОрепСЬ на основі ру§1е(. 

ітрогі ру§1еі 

-Ргот ру§1еі .и/іпсіои/ ітрогі: Ілііпсіоїл/., тоизе 
-Ргот ру§1еі.§1 ітрогі: * 

сіазз МуїлІ і п сі ои/( Ілііпсіоїл/): # клас вікна 

сіе-р _ іпіі_(5ЄІ-Р, *аг§5^ **к\л/аг§з): 

зирег (Муїлііпсіои/., 5ЄІ-Р) ._ іпіі_ (*аг§з., 

** ки/а г§з) 

зеІі.х^зеІ-Е.у = 0,0 # кути повороту 
зеї-Е.ІаЬеІ = 

ру§1еі.іехі. І_аЬе1(х=20,у=20, со1ог=(0, 0, 0, 255)) # 

надпис 

§1С1еагСо1ог(1, 1, 1, 1) # визначає НОВА 
колір, який буде використовувати діСіеаг 

§1ЕпаЬ1е(СІ-_0ЕРТН_ТЕ5Т) # активізувати 
перевірку глибини (не показувати невидимі поверхні) 

Сіе-Р оп_ге5І2е(5е1-Р^ и/ісІіЬ, Ьеі§Іі1:): # під час 

зміни розміру вікна 

азресіКаііо = іл/ісНЬ/Неі^ІтІ: # відношення 

сторін 

§1Уіе\л/рог1:(0, 0, \л/ісІ1:Ь_, Ьеі§Ьі:) # 

установлення порту виведення 

§1МаігіхМосіе(ОіІ-_РКО:)ЕСТІОІ\І) # режим матриці 

проекцій 

§ИоасІІсіеп1:і1:у() # одинична матриця 

208 





£ІиРегзрес1:ІУе(35.0, азресІКаІііо, 1.0, 

1000.0) # матриця перспективної проекції 

§1Ма1гіхМос)е(СіІ-_МСЮЕІ-\/ІЕІлІ) # режим матриці 

вигляду 

§ИоасІІсІеп'1:і1:у() 

сІе-Р оп_сІгаіл/( зеї-р) : # під час необхідності 
перерисування 

§1С1еаг(СІ__С0І_0К_ВІІРРЕК_ВІТ | 6І__0ЕРТН_ВІІРРЕК_ВІТ) # 

очистити буфери кольору і глибини 

§1Ма1гіхМос)е(СіІ-_МСЮЕІ-\/ІЕІлІ) # режим матриці 

вигляду 

§1Ри5ИМа1:гіх() # запам'ятати глобальну 
систему координат 

§1Тгапз1а1:е-Р(0, 0, -600) # перемістити 

систему координат вздовж 2 

зеї-р. ІаЬеІ.-|:ехі:= 1 ах=%сІ ау=%сІ '%(зе1-Р.х,зе1-Р.у) 

# змінити надпис 

зеї-р. ІаЬеІ .сІга\л/() # нарисувати надпис 
§1Во1:а-(:е-р( зеї-р. х, 1, 0 , 0 ) # повернути в 

новій системі координат навколо осі X 

§1Ко1:а1:е-р(5ЄІ-р.у^ 0, 1, 0) # повернути в 
новій системі координат навколо осі У 

зеї-р. сІга\л/Ахез() # нарисувати осі 
зеї-р. сІга\л/ОЬ]ЄСІ:() # нарисувати об'єкт 
§ІРорМа1:гіх() # відновити глобальну систему 
координат 

сіе-р сІгаи/Ахез( зеї-р) : # рисує осі Х,У,2 

§1Ве§іп(СІ-_І-]Ж5) # розмежовує вершини 

примітива (лінії) 

-Рог г,§,Ь,х,у ,2 іп [ (1,0,0,1000,0,0) , 
(0,1,0,0,1000,0) , (0,0,1,0,0,1000)] : 

§1Со1огЗ-Р(п, §, Ь) # колір наступної 


209 




вершини 

§1\/ег1:ехЗ-р(-X; ~У) -Т-) # перша вершина 
§1\/ег1:ехЗ-Р(х^ у, т.) # друга вершина 
§ІЕпсІ() # завершити список вершин примітива 

сіе-р сІпа\л/0Ь]есі:(5е1-Р): # рисує об'єкт 

§1Ве§іп(СІ-_ТКІАІ\І0іІ-Е5) # розмежовує вершини 

примітива (трикутника) 

§1Со1огЗ-Р(0, 0, 1) # колір наступної вершини 

§1\/ег1:ехЗ-р(0; 0, 0) # перша вершина 
§1\/ег1:ехЗ-Р(100, 0 ^ 0) # друга вершина 
§1\/ег1:ехЗ-Р(100, 100, 0) # третя вершина 
§ІЕпсІ() # завершити список вершин примітива 

Сіе-Р оп_тоизе_сІга§(5е1-Р^ х , у, сіх, сіу, Ьііііііопз, 
тосІі-Ріегз): # під час руху миші 

і-р Ьиііііопз & шоіібє.і-ЕРТ: 

5ЄІ-р.х-=сіу # змінити кут повороту на 

величину переміщення миші 

5ЄІ-р.у+=сІх 

МуІлІіпс1о\л/(\л/ісІ1:Іі=400, Ьеі§ІтІ:=400, 
сар1:іоп="ру§1е-1: ге5ІгаЬ1е=Тгие) # вікно 
ру§1е1:.арр.гип() # цикл обробки подій 


210 





Рисунок 48 - Вікно програми 

руїЬоиОСС - прив’язка до геометричного ядра Ореи СА8САОЕ 

ТесЬио1о§у 

Ореп СА8САБЕ ТесЬпо1о§у (ОССТ) - вільна бібліотека мовою 
С++ для геометричного моделювання (геометричне ядро), яка 
найчастіше використовується для створення САПР. Геометричні 
моделі створюються способом граничного подання ВКЕР (Ьоипсіагу 
гергезепіаііоп) у вигляді топологічних форм (вершин, ребер, циклів, 
граней, поверхонь, твердотільних форм і їх поєднань). руїйопОСС 
0.18.1 (Ьир://\¥\¥\¥.руіЬопосс.ог§) - бібліотека РуїЬоп, що дозволяє 
використання класів ОССТ [34]. Побудована за допомогою 8\¥Ю - 
інструмента для пов’язування коду С++ та РуїЬоп. 

■Ргот таіЬ ітрогі рі 

Ргот 0СС.§р ітрогі: * # геометричний процесор др ■ 
незбережувані базові геометричні об'єкти 
#^гот ОСС.веот ітрогі * # збережувані базові ЗО 
геометричні об'єкти 

Ргот ОСС.СС ітрогі * # алгоритми для побудови 
елементарних геометричних об'єктів ОСС.веот 

Ргот ОСС.ВРерВиіїсіегАРІ ітрогі * # класи для 

211 








моделювання і побудови чисто типологічних структур 
даних 

р1=§р_Рп1:(1, 0, 0) # точка (др_Рпі) 
р2=§Р_Рп1:(1, 2, 0) # точка 
рЗ=§р_Рп1:(2^ 1, 0) # точка 

есі§е1=ВКерВиі1с)егАРІ_МакеЕс)§е(р1^ р2). ЕсІ§е() # ребро 
(ТороОБ_Едде) 

агс=СС_МакеАгсО-РСігс1е(р1,рЗ;р2) .\/а1ие() # дуга 

(НапсІіе_Сіеот_ ТгіттедСигие) 

ес!§е2=ВКерВиі1с)егАРІ_МакеЕс1§е(агс) .Ес1§е() # створює 

ребро з дуги 

тіл/=ВКерВиі1сІегАРІ_Маке1лІіге() # створює контур 

(ВВерВиіідегАРІ_МакеІлІіге ) 

іш. Ас1сІ(есІ§е1) # додати ребро 

ти/. АсІсІ(есІ§е2) # додати ребро 

и/іге=ти/.1лІіге() # контур (Торо05_ІлІіге) 

■Расе=ВКерВиі1с1егАРІ_МакеРасе(и/іге) .Расе() # грань 

(Торо05_Еасе) 

уес1:ог=§р_\/ес(рі^ §р_Рп1:(1, 0, 1 )) # вектор (др_\/ес) 
■Ргот ОСС. ВКерРгітАРІ ітрогі: * # забезпечує АРІ для 
створення примітивів (призм, тіл обертання, 
витягувань, сфер, циліндрів ...) 

зоїісії = ВКерРгітАРІ_МакеРгІ5т(-РасЄ; уєсіог) .5Ьаре() 

# призма (Торо05_5ііаре) 

ахіз=§р_Ах1(§р_Рп1:(),§р_Оіг(0,1,0)) # вісь У (др_Ах1) 
50ІІСІ2 = ВКерРгітАРІ_МакеКеуо1(-РасЄ; ахіз^ 
рі).51іаре() # тіло обертання (Торо05_5Ьаре) 

■Ргот ОСС. ВКерА1§оАРІ ітрогі: * # забезпечує новий АРІ 
для булевих операцій з формами (об'єднань, вирізів, 
перетинів) 


212 




50ІісІЗ=ВКерА1§оАРІ_Ри5е(50ІісІ2; зоїісії) .5Ьаре() # 

тіло після об'єднання (Торой5_5Ііаре) ; деколи важлива 
послідовність аргументів 

Ргот ОСС .Оізріау.БітрІеСиі ітрогі: іпі1:_сІІ5р1ау # 

засоби для створення СІЛ 

сіізріау; 5І:аг1:_сІІ5р1ау., асІсІ_тепи, 

асІсІ_Рипс1:іоп_1:о_тепи = Іпі1:_гіі5р1ау() 

сіізріау. 5ЄІ:_Ь§_§гасІіеп1:_со1ог (255, 255, 255,255,255,255 

) # колір фону 

сІІ5р1ау.0І5р1ау5Ііаре(5о1ісІЗ) # показати форму 
сіізріау. РіГАІЦ) 

5І:аг1:сІі5р1ау () 



Рисунок 49 - Результати виконання програми 

РгееСАО - вільна САПР з РуІЇюп АРІ 

РгееСАО 0.17 (Ь П р: /Лу \у \у. ґгеесасІшеЬ. ог §) - це вільна 
параметрична ЗО САПР, яка базується на геометричному ядрі Орел 
СА8САОЕ ТесЬпо1о§у 7.2.0 і володіє РуїЬоп АРІ. Геометричні 
моделі створюються способом граничного подання ВКЕР за 
допомогою її РуїЬоп-модуля Рай, який є прямим зв’язком з ОССТ 
[34]. Повністю ОССТ доступна з РуїЬопОСС, але використання 


213 





РгееСАБ модуля Раті набагато зручніше. Для виконання прикладу 
введіть в консолі: 

"е:\РгееСА0 0.17х64\Ьіп\руІ:Ііоп.ехе" таіп.ру 

Для виконання з довільного інтерпретатора Руйтоп27х64 
введіть в консолі: 

с:\Ру1:Ііоп27\ру1:Иоп.ехе таіп.ру 


ітрогі зуз 

РКЕЕСАОРАТН = г"е:\РпееСА0 0.17х64\Ьіп" 

зуз. раїИ. аррепсі (РКЕЕСАОРАТН) # шлях до бібліотек 

РгееСАО 

ітрогі таіЬ 

ітрогі РгееСАР аз Арр # модуль для роботи з програмою 
ітрогі РпееСАОСиі аз Сиі # модуль для роботи з СІЛ 
ітрогі Рагі # могкЬепсЬ-модуль для створення і 
керування ВНер об'єктами 

у1=Арр.\/ес1:ог(0,0,0) # вектор (або точка) 

у2=Арр.\/ес1:ог(0, 10,0) 
уЗ=Арр.\/ес1:ог(5, 5,0) 

11=Рап1:. іЛпе5е§теп1:(у1, у2) # лінія 
е1=11.1:о5Ьаре() # ребро 

# або е1=Рагї.такеііпе((0>0 ) 0) , (0,10,0)) # ребро 
а1=Раг1:.Агс(у1,уЗ,у2) # дуга за трьома точками 
е2=а1.1:о5Ііаре() # ребро 

# або 

е2=Рагї.такеСігсіе(5, Арр. \ /есіог(в, 5, 0),Арр. Vесїо^(0 ^ 0 
А), -90, 90) 

Ьз=Раг1:. В5р1іпеСигуе() # В-сплайн 

Ьз.іпіегроІаіеС[ (0,0,0) ,(0, 1, 1),(0, -1, 2)]) # шляхом 

інтерполяції 


214 





# або 

#Ьз.арргохітаїе([(0,0,0),(0,1,1),(0,-1,2)]) # шляхом 
апроксимації 

#Ьз. Ьиі ід РготРоіез([(0,0,0), (0,1,1), (0, -1,2)]) # за 

списком полюсів 

еЗ=Ьз.1:о5Ііаре() # ребро 

\л/1=Раг1:.Ілііге( [е1,е2]) # цикл (сукупність ребер) 
ї1=Рагї. Расе(\л/1) # грань 
1:г5-Р=Арр .Ма1;гіх() # матриця трансформації 
1:г5-р.го1:а1:е2(та1:Ь.рі/4) # повернути навколо осі т. 
1:г5-р.тоуе(Арр.\/ес1:ог(5,0,0)) # перемістити 
-Р2=-Р1. сору() # копія форми 

-Р2.1:гап5-Рогт5Наре(1:г5-Р) # виконати трансформацію 

# або 

# 

/2. гоїаїе (Арр. \/есїог( 0, 0,0),Арр. \/есїог(0,0,1), 180.0/4 

) 

# /2. ігапзіаїе(Арр. \/есїог(5,0,0)) 

5І=-Р2.ех1:гисіе(Арр.\/ес1:ог(0,0,10)) # тіло шляхом 
видавлювання 

52=Раг1: .ІлІіге( [еЗ]). такеРіре(-Рі) # тіло шляхом 

видавлювання по траєкторії 

# або 

52=Рагї.ІлІіге([еЗ]).такеРіре5беіі([ іл/ 1], Тгие, Тгие) 

53=-Рі.геуоІУе(у1,Арр.\/ес-1:ог(0,1,0),90) # тіло шляхом 
обертання 

$2=52.-Ри5е(53) # об'єднання тіл (див. також соттоп, 
сиї, оідРизе) 

52=52. гетоуе5р1і1:1:ег() # видалити непотрібні ребра 
(ге^іпе з баре) 

# див. також такеВох, такеСуііпдег, такеїо^ї, 
такеТкіскпезз, ... 

5І=5І .такеРі11е1:(1 ,[ 5І. Есі§Є5 [1] ]) # скруглення (див. 

також такеСбат^ег) 


215 




ргіпі: зі. БЬареТуре # тип форми 

ргіпі зІ.УоІите # об'єм (див. також їепдіїї, Агеа, 
СепїегО^Мазз) 

ргі пі: зі. сіізіТ оБЬарє (з2) [ 0] # мінімальна відстань до 
іншої форми 

ргіпі з1.Расез[0] # перша грань 
РПІПІ ЗІ. ЕСІ§Є5 [0] # Перше ребро 

рпіпі іуре(з1. Есі§є 5 [0]. Сигуе) # тип кривої першого 

ребра 

рпіпі 5І.\/ег1:ехе5[0] .Роіпі.х # координата х точки 

першої вершини 

#5І.ехрогїВгер("ту.Ьгер") # експорт у форматі ВИ.ЕР 
(див. також ехрог±5±ер Л ехрогїідез) 

#5І = Рагї.5іюре() 

#5І.геад("ту.Ьгер") # імпорт у форматі ВІЇЕР 

# Наступні команди потрібні тільки для візуалізації 
створених форм 

Сиі. 5ЬомМаіп1лІіпсІснл/() # показати головне вікно 
гіос=Арр.пем0оситеп1:() # створити новий документ 
■Рог зіпаре іп [11 .іо5Иаре() , а1.іо5Ііаре() , іл/1, її, Е2, 
зі ^ Ьз.1:о5Ьаре (), з2]: 

Рагі. зНоЦзЬаре) # показати форму 
сіос. гесотри1:е() # перебудувати 
Сиі.ехес 1оор() # головний цикл програми 


СотроипсІ 

389.596349447 

0.0 

<Расе оЬ^есі аі 0000000003АР38О0> 
<ЕсІ§е оЬ]ЄСі аі 0000000003АР4350> 
сіуре ' Рагі.І-іпе'х 
-1.27414669346 


216 





Комбо панель 



АЬа^и8/САЕ - моделювання методом скінченних елементів 

АЬациз/САЕ 6.14 (ЬЦр://\у\у\у.ЗЙ8.сот/ргос1ис1:8-8егуісе8/8Іти1іа) 
- комерційне середовище для розв’язування задач механіки 
деформівного твердого тіла, гідрогазодинаміки і електродинаміки 
методом скінченних елементів (МСЕ). Володіє зручним АРІ мовою 
РугЬоп 2.7, який дозволяє створювати прикладні програми. В 
прикладі створюється осесиметрична модель деталі, яка 
розтягується осьовим навантаженням. Зазвичай послідовність 
розв’язування задач МСЕ містить етапи: створення геометрії, 
властивостей матеріалу, генерація сітки елементів, створення 
граничних умов, розв’язування рівнянь і аналіз результатів. 

Ргот аЬариз ітрогі * 

Ргот аЬаризСопзіапіз ітрогі: * 

МсіЬ () # створити нову модель 

т=тсІЬ.тосіеІ5[ 'Мосіеі-І' ] # модель 
ітрогі 05 

05 . сйсііг(г"С : ХАЬариз" ) # робочий каталог 
5=т .Соп5ігаіпесі5кеісІ'і(пате= '_ргоРііе_ , 


217 













5Ііее1:5І2Є=200.0) # ескіз 

з . Соп5І:гис1:іопІ-іпе( (0.0, -100. 0); (0.0, 100.0)) # 

допоміжна лінія 

роіп1:5=[(10.0, 0.0),(0.0, 0.0), (0.0, 10.0),(10.0, 
10.0),(5.0, 5.0), (10.0, 0.0)] # точки ескізу 

■Рог р1,р2 іп гір(роіпїзроіпііз[ 1 : ]): 

5.1_іпе(р1, р2) # лінія за точками 

р=т. Раг1:(пате=' Рагї-1 , сІітеп5Іопа1і1:у=АХІ5УМІ' / 1ЕТКІС, 
1:уре=0ЕР0КМАВІ_Е_ВСЮУ) # деталь 
р.Ва5е5Ье11(5ке1:сІі=5) # на основі ескізу з 

та1:=т.Ма1:егіа1(пате= 'Маїегіаі-І' ) # матеріал 
та1;.ЕІа5І;іс(1;аЬ1е=((2.1е11, 0.3), )) # модуль Юнга і 
коеф. Пуасона 

т.Ното§епеои55о1ісІ5ес1:іоп(пате= ' Бесїіоп-І' , 
таі:егіа1='Ма1:егіа1-1 , 1:Рііскпе55=Мопе) # однорідна 

секція матеріалу 

ге§іоп = р.Бе1:(-Расе5=р.-Расе5, пате= ' 5е1:-1' ) # 

геометричний регіон 

р.БесїіопА5 5І§птеп1:(ге§іоп=ге§іоп, 

зес1:іоп№те= 'Бесїіоп-І' ) # зв'язати секцію і деталь 

а = т. гооїАззетЬІу # збірка 

іп5І:=а.Іпз1:апсе(пате= 'Рагї-І-І , рап1;=р, 

сІерепсІеп'1:=0М) # її елемент 

а .5е1:(уег1:ісе5=іп5І:.уегїісез .-РіпсІАЇ:((( 5, 5,0) ,)), 
пате= ' СепїегРоіігІ:' ) # точка для результатів 
р. зеесІРаг1:(5І2Є=1 .0, сІеуіа1:іопРас1:ог=0 .1, 
тіп5І2еРас1:ог=0.1) # розміри сітки 
р.§епега1:еМе5Ь() # створити сітку 

т.51:а1:іс51:ер(пате=' 51:ер-1 , ргеуіоиз= ' Іпіїіаі 1 ) # 

статичний крок 

пе§іоп=а . Бе1:(есі§е5=іп5і:. есІ§Є5 . -РіпсІАІ: (((1,0,0),)), 
пате= 'Епсазїге' ) 


218 




т. Епсаз1:геВС(пате= ' ВС-1 ' , сгеа1:е51:ер№те=' 51:ер-1 , 
ге§іоп=ге§іоп, 1оса1Сзуз=І\Іопе) # гранична умова на 
нижньому торці 

ге§іоп=а . 5ип-Расе(зісІе1ЕсІ§Є5=іп5І:. есі§Є5 .-РіпсІАІ:(((1^10^ 
в),)), пате= ' 5ип-р-1' ) 

т. Рпеззипе(пате= ' І.оасІ-1 ' , сгеа1:е51:ер№те= ' 51:ер-1 , 
ге§іоп=ге§іоп, та§пі1:исІе=-10е6) # тиск на верхньому 

торці 

]оЬ=тсІЬ. ИоЬ(пате= ' ЗоЬ-1 ' , тосІе1= 'МосІеІ-1' ) # створити 
задачу 

]оЬ.зиЬті1;() # надіслати розв'язувану 

]оЬ .\л/аі1:РопСотр1е1:іоп() # чекати завершення 

-Ргот уізиаіігаііоп ітрогі * # для візуалізаціг 

результатів 

ос!Ь=орепОсІЬ("С:/АЬари5/ЗоЬ-1.осІЬ") # відкрити базу 
даних результатів 

Р=осІЬ. зііерз[' 51;ер-1' ] .Ргатез [-1].Ріе1сІ0и1:ри1:з # 

результати останнього фрейму 

ге§=осІЬ. гоо1:А55етЬ1у.е1етеп1:5е1:5[' ЕІМСА5ТКЕ ' ] # нижній 

торець 

ргіпі -Р[' 5' ] .§еі5иЬзеі(ро5І1:іоп=ІІ\ІТЕСКАТІ0І\І_Р0ІІ\ІТ, 
ге§іоп=пе§).уаіиез[0].тізез # еквівалентне напруження 

в елементі в регіону 

ге§=осіЬ. гооіАззетЬІу. погіеБеіз [ ' СЕІЧТЕКРОІІМТ' ] # 

центральна точка 

ргіпі: Р[ ’ІГ ] .§е1:5иЬзе1:(ро5І1:іоп=М00АІ, 
ге§іоп=ге§).уаіиез [0] .сіаіа # переміщення і)х і ііу 

(.тадпііиде - сумарне) 

осІЬ.сІозеО # закрити базу даних результатів 


7578833.5 

[ 0.00022752 0.00070781] 


219 






Рисунок 51 - Еквівалентні напруження за критерієм Мізеса-Губера 

(Па) 

8утРу - символьна математика 

8утРу (ЬНр ://\у\\'\у.8утру.ог«) - це бібліотека для символьної 
математики, яка призначена для роботи з математичними виразами 
в аналітичній (символьній) формі на відміну від чисельних 
обчислень в 8сіРу. Її можна розглядати як вільну альтернативу 
системам символьної математики Маріє, МаїНсасІ, МаІЇїетаІіса. Для 
прикладу 8утРу дозволяє інтегрувати, диференціювати, 
спрощувати вирази, розв’язувати рівняння в символьній формі. 

-Ргот зутру ітрогі * 

х,у, 1атсІа=5утЬоІ5( ’х у Іатсіа 1 ) # визначити змінні 
ехрг=х+у # вираз 
ехрг2=ехрг+х # вираз 

ргіпі ехрг2.5иЬз(у,2) # вираз шляхом підстановки у=2 
ргіпі 5герг(ехрг2) # низькорівневе представлення 
виразу 

ргіпі: ехрп2.аг§з # кортеж усіх складових виразу 

ргіпі ехрг2.аіот5() # атоми виразу 

ргіпі ехрг2.аіот5(8утЬо1) # атоми (типу ЗутЬоі) 

виразу 

ргіпі ехрг2.зиЬз([(х, 5) , (у,2)]).еуаіі() # підставити 

у вираз і обчислити 

#ргіпі ехрг2.5иЬз({х:5 } у:2}).еиаі^() # або так 


220 

























#ргіпі ехрг2. еиаі^(зиб5={х:5, у:2}) # або так 
#ргіпі М(ехрг2, зиЬз={х:5, у:2}) # або так 
ргіпі зутрііу( "х**2-1/2" ) # перетворити рядок у вираз 
ЗутРу 

ехргЗ=5Іп(х) # вираз 

-р=1атЬсІі-Ру(х л ехргЗ/'таіЬ") # функція для швидкого 
розрахунку числових значень. Третім аргументом може 
бути "таіТі" або "питру" або, наприклад, {"зіп":тузіп} 
ргіпі: і(0.1) # числове значення 

ехрг4=Іпіе§га1(5ргі(1/х ), х) # вираз-інтеграл 
рргіпі(ехрг4., и5Є_ипісосіе=Ра1зе) # виведення в 
ІІпісоде (Тгие) або А5СІІ (Раізе). Для ІІпісоде 
використовуйте для виведення ІРуіііоп <2ТСопзоіе або 
ІРуібоп поіеЬоок 

ргіпі 1аіех(ехрг4) # вивести як іаТеХ 
ігот 5утру.ргіпііп§.таіЬт1 ітрогі * 
ргіпі таіЬті(ехрг4) # вивести як МаНіРИ 

ргіпі 5Ітр1і-ру(5Іп(х)**2 + соз(х)**2) # спростити 

вираз 

ргіпі ехрапсІ((х + 1)**2) # розширити поліноміальний 
вираз 

ргіпі сіі-Рі(х** 2; х) # похідна 

ргіпі с1і-р-р(х**2, х,х) # похідна другого порядку 

#ргіпі ді^(х**2, х,2) # або так 

ргіпі ехргЗ.сІі-р-р(х) # похідна 

ехрг5=0егіуаііуе(х**2,х) # нерозрахована похідна 
іпіі_ргіпііп§(и5е_ипісосіе=РаІ5е) # не використовувати 

ІІпісоде для виведення 

рргіпі(ехргБ) вивести вираз в математичному вигляді 
ргіпі ехрг5.сіоіі() # розрахувати похідну 

ргіпі с)і-р-р(ехр(х*у) ,х,х,у,у) # мішана похідна 
ргіпі іпіе§гаіе(зіп(х),х) # невизначений інтеграл 


221 




рг і пі: іпіе§гаіе(ехр(-х) , (х, 0, оо)) # визначений 

інтеграл 

ргіпі іпіе§гаіе(ехр(-х**2 - у**2); (X; -оо., оо); (у., 
-оо., оо)) 

ргіпі: 1ітіі(5Іп(х)/Х; X; 0) # границя 
ргіпі 5егіез(5іп(х); X; 0 ^ 8) # ряд функції 

ргіпі 50іує(Ея(х** 2, 4)^ х) # розв'язати рівняння 

#ргіпї зоі\/е(х**2-4, х) # або так 

# розв'язку не знайдено, якщо зоіие повертає [] або 

викликає МоіІтріетепіедЕггог 

ргіпі 50іуе([х-у; х+у], [х, у], сІісі=Тгие) # 

розв 'язати систему рівнянь 

#ріої((х-2)**2-2) # нарисувати графік функції 

2 = ЗутЬоЦ'г', геаі=ТгиЄ; ро5ІіІУЄ=Тгие) # визначити 

змінну 

ргіпі 50іує( [г>2,(г-2)**2-2], г.) # розв'язати систему 

і=5утЬоІ5 ( ' і ' , сіз=Рипсііоп) # визначити функцію 
сііііер = Ея(-Р(х) .сІі-р-р(х л х) - 2*Р(х) .сІі-РІ^х) + і(х); 

0) # диференціальне рівняння 

ргіпі сі50іує (сіі-р-рер ^ -Р(х)) # розв'язати 
диференціальне рівняння 


2*х + 2 

АсІсІ(Ми1(Іпіе§ег(2 ), 5утЬоі(’х 1 )), 5утЬо1('у’)) 
(у, 2*х) 
зеі([2, х , у]) 
зеі([х, у]) 

12.0000000000000 
х**2 - 1/2 
0.0998334166468 
/ 


222 






СІХ 


І / 1 

І / - 

І \/ X 

/ 

\іпї: \5яг1:{\-( : пас{1}{х}}\, сіх 

<арр1ухіп1:/хЬуагхсі>х</сіх/Ьуагхарр1ухгоо1:/хар 

р1у><ро\л/ег/><сі>х</сі><сп>-1</сп></арр1у></арр1ух/ар 

р1у> 

1 

х**2 + 2*х + 1 

2*х 

2 

С05(х) 

сі / 2\ 

--\Х / 

СІХ 

2*х 

^ х **2*у**2 + 4*х*у + 2)*ехр(х*у) 

-соз(х) 

1 

РІ 

1 

х - х**3/6 + х**5/120 - х**7/5040 + 0(х**8) 

[-2, 2] 

[{х: 0, у: 0}] 

Ея(2, 5ЯГІ:(2) + 2) 

Ер(-Р(х)^ (СІ + С2*х)*ехр(х)) 

Взаємодія з Маріє 

Маріє (ЬіІр://\у\у\у.тар1е80Й.сот) - система комп’ютерної 
математики з можливостями символьних обчислень. У прикладі 
показано спосіб взаємодії РуїЬоп з Маріє шляхом створення файлу 
тутаріе.трі з командами Маріє та командного файлу 


223 



тутаріе. Ьаі;, який створює процес старіє.ехе, що виконує ці 
команди і повертає файл результатів гезиН .їх!. 


ітрогі 05 

Р=ореп("сі:/тутар1е.тр1", 'V') # відкрити файл з 
командами Маріє для запису 

■р.іл/гі1:е(г"еуа1-Р(5Іп(Рі/3)); ") # записати в файл 

команду Маріє 

■р. сІозе() # закрити файл 

Р=ореп( "сі:/тутаріе.Ьаї", 'V') # відкрити командний 
файл для запису 

■Р.іл/гі1:е1іпе5( (г"ра1:Ь сІ:\Рго§гат Рі1е5\Мар1е 
14\Ьіп.іл/іп" + "\п", 

г"стар1е.ехе < сі:\тутар1е.трі > 
Сі:\ге5и11:.1:х1:" + "\п", 

г"ехії")) # записати команди в 

командний файл 

■р. сІозе() # закрити файл 

ргіпі: 05.5уз1:ет(г ' зіагі: /ІлІАІТ сі: \тутар1е. Ьаі:' ) # 
виконати команду ОС і чекати її завершення 
05. гетоуе(г"сІ : \тутар1е. Ьаі" ) # видалити файл 
05. гетоуе(г"сІ : \тутар1е.трі' ) 


ОМРуІЬоп - інтерфейс ОрепМойеІіса РуіЬоп 

Мобеїіса - це основана на рівняннях об’єктно-орієнтована мова 
для зручного моделювання складних фізичних систем, які містять, 
наприклад, механічні, електричні, гідравлічні, термічні 
субкомпоненти. ОрепМобеІіса 1.12 (Ь Н р: /Лу\ у\у.орсптобеїіса. ог§/) - 
це вільне середовище симуляції мовою Мобеїіса. ОМРуїЬоп - це 
інтерфейс з ОрепМобеІіса мовою РуіЬоп, який забезпечує доступ до 
ОрспМосІсІіса АРІ. Для його інсталяції введіть в консолі: 


224 



ссі е: \0репМосІе1іса\5Ьапе\отс\5сгір1:5\Ру1:ЬопІп1:еп-Расе 
с:\Ру1:Ііоп27\ру1:Ііоп. ехе -т рір іпзіаіі . 

В прикладі розв’язується просте диференціальне рівняння з 
початковою умовою х(0) = 1: 


сосІе= ' ' ' тосіеі Вітріє 
Кеаі х(5іаг1:=1); 
рагатеїіег Кеаі а=1; 
еяиаііоп 

сІег(х)=а*х; 

епсі Вітріє; ' ' ' # модель мовою Модеііса 

іл/іііі ореп('Вітр1е.тоу, ' и/ ) аз і: -р.и/пі1:е(сосІе) # 

створити файл моделі 

ітрогі 05 , 5уз 
зуз. раіЬ. Іп5ег1:(0, 

г"е: ХОрепМосІеІісаХзЬагеХотсХзсгірізХРуїіІ'іопІпІег-Расе" ) 

# шлях до модулів 

■Ргот ОМРуіИоп ітрогі ОМСВеззіоп, МосІеНсаВузіет 

# перший спосіб - використання ОМСЗеззіоп: 

оте = 0МСВе55Іоп() 

оте. 5епсІЕхрге5 5іоп(' 1оасІРі1е( "Вітріє.то")' ) 

оте. зепсІЕхрге55Іоп( ' 5е1:Рагате1:ег\/а1ие(Вітр1е, а^ 2)') 

оте. 5епсІЕхрге5 5іоп(' 5Іти1а1:е(Вітріє)' ) 

оте. зепсІЕхрге5 5іоп(' ріоі (х)' ) 

ргіпі оте . 5епсІЕхрге55Іоп( ' уа1(х , 1.0)') # результат 
х(ііте=1.в) 

# або більш зручний спосіб: 

тосІ=І' / 1осіе1ісаВу5І:ет( "Вітріє.то , 'Вітріє") 
рг і пі: тосі.§е1:Рагате1:ег5() 
тосі. 5е1:Рагате1:еп5(а=2) 


225 





тосі. 5ЄІ:5іти1а1:іоп0р1:іоп5(5І:орТіте=2.0) 
тосі. зіти1а1:е() 

ргіпі: тосі .§е1:5о1и1:іоп5( їіте^'х') # результати як 

масиви 

# або компілювати модель і симулювати без ОМРуібоп: 

оте. зепсІЕхрге55Іоп( Ьиі1сІМосІе1(5ітр1е)' ) # 

компілювати 

05.єпуігоп["РАТН"] += оз.раіііізер + 
г"е:\0репМосіе1іса\Ьіп" # шлях до дії 
рагат=' ' ' ои1:ри1:Рогта1:=с5У 
з1:орТіте=2 
а ={} 

''' # значення параметрів 

■Рог і,р іп епитега1:е( [1, 2, 3 ]): # для кожного 

значення 

ореп( оуєггісіє%сі .їх* ’%і, 'VI') аз -Р: 
-р.\л/гіі:е(рапат.-Рогта-(:(р)) # створити файл зі 

значеннями параметрів 

оз.зуз1:ет(г 'Бітріе.ехе - 

оуєггісієРі1є=оуєггісіє%сі .їх* -г=5ітр1е_%сІ .сзу'%(і,і)) 

# симуляція 


7.38908993012 
{'а': 1.0} 

(аггау([0., 0.002^ 0.004, ..., 1.998, 2., 2.]), аггау 
([1., 1.00400801, 1.0080321, ..., 54.38076352, 54.598 
72293, 54.59872293])) 


226 





8 



йте 

Рисунок 52 - Результати симуляції 

хілті - створення електронних таблиць Ехсеї 

хіууі (ННр://рур і.ог«/річцссі/х 1 \\’[) - бібліотека для створення 
електронних таблиць у форматі Місго$оЙ Ехсеї 95-2003 на будь-якій 
платформі. В прикладі за допомогою хіууі 1.3.0 створюється робоча 
книга і лист Ехсеї, в комірки якого заноситься значення і формула. 

ітрогі: х1\лгЬ 

іл/огкЬоок = хііл/і: .1лІогкЬоок() # робоча книга Ехсеі 
зЬееЬ = и/огкЬоок.асІсІ_5Ііее1:( 5Ьее1:1 ) # робочий лист 
5ріее1:.\л/гі1:е(0^ 0, 7.0) # записати в комірку 0, 0 

значення 

зИееІ:.\л/пі1:е(0, 1, хііл/Е. Рогти1а( 'А1+2" )) # записати в 

комірку 0 ^ 1 формулу 

\л/огкЬоок.5ауе("Воок1.хІ5 м ) # зберегти файл 


ру\уїп32 - інтерфейс до \\іп32 СШ АРІ 

РуїЬоп їбг \¥іп32 Ехієп8Іоп8 (ру\уіп32) -це бібліотека, яка 
забезпечує доступ до багатьох \УіпсІо\У8 АРІ з мови РуїЬоп 
(Ннр://«ііНиЬ.сот/тЬаттопс1/ру\\їп32). Після установки 

документація доступна у файлі Ру\¥іп32.сЬт. 

227 















Приклад показує можливість застосування ру\уіп32 (версія 221) 
для управління графічним інтерфейсом інших програм. Програма 
створює процес саіс.ехе, знаходить вікно програми і імітує 
натискання клавіш клавіатури і миші користувачем. Після цього 
програма входить в цикл, в якому показує відносні координати 
миші. Щоб завершити програму посуньте курсор миші в верхній 
лівий кут екрану. 

ітрогі 05; зу5; іііте; \л/іп32арі; \л/іп32§иі, \л/іп32соп 
05.5у5іет( "зіагі: саіс.ехе') # виконати команду і 

продовжити роботу 

ііте.зіеер(і) # чекати 1 секунду 

Ьіл/псІ = міп32§иі. РіпсІ1лІіпсІо\л/(МопЄ; и"Калькуяятор" ) # 

знайти дескриптор вікна за назвою 

±гу: 

\л/іп32§иі.5е1:Ропе§гоипсІ1лІіпсіо\л/(Іііл/псі) # установити 

на передній план 

с\л/=іл/іп32§иі.Се1:ІлІіпсіо\л/Кес1:(Іііл/псІ) # координати 
вікна 
ехсері:: 

зуз. ехі1:() 

■Рог к іп [0х32;0х6В;0хЗЗ;0х0О] : # натиснути клавіші 2 
+ 3 Епіег 

\л/іп32арі. кеуЬсІ_еуеп1:(к;0;0;0) # к - віртуальний 

код клавіші 

Іііте.5Іеер(0.1) 

\л/іп32арі. 5е1:Сиг50гР05( [ сіл/[0] +380, с\л/[1]+260]) # 

установити курсор миші 

ііте.зіеер(і) 

\л/іп32арі . тои5Є_еуеп1:(\л/іп32соп .МОІІ5ЕЕ\/ЕІ\ІТР_І-ЕРТООШ;0; 

в,в,в) # натиснути ліву клавішу миші 

ііте.зіеер(1) 

иіп32арі .тои5Є_еуеп1:(\л/іп32соп .МОІІ5ЕЕ\/ЕІ\ІТР_І-ЕРТІІР;0;0; 

0;0) # відпустити ліву клавішу миші 


228 





Іііте. зіеер(і) 
мРіііє Тгие: # цикл 

с=и/іп32§иі.Се1:СипзопІп-Ро() # координати курсора 

миші 

ргіпі: с[2] [0]-сіл/[0], с[2] [1]-с\л/[1] # відносні 

координати 

і-р с[2]==(0,0): Ьгеак # завершити якщо координати 

(в, 0) 


305 68 
295 71 


\уіп32сот.с1іепІ - об’єкти Ехсеї 

СОМ (Сотропепі Оіцссі Мосісі) — платформа компонентно- 
орієнтованого програмування, яка використовується в ОС ЛУіпскт'з. 
Підтримує повторене використання і можливість взаємодії об’єктів 
незалежно від мови програмування, на якій вони були розроблені. 
Основними елементами СОМ є: об’єкт СОМ (екземпляр класу СОМ 
в сервері СОМ), сервер СОМ (програма, яка організовує доступ до 
створеного в ній об’єкта СОМ, реалізуючи інтерфейси), клієнт СОМ 
(програма, яка, використовуючи інтерфейс, отримує доступ до 
об’єкта СОМ), інтерфейс СОМ (визначає відкриті методи, які 
використовуються для доступу до об’єкта СОМ), клас СОМ 
(реалізація інтерфейсу СОМ в сервері СОМ). Пакет \л/іп32сот є 
частиною бібліотеки ру\¥Іп32 і реалізує пітримку СОМ в РуїЬоп. В 
прикладі створюється клієнт СОМ для доступу до об’єктів Ехсеї. 

ітрогі: и/іп32сот.сііепі: # імпортувати модуль 

міп32сот.сііепі 

оЬ] = \л/іп32сот.с1іеп1:.0І5ра1:сИ( 'Ехсеї.Арріісаіііоп 1 ) # 

створити об'єкт Ехсеі.Арріісаііоп 
оЬ].\/І5ІЬ1е = 1 # зробити Ехсеі видимим 

оЬ] .ІлІогкЬоокз . Асісі () # додати робочу книгу 


229 








оЬ] .СеІІз(ІД) .\/а1ие = "Неііо" # б комірку 1,1 
помістити "НеПо" 



Рисунок 53 - Результат роботи програми в Ехсеї 

\уіп32сот.с1іепї - об’єкти Ехсеї з обробкою подій 

В більш складному прикладі створюється клієнт СОМ для 
доступу до об’єктів Ехсеї з обробкою подій. Під час оброблення 
події програми ОпБЬееІїВеРогеОоиЬІеСІіск та події робочого 
листа 0п5е1ес1:іопСІіап§е виводиться інформація про вибрані 
комірки. Ц,ей модуль слід виконувати так: 

руіЬоп таіп.ру 

Для виходу слід в консолі натиснути Езс. Дивись інші 
приклади в с : \Руі:Ііоп27\ІіЬ\5І1:е-раска§Є5\и/іп32сот\1:е5І:. 

ітрогі \л/іп32сот.сііепі 
ітрогі шзусгі, руіЬопсот 

с1а55 МуЕхсеІЕуепіз: # події прикладної програми 
Ехсеі 

бе-Р ОпБЬееіВеіогеОоиЬіеСІіск^еІі., БЬееі, Таг§еі; 
Сапсеї): # обробник події ОпЗЬееіВе^огеОоиЬїеСїіск 
ргіпі "БЬееіВеіогеОоиЬІеСІіск" 
ргіпі Таг§еі.СеіАсІсІге55() # Тагдеї - комірка 
ргіпі Таг§еі.Со1итп # колонка 
рпіпі: Таг§еі. Кой/ # рядок 
#Тагде±.\/аіие=' 111' # значення комірки 

сіазг МуІлІогкзЬееіЕуепізО : # події робочого листа 

Іліогкзбееї 


230 










сіе-р Оп5е1ес1:іопСЬап§е(5ЄІ-р^ Кап§е): # обробник 
події ОпЗеіесїіопСіїапде 

ргіпі: сІіг(Кап§е) [: В] # вивести деякі атрибути 
об'єкта Капде (діапазон комірок) 

ргіпі: Кап§е.СеіАсІсІге55() # отримати адресу 

комірки 

ргіпі Кап§е . Сеі\/а1ие() # отримати значення 

комірки 

ехсеІАрр = 

\л/іп32сот. сііепі . 0ізра1:сІіІлІі1:ІіЕуеп1:5( "Ехсеі.Арріісаііоп 
", МуЕхсеІЕуепіз) # створити об'єкт 

Ехсеі.Арріісаїіоп з обробкою подій 
#ехсеіАрр = 

міп32сот. сііепї. 0ізраїсіі( "Ехсеі .Арріісаїіоп") # без 
обробки подій 

ехсеІАрр.УізіЬІе = 1 # зробити Ехсеі видимим 

шогкВоок=ехсе1Арр.1лІогкЬооІ<5.АсІсі() # додати робочу 

книгу 

\л/огк5Ьее1:=ехсе1Арр. АсіІуеІлІогкЬоок. АсііуєВЬєєі: # 

активний лист 

\л/огк5Нее1:=\л/іп32сот. сііепї:. ОізраІїсИІлІіІіІпЕуепІіз (\л/опк5Иее 
ї, МуїлІогкзЬееіЕуепіз) # створити об'єкт іліогкБіїееї з 

обробкою подій 

\л/огк5Ьее1:.Се1І5(1,1) .\/а1ие = 100 # в комірку 1,1 
помістити 100 

# в діапазони комірок помістити значення: 

\л/ог кВЬееІ:. Кап§е( "В1:02" ).\/аіие =( (1, 2, 3) , (10, 20, 30) ) 
іл/огкЗНееі. Кап§е("ВЗ :03" ) .\/а1ие =(и"а" д и"б" д и"в") 
іл/огкВНееІ:. Кап§е( "А2" ).Уаіие = "=А1+1" 

# або могкБіїееї.Сеііз(2,1) . Еогтиіа = "=А1+1" 


231 




иііііе Тгие: # цикл 

ІР гпбусгі:. кЬИіІ:(): # якщо в консолі натиснута 
клавіша 

ІР огсІ(т5УСГІ: .§еі:сІі() )==27: Ьгеак # 

завершити, якщо це Езс 

руРНопсот. Ритр1лІаі1:іп§Ме55а§е5 () # обробляти події 

\л/опкВоок.С105е(РаІ5е) # закрити робочу книгу без 
збереження 

ехсе1Арр.(2иі1:() # вийти з Ехсеі 

ехсе1Арр=могкВоок=могк5Ьее1:=І\Іопе 
Ргот \л/іп32сот.1:е5І:. иРіІ ітрогР СЬескСІеап 
СМескС1еап() # перевірити скільки СОМ об'єктів 
залишилося 

руРйопсот.СоІІпіпі1:іа1І2е() # відмінити ініціалізацій 
СІіескС1еап() # перевірити скільки СОМ об'єктів 
залишилося 


БНееРВеРогеОоиЬІеСІіск 

$А$1 

1 

1 

[’АсРІуаРе', 'АсИСоттепР ', 'АсіуапсесіРіНіеп' ] 
$А$2 
101.0 



Рисунок 54 - Робочий лист Ехсеі 


232 









л\тп32сот.с1іепі - об'єкти 80ЬГОЗУ0КК8 

В прикладі створюється клієнт СОМ для доступу до об’єктів 
системи автоматизованого проектування 80ЬГО\¥СЖК8. Програма 
змінює значення розміру активної моделі і перебудовує модель. 

ітрогі \л/іп32сот.сііепі: 

5\л/Арр = 

\л/іп32сот. сііепі:.ОізраСсП( "Бісіїліогкз . Арріісаііоп" ) # 

створити об'єкт Зіділіогкз .Арріісаііоп 

Рагі=5іл/Арр.Ас1:ІУе0ос # активний документ 
# змінити значення параметра "01@Ех±гиде1" на їв мм 

Раті. Рагате1:ег( "01@Ех1:гисІе1" ) .БузіеігЛ/аІие = 10.0/1000 
Раті. ЕсііІіКеЬиіїсІ # перебудувати модель 


рузегіаі - доступ до послідовного порту 

рузегіаі (Ьир://§ііЬиЬ.сот/ру8егіа1/ру8егіа1) - модуль РуїЬоп для 
доступу до послідовного порту на \Уіпс1о\У8, 08Х, Ьіпих, В8Б (будь- 
які Р08ІХ системи) і І гоп РуїЬоп. Для тестування віртуальних 
послідовних портів можна використовувати ЕШта УігШаї 8егіа1 Роті 
Бпуєт (Нир://\у\у\у.екіта.сот/т/ргос1исІ8/\'8рс1хр) або сотОсот 
(Ьйр://сот0сот.8оигсеїог£е.пеІ) і створити з’єднані віртуальні порти 
СОМ6-СОМ7. За допомогою 8егіа1 Роті Тегтіпаї можна відкрити 
СОМ6 або СОМ7 для запису чи читання даних. Або можна 
записувати і читати за допомогою рузегіаі 2.7, як це показано в 
прикладі. 

ітрогі: зегіаі,ііте 

сІа1:а=1І5І:( "Ьеііо!" ) # дані, що будуть надсилатись 

5ег6 = зегіаі. 5егіа1(рог1:= ’СОМ6 ' , ЬаисІга1:е=9600) # 

відкрити порт СОМб 

ргіпі зегб.рогізіг # перевірити чи порт 
використовується 

зег7 = зегіаі.5егіа1(рог1:= ’СОМ7 1 , ЬаисІга1:е=9600) # 

233 






відкрити порт С0М7 

ргіпі: зег7. ропі:Біг 
х= ' ' 

мНіїе х!= '!' : # поки на СОМб не прийде байт '! ' 
х=сІа1:а. рор(0) # отримати і видалити перший 
елемент 

5ег7.іл/пі1:е(х) # послати дані з С0М7 на С0М6 
4іте.зіеер(і) # чекати 1 секунду 
х=5егб. геасі(і) # читати байт на С0М6 

ргіпі: х , 

5еп7.сі05е() # закрити порт 
зегб.сІозеО # закрити порт 


СОМб 

С0М7 

Ь е 1 1 о ! 

руРігтаїа - комунікація комп’ютера та Агсіиіпо 

Агсіиіпо агсіиіпо.сс) - відкрита і зручна у використанні 

платформа, яка основана на одноплатному мікроконтроллері Аітеї 
АУК і використовується аматорами для побудови простих систем 
автоматики і робототехніки [13]. Рігтаїа (ЬіІр://йгтаІа.ог§) це 
загальний протокол для зв’язку мікроконтроллерів з головним 
комп’ютером. Рігтаїа дозволяє експериментувати з Агсіиіпо без 
необхідності його перепрограмовування кожного разу. В прикладі 
використано плату Агсіиіпо ІЛЧО для вимірювання значень 
температури за допомогою терморезистора і виведення їх на графік 
у реальному часі. 

Передусім установіть драйвер ІІ8В-8ЕКІАЬ для Агсіиіпо. В 
цьому прикладі це СН340 

(НЦ р :/Лу\\'\у.\\ сН.сп/сіо\уп 1 оасі/СН3418 Е1Р.НІтІ). Розпакуйте на 
комп’ютер середовище Агсіиіпо ГОЕ. У файлі /ауг/ЬоагсВ.ІхІ 
перевірте швидкість передачі даних ипо. иріоасі. зреесІ=57600. 
Під’єднайте датчик температури (терморезистор) до контактів 
ОІ8ГО, АКАИОС ЕЧ 0 (АО), 5У (рис.). Під’єднайте світлодіод до 


234 





контактів (ЖО і БІСІТЛЬ 13. Під’єднайте Аітіиіпо до ИЗВ-порту 
комп’ютера. В гілці “порти” диспетчера пристроїв знайдіть 11$В- 
ЗЕВІАЬ СН340 (СОМ9), де СОМ9 - назва послідовного порту. У 
вас номер може бути інший. З Агбиіпо ГОЕ завантажте в пам’ять 
мікроконтроллера приклад Ріг таІа/8 Іапбаг сіРігтаїа. Установіть на 
комп’ютері руЕігтаїа (Ьир8://§ііЬііЬ.сот/Цпо/руЕігтаїа) і запустіть 
наступний приклад. 


5У 



АО 


СМР 


Рисунок 55 - Під’єднання датчика температури 


ітрогі таірІоіІіЬ. руріоі аз ріі 
ітрогі ііте 

Ргот руіігтаіа ітрогі: Агсіиіпо, иііі 

ЬоагсІ = АгсІиіпо( 1 С0М9 1 ) # з'єднати Агдиіпо з портом 

СОМ 9 

іі = иііі.Ііегаіог(ЬоагсІ); іі.5І:агі:() # для 

використання аналогових портів 
ЬоагсІ. апа1о§[0]. епаЬ1е_герогііп§() 

Х=[] # список зі значеннями температури 
р1і.іоп() # інтерактивна побудова графіка 
иііііе 1еп(Х)<30: # поки довжина списку мала 
ііте.зіеер(і) # затримка 1 с 
х=ЬоагсІ.апа1о§[0] .геасІ() # читати значення з 
аналогового входу 0 
ргіпі х 

Х.аррепсІ(х) # додати в список 
ріі.р1оі(Х, " І<о- 1 ); рІі.сІгаЦ) # рисувати графік 
(ріі.сі^О - очистити) 

ІР х>0.35: # якщо температура висока 


235 









ЬоагсІ .сІі§і1:а1[13] .\л/пі1:е(1) # включити 

світлодіод 

еізе: 

ЬоагсІ .сІі§і1:а1[13] .\л/пі1:е(0) # виключити 
світлодіод 

ЬоагсІ.ехі1:() # вийти 



Рисунок 56 - Графік температури 

сопсиггепі.Гиіигея - запуск паралельних задач 

сопсиггепГґиШгек - високорівневий інтерфейс для асинхронного 
виконання виконуваних об’єктів за допомогою потоків 
(ТИгеасІРооІЕхесиїїог) або процесів (РгосеззРооІЕхесиїїог). 
Входить в стандартну бібліотеку РуїЬоп 3.2, але доступний і для 
РуїЬоп 2.7 (Ьир://рурі.ог§/рго]ес1:/ітіШге8). Подібний приклад можна 
також розробити за допомогою тиШргосе88Іп§. Див. також приклад 


236 









використання інтерфейсу ґиіигек в розподілених обчисленнях 
(Вазк.ОізІгіЬиІеб). 

ітрогі: сопсиггепі:.РикигеЗ; кіте 

сіе-р -Р(х) : # функція^ яка буде виконуватись в окремих 
процесах 

кіте.зіеер(х) # затримка (тільки для тестування 
паралельності) 

гекигп х 

і-р _пате_ == '_таіп_' : 

мікії 

сопсиггепк .-Рикигез. РгосеззРооІЕхесиког (тах_\л/огкегз=4) 
аз е: 

а=е.зиЬтік(-р; 4) # виконати в окремому 

процесі ?(х=4) 

Ь=е.зиЬтік(-р; 2) 
с=е.зиЬтік(-р; 3) 
сІ=е. 5иЬті1: (-р_, 1) 

# для кожного об'єкта Риіиге, що виконує / 

■Рог кик іп 

сопсиггепк .-Рикигез . аз_сотр1екес!( [а,Ь,с,сІ]): 

ргіпк -Рик.ге5и1к() , # отримати результати 

асинхронно 

#ргіпі [х. гезиііО /і ог х іп [а ^ Ь ^ с^д]] # або 
чекати усі результати 

#ргіпі [х /і ог х іп е.тар(^ } [1,2,3 } 4])] # або 

простіше 


12 3 4 


Базк - розподілені обчислення на чистій РуіЬоп 

Базк 0.18.2 (Мір: //сіазк. русі аіа. ог§) - це гнучка бібліотека для 
паралельних обчислень. Базк забезпечує динамічне планування 
задач, оптимізоване для інтерактивних обчислювальних 
навантажень, та прості шляхи масштабування задач Рапбаз, Зсікії- 


237 



Ьсагп і Митру. Дозволяє легко паралелізувати довільний РуїЬоп- 
алгоритм шляхом створення “лінивих” функцій з відкладеним 
виконанням. Функція сіазк.сіеіауесі обгортає довільну функцію 
так, що вона не виконується миттєво, а створює граф задач. 
Передача відкладених результатів іншим відкладеним функціям 
створює залежності між задачами. Обчислити результати 
паралельно можна за допомогою методу сотриіе. Нижче наведено 
приклад алгоритму, який паралелізується. Для виконання прикладу 
на кластері див. приклад Вазк.ВМігіЬиІесІ. 

■Ргот сІазк.сІізРгіЬиРесІ ітрогі Сііепі 
Ргот сіазк ітрогі: сіеіауесі 
ітрогі ііте 

сІеР Р(х): # функція, яка буде виконуватись в окремих 
процесах 

ііте.5Іеер(х) 
геіигп х 

і-р _пате_ == '_ таіп_' : 

#сііепї = Сігепі() # клієнт (кластер на локальній 
машині) 

сііепі = С1іепі( 1 192.168.1.33:8786' ) # клієнт 

ГЄ5=[] 

Рог х іп [1, 2 , 3,4]: 

Р_ = сіеіауесі(р) (х) # відкладене виконання 
функції / 

пе5. аррепсі (-Р_) # додати відкладений результат 

в список 

5ит_=сІе1ауесІ(5ит)(гез) # відкладене виконання 
функції зит 

ргіпі зит_.сотриіе() # обчислити 
?(1),^(2) ,^(3),^(4) паралельно, а потім обчислити їх 
суму 


10 


238 



Ва8к.ВІ8ІгіЬиІес1 - розподілені обчислення 


Розподілені обчислення - це вид паралельних обчислень за 
допомогою множини комп’ютерів, які об’єднані в мережу. 
Ва8к.ВІ8ІгіЬиІес1 (ЬіІр://бІ8ІгіЬиІес1.геасІіЬесІос8.іо) - це легка 
бібліотека для розподілених обчислень на РуїЬоп. Вона розширює 
АРІ сопсиггепі: .Риііигез і йазк (бібліотека паралельних 
обчислень на чистій РуїЬоп) для невеликих кластерів. Для 
виконання прикладу необхідно установити Ба8к повністю на 
кожній \¥іпсіо\¥8 машині: 

рір іпзЬаІІ м сІа5к[сотр1е1:е]" 

Або на кіпих-машині: 

5ибо рір2 іпзЬаІІ м сІа5к[сотр1е1:е]" 

На одній ма ш ині (наприклад 192.168.1.33) запустити 
планувальник: 

сІазк-зсЬесІиІег 

На кожній машині запустити виконавців, які виконують 
завдання планувальника за допомогою ТЬгсасІРооІ. Якщо 
обчислення вивільняють СІЬ (наприклад МитРу або Рапсіаз), 
введіть: 

сіазк-и/опкег 192.168.1.33:8786 

Або, якщо обчислення не вивільняють СІЬ: 
сіазк-и/опкеп 192.168.1.33:8786 --прпосз 4 --пкЬгеасІз 1 
Виконати програму клієнта: 
рукЬоп таіп.ру 

Переглянути статус виконання можна в браузері (потрібен 
установлений ВокеЬ): 


239 



И-Ь-Ьр : //192.168.1.33:8787 


Ргот сІазк.сІізРгіЬиРесІ ітрогР Сііепі:,, а5_сотр1еРесІ 
ітрогР Ріте 

сІе-Р -Р(х): # функція, яка буде виконуватись в окремих 
процесах 

Ріте.зіеер(х) 
геРигп х 

ІР _пате_ == ' _таіп_' : 

#сііепі = Сііепі() # клієнт (кластер на локальній 
машині) 

сііепр = С1іепР( ' 192.168.1.33:8786' ) # клієнт 
ргіпР сііепр 

а=с1іепР.5иЬтіР(Р, 4) # виконати на кластері 

і(х=4) 

Ь=с1іепР. 5иЬтіР(Р, 2) 
с=с1іепР.5иЬтіР(Р, 3) 
сі=с1іепР. 5иЬтіР(Р, 1) 

# для кожного об'єкта Риіиге, що виконує / 

Рог РиР іп аз_сотр1еРесІ( [а, Ь, с,сІ]): 

ргіпР РиР.ге5иІР() , # отримати результати 
асинхронно 

#^иіиге5=сііепі.тар(ф : , [1,2,3,4,5,6,7,8]) # або 
#ргіпі сііепі.даібег(^иіиге5) # чекати усі 
результати 

# або [^иі. гезиііО /ог /иР іп / иіигез] 


<С1іепР: зсИесІи1ег=' Рср: //192.168.1.33:8786' 
5=8 согез=8> 

1, 2, 3, 4 


рпосеззе 


Ру(3і4 - фреймворк в РуІЇїоп 

Ру0(4 (Ь Н р:/Л у\у\¥. гіVсі'ЬапксотриПп«.сот /зоЙшаге /рурІ) - це 
“прив’язка” фреймворку С/1 до мови РуїЬоп. С/1 - це 

багатоплатформовий програмний фреймворк для створення ПЗ 


240 



мовою С++. Містить класи для створення СІЛ, роботи з мережею, 
базами даних, ОрепСЬ, мультимедіа і т.д. Існує також прив’язка з 
більш вільними умовами ліцензування РуЗісІс 
(ЬЦр://\¥Ікі.ц1.іо/Ру8ісіе), яка сумісна на рівні АРІ з РуОі. В прикладі 
показано програму з СІЛ для розрахунку квадрату числа. Цей 
приклад буте також працювати в РуЗісІс 1.2.4, якщо замінити рядок 
Ру()1:4 на РуЗісІе. 

ітрогі зуз 

■Ргот Ру()і4.(2іСоге ітрогі: * # базові класи 

ігот Ру()і4.С)іСіиі ітрогі * # СІЛ класи 

сіазз Му_0іа1о§((ріа1о§) : # клас вікна успадковує 

(?Оіаіод 

сіе-р _ іпіі_(зеїі, рагепі=І\Іопе): # конструктор 

зирег(Му_Ріа1о§, зеїі) ._ іпіі_ (рагепі) # 

виклик конструктора (}Оіаіод 

5ЄІР. зєіілііпсіомТ іііе ( х**2") # надпис вікна 
зеїі. гезІ2е(150, 100) # змінити розмір вікна 
зеїі. ризИВиііоп = 

^Ри5ИВи1:1:оп( 'Саісиїаіе' , зеїі) # кнопка 

зеїі. ризЬВиііоп. зеіСеотеігу(()Кесі(25, 50, 90, 

30)) # змінити геометрію кнопки 

зеїі. ІіпеЕсІіІ = (ЗііпеЕсЦіС^', зеїі) # поле 

редагування 

зеїі. ІіпеЕсІіІ:. зеібеотеігу (С)Кесі(25, 10, 90, 

30)) # змінити геометрію поля редагування 

зеїі. ІіпеЕсІіІ. зеіРосиз() # установити фокус 

вводу 

# приєднати сигнал сііскед() до слота 

5ЄІ/. 5І0І 

зеїі. соппесі(зе1-р. ризИВиііоп, 
5ІСІ\ІАІ-("с1іскесІ()"), зеїі.зіоі) 

сіе-р зіоі( зеІР) : # обробник сигналу сііскед() 
х=-Р1оаі(зе1-р.1іпеЕс)іі.іехі()) # введене у 

поле число 


241 





зеї-Р. ІіпеЕсІіІ:. 5еіТех1:( (х**2). _зіг_ ()) # 

вивести у поле 

арр = (2Арр1іса1:іоп(5у5. аг§у) # створити застосування 
сііаіо^ = Му_0іа1о§() # створити вікно 
гііа1о§.5Ііо\л/() # показати вікно 
арр.ехес() # виконати застосування 


Е ) х **2 _?!_><] 

4.0 


Саісиїаіе 


Рисунок 57 - Вікно програми 

Ру(^і4 - елементи керування (}їСиі 

Більш складний приклад використання таких елементів 
керування як (ЗМаіпІлІіпсІоїл/ (головне вікно), (ЗМепиВаг (смуга 
меню), (ЗМепи (меню), (ЗАсііоп (дія СІЛ), (ЗТехіВгои/зег 
(текстовий браузер), (^СотЬоВох (список), (ріаі (пристрій 
регулювання), ()СІіесІ<Вох (прапорець), (^Ріхтар (рисунок), ()І-аЬе1 
(надпис або рисунок), (2ТгееІлІісІ§е1: (дерево), (2Тгее1лІісІ§е1:І1:ет 
(елемент дерева), (2Рі1е0іа1о§ (вікно вибору файлу), 
(ЗМе5 5а§еВох (вікно з повідомленням), (^Арріісаіііоп (СІЛ- 
застосування). Програма Бе8І§пег дозволяє полегшити створення 
складних СІЛ в режимі \УУ8І\УУС. Після створення нею файлу 
опису СІЛ таіп. иі потрібно згенеруватн код РуїЬоп за допомогою 
програми руиіс: 

руиіс.ру -х таіп.иі -о таіп.ру 


ітрогі зуз 

■Ргот Ру(2і4.(2іСоге ітрогі: * 
■Ргот Ру(2і4.(2іСіиі ітрогі * 


242 












сіазз МуІлІіпЬо\л/(()МаіпІлІіпсІо\л/): # клас вікна успадковує 

(2Маіпілііпдом 

сіе-р _ іпіі_(зеї-Р, рагепі=І\Іопе): # конструктор 

зирег (Муїлііпсіои/., зеї-Р)._іпії:_ (рагепі) # 

виклик конструктора @Маіпілііпдом 

зеї-Р. ге5І2е(400, 300) # змінити розмір вікна 
зеї-Р. тепиЬаг = (ЗМепиВаг(зеІ-Р) # створити 
смугу меню 

зеї-р.тепиЬаг. зеіСеотеігу(()Кесі(0; 0; 400; 

24) ) # геометрія 

# підменю: 

зеї-Р. тепиРііе = (ЗМепи(зеІ-Р.тепиЬаг) # меню 

Рііе в тепиЬаг 

зеї-Р. тепиРііе.зеіТіі1е( 'Рііе" ) # установити 

надпис 

зеї-Р. тепи№\л/ = ()Мепи(5ЄІ-р.тепиРііе) # меню 
Л/еіл/ в тепиРііе 

зеї-Р. тепи№и/.зеіТіі1е( "Ие\л/ ) 
зеї-Р. тепиАЬоиІ = (ЗМепи(зеІ-р.тепиЬаг) 
зеї-Р . тепиАЬоиІ:. зеіТіііе ( АЬоиі" ) 

# дії меню: 

зеї-Р. асііоп№\л/Ііет = ()Асііоп( зеї-Р) 
зе1-р.асііоп№\л/Ііет.зеіТехі( "№\л/ Ііет ) 
зеї-Р. асііопОреп = (ЗАсііоп(зеІ-р) 
зеї-Р. асііопОреп. зеіТехі( Ореп") 

# додати до меню дії: 

зеї-Р . тепи№\л/. асі сІАсііоп( зеї-Р . а сііоп№\л/Ііет) 

зеї-Р. тепи Р Не. асИАсііоп ( зеї-Р .тепи№\л/.тепиАсііоп()) 
зеї-Р. тепиРііе. асісІАсііоп( зеї-Р. асііопОреп) 

зеї-Р. тепи Ьа г.асІЬАсііоп( зеї-Р. тепиРііе. те пиАсііоп()) 

зеї-Р. тепи Ьаг.асІсІАсііоп( зеї-Р. тепиАЬоиІ. тепиАсііоп()) 


243 




зеІ-р.ІехІїВгоіл/зег = (ЗТехІВгоіл/зег (зеї-р) # 

текстовий браузер 

зеІ-р.ІехІїВгоіл/зег.зе1:Сеоте-1:гу((2Кес1:(10, 30, 

130, 200)) 

зеї-р. сотЬоВох = (2СотЬоВох( зеї-р) # 

комбінований список 

зеї-р. сотЬоВох.асШі:ет5( [5І:г(і) -Рог і іп 
гап§е(1, 11) ]) # додати елементи 

зеї-р. сотЬоВох.зе1:Єеоте-1:гу((2Кес-1:(10, 240, 100, 

20)) 

зеї-р. сііаі = (ріаЦзеІ-Р) # пристрій 

регулювання 

зеї-р . сііаі. 5Є-Шо-1:сРіЄ5\/І5ІЬ1е(Тгие) # 

установити шкалу 

зеї-р. сИа1.зе1:Сеоте-1:гу((ЗКес1:(150, 30, 50, 50)) 
зеї-р. сРіескВох=(2СРіескВох( СИескВох' , зеї-р) # 

прапорець 

зеї-р. сЬескВох.зе1:ТпІ5-(:а-1:е(Тгие) # установити 

три можливі стани 

зеї-р. сИескВох. зеІСеотеІігу (^Рес1: ( 150, 110, 

100, 20)) 

зеї-р. ріхтар=(2Ріхтар() # рисунок 
зеї-р. ріхтар. 1оасІ(и м ріс .рп§" ) # завантажити 
зеї-р. 1аЬе1=()І-аЬе1(5е1-Р) # надпис 
зеї-р. 1аЬеі. зе-(:Ріхтар( зеї-р . ріхтар) # 

установити рисунок 

зеї-р. ІаЬеІ. зе1:С>еоте1:гу((ЗКес1:(150, 150, 100, 

100)) 

зеї-Р. -Рпее1л1іс1§е1: = (2Тгее1лІісі§е-1:( зеї-р) # дерево 
зеї-р. -Рпее1л1іс)§е1:. зеІСеотеІігу ((ЗКес1:(250, 30, 

140, 200)) 

і-рет_0 = (2ТгееІлІісі§е1:І-1:ет( зеї-р. 1:гее1лІіс1§е1:) # 

додати кореневий елемент 

І1:ет_1 = рТпее1лІісі§е1:І-(:ет(і-1:ет_0) # додати 
дочірній елемент до ііет_0 


244 




І1:ет_0.зе1:Тех1:(0, 'есІіІіаЬІе ) # установити 
текст елемента 

І1:ет_1. зе1:Тех1:(0, ' 11' ) 
і-рет_0.5ЄЇРІа§5(С1:. І1:етІ55е1ес1:аЬ1е 
.ІІіетІзЕсІіІіаЬІе (21:.І1:етІ50га§ЕпаЬ1есІ | 

(21:. І1:етІ5ІІ5егСРіескаЬ1е (21:. ІІіетІзЕпаЬІесІ) # 

властивості елемента 

бєі-Р . 1: гееїліісі^еі:. ехрапсІТойерІїИ ( 2 ) # розвернути 

дерево до рівня 2 

# приєднати сигнали до слотів: 

бєі-Р . соппєс1:(5ЄІ-р. сотЬоВоx^ 5ІСМАЦ м сиггеп1:ІпсІехСЬап§е 
сі (і пі:) ); зеї-р. 5 іо1:2) 

бєі-Р. соппесі: (зеї-Р. сііаі, 

БІСИАЦ 'уа1иеСРіап§есІ(іп1:) ), бєі-Р. 5Іо1:3) 
бєі-Р. соппесЦ бєі-Р. сРіескВох, 

5ІСМАЦ '5-ра-реСЬап§есІ(іп1:) ), бєі-Р. 5іо1:4) 
бєі-Р. соппес1:(5е1-Р.ас1:іоп0реп, 

БІСМАЦ ’1:гі§§егесІ () "), бєі-Р. зіоііі) 

бєі-Р. соппесЦ бєі-Р. ас1:іопМеіл/І1:еггь 
БІСИАЦ '1:гі§§егесі ()" ), бєі-Р. 5іо1:2) 

бєі-Р. соппесЦ бєі-Р. 1:гееІлІісІ§е1:, 

5ІС№І.( " і-регїЮоиЬ1еС1іскесі((2ТгееІлІісі§е1:І1:ет*, іггР)" ), 
бєі-Р. 5Іо1:4) 

#обробники відповідних сигналів: 

сіе-р 5Іо1:1(5е1-Р): 

-Рі1епате=(2Рі1е0іа1о§. §е1:0репРі1еІ\Іате(5е1-Р; 
"МуРіїе") # ім'я файлу з вікна вибору файлу 

бєі-Р. " 1:ех1:Вго\л/5ег.аррепсі( <-Роп1: со1ог=Ь1ие>" + 
-Рііепате + "</-Роп1:>" ) # додати в текстовий браузер 

сіе-р 5 іо1:2(5ЄІ-Р) : 

і-р 5ЄІ"Р . -ргееїліісі^еі:. сиггеп1:І1:ет()! =Nопе : # 

якщо існує поточний елемент дерева 


245 




іііет = 

^Тпее1лIісI§е1:I1:ет(5е1■Р.■^:^ее1лIісI§е■^:.сиггеп1:І1:ет()) # 

створити дочірній елемент до поточного 

і1:ет.5е1:Тех1:(0, Ие\л/ ) # його текст 
іііет. зе1:Тех1:Со1ог(0,(2Со1ог(255,0,0)) # 

його колір 

іііет. бєііСіпєс к51:а1:е( 0 ^ (^Іі.СЬескесі) # 

установити стан 

еізе: # інакше вивести вікно повідомлення 

(ЗМе5за§еВох.\л/агпіп§(5е1-Р; 
"І' / 1е55а§еВох"/ , 5е1ес1: рагепі: іііет!") 

5ЄІ-р.-(:ех1:Вго\л/5ЄГ.аррепсі( іпсіех {0} - їехі: 

{1}" .-Ропта1:(5е1-Р. сотЬоВох. сипгеп1:ІпсІех (), 
зеї-р. сотЬоВох. сиггеп1:Тех1:())) # додати в браузер 
індекс і текст поточного елемента списку 

сіе-р 5Іо1:3(5ЄІ-р): 

зеї-р. сІїескВох. 5ЄІ:Тех1:(5ЄІ-р.сІіа1.уа1ие(). _зі:г_ ()) # 

значення пристрою регулювання 

сіе-р 5 іо1:4(5ЄІ-Р) : 

і-р 5е1-р.1:гее1л1іс1§е1:.сигпеп1:11:ет() !=Иопе: # 

якщо існує поточний елемент дерева 

і-р 

5е1-р.1:гее1л1іс)§е1:.сигпеп1:11:ет().сЬеск51:а1:е(0): # якщо 

стан вибраний 

5е1-р.1:гее1л1іс)§е1:. гетоуеІ1:ет1лІісІ§е1:(5ЄІ-р.1:гее1лІісі§е1:. сигг 
еп1:І1:ет() ,0) # видалити поточний елемент 
зеї-р.ІіехІїВгои/зег.аррепсі( сЬескВох 
{0}" .-Ропта1:(5е1-Р.сІіескВох.сІіеск51:а1:е())) # додати в 

браузер стан перемикача 

арр = (2Арр1іса1:іоп(5у5.аг§у) # створити застосування 


246 




ІаЬеІ = (2І_аЬе1( "<-Роп1: со1ог=гесІ 5І2Є=72хЬ>" + 
"Неііо" + "</Ьх/-Ропі>") # надпис (з'являється перед 
появою головного вікна) 

1аЬе1.5е1:ІлІіпсІо\л/Р1а§5(С)1:.5р1а5Іі5сгееп) # властивості 

вікна 

ІаЬеІ. 5Ііои/() # показати 
ітрогі: Іііте 

ііте.5Іеер(1) # затримка на 1 с. 

ІаЬеІ.ИісІе() # сховати надпис 

иіпсіоїл/ = Му1лІіпсІо\л/() # створити вікно 
іл/іпсіоїл/.5Іпо\л/() # показати вікно 

#^Тіте^.зіпдіеБЬоі(10000 ^ арр.диіі) # вийти через 10 
с. 

арр.ехес() # виконати застосування 


1-1 руІЬоп — І□ І Х| 

Рііе АЬоиІ 


іпЬех 0 - Іехі 1 
тЬех 0 - Іехі 1 
іпЬех 1 - Іехі 2 
іпЬех 1 - Іехі 2 
сЬескВох 1 



0 31 


3] 


В ейЬЬІе 

В' 11 _ 

ВІИЕЗЯ^И 

0 N6» 
В □ N0» 

0 Мел 1 


Рисунок 58 - Вікно програми 


Ру(^і4 - створення елемента керування 

В прикладі показано створення нового елемента керування 
(ОШ-віджету) МуВиіІіоп шляхом успадкування класу (ЗРизЬВиїїІіоп 

247 

















(кнопка). На відміну від базового класу нова кнопка володіє 
атрибутом зіа^е, логічне значення якого змінюється на 
протилежне під час натиску на неї. Крім того це значення 
відображається на самій кнопці. 

ітрогі: зуз 

-Ргот Ру(2і4.(21:Соге ітрогі: * 

-Ргот Ру(2і4.()1:0иі ітрогі * 

сіазз МуВиііоп^РизНВиііоп): # клас успадковує 
(^РизТіВиііоп 

зіаіе = Тгие 

сіе-р _іпіі_(зеїі, зіаіе, рагеп1:=І\Іопе): # 

конструктор 

зирег(МуВи1:1:оп, зеїі)._іпіі_ (рагепі) # 

виклик конструктора (^РизТіВиііоп 

зеїі. зіаіе=зіаіе # стан кнопки (Тгие, Раізе) 

зеїі . зеіТех-Цзеїі. зіаіе._ 5ІГ_ ()) # 

установити надпис на кнопці 

# приєднати сигнал сііскед() до слота 
зеї/. сЬапде_5±а±е() 

зеїі. соппесЦзеІі, 5ІСИАІ.("с1іскесІ() ), 
зеїі. сНап§е_з1:а1:е) 

сіе-р с1іап§е_5І:а1:е(5е1і): # обробник сигналу 
сііскеб() 

і і зеїі. зіаіе: # якщо стан Тгие 

зеїі . етіі(5ІСМАІ-( "зіаіе_ігие' ), 
зеїі. зіаіе) # генерувати сигнал зіаіе_ігие 
зеїі. зіаіе=Ра1зе # змінити стан 
еізе: # інакше генерувати сигнал 5іоіе_/аІ5е 
зеїі. етіі(5ІСМАі("5іаіе_іа1зе' ), 

зеїі. зіаіе) 

зеїі. зіаіе=Тгие # змінити стан 
зеїі. зеіТехі(зе1і. зіаіе._ зіг_ ()) # 

установити надпис на кнопці 


248 





сіазз Му_0іа1о§(()0іа1о§): # клас вікна успадковує 

<2 Оіаіод 

сіе-р _іпії_(зеї-Р, рагепі=І\Іопе): # конструктор 

зирег(Му_0іа1о§, зеї-Р)._іпії_ (рагепі) # 

виклик конструктора £Оіаіод 

зеї-Р. гезІ2е(230, 100) # змінити розмір вікна 

зеї-Р. ризЬВиіІіопІ = МуВи1:1:оп(Тгие, зеї-Р) # 

кнопка 

зеї-Р. ризЬВиіІіопІ. зе1:Сеоте1:гу((ЗКес1:(25, 50, 

90, 30)) # змінити геометрію кнопки 

зеї-Р. ризНВи1:1:оп2 = МуВи1:1:оп(РаІ5Є, зеї-Р) # 

кнопка 

зеї-Р. ризЬВи1:1:оп2. зе1:Сеоте1:гу((ЗКес1:(120, 50, 

90, 30)) # змінити геометрію кнопки 

зеї-Р. ІіпеЕсІіІ: = ()1-іпеЕсіі1:(5ЄІ-р) # поле 

редагування 

зеї-Р. ІіпеЕсІіІ:. зеїСеотеігу (()Кес1:(25, 10, 90, 

30)) # змінити геометрію поля редагування 

# приєднати сигнали до слотів 

зеї-Р. соппе сі (зеї-Р. ІіпеЕсІіІ:, 

5ІСМАЦ "іехі:СІіап§есі ((25ігіп§)" ), 

зеї-Р, 

5ЮТ ( м зе1:ІлІіпсІо\л/Ті1:1е((251:гіп§)" )) 

зеї-Р. соппесі( зеї-Р. ризНВиііопІ, 

5ІСМАЦ 'зїаїе_1:гие") , зеї-Р. зіої) 

зеї-Р. соппесї( зеї-Р. ризЬВиі1:оп2, 

БІСіМАЦ '5їаіе_1:гие"), зеї-Р. зіої) 

сіе-р зіоі( зеї-Р) : # обробник сигналу зіаіе_ігие 
Ьиііоп = зеї-Р. зепсІег() # компонент , що 
надіслав сигнал 

# якщо це ніякий компонент або не об'єкт 
класу МуВиііоп 

і-р Ьиііоп із ІМопе ог поі ізіпзїапсе(Ьиііоп, 
МуВиіїоп): 


249 




геіигп # то вийти 

§1оЬа1 х # звернення до глобальної змінної 

і-р Ьи1:1:оп==5ЄІ-р. ризІїВиІЛопІ: х+=1 # якщо 
кнопка ризбВиїїопІ 

еізе: х-=1 # інакше 

зеї-р. ІіпеЕсІіІ:. зе1:Тех1:(х._ зіг_ ()) 

х=0 # глобальна змінна 

арр = 0Арр1іса1:іоп(5у5. аг§у) # створити застосування 
сІіа1о§ = Му_0іа1о§() # створити вікно 
сІіа1о§.5Ио\л/() # показати вікно 
арр.ехес() # виконати застосування 



Рисунок 59 - Вікно програми 

РуРаг8Іп§ - зручний синтаксичний аналіз 

Синтаксичний аналіз (парсинг) - це процес зіставлення 
послідовності лексем (неподільних груп символів) певної мови з її 
формальною граматикою (способом опису мови). Лексеми 
отримуються шляхом лексичного аналізу (токенізації). РуРа8Іп« 
2.2.0 (ЬНр://рурі.ог^/рго]ссі/рураі'8іп«) - модуль для синтаксичного 
аналізу, який реалізує альтернативний і більш зручний підхід для 
створення і використання граматик, у порівнянні з традиційним 
Іех/уасс або використанням регулярних виразів. Модуль містить 
класи для створення граматик прямо в Руйюп-коді. 

-Ргот _-Риііипе_ ітрогі: ргіп1:_-Рипс1:іоп 

-Ргот рурагзіп§ ітрогі: * 

5= "Оєііо іл/огісі!" # текст, який будемо парсити 
# вираз для парсингу: 


250 
















\л/опсІ=Іл1огсІ(а1рЬа5) # слово з букв, 
аірі)аз= 'абссіе. . . ' +’АВСОЕ.. . ' 
ргіп1:(1:уре(\л/опсІ)) 

#<сіазз ' рурагзіпд.НогсІ'> 

р="Ье11о"+и/огсІ+Іі1:ега1( ! ) 

# або р=АпсІ([іііегаі("ііеііо"), могсі, іііегаі("! ")]) 
ргіпИ(1:уре(р)) 

#<сіазз ' рурагзіпд.Апй'> 

ігу: # тут бажане перехоплення помилки 

ргіітІ:(р.раг5е51:гіп§(5)) # знайти р в з ОДИН раз 
#['Ьеііо', 'могісі', '!'] 

рг ігтЬ (р. раг5е51:гіп§(5) .а5І_І5І:()[0]) 

#ііеііо 
ехсері:: разз 

■Рог х іп 1лІогсі(а1рІіа5).5еагсЬ51:гіп§(5): # знайти УСІ 

слова в з 
ргіїтЦх) 

#['Ьеііо'] 

#[ 'могісі' ] 

ргіп1:(2его0гМоге( ’о" ). 5еагсЬ51:гіп§(5)) # 0 або більше 

#[[ 'о'], [], ['О']] 

ргіп1:(0пе0пМопе( "о" ). 5еагсЬ51:гіп§(5)) # 1 або більше 

#[['о'], ['о']] 

ге5 = [х -Рог х іп ОпеОпМоге( ’о" ). 5сап51:гіп§(5) ] 
ргіп1:(ге5 [0]) # кортеж 
#((['о'], {}), 4, 5) 

р=І_і1:ега1( 1 Ьеііо ) л І_і1:ега1( июгІсГ ) # або 'ііеііо' або 

'могісі' 

# або р=Ог([іііегаі( 'ііеііо '), іііегаі( 'могісі')]) 

ргіп1:(р. раг2е51:гіп§( "іл/огІсГ )) 

#[ 'могісі'] 


251 




р=І_і1:ега1("\л/ог1сІ") | І_і1:ега1( "Неііо" ) # знайти перше 
могід або ііеііо 

# або МаісііРігзі( [ іііегаі( "могісі"), іііегаі( "ііеііо")]) 

ргіїтЦр. рагзе51:гіп§(5)) 

#['ііеііо'] 

р=1_і1:ега1( "ілюгісі" )&І_і1:ега1( "Неііо" ) # як +, але не 
послідовно, а в довільному порядку 

# або р=ЕасИ([іііегаі("могід"), іііегаі("ііеііо") ] ) 

ргіпі:(р. рагзе51:гіп§(5)) 

#[ 'Ьеііо', 'могід'] 

# літерал і слово (якщо є ; але без нього) 

р=І_і1:ега1( 'Неііо )+0р1:іопа1(5иррге5 5(ІлІоггі(а1рНа5))) 
ргі пі: (р. рапзе51:гіп§(5)) # без другого слова 

#[ 1 ііеііо 1 ] 

сіе-р "Рп(5^ Іос., Ііокз): 
ргіп1:(5^ Іос, іокз) 

р=1л/опсі(аїрИаз).5е1:Раг5еАс1:іоп(-( : п)+1лІогсІ(аІрНаз) # 

викликає функцію /п для першого слова 

р. раг5е51:гіп§(5) 

#ііеііо могід! 0 ['ііеііо'] 

р=1л/опсі(аїрИаз). зе1:Ке5и11:5№те( "іл/огсії" )+1лІогсІ (аІрНазн-' ! 

') # у виразі задано ім'я для першого слова 

ргі пі (р. рагзе51:гіп§(5) .июгсЛ) 

#ііеііо 

р=І_і1:ега1("Не11о' ). зе1:Раг5еАс-1:іоп(гер1асеІлІі1:Н( Ні' )) 
ргіпі(р.ігап5-Рогт51:гіп§(5)) # заміна ііеііо на Ні 

#ііі могід! 

а1рНазІІА= 1 АБВГҐДЕЄЖЗИІЇЙКЛМНОПРСТУФХЦЧШЩЬЮЯабвгґдеєжз 
иіїйклмнопрстуфхцчшщьюя 1 


252 




а1рба5КІІ= ' АБВГ ДЕЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЬІЬЗЮЯабвгдеежзи 
йклмнопрстуфхцчшщььіьзюя' 

ргіп1:(ІлІогсІ(а1ркіазІІА). рагзе51:гіп§( "привіт могісі!" ) [0]) 

#привіт 

# іменовані регулярні вирази 

ргіп1:(Ке§ех(г"Ье11о 
(?Р<пате>. *)' ). раг5е51:гіп§(5). пате) 

# і ліогісі! 


ргіп1:(5кірТо( Ш:епа1( "іл/огісі" )). рап5е51:гіп§(5)) # все 

що до літералу "могісі" 

#['беііо ’] 

р=СотЬіпе(1лІогсІ(а1рЬа5) + Ш:епа1( ”) +\ліо псі(аіріпаз)) # 

об'єднати 

ргіпіЦр. рапзеБігіп§(з)) 

#['їіеііо могід'] 


VI = ІлІогсЦпитз) 

р = Ропл/агсІ() # попередня декларація 

р << ( [ , +ОпеОгМоге(Єгоир(р) л іл/) + ' ]' ) # рекурсія 
ргіпі(р. рагзе51:гіп§( [1 2 [3 4]]')) 

#ГГ, Ч', '2', '3' , '4', •]•], ']'] 


рутогрЬу2 - морфологічний аналізатор 

рутогрЬу2 (НПр.ч://«і[ЬиЬ.сот/ктікс/рутогрЬу2) 

морфологічний аналізатор для російської і української мови. 
Повертає граматичну інформацію про слово (число, рід, відмінок, 
частина мови і т.д.), приводить слово до нормальної форми, ставить 
слово в потрібну форму. Використовує словник орепсогроґа.оґіт 
Для незнайомих слів будуються гіпотези. Дивись також йіЬТК 
(\\’\\’\\'.пЙк.ог§) - пакет для обробки природної мови. Ці пакети 
широко застосувуються в галузі штучного інтелекту. 


253 





ітрогі: рутогрЬу2 

тогрЬ = рутогрНу2.МопрИАпа1у2Єп() # об'єкт для 

морфологічного аналізу 

рр=тогрЬ.раг5е(и' уменьшить' ) # виконати аналіз слова 
р=рр[0] # перший варіант слова 
1:=р.1:а£ # набір грамем слова 
ргіпі: 1:. РОБ # частина мови 

#див. також і.іепзе (час), і.сазе (відмінок), 
і.депдег (рід), і.питЬег (число), і.тоод (спосіб 
дієслова), і.стан (моісе) та ін. 
п=р. погшаїігесі # нормальна форма 
ргіпі: п.іл/огсі 

ргіпі: п. іігР1ес1:({ ' \/ЕКВ' , ' Зрег ' , ' -Риііг' }) .и/опсі # 

перевести слово в іншу форму 

■Рог х іп р.іехете: # лексема (різні форми слова) 

рпіпі: х.июгсі , 


INРN 

уменьшить 

уменьшит 

уменьшить уменьшил уменьшила уменьшило . . . 


ру§тепІ8 - підсвітка синтаксису 

Підсвітка синтаксису - це виділення синтаксичних конструкцій 
тексту за допомогою різних шрифтів, їх кольорів і написань. 
Використовується для спрощення сприйняття тексту. Підсвітка 
синтаксису виконується за допомогою лексичного аналізатора, який 
визначає окремі лексеми (послідовність символів, що має певне 
значення). Пакет ру§теп1:з 2.2.0 (Ьир://ру§тепї8.ог§) призначений 
для підсвічування синтаксису, підтримує близько 300 мов, дозволяє 
створювати нові лексичні аналізатори, виводить в багатьох 
форматах (НТМЬ, КТР, ЬаТеХ та ін.), може використовуватись в 
командному рядку або як бібліотека. 


254 



■Ргот ру^тепіз ітрогі: Ріі§Рііі§Рі1: # повертає 

відформатований текст 

■Ргот ру§теп1:5. Іехегз ітрогі: РуіРюпІ-ехег # лексичний 

аналізатор РуіТюп 

■Ргот ру^тепіз .-Рогтаііегз ітрогі: РІітІРогтаііег # для 

форматування у вигляді НТМІ 

сосіе = и'ргіпі: "Неііо Іліогісі" # коментар' # Юнікод (!) 
рядок Руіііоп коду 

ргіпі Іті§Іт1і§ІтІ:(сос)е_, РуіРюпІ-ехе^); Н1:т1Рогта1:1:ег()) 

# повертає проаналізований Руіііопіехег( ) та 
відформатований НітіРогтаііег() текст 

#ргіпі НітіРогтаііег().деі_зіуіе_деф : 5('.ііідіііідііі') # 
повертає текст стилю С55 

# бсе в одному файлі НТМІ 

#ргіпі ЬідЬІіді)1:(соде і Ру±Ьопіехег(), 
НітіРогтаі1:ег(ф : иіі=Тгие) ) 

# все в одному файлі НТМІ окрім стилю. Стиль окремим 
файлом руіііоп. сзз 

#ргіпі ііідіііідіі±(соде> Ру±ііопіехег(), 
НітіРо^таііе^(^ : иіі=Т^ие^ сззф : ііе= 'руіііоп. сзз ')) 

# новий лексичний аналізатор на основі регулярних 
виразів 

■Ргот ру^тепіз.Іехег ітрогі: Ке§ехІ_ехег 
■Ргот ру^тепіз . іокеп ітрогі * 
сіазз МуІ.ехег(Ке§ехІ-Єхег): 

іокепз = {'гоо-р': [ ( г' [ л #] +' ^ Техі), (г ' #. *\п 1 , 
Соттепі),(г '\п.* ' , Техі)]} # послідовність (рег. 
вираз^ токен) 

ргіпі Иі§И1і§И1:(сос)е_, МуЬехегО^ РІітІРогтаііегО) 


255 



<сііу с1а55="Ьі§И1і§ІтІ:"><рпе><5рап></зрап><зрап 
с1азз="к">ргіпі</5рап> <зрап с1азз="з2">&рио1:;Не11о 
Іліогісі&риоі:;</зрап> <зрап с1азз="с1"># коментар</зрап> 
</ргех/сІіу> 

<сі іу с1аз5="Ііі§Н1і§ІтІ:"хргех5рапх/5рап>ргіп1: 
&Яио1:;Не11о Іліогісі&риоі:; <зрап с1азз="с"># 
коментар</зрап> 

</ргех/с!іу> 

ру§тепІз - підсвітка синтаксису в Ткіпіег 

Приклад показує способи підсвітки синтаксису в текстовому 
віджеті Ткіпіег. Техі за допомогою пакету ру§теп1:5. 

■Ргот Ткіпіег ітрогі: * 

Ргот ру§тепРз.Іехегз ітрогі: РуРИопІ-ехег # лексичний 

аналізатор Руібоп 

Ргот ру§тепРз.РогтаРРегз ітрогі РашТокепРогтаРРег 

# РамТокепГогтаііег - для форматування у "сирому" 
вигляді: тип токена<ТАВ>герг(рядок токена)\п 

гооР = Тк() # головне вікно 

РехР = ТехР(гооР, РопР=( 'агіаі , 10^ 'погтаї )) # 

віджет для відображення тексту 
РехР.раск() # розташувати 

сосіе = и'ргіпР "Неііо" # коментар' # рядок Руікоп 
коду 

РехР.іпзегР( "епсі", сосіе) # вставити текст в текстовий 
віджет 

# конфігурувати теги текстового віджету 

РехР. Ра§_сопРі§иге ( "Токеп. КеушогсІ " , 

Роге§гоипсІ= ' Ьіие , РопР=( ' агіаі ' , 10, ' Ьоісі )) 
РехР.Ра§_сопРі§иге("ТоІ<еп.ТехР , Роге§гоипсІ = ' Ьіаск ' , 
РопР=( ' агіаі ' , 10, 'погтаї')) 


256 





іехі: .1:а§_соп-Рі§иге( "Токеп. Иіегаї. 51:гіп§' , 
■Ропе§гоипсІ= , гесІ \, Топі:=( ' агіаі , 10^ ’поптаї )) 

Ііехі:. 1:а§_соп-Рі§иге ( "Токеп. Соттепі :" , 

Тоге§гоипсІ= ' сІагк§гееп' , Топ1;=( 'апіаі' , 10, ' погтаї')) 

сосіе = 1:ех'1:.§еі:("1. 0 " , "епс)-1с") # отримати текст з 
текстового віджету 

їех'Е.сІе1е'Ее("1.0", "епсі") # видалити весь текст з 
текстового віджету 

# перший спосіб: 

■Ргот ру§теп1:5 ітрогі Ьі§И1і§ІгІ: # повертає 
відформатований текст 

■Рог Ііпе іп Ьі§Іі1і§ІтІ:(сос)е, РуіНопІ-ехег ^), 
Каіл/ТокепРогта1:1:ег()). зрііі:( "\п" ): # для кожного рядка 
тексту, відформатованого за допомогою Руікопіехег() 
та РамТокепРогтаііег() 

раіг=1іпе.зр1і1:("\1:") # розділити рядок символом 
табуляції 

і-р раіг! = [’’]: # якщо пара не пуста 

(іокеп, з) = раіг 

ргіпі іокеп, еуаі(з) # вивести на консоль 
іехі. іпзеп1:( "епсі", еуаі(з), іокеп) # вставити 

текст з тегом в віджет 

# другий спосіб: 

#^гот рудтепіз ітрогі іех # лексичний аналізатор, 
повертає ітератор токенів 

#^ог іокеп, сопіепі іп іех(собе, РуіЬопіехег()): 

# ргіпі іокеп, сопіепі 

# іехі.іпзегіС'епд", сопіепі, зіг(іокеп)) 
пооі.таіпІоорО # головний цикл програми 


257 





7^1к -ІПІ Х| 

ргіпі "ИеІІо" # коментар 


Рисунок 60 - Вікно програми 

ІхтІ - простий і швидкий парсинг ХМЬ і НТМЬ 

Іхті 4.1.0 (Ннр://1хт1.с1е) - це РуїЬоп-бібліотека для обробки 
ХМЬ і НТМЬ, яка є прив’язкою до С бібліотек 1іЬхш12 і ІІЬххІГ 
Володіє повною підтримкою ХМЬ, є швидкою і зручною у 
використанні, сумісна з ЕІетепіТгее АРІ. В прикладі розглядається 
використання НТМЬРагзег та храіЬ для отримання ключових слів 
некоректного НТМЬ документу з тегу теїа. ХРаіЬ (ХМЬ Ра(Ь 
Ьап§иа§е) - це мова запитів до елементів ХМЬ документа. 

Ргот 5ігіп§10 ітрогі 5ігіп§10 

Ргот Іхті ітрогі: еіігее 

Ьгокеп_Ьіт1=г" " "<Ьіт1><ЬеасІ> 

стеїіа сопіепі="РуіІ-юп, ХМІ." пате="кеу\л/огсІ5" /> 

<Ьеасі>""" # некоректний документ Н7Ж 

рагзег=еігее. НТМІ-Раг5ег() 

ігее=еігее.раг5е(5ігіп§ІО(Ьгокеп_Ьіт1); рагзег) # 

парсинг 

гооі=ігее.§еігооі() # кореневий елемент (біті) 
ез=гооі. -Ріпсіаіі( ' ЬеасІ/теіа ' ) # знайти усі теги теіа 

Рог е іп ез: 

ІР 'пате' іп е.аіігіЬ апсі ’сопіепі' іп е.аіігіЬ: 

# якщо є такі атрибути 

ІР е. аіігіЬ[ ' пате' ]=="І<еу\л/опсІз" : 
ргіпі е.аіігіЬ[' сопіепі' ] 

# або за допомогою мови запитів храіб: 

ез=ігее. храіЬ( "Ьеасі/теіа[@пате=' кеуїл/огсіз 1 ]/@соп1:еп1:" ) 
ез=ігее.храіЬ("сЬі1сІ: :НеасІ/сРііІсі: :теіа[аіігіЬиіе: :пат 


258 








е=' кеушогсіз ' ]/а1:1:піЬи1:е:: сопіепі:" ) # або повний 
синтаксис храїіі 

ргіпі ез[0] 


РуІІіоп, ХМІ_ 
РуІІіоп, ХМ1_ 


Іхті - Х8ЬТ трансформації 

Х8ЬТ (еХіепзіЬІе ЗіуІекЬееІ Ьап§иа§е Тгапзібгтаіїопз) - це мова 
перетворення ХМЬ-документів. В прикладі за допомогою Іхті до 
початкового документа ХМЬ застосовується таблиця стилів Х8ЬТ і 
отримується перетворений документ ХМЬ. Правила вибору даних з 
початкового документу створюються мовою запитів ХРаіЬ. 

■Ргот Іхті ітрогі еігее 
■Ргот 51:гіп§10 ітрогі 51гіп§10 
Х5І1:_гоо1: = еІгее.ХМЦ ' ' \ 

<хз1:5І:уІезИееІ: уєг5Іоп="1.0" 

хтіпз: хз1=" РгЬІір: //ммм.мЗ . ог§/1999/Х8І./Тгап5-Рогт" > 

<хз1:1етр1а1:е та1:сЬ="/"> 

<-Роо><хз1:уаіие-о-р 5ЄІес1="/а/Ь/1:ех1:()" 

/х/-Роо> 

</хз1:1етр1а1:е> 

</хз1:зіуіезріееііх' ' ') # таблиця стилів Х5ІТ 

Ігапз-Рогт = е1гее.Х5І-Т(х5І1:_гоо1:) # функція 

трансформації 

■р = 51гіп§10( ' <ахЬ>Тех1</Ьх/а>' ) # документ для 
трансформації 

бос = еігее. рагзе(-Р) # парсинг документа 
ргіпі: 1гап5-Рогт(сІос) # трансформований документ 


<?хт1 уєг5іоп="1.0"?> 
<-Роо>Тех1:</-Роо> 


259 






ВоМІе - легкий ДУ8СІ веб-фреймворк 

ВоНІс (ЬЦр://ЬоШеру.ог§) - це швидкий, простий і легкий Ш8СІ 
мікро веб-фреймворк для РуїЬоп. Він розповсюджується як один 
файловий модуль і не має ніяких залежностей крім стандартної 
бібліотеки РуіЬоп. Містить вбудований сервер і підтримує інші 
високопродуктивні ЛУ80І сервери. В прикладі використано стару 
версію ВоНІс 0.5.8, яка працює навіть на РуїЬопСЕ. Для тестування 
прикладу запустіть модуль і введіть в адресному рядку браузера 
один з ІЖІ., наведених нижче. 

-Ргот ЬоЕЕІе ітрогі: гоиііе., гип, гериезії; зепсІ_-Рі1е, 
1лІ5СІКеР5егуег 

# декоратор гоиіе() пов'язує функцію Ьеііо_шгід з 
іІЕі-адресами 

@гои1:е( ' / ' ) # Тііір://іосаіНозі:8080/ 

@гои1:е( '/іпбех. Ьііті' ) # 

біір://іосаНюзі: 8080/іпдех. біті 

сіе-р Ие11о_и/оп1сІ(): 

геїіигп ' <Ь2>Не11о Іліогісі! </Ь2> ' # повертає біті 
відповідь сервера 

# тут :пате означає будь-який текст. Також можна 
використовувати регулярні вирази 

@гои1:е( '/Ьеііо/: пате ) # 

іііір: //ІосаНюзі: 8080/ЬеІІо/ЗоЬп 

сіе-р Ие11о_иг1(пате): 

ге-Ьигп ' Неііо %з! ' % пате 

# отримання СЕТ параметра 
@гои1е( '/Ьеііо' ) # 

іііір://іосаібозі:8080/і)еіІо?пате=Зоііп 

сіе-р Ие11о_§еі:(): 

пате = геяие5І:.СЕТ[ ' пате ' ] # отримати параметр 

пате 


260 





геїигп 'Неііо %з! ' % пате 


# Ніті-форма 

@гои1:е( '/-Рогт' ) # йіір://іосаіііозі:8080/^огт 
сіе-р -Рогт(): 

геїигп """<-Ропт ас1:іоп="/есІі1:" теі:ИосІ="роз1:"> 
ІІзег: <іпри1: 1:уре="1:ех1:" пате="изег"> 

Раззіл/огсІ: <іприї: 1:уре="ра55\л/огсГ пате="ра55\л/огсГ > 
<р>Тех1:<Вг><1:ех1:агеа пате="1:ех'1:" >ЗоЬп</1:ех1:агеа></р> 
сіприї: 1:уре="5иЬті1:" уа1ие="5иЬті1:" /></-Рогт>""" 

# відповідь після натиску кнопки зиЬтіі на форт 

@гои1:е( '/есШ:' те1:ЬосІ= ' Р05Т' ) 
сіе-р Не11о_роз1:(): 

изег = геяиезі:. Р05Т[ ' изег' ] # значення поля изег 
раззіл/огсІ = гериезі:. Р05Т[' раззиюгсГ ] # значення 
поля раз змогд 

изегз={ ' асітіп' : ' 111' } # словник з парами 
користувач:пароль 

і-р изег іп изепз апсі разз\л/огсІ==и5ег5 [изег]: # 

якщо користувач і пароль коректні 

їехі: = гериезі:. Р05Т[' Ііехі:' ] # значення поля 

іехі 

ге-Ьигп ’НеІІо %з! ' % Ііехі: 
еізе: 

геїіигп "І.О£Іп -Раііесі" # помилка входу 

# відсилання статичних файлів (I^1:т^ ^ дрд, рпд та ін.) 
@гои1:е( 1 / :-Рі1епате#. *#' ) # 

йіір://іосаііюзі::8080/зіаііс. віті 
віір://іосаНюзі: 8080/ріс. рпд 

сіе-р 5І:а1:іс_-Рі1е(-Рі1епате): 

зепсІ_-Рі1е(-Рі1епате^ гоо1:=' ) # гооі - шлях до 

статичних файлів 


261 




гип(5егуег=1л15<3іке-р5егуеі% Ьоз1;=' ІосаІИозІ:' 
рог1:=8080) # стартувати Іііір сервер 


127.0.0.1 - - [02/Аи§/2018 
200 21 

127.0.0.1 - - [02/Аи§/2018 
НТТР/1.1" 200 21 
127.0.0.1 - - [02/Аи§/2018 
НТТР/1.1" 200 11 
127.0.0.1 - - [02/Аи§/2018 
=1оЬп НТТР/1.1" 200 11 
127.0.0.1 - - [02/Аи§/2018 
1 . 1 " 200 222 

127.0.0.1 - - [02/Аи§/2018 
/ 1 . 1 " 200 11 

127.0.0.1 - - [02/Аи§/2018 
1 НТТР/1.1" 200 77 
127.0.0.1 - - [02/Аи§/2018 
ТР/1.1" 200 75 


14:28:48] 

14:29:06] 

14:29:20] 

14:29:33] 

14:30:12] 

14:30:42] 

14:31:11] 

14:31:11] 


"СЕТ / НТТР/1.1" 
"СЕТ /іпсіех.ИТтІ 
"СЕТ /ЬеІІо/ЗоЬп 
"СЕТ /ЬеІІоРпате 
"СЕТ /Тогт НТТР/ 
"Р05Т /есііі: НТТР 
"СЕТ /зігабіс. Иі:т 
"СЕТ /ріс.рп§ НТ 


<-)-> С 


® ІосаІНо5І:8080/1огт 


Іі$ег: [асітіп 


РаззілогсІ: 


Техї 

СГоЬп 


Л. 


5иЬті{ | 

Рисунок 61 - НТМЬ-форма в браузері 


262 














РОЗДІЛ 3. ЗАДАЧІ 


1. Створити програму для обчислення значення функції Дх), якщо 
і= 1 (рис.). Значення аргументу в програму передається з командного 
рядка. 


/О) = 


І + X 
іх + 2,5і 


+ соз 1+1 




Рисунок 62 - Графік функції Дх) 

2. Створити програму для обчислення значення функції §(х), якщо 
я=-0,5; Ь- 0,5. 

! 0, х < а 

/(х), а < х < Ь 

х, х > Ь 

3. Розв’язати попередню задачу з використанням підпрограми- 
функції, яка повертає значення §(х). 

4 . Створити програму для виведення списку значень функції Дх), 
якщо х змінюється від -1 до 1 з кроком 0,1. Використати оператори 
циклу Гоп або \л/Иі1е. 

г 1 

5. Знайти наближене значення інтегралу )_ 1 /(х)сіх з кроком 
інтегрування 0,1. Використати оператори циклу Гоп або іл/Ьі1е. 

6. Визначте тривалість обчислення значення функції Дх) і її 
інтегралу на вашому комп’ютері. 

7. Знайти мінімальне і максимальне значення функції Дх) на 
проміжку [-1, 1], якщо крок х рівний 0,1. Використати оператори 
циклу і умови. 

8. Знайти корінь рівняння Дх)-1 на проміжку [-1,1], якщо крок х 
рівний 0,1. Використати оператори циклу і умови. 

263 




9. Розв’язати попередні задачі з використанням списків і функцій 
5шп, тіп, тах, зогїесі. Вивести списки, їх перше і останнє 
значення, довжини списків. Знайти значення аргумента аг§тіп та 
агатах. 

10. Створити словник, ключами якого є елементи кортежа (-1,0, 1), 
а значеннями - відповідні значення функції Дх). Вивести усі ключі і 
значення. 

11. Створити довільний рядок. За допомогою операторів циклу і 
умови замінити задані символи (або слова) в рядку на інші. 
Розв’язати цю ж задачу за допомогою методу геріасе. 

12. Створити довільний рядок. За допомогою операторів циклу і 
умови замінити текст в дужках на три крапки (...). Розв’язати цю 
ж задачу за допомогою модуля ге. 

13. Дано множини А={1,2,3,4} і В={3,4,5,6}. Знайти об’єднання, 


перетин, різницю і симетричну різницю цих множин. 

14. Створити рекурсивну функцію Дх,п), де п - додатне ціле число: 

( х 2 , п = 0 


/(х,п) = ( 


1/(х 2 , п — 1), п А 0. 

15. Створити генератор для утворення послідовності х 1 , х 2 , х 3 , х 4 . 

16. Записати у текстовий файл значення аргументу х і функції Дх), 
якщо х змінюється від -1 до 1 з кроком 0,1. Виконати пошук у 
створеному файлі значення /(0). 

17. Розв’язати попередню задачу з використанням модуля С5V. 

18. За допомогою модуля ріскіе записати у бінарний файл списки 
значень аргументу х і функції Дх). Виконати пошук у створеному 
файлі значення ДО). 

19. Створити клас, який містить коструктор, атрибути-дані хтіп, 
хтах, сіх і атрибути-методи/(х), Х(), Р(), які, відповідно, повертають 
значення функції, список значень аргумента х, список значень 
функції Дх). Створити об’єкти класу. 

20. Створити клас шляхом успадкування класу з попередньої задачі, 


який додатково містить методи, що повертають значення похідної 
/ , (х 0 ) = Д/(х 0 )/Дх»(/(х 0 +Лх)-/(х 0 ))/Ах і інтегралу 


264 



Х 0 П 

Р(х 0 ) = | /(х)сіх » У /(х,)Ах в заданій точці х 0 , де п = (х 0 — 

Чпіп і=1 

х тіп)/^ х - 

21. Створити модуль і пакет з класом з попередньої задачі. 
Імпортувати модуль і створити об’єкти класу. 

22. Створити клас, який описує поняття вектора {а 1 , а 2 , а 3 } і містить 
функції для обчислення його довжини д [сії +0.1 +а] , додавання 

двох векторів с і =а і +Ь і (перевантажити _асісі_), скалярного 

з 

множення с = /а і Ь і (перевантажити_тиі_) і векторного 

;=і 

множення: 

сі 7 ■ — сіу • Із*) 

с = ахЬ = <а і -Ь 1 -а 1 -Ь 3 >. 
а х ■Ь 2 -а 2 -Ь 1 

23. Розв’язати попередню задачу шляхом створення класу- 
контейнера. 

24. Дослідити структуру довільного класу і об’єктів за допомогою 
функцій 1:уре(), сііг(), уагз(), §е1:а1:1:г(), методів 

_зігео-р (), _5иЬс1а55Є5 (), атрибутів _сі і сі: , 

_сіос_, _Ьазез_ та модуля іпзресі:. 

25. Створити і використати декоратор, що повертає похідну функції 
І'(х) заданого порядку. Підказка: для першого порядку декоратор 
повинен повертати нову функцію -р_=1атЬсІа х: (Р(х+0.001)- 
"Р(X) )/0.001. 

26. Обчислити декартів добуток множин {1,2,3}, {4,5,6} з 

використанням оператора Роп. Перевірити результат функцією 
ргосіисі: модуля іііегіїооіз. 

27. За допомогою функцій модуля іРєгіюоіз отримати усі 
можливі комбінації і розміщення елементів множини {1, 2, 3} по 2 
елементи. 


265 



28. Яка дата полупиться, якщо від дати 2019-01-02 02:17:01 відняти 
Іеб секунд? Який це день тижня? 

29. Дано рядок, який містить підрядки <ключ>=<значення>. 
Зберегти усі ключі і значення у базу даних. Прочитати з бази даних 
значення за заданим ключем. Використати модулі апусІЬт або 
5ЯІІІІЄЗ. 

30. Зберегти у текстовий файл список елементів поточного каталогу 
і вкладених каталогів. Створити гір-архів з цим файлом і Іаг-архів з 
поточним каталогом. Визначити розмір цих архівів в байтах. 
Створити новий каталог і скопіювати в нього ці файли. 

31. Розв’язати задачу про пошук мінімуму/максимуму функції 
шляхом поділу області пошуку на дві частини і розпаралелювання 
пошуку на два процеси. Використати модуль зиЬргосезз. 

32. Розв’язати попередню задачу шляхом використання модуля 
ти1і:іргосе55Іп§. 

33. Розв’язати попередню задачу шляхом використання 

сопсиггепі: .РиІіигеБ. 

34. Розв’язати попередню задачу шляхом використання сі а з І<. 

35. Розв’язати попередню задачу шляхом виконання одного процесу 
на локальній машині, а другого - на віддаленій. Використати 
модуль зоскеі: або 5оскеі:5епуеп. 

36. Розв’язати попередню задачу шляхом використання 

сіаз к. сіізі: гіЬиІіесІ. 

37. Розробити веб-програму для обчислення значення функції Дх). 
Використати ССІНТТРБєгуєг . 

38. Розробити веб-програму для обчислення значення функції Дх). 
Використати стандартну \л/5§ігеР. 5ітр1е_5егуег абоЬо1:1:1е. 

39. Створити програму, яка отримує дані від веб-сервера (дивись 
попередні задачі). Використати модулі иг11іЬ2 та НТМІ-Рагзег. 

40. Створити програму, яка записує значення функції/(-у) у ХМЬ- 

документ в такому вигляді: <роіпі:><х>0.1</хху>- 

1.25</ух/роіп1:>. Використати хті. сіот. тіпісіот. 

41. Створити програму, яка шукає в ХМЬ-документі з попередньої 
задачі значення у>0. Використати хті. еіігее. ЕІетепІіТпее або 
Іхті. 


266 



42. Розробити програму з графічним інтерфейсом Ткіпіег, яка 
виводить на вікно документ ХМЬ з підсвічуванням синтаксису. 
Використати ру§теп1:5. 

43. Розробити програму з графічним інтерфейсом Ткіпіег для 
виведення значення функції Дх). Передбачити обробку виняткових 
ситуацій, які виникають під час введення недопустимих значень 
аргументу. 

44. Розробити програму з графічним інтерфейсом Ткіпіег для 
виведення списку значень функції Дх). Використати такі класи як 
Виккоп, І_аЬе1, Епкгу, СЬескЬикІюп, КасІіоЬи1:1:оп, ИзїЬох. 

45. Розробити програму з графічним інтерфейсом РуС)і4 або РуЗісІс 
для попередніх задач. 

46. Розробити бібліотеку ОЬЬ мовою С з функцією, що повертає 
список значень функції Дх). Викликати цю функцію з модуля 
РуїЬоп. 

47. Розробити РуїЬоп-модуль розширення мовою С++, який 
повертає список значень функції Д(х). 

48. Створити масив значень функції Дх) за допомогою питру. 
Побудувати графік функції за допомогою такрІокІіЬ. 

49. Розв’язати задачі про пошук коренів рівняння Дх)=1, мінімуму 
функції Дх) і її інтегралу з використанням функцій питру. 

50. Розв’язати систему лінійних рівнянь за допомогою 
питру.1іпа1§: 

І а + Ь + с = 4, 

2а — Ь + 2с = 2, 
а + 2Ь — с = 4. 

51. Згенерувати випадкову вибірку з нормального розподілу (//=20, 
а=2, ЇУ=1000). Обчислити емпіричні середнє значення та 

середньоквадратичне відхилення. 

52. Дано поліном Зх 2 — 5х + 2. За допомогою методів класу 
питру. роїуїсі обчислити значення полінома, його похідної і 
первісної в точці х=5. 

53. За допомогою зсіру-функцій сіі-рр та ситіїгарг побудувати 
графіки похідної і первісної функції Дх). 

54. За допомогою зсіру обчислити визначений інтеграл ]_ 1 /(х)с(х. 


267 



55. Розв’язати систему диференціальних рівнянь з початковими 
умовами х = 2, х' = 1: 

сіх 

~&і =Х ’ 

сіх' 


сіі 


= —х. 


56. Дано дискретний набір значень х = [0, 1, 2, 3], у = [0, 1, 4, 9]. 
Обчислити значення у для х=2,5 шляхом лінійної інтерполяції і 
інтерполяції квадратичним сплайном. 

57. За допомогою зсіру.оріітіїе.Р зоіує роз’язати рівняння 
х 2 — 2х — 2 = 0. 

58. За допомогою зсіру. оріітіїе. гооі: роз’язати систему 
нелінійних рівнянь 

х 2 + 2 у = 0, 
х + у 2 = 1. 

59. За допомогою зсіру. оріітіге. сііпує_-Рі 1: знайти регресію 
виду /(х) = ах 2 + Ьх + с за даними х, у (табл.). Знайти коефіцієнт 
детермінації К 2 . 

Таблиця 2 - Е мпіричні дані - зале жність у від х 


X 

0 

1 

2 

3 

У 

0 

1 

4 

10 


60. За допомогою зсіру. оріітіїе. сипуе_-Ріі: знайти регресію 
виду /(х, у) = а + Ьх 2 + сх + сіу 2 + еу + /ху за даними х, у, і 
(табл.) Знайти коефіцієнт детермінації К 2 . 

Таблиця 3 - Е мпіричні дані - залежн ість г від х і у 


У\ 

1 

2 

3 

4 

1 

0 

0 

1 

4 

2 

0 

1 

4 

8 

3 

1 

4 

8 

10 

4 

4 

8 

10 

20 


61. Знайти мінімум функції Дх) в межах [-1, 1] за допомогою 
зсіру.оріїітіге. Спробуйте різні методи оптимізацїї. Визначте 
тривалість обчислень для кожного методу. 


268 




62. Дано випадкову величину з нормальним розподілом (//=20, о=2). 
Знайти імовірність попадання значень в інтервал (15, 25). Знайти 
квантілі з рівнем 0,1 і 0,9. 

63. Дано випадкову величину з нормальним розподілом (//=20, о=2). 
Згенерувати з неї вибірку розміром 100 значень. Візуально 
порівняти гістограму вибірки і функцію густини цього розподілу. 

64. За допомогою дискретного перетворення Фур'є розрахувати 
спектр частот для сигналу 

2 СОй(37 ті) + СОз(57Г/) + С05(97Г£). 

65. За результатами попередньої задачі і за допомогою оберненого 
дискретного перетворення Фур’є отримати відфільтрований сигнал 
з частотами, які більші 7. 


66. Обчислити центроїди двох кластерів за даними: 


X 

5 

5 

4 

6 

4 

4 

5 

6 

6 

4 

0 

0 

1 

0 

1 

1 

0 

2 

2 

1 

У 

5 

4 

3 

6 

5 

4 

4 

4 

5 

5 

1 

0 

0 

2 

1 

2 

1 

1 

0 

1 


67. За допомогою хімі: створити в Ехсеї наступну таблицю: 


А 

В 

1 

2 

2 


3 

-1 

4 

3 

5 

6 


68. Виконати попередню задачу з використанням 
\л/іп32сот. сііепі: і Ехсеї. 

69. Зберегти попередню таблицю як файл С8У. За допомогою 
рапсіаз прочитати цей файл і створити об’єкт ОаііаРпате. 
Відкинути рядки з відсутніми даними та з даними В< 0. Створити 
новий стовпчик С з сумою А+В. Конвертувати стовпчики А і В в 
питру. псіаггау. 

70. Дано два класи 0 і 1 з ознаками х і у: 


X 

5 

5 

4 

6 

4 

4 

5 

6 

6 

4 

0 

0 

1 

0 

1 

1 

0 

2 

2 

1 

У 

5 

4 

3 

6 

5 

4 

4 

4 

5 

5 

1 

0 

0 

2 

1 

2 

1 

1 

0 

1 

Клас 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

1 

1 

1 

1 

1 

1 

1 

1 

1 

1 


За допомогою зсікії-іеат визначити клас точки л-5. у= 6. 


269 






71. Дано граф, заданий вершинами 1, 2, 3, 4 і ребрами (1,2), (2, 3), 
(2, 4), (3, 4). Знайти найкоротший шлях між вузлами 1, 4. 

72. Дано предикат "причина" та факти "А причина В", "В причина С", 
"А причина О". Задано правило логічного виведення "якщо X 
причина У, то У наслідок X". Знайти усі наслідки А. Використати 
ру0а1:а1о§ або капгеп або зв’язок з інтерпретатором Рго1о§. 

73. Дано змінну а з множиною допустимих значень {1, 3, 5, 7, 9} та 
змінну Ь з множиною допустимих значень {0, 2, 4, 6, 8}. За 
допомогою руСІїоп-сопзСгаіпІ: знайти усі розв’язки задачі 
а+Ь> 10. 

74. За допомогою РІЬ відкрити будь-яке зображення, повернути 
його на 90 градусів вправо і зберегти в відтінках сірого. За 
допомогою іта§е.§е1:ріхе1( (х,у )) визначити колір 
центрального пікселя. 

75. За допомогою руОрепСІ- або ру§1еі: створити тривимірну 
сцену з трьома кубами, які розташовані рядом і повернуті на різні 
кути. 

76. За допомогою руїЬопОСС або РпееСАР створити тривимірне 
тіло шляхом об’єднання призми і сфери. Обчислити об’єм тіла. 

77. Створити макрос для АЬациз/САЕ для обчислення напружень в 
осесиметричній моделі циліндричного тіла. 

78. Дано вираз х 2 + зіп 2 х + соз 2 х — 2. За допомогою БутРу 
виконати підстановку х = (х + І) 2 , спростити вираз, отримати 
похідну і первісну в символьному виді. Обчислити значення виразу, 
похідної та первісної для х=2. 

79. За допомогою БутРу розв’язати в символьному виді рівняння 
відносно х 

х 2 + 2х — а = 0. 

80. За допомогою БутРу розв’язати в символьному виді систему 
рівнянь відносно х,у 

ах — Зу = 2, 
х + 2у = 0. 

81. За допомогою зутру. сізоіує розв’язати систему 
диференціальних рівнянь (знайти функції х({), х ’({)) 


270 



СІХ 

~сй = х ’ 
сіх' 

сіі 

82. За допомогою ОМРуЬЬоп та ОрепМосІеІіса розв’язати попереднє 
рівняння з початковими умовами х = 2, х' = 1. 

83. За допомогою \л/іп32сот. сііепі: змінити розміри довільної 
параметричної моделі 80ЬГО\¥(ЖК8 і перебудови її. 

84. За допомогою рузегіаі та ріскіе записати і прочитати 
довільний РуїЬоп-об’єкт через віртуальні послідовні порти. 

85. За допомогою РуРагмп§ розробити синтаксичний аналізатор О- 
коду для верстату з числовим програмним керуванням. Обмежитись 
командами С00 і С01. Наприклад: 

С00 Х0.0 У0.0 20.0 
Є01 Х0.0 VI.0 20.0 


ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ 

1 АІІеп В. □о\¥пеу. ТЬіпк Сотріехіїу. - [8ссс1Ьат. МаззасЬизейз: 
Огееп Теа Рге88, 2011. - 146р. 

2 АІІеп В. Бо^пеу. ТЬіпк 8іаІ8, 8есопсі Ебіїіоп. - О’КеіІІу, 2015. - 
255р. 

3 Агіійсіаі Іп1е11і§епсе \\їіН РуїЬоп / Ргаїеек І 08 Ьі. - Вігтіп§Ьапг: 
Раскі, 2017. - 437р. 

4 А8ЙІ8Ь Китаї - . Ьеаі - піп§ РґссіісОус Апа1у(іс8 \\ ііИ РуїЬоп - Раскі 
РиЬ1І8Ьіп§. 2016. - 493р. 

5 Бои§ Неіітапп. РуїЬоп Мосіиіс о і' іЬе \¥еск [ЕІесЬюпіс ге8оигсе]. - 
Мосіе о і' ассе88: Ь11 р 8: //р у т оі \у . со т/2/ 

6 Н. ВегепсЕеп. А 8іис1спі’8 Оиісіе Іо іїаіа а псі Еггог Апаїузіз. - 
СатЬіїс1§с 11піуег8ІІу Рге88, 2011. - 239р. 


271 



7 Н. ]. С. ВегепсНеп. 8іти1а1іп§ іЬс рЬу8Іса1 \\'ог1с1. НіегагсЬісаІ 
Мобе1іп§ їгот 0 напій т МесЬапіс8 Іо Еіиісі Оупатіс8. - СатЬгісІ§е 
Шіуег8і1у Рге88, 2007. - 626р. 

8 Нап8 Реііег Ьап§1ап§еп. А Ргітег оп 8сіепІійс Рго§гаттіп§ \уііЬ 
РуїЬоп. 5іЬ ЕсІІГІоп. - 8ргіп§ег, 2016. - 942р. 

9 .Іаап Кіи8а1аа8. №ітегіса1 МсіЬоск іп Еп§іпеегіп§ \уііЬ РуїЬоп. - 
2сс1. - СатЬіісфс ІІпіуег8ІІу Рге88, 2010. - 434р. 

10 Іозе 14пріп§со. РуїЬоп йг РгоЬаЬіІіІу, 8іаІІ8Ііс8, апсі МасЬіпе 
Ьсатіп^- - 8ргіп§ег, 2016. - 288р. 

11 Еапсіаи Е. Н. Сотриіаііопаї РЬу8ІС8. РгоЬІет 8о1уіп§ \уііЬ РуїЬоп, 
Згсі сотріеіеіу геуІ8ед есііііоп / КиЬіп Н. Ьапдаи, Мапиеі І. Раег, 
СгІ8Ііап С. Вогсіеіапіі. - \УеіпЬсіт: \¥ІІсу-УСН, 2015. - 647р. 

12 Еиса Ма88агоп. АІЬегІо Во8сЬеІІі. Ке§ге88Іоп Апа1у8І8 \уііЬ РуїЬоп. 
- Раскі РиЬ1І8Ьіп§, 2016. - 416р. 

13 Ргаїік Ос8аі. РуїЬоп Рго§гаттіп§ Іог Агсіиіпо. - Вігтіп§Ьат: Раскі 
РиЬ1І8Ьіп§, 2015. - 576 р. 

14 8сіру Еесіиге N 0108 [Еіесігопіс ге8оигсе]. - Мосіс оі ассе88: 
Ьіір://\у\у\у.8сіру-1есІиге8.ог§/ 

15 8Ьапе ТогЬегІ. Аррііесі Сотриіег 8сіепсе. 8есопсі Есііііоп. - Еаігіах: 
8 ргіп§ег, 2016. - 291р. 

16 8\уагоор С. Н. А Вуїе оі РуїЬоп [Злектронньш ресурс]. Пер. с 
англ. Режим доступа: ЬіІр://\уотЬа1.ог§.иа/АВуІе01РуіЬоп 

17 ТЬотаз На8І\уапІег. Ап Іпігосіисііоп Іо 8іаІІ8Ііс8 \уііЬ РуїЬоп: \¥ііЬ 
Арр1ісаІіоп8 іп іЬе ЬОс 8сіепсе8. - 8ргіп§ег, 2016. -285р. 

18 Андерс М. Написание скриптов для Віепсіег 2.49. Пер. с англ. - 
РАСК, 2010. - 348с. 

19 Бизли Д. РуїЬоп. Подробньїй справочник. - Пер. с англ. - СПб.: 
Символ-Плюс, 2010. - 864 с., ил. 

20 Бринк Хенрик. Машинное обучение / Бринк Хенрик, Ричардс 
Джозеф, Феверолф Марк. -СПб.: Питер, 2017. -336 с. 

21 Буйначев, С. К. Основні программирования на язьіке РуїЬоп: 
учебное пособие / С. К. Буйначев, Н. Ю. Боклаг. - Екатеринбург: 
Изд-во Урал, ун-та, 2014.-91 с. 

22 Буйначев, С. К. Применение численних методов в 
математическом моделировании : учебное пособие / С. К. 


272 



Буйначев. - Екатеринбург: Издательство Уральского 
университета, 2014. - 70. [2] с. 

23 Бхаргава А. Грокаем алгоритми. Иллюстрированное пособие для 
программистов и любопьітствующих. - СПб.: Питер, 2017. - 288 
с.: ил. 

24 Бзрри, Пол. Изучаем программирование на РуїЬоп / Пол Бзрри; 
пер. с англ. — Москва : Издательство «З», 2017. — 624 с. : ил. 

25 Вабищевич П. Н. Численньїе методи: Вичислительний 
практикум / Петр Николаевич Вабищевич. — М.: Книжний дом 
«ЛИБРОКОМ», 2010. — 320 с. 

26 Васильєв А. Н. РуїЬоп на примерах. Практический курс • по 
программированию. - СПб.: Наука и Техника, 2016. - 432 с.: 
ил. 

27 Гифт Н., Джонс Д. РуїЬоп в системном администрировании 
ІЛЧІХ и Біпих - Пер. с англ. - СПб.: Символ-Плюс, 2009. - 512 с, 
ил. 

28 Гойвертс Я., Левитан С., Регулярние вираження. Сборник 
рецептов, 2-е изд. - СПб.: Символ-Плюс, 2015. - 704с. 

29 Грає Дж. Оаіа Бсіепсе. Наука о данньїх с нуля: Пер. с англ. - 
СПб.: БХВ-Петербург, 2017. - 336 с.: ил. 

30 Гринберг М. Разработка веб-приложений с использованием Ріазк 
на язике РуїЬоп. - М.: ДМК Пресе, 2014. - 272 с. 

31 Доля П. Г. Введение в научний РуїЬоп. Харьков: ХНУ, 2016 - 
265с. 

32 Доусон М. Программируем на РуїЬоп. - СПб.:Питер,2014. - 416 
с.: ил. 

33 Карау X., Конвински 3., Венделл П., Захария М. Изучаем Брагк: 
молниеносний анализ данних. - М.: ДМК Пресе, 2015. - 304 с.: 
ил. 

34 Копей, В.Б. Ядро геометричного моделювання Ореп СА8САОЕ 
ТесЬпоІоду для РуїЬоп-програмістів: Методичні вказівки для 
самостійної роботи / В.Б. Копей. - Івано-Франківськ : ІФНТУНГ, 
2017. - 47с. 

35 Луис Педро Козльо, Вилли Ричарт. Построение систем 
машинного обучения на язике РуїЬоп 2-е издание / Пер. с англ. 
Слинкин А. А. - М.: ДМК Пресе, 2016. - 302 с.: ил. 

273 



36 Лутц М. РуЛюп. Карманньїй справочник, 5-е изд.: Пер. с англ. - 
М.: ООО "И.Д.Вильямс", 2015. - 320 с.: ил. 

37 Лутц М. Изучаем РуЛюп, 4-е издание. - Пер. с англ. - СПб.: 
Символ-Плюс, 2011. - 1280 с.: ил. 

38 Лучано Ромальо. РуЛюп. К вершинам мастерства - М.: ДМК 
Пресе, 2016. - 768 с. 

39 Любанович Билл Простой РуЛюп. Современньїй стиль 
программирования. — СПб.: Питер, 2016. —480 с.: ил. 

40 Марк Саммерфилд. РуїЬоп на практике. / Пер. с англ. Слинкин 
А.А. - М.: ДМК Пресе, 2014. - 338 с.: ил. 

41 Марманис X., Бабенко Д. Алгоритмьі интеллектуального 
Интернета. Передовьіе методики сбора, анализаи обработки 
данньїх. - Пер. с англ. - СПб.: Символ-Плюс, 2011. - 480 с., ил. 

42 Мзтиз Зрик Изучаем РуЛюп. Программирование игр, 
визуализация данньїх, вебприложения. — СПб.: Питер, 2017. — 
496 с.: ил. 

43 Мюллер А. Введение в машинное обучение с помощью РуЛюп. 
Руководство для специалистов по работе с данньїми / Андреас 
Мюллер, Сара Гвидо. - Вильямс, 2017. - 480с. 

44 Плас Дж. Вандер. РуЛюп для сложньїх задач: наука о данньїх и 
машинное обучение. — СПб.: Питер, 2018. — 576 с.: ил 

45 Програмування числових методів мовою РуЛюп : навч. посіб. / А. 
Ю. Дорошенко, С. Д. Погорілий, Я. Ю. Дорогий, Є. В. Глушко; 
за ред. А. В. Анісімова. - К. : Видавничо-поліграфічний центр 
"Київський університет", 2013. - 463 с. 

46 Ра ш ка С. РуЛюп и машинное обучение / пер. с англ. А . В . 
Логунова. - М.: ДМКПресс, 2017. - 418 с.: ил. 

47 Рейтц К., Шлюссер Т. Автостопом по РуЛюп. — СПб.: Питер, 
2017. — 336 с.: ил. 

48 Ричардсон, Крзйг. Программируем с Міпесгай. Создай свой мир 
с помощью РуЛюп / Крзйг Ричардсон; пер. с англ. —М.: Мани, 
Иванов и Фербер, 2017. — 368 с.: ил. 

49 Свейгарт, Зл. Автоматизация рутинних задач с помощью РуЛюп: 
ирактическое руководство для начинающих. - М.: Вильямс, 2017. 
- 592с. 


274 



50 Сегаран. Т. Программируем коллективньїй разум. - Пер. с англ. - 
СПб: Символ-Плюс, 2008. - 368 с., ил. 

51 Сейтц Джастин. Программирование на РуіЬоп для хакеров, Пер. 
с англ. 2012. - 208с. 

52 Силен Д. Основні Баїа Зсіепсе и Ві§ Баїа. РуіЬоп и наука о 
данньїх / Силен Дзви, Мейсман Арно, Али Мохамед - СПб.: 
Питер, 2017. - 336с. 

53 Соловьев И. А., Червяков А. В., Репин А. Ю. Вьічислительная 
математика на смартфонах, коммуникаторах и ноутбуках с 
использованием программньїх сред РуїЬоп: Учебное пособие. — 
СПб.: Издательство «Лань», 2011. — 272 с: ил. 

54 У. Сзнд, К. Сзнд. Неііо ЛУогМ! Занимательное 
программирование. — СПб.: Питер, 2016. — 400 с.: ил. 

55 Узс Маккинли. РуіЬоп и анализ данньїх/ Пер. с англ. Слинкин А. 
А. - М.: ДМК Пресе, 2015. - 482 с.: ил. 

56 Федоров Д. Ю. Основні программирования на примере язьїка 
РуіЬоп : учеб.пособие / Д. Ю. Федоров. - СПб., 2016. - 176 с. 

57 Шоу, Зед. Легкий способ вьіучить РуіЬоп / Зед Шоу; пер. с англ. 
— Москва : Издательство «З», 2017. — 352 с. 

58 Язьік программирования РуіЬоп. / Г.Россум, Ф.Л.Дж.Дрейк, 
Д.С.Откидач, М.Задка, М.Левис, С.Монтаро, З.С.Реймонд, 
А.М.Кучлинг, М.-А.Лембург, К.-П.Ии, Д.Ксиллаг, Х.Г.Петрилли, 
Б.А.Варсав, Дж.К.Ахлстром, Дж.Роскинд, Н.Шеменор, 
С.Мулендер. - 2001. - 454с. 


275 



