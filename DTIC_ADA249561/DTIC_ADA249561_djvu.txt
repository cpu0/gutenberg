AD-A249 561 ^ntation page 

•nil nil nil P 1 how p» mpomo. taPdng M tow lor nitoto 


Fom Approved 
OPM No. 0704-0188 


pt hour porioopotoo,lweludho«w tow tor io<toi«il n Qhmctoiw.to Oirtto Q* « l to nQdP«MwetogtoHB9iiWiitontom»wdPo 
BWibi»dtoOPIiiwPor»i|rollpfpoetcHiPeeloclPnelWoni MPo n.lwchitoigiugg Hnn ilofi»todngWihi»dp<.lelKtohl n gBn 
ns JMorton OnP Hl^pny. StJto 12M. Aitvon. VA 222ae-«302. tod 10 tw OKoo el HMiMton and RiguUory AMw. OKm ol 


AND SUBTITLE 

Validation Summary Report: Concurrent Computer Corporation. C3 Ada Version 
t.Ov, Concurrent Computer Corporation 8400 with MIPS R3000 CpU and MIPS 3010 
Floating Point undter RTU Version 5.1 (Host & Target). 901130W1.1109 


6. AUTHOR(S) 

Wright-Patterson AFB, Dayton. OH 
USA 


7. PERFORMING ORGANIZATION NAME(S) AND7L0DRESS(ES) 

Ada Validation Facility. Language Control Facility ASO/SCEL 
Bldg. 676. Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 


9. SPONSORINGA40NITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 


DTI 



PONSORINGAAONITORING AGENCY 
EPORT NUMBER 



12a. DISTRIBUTION/AVAILABILITY STATEM 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 vnrds) 

Concurrent Computer Corporation, C3 Ada Version 1 .Ov, Wright-Patterson AFB, Concun^ent Computer Corporation 8400 
with MIPS R3000 CpU and MIPS 3010 Floating Point undter RTU Version 5.1 (Host & Target), ACVC 1.11. 


/I <>0 OBW 


92-11780 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECU 
OF REPORT 

UNCLASSIFIED 




UNCLASSIFED 


IFICATION 19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


riS. NUMBEH ur rnuw... 



NSN754(M)1-280-550 


Stuidwd Form 298, (Rav. 2-89) 
PrtscrtMd by ANSI SU. 239-128 













Certificate Information 


Bie following Ada inplementation was tested and determined to pass ACVC 
1.11. Testing was ccmpleted on 30 November 1990. 


Coopiler Name and Version: C3 Ada Version l.Ov 

Host Computer System: Concurrent Computer Corporation 8400 with 

MIPS R3000 CPU and MIPS 3010 Floating 
Point xjnder RTO Version 5.1 

Target Computer System: Concurrent Computer Corporation 8400 with 

MIPS R3000 CPU and MIPS 3010 Floating 
Point under RTU Version 5.1 


Customer Agreement Number: 90-10-08-CCC 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
901130W1.11109 is awarded to Concurrent Computer Corporation. This 
certificate expires on 1 June 1993. 

This report has been reviewed and is approved. 


Ada ValidatiOT Facility 
Steven P. Wilson 
Technical Director 
ASD/SCEL 

Wric^t-Patterson AFB CSJ 45433-6503 





Ada y^c^li^ Organization 

Dire^or/JCcmputer & Software Engineering Division 
Institute ter Defense Analyses 
Alexandria VA 22311 


Aira Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 





A c <3 r' - 

*- * i iot)_ 


• j - 


Corfes 
.'ind/or 
Special 


Dlst 


i^\ 







AVF Control Number: AVF-VSR-416.0891 

1 August 1991 
90-10-08-CCC 


Ada COMPILER 
VALIDATiai SUMMARY REPORT: 
Certificate Number: 901130W1.11109 
Concurrent Computer Corporation 
C3 Ada Version l.Ov 

Concurrent Conpater Corporation 8400 with 
MIPS R3000 CPU and MIPS 3010 Floating Point 
under RTU Version 5.1 
(self-targeted) 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 




DECLARATION OF CONFORMANCE 


Customer: Concurrent Computer Corporation 

Ada. Validation Facility: Wright Patterson Air Force Base, Ohio. 
ACVC Version: 1.11 


Ada Implementation: 

C^Ada Version: 1.0v 

Concurrent Computer Corporation 8400 
with MIPS/R3000 CPU and MIPS/3010 
Floating point under RTU Version 5.1 

Same as Host 


Customer’s Declaration 

I, the undersigned, representing Concurrent Computer Corporation, declare that Concurrent 
Computer Corporation has no knowledge of deliberate deviations from the Ada Language 
Standard ANS1/MIL*STD*1815A in the implementation luted in this declaration. I declare that 
Concurrent Computer Corporation is the Implementor of the above implementation and the 
certificates shall be awarded in the name of Concurrent Computer Corporation’s corporate 
name. 


Compiler Name and Version: 
Host Computer System: 

Target Computer System: 


Seetharama Shastry (date) 

Senior Manager, System Software Development 



TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 














CHAFIER 1 


INTRODUCTIC^I 


Bie Ada inplementation described above vas tested according to the Ada 
Validation Procedures tPro90] against the Ada Standard [Ada83] vising the 
current Ada Conpiler Validation Capability (ACVC). This Validation Sumroary 
Report (VSR) gives an account of the testing of this Ada inplementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide (UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordcuice with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the coiqjuters, operating systems, and coinpiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and conplete, or that the subject inplementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 




INTRODUCTIOJ 


1.2 REFERENCES 


[AdaSB] Reference Manual for the Ada Proqranminq Language, 
ANSI/MIL-STD-1815A, FiBruary 1583 and ISO 8652-1987. 

tPro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint Program 
office, August 1990. 

IUG89] Ada Conpiler Validation Capability User^s Guide , 21 Jxjne 1989. 


1.3 ACVC TEST CLASSES 

Conpliance of Ada isplementations is tested by means of the ACVC. Hie ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. Hie first letter of a test name identifies the class 
to vdiich it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat scxne con^jiler 
optimizations allowed the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK__FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. Hie operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a conpiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting coirpilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code vhich must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada inplementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
inplementation-specific values — for exanple, the largest integer, a list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
inplementation-dependent characteristics. Hie modifications required for 
this inplementation are described in section 2.3. 


1-2 





INTRODUCTION 


For each Ada inplementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89)). 

In order to pass an ACVC an Ada inplementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITIOI OF TERMS 


Ada Conpiler The software euid any needed hardware that have to be added 
to a given host and target conpjter system to allow 
transformation of Ada programs into executable form and 
execution thereof. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


The meauis for testing compliance of Ada implementations, 
consisting of the test suite, the support programs, the ACVC 
user's guide and the template for the validation summary 
report. 


Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 


Ada Joint The part of the certification body which provides policy and 
Program guidance for the Ada certification system. 

Office (AJPO) 


Ada The part of the certification body vdiich carries out the 
Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 


Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 


Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more ccmputers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 






INTRODUCTION 


Conformity Fulfillment by a product, process or service of all 

requirements specified. 

CustopT'r An individual or corporate entity who enters into an 

agreement with an AVF \Aiich specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

Declaration of A formal statement from a customer assuring that conformity 
Conformance is realized or attainable on the Ada isplementation for 
which validation status is realized. 

Host Conpjter A conpiter system where Ada source programs are transformed 
System into executable form. 

Inapplicable A test that contains one or more test objectives found to be 
test irreleveuit for the given Ada isplementation. 

ISO International Organization for Standardization. 

LRN The Ada standard, or Language Reference Manual, published as 

ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Operating Software that controls the execution of programs and that 
System provides services such as resource allocation, scheduling, 

input/output control, and data management. Usxially, 
operating systems are predominantly software, but partial or 
conplete hardware isplementations are possible. 

Target A con^ter system vdiere the executable form of Ada programs 

Ccnqxiter are executed. 

System 

Validated Ada The conqpiler of a validated Ada implementation. 

Conpiler 

Validated Ada An Ada inplementation that has been validated successfully 
Inplementation either AVF testing or by registration [Pro90]. 

Validation The process of checking the conformity of an Ada conpiler to 
the Ada programming language and of issuing a certificate 
for this inplementation. 

Withdrawn A test found to be incorrect and not used in conformity 

test testing. A test may be incorrect because it has an invalid 

test objective, fails to meet its test objective, or 
contains erroneous or illegal xise of the Ada programming 
language. 


1-4 




CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Ttie following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 12 October 1990. 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C7430aA 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C83041A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives vAiich are irrelevant 
for a given Ada inplementation. Reasons for ? test's inapplicability may 
be supported by documents issued by ISO and the AJPO known as ^a 
Comnentaries and commonly referenced in the format Al-ddddd. For this 
inplementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are inclxided as 
appropriate. 


2-1 



IMPLEMEmATIQt^ OEPEM>ENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_D1GITS; 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35e02L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


Hie following 21 tests checlc for the predefined type LONG_INTEGER: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B520040 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C35702A, C35713B, C45423B, B86001T, and C86006H chec)c for the predefined 
type SHORT_FLQAT. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG FLOAT, or SHORT FLOAT. 


C41401A checks that CX3NSTRAINT ERROR is raised upon the evaluation of 
various attribute prefixes; thTs implementation derives the attribute 
values from the subtype of the prefix at conpilation time, and thus does 
not evaluate the prefix or raise the exception. (See Section 2.3.) 


C45531M..P (4 tests) and C45532M..P (4 tests) check fixed-point 
operations for types that require a SYSTEM.MAX_MANTISSA of 47 or 
greater. 

C45624A checks that the proper exception is raised if MACHINEjOVERFLCWS 
is FALSE for floating point types with digits 5. For this 
implementation, MACHINEjOVERFLCMS is TRUE. 

C45624B checks that the proper exception is raised if HACHINEJDVERFLCNS 
is FALSE for floating point types with digits 6. For this 
implementation HAOlINEjQVERFLGWS is TRUE. 

C86001F reconpiles package SYSTEM,making package TEXT_IO, and hence 
package REPORT, obsolete. For this implementation the package TEXT_IO 
is dependent i^n package SYSTEM. 


B86001Y checks for a predefined fixed-point type other than DURATION. 


C96005B checks for values of type DURATION'BASE that are outside the 
range of DURATION. There are no such values for this in^ilementation. 


2-2 



IMPLEMENTATION DEPENDENCIES 


CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 

CD2B15B checks that STORAGE ERROR is raised when the storage size 
specified for a collection Ts too small to hold a single value of the 
designated type; this inplementation allocates more space than was 
specified by the length clause, as allowed by AI-00558. 

BD8001A, BD8003A, BD8004A. .B (2 tests), and AD8011A use machine code 
insertions. 

The tests listed in the following table are not applicable because the 
given file operations are not supported for the given combination of 
mode and file access method. 


Test 

File Operation Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT_IO 

CE3102E 

CREATE 

IN_FILE 

TE5Cr_I0 

CE3102F 

CE3102G 

RESET 

DELETE 

Any Mode 

TEXT 10 

TEXT_IO 

CE3102I 

CREATE 

OUT FILE 

TEXT_IO 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT_IO 


CE2107C..D (2 tests), CE2107H, and CE2107L apply function NAME to 
tenporary sequential, direct, and text files in an attempt to associate 
multiple internal files with the same external file; USE_ERROR is raised 
because tenporary files have no name. 

CE2108B, CE2108D, and CE3112B use the names of tenporary sequential, 
direct, and text files that were created in other tests in order to 
check that the tenporary files are not accessible after the completion 
of those tests; for this implementation, tenporary files have no name. 


2-3 



IMPLENENTATICX) DEPENDENCIES 


CE2203A checks that WRITE raises USE__ERROR if the capacity of the 
external file is exceeded for SEQUENTIAL_10. This inplementation does 
not restrict file capacity. 

EE2401D checks vrtiether DIRECT_IO can be instantiated for an element type 
that is an unconstrained array type; this implementation raises 
USE_ERROR on the attenpt to create a file, because the maximum potential 
element size exceeds the inplementation limit of 2**31 - 1 bits. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_lO. Ihis implementation does not 
restrict file capacity. 

CE3111B and CE311SA associate multiple internal text files with the same 
external file and attenpt to read from one file vdiat was written to the 
other, \^ich is assumed to be immediately available; this implementation 
buffers output. (See section 2.3.) 

CE3202A expects that function NAME can be applied to the standard input 
and output files; in this inplementation these files have no names, and 
USE_ERROR is raised. (See section 2.3.) 

CE3304A checks that USE_E2®0R is raised if a call to SET LINE LENGTH or 
SET_PAGE LENGTH specifies a value that is inappropriate Tor tHe external 
fi-’e. TEis inplementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page 
niimber exceeds COUNT'LAST. For this inplementation, the value of 
CXXJNT'LAST is greater than 150000 making the checking of this objective 
impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 12 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the origin*.! tests: 

B29001A BC2001D BC2001E BC3204B BC3205B BC3205D 

C34007P and C34007S were graded passed by Evaluation Modification as 
directed by the AVO. These tests include a check that the evaluation of 
the selector "all" raises CONSTRAINT_ERROR when the value of the object is 
null. This implementation determines the result of the equality tests at 
lines 207 ard 223, respectively, based on the subtype of the object; thus, 
the selector is not evaluated and no exception is raised, as allowed by LRM 
11.6(7). The tests were graded passed given that their only output from 
Report.Failed was the message "NO EXCEPTION FOR NULL.ALL - 2". 


2-4 



IMPLEMENTATION DEPENDENCIES 


C4140LA was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test checks that the evaluation of attribute prefixes that 
denote variables of an access type raises CONSTRAINT ERROR v^en the value 
of the variable is null and the attribute is approprTate for an array or 
task type. This inplementation derives the array attribute values from the 
subtype; thus, the prefix is not evaluated and no exception is raised as 
allowed by LRM 11.6(7), for the checks at lines 77, 87, 108, 121, 131, 141, 
152, 165, and 175. 

CE3111B and CE3115A were graded inapplicable by Evaluation Modification as 
directed by the AVO. The tests assume that output from one internal file 
is unbuffered and may be immediately read by another file that shares the 
same external file. This implementation raises END_ERROR on the attenpts 
to read at lines 87 and 101, respectively. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies function NftME to the standard input file, \diich 
in this implementation has no name; USE_ERROR is raised but not handled, so 
the test is aborted. The AVO ruled that this behavior is acceptable 
pending any resolution of the issue by the ARC. 


2-5 






CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada inplementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
inplementation system, see: 

Michael Devlin 
106 Apple Street 
Tinton Falls NJ 07724 
(201) 758-7531 

For a point of contact for sales information about this Ada inplementation 
system, see: 


Michael Devlin 
106 J^le Street 
Tinton Falls NJ 07724 
(201) 758-7531 


Testing of this Ada inpleroentation was conducted at the custcmier's site by 
a vali^tion team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Inplementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 





PROCESSING INFORMATION 


Total Number of Applicable Tests 3798 

Total Number of Withdravm Tests 81 

Processed Inappliceible Tests 90 

Non-Processed I/O Tests 0 

Non-Processed Floating-Point 

Precision Tests 201 

Total Number of Inapplicable Tests 291 


Total Number of Tests for ACVC 1.11 4170 


All I/O tests of the test suite were processed because this implementation 
supports a file system. The above number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the inplementation. 


3.3 TEST EXECUTICW 

Version 1.11 of the ACVC conprises 4170 tests. When this compiler was 
tested, the tests listed in section 2.1 had been withdrawn because of test 
errors. The AVF determined that 292 tests were inappliceOsle to this 
inplementation. All inapplicable tests were processed during validation 
testing except for 201 executable tests that use floating-point precision 
exceeding that supported by the inplementation. In addition, the modified 
tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the vali^tion team for processing. The contents of the 
magnetic tape were configured on a 3280 MPS machine emd tremsferred via tar 
tapes to the host machine. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada inplementation. 


The tests were conpiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target computer 
system by the communications link described above, and run. The results 
were captured on the host computer system. 


Testing was performed using ccxnmand scripts provided by the customer and 
reviewed by the validation team. See J^pendix B for a complete listing of 
the processing options for this inplementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


3-2 






PROCESSING INFORMATION 


Option 

Effect 

-1 

Generate a listing file. 

-L 

Specify the name of the file or a directory 
for the listing file. 

-m 

Specify the main program name. 

-o 

Specify the name of the executable image file. 

-V 

Cause the con^iler to write a version 
identification and information messages 
to be displayed. 


The listings were printed on a remote system via a remote shell call. Test 
output, coitpiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 







APPENDIX A 


MACRO PARAMETERS 


Uiis appendix contains the macro parameters used for customizing the ACVC. 
The meeming and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, vhere "V" represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$MAX_IN__LEN 

$BIG_1D1 

$BIG_ID2 

$BIG_ID3 


255 

(1..V-1 «> 'A', V •> '1') 

(1..V-1 -> 'A', V •> '2') 
(1..V/2 »> 'A') & '3' & 
(1..V-1-V/2 »> 'A') 


$BIG_ID4 

$BIG_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING2 

$BLANKS 


(1..V/2 »> 'AM & '4' & 
(1..V-1-V/2 -> 'A') 

(1..V-3 »> 'OM & "298" 

(1..V-5 -> '0') & "690.0" 

& (1..V/2 -> 'A') & 

& (l..'^-l-V/2 «> 'A') & '1' & 

(1..V-20 »> ' ') 


$NAX LE34 INT BASED LITERAL 

"2;" & (1..V-5 -> '0') & "11:" 


$MAX_LEN_REAL_BASED LITERAL 

"16;" & (1..V-7 -> '0') & "F.E:" 


A-1 








MAO^O PARAMETEa^S 


$MAX_STRING_LITERAL 

& (1..V-2 -> 'A') & 

The following table lists all of 
respective values. 

the other macro parameters and their 

Macro Parameter 

Macro Value 

$ACC_SIZE 

32 

$ALIGNMENT 

4 

$COUNT_LAST 

2147283647 

$DEFAULT_MEM_SIZE 

2147283748 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

CCUR_MIPS 

$DELTA_DOC 

2#1.0#E-31 

$ENTRY_ADDRESS 

SYSTEM. signal_user_2_ref 

$ENTRY_ADDRESS1 

SYSTEM. signal_child_ref 

$ENTRY_ADDRESS2 

SYSTEM. signal_power_restore_ref 

$FIELD_LAST 

512 

$FILE_TERMINATOR 

t t 

$FIXED_NAME 

NO_SUCH_FIXED_TYPE 

$FLOAT_NAME 

NO_SUCH_FLOAT_TXPE 

$FORM_STRING 

nn 

$FORM_STRING2 

"CANNOT_RESTRICT_FILE_a^ACITY" 

$GREATER IHAN DURATION 

0.0 


$GREATER THAN DURATION BASE LAST 

looooiy.o 

$GREATER THAN FLOAT BASE LAST 

“ ” ” 16fl.0#+32 

$GREATER IHAN FLOAT SAFE LARGE 

“ " “ 16f0.8#E+32 

A-2 







MACRO PARAMETERS 

$GREATER_THAN_SHORT_ 

FLOAT SAFE LARGE 

0.0 

$HIGH_PRIORITy 

255 

$ILLEGAL EXTERNAL FILE NAMEl 

/nodir/filel 

$ILLEGAL EXTERNAL FILE_NAME2 

ongdir/f ile2 

$INAPPROPRIATE_LINE_ 

LENGTH 
■ -1 

$INAPPROPRIATEJPAGE_ 

LENGTH 
■ -1 

$INCLUDE_PRA01A1 

PRAOm INCLUDE ("A28006D1.TST") 

$INCLUDE_PRAC21A2 

PRAGMA INCLUDE ("B28006F1.TST") 

$INTEGER_FIRST 

-2147483648 

$INTEGER__LAST 

2147483647 

$INTEGER_LAST_PLUS_ 

L 2147483648 

$INTERFACE_LANGUAGE 

ASSEMBLER 

$LESS THAN__DURATIC3N 

-0.0 

SLESS THAN DURATION BASE FIRST 

- “ “ -2ZT0000.0 

$LINE_TERMINATOR 

ASCII.LF 

$LOW_PRIORITY 

0 

$MACHINE CODE STATEMENT 

“ " NULL 

$MACHINE_CODE_TXPE 

NO_SUCH_TYPE 

$MANTISSA_DOC 

31 

$MAX_DIGITS 

15 

$MAX_INT 

2147483647 

$MAX_INT_PLUS_1 

2147483648 

$MIN_INT 

-2147483638 


A-3 



N^CRO PARAMETERS 


$NAME 

$NAME_LIST 

$NAME_SPECIFICATI0N1 

$NAME_SPECIFICATIC»I2 

$NAME_SPEC1FICATI0N3 

$NEG_aASED_INT 

$NEW_MEM_S1ZE 

$NEW_STORJJNIT 

$NEW_SYS_NAME 

$PAGEjrERMlNATOR 

$RECORD_DEFINITION 

§RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

$TICK 

$VAR1ABLE_ADDRESS 

$VARIABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

$YOUR_PRAGMA 


TINY_1NTEGER 

COJRJUPS 

/benlA5)183/acvcll/chape/X2120A 

/benl/1i5>183/acvcll/chape/X2120B 

/benl/ii5>183/acvcll/chape/X3119A 

16#FFFFFFFE# 

2147483648 

8 

CCUR_MIPS 

ASCII.LF & ASCII.FF & ASCII.LF 
NEW INTEGER 

Nq_SUCH_HACHINE_CODE_TYPE 

32 

10240 

1.0/60.0 

GET_VARIABLE_ADDRESS 

GET_VARIABLE_ADDRESS1 

GET_VARIABLE_AroRESS2 

VOLATILE 


A-4 




APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The conpiler emd linker options of this Ada implementation, as described in 
this ^pendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to conpiler and linker 
documentation and not to this report. 


Option Effect 


-1 If specified, listing file is generated 

(listing is not generated by default) 

-L This option specifies the name of the 

file or a directory for the listing file, 
(default filename is source_file_name.l) 

-m This option will specify the main program 

name (a parameterless procedure). 

-c This option will specify the name of 

the library unit on which the completer 
should be run. This will cause the 
conpilation of all generic instantiations. 
This option was not specified. 

~o This option specifies the name of the 

executable image file. This option is 
ignored if -m option is not given. 

-A This option instructs the conpiler to 

generate assembly listing. No assembler 
listing was required, (not specified). 

-C This option instructs the conpiler to 

copy the source file being coopiled 
into the program library, (not specified) 


B-1 



OOMPIIATIOJ SYSTEM OPTICWS 


Option 

Effect 

-S 

This option tells the compiler to suppress 
all run-time checks, (not specified) 

-0 

Itiis option controls the optimization 
level of the conpiler. (the compiler 
performs all optimizations by default) 

-I 

This option tells the conpiler to obey 
pragma inline, (default is to obey the 
pragma) 

-s 

This option tells the compiler to perform 
only the syntax analysis, (not specified) 

-V 

This option causes the compiler to write 
a version identification and information 
messages to be displayed. This option 
was specified, (the default is to 
suppress such information) 


B—2 



APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in ^apter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The iirplementation-dependent 
characteristics of this Ada implementation, as described in this J^pendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are; 


package STANDARD is 

• • • 

type INTEGER is range -2147483648 .. 2147483647; 
type TINY_INTEGER is range -128 .. 127; 
type SHORT_INTEGER is range -32768 .. 32767; 

type FLOAT is digits 6 range -16#0 .FFFFFF#e32 .. 16#0.FFFFFF#E32; 

type LONG_FLQAT is digits 15 

range -16#0.FFFFFFFFFFFFF8#E256 .. 

16#0.FFFFFFFFFFFFF8#E256; 

type DURATION is delta 0.00006103515625 

range -131072.00 .. 131071.99993896484375; 

• # • 

end STANDARD; 


C-1 


APPENDIX F 

IMPLEMENTATION-DEPENDENT CHARACTERISTICS 


F.1 INTRODUCTION 

The Ada programming language definition requires every Ada compilation system to 
supply an Appendix F containing all implementation-specific aspects of the co:..piler and 
the run-time system. 

F^ IMPLEMENTATION-DEPENDENT PRAGMAS 

Table F-1 lists all pragmas in C’Ada predefined as well as implementation-defined. 


TABLE F-1. PRAGMA IMPLEMENTATION SUMMARY 


PRAGMA 

IMPLEMENTED 

COMMENTS 

BYTE.PACK 

Yes 

The elements of an array or record are packed down 
to a minimal number of bytes, pra^na BYTE_PACK 
does not affect packing down to the bit level. 

C_CALLABLE 

Yes 

Allows an Ada routine to be called from C. 

CONTROLLED 

No 

Not applicable because no automatic storage 
reclamation of unreferenced access objects is 
performed. The complete storage requirement of a 
collection is released when it passes out of scope. • 

ELABORATE 

Yes 

Is handled as defined by the Ada language. 

EXTERNAL>NAME 

Yes 

Defines the link-time name of a statically allocated 
object or of a subprogram. 

INLINE 

Yes 

Is handled as defined by the Ada language, with the 
following restrictions: The subprogram to be 
expanded inline must not contain declarations of 
other subprograms, task bodies, generic units, or 
body stubs. If the subprogram is called recursively, 
only the outer call is expanded. The subprogram 
must be previously compiled, and if it is a generic 
instance, it must be previously completed. 

INTERFACE 

Yes 

Is implemented for the languages C. FORTRAN and 
Assembler. 

LIST 

Yes 

Is handled as defined by the Ada language. 

MEM0RY_S1ZE 

No 

You cannot change the number of available storage 
units in the machine configuration, which is defined 
in package SYSTEM. 


48-586 FOO ROO 


F-1 
























TABLE F-1. PRAGMA IMPLEMENTATION SUMMARY (Continued) 


PRAGMA 

IMPLEMENTED 

COMMENTS 

OPTIMIZE 

No 

Optimization of a compilation can only be 
controlled using the -o option on the adac 
command line. 

PACK 

Yes 

The elements of an array or record are packed down 
to a minimal number of bits. 

PAGE 

Yes 

Is handled as defined by the Ada language. 

PRIORITY 

Yes 

Is handled as defined by the Ada language. 
Priorities in the range 0 .. 255 are supported. 

SHARED 

Yes 

Is handled as defined by the Ada language. 

STORAGE_UNIT 

No 

You cannot change the number of bits in a storage 
unit which is defined as 8 in package SYSTEM. 

SUPPRESS 

No 

Different types of checks cannot be switched on or 
off for specific objects: however, see SUPPRESS_ALL 

SUPPRESS«ALL 

Yes 

This pragma allows the compiler to omit the 
generation of code to check for errors that may be 
raised during run-time. The compiler will not 
suppress ELABORATION_CHECKs for tasks, and 
OVERFLOW.CHECKs implicitly done by the 
hardware. 

SYSTEM_NAME 

No 

You cannot change the system name which is 
defined as CCUR_MIPS in package SYSTEM. 

VOLATILE 

Yes 

Specifies that every read or update of a variable 
causes a reference to the actual memory location for 
the variable. That is. a local copy of the variable is 
never made. This is similar to pragma shared, 
except that any variable may be specified. This 
pragma causes all optimizations on the specific 
variable to be suppressed. 


F^1 Pragma INLINE Restrictions 

Inline expansion of subprogram calls occurs only if the subprogram does not contain any 
declarations of subprograms, task bodies, generic units, or body stubs. For recursive calls, 
only the outer call is expanded. The subprogram body must be previously compiled and if 
it is a generic instance, it must be previously completed. If for one or more of these 
reasons the inline expansion is rejected by the compiler, a corresponding warning message 
will be produced. 


Subprograms are automatically compiled inline if the following conditions hold; 

— Automatic iniining has not been suppressed by you. 

— The subprogram meets the requirements that are necessary for explicit iniining via 

pragma XMLIMi:. 

— The specification and body of the subprogram belong to the same compilation unit, 
and that compilation unit is the same as the place of the call being considered, or the 
call is in a subunit of that unit. 

— The size of the subprogram is less than a fixed limit, which is estimated based on the 
number of DIANA nodes used. This is a rough estimate and is equivalent to 
approximately 100 to 200 bytes of code. 


F-2 


48-586 FOO ROO 


































— The subprogram makes no calls to subprograms that have the pragma inline 1 
applied, and makes no calls to routines that may be expanded inline automatically. I 

F.3 REPRESENTATION CLAUSES 

The following subsections describe the restrictions on representation clauses as defined in 
Chapter 13 of the Reference Manual for the Ada Programming Language ANSI/MIL-STD~ 
1815A-1983. 


F.3.1 Length Clauses 

A length clause specifies the amount of storage to be allocated for objects of a given type. 
The following is a list of the implementation-dependent attributes: 


TSIZE 


TST0RAGE_S1ZE 


rSTORAGE_SlZE 


rSMALL 


must be <- 32 for any integer, fixed point, or enumeration 
type. For any type derived from FLOAT or LONG_FLOAT, the 
size must be equal to the default value selected by the 
compiler. These ar^ 32 and 64 respectively. The only value 
allowed for access types is 32 (the default value). If any of 
these restrictions is violated, the compiler will report a 
RESTRlCi ION error. 

If this length clause is applied to a collection, the exact 
amount of space specified . aher rounding to the next multiple 
of 4, will be allocated. No dynamic extension of the collection 
will be performed. If the length clause Is not specified, the 
collection will be extended automatically whenever the 
allocator new is executed and the collection is full. 

If this length clause is applied to a task type, the specified 
amount of stack space will be allocated for each task of 
corresponding type. The value supplied should not be less 
than 1400. If no length clause is specified for a task type, a 
default value of lOK bytes is supplied by the compiler. Stack 
space allocated for a task is never extended automatically at 
run-time. 

There is no implementation-dependent restriction. In 
particular, even values of SMALL which are not powers of 2 
may be chosen. 


F.3.2 Representation Attributes 

The Representation attributes listed below are as specified in the Reference Manual for the 
Ada Programming Language - ANSI/M1L-STD-1815A-1983, Section 13.7.2. 


X’ADDRESS 


X'SIZE 

R.C*POSmON 

R.CFIRST_BIT 

R.C’LAST_B1T 

rSTORAGE_SI2E 


is only supported for objects, subprograms, and interrupt 
entries. Applied to any other entity, this attribute yields the 
value SYSTEMADDRESS_ZERO. type SYSTEMADDRESS must I 
be visible in order to use this attribute. 

is handled as defined by the Ada language. 

is handled as defined by the Ada language. 

is handled as defined by the Ada language. 

is handled as defined by the Ada language. 

applied to an access type, this attribute will return the amount 
of storage currently allocated for the corresponding collection. 
The returned value may vary as collections are extended 
dynamically. 


48-586 FOO ROO 


F-3 


rSTORAGE_SIZE 


for task types or task objects, this attribute is handled as 
defined by the Ada language. 


F.3.3 Representation Attributes of Real Types 

This subsection lists all representation attributes for the floating point types supported: 


P'DIGITS yields the number of decimal digits for the subtype P. The I 

values for the predefined types are 6 and 15 for the types I 
FLOAT and LONG_FLOAT, respectively. 

P’MANTISSA yields the number of binary digits in the mantissa of P. Table 

F-2 shows the relationship between ’DIGITS and ’MANTISSA. 

TABLE F-2. P’MANTISSA VALUES 


DIGITS 

MANTISSA 

DIGITS 

MANTISSA 

1 

5 

9 

31 

2 

8 

10 

35 

3 

11 

11 

38 

4 

15 

12 

41 

5 

18 

13 

45 

6 

21 

14 

48 

7 

25 

15 

51 

8 

28 




P’EPSILON yields the absolute value of the difference between the model 

number 1.0 and the next model number above 1.0 of subtype P. 
Table F*3 summarises the values for ’EPSILON. 


TABLE F-3. P’EPSILON VALUES 


DIGITS 

EPSILON 

DIGITS 

EPSILON 

1 

16#0.1#E0 


16#0.4#E-07 


16#0.2#E-01 


16#0.4#E-08 


16#0.4#E-02 


16#0.8#E-09 


16#0.4#E-03 


16#0.1#E-09 


16#0.8#E-04 

13 

16#0.1#E-10 


16#0.1#E-04 

14 

16#0.2#E-11 


16#0.1#E-05 

15 

15#0.4#E*12 

8 

16#0.2#E-06 




P’EMAX yields the largest exponent of model numbers for subtype P. 

The values of ’EMAX are given in Table F-4. 


F-4 


48-586 FOO ROO 

















TABLE F-4. P’EMAX VALUES 


P'SMALL 


rURCE 


DIGITS 

EMAX 

DIGITS 

EMAX 


20 

9 

124 


32 

10 

140 


44 

11 

152 


60 

12 

164 


72 

13 

180 


84 

14 

192 


100 

15 

204 

1 - 8 

112 




yields the smallest model number of subtype P. The values of 
'SMALL are given in Table F-5, 

TABLE F-5. P’SMALL VALUES 


DIGITS 

SMALL 

DIGITS 

SMALL 


16#0.8#E-05 

9 

16#0.8#E-3i 


16#0.8#E-08 

10 

16#0.8#E-35 


16#0.8#E-11 

11 

16#0.8#E-38 


16#0.8#E-15 

12 

16#0.8#E-41 


16#0.8#E-18 

13 

16#0.8#E-45 


16#0.8#E*21 

14 

16#C.8#E-48 


16#0.8#E-25 

15 

16#0.8#E-51 

8 

16#0,8#E*28 




yields the largest model number of the subtype P. The values 
of 'LARGE are given in Table F-6. 


TABLE F-6. P’LARGE VALUES 


DIGITS 

LARGE 

1 

16#0.F8#E05 

2 

16#0.FF#E08 

3 

16#0.FFE#E11 

4 

16#0.FFFE#E15 

5 

16#0.EEFF.C#E18 

6 

16#0.FFFFJ^8#E21 

7 

16#0.FFFF«FF8#E25 

8 

16#0.FFFF_FFF#E28 

9 

16#0.FFFF_FFFE#E31 

10 

16#0.FFFF_FFFF_E#E35 

11 

16#0.FFFF_FFFF_FC#E38 

12 

16#0.FFFF_FFFF_FF8#E41 

13 

16#0.FFFF.FFFF_FFF8#E45 

14 

16#0.FFFF_FFFF_FFFF#E48 

15 

16#0.FFFF_FFFF_FFFF_E#E51 


48-586 FOO ROO 


F-5 

























The following attributes will return characteristics of the safe numbers and the 
implementation of the floating point types. For any floating point subtype P, the attributes 
below will yield the value of the predefined floating point type onto which type P is 
mapped. Therefore, only the values for the types FLOAT and LONG_FLOAT are given in I 
Table F-7. 

TABLE F-7. IMPLEMENTATION-DEPENDENT ATTRIBUTES FOR FLOAT TYPES 


ATTRIBUTE 

FLOAT 

LONG.FLOAT 

P’SAFE_EMAX 

125 

1021 

P'SAFE_SMALL 

16#0.4#E-31 

16#0.4#E-255 

P’SAFE_LARGE 

16#0.1FFF_FF#E32 

16#0.1FFF_FFFF_ 

FFFF_FC#E256 

P'MACH1NE_R0UNDS 

TRUE 

TRUE 

P'MACHlNE_OVERFLOWS 

TRUE 

TRUE 

P*MACH1NE_RAD1X 

2 

2 

P'MACH1NE_MANT1SSA 

24 

53 

P’MACH1NE_EMAX 

128 

1024 

P'MACH1NE_EM1N 

-125 

-1021 


F.3.4 Representation Attributes of Fixed Point Types 
For any fixed point type T, the representation attributes are: 


TMACHINE^ROUNDS 

TMACHINE^OVERFLOWS 

TMANTISSA 

rsizE 


is TRUE 
is TRUE 

is in the range 1 .. 31 
is in the range 2 _ 32 


F.3.5 Enumeration Representation Clauses 

The integer codes specified for each enumeration literal have to lie within the range of the 
largest integer type of the implementation (which is INTEGER). The maximum number of 
elements in an enumeration type is limited by the maximum size of the enumeration image 
table which cannot exceed 65535 bytes. The enumeration table size is determined by the 
following generic function: 


F-6 


48-S86 FOO ROD 






generic 

type ENUMERATION_TyPE is (<>); 
function ENUMZRATION_TABLE_SIZE return KATRUAL; 

function ENXJMERATI0N_TABLE_SI2E return NATRUAL is 
RESULT : NATURAL T- 0; 
begin 

for I in ENUMERATION_TYPE'FIRST .. ENUMERATION_TYPE'LAST 
loop 

declare 

subtype E is ENUMERATION_TYPE range I ., I; 
begin 

RESULT RESULT + 2 + E'WIDTH; 
end,■ 

end loop; 
return RESULT; 
end ENUMERATION TABLE SIZE; 


F.3.6 Record Representation Clauses 

With a record representation clause, you can define the exact layout of a record in memory. 
Two types of representation clauses are supported: alignment clauses and component 
clauses. 

The value given for an alignment clause must be either 0, 1, 2. or 4. A record with an 
alignment of 0 may start anywhere in memory. Values other than 0 will force the record to 
start on a byte address which is a multiple of the specified value. If any value other than 0. 
1, 2, or 4 is specified, the compiler will report a RESTRICTION error. 

For component clauses, the specified range of bits for a component must not be greater 
than the amount of storage occupied by that component. Gaps within a record may be 
achieved by not using some bit ranges in the record. Violation of these restrictions will be 
flagged with a RESTRICTION error message by the compiler. 

In some cases, the compiler will generate extra components for a record. These cases are: 

• If the record contains a variant part and the difference between the smallest and the 
largest variant is greater than 32 bytes and 

— it has more than one discriminant or 

— the discriminant can hold more than 256 values. 

In these cases, an extra component is generated which holds the actual size of the 
record. 

• If the record contains array or record components whose sizes depend on 
discriminants. In this case, one extra component is generated for each such component 
holding its offset in the record relative to the component generated. 

The compiler does not generate names for these extra components. Therefore, they cannot 
be accessed by the Ada program. Also, it is not possible to specify representation clauses 
for the components generated. 

F.4 ADDRESS CLAUSES 

Address clauses can be used to allocate an object at a specific location in the computer's 
address space or to associate a task entry with an interrupt. 

Address clauses are supported for objects declared in an object declaration and for task 
entries. If an address clause is specified for a subprogram, package, or task unit, the 
compiler will report a RESTRICTION error. 


48-S86 FOO ROO 


F-7 




For an object, an address clause causes the object to start at the specified location. 

F.4.1 Interrupt Entries 

Address clauses are supported for task entries. An address clause applied to a task entry 
enables an operating system signal to initiate an entry call to that entry. The address 
supplied in an address clause for a task entry must be one of the constants declared in 
package SYSTEM for this purpose. 

The interrupt is mapped onto an ordinary entry call. The entry may also be called by an 
Ada entry call statement. However, it is assumed that there are no entry calls waiting for 
the same entry when an interrupt occurs. Otherwise, the program is erroneous and behaves 
as follows: 

• If an entry call on behalf of an interrupt is pending, the pending interrupt is lost. 

• If any entry call on behalf of an Ada entry call statement is pending, the interrupt entry 
call takes precedence. The rendezvous on behalf of the interrupt is performed before 
any other rendezvous. 

F.5 PACKAGE SYSTEM 

The Ada language definition requires every implementation to supply a package SYSTEM. In 
addition to the declarations required by the language, package SYSTEM includes definitions 
of certain configuration-dependent characteristics. The specification for the C^Ada 
implementation is given below. 


package SYSTEM is 

type ADDRESS is private; 

ADDRESS_NULL : constant ADDRESS; 
ADDRESS~ZERO : constant ADDRESS; 


function "+" (LEFT 
function "+" (LEFT 
function (LEFT 
function (LEFT 


ADDRESS; RIGHT : 
INTEGER; RIGHT : 
ADDRESS; RIGHT : 
ADDRESS; RIGHT : 


INTEGER) return ADDRESS 
ADDRESS) return ADDRESS 
INTEGER) return ADDRESS 
ADDRESS) return INTEGER 


function SYMBOLIC_ADDRESS (SYMBOL : STRING) retiam ADDRESS; 

— Returns the address of the external symbol supplied by 

— SYMBOL, which must be a string literal. This value can 

— be used in address clauses for objects, providing the 

— capability of referring to objects declared in C, Fortran, or 

— Assembler. 


type NAME is (CCUR_MIPS); 

SYSTEM_NAME : constant NAME CCUR_MIPS; 

STORAGE_UNIT : Constant 8; 

MEM0RY_S1ZE : constant 2 *• 31; 

MIN_INT : constant - 2 •• 31; 

MAx”lNT : constant 2 •• 31 - 1; 

MAX_DIGITS : constant 15; 

MAX_MANT1SSA : Constant 31; 

FINE_DELTA : Constant 2.0 •• (-31); 

TICK : constant 1.0 / 60.0; 

type UNS1GNED_SH0RT__INTEGER is range 0 .. 65_535; 
type UNSlGNED~TINY_iNTEGER is range 0 .. 255; 


F-8 


48-586 FOO ROO 







for UNSIGNED_SHORT_im:EGEB'SIZE Use 16/ 
for UNS1GNED~T1NY_INTEGER'S1ZE Use 8; 

subtype BYTE i* UNSIGNED_TINY_INTEGER; 

subtype ADDRESS_RANGE is INTEGER; 

subtype PRIORITY is INTEGER range 0 .,255; 


type SIGNAL is ( 

S1GNAL_NULL, 

signal”hangup, 

S1GNAL~INTERRUPT, 

signal”quit, 

SIGNAL~ILLEGAL_INSTRUCTION, 

signal3trace_trap, 
signal”abort, 
signal3emt_instruction, 
signal”floating_point_error, 
signalIkill, 
signal”bus_error, 
signal7segmei;tation_violation , 

SIGNAL_BAD_ARGUMENT_TO_SySTEM_CAliL, 
SIGNAl7pIPE_WRITE, 

SIGNAL^ALARM, 

signal^terminate, . 

SIGNAl7uSER_1/ 
signal7user_2, 

SIGNAL^CHILD, 

SIGNAL^POWER^RESTORE, 

SIGNAL^STOP,"" 
signal7terminal_stop, 

SIGNAL^CONTINUE, 

signal7terminal_input, 
signal""terminal_output , 
signal7input_character, 

SIGNAL7cPU_TiME_LIMIT_EXCEEDEI5, 
SIGNAL7FlLE_SIzi_LIMIT_EXCEEDEI>, 

signal7window_resized, 
signal7out_of_band_data_on_socket, 
signal7virtual_timEr_alarm, 
signal7profiling_timer_alarm, 
signal"”I0_IS_F0SSIBLE) ; 


~ signal_null_ref 

SIGNAL_HANGUP_REF 

signal7interrupt_ref 
signal”quit ref 

—signal_illegal_instruction_ref 

signal_trace_trap_ref 

signal7abort_ref 

SIGNAl”eMT INSTRUCTION^REF 

~SIGNAL_FLOATING_POINT_ERROR_REF 

—signal7kill_Ref 
—signal7bus_error_ref 

—SI GNAL'’SEGMENTATION_VIOLATION_REr 
SIGNAL_BAD_ARGtJMENT_TO_SYSTEM_CALL_REF 

signal7pipe_write_ref 

—SIGNAL_ALARM_REF 
SIGNAL_TiRMINATE_REF 
—SIGNAL_USER_1_REF 
SIGNAL_USER_2_REF 


intentionally onitted 
: constant ADDRESS; 

; constant ADDRESS; 

: constant ADDRESS; 

intentionally omitted 
: constant ADDRESS; 

: constant ADDRESS ; 

: constant ADDRESS; 
intentionally omitted 
intentionally omitted 
intentionally omitted 
intentionally omitted 
: constant ADDRESS; 

: constant ADDRESS,- 
intentionally onitted 
: constant ADDRESS ; 
intentionally onitted 
: constant ADDRESS; 


48-586 FOO ROO 




SIGNAL_CHILD_REF 
SIGNAL_POWER_RESTORE_REF 
—SIGNAL_STOP_REF 
SIGNAL_TERMINAL_STOP_REF 

signal_continueIref 

signal~terminal_input_ref 

signalIterminal~output_ref 

SIGNAL_INPUT_C3iARACTZR_REF 

SIGNAL_CPU_TiME_LIMIT_EXCEEDED_REF 

SIGNAL_FILE_SIZE_LIMIT_EXCEEDED_REF 

SIGNAL~WIND0W_RESI2ED_REF 

signal~out_of~band_data_on_socket_ref 

signalIvirtual_timer_alarm_ref 

SIGNAL~PROFILING_TIMiR_ALARM_REF 
SIGNAL 10 IS POSSIBLE REF 


: constant ADDRESS; 

: constant ADDRESS; 

Intentionally onltted 
: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; • 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 


type PROCESS_ID is new INTEGER; 

subtype AST^NUmIeR is INTEGER range 65..128; 

type ASt”prIORITY is range 0..32767; 

for AST_PRI0RITY'SIZE use 32; 

— defisitioDs for AST support, 
type EXCEPTI0N_ID is new ADDRESS; 


NO EXCEPTION ID : constant EXCEPTION ID ADDRESS_2ER0; 


— Coding of the predefined exceptions: 


C0NSTRAINT_ERR0R_ID 

NUMERIC_ERROR_ID 

program~error”id 

storage~errorIid 

tasking”error_id 

STATUS_ERROR_ID 

M0DE_ERR0R_ID 

NAME_ERR0R_ID 

USE_iRR0R_iD 

DEVICE_ERROR_ID 

END_ERR0R_ID 

DATA_ERR0R_ID 

LAy0UT_ERR0R_ID 

TIME ERROR ID 


constant EXCEPTI0N_ID 
constant EXCEPTI0N_ID 
constant EXCEPTI0N_ID 
constant EXCEPTI0 n”id 
constant EXCEPTI0 n”iD 
constant EXCEPTI0N_ID 
constant EXCEPTI0 n”id 
constant EXCEPTI0N~ID 
constant EXCEPTI0 n”id 
constant EXCEPTI0N~ID 
constant EXCEPTION_ID 
constant EXCEPTION_ID 
constant EXCEPTI0N~ID 
constant EXCEPTION ID 


implementation defined, 
implementation defined 
implementation defined, 
implementation defined 
implementation defined 
implementation defined, 
implementation defined, 
implementation defined, 
implementation defined 
implementation defined, 
implementation defined 
implementation defined, 
implementation defined, 
implementation defined. 


NO ERROR CODE : constant 0; 


type EXCEPTION_INFORMATION 
is record 

EXCP_ID : EXCEPTI0N_ID; 

— Identification of the exception. The codings of 

— the predefined exceptions are given above. 

C0DE_ADDR : ADDRESS; 

— Code address whe.re the exception occured. Depending 

— on the kind of the exception it aay be the address of 

— the instruction which caused the exception, or it 

— may be the address of the instruction which would 

— have been executed if the exception had not occured. 

SIGNAL : SYSTEM.SIGNAL; 

— Signal that caused this exception to be raised, 

— else SIGNAL_NULL. 
end record; 


F-10 


48>S86 FOO ROO 









procedure GET_EXCEPTION_INFORMATION 

(EXCP_INFO~: out EXCEPTION_INFORMATION) ; 

— The subprogram GET_EXCEPTION_INFORMATION must only be called 

— from within an exception handler BEFORE ANY OTHER EXCEPTION 

— IS RAISED. I*, then returns the information record about the 

— actually handled exception. 

— Otherwise, its result is undefined. 


function INTEGER_TO_ADDRESS(ADDR : ADDRESS_RANGE) return ADDRESS; 
function ADDRESs3oIlNTEGER(ADDR : ADDRESS) return ADDRESSTRANGE; 
pragma INLINE(INTEGiR_TO_ADDRESS, ADDRESS_TO_INTEGER); "" 

— Conversion between ADDRESS and INTEGER types. 

type EXIT_STATUS is new INTEGER range 0 .. 2**8-l/ 

NORMAL_EXIT ! constant EXIT_STATUS 0; 

ERRNO : INTEGER; 

for ERRNO use at SYMBOLIC_ADDRESS (“errno")/ 

— Allows access to the errno set by the last system call, C, or 

— assembler routine call that was made on behalf of the calling 

— task. 

procedure EXIT_PROCESS (STATUS : in EX1T_STATUS NORMAL_EXIT); 

— Terminates the Ada program with the following consequences: 

— All Ada tasks are aborted, and the main program exits. 

— All I/O buffers are flushed, and all open files are closed. 

private 

— Implementation defined 
end SYSTEM; 


F.6 TYPE DURATION 

DURATION’SMALL is 2 ‘^ seconds. This number is the smallest power of two which can 
represent the number of seconds in a day in iongword fixed point number representation. 

SYSTEM.TICK is equal to 1.0 / 60.0 seconds. DURATION’SMALL is significantly smaller than 
the actual computer clock-tick. Therefore, the accuracy with which you can specify a delay 
is limited by the actual clock-tick and not by DURATION’SMALL Table F-8 summarizes the 
characteristics of type DURATION: 


48*586 FOO ROO 


F-H 




TABLE F-a TYPE DURATION 


ATTRIBUTE 

VALUE 

APPROXIMATE 

VALUE 

DURATION’DELTA 

2#1.0#E-14 

- 61 fts 

DURATION’SMALL 

2#1.0#E-14 

— 61 /is 

DURATION'FIRST 

-131072.00 

~ 36 hrs 

DURATION’LAST 

131071.99993896484375 

* 36 hrs 

DURATION’SIZE 

32 



F.7 INTERFACE TO OTHER LANGUAGES 

Pragma INTERFACE is Implemented for three programming languages; C, FORTRAN and I 
Assembler, The pragma has the form; 

pragma INTERFACE (C, subprogram^name) ; 


pragma INTERFACE (ASSEMBLER, SUbprogratn^name); 


pragma INTERFACE (FORTRAN, SUbprogram^name I,IS_FUNCTION] ); 


pragma INTERFACE (FORTRAN_FUNCTION, 5Ubprogram^name)\ I 

Here, subprogram^name is the Ada name of the subprogram, written in the language C. I 
ASSEMBLER or FORTRAN. It can be a function or a procedure. If it is a function, the I 
returned result is the result delivered by the called routine. 

The only parameter mode supported for subprograms written in the C language is in. The 
only types allowed for parameters to subprograms written in the C language are INTEGER. 
LONG_FLOAT, and SYSTEMADDRESS. These restrictions are not checked by the compiler. 

Details on Interfacing to other languages are given in Chapters 6, 7 and 8. Code I 
statements and package machine.code are not supported. 

F.8 INPUT/OUTPUT PACKAGES 

The following two system-dependent parameters are used for control of external files; 

• the NAME parameter 

• the FORM parameter 

The NAME parameter must be a legal RTU pathname conforming to the following syntax; 

pathname I/11 dirname [/ dirname )/] filename 

dirname and filename are strings of up to 14 characters length. Any characters except 
ASCII.NUL, ■ ’ (blank), and 7' (slash) may be used. 

The following is a list of all keywords and possible values for the FORM parameter in 
alphabetical order. 


F-12 


48-586 FOO ROO 




















APPEND -> FALSE i TRUE Only applicable to sequential and text files. If 

TRUE is specified in an OPEN operation, the file 
pointer is positioned to the end of the file. This 
keyword is ignored in a CREATE operation. The 
file mode must be IN_F1LE The default is 
APPEND -> FALSL 

MODE -> numehCL.Iiteral This value specifies the access permission for an 

external file. It only takes effect in a CREATE 
operation. It is ignored in an OPEN operation. 
Access rights can be specified for file owner, 
group members, and all users. The 
numeric-literal has to be a three digit octal 
number. The single bits of this number have the 
following meaning; 


8#400# read access owner 
8#200# write access owner 
8# 100# execute access owner 
8#040# read access group 
8#020# write access group 
8#010# execute access group 
8#004# read access all others 
8#002# write access all others 
8#001# execute access all others 


RECORD_FORMAT ■> VARIABLE | 
FIXED 

RECORD SIZE -> numericjiteral 


TRUNCATE -> FALSE 1 TRUE 


You can specify any sum of the above. The 
default value is 8#666#. 

Note that the RTU operating system will subtract 
the process's file* mode creation mask from the 
mode you have specified. You can change the file 
mode creation mask with the RTU command 
umask (see the RTU Programming Manual)- For 
example, if your session has a file mode creation 
mask of 8#022# and you create a file with mode 
8#666#, the file will actually be created with the 
privileges 8#644#. 

This parameter is only allowed for sequential 
files. The default value is VARIABLE- 

Only applicable to sequential and direct files. It 
specifies the number of bytes in one record. 
This parameter is only allowed for files with a 
fixed record length. When specified in an OPEN 
operation, it must agree with the corresponding 
value of the external file. If ELEMENT.TYPE is a 
constrained type, the maximum size of 
ELEMENTJTYPE rounded up to the next byte 
boundary is selected by default. If 
ELEMENTJTYPE is an unconstrained array type 
and you want a fixed record length file, this 
parameter must be specified. 

Only applicable to sequential files. The 
FILE_MODE must be 0UT_F1LL When TRUE Is 
specified in an OPEN operation, the file size is 
truncated to zero. The previous contents of the 
file is deleted. If FALSE is specified, the file is not 


48-S86 FOO ROO 


F-13 






changed initially. If less records than the Initial 
file size are written, old records will remain 
unchanged in the file. This parameter is ignored 
for CREATE operations. The default value Is 
TRUE. 


F.8.1 Text Input/Output 

There are two implementation-dependent types for TEXTJO: COUNT and FIELD. In C’Ada 
they are implemented as: 


type COUKT is range 0 .. INTEGER'LAST; 
subtype FIELD is INTEGER range 0 .. 512; 

The line terminator is implemented by the character ASCll.LF. the page terminator by the 
sequence ASCll.LF, ASCIl.FF, ASCll.LF. There is no character for the file terminator. End of 
file is deduced from the file size. 

F.9 UNCHECKED PROGRAMMING 


F.9.1 Unchecked Storage Deallocation 

The generic function UNCHECKED_DEALL0CAT10N is supported as specified in the 

Reference Manual for the Ada Programming Language - ANSI/MIL-STD-1815A-1983, 

Section 13.10. 

F.9.2 Unchecked Type Conversion 

The generic function UNCHECKED_CONVERSION is supported as specified in the Reference 

Manual for the Ada Programming Language - ANS1/MIL-STD-1815A-1983, Section 13.10. 

However, the following restrictions apply: 

The generic parameter TARGET must not be an unconstrained array type. If TARGETSIZE > 

SOURCE'SIZE, the result of the conversion will be unpredictable. On the other hand, if 

TARGET'SIZE < SOURCE’SIZE. the left-most bits of the source will be copied to the target. 

F.10 IMPLEMENTATION-DEPENDENT RESTRICTIONS 

The following is a list of implementation-dependent restrictions of the compiler 

• The maximum length of a source line is 255 characters. 

• A main program may not consist of more than 16380 compilation units. 

• The maximum number of com''iiation units in a library is 16380. including all 
referenced units whether directly or indirectly. 

• The maximum number of compilation units that can be listed by adallb is 16380. 

• The maximum number of parent libraries a sublibrary can have is 127. 

• The maximum number of units which can be used directly by another unit is 1024. 
Directly used units are those which are mentioned in the with clause or those to which 
a reference exists because of an implicitly use of a type definition, or units from which 
a subprogram was expanded inline. 

• A sublibrary can store nearly 65_536 different Ada compilation unit names, source files 
and library names. 

• A single compilation unit may not contain more than 65534 lines of Ada source text. 
(Depending on the complexity of the code, the actual number of lines acceptable may be 
considerably smaller than the upper limit.) 


F-14 


48*586 FOO ROO 





I 


• The maximum number of nested separatee is 511. 

• The main program must be a parameterless procedure. 

• The maximum length of an identifler is 255 (maximum line length). All characters of an 
Identifier are significant. 

• The maximum number of bits of any object is 2’* • 1. 

• The maximum number of numeric literals per compilation is 88000. 

• The maximum number of library pages, which are used to hold DIANA and other I 
intermediate languages, is 2048 per compilation unit. 

• The maximum length of a file name is 255 characters. 

• The maximum length of a listing line is 131 characters. 

• The maximum number of errors handled is 1000. 

• The maximum number of units that may be named in the pragma ELABORATE of a I 

compilation unit is 1024. I 

• The maximum total size for text of unique symbols per compilation is 300000 bytes. 

• The maximum parser stack depth is 10000. 

• The maximum depth of nested packages is 511. I 

• The maximum length of a program library name is 242 characters. 

• The attribute ADDRESS is not supported for packages, labels, and entries that do not 
have an address clause applied to them. 

• The amount of statically allocated, non-initialized data in a compilation unit cannot 
exceed INTEGER'LAST bytes. 

• The amount of statically allocated, initialized data in a compilation unit cannot exceed 
INTEGER'LAST bytes. 

F.11 UNCONSTRAINED RECORD REPRESENTATION 

Objects of an unconstrained record type with array components based on the discriminant 
are allocated using the discriminant value supplied in the object declaration. However, if 
no discriminant is supplied in the object declaration, the compiler will choose the 
maximum possible size. For example: 

type DYNAMIC_STRING ( LENGTH : NATURAL 10 ) is 
xecosd 

STR : STRING ( 1 .. LENGTH ); 
end zecoxd; 

DSTR : DYNAMIC_STRING; 

For the record DSTR, the Compiler would attempt to allocate NATURAL'LAST bytes. 
However, this is more than 2 GBytes. As a consequence. CONSTRAlNT_ERROR would be 
raised. On the other hand, the declaration 

CSTR : DYNAMIC_STRING (80); 

causes no problems. The compiler would allocate 84 bytes for CSTR. 

F.12 TASKING IMPLEMENTATION 

The C*Ada system implements fully pre-emptive and priority-driven tasking. Pre-emptive 
means that task switches may take place even when the currently running task does not 
voluntarily give up processor control. This may happen when a task with a high priority is 


48-586 FOO ROO 


F-IS 




waiting on an external event (the time period specified in a delay statement expires). When 
this event occurs, processor control is passed to the waiting task immediately if it has the 
highest priority of the tasks ready to run. 

The C*Ada run-time system keeps track of all tasks in two categories: tasks which are 
ready to run and those that are suspended because they are waiting for something (e.g.. a 
rendezvous to occur or waiting in a delay statement). The tasks ready to run are sorted in 
a queue by priority (high priorities first). Within one priority, they are sorted in the order 
In which they entered the "ready" state (tasks waiting longer are served first). Whenever 
the run-time system needs a task to schedule, the first task in the queue is selected and 
run. 

The accuracy of delay statements is governed by the resolution of the operating system 
ciock which is 1.0/60.0 seconds (SYSTEM.TICK). Although the resolution of the type 
DURATION is much higher (2'*^ seconds), task switches caused by the expiration of a delay 
can only take place on a clock tick. A task waiting in a delay enters the "ready" state when 
the next clock tick after its delay period has expired. 

Another implementation-dependent aspect of tasking is the stack size of each task. All task 
objects of a task type with a length clause and all tasks of an anonymous task type have a 
stack space of lOK bytes. For task types, a length clause may be given. The specified 
amount of storage space will be allocated for each task object of that type. 

In addition to stack space, a task control block is allocated for each task object it occupies 
250 -•- 20 * number^of^entries bytes. The task control block is deallocated when the task 
passes out of scope. 

A program is erroneous if any of the following operations can be performed 
simultaneously by more than one task: 

• The allocator new is evaluated for the same collection. 

• Input-Output operations are performed on the same external file. 

A C^Ada task is not implemented as an independent operating system process; rather, the I 
whole Ada program is one operating system process which does not use RTU threads. I 

F.13 PREDEFINED EXCEPTIONS I 

As specified by Al-00387. this implementation raises the predefined exception I 
CONSTRAlNT_ERROR whenever the Ada standard requires that NUMERICLERROR be raised I 
(other than by a raise statement). The compiler gives a warning message for any I 
exception handler that has a sequence of exception choices where NUMERICLERROR is 1 
mentioned, but not CONSTRAlNT_ERROR. 


F-16 


48-586 FOO ROO 



