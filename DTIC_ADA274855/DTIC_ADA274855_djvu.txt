(S> 


NAVAL POSTGRADUATE SCHOOL 

Monterey, California 


An-A274 855 

,.,.^111 HIV mil lllllllll 


ill 







THESIS 


DTIC 


Cf-M eiECTE 
•>.- JAN2 6 1994 


D 



A Functional Bar Code Inventory System 
for 

Marine Corps Systems Command 
by 

Richard M. Hancock 


September, 1993 


Thesis Advisor: 
Co-Advisor: 


William Haga 
Shu S. Liao 



Approved for public release; distribution is unlimited. 




1 2 


94-02119 


t 1 







REPORT DOCUMENTATION PAGE 


Form Approved 


No. 0704 


I’ublic reporting burden for this collection of information ia estimated to average 1 hour per response, including 
Lhe time for reviewing instruction, searching existing data aourcea, gathering and maintaining the data nee d ed , 
■nd completing and reviewing the collection of information. Send connents regarding this burden eatiauite or any 
jther aspect of this collection of information, including suggestions for reducing this burden, to Nashington 
leadquarters Services, Directorate for Information Operations and Reports, 131S Jefferson Davia Highway, Suite 
1304, Arlington, VA 33303-4302, and to the Office of Management and Budget, Paperwork Reduction Project 
(0704-0188) Washington DC 20503. 


1. AGENCY USE ONLY (Leave 

2. 

REPORT DATE 

blank) 


Sep 1993 


3. REPORT TYPE AND DATES COVERED 

Master's Thesis, Pinal 


. TITLE AND SUBTITLE A Functional Bar Code 
Inventory System for Marine Corps Systems Command 


5. FUNDING NUMBERS 


AUTHOR(S) Richard M. Hancock 


PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 
Naval Postgraduate School 
Monterey CA 93943-5000 


SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 


10. SPONSORING/MONITORING 

AGEN(7Y REPORT NUMBER 


11. SUPPLEMENTARY NOTES The views expressed in this thesis are those of the 
author and do not reflect the official policy or position of the 
Department of Defense or the U.S. Government. 


12a. DISTRIBUTION/AVAILABILITY STATEMENT Approved for 
ublic release; distribution unlimited 


12b. DISTRIBUTION CODE 

A 


13. ABSTRACT (maxiwuw 200 words) 

Marine Corps Systems Command, located in Quantico, Virginia, maintains 
a large amount of computer assets to support its vast and varied 
operations. This property requires accurate record keeping to assure 
accountability of each item throughout its lifetime, from initial 
acquisition through disposal. This thesis designs and implements a Bar 
Code Inventory System (BCIS) to support the management and accountability 
bf the command's assets. The BCIS is a fully tested, menu driven system 
designed to increase the efficiency and effectiveness of the inventory 
t)rocess. 


14. SUBJECT TERMS Bar Code Inventory,Intermec,InterScan, 
PCIRL,Ada,Interactive Reader Language(IRL). 


7. SECURITY 

CLASSIFICATION OF 
REPORT 


18. SECURITY 

CLASSIFICATION OF 
THIS PAGE 


19. SECURITY 

CLASSIFICATION OF 
ABSTRACT 


15. NUMBER OF 
PAGES I2V 


16. PRICE CODE 


20. LIMITATION OF 
ABSTRACT 
UL 


Unclassified 


Unclassified 


Unclassified 





















A^voved fdM- jmblic release; distribudon is unlimited. 

A Functional Bar Ckxk Inventory System 
for 

Marine Corps Systons C omman d 
by 

Richard M. Hancock 
Captain, United States Marine C(»ps 
B.S., Randolph-Macon College, 1985 

Submitted in partial fiilflllment 
of the requirements for the degree of 

MASTER OF SCIENCE IN INFORMATION TECHNOLOGY MANAGEMENT 

from die 


Author: 


Approved by: 




ii 









ABSTRACT 


Marine Corps Systems Command, located in Quantico, 
Virginia, maintains a large amount of computer assets to 
support its vast and varied operations. This property 
requires accurate record keeping to assure accountability of 
each item throughout its lifetime, form initial acquisition 
through disposal. This thesis designs and implements a Bar 
Code Inventory System (BCIS) to support the management and 
accountability of the command’s assets. The BCIS is a fully 
tested, menu driven system designed to increase the 
efficiency and effectiveness of the inventory process. 

WIOQUWJTYffiSPECrrEDB 


iii 








TABLE OF CONTENTS 


I. INTRODUCTION. 1 

A. BACKGROUND . 1 

B. PROBLEMS WITH MANUAL INVENTORY SYSTEM . 1 

C. GOALS AND OBJECTIVES . 2 

D. CHAPTER DESCRIPTIONS . 2 

II. SYSTEM ANALYSIS . 4 

A. SURVEY PHASE . 4 

1. Methodology . 4 

2. Application . 5 

B. STUDY PHASE . 6 

1. Methodology . 6 

2. Application . 6 

C. DEFINITION PHASE . 11 

1. Methodology . 11 

2. Application . 12 

III. SYSTEM DESIGN . 17 

A. INTRODUCTION . 17 

B. OBJECT AND ATTRIBUTE IDENTIFICATION . 18 

C. OPERATIONS WITH OBJECTS . 19 

D. VISIBILITY RELATIONSHIPS . 21 

E. INTERFACE SPECIFICATIONS . 21 

IV. IMPLEMENTATION . 24 

A. CREATING SERIAL NUMBER FILE PHASE . 24 

B. INVENTORY PHASE . 26 

C. CREATE REPORTS PHASE . 27 

D. PRINT BAR CODE LABELS . 29 

E. SYSTEM INTEGRATION . 30 

V. CONCLUSION . 34 

APPENDIX A: SOURCE CODE . 35 

APPENDIX B: BCIS USER'S MANUAL . 98 

A. INTRODUCTION . 98 

B. INSTALLATION AND SETUP . 98 

iv 



































1. Compatibility and Requirements . 98 

2. Installation . 99 

3 . Setup . 100 

C. STARTING THE SYSTEM . 101 

D. DOWNLOAD FILE TO BAR CODE READER . 102 

1. Establish a Connection . 102 

2. Set Protocol On Reader. 102 

3. Place CMR Listing in Proper Directory . 104 

4. Initiating Dovmload Option . 104 

5. Configure PCIRL for Communication . 105 

6. Downloading File to Reader . 105 

E. CONDUCTING THE INVENTORY . 106 

F. RECEIVE INVENTORY RESULTS . 109 

1. Receive Found File . 110 

2. Receive Not Found File . 112 

3. Receive Both Files . 114 

4. Configure Intrscan for Communication . 115 

G. PRINT REPORTS . 115 

H. PRINT BAR CODE LABELS . 117 

I. EXIT THE SYSTEM . 118 

LIST OF REFERENCES .119 

INITIAL DISTRIBUTION LIST.120 


V 



























1. IinROOUCTXON 


A. BACKaROUMD 

Meurine Corps Systems Command (MARCORSYSCOM), located in 
Quantico, Virginia, is responsible for the acquisition and 
accounted:>ility of computer assets. Their current Consolidated 
Memorandum Receipt (CMR)—a listing of all assets owned by the 
command—is in excess of thirty pages with approximately 3,000 
computer assets. The size of the CMR is further complicated by 
the fact that many of these assets are portable, thus heu&pering 
the command's ability to maintain proper accountability of these 
assets. 

The implementation of an automated inventory system will 
increase the efficiency and effectiveness of the inventory 
process and provide the command with the resources 
necessary to maintain proper accountability of its computer 
assets. 

B. PROBLQfS WITH MANUAL INVENTORY SYSTBl 

The manual system takes approximately six weeks to complete 
an inventory. Many of the items are portedDle, thus con^licating 
the inventory process. Because of the length of time it takes to 
complete em inventory, memy of the assets move from location to 
location during the inventory. Tfhis results in some assets being 


1 




inventoried twice while other assets are never inventoried. This 


problem hampers the command's ability to maintain proper 
accountability of its computer assets. 

C. GOALS AMD OBJECTIVES 

The priiMury goal of this project is to design, develop and 
implement a bar code inventory system which could assist 
MARCORSYSCOM in conducting an accurate and timely inventory of 
its computer assets. Automating the inventory process will 
provide substantial time savings and significantly increase the 
accuracy of the inventories. 

The automated system was designed using the Object-Oriented 
Design approach and was implemented using Ada and Interative 
Reader Language (IRL) programming languages. The system accepts 
input from a bar code scanner, manual keypunch entries, and files 
downloaded from the local area network (LAN). The Bar Code 
Inventory System (BCIS) produces bar code labels and generates 
periodic reports on the status of the assets within the command. 
The BCIS is a fully integrated, menu driven system with 
established communication between the various heurdware 
platforms—personal computer, bar code reader and bar code 
printer. 

D. CHAPTER DESCRIPTIONS 

Chapter II studies the old system and its problems, 
defines business needs and requirements, and evaluates 


2 





alternative solutions. The step by step strategies employed 
during this analysis is covered in this chapter. 

Chapter III will review the System Design methodology used in 
designing the Bar Code Inventory System (BCIS). The four phases 
associated with Object-Oriented Design, object identification, 
defining operations with each object, determination of 
relationships between objects, and developing interface 
specifications, will be covered. 

Chapter IV covers the implementation of the BCIS. This 
chapter discuses how the four phases of the system were • 
implemented—creating a serial number file to download to the bar 
code reader, conducting an inventory using the reader, processing 
the results of the inventory into reports, and printing bar code 
labels--and problems encountered while integrating these phases 
into the BCIS. 

Chapter V, the conclusion, determines whether the system is 
operational and ready for implementation at MARCORSYSCOM. 

Appendix A includes all the source code that was incorporated 
in the BCIS. This section includes the progreuns written in Ada, 
IRL, and the Batch File composed to integrate the system. 

Appendix B is the user's xoanual. This chapter provides the 
documentation necessary to install euid operate the Bar Code 
Inventory System. 


3 




II. SYSTEM AHALYSIS 


The purpose of systems analysis is to study the current 
business system «uid its problems, define business needs emd 
requirements, emd evaluate alternative solutions. The three 
phases used in the emalysis of the Bar Code Inventory System 
(BCIS) will be discussed in this section. The step-by-step 
strategies for completing each phase will be discussed followed 
by how that phase was applied in developing the BCIS. 

A. SURVEY PHASE 

1. Methodology 

A project is initiated with a preliminary analysis of 
project scope and feasibility. The survey phase determines 
whether significant resources should be committed to the future 
phases of the life cycle. "During the Survey Phase, we define 
the scope of the project, perceived problems and opportunities, 
business and technical constraints, perceived project goals, and 
possible solutions" [Whitten, Bentley and Barlow, 1989, p.87]. 
Information gathered during this phase, although probably not 
very detailed--or even acurate—will be the starting point for a 
detailed Systems Analysis [Page-Jones, 1988, p.21]. 


4 





2. Application 

The goal of this project was to develop an automated 
inventory system which could assist Marine Corps Systems Command 
(MARCORSYSCOM) in conducting an accurate and timely inventory of 
existing assets. Captain Lang, the Resource Memager for the 
Information Systems Management Division at MARCORSYSCC^, wanted 
to limit the scope of the inventory system to include only 
serialized assets—such as computers, printers, monitors, etc. 
These types of assets have a high dolleu: value and represent the 
majority of items on Captain Lang's Consolidated Memoremdum 
Receipt (CMR)-- a listing of all assets under his control. The 
current CMR is in excess of thirty pages with approximately 3,000 
serialized items that must be inventoried qu^u^terly. The size of 
the CMR is further complicated by the fact that many of these 
assets are portable, thus making the inventory process extremely 
difficult. The proper accountability of these assets is very 
important and requires a great deal of time and effort. The 
problems Identified with the current system emd the potential 
benefits of automating this process will be discussed in the 
following sections of this chapter. 

It was decided that the scope of this work warranted 
develoiMnent as an individual thesis project. The core of the 
work would be performed on a personal computer owned by the 
author. MARCORSYSCOM provided the hardware necessary to automate 
the current system to include: a bar code reader, scanner, beu: 


3 




code printer, and manuals. The cost of the additional hardware 
was considered negligible in comparison to the benefits expected 
with a fully automated inventory system. A time spem of nine 
months, with commencement in December 1992 and system completion 
by August 1993, was considered feasible. The Survey Phase was 
accomplished during a single interview with Captain Lang that 
took approximately one hour. 

B. STUDY PHASE 

1. Methodology 

During this phase facts are collected about how the 
current system functions. Problems with the current system are 
identified and potential opportunities are diagnosed in an 
attempt to improve the process. Data are collected using 
interviews and modeling techniques to learn about the system. 
"You need to understand the existing system, manual or 
computerized, before you can design and build a new system." 
[Whitten, Bentley, and Barlow, 1989, p.90] 

2. Application 

On 14 December 1992, the author took a four day research 
trip to MARCORSYSCOM, which is located in Queuitico, Virginia. 
Captain Lemg was interviewed to acquire an understemding of the 
current inventory process. Captain Lemg is accountable for all 
the assets assigned to his division. He is responsible for 
conducting quarterly inventories and possesses a thorough 


6 





understanding of the process. During the interview the author 
developed a detailed understanding of the current system. 

Physical data flow diagrams (DFDs) were drafted to document the 
processes and the flow of data and information through the 
existing system (see Figures 2.1 through 2.3). These models show 
not only what a system does, but also how the system is 
physically implemented. The use of these models helped the 
author grasp the inputs, outputs, and processes, and the 
relationships among the different processes of the system. 

After evaluating the models and data collected during the 
research trip, the following problems were identified: 

1. Current system is inefficient resulting in a 
slow inventory process; 

2. Poor accountability; and 

3. Duplication of effort. 

The process of manually searching the CMR for a serial 
number that matches the serial number on the asset was determined 
to be the most inefficient and time-consioming process in the 
system. The current CMR is in excess of thirty pages with 
approximately 3,000 serial numbers. The CMR is organized in such 
a way that each item, for example a monitor, can have many 
National Stock Numbers (NSNs). Under each NSN there may be many 
serial numbers. In order to efficiently match the serial number 
of the asset with the serial number on the CMR the person 


7 







Ffaysical Context Data Flow Diagram 












9 













10 












conducting the inventory must know the NSN of the asset. This 
information is not obtainable in the current system, forcing the 
user to seeurch each NSN for a serial number that matches. For 
some items, such as monitors euid printers, the user must seeurch 
through several pages of serial nximbers to find a match. This 
results in an inventory process that takes approximately six 
weeks to complete. 

By automating the process of searching the CMR for a 
serial niamber, the problem of duplication of effort and poor 
accountedsility could also be reduced. For example, many of the 
items are portable, thus complicating the inventory process. 
Because of the length of time it takes to complete an inventory, 
many of the assets move from location to location during the 
inventory. This results in some assets being inventoried twice 
(duplication of effort) while other assets are never inventoried. 
This creates a problem in the accountability of the command's 
assets. By automating the current process the inventory could be 
completed In less than a week, lessening the problem of assets 
moving during the inventory. Automating the current process will 
increase the efficiency and accuracy of the current system. 

C. DEFINITION PHASE 
1. Methodology 

The goal of the definition phase is to develop a detailed 
definition of the requirements and objectives of the proposed 


11 






system. Requirements are the blueprint that will be used to 
design ^md implement the new system. Before moving on to 
development, the developer must know exactly what the system is 
supposed to do. ‘The purpose of the Definition Phase is to 
identify what the improved system must be able to do without 
specifying how the system could or will do it"[Whitten,Bentley 
and Barlow, 1989, p.l56]. 

It is not only important that the system is built 
correctly, but vital that the correct system is built. The 
analyst should actively involve all of the end-users who were 
identified during the Study Phase. It is important to give 
end-users at every level of the organization the opportunity to 
define goals, objectives, and information system needs. Proper 
definition of the requirements is the first step toward 
preventing future maintenance nightmares. 

2. Application 

The research trip identified the end user’s information 
needs and what functions the new system is expected to perform. 

A six-week tux-neuround time to complete an inventory was 
considered unsatisfactory. The major goal of the new system was 
to reduce the amount of time it takes to conduct an inventory and 
thus increase the accuracy of the inventory. 

Marine Corps Systems Command wanted to use bar code 
technology to completely autcraate the inventory process. The 
system needed to read the serial number of the asset, search the 


12 





CMR for a match, and produce a report specifying which serial 
numbers were found. By using bar code technology, MARCORSYSCCM4 
felt the inventory process could be condensed into one week. 

These basic requirements were used to model the new 
system using logical DFDs (see Figures 2.4 and 2.5). Logical DFDs 
are implementation-independent models that display the essential 
requirements of the system—those requirements that must be 
fulfilled no matter how the system might be implemented. These 
models were presented to the end user and the following detailed 
system requirements were drafted: 

1. System will be a fully automated bar code inventory system 
and will meet all specified requirements; 

2. System will use bar code technology; 

3. System will function on an IBM compatible desktop computer; 

4. System will interface with the bar code reader and printer; 

5. System scope will be limited to serialized assets: such as 
computers, laptops, monitors, etc.; 

6. User will provide a CMR file; 

7. CMR will be obtained from an ASCII file contained in an 
external file memory source; 

8. The values of all serial numbers are of alpha-numeric type; 

9. A serial number is a unique identifier—assets will not 
have the same serial number; 

10. The system will produce bar code led;>els to be affixed to 
each asset. User will have the option of producing a batch 
of labels from the CMR or individual labels by manual 
keypunch entry; 


13 








FICPRE 2.A Logical Context Data Flow Dlagraa 


14 














11. System will prompt the user if the item scanned is 
not on the CMR. The user will be prompted for a 
description of the item and its location; 

12. System output will be in CMR format with found serial 
numbers annotated; 

13. System will produce ^ul exception report, listing the 
serial numbers inventoried but not on the CMR; 

14. System will be implemented in Ada or DBase III; 

15. System will be menu driven and be user friendly (will 
not require computer experience to operate the system); 

16. System will be fully documented and a users manual will 
accompemy the system; amd 

17. System will be designed with ease of modification or 
upgrade in mind. 


16 



Ill. SYSTBf DESIGN 


A. INTRODUCTION 

The purpose of the design phase is to design a software 
solution for the new system, including a definition of the 
interfaces among units and a detailed procedxural flow. During 
system design, the target system is orgemized into subsystems 
based on both the analysis structure and the proposed 
eirchitecture. The system designer must decide what perfonaance 
characteristics to optimize, choose a strategy to attack the 
problem, and make tentative resource allocations. 

An Object-Oriented Design (OOD) strategy was employed to 
design the Bar Code Inventory System. This method of design 
results in a software solution that closely resembles the 
real-world problem. Object- Oriented Design incorporates three 
important software design concepts: abstraction, information 
hiding and modularity. "All design methods strive for software 
that exhibits these fundamental characteristics, but only OOD 
provides a mechemism that enables the designer to achieve all 
three without complexity or compromise" [Pressman, 1992, p.395]. 

The Design Phase uses the results of the System Analysis 
Phase to complete several sequential steps. These steps and 
their results are presented in the remainder of this chapter. 


17 



B. OBJECT AMD ATTBIBOTE ZDEMTZFXCATION 


The system requirements and logical data flow diagrams were 
used to identify the objects judged critical to the production of 
the Bar Code Inventory System, (see Figure 3.1). The objects 
identified were derived from nouns used in describing the system. 
An object is a component which exists in the real world—a 
person, place, thing, occurrence, role, or event—that is mapped 
into the software domain. Objects are typically producers or 


Oblecta 

AttribatgQ 

CMR Listing 

File Name 

Status 

Serial Number 

Value 

Position 

Type 

Found 

Bar Code Reader Input 

File Name 

Status 

Bar Code Reader Output 

File Name 

Status 

Inventory 

None 

Report 

File Name 

Type 

File Processor 

File Name 

Type 

Label 

Format 

Size 

Serial Number 

Quantity 

Serial Number File 

File Name 

Size 

PIGDRE 3.1 Obiects and Attributes of BCIS 


18 






consumers of information or an information item. Only those 
objects that played a critical role in the system's purpose were 
included, as these are the items which will eventually be 
implemented as part of the solution. 

Additionally, the defining characteristics or attributes of 
the objects were defined. Attributes eire values or features of 
an object that distinguish one instemce of em object from 
another. For example, the attribute Value helps distinguish one 
serial number from another. Identifying the attributes of an 
object help the progreunmer define the functional relationship 
between two instances of the seune object. For example, the 
system will produce two different reports--a CMR report and an 
exception report. The attribute File Name and Type tell the 
progreunmer that the two reports can be distinguished by the file 
name and the type of report required. 

C. OPERATIONS WITH OBJECTS 

The major objects of interest and their attributes have been 
identified, but that is not sufficient to establish the design of 
the software solution. The next step is to determine the 
operations associated with each object, (see Figure 3.2). This 
was accomplished by considering which operations can be performed 
on or by a peurticulau: object. In identifying the operations 
associated with an object the designer cem characterize the 
external behavior of that object. This external view captures 


19 





ca>i«ct 

CMR Listing 


Serial Number 

Bar Code Reader Input 

Bar Code Reader Output 

Inventory 

Report 

File Processor 

Label 


Serial Number File 


QMratifln 

Open 

Reset 

Close 

Get Serial Number 
Get Line 

Create 

Mark 

Return Value 
Compare 

Create 

Open 

Close 

Add Serial Number 
Get Serial Ntimber 

Open 

Close 

Get Serial Number 
Get Description 
Get Location 

Get Serial Number 
Match Serial Numbers 
Get Location of Asset 
Get Description of Asset 

Create 
Close 
Add Line 

Format Exception Report 

Format Serial Number File 
Format CMR Report File 
Format Exception File 
Format Labels File 

Create 

Open 

Close 

Add Serial Nxamber 
Get Serial Number 
Print Label 

Create 

Insert Serial Number 
Sort by Value 
Sort by Position 
Mark Serial Number Found 
Remove Serial Number 


PIGORE 3.2 Objects and Operations of BCIS 






the behavior of an object from the perspective of its clients 
without concern for how the object will be implemented. By 
separating the behavior of the object from its implementation 
the principles of abstraction emd information hiding are applied. 

D. VISIBILITY RELATICBfSHIPS 

The next step in the Object-Oriented Design process is the 
determination of how these objects relate to one another. To 
establish the visibility relationship, each object is examined to 
determine which objects it depends on emd what objects depend on 
it. 

Figure 3.3 is a graphical representation of the relationships 
between the various objects in the system. An object that points 
to another signifies its dependence on that object. For exeunple, 
the object BCIS depends on all the other objects in the system to 
perform its intended functions. Understanding the relationships 
between objects simplifies the implementation process and 
enforces the principles of modularity and cohesion. Taking 
advemtage of these inherent relationships will result in a 
well-structured system that is easy to modify. 

E. INTERFACE SPECIFICATIONS 

The last step in the development process is to establish a 
detailed design of the BCIS. The results of the prior 
steps--Object and Attribute Identification, Operations 


21 




BCIS Vlaibility Diagram 


22 


















with Objects and Visibility Relationships—were used to orgeuiize 
the target system into subsystems. 

First, a separate package was created for each object. A 
package is a separate compilation unit consisting of two parts: a 
package body emd a package specification. During this step the 
package specification of each object was drafted. The package 
specification can be regarded as the package's "shop-window* that 
says what the package has to offer the potential user. 

Next, the operations associated with each object were 
incorporated into the package specifications. This allows the 
designer to display what operations a package will perform, 
without writing any code. 

Finally, how a package interfaces with the other parts of the 
program was specified. This was accomplished by declaring the 
Visibility Relationships between packages in the package 
specifications. The package specifications for each object are 
listed in alphabetical order in Appendix A. 


23 




ZV. IlfW.niEWTATI(» 

The Implementation Phase used the results of the Analysis and 
Design Phases to create an automated inventory system. During 
implementation the system was divided into four phases—creating 
a serial number file to download to the bar code reader, 
conducting an inventory using the reader, processing the results 
of the inventory into reports, and printing the bar code labels 
that will be attached to the assets prior to em inventory. 

Each phase was implemented separately emd then integrated 
into the Bar Code Inventory System. This chapter will present 
how each phase was developed and the problems that were 
encountered during integration. 

A. CRSATZIiO SERZAL NUMBER FZUE PHASE 

This portion of the system opens the CMR File—an ASCII file 
containing a list of assets that need to be inventoried—and 
searches the file for serial niambers. When a serial nuniber is 
found it is copied to a file called Readin. During the transfer 
process the serial number is converted from the type string to a 
private type. Private type is an Ada convention which limits the 
operations that can be performed on an object outside of the 
obj ect's package. 

In this case, declaring serial number as a private type 
prevents the user from modifying a serial number outside the 


24 









package Serisl Number. This incorporates ed:>straction and 
information hiding and prevents a serial number from being 
inadvertently modified. The private type serial number is a 
record that stores the value of the serial number and its 
position in the CMR. 

Once all the serial numbers are tremsferred to the Readin 
File, an eurray is created. The serial numbers, along with their 
original CMR position, are read into the eurray. Inside the array 
the serial numbers are fojrmatted for the beur code reader. This 
consists of removing any blanks that might be in front of a 
serial ntunber and sorting the serial numbers in alpha-numeric 
order. The formatted serial numbers are then read back into the 
Readin File for download to the bar code reader. 

The Create Serial Number Phase of the system resides on a 
personal computer and incorporates the following packages 
(objects) identified during the System Design Phase--CWR Listing, 
Serial Number, Serial Number File, Bar Code Reader Input and File 
Processor. The operations necessary to extract and format the 
serial numbers from the CMR were implemented using Ada 
programming lanrjuage. A program called DOWNLOAD acts as a driver 
and calls all the operations needed to create the serial number 
file. 


25 




B. mVBITORY PHASE 


The Inventory Phase was implemented using Interactive 
Reader Leuiguage (IRL) euid resides in the bar code reader. This 
program has two major functions: conducting an inventory of the 
command's serialized assets emd transmitting the results of the 
inventory back to a file on a personal computer. 

During the Inventory Function, the user is prompted to enter 
a serial number. The reader receives the serial number that is 
scanned by the user emd searches File A for a match. File A 
contains the serial numbers extracted from the CMR during the 
Create Serial Number File Phase. If the serial number scemned 
matches a serial number on the CMR, the program searches File B, 
the Match File, to see if the asset was already inventoried. If 
the assets has not been inventoried, the serial number is saved 
in File B. If the asset has already been inventoried, the serial 
number is not saved and the user is asked to scan another asset. 

If a serial number does not match the serial numbers 
extracted from the CMR, the reader emits a warning beep and 
prompts the user to enter a description and the location of the 
asset. This information along with the serial number is saved in 
File C, the Not Found File. The inventory portion of the program 
is terminated when the user enters 'F3' instead of a serial 
number. 

During Tremsmit the user is asked which file to tremsmit--the 
Match or Not Found File. A file is then transmitted to a 


26 





personal computer one serial number at a time. If the user 
attempts to transmit a file that does not contain any records an 
error message is displayed and the user is again prompted which 
file to transmit. The Tremsmit portion of the program is 
terminated when the user turns off the reader. 


C. CRIMn RIFORTS PHRSK 

The Create Reports Phase consists of two programs—one for 
the CMR Report and another for the Ebcception Report. 

The program that creates the CMR Report is called CMR_RPT. 
This program was implemented using Ada emd resides on a personal 
computer. The packages (objects) used to create this portion of 
the system are: CMR Listing, Serial Number, File Processor, Bat 
C ode Reader Input, serial Number File, Reader Output, and Report. 
The program CMR_RPT acts as a driver and calls the operations 
that reside in these packages to perform the functions needed to 
convert the results of the inventory into a CMR Report. 

This program opens the CMR File and copies the serial numbers 
along with their CMR position into an array. The Match File is 
then opened and each serial number is matched with the serial 
numbers in the array. When a match is found the serial number in 
the array is flagged as found—a blank space and em 'F' are 
appended to the end of the serial number. When all the serial 
numbers in the Found File have been matched, the file is closed 
and the array is sorted by original CMR position. 


27 




The CMR File is again opened and each line is copied to the 
CMR Report File. If a line contains serial numbers the program 
copies the serial numbers contained in the eurray (i.e., the 
flagged serial numbers) to the CMR Report File instead of the 
original serial numbers. The result is a report that is 
identical to the original CMR with the serial numbers found 
during the inventory marked as found. 

The program that creates the Exception Report is called 
X_REPORT. This program creates em Exception Report File emd 
formats the report for input. This consists of giving the report 
a title, setting the columns in the report emd giving each column 
a header. The program then opens the Not Found File—a file 
uploaded from the reader containing assets found during the 
inventory that were not on the CMR. The serial nvuober, 
description and location of an asset are extracted from the Not 
Found File and transferred to the correct position in the 
Exception Report. 

The Exception Report program resides on a personal computer 
euid incorporates the following packages (objects) identified 
during the System Design Phase—Bar Code Reader Output, Report 
and File Processor. The operations necessary to create the 
report were implemented using Ada progreunming language. 


28 




D. PRIMT BAR CODE LABELS 


The Print Bar Code Led:>els Phase consists of two programs—one 
for creating individual l^d>els and another to produce a batch of 
labels from the CMR listing. Both of the programs were 
implemented using Ada and reside on a personal computer. 

The program that generates individual led^els is called 
PRN_INDIV. This program acts as a driver and calls the 
operations that reside in the package Labels to create bar code 
leUsels. The application generates a screen euid queries the user 
to enter a serial number or 'quit” to exit. If the user enters a 
serial number, the application appends the necessary control 
characters to the serial number and sends this data to the COM2 
port of the personal computer. The Intexmec Bar Code Printer 
accepts the control characters and serial number and produces a 
bar code label. 

The progreun that generates a batch of bar code labels from a 
CMR listing is called PRN_BATCH. This progreun opens the CMR ^uld 
extracts all the serial numbers into a file called Label. Once 
all the serial numbers are transferred to the Label File, an 
array is created. The serial numbers are then read into the 
array to be formatted for the bar code printer. This consists of 
removing any blanks from the front of a serial number and sorting 
the serial numbers in alpha-numeric order. 

The application appends the necessary control characters to 
the serial numbers in the array. The COM2 port is then opened 


29 






for communication with the bar code printer. The serial numbers 
with control ch^u:acters Are sent to the printer via the C<»1 port. 

This portion of the system incorporates the following 
packages (objects) identified dxiring the System Design Phase— CMR 
Listing, Labels, Serial Numbers, Serial Number File, and File 
Processor. The operations contained in these packages were used 
to generate the batch b€u: code labels. 

E. SYSTBI INTBORATZON 

The four phases of the system were developed and tested 
sepeurately emd then integrated into a single b^u^ code inventory 
system. The communication among the various hardware 
platforms—personal computer, bar code reader, and bar code 
printer--proved to be the most difficult portion of implementing 
the system. 

The integrated system needed to pass various files across 
hardware platforms for the system to perform the functions 
specified in the System Requirements. Various approaches were 
tried in an attempt to establish a common protocol and initialize 
the COM port—set the baud rate, parity, number of data bits and 
stop bits--on the computer. 

A communication driver was developed using QBasic to 
ested^lish communication between a bar code reader and personal 
computer. This driver initialized the COM port on the computer 
to match the settings on the reader. The driver then appended 


30 





control characters to the file being transmitted which would 
start and stop communication. This approach proved to be 
ineffective. The communication driver failed to establish 
communication between the personal computer emd reader. 

A commercial communication package called Crosstalk was used 
to establish communication between the personal computer and 
reader. This software package allows the user to estedslish a 
direct connection with other hardware platforms. The program 
initializes the COM port of the computer and allows the user to 
select a protocol to establish communication. The problem with 
this approach was the protocols provided in the software package 
did not match the protocols in the reader. Communication between 
the computer and reader was never established using this 
approach. 

Intermec Corporation, the manufacturer of the bar code reader 
and printer, provided a software p>ackage called InterScan. This 
communications package was designed to establish communication 
between a personal computer and Intermec hardware. The softweure 
initializes the COM port in the computer and the reader. During 
the initial tests this program effectively established 
communication between the personal computer emd reader. When a 
large Serial Number File, with three thousand serial numbers, was 
downloaded to the reader the progreun failed. The package would 
initiate communication but would "time out" before the entire 
file could be downloaded. After further testing, it was 


31 





established that the problem originated from bugs in the 
InterScan software. 

However, the InterScan softweure proved to be effective 
uploading the Match and Not Pound Piles from the reader to the 
personal computer. The software furnishes special IRL commands 
that allow the programmer to send the uploaded data files to 
specified files on the computer. This caped>ility ccmnot be 
achieved with other software applications. The Code 
Inventory System utilizes the InterScan application for uploading 
data files from a reader to a personal computer. 

Intermec Corporation provided smother software package called 
PCIRL. This softwsure was designed as an IRL development system. 
It allows users to create and compile IRL programs on a personal 
computer. The application also provides the capability of 
downloading programs and files to the reader. This package was 
able to download the large Serial Number File to the reader. The 
PCIRL software is utilized in the Bar Code Inventory system to 
download files from the computer to a bar code reader. 

When the communication problem was solved the system was 
integrated into the Bar Code Inventory System. The System 
Requirements specified the system must be menu driven emd user 
friendly. A batch file was developed to create a menu system 
that would execute the necessary progreuns when the user selected 
an option. The batch file was compiled into a .COM file to 
increase the processing speed of the progreim. The .COM file. 


32 



called BCIS, controls the Bar Code Inventory System and is the 
program that integrated the four phases of the system. 


33 






V. CONCLUSION 


This thesis developed a Bar Code Inventory System (BCIS) for 
Marine Corps Systems Command (MARCORSYSCOM). Ada and Interactive 
Reader Language were used as the programming lemguages to 
implement this system. 

The BCIS is a fully integrated, menu-driven system that will 
automate the inventory process at MARCORSYSCCM. This system 
extracts the serial numbers from the command's CMR—a listing of 
all assets owned by the comm 2 uid—and downloads them into a bar 
code reader. During the inventory, the system informs the user 
if the asset inventoried is not on the CMR. The system saves the 
information gathered during the inventory amd produces two 
Reports—a CMR and an Exception Report. The system also produces 
the bar code labels, which are attached to the commemd's assets. 

The BCIS is fully tested and ready for implementation at 
MARCORSYSCOM. The system meets all the requirements specified by 
Captain Lang, the Resource Manager for the Information Systems 
Management Division at MARCORSYSCOM. 





APPENDIX A 


SOURCE CODE 

This appendix contains the source code used to implement the 
Bear Code Inventory System. The Programs, Package Definition 
Specifications, Package Definition Bodies, and batch files are 
included in this section and are listed in alph 2 d:>etical order. 


35 





I” "" " - ----—---— 

rem BCIS.COM 

ran- 

rem - This [ungram integrated die BCIS by creating a moiu driven system ttiat calls all the 
rem - odier programs. 

ran- 

@ECHO OFF 

ran- 

rsDD - This batch file automates the Bar Code Inventory System by creating a nraiu sysran and 
rem - calling all die applications needed to perform die desired fimctioiL 
ran- 


ran-:- 

rem - The DRAWMAIN procedure creates the main menu for the systeuL The user is prompted 
rem - to enter the number in front of die wanted function 

ran- 


:DRAWMAIN 
CLRSCR 07 
CLRSCR 40 1 20 7 60 
SETPOS 1 20 
DRAWBOX 4E 41 7 2 
SETPOS 4 28 

TEXTOUT 4F "BAR CODE INVENTORY SYSTEM" 
CLRSCR IF 10 15 23 64 
SETPOS 12 27 

TEXTOUT IF "1. Download File to Reader" 

SETPOS 14 27 

TEXTOUT IF "2. Receive Inventory Results" 

SETPOS 16 27 

TEXTOUT IF "3 Print Reports" 

SETPOS 18 27 

TEXTOUT IF "4. Print Bar Code Labels" 

SETPOS 20 27 

TEXTOUT IF "5. Exit to DOS" 

SETPOS 22 40 

TEXTOUT IF "ENTER (1..5) " 


rem Procedure DRAWMAIN 

rem creates a red box 
rem sets posdon of cursor 
rem puts outline around box 

rem outputs text to screen 
rem creates a blue box 

rem ouQiuts text to screen 


ran- 

rem - Procedure GETKEY uses the program BATCHKEY.COM (must be in same dir) to get the 
rem - users selection and assigns the users selection to an errorlevel which is used to branch to 
rem - die desired procedure 

ran- 


36 












;GETKEY 

BATCHKEY "12345" 

IF ERRORLEVEL 5 GOTO END 
IF ERRORLEVEL 4 GOTO LABELS 
IF ERRORLEVEL 3 GOTO REPORTS 
IF ERRORLEVEL 2 GOTO RECEIVE 
IF ERRORLEVEL 1 GOTO DOWNLOAD 
GOTO GETKEY 


rem if user enters 5 goto aid (vocedure 
ran if user enters 4 goto labels procedure 
rem if user entos 3 goto rqx»ts (vocedure 
rem if user alters 2 goto receive procedure 
rem if usa enters 1 goto download {vocedure 
rem if usa alters wnxig choice try again 


rem- 

rem - Procedure DOWNLOAD changes to the Ada directory where die Ada program Download 
rem - is located. Starts the program which will produce the file READIN which wiU be 
rem - downloaded to die reada using PCIRL. This procedure copys diis file to C:\PCIRL thoi 
rem - changes to diat directory and starts the qiplication. When die usa is finished downloading 
rem - the is letumed to the main menu 

rem- 

DOWNLOAD 
CLRSCR07 
SETPOS 23 35 

TEXTOUT 4F "EXTRATING SERIAL NUMBERS FROM CMR." 

CD\BCIS\ADA 

CALL DOWNLOAD 

COPY READIN C:\PCIRL >NUL 

CD\PCIRL 

CALLPCIRI. 

CD\BCIS 

GOTO DRAWMAIN 


rem- 

rem - The RECEIVE procedure creates the menu for die reveive portion of die system. The usa 

rem - is prompted to enter the number in front of the wanted fimction 

rem- 


:RECEIVE 

CLRSCR 07 

CLRSCR IF 1 20 7 60 

rem 

creates a blue box 

SETPOS 1 20 

rem 

sets postion of cursor 

DRAWBOX ID 41 7 2 

rem 

puts outline around box 

SETPOS 4 30 

TEXTOUT IF "RECEIVE FILE OPTIONS" 

CLRSCR 3F 10 15 23 64 

rem 

creates a cyan box 

SETPOS 12 27 

TEXTOUT 3F "1. Receive Found File" 

SETPOS 15 27 

TEXTOUT 3F "2. Receive Not Found File" 




37 










SETPOS 18 27 

TEXTOUT 3F "3. Receive Botfi Files" 

SETPOS 21 27 

TEXTOUT 3F "4. Exit to Main Menu" 

SETPOS 23 40 

TEXTOUT 3F "ENTER (1..4) " 

rem- 

rem • Procedure RECEIVEGET uses die program BATCHKEY.COM (must be in same dir) to 
rem - get the users sekctkm and assigns die users selection to an eanxlevel inliicli is used to 
rem - bnr h to die desired procedure 

rem- 

JIECEIVEGET 
BATCHKEY "1234" 

IF ERRORLEVEL 4 GOTO DRAWMAIN rem if user enters 4 goto labels procedure 
IF ERRORLEVEL 3 GOTO BOTH rem if user enters 3 goto repeals {vocedure 

IF ERRORLEVEL 2 GOTO NOTFOUND ran if user enters 2 goto receive procedure 
IF ERRORLEVEL 1 GOTO FOUND rem if user mters 1 goto download procedure 

GOTO RECEIVEGET ran if wremg value entered waits for anodier try 

rem- 

rem - The FOUND procedure dianges to the INTRSCAN diiectmy where die found will be 
rem - uploaded Iran the reader. 11^ procedure opies an existing found file to found.bak then 
rem - (teletes die found file. The new found file b then uploaded from the bar code reader. The 
rem - file is opied to the ada directory and die program CMR_RPT is executed. When 
rem- completed die user is returned to the receive menu 

rem- 

FOUND 

CDMNTRSCAN 

COPY FOUND FOUND.BAK >NU1. 

DEL FOUND >NUL 

CALL INTRSCAN rem execute intrscan program 

CD\BaS 

CLRSCR 07 

SETPOS 23 35 

TEXTOUT 4F "CREATING CMR REPORT.." 

CDMNTRSCAN 

COPY FOUND C:\BaS\ADA >NUL 

CD\BaS\ADA 

CALL CMR_RPT 

CDNBQS 

GOTO RECEIVE rem returns to receive menu 


38 











rem- 

rem - The NOTFOUND procedure changes to the INTRSCAN directory where die NOFTND file 
rem - will be uploaded from the reader. This procedure cq)ies an existing NOFIND file to 
rem - NOFIND.BAK then deletes the NOFTND file. The new NOFIND file is then uploaded 
rem - from the bar code reader. The file is copied to the ada directory and the program 
rem - X_REPORT is executed. When completed the user is returned to tiie receive menu 
rem- 

:NOTFOUND 

CDMNTRSCAN 

COPY NOFIND NOFIND.BAK >NUL 

DEL NOFIND >NUL 

CALL INTRSCAN 

CDVBCIS 

CLRSCR 07 

SETPOS 23 35 

TEXTOUT 4F "CREATING EXCEPTION REPORT." 

CDMNTRSCAN 

COPY NOFIND C:\BCIS\ADA >NUL 

CD\BCIS\ADA 

CALL X.REPORT 

CD\BCIS 

GOTO RECEIVE rem returns to receive menu 

rem- 

rem - The BOTH procedure performs the same frmctions as the FOUND and NOT FOUND 
rem - procedures. It combines the operations of those two procedures into a single procedure 
rem - for the users convenience. 

rem- 


:BOTH 

CDMNTRSCAN 

COPY FOUND FOUND.BAK >NUL 

DEL FOUND >NUL 

COPY NOFIND NOHND.BAK >NUl. 

DEL NOFTND >NUL 
CALL INTRSCAN 
CD\BCIS 
CLRSCR 07 
SETPOS 23 35 

TEXTOUT 4F "CREATING CMR AND EXCEPTION REPORTS." 

CDMNTRSCAN 

COPY FOLTND C:\BCIS\ADA >NUL 
COPY NOFIND C:\BCIS\ADA >NUI. 

CD\BCIS\ADA 
CALL CMR RPT 


39 













CALLX_REPORT 

CDNBCIS 

GOTO RECEIVE rein returns to receive menu 

rem- 

rem - The REPORTS procedure creates die menu fmr die nports poitkm of the system. The user 

ran - is ixtuiq^ to enter die number in fixmt of die wanted fuiK^kHi 

ran- 

•J^EPORTS 

CLRSCR07 

CLRSCR 74 1 20 7 60 rem creates a white box 

SEIPOS 1 20 rem sets postkm of curs<x’ 

DRAWBOX 74 4] 7 2 rem puts outline around box 

SETPOS 4 30 

TEXTOUT 74 "PRINT REPORT OPTIONS" 

CLRSCR 3F 10 15 23 64 rem creates a cyan box 

SETPOS 12 27 

TEXTOUT 3F "1. Print CMR Report" 

SETPOS 15 27 

TEXTOUT 3F "2. Print Exception Report" 

SETPOS 18 27 

TEXTOUT 3F "3. Print Both Reports" 

SETPOS 21 27 

TEXTOUT 3F "4. Exit to Main Menu" 

SETPOS 23 40 

TEXTOUT 3F "ENTER (1..4) " 

rem - 

rem - Procedure REPORTGET uses die program BATCHKEY.COM (must be in same dir) to 
rem - get die users selection and assigns the users selection to an errorlevel which is used to 
rem - branch to die desired procedure 

rem- 

REPORTGET 
BATCHKEY "1234" 

IF ERRORLEVEL 4 GOTO DRAWMAIN rem if user mteis 4 goto main menu 

IF ERRORLEVEL 3 GOTO BOTHRPTS rem if user enters 3 goto bodupts procedure 

IF ERRORLEVEL 2 GOTO XRPT rem if user enters 2 goto XRPT procedure 

IF ERRORLEVEL 1 GOTO CMRRPT rem if user enters 1 goto CMRRPT procedure 

GOTO REPORTGET rem if wrong value ratered waits fcM* anodier try 

rem- 

r^ - Ihe CMRRPT procedure displays a message on the screen that die CMR REPORT is 
rem - printing. The procedure changes to die directory where REPORT is located and sends the 
rem - report to die printer. When finished the procedure returns die user to die reports menu, 
rem- 


40 











.CMRRPT 
CLRSCR 07 
SETPOS 22 38 

TEXTOUT 4F "PRESS ENTER.." 

SETPOS 23 35 

TEXTOUT 4F "PRINING CMR REPORT." 

SETPOS 40 1 
CD\BCIS\ADA 
PRINT REPORT 
CD\BaS 
GOTO REPORTS 

rem- 

rem - Tlie XRPT procedure displays a message on die screen that the XREPORT is printing, 
rrai - The procedure changes to the direct<»y where XREPORT is located and said die rep<»t to 
rem - die printer. When finished die procedure returns the user to the reports menu. 
ran - 


:XRPT 
CLRSCR 07 
SETPOS 22 42 

TEXTOUT 4F "PRESS ENTER." 

SETPOS 23 35 

TEXTOUT 4F "PRINT!! IG EXCEPTION REPORT.." 

SETPOS 40 1 
CD\BCIS\ADA 
PRINT XREPORT 
CD\BCIS 
GOTO REPORTS 

rem- 

rem - The procedure BOTHRPTS prints both die CMR REPORT and the XREPORT. It 
rem - perfoims die same operatioiis as die above two procedures and is included for user 
rem- convenience. 

ran- 

BOTHRPTS 
CLRSCR 07 
SETPOS 22 46 

TEXTOUT 4F "PRESS ENTER." 

SETPOS 23 35 

TEXTOUT 4F "PRINTING CMR AND EXCEPTION REPORTS." 

SETPOS 40 1 

CD\BaS\ADA 

PRINT REPORT XREPORT 

CD\BaS 

GOTO REPORTS 


41 












- Ibe LABELS procedure aeates the menu fcM* printing bar code labels. The user is 

- prcunpted to eider the numbCT in frcMit of the wanted function 


T^TiT 


OABELS 

CLRSCR07 

CLRSCR 4F 1 20 7 60 rem creates a red box 

SETPOS 1 20 rem sets postion of cursor 

DRAWBOX 40 41 7 2 ran puts outline around box 

SETPOS 4 26 

TEXTOUT 4F "PRINT BAR CODE LABEL OPTIONS" 

CLRSCR 3F 11 IS 23 64 rem creates a cyan box 

SETPOS 14 27 

TEXTOUT 3F "1. Print Batch Labels" 

SETPOS 17 27 

TEXTOUT 3F "2. Print Individual Labels" 

SETPOS 20 27 

TEXTOUT 3F "3. Exit to Main Menu" 

SEIPOS 23 40 

TEXTOUT 3F "ENTER (1..3) " 

rem- 

rem - Procedure LABELGET uses die program BATCHKEY.COM (must be in same dir) to get 
rem • the users selection and assigns the users selection to an errOTlevel which is used to branch 
rem - to the desired procedure 
rem- 

iABELGET 
BATCHKEY "123" 

IF ERRORLEVEL 3 GOTO DRAWMAIN 
IF ERRORLEVEL 2 GOTO INDIV 
IF ERRORLEVEL 1 GOTO BATCH 
GOTO LABELGET 

rem- 

ran - The procedure BATCH initializes COM2 for cmnraunication witti die bar code printer. The 
rem - procedure moves to die directory where PRN_BATCH is located and executed the 
ran - program. Hie user is dien returned to dielabels menu. 

rem- 

BATCH 

MODE COM2; BAUI>=96 PARITY=E DATA=7 STOP=l >NUL 
CLRSCR 07 
SETPOS 23 35 

TEXTOUT 4F "PRINTING BAR CODE LABELS." 

42 


rem if user enters 4 goto main menu 
rem if user enters 2 goto INDIV jvocedure 
rem if user alters 1 goto BATCH {micedure 
rem if wrong value altered waits fa* anotha try 











SETPOS 40 1 
CD\BaS\ADA 
CALL PRN_BATC 
CDVBCIS 
GOTO LABELS 

rem- 

ran - The procedure INDIV inf»ialKr<>s COM2 communkalion widi die bar code printer. Hie 

rem - procedure moves to the direct<»u where PRN.INDI located and exeoites the ptogran. 
The 

rem - user can dim print as many bar code labels as he needs. Ibe user is dien r^umed to die 
rmi- labels menu. 

ran- 

JNDIV 

MODE COM2: BAUD=96 PARITY=E DATA=7 STOP=l >NUI. 

CD\BCIS\ADA 
CALL PRN_INDI 
CDNBCIS 
GOTO LABELS 

rem- 

rem - The end procedure exits die user from the batch file and cleats die screen. This is the end 
rem - of die inrogram 

rem- 

:END 

CLRSCR 07 
SETPOS 1 0 
C:\ 





- TnUE : CMR LISTING package definitiOQ q)ecificatioiis 

- NAME : Ridiard Hancock 

-DATE : 28 July 1993 

- DESCRIPTION : This padiage contains aU <^)entions associalBd witfi the object CMRL, 

- : whidi stands for CMR Us^. This object: is an ASCII file ccadaming a 

- : listing of all assets a req>oi»ible ofHcei is accountable fix*. The fonnat of 

- : die CMR is fixed. This package contains operatkaos that will OI^N, 

- : CLOSE, and RESET die file. It also contains <^)entions dot will seardi 

- : the CMR and pull out all the serial numbers or search the CMR and get 

- : each line. A Detailed descriptkm of each of the <^>eraitions is provided in 

- : die padcage body. 


with SERIAL.NUMBERS; use SERIAL_NUMBERS; 
package CMRL is 

{xocedure OPEN (NAME : in STRING); 
procedure RESET (NAME : in STRING); 
procedure CLOSE (NAME : in STRING); 

procedure GET_SN (SN : out SERIAL.NUMBER); 

procedure GET_LINE (LINE : out STRING; LAST: out NATURAL); 

function ENDOF_FILE return BOOLEAN; 

OPEN_ERROR .‘exception; 

RESET_ERROR: exception; 

CLOSE_ERROR : exception; 


end CMRL; 









~ TITLE : CMR LISTING package definitkm body 

*- NAME ; Richard Hancock 

— DATE : 28 July 1993 

~ DESCRIPTION : This padcage contains all opentkxis associated wiA the object CMRL, 

: which stands fw CMR Listing. This object is an ASCII fite c ontaining a 
~ ; listing of aU assets a resp<Htsibie officer is accountri>te fw. The fonnat of 

— : the CMR is fixed. This package (xntains operations diat will OPEN, 

— : CLOSE, and RESET the Ale. It also cn ntains operations that will search 
: die CMR and {mil out all dieserial numbers or seardi the CMR and get 

— : each line. A Detailed description of each of the tolerations is {irovided in 

— : the package body. 


with TEXTJO; use TEXT JO; 


package body CMRL is 

CMRL_FILE 

: FTLE_TYPE; 

MORE_SERIAL_NUMBERS 

: BOOLEAN := fake; 

LAST_LINE_HAD_SERNRS 

: BOOLEAN := fake; 

SN_COUNT 

: INTEGER; 

END_OF_FILE 

: BOOLEAN - fake; 


-PROCEDURE OPEN- 

— This procedure opens die CMRL Ale. The name of die Ale to be ojiened is passed to this 

- procedure from the calling procedure. Ihis procedure sets the default input to be the CMRL 
-- Ale. 


procedure OPEN (NAME ; in STRING) is 
begin 

TEXTJO.OPEN (CMRL_FILE, IN_FILE, NAME); 
TEXTJO.SET.INPUT (CMRI._FILE); 
exception 

when odiers => 

raise OPEN_ERROR; 


end OPEN; 


45 










-PROCEDURE RESET- 

- This procedure assumes the same file name is passed as when die CMRL file was opened. It 

- resets die file so diat reading from its elements can be restarted from die beginning (Le., resets 
the pointer to die beginning of die file). Sets the file as die cunent iniHit file and res^ the 

- End-of-File Flag. 


jmicedure RESET (NAME ; in STRING) is 
begin 

TEXTJO.RESET (CMRIv.FILE, IN_FILE); 
TEXT_IO.SET_INPUT (CMRL_FILE); 
END_OF_FILE “ false; 

exception 
when others => 

raise RESET_ERROR; 

end RESET; 


-PROCEDURE CLOSE- 

This procedure closes the CMRL file and the defauh input is set to standard (i.e., keyboard). 


procedure CLOSE (NAME ; in STRING) is 
begin 

CLOSE (CMRL.FILE); 

TEXT_IO.SET_INPUT (TEXT_IO.STANDARD_INPUT); 

exception 
when others => 

raise CLOSE_ERROR; 

end CLOSE; 


46 







-PROCEDURE GET_SN- 

~ This procedure reads in the liist 18 characters of each line of the CMRL file. If the line has a 
" serial number, it reads die serial number into a 22 character field and converts the type string 

- to type smal number (private type) widiout changing the value. This serial number type is 

— passed back to the caUing procedure. This procedure continues to read in and process serial 
~ numbers until the end of line. Then it skips to die next line and continues to search fu-serial 
~ numbers until the end of file. 


procedure GET_SN (SN : out SERIAL_NUMBER) is 

SER_NR : STRING (1 ..22); 

HEADER : STRING (1.. 18); 

JUNK_CHAR : CHARACTER; 

COLUMN : TEXTJO.count; 

LINE ; TEXTJO.counl; 

begin 

if not MORE , SERI AL_NUMBERS then -- have a new line 

SN_COUNT := 0; -- set serial number count to 0. 

loop 

TEXTJO.get (CMRL_FILE, HEADER); - get first 18 chars in line 
exit when HEADER = " SER NRS 

exit when LAST_LINE_HAD_SERNRS AND HEADER = " "; 

LAST_LINE_.HAD_SERNRS := false; -- if line just read in had no serial 

TEXT_IO.skip_line (CMRL_FTLE); numbers dien reset flag 

end loop; 

LAST_LINE_HAD_SERNRS ;= true; -- now have a line widi serial #'s 
end if; ~ so next time around this state 

-- will be true. 

if SN_COUNT> 1 then 

get (CMRL_FILL, JUNK_CHAR); — special case where serial #'s in 
end if; -columns 3-5 have 23 vice 22 chars 

for CHAR in 1 ..22 loop ~ read the sn in to a 22 char field 

get (CMRL.FILE, SER_NR(CHAR)); 
end loop; 

SN_COUNT := SN_COUNT + 1; - increment our count 

if not TEXT_IO.END_OF_LINE then — if we haven't reached die end of 

MORE_SERIAL_NUMBERS := TRUE; — the line then we have more sn's 
else ~ other wise we don't. 

MORE_SERIAI._NUMBERS := FALSE; 
skip_line (CMRL_FILE); 
end if; 

SERIAL_NUMBERS.CREATE (SER_NR, SN); — create a sn record(private type) 


47 









exception 

when TEXT_IO.END_ERROR => 

END_OF_FILE := Inie; 
when CONSTRAINT_ERROR => 

TEXTJO.PUT_LINE (STANDARD.OUTPUT, "-CONSTRAINT_ERROR raised 

reading in from CMRL 

when odiers => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "»CONSTRAINT_ERROR raised 

reading in from CMRL 

end GET_SN; 


-PROCEDURE GET.UNE- 

- This procedure reads a full line from the CMRL into a 150 char string and returns the string 
~ and die position of the last char in the line. 


procedure GET LINE (LINE : out STRING; LAST: out NATURAL) is 
begin 

TEXTJO.GET.LINE (CMRL_ni.E, LINE, LAST); - get the full line 
exception 

when TEXTJO.END_ERROR => 

END_OF_FILE := true; 
when CONSTRAINT_ERROR => 

TEXTJO.PUT_LINE (STANDARD.OUTPUT, CONSTRAINT_ERROR 

raised reading in from CMRL ~"); 

when others " > 

TEXT_IO.PU r_UNE (STANDARD_OUTPUT, "-CONSTRAINT ERROR raised 
reading in from CMRL -"); 

end GET_LINE; 


-FUNCTION ENDOFJTLE- 

— This function returns the value of the £nd-of-File flag. Ihe flag is initially set to false but is 

— changed to true when an END_OF_FILE exception is raised in either the GET_SN or 
-- GET_LINE procedures. 


function ENDOF_FILE return BOOLEAN is 
begin 

return END_OF_FILE; 
end ENDOF_FILE; 


end CMRL; 


48 






- TITLE : CMR REPORT 

-- NAME : Richard M. Hancock 

-DATE : 08 Aug 1993 

~ DESCRIPTION : Hiis procedure is the main driver for die Report portion of die Bar Code 

: Inventory System. This Part of the system opens die found file which as 
; was uploaded to the computer iq>on conqiletion of die inventory. This 
~ : proce^e formats the soial numbers (sqqiends blanks to die front of each 

~ : serial number to return dim to 22 character fields). The serial numbm 

— : are flaged as found (ie a space and an F is appmded to die serial number 

: to identify which serial numbers were found during the inventory). The 

~ : serial numbers are dien sorted, ie returned to dieir original ordo* when 

: extracted from die CMRL. The CMRL is dien opened and each Une is 
: copied to a File called REPORT. When a line is extracted from die 
: CMRL it is searched for serial numbers, if serial numbers are found diey 
: are replaced with the serial numbers that have been flaged, dius 
: producing a final report in CMR format of which serial numbers were 
: found during the inventory. The system was designed using die object 
: oriented approach and each package is an object dial was identifed during 
; the design phase. All operations concerining a particular object will be 
; found in that Package. The Packages used in this portion of the system 
: are CMRL, READER_INPUT, READER_OUTPUT, 

: SERIAL_NUMBERS, SN_ARRAY, FILE.PROCESSOR and REPORT 


with CMRl,; with READER INPUT; with READER_OUTPUT; with REPORT; 

with SERIAL_NUMBERS; use SERIAL_NUMBERS; 

with SN_ARRAY; use SN_ARRAY; 

with FILE.PROCESSOR; use FILE.PROCESSOR; 

with TEXT.IO; use TEXT.IO; 

procedure CMR.RPT is 


CMRl-.FflE.NAME 
REPORT .FILE.NAME 
READER.INPUT.FILE.NAME 
READER.OUTPUT.FILE.NAME 


; STRING (1..4) .•= "CMRL"; 

: STRING (1..6) := "REPORT"; 
: STRING (1..6) := "READIN"; 
: STRING (1..5) := "FOUND"; 


SN : SERIAL.NUMBER; 

SN.COUNT : INTEGER := 0; 
ARR_PTR ; ARRAY.POINTER; 


begin 

CMRL.OPEN (CMRL.FILE.NAME); 

READER INPUT.CREATE (READER, INPUT.FBLE.NAME); 


49 






k>q} 

CMRL.GET_SN (SN); 

exit when CMRL.ENDOF JTLE; 

SN.COUNT := SN.COUNT + 1; 

READERJNPUT.ADD_SN (SN); 
endk>Of>; 

CMRL.RESET (CMRL_FILE_NAME); 

READER^INPUT.CLOSE_OUTPUT (READER^INPUT_FILE_NAME); 
SN_ARRAY.CREATE_^ARRAY (SN.COUNT, ARIU*Tlt); 

FORMAT_SERNR_FILE (SN.COUNT, READER„INPUT_FILE_NAME, ARILPTR); 
FORMAT_CMRJlEPORT_FILE (SN.COUNT, READER_OUTPUT_FILE_NAME, 

REPORTJTLE.NAME, ARR_PTR); 
CMRL.CLOSE (CMRL_FILE_NAME); 


exception 

when CMRL.OPEN_ERROR => 

TEXTJO.PUTJJNE (STANDARD.OUTPUT, "Error OPENING file CMRL"); 
when CMRI..RESET_ERROR => 

TEXTJO.PUT_JJNE (STANDARD_OUTPUT, "Error RESETTING file CMRL"); 
when CMRL.CLOSE_ERROR => 

TEXTJO.PUT.LINE (STANDARD.OUTPUT, "Error CLOSING file CMRL"); 

when READER_INPUT.CREATE_ERR0R => 

TEXTJO.pUT_LINE (STANDARD.OUTPUT, "Error CREATING file READIN"); 
when READER_INPUT.OPEN_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error OPENING file READIN"); 
when READER_INPUT.CLOSE_ERROR => 

TEXT_IO.PUTa.INE (STANDARD_OUTPUT, "Error CLOSING file READIN"); 

when READER_OUTPUT.OPEN JRROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error OPENING file FOUND.DAT"); 
when READER_OUIPUT.CLOSE_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error CLOSING file FOUND.DAT"); 

when REPORT.CREATE_ERROR => 

TEXT_IO.PUTJJNE (STANDARD_OUTPUT, "Error CREATING file REPORT"); 
when REPORT.CLOSE_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error CLOSING file REPORT"); 


endCMRJlPT; 


50 









F 


-TITLE : Download 

- NAME : Richard M. Hancock 

- DATE : 05 Aug 1993 

— DESCRIPTION : Diis procedure is die main driver die for download portion of the Bar 

: Code lnventor>’ Systm. This part of die system opens the CMRL file 

- : (ASCn file) provided by the user and extracts all the serial numbers into 

: a Readin file. These serial numbers are dien fmmatted (any blanks at the 

— ; front of die serial numbers are removed) and the file b srxted into 

: alpha-numeric ascending order prim* to download to d^ bar code reada*. 

; Ihis portion of die system is necessary before die actual invait<»y is 
: conducted. The system was designed using die object uimted aj^noadi 
: and each package is an object that was identified during die design phase. 
: All operations concerning any object may be found in diat Package. The 

— : Packages used with this portion of the system are CMRL, 

: READER_INPUT, SERIAL.NUMBERS, SN_ARRAY, and 
: FILE_PROCESSOR. 


with CMRL; with READER_INPUT; 

with SERIAL_NUMBERS; use SERIAL.NUMBERS; 

with SN_ARRAy; use SN.ARRAY; 

with FILE_PROCESSOR; use FELE.PROCESSOR; 

with TEXT_IO; use TEXT.IO; 

procedure DOWNLOAD is 

CMRL_FILE_NAME : STRING (1..4) ~ ’’CMRL"; 

READER_INPUT_FILE_NAME : STRING (1 ..6) := "READIN"; 

SN : SERIAL_NUMBER; 

SN_COUNT : INTEGER 0; 

ARR_PTR ; ARRAY_POINTER; 

begin 

CMRL.OPEN (CMRL_FILE_NAME); 

READER_INPUT.CREATE (READER_INPUT_FILE_NAME); 
loop 

CMRL.GET_SN (SN); 

exit when CMRIv.ENDOF_FILE; 

SN.COUNT := SN_COUNT + 1; 

READER_INPUT.ADD_SN (SN); 
end loop; 

CMRL.CIX)SE(CMRL_FnE_NAME); 

READER_INPUT.CLOSE_OUTPUT(READER_INPUT_FILE_NAME); 
SN ARRAY.CREATE_ARRAY (SN_COUNT, ARR.PTR); 


51 








FORMAT_SERNR_FILE (SN_COUNT, READER_INPUT_F1LE_NAME, ARR_PTR); 


exception 

when CMRL.OPEN_ERROR => 

TEXT_IO.PUT_UNE (STANDARD.OUTPUT, "Enor OPENING file CMRL"); 
when CMRL.CLOSE_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error CLOSING file CMRL"); 

when READER_INPUT.CREATE_ERROR => 

TEXT_IO.PUT_LINE (STANDARD.OUTPUT, "Error CREATING file READIN"); 
when READER_INPUT.OPEN_ERROR => 

TEXTJO.PUT.UNE (STANDARD .OUTPUT, "Error OPENING file READIN"); 
when READER_INPUT.CLOSE_ERROR => 

TEXTJO.PUT.LINE (STANDARD_OUTPUT, "Error CLOSING file READIN"); 


end DOWNLOAD; 






- TITLE : Exception Report 

- NAME : Richard M. Hancock 

-DATE : 11 Aug 1993 

- DESCRIPTION ; This procedure is the main driver the for iq>loading the NoFind flie from 

: the bv code reader. This procedure creates an Excq)tion Rqxxt file and 

- ; and opens die NoFind nie. F(»inats tiie repent by givii^ die report a title 

- : and column headings. The jnrocedure then gets the serial number, 

~ : descr^tiem and location of the asset not em the CMR and {Hits it in the 

~ : r^rt, under die appropriate heading. This is continued until die end of 

: file flag is raised for the NoFind file. The Packages used with this portion 

- : of the system are CMRL, READOIJNPUT, SERIAL_NUMBERS, 

: SN_ARRAY, and FILE_PROCESSOR. 


with READER.OUTPUT; with REPORT; 

with FILE_PROCESSOR; use FILE_PROCESSOR; 

with TEXT JO; use TEXT JO; 

procedure X_REPORT is 

REPORT_FE.E : FILE_TYPE; 

REPORT_FILE_NAME : STRING (1 ..7) .*= "XREPORT"; 

READER. OUTPUT.HLE NAME : STRING (1 ..6) := "NOFIND”; 

begin 

CREATE (REPORTJTLE, OUT_FILE, REPORT_FILE_NAME); 

SET_OUTPUT (REPORT_FILE); 

FORMAT_EXCEPTION_JILE (READER_OUTPUT_FILE_NAME, REPORT_FILE); 
CLOSE (REPORT_FnT); 

exception 

when READER_OUTPUT.OPEN_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT , "Error OPENING file NOHND"); 

when READER_OUTPUT .CLOSE_ERROR => 

TEXTJO.PUT_LINE (STANDARD_OUTPUT, "Error CLOSING file NOFIND"); 


end X_REPORT; 


53 







-TITLE ; FILE PROCESSOR definitioD package specifkatkxis 

- NAME : Richard Hancock 

-DATE : 17 July 1993 

- DESCRIPTION : This padcage contains all (^)erations associated with die <d>jed FILE 

- : PRO^SSOR. The operadcuis are necessary to foraiat the files that will 

: be passed between difToent hardware platf<xins. The Package petfcxins 

- ; operatkms on files such as ranoving any blank q>aces fhnn serial 

- : numbers before diey are passed to die Imt code reader and ai^ the 

: inventory is c<«npleted the serial numbers dial found are flaged and 

: returned to their origninal lengdi of 22 diaracters. A detailed descr^tion 
: of each of the operations is provided in die package body. 


with SN_ARRAY; use SN.ARRAY; 
with TEXT JO; use TEXT JO; 

package FILE_PROCESSOR is 


REPORT_FILE : FILE_TYPE; 


procedure FORMAT_SERNR_FILE (SN.COUNT : in INTEGER; 

SERNR_FILE :m STRING; 

ARR PTR : in ARRAY.POINTER); 

procedure FORMAT CMR_REPORT_FILE (SN_COUNT ; in INTEGER; 

SOURCE_FILE: in STRING; 
DEST.FHE : in STRING; 

ARR_PTR : in ARRAY.POINTER); 

procedure FORMAT_EXCEPTION_FILE (SOURCE_FILE : in STRING; 

REPORT.FHE: in FILE.TYPE); 

procedure FORMAT_LABELS_FILE (SN. COUNT : in INTEGER; 

LABEL_FILE ; in STRING; 

PRINT.FILE : in STRING; 

ARR.PTR : in ARRAY_POINTER); 


end FILE.PROCESSOR; 


54 











-TITLE : FDLE PRCMDESSOR defmkkm package body 

- NAME : Richard Hancock 

-DATE : 17 July 1993 

- DESCRIPTION : Tliis package coatains all operations associated with the object FILE 

- : PROCESSOR. The <^>etatioDS are necessary to fonnat the files tfiat will 

- ; be passed between different hardware platforms. The Package petfonns 

- : <^)eratioiis on flies such as removing any Uaidc q»ces frnn serial 

- : numbers befcm diey are passed to the Iw code reader and after the 

~ ; invait<My is completed die smal numbers that found are flagged and 

- : returned to dietr (uiginal loigth of 22 characters. A detailed desaiptkm 

: of each of the <^>erati<»is is {n-ovided in die padcage body. 


with SERIAL_NUMBERS; use SERIAL.NUMBERS; 
with TEXT JO; use TEXT JO; 
with READER JNPUT; with READER.OUTPUT; 
with REPORT; with CMRL; with LABELS: 

package body FILE_PROCESSOR is 

-PROCEDURE F0RMAT„SERNR_F1LE- 

— This procedure opens the file READIN, which contains the serial numbers extracted from 

— die CMR and formats this file for the bar code reader. The serial numbers in the file are 22 

— characters long, this procedure reads each smal number into an array and removes any blank 

— spaces in front of die serial number. The array is scHled in alpha-numeric wder and then read 

— back to the original file caUed READIN. This file is then going to be downloaded to the bar 

— code reader. 


procedure FORMAT SERNR_FILE (SN_COUNT : in INTEGER; 

SERNR_Fn.£ : in STRING; 

ARR_PTR : in ARRAY_POINTER) is 


VALUE : STRING (1..22); 
INDEX : INTEGER “ 0; 

SN ; SERIAL_NUMBER; 


begin 

READER_INPUT.OPEN_INPUT (SERNR_FnL); 
for I in l..SN_COUNT loop 
READER_INPUT.GET_SN (SN); 
SN_ARRAY.INSERT_SN a,SN,ARRJ*TR); 
end loop; 

READER JNPUT.CLOSE JNPUT (SERNR_FILE); 
READER_INPUT.OPEN. OUTPUT (SERNR. FIIL); 


~ open sn file 

— for die number 
-of serial nums 

- get one and place 

- it in die sn array 
-close the file to input 

— reopen it for output 


55 











SN_ARRAY.S0RT_BY_VALUE (SN_COUNT,ARR_FrR); 


- sort su's 


for I in l..SN_COUNT kx^ 

VALUE := SER1AL_NUMBERS.VALUE (SN_ARRAY.REMOVE_SNa,ARR_PTR)); 
for Jin 1..22 loop 

ifVALUE(J..J)/= then - foreacfasninttie 

INDEX := J; - anay, get its vahie 

exit; - ronove any blanks 

mdif; - and output it to the 

end loop; - Ixur code reader iiqMit file 

READER_INPUT.ADD_SN (VALUE (INDEX..22)); 
oidloq;); 

READER_INPUT.ADD_SN ("•"); - teU reader EOF 

READER_INPUT.CLOSE_OUTPUT(SERNR_FILE); - close the file 


end FORMAT_SERNR_FlLE; 


-^PROCEDURE FORMAT_CMILREPORT_FILE- 

- lliis inocedure <^>ens die file FOUND, which ccmtains the serial numbers found during die 

- invait<My diat were on the CMR. The serial numbers are read from the FOUND file and die 
~ array is searched for a match. The serial numbers in the array are the serial numbers 

~ extracted frmn die CMR and were placed in the array when procedure 

— FORMAT_SERNR_FILE was called. When die serial number in die array is matched with a 
" serial number in die found file die serial number in die array is flagged as found. The serial 

— number is ^^lended widi a blank and an 'F. The serial numbers in the array are dien sorted 

- back to their original CMR position. A file called REPORT is created and die CMR file is 

— opened. Each line of the CMR is copied to the REPORT file. If a line in the CMR contains 
~ any serial numbers the serial numbers in the array are wriden to die report file instead of die 
~ serial numbers in the CMR. This creates a report that is the same format as the CMR except 
~ die serial numbers that were found during the inventory are flagged as found. 


procedure FORMAT_CMR_REPORT_FILE (SN_COUNT : in INTEGER; 

SOURCE.FILE : in STRING; 

DEST_FnE : in STRING; 

ARR_PTR ; in ARRAY_POINTER) is 


INDEX : INTEGER := 0; 

SN ; SERIAL_NUMBER; 

SN_STR : STRING (1 ..22); 

IN_LINE ; STRING (1.. 150); 

LAST : NATURAL; 


56 








begin 

READER_OUTPUT.OPEN (SOURCE_FILE); 

REPORT.CREATE (DEST_FILE); 

loop 


- open the bar code reader 
- ou^Hit file, create die 
~ onrl rep<Ht file 


SN_STR := " 

READER_OUTPUT.GET_SN (SN_STR); 
exit when READER_OUTPUT.ENDOF_FILE; 
SN_ARRAY.MARK_SN_FOUND (SN_STR,ARR_PTR); 
end loop; 

SN_ARRAY.SORT_BY_KEY (SN.COUNT, ARR_PTR); 


— f(Hr every sn in the 
~ file, get it and marie 

- it found 

- sort die array of sn's 
~ back to original <Hder 


INDEX := 1; 

loop — get each line in die raiginal 

CMRL.GET_LINE(IN_LINE,LAST); - cmrl 


exit when CMRL.ENDOF_FILE; 


if IN_LINE (1..18) /- " " then 

whileIN_LINE(I..18)/=” SERNRS:” loop 

REPORT. ADD_LINE (IN_LINE (1 ..LAST)); ~ if the line doesnl 

CMRL.GET_LINE (IN_LINE, LAST); - have any sn’s then get 

end loop; -- the next line until EOF 

end if; 

SN := SN_ARRAY.REMOVE_SN (INDEX, ARR.PTR); 


~ want to take the line input from the original cmrl and reinsert serial numbers from 
“ the array and then output the reconstructed line to the cmrl report file 

IN_LINE (19..40)SER1AL_NUMBERS.VALLT (SN); - insert 1st sn 

if LAST 62 then -- insert 2nd sn 

INDEX INDEX + 1; 

1N_LINE(41..62);= 

SERIAL_NUMBERS.VALUE(SN_ARRAY.REMOVE_SN(INDEX, 

ARR_PTR)); 

end if: 

if LAST >= 85 then - insert 3rd sn 

INDEX" INDEX + 1; 

IN_LINE(64..85):=SERIAL_NUMBERS.VALUE(SN_ARRAY.REMOVE_SNaNDEX, 

ARR_PTR)); 

end if; 

if LAST 108 then - insert 4di sn 

INDEX INDEX + 1; 

IN_LINE(87.. 108):=SERI AL_NUMBERS. VALUE(SN_ARRA Y.REMOVE.SN 

(INDEX, ARR_PTR)); 

end if; 

if LAST = 131 then -- insert 5di sn 

INDEX := INDEX + 1; 


57 





IN_LINE(110..131):= SERlAL_NUMBERS.VALUE(SN_ARRAY.REMOVE_SN 

(INDEX, ARR_PTR)); 

end if; 

IND^ ;= INDEX + 1; - add reconstructs! line 


REPORT.ADD_LINE (IN_LINE(1 ..LAST)); to tire cmrl report 

end loop; 

READER.OUTPUT.CLOSE (SOURCE.FILE); close the files 

REPORT.CLOSE (DEST.FTLE); 


end FORMAT_CMR_REPORT_ni.E; 

-PROCEDURE FORMAT_EXCEPTION_FILE- 

~ This procedure formats die serial numbers that were not on the CMR but were found during 
" the inventory into an exception report. During die inventory the user is notified when an asset 
— is not on the CMR. He is instructed to enter a description of the asset and its locatkm . This 
~ information will be recorded in the exception report. 


procedure FORMAT_EXCEPTION_FlLE (SOURCE_Fn.E : in STRING; 

REPORT_FlLE : in FILE.TYPE) is 

SN.STO ; STRING (1..22); 

ASSET_DESCRIPTION : STRING (1 ..30); 

ASSET_LOCATION : STRING (1.. 18); 

LAST : NATURAL; 


begin 

REPORT.FORMAT_EXCEPTION_REPORT; 
READER_OUTPUT.OPEN (SOURCE_FILE); 
loop 

exit when READER_OUTPUT.ENDOF_FIl.E; 

SN.STR := " "; 

ASSET_DESCRIPTION " "; 

ASSET_L0CAT10N := " "; 

READER_OUTPUT.GET_SN (SN..STR); 
TEXT_IO.SET_COL(REPORT_FILE, 1); 

TEXT_IO.PLrr(SN_STR); 

READER_OUTPUT.GET_DESCRIPTION(ASSET_DESCRIPTION); 
TEXT_10.SET_C0L(REP0RT_FILE, 28); 
TEXT_IO.PUT(ASSET_DESCRIPTION); 
READER_0UTPUT.GFT_1.0CATI0N(ASSET_L0CATI0N); 
TEXTJO.SET_COL(' . ORT_FILE, 62); 
TEXT_IO.PUT_LINE(ASSET_LOCATION); 
end loop; 

READER_OUTPUT.CLOSE (SOURCE_FILE); 
end F0RMAT_EXCEPT10N_FILE; 


58 






-PROCEDURE FORMAT„LABELS_nLE- 

This procedure opens the file LABELS, which contains the serial numbers extracted from the 

— CMR and formats this file for printing bar code labels. The serial numbers in the file are 22 
~ characters long, this procedure reads each serial number into an array and removes any blank 
" spaces in front of die serial number. The array is sorted in a^ha-numeric order and dien the 

— serial numbers are a^ipended with the necessary control characters for communication with die 
~ bar code printer. The serial numbers with the control characters are then written to COM2 port 

— for printing. 


procedure FORMAT_LABELS_FILE (SN_COUNT 

LABEL_FILE 
PRINT_FILE 
ARR PTR 


VA1.UE 

INDEX 

LENGTH 

SN 


STRING (1..22); 
INTEGER - 0; 

IN TEGER ;= 0; 

: SERIAL. NUMBER: 


in INTEGER; 
in STRING; 
in STRING; 

: in ARRAY.POINTER) is 


begin 

LABELS.OPEN_INPUT (LABEL_nLE); 
forlin L.SN.COUNTloop 
LABELS.GET. SN (SN): 
SN.ARRAY.INSERT.SN (I,SN,ARR.PTR); 
end loop; 

LABELS.CLOSEJNPUT aABEL_FILE); 


- open sn file 

- for the number 

- of serial nums 

- get one and place 

- it in the sn array 

” close the file to input 

- open com2 for output 
- sort sn's 


LABELS.CREATE (PRINT_FILE); 

SN_ARRAY.S0RT_BY_VALUE (SN_C0UNT,ARR_PTR); 
for I in 1..SN. COUNT loop 

VALUE := SERIAL..NUMBERS VALLTt (SN_ARRAY.REMOVE_SNa.ARR. PTR)): 
for J in 1..22 loop 

’ then 


INDEX; 


ifVALUt(J..J)/- 
INDEX := J; 

LENGTH := 23 
exit; 
end if; 
end loop; 

LABELS.PRINT_LABEL (VALUE aNDEX..22), LENGTH); 
end loop; 

LABELS.CLOSE_OUTPUT a'RINT_nLE); 
end FORMAT_LABELS_nLE; 


— for each sn in the 

— array, get its value 

— get length of each sn 

— remove any blanks 

— and output it to the 

— com2 port 


-- close coin2 port 


end FILE_PROCESSOR; 


59 










INVENTORY PORTION OF SYSTBI 




This progreun is designed to be used by Meurine Corps Systems 
Command in conducting inventory of its serialized assets. This 
portion of the system is written using IRL emd will reside in 
the bar code reader. This program has two major functions: 
conducting the inventory and transmitting the results back to a 
con^uter. During the inventory portion, the user is prompted to 
enter a serial number or F3 to tremsmit. The user should 
continue to enter serial numbers \intil the inventory is 
complete. The inventory takes a serial number , emd performs a 
search of the serial niimber file (FILE A) . This file contains 
all the serial numbers found on the CMR Listing. If the serial 
number scanned is is on the CMR (in FILE A), the program jumps 
to a procedure called CHKDUP. This procedure then checks the 
found file to see if the asset just scanned has already been 
inventoried. If the asset has not already been inventoried the 
program jumps to the FOUND procedure, where the serial number 
is recorded in the found file (PILE B). If the asset has 
already been inventoried the program jumps back to the INV 
procedure and the user is asked to enter emother serial number. 
If the serial number scanned does not match any of the serial 
numbers in FILE A, the user receives a warning beep and is 
instructed to enter the description and location of the asset. 
This data is then recorded in the not found file (FILE C). When 
the user selects transmit data he is promted whether he wants 
to transmit the found file or the not found file. The reader 
then assigns the name the file will be transmitted to on 
the computer using IRL commands specially created to interact 
with intrscam software. The files are then uploaded to the 
computer. 


SPECIFICATION DEFINITION SECTION 


OA(4000,23) 

OB(4000,23) 

OCdOO, 128) 

P" MARCORSYSCOM" 
P" INVENTORY" 

W3 


Open file A for 4000 records, 23 char per 
record. File will contain serial #'s 
downloaded from CMR. 

Open file B for 4000 records, 23 cheuc per 
record. File will contain the serial# of 
assets scanned that matched the CMR. 

Open file C for 100 records, 128 cheur per 
record. File contains the serial #, 
description, and location of assets that 
were not on the CMR. 

Displayed on screen when progreun is 
initiated. 

Wait 3 seconds 















INVENTORY PORTION OP PROGRAM 


The INV routine commences the actual inventory portion of the 
progreun. It prompts the user to enter a serial # or F3 to 

transmit files after the inventory is completed. 
*****iHi****1Hi***1t****ir*1t*1Hiii*1Hi1Hi1HHt*1i**1t1t****it*it1t*iHt1titit*1HHt1lit 


. INV : INV routine 

D$0="" : Cleeu: input register 0 

P*\e{2J“ : Clear screen on reader 

P-enter serial # OR- 
P-F3 TO TRANSMIT- 

P“\r" : Carriage return 

A : Get ASCII input 

G$0=-F3-.XMIT : Goto XMIT routine if F3 is entered 


SEARCH is a routine designed to perform a search of File A 
to see if the serial # of the asset inventoried is on the CMR. 
The routine calls two other routines (CHKDUP and NOFIND). 


•SEARCH 

H#9=A 

LA$0#8 


G#8<=#9.CHKDUP 

G#8>#9.NOFIND 


SEARCH ROUTINE 

Puts the location number of the last 
record in File A into register #9. 
Searches file A for a serial number that 
matches the serial number is string 
register $0. It then places the location 
of the match in register #8. If there is 
not a match it places the location number 
of the last serial number in the file 
plus one into register #8. 

Goto CHKDUP routine if the location 
number in register 8 is less them or 
equal to the location # in register 9. 
Goto routine NOTFOUND if the location 
number found in register 8 is greater 
than the number of records in the file. 


61 









The CHKIXJP routine is called from the SEARCH routine. This 
routine searches the found file to make sure the asset just 
scanned hasn't already been inventoried. If the asset has not 
already been inventoried the progreun jumps to the FOUND 
routine. If the asset has already been inventoried the program 
returns to the IN'/ routine. 

**************************************************************** 


.CHKDUP 

H#7=B 

LB$0#6 


G#6<=#7.INV 


G#6>#7.FOUND 


CHKDUP ROUTINE 

Puts the location number of the last 
record in File B into register #7. 
Searches file B for a serial number that 
matches the serial number is string 
register $0. It then places the location 
of the match in register #6. If there is 
not a match it places the location number 
of the last serial number in the file 
plus one into register #6. 

Goto INV routine if the location number 
in register 6 is less than or equal to 
the location # in register 7. (If the 
asset has already been inventoried). 

Goto routine FOUND li '"he location 
number found in register & is greater 
them the number of records in the file. 
The asset has not already been 
inventoried. 


FOUND routine is called from .chkdup and is initiated when 
the serial # scanned is found in FILE A. This routine saves the 
serial number in the found file (FILE B) and returns to the INV 
routine. 


.FOUND 

RB 

G.INV 


FOUND ROUTINE 

Puts the serial number scanned into file 
B which is the matched file and clears 
string register 0. 

Goto INV routine, this forms a loop 
taking you back to the beginning of 
the program an asks for emother serial 
number 


62 
















**★**★*****★*********★**★*****•*★★***★*****★**•*•★★*★**********★★★* 
The NOFIND routine is called from the SEARCH routine. It is 
initiated when the entire file A has been seeurched and none of 
the serial numbers matched. This routine querries the user 
to enter a description of the item and the location emd 
stores the information in file C. 


. NOFIND 

Bllllll 

P"\e[2J" 

P"ITEM NOT ON CMR" 
W3 

P"\e[2J" 

RC 


P"ENTER DESCRIPTION" 
P"OF THE ASSET " 
P"\r" 

K 

RC 


P"\e[2J" 

P"ENTER LOCATION" 
P"OF THE ASSET " 

P"\r" 

K 

RC 

G.INV 


NOFIND ROUTINE 

bar code reader will beep to warn user 
Clears the screen on the reader 
Prompt user 

Wait 3 sec before going to next 
command 

Clears screen on reader 

Transfers the serial number to the Not 

Found file (file C) and clear the 

register 

Prompt user 

Carriage return 

Get input from the keypad 

Transfers the description to the Not 

Found file (file C) and clear > le 

register 

Clears screen on reader 
Prompt user 

Carriage return 
Get input from the keypad 
Transfers location to Not found file 
(file C) and clears the register 
Goto INV routine 


: TRANSMIT PORTION OF PROGRAM 


★ ★•AT************************************************************* 

The XMIT routine prompts the user to choose which file to 
transmit: the found file (FILE B) or the not found file 
(FILE C). Depending on the users input, this routine calls 

either XFIND or XNOFIND routines. 
*★***•*•★■*•★*****★**★•*•♦**★**•*•******★********★★*★★*♦*♦****♦★★***★♦★★ 


63 
















.XMIT 

D$0='• 

P‘\e[2J* 

P“ ENTEK TO XMIT“ 
p«Fl- FOUND FILE“ 
P“F2- NOT FOUND FILE* 
P-\r* 

A2 

G$0=-F1".XFIND 
G$0=*F2*.XNOFIND 


: Cleeirs input register 0 
: Cleeurs screen on reader 
: Prompt user 


: Carriage return 
; Get ASCII input of 2 chars 
: Goto XFIND routine if Fl 
: Goto XNOFIND routine if F2 


*********♦***★*****♦*★**★★****♦*♦*♦**♦*♦**********************♦•* 
The XFIND routine is called from XMIT routine. This routine 
finds how meiny records are in the file. If there eure no 
records in the file the routine calls NO__RECS routine. This 
routine also prompts the user that the reader is transmitting. 
**★**★♦***★***♦*★****★★**♦♦***♦**♦★***♦♦***★*******************★ 


.XFIND 

H#1=B 

G#1=O.NO_RECS 
D#2 = 0 
P"\e[2J" 

p-TRANSMITTING..." 


Puts the number of records in 
FILE B into register 1 
Goto NO_RECS routine if FILE B 
doesn't have any records 
Sets register 2 equal to 0 (the 
first record in the file) 

Clears screen on reader 
Tells user reader is 
tramsmitting 


****************************************************************** 

The TRANSFD routine transmits the found file (FILE B), one 
record at a time. The file will be transmitted to the computer 
using intrscan software. The file will be transmitted to a 
file called FOUND.DAT located in the intrscan directory on the 
computer. 

********************************************************************* 


64 

























.TRANSFD 

D$0=““ 

D$ 0 = •■ ~DATA_1_F0UND. DAT_ “ 


D$0=$0+B(#2) 


XMP,$0 

D#2=#2+l 

G#2<#1.TRANFD 

G.INV 


Clears input register 0 
IRL cozDZD 2 uid for intrsacem to put 
the data appended to this 
statement in a file called 
FOUND.DAT 

#2 is a pointer that is pointing 
to a record in FILE B. That 
record will be appended to the 
statement above. 

Transmit using protocol the 
contents of register 0. 

Increment the pointer 
Loop until the pointer equals the 
number of records found in FILE B 
Goto INV routine 


*★*****★★****★★****★*★**★**★★***•****■*■★*★*★******★*★*♦•*****★**★*★ 

The XNOFIND routine is called from XMIT routine. This routine 
finds how memy records are in the file. If there 2 u:e no 
records in the file the routine calls NO_RECS routine. This 
routine also prompts the user that the reader is transmitting. 

-k’k'k'kif'k'kif'k’kif-kit'kitii’kifitifitif'kic'kicirifiririeir-k’kititicitififiticickifk’kiriticir’kir’k’kifk’kifitic'k'kit 


.XNOFIND 

H#1=C 

G#1=O.NO_RECS 
D#2 = 0 
P"\e[2J" 

P"TRANSMITTING... 


Puts the nvunber of records in 
FILE C into register 1 
Goto NO_RECS routine if FILE C 
doesn't have any records 
Sets register 2 equal to 0 (the 
first record in the file) 

Clears screen on reader 
Tells user reader is 
transmitting 


The TRANSNO routine transmits the not found file (FILE C), one 
record at a time. The file will be transmitted to the computer 
using intrscan software. The file will be transmitted to a 
file called NOFIND.DAT located in the intrscan directory on the 
computer. 


65 











.TRANSNO 

D$0=*" 

D$0="~DATA_l_NOFIND.DAT_- 


D$0=$0+C{#2) 


XMP,$0 

D#2=#2+l 

G#2<#l.TRANNO 

G.INV 


Cleeurs input register 0 
IRL commeuid for intrsacan to put 
the data appended to this 
statement in a file called 
NOFIND.DAT 

#2 is a pointer that is pointing 
to a record in FILE C. That 
record will be appended to the 
statement ed:>ove. 

Transmit using protocol the 
contents of register 0. 

Increment the pointer 
Loop until the pointer equals the 
number of records found in FILE C 
Goto INV routine 


NO_RECS is called from either XFIND or XNOFIND routines. This 
routine is an exception handler. If the user tries to transmit 
a file that doesn't have any records, the user will be prompted 
the file is empty and the program will return to the INV 
routine. 

***************************************************************** 


.NO_RECS 

Bllllll 

P-\e[2J'' 

P"NO RECORDS IN FILE" 
W3 

G.INV 

E 


Reader will beep a warning 

Clears screen on reader 

Prompts user 

Waits 3 seconds 

Goto INV routine 

End of progreun 


66 


















-TITLE : LABELS package definidoD speciAcatkms 

- NAME : Richard Hancock 

-DATE : 20 Aug 1993 

~ DESCRIPTION : This package contains all operadons associated with the object Labels. 

- : Labels are created by extracting serial numbers from die CMR. Ihe 

- : soial numbers are placed in a file called LABEL. These soial numbers 
; are formatted the same as die reader input file (i.e. all die blanks are 

: removed and the serial numbers are sorted in a^iha numeric (»der. The 
: serial numbers are dien ai^nded with the necessary ctmtrol characters 
: for communication wi& die bar code {uinter. This packi^e contains die 

- : following operations: CREATE, OPEN_INPUT, CIX)SE_INPUT, 

: CLOSE. OUTPUT, ADD_SN, PRINT LABEL and GET_SN . A 

- : detailed descrqition. of each of the operations is provided in die padcage 

: body. 


with SERIAL.NUMBERS; use SERIAL.NUMBERS; 
package LABELS is 

procedure CREATE (NAME : in STRING); 

procedure OPEN.INPUT (NAME : in STRING); 

procedure CLOSE.INPUT (NAME : in STRING); 
procedure CLOSE.OUTPUT (NAME : in STRING); 

procedure ADD.SN (SN : in SERIAL.NUMBER); 
procedure ADD.SN (SN : in STRING); 

procedure PRINT.LABEl. (SN: in STRING; LENGTH: in INTEGER); 

procedure GET.SN (SN : out SERIAL.NUMBER); 

function ENDOF.FILE return BOOLEAN; 

CREATE.ERROR: exception; 

OPEN.ERROR : exception; 

CLOSE.ERROR : exception; 


end LABELS; 


67 










- TITLE : LABELS package definition body 

- NAME : Richard Hancock 

- DATE ; 20 Aug. 1993 

~ DESCRIPTION : This package contains all <^)eratk»s associated with die object Labels. 

~ : Labels are created by extracting soial numbers frcMn the CMR. The 

: serial numbers are placed in a file called LABEL. These smal numbos 

- : are f(»inatted die same as die reader input file (ie. all the bfamks are 

~ : removed and die serial numbers are sorted in alpha numeric order. The 

" : serial numbm are dien appended widi die necessary (xmtrol characters 

; for c<»nmunicadon with die bar code printer. This padcage contains die 

- : following operations; CREATE, OPENJNPUT, CLOSE_INPUT, 

: CLOSE. OUTPUT, ADD.SN, PRINT LABEL and GET.SN . A 

; detailed description of each of die operations is provided in the package 
; body. 


with TEXT.IO; use TEXT.IO; 

package body LABELS is 

INFILE : FILE.TTPE; 

OUTEILE ; FILE.TYPE; 

END.OF.FILE : BOOLEAN := false; 

-PROCEDURE CREATE- 

-- This procedure creates a file to store the serial numbers extracted from die CMRL file. Sets 
~ the defauh output to this file. 


procedure CREATE (NAME : in STRING) is 
begin 

TEXT.IO.CREATE (OUTFILE, OUT.FILE, NAME); 
TEXT.IO.SET.OUTPUT (OUTFILE); 

exception 
when others => 

raise CREATE.ERROR; 

end CREATE; 


68 














-PROCEDURE OPEN.INPUT- 

- This procedure <^iis die file storing serial numbers for input to format (ie rmiove blank 
~ spaces) ftM* printing bar code labels. Sets the default input to this file 


procedure OPEN_INPUT (NAME : in STRING) is 
begin 

TEXTJO.OPEN (INFILE, IN.FILE, NAME); 

TEXTJO.SET.INPUT (INFILE); 
exception 

when odiers => 

raise OPEN_ERROR; 

end OPEN_INPUI; 

-PROCEDURE CLOSEJNPUT- 

- This procedure closes die file, setting the default to standard input (ie keyboard) 


procedure CLOSEJNPUT (NAME : in STRING) is 
begin 

TEXTJO.CLOSE (INFILE); 

TEXT JO. SETJNPUT (TEXT_IO. STAND ARD.INPUT); 
exception 

when others => 

raise CLOSE_ERROR; 

end CLOSILINPUT; 

-PROCEDURE CLOSE_OlTTPUT-- 

-- This procedure closes the file to output, setting tiie defauh to standard ou^ut (ie the 
- monitor). 


procedure CLOSE.OUTPUT (NAME : in STRING) is 
begin 

TEXTJO.CLOSE (OUTFILE); 

TEXT JO. SET_OUTPUT (TEXT JO.STANDARD.OUTPUT); 
exeq^tion 
when odiers => 

raise CLOSE_ERROR; 


end CLOSE_OUTPUT; 


69 












-PROCEDURE ADD_SN- 

- This f^'ocediire receives a serial number of private type serial number and calls die fimctimi 

- VALUE in package SERIAL NUMBERS which converts the serial number (to type siring). 

- This proceitoe then writes die senal number to the file diat is (^lened fcnr curroit input. 


procedure ADD.SN (SN ; in SERIAL.NUMBER) is 
begin 

TEXTJO.PUT.LINE (OUTFELE, SERIAL_NUMBERS.VALUE(SN)); 
end ADD_SN; 


-PROCEDURE ADD_SN- 

— This procedure receives a serial number (type string) and writes the serial number to the 
~ current file open for input 


procedure ADD_SN (SN ; in STRING) is 
begin 

TEXTJO.PUT.LINE (OUTFILE, SN); 
end ADD_SN; 


-PROCEDURE PRINT. LABEI.- 

- This procedure receives a serial number of type string and appends the necessary control 

- characters for communication with the bar code printer to each serial number. The serial 

- number and control characters are then written to COM2 port for printing. 


procedure PRINTJLABEL (SN : in STRING; LENGTH : in INTEGER) is 

STX. CHARACTER-ASCn.STX; 

ESC: CHARACTER:^ ASCn.ESC; 

CAN: CHARACTER:= ASCD.CAN; 

ETB: CHARACTER:= ASCn.ElB; 

ETX: CHARACTER:= ASCn.ETX; 

LABEL: STRING(1..LENGTH4 7); 

begin 

LABEL:=STX&ESC4fc’'EI "&CAN&SN&ETB&ErX; 
TEXTJO.PUT_LINE(OU'mLE,LABEL); 

end PRINT_LABEL; 


70 

















-PROCEDURE GET_SN- 

-- This procedure gets a serial number from the current file c^n for ou^[>ut. Passes die serial 

- num^ (type string) to CREATE procedure in package SERIAL NUMBERS which returns a 

- serial number (private type serial number) with the same value. The {vocedure advances the 

- open file one line and returns die serial number(private type) to the calling procedure. 


procedure GET_SN (SN ; out SER1AI,_NUMBER) is 

VALUE : STRING (1..22); 

LAST : INTEGER; 

begin 

TEXTJO.GET (INHIE,VALUE); 
SERIAL_NUMBERS.CREATE (VALLTi, SN); 
TEXT_IO.skip_line (INFELE); 
exception 

when TEXT JO.END_ERROR => 

END_OF_HLE := true; 


end GET_SN; 


-FUNCTION ENDOF.FILE— 

- This function returns the value of the END_OF_FILE flag 


function FNDOF..FILE return BOOLEAN is 
begin 

return TEXT_IO.END_OF_FILE; 
end ENDOF_niE; 


end LABELS; 


71 











- TITLE : Print Batdii Labels 

~ NAME : Richard M. Hancock 

- DATE : 20 Aug 1993 

- DESCRIPTION : Tins procedure is the main driver the for the i»int bar code label protkm 

- : oftheBCIS. This part of the syston <^>ens the CMRL file (ASCII file) 

- : provided by the user and extracts all die serial numbers into a Label fDe. 

- : These serial numbers are tfien fonnalted (any blanks at the frcmt of die 

- : serial numbers are ranoved) and the file b sorted into a^dia^nnneric 

- : ascending <Mxler. Thb {urogram uses d^ same code as the download 

: {KMtiixi of die syston to ensure the serial numbm downloaded to die 
~ ; reader match the serial numbers (Ml die labek. Thk {irogram thm 

- : appen(b die necessary (XMitrol (haracters for c<MnmunicatkMi with the bar 

- : co^ {Vinter to each serial number and sends thb info to the bar code 

~ {vinter vb COM {>ort 2. Ihe objects used in thb {xvticm ofdie system are 

CMRL, READER_INPUT. SERIAL_NUMBERS, SN_ARRAY, and 
: FILE.PROCESSOR. 


with CMRL; with LABELS; 

with SERIAL_NUMBERS; use SERIAL.NUMBERS; 

with SN.ARRAY; use SN.ARRAY; 

with FILE.PROCESSOR; use FTLE_PROCESSOR; 

with TEXTJO; use TEXTJO; 

procedure PRN_BATCH b 

CMRL_FILE_NAME : STRING (1 ..4) := "CMRL"; 
LABEL_FILE_NAME : STRING (1 ..6) := "LABELS"; 

OUTPUT_FILE_NAME : constant STRING := "COM2"; 

SN : SERIAL_NUMBER; 

SN.COUNT : INTEGER :=0; 

ARR_PTR ; ARRAY_POINTER; 

begin 

CMRL.OPEN (CMRL_FILE_NAME); 

LABELS.CREATE (LABEL_FILE_NAME); 
loop 

CMRL.GET_SN (SN); 

exit when CMRL.ENDOF_FlLE; 

SN.COUNT := SN_COUNT + 1; 

LABELS.ADD_SN (SN); 
end loop; 


72 










CMRL.CLOSE(CMRL_Fn.E_NAME); 

LABELS.CLOSE_OUTPUT(LABEL_FILE_NAME); 

SN_ARRAY.CREATE_ARRAY (SN_COUNT, ARR_PTR); 

FORMAT_LABELS_FILE (SN.COUNT, LABEL_FILE_NAME, OUTPUT_FILE_NAME, 

ARR_PTR); 

exception 

when CMRL.OPEN_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_Oim>lJT, "Error OPENING file CMRL"); 
when CMRL.CLOSE_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error CLOSING file CMRL"); 
when LABELS.CREATE_ERROR => 

TEXT_IO,PUT_LINE (STANDARD_OUTPUT, "Error CREATING file LABELS"); 
when LABELS.OPEN_ERROR => 

TEXT_IO.PUT_LINE (STANDARD_OUTPUT, "Error OPENING file LABELS"); 
when LABELS.CLOSE_ERROR => 

TEXTJO.PUT.LINE (STANDARD.OUTPUT, "Error CLOSING file LABELS"); 


end PRN_BATCH; 


73 






-TITLE 

-NAME 

-DATE 

- DESCRIPTION 


: Print Individual Labels 
: Ridiard M. Hancodc 
; 22 Aug 1993 

: This inrocedure is die main driver the for {Minting individual bar ccxk 
: labels. This {vogram qt^ries die user to enter a serial number. The serial 
; number is thra af^ioided with the necessary control characters for 
: communication with a bar code {vinter. The smal number and ctMitrol 
: characters are dien sent to the {vinter via die COM2 {K»t. The object 
: used in this (XMtion of die syston is LABEL.. 


whh LABELS; with TTY; 
with CURSOR; use CURSOR; 

with COMMON_DISPLAY_TYPES; use COMMON_DISPLAY_TYPES; 
with TEXT JO; use TEXT JO; 

procedure PRN_INDrV is 

OUTPUT_FILE_NAME : constant STRING := "COM2"; 

SN :STRING(1..22); 

LENGTH : INTEGER r=0; 

NO.BLINK: BOOLEAN := false; 

FINISHED: BOOLEAN := false; 

BLANK ; constant STRING:= " "; 

ASK : constant STRING:= " ENTER A SERIAL NUMBER OR ’QUIT TO EXIT 
BACK : COLOR := blue; 

FORE : COLOR := bright_white; 

ESC : CHARACTER ;= ASCB.ESC; 

begin 

while not FINISHED loop 
TTY.CLEAR.SCREEN; 

TTY.PUT(10,153LANK,FORE3ACK,NO_BLINK); 

TrY.PUT(l 1,15,ASK,FORE,BACK,NO_BLINK); 

TrY.PUT(12,l 53LANK30RE3ACK,N0_BLINK); 
nY.PUT(13,153LANK,FORE,BACK,NO_BLINK); 

CURSOR.MOVE(13,30); 

TEXTJO.GET_UNE(SN3ENGTH); 
if SN(1 ..LENGTH) = "QUIT" or SN(1 ..LENGTH) = "Quit" 
or SN(1..LENGTH) = "quit" then 
FINISHED := true; 
else 

LABELS.CREATE (OUTPUT_FILE_NAME); 
LABELS.PRINT_LABEL(SN(1..LENGTH),LENGTH); 

FINISHED := false: 


74 









LABELS.CLOSE.OUTPUT (OUTPUT_FILE_NAME); 
end if; 

Old loop; 

exception 

when LABELS.CREATE_ERROR => 

TEXTJO.PUT_LINE (STANDARD.OUTPUT, "Eiror OlEATING file LABELS"); 
whra LABELS.CLOSE_ERROR => 

TEXTJO.PUT_LINE (STANDARD. OUTPUT. "Error CXOSING file LABELS"); 


endPRN_INDIV; 


75 





-- TITI^ : READER INPUT package definition specifkatk»s 

~ NAME : Richard Hancock 

- DATE : 28 July 1993 

~ DESCRIPTION : This package contains all operations associated widi the object reader 

: input READER INPUT is a file that contains only serial numbers diat 
: were extracted from the CMRL. This file wiU be downloaded to the bar 
: code reader before an inventory is conducted. The operatioDS amtained 
; in this package are CREATE, OPEN INPUT, OPEN OUTPUT, CLOSE 
: INPUT, CLOSE OUTPUT, ADD SERIAL NUMBER, GET SERIAL 
; NUMBER, and END OF FILE. A detailed description of eadi of 
; operations are contained in the Package Body. 


with SERIAL_NUMBERS; use SER1AL_NUMBERS; 

package READER_INPUT is 

procedure CREATE (NAME : in STRING); 

procedure OPEN_INPUT (NAME : in STRING); 
procedure OPEN.OUTPUT (NAME : in STRING); 

procedure CLOSE_OUTPUT (NAME : in STRING); 
procedure CLOSEJNPUT (NAME : in STRING); 

procedure ADD_SN (SN : in SERIAI...NUMBER); 
procedure ADD_SN (SN : in STRING); 

procedure GET_SN (SN ; out SERIA1._NUMBER); 

function ENDOF_FILE return BOOLEAN; 

CREATE_ERROR : exception; 

OPEN_ERROR : exception; 

CLOSE_ERROR : exception; 


end READER_INPUT; 


76 









- TITLE : READER INPUT package definition body 

- NAME : Richard Hancock 

- DATE : 28 July 1993 

- DESCRIPTION : This package contains all opoations associated widi the object reader 

: input. READER INPUT is a file that contains only serial numbers that 
~ : were extracted from the CMRL. This file will be downloaded to the bar 

: code reader before an inventory is conducted. The operations contained 
: in this package are CREATE, OPEN INPUT, OPEN OUTPUT, 

: CLOSE INPUT, CLOSE OUTPUT, ADD SERIAI. NUMBER, GET 
: SERIAL NUMBER, and END OF FILE. A detailed descrqition of each 
: of these operations are contained in the Package Body. 


with TEXTJO; use TEXTJO; 

package body READER_INPUT is 

INULE : FILE_TYPE; 

OUTFILE : FILE_TYPE; 

END_OF_FILE : BOOLEAN := false; 

-PROCEDURE CREATE- 

- This procedure creates a file to store the serial numbers extracted from the CMRL file. Sets 

- the default output to this file 


procedure CREATE (NAME : in STRING) is 
begin 

TEXT lO.CREATE (OUTHLE. OITJ HLE, NAME); 
TEXTJO. SET_OUTPUT (OUTFILE); 
exception 

when others => 

raise CREATE_ERROR; 

end CREATE; 


-PROCEDURE OPEN_INPUT- 

- This procedure opens the file storing serial numbers for input to format (ie remove blank 

- spaces) for bar code reader input. Sets the default input to this file 


77 

















procedure OPEN_INPUT (NAME ; in STRING) is 
begin 

TEXTJO.OPEN (INFILE, IN_FILE, NAME); 
TEXT_IO.SET_INPUT (INFTLE); 
exception 

when otibiers => 

raise OPEN_ERROR; 

endOPEN_INPUT; 


-PROCEDURE OPEN.OUTPUT- 

~ Hiis procedure opens the flle storing serial numbers for output to hold formatted serial 
~ numbers for bar code reader iiq>ut. Sets default output to diis flle. 


procedure OPEN.OUTPUT (NAME : in STRING) is 
begin 

TEXT JO.OPEN (OUTFILE, OUT_FILE, NAME); 

TEXTJO.SET_OUTPUT (OUTFILE); 
exception 
when others => 

raise OPEN_ERROR; 

end OPEN_OUTPUT; 

-^PROCEDURE CLOSE..OUTPU T-- 

— Tliis procedure closes die flle to output, setting the default to standard ou^ut (ic the monitor). 


procedure CLOSE_OUTPUT (NAME ; in STRING) is 
begin 

TEXTJO.CLOSE (OUTFILE); 

TEXTJO,SET_OUTPUT (TEXTJO.STANDARD_OUTPUT); 
exception 
when others => 

raise CLOSE_ERROR; 

end CLOSE.OUTPUT; 


78 










-PROCEDURE CLOSE_INPUT- 

- This procediffe closes die file, setting the defauh to standard iiqiut (ie keyboard) 


procedure CLOSE_rNPUT (NAME : in STMNG) is 
begin 

TEXTJO.CLOSE (INFn£); 

TEXTJO.SET_INPUT (TEXT_IO.STANDARD_INPUT); 
exception 

when others => 

raise CLOSE„ERROR; 

end CLOSE_INPUT; 


-PROCEDURE ADD_SN- 

- Hus procedure receives a serial number of private type serial number and calls the function 
~ VAIyUE in package SERIAL NUMBERS which converts die serial number (to type string). 

- This procedure then writes the serial number to the file that is opened for current input. 


procedure ADD..SN (SN ; in SERIAL_NUMBER) is 
begin 

TCXTJO.PUT_LINE (OUTFILE, SERIAL_NUMBERS.VALUE(SN)); 
end ADD_SN; 


-PROCEDURE ADD_SN- 

~ This procedures receives a serial number (type string) and writes the serial number to the 
~ current file open for input. 


procedure ADD..SN (SN : in STRING) is 
begin 

TEXT_IO.PUT_LINE (OUTFILE, SN); 
end ADD_SN; 


--PROCEDURE GET_SN- 

~ Hiis procedure gets a serial number from the current file open for output. Passes the serial 

- number (type string) to CREATE procedure in package SERIAL NUMBERS which returns a 

- serial number (private type serial number) widi fte same value. The procedure advances the 
“ open file one line and returns the serial number(private type) to the calling procedure. 


79 











procedure GET_SN (SN : out SERIAL_,NUMBER) is 

VALUE : STRING (1..22); 

LAST : INTEGER; 

begin 

TEXTJO.GET (INFILE.VALUE); 
SERIAL.NUMBERS.CREATE (VALUE, SN); 
TEXTJO.SKIPLINE (INFILE); 
exception 

when TEXTJO.END_ERROR => 

END_OF_FILE := true; 


endGET.SN; 


-FUNCTION ENDOF.FILE- 

- This function returns the value of the END_OF_FILE flag 


function ENDOF_FILE return BOOLEAN is 
begin 

return TEXTJO.END_OF_FILE; 
end ENDOF_FILE; 


end READERJNPUT; 


80 










— nTLE : READER OUTPUT package definiticm specificalioiis 

~ NAME : Richard Hancock 

- DATE : 28 July 1993 

- DESCRIPTION ; This package contains all operations associated with the object reader 

— : output READER OUTPUT is a file that contains only serial numbers 

: that were uploaded from barcode reader, lliese files will be frxmated 
: for processing into reports. The (^>aations ccmtained in this padtage are 
: OPEN, CLOSE, GET SERIAL NUMBER AND END OF FILE. A 
: detailed description of each of these operations are c<mtained in the 
: Package Body. 


package READER_OUTPUT is 

procedure OPEN (NAME : in STRING); 
procedure CLOSE (NAME : in STRING); 
procedure GET_SN (SN : out STRING); 

procedure GET_DESCRIPTION (ASSET.DESCRBPTION : out STRING); 

procedure GET_LOCATION (ASSET^LOCATION : out STRING); 

function ENDOF_FILE return BOOLEAN; 

OPEN_ERROR ; exception; 

CI/OSE_ERROR : exception; 


end READER_OUTPUT; 








-- TITLE : READER OUTPUT package (lefiniti<Hi body 

- NAME : Richard Hancock 

- DATE ; 28 July 1993 

- DESCRIPTION : This package contains all operations associated with the object reader 

~ : output. READER OUTPUT is a file diat cixitains serial numbers diat 

~ : were i4)k)aded from die barcode reader. These files will be framated 

- : for processing into reports. The c^ioatkms c<mtained in diis package are 

: OPEN. CLOSE, GET SERIAL NUMBER, GET LOCATION, GET 

; DESCRIPTION and END OF FILE. A detailed descrqition of each of 
: diese operations are omtained in the Padcage Body. 


with TEXTJO; use TEXTJO; 


package body READER_OUTPUT is 

READER_OUTFILE : TEXTJO.FILE_TYPE; 
END_OF..FILE : BOOLEAN := false; 


-PROCEDURE OPEN- 

-- This procedure opens the file generated by the bar code reader and sets the default hqiut to the 
- given file name. 


procedure OPEN (NAME : in STRING) is 
begin 

TEXT JO.OPEN (READER_OUTFILE, IN_FILE, NAME); 
TEXTJO.SET_INPUT (READER_OUTni,E); 
exception 

when others => 

raise OPEN_ERROR; 

end OPEN; 


-PROCEDLTIE CLOSE- 

- This procedure closes die ou^iut file produced by the bar code reader and sets die default 

- input to standard input (ie keyboard). 


82 














|»XKedure CLOSE (NAME : in STRING) is 
begin 

CLOSE (READER.OUTFILE); 

TEXTJO.SETJNPUT (TEXT_IO.STANDARD_INPUT); 
excei^on 

when others => 

raise CLOSE_ERROR; 

end CLOSE; 


-^PROCEDURE GET_SN- 

~ Ihis procedure gets a serial number from the bar code reader output file. This procedure 
~ counts whow many characters are in the serial number and pads the front of the serial number 
-- with blanks to return die serial number to a 22 character field 


procedure GET_SN (SN ; out STRING) is 

VALUE : STRING (1..22); 

LAST : NATURAL; 

BLANK_COUNT : NATURAL; 

-input a sn 
and then pad it 
~ with blanks to 
" get 22 chars. 


end GET_SN; 


begin 

TEXT_IO.GET_LINE (READER.OUTFILE, VALUE, LAST); 
BLANK_COUNT := 22 - LAS 1'; 
for I in l..BLANK_COUNT loop 
SN a..I) “ " "; 
end loop; 

SN (BLANK_C0UNT4 1..22) ;= VAI.UE (1..LAST); 
exception 

when TEXTJO.END_ERROR => 

END_OF_FILE “ true; 


-PROCEDURE GET_DESCRIPT10N- 

— This procedure gets the description of the asset fhmi tibe not found frle that was created during 

— die inventory. The descrqition is returned to the procedure FORMAT_EXCEPTION_FILE to 

— be processed into exception report. 


83 







procedure GET.DESCRIPTION (ASSET_DESCRIPTION : out STRING) is 

VALUE : STRING (1..30); 

LAST : NATURAL; 

begin 

TEXTJO.GET.UNE (READER_OUTFILE. VALUE, LAST); 
for I in LAST+1..30 loop 
VALUEa .I):= " "; 
end loop; 

ASSET.DESCRIPnON := VALUE; 
excq>tion 

when TEXT_IO.END„ERROR => 

END_OF_FILE trae; 

end GET_DESCRIPTION; 


-^PROCEDURE GET_LOCATION- 

~ This procedure gets die location of the asset from the not found file diat was created during 

- the inventory. The location is returned to the procedure FORMAT_EXCEPTION_FILE to be 

- processed into the exception report. 


procedure GET_LOCATION (ASSET_LOCATION ; out STRING) is 

VALUE: STRING (1..18); 

LAST ; NATURAL; 

begin 

TEXT_IO.GET_LINE (READER_OUTFILE, VAl-UE, LAST); 
forlinLAST+L.lSloop 

VALUEa .I):= " "; 

aidloqp; 

ASSET.LOCAHON := VALUE; 
exceptkm 

when TEXT_IO.END_ERROR => 

END_OF_FILE /= true; 


end GET_LOCATION; 


84 









-FUNCTION ENDOF_FILE 

Tliis function retuins ttie £ND_OF_FIL£ fla^ variable. 


function ENDOF_FILE return BOOLEAN is 
begin 

return END_OF_FILE; 
endENDOF.FILE; 

end READER.OUTPUT; 


85 






-TITLE 

REPORT package deflnitkHi specifications 

-NAME 

Richard Hancock 

-DATE 

28 July 1993 

- DESCRIPTION 

This package contains all operations associated with ttte object r^xxt 

— 

REiPORT is a file that replicates the <»ignial CMRL but the serial 

— 

nundters that were found during the inventory were annotated widi a flag. 

~ 

XREPORT is a file that c<Hitains assets that wa% found during die 

— 

inventory but were not on the CMRL. This report contains die serial 

— 

number, descrqdi<» ^ location of the assets. The (^leratkNis contained 

— 

m diis padcage are CREATE, CLOSE, ADD LINE and 

— 

F0RMAT_EXCEPT10N_REP0RT. A detailed desoiptkHi of each of 

— 

tticse (^leiatkxis are contained in die Padcage Body. 


with TEXTJO; use TEXTJO; 
package REPORT is 


procedure CREATE (NAME : in STRING); 
procedure CLOSE (NAME : in SIRING); 
procedure ADD_LINE (LINE : in STRING); 
procedure FORMAT_EXCEPTION_REPORT; 
CREATE_ERROR; exception; 
CLOSE_ERROR ; exception; 

end REPORT; 












- TITLE : REPORT package defmMon body 

“ NAME : Richard Hancock 

- DATE : 28 July 1993 

~ DESCRIPTION : This package c ontains all operati<Mis associated with the object report 

: REPORT is a file that replicates the <»ignial CMRL but die serial 
: numbers diat were found (hiring the inventory were annotated widi a flag. 

~ : XREPORT is a flle that (contains assets that were found during the 

- : inventory but were not <hi die CMRL. This r^xxt contains die serial 

~ : number, descr^don and kxation of the assets. The <^>eratk»is ctmtained 

; in diis packt^e are CREATE, CLOSE, ADD LINE and 
: F0RMAT_EXCEPT10N_REP0RT. A detailed description of each of 
; diese operatums are contained in the Package Body. 


with TEXTJO; use TEXTJO; 

package body REPORT is 

REPORT_FILE : FILE_TYPE; 

MORE_SERlAL_NUMBERS : BOOLEAN := FALSE; 
SN.COUNT : INTEGER::= 0; 


--PROCEDURE CREATE- 

" This procedure creates the output report file with the given name and sets the default output to 
~ diatfile. 


procedure CREATE (NAME : in STRING) is 
begin 

TEXT JO.CREATE (REPORT.FILE, OUT.FILE, NAME); 
TEXTJO.SET.OUTPUT (REPORT.FILE); 
exception 

when others => 
raise CREATE.ERROR; 

end CREATE; 


--PROCEDURE CLOSE- 

- This procedure closes the CMRL report file of die given name and sets die default ou^iut back 
~ to standard output (ie monitor). 


87 
















procedure CLOSE (NAME : in STRING) is 


begin 

CLOSE (REPORT_FILE); 

TEXTJO.SET_OUTPUT(TEXT_IO.STANDARD_OUTPUT); 

exception 

when others => 

raise CLOSE_ERROR; 

end CLOSE; 

-PROCEDURE ADD.UNE- 

- This procedure adds a line to the CMRL report file. 


procedure ADD_LINE (LINE ; in STRING) is 
begin 

PUT.LINE (REPORT.FILE, LINE); 
end ADD_LINE; 


-PROCEDURE FORMAT_EXCEPTION_REPORT 

- This procedure formats the exception report. 


procedure FORMAT_EXCEPTION_REPORT is 

TITLE : STRING (1.16):= "EXCEPTION REPORT; 

HEADERl : STRING (1.. 13):= "Serial Number"; 
HEADER2 : STRING (1.. 11):= "Description"; 

HEADERS : STRING (1 ..8):= "Location"; 

begin 

NEW_LINE(3); 

SET_COL(32); 

PUT_LINE(TITLE); 

NEW_LINE(2); 

SET_COL(10); 

PUT(HEADER1); 

SET_COL(28); 

PUT(HEADER2); 

SET_COL(62); 

PUT_LINE(HEADER3); 

NEW_LINE; 

end FORMAT_EXCEPTION_REPORT; 


end REPORT; 


88 










- TITLE : Serial Number Array definition package specifications 

- NAME : Richard Hancock 

- DATE : 17 July 1993 

- DESCRIPTION : Hiis package co ntains all operations associated with the object Serial 

~ ; Number Array. This object was not devek^>ed during the design jrfiase, 

~ : but was created to he^) with die implementation of die syston. This 

: object: is used to sort die serial number files and flag a smal numbo' as 

- : found. The package ctxitains (^leratioiis diat will CREATE an array, 

- : INSERT a serial number into ^ array, SORT an array by value, SORT 

~ : an array by initial tile position, MARK a serial number as found, and 

- : removes as serial number fttm the Array. A detailed desciiptirMi of each 

- : of the operations is provided in the package body. 


with SERIAI._NUMBERS; use SERIAI._NUMBERS; 

package SN_ARRAY is 

type ARRAY_RECORD is 
record 

DATA : SERIAL..NUMBER; 

KEY : INTEGER; 
end record; 

type SER_ ARRAY is array (INTEGER RANGE o) of ARRAY.RECORD; 
type ARRAY_POINTER is access SER_ARRAY; 


procedure CREATE_ARRAY (SN.COUNT : in INTEGER; ARR_PTR : out 

ARRAY_POINTER), 

procedure INSERT_SN (INDEX : in INTEGER; VALUE : in SERIAl-.NUMBER; 

ARR_PTR: in ARRAY_POINTER); 

procedure SORT_BY_VALUE(ARRAY_SIZE : in INTEGER; ARR_PTR : in 

ARRAY_POINTER); 

procedure SORT_BY_KEY (ARRAY_SIZE : in INTEGER; ARR_PTR : in 

ARRAY_POINTER); 

procedure MARK_SN_FOUND (SN_STR : in STRING; ARR.PTR : in 

ARRAY_POINTER); 

function REMOVE_SN (INDEX : in INTEGER; ARR_PTR : in ARRAY_POINTER) 

return SERIAL_NUMBER; 


end SN_ARRAY; 


89 











- TITLE : Smal Number Array delinitioD pack^e body 

~ NAME : Richard EUmcock 

-DATE : 17 July 1993 

~ DESCRIPTION : This padkage ccmtains aU opoatious associated witti die object Soial 
~ : Number Amy. This inject was not devek^>ed during die design phase, 

~ : but was oeated to he^ with die inqilementatkai of the syston. This 

; object is used to sort die serial number files and flag a serial number as 
~ : found. The package contains operations that will CREATE an amy, 

: INSERT a serial number into die amy, SORT an amy by value, SORT 

— : an amy by initiftl fik position, MARK a serial number as fouiul, and 

- : removes a serial number from the Amy. A detailed descr^on of each 

— : of the operations is provided in the package body. 


with TEXTJO, use TEXTJO; 
package body SN_ARRAY is 

-PROCEDURE CREATE_ARRAY- 

" This procedure creates an amy with a size equal to the number of serial numbers found in the 

- CMRL. The procedure returns an amy pointer to the calling procedure, which points to the 

- memory location of the amy. This pointer allows us to access and preserve the contents of 
" the amy after a procedure is closed. This is a benefit because we do not have to pass an entire 
" amy from procedure to procedure, which could result in the data being erroneously 

" modified. 


procedure CREATE.ARRAY (SN_COUNT ; in INTEGER; ARR_PTR : out 

ARRAY_POINTER) is 


begin 

ARR_PTR new SER.ARRAY (l..SN_COUNT); 
end CREATE.ARRAY; 


-^PROCEDURE INSERT.SN- 

- This procedure inserts die serial number value and the original file position of the serial 
~ number into an amy record element The file position is saved for when we put die s^ial 
-- numbers back in the CMRI. with a found flag. 


90 















procedure INSERT_SN (INDEX : in INTEGER; VALUE : in SERIAL_NUMBER; 

ARR_PTR : in ARRAY.POINTER) is 


begin 

ARR_PTR(INDEX).DATA := VALUE; 
ARR_PTR(INDEX).KEY := INDEX; 
end INSERT_SN; 


-^PROCEDURE SORT_BY_VALUE- 

- This procedure conducts a shell sort of die array by serial number value, placing die serial 

>- numbers in ascending alpha-numeric order. This procedure was obtained from a bo<^ called 

- ALGORITHMS written by ROBERT SEDGEWICK (1984). This jMocedure is found on 

- page 98. 


procedure SORT_BY_VALUE (ARRAY. SIZE : in INTEGER; ARR_PTR : in 

ARRAY_POINTER) is 

TEMP_REC : ARRAY.RECORD; 

TEMP_SN : SERIAL_NUMBER; 

H, J : INTEGER; 

begin 

H:=l; 

loop 

H :=3*H H; 

exit when H > ARRAY_SIZE; 
end loop; 
loop 

H:=H/3; 

for I in H+1..ARRAY_SIZE loop 
TEMP_REC “ ARR_PTR (I); 

TEMP.SN := ARR_PTRa).DATA; 

J:=I; 

whUe ARR_PTR(J-H).DATA > TEMP.SN loop 
ARR_PTR (J) := ARR_PTR (J-H); 

J ;= J-H; 

exit when J <= H; 
end loop; 

ARR.PTR (J) “ TEMP_REC; 
end loop; 
exit when H = 1; 
end loop; 


91 







exception 

when CONSTRAINT.ERROR => 
text_io.put_Iine (standaF(Loii4>ut, "-CONSTRAINT.^ERROR in 
ARRAY_SORT_BY_BALUE procedure.-"); 
end SORT_BY_VALUE; 


-^PROCEDURE SORT.BYJCEY- 

~ This procedure conducts a shell sort of an array by key, whidi places dte serial numbers back 

— in the order diat tiiey were read in finom the CMRL file. This procedure was obtained fnm a 

— book called ALGORITHMS written by ROBERT SEDGEWICK (1984). This i»ocedure is 

— found on p^e98. 


procedure SORT_BY_KEY (ARRAY.SIZE : in INTEGER; ARR_PTR : in 

ARRAY_POINTER) is 

TEMP.REC : ARRAY.RECORD; 

TEMP.KEY : INTEGER; 

H, J : INTEGER; 

begin 

H:=l; 

loop 

H:=3*H+1; 

exit when H > ARRAY_SI2E; 
end loop; 
loop 

H := H / 3; 

for I in H+1..ARRAY_SIZE loop 
TEMP_REC := ARR_PTR ( 1 ); 

TEMP_KEY - ARR_PTRa) KEY; 

while ARR_PTR(J-H).KEY > TEMP_KEY loop 
ARR.PTR (J) := ARR.PTR (J-H); 

J ;= J-H; 

exit when J <= H; 
end loop; 

ARR_PTR (J) := TEMP_REC; 
end loop; 
exit when H= 1; 
end loop; 


92 




excq>tion 


when CONSTRAINT_ERROR => 

text_io.put_line (standaFd_oii4>ut,CONSTRAIN_ERROR in ARRAY 
SORT_BY_KEY procedure.-"); 

end SORT_BY_KEY; 


-^PROCEDURE MARK_FOUND- 

~ This procedure is passed a serial number (string of 22 chars). The procedure opens die serial 

— number array and sea;:'ches the array for a saial number diat matches. When a match is 

- found the MARK procedure in the package SERIAL NUMBERS is called and stipends a 
~ flag to the end of die serial number. Tliis serial number is then placed back into die array 


procedure MARK_SN_FOUND (SN_STR:m STRING; ARR_PTR:in ARRAY_POINTER) is 


I : INTEGER p=l; 

VALUE : STRING (1..22); 


begin 

VALUE := SERIAL_NUMBERS.VALUE (ARR_PTR (I).DATA); 
while (VALUE (22..22) = "F" ) or ( SN_STR /= SERIAL_NUMBERS.VALUE (ARR_PTR 
a).DATA)) loop 
I;=I+ 1; 

VALUE := SERIAI._NUMBERS.VALUE (ARR_PTR a).DATA); 
end loop; 

SERIAL_NUMBERS.MARK (ARR_PTRa).DATA); 
exception 

when CONSTRAINT_ERROR => 

text_io.put_line (standard_output, "-CONSTRAINT_ERROR in ARRAY 
MARK_SN_FOUND procedure.-"); 

end MARK_SN_FOUND; 


93 





-FUNCTION REMOVE_SN- 

~ Tliis function given an index value and die location of an array goes into die array and r^ums 
- the serial number value found in the position specified by the index value. 


function REMOVE_SN (INDEX : in INTEGER; ARR_PTR : in ARRAYJ>OINTER) 

return SER1AL_NUMBER is 


begin 

return ARR_PTR(INDEX).DATA; 
end REMOVE_SN; 


end SN_ARRAY; 


94 






- TITLE : SERIAL NUMBERS package definition specifications 

-- NAME : Richard Hancock 

-DATE : 28 July 1993 

- DESCRIPTION : Tliis package contains all operations associated widi the object serial 

- : numbers. Serial numbers are al^rfianumeric and can be iqt to 23 

: characters in lengtfi. This packi^e defines serial numbers as a fuivate 

- ; type to enhance die object orieoted principle of inf<Hmatk>n hiding. By 

" : declaring serial numbers a inivate type we limit die <^>eratkxis that can be 

- : performed on serial numbers outside this padcage. The tolerations 

- : contained in diis package are: CREATE (ctMQverts type string to type 

- : serial number), MARK (places a flag at the end of found serial numbos), 
: VALUE (converts type serial number to type string), and (cmnpares 

; two serial numbers and returns a boolean). A detailed descriptitHi of each 
~ : of these operations are provided in the Package Body. 


package SERIAL_NUMBERS is 

type SERIAL_NUMBER is private; 

procedure CREATE (VALUE : in STRING; SN : out SERIAL_NUMBER); 
procedure MARK (SN : in out SERIAL_NUMBER); 
function VALUE (SN : SERIAL.NUMBER) return STRING; 
function ">" (SN1,SN2 : in SER1AL_NUMBER) return BOOLEAN; 

private type SERIAL,_NUMBER is 
record 

VA1.UE: STRING (1..22); 
end record; 

end SERIAI._NUMBERS; 


95 







~ TITLE : SERIAL NUMBERS i»ckage definition body 

- NAME : Richard Hancodc 

-DATE : 28 My 1993 

- DESCRIPTION : This package contains all <^>entk)ns associated widi die (d>ject serial 

- : numbCT. Serial numbers are alfdtanumeik and can be iq> to 23 characters 

- : in lengdL This package defines serial numbos as a private type to 

- ; Mtance die object Miented princ^te of infoiinatkm hiding. Bydechring 

- : serial numbers a private type we limit the operations that can be 

- : petfonned on sei^ numbers outside diis package. The (^leiatkms 

~ : (xmtained in diis padc^e are CREATE (c<Hiverts type ^rii^ to type 

- : serial number), MARK (places a flag at the end of found serial mnnbers) 

~ : and VALUE (amveits type serial number to type string). A detailed 

~ : description of each of diese operati<Mis are i»x>vided in die Package Body 


with TEXTJO; use TEXTJO; 
package body SER1AL_NUMBERS is 

--PROCEDURE CREATE- 

- This procedure accepts a serial number value (of type string) and creates a new serial number 

- (of private type serial number) with die same value. This i»eserves the integrity of the serial 

- numbers because using this type limits die operati<His performed outside diis padcage. 


procedure CREATE (VALUE : in STRING; SN : out SERIAL.NUMBER) is 
begin 

SN.VA1.UE := VALUE; 
end CREATE; 


-PROCEDURE MARK- 

— This procedure removes two blanks fiom die front of the serial number and ai^ioids a blank 
~ and an F to flag the serial number as found. This juocedure assumes die Ira^ of a serial 

- number will not exceed 22 charactos. 


procedure MARK (SN : in out SERIAL.NUMBER) is 
begin 

SN.VALUE ~ SN.VALUE (3..22) & " F"; 
end MARK; 


96 








-FUNCTION VALUE- 

~ This function accepts a serial number (of i»ivate type serial number) and converts it to type 
~ string. This is necessary so we can perfonn necessary fimctions to tiie serial number outside 
- this package. 


function VALUE (SN : SERIAL_NUMBER) return STRING is 
begin 

return SN.VALUE; 
end VALUE; 


-FUNCTION ">"- 

- This function is used to compare the values of two serial numbers and return a boolean value 

- if the first serial number is greater that the second. This function is used in the Package 

- SN_ARRAY during the procedure SORI_BY_VALUE. 


function (SN 1 ,SN2 : in SERIAL_NUMBER) return BOOLEAN is 
begin 

return SN LVALUE > SN2. VALUE; 
end •■>”; 


end SERIAL _NUMBERS; 


97 











APPENDIX B 


BCIS USER'S KANUAL 


A. ZNTRQDUCTZON 

The Bar Code Inventory System (BCIS) is an automated 
inventory system designed to provide Marine Corps Systems Command 
(MARCORSYSCOM) with an efficient and effective tool with which to 
manage the unit's serialized assets. 

The following special topics are presented to facilitate 
introduction to this system: 

1. INSTALLATION AND SETUP 

2. STARTING THE SYSTEM 

3. DOWNLOAD FILE TO BAR CODE READER 

4. CONDUCTING AN INVENTORY 

5. UPLOADING INVENTORY RESULTS 

6. PRINTING REPORTS 

7. PRINTING BAR CODE LABELS 


B. INSTALLATION AND SETUP 

1. Compatibility and Requirements 

The BCIS is compatible with any IBM personal computer or 
IBM compatible personal computer. In addition, the BCIS requires 
the following configuration: 

1. MS-DOS or PC-DOS (Versions 5.0 or 6.0). 

2. 640K RAM (IM recommended). 

3. Two serial ports and one parallel port 

4. Intermec Bar Code Reader 

5. Intermec Bar Code Printer 

6. 10-9 Null Modem Cedsle 

7. 25-Pin Printer to PC Cable 

8. Visible Laser Sceuiner 


98 







2 . InstallAtlon 


To install the Bar Code Inventory System on a personal 

computer, place the BCIS diskette in B drlvw (or Drive A) of the 

computer and type B:\Z1ISTALL (or A:\INSTBLL) . The install 

program will create four directories on the computer's hard drive 

and copy the system programs to those directories. When the 

installation process is complete check the computer's hard drive 

for the following directories and progreuas: 

BCIS 

BCIS .COM 
BATCHKEY.COM 
CLRSCR .COM 
TEXTOUT .COM 
SETPOS .COM 
DRAWBOX .COM 

BCIS/ADA 

CMR_RPT .EXE 
DOWNLOAD .EXE 
PRN_BATCH.EXE 
X_REPORT .EXE 
PRN_INDIV.EXE 

INTRSCAN 

README 
COMMDRV .EXE 
INTRSCAN.EXE 
PCHOST .EXE 
TERMDRV .EXE 
UTILDRV .EXE 
INV .IRL 

INTRSCAN.INI 

PCIRL 

PCIRL .EXE 
PIPE .EXE 
README 
PCIRL .CFN 
BCIS .IRL 
INV .IRL 


99 




In addition to the eyetem files, a file called 
PCDRIVER.SYS will be added to the computer’s Root directory. 
PCDRIVER.SYS is a PCIRL device driver that will memage the 
communication protocol for uploading and downloading programs and 
files. 

3. Setup 

Before PCIRL can be utilized, ANSI.SYS must be added to 
the Root directory emd two lines must be added to the CONFIG.SYS 
File. ANSI.SYS is a DOS device driver that will manage the PCIRL 
screen output. 

To add the required lines to the CONFIG.SYS file, perform 
the following steps: 

1. Move to the Root directory by typing CD\. 

2. At the DOS prompt, type EDIT CONFIG.SYS. 

3. Press [Ehter]. 

4. At the end of the CONFIG.SYS lines, type the following: 

DEVICEsANSI.SYS. 

5. Press [Enter]. 

6. On the next line, type OEYICEsPCDRIVER.SYS. 

7. Press [Enter]. 

8. Press [Alt] to activate the menu. Use the eurrow keys to 
select FILE and press [Enter]. 

9. Select SAVE and press [Enter]. 

10. Press [Alt] to activate the menu. Use the arrow keys to 
select FILE emd press [Enter]. 

11. Select EXIT and press [Enter]. 


100 




12. At the DOS prompt, type the following: TYPE CONFIG.SYS. 

13. Press [Enter]. 


14. Verify that CONFIG.SYS now includes the two required 
lines: 

DEVICE=ANSI.SYS 

DEVICE=PCDRIVER.SYS 

15. Reboot the computer by pressing[Ctrl]-[Alt]-[Del]. 

C. STARTING THE SYSTEM 

To initiate the Bar Code Inventory System, move to the BCIS 
directory by typing CD\BCIS. The system starts when BCIS is 
entered at the >C:\BCIS prompt. 

Once in the Bar Code Inventory System, the user is directed 
to the Main Menu. Figure B.l illustrates the options available 
to the user. To navigate through the system, type the number in 
front of the desired option. For example, to exit the system 
press [5] and hit [Enter]. 

BAR CODE INVENTORY SYSTBS 

1. Download File to Reader 

2. Receive Inventory Results 

3. Print Reports 

4. Print Bar Code Iied:>els 

5. Exit to DOS 


ENTER (1..5) 








D. DONMXjQAD file to bar cook rbrdbr 


This portion of the system extracts the serial numbers from 
the CMR Listing emd creates a serial number file. The file is 
formatted for the reader emd is passed to the PCIRL directory for 
dovmload. After the file is dovmloaded to the reader, the user 
is returned to the Main Menu, (see Figure B.l). The serial 
number file must be dovmloaded to the reader before conducting an 
inventory. 

1. Establish a Connaction 

Before commencing the dovmload portion of the system, 
connect the male end of the of the 10-9 Null Modem C 2 J^le into the 
reader's communication dock ^uld the female end into the COMl port 
of the personal computer. 

2. Set Protocol On Reader 

The communication protocol, on the reader, must be set to 
■POLLING MODE D" before dovmloading a file. The following 
example illustrates the steps required to set the reader's 
protocol to "POLLING MODE D': 

1. Press the reader's OS-OVF key to turn the reader on. 

2. At the "READY" prompt, press [Ctrl]-[E] to enter 
configuration mode. The prompt in Figure B.2 appeeurs 
on the reader's screen; 


CONFIGURATION MENU: 

Press <?> for help, 

<ENTER> to continue 
<CNTRL-Z> to exit 

FIGURE B.2 Reader Configuration Prompt 


102 





3. Press [ENTER] to continue. The prompt in Figure B.3 
appeeurs: 


CONFIGURATION MENU: 
Select or modify 
bar codes? 

NO _ 


riOURE B.3 Bar Code Option 


4. Press [ENTER] for no. The screen in Figure B.4 
appeeirs: 


CONFIGURATION MENU: 
Select or modify 
operating peucms? 

NO _ 


FIGURE B.4 Operating Parameter Option 


5. Press [ENTER] for no. The screen in Figure B.5 
appears: 


CONFIGURATION MENU: 
Select or modify 
comm protocol? 

NO (now=PT. TO PT.) 


FIGURE B.5 Comm Protocol Option 


6. Press [SPACE] twice to change to "POLLING MODE D" 
Protocol. 

7 . Press [Alt]-[E] to save changes and exit 
Configuration Menu. 


103 








3. Placa CUR Listing in Propsr Dirsctory 


Before selecting the download option from the Main Menu, 
the CHR Listing must be copied to the BCIS\ADA directory under 
the File Name CaiRL. If this step is not accomplished prior to 
initiating download, the user will receive a quick error message 
and the progreun will retiim to the main menu. 

4. Initiating Dovmload Option 

Once the CMRL File is copied to the BCZSXAOA directory, 
the download ceui be steurted by pressing [1] then [Enter] . The 
system will then display a message that Serial Numbers eure being 
extracted from the CMR. 

When all the serial numbers have been extr^&cted from the 
CMR the screen in Figure B.€ will be displayed. This screen is 
the PCIRL Set-Up Screen. To proceed with downloading the file to 



PC'tRL if nof rfady for o FUNCTION loloctlon. 


function nooff art lifted in the top lino of the ditploy. 

Soft houf Optionf ohich till oppfor in drop-doon oonuf 
then 0 FUNCTION it folectod. For o dftcription of the 
FUNCTIONf and their Optionf, eflfct INFO. Uhtn tore Help 
if auailoblf, the Help key (Fll if ditplayed. 

>> To fflfct a FUNCTION; 

• Hold doth thf [RIt] key. 

- Protf the firtt Ifttor in thf FUNCTION nofo. 

>> To fflfCt an Opt ion froo a drop-doon oonu: 

- Proff the firtt Ifttor in thf Option nooo. 

>> To clfor thif fcrfon, proof the [Etc] key. 

PC-IRL OEUELOPNEHT SOFTURRE 
PROGRfln 049316- 
COPVfllGHT (c) 1967 
INTERIIEC CORPORATION 
Rll righto rotervod. 

V_^_/ 


FIGURE B.6 PCIRL Sat-Up Screen 


104 










the reader, this screen must be cleared before a ftmction cem be 
selected. To clear the Set-Up Screen press [Bsc]. 

5. Configure PCXRL for CoBDunlcatlon 

The first time the B^ur Code Inventory System is used, 
PCIRL must be configvured prior to downloading the file. To 
select the CONFIG function enter CAlt]-[C]. Verify that the 
CONFIG Screen looks like Figure B.7. To make configuration 
changes, use the eurrow keys to move to the appropriate field amd 
manually enter the correct setting. 


^ - -- ^ 


COMF I G 


Text editor file noaa . 


||■(PIPE.EXE i 

i nc1udad in 

CoRpil^ trror ddstingtion ... 

.. t 

(E • IRE, 

L • . IRL) 

Redder disploy line count ... 

. . 4 

(up to 4) 


line length .. 

. . 20 

(up to 20 ) 


Tronsait output to .IRX 

file during Run/Oebug .. 

. . H 

(V or H) 



Up Iood/OosnIood Paroaeters: 

Transfer «i 0 controller? .. H 

Baud rot e . 9600 

Parity ... £ 

Ooto bits . 7 

Stop bits . I 

Coapile before Ooenlood? .. V 
Coapoct before Ooenlood? . N 

Target EPROH selection . 1 


(V or H) 

(9600,4800,2100,1200,600,300) 
(E, 0 or «) 

(7 or 8) 

(1 or 2) 

(V or M) 

(V or M) 

(1 • Cl, 2 ■ Hitochi, 3 • Tl, 
4 • Intel, 5 • liEC) 



V. 




FIGURE B.7 PCIRL Configuration Screen 


6. Downloading File to Reader 

After configuring PCIRL, move to the LOAD function by 
pressing [Alt]-[L]. This creates a drop-down menu as depicted in 
Figure B.8. Select [D] for download emd type RBADIN for the 


105 














FIGORE B.8 PCZRL Load Scraan 

download file neune. Using the down arrow, move to the file 
destination field and enter [A]. Turn the bar code reader on by 
Pressing the [ON-OFF] key emd wait for the ready prompt. Hit 
[ENTER] on the computer keyboard and PCIRL will download the file 
to the reader. The download process is finished when PCIRL 
displays the message 'DOWNLOAD COMPLETE...' in the lower right 
of the screen. EInter [F2] to exit the download menu and 
[Alt]-[Q] to return to the BCIS Main Menu. This completes the 
download portion of the system. 

E. CONDUCTING THE INVENTORY 

This portion of the system is performed with the bar code 
reader. The reader scans bar code labels affixed to the 
serialized assets and checks to see if the asset is on the CMR. 

If the asset inventoried is on the CMR the serial number is 
recorded in the Found File. If the asset is not on the CMR the 


106 













ueer is prompted to enter a description and location of the 
asset. This information along with the serial number is then 
recorded in the Not Found File. 

To begin the inventory, connect the laser sceuiner to the bar 
code reader. Press the [MI-OPT] key to turn the reader on and 
wait for the ready prompt. At the ready prompt enter 
[Ctrl]-[IIITra] [B] . Press the [Ctrl] and [ENTER] keys 
simultaneously and then press [B] . This key sequence initiates 
the IRL program stored in the reader's memory. When the program 
is initiated the prompt in Figure B.9 appears on the screen: 

MARCORSYSCOM 

INVENTORY 

FIGPRE B.9 Start of Program Screen 

After three seconds the screen clears and the user is presented 
with the prompt in Figure B.IO: 



FIGORE B.IO Biter Serial Number or Tremsmlt Pro^^t 

At this prompt, the user scans or manually enters the serial 
number of the asset being inventoried. If the asset inventoried 
is on the CMR the user is returned to the prompt in Figxure B.IO. 


107 









If the asset inventoried is not on the CMR the reader emits a 
seQuence of beeps and the screen depicted in Fioure B.ll appears: 

ITEM NOT ON CMR 

riGURE B.ll Item Hot On Xnvmntoxy Scr««n 

After three seconds, the screen is cleared and the user is 
presented with the prompts illustrated in Figures B.12 and B.13. 

ENTE» DESCRIPTION 
OF THE ASSET 


FIGURE B.12 Enter Description Prompt 

At these prompts, manually enter the description and location 
of the asset just inventoried. After this information is 
recorded, the user is returned to the EInter Serial Number Prompt. 
This process is continued until the inventory is completed. 

ENTER LOCATION 
OF THE ASSET 

FIGURE B.13 Bntsr Location Prompt 

If the reader is turned off during the inventory, the data is 
not lost. To resume cne inventory, press the [OH-OFF] key and at 


108 








the ready prompt enter [Ctrl] ■* [ENTER] [B] . The IRL program is 
resumed and the user ceui continue the inventory. 

P. RBCEZVE INVENTORY RESULTS 

This phase of the system uploads the results of an inventory 
from the reader to the personal computer. The results are then 
processed emd two reports are created, the CMR Report and the 
Exception Report. 

To Receive the inventory results, select option [2] from the 
Main Menu, (see Figure B.l). Press [ENTER] emd the Receive File 
Option Menu appeeurs, (Figure B.14). 

This Menu allows the user to select which file to upload--the 
Found or Not Found File—or to upload both files. The proper 
selection depends on the needs of the user. 



RECEIVE FILE OPTIONS 

1. 

Receive Found rile 

2. 

Receive Not Found File 

3 . 

Receive Both Files 

4. 

EIxit to Main Menu 


ENTER (1..4) 


FIGURE B.14 Receive File Options Menu 


109 






1. R«c«iv« Foiind Fll* 

If all the assets inventoried were on the CMR (i.e., the 
Not Found File is empty), select option [1] and press [SNTBt]. 
The Interscem Menu illustrated in Figure B.15 will appear on the 
screen. 



The first time the Bar Code Inventory System is used, 
Intrsceui must be configured prior to uploading a file. To 
configxire the Intrscan software for communication with a reader 
refer to the Configure Intrscan Section, at the end of Section F. 

Select [F2] for reader communication and the Intrscan 
Communication Screen will appear, (Figure B.16). Mhen in this 
screen the computer is ready to receive the Found File. 


110 







Before uploading the file to the computer, connect the 
male end of the of the 10-9 Null Modem Cable into the reader's 
communication dock euid the female end into the COMl port of the 
personal computer. 

I H InterScan Oevlee Drtunr n I 
<ns 9 > 87-02-1991 15:53:04 Connunleatlan Initialed 


CEscI Exit I (Fll Poraat I CF2I IRL I (F3} OeU I CF101 Trace On 

Camwnlcatlen In Process 

FIGURE B.16 InterScan Coaniunicatlon Screen 


Turn the bar code reader on and at the 'READY PROMPT" 
type [Ctrl] - [EOTER] [B] to start the progreun. The start of 
progreun screen, (see Figure B.9), will appear for three seconds 
followed by the “enter serial number or F3 to trcmsmit' 
prompt,(see Figure B.IO). At this prompt enter [F3] to transmit 
emd the screen in Figure B.17 will appear. 

ENTER TO XMIT 
FI- FOUND FILE 
F2- NOT FOUND FILE 

FIGURE B.17 Transait Screen 


Ill 















Enter [Fl] at this prompt and the reader will upload the 
file to the computer. The serial numbers will scroll down the 
Intermec Communication Screen (Figure B.16). The serial numbers 
will be stored in a file called Found on the personal computer. 
The upload is complete when serial numbers stop scrolling across 
the computer screen. 

Press [Bsc] twice and the program will process the serial 
numbers in the Found file and create the CMR Report. When the 
CMR Report is finished the user is returned to the Receive File 
Options Menu, (Figure B.14). 

2. Receive Hot Found File 

This option uploads the Not Found File from the bar code 
reader and creates an Exception Report. The Exception Report is 
a listing of all of the serial numbers found during the inventory 
that are not on the CMR. A short description and the location of 
the item is also provided. 

To initiate this option press [2] then [EHl'ER] from the 
Receive File Options Menu, (see Figure B.14). The Intrscan Menu 
illustrated in Figure B.15 will appear on the screen. 

The first time the Bar Code Inventory System is used, 
Intrscan must be configured prior to uploading a file. To 
configure the Intrscan software for communication with a reader 
refer to the Configure Intrscan Section, at the end of Section F. 


112 








Select [rt] for reader communication and the Intrscan 
Communication Screen will appeeu:, (see Figure B.16). When in 
this screen the computer is ready to receive a File. 

Before uploading the file to the computer, connect the 
male end of the of the 10-9 Null Modem Cable into the reader's 
communication dock and the female end into the CCMl port of the 
personal computer. 

Turn the bar code reader on and at the ■ready prompt* 
type [Ctrl]- [ENTER] [B] to start the program. The St^u^t of 
Progr 2 un screen, (see Figure B.9), will appeeu: for three seconds 
followed by the “enter serial number or F3 to tremsmit* 
prompt,(see Figure B.IO). At this prompt enter [F3] to transmit 
and the screen in Figure B.17 will appear. 

Enter [F2] to transmit the Not Found File and the reader 
will upload the file to the computer. The data uploaded will 
scroll down the Intermec Communication Screen (see Figure B.16). 
This information will be stored in a file called NoFind on the 
personal computer. The upload is complete when the data stops 
scrolling down the computer screen. 

Press [Esc] twice and the progreun will process the 
information in the NoFind file and create an Exception Report. 
When the Exception Report is finished the user is returned to the 
Receive File Options Menu, (see Figxire B.14) . 


113 






3. R«c«iv« Both Filos 


This option uploads the Foimd emd Not Found File from the 
beu: code reader and creates both the CMR and Exception Reports. 

To initiate this option press [3] then [ENTER] from the Receive 
File Options Menu, (see Figure B.14). The Intrscem Menu 
illustrated in Figure B.15 will appear on the screen. 

The first time the B^u^ Code Inventory System is used, 
Intrscem must be configured prior to uploading a file. To 
configure the Intrscem softweure for communication with a reader 
refer to the Configure Intri^oan Section, at the end of Section F. 

Select [F21 for reader communication emd the Intrscem 
Communication Screen will appear, (see Figure B.16). When in 
this screen the computer is ready to receive a File. 

Before uploading the file to the computer, connect the 
male end of the of the 10-9 Null Modem Cable into the reader's 
communication dock and the female end into the COMl port of the 
personal computer. 

Turn the bar code reader on and at the "READY PROMPT" 
type [Ctrl] -[ENTER] [B] to steurt the program. The Steurt of 
Program screen, (see Figure B.9), will appear for three seconds 
followed by the "enter serial number or F3 to tremsmit" 
prompt,(see Figure B.IO). At this prompt enter [F3] to tremsmit 
and the screen in Figure B.17 will appear. 

Enter [Fl] to tremsmit the Found File emd the reader will 
upload the file to the computer. When the serial numbers stop 


114 



scrolling dovm the Intermec Communication Screen (see Figure 
B.16) the file is uploaded. At the ‘ENTEK SERIAL NUMBER OR F3" 
prompt enter [r3]. Press [«] and the Not Found File will be 
trcmsmitted to the computer. The upload is complete when the 
data stops scrolling down the computer screen. 

Press [Esc] twice and the progr 2 ua will process the 
received information into the CMR 2 md Exception Reports. When 
the Reports are created the user is returned to the Receive File 
Options Menu, (see Figure B.14). 

4. Configure InterScan for Coaoninlcatlon 

To enter the Configuration Menu, select [FIO] from the 
Interactive Mode Menu, (see Figure B.15). The Configuration Menu 
is illustrated in Figure B.18. Use the [SPACE] key to change the 
options, the [ENTER] key to move to the next field, and the 
[Bksp] key to move to the prior field. Change the options on the 
screen to match Figure B.18 and enter [Esc] to return to the 
Interactive Mode Menu. 

6. PRINT REPORTS 

This option allow the user to print the CMR and Exception 
Reports. At the Bar Code Inventory System Main Menu type [3] 
then [ENTER]. The Print Report Options Menu, illustrated in 
figure B.19 will appear. 

This Menu allows the user to select which Report to 
print--the CMR Report or Exception Report—or to print both 


115 







Coml Device - Reader Com2 Device - Printer 

Speed - 9600 Speed - 9600 

Peurity - E Peurity - E 

Data Bits - 7 Data Bits - 7 

Stop Bits - 1 Stop Bits - 1 

Text Color - 7 Log File EneJ:>le - Off 

Border Color - 7 Trace - On 

Modem Command - Tone Host Receive EOM - <CR><LF> 

Modem No. Prefix - None Host Transmit EOM - <CR><LF> 


[Esc]-Exit [Space]-Options [Enter]-Next Prompt [Bk:sp]-Last 


Options for Configuration 


FIGURE B.18 InterScan Configtiration Menu 



PRINT REPORT OPTIONS 

1. 

Print CMR Report 

2. 

Print Exception Report 

3. 

Print Both Reports 

4. 

Exit to Main Menu 


ENTER (1..4) 


FIGURE B.19 Print Report Options Menu 


116 












Reports. To select which report to print type the number in 
front of the desired option and press [BNTBR] . The proper 
selection depends on the desires of the user. 

H. PRINT BAR CODE LABELS 

This option prints the h&r code l^J^els that will be attached 
to the serialized assets. At the Main Menu type [4] then [ENTER] 
to access the Print Bar Code IJ^dDel Menu, (Figure B.20). 

PRINT BAR CODE LABEL OPTIONS 

1. Print Batch L 2 d>els 

2. Print Individual Labels 

3. Exit to Main Menu 

ENTER (1..3) 

FIGORE B.20 Print Bar Code Label Options Menu 

Before printing euiy labels, connect the female end of the of 
the 25-Pin printer cable into the printer's interface connector 
port and the male end into the COM2 port of the personal 
computer. 

The Print Batch Labels option allows the user to print bar 
code leU^els for all the assets on the CMR. Before selecting this 


117 







option, the CMRL file must be placed in the BCIS\ADA directoxY* 

To execute this option type [1] then [BVTBl]. 

The Print Individual Labels option allow the user to print 
individual labels. Uhen a new asset eurrives, the user can select 
this option to create a new label and affix this label to the 
item. To execute this option type [2] then [ENTER]. The prompt 
is figure B.21 will appear on the screen. 

At this prompt, type the serial number of the asset and hit 
[ENTER]. A bar code label will be printed emd figure B.21 will 
return to the screen. To return to the Print B^u^ Code Label 
Options type QUIT instead of a serial number. 


ENTER A SERIAL NUMBER OR ’QUIT' TO EXIT 


FIGURE B.21 Individual Label Prompt 
I. EXIT THE SYSTEM 

To exit the Bar Code Inventory System, select the option to 
return to the Main Menu. At this screen type [5] then [ENTER] 
and the user will be returned to the DOS prompt. 


118 












LIST OP REFEROICES 


Pag«-Jones, M., PrActicetl Guide to Structured Systems Design, 

2nd ed., Prentice-Hall, Inc., 1988. 

Pressmem, R.S., Software Engineering: A Practitioner's Approach, 
3rd ed., McGraw-Hill, Inc., 1992. 

Sedgewick, R., Algorithms, Addison-Wesley Publishing Company, 
Inc., 1984. 

Vfhitten, J.L., Bentley, L.D., and Beurlow, V.M., Systems Analysis 
and Design Methods, 2nd ed., Irwin, Inc., 1989. 


119 






INITIAL DISTRIBOTIOM LIST 


1. Defense Technical Information Center 2 

Cameron Station 

Alexandria, VA 22304-6145 

2. Librairy, Code 52 2 

Naval Postgraduate School 

Monterey, CA 93943-5002 

3. Director, Training emd Education 1 

HCCDC, Code C46 

1019 Elliot Road 
Quantico, VA 22134-5027 

4. Director ISMD 1 

MARCORSYSCOM 

2033 Barnett Avenue, Suite 315 
Quantico, VA 22134-5010 

5. Professor William Haga, Code AS/HA 1 

Naval Postgraduate School 

Monterey, CA 93943-5002 

6. Professor Shu S. Liao, Code AS/LC 1 

Naval Postgraduate School 

Monterey, CA 93943-5002 

7. Computer Technology Progreuns, Code 370 1 

Naval Postgraduate School 

Monterey, CA 93943-5002 

8. Capt. Richard M. Hancock 1 

206 Greensview Drive 

Cary, NC 27511 


120 





