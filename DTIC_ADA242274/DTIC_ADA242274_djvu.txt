AD-A242 274 


V -- 


mm 


IMENTATION PAGE 


I 'Form Approved 
OPM No. 0704-0188 


I Wiwragil hour ptftMponM, Including Urn* to r»i<»»ilng lr H MCIIocw >t » thing ««Mng dm tourewgMhwIngaidnwInlilnlngKmte 
■ ragwdkig thk burdMi wdnult or in|r othor MpM oi dill oolocllon oi MoffluUoa Indudkig fuggMtiono forraducing this burdwi, to WashingM 
•pom, 121SJ<AttMnOiidilllghwiy,SulM12M,Atltiglon,VA22202-4302.indtolhoOlllcoollnloirrationandRigul*lotyAlliin,Ollicoal 


1. AGENCY USE ONLY (Leave Blank) 


ANDSU 


2. REPORT DATE 


3. REPORT TYPE AND DATES COVERED 

Rnal: 29 Nov 1990 to 01 Jun 1993 


R.R. Software, Inc., Janus/Ada 2.2.0 PHAR Lap/OOS, IBM PS/2, MOD. 80 Phar 
Lap/DOS 3.3 (Host & Target), 901120W11088 



7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) i* 

Ada Validation Facility, Language Control Facility ASD/SCEL 1# 

BkJg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 

8.‘-HnFORMING ORGANIZATION 

REPORT NUMBER 

AVF-VSR436-0891 



Ada Joint Program .Office 

United States Department of Defense 

Pentagon, Rm3E114 

Washington, D.C. 20301-3081 

REPORT NUMBER 


\ 1 . ^ilPf^lillil^NYARY NOt^S ....' ' . 

/?- < L / V ■j-dU.-u/vy 


1 Ja. 5liTWSUn<5N/AvAiLABIUTy sTXTEUEnT 

Approved for public release; distribution unlimited. 

1 3. ABSTRACT (Maximum 200 vnrds) 

12b. DIsYriBUTION COD^ ... 


R.R. Software, Inc., Janus/Ada 2.2.0 PHAR Lap/DOS, Wright-Patterson AFB, OH, IBM PS/2, MOD. 80 Phar Lap/DOS 3.3 
(Host & Target), ACVC 1.11. 




14. SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECURITY CUSSIFICATION 
OF REPORT 

UNCLASSIFIED _ 

NSN 7540-01-280-550 


18. SECURITY CLASSIFICATION 

UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 
UNCLASSIFIED 


15. NUMBER OF PAGES 

16. PRICE CODE 

20. LIMITATION OF ABSTRACT 


Sandard Form 298, (Rev. 2-89) 
Prescribed by ANSI Std. 239-128 



















Certificate Information 


The following Ada ii^plementation was tested and determined to pass ACVC 
1.11. Testing was coiqpleted on 29 November 1990. 

Conpller Name and Version: Janus/Ada 2.2.0 Phar Lap/tX)S 

Host Conpiter System: IBM PS/2, VCD. 80 (under Phar Lap/COS 3.3) 

Target Conputer System: IBM PS/2, MOD. 80 (under MS DOS 3.3) 

Customer Agreement Number: 90-08-02-RRS 


See Section 3.1 for any additional information about the testing 
environment. 

As a resxilt of this validation effort. Validation Certificate 

901120W1.11088 is awarded to R.R. Software, Inc. This certificate expires 

on 1 June 1993. 

This report has been -reviewed and is approved. 




Ada validation Facilx^ 

Steven Wilson 
Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


/ 


/ Ada Validation Organization 
Director, Conputer & Software Engineering Division 
, Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Ctt^ce 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 


Ac«»Asioa ?or 

DTIC TAB □ 

Uao-naotuHied q 




-- 

;_Di3iributljon/ 


iAv^llabll-ltr Codi«8 
j |Avail and/or 
iDlat j Spocial 








AVF Control Number ;AVF-VSR-436-0891 

1 August 1991 
90-08-02-RRS 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 901120W1.11088 
R.R. Software, Inc. 

Janus/Ada 2.2.0 Phar Lap/DOS 

IBM PS/2, MOD. 80 Phar Lap/DOS 3.3 »> IBM PS/2 MOD. 80 MS DOS 3.3 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


Declaration of Conformance 


Compiler Implementor : R.R. Software, Inc. 

Ada Validation Facility ; Wright-Patterson AFB, Ohio 45433-6503 
Ada Compiler Validation Capability (ACVC) Version : 1.11 


Base Configuration 

Ada Compiler Name : Janus/Ada Version : 2.2.0 Phar Lap/DOS 

Host Architecture: IBM PS/2, Mod. 80 Host OS & Ver.:Phar Lap/DOS 3 
Target Architecture: IBM PS/2, Mod.80 Target OS & Ver.: MS DOS 3.3 

Implementor's Declaration 


I, the undersigned, representing R.R. Software, Inc. have 
implemented no deliberate extensions to the Ada Language Standard 
ANSI/MIL-STD-1815A in the compiler listed in this declaration. I 
declare that R.R. Software, Inc. is the owner of record of the Ada 
compiler listed above, and as such, is responsible for maintaining 
said compiler in conformance to ANSI/MIL-STD-1815A. All 
certificates and registration for Ada language compiler listed in 
this declaration shall be made only in the owner's corporate name. 




ames StsWart ' 
Vice President 
R.R. Software, Inc. 


/i£.' /99S 

Date 


Owner's Declaration 

I, the undersigned, representing R.R. Software, Inc. take full 
responsibility for implementation and maintenance of the Ada 
compiler listed above, and agree to the public disclosure of the 
final Validation Summary Report. I declare that all of the Ada 









TABLE OF CONTENTS 


CHAPTER 1 INTRCJDUCTICN 

1.1 USE OP THIS ^^lnATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES. 1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST NCX)IFICATIQNS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 ...3-1 

. 3.3 TEST EXECUTION ..3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 

















CHAPTER 1 


INTRODUCTION 


Hie Ada inpleiMntation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Confiiler Validation Capability (ACVC). This Validation Suinnary 
Report (VSR) gives an account of the testing of this Ada inplementation. 

For any te^ical terms used in this report, the reader is referred to 
ipro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the united States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the cospiters, operating systems, and compiler versions identified 
in this report. 

Hie organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and cosplete, or that the subject inplementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF vdiich performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF vdiich performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801‘North Beauregard Street 
Alexandria VA 22311 


1-1 







INTRODUCTIGN 


1.2 REFERENCES 


Reference Manual for the Ada Proarainming Language, [Ada83] 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Ada Conpiler Validation Procures, Version 2.1, [Pro90] 

Ada Joint Program Office, August 1990. 

Ada Ccmpiler Validation Capability User's Guide, [UG89] 21 June 1989. 


1.3 ACVC TEST CLASSES 

Ccxnpliance of Ada inplementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. Die first letter of a test name identifies the class 
to idtiich it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at conpile time and link 
time, respectively. 

Die executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result vHien they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some conpiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. Die package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. Die procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. Die operation of REPORT and CHECK_FILE is checked a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a confiiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is cospiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code vdiich must not be flagged illegal by the conpiler. This behavior is 
also verified. 

Class L tests check that an Ada inplementation correctly detects violation 
of the Ada Standard involving multiple, separately conpiled units, Errors 
are expected at link time, and execution is attenpted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
inplementation-specific values — for exanple, the largest integer. A list 
of ^e values -used for this inplementation is provided in ^pendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
iirplementation-dependent characteristics. The modifications required for 
this inplementation are described in section 2.3. 


1-2 



DJTRODUCTICN 


"For each Ada iiq>leinentation, a customized test suite is produced by the 
AVF. Ihis customization consists of meOcing the modifications described in 
the prec^ng paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplic^le tests (see Section 2.2 and [UG89]}. 

In order to pass an ACVC an Ada ispleiasntation must process each test of 
the customizi^ test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler Ihe software and any needed hardware that have to be added 
to a given host and target conputer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 


Ada Coopiler 
Validation ' 
Capability 
(ACVC)' 


Ihe means, for testing ccxnpliance of Ada implementations, 
consisting of the test suite, the support programs, the ACVC 
user's guide and the teaplate for the validation summary 
report. 


Ada An Ada coopiler with its host conputer system and its 

Implementaticm target conputer system. 


Ada Joint The part of the certification body vrtiich provides policy and 
Program guidwce for the Ada certification system. 

Office (AJPO) 


Ada The part of the certification body vdiich carries out the 
Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 


Ada The part of the certification body that provides technical 

Validation guidwce for operations of the Ada certification system. 

Organization 
(AVO) 


Coopliance of The ability of the inplementation to pass an ACVC version, 
an Ada 

Implementation 


Conputer A functional \anit, consisting of one or more computers and 
System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during- execution. A 
conputer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 





INTRCXXJCnON 


Conformity Fulfillment by a product, process or service of all 

requirements specified. 

Customer An individual or corporate entity \dio enters into an 

agreanent with ah AVF vdiich specifies the teme and 
conditions for AVF services (of any kind) to be performed. 

.^deration of-A formal statement from a customer assuring that conformity 
Conformehce is realized or attainable on the Ada inplementation for 
v^ich validation status is realized. 

Host Ccapiter A conputer system where Ada source programs are transformed 
System into executable form. 

Inapplicable A test that contains one or more test objectives found to be 
test irrelevant for the given Ada inplementation. 

ISO International Organization for Standardization. 

LBH The Ada standard, or Language Reference Manual, published as 

ANS1/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>;<paragraph>." 

Operating Softvmre that controls the execution of programs and that 
System provides services such as resource allocation, scheduling, 

input/output control, and data management. Ust^lly, 
operating systems are predominantly software, but partial or 
conplete hardware implementations are possible. 

Target A conputer system where the executable form of. Ada programs 

Computer are executed. 

System 

Validated Ada The compiler of a validated Ada inplementation. 

Conpiler 

Validated Ada An Ada implementation that has been validated successfully 
Inplementation either by AVF testing or by registration [Pro90]. 

Validation The process of checking the conformity of an Ada conpiler to 
the Ada programming language and of issuing a certificate 
for this inplementation. 

Withdrawn A test found to be incorrect and not used in conformity 

test testing. A test may be incorrect because it has an invalid 

test objective, fails co meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 


CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn-by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 21 November 1990. 


E28005C 

B28006C 

C34006D 

C35702A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C7430aA 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

• C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1S02B 

BD1B08A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

■CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3i902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives vhich are irrelevant 
for a given Ada inplementation. Reasons for a test's inapplicability may 
be supported by documents issued by ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
inplementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 






IMPLEIQNIATION DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MftX_DIGITS; 


C24113Li.Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 21 tests check for the predefined type SHORT_INTEGER: 


C35404B 

B36105C 

C45231B 

C45304B 

C45411B 

C45412B 

C45502B 

C45503B 

C45504B 

C45504E 

C45611B 

C45613B 

C45614B 

C45631B 

C45632B 

B52dC4E 

a)710lE 

C55B07B 

B55B09D 

B86001V 

C86006D 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a predefined 
integer type with a name other than INTEGER, IjCMG_INTEGER, or 
SHORT_INTEGER. 

C35702A, C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLQAT, or SHORT_FLCiAT.. 

C45531M..P (4 tests) and C45532H..P (4 tests) check fixed-point 
operations for types that require a SYSTEH.HAX_MANTISSA of 48 or 
greater. 

C45624A checks that, the proper exception is raised if NACHINEjOVERFLCWS 
is FALSE for floating point types with digits 5.. For this 
in^lementation, HACHINE_OVERFLCMS is TRUE. 

C45624B checks that the proper exception is raised if MACHINEJDVERFLCWS 
is FALSE for floating point types with digits 6. For this 
in?>lementation, MACHINEjOVERFLCWS is TRUE. 

D55A03E..H (4 tests) use 31 or nrare levels of loop nesting which exceeds 
the capacity of the conpiler. 

D56001B uses 65 levels of block nesting which exceeds the capacity of 
the conpiler. 

D64005F..G (2 tests) use 10 or more levels of recursive procedure calls 
nesting vdiich exceeds the capacity of the compiler. 

B86001Y checks for a predefined fixed-point type other than DURATIOI. 



IMPLEMENIATiai DEPENDENCIES 


C96005B checks for values of type DURATIOSI'BASE that are outside the 
range of DURATICW. There are no such values for this inplementation. 

IA3004A, IA3004B, EA3004C, EA3004D, aG004E; and c:A3004F check for 
pragma INLINE for procedures and functions. 

CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-defa\ilt sizes for access types. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions. 

AD9004A uses pragma INTEE^ACE for overloaded subprograms; this 
iiqplementation rejects this use due to calling conventions. (See 
section 2.3.) 

CCA201C instantiates unchecked Conversion with an array type with a 
non-static index constraint; tHis in^lementation does not support 
Unchecked_Conversion for types with non-static constraints. 

The tests listed in the following table are not applicable because the 
given file operations are supported for the given combination of mode 
and file access method. 


Test 

File Operation Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 ~ 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE , 

, DIRECT 10 

CE2102N 

OPEN- 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT 10 

CE3102E 

CREATE 

IN_FILE 

TEXT 10 

CE3102F 

RESET 

Any Mode 

TEXT_I0 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT_IO 

CE3102K 

OPEN 

aiT FILE 

TEXT_IO 


2-3 


IHPLEMENIATION DP>ENDENCIES 


The following 16 tests check operations on sequential, direct, and text 
files v^en multiple internal files are associated with the same external 
file and one or more are open for writing; USE_ERROR is raised \dien this 
association is attempted. 


CE2107B.iE CE2107G..H CE2107L CD2110B CE2110D 

CE2111D CE2111H CE3111B CE3111D..E CE3114B 

CE3115A 

EE2201D uses instantiations of package SEQUENTIAL_IO with unconstrained 
array types; this inplementation raises USE_ERROR on the attenpt to 
create a file of such type. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for SEQUENT1AL_I0. This implementation does 
not restrict file capacity. 

EE2401D uses instantiations of package DIRECT_IO with unconstrained 
array types; this inplementation raises USE_ERROR on the attenpt to 
create a file of such type. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_IO. This implementation does not 
restrict file capacity. 

CE3304A checks that USE_ERROR is raised if a call to SET LINE LENGTH or 
SCT_PAGE l,ENGTH specifies a value that is inappropriate Tor tHe external 
file. Tfiis implementation does riot have inappropriate values for either 
line length or page length. 


'2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 88 tests. 


The following tests were split into two or more tests because this 
inplementation did not report the violations of the Ada Stemdard in the way 
expected by the original tests. 


B22003A 

B24007A 

B24009A 

B25002A 

B26005A 

B27005A 

B29001A 

B37106A 

B51001A 

B53003A 

B55A01A 

B63001A 

B63001B 

B73004B 

B83003B 

B83004B 

B83004C 

B83004D 

B83004F 

B83030D 

B83E01C 

B83E01D 

B83E01E 

B83E01F 

C85006A 

C85006B 

C85006C 

C85006D 

C85006E 

B91001H 

BAIOOIA 

BA1.001B 

BAIOOIC 

BAlOlOA 

BAIOIOD 

BAllOlA 

^lOlE 

BA3006A 

BA3006B 

BA3007B 

BA3008A 

BA3008B 

BA3013A 

BC2001D 

BC2001E 

BC3005B 

BD2B03A 

BD2D03A 


BD4003A 


2-4 



IMPLEMENTATION DEPENDENCIES 


C85006A. .E (5 tests) were graded passed by Test Modification as directed 1:^ 
the AVO. This in^lementation generates more object code for these tests 
than it can contain in a single conpilation unit. Each of these tests was 
split into five equivalent subtests. 

The tests below were-graded passed by Test Modification as directed the 
AVO. These tests all use one of the generic support procedures, 
LengthjCheck or EnumjCheck (in support files LENCHECK.ADA & EXnJMCHEK.ADA), 
v^ch use the generic procedure Uhchecked_Conversion. This in 5 >leiDentation 
rejects instantiations of UhcheckedjConversion with array types that have 
non-static index ranges. The AVO ruled that since this issue was not 
addressed by AI-00590, v^ich addresses required support for 
UhcheckedjConversion, and since Al-00590 is considered not binding under 
ACVC 1.11, the support procedures could be modified to remove the use of 
UhcheckedjConversion. Lines 40..43, 50, and 56..58 in LENCHECK and lines 
42, 43, and 58..63 in ENUHCHEK were commented out. 

CD1009A CD1009I CD1009M CD1009V CD1009W CD1C03A 

CD1C04D CD2A21A..C CD2A22J CD2A23A..B CD2A24A CD2A31A..C 

CD2A81A CD3014C CD3014F CD3015C CD3015E..F CD3015H 

CD3015K CD3022A . CD4061A 

BO4006A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test checks that non-static values in component and 
alignment clauses are rejected; but static alignment values of 8, 16, & 32 
are assumed to be supported. This inplementation supports only values 1 & 
2; it rejects the clauses at lines 42, 48, 58, and 63, v^ich are not marked 
as errors. 

AD9001B was graded passed by Processing Modification as directed by the 
AVO. This test checks that, if pragma INTERFACE is supported, no bodies 
are required fcr interfaced subprograms. This implementation requires that 
some foreign bodies exist, even if the subprograms are not called. This 
test was processed in an environment in v^ich inplementor-supplied foreign 
bodies were present. 

AD9004A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test uses a single INTERFACE pragma for several overloaded 
procedure and fxinction subprograms; this implementation does not support 
the pragma in such circumstances due to the calling conventions of the 
interfaced language, and thus rejects the pragma. 

CDA201C was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test instantiates Unchecked_Conversion with an array type 
with a non-static index constraint; this implementation does not support 
Unchecked_Conversion for unconstrained types and so rejects the 
instantiation. The AVO ruled that various restrictions on 
Unchecked_Conversion may be accepted for validation under ACVC 1.11, 
because AI-00590, which addresses Unchecked_Conversion, did not show an ARC 
consensus at the time of ACVC 1.11's release. 


2-5 


inPLEHENTA.T10N DEPENDENCIES 


C^IOSB, CE2108D, and CE3112B were graded passed by Test Modification as 
directed by the AVO. These tests, respectively, check that tenporary files 
that were created by (earlier-processed) CE2108A, CE2108C, and CE3112A are 
not accessible after the completion of those tests. However, these tests 
also create ten^rary files. This implementation gives the same names to 
the tei^rary files in both the earlier- and later-processed tests of each 
pair; thus, CE2108B, CE2108D, and CE3112B report failed, as though they 
have accessed the earlier-created files. The tests were modified to remove 
the code that created the (later) temporary file; these modified tests were 
passed. Lines 45..64 were comsmented out in CE2108B and CE2108D; lines 
40..48 were camnented out in CE3112B. 


2-6 


CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

Itie Ada i8{)leinentation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
iiqplementation system, see: 

Isaac Pentinmaki 
R.R. Software, Inc. 

P.O. Box 1512 
Madison, WI 53701 

For a point of contact for sales information about this Ada implementation 
system, see: 

Jim Stewart 
R.R. Software, Inc, 

P.O. Box 1512 
Madison, WI 53701 


Testing of this Ada inplementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 Summary Of Test Results 

An Ada- Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, vrtiether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 


3-1 






PROCESSING INFORMATICXJ 


For all processed tests (inapplicable applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the inplementation's maximum 
precision (item e; see section 2.2), and those that depend on the support 
of a file system — if none is supported (item d). All tests passed, 
except those that are listed in sections 2.1 and 2.2 (counted in items b 
and f, below). 


a) Total Number of ^plic 2 ±)le Tests 3773 

b) Total Number of Withdrawn Tests 83 

c) Processed Inapplicable Tests 113 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 314 


g) Total Number of Tests for ACVC 1.11 4170 


3.3 TEST EXECUTION 

The diskettes containing the customized test suite (see section 1.3) were 
taken on-site by the validation team for processing. The contents of the 
diskettes were installed onto a Northgate 386 widi DOS 3.30 and then 
archived for installation on the actual host computer. The files were 
restored onto an IBM PS/2 Model 80 with DOS 3.30. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada inplementation. . 


The tests were conpiled and linked on the host conputer system, as 
appropriate. The executable images were transferred to the target conputer 
system by the communications link described above, and run. The results 
were captured on the host computer system. 


Testing was performed using command scripts provided by the customer and 
review^ by the validation team. See Appendix B for a complete listing of 
the processing options for this inplementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


3-2 







PROCESSING INFORMATim 


Itie options used for Janus/Ada are: 

/Q - Quiet error messages - suppresses user pronpting on errors. 

Necessary for running B-Tests; otiierwise every error would have 
to be responded to. 

/W - Warnings off - warnings were suppressed mainly because of the 
many confusing warnings the validation tests produce. Many 
validation tests have intentional errors (such as an expression 
which always raises an exception, use of null ranges, imreachable 
code, etc.). The large volune of warnings produced made it 
difficult to grade the B-Tests in particular, so they were 
suppressed. 

/BS - Brief Statistics. This was also used to cut the amount of output 
produced by the con^iler during compile time. 

/S? - Used this option to re-direct the coitpiler scratch files into 
a Ram disk \diere possible (? is replaced by a drive path), 
thus speeding up the coo^iles. 

/01 - Memory aodel 1 - this directs the compiler to use memory model 1 
for the output. This model allows much more code than memory 
mcdel 0, and is necessary in order to have a few large tests be 
able to run. 

/D - Debugging code off - this directs the compiler to not generate 
any debugging code (generally line numbers and walkt)acks). This 
was also used to cut the space used by the tests. 

All other options used their default values. 

Then, all of the non-B-Tests were linked with the options: 

/Q - Quiet error messages - suppresses user.proiipting on errors. 

Necessary for running L-Tests; otherwise every error would have 
to be responded to. 

/T - Trim unused code - this option directs the linker to remove 
unused subroutines from the result file. This can make as much 
as a 30K space saving in the result file. 

/B - Brief Statistics. This was also used to cut the amount of output 
produced by the Linker. 

/01 - Memory model 1 - to match the compiler memory model. 

All other options used their default values. 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 





APPENDIX A 


MACRO PARAMETERS 


Hiis appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG69]. The 
parameter values are presented in two tables. The first table lists the 
valpes that are defined in terms of the maximum input-line length, which is 
the value for $MAX_ZN_LEN—also listed here. These values are expressed 
here as Ada string"aggregates, vdiere "V” represents the maximum input-line 
length. 

Macro Parameter • ■ Macro Value 


$MiVX_IN_LEN 200 

$B1G_ID1 (1..V-1 -> 'A', V-> '1') 

$BIG__ID2 (1..V-1 -> 'A', V-> '2') 

$BIG_ID3 (1..V/2 -> 'A') & '3' & 

(1..V-1-V/2 -> 'A') 

$BIG_1D4 (1..V/2 -> 'A') & '4' & 

{1..V-1-V/2 -> 'A') 

$BIG_INT_LIT (1..V-3 -> '0') & ''298" 

$BIG_REAL_LIT (1..V-5 -> '0') & "690.0" 

$BIG_STRING1 & (1..V/2 -> 'A') & 

$BIG_STRING2 & (1..V-1-V/2 »> 'A') & '1'. & 

$BLANKS (1..V-20 ) 

$MAX_LEN_INT_BASED LITERAL 

"2;" & (1..V-5 -> '0') & "11;'' 

$MAX_LEN_REAL_BASED_LITERAL 

"16;" & (1..V-7 *> '0') & "F.E;" 


A-1 


MACRO PARAMETERS 


$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 

The follovd.ng table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 


$ACC_SIZE 

$ALZGNHENT 

$COUNT_LAST 

$DEFAULT_MEM_S1ZE 

$DEFAULT_STORJUNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

$EMTRY_ADDRESS2 

$F1ELD_LAST 

$FILE_TERHINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$PORM STRING2 


16 

2 

32_767 

65536 

8 

MS_D0S2 
2#1.0#E-31 
(O', 16#40#) 

(0, 16#05#) 

(0, 16#01#) 

32_767 

f f 

NO_SUCH_FIXED_TYPE 

Nq_SUCH_FLOAT_TYPE 

tin 

CANNOT RESTRICT FILE CAPACITY 


$GREATER THAN DURATION 


300 000.0 


$GREATER THAN DURATION BASE LAST 

T.0E6 

$GREATER THAN FLOAT BASE LAST 

l.'ijE+40 

$GREATER_THAN_FLQAT_SAFE LARGE 

1.UE38 


A-2 






PARAMETERS 

$GREATER_THAN_SHORT FLOAT SAFE LARGE 

1.0E308 " 

$Hica!_PRiORiTy ■ 0 

$ILLEGAL_EXTERNAL_FILE_NftMEl 

/NODIRECTORY/FILENAME 

$ILLEGAL EXTERNAL_FILE_NAHE2 

<BAD/''"> 

$INAFFROPRIATE LINE LENGTH 
- - _1 

$INAPPROPRIAT£ PAGE LENGTH 
" -1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.ADA") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE (’'B28006E1.ADA'') 

$INTEGER_PIRST -32768 

$INTEGER__LAST 32767 

$INTEGER_LAST_PLUS__1 32768 

$INrERFACE_LANGUAGE MASM 

$LESS_THANJXJRATION -305_000.0 

$LESS_THAN DURATION BASE FIRST 

“ -1T0E6 

$LINE_TERMINATOR ASCII.CR & ASCII.LF 

$LOW_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 

$MIN INT 


-214783648 









MCRO PABAMETERS 


$NAHE 

N0_SUCH_INTEGER_TYPE 

$NAME_LIST 

MS_DOS2 

$NAME_SPECIFICATICW1 

D;/VALID/X2120A 

$NAME_SPECIFICATION2 

D:/VALID/X2120B 

$NAME__SPECIFICATiaj3 

D:/VALID/X3119A 

$NEG_BASED_INT 

16#FFFF_FFFF# 

$NEW_MEM_SIZE 

65536 

$NEW_STORJUNIT 

8 

$NEK1.SYS_NAME 

MS_DOS2 

$PAGE_TERMINATOR 

ASCII.FF 

$RECORD_DEFINITION 

RECORD NULL; END RECORD; 

$RECORD_NAME 

NO__SUCHJMACHINE_CODE_TYPE 

$TASK_SIZE 

16 

$TASK_STORAGE_SIZE 

512 

$TICK 

0.01 

$VARZABLE__AK)RESS 

FCNDECL.SOME_VAR'ADDRESS 

$VARIABLE_ADDRESS1 

FCNDEn,. SOME_VAR2 'ADDRESS 

$VARIABLE_ADDRESS2 

FCNDECL. S(»IE_VAR3 'ADDRESS 

$YOUR_PRAGMA 

ALL_CHECKS 


A-4 







APPENDIX B 


COMPILATICXJ SYSTEM OPTIWS 


The conqpiler options of this Ada in^leinentation are provided by the 
customer and can be found in A^^ndix F, section F.9, page F-14. 


B-1 








COMPILATION SYSTEM OPTIONS 


LINKER OPTIONS 

The linker options of this Ada inplementation are provided by the customer 
and can be found in ^jpendix F, section F.9, page F-14. 


B-2 



JUnk Manual 


Jlink Manual 

The Janui/Ada linker is used to combine a main program with system and 
user defined compilation units to create an executable program. Only object 
code flies • that Is, JRL (Janus relocatable) and SRL (spaciflcatlon relocatable) 
files • created by the Janus/Ada compiler, assembler, or other compatiUe 
products can be combined. For more information on SRL and JRL files, see 
Section 10,1 uf tlie compiler manual. The linker only needs to be supplied 
with the name of th<> obj^t code file for the main program. It will search disks 
(Including a swap disk. If desired) for the required units. It deiennines the 
loading order of tlie units, and finally produces an executable program. The 
linker is disk based, so any possible sized program may be linked with JUNK. 
It may not be possible to produce an easier to use linker. 

Using the Linker 

The user only needs to type the command 
JLINK (d;]progjiume 

to mil the linker. The disk name d; specifies the disk on which to look for the 
main program. The prog, name Is the name of the object code file for the 
main program, without the .SRL or JRL file name eximlon. The result file 
Is placed Into the file witii the same name as the main program object code, 
aixi tltc file name extension appropriate for your system (.COM or .EXE for 
MS*DOS). The result file is placed on the disk where the main program is 
found. 

Examples; 

JUNKTESTPROG 

•• Links Tastproy to maku an exucutabla piogiem. 

JLINK B.QSORT 

-• Links Qson (y«iiic-ri will be tound on tne B; disk) 

•• into an eAScuiabie piogrom 

This is all of the infomiatlon needed to use the linker. More details about the 
operation of the linker will be found on succeeding pages. 


Lii'i.K-l 


RtvUion 4.6 







Jlink'M&nual 


Linker Operation 

The linker operates automatically. However, to better understand the opem* 
tlon of tlie linker options (below), a brief description of the linker operation 
is given here. 

The following disk (drive) name dellnlUons are used throughout the rest of 
the linker manual. 

The default disk is the one currently logged in on yourqtstem. This is the disk 
name which appears in the system prompt. 

The source disk Is the disk which U specified on tlie command line as the 
source of the main program. Unless a different disk is specified on the 
command line, it will be the default disk. 

The destination disk is the disk to which the output esecutable file will be 
written. Unless a different disk is specified on the command line, it will be the 
source disk. 

The swep disk is a disk specified on the command line which allows a whole 
set of di^ to be search^ by swapping each disk into a disk drive. Any disk 
other than the destination disk may be used for this purpose. There is no 
swap disk unless the swap opUott is used. 

In many cases, the default, source, and destination disks refer to the same 
hard disk, and (he swap disk is not needed. 

There are two kinds of segments (memory areas) referred to in this manual. 
Physical segments aie the segments impp^ by the underlying hardware. A 
logical segment U the segmenting imposed by the Janui/Ma compiler and 
assembler. Each unit is divided into three logical segments - code, data, and 
constant. Tlw linker's Job is to combine many logical segments into the proper 
number of ptiysicai segments. Whenever a segment is referred to in the rest 
of this manual, it means a logical segment, unless otherwise noted. 

The mapping between ph^'sical segments and logical segments Is specified, 
by the progreim's memory model. Many machines with modem architectures 
ailow the mapping of the many logical segments Into one large physical 
segment. These machines require only one memory model. Other machines 
(like the 8086 family) have an architecture which makes the mapping more 
difficult. The different models generate different amounts of code, run at 
different speeds, and have ditferent limits on the size of programs. 

UNK.2 

Copyrlyhl 1969 R H Schwais, !nc 







JUnkMMual 


On the 8086 {and chips in the same family), the default memory model will 
generally cause the linker to produce a COM file. This memory model, called 
Model 0, has a maximum of OAK of code in a program. To allow the use of 
more code in a program, one may use tire /01 (Model 1) option in both the 
compiler and in the linker (see below). ThU option causes the linker to 
produce atr EXE file; the code size is restricted then only by your operating 
system and by the amount of memory available on your machine. Note that 
some versions of the Janus/Ada compiler are sold without the libraries to 
allow the use of Model 1. 

All compilation units In a given program must be compilad with the same 
memory model, and the program mu&t be linked with that same model; the 
compto attd iiie linker enforce this nile. 

The linker operates In three phases. The first phase loads thi haadari of all 
of the units, and thereby determines witleh units are needed. This phase also 
records the disks where the units are found (for later use) and creates a table 
of entry points (places where other units may access this one). The disks are 
searched in the following order; first the source disk, then tire default disk, 
and iiten the swap disk umH all of tire units are found (or the linker is aborted 
by the user). 

The second phase does not use the disks at all The table of units to load 
created by the first phase is used to determine the loading order of the units. 
This step Is necessary due to the elaboration rules of Ada (See Section 10.5 
of the compiler ntamial), sittce Janus/Ada loads units in the order in which 
they are to be elaborated. The load address of each unit is detennlned In this 
step. The second phase tries to minimize the anrount of disk swapping that 
will be necessary in ihe third phase 

The third phase reads In each unit, fixes up all external references and 
reiocatabie items, arid writes out the resulting executable file. [External 
references are usages of Items declared outside of the unit being linked. The 
linkage Informatlotr held in an extcriral reference is replaced by actual 
machiiite addresses when It is ’fixed u|>' ] 

If the swap option is not used, as i$ usually ilte case when compiling from a 
hard disk, the fixing up is done without any user intervention. A prompt 1$ 
issued each time the swap disk needs to be changed, wKh a list of the units 
which should be on the disk Inserted. The linker tries to be friendly about 
errors in this process - It the designated file is not found, It just asks again for 
the disk to be Inserted. 


: It 


:k.3 


Revision 4.6 





Jlltik Manual 


Linker Command Line and Options 

The linker command line looks Mte: 

JUNK (D:jprog_nam 0 {/optiona} 

The prog_name Is the name of the object code file (SRL or JRL file) of the 
main program, without the '.SRL" or * JRL” extension. (We will refer to this 
simply as an SRL file from here on In this manual; howew, everything said 
about the main program’s SRL file should be understood to apply If the main 
program Itas generated a JRL (as It would If a separate spedflcatlon was 
provided]). The opllonal disk name D allows the source di^ to be specified 
as sonte other disk titan the default disk. The main program's SRL file should 
be found on the source disk. The main program must be a JanuVAda 
paremeierless procedure. 

Note: 

No file'name extension is allowed. 

In general, the name ol tlte SRL file for the main program oonasponds to the 
first eight letters ol tlie unit name for the main program. If that name had 
already been used by sonte other urtit, however, tlten the SRL file name wilt 
vary. This can only itappen it some other unit In the same program library 
has the same first eight l^ers as the main progiam. For more intonnatlon on 
JanusfAda file naming conventions, sea Section KXl of the Jenus/Ada 
compiler manual. 

Many users will never ne^ any options; most tlrat do will need only the /Ol 
option to allow for tire iar^r memoiv model, the /F2 option to use hardware 
floating point, the /T option to reduce the sfa» of the executable, or occasional* 
iythe/E,/L,/Q,or/S opt torts. However, all the following options art provided 
to increase the flexibility ol the linker 

Chhhh Set the starting address of the code within the physical code 
segment to hhhh (hexadecimal). The physleal code segment will 
still be allocated from zero by the operating system. The physical 
code segment con be loaded anywhere in special applications, so 
tills option will be used very rardy. The resulting program will not 
woik under MS-DOS. 

Dhhhii Set the starting addtess of the data within the physical data 
segment to hhtih (hcxadecinial). The p.hyslcal data segment will 
stil! be allocated from zeio. The physical data segment allocation 


Copyrl 9 hl 19S9. J( It Sciiwau*. Inc 


UNK.4 







Jlink Manual 


address can t:>e changed by modifying JLIB86. Tliis option will 
only be used for very applications. The TMultlng program 
will not wotk under MS DOS unless JUB86 Is modified, 

E Create an EXE file. This tsassumed if the/01 option Is given. This 

allows allow a somewhat larger total progmm size if memory 
model 0 is used, by using different physical segments for the loglcd 
constant segment and the logical code segment. 

Fn Usethe class n (where n is 0 or2) floatingpoint Ubmry. If a floating 

point library of the specified class already exists in the link, then It 
is used. Othctwfse, the default floating point library is used. If this 
option is not used, the class 2 libreiy Is used If any unit was 
complied with the /F (hardware floating point) compiler option, 
or otherwise contains hardware floating point operations; and the 
class 0 llbraiy U used otherwise. The cls^ses are: 

0 Universal sofnvare floating point (FLOATOPS). 

1 Noi supix>rtcd in our Ada compilers. 

2 UnivC'Kal haidware floating point (FLOATS? on the 8086 
series). IVurning' In some versions of Janus/Ada, the 
hardware of II le 8087 chip can cause some surprising results 
when using this option. Qredr Apixmdix Section L2 in the 
compiler manual to see If your veision Is affected. 

3 N(;t supported in our Ada compilers. 

This option allows the use of different fonns of floating point sup- 
pot t without mcotnpiling the piogram. It also eliminates the pos¬ 
sibility' of mote (Itan one floating point library being used in a 
single program (whicit does nut work!). An error ts generated If you 
tty to use software supfjoit wltli units compiled with the /F option. 

L Turtu on the listing option. The currant unit being worked on is 
printed, attd a table of addresses for each unit is listed on the con¬ 
sole. 'I'hese can be used tor debugging. Ttie format of the table is: 

Pack-nnme Code-hbhli Data-hhhh Const-hhhh 
where hhhh is the hex value of the first address assigned to that 
unit's codv data, or cointaiil segment. Tlie order given for the 
units III titv si.'v.'ciid .'.nd third passes of the linker specifies the 


UNK-S 


R«vi(l0n4.6 






Jiink Maiiusl 


elAboidUon oixier of tfic various units (saa Section 10.5 of the 
compikir manual). 

' Mhlthh Set the minimum size of the physical code segment phis the 
physical constant segment. The size hlihh is In paragraphs (16 
byte Inctenu^iits). This forces the start of the physical data segment 
to start t'.hhhO (hex) bytes after the start of the physical code 
segment. If this option is used, and the physical code segment plus 
the physical constant segment size exce^ the minimum sImi a 
warning ntussage is produced. This option is primarily useful for 
programs which use the Chain procedure and wish to preserve 
the physical data segment. The option essentially causes the 
physical data segment to be in the same absolute locations In each 
program which uses it 

This option may only, be used with the small memoiy model 
(model U). 

On Use memoiy model n (when n Is a number between 0 and 7). This 
option Is us^ lo specify an altemattve memoiy model to the small 
model used by default. A!! Units linked must be compiled or 
assembled with tlx: specified memory modet The memory models 
are: 

0 Small code. (64K code, 64K data, 64K constants). The 
dclauli modet, and the only one supported In the C-Pak. 
Tills model generates a COM nie, unless the /E option Is 
specitled. A COM file Is limited to 64K total for both code 
and constants. If more Is necessary, use.tha /E option, or 
model !.• 

1 Largecode. (Untlmltedcode,64Kdata,64KconitBnts).The 
code sUe is limited by available memoiy. This model is 
appropriate for larger programs. This model generates a 
fite. Frogiams that use this model will typically be 
atx3ut ten io twenty percent bigger and slower than the 
equivalent piogiam using model 0. 

2-7 Unused. 

Q Produce quiet error messages. In the nomial mode of operation, 

the link watts after cv%'iy error so that the user can see the error 
without it scrcllii^ off ihe screen. This option suppresses those 
prompts. 

UNK 6 

Copyright 198V. f{.R SotivaiK, Iik. 



Jllnk Manual 


l^ih Re'direct the linker ouhiiit 1o the specified path, the default is the 
same palh ns nieruune. 

Spath Use the specified path as the swap disk. The linker will abort If all 
of the libraries needed iti the current ptogtam are not found on 
the source or default disk when t\o swap disk is specified. If a swap 
disk is spccifled. a prompt will be Issued for the user to change the 
swap disk. ITte linking may be aborted at any time during a swap. 
The swap disk may not be the same as the destination disk. Any 
other path may be used This option Is most usehil on systems 
with limited disk capaci^' (l.e. s^ms with less than 720K per 
disk). 

T Trim out unteacltable subprograms from units that were compiled 

with the compiler's /T option (see AppendU Section H.1 of the 
compiler ntanunl); this can significantly reduce the tbe of the 
executable (iie,- at the cost of slowing down the linking process. 
Using this option invokes an extra pats, between the fltst and 
second linlicr passes, to do the requested trimming. We strongly 
recommend using this option on (at least) final versions of 
programs. 

Uhhhh Set the storting address of the constants within the physical 
constant segment to hhhti hexadecimal. 'The physical constant 
segment will still be allocated from zero. The physical constant 
segment allocation address can be changed by n^fylng JUB86. 
This option will only be used for very special applications. The 
resulting program will not work under MS-DOS unless JUB86 Is 
modified. 

X Produce an eXtra detailed link map for the program. This wilt be 
left m a (tie called <prog_name>.LNK. where <piog^name> is 
the name oi the niatn piograin. This file Is mainly for the use of 
debuggers and otlici luiure tools. 


Examples: 

JUNK B:TESTPROG/RO 
•• Link Testpiog tiom me &; UisK. and put the 
- result on the D: disk. 

JUNK C:CHAIN/SB/L 

•> Link Cham from tno C. disk, soaich the B. disk 
•• tor needed units ei!ov/ing mu user to swap disks 


LIMK.7 


Rcvblon 4.6 









Jlink Manual 


- whan nuedad. Put tha lesult onto tha C. disk, 

.. and display a listing of tha link addrsasas. 

JLINK B:SAVEOArA/.M8000/F2 

- Link SavaData from tha B: disk, forcing tha coda aUa 
to ba at laast BOOO Hax bytas. Uaa floating point 

>• modal #2. 

Enor Measagcs 

All anon excapt warnings ate fatal. Tha llnkar will prompt tha user after an 
error so that the user Is sure to notice the error. (These prompts may be turned 
off by the /Q option). Fatal errors abort the linker. 

Some error mcBisagos mention a JRL file explicitly. The meaning may actually 
be for a SRL file; the error messages only mention JRL hr brevity. 

Warninge 

Some units use Floating Point Hardware, yet i Software unit waa apaclfled 

The softwaic and hardware floating point should not be mixed. If 
you have a fluatliig point co-ptocessor on your target machine, we 
recommend using only liardware floating point; otlienwise, use 
only software floating point. 

Tha Code segment la larger than tha minimum 
(See /M option, above, for explanation) 

Tha unit xxxx is obsolaia because yyyy was recompiled 
It will be ignored 

The unit xxxx itas an optional body, and that body was made ob> 
soiete by recompiling yyyy (one of the units withed by xxxx). 

Ada's rules state Durt xx>:x must be Ignored unless it Is recompiled. 
The linker Is Just letting you know that this happened; if you really 
want to have the body of xxxx linked in, you should recompile it. 
This same message can apirear as an enor if xxxx is anything other 
than an optional body. 

Command Line Errors 

These are all caused by an Inconect cornmaixl line. 

Command Lina Option Unknown 


L1NK.8 

Copyright l9Sy. H.R. Soriv^M*. In,.. 



Jllnk Manual 


An option following a slash docs not conespond to any legal linker 
option. 

Disk Name too long 

The disk name In the command tine may have at most one letter. 
Extension too long 

At most three leitets are allc.ved In a file name extension. (Tills mes* 
sage comes from our standard command line parser. In fact, the 
linker does not allow ony flic name extensions) 

Extensions not Allowed in Linker 

The unit name given to link must not have a file name extension. 

Pile Name too long 

The file name In the command line should be at most eight letters 
long. This Is no longer checked in most versions of the linker, so 
this error should not occur. 

Garbage on end of command line 

The linker cannot understand some or all of the command line. 
Make sure that the syntax of the command tine matchee that listed 
In the section called "Linker Command Line and Options,* above. 

Illagei Disk Name for Option 

A disk name for the /R or /S option was not In the range A..W. 

Illegal Value for Option 

The value given with an option that needs one (/F, JO) Is Illegal or 
out of range. 

Missing Disk Name for Option 

An option requiring a dbk name (/R, JS) does not have one. 

Misting Value for Option 

A value was ex{>ected following an option (probably /F or JO). 


I *• It» i\ 


Revkton 4.6 


Jlink Manual 


Multipi* Colons Iii File Naino 

The file nnnie Ibied in (he command line may not have multiple 
colons. 

Multiple Periods in I- lie Name 

The file name listed in the command line may not have multiple 
periods. (Thu message comes from our standard command line 
parwr. In fact, the linker dues not allow file name extensions, so no 
periods are allowed) 

No File Name Present 

No file name was found on the command line. 

No Hex Number git/en (or optlorr 

An option requiring a tiexadecimal number (/C, /D, or/M) does not 
have one. 

No option after slash on command line ■ 

There was a slash on tire command line without anything following 
It 

Paths not allowed in tinker 

The file name In (he command line may' not Indude a path. 

The Swap disk cannot be the same as the destination disk 

Most operating systems do not allow the changing of disks which 
art being written to; therefore the destination disk cannot be used 
as the swap disk. 

Too many digits In hex number 

A hex number speciiled in (lie /C, ID, or /M options may only have 
4 digits. 

Generic Unit Errors 

Illegal generic in6tantia(!o;i in xxxx 

The Instantiation on line number yyyy is indirectly circular. 

A unit may not Instantiaie a unit whicn instantiates the original unit. 

A generic unit cannot Instantiafo a generic unit which, directly or In* 
directly, causex att instantlattcn of the first unit. This error can 
sometimes be determined at compile time. In the case of separately 
compiled getierice, however. It may not be detected until link time. 

UNK-IO 

Copyriald 1989. R.K So.'r.vai. Ihc. 






JlInkMiknual 


In this case, th^ enor message gives the name of the obtject code 
file that was puxluced when one of the offending instantiations 
was compiled, as well as the line number where that Instantiation 
occurred. 

Illegal genarlc insianiiatiott in xxxx 

Parameter number yyyy In tns Instantiation on lino number zzzz 

must not be an unconstrained type. 

Certain rcitilctlons apply to generic actual types if the correspond¬ 
ing generic formal type is used in certain ways in the body of the 
generic unit. In particular, tire generic actual type may not be either 
an uncoiutrainr^ airay subtype (see Section 3.6 of tire compiler 
manual) oi a di«;riminated record subtype with no defaults for the 
discriminants (sec Section 3.7.2 of the compiler manual) if the cor¬ 
responding generic fornral type is used In any of the foUowing 
ways, as the type of a variable declaration; as the type of a com¬ 
ponent declaration; or us the full declaration of a private type, Thjs 
Ttttriction preverrts using gertet let to create objects that n^ to be 
constrained but are not. This error can sometimes be determined at 
compile time. In the case of separately complied generics, however, 
It may not be detected utrill link time. In this case, the error mes¬ 
sage gives the foiiowitrg infunnatlon; the name of the object code 
file that was prcxtuccd wlren lire offending instentlallon was com¬ 
piled; the iramtrreter number irr the instantbtlon; and the line num¬ 
ber where the tnsianiiaUon occurred. 

Link Errors 

Bad. JRL flit • lliagai t^ato Etemam 

The JRI. ftle or SRL file has a bad data eiement. Recompile the indi¬ 
cated unit ntul (if it Is a specification) any units that depend on It. 

Cannot be u Moin Frograrn 

A Mein Program must be « Pararnotoness Procedure. 

The unit that ends up being the iirairi prograttt must be a non¬ 
generic procedure, witli iro parameters. 

Cannot use a .COM trie tut this progrom. 

Tire snrwii model program Iras too much code and constants to fit in 
a COM iile. (MS-DOS puts n 6'IK limit on the .size of COM flics; 
larger ones wilt not load properly.) You siroulct either use the 
linker’s /E anri/br /T optioits if you are not already doing so; 
decrease me size ot the units (perhaps by using the OPTIMEE 

UNK-n 


Rtvision 4.6 





Jllnk Matiued 


. piagmn); or recon)pile and rdink tha anttre program with the large 
memoiy tiKxlu! (model 1). 

Code Segment Ovutlonv • Cannot be larger thon 64K 

You tiled to link a small memory model program (modd 0) which 
has iiKare than 64K of code You should either use the linker’s /T 
option if you are nut already doing so; decrease the size of the 
units (perhaps by using the OPTIMIZE pragma); or recompile and 
relink tlte entiic program wiili the large memoiy model (m^d 1). 

Compilation Units yet to bo loaded • 

(UnItUst] 

ara not found on eitbor the source ot default disks 

The file(s) specified were not found on any of the disks, and are re> 
quiied by this program. 

Constant Segment Oveiflow • Cannot ba larger than 64K 

You tried to link a program with moie than 64K of constants. 
Janus/Ada only allows 64K of constants, due to the aiehitectuie of 
the 8086. 

Data Ssgmont Overflow • Cannot be larger then 6<K 

You tried to link a piogram with more than 64K of statically alloo 
cated data. The maKimum physical segment size Is 64K, arid the 
present version of Janus/Ada doee not allow more than one normal 
physical data segment. If you get this error, you must move enough 
data out of the data segment to allow room both for the statically al> 
located data and for dynamic data, Including local variables and 
objects allocated on the heap. If the package BIGARRAY was tup- 
pIM with your compiler, you can use H to move tome of your data 
into a special pliysicai data segment. 

Dependency Table Oveiiiow 

The linker’s internal table that says which units are interdependent 
has overflowed. If y<}u get this cnor message, your program Is too 
big for Jaruis'Ada to liandle In oi'ke piece. Consider using the 
Janu&'Aila chainitig libmty (CHAINUB) to break up your program 
into separate i^asse: (CHaiNUB Is not provided with all Janus/Ada 
packages). 

Disk Full 

Tire output disk was full. 


Copyright 1989, H it. $ohvv«i*, i:,( 


UNK 12 



Jlink Manual 


Entry Point Tablo Ovarflow 

Thc' cntiy point table has overflowed. If you get this arror message, 
your piograin is too big for JnnuVAda to handle in one place. 
sidOT using the Janus/Ada chaining library (CHAINUB) to break 
up your program Into separate passes (CHAINUB is not provided 
with all Janus/Ada packages). 

Error Number Incoireci 

The linker tried to use an unused error message. Please contact 'as 
with details. 

,JRL file not the same on tna second reading 

This error can only occur if you used two different swap disks on 
the first and second reading of a given unit’s JRL file or SRL flie. 

Minimum Code Option can only be used with memory modal 0 
The /M option Is allowed only for small model programs. 

Missing External Item 

An external Item was not found in the entry point table. The unit 
name in which the Item was expected to be found Is listed with the 
error message. Tiie most likely reason (or this error is an Incorrect 
compilation order. Another possible reason Is that the JRL fUe or 
SRL file for the gK^en unit has been damaged. Try rocompillng the 
offending unit. If that (alts, then try rocompillng the entire program 
(using CARDER, If you have 11, to insure that the order 1$ correct). 
If both of those fail, ploase contact RR Software. 

Not a .JRL fllo from tho curient version ot Janus/Ada 

The JRL or SRL version number (In the file) Is not current. Recom* 
pile the Indicated unit and (it it is a specification) any units that 
depend on it. 

Not enough RAM 

This message Indicates that there Is not enough available random 
access nteniury in your mnciiinc to run tire linker. Janus/Ada re¬ 
quires 64()K of random access memory On your machine. If you 
think you have enough memrmy, but you get this message, (±eck 
whether you arc running any memory resident programs; such 
programs decrease the amount of available memory on your 
machine. If you have enough, memory and no memory resident 
programs, pk-ase i-untact K.K. Software. This message is usually 
printed with the name of one of JLINK’s units; that Information will 


Ll.NK.i3 


R«vUion 4.6 



JUnk Manual 


help our support staff lut you know how much more memoty you 
will nised V: lun the linker. 

Obsolete Units found 

Some of tlie units that wcm to be linked are obeolete: that is, some 
of the units on which they depend have been recompiled more 
recently titan they have. The offending units were listed before this 
message came out. The appropriate units and any units that 
depend on them should be recompiled. If you haveCORDER, the 
Janus/Ada compilation order tool, you may wish to use It io rectmi* 
pile all obsolete units. 

The following complieiion units could not be loaded due to 

e mutual dependency (probably caused by Elaborate pragmei) 

(Unit List] 

The unite Hated below (If any) may/also be mutually dependent 

(UnltUstj . 

The mutual dependency muct be removed. 

The (list list of units shows a cycle of uniu that cannot be loaded. 
The last unit in the list is required to be elaborated before the ftrit 
unit In the list, and each other unit in the list Is required to be 
elaborated before the next unit In the list. Hence, than Is ix> legal 
elaboration order. Tire reason that each unit In the list It required 
to be elaborated belote another listed unit is one of the follming 
three reasons; the unit to be loaded first is a specification and other 
unit is Its body: the unit to be loaded fbst is a spociflcatlon man* 
tionad in a with clause of the other unit, or the unit to be loaded 
first Is a body inentlonod In an ELABORATE pragma of the other 
unit. The secoiKl list of units shows other units that were not 
loadable; these may depend on the units In tire cycle, or there may 
be another cyf If. 

In tJieoty, this error can only occur if an ELABORATE pragma is 
present, since otherwise the compilation order gives a proper ' 
elabomdon order. If you yet this enor and you have no 
ELABOKAT]j( pragmas In your program, then one of your SRL or 
JRL flies is pnrtrab.'y damaged. Recompile your entire program in a 
ptojrer order 

The unit xxxx lu obsolete because yyyy was rscompiled 

Unit xxxx dci'xmds ort unit yyyy, but wyy was compiled more 
recentlyVhan jstrxx. Hv(X}mptie yxxx and any units that depend on 
it. Tills .Sartre message can appear as a wanting if xxxx is an q>tion- 
ai body. 

UNK.14 

Copyrijlil 1989. RR SolM-xi*. Inc 







JUnk Manual 


Too many Compilation Units In ona ProQram 

Ona piograri) nwty hava only 300 compilation unlit. If you axcaod 
this limit, your piogrem Is too big for Janus/Ada to hai^ In one 
piere. Coiulder using the Janus/Ada cliaining library (CHAINUB) 
to break up your program into separate passes (CHAII^B is not 
provided with all Janus/Ada packages). 

Too many deletloris (or /T option 

Your program tequtres the fX option to remove loo many ptoce* 
duns. R^uce your use of unneaded procedures, compile some of 
your uidis wititoui the /T compiler option, or do not use the /T op' 
tton. 

Too many externola foi /T option 

Your program has so many external references that the Janua/Ada 
linker cannot keep track of all of them for the puiposM of the trim¬ 
ming done by the fX option. Reduce the number of such references 
(possibly by suppressing checks), compile some of your units 
without the fX compiler option, or do not use the /T option. 

Too many geiterlc check records 

Your program has more direct and Indirect genetic Instandatlons 
- than Janui/Ada can harxite; too much memory would be needed 
to check that the instantiations are all legal. Reduce your usage of 
generics. 

Too many relocations (or fX option 

The program unit being loaded has so many relocations that the . 
Janus/Ada linker cannot keep (rack of all of them for the purposes 
of the himming done by the fX option. Reduce the numbttf of 
relocatlota by ccmpiiing the offending unit with the optimizer on, 
compilit^g the unit wiihoul iite /T compiler option, or do not use the 
/T option. 

Too much Code for one .JRL File 

The maximum anioun! cl code (Including constants) In one JRL 
file or SKL file !s 32000 t^es Hie JRL file or SRL file is probably 
damaged. Recompile ihu indicated unit and (If It is a spedHcatlon) 
any units tiiat depend on It 




IUvition4.6 





JItnk Manual 


«'an apeciffod 


CopyriBh|]989.|{H ;k»(v..«„. j„. 


IJNK 16 






APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed inoplementation dependencies correspond to 
iiqplementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The inplementation-dependent 
characteristics of this Ada inf>lementation, as described in this i^pendix, 
.are provided by the customer, unless specifically noted otherwise, 
references in this Appendix are to ccmpiler documentation and not to this 
report. I]if>lementation-specific portions of the package STANDARD, -vdiich 
are not a part of ^spendix F, are: 


package STANDARD is 

type INTEGER is range -32768 .. 32767; 

type LONG^INTEGER is range -21474838648 .. 2147483647; 

type FLOAT is digits 6 range -((2.0 ** 128) - (2.0 ** 104)) .. 

((2.0 ** 128) - (2.0 ** 104); 

type LONG FLOAT is digits 15 range -((2.0 ** 1024) - (2.0 ** 971)) 

((2.0 ** 1024) - (2.0 ** 971)) 

t^ DURATION is delta 0.00025 range -((2.0 ** 31) - l)/4096.0 .. 

((2.0 ** 31) - l)/4096.0; 


end STMCARD; 


C-1 








Appendix F: Implementation Dependencies 


F awa ntation Dependeneiaa 

This appendix specifies certain system-dependant characteristics 
of the Janus/Ada version 2.2.d 386 to DOS compiler. 

F.l Ii^)leBentatio]i Dependent Pragnas 

In addition to the required Ada pragmas, Janus/Ada also provides 
several others. Some of these pragmas have a textual range . 

Such pragmas set some value of importance to the compiler, 
usually a flag that may be On or Off. The value to be used by 
the compiler at a given point in a program depends on the 
parameter of the most recent relevant pragma in the text of the 
program. For flags, if the parameter is the identifier On, then 
the flag is on; if the parameter is the identifier Off, then the 
flag is off; if no such pragma has occurred, then a default value 
is used. 

The range of a pragma - even a pragma that usually has a textual 
range - may vary if the pragma is not inside a compilation unit. 
This matters only if you put multiple compilation units in a 
file. The following rules apply: 

1) If a pragma is inside a compilation unit, it 
affects only that unit. 

2) If a pragma is outside a compilation unit, it 
affects all following.compilation units in the 
compilation. 

Certain required Ada pragmas, such as INLINE, would follow 
different rules; however, as it turns out, Janus/Ada ignores all 
pragmas that would follow different rules. 

The following system-dependent pragmas are defined by Janus/Ada. 
Unless otherwise stated, they may occur anywhere that a pragma 
may occur. 

ALL__CHECKS Takes one of two identifiers On or Off as its 
argument, and has a textual range. If the 
argument is Off, then this pragma causes 
suppression of arithmetic checking (like pragma 
ARITHCHECK - see below), range checking (like 
pragma RANGECHECK - see below), storage error 
checking, and elaboration checking. If the 
argument is On, then these checks are all 
performed as usual. Note that pragma ALL_CHECKS 
does not affect the status of the DEBUG pragma; 
for the fastest run time code (and the worst run 
time checking), both ALL_CHECKS and DEBUG should 

F-1 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 



Appendix ft Inplementation Dependencies 


ARITHCHECK 


CLEANUP 


be turned Off and the pragma OPTIMIZE (Time) 
should be used. Note also that ALL_CHECKS does 
not affect the status of the ENUMTAB pragma. 
Combining check suppression using the pragma 
ALL_CHECKS and using the pragma SUPPRESS may cause 
unexpected results; it should not be done. 

However, ALL_CHECKS may be combined with the 
Janus/Ada pragmas ARITHCHECK and RANGECHECK; 
whichever relevant pragma has occurred most 
recently will determine whether a given check is 
performed. ALL_CHECKS is on by default. Turning 
any checks off may cause unpredictable results if 
execution would have caused the corresponding 
assumption to be violated. Checks should be off 
only in fully debugged and tested programs. After 
checks are turned off, full testing should again 
be .done, since any program that handles an 
exception may expect results that will not occur 
if no checking is done. 

Takes one of the two identifiers On or Off as its 
argument, and has a textual range. Where 
ARITHCHECK is on, the compiler is permitted to 
(and generally does) not generate checks for 
situations where it is permitted to raise 
NUMERIC^ERROR; these checks include overflow 
checking and checking for division by zero. 
Combining check suppression using the pragma 
ARITHCHECK and using the pragma SUPPRESS may cause 
unexpected results; it should not be done. 

However, ARITHCHECK may be combined with the 
Janus/Ada pragma ALL_CHECKS; whichever pragma has 
occurred most recently will be effective. 
ARITHCHECK is on by default. Turning any checks 
off may cause unpredictable results if execution 
would have caused the corresponding assumption to 
be violated. Checks should be off only in fully 
debugged and tested programs. After checks are 
turned off, full testing should again be done, 
since any program that handles an exception may 
expect results that will not occur if no checking 
is done. 

Takes an integer literal in the range 0 .. 3 as 
its argument, and has a textual range. Using this 
pragma allows -he Janus/Ada run-time system to be 
less than meticulous about recovering temporary 
memory space it uses.. This pragma can allow for 
smaller and fas-cer code, but can be dangerous; 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 






Appendix fz Inplenentetion Dependencies 


DEBUG 


ENUMTAB 


certain constructs can cause nenox^ to be used up 
very quickly. The smaller the parameter, the more 
danger is permitted. A value of 3 - the default 
value -causes the run-time system to be its usual 
immaculate self. A value of 0 causes no 
reclamation of temporary space. Values of 1 and 2 
allow compromising between "cleanliness” and 
speed. Using values other than 3 adds some risk 
of your program running out of memory, especially 
in loops which contain certain constructs. 

Takes one of the two identifiers On or Off as its 
argument, and has a textual range. This pragma 
controls the generation of line number code and 
procedure name code. When DEBUG is on, such code- 
is generated. When DEBUG is off, no line number 
code or procedure names are generated. This 
information is used by the walkback which is 
generated after a run-time error (e.g., an 
unhandled exception). The walkback is still 
generated when DEBUG is off, but the line numbers 
will be incorrect, and no subprogram names will be 
printed. DEBUG*s initial state can be set by the 
command line; if no explicit option is given, then 
DEBUG is initially on. Turning DEBUG off saves 
space, but causes the loss of much of Janus/Ada's 
power in describing run time errors. 

Notes: 

DEBUG should only be turned off when the program 
has no errors. The information provided on an 
error when DEBUG is off is not very useful. 

If DEBUG is on at the beginning of a subprogram or 
package specification, then it must be on at the 
end of the specification. Conversely, if DEBUG is 
off at the beginning of such a specification, it 
must be off at the end. If you want DEBUG to be 
off for an entire compilation, then you can either 
put a DEBUG pragma in the context clause of the 
compilation or you can use the appropriate 
compiler option. 

Takes one of the two identifiers On or Off as its 
argument, and has a textual range. This pragma 
controls the generation of enumeration tables. 
Enumeration tables are used for the attributes 
IMAGE, VALUE, and WIDTH, and hence to input and 
output enumeration values. The tables are 


F-3 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Apptndix F: Inplenentation Oependenciat 


OPTIMIZER 


generated when EMUMTAB is on. The state of the 
ENU^AB flag is significant only at enumeration 
type definitions. If this pragma is used to 
prevent.generation of a type's enumeration tedsles, 
then using the three mentioned attributes'causes 
an erroneous program, with unpredictable results; 
furthermore, the type should not be used as a 
generic actual discrete type, and in particular 
TEXT_IO.ENUMERATION_IO should not be instantiated 
for the type. If the enumeration type is not 
needed for any of these purposes, the tables, 
which use a lot of space, are unnecessary. 

ENUMTAB is on by default. 

Takes one of the identifiers On or Off, or an 
integer literal, as an argument. This pragma 
turns optimization on or off, either totally or 
partially. It has a textual range, except that if 
the global optimizer is turned on for any part of 
a compilation unit, then it is on for the entire 
compilation unit. If the identifier is On or Off, 
then Janus/Ada's optimizers are turned totally on 
or totally off, as appropriate. An integer 
literal as an arguement causes optimization to be 
turned partially on or off. 

The following integer literals are meaningful as 
an argument to this pragma: 

1) Turns check elimination optimizations on. 

2) Turns the basic block optimizer on. 

3) Turns the global optimizer on. If this is on 
anywhere in a compilation unit, it will be on 
everywhere in that unit. 

4) Turns peephole optimizations on. 

5) Puts the optimizer in 'Space' optimization 
mode (the default). 

6) Puts the optimizer in 'Careful' optimization 
mode. The can take much longer than 'Quick' 
optimization, but will find more 
optimizations. 

7) Puts the compiler in 'Fastest alignment' 
mode. Data objects will be aligned for the 
fastest performance on the target (unless 
overridden by rep. clauses). This takes more 
data space. 

51) Turns checi: elimination optimizations off. 
Useful for finding uninitialized variables. 

52) Turns the basic block optimizer off. 


r*4 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Afspendix f: Inplantntation Dependencies 


PAGE LENGTH 


RANGECHECK 


53) Turns the global optimizer off. 

54) Turns peephole optimizations off. 

55) Puts the optimizer in ’Time' optimization 
mode. 

56) Puts the optimizer in 'Quick' optimization 
mode. This is faster than 'Careful' 
optimizations, and often will generate nearly 
the same code. 

57) Put the compiler in 'Smallest alignment' 
mode. Data is only aligned- when required or 
when the performance penalty is-severe. 

Takes less data space. 

Other integer literals will be ignored. In 
general, this pragma should not be mixed with the 
OPTIMIZE pragma, since one has a textual arange 
and the other does not; this can lead to 
surprising situations. However, the OPTIMIZE 
pragma may.be used inside a compilation unit for 
which pragma OPTIMIZER(bn) has been listed before 
the start of the compilation unit. 

This pragma takes a single integer literal as its 
argument. It says that a page break should be 
added to the listing after each occurrence of the 
given number of lines. The default page length is 
32000, so that no page breaks are generated for 
most programs. Each page starts with a header 
that looks like the following: 

Janus/Ada Version 2.2.0 compiling file on 
date at time 

Takes one of the two identifiers On or Off as its 
argument, and has a textual range. Where 
RANGECHECK is off, the compiler is permitted to 
(and generally does) not generate checks for 
situations where it is expected to raise 
CONSTRAINT_ERROR; these checks include null 
pointer checking, discriminant checking, index 
checking, array length checking, and range 
checking. Combining check suppression using the 
pragma RANGECHECK and using the pragma SUPPRESS 
may cause unexpected results; it should not be 
done. However, RANGECHECK may be combined with 
the Janus/Ada pragma ALL_CHECKS; whichever pragma 
has occurred most recently will be effective. 
RANGECHECK is on by default. ■ Turning any checks 
off may cause unpredictable results if execution 


F-5 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Appendix F: Inplementation Dependencies 


would have caused the corresponding assumption to 
be violated. Checks should be off only in fully 
debugged and tested programs. After checks are 
turned off, full testing should again be done, 
since any program that handles an exception may 
expect results that will not occur if no checking 
is done. 

SYSLIB This pragma tells the compiler that the current 

unit is one of the standard Janus/Ada system 
libraries. It takes as a parameter an integer 
literal in the range 1 .. 15; only the values 1 
through 4 are currently used. For example, system 
library number 2 provides floating point support. 
Do not use this pragma unless you are writing a 
package to replace one of the standard Janus/Ada 
system libraries. 

VERBOSE Takes On or Off as its argument, and has a textual 

range. VERBOSE controls the amount of output on 
an error. If VERBOSE is on, the two lines 
preceding the error are printed, with an arrow 
pointing at the error. If VERBOSE is off, only 
the line number is printed. 

VERBOSE(Off): 

Line 16 at Position 5 

♦ERROR* Identifier is not defined 

VERBOSE(On): 

15; if X = 10 then 
16: Z ;= 10; 

♦ERROR* Identifier is not defined 

The reason for this option is that an error 
message with VERBOSE on can take a long time to be 
generated, especially in a large program. 

VERBOSE'S initial condition can be set by the 
compiler command line. 

Pragma INTERFACE is supported for the language MASM. Pragma 
INTERFACE^NAME can be used to specify a name other than the Ada 
one as the name of the MASM function called. INTERFACE_NAME 
takes two parameters, the Ada subprogram name, and a string 
representing the MASM name for the function. Pragma 
INTERFACE_NAME is provided so that convienient Ada names can be 

F-6 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 






Appendix F: Inplementation Dependencies 


used as appropriate, including operator symbols, and so that 
foreign language names which are not legal Ada identifiers can be 
interfaced to. If pragma- INTERFACE is used in a- program, 

Jbind must be used to link it, and it must be linked with the 
Interface run-time. 

Several required Ada pragmas may have surprising effects in 
Janus/Ada. The PRIORITY pragma may only take the value 0, since 
that is the only value in the range System.Priority. Specifying 
any OPTIMIZE pragma turns on optimization; otherwise, 
optimization is only done if specified on the compiler's command 
line. The SUPPRESS pragma is ignored unless it only has one 
parameter. Also, the following pragmas are always ignored: 
CONTROLLED, INLINE, MEMORY_SIZE, SHARED, STORAGE_UNIT, and 
SYSTEM__NAME. Pragma CONTROLLED is always ignored because 
Janus/Ada does no automatic garbage collection; thus, the effect 
of pragma CONTROLLED already applies to all access types. Pragma 
SHARED is similarly ignored: Janus/Ada's non-preemptive task 
scheduling gives the appropriate effect to all variables. The 
pragmas INLINE and.SUPPRESS (with two parameters) provide 
recommendations to the compiler; as Ada allows, the 
recommendations are ignored. The pragmas MEMORY SIZE, 
STORAGE_UNIT, and SYSTEM_NAME all attempt to make changes to 
constants in the System package; in each case, Janus/Ada allows 
only one value, so that the pragma is ignored. 

F.2 I^pleaeiitatioii Dependant Attributes 

Janus/Ada does not provide any attributes other than the required 
Ada attributes. 

F.3 Specification of the Package SYSCTM 

The package System for Janus/Ada has the following definition. 

package System is 

— System package for Janus/Ada 

— Types to define type Address, 
type Word is range 0 .. 65536; 
for Word'Size use 16; 
type Offset Type is new Word; 
type Address is record 

Offset : Offset__Type; 

Segment : Word;” 
end record; 

Function "+" (Left : Address; Right : Offset_Type) Return 

Address; 


F-7 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Appendix F: Inplenentation Dependencies 


Function ”+'• 
Function 
Function 
typ* Name is 
System_Name : 


(Left I Offset__Type; Right ; Address) Return 
Address; 

(Left : Address; Right : Offset_Type} Return 
Address; 

(Left, Right ; Address) Return Offset__Type; 
(MS_DOS2); 

constant Name MS D0S2; 


Storage_Unit ; constant :« 8; 

Memory_Size : constant 65536; 

— Note; The actual memory size of a program is 
—• determined dynamically; this is the maximum 
— number of bytes in the data segment. 


—• System Dependent Named Numbers: 

Min_Int ; constant :« -2__147_483_648; 

Max_Int : constant :« 2_147__483__647; 

Max__Digits : constant :« 15; "* 

Max^Mantissa : constant :« 31; 

Fine Delta : constant :» 2#1.0#E->31; 

equivalently, 4.656612873077392578125E-10 
Tick : constant :» O.Ol; Some machines have less 

— accuracy; for example, the IBM PC actually ticks 
~ about every 0.06 seconds. 

Other System Dependent Declarations 
subtype Priority is Integer range 0 .. 0; 

type Byte is range 0 .. 255; 
for Byte'Size use 8; 


end System; 

The type Byte in the System package corresponds to the 8-bit 
machine byte. The type Word is a 16-bit Unsigned Integer type, 
corresponding to a machine word. 

F.4 Restrictions on Representation Clauses 

A length clause that specifies T'SIZE has the following 
restrictions: 


If T is a discrete type, or a fixed point type, then the 
size expression can given any value between 1 and 32 bits 
(subject, of course, to allowing enough bits for every 
possible value). Signed and unsigned representations are 
supported. 


F-8 


Copyright 1990, R.R. Software, Inc. 


Revision 4,6 



Appendix F: Inplementation Dependencies 


If T is a floating point type, sizes of 32 and 64 bits are 
supported (corresponding to Float and Long_Float 
respectively). 

If T is an array or record type, the expression must give 
enough room to represent all of the components of the type 
in their object representation. This can be smaller than 
the default size of the type. 

If T is an access type or task type, the expression must 
give the default size for T. 

A length clause that specifies T*STORAGE_SIZE for an access type 
is supported. 

Any integer value can be specified. STORAGE_ERROR will be raised 
if the value is larger than available memory; no space will be 
allpcated if the value is less than or equal to zero. 

A length clause that specifies T‘STORAGE'SIZE for a task type T 
is supported. Any integer value can be specified. Values 
smaller than 256 will be rounded up to 256 (the minimum 
T'Storage_Size), as the Ada standard does not allow raising an 
exception in this case. 

A length clause that specifies T*SMALL for a fixed point type 
must give a value (subject to the Ada restrictions) in the range 

2.0 ** (-99) .. 2.0 ** 99, 

inclusive. 

An enumeration representation clause for a type T may give any 
integer values within the range System.Min_^Int .. System.Max_Int. 
If a size length clause is not given for the type, the type's 
size is determined from the literals given. (If all of the 
literals fit in a byte, then Byte'Size is used; similarly for 
Integer and Long_Integer). 

The expression in an alignment clause in a record representation 
clause must equal 1 or 2 (to specify Byte or Word alignment 
respectively). The alignment value is respected for all object 
creations unless another representation clause explicitly 
overrides it. (By placing a component at a non-aligned address, 
for example). 

A component clause may give any desired storage location. The 
size of the record is adjusted upward if no representation clause 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 



Appendix F: Inplenentation Dependencies 


has been given, and more space is needed for the specified 
storage location to be obeyed. 

The range for specifying the bits may specify any values within 
the following limitations (assuming enough bits are allowed for 
any value of the subtype): 

If the component type is a discrete or fixed point type, any 
value may be specified for the lower bound. The upper bound 
must satisfy the equation 

UB - (LB - (LB Mod System.STORAGE_UNIT_SIZE)) <= 32. 

If the component type is any other type, the lower bound 
must satisfy 

LB Mod System.STORAGE_UNIT_SIZE » 0. 

The upper bound must be 

U£5 :* LB + T'Size - 1; 

Janus/Ada supports <;ddress clausei: on Most objects. Address 
clauses are not allowed on parameters, generic formal parameters, 
and renamed objects. The address »jiven for an object address 
clause may be any leg^^l value of type System.Address. It will be 
interpr<»ted as an £\bsolute machine address, using the segment 
part as a sselector if in the protected mode. It is the user's 
responsibility to ensure that the value given makes sense (i.e., 
points at memo:,*y, does not overlay other objects, etc.) No other 
address clauses are supported. 

F.5 I^lemeatation Defined Hanes 

Janus/Ada uses no imolementation generated names. 

F.6 Address Clause Expressions 

The address given for an object address clause may be any.legal 
value of type System.Address. It will be interpreted as an 
absolute machine address, using the segment part as a selector if 
in the protected mode. It is the user's responsibility to ensure 
that the value given makes sense (i.e., points at memory, does 
not overlay other objects, etc.) 

F.7 v7Bchecke(S_Cony«Tsion Restrictions 

We first make the following definitions; 


F-10 


Copyright 1990, R.i?. Softhsre, Inc. 


Revision 4.6 


Appendix F: Implementation Dependencies 


A type or subtype is said to be a simple type or a simple subtype 
(respectively) if it is a scalar (sub) type, an access (sid3)type, 
a task (sub)type, or if it satisfies the following two 
conditions: 

1) If it is an array type or subtype, then it is 
constrained and its index constraint is static; and 

2) If it is a composite tj^e or subtype, then all of its 
subcomponents have a simple subtype. 

A (sub)type which does not meet these conditions is called non- 
simple . Discriminated records can be simple; variant records can 
be simple. However, constraints which depend on discriminants 
are non-simple (because they are non-static). 

Janus/Ada imposes the following restriction on instantiations of 
Unchecked__Conversion: for such an instantiation to be legal, both 
the source actual subtype and the target actual subtype must be 
simple subtypes, and they must have the same size. 

F.8 laqplementatlon Dependencies of I/O 

The syntax of an external file name depends on the operating 
system being used. Some external files do not really specify 
disk files; these are called devices . Devices are specified by 
special file names, and are treated specially by some of the I/O 
routines. 

The syntax of an MS-DOS 2.xx or ^.xx filename is; 

[d:][path]filename[.ext] 

where ”d;” is an optional disk name; "path” is an optional 
path consisting of directory names, each followed by a 
backslash; "filename" is the filename (maximum 8 
characters); and ".ext" is the extension (or file type). 

See your MS-DOS manual for a complete description. In 
addition, the following special device names are recognized 

STI; MS-DOS standard input. The same as Standard__Input. 

Input is buffered by lines, and all MS-DOS line editing 
characters may be used. Can only be read. 

STO: MS-DOS standard output. The same as Standard_Output. 
Can only be written. 

ERR: MS-DOS standard error. The output to this device 
cannot be redirected. Can only be written. 

CON: The console device. Single character input with 

echoing. Due to the design of MS-DOS, this device can 
be redirected. Can be read and.written. 

■ F-n 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 



Appendix F: Inplenentation Dependencies 

AUX: The auxiliary device. Can be read or written. 

LST: The list (printer) device. Can only be written. 

KBD: The console input device. No character interpretation 
is performed, and there is no character echo. Again, 
the input to this device can be redirected, so it does 
not always refer to the physical keyboard. 

The MS-DOS device files may also be used (CON, AUX, and PKN 
without colons For compatibility reasons, we do not 

recommend the use of these names. 

The MS-DOS 2.xx version of the I/O system will do a search 
of the default search path (set by the DOS PATH command) if 
the following conditions are met: 

1) No disk name or path is present in the file name; 
and 

2) The name is not that of a device. 

Alternatively, you may think of the search being done if the 
file name does not contain any of the characters '/'» 

or 

The default search path cannot be changed while the program 
is running, as the path is copied by the Janus/Ada program 
when it starts running. 

Note: 

Creates will never cause a path search as they must work in 
the current directory. 

Upon normal completion of a program, any open external files are ■ 
closed. Nevertheless, to provide portability, we recommend 
explicitly closing any files that are used. 

Sharing external files between multiple file objects causes the 
corresponding external file to be opened multiple times by the 
operating system. The effects of this are defined by your 
operating system. This external file sharing is only allowed if 
all internal files associated with a single external file are 
opened only for reading (mode In_File), and no internal file is 
Created. Use_Error is raised if these requirements are violated. 
A Reset to a writing mode of a file already opened for reading 
also raise Use_Error if the external file also is shared by 
another internal file. 

Binary I/O of values of access types will give meaningless 
results and should not be done. Binary I/O of types which are 

F-12 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Appefxiix F: Implanentation Dependencies 


not simple types (see definition in Section F.7, above) will 
raise Use__Error when the file is opened. Such types require 
specification of the block size in the form, a capability which 
is not yet suppozrted. 

The form parameter for Sequential_IO and Direct_IO is always 
expected to be the null string. 

The type Count in the generic package Direct_IO is defined to 
have the range 0 .. 2_147_483_647. 

Ada specifies the existence of special markers called terminators 
in a text file. Janus/Ada defines the line terminator to be <LF> 
(line feed ), with or without an additional <CR> (carriage 
return). The page terminator is the <FF> (form feed) character; 
if it is not preceded by a <LF>, a line terminator is also 
assximed. 

The file terminator is the end-of-file returned by the host 
operating system. If no line and/or page terminator directly 
precedes the file terminator, they are assumed. If the form ”Z" 
is used, the <Ctrl>-Z character also represents the end-of-file. 
This form is not necessary to correctly read files produced with 
Janus/Ada and most other programs, but may be occasionally 
necessary. The only legal forms for text files are (the null 
string) and ”Z”. All other forms raise USE_ERROR. 

If the form is the <Ctrl>-Z character is ignored on input. 

The <CR> character is always ignored on input, (They will not be 
returned by Get, for instance). All other control characters are 
sent directly to the user. Output of control characters does not 
affect the layout that Text_IO generates. In particular, output 
of a <LF> before a' New_Page does not suppress the New^Line caused 
by the New_Page. 

On output, the ”Z” form causes the end-of-file to be marked by a 
<Ctrl>-Z; otherwise, no explicit end-of-file character is used. 
The character pair <CR> <LF> is written to represent the line 
terminator. Because <CR> is ignored on input, this is compatible 
with input. 

The type Text_IO.Count has the range 0 .. 32767; the type 
Text_IO.Field also has the range 0 .. 32767. 

IO_Exceptions.USE_ERROR is raised if something cannot be done 
because of the external file system; such situations arise when 
one attempts; 


r-13 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Apptndix F: InplMentation Dependencies 


- to create or open an external file for writing when the 
external file is already open (via a different internal 
file). 

> to create or open an external file when the external 
file is already open for writing (via a different 
internal file). 

- to reset a file to a writing mode when the external 
file is already open (via a different internal file). 

- to write to a full disk (Write, Close); 

- to create a file in a full directory (Create); 
to have more files open than the OS allows (Open, 
Create); 

• to open a device with an illegal mode; 

- to create, reset, or delete a device; 

- to create a file where a protected file (i.e., a 
directory or read-only file) already exists; 

- to delete a protected file; 

- to use an Illegal form (Open, Create); or 

- to open a file for a non-simple type without specifying 
the block size; 

to open a device for direct I/O. 

IO_Exceptions.DEVICE_ERROR is raised if a hardware error other 
than those covered by USE_ERROR occurs. These situations should 
never occur, but may on rare occasions. For example, 

DEVICE^ERROR is raised when: 

- a file is not found in a Close or a Delete; 

- a seek error occurs on a direct Read or Write; or 

- a seek error occurs on a sequential End_Of_File. 

The subtypes Standard.Positive and Standard.Natural, used by some 
I/O routines, have'the maximum value 32767. 

No package Low_Level_IO is provided. 

7.9 Sonaing the compiler and linker 

The Janus/Ada compiler is invoked using the following format; 

JANUS [path] filename [.ext] {/option} 

where filename is an MS/DOS file name with optional path [path] 
(here path includes disk names), optional extension [.ext], and 
compiler options {/option). If no path is specified, the current 
disk and path is assumed. If no extension is specified, .PKG is 
..assumed. 

The compiler Options are: 

F-14 


Copyright 19M, R.'R. Software, Inc. 


Revision 4.6 


Appendix F: Implenwntation Dependencies 


B Brief error messages. The line in error is not printed 

(equivalent to turning off pragma VERBOSE). 

BS Brief statistics. Few compiler statistics are printed. 

D Don't generate debugging code (equivalent to turning 

off pragma DEBUG) 

F Use in-line 8087 instructions for Floating point 

operations. By default the compiler generates library 
calls for floating point operations. The 8087 may be 
used to execute the library calls. A floating point 
support library is still required, even though this 
option is used. 

L Create a listing file with name filename.PRN on the 

same disk as filename. The listing file will be a 
listing of only the last compilation unit in a file. 

Lpath Create a listing file on specified path 'path'. 

Ox Object code memory model. X is 0 or 1. Memory model 0 

creates faster, smaller code, but limits all code in 
all units of a program to one MS-DOS segment (i.e,, 64 
kilobytes); Memory model 1 allows code size limited 
only by your machine and operating system. See the 
linker (JLINX) manual for more information. Memory 
model 0 is assumed if this option is not given. The 
compiler records the memory model for which each 
library unit was compiled, and it will complain if any 
mismatches occur. Thus, the compiler enforces that if 
it is run using the /ol option, then all of the withed 
units must have been compiled with the same option. 

Q Quiet error messages. This option causes the compiler 

not to wait for the user to interact after an error. 

In the usual mode, the compiler will prompt the user 
after each error to ask if the compilation should be 
aborted. This option is useful if the user wants to 
take a coffee break while the compiler is working, 
since all user prompts are suppressed. The errors (if 
any) will not stay on the screen when this option is 
used; therefore, the console traffic should be sent to 
the printer or to a file. Be warned that certain 
syntax errors can cause the compiler to print many 
error messages for each and every line in the program. 

A lot of paper could be used this way! Note that the /Q 



Copyright 1990, R.R, Software, Inc. 


Revision A.6 



Appendix F: Iigplementation Dependencies 

option disallows disk swapping, even if the /S option 
is given. 

Rpath Route the SYM, SRL, and JRL files produced by the 

conpiler to the specified path 'path'. The default is 
the sane path as filename. 

Spath Route Scratch files to specified path. This option is 
useful if you have a RAM disk or if your disk does not 
have much free space. The use of this option also 
allows disk swapping to load package specification 
(.SYM) files. Normally, after both the compiler and 
source file disks are searched for .SYM files, an error 
is produced if they are not all found. However, when 
the /S option is used, the compiler disk may be removed 
and replaced by a disk to search. The linker has a 
similar option, which allows the development of large 
programs on systems with a small disk capacity. Note 
that disk swapping is not enabled by the /S option if ■ 
the /Q (quiet option) is also given. The /Q option is 
intended for batch mode compiles, and its purpose 
conflicts with the disk swapping. The main problem is 
that when the /S option is used to put scratch files on 
a RAM disk, a batch file may stop waiting for a missing 
.SYM or ERROR.MSG file; such behavior would not be 
appropriate when /Q is specified. 

T Generate information which allows trimming unused 

subprograms from the code. This option tells the 
compiler to generate information which can be used by 
the remove subprograms from the final code. This 
option increases the size of the .JRL files produced. 

We recommend that it be used on reusable libraries of 
code (like trig, libraries or stack packages) - that 
is those compilations for which it is likely that some 
subprograms are not called. 

W Don't print any warning messages. For more control of 

warning messages, use the, following option form (Wx). 

Wx Print only warnings of level less than the specified 

digit 'x'. The given value of x may be from 1 to 9. 

The more warnings you are willing to see, the higher 
the number you should give. 

X Handle extra symbol table information. This option is 

for the use of the JScope debugger and other tools. 

This option requires large quantities of memory and 
disk space, and thus should be avoided if possible. 

F-16 


Copyright 1990, R.R. Softwore, Inc. 


Revision 4.6 


Appendix F: liplanentation Dependencies 


Z Turn on optimization. This has the same effect as if 

the pragma OPTIMIZE were set to SPACE throughout your 
compilationi 

The default values for the command line options are: 

B Error messages are verbose. 

BS Statistics are verbose. 

D Debug code is generated. 

F Library calls are generated for floating point operations. 

L No listing file is generated. 

0 Memory model 0 is used. 

Q The compiler prompts for abort after every error. 

R The SYM, SRL, and JRL files is put on the same path as the 
input file. 

S Scratch files are put in the current directory. 

T No trimming code is produced. 

W All warnings are printed. 

X Extra symbol table Information is not generated. 

Z Optimization is done only where so specified by pragmas. 

Leading spaces are disregarded between the filename and the call 
to JANUS. Spaces are otherwise not recommended on the command 
line. The presence of blanks to separate the options or between 
the filename and the extension will, be ignored. 

Examples: 

JANUS test/Q/L 
JANUS test.run/W4 
JANUS test 

JANUS test .run /B /W/L 

The compiler produces a SYM (SYMbol table information) file when 
a specification is compiled, and a SRL or JRL (Specification 
ReLocatable or Janus Relocatable) file when a body is compiled. 
To make an executable program, the appropriate SRL and JRL files 
must be linked (combined) with the run-time libraries. This is 
accomplished by running the Janus/Ada linker, JLINK. 

The Janus/Ada linker is invoked using the following format: 

JLINK [path] filename (/option) 

Here "filename" is the name of the SRL or JRL file created when 
the main program was compiled (without the .SRL or .JRL 
extension) with optional path name [path] (again, the disk name 
is consider part of the path here), and compiler options 
(/option). The filename usually corresponds to the first eight 

F-17 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


Appendix F: Inplementation Dependencies 


letters of the name of your main program. A path may be 
specified where the files are to be found. See the linker manual 
for more detailed directions. We summarize here, however, a few 
of the most commonly used linking options: 

E Create an EXE file. This is assumed if the /01 option is 
given. This, allows allow a slightly larger total program 
size if memory model is used. 

FO Use software floating point (the default). 

F2 Use hardware (8087) floating point. 

L Display lots of information about the loading process. 

00 Use memory model 0 (the default); see the description of the 
/O option in the compiler, above. 

01 Use memory model 1. 

Q Use quiet error messages; i.e., don't wait for the user to 
interact after an error. 

B Use brief statistics. 

T Trim unused subprograms from the code. This option tells 

the linker to remove subprograms which are never called from 
the final output file. This option reduces space usage of 
the final file by as much as 3OK. 

Examples: 

JLINK test 
JLINK test /Q/L 
JLINK test/01/L/F2 

Note that if you do not have a hardware floating point chip, and 
if you are using memo^ model 0, then you generally will not need 
to use any linker options. 


F-18 


Copyright 1990, R.R. Software, Inc. 


Revision 4.6 


