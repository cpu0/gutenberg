UNCLASSIFIED _ , 

SECURI T r CLASSIFICATION Of THIS PAGE (When Pete entered) 

I REPORT DOCUMENTATION PAGE 


AD-A219 438 





4. TITLE (snctStjbt’tit) 

Ada Compiler Validation Summary Report iLoral/Roi 
iil-Spec Computers ADE, Revision 3.01, MV ltlOOO (Host; to 

3SWK/32 (Target), 890804S1.10142 


7. authored 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 


•. PERFORMING ORGANIZATION ANO ADDRESS 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 


11. CONTROLLING OFf ice NAME and aooress 
Ada Joint Program Office 
United States Department of Defense 
Washington, DC 2&301-3081 


14. MONITORING AGENCY NAME A ADDRESSEEfrom Controlling OH,it) 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 


16. DISTRIBUTION STATEMENT (of this Bepon) 


■troKt coy?.tTt>' J mj*v I 


3. RECIPIENT'S CATALOG NUMBER 


5. TYPE Of REPORT l PERIOD COVERED 

04 Aug. 1989 to 01 Dec. 199C 


B. PERFORMINGtRG. REPORT NUMBER 


t. CONTRACT OR GRANT NUMBERED 


10. PROGRAM element. PROJECT. TASa 
AREA t NORA UNIT NUMBERS 


1Z. REPORT DATE 


15. SECURITY CLASS (ofthu report) 

UNCLASSIFIED 


15i. ^C^aS^FICATION-DOmNGRADING 

N/A 


Approved for public release; distribution unlimited. 


17. DISTRIBUTION STATEMENT (of the ebstred entered m Block 20 If different from Repon) 


UNCLASSIFIED 


18. Supplementary notes 


DTIC 

£* .ECTE 



19 . IEynORDS (Continue o n reverse S'df if necessery end identify by block number) 

Ada Programming language, Ada Compiler Validation Summary Report, Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/KIL-STD- 
1815A, Ada Joint Program Office, AJPO 


70. ABSTRACT (Continue on reverse Side if necessery end identify by block number) 

Loral/Rolm Mil-Spec Computers ADE, Revision 3.01, Gaithersburg, Maryland, MV 10000 under 
AOS/VS 7.64 (Host) to HAWK/32 under ARTS/32 Revision 2.71 (Target), ACVC 1.10. 


DD ’ UK * 1473 eoition of i nov 6s is obsolete 
1 JAM 73 S/N OlOZ’Lf-014-6601 


UNCLASSIFIED _ 

SECURITY CLASSIFICATION Of this page O+nen Pete entered) 



















AVF Control Number: 

PRE-VALIDATION: 

ON-SITE: 

LAST REVISION: 

LAST REVISION: 


NIST89ROL535_2_l. 
19 JULY 1989 
04 AUGUST 1989 
14 DECEMBER 1989 
04 JANUARY 1990 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 890804S1.10142 
Loral/Rolm Mil-Spec Computers 
ADE, Revision 3.01 
MV 10000 Host and HAWK/32 Target 


Completion of On-Site Testing: 
4 August 1989 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 



a, 




10 






AVF Control Number: NIST89ROL535_2_l.10 
Ada Compiler Validation Summary Report: 

Compiler Name: ADE Revision 3.01 
Certificate Number: 890804S1.10142 

Host: MV 10000 under AOS/VS 7.64 

Target: HAWK/32 under ARTS/32 Revision 2.71 

Testing Completed 4 August 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 





Engineering Division 
National Computer Systems 
Laboratory (NCSL) 
National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Ada'validation Facility 
Mr. L. Arnold Johnson 
Manager, Software Standards 
Validation Group 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 




Ada Validation Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 
Alexandria VA 22311 




By . 

1 Di .t 

Ada Joint Program Office 


Dr. John Solomond 

1 

Director 

O'h 

Department of Defense 

A 1 

Washington DC 20301 

yw 


t . 










TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 AC VC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . . 3-8 

3.7 ADDITIONAL TESTING INFORMATION . 3-8 

3.7.1 Prevalidation.3-8 

3.7.2 Test Method.3-8 

3.7.3 Test Site.3-9 


APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 


APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
Loral/Rolm Mil-Spec Computers 





















CHAPTER 1 


INTRODUCTION 



This Validation Summary Report -(VSR f describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of testing this compiler using the Ada Compiler 
Validation Capability.^ (ACVC)9 An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. -\ The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler properly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 


1-1 







1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by GEMMA Corp under the direction 
of the AVF according to procedures established by the Ada Joint Program 
Office and administered by the Ada Validation Organization (A VO). 
On-site testing was completed 4 August 1989 at Loral/Rolm Mil-Spec 
Computers. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
Institute for Computer Sciences and Technology 
National Bureau of Standards 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


1-2 










Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 


Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 

1. Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 

1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The sec of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada An Ada Commentary contains all information relevant to 

the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 


Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 


AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 


1-3 










technical support for Ada validations to ensure 
consistent practices. 

Compiler A processor for the Ada language. In the context of 

this report, a compiler is any language processor, 
including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 

that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding 

a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 

1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 


1-4 










Co check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is , an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 


1-5 









FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 
of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CH£CK_FILE is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


1-6 










CHAPTER 2 


CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 

Compiler: ADE Revision 3.01 

ACVC Version: 1.10 

Certificate Number: 890804S1.10142 

Host Computer: 

Machine: MV 10000 

Operating System: AOS/VS 7.64 
Memory Size: 16 MBytes 

Target Computer: 

Machine: HAWK/3 2 

Operating System: ARTS/32 Revision 2.71 

Memory Size: 8 MBytes 


2-1 






2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 


a. Capacities. 

(1; The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

(3) The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 

b. Predefined types. 

(1) This implementation supports the additional predefined 
types SHORT_INTEGER (B86001V) and LONG_FLOAT (B86001U) in 
the package STANDARD. (See tests B86001T..Z (7 tests).) 

c. Based literals. 

(1) An implementation is allowed to raise NUMERIC_ERROR or 
C0NSTRAINT_ERR0R when a value exceeds SYSTEM.MAX_INT. This 
implementation raises NUMERIC_ERROR during execution. (See 
test E24201A.) 

d. Expression evaluation. 

The order in which expressions are evaluated and the time 
at which constraints are checked are not defined by the 
language. While the ACVC tests do not specifically attempt 
to determine the order of evaluation of expressions, test 
results indicate the following: 

(1) None of the default initialization expressions for record 
components are evaluated before any value is checked for 


2-2 







membership in a component's subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test J35712B.) 

(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) NUMERIC_ERROR is raised when an integer literal operand in 
a comparison or membership test is outside the range of the 
base type. (See test C45232A.) 

(5) No exception is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is not gradual. (See tests C45524A..Z (26 

tests).) 

e. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. While the A CVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 

(1) The method used for rounding to integer is round away from 
zero. (See tests C46012A..Z (26 tests).) 

(2) The method used for rounding to longest integer is round 
away from zero. (See tests C46012A..Z (26 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round away from zero. (See test 
C4A014A.) 

f. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises no exception. 
(See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST + 2 components. (See test C36202A.) 


2-3 













(3) NUMERIC_ERROR is raised when 'LENGTH is applied Co an array 

type with SYSTEM. MAX_INT + 2 components. (See test 

C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises STORAGE_ERRORI when the array objects 
are declared. (See test C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more than 
INTEGER'LAST components raises STORAGE_ERROR when the array 
objects are declared. (See test C52104Y.) 

(6) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

(7) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

g. A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises no exception. (See test E52103Y.) 

h. Discriminated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
CONSTRAINT_ERROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 

i. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised after all choices are evaluated 
when a bound in a non-null range of a non-null aggregate 


2-4 






does noc belong to an index subtype. (See test E43211B.) 


j. Pragmas. 

(1) (The pragma INLINE is supported for functions or 
procedures. (See tests LA3004A..B (2 tests), EA3004C..D (2 
tests), and CA3004E..F (2 tests).) 

k. Generics. 

(1) Generic specifications and bodies cannot be compiled in 

separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

(2) Generic subprogram declarations and bodies cannot be 
compiled in separate compilations. (See tests CA1012A and 
CA2009F.) 

(3) Generic library subprogram specifications and bodies cannot 
be compiled in separate compilations. (See test CA1012A.) 

(4) Generic non-library package bodies as subunits cannot be 
compiled in separate compilations. (See test CA2009C.) 

(5) Generic non-library subprogram bodies cannot be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic unit bodies and their subunits cannot be compiled 
in separate compilations. (See test CA3011A.) 

(7) Generic package declarations and bodies cannot be compiled 
in separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(8) Generic library package specifications and bodies cannot be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(9) Generic unit bodies and their subunits cannot be compiled 
in separate compilations. (See test CA3011A.) 

l. Input and output. 

(1) The package SEQUENTIAL_I0 cannot be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.) 

(2) The package DIRECT_IO cannot be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101H, 


2-5 







EE2401D, and EE2401G.) 


(3) Modes IN_FILE and OUT_FILE are supported for SEQUENTIAL_IO. 
(See tests CE2102D..E, CE2102N, and CE2102P.) 

(4) Modes IN_FILE, OUT_FILE, and INOUT_FILE are supported for 

DIRECT_IO. (See tests CE2102F, CE2102I..J (2 tests), 

CE2102R, CE2102T, and CE2102V.) 

(5) Modes IN_FILE and OUT_FILE are supported for text files. 
(See tests CE3102E and CE3102I..K (3 tests).) 

(6) RESET and DELETE operations are supported for 
SEQUENTIAL_10. (See tests CE2102G and CE2102X.) 

(7) RESET and DELETE operations are supported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(8) RESET and DELETE operations are supported for text files. 

(See tests CE3102F..G (2 tests), CE3104C, CE3110A, and 

CE3114A.) 

(9) Overwriting to a sequential file does not truncate the 
file. (See test CE2208B.) 

(10) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

(11) Temporary direct files are given names and deleted when 
closed. (See test CE2108C.) 

(12) Temporary text files are given names and deleted when 
closed. (See test CE3112A.) 

(13) More than one internal file can be associated with each 

external file for sequential files when writing or reading. 
(See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 

CE2111D.) 

(14) More than one internal file can be associated with each 

external file for direct files when writing or reading. 
(See tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(15) More than one internal file can be associated with each 

external file for text files when writing or reading. (See 
tests CE3111A..B (2 tests), CE31111D..E (2 tests), CE3114B 
and CE3115A.) 


2-6 





CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 
** 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 567 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. Modifications to the code, processing, 
or grading for one test was required to successfully demonstrate the 
test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

. A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

124 

1129 

1773 

15 

21 

44 

3106 

Inapplicable 

5 

9 

542 

2 

7 

2 

567 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 



3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

7 

CHAPTER 
8 9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

194 

573 

533 

245 

172 

99 

158 

331 

131 

36 

250 

90 

294 

3106 

Inapplicable 

18 

76 

147 

3 

0 

0 

8 

1 

6 

0 

2 

279 

27 

567 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

CD2A63C 

CD2A73B 

CD2A81G 

CD50110 

CE3111C 

ED7006C 


B97102E C97116A 
CD2A63D CD2A66A 
CD2A73C CD2A73D 
CD2A83G CD2A84M 
CD7105A CD7203B 
CE3301A CE3411B 
ED7006D 


BC3009B CD2A62D 
CD2A66B CD2A66C 
CD2A76A CD2A76B 
CD2A84N CD2B15C 
CD7204B CD7205C 
E28005C ED7004B 


CD2A63A CD2A63B 
CD2A66D CD2A73A 
CD2A76C CD2A76D 
CD2D11B CD5007B 
CD7205D CE2107I 
ED7005C ED7005D 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 567 
tests were inapplicable for the reasons indicated: 

The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 


3-2 










C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 4 tests are not applicable because the tests 
require a source line of characters greater than the 120 
character source line which this implementation does not 
support: 

C24113H..K ( 4 tests) 


C34006D is not applicable because use of record descriptors for 
arrays gives larger 'SIZE for array. 

C35702A and B86001T are not applicable because this 
implementation supports no predefined type SH0RT_FL0AT. 

The following 34 tests are not applicable because 'SIZE 
representation clauses for enumeration types are not supported: 


A39005B 

CD1009B 

CD1009P 

CD2A21A 

CD2A21B 

CD2A21C 

CD2A21D 

CD2A21E 

CD2A22A 

CD2A22B 

CD2A22C 

CD2A22D 

CD2A22E 

CD2A22F 

CD2A22G 

CD2A22H 

CD2A22I 

CD2A22J 

CD2A23A 

CD2A23B 

CD2A23C 

CD2A23D 

CD2A23E 

CD2A24A 

CD2A24B 

CD2A24C 

CD2A24D 

CD2A24E 

CD2A24F 

CD2A24G 

CD2A24H 

CD2A24I 

CD2A24J 

ED2A26A 


The following 14 tests 
not supported: 

are not 

applicable 

because 'STORAGE_SIZE 

A39005C 

C87B62B 

CD1009J 

CD1009R 

CD1009S 

CD1C03C 

CD2B11B 

CD2B11C 

CD2B11D 

CD2B11E 

CD2B11F 

CD2B11G 

CD2B15B 

CD2B16A 



The following 7 tests are not supported because 'SMALL 
representation clauses are not supported: 

A39005E C87B62C CD1009L CD1C03F CD2D11A 

CD2D11B CD2D13A 

The following 16 tests are not applicable because this 
implementation does not support a predefined type LONG_INTEGER: 

C45231C C45304C C45502C C45503C C45504C 

C45504F C45611C C45613C C45614C C45631C 

C45632C B52004D C55B07A B55B09C B86001W 

CD7101F 


3-3 








C45531I..P (8 tests) and C45532I..P (8 tests) are not applicable 
because the value of SYSTEM.MAX_MANTISSA is less than 11. 

C4A013B is not applicable because the evaluation of an 
expression involving 'MACHINE_RADIX applied to the most precise 
floating-point type would raise an exception; since the 
expression must be static, it is rejected at compile time. 

D4A002B and D4A004B use 64-bit integer calculations which are 
not supported by this compiler. 

B86001X, C45231D, and CD7101G are not applicable because this 
implementation does not support any predefined integer type with 
a name other than INTEGER or SHORT_INTEGER. 

B86001Y is not applicable because this implementation supports 
no predefined fixed-point type other than DURATION. 

B86001Z is not applicable because this implementation supports 
no predefined floating-point type with a name other than FLOAT 
or LONG_FLOAT. 

The following 24 tests are not applicable because 'SIZE 
representation clauses for integer types are not supported: 

C87B62A CD1009A CD1009O CD1C03A CD1C04A 
CD2A31A CD2A31B CD2A31C CD2A31D CD2A32A 
CD2A32B CD2A32C CD2A32D CD2A32E CD2A32F 
CD2A32G CD2A32H CD2A32I CD2A32J CD2A64B 
CD2A64D CD2A65B CD2A65D CD2A74B 

C96005B is not applicable because there are no values of type 
DURATION'BASE that are outside the range of DURATION. 

CA1012A, CA2009C, CA2009F, CA3011A, BC3204C, BC3204D, LA5008M 
and LA5008N are not applicable because this implementation does 
not permit compilation in separate files of generic 
specifications and bodies or of specifications and bodies of 
subunits of generic units. 

The following 16 tests are not applicable because 'SIZE 
representation clauses for floating-point types are not 
supported: 

CD1009C CD2A41A CD2A41B CD2A41C CD2A41D 
CD2A41E CD2A42A CD2A42B CD2A42C CD2A42D 
CD2A42E CD2A42F CD2A42G CD2A42H CD2A42I 
CD2A42J 

The following 31 tests are not applicable because 'SIZE 
representation clauses for fixed-point types are not supported: 


3-4 









CD1009D CD1009Q CD1C04C CD2A51A CD2A51B 
CD2A51C CD2A51D CD2A51E CD2A52A CD2A52B 
CD2A52C CD2A52D CD2A52G CD2A52H CD2A52I 
CD2A52J CD2A53A CD2A53B CD2A53C CD2A53D 
CD2A53E CD2A54A CD2A54B CD2A54C CD2A54D 
CD2A54G CD2A54H CD2A54I CD2A54J ED2A56A 
ED2A86A 

The following 21 tests are not applicable because 'SIZE 
representation clauses for array types are not supported: 

CD1009E CD1009F CD2A61A CD2A61B CD2A61C 
CD2A61D CD2A61E CD2A61F CD2A61G CD2A61H 
CD2A61I CD2A61J CD2A61K CD2A61L CD2A62A 
CD2A62B CD2A62C CD2A64A CD2A64C CD2A65A 
CD2A65C 

The following 16 tests are not applicable because 'SIZE 
representation clauses for record types are not supported: 

CD1009G CD2A71A CD2A71B CD2A71C CD2A71D 
CD2A72A CD2A72B CD2A72C CD2A72D CD2A74A 
CD2A74C CD2A74D CD2A75A CD2A75B CD2A75C 
CD2A75D 


The following 1 test 
representation clauses for 

is not applicable 
private types are not 

because 

supported 

'SIZE 

CD1009H 






The following 

representation 

supported: 

1 test 
clauses 

i s 
for 

not applicable 
limited private 

because 'SIZE 
types are not 

CD1009I 






The following 

22 tests 

are 

not applicable 

because 

'SIZE 


representation clauses for access types are not supported: 


CD2A81A 

CD2A81B 

CD2A81C 

CD2A81D 

CD2A81E 

CD2A81F 

CD2A83A 

CD2A83B 

CD2A83C 

CD2A83E 

CD2A83F 

CD2A84B 

CD2A84C 

CD2A84D 

CD2A84E 

CD2A84F 

CD2A84L 

CD2A84G 

CD2A87A 

CD2A84H 

CD2A84I 

CD2A84K 

The follow 

ing 5 tests are 

not applicable becau; 

representation clauses 

for task 

types are 

not supported 

CD2A91A 

CD2A91B 

CD2A91C 

CD2A91D 

CD2A91E 


The following 12 tests are not applicable because of 


3-5 





restrictions on the use of enumeration types for which an 
enumeration representation clause has been given: 


CD3014A CD3014B CD3014D CD3014E CD3015A 
CD3015B CD3015D CD3015E CD3015G CD3015I 
CD3015J CD3015L 

CD4031A, CD4051C, and CD4051D are not applicable because record 
representation clauses are not supported for record types with 
discriminant parts. 


The following 46 tests 

are not applicable 

because, 

for 

this 

implementation, SYSTEM. 

ADDRESS 

clauses for 

variables 

are 

not 

supported: 







CD5003B. 

.1 (8 tests) 

CD5011A 

CD5011C 

CD5011E 



CD5011G 

CD5011I 

CD5011K 

CD5011M 

CD5011Q 



CD5012A. 

.B CD5012E..F 

1 CD5012I 

. . J CD5012M 

CD5013A 



CD5013C 

CD5013E 

CD5013G 

CD5013I 

CD5013K 



CD5013M 

CD50130 

CD5013S 

CD5014A 

CD5014C 



CD5014E 

CD5014G 

CD5014I 

CD5014K 

CD5014M 



CD50140 

CD5014S..1 

: CD5014V 

CD5014X..Z 

(3 tests) 



The following 30 tests 

are not applicable 

because, 

for 

this 

implementation, SYSTEM. 

ADDRESS 

clauses for 

constants 

are 

not 

supported: 







CD5011B 

CD5011D 

CD5011F 

CD5011H 

CD5011L 



CD5011N 

CD5011R 

CD5011S 

CD5012C 

CD5012D 



CD5012G 

CD5012H 

CD5012L 

CD5013B 

CD5013D 



CD5013F 

CD5013H 

CD5013L 

CD5013N 

CD5013R 



CD5014B 

CD5014D 

CD5014F 

CD5014H 

CD5014J 



CD5014L 

CD5014N 

CD5014R 

CD5014U 

CD5014W 




AE2101C, EE2201D, and EE2201E use instantiations of package 
SEQUENTIAL_IO with unconstrained array types and record types 
with discriminants without defaults. These instantiations are 
rejected by this compiler. 

AE2101H, EE2401D, and EE2401G use instantiations of package 
DIRECT_IO with unconstrained array types and record types with 
discriminants without defaults. These instantiations are 
rejected by this compiler. 

CE2102D is inapplicable because this implementation supports 

CREATE with IN_FILE mode for SEQUENTIAL_IO. 

CE2102E is inapplicable because this implementation supports 

CREATE with OUT_FILE mode for SEQUENTIAL_IO. 

CE2102F is inapplicable because this implementation supports 

CREATE with INOUT FILE mode for DIRECT 10. 


3-6 





CE2102I is inapplicable because this implementation supports 
CREATE with IN_FILE mode for DIRECT_IO. 

CE2102J is inapplicable because this implementation supports 
CREATE with OUT_FILE mode for DIRECT_IO. 

CE2102N is inapplicable because this implementation supports 

OPEN with IN_FILE mode for SEQUENTIAL_IO. 

CE2102O is inapplicable because this implementation supports 

RESET with IN_FILE mode for SEQUENTIAL_IO. 

CE2102P is inapplicable because this implementation supports 

OPEN with OUT_FILE mode for SEQUENTIAL_IO. 

CE2102Q is inapplicable because this implementation supports 

RESET with OUT_FILE mode for SEQUENTIAL_IO. 

CE2102R is inapplicable because this implementation supports 

OPEN with INOUT_FILE mode for DIRECT_IO. 

CE2102S is inapplicable because this implementation supports 

RESET with IN0UT_F1LE mode for DIRECT_IO. 

CE2102T is inapplicable because this implementation supports 

OPEN with IN_FILE mode for DIRECT_IO. 

CE2102U is inapplicable because this implementation supports 

RESET with IN_FILE mode for DIRECT_IO. 

CE2102V is inapplicable because this implementation supports 

OPEN with OUT_FILE mode for DIRECT_IO. 

CE2102W is inapplicable because this implementation supports 

RESET with OUT_FILE mode for DIRECT_IO. 

CE3102E is inapplicable because text file CREATE with IN_FILE 
mode is supported by this implementation. 

CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

CE3102G is inapplicable because text file deletion of an 
external file is supported by this implementation. 

CE3102I is inapplicable because text file Cause text file CREATE 
with OUT_FILE mode is supported by this implementation. 

CE3102J is inapplicable because text file OPEN with IN_FILE mode 
is supported by this implementation. 


3-7 








CE3102K is inapplicable because text file OPEN with OUT_FILE 
mode is not supported by this implementation. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases 
where legitimate implementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

Modifications were required for one test CC1223A. CC1223A was modified 

according to AVO instructions to replace the expression 
"2**T'MANTISSA-1" at line 262 with "2**(T'MANTISSA-1)-1)"; the original 
expression raised an exception because 2**T' MANTISSA exceeds 
SYSTEM.MAX INT. 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for A CVC Version 1.10 
produced by the ADE Revision 3.01 compiler was submitted to the AVF by 
the applicant for review. Analysis of these results demonstrated that 
the compiler successfully passed all applicable tests, and the compiler 
exhibited the expected behavior on all inapplicable tests. 


3.7.2 Test Method 

Testing of the ADE Revision 3.01 compiler using ACVC Version 1.10 was 
conducted on-site by a validation team from the AVF. The configuration 
in which the testing was performed is described by the following 
designations of hardware and software components: 

Host computer: MV 10000 

Host operating system: AOS/VS 7.64 

Target computer: HAWK/32 

Target operating system: ARTS/32 Revison 2.71 


A tape containing all tests except for withdrawn tests and tests 
requiring unsupported floating-point precisions was taken on-site by the 
validation team for processing. 


3-8 






The contents of the tape were loaded directly onto the host computer. 
After the test files were loaded to disk, the full set of tests was 
compiled, linked, and all executable tests were run on the HAWK/32 
under ARTS/32 Revision 2.71. Results were printed from the MV 10000 
computer. 

The compiler was tested using command scripts provided by Loral/Rolm 
Mil-Spec Computers and reviewed by the validation team. See Appendix E 
for a complete listing of the available compiler options for this 
implementation. The only option invoked during this validation was: 

MAIN PROGRAM. 


Tests were compiled, linked, and executed (as appropriate) using one 
host computer, the MV 10000, and one target computer, the HAWK/32 under 
ARTS/32 Revision 2.71. Test output, compilation listings, and job logs 
were captured on tape and archived at the AVF. 


3.7.3 Test Site 

Testing was conducted at Loral/Rolm Mil-Spec Computers and was completed 
on 04 August 1989. 


3-9 












APPENDIX A 


DECLARATION OF CONFORMANCE 

Loral/Rolm Mil-Spec Computers has submitted the following 
Declaration of Conformance concerning the 

HOST: MV 10000 

TARGET: HAWK/32 under ARTS/32 Revision 2.71. 


A- 1 






Attachment 4 


DECLARATION OF CONFORMANCE 


Compiler Implementor: Loral/Rolm Mil-Spec Computers _ 

Ada Validation Facility: Institute for Computer Sci.and Techn. 
Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Configuration 


Base Compiler Name: APE 
Host Architecture - ISA: 
Target Architecture - ISA: 
Target Architecture - ISA: 


MV 10,000 
HAWK/32 
HAWK/32 


Revision: 3.01 _ 

OS&VER # AOS/VS 7.6 4 
OS&VER #: AOS/VS 7.6 4 
OS&VER #: ARTS/32 2.71 


Derived Compiler Registration 


Derived Compiler Name: APE _ 

Host Architecture - ISA: MV Family 
Target Architecture - ISA: MV Family 
Target Architecture - ISA: HAWK/32 
Target Architecture - ISA: HAWK/32 


_Revision: 3.01 _ 

OS&VER #: AOS/VS 7.6 4 
OS&VER #: AOS/VS 7.64 
OS&VER #: AOS/VS 7.64 
OS&VER #: ARTS/32 2.71 


Owner / Implementor's Declaration 

I, the undersigned, representing Rolm Mil-Spec Computers 
have implemented no deliberate e:.-tensions to the Ada Language 
Standard ANSI/MIL-STD-1815A in che compiler(s) listed in this 
declaration. I declare chat Rolm Mil-Spec Computer s is the owner 
of record of the Ada language compiler(s) listed above and, as 
such, is responsible for maintaining said compiler(s) in 
conformance to ANSI/MIL-STD-1815A. All certificates and 
registrations for Ada language corapiler(s) listed in this 
declaration shall be made only in the owner's corporate name. 


lliott - Software Product Manager 


Owners Declaration 
I, the undersigned, representing 

agree that as part of the joint Marketing Agreement between Rolm 
Mil-Spec and Data General for the Ada Development Environment, 
Data General has the responsibility to maintain the Base Compiler 
listed above. I declare that all of the Ada language compilers 
listed, and their host/target performance are in compliance with 
the Ada Language Standard ANSI/MIL-STD-1815A. 


Date 





APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation - dependent pragmas, to certain machine - dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the ADE Revision 3.01 
compiler, as described in this Appendix, are provided by Loral/Rolm Mil- 
Spec Computers. Unless specifically noted otherwise, references in this 
appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are not 
a part of Appendix F, are: 

package STANDARD is 


type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type SHORT_INTEGER is range -32768 .. 32767; 

type FLOAT is digits 6 range 

-16#0.10000000000000# * 16 **(-64) .. 16#0.FFFFF# * 16 **(63); 
type L0NG_FL0AT is digits 15 range 

-16#0.10000000000000# * 16 **(-64)..16#0.FFFFFFFFFFFFFF# * 16 **(63); 


type DURATION is delta 2.0**(-9) range -2**22 .. 2**22; 


end STANDARD; 


B-l 







Addendum to 

the ANSI Reference Manual for 
the Ada® Programming Language 


088 - 000070-02 


This addendum updates manual 069-000073-00 . 
See updating instructions inside. 


Ordering No.086-0000?0 

Rev. 02, December 1988 

Copyright <S Semantic Software. Inc.. 1984, 1988 

Copyright O Data General Corporation. 1984, 1988 

All Rights Reserved 

Printed in the United States of America 









Notice 


Data GENERAL CORPORATION (DGC) has prepared this document for use by ogc per¬ 
sonnel. CUSTOMERS. AND PROSPECTIVE CUSTOMERS. THE INFORMATION CONTAINED 
HEREIN SHALL NOT BE REPRODUCED IN WHOLE OR IN PaAT WITHOUT DOC’S PRIOR WRITTEN 
APPROVAL. 

DGC reserves the right to make changes in spaofications and other information contained in 
this document without prior nones, and the reader should in ail cases consult DGC to deter¬ 
mine whether any such changes have been made. 

THE TERMS AND CONDITIONS GOVERNING THE SALE OF DGC HARDWARE 
PRODUCTS AND THE LICENSING OF DGC SOFTWARE CONSIST SOLELY OF 
THOSE SET FORTH IN THE WRITTEN CONTRACTS BETWEEN DGC AND ITS CUS¬ 
TOMERS. NO REPRESENTATION OR OTHER AFFIRMATION OF FACT CON¬ 
TAINED IN THIS DOCUMENT INCLUDING BUT NOT LIMITED TO STATEMENTS 
REGARDING CAPACITY. RESPONSE-TIME PERFORMANCE. SUITABILITY FOR 
USE OR PERFORMANCE OF PRODUCTS DESCRIBED HEREIN SHALL BE DEEMED 
TO BE A WARRANTY BY DGC FOR ANY PURPOSE. OR GIVE RISE TO ANY LI¬ 
ABILITY OF DGC WHATSOEVER. 

IN NO EVENT SHALL DGC BE LIABLE FOR ANY INCIDENTAL. INDIRECT. SPECIAL 
OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING BUT NOT LIMITED TO 
LOST PROFITS) ARISING OUT OF OR RELATED TO THIS DOCUMENT OR THE IN¬ 
FORMATION CONTAINED IN IT. EVEN IF DGC HAS BEEN ADVISED, KNEW OR 
SHOULD HAVE KNOWN OF THE POSSIBILITY OF SUCH DAMAGES. 

CEO. DASHER. DATAPREP. DESKTOP GENERATION. ECLIPSE. ECLIPSE MV/4000. 
ECLIPSE MV/6000. ECLIPSE MV/8000. GENAP. INFOS. microNOVA. NOVA. 
PRESENT. dPROXI. SWAT, and TREND VIEW are U.S. registered trademarks of Data 
General Corporation; and AOSMAGIC. AOS/VSMAGIC. AROSE/PC. ArrayPlus. 

Bust GEN. BusiPEN. BuaiTEXT. CEO Connection. CEO Drawing Board. CEO DXA. 

CEO Light. CEO MAILI. CEO PXA. CEO Wordview. CEOwrite. COBOL/SMART. 
COMPUCALC. CSMAGIC. DASHER/One. DASHER/286. DASHER/386. DASHER/LN. 
DATA GENERAL/One. DESKTOP/UX. DG/500. DG/AROSZ. DGConnect. DG/DBUS. 
DG/Fonutyies. DG/GATE. DG/GEO. DG/L. DG/UBRARY. DG/UX. DG/XAP. 

ECLIPSE. MV/1400, ECLIPSE MV/2000. ECLIPSE MV/2SOO. ECLIPSE MV/7800. 
ECLIPSE MV/10000. ECLIPSE MV/15000. ECLIPSE MV/20000. ECLIPSE MV/40000. 
FORMA-TEXT. GATEKEEPER. GDC/1000. GDC/2400. microECLXFSE. mieroMV. 
MV/UX. PC Liaison. RASS. REV-UP. SLATE. SPARE MAIL. TEO. TEO/3D. 
TEO/EIectronics. TURBO/4, UNITE, and XODIAC are trademarks of Data General 
Corporation. 

Ada is a registered trademark of the U. S. Government (AJPO). ROLM is a registered trade* 
mark and ADE is a trademark of ROLM Corporation. 


Addendum to the ANSI Reference Manual for the Ada® Programming Language 

086-000070-02 

Effective with; AOS/VS ADE. Rev. 3.00 


Please insert Appendix F in your copy of the ANSI Riftrtnct Manual for tht Ada 
Programming Language. 






anS(/M(L ST3.i8iSA Mt tnet 


Appendix F: 

Implementation-Dependent 

Characteristics 

The DGC Ada compiler is distributed as part of the Ada Development Environment (AD El. 

DGC Ada is a validated implementation of Ada that conforms to the full ANSI/M1L-STD- L8L5A 
standard. The ANSI standard allows individual implementations to sec or certain language 

characteristics, such as pragmas, restrictions on representation clauses, and capacity 1™**- 

This appendix describes the language characteristics defined by the DGC implementation, version 
3.00 or higher. In this appendix, the ANSI Reference Manual for the Ada Pmpmtumng Language is 
referred to as the LRM. 

This appendix contains the following information: 

ADE-Defined Pragmas... —JF-2 

Pragmas That Have No Pffret .—... ... pa 

Pragmas Implemented in the ^np ... f-i 

ELABORATE_F-* 

ENTRY POINT._F-J 

INLINEl_ F-6 

INTERFACE. F-10 

LIST_-F-L5 

LOAD_ F-I6 

MAIN_F-17 

MAX TASKS_F-19 

MV ECS_F-20 

PAGE_F-21 

PRIORITY_F-22 

SUPPRESS_F-23 

TASK STORAGE SIZE_F-26 

Package SYSTEM.I_F-23 

Representation Clauses ...___-._—---F-30 

1 , ... .... ...F-30 

Enumeration Representation*-F-31 

Record Representation-F-32 

Unchecked Programming,,..-.—— -F-33 

Procedure UNCHECKED DEALLOCATION-F-34 

Function UNCHECKED ^CONVERSION_ F-35 

Characteristics of ADE Input-Output Packag e s., . - . - -- - -- F-36 

Maximum Sixes Limits in the ADE__-.—-F-37 

Summary of the ADE Real Type Attributes - - - ...... F-38 

Type Definitions in the ADE. ,. . - ... . .. . . F~*l 












ANSI/MIL ST0-181JA *3* S*<*rtne» Manual 


ADE-Defined Pragmas 

Pragma* ceil the compiler how to process your program at compile time. They do not affect the 
semantics of a program, but they allow you to exerase some control over how the compiler 
processes your programs. 

The ANSI Rcfeitnct Manual far tha Ada Propamming Languaga (LRM) describes the standard 
pragmas and their use. Other pragmas are defined by the various implementations of the 
language. This section provides additional information on those standard pragmas and defines the 
pragmas that are unique to DGC Ada. 

This section contains two parts. The first part lists pragmas this are not implemented in the 
current version of the ADS. The second part lists the implemented pragmas in alphabetical order, 
describes them, and provides examples of their use. 


P-2 


o— noorrro ni 

■>* 00007*00 






ANSI/ SA Adi A#ti»«nci Mirv.ii 


Pragma! That Have No Effect 

Tie following Ada pragmas are not implemented in the current version of the ADE: 


Pragma 

Explanation 

CONTROLLED 

This pragma is not aeeded because the compiler does not 
reclaim unused storage automatically. To deallocate storage 
explicitly, use the generic procedure 

UNCHECKED-DEALLOCATION. Refer to the LRM, 

Section 13.10, and the ADE User's Manual for more information 
about this procedure. 

MEMORYJI2E 

Tie package SYSTEM defines the MEMORY_SIZE constant 
as 2 *• 29 words. Use the /MTOP switch on the ADAL1NK 
command to adjust the maximum virtual memory size. Refer to 
the ADE User's Manual for more information about the 

AD ALINK command. 

OPTIMIZE 

Tie compiler does not currently use time or space optimization 
criteria. 

PACK 

This pragma has no effect in the current version. 

SHARED 

Tie compiler does not implement indivisible direct read and 
update operations for any object; therefore, there are no objects 
to which you can apply this pragma. Refer to the LRM. Section 
9.1L 

STORAGE UNIT 

Tie package SYSTEM currently defines the storage unit as a 
16-bit word. You can not redefine it. 

SYSTEM_NAME 

Tie package SYSTEM defines this as an object of enumeration 
type NAME, for which oniy one literal is allowed. 


I'lTT 10 I'll 


F-3 


o an o t a ro-oo 




ANSI/MIL STO-'81 !AAd» S«*«r«ne* Manual 


Pragmas Implemented in the AOE 

The following pages describe, is alphabetical order, the AD E-specific pragmas. 


pragma ELABORATE 

Specifies which library unit bodies (secondary units) to elaborate 
before the current compilation unit. 


Format 

pragma ELABORATE (libraryjjnit (,library_unit)); 


where: 

libraryjjnt Specifies the simple oaae of the library unit whose body you 

want elaborated before che current compilation unit. 

Description 

Pragma ELABORATE tells the compiler to elaborate the body of the specified library unit or 
units before elaborating the current compilation unit If the current compilation unit is a subunit 
the compiler elaborates the body of the specified library unit before elaborating the unit that is the 
ancestor of che current compilation subunit 

t 

Pragma ELABORATE must appear after the cornea clause for the current compilation unit and 
it mutt specify a library unit named in that contea clause. The specified library unit must have a 
body. 


For more information, refer to the LRM, Section 10 .5. 

Example 

with EARTH DATA; 

pragma ELABORATE (EARTHEDATA); 

procedure SOLAR^SYSTEM i/ 

EARTH J3ATA.TRACKORBIT; 

and S0tAR_SYSTEM; 


F-4 


can ooop7o-<3 
up &tm ijw ogoon oo 



ANSI/ MIU-ST^ 181SA Ad* S***f*fie» Miruii 


pragma ENTRY_POINT 

Associates an Ada subprogram name with a specific entry point label 
so foreign language routines can call or be called by Ada 
subprograms. 

Format 

pragma ENTRY^POINT (subprogramjname.' entry ^pointjwne*); 

where: 

subprogram name Specifies the unique game of an Ada subprogram defined in the 

declarative part of the current compilation unit. Do not use dot 
notation to specify subprogram jiame. 

entry point name Specifies the STRING literal denoting the actual external label. 

Use uppercase letters enclosed in quotes, for example, 
*FRTN_UBNAME*. 

Description 

Yon can use this pragma in either of two ways: 

• A subprogram written in another language can refer to an Ada subprogram using the entry 
point defined by this pragma. 

• An Ada subprogr a m can call a library routine written in another language by giving the name 
of the routine as an entry point. In this case, you must also use pragma INTERFACE to 
specify the language of the library routine. 

Pragma ENTRY POINT must appear in the declarative part of a block, in a package specification, 
or after a compilation unit. You must specify both arguments. 

Example 

procedure MAIN la 

function FHTN OP (X: INTEGER) return BOOLEAN; 

pragma INTERFACE (F77. FHTN OP); 

pragma ENTRY J»OINT (FRTNjJp. •FRTNJJBNAME’); 

•M 

begin 
end MAIN; 





an5!/MU.-ST0-'8isa Ada matuaj 


pragma INLINE 

Specifics 1he subprograms and generic units that you want expanded 
inline at each call whenever possible. 


Format 

pragma INLINE (name (, nama|); 


where 

name Specifies che subprogram or generic unit you want inline d at 

each caiL The subprogram or genenc unit must be defined 
before pragma INLINE in the declarative part of Use program. 


Description 

Pragma INLINE tells the compiler to insert code for the body of Use subprogram each time the 
subprogram is called. If the named subprogram is a generic unit, the compiler inserts code for Use 
bodies of ail subprograms that are instantiations of that generic unit. 

The following restrictions apply to pragma INLINE: 

« The nesting level of inlined procedures cannot exceed 100. 

• A program that inlines a function that returns an unconstrained object will not work correctly. 
The ADE will not inline the following: 

• Recursive subprograms 

• Subprograms containing exception handlers 

• Any unit that declares a task, task type, or access to a task type. 


M 


OH 000070 03 

oh oooon-oo 



Ad* Petere^ce 


pragma INLINE (continued) 


Example 

This example shows two assembly (.SR) files for the following source code. The first assembly file 
shows the source code compiled with pragma INLINE. The second example shows the assembly 
file without the pragma. 

Source Code 

In the following example, pragma INLINE applies to ail the calls to SQUARE in WITH INLINE. 

procedure WITH INUNE is 
FIRST, SECONO: INTEGER: 
function SQUARE (S : INTEGER) return INTEGER: 
pragma INUNE (SQUARE): 

function SQUARE (S : INTEGER) return INTEGER Is 
begin 

return S*S: 
end SQUARE; 
begin 

eio«r ■ -» t&qe in. 

SECCnT SQUARE (SQUARE (FIRST)); 
end WITH INUNE 



4NSI/MIU-ST0.W3A Ad* 


pragma INLINE (continued) 

Assembly File with Pragma INLINE 

e . , ntrAR B u -ii-d. the compiler inserts code for that funcnon. la tie foilowu* 

S^5SffiT«3SL- dJT n. M >» »*•—-»»*-■ 

beqin 

;; FIRST :» SQUARE (2); 

•• s • constant INTEGER • * 2: 
rstum S * 3 - first irtina extension 

" Sa «« = "* r 

•• SECOND :• SQUARE (SQUARE (FIRSTS); 
j* S : constant INTEGER : - SQUARE (FIRST); 

•• S • constant INTEGER •' * FIRST; 

;;™mS«S -sawndirtin. expanse 

xwmul °- 19 - 3 :: J 

XWSTA 0,1?.,3 >• 3 

;; returnS-S - third Irtina expansion 

XWMUL eerONQ 

XWSTA 0.14..3 ..SECONO 

WRTN 
;; and 

function SQUARE (S; INTEGER) return INTEGER is 
begin 

return S*S; ^ „ 

XWLDA O.0-12..3 

XWMUL 0.0-11.3 

XWSTA 0.-8-- 3 

WRTN 
;; end 


oaaooooTOca 
upeoM oaa-oooorvx 





ANSI/MIL aiSA ~a» V4: 


pragma INLINE (continued) 

Assembly File without Pragma INUNE 


;; begin 

•• FIRST: - SQUARE (2): 

LPSF U3 "f 

LCALL U2.1.1 - fll 

XWSTA 0.12.. 3 

;* S6CONO : - SQUARE (SQUARE (FIRST)); 
XWSTA O.I 7 " 3 

XPEP l7 - 3 "5 

UCA1L L2.1.1 " 5 

XWSTA 0.19..3 

XpFF 19..3 -P 

LCALL 1A1. “ l 

XWSTA O- 14 ’ 3 

WRTN 
;;snd 


- push effective address (U| - 2 

- first caii to SQUARE 


-push effective address [ 1 7]-* 

- second cad to SQUARE 

- push effective address (191 -18 
-third caU to SQUARE 


function SQUARE (S: INTEGER) return INTEGER Is 
begin 

3 * S ’ - beginning of the called function 

XWLDA O.S-11.3 

XWMUL Q.&1Z.3 

XWSTA 0.-8- 3 

'^ TTN - and of the cailed function 

;; 9TO 


L3: 2 

END 





an$I/MIL-STO-' 8'3A Ada Sa«#fanea Manual 


pragma INTERFACE 

Specific* another language (and calling conventions) for interfacing 
with an Ada program. 


Format 

pragma INTERFACE (!ariguage_name. jubprogram_narne); 


where: 

languege_nam# Specifies the language of the called subprogram. 

subpfogram_name Specifies the name of the called subprogram. The subprogram 

must be declared earlier in the program. 


Description 

Pragma INTERFACE allows you to call program units written in other languages (foreign 
subprograms). A specification for the named subprogram must be written in Ada. The body of 
the subprogram can be written in another language. 

Pragma INTERFACE must be ia the declarative part or package specification of the Ada unit that 
calls the subprogram. The subprogram you specify as an argument must be declared earlier in the 
same declarative part or package specification. 

Your program must include the following pragma LOAD statements in the order shown: 

pragma LOAD (*ADE ROOT?:RUNTIMES:INTERFACE LRT TRIGGGER’); 
pragma LOAD ("LANG^RTiS*); 

You must be able to access LANG_RT.L3 through one of the file access methods provided by the 
system, such as search lists or links. The IMPORT command links LANG_RT.LS automatically. 
Use it to import routines written in FT7, C, or PASCAL. 

Ada supports the of subprograms written in F77, PASCAL, C, MASM. and ASSEMBLY. 

In addition, you can call any language that obeys the common calling conventions of DGC 
languages, but you will receive a compiler warning that the language is not explicitly supported. 

The Ada runtime interface traps any runtime errors in the called routine and raises the 
PROGRAM_ERROR exception in the calling program. The interface also suspends Ada tasking 
during the call to the non-Ada subroutine. 


MO 


099 000070 09 

i n wiiw m oooon oo 




ANSI/MIU-3T^.^3i5A A<3« 'rfUPuti 


pragma INTERFACE (continued) 

General Notes 

• Characters within constructs are packed according to DGC alignment requirements for the 
called language. 

• Boolean!, arrays, and records are not packed. Booleaaa are passed one per word. 

• Return values are not checked for validity. 

• Procedure and function calls to ocher languages do not support type conversions. You must 
do type conversions explicitly. 

• You can pass ACCESS types, but exercise caution when changing Ada data structures. Data 
General may change data formats in a future revision. After receiving any revisions of the 
ADE, test thoroughiy all programs that depend on specific data formats. 

• LANG JIT performs the exception handling for foreign subprograms. IT a foreign 
su b program has an error, that error is propagated to the calling Ada program as a 
PROGRAMERROR. 

• Foreign subprograms must be in the same ring as the calling Ada program. 

• Foreign subprograms can perform I/O operations, but it is the user's responsibility to use 
pragma LOAD to load all the necessary runtime objects. Alternately, you can use the 
template facility provided by ADALINK. 

• The foreign code interface does not support Ada unconstrained types for any languages. 

• Ail appropriate LB and OB files must be loaded into Ada programs that call foreign 
programs. The IMPORT f u ncti o n only ensures that the OB containing your function and 
LANG JUT are loaded with pragma LOAD. If the foreign code requires additional runtime 
support, such as MULTITASKING.OB. you should add the names of all necessary OB and 
LB files to intefac*jtockagtji file. This file is created by IMPORT or by ADALINK 
templates. 



ANSI/MIL-STS-<311A Ada Rafwance Manual 


pragma INTERFACE (continued) 


Foreign Language Calling Conventions and Data Types 

The following sections describe the calling conventions and/or the data types used by DGC Ada to 
call subprograms written m foreign languages. 

MASM or ASSEMBLY 

The MASM and ASSEMBLY options provide the standard Ada calling conventions. If either is 
specified, the called program (which may or may not be MASM or ASSEMBLY) is expected to 
follow Ada calling conventions and to know how Ada data structures are formatted. 

F77 

F77 is supported as follows: 


F77 Data Type Ada Data Type 


INTEGER** 

INTEGER-2 

REAL** 

REAL-3 

CHARACTER-! 

CHARACTER-N 

ARRAY 


INTEGER 

SHORT INTEGER 

FLOAT' 

LONG_ FLOAT 

CHARACTER 

STRING(UN) 

ARRAY 


Notes: 

• Array elements must be of a supported scalar type. 

• Scalar parameters are passed copy-in copy-out. 

• One-dimensional arrays are passed by reference for copy-in copy-out. 

• Multidimensional arrays obey copy-in copy-out rules. 


F-ta 


0— 000070 M 
00 ^ 000073-00 



anSI/MiU S“w-'4i 5A Ada 3«t*»»cc« M*ru4i 


pragma INTERFACE (continued) 
C 

C is supported is follows: 

C Data Typa Ada Dsta Type 


SHORT INT 
LONG INT 
SHORT FLOAT 
LONG_FLOAT 

character 

POINTER 

ENUMERATION 

ARRAY OF CHARACTER 

ARRAY 

STRUCTURE 


SHORT INTEGER 
LONG INTEGER 
FLOAf 

LONG FLOAT 

CHARACTER 

ACCESS 

ENUMERATION 

STRING 

ARRAY 

RECORD 


Note; C calling conventions specify pass by value. Therefore, only copy-in mods is allowed for 
scalar parameters and structures. The call interface enforces pass by value for arrays. 

PASCAL 

PASCAL is supported as follows: 


PASCAL Data Typa Ada Data Type 


SHORT INTEGER 
LONG INTEGER 
real” 

DOUBLE REAL 

BOOLEAN 

CHAR 

ENUMERATION 

POINTER 

ARRAY 

PACKED ARRAY OF CHAR 
RECORD 


SHORT INTEGER 

INTEGER 

FLOAT 

LONG FLOAT 

BOOLEAN 

CHARACTER 

ENUMERATION 

ACCESS 

ARRAY 

STRING 

RECORD 


Notes: 

• Not supported: RECORD VARIANTS, SET, FILE. 

• One-dimensional arrays are passed by reference for copy* in copy-out. 

• Multidimensional arrays obey copy-in copy-out rules. 


QSM0007043 

00^000073-00 


F-13 






ANSf/MfU-ST3>t8l5A U| Manual 


pragma INTERFACE (continued) 


PL/1 

PL/l is supported as follows: 


PL/l Oats Type 

Ada Data Type 

FIXED BINARY (IS) 

SHORT INTEGER 

FIXED BINARY (31) 

INTEGER 

FLOAT BINARY (21) 

FLOAT 

FLOAT BINARY (53) 

LONG FLOAT 

POINTER 

ACCESS 

ARRAY 

ARRAY 

RECORD 

RECORD 


Notts 

• PL/l is ooc explicitly supported; however, the data types listed above caa be »« rd if ad data 
follows standard LANG^RT alignment and space characteristics. Specifying PL/l produces 
warning messages when you compile the program. 

• One-dimensional arrays are passed by reference for copy-in copy-out. 

• Multidimensional array obey copy-in copy-out rules. 


P-14 


00400007002 




iNSl/MIL-STO-taiJA A<3* 3«t«f»ce» Manual 


pragma UST 

Suspends or resumes the compiler listing file output 
Format 

pragma UST {ON ] OFF); 

Description 

The compiler always produces a listing (.LST) die unless you do oae of the following: 

• Include the /ERRORS switch with the ADA command (and the compilation units contain no 
errors) 

• Include pragma UST (OFF); in the compilation unit. 

Pragma UST (OFF); suspends the output in the JLST file during compilation. 

Pragma UST (ON); resumes -LST output. 

Example 

In the following example, the code for MEMBERS is not printed in the listing file. 

procedure MAIN Is 
type MEMBERS Is private; 
procedure SORT (UST: in out MEMBERS); 
function HEAD (L UST) return MEMBERS; 

pragma UST (OFF); 
type MEMBERS ia 

end MEMBERS; 
pragma UST (ON); 
begin 

end MAIN; 


QWOOOOTOOa 


F.is 


nwaoooomo 


ANSI/Mit STO-iaiSA >«• c* Manual 


pragma LOAD 

includes non-Ada object Alas in tbe linked program tile. 


Format 

pragma LOAO ("object JBejjathname'); 

where: 

objectJ8e_pathname Specifies the STRING literal (in quotes) that denotes the full 

pathname of the non-Ada object file you want to load. You do 
not need to include the .OB filename extension. 


0 ascription 

pragma LOAD allows you to i n c l u de foreign (non-Ada) object files in your program. You can use 
it with pragmas INTERFACE and ENTRY J»OlNT to allow Ada procedures to call non-Ada 
subprograms. The Ada linker includes the named object file when it builds the Ada program 
(.PR) file. 

Pragma LOAD must appear at the head of a compilation for a body. When using pragma LOAD 
with compilation subunits, always specify the /READ_SUBUNITS switch on the ADALINK 
command line. If you omit that switch, you may receive this error message from the Linker 

‘Can't get [body] tree for < programjinit jsame>* 

Note: Pragma LOAO does not guarantee the order of the loaded files. If order is important, use 
the /TEMPLATE switch with the ADALINK command. 

Example 

In the following example, the file SEVEN JJP.QB must be in the current directory. 

pragma LOAO fSEVEN JJP - ); 
with TEXT JO; usa TEXT JO; 
procedun~AOA_CALL3_PL1 la 
procedure SEVEN JJP (X: out INTEGER); 
pragma INTERFACE (PL1, SEVEN UP); 
pragma ENTRY POINT (SEVEN UP, ‘SEVEN UP“); 

N: INTEGER; 
begin 

SEVEN UP (N); 

PUT (Nf; 

end AO A CALLS PL1; 


F-1* 


HM CC0070 02 
nm ijrmn <~jj 




ANSI/mil 3TC-'ai JA A^a a«i*r«re» Maruaj 


pragma MAIN 

Indicates that a subprogram unit is a main program. 

Format 

png mu MAIN: 

Description 

Pragma MAIN designates the mam subprogram unit. Place pragma MAIN immediately after the 
subprogram you want to be the maia subprogram. 

Example 

The following code designates TEST as the main procedure, 
procedure TEST Is 
procedure FIRST is 
end FIRST; 

procedure SECONO is 

end SECONO: 
begin 

••• 

end TEST; 
pragma MAIN; 


OSMOOOTOOS 


iea— m oooon oo 


F»t7 






ANSI/Mlt.-ST0->8il* Ms Pmiivrcm Manual 


pragma MAIN (continued) 

Another way to distinguish the main subprogram in a compilation unit is to use the 
, MAIN PROGRAM switch on the ADE command line. For example, you can compile the 
procedure TEST, located in the source Hie TEST AD A, as a main program with this command: 

-) AOA/MAIN J’flCGRAM « TEST TEST 

You must use the /MAIN_PROGRAM switch in each of the following cases 

• The source file that you are compiling contains more than one library unit 

• You specify more than one source file with the same ADA command. The compiler assumes 
that the first file listed contains the main program. If it does not, you must specify which 
subprogram is the main program with the /MAlN_PROGRAM switch. For example, the 
following command compiles the source files FOO ADA, FOOBARADA, and TEST ADA. 
It compiles the subprogram TEST ADA as the main program: 

*) AOA/MAINJ»ROGRAM - TEST FOO TEST FOOBAR 

For more information about the ADA command, refer to the ADE Ufa's Manual. 


F*11 


QM OOOOTQ 03. 

man oa»cooor>oo 






ANSI/MIL-STO-'8i5A Ada ^<*f«nea Manual 


pragma MAX_TASKS 

SpadflM tha maximum numdar of Ada tasks you want activa 
simultaneously. 


Format 

praams MAX JASKS (n); 


where: 

n Specifies an integer value greater than zero. 

Oascription 

Pragma MAXTASKS specifies the maximum number of Ada tasks that can be active at the same 
time. If you do not specify the number, the system gives you a maximum of 30. 

This pragma must appear at the head of a compilation. It applies to all units in the compilation. 

Exampla 

pragma MAX JASKS(40); 
package body TASKS is 

task ONE is...; 
task TWO Is...; 

task type THREE TO FORTY is...; 
type REMAINING JASKS is 
array (3..40) ofTHREE TO FORTY; 

MULTI JASKS ; REMAINING JASKS; 

and TASKS; 


You can also specify the m aximum number of tasks by using the /MAX JASKS switch with the 
AJDALINK command. For example: 

•)AOAUNK/MAX JASKS-40 object Janame 

If you specify a maximum number of Ada tasks with both a pragma and a switch, the pragma cakes 
precedence. For more information, refer to the ADE UsVt Manual. 







ANSI/MH. ST0-'S15A ao« vtsnuw 


pragma MV_ECS 

SpeciflM tfte us« of the Data General MV External Calling Sequence. 


Format 

pragma MV_ECS( unit_nama {.unitjiame...]); 


where 

unitjianie Specifies the same of the subprogram for which you need the 

compiler to generate MV ECS. 

Description 

To optimize code quality, the compiler does not always generate code that conforms to the Data 
General MV External Calling Sequence (ECS'). In some cases, however, you will need to cell the 
compiler that MV ECS is necessary. Subroutines that meet any of the following criteria must use 
MV ECS; 

• MACHINE_CODE subroutines with formal arguments 

• Subroutines called from other DGC languages 

• Subroutines that can be called from outer rings. 

Place pragma MV ECS Immediately after the subprogram for which you want the coemier to 
generate MV ECS. 

Example 

procedure TEST is 

procedure FIRST is 

end FIRST; 

procedure SECQNO le 

end SECQNO; 
begin 

end TEST; 

pragma MV_ECS( TEST); 


F-20 


oee 000070 oa 
upaatM am oooon oo 





ANSI/MIU-STO-WSAAda R*<«r*oc* Manual 


pragma PAGE 

Begins a new page in tne compiler output iiating fife. 

Format 

pragma PAGE; 

Description 

The compiler produces a listing (.LST) file unless you do one of the following: 

• Include the /ERRORS switch with the ADA command (and the compilation unit contains no 
errors) 

• Tnrfarfg pragma LIST (OFF); in the compilation unit. 

If the compiler is producing a listing of the compilation, pragma PACE causes the text following 
the pragma to appear on a new page. 

Example 

In the following example, procedure SECOND would be printed on a page by itself. 

procedure FIRST is 

end FIRST; 

pragma PAGE; 
procedure SECONO is 

end SECONO; 

pragma PAGE; 


0—OOOBTPgi 

nine— ore oooon-oa F-21 





ANSI/ MIL-STO-181SA Ad* A«<*r*fle* Manual 


pragma PRIORITY 

Specifies the priority of a task or task typo. 


Format 

pragma PRIORITY (n); 


where: 

n Specifies an integer value from L to 10. Lower values indicate 

lower priorities. 

Description 

You can assign priorities to tasks or task types by including pragma PRIORITY within the 
appropriate task specifications. 

Assigning priorities tells the system how to handle competing tasks. When more that one task is 
eligible for exec u tion at the same time, the system executes them in the order you specify with 
pragma PRIORITY. Tasks that are ready for execution are queued first by priority number and. 
within priorities, by order of their occurrence in the source file (FIFO). 

You can assign each task or task type only one priority. If you assign more than one priority, the 
system recognizes the first assignment and ignores the others. 

Assigning priorities is optional. The default priority is 2. 


Example 

The following code assigns a priority of 7 to TASK_TYPE and a priority of 3 to NEXT_TASK_ 

procedure OUTER is 

task type TASK JTYRS is 
pragma PRIORITY (7); 

end TASK JYPE; 

task type NEXTTASK is 
pragma PRIORITY (8); 

and NEXT JASK; 

end OUTER: 


P-22 


U| 


oeeooooro-oa 
oae ooooyi oo 



ANSI/MIL-ST0-1815A Ads matvisi 


pragma SUPPRESS 

SupprMsaa specified runtima checks. 


Format 

pragma SUPPRESS (cfieck_kiefltifler [, [ON* >] namej); 


» 


I 


where: 

checkjdenttfler Specifies the c h eck you waul to suppress. Check identifier 

names are listed in the description chat follows. 

name Specifies the name of a type, subtype, object task unit, generic 

unit, or subprogram. 

Description 

To suppress certain runtime checks, place pragma SUPPRESS in the declarative part of a program 
unit or block or immediately within a package specification. For statements in a program unit or 
block, check suppression extends from the pragma statement to the end of the declarative part 
associated with that program unit or block. For stateme nts in a package, check suppression 
e xtends to the end of the scope of the specified ON* > entity. You must declare that entity 
immediately within the package specification. 

The following table shows the extent of check suppression for each named entity. 


Check suppression for Extends over 


An entity (name omitted) 

An object 

An object of the base type or subtype 
A task or task type 
A generic unit 
A subprogram 


The remaining declarative region 

Ail operations of the abject 

All operations of the object or subtype 

Ail activations of the task 

Ail instantiations of the generic 

Ail calls of the subprogram 







ANS1/MH.-STO-1815A Ad* 3«<«r«ne« Manual 


pragma SUPPRESS (continued) 

Although it is a better programming practice to have runtime exceptions rr^d ltuumancally, you 
can suppress them if you need to decrease runtime overhead. When you suppress runtime checks, 
you turn off certain program exceptions. If an error arises after you have suppressed a check, your 
compiled program will not work correctly. The following table shows wnich program exceptions 
you turn off when you suppress 


Suppression of this 
chcckjdcntiflcr 

Turns off this 
exception 

When program detects this runtime 
error 

ACCESS_CHECK 

CONSTRAINT 

ERROR 

Selection or indexing applied to an 
object with a null value 

DISOMINANT 

CHECK 

CONSTRAINT 

ERROR 

Violation of discriminant constraint 

INDEXCHECX 

CONSTRAINT 

ERROR 

Out-of-range index values 

LENGTH 

CHECK ’ 

CONSTRAINT 

ERROR 

Wrong number of index components 

RANGE.CHECX 

CONSTRAINT 

ERROR 

Values exceed range constraint, or 
type is incompatible with constraint 

DIVISION 

CHECK 

NUMERIC 

ERROR 

Division, rem, or mod by zero 

OVERFLOW 

CHECK 

NUMERIC 

ERROR 

Operation result exceeds implemented 
range 

ELABORATION 

CHECK 

PROGRAM 

ERROR 

Attempt to call a unit before it is 
elaborated 

STORAGE 

CHECK 

STORAGE 

ERROR 

Over-allocation of memory space 





ANSI/MIU-STO-iglSA AO« a-ttftrea 


pragma SUPPRESS (continued) 

Example 

la the following example, the pragma suppresses the checks on the indices of variables of the type 
TABLE. Ail type TABLE operations in MAIN are aUected. No exceptions are raised if X and Y 
are not in the range of 1 to 3. 

procedure MAIN le 
type COLOR is (RED. BUCK); 
type TABLE is array (i.. a, t. .3) of COLOR: 
pragma SUPPRESS (INDEX CHECK. ON - > TA8LE); 

X Y: INTEGER: 

BOARD: TABLE; 
begin 

BOARO (X Y): - RED: 
end: 


P-2S 


oeeooooToai 
ip n —■ n ee o oo on o o 



ANSJ/MlL-5TO-'8i5A Ada • Manual 


pragma TASK_STORAGE_SIZE 

Specifies the amount of heap storage space to allocate for task 
stacks. 


Format 

pragma 7ASK_STCRAGE_S!Z£ (n); 


where: 

n Specifies Che total number of 2-byte words you want to allocate 

for ail active task stacks. The variable a can be any integer 
value, but only values greater than -1 have an effect. 


Description 

Pragma TASK_STORAGEJ3IZ£ allows you to reset the amount of heap space to allocate for all 
task sucks. The amount of space you specify should exceed the amount of storage you need at oae 
time for all active tasks. By default, the system allocates 128 K words. 

The pragma must appear at the head of a compilation. It applies to the entire compilation unit. 

You can also use the /TASK_STORAGE_SIZE switch on the ADAL1NK command line to 
control the maximum heap space allocated to active task stacks. If you use both the pragma and 
the command switch, the pragma takes priority. 

Resetting MTOr 

If you need to set TASK_STORAGE_SIZE to a value greater than the current virtual address 
space allows, you must reset the maximum virtual address space by specifying the value of MTOP. 
MTQP defines the maximum virtual address for a program. Use the /MTOP switch with the 
AJDAI2NK command to specify how many megabytes your program requires. The default value of 
MTOP is 1 Mbyte. 

For example, this command resets MTOP to 20 Mbytes: 

•) AOAUNK/MTOP-20 obfectjle 


F-2S 


00000007003 
upflMM 08000007300 


ANSI/MIL-370- ! 3' SA Ac a S*<*««ne« 


pragma TAS K_ST0RAGE_SI2E (continued) 

Individual Task Storage 

By default, the system allocates 2048 words for each active task stack. If you require a Larger or 
smaller stack for a particular task type, use the STORAGE_SlZE representation clause. For 
example, the following clause tells the compiler to associate task type BIG with a stack of size N: 

for BIG’STORAGE JI2E use N; 

The minimum stack size that you can specify is 512 words. 

Exampto 

In the following example, the value given in the pragma excee d s the storage required for all tasks 
at one time. 

pragma TASK_STORAGE_SIZE(56J3O0) 
procedure MaTn is 

task type ONE is 

tar QNESTORAGE_SlZE use 1J300; 
task type TWO is 

for TWO-STORAGE SIZE use 2 000: 


task type TEN Is 

for TEN'STORAGE_SIZE use 10JXXJ; 
end MAIN; 


oee 00007002 
BniiMeoooon-00 


F- 27 




ANSI/ MIU-S70-' 8' SA A at 3«t«f*nc* Maru4i 


Package SYSTEM 


The predefined library package SYSTEM defines certain types, subtypes, and objects that are 
specific to DGC Ada. The package SYSTEM is described in the LRM. Section 13.7. 


SYSTEM contains the following dedaradona: 


package SYSTEM is 


typo AOORESS Is new INTEGER: 
type NAME is (MV); 

SYSTEM NAME : constant 

STORAGE UNIT : constant 

MEMORY SIZE : constant 


NAME : • MV; 

is: 

2 "* 29; 


MAX I NT 

minTnt 
max' oigits 
max'mantissa 
rne' delta 
tick' 


: constant:» (2**30) -1 * (2**30); 
: constant: * -MAXJNT • 1; 

: constant:» tS; 

: constant: ■ 31: 

: constant: • 2.0 ** (-31): 

: constant :» 0.1; 


sufitypa PRIORITY is INTEGER rang# 1 .. 1 Q; 


and SYSTEM; 


The following table describes these types and constants and gives the value of each. 


Type or Constant 

Defined is 

Explanation 

ADDRESS 

INTEGER 

Address clauses and attributes 
(P* ADDRESS') return objects of the 
derived type ADDRESS. 

NAME 

MV 

The enumeration type NAME 
declares one object: the literal MV. 

SYSTEMNAME 

MV 

SYSTEM J^AME is an object of type 
NAME and is initialized to MV. 

STORAGE_UNTT 

16 

Denotes the number of bits per 
storage unit. 

MEMORY JIZE 

2**29 

Denotes the number of available 
storage units. 

MAXJNT 

(2**30MM2**30) 

• 2_147_483_647 

Denotes the highest value of 
predefined INTEGER rypev 


P-21 


00100007042 


qq> croon go 




ANSI/MlU-jTO.;atSA Ada 'Aaruai 


Type or Coos tut 

Defined u 

Explanation 

MINJNT 

-MAX INT -1 • 

- 2_ 147 ”'i83_6^8 

Denotes the lowest (most negative) 
value of predefined INTEGER types. 

MAX DIGITS 

13 

Denotes the largest number of 

point constraint. 

MAXMANTISSA 

31 

Denotes the largest allowed number 
of binary in mantissa of 

model numbers of a fixed-point 
subtype. 

FINE DELTA 

•m 

LQ”(-31) 

Denotes the smallest delta allowed in 
a fixed-point constraint thar has the 
range constraint -L0_LQ. 

TICK 

0.1 

Denotes the basic dock period in 
seconds. 

PRIORITY 

L.10 

Declares the range of values you can 
use on pragma PRIORITY 
statements. PRIORITY is a subtype 
of the base type INTEGER. 





ANSI/MU.-3T0-131SA Ada Scfcftnct Manual 


Representation Clauses 

This section describes the use of representation clauses in die ADE. You can use representation 
clauses for either of rwo purposes: 

• To specify a more efficient representation of data in the underlying machine 

• To communicate with features outside the domain of the Ada Language, for example, 
peripheral hardware. 

The Ada programming language provides four classes of representation clauses: 


Clause Class 

Specifics 

Length clause 

The amount of storage you want associated 
with a type. 

Enumeration representation 

The internal codes for the literals of an 
enumeration type. 

Record representation 

The storage order, relative position, and size of 
record components. 

Address clause 

The require! address in storage for aa entity. 
Address clauses are not supported by the 

ADE. To assign internal names, use pragma 
ENTRY_POINT whenever possible. 


The following paragraphs describe the use of each class of representation clauses. 


Length Clauses 

You can use the ’STORAGE J5IZE attribute only for reserving storage for activating a task type. 
For example: 

BITS :constanc»i; 

BYTES . constant: ■ 8’SnS; 

KBYTES :consanc- 1024-BYTES; 

task type MONITOR Is...; 

for MONlTOfVSTORAGE JIZE use 4'KBYTES; 

The ADE does not support the 'SIZE and ’SMALL attributes. 


P-30 


o—ooogwxa 
oee Q00Q73-00 







ANSI/MIL-3T£. m 5 A Afl* a«f»**ne» 


Enumeration Representations 

The ADE supports enumeration representation clauses as specified in the LRM. Section L3_3. All 
enumeration literals must be provided with distinct. static integer codes. The sequence of integer 
codes specified for the enumeration type must consistently increase ia value. 

There are two restrictions: 

• The range of internal codes trust be a SHORT^INTEGER. 

• Enumeration types with representation clauses are not allowed as the index type of an array 
type definition (refer to the LRM, Section 3.6). 

Chang# of Representation 

To change the representation clause of a type, you can declare a second type, derived from the 
first, and assign the variables of the first type to the second type. This process is described in the 
LRM, Section 13.6. 

Operations of Olscrate Types 

If yon use the attributes 'POS, ’VAL. SUCC, and PREP, the program may involve 

additional runtime overhead. Since potentially noncontiguous internal codes must bs. mapped to 
position numbers, caemring the program involves additional overhead if the argument is nonstatic 
or is a discrete type or subeype whose base type is enumeration rep r e s ent a ti on. Refer to the LRM, 
Section 13 3 for more information. 

Conversions mat Cause Overhead 

Explicit conversions between enumeration types in which either base type has a representation 
danse may cause additional runtime overhead. The argument itself and the method of conversion 
both ef fe ct the amount of overhead. 

You can perform explicit conversions between enumeration types by using an attribute such as 
'POS or 'SUCC to evaluate an argument and assign the results to a variable of the target type. 

You can also perform explicit conversions by using the attribute and its argument as the actual 
parameter in a subprogram caiL Each method of converting between types causes additional 
overhead if the argument ia nonstatic In the latter case Ada performs checks on the actual 
parameter that may also add overhead. 

Sections 3-5-5,4.6, and 6.4.1 of the LRM provide more information about explicit conversions and 
parameter associations. 


<**00007003 


F-Jl 





ANSI/MH. ST3-1 a 15A *3* Rafwanee Manual 


Cast Statements 

If the ba se type of the caw statement expression is an enumeration type with a representation 
dause, the resulting cod e is optimized with res pea to space rather than time. The value of the 
case expression is compared with case alternatives until a match is found. 

Case statements with types other ^an enumeration with a representation clause are unaffected. 


Loop Statements 

FOR loops for which the base type of the loop parameter is an enumeration type with a 
repr esentation clause causes additional runtime overhead. (For more information refer to the 
LRM, Seaton 3-5-5.). 

Loop for which the base type is not as enumeration type with a representation clause 

do not cause additional overhead. 

Record Representations 

Representation of record types in the ADE is the same as in standard Ada with certain 

restrictions. Specifically, you cannot use record representation clauses to specify alignment and 
component locations for the following; 

• Record types with discr i m i na nts 

• Record types with variant parts 

• Record types with array components. 

When specifying component storage, you can cross only one 16-bit word boundary. You ca nno t 
specify the storage for composite, FLOAT, or LONG_FLOAT components. For components of 
these types, the compiler automatically determines the storage required. You can specify storage 
for all the remaining component types the same way as in standard Ada. 


m ooooTo oa 







ANSI/MIL-STO-I815A Ad* 


The following example show, a valid record representation tpeoftcatiotu 


type IUFL l* 

f9 REnjRN FLAGS : INTEGER range 0 .. 15: 

TERMINATION JRELD '• INTEGER rang# 0.. 7, 
PROCESS 10 ; INTEGER rang# t .. 255. 

and record; 
for IUFL us# 

record „ .. 

RETURN FLAGS at 0 range 0 - A 

TERMINATION ELD at 0 rang# 5 .. 7. 

PROCESS JO " at 0 rang# 8.. 15: 

end record; "* 

(user Qag word) in a ?IR£C system calL 


at 0 range 0 •• *: 
at 0 rang# 5 .. 7; 
at 0 rang# 8.. 15: 


Field 

Boundaries 


Field 

Contents 


RETURN FLAGS 

^ _ termination FIELD 

£13 process_id 

n. ade do» « alto. «.!»««>u,owbp:Wtot-M«*‘ l 
cross more than one 16-bit word boundary. 

Unchecked Programming 

ThcWlcn, 

s e c t io ns explain how to use these subprograms. 


QaftOGoarooa 



ANSI/Miu-STO- i 81SA Ad« Baiwence Manual 


Procedure UNCHECKED^DEALLOCATION 

You as use the generic procedure L’NCHECXED_DEALLOCATTON to deallocate dynamic 
objects explicitly that are designated by values of access types. To deallocate dynamic objects 
explicitly, your program must instantiate this procedure for a particular object and access type. In 
the program body, a call to the instantiated procedure specifies the dynamic object as a parameter. 
When that call is executed, the specified object is deallocated, and its value is set to aulL The 
following example shows how this works: 

Example 

In the following example, the call to the procedure DISPOSE deallocates the dynamic object 
designated by the access value ROOT! and resets ROOT1 to null However, if the enclosing 
procedure uses the other a c ce s s value, ROOT2, to designate the same object as ROOTI, this code 
causes a program error because the object no longer exists. You must watch for similar dangling 
references when using the procedure UNCHECKED ^DEALLOCATION. 

with UNCHECKED J3EALL0CAT10N: 
package TREE_LA8£L£R is 

typa LABELJYPE is private: 
type NODE:' 

typa TREE Is accsss NODE: 
type NODE is record 
LABEL : LABELJYPE; 

LEFT : TREE; 

RIGHT : TREE: 

end record: 


procedure DISPOSE is new UNCHECKED DEALLOCATION (NODE. TREE); 


procedure LABEL ROOT (LABEL 

ROOT 
LABELLED TREE 

end TREE LABELER; 


: in LA8EL_TYPE; 
: in out TREE: 

: out TREE): 


package body TREEJABELER is 
procedure LABEL ROOT (LABEL 

ROOT 

LABELLED TREE 
ROOTI, ROOTZ 


in LABEL JYPS; 
in out TREE; 
out TREE); 
NOOE; 


begin 

DISPOSE (ROOTI); 

end LABEL ROOT: 
end TREEJjASELER: 


F*34 




Qsea»OTO-Qa 

aae-ooDon-oo 




AN$I/MIU,-3T0-i$ 15A Act 


Function UNCHECKED_CONVERSlON 

The generic function UNCHECK£D_CONVERSION allows you to return the value of a copy-in 
parameter as a value of a target type. The actual bit pattern corresponding to that parameter value 
does not change. 

The function L'NCHECKED_CONVERSION is a unit in the ADE SYSTEM library. The visible 
part of that function is listed below. 

generic 

type SOURCE is limited private: 
type TARGET is limited private; 

function UNCHECKED ^CONVERSION (S : SOURCE) return TARGET; 

function UNCHECKED CONVERSION (S ; SOURCE) return TARGET is 
pragma SUPPRESS (RANGE_CHECK); 
begin 
return S; 

end UNCHECKED CONVERSION; 

For instantiations of this generic function, types SOURCE and TARGET must be of the same 
class and the same length. SOURCE and TARGET cannot be array types. 

For more information about unche c ke d conversions, refer to the LRM, Section 13.10. 

Example 

The following example shows source code that uses the function UNCHECKED_CONVERSION. 

with UNCHECKEO_CONVERSION. ALPHA; 
package BETA is 
type TEST_NAM6 is private: 
type OATAls record 

IS VAUD : BOOLEAN; 

TEST_08JECT : TEST_NAME; 

end record: 

function CONVERT TO BETA OATA is new 
UNCHECKED-CONVERSION {ALPHA.INFO. DATA); 
function CONVERT FROM BETA OATA is new 
UNCHECKEDjOONVERSlON (DATA, ALFHA.iNFO); 

end BETA; 


F-35 


fee 000870 qj 




ANSI/MIC-STD-taiSA W* M»nu*l 


Characteristics of ADE Input/Output Packages 


m (he DGC manual Learning to Us* Your AOS/VS System. 


men you are using the ADE I/O packages, remember the following: 

. The made** -eta f« TEXr.lO.COUNT arf TBCT.IOJTEU: * SYSTEM.MAX.IVT. 
. The FORM paiameler of th« TEXT_IO.OPEN procedure it aol used. 

. Type TEXT JO iTLE_TY?E is an access type. 


For more 


information about input/output operations 


in the ADE, refer to ±cAD£ User's Manual. 


p*3i 


06MOOOTO-Q2 

upemaeon in'irrwjo 



ANSI/MU. 5*3^8 15 A 


Maximum Size Limits in the ADE 

The ADE places the following absolute limits on the use of Ada language features: 


Compilation step 


Language Feature 


Maximum 
or amount 


Syntax parsing 

Length of identifiers 

no 


Length of line 

no 

Semantics checking 

Discriminants in constraint 

256 


Associations in record aggregate 

256 


Fields in record aggregate 

256 


Formals in generic 

256 


Nested contexts 

250 

Generating machine code 

Indices in array aggregate 

128 


Parameters in call 

128 


Nesting depth of expressions 

100 


Nesting depth of iniined expressions 

100 


Nesting depth of packages with tasks 

ICO 



ANSI/MIL-STO-ISISA Ana a*l«r«nc* Manual 


Summary of the ADE Real Type Attributes 

The following session lists the same and value for each ADE specific real attribute. 


Float Type 


Value 


TMACHINE_RADIX 


16 


TMACHINEMANTISSA 


6 for FLOAT 

14 for LONG FLOAT 

It is the number of T*MACHINE_RADIX 

(hex) digits in mantissa. 


tmachike_emax 


t-machine^emin 


tmachine_rounds 

TMACHINE.OVERFLOWS 

TSAFE.EMAX 


TSAFEJMALL 

TSAFE^LARGE 


It is the maximum exponent for MV floating 
types, base 16. 

-64 

It is the minimum exponent for MV floating 
types, base 16 . 

TRUE 

TRUE 

252 

The formula is: 

log, (TMACHINE RADIX) * 
TMaCHINE.EMAX 

2.0 - (-TSAFE_EMAX - 1) 

2.Q •• TSAFE EMAX * (1.0 • 2.0 ** 
(.TBASE'MANnSSA)) 


ANSl/MIL-STO-’aiSA Ad* 


Fixed Types 


Value 


TMACHINE.ROUNDS 
TMACHINE.OVERFl.OWS 
TEASE'S MALL 
TBASE'MANTISSA 


TRUE 
TRUE 
- TSMALL 

(Same aa SYSTEM .MAX.MANTISSA) 


tsafe.small 

tsafe.large 


. TBaSE’SMALL 
. TBASE’LARGE 


also 


. (2 •* TBASE r MANTISSA -1) * 
TBASE'SMALL 


OtMODOTOOa 

.nu i ai am " 


anSI/MIL- 3T3-’31!A Ad* 3*t«r*nc* vi*nu*i 


General Notts 

• All fixed-point numbers are stored ia 32-bit integers. 

. Flo.tmg.pomt tvpos togmrmg 5 digit, or to of pretoo. to stored m FLO AT; thorn 
requiring 6 to 14 digits are stored in LONGBOAT. 

. FLOAT and LONG FLOAT use 1 bit for the sign and 7 bits for 56 

notation. FLOAT has 24 bits available for the mantissa; LONG .FLOAT has .6. 

. For FLOAT and LONG.FLOAT. the smallest number that can be represented u the MV 
architecture is given by the following formula: 

TMACHINE,RADIX •• (TMACHINE.EMJN -1). 

This is equal to 16 •• (-65) or 16 #0.10000000000000# * 16 ** (-64). 

. For FLOAT and LONG .FLOAT, the largest number that can be represented in the MV 
architecture is given by the following formula. 

n 0 . TMACHINE RADIX - (-TMACHINE_MANTISSA)) * 
(TMACHINE.RADIX •• TMACHINE.EMAX). 

For FLOAT, this is equal to 16 # 0 iTFFF# * 2 “ (63). 

For LONG .FLOAT, this is equal to the following; 

16 # 0 JFFFFFFFFFFFFF # * 2 - (63) for LONG.FLOAT. 


09640007942 
uooatM 09600007340 



Definition 


Type 


INTEGER 


FLOAT 

DURATION 


The set of integers begins with the value MIN INT and ends 
with MAXINT. The formulas for MIN JNT'and MAXINT 
are described under 'Package SYSTEM.* 

The type FLOAT is defined by the values described in the notes 
under 'Summary of the ADE Real Type Attributes.' 

The type DURATION is defined as follows: 

2.0 ” (-9) range -2 " 22- 2 **22; 


End of Appendix 




APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension . TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


C-l 




MACRO.DFS 


ACVC VERSION 1.10 


-- THIS FILE CONTAINS THE MACRO DEFINITIONS USED IN THE ACVC TESTS. 

— THESE DEFINITIONS ARE USED BY THE ACVC TEST PRE-PROCESSOR, 

— MACROSUB. MACROSUB WILL CALCULATE VALUES FOR THOSE MACRO SYMBOLS 

— WHOSE DEFINITIONS DEPEND ON THE VALUE OF MAX_IN_L£N (NAMELY, THE 
--- VALUES OF THE MACRO SYMBOLS BIG_ID1, BIG_ID2, BIG ID3, BIG ID4 , 

— BIG STRING1, BIG_STRING2, MAX_STRING_LITERAL, BIG~INT_LIT,~ 

— BIG REAL LIT, MAX_L£N_INT_BASED LITERAL, MAX LEN REAL_BASED_LITERAL, 

— AND BLANKS). THEREFORE, ANY VALUES GIVEN IN THIS FILE FOR THOSE 

— MACRO SYMBOLS WILL BE IGNORED BY MACROSUB. 

— NOTE: THE MACROSUB PROGRAM EXPECTS THE FIRST MACRO IN THIS FILE TO 

BE MAX IN LEN. 


— EACH DEFINITION IS ACCORDING TO THE FOLLOWING FORMAT: 

— A. A NUMBER OF LINES PRECEDED BY THE ADA COMMENT DELIMITER, 

THE FIRST OF THESE LINES CONTAINS THE MACRO SYMBOL AS IT APPEARS 
IN THE TEST FILES (WITH THE DOLLAR SIGN) . THE NEXT FEW "COMMENT" 
LINES CONTAIN A DESCRIPTION OF THE VALUE TO BE SUBSTITUTED. 

THE REMAINING "COMMENT" LINES, THE FIRST OF WHICH BEGINS WITH THE 
WORDS "USED IN: " (NO QUOTES), CONTAIN A LIST OF THE TEST FILES 
(WITHOUT THE .TST EXTENSION) IN WHICH THE MACRO SYMBOL APPEARS. 
EACH TEST FILE NAME IS PRECEDED BY ONE OR MORE BLANKS. 

— B. THE IDENTIFIER (WITHOUT THE DOLLAR SIGN) OF THE MACRO SYMBOL, 

FOLLOWED BY A SPACE OR TAB, FOLLOWED BY THE VALUE TO BE 
SUBSTITUTED. IN THE DISTRIBUTION FILE, A SAMPLE VALUE IS 
PROVIDED; THIS VALUE MUST BE REPLACED BY A VALUE APPROPRIATE TO 
THE IMPLEMENTATION. 

— DEFINITIONS ARE SEPARATED BY ONE OR MORE EMPTY LINES. 

— THE LIST OF DEFINITIONS BEGINS AFTER THE FOLLOWING EMPTY LINE. 

— $MAX_IN_LEN 

— AN INTEGER LITERAL GIVING THE MAXIMUM LENGTH PERMITTED 3Y THE 

— COMPILER FOR A LINE OF ADA SOURCE CODE (NOT INCLUDING AN END-OF-LINE 

— CHARACTER). 

— USED IN: A26007A 

MAX_IN_LEN 120 

— $3IG_ID1 

— AN IDENTIFIER IN 'WHICH THE NUMBER OF CHARACTERS IS $MAX IN LEN. 

— THE MACROSUB PROGRAM WILL SUPPLY AN IDENTIFIER IN WHICH THE 

— LAST CHARACTER IS '1' AND ALL OTHERS ARE 'A’. 

— USED IN: C230Q3A C23003B C23003C B23003D B23003E C23003G 

C23003H C23003I C23003J C35502D C35502F 

BIG ID1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, 


— $BIG_ID2 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN LEN, 

— DIFFERING FROM $BIG_ID1 ONLY IN THE LAST CHARACTER. THE MACROSUB 

— PROGRAM WILL USE '2' AS THE LAST CHARACTER. 

— USED IN: C23003A C23003B C23003C B23003F C23003G C23003H 

C23003I C23003J 

BIG_ID2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ 

— $BIG ID3 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN_LEN. 

— MACROSUB WILL USE 1 3’ AS THE "MIDDLE" CHARACTER; ALL OTHERS ARE 'A 

— USED IN: C23003A C23QQ3B C23QQ3C C23003G C23003H C23003I 

C23003J 

BIG_ID3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3; 





— $BIG_ID4 

-- an identifier in which the number of characters is $max_in_len, 

— DIFFERING FROM $BIG_ID3 only in the middle character, macrosub 

— WILL USE '4' AS THE MIDDLE CHARACTER. 

— USED IN: C23003A C23003B C23003C C23003G C23GQ3H C23Q03I 

C23003J 

BIG_ID4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAA 

— $BIG STRING1 

— A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH $BIG_STRING2 

— ($BIG STRING1 & SBIG STRING2) PRODUCES THE IMAGE OF $BIG ID1. 

— USED IN: C35502D CI5502F 

BIG_STRING1 "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ” 

— $BIG_STRING2 

— A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH $3IG STRINGI 

— ($BIG_STRING1 & $3IG STRING2) PRODUCES THE IMAGE OF $BIG IDI. 

— USED IN: C35502D CI55Q2F 

BIG_STRING2 " AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1" 

— $MAX_STRING_LITERAL 

— A STRING LITERAL CONSISTING OF $MAX_IN_LEN CHARACTERS (INCLUDING THE 

— QUOTE CHARACTERS) . 

— USED IN: A26007A 

MAX_STRING_LITERAL " AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

— $NEG_BASED_INT 

— A BASED INTEGER LITERAL (PREFERABLY BASE 8 OR 16) WHOSE HIGHEST 0EIDER 

— NON-ZERO BIT WOULD FALL IN THE SIGN BIT POSITION OF THE 

— REPRESENTATION FOR SYSTEM.MAX INT, I.E., AN ATTEMPT TO WRITS A 
-- NEGATIVE VALUED LITERAL SUCH AS -2 BY TAKING ADVANTAGE OF THE 
~ BIT REPRESENTATION. 

— USED IN: E24201A 
NEG_BASED_INT 8*37777777776# 

— $BIG_INT_LIT 

— AN INTEGER LITERAL WHOSE VALUE IS 298, BUT WHICH HAS 
- (SMAX IN_LEN - 3) LEADING ZEROES. 

— USED IN: C24003A 

BIG_INT_LIT OOOQOQOOQQOOOOOOOOOOOQOOOOOOOOOOOOOQOOOQOOOOOOOCOCOCCCOOOOOOOOC 
-- $BIG_REAL_LIT 

— A UNIVERSALJUEAL LITERAL WHOSE VALUE IS 6 90.0, BUT WHICH HAS 

— (SMAX IN_LEN - 5) LEADING ZEROES. 

— USED IN: C24003B C24003C 

BIG_REAL_LIT OOOOOOQOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOCOCOCOOOGCOOOOOOOOC 

— $MAX_LEN_INT_BASED_LITERAL 

— A BASED INTEGER LITERAL (USING COLONS) WHOSE VALUE IS 2:11:, HAVING 
-- (SMAX IN_LEN - 5) ZEROES BETWEEN THE FIRST COLON AND THE FIRST 1. 

— USED IN: C2A009A 

MAX_LEN_INT_BASED_LITERAL 2 : 0000000000000000000000000000000000000000000QC 

— $MAX_LEN_REAL_BASED LITERAL 

— A BASED REAL LITERAL (USING COLONS) WHOSE VALUE IS 16:F.E:, HAVING 

— ($MAX_IN LEN - 7) ZEROES BETWEEN THE FIRST COLON AND THE F. 

— USED IN:” C2A009A 

MAX_LEN_REAL_BASED_LITERAL 16:OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOCCOOOOOOGO( 

— $BLANKS 

— A SEQUENCE OF (SMAX IN LEN - 20) BLANKS. 

— USED IN: B220O1A B22ff01B B22001C B22001D B22001E B22001F 







B22001G B22001I B22001J B22001K B22001L B22001M 

B22001N 

< LIMITS OF SAMPLE SHOWN BY ANGLE BRACKETS > 

MKS < 

$MAX_DIGITS 

AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX DIGITS. 

USED IN: B35701A CD7102B 

_DIGITS 15 

$NAME 

THE NAME OF A PREDEFINED INTEGER TYPE OTHER THAN INTEGER, 
SHORT_INTEGER, OR LONG_INTEGER. 

(IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 
IDENTIFIER SUCH AS NO SUCH_TYPE_AVAILABLE.) 

USED IN: AVAT007 C452I1D B86001X C7D101G 

E NO_SUCH_TYPE_AVAILABL£ 

$FLOAT_NAME 

THE NAME OF A PREDEFINED FLOATING POINT TYPE OTHER THAN FLOAT, 
SHORT FLOAT, OR LONG_FLOAT. (IMPLEMENTATIONS WHICH HAVE NO SUCH 
TYPES SHOULD USE AN UNDEFINED IDENTIFIER SUCH AS NO_SUCH_TYPE. ) 
USED IN: AVAT013 B86001Z 
AT_NAME NO_SUCH_TYPE 

$FIXED_NAME 

THE NAME OF A PREDEFINED FIXED POINT TYPE OTHER THAN DURATION. 
(IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 
IDENTIFIER OUCH AS NO SUCH_TYPE.) 

USED IN: A7AT015 B8Z0Q 1Y~ 

ED_NAME NO_SUCH_FIXED_TYPE 

$INTEGER_FI?.ST 

AN INTEGER LITERAL, WITH SIGN, WHOSE VALUE IS INTEGER'FIRST. 

THE LITERAL MUST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 
BLANKS. 

USED IN: CJ5503F B54B01B 

’EGER_FIRST -2147483648 

SINTEGER_LAST 

AN INTEGER LITERAL WHOSE VALUE IS INTEGER'LAST. THE LITERAL MUST 
NOT INCLUDi UNDERSCORES OR LEADING OR TRAILING BLANKS. 

USED IN: C35503F C45232A B45B01B 

’EGER_LAST 2147483647 

$ INTEGER_L. ST_PLUS_1 

AN INTEGER LITERAL WHOSE VALUE IS INTEGER'LAST + 1. 

USED IN: C45232A 
’EGER_LAST_PLUS_1 2147483648 

$MIN_INT 

AN INTEGER LITERAL, WITH SIGN, WHOSE VALUE IS SYSTEM.MIN_INT. 

THE LITERAL MUST NOT CONTAIN UNDERSCORES OR LEADING OR TRAILING 
BLANKS. 

USED IN: C35503D C35503F CD7101B 
;_INT -2147483648 

$MAX INT 

AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX INT. 

THE LITERAL MUST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 
BLANKS. 

USED IN: C35503D C35503F C4A007A CD7101B 
: INT 2147483647 







— $TASK SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

— HOLD A TASK OBJECT WHICH HAS A SINGLE ENTRY WITH ONE INOUT PARAMETER. 

— USED IN: CD2A91A CD2A91B CD2A91C CD2A91D CD2A91E 

TASK_SIZE 32 

— $MIN_TASK_SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

— HOLD A TASK OBJECT WHICH HAS NO ENTRIES, NO DECLARATIONS, AND "NULL;" 

— AS THE ONLY STATEMENT IN ITS BODY. 

— USED IN: CD2A95A 
MIN_TASK_SIZE 32 

— $NAME_LIST 

— A LIST OF THE ENUMERATION LITERALS IN THE TYPE SYSTEM.NAME, SEPARATED 

— BY COMMAS. 

— USED IN: CD7003A 

NAME_LIST MV 

— $DEFAULT_SYS_NAME 

— THE VALUE OF THE CONSTANT SYSTEM.SYSTEM NAME. 

— USED IN: CD7004A CD7004C CD7004D 

DEFAULT_SYS_NAME MV 

— $NEW_SYS NAME 

— A VALUE OF THE TYPE SYSTEM.NAME, OTHER THAN $DEFAULT_SYS NAME. IF 

— THERE IS ONLY ONE VALUE OF THE TYPE, THEN USE THAT VALUE. 

— NOTE: IF THERE ARE MORE THAN TWO VALUES OF THE TYPE, THEN THE 

PERTINENT TESTS ARE TO BE RUN ONCE FOR EACH ALTERNATIVE. 

— USED IN: ED7004B1 CD7004C 

NEW_SYS_NAME MV 

— $DEFAULT_STOR_UNIT 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.STORAGE_UNIT. 

— USED IN: CD7005B ED7005D3M CD7005E 

DEFAULT_STOR_UNIT 16 

— $NEW_STOR_UNIT 

— AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 

— PRAGMA STORAGE_UNIT, OTHER THAN $DEFAULT_STOR UNIT. IF THERE 

— IS NO OTHER PERMITTED VALUE, THEN USE THE VALUE OF 

— 5SYSTEM.STQRAGE_UNIT. IF THERE IS MORE THAN ONE ALTERNATIVE, 

— THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR EACH ALTERNATIVE. 

— USED IN: ED7005C1 ED7005D1 CD7005E 

NEW_STOR_UNIT 16 

— $DEFAULT_MEM_SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MEMORY SIZE. 

— USED IN: CD7Q06B ED7006D3M CD7006E 

D EFAULT_MEM_SIZ E 536_870_912 

— $NEW_MEM SIZE 

-- AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 

— PRAGMA MEMORY SIZE, OTHER THAN 5DEFAULT MEM SIZE. IF THERE IS NO 

— OTHER VALUE, 'THEN USE $DEFAULT_MEM_SIZE. IF THERE IS MORE THAN 

— ONE ALTERNATIVE, THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR 

— EACH ALTERNATIVE. IF THE NUMBER OF PERMITTED VALUES IS LARGE, THEN 

— SEVERAL VALUES SHOULD BE USED, COVERING A WIDE RANGE OF 

— POSSIBILITIES. 

— USED IN: ED7006C1 ED7006D1 CD70Q6E 

JEW MEM SIZE 536 870 912 








— SLOW PRIORITY 

— AN INTEGER LITERAL WHOSE VALUE IS THE LOWER BOUND OF THE RANGE 

— FOR THE SUBTYPE SYSTEM.PRIORITY. 

— USED IN: CD7007C 

LOW_P RIORITY 1 

-- $HIGH PRIORITY 

— AN INTEGER LITERAL WHOSE VALUE IS THE UPPER BOUND OF THE RANGE 

— FOR THE SUBTYPE SYSTEM.PRIORITY. 

— USED IN: CD7007C 
HIGH_PRIORITY 10 

— $MANTISSA DOC 

— an INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX_MANTISSA AS SPECIFIED 

— IN THE IMPLEMENTOR’S DOCUMENTATION. 

— USED IN: CD7013B 

MANTISSA_DOC 31 

— $DELTA DOC 

— A REAL - LITERAL WHOSE VALUE IS SYSTEM.FINE_DELTA AS SPECIFIED IN THE 

— IMPLEMENTOR’S DOCUMENTATION. 

— USED IN: CD7013D 

DELTA_DOC 2.0**(-31) 

— STICK 

— A REAL LITERAL WHOSE VALUE IS SYSTEM.TICK AS SPECIFIED IN THE 

— IMPLEMENTOR’S DOCUMENTATION. 

— USED IN: CD7104B 
TICK 0.1 





APPENDIX D 


WITHDRAWN TESTS 


Some Cests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implememtation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'flZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84N & M, & CD50110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for task termination; this is 


D-l 






not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 

CD2B15C & CD7205C 

These tests expect that a ' STORAGE_SIZE length clause provides precis.e 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERR0R is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END OF LINE & END OF PAGE that have 


D-2 









no parameter: these calls were intended to specify a file, not to refer 
to STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 

CE3411B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAY0UT_ERR0R is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 

will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D-3 








APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
Loral/Rolm Mil-Spec Computers 


Compiler: ADE Revision 3.01 

ACVC Version: 1.10 


E-l 








DATA GENERAL CCRP 


CDfi R~P 


P.2 1 


i 


following compiler switches are available for DG AOS 3.01: 

/ASSEMBLY Preserves the assembly language for an Ada program 

' in a .SR file. If this switch is not given, the 

< assembly-language source may be deleted after the 

j compilation? this option is controlled by the ADE 

configuration. (For details, on ADE configuration, 
see the ADE release notice.') When the user supplies 
this switch, the Ada source code will appear as 
comments in the .SR file. Use this switch for 
machine-level debugging only . 


/AUTO INLINING*n Tells the compiler to inline any subroutine called 

" n or fewer times. For the compiler to perform 

automatic inlining on a subroutine, the subroutine 
must not be visible outside i.ts compilation unit, and 
must also pass some implementation restrictions which 
ensure the code will be duplicated no more than n 
times. Automatic inlining will not occur when the 
/NO INLINING switch is present. Do not use 
/AUTO INLINING on a source which contains 
MACHlHE_CODE subroutines which manipulate parameters, 
because - parameters are not passed on the stack to an 
. inlined subroutine. When /AUTO_INLINING*0, the 

/ . » compiler will not generate code for unreferenced 

* subroutines which pass the automatic inlining 

] t implementation restrictions. 

/CONPIGURATION»configname 

Generate code for the configuration whose source 
text statements begins "—/configname". You may give 
multiple confignames by separating them with 
underscores (for example: 

/CONFIGURATION»configl_config2_config3). 


/CPL-n 

* 


Controls listing eolumns-per-line. The value of n 
may be from 40 to 200, and includes eight columns per 
line used by the compiler. Lines that are longer than 
n columns are split so that*, indentation is preserved 
when possible. 


/DEBUG 


) * 

/ERRORS ^ 


/IDIR*dirname 


Compiles filename for use with the Ada Source Code 
Debugger. (The Ada Debugger is sold separately with 
the ADEX product and may not be available at your 
site.) NOTE: Compiling with the /DEBUG switch will 
increase the volume of generated code and decrease 
runtime performance. 

Inhibits a full listing. Puts only error messages (if 
any) in the .LST. If there are no errors, the listing 
file will be empty. 

Specifies the directory where otherwise unqualified 
input filenames may be obtained. When input pathnames 
include a directory prefix, the IDIR= switch is 
ignored. 

Names the target Ada librsry into which the source 
is to be compiled. If om.'.tted, ADE uses the current 
directory's default library. All binaries output by 
the compiler are placed in the same directory as the 


/LIBRARY-libname 




DATA GENERAL CCRP 

% 

/LPP-n 

/ MAIN__PROGRAM [ -name ] 

/NO_SYSTEM 

/NO_INLINING 

/SUPPRESS 

/TABLE 



vi ‘ Tip- 


one in which the target library reside. 

Controls listing lines-per-page, where n is an integer 
in the range 0..66. A value cf 0 disables page ejects 
and headings. Default n is 66. 

Specifies the source is a main program. If the source 
file contains more than one library unit, the 
/HAIN_PROGRAM-name keyword switch must be used. 

Prevents automatic inclusion of Ada system library in 
the library searchlist for this compile. 

Overrides /AUTO INLINING and pragma INLINE. Since 
the Ada Source Code Debugger cannot debug inlined 
subprograms, use of this svitch will help in using 
the Debugger. 

Suppresses all run-time checking in the code output by 
the compiler, including range checking and record 
variant checking. This makes your compiled program 
run faster, but also makes debugging more difficult. 

Generates information needed by the Adi Source Code 
Debugger to view information, but not set breakpoints 
nor step. You need not include this switch if the 
/DEBUG switch is specified. NOTE* This switch 
increases the generated coda size and decreases 
runtime performance, but not as much as the /DEBUG 
switch. 


