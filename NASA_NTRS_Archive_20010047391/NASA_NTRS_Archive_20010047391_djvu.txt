NASA/TM— 2001-210701 



A Comprehensive C++ Controller for a 
Magnetically Supported Vertical Rotor: 
Version 1.0 


Carlos R. Morrison 

Glenn Research Center, Cleveland, Ohio 


* 

l 


April 2001 



The NASA STI Program Office ... in Profile 


Since its founding, NASA has been dedicated to 
the advancement of aeronautics and space 
science. The NASA Scientific and Technical 
Information (STI) Program Office plays a key part 
in helping NASA maintain this important role. 

The NASA STI Program Office is operated by 
Langley Research Center, the Lead Center for 
NASA's scientific and technical information. The 
NASA STI Program Office provides access to the 
NASA STT Database, the largest collection of 
aeronautical and space science STI in the world. 
The Program Office is also NASA's institutional 
mechanism for disseminating the results of its 
research and development activities. These results 
are published by NASA in the NASA STT Report 
Series, which includes the following report types: 

• TECHNICAL PUBLICATION. Reports of 
completed research or a major significant 
phase of research that present the results of 
NASA programs and include extensive data 
or theoretical analysis. Includes compilations 
of significant scientific and technical data and 
information deemed to be of continuing 
reference value. NASA's counterpart of peer- 
reviewed formal professional papers but 

has less stringent limitations on manuscript 
length and extent of graphic presentations. 

• TECHNICAL MEMORANDUM. Scientific 
and technical findings that are preliminary or 
of specialized interest, e.g., quick release 
reports, working papers, and bibliographies 
that contain minimal annotation. Does not 
contain extensive analysis. 

• CONTRACTOR REPORT. Scientific and 
technical findings by NASA-sponsored 
contractors and grantees. 


• CONFERENCE PUBLICATION. Collected 
papers from scientific and technical 
conferences, symposia, seminars, or other 
meetings sponsored or cosponsored by 
NASA. 

• SPECIAL PUBLICATION. Scientific, 
technical, or historical information from 
NASA programs, projects, and missions, 
often concerned with subjects having 
substantial public interest. 

• TECHNICAL TRANSLATION. English- 
language translations of foreign scientific 
and technical material pertinent to NASA's 
mission. 

Specialized services that complement the STT 
Program Office's diverse offerings include 
creating custom thesauri, building customized 
data bases, organizing and publishing research 
results . . . even providing videos. 

For more information about the NASA STT 
Program Office, see the following: 

• Access the NASA STT Program Home Page 
at http:! / wwiv.sti.nasa.gov 

• E-mail your question via the Internet to 
help@sti.nasa.gov 

• Fax your question to the NASA Access 
Help Desk at 301 -h621-0134 

• Telephone the NASA Access Help Desk at 
301-621-0390 

• Write to: 

NASA Access Help Desk 
NASA Center for AeroSpace Information 
7121 Standard Drive 
Hanover, MD 21076 


NASA/TM— 2001-210701 



A Comprehensive C++ Controller for a 
Magnetically Supported Vertical Rotor: 
Version 1.0 


Carlos R. Morrison 

Glenn Research Center, Cleveland, Ohio 


National Aeronautics and 
Space Administration 


Glenn Research Center 


April 2001 



Available from 


NASA Center for Aerospace Information 
7121 Standard Drive 
Hanover, MD 21076 


National Technical Information Service 
5285 Port Royal Road 
Springfield, VA 22100 


b ap://g ltrs. g rc.Q a s^ gov/gLTKS 


Available electronically at 





CONTENTS 


SUMMARY 1 

1.0 INTRODUCTION 1 

2.0 MAGNETIC BEARING CONTROL FORCE EQUATIONS 4 

3.0 MODAL CONTROL THEORY 4 

4.0 INITIAL COMPUTER HARDWARE REQUIREMENTS 6 

5.0 INITIAL SCREEN DISPLAY PARAMETER 8 

6.0 BEARING ENERGIZING PARAMETERS 8 

7.0 LOOP BUFFER TOGGLE 8 

8.0 ASSEMBLY TOGGLE 11 

9.0 STIFFNESS AND DAMPING GAIN ADJUSTMENT 11 

10.0 OFFSET ADJUSTMENT 11 

1 1 .0 BIAS CURRENT ADJUSTMENT 11 

12.0 INTEGRAL GAIN 13 

13.0 CENTER OF GRAVITY ADJUSTMENT OPTION 13 

14.0 ROTOR EXCITATION IN STATIONARY AND ROTATING FRAMES 13 

15.0 EXCITATION FUNCTIONS AND FREQUENCY ADJUSTMENT 14 

16.0 MODAL CONTROL TOGGLE 16 

17.0 EXTERNALLY GENERATED EXCITATION SIGNAL TOGGLE 17 

1 8.0 INTERNALLY GENERATED EXCITATION SIGNAL TOGGLE 17 

19.0 SIGNAL EXPORTATION TOGGLE 17 

20.0 SAFE GAIN TOGGLE 19 

2 1 .0 LOOP TIME AND CURRENT TIME DISPLAY 19 

22.0 DISPLAY OF ROTOR DISPLACEMENT 19 

23.0 NONDIAGNOSTIC MODE DISPLAY 19 

APPENDIX A— GRAPHICAL AND MATHEMATICAL REPRESENTATIONS OF 

EXCITATION SIGNALS 20 

APPENDIX B— SOURCE CODE 23 


REFERENCES 


124 






A COMPREHENSIVE C++ CONTROLLER FOR A MAGNETICALLY 
SUPPORTED VERTICAL ROTOR: VERSION 1.0 


Carlos R. Morrison 

National Aeronautics and Space Administration 
Glenn Research Center 
Cleveland, Ohio 44135 


SUMMARY 

This manual describes the new FATMaCC (Five-Axis, Three-Magnetic-Bearing Control Code). The 
FATMaCC (pronounced “fat mak”) is a versatile control code that possesses many desirable features that were not 
available in previous in-house controllers. The ultimate goal in designing this code was to achieve full rotor levita- 
tion and control at a loop time of 50 ps. Using a 1-GHz processor, the code will control a five-axis system in either a 
decentralized or a more elegant centralized (modal control) mode at a loop time of 56 ps. In addition, it will levitate 
and control (with only minor modification to the input/output wiring) a two-axis and/or a four-axis system. Stable 
rotor levitation and control of any of the systems mentioned above are accomplished through appropriate key 
presses to modify parameters, such as stiffness, damping, and bias. A signal generation block provides 1 1 excitation 
signals. An excitation signal is then superimposed on the radial bearing x- and y-control signals, thus producing a 
resultant force vector. By modulating the signals on the bearing x- and y-axes with a cosine and a sine function, 
respectively, a radial excitation force vector is made to rotate 360° about the bearing geometric center. The rotation 
of the force vector is achieved manually by using key press or automatically by engaging the “one-per-re volution” 
feature. Rotor rigid body modes can be excited by using the excitation module. Depending on the polarities of the 
excitation signal in each radial bearing, the bounce or tilt mode will be excited. 


1.0 INTRODUCTION 

For the past 14 years, the NASA Glenn Research Center has been actively involved in the development of mag- 
netic bearings. Most of these dynamic suspension systems support a rotor in a two-axis or four-axis configuration. 
One of these two-axis systems, the Dynamic Spin Rig (DSR), supports a vertical rotor by employing a ball bearing 
at the upper end and a radial magnetic bearing at the lower end. The DSR is used primarily for vibration testing of 
turbomachinery blades and components under a spinning condition in a vacuum. The ball bearing imposes limita- 
tions, such as frictional heating, on the rotational speeds (less than 18 000 rpm) of the rotor. 

By the late 1990's, the previous technologies had set the stage for the development of the Five- Axis, Three- 
Magnetic-Bearing Dynamic Spin Rig. The motivation for developing this type of bearing system was to achieve 
higher rotational speeds (25 000 to 60 000 rpm) in the spin rig for use in high-cycle-fatigue research projects per- 
taining to damping and mistuning for bladed disks. 

The Five- Axis, Three-Magnetic-Bearing Dynamic Spin Rig consists of three magnetic bearings; a thrust bear- 
ing/a radial upper bearing, and a radial lower bearing. Figure 1 shows the actual shaft or rotor; figure 2, the rotor 
being held for size comparison; figure 3, the top portion of the rotor where the thrust bearing is affixed; figure 4, the 
thrust plate and the thrust coils; and figure 5, the upper and lower radial stators. 

A control code written in C++ was designed for this magnetic bearing configuration. A 100-MHz processor PC, 
capable of running the code at a sampled average loop time of 100 ps, can simultaneously control all three magnetic 
bearings in a centralized (modal control) or decentralized mode. When the code’s executable file is launched and all 
the input parameters are correctly set, the bearings will levitate a vertical, solid, cylindrical shaft. The energized 
bearings are capable of lifting and shaking a rotor and test article that have a combined weight of 400 lb. 

The 23 sections of this manual and appendix A will help the user to correctly set up and run the code. 

Appendix B lists the source code cited in the manual. 


NASA/TM — 200 1-210701 


1 






Figure 1 . — Rotor without stator assembly. Figure 2. — Rotor juxtaposition for size com- 

parison. 



Figure 3.— Top view of rotor without thrust bearing assembly. 


NASA/TM— 2001-210701 


2 



Figure 5. — Upper and lower radial stators. 


NASA/TM — 2001-210701 


3 







2.0 MAGNETIC BEARING CONTROL FORCE EQUATIONS 


From reference 1 , it can be shown that the net controlling force (due to an opposing pair of identical electro- 
magnets) acting on the rotor has the form 


F - 




( 1 ) 


where 

z= PoA^4 

4 


( 2 ) 


and i { and i 2 are the currents in the opposing coils; x gl and x 2 are the gap distances between the rotor and each 
opposing pole face; is the permeability of free space; N is the number of coil turns; and A is the pole face area. 

The squared terms in equation (1) are undesirable from a control standpoint and are thus eliminated by using a 
linearizing technique that incorporates a bias current and a control current. By replacing ^ and i 2 in equation (1) 
with (i b + i c ) and (i b - i* c ), respectively, and x gl and x g2 with (* 0 - x) and (x 0 + *), respectively, the force equation 
becomes 


F = 


j^b + *c ) _ [}b jc _ )_ 

{XQ-Xf (* 0 + xf 


(3) 


where i b is the bias current, i c is the control current, x Q is the nominal gap, and x is the deviation from the nominal 
value. 

After making the appropriate algebraic manipulation and taking the requisite partial derivatives, the force, cur- 
rent, and position are shown to have the linear relationship 

F n =K x x+Kji (4) 

where K x is the position stiffness and K i the current stiffness. For proportional-derivative (PD) feedback control 
when an excitation signal is used, i is replaced by -(K^x + K d x) + i where K p and K d are the proportional control 
gain and derivative control gain, respectively, and i ex is the excitation current variable. Equation (4) thus becomes 

F ex = m eq x + K t K d x + [KjKp - K x ^x (5) 

where m eq is the rigid rotor equivalent mass and F €X = Further algebraic simplification produces an expression 
of the form 


F ex - m eq x + c eq x + k eq x (6) 

The control force equations used in the code have a form similar to this expression, and the offset and the bias 
current parameters make it possible for an operator to adjust the position and current stiffness, respectively, of the 
bearings. 


3.0 MODAL CONTROL THEORY 

Most methods of multimagnetic bearing control rely on independently levitating each end of the rotor. How- 
ever, modal control is more sophisticated and elegant because it is accomplished by coupling the sensor signals 


NAS A/TM— 2001 -2 1070 1 


4 



Thrust 

coils 


1^1 


Upper ./ |XH 
bearing 


r 1 + '2 


Lower 

bearing 


'El 


PVvM 


Shaft 


1S1 

Thrust 
plate 


e 


Coil 


Center of gravity 


Coil 


EK 


Figure 6. — Five-axis ensemble (not to scale). 



Figure 7.— Free-body diagram for modal control 
mathematical derivation. 


extant at the upper and lower bearings and then using that information to control each bearing. In other words, the 
rigid rotor motion information (as opposed to the independent motions at the bearings) is used to control the radial 
bearings. 

The rotor and bearings are depicted schematically in figure 6 where the magnetic restoring forces are repre- 
sented by springs. For the vertically oriented axis, gravity does not affect the radial degrees of freedom (see fig. 7 for 
the free-body diagram of the shaft motion). The motion of the center of mass (c.m.) (ref. 2) in the *,;;-plane is thus 
given by Newton’s second law as 


mx = ky (x av - >10) - k 2 (x av + r 2 0) - - c 2 x 2 (7) 

mix = -(*, + k 2 )x av - ( k 2 r 2 - k x r x )0 - (ci + c 2 )x m , - ( c 2 r 2 - c x r x )0 (8) 

where, for the lower bearing, = k ^ and for the upper bearing, k 2 = k eq 2 ; x av is the average displacement of the 
center of gravity; r { and r 2 are the distances from the ends of the shaft to_the center of gravity; 0 is the tilt angle; c { 
and c 2 are damping constants, where c { = c eql and c 2 = T 

The equations relating to shaft centerline tilt displacement in the x,z-plane are 

k® = k l ( x av - 'i 0 ) r l - k 2 ( x av + r 2 0 ) r 2 ( 9 ) 

/ G 0 = (k x r x - k 2 r 2 )x m , - {k 2 r% + V 2 ) 0 (l 0 ) 

where I G is the moment of inertia about the center of gravity. 

From equations (8) and (10), it is seen that the centralized force equations have the form 

Force (center of mass translation) = -(fcj 4- k 2 )x av - (q + C 2 )xav (1 1) 

Force (rotation) = -{k 2 r 2 + r \ “ ( c 2 r 2 + q q 2 (12) 


NASA/TM — 200 1-210701 


5 




Hence, the total centralized force is given by 


Force (total) = force (center of mass translation) + force (rotation) (13) 

Similar equations apply in the >\z-plane. Equation ( 1 3) was used in the code (source code lines 1 887-1 89 1 ; 

1907-191 1; and 1915-1925). 


4.0 INITIAL COMPUTER HARDWARE REQUIREMENTS 

This code was designed to run in the pure DOS mode on any Pentium-class PC having a processor speed of 
100 MHz or higher. Robust control at all operating speeds requires a loop time of 100 ps or less. Higher processor 
speeds, in most instances, trend towards a shorter loop time. A shorter loop time can provide more stable control of 
the rig at higher rotor speeds. Figure 8 shows the Datel A/D input and Metrabyte D/A output boards as they appear 
in the back of the central processing unit. The ribbon cables are attached to the output boards and the coaxial cables 
are connected to the input boards. These boards should be installed in ISA expansion slots (source code lines 86-122 
for the input board initial setup and lines 126-158 for the output board initial setup). The channels of the output 
boards are as indicated in source code lines 136-141 and 153-158, and the channels of the input boards are specified 
in lines 67CU682. There should be 8 input (fig. 8) and T2 output channels (fig. 9). Eleven of the twelve output chan- 
nels (the zero channel on the upper bearing output box is not used) are actually employed in this rig. The monitor 
should be an SVGA or better for the best text display. Figure 10 shows the operations center of the five-axis rig. 



Figure 8. — input and output board configuration in 
central processing unit. 


NASA/TM — 200 1-210701 


6 




Figure 9. — Twelve-channel output box from central processing unit. 



Figure 10. — Operations center for Five-Axis, Three- 
Magnetic-Bearing Dynamic Spin Rig. 


NAS A/TM — 200 1-21 070 1 


7 



5.0 INITIAL SCREEN DISPLAY PARAMETER 


When the file “FiveAx.exe” is launched, “DIAGNOSTIC (y/n)?:” appears on the screen along with a logo of 
the test facility (fig. 1 1). If y is selected, the screen changes to the diagnostic mode (fig. 12). If n is selected, the 
screen changes to the nondiagnostic mode (fig. 13). The diagnostic mode allows one to make critical adjustments to 
the rig parameters before and/or during levitation. After setting these parameters, the nondiagnostic display may be 
toggled. The values of the parameters are preserved on transitioning to the nondiagnostic mode and the screen will 
be minimally congested. As a rule, always toggle the diagnostic mode first. If the nondiagnostic mode is initially 
toggled, the default values of critical parameters may not be appropriate for a stable levitation of the rotor. 


6.0 BEARING ENERGIZING PARAMETERS 

If the diagnostic mode is initially selected, the status indicators for the thrust, upper, and lower bearings show 
that they are not energized (fig. 12). The on/off toggle letters H, I, J (listed below the heading “Energizing Parmtr”) 
are also blinking. The blinking letters are an aid to quickly identifying the appropriate bearing toggle letter. Energize 
the bearings, beginning with the thrust bearing, and then energize the upper and then the lower bearing using the on/ 
off toggle letters H, I, and J. The status indicators of the bearings change to red, and the on/off toggle letters no 
longer blink (fig. 14). The rotor should be in levitation at this point, provided that the gains are correct (see sec. 9.0). 


7.0 LOOP BUFFER TOGGLE 

The “Loop buffer” is a series of dummy mathematical statements (source code lines 1513-1518; 1864-1869; 
and 2663-2666) that automatically activate when one or two of the bearings are deactivated. Its sole purpose is to 
maintain the loop time of the code, irrespective of the state of the energizing parameters. If loop buffering were not 
done, the controlling characteristics of the code would change as each bearing is toggled on or off. The code 


T file : 


t |«£- 

SEAR IMS r fit- i L I i t 


C-00-1596 


Figure 1 1 —Initial screen display. 


NAS A/TM— 200 1 -2 1 070 1 


8 




:> ’tj select excitation 
<R> to toggle Bounce/Tilt 
■„:> to toggle O.P.R. dirction 
<(> to toggle ext. input. exction 
<8,*>avrg freq update adjst 


[file : FiueAx.c ] 

* Thrst bearing not energized ! 

* Upper bearing not energized ! 
» Lower bearing not energized ! 

==> LOWER BEARING <= 


Display Parameter 

t THE HA6NETIC ] <c)CG factor: 0.00 ================= 

[BEARING SYSTEN IS] [ loop time: 70. Z7 micro-sec ] <l>Louer Bearing 

[ ] Time: 10:31:55 AN <u>Upper Bearing 

I Y_AXIS <N>-test: 0_ X_AXIS <z>Thrst Bearing 

I 

ku bot<p> : l 30 kb_bot<g> : Z.30 Energizing Parmtr 

[<r>QHE_PR_REU ] d«_hot<u> : 15 00 dh_bot<d> : Is, 00 ================= 

[Lwr Safe Gain ON ] =================== ================== <H>Thrst Bearing 

[Upr Safe Gain ON ] [Loop buffer ON ] <I>Upper Bearing 

[Tht Safe Gain ON ] offset_bot<t> : -Z0 <J>Louer Bearing 

[<m>H0DAL CTRL ] offset_bot<w> : -Z0 

[< >EXCITATION ] bias current_hoUb> : 1.00 Amp. 

< >Frg_lnpt: -8.0 Hz. Force (H) xjralue y.ualue 


{Excitation Parmtr) 

< >1/FL: 1.808 [<*> to toggle D A. ] 

<a>A«piitude: 0.8 w 0-pk [<,) Enable exction.] ♦ - + 

(sito adjust Pulse Width 11*) Assembly ON ] X X Y Y c*00 _ 1823 


Figure 12. — Initial diagnostic mode screen display. 


<x/k> to adjust frequency [ f j| e ; FiueAx.c 1 

<b> to toggle Bounce/Tilt DIAGNOSTIC T0€€LE<E> 

w to toggle ext . input .exction 
<i ( *>avrg freq update adjst 

r ™ Anti elkwse 

=-> <=- 

t THE HAGHETIC ] 

[BEARING SYSTEM IS] I loop tine: 76,13 micro-sec j 

[ ] Time; 11:12:83 AH 


==> <=- 
[<r>0WE FJLREU 0 N I ==> <== 

CLwr Sare Gain OH ] «> <“ 

[Upr Safe Gain OH J 

[Tht Safe Gain OH 3 

[MODAL CNTRL 3 

[<-1 EXCITATION ON 3 CENTER 

< >FrqJnpt: Z68.0B Hz. 
fl: 8.1331a 6.0, 15 DA. 


< >1/PL : 7.139 £<"> to toggle DA. ] 
<i>A«plitude; 1.8 u 0-pk f<,> Enable exction. 3 
<s>to adjust False Width EO> Assembly OH 3 


Figure 13. — Nondiagnostic screen display. 


C-OO-1 606 


NASA/TM— 2001-210701 


9 






<♦,-> to toggle input-output writes 

[file : FiueAx.c ] 


<q> to abort control 




<f> to toggle loop tine buffer 




<e> non diagnostic 





<!,M> disable safe gain --> 

LOWER 

BEARING 



O.P.R. Anti elkwse 





==> BOUNCE HOPE <== 


Display Parameter 


[ THE MAGNETIC ] 

<C>CG factor: 0.00 




[BEARING SYSTEH IS] 

C loop time: 71,88 micro-sec 

j 

<!>Loyer Beariiig 


[ ] 

Tine ; 18:29:21 AH 


<u>Upper Bearing 


1 

1 

if .AXIS <H>-test : 1 X-AXIS 


<Z>Thrst Bearing 


t 

ku hot<p> ‘ Z > 38 kh hot<g> 

2. JO 

Energizing Fsritr 


<0>ph! ANG: 0 deg 

du boi<v> : 15.00 dh hot<d> : 

I5.UU 



[Lunr Safe Gain ON 3 

-“========-=- — == ============== 


<H>Thrst Bearing 1 


[Hpr Safe Gain OH ] 

tLoop buffer OH 3 


<I)Upper Bearing 1 


[Tht Safe Gain OH 3 

oil se ■■ t 


<J>Lower Bearn;; 1 


[<a>M0B0L CTRL 3 

Qi i SCX j)‘jT fU? 

r *" 



[SINE QH 3 

1) 1 £ H IJi! I’ f r H L i/U i. % ? 

T TTTE 



<k>Frg_inpU 288.0 

Hz. Force (N) x.value 

y value I 


PL: 8 . 1328 





<Exc itat ron Parmir) 

x: 3.9Su Bispiacement: B.lv 

-e.bu 


<o>l/PL: 7.578 

y: 3.8§u -U.lv, 

-I.Bv, 

-8.8v, 3.3v J 


<a>fi»pntude: 1.8 u 

0-pk U,> Enable exction.i + 

- 

+ 1 


<?>f_excite-^ 

[<:> Assembly OH j X 

X 

V 1 

1(a) 




C-QQ-1813 | 


(b) 


vHJ> to select excitation l file •' Five Ax. c ] 

<B> to toggle Bounce/Tilt 
<F> to toggle Q.P.R. dirction 
«> to toggle ext . inpirt~.cxcfIoir 

<l,*>avrg freq update aSjst ==> UPPER BEARING < 

O.P.E, Anti cl Ruse 

==> BOUNCE NODE <== Bisplay Parameter 

t THE MAGNETIC ] <OCG factor: U.Uti — = == == 

[BEARING SYSTEM IS! E loop t iac : 73.87 wtcro=see ] <l>Lower Bearing 

I 1 Tine: 10:3G:Z5 AM <u>Upper Bearing 

I Y_AXIS <M>-test: 1_ X.AXIS <z>Thrst Bearing 

t 

I 

kv top<p> 150 Kh top<g> 1.50 Energizing Farmtr 

[<r>0H£_FR.REU 3 do topes} : 5.00 dh_top<d> : H.m =============== 

CLwr Safe 6a in OH 3 ================= =================== <H>Thrst Bearing 

CUpr Safe Gain OH 3 [Loop buffer OH 3 <I>Upper Bearing 

[Tht Safe Gain OH 3 offset_top<t> : ~2B <J>Lowcr Bearing 

t<ffl>HODAl CTRL 3 offset toB<M> : -ZB 

[SINE ON 1 bi as current_top<b> : l.ttU hrp. 

< >Prq_inpt: Z00.8 Hz. Force (N) x_ualue y.value 

PL: 8 . 1326 
(Excitation Parmtr) 

<o>lzPL: 7.578 

<a>ANpiliude:4.B v 0-pk [<,> Enable exctlon.l ♦-*- 
<s>to adjust Pulse Width [<:> Assembly ON ] X X Y Y COO 1816 1 


Figure 14. — Diagnostic mode screen displays for upper and lower bearings, (a) Lower bearing, (b) Upper 
bearing. 


NAS A/TM— 2001-210701 


10 




executes successively faster as each bearing in turn is de-energized. The variation in the controlling characteristic is 
undesirable if diagnostic tests are to be performed during the levitation of one or two bearings. The changes in the 
control characteristic are due, in large part, to the action of the derivative terms present in the force equations 
(source code lines 1181-1186 and 1325-1327; 1333-1338 and 1477-1479; 1532-1537 and 1676-1678; 

1684-1689 and 1828-1830; 2481-2487 and 2626-2628). Note that the loop buffer defaults ON. 


8.0 ASSEMBLY TOGGLE 

The goal in designing this code was to achieve full rotor levitation and control with a minimum loop time of 
50 |is. The loop time of 68 [is was attained on a 533-MHz PC and was further reduced to 65 jas by coding the input/ 
output statements of the boards in assembly language. The actual percentage improvement from using assembly 
vis-^-vis C++, however, will depend on the type of processor employed in running the code. One tends to see pro- 
gressively less benefit as the processor speed increases. The fastest Pentium-class machines (1 GHz and higher, 
where the minimum loop time observed was 56 |is) showed marginal to no improvement with the code running in 
the assembly mode. The greatest percentage improvement was achieved with a 486 machine on which a 13-jis loop 
time reduction was observed using assembly statements, albeit, the minimum loop time was more than 400 [is. It 
should be noted that the assembly mode is the default stale of the code. Press the Shift and : keys to toggle the 
assembly mode; see display “[oAssembly ON].” 


9.0 STIFFNESS AND DAMPING GAIN ADJUSTMENT 

The default values for the stiffness (proportional control gain) and damping (derivative control gain) may not be 
appropriate for stable levitation (source code lines 1 185, 1336, 1536, 1688, and 2486). Hence, these values may 
have to be adjusted until the rotor position, as observed on the oscilloscopes and/or on the spectrum analyzer, is 
within the safe zone area and is well damped. Note that the lower bearing parameters are initially displayed (fig. 12). 
Press the p and g keys to increase the stiffness values along the y- and ar-axes respectively, and press the v and d 
keys to increase the damping values along they- and .v-axes, respectively. Decrease the stiffness/damping values by 
depressing the Shift key while simultaneously pressing said keys. If necessary, select the upper bearing display by 
pressing the u key and repeat the procedure just described. Press the z key to display the thrust bearing parameters. 
Make any necessary adjustment to the thrust bearing parameter values. The menu for selecting each bearing param- 
eter display is listed under the header “Display Parameter.” Each bearing display toggle letter blinks after its 
selection. 


10.0 OFFSET ADJUSTMENT 

The equilibrium position of the rotor is adjusted by varying the offset parameters “offset_bot<t>” and 
“offset_bot<w>” (fig. 14(a)); “offset_top<t>” and “offset_top<w>” (fig. 14(b)); and “offset_th<t>” (fig. 15). If the 
lower bearing parameters are initially displayed, press the t and w keys to increase the offset values along the bear- 
ing x- and y-axes, respectively. Decrease the offset values of the bearing by depressing the Shift key while simulta- 
neously pressing said keys. Repeat this procedure for the upper and thrust bearings. There is no u offset_th<w>” 
parameter for the thrust bearing as it has only one axis of motion (i.e., its direction is along the ±z, or axial, axis). 
Pressing these keys will incrementally move the rotor along the .v-, y-, and z-axes. Adjust the position of the rotor 
until it is in the center of each bearing (as observed on the oscilloscopes in fig. 16). 


1 1 .0 BIAS CURRENT ADJUSTMENT 

For the Five-Axis, Three-Magnetic-Bearing DSR, the bias current should be kept at its default value of 1.0 A 
for the lower and upper bearings (figs. 14(a) and (b)) and at 1.5 A for the thrust bearing (fig. 15). If needed, press the 
b key to increase the bias current value. Decrease the bias current by depressing the Shift key while simultaneously 
pressing the b key (source code lines 1187, 1 188, 1538, 1539, 2488, and 2489). 


NASA/TM — 200 1-21 070 1 


11 


f file : FiueAx.c J 


<♦,-> to toggle input-output writes 
<q> to abort control 
<f> to toggle loop tile buffer 
<e> non diagnostic 

disable safe gain --> THRUST BEARING < - 

O.P.H. Anti clkwse 


"> BOUNCE NODE <== Display Parameter 

l THE MAGNETIC ] <(, )>igainth: B.080Z ============= 

[BEARING STSTEN IS! t loop tine: 71.67 micro-sec 1 (JHouer Bearing 


[ 3 Time; 10:38:10 AM <u>Upper Bearing 

I Z.AXIS <M>-test: 1_ <z>Thrst Bearing 

I 

ku_th<p> : 1.50 Energizing Farmtr 

<n>PHSE ANG: 45 deg de th<u> : 9. OB ============== 

[Lur Safe Gain ON 3 ================== <H>Thrst Bearing 

[Upr Safe Gain ON 3 Eloop buffer ON 3 <I>Upper Bearing 


ETbt Safe Gain ON 3 offset th<t > -20 <J>Loucr Bearing 

[<»>H0DAL CTRL 3 

[SINE ON 3 bias current th<b> : l.bO Ha 

<k>Frq_lnpt: Z88.B Hz. Force (N) z„ value 

FL: 8.1328 

(Excitation Panatr> 

<o>l/PL: 7.578 

^Amplitude: 1.8 v 0-pk [<,> Enable exction.l * 

<?)f_excite : t<:> Assembly ON 3 Z Z 


Figure 15. — Diagnostic mode screen display for thrust bearing. 



NAS A/TM— 200 1 -2 1 070 1 


12 





12.0 INTEGRAL GAIN 


When the thrust bearing display is toggled (fig. 15), the parameter “<c>CG factor:” display (figs. 14(a) and (b) 
under the “BOUNCE MODE”) is replaced with the “<(,)>igainth:” parameter. This parameter enables adjustment of 
the integral gain term present in the thrust bearing force equation (source code lines 2482 and 2486). If there is an 
axial offset of the rotor (i.e., ±z about the zero probe position), the integral gain term has the effect of automatically 
restoring the thrust plate to its zero probe or equilibrium position. A higher value of the integral gain will result in a 
quicker restoration to the equilibrium position. Press the ( key to decrease the igainth value or press the ) key to 
increase the igainth value. 


1 3.0 CENTER OF GRAVITY ADJUSTMENT OPTION 

The rotor has a relatively massive thrust plate affixed to its top end. Attaching a massive test article to the rotor 
effectively shifts its c.m. towards the test article. Consequently, the c.m. of the rotor is not generally at its geometric 
center. Because this shift in the c.m. can adversely affect the stability of the rotor, it must be taken into account, 
especially in the centralized (modal) control mode. Press the 1 key to display the screen depicted in figure 14(a) and 
then press the c key to effect appropriate weighting of the outputs to the upper and lower bearings. The “<c>CG 
factor:” parameter has a default value of 0.00 and can vary between -0.5 and +0.5. Values above zero correspond to 
a c.m. closer to the upper bearing, and values below zero correspond to a c.m. closer to the lower bearing. The bear- 
ing closer to the c.m. should exert a greater force than the bearing farther from the c.m. Adjust the “<e>CG factor:” 
based on either an experimental measurement or a finite-element analysis to determine its position. See source code 
lines 1 185 and 1536 where MCG and PCG, respectively, arc the “<c>CG factor:” variables. 


14.0 ROTOR EXCITATION IN STATIONARY AND ROTATING FRAMES 

The code is designed to apply excitation signals concurrently to the upper and lower bearings. At each bearing, 
excitation signals are applied simultaneously to the x- and y-axes. This simultaneous excitation produces a resultant 
force vector with a magnitude and an angular orientation. The direction of this force vector can be fixed in a 
nonrotating frame of reference by setting the desired phase angle (“<n>PHSE ANG:” in fig. 15). The force vector 
can also be made to rotate with the test article by engaging the “[<r>ONE„PR_REV]” logic block (fig. 14(b) and 
source code lines 1 082-1 1 1 7). This block of code makes it possible to synchronize a rotating force vector with the 
rotation of the shaft. A tiny mirror attached to the shaft reflects a pulse of laser light once every rotation of the shaft. 
A sensor then converts the light pulses to electrical pulses. These pulses are sent to an input channel on a Datel 
board where they are used to trigger the “[<r>ONE_PR_REV]” logic block (the “[<r>ONE_PR_REV]” signal is 
applied to channel 2 on the Datel input board at address 0x366). The logic block calculates the angular rotation of 
the shaft during one loop time of the code (source code line 1094) based on the number of loops between successive 
pulses. The shaft angular rotation per loop is henceforth used to drive the angular rotation of an excitation force vec- 
tor in synchrony with the rotating shaft (source code line 1048). The rotating force vector can be made to excite at a 
specified angle (“<{ }>phi ANG:” in fig. 14(a)) vis-^-vis the long axis of the test article. The phi angle ranges from 
0° to 360°. In addition, the direction of rotation of the force vector can be toggled. 

Manual adjustment of the phase angle “<n>PHSE ANG:” in figure 15 (in increments of 5°) is accomplished 
by pressing the n key to increase the angle in the “Anti elkwse” (anticlockwise) direction or by depressing the 
Shift key while simultaneously pressing said key to decrease the angle. The “<{ }>phi ANG:” angle in 
figure 14(a) is increased (in increments of 5°) by pressing the J key and is decreased by pressing the { key. The 
“[<r>ONE_PR_REV]” logic (fig. 14(b)) is toggled on or off by pressing the r key. Toggle the rotation direction of 
the force vector by depressing the Shift key while pressing the f key. 

A shaft can be excited in many modes, two common ones being the bounce and tilt. These two modes were 
implemented in FATMaCC. If the “[<r>ONE_PR_REV]” is engaged, the bounce mode describes a motion that, if 
the ends of the shaft were traced, approximates a vertical cylinder. In the tilt mode, the excitation force vector in the 
top bearing is 180° out of phase with the excitation in the lower bearing. Consequently, the shaft centerline traces 
out a conical surface. Figure 16 shows the paths of the shaft in the bounce or tilt mode and the position of the thrust 
bearing. In these displays, the “[<r>ONE_PR_REV]” is turned off and the shaft is being excited at a phase angle 


NAS A/TM— 2001-210701 


13 



I HFU i 

ZBVtHz B*s*Bn4 

nc «c oc 
leu lev i0u 
0 0 0 

TRIGGER 

orr 


►C>>=2/1 XY 
r i 

♦ . 05 *-M : 

► XI 


AVERAGING 11122“: 

HoRej^ct 234344 

cn t= 32 ««*»*• 

WINDOWING 
Hanning /* Nor«^l 


channel 2 /'ch*rm*l 1 MOD ES 


c)l*nn#l 4 /channe! 3 


-Z . ZGOOl 1 t = 
-2 * V7UU4 1 «« 


frAnr - 1 024 HonOv*rlF 

flutoRna-Off Non -0p.^f 

PI SPLAY 

Double LINh Hz 
Cursor: Noth*! I -Cur* 


*w to .set 
ha t h 
I0JUN97 . D«t 


OUTPUT 

Sine 

30 Hz 

Offset: 


« 

Kh:V3 cam 

inp ► ^ 

t : bs • 

" 5 1 iw -t S he don* in 
BSMOriuto S96C tra 
Cfj»rc“cro*s sjwct^a 


' 2 4 2050 0 1 t 5 
* 2 V 9 8 SMol is 


Off 

AW 

0 Fil ton 


0 19.980^h 

sh«rinr I ^/clsann*! 3 


RUN ENABLE CONFIG 
Off Off «**" 


Xf« p - transfer fium correi»t>o 

Coh =eo hffpnr p — f unc Ccef^cross cerreian^ 
Imp -Input c© r«*p. X-Y ropfci t/Iifl*D 9 »* 


C-00-1824 


Figure 17. — Tektronix x,y-screen display of upper and lower bearing rotor displacement. 


(“<n>PHSE AN G:”) of 45°. Figure 17 is the Tektronix x,y-display of the upper and lower bearing rotor displace- 
ment. The tilt/bounce mode is toggled by depressing the Shift key while simultaneously pressing the r key. 


1 5.0 EXCITATION FUNCTIONS AND FREQUENCY ADJUSTMENT 

The heart of the excitation-generating scheme is the sine and cosine functions. The signal block (source code 
lines 744-986) is designed to produce a periodic signal whose period is proportional to a nondimensional parameter 
PL, or period length (appendix A). If PL is identically 1 .0, the period is equal to the time to perform 500 loops in 
the code. A loop time of 50 jis yields an excitation frequency of 40 Hz, which is approximated by 500 steps in the 
output signal. The steps or discreteness is evident in the sine curve depicted in figure 18 where the frequency is 
200.6 Hz. Other frequencies are obtained by choosing PL in inverse proportion to the desired frequency. Each loop 
increments the ,v-value of the function argument by 1 .0/500, or 0.002 (source code lines 813, 840, 868, 896, 925, 

953, and 983). 

For experiments requiring excitation signals, 1 1 functions are available: sine, sine squared, cosine, cosine 
squared, random, square pulse train, square wave, triangular wave, square pulse, triangular pulse, or saw tooth 
(source code lines 744-986). Select the desired function “[< >Excitation ON]”by pressing the number keys [4, 5, 6, 7, 
8,9, or 01. Pressing the number 4 key initially engages the trigonometric block and brings up the “sine" function in 
an off state. Continually pressing the 4 key cycles through sine squared, cosine, cosine squared, random (fig. 19) and 
back to sine (fig. 1 8). To toggle this function block on or off, depress the Shift key and simultaneously press the 4 
key. Key 5 selects the “square pulse train,” 6 selects the “square wave,” 7 selects the “triangular wave,” 8 selects the 
“square pulse,” 9 selects the “triangular pulse,” and 0 selects the “saw tooth wave.” See appendix A for an analytical 
presentation of these functions. 

Selecting the 8 key automatically activates the pulse width toggle flag. Pressing the s key decreases the pulse 
width (fig. 12) and depressing the Shift key while simultaneously pressing the s key increases the pulse width. Func- 
tions 5 to 9 and 0 are each toggled off by pressing the respective key. 


NASA/TM— 2001-210701 


14 





Figure 18. — Hewlett Packard digital scope display of sine curve excitation signal. 



Figure 19. — Hewlett Packard digital scope display of random curve excitation signal. 


NAS A/TM— 200 1-210701 


15 






Input the desired frequency in 10-Hz increments by pressing the x key. Press the k key to make fine adjustments 
in 0.1 -Hz increments (see fig. 12 display “<x>Frq_inpt:”). The specified frequency is used (in conjunction with the 
loop time determined from the DOS clock) to generate the signal frequency via the aforementioned functions 
(source code lines 2859 and 2878). Because the DOS clock is coarse, it tends to cause undesirable variation in the 
signal frequency. Thus, an averaging method called “dynamic averaging” (D.A.) is employed to improve the stabil- 
ity of the signal frequency. During D.A., the loop time (as measured against the BOS clock) is averaged continu- 
ously over 1 5 successive loop time updates (see sec. 2 1 .0 for the rate of loop "time updating). The resulting averaged 
value is then used in generating the signal frequency. D.A. is automatically engaged when a frequency is inputted 
using the x or k key. The D.A. displayed at the end of the period length (PL) field is confirmation of this (fig. 13). 

For D.A., refer to source code lines 2847-2869. 

The second option, which may be toggled at any time, is called “intermittent averaging” (I.A.). This method is 
somewhat less effective on slower processors (those with clock speeds below 533 MHz) in smoothing out the DOS 
clock variations discussed earlier. The averaging mechanism employed herein requires that the user set the update 
count limit (UCL). When a value greater than 15 is entered, the code will recalculate the signal frequency at a peri- 
odic rate determined by the expression [(UCL - 15) + 15]. This periodicity tends to make the signal frequency 
change abruptly at each successive update because of slight variations in the averaged loop time values. On the fast- 
est processor (1 GHz and above with an improved DOS clock), this presents less a problem. Whenever a frequency 
is entered while the code is in the D.A or LA. mode, the “o” in the parameter “<o>l/PL:” turns red and blinks for 
the duration of 15 counts. During the red blinking phase, no experimental measurements should be taken as the code 
is still averaging the loop time. After 15 counts, the “o” turns green and stops blinking. Measurements should re- 
sume at this point. 

What distinguishes D.A. from I. A. is that in the D.A. mode, the loop time is averaged continuously, producing a 
relatively smooth and stable signal. On the other hand, in the I. A. mode, the averaged loop time value remains con- 
stant between each update, resulting in a minor discontinuity at the instant of the update. The number 15 in the pre- 
ceeding expression is the maximum number of DOS-clock-determined loop times that were averaged. UCL is 
adjusted upwards by the * key or downwards by the & key. This adjustment is only possible when the intermittent 
averaging option is toggled. For LA., refer to source code lines 2873-2898. 

The third option for generating a signal frequency is called the “standard method” (SM). This method produces 
the most stable signal frequency because the O - value (source code lines 3736-3755) is calculated directly. The two 
previously discussed methods determined the 0-value by averaging the loop time. The drawback with the standard 
method is that the signal frequency is obtained by changing the PL in increments of 0.002. This discreteness makes 
it impossible at times to obtain a desired frequency. In the previous methods, the exact frequency can be specified 
and the computer then determines the 0-value. Pressing the o key increases the frequency and depressing the Shift 
key while simultaneously pressing the o key decreases the frequency. The approximate frequency is displayed under 
the header “<Excitation Parmtrx” Use a digital oscilloscope for a more accurate measure of the output frequency. 
Connect the oscilloscope to the signal output connector (“SIGNAL GEN”) located on the test rig control panel 
(fig. 16, lower bearing output panel). 

After selecting a desired frequency, increase the signal amplitude by pressing the a key or decrease the signal 
amplitude by depressing the Shift key while simultaneously pressing the a key. The maximum amplitude available 
is 5 V, (0 to peak). The next step is to output the signal to the magnetic bearings, which is accomplished by pressing 
the , key. Observe the “[<,> Enable exetion.]” display at the bottom of the screen (fig. 14(a)). 


16.0 MODAL CONTROL TOGGLE 

After correctly setting all the critical parameters discussed in sections 6.0 to 15.0, engage the modal control by 
toggling the m key (see fig. 20 for the corresponding screen display). The transition to modal control is seamless and 
without any noticeable changes in the levitation of the rotor. Modal control may also be toggled in the nondiagnostic 
display mode. Make any necessary fine adjustments to the “<c>CG factor:.” 


NAS A/TM— 2001-210701 


16 



<♦,-> to toggle input-output writes 

[ file : FlueAx.c ] 

<q> to abort control 



<f> to toggle loop tine buffer 


<e> non diagnostic 



<!,9,»> disable safe gain 

==> MODAL CONTROLLER <== 

O.P.R. 

Anti clbwse 



==> BQUhCE flODE <-= 

Display Parameter 

[ TOE MAGNETIC ] 

<c>C6 factor: Q.Q0 


[BEARING SYSTEM IS] 

[ loop time: 77,68 micro-sec ] 

<l)Lower Bearing 

[ ] 

Time: 18:33:18 AM 

ODHpper Bearing 

1 

1 

l 

Y.AXIS < ID-test: 1 X.AXIS 

<Z>Thrst Bearing 

Milt 

: 0.75 

Energizing Famtr 

<n>PHSE 0NG: 15 deg c_t i It 

: 1,50 

=====r ==== == ==ss - 

[Lur Safe Gain Oh I 


<H>Thrst Bearing 

[Upr Sare Gain ON ] 

[Loop buffer ON ] 

<!>Uppnr Bearing 

[Tht Safe Gain ON ] 


<J>Louer Bear ins 

[<o>H0DAL CTRL ON ] 



[SINE ON ] 

<L>Frq inpt: Z80.0 Hz, 

x_walue 

y value 

PL: 8.1328 


(L) 

‘.Excitation Parmtr> 

Displacement : 0.1u 

"8*5v 

< >i/PL: 7,578 

[<"> to toggle ' ] 3.8v, 1 

i*8v, -Uv, -S.iv^ 

<a)A>plitude: 1,8 u 0-pfc 

[<,> Enable exction.] + 

- + - 

<?>f_exclte : 

l<:> Assembly ON ] X 

X ? y C-00-1820 


Figure 20. — Modal control display screen. 


17.0 EXTERNALLY GENERATED EXCITATION SIGNAL TOGGLE 

To switch to an external signal source such as a signal generator, press the < key. The label “f_excite2” ap- 
pears at the bottom left of the screen (Fig. 21), thus confirming the signal source status. The external signal source 
should be connected to channel 3 on the Datel input board 2 at address 0x366. 


1 8.0 INTERNALLY GENERATED EXCITATION SIGNAL TOGGLE 

Press the ? key to toggle the screen display of the outputs from a selected signal function (fig. 22). Note the 
display (which is in digital counts as the code cycles through 0 to 500 steps) at the right of the “<?>f_excite:” label, 
and the current cumulative number of period lengths PL, which is displayed at the right of header “<Excilation 
Parmtrx” This option should be used only for code diagnosis because the code is slowed 60 ms to make it possible 
to observe the signal output. The code may respond sluggishly to key commands during this mode of operation. 


1 9.0 SIGNAL EXPORTATION TOGGLE 

The excitation signals, whether generated in the code or imported from an external signal generator, may be 
exported for display on an oscilloscope. To toggle this option, depress the Shift key while simultaneously pressing 
the m key. In figure 12, the 0 displayed at the “<M>-tcst:” label changes to 1 to indicate an “on” status (fig. 14(a)). 
A 0 represents an “of f ’ status. This signal can be obtained from either channel 0 on the Metrabyte board at address 
0x330 or more conveniently from the “bnc” connector labeled “SIGNAL GEN,” which is located on the lower bear- 
ing output panel in figure 16. 


NAS AFTM — 200 1 -2 1 070 1 


17 




[file : FIueAx.c 3 


to select excitation 


<R> to toggle Bounce/Ti It 
<r> to toggle O.P.F. dirction 
«> to toggle ext. input. exction 

<8,»>a«rg freq update adjst =r > LOWER 

O.P.R, Anti clkuse 

==> BOUNCE NODE <== 

[ THE MAGNETIC 1 <c>CG factor: 8,88 

[BEARING STSTEH IS3 I loop time: 69.47 micro-sec 3 
l 3 Time; 18:33:86 AH 

| Y_AX IS <H>-test: 1_ X.AXIS 

V 

t 

Jy_bot<p> 2 . 30 R h_b oi<fjf > : 2,30 

[<r)0HE PR BEU ] du bot<u> : 15.00 dh bot«t> : lb. Hi* 

CLwr Safe Sain OH 3 =================== ===^==^=========== 

[Upr Safe Sain OH 3 [Loop buffer OH 3 

[Tht Safe Sain OH 3 off set_feot<t> : -20 


BEARIN6 : 

Display fara*eter 


<!>lower Bear inf 
<tt>Upper Bearing 
<z>TIirst Bearing 

Energizing Parsitr 

<H>Thrst Bearing 
<I>Uppcr Bearing 
<J>louer Bearing 


[<b>H 0BAL CTRL 3 offset not <«? ~f.n 

[SINE OH 3 b i 3s current but 1 :.) : ±.yy hil. 

< >Frq_Inpt: 280 .6 Hz. Force (N) xjialue y.ualue 

FI: 8 . 1328 


(Excitation Parmtr> 

<«>1/Pl: 7.578 [<"> to toggle B.h. 1 

<a>Aapl itude: 4.8 v 0-pk [<,> Enable exction. 3 ♦ - * - 

ff_exclteZ 1 <== !<-> Asseably ON 3 X X 7 1 c-00-1819 


Figure 21 . — Lower bearing display screen showing selection of external signal source ([f_excite2]). 


<♦,-> to to g gle input-output writes 
<q> to abort control 
<f> to toggle loop tine buffer 
<e> Bon diagnostic 

<(,»,«> disable safe gain ==> 

O.P.R. Anti clkuse 

==> BOUNCE HOPE <== 

[ THE MAGNETIC 3 «=>«: factor: u.iiii 

[BEARING S7STEM 1S3 [ loop tine: 73.87 micro-sec 

[ 3 Time: 18:31:45 AH 

I V.AX1S <M>-test: 1 X_AXIS 


[file : FiaeAx.c ] 


LOWER BEAR INi 

Display Parameter 


3 <l>Louer Bear my 

<U>Upper Beaniitj 
<Z>Hirst Benrirq 


ku_bot<p> : Z 38 Lhjmt<g> ■ 2.. ’ll) 

<{)>phi ANG : B deg d*< hn*'»' • t 1 ; OB ah hntc/i'; : 1-. mi 

[Lur Safe Gain ON 3 ==--==■--—=====—-- =================== 

[Upr Safe Gain ON 3 [Loop buffer ON 3 

[Tht Safe Gain ON 3 ..ffsct bot<t> 

Kb>H0DAL CTRL 3 

[SINE ON 1 bias rsrmn- ----- : {% 

<k>Frq_lnpt: 200.8 Hz. x.value 

FL: 8.1328 

(Excitation Pnrntr) 1.3E+B5 
<o>l/PL: 7.578 

<a>A«pl Itude: 4,8 v 0-pk [<•> Enable exction. J ♦ 

<?>f .excite : 338. 388 R:T Assembly OH 3 X X 


Energizing Parstr 


<H>Thrsl Bearing 
<l>llpper Bear nil; 

<J> Lower Bear! ; 


y.value 


f 


1 C-00-1818 


Figure 22. — Lower bearing display screen of a selected internal signal function (note outputs 200.0 Hz, 
1.3E+05, 7.578). 


NAS A/TM— 200 1 -2 i 070 1 


18 






20.0 SAFE GAIN TOGGLE 


Extreme adjustments to the stiffness and/or damping values (see sec. 9.0) may result in the rotor experiencing 
unstable levitation. Hence, each bearing control block has a safety logic mechanism known as “safe gain (source 
code lines 1493-1496; 1844-1847; and 2644-2647). The safe gain logic checks to see if the input value from the 
proximeter probes exceeds a predetermined upper limit. If this value is exceeded, the stiffness/damping parameters 
are instantly restored to values that have previously been shown to permit stable levitation. The safe gain parameters 
should be kept on at all times (fig. 12). Depressing the Shift key while simultaneously pressing the 1, 2, and 3 keys 
will turn off the safe gain parameter of each bearing. 


21.0 LOOP TIME AND CURRENT TIME DISPLAY 

The code cycles through 75 000 loops, after which it does a current time (as per the DOS clock) and a loop time 
update (source code lines 2767-2807; 2815-2820; and 2844-2845). The loop time is the time the code takes to com- 
plete one control loop cycle (fig. 12). 


22.0 DISPLAY OF ROTOR DISPLACEMENT 

Simultaneously press the Shift and + keys to display (under the header “ Force (NV V ) the value of the control 
force command on the rotor along with its instantaneous displacement values (fig. 14(a)). Press the - key to turn 
off the display. These keys also activate and deactivate the displacement display while the code is running in modal 
control mode. A blinking yellow w (fig. 14(b)) will appear in the displacement field if a bearing writeout is uninten- 
tionally left activated while the user is viewing the parameter of another bearing. The code may respond sluggishly 
to key commands during this mode of operation. 

23.0 NONDIAGNOSTIC MODE DISPLAY 

The nondiagnostic display (fig. 13) is a minimal display mode that may be toggled after adjusting all the critical 
parameters. When this display is selected, only the nondiagnostic parameter keys are active, except for the safe gain 
keys. The parameters that are not displayed will be inoperative until the diagnostic mode is again toggled. The 
“[<r>ONE_PR_RE V] “MODAL CNTRL,” “< >EXCITATION,” and “<,> Enable exction.” parameters are all 
automatically deactivated but may be reactivated if needed. 


NASA/TM — 200 1-210701 


19 


APPENDIX A 


GRAPHICAL AND MATHEMATICAL REPRESENTATIONS OF EXCITATION SIGNALS 

The following are the graphical and mathematical representations of the excitation signals that were imple- 
mented in the code. The amplitude A was replaced by the variable t04 (source code lines 750, 757, 764, 771 , 796, 
825, 853, 881, 910, 938, and 967), and its value ranges from 0.0 to 1024.0 digital counts (i.e., 0 to 5 V in 0.1-V 
increments). “0” is 1/PL. By changing the value of PL between 0.002 and 1.0, a wide range of frequencies may be 
obtained. Each loop of the code increments the x-value by 0.002 until it exceeds the upper limit 1 .75x1 0 308 , at 
which point x is reinitialized to zero. 

Sine: 


f(x) = Ax sin (2.0 x n x Ox *) 


(14) 


Sine squared: 


f(x) = A x $in(2.0 x n x 0 x x) x sin(2.0 x n x 0 x x) 


(15) 


Cosine: 


f(x) = Ax cos(2.0 xnxOxx) 


(16) 


Cosine squared: 


/ (jc) = A x cos(k x 0 x x) x cos(ti X 0 x x) 


Random: 


(17) 


f(x) = A x sin(2.0 x n x f_excite 3) x [sin(2.0 x n x O x x) + sin(2.0 x n x f_excite 4 x 0)] (1 8) 

where f_excite3 and fjexcite4 are random number variables (source code lines 785 and 789). The second sine term 
coupled with the third produces a curve with a random beat frequency, the amplitude of which is further modulated 
by the first sine term. 

Squared pulse train: 



(19) 


NAS A/TM— 200 1 -210701 


20 


Square wave: 



Triangular wave: 


f(x) = Ax 


Mf 

r (-i)* ' 

1* ! IS 

(2k + 1) 2 


x sin [2.0 x (2k + 1) x n x O x jc] i 


( 21 ) 


W, 



Single square pulse: 


f(x) = Ax 


^ ^ 2 
OxC + - 

71 

40 1 

1 

kl 


Ui=i l 



x sin(£l x 71 x O x C) x cos(2.0 x kl x 7t x O x x) > 


where C is the pulse width PW. 



( 22 ) 


NASA/TM— 2001-210701 


21 


Single triangular pulse: 



( 23 ) 


Saw tooth: 


40 


/(,) = Ax- X 


(- 1 ) 


*1 + 1 


U=0L 


*1 


x sin(2.0 x *1 x n x O x x)\ 


(24) 



NASA/TM— 200 1 -210701 


22 



APPENDIX B 


SOURCE CODE 


This program was designed and written by Carlos R. Morrison (9/28/2000). It incorporates three control blocks 
for levitating and controlling three magnetic bearings: lower, upper, and thrust. Additionally, the code allows one to 
toggle any 1 of 1 1 excitation signals. Each signal is used in conjunction with the “ONE_PR_REV" (one-per-revolu- 
tion) logic block that was originally conceived by Dr. Gerald Brown. The code also has an enhanced graphical user 
interface for ease of use. 


NASA/TM— 2001-2 10701 


23 


FIVEAXW . C 


1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 #include<stdio . h> 

12 #include<dos . h> 

13 #include<conio . h> 

14 #include<math . h> 

15 #include<time .h> 

16 #include<stdlib . h> 

17 

18 /*- VARIABLE DECLARATION --*/ 

19 

20 int board, lchanl, lchan 2 , lchan3 , pchanl , pchan 2 , pchan3 , erstat , xbot , ybot , xtop, 

21 ytop, zth, zthl , zth 2 , x_bot_oldl , x_bot_old 2 , x__bot_old3 , x_bot_old4 , 

22 x_bot__old 5 , y_old_bot , y_old_top , y_old_th, y_bot_oldl , y_bot_old 2 , 

23 y_bot_old3 , y_bot_old4 , y__bot_old5 , x_top_oldl , x_top_old2 , x_top_old3 , 

24 x_top_old 4 , x_top_old5 , y_top_oldl , y_top_old 2 , y_top_old3 , y_top_old4 , 

25 y top old 5 , z_th_oldl , z_th_old 2 , z_th_old3 , z_th_old4 , z_th_old5 , Basel , 

26 Base2 , out_chanl_0 , out_chanl_l , out_chanl_2 , out_chanl_3 r out_chanl_4 , 

2 7 out_chanl_5 , out_chan2__0 , out_chan2_l , out_chan2_2 , out_chan2_3 , out_chan2_4 f 

2 8 out_chan2_5 f i_bot, i_top, i_th, j , tBias_bot , tBias_top, tBias_th, wBias_bot , 

2 9 wBias_top , wBias_th , nw_bot , nw_top , nw_th, f ig , out_min , out_max f n , j j j , 

30 bias_current_bot , bias_current_top, bias_current_th, nmax, Imax, 1 , 

31 PD_tBias_bot , PD_tBias_top, PD_tBias_th, PD_wbias_bot , PD_wbias_top , 

32 PD~wbias_th, valuenoise , FIF01 , FIF02, zero, one, two,hh,g, w=15,k,kl r m,ml, 

33 m2 , m3 , m4 , p , xO , d_max_th, d, v, ROUND , f lagl , f lag2 , f lag 3 , f lag4 , f lag5 , 

34 flag 6 , flag 7 , flag 8 , f lag 9 , f laglO , flagl 2 , f lagl 3 , flaglS, f lagll, flag 22 , 

35 flag33 , f lag44 , f lagl6 , f lagl8 , f lagl9 , f lag20 , f lag21 , f lag23 , f lag24 , f lag25 , 

36 f lag 4 a, f lag4b f f lag4c # f lag4d, f lag_A, flag_B, flag_C, flag_D, flag_E, flagJF, 

37 flag_G, f lag_H, f lag_I , f lag_J, flag_K, flag_L, flag_M, flag_N, flag_AA, flag_BB, 

38 flag_CC, flagJOD, flag_EE, f lag_FF, f lag_GG, flag_HH, flag_II, flag_JJ, f lagJJ , 

39 thp, flagjj j , flagKK, flagLL, flagMM, flagNN, out_bot , out_top , out_th, diag, t48, 

40 round2 , cir , cir2 , sgl , sg2 , sg3 , excite, f_excite, f_excite2 , num, n_x, SSS , th, 

41 i_rev , one_per_r ev , trigger=21, rise, N_ ticks , j _re v , X_P_0__B , X _N_0_B , Y_P_0_B , 

42 Y _ N_0_B , X_P_0_T , X_N_0_T , Y_P_0_T , Y_N_0_T , TC , test_signal , switchl , excite_cos , 

43 excite_sin,maxv, set=l, rr» 0 , qq= 0 , i; 

44 

45 double I_lim, loop_time, last_time , micro, junk, ibiasjaot , ibias_top, ibias_th, 

4 6 dh_bot , kh_top , dh_top , dh_th , dv_bot , kh_bot , kh_th , kv_bot , kv_top , kv_th , 

47 dv_top , dv_th, x_f orce_bot , y_force_bot , x_f orce_top, y_force_top, 

48 z force_th, xbotderiv, ybotderiv, xtopderiv, ytopderiv, zthderiv, 

49 x_pos_output_bot , x_neg_output_bot , x_pos_output_top, x_neg_output_top, 

50 up_output_th, down_output_th , yjpos_output_bot , y_pos_output_top, 

51 y neg_output_bot , y_neg_output_top, z, xbotsum,ybotsum, xtopsum, zthsum, 

52 ytopsum, igainbot, igaintop, igainth, igainmod, safe, zsaf e, x, O, frequency, 

53 period, PL, ex, f_ex, volt, C, PW, PWW, freq, t04 , THETA, f_excite_cos , 

54 f_excite_sin, PI 2 _o_Nticks , PI2 , phi , i_revl , pp=0 . 0 , Yav, Xav, xbot_f orce_tr , 

55 xtop force_tr , ybot_force_tr , ytop_f orce_tr , dotXav, dotYav , oldoldXav , 

56 oldXav, oldoldYav, oldYav, ThetaX , ThetaY, L, xbot_f orce_rot , k_tilt , c_tilt , 

57 dotThetaX , xtop_f orce_rot , ybot_f orcerot , dotThetaY , ytop_f orce_rot , 

58 oldoldThetaX, oldoldThetaY, oldThetaY, oldThetaX, xbot_f orce_modal_pos , 


NASA/TM— 2001-210701 


24 


FIVEAXW.C 


59 xbot_force_modal_neg,xtop_force_modal_pos,xtop_force_modal_neg, 

60 ybot_force_modal_pos,ybot_force_modal_neg, ytop^forcejnodaljpos, XI, JJ, 

61 ytop_f orce_modal_neg , F_XB_tr , F_XT_tr , F_YB_tr, F_YT_tr, excitef , 

62 LIM, 00=0 . 0 , OL=0 .0,11=0.0, LT, L_T, CG, A1=0 . 0 , A2 = 0 . 0 , A3 = 0 . 0 , A4=0 . 0 , A5=0 . 0 , 

63 A6=0 . 0 , A7 = 0 . 0 , A8=0 . 0 , A9 = 0 . 0 , A10=0 . 0 , A11 = 0 . 0 , A12 = 0 . 0 , A13=0 . 0 , A14=0 . 0 , 

64 A15=0.0,B1=0. 0 ,32=0.0, B3=0 . 0 , B4=0 . 0 , B5=0 . 0 , B6=0 . 0 , B7=0 . 0 , B8 =0 . 0 , B9=0 . 0 , 

65 B10=0.0,Bll=0.0,B12=0.0 / B13=0.0,B14=0.0,B15=0.0,f_excite3,f_excite4, 

66 xy=0 . 0 , C0UNTMAX=15 . 0 , MCG, PCG, cos (double x) , sin (double x),ns; 

67 

68 struct time now,tt; 

69 

70 unsigned int ti_min, ti_second, ti_hund; 

71 

72 float roundl (float u) , randvalue , timel ; 

73 

74 char resp , lu, respp, ig ; 

75 

76 const int NUMBERS = 1; 

77 

78 int main (void) 

79 

80 /* INITIALIZE - - - - * / 

81 

82 { 

83 clrscrO; 

84 


85 

// ******************* patel 

Input Board (1) setup ********★+******+*+ 

86 

// Board address: 

0x3 00 





87 

outportb ( 0x3 Oe , 

0x3a) ; 

j * 1; while 

( 

j <5 000 

) 

j++; 

88 

outpor tb (0x308, 

2) ; 

j = 1; while 

( 

j <5000 

) 

j++; 

89 

outportb (0x308, 

0) ; 

j « 1; while 

( 

j <5000 

> 

j++; 

90 








91 

outportb ( 0x3 Oe , 

0x7a) ; 

j =» 1; while 

( 

j <5000 

) 

j++; 

92 

outportb ( 0x3 0a , 

1) ; 

j = 1; while 

{ 

j <5000 

) 

j++? 

93 

outportb ( 0x3 0a , 

0) ; 

j = 1; while 

{ 

j <5000 

) 

j++; 

94 








95 

outportb ( 0x3 Oe , 

Oxba) ; 

j ■ 1; while 

( 

j <5000 

) 

j++; 

96 

outportb ( 0x3 Oc , 

1) ; 

j = 1; while 

( 

j <5000 

) 

j++? 

97 

outportb ( 0x3 0c , 

0) ; 

j = l; while 

( 

j <5000 

) 

j++; 

98 








99 

outport (0x302, 

0x40) ; 

j = 1; while 

( 

j <5000 

> 

j++; 

100 

outpor t (0x306, 

1) ? 

j = 1 ; while 

( 

j <5000 

> 

j++; 

101 

outport (0x300, 

Oxe) ; 

j = 1; while 

( 

j<5000 

> 

j++; 

102 








103 

// ******************* Da tel 

Input Board (2) setup ******************* 

104 

// Board address: 

0x360 





105 

outportb ( 0x3 6e , 

0x3a) ; 

j - 1; while 

( 

j <5000 

) 

j++; 

106 

outportb ( 0x3 6 8 , 

2) ; 

j ■ 1 ; while 

( 

j <5000 

) 

j++; 

107 

outportb ( 0x3 6 8 , 

0) ; 

j = 1; while 

( 

j <5000 

) 

j++? 

108 








109 

outportb ( 0x36e , 

0x7a) ; 

j - 1; while 

( 

j <5000 

) 

j++? 

110 

outportb ( 0x36a , 

1) ; 

j * 1; while 

( 

j <5000 

) 

j++; 

111 

outportb ( 0x3 6a , 

0) ; 

j = 1 ; while 

( 

j<5000 

) 

j++; 

112 








113 

outportb ( 0x3 6 e , 

Oxba) ; 

j = 1 ; while 

( 

j <5000 

) 

j++; 

114 

outportb ( 0x3 6c , 

1) ; 

j = l; while 

( 

j <5000 

) 

j++; 

115 

outportb ( 0x3 6 c , 

0) ; 

j * 1 ; while 

( 

j <5000 

) 

j++; 


116 


NAS A/TM— 200 1-210701 25 


FIVEAXW.C 


117 outport (0x362 , 0x40); j = 1; while ( j<5000 ) j++; 

118 outport (0x366, 1); j = 1; while ( j<5000 ) j++; 

119 outport (0x360, Oxe) ; j - i ; while ( j<5000 ) j++; 

120 

121 FIFOl = 0x306;// Base = 300, FIFOl = base + 6; 

122 FIF02 = 0x366;// Base = 360, FIF02 = base + 6; 

123 

124 // **************** Metrabyte Output Board (1) setup **************** 

125 

126 Basel = 0x33 0;// Board address: 0x33 0 Lower Bearing + Thrust up (Z+) 

127 out_chanl_0 = Basel + 0; 

128 out_chanl_l = Basel + 2; 

129 out_chanl_2 = Basel + 4; 

130 out_chanl_3 = Basel + 6; 

131 out_chanl_4 = Basel + 8; 

132 out_chanl_5 = Basel + 10; 

133 

134 t48 « 2048;// 2048 => Ten volts 

135 

136 outport (out_chanl_0, t48) ;// Code’s signal output 

137 outport (out_chanl_l , t48);// +X_L 

138 outport (out_chanl_2 , t48);// ~X_L 

139 outport (out_chanl_3 , t48);// + Y_L 

140 outport (out_chanl_4 , t48);// ~Y_L 

141 outport (out_chanl_5, t48);// +Z_TH 

142 

143 // **************** Metrahyte Output Board (2) setup **************** 

144 

145 Base2 = 0x390;// Board address : 0x390 Upper Bearing + Thmst down (Z-) 

146 // out_chan2_0 = Base2 + 0 ; 

147 out_chan2_l = Base2 + 2; 

148 out_chan2_2 - Base2 + 4; 

149 out_chan2_3 = Base2 + 6; 

150 out_chan2_4 = Base2 + 8; 

151 out_chan2_5 = Base2 + 10; 

152 

153 // outport (out_chan2_0 , 1 48); 

154 outport (out_chan2_l , t48);// +X_U 

155 outport (out_chan2_2 , t48);// - X_U 

156 outport (out__chan2_3 , t48);// + Y_C7 

157 outport (out_chan2_4 , t48) ;// -Y_U 

158 outport (out_chan2_5 , t48) ;// -Z_TH 

159 

160 

161 // ********************** general variable initialization ****************** 

162 

163 safe - 32600; 

164 zsafe = 16300; 

165 nmax = 500; lmax = 150; 1=0; 

166 micro = (1000000.0 / nmax / lmax); 

167 I_lim = 4.0; 

168 out_min - -roundl(2.0 * I_lim * 204.8} + t48; 

169 out_max = roundl(2.0 * I_lim * 204.8) + t48; 

170 loop__time = 0.78; hh = 0; 

171 zero = 0; one = 1; two * 2; 

172 LIM = 1.75 * pow ( 10 , 308 ) ; // max # of period lengths Supper limit) 

173 X0 = 21 ; /* (0.1) * //*103 ( . 5v) */ /*205 (lv) *//* 1435 (7v) */ 

174 k = 0; 


NASA/TM— 2001-210701 


26 


FIVEAXW.C 


175 

kl = 1; 



176 

X = 0.0; 



177 

f_excite = 

0 . 

0; 

178 

excite = C 

-0; 


179 

f_excite_sin 

= 0.0; 

180 

f_excite cos 

= 0.0; 

181 

JJ = 1.0; 



182 

II = 1.0; 



183 

ex = 0.0; 



184 

0 = 1.0; 



185 

frequency 

= 0 

•0; 

186 

PWW = 0.0; 



187 

PW » 0.0; 



188 

i_rev = 0; 



189 

j_rev = 0; 



190 

THETA = 0. 

0; 


191 

th = 0 ; 



192 

PI2 = 2 * 

M PI; 

193 

phi = 0.0; 



194 

L = 1.0; 



195 

TC = 9; 



196 

test signal = 

0; 

197 

t04 = 0.0; 



198 

f req = 0.0 

; 


199 

PL - 1.0; 



200 

CG = 0.0; 



201 

MCG =0.5 

- CG; 

202 

PCG =0.5 

+ CG; 

203 

cir = 23; 



204 

cir2 = 55; 



205 

flag5 =* 0; 



206 

f lag6 * 0 ; 



207 

f lag7 = 0; 



208 

f lag8 = 0 ; 



209 

f lag9 - 0 ; 



210 

f lagl2 = 0 



211 

flagl3 = 0 



212 

flaglO = 0 

// 

Disable modal block 

213 

flaglS = 1 



214 

flagl6 = 1 

// 

Assembly condition (on) 

215 

f lagl8 = 0 



216 

f lagl9 = 0 



217 

f lag20 = 1 



218 

f lag21 = 0 

// 

Disable excitation block 

219 

f lag23 = 1 



220 

flag24 = 1 

// 

Enable loop_time averaging 

221 

flag25 = 1 

// 

Toggle loop^time averaging 

222 

f lag_A = l 

// 

Assembly toggle set to off 

223 

f lag__B = 1 



224 

flag_C = 1 



225 

flagJO = 1 



226 

flag_E = 1 



227 

f lag_F = l 



228 

f lag_G = 1 



229 

flag_H = 1 



230 

f lag_I = l 



231 

flag_J = 1 



232 

flag_K = 0 




NAS A/TM— 200 1-210701 


27 


FIVEAXW.C 


233 flag_L = 0; 

234 flag_M - 1; 

235 flag_N - 1; 

236 flag_AA = 0; 

237 f lag_BB = 1; 

238 f lag_GG = 1; 

239 flag_HH = 0; 

240 flag_II = 0; 

241 flagJJ = 1; 

242 flag__JJ = 1; 

243 f lag_j j = 1; 

244 flagKK = 1/ 

245 flagLL = 1; 

246 flagMM « 0; 

247 flagNN = 1; 

248 SWitchl ~ 0; 

249 

250 // ******************* BOTTOM BEARING VARIABLE INITIALIZATION ************** 

251 

252 kv_bot - 2.3; 

253 kh_bot = kv_bot; 

254 dh_bot = 15.0; 

255 dv_bot = dhjDOt ; 

256 ibias_bot - 1.0;// Amperes 

257 bias_current_bot * roundl (ibias_bot * 2.0 * 204.8);// two Volts => one Amp. 

258 

259 // .Remember amplifier gain is 0.5A/V 

260 

261 PD_tBias_bot « -20; PD_wbias_bot = -20;// Initial differential biases 

262 tBias_bot = PD_tBias_bot ; wBias_bot * PD__wbias__bot ; 

263 nw_bot * 0;// For writeout, set nw_bot = 1 

264 sgl = 1;// Lower Bearing safe gain set 

265 

266 // ***************** TOP BEARING VARIABLE INITIALIZATION ******************* 

267 

268 kv_top * 2.3; 

269 kh_top = kv_top; 

270 dh_top = 15.0; 

271 dv_top = dh_top; 

272 ibias_top = 1.0;// Amperes 

273 bias_current_top = roundl {ibias_top * 2.0 * 204.8);// Two Volts -> one Amp 

274 

275 // Remember amplifier gain is 0.5A/V 

276 

277 PD_tBias_top = -20; PD_wbias_top -= -20;// Initial differential biases 

278 tBias__top = PD_tBias_top; wBias_top = PD_wbias top; 

279 nw__top » 0; 

280 sg2 = 1;// Upper Bearing safe gain set 

281 

282 // **************** THRUST BEARING VARIABLE INITIALIZATION ***************** 

283 

284 kv_th = 2.3; 

285 dv_th = 15.0; 

286 ibias_th = 1.5 ;// Amperes multiplication factor 

287 igainth = 0.0002; 

288 bias_current_th = roundl (ibias_th * 2.0 * 204.8);// Two Volts => one Amp 

289 

2 90 // Remember amplifier gain is 0.5A/V 


NASA/TM — 200 1 -210701 


28 



FIVEAXW . C 


291 

292 

293 

294 

295 

296 

297 

298 

299 

300 

301 

302 

303 
3 04 

305 

306 

307 

308 

309 

310 

311 

312 

313 

314 

315 

316 

317 

318 

319 

320 

321 

322 

323 

324 

325 

326 

327 

328 

329 

330 

331 

332 

333 

334 

335 

336 

337 

338 

339 

340 

341 

342 

343 

344 

345 

346 

347 

348 


PD_tBias_th = -20; // initial differential biases 

tBias_th * PD_tBias_th; 
nw_th * 0; 

sg3 = 1;// Thrust Bearing safe gain set 
/ / *** + *********** + ************************************ + ++•*■******* + + * + ****** 


flagl = 0; 
flag2 = 0; 
f lag3 = 0; 
flag4 = 1; 

flag4a = 0; 
flag4b m 0; 
flag4c = 0; 
flag4d = 1; 


f lagll 
f lag22 
f lag33 
f lag44 


1;// Enable lower bearing write out block 
0;// Disable upper bearing write out block 
0;// Disable thrust bearing write out block 
0;// EnaJble D.A/l.A . display 


// SH0W 

clrscr {) ; 

gotoxy{45 / 6) ; textcolor (4 ) ; 
gotoxy (5 9,1) ; textcolor (15) ; 
cprintf{"[ file : FiveAx.c ]"); 

gotoxy (29, 13) ; textcolor ( 15) ; 
cpr int f( M ***************★******”) • 
gotoxy (29, 14 ) ; textcolor (15) ; 
cprintf( n * **' ) ; 

gotoxy (29 , 15) ; textcolor (15) ; 
cprintff"* *”); 

gotoxy (29, 16) ; textcolor (15) ; 
cpr int f ( 11 *** + * + ****★*** + **■*■ + ***») • 
gotoxy (35 , 14 ) ; textcolor (14) ; 
cpr int f ("FIVE- AXIS”); 
gotoxy (32 , 15) ; textcolor (14) ; 
cpr intf ("BEARING FACILITY"); 

G: gotoxy (31 , 5) ; textcolor (10) ; 

cprintf ( "DIAGNOSTIC (y/n) ? : " ) ; 
respp » getchO; 
gotoxy (31, 5) ; 

printf ( " ") ;// Erase "DIAGNOSTIC (y/n)?: 11 

if (respp -- 1 y 1 | | resp == 1 Y' ) 

{ 

SSS - 1; 

diag = 1 ; 

clrscr () ; 


goto H; 

} 


NAS A/TM— 200 1 -2 1 070 1 


29 


FIVEAXW . C 


349 

350 

351 

352 

353 

354 

355 

356 

357 

358 

359 

360 

361 

362 

363 

364 

365 

366 

367 

368 

369 

370 

371 

372 

373 

374 

375 

376 

377 

378 

379 

380 

381 

382 

383 

384 

385 

386 

387 

388 

389 

390 

391 
3 92 

393 

394 

395 

396 

397 

398 

399 

400 

401 

402 

403 

404 

405 

406 H: 


else 

if (respp =»= T n’ || resp -= 'N'} 

{ 

clrscr {) ; 

SSS = 0; 

gotoxy (1 , 1) ; textcolor (15) ; 

cprintf ( "<x/k> to adjust frequency"}; 

gotoxy (1,2) ; textcolor (15) ; 

cprintf ( "<q> to abort control"); 

gotoxy (1,3) ; textcolor (15) ; 

cprintf (" <m> to toggle modal cntrl") ; 

gotoxy (1 , 4} ; textcolor (15) ; 

cprintf ("<?> to toggle f_excite" ) ; 

gotoxy (1,5) ; textcolor (15) ; 

cprintf (" <4- 0> to select excitation"); 

gotoxy (59,1) ; textcolor (15) ; 

cprintf ("[ file : FiveAx.c ]"}; 

gotoxy (3 1,2) ; textcolor (11) ; 

cprintf ("DIAGNOSTIC T0GGLE<E> " ) ; 

gotoxy (I, 22) ; textcolor (13) ; 

cprintf ( " <Excitation Parmtr>") ; 

gotoxy (1,14) ; textcolor (10) ; 

cprintf ("< >PHSE ANG : % 3 u deg",th); 

gotoxy (2 ,14) ; textcolor (15) ; 

cprintf ( "n" ) ; 

gotoxy (1,23) ; textcolor (15) ; 

cprintf { "<o>f req : %8 . 2f Hz" , frequency) ; 

gotoxy (1 , 20 ) ; textcolor (15) ; 

cprintf ( " <x>Frq_inpt : %7 . If Hz . " , freq) ; 

gotoxy (1,2 5) ; textcolor (15) ; 

cprintf ( ,! <s>to adjust Pulse Width"); 

gotoxy (1,24) ; textcolor (15) ; 

cprintf ( "<a> Amplitude : %4 . If v 0-pk",volt); 

gotoxy (27 , 23) ; textcolor (14 ) ; 

cprintf {" [<^> to toggle D. A. ]"); 

gotoxy (27 , 24) ; textcolor (14) ; 

cprintf ("[<, > Enable exction.]"); 

gotoxy (28 , 25) ; textcolor (14) ; 

cprintf ("[<: > Assembly ] " ) ; 

gotoxy (42 , 25) ; textcolor (10) ; 

cprintf ( "ON" ) ; 

nw_bot = 0 ; 
nw_top = 0; 
nw_th = 0 ; 

diag = 0; 

flagl = 1;// Lower bearing block activated 
f lag2 = 1;// Upper bearing block activated 
f lag3 = 1;// Thrust bearing block activated 

goto H; 

} 

goto G; 

if (diag 1) 


NASA/TM— 2001-2 10701 


30 


FIVEAXW.C 


407 

408 

409 

410 

411 

412 

413 

414 

415 

416 

417 

418 

419 

420 

421 

422 

423 

424 

425 

426 

427 

428 

429 

430 

431 

432 

433 

434 

435 

436 

437 

438 

439 

440 

441 

442 

443 

444 

445 

446 

447 

448 

449 

450 

451 

452 

453 

454 

455 

456 

457 

458 

459 

460 

461 

462 

463 

464 


{ 

gotoxy (59, 1 ) ; textcolor (15) ; 
cprintf ("[ file : FiveAx.c ]"}; 

gotoxy (1,1) ; textcolor (15) ; 

cprintf { "<+ , -> to toggle input-output writes"); 

gotoxy (1,2) ; textcolor (15) ; 

cprintf ("<q> to abort control"); 

gotoxy (1 , 3 ) ; textcolor (15) ; 

cprintf ("<f> to toggle loop time buffer"); 

gotoxy (1,4) ; textcolor (15) ; 

cprintf ("<e> non diagnostic"); 

gotoxy (1, 5) ; textcolor (15) ; 

cprintf {"<!, @, #> disable safe gain") ; 

gotoxy (19 , 11) ; textcolor (15) ; 

cprintf ( " Y_AXIS X_AXIS" ) ; 

gotoxy (36 , 11) ; textcolor (13) ; 

cprintf ("< >- test : %lu" , test_signal) ; 

gotoxy (37, 11) ; textcolor ( 15 ) ; 

cprintf ( "M" ) ; 

gotoxy (21 , 12 ) ; textcolor (4) ; 

gotoxy (21, 15) ; textcolor (14) ; 

gotoxy (52, 5) ; textcolor (14+128) ; 
cprintf ( "==> <=="); 

gotoxy (57 , 5) ; textcolor (10) ; 
cpr int f { " LOWER BEARING " ) ; 
gotoxy (31,8) ; textcolor (9) ; 
cprintf (" <c>CG factor: %5.2f",CG); 
gotoxy (32 ,16) ; textcolor (14 ) ; 
cprintf {" [loop buffer ]"); 
gotoxy (4 5 , 16 ) ; textcolor (10) ; 
cprintf ("ON " ) ; 
gotoxy (21 ,13) ; textcolor (9) ; 
cprintf ( "kv_bot<p> :%6.2f", 
gotoxy (42 , 13 ) ; textcolor (9) ; 
cprintf ( M kh_bot<g> :%6.2f", 
gotoxy (21 , 14) /textcolor (9) ; 
cprintf ( "dv_bot<v> :%6.2f", 
gotoxy (42 ,14) ; textcolor (9) ; 
cprintf ( "dh_bot<d> :%6.2f", 
gotoxy (21, 17) ; textcolor (9) ; 
cprintf ( "of f set_bot<t> 
gotoxy (55, 17) ; textcolor (9) ; 
cprintf ( "%5d" , tBias_bot) ; 
gotoxy (21,18) ; textcolor (9) ; 
cprintf ( "of f set_bot<w> 
gotoxy (55 , 18) ; textcolor (9) ; 
cprintf ("%5d" , wBias_bot) ; 
gotoxy (21 , 19) ; textcolor (9) ; 

cprintf ( "of f set current_bot<b> :"); 

gotoxy (55 ,19) ; textcolor (9) ; 
cprintf ( "%6 . 2f Amp.", ibias_bot); 
gotoxy (51 , 20) ; textcolor (15) ; 
cprintf ( "x_value y_value" ); 

gotoxy (51 ,21) ; textcolor (4) ; 
cprintf { "=*====== ==*«*==»); 

gotoxy (49 , 24) ; textcolor ( 15) ; 


kv_bot) ; 
kh_bot ) ; 
dv_bot) ; 
dh_bot ) ; 


N AS A/TM — 200 1-210701 


31 



FIVEAXW.C 


465 

466 

467 

468 

469 

470 

471 

472 

473 

474 

475 

476 

477 

478 

479 

480 

481 

482 

483 

484 

485 

486 

487 

488 

489 

490 

491 

492 

493 

494 

495 

496 

497 

498 

499 

500 

501 

502 

503 

504 

505 

506 

507 

508 

509 

510 

511 

512 

513 

514 

515 

516 

517 

518 

519 

520 

521 

522 


cprintf (" + - + ») ; 

gotoxy (49, 25) ; text color (15) ; 

cprintf ( " X X Y Y "); 

gotoxy (64, 7) ; textcolor (11) ; cprintf ( ’’Display Parameter”) 

gotoxy (64, 8) ; textcolor (15) ; cprintf 

gotoxy (64 , 9) ; textcolor (13 ); cprintf { r, < >Lower Bearing”)/ 

gotoxy (65, 9) ; textcolor (15) ; cprintf ( "1 " ) ; 

gotoxy (64 ,10) ; textcolor (13 ) ; cprintf ( "< >Upper Bearing”); 

gotoxy (65, 10) ; textcolor (15 ) ; cprintf ( ”u” ) ; 

gotoxy (64 , 11) ; textcolor (13) ; cprintf ( ”< >Thrst Bearing”); 

gotoxy (65, 11) ; textcolor (15) /cprintf ("z”) ; 

gotoxy (64, 13) /textcolor (11) ; cprintf { "Energizing Parmtr") 

gotoxy (64, 14) ; textcolor (15) ; cprintf ( "============«====:" ) 

gotoxy (64, 15) /textcolor (13) /cprintf (”< >Thrst Bearing”) ; 

gotoxy (65 , 15) ; textcolor (15+128 ) ; cprintf ( "H" ) ; 

gotoxy (64,16) /textcolor (13) /cprintf ("< >Upper Bearing"); 

gotoxy (65, 16) /textcolor (15+128) / cprintf {" I ” ) ; 

gotoxy (64 , 17) ; textcolor ( 13 ) /cprintf (”< >Lower Bearing") ; 

gotoxy (65, 17) /textcolor (15+128) /cprintf ("J" ) ; 

gotoxy (26, 20) ; textcolor (15) ; 

cprintf ("Force (N) " ) ; 

gotoxy (25, 21) ; textcolor ( 4) ; 

cprintf {"==««====*==” ) ; 

gotoxy (1,20) ; textcolor ( 15) ; 
cprintf (”<x>Frq_inpt : %7 . If Hz.”); 
gotoxy (1,25) ; textcolor (15) ; 
cprintf ( "<s> to adjust Pulse Width"); 
gotoxy (1,15) ; textcolor (15 ) ; 
cprintf ( " [ ] " ) ; 

gotoxy (1,14) /textcolor (10) ; 
cprintf ("< >PHSE ANG:%3u deg",th); 
gotoxy (2, 14) ; textcolor (15) ; 
cprintf ( "n" ) 

gotoxy (2 , 15) ; textcolor { 14 ) ; 
cprintf { "Lwr Safe Gain " ) / 
gotoxy (16, 15) ; textcolor (10) ; 
cprintf ("ON ") ; 
gotoxy (1, 16} ; textcolor (15) ; 
cprintf ( " [ ]"); 

gotoxy (2, 16) / textcolor (14 ) ; 
cprintf ( "Upr Safe Gain "); 
gotoxy (16 , 16) ; textcolor (10) ; 
cprintf ("ON ") ; 
gotoxy (l, 17) ; textcolor (15) ; 
cprintf ( " [ ] " ) ; 

gotoxy (2, 17) / textcolor (14) ; 
cprintf ("Tht Safe Gain " ) ; 
gotoxy (16 ,17) ; textcolor (10) ; 
cprintf ("ON "); 
gotoxy (1,18) ; textcolor (15) ; 
cprintf ("[ 3" ); 

gotoxy (2 , 18 ) / textcolor (14) ; 
cprintf (”< >MODAL CTRL ") ; 
gotoxy (3 , 18) ; textcolor (15+128) ; 
cprintf ("m") ; 

gotoxy (16 , 18) ; textcolor (12+128) ; 

cprintf ("OFF”) ; 

gotoxy (1, 19) /textcolor (15) ; 


N AS A/TM — 200 1-210701 


32 


FIVEAXW . C 


523 

524 

525 

526 

527 

528 

529 

530 

531 

532 

533 

534 

535 

536 

537 

538 

539 

540 

541 

542 

543 

544 

545 

546 

547 

548 

549 

550 

551 

552 

553 

554 

555 

556 

557 

558 

559 

560 

561 

562 

563 

564 

565 

566 

567 

568 

569 

570 

571 

572 

573 

574 

575 

576 

577 

578 

579 

580 


cprintf ( " [ ]"); 

gotoxy (2,19) ; text color (14 ) ; 

cprintf ("< >EXCITATION "); 

gotoxy (16,19) ; textcolor (12+12 8) ; 

cprintf ( "OFF" ) ; 

gotoxy (1, 22) ; textcolor (13) ; 

cprintf ( n <Excitation Parmtr> M ) ; 

gotoxy (1,23) ; textcolor (15) ; 

cprintf ( 11 <o>f req : %8 . 2f Hz 11 , frequency) ; 

gotoxy (1,24) / textcolor (15) ; 

cprintf ( "<a>Amplitude : %4 . If v O-pk" , volt) / 

gotoxy (27 , 23) ; textcolor (14 ) ; 

cprintf (" [< A > to toggle D . A. ]"); 

gotoxy (27 , 24) ; textcolor (14 ) ; 

cprintf ("[<, > Enable exction.]"); 

gotoxy (2 B , 25) ; textcolor (14 ) ; 

cprintf ("[<: > Assembly ]" )/ 

gotoxy (42 , 25) ; textcolor (10) j 

cprintf ( "ON" ) ; 

}// End if (diag ==* 1) 

gotoxy (27, 9) ; textcolor (10) ; 

cprintf ("[ loop time: micro-sec ] ") ; 

gotoxy (1 , 8) /textcolor (15) ; cprintf (" [ THE MAGNETIC ] ") 

gotoxy (1 , 9) /textcolor (15) ; cprintf (" [BEARING SYSTEM IS}") 

gotoxy (1, 10) ; textcolor (15) /cprintf ( " [ ] ») 

gotoxy (9, 11) ; textcolor (15) /cprintf (" | ") ; 

gotoxy (9, 12) ; textcolor (15) /cprintf ( M j " ) ; 

if (f lag4 -= 0) 

{ 

gotoxy (4,10) ; textcolor (12+128) ; 
cprintf ("OPERATIONAL ! "); 

} 

else 

{ 

gotoxy (4, 10) ; textcolor (12+128) ; 
cprintf ( "OPERATIONAL ! \a " ) ; 

} 

if (diag 1) 

{ 

f lag_CC = 1? 
flagl - 0/ 

flag4a = 1;// Turn on Lower Bearing buffer 

gotoxy (48, 4) ; textcolor (14+128) ; 

cprintf (" * Lower bearing not energized ! " ) ; 

flag^DD = 1/ 
f lag2 = 0/ 

flag4b = 1;// Turn on Upper Bearing buffer 

gotoxy (48, 3) / textcolor (14+128) ; 

cprintf (" * Upper bearing not energized t " ) ; 

flag_EE = 1; 
f lag3 = 0; 

f lag4c = 1/// Turn on Thrust Bearing buffer 

gotoxy (48, 2) ; textcolor (14+128) ; 

cprintf (" * Thrst bearing not energized i"); 


NASA/TM — 200 1 -2 1 070 1 


33 


FIVEAXW.C 


581 } 

582 else 

583 

584 if (diag =- 0} 

585 { 

586 gotoxy (31 , 8) ; textcolor (9) ; 

587 cprintf { n <c>CG factor: %5.2f",CG); 

588 gotoxy (26 # 13) ; textcolor (14) ; 

589 cprintf ( "==> <«="}; 

590 gotoxy (30 , 13) ; textcolor (12+128) ; 

591 cprintf ("THRST BEARING ENERGIZED"); 

592 gotoxy (26 , 14) ; textcolor (14 ) ; 

593 cprintf { "==> <=»"); 

594 gotoxy ( 30 # 14) ; textcolor (12+128) ; 

595 cprintf ("UPPER BEARING ENERGIZED") ; 

596 gotoxy (26 , 15) ; textcolor (14 ) ; 

597 cprintf { "==> <=="); 

598 gotoxy (3 0 ,15} ; textcolor (12 + 128) ; 

599 cprintf ("LOWER BEARING ENERGIZED"); 

600 } 

601 gotoxy (1,15) ; textcolor (15 ) ; 

602 cprintf ( " [ ] ") ; 

603 gotoxy (2 , 15) ; textcolor (14) ; 

604 cprintf { "Lwr Safe Gain " ) ; 

605 gotoxy (16, 15) ; textcolor (10) ; 

606 cprintf ("ON "); 

607 gotoxy (1 , 16} ; textcolor (15) ; 

608 cprintf ("[ ]"); 

609 gotoxy (2 ,16) ; textcolor ( 14 ) ; 

610 cprintf ( "Upr Safe Gain " ); 

611 gotoxy (16 , 16 } ; textcolor (10) ; 

612 cprintf ("ON "); 

613 gotoxy (1, 17) ; textcolor (15) ; 

614 cprintf ( " [ ] ") ; 

615 gotoxy (2,17) /textcolor (14) ; 

616 cprintf ( "Tht Safe Gain " ) ; 

617 gotoxy (16 ,17} ; textcolor (10) ; 

618 cprintf ("ON ") ; 

619 gotoxy (1, 18) ; textcolor (15) ; 

620 cprintf (" [ ] ") ; 

621 gotoxy (2, 18) ; textcolor (14) ; 

622 cprintf {"< > MODAL CTRL "); 

623 gotoxy(3,18) ; textcolor (15+128 ) ; 

624 cprintf ("m" ) ; 

625 gotoxy (16 , 18 ) ; textcolor (12+128) ; 

626 cprintf ("OFF") ; 

627 gotoxy (1,19) ; textcolor (15) ; 

628 cprintf ("[ ]"); 

629 gotoxy (2 ,19} ; textcolor (14 ) ; 

630 cprintf ("< >EXCITATION ") ; 

631 gotoxy (16, 19) ; textcolor (12+128) ; 

632 cprintf ("OFF") ; 

633 

634 C: 

635 

636 // CONTROL LOOP 

637 


638 loop: 


NAS A/TM— 200 1 -2 1 070 1 


34 


FIVEAXW.C 


639 

640 

641 

642 

643 

644 

645 

646 

647 

648 

649 

650 

651 

652 

653 

654 

655 

656 

657 

658 

659 

660 
661 
662 

663 

664 

665 
6 66 

667 

668 

669 

670 

671 

672 

673 

674 

675 

676 

677 

678 

679 

680 
681 
682 

683 

684 

685 

686 

687 

688 

689 

690 

691 

692 

693 

694 

695 

696 


i_bot=l ; i_top=l ; i_th=l ; n=0 ; 
while (n <= nmax) 

{ 

if (diag == 0) 

{ 

if (n == 1) 

{ 

gotoxy (cir-1 , 21); 

textcolor (9) ; cprintfp' >>> " ) ; 

if (cir == 52) 

{ 

gotoxy (cir-1, 21); 
cir = 25; 

}// End of if (cir == 52) 
cir++; 

f f ******************************* 

gotoxy(cir2, 21); 
textcolor (9) ; cprintfp' <<< "); 
if(cir2 =» 25) 

{ 

gotoxy (cir2, 21) ; 
cir2 = 52; 

}// End of if (cir2 25) 
cir2 - - ; 

}// End of if (n 1) 

}// End of if (diag mm 0) 


// ******************** Da tel Board data input block *********************** 

if(flagl6 == 0)// Non assembly condition 

{ 

xbot = - inport (FIF01) ;// - x0;// Channel 0 

ybot - inport (FIF01) ;// + xO ; / / Channel 1 


xtop = - inport (FIF01) ;// - x0;// Channel 2 

ytop = inport (FIF01) ;// + x0;// Channel 3 


// 


Zthl m 

zth2 * 

one_per_rev = 
f_excite2 » 

} 


- inport (FI F02) ; // 
inport (FI F02) ;// 

inport (FIF02 ) ; // 
inport (FIF02 ) ; // 


- x0;// Channel 0 
+ x0;// Channel 1 

+ xO ; / / Channel 2 
+ xO;// Channel 3 


else 

if (flag!6 == 1)// Activates assembly block 

{ 

asm{ 

mov dx, [FIFOl] // Channel 0 

in ax, dx 

neg ax 

sub ax, [xO] 

mov [xbot] , ax 

} 

asm{ 


NAS A/TM— 200 1 -2 1 070 1 


35 


FIVEAXW . C 


697 

698 

699 

700 

701 

702 

703 

704 

705 

706 

707 

708 

709 

710 

711 

712 

713 

714 

715 

716 

717 

718 

719 

720 

721 

722 

723 

724 

725 

726 

727 

728 

729 

730 

731 

732 

733 

734 

735 

736 

737 

738 

739 

740 

741 

742 

743 

744 

745 

746 

747 

748 

749 

750 

751 

752 

753 

754 


mov dx, [FIFOl]// Channel 1 
in ax, dx 
add ax, [xO] 
mov [ybot] , ax 

} 

asm{ 

mov dx, [FIFOl] // Channel 2 

in ax , dx 

neg ax 

sub ax, [xO] 

mov [xtop] , ax 

} 

asm{ 

mov dx, [FIFOl]// Channel 3 
in ax, dx 
add ax, [xO] 
mov [ytop] , ax 

} 

asm{ 

mov dx, [FIF02] / / Channel 0 

in ax, dx 

neg ax 

sub ax, [xO] 

mov [zthl] , ax 

} 

asm{ 

mov dx, [FIF02 ] / / Channel 1 
in ax, dx 
add ax, [xO] 
mov [zth2] , ax 

} 

asm{ 

mov dx, [FIF02 3 // Channel 2 
in ax , dx 

mov [one_per__rev] , ax 

} 

asm{ 

mov dx, [FIF02 ] // Channel 3 

in ax, dx 

mov [f_excite2] , ax 

} 


// ***************** End Da tel Board data input block ********************** 

// ********************* Signal generation block *************************** 

iffswitchl =*= 0)// Shuts down excitation function block when an 
{ // external excitation (switch=l) source is used 

if (flags « 1)// <4> 

{ 

if (f lag_AA «= i) 

{ 

f_ex = t04 * sin (0*x*2 . 0*M_PI) ;// Sine 

} 


else 


NASA/TM— 2001-210701 


36 


FIVEAXW.C 


755 

756 

757 

758 

759 

760 

761 

762 

763 

764 

765 

766 

767 

768 

769 

770 

771 

772 

773 

774 

775 

776 

777 

778 

779 

780 

781 

782 

783 

784 

785 

786 

787 

788 

789 

790 

791 

792 

793 

794 

795 

796 

797 

798 

799 

800 
801 
802 

803 

804 

805 

806 

807 

808 

809 

810 
811 
812 


if (f lag__AA == 2) 

{ 

f_ex = t04 * pow (sin (0*x/*2 . 0*/+M_PI) ,2) ;// Sine squared 


else 

if(flag_AA == 3) 

{ 

f_ex = t04 * cos (0*x*2 . 0*M_PI) ; // Cosine 

} 

else 

if(flag_AA == 4) 

{ 

f_ ex = t04 * pow (cos (0*x/*2 . 0*/*M_PI) , 2) ; // Cosine squared 


else 

if { f lag_AA == 5) 

{ 

xy = xy + 1.0; 
srand (xy) ; 

if(flag21 == 1)// Excitation switch 

{ 

for(i = 1; i <=r 2; i + +) 

{ 

f_excite4 = (float (rand 0 ) /RAND MAX) ; 

} 

for ( i = 1; i <= 2/*NUMBERS*/; i++) 

{ 

f_excite3 * float (rand ()) /RAND_MAX; 

} 

}// End of if(flag21 »- 1) 

if (xy >= LIM) 
xy = 0.0; 

f_ex = t04 * sin (2 . 0*M_PI *f_excite3 ) * (sin{0*x*2 . 0*M_PI) 
sin (0*2 . 0*M_PI*f_excite4) ) ;// Random sine 
}// End of if(flag_AA == 5) 

{ 

g = ceil ( f_ex) ; 
z = f _ex + 0.5; 

if (g >= Z) 

v = floor (f_ex); 

else 

V = g; 

if(flag21 =**= 1)// Excitation On/Off switch 

{ 

f_excite = v; 

} 

> 


NASA/TM— 2001-210701 


37 


FIVEAXW.C 


813 

814 

815 

816 

817 

818 

819 

820 
821 
822 

823 

824 

825 

826 

827 

828 

829 

830 

831 

832 

833 

834 

835 

836 

837 

838 

839 

840 

841 

842 

843 

844 

845 

846 

847 

848 

849 

850 

851 

852 

853 

854 

855 

856 

857 

858 

859 

860 
861 
862 

863 

864 

865 

866 
867 
8 68 

869 

870 


X = X + 0 . 002 ; 

}// End of if (flags == 1) / / <4> 

else 

if{flag6 =*= 1)// <5> 

{ 

while (k <= 40)// Forty terms in series 

{ 

ex - ex + (1 . 0/ (2 .0*k+l. 0) ) *sin (2 . 0* (2 . 0*k+l) *0*M_PI*x) ; ’ 
k++; // Square wave pulse train 

} 

f_ex = t04 + t04 * (4.0 /M_PI ) * ex; 

■ ‘ { 

g = ceil(f_ex); 
z = f ex + 0.5; 

if (g >= z) 

v = floor{f_ex); 

else 

v = g; 

if (f lag2 1 == 1)// Excitation On/Off switch 

{ 

f_excite = v / 2 ; 

} 

} 

X = X + 0.002; 
k - 0; 

}// End of if(flag6 == 1) / / <5> 

else 

if {f lag7 *= 1)// <6> 

{ 

while (k 40)// Forty terms in series 

{ 

ex = ex + (1. 0/ (2 .0*k+1.0) ) *sin(2 . 0* (2 . 0*k+l) *0*M_PI*x) ; 

// Square wave 

f_ex = 1 04 * (4.0/M_PI) * ex; 

{ 

g = ceil (f_ex) ; 
z = f _ex + 0.5; 

if {g >= z) 

v = floor (f_ex) ; 
else 

v = g; 

if(flag21 == 1)// Excitation On/Off switch 

{ 

f_excite - v; 

} 

} 

X =* X + 0.002; 
k - 0; 

}// End of if (flag7 =* 1) / / <6> 


N AS A/TM— 200 1 -2 1 070 1 


38 



FIVEAXW, C 


871 

872 

873 

874 

875 

876 

877 

878 

879 

880 
881 
882 

883 

884 

885 

886 

887 

888 

889 

890 

891 

892 

893 

894 

895 

896 

897 

898 

899 

900 

901 

902 

903 

904 

905 

906 

907 

908 

909 

910 

911 

912 

913 

914 

915 

916 

917 

918 

919 

920 

921 

922 

923 

924 

925 

926 

927 

928 


else 

if (flag8 == 1)// <7> 

{ 

while (k <= 40)// Forty terras in series 

{ 

ex = ex + (pow (-1 , k) /pow { (2 . 0*k+l . 0) , 2) ) *sin (2 . 0* (2*k+l) *0*M_PI*x) 
k++; // Saw tooth 

} 

f_ex = t04 * (8 . 0/pow (M_PI , 2) ) * ex; 

{ 

g = ceil(f_ex); 
z = f _ex + 0.5; 

if (g >= z) 

v = floor (f_ex) ; 

else 

v = g; 

if ( f lag21 == 1)// Excitation On/Off switch 

{ 

f_excite = v; 

} 

} 

X * X + 0.002; 
k = 0; 

}// End of if (flag8 == 1) / / <7> 

else 

if(flag9 ** 1}// <9> 

{ 

C = PW; 

while (kl <= 40)// Forty terms in series 

{ 

ex = ex + (pow(-l,kl) /kl) *sin (kl*0*M_PI*C) *cos (2 . 0*kl*O*M_PI*x) ; 
kl++; // Single square pulse 

} 

f_ex = 1 04 * (O * c + (2 . 0/M__PI) * ex); 

{ 

g = ceil (f_ex) ; 
z = f _ex + 0.5; 

if (g >= z) 

v = floor ( f_ex) ; 

else 

v = g; 

if(flag21 =» 1)// Excitation switch 

{ 

f_excite = v; 

} 

} 

X = X + 0.002; 
kl = 1; 

}// End of if(flag9 «= 1) / / <8> 


NAS AAM— 200 1 -2 1 070 1 


39 



FIVEAXW . C 


929 

930 

931 

932 

933 

934 

935 

936 

937 

938 

939 

940 

941 

942 

943 

944 
94 5 

946 

947 

948 

949 

950 

951 

952 

953 

954 

955 

956 

957 

958 

959 

960 

961 

962 

963 

964 // 

965 

966 

967 

968 // 

969 

970 

971 

972 

973 

974 

975 

976 

977 

978 

979 

980 

981 

982 

983 

984 

985 

986 


else 

if (flagl2 == 1) // <9> 

{ 

while (k <= 40)// Forty terms in series 

{ 

ex = ex + (1.0/pow( (2. 0*k+l. 0) # 2) ) *cos(2.0* (2.0*k+1.0)*0*M_J>I*x) ; 

// Single triangular pulse 

f_ex = t04 * (0.5 - (4 . 0/pow (M_PI , 2 ) ) * ex); 

{ 

g = ceil (f_ex) ; 
z = f _ex + 0.5; 

if (g >= z) 

v = floor (f_ex) ; 

else 

v = g; 

if(flag21 1)// Excitation On/Off switch 

{ 

f_excite = v; 

} 

} 

X = x + 0.002; 
k = 0; 

}// End of if(flagl2 1) / / <9> 

else 

if (f lag!3 == 1)// <0> 

{ 

while (kl <= 40)// Forty terms in series 

{ 

ex = ex + (pow(-l, (kl+l) ) / (kl*l . 0) ) *sin (2 . 0*kX*0*M_PI*x) ; // Saw tooth 
ex = ex + (l/kl) *sin (kl*0*M_PI*x) ; 
kl + + ; 

} 

f_ex = t04 + {2.0 /M_P I ) * ex; 
f_ex = t04 * (0.5 - 1.0/M_PI * ex); 

{ 

g = ceil(f_ex); 
z * f _ex + 0.5; 

if (g >= z) 

v = floor { f_ex) ; 
else 

v = g; 

if(flag21 == 1)// Excitation On/Off switch 

{ 

f_excite * v; 

} 

} 

X - X + 0 . 002 ; 
kl = 1; 

}// End of if (flagl3 == 1) / / <0> 

)// End of if(switchl -= 0) 


NASA/TM— 2001-210701 


40 



FIVEAXW.C 


987 

988 // 

989 

990 // 

991 

992 

993 

994 

995 

996 

997 

998 

999 

1000 // 
1001 
1002 // 

1003 // 

1004 // 

1005 

1006 

1007 

1008 

1009 

1010 
1011 
1012 

1013 

1014 

1015 

1016 

1017 

1018 

1019 

1020 
1021 
1022 /* 

1023 

1024 

1025 

1026 

1027 

1028 

1029 

1030 

1031 

1032 

1033 

1034 

1035 

1036 */ 

1037 

1038 

1039 // 

1040 

1041 // 

1042 // 

1043 // 

1044 // 


********************* End of signs 1 


generation block 


******************** 


********************* External Excitation input Block ******************* 

if (switchl == 1)// External excitation flag 

{ 

if (flag21 == 1)// Excitation On/Off switch 

{ 

f_excite = f_excite2;// Da tel input channel #3 on board #2 

} 

} 


***************** En £ Q f External Excitation Block *************** 

************************************************* ***** 

* This block is used to output tfte excitation signal * 
****************************************************** 

if { test_signal == 1) 

{ 

if ( f lagl6 == 0) 

outport (out_chanl__0 , (f_excite + t48) ) ; // Board 1 

else 

if(flagl6 == 1) 

{ 

asm{ 

mov dx, [out_chanl_0] 
mov ax, [f_excite] 
add ax, [t48] 
out dx, ax 

} 

} 

if (flaglG == 0) 

outport (out _chan2_0, ( f_excite + 1 48);// Board 2 

else 

if(flag!6 *=5 1) 

{ 

asm{ 

mov dx, [ out_chan2_0 ] 
mov ax, [f_excite] 
out dx, ax 

} 

} 

}// End of if (test_signal 1) 

★*++**+*+***** End of signal generator block ************** 

********************************** 

* This block is used to generate * 

* the One - Per - J?ev signal * 
********************************** 


NASA/TM— 200 1 -21070 1 


41 



FIVEAXW.C 


1045 

1046 

1047 

1048 

1049 

1050 

1051 

1052 

1053 

1054 

1055 

1056 

1057 

1058 

1059 

1060 
1061 
1062 

1063 

1064 

1065 

1066 

1067 

1068 

1069 

1070 

1071 

1072 

1073 

1074 

1075 

1076 

1077 

1078 

1079 

1080 
1081 
1082 

1083 

1084 

1085 

1086 

1087 

1088 

1089 

1090 

1091 

1092 

1093 

1094 

1095 

1096 

1097 

1098 

1099 

1100 
1101 
1102 


if(flag_II =« 1)// one_per_rev set to on 

{ 

THETA = II * (PI2_0_Nticks * i_rev) ; 

} 

{ 

f_excite_cos = f_excite * cos (THETA ) ;// X - AXIS 
f_excite_sin = f_excite * sin (ns*THETA) ;// Y - AXIS 

) 

if (f lagl8 == 1) 

{ 

delay (6 0) ;// Delay 60 milli sec „ - used for diagnostic purposes 

if (diag == 1)// Display # of period length(s) only in diagnostic mode 

gotoxy (25 , 22) ; textcolor (11) ; 
cprintf { ”%5 . IE ” , x - 0.002); 

gotoxy (25 , 23) ? 

printf ( 11 ");// Erase y: display 

} 

gotoxy (14 , 25) /textcolor (15) ; 
cprintf ( M %5d, %4u 0 , f_excite , n) ; 

}// End of if (flagl8 ■■ l) 

if (n == 500)// Test for maximum # of loops in one period length 

x = x + 0.002; 

if (x > LIM) 

{ 

x = 0.0;// Resets x to zero 

} 

}// Ene of if (n == 500) 

ex = 0;// Summed ex values zeroed 

if(flag_Il « 1)// onejper^rev set to on 

{ 

if (one _per__rev < trigger)// No pulse condition , One_per_rev is < O.lv 
rise = 1; 
if (rise == l) 

if (one_per_rev >= trigger)// --> A pulse 

{ 

rise = 0; 

N_ticks « j_rev;// # of loops in one revolution of the shaft 
if (N_ticks =» 0) 

N_ticks = 1 ; 

PI2_o_Nticks = PI2/N_ticks ; // Shaft radians per loop 
i_revl = (phi/360.0) * N_ticks;// phi: (0.0 --> 360.0) deg. 

g * ceil (i_revl) ; 
z = i_revl + 0.5; 

if (g >= z) 

v - f loor (i_revl) ; 

else 


NASA/TM— 2001 -2 10701 


42 



FIVEAXW.C 


1103 


V = g; 

1104 



1105 


i rev = v;// After one shaft rotation i rev = 0 

1106 


} 

1107 


j_rev = 0;// After one revolution of shaft. 

1108 


}// End of if (onejper_rev >= trigger ) . 

1109 



1110 


i_rev++; // Loop counter for one shaft rotation 

1111 


// used to calculate (THETA). 

1112 



1113 


j_rev++; // Loop counter for one shaft rotation 

1114 


// used to calculate (PI2 o Nticks) . 

1115 


if(i_rev > N_ticks) 

1116 


i_rev = i_rev - N_ticks; 

1117 


}// End of if(flag_II =* 1) 

1118 



1119 

// 

************** of One - Per - i?ev block ************** 

1120 



1121 

if (flag!6 == 0)// Non assembly condition , 

1122 

{ 


1123 


// Commands board (1) to read next input value 

1124 


outport (0x300 , one); 

1125 


outport (FIF01, two) ; 

1126 


outport (0x300, Oxe) ; 

1127 



1128 


// Commands board (2) to read next input value 

1129 


outport (0x360 , one); 

1130 


outport (FIF02 , two); 

1131 


outport {0x360 , Oxe); 

1132 

} 


1133 



1134 

else 

1135 



1136 

if (flaglS «= 1)// Assembly condition 

1137 

{ 

// Commands hoard (1) to read next input value 

1138 


asin{ 

1139 


mov dx, 0x300 

1140 


mov ax, [one] 

1141 


out dx, ax 

1142 


} 

1143 


asm{ 

1144 


mov dx, [FIFOl] 

1145 


mov ax, [two] 

1146 


out dx, ax 

1147 


} 

1148 


asm{ 

1149 


mov dx, 0x300 

1150 


mov ax, Oxe 

1151 


out dx, ax 

1152 


} 

1153 

// ************************* 

1154 


// Commands board (2) to read next input value 

1155 


asm{ 

1156 


mov dx, 0x360 

1157 


mov ax, [one] 

1158 


out dx , ax 

1159 


} 

1160 


asxn{ 


NASA/TM— 200 1-210701 


43 


FIVEAXW.C 


1161 

mov 

dx, 

[FIF02] 

1162 

mov 

ax, 

[two] 

1163 

out 

dx. 

ax 

1164 

} 



1165 

asm{ 



1166 

mov 

dx, 

0x360 

1167 

mov 

ax. 

Oxe 

1168 

out 

dx, 

ax 


1169 } 

1170 }// End of if (flagl6 =« 1) 

1171 

1172 if {flaglO — 0)// Non modal condition 

1173 { 

1174 // ***************************** LOWER BEARING **************************** 

1175 

1176 if (f lagl — 1} 

1177 { 

1178 

1179 // * * * Begin x_force_bot calc * * * 

1180 

1181 xbotderiv = xbot - x_bot_old3 ; 

1182 

118 3 // * * * Calculate x_force_bot * * * 

1184 

118 5 x_f orce_bot = ( ( (kh_bot * xbot + dh__bot * xbotderiv) * MCG) 

86 - tBias_bot) + f _excite_cos ; 

1187 x_pos_output_bot = - x_f orce_bot - bias_current_bot ; 

1188 x_neg_output_bot = - x_force_bot + bias_current_bot ; 

1189 

1190 // * * * OUTPUTS FOR x_direction_bot * * * 

1191 

1192 // *****+++*+R0UNDING BLOCK ********** 


1193 

g = ceil (x_pos_output_bot } ; 

1194 

z = x_j?os_output_bot + 0.5; 

1195 


1196 

if (g >= z) 

1197 

v =* floor (x_pos_output_bot) ; 

1198 

else 

1199 

< 

ii 

tq 

1200 


1201 

round2 = v + t48; 

1202 // 

*********************************** 

1203 


1204 

if(round2 < out min) 

1205 

{ 

1206 

if (flagl6 == 0) 

1207 

outport (out_chanl__l , out min] 

1208 


1209 

else 

1210 


1211 

if(flagl6 == 1) 

1212 

{ 

1213 

asm{ 

1214 

mov dx, [out_chanl 1] 

1215 

mov ax, rout_min] 

1216 

out dx , ax 

1217 

} 

1218 

} 


N AS A/TM — 200 1-210701 


44 



FI VEAXW . C 


1219 

1220 
1221 
1222 

1223 

1224 

1225 

1226 

1227 

1228 

1229 

1230 

1231 

1232 

1233 

1234 

1235 

1236 

1237 

1238 

1239 

1240 

1241 

1242 

1243 

1244 

1245 

1246 

1247 

1248 

1249 

1250 

1251 

1252 

1253 

1254 

1255 

1256 

1257 

1258 

1259 

1260 
1261 
1262 

1263 

1264 

1265 

1266 

1267 

1268 

1269 

1270 

1271 

1272 

1273 

1274 

1275 

1276 


}// End of if (round2 < out_jnin; 

else 

if(round2 > out_max) 

{ 

if(flagl6 == 0) 

outport (out_chanl_l , out_max) ; 

else 

if(flagl6 1) 

{ 

asm{ 

mov dx, [out_chanl_l] 
mov ax, [out_max] 
out dx, ax 

} 

} 

}// End of if (round2 > outjnax) 

else 


{ 

if(flagl6 == 0) 

outport (out_chanl_l, round2);// HORIZ . (RIGHT) 

else 

if{flagl6 == 1) 

{ 

asm{ 

mov dx, [out_chanl_l] 
mov ax, [round2] 
out dx, ax 

} 

} 

} 

// ******* ***ROUNDING block *********** 
g 1 - * ceil <x_neg_output_bot) ; 
z = x_neg_output_bot + 0.5; 

if (g >= z) 

v - f loor (x_neg_output_bot) ; 

else 

v - g; 

round2 = v + t48; 

// *********************************** 

if (round2 < out_min) 

{ ' 

if(flagl6 «« 0) 

outport (out_chanl_2 , out_min) 

else 

if(flag!6 == 1) 


NASA/TM — 200 1 - 2 1 070 1 


45 


FIVEAXW.C 


1277 

{ 

1278 

asm{ 

1279 

mov dx, [out_chanl_2] 

1280 

mov ax, [out_min] 

1281 

out dx, ax 

1282 

} 

.1283 

} 

1284 

1285 

}// End of if (round2 < outjmin) 

1286 

1287 

else 

1288 

if(round2 > out max} 

1289 

{ 

1290 

if(flagl6 == 0) 

1291 

1292 

outport (out_chanl_2 , out_max] 

1293 

1294 

else 

1295 

if (f lagl6 == 1) 

1296 

{ 

1297 

asm{ 

1298 

mov dx, [out^chanl 2] 

1299 

mov ax, [out_max] 

1300 

out dx, ax 

1301 

} 

1302 

} 

1303 

1304 

}// JEnd of if (round2 > out_max) 

1305 

1306 

else 

1307 

{ 

1308 

if {flagl6 == 0) 

1309 

1310 

outport {out_chanl_2 , round2 ) ; 

1311 

1312 

else 

1313 

if(flagl6 == 1) 

1314 

{ 

1315 

asm{ 

1316 

mov dx, [out_chanl_2] 

1317 

mov ax, [round2] 

1318 

out dx , ax 

1319 

} 

1320 

} 

1321 

1322 

} 


// x_bol_old5 
// x_bot_old4 
x_bot_old3 
x_bot_old2 
x bot oldl 


1323 

1324 

1325 

1326 

1327 

1328 

1329 // 

1330 

1331 // * 

1332 

1333 ybotderiv 

1334 


x_bot_o!d4; 
x_Jbot_o!d3; 
x_bot_old2 ; 
x_bot_oldl ; 
xbot ; 

* * * End x_force_bot * * * 
* Begin y_£orce_bo t calc * * * 
= ybot - y_bot_oId3; 


NASA/TM — 2001-210701 


46 



FIVEAXW.C 


1335 // * * * Calculate y_force_bot * * * 

1336 

1337 y_force_bot « ( ( <kv_bot * ybot + dv_bot * ybotderiv) * MCG) 

333 8 - wBias_bot) + f_excite_sin; 

1339 y_pos_output_bot => y_force_bot - bias_current_bot ; 

1340 y_neg_output_bot - y_force_bot + bias_current_bot ; 

1341 

1342 // * * * OUTPUTS FOR y_direction bot * * * 

1343 

1344 // **+*******ROUNDING BLOCK ********** 


1345 

g = ceil (y_pos_output_bot) ; 

1346 

z = y_pos__output_bot + 0.5; 

1347 

1348 

if (g >= z) 

1349 

v = floor (y_pos_output_bot) ; 

1350 

else 

1351 

V * g ; 

1352 

1353 

round2 = v + t48; 

1354 // 

**★*★** + *■* + + + * + ** + * + *■* + *★*★ + ■* + ★ + * + * 

1355 

1356 

if(round2 < out min) 

1357 

{ 

1358 

if {flagl6 -= 0) 

1359 

outport (out_chanl_3, out_min) 

1360 

1361 

else 

1362 

1363 

if (f lagl6 — 1) 

1364 

{ 

1365 

asm{ 

1366 

mov dx, [out_chanl_3] 

1367 

mov ax, [out__min] 

1368 

out dx, ax 

1369 

} 

1370 

} 

1371 

}// End of if (round2 < out_min) 

1372 

1373 

else 

1374 

1375 

if(round2 > out max) 

1376 

{ 

1377 

if ( f lagl6 == 0) 

1378 

outport (out_chanl_3, out_max) 

1379 

1380 

else 

1381 

1382 

if (f lagl6 — 1) 

1383 

{ 

1384 

asm{ 

1385 

mov dx, [out_chanl_3] 

1386 

mov ax, [out max] 

1387 

out dx, ax 

13B8 

} 

1389 

} 

1390 

}// End of if (round2 > out_max) 

1391 

1392 

else 


NASA/TM — 200 1-210701 


47 


FIVEAXW . C 


1393 

1394 

1395 

1396 

1397 

1398 

1399 

1400 

1401 

1402 

1403 

1404 

1405 

1406 

1407 
1406 

1409 // 

1410 

1411 

1412 

1413 

1414 

1415 

1416 

1417 

1418 

1419 // 

1420 

1421 

1422 

1423 

1424 

1425 

1426 

1427 

1428 

1429 

1430 

1431 

1432 

1433 

1434 

1435 

1436 

1437 

1438 

1439 

1440 

1441 

1442 

1443 

1444 

1445 

1446 

1447 

1448 

1449 

1450 


{ 

if ( f lag!6 *= 0) 

outport (out_chanl_3 , round2) ;// VERT, (TOP) 

else 

if{flag!6 == 1) 

{ 

asm { 

mov dx, [out_chanl_3] 
mov ax, [round2] 
out dx, ax 

} 

} 

} 

********* * ROUNDING BLOCK ********** 
g = ceil (y_neg_output_bot) ; 
z = y_neg_output_bot + 0,5; 

if (g >- z) 

v = f loor (y_neg_output_bot) ; 
else 

v = g? 

round2 = v + t48; 

************************************ 

if {round2 < out_min) 

{ 

if (flagie == 0) 

outport (out_chanl_4 , out_min) ; 

else 

if{flagl6 == 1) 

{ 

asm{ 

mov dx, [out_chanl_4] 
mov ax, [out_min] 
out dx, ax 

} 

} 

}// End of if (round2 < out_min) 

else 

if (round2 > out_max) 

{ 

if (f lagl6 == 0) 

outport (out_chanl_4, out_max) ; 

else 

if(flagl6 1) 

{ 

asxn{ 

mov dx, [out_chanl_4] 



NAS A/TM — 200 1-210701 


48 



FIVEAXW . C 


1451 

1452 

1453 

1454 

1455 

1456 

1457 

1458 

1459 

1460 

1461 

1462 

1463 

1464 

1465 

1466 

1467 

1468 

1469 

1470 

1471 

1472 

1473 

1474 

1475 

1476 

1477 

1478 

1479 

1480 

1481 

1482 

1483 

1484 

1485 

1486 

1487 

1488 

1489 

1490 

1491 

1492 

1493 

1494 

1495 

1496 

1497 

1498 

1499 

1500 

1501 

1502 

1503 

1504 

1505 

1506 

1507 

1508 


} 


} 


mov ax, [out_max] 
out dx, ax 


}// End of if (round2 > out_max) 

else 

{ 

if(flagl6 == 0) 

outport (out_chanl_4 , round2);// VERT, (BOTTOM) 

else 

if (f lagl6 «= 1) 

{ 

asn{ 

mov dx, [out_chanl__4] 
mov ax , [ r ound2 ] 

out dx, ax 

} 

} 

} 


// y_bot_old5 = y_hot_old4 ; 
// y_bot_old4 m y_bot_old3 ; 
y_bot_old3 = y_bot_old2; 
y_bot_old2 = y_bot_oldl; 
y__bot_oldl = ybot ; 


// 

// 


* * * End y_force__bot * * * 

* * * Safe Gain * * * 


if (sgl == 1) 
goto LI; 


else 

goto L2 ; 
Ll: { 


// 


} 


if { (xbot * xbot + ybot * ybot) > safe) 

{ 

kh_bot = 1.5; kv_bot = kh_bot ; 
dh_bot * 9.0; dv_bot = dh_bot ; 

} 

goto L2 ; 


* * * End Safe Gain * * * 
}// End of if (flag-1 -= 1) 

L2 : 

if (diag == 1) 

{ 

if (f lag4d «= 1) 

{ 


NAS A/TM— 2001-210701 


49 


FIVEAXW.C 


1509 if (f lag4a -= l) 

1510 { 

1511 // junk = exp (1. 34567) ; 

1512 // junk - exp (1 . 34567) ; 

1513 junk = exp (1 . 34567) ; 

1514 junk = exp(l. 34567) ; 

1515 junk - exp(l. 34567) ; 

1516 junk = exp(l. 34567) ; 

1517 junk = COS(l. 34567) ; 

1518 junk = cos (1 . 34567) ; 

1519 // junk = cos (1 . 34567) ; 

1520 // junk = cos (1 . 34567) ; 

1521 // junk = cos (1 . 34567) ; 

1522 }// End of if (flag4a == 1) 

1523 }// 2nd of if(flag4d == 1) 

1524 }// End of if(diag == 1) 

1525 

1526 // *************************** UPPER BEARING ******************************* 

1527 

1528 if (f lag2 == 1) 

1529 { 

1530 // * * * Begin x_force_top calc * * * 

1531 

1532 xtopderiv = xtop - x_top_old3 ; 

1533 

1534 // * * * Calculate x_force_top * * * 

1535 

1536 x_force_top = ( ( (kh_top * xtop + dh_top * xtopderiv) * PCG) 

1537 - tBias_top) + JJ * f_excite_cos ; 

1538 x__pos output top = - x_force_top - bias_current_top ; 

153 9 x__neg_output_top = - x_force_top + bias_current_top; 

154 0 

1541 // * * * OUTPUTS FOR x_direction_top * * * 

1542 

1543 // **********ROUNDING BLOCK********** 

1544 g = ceil (x_pos_output_top) ; 

1545 z * x_pos_output_top + 0.5; 

1546 

1547 if (g >= z) 

1548 v - f loor (x_pos_output_top) ; 

1549 else 

1550 v = g; 

1551 

1552 round2 = V + t48; 

1553 // *********************************** 

1554 

1555 if (round2 < out_min) 

1556 { 

1557 if {f lagl6 == 0) 

1558 outport (out_chan2_l , out_min) ; 

1559 

1560 else 

1561 

1562 if (f lagl6 =;= 1) 

1563 { 

1564 asm{ 

1565 mov dx, [out_chan2_l] 

1566 mov ax, [out_min] 


NASA/TM— 2001-210701 


50 


FIVEAXW.C 


1567 

1568 

1569 

1570 

1571 

1572 

1573 

1574 

1575 

1576 

1577 

1578 

1579 

1580 

1581 

1582 

1583 

1584 

1585 

1586 

1587 

1588 

1589 

1590 

1591 

1592 

1593 

1594 

1595 

1596 

1597 

1598 

1599 

1600 
1601 
1602 

1603 

1604 

1605 

1606 

1607 

1608 

1609 

1610 
1611 
1612 

1613 

1614 

1615 

1616 

1617 

1618 

1619 

1620 
1621 
1622 

1623 

1624 


out dx, ax 

} 

} 

}// End of if (round2 < out^min) 

else 

if (round2 > out_max) 

{ 

if{flagl6 == 0) 

outport (out_chan2_l, out_max) ; 

else 

if (flagl6 == 1) 

{ 

asm{ 

mov dx, [out_chan2_l] 
mov ax, [out_max] 
out dx, ax 

} 

) 

}// End of if (round2 > ou t_wax) 

else 


{ 

if(flagl6 -■ 0) 

outport (out_chan2_l, round2) ;// HORIZ. (RIGHT) 

else 


if (f lagl6 » 1) 

{ 

asm{ 

mov dx, [out_chan2_l] 
mov ax, [round2] 
out dx , ax 

} 

} 

} 

// **********xoUNDING BLOCK********** 
g = ceil (x__neg_output_top) ; 
z * x_neg_output_top + 0.5; 

if (g >= z) 

v - floor (x_neg_outpu t__ top) ; 

else 

v = g; 

round2 - v + t48; 

// *******+****+*+*★+*************+*** 


if(round2 < out_min) 

{ 

if(flagl6 -= 0) 

outport (out_chan2_2, out_min) ; 


NASA/TM — 2001-210701 


51 


FIVEAXW.C 


1625 

1626 

else 

1627 

if(flagl6 == 1) 

1628 

{ 

1629 

asm{ 

1630 

mov dx, [out_chan2_2] 

1631 

mov ax, [out_min] 

1632 

out dx, ax 

1633 

} 

1634 

} 

1635 

1636 

}// End of if (round2 < out_min) 

1637 

1638 

else 

1639 

if(round2 > out max) 

1640 

{ 

1641 

if (f lagl6 *■ 0 ) 

1642 

1643 

outport (out_chan2_2 , out max) 

1644 

1645 

else 

1646 

if(flag!6 == 1) 

1647 

{ 

1648 

asm{ 

1649 

mov dx, [out_chan2_2] 

1650 

mov ax, [out_max] 

1651 

out dx , ax 

1652 

} 

1653 

} 

1654 

1655 

}// End of if (round2 > out max) 

1656 

1657 

else 

1658 

{ 

1659 

if (flagl6 == 0) 

1660 

1661 

outport (out_chan2_2 , round2 ) ; , 

1662 

1663 

else 

1664 

if(flag!6 ■ ■ 1) 

1665 

{ 

1666 

asm{ 

1667 

mov dx, [out_chan2 2] 

1668 

mov ax, [round23 

1669 

out dx, ax 

1670 

} 

1671 

} 

1672 

1673 

} 

1674 // 

x_top_old5 = X_top_old4; 

1675 // 

x_ top_ol d4 = x_top_ol d3 ; 

1676 

x_top_old3 = x_top_old2 / 

1677 

x_top_old2 = x top_oldl; 

1678 

1679 

x_top_oldl » xtop ; 

1680 // 
1681 

* + * End x force^top * * * 

1682 // 

* * * Begin y_force_top calc * 


NASA/TM— 2001-210701 


52 


FIVEAXW.C 


1683 

1684 ytopderiv = ytop - y_top_old3; 

1685 

1686 // * * * Calculate y_force_top * * * 

1687 

1688 y_force_top = ( { (kv_top * ytop + dv_top * ytopderiv) * PCG) 

1689 - wBias_top) + f_excite_sin; 

1690 y_pos_output_top = y_force_top - bias_current_top ; 

1691 y_neg__output_top = y_force_top + bias_current_top; 

1692 

1693 // * + * OUTPUTS FOR y_direction_top * * * 

16 94 

1695 // +*********R0UNDING BLOCK ********** 


1696 


g = ceil (y_pos_output_top) ; 

1697 


z * y_pos_output_top + 0.5; 

1698 



1699 


if (g >= z) 

1700 


v = f loor (y_pos_output_top) ; 

1701 


else 

1702 


v = g; 

1703 



1704 


round2 = v + t48; 

1705 // 

************************************ 

1706 



1707 

if{round2 < out min) 

1708 

{ 


1709 


i£(flagl6 =»= 0) 

1710 


outport (out_chan2_3 , out_min) ; 

1711 



1712 


else 

1713 



1714 


if (f lagl6 ==* 1) 

1715 


{ 

1716 


asm{ 

1717 


mov dx, [out_chan2_3] 

1718 


mov ax, [out_min] 

1719 


out dx, ax 

1720 


} 

1721 


} 

1722 

} 


1723 



1724 

else 

1725 



1726 

if(round2 > out max) 

1727 

{ 


1728 


i£{flagl6 == o) 

1729 


outport (out_chan2_3 , out_max) ; 

1730 



1731 


else 

1732 



1733 


if (f lag!6 »= 1) 

1734 


{ 

1735 


aszn{ 

1736 


mov dx, [out_chan2_3] 

1737 


mov ax, [out max] 

1738 


out dx , ax 

1739 


} 

1740 


} 


NASA/TM— 2001-210701 


53 


FIVEAXW . C 


1741 

1742 

1743 

1744 

1745 

1746 

1747 

1748 

1749 

1750 

1751 

1752 

1753 

1754 

1755 

1756 

1757 

1758 

1759 

1760 // 

1761 

1762 

1763 

1764 

1765 

1766 

1767 

1768 

1769 

1770 // 

1771 

1772 

1773 

1774 

1775 

1776 

1777 

1778 

1779 

1780 

1781 

1782 

1783 

1784 

1785 

1786 

1787 

1788 

1789 

1790 

1791 

1792 

1793 

1794 

1795 

1796 

1797 

1798 


} 

else 

{ 

if (f laglS == 0) 

outport (out_chan2_3 , round2);// VERT. (TOP) 

else 

if (f lagl6 =« 1) 

{ 

asm{ 

mov dx, [out_chan2_3] 
mov ax, [round2] 
out dx , ax 

} 

} 

} 

********* GROUNDING BLOCK * ********** 
g = ceil (y_neg_output_top) ; 
z = y__neg_output_top + 0.5; 

if (g >= z) 

v = f loor (y_neg_output_top) ; 

else 

v - g; 

round2 - v + t48; 

*********★******+****+************** 

i£(round2 < out_min) 

{ 

if(flagl6 =« 0} 

outport (out_chan2_4 , out_min) ; 

else 

if (flagl6 == l) 

{ 

asm{ 

mov dx, [out_chan2_4] 
mov ax, [out_min] 
out dx, ax 

} 

} 

} 

else 

if (round2 > out_max) 

{ 

if(flagl6 0) 

outport (out_chan2_4 , out_max) ; 

else 

if (f lagl6 « 1) 


NASA/TM— 2001-210701 


54 



FIVEAXW.C 


1799 

1800 
1801 
1802 

1803 

1804 

1805 

1806 

1807 

1808 

1809 

1810 
1811 
1812 

1813 

1814 

1815 

1816 

1817 

1818 

1819 

1820 
1821 
1822 

1823 

1824 

1825 

1826 

1827 

1828 

1829 

1830 

1831 

1832 

1833 

1834 

1835 

1836 

1837 

1838 

1839 

1840 

1841 

1842 

1843 

1844 

1845 

1846 

1847 

1848 

1849 

1850 

1851 

1852 

1853 

1854 

1855 

1856 


{ 

asxn{ 

mov dx, [out_chan2_4] 
mov ax, [out_max] 
out dx, ax 

} 

} 

} 

else 

{ 

if (f lagl6 == 0) 

outport (out_chan2_4 , round2) ;// VERT . (BOTTOM) 

else 

if(flagl6 == 1) 

{ 

asm{ 

mov dx, [out_chan2_4 3 
mov ax, Cround2] 
out dx , ax 

} 

} 

} 

// y_top_old5 = y_top__old4 ; 

// y_top_old4 - y_top_old3 ; 

Y_top_old3 = y_top_old2; 
y_top_old2 = y_top_oldl; 
y_top_oldl = ytop; 

// * * * End y_force_top * * * 

// * * * Safe Gain * * * 

if (sg2 == 1} 
goto U1 ; 

else 

goto U2 ; 

Ul: { 

if ( (xtop * xtop + ytop * ytop) > safe) 

{ 

kh_top = 1.5; kv_top = kh_top ; 
dh_top = 9.0; dv_top = dh_top; 

} 

goto U2; 

} 

// * * * End Safe Gain * * * 

}// End of if (flag2 =» 1) 

U2 : 

if (diag == 1) 


NAS A/TM— 200 1 -2 1 070 1 


55 



FIVEAXW . C 


1857 { 

1858 if (flag4d == 1) 

1859 { 

1860 if (flag4b == l) 

1861 { 


1862 

// 

junk 

= 

exp (1.3456 7) 

1863 

// 

junk 


exp (1. 34567) ; 

1864 


junk 

= 

exp (1.34567) ; 

1865 


junk 

= 

exp (1.34567) ; 

1866 


junk 

= 

exp (1.34567) ; 

1867 


junk 

= 

exp (1 . 34567) 

1868 


junk 


COS (1.34567) ; 

1869 


junk 

= 

cos (1.34567) ; 

1870 

// 

■ junk 

= 

cos (1.34567) ; 

1871 

// 

junk 


cos (1.34567) ; 

1872 

// 

junk 

= 

cos (1.34567) ; 


1873 }// End of if (diag == 1) 

18 74 }// End of if(flag4d == 1) 

1875 }// End of if (flag4b == 1) 

1876 }// End of if (flaglO 0) 

1877 

1878 // ************************** MODAL CONTROL BLOCK ************************** 

1879 

1880 if{flagl0 *== 1)// Modal condition 

1881 { 

1882 // ****************** Centralized Rigid Body Translation ***************** 

1883 

1884 Xav = xbot * MCG + xtop * PCG; 

1885 Yav = ybot * MCG * ytop * PCG; 

1886 


1887 

xbot_force_tr = (-(kh bot 


kh_top) 

+ 

Xav - 

( dh_bot 

+ 

dh_top) 

* 

dotXav) 

1888 

1889 

xtop_force_tr = (~(kh_bot 

+ 

kh_top) 

* 

Xav - 

(dh_bot 

+ 

dh_top) 

* 

dotXav) 

1890 

ybot_force_tr = {-{kv_bot 

+ 

kv_top) 

* 

Yav - 

(dv_bot 

+ 

dv_top ) 

* 

dot Yav) 

1891 

1892 

ytop_force_tr - ( - (kv_bot 

+ 

kv_top) 

* 

Yav - 

(dv_bot 


dv_top) 

* 

dot Yav) 


1893 F_XB_tr - xbot_force_tr * MCG;// F1_X 

1894 F_XT_tr * xtop_force_tr * PCG;// F2_X 

1895 ” 

1896 F_YB_tr * ybot_f orce_tr * MCG;// FI Y 

1897 F_YT_tr - ytop_force_tr * PCG;// F2 Y 

1898 

1899 // ****************** Centralized Rigid Body Rotation ******************** 

1900 

1901 The taX » xbot - xtop; 

1902 ThetaY = ybot - ytop; 

1903 

1904 k_tilt = kh__top * MCG * MCG + khjoot * PCG * PCG; 

1905 c_tilt = dh_top * MCG * MCG + dh_bot * PCG * PCG; 

1906 

1907 xtop_force_rot » k_tilt * ThetaX + c_tilt * dotThetaX; 

1908 xbot_f orce_rot = -k_tilt * ThetaX - c_tilt * dotThetaX; 

1909 

1910 ytop_force_rot * k_tilt * ThetaY + c_ti.lt * dotThetaY; 

1911 ybot_force_rot - -k_tilt * ThetaY - c_tilt * dotThetaY; 

1912 

1913 // ********************* Centralized force summed ************************ 

1914 


N AS A/TM— 200 1 -2 1 070 1 


56 


FIVEAXW.C 


1915 

1916 

1917 

1918 

1919 

1920 

1921 

1922 

1923 

1924 

1925 

1926 

1927 

1928 

1929 

1930 

1931 

1932 

1933 

1934 

1935 

1936 

1937 

1938 

1939 

1940 

1941 

1942 

1943 

1944 

1945 

1946 

1947 

1948 

1949 

1950 

1951 

1952 

1953 

1954 

1955 

1956 

1957 

1958 

1959 

1960 

1961 

1962 

1963 

1964 

1965 

1966 

1967 

1968 

1969 

1970 

1971 

1972 


xbot_force_modal_pos - F_XB_tr + xbot_force_rot + bias_current_bot ; 
xbot_f or ce_moda l_neg * - (F_XB_tr + xbot_f orce_rot) + bias_current_bot ; 


ybot_force_modal_pos = F_YB_tr + ybot_f orce_rot - bias_current__bot ; 

ybot_force_modal_neg = - (F_YB_tr + ybot_forcejrot) - bias_current_bot ; 

// - 

xtop_force_modal_pos * F_XT_tr + xtop_f orce_rot + bias_current_top; 

xtop_force_modal_neg - - (F_XT_tr + xtop_f orce_rot ) + bias_current_top; 


ytop_force_modaljpos = F_YT_tr + xtop_f orce_rot - bias_current_top ; 
ytop_force_modal_neg = - (F_YT_tr + xtop_f orce_rot) - bias_current_top ; 

// 

x_j?os_output_bot = xbot_force_modal_pos + f_excite_cos * -1; 
x_neg_output_bot = xbot_force_modal_neg + f_excite_cos * -1; 


y_jpos_output_bot = ybot_force_modal_pos + f_excite_sin; 

y_neg_output_bot = ybot_force_modal_neg + f_excite_sin; 

// - 

x JP°s_output_top - xtop_force_modal_pos + f_excite_cos * -1 ; 

x_neg_output_top « xtop_force_modal_neg + f_excite_cos * -1; 


y_pos_output_top = ytop_force_modal_pos + JJ * f_excite_sin; 
y_neg_output_top = ytop_force_modal_neg + JJ * f_excite_sin; 

// Note that f_excite_cos is multiplied by -1 to give 
// the correct One - Per - Rev vector rotation direction . 


// ********** ROUNDING BLOCK - x_pos_ou tpu t_bot ********** 
g = ceil (x_jpos_output_bot ) ; 

2 = x__pos_output_bot + 0.5; 

if (g >= z) 

v = f loor (x_pos_output_bot) ; 

else 

v = g ; 

X_P_0_B = v + t48; 

// ************ 

if { X_P_0_B < out_min) 

{ 

if (f lagl6 == 0) 

outport (out_chanl_l , out_min) ; 

else 

if (f lagl6 == 1) 

{ 

aszn{ 

mov dx, [out_chanl_l] 
mov ax, [out_min] 
out dx, ax 

} 

} 

}// End of if (X_P_0_B < ou t_min) 

else 

if (X P O B > out max) 


NAS A/TM — 200 1-21 070 1 


57 



FIVEAXW.C 


1973 

{ 

1974 

if(flagl6 -« 0) 

1975 

1976 

outport (out_chanl_l , out_max) 

1977 

1978 

else 

.1979 

if (f lagl6 == 1) 

1980 

{ 

1981 

asm{ 

1982 

mov dx, [out_chanl_l] 

1983 

mov ax, [out_max] 

1984 

out dx, ax 

1985 

} 

1986 

} 

1987 

1988 

}// End of if (X_P_0_B > out max) 

1989 

1990 

else 

1991 

{ 

1992 

if (flagl6 == 0) 

1993 

1994 

outport (out_chanl_l , X_P_0 B) , 

1995 

1996 

else 

1997 

if (f lagl6 == 1) 

1998 

{ 

1999 

asm{ 

2000 

mov dx, [out_chanl_l] 

2001 

mov ax, [X_P_0 B] 

2002 

out dx, ax 

2003 

} 

2004 

} 

2005 

} 

2006 

// ********** ROUNDING BLOCK - x neg 

2007 

g = ceil (x_neg_output_bot) ; 

2008 

2009 

z * x_neg_output_bot + 0.5; 

2010 

if (g >= z) 

2011 

v = floor (x_neg_output_bot) ; 

2012 

else 

2013 

2014 

it 

to 

2015 

X_N_0_B = v + 1 4 8 ; 

2016 

// ************ 

2017 

if (X_N__0_B < out_min) 

2018 

{ 

2019 

if (flagl6 == 0) 

2020 

2021 

outport (out_chanl_2 , out min); 

2022 

2023 

else 

2024 

if (flagl6 == 1) 

2025 

{ 

2026 

asm{ 

2027 

mov dx, [out_chanl_2] 

2028 

mov ax, [out_min] 

2029 

out dx, ax 

2030 

} 


NASA/TM— 2001-210701 


FIVEAXW.C 


2031 

2032 

2033 

2034 

2035 

2036 

2037 

2038 

2039 

2040 

2041 

2042 

2043 

2044 

2045 

2046 

2047 

2048 

2049 

2050 

2051 

2052 

2053 

2054 

2055 

2056 

2057 

2058 

2059 

2060 
2061 
2062 

2063 

2064 

2065 

2066 

2067 

2068 

2069 

2070 

2071 

2072 

2073 

2074 

2075 

2076 

2077 

2078 

2079 

2080 
2081 
2082 

2083 

2084 

2085 

2086 

2087 

2088 


} 

}// Ei3d of if (X_N_0_B < outjmin) 

else 

if (X_N_0_B > out_max) 

{ 

if (flagl6 == 0) 

outport (out_chanl_2 , out_max) ; 

else 

if (flaglS l) 

{ 

asm{ 

mov dx, [out_chanl_2] 
mov ax, [out max] 
out dx, ax 

} 

} 

}// End of if (XJNJD__B > out_max) 

else 


{ 

if (f lagl6 == 0) 

outport {out_chanl_3 , X_N__0_B) ; 

else 

if(flagl6 == l) 

{ 

asxn{ 

mov dx, [out_chanl_2] 
mov ax, [X_N_0_B] 
out dx, ax 

} 

} 

} 

// ********** ROUNDING BLOCK - y_j)os_output__bot ********** 
g - ceil (y_j?os_output_bot) ; 

2 * y_pos_output_bot + 0.5; 

if (g >* z) 

v m floor (y_pos_output__bot) ; 

else 

v = g; 

Y_P_0_B = v + t48; 

// ************ 

if (Y_P_0_B < out_min) 

{ 

if (f lagl6 -= 0) 

outport (out_chanl_3 , out_min) ; 

else 

if (f lagl6 == 1) 


NASA/TM— 2001-210701 


59 


FIVEAXW . C 


2089 

{ 

2090 

asm{ 

2091 

mov dx, [out_chanl_3] 

2092 

mov ax, [out_min] 

2093 

out dx , ax 

2094 

} 

2095 

} 

2096 

2097 

}// End of if (Y_P_0_B < out_min) 

2098 

2099 

else 

2100 

if(Y P 0 B > out max) 

2101 

{ 

2102 

if (f lagl6 == 0) 

2103 

2104 

outport (out_chanl_3, out_max) ; 

2105 

2106 

else 

2107 

if(flagl6 =*sb l) 

2108 

{ 

2109 

asm{ 

2110 

mov dx, [out_chanl_3] 

2111 

mov ax, [out_Tnax] 

2112 

out dx, ax 

2113 

} 

2114 

} 

2115 

2116 

}// End of if (Y__P_0^_B > out max) 

2117 

else 

2118 


2119 

{ 

2120 

if (f lagl6 == 0) 

2121 

2122 

outport (out_chanl_3 , Y_P 0 B) ; 

2123 

2124 

else 

2125 

if(flagl6 «« 1) 

2126 

{ 

2127 

asm{ 

2128 

mov dx, [out_chanl_3] 

2129 

mov ax, [Y P 0 B] 

2130 

out dx , ax 

2131 

} 

2132 

} 

2133 

} 

2134 

// ********** ROUNDING BLOCK - 7 _neg_i 

2135 

g = ceil (y_neg_output_bot) ; 

2136 

2137 

z “ y_neg_output_bot + 0.5; 

2138 

if (g 2 ) 

2139 

v = floor (y_neg_output_bot) ; 

2140 

else 

2141 

2142 

v = g; 

2143 

Y_N_0_B = v + t4 8 ; 


2144 // ************ 

2145 if(Y_N_0_B < out_min) 

2146 { 


NASA/TM— 200 1 -21070 1 


FIVEAXW . C 


2147 

2148 

2149 

2150 

2151 

2152 

2153 

2154 

2155 

2156 

2157 

2158 

2159 

2160 
2161 
2162 

2163 

2164 

2165 

2166 

2167 

2168 

2169 

2170 

2171 

2172 

2173 

2174 

2175 

2176 

2177 

2178 

2179 

2180 
2181 
2182 

2183 

2184 

2185 

2186 

2187 

2188 

2189 

2190 

2191 

2192 

2193 

2194 

2195 

2196 

2197 

2198 

2199 

2200 
2201 
2202 

2203 

2204 


if(flag!6 == 0} 

outport (out_chanl_4 , out_min) ; 

else 

if(flag!6 1) 

{ 

asm{ 

mov dx, [out_chanl__4] 
mov ax, [out_min] 
out dx, ax 

} 

} 

}//' End of if (Y_N_0_B < out_min) 

else 

if (Y_N_OB > out_max) 

{ 

if (f lagl6 == 0) 

outport (out_chanl__4 , out_max) ; 

else 

if (f lagl6 1) 

{ 

asm{ 

mov dx, [out__chanl_4] 
mov ax, [out_max] 
out dx, ax 

} 

} 

}// End of if (Y_N_0_B > out_wax) 

else 


{ 

if (f lagl6 == 0) 

outport {out_chanl_4 , Y_N_0_B) ; 

else 

if (f lagl6 == 1) 

{ 

asm{ 

mov dx, [out_chanl_4} 
mov ax, [Y_N_0_B] 
out dx, ax 

} 

} 

} 

// ********** ROUNDING BLOCK - x_pos_output_top 
g = ceil (x_pos_output_top) ; 
z = x__pos_output_top + 0.5; 

if (g >- z) 

v = f loor (x_pos_output_top) ; 

else 


********** 


NAS A/TM — 200 1-210701 


61 


FIVEAXW.C 


2205 

2206 

V = g; 

2207 

X_P_0_T « v + t4 8 ; 

2208 

// ************ 

2209 

if(X P 0 T < out min) 

2210 

{ 

.2211 

if (flag!6 == 0) 

2212 

2213 

outport ( out_chan2_l , out__min ) 

2214 

2215 

else 

2216 

if(flagl6 == l) 

2217 

{ 

2218 

asm{ 

2219 

mov dx, [out_chan2_l] 

2220 

mov ax, [out_min] 

2221 

out dx, ax 

2222 

} 

2223 

} 

2224 

2225 

}// End of if (X_JP_p_T < out min) 

2226 

2227 

else 

2228 

if (X P 0 T > out max) 

2229 

{ 

2230 

if(flagl6 == 0) 

2231 

2232 

outport (out_chan2_l , out_max) ; 

2233 

2234 

else 

2235 

if(flagl6 =- 1) 

2236 

{ 

2237 

asxn{ 

2238 

mov dx, [out_chan2_l] 

2239 

mov ax, [out max] 

2240 

out dx, ax 

2241 

} 

2242 

} 

2243 

2244 

}// End of if (X^P_0_T > out max) 

2245 

2246 

else 

2247 

{ 

2248 

if(flagl6 0) 

2249 

2250 

outport (out_chan2_l, X_PjD_T) ; 

2251 

2252 

else 

2253 

if(flagl6 « = 1) 

2254 

{ 

2255 

asm{ 

2256 

mov dx, [out_chan2 1] 

2257 

mov ax, [X P 0 T] 

2258 

out dx, ax 

2259 

} 

2260 

} 

2261 

} 

2262 // ********** ROUNDING BLOCK - x_neg_< 


********** 


NASA/TM — 2001-210701 


62 


FIVEAXW.C 


2263 

g = ceil (x_neg_output__top) ; 


2264 

z = x_neg_output_top + 0.5; 


2265 



2266 

if (g >= z) 


2267 

v = floor (x_neg_output_top) ; 

2268 

else 


2269 

ii 

tq 


2270 



2271 

X_N_0_T =* v + t4 8; 


2272 

// ************ 


2273 

if (X N 0 T < out min) 


2274 

{ 


2275 

if(flag!6 == 0) 


2276 

outport (out_chan2_2 , out_min) 

2277 



2278 

else 


2279 



2280 

if (f lagl6 == 1) 


2281 

{ 


2282 

asxn{ 


2283 

mov dx, [out_chan2 


2284 

mov ax, [out_min] 


2285 

out dx , ax 


2286 

} 


2287 

} 


2288 

}// End of if (X_N_0_T < out 

jnin) 

2289 



2290 

else 


2291 



2292 

if (X N 0 T > out max) 


2293 

{ 


2294 

if (flagl6 == 0) 


2295 

outport (out_chan2_2 , out_max) 

2296 



2297 

else 


2298 



2299 

if (f lagl6 == 1) 


2300 

{ 


2301 

asm{ 


2302 

mov dx, [out_chan2_ 

_2] 

2303 

mov ax, [out^max] 


2304 

out dx, ax 


2305 

} 


2306 

} 


2307 

}// End of if (X_N_0_T > out_ 

max) 

2308 



2309 

else 


2310 



2311 

{ 


2312 

if (f lagl6 == 0) 


2313 

outport (out_chan2_2 , X_ 

_N_0_T) 

2314 



2315 

else 


2316 



2317 

if{flagl6 == 1) 


2318 

{ 


2319 

asm{ 


2320 

mov dx, [out chan2 

_2 ] 


NAS A/TM — 200 1-210701 


63 


FIVEAXW.C 


2321 

mov ax, [X_N_0_T] 

2322 

out dx, ax 

2323 

} 

2324 

} 

2325 

} 

2326 

// ********** rounding BLOCK - y_pos_ i 

2327 

g = ceil (y_pos_output_top) ; 

2328 

2329 

z - y_pos_output top + 0.5; 

2330 

if (g >= z) 

2331 

v « f loor (y_pos_output_top) ; 

2332 

else 

2333 

2334 

v = g; 

2335 

Y_P_°_T = v + t4 8; 

2336 

// ************ 

2337 

if (Y P 0 T < out min} 

2338 

{ 

2339 

if(flagl6 == 0} 

2340 

2341 

outport (out_chan2_3, out_min) ; 

2342 

2343 

else 

2344 

if {flagl6 == 1} 

2345 

{ 

2346 

asm{ 

2347 

mov dx, [out_chan2_3] 

2348 

mov ax, [out_min] 

2349 

out dx, ax 

2350 

} 

2351 

) 

2352 

2353 

}// End of if (Y m JP_O m _T < out^min) 

2354 

2355 

else 

2356 

if (Y P 0 T > out max) 

2357 

{ 

2358 

if (f lagl6 =« 0) 

2359 

2360 

outport (out_chan2_3 , out_max) ; 

2361 

2362 

else 

2363 

if (f lagl6 -= 1) 

2364 

{ 

2365 

asxn{ 

2366 

mov dx, [out_chan2_3] 

2367 

mov ax, [out max] 

2368 

out dx, ax 

2369 

} 

2370 

} 

2371 

2372 

}// End of if (Y_P_0_T > out_max) 

2373 

2374 

else 

2375 

{ 

2376 

if (flagl6 == 0) 

2377 

2378 

outport (out_chan2_3 , Y_P_0_T) ; 


NAS A/TM— 200 1 -2 1 070 1 


FIVEAXW . C 


2379 

2380 

2381 

else 

if (f lagl6 — 1} 


2382 

2383 

2384 

{ 

asm{ 

3 

0 

< 

dx. 

[out_chan2 

2385 


mov 

ax, 

[Y_P_0_ T ] 

2386 


out 

dx. 

ax 

2387 

2388 

2389 

} 

} 

} 





2390 // ********** ROUNDING BLOCK - y_neg_outpu t_top 

2391 g = ceil (y_neg_output_top) ; 

23 92 z = y_neg__output_top + 0.5; 

2393 

2394 if (g >= z) 

2395 v = f loor (y_neg_output__top) ; 

2396 else 

2397 v = g; 

2398 

2399 Y_N_0_T = v + t48; 

2400 // ************ 

2401 if(Y_N_0_T < out_min) 

2402 { 

2403 if (f lagl6 =- 0) 

2404 outport (out_chan2_4 , out_min) ; 

2405 

2406 else 

2407 

2408 if (f lagl6 == 1) 

2409 { 

2410 asm{ 

2411 mov dx, [out__chan2_4] 

2412 mov ax, [out_min] 

2413 out dx, ax 

2414 } 

2415 } 

2416 }// End of if(Y_N_0_T < out_min; 

2417 

2418 else 

2419 

2420 if (Y_N_0_T > out_max) 

2421 { 

2422 if (f lagl6 — 0) 

2423 outport (out_chan2 4 , out_max) ; 

2424 

2425 else 

2426 

2427 if (f lagl6 =- 1) 

2428 { 

2429 asm{ 

2430 mov dx, [out_chan2_4] 

2431 mov ax, [out_max] 

2432 out dx, ax 

2433 } 

2434 } 

243 5 }// End of if (Y_N_0_T > out_max) 

2436 


********** 


NASA7TM — 200 1-210701 


65 


FIVEAXW.C 


2437 else 

2438 

2439 { 

2440 if ( f lag!6 == 0) 

2441 outport (out_chan2_4 , Y_N_0_T) ; 

2442 

2443 else 

2444 

2445 if (f lagl6 *== 1) 

2446 { 

2447 asro{ 

2448 mov dx, [out_chan2_4] 

2449 mov ax, [Y_N_0_T] 

2450 out d x, ax 

2451 } 

2452 } 

2453 } 

2454 

2455 dotXav = Xav - oldoldXav; 

2456 oldoldXav = oldXav; 

2457 oldXav = Xav; 

2458 

2459 dotYav = Yav - oldoldYav; 

2460 oldoldYav = oldYav; 

2461 OldYav = Yav; 

2462 

2463 dotThetaX = ThetaX - oldoldThetaX; 

2464 oldoldThetaX = oldThetaX; 

2465 oldThetaX ~ ThetaX; 

2466 

2467 dotThetaY = ThetaY - oldoldThetaY; 

2468 oldoldThetaY = oldThetaY; 

2469 oldThetaY = ThetaY; 

2470 }// End of if(flagl0 s® l) 

2471 

2472 // *****************************end MODAL CONTROL *************************** 

2473 

2474 // ****************************** THRUST BEARING *************************** 

2475 

2476 if (f lag3 == 1) 

2477 { 

24 78// *** Begin z_force_th calc * * * 

24 79 

2480 zth - (zthl + zth2) / 2.0; 

2481 zthderiv = zth - z__th_old3; 

2482 zthsum = zthsum + igainth * zth; 

2483 

2484 // * * * Calculate z_force_th * * * 

2485 

2486 z_force_th = {kv_th * zth + dv_th * zthderiv) / 2.0 + zthsum 

2487 - tBias_th; 

2488 up_output__th = z_force_th - bias_current_th; 

2489 down_output_th = z_force_th + bias__current_th; 

2490 

2491 // * * * OUTPUTS FOR z_direction_th * * * 

24 92 

2493 // ********* GROUNDING BLOCK********** 

2494 g = ceil (up_output_th) ; 


N AS A/TM — 200 1-21 070 1 


66 


FIVEAXW.C 


2495 

z = up_output_th + 0.5; 

2496 

2497 

if (g >= z) 

2498 

v = f loor (up_output_th) ; 

2499 

else 

2500 

<J 

ii 

IQ 

2501 

2502 

round2 = v + t48; 

2503 // 

********************-**-************* 

2504 

2505 

if(round2 < out min) 

2506 

{ 

2507 

if ( f lagl6 == 0) 

2508 

outport (out_chanl_5 , out_min) 

2509 


2510 

else 

2511 

2512 

if (f lagl6 1) 

2513 

{ 

2514 

asm{ 

2515 

mov dx, [out_chanl_5] 

2516 

mov ax, [out_min] 

2517 

out dx, ax 

2518 

} 

2519 

} 

2520 

} 

2521 

2522 

else 

2523 

2524 

if(round2 > out max) 

2525 

{ 

2526 

if ( f lag!6 == 0) 

2527 

outport ( out_chanl_5 , out_max) 

2528 

2529 

else 

2530 

2531 

if {f lagl6 » 1) 

2532 

{ 

2533 

asm{ 

2534 

mov dx, [out chanl 5] 

2535 

mov ax, [out_max] 

2536 

out dx, ax 

2537 

} 

2538 

} 

2539 

} 

2540 

2541 

else 

2542 

2543 

{ 

2544 

if (flaglfi == 0) 

2545 

outport (out_chanl_5, round2); ( 

2546 

2547 

else 

2548 

2549 

if(flagl6 1) 

2550 

{ 

2551 

asm{ 

2552 

mov dx, [out_chanl_5] 


NASA/TM— 2001-210701 


67 


FIVEAXW . C 


2553 

2554 

2555 

2556 

2557 

2558 // 

2559 

2560 

2561 

2562 

2563 

2564 

2565 

2566 

2567 

2568 // 

2569 

2570 

2571 

2572 

2573 

2574 

2575 

2576 

2577 

2578 

2579 

2580 

2581 

2582 

2583 

2584 

2585 

2586 

2587 

2588 

2589 

2590 

2591 

2592 

2593 

2594 

2595 

2596 

2597 

2598 

2599 

2600 
2601 
2602 

2603 

2604 

2605 

2606 

2607 

2608 

2609 

2610 


mov ax, [round2] 
out dx, ax 

} 

} 

} 

*********** + *******■*■*** + * + ********** 
g = ceil (down_output_th) ; 

2 = down_output_th + 0.5; 

if (9 >= z) 

v = floor (down_output_th) ; 

else 

v = g; 

round2 = v + t4 8; 

***********************+++*****+**** 

i£(round2 < out_min) 

{ 

i£(flagl6 == 0) 

outport (out_chan2_5, out_min) ; 

else 

if(flagl6 == 1} 

{ 

asm{ 

mov dx, [out_chan2_5] 
mov ax, [out_min] 
out dx, ax 

} 

} 

} 

else 

if (round2 > out_max) 

{ 

if (f lagl6 *= 0} 

outport ( out_chan2_5 , out_max) ; 

else 

if(flag!6 == 1) 

{ 

asm{ 

mov dx, [out_chan2_5] 
mov ax, [out_max] 
out dx, ax 

} 

) 

} 

else 

{ 

if(flagl6 == 0) 

outport (out_chan2_5, round2) ;// VERT. (DOWN) 



NAS A/TM— 200 1 -2 1 0701 


68 


FIVEAXW . C 


2611 

2612 

2613 

2614 

2615 

2616 

2617 

2618 

2619 

2620 
2621 
2622 

2623 

2624 

2625 

2626 

2627 

2628 

2629 

2630 

2631 

2632 

2633 

2634 

2635 

2636 

2637 

2638 

2639 

2640 

2641 

2642 

2643 

2644 

2645 

2646 

2647 

2648 

2649 

2650 

2651 

2652 

2653 

2654 

2655 

2656 

2657 

2658 

2659 

2660 
2661 
2662 

2663 

2664 

2665 

2666 

2667 

2668 


else 

if ( f lagl6 « 1) 

{ 

asm{ 

mov dx, [out_chan2_5J 
mov ax, [round2] 
out dx , ax 

} 

} 

} 

// z_th_old5 = z_th_old4 ; 

// z_th_old4 = z_th_old3 ; 
z_th_old3 = z_th_old2 ; 
z_th_old2 = z_th_oldl; 
z_th_oldl = zth; 

// * * * End z force th * * * 


}// End of if(flag3 == 1 ) 

// * * * Safe Gain * * * 

if (sg3 == 1) 
goto Tl; 

else 

goto T2 ; 

Tl : { 

if { (zth * zth) > zsafe) 

{ 

kv_th = 1.5; 
dv_th = 9.0; 

} 

goto T2 ; 

} 

// * * * End Safe Gain * * * 

T2 : 


if (diag == l) 

{ 

if (flag4d == 1) 

{ 

if (f lag4c =- 1) 

{ 


// 

// 


// 

// 


junk = exp (1 . 34567) ; 
junk = exp (1.3456 7); 
junk - exp (1 . 34567) ; 
junk = exp (1 . 34567) ; 
junk = cos (1 . 34567) ; 
junk = cos (1 . 34567) ; 
junk = cos (1.3456 7); 
junk - cos (1.3456 7); 


NASA/TM — 200 1-210701 


69 


FIVEAXW . C 


2669 

2670 

2671 

2672 

2673 

2674 

2675 

2676 

2677 

2678 

2679 

2680 
2681 
2682 

2683 

2684 

2685 

2686 

2687 

2688 

2689 

2690 

2691 

2692 

2693 

2694 

2695 

2696 

2697 

2698 

2699 

2700 

2701 

2702 

2703 

2704 

2705 

2706 

2707 

2708 

2709 

2710 

2711 

2712 

2713 

2714 

2715 

2716 

2717 

2718 

2719 

2720 

2721 

2722 

2723 

2724 

2725 

2726 


// junk = cos(l, 34567) ; 

// junk = cos (1. 34567) ; 

}// End of if(flag4c *= 1) 

}// End of if (flag4d =- 1) 

)// End of if(diag =*= 1) 

if(flagll == 1)// Lower bearing write out activation flag 

if(nw_bot 1) 

{ 

if (i_bot == 1) 

{ 

gotoxy (51, 22) ; textcolor (11) ; 

cprintf <"%6.1fv %6.1fv'\ xbot / 204.8, ybot / 204.8); 

gotoxy (49, 23 ) ; textcolor (11 ) ; 

cprintf (" %4 . If v, %6 . lfv, %6 . if v, %6 . ifv' 1 , x_pos_output_bot / 204.8, 

x _ ne 9_OUtput_bot / 204.8, 
y_pos_output_bot / 204.8, 
y_neg_output_bot / 204.8) 

if (f laglO «= 0)// Activates when modal is off 

{ 

gotoxy (25 , 22 ) ; textcolor ( 11) ; 

cprintf { M %9 . 2 fv 1 ' , x_force_bot / 204.8); 

gotoxy (25 , 23) ; 

cprintf ( M %9 . 2fv M , y_force__bot / 204.8); 

} 

}// End of if(i_bot -= 1) 
i__bot = i_bot + 1; 

if(i_bot *= = 1025) 
i_bot = 1 ; 

}// End of if(nw_bot »* 1) 

)// End of if (flagll == 1) 

Bias 

if (f lag22 — 1)// Upper bearing write out activation flag 

{ 

if (nw_top == 1) 

{ 

if(i_top ==* 1) 

{ 

gotoxy (51, 22) ; textcolor (11) ; 

cprintf (”%6. If v %6.1fv n , Xtop / 204.8, ytop / 204.8); 

gotoxy (49, 23) ; textcolor (11) ; 

cprintf ( ,, %4.1fv,%6.1fv,%6.1fv,%6. lfv n , x_pos_output_top / 204.8, 

x _neg_output_top / 204.8, 

y_pos_output_top / 204.8, 

y_neg_output_top / 204.8); 

if (flaglO == 0)// Activates when modal is off 

{ 

gotoxy (25, 22) ; textcolor (11) ; 

cprintf ( "%9 . 2fv" , x_force_top / 204.8); 

gotoxy (25, 23 } ; 

cprintf ( "%9 . 2fv M , y_force_top / 204.8); 

} 

}// End of if(i_top == 1) 


NAS A/TM— 200 1 -2 1 0701 


70 


FIVEAXW . C 


2727 

2728 

2729 

2730 

2731 

2732 

2733 

2734 

2735 

2736 

2737 

2738 

2739 

2740 

2741 

2742 

2743 

2744 

2745 

2746 

2747 

2748 

2749 

2750 

2751 

2752 

2753 

2754 

2755 

2756 

2757 

2758 

2759 

2760 

2761 

2762 

2763 

2764 

2765 

2766 

2767 

2768 

2769 

2770 

2771 

2772 

2773 

2774 

2775 

2776 

2777 

2778 

2779 

2780 

2781 

2782 

2783 

2784 


i_top = i_top + 1; 

if(i_top =« 1025) 
i_top = 1 ; 

}// End of if (nw_top « 1) 

}// End of if (flag22 == 1) 

else 

if (f lag33 == 1)// Thrust bearing write out activation flag 

{ 

if (nw_th == 1) 

{ 

if (i_th == 1) 

{ 

gotoxy (51 , 22) ; text color (11 ) ; 
cprintf (”%6 . lfv ", zth / 204.8); 

gotoxy (49, 23) ; textcolor (11) ; 

cprintf (" %4 . lfv, %6 . lfv" , up_output_th / 204.8, 

down_output_th / 204.8); 

if (flaglO == 0}// Activates when modal is off 

{ 

gotoxy (25, 22) ; textcolor (11) ; 
cprintf {" %9 . 2fv" , z_force_th / 204.8); 

} 

}// End of if (i_th mm l) 
i_th = i_th + 1; 

if(i_th == 1025) 
i_th = 1 ; 

}// End of if (nw_th == 1) 

}// End of if(flag33 =■ 1) 

n++ ; 

}// End of while (n < = nmax) loop 

// ************** Time & Loop time update block ************** 


get time (&tt ) ; 

if (tt . ti_hour 0) 

{ 

hh =- -12; 

gotoxy(48,l0) ; textcolor (14) ; 
cprintf { "AM" ) ; 

} 


else 

if (tt . ti__hour >= 1 && tt.ti_hour < 12) 

{ 

hh = 0 ; 

gotoxy (48 , 10) ; textcolor (14 ) ; 
cprintf ( "AM" ) ; 

} 


NAS A/TM— 200 1-210701 


71 


FIVEAXW . C 


2785 

2786 

2787 

2788 

2789 

2790 
.2791 

2792 

2793 

2794 

2795 

2796 

2797 

2798 

2799 

2800 
2801 
2802 

2803 

2804 

2805 

2806 

2807 

2808 

2809 

2810 
2811 
2812 

2813 

2814 

2815 

2816 

2817 

2818 

2819 

2820 
2821 
2822 

2823 

2824 

2825 

2826 

2827 

2828 

2829 

2830 

2831 

2832 

2833 

2834 

2835 

2836 

2837 

2838 

2839 

2840 

2841 

2842 


else 

if (tt . ti_hour *== 12) 

{ 

hh = 0 ; 

gotoxy (48 , 10 ) ; text color (14 } ; 
cprintf ("PM") ; 

} 


else 

if (tt . ti_hour > 12 && tt.ti_hour < 24) 

{ 

hh = 12; 

gotoxy (48,10) ; textcolor (14) ; 
cprintf ("PM") ; 

} 

gotoxy (33 , 10} ; textcolor (14 ) ; 
cprintf ( "Time : " ) ; 

gotoxy (39, 10) ; textcolor (11) ; 

cprintf ( "%2d: %02d: %02d\n" , 

tt . ti_hour-hh, tt.ti_min, tt.ti_sec); 

if(flag_L =■ 1) 

{ 

gotoxyd, 13) ; textcolor (14+128) ; 
cprintf (" QUIT (y/n) ? : 11 ) ; 

} 

if(l «= lmax) // Time update block 

{ 

get time (&now) ; 
last_time = timel; 

timel = now.ti_sec + 0.01 * now.ti_hund + 60.0 * now.ti_min 
loop__time «{ (timel - last_time) * micro); 

if (abs (loop_time) < 800.0) 

{ 

if(flagl0 « 1 && diag == 1) 

{ 

gotoxy (34, 13) ; textcolor (15) ; 
cprintf ("%6. 2 f", k_tilt) ; 
gotoxy (34 , 14) ; textcolor (15) ; 
cprintf ( "%6 . 2f 11 , c_tilt) ; 

} 

if (nw_bot == 1 | | nw_top ==* 1 | | nw th == 1) 

{ 

gotoxy (62 , 22) ; textcolor (128+14 ) ; 
cprintf ( "w" ) ; 

} 

if(nw_bot ** 0 && nw_top 0 && 

nw_th == 0 Sc Sc flag_B == l && 

flaglO « 0 | | flaglO == 1) 

{ 

gotoxy (27, 23) ; textcolor (14) ; 
cprintf (" [<*> to toggle D.A. ] '*) ; 


NAS A/TM— 2001-210701 


72 


FIVEAXW . C 


2843 

2844 

2845 

2846 

2847 

2848 

2849 

2850 

2851 

2852 

2853 

2854 

2855 

2856 

2857 

2858 

2859 

2860 
2861 
2862 

2863 

2864 

2865 
2 B66 

2867 

2868 

2869 

2870 

2871 

2872 

2873 

2874 

2875 

2876 

2877 

2878 

2879 

2880 
2881 
2882 

2883 

2884 

2885 

2886 

2887 

2888 

2889 

2890 

2891 

2892 

2893 

2894 

2895 

2896 

2897 

2898 

2899 

2900 


} 

gotoxy (39 , 9) ; textcolor (15) ; 
cprintf ( "%6 . 2f ” , loop_time) ; 


if (f lag24 =« 1 && flag_K 

{ 


1)// Dynamic Averaging block 


ii = ii + 1.0; 

A1 = A2; A2 

A5 = A6 ; A6 
A9 = A10; A10 
A13 = A14 ; A14 


= A3; A3 = 

- A7 ; A 7 = 

- All; All = 

- A15; A15 = 


A4; A4 = A5; 
A8 ; A8 = A9 ; 
A12; A12 = A13 ; 
loop_time; 


L_T » A1 + A2 +A3 +A4 +A5 +A6 +A7 +A8 +A9+A1 0 +A11+A12 +A1 3 +A14 +A1 5 ; 

LT = L_T / 15.0;// Average loop time 

PL = 1000000.0 / (freq*LT*500) ;// Period length 
O = l/PL;// O = (l/period length) , used in signal generation 

// block 

qq = qq + 1; 
if (qq > w) 

{ 

qq = o; 
ii = 0.0; 

} 

}// End of if (flag24 == 1 && flag_K == 1) 

else 

if (flag24 == 0 && flag_K -= 1)// Intermittent Averaging block 

if (rr == 0 ScS. ii <= 15.0) 

{ 

ii = ii + 1.0;// Counter 

OO = 1000000.0 / (freq*loop_time*500) ;// Period length 
OL = OL + OO;// Accumulated period length 
L_T = L_T + loop_time; 
if (ii »- 15.0) 

{ 

PL = OL / ii;// Average period length 
LT = L_T / ii;// Average loop time 
O * 1.0 / PL; 
rr = 1; 

OL = 0.0; 

L_T = 0.0; 

} 

}// End of if (rr == 0 && ii <=. 15.0) 
qq = qq + 1; 
if(qq > w) 

{ 

rr = 0; 
qq = 0; 
ii = 0.0; 

} 

}// End of if (flag24 =- 0 && flag_K == 1) 
if (f lag_K == 1) 


NAS A/TM— 200 1-210701 


73 


FIVEAXW.C 


2901 

2902 

2903 

2904 

2905 

2906 

2907 

2908 

2909 

2910 

2911 

2912 

2913 

2914 

2915 

2916 

2917 

2918 

2919 

2920 

2921 

2922 

2923 

2924 

2925 

2926 

2927 

2928 

2929 

2930 

2931 

2932 

2933 

2934 

2935 

2936 

2937 

2938 

2939 

2940 

2941 

2942 

2943 

2944 

2945 

2946 

2947 

2948 

2949 

2950 

2951 

2952 

2953 

2954 

2955 

2956 

2957 

2958 


{ 

if (flag_H »= l) 

{ 

gotoxy(l,21) ; text color (15 ) ; 

cprintf { " PL : %6 . 4f , %4 . If , %3u ",PL,ii,w) 

} 

else 

if(flag_H == 0) 

{ 

gotoxy(l, 21) ; textcolor (15) ; 
cprintf ("PL: %6.4f”,PL); 

} 

}// End of if (flag_K == 1) 

if (resp 'o' || resp == ’O') 

{ 

frequency = (1000000 . 0/ (PL*loop_time*500) ) 

gotoxy (1 , 21) ; textcolor (15) ; 

cprintf ("PL: %6.4f " , PL) ; 

gotoxy (1, 23) ; textcolor (15) ; 

cprintf ( "<o>f req : %8 . 2f Hz . " # frequency) ; 

} 

else 

{ 

gotoxy (1,23) ; textcolor ( 15 ) ; 
cprintf {"< > 1 / PL : ») ; 

gotoxy (10 , 23) ; textcolor (15) ; 
cprintf ( n %7.3f", o) ; 


if (ii < COUNTMAX) 

{ 

gotoxy (2, 23) ; textcolor (12+128) ; 
cprintf { "o" ) ; 

} 

else 

{ 

COUNTMAX » -1.0; .. . . . - 

gotoxy (2 ,23) /textcolor (10) ; 
cprintf ("o") ; 

} 

} 

// +****+*++++*+***★*★**★******+*+*+****** 

if(diag ■= 0) 

{ 

f lag_HH = f lag_HH + 1; 


if (flag_HH == 1) 

{ 

TC = 10; 

gotoxy (37, 19) ; textcolor (TC) ; 
cprintf (" NASA "); 

} 

else 

if (flag_HH == 2) 

{ 

TC = 11; 

gotoxy (3 7, 19) ; textcolor (TC ) ; 
cprintf (" GLENN "); 


NASA/TM— 200 1-2 10701 


74 


FIVEAXW . C 


2959 

2960 

2961 

2962 

2963 

2964 

2965 

2966 

2967 

2968 

2969 

2970 

2971 

2972 

2973 

2974 

2975 

2976 

2977 

2978 

2979 

2980 

2981 

2982 

2983 

2984 

2985 

2986 

2987 

2988 

2989 

2990 

2991 

2992 

2993 

2994 

2995 

2996 

2997 

2998 

2999 

3000 

3001 

3002 

3003 

3004 

3005 

3006 

3007 

3008 

3009 

3010 

3011 

3012 

3013 

3014 

3015 

3016 


} 

else 

if (f lag_HH == 3) 

{ 

TC = 13; 

gotoxy(37, 19) ;textcolor (TC) ; 
cprintf ("RESEARCH") ; 

} 

else 

if(flag_HH == 4) 

{ 

TC = 14; 

gotoxy (37, 19) ; textcolor (TC) ; 
cprintf (" CENTER ") ; 

} 

if (flag_HH >= 4) 
flag_HH = 0; 

}// End of if (diag == 0) 

/ / ******* + * + + ★★* + ****** + *** + *****■*■* + ■*■*•*+* 
if (f lag_BB == 1) 

{ 

gotoxy (1,2) ; textcolor (15) ; 

cprintf ("<q> to abort control " ) ; 

if (flag_B == 1 && flag44 — = 0 | ( diag == 0) 

{ 

if { f laglO == 0 && nw_bot «*= 0 && 

nw_top == 0 && nw_th *= 0 | | flaglO =» 1) 

{ 

gotoxy (42 , 23) ; textcolor (12) ; 
cprintf ("I. A. ") ; 

} 

} 

if (diag == 0) 

{ 

gotoxy (1, 5) ; textcolor (15) ; 

cprintf (”<4-0> to select excitation "); 

gotoxy (1,3) ; textcolor ( 15) ; 

cprintf ( n <m> to toggle modal cntrl H ); 

gotoxy (1,4) ; textcolor (15) ; 

cprintf ("<?> to toggle f_excite ,l ) ; 

} 

if (diag == 1) 

{ 

gotoxy (1 , 1) ; textcolor (15) ; 

cprintf ("< + ,- > to toggle input-output writes”) 

gotoxy (1,3) ; textcolor ( 15) ; 

cprintf ( M <f> to toggle loop time buffer”); 

gotoxy (1,4) ; textcolor (15) ; 

cprintf ( "<e> non diagnostic ») ; 

gotoxy (1, 5) ; textcolor (15) ; 

cprintf ("<!,©,#> disable safe gain ”) ; 

} 


NAS A/TM— 200 1 -2 1 070 1 


75 


FIVEAXW.C 


3017 

3018 

3019 

3020 

3021 

3022 

3023 

3024 

3025 

3026 

3027 

3028 

3029 

3030 

3031 

3032 

3033 

3034 

3035 

3036 

3037 

3038 

3039 

3040 

3041 

3042 

3043 

3044 

3045 

3046 

3047 

3048 

3049 

3050 

3051 

3052 

3053 

3054 

3055 

3056 

3057 

3058 

3059 

3060 

3061 

3062 

3063 

3064 

3065 

3066 

3067 

3068 

3069 

3070 

3071 

3072 

3073 

3074 


if (switchl == 1) 

{ 

gotoxy (1,25) ; text color (13) ; 
cprintf ( ” [ ] ") ; 

gotoxy (2,25) ; textcolor ( 14 ) ; 
cprintf { "f_excite2 " ) ; 
gotoxy (13,25) ; textcolor (15+128 } ; 
cprintf ( »<««" ) ; 

} 

else 

if(switchl == 0) 

{ 

gotoxy (1,25) ; textcolor (15) ; 
cprintf ( "<?>f_excite : ") ; 

} 

gotoxy (2 ,20) ; textcolor (10) ; 
cprintf ("k") ; 

i f ( f 1 ag_N == l) 

{ 

if(flag_jj »» 1) 

{ 

gotoxy (1, 14) /textcolor (10) ; 
cprintf ("< >PHSE ANG:%3u deg » , th) ; 
gotoxy (2 , 14) ; textcolor (15) ; 
cprintf ( ,r n" ) ; 
flag jj = 0? 

} 

else 

if(flag_jj *= 0) 

{ 

gotoxy (1,14) /textcolor (13) ; 
cprintf ( M < >phi ANG:%3u deg” , thp) ; 
gotoxy (2 , 14) /textcolor (15) ; 
cprintf ( rl { } "} ; 
flag_jj = 1; 

} 

} 

flag_BB = 0/ 

}// End of if (flag_BB == 1) 

else 

if { f lag_BB == o) 

{ 

if (diag == 1) 

{ 

gotoxy (1,1) ; textcolor (9) ; 

cprintf {" <4- 0> to select excitation 

} 

if (flag_B == 1 flag44 0 | | diag == 0 

{ 

if (f laglO == 0 && nw_bot == 0 && 

nw_top == 0 && nw_th == 0 j j flaglO 

{ 

gotoxy (42 ,23) ; textcolor (10) ; 
cprintf ( "D . A. H } ; 

} 

} 


NASA7TM — 2001-210701 


76 



FIVEAXW . C 


3075 

3076 

3077 

3078 

3079 

3080 

3081 

3082 

3083 

3084 

3085 

3086 

3087 

3088 

3089 

3090 

3091 

3092 

3093 

3094 

3095 

3096 

3097 

3098 

3099 

3100 

3101 

3102 

3103 

3104 

3105 

3106 

3107 

3108 

3109 

3110 

3111 

3112 

3113 

3114 

3115 

3116 

3117 

3118 

3119 

3120 

3121 

3122 

3123 

3124 

3125 

3126 

3127 

3128 

3129 

3130 

3131 

3132 


gotoxy (1,2) ; textcolor (10) ; 

cprintf ( T, <R> to toggle Bounce/Tilt"); 

if(diag == 1 | | diag == 0) 

{ 

if(flagMM ** 0 && switchl == 0) 

{ 

gotoxy (1,25) ; textcolor (15) ; 
cprintf ( "<s>to adjust Pulse Width"); 

} 

gotoxy (1,3) ; textcolor { 13 ) ; 

cprintf ("<F> to toggle O.P.R. dirction "); 

gotoxy (1,4) ; textcolor (14) ; 

cprintf (” <<> to toggle ext . input . exct ion" ) 

gotoxy (1, 5) ; textcolor ( 11 ) ; 

cprintf ("<&, *>avrg freq update adjst") ; 

}// End of if (diag « 1 | | diag « 0) 
gotoxy (2 , 20) ; textcolor (12) ; 
cprintf ("x") ; 
f lag_BB = 1; 

if ( f lag_N =« 1) 

{ 

gotoxy (1 , 14) ; textcolor (15) ; 
cprintf ( " [ ]”); 

gotoxy(2,14) ; textcolor (14) ; 
cprintf ( M < >ONE_PR_REV" ) ; 
gotoxy (3 , 14) ; textcolor (10) ; 
cprintf ("r'j ; 

gotoxy (16 , 14) ; textcolor (12+128) ; 
cprintf ( "OFF 1 ' ) ; 

} 

}// End of if(flag_BB -- 0) 

/ / ****+***+**+**+++*****★+***+*+**+**+★** 

}// End of if (abs (loop_time) < 800.0) 

1 = 0 ; 

}// End of if (1 =- Imax) 

1++; 

hh - kbhit 0 ; 

if (hh == 0} 
goto loop; 

else 


{ 

resp = getch(); 
hh = 0; 

} 

if (diag == 1 && SSS == 1) 

{ 

if (resp == 'q' || resp == ’Q 1 ) 

{ 

flag_L = 1; 


NAS ATTM— 200 1 -2 1 070 1 


77 


FIVEAXW. C 


3133 

goto loop; 





3134 

} 





3135 

if (flag L == 1) 





3136 

{ 





3137 

if (resp == *y 

■’ | | resp =- 1 Y f ) 




3138 

goto ramp_down; 

- 



3139 






3140 

if (resp »= ' n 

1 | | resp == 'N* ) 




3141 

{ 





3142 

gotoxy (1, 13) ; textcolor (14) ; 




3143 

cprintf ( ” 

") ;// ERASE QUIT (y/n)?: 

3144 

f lag_L = 0; 





3145 

goto loop; 





3146 

} 





3147 

} 





3148 






3149 

if (resp == 1 p 1 ) 

goto kv_up; if (resp 

= =S 

’ p T ) 

goto 

3150 

if (resp == ' d 1 ) 

goto dh_up; if (resp 

= = 

1 D 1 ) 

goto 

3151 

if (resp == r g ' ) 

goto kh_up ; if (resp 

e* 

' G 1 ) 

goto 

3152 

if (resp 1 v 1 ) 

goto dv_up; if (resp 


'V' ) 

goto 

3153 

if (resp == 1 w ’ ) 

goto wBias_up; if (resp 

= * 

1 W' ) 

goto 

3154 

if (resp == 1 t 1 ) 

goto tBias_up; if (resp 


’T* ) 

goto 

3155 

if (resp -= *b f ) 

goto bias_up; if (resp 


’B' ) 

goto 

3156 

if (resp »■ 1 f ' ) 

goto buffer; if (resp 

ms ar 

' M * ) 

goto 

3157 

if (resp ==# ' + f ) 

goto writeout; if (resp 

= m 

f - •) 

goto 

3158 

if (resp ' ) ' ) 

goto igain_up ; if (resp 

=» 

' (') 

goto 

3159 

if (resp == 1 I 1 ) 

goto disable__saf el ; i f (resp 

ms s 

’l’) 

goto 

3160 

if (resp »■ f @’ ) 

goto disable_saf e2 ; if (resp 

mms 

'2 ' ) 

goto 

3161 

if (resp == f # ' ) 

goto disable_safe3 ; if (resp 


'3’) 

goto 

3162 

if (resp == ' e 1 } 

goto non_di agnostic; 




3163 






3164 

if (resp =» 1 H 1 ) 

goto thrust_bearing; 




3165 

if (resp =* 1 I ’ ) 

goto upper_bearing; 




3166 

if(resp == 'J') 

goto lower_bearing; 




3167 






3168 

if (resp mm ' 1 ' } 

goto l_on; 




3169 

if (resp == ' u ' ) 

goto u_on; 




3170 

if (resp T z ’ ) 

goto z on; 




3171 

}// End of if (diag = 

= = 1 && SSS M 1) 




3172 






3173 

if (diag == 1 | | diag 

— 0) 




3174 

{ 





3175 

if (resp == 1 q ' | 

| resp «= 1 Q f ) 





kv_down ; 
dh_ down ; 
kh__down ; 
dv_down ; 
wBias_down ; 
tBias_down; 
bias_down ; 
test_signal ; 
nowrite ; 
igain_down; 
enable_safel ; 
enable_safe2 ; 
enable_safe3 ; 


3176 

3177 

3178 

3179 

3180 

3181 

3182 

3183 

3184 

3185 

3186 

3187 

3188 

3189 

3190 


flag_L - 1; 
goto loop; 

} 

if (f lag_L == 1} 

{ 


if (resp == f y 1 
goto ramp_down; 

if{resp == 'n 1 

{ 


resp 


'Y' ) 


resp == ' N ' ) 


gotoxy(l,13) ; textcolor (14 ) ; 
cprintf { " 
flag_L = 0; 
goto loop; 


" ) ; // ERASE QUIT (y/n ) ? ; 


NAS A/TM — 200 1-210701 


78 



FIVEAXW.C 


3191 

3192 

3193 

3194 

3195 

3196 

3197 

3198 

3199 

3200 

3201 

3202 

3203 

3204 

3205 

3206 

3207 

3208 

3209 

3210 

3211 

3212 

3213 

3214 

3215 

3216 

3217 

3218 

3219 

3220 

3221 

3222 

3223 

3224 

3225 

3226 

3227 

3228 

3229 

3230 

3231 

3232 

3233 

3234 

3235 

3236 

3237 

3238 

3239 

3240 

3241 

3242 

3243 

3244 

3245 

3246 

3247 

3248 


} 

} 


if (resp == 

■c ) 

if ( resp == 

'C') 

if (resp =* 

'E' ) 

if (resp = = 

'm' ) 

if (resp -- 

'o') 

if (resp == 

'O' ) 

if (resp -- 

'a' ) 

if (resp = = 

'A' ) 

if (resp == 

' 

if (resp sa 

' ? 1 ) 

if (resp ==* 

' ,') 

if (resp == 


if (resp sa- 

'*') 

if (resp == 


if (resp ==* 

'$' ) 

if (resp =* 

'*') 

if (resp -= 


if (resp == 

*}•> 

if (resp == 

' 4 ' ) 

if (resp == 

'5') 

if (resp == 

r 6 r ) 

if (resp == 

r 7 1 ) 

if (resp == 

'8 1 ) 

if (resp == 

1 9 ’ ) 

if (resp h 

'O' ) 

if (resp == 

'S') 

if (resp == 

'S' ) 

if (resp == 

' X 1 ) 

if (resp == 

'X' ) 

if (resp == 

’k* ) 

if (resp == 

-K 1 ) 

if (resp == 

'n' ) 

if (resp « 

’N 1 ) 

if (resp == 

1 r 1 ) 

if (resp == 

1 R 1 ) 

if (resp == 

’F' ) 

goto loop; 



}// End of if(diag 


goto cg_f actor_up ; 

goto cg_factor_down; 

goto diagnostic; 

goto modal ; 

goto f requency_up; 

goto frequency_down; 

goto amplitude_up; 

goto amplitude_down; 

goto assembly; 

goto display; 

goto excitation; 

goto excitation_switch; 

goto W_up; 

goto w_down; 

goto excitel_toggle ; 

goto loop_time_average_toggle; 

goto phi_down; 

goto phi_up; 

goto excitel; 
goto excite2 ; 
goto excite3; 
goto excite4; 
goto exciteS; 
goto excite 6; 
goto excite7 ; 

goto pulse_width_up ; 
goto pulse_width_down; 
goto f requency_input_up ; 
goto frequency_input_down; 
goto f reqf ine_adjust__up; 
goto f req_f ine_adjust_down; 
goto THETA_up ; 
goto THETA_down ; 
goto one_per_rev; 
goto Tilt_Bounce_Mode ; 
goto one_p_rev_dir ; 

== 1 | | diag == 0) 


loop_time__average_toggle : { 

if (f lag_K -= 1) 

{ 

if(flag25 == 1) 

{ 

flag24 = 0; 
f lag25 = 0; 
flag_H = 1; 

gotoxy {21, 21) ; text col or (12 ) 
cprintf ("I .A. ") ; 
rr = 0; 

OL = 0.0; 

L_T = 0.0; 

qq — o ; 


NASA/TM — 200 1 >2 1 070 1 


79 


FIVEAXW.C 


3249 

3250 

3251 

3252 

3253 

3254 

3255 

3256 

3257 

3258 

3259 

3260 

3261 

3262 

3263 

3264 

3265 

3266 w__up : { 

3267 

3268 

3269 

3270 

3271 

3272 

3273 

3274 

3275 

3276 

3277 

3278 

3279 

3280 

3281 

3282 } 

3283 vv down: 


ii = 0.0; 

} 

else 

if {f lag25 *= 0) 

{ 

f lag24 = 1; 
flag25 - 1; 
flag_H = 1; 

gotoxy (1, 21) ;textcolor (15 ) ; 

cprintf ("PL: %6 . 4f , %4 . If , %3u" , PL, ii , w=15) ; 

gotoxy (21,21) ; textcolor ( 10 ) ; 
cprintf ("D.A. ") ; 

} 

goto loop; 

}// End of if(flag_K = 1) 
goto loop; 

} 

if (flag24 == 0 && flag_K -= 1) 

{ 

OL - 0.0; 

L_T = 0.0; 
rr * 0 ; 

qq - o; 
ii = 0,0; 
w * w -f- 1 ; 
if{w >= 100) 

W = 100; 

gotoxy (17 , 21) ; textcolor (15) ; 
cprintf ( " %3u n , w) ; 
goto loop; 

} 

goto loop; 

{ 


3284 

3285 

3286 

3287 

3288 

3289 

3290 

3291 

3292 

3293 

3294 

3295 

3296 

3297 

3298 

3299 


if (f lag24 -= 0 && flag_K 1) 

{ 

OL = 0.0; 

L_T - 0.0; 
rr = 0 ; 
qq = 0; 
ii = 0.0; 
w = w - 1; 
if (w <= 15) 
w = 15; 

gotoxy (17, 21) ; textcolor (15) ; 
cprintf ( nSu” , w) ; 
goto loop; 

} 

goto loop; 

} 


3300 excitation_switch : { 


3301 

3302 

3303 

3304 

3305 

3306 


if ( f lagNN == l) 

{ 

switchl = 1; 
f lagNN = 0; 

gotoxy(l,25) ; textcolor (13 ) ; 
cprintf ("[ ] ") ; 


NASA/TM— 2001-210701 


80 


FIVEAXW.C 


3307 

gotoxy(2,25) ; textcolor (14) ; 

3308 

cprintf ( "f_excite2 " ) ; 

3309 

gotoxy (13 , 25) ; textcolor (15) ; 

3310 

cprintf ("<== '■) ? 

3311 

} 

3312 

else 

3313 

if (flagNN »= 0) 

3314 

{ 

3315 

COUNTMAX = 15.0; 

3316 

OL = 0.0; 

3317 

L T a 0.0; 

3318 

rr = 0; 

3319 

qq - 0 ; 

3320 

ii = 0.0; 

3321 

switchl = 0 ; 

3322 

flagNN =1; 

3323 

gotoxy (1,25) ; textcolor (15) ; 

3324 

cprintf ( M <?>f excite :%5d",f excite) 

3325 

} 

3326 

goto loop; 

3327 

} 

3328 test_signal : { 


3329 

if (f lagLL == 1) 

3330 

{ 

3331 

test_signal = 1; 

3332 

f lagLL = 0; 

3333 

gotoxy (36 , 11) ; textcolor ( 13) ; 

3334 

cprintf ( "<M>- test : %lu rf , test_signal) ; 

3335 

gotoxy (46 , 11) ; textcolor (12) ; 

3336 

cprintf ( "%lu" , test signal); 

3337 

} 

3338 

else 

3339 

if (f lagLL == 0) 

3340 

{ 

3341 

test_signal = 0; 

3342 

f lagLL = 1; 

3343 

gotoxy (3 7, 11) ; textcolor (15) ; 

3344 

cprintf { M M" ) ; 

3345 

gotoxy (46,11) ; textcolor (10) ; 

3346 

cprintf ( ”%lu n , test signal); 

3347 

} 

3348 

goto loop; 

3349 } 


3350 one_p_re v_di r ; 


3351 

if (flag N == 0) 

3352 

{ 

3353 

gotoxy (21, 6) ; textcolor (13) ; 

3354 

cprintf ("O.P.R, ") ; 

3355 

gotoxy (28, 6) ; textcolor (13+128 ) ; 

3356 

cprintf (" >") ; 

3357 


3358 

if (flagKK == 1) 

3359 

{ 

3360 

II = -1.0; 

3361 

gotoxy (36, 6) ; textcolor (11) ; 

3362 

cprintf ( n Anti clkwse") ; 

3363 

flagKK = 0; 

3364 

} 


NASA/TM— 2001-210701 


81 



FIVEAXW . C 


3365 

3366 

3367 

3368 

3369 

3370 

3371 

3372 

3373 

3374 

3375 

3376 

3377 Tilt_Bounce 

3378 ' - 

3379 

3380 

3381 

3382 

3383 

3384 

3385 

3386 

3387 

3388 

3389 

3390 

3391 

3392 

3393 

3394 

3395 

3396 

3397 

3398 

3399 one_per_rev: 


0 ) 


else 

if (flagKK 

{ 

II = 1.0; 

gotoxy (36, 6) ; textcolor (11) ; 
cprintf (" Clckwse "); 
flagKK - 1; 

} 

goto loop; 


} 

goto loop; 
Mode : { 


} 


if (flagJJ -= l) 

{ 

J J - 1.0; 
flagJJ = 0; 

gotoxy (32 , 7) ; textcolor (15) ; 
cprintf { "=«> <= - " ) ; 

gotoxy (36,7) ; textcolor (14+128) ; 
cprintf ( " BOUNCE MODE" ) ; 

} 

else 

if (flagJJ — 0) 

{ 

JJ = -1.0; 
flagJJ = 1 ; 

gotoxy (32 ,7) ; textcolor (15) ; 
cprintf ( "»»> <==’') ; 

gotoxy (36, 7) ; textcolor (13+128) ; 
cprintf (" TILT MODE 

} 

goto loop; 


3400 

3401 

3402 

3403 

3404 

3405 

3406 

3407 

3408 

3409 

3410 

3411 

3412 

3413 

3414 

3415 

3416 

3417 

3418 

3419 

3420 

3421 

3422 


if (f lag_M =» 1)// Toggle on flag 

{ 

ns = 1.0;// Condition for correct manual vector rotation 

gotoxy (1, 14) ; textcolor (15) ; 

cprintf ("[ ]"); 

gotoxy (2, 14) ; textcolor (14) ; 

cprintf ( n < >0NE_PR_REV" ) ; 

gotoxy (3,14) /textcolor (10) ; 

cprintf ("r") ; 

gotoxy (16 , 14) /textcolor (10) ; 
cprintf ("ON" ) ; 

flag_II = 1;// one _jper_rev set to on 

flag_M = 0; 

flag__N = 0; 

goto loop; 

} 

else 

if (flag_M == 0)// Toggle off flag 

{ 

gotoxy (16, 14) ; textcolor (12+128) ; 
cprintf ( "OFF" ) ; 
flag_II = 0; 

f lag_M = 1; 


NASA/TM— 200 1 -2 10701 


82 



FI VEAXW . C 


3423 

3424 

3425 

3426 

3427 

3428 

3429 

3430 

3431 

3432 

3433 

3434 

3435 

3436 

3437 

3438 

3439 

3440 

3441 

3442 

3443 

3444 

3445 

3446 

3447 

3448 

3449 

3450 

3451 

3452 

3453 

3454 

3455 

3456 

3457 

3458 

3459 

3460 

3461 

3462 

3463 

3464 

3465 

3466 

3467 

3468 

3469 

3470 

3471 

3472 

3473 

3474 

3475 

3476 

3477 

3478 

3479 

3480 


flag_N * 1; 

THETA = 0.0; 
th = 0; 
goto loop; 

} 

} 

THETA_up : { 

if (f lag_ll == 0)// One - Per - Rev is Off 

{ 

ns = -1.0;// Condition for correct manual vector rotation 
THETA = THETA + 5.0 * M_PI/l80.0; 
th = th + 5; 
if (THETA >= 2.0 * M__PI) 

{ 

THETA = 2.0 * M_PI ; 
th = 360; 

} 

gotoxy (1, 14) ; textcolor (10) ; 
cprintf ( "< >PHSE ANG: deg"); 

gotoxy (2 , 14 ) ; textcolor (15} ; 
cprintf ("n") ; 

gotoxy (13 , 14) ; textcolor (15) ; 
cprintf ( "%3u" , th) ; 
goto loop; 

}// End of if (flag^II == 0) 
goto loop; 

} 

THETA_down : { 

if (f lag_II == 0) 

{ 

ns = -1.0;// Condition for correct manual vector rotation 
THETA = THETA - 5.0 * M_PI/180.0; 
th = th - 5; 

if (THETA <= 0.0 && th <= 0) 

{ 

THETA * 0.0; 
th = 0; 

} 

gotoxy (1, 14} ; textcolor ( 10) ; 
cprintf ("< >PHSE ANG: deg ,! } ; 

gotoxy (2 , 14) ; textcolor (15) ; 
cprintf ( "n" ) ; 

gotoxy (13, 14) ; textcolor (15) ? 
cprintf ( n %3u" , th) ; 
goto loop; 

}// End of if (flag_II ■= 0) 
goto loop; 

} 

Phi_up : { 

if (f lag_II == 0) 

{ 

phi = phi + 5.0 * M_PI/180 . 0 ; 
thp = thp + 5 ; 
if (phi >= 2.0 * M_PI) 

{ 

phi = 2.0 * M_PI ; 
thp = 360; 


NAS A/TM— 200 1-210701 


83 


FIVEAXW.C 


3481 

gotoxy (1, 14) ; textcolor (13 ) j 

3482 

cprintf("< >phi ANG: deg"); 

3483 

gotoxy (2, 14) ; textcolor (15) ; 

3484 

cprintf ("{}”) ; 

3485 

gotoxy (13 , 14 ) ; textcolor (15) ; 

3486 

cprintf ( " %3u" r thp) ; 

3487 

goto loop; 

3488 

}// End of if (flag_XI =« 0) 

3489 

goto loop; 

3490 } 

3491 phi_down 

:{ 

3492 

if (flag II == 0) 

3493 

{ 

3494 

phi = phi - 5.0 * M_PI/ 180.0; 

3495 

thp = thp - 5; 

3496 

if (phi <= 0.0 ScSc thp <= 0) 

3497 

{ 

3498 

phi = 0.0; 

3499 

thp = 0 ; 

3500 

} 

3501 

gotoxy (1 ,14) ; textcolor (13) ; 

3502 

cprintf ("< >phi ANG: deg" ) ; 

3503 

gotoxy (2 ,14) ; textcolor (15) ; 

3504 

cprintf ("{}"); 

3505 

gotoxy (13, 14) ; textcolor (15) ; 

3506 

cprintf ( " %3u M , thp) ; 

3507 

goto loop; 

3508 

}// £nd of if(flag_JJ =* 0) 

3509 

goto loop; 

3510 

} 

3511 assembly: 

{ 

3512 

if (flag A =» 0) 

3513 

{ 

3514 

flagl6 = 1; 

3515 

gotoxy (42 , 25) /textcolor (10) ; 

3516 

cprintf ("ON "); 

3517 

flag__A = 1; 

3518 

goto loop; 

3519 

} 

3520 

else 

3521 

if (flag A *= 1) 

3522 

{ 

3523 

flag!6 = 0; 

3524 

gotoxy (42 , 25) ; textcolor (12+128) ; 

3525 

cprintf ( "OFF" ) ; 

3526 

flag_A = 0; 

3527 

goto loop; 

3528 

} 

3529 

} 

3530 display:{ 

3531 

if (nw bot *= 0 ScSc nw top == o && nw th = 

3532 

{ 

3533 

if (flag B -= 1) 

3534 

{ 

3535 

flaglB = 1; 

3536 

flagMM = 1; 

3537 

gotoxy(26, 20) /textcolor (15) ; 

3538 

cprintf (" ") ;// Erase " Force 


NASA/TM — 200 1-210701 


84 


FIVEAXW.C 


3539 


if (diag == 1) 

3540 


{ 

3541 


gotoxy (27, 23) ;// Erase [<*> to toggle D. 

3542 


cprintf (" ") ; 

3543 


} 

3544 


gotoxy (1 # 2 5) ; textcolor (15) ; 

3545 


cprintf ("<?>f_excite : %5d" , f_excite) ; 

3546 


flag_B = 0; 

3547 


goto loop; 

3548 


} 

3549 


else 

3550 


if (flag B == 0) 

3551 


{ 

3552 


flaglS = 0; 

3553 


flagMM = 0; 

3554 


if (diag == 1) 

3555 


{ 

3556 


gotoxy (26 , 20) ; textcolor (15) ; 

3557 


cprintf ("Force (N) ") ; 

3558 


} 

3559 


gotoxy (25 , 22) ; 

3560 


printf{" ");// Erase period length 

3561 


gotoxy (27 , 23) ; textcolor (14) ; 

3562 


cprintf (" [<^> to toggle D.A. ] M ) ; 

3563 


gotoxy (l ; 25) ; textcolor (15) ; 

3564 


cprintf ( " <s>to adjust Pulse Width"); 

3565 


flag_B = 1; 

3566 


goto loop; 

3567 


} 

3568 

} 


3569 

goto loop; 

3570 

} 


3571 

excitation : { 


3572 


if (flag C — 1) 

3573 


{ 

3574 


f lag2 1 = 1; 

3575 


gotoxy (32 , 24) ; textcolor (10) ; 

3576 


cprintf ("Enable") ; 

3577 


flag_C = 0; 

3578 


goto loop; 

3579 


} 

3580 


else 

3581 


if (flag C =■ 0) 

3582 


{ 

3583 


f lag21 = 0; 

3584 


gotoxy (32 ,24) ; textcolor ( 12 ) ; 

3585 


cprintf ( "Dsable" ) ; 

3586 


flag_C *= 1; 

3587 


goto loop; 

3588 


} ' 

3589 

} 


3590 

ampl i tude_up 

:{ 

3591 


t04 = t04 + 102.4*0.2; 

3592 


volt = volt + 0.1; 

3593 


if (t04 > 1024) 

3594 


{ 

3595 


t04 = 1024; 

3596 


volt 1 = 5.0; 


NASA/TM— 2001-210701 


85 


FIVEAXW.C 


3597 

3598 

3599 

3600 

3601 } 

3602 amplitude_down : { 

3603 

3604 

3605 

3606 

3607 

3608 

3609 

3610 

3611 

3612 

3613 } 

3614 f requency_input_up : { 


} 

gotoxy (14 , 24) ; textcolor (15 ) 
cprintf ( "%4 . If" , volt) ; 
goto loop; 


t04 = t04 - 102.4*0.2; 

volt = volt - 0.1; 
if { t04 <= 0.0) 

{ 

t04 = 0.0; 

volt = 0.0; 

} 

gotoxy (14,24) ; textcolor ( 15 ) ; 
cprintf ("%4 . If ,r , volt) ; 
goto loop; 


3615 

COUNTMAX = 15.0; 

3616 

flag_K * 1; 

3617 

f lag24 =* 1; 

3618 

w = 15;// used only for deft 

3619 

// D.A. mode upper 1: 

3620 

if (freq =* 1) 

3621 

freq = 0; 

3622 

freq = freq + 10.0; 

3623 

if (freq > 5000 . 0} 

3624 

freq = 5000.0; 

3625 


3626 

gotoxy (2 ,20) ; textcolor (12 ) ; 

3627 

cprintf ( “x" ) ; 

3628 


3629 

gotoxy (13,20) ; textcolor (15 ) 

3630 

cprintf ( w %7 . If Hz." , freq); 

3631 


3632 

if (flag H *= 1} 

3633 

{ 

3634 

gotoxy (21, 21) ; textcolor (10) 

3635 

cprintf ( n D . A. ”) ; 

3636 

} 

3637 


3638 

rr = 0 ; 

3639 

OL = 0.0; 

3640 

o 

o 

ii 

5 

3641 

qq = 0; 

3642 

ii - 0.0; 

3643 


3644 

goto loop; 

3645 

} 


3646 freq_f ine_adjust_up : { 
364 7 

3648 

3649 

3650 

3651 

3652 

3653 

3654 


COUNTMAX * 
flag_K = 1 
f lag24 = 1 
w - 15 ; // 


15.0; 


used only for default display of 
// D.A . mode upper limit 
freq * freq + 0.1; 
if(freq > 5000.0) 
freq = 5000.0; 


NAS A/TM— 200 1 - 2 1 070 1 


86 



FIVEAXW . C 


3655 

3656 

3657 

3658 

3659 

3660 

3661 

3662 

3663 

3664 

3665 

3666 

3667 

3668 

3669 

3670 

3671 

3672 

3673 

3674 

3675 

3676 

3677 

3678 

3679 

3680 

3681 

3682 

3683 

3684 

3685 

3686 

3687 

3688 

3689 

3690 

3691 

3692 

3693 

3694 

3695 

3696 

3697 

3698 

3699 

3700 

3701 

3702 

3703 

3704 

3705 

3706 

3707 

3708 

3709 

3710 

3711 

3712 


gotoxy (2 , 20) ; textcolor (10) ; 
cprintf ("k") ; 

gotoxy (13 , 20 ) ; textcolor (15) ; 
cprintf ( "%7 . If Hz." , f req) ; 

if { f lag_H == 1) 

{ 

gotoxy (21,21) ; textcolor (10) ; 
cprintf ( "D . A. " ) ; 

} 


rr = 0 ; 

OL ^ 0.0; 

L_T = 0.0; 

qq - o; 

ii = 0.0; 
goto loop; 

} 

f requency_ input _down : { 

COUNTMAX = 15.0; 
flag_K = 1; 
f lag24 = 1; 

w = 15;// used only for default display of 
// D.A. mode upper limit 
freq = freq - 10.0; 
if(freq <= 0) 
freq = 10.0; 

gotoxy (2, 20) ; textcolor (12) ; 
cprintf ( M x" ) ; 

gotoxy (13 , 20) ; textcolor (15) ; 
cprintf ("%7 . If Hz.” , freq); 

if (f lag_H — l) 

{ 

gotoxy (21,21) ; textcolor (10) ; 
cprintf ( "D.A. " ) ; 

} 


rr « 0; 

OL - 0.0; 

L_T = 0.0; 
qq = 0; 
ii = 0.0; 

goto loop; 

} 

freq_f ine_adjust_down : { 

COUNTMAX = 15.0; 
f 1 ag_K = 1; 
flag24 = 1; 

w = 15;// Used only for default display of 
// D.A. mode upper limit 
freq « freq - 0.1; 


NAS Arm— 200 1 -21070 1 


87 


FIVEAXW . C 


3713 

if(freq < 0.0) 

3714 

3715 

freq = 10.0; 

3716 

gotoxy (2 , 20) ;textcolor (10) ; 

3717 

3718 

cprintf ("k" ) ; 

3719 

gotoxy (13, 20) ; textcolor (15) ; 

3720 

cprintf {"%7. If Hz. ", freq); 

3721 


3722 

if (flag H == 1) 

3723 

{ 

3724 

gotoxy (21 , 21) ; textcolor (10) 

3725 

cprintf ("D.A. ") ; 

3726 

} 

3727 


3728 

rr = 0; 

3729 

OL « 0.0; 

3730 

L_T « 0.0; 

3731 

qq - 0; 

3732 

ii - 0.0; 

3733 

3734 

goto loop; 

3735 

} 

3736 frequency_up : { 


3737 flag K = 0; 

3738 PL = PL - 0.002; 

3739 if (PL <= 0.0) 

3740 

PL = 0.002; 

3741 0 

= 1.0/PL; 

3742 gotoxy (1,21) ; textcolor (15) ; 

3743 cprintf ("PL: %6.4f ",PL); 

3744 goto loop; 

3745 } 

3746 frequency_down : { 


3747 

flag_K * 0; 

3748 

PL * PL + 0.002; 

3749 

if {PL >1.0) 

3750 

PL = 1.0; 

3751 

0 = 1.0/PL; 

3752 

gotoxy (1,21) ; textcolor (15) ; 

3753 

cprintf ( "PL: %6.4f " , PL) 

3754 

goto loop; 

3755 } 

3756 pulse_width_up: { 


3757 

if(flag9 == 1) 

3758 

{ 

3759 

flagH * 0; 

3760 

PWW = PWW + 1.0; 

3761 

PW = 1. 0/ (2 . 0*PWW) ; 

3762 

gotoxy (13 , 21) ; textcolor (15) ; 

3763 

cprintf ("PW; %6 . 4f " ,PW); 

3764 

goto loop; 

3765 

} 

3766 

goto loop; 

3767 } 

3768 pulse_width_down: 

{ 

3769 

if{flag9 *= 1) 

3770 

{ 


NASA/TM — 200 1 -2 1 070 1 


88 


FIVEAXW.C 


3771 

f lag_H = 0; 

3772 

PWW = PWW - 1.0; 

3773 

if (PWW <= 0.0) 

3774 

PWW = 1.0; 

3775 

PW = 1.0/(2.0*PWW) ; 

3776 

gotoxy (13 , 21} ; textcolor (15) 

3777 

cprintf ("PW: %6.4f " , PW) ; 

3778 

goto loop; 

3779 

} 

3780 

goto loop; 

3781 

} 

3782 excitel: 

{ 

3783 

f lag6 = 0; 

3784 

flag7 = 0; 

3785 

f lags = 0; 

3786 

flag9 = 0; 

3787 

flagl2 = 0; 

3788 

f lagl3 = 0; 

3789 

COUNTMAX = 15.0; 

3790 

f lag_H = 1; 

3791 


3792 

flagAA = flag_AA + 1; 

3793 


3794 

if (flag AA > 5) 

3795 

{ 

3796 

flag AA * l ; 

3797 

} 

3798 


3799 

if (flag AA == 1) 

3800 

{ 

3801 

gotoxy (2, 19) ; textcolor ( 14 ) ; 

3802 

cprintf ("SINE «) ; 

3803 


3804 

±f(flag5 == 1) 

3805 

{ 

3806 

gotoxy (16 , 19) ; textcolor (10) ; 

3807 

cprintf ("ON ") ; 

3808 

} 

3809 

else 

3810 

if (flags -= 0) 

3811 

{ 

3812 

gotoxy(16, 19) ; textcolor (12+128) ; 

3813 

cprintf ("OFF”) ; 

3814 

} 

3815 

} 

3816 

else 

3817 

if (flag AA =« 2) 

38X8 

{ 

3819 

gotoxy (2 , 19) /textcolor (14) ; 

3820 

cprintf ("SINE SQUARED «) ; 

3821 


3822 

if{flag5 == 1) 

3823 

{ 

3824 

gotoxy (16 , 19) ; textcolor ( 10) ; 

3825 

cprintf ("ON "); 

3826 

} 

3827 

else 

3828 

if (flags == 0) 


NAS A/TM— 200 1 -2 1 070 1 


89 


FI VEAXW . C 


3829 

3830 

3831 

3832 

3833 

3834 

3835 

3836 

3837 

3838 

3839 

3840 

3841 

3842 

3843 

3844 

3845 

3846 

3847 

3848 

3849 

3850 

3851 

3852 

3853 

3854 

3855 

3856 

3857 

3858 

3859 

3860 

3861 

3862 

3863 

3864 

3865 

3866 

3867 

3868 

3869 

3870 

3871 

3872 

3873 

3874 

3875 

3876 

3877 

3878 

3879 

3880 

3881 

3882 

3883 

3884 

3885 

3886 


{ 

gotoxy (16, 19) ; textcolor (12+128 } ; 
cprintf ( "OFF”) ; 

} 

} 

else 

if (f lag_AA ** 3) 

{ 

gotoxy (2 , 19) ; textcolor (14) ; 
cprintf ("COSINE ») ; 

if (flags — 1) 

{ 

gotoxy (16 , 19) ; textcolor (10) ; 
cprintf ("ON "); 

} 

else 

if (flags == 0) 

{ 

gotoxy (16 r 19) ; textcolor (12+128 ) ; 
cprintf { "OFF" ) ; 

} 

} 

else 

if(flag_AA 4) 

{ 

gotoxy (2,19) ; textcolor ( 14 ) ; 
cprintf ("COSINE SQARED ") ; 

if (flags == 1) 

{ 

gotoxy (16 , 19) ; textcolor (10) ; 
cprintf ("ON "); 

} 

else 

if (flags -« 0) 

{ 

gotoxy (16 , 19) ; textcolor (12 + 128) ; 
cprintf ( "OFF" ) ; 

} 

} 

else 

if(flag_AA -= 5) 

{ 

gotoxy (2 , 19} ; textcolor (14 ) ; 
cprintf ( "RANDOM » ) ; 

if (flags == 1) 

{ 

gotoxy (16, 19) ; textcolor (10) ; 
cprintf ("ON " ); 

} 

else 

if (flags o) 

{ 

gotoxy (16 , 19) /textcolor (12+12 B) ; 
cprintf ("OFF") ; 

} 


NAS A/TM— 200 1 -2 1070 1 


90 



FIVEAXW.C 


3887 

3888 

3889 

3890 

3891 

3892 

3893 

3894 

3895 

3896 

3897 

3898 

3899 

3900 

3901 

3902 

3903 

3904 

3905 

3906 

3907 

3908 

3909 

3910 

3911 

3912 

3913 

3914 

3915 

3916 

3917 

3918 

3919 

3920 

3921 

3922 

3923 

3924 

3925 

3926 

3927 

3928 

3929 

3930 

3931 

3932 

3933 

3934 

3935 

3936 

3937 

3938 

3939 

3940 

3941 

3942 

3943 

3944 


} 

goto loop; 

} 

excitel_toggle : { 

if(flag__D ==* 1) 

{ 

flags = 1;// <4> 
flag6 = 0; 
flag7 = 0; 
flagB » 0; 
flag9 = 0; 
f lagl2 = 0; 
flagl3 = 0; 
num = 4 ; 

gotoxy (16, 19) ; textcolor (10) ; 

cprintf ("ON ") ; 

gotoxy (13, 21) ; textcolor (15) ; 

cprintf ( " ");// Erase ”PW: %6.4f " 

gotoxy(21, 21) /textcolor (10) ; 

cprintf ( ,? D. A. ») ; 

f lag_D = 0; 

flag_E = 1; 

flag_F = 1; 

flag_G = 1; 

flag_H = 1; 

f lag_I « 1 ; 

f lag_J = 1 ; 

rr = 0; 

OL « 0.0; 

L_T « 0.0; 
qq = 0; 
ii a 0.0; 

goto loop; 

} 

else 

if ( f lag_D == 0) 

{ 

if (f lag5 == 1) 

{ 

flags = 0; 

gotoxy (16 , 19) ; textcolor (12 + 128) ; 


cprintf ( ' 

"OFF" ) ; 

flag_D = 

l; 

flag_E = 

i; 

flagF = 

1; 

flag G = 

l; 

flag H = 

1; 

flag I = 

i; 

flag J = 

i; 

} 


goto loop; 



excite2 : { 

if (flag_E == 1) 
{ 


NASA/TM— 2001-210701 


91 


FIVEAXW.C 


3945 

COUNTMAX = 

15 .0; 

3946 

flags = 0; 



3947 

flag6 = 1; 

A 

V 

3948 

flag7 = 0; 



3949 

f lag8 * 0; 



3950 

f lag9 = 0; 



3951 

flagl2 a 0; 


3952 

f lagl3 = 0 

; 


3953 

gotoxy (2 , 19) ; textcolor ( 14 ) ; 

3954 

cprintf ( "< 

> EXCITATION ») 

3955 

gotoxy {3,19} 

; textcolor (14) ; 

3956 

cprintf ( "5 

rr ) 

i 

3957 

num = 5 ; 



3958 

gotoxy (16 , 19) / textcolor (10} ; 

3959 

cprintf ( "ON 

") ; 

3960 

gotoxy (13 , 21) ; textcolor ( 15 } ; 

3961 

cprintf ( H 


") ; 

3962 

gotoxy (21, 21) ; textcolor (10) ; 

3963 

cprintf ( n D 

.A 


3964 

f lag_E = 0 



3965 

f lag_D = 1 



3966 

f lag_F = l 



3967 

f lag_G « l 



3968 

f lag_H - l 



3969 

flag_l - 1 



3970 

f lag_J = 1, 



3971 




3972 

rr = 0; 



3973 

OL = 0.0; 



3974 

L_T = 0.0; 



3975 

qq = 0; 



3976 

ii = 0.0; 



3977 




3978 

goto loop; 



3979 

} 



3980 

else 



3981 

if (flag E =~ 

0) 

3982 

{ 



3983 

if (flag6 *= 


L) 

3984 

{ 



3985 

flag6 = 0 

r 


3986 

gotoxy (16, 19) ; textcolor (12+: 

3987 

cprintf ( " 

OFF") ; 

3988 

flag_E = 

1 


3989 

flag_D s 

1 


3990 

flag_F = 

1 


3991 

flag G = 

1 


3992 

f lag_H * 

1 


3993 

flag_I = 

1 


3994 

f 1 ag J * 

1 


3995 

} 



3996 

goto loop; 



3997 

} 



3998 } 




3999 excite3 : { 




4000 

if (flag F == 

1) 


4001 

{ 



4002 

COUNTMAX = 

15.0; 


NASA/TM— 2001-210701 


92 



FIVEAXW. C 


4003 

4004 

4005 

4006 

4007 

4008 

4009 

4010 

4011 

4012 

4013 

4014 

4015 

4016 

4017 

4018 

4019 

4020 

4021 

4022 

4023 

4024 

4025 

4026 

4027 

4028 

4029 

4030 

4031 

4032 

4033 

4034 

4035 

4036 

4037 

4038 

4039 

4040 

4041 

4042 

4043 

4044 

4045 

4046 

4047 

4048 

4049 

4050 

4051 

4052 

4053 

4054 

4055 

4056 

4057 

4058 

4059 

4060 


k = 0; 
flags = 0; 
flags s 0; 
flag7 = 1;// < 6 > 
flag8 = 0; 
flag9 = 0; 
flagl2 = 0; 
f lagl3 = 0; 

gotoxy (2,19) ; text color (14) ; 
cprintf ( "< >EXCITATION "); 
gotoxy (3 ,19) ; text color ( 14 ) ; 
cprintf ( n 6 ” ) ; 
num = 6 ; 

gotoxy (16 , 19) ; textcolor (10) ; 

cprintf ( 11 ON ") ; 

gotoxy (13 , 21) ; textcolor (15) ; 

cprintf (" "); 

gotoxy (21 , 21) ; textcolor (10) ; 

cprintf ( "D . A. " ) ; 

flag_F = 0; 

f 1 ag_D = 1 ; 

flag_E - 1; 

flag_G = 1; 

flag_H « 1; 

flag_I = 1; 

flag_J = 1; 

rr * 0; 

OL = 0.0; 

L_T = 0.0; 
qq = 0; 
i i = 0.0; 

goto loop; 

} 

also 

if (flag_F == 0) 

{ 

if ( f lag7 == 1) 

{ 

flag7 = 0; 

gotoxy (16 , 19} ; textcolor (12+128) 

cprintf ( "OFF" ) ; 

flag_F = 1; 

f lag_D = 1 ; 

flag_E = 1; 

f lag_G = 1; 

flag_H = 1; 

f lag_I = l; 

flag_J = 1; 

} 

goto loop; 

} 

} 

excite4 : { 

i f ( f 1 ag_G -= 1) 

{ 

COUNTMAX = 15.0; 


NASA/TM— 2001-210701 


93 


FIVEAXW , C 


4061 

4062 

4063 

4064 

4065 

4066 

4067 

4068 

4069 

4070 

4071 

4072 

4073 

4074 ■ - 

4075 

4076 

4077 

4078 

4079 

4080 

4081 

4082 

4083 

4084 

4085 

4086 

4087 

4088 

4089 

4090 

4091 

4092 

4093 

4094 

4095 

4096 

4097 

4098 

4099 

4100 

4101 

4102 

4103 

4104 

4105 

4106 

4107 

4108 

4109 

4110 

4111 

4112 

4113 

4114 } 

4115 excites : { 

4116 

4117 

4118 


k = 0; 
flag5 = 0; 
flag6 = 0; 
f lag7 = 0; 
flags = 1;// <7> 
flag9 = 0; 
flagl2 = 0/ 
f lagl3 = 0; 

gotoxy (2, 19) ; textcolor (14) ; 
cprintf ( "< >EXCITATXON "} ; 
gotoxy (3, 19) ; textcolor (14) ; 
cprintf { "7" ) ; 
num - 7 ; 

gotoxy (16 ,19) ; textcolor (10) ; 

cprintf (" ON ") ; 

gotoxy (13 , 21) ; textcolor (15) ; 

cprintf (” " ) ; 

gotoxy (21, 21) ; textcolor (10) ; 

cprintf ( M D . A. M ) ; 

flagjG m 0; 

f lag_D = 1; 

f lag__E = 1; 

flag_F = l; 

flag_H - 1; 

flag_I = 1; 

flag_J « 1; 

rr = 0; 

OL = 0.0; 

L_T = 0.0; 

qq = 0 ; 

ii = 0.0; 

goto loop; 

} 

else 

if ( f lag_G == 0) 

{ 

if{flag8 == 1) 

{ 

flags = 0; 

gotoxy (16 , 19) /textcolor (12+128) 

cprintf ( "OFF” ) ; 

flag_G = 1; 

flag_D = 1; 

flag_E = 1; 

flag__F = 1; 

flag_H = 1; 

flag_I = l; 

flag_J = 1; 

} 

goto loop ; 

} 


if (f lag_H == 1) 

{ 

COUNTMAX = 15.0; 


NAS A/TM— 200 1-210701 


94 



FIVEAXW.C 


4119 

kl * 1; 

4120 

flags = 0 ; 

4121 

flag6 = 0; 

4122 

flag7 = 0; 

4123 

flags = 0; 

4124 

flag9 = 1;// < 8 > 

4125 

flagl2 = 0; 

4126 

flagl3 = 0; 

4127 

gotoxy (2 , 19) ; textcolor (14) ; 

4128 

cprintf ( 11 < > EXCITATION "); 

4129 

gotoxy (3 ,19) ; textcolor (14 ) ; 

4130 

cprintf ("8") ; 

4131 

num = 8 ; 

4132 

gotoxy (16 , 19) ; textcolor (10) ; 

4133 

cprintf ("ON n ) ; 

4134 

gotoxy (13, 21) /textcolor (15) ; 

4135 

cprintf ("PW: %6.4f " , PW) ; 

4136 

f lag_H = 0; 

4137 

flag_D = 1; 

4138 

flag_E = 1; 

4139 

flag_F = 1 ; 

4140 

flag_G = 1; 

4141 

flag_I * 1; 

4142 

flag_J = i; 

4143 


4144 

rr = 0 ; 

4145 

OL = 0.0; 

4146 

o 

o 

II 

5 

4147 

qq = 0/ 

4148 

ii = 0.0/ 

4149 


4150 

goto loop; 

4151 

} 

4152 

else 

4153 

if (flag H =■ 0) 

4154 

{ 

4155 

if (f lag9 == 1) 

4156 

{ 

4157 

flag9 = 0; 

4158 

gotoxy (16,19) ; textcolor (12+128 ) ; 

4159 

cprintf ("OFF") ; 

4160 


4161 

gotoxy (13,21) ; textcolor (10) ; 

4162 

cprintf ( n D. A. " ) ; 

4163 


4164 

flag_H = 1; 

4165 

flag_D * 1; 

4166 

flag_E = 1; 

4167 

flag_F = 1; 

4168 

f 1 ag_G = 1; 

4169 

f lag_I * 1; 

4170 

flag J = 1; 

4171 

} 

4172 

goto loop; 

4173 

} 

4174 } 


4175 excites : { 


4176 

if ( (flagl — 1 || f lag2 =» 1 | | flag3 


NASA/TM — 200 1-210701 


95 


FIVEAXW.C 


4177 

4178 

4179 

4180 

4181 

4182 

4183 

4184 

4185 

4186 

4187 

4188 

4189 

4190 

4191 

4192 

4193 

4194 

4195 

4196 

4197 

4198 

4199 

4200 

4201 

4202 

4203 

4204 

4205 

4206 

4207 

4208 

4209 

4210 

4211 

4212 

4213 

4214 

4215 

4216 

4217 

4218 

4219 

4220 

4221 

4222 

4223 

4224 

4225 

4226 

4227 

4228 

4229 

4230 

4231 

4232 

4233 

4234 


{ 

if (f lag__I == l) 

{ 

COUNTMAX = 15.0; 
k = 0; 
flag5 =0; 
flag6 = 0; 
f lag7 = 0; 
flags = 0; 
flag9 = 0; 
flagl2 = 1;// <9> 
flagl3 = 0; 

gotoxy (2, 19) ; textcolor (14) ; 
cprintf ( "< > EXCITATION ♦'); 

gotoxy (3 , 19) ; textcolor (14) ; 
cprintf ( "9") ; 
num = 9 ; 

gotoxy (16 , 19) ; textcolor ( 10) ; 

cprintf ( n ON ") ; 

gotoxy (13 ,21) ; textcolor (15 ) ; 

cprintf {" " ) ; 

gotoxy (21, 21) ; textcolor (10) ; 

cprintf ("D.A. ■’) ; 

flag_I = 0; 

flag_D = 1; 

flag_E = 1; 

flag_F = 1; 

f lag_G = 1 ; 

flagH = 1; 

flag_J = 1; 

rr - 0 ; 

OL * 0.0; 

L_T = 0.0; 

gq - o; 
ii = 0.0; 

goto loop; 

} 

else 

if(flag_I 0) 

{ 

if (f lagl2 -= 1) 

{ 

flagl2 = 0; 

gotoxy (16 , 19) ;textcolor(12+128) ; 

cprintf ( "OFF" ) ; 

flag_I = 1; 

f lag_D = 1; 

f lag_E = 1; 

f lag_F = 1; 

f lag_G = 1 ; 

flag_H - 1; 

flag_J - 1; 

} 

goto loop; 

} 

}//End of if((flagl == 1 j | flag2 == 1 | | flag3 == 1) && flag23 == 1) 


1 




NASA/TM— 2001-210701 


96 


FIVEAXW . C 


4235 

4236 

4237 

4238 

4239 

4240 

4241 

4242 

4243 

4244 

4245 

4246 

4247 

4248 

4249 

4250 

4251 

4252 

4253 

4254 

4255 

4256 

4257 

4258 

4259 

4260 

4261 

4262 

4263 

4264 

4265 

4266 

4267 

4268 

4269 

4270 

4271 

4272 

4273 

4274 

4275 

4276 

4277 

4278 

4279 

4280 

4281 

4282 

4283 

4284 

4285 

4286 

4287 

4288 

4289 

4290 

4291 

4292 


goto loop; 

} 

excite7 : { 

if ( (f lagl == 1 | | flag2 — 1 I I flag3 == 1) && flag23 

if(flag_J == 1) 

{ 

COUNTMAX = 15.0; 

kl = 1 ; 

flag5 - 0; 

flag6 = 0; 

f lag7 = 0; 

f lag8 * 0; 

flag9 = 0; 

f lagl2 = 0; 

f lagl3 = 1;// < 0 > 

gotoxy{2 / 19) ; textcolor { 14) ; 

cprintf { M < > EXCITATION "} ; 

gotoxy (3 , 19) ; textcolor (14) ; 

cprintf ( 11 0 " ) ; 

num = 0 ; 

gotoxy (16, 19) /textcolor (10) ; 

cprintf ("ON ”) ; 

gotoxy (13 , 21) ; textcolor (15) ; 

cprintf (” ,[ ) ; 

gotoxy (21 , 21} ; textcolor (10 ) ; 

cprintf { "D. A. M ) ; 

flag_J = 0; 

flag_D = l; 

flag_E = 1; 

flag_F * 1; 

flag_G = 1; 

flag_H = 1; 

flag_I = 1; 

rr = 0; 

OL - 0.0; 

L_T = 0.0; 

qq - o; 

ii = 0.0; 
goto loop; 

} 


else 

if (f lag_J »= 0) 

{ 

if (f lagl3 == 1) 

{ 

f lag!3 = 0; 

gotoxy (1G, 19) ; textcolor (12+128) ; 

cprintf ("OFF") ; 

flag_J « 1; 

flag_D - 1; 

flag_E <= 1; 

flag_F = 1; 

flag_G = 1 ; 


NAS A/TM— 200 1 -2 1070 1 


97 



FIVEAXW.C 


4293 

4294 

4295 

4296 

4297 

4298 

4299 

4300 

4301 modal : { 

4302 

4303 

4304 

4305 

4306 

4307 

4308 

4309 

4310 

4311 

4312 

4313 

4314 

4315 

4316 

4317 

4318 

4319 

4320 

4321 

4322 

4323 

4324 

4325 

4326 

4327 

4328 

4329 

4330 

4331 

4332 

4333 

4334 

4335 

4336 

4337 

4338 

4339 

4340 

4341 

4342 

4343 

4344 

4345 

4346 

4347 

4348 

4349 

4350 


flag_H = 1; 
flag_I = 1; 

} 

goto loop; 

} 

}// if ( (flagl mm i | | flag2 =» 1 | | flag3 -= l) && flag23 =*= 1) 
goto loop; 

} 

rr - 0; 

OL = 0.0; 

L__T = 0.0; 

qq * 0 ; 

ii = 0.0; 

COUNTMAX = 15.0; 

if (diag == 1) 

{ 

flag44 = 0; 

gotoxy (2 6 , 2 0) ; textcolor (15) ; 

cprintf (" ");// Erase "Force (N) " 

gotoxy {25, 21) ; textcolor ( 4) ; 

cprintf ( " ");// Erasr ,r == = = ===»K5s«" 

gotoxy (42 , 12 ) ; textcolor (4 ) ; 

cprintf (" ");// Erase "-- =============== >’ 

gotoxy (42 , 15) ; textcolor (14) ; 

cprintf ( " ");// Erase ' , ==**=-==*«========^ " 

gotoxy (22 , 22) ; textcolor (15) ; 
cprintf (" "};// Erase " x:” 

gotoxy(22, 23) ; textcolor (15) ; 

cprintf (" ”);// Erase "y: n 

gotoxy (42, 13) ; 

cprintf { " " ) ; // Erase "kh_bot<g> " 

gotoxy (42 ,14) ; 

cprintf ( n ”);// Erase "dh_bot<d>" 

gotoxy (21, 17) ;// Erase "offset_bot<t>" 

cprintf{” »•); 

gotoxy (21, 18) ; // Erase n offset_bot<w> ” 

cprintf ( " » ) ; 

gotoxy (21, 19) ;// Erase "bias_current__bot<b> " 

cprintf {" ? 

gotoxy(21, 13) ; textcolor (11) ; 

cprintf ( "k_tilt ; M ) ; 

gotoxy (34,13) ; textcolor (15) ; 

cprintf { ”%6 . 2f" , k_tilt) ; 

gotoxy (21, 14) ; textcolor (11) ; 

cprintf ( "c_tilt ; 11 ); 

gotoxy (34,14) ; textcolor (15) ; 

cprintf ( M %6 . 2f " , c_tilt ) ; 

gotoxy (65, 9) ; textcolor (15) ; 

cprintf { "1 ") ; 

gotoxy (65,10) ; textcolor (15) ; 
cprintf { "u n ) ; 

gotoxy (65, 11) ; textcolor (15) ; 
cprintf ("z") ; 

gotoxy (61 , 21) ; textcolor (15) ; 
cprintf ( ” { ) H ) ; 
if (flag_GG == 1) 



NASA/TM — 2001-210701 


98 



FIVEAXW . C 


4351 

4352 

4353 

4354 

4355 

4356 

4357 

4358 

4359 

4360 

4361 

4362 

4363 

4364 

4365 

4366 

4367 

4368 

4369 

4370 

4371 

4372 

4373 

4374 

4375 

4376 

4377 

4378 

4379 

4380 

4381 

4382 

4383 

4384 

4385 

4386 

4387 

4388 

4389 

4390 

4391 

4392 

4393 

4394 

4395 

4396 

4397 

4398 

4399 

4400 

4401 

4402 

4403 

4404 

4405 

4406 

4407 

4408 


{ 

COUNTMAX = 15.0; 
flaglO = 1; 

gotoxy (52 , 5) ; textcolor (15) ; 
cprintf ("==> <=="); 

gotoxy (56 , 5) ; textcolor (14 + 12 8) ; 
cprintf ("MODAL CONTROLLER") 
if (lu =« ‘1’) 

{ 

gotoxy (62 , 21) ; textcolor (15 + 128) ; 
cprintf ( "L" ) ; 

} 

else 

if (lu == 'u') 

{ 

gotoxy (62 , 21) ; textcolor (15 + 128 ) ; 
cprintf ( «U") ; 

} 

gotoxy (16 ,18) ; textcolor (10) ; 
cprintf ("ON " ) / 
gotoxy (25,22) ; 

cprintf ( " ");// Erase x: along with output value 

flagJJ = 0;// Initialize toggle to "TILT MODE " 

£ 1 ag_GG - 0 ; // Toggl e condi t ion 
goto loop; 

} 

else 

if (flag_GG == 0) 

{ 

lu = • 1 1 ; 
flaglO - 0; 
flaglS - 1; 

gotoxy (16 , 18) ; textcolor (12+128) ; 
cprintf ("OFF") ; 
gotoxy (57, 5) ; 

cprintf (" ") ;// Erase "MODAL CONTROLLER 

gotoxy (52, 5) ; textcolor (14 + 128) ; 

cprintf ( "==> <=="); 

gotoxy (57, 5) /textcolor (10) ; 

cprintf ( "LOWER BEARING" ) ; 

gotoxy (65, 9) ; textcolor (15+128) ; 

cprintf ("1") ; 

gotoxy (61, 21) /textcolor (15) ; 
cprintf (" ");// Erase (L) & (U) 

gotoxy (3 1,8) ; textcolor (9) ; 
cprintf (" <c>CG factor: %5.2f",CG); 
gotoxy (21 , 13) ; textcolor (9) ; 
cprintf ("kv_bot<p> : %6 . 2f " , kv_bot) ; 
gotoxy (42 , 13) ; textcolor ( 9 ) ; 
cprintf ("kh_bot<g> : %6 . 2f " , kh_bot) ; 
gotoxy (21, 14) ; textcolor ( 9) ; 
cprintf ( "dv_bot<v> : %6 . 2f " , dv_bot) ; 
gotoxy (42 ,14) ? textcolor (9) ; 
cprintf ("dh_bot<d> : %6 . 2f " , dh_bot) ; 

gotoxy (21, 17) /textcolor (9) ; 

cprintf ( "of fset_bot<t> ; ») } 

gotoxy (55, 17) /textcolor (9); 
cprintf ("%5d ,T , tBias_bot) / 


NASA/TM— 200 1-210701 


99 



FIVEAXW.C 


4409 

4410 

4411 

4412 

4413 

4414 

4415 

4416 

4417 

4418 

4419 

4420 

4421 

4422 

4423 

4424 

4425 

4426 

4427 

4428 

4429 

4430 

4431 

4432 

4433 

4434 

4435 

4436 

4437 

4438 

4439 

4440 

4441 

4442 

4443 

4444 

4445 

4446 

4447 

4448 

4449 

4450 

4451 

4452 

4453 

4454 

4455 

4456 

4457 

4458 

4459 

4460 

4461 

4462 

4463 

4464 

4465 

4466 


gotoxy (21, 18) ; text color ( 9 ) ; 

cprintf ( "of fset_bot<w> 

gotoxy (55,18) ; textcolor ( 9) ; 

cprintf { "%5d" , wBias_bot) ; 

gotoxy (21, 19) ; textcolor (9) ; 

cprintf ( "of f set current_bot<b> 

gotoxy (55, 19) /textcolor (9) ; 

cprintf (*'%6 . 2f Amp.", ibias_bot) ; 

gotoxy (26 , 20) /textcolor (15) ; 

cprintf { "Force (N) " ) ; 

gotoxy (25, 21) ; textcolor ( 4); 

cprintf ( "=:= ====*=== = = " ) ; 

gotoxy {51 , 20} ; textcolor (15) ; 

cprintf ( "x_value y_value" ) ; 

gotoxy (51 , 21) ; textcolor (4 ) ; 

cprintf ( "-»**«== =======»); 


if (nw_bot == l) 

{ 


:") ; 


:"); 


gotoxy (22 , 22) /textcolor (15 ) ; 
cprintf ( "x : 11 ) ; 

gotoxy (22 , 23) / textcolor (15) ; 
cprintf ( "y : M ) ; 

} 


gotoxy (49 , 24) / textcolor (15) / 
cprintf (" + - + - 

gotoxy (4 9, 2 5) ; textcolor (15) / 
cprintf (" X X Y Y 

gotoxy (19, 11) ; textcolor (15) ; 
cprintf (" Y_AXIS 

gotoxy (36, 11) ; textcolor (13) ; 
cprintf ( n < > - test : %lu",test_signal}/ 
gotoxy (37, 11) ; textcolor (15) / 
cprintf ( "M" ) / 

gotoxy (21, 12) ; textcolor (4) / 

gotoxy (21, 15) ; textcolor (14) / 
cprintf ( H B=sa B ™»= a «s« BB= 


") ; 

") ; 

X_AXIS 11 ) ; 



") 

") 


flaglS = 1; 

flagll = 1;// Lower bearing write out block activated 
flag22 = 0;// Upper bearing write out block deactivated 
f lag33 » 0;// Thrust bearing write out block deactivated 
flag23 = 1;// Enable key press ”9 & 0" 
flag_GG = 1; 


goto loop; 

}// End of if(flag__GG == 0) 

}// End (diag == 1) 

else 

if (diag -= 0) 

{ 

if (f lag_GG == 1) 

{ 

flaglO * 1; 

gotoxy{52, 5) ; textcolor (15+128 ) ; 
cprintf ("==> <==»); 

gotoxy (56, 5) ; textcolor (14) / 
cprintf ("MODAL CONTROLLER") ; 


NASA/TM— 2001-210701 


100 



FIVEAXW . C 


4467 

4468 

4469 

4470 

4471 

4472 

4473 

4474 

4475 

4476 

4477 

4478 

4479 

4480 

4481 

4482 

4483 

4484 

4485 

4486 

4487 

4488 

4489 

4490 

4491 

4492 

4493 

4494 

4495 

4496 

4497 

4498 

4499 

4500 

4501 

4502 

4503 

4504 

4505 

4506 

4507 

4508 

4509 

4510 

4511 

4512 

4513 

4514 

4515 

4516 

4517 

4518 

4519 

4520 

4521 

4522 

4523 

4524 


gotoxy (16 , 18) ; textcolor (10) ; 
cprintf ("ON " ) ; 

flag__GG = 0;// Toggle condition 
goto loop; 

} 

else 

if (flag GG — = 0) 

{ 

flaglO « 0; 

gotoxy (52 , 5) ;// Erase("==> 
cprintfC* « ) - 

gotoxy (16 , 18) ; textcolor (12 + 128 ) ; 
cprintf ( "OFF” ) ; 

flag_GG « 1;// Toggle condition 
goto loop; 

} 

} 

goto loop; 

} 

disablesafel : { 

sgl = 0; 

gotoxy (16, 15) ; textcolor (12+128) ; 
cprintf ( ,, OFF ,f ) ; 
goto loop; 

} 

enable_safel : { 

sgl - 1; 

gotoxy (16 , 15) ; textcolor (10) ; 
cprintf (" ON "}; 
goto loop; 

} 

disable_safe2 : { 

sg2 w 0; 

gotoxy (16 , 16) ; textcolor (12+128) ; 
cprintf ( "OFF" ) ; 
goto loop ; 

} 

enable safe2 : { 

sg2 = 1; 

gotoxy (16 ,16) ; textcolor ( 10 ) ; 
cprintfC’ON ,! ) ; 
goto loop; 

} 

disable_safe3 : { 

sg3 = 0 ; 

gotoxy (16, 17) ; textcolor ( 12+128 ) ; 
cprintf ("OFF") ; 
goto loop; 

} 

enable_safe3 : { 

sg3 = 1; 

gotoxy (16, 17) ; textcolor (10) ; 
cprintf ("ON " ) ; 
goto loop; 

} 

cg_f actor_up : { 

CG = CG + 0.01; 
if (CG >0.5) 


NASA/TM— 200 1-2 10701 


101 



FIVEAXW.C 


4525 

CG = 0.5; 

4526 

MCG = 0.5 - CG; 

4527 

PCG = 0.5 + CG; 

4528 

gotoxy {46 , 8) ; textcolor (15) 

4529 

cprintf ( "%5 . 2f " , CG) ; 

4530 

goto loop; 

4531 

} 

4532 cg_factor_down : { 

4533 

CG « CG - 0.01; 

4534 

if (CG < -0.5) 

4535 

CG = -0.5; 

4536 

MCG = 0.5 - CG; 

4537 

PCG = 0.5 + CG; 

4538 

gotoxy (46, 8) ; textcolor (15 ) 

4539 

cprintf ( "%5 . 2f" , CG) ; 

4540 

goto loop; 

4541 

} 

4542 igain_ 

Up: { 

4543 

if(flag3 =* 1 && flagis *= 0) 

4544 

{ 

4545 

igainth = igainth + 0.0001; 

4546 

gotoxy (44 , 8 ) ; textcolor (15) ; 

4547 

cprintf ( "%7 . 4f 11 , igainth); 

4548 

goto loop; 

4549 

} 

4550 

goto loop ; 

4551 

} 

4552 igain_ 

down : { 

4553 

if (f lag3 1 ScSc flaglS »«* 0) 

4554 

{ 

4555 

igainth = igainth - 0.0001; 

4556 

gotoxy (44 , 8) ; 

4557 

printf ( M % 7 . 4 f " , igainth) ; 

4558 

goto loop; 

4559 

} 

4560 

goto loop; 

4561 

} 

4562 buffer 

= { 

4563 

if {flag FF -= 1)// Toggle flag 

4564 

{ 

4565 

flag4d =s 1;// Buffer on 

4566 

gotoxy (45 , 16) ; textcolor (10) ; 

4567 

cprintf ("ON ») ; 

4568 

flag_FF = 0; 

4569 

goto loop; 

4570 

} 

4571 

else 

4572 

if (flag FF == 0)// Toggle flag 

4573 

{ 

4574 

flag4d = 0;// Buffer off 

4575 

gotoxy (45 , 16) ; textcolor (12+128) ; 

4576 

cprintf ("OFF") ; 

4577 

f lag_FF = 1; 

4578 

goto loop ; 

4579 

} 

4580 

} 

4581 diagnostic:! 

4582 

gotoxy (37 , 19) ; textcolor (14) ; 


NASA7TM — 2001-210701 


102 



FIVEAXW.C 


4583 

cprintf { " 

");// Erase NASA, GLENN, RESEARCH, 

4584 

gotoxy (10,21) ; 

4585 

cprintf 


4586 

(" 


4587 

0 = 1 

• 0; 

4588 

flags = 0 

;// 1 

4589 

f lag6 - 0 

;// 1 

4590 

f lag7 « 0 

;// 1 

4591 

flags » 0 

;// | Shut down excitor functions . 

4592 

flag9 = 0;// j 

4593 

flagl2 * 0 

;// 1 

4594 

f lagl3 = 0;// | 

4595 

flaglS = 1;// Assembly condition (on) 

4596 

f lagl8 = 0 


4597 

flag21 = 0 

;// Excitation switch 

4598 

flaglO = 0 

?// Turn off modal block 

4599 

flag44 = 0 

;// Enable D.A. /X .A. display 

4600 

4601 

flag_A = 1 

// Assembly toggle set to on 

4602 

flag_B = 1 

// f_excite toggle set to on 

4603 

f lag_C = 1 

// Excitation toggle set to on 

4604 

flag_D = 1 


4605 

f lag_E = 1 


4606 

flag_F - 1 


4607 

flag_G - 1 


4608 

flag_H * 1 


4609 

f lag_I = l 


4610 

f lag_J = l 


4611 

flag_M * 1 


4612 

flag__N * 1 


4613 

flagKK - 1 


4614 

f lag_II = C 

>; 

4615 

4616 

flag4a = 0;// Shuts down Lower bearing buffer 

4617 

flag4b = 0;// Shuts down Upper bearing buffer 

4618 

flag4c * 0; 

// Shuts down Thrust bearing buffer 

4619 

4620 

rr = 0; 

4621 

o 

o 

H 

J 

O 


4622 

o 

o 

II 

Eh 

J 


4623 

qq = 0; 


4624 

ii = 0.0; 


4625 

diag = 1 ; 


4626 

SSS = l;// < Condition necessary to access 

4627 

// diagnostic parameter controls . 

4628 

flag_GG = 1 

$ 

4629 



4630 

COUNTMAX = 

15.0; 

4631 

gotoxy (31, 8) ; textcolor (9) ; 

4632 

cprintf (" <c>CG factor: %5.2f" ,CG); 

4633 

gotoxy (32 , 16) ; textcolor (14 ) ; 

4634 

cprintf (” [loop buffer ] " ) ; 

4635 

4636 

if(flag4d * 

- i) 

4637 

{ 


4638 

gotoxy (45 

, 16) /textcolor (10) ; 

4639 

cprintf ( n 

ON ") ; 

4640 

} 



NASA/TM — 2001-210701 


103 



FIVEAXW . C 


4641 

4642 

4643 

4644 

4645 

4646 

4647 

4648 

4649 

4650 

4651 

4652 

4653 

4654 

4655 

4656 

4657 

4658 

4659 

4660 

4661 

4662 

4663 

4664 

4665 

4666 

4667 

4668 

4669 

4670 

4671 

4672 

4673 

4674 

4675 

4676 

4677 

4678 

4679 

4680 

4681 

4682 

4683 

4684 

4685 

4686 

4687 

4688 

4689 

4690 

4691 

4692 

4693 

4694 

4695 

4696 

4697 

4698 


else 

if (f lag4d == 0) 

{ 

gotoxy (45, 16) ; textcolor (12+128) ; 
cprintf { "OFF”) ; 

} 

gotoxy (30 , 2) ; 

printf (" ") ;// Erase DT 

gotoxy (23 , 13) ; 

cprintf (" "};// Erase LBE 

gotoxy (23 ,14}; 

cprintf (" ");// Erase UBE 

gotoxy (23 ,15) ; 

cprintf (" ");// Erase TBE 

gotoxy (48 ,2) ; textcolor (12) ; 

cprintf (" * Thrst bearing is energized !") ; 

gotoxy (4 8, 3) ; textcolor (12) ; 

cprintf (" * Upper bearing is energized I"); 

gotoxy (48 , 4) ; textcolor (12 ) ; 

cprintf { 11 * Lower bearing is energized ! " ) ; 

gotoxy (52 , 5) ; textcolor (14 + 128) ; 

cprintf ("■■> <=="); 

gotoxy (57, 5) ; textcolor (10) ; 

cprintf ( "LOWER BEARING" ) ; 

gotoxy (1, 1) /textcolor (15) ; 

cprintf ("<+,-> to toggle input-output writes'* ) ; 

gotoxy (1 , 2) /textcolor (15) ; 

cprintf ("<q> to abort control"); 

gotoxy (1, 3) /textcolor (15) / 

cprintf ("<f> to toggle loop time buffer"); 

gotoxy (1, 4) ; textcolor (15) ; 

cprintf { "<e> non diagnostic "); 

gotoxy (1,5) ; textcolor ( 15) ; 

cprintf ("< i , #> Disable safe gain "); 

gotoxy (19, 11) / textcolor (15) ; 

cprintf ( " Y_AXIS X_AXIS" ) ; 

gotoxy (36 , 11) ; textcolor (13) ; 

cprintf ("< >- test : %lu" , test_signal) ; 

gotoxy (37 , 11) ; textcolor (15) ; 

cprintf ( "M" ) ; 

gotoxy (21, 12) ; textcolor (4) ; 

cprintf (" -*====«*»============. =»==*==»===:====„«=") ; 

gotoxy (21, 15) /textcolor (14) ; 

gotoxy (21, 13) /textcolor (9) ; 

cprintf { "kv_bot<p> : %6 . 2f ” , kv_bot) ; 

gotbxy (42, 13) ; textcolor { 9) ; 

cprintf ( "kh_bot<g> : %6 . 2f " , kh_bot) ; 

gotoxy (21 , 14) /textcolor (9) ; 

cprintf ("dv_bot<v> : %6 . 2f " , dv_bot) ; 

gotoxy (42 , 14) ; textcolor (9) ; 

cprintf ( "dh_bot<d> ; %6 . 2f " , dh_bot) ; 

gotoxy (21 , 17) ; textcolor (9) / 

cprintf ( "of f set_bot<t> :”); 

gotoxy (55, 17) ; textcolor ( 9) ; 
cprintf ("%5d", tBias_bot) ; 
gotoxy (21, 18) ; textcolor (9) ; 

cprintf { "of f set_bot<w> ; « ) ; 


NASA/TM— 2001-210701 


104 



FIVEAXW.C 


4699 

4700 

4701 

4702 

4703 

4704 

4705 

4706 

4707 

4708 

4709 

4710 

4711 

4712 

4713 

4714 

4715 

4716 

4717 

4718 

4719 

4720 

4721 

4722 

4723 

4724 

4725 

4726 

4727 

4728 

4729 

4730 

4731 

4732 

4733 

4734 

4735 

4736 

4737 

4738 

4739 

4740 

4741 

4742 

4743 

4744 

4745 

4746 

4747 

4748 

4749 

4750 

4751 

4752 

4753 

4754 

4755 

4756 


gotoxy (55, 18) ; textcolor (9) ; 
cprintf ( " %5d H , wBias_bot) ; 
gotoxy (21, 19} /textcolor (9) ; 

cprintf ( "bias current_bot<b> : ") ; 

gotoxy {55 ,19) ; textcolor (9) ; 

cprintf ( u %6 .2f Amp.", ibias_bot) ; 

gotoxy (51, 20) ; textcolor (15) ; 

cprintf ( "x_value y_value" ) ; 

gotoxy {51, 21) /textcolor (4) / 

cprintf ("=-===== ===«===» ) ; 

gotoxy (49 , 24) / 

textcolor (15) ; 

cprintf {" + - + «) ; 

gotoxy (4 9 , 25) ; 
textcolor (15) ; 

cprintf (" X X y y "); 

gotoxy(64, 7) ; textcolor (11) ; cprintf ( "Display Parameter") 

gotoxy (64 , 8) / textcolor (15) ; cprintf ( ) 

gotoxy(64, 9) ; textcolor (13) / cprintf ( "< >Lower Bearing"); 

gotoxy (65, 9) ; textcolor (15) /cprintf ("1") ; 

gotoxy(64, 10) /textcolor (13) /cprintf ("< >Upper Bearing"); 

gotoxy (65, 10) /textcolor (15) ; cprintf ( "u" ) ; 

gotoxy(64, 11) /textcolor (13) /cprintf ("< >Thrst Bearing"); 

gotoxy (65, 11} / textcolor (15) ; cprintf { "z" ) ; 

gotoxy (64,13) ; textcolor (11) ; cprintf ("Energizing Parmtr") 

gotoxy (64 , 14) ; textcolor ( 15) ; cprintf ("=-=========«==:=«" ) 

gotoxy (64, 15) ; textcolor (13) /cprintf ("<H>Thrst Bearing") ; 

gotoxy (65, 15) /textcolor (15) ; cprintf ( "H" ) ; 

gotoxy (64 , 16) /textcolor (13) /cprintf ( "< >Upper Bearing"); 

gotoxy (65, 16) ; textcolor (15 ) /cprintf ("I") ; 

gotoxy(64, 17) /textcolor (13) /cprintf ("< >Lower Bearing"); 

gotoxy (65, 17) /textcolor (15) ; cprintf ( "J" ) / 

gotoxy (2, 18) ; textcolor (14 ) ; 

cprintf ("< > MODAL CTRL "); 

gotoxy (3 , 18 ) / textcolor (15+128) ; 

cprintf ( "m" ) / 

gotoxy (16, 18) ; textcolor (12+128) ; 

cprintf ( "OFF") ; 

gotoxy (2 , 19) /textcolor (14) ; 

cprintf ( " < > EXCITATION " ) ; 

gotoxy (2 , 19) ; textcolor (14 ) ; 

cprintf ( " <%u>EXCITATION » , num) ; 

gotoxy (16 , 19) ; textcolor ( 12+128 } ; 

cprintf ("OFF") ; 

gotoxy (26 , 20} ; textcolor (15) / 

cprintf ( "Force (N) ") ; 

gotoxy (25, 21) /textcolor (4 ) ; 

cprintf (”==-======«") ; 

gotoxy (1,20) ; textcolor (15) ; 

cprintf ("<x>Frq_inpt :%7.2f Hz. n ,freq) ; 

gotoxy (1, 25) /textcolor (15) / 

cprintf ("<s>to adjust Pulse Width"); 

gotoxy (27, 24) /textcolor (14) / 

cprintf ("[<, > Enable exction.]"); 

gotoxy (28, 25) / textcolor {14 ) / 

cprintf ("[<: > Assembly ]")/ 

gotoxy (42 , 25) / textcolor (10) ; 

cprintf ("ON") / 


NASA/TM — 200 1-210701 


105 



FIVEAXW . C 


4757 

4758 

4759 

4760 

4761 

4762 

4763 

4764 

4765 

4766 

4767 

4768 

4769 

4770 

4771 

4772 

4773 

4774 

4775 

4776 

4777 

4778 

4779 

4780 

4781 

4782 

4783 

4784 

4785 
4766 

4787 

4788 

4789 

4790 

4791 

4792 

4793 

4794 

4795 

4796 

4797 

4798 

4799 

4800 

4801 

4802 

4803 

4804 

4805 

4806 

4807 

4808 

4809 

4810 

4811 

4812 

4813 

4814 


goto loop; 

} 

non_di agnostic : { 

clrscr (} ; 


o 

= 

1.0; 


flags 


0;// 

i 

f lag6 


0/// 

i 

flag 7 


0;// 

i 

flags 

= 

0;// 

i Shut down excitor functions 

f lag9 

= 

0;// 

1 

f lagl2 

- 

Q;// 

1 

f lag!3 

= 

0;// 

1 

f lagl6 


1;// 

Assembly condition (on) 

f laglO 

= 

0;// 

Turn off modal block 

f lag__A 

= 

1;// 

Assembly toggle set to on 

flag_B 

= 

1;// 

f_excite toggle set to on 

f lag_C 

= 

l;// 

Excitation toggle set to on 

f lag_D 


i; 


f lag_E 

= 

l; 


f lag_F 


l; 


f 1 ag_G 

= 

If 


f lag_H 


l; 


flag_I 

* 

l; 


flag_J 

= 

i; 


f lag_M 


i; 


f lag_N 

3 

1; 


flagKK 

= 

i; 



flag_Il *= 0; 
flag_CC - 0; 
flag_DD - 0; 
flag_EE = 0; 


flagl8 = 0/ 

flag21 « 0;// Excitation switch 
flag4 =0; 

SSS = 0; 
f lag_GG = 1; 

COUNTMAX = 15.0; 

gotoxy (1, 1) ; textcolor (15) ; 

cprintf ( "<x/k> to adjust frequency"); 

gotoxy (1,2) / textcolor (15) ; 

cprintf ( "<q> to abort control"); 

gotoxy (1, 3) ; textcolor (15) ; 

cprintf ("<m> to toggle modal cntrl") ; 

gotoxy (1 , 4 ) /textcolor (15) ; 

cprintf ( "<?> to toggle f_excite") ; 

gotoxy (l, 5) / textcolor (15) / 

cprintf { "<4-0> to select excitation"); 

gotoxy (5 9, 1) /textcolor (15) ; 

cprintf ("[ file : FiveAx.c ] " ) ; 

gotoxy (23 , 14) ; 

cprintf (" ");// -Erase TBF 

gotoxy (31, 2) ; textcolor (11) ; 
cprintf ( "DIAGNOSTIC TOGGLE<E>") ; 
gotoxy (31, 8) /textcolor (9) ; 


N AS A/TM— 200 1 -2 i 070 1 


106 



FIVEAXW.C 


4815 

4816 

4817 

4818 

4819 

4820 

4821 

4822 

4823 

4824 

4825 

4826 

4827 

4828 

4829 

4830 

4831 

4832 

4833 

4834 

4835 

4836 

4837 

4838 

4839 

4840 

4841 

4842 

4843 

4844 

4845 

4846 

4847 

4848 

4849 

4850 

4851 

4852 

4853 

4854 

4855 

4856 

4857 

4858 

4859 

4860 

4861 

4862 

4863 

4864 

4865 

4866 

4867 

4868 

4869 

4870 

4871 

4872 


cprintf { " <c>CG factor; %5.2f" , CG) ; 

gotoxy (27 , 9) ; textcolor { 10 ) ; 

cprintf ( M [ loop time: micro-sec ]”); 

gotoxy (1,8) ; textcolor (15) ; cprintf ( M [ THE MAGNETIC ]"}; 

gotoxy (1 , 9) ; textcolor (15) ; cprintf { " [BEARING SYSTEM IS]"); 

gotoxy (1, 10) ;textcolor (15) /cprintf (" [ ] ») 

gotoxy (9, 11) ; textcolor (15) /cprintf (" | ") ; 

gotoxy (9,12) /textcolor (15) /cprintf (" j «) ; 

gotoxy (4 , 10 } / textcolor (12+128) ; 

cprintf ( M OPERATIONAL ! ") ; 

gotoxy (26 , 13) ; textcolor (14) / 

cprintf ( " = = > <=*•«); 

gotoxy (30, 13) /textcolor (12+128) / 

cprintf ("THRST BEARING ENERGIZED"); 

gotoxy (26, 14) /textcolor (14) ; 

cprintf ( "==> <==»); 

gotoxy (30, 14 ) ; textcolor (12+128) ; 

cprintf { "UPPER BEARING ENERGIZED"); 

gotoxy (26, 15) /textcolor (14) ; 

cprintf ("==> <-=*•) ; 

gotoxy (3 0, 15) / textcolor { 12 + 128 ) ; 

cprintf ("LOWER BEARING ENERGIZED") ; 

nw_bot = 0; 

nw_top = 0; 

nw_th * 0 ; 

gotoxy (1,22) / textcolor (13 ) ; 
cprintf ("<Excitation Parmtr>") ; 
gotoxy (1,14) /textcolor (10) / 
cprintf ("< >PHSE ANG : %3u deg",th) ; 
gotoxy (2, 14) ; textcolor (15) ; 
cprintf ( "n" ) ; 

gotoxy (1, 24) /textcolor (15) / 

cprintf ( "<a>Ampli tude : %4 . If v 0-pk n ,volt); 

gotoxy (1 , 20) /textcolor (15) ; 

cprintf ("<x>Frq_inpt:%7,2f Hz . " , f req) ; 

gotoxy (1, 25) / textcolor (15) ; 

cprintf ("<s>to adjust Pulse Width"); 

gotoxy (48 ,22) ; 

printfC ») j 

gotoxy (46,23) ; 

printf(" »■) ; 

diag = 0; 

flagl = 1;// Lower bearing block activated 
f lag2 = 1/// Upper bearing block activated 
f lag3 » 1;// Thrust bearing block activated 

flagll = 1/ 
f lag22 = 1/ 
flag33 = 1; 

f lag44 = 0;// Enable D.A./I.A. display 

sgl - 1; 
sg2 - 1; 
sg3 « 1/ 

gotoxy (1,15) ; textcolor (15) ; 


NASA7TM — 200 1-210701 


107 



FIVEAXW . C 


4873 

4874 

4875 

4876 

4877 

4878 
.4879 

4880 

4881 

4882 

4883 

4884 

4885 

4886 

4887 

4888 

4889 

4890 

4891 

4892 

4893 

4894 

4895 

4896 

4897 

4898 

4899 

4900 

4901 

4902 

4903 

4904 

4905 

4906 

4907 

4908 

4909 

4910 lower_bearing : { 

4911 

4912 

4913 

4914 

4915 

4916 

4917 

4918 

4919 

4920 

4921 

4922 

4923 

4924 

4925 

4926 

4927 

4928 

4929 

4930 


cprintf ( " [ ] '» ) ; 

gofcoxy (2 , 15) ;textcolor (14) ; 
cprintf ( M Lwr Safe Gain M ); 
gotoxy (16 , 15) ; textcolor (10) ; 
cprintf ("ON " ) ; 
gotoxy (1 , 16) /textcolor (15) ; 
cprintf ( 11 [ } " ) ; 

gotoxy (2 , 16) ; textcolor (14) ; 
cprintf ( "Upr Safe Gain R ); 
gotoxy (16 , 16 ) ; textcolor (10) ; 
cprintf ( M ON ") ; 
gotoxy (1 , 17) ; textcolor (15) ; 
cprintf ( M [ ] n ) ; 

gotoxy (2, 17) ; textcolor (14 ) ; 
cprintf { "Tht Safe Gain "); 
gotoxy (16, 17) ; textcolor (10) ; 
cprintf ( "ON "); 
gotoxy (1 , 18) ; textcolor (15) ; 
cprintf ( " [ ] » ) ; 

gotoxy (2, 18) ; textcolor (14) ; 
cprintf ("MODAL CNTRL »); 

gotoxy (16, 18) ; textcolor (12+128) ; 
cprintf ( "OFF" ) ; 
gotoxy (1, 19) ; textcolor (15) ; 
cprintf ( " [ ] " ) ; 

gotoxy (2 , 19) ; textcolor (14) ; 
cprintf ("<%u>EXCITATION %num) ; 

gotoxy (16, 19) ; textcolor { 12+128 ) ; 
cprintf ("OFF") ; 
gotoxy (27, 24) ; textcolor (14 ) ; 
cprintf ("[<, > Enable exction . ] " ) ; 
gotoxy (28 , 25) ; textcolor (14) ; 
cprintf ("[<: > Assembly ]"); 
gotoxy (42 , 25) / textcolor (10) ; 
cprintf ( "ON" ) ; 
goto loop; 


if (f lag_CC == 1) 

{ 

gotoxy (4 8, 4) ; textcolor (12 ) ; 

cprintf {" * Lower bearing is energized !" ); 

gotoxy (65, 17) ; textcolor ( 15) /cprintf ( "J") ; 
flagl = 1; 

f lag4a = 0;// Shuts down Lower bearing buffer 
f lag_CC = 0; 
goto loop; 

} 

else 

if(flag_CC «= 0) 

{ 

gotoxy (52, 4) ; textcolor (14+128 ) ; 
cprintf ( "Lower bearing not energized !" ); 
gotoxy{65, 17) ; textcolor (15+128) ?cprintf ("J") ; 
flagl = 0; 

f lag4a =* 1;// Turn on Lower bearing buffer 
flag_CC = 1; 
goto loop; 


NASAmi— 2001-210701 


108 



FIVEAXW . C 


4931 

4932 } 

4933 upper_bearing : { 

4934 

4935 

4936 

4937 

4938 

4939 

4940 

4941 

4942 

4943 

4944 

4945 

4946 

4947 

4948 

4949 

4950 

4951 

4952 

4953 

4954 

4955 } 

4956 thrust_bearing : { 

4957 

4958 

4959 

4960 

4961 

4962 

4963 

4964 

4965 

4966 

4967 

4968 

4969 

4970 

4971 

4972 

4973 

4974 

4975 

4976 

4977 

4978 } 

4979 l_on:{ 


} 


if (f lag_DD == 1) 

{ 

gotoxy (48,3) ; text color (12 ) ; 

cprintf( M * Upper bearing is energized !"); 
gotoxy (65, 16) ; textcolor (15) ;cprintf ("I”) ; 
flag2 = 1; 

flag4b = 0;// Shuts down Upper bearing buffer 
flag_DD = 0; 
goto loop; 

} 

else 

if(flag_DD == 0) 

{ 

gotoxy (52,3) ; textcolor ( 14+128) ; 
cprintf ( "Upper bearing not energized !"); 
gotoxy (65,16) ; textcolor (15+128) ; cprintf {" I ») ; 
flag2 = 0; 

f lag4b - 1;// Turn on Upper bearing buffer 
flag_DD = 1; 
goto loop; 

} 


if(flag_EE »» 1) 

{ 

gotoxy (48,2) ; textcolor (12) ; 

cprintf (" * Thrst bearing is energized !”); 

gotoxy (65, 15) ; textcolor (15) ; cprintf ("H") ; 
flag3 = 1; 

flag4c = 0;// Shuts down Thrust bearing buffer 
flag_EE = 0; 
goto loop; 

} 

else 

iffflagJEE == 0) 

{ 

gotoxy (52,2) ; textcolor { 14+128) ; 
cprintf ("Thrst bearing not energized t " ); 
gotoxy (65, 15) ; textcolor (15+128) ; cprintf ( "H" ) ; 
f lag3 « 0; 

flag4c « 1;// Surn on Thrust bearing buffer 
flag_EE = 1; 
goto loop; 

} 


4980 

4981 

4982 

4983 

4984 

4985 

4986 

4987 

4988 


if (flaglO — 0)// Disable this block when in modal jnode 

{ 

gotoxy (31, 8) ; textcolor (9) ; 
cprintf (" <c>CG factor: %5.2f' ? ,CG); 
gotoxy (52, 5) ; textcolor (14+128) ; 
cprintf ( "-*> 

gotoxy (57, 5) /textcolor (10) ; 
cprintf ( "LOWER BEARING" ) ; 
gotoxy (21, 13) ; textcolor { 9) ; 


NAS AvTM — 200 1-2 1 070 1 


109 


FIVEAXW.C 


4989 

4990 

4991 

4992 

4993 

4994 

4995 

4996 

4997 

4998 

4999 

5000 

5001 

5002 

5003 

5004 

5005 

5006 

5007 

5008 

5009 

5010 

5011 

5012 

5013 

5014 

5015 

5016 

5017 

5018 

5019 

5020 

5021 

5022 

5023 

5024 

5025 

5026 

5027 

5028 

5029 

5030 

5031 

5032 

5033 

5034 

5035 

5036 

5037 

5038 

5039 

5040 

5041 

5042 

5043 

5044 

5045 

5046 


cprintf ("kv_bot<p> ; £6 . 2f M , kv_bot) ; 
gotoxy (42 , 13) ; text color { 9) ; 
cprintf ("kh_bot<g> : %6 . 2f 11 # kh_bot) ? 
gotoxy (21 , 14 ) ; textcolor (9) ; 
cprintf (”dv_bot<v> : %6 . 2f M , dv_bot) ; 
gotoxy (42 , 14} ; textcolor (9) ; 
cprintf { "dh__bot<d> : %6 . 2f 11 , dh_bot ) ; 

gotoxy (21 , 17) ; textcolor ( 9) ; 

cprintf ( "of f set_bot<t> ; ») ; 

gotoxy (55,17) ; textcolor (9) ; 
cprintf ( ”%5d" , tBias_bot) ; 
gotoxy (21,18) ; textcolor (9) ; 

cprintf { "of f set_bot<w> : ; 

gotoxy ( 55 , 18) ; textcolor (9) ; 

cprintf (" %5d" , wBias_bot) ; 

gotoxy (21, 19) ; textcolor (9) / 

cprintf ( "bias current_bot<b> 

gotoxy (55 , 19) ; textcolor (9) ; 

cprintf ("%6.2f Amp.", ibias_bot) ; 

gotoxy (26 , 20) ; textcolor (15) ; 

cprintf ( 11 Force (N) " ) ; 

gotoxy (25, 21) ; textcolor ( 4) ; 

cprintf ( "===*-====«-" ) ; 

if (nw_bot == 1) 

{ 

gotoxy (22 , 22) / textcolor ( 15) ; 
cprintf ( "x: " ) ; 

gotoxy (22 , 23) ; textcolor (15) ; 
cprintf ( "y: ") ; 

} 

gotoxy (51 , 20) ; textcolor (15) ; 
cprintf ( "x_value y_value" ) ; 

gotoxy (51 , 21) ; textcolor (4 ) ; 
cprintf (" ===*-!®= »*==**»=«); 

gotoxy (27, 23) ; 

cprintf (" ");// Erase [<*> to toggle D.A. 

gotoxy (49 , 24 ) ; textcolor (15) ; 

cprintf (" + - + »*) ; 

gotoxy (49 , 25) ; textcolor (15) ; 

cprintf (” X X Y Y " ) ; 

gotoxy (19 , 11) ; textcolor (15) ; 

cprintf (" Y_AXIS X__AXIS H ) ; 

gotoxy (36 ,11) ; textcolor (13 ) ; 

cprintf {"< test : %lu",test_signal); 

gotoxy (37, 11) / textcolor (15) ; 

cprintf ("M") ; 

gotoxy (21 , 12) ; textcolor (4) ; 

gotoxy (21, 15) /textcolor (14) ; 

gotoxy (6 5, 9) ; textcolor (15+128) ; 
cprintf ( "1") ; 

gotoxy (6 5 , 10) ,* textcolor (15) ; 
cprintf ( "u") ; 

gotoxy (6 5, 11) ; textcolor (15) ; 
cprintf ( "z ") ; 

flaglS = 1; 


NAS A/TM— 200 1 -21070 1 


110 


FIVEAXW.C 


5047 

5048 

5049 

5050 

5051 

5052 

5053 

5054 

5055 

5056 

5057 

5058 

5059 

5060 

5061 

5062 

5063 

5064 

5065 

5066 

5067 

5068 

5069 

5070 

5071 

5072 

5073 

5074 

5075 

5076 

5077 

5078 

5079 

5080 

5081 

5082 

5083 

5084 

5085 

5086 

5087 

5088 

5089 

5090 

5091 

5092 

5093 

5094 

5095 

5096 

5097 

5098 

5099 

5100 

5101 

5102 

5103 

5104 


}// End of if (flaglO == 0) 
if(flagl0 0 || flaglO = = l) 

{ 

lu * 1 1 1 ; 
if (nw_bot » 1) 

{ 

gotoxy (37, 22) ; textcolor (10) ; 
cprintf ( "Displacement : M ) ; 

} 

if (f laglO == 1) 

{ 

gotoxy (62 , 21) ; textcolor (15+128) ; 
cprintf ( "L n ) ; 

} 

flagll = 1;// Lower bearing write out block activated 
flag22 = 0;// Upper bearing write out block deactivated 
f lag33 = 0;// Thrust bearing write out block deactivated 
}// End of if (flaglO 0 \ \ flaglO == 1) 
flag23 *= 1;// Enable key press "9 & 0 rr 
goto loop; 

} 

u_°n ; { 

if (flaglO 0)// Disable this block when in modal mode 

{ 

gotoxy (31, 8) ; textcolor { 9) ; 

cprintf (" <c>CG factor: %5.2f",CG); 

gotoxy (52 , 5) /textcolor (14+128) ; 

cprintf { "*=> <=="); 

gotoxy (57, 5) ; textcolor (10) ; 

cprintf ( "UPPER BEARING" ) ; 

gotoxy (21, 13) ; textcolor (9) ; 

cprintf ( "kv_top<p> : %6 . 2f " , kv_top) ; 

gotoxy (42, 13) ; textcolor (9) ; 

cprintf ( "kh_top<g> : %6 . 2f " , kh_top) ; 

gotoxy (21 , 14) ; textcolor (9) ; 

cprintf {"dv_top<v> : %6 . 2f " , dv_top) ; 

gotoxy (42, 14) ; textcolor (9) ; 

cprintf { "dh_top<d> : %6 . 2f " , dh_top) ; 

gotoxy (21 ,17) ; textcolor (9); 

cprintf ( "of fset_top<t> :"); 

gotoxy (55 , 17 ) ; textcolor (9) ; 
cprintf ( "%5d n , tBias_top) ; 
gotoxy (21, 18) /textcolor (9); 

cprintf ( "of fset_top<w> : n ); 

gotoxy (55, 18) ; textcolor (9) ; 
cprintf ( " %5d" , wBias_top) ; 
gotoxy (21, 19) ; textcolor ( 9) ; 

cprintf ( "bias current_top<b> :"); 

gotoxy (55, 19) /textcolor (9) ; 

cprintf ("%6.2f Amp.", ibias_top) ; 

gotoxy (26 , 20) ; textcolor (15 ) ; 

cprintf ( "Force (N) " ) ; 

gotoxy(25, 21) /textcolor ( 4) ; 

cprintf { " ====■===*== |f ) ; 

if (nw_top == l) 

{ 

gotoxy (22, 22) ; textcolor (15) ; 


NASA/TM— 2001-210701 


111 



FIVEAXW . C 


5105 

5106 

5107 

5108 

5109 

5110 
.5111 

5112 

5113 

5114 

5115 

5116 

5117 

5118 

5119 

5120 

5121 

5122 

5123 

5124 

5125 

5126 

5127 

5128 

5129 

5130 

5131 

5132 

5133 

5134 

5135 

5136 

5137 

5138 

5139 

5140 

5141 

5142 

5143 

5144 

5145 

5146 

5147 

5148 

5149 

5150 

5151 

5152 

5153 

5154 

5155 

5156 

5157 

5158 Z 

5159 

5160 

5161 

5162 


cprmtf ("X: ") ; 

gotoxy (22 , 23) ; textcolor (15) ; 
cprintf ("y: ") ; 

} 

gotoxy ( 51 , 20) ; textcolor (15) ; 
cprintf ( M x value y value " ) ; 


gotoxy (51 , 21) ; textcolor (4 ) ; 
cprintf { "===-=== »■: 

gotoxy (27 , 23) ; 
cprintf { " 

gotoxy (49 , 24) ; textcolor (15) ; 
cprintf (" + - + 

gotoxy (49, 2 5) ; textcolor (15) ; 
cprintf ( w X X Y 

gotoxy (19, 11) ; textcolor (15) ; 
cprintf (" Y_AXIS 

gotoxy (36 ,11) ; textcolor (13 ) ,* 
cprintf ("< >- test : *lu" ,test_ 
gotoxy (37, 11) ; textcolor (15 ) ; 
cprintf C'M") ; 

gotoxy (21, 12 ) / textcolor (4 ) ; 
cprintf {" =»====*«!»====*== === 
gotoxy (21, 15) ; textcolor (14 ) ; 
cprintf ("===«.*====«»===-=== = 
gotoxy (65 , 9) ; textcolor (15) ; 
cprintf ("l") ; 


■“"> f 

") ;// Erase f< A > to toggle D.A . ] 
- "); 

Y n ) ; 

X_AXIS rt ) ; 

ignal) ; 



gotoxy (65, 10) ; textcolor (15 + 128 ) ; 
cprintf ("u") ; 

gotoxy (65 , 11} ; textcolor (15) ; 
cprintf ( M z M ) ; 


flaglS = 1; 

}// End of if(flagl0 == 0) 
if(flagl0 0 | | flaglO == 1) 

{ 

lu *= ' U 1 ; 

if(nw_top == 1) 

{ 

gotoxy (37 , 22) ; textcolor (10) ; 
cprintf ( ,f Di splacement : " ) ; 

} 

if (flaglO == l) 

{ 

gotoxy (62 ,21) ; textcolor (15+128) ; 
cprintf ("U ") ; 

} 

flagll = 0;// Lower bearing write out block deactivated 
flag22 * 1;// Upper bearing write out activated 
flag33 = 0;// Thrust bearing write out block deactivated 
}// End of if (flaglO == 0 | | flaglO «= l) 
flag23 = 1;// KnaJble key press n 9 & 0" 
goto loop; 

} 

on: { 

if (flaglO == 0)// Disable this block when in modal mode 

{ 

gotoxy (31, 8) ; textcolor (9) ; 

cprintf ("<(,) >igainth: %7 . 4f " , igainth) ; 


NASA/TM — 2001-210701 


112 



FIVEAXW.C 


5163 

gotoxy (52,5) ; textcolor (14+128) ; 


5164 

cprintf ( "==> <= 

«") ; 

5165 

gotoxy (57, 5) ; textcolor ( 10) ; 


5166 

Cprintf { "THRUST BEARING") ; 


5167 

gotoxy (21,13) ; textcolor (9); 


5168 

cprintf { ”kv_th<p> :%6.2f" , kv 

_th) ; 

5169 

gotoxy (42, 13) ; textcolor (9) ; 


5170 

cprintf <" ");// Erase top right half 

5171 

gotoxy (21 , 14) ; textcolor { 9) ; 


5172 

cprintf ( "dv_th<v> :%6.2f" ,dv 

.th) ; 

5173 

gotoxy (42 , 14) ; textcolor (9) ; 


5174 

cprintf {" ") ,-// Erase bottom right half 

5175 

gotoxy (21 , 17) ; textcolor (9) ; 


5176 

cprintf ( "of f set_th<t> 


5177 

gotoxy (55, 17) ; textcolor (9) ; 


5178 

cprintf ( " %5d" , tBias_th) ; 


5179 

gotoxy (21, 18 ); textcolor (9) ; // Erase wBias th 

5180 

cprintf ( " 

") ; 

5181 

gotoxy (21, 19) ; textcolor (9) ; 


5182 

cprintf ( "bias current_th<b> 

:") ; 

5183 

gotoxy (55,19) ; textcolor ( 9 ) ; 


5184 

cprintf ("%6.2f Amp.", ibias_th); 


5185 

gotoxy ( 50 , 20) ; textcolor (15) ; 


5186 

cprintf (" z_value 

") ; 

5187 

gotoxy (50 , 21) ; textcolor (4) ; 


5188 

cprintf ( " ======= 

"); 

5189 

gotoxy (26 , 20) ; textcolor (15) ; 


5190 

cprintf ( "Force (N) " ) ; 


5191 

gotoxy (25 , 21) ; textcolor ( 4) ; 


5192 

■ cprintf { "===-=====,=='») ; 


5193 

gotoxy (24, 22) ; // Erase x : 


5194 

printf ( " 


5195 

gotoxy (22 , 23 ); // Erase y : 


5196 

printf 


5197 

(" 


5198 

gotoxy (4 9, 24) ; textcolor (15 ) ; 


5199 

cprintf (" + 

") ; 

5200 

gotoxy (49 , 25) ; textcolor (15) ; 


5201 

cprintf (" Z Z 

") ; 

5202 

gotoxy (19, 11) ; textcolor (15) ; 


5203 

cprintf {" ZJUIZS 

") ; 

5204 

gotoxy (36 , 11) ; textcolor ( 13 ) ; 


5205 

cprintf ("< >- test : %lu",test signal); 

5206 

gotoxy (37 , 11) ; textcolor ( 15) ; 


5207 

cprintf ( M M" ) ; 


5208 

gotoxy (21 , 12) ; textcolor (4) ; 


5209 

cprintf 

") ; 

5210 

gotoxy (21, 15) ; textcolor (14) ; 


5211 

cprintf ( "=--================ 

") ; 

5212 

gotoxy (22 , 22) ; textcolor (15) ; 


5213 

cprintf (" ");// Erase "x:" 


5214 

if (nw th == 1) 


5215 

{ 


5216 

gotoxy (37, 22) ; textcolor (10) ; 


5217 

cprintf ( "Displacement : " ) ; 


5218 

gotoxy (22,22) ; textcolor (15) ; 


5219 

cprintf ( "z : " ) ; 


5220 

} 



NASA/TM — 200 1-210701 


113 



FI VEAXW . C 


5221 

5222 

5223 

5224 

5225 

5226 

5227 

5228 

5229 

5230 

5231 

5232 

5233 

5234 

5235 

5236 

5237 

5238 

5239 

5240 

5241 

5242 

5243 

5244 

5245 

5246 

5247 

5248 

5249 

5250 

5251 

5252 

5253 

5254 

5255 

5256 

5257 

5258 

5259 

5260 

5261 

5262 

5263 

5264 

5265 

5266 

5267 

5268 

5269 

5270 

5271 

5272 

5273 

5274 

5275 

5276 

5277 

5278 


gotoxy (65, 9) ; textcolor (15) ; 
cprintf ( " 1 " ) ; 

gotoxy (65 , 10) /textcolor (15) ; 
cprintf ( H u n ) ; 

gotoxy (65 , 11) ; textcolor (15+128) ; 
cprintf ( M z M ) ; 

flaglS = 0; 

flagll = 0;// Lower bearing write out block deactivated 
flag22 « 0;// Upper bearing write out block deactivated 
flag3 3 =* 1;// Thrust bearing write out block activated 
flag23 = 0;// Disable key press n 9 & 0 n 
f 1 ag GQ — 1 / 

goto loop/ 

}// End of if (flaglO *= 0) 
goto loop; 

} 

kv__up : { 

if(flagl0 0) 

{ 

if (flagll == 1) 

{ 

kv_bot - kvjbot + 0.1; 
gotoxy (34 ,13} ; textcolor (15) ; 
cprintf ( n %6 . 2f" , kv_bot) ; 
goto loop; 

} 

else 

if(flag22 1) 

{ 

kv_top - kv_top + 0.1; 
gotoxy (34 , 13) ; textcolor (15) ; 
cprintf (" %6 . 2f” , kv_top) ; 
goto loop; 

} ' 

•lee 

if (f lag33 == 1) 

{ 

kv_th = kv_th + 0.1; 
gotoxy (34 , 13); textcolor (15) ; 
cprintf ( "%6 . 2f" , kv_th) ; 
goto loop; 

} 

}// End of if (flaglO == 0) 
goto loop ; 

} 

kv_down : { 

if (flaglO =■ 0) 

{ 

if (flagll — 1) 

{ 

kv_bot * kvbot - 0.1; 

gotoxy (34 , 13) ; printf ( " %6 . 2f ” , kv_bot) ; 
goto loop; 

} 

else 

if(flag22 == 1) 


NAS A/TM— 2001-210701 


114 



FIVEAXW.C 


5279 

{ 


5280 

kv_top = kv_top - 0.1; 


5281 

gotoxy (34, 13) ; printf { 

" %6 

5282 

goto loop; 


5283 

} 


5284 

else 


5285 

if ( f lag33 =* 1) 


5286 

{ 


5287 

kv_th » kv_th - 0.1; 


5288 

gotoxy (34 ,13) ; printf (' 

"%6 

5289 

goto loop; 


5290 

} 


5291 

} 


5292 

goto loop; 


5293 

} 


5294 

dh_up : { 


5295 

if(flagl0 == 0) 


5296 

{ 


5297 

if(flagll == 1) 


5298 

{ 


5299 

dh_bot * dh_bot + 0.5; 


5300 

gotoxy {55, 14) ; textcolor (15) ; 

5301 

cprintf ("%6.2f ", dh_bot) ; 


5302 

goto loop; 


5303 

} 


5304 

else 


5305 

if(flag22 -= 1) 


5306 

{ 


5307 

dh_top = dh_top + 0.5; 


5308 

gotoxy (55 , 14) ; textcolor (15) ; 

5309 

cprintf ("%6.2f n f dh_top) ; 


5310 

goto loop; 


5311 

} 


5312 

} 


5313 

goto loop; 


5314 

} 


5315 

dh_down : { 


5316 

if (f laglO == 0) 


5317 

{ 


5318 

if(flagll == 1) 


5319 

{ 


5320 

dh_bot » dh_bot - 0.5; 


5321 

gotoxy (55,14) ; printf ( 

“%6 

5322 

goto loop; 


5323 

} 


5324 

else 


5325 

if ( f lag22 =*- l) 


5326 

{ 


5327 

dh_top = dh_top - 0.5; 


5328 

gotoxy (55, 14) ; printf ( 

" %6 

5329 

goto loop; 


5330 

} 


5331 

} 


5332 

goto loop; 


5333 

} 


5334 : 

kh_up : { 


5335 

if(flagl0 =* 0) 


5336 

{ 



kv_top) ; 


kv_th) ; 


dh_bot) ; 


dh_top) ; 


NAS A/TM — 200 1 -2 1 070 1 


115 


FIVEAXW.C 


5337 


if (f lagll «= 1) 

5338 


{ 

5339 


kh_bot = kh_bot + 0.1; 

5340 


gotoxy{55, 13) ; textcolor (15) 

5341 


cprintf ( "%6 . 2f " , kh_bot) ; 

5342 


goto loop; 

5343 


} ' 

5344 


else 

5345 


if(flag22 == 1) 

5346 


{ 

5347 


kh_top = kh top + 0.1; 

5348 


gotoxy (55 , 13) ; textcolor (15} 

5349 


cprintf {*» %6 . 2f" , kh_top) ; 

5350 


goto loop; 

5351 


} 

5352 

} 


5353 

goto loop; 

5354 

} 


5355 

kh_down : { 


5356 


iftflagio == 0) 

5357 


{ 

5358 


if (f lagll == 1) 

5359 


{ 

5360 


kh_bot = kh_bot - 0.1; 

5361 


gotoxy (55, 13) ; printf( M %6. 

5362 


goto loop; 

5363 


} 

5364 


else 

5365 


if (f lag22 == l) 

5366 


{ 

5367 


kh_top = kh_top - 0.1; 

5368 


gotoxy (55 , 13) ; printf(”%6. 

5369 


goto loop; 

5370 


} 

5371 


} 

5372 


goto loop; 

5373 

} 


5374 

dv_up : { 


5375 

if(flagl0 mm 0) 

5376 

{ 


5377 


if (f lagll h 1) 

5378 


{ 

5379 


d v _bot = dv_bot + 0.5; 

5380 


gotoxy (34, 14) ; textcolor (15) ; 

5381 


cpr int f ( " % 6 , 2 f M , dv_bot ) ; 

5382 


goto loop; 

5383 


} 

5384 


else 

5385 


if (flag22 == 1) 

5386 


{ 

5387 


dv_top = dv top + 0.5; 

5388 


gotoxy (34 , 14) /textcolor (15) ; 

5389 


cprintf ("%6.2f" # dv_top) ; 

5390 


goto loop; 

5391 


} 

5392 


else 

5393 


if (flag33 -= 1) 

5394 


{ 


kh hot) 


kh_top) 


NASA/TM— 2001-210701 


116 


FIVEAXW.C 


5395 

dv_th « dv_th + 0.5; 

5396 

gotoxy (34 ,14) ; textcolor (15 ) ; 

5397 

cprintf ( " %6 . 2f " , dv_th) ; 

5398 

goto loop; 

5399 

} 

5400 

} 

5401 

goto loop; 

5402 } 


5403 dv down: 


5404 

if{flagl0 == 0) 

5405 

{ 

5406 

if(flagll == l) 

5407 

{ 

5408 ' * 

dv_bot = dv_bot - 0.5; 

5409 

gotoxy (34 , 14) ; printf ( M %6 . 2f " 

5410 

goto loop; 

5411 

} 

5412 

else 

5413 

if(flag22 == 1) 

5414 

{ 

5415 

dv_top = dv_top - 0.5; 

5416 

gotoxy (34,14) ; printf ( "%6 . 2f 11 

5417 

goto loop; 

5418 

} 

5419 

else 

5420 

if (flag33 == 1) 

5421 

{ 

5422 

dv_th * dv_th - 0.5; 

5423 

gotoxy (34 ,14) ; printf ("%6.2f", 

5424 

goto loop; 

5425 

} 

5426 

} 

5427 

goto loop; 

5428 

} 

5429 wBias_up 

= { 

5430 

if (flaglO « 0) 

5431 

{ 

5432 

if (flagll l) 

5433 

{ 

5434 

wBias_bot = wBias_bot + 5; 

5435 

gotoxy (55, 18) ; textcolor (15) ; 

5436 

cprintf ("%5d M , wBias__bot) ; 

5437 

goto loop; 

5438 

} 

5439 

else 

5440 

if (f lag22 == 1) 

5441 

{ 

5442 

wBias_top = wBias_top + 5; 

5443 

gotoxy {55 , 18) ; textcolor (15) ; 

5444 

cprintf (nsd", wBias^top) ; 

5445 

goto loop; 

5446 

} 

5447 

} 

5448 

goto loop; 

5449 

} 

5450 wBias down : { 

5451 

if(flagl0 == 0) 

5452 

{ 


dv bot) 


dv^top) 


dv_th) ; 


NAS A/TM— 200 1-210701 


117 


FIVEAXW.C 


5453 


if ( f lagll == 1) 

5454 


{ 

5455 


wBias_bot » wBias_bot - 5; 

5456 


gotoxy (55 ,18) ; print f ( n %5d H , 

5457 


goto loop; 

5458 


} 

5459 


else 

5460 


if (f lag22 == 1) 

5461 


{ 

5462 


wBias top * wBias top - 5; 

5463 


gotoxy (55 , 18) ;printf ( ’^Sd " , 

5464 


goto loop; 

5465 


} 

5466 


} 

5467 


goto loop; 

5468 

} 


5469 

tBias__up : { 


5470 

iffflaglO *= 0) 

5471 

{ 


5472 


if (f lagll -= 1) 

5473 


{ 

5474 


tBias_bot = tBias_bot + 5; 

5475 


gotoxy (55, 17) ; text color (15) ; 

5476 


cprintf ( " %5d M , tBias_bot) ; 

5477 


goto loop; 

5478 


} 

5479 


else 

5480 


if (f lag22 == 1) 

5481 


{ 

5482 


tBias_top = tBias_top + 5; 

5483 


gotoxy (55 , 17) ; textcolor (15 ) ; 

5484 


cprintf ("%5d tt , tBias_top) ; 

5485 


goto loop; 

5486 


} 

5487 


else 

5488 


if (f lag33 == 1) 

5489 


{ 

5490 


tBias_th = tBias_th + 5; 

5491 


gotoxy (55, 17) ; textcolor (15) ; 

5492 


cprintf (" %5d" , tBias_th) ; 

5493 


goto loop; 

5494 


} 

5495 

} 


5496 

goto loop; 

5497 

} 


5498 

tBias_down : { 


5499 


if{flagl0 «= = 0) 

5500 


{ 

5501 


if (flagll == 1) 

5502 


{ 

5503 


tBias_bot s tBias_bot - 5; 

5504 


gotoxy (55 , 17) ; print f ( " %5d" 

5505 


goto loop; 

5506 


} 

5507 


else 

5508 


if (f lag22 == 1) 

5509 


{ 

5510 


tBias_top - tBias_top - 5; 


wBias_bot) 


wBias_top) 


tBias bot) 


NASA/TM — 200 1 -2 1 070 1 


118 


FIVEAXW . C 


5511 

5512 

5513 

5514 

5515 

5516 

5517 

5518 

5519 

5520 

5521 

5522 

5523 

5524 writeout:{ 

5525 

5526 

5527 

5528 

5529 

5530 

5531 

5532 

5533 

5534 

5535 

5536 

5537 

5538 

5539 

5540 

5541 

5542 

5543 

5544 

5545 

5546 

5547 

5548 

5549 

5550 

5551 

5552 

5553 

5554 

5555 

5556 

5557 

5558 

5559 

5560 

5561 

5562 

5563 

5564 

5565 

5566 

5567 

5568 


gotoxy (55, 17) / printf ( "%5d", tBias_top) ; 
goto loop; 

} 

else 

if (flag33 =- 1) 

{ 

tBias_th = tBias_th - 5; 

gotoxy (55, 17) ; printf ( " %5d" , tBias_th) ; 

goto loop; 

} 

} 

goto loop; 

} 

if ( f lag_B == 1) 

{ 

if (f lagll == 1) 

{ 

gotoxy (37, 22) ; textcolor (10+128 ) ; 
cprintf ( "Displacement : " ) 
if(flagl0 «= 0) 

{ 

gotoxy (22, 22) ; textcolor (15 + 128) ; 
cprintf ("x: ") ,- 

gotoxy (22 , 23 ) ; textcolor (15+128 ) ; 
cprintf ("y : ") ; 

} 

nw _b Qt - 1;// Write out enabled 
gotoxy (27,23) ; 

cprintf (" ") ;// Erase [<*> to toggle D.A. ] 

goto loop; 

} 

else 

if{flag22 =* l) 

{ 

gotoxy (37, 22) , -textcolor (10+128) ,- 
cprintf ( "Displacement : " ) ; 
if(flagl0 == 0) 

{ 

gotoxy (22,22) ; textcolor (15+128) ; 
cprintf ("x: " ) ; 

gotoxy (22,23) ; textcolor (15 + 128 ) ; 
cprintf ( "y : ” ) ; 

} 

nw_top = 1;// Write out enabled 
gotoxy (27,23) ; 

cprintf (” ");// Erase f< A > to toggle D.A . ] 

goto loop; 

} 

else 

if (flag33 == 1) 

{ 

gotoxy (37, 22) , -textcolor (10+128) ; 
cprintf ("Displacement : ") ; 
gotoxy (22 , 22 ) ; textcolor ( 15+128) ; 
cprintf ( "z : ") ; 

nw_th * 1;// Write out enabled 
gotoxy (27, 23) ; 


NAS A/TM — 200 1-210701 


119 



FIVEAXW . C 


) ;// Erase [<*> to toggle D.A . 


5569 

5570 

5571 

5572 

5573 

5574 

5575 

5576 

5577 

5578 

5579 

5580 

5581 

5582 

5583 

5584 

5585 

5586 

5587 
55B8 

5589 

5590 

5591 

5592 

5593 

5594 

5595 

5596 

5597 

5598 

5599 

5600 

5601 

5602 

5603 

5604 

5605 

5606 

5607 

5608 

5609 

5610 

5611 

5612 

5613 

5614 

5615 

5616 

5617 

5618 

5619 

5620 

5621 

5622 

5623 

5624 

5625 

5626 


cprintf(" » 

goto loop; 

} 

}// End of if(flag_B == 1) 
goto loop; 

} 

nowrite : { 

if (flag_B =« 1) 

{ 

if (flagll =- 1) 

{ 

flag44 = 0;// Enable D.A/I.A. display 
nw_bot = 0;// IVrite out disabled 
gotoxy (22 ,22) ; 
printf ( ,f 
gotoxy (22 ,23) ; 
printf 
{" 

goto loop; 

} 

else 

if ( f lag22 == 1) 

{ 

flag44 = 0;// Enable D.A/I.A. display 
nw_top = 0;// Write out disabled 
gotoxy (22 , 22) ; 
printf ( 11 
gotoxy (22 ,23) ; 
printf 
{" 

goto loop; 

} 

else 

if (f lag33 1) 

{ 

flag44 = 0;// Enable D.A/I.A, display 
nw_th = 0;// Write out disabled 
gotoxy (22 ,22) ; 
printf {" 
gotoxy (22 , 23 ) ; 
printf 
(" 

goto loop; 

} 

}// End of if(flag_B == 1) 
goto loop; 

} 

bias_up : { 

if (flaglO == 0) 

{ 

if (flagll == 1) 

{ 

ibias_bot = ibias_bot + 0.1; 
bias_current_bot = roundl (ibias_bot * 2.0 
gotoxy (55, 19) ; textcolor (15) ; 
cprintf ("%6 .2f M , ibias_bot) ; 
goto loop; 

} ' 


'■) 

") ; 

") ; 

") ; 


* 204.8) ; 


NASA/TM — 2001-210701 


120 



FIVEAXW.C 


5627 else 

5628 if (flag22 == 1) 

5629 { 

5630 ibias_top = ibias_top + 0.1; 

5631 bias_current_top = roundl {ibias_top * 2.0 * 204.8); 

56 32 gotoxy (55, 19) ; textcolor (15 } ; 

5633 cprintf ("%6.2f ", ibias_top) ; 

5634 goto loop; 

5635 } 

5636 else 

5637 if (f lag33 == 1) 

5638 { 

5639 ibias_th = ibias_th + 0.1; 

5640 bias_current_th * roundl (ibias_th * 2.0 * 204.8); 

5641 gotoxy (55, 19) ; textcolor { 15) ; 

5642 cprintf ("%6 . 2f", ibias_th) ; 

5643 goto loop; 

5644 } 

5645 } 

5646 goto loop; 

5647 } 

5648 bias_down:{ 

5649 if{flagl0 == 0) 

5650 { 

5651 if (f lagll == 1) 

5652 { 

5653 ibias__bot = ibias_bot - 0.1; 

5654 bias_current_bot = roundl (ibias_bot * 2.0 * 204.8) 

5655 gotoxy (55, 19) ; 

5656 printf ("%6.2f", ibias_bot) ; 

5657 goto loop; 

5658 } 

5659 else 

5660 if(flag22 =- 1) 

5661 { 

5662 ibias_top = ibias_top - 0.1; 

5663 bias_current_top = roundl (ibias_top * 2.0 * 204.8) 

5664 gotoxy (55, 19) ; printf ( . 2 f” , ibias_top) ; 

5665 goto loop; 

5666 } 

5667 else 

5668 if(flag33 == 1) 

5669 { 

5670 ibias_th = ibias_th - 0.1; 

5671 bias_current_th * roundl (ibias_th * 2.0 * 204.8); 

5672 gotoxy (55, 19) ; printf (" %6 . 2f M , ibias__th) ; 

5673 goto loop; 

5674 } 

5675 } 

5676 goto loop; 

5677 } 

5678 

5679 /* - RAMP DOWN WHILE SUPPORTED -- 

5680 

5681 ramp_down : { 

5682 gotoxy (10, 6) ; textcolor (14) ; 

5683 cprintf ("CONTROL RAMPING DOWN »); 

5684 


NASAVTM — 200 1-210701 


121 



FIVEAXW. C 


5685 

5686 

5687 

5688 

5689 

5690 

5691 

5692 

5693 

5694 

5695 

5696 

5697 

5698 

5699 

5700 

5701 

5702 

5703 

5704 

5705 

5706 

5707 

5708 

5709 

5710 

5711 

5712 

5713 

5714 

5715 

5716 

5717 

5718 

5719 

5720 

5721 

5722 

5723 

5724 

5725 

5726 

5727 

5728 

5729 

5730 

5731 

5732 

5733 

5734 

5735 

5736 

5737 

5738 

5739 

5740 

5741 

5742 


t48 ) ; 
t48) ; 
t48) ; 
t48) ; 
t48 ) ; 
t4 8) ; 

t48) ; 
t48 } ; 
t4 8 } ; 
t48 } ; 
t48) ; 
t48) ; 

gotoxy (31 , 7) / textcolor {14 ) ; 
cprintf (" ..... .COMPLETE i ») ; 

gotoxy (1, 8) ; print f ( " [ THE MAGNETIC ] ») ; 

gotoxy (1 , 9) /print f (" [BEARING SYSTEM IS]"); 
gotoxy {1, 10) /print f { " [ ]») ; 

gotoxy (8 ,10) ; textcolor (10+128 } / 
cprintf ( "OFF l \a\a ")/ 
if (diag == 0) 

{ 

gotoxy (26 ,13) ; 

cprintf!" ");// ERASE LBE 

gotoxy (26, 14) ; 

cprintf!" ");// ERASE UBE 

gotoxy (26 , 15) ; 

cprintf!" ") ;// ERASE TBE 

} 

loop3 : gotoxy (1,13) / textcolor (14 ) ; 

cprintf ( 11 ") ;// ERASE AYS 

gotoxy (3 ,13) ; textcolor (10) / 
cprintf { " CONTINUE (y/n) ? : " ) ; 

resp = getch ( ) ; 

if (resp =*» 'y ' ) 

{ 

if (diag == 0) 

{ 

gotoxy (26, 13) /textcolor (14) ; 
cprintf ( " ==> 

gotoxy (3 0, 13) ; textcolor (12 + 12 8 ) / 
cprintf ("LOWER BEARING ENERGIZED") ; 
gotoxy (26, 14) ; textcolor (14) / 
cprintf { " ==> 

gotoxy (30, 14) /textcolor (12+128) ; 
cprintf ("UPPER BEARING ENERGIZED")/ 
gotoxy (26 , 15) ; textcolor (14 ) / 
cprintf ( 

gotoxy (30, 15) /textcolor (12+128) ; 
cprintf ("THRST BEARING ENERGIZED") ; 

} 



outport (out_chanl_0, 
outport (out_chanl_l , 
outport (out_chanl_2 , 
outport (out_chanl_3 , 
outport (out_chanl_4 , 
outport (out_chanl_5, 

// ou tpor t (ou t_chan2_ 0 , 

outport (out_chan2__l, 
outport (out_chan2_2 , 
outport (out_chan2_3 , 
outport (out_chan2_4, 
outport (out_chan2_5, 


NAS A/TM— 200 1 -2 1 070 1 


122 


FIVEAXW.C 


5743 

if (resp == ’y' 

| [ resp == ' Y' ) 

5744 

{ 


5745 

gotoxy (10, 6) ; 

print f { " 

5746 

gotoxy (31 , 7) ; 

printf ( " 

5747 

gotoxy (3 ,13) ; 

printf (" 

5748 

gotoxy (1 , 8) ; textcolor (15) ; 

5749 

cprintf ( " [ 

THE MAGNETIC ] « ) ; 

5750 

gotoxy (1 , 9) ; textcolor (15) ; 

5751 

cprintf (■' [BEARING SYSTEM IS]"); 

5752 

gotoxy (1, 10) ; textcolor ( 15 ) ; 

5753 

cprintf ( " [ 

1 ") ; 

5754 

gotoxy (4 , 10) /textcolor (12+128) ; 

5755 

cprintf ("OPERATIONAL ! \a ") ; 

5756 

f lag_L = 0; 


5757 

goto loop; 


5758 

} 


5759 

else 


5760 

if (resp == 'n 1 

| ) resp == 'N' ) 

5761 

goto loop 2 ; 


5762 

goto loop 3 ; 


5763 

} // End ramp_down 


5764 loop2 : 

textcolor (7) ;cprintf ( n \b M ) ;clrscr () ; 

5765 return (0) ; 


5766 }// 

* * * End of wain function 


5767 

5768 float roundl (float u) 

5769 { 

5770 int g,v; 

5771 float z; 

5772 

5773 g = ceil (u) ; 

5774 z =11 + 0.5; 

5775 

5776 if (g >= z) 

5777 v = floor (u); 

5778 else 

5779 v = g; 

5780 return (v) ; 

5781 } 


" ) ; // CRD 

”) ;// c 

");// ERASE "CONTINUE?" 


* 


NAS A/TM— 200 1-210701 


123 



REFERENCES 


1. Johnson, Dexter; Brown, Gerald V.; and Mehmed, Oral: A Magnetic Suspension and Excitation System for Spin 
Vibration Testing of Turbomachinery Blades. NASA/TM — 1998-206976 (AIAA Paper 98-1851), 1998. 
http://gltrs.grc.nasa.gov/GLTRS/ 

2. Hutton, David V.: Applied Mechanical Vibrations. McGraw-Hill, New York, NY, 1981. 


NASA/TM— 2001 -2 1070 1 


124 




REPORT DOCUMENTATION PAGE 


Form Approved 
OMB No. 0704-0186 


Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing Instructions, searching existing data sources, 
gathering and maintaining the data needed, and completing and reviewing the collection of information. Send comments regarding this burden estimate or any other aspect of this 
collection of information, including suggestions for reducing this burden, to Washington Headquarters Sen/ices, Directorate for Information Operations and Reports, 1215 Jefferson 
Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project (0704-0188), Washington, DC 20503. 


1. AGENCY USE ONLY (Leave blank) 


TITLE AND SUBTITLE 


2. REPORT DATE 


April 2001 


3. REPORT TYPE AND DATES COVERED 

Technical Memorandum 


5. FUNDING NUMBERS 


A Comprehensive C++ Controller for a Magnetically Supported Vertical Rotor: 
Version 1.0 


6. AUTHOR(S) 


WU-708-28-1 3-00 


Carlos R. Morrison 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

National Aeronautics and Space Administration 
John H. Glenn Research Center at Lewis Field 
Cleveland, Ohio 44135-3191 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 


E-12632 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

National Aeronautics and Space Administration 
Washington, DC 20546-0001 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 


NASA TM— 2001-210701 


11. SUPPLEMENTARY NOTES 


Responsible person, Carlos R. Morrison, organization code 5930, 216-433-8447. 


12a. DISTRIBUTION/AVAILABILITY STATEMENT 12b. DISTRIBUTION CODE 

Unclassified - Unlimited 

Subject Categories: 31, 61, 62, and 63 Distribution: Standard 

Available electronically at http://gltrs.grc.nasa.gov7GLTRS 

This publication is available from the NASA Center for AeroSpace Information, 301-621-0390. 

13. ABSTRACT (Maximum 200 words) 

This manual describes the new FATMaCC (Five- Axis, Three-Magnetic-Bearing Control Code). The FATMaCC (pro- 
nounced “fat mak”) is a versatile control code that possesses many desirable features that were not available in previous 
in-house controllers. The ultimate goal in designing this code was to achieve full rotor levitation and control at a loop time 
of 50 ps. Using a 1-GHz processor, the code will control a five-axis system in either a decentralized or a more elegant 
centralized (modal control) mode at a loop time of 56 ps. In addition, it will levitate and control (with only minor modifi- 
cation to the input/output wiring) a two-axis and/or a four- axis system. Stable rotor levitation and control of any of the 
systems mentioned above are accomplished through appropriate key presses to modify parameters, such as stiffness, 
damping, and bias. A signal generation block provides 1 1 excitation signals. An excitation signal is then superimposed on 
the radial bearing x- and y-control signals, thus producing a resultant force vector. By modulating the signals on the 
bearing x-and y-axes with a cosine and a sine function, respectively, a radial excitation force vector is made to rotate 360° 
about the bearing geometric center. The rotation of the force vector is achieved manually by using key press or automati- 
cally by engaging the “one-per-revolution” feature. Rotor rigid body modes can be excited by using the excitation module. 
Depending on the polarities of the excitation signal in each radial bearing, the bounce or tilt mode will be excited. 


14. SUBJECT TERMS 


C++ controller; Controller; Five-axis controller; Magnetic bearing controller; 
Thrust bearing; FATMaCC 


17. SECURITY CLASSIFICATION 
OF REPORT 

Unclassified 


18. SECURITY CLASSIFICATION 
OF THIS PAGE 

Unclassified 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

Unclassified 


15. NUMBER OF PAGES 

130 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


Standard Form 298 (Rev. 2-89) 
Prescribed by ANSI Std. Z39-1B 
298-102 























