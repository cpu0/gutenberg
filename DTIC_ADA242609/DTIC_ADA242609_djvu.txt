REPOpfr 


Public rtQorting burdtn tor ihit cofloaon of *nt(i 
n tdod. and rowowing tho coloctioc ol irtormat 
Hoadquarton Sarvica. Oiractoraia for intormaiK 
Managamant and Budgat Waabingion. DC 205 


1 AGENCY USE ONLY (Leave Blank) 2. REPORT DATE 3 REPORT TYPE AND DATES COVERED 

Final: 18 Sep 1991 to 01 Jun 1993 

4 TITLE AND SUBTITLE 

Ada Compiler Validation Summary Report:NEC Corporation, NEC Ada Compiler 
System for EWS-UX/V (Rel 4,0), Version Release 2.1 (4.6) EWS4800/220 (Host & 
Target), 910918S1.11216 

5. FUNDING NUMBERS 

6 AUTHOR(S) V 

National Institute of Standards and Technology i J | | \ 

Gaithersburg, MD xrrTi 

7 PERFORMING ORGANIZATION NAME(S) AND ADDReSS(ES) K 0 1 / i I'-J ' fl B, 

National Institute of Standards and Technology 

National Computer Systems Laboratory 

Bldg 255, Rm A266 W 

Gaithersburg, MD 20899 USA 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

NIST90NEC525_1_1.11 

9 SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Pentagon, RM 3E114 

Washington, D C. 20301-3081 

10 SPONSORING/MONITORING AGENCY 
REPORT NUMBER 

11 SUPPLEMENTARY NOTES - , 1 a i i ’ J ■ 

‘ i., ■■ 4. I • i t ^' 1 * S 1 V. 

12a DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 

12b DISTRIBUTION CODE 

13 ABSTRACT (Maximum 200 words) 1 


System for EWS-UX/V (Rel 4.0), Version Release 2.1(4.6), Gaithersburg, MD, EWS4800/220 (Host & Target), ACVC 

1 . 11 . 


AD-A242 609 



Form Approved 
0PM No. 0704 0188 


i 


ling inuructloni. SMicTung tuning 4tu toucctt gnlwing and mitoiang i>it dm 
oltciion of Homuiion. including tuggtniont lot rnknng ihit burdtn. to WatfangKn 
VA 22202-4302. tnd 10 ttit Oflict Of Intomuiion and ntguUoiY Allan. Ollica of 


91-15331 

iSiliilli 


14 SUBJECT TERMS 15. NUMBER OF PAGES 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 

Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. i6. price code 


17. SECURITY CLASSIFICATION 

OF REPORT 

UNCLASSIFIED 

18 SECURITY CLASSIFICATION 

UNCLASSIFED 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFIED 

20. LIMITATION OF ABSTRACT 

NSN 7540-01-280-550 

tl 1108 ( 

>64 

Standard Form 298, (Rev. 2-89) 
Prescribed by ANSI Sid. 239-128 














AVF Control Number: NIST90NEC525_1_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on 18 SEPTEMBER 1991. 

Compiler Name and Version: NEC Ada Compiler System for EWS- 

UX/V(Rel 4.0), Version Release 



2.1(4.6) 



Host Computer System: 

EWS4800/220 
4.0) R2.1 

running 

EWS-UX/V(Rel 

Target Computer System: 

EWS4800/220 
4.0) R2.1 

running 

EWS-UX/V(Rel 


See section 3.1 for any additional information about the testing 
environment. 


As a result of this validation effort. Validation Certificate 
910918S1.11216 is awarded to NEC Corporation. This certificate 
expires on 01 March 1993. 

This report has been reviewed and is approved. 


. I ■ "■ ^ / 

X ' ^ -> ^ N • .. 

Ada Validation Faaillity 
Dr. David K. Jefferslon 
Chief, Information Systems 
Engineering Division (ISED) 




Ada Validatio^h Facility 
Mr. L. Arnold Johnson 
Manager, Software Standards 
Validation Group 

Computer Systems Laboratory (CLS) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


Ada Joint Program Office 



Ada V^icMyrf Organization 
Director,'^CMuter & Software 
Engineering Mvision 
Institute for Defense Analyses 
Alexandria VA 22311 


A- Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 






AVF Control Nvimber; NIST90NEC525_1_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 1991-07-25 
AFTER ON-SITE: 1991-09-18 
REVISIONS: 1991-10-16 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 910918S1.11216 
NEC Corporation 
NEC Ada Compiler System for 
EWS-UX/V(Rel 4.0), Version Release 2.1(4.6) 
EWS4800/220 »> EWS4800/220 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


r».i- 

: ' I- 

• 4. « • ^ 





, I) 1 ? t. 


'■ r I Oij: 1 oi*, 

iA¥h'j (:r\t*/or 





AVF Control Number; NIST90NEC525_1_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on 18 SEPTEMBER 1991. 

Compiler Name and Version; NEC Ada Compiler System for EWS- 

UX/V(Rel 4.0), Version Release 
2.1(4.6) 

Host Computer System; EWS4800/220 running EWS-UX/V(Rel 

4.0) R2.1 

Target Computer System; EWS4800/220 running EWS-UX/V(Rel 

4.0) R2.1 

See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
910918S1.11216 is awarded to NEC Corporation. This certificate 
expires on 01 March 1993. 

This report has been reviewed and is approved. 


Mr. L. Ari>6^ Johnson 
Manager, Software Standards 
Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CLS) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 


I 


J Ada VaiyratiU OfUhization 
^ DirectoB, & Software 

U Engineering Division 

Institute for Defense Analyses 
Alexandria VA 22311 




Chief, Information Systems 




N1ST90NEC525-1 .1. 1 1 


DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the 
cus tomer. 

Customer: NEC Corporation 

Igarashi Building 

11-5. 2-CHOUME. SHIBAURA 

Minato-ku. Tokyo. 108 Japan 

Certificate Awardee: NEC Corporation 

Igarashi Building 

11-5. 2-CHOUME, SHIBAURA 

Minato-ku. Tokyo. 108 Japan 

Ada Validation Facility: National Institute of Standards and 

T echnology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225. Room A266 
Gaithersburg. Maryland 20899 

ACVC Version: I. 11 

Ada I mp Iementati on : 

Compiler Name and Version: NEC Ada Compiler System for EWS- 

UX/V(Rel 4.0). Version Release 
2.I(4.6) 

Host Computer System: EWS4800/220 running EWS-UX/V(Rel 

4.0) R2.1 

Target Computer System: EWS4800/220 running EWS-UX/V(Rel 

4.0) R2.I 

DecIarati on: 


I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STO-I 8 I5A ISO 
8652-1987 in the implementation listed above. 



Customer Signature and Certificate 
Awardee Signature 
Mr. Hiroyuki Sakurai 


o/ti 


2nd Language Processor Development Department 


1st Basic Software Development Division 


NEC Corporation 







TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION . 1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 


CHAPTER 3..'.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 

APPENDIX C.. . . C-1 

APPENDIX F OF THE Ada STANDARD.C-1 


























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552) . The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
.report are accurate and complete, or that the subject 
implementation has no nonconfomnities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1.2 REFERENCES 

[Ada83] Reference Manual fo r the Ada Programming Language. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 




[Pro90] Ada Compi ler Validation Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 


[UG89] Ada Compiler Validation Capability User's Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 


1-2 







For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to 
be added to a given host and target computer 
system to allow transformation of Ada programs 
into executable foirm and execution thereof. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


The means for testing compliance of Ada 
implementations. Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user’s guide and the template for 
the validation summary (ACVC) report. 


Ada An Ada compiler with its host computer system and 

Implementation its target computer system. 


Ada Joint The part of the certification body which provides 

Program policy and guidance for the Ada certification office 

(AJPO) system. 

Ada The part of the certification body which carries 

Validation out the procedures required to establish the 

Facility (AVF) compliance of an Ada implementation. 

Ada The part of the certification body that provides 

Validation technical guidance for operations of the Ada 
Organization certification system. 

(AVO) 

Compliance of The ability of the implementation to pass an ACVC 
an Ada version. 

Implementation 

Computer A functional unit, consisting of one or more 

System computers and associated software, that uses 

common storage for all or part of a program and 
also for all or part of the data necessary for 
the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including 


1-3 





Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 


ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process or service of 
all requirements specified. 

An individual or corporate entity who enters into 
an agreement with an AVF which specifies the terms 
and conditions for AVF services (of any kind) to 
be performed. 

A formal statement from a customer assuring that 
conformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, 
published as ANSI/MIL-STD-1815A-1983 and ISO 
8652-1987. Citations from the LRM take the form 
''<section>. <subsection>: <paragraph>. " 

Software that controls the execution of programs 
and that provides services such as resource 
allocation, scheduling, input/output control, 
and data management. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible, 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
successfully either by AVF testing or by 
registration [Pro90]. 


1-4 



Validation 


Withdrawn 

test 


The process of checking the conformity of an Ada 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


1-5 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 95 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-08-02. 


E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D. 

CD4024B 

CD4024C 

GD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L. . Y 

(14 

tests) 

C35705L..Y 

(14 

tests) 

C35706L..Y 

(14 

tests) 

C35707L..Y 

(14 

tests) 

C35708L..Y 

(14 

tests) 

C35802L. .Z 

(15 

tests) 


2-1 



C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 

C24113I..K (3 TESTS) use a ; 
exceeds 126 characters. 


C45321L..Y (14 tests) 

C45521L..2 (15 tests) 
C45621L..Z (15 tests) 

C46012L,.Z (15 tests) 

length in the input file which 


The following 20 tests check for the predefined type LONG_INTEGER; 
for this implementation, there is no such type: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 
predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 


C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SH0RT_FL0AT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, L0NG__FL0AT, or SH0RT_FL0AT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 


CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 


2-2 


allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 

CD1009C uses a representation clause specifying a non-default size 
for a floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 TESTS), AND CD2A840 use 
representation clauses specifying non-default sizes for access 
types. 

The tests listed in the following table check that USE_ERROR is 
raised if the given file operations are not supported for the given 
combination of mode and access method; this implementation supports 
these operations. 


Test 

File Operation Mode 

File Access Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE21020 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT 10 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT 10 


The tests listed in the following table check the given file 
operations for the given combination of mode and access method; 
this implementation does not support these operations. 

Test File Operation Mode File Access Method 


CE2105A 

CE2105B 

CE3109A 


CREATE 

CREATE 

CREATE 


IN_FILE 
IN_FILE 
IN FILE 


SEQUENTIAL_IO 
DIRECT_IO 
TEXT 10 


CE2203A checks that WRITE raises USE_ERR0R if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 


2-3 









EE2401D checks whether read, write, set_index, index, size, and 
end_of_file are supported for direct files for an unconstrained 
array type. USE_ERROR was raised for direct create. The maximum 
element size supported for DIRECT_IO is 32K bits. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot 
restrict file capacity. 

CE3111B and CE3115A associate multiple internal text files with the 
same external file and attempt to read from one file what was 
written to the other, which is assumed to be immediately available; 
this implementation buffers output. (See section 2.3.) 

CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise 
USE_ERROR if they specify an inappropriate value for the external 
file; there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the 
page number exceeds COUNT'LAST; for this implementation, the value 
of COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 71 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B26001A 

B26002A 

B26005A 

B28003A 

B29001A 

EB33aiB 

B35101A 

B37106A 

B37301B 

B37302A 

B38003A 

B38003B 

B38CXm 

B380Q9B 

B55A01A 

B61001C 

B61001F 

B61001H 

B61001I 

B61D03M 

B61001R 

B61001W 

B67001H 

B83A07A 

B83A07B 

B83A07C 

BBSETXIC 

B83E01D 

B83E01E 

B85001D 

B85008D 

B91001A 

B91002A 

E910a2B 

B91002C 

B91002D 

B91002E 

B91002F 

B91002G 

B91002H 

E910C2I 

B91002J 

B91002K 

B91002L 

B95030A 

B95061A 

B95061F 

E850SIG 

B95077A 

B97103E 

B97104G 

BAIOOIA 

BAllOlB 

BC1109A 

BCI109C 

BC1109D 

BC1202A 

BC1202F 

BC1202G 

BE2210A 

BE2413A 



C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PR0GRAM_ERR0R. 


2-4 



CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the* instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 


CE3111B and CE3115A were graded inapplicable by Evaluation 
Modification as directed by the AVO. The tests assume that output 
from one internal file is unbuffered and may be immediately read by 
another file that shares the same external file. This 
implementation raises END_ERROR on the attempts to read at lines 87 
and 101, respectively. 


2-5 



CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The testing environment consisted of a host/target computer and an 
auxiliary computer. The host/target computer and an auxiliary 
computer are connected by cassette cartridge. The configurations 
of these computers are described by the following: 

Host/target Computer System: EWS4800/220 running EWS- 

UX/V(Rel 4.0) R2.1 

Auxiliary Computer System: Sun-3/260 running SunOS, 

Version 4.0.1 

Communication link: cassette cartridge 


For technical and sales information about this Ada implementation, 
contact: 


Mr. Akio Yuzawa 

2nd Language Processor Development Department 
1st Basic Software Development Division 
NEC Corporation 

Shibaura 4-Chome, 14-22, Minato-ku, Tokyo, 108 Japan 
VOICE TELEPHONE: 81-3-3456-7446 
FAX TELEPHONE; 81-3-3456-7448 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[ProSO]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation’s maximum precision (item e; see section 2.2), and 


3-1 





those that depend on the support of a file system — if none is 
supported (item d) . All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


a) Total Number of Applicable Tests 3791 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicable Tests 284 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


f) Total Number of Inapplicable Tests 284 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
customized test suite was loaded onto an auxiliary computer, the 
Sun-3/260, via a magnetic tape device. The customized test suite 
was then transferred from the auxiliary computer to a cassette 
cartridge. The customized test suite via the cassette cartridge 
was then loaded onto the host/target computer, the EWS4800/220. 

After the test files were loaded onto the host/target computer, the 
full set of tests was processed .by the Ada implementation. 

The tests were compiled, linked, and executed on the host/target 
computer system. The results were transferred from the host/target 
computer to a cassette cartridge. The results were transferred to 
Sun-3/260 auxiliary computer system via the cassette cartridge. 
The Sun-3/260 then wrote the results to a magnetic tape. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
compiler options invoked both explicitly and implicity for 
validation testing during this test were: 


-a 

-L -a 
The linker options 
-a 


(for A, C, D, and L tests) 

(for B and E tests and support files) 
invoked explicitly for validation testing were: 
(for all tests) 


3-2 







Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-3 





APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IN_LEN—also listed here. These values are expressed here as 
Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 

$BIG_ID1 

$BIG_ID2 

$BIG_ID3 

$BIG_ID4 

$BIG_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING1 

$BLANKS 


$MAX LEN_INT_BASED_LITERAL 

"2:" & {1..V-5 =«> ’O') & "11;” 

$MAX LEN_REAL_BASED_LITERAL 

"16;" & (1..V-7 »> '0') & "F.E;" 


<126> - 

- Value 

of 

■ V 





(1. 

r^ 

1 

> 

< 

A 

11 

V 

=> ' 

1' 

) 



(1. 

.V-1 

< 

A 

II 

V 

=> ' 

2 ' 

) 



(1. 

.V/2 

=> 'A') 

& 

'3 ' 

& 

(1. 

.V-l-V/2 => 

'A' ) 

(1. 

.V/2 

=■> 'A') 

& 

•4 ' 

& 

(1., 

.V-l-V/2 => 

'A' ) 

(1. 

.V-3 

»> • O' ) 

& 

"298 

II 




(1. 

.V-5 

»> '0') 

& 

"690 

.0 

II 



1 tf 1 

& (1 

..V/2 = 

> ' 

A') 

& 

1 II 1 



I (f 1 

& (1 

. .V-l-V/2 

=> • 

A' 

) & 

' 1 ' & ' " ' 


(1. 

.V-20 

=> ' ' 

) 







$MAX_STRING_LITERAL "" & (1..V-2 »> 'A') & "" 


I 


I 


A-1 




The following table contains the values for the remaining macro 
parameters. 

Macro Parameter Macro Value 


$ACC_SIZE 

$ALIGNMENT 

$COUNT_LAST 

$ DEFAULT_MEM_SIZ E 

SDEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$ FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

$GREATER THAN DURATION 


32 

4 

2147483647 

2_097_152 

8 

EWS_UXV_R4 

2#1.0#E-31 

16#FF# 

16#FE# 

16#FD# 

35 

I I 

NO_SUCH_TYPE 

NO_SUCH_TYPE 

H »I 

"CANNOT_RESTRICT_FILE_CAPACITY" 

100000.0 


$GREATER_THAN_DURATION_BASE_LAST 200000.0 
$GREATER THAN FLOAT BASE_LAST 1.80141E+38 


$GREATER_THAN_FLOAT_SAFE_LARGE 1.0E3 08 

$GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 1.0E3 08 

$HIGH PRIORITY 32 


A-2 




$ILLEGAL_EXTERNAL_FILE_NAME1 /NODIRECTORY/FILENAME 

$ILLEGAL_EXTERNAL_FrLE_NAME2 

’'NAMES_OF_MORE_THAN__14_CHARACTERS'' & 
''NAMES_OF_MORE_THAN_14_CHARACTERS” & 

'• NAMES_OF_MORE_THAN_l 4_CHARACTERS " & 
"NAMES_OF_MORE_THAN__14_CHARACTERS'' & 
"NAMES_OF_MORE_THAN_14_CHARACTERS" & 
''NAMES_OF_MORE_THAN_14_CHARACTERS" & 
'•NAMES_OF_MORE_THAN_14_CHARACTERS" & 
"NAMES_OF_MORE_THAN_14_CHARACTERS" & 
'•NAMES_OF_MORE_THAN_l 4_CHARACTERS " 

$INAPPROPRIATE_LINE_LENGTH -1 

$INAPPROPRIATE_PAGS_LENGTH -1 

SINCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.TST") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("B28006E1.TST") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2_147_483_648 

$INTERFACE_LANGUAGE AS 

$LESS_THAN_DURAT10N -75_000.0 

$ LES S_THAN_DURATION_BAS E_FIRST 

-131_073.0 

$LINE_TERMINATOR ' ' 

$LOW_PRIORITY 1 

$MACHINE_CODE_STATEMENT 

AA_INSTR'(AA_EXIT_SUBPRGRM,0,0,0,AA_INSTR_INTG'FIRST,0); 
$MACHINE_CODE_TYPE AA_INSTR 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX INT PLUS 1 2 147 483 648 


A-3 






P" " ■ ■ ' ' ■ 

$MIN_INT 

-2147483648 

$NAME 

NO_SUCH_TYPE_AVAILABLE 

$NAME_L1ST 

EWS_UXV_R4 

$NAME_SPECIFICATI0N1 

/usr2/ada/risc_self/acvc/coni/X2120A 

$NAME_SPECIFICATI0N2 

/usr2/ada/risc_self/acvc/com/X2120B 

$NAME_SPECIFICATI0N3 

/usr2/ada/risc_self/acvc/coin/X3119A 

$NEG_BASED_INT 

16#F000000E# 

$NEW_MEM_SIZE 

2097152 

$NEW_STOR_UNIT 

8 

$NEW_SYS_NAME 

EWS_UXV_R4 

$PAGE_TERMINATOR 

f 1 

$RECORD DEFINITION 

RECORD INSTR NO: 
INTEGER;ARG3: 

INTEGER;ARGO:INTEGER;ARGl : INTEGER;ARG2: 

INTEGER ; ARG4:INTEGER;END RECORD ; 

$RECORD_NAME 

• AA_INSTR 

$TASK_SIZE 

32 

$TAS K_STORAGE_SIZ E 

1024 

$TICK 

1.0 

$VARIABLE_ADDRESS 

16#7fa30000# 

$VARIABLE_ADDRESS1 

16#7fa30020# 

$VARIABLE_ADDRESS2 

16#7fa30040# 

$YOUR_PRAGMA 

NOFLOAT 

1 

} 

i 

1 

L .. ... 

A-4 





APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-1 





NEC Ada Compilation System 
for EWS-UX/V(Rel 4.0) Release 2.1(4.6) 

Compiler Options 


September 1, 1991 
NEC Corporation 


CONTENTS 


1 


Contents 

1 Introduction 2 


2 Options for The Ada Compiler 

2.1 The Invocation Command . . 

2.1.1 The List File. 

2.1.2 The Diagnostic File . . 

2.1.3 The Configuration File 

2.2 The Source Text . 

2.3 Compiler Output. 

2.3.1 Format of the List File 

2.3.2 Source Listing. 

2.3.3 Compilation Summ<iry 

2.3.4 Diagnostic Messages . 

2.4 The Program Library. 

2.4.1 Correct Compilations . 

2.4.2 Incorrect Compilations 


3 

3 

6 

6 

6 

8 

9 

10 

10 

10 

11 

12 

12 

14 


3 Commands of The Ada Linker I 

3.1 The Invocation Command. 1 



lO ‘O 




















I INTRODUCTION 


2 


1 Introduction 

This document contains options of Ada Compiler eind Ada Linker, NEC Ada 
Compilation System for EWS-UX/V(Rel 4.0) Release 2.1(4.6). 


2 OPTIONS FOR THE ADA COMPILER 


3 


2 Options for The Ada Compiler 

The Ada Compiler is invoked by specifying a call of the program Ada to the 
shell. The invocation command is described in Section 2.1. 

If any diagnostic messages are produced during the compilation, they are 
output on the diagnostic file and on the standard output. The diagnostic file 
emd the diagnostic messages are described in Sections 2.1.2 and 2.3.4 

The user may request additional listings to be output on a list file by 
specifying options in the compiler invocation. The list file and the listings 
are described in Sections 2.1.2. 

The compiler uses a program library during the compilation. The com¬ 
pilation unit may refer to units from the program and will be showed in the 
program library as a result of a successful compilation. The program library 
is described in the attachment. Section 2.4 briefly describes how the Ada 
compiler uses the library. 

2.1 The Invocation Command 

The invocation command has the following syntax: 


ada {<options>} Oource—file—naae> {<source—file—name>} 


1. OptioTu 
—L and -1 

Causes the compiler to produce a formatted listing of the input 
sources. The listing is written on the list file. Section 2.3.2 con¬ 
tains a description of the source listing. The default is no list file, 
in which case no source listing is produced, regardless of any LIST 
pragmas in the program or any diagnostic messages produced. 

— X 

Causes the compiler to produce a cross-reference listing. If this 
option is given and no severe or fatal errors are found during the 
compilation, the cross-reference listing will be written on the list 
file. 




2 OPTIONS FOR THE ADA COMPILER 


4 


-P 

P rogress—report. 

— a <lib_ap«c> 

Specifies the current sublibrary,and therefore the program library. 
If this option is omitted, the sublibrary designated by the envi¬ 
ronment variable, ADA_LIBRARY, is used. If the variable does not 
exist, the file, ADA_LIBRARY, is used. Section 2.4 describes how the 
Ada compiler uses the library. 

—c <file_naae> 

Specifies the configiiration file to be used by the compiler in the 
current compilation. If this option is omitted, the configuration 
file (config) in the compiler directory is used. 

— 3 and —S 

Specifies that the source text is not be saved in the program li¬ 
brary. This saves some space in the sublibrary. The default is 
to save source text. In this way, the user is always certain what 
version of the source text was compiled. The source text may be 
displayed from the sublibrary with the PLU Type command. 

-B 

Build standard. Pseudo compilation of package standard. This 
option is intended for maintenance purposes only. 

—n 

No check. Suppress all run-time checks. By default, all run¬ 
time checks are generated. 

—N <key¥ord> {,<k*yword>} 

Toggle check. Selective suppress of run-time checks. If a check is 
suppressed, the option will enable the check. If a check is enabled, 
the option will suppress the check. The following keywords are 
allowed: 

• access 

• index 

• discriminant 

• range 

• length 



2 OPTIONS FOR THE ADA COMPILER 


5 


i 


f 


• elaboration 

• storage 

Keywords are case—insensitive and can be abbreviated such that 
the abbreviation is unique. 

—o 

Optimize. Optimize the program with respect to execution time, 
which, under normal circumstances, also is optimization with re¬ 
spect to size of the executable. If this option is omitted, the 
program is not optimized. 

—0 <Key«ord> {,<K«yword>} 

Toggle optimization. The correspondence between keywords and 
optimization is as follows: 


Keyword optimization 


Block Optimize block and call frames. 

Peep Peephole optimization. 

Cse Common subexpressions elimination. 

Reordering Optimize aggregates and procedure calls. 

Stackheight Minimize stack height. 

Fct2proc Change functions to procedures. 

The keywords are case—insensitive and can be abbreviated such 
that the abbreviation is unique. 


—u <unit Jiuab6r> 

Specifies that the compilation unit being compiled is assigned the 
unit number<unit_aumber> in the current sublibrary (see the at¬ 
tachment for explanation of unit numbers). This option will only 
work for: 


• compilations containing a single compilation unit which is nei¬ 
ther a subunit nor contains subunit stubs, 

• unit numbers which are unused and smaller than 32768. 


2. Parameters 

The < sourcs—file—nam«> specifies the file containing the source 
texts to be compiled. A source file is expected to have the string ” . ada” 
as the last four characters of its name. If the last part of the name does 






2 OPTIONS FOR THE ADA COMPILER 


6 


not contain ,the string ” .ada” is appended to the name . More than 
one file name must be specified. Each <source—f ile—naBe> can be 
a file name with wildcards as defined by Bourne shell. 

The compilation starts writh the leftmost file name in the file name list, 
and ends with the rightmost. If the list of file names includes a file name 
with wildcards, the files matching the wildcard name are compiled in 
alphabetical order. If any file name occurs seveial times in the list of 
file names, the file is compiled several times, i.e. one file is compiled as 
many times as its name occurs in the list of file names. 

2.1.1 The List File 

The name of the list file is identical to the name of the source file except 
that the final characters ” .ada” are replaced by ” .lis”. The list file will be 
placed in the ctirrent directory. 

2.1.2 The Diagnostic File 

The name of diagnostic file is identical to the name of the source file except 
that the final characters ”. ada” are replaced by ”. err”. The diagnostic file 
will be placed in the invoker’s current directory. 

The diagnostic file is a file containing a list of diagnostic messages, each 
followed by a line showing the number of the line in the source that caused the 
message to be generated, and then by a blank line. The file is not separated 
into pages and there are no headings. 

2.1.3 The Configuration File 

Certain functional characteristics of the compiler may be modified by the 
user. These characteristics are passed to the compiler by means of a config¬ 
uration file, which is a text file. The contents of the configuration file must 
be an Ada positional aggregate, written on one line, of the type CONFIGU¬ 
RATION-RECORD, which is described below. The configuration file is not 
accepted by the compiler in the following cases: 

• The syntax does conform with the syntax for positional Ada aggregates. 

• A value is outside the ranges specified below. 






2 OPTIONS FOR THE ADA COMPILER 


7 


• A value is not specified as a literal. 

• LINES J>ER_PAGE is not greater then TOPJIARGIN + BOTTOMJtARGIN. 

• The aggregate occupies more than one line. 

If the compiler is unable to accept the configuration file,an error message 
is written on the standard out put and the compilation is terminated. 

Type OUTFORMATTING is 
record 

LIJffiS.PER.PAGE : IMTEGER range 30..100; 

— ct. Section 2.3.1 

TOP.MARGIN : INTEGER range 4..90; 

— cf. Section 2.3.1 

BOTTOM.MARGIN : INTEGER range 0..90: 

— ci. Section 2.3.1 

OOT.LINELENGTH : INTEGER range 80.,132; 

— cf. Section 2.3.1 
SUPPRESS.ERRORNO : BOOLEAN; 

— cf. Section 2.3.4 
end record; 

Type INPUT.FORMATS is 
(ASCII); 

— cf. Section 2.2 

Type INFORMATTING is 
record 

INPUT.FORMAT : INPUT.FORMATS; 

— cf. Section 2.2 

INPUT.LIHELEHGTH : INTEGER range 70..250; 

" cf. Section 2.2 
end record; 

Type COHFIGURATION.RECQRD is 
record 

II.FORMAT : IHFORMATTING; 







2 OPTIONS FOR THE ADA COMPILER 


8 


OUT.FORMAT : OUTFORMATTING; 

ERROR.LIMIT : INTEGER; 

— cf. Section 2.3.4 
•nd record; 

The configuration file has the following content: 

((ASCII.126),(48,S,3.100.FALSE).200) 

The name of this configuration file is passed to the compiler through the 
argument supplied with the -c option. 

The output formatting parameters have the following meaning: 
LIHES_PER_PAGE: 

specifies the maximum number of lines written on each page (including 
top and bottom margin). 

TOPJURGIN: 

specifies the number of lines on top of each page used for a standaird 
heading and blank lines. The heading is placed in the middle lines of 
the top margin. 

BOTTOMJURGIN: 

specifies the minimum number of lines left blank in the bottom of the 
page. The number of lines available for the listing of the program is 
LINESJ»ER-PAGE - TOP-MARGIN - BOTTOM.MARGIN. 

OGT.LIHELEHGTH: 

specifies the maximum number of characters written on each line. Lines 
longer than OUTXINELENGTH are separated into two lines. 

SUPPRESS-ERRORNQ : 

specifies the format of error messages. 

2.2 The Source Text 

The user submits one file containing a source text in each compilation. The 
source text may consist of one or more compilation units. 








2 OPTIONS FOR THE ADA COMPILER 


9 


The format of the source text specified in the configuration file (cf. Sec¬ 
tion 2.1.3) must be the ISO-FORMAT ASCII. This format requires that the 
source text is a sequence of ISO characters (ISO standard 646), where each 
line is terminated by either one of the following termination sequences (CR 
means carriage return, VT means vertical tabulation, LF means line feed, and 
FF means form feed): 

• A sequence of one or more CRs, where the sequence is neither immedi¬ 
ately preceded nor immediately followed by any of the characters VT,LF, 
or FF. 

• Any of the characters VT,LF, or FF, immediately preceded and followed 
by a sequence of zero or more CRs. 

In general, ISO control characters are not permitted in the source text with 
the following exceptions: 

• The horizontal tabulation (HT) character may be used as a separator 
between lexical units. 

• LF, VT,FF, and CR may be used to terminate lines, as described above. 

The maximum number of characters in an input line is determined by the 
contents of the configriration file, cf. Section 2.1.3. The control characters 
CR, VT,LF, and FF are not considered a part of the line. Lines containing 
more than the maximum number of characters are truncated, and an error 
message is issued. 

2.3 Compiler Output 

The compiler may produce output in the list file, the diagnostic file and the 
standard output. It furthermore updates the program library if the compila¬ 
tion is successful. The present section describes the text output in the three 
files mentioned above. The updating of the program library is described in 
section 2.4. 

The compiler may produce the following text output: 

1. A listing of the source text with embedded diagnostic messages is writ¬ 
ten on the list file if the -L option is present. 




2 OPTIONS FOR THE ADA COMPILER 


10 

2. A compilation summary is written in the list file if the -L option is 
present. 

3. A cross-reference listing is written on the list file if the -x option is 
present and severe or fatal errors have been detected during the com¬ 
pilation. 

4. A diagnostic file containing the diagnostic messages is written if there 
axe any diagnostic messages. 

2.3.1 Format of the List File 

The list file may include one or more of the following parts: a source listing, 
a cross-reference listing and a compilation summary. 

The parts of the list file are separated by page ejects. The contents of each 
part are described in sections 2.3.2. - 2.3.4. 

The format of the output on the list file is controlled by the configuration 
file (cf. Section 2.1.3) and may therefore be controlled by the user. 

2.3.2 Source Listing 

A source listing is an unmodified copy of the source text. The listing is 
divided into pages and each line is supplied with a line number. 

The number of lines output in the source listing is governed by the occurrence 
of LIST pragmas and the number of objectionable lines. 

• Parts of the listing can be suppressed by the use of LIST pragmas, and 
page breaks may be introduced by PAGE pragmas. 

• A line containing a construct that caused a diagnostic message is printed 
even if it occurs at a point where the listing has been suppressed by a 
LIST pragma. 

2.3.3 Compilation S ummar y 

At the end of a compilation, the compiler produces a summary that is an 
output on the list file if the -L option is present. 

The summary contains information about: 






2 OPTIONS FOR THE ADA COMPILER 


11 


1. The type and name of the compilation unit, and whether it has been 
compiled successfully or not. 

2. The number of diagnostic messages produced for each class of severity, 
cf. Section 2.3.4. 

3. Which options were present. 

4. The full name of the source file. 

5. The full name of the progrcim library. 

6. The number of source text lines. 

7. The size of the text segment, the data segment, and the BSS segment. 

8. Elapsed time and CPU time. 

9. A "Compilation terminated” message if the compilation unit was the 
last in the compilation or "Compilation of next unit initiated” other¬ 
wise. 

2.3.4 Diagnostic Messages 

The Ada compiler issues diagnostic messages on the diagnostic file (cf. Sec¬ 
tion 2.1.2). Diagnostics other than warnings also appear on the standard 
output. If a source text listing is required, the diagnostics are also found 
embedded in the list file (cf. Section 2.1.1). 

In a source listing , a diagnostic message is placed immediately after the 
source line causing the message. Messages not related to any particular line 
are plawred at the top of the listing. Every diagnostic message in the diagnostic 
file is followed by a line stating the line number of the objectional line. The 
lines Me ordered by increasing source line numbers. Messages not related 
to any particular line are assigned to line 0. On the standard output the 
messages appear in the order in which they are generated by the compiler. 

The diagnostic messages are classified according to their severity auad the 
compiler action taken: 








2 OPTIONS FOR THE ADA COMPILER 


12 


Warning; Reports a questionable construct or an error that does not influ¬ 
ence the meaning of the program. Warnings do not hinder the genera¬ 
tion of object code. 

Example; A warning will be issued for constructs for which the compiler 
detects that they will raise CONSTRAINT_ERROR at run time. 

Error: Reports an illegal construct in the source program. Compilation 
continues, but no object code will be generated. 

Example: most syntax errors; most static semamtic errors. 

Severe error: Reports an error which causes the compilation to be termi¬ 
nated immediately object code is generated. Excimple; A severe 
error message v ;]' be issued if a library unit mentioned by a WITH 
clause is not present in the current program librciry. 

Fatal error; Reports an error in the compiler system itself. The compila¬ 
tion is terminated immediately and no object code is produced. The 
user may be able to circumvent a fatal error by correcting the prograun 
or by replacing program constructs with alternatives. Please inform 
NEC about the occurrence of fatal errors. 

The detection of more errors than allowed by the number specified by the 
ERROR_LIMIT parameter of the configuration file (cf. Section 2.1.3) is 
considered a severe error. 

2.4 The Program Library 

This section briefly describes how the Ada compiler changes the program 
library. For a general description of the program library refer to the attach¬ 
ment. 

The compiler is allowed to read from all sublibraries constituting the 
current program library, but only the current sublibrary may be changed. 

2.4.1 Correct Compilations 

In this section, it is assumed that the compilation units are correctly com¬ 
piled, i.e. that no errors axe detected by the compiler. 






2 OPTIONS FOR THE ADA COMPILER 


13 


Compilation of a Library Unit Which Is a Declaration 

If a declaration unit of the same name as the one currently being com¬ 
piled exists in the current sublibrary, it is deleted together with its 
body unit and the body’s possible subimits. A new declaration unit is 
inserted in the sublibrary. 

Compilation of a Library Unit Which Is a Subprogram Body 

A subprogram body in a compilation unit is treated as a secondary 
unit if the current sublibrary contains; 

« a valid subprogram declaration of the same name, or 

• a valid generic subprogram declaration of the same name. 

In all other cases, it will be treated as a library unit, i.e.: 

• when there is no library unit of that name, 

• when there is an invalid declaration unit of that name, 

• when there is a package declaration, generic package declaration 
or an instantiated package or subprogram of that name. 

Compilation of a Library Unit Which Is an Instantiation 

A declaration unit with the name of the compilation unit in the cur¬ 
rent sublibrary is deleted (if it exits) with its body unit and possible 
subunits. A new declaration unit is inserted. 

Compilation of a Secondary Unit Which Is a Library Unit Body 

The existing body is deleted from the sublibrary together with its pos¬ 
sible subunits. A new body unit is inserted. 

Compilation of a Secondary Unit Which Is a Subunit 


If the subunit exists in the sublibrary, it is deleted with its possible 
subunits. A new subunit is inserted. 






2 OPTIONS FOR THE ADA COMPILER 


14 


2.4.2 Incorrect Compilations 

If the compiler detects an error in a compilation, the program library will 
remain unchanged. 

Note that if a file consists of severjd compilation units and an error is detected 
in any of these compilation units, the program library will not be updated 
for any of the compilation units. 


I 

I 


4 


k 

f 


i 





3 


COMMANDS OF THE ADA LINKER 


15 


3 Commands of The Ada Linker 

Before a compiled Ada program can be executed, it must be linked by the 
Ada Linker. 

The Ada Linker performs two different jobs: 

• It links an Ada program. The linker will check the consistency of the 
program and decide an elaboration order for the units constituting the 
program. Any errors found will be reported on the standard output 
and optionally on a log file. If no errors are found, an executable image 
file will be produced. 

• It examines the consequences of recompilations. The linker will check 
the consistency of the specified program units as if the specified re¬ 
compilations were actuzdly performed, and determine an elaboration 
order for the program. Any errors found will be reported on the stan¬ 
dard output and optionally on a log file, together with a list of needed 
recompilations. 

It is possible to check the consequences of no recompilations, in which case 
the linker will check the consistency of the specified program units as they 
appear in the current program library. 

3.1 The Invocation Command 

The linker is invoked by submitting the following command to the command 
language interpreter: 


al {<options>} <unit_iiaBe> 


<anit.jiaa«> 

If a linking is requested, <unit_name> must specify a main program 
which is a library unit of the current program library, but not neces¬ 
sarily of current sublibrary. The library unit must be a parameterless 
procedure. Wildcard characters are not permitted. 





3 COMMANDS OF THE ADA LINKER 


16 


If examination of the consequences of recompilations is requested, <unit_name> 
specifies a set of program librciry units whose consistency adter the hy¬ 
pothetical recompilations will be checked. <unit_name> may contain 
wildcard characters which will be interpreted according tc the rules of 
the UNIX in the current sublibrary with names that match specified 
<unit_name>. All types of librairy unit may be designated. 

1. Options 

-1 <filejiaae> 

Causes the linker to produce a log file nauned < file .name >. The 
log file is written to the invoker’s current directory. The default 
is no log file. 

-L 

Causes the linker to produce a log file named ’’link.log”. The 
log file is written to the invoker’s current directory. The default 
is no log file. 

-a <libjp«c> 

Specifies the current sublibrairy and thereby also the current pro¬ 
gram library. If this option is omitted then the sublibrary des¬ 
ignated by the environment variable, ADAJ.IBRARY, is used. If 
the environmental variable is not denied, the file, ADA J.IBRARY, is 
used. 

— c 

causes the linker to check the the consistency of the program(s) 
specified by <unitjam«>. If this option is omitted then the 
specified program will be linked. 

—s and —b <unit-set> 

Define those library units after whose hypothetical recompilations 
the consistency will be checked. The meaning of <unit- 3 et> is: 
<unitj«t> <unitjiam«> {, <unitjiame>} 

For those unit names that appear with the —s option, the specifi¬ 
cations of the corresponding library units are included in the list 
of hypothetical recompilations. 

For those unit names that appear with the -b option, the bod¬ 
ies of the corresponding library units are included in the list of 
hypothetical recompilations. 


3 COMMANDS OF THE ADA LINKER 


17 


A <unit jiame> may appear in the <unit.set> of both options 
if required. 

~T <teat_code> 

Causes the linker to send test output to the log file. The <te3t-code> 
is an integer in the range 0..9. This option is only allowed if the 
—1 or — L option is present. 

~o <filena«e> 

Include the file denoted by <filename> in the link. Useful for 
including entities written in assembly language or C. 

'P "string" 

Options. The string will be inserted immediately after the ”ld” 
command when the native linker is invoked. Useful for supplying 
options for the linker. 

—I <count> 

Period. The granularity of the timer measured in 1/100 second. 
Default is 1/10 second. 

—S <coat> 

Time slice. The time between activations of the schedule measured 
in periods. Default is 10. 

-R 

No time slice. Do not activate the scheduler. 

—P <prio> 

Default priority. Specifies the default priority for tasks of a taisk 
type for which a pragma priority is not present. The default is 16. 

—D <stack> 

Default stack— size. Specifies the amount of stack allocated for 
task of a task type for which a length clause is not specified. 

2. Examples 

$ al -a aylib nyprog 

The linker will generate an executable image in the current directory 
from the program from the library mylib. 





3 COMMANDS OF THE ADA LINKER 


18 


$ al -L -c -s example -b utility myprog 

This will examine the consequences of the recompilations of the ex¬ 
ample specification and the utility body. The linker will give a list of 
necessary compilations to keep myprog consistent. The program library 
is given by the environment variable ADA_LIBRARY. 

$ al -c -3 a+b -b c prog.x 

Here the linker will examine the consistency of the program ”prog-x” 
in case of a recompilations of the specifications of the library unit ”a” 
and all library units with names starting with ”b”, and a recompilation 
of the bodies of the all library units with names starting ” c”. 

$ ail -o ObjectFile.o myprograun 

The linker will include the code in ObjectFile.o in the linkage of the 
program "myprogram". This program presumably features a program 
interface to some routines appearing in the ObjectFile. 




LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 


B-2 




3 


COMMANDS OF THE ADA LINKER 


13 


3 Commands of The Ada Linker 

Before a compiled Ada program can be executed, it must be linked by the 
Ada Linker. 

The Ada Linker performs two different jobs: 

• It links an Ada program. The linker will check the consistency of the 
program and decide an elaboration order for the units constituting the 
program. Any errors found will be reported on the standard output 
and optionally on a log file. If no errors are found, an executable image 
file will be produced. 

• It examines the consequences of recompilations. The linker will check 
the consistency of the specified program units as if the specified re¬ 
compilations were actually performed, and determine an elaboration 
order for the program. Any errors found will be reported on the stan¬ 
dard output and optionally on a log file, together with a list of needed 
recompilations. 

It is possible to check the consequences of no recompilations, in which case 
the linker will check the consistency of the specified program units as they 
appear in the cxirrent program library. 

3.1 The Invocation Command 

The linker is invoked by submitting the following command to the command 
language interpreter: 


al {<optioas>} <anit-xiaae> 


<unit-naB«> 

If a linking is requested, <unit jiame> must specify a main program 
which is a library unit of the current program library, but not neces¬ 
sarily of current sublibrary. The library unit must be a parameterless 
procedure. Wildcard characters are not permitted. 




3 COMMANDS OF THE ADA LINKER 


16 


If examination of the consequences of recompilations is requested, <unit_name> 
specifies a set of program library units whose consistency after the hy¬ 
pothetical recompilations will be checked. <unit_n«ime> may contain 
wildcard characters which will be interpreted according to the rules of 
the UNIX in the current sublibrary with names that match specified 
<unit_name>. All types of library unit may be designated. 

1. Options 

—1 <file_naa6> 

Causes the link er to produce a log file named <file_name>. The 
log file is written to the invoker’s current directory. The default 
is no log file. 

-L 

Causes the link er to produce a log file named ’’link.log”. The 
log file is written to the invoker’s current directory. The default 
is no log file. 

— a <lib_sp«c> 

Specifies the current sublibrary and thereby also the current pro¬ 
gram library. If this option is omitted then the sublibrary des¬ 
ignated by the environment variable, ADA-LIBRARY, is used. If 
the environmental variable is not denied, the file, ADA-LIBRARY, is 
used. 

— c 

causes the linker to check the the consistency of the program(s) 
specified by <iinit^affl«>. If this option is omitted then the 
specified program will be linked. 

— s <unit_set> and —b <unit_s«t> 

Define those library units after whose hypothetical recompilations 
the consistency wUl be checked. The meaning of <unit-set> is: 
<unitj«t> <unit_nam«> {, <unit_aane>} 

For those unit names that appear with the —s option, the specifi¬ 
cations of the corresponding library units are included in the list 
of hypothetical recompilations. 

For those unit names that appear with the -b option, the bod¬ 
ies of the corresponding library units are included in the list of 
hypothetical recompilations. 




3 COMMANDS OF THE ADA LINKER 


17 


A <unit_naa«> may appear in the <unit jet> of both options 
if required. 

—T <test.code> 

Causes the linker to send test output to the log file. The <test_code> 
is an integer in the range 0..9. This option is only allowed if the 
—1 or — L option is present. 

—o <filename> 

Include the file denoted by <lilenaae> in the link. Useful for 
including entities written in assembly language or C. 

-p "string" 

Options. The string will be inserted immediately edter the ”ld” 
command when the native linker is invoked. Useful for supplying 
options for the linker. 

— I <count> 

Period. The granularity of the timer measured in 1/100 second. 
Defaiilt is 1/10 second. 

■—S <cont> 

Time slice. The time between activations of the schedule measured 
in periods. Default is 10. 

-R 

No time slice. Do not activate the scheduler. 

—P <prio> 

Default priority. Specifies the default priority for tasks of a task 
type for which a pragma priority is not present. The default is 16. 

—D <stack> 

Default stack—size. Specifies the amount of stack allocated for 
task of a task type for which a length clause is not specified. 

2. Examples 

I al -a nylib syprog 

The linker will generate an executable image in the current directory 
from the program from the library mylib. 






3 COMMANDS OF THE ADA LINKER 


18 


$ al -L -c -3 example -b utility myprog 

This will examine the consequences of the recompilations of the ex¬ 
ample specification and the utility body. The linker will give a list of 
necessary compilations to keep myprog consistent. The program library 
is given by the environment variable ADA_LIBRARY. 

$ al -c -a a+b -b c prog_x 

Here the linker will examine the consistency of the program "prog-x” 
in case of a recompilations of the specifications of the library unit ”a” 
and all library units with names starting with ’’b”, and a recompilation 
of the bodies of the all library units with names starting ”c”. 

$ al -o ObjectFila.o rnyprogreua 

The linker will include the code in ObjectFile .o in the linkage of the 
program "myprogram”. Tlus program presumably featmes a program 
interface to some routines appearing in the ObjectFile. 



APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32_768..32_767; 

type INTEGER is range -2_147_483_648..2_147_483_647; 

type FLOAT is digits 6 

range -16#0.FFFF_FF#E32..16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256..16#0.FFFF_FFFF FFFF_F8#E256; 
type DURATION is delta 2#1.0#E-14 range -131_072.0.. 13“l_071.0 ; 

end STANDARD; 


C-1 






NEC Ada Compilation System 
for EWS-UX/V(Rel 4.0) Release 2.1(4.6) 

Appendix F 


September 1, 1991 
NEC Corporation 





CONTENTS 


1 


Contents 

1 Introduction 2 

2 Implementation-Dependent Pragmas 2 

3 Implementation-dependent Attributes 3 

3.1 Package SYSTEzM. 3 

3.2 Representation Clauses. 4 

3.2.1 Pragma PACK. 4 

3.2.2 Length Clauses. 4 

3.2.3 Enumeration Representation Clauses. 6 

3.2.4 Record Representation Clauses . 6 

3.3 Implementation-Dependent Names . 8 

3.4 Address Clauses. 8 

3.4.1 Objects. 8 

3.5 Unchecked Conversion. 8 

3.6 Input-Output Packages. 10 

3.6.1 External Files.10 

3.6.2 File Management. 11 

3.6.3 Buffering. 15 

3.6.4 Package 10 JIXCEPTIONS . 16 

3.6.5 Sequential Input-Output. 16 

3.6.6 Direct Input-Output. 18 

3.6.7 Specification of the Package Text JO.20 

3.6.8 Low Level Input-Output.23 

3.6.9 Package TERMINAL. 26 
























1 INTRODUCTION 


2 


1 Introduction 

This document describes the implementation-dependent characteristics of 
the NEC EWS-UX/V(Rel4.0) Ada Compiler Release R2.1(4.6) as required 
in the Appendix F frame of the Ada Reference Manual(ARM,ANSI/MIL- 
STD 1815A). 

2 Implementation-Dependent Pragmas 

There is one implementation-defined pragma: Interface-spelling. 

INTERFA CE^ FELLING 

This is the only implementation defined pragma. It allows the user 
to call interfaced subprograms that have names that ccinnot be given 
to Ada subprograms because of Ada’s lexical rules. Pragma inter¬ 
face-spelling supplies a mapping between the name of an Ada subpro¬ 
gram (that is mentioned in a pragma interface) and the name under 
which the subprogram is known in the surroundings. 

Example 


function Allocate (seize: integer) return byte.ptr; 

pragma interface (C, Allocate); 

— Supply the name of the C allocate function 
pragma interface.spelling (Allocate, "alloc"); 

If no pragma interface-spelling is given for an interfaced subprogram, 
the result will be as if a pragma interface-spelling had been given with 
a string containing the Ada spelling of the subprogram in lower case: 

pragma interface (C, Some.function); 

— Implicit pragma interface.spelling 

(Some.function, "Some.function"); 

pragma interface (AS. Some.function) 


3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


3 


Implicit pragma interface.spelli&g 

(Some.function, "SOME.FUNCTION"); 


3 Implementation-dependent Attributes 

No implementation-dependent attributes are defined. 

3.1 Package SYSTEM 

package SYSTEM is 

type ADDRESS is nem INTEGER; 

subtype PRIORITY is INTEGER range 1..32; 
type NAME is (EWS.DXV.R4); 

SYSTEM.NAME: constant NAME :* EWS.DXV.R4: 

STORAGE.UNIT: constant := 8; 

MEM0RY.SI2E: constant := 2048*1024; 

MIN.INT: constant := -2.147_483.648: 

MAX.INT: constant := 2.147.483.647; 

HAX.DIGITS: constemt := 15; 

MAX.MANTISSA: consteint 31; 

FINE.DELTA: constant := 2#1.0#E-31; 

TICK: constant := 1.0 

type interface.language is (C, AS); 

— Compiler system dependent types: 

subtype IHTEGER.16 is SHORT.INTEGER; 

subtype NATURAL.16 is INTEGER.IS range 0..INTEGER.16’LAST; 
subtype P0SITIVE.16 is IHTEGER.16 range 1..INTEGER.16'LAST; 
subtype INTEGER.32 is INTEGER; 

subtype HATTnUL.32 is IMTEGER.32 range 0..INTEGER.32’LAST; 
subtype P0SITIVE.32 is IHTEGER_32 range 1..INTEGER.32’LAST; 
end SYSTEM; 





3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


4 


3.2 Representation Clauses 

The representation clauses that are accepted are described below. Note that 
representation specification can be given on derived types too. 

3.2.1 Pragma PACK 

Pragma PACK applied on an array type will pack each array element into 
the smallest number of bits possible, assuming that the component type is a 
discrete type other than LONGJNTEGER or a fixed point type. Packing of 
arrays having other kinds of component types have no effect. 

When the smallest number of bits needed to hold any value of a type is 
calcxilated, the range of the types is extended to include zero. 

Pragma PACK applied on a record type will attempt to pack the compo¬ 
nents not already covered by a representation clause (perhaps none). This 
packing will begin with the small scalar components and larger components 
will follow in the order specified in the record. The packing begins at the 
first storage unit after the components with representation clauses. 

The component types in question are the ones defined above for array 
types. 


3.2.2 Length Clauses 

Four kinds of length caluses are accepted. 

1. Size specifications: 

The size attribute for a type T is accepted in the following cases: 

(a) If T is a discrete type, then the specified size must be greater than 
or equal to the number of bits needed to represent a value of the 
type, and less than or equal to 32. Note that when the number of 
bits needed to hold any value of the type is calculated, the range 
is extended to include 0 if necesssary, i.e. the range 3..4 cannot be 
represented in 1 bit, but needs 3 bits. 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


5 


(b) If T is a fixed point type, then the specified size must be greater 
than or equal to the smelliest number of bits needed to hold any 
value of the fixed point type, and less than 32 bits. Note that the 
Ada Reference Manual permits a representation where the lower 
bound and the upper bound is not representable in the type. Thus 
the type 

type FIX is delta 1.0 range -1.0 .. 7.0; 

is representable in 3 bits. As for discrete t'ypes, the number of bits 
needed for a fixed point type is calculated using the range of the 
fixed point type possibly extended to include 0.0. 

(c) If T is a floating point type, an access type, or task type the 
specified size must be equal to the number of bits used to represent 
values of the type (floating points: 32 or 64 bits, access types ; 32 
bits and task types: 32 bits). 

(d) If T is a record type, the specified size must be greater than or 
equal to the minimal number of bits used to represent values of 
the type per default. 

(e) If T is an array type, the size of the array must be static, i.e. 
known at compile time cind the specified size must be equal to the 
minimal number of bits used to represent values of the type per 
default. 

Furthermore, the size attribute hais effect only if the type is part of a 
composite type. 

type BYTE is range 0..255; 
for BYTE'size use 8; 

SIXTEEN : BYTE; — one 

EIGHT : array(l..4) of BYTE; — one 

2. Collection size specifications: 

Using the STORAGE-SIZE attribute on an access type will set an up¬ 
per limit on the total size of objects allocated in the collection edlocated 


vord allocated 
byte per element 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


6 


for the access type. If further allocation is attempted, the exception 
STORAGEJERROR is raised. The specified storage size must be less 
than or equal to INTEGER’LAST. 

3. Task storage size: 

When the STORAGE-SIZE attribute is given on a task type, the task 
stack area will be of the specified size. There is no upper limit on the 
given size. 

4. Small specifications: 

Any value of the SMALL attribute less than the specified delta for the 
fixed point type can be given. 

3.2.3 Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in the range 
of INTEGERTIRST+1..INTEGER’LAST-1. An enumeration representa¬ 
tion clause may be combined with a length clause. If an enumeration rep¬ 
resentation clause has been given for a type, the representational values are 
considered when the number of the bits needed to hold any value of the type 
is evaluated. Thus the type 

type ENUM is (A,B,C); 
for EMUM use (1,3,5); 

needs 3 bits not 2 bits to represent any value of the type ENUM. 

3.2.4 Record Representation Clauses 

When component clauses are applied to a record type the following restric¬ 
tions and interpretations are imposed: 

• All values of the component type must be representable within the 
specified number of bits in the component clause. 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


7 


• If the component type is either a discrete type, a fixed point type, an 
array type with a discrete type or a fixed point type as element type, 
then the component is packed into the specified number of bits (see 
however the restriction in the paragraph above), and the component 
may start at any bit boundary. 

• If the component type is not one of the types specified in the paragraph 
above, it must start at a storage unit boundary, a storage unit being 8 
bits, and the default size calculated by the compiler must be given as 
the bit width, i.e. the component must be specified as 

component at N range 0..8eN'l 

where N specifies the relative storage unit number (0,1,,.,.) from the 
beginning of the record, and M the required number of storage units 
( 1 , 2 ,...). 

e The maximum bit width for components of scalar types is 32. 

e A record occupies an integral number of storage units. 

• A record may take up a mciximum of 32Kbits. 

• If the component type is an array type with discrete type or a fixed 
point type as element type, the given bit width must be divisible by 
the length of the array, i.e. each array element will occupy the same 
number of bits. 

If the record type contains components which are not covered by a com¬ 
ponent clause, they are allocated consecutively after the component with 
the value. Allocation of a record component without a component clause is 
always aligned on a storage unit boundary. Holes created because of compo¬ 
nent clauses ate not otherwise utilized by the compiler. 

1. Alignment Clause 

Alignment clause for records are implemented with the following char¬ 
acteristics: 


3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


8 


• If the declaration of the record type is done at the outermost level 
in a library, any alignment is accepted. 

• If the record declaration is done at a given static level (higher 
than the outermost library level, i.e. the permanent), only word 
alignments are accepted. 

3.3 Implementation-Dependent Names 

None defined by the compiler. 

3.4 Address Clauses 

This section describes the implementation of address clause and what types 
of entities may have their address specified by the user. 

3.4.1 Objects 

Address clauses are supported for scalar and composite objects whose size 
can be determined at compile time. The address value must be static. The 
given address is the virtual address. 

3.5 Unchecked Conversion 

Unchecked conversion is only allowed for types where objects of the same 
"size”. The size of an object is interpreted as follows : 

• for arrays, it is the number of storage units occupied by the array 
elements. 

• for records, it is the size of the fixed part of the record, i.e. excluding 
any dynamic storage allocated outside the record. 

• for the other non-structured type, the object size is described at fol¬ 
lowing table. 




3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


class of type 

size (byte) 

Short Intg 

2 

Intg 

4 

Float 

4 

LongFloat 

8 

Fixed 

2 

LongFLxed 

4 

Enumeration 

(include boolean type and character type) 

4 

Task 

4 


For scalar types having a size specification, special rules apply. Conver¬ 
sion involving such a type is allowed if the given size matches either the 
specified size or the object size. 

Example 


type ACC is access INTEGER; 

function TO.INT is new UNCHECKED.C0NVERSI0N(ACC,INTEGER); 

— OK 


function TO.ACC is new 

DNCHECKED_CONVERSION(SHORT.INTEGER,ACC,I); 

— NOT OK 


type UNSIGNED is range 0..65535; 
for UNISGNED’SIZE use 16; 


function TO.INT is new UNCHECKED.CONVERSION(UNSIGNED,INTEGER); 

— OK 


function TO.SHORT is new 

UNCHECKED.CONVERSION(UNSIGNED,SHORT.INTEGER); 

— OK 


End of example 
























3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


10 


3.6 Input-Output Packages 

The implementation supports all requirements of the Ada language and the 
POSIX standard described in document P1003.5 Draft4.0/WG15-N45. It is 
an effective interface to the UNIX file system, and in the case of text JO it is 
also an effective interface to the UNIX standard input, standard output and 
standard error streams. 

This section describes the functional aspects of the interface to the UNIX 
file system, including the methods of using the interface to take advantage 
of the file facilities provided. 

The Ada input-output concept as defined in Chapter 14 of the ARM 
does not constitute a complete functional specification of the input-output 
packages. Some aspects of I/O system are not discussed at all, while others 
are intentionally left open for implementation. This section describes those 
sections not covered in the ARM. Please notice that the POSIX standard 
puts restrictions on some of the aspects not described in Chapter 14 of the 
ARM. 

The UNIX operating system considers all files to be sequences of char¬ 
acters. Files can either be accessed sequentially or randomly. Files are not 
structured into records, but an access routine can treat a file as a sequence 
of records if it arranges the record level input-output. 

Note that for sequential or text files (Ada files not UNIX external files) 
RESET on a file in mode OUT-FILE will empty the file. Also, a sequential 
or text file opened as an OUT_FILE will be emptied. 

3.6.1 External Files 

An external file is either a UNIX disk file, a UNIX FIFO (named pipe), a 
UNIX pipe, or any device defined in the UNIX directory. The use of devices 
such as a tape or communication line may require special access permissions 
or have restrictions. If an inappropriate operation is attempted on a device, 
then USE.ERROR exception is raised. 

External files created within the UNIX file system shall exist after the 
termination of the program that created it, and will be accessible from other 
Ada programs. However, pipes and temporary files will not exist after pro¬ 
gram termination. 

Creation of a file with the same name as an existing external file will 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


11 


cause the existing file to be overwritten. 

Creation of files with mode IN JILE will cause USE JIRROR to be raised. 
The name parameter to the input-output routines must be a valid UNIX 
file name. If the name parameter is empty, then a temporary file is created 
in the /usr/tap directory. Temporary files are automatically deleted when 
they are closed. 

3.6.2 File Management 

This section provides useful information for performing file management func¬ 
tions within an Ada program. 

1. Restrictioru on Sequential and Direct Input-Output 

The only restrictions are that placed on the element size, i.e. the num¬ 
ber of bytes occupied by the ELEMENT-TYPE: the maximum size 
allowed is 2147483647 bits; and if the size of the type is variable, the 
maximum size must be determinable at the point of instantiation from 
the value of the SIZE attribute for the element type. 

2. The NAME Parameter 

The NAME parameter must be a valid UNIX pathname (unless it is 
the empty string). If any directory in the pathname is inaccessible, 
USE-ERROR or NAME-ERROR is raised. 

The UNIX names "stdin", "stdout”, and "stderr”, can be used with 
TEXTJO.OPEN. No physical opening of the external file is performed 
and the Ada file will be associated with the adready open external file. 
These names have no significance for other I/O packages. 

Temporary files(NAME = null string) are created using tmpname(3) 
and will be deleted when CLOSED. Abnormal program termination 
may leave temporary files in existence. The name function will return 
the full name of temporary file when it exists. 

3. The Form Parameter 

The Form Parameter, as described below, is applicable to DIRECT JO, 
SEQUENTIALJO and TEXTJO operations. The value of the Form 
PaLTameter for Ada I/O shall be a character sting. The value of the 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


12 


character string shall be a series of fields separated by commas. Each 
field shall consist of optional separators, followed by a field name iden¬ 
tifier, followed by optional separators, followed by ” = >”, followed by 
optional separators, followed by a field value, followed by optional sep- 
.irators. The allowed values for the field names and the corresponding 
field values are described below. All field names and field values cire 
case-insensitive. 

The following BNF describes the syntax of the Form Pcirameter; 


form 

fields 


rights : 

access 

access.underscor 

append 

blocking : 

terminal.input 
fifo 

posix.file.descriptor 


[field {, field}*] 
rights I append I blocking I 
terminal.input | fifo I 
posix.file.descriptor 
OWNER I GROUP I WORLD => 

READ I WRITE I EXECUTE 1 NONE 
.READ 1 .WRITE I .EXECUTE I .NONE 
APPEND *> YES I NO 
BLOCKING *> TASKS I PROGRAM 
TERMINAL.INPUT => LINES I CHARACTERS 
FIFO => YES 1 NO 

POSIX.FILE.DESCRIPTOR => 2 


The FORM parameter is used to control the following : 

(a) File ownership; 

Access rights to a file <ire controlled by the following field names 
"OWNER”, "GROUP” and ”WORLD". The field values are 
"READ”, "WRITE”, "EXECUTE” and "NONE” or any com¬ 
bination of the previously listed values separated by underscores. 
The access rights held names are applicable to TEXT JO, DI- 
RECTJO and SEQUENTIALJO. The default value is OWNER 
=> READ-WRITE, GROUP => READ.WRITE and WORLD 
= > READ-WRITE. The actual access nghts on a created file will 
be the default value subtracted from the value of the environment 
variable umask. 





3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


13 


Example 

To make a file readable and writable by the owner only, the Form 
Parameter should look something like this: 

"0»n#r =>raad_writ«, Morld=> none, Group=>none" 

If one or more of the field names are missing the default value is 
used. The permission field is evaluated in left-to-right order. An 
ambiguity may arise with a Form Parameter of the following: 

"0«ner=>Raad.Execate_None.Write.Read" 

In this instance, using the left-to-right evaluation order, the ”None” 
field will essentially reset the permissions to none and this example 
would have the access rights WRITE cind READ. 

(b) Appending to a file: 

Appending to a file is achieved by using field name ’’APPEND” 
and one of the two field values ”YES” or ”NO”. The default 
vjdue is "NO”. "Append” is allowed with both TEXTJO and 
SEQUENTIALJO. The effect of appending to a file is that all 
output to that file is written to the end of the named external file. 
This field may only be used with the "OPEN” operation, using 
the field name "APPEND” in connection with a "CREATE” op¬ 
eration shall raise USEJERROR. Furthermore, a USE-ERROR is 
raised if the specified file is a terminal device or another device. 

Example 

To append to a file, one would write: 

"Append »> Yes" 

(c) Blocking vs. non-blocking I/O: 

The blocking field name is "BLOCKING” and the field values 
are "TASKS" and "PROGRAM”. The default value is "PRO¬ 
GRAM”. ”BLOCKING=>TASKS" causes the caUing task, but 
no others, to wait for the completion of an I/O operation. 
”BLOCKING=>PROGRAM" causes all tasks within the pro¬ 
gram to wait for the completion of the I/O operation. The block¬ 
ing mechanism is applicable to TEXTJO, DIRECTJO and SE- 




3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


14 


QUENTIAL JO. UNEC does not allow the support of ”BLOCKING=>TASKS" 
currently. 

(d) How characters are read from the keyboard: 

The field name is "TERMINALJNPUT” and field value is ei¬ 
ther "LINES" or "CHARACTERS". The effect of the field value 
"TERMINALJNPUT => CHARACTERS” is that characters are 
read in a noncanonical fashion with Minimum-count=l, meaning 
one character at a time=:0.0 corresponding so that the read opera¬ 
tion is not satisfied until Minim um-Count characters are received. 

If field value "LINES" is used, the chairacters are read one line at 
a time in canonical mode. The default value is Lines. "TERMI¬ 
NALJNPUT” has effect if the specified file is not already open or 
if the file is not open on a terminal. It is permitted for the same 
terminal device to be opened for input in both modes as separate 
Ada file objects. In this case, no user input characters shall be 
read from the input device without an explicit input operation on 
one of the file objects. The "TERMINALJNPUT” mechanism is 
only applicable to TEXT JO. 

(e) Creation of FIFO files: 

The field name is "FIFO” emd the field value is either "YES” 
or "NO”. "FIFO => YES” means that the file shall be a named 
FIFO file. The default value is "NO”. For use with TEXT JO, the 
"FIFO” field is only allowed with the CREATE operation. If used 
in connection with an open operation, USE-ERROR is raised. 

For SEQUENTIALJO, the FIFO mechanism is applicable for 
both the CREATE and OPEN operation. 

In connection with SEQUENTIALJO, an additional field name 
"O-NDELAY” is used. The field values allowed for "0-NDELAY” 
are "YES" and "NO". Default is "NO”. The "O-NDELAY” field 
name is provided to allow waiting or immediate return. If, for 
example, the following form parameter is given: 

’•FIF0*>ye8, 0_NDEUY»>Yes" 

then waiting is performed until completion of the operation. The 
"O-NDELAY” field name only has meaning in connection with 
the FIFO facility and otherwise is ignored. 





3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


15 


(f) Access to OPEN POSIX files: 

The field name is ”POSIX_FileJ)escriptor”. The field value is 
the character string ”2” which denotes the stderr file. Any other 
field value wiU result in USE_ERROR being raised. The NAME 
puameter provides the value which will be returned by subsequent 
usage of the NAME function. The operation does not change the 
state of the file. Dviring the period that the Ada file is open, the 
result of any file operations on the file descriptpr are undefined. 
Note that this is a method to make stderr accessible from an Ada 
program. 

4. File Access 

The following guidelines should be observed when performing file I/O 
operations: 

• At a given instant, any number of files in an Ada program can be 
associated with corresponding external files. 

• When sharing files between programs,.it is the responsibility of 
the programmer to determine the effects of sharing files. 

• The RESET and OPEN operations to files with mode OUT_FILE 
will empty the contents of the file in SEQUENTIAL JO and TEXT JO. 

• Files can be interchanged between SEQUENTIALJO and DI¬ 
RECT JO without any special operations if the files are of the 
same object type. 

3.6.3 Buffering 

The Ada 1/O system provides buffering in addition to the buffering provided 
by UNIX. The Ada TEXTJO packages will flush all output to the operating 
system under the following circumstances: 

1. The device is a terminal device and an end of line, end of page, or end 
of file has occurred. 

2. The device is a terminal device and the same Ada program makes an 
Ada TEXTJO input request or another file object representing the 
same device. 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


16 


3.6.4 Package IO_EXCEPTIONS 

The specification of package lO JIXCEPTIONS: 


Package ZO.EZCEPTIOirs is 


— The order of the following declarations must NOT be changed: 


STATUS.ERROR 

MODE.ERROR 

NAME.ERROR 

nSE.ERROR 

DEVICE.ERROR 

END.ERROR 

DATA.ERROR 

LAYODT.ERROR 


: exception; 
: exception; 
: exception; 
: exception; 
; exception; 
: exception; 
: exception; 
: exception; 


end lO.EXCEPTIONS; 


3.6.S Sequential Input-Output 

The implementation omits type checking for DATA^RROR, in case the 
element type is of am unconstrained type, ARM 14.2.2(4), i.e.: 


...f : FILE.TYPE 
type et is 1..100; 

type eat is arrayC et rangs <> ) of integer; 

X : eatC 1..2 }; 

Y ; eat( 1..4 ); 

— write X, Y: 

writeC f, X); write( f, Y); reset( f, IB.FILE); 

— read X into Y and Y into X: 
readC f, Y); readC f, X); 

This will give undefined values in the last 2 elements of Y, and not 

DATAJERROR. 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


17 


1. Specification of the Package SequentiaLIO 


with BASIC.IO.TYPES; 
with lO.EXCEPTIONS; 
generic 

type ELEMENT.TYPE is private; 
package SEQUENTIAL.IO is 

type FILE.TYPE is limited private; 
type FILE.MODE is (IN.FILE, ODT.FILE); 

— File management 

procedure CREATE(FILE : in out FILE.TYPE; 

MODE : in FILE.MODE := ODT.FILE; 

NAME : in STRING := 

FORM : in STRING := 

procedure OPEN (FILE : in out FILE.T'PE; 

NODE : in FILE.MODE; 

NAME ; in STRING; 

FORM : in STRING :* 

procedure CLOSE (FILE : in out FILE.TYPE); 

procedure DELETE(FILE : in out FILE.TYPE); 

procedure RESET (FILE : in out FILE.TYPE; 

NODE : in FILE.MODE); 

procedure RESET (FILE : in out FILE.TYPE); 

function NODE (FILE : in FILE.TYPE) return FILE.MODE; 

function NAME (FILE : in FILE.TYPE) return STRING; 

function FORM (FILE : in FILE.TYPE) return STRING; 

function IS_OPEN(FILE : in FILE.TYPE) return BOOLEAN; 

— input and output operations 

procedure READ (FILE : in FILE.TYPE; 

ITEM : out ELEMENT.TYPE); 

procedure WRITE (FILE : in FILE.TYPE; 

ITEM : in ELEMENT.TYPE); 

function END.OF.FILE(FILE ; in FILE.TYPE) return BOOLEAN; 


i 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


18 


— exceptions 
STATUS.ERRQR 
HODE.ERRQR 
NAME.ERROR 
USE.ERRQR 
DEVICE.ERROR 
END.ERROR 
DATA.ERROR 


exception 

exception 

exception 

exception 

exception 

exception 

exception 


renanes 

renames 

renames 

renames 

renames 

renames 

renames 


lO.EXCEPTIQNS.STATUS.ERRQR; 
IQ.EXCEPTIQNS.HODE.ERRQR; 
lO.EXCEPTIQNS.NAME.ERROR; 
lO.EXCEPTIQNS.USE.ERROR; 
lO.EXCEPTIQNS.DEVICE.ERROR; 
lO.EXCEPTIQNS.END.ERROR; 
lO.EXCEPTIQNS.DATA.ERROR; 


private 

type FILE.TYPE is new BASIC.IO.TYPES.FILE.TYPE; 
end SEQUENTIAL.IO; 


3.6.6 Direct Input>Output 

The implementation omits type checking for DATA-ERROR these case in 
which the element type is of an unconstrained type. 

1. Specification of the Package Direct JO 


with BASIC.IO.TYPES; 
with lO.EXCEPTIQNS; 
generic 

type ELEHENT.TYPE is private; 
package DIRECT.IO is 

type FILE.TYPE is limited private; 

type FILE.MODE is (IN.FILE, INOUT.FILE, ODT.FILE); 

type COUNT is range 0..INTEGER’LAST; 

subtype POSITIVE.COUNT is COUNT range 1..COUNT’LAST; 

— File management 

procedure CREATECFILE : in out FILE.TYPE; 

MODE : in FILE.MODE := INOUT.FILE; 



3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


19 


NAME ; in STRING := ; 

FORM ; in STRING := '‘"); 

procedure OPEN (FILE : in out FILE.TYPE; 

MODE : in FILE.MODE; 

NAME : in STRING; 

FORM ; in STRING := 

procedure CLOSE (FILE : in out FILE.TYPE); 

procedure DELETE(FILE : in out FILE.TYPE); 
procedure RESET (FILE : in out FILE.TYPE; 

MODE ; in FILE.MODE); 

procedure RESET (FILE : in out FILE.TYPE); 

function MODE (FILE : in FILE.TYPE) return FILE.MODE: 
function NAME (FILE : in FILE.TYPE) return STRING; 
function FORM (FILE ; in FILE.TYPE) return STRING; 
function IS.OPEN(FILE : in FILE.TYPE) return BOOLEAN; 

— input and output operations 

procedure READ (FILE ; in • FILE.TYPE; 

ITEM : out ELEMENT.TYPE; 

FROM : in POSITIVE.CODNT); 

procedure READ (FILE : in FILE.TYPE; 

ITEM : out ELEMENT.TYPE); 

procedure WRITE (FILE : in FILE.TYPE; 

ITEM : in ELEMENT.TYPE; 

TO : in POSITIVE.COUNT); 

procedure WRITE (FILE : in FILE.TYPE; 

ITEM : in ELEMENT.TYPE); 

procedure SET.INDEX(FILE : in FILE.TYPE; 

TO : in POSITIVE.COUNT); 

function INDEX(FILE : in FILE.TYPE) return POSITIVE.COUNT; 
function SIZE (FILE ; in FILE.TYPE) return COUNT; 
function END.OF.FILE(FILE : in FILE.TYPE) return BOOLEAN; 

— exceptions 

STATUS.ERROR : exception renames lO.EXCPTIONS.STATUS.ERROR 

MODE.ERROR : exception renames lO.EXCPTIONS.MODE.ERROR; 

NAME.ERRQR : exception renames lO.EXCPTIONS.NAME.ERROR; 





3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


20 


USE.ERROR 

DEVICE.ERROR 

END.ERROR 

OATA.ERROR 


exception reneunes 10_EXOPTIONS.USE.ERROR; 
exception renames lO.EXCPTIONS.DEVICE.ERROR; 
exception renames lO.EXCPTIONS.END.ERROR; 
exception renames lO.EXCPTIONS.DATA.ERROR; 


private 

type FILE.TYPE is new BASIC.IO.TYPES.FILE.TYPE; 
end DIRECT.IO; 


3.6.7 Specification of the Package Text JO 


with BASIC.IO.TYPES; 
with lO.EXCEPTIONS; 


package TEXT.IO is 

type FILE.TYPE is limited private; 
type FILE.MODE is (IN.FILE, OUT.FILE); 
type COUNT is range 0 .. INTEGER'LAST; 
subtype POSITIVE.COUNT is COUNT range 1 .. COUNT’LAST; 
UNBOUNDED: constant COUNT0; line and page length 
— max. size of am integer output field 2#....# 
subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER.BASE is INTEGER range 2 .. 16; 


type TYPE.SET is (LOWER.CASE, UPPER.CASE); 


File Hamagement 

procedure CREATE (FILE 
NODE 
NAME 
FORM 

procedure OPEN (FILE 
NODE 
NAME 
FORM 

procedure CLOSE (FILE 
procedure DELETE (FILE 


in 

out 

FILE.TYPE; 


in 


FILE.MODE := 

OUT.FILE; 

in 


STRING := 

M M . 

» 

in 


STRING : = 

■”'): 

in 

out 

FILE.TYPE; 


in 


FILE.MODE; 


in 


STRING; 


in 


STRING := 

"■•): 

in 

out 

FILE.TYPE); 


in 

out 

FILE.TYPE); 






3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 21 

procedure RESET (FILE : in out FILE.TYPE; 

MODE : in FILE.MODE); 
procedure RESET (FILE : in out FILE.TYPE); 

function MODE (FILE : in FILE.TYPE) return FILE.MODE; 

function NAME (FILE : in FILE.TYPE) return STRING; 

function FORM (FILE : in FILE.TYPE) return STRING; 

function IS.OPEN(FILE : in FILE.TYPE) return BOOLEAN; 

— Control of default input and output files 
procedure SET.INPUT (FILE : in FILE.TYPE); 

procedure SET.ODTPDT (FILE : in FILE.TYPE); 

function STANDARD.INPUT return FILE.TYPE; 

function STANDARD.OUTPUT return FILE.TYPE; 

function CURRENT.INPDT return FILE.TYPE; 

function CURRENT.OUTPUT return FILE.TYPE; 

— specification of line and page lengths 
procedure SET.LINE.LENGTH (FILE ; in FILE.TYPE; 

TO : in COUNT); 

procedure SET.LINE.LENGTH (TO : in COUNT); 

procedure SET.PAGE.LENGTH (FILE : in FILE.TYPE; 

TO : in COUNT); 

procedure SET.PAGE.LENGTH (TO : in COUNT); 

function LINE.LENGTH (FILE : in FILE.TYPE) return COUNT 

function LINE.LENGTH return COUNT 

function PAGE.LENGTH (FILE : in FILE.TYPE) return COUNT 

function PAGE.LENGTH return COUNT 

— Column, Line, and Page Control 

procedure NEW.LINE (FILE : in FILE.TYPE; 

SPACING ; in POSITIVE.COUNT := 1); 
procedure NEW.LINE (SPACING : in POSITIVE.COUNT := 1); 

procedure SKIP.LINE (FILE : in FILE.TYPE; 

SPACING : in POSITIVE.COUNT := 1); 
procedure SKIP.LINE (SPACING : in POSITIVE.COUNT := 1); 
function END.OF.LINE (FILE : in FILE.TYPE) return BOOLEAN; 
function END.OF.LINE return BOOLEAN; 






3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


22 


procedure NEW.PAGE (FILE : in FILE.TYPE): 
procedure NEW.PAGE ; 

procedure SKIP.PAGE (FILE : in FILE.TYPE); 

procedure SKIP.PAGE ; 

function EHD.OF.PAGE (FILE : in FILE.TYPE) return BOOLEAN; 

function END.OF.PAGE return BOOLEAN; 

function END.OF.FILE (FILE : in FILE.TYPE) return BOOLEAN; 

function END.OF.FILE return BOOLEAN; 

procedure SET.COL (FILE : in FILE.TYPE; 

TO : in POSITIVE.COUNT); 

procedure SET.COL (TO : in POSITIVE.COUNT); 

procedure SET.LINE (FILE : in FILE.TYPE; 

TO : in POSITIVE.COUNT); 

procedure SET.LINE (TO : in POSITIVE.COUNT); 


function 

COL 

(FILE : 

in FILE.TYPE) 

return POSITIVE.COUNT; 

function 

COL 


return POSITIVE.COUNT; 

function 

LINE 

(FILE : 

in FILE.TYPE) 

return POSITIVE.COUNT; 

function 

LINE 


return POSITIVE.COUNT; 

function 

PAGE 

(FILE : 

in FILE.TYPE) 

return POSITIVE.COUNT; 

function 

PAGE 


return POSITIVE.COUNT; 


— Character Input-Output 

procedure GET (FILE : in FILE.TYPE; 

ITEM : out CHARACTER); 

procedure GET (ITEM : out CHARACTER); 

procedure PUT (FILE : in FILE.TYPE; 

ITEM : in CHARACTER); 

procedure PUT (ITEM : in CHARACTER); 

— String Input-Output 

procedure GET (FILE : in FILE.TYPE; 

ITEM : out STRING); 

procedure GET (ITEM : out STRING); 

procedure PUT (FILE : in FILE.TYPE; 








3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


23 


procedure 

procedure 

procedure 

procedure 

procedure 


ITEM : ia STRING); 
PUT (ITEM : in STRING); 


GET.LINE 

(FILE : 

in 



ITEM : 


out 


LAST : 


out 

GET.LINE 

(ITEM : 


out 


LAST : 


out 

PUT.LINE 

(FILE ; 

in 



ITEM : 

in 


PDT.LINE 

(ITEM : 

in 



FILE.TYPE; 
STRING; 
NATURAL); 
STRING; 
NATURAL); 
FILE.TYPE: 
STRING): 
STRING); 


— Generic Package for Input-Output of Integer Types 
generic 

type NUM is range <>; 
package INTEGER.IO is 

DEFAULT.WIDTH : FIELD := NUM'WIDTH; 

DEFAULT.BASE : NUMBER.BASE := 10; 


procedure GET 

(FILE 


in 

FILE.TYPE: 


ITEM 



out MUM; 


WIDTH 


in 

FIELD := 0); 

procedure GET 

(ITEM 



out NUM; 


WIDTH 


in 

FIELD := 0); 

procedure PUT 

(FILE 


in 

FILE.TYPE; 


ITEM 


in 

HUM; 


WIDTH 


in 

FIELD ;= DEFAULT.WIDTH; 


BASE 


in 

NUMBER.BASE ;= DEFAULT.BASE); 

procedure PUT 

(ITEM 


in 

MUM; 


WIDTH 


in 

FIELD := DEFAULT.WIDTH: 


BASE 


in 

NUMBER.BASE := DEFAULT.BASE); 

procedure GET 

(FROM 


in 

STRING; 


ITEM 



out NUM; 


LAST 



out POSITIVE); 

procedure PUT 

(TO 



out STRING; 


ITEM 


in 

NUM; 


BASE 


in 

NUMBER.BASE DEFAULT.BASE); 


end INTEGER.IO; 




3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


24 


— Generic Packages for Input-Output ol Real Types 
generic 

type MUM is digits <>; 
package FLOAT.IO is 


DEFAULT.FORE : 

FIELD := 

2; 

DEFAULT.AFT : 

FIELD := 

NUM’digits - 1: 

DEFAULT.EXP : 

FIELD := 

3: 

procedure GET 

(FILE : 
ITEM : 
WIDTH : 

in FILE.TYPE; 

out MUM; 

in FIELD := 0); 

procedure GET 

(ITEM : 
WIDTH : 

out MUM; 

in FIELD := 0): 

procedure PUT 

(FILE : 
ITEM : 
FORE : 
AFT : 
EXP : 

in FILE.TYPE; 
in MUM; 

in FIELD := DEFAULT.FORE; 
in FIELD := DEFAULT.AFT; 
in FIELD := DEFAULT.EXP): 

procedure PUT 

(ITEM : 
FORE : 
AFT : 
EXP : 

in MUM; 

in FIELD DEFAULT.FORE: 

in FIELD := DEFAULT.AFT; 
in FIELD := DEFAULT.EXP): 

procedure GET 

(FROM : 
ITEM : 

LAST : 

in STRIMG; 

out MUM; 
out POSITIVE); 

procedure PUT 

(TO : 

ITEM : 
AFT : 
EXP : 

out STRIMG; 
in MUM; 

in FIELD := DEFAULT.AFT; 

in FIELD := DEFAULT.EXP); 


end FLOAT.IO; 


generic 

type MUM is delta <>; 
package FIXED.10 is 

DEFAOLT.FORE : FIELD := NUM’FORE; 

DEFAULT.AFT : FIELD ;= SUM’AFT; 

DEFAULT.EXP : FIELD ;= 0; 

procedure GET (FILE : in FILE.TYPE; 









3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


25 


ITEM : out MUM; 

WIDTH : ia FIELD := 0); 


proc«dura GET (ITEM out MUM; 

WIDTH : ia FIELD := 0); 
procedur* PUT (FILE : ia FILE.TYPE; 




ITEM : 

in 

NUM; 




FORE : 

in 

FIELD 

= DEFAULT.FORE; 



AFT : 

in 

FIELD 

= DEFAULT.AFT; 



EIP : 

in 

FIELD 

= DEFAULT.EXP); 

procedure 

PUT 

(ITEM : 

in 

MUM; 




FORE : 

in 

FIELD 

= DEFAULT.FORE; 



AFT : 

in 

FIELD 

= DEFAULT.AFT; 



EXP : 

in 

FIELD 

= DEFAULT.EXP); 

procedure 

GET 

(FROM : 

in 

STRIMG; 



ITEM : 


out MUM; 



LAST : 


out POSITIVE); 

procedure 

PUT 

(TO ; 


out STRIMG; 


ITEM 

: in 

NUM; 


AFT 

: in 

FIELD 

;= DEFAULT.AFT;. 

EXP 

: ia 

FIELD 

:= DEFAULT.EXP); 


•ad FIIED.IO; 

— Gaaerjc Package for Input-Output of Enuaeration Types 
generic 

type ENUM is (<>); 
package ENUMERATION.IO is 

DEFAULT.WIDTH : FIELD := 0; 

DEFAOLT.SETTING : TYPE.S2T UPPER.CASE; 

procedure GET (FILE : ia FILE.TYPE; 

ITEM : out ENUM); 

procedure GET (ITEM : out ENUM); 

procedure PUT (FILE : ia FILE.TYPE; 

ITEM : ia ENUM; 

WIDTH : ia FIELD :* DEFAULT.WIDTH; 

SET : ia TYPE.SET := DEFAULT.SETTING); 

procedure PUT (ITEM : in ENUM; 

WIDTH : ia FIELD 


;= DEFAULT.WIDTH; 









3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 


26 



SET : in TYPE.SET := 

DEFAULT.SETTING); 

procedure GET 

(FRON : in 

STRING; 



ITEN : 

out ENUN; 



LAST : 

out POSITIVE); 


procedure PUT 

(TO : 

out STRING; 



ITEM : in 

ENUN; 



SET : in 

TYPE.SET : 

= DEFAULT.SETTING); 

end ENUNERATION.IO; 




— Exceptions 

STATUS.ERROR 

NODE.ERROR 

NANE.ERROR 

USE.ERROR 

DEVICE.ERROR 

END.ERROR 

OATA.ERROR 

LAYOUT.ERROR 


exception 

exception 

exception 

exception 

exception 

exception 

exception 

exception 


renanes lO.EXCEPTIOMS.STATUS.ERROR; 
renames IQ.EXCEPTIONS.NODE.ERROR; 
renames lO.EXCEPTIONS.NANE.ERROR; 
renames lO.EXCEPTIOHS.USE.ERROR; 
renames lO.EXCEPTIONS.DEVICE.ERROR; 
renames lO.EXCEPTIONS.END.ERROR; 
renames lO.EXCEPTIONS.DATA.ERROR; 
renames lO.EXCEPTIONS.LAYOUT.ERROR; 


priTate 

tjpe FILE.BLOCK.TYPE is new BASIC.IO_TYPES.FILE.TYPE; 
type FILE.OBJECT.TYPE is record 


IS.OPEN : BOOLEAN FALSE; 

FILE.BLOCK : FILE.BLOCK.TYPE; 
end record; 


type FILE.TYPE is access FILE.OBJECT.TYPE; 
end TEXT.10; 


3.6.8 Low Level Input-Output 
The package LOWJ^EVELJO is empty. 

3.6.9 Package TERMINAL 

The specification of package TERMINAL: 


with COHHOI.DEFS; 





3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 

as* COMMON.DEFS: 

Package TERNIHAL is 

procedure SET_CnRS0R(R0U.C0L : in INTEGER); 

procedure IH.CHARACTER(CH out CHARACTER): 

procedure IN.INTEGER (I out INTEGER); 

procedure IN-LINE (T out TERMINAL.LINE); 

procedure OUT.CHARACTER(CH ; in CHARACTER); 

procedure OOT.INTEGER (I : in INTEGER): 

procedure OUT.INTEGER.Fd, V : in INTEGER); 

procedure OTTT.LINE (L : in STRING); 

procedure OUT.STRING (S : in STRING); 

procedure OTIT.NL: 
procedure OOT.FF; 
procedure FLUSH; 

procedure OPEH.LOG,FILE(FILE.NAME : in STRING); 
procedure CLQSE.LOG.FILE; 
end TERMINAL: 





