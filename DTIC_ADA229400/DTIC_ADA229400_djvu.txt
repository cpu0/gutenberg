TASK: UR20 
CDRL 00980 


UR20 — Process/Environmen^ 

Integration . __ & 

„„ m c rnPY Ada Command Environment 

NIC at w (ACE) User ’ s Manua | 


UNISYS 


Informal Technical Data 




o 

cn 

CM 

CM 

< 

I 

D 

< 


'-7cM 


Ssfficsess SssESasSs ^ 1 a-p A'&j-MSia a 


1 £$3©&3333 


STARS-RC-00980/001 /00 

29 October 1990 

DTIC 

ELECTE“ 

NOV 141990 



D 




IX 13 130 


Mt r>*s»* 









REPORT DOCUMENTATION PAGE 


Form Approved 
OMB No 0704-0188 


P-oiK »eoe p "*'C Duraer, tor :CHtoon cl ntcmairor >% estimated tc 4**r» oe ■ *our oer 'e^oo^se. ‘nciuai*? tfe time tor reviewing irwruaicnv se»rc**i»e e«»t'* , s oat* sources 
gttfw *3 *no maintaining tne data needed. *nc como<eiing ano rev»e>**nc theccliect'on of information Seno commfmt regarding tn»* burden estimate or an, rtner avoen o» tn.> 
co'iectior z* ^ormanc*. mcuamg suggestions for reducing tftis Durden to Washington Neaoouarterv Services. directorate «or information Operation* ano fteooni. *2fS ie*fer>on 
On* Suite 12C4 Arlington va 22202-4302. ana tc the o*f<ce of Management and Budge*. p aoer*.cr* Reduction Projen (0704-OiM). Washington. DC 20503 


1. AGENCY USE ONIY (Leave Plank) 


4. TITLE AND SUBTITLE 


2. REPORT DATE 

29 October 1990 


3. REPORT TYPE AND OATES COVERED 

Final. 


5. FUNDING NUMBERS 


User Manual for Ada Command Environment (ACE) 


6. AUTHOR(S) 

WiLLiam P. Loftus 
John A. Thalhammer 


7. PERFORMING ORGANIZATION NAME(S) AND AODRESS(ES) 


Unisys Corporation 
12010 Sunrise Valley Drive 
Reston, VA 22091 


STARS Contract 
F19628-88-D-0031 


8 PERFORMING ORGANIZATION 
REPORT NUMBER 

GR-7670-1 141 (NP) 


9. SPONSORING/ MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Department of the Air Force 

Headquarters, Electronic Systems Division (AFSC) 
Hanscom AFB, MA 01731-5000 


10. SPONSORING MONITORING 
AGENCY REPORT NUMBER 


00980 



12a. DISTRIBUTION/AVAILABILITY STATEMENT 


12b. DISTRIBUTION CODE 


Approved for public release; 
distribution is unlimited 


13. ABSTRACT (Maximum 200 words) 


This technical report provides users of the Ada Command Environment 
(ACE) with a description of each of the packages and subprograms 
that are provided with ACE. In addition, the report describes the 
overall purpose of ACE, general guidelines on ACE usage, and provides 
examples of typical user interaction during an ACE session. 


14 SUBJECT TERMS 

Ada Command Environment (ACE) 
Abstract Data Types (ADT) 

X Window System - 



IS. NUMBER OF PAGES 

142 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 






















TASK: UR20 
CDRL: 00980 
29 October 1990 


USER MANUAL 
For The 

SOFTWARE TECHNOLOGY FOR ADAPTABLE, RELIABLE SYSTEMS 

(STARS) 


Ada Command Environment (ACE) 
Version 8.0 

SunOS Implementation 


STA RS- RC-00980/001/00 
Publication No. GR-7670-1141 (NP) 
29 October 1990 


Data Type: A005, Informal Technical Data 

CONTRACT NO. F19628-88-D-0031 
Delivery Order 0002 


Prepared for: 

Electronic Systems Division 
Air Force Systems Command, USAF 
Hanscom AFB, MA 01731-5000 


Prepared by: 

Unisys Defense Systems 
Tactical Systems Division 
12010 Sunrise Valley Drive 
Reston, VA 22091 


( Distribution limited tp 

U.S. Government and'U.Sl Gofveriirtfjnt 
Contractors on^y; i i 
Adtninist^ative , (29'Octiofee^/L9$Jji)^/ 


\ 


v 




TASK: UR20 
CDRL: 00980 
29 October 1990 


USER MANUAL 
For The 

SOFTWARE TECHNOLOGY FOR ADAPTABLE, RELIABLE SYSTEMS 

(STARS) 


Ada Command Environment (ACE) 
Version 8.0 

SunOS Implementation 


STARS-RC-00980/001/00 
Publication No. GR-7670-1141(NP) 
29 October 1990 


Data Type: A005, Informal Technical Data 

CONTRACT NO. F19628-88-D-0031 
Delivery Order 0002 


Prepared for: 

Electronic Systems Division 
Air Force Systems Command, USAF 
Hanscom AFB, MA 01731-5000 


Prepared by: 

Unisys Defense Systems 
Tactical Systems Division 
12010 Sunrise Valley Drive 
Reston, VA 22091 




29 October 1990 


STARS-RC-00980/001/00 


PREFACE 


This document was prepared by Unisys Defense Systems, Valley Forge Laboratories, in sup¬ 
port of the Unisys STARS Prime contract under the Process/Environment Integration task 
(UR20). This CDRL, 00980, is type A005 (Informal Technical Data) and is entitled "Ada 
Command Environment (ACE) User’s Manual, Version 8.0". 


Reviewed by: 


Approved by: 


—- u, _ 

/ Teri F. Payton, System Architect ~ 

/ 

/ 

uj • { -_ /fl/jo/'fo 

Hans W. Polzer, Program Manager 




29 October 1990 


STARS-RC-00980/001/00 


Contents 

1 Introduction 1 

1.1 Intended Audience. 1 

1.2 Reference Documents. 1 

2 The Command Language of ACE 1 

2.1 The Environment of ACE. 2 

2.2 Interaction with ACE. 3 

3 Starting ACE 3 

3.1 Example. 4 

4 Software and Hardware Environment 4 

4.1 Sun Workstation . 5 

5 Pragmas Supported by ACE 5 

6 Environment of ACE 7 

6.1 ACE Libraries and Environment Tailoring. 9 

6.2 ADT Philosophy . 12 

6.2.1 The Ada Language Standard. 13 

6.2.2 Command Structure. 14 

6.2.3 Command Applicability. 15 

6.2.4 Command Specialization. 16 

6.2.5 Command Extensibility . 16 

6.3 ADT Interfaces within ACE. 16 

6.4 ADT Body Implementations. 17 

6.5 External Images. 17 

6.6 ADT Summary. 18 

6.7 ACE Command List .. 20 

7 Abstract Data Types of ACE 23 

7.1 Standard Packages. 23 

7.1.1 Objects . 24 

7.1.2 Standard. 24 

7.1.3 System. 29 

7.1.4 IoJExceptions. 29 

7.1.5 Low_Level_Io . 30 

7.1.6 Calendar. 30 

7.1.7 TextJo. 31 

7.1.8 Ace_Standard. 35 

7.1.9 Strings. 36 

7.2 Command Language Commands. 36 

7.2.1 Ace_Adt. 37 

7.2.2 Host.Os. 38 


Page ii 



































29 October 1990 


STARS-RC- 00980/001 /00 


7.2.3 Manipulate_Scope. 38 

7.2.4 Debugger . 39 

7.2.5 File_System. 41 

7.2.6 Directory .Objects. 42 

7.2.7 Text.Objects . 44 

7.2.8 Program.Objects. 45 

7.2.9 Program.Text.Objects. 46 

7.2.10 Binary .Objects. 47 

7.2.11 Program.Units . 47 

7.2.12 Help_Adt . 50 

7.2.13 Object .Lister. 50 

7.3 Key Bindings. 51 

7.3.1 Key-Bindings. 51 

7.4 Windowing Commands. 56 

7.4.1 Window-Objects . 56 

7.4.2 Ace_X_Window_System. 56 

7.4.3 Ace_User_X_Window_System. 57 

7.4.4 Window _Draw_Routines. 58 

7.5 CAIS-A Commands . 59 

7.5.1 CAIS .Routines. 59 

7.5.2 STARS.Tools. 61 

7.6 CPU Timing Package. 63 

7.6.1 Cpu.Time. 63 

7.7 Xt Toolkit Interface. 63 

7.7.1 X.Windows. 64 

7.7.2 Renamed_Xlib_Types. 65 

7.7.3 Intrinsics. 66 

7.7.4 Widget_Package. 67 

7.7.5 Hp.Widgets. 84 

8 More Information About Some Ace Features 109 

8.1 Xt Toolkit Interface. 109 

8.1.1 Xt Prototyping Sessions. 110 

8.1.1.1 Starting an Xt Prototyping Session.110 

8.1.1.2 Finishing an Xt Prototyping Session. Ill 

8.1.2 Xt Argument Lists. 112 

8.1.3 Xt Callbacks . 113 

8.1.3.1 Callback Procedures. 113 

8.1.3.2 Action Procedures. 114 

8.1.3.3 Callback Interpretation.115 

8.1.3.4 Prototyping Callbacks. 115 

8.1.4 Transition to Compiled Code . 116 

8.1.5 A Small Example. 117 

8.2 The Key.Bind.ings Package. 119 

8.2.1 Making Bindings. 119 


Page iii 
















































29 October 1990 


STARS-RC-00980/001/00 


8.2.1.1 Using Interpret JSt ring . 121 

8.2.1.2 Intermixing I/O with I\ey-Bindin<js Routines. 121 

8.2.2 An Example for InterpretString . 122 

9 Supported Ada Features 123 

10 Examples 130 

10.1 Interactive Ada Example. 130 

10.2 Manipulating Ada Components. 131 

10.3 Interfacing with Host O/S (UNIX) . 134 


Page iv 













STARS-RC-00980/001/00 


|29 October 1990 
!l Introduction 


J L'lie Ada Command Environment (ACE) is an interactive command language environment 
for Ada software development. Ada is both the programming language and the command 
language used within ACE. The paradigm and philosophy used by the Ada programmer 
during program development are extended into the environment in which program devel¬ 
opment takes place. ACE is modeled after other interactive programming environments, 
such as Smalltalk and Interlisp, which are touted for individual programmer productivity. 
Whereas other interactive programming environments are targeted toward programminy-in- 
the-small , ACE supports programming-in-the-large techniques that are key elements of the 
Ada language. 



1.1 Intended Audience 


This document assumes the user has a basic understanding of the Ada language, including 
its concepts and the use of Ada for software design and development. This document is not 
tutorial in nature with regards to the Ada language. The user is directed to one of the many 
texts on Ada or thej\da Language Reference Manual for background on Ada. / y 

■ O 


77 - 




.i. y 


a 


1.2 Reference Documents 


L c 




4 - 




/• 


,7 l 


MIL-STD-1815A Ada Programming Language , 22 Jan 1983 

William P. Loftus, Charles L. Oei, and John A. Thalhamer. The Ada Command Environment— 
ACE. In Proceedings of Ada Expo ’88, Anaheim, California, October 1988. 

John A. Thalhamer, William P. Loftus, Charles L. Oei, Ralph A. Foy. Ada Abstract Data 
Types —the Foundation of an Interactive Ada Command Environment. Proceedings of the 
Seventh Annual National Conference on Ada Technology , Atlantic City. New Jersey. March 
1989 

Unisys, Ada Command Environment Installation Guide , Version 8.0, Informal Report, U.S. 
Department of Defense Contract No. F19628-88-D-0031, 12 April 1990 


2 The Command Language of ACE 

The command language accepted by ACE is Ada. Within ACE, Ada is used as the language 
for program development as well as the mechanism for traditional interaction with the host 
operating system. Each command entered into ACE must be a legal Ada construct. 

Ada as a command language allows interactive program development, typical user inter¬ 
action with the host environment, and the development of command language procedures. 
Whereas within other environments different language constructs are needed for the com- 


Page 1 



29 October 1990 


STARS-RC-00980/001/00 


mand language and command language procedures (not to mention the different program¬ 
ming language'. ACE allows Ada to be used as the unifying language. 

ACE immediately executes Ada constructs as they are presented. The set of Ada constructs 
that are immediately executed are compilation units, statements, and basic declarations. 
Upon the completion of one of the constructs, the statements associated with the construct 
are executed and the appropriate results are given based upon the Ada statements that were 
evaluated. 

Immediate execution of the Ada constructs for compilation units, statements, and basic 
declarations allows Ada to be effectively used as a command language. An interactive devel¬ 
opment environment requires a dynamic atmosphere in which the next operation performed 
may be based upon a previous result. The ability to intermingle declarations, statements, 
and compilation units as commands to ACE is the basis for a dynamic environment. For 
example, a typical order of Ada commands to ACE may be the declaration of an object, 
assignment of an initial value to that object, the definition of a subprogram specification and 
body, followed by an invocation of the subprogram using the declared object. This sample 
shows the ability to intermix the sequence of declarations, statements, and compilation units 
that are submitted to ACE. 


2.1 The Environment of ACE 

ACE provides a basic set of Ada objects and operations as the initial environment of ACE. 
These objects and operations are encapsulated as abstract data types (ADTs) and imple¬ 
mented as a set of Ada packages. Upon initialization of ACE, the basic set of ADTs are 
assimilated into a base environment for the user. This base environment includes pack¬ 
ages that are necessary for the interpretation of Ada statements (such as the Ada package 
Standard ), as well as packages that provide operations typically performed by a user when 
interacting with the underlying operating system. 

Each subprogram or package that is entered by the user during an ACE session may be 
viewed as an extension of the environment. The subprogram and/or package provides a set 
of objects and operations which is available to the user. These subprograms and packages 
may be permanently stored so that they will be persistent between ACE sessions. Upon 
start-up of the user’s subsequent ACE session, these user-defined ADTs may be included 
into the ACE environment, thus tailoring the ACE environment to the user’s preferences. 

Common, every day operations that would typically be invoked by the majority of ACE 
users are made directly visible to the user as a default. The user may simply acquire direct 
visibility of other ADTs through the Ada use statement. In the event that direct visibility 
is not desired when given as a default, ACE provides a set of ADTs that may “undo” the 
Ada use statement. More detail on the operation of this type of ADT is provided in the 
description of the dynamic environment ADTs. 

The description of the ADTs that are provided as the base environment for ACE are described 


Page 2 




29 October 1990 


STA RS-RC-00980/001/00 


later in this manual (see section 7). 


2.2 Interaction with ACE 

The user is provided with a mechanism for controlling the operating characteristics of the 
Ada Command Environment. Within Ada, the pragma construct is the means for issuing 
directives to the compiler which do not affect the legality of the Ada program. Since ACE 
is based upon the paradigms of Ada, the Ada pragma construct is utilized within ACE to 
control the operation of ACE. 

In addition to the pragma directives of ACE, Ada objects and operations (in the form of 
an ADT) are employed to provide user control over ACE’s input and output mechanisms. 
The Ada Text-Io package contains the definition of a set of operations to control the default 
input and output files associated with the Ada program. A similar facility is provided 
within ACE to control the default input and output files associated with ACE. For example, 
Standard-Ace-Input and Standard~Ace.Ou.tput are defined to return a file type associated 
with the keyboard and CRT, respectively. Additional operations such as Set-Ace-Input and 
Current-AceJnput are used to modify and acquire the current file type which defines the file 
from which ACE is to acquire input. Similarly named operations exist for output. 

A description of the pragmas supported by ACE and the ADTs associated with the operation 
of ACE are given later in this manual (see section 5). 


The Exit Statement 

The exit statement is used to terminate the execution of subprograms within ACE or ACE 
itself. 


• exit Ace terminates the execution of ACE and returns the user to the host operating 
system. 

• exit Ace-Level terminates the current level of execution and returns the user to the 
next higher level. 

• exit Ace-Main terminates execution of all subprograms and returns the user to the top 
level of ACE. 


3 Starting ACE 

ACE can be started by typing the command '‘ACE” at the Unix prompt. This initiates the 
ACE session. During start up, ACE processes the definitions of the default abstract data 
types that will be available during the ACE session. A noticeable delay occurs during the 


Page 3 






29 October 1990 


STARS-RC 00980/0C1/00 


initiation ot' ACE white this set. of abstract data types is processed. ACE is ready to accept 
user commands after the display of tin' ACE main prompt — "ACE> ". 

When ACE has begun accepting a command and requires more information to complete the 
command, ACE will display a continuation prompt u I”. This prompt indica f es that the 
Ada construct being entered as a command is not yet complete. Examples of these Ada 
constructs include a compound statement, such as an if statement, a subprogram body, or 
even an assignment statement or declaration statement that is entered on multiple lines. 
The continuation prompt indicates that ACE is awaiting further input associated with the 
incomplete command, and will execute the command upon completion of the command. 


3.1 Example 
ACE> 

ACE> i : integer; 

ACE> i := 100; 

ACE> 

ACE> if i < 0 then 

1 put_line ("negative value"); 

I elsif i > 0 then 
I put_line ("positive value"); 

I else 

I put ..line ("zero value”) ; 

1 end if; 
positive value 
ACE> 


4 Software and Hardware Environment 

The ACE prototype is operational on a Sun-3 workstation. The description of each of these 
environments is detailed below. 

Execution of ACE should be performed within the same directory in which the executable 
image of ACE resides. The files that should be located within this directory are as follows: 


• ACE —the ACE executable image 

• startup.ace —the environment initialization file processed by ACE when ACE is started 

• ace-ada — script that interfaces with the host Ada compilation system (Verdix on the 
Sun workstation). This may be tailored to local preferences. 

• ace-edit —script that interfaces with the host editor (vi on the Sun workstation). This 
may be tailored to local preferences. 


Page 4 




29 October 1 990 


STARS-RC-00980/001/00 


• observe.windou'.icn —iconic image for the windows created by pragma observe, which 
is onlv needed when running within a window environment and when a window is 
closeu to its iconic torm. 


4.1 Sun Workstation 

Within the Sun workstation environment, ACE provides a simple interface to the X Window 
System. However, ACE may be executed independently without a supporting windowing 
system. Window manipulation operations are provided with the X Window System—ACE 
has integrated Xlib-Ada binding from the Unisys UR20 user interface task to provide a 
programmatic interface to X. 

To execute ACE, the suggested configuration is a Sun-3 workstation running: 


• SunOS 3.5 

• X Window System, X 11 Release 3, if running under X 

• V'erdix Ada Development System version 5.5 and the vi editor 

To create an ACE executable image, the suggested configuration is a Sun-3 workstation 
running: 

• SunOS 3.5 

• X Window System, X 11 Release 3, if using a window system 

• Verdix Ada Development System version 5.5 

• Ada bindings to Xlib (Available from Unisys STARSCenter) 

• C compiler provided with SunOS 3.5 


5 Pragmas Supported by ACE 

Pragmas are the mechanism for controlling ACE’s operating characteristics. These pragmas 
control the production and format of information produced by ACE, and are particularly 
useful for debugging purposes. The following pragmas are supported in ACE: 


1. Observe 

Takes an enumeration string literal (Objects, Statements, or Subprograms) as the first 
argument and one of the identifiers On or Off as the second argument. Default at ACE 
initialization is Off for all three observation items. 


Page 5 





29 October 1990 


STARS-RC-00980/001/00 


An observation window is created to observe the manipulation of objects, statements, 
or subprograms. On enables observation: Off disables observation. Objects displays 
the definition of each object within ACE when it is elaborated. Statements displays 
each Ada statement as it is executed within ACE. Subprograms displays each Ada 
subprogram as it is executed, by displaying the Ada statements that make up the 
subprogram body and highlighting the statement number of each statement as the 
statement is executed. (Execution speed of ACE is artificially decreased during Sub¬ 
programs observation to allow appropriate visual recognition of the trace of statement 
execution.) 

Only a single Subprogram observation window is created. For Objects and Statements , 
each pragma Observe with On will create a new observation window, and will not 
delete the previous observation window. This allows tracing and comparison of several 
program execution paths. 

2. Echo 

Takes one of the identifiers On or Off as the single argument. Default at ACE initial¬ 
ization is Off. 

Echo will display within the primary ACE window each line of input that is being 
processed by ACE. 

3. Dump 

Takes one of the identifiers On or Off as the single argument. Default at ACE initial¬ 
ization is Off. 

Dump will display the Ada statement that has been syntactically and semantically 
checked by ACE prior to its execution. 

4. Trace 

Takes one of the identifiers On or Off as the single argument. Default at ACE initial¬ 
ization is Off. 

Trace will display within the primary ACE window each Ada statement as it is exe¬ 
cuted. (This is similar to pragma Observe (Statements, On) except that tracing output 
is sent to the primary ACE window rather than to a statement observation window.) 

5. Debug 

Takes one of the identifiers On or Off as the single argument. Default at ACE initial¬ 
ization is Off. 

Debug will force ACE to save the local symbolic information associated with subpro¬ 
grams during subprogram execution. This allows local symbolic information to be 
referenced when breakpoints are triggered within subprograms. This saving of local 
symbolic information decreases the execution speed of ACE. 

6. List-Statement-Numbers 


Page 6 







29 October 1990 


STARS-RC-00980/001/00 


Takes one of the identifiers On or Off as the single argument. Default at ACE initial¬ 
ization is Off. 

List.Statement.Numbers will flag the internal Dump routines to associate numbers with 
the statements that are dumped. These numbers can be used in association with the 
ACE Debugger ADT. 

7. Main.Prompt 

Takes a string as its only argument. 

Main_Prompt will set the main prompt of ACE. 

8. ContinueJ-’rompt 

Takes a string as its only argument. 

Continue_Prompt will set the continuation prompt of ACE. 

9. Builtin 

FOR DEVELOPERS/SYSTEM ADMINISTRATORS ONLY 

Takes a string literal, the name of a subprogram, as the r argument and a static 
expression of the predefined integer type as the second argument. 

The body associated with the identified subprogram specification is built-in to ACE. 
The body has been pre-compiled and merged into ACE. ACE does not expect further 
Ada input to define the body for this built-in subprogram. The second argument is an 
internal numbering scheme within ACE to uniquely identify each built-in subprogram. 


6 Environment of ACE 

The environment encompasses the traditional view of programmer interaction with the op¬ 
erating system, such as file manipulations, editors, compilers, debuggers, and windowing 
systems. A set of consistent Ada packages has been constructed to encapsulate these tradi¬ 
tional objects and operations. Moreover, the environment extends the user’s view to include 
interaction with parts of Ada software systems to facilitate programming-in-the-large activi¬ 
ties. 

The environment consists of a set of Ada packages that is interpreted by the ACE Ada 
interpreter, where each package defines an ADT which the user may manipulate, redefine, 
or extend. ADTs implemented in ACE which support the user’s traditional view of an 
environment include: 


• a help ADT 

• a host operating system ADT 

• a hierarchical typed file system ADT (which includes the editor, compiler, stubber, 
and other file support tools) 


Page 7 



29 October 1990 


STARS-RC-00980/001/00 


• a windowing ADT 

• a symbolic debugger ADT 

• Ada predefined library packages (Standard ADT, ASCII ADT, System ADT, Text Jo 
ADT, Io_Exceptions ADT, Low.XeveLIo ADT, Calendar ADT, Object List ADT) 


ADTs implemented in ACE which support rapid prototyping and programming-in-the-large 
include a package ADT and subprogram ADT (i.e. abstract data types that allow Ada 
packages and subprograms to be manipulated as data). 

For example, the ACE user could enter a set of Ada procedures into the Ada interpreter, 
testing and refining them as needed. Then, using the package and subprogram ADTs, the 
user could define a package and insert the procedures into the package, thus creating a new 
ADT. This illustrates the power ACE provides in extending the environment, and the ease by 
which the user may accomplish it. ACE provides the mechanism for the user to interactively 
define a set of data types and operations on the data types. ACE also allows the user to 
further manipulate these types and operations by encapsulating them into abstract data 
types. Moreover, the user may then collect a set of ADTs into a software system. 

Currently, the ACE-developed ADTs provide basic, low-level functionality within their par¬ 
ticular domains. This avoids biasing the ACE environment towards specific existing environ¬ 
ments. Users can easily tailor or augment the basic routines to personal or project needs. As 
general-purpose higher levels of abstraction are defined, additional ADTs will be developed 
which extend the ACE environment. The basic ADTs serve as building blocks for the next 
higher level of abstraction. 


Use of Form Parameters in ACE 

The Foi'm parameter is used within Ada Input-Output (Chapter 14 of the Ada Reference 
Manual) to give system-dependent characteristics that may be associated with a file. For 
example, the Form parameter of the Open subprogram in the package TexLlo is used to 
define attributes of the specified file (e.g., protection, type of file, etc.). Since ACE supports 
TexLlo (and other standard Ada packages) the Form parameter is also supported. 

In addition, the ACE Command Language uses the Form parameter as a mechanism within 
other abstract data types to give system-dependent characteristics that are associated with 
the objects being manipulated within the package. Some ADTs within ACE are concerned 
with the manipulation of subprograms. Expanded names alone cannot uniquely identify 
overloaded subprograms. The Form parameter is the mechanism by which overloaded sub¬ 
programs are uniquely identified. Each Ada statement within ACE is assigned a unique 
statement number . This statement number, passed as a string in the Form parameter, may 
uniquely identify the appropriate subprogram. 

In order to acquire the statement number (or Form ) attribute of a subprogram, ACE also 


Page 8 




29 October 1990 


STARS-RC-009SO/001/00 


provides a Form function within several ADTs. When invoked upon a subprogram or package 
object, this function will return the string Form of the respective object. 

The following example will highlight the use of the Form parameter. List is an operation 
that can display a subprogram’s specification and/or implementation. In the example, in¬ 
vocations of List illustrate acquisition of the most recently defined subprogram of a given 
name ( Interpret ), all subprograms of the same given name, or a specific subprogram of the 
given name—identified via the Form parameter. 


ACE> List ("interpret"); 

procedure interpret (file : in file.type; error : out boolean); 

— Form => " 377" 

pragma builtin (interpret, 505); 

ACE> List ("interpret", "all"); 

procedure interpret (file : in file.type; error : out boolean); 

— Form => " 377" 

pragma builtin (interpret, 505); 


procedure interpret (str : in string; error : out boolean); 

— Form => " 375- 

pragma builtin (interpret, 504); 


procedure interpret (tree : in ace_statement.database; error : out boolean); 

— Form => " 373" 

pragma builtin (interpret, 503); 

ACE> List ("interpret", "375"); 

—? interpret will "execute" the value of the str parameter, 
procedure interpret (str : in string; error : out boolean); 

— Form => " 375- 

pragma builtin (interpret, 504); 


6.1 ACE Libraries and Environment Tailoring 

When ACE is executed, an initialization file is automatically interpreted. This initialization 
file is called startup.ace and is located in the user’s home directory. This file contains ACE 


Page 9 



29 October 1990 


STARS-RC-00980/001/00 


commands (in the form of Ada) that define all the operations (i.e., subprograms) that will 
be recognized by ACE. The following is an example of a start up.ace file: 

—pragma echo(on); 

—pragma trace(on); 

Demo.Directory : constant String := "/ace/demo/"; 

Startup.Directory : constant String := "/ace/startups/"; 

— Define "ft", so we can use environment strings (e.g., Demo.Directory). 
function "ft" (Lhs, Rhs : String) return String; 

pragma builtin ("ft", 0); 

— get routines for measuring CPU. 

Interpret.File (Startup.Directory ft "cpu.time.ace"); 

— Variables for clocking our startup speed. 

Start : Time; 

Stop : Time; 

— Start ticking 
Start := Clock; 

— Ada’s Standard Package 

Interpret.File (Startup.Directory ft "standard.ace"); 

— Key Mappings 

Interpret.File (Startup.Directory ft "bindings.ace"); 

— Normal Command Language commands (e.g., Set.Directory) 

Interpret.File (Startup.Directory ft "commands.ace"); 

— Windowing ADTs 

Interpret.File (Startup.Directory ft "windowing.ace"); 

— Some developer debugging aids 

Interpret.File (Startup.Directory ft "developer.ace"); 

— Xt toolkit ADTs 

Interpret.File (Startup.Directory ft "xt.ace"); 

— Xt demonstration 

Set.Directory (Demo.Directory ft "Xt"); 

—Console ("Support"); 

—Interpret.File ("support"); 


Page 10 



29 October 1990 


STA RS- RC- 00980/001 /00 


—Console ("Globals"); 

--Interpret.File ("globals"); 

--Console ("Edit_panel"); 

--Interpret.File ("edit.panel"); 

--Console ("Callbacks"); 

—Interpret.File ("callbacks"); 

—Console ("Ace.buttons"); 

—Interpret.File ("ace.buttons"); 

—Console ("Demo"); 

—Interpret.File ("demo"); 

—New.Line; 

procedure Back.Word is 
begin 

Do.Move.Left; 

while Key.Bindings.Do.Get.Current.Character = ’ ’ and 
Key.Bindings.Do.Get.Current.Column /= 1 loop 
Do.Move.Left; 
end loop; 

while Key.Bindings.Do.Get.Current.Character /= ’ ' 
and Key .Bindings. Do.Get.Current.Column /= 1 loop 
Do.Move.Left; 
end loop; 

if Key.Bindings.Do.Get.Current.Column /= 1 then 
Do.Move.Right; 
end if; 

end Back.Word; 

procedure Kill.Word is 
begin 

Back.Word; 

while (Do.Get.Current.Character /= ' ’ and 

Do.Get.Current.Character /- Ascii.Nul) loop 
Do.Delete_This.Char; 
end loop; 

Do.Delete.This.Char; 
end Kill.Word; 

procedure Forward.Word is 
begin 

while (Do.Get.Current.Character /= ’ ' and 

Do.Get.Current.Character /= Ascii.Nul) loop 
Do.Move.Right; 
end loop; 

while (Do.Get.Current.Character = ' ’) loop 


Page 11 






29 October 1990 


STARS-RC-00980/001/00 


Do_Move_Right; 
end loop; 
end; 


— Set some history and editing key commands 
Make_Binding (Ascii.Eot, Delete_This_Char); 

Make_Binding (Ascii.Nak, Kill_Line); 

Make.Binding (Ascii.Enq, Key.Bindings.End_0f.Line); 
Make_Binding (Ascii.Soh, Beginning.Of.Line); 

Make_Binding (Ascii.Dc2, Refresh.Current.Line.And.Prompt); 


Make.Binding (Ascii.Etb, Interpret.String, "Kill.Word;"); 

Make.Binding (Ascii.Ack, Interpret.String, "Forward_Word;"); 

Make.Binding (Ascii.Stx, Interpret.String, "Back.Word;"); 


Make.Binding 

Make.Binding 

Make.Binding 

Make.Binding 


(Ascii.Esc & "[A", History.Back); 
(Ascii.Esc & "[B", History.Forward); 
(Ascii.Esc & "CD", Move.Left); 
(Ascii.Esc & "[C", Move.Right); 


— Stop Ticking 
Stop := Clock; 

— How much time? 

Put ("Startup CPU seconds: "); 
Put.Time(Difference(Stop, Start)); 

— ASCII Terminal clear to EOL. 
Put_Line(Ascii.Esc & "[K"); 


The InterpretJFile command is predefined in ACE, and can be used without being defined 
by the user. All other commands and variables must be defined by a previous declaration. 
Through the editing of this file the user can customize and tailor their environment. The 
ACE libraries (.ace files) referred to in the example are described in section 7. 


6.2 ADT Philosophy 

Data abstraction, information hiding, modularity, and locality are some of the the mod¬ 
ern software engineering principles used in the development of software applications. The 
notion of data abstraction is also a powerful mechanism for the definition of a command 
environment—an environment that contains a set of objects upon which a group of com¬ 
mand operations act. 

An abstract data type is an abstraction mechanism that encapsulates a set of values together 


Page 12 









29 October 1990 


STARS-RC-00980/001/00 


with a set of operations that apply to the values. Within software development, the decom¬ 
position of the system may be defined through a set of objects, the operations applicable 
to the objects, and the operations needed by the objects. ADTs serve as a natural descrip¬ 
tion method for this type of system decomposition. ADTs are also a key component of the 
object-oriented design and development approach. 

The directives issued by a software developer to the underlying host environment may also 
be naturally defined through the use of ADTs. Each directive or command may be viewed 
as an operation; the qualifiers or parameters may be viewed as the objects upon which 
the operation is performed. Logically associated objects and operations may be gathered 
together into collections which are related to particular components of the underlying host 
environment. Thus, a parallel can be drawn between abstract data types and the composition 
of a command language. 

Many of the newer procedural languages provide syntactic mechanisms to easily specify and 
manipulate ADTs. Ada is one such language. The constructs of packages (specification and 
body), subprograms (functions and procedures), subprogram invocation, type declarations, 
object declarations, and context clauses are examples of Ada’s support for ADTs. The Ada 
Command Environment makes use of these Ada constructs to define the environment objects 
and operations through ADTs. 

ACE provides an Ada ADT interface to the underlying host environment in the form of Ada 
package specifications. The package specifications are processed by ACE upon initiation. 
Thus, a set of predefined types and operations are made available to the user from the 
beginning of an ACE session. Since these types and operations are defined via the Ada 
package construct, the methods used to manipulate Ada packages are also used to manipulate 
the operation of the environment ADTs. 


6.2.1 The Ada Language Standard 

Ada, as a modern procedural language, encompasses many of the state-of-the-art software 
engineering principles. These principles are extended into the command environment through 
the use of Ada to define the environment with ADTs. 

The Ada package construct supports the principles of data abstraction and information 
hiding through the separation of the package specification from the package body. The 
separation of the specification and implementation of the abstract data type in Ada and 
ACE is a key element in the ability to tailor the environment. Different implementations of 
an environment ADT specification are an obvious mechanism for tailoring the environment 
to a project’s taste. For example, a common configuration management interface may be 
defined through a single ADT specification, but different implementations may be written 
based upon the project’s particular selection of a configuration management application 
system. 

The ability to layer ADTs within Ada supports the principles of modularity and locality. 


Page 13 








29 October 1990 


STARS-RC-00980/001/00 


Environment extensibility may be accomplished through the use of layered ADTs. For 
example, a new ADT specification may be written that presents an interface that is more 
familiar or comfortable to the user. The implementation of that ADT simply invokes the 
standard set of operations. The ADT makes the translation from user orientation to system 
orientation, rather than forcing the human to mentally perform the translation. Layered 
ADTs also support the notion of different levels of abstraction. For example, the notion of 
formatting a textual document, building its table of contents, and printing the result on a 
printer may be viewed as either a single operation or a series of lower level operations. Low 
level ADTs serve as the building blocks for higher level ADTs. 

Within the language definition of Ada, Ada is used to extend its own definition. The Ada 
input-output operations (chapter 14 of the reference manual) are provided in the language by 
the means of predefined packages. In addition, other-predefined library packages are required 
for each Ada implementation. ACE has implemented the Ada predefined packages, such as 
Standard , ASCII, Calendar, System, and Text.Io. This set of packages makes the standard 
Ada types and operations available in the command environment. Continuity is established 
between the command environment and the typical Ada development environment. 

ACE also views the set of Ada predefined packages defined in the reference manual as a set 
of guidelines to be followed in the development of environment ADTs. The input-output 
packages of chapter 14 of the reference manual denote a style of operation definition and 
object manipulation that ACE has expanded to encapsulate the entire environment. The 
Create, Open, Close, and Delete procedures that are applicable to file objects are used within 
the command environment to define similar control operations upon other types of objects. 
An example of this is the similar treatment of file objects and window objects. File objects 
and window objects are each abstract data types in ACE that are created using the Create 
procedure and removed using the Delete procedure. The operations that the Ada developer 
is familiar with in the program development- environment are the same operations that are 
to be invoked within the host environment to accomplish similar tasks. 

The guidelines are followed in more detail than simply through subprogram names. Names 
and modes of parameters, the selection of a procedure versus a function, and the use of the 
Form parameter as a string data type to specify non-default implementation options are all 
further examples of following the style of Ada as defined in the language standard. These 
and other instances of conformance within ACE, enforce an Ada-oriented style of ADTs 
within the ACE environment. 


6.2.2 Command Structure 

Consistency and uniformity in the command environment of ACE is achieved through the 
use of Ada and ADTs. Commands and objects are logically grouped together as ADTs 
via the Ada package mechanisms. This grouping allows the environment to be structured 
and ordered. In addition, by nesting packages and subprograms the environment provides 
controlled access to information. Users explore the environment in an orderly and informative 
manner. This logical grouping of environment components has many benefits over the fiat 


Page 14 







29 October 1990 


STARS-RC-00980/001/00 


structure supported by most command languages. 

For example, if a specific windowing package is nested inside a basic windowing package, 
novice users must "use" or reference the basic windowing package before they can access 
the specific windowing package. This does not guarantee that novice users understand the 
environment. However, it does guarantee that novice users understand the logical structure 
of the environment. Of course, expert users who know the structure of the environment are 
not hindered, since they can simply reference an arbitrarily nested command via the Ada 
expanded name feature. 

Another benefit of this command structure combined with Ada is the ability to define a user 
interface that is consistent with the paradigms of Ada, as well as uniform in its treatment 
of objects and operations in the environment. Such an environment would support (at all 
levels of interaction with the environment) Ada philosophies, providing an excellent vehicle 
for Ada development. The facilities of overloading and derived subprograms in Ada provide 
the opportunity to define uniform interfaces to logically related operations and objects. As 
described above, the ability to define a Create operation for each type of environment object 
is supported in Ada through overloading. ACE supports overloading to allow the uniform 
definition of abstract data types across the entire command environment. In addition to 
being consistent with the Ada standard, the environment is also uniform among the ADTs 
that are defined within it. 


6.2.3 Command Applicability 

One benefit of modern procedural languages is the notion of strong typing. The benefits of 
strong typing within Ada are also of benefit to Ada as a command language and the definition 
of ADTs. While ADTs allow the definition of operations for objects, strong typing enforces 
the proper use of the operations. Many of the problems associated with a novice’s use of 
a command language can be attributed to the application of operations to inappropriate 
objects (e.g., printing a binary image). In a strongly typed command language, and in 
particular ACE, if there is no operation ‘‘print” defined for binary image objects then the 
user can not (even accidentally) apply the operation. 

Another benefit of strong typing in a command language is in the operation of very large 
software systems. Many of the benefits of using ADTs in the construction of these software 
systems are retained in the command language which acts as the “glue” which holds such 
systems together. Having a strongly typed command language helps guarantee that the 
systems are correctly constructed from their components. In addition, having a compilable 
command language allows an interpreted system to become an entirely compiled system 
merely by compiling the command language, whereas in a traditional command language, 
the “glue” would have to be rewritten into the system’s programming language. 


Page 15 






29 October 1990 


STARS-RC-00980/001/00 


6.2.4 Command Specialization 

Through the use of derived types and derived subprograms, new objects can be described 
as specializations of existing objects, i.e., described as differences from existing objects. For 
example, the entire abstract data type for ACE’s hierarchical file system is constructed of 
existing ADTs that are specializations of a general file ADT. The general file ADT provides 
the basic operations (e.g., Create, Delete, Copy, Rename, etc.) that can be performed on all 
files. The immediate specializations of the general file ADT are TextJFiles, Directory^Files, 
and BinaryJ'iles. Each of these specializations provides specific new or redefined operations 
for each type. Any operation defined for the general file ADT that is not redefined in a 
specialization’s operations is inherited by the specialization. Therefore, each specialization 
of the general file ADT inherits the Create , Delete , etc. operations, which in turn allows every 
type of file in the file system to be manipulated via the general file operations. Specialization 
provides a very powerful reuse mechanism within ACE; existing objects can be extended or 
tailored for particular applications or user aesthetics without having to describe the entire 
ADT. 

In addition, since Ada (and consequently ACE) implicitly derives subprograms for every 
derived type, much of the work that is normally associated with strong typing in a command 
language and the construction of a hierarchical command environment is removed from 
the user. Each derived type implicitly inherits a set of commands that enable its basic 
manipulation. 


6.2.5 Command Extensibility 

An important part of any state-of-the-art environment is the ability of the environment to 
evolve as technology and methodologies evolve. ACE’s approach is to use Ada ADTs to 
define the command language (creating a command environment). As described before, Ada 
ADTs have a clean separation of implementation from specification. Therefore, as technology 
makes small leaps, the new techniques can be incorporated in the ADT implementation 
while not effecting the specification. In addition, when radical breakthroughs are made in 
technology, new environment ADTs can be constructed and incorporated into the command 
environment. Using this approach, we are only limited by the ability of Ada to assimilate 
new approaches. 


6.3 ADT Interfaces within ACE 

Abstract data types within ACE are defined by Ada packages. The package specifications 
encapsulate the definition of the objects and the operations that are applicable to the ob¬ 
jects. Additionally, the package specification provides a mechanism for information hiding, 
particularly hiding of the operations' implementations. The Ada package body contains the 
implementation of the object and its respective operations. 

ACE supports two mechanisms for the implementation of the ADT bodies: interpreted and 


Page 16 







29 October 1990 


STARS-RC-00980/001/00 


built-in. Each of these mechanisms supports a different facet of environment definition, and 
together they provide the facilities to compose and extend the Ada command environment. 
Additionally, ACE through its ADTs provides a mechanism to access executable images 
external to ACE. This provides added power and flexibility to the command environment. 


6.4 ADT Body Implementations 

As previously stated, Ada is the command language accepted by ACE and interpreted by 
ACE’s command language interpreter. The environment (as defined by Ada packages) is 
read by the command language interpreter and processed, resulting in the elaboration of 
Ada packages. This process of interpreting Ada ADT package specifications and bodies is 
the typical method through which ADTs are declared within ACE. 

ACE provides an additional mechanism by which package bodies may be defined. Rather 
than interpreting an Ada package body, the Ada code may be compiled and linked into 
the ACE executable. The package specification for the package is still Ada code that is 
interpreted by ACE. A pragma directive informs ACE that the package body associated 
with this package specification is already compiled and included within ACE. 

This method of package body inclusion provides benefits to the runtime efficiency of ACE. 
ACE may be tuned such that frequently invoked code is executed at the machine language 
level (i.e., the compiled level), rather than interpreted. 

Another benefit of compiled implementation is that it provides interactive invocation and 
composition of compiled code within the command environment. An example of this is the 
X Window System ADT of ACE which provides Ada interfaces to the X Window System 
(currently implemented in C). 


6.5 External Images 

A vast array of applications and support tools are typically available within the host envi¬ 
ronment. ACE does not impose a restrictive environment that limits the facilities available 
to the software developer. Through a host operating system ADT, ACE provides an inter¬ 
face mechanism which makes external executable images on the host system available from 
within the command environment. Thus, environment ADT specifications are able to pro¬ 
vide the user with a consistent Ada paradigm that may interface with a diverse set of Ada 
and non-Ada external images, including the host operating system. 

The ability to access external images provides the opportunity to build high level Ada ab¬ 
stractions from low level non-Ada applications. Relationships may be formed among stand¬ 
alone applications, providing a higher level data abstraction that encompasses the user’s 
desired functionality. The intricacies and/or idiosyncrasies of the individual applications 
are hidden from the user in the ADT implementation. The implementation also hides the 
handling of intermediate results being passed between applications. The user simply sees 


Page 17 





29 October 1990 


STARS-RC-00980/001/00 


the specification, which is designed to provide a consistent interface within the Ada-oriented 
environment. 

By invoking external images through environment ADTs, the functionality of ACE can be 
extended into domains which can be tailored to specific environments, projects, or users. For 
example, a project-oriented configuration management ADT can be defined which provides 
software configuration control objects and operations. The programs which must be accessed 
to support these facilities may exist scattered about the file system, or perhaps in a common 
directory with many other programs unrelated to configuration management tasks. The 
configuration management ADT can provide a coherent view of these operations and hide 
the organization or disorganization of the underlying programs. 


6.6 ADT Summary 

This section lists the ADTs which are defined in the startup.ace file provided with the current 
release of ACE and gives a brief description of the subprograms and objects provided by the 
package. 


1 . 

2 . 

3. 

4 . 


6 . 


8 . 


9. 

10 . 

11 . 

12 . 


Objects Contains the basic definitions for all objects in the environment. 

Standard Predefined identifiers based upon the package Standard in the LR\1 (C). 

ASCII Contains identifiers for characters in the ASCII character set, as defined in the 
LRM (C). This package is defined within the package Standard. 

System Contains identifiers for configuration-dependent characteristics. It is based 
upon the package System as defined in the LRM (13.7). 

Io.Exceptions Not currently supported. 

LowJeveLIo Not currently supported. 

Calendar Provides the user operations on the clock, as defined in the LRM (9.6). 


Text Jo 

Provides facilities for input and output in human-readable form, as defined in the LRM 
(14.3). 


AceJntegerJo Provides input/output functions for integers. This is a hand-instantiated 
version of the Integer Jo package defined in the LRM (14.3.7), tailored for Integer Jo 
type. 


AceJStandard Provides assistance objects and operations that are standard for ACE. 


AceJo Provides operations that control the input/output of the ACLI. 


Strings Provides operations that mimic the slicing and indexing of arrays for Ace_String. 


Page 18 







29 October 1990 


STARS-RC-00980/001/00 


13. .1 ce.Adt Provides objects and operations to support a programmatic interface to the 

ACLI. 

14. I lost.Os Provides an interface to the underlying host operating system. 

15. Manipulntejycope Provides operations to support the dynamic removal and hiding of 
objects from the environment. 

16. Debugger Provides operations to manipulate the symbolic execution of subroutines. 

17. File.System Defines objects and operations that may be performed on the hierarchical, 
typed file system. 

18. Directory.Objects Provides operations that may be performed upon directories. 

19. Text.Ohjects Provides operations that may be performed upon text files. 

20. Program.Oojects Provides operations that may be performed upon programs. 

21. Program.Text.Objects Provides an interface to the the Ada Repository Stubber pro¬ 
gram. 

22. Qinary.Objects Provides operations that may be performed upon binary files. 

23. Program.Units Provides the objects and operatic- ' .r ACE compilation units. 

24. Help-Adt Defines operations which ^“ovlde the user with on-line assistance for declared 
objects in ACE, namely: packages, subprograms, and types. 

25. Object-Lister Provides a routine to allow qucne- the statement database for groups 
of objects declared the same way (i.e, all objects, all types, etc). 

26. Key.Bindings Provides the operations that allow sequences of key strokes to be bound 
to editing and history functions. 

27. Window.Objects Defines the objects that are associated with the Window ADTs. 

28. AceJK.WindowJSystem Provides an interface to a small subset of the X Window system 
based upon the X Window naming conventions. 

29. Ace.U ser-X.WindowSystem Provides an interface to a small subset of the X Window 
system based upon Ada paradigms. 

30. Window.Draw.Routincs Provides a simple set of drawing operations that may be per¬ 
formed in Window objects. 

31. Line-Counter Provides a completely interpreted Ada line counter operation. 

32. Cuis-Routines Provides access to the underlying CAIS-A operations. 

33. Stnrs.Tools Provides access to various STARS developed tools. 


Page 19 







29 October 1990 


STARS-RC-009S0/001/00 


31. Cpn-Time Provides operations to determine CPU use. 

3o. A_l Vi n dotes Provides declarations of the basic X library data types needed to use the 
ACE interface to the Xt toolkit, 

36. Rename (LX lib .Types Defines the connection between some type names used by Xt 
routines and the equivalent type names in the basic X libary. 

37. Intrinsics Contains the type declarations common to all Xt toolkit routines. 

38. WidgeLPackage Provides a sample selection of Xt toolkit procedures. 

39. Xt-Stringdefs Defines commonly used Xt resource name constants. 

40. Hp-Widgets Provides the ACE interface to the Hewlett-Packard widget set. 

6.7 ACE Command List 

Ace Adt: Compile, Delete, Interpret, Interpret_File 

Ace Io: Current_Ace_Input, Current_Ace_Output, Set_Ace_Input, Set_Ace_0utr>ut, 
Standard.Ace.Input, Standard_Ace_Output 

Ace User X Window System: Create, Delete 

Ace X Window System: Clear_Window, Create_Window, Destroy_Window 

Ada Standard Commands: abs, and, mod, not, or, rem, xor, +, -, <, <=, =, >, 

>=, /=,*, /, **, & 

Binary Objects: Execute 

Calendar: Clock, Day, Month, Seconds, Split, Time_0f, Year, +, <, <=, >, > 

Cais Routines: Append_To_Cais_Arg_List, Create_Cais_Argument_List, 
Invoke.Process, Put.Cais.File.Node.Host.Name, 
Put.Cais.Node.Relationships, Put.Current_Cais_Node, 

Prefix_To_Cais_Arg_List, Set_Current_Cais_Node, Spawn.Process, 

Cpu Time: Clock, Difference, Put.Time 

Debugger: Break, Clear.Break, Continue, Display, Display.Current.Statement, 
Display.Next, Display.Previous, List, List.Breakpoints, 
List.Symbol.Table, Set.Break, Step 

Directory Objects: Close, Create, Current.Directory, Form, Home.Directory, 


Page 20 







29 October 1990 


STARS-RC-009S0/001/00 


ls_0pen. List, Name, Open, Put.Current.Directory, Set_Directory 

File System: Copy, Create, Delete_File, Exists, Open, Rename, Reset, 
Temporary_Name 

Help: Help 

Host: Host 

Hp Widgets: Xw.Arrow.Widget.Class, Xw.Ascii.Sink.Create, 
Xw_Bulletin_Board_Widget_Class, 

Xw.Bulletin.Widget.Class, Xv_Button_Widget_Class, 

Xw_Cascade_Widget.Class, Xw.Disk.Source.Create, 

Xw.Disk.Source.Destroy, Xw.Form.Widget.Class, 

Xw.Image.Edit.Widget.Class, Xw.List.Widget.Class, 
Xw.Listrow.Col.Widget.Class, Xw.Manager.Widget.Class, 
Xw.Menu.Button.Widget.Class, Xw.Menu.Sep.Widget.Class, 
Xw.Menubutton.Widget.Class, Xv.Menumgr.Widget.Class, 
Xw.Menupane.Widget.Class, Xw.Move.Focus, Xw.Panel.Widget.Class, 
Xw.Popup.Mgr.Widget.Class, Xw.Popupmgr.Widget.Class, 
Xw.Primitive.Widget.Class, Xw.Push.Button.Widget.Class, 
Xw.Row.Col.Widget.Class, Xw_Sash.Widget.Class, 

Xw.Scroll.Bar.Widget.Class, Xw.Scrollbar.Widget.Class, 
Xw.Scrolled.Window.Widget.Class, Xt.Set.Arg, Xu.Sraster.Widget.Class, 
Xw.Static.Raster.Widget.Class, Xw.Static.Text.Widget.Class, 
Xw.Statictext.Widget.Class, Xw.String.Source.Create, 
Xw.String.Source.Destroy, Xw.Swindow.Widget.Class, 

Xw.Text.Clear.Buffer, Xw.Text.Copy.Buffer, Xw.Text.Copy.Selection, 
Xw.Text.Edit.Widget.Class, Xw.Textedit.Widget.Class, 

Xw.Text_Get_Insert.Pos, Xw.Text_Get_Last.Pos, Xw.Text_Get_Selection.Pos, 
Xw.Text.Insert, Xw.Text.Read.Sub.String, Xw.Text.Redraw, 
Xw.Text_Set_Insert.Pos, Xw.Text.Set.Selection, Xw.Text.Set.Source, 
Xw.Text.Replace, Xw.Text.Unset.Selection, 

Xw_ T ext.Update, Xw.Text.Set.Source, 

Xw.Title.Bar.Widget.Class, Xw.Titlebar.Widget.Class, 

Xw.Toggle.Widget.Class, Xw.Valuator.Widget.Class, 

Xw.Work.Space.Widget.Class 

Intrinsics: Null.Caddr.T, Null.Widget, Null.Widget.Class 

Key Bindings: Do.Goto.End.Of.History, Do.Goto.Start.Of.History, 

Do.Goto_Beg.Of.Line, Do.Goto.End.Of.Line, 

Do.Move.Left, Do.Move.Right, 

Do.Show.Historj, Do.Delete, Do.Delete.This.Char, 

Do.Self.Insert, Do.Kill.Line, 







29 October 1990 


STARS-RC-00980/001/00 


Do_Insert_String, Do.Show.History.Limat, Do.Set.History.Limit, 
Do_Quoted_Insert, Do.Refresh.Current.Line, 

Do_Refresh_Current_Line_And_Prompt, Do_Rewrite_Current_Line, 
Do.Rewrite.Current.Line.And.Prompt, Do_Get_Current_Line, 

Do_Get_Current.Character, Do.Get.Current.Column 
Make.Binding, Interpret.String, History.Back, History.Forvard 

Manipulate Scope: Delete, Deuse, Undelete 

Object Lister: List 

Program Objects: Compile, Edit.And.Interpret 

Program Units: Close, Create, Delete, Deuse, Form, Is.Open, List, Mode, Name, 
Open, Put 

Stars Tools: Check.Style, Count.Features, Count.Statements, 

Diana.Browser, Diana.Front.End, Diana.Mklib, Diana.Rmlib, 

Diana.Cleanlib, Diana.Make.Predefined.Env, Diana.Create.Predefined.Env, 
Measure.Mccabe.Complexity, Set.Up, Test.Case.Generator, 
Test.Results.Analyzer, Test.Procedures.Generator, Test.Comparator, 

Test.Updater 

Strings: Length, Slice 

Text Io: 

File Management: Close, Create, Delete, Form, Is.Open, Mode, Name, 

Open, Reset 

Default Io Control: Current.Input, Current.Output, Set.Input, Set.Output, 
Standard.Input, Standard.Output 

Specify Line and Page Length: Line.Length, Page.Length, Set.Line.Length, 

Set.Page.Length 

Column, Line and Page Control: Col, End.Of.File, End.Of.Line, End.Of.Page, 
Line, New.Line, New.Page, Page, Set.Col, Set.Line, Skip.Line, Skip.Page 

Character Input-Output: Get, Put 

String Input-Output: Get, Get.Line, Put, Put.Lme 

Ace Integer Io: Get, Put 


Page 22 







29 October 1990 


STARS-RC-00980/001/00 


Text Objects: Edit, Edit.File, Get.File, List, List.File, Print, Put.File 

Widgets Package: Action.Procedure.Pointer, Callback_Procedure_Pointer, 
Create, Get, Make_Xt_Stnng, Null_Xrm_Option_List, Null.Xt.Arg.List, 

Put, Xt_Add_Actions, Xt_Add_Callback, Xt.App.Next.Event, 
Xt.Augment.Translations, Xt.Create.Managed.Widget, Xt.Create.Widget, 
Xt.Default.App.Context, Xt_Destroy_Widget, Xt_Dispatch_Event, 
Xt.Get.Value, Xt.Initialize, Xt_Main_Loop, Xt_Qverride_Translations, 
Xt.Parse.Translation.Table, Xt_Realize_Widget, Xt_Set_Arg, 

Xt.Set.Values, X.Text.Width 

Window Draw Routines: Draw.Dashed.Line, Draw.Line, Draw.Rectangle, 
Draw.Rectangle.Builtin, Draw.Text 

X Windows: Ascent, Descent, Text.Width 


7 Abstract Data Types of ACE 

This section provides a description of the Abstract Data Types (ADTs) currently supported 
by ACE. The ADTs are grouped into several related areas as ACE library files. They are: 
standard.ace, commands.ace, bindings.ace, windows.ace, and cais.ace. 

1. standard.ace provides the standard Ada package, and several packages that are stan¬ 
dard to ACE. 

2. commands.ace provides the operations that are normally associated with a command 
language. 

3. bindings.ace provides the operation to bind arbitrary key strokes to editing and history 
functions. 

4. windows.ace provides a simple interface to the X Window System. 

5. cais.ace provides an interface to the underlying CAIS-A implementation. 

6. cpuJime.ace provides the operation to measure CPU time use. 


7.1 Standard Packages 

The following packages provide the standard definitions of the required Ada packages, and 
several packages that are standard for ACE. 


Page 23 







29 October 1990 


STARS-RC-00980/001/00 


7.1.1 Objects 

The basic building blocks of all ACE objects are the objects package, derived types, and 
derived subprograms. The "Object_Type" type is the basic representation of every object in 
ACE, and provides the means (through derived subprograms) of defining operations on all 
ACE objects. Since every object in ACE is a derived type of "Object.Type” in the objects 
package, it is possible to define an operation that can act on every object in ACE. 


package Objects is 

type Object_Type is new Integer; 
end Objects; 


7.1.2 Standard 

This is the package "Standard” from the Ada reference manual as implemented in ACE. The 
description order of this package is slightly rearranged from that within the Ada reference 
manual order to conform with the format used in the description of all ACE’s ADTs. 


package Standard is 
use Objects; 

— type Boolean is (False, True); 

-- The predefined relational operators for this type are as follows: 

function ”=” (Left, Right : Boolean) return Boolean; 

function "/=" (Left, Right : Boolean) return Boolean; 

function "<" (Left, Right : Boolean) return Boolean; 

function "<=" (Left, Right : Boolean) return Boolean; 

function ">" (Left, Right : Boolean) return Boolean; 

function ">=»" (Left, Right : Boolean) return Boolean; 

— The predefined logical operators and the predefined logical 

— negation operator are as follows: 


function "and" (Left, Right : Boolean) return Boolean; 
function "or" (Left, Right : Boolean) return Boolean; 
function "xor" (Left, Right : Boolean) return Boolean; 


Page 21 








29 October 1990 


STARS-RC-00980/001/00 


function "not" (Right : Boolean) return Boolean; 

-- the Universal type universal_integer is predefined. 

— type Integer is range -Integer'last .. Integer'last; 

— The predefined operators for this type are as follows: 


function 

II s l« 

(Left, 

Right 

: Integer) 

return 

Boolean; 

function 

it y s n 

(Left, 

Right 

: Integer) 

return 

Boolean; 

function 

H 

(Left, 

Right 

: Integer) 

return 

Boolean; 

function 

ii < = ii 

(Left, 

Right 

: Integer) - 

'return 

Boolean; 

function 

ii^ii 

(Left, 

Right 

: Integer) 

return 

Boolean; 

function 

(1 \ s (l 

(Left, 

Right 

: Integer) 

return 

Boolean; 


function "+" (Right : Integer) return Integer; 
function (Right : Integer) return Integer; 
function "abs" (Right : Integer) return Integer; 


function "+" 
function 
function 
function "/" 
function "rem" 
function "mod" 


(Left, Right 
(Left, Right 
(Left, Right 
(Left, Right 
(Left, Right 
(Left, Right 


Integer) return Integer; 
Integer) return Integer; 
Integer) return Integer; 
Integer) return Integer; 
Integer) return Integer; 
Integer) return Integer; 


function "**" (Left : Integer; Right : Integer) return Integer; 

— Type Float is unimplemented. 

— Type Character is partially implemented, but not supported, 
package Ascii is 


’age 25 







29 October 1990 


STARS-RC-00980/001/00 


-- Control characters: 


Nul 

constant Character 

= Character'VAL 

Soh 

constant Character 

= Character'VAL 

Stx 

constant Character 

= Character’VAL 

Etx 

constant Character 

* Character’VAL 

Eot 

constant Character 

= Character'VAL 

Enq 

constant Character 

= Character’VAL 

Ack 

constant Character 

= Character'VAL 

Bel 

constant Character 

= Character'VAL 

Bs 

constant Character 

= Character'VAL 

Ht 

constant Character 

= Character'VAL 

Lf 

constant Character 

= Character'VAL 

Vt 

constant Character 

= Character'VAL 

Ff 

constant Character 

= Character'VAL 

Cr 

constant Character 

* Character'VAL 

So 

constant Character 

= Character'VAL 

Si 

constant Character 

= Character'VAL 

Die 

constant Character 

= Character’VAL 

Del 

constant Character 

= Character'VAL 

Dc2 

constant Character 

= Character’VAL 

Dc3 

constant Character 

= Character'VAL 

Dc4 

constant Character 

= Character'VAL 

Nak 

constant Character 

* Character'VAL 

Syn 

constant Character 

* Character'VAL 

Etb 

constant Character 

= Character’VAL 

Can 

constant Character 

= Character’VAL 

Em 

constant Character 

= Character'VAL 

Sub 

constant Character 

= Character'VAL 

Esc 

constant Character 

= Character’VAL 

Fs 

constant Character 

= Character'VAL 

Gs 

constant Character 

= Character'VAL 

Rs 

constant Character 

= Character'VAL 

Us 

constant Character 

* Character'VAL 

Del 

constant Character 

= Character'VAL 


— Other characters: 


Exclam 

: constant 

Character 

; s 

> 1 > 

Sharp 

: constant 

Character 

' 3 


Percent 

: constant 

Character 

; = 

’7.’ 

Colon 

: constant 

Character 

: = 

) . 1 

Query 

: constant 

Character 

; s 

t 7 > 

L.Bracket 

: constant 

Character 

: = 


R.Bracket 

: constant 

Character 

: = 



( 0 ); 

(1) ; 

( 2 ) ; 

(3) ; 

(4) ; 

(5) ; 
(5); 

(7) ; 

( 8 ) ; 

(9) ; 

( 10 ) ; 
(11); 
( 12 ); 

(13) ; 

(14) ; 

(15) ; 

(16) ; 

(17) ; 

(18) ; 

(19) ; 

( 20 ) ; 

(21); 

(22); 

(23) ; 

(24) ; 

(25) ; 

(26) ; 

(27) ; 

(28) ; 

(29) ; 

(30) ; 

(31) ; 
(127); 


Rage 26 















29 October 1990 


STARS-RC-009S0/001/00 


Underline : 

constant Character : 

— ) > . 

— i 

L_Brace 

constant Character : 

= 

R.Brace : 

constant Character : 

= 

Quotation 

constant Character 

_ i ti t * 

Dollar 

constant Character 

* 

Ampersand 

constant Character 

* '4'; 

Semicolon 

constant Character 

— ) . / . 

9 9 

At_Sign 

constant Character 

= '<0’ ; 

Back_Slash 

constant Character 

= ’ V ; 

Circumflex 

constant Character 

s » “ » • 

1 

Grave 

constant Character 

— ) t > . 

9 

Bar 

constant Character 

- ' 1 '; 

Tilde 

constant Character 

— i — > . 

9 

— Lower case letters: 


Lc_A 

constant Character 

= 'a'; 

Lc_B 

constant Character 

» 'b'; 

Lc_C 

constant Character 

= 'c'; 

Lc_D 

constant Character 

= 'd'; 

Lc_E 

constant Character 

= 'e'; 

Lc.F 

constant Character 

* 'f ’; 

Lc.G 

constant Character 

* 'g'; 

Lc_H 

constant Character 

« 'h'; 

Lc_I 

constant Character 

* 'i'; 

Lc.J 

constant Character 

= 'j'; 

Lc.K 

constant Character 

» 'k'; 

Lc_L 

constant Character 

- '1'; 

Lc_M 

constant Character 

= 'm' ; 

Lc_N 

constant Character 

= 'n' ; 

Lc_0 

constant Character 

= 'o'; 

Lc_P 

constant Character 

= 'p'; 

Lc_q 

constant Character 

= ’q'; 

Lc_R 

constant Character 

= 'r'; 

Lc_S 

constant Character 

* 's'; 

Lc_T 

constant Character 

* 't'; 

Lc_U 

constant Character 

= 'u' ; 

Lc_V 

constant Character 

* 'v'; 

Lc.W 

constant Character 

- 'w' ; 

Lc_X 

constant Character 

= 'X' 

Lc_Y 

constant Character 

= ’y’; 

Lc.Z 

constant Character 

a ’Z’ 

end Ascii; 




Page 27 











29 October 1990 


STARS-RC-009S0/001 /00 


— Predefined subtypes: 

subtype Natural is Integer; — range 0 .. Integer'last; 
subtype Positive is Integer; — range 1 .. Integer'last; 

— type String is array (Positive range <>) of Character; 

— Type "String" is not implemented in ACE as a one-dimensional array 

— of the predefined type character. Strings and string literals 

— within ACE provide some of the operations that are applicable to 
-- Standard strings. Operations applicable to one-dimensional arrays 

— are not applicable to "String"s in ACE. 

— When composite types are supported in ACE, "String" will be changed 

— to its array definition. 

subtype Ace_String is String; 


function "=" (Left, Right 
function "/■" (Left, Right 
function "<" (Left, Right 
function "<*" (Left, Right 
function ">" (Left, Right 
function ">*" (Left, Right 


String) return Boolean; 
String) return Boolean; 
String) return Boolean; 
String) return Boolean; 
String) return Boolean; 
String) return Boolean; 


function "ft" (Left : String; Right : String) return String; 
function "ft" (Left : String; Right : Character) return String; 
function "ft" (Left : Character; Right : String) return String; 
function "ft" (Left : Character; Right : Character) return String; 


type Duration is new Object.Type; 

— Duration is simply a new integer type 

— since fixed points are not implemented [TDB] 


— Exceptions are not supported. [TDB] 


-- Constramt.Error : exception; 

— Numeric.Error : exception; 

— Program.Error : exception; 

-- Storage.Error : exception; 


Pago 28 







29 October 1990 


STA RS- RC- 00980/001 /00 


— Tasking_Error : exception; 
end Standard; 


7.1.3 System 

Predefined system package, as defined in the Ada standard. 

package System is 
use Objects; 

type Address is new Object_Type; 
type Name is (Ms_Dos, Sun.Unix); 

System_Name : constant Name := Sun„Unix; 

— Storage_Unit : constant Integer := 1; 

— Memory_Size : constant Integer := 1; 

Min_Int : constant i ceger := Integer’First; 

Max.Int : const-n' integer := Integer’Last; 

— Max_Digits : constant Integer := 1; 

— Max.Man^issa : constant Integer := 1; 

— Fine_Delta : constant Integer := 1; 

— Tick : constant Integer := 1; 

— subtype PRIORITY is integer range -16 .. 16; 

end System; 


7.1.4 IoJExceptions 

This package defines the exceptions needed by the packages 
Sequential_Io, Direct_Io, and Text.Io. Only Text.Io is 
implemented in ACE. Exceptions are currently not fully supported. 


package Io_Exceptions is 


Status_Error 

Mode_Error 

Name.Error 

Use.Error 


exception; 
exception; 
exception; 
exception; 


Page 29 







29 October 1990 


STARS-RC-00980/001/00 


Device.Error : exception; 
End.Error : exception; 
Data_Error : exception; 
Layout_Error : exception; 

end Io.Exceptions; 


7.1.5 LowXeveUo 

Low Level input-output operations are operations that act on a physical 
device. Low_Level_Io is currently not supported. 

package Low_Level_Io is 

end Low.Level.Io; 


7.1.6 Calendar 


This package provides the user access to operations on the 
clock, as defined in the LRM (9.6). 

Note: Duration is currently not implementated as a fixed point, 
and exceptions are currently not supported. 

package Calendar is 
use Objects; 


type Time is new Object_Type; 


subtype Year.Number is Integer; 
subtype Month.Number is Integer; 
subtype Day.Number is Integer; 
subtype Day_Duration is Duration; 


range 

1901 

.. 2099; 

range 

1 . . 

12; 

range 

1 . . 

31; 

range 

0 . . 

86.400; 


function Clock return Time; 

function Year (Date : Time) return Year.Number; 
function Month (Date : Time) return Month.Number; 
function Day (Date : Time) return Day.Number; 
function Seconds (Date : Time) return Day.Duration; 

procedure Split (Date : in Time; 

Year : out Year.Number; 


Page :10 



29 October 1990 


STARS-RC-009S0/001/00 


Month : out Month_Number; 

Day : out Day.Number; 

Seconds : out Day_Duration); 


function Time.Of (Year 

Month 

Day 

Seconds 


Year.Number; 

Month.Number; 

Day.Number; 

Day.Duration := 0) return Time; 


function "+" (Left 
function "+" (Left 
function (Left 
function (Left 


Time; Right : Duration) return Time; 

Duration; Right : Time) return Time; 

Time; Right : Duration) return Time; 

Time; Right : Time) return Duration; 


function "<" 
function "<=" 
function ">" 
function ">=" 


(Left, Right 
(Left, Right 
(Left, Right 
(Left, Right 


Time) return Boolean; 
Time) return Boolean; 
Time) return Boolean; 
Time) return Boolean; 


Time.Error : exception; 


end Calendar; 


7.1.7 Text Jo 

This is the "Text.Io" package of Ada (Chapter 14 of the Ada 
Reference Manual). 


package Text.Io is 
use Objects; 

type File.Type is new Object.Type; 
type File.Mode is (In.File, Out.File); 

type Count is new Integer; 
subtype Positive.Count is Count; 

Unbounded : constant Count := 0; — line and page length 

subtype Field is Integer; 
subtype Number.Base is Integer; 

type Type.Set is (Lower.Case, Upper.Case); 

-- File Management 


Page :{1 









29 October 1990 


STARS-RC-00980/001/00 


procedure Create (File : in out File.Type; 

Mode : in File_Mode := Qut_File; 

Name : m String := 

Form : in String := 

procedure Open (File : in out File.Type; 

Mode : in File_Mode; 

Name : in String; 

Form : in String := 

procedure Close (File : in out File_Type); 
procedure Delete (File : in out File_Type); 
procedure Reset (File : in out File_Type; 

Mode : in File_Mode); 

procedure Reset (File : in out File_Type); 

function Mode (File : in File.Type) return File_Mode; 

function Name (File : in File.Type) return String; 

function Form (File : in File.Type) return String; 

function Is_0pen (File : in File.Type) return Boolean; 

— Control of default input and output files 

procedure Set_Input (File : in File.Type); 
procedure Set_Output (File : in File.Type); 


function Standard,Input return File.Type; 
function Standard.Output return File.Type; 

function Current_Input return File,Type; 
function Current_Qutput return File.Type; 

— Specification of line and page lengths 


procedure Set_Line_Length (File : in File.Type; 

To : in Count); 

procedure Set_Line_Length (To : in Count); 

procedure Set_Page_Length (File : in File_Type; 

To : in Count); 

procedure Set_Page_Length (To : in Count); 


Pa £<• :{2 






) October 1990 


STARS-RC-00980/001 / GO 


function Lme.Length (File : in File_Type) return Count; 
function Lme_Length return Count; 

function Page_Length (File : in File_Type) return Count; 
function Page_Length return Count; 

— Column, Line, and Page Control 

procedure New_Line (File : in File_Type; 

Spacing : in Positive_Count := 1); 
procedure New_Line (Spacing : in Positive.Count := 1); 

procedure Skip_Line (File : in File_Type; 

Spacing : in Positive_Count := 1); 
procedure Skip_Line (Spacing : in Positive.Count := 1); 

function End_0f_Line (File : in File_Type) return Boolean; 
function End_0f_Line return Boolean; 

procedure New_Page (File : in File_Type); 
procedure New_Page; 

procedure Skip_Page (File : in File_Type); 
procedure Skip_Page; 

function End_Of_Page (File : in File.Type) return Boolean; 
function End_0f_Page return Boolean; 

function End_0f_File (File : in File_Type) return Boolean; 
function End_0f_File return Boolean; 

procedure Set.Col (File : in File_Type; 

To : in Positive.Count); 
procedure Set.Col (To : in Positive.Count); 


procedure Set_Line (File : in File_Type; 

To : in Positive_Count); 
procedure Set_Line (To : in Positive.Count); 

function Col 'File : in File_Type) return Positive_Count; 
function Col return Positive; 


Page M 







29 October 1990 


STARS-RC-00980/001/00 


function Line (File : in File_Type) return Positive.Count; 
function Line return Positive_Count; 

function Page (File : in File.Type) return Positive_Count; 
function Page return Positive.Count; 

— Character Input-Output 

procedure Get (File : in File.Type; 

Item : out Character); 
procedure Get (Item : out Character); 

procedure Put (File : in File_Type; 

Item : in Character); 

procedure Put (Item : in Character); 

-- String Input-Output 

procedure Get (File : in File.Type; 

Item : out String); 

procedure Get (Item : out String); 

procedure Put (File : in File_Type; 

Item : in String); 

procedure Put (Item : in String); 

procedure Get_Line (File : in File^Type; 

Item : out String; 

Last : out Natural); 

procedure Get.Line (Item : out String; 

Last : out Natural); 

procedure Put_Line (File : in File_Type; 

Item : in String); 

procedure Put_Line (Item : in String); 

— Instantiated generic package for Input-Output of Integer Types 
Ace_Integer_Io is a hand-instantiated Integer.Io package. 

package Ace_Integer_Io is 

Default_Width : Field := 10; 

Default^Base : Number_Base :* 10; 

procedure Get (File : in File.Type; 


Page 'M 









29 October 1990 


STARS-RC-009S0/001/00 


Item : out Integer; 
Width : in Field := 0); 


procedure Get (Item : out Integer; 

Width : in Field := 0); 

procedure Put (File : in File_Type; 

Item : in Integer; 

Width : in Field :* Default.Width; 

Base : in Number_Base := Default_Base); 

procedure Put (Item : in Integer; 

Width : in Field := Default_Width; 

Base : in Number_Base := Default_Base); 


procedure Get (From : in String; 

Item : out Integer; 

Last : out Positive); 

procedure Put (To ; out String; 

Item : in Integer; 

Base : in Number.Base := Default_Base); 
end Ace_Integer_Io; 
end Text_Io; 

7.1.8 Ace_Standard 

In addition to the Ada package "Standard", ACE contains an 
additional set of objects and operations that are standard for ACE. 

package Ace_Standard is 

subtype Interpreter.String is Ace_String; 
subtype File_System_String is Ace.String; 
subtype Data_String is Ace.String; 
subtype Host_0s_String is Ace.String; 

type List.Mode is (Both, Specification, Implementation); 
type Method_0f.Execution is (Foreground, Background); 


Pago 25 





29 October 1990 


STA RS- RC-009S0/001 / 00 


These should remain in Text_Io, since File_Type 
should be a limited private type. 

package Ace.Io is 
use Text_Io; 

procedure Set_Ace_Input (File : in File_Type); 
procedure Set_Ace_Gutput (File : in File_Type); 
function Standard_Ace_Input return File.Type; 
function Standard_Ace_0utput return File_Type; 
function Current_Ace_Input return File.Type; 
function Current_Ace_Output return File_Type; 

end Ace_Io; 

end Ace_Standard; 


7.1.9 Strings 

Temporary string operations that perform slices, 
package Strings is 

function Slice (Str : in String; 

Start.Pos : in Integer; 

Stop_Pos : in Integer) return String; 

function Slice (Str : in String; 

Pos : in Integer) return Character; 

function Length (Str : in String) return Integer; 

end Strings; 


7.2 Command Language Commands 

The following packages provide operations that are similar to the expected commands pro¬ 
vided by most command languages (i.e., Set^Dircctory). 


Page 36 






2!) October 1990 


STARS-RC-00980/001/00 


7.2.1 Ace_Adt 

Ace_Adt provides an interface to the interpret in the ACE system. 

package Ace_Adt is 
use Text.Io; 
use Objects; 

type Ace.Statement.Database is new Object.Type; 

This routine will "compile" a string into the statement 
database form. 

procedure Compile (Str : in String; 

Tree : in out Ace.Statement.Database; 

Error : out Boolean); 

This routine will "compile" a file into the statement 
database form. 

procedure Compile (File : in File.Type; 

Tree : in out Ace.Statement.Database; 

Error : out Boolean); 

This routine will delete the statement database tree associated 
with "tree". 

procedure Delete (Tree : in Ace.Statement.Database); 

Interpret will "execute" the tree associated with the parameter 
"tree". 

procedure Interpret (Tree : in Ace.Statement.Database; 

Error : out Boolean) ; 


Interpret will "execute" the value of the Str parameter, 
procedure Interpret (Str : in String; 

Error : out Boolean); 

Interpret will "execute" the contents of a file, 
procedure Interpret (File : in File.Type; 

Error : out Boolean); 

Interpret will "execute" the tree associated with the parameter 
"tree". 

procedure Interpret (Tree : in Ace.Statement.Database) ; 
Interpret will "execute" the value of the Str parameter. 

procedure Interpret (Str : in String); 

Interpret will "execute" the contents of a file, 
procedure Interpret (File : in File.Type); 


Page 37 








29 October 1990 


STARS-RC-00980/001/00 


Interpret_File will "execute" the contents of a file. 

procedure Interpret_File (File : String); 
end Ace_Adt; 


7.2.2 Host_Os 

"Host_0s" provides the interface to the underlying operating 
system on which ACE is executing. 

package Host_0s is 

Host provides an escape to the host operating system. The 
text of the "Command" parameter will be passed to the command language 
processor of the host operating system. Arguments to the command may 
be passed, as well as an indication whether ACE should wait for the 
completion of the command. 

procedure Host (Command : in Host.Os.String; 

Command.Arguments : in Host.Os.String := 

How : in Method.of.Execution := Foreground); 


end Host.Qs; 

7.2.3 Manipulate_Scope 

"Manipulate.Scope" contains routines which allow the scope of 
objects to be manipulated within ACE. These routines support the 
dynamic removal of existing objects and the availability to "undo" the 
Ada "Use" statement. 

package Manipulate.Scope is 


Procedure "Delete” removes an object from the ACE environment. 

This allows objects to be removed and a new defintion of the object to 
be reintroduced into ACE. The Form parameter also allows overloaded 
names to be uniquely identified. 

procedure Delete (Name : in Interpreter.String; 

Form : in Interpreter.String := ""); 

— [TBD] NOT YET IMPLEMENTED 

— procedure Undelete (Name : in Interpreter.String; 

Form : in Interpreter.String); 


Page 38 







29 October 1990 


STARS-RC-009S0/001 /00 


— procedure Undelete (Name : in Interpreter_String); 


Procedure "Deuse" performs an "undo" for the Ada "Use" statement. 

The names given direct visibility are no longer directly visible. 

NOTE: an item from another package that was hidden due to USE-ing this 
package will not automatically be made visible. 

procedure Deuse (Package.Name : in Interpreter.String; 

Form : Interpreter_String := ""); 

end Manipulate.Scope; 


7.2.4 Debugger 

The debugger package provides routines to symbolically view the 
execution of programs. 

package Debugger is 

This procedure will list the contents of the entire 
statement database (i.e., every object declared in the 
environment). 

procedure List_Symbol_Table (List.Kind : in List_Mode := Specification); 

This procedure will list the object that has been associated 
with the "name" parameter. The List.Kind parameter cam be 
use to list the implementation or specification of the object, 
and the Form parameter can be used to identify an overloaded 
subprogram. 

procedure List (Name : in Interpreter.String; 

List.Kind : in List.Mode := Specification; 

Form : in Interpreter.String := ; 

This procedure will list the specification of the 
object that has been associated with the "name" parameter. 

The Form parauneter can be used to identify an overloaded 
subprogram. 

procedure List (Name : in Interpreter.String; 

Form : in Interpreter.String :* ; 


List.Breakpoints will list all the break points that are 
currently active. 

procedure List.Breakpoints; 


Page 39 






29 October 1990 


STARS-RC-009S0/001/00 


Break will temporarily suspend execution for debugging, 
procedure Break; 

Continue will begin execution after a Break statement was encountered 
procedure Continue; 

Step will execute a statement after a break statement was encountered 
procedure Step (Count : Positive := 1); 

Set_Break will place a break point on the appropriate Statement_Number 
procedure Set_Break (Statement.Number : in Integer); 

Set_Break will place a break point on the appropriate Subprogram 
procedure Set_Break (Name : in Interpreter_String); 

Set_Break will place a break point on the current Statement 
procedure Set.Break; 

Clear.Break will remove a break point on the appropriate Statement_Number 
procedure Clear_Break (Statement.Number : in Integer); 

Clear_Break will remove a break point on the appropriate Subprogram 
procedure Clear_Break (Name : in Interpreter_String); 

Clear_Break will remove a break point on the current statement 
procedure Clear_Break; 

Display will list the current statement 

procedure Display (Statement_Number : in Integer); 

Display will list the first statement associated with a 

subprogram upon which a breakpoint may be set. 

procedure Display (Name : in Interpreter.String); 

Display will list the current statement, 
procedure Display; 

Display_Current_Statement will list the current statement, 
procedure Display_Current_Statement; 

Display_Next will list the next executable statement 

procedure Display.Next (Statement.Number : in Integer); 

Display.Next will list the next executable statement 
procedure Display.Next; 

Display_Previcus will list the previously executed statement 
procedure Display.Previous (Statement.Number : in Integer); 

Display.Previous will list the previously executed statement 
procedure Display_Previous; 


Page 40 






29 October 1990 


STARS-RC-009S0/001 /00 


end Debugger; 


7.2.5 FilejSystem 

This package is the basic definition of the ACE file system. 

All other file system packages will be derived from this one (i.e., 
they will use this package—directly or indirectly—and derive types 
from the basic type "File.Object"). 

package File_System is 
use Objects; 
use Text_Io; 

-- File_Object is the basic representation of an Object (or File) 
— ACE. 

type File_0bject is new File_Type; 

type Object_Mode is (ln_0bject, Out.Object); 


— by every derived type of File_Qbject. 

-- Other commands can be declared 

— Using this technique we can define the entire file 

— system for ACE as Ada declarations. 

Generate a temporary name. 

function Temporary_Name return String; 

Thu procedure copies the contents from one file to the other file, 
procedure Copy (From : in File_0bject; 

To : in File_0bject) ; 

This procedure copies the contents from one file to the other file, 
procedure Copy (From : in File_System_String; 

To : in File_System_String); 

This procedure deletes an object from the file system, 
procedure Delete.File (Obj : in File_System_String); 

This procedure changes the name associated with a file, 
procedure Rename (From : in File_0bject; 

To : in File_Qbject); 

This procedure changes the name associated with a file. 


in 


Page 11 









29 October 1990 


STARS-RC-00980/001/00 


procedure Rename (From : in File_System_String; 

To : in File_System_String); 

This function returns the boolean value "True" if a file exists 
within the current working directory. 

function Exists (Obj : in File_System_String) return Boolean; 


This procedure creates a new persistent file object with the 
specified name. If no name is given, an arbitrary name will be 
generated. 

procedure Create (Obj : in out File_Qbject; 

Mode : in Object.Mode := Out.Object; 

Name : in File_System_String := ""; 

Form : in Host_0s_String := ""); 

This procedure associates a file object with the persistent 
object having the specified name. 

procedure Open (Obj : in out File.Object; 

Mode : in Qbject.Mode; 

Name : in File_System_String; 

Form : in Host.Os.String :* ""); 

This procedure resets the specified file object, possibly 
changing the mode associated with it. 

procedure Reset (File : in out File.Object; 

Mode : in Object.Mode); 

This procedure resets the specified file object, 
procedure Reset (File : in out File.Object); 

end File.System; 


7.2.6 Directory .Objects 

Directory-Objects provides operations on directories 

package Directory-Objects is 
use File-System; 

-- There needs to be a universal naming scheme for identifying 
— directories (e.g., 

type Directory-Object is new File.Object; 


Page 42 









29 October 1990 


STARS-RC-009S0/001/00 


This procedure creates a new directory object with the specified 
name. If a name is not given, an arbitrary name will be generated 
procedure Create (Directory : in out Directory.Object; 

Name : in File_System_String; 

Form : in Host_Qs_String := 

This procedure associates an object with the directory object 
procedure Open (Directory : in out Directory.Object; 

Name : in File_System_String; 

Form : in Host_0s_String := 

This procedure disassociates am object from the directory object 
procedure Close (Directory : in out Directory_Object); 


This function returns the name of the specified directory object 
function Name (File : in Directory.Object) return String; 

This function returns the form string of the specified directory object 
function Form (File : in Directory.Object) return String; 

This function returns the file status of the specified directory object 
function Is.Open (File : in Directory.Object) return Boolean; 

This function returns the user's home directory 
function Home.Directory return Directory.Object; 

This function returns the user’s current working directory 
function Current.Directory return Directory.Object; 

This procedure lists the contents of the specified directory object 

procedure List (Directory : in Directory.Object := Current_Directory); 

This procedure changes the current working directory to the 

specified directory object, or the specified file system directory 

procedure Set.Directory (Directory : in Directory.Object := Home.Directory); 

This procedure changes the current working directory to the 

specified directory object, or the specified file system directory 
procedure Set.Directory (Directory : in File.System.String); 

This procedure displays the current working directory 
procedure Put.Current.Directory; 

end Directory.Objects; 


Page 43 








29 October 1990 


STARS-RC-00980/001/00 


7.2.7 Text.Objects 

Text_Qbjects provides operations on text files. 

package Text_Objects is 
use File.System; 

type Text.Object is new File.Object; 
type History.Mode is (New_File, 01d_File); 

This procedure displays the contents of a text file, either by 
specifying the text object 

procedure List (Text : in Text_0bject); 

This procedure displays the contents of a text file, either by 
specifying the file system name of the text file 

procedure List_File (Text : in File_System_String); 

— This routine should be List not List_File, 

— but until we have expanded names this will have 

— to do. 


This procedure invokes the system editor upon the specified text file 
procedure Edit (Text : in out Text.Object; 

How : in Method_0f.Execution := Foreground); 

This procedure invokes the system editor upon the specified text file 
procedure Edit_File (Text : in File_System_String; 

History : in History_Mode := 01d_File; 

How : in Method.Of.Execution := Foreground); 

— These routines should be Edit not Edit.File, 

— but until we have expanded names this will have 

— to do. 

This procedure will print the specified file on the standard 
default printer 

procedure Print (Text : in Text.Object); 

This procedure will print the specified file on the standard 
default printer 

procedure Print (Text : in File.System.String); 

This procedure will put the textual Ada code that is associated 
with the ACE persistent object (Interpreter.String) into the specified 
file name. 

procedure Put.File (Object : in Interpreter.String; 


Page 14 






29 October 1990 


STARS-RC-00980/001 /00 


Forir : in Interpreter.String; 

File.Name : in File_System_String) ; 

This procedure will put the textual Ada code that is associated 
with the ACE persistent object (Interpreter_String) into 
a default file that will have a file name identical to the name of 
the ACE obj ect. 

procedure Put_File (Object : in Interpreter.String; 

Form : in Interpreter.String := 

This procedure will cause ACE to read textual input from the 
specified file, rather than from Ace_Standard_Input (see 
Ace_Standard.Ace_Io package), until the end of file is reached, 
procedure Get_File (File_Name : in File.System.String); 

end Text_0bjects; 


7.2.8 Program_Objects 

Program_Objects provides operations for text files that contain 
Ada code. 

package Program_Objects is 
use File.System; 
use Text_0bjects; 
use Ace_Adt; 


"Program_Text" represents files that contain Ada code, 
type Program.Text is new Text.Object; 

"Format.Text" represents files that are formatted, such as 
program listings. 

type Format.Text is new Text.Object; 

"Data.Text" can represent any ASCII file, 
type Data.Text is new Text.Object; 

This procedure submits the specified program text to an Ada 
compiler with the Form string being passed to the Ada compiler, 
procedure Compile (Program : in Program.Text; 

Form : in Host.Os.String := ""); 

This procedure submits the specified program text to an Ada 
compiler and linker, identifying the name of the main unit and the 
executable code file. 


Page 15 






29 October 1990 


STARS-RC-009S0/001 /GO 


procedure Compile (Program : in Program.Text; 

Main_Unit : in Data_Stnng; 

Host_Binary_Name : in File_System_Strmg); 

This procedure submits the specified file containing Ada co^i 
to an Ada compiler 

procedure Compile (Program : in File_System_String; 

Form : in Data.String :■ ""); 

This procedure submits the specified program text to an Ma. 
compiler and linker, identifying the name of the main unit and 
executable code file. 

procedure Compile (Program : in File_System_String; 

Main_Unit : in Data_String; 

Host.Binary.Name : in File_System_String); 

This procedure edits the ACE item ("Name"), where the Form parameter 
is used to uniquely identify overloaded names, such as 
subprograms, with the ACE item also being stored in the program 
text file denoted by "Object". The item will be reinterpreted by 
the ACLI. 

procedure Edit_And_Interpret (Name : in Interpreter.String; 

Form : in Interpreter_String := 

Object : in out Program_Text); 

This procedure edits the ACE item ("Name"), where the Form parameter 
may be used to uniquely identify overloaded names, such as 
subprograms. The item will then be reinterpreted by the ACLI. 
procedure Edit.And.Interpret (Name : in Interpreter.String; 

Form : in Interpreter.String := ""); 


end Program_Objects; 


7.2.9 Program_Text_Objects 

Program.Text.Objects provides operations on program specs and bodies 
package Program_Text_Objects is 
use Program.Qbjects; 

"Spec.Program" represents files that contain Ada specifications, 
type Spec.Program is new Program.Text; 

"Body.Program" represents files that contain Ada implementations, 
type Body.Program is new Program.Text; 

end Program_Text_Objects; 


Page 46 








29 October 1990 


STARS-RC-00980/001/00 


7.2.10 Binary .Objects 

Bmary_0bjects provides operations on executable files. 

package Binary.Objects is 
use File_System; 

Binary.Object represents files that would contain any data such 
as program execuatbles, raster images, etc. 
type Binary.Object is new File.Object; 

Program.Binary is the compiled version of a Program.Text type, 
type Program_Binary is new Binary.Object; 

Format.Binary is formatted output that contains non-ASCII data, 
such as raster images. 

type Format.Binary is new Binary.Object; 

Data.Binary is any file that contains non-ASCII data and is 
neither a Program.Binary or Format.Binary file, 
type Data.Binary is new Binary.Object; 

This procedure has the host operating system 
specified program binary object, 
procedure Execute (Program 

Command.Line.Argument s 
procedure Execute (Program 

Command.Line.Arguments 

end Bmary.Objects; 

7.2.11 Program.Units 

Package "Program.Units" contains the defintion of ACE compilation 
units. Packages and subprograms are currently supported within ACE 
compilations units. This package provides the definition of the 
creation, deletion, open, close, mode, and is.open operations. 

package Program.Units is 
use Objects; 

type Package.Type is new Object.Type; 

type Subprogram.Type is new Object.Type; 

type Program.Unit.Mode is (In.Prog.Unit, Out.Prog.Unit); 


execute the 

: in Program.Binary; 

: in Data.String := "") ; 
: in File.System.String; 
: in Data.String := ""); 


Page IT 







29 October 1990 


STARS-RC-009S0/001/00 


procedure Create (Ace_Package : in out Package_Type; 

Mode : in Program_Unit_Mode := Qut_Prog_Umt; 

Name : in Interpreter_String := 

Form : in Interpreter.String := 

—procedure Create (Ace_Subprogram : in out Subprogram„Type; 

Mode : in Program_Unit_Mode := Out_Prog_Unit 

Name : in Interpreter.String := 

Form : in Interpreter_String := 

Procedure "Open" associates an existing package with a package object 
procedure Open (Ace_Package : in out Package_Type; 

Mode : in Program_Unit_Mode; 

Name : in Interpreter_String; 

Form : in Interpreter.String := 


Procedure "Open" associates an existing program with a 
subprogram object 

procedure Open (Ace_Subprogram : in out Subprogram_Type; 


Mode 

: in Program_Unit_Mode; 

Name 

: in Interpreter.String; 

Form 

: in Interpreter_String :* 

This procedure disassociates a 
resident within ACE 

package object with a package 

procedure Close (Ace_Package 

: in out Package_Type); 


This procedure disassociates a subprogram object with a package 
resident within ACE 

procedure Close (Ace.Subprogram : in out Subprogram_Type); 

This procedure removes the specified package object from the 
name space of ACE. 

procedure Delete (Ace.Package : in out Package.Type); 


This procedure removes the specified subprogram object from the 
name space of ACE. 

procedure Delete (Ace.Subprogram : in out Subprogram_Type); 

This function returns the mode of the specified package object 

function Mode (Ace.Package : in Package_Type) return Program_Unit_Mode; 


Page IS 








29 October 1990 


ST/ RS-RC-009S0/001/00 


This function returns the mode of the specified subprogram object 
function Mode (Ace_Subprogram : in Subprogram.Type) 
return Program_Unit_Mode; 

This function returns the name of the specified package object 

function Name (Ace_Package : in Package_Type) return Interpreter_Stri •; 

This function returns the name of the specified subprogram object 
function Name 

(Ace_Subprogram : in Subprogram_Type) return Interpreter.String; 

This function returns the form of the specified package object. 

The form is the statement number associated with the package. 

function Form (Ace_Package : in Package_Type) return Interpreter_String; 

This function returns the form of the specified subprogram object. 

The form is the statement number associated with the Subprogram, 
function Form 

(Ace_Subprogram : in Subprogram_Type) return Interpreter_Strmg; 

This function returns the open status of the specified package object 
function Is.Open (Ace_Package : in Package.Type) return Boolean; 

This function returns the open status of the specified 
subprogram object 

function Is.Open (Ace_Subprogram : in Subprogram_Type) return Boolean; 

This procedure performs an "undo" of the Ada "use" statement. 

The names given direct visibility by the "use" starement will no 
longer be directly visible. 

note: An item from another package that was hidden due to using 
the package will not automatically be made visible, 
procedure Deuse (Ace_Package : in Package_Type); 

The location type specifies whether the subprogram is only to 
be moved into the package specification or into the package body, 
type Location_Type is (In.Spec, In.Body); 

The visibility type specifies whethe 1- the the subprogram object 
is to be visible (moved into the visible portion of the package 
spec) or hidden (moved into the private portion of the package spec). 
type Visibility.Type is (Visible, Hidden); 


"Put" will put the textual Ada code that is associated 
with the ACE persistent object (Subprogram.Item) into 


Pago 19 





29 October 1990 


STARS-RC-00980/001/00 


the specified package. 

procedure Put (Subprogram.Item : in Subprogram.Type; 

Into_Package : in Package_Type; 

Location : in Location_Type; 

Visibility : in Visibility.Type); 

"List" displays the package object. The "List_Method" controls the 
portion of the package listed: spec, body, or both, 
procedure List (Ace_Package : in Package.Type; 

List_Method : in List.Mode := Both); 

"List" displays the subprogram object. The "List_Method" controls the 
portion of the subprogram listed: spec, body, or both, 
procedure List (Ace.Subprogram : in Subprogram.Type; 

List.Method : in List.Mode := Both); 


end Program.Units; 


7.2.12 Help_Adt 

The Help.Adt provides operations to aid the user. Type 
"Help;" to learn more about the help subprogram. 

package Help.Adt is 

The Help command provides the user with on-line assistance for 
declared objects in ACE: packages, subprograms, and types. 

These objects may be associated with help comments, which are 
denoted by the PDL-like "— r? ". When invoked, this command displays 
the text of the help comment associated with the object (NAME). 

The form parameter is used to uniquely identify overloaded names. 

procedure Help (Name : Interpreter.String := "Help"; 

Form : Interpreter.String := ""); 


end Help.Adt; 


7.2.13 ObjectJLister 

Qbject.Lister provides operations that allow users to browse the 
defined constructs in ACE. 

package Object.Lister is 


Page 50 






29 October 1990 


STARS-RC-00980/001/00 


type Qb]ect_Declarations is 
(Any, 

Obj s, 

Type_Marks, 

Types, » 

Subtypes, 

Subprograms, 

Packages, 

Procedures, 

Functions, 

Labels); 

procedure List will display the names of environment objects that 
are currently visible. One can focus the report on a particular object 
procedure List (Object_Type : Object.Declarations; 

Specifier : Interpreter_String := ""); 


end Object.Lister; 


7.3 Key Bindings 

The following packages provide operations to bind arbitrary keystrokes to editing and history 
functions. 


7.3.1 Key_Bindings 

Key.Bindings provides operations to bind arbitrary keystrokes 
to editing and history functions. 

package Key.Bindings is 

type Commands is 
(Error, 

Unbound, 

Line.Separator, 

Interpret.String, 

History.Back, 

History.Forvard, 

Move.Left, 

Move.Right, 

Beginning.Of.Line, 

End.Of.Line, 

Start.Of.History, 


Page 5 1 




29 October 1990 


STARS-RC-00980/001/00 


End.Of.History, 

Delete, 

Delete.This.Char, 

Shou.History, 

Set.History.Limit, 

Show.History.Limit, 

Kill.Line, 

Quoted.Insert, 

Refresh.Current.Line, 

Refresh.Current.Line.and.Prompt, 
Rewrite.Current.Line, 
Rewrite.Current.Line.and.Prompt, 
Get.Current.Line, 

Get.Current.Charact er, 
Get.Current.Column, 

Insert.String, 

Self.Insert); 


Bind an input string to 
available commands are: 
Unbound 
Line.Separator 
Interpret.String 
History.Back 
History.Forward 
Move.Left 
Move.Right 
Beginning.Of.Line 
Start_0f.History 
End.Of.History 
Show.History 
Delete 

Delete.This.Char 
Self.Insert 
Show.History.Limit 
Set.History.Limit 
Kill.Line 
Quoted.Insert 

Refresh.Current.Line 
Refresh.Current.Line. 
Rewrite.Current.Line 
Rewrite.Current.Line. 


a history or editing command; 

(used to remove an existing binding) 

End-of-line symbol for input 
Interpret arbitrary Ada code 
Show previous command 
Show next command 
Move cursor left (backspace) 

Move cursor right 

Move cursor to beginning of line 

Show oldest command 

Show most recent command 

Show complete command history 

Delete character to left of cursor 

Delete character under cursor 

Insert character corresponding to keystroke 

Show the number of lines being saved in history 

Change the number of lines being saved in history 

Delete the entire line 

For the next character received, do not look for 
a binding, just insert it into the line 
refresh the portion of the line following the prompt 
.And_Prom.pt refresh the entire line 

replace the current line with the argument 
.And.Prompt write the prompt, followed by the argument 
on the next physical line 


Page ")2 











2!) October 1990 

STARS-RC-009S0/001/00 

• 

Get_Current.Line 

argument will hold the current input 

Get.Current.Character 

argument will hold the current character, or 
ascii.nul if the cursor is at the end of the line 


Get.Current.Column 

argument is the 1-based position of the cursor 


Insert.String 

insert argument into current line at current position 


procedure Make.Binding 

(Char.Seq : in String; 

Binding : in Commands; 

Optional.String : in String := ""); 


Bind an input character to 
available commands are: 

a history or editing command; 


Unbound 

(used to remove an existing binding) 


Line.Separator 

End-of-line symbol for input 


Interpret.String 

Interpret arbitrary Ada code 


History.Back 

Show previous command 


History.Forward 

Show next command 


Move.Left 

Move cursor left (backspace) 


Move.Right 

Move cursor right 


Beginning.Of.Line 

Move cursor to beginning of line 


Start.Of.History 

Show oldest command 

• 

End.Of.History 

Show most recent command 


Show.History 

Show complete command history 


Delete 

Delete character to left of cursor 


Delete.This.Char 

Delete character under cursor 


Self.Insert 

Insert character corresponding to keystroke 


Show.History.Limit 

Show the number of lines being saved in history 


Set.History.Limit 

Change the number of lines being saved in history 


Kill.Line 

Delete the entire line 


Quoted.Insert 

For the next character received, do not look for 
a binding, just insert it into the line 


Refresh.Current.Line 

refresh the portion of the line following the prompt 


Refresh.Current.Line.And.Prompt refresh the entire line 1 


Rewrit e.Current.Line 

replace the current line with the argument 1 


Rewrite.Current.Line.And.Prompt write the prompt, followed by the argument 

on the next physical line 


Get.Current.Line 

argument will hold the current input 


Get.Current.Character 

argument will hold the current character, or 
ascii.nul if the cursor is at the end of the line 


Get.Current.Column 

argument is the 1-based position of the cursor 


Insert.String 

insert argument into current line at current position 

• 


procedure Make.Binding 

(C : in Character; 



Pago 53 







29 October 1990 


STARS-RC-009S0/001/00 


Binding : in Commands; 

Optional_String : in String := 


— Commands 

String is the name of a procedure to be invoked 
procedure Interpret_String (Str : String); 

Display previous command, that is, the next oldest command 
from the current history position; if this position is the 
top of the command history, this procedure does nothing 
procedure History_Back; 

Display next command, that is, the next most recent command 
from the current history position; if this position is the 
bottom of the command history, this procedure does nothing 
procedure History_Forward; 

Move cursor left (i.e., backspace); if the cursor is already 
at the beginning of the input line, this procedure does nothing 
procedure Do_Move_Left; 

Move cursor right; this procedure will only move the cursor 
as far as one position to the right of the last input character 
procedure Do.Move.Right; 

Move cursor to beginning of (input) line 
procedure Do_Goto_Beg_0f_Line; 


Move the cursor to the end of the line; 
procedure Do_Goto_End_0f_Line; 

Show oldest command in the command history 
procedure Do_Goto_Start_0f.History; 

Show most recent command in the command history 
procedure Do_Goto.End.0f.History; 

Show complete command history 
procedure Do.Show.History; 


Page 54 






29 October 1990 


STA RS- RC-00980/ 001 /00 


Delete character to left of cursor 
procedure Do_Delete; 

Delete character under cursor 
procedure Do_Delete_This_Char; 

Insert character corresponding to keystroke; 
procedure Do_Self.Insert; 

Delete the entire line 
procedure Do_Kill_Line; 

Insert a string passed in Str; 

procedure Do_Insert_String (Str : String); 

Show the user the number of lines saved for the command history 
procedure Do.Show.History.Limit; 

Reset the number of lines of command history to be saved (based on user input) 
procedure Do_Set_History_Limit; 

Insert the next character typed into the current line as is 
procedure Do.Quoted.Insert; 

clear, then rewrite the current line, not including the prompt 
procedure Do.Refresh.Current.Line; 

(cursor should already be positioned at the beginning of a line) writes 

out the prompt and current line; 

procedure Do.Refresh.Current.Line.And.Prompt; 

kill the current line and replace it with Line, not including the prompt; 
procedure Do_Rewrite_Current_Line( Line : String); 

(cursor should already be positioned at the beginning of a line) kills the 

current line and replaces it with Line, writing out both the prompt and Line 
procedure Do.Rewrite.Current.Line.And.Prompt ( Line : String); 

returns the current line of input 

procedure Do.Get.Current.Line (Line : out String; Length : out Natural); 


returns the character on which the cursor is positioned 
function Do.Get.Current.Character return Character; 


Page •')") 





29 October 1990 


STARS-RC-00980/001/00 


returns the 1-based number of the column the cursor is in 
function Do_Get_Current_Column return Natural; 

end Key_Bindings; 


7.4 Windowing Commands 

The following packages provide a simplified interface to a small subset of the X Window 
System. 


7.4.1 Window_Objects 

This package defines the objects that are associated with the 
Windows abstract data type. 

package Window_0bjects is 

use Objects; 

type Window_Type is new Qbject_Type; 

type Coordinate is new Integer; 
type Pixels is new Integer; 

end Window_Objects; 


7.4.2 Ace_X_Window_System 

Package "Ace_X_Window_System" defines the ACE abstraction to the 
X window system. This package is intended for experienced windowing 
system programmers. X Window system version 11, release 2 is the 
supported version. 

package Ace_X_Window_System is 

use Window_0bjects; 

This procedure creates a window at the specified position with 
the given size and associates the window with a window object, 
procedure Create_Window 

(Window : in out Windov_Type; 

Horizontal_Position : in Coordinate; 


Page 06 







29 October 1990 


STA RS-RC-00980/001 /00 


Vertical.Posit ion : in Coordinate; 

Horizontal_Size : in Pixels; 

Vertical_Size : m Pixels); 

This procedure destroys the window associated with the window object, 
procedure Destroy_Window (Window : in out Window_Type); 

This procedure clears the window object by painting the window 
with the window’s background color. 

procedure Clear.Window (Window : in out Window_Type); 

end Ace_X_Window_System; 


7.4.3 Ace_User_X_Window_System 

This package defines a simplified ACE windows system 

abstraction to the X window system. The operation nomenclature within 
this package adheres to Ada paradigms, rather than to the X window 
system paradigms. This package is intended for novices to windowing 
systems and novices to the X window system. X Window System version 
11, release 3 is the supported version. 

package Ace_User_X_Window_System is 

use Window.Objects; 
use Ace_X_Window_System; 

This procedure creates a window at the specified position with 
the given size and associates the window with a window object, 
procedure Create (Window : in out Window_Type; 

Horizontal.Position : in Coordinate; 

Vertical.Position : in Coordinate; 

Horizontal.Size : in Pixels; 

Vertical_Size : in Pixels) ; 

This procedure destroys the window associated with the window object, 
procedure Delete (Window : in out Window_Type); 

This procedure clears the window object by painting the window 
with the window’s background color. 

procedure Reset (Window : in out Window_Type); 

end Ace_User_X_Window_System; 


Page 57 








29 October 1990 


STARS-RC-009S0/001/00 


7.4.4 Window JDraw_Routines 

"Window_Draw_Routines" provides a simple set of drawing 
operations that may be performed in window objects. The routines 
rely upon the X window system and therefore should only be use when X 
is running. 

package Window_Draw_Routines is 

use Window_Objects; 
use Ace_X_Window_System; 


"Draw_Line" draws a line within the window object from the 
coordinates (xl, yl) to (x2, y2) 

procedure Draw_Line (Window : in Window_Type; 

XI, Yl, X2, Y2 : in Coordinate); 

"Draw_Dashed_Line" draws a dashed line within the window object 
from the coordinates (xl, yl) to (x2, y2) 

procedure Draw_Dashed_Line (Window : in Window.Type; 

XI, Yl, X2, Y2 : in Coordinate); 

"Draw_Text" draws the text string within the current window 
object left justified from the coordinate (x, y) 
procedure Draw_Text (Window : in Window_Type; 

X, Y : in Coordinate; 

Text : in String); 

"Draw_Rectangle" draws a rectangle within the window object with 
the upper left corner positioned at coordinate (X, Y) and of the 
specified width and height in pixels 

procedure Draw.Rectangle (Window : in Window.Type; 

X, Y : in Coordinate; 

Width, Height : in Pixels); 

"Draw_Rectangle_Builtin" draws a rectangle within the window object with 
the upper left corner positioned at coordinate (X, Y) and of the 
specified width and height in pixels 
procedure Draw.Rectangle.Builtin 

(Window : in Window.Type; 

X, Y : in Coordinate; 

Width, Height : in Pixels); 


end Window_Draw_Routines; 


Page 58 







29 October 1990 


S TA RS- RC -00980/001/00 


7.5 CAIS-A Commands 

The following packages provide AC E s interlace to the underlying CAIS-A s\stem. 


7.5.1 CAIS_Routines 


Package CAIS_Routines provides operations to view and move around 
the CAIS-A node model, to invoke and spawn CAIS-A processes, 
and to build string representations of CAIS-A argument lists. 

package Cais_Routines is 


type Cais_Node_Kinds is 
(Structural_Nodes_0nly, 

File_Nodes_0nly, 

Process_Nodes_0nly, 

All_But_Structural_Nodes, 

All_But_File_Nodes, 

All_But_Process_Nodes, 

All_Cais_Node_Kinds); 

type Cais_Relationship_Kinds is 
(Primary_Relationships, 

Secondary.Relationships, 

Both.Relationship.Kinds); 

subtype Cais_Arg_List_Str_Rep is Ace.String; 

Procedure spawn_process will use the CAIS to create a process 
node in the CAIS node model and start the process running 
in the background. 

procedure Spawn_Process (Node_Path : in Host_0s_String; 

Parameters : in Host_0s_String := 

Procedure invoke_process will use the CAIS to create a process 
node in the CAIS node model and execute the process, returning 
results in the Results parameter. 

procedure Invoke_Process (Node_Path : in Host_0s_String; 

Parameters : in Host_0s_String := 
Results : out Host_0s_String); 

Procedure set_current_CAIS_node will change the CURRENT.NODE in 

Page 59 





29 October 1990 


STARS-RC-009S0/001/00 


the CAIS node model to the node whose path name is passed in. 

procedure Set_Current_Cais_Node (Node.Path : in File_System_String); 

Procedure current_CAIS_node returns a string representation 
of the primary pathname of the CURRENT.NODE in the CAIS-A node 
model. 

procedure Put.Current_Cais_Node; 

Procedure put_CAIS_node_relationships displays some or all of the 
relationships emanating from the CURRENT.NODE in the CAIS node model 
procedure Put_Cais_Node_Relationships 

(Relation : in Host_Os_String := 

Key : in Host_Os_String := 

Rel.Kinds : in Cais_Relationship_Kinds := Both.Relationship.Kinds; 

Node.Kinds : in Cais_Node_Kinds := All_But_Process_Nodes); 


Procedure put_CAIS_file_node_host_name displays the host 
operating system's file name for the CAIS-A file node found 
at node model pathname passed in. This file name is the file 
name of the file within the CONTENTS directory of the CAIS-A database, 
procedure Put_Cais_File_Node_Host_Name 

(Node.Path : in File.System.String := "■’CURRENT.NODE”); 

Function Create_Cais_Argument_List builds a string representation 
of a CAIS argument list using the string item passed in as the sole 
item in the returned CAIS argument list string representation. 

function Create_Cais_Argument_List (Str : in Ace.String) return 
Cais_Arg_List_Str_Rep; 

Function Append_To_CAIS_Arg_List appends the string item passed in 
to the CAIS argument list string representation also passed, and 
returns the resulting string representation of a CAIS list. 

function Append_To_Cais_Arg.List (List : in Cais_Arg_List_Str_Rep; 

Str : in Ace.String) return 

Cais_Arg_List_Str_Rep; 

Function Prefix_To_CAIS_Arg_List prefixes the string item passed in 
to the CAIS argument list string representation also passed, and 
returns the resulting string representation of a CAIS list. 

function Prefix_To_Cais_Arg_List (List : in Cais_Arg_List_Str_Rep; 

Str : in Ace.String) return 

Cais_Arg_List_Str_Rep; 
end Cais.Routines; 


Rage (iO 










29 October 1990 


STARS-RC-009S0/001/00 


7.5.2 STARS .Tools 

Package STARS_Tools contains the interfaces to the Unisys Q task 
tools integrated with the ACE/CAIS-A Baseline SEE. These include 
the Q13 Ada source code metrics tools, the Q14 Diana IDL tools, 
and the Q10 test tool suite. 

package Stars.Tools is 

Procedure Check_Style invokes the modified Q13 Style Checker. 

The tool takes its input and output files as parameters. 

If no input file is provided, the user is prompted for its name. 
Output defaults to a file named "Style_Report." 

procedure Check_Style (File_To_Check : in File.System.String := 

Flaws_File : in File_System_String := 

"Flaws_Report"; 

Style_File : in File_System_String := 

"Style_Report"; 

How : in Method_of.Execution := 

Foreground); 


Procedure Count.Features invokes the Q13 feature counting tool. 

The tool takes its input and output files as parameters. 

If no input file is provided, the user is prompted for its name. 

Output defaults to a file named "Features.Report." 

procedure Count.Features (File.To.Count : in File.System.String : = 

Results.File : in File.System.String := 
"Features.Report"; 

How : in Method.of.Execution := 

Foreground); 


Procedure Count.Statements invokes the Q13 statement counting tool. 
The tool takes its input and output files as parameters. 

If no input file is provided, the user is prompted for its name. 
Output defaults to a file named "Statements.Report." 

procedure Count.Statements (File.To.Count : in File.System.String 

Results.File : in File.System.String 

"Statements.Report"; 


How : in Method.of.Execution 

Foreground) ; 


_ ii ii . 


Procedure Measure.Mccabe.Complexity invokes the Q13 tool which 
calculates the McCabe Complexity for a source file. 

The tool takes its input and output files as parameters. 


I’au*’ b 1 




29 October 1990 


STARS-RC-009S0/001/00 


If no input file is provided, the user is prompted for its name. 

Output defaults to a file named "Mccabe.Report." 
procedure Measure_Mccabe_Complexity 

(File.To.Measure : in File_System_String := 

Results.File : in File_System_String := "Mccabe.Report"; 

How : in Method_of.Execution :* Foreground); 

Procedure Diana.Browser invokes the Q14 Diana IDL Library Unit Browser. 

It takes the name of the unit to browse as an argument, and an optional 

"-b" which has the Browser display bodies as well as specifications, 
procedure Diana.Browser (Unit : in Ace.String; 

Options : in Ace.String := ; 

Procedure Diana.Front_.End invokes the Diana IDL Front End Processor. 

It takes an Ada source filename to process as an argument, 
procedure Diana.Front.End (Source : Fil<- System.String); 

Procedure Diana.Mklib creates a new Diana unit library, 
procedure Diana.Mklib; 

Procedure Diana.Rmlib removes a Diana unit library, 
procedure Diana.Rmlib; 

Procedure Diana.Cleanlib resets a Diana unit library, 
procedure Diana.Cleanlib; 


Procedure Diana.Make.Predefined.Env builds the Diana IDL predefined 
environment. 

procedure Diana.Make.Predefined.Env; 

Procedure Diana.Create.Predefined.Env builds the Diana IDL 
predefined environment after the IDL has been modified. 

This procedure should only be run once, 
procedure Diana.Create.Predefined.Env; 

Procedure Test.Case.Generator invokes the Q10 test case generator, 
procedure Test.Case.Generator; 

Procedure Test.Results.Analyzer invokes the Q10 tool which analyzes 
the test case results. 

procedure Test.Results.Analyzer; 

Procedure Test.Procedures.Generator invokes the Q10 tool which 
generates testing procedures. 


ibigc 92 







29 October 1990 


STARS-RC-00980/001/00 


procedure Test.Procedures.Generator; 

Procedure Test.Comparator invokes the Q10 test comparator, 
procedure Test.Comparator; 

Procedure Test.Updater invokes the Q10 test updater, 
procedure Test.Updater; 

Procedure Set.Up invokes the Q10 routine to set up the environment, 
procedure Set.Up; 

end Stars.Tools; 


7.6 CPU Timing Package 

The following packages provide routines to measure and report CPU use. 


7.6.1 Cpu.Time 

Cpu.Time defines operations to determine the amount of CPU time 
used during a specific period, 
package Cpu.Time is 

type Time is new Integer; 

Clock returns the current CPU time 
function Clock return Time; 

Difference will return the amount of time between two clock points, 
function Difference (Stop.Time, Start.Time : Time) return Time; 

Put..Time will print the time out in a reasonable manner, 
procedure Put.Time (A.Time : in Time); 

end Cpu.Time; 


7.7 Xt Toolkit Interface 

1 he following packages provide an interface to a subset, of the Xt Toolkit, which is a sot of 
procedures for building applications of the X Window System. 






29 October 1990 


STARS-RC-00980/001/00 


7.7.1 X_Windows 
with Objects; 

Package X.Windows provides declarations of the basic X library 
data types needed to use the ACE interface to the Xt toolkit. 
The X windows library procedures supported by ACE will also be 
found here. 

Package X.Windows is 
use Objects; 

type Drawable is new Object_Type; 

type Context is new Object_Type; — 

type Visual is new Object_Type; 
type Screen is new Object_Type; 
type Display is new Object_Type; 

subtype Window is Drawable; 
subtype Pixmap is Drawable; 

type Pixels is new Integer; 
subtype Coordinate is Pixels; 
type Caddr.T is new System.Address; 

type String_Pointer is new Object_Type; 
type String_Pointer_Array is new Object.Type; 
type String.List is new Object.Type; 


— type String.Pointer is access String; 

-- type String_Pointer_Array is array (Natural range <>) of String.Pointer; 
-- type String_List is access String_Pointer_Array; 

package Fonts is 

type Font is new Object.Type; 

type Font_Direction is (Left_To_Right, Right.To.Left); 


type Font.Record is new Object.Type; 


Returns the Ascent field of its parameter. 

function Ascent (F : in Font.Record) return Pixels; 
pragma Builtin (Ascent, 2101); 


Page (VI 






29 October 1990 


STARS-RC-00980/001/00 


Returns the Descent field of its parameter. 

function Descent (F : in Font.Record) return Pixels; 
pragma Builtin (Descent, 2102); 

Returns the width of its Text parameter, in the 
font specified by the Font_Info parameter. 

function Text_Width (Font_Info : in Font.Record; 

Text : in String) return Pixels; 

pragma Builtin (Text.Width, 2103); 
end Fonts; 

type Gravity.Type is 
(Forget.Gravity, 

Northwest.Gravity, 

North.Gravity, 

Northeast.Gravity, 

West.Gravity, 

Center.Gravity, 

East.Gravity, 

Southwest.Gravity, 

South.Gravity, 

Southeast.Gravity, 

Static.Gravity); 

package Events is 

type Event is new Object.Type; 
end Events; 

package Resource.Manager is 

type Xrm.Option_Desc.List is new Object.Type; 
end Resource.Manager; 
end X.Windows; 

7.7.2 Renamed_Xlib_Types 
with X.Windows; 

Package Renamed.Xlib.Types defines the connection between some 
type names used by Xt routines and the equivalent type names 
in the basic X libary. 

package Renamed.Xlib.Types is 


Pago Go 







29 October 1990 


STARS-RC-009S0/001/00 


subtype Pixel is X_Windows.Pixels; 

subtype Xt.String is X_Windows.String_Pointer; 

subtype Xt_Stnng_List is X.Wmdows . String_Pointer_Array; 

subtype Xt_Stnng_List_Ptr is X_Windows . String_List; 

subtype Argv_Type is X_Windows.String_List; 

end Renamed.Xlib.Types; 


7.7.3 Intrinsics 
with Objects; 

with System; — 

with Renamed_Xlib_Types; 
with X.Windows; 

The package Intrinsics contains the type declarations common to 
all Xt toolkit routines, 
package Intrinsics is 
use Objects; 

type Cardinal is new Integer; 
type Short.Cardinal is new Integer; 

— type Cardinal is range 0 .. (2 ** 31 - 1); 

— type Short.Cardinal is range 0 .. (2 ** 16 - 1); 

subtype Position is X.Windows.Pixels; 
subtype Dimension is Short.Cardinal; 

type Widget is new System.Address; 
type Widget.Class is new System.Address; 

function Null.Widget return Widget; 

function Null_Widget_Class return Widget.Class; 

function Null_Caddr_T return X.Windows.Caddr.T; 

type Xt_App_Context is new System.Address; 

package Xt_Ancillary_Types is 

subtype Xt_Arg_Val is X.Windows.Caddr.T; 
type Xt.Arg is new Object.Type; 


Page 66 


29 October 1990 


STARS-RC- 00980/001/00 


— type Xt_Arg is 
record 

Name : Renamed_Xlib_Types . Xt_Stnng; 

Value : Xt_Arg_Val; 
end record; 

end Xt_Ancillary_Types; 
end Intrinsics; 

7.7.4 Widget_Package 

with Objects; 

with System; 

with Intrinsics; 

with X.Windows; 

with Renamed_Xlib_Types; 

This package offers a sample selection of Xt toolkit procedures. 

For detailed documentation on these routines, the user should 
consult Xt documentation. The names of the toolkit procedures, 
as given in the Xt documentation are the same as the names used 
here, but with the underscores removed. 

package V ,dget_Package is 
use Objects; 

function Null_Xnn_0ption_List 

return X.Windows.Resource.Manager.Xrm.Qption.Desc.List; 
pragma Builtin (Null.Xrm.0ption.List, 2201); 

— tyy a Xt_Arg_List is 

array (Integer range <>) of Intrinsics.Xt_Ancillary_Types.Xt_Arg; 

type X-._Arg_List is new Object .Type; 

function Null_Xt_Arg_List return Xt_Arg_List; 
pragma Builtin (Null_Xt_Arg_List, 2202); 

type Xt.Translations is new System.Address; 



Converts an Ada string to a string suitable for the Xt toolkit. 

function Make.Xt.String (S : in String) return Renamed.Xlib.Types.Xt.String; 
pragma Builtin (Make.Xt.String, 2203); 


Page 67 











29 October 1990 


STARS-RC-00980/001/00 


Ada version of the Xt toolkit routine Xtlnitialize. 
procedure Xt_Imtialize 

(Out.Value : out Intrmsics . Widget; 

Name : in String; 

Classname : in String; 

Urlist : in X_Windows.Resource_Manager.Xrm_Option_Desc_List; 

Num.Urs : in Intrinsics.Cardinal; 

Argc : in out Intrinsics.Cardinal; 

Argv : in out Renamed_Xlib_Types.Argv.Type); 

pragma Builtin (Xt.Initialize, 2204); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity.Type 

procedure Xt_Set_Arg (Arg : out Intrinsics.Xt_Ancillary_Types.Xt_Arg; 

Name : in String; 

Value : in Boolean); 
pragma Builtin (Xt_Set_Arg, 2205); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity.Type 


procedure Xt_Set_Arg (List 

in 

out Xt_Arg_List 

Subscript 

in 

Integer; 

Name 

in 

String; 

Value 

in 

Boolean); 


I’age 68 









29 October 1990 


STARS-RC-00980/001/00 


This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity_Type 

procedure Xt_Set_Arg (Arg : out Intrinsics.Xt.Ancillary_Types.Xt_Arg; 

Name : in String; 

Value : in String); 

pragma Builtin (Xt_Set_Arg, 2206); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity.Type 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in String); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity.Type 

procedure Xt_Set_Arg (Arg : out Intrinsics.Xt_Ancillary_Types.Xt_Arg; 


Page 69 






'29 October 1990 


STARS-RC-00980/001/00 


Name : in String; 

Value : in Integer); 
pragma Builtm (Xt_Set_Arg, 2207); 

This set of overloaded procedures provides a strongly typed, 
Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity_Type 


procedure Xt_Set_Arg (List 

: in 

out Xt_Arg_List; 

Subscript 

: in 

Integer; 

Name 

: in 

String; 

Value 

: in 

Integer); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity_Type 

procedure Xt_Set_Arg (Arg : out Intrinsics.Xt.Ancillary.Types.Xt_Arg; 

Name : in String; 

Value : in System.Address); 
pragma Builtin (Xt_Set_Arg, 2208); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 


Page 70 







29 October 1990 


STARS-RC-00980/001/00 


Dimension 

Position 

Gravity.Type 

procedure Xt_Set_Arg (List 

Subscript 

Name 

Value 


in out Xt_Arg_List; 
in Integer; 
in String; 
in System.Address); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity_Type 

procedure Xt_Set_Arg (Arg : out Intrinsics.Xt_Ancillary_Types.Xt_Arg; 

Name : in String; 

Value : in Intrinsics.Dimension); 
pragma Builtin (Xt_Set_Arg, 2209), 


This set of overloaded procedures provides a strongly typed, 
Aaa version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 
String 
Integer 
Address 
Dimension 
Position 
Gravity_Type 

procedure Xt_Set_Arg (List : in 

Subscript : in 

Name : in 

Value : in 

This set of overloaded procedures provides a strongly typed, 
Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 


out Xt_Arg_List; 
Integer; 

String; 

Intrinsics.Dimension); 


Page 71 







29 October 1990 


STARS-RC-00980/001/00 


Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity_Type 

procedure Xt_Set_Arg (Arg : out Intrinsics.Xt_Ancillary_Types.Xt.Arg; 

Name : in String; 

Value : in Intrinsics.Position); 
pragma Builtin (Xt.Set.Arg, 2210); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity.Type 


procedure Xt.Set.Arg (List 

: in 

out Xt.Arg.List; 

Subscript 

: in 

Integer; 

Name 

: in 

String; 

Value 

: in 

Intrinsics.Position); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 
of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity.Type 

procedure Xt.Set.Arg (Arg : out Intrinsics.Xt_Ancillarv_Types.Xt.Arg; 

Name . _n String; 

Value : in X.Windows.Gravity.Type); 
pragma Builtin (Xt.Set.Arg, 2211); 


Page 72 









29 October 1990 


STARS-RC-00980/001/00 


This set of overloaded procedures provides a strongly typed, 

Ada version of the Xt toolkit macro XtSetArg. 

Current overloading permits the Value parameter to be one 

of the following types: 

Boolean 

String 

Integer 

Address 

Dimension 

Position 

Gravity_Type 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in X_Windows.Gravity_Type); 

Create produces an array of Xt_Arg 

procedure Create (Arg_List : out Xt_Arg_List; 

First : in Integer; 

Last : in Integer); 

pragma Builtin (Create, 2212); 

Put sets an element of an array of Xt.Arg 

procedure Put (Arg_List : out Xt.Arg.List; 

Subscript : in Integer; 

Value : in Intrinsics.Xt_Ancillary.Types.Xt_Arg); 

pragma Builtin (Put, 2213); 

Get retrieves the value of an element of an array of Xt.Arg 
function Get 

(Arg.List : in Xt.Arg.List; 

Subscript : in Integer) return Intrmsics .Xt.Ancillary.Types .Xt.Arg; 
pragma Builtin (Get, 2214); 


Get retrieves a slice of an array of Xt.Arg 

function Get (Arg.List : in Xt_Arg_List; 

First : in Integer; 

Last ; in Integer) return Xt_Arg_List; 

pragma Builtin (Get, 2215); 

Ada version of the toolkit procedure XtSetValues. 

procedure Xt.Set.Values (W : in Intrinsics.Widget; 

Arg.List : in Xt_Arg_List); 
pragma Builtin (Xt.Set.Values, 2216); 


Page 72 






29 October 1990 


STARS- RC-00980/001/00 


This set of overloaded functions provides a strongly typed, 

Ada alternative to the Xt toolkit procedure XtGetValues. 

Current overloading permits the returned value to be one 
of the following types: 

Boolean 
Dimension 
Font.Record 

function Xt.Get.Value (W : in Intrinsics.Widget; 

Name : in String) return Boolean; 
pragma Builtin (Xt_Get_Value, 2217); 

This set of overloaded functions provides a strongly typed, 

Ada alternative to the Xt toolkit procedure XtGetValues. 

Current overloading permits the returned value to be one 
of the following types: 

Boolean 
Dimension 
Font.Record 

function Xt.Get.Value (W : in Intrinsics.Widget; 

Name : in String) return Intrinsics.Dimension; 
pragma Builtin (Xt.Get.Value, 2218); 

This set of overloaded functions provides a strongly typed, 

Ada alternative to the Xt toolkit procedure XtGetValues. 

Current overloading pennies the returned value to be one 
of the following types: 

Boolean 

Dimension 

Font.Record 

function Xt.Get.Value (W : in Intrinsics.Widget; 

Name : in String) return X.Windows.Fonts.Font.Record; 
pragma Builtin (Xt.Get.Value, 2219); 

This set of overloaded procedures provides a strongly typed, 

Ada interface to the XtAddCallback toolkit procedure. 


Current overloading permits the Closure parameter to be one 
of the following types: 

Address 
Integer 

procedure Xt.Add.Callback (W 

Name 


Page 71 


: in Intrinsics.Widget; 
: in String; 







29 October 1990 


STARS-RC-00980/001/00 


Callback_Proc : in System.Address; 

Closure : in System.Address); 

pragma Builtin (Xt_Add_Callback, 2220) ; 

This set of overloaded procedures provides a strongly typed, 

Ada interface to the XtAddCallback toolkit procedure. 

Current overloading permits the Closure parameter to be one 

of the following types: 

Address 

Integer 

procedure Xt_Add_Callback (W : in Intrinsics.Widget; 

Name : in String; 

Callback_Proc : in System.Address; 

Closure : in Integer); 

pragma Builtin (Xt_Add_Callback, 2221); 

Ada version of the Xt toolkit routine XtCreateWidget. 

procedure Xt_Create_Widget (0ut_Value : out Intrinsics.Widget; 

Name : in String; 

Widgetclass : in Intrinsics.Widget_Class; 

Parent : in Intrinsics.Widget; 

Arg_List : in Xt_Arg_List) ; 

pragma Builtin (Xt_Create_Widget, 2222); 

Ada version of the Xt toolkit routine XtCreateManagedWidget. 

procedure Xt_Create_Managed_Widget (Qut_Value : out Intrinsics.Widget; 

Name : in String; 

Widgetclass : in Intrinsics.Widget_Class 

Parent : in Intrinsics.Widget; 

Arg.List : in Xt_Arg_List); 

pragma Builtin (Xt_Create_Managed_Widget, 2223); 

Ada version of the Xt toolkit routine XtRealizeWidget. 

procedure Xt_Realize_Widget (W : in Intrinsics.Widget); 
pragma Builtin (Xt_Realize_Widget, 2224); 

Ada version of the Xt toolkit routine XtMainLoop. 
procedure Xt_Mam_Loop; 
pragma Builtin (Xt_Mam_Loop, 2225); 

Ada version of the Xt toolkit routine XtDestroyWidget. 

procedure Xt_Destroy_Widget (W : in Intrinsics.Widget); 
pragma Builtin (Xt_Destroy_Widget, 222G); 









29 October 1990 


STARS-RC-00980/001/00 


Ada version of the X library routine XTextWidth. 

function X_Tex.t_Width (F : in X.Wmdows . Fonts . Font_Record ; 

S : in String) return Intrinsics.Dimension; 
pragma Builtin (X_Text_Width, 2227); 

Ada version of the Xt toolkit routine XtParseTranslationTable. 

function Xt_Parse_Translation_Table (S : in String) return Xt.Translations; 
pragma Builtin (Xt_Parse_Translation_Table, 2228); 

Ada version of the Xt toolkit routine XtOverrideTranslations. 
procedure Xt_Override_Translations (W : in Intrinsics.Widget; 

T : in Xt.Translations); 

pragma Builtin (Xt.Override.Translations, 2229); 

Ada version of the Xt toolkit routine XtAugmentTranslations. 
procedure Xt.Augment.Translations (W : in Intrinsics.Widget; 

T : in Xt.Translations); 
pragma Builtin (Xt.Augment.Translations, 2230); 

Ada version of the Xt toolkit routine XtAddActions. 

procedure Xt.Add.Actions (Arg.List : in Xt.Arg.List); 
pragma Builtin (Xt.Add.Actions, 2231); 

Returns a pointer to an interpreted action procedure; 

this should be used when providing procedure "addresses" to 

Xt.Add.Actions 

function Action.Procedure.Pointer (Name : in String) return System.Address; 
pragma Builtin (Action.Procedure.Pointer, 2232); 

Returns a pointer to an interpreted callback procedure; 
this should be used when providing procedure "addresses" to 
Xt.Add.Callback 

function Callback.Procedure.Pointer (Name : in String) return System.Address 
pragma Builtin (Callback.Procedure.Pointer, 2233); 

Ada version of the Xt toolkit routine .XtDefaultAppContext. 

function Xt.Default.App.Context return Intrinsics.Xt.App.Context; 
pragma Builtin (Xt.Default.App.Context, 2234); 

Ada version of the Xt toolkit routine XtAppNextEvent. 
function Xt.App.Next.Event 

(App : in Intrinsics .Xt.App.Context) return X.Wmdows. Events .Event; 
pragma Builtin (Xt.App.Next.Event, 2235); 


Ada version of the Xt toolkit routine XtDispatchEvent. 







29 October 1990 


STARS-RC-009S0/001/00 


procedure Xt_Dispatch_Event (E : in X.Wmdows. Events . Event) ; 
pragma Builtm (Xt_Dispatch_Ever, v 2236); 

end Widget.Package; 


with System; 
with X.Windows; 
with Intrinsics; 
package body Widget.Package is 
use System; 
use X.Windows; 
use Intrinsics; 
use Xt_Ancillary_Types; 

procedure Xt_Set_Arg (List in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Boolean) is 
Temp_Xt_Arg : Xt.Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in String) is 
Temp_Xt_Arg : Xt.Arg; 
begin 

Xt_Set_Arg (Temp.Xt.Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Integer) is 
Temp_Xt_Arg : Xt.Arg; 
begin 

Xt_Set_Arg (Temp.Xt.Arg, Name, Value); 

Put (List, Subscript, Temp.Xt.Arg); 
end Xt_Set_Arg; 


Page 77 




29 October 1990 


STARS-RC-00980/001/00 


procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Address) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Dimension) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Position) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Gravity_Type) is 

Temp_Xt_Arg : Xt.Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

end Widget_Package; 

Xt.Stringdefs is a package which contains commonly used 
resource name constants. 


Page 78 








29 October 1990 


STARS-RC-00980/001/00 


package Xt_Stringdefs is 

-- resource name constants 


Xt_N_Accelerators 

Xt.N.Allov.Horiz 

Xt.N.Allow.Vert 

Xt.N.Ancestor.Sensitive 

Xt.N.Background 

Xt_N_Background_Pixmap 

Xt_N_Bitmap 

Xt.N.Border.Color 

Xt_N_Border 

Xt.N.Border.Pixmap 

Xt,N_Border_Width 

Xt.N.Callback 

Xt_N_Colormap 

Xt.N.Depth 

Xt.N.Destroy.Callback 

Xt_N_Edit_Type 

Xt_N_File 

Xt.N.Font 

Xt_N_Force_Bars 

Xt_N_Foreground 

Xt.N.Function 

Xt.N.Height 

Xt_N_Highlight 

Xt_N_H_Space 

Xt.N.Index 

Xt_N_Inner.Height 

Xt.N.Inner.Width 

Xt.N.Inner.Window 

Xt.N.Insert.Posit ion 

Xt.N.Internal.Height 

Xt.N.Internal.Width 

Xt.N.Jump_Proc 

Xt.N.Justify 

Xt.N.Knob.Height 

Xt.N.Knob.Indent 

Xt.N.Knob.Pixel 

Xt.N.Knob.Width 

Xt.N.Label 

Xt.N.Length 

Xt.N.Lower.Right 


constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 


"accelerators"; 
"allowHoriz"; 
"allowVert"; 
"ancestorSensitive"; 
"background"; 
"backgroundPixmap"; 
"bitmap"; 
"borderColor"; 
"borderColor"; 
"borderPixmap"; 
"borderWidth"; 
"callback"; 
"colormap"; 

"depth"; 

"destroyCallback"; 
"editType"; 

"file"; 

"font"; 

"forceBars"; 
"foreground"; 
"function"; 

"height"; 

"highlight"; 

"hSpace"; 

"index"; 
"innerHeight"; 
"mnerWidth"; 
"innerWindow"; 
"insertPosition"; 
"internalHeight"; 
"internalWidth"; 
"jumpProc"; 

"justify"; 
"knobHeight"; 
"knoblndent"; 
"knobPixsl"; 
"knobWidth"; 

"label"; 

"length"; 
"lowerRight"; 


Page 7!) 









29 October 1990 


STARS-RC-009S0/001/00 


Xt_N_Mapped_When_Managed 

constant String 

Xt.N.Menu.Entry 

constant String 

Xt_N_Name 

constant String 

Xt.N.Notify 

constant String 

Xt_N_Orientation 

constant String 

Xt_N_Parameter 

constant String 

Xt_N_Pixmap 

constant String 

Xt.N.Popup.Callback 

constant String 

Xt_N_Popdown_Callback 

constant String 

Xt_N_Resize 

constant String 

Xt_N_Reverse_Video 

constant String 

Xt.N.Screen 

constant String 

Xt_N_Scroll_Proc 

constant String 

Xt.N.Scroll.D.Cursor 

constant String 

Xt_N_Scroll_H_Cursor 

constant String 

Xt.N.Scroll.L.Cursor 

constant String 

Xt_N_Scroll_R_Cursor 

constant String 

Xt.N.Scroll.U.Cursor 

constant String 

Xt_N_Scroll_V_Cursor 

constant String 

Xt_N_Selection 

constant String 

Xt.N.Selection.Array 

constant String 

Xt_N_Sensitive 

constant String 

Xt_N_Shown 

constant String 

Xt_N_Space 

constant String 

Xt.N.Strmg 

constant String 

Xt_N_Text.Options 

constant String 

Xt.N.Text.Sink 

constant String 

Xt_N_Text.Source 

constant String 

Xt.N.Thickness 

constant String 

Xt.N.Thumb 

constant String 

Xt_N.Thumb_Proc 

constant String 

Xt.N.Top 

constant String 

Xt.N.Translations 

constant String 

Xt.N.Update 

constant String 

Xt.N.Use.Bottom 

constant String 

Xt.N.Use.Right 

constant String 

Xt.N.Value 

constant String 

Xt.N.V.Space 

constant String 

Xt.N.Width 

constant String 

Xt.N.Window 

constant String 

Xt.N.X 

constant String 

Xt.N.Y 

constant String 


— resource class constants 


"mappedWhenManaged"; 
"menuEntry"; 

"name"; 

"notify"; 
"orientation"; 
"parameter"; 

"pixmap"; 
"popupCallback"; 
"popdownCallback"; 
"resize"; 
"reverseVideo"; 
"screen"; 
"scrollProc"; 
"scrollDCursor"; 
"scrollHCursor"; 
"scrollLCursor"; 
"scrollRCursor"; 
"scrollUCursor"; 
"scrollVCursor"; 
"selection"; 

"selectionArray"; 
"sensitive"; 

"shown"; 

"space"; 

"string"; 
"textOptions"; 
"textSink"; 
"textSource"; 
"thickness"; 

"thumb"; 

"thumbProc"; 

"top"; 

"translations"; 
"update"; 

"useBottom"; 
"useRight"; 

"value"; 

"vSpace"; 

"width"; 

"window"; 

11.11 . 

A » 

"y"; 










29 October 1990 


STA RS- RC-00980 / 001 / 00 


Xt_C_Accelerators 

Xt_C_Background 

Xt.C.Bitmap 

Xt_C_Boolean 

Xt_C_Border.Color 

Xt_C_Border.Width 

Xt.C.Callback 

Xt.C.Colormap 

Xt.C.Color 

Xt.C.Cursor 

Xt.C.Depth 

Xt.C.Edit. Type 

Xt.C.Event.Bindmgs 

Xt.C.File 

Xt.C.Font 

Xt.C.Foreground 

Xt.C.Fraction 

Xt.C.Function 

Xt.C.Height 

Xt.C.H.Space 

Xt.C.Index 

Xt.C.Insert.Position 

Xt.C.Interval 

Xt.C.Justify 

Xt.C.Knob.Indent 

Xt.C.Knob.Pixel 

Xt.C.Label 

Xt.C.Length 

Xt.C.Mapped.When.Managed 

Xt.C.Margm 

Xt.C.Menu.Entry 

Xt.C.Notify 

Xt.C.Orientation 

Xt.C.Pararaeter 

Xt.C.Pixmap 

Xt.C.Position 

Xt.C.Resize 

Xt.C.Revarse.Video 

Xt.C.Screen 

Xt.C.Scroll.Proc 

Xt.C.Scroll.D.Cursor 

Xt.C.Scroll.H.Cursor 

Xt.C.Scroll.L.Cursor 

Xt.C.Scroll.R.Cursor 

Xt.C.Scroll.U.Cursor 


constant String := 

"Accelerators" ; 

constant 

String := 

"Background"; 

constant 

String := 

"Bitmap"; 

constant String := 

"Boolean"; 

constant String := 

"BorderColor"; 

constant String := 

"BorderWidth"; 

constant String := 

"Callback"; 

constant 

String := 

"Colormap"; 

constant 

String := 

"Color"; 

constant 

String := 

" Cursor "; 

constant String :* 

"Depth"; 

constant 

String := 

"EditType"; 

constant 

String :=- 

-‘EventBindings"; 

constant String := 

"File"; 

constant String := 

"Font"; 

constant String := 

"Foreground"; 

constant 

String := 

"Fraction"; 

constant 

String := 

"Function"; 

constant 

String := 

"Height"; 

constant String := 

"HSpace"; 

constant 

String := 

"Index"; 

constant String := 

"InsertPosition"; 

constant String :* 

"Interval"; 

constant String := 

"Justify"; 

constant 

String :* 

"Knoblndent"; 

constant 

String := 

"KnobPixel"; 

constant 

String := 

"Label"; 

constant 

String := 

"Length"; 

constant 

String := 

"MappedWhenManaged 

constant 

String := 

"Margin”; 

constant 

String := 

"MenuEntry"; 

constant 

String := 

"Notify"; 

constant 

String := 

"Orientation"; 

constant 

String := 

"Parameter”; 

constant 

String := 

"Pixmap"; 

constant 

String := 

"Position"; 

constant 

String :* 

"Resize"; 

constant 

String := 

"ReverseVideo"; 

constant String :* 

"Screen"; 

constant 

String :* 

"ScrollProc"; 

constant 

String := 

"ScrollDCursor"; 

constant 

String := 

"ScrollHCursor"; 

constant String :* 

"ScrollLCursor"; 

constant 

String :* 

"ScrollRCursor"; 

constant String := 

"ScrollUCursor"; 


Page 81 





29 October 1990 


STARS-RC-0Q9S0/001/00 


Xt.C.Scroll.V.Cursor 

constant String 

= "ScrollVCursor"; 

Xt_C_Selection 

constant String 

= "Selection"; 

Xt.C.Sensitive 

constant String 

= "Sensitive"; 

Xt_C_Selection_Array 

constant String 

= "SelectionArray" 

Xt_C_Space 

constant String 

= "Space"; 

Xt_C_String 

constant String 

= "String"; 

Xt.C.Text.Options 

constant String 

= "TextOptions"; 

Xt.C.Text.Position 

constant String 

= "TextPosition"; 

Xt.C.Text.Sink 

constant String 

= "TextSink"; 

Xt.C.Text.Source 

constant String 

= "TextSource"; 

Xt.C.Thickness 

constant String 

= "Thickness"; 

Xt.C.Thumb 

constant String 

= "Thumb"; 

Xt.C.Translations 

constant String 

= "Translations"; 

Xt.C.Value 

constant String 

= "Value"; 

Xt.C.V.Space 

constant String 

= "VSpace"; 

Xt.C.Width 

constant String 

= "Width"; 

Xt.C.Window 

constant String 

= "Window"; 

Xt.C.X 

constant String 

= "X"; 

Xt.C.Y 

constant String 

= "Y"; 


— resource type constants 


Xt.R.Accelerator.Table 

constant String 

= "AcceleratorTable" 

Xt.R.Bool 

constant String 

* "Bool"; 

Xt.R.Boolean 

constant String 

= "Boolean"; 

Xt.R.Callback 

constant String 

= "Callback"; 

Xt.R.Call.Proc 

constant String 

= "CallProc"; 

Xt.R.Color 

constant String 

= "Color"; 

Xt.R.Cursor 

constant String 

= "Cursor"; 

Xt.R.Dimension 

constant String 

= "Dimension"; 

Xt.R.Display 

constant String 

= "Display"; 

Xt.R_Edit.Mode 

constant String 

= "EditMode"; 

Xt.R.File 

constant String 

= "File"; 

Xt.R.Font 

constant String 

= "Font"; 

Xt.R.Font.Struct 

constant String 

= "FontStruct"; 

Xt.R.Function 

constant String 

= "Function"; 

Xt.R.Geometry 

constant String 

= "Geometry"; 

Xt.R.Immediate 

constant String 

* "Immediate"; 

Xt.R.Int 

constant String 

= "Int"; 

Xt.R.Justify 

constant String 

■ "Justify"; 

Xt.R.Long.Boolean 

constant String 

= "Bool"; 

Xt.R.Orientation 

constant String 

= "Orientation"; 

Xt.R.Pixel 

constant String 

* "Pixel"; 

Xt.R.Pixmap 

constant String 

* "Pixmap"; 

Xt.R.Pointer 

constant String 

= "Pointer"; 


Page 82 











29 October 1990 


STARS-RC-00980/001/00 


Xt.R.Position 

constant 

String 

= 

"Position"; 

Xt.R.Short 

constant 

String 

= 

"Short"; 

Xt.R.Stnng 

constant 

String 

= 

"String"; 

Xt.R.String.Table 

constant 

String 

= 

"StringTable"; 

Xt.R.Unsigned.Char 

constant 

String 

= 

"UnsignedChar"; 

Xt.R.Translation.Table 

constant 

String 

= 

"TranslationTable"; 

Xt.R.Window 

constant 

String 

= 

"Window"; 


— shell specific stringdefs 


Xt_N.Icon.Name 

Xt.C.Icon.Name 

Xt.N.Icon.Pixmap 

Xt_C_Icon_Pixmap 

Xt.N.Icon.Window 

Xt_C_Icon_Window 

Xt_N_Icon_Mask 

Xt_C_Icon_Mask 

Xt.N.Window.Group 

Xt.C.Window.Group 


constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 


= "iconName"; 

= "IconName"; 

= "iconPixmap"; 

= "IconPixmap"; 

= "iconWindow"; 

= "IconWindow"; 

= "iconMask"; 

= "IconMask"; 

= "windowGroup"; 
= "WindowGroup"; 


Xt.N.Save.Under 

Xt.C.Save.Under 

Xt_N_Transient 

Xt_C_Transient 

Xt_N_Override_Redirect 

Xt_C_Override_Redirect 


: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 


= "saveUnder"; 

» "SaveUnder"; 

= "transient"; 

= "Transient"; 

= "overrideRedirect"; 
* "OverrideRedirect"; 


Xt_N_Allow_Shell.Resize 
Xt_C_Allow.Shell.Resize 
Xt.N_Create_Popup_Child.Proc 
Xt.C_Create_Popup_Child.Proc 


constant String 
constant String 
constant String 
constant String 


"allowShellResize" ; 
"AllowShellResize"; 
"createPopupChildProc"; 
"CreatePopupChildProc"; 


Xt.N.Title : constant String "title"; 
Xt.C.Title : constant String : = "Title"; 


-- The following are only used at creation and can not be changed via 
— SetValues. 


Xt.N.Argc 

constant String 

* "argc"; 

Xt.C.Argc 

constant String 

= "Argc"; 

Xt.N.Argv 

constant String 

= "argv"; 

Xt.C.Argv 

constant String 

* "Argv"; 

Xt.N.Icon.X 

constant String 

■ "iconX"; 

Xt.C.Icon.X 

constant String 

* "Icor.X"; 


Pago s;i 

















29 October 1990 


STARS-RC-00980/001/00 


Xt.N.Icon.Y 

Xt_C_Icon_Y 

Xt.N.Input 

Xt_C_Input 

Xt_N_Iconic 

Xt_C_Iconic 

Xt_N_Initial.State 

Xt.C.Initial.State 

Xt.N.Geometry 

Xt.C.Geometry 

Xt.N.Min.Width 

Xt.C.Min.Width 

Xt.N.Min.Height 

Xt.C.Min.Height 

Xt.N.Max.Width 

Xt.C.Max.Width 

Xt.N.Maix.Height 

Xt.C.Max.Height 

Xt.N_Width.Inc 

Xt.C_Width.Inc 

Xt.N_Height.Inc 

Xt.C_Height.Inc 

Xt.N.Min.Aspect.Y 

Xt.C.Min.Aspect_Y 

Xt.N.Max.Aspect_Y 

Xt.C.Max.Aspect_Y 

Xt.N.Min.Aspect.X 

Xt.C.Min.Aspect.X 

Xt.N.Max.Aspect.X 

Xt.C.Max.Aspect.X 

Xt.N.Wm.Timeout 

Xt.C.Wm.Timeout 

Xt.N_Wait_For.Wm 

Xt.C_Wait_For.Wm 


constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String :~ 
constant String := 
constant String := 
constant String := 
constant String := 
constant String : = 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String :* 
constant String := 
constant String := 
constant String : = 
constant String := 


end Xt.Stnngdef s; 


"iconY"; 

"IconY"; 

"input" ; 
"Input"; 
"iconic"; 
"Iconic"; 
"initialState"; 
"InitialState"; 
"geometry"; 
"Geometry"; 
"minWidth"; 
"MinWidth"; 
"minHeight"; 
"MinHeight"; 
"maxWidth"; 
"MaxWidth"; 
"maxHeight"; 
"MaxHeight"; 
"widthlnc"; 
"Widthlnc”; 
"heightlnc"; 
"Heightlnc"; 
"minAspectY"; 
"MinAspectY"; 
"maixAspectY" ; 
"MaixAspectY"; 
"minAspectX"; 
"MinAspectX"; 
"maxAspectX"; 
"MaxAspectX"; 
"wmTimeout"; 
"WmTimeout"; 
"vaitforwm"; 
"Waitforvm"; 


7.7.5 Hp.Widgets 

with Intrmsics; 
with Widget.Package; 
with System; 


The package Hp.Widgets is the ACE interface to the Hewlett-Packard 


Page 81 










29 October 1990 


STARS-RC-00980/001 /00 


widget set. This package defines all of the numeric constants, 
enumerated types, and resource names of this widget set, defines all 
of the widget classes in this set, and supports all of the user 
widget procedures in this set. 

For further information on these routines, see the Hewlett-Packard 
document ation. 

package Hp.Widgets is 
use Intrinsics; 
use Widget.Package; 
use Xt.Ancillary.Types; 

XwjSingle : constant Integer := 0; 

Xw.Multiple : constant Integer := 1; 

Xw.Border : constant Integer := 0; 

Xw.Invert : constant Integer := 1; 

Xw_No_Bias : constant Integer := 0; 

Xw.Row.Bias : constant Integer := 1; 

Xw_Col_Bias : constant Integer := 2; 

Xw.Instant : constant Integer := 0; 

Xw.Sticky : constant Integer := 1; 

Xw_No_Shrink : constant Integer := 0; 

Xw.Shrink.Column : constant Integer :» 1; 

Xw_Shrink_All : constant Integer :» 2; 

Xw.Auto.Scroll.0ff : constant Integer := 0; 
Xw_Auto_Scroll_Horizontal : constant Integer := 1; 
Xw.Auto.Scroll.Vertical : constant Integer := 2; 

Xw_Grow_0ff : constant Integer := 0; 

Xw_Grow_Horizontal : constant Integer := 1; 

Xw_Grow_Vertical : constant Integer ;= 2; 

Xw_N.0f.Many : constant Integer := 0; 

Xw.Qne.0f.Many : constant Integer := 1; 

Xw.Requested.Columns : constant Integer :■ 0; 

Xw.Maximum.Columns : constant Integer := 1; 

Xw.Maximum.Unaligned : constant Integer := 2; 

Xw.Right : constant Integer :* 0; 

Xw.Left : constant Integer := 1; 

Xw.Center : constant Integer :» 2; 

Xw.String : constant Integer := 0; 

Xw.Image : constant Integer : a 1; 

Xw.No.Line : constant Integer := 0; 

Xw.Single.Lme : constant Integer := 1; 

Xw.Double.Line : constant Integer := 2; 

Xw.Single.Dashed.Line : constant Integer :* 3; 
Xw.Double_Dashed.Line : constant Integer :* 4; 


Pago 85 










29 October 1990 


STARS-RC-009S0/001/00 


Xw_Solid : constant Integer := 0; 

Xw_Pattern : constant Integer := 1; 
Xw_Tra_.sparent : constant Integer := 2; 
Xw.Horizontal : constant Integer := 0; 
Xw_Vertical : constant Integer := 1; 

Xw.Top : constant Integer := 1; 

Xw_Bottom : constant Integer := 2; 

Xw.Foreground : constant Integer := 0; 
Xw_Background : constant Integer := 1; 
Xw_25_Foreground : constant Integer := 2; 
Xw_50_Foreground : constant Integer := 3; 
Xw_75_Foreground : constant Integer := 4; 
Xw.Vertical.Tile : constant Integer := 5; 
Xw_Horizcntal_Tile : constant Integer := 6; 
Xw.Slant.Right : constant Integer := 7; 
Xw_Slant_Left : constant Integer := 8; 
Xw.Highlight.Off : constant Integer := 0; 
Xw_Highlight_Enter : constant Integer := 1; 
Xw.Highlight.Traversal : constant Integer := 2; 
Xw.Arrow.Up : constant Integer := 0; 
Xw_Arrow_Down : constant Integer := 1; 
Xw.Arrow.Left : constant Integer := 2; 
Xw.Arrow.Right : constant Integer := 3; 
Xw_Pattern_3order : constant Integer := 1; 
Xw_Widget_Defined : constant Integer := 2; 
Xw.Ignore : constant Integer := 0; 

Xw.Minimize : constant Integer := 1; 

Xw.Maximize : constant Integer := 2; 


Tf.No.Fit 

constant Integer 

= 16#01# 

Tf_Include_Tab 

constant Integer 

= 16#02# 

Tf_End_Text 

constant Integer 

= 16#04# 

Tf .Newline 

constant Integer 

= 16#08# 

Tf_Wrap.White.Space 

constant Integer 

= 16#10# 

Tf.Wrap.Any 

constant Integer 

= 16#20# 

Word.Break 

constant Integer 

= 16#01# 

Scroll.Vertical 

constant Integer 

= 16#02# 

Scroll.Horizontal 

constant Integer 

= 16#04# 

Scroll.On.Overflow 

constant Integer 

= 16#08# 

Resize.Width 

constant Integer 

= 16#10# 

Resize.Height 

constant Integer 

= 16#20# 

Editable 

constant Integer 

= 16#40# 


: constant String :» 
: constant String := 


"traversalOn”; 
"traversalType"; 


Xt_N_Traversad_0n 

Xt_N_Traversal_Type 


Page 86 










'29 October 1990 


STARS-RC-00980/001/00 


Xt.N.Highlight.Style 

Xt.N.Highlight.Tile 

Xt_N_Highlight .Thickness 

Xt.N.Highlight.Color 

Xt.N_Background.Tile 

Xt.N.Cursor 

Xt.N.Recompute.Size 

Xt.N.Layout 

Xt.N.Label.Location 

Xt.N.Sensitive.Tile 

Xt.N.Columns 

Xt.N.Mode 

Xt.N.Set 

Xt.N.Select 

Xt.N.Release 

Xt.N.Next.Top 

Xt.N.Title.Showing 

Xt.N.Mgr.Title.Override 

Xt.N.Title.Type 

Xt.N.Title.String 

Xt.N.Title.Image 

Xt.N.Font.Color 

Xt.N.Mnemonic 

Xt.N.Underline.Title 

Xt.N.Mgr.Underline.Override 

Xt.N.Underline.Position 

Xt.N_Attach._To 

Xt.N.Kbd.Accelerator 

Xt.N.Associate.Children 

Xt.N.Menu.Post 

Xt.N.Menu.Select 

Xt.N.Post.Accelerator 

Xt.N.Menu.Unpost 

Xt.N.Kbd.Select 

Xt.N.Num.Columns 

Xt.N.Row.Position 

Xt.N.Column.Position 

Xt.N.Selection.Method 

Xt.N.Element.Highlight 

Xt.N.Selection.Bias 

Xt.N.Selection.Style 

Xt.N.Column.Width 

Xt.N.Element.Height 

Xt.N.Selected.Elements 

Xt.N.Num.Selected.Elements 


constant String := "highlightStyle"; 
constant String := "highlightTile"; 
constant String := "highlightThickness"; 
constant String .= "highlightColor"; 
constant String := "backgroundTile”; 
constant String :» "cursor"; 
constant String := "recomputeSize"; 
constant String := "layout"; 
constant String := "labelLocation"; 
constant String := "sensitiveTile"; 
constant String := "columns"; 
constant String := "mode"; 
constant String := "set"; 
constant String := "select"; 
constant String := "release"; 
constant String := "nextTop"; 
constant String := "titleShowing"; 
constant String := "mgrTitleOverride"; 
constant String := "titleType"; 
constant String := "titleString"; 
constant String := "titlelmage"; 
constant String := "fontColor"; 
constant String := "mnemonic"; 
constant String := "underlineTitle"; 
constant String := "mgrUnderlinaUverride"; 
constant String := "underlinePosition"; 
constant String :* "attachTo"; 
constant String := "kbdAccelerator"; 
consta^it String := "associateChildren"; 
constant String := "menuPost"; 
constant String := "menuSelect"; 
constant String := "postAccelerator"; 
constant String := "menuUnpost"; 
constant String := "kbdSelect"; 
constamt String :=* "numColumns"; 
constant String := "rowPosition"; 
constant String :» "columnPosition"; 
constant String :* "selectionMethod"; 
constant String := "elementHighlight"; 
constant String := "selectionBias"; 
constant String := "selectionStyle"; 
constant String := "columnWidth"; 
constant String :* "elementHeight"; 
constant String :» "selectedElements"; 
constauit String := "numSelectedElements"; 


Page 87 








'29 October 1990 


STARS-RC-009S0/001/0Q 


Xt.N.Destroy .Mode 

Xt.N.Layout.Type 

Xt_N_Force_Size 

Xt.N.Single.Row 

Xt_N_Separator_Type 

Xt.N.Vsb.X 

Xt.N.Vsb.Y 

Xt.N.Vsb.Width 

Xt.N.Vsb.Height 

Xt_N_Hsb_X 

Xt_N_Hsb_Y 

Xt.N.Hsb.Width 

Xt.N.Hsb.Height 

Xt_N_V_Slider_Min 

Xt_N_V_Slider_Max 

Xt.N.V.Slider.Origin 

Xt.N.V.Slider.Extent 

Xt.N_H_Slider.Min 

Xt.N_H_Slider.Max 

Xt.N.H.Slider.Origin 

Xt_N_H_Slider.Extent 

Xt_N_H_Scroll_Event 

Xt.N.V.Scroll.Event 

Xt.N.V.Scroll.Bar.Width 

Xt.N.V.Scroll.Bar.Height 

Xt.N.H.Scroll.Bar.Width 

Xt.N_H_Scroll.Bar.Height 

Xt_N_Force_Vertical_Sb 

Xt_N_Force_Horizontal_Sb 

Xt_N_Initial_X 

Xt_N_Initial_Y 

Xt_N_Border_Pad 

Xt_N_S_Rimage 

Xt_N_Show_Selected 

Xt_N_Display.Position 

Xt.N.Insert.Position 

Xt.N.Left.Margin 

Xt.N.Right.Margin 

Xt.N.Top.Margin 

Xt.N.Bottom.Margin 

Xt.N.Select ion.Array 

Xt.N.Text.Source 

Xt.N.Selection 

Xt.N.Maximum.Size 

Xt.N.Edit.Type 


constant String : = 
constant String := 
constant String := 
constant String := 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 


"destroyMode"; 
"layoutType"; 

"forceSize"; 
"smgleRov"; 
"seraratorType”; 
"vsbX"; 

"vsbY"; 

"vsbWxdth"; 
"vsbHeight"; 

"hsbX"; 

"hsbY"; 

"hsbWidth"; 
"hsbHeight"; 
"vSliderMin"; 
"vSliderMax"; 
"vSliderOrigin"; 
"vSliderExtent"; 
"hSliderMm"; 
"hJliderMax"; 
"hSliderOngm" ; 
"hSliderExtent"; 
"hScrollEvent"; 

= "vScrollEvent"; 

= "vScrollBarWidth"; 

= "vScrollBairHeigu'c"; 

= "hScrollBarWidth"; 

= "hScrollBarHeight"; 

= "forceVerticalSB"; 

= "forceHorizontalSB"; 
= "initialX"; 

= "initialY"; 

= "borderPad"; 

= "rasterlraage"; 

= "showSelected"; 

= "displayPosition"; 

= "insertPosition"; 

= "leftMargin"; 

* "rightMargin"; 

= "tcpMargin"; 

= "bottomMargin"; 

= "selectionArray"; 

= "textSource"; 

= "selection", 

* "maximumSize"; 

= "editType"; 


Page 88 









29 October 1990 


STARS-RC-00980/001/00 


Xt_N_File : constant String := "file"; 

-- Xt.N.String : constant String := "string"; — defined in Xt.Stringdefs 
Xt_N_Length. : constant String := "length"; 

— Xt_N_Font : constant String := "font"; — defined in Xt_Stringdef s 
Xt.N.Disk.Src : constant String := "disksrc"; 

Xt_N_String_Src : constant String :* "stringsrc"; 

Xt.N.Execute : constant String :* "execute"; 

Xt_N_Source_Type : constant String := "sourceType"; 

Xt_N_Motion_Verification : constant String "motionVerification"; 

Xt.N.Modify.Verification : constant String := "modifyVerification"; 

Xt.N_Leave.Verification : constant String := "leaveVerification"; 

Xt_N_Wrap : constant String := "wrap"; 

Xt.N_Wrap.Form : constant String := "wrapForm"; 

Xt.N.Wrap.Breaik : constant String := "wrapBreak"; 

Xt.N.Scroll : constant String := "scroll"; 

Xt_N_Grow : constant String := "grow"; 


Xt_N_Alignment 

Xt_N_Line_Space 

Xt_N_Gravity 

Xt_N_Slider_Min 

Xt_N_Slider_Max 

Xt_N_Slider_Origin 

Xt.N.Slider.Extent 

Xt_N_Slider_Color 

Xt_N_Slide_Orientation 

Xt_N_Slide_Move_Type 

Xt_N_Slide_Area_Tile 

Xt_N_Slider_Moved 

Xt_N_Area_Selected 

Xt_N_Slider_Tile 

Xt_N_Slider_Released 

Xt_N.X_Ref.Name 

Xt_N_X_Ref.Widget 

Xt.N.X.Offset 

Xt.N.X.Add.Width 

Xt_N_X.Vary.0ffset 

Xt.N.X.Resizable 

Xt.N.X.Attach.Right 

Xt.N_X_Attach.Offset 

Xt.N_Y_Ref.Name 

Xt_N_Y_Ref.Widget 

Xt.N_Y.0ffset 

Xt.N.Y.Add.Height 

Xt_N_Y.Vary.0ffset 

Xt.N.Y.Resizable 


constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String 
constant String := 
constant String := 
constant String :=* 
constant String := 
constant String := 
constant String := 
constant String :* 
constant String := 
constant String :* 
constant String := 
constant String := 
constant String := 
constant String := 
constant String := 
constant String :» 
constant String :* 


"alignment"; 
"lineSpace"; 
"gravity"; 
"sliderMin"; 
"sliderMax"; 
"sliderOrigin"; 
"sliderExtent"; 
"sliderColor"; 
"slideOrientation"; 
"slideMoveType"; 
"slideAreaTile"; 
"sliderMoved"; 
"areaSelected"; 
"sliderTile"; 
"sliderReleased"; 
"xRefNaime"; 
"xRefWidget"; 

"xOffset"; 
"xAddWidth"; 
"xVauryOff set"; 
"xResizable"; 
"xAttachRight"; 
"xAttachOffset"; 
"yRefName"; 

"yRefWidget"; 

"yOffset"; 
"yAddHeight"; 
"yVaryOffset"; 
"yResizable"; 


Page 89 








29 October 1990 


STARS-RC-00980/001/00 


Xt_N_Y_Attach_Bottom 

Xt.N_Y_Attach.Offset 

Xt_N_Pixel_Scale 

Xt_N_Grid_Thickness 

Xt.N.Image 

Xt.N.Draw.Color 

Xt_N_Erase_Color 

Xt_N_Erase_0n 

Xt.N.Label.Type 

Xt.N.Label.Image 

Xt.N.Cascade.Image 

Xt_N_Mark_Image 

Xt_N_Set_Mark 

Xt.N_Cascade.0n 

Xt_N_Invert.On.Enter 

Xt.N.Mgr.Override.Mnemonic 

Xt_N_Cascade_Select 

Xt.N.Cascade.Unselect 

Xt _N_Menu_Mgr_Id 

Xt.N.Scrollbar.Orientation 

Xt_N_Selection_Color 

Xt.N.Initial.Delay 

Xt.N.Repeat.Rate 

Xt_N_Granularity 

Xt_N_Invert_Qn_Select 

Xt.N.Toggle 

Xt_N_Square 

Xt_N_Select.Color 

Xt_N_Allow_Resize 

Xt.N.Sash.Indent 

Xt.N.Refigure.Mode 

Xt_N_Padding 

Xt_N_Min : constant String 

Xt.N.Max : constant String 

Xt.N.Skip.Adjust 

Xt.N.Framed 

Xt.N.Border.Frame 

Xt_N_Expose 

Xt.N.Resize 

Xt_N_Key_Down 

Xt_N_Sticky.Menus 

Xt.N.Allow.Cascades 

Xt.N_Pulldown_Bar.Id 

Xt.N.Strip 

Xt.N.Title.Precedence 


: constant String 
: constant String 
: constant String 
: constant String 
: const amt String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constamt String 
: constant String 
"min"; 

"max"; 

: constamt String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constant String 
: constamt String 
: constant String 
: constant String 
: constant String 


"yAttachBottom"; 
"yAttachQffset"; 
"pixelScale"; 
"gridThickness"; 
"image"; 

"drawColor"; 
"eraseColor"; 
"eraseOn"; 
"labelType"; 
"labellmage"; 
"cascadelmage"; 
"marklmage"; 

"setMark"; 
"cascadeOn"; 
"invertOnEnter"; 
"mgrOverrideMnemonic" 
"cascadeSelect"; 
"cascadeUnselect"; 
"menuMgrld"; 

= "scrollbarOrientation 
= "selectionColor"; 

= "initialDelay"; 

* "repeatRate"; 

= "granularity"; 

= "invertOnSelect"; 

= "toggle"; 

= "square"; 

= "selectColor"; 

= "allowResize"; 

= "sashlndent"; 

= "refigureMode"; 

* "padding"; 


= "skipAdjust"; 

= "framed"; 

* "borderFrame"; 

* "expose"; 

* "resize"; 

» "keyDown"; 

* "stickyMenus"; 

= "allowCascades"; 

= "pulldownBarld"; 

« "strip"; 

■ "titlePrecedence"; 


Page 90 










29 October 1990 


STARS-RC-00980/001/00 




Xt_N_Title_Foreground 

constant String 

= "titleForeground"; 

Xt.N.Title.Background 

constant String 

= "titleBackground"; 

Xt_N_Title_Region 

constant String 

= "titleRegion"; 

Xt_N_Title_Position 

constant String 

= "titlePosition"; 

Xt.N.Title.Rpadding 

constant String 

= "titleRPadding"; 

Xt.N.Title.Lpadding 

constant String 

* "titleLPadding"; 

Xt.N.Title.Border.Width 

constant String 

* "titleBorderWidth"; 

Xt_N_Title_Translations 

constant String 

* "titleTranslations"; 

Xt.N.Title.Hspace 

constant String 

* "titleHSpace"; 

Xt.N.Title.Vspace 

constant String 

= "titleVSpace"; 

Xt.N.Title.Select 

constant String 

= "titleSelect"; 

Xt_N_Title.Release 

constant String 

* "titleRelease"; 

Xt_N_Title_Next_Top 

constant String 

= "titleNextTop"; 

Xt.N.Titlebar.Tile 

constant String 

= "titlebaurTile"; 

Xt_N_Enter 

constant String 

= "enter"; 

Xt.N.Leave 

constant String 

= "leave"; 

Xt_N_Region 

constant String 

= "region"; 

Xt_N_Position 

constant String 

= "position"; 

Xt_N_L_Padding 

constant String 

= "IPadding"; 

Xt_N_R_Padding 

constant String 

= "rPadding"; 

Xt_N_Precedence 

constant String 

* "precedence"; 

Xt_N_Title_To_Menu_Pad 

constant String 

= "titleToMenuPad"; 

Xt_N_Work_Space_To_Sibling_Pad 

constant String 

* "workSpaceToSiblingPad" 

Xt_N_Widget_Type 

constant String 

* "widgetType"; 

Xt_N_Top_Level 

constant String 

= "topLevel"; 

Xt_N_Display.Title 

constant String 

= "displayTitle"; 

Xt_N_Causes.Resize 

constant String 

= "causesResize"; 

Xt.N.Arrow.Direction 

constant String 

* "arrowDirection"; 


subtype Xw_Text_Position is Cardinal; 

type Xw.Text.Source.Ptr is new System.Address; 
type Xw.Text.Sink.Ptr is new System.Address; 

type Xw.Alignment is 
(Xw_Align_None, 

Xw.Align.Left, 

Xw.Align.Center, 

Xw.Align.Right); 

type Xw_Widget_Type is (Xw.Unknown, Xw.Pulldown, Xw.Title, Xw.Work.Space) ; 
type Xw.Scan.Direction is (Xw.Sd.Left, Xw_Sd_Right); 
type Xw.Scan.Type is 


Page 91 









29 October 1990 


STARS-RC-00980/001/00 


(Xw_St_Positions, 

Xw_St_White_Space, 

Xw_St_Eol, 

Xw_St_Last); 

type Xw_Edit_Type is (Xv_Text_Read, Xw.Text.Append, Xw.Text.Edit); 

type Xw.Edit.Result is 
(Xw.Edit.Done, 

Xw.Edit.Error, 

Xw.Edit.Pos.Error, 

Xw.Edit.Reject); 

type Xw.Verify.Op.Type is (Motion.Verify, Mod.Verify, Leave.Verify); 
type Xw.Source.Type is (Xw.String.Src, Xw.Disk.Src, Xw.Prog.Defined.Src); 
type Xw.Wrap is (Xw.Wrap.Off, Xw.Soft.Wrap, Xw.Hard.Wrap); 
type Xw.Wrap.Form is (Xw.Source.Form, Xw.Display.Form); 
type Xw.Wrap.Break is (Xw.Wrap.Any, Xw.Wrap.White.Space); 


function Xw.Arrow.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Arrow.Widget.Class, 2301); 

function Xw_Bulletin.Board.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Bulletin.Board.Widget.Class, 2302); 

function Xw.Bulletin.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Bulletin.Widget.Class, 2303); 

function Xw.Button.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Button.Widget.Class, 2304); 

function Xw.Cascade.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Cascade.Widget.Class, 2305); 

function Xw.Form.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Form.Widget.Class, 2306); 

function Xw.Image.Edit.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Image.Edit.Widget.Class, 2307); 
function Xw.List.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.List.Widget.Class, 2308); 

function Xw.Listrow.Col.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Listrow.Col.Widget.Class, 2309); 
function Xw.Manager.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Manager.Widget.Class, 2310); 

function Xw.Menu.Button.Widget.Class return Intrinsics.Widget.Class; 


Page 92 







29 October 1990 


STARS-RC-00980/001 /00 


pragma Builtin (Xw.Menu.Button.Widget.Class, 2311); 

function Xw.Menu.Sep.Widget.Class return Intrinsics.Widget_Class; 

pragma Builtin (Xw.Menu.Sep.Widget.Class, 2312); 

function Xw_Menubutton_Widget_Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw_Menubutton_Widget_Class, 2313); 
function Xw.Menumgr.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Menumgr.Widget.Class, 2314); 

function Xw.Menupane.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Menupane.Widget.Class, 2315); 
function Xw.Panel.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Panel.Widget.Class, 2316); 

function Xw.Popup.Mgr.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Popup.Mgr.Widget.Class, 2317); 
function Xw.Popupmgr.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Popupmgr.Widget.Class, 2318); 

function Xw.Primitive.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Primitive.Widget.Class, 2319); 

function Xw.Push.Button.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Push.Button.Widget.Class, 2320); 

function Xw.Row.Col.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Row.Col.Widget.Class, 2321); 

function Xw.Sash.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Sash.Widget.Class, 2322); 

function Xw.Scroll.Bar.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Scroll.Bar.Widget.Class, 2323); 
function Xw.Scrollbar.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Scrollbar.Widget.Class, 2324); 

function Xw.Scrolled.Window.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Scrolled.Window.Widget.Class, 2325); 


function Xw.Sraster.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Sraster.Widget.Class, 2326); 

function Xw.Static.Raster.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Static.Raster.Widget.Class, 2327); 

function Xw.Static.Text.Widget.Class return Intrinsics Widget.Class; 

pragma Builtin (Xw.Static.Text.Widget.Class, 2328); 

function Xw.Statictext.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Statictext.Widget.Class, 2329); 

function Xw.Swindow.Widget.Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Swindow.Widget.Class, 2330); 

function Xw.Text.Edit.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Text.Edit.Widget.Class, 2331); 
function Xw.Textedit.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Textedit.Widget..Class, 2332); 


Page 93 






29 October 1990 


STARS-RC-00980/001/00 


function Xw.Title.Bar.Widget.Class return Intrinsic .Widget.Class; 

pragma Builtin (Xw_Title_Bar_Widget_Class, 2333); 

function Xw_Titlebar_Widget_Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw.Titlebar.Widget.Class, 2334); 

function Xv_Toggle_Widget_Class return Intrinsics.Widget.Class; 

pragma Builtin (Xw_Toggle_Widget_Class, 2335); 

— Using Xw.V.Paned.Widget.Class creates a demand for a procedure 

— called .XtCreateFontCursor, which does not seem to be in any 

— X library (rhp, 5/2/90) 

— Aha! This is apparently a misprint for .XCreateFontCursor (rhp) 

— function Xw_V_Paned_Widget_Class return Intrinsics.Widget.Class; 

— pragma Builtin (Xw_V_Paned_Widget.Class, 2336); 

function Xw.Valuator.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Valuator.Widget.Class, 2337); 

function Xw.Work.Space.Widget.Class return Intrinsics.Widget.Class; 
pragma Builtin (Xw.Work.Space.Widget.Class, 2338); 

Ada interface to the widget procedure XwTextClearBuffer 
procedure Xw.Text.Clear.Buffer (W : in Widget); 
pragma Builtin (Xw.Text.Clear.Buffer, 2401); 

Ada interface to the widget procedure XwTextCopyBuffer 

function Xw.Text_Copy.Buffer (W : in Widget) return String; 
pragma Builtin (Xw.Text_Copy.Buffer, 2402); 

Ada interface to the widget procedure XwTextCopySelection 

function Xw.Text.Copy.Selection (W : in Widget) return String; 
pragma Builtin (Xw.Text.Copy.Selection, 2403); 


Ada interface to the widget procedure XwTextReadSubString 


procedure Xw.Text.Read.Sub.String (W 

Start.Pos 
End.Pos 
Target 
Target.Used 
Source.Used 

pragma Builtin ^Xw.Text.Read.Sub.String, 2404); 


in Widget; 
in Integer; 
in Integer; 
out String; 
out Integer; 
out Integer); 


Ada interface to the widget procedure XwTextUnsetSelection 
procedure Xw.Text.Unset.Selection (W : in Widget); 
pragma Builtin (Xw.Text.Unset.Selection, 2405); 


Page 94 





29 October 1990 


STARS-RC-00980/001/00 


Ada interface to the widget procedure XwTextSetSelection 
procedure Xw_Text_Set_Selection (W : in Widget; 

Left : in Xw_Text_Position; 

Right : in Xw_Text_Position); 
pragma Builtin (Xw.Text.Set.Selection, 2406); 

Ada interface to the widget procedure XwTextReplace 
function Xw_Text_Replace (W : in Widget; 

Start_Pos : in Xw.Text.Position; 

End.Pos : in Xw.Text.Position; 

S : in String) return Xw_Edit_Result; 

pragma Builtin (Xw.Text.Replace, 2407); 

Ada interface to the widget procedure XwTextRedraw 
procedure Xw.Text.Redraw (W : in Widget); 
pragma Builtin (Xw.Text.Redraw, 2408); 

Ada interface to the widget procedure XwTextUpdate 
procedure Xw.Text.Update (W : in Widget; 

Status : in Boolean); 

pragma Builtin (Xw.Text.Update, 2409); 

Ada interface to the widget procedure XwTextlnsert 
procedure Xw.Text.Insert (W : in Widget; 

S : in String); 

pragma Builtin (Xw.Text.Insert, 2410); 

Ada interface to the widget procedure XwTextGetLastPos 

function Xw.Text_Get_Last.Pos (W : in Widget) return Xw.Text.Position; 
pragma Builtin (Xw.Text_Get_Last.Pos, 2411); 

Ada interface to the widget procedure XwTextGetSelectionPos 
proceure Xw.Text_Get_Selection.Pos (W : in Widget; 

Left : out Xw.Text.Position; 

Right : out Xw.Text.Position); 
pragma Builtin (Xw.Text_Get_Selection.Pos, 2412); 


Ada interface to the widget procedure XwTextSetlnsertPos 
procedure Xw.Text_Set_Insert.Pos (W : in Widget; 

Pos : in Xw.Text.Position); 
pragma Builtin (Xw.Text_Set_Insert.Pos, 2413); 

Ada interface to the widget procedure XwTextGetlnsertPos 


Page 95 






29 October 1990 


STARS-RC-00980/001/00 


function Xw_Text_Get_Insert_Pos (W : in Widget) return Xw_Text_Position; 
pragma Builtin (Xw_Text_Get_Insert_Pos, 2414); 

Ada interface to the widget procedure XvTextSetSource 
procedure Xw_Text_Set_Source (W : in Widget; 

Source : in Xw_Text_Source_Ptr; 

Start_Pos : in Xw_Text_Position); 

pragma Builtin (Xw_Text_Set_Source, 2415); 

Ada interface to the widget procedure XwAsciiSinkCreate 
function Xw_Ascii_Sink_Create 
(W : in Widget; 

Args : in Xt_Arg_List) return Xw_Text_Sink_Ptr; 

pragma Builtin (Xw_Ascii_Sink_Create, 2416); 

Ada interface to the widget procedure XwDiskSourceCreate 
function Xw_Disk_Source_Create 
(W : in Widget; 

Args : in Xt_Arg_List) return Xw_Text_Source_Ptr; 

pragma Builtin (Xw_Disk_Source_Create, 2417); 

Ada interface to the widget procedure XwDiskSourceDestroy 

procedure Xw_Disk_Source_Destroy (Src : in Xw_Text_Source_Ptr); 
pragma Builtin (Xw_Disk_Source_Destroy, 2418); 

Ada interface to the widget procedure XwStringSourceCreate 
function Xw_String_Source_Create 
(W : in Widget; 

Args : in Xt_Arg_List) return Xw_Text_Source_Ptr; 

pragma Builtin (Xw_String_Source_Create, 2419); 

Ada interface to the widget procedure XwStringSourceDestroy 

procedure Xw_String_Source_Destroy (Src : in Xw_Text_Source_Ptr); 
pragma Builtin (Xw_String_Source_Destroy, 2420); 

Ada interface to the widget procedure XwMoveFocus 
procedure Xw_Move_Focus (W : in Widget); 
pragma Builtin (Xw_Move_Focus, 2421); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 


Page 96 




29 October 1990 


STARS-RC-00980/001/00 


Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 
procedure Xt_Set_Arg 


(Arg : out Xt_Arg; 

Name : in String; 

Value : in Xw_Alignment); 


pragma Builtin (Xt_Set_Arg, 2422); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw.Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xv_Verify_Op_Type 
Xw_Source_Type 
Xw.Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw.Alignment); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xv_Edit_Type 


Page 97 







29 October 1990 


STARS-RC-00980/001/00 


Xw_Edit_Result 

Xw_Verify_Op_Type 

Xw_Source_Type 

Xw.Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 
procedure Xt_Set_Arg 


(Arg : out Xt.Arg; 

Name : in String; 

Value : in Xv_Widget_Type); 


pragma Builtin (Xt_Set_Arg, 2423); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 

Xw_Alignment 

Xw.Widget _Type 

Xw_Scan_Direction 

Xw_Scan_Type 

Xw_Edit_Type 

Xw.Edit.Result 

Xw.Verify.Op.Type 

Xw.Source.Type 

Xv.Wrap 

Xw_Wrap_Form 

Xw.Wrap.Break 

procedure Xt_Set_Arg (List : in out Xt.Arg.List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw.Widget.Type); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw.Alignment 
Xw.Widget.Type 
Xw_Scan_Direction 
Xv_Scan_Type 
Xw_Edit_Type 
Xw_Edit.Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw.Wrap 


Page 98 








29 October 1990 


STARS-RC-009S0/001/00 


Xw_Wrap_Form 

Xw_Wrap_Break 

pxocedure Xt_Set_Arg (Arg : out Xt.Arg; 

Name : in String; 

Value : in Xw_5can_Direction); 

pragma Builtin (Xt_Set_Arg, 2424); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw_Edit_Type 
Xw_Edit.Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw.Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xv_Scan_Direction); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 

Xw_Alignment 

Xw_Widget_Type 

Xv_Scan_Direction 

Xw_Scan_Type 

Xw_Edit_Type 

Xw.Edit.Result 

Xw_Verify_Op_Type 

Xw_Source_Type 

Xw.Wrap 

Xw_Wrap_Form 

Xw_Wrap_Break 

procedure Xt.Set.Arg (Arg : out Xt.Arg; 

Name : in String; 


Page 99 









29 October 1990 


STARS-RC-n09S0/001/00 


Value : in Xw_Scan_Type); 
pragma Builtin (Xt_Set_Arg, 2425); 

This set of overloaded procedures provides a strongly typed, 

Ad_ version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 

Xw_Alignment 

Xw_Widget_Type 

Xw_Scan_Direction 

Xw_Scan_Type 

Xw_Edit_Type 

Xw_Edit_Result 

Xw_Verify_Op_Type 

Xw_Source_Type 

Xw_Wrap 

Xw_Wrap_Form 

Xw_Wrap_Break 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Scan_Type); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw.Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xw_Verify_Op_Type 
Xv_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (/rg : out Xt_Arg; 

Name : in String; 

Value : in Xw_Edit_Type); 

pragma Builtin (Xt_Set_Arg, 2426); 

This set of overloadad procedures provides a strongly typed. 


Page 100 








29 October 1990 


STARS-RC-009SG./001/00 


Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 

Xw_Alignment 
Xv_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xv_Edit_Type 
Xw_Edit_Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 
procedure Xt_Set_Arg 


(List 

Subscript 

Name 

Value 


in out Xt_Arg_List; 
in Integer; 
in String; 
in Xw_Edit_Type); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xv_Alignment 
Xv_Widget.Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xw_Verify_0p_Type 
Xw_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (Arg : out Xt_Arg; 

Name : in String; 

Value : in Xw_Edit_Result); 
pragma Builtin (Xt_Set_Arg, 2427); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw.Alignment 


Page 101 





29 October 1990 


STA RS-RC-00980/001 /00 


Xw_Widget_Type 

Xw_Scan_Direction 

Xw.Scan.Type 

Xw_Edit_Type 

Xw_Edit_Result 

Xw_Verify_Op_Type 

Xw_Source_Type 

Xw.Wrap 

Xw.Wrap.Form 

Xw_Wrap_Break 

procedure Xt.Set.Arg (List : in out Xt.Arg.List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xv_Edit_Result); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw.Edit.Type 
Xw.Edit.Result 
Xw_Verify_Op_Type 
Xw.Source.Type 
Xw.Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (Arg : out Xt.Arg; 

Name : in String; 

Value : in Xw.Verify.Op.Type); 
pragma Builtin (Xt_Set_Arg, 2428); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw.Alignment 
Xw_Widget.Type 
Xw.Scan.Direction 
Xw.Scan.Type 
Xw.Edit.Type 


Page 102 





29 October 1990 


STARS-RC-00980/001/00 


Xw_Edit_Result 

Xw_Verify_0p_Type 

Xw_Source_Type 

Xw_Wrap 

Xw_Wrap_Form 

Xw_Wrap_Break 


procedure Xt_Set_Arg (List 

: in out Xt.Arg.List; 

Subscript 

: in Integer; 

Name 

: in String; 

Value 

: in Xv_Verify_Op_Type); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xw_Verify_Qp_Type 
Xw_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (Arg : out Xt_Arg; 

Name : in String; 

Value : in Xv_Source_Type); 
pragma Builtin (Xt_Set_Arg, 2429); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
X w_ W idget _Type 
Xw_Scan_Direction 
Xv_Scan_Type 
Xw_Edit_Type 
Xw_Edit.Re.sult 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw_Wrap 


Pago 103 






29 October 1990 


STARS-RC-00980/001/00 


Xw_Wrap_Form 
Xw_Wrap_Break 
procedure Xt_Set_Arg (List 

Subscript 

Name 

Value 


in out Xt_Arg_List; 
in Integer; 
in String; 
in Xv_Source_Type); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xv_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw.Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (Arg : out Xt_Arg; 

Name : in String; 

Value : in Xw.Wrap); 

pragma Builtin (Xt_Set_Arg, 2430); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget_Type 
Xw_Scan_Direction 
Xv_Scan_Type 
Xw_Edit_Type 
Xw_Edit_Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 


Page 104 






29 October 1990 


STARS-RC-00980/001/00 


Name 

Value 


: in String; 

: in Xw.Wrap); 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw_Alignment 
Xw_Widget.Type 
Xw_Scan_Direction 
Xw_Scan_Type 
Xw.Edit.Type 
Xw_Edit_Result 
Xw_Verify_Op_Type 
Xw_Source_Type 
Xw_Wrap 
Xw_Wrap_Form 
Xw_Wrap_Break 


procedure Xt_Set_Arg (Arg 

Name 

Value 


out Xt_Arg; 
in String; 
in Xv_Wrap_Form); 


pragma Builtin (Xt_Set_Arg, 2431); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 

Xw_Alignment 

Xw_Widget_Type 

Xw_Scan_Direction 

Xw_Scan_Type 

Xv_Edit_Type 

Xw_Edit_Result 

Xw_Verify_Op_Type 

Xw_Source_Type 

Xw_Wrap 

Xw_Wrap_Form 

Xw_Wrap_Break 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xv_Wrap_Form); 


Page 105 







29 October 1990 


STARS-RC-00980/001/00 


This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 

Xw.Alignment 

Xw.Widget.Type 

Xv.Scan.Direction 

Xv.Scan.Type 

Xw.Edit.Type 

Xw.Edit.Result 

Xw.Verify.Op.Type 

Xw.Source.Type 

Xw.Wrap 

Xw.Wrap.Form 

Xw.Wrap.Break 

procedure Xt.Set.Arg (Arg : out Xt.Arg; 

Name : in String; 

Value : in Xw.Wrap.Break); 

pragma Builtin (Xt.Set.Arg, 2432); 

This set of overloaded procedures provides a strongly typed, 

Ada version of the C macro XtSetArg. 

The overloading provided here permits the Value parameter to be one 
of the enumerated types defined in this package, namely: 
Xw.Alignment 
Xw_Widget.Type 
Xw.Scan.Direction 
Xv.Scan.Type 
Xw.Edit.Type 
Xw.Edit.Result 
Xw.Verify.Op.Type 
Xw.Source.Type 
Xw.Wrap 
Xw.Wrap.Form 
Xw.Wrap.Break 

procedure Xt.Set.Arg (List : in out Xt.Arg.List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw.Wrap.Break); 

end Hp.Widgets; 


with Intrinsics; 
with Widget.Package; 

Page 106 





29 October 1990 


STARS-RC-00980/001/00 


package body Hp.Widgets is 
use Widget.Package; 
use Intrinsics; 
use Xt_Ancillary_Types; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Alignment) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Widget_Type) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt.Set.Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt„Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Scan_Direction) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp.Xt.Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Scan_Type) is 

Temp_Xt_Arg : Xt.Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 


Page 107 




29 October 1990 


STARS-RC-00980/001/00 


procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Edit_Type) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt.Set.Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Edit_Result) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Verify_Op_Type) 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xv_Source_Type) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt.Set.Arg; 

procedure Xt_Set_Arg (List : in our Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xv_Wrap) is 

Temp_Xt_Arg : Xt_Arg; 


is 


Page 108 






29 October 1990 


STARS-RC-00980/001/00 


begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 
Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 


procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw.Wrap.Form) is 

Temp_Xt_Arg : Xt.Arg; 
begin 

Xt_Set_Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

procedure Xt_Set_Arg (List : in out Xt_Arg_List; 

Subscript : in Integer; 

Name : in String; 

Value : in Xw_Wrap_Break) is 

Temp_Xt_Arg : Xt_Arg; 
begin 

Xt.Set^Arg (Temp_Xt_Arg, Name, Value); 

Put (List, Subscript, Temp_Xt_Arg); 
end Xt_Set_Arg; 

end Hp.Widgets; 

8 More Information About Some Ace Features 

This section provides a detailed look at some Ace ADTs, to help the user become familiar 
with the functionality they provide. 

8.1 Xt Toolkit Interface 

The Xt toolkit is a library of functions that provide an object-oriented approach to the 
X windowing system. The toolkit consists of a set of basic procedures, called intrins/cs 
and a set of facilities for creating window objects called widgets. Widgets are individual 
representatives of widget classes. While the Xt toolkit permits the creation of new widget 
classes, many sets of widget classes are already available in the public domain. 

ACE provides an Ada interface to a subset of the Xt intrinsic functions and to a complete 
set of widget classes, namely, those offered in the Hewlett-Packard widget set. This section 


Page 109 









29 October 1990 


STARS-RC-00980/001/00 


is not intended as a detailed description of either the Xt intrinsics or the Hewlett-Packard 
widget set, for which appropriate documentation is available from the respective distributors. 
I his section describes only those features of the ACE interface that differ from a compiled 
interface to these libraries. 


8.1.1 Xt Prototyping Sessions 

The Xt toolkit assumes that an application will be driven entirely from the X windows that it 
creates. Each Xt application consists, therefore, of two distinct parts. The initialization code 
creates the application’s windows, panels, and pushbuttons. After the initialization code has 
run, control is given to an endless event-handling loop. The event loop responds to events 
such as pointer motions and keyboard input by calling user-defined response code through 
a mechanism known as callback. In the Xt toolkit’s view of an application, this process 
continues as long as the application. That is, when the windowing part of the application is 
finished, so is the application program itself. 

In order to provide this view of an application without requiring ACE to be restarted, the 
ACE interface provides a means of creating separate Xt sessions. Each Xt session appears 
to the Xt toolkit as a new application program. 


8.1.1.1 Starting an Xt Prototyping Session. To begin a new Xt session, the ACE 
user should use the routine XtJnitialize. When the Xt session begins, ACE will signal the 
user by changing its prompt from 

ACE> 


to 


ACE Xt> 

Calling XtJnitialize not only begins an Xt session, but also performs the toolkit functions 
associated with this procedure. For this reason, it is an error to call this procedure once the 
Xt session has started, since this would appear to the Xt toolkit as if an application were 
trying to initialize twice, a violation of the Xt toolkit’s rules. 

Also, if the XtJnitialize procedure is called from some other procedure, the code following 
it will be interpreted twice, once in the Xt session, and again after the Xt session is finished. 
If the following code contains certain calls to the Xt toolkit, the toolkit’s error action, taken 
when these calls are performed outside the Xt prototyping session, can cause ACE to exit. 
It is therefore a good practice not to call this procedure as part of some other procedure 
(unless calling XtJnitialize is the only instruction, as shown in the example below). 

The Ada specification of the XtJnitialize procedure is given below. 


Page 110 






29 October 1990 


STARS-RC-00980/001/00 


procedure Xt.Initialize 

(Out.Value : out Intrinsics.Widget; 

Name : in String; 

Classname : in String; 

Urlist : in X_Windows.Resource_Manager.Xrm.Option.Desc.List; 

Num.Urs : in Intrinsics.Cardinal; 

Argc : in out Intrinsics.Cardinal; 

Argv : in out Renamed.Xlib.Types.Argv.Type); 

After the Xtjnitialize procedure has been called, the Out-Value parameter will contain the 
value of the shell widget, which is used as the ultimate ancestor for all other widgets created 
during the Xt prototyping session. 

Because the Xtjnitialize procedure requires a complex set of arguments, it will be convenient 
to create an argument-free procedure that calls it. For the reasons given above, the call to 
Xtjnitialize should be the only instruction in such a procedure. A typical version of such a 
procedure is shown below. 

procedure Start.Xt is 

Argc : Intrinsics.Cardinal := 0; 

Argv : Renamed_Xlib_Types.Argv.Type 0; 
begin 

Xt.Initialize (Shell.Widget, 

Widget.Package.Null.Xrm.Option.List, 0, 

Argc, Argv); 

end Start.Xt; 

Currently, ACE does not provide any means of creating objects of either the type Xrm_Option_DcscJ, 
or the type Argv.Type. Therefore, the values shown in this example for the parameters L'rlist. 
Num-Urs , Argc , and Argv are the only values allowable. 


8.1.1.2 Finishing an Xt Prototyping Session To end an Xt prototyping session, the 
user should cause ACE to interpret the instruction 

exit ACE; 

That is, the same instruction that is normally used to end an ACE run will also end an Xt 
prototyping session. When used from such a session, however, ACE will not end, but will 
return to its normal mode of operation, with its original user prompt. 

This instruction will normally be part of a callback procedure. A typical means of ending an 
application that uses the Hewlett-Packard widget set is to incorporate a pushbutton widget 
whose selection callback is a procedure that performs this instruction. 


Page 111 








29 October 1990 


STARS- RC-00980/001 /00 


In the current version of ACE, any callback routine that fails to execute properly, that is. 
any routine that raises an exception, will also cause the Xt prototyping session to end. 


8.1.2 Xt Argument Lists 

Most of the Xt routines are parameterized by lists of pairs, with each pair consisting of a 
resource name and a resource value. Because ACE does not support arrays, special routines 
are provided to manipulate such lists. The Ada specifications of these routines are shown 
below. 


procedure Create 


(Arg.List 

First 

Last 


out Xt.Arg.List; 
in Integer; 
in Integer); 


procedure Put (Arg_List 
Subscript 
Value 


out Xt_Arg_List; 
in Integer; 
in Xt.Arg); 


function Get 

(Arg.List : in Xt_Arg_List; 

Subscript : in Integer) return Xt.Arg; 


function Get (Arg.List 
First 
Last 


in Xt_Arg_List; 
in Integer; 

in Integer) return Xt_Arg_List; 


The Create procedure reserves space for an argument list and assigns upper and lower bounds. 
The Put procedure assigns a value to a specified member of an argument list. The Get 
function with a single Integer parameter returns the value of a member of an argument list, 
while the Get function with two Integer parameters returns a specified slice. 

To create values of the type Xt.Arg suitable for inclusion in argument lists, ACE provides the 
Xt toolkit procedure XtJSet^Arg. Since the elements of argument lists are of many different 
types, the XtJSet-Arg procedure is overloaded many times. All of its overloaded versions, 
however, conform to one of two basic patterns. 

In the first pattern, XtJSet.Arg is used to create a single value of type Xt^Arg, as shown 
below. 


procedure Xt_Set_Arg 


(Arg 

Name 

Value 


out Xt.Arg; 
in String; 

in Some.Value.Type); 


Page 112 









29 October 1990 


STARS-RC-00980/001 /00 


In the second pattern, an argument value is built and inserted directly into an argument list, 
as shown below. 


procedure Xt_Set_Arg (List 

: in out Xt_Arg_List; 

Subscript 

: in Integer; 

Name 

: in String; 

Value 

: in Some_Value_Type); 


The reader should consult Xt toolkit documentation for the allowable resource names and 
value types. 


8.1.3 Xt Callbacks 

The Xt toolkit supports two kinds of user response procedures, called callback procedures 
and action procedures. From the programmer’s point of view, there is little difference be¬ 
tween these two kinds of procedures. Both kinds are registered with the toolkit during the 
initialization part of an Xt application and both are called by the event-handling loop in 
response to some set of events. 


8.1.3.1 Callback Procedures. Callback procedures are associated with specific call¬ 
back points provided by each widget class. Callback procedures are registered through the 
procedure Xt^Add-Callback , whose Ada specification is given below. 


procedure Xt_Add_Callback (W 

Name 

Callback.Proc 

Closure 


in Intrinsics.Widget; 
in String; 
in System.Address; 
in Integer); 


To obtain a value for the Callback.Proc parameter, the ACE user should use the function 
Callback.ProcedureJ-’ointer, which accepts a callback procedure’s name, in the form of a 
string, and returns a value that ACE can use as the callback procedure’s address. The 
Closure parameter is an arbitrary value that will be passed to the callback procedure when 
it is called. The typical use of this parameter is to permit a callback routine to be registered 
more than once and to distinguish the two registrations. 

Every callback procedure must conform (except for the names of the procedure and its 
parameters) to the following specification. 


procedure Typical.Callback 


(W 

Client_Data 

Call_Data 


in Intrinsics.Widget; 
in Integer; 
in Integer); 


Page 113 






29 October 1990 


STARS-RC-00980/00] /00 


When the procedure is called, the second parameter {Client.Data) will be a copy of the 
Closure parameter given at registration. The meaning of the third parameter (Call-Data) is 
defined by each widget class. 

Callback procedures should be either independent compilation units or should be at the top 
level of some package. That is, callback procedures should not be nested inside other proce¬ 
dures. The results of registering and invoking nested callback procedures are unpredictable. 


8.1.3.2 Action Procedures. Action procedures can be associated with various events, 
such as pointer motions and keyboard input, that are not specific to a single widget class. 
The use of action procedures involves two distinct steps. First, the procedures are registered 
with the Xt toolkit by using the Xt_Add^\ctions procedure. The Xt.Add-Actions procedure 
takes a single argument of type Xt^Argdjist. The elements of this list consist of pairs whose 
first element is a string containing an arbitrary symbolic name for the action procedure and 
whose second element is a procedure pointer. 

To obtain values for the required procedure pointers, the ACE user should use the function 
Action.Procedure.Pointer, which accepts an action procedure’s name, in the form of a string, 
and returns a value that ACE can use as the action procedure’s address. 

Every action procedure must conform (except for the names of the procedure and its param¬ 
eters) to the following specification. 

procedure Typical_Action (W : in Intrinsics.Widget; 

E : in X_Windows.Events.Event; 

Args : in X_Windows.String_List ); 

Since the current version of ACE does not provide support for manipulating the Event and 
String.List types, the second and third parameters are not currently useful, but they must 
nevertheless be declared. 

After symbolic names have been assigned to action procedures by Xt.AdcLActions , these sym¬ 
bolic names are used by an Xt toolkit facility called translation, whose task is to translate the 
symbolic names of the action procedures and the (predefined) symbolic names of events into 
the proper widget structures. The relevant Xt routines that cause these things to happen are 
XtJ-’arse.Translation.Table, Xt.Override.Translations, and Xt^Augment-Translations. For 
further information on these routines, the user should consult Xt toolkit documentation, 
since ACE does not impose any of its own constraints on their use. 

Action procedures should be either independent compilation units or should be at the top 
level of some package. That is, action procedures should not be nested inside other proce¬ 
dures. The results of registering and invoking nested action procedures are unpredictable. 

For implementation reasons, no more than thirty-two action procedures may be registered 
by any one Xt prototyping session. Calling the function ,4c/ ion.ProcedureJ^ointer more than 


Page 114 






29 October 1990 


STARS-RC-00980/001/00 


thirty-two times in one Xt prototyping session will produce an error message and will not 
register the action procedure. There is no similar limit on the number of callback procedures, 
however. 


8.1.3.3 Callback Interpretation. Because callback and action procedures are actually 
interpreted by ACE, there is more flexibility in ACE callbacks than in compiled code. In par¬ 
ticular, the parameter supplied to the Callback-Procedure.Pointer and Action JProcedureJPointer 
functions is not confined to simply the names of valid callback and action procedures, but 
may be any valid seqence of Ada statements ending with such a name. 

Since this has no equivalent in compiled code, the ACE user should use this feature very 
sparingly; otherwise, the eventual transition to a compiled application will be more difficult. 

This feature does have one important application in ACE, however. It permits input events 
to be associated with ACE’s debugging pragmas. For example, if the ACE user wants a 
pushbutton that will cause ACE’s trace facility to start, he can use 


Xt_Add_Callback 

(Button_Widget, Xt_N_Select, 

Callback_Procedure_Pointer ("pragma TRACE (On); No_0p"), 0); 


where No-Op is a callback procedure that does nothing. 


8.1.3.4 Prototyping Callbacks. The usual method for prototyping Xt code in ACE 
will be to test each version of the code in a separate prototyping session. Because ACE call¬ 
backs are interpreted, however, callback code can be changed without ending the prototyping 

session. 

This does require special care on the part of the ACE user. In a usual Xt application, the 
initialization part of the application ends by calling the procedure XtJAaindjOop, which is 
available in the ACE interface. This procedure is an endless event-handling loop, which does 
not end until the application itself is finished. 

The following procedure, which performs exactly the same functions as XtJAainJjOop , can 
also be entered in the ACE Xt interface. 


procedure My_Main_Loop is 

E : Event; 

C : Intrmsics . Xt_App_Context 


begin 

loop 

E 


Xt_App_Next_Event (C); 


Xt.Default_App_Context; 


Page 1 15 




29 October 1990 


STARS-RC-00980/001 /00 


Xt_Dispatch_Event (E); 
end loop; 
end My_Mam_Loop; 


The advantage of using such a loop instead of XtJAain-Loop , however, is that the routine 
shown above can be interrupted and resumed. While this loop is running, the ACE interrupt 
key will cause it to stop, and the ACE Continue procedure will cause it to resume. 

While the loop is interrupted, the user is free to change the contents of a callback or action 
procedure. Thus, such procedures can be altered without ending the prototyping session. 

The user should be prepared for some peculiar effects when using this facility. While the 
event loop is interrupted, nothing will be handling the events for the~Xt application. This 
means, for example, that if the application window is covered and re-exposed, it will not be 
refreshed until the loop resumes. 

The user should also be aware that the Xt-App-Next-Event function does not return until 
an event occurs. In practice, this means that the ACE interrupt key will not take effect 
until after some event occurs in the Xt application. The typical sequence of operations for 
interrupting this loop, therefore, will be: 


• Move the mouse pointer to the ACE window 

• Enter the interrupt key 

• Move the mouse pointer to an Xt application widget (to cause an event) 

• Return the pointer to the ACE window (to enter new callback code) 


8.1.4 Transition to Compiled Code 

The purpose of the ACE interface to the Xt toolkit is to permit the prototyping of applica¬ 
tions that will eventually be compiled. For this reason, great care has been taken to make 
the ACE interface nearly the same as the compilable Ada bindings to the Xt toolkit. Once a 
given application has been successfully prototyped in ACE, it should be possible to compile 
the same code with very few changes. A few changes will be necessary, however, which are 
noted below. 


• Procedure Pointers 

References to the functions Callback-Procedure-Pointer and Action-Procedurc-Pointrr 
should be replaced by an appropriate compilable means of obtaining a procedure 
pointer. For some Xt bindings, this will be the Ada ADDRESS attribute, while others 
will require procedure pointers to be obtained by generic instantiation. 


Page 11G 






29 October 1990 


STARS-RC-00980/001/00 


As noted above, there is no compilable equivalent to ACE's ability to create procedure 
pointers from a sequence of Ada statements. Parts of the application that use this 
ability must be either eliminated or rewritten. 

• Array References 

The use of ACE procedures that eliminate array references should be replaced by the 
appropriate subscripted expressions or slices. 

In particular, the overloadings of the XtJSet-Arg procedure that take a list and a 
subscript as separate arguments will not be available in compilable Xt bindings; these 
should be replaced by a single subscripted argument. 

Also, the Get function that returns a slice of an XLArg.List will not be available, and 
should be replaced by array slice expressions. Such slices will usually be arguments to 
the procedures Xt-Add-Actions, XLCreate.Widget, and Xt.Create_Managed_ Widget. 

• Ending the Application 

Since the statement exit ACE; has no equivalent in compiled Ada, it must be replaced 
by some other means of ending the application. This can take the form of interfacing 
to the host computer’s process termination routine, or can be implemented by raising 
an unhandled exception. 


8.1.5 A Small Example 

The following is an example of how the ACE Xt interface might be used. Once this example 
has been entered, it is run in the following way: 


• Run the procedure StartJKt. 

• When the prompt changes to the Xt prototyping prompt, run the procedure Aloha. 

• The screen should now show a small panel with two buttons labelled ’’Hello” and 
’’Goodbye”. Pressing the left mouse button with the pointer in the ”Hello” button will 
cause the application to print ”Hello”; pressing the ”Goodbye” button will cause the 
application to print "Goodbye” and end the prototyping session. 


Not all of the Ada use statements shown below are actually needed to run this example. 
They will be required, however, to extend it. 


use System; 
use Strings; 
use Text.Io; 
use X.Windows; 
use Fonts; 


Page 117 







29 October 1990 


STARS-RC-00980/001/00 


use Events; 
use Resource_Manager; 
use Renamed.Xlib.Types; 
use Intrinsics; 
use Xt_Ancillary_Types; 
use Widget.Package; 
use Xt.Stringdefs; 
use Hp_Widgets; 

Shell.Widget : Widget; 

procedure Start.Xt is 

Argc : Cardinal := 0; — 

Argv : Argv.Type := 0; 
begin 

Xt.Initialize (Shell.Widget, Null.Xrm.Option.List, 0, Argc, Argv); 

end Start.Xt; 

procedure Message (W 

Client.Data 
Call.Data 

begin 

if Client.Data = 0 then 
Put.Line ("Hello"); 
else 

Put.Line ("Goodbye"); 
exit Ace; 
end if; 
end Message; 

procedure Aloha is 

My.Xt_Arg.List 
Panel 
Button1 
Button2 

begin 

Create (My.Xt_Arg.List, 1, 20); 

Xt.Create.Managed.Widget (Panel, Xw.Row.Col.Widget.Class, 

Shell.Widget, Null.Xt.Arg.List); 

Xt.Set.Arg (My.Xt.Arg.List, 1, Xt.N.Label, "Hello"); 
Xt.Create.Managed.Widget 

(Buttonl, Xw.Push.Button.Widget.Class, Panel, 

Get (My.Xt.Arg.List, 1, 1)); 


: Xt.Arg.List; 
: Widget; 

: Widget; 

: Widget; 


: in Widget; 

: in Integer; 

: in Integer) is 


Page 118 







29 October 1990 


STARS-RC-00980/001/00 


Xt_Add_Callback (Buttonl, Xt_N_Select, 

Callback_Procodure_Pointer ("Message"), 0); 

Xt_Set_Arg (My_Xt_Arg_List, 1, Xt.N.Label, "Goodbye"); 
Xt_Create_Managed_Widget 

(Button2, Xw_Push_Button_Widget_Class, Panel, 

Get (My_Xt_Arg_List, 1, 1)); 

Xt_Add_Callback (Button2, Xt_N_Select, 

Callback.Procedure.Pointer ("Message"), 1); 

Xt.Realize.Widget (Shell.Widget); 

Xt.Main.Loop; 
end Aloha; 

8.2 The Key.Bind.ings Package 

The package, Key-Bindings, provides the user with Ada routines to edit command line 
input, and recall earlier lines. It also supplies the mechanism to invoke a specified Ada 
procedure by a user designated keystroke. These capabilities can greatly enhance the day- 
to-day environment of a development programmer. 

Ace is able to provide these capabilities because it now maintains a log of the input (within 
the bounds of the user specified limit), which is available to the history routines declared 
in Key-Bindings, and finds the binding associated with each keystroke (or sequence of 
keystrokes) and calls the routine indicated by the binding. Usually that will be DoSelf-Insert. 
But there are many other things one might want to do, and the code to accomplish some of 
those things is already written, and available to the user at the touch of a key, for the paltry 
price of a call to Make-Binding. 


8.2.1 Making Bindings 

The package Key-Bindings contains the procedures that will associate a routine with a 
keystroke, or sequence thereof, and also all the empowered binding choices (command names). 
When Ace is started a set of default bindings is installed. Each printable ASCII character 
(from space to tilde) is bound to DoSelf-Insert. Carriage return and line feed are bound to 
LineSeparator. The user’s environment is checked to find out which key the user normally 
uses for deleting characters and that key is bound to Delete. 

It is necessary to always have at least one character bound to LineS eparator, and the 
Make-Binding procedures enforce this rule by refusing to cooperate with a request to change 
the binding of the last thing currently bound to LineSeparator. This requirement exists 
because the LineSeparator binding is the only signal to Ace that a line of input has been 
completed. 

In order to obtain the services of any of the other provided routines the user must make the 
appropriate call to Make-Binding. The specifications for the two versions of MakeSinding 


Page 119 







29 October 1990 


STARS-RC-00980, 001/00 


are: 


procedure Make_Binding 


(C 

Binding 

Optional_String 


in Character; 
in Commands; 
in String := 


procedure Make.Binding (Char_Seq : in String; 

Binding : in Commands; 

0ptional_String : in String := ""); 

The first parameter of these procedures should be the value transmitted when the relevant 
key (or sequence) is struck. 

The legal choices for the Binding parameter are: 

Line_Separator 

Interpret_String 

History _Back 

History .Forward 

Move_Left 

MoveJRight 

Beginning_Of_Line 

End_Of_Line 

Start_Of_History 

End_Of_History 

Delete 

Delete_This_Char 

ShowJHistory 

ShowJRistoryJLimit 

Set.HistoryJLimit 

Kill_Line 

QuotedJnsert 

Refresh_Current_Line 

Refresh_Current_Line_And_Prompt 

Self-Insert 


The third parameter is needed only when the second parameter is set to InterpretJztring, 
which is explained below. Please note that it is meaningless to bind a function or procedure 
with parameters to a keystroke, because there is no way to communicate the return value 
to other parts of the code, nor to pass parameter values to the procedure. However, such 
routines can be manipulated through the use of Intcrpre.LSlring. 


Page 120 










29 October 1990 


STARS-RC-00980/001/00 


8.2.1.1 Using InterpretString. In addition to the provided routines the user can write 
Ada procedures of t heir own and bind them to a key via the InterpretjString procedure. To 
use this facility, the user should simply provide the procedure to be invoked and a binding 
for InterpretjString. For example: 


Make_Binding (Ascii.Esc & "[226z", 

Key_Bindings.Interpret_String, 
"My_Procedure;"); 


The third parameter is a string containing an Ada statement, exactly as it would appear 
in a unit of Ada code. Usually this statement will be a call to some routine, but it can be 
more. Some possible values are: 

• “Flag := Some_Function;” 

• “SomeJProcedure (Argl, Arg2);” 

• “Var := 0; Other .Procedure; Other _Var := Something;” 

Any variables appearing in such a string must be global and must be declared before the 
bound key is struck. This hypothetical routine, My-Procedure, in general, is just like any 
other routine written in Ace. However, its I/O must be done according to the guidelines 
given below. 


8.2.1.2 Intermixing I/O with KeyJBindings Routines. If the user wishes to include 
screen or keyboard oriented I/O, they may use TexLlo. However, the programmer must 
keep in mind that their procedure will be executed within the internal environment of Ace 
which has put the terminal in raw mode. Therefore it is necessary to place calls around 
the Text-Io routines, to reset the terminal before Text Jo is used, and then to set it back 
again before returning to Ace’s control. The same is true when using KeyJBindings routines, 
which assume that they know what the current line looks like and that the terminal is in 
raw mode. 

In addition to setting the terminal back to raw mode, the user must always call either 
Refresh-Current-Line-And-Prompt or Rewrite-Current-Line-And-Prompt , when entering the 
Ace-Command-Line Jnput or Key-Bindings environment. This routine will restore the screen 
so that the active line on the screen looks as it did before the user hit the key that caused 
My-Procedure to be invoked, (or restore a different value as the current line of input if the 
programmer prefers). The programmer should be certain that the cursor is positioned at 
the beginning of a line before making the call to restore the line. This is because, currently, 
there is no way for the Key-Bindings routines to clear away output they didn’t write, so you 
must be at the beginning of a line in order to ensure that the restored line looks ok. In a 
later release this requirement should go away. 

The prohibition against making calls to Text-Io routines, while in the cultural context of 
Ace or the Key-Bindings package, also applies in reverse: Key-Bindings routines (other than 
Terminal-Set) should not be called in the Text-Io (cooked) environment. This is because 


Page 121 









29 October 1990 


STARS-RC-00980/001/00 


those routines assume they know how the active line on the screen looks. To summarize, 
calls to Text.Io routines can be intermingled with Key-Bindings calls just so long as: 


• you are in cooked mode when making a Text-Io call 

• you are in raw mode when returning to Ace or when making a Key-Bindings call 

• if the terminal is reset to cooked mode, then a call to restore the active line on the 
screen must be made, after Terminal-Set, and before any Key-Bindings call or return 
to Ace 


When control enters My.Proccdure , the terminal will be in raw (set) mode. And after a call to 
any of the four Refresh/Rewrite procedures, the terminal will be in raw mode. To explicitly 
flip from one mode to the other, call Terminal-Set to gain the Ace-Command-Line-Input or 
Key-Bindings environment, or Terminal-Reset to prepare for calls to TextJo routines. 

Of course if My-Procedure doesn’t have any screen output or keyboard input then the terminal 
will stay set and Key-Bindings routines can be freely interspersed with other Ada code. All 
the Key-Bindings routines listed in the Bindings section can be used in My-Procedure , with 
the single exception of Interpret-String. 


8.2.2 An Example for Interpret-String 

Here is an example of what My-Procedure might look like: 


with Text.Io; 
with Ace_Integer_Io; 
with Strings; 

with Key_Bindings; use Key_Bindings; 

— This procedure copies the input typed so far, 

— a user supplied number of times 

procedure My_Procedure is 

Line : String (1 .. 1024); 

Length : Natural; 

The.Integer : Integer - 1; 

I : Integer :* 1; 

begin 

Do_Get_Current_Lme (Line, Length); 

Do_Kill_Line; 

Terminal_Eeset; — go to cooked mode 

Text.Io.Put ("How many times should this pattern be repeated?"); 


Page 122 






29 October 1990 


STA RS- RC-00980/001/00 


Ace_Integer_Io.Get (The.Integer); 

Terminal_Set; -- go to raw 

-- the carriage return the user ended the integer with 
-- prepaxes us for the insert 
while I <= The.Integer loop 

Do_Insert_String (Strings.Slice( Line, 1, Length)); 
I :■ I + 1; 
end loop; 
end My.Procedure; 


9 Supported Ada Features 

The command language of ACE is Ada. This section describes the language features of 
Ada that are currently supported by the ACE prototype. (Section 5 described the pragmas 
supported by ACE.) The Ada features implemented in the prototype version of ACE are 
those that are necessary to make use of Ada as a command language, those that are needed 
to provide a basis for the construction of abstract data types within the environment, and 
those that together form a logical collection of Ada functionality. This feature set includes 
packages, subprograms, subprogram derivation and overload resolution, assignment, condi¬ 
tional, iteration, termination, and return statments, and scalar types with type and subtype 
declarations. 

The following list summarizes the Ada language features currently implemented in ACE. 
The numbering scheme corresponds to that of the Ada Reference Manual. Qualifications 
on the level of support, if any, are given following the appropriate section. Support is not 
provided for those sections of the reference manual that are omitted from this list. 

As development is continuing for ACE, an explicit “Not Yet Supported” message is produced 
for those Ada features that are still being developed. However, a range of possibilities exist for 
the outcome when an incomplete feature of Ada within ACE is invoked. These possibilities 
include the generation of an Internal Error message, no error message or result due to the 
fact that the statement is parsed successfully and/or discarded, and successful execution of 
some portion of a partially implemented Ada feature. The following list should be consulted 
to verify that only supported features of Ada have been exercised. 


Ada Language Reference Manual Sections 
supported by ACE 


Page 123 







29 October 1990 


STARS-RC-00980/001/00 


2. Lexical Elements 

2.1 Character Set 

2.2 Lexical Elements, Separators, & Delimiters 

2.3 Identifiers 

2.4 Numeric Literals 

2.4.1 Decimal Literals 

2.4.2 Based Literals 

2.5 Character Literals 

Partial support for Character Literals is provided 

2.6 String Literals 

Partial support for String Literals is provided 

2.7 Comments 

2.8 Pragmas 

2.9 Reserved Words 

3. Declarations &: Types 

3.1 Declarations 

3.2 Objects & Named Numbers 

3.2.1 Object Declarations 

3.3 Types & Subtypes 

3.3.1 Type Declarations 

No support for incomplete.type-definition and privateJype-definition delcarations 

3.3.2 Subtype Declarations 
No support for constrmnts 

Page 124 









29 October 1990 


STARS-RC-00980/001/00 


3.4 Derived Types 

No support for constraint portion of subtype.Judication 

3.5.1 Enumeration Types 

No support for characterjiteral as enumeration literal 
No support for overloaded enumeration literals 

3.5.3 Boolean Types 

3.5.4 Integer Types 

Support only for predefined Integer 

3.6.3 The Type String 

Not supported as a one-dimensional array; 

Temporarily implemented as a developer’s string type —AceJitring 

3.9 Declarative Parts 
4. Names Ac Expressions 

4.1 Names 

4.2 Literals 

4.4 Expressions 

4.5 Operators Ac Expression Evaluation 

4.5.1 Logical Operators Ac Short-circuit Control Forms 
Short-circuit control forms ( and then, or else ) not yet supported 

4.5.2 Relational Operators & Membership Tests 

Membership tests (in) not yet supported 


Page 125 







29 October 1990 


ST A RS- RC-00980/ 001 / 00 


4.5.3 Binary Adding Operators 

4.5.4 Unary Adding Operators 

4.5.5 Multiplying Operators 

4.5.6 Highest Precedence Operators 

4.6 Type Conversions 

4.9 Static Expressions & Static Subtypes 

4.10 Universal Expressions 
Partial support for universal-integer 

5. Statements 

5.1 Simple &c Compound Statements - Sequence of Statements 
No support for statement label 

5.2 Assignment Statement 

5.3 If Statement 

5.4 Case Statement 

others , list of choices not yet supported 

5.5 Loop Statement 

for iteration scheme not yet supported 
loop simple name not yet supported 

5.7 Exit Statement 

loop name not yet supported 


Page 126 



29 October 1990 


STA RS- RC-00980/001/00 


5.8 Return Statement 
6. Subprograms 

6.1 Subprogram Declarations 

6.2 Formal Parameter Modes 

6.3 Subprogram Bodies 

Exceptions not yet supported, except for exception declarations 

6.3.1 Conformance Rules 

Legal variations in subprogram conformance not yet supported (numeric literals, simple vs. 
expanded name, string literal as operator symbol) 

6.4 Subprogram Calls 

Named association not yet supported 

6.4.1 Parameter Associations 

6.5 Function Subprograms 

6.6 Parameter & Result Type Profile - Overloading of Subprograms 

Complete overload resolution not yet supported (e.g. overloaded subprogram where an actual 
parameter is also overloaded, overloaded functions that differ only in return type) 

6.7 Overloading of Operators 

Check that proper number of parameters are given for the overloaded operator symbol used 
as a function designator not yet supported 


Page 127 









29 October 1990 

7. Packages 

7.1 Package Structure 

7.2 Package Specifications & Declarations 

7.3 Package Bodies 

exception part of a package not yet supported 

8. Visibility Rules 

Partial support of expanded names is provided 

8.1 Declarative Region 

Declarative blocks are partially supported 

8.2 Scope of Declarations 

8.3 Visibility 

8.4 Use Clauses 

8.6 The Package Standard 

8.7 The Context of Overload Resolution 
Partial support for overload resolution is provided 


STARS-RC-00980/001/00 


Page 128 






29 October 1990 


STARS-RC-009S0/001/00 


10. Program Structure & Compilation Issues 

10.1 Compilation Units - Library Units 

10.3 Order of Compilation 

10.5 Elaboration of Library Units 

10.6 Program Optimization 
14. Input-Output 

14.1 External Files and File Objects 

14.3 Text Input-Output 

14.3.1 File Management 

14.3.2 Default Input and Output Files 

14.3.3 Specification of Line and Page Lengths 

14.3.4 Operations on Columns, Lines, and Pages 

14.3.5 Get and Put Procedures 

14.3.6 Input-Output of Characters and Strings 

14.3.7 Input-Output for Integer Types 

Support for the predefined type Integer provided by the ACE package AceJntegerJo 

14.3.10 Specification of the Package TextJO 

14.4 Exceptions in Input-Output 

Exceptions not supported, except for expection declarations 

14.5 Specification of the Package IO_Exceptions 

Exceptions not supported, except for expection declarations 


Page 129 






29 October 1990 


STARS-RC-00980/001/00 


10 Examples 

This section provides some condensed examples of interactive sessions with ACE. These 
examples include illustrations of Ada being used as an interactive command language, ma¬ 
nipulating Ada subprograms and packages as data, and interfacing with the underlying host 
operating system. The use of the abstract data types described in previous sections, along 
with the Ada statements supported by this ACE prototype, are illustrated in these examples. 


10.1 Interactive Ada Example 
•/. ACE 

Ada Command Environment; Revision: 6.0 Date: 89/12/14 14:51:30 

Processing environment definition... 

ACE> 

ACE> — EXAMPLE INTERACTIVE ACE SESSION 

ACE> — This is a simple example of the development of Ada subprograms 
ACE> — that shows the use of ACE for interactive development. 

ACE> — This example makes use of the packages Text_I0 and 
ACE> — ACE_Integer_I0 of the ACE environment. It also shows examples 
ACE> — of declarations, procedures, functions, overload resolution, 
ACE> — the if statement, loop statement, return statement, assignment 
ACE> — statement, use statement and exit statement, and comments. 

ACE> 

ACE> use text_io; 

ACE> use ace_integer_io; 

ACE> 

ACE> — Develop a Put_Line routine for Integers 
ACE> procedure Put_Line (Item : in Integer) is 
I begin 

1 Put (Item); 

I New.Line; 

I end Put.Line; 

ACE> 

ACE> i : integer; 

ACE> i := 100; 

ACE> Put.Line (i); 

100 

ACE> 

ACE> 

ACE> — Develop a simple Put routine for Booleans 
ACE> procedure Put (Item : in Boolean) is 
I begin 

I Put (Boolean’Image(item)); 


Page 130 





29 October 1990 


STA RS- RC-009S0/001 / 00 


I end Put; 

ACE> 

ACE> b : boolean := false; 

ACE> Put (b) ; New.Lme; 

FALSE 

ACE> 

ACE> — Develop a routine to determine whether a number is prime 
ACE> function Is_Prime (n : in integer) return Boolean is 
| local : integer := 3; 

I begin 

| if n rem 2=0 then 

| return False; 

| end if; 

I 

| while local ** 2 <= n loop 
| if n rem local = 0 then 

| return False; 

| end if; 

| local := local + 2; 

| end loop; 

I 

| return True; 

| end Is_Prime; 

ACE> 

ACE> put (Is_Prime (7)); New_Line; 

TRUE 

ACE> put (Is_Prime (143)); New_Line; 

FALSE 

ACE> 

ACE> 

ACE> exit ace; 

Exiting ACE 


10.2 Manipulating Ada Components 
7. ACE 

Ada Command Environment; Revision: 6.0 Date: 89/12/14 14:51:30 

Processing environment definition... 

ACE> 

ACE> — Example of iterative development of an Ada subprogram 
ACE> — followed by incorporation of the subprogram into a 
ACE> — package that is stored to an external file. 

ACE> 


Page 131 









29 October 1990 


STARS-RC-00980/001 /00 


ACE> — Develop a Factorial routine 

ACE> function Fact (n : in integer) return integer is 
I begin 

I if n = 0 then 

I return 1; 

I else 

I — >» ERROR: will type + rather than * <« 

I return n + fact (n-1); 

I end if; 

I end; 

ACE> 

ACE> 

ACE> put (fact (4)); 

Error: could not find a valid subprogram specification: put 
ACE> 

AC£> — The above error is due to the fact that we have not yet 
ACE> — acquired direct visibility of the Put operation from the 
ACE> — package Ace_Integer_Io within Text.Io. 

ACE> 

ACE> — Use these packages 
ACE> use text_io; 

ACE> use ace_integer_io; 

ACE> 

ACE> put (fact (4)); New_Line; 

11 

ACE> 

ACE> — Fact produces an erroneous result. 

ACE> — Invoke the edit and re-interpret ADT to fix the 
ACE> — erroneous statement in the Fact function. 

ACE> 

ACE> edit_and_interpret ("fact"); 

Spawning a window for editing /sun/ace/src/fact,tmp 

— At this point, the editor is brought up and the 

— "+" is changed to a The changes axe written 

— out and the editor is terminated. 

ACE> — Display the revised Fact function 
ACE> list ("fact", both); 

function fact (n : in integer) return integer; 

— Form => " 819" 

function fact (n : in integer) return integer is 

— Form => " 819" 
begin 


Page 132 






29 October 1990 


STARS- RC-009S0/001 /00 


if (n = 0) then 
return 1; 
else 

return (n * fact((n - 1))); 
end if; 
end fact; 

ACE> Put (Fact (4)); New.Line; 

24 

ACE> 

ACE> Put (Fact (5)); New_Line; 

120 

ACE> ~ 

ACE> — Fact routine is now working. 

ACE> — Define a package into which Fact will be placed. 

ACE> 

ACE> package Math_Routines is 
I end; 

ACE> 

ACE> 

ACE> — Using the Program.Unit abstract data types and operations, 
ACE> — define a package object and a subprogram object. 

ACE> 

ACE> package_object : package_type; 

ACE> function_object : subprogram_type; 

ACE> 

ACE> — Associate the package object with Math_Rcmtines; 

ACE> — associate the function object with Fact 
ACE> 

ACE> open (package_object, out_prog_unit, "Math.Routines"); 

ACE> open (function_object, in_prog_unit, "Fact"); 

ACE> 

ACE> — Place the function object into the package object, 

ACE> — with the implementation of the function being placed 
ACE> — in the body of the package and visible in the package 
ACE> — specification. 

ACE> 

ACE> put (function.object, package_object, in.body, visible); 

ACE> 

ACE> — Display the package object, both spec and body 
ACE> 

ACE> list (package.object, both); 
package math_routines is 
— Form => " 825" 


Page 133 




29 October 1990 


ST A RS-RC-00980/001/00 


function fact (n : in integer) return integer; 

end math_routines; 

package body math_routines is 

function fact (n : in integer) return integer is 

begin 

if (n = 0) then 
return 1; 
else 

return (n * fact((n - 1))); 
end if; 
end fact; 

end math_routines; 

ACE> 

ACE> — Store the Math_Routines package in an external file 
ACE> 

ACE> put_file ( Name(package_object), "math_package.ada"); 

ACE> 

ACE> — End of ACE session 
ACE> exit ace; 

10.3 Interfacing with Host O/S (UNIX) 

*/. ACE 

Ada Command Environment; Revision: 6.0 Date: 89/12/14 14:51:30 
Processing environment definition... 

ACE> — Example of interacting with external Ada compilation 
ACE> — system and the underlying host operating system 
ACE> 

ACE> — Define a program text object 
ACE> program.object : program.text; 

ACE> 

ACE> — List out the contents of the current working directory 
ACE> list; 

Test.Cases 
a. out 
ada.lib 
find.priraes.a 
ACE> 


requirements 
math.package.ada 
test.data 


Page 134 








29 October 1990 


STARS-RC-00980/001/00 


ACE> — Associate the program text object with the file 

ACE> — find_primes.a 

ACE> 

ACE> open (program_object, in_object, "find_primes.a"); 

ACE> 

ACE> — List out the contents of the program.object 
ACE> 

ACE> list (program.object); 

with Text_Io; 

procedure Find.Primes is 

function Is.Prime (n : in integer) return Boolean is 
local : integer := 3; — 

begin 

if n rem 2=0 then 
return False; 
end if; 

while local ** 2 <= n loop 
if n rem local = 0 then 
return False; 
end if; 

local := local + 2; 
end loop; 

return True; 
end Is_Prime; 

package Int.Io is new Text.Io.Integer_Io (Integer); 
begin 

Text_Io.Put_Line ("PRIME NUMBERS FROM 2 .. 64"); 
for i in 2 .. 64 loop 
if Is.Prime (i) then 
Int_Io.Put (i); 

Text_Io.Put_Line (" is a prime number"); 
end if; 
end loop; 
end Find.Primes; 

ACE> 

ACE> — Submit the program text object to the external Ada 
ACE> — batch compilation system (Verdix VADS), where 
ACE> — Find_Primes is the name of the main compilation unit 
ACE> — and the executable image will be stored into the file 
ACE> — "find_primes.exe" 


Page 135 








29 October 1990 


STARS- RC-009S0/001/00 


ACE> 

ACE> compile (program.obj ect, "Fmd.Primes" , "find_pnmes.exe"); 

Compiling -M Find_Pnmes -o find_prlmes.exe /johndoe/f md.primes. a 

ACE> 

ACE> — Define a program binary object and execute it 

ACE> 

ACE> load_image : program.binary; 

ACE> open (load.image, in.object, "find.primes.exe"); 

ACE> 

ACE> execute (load.image); 

PRIME NUMBERS FROM 2 .. 64 

3 is a prime number 
5 is a prime number 
7 is a prime number 
11 is a prime number 
13 is a prime number 
17 is a prime number 
19 is a prime number 
23 is a prime number 
29 is a prime number 
31 is a prime number 
37 is a prime number 
41 is a prime number 
43 is a prime number 
47 is a prime number 
53 is a prime number 
59 is a prime number 
61 is a prime number 

ACE> 

ACE> — End of ACE session 

ACE> exit ace; 

Exiting ACE 


Page 136 








Index 

pkg. def. 25 

”**” pkg. def. 25 
”+” pkg. def. 25, 30 
pkg. def. 25, 30 
pkg. def. 25 

”/=” pkg. def. 24-25, 28 
pkg def. 24-25. 28, 30 
11 j=" pkg. def. 24-25, 28, 30 
”=” pkg. def. 24-25, 28 
7” pkg. def. 24-25, 28, 30 
7=” pkg. def, 24-25, 28, 30 
”abs” pkg. def. 25 
’’and” pkg. def. 24 
’’mod” pkg. def. 25 
"not” pkg. def. 24 
“or” pkg. def. 24 
”rem” pkg. def. 25 
"xor” pkg. def. 24 
pkg. def. 28 

abstract data types (ADT) 2-3, 8, 12-17, 
23, 109 

abstract data types and a command lan¬ 
guage 13 
Ace Adt 37 
Ace Integer Io 33 

Ace User X Window System 19, 57 

Ace X Window System 19. 56 

ACE 4 

ace_ada 4 

Ace_Adt 19 

ace_edit 4 

AceJntegerJo 18 

Ace Jo 18 

Ace_Standard 18 

ActionJ ) rocedureJ > ointer pkg. def. 75 
Action J > rocedureJ > ointer 114 
Ada language standard 1, 13 
Ada-oriented environment 18 
ADT Philosophy 12 
Append_To-Cais_Arg _I,ist pkg. def. 60 
applications 12 
Ascent pkg. def. 64 
ASCII 18 


Binary Files 16 
Binary Objects 19, 47 
bindings.ace 23 
Break pkg. def. 39 
built-in 17 

Cais Routines 19, 23, 59 
CAIS-A 59 
cais.ace 23 
Cais_Node_Kinds 59 
Cais -Relationship-Kinds 59 
Calendar 18, 30 

Callback-Procedure-Pointer pkg. def. 75 

Character Io 33 

Check-Style pkg. def. 61 

Clear_Break pkg. def. 39 

Clear_Window pkg. def. 56 

Clock pkg. def. 30, 63 

Close pkg. def. 32, 42. 47 

Close 14 

Col pkg. def. 33 

Column control 32 

command applicability 15 

command environmemt 13 

command extensibility 16 

command language 1, 15-16, 23, 123 

command language commands 20, 36 

command line editing 23 

command line history 23 

command specialization 15 

command structure 14 

commands.ace 23 

compilation units 2 

Compile pkg. def. 37, 45 

complete command 4 

consistency 14 

consistent objects and operations 15 
Continue pkg. def. 39 
Continue_Prompt 4, 7 
Copy pkg. def. 41 
Copy 16 

Count-Features pkg. def. 61 
Count-Statements pkg. def. 61 
Cpu Time 20, 23. 63 










29 October 1990 


STARS-RC-00980/001/00 


cpu_time.ace 23 

Create pkg. clef. 32. 42. 17. 57. 72. 112 
create ACE 5 
Create 14-16 

Create_Cais_Argument_List pkg. def. 60 
Create.Window pkg. def. 56 
Current_Ace_Input pkg. def. 35 
Current_Ace_Input 3 
Current_Ace_Output pkg. def. 35 
CurrentJDirectory pkg. def. 43 
Current-Input pkg. def. 32 
Current-Output pkg. def. 32 
data abstraction 12-13 
Day pkg. def. 30 
Debugger 7-8, 19, 39 
declarations 2 
Default Io files 32 

Delete pkg. def. 32, 37-38, 47-48, 57 
Delete 14, 16 
Delete_File pkg. def. 41 
derived subprograms 15 
Descent pkg. def. 64 
Destroy .Window pkg. def. 56 
Deuse pkg. def. 38, 48 
development approach 13 
DianaJJrowser pkg. def. 61 
Diana.Cleanlib pkg. def. 61 
Diana_Create_Predefined_Env pkg. def. 62 
Diana.Front.End pkg. def. 61 
Diana.MakeJPredefined_Env pkg. def. 62 
Diana_Mklib pkg. def. 61 
DianaJFtmlib pkg. def. 61 
Difference pkg. def. 63 
Directory Files 16 
Directory Objects 19, 42 
Display pkg. def. 39 
Display-Current-Statement pkg. def. 39 
Display-Next pkg. def. 39 
Display-Previous pkg. def. 39 
Do_Beg_Of_Line pkg. def. 54 
Do.Delete pkg. def. 54 
Do_Delete_This_Char pkg. def. 54 
Do_Get_Current_Character pkg. def. 55 
Do_Get_Current_Column pkg. def. 55 
Do_Get_Current_Line pkg. def. 54 


Do_Goto_End_Of_Historv pkg. def. 54 
Do_Goto_End_Of_Line pkg. def. 54 
Do_Goto_Start_Of_History pkg. def. 54 
Do-History-Back pkg. def. 54 
Do_History-Forward pkg. def. 54 
Do .Insert-Ascii pkg. def. 54 
DoJnsert-String pkg. def. 54 
DoJnterpret-String pkg. def. 54 
DoJKill_Line pkg. def. 54 
Do_Move2Left pkg. def. 54 
Do_Move_Right pkg. def. 54 
Do_Quoted_Insert pkg. def. 54 
Do_Refresh_Current-Line pkg. def. 54 
Do_Refresh_Current_Line_And-Prompt pkg. 
def. 54 

Do_Rewrite_Current_Line pkg. def. 54 
Do_Rewrite_Current_Line^\nd_Prompt pkg. 
def. 54 

Do-Self_Insert pkg. def. 54 
Do_Set_History_Limit pkg. def. 54 
Do_Show-History pkg. def. 54 
Do_Show-History-Limit pkg. def. 54 
DrawJDashed_Line pkg. def. 58 
Draw-Line pkg. def. 58 
Draw-Rectangle pkg. def. 58 
DrawJRectangleJBuiltin pkg. def. 58 
Draw-Text pkg. def. 58 
dynamic 2 
Edit pkg. def. 44 
Edit_And_Interpret pkg. def. 45 
Edit_File pkg. def. 44 
End_Of_File pkg. def. 32 
End_Of_Line pkg. def. 32 
End_Of_Page pkg. def. 32 
environment customize and tailor 12 
environment initialization 4 
environment 2 
error messages 123 
evolution 16 

Example of Interactive Ada 130 
Example of Interfacing with Host OS 134 
Example of Manipulated Ada Components 
131 

Example of Xt 117 

Example of multiple line input 4 


Page 138 





29 October 1990 


STARS-RC-009S0/001/00 


example of nesting commands 15 
example of Form parameters and overload¬ 
ing 9 

example startup.ace file 10 
Execute pkg. def. 47 
execute ACE 5 
execution of ACE 4 
existing environments 8 
Exists pkg. def. 41 
exit Ace 3, 111 
exit Ace_Level 3 
exit Ace_Main 3 
exit 3 

File Management 32 
file object 14 
file system 7, 16, 19, 41 
Form parameter 8, 14 
Form pkg. def. 32, 43, 48 
general file 16 

Get pkg. def. 33, 35, 72-73, 112 
Get_File pkg. def. 44 
Get_Line pkg. def. 33 
Help pkg. def. 50 
help 7, 19, 50 

hierarchical command environment 16 

home directory 9 

Home_Directory pkg. def. 43 

Host Os 19, 38 

Host pkg. def. 38 

host environment support tools 17 

host operating system 7. i7, 19, 38 

Hp Widgets 20, 84, 109 

incomplete command 4 

information hiding 12-13 

inheritance 16 

input and output 3, 14 

interactive 1-2 

interfaces 16 

Interlisp 1 

Interpret pkg. def. 37 
Interpret 9 

interpreted 7, 9, 16-17 
Interpret_File pkg. def. 37 
Interpret_File 12 
Intrinsics 20, 66 


Invoke_Process pkg. def. 59 
Io Exceptions 18. 29 
Is.Open pkg. def. 32. 43. IS 
Key Bindings 19, 23, 51, 119 
Length pkg. def. 36 
library files 8, 14, 23 
Line Counter 19 
Line control 32 
Line length 32 
Line pkg. def. 33 
Line_Length pkg. def. 32 
List Mode 35 

List pkg. def. 39, 43-44, 49, 51 
List 9 

List .Breakpoints pkg. def. 39 

List_Pile pkg. def. 44 

List_SymboLTable pkg. def. 39 

locality 12-13 

logical grouping 14 

Low Level Io 18, 30 

Main_Prompt 4, 7 

Make Bindings 119 

Make-Binding pkg. def. 52 

MakeJCt-String pkg. def. 67 

Manipulate Scope 19, 38 

Measure_Mccabe_Complexity pkg. def. 61 

Method of Execution 35 

Mode pkg. def. 32, 48 

modularity 12-13 

Month pkg. def. 30 

Name pkg. def. 32, 43, 48 

nested subprograms and packages 14 

New .Line pkg. def. 32 

New .Page pkg. def. 32 

NulLCaddr.T pkg. def. 66 

Null.Widget pkg. def. 66 

NulLWidget_Class pkg. def. 66 

Null_Xrm_Option_List pkg. def. 67 

Null_Xt_Arg_List pkg. def. 67 

Object Lister 19, 50 

object-oriented design 13 

Objects 2-3, 5, 18, 24 

observe.window.icn 5 

Off 5-7 

On 5-7 


Page 139 





29 October 1990 


STARS-RC-00980/001/00 


Open pkg. def. 32, 12, 47 
Open 8. 14 
operations 2-3. 13 

overloaded suprograms uniquely identified 

8 

overloading 15 
package ADT 8 
packages 13 
Page control 32 
Page length 32 
Page pkg. def. 33 
Page_Length pkg. def. 32 
pragma Continue_Prompt 7 
pragma Debug 6 
pragma Dump 6 
pragma Echo 6 

pragma List_Statement_Numbers 6 

pragma Main-Prompt 7 

pragma Observe 5 

pragma Trace 6 

pragma 3 

pramga Builtin 7 

pre-compiled 7 

Prefix_To-Cais_ArgJList pkg. def. 60 
Print pkg. def. 44 
Program Objects 19, 45 
Program Text Objects 19, 46 
Program Units 19, 47 
Put pkg. def. 33, 35, 49, 72. 112 
Put_Cais_File_Node_Host_Name pkg. def. 
60 

Put_Current_Cais_Node pkg. def. 59 
Put_CurrentJDirectory pkg. def. 43 
Put_File pkg. def. 44 
Put_Line pkg. def. 33 
Put_Time pkg. def. 63 
rapid prototyping 8 
Rename pkg. def. 41 
Rename 16 

Renamed Xlib Types 20, 65 
Reset pkg. def. 32. 42. 57 
runtime efficiency 17 
Seconds pkg. def. 30 
session 3 

Set_Ace_Input pkg. def. 35 


Set-Ace_Input 3 
Set-Ace_Output pkg. def. 35 
Set-Break pkg. def. 39 
Set-Col pkg. def. 32 
Set_Current_Cais_Node pkg. def. 59 
Set-Directory pkg. def. 43 
SetJnput pkg. def. 32 
Set-Line pkg. def. 33 
Set_Line_Length pkg. def. 32 
Set-Output pkg. def. 32 
Set_Page_Length pkg. def. 32 
Set_Up pkg. def. 62 
Skip-Line pkg. def. 32 
Skip-Page pkg. def. 32 
Slice pkg. def. 36 
Smalltalk 1 

software engineering 12 
Spawn-Process pkg. def. 59 
Split pkg. def. 30 
standard packages 23 
Standard 18, 23-24 
standard’s paradigm 14 
standard.ace 23 

Standard_AceJnput pkg. def. 35 

Standard-AceJnput 3 

Standard_Ace_Output pkg. def. 35 

Standard_Ace_Output 3 

StandardJnput pkg. def. 32 

Standard-Output pkg. def. 32 

Stars Tools 19. 61 

startup.ace 4, 9, 18 

Start-Xt pkg. def. Ill 

statement database 37 

statement number 8 

Statements 2, 5 

Step pkg. def. 39 

String Io 33 

Strings 18, 28, 36 

strong typing 15 

subprogram ADT 8 

Subprograms 5, 13 

Sun workstation 5 

system decomposition 13 

System 18 

system-dependent 8 


Page 140 








29 October 1990 


STARS-RC-009S0/001/00 


technology 16 

Temporary_Name pkg. <lef. 41 

Test_Case_Generator pkg. del. 62 

Test.Comparator pkg. def. 62 

Test_Procedures_Generator pkg. def. 62 

Test Jlesults_Analyzer pkg. def. 62 

Test_Updater pkg. def. 62 

Text Files 16 

Text Objects 19, 44 

Text Jo 3, 8, 31 

Text_Width pkg. def. 64 

Time.Of pkg. def. 30 

traditional view 7 

Undelete pkg. def. 38 

uniformity 14 

visibility 2 

Widget Package 20, 67 
widget 109 

Window Draw Routines 19, 58 
Window Objects 14, 19. 56, 109 
window environment 5 
windowing 8, 19, 23, 56 
windows.ace 23 
X Window System 5 
X Windows 20, 23, 64 
Xt Stringdefs 20 
Xt toolkit 63, 109 
Xt_Add_Actions pkg. def. 75 
Xt_Add_Actions 114 
Xt_Acld_Callback pkg. def. 73-74. 1L3 
Xt_App_Next JEvent pkg. def. 75 
Xt_ArgXist 114 

Xt_Augment_Translations pkg. def. 75 
Xt_Create_Managed_Widget pkg. def. 74 
Xt_Create_Widget pkg. def. 74 
Xt_Default_App_Context pkg. def. 75 
XtJ)estroy_Widget pkg. def. 74 
XtJDispatchJEvent pkg. def. 67, 75 
Xt_Get_Value pkg. def. 73 
XtJnitialize pkg. def. 67, 110 
Xt_MainJLoop pkg. def. 74 
Xt_Override_Translations pkg. def. 75 
Xt_Parse_Translation_Table pkg. def. 75 
Xt_Realize_Widget pkg. def. 74 


Xt2Set_Arg pkg. def. 68-72, 77-78. 96-107. 
109 

Xt_Set_Arg 112 
Xt_Set_Values pkg. def. 73 
Xw_Arrow_Widget_Class pkg. def. 92 
Xw_Ascii_Sink_Create pkg. def. 95 
Xw_Bulletin_Board_Widget_Class pkg. def. 

92 

Xw_Bulletin_Widget_Class pkg. def. 92 
Xw_Button_Widget_Class pkg. def. 92 
Xw_Cascade_Widget.Class pkg. def. 92 
XwJDisk-Source.Create pkg. def. 95 
XwJ)isk_Source_Destroy pkg. def. 95 
XwJ r orm_Widget_Class pkg. def. 92 
XwJmage_Edit_Widget_Class pkg. def. 92 
Xw Jdstrow.CoLWidget.Class pkg. def. 92 
XwXist.Widget.Class pkg. def. 92 
Xw_Manager_Widget_Class pkg. def. 92 
Xw_Menubutton_Widget_C'ass pkg. def. 92 
Xw_Menumgr_Widget_Class pkg. def. 92 
XwJVlenupane.Widget.Class pkg. def. 92 
Xw_MenuJ3utton_Widget_Class pkg. def. 

92 

Xw_Menu_Sep_Widget_Class pkg. def. 92 
Xw_Move_Focus pkg. def. 95 
Xw J^aneLWidget.Class pkg. def. 92 
XwJ > opupmgr_Widget_Class pkg. def. 92 
Xw J’opup.MgrJWidgetXlass pkg. def. 92 
Xw J 5 rimitive_WidgetXlass pkg. def. 92 
Xw Xush J3utton_WidgetXlass pkg. def. 

92 

XwJtowXoLWidgetXlass pkg. def. 92 
Xw_Sash_Widget_Class pkg. def. 92 
Xw_Scrollbar_WidgetXlass pkg. def. 92 
Xw_Scrolled_Window_Widget_Class pkg. def. 

92 

Xw_Scroll_Bar_Widget_Class pkg. def. 92 
Xw_Sraster_Widget_Class pkg. def. 93 
Xw_Statictext_WidgetXlass pkg. def. 93 
Xw_StaticJlaster_WidgetXlass pkg. def. 

93 

Xw2Static_Text._Widget_Class pkg. def. 93 
Xw_String_Source_Create pkg. def. 95 
Xw_String_SourceJ3estroy pkg. def. 95 
Xw_Swindow_WidgetXlass pkg. def. 93 


Page 141 










29 October 1990 


STARS-RC-00980/001/00 


Xw_Textedit_\Vidget_Class pkg. def. 98 
Xw.Text .Clear.Buffer pkg. def. 98 
Xw.Text.C’opyJBulFer pkg. del. 98 
Xw_Text_Copy_Selection pkg. def. 93 
Xw_Text_Edit_Widget_Class pkg. def. 93 
Xw.Text.Get.Insert_Pos pkg. def. 95 
Xw_Text_Get_Last_Pos pkg. def. 94 
Xw_Text_Get_Selection Jos pkg. def. 94 
Xw.Text Jnsert pkg. def. 94 
Xw.Text_Read_Sub_String pkg. def. 94 
Xw.Text .Redraw pkg. def. 94 
Xw.Text .Replace pkg. def. 94 
Xw_Text_Set Jnsert_Pos pkg. def. 95 
Xw_Text_Set_Selection pkg. def. 94 
Xw_Text_Set_Source pkg. def. 95 
Xw.Text.UnsetjSelection pkg. def. 94 
Xw.Text.Update pkg. def. 94 
Xw.Tidebar.Widget.Class pkg. def. 98 
Xw.Title.Bar.VVidget.Class pkg. def. 98 
Xw.Toggle.Widget.Class pkg. def. 9:5 
Xw.Valuator.Widg.c.Class pkg. def. 98 
Xw_Work_Space_Widget_Class pkg. def. 93 
X.Text.Width pkg. def. 75 
Year pkg. def. 30 


Page 142 






