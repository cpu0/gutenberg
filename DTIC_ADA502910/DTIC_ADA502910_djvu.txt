M ^ M Defence Research and Recherche ef developpement 
m ■ I Development Canada pour la defense Canada 


DEFENCE 



Simulation technologies for C 2 IS 
development & training 

Final report 

Thibault, D. U. 

DRDC Valcartier 


Defence R&D Canada - Valcartier 

Technical Report 
DRDC Valcartier TR 2007-412 
February 2008 


Canada 



Simulation technologies for C 2 IS 
development & training 

Final report 


Thibault, D. U. 
DRDC Valcartier 


Defence R&D Canada - Valcartier 

Technical Report 

DRDC Valcartier TR 2007-412 
February 2008 



Author 


Thibault, D. U. 
Approved by 


Guy Turcotte 
(Section Head) 

Approved for release by 


Christian Carrier 
(Chief Scientist) 


Work unit 12kr11 (2000), became 12sd11 in 2003 


© Her Majesty the Queen in Right of Canada as represented by the Minister of National 
Defence, 2008 

© Sa majeste la Reine (en droit du Canada), telle que representee par le ministre de la 
Defense nationale. 2008 






Abstract 


A functional overview of the High Level Architecture (HLA) distributed simulation 
standard Institute of Electrical and Electronics Engineers (IEEE) 1516 is provided. 
The Agent Oriented Software (AOS) intelligent software agent development 
environment, JACK, is described. Problems with the IEEE 1516 specification are 
identified and possible improvements outlined. A demonstration Internet Relay 
Chat (IRC)-like application is designed and implemented, which allows a Java 
application to interoperate with a JACK application through the HLA. A re-usable 
JACK capability is described which allows any JACK agent to participate in an 
HLA federation. A re-usable framework of Java classes implementing the HLA 
Object Model Template (OMT) encoding and decoding facilities is described. 
Finally, bugs are documented in JACK and the HLA Run-Time Infrastructure (RTI) 
used, and various design considerations and lessons learned are discussed. 


Resume 


Le fonctionnement de la norme de simulation repartie High Level Architecture 
(HLA) Institute of Electrical and Electronics Engineers (IEEE) 1516 est decrit de 
fai^on concise. L’environnement de developpement d’agents logiciels intelligents 
JACK d’Agent Oriented Software (AOS) est decrit. Des problemes sont identifies 
au niveau de la norme IEEE 1516 et des ameliorations possibles sont decrites. Une 
application semblable au clavardage Internet a ete cont^ue et implementee, 
permettant de demontrer comment HLA permet Linterfonctionnement d’une 
application Java avec une application JACK. Une capacite JACK reutilisable 
permettant a n’importe quel agent JACK de participer a une federation HLA 
quelconque est decrite. Un cadre de classes Java implementant les methodes de 
codage et d’encodage de l’Object Model Template (OMT) HLA est decrit. 
Finalement, les bogues de JACK et du Run-Time Infrastructure (RTI) HLA sont 
documentes, et diverses considerations et le 9 ons apprises discutees. 


i 


DRDC Valcartier TR 2007-412 






This page intentionally left blank. 


DRDC Valcartier TR 2007-412 



Executive summary 

Distributed simulation, both in its logical and geographical senses, allows one to 
leverage existing and future simulations to the best of their individual capabilities. 
Live, virtual, and constructive simulations are all susceptible to benefit from a 
distributed implementation. A live simulation involves real people operating real 
systems; the latter are modified (blanks instead of live ammunition, for example) or 
augmented (laser tag equipment, for example) in order to allow realistic action to 
occur without the actual risk of casualty or destruction. A virtual simulation 
involves real people operating simulated systems; the humans are in-the-loop in a 
central role, exercising motor control skills, decision, or communication skills. A 
constructive simulation , finally, involves simulated people operating simulated 
systems. Linder certain conditions, constructive simulations are the only ones that 
can be run at vastly increased simulated rates of time lapse. For example, an entire 
large-scale operation spread over days or weeks could be simulated in a matter of 
seconds, given powerful enough (and smart enough) computers. 

Geographical distributedness allows the simulation audience to be widely spread 
across actual space, as long as this does not compromise the illusion. Obviously, a 
real person and a real piece of equipment must be co-located for the one to operate 
the other, but if other entities are perceived artificially (e.g. through the tactical 
radio, through a radar screen, or through a simulated outside view), distributedness 
in principle allows them to be at arbitrarily large distances from each other (in 
practice, time lag problems limit the actual distances achievable). The immediate 
benefit is to allow exercises of any scale to occur at lesser cost in time and expense, 
as the participants need not move to a central location. Similarly, there is a lesser 
need in infrastructure. For example, instead of several sets of simulator units being 
installed in several locations, each one able to accommodate a full platoon, there 
could be only one platoon’s worth of simulators, each individual one at a separate 
location. 

Logical distributedness occurs independently of geographical distributedness; its 
essence lies in breaking down responsibility for various aspects of the simulation 
across different simulation software entities. This allows greater fidelity to be 
achieved by the combined simulation than would be possible using each 
participating simulation by itself. Each participating simulation, by mutual 
agreement, becomes responsible for one or more aspects of virtuality for which it is 
the recognised “expert.” For example, an all-puipose simulation that includes a 
crude missile fly-out model could, through logical distribution, turn over 
responsibility for its missiles’ flight to a specialised simulation, thus improving the 
realism of the whole. Another example would be target detection; once the host 
simulation has established line of sight exists between any two platforms, it could 
rely on another simulation to resolve whether detection occurs or not, the latter 
simulation using a sophisticated atmospheric propagation model to do so. 


DRDC Valcartier TR 2007-412 




The benefits of logical distributedness are many, not least of which is a large 
potential for systematic re-use of models and simulations of established validity and 
sophistication. Putting together a simulation for some specific need, be it training or 
research, then becomes a matter of determining which aspects require the most 
fidelity, and looking up the appropriate contributing simulations in some catalogue. 
Users are no longer locked into some specific investment (monolithic simulation 
environment), but may switch freely to improved components as they arise. 
Developers are free to specialise in some narrow aspect of their model, knowing any 
“deficiencies” their model may have in other aspects will easily be compensated, if 
needed, by the integration of the appropriate components. 

Distributed simulation is made possible through the High Level Architecture (HLA) 
standard, now in its second generation: Institute of Electrical and Electronics 
Engineers (IEEE) 1516. This document summarises the intricacies and subtleties of 
the standard in what is hoped to be a complement to the standard’s defining 
documents themselves. Time management is given minimal treatment while 
ownership and data distribution management are looked at in detail. The 
specification, as amended by the U.S. Department of Defense (DoD), is discussed 
and apparent ambiguities and lacunae are identified, with solutions proposed. 

Since the only fully certified Run-Time Infrastructure (RTT; the concrete 
implementation of the middleware standard) at this time is Pitch’s pRTI1516, that is 
what was used. Few problems were encountered, and these are documented. No 
comparisons or performance benchmarking could be conducted. 

A leading software intelligent agent design environment, Agent Oriented Software’s 
JACK, is summarised so that a clear picture of the component blocks of an agent 
application emerges. The task of integrating a given JACK agent into an HLA 
federation is tackled, using as an example a multi-user communication application 
modelled after Internet Relay Chat (IRC). 

Difficulties inherent in multi-threading applications were encountered, and the 
mechanisms required to surmount them within the HLA paradigm were 
implemented. Retrospection reveals how several of these could be improved, and 
this is discussed. 

A re-usable JACK “capability” module was designed and implemented, and quickly 
retrofitted to the older 1.3 standard. A re-usable and extendable framework of Java 
classes implementing the HLA Object Model Template (OMT) encoding and 
decoding facilities is described and implemented. It can be used until such time as 
an evolved version of HLA IEEE 1516 appears which resolves the related issues. 
Miscellaneous other utility classes are provided as well. 


DRDC Valcartier TR 2007-412 



It is hoped that the work will facilitate the integration of intelligent agents such as 
those made possible by JACK into existing or future simulations in use by the 
Canadian Forces, or by various Defence Research & Development Canada projects, 
such as those looking into cognitive effects and other human factors. The work 
should also be of some use to any effort involving HLA in general. 


Thibault, D. U.. 2008. Simulation technologies for C 2 IS development & training. 
DRDC Valcartier TR 2007-412. Defence R&D Canada - Valcartier. 


DRDC Valcartier TR 2007-412 


v 



Sommaire 


La simulation repartie, dans ses sens logique et geographique, permet d’exploiter au 
mieux de leurs capacites individuelles les simulations contemporaines et a venir. 

Les simulations reelles, virtuelles et constructives sont toutes susceptibles de 
beneficier d’une implementation repartie. Line simulation reelle implique des 
personnes reelles faisant fonctionner des systemes reels; ces demiers sont modifies 
(p. ex. fausses balles) ou augmentes (p. ex. equipement laser) afin de pennettre le 
realisme sans encourir les risques habituels de destruction ou blessure. Line 
simulation virtuelle implique des personnes reelles faisant fonctionner des systemes 
simules; les humains sont dans la boucle de fa£on centrale, exergant leur habilete 
manuelle, ou leurs competences de decision ou de communication. Une simulation 
constructive , enfin, implique des personnes simulees faisant fonctionner des 
systemes simules. Dans certaines conditions, les simulations constructives sont les 
seules a pouvoir etre executees a un rythme fortement accelere. Par exemple, une 
operation a grande echelle se deroulant pendant des jours ou des semaines pourrait 
etre simulee en quelques secondes, si la puissance (et Pintelligence) des ordinateurs 
le permet. 

La repartition geographique permet au personnel implique d’etre eparpille 
spatialement, du moment que Pillusion n’est pas compromise en ce faisant. 
Evidemment, une personne et un equipement reels doivent etre au meme endroit afin 
que fun puisse faire fonctionner V autre, mais si les autres entites ne sont per$ues 
qu’indirectement (p. ex. a travers la radio tactique, un ecran radar ou encore une we 
exterieure simulee), la repartition permet, en principe, a ces entites d’etre a une 
distance reelle arbitraire (en pratique, les delais de transmission limitent les distances 
reelles permissibles). Le benefice immediat est que les exercices, quelle que soit 
leur echelle, peuvent etre realises a moindre cout en temps et ressources, car les 
participants n’ont plus a se rendre physiquement a un meme endroit. Similairement, 
il y a un besoin moindre en infrastructure. Par exemple, au lieu de plusieurs 
ensembles de simulateurs installes en divers endroits, chacun en mesure 
d’accommoder un peloton entier, il devient envisageable d’avoir un seul peloton de 
simulateurs, repartis en divers endroits a la piece. 

La repartition logique peut avoir lieu independamment de la repartition 
geographique : son essence consiste a distribuer la responsabilite de divers aspects 
de la simulation entre differentes entites logicielles. Ceci permet a la simulation 
combinee d’atteindre une fidelite superieure a celle possible avec une seule des 
simulations participates. Chaque participant, d’un commun accord, se charge des 
aspects de la virtualite pour lesquels il est reconnu etre l’« expert ». Par exemple, 
une simulation a tout faire qui inclut un glossier modele de vol de missiles pounait, 
grace a la repartition logique, confier la responsabilite du vol de ses missiles a une 
simulation specialisee, ameliorant ainsi le realisme de 1’ensemble. Un autre exemple 
pounait etre l’acquisition de cibles; une fois que la simulation hote a etabli 
l’existence d’une ligne de visee entre les plateformes impliquees, elle pounait se fier 
a une autre simulation (utilisant un modele de propagation atmospherique 
sophistique) pour determiner s’il y a detection ou non. 


VI 


DRDC Valcartier TR 2007-412 



Les benefices de la repartition logique sont nombreux, a commencer par la re¬ 
utilisation systematique de simulations dont la validite et la sophistication sont 
etablies de longue date. La conception d’une simulation repondant a un besoin 
specifique, qu’il s’agisse d’entrainement ou de recherche, consiste alors a determiner 
les aspects requerant la plus grande fidelite, pour ensuite identifier les simulations 
devant etre mises a contribution dans un catalogue. Les utilisateurs ne sont plus 
prisonniers d’un investissement quelconque (un environnement de simulation 
monolithique), mais peuvent transitionner librement vers des composants ameliores 
lorsqu’ils surviennent. Les developpeurs sont fibres de specialiser leur modele, 
sachant que les “deficiences” que leur simulation pourrait presenter seront 
facilement compensees, si necessaire, par la participation d’autres simulations. 

La simulation repartie est rendue possible par la norme High Level Architecture 
(HLA), qui en est maintenant a sa seconde generation: Institute of Electrical and 
Electronics Engineers (IEEE) 1516. Ce document en explique les subtilites et les 
details d’une fai^on qui se veut complementaire aux documents de la norme eux- 
memes. La gestion du temps se voit accorder un minimum d’attention, tandis que la 
gestion de la propriete ainsi que la gestion de la repartition des donnees sont 
examinees attentivement. La norme, telle qu’amendee par l’U.S. Department of 
Defense (DoD), est discutee et d’apparentes ambiguites et lacunes sont identifiees, et 
des solutions sont proposees. 

Puisque le seul Run-Time Infrastructure (RTT; la realisation concrete de la norme 
intergicielle HLA) pleinement certifie lors de ces travaux est le pRH1516 de Pitch, 
c’est ce qui fut utilise. Quelques problemes furent rencontres, et ils sont 
documentes. II n’y avait pas lieu de faire des comparaisons ou des etalonnages de 
performance. 

Un environnement de conception d’agents logiciels intelligents d’avant-garde, 

JACK d’Agent Oriented Software, est decrit avec suffisamment de detail pour 
qu’une idee claire puisse se faire des composants qui constituent une application 
faisant usage d’agents intelligents. Nous nous attelons ensuite a la tache d’integrer 
un agent JACK donne a une federation HLA, en utilisant comme exemple une 
application de communication a multiples usagers, simulant de pres le clavardage 
Internet. 

Des difficultes inherentes aux applications multi-fil ont ete rencontrees, et les 
mecanismes permettant de les surmonter dans le contexte du paradigme HLA ont ete 
implantes. Une retrospective revele comment certains de ceux-ci pourraient etre 
ameliores, et ces options sont discutees. 

Un module de “capacite” JACK reutilisable a ete con 9 u et realise, et rapidement 
retro-ajuste a l’ancienne norme HLA 1.3. Un cadre de classes Java reutilisable et 
extensible realisant les methodes d’encodage et de decodage de l’Object Model 
Template (OMT) HLA est decrit et realise. II pourra etre exploite jusqu’a ce qu’une 
version evoluee d’HLA IEEE 1516 apparaisse qui resolve cette difficulte de la 
norme courante. Diverses autres classes utilitaires ont ete egalement realisees. 


DRDC Valcartier TR 2007-412 


VII 



Ces travaux devraient faciliter l’integration d’agents intelligents comme ceux rendus 
possibles par JACK a des simulations existantes ou futures, utilisees par les Forces 
canadiennes ou par divers projets de Recherche et developpement pour la defense 
Canada, comme ceux touchant aux effets cognitifs et autres facteurs humains. Ces 
travaux devraient egalement etre de quelque utilite pour tout effort impliquant HLA 
en general. 


Thibault, D. U.. 2008. Simulation technologies for C 2 IS development & training. 
DRDC Valcartier TR 2007-412. R & D pour la defense Canada - Valcartier. 


VIII 


DRDC Valcartier TR 2007-412 



Table of contents 


Abstract.i 

Executive summary.iii 

Sommaire.vi 

Table of contents.ix 

List of figures.xv 

1. Introduction.1 

General.1 

Background.1 

Context.2 

Aim.5 

Objectives.6 

Scope.6 

Outline.6 

2. High-Level Architecture (HLA).9 

Historical Perspective.9 

Framework and Rules.10 

Synthetic Environment.13 

HLA Interface.15 

HLA Services.16 

Federation Management.16 

Declaration Management.22 

Object Management.23 

Ownership Management.24 

Time Management.28 

Data Distribution Management.29 

Support Services.36 

DRDC Valcartier TR 2007-412 ix 





























Threads and Process Models.37 

Synchronization Issues.38 

Pitch pRTI1516.39 

Bugs.41 

Visual OMT 1516.44 

Bugs.44 

3. JACK™ Intelligent Agents.45 

Overview of JACK.46 

Events.46 

Belief Sets.47 

Plans.48 

Capabilities.49 

Multi-Threading.49 

JACK-HLA interface.50 

HLA services, callbacks and JACK events.50 

HLA1516 JACK Capability.51 

HLA13 JACK Capability.55 

JACK Integrated Development Environment (IDE).55 

JACK Bugs.56 

JACK Pre-Processor Bugs.56 

4. Chat Application.59 

JACK Chat Demonstration.60 

HLA Chat Demonstration.65 

HLA Chat Federation Object Model.68 

Assertions.77 

Federate Life Cycle.78 

5. Conclusions.83 


x 


DRDC Valcartier TR 2007-412 






























Annex A - Notes on the IEEE 1516-2000 Series of Standards.85 

IEEE 1516-2000 Series.85 

Multiple Federation Executions.85 

Simple Inheritance.86 

Declaring Dimensions.87 

Encoding/Decoding Values.88 

Names.89 

IEEE 1516.1-2000: Federate Interface Specification.92 

1.4.3 General nomenclature and conventions.92 

4.4 Join Federation Execution.92 

5.2/5.3 [UnJPublish Object Class Attributes.93 

5.6/5.7 [UnjSubscribe Object Class Attributes.95 

5.8/5.9 [UnjSubscribe Interaction Class.95 

6.1 Overview.96 

6.3 Object Instance Name Reserved.97 

6.7 Reflect Attribute Values.97 

6. 10/6.12 [Local] Delete Object Instance.98 

6.14/8.24 Change Interaction Transportation/Order Type.99 

7.3 Negotiated Attribute Ownership Divestiture.99 

9.5 Register Object Instance With Regions.99 

9.10/9.11 [UnjSubscribe Interaction Class With Regions.100 

Logical Time, Time Stamps, and Lookahead.100 

Annex B: Java application programmer’s interface.105 

Annex B: Java application programmer’s interface - 
InvalidFederateHandle.106 

Annex B: Java application programmer’s interface - 
MessageRetractionReturn.106 

Annex B: Java application programmer’s interface - Service 
Groups.107 

D.8.1 [Time Management] Overview.108 

IEEE 1516.2-2000: Object Model Template (OMT) Specification.108 

4.4.2 [Attribute] Table Format.108 

4.6 Dimension Table.109 

B.1 Linear normalization function.111 

DRDC Valcartier TR 2007-412 xi 


































B.1.1 Linear unnormalization function.111 

B.2 Linear enumerated normalization function.112 

B.2.1 Linear enumerated unnormalization function.112 

B.3.1 Enumerated set unnormalization function.112 

B.4 Logarithmic normalization function.112 

B.4.1 Logarithmic unnormalization function.113 

B.5 Hyperbolic tangent normalization function.113 

B. 5.1 Hyperbolic tangent unnormalization function.113 

C. 2 HLA OMT DIF DTD declaration.113 

Annex B - HLA 1516 Java API with Javadoc.115 

Annex C - DRDC HLA 1516 OMT Supporting Classes.405 

Basic datatypes.405 

Simple datatypes.405 

Enumerated datatypes.406 

Array datatypes.406 

Fixed record datatypes.407 

Variant record datatypes.407 

Annex D - DRDC HLA 1516 FederateAmbassador Supporting Classes....759 

Annex E - The Java Chat Client.997 

Annex F - The JACK Chat Client.1109 

Part One - The capHLA1516 Capability.1110 

Part Two - The JACK Chat Client Proper.1205 

References.1345 

Bibliography.1349 

List of symbols/abbreviations/acronyms/initialisms.1355 

Distribution list.1361 


DRDC Valcartier TR 2007-412 




























Internal distribution (DRDC Valcartier).1361 

External distribution.1361 


Note: The Annexes B through F are included only in the CD-ROM version of 
the report. 


XIII 


DRDC Valcartier TR 2007-412 





This page intentionally left blank. 


XIV 


DRDC Valcartier TR 2007-412 



List of figures 


Figure 1. The Topographic Map Display (ToMaDi).4 

Figure 2. The ImmersaDesk.5 

Figure 3. High Level Architecture.11 

Figure 4. The intersections of the object models.12 

Figure 5. A subset of the RPR-FOM version 2.0 object class hierarchy.13 

Figure 6. The interfaces between a federate and the HLA RTI.16 

Figure 7. The global federate states and their transitions.17 

Figure 8. The joined federate states.19 

Figure 9. The federate save and restore states.20 

Figure 10. Interchangeability of federates of the same type.22 

Figure 11. Known/Unknown transition state diagram.23 

Figure 12. Owned/Unowned transition state diagram.26 

Figure 13. Not Acquiring/Acquisition Pending transition state diagram.27 

Figure 14. Dimensions, ranges, regions, and region sets.30 

Figure 15. Transitions between region templates, specifications and realizations ..31 

Figure 16. Relationship between dimension sets.33 

Figure 17. An example of overlapping publication and subscription region sets....34 

Figure 18. Another example.35 

Figure 19. How an agent uses the HLA capability.54 

Figure 20. A high-level view of a chat application.60 

Figure 21. The JACK Chat Server window.61 

Figure 22. The JACK Chat Client window at start-up.61 

Figure 23. The JACK Chat Client window after logging in.63 


DRDC Valcartier TR 2007-412 


xv 


























Figure 24. The JACK Chat demonstration.64 

Figure 25. The Java Chat demonstration.65 

Figure 26. The Java Chat Client window after start-up.66 

Figure 27. The Java and JACK Chat Client windows after both have joined.67 

Figure 28. The Chat federation in action.67 

Figure 29. The Participant objects and the ChatRoomSlots dimension.76 

Figure 30. The Java Chat client in the disconnected state.997 

Figure 31. The Java Chat client in the joined state.997 


XVI 


DRDC Valcartier TR 2007-412 











1. Introduction 


General 

Modelling and simulation (M&S) are recognised as tools of paramount importance 
throughout the military endeavour. Physical M&S can be used to evaluate 
engineering solutions to specific problems (e.g. Which shape of helmet best protects 
against a projectile impact? Which layering of materials offers the best armour 
protection against a specific threat? Which disposition of controls best suits the 
ergonomics of the cockpit?). Logistics and demographics simulations can be used to 
evaluate force deployability and sustainability solutions. Virtual and real 
simulations are constantly used in training at all levels, ranging from small arms 
individual training, through simulators (aircraft, armoured vehicles, ship bridges) all 
the way up to command post exercises. Simulations are also extensively used in the 
design phases of acquisition projects, to refine requirements, identify errors before 
they result in expenses, and identify potential synergies. During real operations, 
simulations can be used to put to the test proposed friendly (or suspected enemy) 
courses of action, identifying overlooked opportunities or threats. And so on. 

Faced with this overwhelming breadth of applicability and abundance of diverse 
applications, simulation interoperability quickly emerged as a lynchpin. The High 
Level Architecture (HLA) is the still-evolving standard that strives to make this 
interoperability happen. 


Background 

In the Research and Development (R&D) domain, it is necessary to explore a variety 
of issues with a minimum of effort and expenditure of resources. Both to ensure the 
validity and applicability of the research and to avoid duplicate development and 
maintenance, the simulations used in R&D ought to be the same as (or at least have 
much in common with) those used in the military community. However, in the 
military application domain simulation is overwhelmingly used for training 
purposes. Command and control (C 2 ) training simulations perforce do not automate 
or simulate the C 2 process, since that is precisely the expected trainee benefit. One 
can oversimplify the situation like this: for training puiposes, the more humans are 
involved, the better. New equipment is introduced in the training scenarios only 
shortly before it is actually deployed. The preparation and execution of the 
scenarios is a complex, labour-intensive affair. Hence the conundrum: simulations 
designed for training puiposes have manpower requirements which make them 
poorly suited to the R&D environment. 


DRDC Valcartier TR 2007-412 


1 




Consequently, R&D tends to minimise the scope of simulation vignettes used to 
explore new concepts, in order to make the running of the simulations achievable 
with a minimum of personnel. This approach is quite successful in the “material” 
domains, but what if one wishes to study the complex interactions of multiple 
systems in the overall C 2 process? The number (and nature) of entities to be 
simulated cannot be reduced without voiding the purpose pursued. There is a need 
to provide a reasonable level of “intelligence” to the entities. This is, of course, a 
much harder problem than physical simulation, but artificial intelligence has made 
some progress over the decades since its inception. 

One of the paradigms that holds a fair amount of promise nowadays is the so-called 
intelligent agent approach, which strives to provide software entities with 
deliberative and pro-active qualities. 


Context 

The 12sd Simulation technologies for C 2 information system (C 2 IS) development & 
training project was known as 12kr before 2003. Briefly designated 2kq when 
created in 2000, it was at first called Army C 2 IS development and training through 
simulation. The project was an administrative means of regrouping a number of 
disjointed work units. The original aim was “To demonstrate an HLA simulation 
federation involving a simulation engine (with emphasis on OOTW support), 
command agents, an LFCS stand-in, an intelligence CCIS subset (ASIP) and 
decision aid tools.” The objectives were: 

• Command Agents: Explore models of the decision making process of military 
command and formalise a command model (below battalion, e.g. section, platoon, 
company and battalion) derived from contemporary artificial intelligence. The models 
must be flexible enough to represent doctrinally different allies and enemies as well as 
non-military entities (insurgents, refugees, organized crime, non-governmental 
organizations, etc.). 

• Tools: Explore development and implementation environments and tools 
applicable to HLA object models (simulation and federation), HLA federation 
development process management, and command agents. 

• Analysis: Evaluate the efficiency of command agents in land tactical CCIS over 
a distributed simulation environment. Evaluate several different mixed CORBA/HLA 
distributed environments. Evaluate desirable levels of HLA compliance on the part of 
the CCIS. 

• Demonstration: Demonstrate the usefulness of the federation by using it to test 
advanced land intelligence tools in a fully interactive peace-keeping simulated 
exercise. 

• Interfaces: Explore 3D visualisation and multi-modal interfaces for 
exercise/experiment preparation and execution. 


2 


DRDC Valcartier TR 2007-412 



With the eventual termination of one of the work units, the splitting off of another, 
and unexpected difficulties due in part to the immaturity of the domain and shifting 
standards, considerably less was achieved than hoped at the outset. 

This report concerns the 12sdll work unit, Simulation technologies. Besides the 
work being reported here, there was also another report, Conformation a et 
exploitation de HLA par ASIP (ASIP Compliance to and Exploitation of HLA ), 
written by Catherine Daigle ([1] Daigle 2001), who later became a member of 
DRDC Valcartier’s Decision Support Systems (DSS) Section. This report is 
included alongside this one on the CD (Compact Disc). 

The 12krl2 work unit, Command agents in simulation , was the responsibility of: 
Kenneth N. Ackles and Dr. Benoit Jean Fugere of the Royal Military College 
(RMC) Kingston. The goal was originally stated as the “exploration of models of 
computer-generated forces (CGF) under command, which must react to orders and 
the enemy in a realistic, doctrinally sound manner.” This was tightly integrated with 
the RMC graduate programs in Military Modelling & Simulation and RMC’s 
implication in the High Performance Computing Virtual Laboratory (HPCVL). A 
prototype armoured squadron set of command agents (using JACK) was allegedly 
completed. Alternate architectures involving neural networks and fuzzy logic were 
investigated. No reports were ever delivered to Defence R&D Canada (DRDC), 
although a number of theses were written and papers were published ([2] Liang and 
Fugere 2000, [3] Liang et al. 2001, [4] Robichaud 2001, [5] Liang and Fugere 2002, 
[6] Jaillet et al. 2002). The decision was made to terminate the work unit in early 
2003. 

The 12krl3 work unit, New media , was the responsibility of Roger Fortin of DRDC 
Valcartier. It concerned itself with a novel interface device, a Topographical Map 
Display (ToMaDi) ([7] Fortin 2001a). Second and third generations of the prototype 
device were realised and field tested in three major military exercises. ToMaDi 
Mkll ([8] Fortin 2001b, [9] Fortin 2001c) consists of a tiltable 4 by 4 matrix of 
sixteen colour Thin Film Transistor - Liquid Crystal Displays (TFT-LCDs, 
essentially portable computer screens) combined with a touch screen. It presents so 
far the only practical alternative to topographical paper maps for C 2 applications. 
With ToMaDi, it is possible to physically step back and view the entire map at once, 
and step up for the detail picture, without zooming in and out nor restricting access 
to one person at a time. Presently, two technologies are being investigated to make 
the ToMaDi’s mullions vanish: aspheric lenses and retroprojection (reports in 
preparation). ToMaDi contributes to the digitization of the battlefield. 


DRDC Valcartier TR 2007-412 


3 




Figure 1. The Topographic Map Display (ToMaDi) 


The 12krl4 work unit, Urban simulation, was the responsibility of Francois 
Letoumeau of DRDC Valcartier. It split off from 12kr in fiscal year 2001-2002 to 
become 12kx, which later became project 15al Geospatial technologies for 
information decisions' (GEO-TIDE) . The work focused on the development of three- 
dimensional models of urban areas, specifically Quebec City. This entailed the 
purchase of 3D modelling software and visualisation hardware (e.g. an 
ImmersaDesk). Various methodologies of 3D urban model creation were examined 
in order to gauge the effort required and identify the challenges, stakes and technical 
and methodological considerations involved. Two reports documented this work 
([10] Letoumeau et al. 2003, [11] Martel and Letoumeau 2003). 

The 3D models of Quebec City were used for technology demonstration purposes 
during the Summit of the Americas in 2001 by the RCMP headquarters. The Soldier 
information requirements (SIREQ) Technology Demonstration (TD) project asked 
12krl4 to produce several versions of the Quebec City 3D model which were used in 
an experiment that studied how different geospatial representations affected the 
capacity of soldiers to orient themselves in an urban operations field (reports in 
preparation). 


4 


DRDC Val earlier TR 2007-412 















Figure 2. The ImmersaDesk 


The 12sdl5 work unit, Display assessment and enabling technology research for 
new military displays, was also the responsibility of Roger Fortin of DRDC 
Valcaitier, and a Defence Industrial Research (DIR) project. It was intended to 
provide enhanced display design capabilities through the application of 
commercially available display components via the development of enabling 
technology elements. The work focused on investigations into Active Matrix Liquid 
Crystal Display (AMLCD), Field Emission Display (FED), and Organic Light- 
Emitting Diode (OLED) displays and into the associated core technologies necessary 
to implement military displays. Solutions to a wide variety of display-related 
problems were identified and the basic technology foundations developed ([12] 
Thomas 2004). An OLED display was built and demonstrated. 


Aim 

The aim of this document is to provide a number of insights into the technical 
aspects of the current HLA standard. Institute of Electrical and Electronics 
Engineers (IEEE) 1516, and into the technical issues relating to its interface with one 
particular software intelligent agent development environment, Agent Oriented 
Software’s JACK. 


DRDC ValcartierTR 2007-412 


5 










Intelligent agents model reasoning behaviour according to the theoretical Belief 
Desire Intention (BDI) model of artificial intelligence. They are autonomous 
software components that have explicit goals to achieve or events to handle 
(“desires”). To achieve their goals, the agents follow plans, which are high-level 
descriptions of expert behaviour. Set to work, the agents pursue their given goals 
(desires), adopting the appropriate plans (intentions) according to their current set of 
data (beliefs) about the state of the world. This combination of desires and beliefs 
initiating context-sensitive behaviour is a central characteristic of BDI agents. 

Objectives 

The specific objectives of this report are to: 

• Provide an overview of HLA IEEE 1516, focusing on a subset of the services it 
provides; 

• Provide an overview of Agent Oriented Software’s JACK; 

• Suggest improvements to the IEEE 1516 specification, building on those already 
promulgated by the U.S. Department of Defense; 

• Document bugs in the only commercially available RTI that fully implements 
IEEE 1516, Pitch’s pRTI 1516; 

• Document bugs in the current version of JACK; and 

• Document various design considerations, tips, tricks and lessons learned in 
implementing a specific federation. 

Scope 

This document is intended for those who are familiar with the high-level concepts of 
HLA and software engineering. 


Outline 

The sections examine, in turn, the HLA, the JACK intelligent agents, and the 
demonstration federation and Chat application. In the annexes, we comment on the 
IEEE 1516 specification, provide Javadoc for the HLA 1516 Application 
Programming Interface (API), document our re-usable supporting classes, provide a 
closer look at the Java Chat Client and provide its code, document the re-usable 
JACK capHLA1516 capability, and provide the JACK Chat Client code. 


DRDC Valcartier TR 2007-412 



This document is also distributed in electronic form, as a CD-ROM (Compact Disc - 
Read-Only Memory). The CD’s directory structure is as follows: 

• Java 

bin 

chat 

doc 

doccheck 

lib 

src 

• JACK 

chat 

capHLA1516 

capHLA13 

The Java source files are rooted at Java\src; for example, 

hla.rtil5l6.AttributeHandle.j ava is found at 

Java\src\hla\rtil5l6\AttributeHandle.j ava. The corresponding class 
files are rooted at Java\lib. Java\bin contains j ar files that provide an alternate 
representation of the class files. The doccheck directory contains the results of 
running the Doccheck doclet on the source files, while the doc directory contains 
the generated Javadoc. 

The code supplied in the annexes is found here: 

• The hla. rtiisis IEEE 1516 Java API with Javadoc added (Annex B); 

• The ca . gc . drdc_rddc . hla.rtil5l6 Integers 4 family of 
LogicalTime[lnterval][Factory] implementations called for by the specification 
but missing from the Pitch pRTI1516 product; 

• The ca .gc. drdc_rddc .hla. rt 11516 . omt supporting classes (Annex C); 

• The ca .gc. drdc_rddc .hla. rt 11516 . FedAmb supporting classes (Annex D); 
and 


• The chat Java Chat client code (Annex E). 

The JACK source files are in the jack directory: 

• The chat project (Annex F Part Two); 

• The capHLAis 1 6 re-usable capability (Annex F Part One); and 

• A capHLAi3 re-usable capability for HLA 1.3NGv6 (bonus). 


DRDC Valcartier TR 2007-412 


7 



This page intentionally left blank. 


8 


DRDC Valcartier TR 2007-412 



2. High-Level Architecture (HLA) 


Historical Perspective 

Computer simulation was developed hand-in-hand with the rapid growth of the 
computer. One of the very first large-scale efforts was the World War II Manhattan 
Project’s computer modelling of the process of nuclear detonation. In the military 
domain, simulators had been used for individual training purposes long before the 
computer was invented. Likewise, the “war game” as a command training tool dates 
back at least to the Napoleonic era. Computers, naturally, were at first used to 
enhance these disparate tools on a piecemeal basis. Thousands of different computer 
applications were eventually developed to fulfill an immense variety of training and 
research requirements. Simulations grew from the bottom up, features being added 
every time they were felt necessary, leading to repeated reinvention of the same 
wheels. Interoperability was virtually non-existent. By the early 1980s, it was 
generally considered impossible to build an affordable, large-scale, collective, free- 
play, force-on-force, interactive, worldwide networked war fighting system ([13] 
Cosby 1999). 

That is precisely what the U. S. Defense Advanced Research Projects Agency 
(DARPA) SIMulator NETwork (SIMNET) programme set out to disprove 
(SIMNET later became SIMulation NETwork, to reflect its widening span). 

Initiated in 1983, it was the first step in moving from individual task-based 
simulators to a network of low-cost simulators that fought on a virtual battlefield to 
provide "synchronized execution of collective war fighting skills in a combined aims 
and joint arena." Eventually, the University of Central Florida’s Institute for 
Simulation and Training (1ST) was contracted by DARPA to undertake research in 
support of SIMNET. The first draft of the resulting Distributed Interactive 
Simulation (DIS) protocol appeared in 1992 ([14] DIS 1992), and it quickly became 
an IEEE standard, IEEE 1278 ([15] IEEE 1993). DIS enjoyed considerable success 
and is still used in some contexts. 

In 1989, DARPA started extending the SIMNET DIS principles to aggregate level 
constructive training simulations. The effort led in 1991 to the Aggregate Level 
Simulation Protocol (ALSP) which was first used to support major exercises in 
1992 ([16] MITRE 1993). ALSP laid the theoretical foundations for the High Level 
Architecture (HLA) while becoming a multi-service program focusing on the 
support and execution of the Joint Training Confederation (JTC). By 1998, the 
ALSP Confederation would start transitioning to HLA. 


DRDC Valcartier TR 2007-412 


9 



Starting in 1995, the U. S. Defense Modeling and Simulation Office (DMSO) 
developed the High Level Architecture as a standard for distributed simulation that 
could support any kind of simulation (live, virtual or constructive, real-time or not) 
while encouraging re-usability as much as possible by not imposing semantics on the 
participating simulations ([17] Kuhl et al.). First published and adopted as the U.S. 
Department of Defense de facto standard architecture for distributed simulation on 
10 September 1996 ([18] DoD 1996), HLA underwent several revisions, eventually 
becoming the Object Management Group (OMG) standard Facility for Distributed 
Simulation Systems 1.0 in November 1998 ([19] OMG 1998a). The DMSO 
demonstration Run-Time Infrastructure (RTT, the implementation of the middleware 
allowing HLA distributed simulations to take place) underwent successive revisions 
in parallel, eventually stopping with version 1.3NGv6. It was provided free-of- 
charge to encourage experimentation and development. In 2002, distribution was 
shut down to avoid competing with the burgeoning commercial implementations of 
HLA. 

Simultaneously with the OMG ratification process, the standard was submitted to the 
IEEE, partly in order to rely on a non-governmental standard, since American law 
requires the U.S. Department of Defense (DoD) to use such non-governmental 
standards when consistent with mission, priorities and budget resources. The IEEE 
gave it a thorough going over, resulting in IEEE 1516 in 2000-2003 ([20] IEEE 
2000). The IEEE standard deliberately avoided including a Common Object 
Request Broker Architecture (CORBA) ([21] OMG 1998b) Interface Definition 
Language (IDL) specification (unlike HLA 1.3), leaving this up to the OMG. The 
result was the OMG Facility for Distributed Simulation Systems 2.0 in February 
2002 ([22] OMG 2002). 

Version 2 of IEEE 1516 has just begun preparation and is expected to be released 
within the next few years. 

The most recent edition of DoD 4120.24-M, Defense Standardization Program 
(DSP) Policies and Procedures , is dated 9 March 2000 and does not yet formally 
adopt either HLA 1.3 or IEEE 1516 ([23] DoD 2000). The situation is similar on the 
North Atlantic Treaty Organization (NATO) side, where Standardisation Agreement 
(STANAG) 4574, Standardized Modelling and Simulation Information for High 
Level Architecture (HLA), ([24] NATO 1999) has yet to replace STANAG 4482, 
Standardized Information Technology Protocols for Distributed Interactive 
Simulation (DIS) ([25] NATO 1995). Nevertheless, the trend is clear: HLA is the 
way of the future. 

Framework and Rules 

HLA strives to be an interface definition which is flexible enough to accommodate 
any combination, in number and kind, of simulations. Live, virtual and constructive 
simulations can, in principle, be made to interoperate using HLA. HLA is fully 
described by the IEEE 1516 documents (see the Bibliography for a full list), so we 
do not reproduce them here. Instead, a brief overview and summary is provided. 


10 


DRDC Valcartier TR 2007-412 



The functional components are of two kinds: th c federate applications and the run¬ 
time infrastructure (RTI). The federate applications are the individual simulation 
applications. The RTI plays a role similar to an Object Request Broker (ORB) under 
the CORBA; it is the (veiy likely distributed) set of software services which links 
the federates together (see Figure 3). 



RTI 


Figure 3. High Level Architecture 

Here several federates participate in two different federation executions (red and green pipes) 
through the RTI. An unjoined federate can also be seen. 

Each federate application has a Simulation Object Model (SOM): a software 
document written according to the rules laid out as part of the standard (the Object 
Model Template (OMT)). This SOM describes the objects, interactions, dimensions 
and other features of the simulation relevant to interoperability. Each version of the 
simulation application will likely have a different SOM, unless the changes are 
entirely transparent to the other federates. That is to say, implementation details can 
change freely, as long as the interface and the semantics do not. The actual 
operation, over time, of a federate application is referred to as a federate. 

A federation is a named set of federate applications and a common Federation 
Object Model (FOM) that are used as a whole to achieve some specific objective. 
The FOM is best thought of as the relevant intersection of the SOMs of the federates 
involved (see Figure 4). The FOM is concretely represented by the FOM Document 
Data (FDD), although the two terms are essentially interchangeable. A federation 
execution is the actual operation, over time, of a set of federates interconnected by 


an RTI. 


DRDC Valcartier TR 2007-412 


11 


















In principle, a FOM exists only for the duration of the “specific objective”, typically 
a scheduled exercise. When that is the case, it does indeed make sense to generate 
the FOM as the intersection of the SOMs of the federates involved. However, in 
practice FOMs tend to lead a continuing existence of their own, either because the 
exercise is repeated at regular intervals, or because an all-inclusive FOM is desired 
in order to avoid having to edit it despite a changing roster of federates. In 
particular, a FOM greater than the intersection of the actively participating federates 
makes sense when passive federates are used to capture (for analysis logs or for 
after-action reviews, for example) what happens during the federation execution. In 
such a case, the passive federate needs to be able to subscribe to objects and 
interactions (see Synthetic Environment, below) that spend their entire lifespan (i.e. 
are created, managed and destroyed) within a single federate’s purview. Even 
though no collaborative simulation occurs, the objects of interest must nevertheless 
appear in the FOM for the passive federate to accomplish its task. 

All communication and interaction between the federates goes through the RTI; 
private direct connections are not allowed. The representations of the objects in the 
federation execution are all held by the federates: the RTI does not cache the data 
that transits through it. 



Figure 4. The intersections of the object models 

The intersections of the simulation and federation object models (SOM and FOM) dictate the possible 
collaborations. The three-colour area represents the object model understood by both simulations 
and the federation; only those objects are susceptible to collaborative simulation by the simulations 

during the federation execution. 


12 


DRDC Valcartier TR 2007-412 





Synthetic Environment 


The HLA synthetic environment is populated by durable entities called objects. In a 
military context, the simulation objects are usually representations of real-world 
objects: soldiers, vehicles, buildings and so on. More abstract objects are possible 
and indeed often desirable. For example, a simple tactical constructive simulation 
could have a “Weather” object, which could be little more than a holder for a 
handful of meteorological parameters such as temperature, humidity, wind speed and 
wind direction. Other objects could represent more abstract concepts, such as 
groups of entities (organized or not): a military unit or a crowd of protesters. 

The object models define classes of objects, which are nothing more than a 
collection of attributes that serve to define the object’s state. In other words, object 
classes are data structure templates. In object-oriented software design, objects are 
normally defined as encapsulations of data and operations ( methods ); in HLA, object 
classes have no methods: they are defined entirely by their identifying attributes. 

The behaviours and operations that affect the values of HLA object attributes are 
kept resident in the federates. The HLA supplies the HLAobj ectRoot class, from 
which all other object classes descend in hierarchical fashion. Subclasses inherit 
their superclass’s attributes, naturally. 



Figure 5. A subset of the RPR-FOM version 2.0 object class hierarchy 
The attributes are not shown. 


DRDC Valcartier TR 2007-412 


13 
































































































































































During a federation execution, instances of the various object classes may be created 
and deleted by each federate. A federate declares its intention to publish and 
subscribe to an object class’s attributes (or a subset thereof). When an object 
instance is created by a federate, the RTI considers that federate as owning the 
instance attributes that it publishes for that class (any remaining attributes are 
unowned). Ownership of an instance attribute means the owner is responsible for 
keeping that instance attribute’s value up to date, and for supplying that value when 
it is requested by the RTI. Subscribers discover object instances when they are 
pertinent to their subscription interests, and may, as needed, request that the RTI 
supply them with the instance attribute values. The RTI truly earns its title of 
middleware in this circumstance, since all it does is request the values from their 
respective owners and then dispatch the owners’ subsequent value update. 

The RTI also mediates ownership transfers between federates. Divestiture of an 
owned instance attribute can be initiated by the owning federate with varying 
degrees of assertiveness (If Wanted, Negotiated and Unconditional) or it can be 
requested by the RTI. Conversely, acquisition of an unowned instance attribute may 
be requested by the federate with varying degrees of forcefulness (If Available, 
Negotiated) or it can be offered by the RTI. The section entitled Ownership 
Management (below) discusses this delicate matter in detail. 

Interaction is a concept closely related to the object. Interactions are also described 
as a hierarchy of classes, descending from HLAinteractionRoot. Their attributes 
are called parameters , and the key difference is that instead of creating instances, the 
federates send occurrences. Interactions have no duration: they are created at a 
given instant, distributed like an object instance attribute update, and then cease to 
exist. They are meant to represent simulation events such as a lightning flash or a 
direct-fire engagement. Note that SOMs can disagree on what should and should not 
be an interaction. Let’s take the example of a burst of machine gun fire aimed at an 
infantry platoon. A simpler simulation would likely model this direct-fire 
engagement as an interaction, whereas a more detailed simulation could choose to 
create object instances for each bullet. 

Despite their name, interactions don’t necessarily involve more than one object 
instance. A FOM could very well include interactions which are nothing more than 
running commentaries, destined for eventual consumption by event loggers. For 
example, an event could be designed that corresponds to the decision by one entity 
to engage another. This “event” has no immediate physical consequences since it 
occurs “inside the head” of the entity, and could be of interest only while debugging 
the entity’s target selection algorithm. 


14 


DRDC Valcartier TR 2007-412 



Each simulation is free to have object models of varying degrees of detail. Indeed, a 
sizable part of the federation development process (FEDEP) consists of deciding 
what level of detail is required and which federate is most suited to the task, as well 
as reconciling object model differences. To facilitate this process, the Real-time 
Platform Reference FOM (RPR-FOM) is published by the Simulation 
Interoperability Standards Organization (SISO). SISO-STD-OOl-1999, RPR-FOM 
vl.O ([26] SISO 1999a, [27] SISO 1999b) captures the functionality of DIS (IEEE 
1278.1-1995), and facilitates interfacing a DIS simulation with an HLA federation. 
RPR-FOM version 2.0 is intended to add the functionality of DIS 2.0 (IEEE 
1278. la-1998) and to update version 1.0 to the IEEE 1516 HLA standard; it is in its 
seventeenth draft as this is being written ([28] SISO 2003). RPR-FOM version 3.0 
is in early draft form and is intended to include features that were originally 
considered for DIS 3.0 (now abandoned). 

A federate could subscribe to an object or interaction class for which there is no 
publisher; if another federate publishes a superclass of the subscribed class, that is 
what the first federate will discover. In that sense, HLA is polymorphic. All it 
really means is that you may not get all of the attributes or parameters you 
subscribed to, since successive subclasses can only differ by the monotonic accretion 
of attributes/parameters. 

Dimension rounds out the set of key HLA concepts. It will be discussed in the 
section on data distribution management below. 


HLA Interface 

The application programming interface between a federate and an HLA RH consists 
of two software objects: the RH Ambassador and the Federate Ambassador. The 
RTI Ambassador instance is supplied by the RH and exposes a number of methods, 
called services, to the federate (documented in IEEE 1516.1-2000). The federate 
sends “commands” to the RTI by invoking the RH Ambassador services. Some 
services return a value immediately (a Boolean, an attribute handle set, etc.) but 
most respond asynchronously through the Federate Ambassador. The IEEE 1516 
specification, unlike the older specifications (1.3 and predecessors), does not 
prescribe how the RTI Ambassador instance is to be procured. This allows multiple 
RTIs to cohabit in the same name space, but it does mean a federate application will 
probably need a thin adaptor class in order to be able to fetch whichever RH is 
installed without needing to be recompiled. 


DRDC Valcartier TR 2007-412 


15 



Federate 



Figure 6. The interfaces between a federate and the HLA RTI 
The RTI supplies the RTIambassador; the federate must supply a compliant FederateAmbassador. 

The Federate Ambassador instance, on the other hand, is supplied by the federate 
and must implement a specific set of methods (also documented in IEEE 1516.1- 
2000). The RTI communicates with the federate by invoking the Federate 
Ambassador methods, called callbacks. None of the Federate Ambassador methods 
return anything to the RTI; the latter expects normal retroaction to occur through 
RTI Ambassador services, although the Federate Ambassador is expected to throw a 
variety of exceptions if something is amiss. 

The rest of the HLA package consists of a number of classes that define the 
arguments to the services and callbacks (handles, factories, sets, maps, lists, etc.), as 
well as the exceptions that they may throw. 

The interfaces are specified in terms of services (methods), designators (names and 
handles) and abstract data types only. The mappings to specific programming 
languages are supplied in three annexes, covering respectively Ada 95, C++ and 
Java. The mapping used by a given federate has no consequences on the rest of the 
federation; for example, a designator encoded using one mapping will be decodable 
using any other mapping. Since the JACK Agent Language is an extension of Java, 
we naturally chose to restrict ourselves to Java in what follows. 


HLA Services 

For convenience, the HLA interface methods are grouped into seven service groups, 
which we will discuss in varying degrees of detail below. 


Federation Management 

These services deal with the creation, dynamic control, modification, and deletion of 
a federation execution. Create/Destroy Federation Execution are used to create and 
destroy federation executions. Join/Resign Federation Execution are used by the 
federate to join a federation execution and withdraw from it when the execution 
ends. 


16 


DRDC Valcartier TR 2007-412 















Figure 7. The global federate states and their transitions 
This diagram and the following ones use the ([29] Hare! 1987) statechart notation and are derived 
from the HLA IEEE 1516 state diagrams. The dot is the initial state. The bracketed term is a 
Boolean guard expression; here it shows the federation execution may be successfully destroyed 

only if there are no joined federates. 


DRDC Valcartier TR 2007-412 


17 



Synchronization points may be declared by the Register Federation Synchronization 
Point service. Optionally, knowledge of the synchronization point’s existence can 
be restricted to a subset of the joined federates. The RTI responds with either a 
Synchronization Point Registration Succeeded or a Synchronization Point 
Registration Failed callback (the latter includes a reason for failure parameter, 
because the second form of the Register Federation Synchronization Point service 
can fail in two distinct ways). The semantics of the synchronization points are 
documented in the FDD but the RTI does not (indeed cannot) enforce them. A 
typical use would be a “StartingLine” synchronization point (to use a racing 
metaphor). As federates join the federation execution and complete their 
initialization process (which may include interactions between the federates, 
mediated by the RTI), they would be advised by the RTI of the synchronization 
point’s existence through the Announce Synchronization Point callback, and would 
be expected to eventually invoke the Synchronization Point Achieved service. Once 
all required federates have thus acknowledged the synchronization, the RTI 
announces this state of affairs to each federate through the Federation Synchronized 
callback, in this case firing the “starting gun.” Once the Federation Synchronized 
callbacks have all been issued, the synchronization point ceases to exist (and may 
therefore be registered anew). 

Federation Synchronization points can also be used whenever some form of 
synchronization is desirable between multiple joined federates. They can be used to 
let the RTI arbitrate potential race conditions between federates. Whenever 
synchronization is required between the multiple threads of an application, 
programming languages or frameworks provide a variety of synchronization and 
exclusion classes and mechanisms, variously named semaphores , mutexes 
(contraction of “mutual-exclusion”), or monitors. In broad terms, the protected 
object or block of code has an associated lock which can be owned by only one 
thread at a time. When a race condition occurs, one thread succeeds on its lock 
operation while the others block on it. When the winner concludes the protected 
block and relinquishes the lock, the system awards it to one of the blocked threads, 
and so on. 

The synchronization services can mimic this. Obtaining a lock corresponds to the 
successful registration of a synchronization point: if the operation succeeds, the 
federate “has the lock.” The other federates are expected to achieve the 
synchronization as soon as it is announced to them (acknowledging the lock). Other 
federates that were simultaneously attempting to register the lock (presumably they 
would not try if they were already aware of the lock’s existence) are expected to put 
themselves in whatever wait mode is appropriate. The lock’s owner relinquishes the 
lock by achieving the synchronization in its turn (most likely it will be the last 
federate to do so, but this is not a requisite). When this occurs, the RTI invokes 
Federation Synchronized for all federates, which signals that the lock has been freed 
up (i.e. the synchronization point no longer exists). By varying this pattern slightly, 
semaphores can also be mimicked (e.g. announcement of the synchronization point’s 
existence is the signal being awaited). 


18 


DRDC Valcartier TR 2007-412 



1 


Joined Federate 


Register Federation Confirm Synchronization 
Synchroniifatibn Point PoinKRegistration 1 ^ 



□ Announce 

nchronization Points 


Fe^r^tfon Synd^ropfeation Point 
Synchronized^ Achieved 


Federate Save 
in Progress 


Federate Restore 
in Progress 


Figure 8. The joined federate states 

Transitions marked with a dagger (f) are FederateAmbassador callbacks. The synchronization point 
services do not change the state of the federate itself, although they do change the federation state. 

Federation saves complete this set of services. A federation save stores a complete 
description of the federation execution in such a way that the federation execution 
may be restored later. Saves are identified by a label, and can be generated at an 
optional specific logical time. It can be presumed to consist of a set of files 
distributed between the joined federates on the one hand, and the RTT on the other 
(the form the storage takes is left as an implementation issue for the RTI and 
federates). Besides the save label, the RTI stores the number of federates joined at 
the time the save is created, and the types of the various joined federates (these types 
are simply labels supplied by the federates when they join the federation execution; 
their semantics are left to the federation). Unlike synchronization points, saves 
always affect the entire set of joined federates. A federate is expected to use the 
save label, the name of the federation execution (and, implicitly, the FDD), its joined 
federate designator and its federate type to distinguish the saved state information. 


DRDC Valcartier TR 2007-412 


19 









Request Federation Save 


Active Federate 


Active 


—Request Federation Restore— 

- Gefrf i f - m --Fe d efa4i en - R e» t&f ati e f v - 


Restore request pending 


Request 1, (failed) 


Initiate Federate Save? 


F ideration Saved 1 


Instructed to Save 


Saving 


0 


Waiting for 
federation to save 


Confirm Fede ation Restoration 
Request 1 (succeeded) 

Federation Restored 1 


Federation Rest&re-Beg r 
derate Save Begun 

Initiate Federate Rested 
derate Save Complete 

Federate Restore Compl 


Federate Save in Progress 


€ 


Waiting for 
Restore to begin 


Prepared to 
Restore 


Restoring 


€ 

V Waiting for 
V [federation to restore 


Federate Restore in Progress 


Figure 9. The federate save and restore states 
Most useful work is done in the Active Federate states. 


Any federate may Request Federation Save. The RTI sends the Initiate Federate 
Save callback to each federate, including the requestor. Each federate then complies 
by invoking Federate Save Begun and later Federate Save Complete (specifying if it 
was successful or not). As soon as the federate enters one of the “Federate Save in 
Progress” states, the RTI withholds most callbacks and refuses to accept the 
overwhelming majority of the various service invocations from the federate—those 
that would change the state of the federation in some way. As the save progresses, a 
federate may Query Federation Save Status, to which the RTI responds with the 
Federation Save Status Response callback. Eventually the RTI announces to the 
federates that the save is complete (successful or not) through the Federation Saved 
callback, and normal execution can then resume. 


20 


DRDC Valcartier TR 2007-412 
































The reverse of the save process is the federation restore process. This begins with a 
Request Federation Restore, which the RTI acknowledges with the Confirm 
Federation Restoration Request callback (specifying if it was successful or not). 
Using the Federation Restore Begun callback, the RTI signals each federate 
(including the requestor) that it has been put in the “Federate Restore in Progress” 
state, which restricts federate activity just like during a federation save. Note that 
the requestor enters the suspended state as soon as it receives confirmation of the 
request. Next, the RTI requests of each federate that it begin to restore its state as 
previously saved, using the Initiate Federate Restore callback. The federate signals 
the completion of its restore process through Federate Restore Complete (specifying 
if it was successful in doing so or not) and may Query Federation Restore Status, 
receiving a Federation Restore Status Response callback in response. Finally, the 
RTI advises each federate of its return to normal operation through the Federation 
Restored callback. 

Because federation saves are implementation-specific, there is no requirement that a 
save created by one vendor’s RTI be restorable by another vendor’s RTI. Also, 
federates that share the same federate type must be able to handle each other’s save 
documents. For example, if federates A, B, and C were all of the same type when 
the save was created, when the RTI processes a restore request the only guarantee is 
that it will assign each of the federates one of those three roles (see Figure 10). 
Federate A could therefore end up restoring its own save data, or B’s or C’s. This 
strongly suggests a certain level of storage sharing for save/restore. 


DRDC Valcartier TR 2007-412 


21 





Figure 10. Interchangeability of federates of the same type 
Top: the federation is saved and the save data is spread between the stores (in grey). When the 
restore occurs (bottom), the federate instances B, through B 3 , all of the same type, may be assigned 

any of each other's original roles. 


Declaration Management 

These services deal with the publication of and subscription to object and interaction 
classes. This is accomplished by the [UnJPublish/Subscribe Object Class Attributes 
and [Un]Publish/Subscribe Interaction Class services. Note that publication is at the 
object class attribute level in the former case, but at the interaction class level in the 
latter: you cannot subscribe to or publish just a subset of an interaction’s parameters. 

The only (optional) RTI callbacks are Start/Stop Registration For Object Class and 
Turn Interactions On/Off. These are known as the Object Class and Interaction 
Relevance Advisories, respectively. They are used to allow a federate to more 
intelligently manage its publication activities. In effect, the Object Class Relevance 
Advisory lets the federate know whether or not any other federates are actively 
subscribing to a published set of object class attributes. If there are none, there is no 
point in registering new object instances (or sending new interactions). This can 
help with federation execution performance. 

A small subtlety here is the possibility of passive subscriptions ; these do not trip the 
advisories and are designed to allow special federates like loggers or viewers, which 
do not contribute actively (i.e. do not own anything or send interactions), to join a 
federation execution freely without modifying its behaviour. 


22 


DRDC Valcartier TR 2007-412 












Object Management 


These services deal with the registration, modification, and deletion of object 
instances and the sending and receipt of interactions. The bulk of the “action” of a 
federation execution is expected to occur here. 



Figure 11. KnownAJnknowri transition state diagram 
Part of the state diagram for object instance attributes, focusing on the known/unknown transitions. 
The details of the owned/unowned transitions (*) are given in Figure 12. Here i stands for an object 
class, j for an object attribute and k for an object instance. 

The first service in this group is Reserve Object Instance Name, to which the RTI 
responds through the Object Instance Name Reserved callback. All object instances, 
as they are registered, are given federation-wide unique names automatically by the 
RTI. The name reservation service allows a federate to reserve a name, something 
which is typically done for special object instances that have been deemed necessary 
for the federation execution design. 

Next is Register Object Instance, which may trigger Discover Object Instance at 
other federates. This is how object instances are injected into the federation 
execution. The converse service is Delete Object Instance, which will trigger 
Remove Object Instance at the federates that had previously discovered the object 
instance. A non-owning federate can also invoke Local Delete Object Instance, 
whose purpose is simply to “forget” about the object instance. This could be 
because it has gone out of scope and is no longer of any interest to the federate, or it 
could be because the federate wants to shift its subscription interests for already- 
discovered object instances (e.g. an object was previously discovered as one of its 
superclasses and the federate wants to rediscover it as a more specific subclass, or 
vice versa). 


DRDC Valcartier TR 2007-412 


23 



Then we have Update Attribute Values, which is how an owning federate apprises 
the RTI of the new values of instance attributes. The update policy for each class 
attribute is documented in the FDD but is not enforced by the RTI. The updated 
values are distributed to the subscribing parties through the Reflect Attribute Values 
callback. A subscriber may invoke Request Attribute Value Update, which will lead 
the RTI to prompt the publisher with a Provide Attribute Value Update callback. 
Note that a request for a value update for an unowned instance attribute won’t be 
answered, since no custodian of the instance attribute value exists. This is because 
the RTI does not cache the “last known value.” 

Interactions, because of their transient nature, combine Register and Update into a 
single service, Send Interaction. Subscribers receive the Receive Interaction 
callback. 

The RTI supports two built-in transportation types', “reliable” and “best effort”, 
typically mapped to Transmission Control Protocol/Intemet Protocol (TCPTP) and 
User Datagram Protocol (UDP), respectively. New ones may be defined if needed. 
The transportation type is specified by the FDD and may be changed at the instance 
attribute or interaction class level through the Change Attribute/Interaction 
Transportation Type services. 

Finally, there are two sets of advisories associated with this service group. They 
serve to let publishers and subscribers know whether or not they have counterparts 
in the federation. Like the declaration management advisories, they serve to let 
federates optimise their use of bandwidth—there is no point in sending instance 
attribute updates regularly if there are no subscribers currently listening. The 
Attribute Relevance Advisory causes the Turn Updates On/Off For Object Instance 
callbacks at the publisher. Its converse, the Attribute Scope Advisory, causes the 
Attributes In/Out Of Scope callbacks at the subscriber. A published attribute goes 
out of scope if it has no subscribers; a subscribed attribute goes out of scope if it has 
no publisher (i.e. is unowned). This notion of scope is of limited usefulness until the 
data distribution management services are considered, as we will see later. 


Ownership Management 

These services deal with the transfer of ownership of instance attributes among 
joined federates. HLA departs from conventional object-oriented design in allowing 
the attributes of an object instance to be owned in a distributed fashion, rather than 
being under the exclusive responsibility of the object owner. This is a powerful 
feature that greatly facilitates the cooperative modelling of objects. 

The root object, HLAobj ectRoot, has just one attribute, 

HLAprivilegeToDeleteObj ect, inherited by all HLA objects. This attribute has 
no value (content); the only thing that matters is which federate owns it. The 
federate that owns this attribute “owns” the object instance, in the sense that it is the 
sole federate allowed to delete the object instance. 


24 


DRDC Valcartier TR 2007-412 



To give a simple example of what attribute ownership means, consider a missile 
ordnance object. Before the missile’s launch, it is attached to its launcher (e.g. under 
the wing or in the bomb bay of an aircraft, in a ship’s missile storage compartment, 
in a man-portable launch tube, etc.). HLA ownership management allows the 
missile’s geographical coordinates attributes to be the responsibility of (to be owned 
by) whichever simulation moves the launcher about. It is only once the missile is 
launched that ownership of these attributes needs to be transferred to the federate 
responsible for the missile’s flight. 

HLA defines the Management Object Model (MOM), a small hierarchy of objects 
and interactions which are part of every FOM. These are owned by the RTI and 
represent the federates and their relation to the RTI; they are mostly used for 
network oversight, performance tuning, and troubleshooting. The RTI never accepts 
ownership of anything else, and never relinquishes ownership of any part of the 
MOM. 

Ownership is crucial within an HLA federation, because the owner of an object 
instance attribute is the sole custodian of its value. While an attribute is unowned, 
its value cannot be obtained from the RTI: each federate is left with its locally 
cached “last known value”, if any. Ownership is also tied to discovery: if an object 
instance ends up an orphan (that is to say, none of its attributes are owned by any 
federate and it is currently not known by any federate), it cannot be discovered at all. 

Ownership management is a delicate process, as the associated state diagrams show 
(see Figure 12 and Figure 13). A federate starts off owning all of the published 
attributes of an object instance it registers (a minimum of one attribute). It can 
divest itself of ownership in four ways: through the Unconditional Attribute 
Ownership Divestiture service, the Negotiated Attribute Ownership Divestiture 
service, the Attribute Ownership Divestiture If Wanted service, and by unpublishing 
the owned object’s class. Conversely, it may acquire ownership in two ways: 
through the Attribute Ownership Acquisition service, or the Attribute Ownership 
Acquisition If Available service. 


DRDC Valcartier TR 2007-412 


25 




Figure 12. Owned/Unowned transition state diagram 
Part of the state diagram for object instance attributes, focusing on the owned/unowned transitions 
(the asterisk in Figure 11). The circled H indicates the historical state (meaning the service may be 
invoked from any one of the inner states and returns whence it was invoked). The details of the Not 
acquiring/Acquisition pending transitions (the asterisk here) are given in Figure 13. 

The Attribute Ownership Acquisition If Available service is “non-intrusive” (like a 
passive subscription) and is immediately resolved by the RTI based on current 
ownership availability. The requesting federate receives an Attribute Ownership 
Acquisition Notification for the instance attributes acquired and an Attribute 
Ownership Unavailable for the others. 

The Attribute Ownership Acquisition request, on the other hand, puts the federate in 
the “acquiring” state (with respect to the specific instance attribute), whence it may 
return through the Cancel Attribute Ownership Acquisition service. The RTI 
acknowledges this cancellation through the Confirm Attribute Ownership 
Acquisition Cancellation callback. This form of acquisition is “intrusive” (like an 
active subscription) because the RTI will prompt the owner (if not already divesting) 
through a Request Attribute Ownership Release callback. The Attribute Ownership 
Unavailable callback does not occur in this context, but several Attribute Ownership 
Acquisition Notifications may occur depending on the number of previous owners 
involved and their ownership release schedules. Note that the Attribute Ownership 
Acquisition If Available service will not return the federate from the “acquiring” 
state since it is a weaker request than the outstanding Attribute Ownership 
Acquisition. 


26 


DRDC Valcartier TR 2007-412 











Figure 13. Not Acquiring/Acquisition Pending transition state diagram 
Part of the state diagram for object instance attribute ownership, focusing on the Not 
acquiring/Acquisition pending transitions. The left-hand acquisition pending state represents non- 
intrusive acquisition, whereas the right-hand states represent intrusive acquisition. 

When an Unconditional Attribute Ownership Divestiture occurs, the federate 
immediately ceases to own the instance attribute. It may become unowned, or the 
RTI may immediately grant ownership to some other federate that had previously 
requested Attribute Ownership Acquisition. If there are no such “acquiring” 
federates, other publishers are prompted by the RTI through the Request Attribute 
Ownership Assumption callback. This is the only circumstance under which the 
RTI will actively pester the federates to assume ownership. 

With the Negotiated Attribute Ownership Divestiture service, the federate puts itself 
in the “divesting” state, whence it may return through the Cancel Negotiated 
Attribute Ownership Divestiture service. If other federates are already in the 
“acquiring” state (failing that, the RTI will prompt potential new owners as in the 
unconditional case), the divesting federate receives a Request Divestiture 
Confirmation callback. It then confirms the transfer of ownership by invoking the 
Confirm Divestiture service. The federate can also leave the “divesting” state by 
unpublishing the attribute or by divesting it in one of the other two means mentioned 
earlier. 


DRDC Valcartier TR 2007-412 


27 



With the Unpublish Object Class Attributes service, the federate immediately ceases 
to own any attribute of every single instance of the unpublished object class; unlike 
Unconditional Attribute Ownership Divestiture, the RTI will not offer ownership to 
eligible federates other than those actively pursuing acquisition. 

Ownership management is rounded out by the Query Attribute Ownership service, to 
which the RTI responds through an Inform Attribute Ownership callback. A simpler 
form of the query is the Is Attribute Owned By Federate service, which returns a 
Boolean immediately. 


Time Management 

These services and associated mechanisms provide a federation execution with the 
means to order the delivery of messages (service and callback invocations) 
throughout the federation execution according to a logical time scale. The 
federation execution has a single global “clock” which tracks the federation time. 
This time is advanced in cooperative fashion by the various federates, and serves to 
preserve causality. The only way the federation clock may be turned back is through 
the save/restore facility. The description of the services that make up this group will 
be kept to a minimum here, as these services were not the focus of this work and 
have been better described by others (see for example [30] Fujimoto and Weatherly 
1996, [31] Carothers et al. 1997, [32] DISTI 1997). 

Messages are delivered according to two ordering types', receive order and time- 
stamp order. The former ordering type is “timeless” in the sense that it ignores 
logical time considerations and is delivered as soon as possible in real time. 

Similarly, federates may be time-regulating , time-constrained , both or neither (this 
status can change freely during execution). Time-regulating federates are the only 
ones sending time-stamped messages, whereas time-constrained federates are those 
receiving time-stamped messages. The actual ordering type of a sent or received 
message depends on the status of the involved federates, the message’s preferred 
ordering type, and the specific variant of the service used (i.e. whether or not a time- 
stamp argument is provided). 

Apart from time management services, relatively few services can accept a time- 
stamp argument: Request Federation Save, Update Attribute Values, Send 
Interaction and Delete Object Instance. Note in particular that ownership 
management is not time-stamped, which means precautions must be taken to avoid 
odd situations where instance attributes are, for a given logical time, owned by either 
no federate or several federates. 

In part to allow optimistic simulations (where some of the federates anticipate events 
by processing them ahead of time so that the results of their computations are readily 
available when the events do occur), the time management services provide an event 
retraction capability: within some logical time constraints, a time-regulating federate 
may send messages time-stamped in the federation’s future and later Retract them. 
Retracted events will either be simply removed from other federates’ queues (if not 
delivered yet) or cause the affected federates to receive a Request Retraction 
callback. 


28 


DRDC Valcartier TR 2007-412 



A key concept of HLA time management is the federate lookahead. This is a span 
of logical time, extending from the federate’s current logical time value into the 
future, within which the federate may not send time-stamped messages. It can be 
conceived as the “thickness” of the federate’s “now”, or as the federate’s “reaction 
time.” Its purpose is to avoid a variety of time deadlock situations. It is modifiable 
through the Modify Lookahead service. 

A federate signals its intent to move its clock ahead through the Time Advance 
Request [Available], Next Message Request [Available] and Flush Queue Request 
services. This switches the federate from the “time granted” state (the normal 
operating state) to the “time advancing” state. The Time Advance Grant callback 
completes the process by switching the federate’s state back to “time granted.” 

Federates change their time status with the Enable/Disable Time 
Regulation/Constrained services. The Enable services are acknowledged by the 
callbacks Time Regulation/Constrained Enabled (the Disable services automatically 
succeed, so no acknowledgement callbacks are required). The preferred ordering 
type of attribute updates and interactions are modifiable through the Change 
Attribute/Interaction Order Type services. Whether receive-order messages may be 
received while in the “time advancing” state is controlled through the 
Enable/Disable Asynchronous Delivery service. 

Finally, the federate can query the RTI about a variety of time management 
parameters through the Query Lookahead, Query Logical Time, Query GALT 
(greatest available logical time) and Query LITS (least incoming time stamp) 
services. 


Data Distribution Management 

These services provide a set of powerful filtering mechanisms allowing the 
exclusion of irrelevant messages at the instance attribute or interaction occurrence 
level. Both producers and consumers may restrict their publishing and subscribing 
distribution regions according to a federation-defined set of dimensions. The RTI 
ensures that message delivery occurs only when the two sets of regions actually 
overlap. An example would be interaction classes that reflect command and control 
radio traffic: their publication would probably be restricted to a small range (see 
below) over the frequency dimension (the communication’s bandwidth), while an 
electronic warfare listening post would restrict its subscription to the bandwidth it is 
currently listening to. Only if the two ranges overlap is an intercept possible. 

Each of the federation-defined dimensions is an independent axis along which 
ranges may be defined as needed. They are defined by an included lower bound of 
zero and an excluded upper bound which can be any integer type. Typical examples 
of dimensions are latitude, longitude, altitude, and broadcast frequency. HLA 
automatically provides the default region , which encompasses all of the defined 
dimensions in their entire range; in other words, it is the universal nothing-gets- 
filtered-out filter. Unless data distribution management (DDM) is used to modify 
object and declaration management services, these are assumed to use the default 
region. 


DRDC Valcartier TR 2007-412 


29 



DimensionY 


Range along DimensionX (Publication) 






( 


Region 

Set 








Region 

Set 


(Subscription) 

Range along DimensionY 


-► 

DimensionX 

Figure 14. Dimensions, ranges, regions, and region sets 
Overlapping attribute publication (red) and subscription (green) region sets are also shown. 

In the FDD, each object class attribute or interaction may be associated with any 
number of dimensions, depending on the federation’s needs for filtering. This set of 
dimensions is called the attribute’s (or interaction’s) available dimensions. It is 
important to realise that an attribute’s dimension, in the physical sense, has nothing 
to do with the DDM dimension. For example, any attribute of a vehicle class that is 
likely to be of interest to other federates should be associated with the longitude 
dimension in order to allow spatial filtering, not just the longitude attribute. 

Each dimension defines a default range , which can be an actual range or an 
exclusion indicator. Note that a dimension’s default range does not affect the extent 
of the default region. Default ranges come into play when realizing regions, as we’ll 
see shortly. 


30 


DRDC Valcartier TR 2007-412 


















The Create Region service expects as argument a set of specified dimensions , and 
returns a region template. The federate’s choice of specified dimensions signals to 
the RTI its intent to specify a range (a single continuous interval) over each of those. 
Once the bounds have been set for each of the specified dimensions, the Commit 
Region Modifications service may be invoked to create a region specification. The 
range bounds may be modified later on, again using the Commit Region 
Modifications service. This allows regions to be dynamically modified as simulated 
time elapses. 

A region template or specification may be deleted using the Delete Region service. 
Regions that are “in use” (that have been realized, as we’ll see below) may not. 

Region ownership is not transferable: only the region’s original creator federate 
may delete it, modify it, or use it to send an interaction, or to publish or subscribe to 
attributes. The Receive Interaction and Reflect Attribute Values callbacks may, if 
the receiving federate wishes it, include the regions used by the sender. This allows 
the receiving federate to inspect those regions, possibly in order to create duplicate 
regions of its own. 



Register Object Instance with R sgions 
Associate Regions for U Delates 
Subscribe Object Class Attributes With R sgions 
Subscribe Interaction Class with R sgions 
Send Interaction With R sgions 
Request Attribute Value Update With R sgions 


Delete Object Instance 
^ciate Regions for Updates 
s Ownership Divestiture services) 
scribe Object Class Attributes With Regions 
scribe Interaction Class with Regions 


[Local 

Unass 

(varioi 

Unsub 

Unsub 


Ranges of unspecified 
dimensions are filled 
in from default ranges 
(unless excluded) 


Region 

Realization 

^ v 


Coi 


mit Region Modifications 


Figure 15 . Transitions between region templates, specifications and realizations 


DRDC Valcartier TR 2007-412 


31 



Region specifications become region realizations when associated with an object 
instance attribute, an object class attribute or an interaction class. Unspecified 
dimensions that are members of the available dimensions and that had default ranges 
are added by the RTI to the region realization. The region’s contained dimensions is 
the set of dimensions for which the region defines a range. Note that a given region 
specification may give rise to a number of different region realizations, depending 
on the attributes or interactions it is associated with. Note also that federates can 
designate region realizations only in one instance: during a Reflect Attribute Values 
or Receive Interaction callback, the RegionHandleSet received (if any) consists of 
copies of the region realizations used by the sender when the attribute value update 
or interaction was sent. They are read-only, and cease to exist once the callback 
concludes. 

A region cannot be associated with an attribute or interaction if overspecified. That 
is to say, the region’s specified dimensions must be a subset of the attribute’s (or 
interaction’s) available dimensions. 

Figure 16 illustrates the relationships between the various dimension sets described 
above. The federation defines the outer set, the defined dimensions. A region’s 
specified dimensions and an attribute/interaction’s available dimensions are 
independent subsets of the defined dimensions. For a region to be applicable to an 
attribute/interaction, however, its specified dimensions must be a subset of the 
available dimensions, which is what is shown here. The defined dimensions can be 
subdivided into those dimensions that have a default range (on the right) and those 
that don’t (“excluded” dimensions, on the left). When a region realization occurs, 
by associating an attribute/interaction with an applicable region specification, the 
resulting contained dimension set is the one filled in yellow. 


32 


DRDC Valcartier TR 2007-412 




A Venn diagram illustrating the relationship between different dimension sets. 


The fact that each region defines at most one range over each dimension (thus 
describing a hypercube of sorts) is quite limitative, which is why publications and 
subscriptions are defined over sets of regions. As Figure 14 shows (in red), a fair 
approximation to a two-dimensional circle can be achieved by defining a suitable set 
of rectangular regions. Region sets can also be used to describe discontinuous 
(broken up) volumes. 

For an interaction to be received, for an object instance to be discovered and for 
attribute value updates to be reflected, the publication and subscription regions must 
overlap. Overlap is determined by looking at the publisher’s and subscriber’s region 
sets. There is overlap between the sets if at least one publisher’s region overlaps one 
subscriber’s region. A given publisher region overlaps a subscriber region only if 
they have at least one contained dimension in common and if the ranges overlap for 
each contained dimension common to the two regions. 

Figure 17 shows a crude example where a radar has defined a subscription region set 
that roughly represents its coverage volume using the radar cross-section and easting 
dimensions (not shown are the northing and altitude dimensions). An aircraft object 
defines its publication region based on its current position and radar cross-section. 
When the two region sets do not overlap, the radar federate does not discover the 
target object and does not have to spend any computation time rejecting the potential 
detection. 


DRDC Valcartier TR 2007-412 


33 









Radar Cross-Section 



Figure 18 shows the converse, where the radar has defined a publication volume 
using the radiated power and easting dimensions. The aircraft object defines its 
subscription volume based on its current position and radar warning device 
threshold. While the two region sets do not overlap, the aircraft federate does not 
waste time triggering its radar warning device algorithm. 


34 


DRDC Valcartier TR 2007-412 

































Radiated Power 



Figure 18. Another example 

The declaration management services modified by DDM are the subscription 
services only. The object management services modified are the object registration, 
interaction sending and attribute value updating sendees. The umnodified sendees 
behave as if they were using the default region. Whenever an attribute is without 
any associated regions, it reverts to the default region. Conversely, whenever at 
least one region is associated with an attribute, it is unassociated from the default 
region. 

Register Object Instance With Regions combines atomically the Register Object 
Instance and Associate Regions For Updates services, preventing the newly declared 
object from having its published attributes associated with the default region, 
however briefly. 


DRDC Valcartier TR 2007-412 


35 


































The region creation process involves identifying the various handles involved 
(federates initially know only the names of dimensions, object classes and so on, and 
must therefore use a variety of Support Services to accomplish this translation), 
creating a dimension set from the subject’s available dimensions, invoking the RTFs 
Create Region service (a region factory) to create a region having those specified 
dimensions, and modifying each specified dimension’s range as needed. Once this 
process is complete for each of the regions making up the set, the set is committed 
through the Commit Region Modifications service, and can then finally be used in 
an attribute association or subscription sending. The region set may be modified and 
the changes committed again as necessary; a typical usage is to have various 
publisher or subscriber “footprints” move over the battlefield’s dimensions 
(detection and coverage volumes, transmission bandwidths, and so on). 

Additional regions may be associated and unassociated freely with the attributes. 
Once a region is no longer needed (that is to say, it is no longer associated with 
anything), the Delete Region service may be used to get rid of it. 

Ownership services are indirectly affected by DDM. Whenever instance attribute 
ownership is transferred between federates, all of the original owner’s region 
associations lapse. To preserve region associations during ownership transfer, the 
prospective new owner must, as part of its acquisition process, associate the instance 
attributes beforehand. These associations have no effect until ownership is actually 
transferred. 

The Attribute Relevance and Attribute Scope advisories are directly affected by 
DDM, unlike the Object Class Relevance and Interaction Relevance advisories. 
Whenever an instance attribute publication region set ceases or begins to overlap a 
subscription region set, the publisher may get the former advisory while the 
subscriber definitely gets the latter advisory. The publisher’s Attribute Relevance 
advisories are less frequent because they only occur when the status changes 
between “no subscribers” and “some subscribers”; they are not triggered by changes 
in the make-up of the set of subscribing federates. The subscriber’s Attribute Scope 
advisories are more frequent but are more specific: only those subscribers that are 
concerned get them. 


Support Services 

This service group includes miscellaneous services used to perform name-to-handle 
and handle-to-name transformations (for object classes and instances, attributes, 
interaction classes, parameters, dimensions, transportation and ordering types), to 
change advisory switches (object class relevance, attribute relevance and scope, 
interaction relevance), to manipulate regions, and to control callback invocations. 
There is no need to detail these services here except to mention that none of them 
give rise to callbacks: they all return a result immediately if pertinent. As a general 
rule, these are the only services that can be invoked from within the federate service 
thread. 


36 


DRDC Valcartier TR 2007-412 



Threads and Process Models 


Neither the IEEE 1516 specification nor the HLA 1.3 specification imposes a 
process model. However, the standard HLA 1.3 implementation, the DMSO 1.3NG 
RTI, did impose indirectly a single-threaded or asynchronous process model through 
the RTiambassador tick () service, which was expected to be “invoked 
frequently.” 

There are three possible process models: single-threaded (also called polling ), 
asynchronous and multi-threaded. Each specifies when to devote processor time to 
the local RTI component (LRC). The LRC is the part of the RH that is responsible 
for transmitting the federate’s service invocations to the RTI at large, for invoking 
the federate’s callbacks in response to RTI messages, and for maintaining the RTFs 
MOM objects and interactions. 

In the single-threaded or polling process model, the federate application is 
responsible for yielding process time to the LRC through frequent t i c k () 
invocations. The LRC executes only while the federate waits for the tick () 
invocation to complete. If one considers the federate’s code and the LRC’s code, 
execution occurs at only one spot of either one at any time (there is a single “cursor” 
shared between the two blocks of code). 

In the asynchronous process model, there are two concurrent threads that do not 
intermingle, one for the federate and one for the LRC. The federate is responsible 
for signaling when it is ready to receive callbacks through the tick () invocation. 
Continuing the preceding allegory, there are two “cursors”, one in each block of 
code (the federate’s and the LRC’s) and both execute at the same time, except when 
the LRC’s cursor “invades” the federate’s code in the body of the latter’s callbacks. 

In the multi-threaded process model, finally, the LRC runs in its own separate thread 
(the federate service thread) and can invoke callbacks at any time. There is no 
tick () service. Continuing the allegory, there can be multiple cursors in either 
block, and the LRC’s cursors can freely scan the federate’s code at any time. 

In HLA 1.3, there was a specific exception, ConcurrentAccess, which was thrown 
when a FederateAmbassador callback tried to invoke an RTiambassador service. 
In other words, the LRC accepted RTiambassador invocations only when not busy 
invoking a federate callback. This exception disappeared from the IEEE 1516 
specification. However, Pitch pRTI1516, despite being multi-threaded, still behaves 
in a similar fashion: to ensure consistent sequencing of callback deliveries, each 
federate is assigned a single federate service thread, and while this thread is busy 
invoking a federate callback, most RTiambassador invocations will cause an 
RTIinternalError: Concurrent access attempted to cmethod name>to 
be thrown. This apparently serves to ensure the federate does not undergo any state 
transitions during a callback; in other words, the RTI treats federate callbacks as 
atomic. 


DRDC Valcartier TR 2007-412 


37 



In any case, making a federate multi-threaded is a tricky matter, since a new federate 
callback invocation can occur at any point (except during a callback invocation in 
the Pitch pRTI1516 case). Assertions regarding the federate’s state are only valid 
instantaneously unless precautions are taken. These typically involve setting up 
various synchronization semaphores in order to protect critical sections of code. But 
such precautions entail their own share of problems, such as the risk of deadlock. 

Synchronization Issues 

If we assume a fully multi-threaded RTI, the only thing that we can be sure of is that 
the callbacks will not occur concurrently: the LRC will evoke each callback in 
sequence from a single Federate Service Thread. Even that may change in some 
future RTI implementations. The callbacks themselves are not guaranteed to be 
received in any particular order (because of network delays, among other things) 
unless time management is used and several conditions are satisfied at once. For a 
message to be sent and received in time-stamped order (TSO): 

• It must be an attribute value update, object deletion or interaction occurrence 
(note in particular that ownership negotiations are not susceptible to time-stamping); 

• The interaction class or object instance must have a preferred order type of TSO 
in the FDD (if not, this may be changed, locally to the federate, through the Change 
Attribute/Interaction Order Type services, on a per-instance basis in the object case); 

• The sending federate must be time-regulating; 

• The time-stamped form of the service must be used by the sending federate; and 

• The receiving federate must be time-constrained. 

Sequences of related messages can reasonably be expected to be received in order, 
either because the RTI implementation makes sure of this, or because the main 
factor responsible for scrambling message arrival times (i.e. network jitter) is likely 
to be relatively constant for messages fired in quick sequence from a single origin. 
For example, an object instance will be Discovered before the related Attribute 
Scope Advisory is received, and this in turn will precede any Attribute Value Update 
Reflection. 

What is much more likely to occur are mutually unrelated messages, such as 
interactions, attribute value updates of different object instances, ownership transfers 
and so on. It is tempting to have the federate devote a thread to each of these 
unrelated objects, but the overhead associated with constant context switching may 
be too costly, depending on the application. Some form of message dispatching is 
clearly desirable. The simplest form has the Federate Service Thread perform crude 
validation on the messages as they arrive (because the Federate Ambassador 
exceptions can only be thrown from that vantage point) and then store them in a 
queue for later processing by another thread or threads. 


38 


DRDC Valcartier TR 2007-412 



The queue may be a simple first-in first-out (FIFO) implementation, with a single 
worker thread grabbing each message in turn, or it could be more sophisticated. One 
possibility is to sort the messages into separate queues by type (one queue for object 
discoveries, another for object removals, and so on), allowing various priority 
schemes to be readily applied. Another possibility is to sort the messages by 
simulation aspect: there would be one queue for each interaction class, another for 
each object class, another for each object instance, maybe even another for each 
object instance attribute. Yet another possibility would be a mixed scheme. 

Another important design consideration is the tracking of simulation-related states. 
The federate needs to know what it has subscribed to, through which regions, and so 
on. This can be filled in from the various MOM HLAreport interactions, or it can 
be tracked from the federate’s end. For example, to find out whether an object 
instance attribute is subscribed to or not, one can either have a flag attached to the 
internal representation of that attribute and change that flag as subscriptions are 
established and withdrawn, or one can send an HLArequestSubscriptions 
interaction, to which the RTI responds with an 

HLAreportObj ectClassSubscription interaction for each object class one is 
subscribed to. Once the one with the correct HLAobj ectclass is received, its 
HLAattributeList field can be scanned to see if the attribute in question is there 
or not. As can be seen, considerable overhead is involved in the latter approach, not 
to mention message traffic. In any case, some state information is missing from the 
MOM; for example, there is no way to find out whether the subscribed attribute 
instance of the example is currently in scope or not, nor which regions the 
subscription is currently being filtered through. 

In our Chat Clients, we ended up tracking whether object instances were owned or 
not, whether they were subscribed to or not (at the class level), whether they were up 
for divestiture or not, and whether they were in scope or not. 

Pitch pRTI1516 


According to the DMSO RTI Verification Status Board 

( https://www.dmso.mil/public/transition hla/rti/statusboard) . the only verified IEEE 
1516 implementation is Pitch SA’s pRTI 1516. There are only two others currently 
undergoing verification: MAK Technologies Inc.’s High Performance RTI and 
Magnetar Games’ Chronos. Other implementations are the open-source XRTI, and 
CAE Canada is experimenting with a 1516 partial RTI implementation. 


DRDC Valcartier TR 2007-412 


39 



Magnetar Games (http:// www.magnetargames.com/, formerly Ibis Research, 
http://www.ibis-research.com ) has been developing FederationX since 1997. 
Magnetar stands for Metaprogrammable AGent NETwork ARchitecture 
( http://www.magnetar.org, ) . The aim is the creation of a research-oriented open- 
software Collaborative Metaprogramming Framework (CMF) supporting small 
teams of developers and product designers who endeavour to create rich-media 
collaborative real-time entertainment and educational software. A core concept of 
FederationX is that of systems which execute domain-specific metaprograms 
expressed in extensible Markup Language (XML). The metaprogrammable features 
of systems are built up from FederationX engines. The networking engine is 
Chronos, an IEEE 1516 implementation using Microsoft’s DirectPlay 
communications layer. The result is a high performance and scalable seivice 
supporting large scale peer-to-peer and massive client-server applications. A similar 
effort is Cybernet Systems Corp.’s OpenSkies RTI, although it is based on the older 
HLA 1.3 specification. 

The extensible Run-Time Infrastructure (XRTI; 

http://www.npsnet.org/-npsnet/xrti/) is an open-source, freely redistributable, Java- 
based partial implementation of IEEE 1516.1. The aim of the XRTI project is not to 
compete with commercially available run-time infrastructures, but rather to provide 
a foundation for research into improvements and extensions to the HLA. It does 
address a number of themes currently being actively pursued by a number of SISO 
HLA Product Development Groups (PDGs), such as dynamic FOM modification 
during federation execution and RTI interoperability. 

Because of this lack of real choice, no comparisons could be made, and the decision 
was made to leave such efforts for a later endeavour. A few comments are 
nevertheless in order. 

The pRTI 1516 package installs and runs without any trouble, although it must be 
said that no extensive testing was conducted. The Javadoc is essentially non¬ 
existent, which is unfortunate. This is a result of the IEEE 1516.1 specification, 
whose Annex B (the Java API) is normative. 

The supplied documentation is meagre; the LIser’s Guide mentions one way to 
obtain an RTIambassador interface for C++ (through the undocumented 

hla. rtil516 . die . RTIambassadorFactory class’s 

createRTlambassador (String[] ) method). Proximity to the mysterious 
hla.rtil516.die.RtiFactory and hla.rtil516.die.RtiFactoryFactory 

classes does make one hesitate to use it, however. Later on, the same LIser’s Guide 
mentions the Java preferred approach, the se.prtii5l6.RTl class’s constructor. 
This is also where one learns of the se .prtil516. FederateAmbassadorlmpl 
class. 

Inspection of the prt H516. j ar Java archive file reveals the 

hla. rti 1516 . utility classes, which seem to be an OMT data type 

implementation. Alas, without documentation, one hesitates to use them. 


40 


DRDC Valcartier TR 2007-412 






We ended up modifying the API files to include extensive Javadoc, mainly for ease 
of development and reference (Annex B). The Pitch-specific API is, 
understandably, proprietary and undocumented. There are some classes with 
tantalizingly significant names, such as hi a. timei5i6 . Normal izedlnterval, 
hi a.time 1516. Normal izedTime, and se.prtil5l6. Encoder (which seems to 
implement a few of the OMT datatypes: HLAinteger32BE, HLAboolean, 
HLAunicodeString, HLAresignAction, HLAhandle, HLAlogicalTime , plus 
the apparently misnamed HLAlogicalTimelnterval). 

Bugs 

UlegalArgumentException not thrown 

According to IEEE 1516.1-2000, “12.4.2.15 Constrained set of attribute designator 
and value pairs: [...] AttributeHandleValueMap [...] extends java.util. Map [...] The 
values are instances of byte[]; UlegalArgumentException shall be thrown for 
violations. [...] The implementation shall not accept null mappings.” 

However, someAttributeHandleValueMap.put(someAttributeHandle, 
null) fails to throw the expected UlegalArgumentException. 

ParameterHandleValueMap (IEEE 1516.1-2000 12.4.2.16 Constrained set of 
interaction parameter designator and value pairs) suffers from the same bug: it fails 
to throw UlegalArgumentException when putting a null value. 


Large Dimensions not Handled Correctly 

Pitch pRTI1516 (2.3rl build 101) is unable to read FDDs that define large 
Dimensions. Specifically, as soon as a dimension’s upper bound reaches or exceeds 
2 31 = 2 147 483 648, the RTiexec throws an "ErrorReadingFDD: Invalid dimension 
upper bound" exception. Clearly this is because it internally attempts to convert the 
upper bound to an int instead of a long (which is what the API allows). Note that 
Visual OMT 1516has no problem dealing with large Dimensions. 

Reserved Names Not Rejected 

Although IEEE 1516.1-2000 simply states “6.2 Reserve Object Instance Name: [...] 
The value of the supplied name argument shall not begin with "hla"”, the intent 
seems to be as stated in IEEE 1516.2-2000: “3.3.1 Conventions - Names: [...] c) 
Names beginning with the string "hla", or any string that would match (('H'|'h') ('l'|T) 
('A'|'a')), are reserved and shall not be included in user-defined names. [...] e) A 
name consisting of the string "na", or any string that would match (('N'|'n') ('A'|'a')), is 
reserved [...] and shall not be included as a user-defined name.” 1516.2-2000 goes 
on to list the names for which the rules are applicable, omitting object instances 
presumably because of the document’s focus on the OMT. 


DRDC Valcartier TR 2007-412 


41 



Pitch pRTI1516 adheres strictly to the 1516.1 definition, and throws an exception 
only for user-defined object instance names beginning with "hla". The fact that it 
allows names beginning with "hla" or "Hla", etc., is arguably not a bug per se but 
rather a potential problem with the interpretation of IEEE 1516. 

Orphans Not Deleted 

IEEE 1516.1-2000 states: “6.1 Object Management - Overview: [...] Orphaned object 
instances are unknown by all joined federates and cannot be discovered by any 
means. [...] Orphaned object instances shall be unreachable by joined federates and 
should be dealt with appropriately by the RTI.” 

Unfortunately, the phrase "should be dealt with" is never defined. Arguably, 
deletion is the appropriate policy: the orphans are undiscoverable, and attempting to 
register new instances of the same names will fail whether the orphans have been 
deleted or not. So they might as well be deleted, one may reason. The fact that 
Pitch pRTI1516 (2.3rl build 101) fails to "deal appropriately with" (i.e. delete) 
orphaned object instances is again not a bug per se, but rather an IEEE 1516 
interpretation problem. 

lnteger64Time Missing 

The 1516.1 specification states “12.4.2.23: [the] implementers of the Java API shall 
provide [... ] an implementation of the interface LogicaiTime called 
Integer64Time, [...] an implementation Of the interface LogicalTimeFactory 
called integer64TimeFactory, [...] an implementation of the interface 
LogicalTimelnterval called Integer64TimeInterval, and [... ] an 
implementation of the interface LogicaiTimeintervaiFactory called 
lnteger64TimelntervalFactory”. No such implementations could be found in 
the Pitch packages. 

Instead, we find se.prtil5l6 .LogicalTimeDouble, 
se.prtil516.LogicalTimeFactoryDouble, 
se.prtil5l6.LogicaiTimeIntervalDouble , and 

se.prtil5l6 .LogicalTimelntervalFactoryDouble, which offer some 
additional (undocumented) methods. The end functionality is essentially the same, 
but one nevertheless wonders what else the certification process overlooked. 

Federate Service Thread Synchronization Bug 

Assume a Java class with subclasses handling the FederateAmbassador calls. The 
HLAautoProvide switch is Enabled. In what follows, the code has been simplified 
to the utmost (try/catch blocks aren't shown, etc.). 


42 


DRDC Valcartier TR 2007-412 



In the main thread, at some point we have: 

synchronized(_me) 

{ 

_rtiAmbassador.associateRegionsForUpdates(_handle, 
_newDistributionRegions) ; 

[ some calls that prepare an AttributeHandleValueMap object (_ahvm) 

] 

_rtiAmbassador.updateAttributeValues(_handle, _ahvm, null); 


In the FederateAmbassador . provideAttributeValueUpdate handler, we have: 

[ validation code that checks the arguments passed in ] 
synchronized(_me) 

{ 

[ some calls that prepare an AttributeHandleValueMap object (_ahvm) 

] 

new Thread() { public void run() { 

_rtiAmbassador.updateAttributeValues(_handle, _ahvm, null); 

} }.start(); 

} 

The key factor is that both snippets of code synchronize on the same object (_me). 

Now a race condition occurs. Sometimes, the main thread enters and leaves the 
synchronized block before the Federate Service thread reaches its synchronized 
block. All is well, execution flows smoothly. 

However, at other times the main thread is still within the synchronized block when 
the Federate Service thread starts up (because the associateRegionsForUpdate 
call has caused the object instance represented by handle to come into scope for 
some other federate, and the RTI then fetches the attribute updates in preparation for 
distribution—remember that AutoProvide is turned on). The Federate Service 
thread will appropriately stop just before the synchronized block, because that 
monitor is owned by the main thread. What is buggy, however, is that the main 
thread’s updateAttributeValues call then blocks for no discernible reason. The 
entire execution freezes as a result. By rights, the main thread’s 
updateAttributeValues call, even though it'll put calls in the Federate Service 
thread’s queue for later processing, should return normally so the main thread can 
then exit the synchronized block. 

Put succinctly, if the Federate Service thread is in any kind of synchronization¬ 
waiting state (a semaphore, say), then a federate-triggering RTiambassador call by 
any thread will freeze, even if the latter rti ambassador-caller does not own any 
monitors. 

It’s as if the RTiambassador call, in the local RTI component, needed to wait after 
the FederateAmbassador, running in the Federate Service thread, to acknowledge 
the events being added to its queue, or something like that. Without knowing how 
the RTI is implemented, this surmise may be completely wrong; what matters is that 
the bug is real and potentially disastrous in its consequences. 


DRDC Valcartier TR 2007-412 


43 



Interestingly, even the pRTI Explorer seems confused about the state of the 
federation, as it reports the frozen federate as having no discovered instances of 
anything (even though there are some). This may conceivably be just a side-effect 
of the federate’s frozen state on the Explorer’s display methods. 

Visual OMT 1516 

Although there were a number of commercial offerings when the time came to edit 
OMT files for HLA 1.3, there is a dearth on the IEEE 1516 side. Several of the 
companies that existed at this project’s outset have apparently gone out of business, 
or have failed to make the 1516 move. 

Pitch offers its own tool, Visual OMT 1516, which has the excellent feature of being 
able not only to import 1.3 OMT files, but also to export 1516 object models to the 
1.3 format. Automatic conversion is supported to a reasonable extent; since DDM is 
very different in 1.3 compared to 1516, human intervention is unavoidably required. 

Visual OMT 1516 supported our federation object model design process without any 
serious trouble. Because there were really no other tools to compare it with, and 
because we made only light use of object model editing, no recommendations are 
made on this subject. 


Bugs 

The Visual OMT 1516 (version 1.04) interface suffers from one apparent bug, which 
may be in part a matter of design. When one wants to attach a note (a table of which 
is part of the OMT) to some item in the object model, one pops the contextual menu 
and navigates to the Notes sub-menu. It displays the Notes table, which can be 
edited in-place (a very nice feature). The Enter key shifts the focus to the next note 
in the list, the delete key deletes the current note, and so on. 

To (un)associate one (or several) note(s) to the item, one (un)checks the tick box(es) 
appearing beside the chosen note(s). This can be done with the mouse or the space 
bar. But the changes “take” only if one exits the menu in a very specific, counter¬ 
intuitive way: by (right or left) clicking one of the application menu titles. This is 
very puzzling behaviour. It would have been much simpler to have the ticks “take” 
without the need for any further action. The Visual OMT 1516 User’s Guide is 
unhelpful on this subject, as it declines to detail how notes are (un)associated to 
object model items. It laconically states “To add a note, right-click in the table-cell 
or on the label and select Notes on the menu.” 


44 


DRDC Valcartier TR 2007-412 



3. JACK™ Intelligent Agents 

JACK™ Intelligent Agents is an agent-oriented development environment built on 
the JACK Agent Language (JAL), which is an extension of the Java programming 
language. It is the property of Agent Oriented Software (AOS) Group, based in 
Australia, the United Kingdom and the United States. 

In the same way that object-oriented programming introduces a number of key 
concepts that influence the entire logical and physical structure of the resulting 
software system, so too does agent-oriented programming. In agent-oriented 
programming, a system is modelled in terms of agents. These agents are 
autonomous, reasoning entities capable of making pro-active decisions while 
reacting to events in a real-time environment. 

Agent-oriented programming ([33] Shoham 1993, [34] Wooldridge and Jennings 
1995) is an advanced software modelling paradigm that arose from research in 
distributed artificial intelligence. It addresses the need for software systems to 
exhibit rational, human-like behaviour in their respective problem domains. This 
makes it ideally suited to the task of lightening the operator load required for a 
constructive simulation. Agents of varying degrees of sophistication could be 
responsible for simulating various expected entity behaviours, ranging from a 
civilian bystander’s reaction to a sudden burst of gun fire, to the cunning expected of 
an adversary general. A similar pursuit of verisimilitude has been observed in the 
software gaming industry, where the quality of the behaviour of simulated entities 
can make or break the commercial success of the title. Adventure role-playing titles 
strive to have complex non-player characters that can actually keep parts of the plot 
in motion independently of the player’s choice of actions, or serve as reasonably 
believable adventuring associates (hirelings, comrades, allies). Empire-building 
simulations strive to provide believable (and tuneable) adversaries that can give the 
player a good run for his money without resorting to obvious cheats such as 
drastically reduced time and money costs. The list goes on. 

The term agent is widely used to describe a range of software components ([35] 
Franklin and Graesser 1996), varying in capability from procedural wizards (found 
in popular desktop applications), to information agents (used to automate 
information search and retrieval), and to intelligent agents capable of reasoning in a 
well-defined way. The agents used in JACK are intelligent agents. They model 
reasoning behaviour according to the theoretical Belief Desire Intention (BDI) 
model of artificial intelligence ([36] Bratman 1999). 


DRDC Valcartier TR 2007-412 


45 




Following the BDI model, JACK intelligent agents are autonomous software 
components that have explicit goals to achieve or events to handle {desires). To 
describe how they should go about achieving these goals, these agents are 
programmed with a set of plans. Each plan describes how to achieve a goal under 
varying circumstances. Set to work, the agent pursues its given goals (desires), 
adopting the appropriate plans (intentions) according to its current set of data 
(beliefs) about the state of the world. This combination of desires and beliefs 
initiating context-sensitive intended behaviour is part of what characterises a BDI 
agent. 

An agent can be thought of as a person with access to a procedures manual. The 
procedures manual (set of plans) describes the steps that the agent should take when 
a certain event arises or when it wants to achieve a certain outcome. At first glance, 
this may seem like ordinary expert system behaviour—with all the limitations that 
this implies. However, the crucial difference in agent-oriented systems is that the 
agent exhibits goal-directed focus: it focuses on the objective and not the method 
chosen to achieve it. In addition, the agent is continuously aware of context, re¬ 
evaluating the validity or relative importance of various goals being pursued 
simultaneously in the light of new events or goals. 


Overview of JACK 

Events 

Quite naturally, agent-oriented programming is an extension of event-driven 
programming. When an event occurs, it is either posted to the agent owning the 
entity wherein it arises, or sent to a specific different agent. The agent handling the 
event may react by taking action. There are a number of event types in JACK, each 
with different uses. These different event types help model: 

External stimuli, such as messages from other agents, percepts that an agent receives 
from its environment, or belief state changes. These events make the agent reactive. 

Internal stimuli, events that an agent sends to itself. These can represent sub-tasks 
that the agent uses to break down complex goals or meta-reasoning events that the 
agent uses to decide which plans to implement. They are integral to the ongoing 
execution of an agent and the reasoning that it undertakes, and make the agent 
proactive. 

Motivations that the agent may have, such as goals that the agent is committed to 
achieving. 


46 


DRDC Valcartier TR 2007-412 



Events are the origin of all activity within an agent-oriented system. In the absence 
of events, an agent sits idle. Whenever an event occurs, an agent initiates a task to 
handle it. This task can be thought of as a thread of activity within the agent. The 
task causes the agent to choose between the plans it has available, executing a 
selected plan or plan set (depending on the event processing model chosen) until it 
succeeds or fails. Multiple tasks can be active at once, the agent using a specified 
task management policy to allocate its execution resources between them. 


Belief Sets 

In addition to ordinary Java data members and other data structures, the JACK 
Agent Language provides belief set classes that facilitate the maintenance of an 
agent’s beliefs about the world, represented in a first order, tuple -based relational 
model. Each belief set relation consists of a set of fields, each of which can be any 
Java primitive type (boolean, byte, char, short, int, long, float and 
double), a string or an object. All, none or some of the fields may be declared 
to be keys. Keys serve to indicate the object of a tuple; that is to say, what the belief 
is about. There will be at most one tuple in the belief set for any given combination 
of distinct keys (if none of the fields are keys, then all of the belief set’s tuples are 
about the same unique object). 

The belief sets automatically maintain their logical consistency: when an agent adds 
a belief that contradicts a previously held belief, the belief set detects this and 
automatically removes the old belief. They are also able to post events 
automatically when certain changes occur. Finally, cursor statements are supported 
(more on these shortly). 

Belief Sets descend from two root classes, supporting Open World and Closed 
World semantics respectively. In a Closed World belief set relation, all statements 
(possible tuples) are either true or false, so that the unknown state cannot occur. In 
an Open World belief set relation, by contrast, all possible statements (beliefs) are 
initially in the unknown state and the agent can therefore establish a fact either by 
assertion (by affirming it) or by elimination (by denying all other possibilities). 
Another way of looking at it is that, in a Closed World, all possible queries have a 
definite yes or no answer, whereas in an Open World some if not most queries will 
probably be unanswerable. 

Closed World relations theoretically represent every possible tuple; in practice, only 
those tuples that the agent believes to be true are stored, and any tuple that is not 
stored is assumed to be false. Open World relations store all true and false tuples, 
and assume any tuple that is not stored to be unknown. 


DRDC Valcartier TR 2007-412 


47 



The JACK Agent Language makes extensive use of logical variables , which, 
although typed, are initially unbound (have no definite value). They can be thought 
of as the unknowns in the initial statement of a problem. The problem is solved 
once all unknowns have been bound to specific values, a process known as 
unification. Unification can be invoked explicitly, or it can occur indirectly. Belief 
sets are normally queried through cursors, which are a means of scanning through 
the successive possible bindings of a set of logical variables. A cursor, when first 
queried, provides bindings for its implicated logical variables. If these bindings are 
determined to be unsuitable to the agent’s purposes, the cursor, when next queried, 
rolls the bindings back and provides a new set of bindings (assuming one exists). In 
this fashion, an agent can entertain successive hypotheses until a satisfactory one is 
achieved. 

Finally, for ease of interoperability the JACK Agent Language defines views, which 
can be thought of as highly abstracted belief sets. Much of the methods and 
behaviours automatically generated by JACK for a normal belief set become 
optional and can be implemented with great freedom of choice by the programmer. 
Views allow any external entity to be encapsulated to serve as a belief set. They can 
be used in a variety of ways, such as querying across multiple belief sets without 
duplicating the beliefs, or turning the keyboard input stream into a source of events, 
to name but two. 


Plans 

Plans are the heart of JACK agent programming. Plans describe sequences of 
actions that an agent can take when events occur. They can be thought of as the 
pages from a procedures manual; each describes, in explicit detail, exactly what an 
agent should do when a given event occurs. 

Each plan is declared as handling a single event. When an instance of a given event 
arises, the agent first constructs the set of applicable plans. This set is initially 
constituted of those plans which the agent uses and which declare they handle this 
event. The agent further discriminates between these plans by checking their 
relevance. The relevant () method of each plan is a static (class-level) method 
which can examine the attributes of the event to decide whether it is relevant or not. 
A final criterion is applicability. The context () method of each plan is dynamic 
(instance-level) and serves to take into account the current circumstances (the 
agent’s current beliefs and any other agent-accessible data). This is where, typically, 
the plan’s logical members’ values are bound. For every possible set of bindings, a 
separate applicable instance of the plan is generated. 

Once the agent has found all applicable instances of each relevant plan, it selects one 
of these to execute. The selection method used is controlled through various 
programming means, which may include the posting of a PlanChoice event. JACK 
agents are fully capable of meta-level reasoning, that is to say, plans about plans. 


48 


DRDC Valcartier TR 2007-412 



The body of a plan is an instance of what the JACK Agent Language calls a 
reasoning method. Reasoning methods extend the normal Java execution paradigm, 
in that each statement is treated as a logical expression that can either succeed or 
fail. Another way to look at it is to consider the reasoning method’s statements as 
being connected by Java conditional-AND operators (each reasoning method 
statement is atomic, however). A reasoning method fails as soon as it reaches a 
failed statement: this fails the plan instance, and the agent then fails the event 
handling or tries again with a different plan instance depending on how it has been 
programmed. 

Besides the mandatory body () reasoning method, a plan may declare other 
reasoning methods as members. This is a convenience that facilitates the breakdown 
of complex plans for maintenance, re-usability and verification purposes. In 
particular, there are the pass () and fail () optional reasoning methods, which are 
automatically invoked by JACK once the plan succeeds or fails, respectively. 

Another JACK Agent Language feature that appears within plans are the reasoning 
method statements or @-statements, language extension tokens which serve to wait 
or watch for certain conditions, to reply to events sent by other agents, or to post or 
send events under a variety of conditional modes (analogous to the usual control 
flow paradigms: if, switch, for, while, repeat until). 


Capabilities 

Capabilities are a programming convenience similar to Java packages. They are a 
means of structuring reasoning elements of agents into clusters that implement 
selected reasoning capabilities. This simplifies agent system design, allows code re¬ 
use, and encapsulation of agent functionality. 

Capabilities are built in a similar fashion to simple agents: constructing them is 
merely a matter of declaring the JACK Agent Language elements required. Events, 
belief sets, views, plans, Java code and other capabilities can all be combined to 
make a capability. 

It should be fairly obvious that a generic, re-usable HLA “module” for JACK is best 
implemented as a capability. 


Multi-Threading 

When we described events earlier, we mentioned that each event triggers a task, 
which corresponds to a thread of activity within the agent. Java is inherently multi¬ 
threaded, and switching between execution threads is normally the responsibility of 
the programmer. The Java execution engine does not guarantee safe points at which 
it will switch execution threads, so it is up to the Java programmer to implement 
object locking monitors and any other concurrency controls which may be required. 


DRDC Valcartier TR 2007-412 


49 



JACK is also multi-threaded but the context switching is managed in large part by 
the JACK kernel. Reasoning methods and task executions are Finite State 
Machines, meaning each statement is executed in a series of atomic steps, between 
which the agent can switch to other execution threads safely. A compound logical 
statement, for example, is executed in the usual short-circuit way, and thus each 
individual Boolean evaluation is a separate step. This simplifies considerably the 
task of making a plan thread-safe. 

Each agent uses a TaskManager object to decide how to allocate its execution time 
between tasks (threads). The two most basic TaskManager strategies are depth-first 
(the agent pursues one task until it completes or blocks, then switches) and breadth- 
first (the agent executes a certain number of steps in any one task before switching 
to another, in round-robin fashion). More elaborate TaskManagers are possible, for 
example, prioritizing tasks. 


JACK-HLA interface 

HLA services, callbacks and JACK events 

It was immediately realised that the HLA callbacks, which can occur at any time and 
are the only form of message issuing from the RTI besides the few services that 
actually return an immediate response value, should map to JACK events. The 
services, on the other hand, can be invoked from anywhere within the JACK code 
simply by providing the RTiambassador reference. 

The HLA-expected behaviour of the Federate Ambassador is, in any case, 
minimalist: in order to allow callbacks to occur at any time and at as high a rate as 
necessary, the callback handler should conclude as quickly as possible. This is best 
achieved, as was discussed earlier, by storing the callback’s arguments and either 
queuing the event internally (for processing by another thread) or spawning a 
separate worker thread. This is precisely what is achieved by posting a JACK event, 
so the match is natural. 

However, the federate does have the opportunity (indeed, the responsibility) of 
throwing exceptions from within the callback’s thread in order to advise the RTI that 
something is amiss. This behaviour is exceptional but may nevertheless be 
necessary. As a general rule, these exceptions are thrown if argument validation 
fails, each exception corresponding to a different validation failure mode. Because 
of the thread constraint, a generic HLA-JACK adaptor module must treat this 
validation activity as an exterior handler. We’ll see later how this was achieved. 


50 


DRDC Valcartier TR 2007-412 



In order to post JACK events, our code needs access to an event posting method 
reference (an event factory) and to an agent reference (in order to invoke the 
postEvent or send methods). We first thought of putting the HLA 
FederateAmbassador implementing class in the project’s Other Files section, but 
this does not work for the simple reason that an agent’s event posting methods, once 
pre-compiled to Java, are private to the agent. There are two ways around this 
obstacle. The first is to add to the agent a series of public methods that each return a 
different event factory. It is crude but effective, and has the main drawback that the 
programmer must go through the drudgery of creating each event factory access 
method manually. In addition, it forces the agent to declare that it posts or sends 
the events (even though it does not) because the handles declaration only mentions 
the event type, omitting the event factory instance. 

The second way is to move the HLA FederateAmbassador implementing class 
into the agent class as an inner class. This immediately gives it access to all of the 
enclosing agent’s members. 

Since the agent must manage several HLAchat instances in any case, putting their 
references in a belief set makes more sense. It becomes relatively easy to recover 
the HLAchat reference as part of each plan’s context() method. 

HLA1516 JACK Capability 

An RTI implementation typically supplies a “null” Federate Ambassador 
implementation which the user is expected to subclass, overriding only those 
callbacks which are of interest to him. This null implementation simply implements 
each of the 56 callbacks but does nothing (the method bodies are empty). This 
makes the user’s subclass code a lot more compact and easier to read. To follow this 
pattern, our HLA 1516 capability should post all possible events but not require the 
user to supply “null plans” for those events which are not of interest. We achieved 
this by having the capability handle each of the events as well as post them, but use 
in each case a null plan that categorically declares itself as irrelevant (the 
relevant () static method returns false in each case). This satisfies the JACK run¬ 
time initialization, which won’t complain that the agent using the capability has 
unhandled events, and neatly avoids the undesirable side effect of having significant 
events “ambushed” by the capability. This would occur because JACK capabilities 
are searched for applicable plans before any of the agent’s (or enclosing capability’s) 
own plans. 


DRDC Valcartier TR 2007-412 


51 



Although the HLA Federate Ambassador interface consists of 56 different callbacks, 
there are only 43 differently named ones. Four callbacks (initiateFederateSave, 
reflectAttributeValues, receivelnteraction, and 
removeobj ectinstance) are overloaded to varying degrees. These sets of 
overloaded callbacks can be safely combined into four events by substituting null 
arguments as needed, since the HLA specification guarantees that no argument will 
ever be null, except for the userSuppliedTag byte arrays which appear in eight 
callbacks (announceSynchronizationPoint, reflectAttributeValues, 
receivelnteraction, removeObj ectinstance, 

provideAttributeValueUpdate, requestAttributeOwnershipAssumption, 
attributeOwnershipAcquisitionNotification, and 

requestAttributeOwnershipRelease). For example, InitiateFederateSave 

has two forms, one with a single argument (a string), the other with two (a string 
and a LogicalTime); the former is rolled into the latter by passing a null 

LogicalTime. 

Several sets of events have the same payloads (field sets) and could conceivably be 
further merged provided some discriminant fields were added. For example, the 

federationRestoreBegun, federationRestored and federationSaved events 
have no fields beside the identifier. There are no clear benefits to be gained from 
such mergers, however, except possibly for those events which pair off in Boolean 
fashion: attributes In/OutOf Scope, turnUpdates Off/On 
ForObj ectinstance, obj ectlnstanceNameReservation Falied/Succeeded, 
requestFederationRestore Failed/Succeeded, start/stop 
RegistrationForObj ectClass, and turnlnteractions Of f/On. This is really 
a matter of programming style more than anything else. 

To allow an agent using the capability to potentially manage multiple federates, the 
capability’s inner class (HLAf ederate) has a single constructor that expects an 
identifier String argument. This argument is prefixed into each event posted out 
of the capability, thus allowing the agent to tell which of the Federate Ambassadors 
generated it. 

Next, to allow the HLAf ederate’s callbacks to throw exceptions as needed, we 
declared 43 interfaces (one for each differently named callback) which consist of a 
single method (validate) accepting the callback’s arguments and throwing its 
exceptions (the method is overloaded just like the callback itself). The 
HLAf ederate stores privately a reference to each of these interfaces, null by default, 
and exposes get and set methods to allow the references to be manipulated. When 
a callback is invoked by the RTT, if the corresponding validation interface reference 
is non-null, the arguments are passed to it before moving on to the event posting 
method. 


52 


DRDC Valcartier TR 2007-412 



Thus, the capHLAisis capability consists of: 

• An inner class (HLAf ederate), which includes a placeholder member for the 
federate’s RTiambassador instance; 

• Forty-three events (MessageEvent) encapsulating the 56 HLA 1516 Federate 
Ambassador callbacks, each both posted (#posts external event) and 
handled (#handles external event) externally; and 

• Forty-three used plans (#uses plan), each of which declares itself as irrelevant 
(the static relevant method returns false) and has consequently no reasoning 
method; and 

• A belief set prototype (bl f hla), an instance of which you must supply to the 
capability. 

The bl f hla belief set is used by the capability to manage the HLAfederate 
instances. The enclosing agent (or capability) queries the belief set in order to 
recover the HLAfederate instance, using the identifier prefixed to the event. This is 
typically done by its plan’s context () method. 

Figure 19 illustrates the process. The RTFs callbacks are handled by the 
HLAfederate instance, which tacks its identifier to the event parameters set when 
invoking the capability’s event factory. The agent may supply validator methods to 
the HLAfederate instance if it wishes exceptions thrown at the RTI. The 
HLAfederate instance has a placeholder for the corresponding RTiambassador 
instance, so the agent’s plans may easily invoke RTI services. 


DRDC Valcartier TR 2007-412 


53 




Figure 19. How an agent uses the HLA capability 
The agent is free to specify Validator interfaces or not; it is also free to ignore irrelevant events. 


External dependencies were kept to a minimum. The capability imports the generic 
hla. rtiisis classes, and two of our own packages. The first, 
ca. gc . drdc_rddc . hla.rtii5i6. omt, implements the HLAopaqueData datatype 
(as specified by IEEE 1516.2 at 4.12.6) which is used to wrap the byte [] arguments 
occurring with certain callbacks. This was necessary to circumvent JACK’S 
inability (in its 4.1wj version) to cope with byte [] event fields. Another possible 
solution would have been a j ava. nio. ByteBuf f er implementation (the Java 2 
Platform class is abstract), but since an HLA-capable JACK agent is likely to use 
other HLA OMT classes, it seemed more logical to supply those anyway. 


The second, ca .gc . drdc_rddc .hla. rtiisis .FedAmb, specifies the event 
validation interfaces. 


54 


DRDC Valcartier TR 2007-412 






In a concrete application, an RTiambassador implementation is required. This is 
part of what each RTI vendor supplies, and its constructor can take a variety of 
guises. Luckily, we don’t need to worry about this. The HLAfederate class 
supplies a placeholder RTiambassador member (rtiAmbassador), which is 
expected to be filled in by the agent using whichever means it finds convenient. 

Finally, we expect the using agent to extend the HLAfederate class as a convenient 
way of keeping all federate-related fields and methods together. In order for the 
belief set’s getinstance query to return the correct obj ect instance, the only 
requirement on the extending class is that its constructor invoke the superclass’s 
constructor through the super keyword, something which Java enforces anyway. 

HLA13 JACK Capability 

Retrofitting the HLA1516 capability for use within an HLA 1.3 context turned out to 
be very easy. The HLA1516 capability was used as a template, the processing 
model remaining the same. The classes and interfaces were repackaged to avoid 
conflicts with 1516, and the methods and interfaces appropriately renamed. 


JACK Integrated Development Environment (IDE) 

The JACK Development Environment (JDE) is decent but suffers from a number of 
really annoying deficiencies. The built-in text editor recognises only a small set of 
key strokes and is seriously deficient when compared with such simple editors as the 
Windows built-in Notepad. Understandably, AOS does not want to spend much 
effort on it and prefers investing in the useful aspects of the engine. JACK does 
offer the capability to use an “external” text editor, which is something we never got 
around to trying out. It may solve the problem nicely. The JDE also seems to suffer 
from some form of memory leakage: after opening, editing, closing and saving 
various parts a fair number of times, we get a message that the JDE is running out of 
memory. At that point, one saves the project and restarts the JDE: a mere 
annoyance. 

It may be that version 5, delivered as this report was nearing completion, solves 
some of these small complaints. 

The JDE is not as robust as it should be, and even an unimaginatively devious user 
can create all sorts of problems for himself. A few examples: 

• If you drag and drop a Named Data to an Agent’s Belief Data container twice, 
you get two identically-named references, which of course won't compile properly. 

• If you create several Named Data instances of various types, they all get the 
same default name "data", which leads to confusion and/or compilation errors later 
on. A simple default name convention could be "data_<BeliefSet Type>_i" (e.g. 
"Belief SetDelusions" would generate "data_Belief SetDelusions_l"). 


DRDC Valcartier TR 2007-412 


55 



• If you Remove an Event Type from the project window, any separate windows 
previously created for that Event remain opened instead of closing (and will still accept 
drag-and-drop, editing as JACK file, etc). One can even create a new Event Type 
using the still-open Event’s name, leading to potentially catastrophic confusion within 
the project’s file structure. The same can occur with Events' Fields, Agents, Plans, 
Capabilities, Events' Posting Methods, BeliefSet Queries, etc. 

• Using drag-and-drop, it is quite possible to mark a Capability as having itself as 
a Sub-Capability. Is this reasonable or will it create an infinite loop of some sort? If 
the latter, care will need to be taken to make sure the Capability hierarchy remains an 
acyclic directed graph (thus if B is a sub-capability of A, then it should not be possible 
to declare A as a sub-capability of B, and so on regardless of the number of 
intermediate steps). 

If one treats the JDE as the fragile thing it is, all is well. Productivity may not be 
what it should be (compared to Java Integrated Development Environments (IDEs) 
such as NetBeans or Eclipse), but it is tolerable. 


JACK Bugs 

Defining an array field for a MessageEvent or BDlMessageEvent (but not for the 
other event classes) causes a compilation problem. This occurs both with primitive 
data types (byte, int, etc.) and with classes in general, although the error reported 
is different. This is apparently (according to AOS) a limitation of using the JACOB 
transportation of message events by default. The solution is either to force the use of 
Java serialization as the event transport mechanism (by adding #set transport 
j ava ; to the event class definition), or to wrap the array in a utility class 
(HLAopaqueData in our case). 


JACK Pre-Processor Bugs 

The JACK-HLA interfacing effort revealed a number of unexpected JACK bugs, 
which arose from its pre-processor. When a JACK application is compiled, the pre¬ 
processor reads the plans, events, agents and other JACK-specific constructs in order 
to process the JACK Agent Language syntax extensions. The remaining code is 
expected to be standard Java but is nevertheless validated as part of the pre¬ 
processor’s parsing. This step is required because JACK must parcel out the Java 
statements into the sometimes rather involved Java structures that make the 
extensions understandable to the Java virtual machine. For example, each of the 
statements in a plan’s reasoning method has to be put in a separate branch of a large 
switch statement at the heart of a finite-state-machine loop understandable by the 
proprietary JACK executable classes. 

It turns out that some unusual Java syntax is involved in invoking or extending inner 
classes, and that the JACK pre-processor did not understand those correctly. This 
resulted in spurious errors being reported during the pre-processing phase. 

Specifically, this line would not compile: 


56 


DRDC Valcartier TR 2007-412 



String s = AgentClass.InnerClass.aConstantString; 

Here we use a qualified class identifier to access an inner class’s static member. A 
simple workaround is to have the outer class pass the inner class’s member out 
through a static member of its own. This line wouldn’t compile either: 

AgentClass.InnerClass inner = agent.new InnerClass(); 

Here we invoke an inner class’s constructor by qualifying it with the enclosing 
instance, as is proper. A simple workaround is to have the outer class pass the inner 
class’s constructors out through a factory method of its own. 

A third instance of the problem arises when one extends an inner class from outside 
itself. In such a case, the Java language dictates that the extending class’s 
constructor use the ancestor’s enclosing instance as its first argument. By itself, that 
works fine, but if you need to invoke the ancestor’s constructor through the super 
keyword, the latter will also need to be qualified by the ancestor’s enclosing 
instance, like so: 

public class 
OuterClass 


public class 
InnerClass 


public class 
InnerClass_DesCendant 
extends InnerClass 

{ 

public 

InnerClass_Descendant(OuterClass containinglnstance) 

{ 

containinglnstance.super() ; 


In this case the qualified super stalls JACK’S pre-processor. There is no simple 
workaround in this case, except to comment the offending line out, compile the 
project, then manually uncomment the super call from the generated agent’s . j ava 
file and recompile it. This is awkward, but it gets the job done. 

Although we have not tested this, AOS assures us these bugs are all fixed in the 
newest release of JACK. 


DRDC Valcartier TR 2007-412 


57 



This page intentionally left blank. 


58 


DRDC Valcartier TR 2007-412 



4. Chat Application 

We chose as our test case a chat application. The main virtue of such a simple 
demonstration is that it pre-existed in both the HLA and JACK cases, a natural 
consequence in both cases of their network-awareness. 

One of the very first network chat applications was ARPANet’s Planet chat system, 
in 1973. Internet Relay Chat (IRC) itself was invented by Jarkko Oikarinen in 1988 
at the University of Oulu, Finland ([37] Hardy 1996, [38] Kantor 2003). It became 
popular after it was made famous during the Iraqi invasion of Kuwait in 1991, where 
it was used by people to get information about events in Kuwait to the outside world 
after all other forms of communication had been cut off. 

A chat application can be a simple text-only interface, command-line-driven, which 
allows a user to (this list is by no means exhaustive, but it is sorted in rough order of 
feature necessity): 

• Log into and out of the network; 

• Send and receive text messages; 

• Join or create chat groups (chat rooms); 

• Send and receive private messages (messages addressed to a single other user); 

• Find out which groups/rooms exist; and 

• Find out which other users are logged on. 


DRDC Valcartier TR 2007-412 


59 














The JACK chat demonstration consists of two executables, a Server and a Client. 
Each instance of the Server agent manages a separate chat network, and each Client 
instance must specify (in its command line) to which Server it will connect. The 
Server is completely automated; the only user int erventions consist of starting it and 
shutting it down. 


[Uses JACK Intelligent Agents Runtime, Copyright 1999-2004, AOS] 
New 'nameseruer' created. 

WARNING: portal connecting to self detected (sds-dthl:5002) 
SeruerPortal created. 

Seruer Host: sds-dthl 
Seruer Port: 5002 

Seruer agent ’ChatSeruer@SeruerPortal' created. 

+++ Seruer startup concluded +++ 

Hit any key to terminate: 


Figure 21. The JACK Chat Server window 
Its role is analogous to the RTI’s RTI Manager application. 

The Client uses a command line interface with a two-state architecture. Initially, the 
Client is in the “Logged-Out” state. The user has a very limited choice of 
commands: 

• The commands qui t or exi t will shut down the Client agent altogether; 

• The command login <username> will attempt to log the Client onto the chat 
network; 

• Any other command acts as a help command and lists the possible commands. 


[Uses JACK Intelligent Agents Runtime, Copyright 1999-2004, AOS] 
Starting chat client... 

Identifying local host... 

Local host identified. 

Looking up chat seruer... 

Local Portal created as M 1111605269029:131.132.34.98" 

Local Portal host is sds-dthl 

Local Portal port is 2851 

Nameseruer address is "localhost:5002" 

Found Seruer agent ChatSeruer@SeruerPortal 

xxxxxxxxxxxxxxxxxxxxxxxxxxx 
X X 

* WELCOME TO "AGENT-CHAT" * 

X X 

xxxxxxxxxxxxxxxxxxxxxxxxxxx 

ChatSeruer@SeruerPortal: 


Figure 22. The JACK Chat Client window at start-up 


DRDC ValcartierTR 2007^12 


61 




If the login fails, the Client remains in the “Logged-Out” state. Otherwise, the login 
request was successfully processed by the Server (that is to say, the requested 
username was available) and the Client is now in its “Logged-In” state, and joins the 
“General” chat group. New commands become available: 

• The logout command disconnects the Client from the chat network and shuts 
down the Client application; 

• The j oin <groupname> command joins the Client to the specified chat group, 
creating the group if necessary; 

• The leave <groupname> command unjoins the Client from the specified chat 
group; 


• The who [<groupname>] command lists the users (including the Client) 
currently in the specified chat group (if unspecified, the Client’s current chat group 
joined is assumed); 

• The msg <text> command sends the message (the specified text) to the users in 
the Client’s current chat group; 

• The msgusr <username> <text> command sends the message (the specified 
text) to the specified user; 

• The group command lists the existing chat groups; and 

• The help command lists the available commands. 

Advisories appear when another user either joins or leaves the group the Client is in. 


62 


DRDC Valcartier TR 2007-412 



XXXXXXXXXXXXXXXXXXXXXXXXXXX 
X X 

x WELCOME TO •■AGENT-CHAT" x 

X X 

xxxxxxxxxxxxxxxxxxxxxxxxxxx 

ChatSeruer@SeruerPortal: login oingo 
Creating Client 'oingo' 


Welcome to the "General" chat group 


xxxYou are 'oingo' xxx 
Login successfull. 

xxxYou are 'oingo' xxx 


Figure 23. The JACK Chat Client window after logging in 


The application, as supplied, suffers from two design flaws: 1) nothing prevents a 
Client from joining multiple groups; and 2) nothing prevents a Client from leaving 
all groups, even the default one. This was clearly unintended since each Client 
remembers only the last group it joined and can only send to its “current” group (the 
last one joined). Joining multiple groups means a client will receive messages from 
all of the groups it has joined. A Client that joins more than one group and then 
leaves the last one no longer blows wfiich group(s) it is in. It considers itself group¬ 
less and thus unable to send any group messages. Finally, a group-less Client can 
only be reached by private messages. 

Clearly the intent was to restrict the Clients to belonging to one and only one group 
at all times, and to have them revert to the default group when leaving a specified 
group. It is possible to properly support multiple-group affiliation (by sending 
messages to all groups one belongs to, and warning the user when he ends up group¬ 
less), but that adds complexity which is not useful for our purpose: an HLA-JACK 
interop erab i 1 ity dem on strati on. 

Figure 24 shows the key features of the JACK Chat demonstrator. Each Client 
instance must go through the same Server, identifying itself through a login request. 
All Client requests go through the Server. The latter maintains three belief sets: a 
mapping of usernames to Client inst ance references, a list of extant groups, and a 
mapping of Client usernames to group names (which keeps track of the group each 
Client is “in”). Using these belief sets, the Server can easily supply lists of groups 
and lists of co-located Clients, as well as manage the flow of messages between 
Clients. 


DR DC Valcartier TR 2007^12 


63 







Figure 24. The JACK Chat demonstration 
In blue, the group management subset. 

In retrospect, the arbitrary decision to maintain the Client-Server architecture used 
by the original JACK demonstration may not have been the best approach. By 
keeping the Client unchanged, we are incurring a double networking overhead. 

Every time HLA invokes a callback in a JACK Federate Ambassador instance, this 
occurs within the Server’s process space. The Server then posts an event to itself 
and goes through the overhead of binding to the Federate Ambassador instance from 
within (one of) its task processing thread(s). The plan then eventually sends a 
message to the appropriate Client, going through JACK’S own communication layer. 
The process occurs in reverse when a Client sends a command out. Note that if the 
Server is using a single task thread (the default setting), it will handle only one 
client’s callback at a time. 

We could have had each JACK Chat instance be its own server. This would do 
away with the JACK communication layer, get rid of the Federate Ambassador 
instance binding overhead (or at least reduce it to a minimum), and allow true multi¬ 
tasking (since each client would operate in its own process space). 


64 


DRDC Valcartier TR 2007-412 



























HLA Chat Demonstration 


Although a number of HLA chat demonstrations exist, we chose to develop one 
from scratch in order to match the operational concept of the JACK chat 
demonstration as closely as possible. 

HLA is a very “democratic” architecture: all federates are equal in importance in the 
eyes of the RH. Breaking this symmetry is possible but is a function of the 
federation’s semantics: during federation development, a federate may be singled 
out to act as a “server” for certain classes of objects, for example. For our Chat 
demonstration, we decided to use a peer-to-peer architecture, where all federates are 
“clients.” This means the JACK “Servers” must become proxies for their Clients, 
managing multiple FederateAmbassador instances on their behalf but having no 
existence as far as the federation is concerned. 



Figure 25. The Java Chat demonstration 

Besides events, the client is aware of User (Participant) and Group (ChatRoom) objects. 

Our pure-Java Chat Client uses a graphical interface. Initially, the Client is in the 
“Logged-Out” state. The user can then either: 

• Shut down the Client altogether; or 

• Attempt to log in after specifying a <username>. 


DRDC Valcartier TR 2007-412 


65 



Log In 


Send 


Chat Room: 


<General> ^ 


New 


Send To: <AII> ▼ 


Welcome to MyCliat - Please log in 

Figure 2(x The Java Chat Client window after .startup 


Once successfully logged in, the Client joins the “General” chat group. The extant 
chat rooms are listed, as well as the other users that are in the same chat room. The 
user can now: 

• Shut down the Client altogether, 

• Log out from the chat network and return to the “logged out” state; 

• Join a group (chat room) by selecting it from the drop-down list; 

• Create a group (chat room), specifying its name (the “New” button); 

• Send a message to the users in the Client’s current chat group, or 

• Send a private message to one of the other users in the Client’s current group 
(message addressees are designated using the “Send To” drop-down list). 

Advisories appear when another user either joins or leaves the group the Client is in. 

As can be seen, the semantics are essentially the same. Key differences are that the 
Client is now always in exactly one group at. a time, and that private messages are 
only possible within the current group. These changes were integrated into the 
JACK chat at the same time that it was interfaced with the HLA chat. We confined 
the changes to the Server part of the JACK chat demonstration, which means the 
Client’s interface is now less suitable. The “leave” command still requires that the 
group being left be specified, which is pointless now since the client can only leave 
the current group. Such is the price of backward compatibility. 

Figure 25 adapts Figure 24 to the Java context. The server is eliminated and the RTI 
acts as a connector between the Client instances, mediating User and Group obj ects 
(as well as Message interactions). The semantics of the federation now reside in the 
expected behaviour of the federates (the Clients), and are thus much less readily 
apparent from this type of diagram. 


66 


DRDC Valcartier TR 2007-412 

















Figure 27. The Java and JACK Chat Client windows after both have joined 



Figure 28. The Chat federation in action 


DRDC ValcartierTR 2007-412 


67 



































HLA Chat Federation Object Model 


Dimensions 

Because we need to use DDM in two different ways (to channel messages by group 
and by user), we shall define two dimensions: 

• ChatRoomSlots ([0..32 768[, excluded by default) 

• UserHandleSlots ([0..2 147 483 647[, excluded by default) 

Here we ran into a bug with Pitch pRTI 1516. The 1516.2 specification states that 
dimensions can be of any simple or enumerated datatype, although their upper 
bound is always specified as an integer. Since the integer basic datatypes (1516.2 
4.12.3 Table 23) are 16-, 32- and 64-bit (two’s complement signed) integers, it 
should be perfectly legitimate to define a dimension that uses the HLAinteger64BE 
datatype. However, pRTI 1516 RHexec throws an ErrorReadingFDD “Invalid 
dimension upper bound” exception when createFederationExecution is invoked 
with an FDD containing dimension upper bounds reaching or exceeding 2 31 = 

2 147 483 648. Apparently pRTI 1516 tries to store internally the upper bound as a 
Java int (32-bit two’s complement signed integer). Note also that the specification 
does not mention what should happen if you define a dimension with datatype 
HLAinteger64BE and then try to define a default range that covers the entire 
positive span: 64-bit signed integers can range up to 2 63 -l, which means an upper 
bound of 2 63 , a number which cannot be represented as an HLAinteger64BE. This 
occurs only because upper bounds are defined by their excluded value (dimensions 
are semi-open intervals, ranging from zero, inclusive, to the upper bound, exclusive). 

Switches 

The switches we enabled are: 

• AutoProvide 

• AttributeScopeAdvisory 

• InteractionClassRelevanceAdvisory 

The AutoProvide switch is simply convenient; it means our subscribing federates 
need not send a Request Attribute Value Update after discovering an object. The 
RTI will solicit the owner automatically with a Provide Attribute Value Update 
callback. 


68 


DRDC Valcartier TR 2007-412 



The Java Chat federate uses the Attribute Scope Advisories to add to/remove from 
its drop-down list of private message targets. The JACK Chat federate does not care 
about these advisories, since the Server resolves the list of potential chatters only 
when a Client requests it (using the who command). The Java federate could have 
used object discovery to accomplish the same thing (an attribute scope advisory 
always follows a discovery notification), but this approach involves considerably 
more overhead. Firstly, in order to receive a discovery notification every time an 
object comes into scope, the federate must “forget” about the discovered object 
(using the LocalDelete service) every time it goes out of scope. This required action 
cannot be accomplished within the scope advisory callback because of the 
ConcurrentAccess feature (q.v.): it must be threaded off. Secondly, this also 
entails the additional attribute value traffic concomitant with discovery. 

The Interaction Class Relevance Advisories, finally, are used in an unexpected 
fashion to solve the federation destruction problem, as we’ll see later on. 

Datatypes 

We defined only two additional datatypes beyond the mandatory basic datatypes: 

• chatRoomRegistryEntry is a fixed record of two fields: 

name is an HLAunicodeString 
slot is an HLAintegerlSBE 

• ChatRoomRegistryEntries is a dynamic array of ChatRoomRegistryEntry 

Attributes of our custom datatypes which are sent to the RTI or received from it are 
passed as byte arrays, and the RTI does no validation whatsoever over them. It is 
entirely up to the federates to ensure that they use the same classes to encode and 
decode the custom datatype attributes. This can be seen as providing flexibility, but 
it is also fraught with potential disaster. Subtle differences in the implementations of 
a custom datatype between two distinct federates may lead to apparently correct 
behaviour until very specific circumstances arise where the byte representations 
diverge, unless cross-certification is exhaustive. 

Interaction Classes 

We defined a single interaction class: 

• Communication has two attributes: 

message is an HLAunicodeString 
sender is an HLAunicodeString 


DRDC Valcartier TR 2007-412 


69 



This represents a chat message being sent across the network. The message is the 
“payload”, that is to say, the text being sent by the user. The sender serves simply 
to identify the sending federate by its user name; this is necessary because users 
expect the interface to attribute messages as they occur, whereas HLA does not 
explicitly provide an interaction’s provenance. In order to make DDM possible, the 
interaction is associated with both dimensions. 

Object Classes 

We defined three object classes: 

• chatRoomRegistry has one attribute: 

list is a ChatRoomRegistryEntries 

• chatRoom has two attributes: 

slot is an HLAintegerlSBE 
name is an HLAunicodeString 

• Participant has three attributes: 

logged_in is an HLAboolean 

user_handle is an HLAinteger32BE 

chat_room_slot is an HLAintegerlSBE 

The attributes of both the chatRoom and the Participant are associated with the 
chatRoomSlots dimension. The ChatRoomRegistry is treated as a “global” 
object and therefore does not have its attribute associated with a dimension. 

General Principles of Operation 

Although HLA considers ownership at the instance attribute level (that is, an object 
instance’s attributes could each be owned by a different federate), in our simulation 
we will treat ownership at the object instance level. Ownership will be transferred 
using the same single attribute set for each instance of any given object class: the 
object’s FOM-specified attributes plus the HLAprivilegeToDeleteObj ect 
attribute. This simplifies what is meant by “ownership” and suits our purposes 
nicely. 

The first important design decision was to forgo time management entirely. None of 
the federates are time-regulating or time-constrained, and all HLA messages will be 
receive-ordered. This simplifies considerably some aspects of the federation, but it 
also means that any required synchronization will have to be accomplished by non- 
time-dependent means. 


70 


DRDC Valcartier TR 2007-412 



In order to allow the users complete freedom in specifying their user names and chat 
room names while avoiding collisions with the RTI-reserved names (anything 
beginning with “HLA”, in any mixture of case), we chose to systematically prefix 
object names. These prefixes are for the federation’s consumption, and are not seen 
by the users. Participant objects’ names are prefixed by “p”, ChatRoom names are 
prefixed with “c”, and chat-system reserved names are prefixed with This 
approach also prevents collisions between user-specified ChatRoom names and 
system-reserved ChatRoom names. 

Role of the Participant Objects 

The Participant object can be described as a “pass”, required for admittance to 
the chat federation. When a user logs on, he does so under a specific user name, 
which must be unique. The user name is borne, appropriately prefixed, by at most 
one Participant object instance. If the federate manages to obtain ownership of that 
Participant object instance (through creation or ownership transfer), the log-on is 
successful. Accordingly, the federate shall refuse to relinquish ownership as long as 
it remains logged on. 

To ensure the uniqueness of user names, it is much simpler to use HLA’s Name 
Reservation service rather than implement some name control scheme of our own. 
However, HLA’s Name Reservation service is persistent , in the sense that once a 
name has been reserved, it cannot be used again, even if the object instance is 
deleted. This means our Participant objects must also be persistent, being deleted 
only when the federation itself is destroyed. Hence the loggedin attribute, which 
serves to mark those Participant instances that are “in use.” 

Another feature of HLA is that objects must not become “orphans.” That is to say, 
they must have at least one owner (i.e. at least one attribute must be owned) at all 
times, otherwise they become undiscoverable (see Ownership Management in 
Section 2 for details). Therefore, we will need to pass ownership ( custody ) of 
“logged out” Participant objects around as federates join and resign from the 
federation. 

The userhandle attribute will serve not so much to identify the owner of the 
Participant object as to allow private messages to be sent. It designates a slot in the 
UserHandleSlots dimension and is very simply the 32-bit integer representation of 
the HLA object instance handle. In that sense, it is just as unique as the object 
instance’s name, and is associated with that name for the duration of the federation. 


DRDC Valcartier TR 2007-412 


71 



Whether we map object instance handles or object instance names (Unicode strings) 
to a dimension (the HLA specification, at 1516.2 4.6.1, states that each federate must 
provide a normalization function that maps values from the federate view of a 
dimension to values in the RTI view of a dimension), we face precisely the same 
problem: they are dynamic arrays of bytes. It is tempting to use the hashcode () 
method to map these “keys” to a 32-bit integer dimension. However, the standard 
j ava. lang. string.hashcode () implementation is more likely to produce 
collisions (between Strings of four or less characters and Strings of five or more 
characters, for example) than the 

hla.rtil5l6. Obj ect InstanceHandle. hashcode (). No collisions at all are 

expected for handles which are 32-bit or less wide, as long as the comparisons are 
between same-class objects. An eventual RTI using 64-bit wide handles could allow 
hashcode collisions to occur, but even then this seems extremely unlikely. For our 
purposes, objectlnstanceHandle.hashcode () was deemed sufficient. 

One notes that the Management Object Model (MOM) specifies the 
HLAf ederat eHandle datatype as being a 32-bit integer. However, as the 
specification states, “this is a pointer to an RTI-defined programming language 
object, not an integer 32.” The datatype indeed represents a Java reference to a 
FederateHandle interface, and is used (within the MOM) only for the Federate 
dimension. In other words, the instance attributes 

HLAmanager . HLAf ederate . HLAf ederat eHandle are HLAhandles, and each of 
those contains a FederateHandle reference, passed to 

RTI ambassador .normalizeFederateHandle as the MOM HLAf ederat eHandle 

datatype. 

The chat room slot attribute, finally, indicates in which chat room the 
Participant “is.” 

Role of the ChatRoom Objects 

The ChatRoom objects represent the chat groups which are dynamically formed and 
dissolved as the federation executes. A logged-in user’s Participant token is “in” 
precisely one chat room at all times. Each ChatRoom occupies a slot in the 
chatRoomSlots dimension, and this serves to channel communications using DDM. 
Ownership of ChatRoom objects is not as critical as with Participant objects, and it 
is expected that it will pass around. The federation ensures that ownership of a 
ChatRoom object (other than the Waiting Room) remains with one of the 
Participants in it. A ChatRoom that would become “empty” is deleted (except for 
the Waiting Room). 


72 


DRDC Valcartier TR 2007-412 



There are three special chat rooms. The “Nowhere” room is never instantiated; it is 
a reserved chat room slot that can be published into but to which no federate ever 
subscribes. It serves as a publication safety net, to prevent object attributes from 
reverting to the default region. The “Waiting Room” is instantiated only once, using 
the Name Reservation service, and is as a result never deleted, even if empty. It 
serves as a storage area for inactive (“logged out”) Participant objects. The 
“General” chat room, finally, is the default room one joins when first logging in. 
Like normal chat rooms, it may be created and destroyed repeatedly. 

As with Participant objects, we need to ensure the uniqueness of ChatRoom object 
names. However, since they will possibly be created and destroyed repeatedly over 
the duration of the federation, HLA’s Name Reservation service cannot be used. 
Thus a ChatRoom’s name is not its HLA object instance name, but rather an 
attribute. Secondly, we need a mechanism to allocate chat room slots without 
causing any collisions. This is the role of the ChatRoomRegistry object. 

Role of the ChatRoomRegistry Object 

This unique object stores the list of current name-slot attributions in its single 
attribute. By subscribing to the single ChatRoomRegistry object instance, each 
federate keeps its local copy of the list up to date. It is an easy matter to scan the list 
for any given ChatRoom name to see if it already exists, or to scan the list for the 
first free slot value. Since only the owner of the list attribute can modify it, there is 
no risk of several federates attempting to create or delete a ChatRoom object 
instance simultaneously. 

Ownership of the ChatRoomRegistry is used as a means of synchronization between 
the federates—a sort of baton or token. For example, before a federate can decide 
whether it needs to create a ChatRoom or not, it will obtain ownership of the 
ChatRoomRegistry, thus ensuring that there won’t be any changes to the list 
concurrent with its own consultation of the list. In that sense, ownership of an HLA 
object is similar (at the federation level) to the procurement of a monitor lock on a 
Java object (at the federate thread level). 

The drawback of this approach is that it creates a bottleneck (the ChatRoomRegistry 
being passed around), but this is an unavoidable consequence of the need for 
synchronisation. It would have been much worse to introduce a server-like special 
federate, whose only purpose would be to maintain this list and respond to creation 
and deletion requests, because this introduces a single point of failure and forces 
network traffic into a hub-and-spoke pattern. 

The ChatRoomRegistry’s list attribute may seem superfluous. Since all ChatRooms 
are known by all federates at all times (by design), each federate is fully capable of 
maintaining a list of name-slot pairs from those subscriptions alone. This may be 
true. 


DRDC Valcartier TR 2007-412 


73 



On the one hand, this approach would certainly lighten the traffic load somewhat, 
since there would not be any need to broadcast the entire ChatRoomRegistry list 
attribute every time it is modified. Note that this is equivalent to breaking up the 
ChatRoomRegistry object (with its single chatRoomRegistryEntries list 
attribute) into a series of ChatRoomRegistryEntry objects (each containing a single 
ChatRoomRegistryEntry attribute). 

On the other hand, this approach would not improve the federation’s resistance to 
failure (due to RTI events arriving out of sequence). When you obtain an update of 
the ChatRoomRegistryEntries attribute, you can rely on its value to ascertain 
whether a certain chat room slot is present or not, whereas if you rely on the set of 
subscribed ChatRoomRegistryEntry objects, you can never affirm a slot’s 
absence, as its discovery may very well be pending. 

One possible alternate mechanism for achieving this kind of certainty is the 
federation synchronization service group. A federate would announce its intent to 
create a chat room at a given slot value by constructing a unique synchronization 
label from that slot value and attempting to register it. If the registration succeeds, 
the slot is deemed “reserved” and the federate can proceed with the chat room 
creation process. When the chat room object is eventually deleted, the deleting 
federate would assert that synchronization has been achieved (for the 
synchronization point label corresponding to the slot), and so would the other 
federates upon receiving the Remove Object Instance callback. In this way the 
synchronization label would exist as long as the chat room slot is occupied. 

Publication and Subscription 

We are relying extensively on DDM to achieve the filtering expected of our chat 
application. Here is how it plays out. 

The Communication interaction is sent through either a chat room slot region (one’s 
current chat room) or a user handle slot region (the targeted user). It is subscribed 
through those same regions and through the Waiting Room. This latter subscription 
serves a single purpose: tripping the interaction scope advisories in order to ascertain 
whether the federate is “alone” or not. Set up this way, a joined federate will receive 
a turninteractionsOn when at least one other federate is joined, and will receive 
a turninteractionsof f when all other federates have resigned. The federate 
needs to know this when it resigns, in order to decide whether to negotiate the 
ownership divestiture of objects in its custody, or to destroy the federation behind it. 
We could also have achieved this by subscribing to the federation’s MOM 
HLAf ederate objects, but this way is simpler. 

The ChatRoomRegistry’s attributes are published and subscribed through the default 
region. 

The ChatRooms’ attributes are also published and subscribed through the default 
region. 


74 


DRDC Valcartier TR 2007-412 



The Participants’ attributes are published through two regions. The first is the 
“Nowhere” chat room slot. This serves only to ensure that a Participant’s 
publication regions never revert to the default area. The second is the Participant’s 
current chat room slot. When a Participant instance moves between chat room slots, 
the [un] associateRegionsForUpdates service is used to remove it from the old 
slot and then to add it to the new slot. If the Participant were not also associated 
with the “Nowhere” slot, it would revert to the default region between its withdrawal 
and its return. Subscription is through the “Waiting Room” (at all times) and the 
user’s current ChatRoom slot. 

Figure 29 shows how Participant objects are distributed in the ChatRoomSlots 
dimension. Shown in red are those Participant objects which are currently logged- 
in; each one is owned by the corresponding logged-in federate. Each federate may 
also own (have custody of) none, one or more of the logged-out Participants, shown 
in black. Note that logged-out Participants all lie in the Waiting Room slot, and 
logged-in Participants all lie perforce elsewhere. By subscribing to the chat room 
slot a federate is currently “in”, it knows of the other federates sharing the chat 
room. By subscribing to the Waiting Room slot, it is readily capable of accepting 
custody of those Participants should the need arise. 


DRDC Valcartier TR 2007-412 


75 



I Nowhere 



76 


DRDC Valcartier TR 2007-412 


















Assertions 


Each active federate: 

• represents a “logged-in” user; 

• is “in” one ChatRoom at all times (the General chat room or any one of the user- 
created chat rooms); 

• knows all ChatRoom object instances (the Nowhere room is virtual); 

• knows the unique ChatRoomRegistry object instance; 

• owns the Participant object instance that bears its user name (and will not 
relinquish it while logged in); 

• knows the Participant object instances that are “in” the same ChatRoom; 

• knows the Participant object instances that are dormant (“logged-out”); 

• listens to the Communication interaction through a DDM channel corresponding 
to its user handle slot; 

• listens to the Communication interaction through a DDM channel corresponding 
to its chat room slot; and 

• listens to the Communication interaction advisories through a DDM channel 
corresponding to the Waiting Room slot. 

Each Participant object: 

• represents a unique (by user name and user slot) federate; 

• if “logged-out”, is “in” the Waiting Room and owned by some federate; 

• if “logged-in”, is “in” a chat room other than the Waiting Room (e.g. the 
General chat room or any one of the user-created chat rooms); 

• is published through a DDM channel corresponding to its user handle slot; 

• is published through a DDM channel corresponding to its chat room slot; and 

• is published through a DDM channel corresponding to the Nowhere slot. 

When a Participant switches chat rooms, it is simply unassociated from its old chat 
room slot (so that it is now published only through the Nowhere slot) and then 
associated with its new chat room slot. When a Participant logs out, it 
simultaneously switches to the Waiting Room slot. When it logs in, it is either 
created in the General chat room or switched from the Waiting Room to the General 
chat room. 


DRDC Valcartier TR 2007-412 


77 



Each ChatRoom object: 


• represents a unique (by name and slot) chat room; 

• is created when a Participant moves “in”; and 

• is deleted when the last Participant moves “out.” 

Each Communication interaction occurrence: 

• represents a message being sent across the chat network; 

• if public, is sent through a DDM channel corresponding to the sender’s current 
chat room slot; and 

• if private, is sent through a DDM channel corresponding to the target’s user 
handle slot. 


Federate Life Cycle 

Federates are created and initialised in the not-joined state, obviously. They join the 
federation with the sole intent of logging in. Having joined, their first step is to 
obtain the values of the various static FOM handles (interaction and object class 
handles, parameter and attribute handles, dimension handles). 

Generally, a federate’s ownership, subscription and publication interests are 
dynamic and thus a variety of objects are created just before being consumed by an 
rti ambassador service invocation. For example, the Subscribe Object Class 
Attributes With Regions service consumes an attribute-set region-set pair list, so the 
federate must generate attribute handle sets and region handle sets. Each region 
included in the latter forces the federate to generate a dimension handle set, to set the 
range bounds over each dimension and to commit the region modifications. 

Although straightforward, these preparations can nevertheless be lengthy. 

In our case, the ownership, subscription and publication policies are static, so we 
generate as many of these objects as possible during initialization: attribute handle 
sets, dimension handle sets, as well as some of the region handle sets, regions and 
attribute-set region-set pair lists (i.e. those dealing with the three reserved chat room 
slots). 


The Login Process 

The preliminaries consist in publishing and subscribing to the federation’s four 
classes. First, the federate publishes the Communication interaction class and 
subscribes to it through the waiting room slot. 


78 


DRDC Valcartier TR 2007-412 



Next, the federate publishes the ChatRoomRegistry class and then attempts to 
reserve the ChatRoomRegistry’s name through the Name Reservation service. If the 
reservation succeeds, the ChatRoomRegistry did not exist and it is the responsibility 
of this federate to create it. If it fails, the federate simply waits for the object 
discovery to occur. 

The federate repeats the reservation/creation/discovery process for the waiting room. 
These two objects are the only “fixtures” of the federation. 

The federate concludes the login preliminaries by publishing the Participant class 
and subscribing to Participants in the waiting room. 

The login proper then begins. The federate attempts to reserve the chosen username 
through the Name Reservation service. If the reservation succeeds, the username is 
new to the federation, so the federate can create the corresponding Participant object 
and log itself into the general chat room. If it fails, the username already has a 
corresponding Participant object floating about, which may be logged-in or not. 

If logged-out, that Participant will be in the waiting room and will thus be 
discovered; once discovered, the federate can acquire it (if it does not already own 
it) and proceed to log it into the general chat room. The login process is then 
complete. 

If logged-in, the Participant will be in the general chat room or some other chat 
room; even if known the acquisition attempt will fail. At this point the login process 
is a failure and the federate resigns from the federation. 

Although the login process is relatively quick, it does nevertheless take a finite time. 
The federation runs the risk of putting itself in a pathological state if it had only one 
joined federate left and it logs out simultaneously with the log in of another. As 
stated above, the first step of the login process is the publication of the 
Communication interaction, which triggers an interaction scope advisory at the 
logging-out federate. The logging-out federate may then tender ownership of its 
objects (the ChatRoomRegistry, the waiting room ChatRoom and others) to the 
logging-in federate before the latter has had time to publish the relevant classes, 
discover the objects and receive their values. Conversely, the logging-out federate 
could destroy its owned objects before it receives the advisory, and the logging-in 
federate will then be unable to recreate the federation’s standard objects. 

Another possible problem is a race for the same pre-existing (logged-out) 

Participant: if two users attempt to log in at about the same time, the slower one may 
see the desired object go out of scope (be acquired by the faster federate) after it has 
already committed itself (after checking for a number of pre-conditions) to wait for 
the acquisition. Conversely, duplicate ChatRooms (except for the waiting room, 
which is named) are possible if federates are racing to create them (e.g. both pass the 
non-existence check points and commit themselves to creating the chat rooms). See 
the MyChat. registerParticipant () code in Annex E for details. 


DRDC Valcartier TR 2007-412 


79 



Skilful use of a federation synchronization point could prevent these kinds of race 
conditions. The very first action a logging-in federate would take would be to 
register a synchronization point named something like “Login in progress”; other 
federates would achieve the point immediately, while logging-out federates would 
await the Federation Synchronized callback before proceeding. A similar “Logout 
in progress” synchronization point would also be used. These precautions were not 
taken with this work for expediency’s sake. 

The Logout Process 

As soon as it starts the logout process, the federate sets an internal flag that will have 
it decline offers of ownership; as discussed in the login process, this could be a 
problem if all remaining joined federates try to log out simultaneously. 

First, the federate proceeds as if switching chat rooms (see below), from the current 
one to the “waiting room”, except that no subscription to the Communication 
interaction through the latter occurs. While “nowhere”, the federate’s Participant 
avatar has its logged in attribute changed in addition to chat room slot. 

The federate unsubscribes from any remaining subscriptions and then, if the 
interaction scope advisories indicate that there are other joined federates, it 
negotiates the divestiture of any owned objects to those federates (in order to prevent 
the potential orphaning of any instances), including, of course, its Participant avatar. 
Once that is done, any remaining publications can be shut down, and the federate 
can now resign freely from the federation. The last federate to resign from the 
federation deletes all objects from the federation and then destroys the federation. 

The Chat Room Switching Process 

When a user switches chat rooms, the first sub-task is to find out if the new chat 
room already exists or not. If not, it needs to be created, a fairly simple matter of 
creating the ChatRoom object and registering it with the federation. 

The federate now withdraws its Participant avatar from the current chat room slot, 
which leaves it published solely through the nowhere room. This means it goes out 
of scope for all other joined federates. Concurrenty, the federate’s subscription to 
the Communication interaction through the old chat room slot is shut down. 

If the chat room left behind becomes empty, it must be deleted. This sub-task entails 
obtaining ownership of the ChatRoomRegistry in order to update its list of extant 
chat rooms. 

To decide if the chat room is now empty, we count the number of Participant objects 
(out of the known set) that are in it (according to their chatroomslot attributes). 
Once that count is secured, the federate can unsubscribe the Participant class from 
the current chat room (this causes any co-Participants to go out of scope, so attribute 
updates are no longer received for those). 


80 


DRDC Valcartier TR 2007-412 



A race condition exists at this point: it is possible another federate may join the chat 
room after it has been determined to be empty but before the actual deletion occurs. 
The solution would be to modify the FOM to add a count attribute to the 
ChatRoom object, which would reflect its occupancy on a continuous basis. A little 
extra overhead would be incurred as ownership of that attribute gets passed around 
(whenever a federate joins or leaves the chat room). 

The potential deletion process would then be as follows. First, check the chat 
room’s count; if greater than 1, no deletion is required and we are done. Otherwise, 
we must acquire the ChatRoomRegistry (since we intend to strike the chat room 
from its list). Once that is done, check the count again, just in case it has 
changed in the meantime. If deletion is still indicated, obtain ownership of the 
ChatRoom and check the count one last time. If still holding at 1, we can delete it 
(there is no point in updating the count to zero and deleting the object immediately 
afterwards). Other federates wanting to join the chat room will try to acquire it, so if 
we receive an ownership release request we will simply ignore it and forge ahead 
with deletion. This will cause the evocation of RemoveObjectlnstance at the other 
federates, which will tell them “back to square one, the requested ChatRoom doesn’t 
exist any more.” 

Once the old chat room has been deleted or simply left behind, the federate’s 
Participant avatar has its chat room slot set locally to the new chat room, and 
then it is re-associated (published) through the new chat room slot, the 
Communication interaction is subscribed through the new chat room slot, and the 
Participant class is subscribed through the new chat room slot (this reveals the co- 
Participants in the new chat room, if any). The AutoProvide switch means an 
attribute value update request occurs immediately after the Participant is discovered 
by or goes back into scope for other joined federates (i.e. those whose Participants 
already are in the new chat room). 

Ownership Transfer Processes 

As the federation evolves, it is expected that the ownership of most objects will be 
transferred repeatedly between the joined federates. The ChatRoomRegistry is 
passed around whenever a chat room needs to be added or deleted. ChatRoom 
objects are transferred so that they are always owned by one of the federates “in” 
that room. Logged-in Participants are each owned by the federate they represent, 
while logged-out Participants are divested by resigning federates (there are no 
particular criteria for ownership besides simply being joined). 


DRDC Valcartier TR 2007-412 


81 



The process of ownership is straightforward. Each federate receiving a request for 
ownership assumption checks if it is in the “normal” state (i.e. not in the process of 
logging out) and that the class is currently subscribed to (because a federate’s local 
copy of an unsubscribed object is probably outdated as far as the object’s attribute 
values go). Once these formalities are out of the way, the key step is establishing the 
to-be-acquired object’s publication regions before requesting tentative ownership 
(using the Attribute Ownership Acquisition If Available service). This ensures 
continuity of an object’s publication regions. Note that this is applicable only to 
Participant objects, since all other objects are published through the default region. 

When prompted to acquire a ChatRoom object, it is the federate’s responsibility to 
check if it is fully eligible (i.e. is the chat room being offered either the waiting room 
or the client’s current chat room?), as the RTI offers ownership to all joined 
federates that know of the object and that publish its class—a broader criterion. 


82 


DRDC Valcartier TR 2007-412 



5. Conclusions 


The IEEE 1516 series of standards offers great promise, and is a great improvement 
over the preceding 1.3 standard. Designing a flexible middleware standard that 
could accommodate vastly differing simulation contexts without presuming on the 
underlying semantics was a daunting task, and the IEEE must be congratulated on 
succeeding at it. 

The use of state diagrams is crucial in understanding how each federate and the RTI 
are expected to work together. They help tremendously in coming to grips with the 
subtle implications of seemingly innocuous concepts such as “ownership transfer.” 

Few blind spots remain with IEEE 1516, and these should be easily remedied by the 
active IEEE/SISO involvement in evolving the standard. The most obvious one is 
the need for RTI-supplied standard encoding and decoding facilities for value 
transport. It is surprising that this need was not recognised (or explained away) in 
the published standard. 

The IRC example application turned out to have rich implications with respect to 
DDM, potential race conditions, and simultaneous actions (imagine all logged-in 
users logging out “at once”); being time-less exacerbated some of these. A new 
appreciation of the federation synchronization services emerges from this. 

JACK’S built-in thread management turned out to avoid a slew of potential 
problems. The Java interface proved very easily adaptable, once the appropriate 
design decisions were identified. 


DRDC Valcartier TR 2007-412 


83 




This page intentionally left blank. 


84 


DRDC Valcartier TR 2007-412 



Annex A - Notes on the IEEE 1516-2000 Series of 
Standards 


This annex comments on the IEEE 1516-2000 Series of Standards in the same 
manner as the U.S. Department of Defense (DoD) Interpretations of the IEEE 1516- 
2000 series of standards: Release 2 [39]. 


IEEE 1516-2000 Series 

Multiple Federation Executions 

The subject of a single federate application running multiple federates, possibly 
spread over several distinct federate executions, is touched upon only in an indirect 
way in the 1516 specification. Recall that the RTI can handle several federation 
executions running at once, and that each federation execution may have any 
number of joined federates. Each of these is an emanation of a federation 
application but, although each joined federate is logically distinct, nothing prevents 
several of them from being emanations of a single federation application instance. 
This is somewhat analogous to a single instance of a word processing application 
handling multiple documents at once, each document containing embedded objects 
that call upon a single third party service (e.g. multimedia clips). 

The key reference is the brief mention, in 1516.1-2000, 1.4.3 General 
nomenclature and conventions, that “For all joined federate-initiated services in 
this specification, except Create/Destroy/Join Federation Execution, an implied 
supplied argument is a joined federate’s connection to a federation execution. For 
all RTI-initiated services, an implied supplied argument is also a joined federate’s 
connection to a federation execution.” 

In practice, the behaviour implemented by the existing RTIs is the following. The 
RTI ambassador interface obtained from the RTI represents implicitly the federate’s 
connection to a federation execution, in the sense that once the federate has joined a 
federation execution, that particular RTIambassador is committed and will throw a 

FederateAlreadyExecutionMember exception if a new Join is attempted, 
regardless of the specified federation execution, federate type or 

FederateAmbassador instance. 


DRDC Valcartier TR 2007-412 


85 




Nothing prevents the federate from obtaining a distinct RTiambassador interface 
and using that to Join the same (or another) federation execution as a logically 
different federate. Although the specification does permit the same 
FederateAmbassador instance to be used for both Joins, it is extremely unlikely 
that this will be done intentionally, as the FederateAmbassador instance will be 
hard pressed to know which federation execution is invoking its callbacks, or, in the 
case where the FederateAmbassador instance is used by two federates of the same 
federation execution, which of the two federates the RTI is sending messages to (and 
therefore which RTiambassador instance the federate application should use in 
replying). 

Unless the FederateAmbassador is carefully designed with this mode of operation 
in mind (setting up thread variables to distinguish between the federate service 
thread contexts seems required as a start), utter chaos and eventual failure of the 
federate application is certain to ensue. 


Simple Inheritance 

A feature common in object-oriented languages is the ability to hide, override or 
overload an inherited member of a class. In the HLA “objects are defined entirely 
by their identifying characteristics (attributes) [...] These are, in OO parlance, data 
members of the class” (1516 1. Overview). Java calls data members fields and, 
consequently, the only pertinent mechanism is hiding , wherein one redeclares an 
inherited field, possibly giving it a different data type. This is not legal in HLA. 

Although one can reasonably derive this result from the definitions for the 
“available/inherited attributes/parameters” (3.1.5; 3.1.7; 3.1.39; 3.1.40) as well as 
the additional statements 1516.1 1.4.3 (“The handle for a class attribute that is 
inherited shall be the same as the handle that is assigned to the class attribute in the 
object class in which it is declared”) and 1516.2 4.2.1 (“Subclasses shall always 
inherit the attributes of their superclasses, and they may possess additional 
attributes to provide the desired specialization”), the clincher is 1516.2 4.4.2: “The 
names assigned to attributes of any particular object class shall not duplicate 
(overload) the names of attributes of this class or any higher level superclass”). 

It would nevertheless have been useful to mention this more explicitly and earlier. 

To give but one example of the confusion possible over this point, the Pitch Visual 
OMT 1516 application, used to create and edit Federation Object Model (FOM) 
Document Data (FDD) files, allows one to hide inherited fields and nevertheless 
declares the file as valid when using its Check Consistency tool. It is only when one 
tries to createFederationExecution using the resulting FDD that one gets an 
ErrorReadingFDD exception. 


86 


DRDC Valcartier TR 2007-412 



Therefore, change the third paragraph of 1516 (Framework and Rules) 1.3 
Relationship of HLA and object-oriented concepts to: 

As discussed above, HLA object classes are described by the attributes that are 
defined for them. These are, in OO parlance, data members of the class. These 
attributes, which are abstract properties of HLA object classes, are referred to as 
class attributes. Another important difference between HLA and OOAD concepts is 
that an inherited class attribute cannot be hidden; that is to say, a class attribute 
defined at a given class is inherited by its subclasses and may not be redeclared. 
HLA object instances are spawned via an HLA service using an HLA object class as 
a template. Each attribute contained by an HLA object instance is called an 
instance attribute. 

Declaring Dimensions 

Clause 4.6 of 1516.2 (Object Model Template Specification) describes how one sets 
up dimensions within the OMT. Interestingly, although dimension upper bounds are 
described in terms of “non-negative integers”, the XML specification expects a 
string and the range of legal strings is not defined. As a result, the Pitch pRTI 1516 
implementation is unable to read correctly an HLAinteger32BE or 
HLAinteger64BE dimension because it attempts to translate the string into a Java 
int, whose maximum value is 2 31 -1 (=2 147 483 647). Since the upper bound is 
excluded, a full 32-bit dimension would have a range of [0, 2147483648) and pRTI 
1516 throws an ErrorReadingFDD exception with the message “invalid 
dimension upper bound.” Even if pRTI1516 correctly handled the upper bounds 
as Java longs, which is what the API specifies for its GetDimensionUpperBound 
service, there would be a problem with the largest possible upper bound, which 
would be 2 63 (whereas the Java long type's upper bound is 2 63 -l). 

Note also that a floating-point dimension is legal, although the upper bound of the 
RTI view of such a dimension is still specified as a non-negative integer. 
Considerable quantization will occur if linearly normalizing such floating-point 
values over spans approaching the full domain. It should be noted, however, that 
when the bit-widths are the same, the lack of precision inherent in the floating-point 
representation itself (at large magnitudes) is much worse than that imposed by the 
quantization. 


DRDC Valcartier TR 2007-412 


87 



Encoding/Decoding Values 


When sending an interaction or an attribute instance update, the values are expected 
to be encoded into opaque byte arrays; likewise, a received interaction or attribute 
instance reflection supplies values as opaque byte arrays. If the values are of certain 
types, the RTI supplies the encode and decode methods necessary for the 
translation. Unfortunately, the standard only specifies eleven datatypes: 
AttributeHandle, DimensionHandle, FederateHandle, 
InteractionClassHandle, LogicalTime, LogicalTimelnterval, 

ObjectClassHandle, ObjectlnstanceHandle, OrderType, ParameterHandle 
and TransportationType. Clearly, any federates that partake of a given FOM 
must also share the relevant encode/decode methods. Even then, it is not clear 
which encode/decode methods should be used when subscribing to MOM objects 
and interactions. 

Clause 4.12.3 of 1516.2 (Object Model Template Specification) describes, in table 
23, the basic data representation formats (HLAintegeriSBE, HLAinteger32BE, 
HLAinteger64BE, HLAfloat32BE, HLAfloat64BE, HLAoctetPairBE, 
HLAintegerlSLE, HLAinteger32LE, HLAinteger64LE, HLAfloat32LE, 

HLAfloat64LE, HLAoctetPairLE, HLAoctet). The following clauses describe the 
remaining datatypes: simple (HLAASCllchar, HLAunicodeChar, HLAbyte), 
enumerated (HLAboolean), fixed array (none mandated), variable array 
(HLAASCII string, HLAunicodestring, HLAopaqueData), fixed record (none 
mandated) and variant record (none mandated). Note that a user-defined datatype 
could be an arbitrarily complex construct (e.g. a variable array of variant records). 
The byte array representations are specified in detail later on, at clause 4.12.9. 
However, no encode/decode methods are supplied, opening the door to inefficient 
or erroneous implementations. 

Note also that 1516.1 11.6 (MOM OMT Tables) defines a number of additional 
datatypes that would need to be supported if one were to make full use of the MOM: 

• Simple: HLAcount, HLAfederateHandle, HLAmsec, and HLAseconds 

• Enumerated: HLAfederateState, HLAorderType, HLAownership, 
HLAresignAction, HLAserviceGroupName, HLAswitch, 

HLAsyncPointStatus , and HLAtimeState 

• Variable Array: HLAargumentList, HLAhandle, HLAhandleList, 
HLAinteractionCounts, HLAinteractionSubList, HLAlogicalTime, 

HLAobj ectClassBasedCounts, HLAsyncPointFederateList, 
HLAsyncPointList , HLAtimelnterval , and HLAtransportationName 

• Fixed Record: HLAinteractionCount, HLAinteractionSubscription, 
HLAobj ectClassBasedCount , and HLAsyncPointFederate 


88 


DRDC Valcartier TR 2007-412 



The RTI Ambassador ought to supply factories for each and every one of the OMT- 
described datatypes, so that a common set of encode/decode methods may be used 
throughout the federation. This could be done through a single RTiambassador 
support service along the lines of DataTypelnterface 

GetDatatypelnstance(String DatatypeName) , where DataTypelnterface 
would include methods such as get Intvalue (), setlntvalue (int value), 
encode(byte[] [, offset] ), decode(byte[] [, offset] ), getName(), 

getDatatypeType () (simple, enumerated, HLAf ixedArray, HLAvariableArray, 
HLAf ixedRecord, HLAvariantRecord) and so on. Each federate could then obtain 
an encoding/decoding interface from the RTI for any arbitrary datatype declared in 
the FDD, and be assured that any values transmitted as part of an interaction or 
attribute value update will be correctly interpreted by the other federates. Until such 
an extension to the IEEE 1516 specification appears, one is forced to implement 
separately the encoding scheme as laid out in 1516.2 4.12.9 (Predefined encodings 
for constructed datatypes). 

We believe one of the SISO HLA Product Development Groups (PDGs) is working 
on precisely this problem (SISO has recently become the custodian of HLA at 
IEEE’s behest). 


Names 

The only part of the standard that defines what is an allowable name is 1516.2 
(Object Model Template Specification), at clause 3.3.1. Even then, the clause omits 
to state whether the definition applies to object instance names, presumably because 
these are the only designators not appearing in the FOM Document Data (FDD). 

The HlegalName exception thrown by the reserveobj ectlnstanceName service 
is laconically described as occurring when “the name argument begins with “HLA”.” 
This is obviously incomplete. Assuming that the 1516.2 rules apply, add to clause 
3.1 (Definitions) the following (renumbering subsequent definitions accordingly): 

3.1.52 name: A human-readable hopefully significant character string used to 
designate an object or interaction class, an attribute, a parameter, a datatype 
(including enumerators and enumerated values), a record field, a dimension, a 
transportation or ordering type, a synchronization point or federation save label, a 
federation execution, a federate type, or an object instance. There are two forms of 
names: simple names and qualified names. A qualified name consists of a name, a 
(period [Unicode $002E]), and a simple name. They are used to designate object 
and interaction classes by tracing their ancestry from their respective root classes. 
Simple names are constructed from a combination of letters (Latin letters “A” 
through “Z” [Unicode $0041 through $005A] and “a” through “z” [Unicode $0061 
through $007A]), digits (“0” through “9” [Unicode $0030 through $0039]), hyphens 
[Unicode $002D], and underscores [Unicode $005F], A simple name cannot begin 
with a digit or hyphen. Case is significant. The name "na" and all names beginning 
with "HLA" (including all case variations in both instances) are reserved. 


DRDC Valcartier TR 2007-412 


89 



Examples: 

HLAfederate is a simple name (from the MOM) 

HLAobj ectRoot. HLAmanager. HLAf ederate is a qualified name 

hLa - Immunological - Complex is an illegal name ("hla" prefix reserved) 

h-L-a-Immunological-Complex is a legal name 

nA is an illegal name ("na" reserved) 

nA_nanoampere is a legal name 

Note that the definition proposed above is more restrictive than clause 1516.2 3.3.1 
as it allows only the ASCII subset. If one wishes to allow the full XML 1.1 [40] 
gamut, it should be explicitly listed: 

A simple name consists of a NameStartChar followed by zero or more 
NameChar. 

The set of NameStartChars consists of the following Unicode characters: 

- the colon $003A; 

- the upper case Latin letters 'A' through 'Z' inclusive, $0041-$005A; 

- the underscore $005F; 

- the lower case Latin letters 'a' through 'z' inclusive, $0061-$007A; 

- the accented Latin letters up to and including the spacing modifier letters (except 
the multiplication and division signs), $00C0-$00D6, $00D8-$00F6, and 300F8- 
$02FF; 

- the Greek letters (except the Greek question mark), $0370-$037D, $037F-$1 FFF; 
and 

- a wide selection of other characters: $200C-$200D, $2070-3218F, 32C00-32FEF, 
$3001-$D7FF, $F900-$FDCF, $FDF0-$FFFD, and $10000-$EFFFF. 

The set of NameChars consists of the set of NameStartChars plus the following 
supplementary Unicode characters: 

- the hyphen $002D; 

- the digits 'O' through '9' inclusive, $0030-$0039; 

- the mid-dot '■', $00B7; 

- the diacriticals $0300-$036F; and 

- the general punctuation signs undertie '_' and character tie l '~' 1 , 3203F-32040. 

While on the subject of names and labels, it seems odd that various services which 
accept String input (such as createFederationExecution, 

requestFederationSave, etc.) do not throw HlegalName-like exceptions when 
the supplied String violates the name construction rules. The only services (in 
addition to reserveobj ectlnstanceName) that currently do throw such exceptions 
are 10.18 getTransportationType and 10.20 getOrderType. 

To give an example of the pathologies that may arise as a consequence of this 
omission, consider that, as the standard is currently written, an RTI must accept any 
form of save or synchronization label, including ones with embedded control or line 
break characters. If an RTI simply filters these out, then the situation occurs where 
two federation-defined labels considered different by the federation (because control 
characters differ or are placed differently within the label) are treated as congruent 
by the RTI. 


90 


DRDC Valcartier TR 2007-412 



Therefore, add the following exceptions (it may be useful to define all of these new 
exceptions as subclasses of HlegalName): 

// 4.2 

[...] createFederat ionExecut ion [...] 

throws IllegalFederationExecutionName [...] 


II 4.3 

[...] destroyFederat ionExecut ion [...] 

throws I llegalFederat ionExecut ionName [...] 


II 4.4 

[...] j oinFederationExecution [...] 

throws IllegalFederateType, I llegalFederat ionExecut ionName [...] 


[...] registerFederat ionSynchronizationPoint [...] 
throws IllegalLabel [...] 


[...] synchronizationPoint Achieved [...] 
throws IllegalLabel [...] 


II 4.11 

[...] requestFederationSave [...] 
throws IllegalLabel [...] 


II 4.18 

[...] requestFederat ionRe store [...] 
throws IllegalLabel [...] 


[...] reserveObj ectlnstanceName [...] 

throws IllegalObj ectlnstanceName [...] 


[...] registerObj ectlnstance [...] 

throws IllegalObj ectlnstanceName [...] 


[...] registerObj ectInstanceWithRegions [...] 
throws IllegalObj ectlnstanceName [...] 


II 10.2 

[...] getObjectClassHandle [...] 

throws IllegalObj ectClassName [...] 


II 10.4 

[...] getAttributeHandle [...] 

throws IllegalAttributeName [...] 


DRDC Valcartier TR 2007-412 


91 



[...] get Interact ionClassHandle [...] 

throws 11 legal Interact ionClassName [...] 


[...] getParameterHandle [...] 

throws IllegalParameterName [...] 


[...] getObj ectlnstanceHandle [...] 

throws IllegalObjectInstanceName [...] 


// 10.12 

[...] getDimensionHandle [...] 

throws IllegalDimensionName [...] 

// 10.18 

[...] getTransportationType [...] 

throws IllegalDimensionName [...] 


IEEE 1516.1-2000: Federate Interface Specification 

1.4.3 General nomenclature and conventions 

Replace: 

For all joined federate-initiated services in this specification, except 4.2, Create 
Federation Execution, 4.3, Destroy Federation Execution, and 4.4, Join Federation 
Execution, an implied supplied argument that is a joined federate’s connection to a 
federation execution. 

With: 

For all joined federate-initiated services in this specification, except 4.2, Create 
Federation Execution, 4.3, Destroy Federation Execution, and 4.4, Join Federation 
Execution, an implied supplied argument is a joined federate’s connection to a 
federation execution. 

4.4 Join Federation Execution 

The consequences of the “implied supplied arguments” mentioned in 1.4.3 are 
worked out incorrectly in the Join Federation Execution service description as 
currently written. To the first paragraph, add: 

[... ] Until the Resign Federation Execution service is invoked by the federate, the 
RTIambassador interface instance used to invoke this service is considered 
committed to the specified federation execution. Although the 4.1 Create Federation 
Execution and 4.2 Destroy Federation Execution services may still be freely invoked, 
any invocation of this service while committed will fail, regardless of the explicitly 
supplied arguments. 


92 


DRDC Valcartier TR 2007-412 



Change 4.4.3 b) to read: 

b) The federate is not joined to any federation execution. 

Change 4.4.5 a) to read: 

a) The federate is already joined to a federation execution. 

5.2/5.3 [Un]Publish Object Class Attributes 

The Annex B rti ambassador. j ava file introduces a potentially dangerous source 
of confusion when it labels (on five occasions) an AttributeHandleSet argument 
“attributeList”. The Java class j ava .util .List is quite different from the 
j ava .util. Set class. Therefore, replace: 

// 5.2 

public void publishObjectClassAttributes ( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 

[...] 

II 5.3 

public void unpublishObjectClassAttributes ( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 


public void subscribeObjectClassAttributes ( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 

[...] 

public void subscribeObj ectClassAttributesPassively ( 
Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 

// 5.7 

[...] 

public void unsubscribeObjectClassAttributes ( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 


DRDC Valcartier TR 2007-412 


93 



With: 


II 5.2 

public void publishObjectClassAttributes ( 
Obj ectClassHandle theClass, 
AttributeHandleSet theAttributes) 

[...] 

II 5.3 

public void unpublishObjectClassAttributes ( 
Obj ectClassHandle theClass, 
AttributeHandleSet theAttributes) 


public void subscribeObjectClassAttributes ( 

Obj ectClassHandle theClass, 

AttributeHandleSet theAttributes) 

[...] 

public void subscribeObj ectClassAttributesPassively ( 
Obj ectClassHandle theClass, 

AttributeHandleSet theAttributes) 

// 5.7 

[...] 

public void unsubscribeObjectClassAttributes ( 

Obj ectClassHandle theClass, 

AttributeHandleSet theAttributes) 


94 


DRDC Valcartier TR 2007-412 



5 . 615.7 [Un]Subscribe Object Class Attributes 

See 5.2/5.3 [UnjPublish Object Class Attributes, above. 

5.8/5.9 [UnjSubscribe Interaction Class 

The Annex B rti ambassador. j ava file introduces a minor source of confusion 
when it labels (on eight occasions) an interactionClassHandle argument 
“theclass”, a name used everywhere else to designate an obj ectclassHandle. 
Other services use “thelnteraction” for InteractionClassHandle arguments. 
Therefore, replace: 


public void subscribelnteractionClass ( 
InteractionClassHandle theClass) 

[...] 

public void subscribelnteractionClassPassively ( 
InteractionClassHandle theclass) 


public void unsubscribelnteractionClass ( 
InteractionClassHandle theclass) 

[...] 

// 6.14 

public void changelnteractionTransportationType ( 
InteractionClassHandle theClass, 

TransportationType theType) 

[...] 

// 8.24 

public void changelnteractionOrderType ( 
InteractionClassHandle theClass, 

OrderType theType) 


public void subscribelnteractionClassWithRegions ( 
InteractionClassHandle theClass, 

RegionHandleSet regions) 

[...] 

public void subscribelnteractionClassPassivelyWithRegions ( 
InteractionClassHandle theClass, 

RegionHandleSet regions) 

[...] 

// 9.11 

public void unsubscribeInteractionClassWithRegions ( 
InteractionClassHandle theClass, 

RegionHandleSet regions) 


DRDC Valcartier TR 2007-412 


95 



public void subscribelnteractionClass ( 

InteractionClassHandle theInteraction) 

[...] 

public void subscribelnteractionClassPassively ( 
InteractIonClassHandle theInteraction) 


public void unsubscribelnteractionClass ( 

InteractIonClassHandle theInteraction) 

[...] 

// 6.14 

public void changelnteractionTransportationType ( 
InteractionClassHandle theInteraction, 
TransportationType theType) 

[...] 

// 8.24 

public void changelnteractionOrderType ( 

InteractionClassHandle theInteraction, 

OrderType theType) 


public void subscribeInteractionClassWithRegions ( 

InteractionClassHandle theInteraction, 

RegionHandleSet regions) 

[...] 

public void subscribeInteractionClassPassivelyWithRegions ( 
InteractionClassHandle theInteraction, 

RegionHandleSet regions) 

[...] 

// 9.11 

public void unsubscribelnteractionClassWithRegions ( 
InteractionClassHandle theInteraction, 

RegionHandleSet regions) 


6.1 Overview 

To clarify the important distinction between known and owned object instances, 
insert this paragraph after the one on orphan object instances (p. 71): 

However, an object instance can become wholly unowned without becoming an 
orphan. It is important to note that object instances that are known remain known 
even if they become undiscoverable. As long as a joined federate that knows of the 
object instance does not invoke Local Delete Object Instance, it continues to know 
of the object instance and ownership acquisition of some or all of the latter’s 
instance attributes remains possible. 


96 


DRDC Valcartier TR 2007-412 



6.3 Object Instance Name Reserved 


A clarification is needed as to whether deleting an object instance frees up its object 
instance name for re-use. The text of clause 6.3 implies that it does not:"[...] no 
joined federate joined to the current federation execution shall subsequently receive 
a successful reservation for that name". That is certainly the way the Pitch 
pRTI1516 interprets it. Under certain circumstances, this behaviour is undesirable. 
For instance, if a reserved name is used to represent a “username token”, then that 
username cannot be re-used (after a “log-off’, say) for the remainder of the 
federation execution. 

Also, replace the first sentence: 

Notifies the joined federate whether the name provided in a previous invocation of 
Register Object Instance Name service has been reserved, which shall 
mean that the name is federation execution-wide unique. 

With: 

Notifies the joined federate whether the name provided in a previous invocation of 
Reserve Object Instance Name service has been reserved, which shall 
mean that the name is federation execution-wide unique. 

6.7 Reflect Attribute Values 

In all forms, it seems odd that the federate is not allowed to throw the 

InvalidOrderType or InvalidTransportationType exceptions. When the 
service conveys a MessageRetractionHandle, the 

invalidMessageRetractionHandle exception should be expected. According to 
the specification, the two forms that convey a LogicalTime and are allowed to 
throw the invalidLogicalTime exception should do so only if the received 
ordering is TIMESTAMP. 

These problems are common to the C++ and Java annexes. 


DRDC Valcartier TR 2007-412 


97 



6. 10/6.12 [Local] Delete Object Instance 


The Annex B RTiambassador. j ava file introduces a minor source of confusion 
when it labels (on three occasions) an obj ectinstanceHandle argument 
“obj ectHandle”. The other services all use “theobj ect”. Therefore, replace: 


public void deleteObjectlnstance ( 

Obj ectinstanceHandle obj ectHandle, 
byte[] userSuppliedTag) 

[...] 

public MessageRetractionReturn deleteObj ectlnstance ( 
Obj ectinstanceHandle obj ectHandle, 
byte[] userSuppliedTag, 

LogicalTime theTime) 

[...] 

// 6.12 

public void localDeleteObjectlnstance ( 

Obj ectinstanceHandle obj ectHandle) 


With: 


public void deleteObjectlnstance ( 

Obj ectinstanceHandle theObj ect, 
byte[] userSuppliedTag) 

[...] 

public MessageRetractionReturn deleteObj ectlnstance ( 
Obj ectinstanceHandle theObj ect, 
byte[] userSuppliedTag, 

LogicalTime theTime) 

[...] 

// 6.12 

public void localDeleteObjectlnstance ( 

Obj ectinstanceHandle theObj ect) 


98 


DRDC Valcartier TR 2007-412 



6.14/8.24 Change Interaction Transportation/Order Type 

See 5.8/5.9 [UnJSubscribe Interaction Class, above. 

7.3 Negotiated Attribute Ownership Divestiture 

The description is incomplete. As the DoD Interpretations clearly indicate, the 
Unconditional Attribute Ownership Divestiture service is a fifth, legal way to 
“divest ownership by other means.” The second paragraph is thus replaced by 1 : 

A request to divest ownership shall remain pending until the request is completed 
(via the Request Divestiture Confirmation f and Confirm Divestiture services), or the 
requesting joined federate successfully cancels the request (via the Cancel 
Negotiated Attribute Ownership Divestiture service), or the joined federate divests 
itself of ownership by other means (i.e. the Attribute Ownership Divestiture if 
Wanted, Unconditional Attribute Ownership Divestiture or Unpublish Object Class 
Attributes services). A second negotiated divestiture for an instance attribute already 
in the process of a negotiated divestiture shall not be legal. 

9.5 Register Object Instance With Regions 

The Annex B rti ambassador. j ava file introduces a minor source of confusion 
when it labels a string argument “theobj ect”. The Register Object Instance 
service uses, more appropriately, “theobj ectName”. Therefore, replace: 


public Obj ectInstanceHandle registerObj ectInstanceWithRegions ( 
Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions, 

String theObject) 


With: 


public Obj ectInstanceHandle registerObj ectInstanceWithRegions ( 
Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions, 

String theobj ectName) 


1 In the IEEE 1516 documents, the printer’s dagger (t) is used to denote the callbacks; that is to say, 
the federate-implemented, RTI-initiated services. 


DRDC Valcartier TR 2007-412 


99 



9.10/9.11 [Un]Subscribe Interaction Class With Regions 

See 5.8/5.9 [UnJSubscribe Interaction Class, above. 

Logical Time, Time Stamps, and Lookahead 

(pp. 259+) The definitions given for the Java interfaces LogicalTime, 
LogicalTimelnterval, LogicalTimeFactory and 

LogicalTimeintervalFactory suffer from a number of inconsistencies when one 
compares the 12.4.2.23 clause with the (normative) Java API supplied by Annex B. 
There are further inconsistencies when one compares the Java clause and annex with 
the corresponding C++ and Ada 95 clauses and annexes. Specifically: 

Interpretation 1 

According to 12.4.2.23, "Methods [...] are provided [...] to set an instance to the 
initial and final [Logical Time] values. A method to set one instance to the same 
value as another is provided as well". The C++ and Ada 95 clauses (12.5.2.23 and 
12.3.2.24, respectively) describe the same methods and their Annexes (C - 
LogicalTime .h and A, respectively) declare them (e.g. for C++: set initial, 
setFinal and setTo). By contrast, the Java API is missing three methods from its 
LogicalTime interface: 


j * * 

* Sets the value to <code>initialTime</code>. 

*/ 

public void setlnitial(); 

j * * 

* Sets the value to <code>finalTime</code>. 

*/ 

public void setFinal(); 

j * * 

* Sets the value to equal the <code>other</code>'s. 

* @param other A <code>LogicalTime</code> whose value is 

* used to set <code>this</code> 

* @throws InvalidLogicalTime 

*/ 

public void setTo(LogicalTime other) 
throws InvalidLogicalTime; 


100 


DRDC Valcartier TR 2007-412 



Interpretation 2 


The Ada 95 clause (12.3.2.24) is the only one that reads "one instance of a 
Logical_Time may be subtracted from another, but not added. The result is of 
type Logical_Time_Interval". On the other hand, all three annexes define 
the method (e.g. "subtract" for C++ and "distance" in Java). Thus the C++ 
clause (12.5.2.23) should have this sentence added to its third paragraph: 

Finally, a method is provided to obtain the RTI: : LogicalTimelnterval 
separating two instances of RTI: : LogicalTime. 

And the Java clause (12.4.2.23) should have this sentence added to its third 
paragraph: 

Finally, a method is provided to obtain the LogicalTimelnterval separating 
two instances of LogicalTime. 

Interpretation 3 

The LogicalTimeFactory is described as having "[...] a method to create a 
LogicalTime instance whose value is the user-defined initial value". The notion 
of “user” is misleading; replace the sentence (in the Java and C++ clauses) with: 

The LogicalTimeFactory interface has a method to create a LogicalTime 
instance whose value is the federate-developer-defined initial value. 

Interpretation 4 

The aforementioned LogicalTimeFactory method is described in the C++ 
(12.5.2.23) and Java (12.4.2.23) clauses, while the Ada 95 clause (12.3.2.24) is mute 
on the subject, the concept of Factory class being alien to that language. Annex C - 
LogicalTimeFactory.h declares makelnitial as expected. Java’s Annex B, 
however, declares two Factory methods, makelnitial and makeFinal. Either the 
extraneous Java method should be deleted from the interface, or the specification 
should be enhanced to include the makeFinal method for C++. 


DRDC Valcartier TR 2007-412 


101 



Interpretation 5 


The LogicalTime manipulation methods bear radically different names in each 
API: 


Ada 

+ 


Java 

add 

subtract 

distance 


C+ + 

increaseBy 

decreaseBy 

subtract 


One must question the wisdom of such inconsistencies, since most other method 
names are immediately recognizable between APIs (e.g. set To Epsilon vs. 
setEpsilon vs. setEpsilon). 


Interpretation 6 

The description of LogicalTimeinterval should stress that it is used to represent 
strictly non-negative values : that is to say, it represents the magnitude of a logical 
time interval. This is crucial for the proper implementation of such methods as 

C++’s LogicalTime.increaseBy, LogicalTime.decreaseBy, 

LogicalTime.subtract and LogicalTimeinterval.subtract. The 
LogicalTimeinterval constructor supplied in sub-clause B.3 should be modified 
consequently: 

ExampleLogicalTimelnterval(long value) 

{ 

_value = j ava.lang.Math.abs(value) ; 


102 


DRDC Valcartier TR 2007-412 



Interpretation 7 


The behaviour of LogicalTimelnterval. subtract is undefined when the 
subtrahend is greater than the current object. We can either throw an 
IllegalTimeArithmetic exception or the InvalidLogicalTimelnterval 
exception which the C++ API throws (and which is re-introduced by Interpretation 
11, below): 


j * * 

* Returns a new <code>LogicalTimeInterval</code> whose value is 

* <code>(this - subtrahend)</code>. 

* @param subtrahend The <code>LogicalTimeInterval</code> to 

* subtract from <code>this</code> 

* @throws InvalidLogicalTimelnterval if the 

* <code>subtrahend</code> is larger 

* than the value 
*/ 

public LogicalTimelnterval 
subtract(LogicalTimelnterval subtrahend) 
throws InvalidLogicalTimelnterval 

{ 

if (_value < ((LogicalTimelnterval)subtrahend)._value) 
throw new InvalidLogicalTimelnterval() 
else 

return new LogicalTimelnterval( 

_value - ((LogicalTimelnterval)subtrahend)._value); 


Interpretation 8 

In both the Java and Ada clauses, LogicalTimelnterval has "methods to set a 
LogicalTimelnterval instance to zero or epsilon and to test an instance to 
determine if it is zero or epsilon". Erroneously, the C++ clause omits the epsilon- 
related methods, while the annex omits just the setEpsilon method: 

virtual 

void 

setEpsilonO = 0; 


DRDC Valcartier TR 2007-412 


103 



Interpretation 9 


Again on the LogicalTimelnterval "methods to set a 

LogicalTimelnterval instance to zero or epsilon", the Java annex omits these 
methods from the interface: 

j * * 

* Sets the value to <code>zero</code>. 

*/ 

public void setZeroO; 

j * * 

* Sets the value to <code>epsilon</code>. 

*/ 

public void setEpsilon(); 


Interpretation 10 

In all three clauses, the description of the LogicalTimelnterval methods 
establishes the analogy with the LogicalTime methods but does not explicitly 
mention a "method to set a LogicalTimelnterval instance to the same value 
as another". This should be corrected. 

Interpretation 11 

The aforementioned LogicalTimelnterval methods "to set a 
LogicalTimelnterval instance to the same value as another" appear in the 
Ada and C++ annexes but not in the Java annex: 


j * * 

* Sets the value to equal the <code>other</code>'s. 

* @param other A <code>LogicalTimeInterval</code> whose value 

* is used to set <code>this</code> 

* @throws InvalidLogicalTimeInterval 

*/ 

public void setTo(LogicalTimelnterval other) 
throws InvalidLogicalTimeInterval; 

Note that this means invalidLogicalTimelnterval must be added to the existing 
set of RTiexceptions (this exception is already thrown by the C++ API). 


104 


DRDC Valcartier TR 2007-412 



Interpretation 12 


The Java LogicalTimelntervalFactory is simply described as "completely 
analogous to its LogicalTime counterpart". However, the C++ description 
mentions "one more method [...which] returns a constant reference to [epsilon]". 
Annex C - LogicalTimelntervalFactory.h contradicts this by declaring 
epsilon as returning an RTI: :LogicalTimelnterval instance. Clearly the 
analogy with rti : :LogicalTimeFactory would be much more consistent. Thus 
RTI: : LogicalTimelntervalFactory should have two methods, makeZero and 
makeEpsilon. Thus (C++): 

virtual 

RTI::auto_ptr< RTI::LogicalTimeInterval > 
makeEpsilon() = 0; 


Interpretation 13 

In 12.4.2.23 Logical time, time stamps, and lookahead, the last bullet of the list of 
logical time interfaces to be implemented by RTI providers incorrectly begins with: 
"An implementation of LogicalTimelntervalFactory called 
Integer64TimeIntegerFactory". Change the sentence to: "An 
implementation of LogicalTimelntervalFactory called 
In t eger 6 4Ti me Interval Factory". 


Annex B: Java application programmer’s interface 

One of the strengths of the Java language is the Javadoc self-documentation 
convention. Besides being directly consultable, the Javadoc is typically exploited 
directly by most Integrated Development Environments (IDEs), and developers have 
to come to rely on it extensively as a productivity aid. It is therefore regrettable that 
the Annex B API omits most of these, particularly since the API is said to be 
normative. Adding the requisite comment lines is a time-consuming task, but it does 
have the virtue of leaving the compiled byte-code unchanged. 

An API with the Javadoc comments integrated into it is supplied in one of the other 
annexes to this report. 


DRDC Valcartier TR 2007-412 


105 



Annex B: Java application programmer’s interface - 
InvalidFederateHandle 


This exception was introduced with the normalizeFederateHandle Java service. 
One notes, however, that it could also have been added to the list of exceptions 
thrown by the registerFederationSynchronizationPoint service when a 
FederateHandleSet is supplied. Currently, it seems that when an invalid handle is 
part of the supplied FederateHandleSet the RTI invokes 
synchronizationPointRegistrationFailed with the 

synchroni zation_set_member_not_joined reason (ref: DoD Interpretations, 
Release 2, Appendix A, Service 4.6: Register Federation Synchronization Point 
(i Clarification 1)). The rationale behind this decision is probably the impossibility of 
distinguishing between an “invalid federate handle” and the “valid” federate handle 
of a now-unjoined federate. 


Annex B: Java application programmer’s interface - 
MessageRetractionReturn 

The Java MessageRetractionReturn class is similar to the TimeQueryReturn 

class, except that it omits the tostring, equals and hashcode methods. There is 
no good reason to do this. Therefore: 

Interpretation 1 

Add, in the MessageRetractionReturn. j ava file, the lines: 


j * * 

* Returns a <code>String</code> representation of the 
<code>MessageRetractionReturn</code>. 

* @return String with value "&lt;retractionHandlelsValid&gt; 
&lt;handle&gt;" 

*/ 

public String toStringO 

{ 

return retractionHandlelsValid + 11 11 + handle; 


106 


DRDC Valcartier TR 2007-412 



* * 


* Returns true iff <code>this</code> and <code>other</code> represent 
the same message retraction return. 

* @param other The <code>Object</code> to compare with 

* @return true iff supplied <code>other</code> is of type 
<code>MessageRetractionReturn</code> and has same value 

*/ 

public boolean equals (Object other) 

{ 

if (other instanceof MessageRetractionReturn) 

{ 

MessageRetractionReturn mrrOther = 

(MessageRetractionReturn)other; 

if ((retractionHandlelsValid == false) && 

(mrrOther.retractionHandlelsValid == false)) 
return true 

else if ((retractionHandlelsValid == true) && 

(mrrOther.retractionHandlelsValid == true)) 

return handle.equals(mrrOther.handle) 
else 

return false; 

} else 

return false; 


j * * 

* Returns a hash code for <code>this</code>; two 
<code>MessageRetractionReturn</code>s for which <code>equals()</code> 
is <code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int hashCodeO 

{ 

return (retractionHandleValid ? handle.hashCode() : 7); 


Annex B: Java application programmer’s interface - 
Service Groups 

The Java implementation of the ServiceGroup class uses internally the values 4 
through 10 to represent the service groups. These values are accessible through the 
class’s tostring () method which will return, for example, "ServiceGroup (4)" 
for the federation_management service group. On the other hand, the 
Management Object Model (MOM) clearly states (Table 11) that it uses the values 0 
through 6 for the same purpose. The potential for confusion is there. The fix is 
simple: 


Interpretation 1 

Replace, in the ServiceGroup. j ava file, the line: 

private static final int _lowestValue = 4; //fedn mgt is chapter 4 


DRDC Valcartier TR 2007-412 


107 



With: 


//initial value for enumeration: 

//MOM uses 0 for federation management service group 
private static final int _lowestValue = 0; 


D.8.1 [Time Management] Overview 

Interpretation 1 

Replace the last paragraph: 

Additionally, each of the language APIs also provide default concrete 
implementations of these two ADTs based on the float 64-datatype. 

With: 

Additionally, each of the language API Examples subclauses also provides a default 
concrete implementation of these two ADTs based on the integer-64 data type. 


IEEE 1516.2-2000: Object Model Template (OMT) 
Specification 

4.4.2 [Attribute] Table Format 

Replace paragraph 14 (page 30): 

The eighth column (Available dimensions) shall record the association of the class 
attribute with a set of dimensions if a federate or federation is using DDM services 
for this attribute. The column shall contain a comma-separated list of names of rows 
in the dimension table described in 4.6. [...] 

With (emphasis added for readability): 

The eighth column (Available dimensions) shall record the association of the class 
attribute with a set of dimensions if a federate or federation is using DDM services 
for this attribute. The column shall contain a space-separated list of names of rows 
in the dimension table described in 4.6. [...] 

Table 8 (p. 31) is also incorrect in showing a comma in the Food. Dr ink. Soda 
Available dimensions column. The same error also appears on p. 32, 4.5.2 
[Parameter] Table Format, paragraph 5: 

The fourth column (Available dimensions) shall record the association of an 
interaction class with a set of dimensions if the federate or federation is using DDM 
services for this interaction. The column shall contain a comma-separated list of 
names of rows from the dimension table described in 4.6. [...] 


108 


DRDC Valcartier TR 2007-412 



Which becomes (emphasis added for readability): 

The fourth column (Available dimensions) shall record the association of an 
interaction class with a set of dimensions if the federate or federation is using DDM 
services for this interaction. The column shall contain a space-separated list of 
names of rows from the dimension table described in 4.6. [...] 

Annexes D and E indeed use space-separated dimension lists (see pp. 82 

[Food.Drink.Soda object class] and 111 [HLAreportServicelnvocation 

interaction class]). Table 7 of IEEE 1516.1-2000, 11.6 MOM OMT Tables, page 
224 is correct. 

4.6 Dimension Table 

In 1516.1 9.1.4, it was stated that “The normalization of federation data to [0, a 
particular dimension’s upper bound) for use with DDM services shall be left to the 
federation.” This is, besides Table 8 in 11.6 MOM OMT Tables, the only mention of 
normalization in the Federate Interface Specification. Buried here in the fourth 
paragraph is the sentence “The federate shall provide a normalization function for 
each dimension, that maps values from the federate view of a dimension to values in 
the RTI view of a dimension.” This requirement is undecidable, as there is no 
member of the FederateAmbassador interface, nor any part of the hla. rtiisis 
package, that mentions these normalization functions. A federate has no means 
whatsoever of providing the RTI (or any other federate) with the “required” 
normalization functions. 

The only guidance supplied for their implementation is 1516.2’s Annex B, which 
lays out common normalization functions (so the algorithms are known), and the 
RTIambassador’s Normalize Federate Handle and Normalize Service Group services 
(so the general declaration form is known). 

Is a mechanism for sharing normalization functions between federates desirable? 

On the one hand, having each federate’s view of a dimension be a private 
implementation matter is a good thing, allowing each federate to choose the internal 
representation that best suits its purpose and capabilities. On the other hand, if the 
federation semantics are such that federate views are to be shared (they could be 
transmitted as object attribute values or as interaction parameters, for example), then 
a common approach to normalization is highly desirable. Providing a normalization 
function sharing mechanism allows both cases to be handled, whereas the absence of 
such a mechanism (which is the current situation) essentially forces the federation 
semantics into the mould of the first case. 


DRDC Valcartier TR 2007-412 


109 



Normalization sharing is not an obvious extension of the RTiambassador and 
FederateAmbassador interfaces. Should the value(s) to be normalized be passed 
like interaction parameters or object attribute values? Will the HLA rules really 
require that a federate ask itself to normalize a value through the RTI (when it 
happens to be the “normalizer”)? How will federates indicate their normalizing 
responsibility? How will the RTI allow multiple federates to normalize for a given 
dimension handle (in order to allow differing views for different federate types)? 
How can a single method-callback pair encapsulate the various normalization 
schemes possible? 

The RTI-provided normalization services (normalizeFederateHandle and 
normalizeServiceGroup) are problematic examples: they introduce two new 
rti except ion descendents, specific to those two services alone: 
invalidFederateHandle and invalidServiceGroup. This is not an example 
that federates can follow, if only because there is no way to introduce a new 
exception class to an existing interface. 

One also notes that the federate view of a dimension is not necessarily integer like 
the RTI view. The linear normalization, for example, could operate from a floating¬ 
point federate view. This means the normalization API must be able to accept 
integer as well as floating-point domain specifications. It is less obvious whether the 
logarithmic and hyperbolic tangent normalization functions should exist in an 
integer form besides the floating-point one. In all cases, it is reasonable to assume 
that the value to normalize is of the same type as the domain’s upper and lower 
bounds. 

Looking more closely at the RHambassador’s 10.32 Set Range Bounds service, it is 
clear that the normalization functions are to be used in converting the federate’s 
view of the range bounds into values usable by the RangeBounds constructor (RTI 
view values). However, what is the federate to make of the values returned by the 
10.31 Get Range Bounds service? They need to be converted back into the 
federate’s view of the dimension. Hence, unnormalization functions are also 
required. 

Normalization and unnormalization algorithms must be defined in tandem such that, 
as a general rule, normalizing and then unnormalizing a given value leaves it 
unchanged (as long as the dimension and domain remain the same, of course). 

When the RH view has grosser quantization than the federate view (e.g. the federate 
domain is 64-bit integer but the RTI dimension is merely 32-bit integer), or when the 
federate view is floating-point, some degeneracy (binning) of federate view values is 
expected, but no drift should occur—that is to say, the federate value should not 
change on a second normalization-unnormalization round-trip. 


110 


DRDC Valcartier TR 2007-412 



Enumerated datatypes raise a different kind of issue. The API-defined enumerated 
types (OrderType, ResignAction, RestoreFailureReason, 

RestoreStatus, SaveFailureReason, SaveStatus, ServiceGroups, 
SynchronizationPointFailureReason, and TransportationType) as well as 
the OMT-defined enumerated datatypes (HLAfederateState, HLAtimeState, 
HLAownership, HLAresignAction, HLAorderType, HLAswitch, 
HLAsyncPointstatus, HLAserviceGroupName , plus any user-defined types) are 
implemented as classes with prototype static field instances. In the absence of a 
structured hierarchy of datatype interfaces, a generic linear enumerated 
normalization method, using a class reference argument, must use Java’s 
introspection methods to extract the prototype instances, and must also rely on the 
hashcode method for the RTI view values. 


B.1 Linear normalization function 

Since the RTI view is integer, either the result of the equation as written needs to be 
rounded or truncated, or the division operator must be replaced by an integer 
division and the parentheses re-arranged. The floor ( ) operation used here is such 
that it returns the largest integer which is smaller than or equal to its argument. Note 
that the expression is the same whether the domain itself is integer or floating-point. 

Function floor([{domain - domainLower} / {domainUpper - domainLower}] * 
[DUB-1]) 

Or: 

Function [(domain - domainLower) * (DUB -1)] div (domainUpper - 
domainLower) 

Where DUB is, as 1516.2-2000, Annex B, states, “the dimension upper bound 
specified for the dimension in the third column of Table 11.” 

B.1.1 Linear unnormalization function 

To properly invert the normalization function when the domain is integer, we define 
the ceiling ( ) operation such that it returns the smallest integer which is larger 
than or equal to its argument. This expression and the corresponding normalization 
function work correctly when the domain range (domainUpper - domainLower) is 
larger or smaller than the dimension range (DUB - 1), and also whether the domain 
extends over the negative integers or not, in whole or in part. When the domain is 
floating-point, the ceiling () function is omitted; and the number of significant 
digits preserved then depends on the quantization imposed by the RTI view (for 
example, a domain extending from 0.0 through 1.0 would have a maximum 
precision of about 1/2 63 ~ 10' 19 ). 

Form unlinear (normalized, domainLower, domainUpper) 

Parameters normalized: the federation’s view of the domain value 


DRDC Valcartier TR 2007-412 


111 



other parameters as per B.1 


Function domainLower + ceiling([normalized * {domainUpper - domainLower}] / 
{DUB-1}) 


B.2 Linear enumerated normalization function 

Same problem as with B.l: 

Function floor([positionlnMappedSet(domain) / {mappedSetLength -1}] * {DUB - 

1 }) 

Or: 

Function [positionlnMappedSet(domain) * (DUB -1)] div (mappedSetLength -1) 


B.2.1 Linear enumerated unnormalization function 

Here the elementFromMappedSet (n) function returns the zero-based nth element 
of the mapped set: 

Form unlinear (normalized, mappedSet) 

Parameters normalized: the federation’s view of the domain value 
other parameters as per B.2 

Function elementFromMappedSet(ceiling(n*{mappedSetLength -1} / {DUB - 

1 })) 


B.3.1 Enumerated set unnormalization function 

Whereas the normalization function’s rti set is best described by a Java HashMap, 
(which uses mappedSet for its keys), unnormalization won’t be as efficient since the 
implementation will have to iterate over the values in order to retrieve any one key. 

Function unRTIset(normalized) 
where 

unRTIset(normalized) is a function that maps the RTI’s view to 
mappedSet values 


B.4 Logarithmic normalization function 

Same problem as with B.l: 

Function floor([log(domain/domainLower) / log(domainUpper/domainLower) * 
{DUB-1}) 


112 


DRDC Valcartier TR 2007-412 



B.4.1 Logarithmic unnormalization function 

Function ceiling(domainl_ower * exp(log(domainUpper/domainLower) * 
normalized / {DUB -1})) 

B.5 Hyperbolic tangent normalization function 

Same problem as with B.l: 

Function floor([{tanh([domain - domainCenter]/domainSize) + 1}/2] * {DUB -1}) 

B.5.1 Hyperbolic tangent unnormalization function 

Function ceiling(domainCentre + domainSize*arctanh([2*normalized/{DUB - 1}] - 

1 )) 


C.2 HLA OMT DIF DTD declaration 

Interpretation 1 

Replace (fourth paragraph, first bullet): 

In the tabular representation of object models, object class and interaction class 
inheritance are represented by columns in which the parent of a class was 
represented to its left and children to its right. In the XML depiction of object 
models, inheritance is represented by membership, in which where children of a 
parent class are depicted as class elements contained within the parent class 
element. 

With: 

In the tabular representation of object models, object class and interaction class 
inheritance are represented by columns in which the parent of a class was 
represented to its left and children to its right. In the XML depiction of object 
models, inheritance is represented by membership, in which children of a parent 
class are depicted as class elements contained within the parent class element. 


DRDC Valcartier TR 2007-412 


113 



This page intentionally left blank. 


114 


DRDC Valcartier TR 2007-412 



Annex B - HLA 1516 Java API with Javadoc 


The files that make up the Java API are listed in alphabetical order, except for the 
Exceptions which are grouped at the end of the annex. 


// File: AttributeHandle.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

/ * * 

* Type-safe handle for an attribute. Generally these are created by 
the RTI and passed to the federate. 

* <p> 

* <code>AttributeHandle</code>s are obtained from the 

* (10.4) {@link RTIambassadorttgetAttributeHandle getAttributeHandle} 

* method and are used by a variety of other methods. 

* <p> 

* They can also be obtained by using the 
<code>AttributeHandleFactory</code>'s {@link 

AttributeHandleFactory#decode decode} method on a <code>byte[]</code> 

* received as part of an attribute update or interaction. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public interface 
AttributeHandle 

extends java.io.Serializable 

{ 

/* * 

* Returns a <code>String</code> representation of the 
<code>AttributeHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 


/* * 

* Returns true iff <code>this</code> and 
<code>otherAttributeHandle</code> represent the same attribute handle. 

* @param otherAttributeHandle the <code>Object</code> to compare 

with 

* @return <code>true</code> iff supplied 
<code>otherAttributeHandle</code> is of type 
<code>AttributeHandle</code> and has same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherAttributeHandle); 


DRDC Valcartier TR 2007-412 


115 




* * 


* Returns a hash code for <code>this</code>; two 
<code>AttributeHandle</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 

* @see Object#equals(java.lang.Object) 

Obj ect.equals(j ava.lang.Obj ect) 

* @see java.util.Hashtable Hashtable 
*/ 

public int 
hashCode(); 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>AttributeHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset) ; 

} 

//end AttributeHandle 


116 


DRDC Valcartier TR 2007-412 



// File: AttributeHandleFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getAttributeHandleFactory getAttributeHandleFactory} 
method. 

* Its one method creates a new {@link AttributeHandle} from a 
supplied <code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
AttributeHandleFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link AttributeHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of an <code>AttributeHandle</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>AttributeHandle</code> begins 

* @return An <code>AttributeHandle</code> constructed from the 
buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public AttributeHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember ,- 

} 

//end AttributeHandleFactory 


DRDC Valcartier TR 2007-412 


117 



// File: AttributeHandleSet.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* A Set of {@link AttributeHandle}s. 

* All {@link java.util.Set} operations are required, none are 
optional. 

* <code>add()</code> and <code>remove()</code> should throw {@link 
IllegalArgumentException} if 

* the argument is not an <code>AttributeHandle</code>. 

* <code>addAll()</code>, <code>removeAll()</code> and 
<code>retainAll()</code> should throw {@link IllegalArgumentException} 
if 

* the argument is not an <code>AttributeHandleSet</code>. 

* <p> 

* <code>AttributeHandleSet</code>s are used by numerous {@link 
RTIambassador} methods and 

* are provided by numerous {@link FederateAmbassador} callbacks. 

* Empty ones can be created by the 

<code>AttributeHandleSetFactory</code>'s 

* {@link AttributeHandleSetFactory#create create} method. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public interface 
AttributeHandleSet 

extends j ava.util.Set, 

j ava.lang.Cloneable, 
j ava.io.Serializable 


//end AttributeHandleSet 


118 


DRDC Valcartier TR 2007-412 



// File: AttributeHandleSetFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 
RTIambassador#getAttributeHandleSetFactory 
getAttributeHandleSetFactory} method. 

* Its one method creates a new {@link AttributeHandleSet}, 

* to be loaded up and then passed to various {@link RTIambassador} 
methods. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
AttributeHandleSetFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link AttributeHandleSet}, initially empty. 

* @return An empty <code>AttributeHandleSet</code> 

*/ 

public AttributeHandleSet 
create () ,- 

} 

//end AttributeHandleSetFactory 


DRDC Valcartier TR 2007-412 


119 



// File: AttributeHandleValueMap.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* A Map linking {@link AttributeHandle} keys with the corresponding 
<code>byte[]</code> attribute values. 

* All {@link java.util.Map} operations are required, none are 
optional. Null mappings are not allowed. 

* <code>put()</code>, <code>putAll()</code> and <code>remove()</code> 
should throw {@link IllegalArgumentException} if 

* the key is not an <code>AttributeHandle</code> or the value a 
<code>byte[]</code>. 

* <p> 

* Its main purpose is for attribute update transmission using the 

(6.6) {@link RTIambassador#updateAttributeValues 

updateAttributeValues} (both forms) 

* method. The updates are received through the (6.7) {@link 
FederateAmbassador#reflectAttributeValues reflectAttributeValues} (all 
forms) 

* callback. 

* <p> 

* Empty <code>AttributeHandleValueMap</code>s can also be created by 
the {@link AttributeHandleValueMapFactory#create create} method. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
AttributeHandleValueMap 
extends j ava.util.Map, 

j ava.lang.Cloneable, 
j ava.io.Serializable 


//end AttributeHandleValueMap 


120 


DRDC Valcartier TR 2007-412 



// File: AttributeHandleValueMapFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 

Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 
RTIambassador#getAttributeHandleValueMapFactory 
getAttributeHandleValueMapFactory} method. 

* Its one method creates a new {@link AttributeHandleValueMap}, 

* to be loaded up and then passed to the (6.6) {@link 
RTIambassador#updateAttributeValues updateAttributeValues} (both 
forms) 

* method. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
AttributeHandleValueMapFactory 
extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link AttributeHandleValueMap} with the specified 
initial capacity. 

* @param capacity The initial size of the 
<code>AttributeHandleValueMap</code>, in number of keys 

* @return An <code>AttributeHandleValueMap</code> of the specified 
initial capacity (in keys) 

*/ 

public AttributeHandleValueMap 
create (int capacity) ; 

} 

//end AttributeHandleValueMapFactory 


DRDC Valcartier TR 2007-412 


121 



// File : AttributeRegionAssociation.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Record stored in {@link AttributeSetRegionSetPairList}. 

* Each record of that list associates a set of attributes with a set 
of regions. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds this class, 
inadvertently omitted from Annex B of IEEE 1516.1-2000. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
AttributeRegionAssociation 

implements j ava.io.Serializable 

{ 

j * * 

* The associated attribute set. 

*/ 

public 

AttributeHandleSet ahset; 

j * * 

* The associated region set. 

*/ 

public 

RegionHandleSet rhset; 

j * * 

* Constructs an AttributeRegionAssociation from the component 
attribute and region sets. 

* @param ahs The {@link AttributeHandleSet} to associate with the 
region set 

* @param rhs The {@link RegionHandleSet} to associate with the 
attribute set 

*/ 

public 

AttributeRegionAssociation(AttributeHandleSet ahs, 

RegionHandleSet rhs) 


ahset = ahs; 
rhset = rhs; 


//end AttributeRegionAssociation 


122 


DRDC Valcartier TR 2007-412 



// File: AttributeSetRegionSetPairList.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* This packages the attributes supplied to the RTI for various DDM 
services with 

* the regions to be used with the attributes. 

* It is a {@link java.util.List} of {@link 
AttributeRegionAssociation}s. 

* Each attribute appearing in an 
<code>AttributeRegionAssociation.AttributeHandleSet</code> is 
[un]associated with each 

* region appearing in the corresponding 

<code>AttributeRegionAssociation.RegionHandleSet</code>. 

* <p> 

* All List operations are required, none are optional. 

* <code>add()</code>, <code>addAll()</code> and <code>set()</code> 
should throw {@link IllegalArgumentException} 

* if the argument is not an <code>AttributeRegionAssociation</code>. 

* <p> 

* Used by the (9.5) {@link 
RTIambassador#registerObjectlnstanceWithRegions 
registerObjectlnstanceWithRegions} (both forms), 

* (9.6/9.7) {@link RTIambassador#unassociateRegionsForUpdates [un] } 

{@link RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates}, 

* (9.8/9.9) {@link 

RTIambassador#unsubscribeObjectClassAttributesWithRegions [un]} {@link 
RTIambassador#subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions} {@link 
RTIambassador#subscribeObj ectClassAttributesPassivelyWithRegions 
[Passively]} or 

* (9.13) {@link RTIambassador#requestAttributeValueUpdateWithRegions 

requestAttributeValueUpdateWithRegions} 

* methods. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

* @see AttributeSetRegionSetPairListFactory 

*/ 

public interface 
AttributeSetRegionSetPairList 
extends j ava.util.List, 

j ava.lang.Cloneable, 
j ava.io.Serializable 


//end AttributeSetRegionSetPairList 


DRDC Valcartier TR 2007-412 


123 



// File: AttributeSetRegionSetPairListFactory.j ava 
package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 
RTIambassador#getAttributeSetRegionSetPairListFactory 
getAttributeSetRegionSetPairListFactory} method. 

* Its one method creates a new {@link AttributeSetRegionSetPairList}, 

* to be loaded up and then passed to the (9.5) {@link 
RTIambassador#registerObjectInstanceWithRegions 
registerObjectlnstanceWithRegions} (both forms), 

* (9.6/9.7) {@link RTIambassador#unassociateRegionsForUpdates [un] } 

{@link RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates}, 

* (9.8/9.9) {@link 

RTIambassador#unsubscribeObjectClassAttributesWithRegions [un]} {@link 
RTIambassador#subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions} {@link 
RTIambassador#subscribeObjectClassAttributesPassivelyWithRegions 
[Passively]} or 

* (9.13) {@link RTIambassador#requestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions} 

* methods. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 

AttributeSetRegionSetPairListFactory 
extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link AttributeSetRegionSetPairList} with the 
specified initial capacity. 

* @param capacity The initial size of the 

<code>AttributeSetRegionSetPairList</code>, in number of 
</code>AttributeSetRegionSetPair</code>s 

* @return An <code>AttributeSetRegionSetPairList</code> of the 
specified initial capacity (in 

</code>AttributeSetRegionSetPair</code>s) 

*/ 

public AttributeSetRegionSetPairList 
create(int capacity); 

} 

//end AttributeSetRegionSetPairListFactory 


124 


DRDC Valcartier TR 2007-412 



// File: DimensionHandle.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Type-safe handle for a dimension. Generally these are created by 
the RTI and passed to the federate. 

* <p> 

* <code>DimensionHandle</code>s can be obtained from the 

* (10.12) {@link RTIambassador#getDimensionHandle getDimensionHandle} 

* and (as parts of a {@link DimensionHandleSet}) the 

* (10.15) {@link 

RTIambassador#getAvailableDimensionsForClassAttribute 
getAvailableDimensionsForClassAttribute}, 

* (10.17) {@link 

RTIambassador#getAvallableDimensionsForInteractionClass 
getAvailableDimensionsForInteractionClass} and 

* (10.30) {@link RTIambassador#getDimensionHandleSet 

getDimensionHandleSet} methods. 

* <p> 

* They can also be obtained by using the 
<code>DimensionHandleFactory</code>'s {@link 

DimensionHandleFactory#decode decode} method on a <code>byte[]</code> 

* received as part of an attribute update or interaction. 

* <p> 

* <code>DimensionHandle</code>s are used to build a {@link 
DimensionHandleSet} which can be passed to 

* the (9.2) {@link RTIambassador#createRegion createRegion} method. 

* They are also used by the 

* (10.13) {@link RTIambassador#getDimensionName getDimensionName}, 

* (10.14) {@link RTIambassador#getDimensionUpperBound 

getDimensionUpperBound} , 

* (10.31/10.32) {@link RTIambassador#getRangeBounds get}/{@link 
RTIambassador#setRangeBounds setRangeBounds} methods. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public interface 
DimensionHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>DimensionHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 


DRDC Valcartier TR 2007-412 


125 



* * 


* Returns true iff <code>this</code> and 
<code>otherDimensionHandle</code> represent the same dimension handle. 

* @param otherDimensionHandle the <code>Object</code> to compare 

with 

* @return <code>true</code> iff supplied 
<code>otherDimensionHandle</code> is of type 
<code>DimensionHandle</code> and has same value 

*/ 

public boolean 

equals(Object otherDimensionHandle); 

j * * 

* Returns a hash code for <code>this</code>; two 
<code>DimensionHandle</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>DimensionHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset The offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 

encode(byte[] buffer, int offset); 

} 

//end DimensionHandle 


126 


DRDC Valcartier TR 2007-412 



// File: DimensionHandleFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getDimensionHandleFactory getDimensionHandleFactory} 
method. 

* Its one method creates a new {@link DimensionHandle} from a 
supplied <code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
DimensionHandleFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link DimensionHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of a <code>DimensionHandle</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>DimensionHandle</code> begins 

* @return A <code>DimensionHandle</code> constructed from the 
buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public DimensionHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember ,- 

} 

//end DimensionHandleFactory 


DRDC Valcartier TR 2007-412 


127 



// File: DimensionHandleSet.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* A {@link java.util.Set} of {@link DimensionHandle}s. 

* All Set operations are required, none are optional. 

* <code>add()</code> and <code>remove()</code> should throw {@link 
IllegalArgumentException} if the argument is not a 
<code>DimensionHandle</code>. 

* <code>addAll()</code>, <code>removeAll()</code> and 
<code>retainAll()</code> should throw 
<code>IllegalArgumentException</code> if 

* the argument is not a <code>DimensionHandleSet</code>. 

* <p> 

* Used with the (9.2) {@link RTIambassador#createRegion createRegion} 
method. 

* Returned by the 

* (10.15) {@link 

RTIambassador#getAvallableDimensionsForClassAttribute 
getAvailableDimensionsForClassAttribute}, 

* (10.17) {©dink 

RTIambassador#getAvailableDimensionsForInteractionClass 
getAvailableDimensionsForInteractionClass} and 

* (10.30) {@link RTIambassador#getDimensionHandleSet 
getDimensionHandleSet} 

* methods. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see DimensionHandleSetFactory 
*/ 

public interface 
DimensionHandleSet 

extends j ava.lang.Cloneable, 
j ava.io.Serializable, 
j ava.util.Set 


//end DimensionHandleSet 


128 


DRDC Valcartier TR 2007-412 



// File: DimensionHandleSetFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 
RTIambassador#getDimensionHandleSetFactory 
getDimensionHandleSetFactory} method. 

* Its one method creates a new {@link DimensionHandleSet}, 

* to be loaded up and then passed to the (9.2) {@link 
RTIambassador#createRegion createRegion} method. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 

DimensionHandleSetFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link DimensionHandleSet}, initially empty. 

* @return An empty <code>DimensionHandleSet</code> 

*/ 

public DimensionHandleSet 
create () ,- 

} 

//end DimensionHandleSetFactory 


DRDC Valcartier TR 2007-412 


129 



// File: FederateAmbassador.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Federate must implement this interface. 

* <p> 

* As of DoD Interpretations of IEEE 1516-2000v2, none of the 
<code>FederateAmbassador</code> callbacks will ever occur 

* with a <code>null</code> argument, with one exception: user- 
supplied <code>tag</code> arguments may be <code>null</code>. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface FederateAmbassador 


// Federation Management Services // 


II 4.7 

j * * 

* Notifies the federate that it has successfully registered a 
federation synchronization point. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see #announceSynchronizationPoint announceSynchronizationPoint 

* @see #federationSynchronized federationSynchronized 

*/ 

public void 

synchronizationPointRegistrationSucceeded( 

String synchronizationPointLabel) 

throws FederatelnternalError; 


130 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that it has failed to register a 
federation synchronization point. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @param reason a {@link SynchronizationPointFailureReason} 
specifying what went wrong 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see #announceSynchronizationPoint announceSynchronizationPoint 

* @see #federationSynchronized federationSynchronized 

*/ 

public void 

synchronizationPointRegistrationFailed( 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 
throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


131 



* Notifies the federate that a synchronization point exists. 

* Achievement of the point is signalled to the RTI through the 

* {@link RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved} method. 

* <p> 

* Federates are by default part of the synchronization set, unless 
a {@link FederateHandleSet} has been specifically 

* supplied to the {@link 

RTIambassador#registerFederationSynchronizationPoint(String,byte[],Fed 
erateHandleSet)} method. 

* A federate that resigns is simply removed from the 
synchronization set. 

* The synchronization point exists until it has been achieved by 
all concerned federates, which could be 

* until the federation execution concludes. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see #synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see #federationSynchronized federationSynchronized 

*/ 

public void 

announceSynchronizationPoint( 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 
throws FederatelnternalError,- 


132 


DRDC Valcartier TR 2007-412 



* * 


* Informs the joined federate that all members of the 
synchronization set of the specified synchronization point 

* have invoked the {@link 
RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved} method for that point. 

* The synchronization point ceases to exist once this callback has 
been invoked on all concerned federates. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see #synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see #announceSynchronizationPoint announceSynchronizationPoint 

*/ 

public void 

federationSynchronized( 

String synchronizationPointLabel) 
throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


133 



II 4.12 

j * * 

* Instructs the joined federate that it is now in the Instructed 
To Save state 

* and should therefore save state as soon as possible. 

* The joined federate should use the supplied <code>label</code>, 

* the name of the federation execution (see the 
<code>federationExecutionName</code> 

* of the {@link RTIambassador#joinFederationExecution 
joinFederationExecution} invocation), 

* its joined federate designator (returned by the aforementioned 
invocation) and 

* its federate type (the aforementioned invocation's 
<code>federateType</code> argument) 

* to distinguish the saved state information. 

* <p> 

* A federate that is not time constrained should expect this 
callback at any point. 

* A time constrained federate can receive this callback only 
whilst in the Time Advancing state. 

* Once in the Instructed To Save state, the federate is severely 
limited in which RTIambassador 

* methods it can invoke. This lasts through the Saving and Waiting 
For Federation To Save states, 

* concluding with the {@link #federationSaved federationSaved} or 

* {@link #federationNotSaved federationNotSaved} callbacks. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

initiateFederateSave( 

String label) 

throws UnableToPerformSave, 

FederatelnternalError ,- 


134 


DRDC Valcartier TR 2007-412 



* * 


* Instructs the joined federate that it is now in the Instructed 
To Save state 

* (as of the specified <code>time</code>) and should therefore 
save state as soon as possible. 

* <p> 

* For details, see the {@link #initiateFederateSave(String)} 
callback. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param time a {@link LogicalTime} specifying when the save was 
scheduled 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #federationSaved federationSaved 

* @see #federationNotSaved federationNotSaved 

* @see #federationSaveStatusResponse federationSaveStatusResponse 

*/ 

public void 
initiateFederateSave( 

String label, 

LogicalTime time) 
throws InvalidLogicalTime, 

UnableToPerformSave, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


135 



II 4.15 

j * * 

* Informs the joined federate that the federation save process is 
complete and successfull. 

* <p> 

* All joined federates at which the {@link #initiateFederateSave 
initiateFederateSave} callback 

* was invoked have in turn invoked the {@link 
RTIambassador#federateSaveComplete federateSaveComplete} method. 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #initiateFederateSave initiateFederateSave 

* @see #federationNotSaved federationNotSaved 

* @see #federationSaveStatusResponse federationSaveStatusResponse 

*/ 

public void 

federationSaved() 

throws FederatelnternalError; 


136 


DRDC Valcartier TR 2007-412 



* * 


* Informs the joined federate that the federation save process has 
completed in failure. 

* <p> 

* The possible save failure reasons are: 

* <ul > 

* <li> RTI_UNABLE_TO_SAVE: The RTI was unable to save 

* <li> FEDERATE_REPORTED_FAILURE: One or more joined federates 
have invoked the {@link RTIambassador#federateSaveNotComplete 
federateSaveNotComplete} method 

* <li> FEDERATE_RESIGNED: One or more joined federates have 
resigned from the federation execution 

* <li> RTI_DETECTED_FAILURE: The RTI has detected failure at one 
or more of the joined federates 

* <li> SAVE_TIME_CANNOT_BE_HONORED: The time stamp specified by 
the {@link RTIambassador#requestFederationSave(String,LogicalTime)} 

* request cannot be honoured, due to possible race conditions in 
the distributed calculation of GALT (Greatest Available Logical Time) 

* </ul> 

* @param reason a {@link SaveFailureReason} specifying why the 
save failed 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #initiateFederateSave initiateFederateSave 

* @see #federationSaved federationSaved 

* @see #federationSaveStatusResponse federationSaveStatusResponse 

*/ 

public void 
federationNotSaved( 

SaveFailureReason reason) 
throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


137 



II 4.17 

j * * 

* Supplies the federate with the previously requested save status 
indicators. 

* @param response a {@link FederateHandleSaveStatusPair}[] 
specifying the {@link SaveStatus} of each federate 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #initiateFederateSave InitiateFederateSave 

* @see #federationSaved federationSaved 

* @see #federationNotSaved federationNotSaved 

*/ 

public void 

federationSaveStatusResponse( 

FederateHandleSaveStatusPair[] response) 

throws FederatelnternalError; 


138 


DRDC Valcartier TR 2007-412 



* * 


* Indicates that the federate's previous {@link 
RTIambassador#requestFederationRestore requestFederationRestore} has 
been granted. 

* <p> 

* This means the RTI has located the RTI-specific saved state 
information matching the previously supplied 

* <code>label</code>, {@link RTIambassador#]oinFederationExecution 

federationExecutionName} and 

* {@link RTIambassador#createFederationExecution fdd}, and that 
the census of currently joined 

* federates matches in number and {@link 
RTIambassador#joinFederationExecution federateType} that of the 

* RTI's saved state. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

requestFederationRestoreSucceeded( 

String label) 

throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


139 



* Indicates that the federate's previous {@link 
RTIambassador#requestFederationRestore requestFederationRestore} has 
been denied. 

* <p> 

* This means the RTI failed to locate its specific saved state 
information or that the census of 

* currently joined federates does not match in number and {@link 
RTIambassador#]oinFederationExecution federateType} 

* that of the retrieved RTI saved state. 

* Failures by individual federates to complete the restoration 
process lead to the 

* {@link #federationNotRestored federationNotRestored} callback 
instead. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestorestatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 

requestFederationRestoreFailed( 

String label) 

throws FederatelnternalError; 


140 


DRDC Valcartier TR 2007-412 



* * 


* Instructs the joined federate that it is now in the Prepared To 
Restore state 

* and should prepare to proceed with saved state restoration. The 
necessary information 

* is later provided by the {@link #initiateFederateRestore 
initiateFederateRestore} callback. 

* <p> 

* Once in the Prepared To Restore state, the federate is severely 
limited in which RTIambassador 

* methods it can invoke. This lasts through the Restoring and 
Waiting For Federation To Restore states, 

* concluding with the {@link #federationRestored 
federationRestored} or 

* {@link #federationNotRestored federationNotRestored} callbacks. 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

federationRestoreBegun() 
throws FederatelnternalError,- 


DRDC Valcartier TR 2007-412 


141 



II 4.21 

j * * 

* Instructs the joined federate to return to a previously saved 
state. 

* The joined federate should use the supplied <code>label</code>, 

* the name of the federation execution (see the 
<code>federationExecutionName</code> 

* of the {@link RTIambassador#joinFederationExecution 
joinFederationExecution} invocation), 

* the supplied federate designator (<code>federateHandle</code>) 

and 

* its federate type (the aforementioned invocation's 
<code>federateType</code> argument) 

* to retrieve the saved state information. 

* <p> 

* Note that the supplied <code>federateHandle</code> may differ 
from the federate's current {@link FederateHandle}; 

* it will assume this new designator if and once it receives the 
{@link #federationRestored federationRestored} callback. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param federateHandle the {@link FederateHandle} that the 
federate will assume if and once it receives the {@link 

#federationRestored federationRestored} callback 

* @throws SpecifiedSaveLabelDoesNotExist should be thrown if the 
label isn't recognized 

* @throws CouldNotlnitiateRestore should be thrown if the federate 
is unwilling or unable to initiate the restore operation 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestorestatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 

initiateFederateRestore( 

String label, 

FederateHandle federateHandle) 

throws SpecifiedSaveLabelDoesNotExist, 

CouldNotlnitiateRestore, 

FederatelnternalError; 


142 


DRDC Valcartier TR 2007-412 



// 4.23 

j * * 

* Informs the joined federate that the federation restore process 
is complete and successfull. 

* This means that all joined federates which received the {@link 
#federationRestoreBegun federationRestoreBegun} 

* callback have invoked the {@link 

RTIambassador#federateRestoreComplete federateRestoreComplete} method. 

* The federate's {@link FederateHandle} is now the one that was 
supplied by the {@link #initiateFederateRestore 

initiateFederateRestore} callback. 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

federationRestored () 

throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


143 



* Informs the joined federate that the federation restore process 
has completed in failure. 

* <p> 

* The possible save failure reasons are: 

* <ul > 

* <li> RTI_UNABLE_TO_RESTORE: The RTI was unable to restore 

* <li> FEDERATE_REPORTED_FAILURE: One or more federates have 
invoked the {@link RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete} method 

* <li> FEDERATE_RESIGNED: One or more joined federates have 
resigned from the federation execution 

* <li> RTI_DETECTED_FAILURE: The RTI has detected failure at one 
or more of the joined federates 

* </ul> 

* @param reason a {@link RestoreFailureReason} specifying the 
reason for the failure 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestorestatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 
federationNotRestored( 

RestoreFailureReason reason) 
throws FederatelnternalError; 


144 


DRDC Valcartier TR 2007-412 



// 4.25 

j * * 

* Supplies the federate with the previously requested restore 
status indicators. 

* <p> 

* The {@link FederateHandle}s used in the {@link 
FederateHandleRestoreStatusPair}[] are the pre-restore ones 

* until all federates have invoked the {@link 
RTIambassador#federateRestoreComplete federateRestoreComplete} 

* service. Once all federates have been issued the {@link 
#federationRestored} callbacks, the post-restore 

* <code>FederateHandle</code>s are used (and each federate's 
status will be {@link RestoreStatus NO_RESTORE_IN_PROGRESS}). 

* <p> 

* If the {@link RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus} service is 

* invoked between those two times, the {@link RestoreStatus} and 
<code>FederateHandle</code>s are unpredictable. 

* A federate should therefore avoid invoking the 
<code>queryFederationRestoreStatus</code> service between the moment 

* it invokes the <code>federateRestoreComplete</code> service and 
the moment it receives the <code>federationRestored</code> 

* or {@link #federationNotRestored} callbacks. 

* @param response a {@link FederateHandleRestoreStatusPair}[] 
specifying the {@link RestoreStatus} of each federate 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

*/ 

public void 

federationRestoreStatusResponse( 

FederateHandleRestoreStatusPair[] response) 
throws FederatelnternalError,- 


DRDC Valcartier TR 2007-412 


145 



// Declaration Management Services // 


1111111111111111111111111111111111111 

ii 5.10 
j * * 

* Notifies the federate that registration of new object instances 
of the specified object class 

* is advised because at least one of the federate-published class 
attributes is actively subscribed to 

* by at least one other federate at that object class. 

* This occurs only if the federate's Object Class Relevance 
Advisory Switch is turned on. 

* @param theClass the {@link ObjectClassHandle} of the subject 
object class 

* @throws ObjectClassNotPublished should be thrown if the federate 
denies publishing <code>theClass</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

* @see RTIambassador#enableObjectClassRelevanceAdvisorySwitch 
enableObj ectClassRelevanceAdvisorySwitch 

* @see RTIambassador#disableObjectClassRelevanceAdvisorySwitch 
disableObj ectClassRelevanceAdvisorySwitch 

*/ 

public void 

startRegistratIonForObj ectClass( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError; 


146 


DRDC Valcartier TR 2007-412 



II 5.11 

j * * 

* Notifies the federate that registration of new object instances 
of the specified object class 

* is not advised because there are no active subscribers to any of 
the federate-published class attributes 

* at that object class. 

* This occurs only if the federate's Object Class Relevance 
Advisory Switch is turned on. 

* @param theClass the {@link ObjectClassHandle} of the subject 
object class 

* @throws ObjectClassNotPublished should be thrown if the federate 
denies publishing <code>theClass</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #startRegistrationForObj ectClass 
startRegistrationForObj ectClass 

* @see RTIambassador#enableObjectClassRelevanceAdvisorySwitch 
enableObj ectClassRelevanceAdvisorySwitch 

* @see RTIambassador#disableObj ectClassRelevanceAdvisorySwitch 
disableObj ectClassRelevanceAdvisorySwitch 

*/ 

public void 

stopRegistrationForObjectClass( 

Obj ectClassHandle theClass) 

throws Obj ectClassNotPublished, 

FederatelnternalError,- 


II 5.12 
j * * 

* Notifies the federate that the specified class of interactions 
is relevant because 

* there is at least one active subscription by another federate. 

* This occurs only if the federate's Interaction Relevance 
Advisory Switch is turned on. 

* @param theHandle the {@link InteractionClassHandle} of the 
subject interaction class 

* @throws InteractionClassNotPublished should be thrown if the 
federate denies publishing <code>theHandle</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnInteractionsOff turnlnteractionsOff 

* @see RTIambassador#enableInteractionRelevanceAdvisorySwitch 
enableInteractionRelevanceAdvisorySwitch 

* @see RTIambassador#disableInteractIonRelevanceAdvisorySwitch 
disableInteractionRelevanceAdvisorySwitch 

*/ 

public void 
turnlnteractionsOn( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


147 



// 5.13 

j * * 

* Notifies the federate that the specified class of interactions 
is not relevant because 

* there are no active subscriptions by other federates. 

* This occurs only if the federate's Interaction Relevance 
Advisory Switch is turned on. 

* @param theHandle the {@link InteractionClassHandle} of the 
subject interaction class 

* @throws InteractionClassNotPublished should be thrown if the 
federate denies publishing <code>theHandle</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnInteractionsOn turnlnteractionsOn 

* @see RTIambassador#enableInteractionRelevanceAdvisorySwitch 
enableInteractionRelevanceAdvisorySwitch 

* @see RTIambassador#disablelnteractionRelevanceAdvisorySwitch 
disableInteractionRelevanceAdvisorySwitch 

*/ 

public void 
turnlnteractionsOff( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError; 


// Object Management Services // 


j * * 

* Notifies the federate that the <code>objectName</code> provided 
in a previous invocation of the 

* {@link RTIambassador#reserveObjectInstanceName 
reserveObjectInstanceName} method has been reserved. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 changes the service name 
from "<code>obj ectInstanceNameReservationSuccededc/code> 11 

* to 11 <code>ob j ect Ins t anceNameReserva tionSucceeded</code > 11 . 

* @param objectName a {@link java.lang.String} holding the 
requested object name 

* @throws UnknownName should be thrown if the federate denies 
requesting to reserve the <code>objectName</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#reserveObjectInstanceName 
reserveObj ectInstanceName 

* @see #obj ectlnstanceNameReservationFailed 
obj ectInstanceNameReservationFailed 

*/ 

public void 

obj ectlnstanceNameReservationSucceeded( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError; 


148 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that the <code>objectName</code> provided 
in a previous invocation of the 

* {@link RTIambassador#reserveObj ectlnstanceName 
reserveObjectlnstanceName} method could not be reserved. 

* @param objectName a {@link java.lang.String} holding the 
requested object name 

* @throws UnknownName should be thrown if the federate denies 
requesting to reserve the <code>objectName</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#reserveObj ectlnstanceName 
reserveObj ectlnstanceName 

* @see #obj ectInstanceNameReservationSucceeded 
obj ectInstanceNameReservationSucceeded 

*/ 

public void 

obj ectlnstanceNameReservationFailed( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError; 


j * * 

* Notifies the federate that it has discovered an object instance. 

* @param theObject the {@link ObjectlnstanceHandle} of the newly 
discovered object instance 

* @param theObjectClass the {@link ObjectClassHandle} of the class 
the instance was discovered as 

* @param objectName a {@link java.lang.String} holding the newly 
discovered object instance's name 

* @throws CouldNotDiscover should be thrown if the object instance 
could not be discovered for some reason other than an unrecognized 
object class 

* @throws ObjectClassNotRecognized should be thrown if the 
federate does not recognize <code>theObjectClass</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#registerObj ectInstance registerObj ectInstance 

*/ 

public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederatelnternalError; 


DRDC Valcartier TR 2007-412 


149 



* Provides the federate with new values for the specified instance 
attributes. 

* This callback, coupled with the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 

<code>sentOrdering</code> and <code>theTransport</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


150 


DRDC Valcartier TR 2007-412 



* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectlnstanceHandle,AttributeHand 
leValueMap,byte[] ) 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


151 



* Provides the federate with new values for the specified instance 
attributes 

* and specifies the update regions used. 

* This callback, coupled with the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided, 

* the instance attributes have available dimensions, the 
federate's Convey Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType}, {@link InvalidRegion} or 
{©dink InvalidRegionContext} 

* exceptions (nor a notional new <code>InvalidRegionSet</code> 
exception) ,- in other words the RTI 

* guarantees the validity and pertinence of the supplied 
<code>sentOrdering</code>, 

* <code>theTransport</code> and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


152 


DRDC Valcartier TR 2007-412 



* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectlnstanceHandle,AttributeHand 
leValueMap,byte[] ) 

* @see RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


153 



* Provides the federate with new values for the specified instance 
attributes 

* and specifies the time-stamp at which this comes into effect. 

* This callback, coupled with the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the <code>receivedOrdering</code> is also 
RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType} or {@link InvalidLogicalTime} 

* exceptions; in other words the RTI guarantees the validity of 
the supplied 

* <code>sentOrdering</code>, <code>theTransport</code>, 

<code>theTime</code> 

* and <code>receivedOrdering</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


154 


DRDC Valcartier TR 2007-412 



* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectlnstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


155 



* Provides the federate with new values for the specified instance 
attributes, 

* specifies the update regions used 

* and specifies the time-stamp at which this comes into effect. 

* This callback, coupled with the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided, 

* the instance attributes have available dimensions, the 
federate's 

* Convey Region Designator Sets Switch is enabled and an update 
region set 

* was used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the <code>receivedOrdering</code> is also 
RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType}, {@link InvalidLogicalTime}, 
{@link InvalidRegion} or 

* {@link InvalidRegionContext} exceptions (nor a notional new 
<code>InvalidRegionset</code> 

* exception) ,- in other words the RTI guarantees the validity of 
the supplied 

* <code>sentOrdering</code>, <code>theTransport</code>, 

<code>theTime</code>, 

* <code>receivedOrdering</code> and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


156 


DRDC Valcartier TR 2007-412 



* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectlnstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

* @see RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


157 



* Provides the federate with new values for the specified instance 
attributes 

* and specifies the time-stamp at which this comes into effect as 
well as a retraction handle. 

* This callback, coupled with the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided) 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType} or {@link 
InvalidMessageRetract ionHandle} exceptions ,- 

* in other words the RTI guarantees the validity of the supplied 

* <code>sentOrdering</code>, <code>theTransport</code>, 

<code>receivedOrdering</code> and 

* <code>retractionHandle</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


158 


DRDC Valcartier TR 2007-412 



* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectlnstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


159 



* Provides the federate with new values for the specified instance 
attributes, 

* specifies the update regions used 

* and specifies the time-stamp at which this comes into effect as 
well as a retraction handle. 

* This callback, coupled with the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided), 

* the instance attributes have available dimensions, the 
federate's Convey Region Designator Sets Switch 

* is enabled and an update region set was used by the sender. 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType}, {@link 
InvalidMessageRetractionHandle}, 

* {@link InvalidRegion} or {@link InvalidRegionContext} exceptions 
(nor a notional 

* new <code>InvalidRegionSet</code> exception); in other words the 
RTI guarantees the validity 

* of the supplied <code>sentOrdering</code>, 

<code>theTransport</code>, <code>receivedOrdering</code>, 

* <code>retractionHandle</code> and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


160 


DRDC Valcartier TR 2007-412 



* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectlnstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

* @see RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


161 



* Provides the federate with a sent interaction. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 

<code>sentOrdering</code> and <code>theTransport</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


162 


DRDC Valcartier TR 2007-412 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[]) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


163 



* Provides the federate with a sent interaction and 

* specifies the broadcasting regions used. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided, 

* the parameters have available dimensions, the federate's Convey 
Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType}, {@link InvalidRegion} or 
{©dink InvalidRegionContext} exceptions 

* (nor a notional new <code>InvalidRegionSet</code> exception); in 
other words the RTI guarantees 

* the validity of the supplied <code>sentOrdering</code>, 

<code>theTransport</code> 

* and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


164 


DRDC Valcartier TR 2007-412 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteractionWithRegions(InteractionClassHandle,Parame 
terHandleValueMap,RegionHandleSet,byte[]) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


165 



* Provides the federate with a sent interaction 

* and specifies the time-stamp at which this occurs. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 

<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType} or {@link InvalidLogicalTime} 
exceptions; in other words the 

* RTI guarantees the validity of the supplied 

<code>sentOrdering</code>, <code>theTransport</code>, 

* <code>receivedOrdering</code> and <code>theTimec/code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


166 


DRDC Valcartier TR 2007-412 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[],LogicalTime) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


167 



* Provides the federate with a sent interaction, 

* specifies the broadcasting regions used 

* and specifies the time-stamp at which this occurs. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided, 

* the parameters have available dimensions, the federate's Convey 
Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 

<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType}, {@link InvalidLogicalTime}, 
{@link InvalidRegion} or 

* {@link InvalidRegionContext} exceptions (nor a notional new 
<code>InvalidRegionSet</code> exception) ,- 

* in other words the RTI guarantees the validity of the supplied 
<code>sentOrdering</code>, 

* <code>theTransport</code>, <code>receivedOrdering</code>, 

<code>theTime</code> 

* and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


168 


DRDC Valcartier TR 2007-412 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteractionWithRegions(InteractionClassHandle,Parame 
terHandleValueMap,RegionHandleSet,byte[],LogicalTime) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


169 



* Provides the federate with a sent interaction 

* and specifies the time-stamp at which this occurs as well as a 
retraction handle. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided) 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 

<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType} or {@link 
InvalidMessageRetractionHandle} exceptions; 

* in other words the RTI guarantees the validity of the supplied 
<code>sentOrdering</code>, 

* <code>theTransport</code>, <code>receivedOrdering</code> and 
<code>messageRetractionHandle</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


170 


DRDC Valcartier TR 2007-412 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param messageRetractionHandle the {@link 
MessageRetractionHandle} of the message 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[],LogicalTime) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle) 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


171 



* Provides the federate with a sent interaction, 

* specifies the broadcasting regions used 

* and specifies the time-stamp at which this occurs as well as a 
retraction handle. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided), 

* the parameters have available dimensions, the federate's Convey 
Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 

<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType}, 

* {@link InvalidTransportationType}, {@link 
InvalidMessageRetractionHandle}, 

* {@link InvalidRegion} or {@link InvalidRegionContext} exceptions 
(nor a notional 

* new <code>InvalidRegionSet</code> exception); in other words the 
RTI guarantees the validity 

* of the supplied <code>sentOrdering</code>, 

<code>theTransport</code>, <code>receivedOrdering</code>, 

* <code>messageRetractionHandle</code> and 
<code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


172 


DRDC Valcartier TR 2007-412 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param messageRetractionHandle the {@link 
MessageRetractionHandle} of the message 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#sendInteractionWithRegions 
sendlnteractionWithRegions 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


173 



* * 


* Notifies the federate that an object instance has been deleted 
from the federation execution. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE 

* and no time-stamp was provided. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#deleteObj ectInstance deleteObj ectInstance 

*/ 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag, 

OrderType sentOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError ,- 


174 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that an object instance has been deleted 
from the federation execution 

* at the specified time stamp. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE 

* and a time-stamp was provided. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @param theTime the {@link LogicalTime} at which the deletion 
occurs 

* @param receivedOrdering the {@link OrderType} the message was 
received as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#deleteObj ectInstance deleteObj ectInstance 

*/ 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


175 



* * 


* Notifies the federate that an object instance has been deleted 
from the federation execution 

* at the specified time stamp and specifies a retraction handle. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (and thus a time-stamp was provided). 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @param theTime the {@link LogicalTime} at which the deletion 
occurs 

* @param receivedOrdering the {@link OrderType} the message was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#deleteObj ectInstance deleteObj ectInstance 

*/ 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 

InvalidLogicalTime, 

FederatelnternalError ,- 


176 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that the specified attributes for the 
object instance are in its scope. 

* This occurs only if the Attribute Scope Advisory Switch is on 
for the federate. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the pertinent attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #attributesOutOfScope attributesOutOfScope 

* @see RTIambassador#enableAttributeScopeAdvisorySwitch 
enableAttributeScopeAdvisorySwitch 

* @see RTIambassador#disableAttributeScopeAdvisorySwitch 
disableAttributeScopeAdvisorySwitch 

*/ 

public void 
attributesInScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


177 



* * 


* Notifies the federate that the specified attributes for the 
object instance are out of its scope. 

* This occurs only if the Attribute Scope Advisory Switch is on 
for the federate. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the pertinent attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #attributesInScope attributesInScope 

* @see RTIambassador#enableAttributeScopeAdvisorySwitch 
enableAttributeScopeAdvisorySwitch 

* @see RTIambassador#disableAttributeScopeAdvisorySwitch 
disableAttributeScopeAdvisorySwitch 

*/ 

public void 
attributesOutOfScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


178 


DRDC Valcartier TR 2007-412 



* * 


* Requests of the federate the current values of the specified 
instance attributes, which it owns. 

* The federate should respond through the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method. 

* @param theObject the {@link ObjectlnstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the requested attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#requestAttributeValueUpdate 
requestAttributeValueUpdate 

*/ 

public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


179 



* * 


* Indicates to the federate that the values of the specified 
instance attributes are required somewhere 

* in the federation execution. The federate should therefore 
update them as needed. 

* This occurs only if the Attribute Relevance Advisory Switch is 
on for the federate. 

* @param theObject the {@link ObjectInstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnUpdatesOffForObj ectInstance 
turnUpdatesOffForObj ectInstance 

* @see RTIambassador#enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#updateAttributeValues updateAttributeValues 

*/ 

public void 

turnUpdatesOnForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 


180 


DRDC Valcartier TR 2007-412 



* * 


* Indicates to the federate that the values of the specified 
instance attributes are no 

* longer required anywhere in the federation execution. 

* This occurs only if the Attribute Relevance Advisory Switch is 
on for the federate. 

* @param theObject the {@link ObjectlnstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnUpdatesOnForObj ectlnstance 
turnUpdatesOnForObj ectlnstance 

* @see RTIambassador#enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#updateAttributeValues updateAttributeValues 

*/ 

public void 

turnUpdatesOffForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


181 



11111111111111111111111111111111111 
// Ownership Management Services // 
/////////////////////////////////// 

// 7-4 

j * * 

* Requests that the federate acquire ownership of the specified 
instance attributes. 

* This can occur because the original owner invoked {@link 
RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditionalAttributeOwnershipDivestiture} 

* or {@link RTIambassador#resignFederationExecution 
resignFederationExecution} (with the 

* UNCONDITIONALLY_DIVEST_ATTRIBUTES, DELETE_OBJECTS_THEN_DIVEST or 
CANCEL_THEN_DELETE_THEN_DIVEST policy). 

* It will <i>not</i> occur if the original owner invoked the 
{@link RTIambassador#unpublishObj ectClassAttributes 
unpublishObj ectClassAttributes} 

* service or if the {@link RTIambassador#registerObjectInstance 
registerObjectlnstance} service is used (and 

* the newly-registered object instance has some unowned 
attributes). 

* <p> 

* The federate may return a subset of the 
<code>offeredAttributes</code> for which it is willing to assume 
ownership 

* through the {@link RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} or {@link 
RTIambassador#attributeOwnershipAcquisitionlfAvailable 
attributeOwnershipAcquisitionlfAvailable} methods. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param offeredAttributes an {@link AttributeHandleSet} 
specifying the offered attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeNotPublished should be thrown if the federate 
denies publishing an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError ,- 


182 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that potential new owners have been found 
for the specified instance attributes and that 

* the negotiated divestiture of these can now be completed. The 
federate can either complete the negotiated 

* divestiture using {@link RTIambassador#confirmDivestiture 
confirmDivestiture}, divest ownership of the instance attributes by 

* some other means (e.g. ; using {@link 
RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditionalAttributeOwnershipDivestiture}) or it can 

* {@link 

RTIambassador#cancelNegotiatedAttributeOwnershipDivestiture 
cancelNegotiatedAttributeOwnershipDivestiture}. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param offeredAttributes an {@link AttributeHandleSet} 
specifying the offered attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws AttributeDivestitureWasNotRequested should be thrown if 
the federate repudiates the divestiture 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


183 



* * 


* Notifies the federate that it now owns the specified set of 
instance attributes. 

* The federate may receive multiple notifications for a single 
invocation of 

* {@link RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} or 

* {@link RTIambassador#attributeOwnershipAcquisitionIfAvailable 
attributeOwnershipAcquisitionlfAvailable} if the requested 

* instance attributes are owned by different federates. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param securedAttributes an {@link AttributeHandleSet} 
specifying the secured attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAcquisitionWasNotRequested should be thrown if 
the federate repudiates its attribute ownership acquisition request 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeNotPublished should be thrown if the federate 
denies publishing an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

attributeOwnershipAcquisitionNotification( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError ,- 


184 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that the specified instance attributes 
were not available for ownership acquisition. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the declined attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeAcquisitionWasNotRequested should be thrown if 
the federate repudiates its attribute ownership acquisition request 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#attributeOwnershipAcquisitionIfAvailable 
attributeOwnershipAcquisitionlfAvailable 

*/ 

public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotRequested, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


185 



II 7.11 

j * * 

* Requests that the federate release ownership of the specified 
instance attributes. 

* The federate may return the subset of instance attributes for 
which it is willing 

* to release ownership through {@link 
RTIambassador#attributeOwnershipDivestitureIfWanted 
attributeOwnershipDivestiturelfWanted}, 

* {@link RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditionalAttributeOwnershipDivestiture} or 

* {@link RTIambassador#negotiatedAttributeOwnershipDivestiture 
negotiatedAttributeOwnershipDivestiture}. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param candidateAttributes an {@link AttributeHandleSet} 
specifying the candidate attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition 

*/ 

public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet candidateAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 


186 


DRDC Valcartier TR 2007-412 



II 7.15 

j * * 

* Notifies the federate that the pending attribute ownership 
acquisition requests for the 

* specified instance attributes have been canceled as requested. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeAcquisitionWasNotCanceled should be thrown if 
the federate repudiates the attribute ownership acquisition 
cancellation 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition 

*/ 

public void 

confirmAttributeOwnershipAcquisitionCancellation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


187 



II 7.17 

j * * 

* In response to an attribute ownership query by the federate, 
specifies the instance attribute's owner: another federate. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
attribute 

* @param theOwner the {@link FederateHandle} of the federate 
owning the attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#queryAttributeOwnership 
queryAttributeOwnership 

*/ 

public void 

informAttributeOwnership( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute, 

FederateHandle theOwner) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError,- 


j * * 

* In response to an attribute ownership query by the federate, 
specifies that the instance attribute is unowned. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#queryAttributeOwnership 
queryAttributeOwnership 

*/ 

public void 
attributelsNotOwned( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 


188 


DRDC Valcartier TR 2007-412 



* * 


* In response to an attribute ownership query by the federate, 
specifies the instance attribute's owner: the RTI. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#queryAttributeOwnership 
queryAttributeOwnership 

*/ 

public void 
attributelsOwnedByRTI( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 


// Time Management Services // 


j * * 

* Notifies the federate that its request to enable time-regulation 
has been honored. 

* @param time the {@link LogicalTime} to which the federate's 
clock has been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid 

* @throws NoRequestToEnableTimeRegulationWasPending should be 
thrown if the federate repudiates the time regulation request 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#enableTimeRegulation enableTimeRegulation 

*/ 

public void 
timeRegulationEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeRegulationWaspending, 
FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


189 



* * 


* Notifies the federate that its request to enable time-constraint 
has been honored. 

* @param time the {@link LogicalTime} to which the federate's 
clock has been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws NoRequestToEnableTimeConstrainedWasPending should be 
thrown if the federate repudiates the time constraint request 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#enableTimeConstrained enableTimeConstrained 

*/ 

public void 

timeConstrainedEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeConstrainedWasPending, 
FederatelnternalError; 


// 8.13 

j * * 

* Notifies the federate that its request to advance its logical 
time has been honored. 

* @param theTime the {@link LogicalTime} to which the federate's 
clock has been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws JoinedFederatelsNotlnTimeAdvancingState should be thrown 
if the federate does not consider itself in the time-advancing state 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#timeAdvanceRequest timeAdvanceRequest 

* @see RTIambassador#timeAdvanceRequestAvaliable 
timeAdvanceRequestAvailable 

* @see RTIambassador#nextMessageRequest nextMessageRequest 

* @see RTIambassador#nextMessageRequestAvaliable 
nextMessageRequestAvailable 

* @see RTIambassador#flushQueueRequest flushQueueRequest 

*/ 

public void 
timeAdvanceGrant( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

JoinedFederatelsNotInTimeAdvancingState, 
FederatelnternalError; 


190 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that the previously delivered message 
specified by the supplied 

* {@link MessageRetractionHandle} has been retracted. 

* <p> 

* Time-constrained federates that do not use the {@link 
RTIambassador#flushQueueRequest flushQueueRequest} method 

* are not subject to invocation of this service because they will 
never receive a 

* {@link OrderType TIMESTAMP} message eligible for retraction. 

* Non-constrained federates, however, must be prepared to deal 
with invocations of this 

* service because any received message that was sent {@link 
OrderType TIMESTAMP} may be eligible for retraction. 

* @param theHandle the {@link MessageRetractionHandle} specifying 
the retracted message 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#retract retract 

*/ 

public void 
requestRetraction( 

MessageRetractionHandle theHandle) 
throws FederatelnternalError,- 

} 

//end FederateAmbassador 


DRDC Valcartier TR 2007-412 


191 



// File: FederateHandle.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Type-safe handle for a federate handle. Generally these are created 
by the RTI and passed to the federate. 

* <p> 

* The federate obtains its own <code>FederateHandle</code> from the 

(4.4) {@link RTIambassador#]oinFederationExecution 

j oinFederationExecution} 

* and (4.21) {@link FederateAmbassador#initiateFederateRestore 
initiateFederateRestore} methods; other federates' 
<code>FederateHandle</code>s are received through 

* the (4.17) {@link FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse} (as part of a {@link 
FederateHandleSaveStatusPair} [] ) , 

* (4.25) {@link FederateAmbassador#federationRestoreStatusResponse 

federationRestoreStatusResponse} (as part of a {@link 
FederateHandleRestoreStatusPair}[]) and 

* (7.17) {@link FederateAmbassador#informAttributeOwnership 
informAttributeOwnership} callbacks. 

* <p> 

* They can also be obtained by using the 

<code>FederateHandleFactory</code>'s {@link 

FederateHandleFactory#decode decode} method on a <code>byte[]</code> 

* received as part of an attribute update or interaction. 

* The Management Object Model (MOM) publishes the 
<code>HLAmanager.HLAfederate</code> object class, which has a 
<code>HLAfederateHandle</code> attribute. 

* The MOM also publishes the <code>HLAmanager.HLAfederate</code> 
interaction class (and its numerous sub-classes), which has a 
<code>HLAfederate</code> parameter. 

* The aforementioned attribute and parameter both have values of type 
<code>FederateHandle</code> (known to the MOM as 
<code>HLAhandle</code>). 

* <p> 

* <code>FederateHandle</code>s are used to build a {@link 
FederateHandleSet} which can be passed to 

* the (4.6) {@link 

RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint} method. 

* Lastly, the (10.33) {@link RTIambassador#normalizeFederateHandle 
normalizeFederateHandle} 

* method can be used to project a <code>FederateHandle</code> onto 
the <code>Federates</code> 

* dimension for <code>Region</code> specification purposes. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 


192 


DRDC Valcartier TR 2007-412 



public interface 
FederateHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>FederateHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 

j * * 

* Returns true iff <code>this</code> and 
<code>otherFederateHandle</code> represent the same federate handle. 

* @param otherFederateHandle the <code>Object</code> to compare 

with 

* @return <code>true</code> iff supplied 
<code>otherFederateHandle</code> is of type 
<code>FederateHandle</code> and has same value 

*/ 

public boolean 

equals(Object otherFederateHandle); 

j * * 

* Returns a hash code for <code>this</code>; two 
<code>FederateHandle</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>FederateHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength() ; 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end FederateHandle 


DRDC Valcartier TR 2007-412 


193 



// File : FederateHandleFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getFederateHandleFactory getFederateHandleFactory} 
method. 

* Its one method creates a new {@link FederateHandle} from a supplied 
<code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
FederateHandleFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link FederateHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of a <code>FederateHandle</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>FederateHandle</code> begins 

* @return A <code>FederateHandle</code> constructed from the 
buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public FederateHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember; 

} 

//end FederateHandleFactory 


194 


DRDC Valcartier TR 2007-412 



// File: FederateHandleRestoreStatusPair.j ava 

package hla.rtil516; //the package name was changed by DoD 

Interpretations of IEEE 1516-2000v2 

j * * 

* The (4.25) {@link 

FederateAmbassador#federationRestoreStatusResponse 
federationRestoreStatusResponse} 

* callback returns an array of these records. For each joined 
federate, there will 

* be a <code>FederateHandleRestoreStatusPair</code> record returned, 
specifying the 

* {@link RestoreStatus} of each {@link FederateHandle}. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds the 

java.io.Serializable implementation and a constructor. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see hla.rtil516.RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

*/ 

public final class 
FederateHandleRestoreStatusPair 

implements j ava.io.Serializable 

{ 

j * * 

* The federate handle. 

*/ 

public 

FederateHandle handle,- 

j * * 

* The federate's restoration status. 

*/ 

public RestoreStatus status,- 

j * * 

* Public constructor. Not expected to be used by the federate but 
rather by the RTI. 

* @param fh The <code>FederateHandle</code> of the federate whose 
corresponding <code>RestoreStatus</code> is specified by this record 

* @param rs The <code>RestoreStatus</code> of the federate 
specified by the <code>FederateHandle</code> field of this record 

*/ 

public 

FederateHandleRestoreStatusPair(FederateHandle fh, 

RestoreStatus rs) 


handle = fh; 
status = rs,- 


//end FederateHandleRestoreStatusPair 


DRDC Valcartier TR 2007-412 


195 



// File: FederateHandleSaveStatusPair.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* The (4.17) {@link FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse} 

* callback returns an array of these records. For each joined 
federate, there will 

* be a <code>FederateHandleSaveStatusPair</code> record returned, 
specifying the 

* {@link SaveStatus} of each {@link FederateHandle}. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds the 

java.io.Serializable implementation and a constructor. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see hla.rtil516.RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

*/ 

public final class 
FederateHandleSaveStatusPair 

implements j ava.io.Serializable 

{ 

j * * 

* The federate handle. 

*/ 

public 

FederateHandle handle,- 

j * * 

* The federate's save status. 

*/ 

public 

SaveStatus status,- 

j * * 

* Public constructor. Not expected to be used by the federate but 
rather by the RTI. 

* @param fh The <code>FederateHandle</code> of the federate whose 
corresponding <code>SaveStatus</code> is specified by this record 

* @param ss The <code>SaveStatus</code> of the federate specified 
by the <code>FederateHandle</code> field of this record 

*/ 

public 

FederateHandleSaveStatusPair(FederateHandle fh, 

SaveStatus ss) 


handle = fh; 
status = ss; 


//end FederateHandleSaveStatusPair 


196 


DRDC Valcartier TR 2007-412 



// File: FederateHandleSet.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* A Set of {@link FederateHandle}s. 

* All {@link java.util.Set} operations are required, none are 
optional. 

* <code>add()</code> and <code>remove()</code> should throw {@link 
IllegalArgumentException} if the argument is not a 
<code>FederateHandle</code>. 

* <code>addAll()</code>, <code>removeAll()</code> and 
<code>retainAll()</code> should throw 
<code>IllegalArgumentException</code> if 

* the argument is not a <code>FederateHandleSet</code>. 

* <p> 

* Used with the (4.6) {@link 

RTIambassador#registerFederationSynchronizationPoint(String,byte[],Fed 
erateHandleSet)} 

* method. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see FederateHandleSetFactory 
*/ 

public interface 
FederateHandleSet 

extends j ava.io.Serializable, 
j ava.lang.Cloneable, 
j ava.util.Set 


//end FederateHandleSet 


DRDC Valcartier TR 2007-412 


197 



// File: FederateHandleSetFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getFederateHandleSetFactory getFederateHandleSetFactory} 
method. 

* Its one method creates a new {@link FederateHandleSet}, 

* to be loaded up and then passed to the (4.6) {@link 
RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint} method. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public interface 
FederateHandleSetFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link FederateHandleSet}, initially empty. 

* @return An empty <code>FederateHandleSet</code> 

*/ 

public FederateHandleSet 
create () ,- 

} 

//end FederateHandleSetFactory 


198 


DRDC Valcartier TR 2007-412 



// File: InteractionClassHandle.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Type-safe handle for an interaction class. Generally these are 
created by the RTI and passed to the federate. 

* <p> 

* They are obtained from the 

* (10.6) {@link RTIambassador#getInteractionClassHandle 
getInteractionClassHandle} 

* method and are used by a variety of other methods. 

* <p> 

* They can also be obtained by using the 

<code>InteractionClassHandleFactory</code>'s {@link 
ObjectClassHandleFactory#decode decode} method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
InteractionClassHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>InteractionClassHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 

j * * 

* Returns true iff <code>this</code> and 
<code>otherInteractionClassHandle</code> represent the same 
interaction class handle. 

* @param otherlnteractionClassHandle the <code>Object</code> to 
compare with 

* @return <code>true</code> iff supplied 
<code>otherInteractionClassHandle</code> is of type 
<code>InteractionClassHandle</code> and has same value 

*/ 

public boolean 

equals (Object otherlnteractionClassHandle) ; 

j * * 

* Returns a hash code for <code>this</code>; two 
<code>InteractionClassHandle</code>s for which <code>equals()</code> 
is <code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 


DRDC Valcartier TR 2007-412 


199 



* * 


* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>InteractionClassHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end InteractionClassHandle 


200 


DRDC Valcartier TR 2007-412 



// File: InteractionClassHandleFactory.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 
RTIambassador#getInteractionClassHandleFactory 
getInteractIonClassHandleFactory} method. 

* Its one method creates a new {@link InteractionClassHandle} from a 
supplied <code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
InteractionClassHandleFactory 
extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link InteractionClassHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of an <code>InteractionClassHandle</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>InteractionClassHandle</code> begins 

* @return An <code>InteractionClassHandle</code> constructed from 
the buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public InteractionClassHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember ,- 

} 

//end InteractionClassHandleFactory 


DRDC Valcartier TR 2007-412 


201 



// File: LogicalTime.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An interface to an immutable time value, 

* one of the four interfaces which the federate implements if it 
wishes to translate 

* the federation's logical times and logical time intervals into 
something meaningful for itself. 

* It is best if all federates in a given federation use the same 
implementations, but it is not strictly necessary. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see LogicalTimeFactory 
*/ 

public interface 
LogicalTime 

extends Comparable, 

j ava.io.Serializable 

{ 

j * * 

* Whether <code>this</code> is the "initial" logical time value or 
not (the smallest logical time possible). 

* @return <code>true</code> iff <code>this</code> is the initial 

time 

*/ 

public boolean 
islnitial () ,- 

j * * 

* Whether <code>this</code> is the "final" logical time value or 
not (the largest logical time possible). 

* @return <code>true</code> iff <code>this</code> is the final 

time 

*/ 

public boolean 
isFinal () ,- 

j * * 

* Returns a new <code>LogicalTime</code> whose value is 
<code>this</code> moved into the future by the <code>val 
LogicalTimeInterval</code>. 

* @param val a <code>LogicalTimeInterval</code> whose value is 
"added" to <code>this</code> value 

* @return The <code>LogicalTime</code> resulting from the addition 

* @throws IllegalTimeArithmetic if the result would be beyond the 
end time 

*/ 

public LogicalTime 

add(LogicalTimeInterval val) 

throws IllegalTimeArithmetic ,- 


202 


DRDC Valcartier TR 2007-412 



* * 


* Returns a new <code>LogicalTime</code> whose value is 
<code>this</code> moved into the past by the <code>val 
LogicalTimeIntervalc/code>. 

* @param val a <code>LogicalTimeInterval</code> whose value is 
"subtracted' 1 from <code>this</code> value 

* @return The <code>LogicalTime</code> resulting from the 
subtraction 

* @throws IllegalTimeArithmetic if the result would be before the 
start time 

*/ 

public LogicalTime 
subtract(LogicalTimelnterval val) 
throws IllegalTimeArithmetic; 


j * * 

* Returns a new <code>LogicalTimeInterval</code> whose value is 
the logical time interval separating <code>this</code> from 

<code>val</code>. 

* <p> 

* Although this is not clearly stated, the resulting logical time 
interval is a magnitude (that is, it cannot be negative). 

* Therefore, Itil.distance(It12) == lti2.distance(ltil) 

* @param val a <code>LogicalTime</code> whose value is compared 
with <code>this</code> value 

* @return The <code>LogicalTimeInterval</code> separating the two 
<code>LogicalTime</code>s 

*/ 

public LogicalTimelnterval 
distance (LogicalTime val) ,- 

// Comparable implementation. 

j * * 

* Compares <code>this</code> object with the specified 
<code>object</code> for order. 

* Later logical time is greater, earlier logical time is smaller. 

* <p> 

* Presumably throws java.lang.ClassCastException if the 
<code>other</code> is incommensurable. 

* @param other the <code>object</code> to compare 
<code>this</code> with 

* @return A negative, zero or positive integer if 
<code>this</code> object is less than, equal to or greater than the 
<code>other</code> 

*/ 

public int 

compareTo (Ob j ect other) ,- 

j * * 

* Returns a <code>String</code> representation of the 
<code>LogicalTime</code>. 

* @return A {@link java.lang.String} representation of 
<code>this</code> 

*/ 

public String 
toString () ,- 


DRDC Valcartier TR 2007-412 


203 



* * 


* Returns true iff <code>this</code> and <code>other</code> 
represent the same logical time. 

* @param other the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>other</code> is of 
the same type and has the same value 

*/ 

public boolean 
equals(Object other); 

j * * 

* Returns a hash code for <code>this</code>; two 
<code>LogicalTime</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>LogicalTime</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end LogicalTime 


204 


DRDC Valcartier TR 2007-412 



// File: LogicalTimeFactory.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* One of the four interfaces which the federate implements if it 
wishes to translate 

* the federation's logical times and logical time intervals into 
something meaningful for itself. 

* It is best if all federates in a given federation use the same 
implementations, but it is not strictly necessary. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
LogicalTimeFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link LogicalTime} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of a <code>LogicalTime</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>LogicalTime</code> begins 

* @return A <code>LogicalTime</code> constructed from the buffer's 
contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public LogicalTime 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode,- 


j * * 

* Creates a new {@link LogicalTime} of "initial" value (the 
smallest <code>LogicalTime</code> possible). 

* @return A <code>LogicalTime</code> of initial value 
*/ 

public LogicalTime 
makelnitial () ,- 

j * * 

* Creates a new {@link LogicalTime} of "final" value (the largest 
<code>LogicalTime</code> possible). 

* @return A <code>LogicalTime</code> of final value 
*/ 

public LogicalTime 
makeFinal () ,- 

} 

//end LogicalTimeFactory 


DRDC Valcartier TR 2007-412 


205 



// File: LogicalTimelnterval.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An interface to an immutable time interval value, 

* one of the four interfaces which the federate implements if it 
wishes to translate 

* the federation's logical times and logical time intervals into 
something meaningful for itself. 

* It is best if all federates in a given federation use the same 
implementations, but it is not strictly necessary. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see LogicalTimelntervalFactory 
*/ 

public interface 
LogicalTimelnterval 
extends Comparable, 

j ava.io.Serializable 

{ 

j * * 

* Whether <code>this</code> is the zero length logical time 
interval or not. 

* @return <code>true</code> iff <code>this</code> is of length 

zero 

*/ 

public boolean 
isZero () ,- 

j * * 

* Whether <code>this</code> is the epsilon length logical time 
interval or not (epsilon is the smallest non-zero logical time 
interval possible). 

* @return <code>true</code> iff <code>this</code> is of length 
epsilon 

*/ 

public boolean 
isEpsilon () ,- 

j * * 

* Returns a new <code>LogicalTimeInterval</code> whose value is 
<code>(this - subtrahend)</code>. 

* One instance of an <code>LogicalTimeInterval</code> may be 
subtracted from another, but not added. 

* <p> 

* Note that what happens when the <code>subtrahend</code> is 
larger than <code>this</code> isn't specified. 

* @param subtrahend a <code>LogicalTimeInterval</code> whose value 
is subtracted from <code>this</code> value 

* @return The <code>LogicalTimeInterval</code> resulting from the 
subtraction 

*/ 

public LogicalTimelnterval 

subtract (LogicalTimelnterval subtrahend) ,- 


206 


DRDC Valcartier TR 2007-412 



// Comparable implementation 


j k k 

* Compares <code>this</code> object with the specified 
<code>object</code> for order. 

* @param other the <code>object</code> to compare 
<code>this</code> with 

* @return A negative, zero or positive integer if 
<code>this</code> object is less than, equal to or greater than the 
<code>other</code> 

* @throws java.lang.ClassCastException if the <code>other</code> 
is incommensurable 

*/ 

public int 

compareTo (Ob j ect other) ,- 

j k k 

* Returns a <code>String</code> representation of the 
<code>LogicalTimeIntervale/code>. 

* @return A {@link java.lang.String} representation of 
<code>this</code> 

*/ 

public String 
toString () ,- 

j k k 

* Returns true iff <code>this</code> and <code>other</code> 
represent the same logical time interval. 

* @param other the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>other</code> is of 
the same type and has the same value 

*/ 

public boolean 
equals (Object other) ,- 

j k k 

* Returns a hash code for <code>this</code>; two 

<code>LogicalTimeIntervale/code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 

*/ 

public int 
hashCode () ,- 

j k k 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>LogicalTimeInterval</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength () ,- 


DRDC Valcartier TR 2007-412 


207 



* * 


* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end LogicalTimeInterval 


208 


DRDC Valcartier TR 2007-412 



// File: LogicalTimelntervalFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* One of the four interfaces which the federate implements if it 
wishes to translate 

* the federation's logical times and logical time intervals into 
something meaningful for itself. 

* It is best if all federates in a given federation use the same 
implementations, but it is not strictly necessary. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
LogicalTimelntervalFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link LogicalTimelnterval} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of a <code>LogicalTimeInterval</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>LogicalTimeInterval</code> begins 

* @return A <code>LogicalTimeInterval</code> constructed from the 
buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public LogicalTimelnterval 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode,- 


j * * 

* Creates a new {@link LogicalTimelnterval} of value zero. 

* @return A <code>LogicalTimeInterval</code> of value zero 
*/ 

public LogicalTimelnterval 
makeZero () ,- 

j * * 

* Creates a new {@link LogicalTimelnterval} of value epsilon, the 
smallest non-zero <code>LogicalTimeInterval</code> possible for this 
implementation. 

* @return A <code>LogicalTimeInterval</code> of value epsilon 
*/ 

public LogicalTimelnterval 
makeEpsilon () ,- 

} 

//end LogicalTimelntervalFactory 


DRDC Valcartier TR 2007-412 


209 



// File: MessageRetractionHandle.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* The user can do nothing with these but employ them as keys. 

* Implementers should provide <code>equals</code>, 

<code>hashCode</code> and <code>toString</code> 

* rather than settling for the defaults. 

* <p> 

* This object is used by the (8.21) {@link RTIambassador#retract 
retract} method. 

* <p> 

* It is also received by the (6.7) {@link 
FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle,Attribu 
teHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Order 
Type,MessageRetractionHandle)}, 

* {@link 

FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle, Attribu 
teHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Order 
Type,MessageRetractionHandle,RegionHandleSet) } , 

* (6.9) {@link 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,LogicalTime,OrderTy 
pe, MessageRetractionHandle) }, 

* {@link 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,LogicalTime,OrderTy 
pe,MessageRetractionHandle,RegionHandleSet)} 

* (6.11) {@link 

FederateAmbassador#removeObjectInstance(Obj ectInstanceHandle,byte[] ,Or 
derType,LogicalTime,OrderType,MessageRetractionHandle)} and 

* (8.22) {@link FederateAmbassador#requestRetraction 

requestRetraction} 

* callbacks. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
MessageRetractionHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>MessageRetractionHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () ,- 


210 


DRDC Valcartier TR 2007-412 



* Returns true iff <code>this</code> and 
<code>otherMRHandle</code> represent the same message retraction 
handle. 

* @param otherMRHandle The <code>Object</code> to compare with 

* @return true iff supplied <code>otherMRHandle</code> is of type 
<code>MessageRetractionHandle</code> and has same value 

*/ 

public boolean 

equals(Object otherMRHandle); 

j * * 

* Returns a hash code for <code>this</code>; two 
<code>MessageRetractionHandle</code>s for which <code>equals()</code> 
is <code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

} 

//end MessageRetractionHandle 


DRDC Valcartier TR 2007-412 


211 



The MessageRetractionReturn class, unlike the similar TimeQueryReturn class 
and the other IEEE 1516 object classes, does not override the obj ect-inherited 
tost ring, equals and hashcode methods. On the assumption that this is an 
unfortunate oversight, commented-out implementations are provided here. 


// File: MessageRetractionReturn.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Record returned by the (6.6) {@link 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime)} , 

* (6.8/9.12) {@link 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[],LogicalTime)} {@link 

RTIambassador#sendInteractionWithRegions(InteractionClassHandle,Parame 
terHandleValueMap,RegionHandleSet,byte[ ] ,LogicalTime) [WithRegions] } 
and 

* (6.10) {@link 

RTIambassador#deleteObj ectInstance(Obj ectInstanceHandle,byte[] ,Logical 
Time)} methods. 

* It consists of a guard boolean 

(<code>retractionHandleIsValid</code>) and a payload {@link 
MessageRetractionHandle} (<code>handle</code>). 

* The latter, if valid, may be used with the (8.21) {@link 
RTIambassador#retract retract} method. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds the 

java.io.Serializable implementation and a constructor. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
MessageRetractionReturn 

implements j ava.io.Serializable 

{ 

j * * 

* Whether the other field is valid or not. 

*/ 

public boolean 
retractionHandlelsValid; 

j * * 

* Payload Message Retraction Handle field. 

*/ 

public MessageRetractionHandle 
handle ,- 


212 


DRDC Valcartier TR 2007-412 



* * 


* Public constructor. 

* @param rhiv Whether the {@link MessageRetractionHandle} field is 
valid or not 

* @param mrh The <code>MessageRetractionHandle</code> field 
*/ 

public 

MessageRetractionReturn(boolean rhiv, 

MessageRetractionHandle mrh) 

{ 

retractionHandlelsValid = rhiv; 
handle = mrh; 


j * * 

* Returns a <code>String</code> representation of the 
<code>MessageRetractionReturn</code>. 

* <p> 

* Strangely missing from 1516.1.5 (DoDv2) 

* @return A {@link java.lang.String} with value 
" &lt;retractionHandlelsValid&gt; &lt;handle&gt;" 

*/ 

// public String 
// toStringO 

// { 

// return retractionHandlelsValid + " " + handle; 

// } 


DRDC Valcartier TR 2007-412 


213 



* * 


* Returns true iff <code>this</code> and <code>other</code> 
represent the same message retraction return. 

* <p> 

* Strangely missing from 1516.1.5 (DoDv2) 

* @param other The <code>Object</code> to compare with 

* @return true iff supplied <code>other</code> is of type 
<code>MessageRetractionReturn</code> and has same value 

*/ 

// public boolean 
// equals(Object other) 

// { 

// if (other instanceof MessageRetractionReturn) 

// { 

// MessageRetractionReturn mrrOther = 

(MessageRetractionReturn)other,- 

// if ((retractionHandlelsValid == false) && 

(mrrOther.retractionHandlelsValid == false)) 

// { 

//When retractionHandlelsValid is false, the payloads are 

ignored 

// return true; 

// } 

// else if ((retractionHandlelsValid == true) && 

(mrrOther.retractionHandlelsValid == true)) 

{ 

//When retractionHandlelsValid is true, the payloads must 
return handle . equals (mrrOther . handle) ,- 

} 

else 

{ 

//mismatched retractionHandlelsValid fields 
return false; 


else 

{ 

//Not the same classes 
return false,- 


j * * 

* Returns a hash code for <code>this</code>; two 

<code>MessageRetractionReturnc/code>s for which <code>equals()</code> 
is <code>true</code> should yield the same hash code. 

* <p> 

* Strangely missing from 1516.1.5 (DoDv2) 

* @return An <code>int</code> hash code 
*/ 

// public int 
// hashCode() 

// { 

// return (retractionHandleValid ? handle.hashCode() : 7); 



//end MessageRetractionReturn 


214 


DRDC Valcartier TR 2007-412 



// File: MobileFederateServices.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Conveys the interfaces for all services that a federate 

* must supply and which may not execute in the federate's space. 

* This is used by the (4.4) {@link 

RTIambassador#]oinFederationExecution j oinFederationExecution} method. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds the 
j ava.io.Serializable implementation. 

* <p> 

* The Java API is the only one which refers to the {@link 
LogicalTimeFactory} and {@link LogicalTimeIntervalFactory} 

* instances being passed to the <code>joinFederationExecution</code> 
method as "Mobile Federate Services" (Ada and C++ 

* simply pass the instances as separate parameters). It is not clear 
either what is meant by "which may 

* not execute" -does it mean they're not allowed to execute in the 
federate's space, or does it mean 

* they could be invoked outside of its space? The latter seems more 
likely. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
MobileFederateServices 

implements j ava.io.Serializable 

{ 

j * * 

* The <code>LogicalTimeFactory</code> reference. 

*/ 

public LogicalTimeFactory 
_t imeFactory; 

j * * 

* The <code>LogicalTimeIntervalFactory</code> reference. 

*/ 

public LogicalTimeIntervalFactory 
_intervalFactory; 


DRDC Valcartier TR 2007-412 


215 



* * 


* Public constructor. 

* @param timeFactory An implementation of {@link 
LogicalTimeFactory} 

* @param intervalFactory An implementation of {@link 
Log!calTimeIntervalFactory} 

*/ 

public MobileFederateServices( 

LogicalTimeFactory timeFactory, 

Log!calTimeIntervalFactory intervalFactory) 

{ 

_timeFactory = timeFactory; 

_intervalFactory = intervalFactory; 


//end MobileFederateServices 


216 


DRDC Valcartier TR 2007-412 



// File: ObjectClassHandle.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Type-safe handle for an object class. Generally these are created 
by the RTI and passed to the federate. 

* <p> 

* They are obtained from the (10.2) {@link 
RTIambassador#getObjectClassHandle getObj ectClassHandle} and 

* (10.16) {@link RTIambassador#getKnownObjectClassHandle 

getKnownObj ectClassHandle} 

* methods and are used by a variety of other methods. 

* <p> 

* They can also be obtained by using the 
<code>Obj ectClassHandleFactory</code>'s {@link 
Obj ectClassHandleFactory#decode decode} 

* method on a <code>byte[]</code> received as part of an attribute 
update or interaction. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
Obj ectClassHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>Obj ectClassHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 

j * * 

* Returns true iff <code>this</code> and 

<code>otherObjectClassHandle</code> represent the same object class 
handle. 

* @param otherObjectClassHandle the <code>Object</code> to compare 

with 

* @return <code>true</code> iff supplied 
<code>otherObjectClassHandle</code> is of type 
<code>ObjectClassHandle</code> and has same value 

*/ 

public boolean 

equals (Object otherObjectClassHandle); 

j * * 

* Returns a hash code for <code>this</code>; two 

<code>ObjectClassHandle</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 


DRDC Valcartier TR 2007-412 


217 



* * 


* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>Obj ectClassHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end Obj ectClassHandle 


218 


DRDC Valcartier TR 2007-412 



// File: Obj ectClassHandleFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getObjectClassHandleFactory getObjectClassHandleFactory} 
method. 

* Its one method creates a new {@link ObjectClassHandle} from a 
supplied <code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 

Obj ectClassHandleFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link ObjectClassHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of an <code>ObjectClassHandle</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>ObjectClassHandle</code> begins 

* @return An <code>ObjectClassHandle</code> constructed from the 
buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public Obj ectClassHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember ,- 

} 

//end Obj ectClassHandleFactory 


DRDC Valcartier TR 2007-412 


219 



// File: Obj ectInstanceHandle.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Type-safe handle for an object instance. Generally these are 
created by the RTI and passed to the federate. 

* <p> 

* They are obtained from the 

* (6.4/9.5) {@link RTIambassador#registerObjectlnstance 
registerObj ectlnstance} {@link 

RTIambassador#registerObj ectlnstanceWithRegions [WithRegions] } (all 
forms) and 

* (10.10) {@link RTIambassador#getObjectInstanceHandle 

getObjectInstanceHandle} methods and are used by a variety of other 
methods. 

* <p> 

* They can also be obtained by using the 
<code>Obj ectInstanceHandleFactory</code>'s {@link 

ObjectInstanceHandleFactory#decode decode} method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
Obj ectInstanceHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>Obj ectInstanceHandlec/code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 

j * * 

* Returns true iff <code>this</code> and 
<code>otherObjectInstanceHandle</code> represent the same object 
instance handle. 

* @param otherObjectlnstanceHandle the <code>Object</code> to 
compare with 

* @return <code>true</code> iff supplied 
<code>otherObjectInstanceHandle</code> is of type 
<code>ObjectInstanceHandle</code> and has same value 

*/ 

public boolean 

equals(Object otherObjectlnstanceHandle); 


220 


DRDC Valcartier TR 2007-412 



* * 


* Returns a hash code for <code>this</code>; two 

<code>ObjectInstanceHandle</code>s for which <code>equals ()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>Obj ectInstanceHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end Obj ectInstanceHandle 


DRDC Valcartier TR 2007-412 


221 



// File: Obj ectInstanceHandleFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 
RTIambassador#getObjectInstanceHandleFactory 
getObj ectInstanceHandleFactory} method. 

* Its one method creates a new {@link ObjectInstanceHandle} from a 
supplied <code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 

Obj ectInstanceHandleFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link ObjectInstanceHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of an <code>Obj ectInstanceHandlec/code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>ObjectInstanceHandle</code> begins 

* @return An <code>ObjectInstanceHandle</code> constructed from 
the buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public Obj ectInstanceHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember; 

} 

//end Obj ectInstanceHandleFactory 


222 


DRDC Valcartier TR 2007-412 



// File: OrderType.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the RTI-provided means of ordering messages 
originating from multiple joined federates that are delivered to a 
single joined federate. 

* Different categories of service are defined with different 
characteristics regarding whether and how an RTI orders messages that 
are to be delivered to a joined federate. 

* Ordering Type defaults are defined at the attribute and parameter 
level by the FOM Document Data; these may be overridden by their 
owners. 

* The two OrderTypes are: 

* <ul > 

* <li><code>RECEIVE</code>: Messages are in an arbitrary order but 
the general policy is "as soon as possible". 

* <li><code>TIMESTAMP</code>: An effort is made to deliver time- 
stamped messages in order of increasing time-stamps 

* </ul> 

* Unlike {@link TransportationType}, the standard does not allow 
specific RTIs to define additional OrderTypes. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
OrderType 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of an <code>OrderType</code> must be 
initialized with one of the defined static values. 

* @param otherOrderTypeValue must be a defined static value or 
another instance. 

*/ 

public OrderType(OrderType otherOrderTypeValue) 

{ 

_value = otherOrderTypeValue._value; 


DRDC Valcartier TR 2007-412 


223 



* * 


* Package-only (default access) constructor. Used by the {@link 
#decode decode} method. 

* @param value an <code>int</code> to assign to the instance; must 
be one of the static values 

*/ 

OrderType(int value) 

throws RTIinternalError 

{ 

_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError("OrderType: illegal value " + 

value) ; 


j * * 

* Private constructor; it is used to generate the static values. 

*/ 

private OrderType() 

{ 

_value = _nextToAssign++; 


j * * 

* Returns a <code>String</code> representation of the 
<code>OrderType</code>. 

* @return A {@link j ava . lang. String} with value "OrderType (n) 11 
where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "OrderType(" + _value + ")"; 


j * * 

* Returns true iff <code>this</code> and 
<code>otherOrderTypeValue</code> represent the same order type. 

* @param otherOrderTypeValue the <code>Object</code> to compare 

with 

* @return <code>true</code> iff supplied 
<code>otherOrderTypeValue</code> is of type <code>OrderType</code> and 
has same value 

*/ 

public boolean 

equals(Object otherOrderTypeValue) 

{ 

if (otherOrderTypeValue instanceof OrderType) 

return _value == ((OrderType)otherOrderTypeValue)._value; 
else 

return false; 


224 


DRDC Valcartier TR 2007-412 



* * 


* Returns a hash code for <code>this</code>; two 
<code>OrderType</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return _value; 


* Returns the 
representation of 

* @return The 
representation of 

*/ 

public int 
encodedLength() 


length (in bytes) of the <code>byte[]</code> 
the <code>OrderTypec/code>. 

length (in bytes) of the <code>byte[]</code> 
<code>this</code> 


return 1; 


j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset) 

{ 

buffer[offset] = (byte)_value; 


DRDC Valcartier TR 2007-412 


225 



* * 


* Creates an <code>OrderType</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>OrderType</code> 

* @param offset where in the <code>buffer</code> the 
<code>OrderType</code> representation begins 

* @return The <code>OrderType</code> that was encoded in the 
provided <code>buffer</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

*/ 

public static OrderType 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

int val = buffer[offset] ; 

OrderType neo; 
try 


neo = new OrderType(val); 

} 

catch (RTIinternalError e) 

{ 

throw new CouldNotDecode(e.getMessage()); 

} 

return neo; 


226 


DRDC Valcartier TR 2007-412 



//The constant instances 

j * * 

* Receive Order (RO). 

* A characteristic of no ordering guarantee for messages. 

* RECEIVE messages will be received in an arbitrary order by the 
respective joined federate. 

* A time stamp value will be provided with the message if one was 
specified when the message was sent, 

* but that time stamp has no bearing on message receipt order. 

*/ 

static public final OrderType 
RECEIVE = new OrderType(); 

j * * 

* Time Stamp Order (TSO). 

* An ordering of messages provided by the runtime infrastructure 
(RTI) for joined federates 

* making use of time management services and messages containing 
time stamps. 

* TIMESTAMP messages are said to be delivered in TSO if, for any 
two messages Ml and M2 

* (time stamped with T1 and T2, respectively) that are delivered 
to a single joined federate 

* and where T1 < T2, then Ml is delivered before M2 (in real 
time) . 

* Messages having the same time stamp will be delivered in an 
arbitrary order 

* (i.e., no tie-breaking mechanism is provided by the RTI). 

*/ 

static public final OrderType 
TIMESTAMP = new OrderType (),- 

} 

//end OrderType 


DRDC Valcartier TR 2007-412 


227 



// File: ParameterHandle.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Type-safe handle for a parameter. Generally these are created by 
the RTI and passed to the federate. 

* <p> 

* They are obtained from the 

* (10.8) {@link RTIambassador#getParameterHandle getParameterHandle} 
when preparing a {@link ParameterHandleValueMap} 

* for transmission through the (6.8) {@link 
RTIambassador#sendInteraction sendlnteraction} (all forms) method. 

* <p> 

* They can also be obtained directly from the 
<code>ParameterHandleValueMap</code> received by the (6.9) {@link 
FederateAmbassador#receiveInteraction receiveInteraction} (all forms) 

* or indirectly by using the <code>ParameterHandleFactory</code>'s 
{@link ParameterHandleFactory#decode decode} method on a 

<code>ParameterHandleValueMapc/code>'s values 

* or even a (6.7) {@link FederateAmbassador#reflectAttributeValues 
reflectAttributeValues} (all forms) callback's {@link 
AttributeHandleValueMap}'s values. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
ParameterHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>ParameterHandle</code>. 

* @return A {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString(); 

j * * 

* Returns true iff <code>this</code> and 
<code>otherParameterHandle</code> represent the same parameter handle. 

* Note that two handles may be equals but still refer to different 
parameters if used in different interaction class contexts. 

* @param otherParameterHandle the <code>Object</code> to compare 

with 

* @return <code>true</code> iff supplied 
<code>otherParameterHandle</code> is of type 
<code>ParameterHandle</code> and has same value 

*/ 

public boolean 

equals(Object otherParameterHandle); 


228 


DRDC Valcartier TR 2007-412 



* * 


* Returns a hash code for <code>this</code>; two 
<code>ParameterHandle</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of the <code>ParameterHandle</code>. 

* @return The length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength(); 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset); 

} 

//end ParameterHandle 


DRDC Valcartier TR 2007-412 


229 



// File: ParameterHandleFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getParameterHandleFactory getParameterHandleFactory} 
method. 

* Its one method creates a new {@link ParameterHandle} from a 
supplied <code>byte[]</code> representation, 

* itself received as an attribute or parameter value. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
ParameterHandleFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link ParameterHandle} from the supplied 
<code>byte[]</code> representation. 

* @param buffer A <code>byte[]</code> containing a representation 
of a <code>ParameterHandle</code> 

* @param offset Offset into the <code>buffer</code> at which the 
representation of the <code>ParameterHandle</code> begins 

* @return A <code>ParameterHandle</code> constructed from the 
buffer's contents 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public ParameterHandle 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode, 

FederateNotExecutionMember; 

} 

//end ParameterHandleFactory 


230 


DRDC Valcartier TR 2007-412 



// File: ParameterHandleValueMap.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Object used to transmit the set of parameters and their values 
involved in an interaction. 

* Keys are {@link ParameterHandle}s; values are byte[]. 

* All {@link java.util.Map} operations are required, none optional. 

* Null mappings are not allowed. 

* <code>put()</code>, <code>putAll()</code>, and 

<code>remove()</code> should throw {@link IllegalArgumentException} 

* to enforce types of keys ({@link ParameterHandle}) and mappings 
(<code>byte[]</code>). 

* <p> 

* Sent by the 

* (6.8/9.12) {@link RTIambassador#sendInteraction sendlnteraction} 
{@link RTIambassador#sendInteractionWithRegions [WithRegions]} (all 
forms) method. 

* Received by the (6.9) {@link FederateAmbassador#receiveInteraction 
receivelnteraction} callback (all forms). 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see ParameterHandleValueMapFactory 
*/ 

public interface 
ParameterHandleValueMap 

extends j ava.lang.Cloneable, 
j ava.util.Map, 
j ava.io.Serializable 


//end ParameterHandleValueMap 


DRDC Valcartier TR 2007-412 


231 



// File: ParameterHandleValueMapFactory.j ava 

package hla.rtil516; //the package name was changed by DoD 

Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getParameterHandleValueMapFactory 
getParameterHandleValueMapFactory} method. 

* Its one method simply creates a new {@link ParameterHandleValueMap} 
obj ect. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public interface 
ParameterHandleValueMapFactory 
extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link ParameterHandleValueMap} instance with the 
specified initial capacity. 

* @param capacity Initial capacity (number of keys) of the 
<code>ParameterHandleValueMapc/code> 

* @return A newly created <code>ParameterHandleValueMap</code> 

*/ 

public ParameterHandleValueMap 
create(int capacity); 

} 

//end ParameterHandleValueMapFactory 


232 


DRDC Valcartier TR 2007-412 



// File: RangeBounds.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Record returned by the (10.31) {@link RTIambassador#getRangeBounds 
getRangeBounds} method 

* and supplied to its (10.32) {@link RTIambassador#setRangeBounds 
setRangeBounds} method. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds the 

java.io.Serializable implementation and a constructor. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
RangeBounds 

implements j ava.io.Serializable 

{ 

j * * 

* Lower (included) bound of the range. 

*/ 

public long lower; 

j * * 

* Upper (excluded) bound of the range. 

*/ 

public long upper; 

j * * 

* Public constructor. 

* @param 1 The range's lower bound (included) 

* @param u The range's upper bound (excluded) 

*/ 

public RangeBounds(long 1, 

long u) 


lower = 1; 
upper = u; 


DRDC Valcartier TR 2007-412 


233 



* * 


* Returns true iff <code>this</code> and <code>other</code> 
represent the same set of bounds. 

* @param other The <code>Object</code> to compare with 

* @return true iff supplied <code>other</code> is of type 
<code>RangeBounds</code> and has same values 

*/ 

public boolean 
equals(Object other) 

{ 

if ((other != null) && (other instanceof RangeBounds)) 

{ 

RangeBounds otherRangeBounds = (RangeBounds)other; 
return (lower == otherRangeBounds.lower) && (upper == 
otherRangeBounds.upper); 

} 

else 

{ 

return false; 


j * * 

* Returns a hash code for <code>this</code>; two 
<code>RangeBounds</code> for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return (int)(lower + upper); 


//end RangeBounds 


234 


DRDC Valcartier TR 2007-412 



// File: RegionHandle.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* A designator for an RTI <code>Region</code> object. 

* <p> 

* A <b>region specification</b> is a set of <code>Range</code>s, each 
one of which is a continuous semi-open interval (defined by an 
included lower bound and an excluded upper bound) on a different 
<code>Dimension</code>. 

* A <b>region realization</b> is a region specification that is 
associated with an instance attribute for update, with a sent 
interaction, or with a class attribute or interaction class for 
subscription. 

* The specification and realization may differ when a default range 
is specified for a dimension in the FOM Document Data (FDD), since if 
that dimension is not mentioned in the region specification, its 
default range is implicitly added to the region realization. 

* <p> 

* Region specifications are created, committed and deleted by the 

* (9.2) {@link RTIambassador#createRegion createRegion}, 

* (9.3) {@link RTIambassador#commitRegionModifications 
commitRegionModifications} and 

* (9.4) {@link RTIambassador#deleteRegion deleteRegion} methods. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface 
RegionHandle 

extends j ava.io.Serializable 

{ 

j * * 

* Returns a <code>String</code> representation of the 
<code>RegionHandle</code>. 

* @return A {@link java.lang.String} with value reflecting 
<code>this</code> 

*/ 

public String 
toString () ,- 

j * * 

* Returns true iff <code>this</code> and 
<code>otherRegionHandle</code> refer to the same Region. 

* @param otherRegionHandle The <code>Object</code> to compare with 

* @return true iff supplied <code>otherRegionHandle</code> is of 
type <code>RegionHandle</code> and has same value 

*/ 

public boolean 

equals (Object otherRegionHandle) ,- 


DRDC Valcartier TR 2007-412 


235 



* * 


* Returns a hash code for <code>this</code>; two 
<code>RegionHandle</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code 

* (because they then refer to the same Region). 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode(); 

} 

//end RegionHandle 


236 


DRDC Valcartier TR 2007-412 



// File: RegionHandleSet.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* A Set of {@link RegionHandle}s. 

* All {@link java.util.Set} operations are required, none are 
optional. 

* <code>add()</code> and <code>remove()</code> should throw {@link 
IllegalArgumentException} if the argument is not a 
<code>RegionHandle</code>. 

* <code>addAll()</code>, <code>removeAll()</code> and 
<code>retainAll()</code> should throw 
<code>IllegalArgumentException</code> if 

* the argument is not a <code>RegionHandleSet</code>. 

* <p> 

* Used with the (9.3) {@link RTIambassador#commitRegionModifications 
commitRegionModifications}, 

* (9.10/9.11) {@link 

RTIambassador#unsubscribeInteractionClassWithRegions [un]} {@link 
RTIambassador#subscribeInteractionClassWithRegions 
subscribeInteractionClassWithRegions} {@link 
RTIambassador#subscribeInteractionClassPassivelyWithRegions 
[Passively]} and 

* (9.12) {@link RTIambassador#sendInteractionWithRegions 
sendlnteractionWithRegions} (both forms) methods. 

* <p> 

* Also received by certain forms of the (6.7) {@link 
FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle,Attribu 
teHandleValueMap,byte[] ,OrderType,TransportationType,RegionHandleSet) } 

* and (6.9) {@link 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,RegionHandleSet)} 

* callbacks if the Convey Region Designator Sets Switch is turned on 
(this is done through the 

* <code>HLAmanager.HLAfederate.HLAadj ust.HLAsetSwitches</code> 
Management Object Model (MOM) interaction: there is no special API for 
it) . 

* These conveyed sets of <code>RegionHandle</code>s can be used with 
the 

* (10.31) {@link RTIambassador#getRangeBounds getRangeBounds} and 

* (10.30) j@link RTIambassador#getDimensionHandleSet 
getDimensionHandleSet} methods. 

* All other RTIambassador <code>RegionHandle</code> methods expect a 
federate-owned <code>Region</code>. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see RegionHandleSetFactory 
*/ 

public interface 
RegionHandleSet 

extends j ava.lang.Cloneable, 
j ava.io.Serializable, 
j ava.util.Set 


//end RegionHandleSet 


DRDC Valcartier TR 2007-412 


237 



// File: RegionHandleSetFactory.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Interface corresponding to the {@link 

RTIambassador#getRegionHandleSetFactory getRegionHandleSetFactory} 
method. 

* Its one method simply creates a new {@link RegionHandleSet} object. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public interface 
RegionHandleSetFactory 

extends j ava.io.Serializable 

{ 

j * * 

* Creates a new {@link RegionHandleSet} instance. 

* @return A newly created <code>RegionHandleSet</code> 

*/ 

public RegionHandleSet 
create(); 

} 

//end RegionHandleSetFactory 


238 


DRDC Valcartier TR 2007-412 



// File: ResignAction.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the resign policy adopted by the federate. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see hla.rtil516.RTIambassador#resignFederationExecution 
resignFederationExecution 

*/ 

public final class 
ResignAction 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a ResignAction must be initialized 
with one of the defined static values. 

* @param otherResignActionValue must be a defined static value or 
another instance. 

*/ 

public 

ResignAction(ResignAction otherResignActionValue) 

{ 

_value = otherResignActionValue._value; 


j * * 

* Package-only (default access) constructor. Unused. 

* @param value to assign to the instance; must be one of the 
static ones 

*/ 

ResignAction(int value) 

throws RTIinternalError 

{ 

_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError("ResignAction: illegal value " + 

value); 


DRDC Valcartier TR 2007-412 


239 



j k k 

* Private constructor; it is used to generate the static values. 

*/ 

private 
ResignAction() 

{ 

_value = _nextToAssign++; 


j k k 

* Returns a <code>String</code> representation of the 
<code>ResignAction</code>. 

* @return A {@link java.lang.String} with value "ResignAction(n)" 
where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "ResignAction(" + _value + ")"; 


j k k 

* Returns true iff <code>this</code> and 
<code>otherResignActionValue</code> represent the same resign action. 

* @param otherResignActionValue The <code>Object</code> to compare 

with 

* @return true iff supplied <code>otherResignActionValue</code> is 
of type <code>ResignAction</code> and has same value 

*/ 

public boolean 

equals(Object otherResignActionValue) 

{ 

if (otherResignActionValue instanceof ResignAction) 
return _value == 

((ResignAction)otherResignActionValue)._value; 
else 

return false; 


j k k 

* Returns a hash code for <code>this</code>; two 
<code>ResignAction</code>s for which <code>equals() </code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return value; 


240 


DRDC Valcartier TR 2007-412 



//The constant instances 

j * * 

* Unconditionally divest ownership of all owned instance 
attributes. 

*/ 

static public final ResignAction 

UNCONDITIONALLY_DIVEST_ATTRIBUTES = new ResignAction() ; 

j * * 

* Delete all object instances for which the joined federate has 
the delete privilege. 

*/ 

static public final ResignAction 
DELETE_OBJECTS = new ResignAction(); 

j * * 

* Cancel all pending instance attribute ownership acquisitions. 

*/ 

static public final ResignAction 

CANCEL_PENDING_OWNERSHIP_ACQUISITIONS = new ResignAction(); 

j * * 

* Perform DELETE_OBJECTS and then 
UNCONDITIONALLY_DIVEST_ATTRIBUTES. 

*/ 

static public final ResignAction 

DELETE_OBJECTS_THEN_DIVEST = new ResignAction(); 

j * * 

* Perform CANCEL_PENDING_OWNERSHIP_ACQUISITIONS, then 
DELETE_OBJECTS and then UNCONDITIONALLY_DIVEST_ATTRIBUTES. 

*/ 

static public final ResignAction 

CANCEL_THEN_DELETE_THEN_DIVEST = new ResignAction(); 

j * * 

* Perform no actions. 

*/ 

static public final ResignAction 
NO_ACTION = new ResignAction(); 

} 

//end ResignAction 


DRDC Valcartier TR 2007-412 


241 



// File : RestoreFailureReason.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the reason why the restore operation of a federate 
failed. 

* It is reported by the {@link 

FederateAmbassador#federationNotRestored federationNotRestored} 
callback. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see hla.rtil516.FederateAmbassador#federationNotRestored 
federationNotRestored 

*/ 

public final class 
RestoreFailureReason 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a RestoreFailureReason must be 
initialized with one of the defined static values. 

* <p> 

* Here we change the parameter name from "otherResignActionValue" 
to "reason"; 

* this is similar to the change DoD Interpretations of IEEE 1516- 
2000v2 applies 

* to the {@link SynchronizationPointFailureReason} constructor. 

* @param reason must be a defined static value or another 
instance. 

*/ 

public 

RestoreFailureReason(RestoreFailureReason reason) 

{ 

_value = reason._value; 


242 


DRDC Valcartier TR 2007-412 



* * 


* Package-only (default access) constructor. Unused. 

* @param value to assign to the instance; must be one of the 
static ones 

*/ 

RestoreFailureReason(int value) 
throws RTIinternalError 

{ 

_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError("RestoreFailureReason: illegal 
value " + value); 


j * * 

* Private constructor; it is used to generate the static values. 

*/ 

private 

RestoreFailureReason () 

{ 

_value = _nextToAssign++; 


j * * 

* Returns a <code>String</code> representation of the 
<code>RestoreFailureReason</code>. 

* @return A {@link java.lang.String} with value 
"RestoreFailureReason(n)" where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "RestoreFailureReason(" + _value + ")"; 


DRDC Valcartier TR 2007-412 


243 



* * 


* Returns true iff <code>this</code> and 
<code>otherRestoreFailureReasonValue</code> represent the same restore 
failure reason. 

* <p> 

* Here we change the parameter name from "otherResignActionValue" 
to "otherRestoreFailureReasonValue"; 

* this follows the same rationale as the change DoD 
Interpretations of IEEE 1516-2000v2 applies 

* to the {@link SynchronizationPointFailureReason} constructor. 

* @param otherRestoreFailureReasonValue The <code>Object</code> to 
compare with 

* @return true iff supplied 

<code>otherRestoreFailureReasonValue</code> is of type 
<code>RestoreFailureReason</code> and has same value 
*/ 

public boolean 

equals(Object otherRestoreFailureReasonValue) 

{ 

if (otherRestoreFailureReasonValue instanceof 
RestoreFailureReason) 

return _value == 

((RestoreFailureReason)otherRestoreFailureReasonValue)._value; 
else 

return false; 


j * * 

* Returns a hash code for <code>this</code>; two 
<code>RestoreFailureReason</code>s for which <code>equals() </code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return value; 


244 


DRDC Valcartier TR 2007-412 



//The constant instances 

j * * 

* The RTI was unable to restore. 

*/ 

static public final RestoreFailureReason 
RTI_UNABLE_TO_RESTORE = new RestoreFailureReason(); 

j * * 

* One or more federates have invoked the {@link 

RTIambassador#federateRestoreNotComplete federateRestoreNotComplete} 
method. 

*/ 

static public final RestoreFailureReason 

FEDERATE_REPORTED_FAILURE = new RestoreFailureReason(); 

j * * 

* One or more joined federates have resigned from the federation 
execution. 

*/ 

static public final RestoreFailureReason 

FEDERATE_RESIGNED = new RestoreFailureReason(); 

j * * 

* The RTI has detected failure at one or more of the joined 
federates. 

*/ 

static public final RestoreFailureReason 
RTI_DETECTED_FAILURE = new RestoreFailureReason(); 

} 

//end RestoreFailureReason 


DRDC Valcartier TR 2007-412 


245 



// File: RestoreStatus.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the restore status of a federate during a federation 
restore operation. 

* It is contained in the {@link FederateHandleRestoreStatusPair} [] 
argument of the {@link 

FederateAmbassador#federationRestoreStatusResponse 
federationRestoreStatusResponse} callback. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
RestoreStatus 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a RestoreStatus must be 
initialized with one of the defined static values. 

* @param otherRestoreStatusValue must be a defined static value or 
another instance. 

*/ 

public RestoreStatus(RestoreStatus otherRestoreStatusValue) 

{ 

_value = otherRestoreStatusValue._value; 


j * * 

* Package-only (default access) constructor. Unused. 

* @param value to assign to the instance; must be one of the 
static ones 

*/ 

RestoreStatus(int value) 
throws RTIinternalError 

{ 

_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError("RestoreStatus: illegal value " + 

value) ; 


246 


DRDC Valcartier TR 2007-412 



j k k 

* Private constructor; it is used to generate the static values. 

*/ 

private RestoreStatus () 

{ 

_value = _nextToAssign++; 


j k k 

* Returns a <code>String</code> representation of the 
<code>RestoreStatus</code>. 

* @return A {@link java.lang.String} with value "RestoreStatus(n)" 
where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "RestoreStatus(" + value + ")"; 


j k k 

* Returns true iff <code>this</code> and 
<code>otherRestoreStatusValue</code> represent the same restore 
status. 

* @param otherRestoreStatusValue The <code>Object</code> to 
compare with 

* @return true iff supplied <code>other</code> is of type 
<code>RestoreStatus</code> and has same value 

*/ 

public boolean 

equals (Object otherRestoreStatusValue) 

{ 

if (otherRestoreStatusValue instanceof RestoreStatus) 
return _value == 

((RestoreStatus)otherRestoreStatusValue)._value; 
else 

return false; 


j k k 

* Returns a hash code for <code>this</code>; two 
<code>RestoreStatus</code>es for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return _value; 


DRDC Valcartier TR 2007-412 


247 



//The constant instances 

j * * 

* No restore in progress (federate in the Active state). 

*/ 

static public final RestoreStatus 
NO_RESTORE_IN_PROGRESS = new RestoreStatus(); 

j * * 

* Federate in the Restore Request Pending state. 

*/ 

static public final RestoreStatus 

FEDERATE_RESTORE_REQUEST_PENDING = new RestoreStatus(); 

j * * 

* Federate in the Waiting For Restore To Begin state. 

*/ 

static public final RestoreStatus 

FEDERATE_WAITING_FOR_RESTORE_TO_BEGIN = new RestoreStatus(); 

j * * 

* Federate in the Prepared To Restore state. 

*/ 

static public final RestoreStatus 

FEDERATE_PREPARED_TO_RESTORE = new RestoreStatus() ; 

j * * 

* Federate in the Restoring state. 

*/ 

static public final RestoreStatus 
FEDERATE_RESTORING = new RestoreStatus(); 

j * * 

* Federate in the Waiting For Federation To Restore state. 

*/ 

static public final RestoreStatus 

FEDERATE_WAITING_FOR_FEDERATION_TO_RESTORE = new RestoreStatus(); 

} 

//end RestoreStatus 


248 


DRDC Valcartier TR 2007-412 



// File: RTIambassador.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Memory Management Conventions for Parameters 

* 

* All Java parameters, including object references, are passed by 
value. 

* Therefore there is no need to specify further conventions for 
primitive types. 

* Unless otherwise noted, reference parameters adhere to the 
following convention: 

* The referenced object is created (or acquired) by the caller. The 
callee must 

* copy during the call anything it wishes to save beyond the 
completion of the 

* call. 

* Unless otherwise noted, a reference returned from a method 
represents a new 

* object created by the callee. The caller is free to modify the 
object whose 

* reference is returned. 

*/ 


DRDC Valcartier TR 2007-412 


249 



* The RTI presents this interface to the federate. 

* The RTI implementer must implement this. 

* <p> 

* As of DoD Interpretations of IEEE 1516-2000v2, none of the 
RTIambassador methods may be called 

* with a <code>null</code> argument, with two exceptions: user- 
supplied <code>tag</code> arguments may be <code>null</code>, 

* and the {@link MobileFederateServices} argument of the {@link 
#joinFederationExecution joinFederationExecution} service 

* may be <code>null</code> (in the case where the federate does not 
wish to supply the {@link LogicalTimeFactory} and {@link 
LogicalTimelntervalFactory}) . 

* With the noted exceptions, if a <code>null</code> argument is 
supplied, the RTI will throw a {@link java.lang.NullPointerException}. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public interface RTIambassador 


// Federation Management Services // 


II 4.2 

j * * 

* Creates a federation execution. 

* @param federationExecutionName a {@link java.lang.String} 
holding the federation execution's identifier 

* @param fdd a {@link java.net.URL} giving the path to the 
federation execution's FOM Document Data (FDD) 

* @throws FederationExecutionAlreadyExists if the specified 
federation execution already exists 

* @throws CouldNotOpenFDD if the FDD could not be found or opened 

* @throws ErrorReadingFDD if the FDD is corrupt or otherwise 
unusable 

* @throws RTIinternalError if something else goes wrong 

* @see #destroyFederationExecution destroyFederationExecution 
*/ 

public void 

createFederationExecution( 

String federationExecutionName, 

java.net.URL fdd) 

throws FederationExecutionAlreadyExists, 

CouldNotOpenFDD, 

ErrorReadingFDD, 

RTI internalError,- 


250 


DRDC Valcartier TR 2007-412 



* * 


* Destroys a federation execution. 

* @param federationExecutionName a {@link java.lang.String} 
holding the federation execution's identifier 

* @throws FederatesCurrentlyJoined if federates are currently 
joined to the federation execution 

* @throws FederationExecutionDoesNotExist if the specified 
federation execution does not exist 

* @throws RTIinternalError if something else goes wrong 

* @see #createFederationExecution createFederationExecution 
*/ 

public void 

destroyFederationExecution( 

String federationExecutionName) 
throws FederatesCurrentlyJoined, 

FederationExecutionDoesNotExist, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


251 



* * 


* Joins the federate to the federation execution. 

* <p> 

* When a federate is instructed to save its state, the federate- 
specific persistent storage must use 

* the save {@link #requestFederationSave(String) label}, the 
<code>federateType</code> 

* supplied to this method and the {@link FederateHandle} returned 
by this method. 

* When the federation is later restored, there must be the same 
number of federates of each 

* <code>federateType</code> joined. 

* @param federateType a {@link java.lang.String} descriptor used 
to distinguish federate categories for federation save-and-restore 
purposes 

* @param federationExecutionName a <code>String</code> giving the 
federation execution's identifier 

* @param federateReference the {@link FederateAmbassador} 
interface of the joining federate 

* @param serviceReferences a {@link MobileFederateServices} record 
holding the federate-supplied {@link LogicalTimeFactory} and {@link 
LogicalTimelntervalFactory} implementations (this parameter may be 
<code>null</code>) 

* @return the joined federate's {@link FederateHandle} 

* @throws FederateAlreadyExecutionMember if the federate (the 
{@link RTIambassador} instance) has already joined a federation 
execution 

* @throws FederationExecutionDoesNotExist if the specified 
federation execution does not exist 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #resignFederationExecution resignFederationExecution 

*/ 

public FederateHandle 
j oinFederationExecution( 

String federateType, 

String federationExecutionName, 

FederateAmbassador federateReference, 

MobileFederateServices serviceReferences) 
throws FederateAlreadyExecutionMember, 

FederationExecutionDoesNotExist, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


252 


DRDC Valcartier TR 2007-412 



* * 


* Resigns the federate from the federation execution. 

* <p> 

* The possible resignation policies are: 

* <ul > 

* <li> UNCONDITIONALLY_DIVEST_ATTRIBUTES: Unconditionally divest 
ownership of all owned instance attributes 

* <li> DELETE_OBJECTS: Delete all object instances for which the 
joined federate has the delete privilege 

* <li> CANCEL_PENDING_OWNERSHIP_ACQUISITIONS: Cancel all pending 
instance attribute ownership acquisitions 

* <li> DELETE_OBJECTS_THEN_DIVEST: Perform DELETE_OBJECTS and then 
UNCONDITIONALLY_DIVEST_ATTRIBUTES 

* <li> CANCEL_THEN_DELETE_THEN_DIVEST: Perform 
CANCEL_PENDING_OWNERSHIP_ACQUISITIONS, then DELETE_OBJECTS and then 
UNCONDITIONALLY_DIVEST_ATTRIBUTES 

* <li> NO_ACTION: Perform no actions 

* </ul> 

* when UNCONDITIONALLY_DIVEST_ATTRIBUTES occurs, the RTI will try 
to transfer ownership to any eligible 

* federates (those that have discovered the object instances); 
this means ownership may be granted outright to 

* federates that were already in the "Acquiring" or "Willing To 
Acquire" states, and that 

* {@link FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks may be sent as a consequence of this federate's 
resignation and of later object instance discoveries. 

* @param resignAction a {@link ResignAction} representing the 
federate's resignation policy 

* @throws OwnershipAcquisitionPending if there is an ownership 
acquisition pending for some object class (and the federate isn't 
cancelling them) 

* @throws FederateOwnsAttributes if the federate owns some 
instance attributes (and isn't deleting or divesting them) 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #joinFederationExecution j oinFederationExecution 

*/ 

public void 

resignFederationExecution( 

ResignAction resignAction) 
throws OwnershipAcquisitionPending, 

FederateOwnsAttributes, 

FederateNotExecutionMember, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


253 



* * 


* Registers a federation synchronization point. This form concerns 
all of the currently joined federates. 

* Synchronization point labels may be pre-defined in the 
federation execution's FOM Document Data (FDD) but this isn't a 
requirement. 

* @param synchronizationPointLabel a {@link java.lang.String} 
holding the synchronization point's identifier 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #synchronizationPointAchieved synchronizationPointAchieved 

* @see 

FederateAmbassador#synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see FederateAmbassador#synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see FederateAmbassador#announceSynchronizationPoint 
announceSynchronizationPoint 

* @see FederateAmbassador#federationSynchronized 
federationSynchronized 

*/ 

public void 

registerFederationSynchronizationPoint ( 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 
throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


254 


DRDC Valcartier TR 2007-412 



* * 


* Registers a federation synchronization point and specifies a 
subset of the currently joined federates. 

* @param synchronizationPointLabel a {@link java.lang.String} 
holding the synchronization point's identifier 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param synchronizationSet a {@link FederateHandleSet} holding 
the {@link FederateHandle}s of the federates concerned by the 
synchronization point 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #synchronizationPointAchieved synchronizationPointAchieved 

* @see 

FederateAmbassador#synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see FederateAmbassador#synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see FederateAmbassador#announceSynchronizationPoint 
announceSynchronizationPoint 

* @see FederateAmbassador#federationSynchronized 
federationSynchronized 

*/ 

public void 

registerFederationSynchronizationPoint( 

String synchronizationPointLabel, 

byte[] userSuppliedTag, 

FederateHandleSet synchronizationSet) 
throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


255 



* Reports to the RTI that the specified synchronization point has 
been achieved. 

* @param synchronizationPointLabel a {@link java.lang.String} 
holding the synchronization point's identifier 

* @throws SynchronizationPointLabelNotAnnounced if the RTI does 
not recognize the specified <code>synchronizationPointLabel</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see 

FederateAmbassador#synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see FederateAmbassador#synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see FederateAmbassador#announceSynchronizationPoint 
announceSynchronizationPoint 

* @see FederateAmbassador#federationSynchronized 
federationSynchronized 

*/ 

public void 

synchronizationPointAchieved( 

String synchronizationPointLabel) 
throws SynchronizationPointLabelNotAnnounced, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


256 


DRDC Valcartier TR 2007-412 



II 4.11 

j * * 

* Requests that the federation save its current state as soon as 
possible under the specified label. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #federateSaveBegun federateSaveBegun 

* @see #federateSaveComplete federateSaveComplete 

* @see #federateSaveNotComplete federateSaveNotComplete 

* @see #queryFederationSaveStatus queryFederationSaveStatus 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

* @see FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse 

*/ 

public void 

requestFederationSave( 

String label) 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


257 



* Requests that the federation save its current state at the 
specified logical time under the specified label. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param theTime the {@link LogicalTime} at which to save the 
federation state 

* @throws LogicalTimeAlreadyPassed if the specified 
<code>LogicalTime</code> is in the federation's past 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTimec/code> is invalid 

* @throws FederateUnableToUseTime if the specified 
<code>LogicalTime</code>, although not in the federate's past, is 
nevertheless too soon to be achievable 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #federateSaveBegun federateSaveBegun 

* @see #federateSaveComplete federateSaveComplete 

* @see #federateSaveNotComplete federateSaveNotComplete 

* @see #queryFederationSaveStatus queryFederationSaveStatus 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

* @see FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse 

*/ 

public void 
requestFederationSave( 

String label, 

LogicalTime theTime) 
throws LogicalTimeAlreadyPassed, 

InvalidLogicalTime, 

FederateUnableToUseTime, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


258 


DRDC Valcartier TR 2007-412 



II 4.13 

j * * 

* Signals the RTI that this federate has begun to save its state. 

* @throws SaveNotlnitiated if a federation save was not previously 
requested 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationSave requestFederationSave 

* @see #federateSaveComplete federateSaveComplete 

* @see #federateSaveNotComplete federateSaveNotComplete 

* @see #queryFederationSaveStatus queryFederationSaveStatus 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

* @see FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse 

*/ 

public void 
federateSaveBegun() 
throws SaveNotlnitiated, 

FederateNotExecutionMember, 

RestorelnProgress, 

RTIinternalError; 


II 4.14 

j * * 

* Signals the RTI that this federate has finished saving its 
state. 

* @throws FederateHasNotBegunSave if the federate has not 
previously invoked {@link #federateSaveBegun federateSaveBegun} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationSave requestFederationSave 

* @see #federateSaveBegun federateSaveBegun 

* @see #federateSaveNotComplete federateSaveNotComplete 

* @see #queryFederationSaveStatus queryFederationSaveStatus 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

* @see FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse 

*/ 

public void 

federateSaveComplete() 

throws FederateHasNotBegunSave, 

FederateNotExecutionMember, 

RestorelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


259 



* * 


* Signals the RTI that this federate was unable to save its state. 

* @throws FederateHasNotBegunSave if the federate has not 
previously invoked {@link #federateSaveBegun federateSaveBegun} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationSave requestFederationSave 

* @see #federateSaveBegun federateSaveBegun 

* @see #federateSaveComplete federateSaveComplete 

* @see #queryFederationSaveStatus queryFederationSaveStatus 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

* @see FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse 

*/ 

public void 

federateSaveNotComplete() 
throws FederateHasNotBegunSave, 

FederateNotExecutionMember, 

RestorelnProgress, 

RTIinternalError; 


II 4.16 

j * * 

* Requests that the federation report on the status of the current 
save. 

* <p> 

* In the DoD Interpretations of IEEE 1516-2000v2, the pre¬ 
condition "Save in progress" is dropped, and the exception 
<code>SaveNotInProgress</code> is also deleted. 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationSave requestFederationSave 

* @see #federateSaveBegun federateSaveBegun 

* @see #federateSaveComplete federateSaveComplete 

* @see #federateSaveNotComplete federateSaveNotComplete 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

* @see FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse 

*/ 

public void 

queryFederationSaveStatus() 

throws FederateNotExecutionMember, 

//SaveNotInProgress, 

RestorelnProgress, 

RTIinternalError; 


260 


DRDC Valcartier TR 2007-412 



* * 


* Requests that the federation restore its current state to that 
saved under the specified label. 

* <p> 

* The federate-specific persistent storage of a federation saved 
state must use the save 

* <code>label</code>, the <code>federateType</code> supplied to 
the {@link #j oinFederationExecution j oinFederationExecution} 

* method and the {@link FederateHandle} returned by the same 
method. 

* For the restoration request to succeed, there must be the same 
number of federates of 

* each {@link #joinFederationExecution federateType} currently 
j oined. 

* Declaring a federate to be of a given <code>federateType</code> 
is therefore equivalent 

* to asserting that it can be restored using the state information 
saved by any other 

* federate of that <code>federateType</code>. 

* <p> 

* The RTI saves its own RTI-specific state information when a 
federation save succeeds; 

* this information tracks the save <code>label</code>, the {@link 
#j oinFederationExecution federationExecutionName}, 

* the {@link #createFederationExecution fdd} and the census of 
joined federates 

* in number and <code>federateType</code>. 

* <p> 

* There is no requirement that a save taken by one RTI 
implementation be restorable by another. 


DRDC Valcartier TR 2007-412 


261 



* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #federateRestoreComplete federateRestoreComplete 

* @see #federateRestoreNotComplete federateRestoreNotComplete 

* @see #queryFederationRestoreStatus queryFederationRestoreStatus 

* @see FederateAmbassador#requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see FederateAmbassador#requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see FederateAmbassador#federationRestoreBegun 
federationRestoreBegun 

* @see FederateAmbassador#initiateFederateRestore 
initiateFederateRestore 

* @see FederateAmbassador#federationRestored federationRestored 

* @see FederateAmbassador#federationNotRestored 
federationNotRestored 

* @see FederateAmbassador#federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 

requestFederationRestore( 

String label) 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


262 


DRDC Valcartier TR 2007-412 



// 4.22 

j * * 

* Signals the RTI that this federate has completed its restore 
operation. 

* @throws RestoreNotRequested if a federation restore was not 
previously requested 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationRestore requestFederationRestore 

* @see #federateRestoreNotComplete federateRestoreNotComplete 

* @see #queryFederationRestoreStatus queryFederationRestoreStatus 

* @see FederateAmbassador#requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see FederateAmbassador#requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see FederateAmbassador#federationRestoreBegun 
federationRestoreBegun 

* @see FederateAmbassador#initiateFederateRestore 
initiateFederateRestore 

* @see FederateAmbassador#federationRestored federationRestored 

* @see FederateAmbassador#federationNotRestored 
federationNotRestored 

* @see FederateAmbassador#federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

federateRestoreComplete () 
throws RestoreNotRequested, 

FederateNotExecutionMember, 

SavelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


263 



* * 


* Signals the RTI that this federate has failed in its restore 
operation. 

* @throws RestoreNotRequested if a federation restore was not 
previously requested 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationRestore requestFederationRestore 

* @see #federateRestoreComplete federateRestoreComplete 

* @see #queryFederationRestoreStatus queryFederationRestoreStatus 

* @see FederateAmbassador#requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see FederateAmbassador#requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see FederateAmbassador#federationRestoreBegun 
federationRestoreBegun 

* @see FederateAmbassador#initiateFederateRestore 
initiateFederateRestore 

* @see FederateAmbassador#federationRestored federationRestored 

* @see FederateAmbassador#federationNotRestored 
federationNotRestored 

* @see FederateAmbassador#federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 

federateRestoreNotComplete() 
throws RestoreNotRequested, 

FederateNotExecutionMember, 

SavelnProgress, 

RTIinternalError; 


264 


DRDC Valcartier TR 2007-412 



// 4.24 

j * * 

* Requests that the federation report on the status of the current 
restore operation. 

* <p> 

* In the DoD Interpretations of IEEE 1516-2000v2, the pre¬ 
condition "Restore in progress" is dropped, and the exception 
RestoreNotlnProgress is also deleted. 

* <p> 

* The {@link FederateHandle}s used in the {@link 
FederateHandleRestoreStatusPair}[] returned by the 

* {@link FederateAmbassador#federationRestoreStatusResponse 
federationRestoreStatusResponse} callback are the 

* pre-restore ones until all federates have invoked the {@link 
RTIambassador#federateRestoreComplete federateRestoreComplete} 

* service. Once all federates have been issued the {@link 
FederateAmbassador#federationRestored federationRestored} callbacks, 
the post-restore 

* <code>FederateHandle</code>s are used (and each federate's 
status will be {@link RestoreStatus NO_RESTORE_IN_PROGRESS}). 

* <p> 

* If this service is invoked between those two times, the {@link 
RestoreStatus} and <code>FederateHandle</code>s 

* are unpredictable. A federate should therefore avoid invoking 
this service between the moment it invokes the 

* <code>federateRestoreComplete</code> service and the moment it 
receives the <code>federationRestored</code> 

* or {@link FederateAmbassador#federationNotRestored 
federationNotRestored} callbacks. 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestFederationRestore requestFederationRestore 

* @see #federateRestoreComplete federateRestoreComplete 

* @see #federateRestoreNotComplete federateRestoreNotComplete 

* @see FederateAmbassador#requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see FederateAmbassador#requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see FederateAmbassador#federationRestoreBegun 
federationRestoreBegun 

* @see FederateAmbassador#initiateFederateRestore 
initiateFederateRestore 

* @see FederateAmbassador#federationRestored federationRestored 

* @see FederateAmbassador#federationNotRestored 
federationNotRestored 

* @see FederateAmbassador#federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

queryFederationRestoreStatus () 
throws FederateNotExecutionMember, 

SavelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


265 



// Declaration Management Services // 


1111111111111111111111111111111111111 

ii 5.2 

j * * 

* Signals to the RTI this federate's intention to start publishing 
some attributes of an object class. 

* @param theClass the {@link ObjectClassHandle} of the published 
object class 

* @param attributeList an {@link AttributeHandleSet} listing the 
published attributes 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #unpublishObjectClass unpublishObjectClass 

* @see #unpublishObj ectClassAttributes 
unpublishObj ectClassAttributes 

*/ 

public void 

publishObjectClassAttributes( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 

throws ObjectClassNotDefined, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


266 


DRDC Valcartier TR 2007-412 



* * 


* Signals to the RTI this federate's intention to stop publishing 
any attributes of an object class. 

* Note that this does <i>not</i> trigger 

* {@link FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks for object instance attributes that become unowned. 

* @param theClass the {@link ObjectClassHandle} of the unpublished 
object class 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws OwnershipAcquisitionPending if there is an ownership 
acquisition pending for the specified object class 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #publishObj ectClassAttributes publishObj ectClassAttributes 

* @see #unpublishObj ectClassAttributes 
unpublishObj ectClassAttributes 

*/ 

public void 
unpublishObjectClass ( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotDefined, 

OwnershipAcquisitionPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


267 



* Signals to the RTI this federate's intention to stop publishing 
certain attributes of an object class. 

* Note that this does <i>not</i> trigger 

* {@link FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks for object instance attributes that become unowned. 

* @param theClass the {@link ObjectClassHandle} of the unpublished 
object class 

* @param attributeList an {@link AttributeHandleSet} listing the 
unpublished attributes 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws OwnershipAcquisitionPending if there is an ownership 
acquisition pending for the specified object class attributes 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #publishObj ectClassAttributes publishObj ectClassAttributes 

* @see #unpublishObjectClass unpublishObjectClass 

*/ 

public void 

unpublishObjectClassAttributes( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 
throws ObjectClassNotDefined, 

AttributeNotDefined, 

OwnershipAcquisitionPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


268 


DRDC Valcartier TR 2007-412 



* * 


* Signals to the RTI this federate's intention to start publishing 
an interaction. 

* @param thelnteraction the {@link InteractionClassHandle} of the 
published interaction 

* @throws InteractionClassNotDefined if 
<code>theInteraction</code> isn't recognized by the RTI 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #unpublishInteractionClass unpublishlnteractionClass 

* @see FederateAmbassador#turnInteractionsOn turnlnteractionsOn 

* @see FederateAmbassador#turnlnteractionsOff turnlnteractionsOff 

*/ 

public void 

publishlnteractionClass ( 

InteractionClassHandle thelnteraction) 
throws InteractionClassNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError,- 


II 5.5 

j * * 

* Signals to the RTI this federate's intention to stop publishing 
an interaction. 

* @param thelnteraction the {@link InteractionClassHandle} of the 
unpublished interaction 

* @throws InteractionClassNotDefined if 
<code>theInteraction</code> isn't recognized by the RTI 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #publishlnteractionClass publishlnteractionClass 

*/ 

public void 

unpublishlnteractionClass( 

InteractionClassHandle thelnteraction) 

throws InteractionClassNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


269 



* * 


* Subscribes the federate to certain attributes of an object 
class . 

* @param theClass the {@link ObjectClassHandle} of the subscribed 
object class 

* @param attributeList an {@link AttributeHandleSet} listing the 
subscribed attributes 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributesPassively 
subscribeObj ectClassAttributesPassively 

* @see #subscribeObj ectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions 

* @see #subscribeObj ectClassAttributesPassivelyWithRegions 
subscribeObj ectClassAttributesPassivelyWithRegions 

* @see #unsubscribeObj ectClass unsubscribeObj ectClass 

* @see #unsubscribeObj ectClassAttributes 
unsubscribeObj ectClassAttributes 

* @see #unsubscribeObj ectClassAttributesWithRegions 
unsubscribeObj ectClassAttributesWithRegions 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObjectClass 
stopRegistrationForObj ectClass 

* @see FederateAmbassador#attributesInScope attributesInScope 

* @see FederateAmbassador#attributesOutOfScope 
attributesOutOfScope 

*/ 

public void 

subscribeObjectClassAttributes( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 
throws ObjectClassNotDefined, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


270 


DRDC Valcartier TR 2007-412 



* * 


* Subscribes the federate to certain attributes of an object class 
without tripping the publishers' object class relevance advisories. 

* <p> 

* Note that if this federate uses this service to switch its 
subscription mode from active to passive and it 

* happened to be the last active subscriber, the publisher may 
receive a 

* {@link FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObjectClass} callback (and possibly 

* one or more {@link 

FederateAmbassador#turnUpdatesOffForObj ectInstance 
turnUpdatesOffForObjectInstance} callbacks). 

* @param theClass the {@link ObjectClassHandle} of the subscribed 
object class 

* @param attributeList an {@link AttributeHandleSet} listing the 
subscribed attributes 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributes 
subscribeObj ectClassAttributes 

* @see #subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions 

* @see #subscribeObjectClassAttributesPassivelyWithRegions 
subscribeObj ectClassAttributesPassivelyWithRegions 

* @see #unsubscribeObj ectClass unsubscribeObj ectClass 

* @see #unsubscribeObj ectClassAttributes 
unsubscribeObj ectClassAttributes 

* @see #unsubscribeObj ectClassAttributesWithRegions 
unsubscribeObj ectClassAttributesWithRegions 

*/ 

public void 

subscribeObj ectClassAttributesPassively( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 
throws Obj ectClassNotDefined, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


271 



* * 


* Unsubscribes the federate from any attributes of an object 
class . 

* @param theClass the {@link ObjectClassHandle} of the 
unsubscribed object class 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributes 
subscribeObj ectClassAttributes 

* @see #subscribeObj ectClassAttributesPassively 
subscribeObj ectClassAttributesPassively 

* @see #subscribeObj ectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions 

* @see #subscribeObj ectClassAttributesPassivelyWithRegions 
subscribeObj ectClassAttributesPassivelyWithRegions 

* @see #unsubscribeObj ectClassAttributes 
unsubscribeObj ectClassAttributes 

* @see #unsubscribeObj ectClassAttributesWithRegions 
unsubscribeObj ectClassAttributesWithRegions 

*/ 

public void 

unsubscribeObjectClass ( 

Obj ectClassHandle theClass) 
throws ObjectClassNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


272 


DRDC Valcartier TR 2007-412 



* Unsubscribes the federate from certain attributes of an object 
class. 

* @param theClass the {@link ObjectClassHandle} of the 
unsubscribed object class 

* @param attributeList an {@link AttributeHandleSet} listing the 
unsubscribed attributes 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributes 
subscribeObj ectClassAttributes 

* @see #subscribeObjectClassAttributesPassively 
subscribeObj ectClassAttributesPassively 

* @see #subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions 

* @see #subscribeObjectClassAttributesPassivelyWithRegions 
subscribeObj ectClassAttributesPassivelyWithRegions 

* @see #unsubscribeObj ectClass unsubscribeObj ectClass 

* @see #unsubscribeObj ectClassAttributesWithRegions 
unsubscribeObj ectClassAttributesWithRegions 

*/ 

public void 

unsubscribeObj ectClassAttributes( 

Obj ectClassHandle theClass, 

AttributeHandleSet attributeList) 
throws Obj ectClassNotDefined, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


273 



* Subscribes the federate to an interaction. 

* @param theClass the {@link InteractionClassHandle} of the 
subscribed interaction 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws FederateServicelnvocationsAreBeingReportedViaMOM if 
service invocations are currently being reported via MOM interactions 
and <code>theClass</code> is 

<code>HLAmanager.HLAfederate.HLAreport.HLAreportServiceInvocation</cod 
e> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribelnteractionClassPassively 
subscribelnteractionClassPassively 

* @see #subscribelnteractionClassWithRegions 
subscribelnteractionClassWithRegions 

* @see #subscribelnteractionClassPassivelyWithRegions 
subscribelnteractionClassPassivelyWithRegions 

* @see #unsubscribelnteractionClass unsubscribelnteractionClass 

* @see FederateAmbassador#receiveInteraction receivelnteraction 

*/ 

public void 

subscribelnteractionClass ( 

InteractionClassHandle theClass) 
throws InteractionClassNotDefined, 

FederateServicelnvocationsAreBeingReportedViaMOM, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


274 


DRDC Valcartier TR 2007-412 



* * 


* Subscribes the federate to an interaction without tripping the 
publishers' interaction relevance advisories. 

* <p> 

* Note that if this federate uses this service to switch its 
subscription mode from active to passive and it 

* happened to be the last active subscriber, the publisher may 
receive a 

* {@link FederateAmbassador#turnInteractionsOff 
turnlnteractionsOff} callback. 

* @param theClass the {@link InteractionClassHandle} of the 
subscribed interaction 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws FederateServicelnvocationsAreBeingReportedViaMOM if 
service invocations are currently being reported via MOM interactions 
and <code>theClass</code> is 

<code>HLAmanager.HLAfederate.HLAreport.HLAreportServicelnvocation</cod 
e> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeInteractionClass subscribelnteractionClass 

* @see #subscribeInteractionClassWithRegions 
subscribelnteractionClassWithRegions 

* @see #subscribeInteractionClassPassivelyWithRegions 
subscribelnteractionClassPassivelyWithRegions 

* @see #unsubscribelnteractionClass unsubscribeInteractionClass 

* @see FederateAmbassador#receiveInteraction receiveInteraction 

*/ 

public void 

subscribelnteractionClassPassively( 

InteractionClassHandle theClass) 
throws InteractionClassNotDefined, 

FederateServicelnvocationsAreBeingReportedViaMOM, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


275 



* Unsubscribes the federate from an interaction. 

* @param theClass the {@link InteractionClassHandle} of the 
unsubscribed interaction 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribelnteractionClass subscribelnteractionClass 

*/ 

public void 

unsubscribelnteractionClass ( 

InteractionClassHandle theClass) 
throws InteractionClassNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


276 


DRDC Valcartier TR 2007-412 



// Object Management Services // 


11111111111111111111111111111111 

a 6-2 

j * * 

* Reserves a federation-unique name for a future object instance 
registration. 

* <p> 

* Note that although only one federate can successfully reserve an 
object instance name, 

* the RTI does not prevent another federate from being the first 
to use it during registration. 

* The Pitch pRTI1516 implementation interprets the specification 
(which is a little ambiguous) 

* to mean that a name, once reserved, cannot be re-used ever, even 
if the registered object 

* is later deleted. 

* @param theObjectName a {@link java.lang.String} holding the 
proposed object instance name 

* @throws IllegalName if the <code>theObjectName</code> is ill- 
formed (begins with "HLA") 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectInstance registerObj ectInstance 

* @see #registerObj ectlnstanceWithRegions 
registerObj ectlnstanceWithRegions 

* @see #getObj ectInstanceName getObjectInstanceName 

* @see FederateAmbassador#objectInstanceNameReservationSucceeded 
obj ectInstanceNameReservationSucceeded 

* @see FederateAmbassador#objectInstanceNameReservationFailed 
obj ectInstanceNameReservationFailed 

*/ 

public void 

reserveObj ectlnstanceName( 

String theObj ectName) 
throws IllegalName, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


277 



II 6.4 

j * * 

* Registers a new instance of the specified object class with the 

RTI. 

* Note that this does <i>not</i> trigger 

* {@link FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks for object instance attributes that are initially 
unowned. 

* @param theClass the {@link ObjectClassHandle} of the object 
instance being registered 

* @return the registered object instance's {@link 
Obj ectlnstanceHandle} 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws ObjectClassNotPublished if <code>theClass</code> isn't 
published by the federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectlnstanceWithRegions 
registerObj ectlnstanceWithRegions 

* @see #deleteObjectlnstance deleteObjectlnstance 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

* @see FederateAmbassador#discoverObjectlnstance 
discoverObj ectlnstance 

*/ 

public Obj ectlnstanceHandle 
registerObjectlnstance ( 

Obj ectClassHandle theClass) 
throws ObjectClassNotDefined, 

Obj ectClassNotPublished, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


278 


DRDC Valcartier TR 2007-412 



* Registers a new instance of the specified object class with the 
RTI, using a previously reserved name. 

* Note that this does <i>not</i> trigger 

* {@link FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks for object instance attributes that are initially 
unowned. 

* @param theClass the {@link ObjectClassHandle} of the object 
instance being registered 

* @param theObjectName a {@link java.lang.String} holding the 
previously reserved object instance name 

* @return the registered object instance's {@link 
Obj ectInstanceHandle} 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws ObjectClassNotPublished if <code>theClass</code> isn't 
published by the federate 

* @throws ObjectlnstanceNameNotReserved if 
<code>theObjectName</code> has not been previously reserved 

* @throws ObjectlnstanceNamelnUse if <code>theObjectName</code> is 
already in use 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectlnstanceWithRegions 
registerObj ectlnstanceWithRegions 

* @see #reserveObj ectInstanceName reserveObj ectInstanceName 

* @see #deleteObjectlnstance deleteObjectlnstance 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

* @see FederateAmbassador#discoverObj ectlnstance 
discoverObj ectlnstance 

*/ 

public Obj ectInstanceHandle 
registerObj ectlnstance( 

Obj ectClassHandle theClass, 

String theObj ectName) 

throws Obj ectClassNotDefined, 

Obj ectClassNotPublished, 

Obj ectlnstanceNameNotReserved, 

Obj ectlnstanceNamelnUse, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


279 



* * 


* Provides the RTI with updated values for certain instance 
attributes. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleValueMap} holding 
the updated values, keyed by attribute 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#turnUpdatesOnForObjectInstance 
turnUpdatesOnForObj ectInstance 

* @see FederateAmbassador#turnUpdatesOffForObjectInstance 
turnUpdatesOffForObj ectInstance 

* @see FederateAmbassador#reflectAttributeValues 
reflectAttributeValues 

*/ 

public void 
updateAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


280 


DRDC Valcartier TR 2007-412 



* * 


* Provides the RTI with updated values for certain instance 
attributes at a specified time-stamp. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleValueMap} holding 
the updated values, keyed by attribute 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param theTime the {@link LogicalTime} at which the updated 
values become valid 

* @return the message's {@link MessageRetractionReturn}, should a 
retraction become necessary 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #retract retract 

* @see FederateAmbassador#turnUpdatesOnForObjectInstance 
turnUpdatesOnForObj ectlnstance 

* @see FederateAmbassador#turnUpdatesOffForObjectlnstance 
turnUpdatesOffForObj ectlnstance 

* @see FederateAmbassador#reflectAttributeValues 
reflectAttributeValues 

*/ 

public MessageRetractionReturn 
updateAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

LogicalTime theTime) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

InvalidLogicalTime, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


281 



* * 


* Sends an interaction. Note that the sender may send a subset of 
the interaction's available parameters. 

* @param thelnteraction the {@link InteractionClassHandle} of the 
interaction being sent 

* @param theParameters a {@link ParameterHandleValueMap} holding 
the interaction values, keyed by parameter 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws InteractionClassNotPublished if the federate does not 
publish <code>theInteraction</code> 

* @throws InteractionClassNotDefined if 
<code>theInteraction</code> isn't recognized by the RTI 

* @throws InteractionParameterNotDefined if one of 
<code>theParameters</code> isn't recognized in the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #sendlnteractionWithRegions sendlnteractionWithRegions 

* @see FederateAmbassador#turnInteractionsOn turnlnteractionsOn 

* @see FederateAmbassador#turnlnteractionsOff turnlnteractionsOff 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType) 

*/ 

public void 
sendlnteraction( 

InteractionClassHandle thelnteraction, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag) 

throws InteractionClassNotPublished, 

InteractionClassNotDefined, 

InteractionParameterNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


282 


DRDC Valcartier TR 2007-412 



* * 


* Sends an interaction at a specified time-stamp. 

* @param thelnteraction the {@link InteractionClassHandle} of the 
interaction being sent 

* @param theParameters a {@link ParameterHandleValueMap} holding 
the interaction values, keyed by parameter 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @return the message's {@link MessageRetractionReturn}, should a 
retraction become necessary 

* @throws InteractionClassNotPublished if the federate does not 
publish <code>theInteraction</code> 

* @throws InteractionClassNotDefined if 
<code>theInteraction</code> isn't recognized by the RTI 

* @throws InteractionParameterNotDefined if one of 
<code>theParameters</code> isn't recognized in the supplied context 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #retract retract 

* @see #sendlnteractionWithRegions sendlnteractionWithRegions 

* @see FederateAmbassador#turnInteractionsOn turnlnteractionsOn 

* @see FederateAmbassador#turnlnteractionsOff turnlnteractionsOff 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,LogicalTime,OrderTy 
pe) 

*/ 

public MessageRetractionReturn 
sendlnteraction( 

InteractionClassHandle thelnteraction, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

LogicalTime theTime) 

throws InteractionClassNotPublished, 

InteractionClassNotDefined, 

InteractionParameterNotDefined, 

InvalidLogicalTime, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


283 



* Notifies the RTI that an object instance is to be deleted. 

* @param objectHandle the {@link ObjectInstanceHandle} of the 
object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws DeletePrivilegeNotHeld if the federate does not own the 
<code>HLAprivilegeToDeleteObj ect</code> attribute of the specified 
object instance 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectInstance registerObj ectInstance 

* @see #registerObj ectlnstanceWithRegions 
registerObj ectlnstanceWithRegions 

* @see FederateAmbassador#removeObj ectInstance 
removeObj ectlnstance 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

*/ 

public void 
deleteObj ectlnstance ( 

Obj ectInstanceHandle obj ectHandle, 
byte[] userSuppliedTag) 

throws DeletePrivilegeNotHeld, 

Obj ectlnstanceNotKnown, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


284 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the RTI that an object instance is to be deleted at a 
specified time-stamp. 

* @param objectHandle the {@link ObjectlnstanceHandle} of the 
object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param theTime the {@link LogicalTime} at which the object 
instance is deleted 

* @return the message's {@link MessageRetractionReturn}, should a 
retraction become necessary 

* @throws DeletePrivilegeNotHeld if the federate does not own the 
<code>HLAprivilegeToDeleteObj ect</code> attribute of the specified 
object instance 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectInstance registerObj ectInstance 

* @see #registerObj ectlnstanceWithRegions 
registerObj ectlnstanceWithRegions 

* @see #retract retract 

* @see FederateAmbassador#removeObjectInstance 
removeObj ectlnstance 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

*/ 

public MessageRetractionReturn 
deleteObj ectlnstance( 

Obj ectInstanceHandle obj ectHandle, 
byte[] userSuppliedTag, 

LogicalTime theTime) 

throws DeletePrivilegeNotHeld, 

Obj ectlnstanceNotKnown, 

InvalidLogicalTime, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


285 



* Notifies the RTI that the federate has "forgotten" all about a 
subscribed object instance and should therefore discover it anew. 

* @param objectHandle the {@link ObjectInstanceHandle} of the 
object instance 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws FederateOwnsAttributes if the federate owns some 
instance attributes of the specified object instance 

* @throws OwnershipAcquisitionPending if there is an ownership 
acquisition pending for some instance attribute of the specified 
object instance 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#discoverObj ectInstance 
discoverObj ectInstance 

*/ 

public void 

localDeleteObj ectInstance( 

Obj ectInstanceHandle obj ectHandle) 
throws Obj ectlnstanceNotKnown, 

FederateOwnsAttributes, 

OwnershipAcquisitionPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


286 


DRDC Valcartier TR 2007-412 



* Notifies the RTI that future {@link #updateAttributeValues 
updateAttributeValues} invocations should use the specified {@link 
TransportationType}. 

* <p> 

* The attribute transportation types revert to their FDD-specified 
values once this federate loses ownership. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @param theType the {@link TransportationType} to which 
<code>theAttributes</code> should switch 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #changeAttributeOrderType changeAttributeOrderType 

* @see #changeInteractionTransportationType 
changeInteractionTransportationType 

*/ 

public void 

changeAttributeTransportationType( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 

TransportationType theType) 
throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


287 



* Notifies the RTI that future {@link #sendInteraction 
sendlnteraction} invocations should use the specified {@link 
TransportationType}. 

* @param theClass the {@link InteractionClassHandle} of the 
subject interaction 

* @param theType the {@link TransportationType} to which 
<code>theClass</code> should switch 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws InteractionClassNotPublished if the federate does not 
publish <code>theClass</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #changeInteractionOrderType changeInteractionOrderType 

* @see #changeAttributeTransportationType 
changeAttributeTransportationType 

*/ 

public void 

changeInteractionTransportationType( 

InteractionClassHandle theClass, 

TransportationType theType) 

throws InteractionClassNotDefined, 

InteractionClassNotPublished, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


288 


DRDC Valcartier TR 2007-412 



* * 


* Requests that attribute value updates be provided for the 
specified instance attributes. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the attributes for which value updates are requested 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions 

* @see FederateAmbassador#provideAttributeValueUpdate 
provideAttributeValueUpdate 

*/ 

public void 

requestAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


289 



* * 


* Requests that attribute value updates be provided for all 
instance attributes of the specified object class. 

* @param theClass the {@link ObjectClassHandle} of the object 
class being polled 

* @param theAttributes an {@link AttributeHandleSet} listing the 
attributes being polled 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions 

* @see FederateAmbassador#provideAttributeValueUpdate 
provideAttributeValueUpdate 

*/ 

public void 

requestAttributeValueUpdate( 

Obj ectClassHandle theClass, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws ObjectClassNotDefined, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


290 


DRDC Valcartier TR 2007-412 



// Ownership Management Services // 



* Notifies the RTI that the federate immediately divests itself of 
ownership of the specified instance attributes. 

* The RTI may issue {@link 

FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks at eligible joined federates for object instance 
attributes that become unowned. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the divested attributes 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

*/ 

public void 

unconditionalAttributeOwnershipDivestiture( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


291 



* * 


* Notifies the RTI that the federate wishes to relinquish 
ownership of the specified instance attributes to any other willing 
federate(s). 

* The RTI may issue {@link 

FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} 

* callbacks at eligible joined federates for the specified object 
instance attributes. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the attributes to divest 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws AttributeAlreadyBeingDivested if an attribute ownership 
divestiture request is already pending for one of the attribute 
instances 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#requestDivestitureConfirmation 
requestDivestitureConfirmation 

* @see #confirmDivestiture confirmDivestiture 

* @see #cancelNegotiatedAttributeOwnershipDivestiture 
cancelNegotiatedAttributeOwnershipDivestiture 

* @see #unpublishObj ectClassAttributes 
unpublishObj ectClassAttributes 

*/ 

public void 

negotiatedAttributeOwnershipDivestiture( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

AttributeAlreadyBeingDivested, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


292 


DRDC Valcartier TR 2007-412 



* * 


* Completes the negotiated divestiture of the specified instance 
attributes. 

* <p> 

* In the DoD Interpretations of IEEE 1516-2000v2, the exception 
NoAcquisitionPending is added. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the confirmed attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws AttributeDivestitureWasNotRequested if the divestiture 
was not previously requested by the federate 

* @throws NoAcquisitionPending if the RTI has not yet located 
candidate federates 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #negotiatedAttributeOwnershipDivestiture 
negotiatedAttributeOwnershipDivestiture 

* @see FederateAmbassador#requestDivestitureConfirmation 
requestDivestitureConfirmation 

*/ 

public void 

confirmDivestiture( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

AttributeDivestItureWasNotRequested, 

NoAcquisitionPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


293 



* Notifies the RTI that the federate wishes to acquire ownership 
of the specified instance attributes. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param desiredAttributes an {@link AttributeHandleSet} 
specifying the desired attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws ObjectClassNotPublished if <code>theClass</code> isn't 
published by the federate 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotPublished if an attribute is not published 
by the federate 

* @throws FederateOwnsAttributes if the federate already owns some 
of the specified instance attributes 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#requestAttributeOwnershipRelease 
requestAttributeOwnershipRelease 

* @see 

FederateAmbassador#attributeOwnershipAcquisitionNotifloation 
attributeOwnershipAcquisitionNotification 

* @see #cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition 

*/ 

public void 

attributeOwnershipAcquisition( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet desiredAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

Obj ectClassNotPublished, 

AttributeNotDefined, 

AttributeNotPublished, 

FederateOwnsAttributes, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


294 


DRDC Valcartier TR 2007-412 



* Notifies the RTI that the federate wishes to acquire ownership 
of the specified instance attributes, 

* but only if they are currently unowned or in the process of 
being divested. 

* <p> 

* Attributes made available through {@link 
#negotiatedAttributeOwnershipDivestiture} are eligible for acquisition 
in this manner. 

* Other federates aren't bothered by this call; the requesting 
federate receives {@link 

FederateAmbassador#attributeOwnershipUnavailable} 

* for those attributes which are currently owned by other 
federates, {@link 

FederateAmbassador#attributeOwnershipAcquisitionNotification} 

* for the unowned ones, and no response for those attributes which 
do not currently exist. 

* Note also that the owning federate may stay in the Completing 
Divestiture state indefinitely (i.e. it postpones 

* emitting {@link #confirmDivestiture} indefinitely); the 
requesting federate won't receive any callbacks during that time. 

* It is not clear whether {@link 

#cancelAttributeOwnershipAcquisition} (whilst the requesting federate 
is awaiting a response) 

* would raise an {@link AttributeAcquisitionWasNotRequested} 
exception or not. 


DRDC Valcartier TR 2007-412 


295 



* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param desiredAttributes an {@link AttributeHandleSet} 
specifying the desired attributes 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws ObjectClassNotPublished if <code>theClass</code> isn't 
published by the federate 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotPublished if an attribute is not published 
by the federate 

* @throws FederateOwnsAttributes if the federate already owns some 
of the specified instance attributes 

* @throws AttributeAlreadyBeingAcquired if an unconditional 
attribute ownership acquisition request is already pending for an 
attribute instance 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see 

FederateAmbassador#attributeOwnershipAcquisitionNotifloation 
attributeOwnershipAcquisitionNotification 

* @see FederateAmbassador#attributeOwnershipUnavailable 
attributeOwnershipUnavailable 

* @see #cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition 

*/ 

public void 

attributeOwnershipAcquisitionlfAvailable( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet desiredAttributes) 
throws Obj ectlnstanceNotKnown, 

Obj ectClassNotPublished, 

AttributeNotDefined, 

AttributeNotPublished, 

FederateOwnsAttributes, 

AttributeAlreadyBeingAcquired, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


296 


DRDC Valcartier TR 2007-412 



II 7.12 

j * * 

* Notifies the RTI that the federate is willing to relinquish 
ownership of the specified instance attributes 

* if any other federates are attempting to acquire them. The 
method concludes the divestiture immediately one way or another. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the offered attributes 

* @return an {@link AttributeHandleSet} specifying the attributes 
successfully divested 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#requestAttributeOwnershipRelease 
requestAttributeOwnershipRelease 

*/ 

public AttributeHandleSet 
attributeOwnershipDivestiturelfWanted( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


297 



II 7.13 

j * * 

* Notifies the RTI that the federate is cancelling the outstanding 
{@link #negotiatedAttributeOwnershipDivestiture 

negotiatedAttributeOwnershipDivestiture} of 

* the specified instance attributes. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the attributes for which divestiture is canceled 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws AttributeDivestitureWasNotRequested if the divestiture 
was not previously requested by the federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #negotiatedAttributeOwnershipDivestiture 
negotiatedAttributeOwnershipDivestiture 

*/ 

public void 

cancelNegotiatedAttributeOwnershipDivestiture( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


298 


DRDC Valcartier TR 2007-412 



II 7.14 

j * * 

* Notifies the RTI that the federate is cancelling the outstanding 
{@link #attributeOwnershipAcquisition attributeOwnershipAcquisition} 
of 

* the specified instance attributes. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the attributes for which acquisition is canceled 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeAlreadyOwned if the cancellation occurs too 
late (i.e. it has already been granted ownership) 

* @throws AttributeAcquisitionWasNotRequested if there is no 
pending attribute ownership acquisition to cancel 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #attributeOwnershipAcquisition 
attributeOwnershipAcquisition 

* @see 

FederateAmbassador#confirmAttributeOwnershipAcquisitionCancellation 
confirmAttributeOwnershipAcquisitionCancellation 

*/ 

public void 

cancelAttributeOwnershipAcquisition( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotRequested, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


299 



* * 


* Requests that the RTI report the ownership status of the 
specified instance attribute. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
queried attribute 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#informAttributeOwnership 
informAttributeOwnership 

* @see FederateAmbassador#attributeIsNotOwned attributelsNotOwned 

* @see FederateAmbassador#attributeIsOwnedByRTI 
attributelsOwnedByRTI 

*/ 

public void 

queryAttributeOwnership( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


300 


DRDC Valcartier TR 2007-412 



* * 


* Requests that the RTI report whether or not the federate owns 
the specified instance attribute. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
queried attribute 

* @return <code>true</code> iff <code>theAttribute</code> is owned 
by the federate 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

*/ 

public boolean 
IsAttributeOwnedByFederate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


301 



// Time Management Services // 


111111111111111111111111111111 
ii 8.2 

j * * 

* Requests that this federate become time-regulating (with the 
specified lookahead), 

* thereby enabling it to send time-stamped messages. 

* @param theLookahead a {@link LogicalTimelnterval} specifying the 
new lookahead 

* @throws TimeRegulationAlreadyEnabled if time regulation is 
already enabled 

* @throws InvalidLookahead if <code>theLookahead</code> is invalid 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeRegulationPending if a time regulation 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableTimeRegulation disableTimeRegulation 

* @see FederateAmbassador#timeRegulationEnabled 
timeRegulationEnabled 

*/ 

public void 
enableTimeRegulation( 

LogicalTimelnterval theLookahead) 
throws TimeRegulationAlreadyEnabled, 

InvalidLookahead, 

InTimeAdvancingState, 

RequestForTimeRegulationPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


302 


DRDC Valcartier TR 2007-412 



* * 


* Requests that this federate no longer be time-regulating, 

* thereby making its future messages receive-ordered. 

* @throws TimeRegulationlsNotEnabled if time regulation is 
currently disabled 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableTimeRegulation enableTimeRegulation 
*/ 

public void 

disableTimeRegulation () 

throws TimeRegulationlsNotEnabled, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


j * * 

* Requests that this federate become time-constrained. 

* @throws TimeConstrainedAlreadyEnabled if time constraint is 
already enabled 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeConstrainedPending if a time constraint 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableTimeConstrained disableTimeConstrained 

* @see FederateAmbassador#timeConstrainedEnabled 
timeConstrainedEnabled 

*/ 

public void 

enableTimeConstrained() 

throws TimeConstrainedAlreadyEnabled, 

InTimeAdvancingState, 

RequestForTimeConstrainedPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


303 



* * 


* Requests that this federate no longer be time-constrained. 

* @throws TimeConstrainedIsNotEnabled if time constraint is 
currently disabled 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableTimeConstrained enableTimeConstrained 

*/ 

public void 

disableTimeConstrained() 

throws TimeConstrainedIsNotEnabled, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


304 


DRDC Valcartier TR 2007-412 



* * 


* Requests an advance of the federate's logical time to the 
specified value, 

* thereby releasing queued messages of appropriate time-stamps. 

* <p> 

* The federate is guaranteeing that it will not later generate a 

* {@link OrderType TIMESTAMP} message with a time stamp less than 
or equal to 

* the specified logical time, even if its lookahead is zero. 

* A Time Advance Grant completes this request and indicates to the 
federate 

* that no additional {@link OrderType TIMESTAMP} messages will be 
later delivered 

* to it with time stamps less than or equal to the logical time of 
the grant. 

* @param theTime the {@link LogicalTime} to which the federate 
wishes to advance 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws LogicalTimeAlreadyPassed if the specified 
<code>LogicalTime</code> is in the federation's past 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeRegulationPending if a time regulation 
request is pending 

* @throws RequestForTimeConstrainedPending if a time constraint 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #tImeAdvanceRequestAvailable tImeAdvanceRequestAvaliable 

* @see #nextMessageRequest nextMessageRequest 

* @see #nextMessageRequestAvailable nextMessageRequestAva11able 

* @see #flushQueueRequest flushQueueRequest 

* @see FederateAmbassador#tImeAdvanceGrant tImeAdvanceGrant 

*/ 

public void 
timeAdvanceRequest( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

LogicalTimeAlreadyPassed, 

InTimeAdvancingState, 

RequestForTimeRegulationPending, 

RequestForTimeConstrainedPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


305 



* * 


* Requests an advance of the federate's logical time to the 
specified value, 

* thereby releasing queued messages of appropriate time-stamps, 
whilst allowing 

* current-time messages to still be exchanged. 

* <p> 

* timeAdvanceRequestAvailable is similar to timeAdvanceRequest, 
except that 

* the RTI does not guarantee delivery of <i>all</i> messages with 
time stamps 

* <i>equal to</i> the logical time granted. The federate is also 
allowed to 

* send additional messages with time stamps equal to the logical 
time granted, 

* if the federate's actual lookahead is zero. 

* @param theTime the {@link LogicalTime} to which the federate 
wishes to advance 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTimec/code> is invalid 

* @throws LogicalTimeAlreadyPassed if the specified 
<code>LogicalTime</code> is in the federation's past 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeRegulationPending if a time regulation 
request is pending 

* @throws RequestForTimeConstrainedPending if a time constraint 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #timeAdvanceRequest timeAdvanceRequest 

* @see #nextMessageRequest nextMessageRequest 

* @see #nextMessageRequestAvailable nextMessageRequestAvailable 

* @see #flushQueueRequest flushQueueRequest 

* @see FederateAmbassador#tImeAdvanceGrant tImeAdvanceGrant 

*/ 

public void 

timeAdvanceRequestAvailable( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

LogicalTimeAlreadyPassed, 

InTimeAdvancingState, 

RequestForTimeRegulationPending, 
RequestForTimeConstrainedPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


306 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the RTI that the federate wishes to advance to the 
lesser {@link LogicalTime} of 

* the one specified and the next time-stamped message awaiting 
delivery. 

* <p> 

* nextMessageRequest is similar to timeAdvanceRequest except that 
the time advance granted 

* is a function of the time-stamp of the next {@link OrderType 
TIMESTAMP} message awaiting delivery. 

* @param theTime the {@link LogicalTime} beyond which the federate 
does not wish to advance 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws LogicalTimeAlreadyPassed if the specified 
<code>LogicalTime</code> is in the federation's past 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeRegulationPending if a time regulation 
request is pending 

* @throws RequestForTimeConstrainedPending if a time constraint 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #nextMessageRequestAvailable nextMessageRequestAvaliable 

* @see #timeAdvanceRequest timeAdvanceRequest 

* @see #timeAdvanceRequestAvailable timeAdvanceRequestAvaliable 

* @see #flushQueueRequest flushQueueRequest 

* @see FederateAmbassador#timeAdvanceGrant timeAdvanceGrant 

*/ 

public void 
nextMessageRequest( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

LogicalTimeAlreadyPassed, 

InTimeAdvancingState, 

RequestForTimeRegulationPending, 

RequestForTimeConstrainedPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


307 



* * 


* Notifies the RTI that the federate wishes to advance to the 
lesser {@link LogicalTime} of 

* the one specified and the next time-stamped message awaiting 
delivery, whilst allowing 

* current-time messages to still be exchanged. 

* <p> 

* nextMessageRequestAvailable is similar to 
timeAdvanceRequestAvailable except that the time advance 

* granted is a function of the time-stamp of the next {@link 
OrderType TIMESTAMP} message awaiting delivery. 

* @param theTime the {@link LogicalTime} beyond which the federate 
does not wish to advance 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTimec/code> is invalid 

* @throws LogicalTimeAlreadyPassed if the specified 
<code>LogicalTime</code> is in the federation's past 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeRegulationPending if a time regulation 
request is pending 

* @throws RequestForTimeConstrainedPending if a time constraint 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #nextMessageRequest nextMessageRequest 

* @see #timeAdvanceRequest timeAdvanceRequest 

* @see #timeAdvanceRequestAvailable timeAdvanceRequestAvailable 

* @see #flushQueueRequest flushQueueRequest 

* @see FederateAmbassador#timeAdvanceGrant timeAdvanceGrant 

*/ 

public void 

nextMessageRequestAvailable( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

LogicalTimeAlreadyPassed, 

InTimeAdvancingState, 

RequestForTimeRegulationPending, 
RequestForTimeConstrainedPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


308 


DRDC Valcartier TR 2007-412 



* Notifies the RTI that the federate wishes to advance to the 
lesser {@link LogicalTime} of 

* the one specified and the next time-stamped message awaiting 
delivery, but should nevertheless 

* receive all currently-queued time-stamped messages awaiting 
delivery. 

* <p> 

* flushQueueRequest is similar to nextMessageRequest except that 
some anticipated messages may be received. 

* As a consequence, later time-stamped messages may not be 
received in the "correct ' 1 order. 

* @param theTime the {@link LogicalTime} beyond which the federate 
does not wish to advance 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws LogicalTimeAlreadyPassed if the specified 
<code>LogicalTime</code> is in the federation's past 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws RequestForTimeRegulationPending if a time regulation 
request is pending 

* @throws RequestForTimeConstrainedPending if a time constraint 
request is pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #nextMessageRequest nextMessageRequest 

* @see #nextMessageRequestAvailable nextMessageRequestAvaliable 

* @see #timeAdvanceRequest timeAdvanceRequest 

* @see #timeAdvanceRequestAvailable timeAdvanceRequestAvaliable 

* @see FederateAmbassador#timeAdvanceGrant timeAdvanceGrant 

*/ 

public void 
flushQueueRequest( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

LogicalTimeAlreadyPassed, 

InTimeAdvancingState, 

RequestForTimeRegulationPending, 

RequestForTimeConstrainedPending, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


309 



* * 


* Instructs the RTI to deliver {@link OrderType RECEIVE} messages 
when the federate is in either of the 

* Time Advancing and Time Granted states. 

* @throws AsynchronousDeliveryAlreadyEnabled if asynchronous 
delivery is already enabled 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableAsynchronousDelivery disableAsynchronousDelivery 

*/ 

public void 

enableAsynchronousDelivery() 
throws AsynchronousDeliveryAlreadyEnabled, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


// 8.15 

j * * 

* Instructs the RTI to deliver {@link OrderType RECEIVE} messages 
only when the federate is in the 

* Time Advancing state. This is only applicable to time- 
constrained federates. 

* @throws AsynchronousDeliveryAlreadyDisabled if asynchronous 
delivery is already disabled 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableAsynchronousDelivery enableAsynchronousDelivery 

*/ 

public void 

disableAsynchronousDelivery() 
throws AsynchronousDeliveryAlreadyDisabled, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


310 


DRDC Valcartier TR 2007-412 



// 8.16 

j * * 

* Requests the federate's current GALT (Greatest Available Logical 
Time) . 

* @return a {@link TimeQueryReturn} containing the requested 
logical time and a validity guard boolean 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

*/ 

public TimeQueryReturn 
queryGALT() 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


II 8.17 

j * * 

* Requests the federate's current logical time. 

* @return the requested {@link LogicalTime} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

*/ 

public LogicalTime 
queryLogicalTime() 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


311 



* * 


* Requests the federate's current LITS (Least Incoming Time 
Stamp) . 

* @return a {@link TimeQueryReturn} containing the requested 
logical time and a validity guard boolean 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

*/ 

public TimeQueryReturn 
queryLITS() 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


j * * 

* Requests a change to the federate's lookahead. 

* If the new lookahead is smaller than the current one, the change 
will come about gradually. 

* The federate's lookahead will shrink every time its logical time 
advances so that the 

* federate's "future" remains at a constant logical time, until 
the specified lookahead 

* value is reached. 

* @param theLookahead a {@link LogicalTimelnterval} specifying the 
requested new lookahead 

* @throws TimeRegulationlsNotEnabled if time regulation is 
currently disabled 

* @throws InvalidLookahead if <code>theLookahead</code> is invalid 

* @throws InTimeAdvancingState if the federate is in the time- 
advancing state 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #queryLookahead queryLookahead 

*/ 

public void 
modifyLookahead( 

LogicalTimelnterval theLookahead) 
throws TimeRegulationlsNotEnabled, 

InvalidLookahead, 

InTimeAdvancingState, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


312 


DRDC Valcartier TR 2007-412 



* * 


* Requests the federate's current lookahead. 

* @return the requested {@link LogicalTimelnterval} 

* @throws TimeRegulationlsNotEnabled if time regulation is 
currently disabled 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #modifyLookahead modifyLookahead 
*/ 

public LogicalTimelnterval 
queryLookahead() 

throws TimeRegulationlsNotEnabled, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError,- 


// 8.21 

j * * 

* Notifies the RTI that a message previously sent by the joined 
federate is to be retracted. 

* @param theHandle the {@link MessageRetractionHandle} of the 
message to retract 

* @throws InvalidMessageRetractionHandle if the 
<code>MessageRetractionHandle</code> is invalid 

* @throws TimeRegulationlsNotEnabled if time regulation is 
currently disabled 

* @throws MessageCanNoLongerBeRetracted the message specified can 
no longer be retracted 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see FederateAmbassador#requestRetraction requestRetraction 

*/ 

public void 
retract ( 

MessageRetractionHandle theHandle) 
throws InvalidMessageRetractionHandle, 

TimeRegulationlsNotEnabled, 

MessageCanNoLongerBeRetracted, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


313 



* * 


* Notifies the RTI that future {@link #updateAttributeValues 
updateAttributeValues} invocations should use the specified {@link 
OrderType}. 

* <p> 

* The attribute ordering types revert to their FDD-specified 
values once this federate loses ownership. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @param theType the {@link OrderType} to which 
<code>theAttributes</code> should switch 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotOwned if an attribute is not owned by the 
federate 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #changeAttributeTransportationType 
changeAttributeTransportationType 

* @see #changeInteractionOrderType changeInteractionOrderType 

*/ 

public void 

changeAttributeOrderType( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 

OrderType theType) 

throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

AttributeNotOwned, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


314 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the RTI that future {@link #sendInteraction 
sendlnteraction} invocations should use the specified {@link 
OrderType}. 

* @param theClass the {@link InteractionClassHandle} of the 
subject interaction 

* @param theType the {@link OrderType} to which 
<code>theClass</code> should switch 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws InteractionClassNotPublished if the federate does not 
publish <code>theClass</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #changeAttributeOrderType changeAttributeOrderType 

* @see #changeInteractionTransportationType 
changeInteractionTransportationType 

*/ 

public void 

changelnteractionOrderType( 

InteractionClassHandle theClass, 

OrderType theType) 

throws InteractionClassNotDefined, 

InteractionClassNotPublished, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


315 



// Data Distribution Management // 


1111111111111111111111111111111111 
ii 9-2 

j * * 

* Creates a region template that has the specified dimensions. 

* <p> 

* Before the region can be used for update or subscription, {@link 
#setRangeBounds setRangeBounds} must 

* be invoked at least once for each dimension specified. Only then 
can {@link #commitRegionModifications commitRegionModifications} 

* be invoked to turn the region template into a region 
specification. 

* @param dimensions a {@link DimensionHandleSet} specifying the 
region's dimensions 

* @return the {@link RegionHandle} of the newly created region 
template 

* @throws InvalidDimensionHandle if one of the {@link 
DimensionHandle}s is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #deleteRegion deleteRegion 

*/ 

public RegionHandle 
createRegion( 

DimensionHandleSet dimensions) 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


316 


DRDC Valcartier TR 2007-412 



* Notifies the RTI that pending dimension range modifications 
should be applied to the regions. 

* <p> 

* <code>commitRegionModifications</code> turns region templates 
into region specifications and updates region realizations. 

* @param regions a {@link RegionHandleSet} specifying the subject 
regions (templates and specifications) 

* @throws InvalidRegion if one of the region templates has not had 
all of its ranges set 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #getRangeBounds getRangeBounds 

* @see #setRangeBounds setRangeBounds 

*/ 

public void 

commitRegionModifications( 

RegionHandleSet regions) 
throws InvalidRegion, 

RegionNotCreatedByThisFederate, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


317 



* * 


* Deletes the specified region. 

* <p> 

* Before a region can be deleted, it must be unassociated from any 
subscriptions or updates. 

* @param theRegion the {@link RegionHandle} to delete (template or 
specification) 

* @throws InvalidRegion if the {@link RegionHandle} is invalid 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws RegionlnUseForUpdateOrSubscription if the region is 
still in use 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #createRegion createRegion 

*/ 

public void 
deleteRegion( 

RegionHandle theRegion) 
throws InvalidRegion, 

RegionNotCreatedByThisFederate, 
RegionlnUseForUpdateOrSubscription, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


318 


DRDC Valcartier TR 2007-412 



// 9-5 

j * * 

* Registers a new instance of the specified object class with the 

RTI 

* and simultaneously associates its attributes with distribution 
regions. 

* @param theClass the {@link ObjectClassHandle} of the object 
instance being registered 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions 
being simultaneously associated 

* @return the registered object instance's {@link 
Obj ectInstanceHandle} 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws ObjectClassNotPublished if <code>theClass</code> isn't 
published by the federate 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotPublished if an attribute is not published 
by the federate 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectInstance registerObj ectInstance 

* @see #deleteObjectlnstance deleteObjectlnstance 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

*/ 

public Obj ectInstanceHandle 
registerObj ectlnstanceWithRegions ( 

Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions) 
throws Obj ectClassNotDefined, 

Obj ectClassNotPublished, 

AttributeNotDefined, 

AttributeNotPublished, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


319 



* Registers a new instance of the specified object class with the 
RTI, using a previously reserved name 

* and simultaneously associates its attributes with distribution 
regions. 

* @param theClass the {@link ObjectClassHandle} of the object 
instance being registered 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions 
being simultaneously associated 

* @param theObject a {@link java.lang.String} holding the 
previously reserved object instance name 

* @return the registered object instance's {@link 
Obj ectlnstanceHandle} 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws ObjectClassNotPublished if <code>theClass</code> isn't 
published by the federate 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws AttributeNotPublished if an attribute is not published 
by the federate 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws ObjectlnstanceNameNotReserved if <code>theObject</code> 
has not been previously reserved 

* @throws ObjectlnstanceNamelnUse if <code>theObject</code> is 
already in use 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #registerObj ectInstance registerObj ectInstance 

* @see #reserveObj ectlnstanceName reserveObj ectlnstanceName 

* @see #deleteObjectlnstance deleteObjectlnstance 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

*/ 


320 


DRDC Valcartier TR 2007-412 



public Obj ectlnstanceHandle 
registerObj ectlnstanceWithRegions( 

Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions 
String theObject) 

throws Obj ectClassNotDefined, 

Obj ectelassNotPublished, 

AttributeNotDefined, 

AttributeNotPublished, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 
InvalidRegionContext, 

Obj ectlnstanceNameNotReserved, 

Obj ectlnstanceNamelnUse, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internal Error ,- 


DRDC Valcartier TR 2007-412 


321 



* Associates distribution regions with the specified object 
instance attributes. 

* @param theObject the {@link ObjectInstanceHandle} of the object 
instance 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions to 
associate 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #unassociateRegionsForUpdates unassociateRegionsForUpdates 

*/ 

public void 

associateRegionsForUpdates( 

Obj ectlnstanceHandle theObj ect, 

AttributeSetRegionSetPairList attributesAndRegions) 
throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


322 


DRDC Valcartier TR 2007-412 



* * 


* Unassociates distribution regions from the specified object 
instance attributes. 

* <p> 

* Regions must be unassociated from any distributions and 
subscriptions before they can be deleted. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions to 
unassociate 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #associateRegionsForUpdates associateRegionsForUpdates 

*/ 

public void 

unassociateRegionsForUpdates( 

Obj ectlnstanceHandle theObj ect, 

AttributeSetRegionSetPairList attributesAndRegions) 
throws Obj ectlnstanceNotKnown, 

AttributeNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


323 



* * 


* Subscribes the federate to certain attributes of an object class 
within specified regions. 

* @param theClass the {@link ObjectClassHandle} of the subscribed 
object class 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions 
being simultaneously associated 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributes 
subscribeObj ectClassAttributes 

* @see #subscribeObj ectClassAttributesPassively 
subscribeObj ectClassAttributesPassively 

* @see #subscribeObj ectClassAttributesPassivelyWithRegions 
subscribeObj ectClassAttributesPassivelyWithRegions 

* @see #unsubscribeObj ectClass unsubscribeObj ectClass 

* @see #unsubscribeObj ectClassAttributes 
unsubscribeObj ectClassAttributes 

* @see #unsubscribeObjectClassAttributesWithRegions 
unsubscribeObj ectClassAttributesWithRegions 

*/ 

public void 

subscribeObj ectClassAttributesWithRegions( 

Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions) 
throws ObjectClassNotDefined, 

AttributeNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


324 


DRDC Valcartier TR 2007-412 



* Subscribes the federate to certain attributes of an object class 
within specified regions, 

* without tripping the publishers' object class relevance 
advisories. 

* @param theClass the {@link ObjectClassHandle} of the subscribed 
object class 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions 
being simultaneously associated 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributes 
subscribeObj ectClassAttributes 

* @see #subscribeObjectClassAttributesPassively 
subscribeObj ectClassAttributesPassively 

* @see #subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions 

* @see #unsubscribeObj ectClass unsubscribeObj ectClass 

* @see #unsubscribeObj ectClassAttributes 
unsubscribeObj ectClassAttributes 

* @see #unsubscribeObj ectClassAttributesWithRegions 
unsubscribeObj ectClassAttributesWithRegions 

*/ 

public void 

subscribeObj ectClassAttributesPassivelyWithRegions( 

Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions) 
throws Obj ectClassNotDefined, 

AttributeNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


325 



* Unsubscribes the federate from certain attributes of an object 
class within specified regions. 

* @param theClass the {@link ObjectClassHandle} of the 
unsubscribed object class 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions 
being simultaneously unassociated 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeObj ectClassAttributes 
subscribeObj ectClassAttributes 

* @see #subscribeObj ectClassAttributesPassively 
subscribeObj ectClassAttributesPassively 

* @see #subscribeObj ectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions 

* @see #subscribeObj ectClassAttributesPassivelyWithRegions 
subscribeObj ectClassAttributesPassivelyWithRegions 

* @see #unsubscribeObj ectClass unsubscribeObj ectClass 

* @see #unsubscribeObj ectClassAttributes 
unsubscribeObj ectClassAttributes 

*/ 

public void 

unsubscribeObj ectClassAttributesWithRegions( 

Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions) 
throws ObjectClassNotDefined, 

AttributeNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


326 


DRDC Valcartier TR 2007-412 



* * 


* Subscribes the federate to an interaction within specified 
regions. 

* @param theClass the {@link InteractionClassHandle} of the 
subscribed interaction 

* @param regions the {@link RegionHandleSet} describing the 
subscription regions 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateServicelnvocationsAreBeingReportedViaMOM if 
service invocations are currently being reported via MOM interactions 
and <code>theClass</code> is 

<code>HLAmanager.HLAfederate.HLAreport.HLAreportServicelnvocation</cod 
e> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeInteractionClass subscribelnteractionClass 

* @see #subscribeInteractionClassPassively 
subscribelnteractionClassPassively 

* @see #subscribeInteractionClassPassivelyWithRegions 
subscribelnteractionClassPassivelyWithRegions 

* @see #unsubscribelnteractionClass unsubscribeInteractionClass 

*/ 

public void 

subscribelnteractionClassWithRegions ( 

InteractionClassHandle theClass, 

RegionHandleSet regions) 

throws InteractionClassNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateServicelnvocationsAreBeingReportedViaMOM, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


327 



* * 


* Subscribes the federate to an interaction within specified 
regions, 

* without tripping the publishers' interaction relevance 
advisories. 

* @param theClass the {@link InteractionClassHandle} of the 
subscribed interaction 

* @param regions the {@link RegionHandleSet} describing the 
subscription regions 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateServicelnvocationsAreBeingReportedViaMOM if 
service invocations are currently being reported via MOM interactions 
and <code>theClass</code> is 

<code>HLAmanager.HLAfederate.HLAreport.HLAreportServiceInvocation</cod 
e> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribelnteractionClass subscribelnteractionClass 

* @see #subscribelnteractionClassPassively 
subscribelnteractionClassPassively 

* @see #subscribelnteractionClassWithRegions 
subscribelnteractionClassWithRegions 

* @see #unsubscribelnteractionClass unsubscribelnteractionClass 

*/ 

public void 

subsoribeInteractionClassPassivelyWithRegions( 
InteractionClassHandle theClass, 

RegionHandleSet regions) 

throws InteractionClassNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateServicelnvocationsAreBeingReportedViaMOM, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


328 


DRDC Valcartier TR 2007-412 



* * 


* Unsubscribes the federate from an interaction within specified 
regions. 

* @param theClass the {@link InteractionClassHandle} of the 
unsubscribed interaction 

* @param regions the {@link RegionHandleSet} describing the 
subscription regions 

* @throws InteractionClassNotDefined if <code>theClass</code> 
isn't recognized by the RTI 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #subscribeInteractionClassWithRegions 
subscribeInteractionClassWithRegions 

*/ 

public void 

unsubscribeInteractionClassWithRegions( 

InteractionClassHandle theClass, 

RegionHandleSet regions) 

throws InteractionClassNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


329 



* * 


* Sends an interaction within specified regions. 

* @param thelnteraction the {@link InteractionClassHandle} of the 
interaction being sent 

* @param theParameters a {@link ParameterHandleValueMap} holding 
the interaction values, keyed by parameter 

* @param regions the {@link RegionHandleSet} describing the 
distribution regions 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws InteractionClassNotDefined if 
<code>theInteraction</code> isn't recognized by the RTI 

* @throws InteractionClassNotPublished if the federate does not 
publish <code>theInteraction</code> 

* @throws InteractionParameterNotDefined if one of 
<code>theParameters</code> isn't recognized in the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #sendInteraction sendlnteraction 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,RegionHandleSet) 

*/ 

public void 

sendlnteractionWithRegions( 

InteractionClassHandle thelnteraction, 

ParameterHandleValueMap theParameters, 

RegionHandleSet regions, 

byte[] userSuppliedTag) 

throws InteractionClassNotDefined, 

InteractionClassNotPublished, 

InteractionParameterNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


330 


DRDC Valcartier TR 2007-412 



* Sends a time-stamped interaction within specified regions. 

* @param thelnteraction the {@link InteractionClassHandle} of the 
interaction being sent 

* @param theParameters a {@link ParameterHandleValueMap} holding 
the interaction values, keyed by parameter 

* @param regions the {@link RegionHandleSet} describing the 
distribution regions 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @return the message's {@link MessageRetractionReturn}, should a 
retraction become necessary 

* @throws InvalidLogicalTime if the specified 
<code>LogicalTime</code> is invalid 

* @throws InteractionClassNotDefined if 
<code>theInteraction</code> isn't recognized by the RTI 

* @throws InteractionClassNotPublished if the federate does not 
publish <code>theInteraction</code> 

* @throws InteractionParameterNotDefined if one of 
<code>theParameters</code> isn't recognized in the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #sendInteraction sendlnteraction 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,LogicalTime,OrderTy 
pe,RegionHandleSet) 

* @see #retract retract 

*/ 


DRDC Valcartier TR 2007-412 


331 



public MessageRetractionReturn 
sendlnteractionWithRegions( 

InteractionClassHandle theInteraction, 
ParameterHandleValueMap theParameters, 
RegionHandleSet regions, 

byte[] userSuppliedTag 

LogicalTime theTime) 

throws InteractionClassNotDefined, 

InteractionClassNotPublished, 
InteractionParameterNotDefined, 
InvalidRegion, 

RegionNotCreatedByThisFederate, 
InvalidRegionContext, 
InvalidLogicalTime, 
FederateNotExecutionMember, 
SavelnProgress, 

RestorelnProgress, 

RTI int ernal Error ,- 


332 


DRDC Valcartier TR 2007-412 



* * 


* Requests that attribute value updates be provided for the 
specified instance attributes 

* if they fall within the specified regions. 

* @param theClass the {@link ObjectClassHandle} of the object 
class being polled 

* @param attributesAndRegions an {@link 
AttributeSetRegionSetPairList} listing the attributes and regions 
being polled 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectClassNotDefined if <code>theClass</code> isn't 
recognized by the RTI 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws InvalidRegion if the {@link RegionHandle} is invalid or 
the region is still a template 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws InvalidRegionContext if the dimensions of one of the 
regions are not a subset of the available dimensions of some attribute 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #requestAttributeValueUpdate requestAttributeValueUpdate 

*/ 

public void 

requestAttributeValueUpdateWithRegions( 

Obj ectClassHandle theClass, 

AttributeSetRegionSetPairList attributesAndRegions, 
byte[] userSuppliedTag) 

throws Obj ectClassNotDefined, 

AttributeNotDefined, 

InvalidRegion, 

RegionNotCreatedByThisFederate, 

InvalidRegionContext, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


333 



// RTI Support Services // 


11111111111111111111111111 

// 10.2 

j * * 

* Requests the {@link ObjectClassHandle} of the class bearing the 
specified name. 

* @param theName a {@link java.lang.String} holding the fully 
qualified class name 

* @return the requested {@link ObjectClassHandle} 

* @throws NameNotFound if the name could not be found in the FOM 
Document Data 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getKnownObj ectClassHandle getKnownObj ectClassHandle 

* @see #getObjectClassName getObjectClassName 
*/ 

public Obj ectClassHandle 
getObj ectClassHandle( 

String theName) 
throws NameNotFound, 

FederateNotExecutionMember, 

RTIinternalError; 


// 10.3 

j * * 

* Requests the (fully qualified) name of the object class bearing 
the specified {@link ObjectClassHandle}. 

* @param theHandle an {@link ObjectClassHandle} 

* @return the requested class name as a {@link java.lang.String} 

* @throws InvalidObjectClassHandle if the {@link 
ObjectClassHandle} was not recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getObjectClassHandle getObjectClassHandle 
*/ 

public String 
getObj ectClassName( 

Obj ectClassHandle theHandle) 
throws InvalidObj ectClassHandle, 

FederateNotExecutionMember, 

RTIinternalError; 


334 


DRDC Valcartier TR 2007-412 



* * 


* Requests the {@link AttributeHandle} of the specified class' 
attribute bearing the specified name. 

* @param whichClass the {@link ObjectClassHandle} of the class to 
which the attribute belongs 

* @param theName a {@link java.lang.String} holding the attribute 

name 

* @return the requested {@link AttributeHandle} 

* @throws InvalidObjectClassHandle if the {@link 
ObjectClassHandle} was not recognized 

* @throws NameNotFound if the name could not be found in the FOM 
Document Data 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getAttributeName getAttributeName 

*/ 

public AttributeHandle 
getAttributeHandle( 

Obj ectClassHandle whichClass, 

String theName) 

throws InvalidObj ectClassHandle, 

NameNotFound, 

FederateNotExecutionMember, 

RTI internalError ,- 


// 10.5 

j * * 

* Requests the name of the specified attribute of the specified 
class. 

* @param whichClass the {@link ObjectClassHandle} of the class to 
which the attribute belongs 

* @param theHandle an {@link AttributeHandle} 

* @return the requested name as a {@link java.lang.String} 

* @throws InvalidObjectClassHandle if the {@link 
ObjectClassHandle} was not recognized 

* @throws InvalidAttributeHandle if the {@link AttributeHandle} 
was not recognized within the specified context 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getAttributeHandle getAttributeHandle 
*/ 

public String 
getAttributeName( 

Obj ectClassHandle whichClass, 

AttributeHandle theHandle) 
throws InvalidObj ectClassHandle, 

InvalidAttributeHandle, 

AttributeNotDefined, 

FederateNotExecutionMember, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


335 



* * 


* Requests the {@link InteractionClassHandle} bearing the 
specified (fully qualified) name. 

* @param theName a {@link java.lang.String} holding the 
interaction class name 

* @return the requested {@link InteractionClassHandle} 

* @throws NameNotFound if the name could not be found in the FOM 
Document Data 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getInteractionClassName getInteractionClassName 

*/ 

public InteractionClassHandle 
getlnteractionClassHandle( 

String theName) 
throws NameNotFound, 

FederateNotExecutionMember, 

RTIinternalError; 


II 10.7 

j * * 

* Requests the (fully qualified) name of the specified interaction 
class . 

* @param theHandle the {@link InteractionClassHandle} 

* @return the requested name as a {@link java.lang.String} 

* @throws InvalidlnteractionClassHandle if the {@link 
InteractionClassHandle} was not recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getInteractionClassHandle getlnteractionClassHandle 
*/ 

public String 
getlnteractionClassName( 

InteractionClassHandle theHandle) 
throws InvalidlnteractionClassHandle, 

FederateNotExecutionMember, 

RTIinternalError; 


336 


DRDC Valcartier TR 2007-412 



* * 


* Requests the {@link ParameterHandle} of the interaction class' 
parameter bearing the specified (fully qualified) name. 

* @param whichClass the {@link InteractionClassHandle} to which 
the parameter belongs 

* @param theName a {@link java.lang.String} holding the name of 
the parameter 

* @return the requested {@link ParameterHandle} 

* @throws InvalidlnteractionClassHandle if the {@link 
InteractionClassHandle} was not recognized 

* @throws NameNotFound if the name could not be found in the FOM 
Document Data 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getParameterName getParameterName 

*/ 

public ParameterHandle 
getParameterHandle( 

InteractionClassHandle whichClass, 

String theName) 

throws InvalidlnteractionClassHandle, 

NameNotFound, 

FederateNotExecutionMember, 

RTIinternalError; 


j * * 

* Requests the name of the interaction class' parameter bearing 
the specified {@link ParameterHandle}. 

* @param whichClass the {@link InteractionClassHandle} to which 
the parameter belongs 

* @param theHandle the parameter's {@link ParameterHandle} 

* @return the requested name as a {@link java.lang.String} 

* @throws InvalidlnteractionClassHandle if the {@link 
InteractionClassHandle} was not recognized 

* @throws InvalidParameterHandle if the {@link ParameterHandle} 
was not recognized within the specified context 

* @throws InteractionParameterNotDefined if <code>theHandle</code> 
isn't recognized in the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getParameterHandle getParameterHandle 

*/ 

public String 
getParameterName( 

InteractionClassHandle whichClass, 

ParameterHandle theHandle) 

throws InvalidlnteractionClassHandle, 

InvalidParameterHandle, 

InteractionParameterNotDefined, 

FederateNotExecutionMember, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


337 



* * 


* Requests the {@link ObjectlnstanceHandle} of the object instance 
bearing the specified name. 

* @param theName a {@link java.lang.String} holding the name of 
the object instance 

* @return the requested {@link ObjectlnstanceHandle} 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getObj ectlnstanceName getObj ectlnstanceName 
*/ 

public Obj ectlnstanceHandle 
getObj ectlnstanceHandle( 

String theName) 

throws Obj ectlnstanceNotKnown, 

FederateNotExecutionMember, 

RTIinternalError,- 

// 10.11 

j * * 

* Requests the name of the object instance bearing the specified 
{@link ObjectlnstanceHandle}. 

* @param theHandle the {@link ObjectlnstanceHandle} of the object 
instance 

* @return the requested name as a {@link java.lang.String} 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getObj ectlnstanceHandle getObj ectlnstanceHandle 
*/ 

public String 

getObj ectlnstanceName( 

Obj ectlnstanceHandle theHandle) 
throws Obj ectlnstanceNotKnown, 

FederateNotExecutionMember, 

RTI internalError ,- 


338 


DRDC Valcartier TR 2007-412 



// 10.12 

j * * 

* Requests the {@link DimensionHandle} of the dimension bearing 
the specified name. 

* @param theName a {@link java.lang.String} holding the name of 
the dimension 

* @return the requested {@link DimensionHandle} 

* @throws NameNotFound if the name could not be found in the FOM 
Document Data 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getDimensionName getDimensionName 
*/ 

public DimensionHandle 
getDimensionHandle( 

String theName) 
throws NameNotFound, 

FederateNotExecutionMember, 

RTIinternalError; 

// 10.13 

j * * 

* Requests the name of the dimension bearing the specified {@link 
DimensionHandle}. 

* @param theHandle the {@link DimensionHandle} of the dimension 

* @return the requested name as a {@link java.lang.String} 

* @throws InvalidDimensionHandle if one of the {@link 
DimensionHandle}s is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getDimensionHandle getDimensionHandle 
*/ 

public String 
getDimensionName( 

DimensionHandle theHandle) 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


339 



// 10.14 

j * * 

* Requests the upper bound of the specified dimension. All 
dimensions have zero as their lower bound. 

* @param theHandle the {@link DimensionHandle} of the dimension 

* @return the requested upper bound as a <code>long</code> 

* @throws InvalidDimensionHandle if one of the {@link 
DimensionHandle}s is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

*/ 

public long 

getDimensionUpperBound( 

DimensionHandle theHandle) 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError,- 

// 10.15 

j * * 

* Requests the available dimensions of the specified class 
attribute. 

* @param whichClass the {@link ObjectClassHandle} 

* @param theHandle the {@link AttributeHandle} 

* @return the requested {@link DimensionHandleSet} 

* @throws InvalidObjectClassHandle if the {@link 
ObjectClassHandle} was not recognized 

* @throws InvalidAttributeHandle if the {@link AttributeHandle} 
was not recognized within the specified context 

* @throws AttributeNotDefined if an attribute could not be 
recognized within the supplied context 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 
*/ 

public DimensionHandleSet 

getAvailableDimensionsForClassAttribute( 

Obj ectClassHandle whichClass, 

AttributeHandle theHandle) 
throws InvalidObj ectClassHandle, 

InvalidAttributeHandle, 

AttributeNotDefined, 

FederateNotExecutionMember, 

RTI internalError ,- 


340 


DRDC Valcartier TR 2007-412 



// 10.16 

j * * 

* Requests the {@link ObjectClassHandle} of the class the 
specified object instance is known under. 

* @param theObject the {@link ObjectlnstanceHandle} of the object 
instance 

* @return the requested {@link ObjectClassHandle} 

* @throws ObjectlnstanceNotKnown if the RTI considers that the 
federate has not discovered <code>theObject</code> 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getObjectClassHandle getObjectClassHandle 

* @see #getObjectClassName getObjectClassName 
*/ 

public Obj ectClassHandle 
getKnownObj ectClassHandle( 

Obj ectlnstanceHandle theObj ect) 
throws Obj ectlnstanceNotKnown, 

FederateNotExecutionMember, 

RTIinternalError; 

// 10.17 

j * * 

* Requests the available dimensions of the specified interaction. 

* @param theHandle the {@link InteractionClassHandle} 

* @return the requested {@link DimensionHandleSet} 

* @throws InvalidlnteractionClassHandle if the {@link 
InteractionClassHandle} was not recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 
*/ 

public DimensionHandleSet 

getAva11ableDimensionsForInteractionClass( 

InteractionClassHandle theHandle) 
throws InvalidlnteractionClassHandle, 

FederateNotExecutionMember, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


341 



* * 


* Requests the {@link TransportationType} bearing the specified 
name, as defined in the FDD Transportation Table. 

* @param theName a {@link java.lang.String} holding the 
transportation type's name 

* @return the requested {@link TransportationType} 

* @throws InvalidTransportationName if the name is not recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getTransportationName getTransportationName 
*/ 

public TransportationType 
getTransportationType( 

String theName) 

throws InvalidTransportationName, 

FederateNotExecutionMember, 

RTIinternalError; 


j * * 

* Requests the name of the specified {@link TransportationType} 
as defined in the FDD Transportation Table. 

* @param theType the {@link TransportationType} for which to 
return the name 

* @return the requested name as a {@link java.lang.String} 

* @throws InvalidTransportationType if the {@link 
TransportationType} is not recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getTransportationType getTransportationType 

*/ 

public String 
getTransportationName( 

TransportationType theType) 
throws InvalidTransportationType, 

FederateNotExecutionMember, 

RTIinternalError; 


342 


DRDC Valcartier TR 2007-412 



* * 


* Requests the {@link OrderType} bearing the specified name, as 
defined in the IEEE 1516 specification. 

* @param theName a {@link java.lang.String} holding the ordering 
type's name 

* @return the requested {@link OrderType} 

* @throws InvalidOrderName if the name is not recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getOrderName getOrderName 
*/ 

public OrderType 
getOrderType( 

String theName) 
throws InvalidOrderName, 

FederateNotExecutionMember, 

RTIinternalError,- 

// 10.21 

j * * 

* Requests the name of the specified {@link OrderType}, as defined 
in the IEEE 1516 specification. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 changes the parameter 
from "theHandle" to "theType". 

* @param theType the {@link OrderType} for which to return the 

name 

* @return the requested name as a {@link java.lang.String} 

* @throws InvalidOrderType if the {@link OrderType} is not 
recognized 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #getOrderType getOrderType 
*/ 

public String 
getOrderName( 

OrderType theType) 
throws InvalidOrderType, 

FederateNotExecutionMember, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


343 



* * 


* Turns the object class relevance advisory switch on for the 
federate. 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws ObjectClassRelevanceAdvisorySwitchlsOn if the advisory 
switch is already on 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableObj ectClassRelevanceAdvisorySwitch 
disableObj ectClassRelevanceAdvisorySwitch 

* @see FederateAmbassador#startRegistrationForObjectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObjectClass 
stopRegistrationForObj ectClass 

*/ 

public void 

enableObj ectClassRelevanceAdvisorySwitch() 
throws FederateNotExecutionMember, 

Obj ectClassRelevanceAdvisorySwitchlsOn, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 

// 10.23 

j * * 

* Turns the object class relevance advisory switch off for the 
federate. 

* @throws ObjectClassRelevanceAdvisorySwitchlsOff if the advisory 
switch is already off 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableObj ectClassRelevanceAdvisorySwitch 
enableObj ectClassRelevanceAdvisorySwitch 

* @see FederateAmbassador#startRegistratIonForObj ectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistratIonForObj ectClass 
stopRegistratIonForObj ectClass 

*/ 

public void 

disableObj ectClassRelevanceAdvisorySwitch() 
throws Obj ectClassRelevanceAdvisorySwitchlsOff, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


344 


DRDC Valcartier TR 2007-412 



// 10.24 

j * * 

* Turns the attribute relevance advisory switch on for the 
federate. 

* @throws AttributeRelevanceAdvisorySwitchlsOn if the advisory 
switch is already on 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch 

*/ 

public void 

enableAttributeRelevanceAdvisorySwitch() 
throws AttributeRelevanceAdvisorySwitchlsOn, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 

// 10.25 

j * * 

* Turns the attribute relevance advisory switch off for the 
federate. 

* @throws AttributeRelevanceAdvisorySwitchlsOff if the advisory 
switch is already off 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch 

*/ 

public void 

disableAttributeRelevanceAdvisorySwitch() 
throws AttributeRelevanceAdvisorySwitchlsOff, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


345 



* * 


* Turns the attribute scope advisory switch on for the federate. 

* @throws AttributeScopeAdvisorySwitchlsOn if the advisory switch 
is already on 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableAttributeScopeAdvisorySwitch 
disableAttributeScopeAdvisorySwitch 

* @see FederateAmbassador#attributesOutOfScope 
attributesOutOfScope 

* @see FederateAmbassador#attributesInScope attributesInScope 

*/ 

public void 

enableAttributeScopeAdvisorySwitch() 
throws AttributeScopeAdvisorySwitchlsOn, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 

// 10.27 

j * * 

* Turns the attribute scope advisory switch off for the federate. 

* @throws AttributeScopeAdvisorySwitchlsOff if the advisory switch 
is already off 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableAttributeScopeAdvisorySwitch 
enableAttributeScopeAdvisorySwitch 

* @see FederateAmbassador#attributesOutOfScope 
attributesOutOfScope 

* @see FederateAmbassador#attributesInScope attributesInScope 

*/ 

public void 

disableAttributeScopeAdvisorySwitch() 
throws AttributeScopeAdvisorySwitchlsOff, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


346 


DRDC Valcartier TR 2007-412 



* * 


* Turns the interaction relevance advisory switch on for the 
federate. 

* @throws InteractionRelevanceAdvisorySwitchlsOn if the advisory 
switch is already on 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableInteractionRelevanceAdvisorySwitch 
disableInteractionRelevanceAdvisorySwitch 

* @see FederateAmbassador#turnInteractionsOn turnlnteractionsOn 

* @see FederateAmbassador#turnlnteractionsOff turnlnteractionsOff 

*/ 

public void 

enableInteractionRelevanceAdvisorySwitch() 
throws InteractionRelevanceAdvisorySwitchisOn, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 

// 10.29 

j * * 

* Turns the interaction relevance advisory switch off for the 
federate. 

* @throws InteractionRelevanceAdvisorySwitchlsOff if the advisory 
switch is already off 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableInteractIonRelevanceAdvisorySwitch 
enableInteractionRelevanceAdvisorySwitch 

* @see FederateAmbassador#turnlnteractionsOn turnlnteractionsOn 

* @see FederateAmbassador#turnlnteractionsOff turnlnteractionsOff 

*/ 

public void 

disablelnteractionRelevanceAdvisorySwitch() 
throws InteractionRelevanceAdvisorySwitchisOff, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


347 



* Requests the {@link DimensionHandleSet} of the specified region. 

* The specified region must either have been {@link #createRegion 
created} by the invoking federate 

* or conveyed to it in a {@link RegionHandleSet} callback 
argument. 

* @param region the {@link RegionHandle} of the region template, 
specification, or realization 

* @return A {@link DimensionHandleSet} specifying the dimensions 
of the region 

* @throws InvalidRegion if the {@link RegionHandle} is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see 

FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle,Attribu 
teHandleValueMap,byte[],OrderType,TransportationType,RegionHandleSet) 

* @see 

FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle,Attribu 
teHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Order 
Type,RegionHandleSet) 

* @see 

FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle,Attribu 
teHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Order 
Type,MessageRetractionHandle,RegionHandleSet) 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,RegionHandleSet) 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,LogicalTime,OrderTy 
pe,RegionHandleSet) 

* @see 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Parameter 
HandleValueMap,byte[],OrderType,TransportationType,LogicalTime,OrderTy 
pe,MessageRetractionHandle,RegionHandleSet) 

*/ 

public DimensionHandleSet 
getDimensionHandleSet ( 

RegionHandle region) 
throws InvalidRegion, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


348 


DRDC Valcartier TR 2007-412 



* * 


* Requests the {@link RangeBounds} of the specified dimension of 
the specified region specification or realization. 

* This service may not be invoked on region templates. 

* @param region the {@link RegionHandle} of the region template or 
specification 

* @param dimension the {@link DimensionHandle} of the dimension 

* @return the requested {@link RangeBounds} 

* @throws InvalidRegion if the {@link RegionHandle} is invalid 

* @throws RegionDoesNotContainSpecifiedDimension if the specified 
region does not contain the specified dimension 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #setRangeBounds setRangeBounds 

* @see #commitRegionModifications commitRegionModifications 
*/ 

public RangeBounds 
getRangeBounds( 

RegionHandle region, 

DimensionHandle dimension) 
throws InvalidRegion, 

RegionDoesNotContainSpecifiedDimension, 
FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


349 



* * 


* Sets the {@link RangeBounds} of the specified dimension of the 
specified region. 

* @param region the {@link RegionHandle} of the region template or 
specification 

* @param dimension the {@link DimensionHandle} of the dimension 

* @param bounds the {@link RangeBounds} to set 

* @throws InvalidRegion if the {@link RegionHandle} is invalid 

* @throws RegionNotCreatedByThisFederate if the federate does not 
own (did not create) one of the regions in the set 

* @throws RegionDoesNotContainSpecifiedDimension if the specified 
region does not contain the specified dimension 

* @throws InvalidRangeBound if the {@link RangeBounds} is invalid 
(the lower bound is smaller than the upper) 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #getRangeBounds getRangeBounds 

* @see #commitRegionModifications commitRegionModifications 
*/ 

public void 
setRangeBounds( 

RegionHandle region, 

DimensionHandle dimension, 

RangeBounds bounds) 

throws InvalidRegion, 

RegionNotCreatedByThisFederate, 

RegionDoesNotContainSpecifiedDimension, 

InvalidRangeBound, 

FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTI internalError,- 


350 


DRDC Valcartier TR 2007-412 



// 10.33 

j * * 

* Projects a {@link FederateHandle} onto the 
<code>Federates</code> dimension 

* (defined by the Management Object Model (MOM)) for 
<code>Region</code> specification purposes. 

* @param federateHandle the <code>FederateHandle</code> to project 
onto the <code>Federates</code> dimension 

* @return a <code>long</code> representing the federate's co¬ 
ordinate along the <code>Federates</code> dimension 

* @throws InvalidFederateHandle if the specified federate handle 
is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

*/ 

public long 

normalizeFederateHandle( 

FederateHandle federateHandle) 
throws InvalidFederateHandle, 

FederateNotExecutionMember, 

RTIinternalError; 

// 10.34 

j * * 

* Projects a {@link ServiceGroup} onto the 
<code>ServiceGroups</code> dimension 

* (defined by the Management Object Model (MOM)) for 
<code>Region</code> specification purposes. 

* <p> 

* The <code>ServiceGroup</code> class uses privately the values 4 
through 10 whereas the Management Object Model uses 0 through 6. 

* <code>normalizeServiceGroup</code> handles the translation. 

* <p> 

* The <code>InvalidServiceGroup</code> exception was missing from 
Annex B (but not from the 10.34 clause). 

* @param group the <code>ServiceGroup</code> to project onto the 
<code>ServiceGroups</code> dimension 

* @return a <code>long</code> representing the group's co-ordinate 
along the <code>ServiceGroups</code> dimension 

* @throws InvalidServiceGroup if the specified service group 
designator is invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

*/ 

public long 
normalizeServiceGroup( 

ServiceGroup group) 
throws InvalidServiceGroup, 

FederateNotExecutionMember, 

RTIinternalError; 


DRDC Valcartier TR 2007-412 


351 



* * 


* In the DoD Interpretations of IEEE 1516-2000v2, this service is 
deleted, 

* along with the InitializePreviouslylnvoked exception (which it 
was the only one to throw). 

* @throws RTIinternalError if something else goes wrong 

*/ 

//public j ava.util.Properties 
//initializeRTI ( 

// j ava.util.Properties properties) 

//throws InitializePreviouslylnvoked, 

// BadlnitializationParameter, 

// RTI internalError,- 


j * * 

* In the DoD Interpretations of IEEE 1516-2000v2, this service is 
deleted, 

* along with the InitializeNeverlnvoked and 
SomeFederateJoinedToAnExecution exceptions (which it was the only one 
to throw). 

* @throws RTIinternalError if something else goes wrong 

*/ 

//public void 
//finalizeRTI () 

//throws InitializeNeverlnvoked, 

// SomeFederateJoinedToAnExecution, 

// RTI internalError ,- 


// 10.37 

j * * 

* Requests that the RTI invoke a single federate callback or, if 
there are none pending, that 

* the method time out after the specified real time has elapsed. 

* <p> 

* If callbacks are disabled, the method times out after the 
specified real-time interval has 

* elapsed but nevertheless returns <code>true</code> even though 
no callbacks are invoked. 

* @param seconds A <code>double</code> specifying the time out in 
real-time seconds (with a precision of at least 1 ms) 

* @return <code>true</code> iff there was at least one callback 
pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #evokeMultipleCallbacks evokeMultipleCallbacks 

* @see #enableCallbacks enableCallbacks 

* @see #disableCallbacks disableCallbacks 

*/ 

public boolean 
evokeCallback( 

double seconds) 

throws FederateNotExecutionMember, 

RTI internalError ,- 


352 


DRDC Valcartier TR 2007-412 



* * 


* Requests that the RTI invoke federate callbacks or wait until a 
minimum real time has elapsed 

* and continue doing so until either it runs out of callbacks or a 
maximum real time is reached. 

* <p> 

* This method will wait for at least the <code>minimumTime</code> ; 
invoking callbacks (if any) during 

* that real-time interval. Once that interval has elapsed, it 
returns when it runs out of callbacks 

* or after <code>maximumTime</code> has elapsed, whichever occurs 
first. 

* <p> 

* If callbacks are disabled, the method times out after the 
specified maximum real-time interval has 

* elapsed but nevertheless returns <code>true</code> even though 
no callbacks are invoked. 

* @param minimumTime A <code>double</code> specifying the minimum 
real-time to wait for, in seconds (with a precision of at least 1 ms) 

* @param maximumTime A <code>double</code> specifying the maximum 
real-time to wait for, in seconds (with a precision of at least 1 ms) 

* @return <code>true</code> iff there was at least one callback 
pending 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong 

* @see #evokeCallback evokeCallback 

* @see #enableCallbacks enableCallbacks 

* @see #disableCallbacks disableCallbacks 

*/ 

public boolean 
evokeMultipleCallbacks( 
double minimumTime, 
double maximumTime) 
throws FederateNotExecutionMember, 

RTI internalError ,- 


DRDC Valcartier TR 2007-412 


353 



* * 


* Instructs the RTI to deliver callbacks when the {@link 
#evokeCallback evokeCallback} and 

* {@link #evokeMultipleCallbacks evokeMultipleCallbacks} methods 
are invoked. This is the default federate state. 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #disableCallbacks disableCallbacks 

* @see #evokeCallback evokeCallback 

* @see #evokeMultipleCallbacks evokeMultipleCallbacks 

*/ 

public void 
enableCallbacks() 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


j * * 

* Instructs the RTI to withold callbacks when the {@link 
#evokeCallback evokeCallback} and 

* {@link #evokeMultipleCallbacks evokeMultipleCallbacks} methods 
are invoked. These methods then time out 

* as instructed but nevertheless return <code>true</code> to 
indicate callbacks are pending. 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws SavelnProgress if the federate is in one of the save-in- 
progress states 

* @throws RestorelnProgress if the federate is in one of the 
restore-in-progress states 

* @throws RTIinternalError if something else goes wrong 

* @see #enableCallbacks enableCallbacks 

* @see #evokeCallback evokeCallback 

* @see #evokeMultipleCallbacks evokeMultipleCallbacks 

*/ 

public void 
disableCallbacks () 

throws FederateNotExecutionMember, 

SavelnProgress, 

RestorelnProgress, 

RTIinternalError; 


354 


DRDC Valcartier TR 2007-412 



//API-specific services 

j * * 

* Supplies the RTIambassador's {@link AttributeHandleFactory}, 
which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link AttributeHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public AttributeHandleFactory 
getAttributeHandleFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link AttributeHandleSetFactory} 
which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return the RTIambassador's {@link AttributeHandleSetFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public AttributeHandleSetFactory 
getAttributeHandleSetFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link 
AttributeHandleValueMapFactory}, which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link 
AttributeHandleValueMapFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public AttributeHandleValueMapFactory 
getAttributeHandleValueMapFactory() 
throws FederateNotExecutionMember; 


DRDC Valcartier TR 2007-412 


355 



* * 


* Supplies the RTIambassador's {@link 
AttributeSetRegionSetPairListFactory}, which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link 
AttributeSetRegionsetPairListFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public AttributeSetRegionSetPairListFactory 
getAttributeSetRegionsetPairListFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link DimensionHandleFactory}, 
which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link DimensionHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public DimensionHandleFactory 
getDimensionHandleFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link DimensionHandleSetFactory} 
which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link DimensionHandleSetFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public DimensionHandleSetFactory 
getDimensionHandleSetFactory() 
throws FederateNotExecutionMember; 


356 


DRDC Valcartier TR 2007-412 



* * 


* Supplies the RTIambassador's {@link FederateHandleFactory}, 
which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link FederateHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public FederateHandleFactory 
getFederateHandleFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link FederateHandleSetFactory} 
which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link FederateHandleSetFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public FederateHandleSetFactory 
getFederateHandleSetFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link 
InteractionClassHandleFactory}, which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link 
InteractionClassHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public InteractionClassHandleFactory 
getInteractionClassHandleFactory() 
throws FederateNotExecutionMember; 


DRDC Valcartier TR 2007-412 


357 



* Supplies the RTIambassador's {@link ObjectClassHandleFactory}, 
which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link ObjectClassHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public Obj ectClassHandleFactory 
getObj ectClassHandleFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link 

ObjectlnstanceHandleFactory}, which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link ObjectlnstanceHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public Obj ectlnstanceHandleFactory 
getObj ectlnstanceHandleFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link ParameterHandleFactory}, 
which can be used to 

* decode callback arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link ParameterHandleFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public ParameterHandleFactory 
getParameterHandleFactory() 
throws FederateNotExecutionMember; 


358 


DRDC Valcartier TR 2007-412 



* * 


* Supplies the RTIambassador's {@link 
ParameterHandleValueMapFactory}, which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link 
ParameterHandleValueMapFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public ParameterHandleValueMapFactory 
getParameterHandleValueMapFactory() 
throws FederateNotExecutionMember; 

j * * 

* Supplies the RTIambassador's {@link RegionHandleSetFactory} 
which can be used to 

* prepare method arguments. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 added "throws 
FederateNotExecutionMember" 

* to each of the get*Factory services. 

* @return The RTIambassador's {@link RegionHandleSetFactory} 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

*/ 

public RegionHandleSetFactory 
getRegionHandleSetFactory() 
throws FederateNotExecutionMember; 

j * * 

* Identifies the RTI's version. 

* @return The {@link java.lang.String} "1516.1.5" 

*/ 

public String 
getHLAversion() ; 

} 

//end RTIambassador 


DRDC Valcartier TR 2007-412 


359 



// File: SaveFailureReason.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the reason why the save operation of a federate 
failed. 

* It is reported by the {@link FederateAmbassador#federationNotSaved 
federationNotSaved} callback. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see hla.rtil516.FederateAmbassador#federationNotSaved 
federationNotSaved 

*/ 

public final class 
SaveFailureReason 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a SaveFailureReason must be 
initialized with one of the defined static values. 

* @param otherSaveFailureReasonValue must be a defined static 
value or another instance. 

*/ 

public SaveFailureReason(SaveFailureReason 
otherSaveFailureReasonValue) 

{ 

value = otherSaveFailureReasonValue. value; 


j * * 

* Package-only (default access) constructor. Unused. 

* @param value to assign to the instance; must be one of the 
static ones 

*/ 

SaveFailureReason(int value) 
throws RTIinternalError 


_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError("SaveFailureReason: illegal value 
+ value); 


360 


DRDC Valcartier TR 2007-412 



j k k 

* Private constructor; it is used to generate the static values. 

*/ 

private 

SaveFailureReason () 

{ 

_value = _nextToAssign++; 


j k k 

* Returns a <code>String</code> representation of the 
<code>SaveFailureReason</code>. 

* @return A {@link java.lang.String} with value 

"SaveFailureReason(n)" where n is <code>this</code> value 
*/ 

public String 
toString() 

{ 

return "SaveFailureReason(" + value + ")"; 


j k k 

* Returns true iff <code>this</code> and 
<code>otherSaveFailureReasonValue</code> represent the same save 
failure reason. 

* @param otherSaveFailureReasonValue The <code>Object</code> to 
compare with 

* @return true iff supplied 
<code>otherSaveFailureReasonValue</code> is of type 
<code>SaveFailureReason</code> and has same value 

*/ 

public boolean 

equals (Object otherSaveFailureReasonValue) 

{ 

if (otherSaveFailureReasonValue instanceof SaveFailureReason) 
return _value == 

((SaveFailureReason)otherSaveFailureReasonValue)._value; 
else 

return false; 


j k k 

* Returns a hash code for <code>this</code>; two 
<code>SaveFailureReason</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return _value; 


DRDC Valcartier TR 2007-412 


361 



//The constant instances 

j * * 

* The RTI was unable to save. 

*/ 

static public final SaveFailureReason 

RTI_UNABLE_TO_SAVE = new SaveFailureReason() ; 

j * * 

* One or more joined federates have invoked the {@link 

RTIambassador#federateSaveNotComplete federateSaveNotComplete} method. 
*/ 

static public final SaveFailureReason 

FEDERATE_REPORTED_FAILURE = new SaveFailureReason(); 

j * * 

* One or more joined federates have resigned from the federation 
execution. 

*/ 

static public final SaveFailureReason 
FEDERATE_RESIGNED = new SaveFailureReason(); 

j * * 

* The RTI has detected failure at one or more of the joined 
federates. 

*/ 

static public final SaveFailureReason 
RTI_DETECTED_FAILURE = new SaveFailureReason(); 

j * * 

* The time stamp specified by the (4.11) {@link 
RTIambassador#requestFederationSave(String,LogicalTime)} 

* request cannot be honored, due to possible race conditions in 
the distributed calculation of GALT (Greatest Available Logical Time). 

*/ 

static public final SaveFailureReason 

SAVE_TIME_CANNOT_BE_HONORED = new SaveFailureReason () ,- 

} 

//end SaveFailureReason 


362 


DRDC Valcartier TR 2007-412 



// File: SaveStatus.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the save status of a federate during a federation save 
operation. 

* It is contained in the {@link FederateHandleSaveStatusPair} 
argument of the {@link FederateAmbassador#federationSaveStatusResponse 
federationSaveStatusResponse} callback. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
SaveStatus 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a <code>SaveStatus</code> must be 
initialized with one of the defined static values. 

* @param otherSaveStatusValue must be a defined static value or 
another instance. 

*/ 

public 

SaveStatus(SaveStatus otherSaveStatusValue) 

{ 

_value = otherSaveStatusValue._value; 


j * * 

* Package-only (default access) constructor. Unused. 

* @param value to assign to the instance; must be one of the 
static ones 

*/ 

SaveStatus(int value) 

throws RTIinternalError 


_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError ("SaveStatus: illegal value 11 + 

value); 


DRDC Valcartier TR 2007-412 


363 



j k k 

* Private constructor; it is used to generate the static values. 

*/ 

private 
SaveStatus() 

{ 

_value = _nextToAssign++; 


j k k 

* Returns a <code>String</code> representation of the 
<code>SaveStatus</code>. 

* @return A {@link java.lang.String} with value "SaveStatus(n)" 
where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "SaveStatus(" + value + 


j k k 

* Returns true iff <code>this</code> and 
<code>otherSaveStatusValue</code> represent the same save status. 

* @param otherSaveStatusValue The <code>Object</code> to compare 

with 

* @return true iff supplied <code>other</code> is of type 
<code>SaveStatus</code> and has same value 

*/ 

public boolean 

equals(Object otherSaveStatusValue) 

{ 

if (otherSaveStatusValue instanceof SaveStatus) 

return _value == ((SaveStatus)otherSaveStatusValue)._value; 
else 

return false; 


j k k 

* Returns a hash code for <code>this</code>; two 
<code>SaveStatus</code>es for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return value; 


364 


DRDC Valcartier TR 2007-412 



//The constant instances 

j * * 

* No save in progress (federate in Active or Restore Request 
Pending states). 

*/ 

static public final SaveStatus 
NO_SAVE_IN_PROGRESS = new SaveStatus(); 

j * * 

* Federate in the Instructed To Save state. 

*/ 

static public final SaveStatus 

FEDERATE_INSTRUCTED_TO_SAVE = new SaveStatus(); 

j * * 

* Federate in the Saving state. 

*/ 

static public final SaveStatus 
FEDERATE_SAVING = new SaveStatus(); 

j * * 

* Federate in the Waiting For Federation To Save state. 

*/ 

static public final SaveStatus 

FEDERATE_WAITING_FOR_FEDERATION_TO_SAVE = new SaveStatus(); 

} 

//end SaveStatus 


DRDC Valcartier TR 2007-412 


365 



// File: ServiceGroup.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the seven HLA service groups (Federation management; 
Declaration management; 

* Object management; Ownership management; Time management; 

* Data distribution management; and Support services). 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 changes one of the constant 
names from "SUPPPORT_SERVICES" to "SUPPORT_SERVICES"- 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

* @see hla.rtil516.RTIambassador#normalizeServiceGroup 
normalizeServiceGroup 

*/ 

public final class 
ServiceGroup 

implements j ava.io.Serializable 

{ 

//each instance's value 
private int _value; 

//initial value for enumeration: fedn mgt is chapter 4 
private static final int _lowestValue = 4; //_lowestValue = 0 may 
be more compatible with the MOM 
//begins at lowest 

private static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a <code>ServiceGroup</code> must 
be initialized with one of the defined static values. 

* @param otherServiceGroupValue must be a defined static value or 
another instance. 

*/ 

public 

ServiceGroup(ServiceGroup otherServiceGroupValue) 

{ 

_value = otherServiceGroupValue._value; 


j * * 

* Package-only (default access) constructor. Unused. 

* @param value to assign to the instance; must be one of the 
static ones 

*/ 

ServiceGroup(int value) 

throws RTIinternalError 

{ 

_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTI internalError (" ServiceGroup: illegal value 11 + 

value) ; 


366 


DRDC Valcartier TR 2007-412 



j k k 

* Private constructor; it is used to generate the static values. 

*/ 

private 
ServiceGroup () 

{ 

_value = _nextToAssign++; 


j k k 

* Returns a <code>String</code> representation of the 
<code>ServiceGroup</code>. 

* @return A {@link java.lang.String} with value "ServiceGroup(n)" 
where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "ServiceGroup(" + _value + ")"; 


j k k 

* Returns true iff <code>this</code> and 
<code>otherServiceGroupValue</code> represent the same service group. 

* @param otherServiceGroupValue The <code>Object</code> to compare 

with 

* @return true iff supplied <code>otherServiceGroupValue</code> is 
of type <code>ServiceGroup</code> and has same value 

*/ 

public boolean 

equals (Object otherServiceGroupValue) 

{ 

if (otherServiceGroupValue instanceof ServiceGroup) 
return _value == 

((ServiceGroup)otherServiceGroupValue)._value; 
else 

return false; 


j k k 

* Returns a hash code for <code>this</code>; two 
<code>ServiceGroup</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return _value; 


DRDC Valcartier TR 2007-412 


367 



//The constant instances 

j * * 

* Methods and callbacks referring to the creation, dynamic 
control, modification and deletion of a federation execution. 

*/ 

static public final ServiceGroup 
FEDERATION_MANAGEMENT = new ServiceGroup () ,- 

j * * 

* Methods and callbacks dealing with the intent of federates to 
generate or consume information. 

*/ 

static public final ServiceGroup 
DECLARATION_MANAGEMENT = new ServiceGroup () ,- 

j * * 

* Methods and callbacks dealing with the registration, 
modification and deletion of object instances, 

* as well as the sending and receipt of interactions. 

*/ 

static public final ServiceGroup 
OBJECT_MANAGEMENT = new ServiceGroup () ,- 

j * * 

* Methods and callbacks dealing with the ownership of instance 
attributes among joined federates. 

* The ability to transfer ownership of instance attributes among 
joined federates supports the 

* cooperative modeling of object instances across a federation. 

*/ 

static public final ServiceGroup 
OWNERSHIP_MANAGEMENT = new ServiceGroup () ,- 

j * * 

* Methods and callbacks dealing with the ordering of the delivery 
of messages throughout the federation execution. 

* Use of these mechanisms permits messages sent by different 
joined federates to be delivered in a consistent 

* order to any joined federate in the federation execution that is 
to receive those messages. 

*/ 

static public final ServiceGroup 
TIME_MANAGEMENT = new ServiceGroup () ,- 

j * * 

* Methods and callbacks dealing with the reduction in the 
transmission and reception of 

* irrelevant data. Whereas DECLARATION_MANAGEMENT services provide 
information on data relevance 

* at the class attribute and interaction class levels, 

DATA_DISTRIBUTION_MANAGEMENT services add 

* the capability to further refine the data requirements at the 
instance attribute and specific 

* interaction levels. 

*/ 

static public final ServiceGroup 

DATA_DISTRIBUTION_MANAGEMENT = new ServiceGroup () ,- 


368 


DRDC Valcartier TR 2007-412 



* * 


* Miscellaneous services utilized by joined federates for 
performing such actions as 

* name-to-handle and handle-to-name transformation, setting 
advisory switches and 

* manipulating regions. 

*/ 

static public final ServiceGroup 
SUPPORT_SERVICES = new ServiceGroup (); 

} 

//end ServiceGroup 


DRDC Valcartier TR 2007-412 


369 



// File: TimeQueryReturn.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Record returned by (8.16) {@link RTIambassador#queryGALT queryGALT} 
and (8.18) {@link RTIambassador#queryLITS queryLITS}. 

* It consists of a guard boolean (<code>timeIsValid</code>) and a 
payload {@link LogicalTime} (<code>time</code>). 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 adds the 

java.io.Serializable implementation and a constructor. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
TimeQueryReturn 

implements j ava.io.Serializable 

{ 

j * * 

* Whether the other field is valid or not. 

*/ 

public boolean 
timelsValid; 

j * * 

* Payload Logical Time. 

*/ 

public LogicalTime 
time; 

j * * 

* Public constructor. 

* @param tiv Whether the {@link LogicalTime} field is valid or not 

* @param It The <code>LogicalTime</code> field 
*/ 

public 

TimeQueryReturn(boolean tiv, 

LogicalTime It) 

{ 

timelsValid = tiv; 
time = It; 


j * * 

* Returns a <code>String</code> representation of the 
<code>TimeQueryReturn</code>. 

* @return A {@link java.lang.String} with value 
"&lt;timelsValid&gt; &lt;time&gt;" 

*/ 

public String 
toString() 

{ 

return 1111 + timelsValid + 11 11 + time; 


370 


DRDC Valcartier TR 2007-412 



* * 


* Returns true iff <code>this</code> and <code>other</code> 
represent the same time query return. 

* @param other The <code>Object</code> to compare with 

* @return true iff supplied <code>other</code> is of type 
<code>TimeQueryReturn</code> and has same value 

*/ 

public boolean 
equals (Object other) 

{ 

if (other instanceof TimeQueryReturn) 

{ 

TimeQueryReturn tqrOther = (TimeQueryReturn)other,- 
if ((timelsValid == false) && (tqrOther.timelsValid == 

false) ) 

{ 

//When timelsValid is false, the payloads are ignored 
return true; 

} 

else if ((timelsValid == true) && (tqrOther.timelsValid == 

true) ) 


//When timelsValid is true, the payloads must match 
return time.equals (tqrOther . time) ,- 

} 

else 


//mismatched timelsValid fields 
return false,- 


else 


//Not the same classes 
return false,- 


j * * 

* Returns a hash code for <code>this</code>; two 
<code>TimeQueryReturn</code>s for which <code>equals()</code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return (timelsValid ? time.hashCode() : 7); 


//end TimeQueryReturn 


DRDC Valcartier TR 2007-412 


371 



// File: TransportationType.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* An enumerated type (not a Java {@link java.util.Enumeration}l) 

* representing the RTI-provided means of message transmission between 
joined federates. 

* Transportation Type defaults are defined at the attribute and 
parameter level by the FOM Document Data; these may be overridden by 
their owners. 

* The two core TransportationTypes are: 

* <ul > 

* <li><code>HLAreliable</code>: provides reliable delivery of data in 
the sense that TCP/IP delivers its data reliably 

* <li><code>HLAbestEffort</code>: makes an effort to deliver data in 
the sense that UDP provides best-effort delivery 

* </ul> 

* Additional <code>TransportationType</code>s may be provided by 
specific RTIs. 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public class 
TransportationType 

implements j ava.io.Serializable 

{ 

j * * 

* Each instance's value. 

*/ 

protected int _value; 

//initial value for enumeration 

private static final int _lowestValue = 1; 

j * * 

* The enumeration begins at the lowest value. 

*/ 

protected static int _nextToAssign = _lowestValue; 

j * * 

* This is the only public constructor. 

* Each user-defined instance of a <code>TransportationType</code> 
must be initialized with one of the defined static values. 

* @param otherTransportationTypeValue must be a defined static 
value or another instance. 

*/ 

public TransportationType(TransportationType 
otherTransportationTypeValue) 

{ 

_value = otherTransportationTypeValue._value; 


372 


DRDC Valcartier TR 2007-412 



* * 


* Class and subclass constructor; it is used to generate the 
static values. 

* Because this class is RTI-extendable, the constructor is 
protected instead of private. 

*/ 

protected TransportationType() 

{ 

_value = _nextToAssign++; 


j * * 

* Package-only (default access) constructor. Used by the {@link 
TransportationType#decode decode} method. 

* @param value an <code>int</code> to assign to the instance; must 
be one of the static values 

*/ 

TransportationType(int value) 
throws RTIinternalError 

{ 

_value = value; 

if ((value < _lowestValue) || (value >= _nextToAssign)) 

throw new RTIinternalError("TransportationType: illegal value 
" + value); 


j * * 

* Returns a <code>String</code> representation of the 
<code>TransportationType</code>. 

* @return A {@link java.lang.String} with value 
"TransportationType (n) 11 where n is <code>this</code> value 

*/ 

public String 
toString() 

{ 

return "TransportationType(" + _value + ")"; 


j * * 

* Returns true iff <code>this</code> and 
<code>otherTransportationTypeValue</code> represent the same 
transportation type. 

* @param otherTransportationTypeValue The <code>Object</code> to 
compare with 

* @return <code>true</code> iff supplied 
<code>otherTransportationTypeValue</code> is of type 
<code>TransportationType</code> and has same value 

*/ 

public boolean 

equals (Object otherTransportationTypeValue) 

{ 

if (otherTransportationTypeValue instanceof TransportationType) 
return _value == 

((TransportationType)otherTransportationTypeValue)._value; 
else 

return false; 


DRDC Valcartier TR 2007-412 


373 



* * 


* Returns a hash code for <code>this</code>; two 
<code>TransportationType</code>s for which <code>equals() </code> is 
<code>true</code> should yield the same hash code. 

* @return An <code>int</code> hash code 
*/ 

public int 
hashCode() 

{ 

return value; 


* Returns the 
representation of 

* @return The 
representation of 

*/ 

public int 
encodedLength( 


length (in bytes) of the <code>byte 
the <code>TransportationType</code> 
length (in bytes) of the <code>byte 
<code>this</code> 


</code> 

</code> 


return 1; 


j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

*/ 

public void 
encode(byte[] buffer, 
int offset) 

{ 

buffer[offset] = (byte)_value; 


374 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>TransportationType</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>TransportationType</code> 

* @param offset where in the <code>buffer</code> the 
<code>TransportationType</code> representation begins 

* @return The <code>TransportationType</code> that was encoded in 
the provided <code>buffer</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded into an instance of the factory's target class 

*/ 

public static TransportationType 
decode(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

int val = buffer[offset] ; 

TransportationType neo; 
try 


neo = new TransportationType(val); 

} 

catch (RTIinternalError e) 

{ 

throw new CouldNotDecode(e.getMessage()); 

} 

return neo; 


//The two core static instances 

j * * 

* Provides reliable delivery of data in the sense that TCP/IP 
delivers its data reliably. 

* Speed is sacrificed for reliability. 

*/ 

static public final TransportationType 
HLA_RELIABLE = new TransportationType(); 

j * * 

* Makes an effort to deliver data in the sense that UDP provides 
best-effort delivery. 

* Reliability is sacrificed for speed. 

*/ 

static public final TransportationType 
HLA_BEST_EFFORT = new TransportationType() ; 

} 

//end TransportationType 


DRDC Valcartier TR 2007-412 


375 



// File: RTIexception.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* Superclass of all exceptions thrown by the RTI. 

* All RTI exceptions must be caught or specified. 

* @author IEEE 

* @version 1516.1.5 (DoD v2) 

*/ 

public class 
RTIexception 

extends Exception 

{ 

j * * 

* Constructs a new exception with the specified detail message. 

* The cause is not initialized, and may subsequently be 
initialized by a call to {@link 

j ava.lang.Throwable#initCause(j ava.lang.Throwable)}. 

* @param msg a {@link java.lang.String} holding the detail 
message, which can be later retrieved by the {@link 

j ava.lang.Throwable#getMessage getMessage} method 
*/ 

public RTIexception(String msg) 

{ 

super (msg) ,- 


//end RTIexception 


376 


DRDC Valcartier TR 2007-412 



The various RTiexception descendents follow a single format. Using the template 
listed below, the expressions <exception_name> and <exception_description> 

are to be replaced successively with the values given by the table that follows the 
template. The proposed exception invalidLogicalTimelnterval is listed 
separately. 


// File: <exception_name>.java 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* <exception_description> 

* @author IEEE 

* ©version 1516.1.5 (DoD v2) 

*/ 

public final class 
<exception_name> 

extends RTiexception 

{ 

j * * 

* Constructs a new exception with the specified detail message. 

* The cause is not initialized, and may subsequently be 
initialized by a call to {@link 

j ava.lang.Throwable#initCause(j ava.lang.Throwable) }. 

* @param msg a {@link java.lang.String} holding the detail 
message, which can be later retrieved by the {@link 

j ava.lang.Throwable#getMessage} method 
*/ 

public 

<exception_name> (String msg) 

{ 

super (msg) ,- 


//end <exception_name> 


DRDC Valcartier TR 2007-412 


377 



<exception_name> 


<exception_description> 


AsynchronousDeliveryAlreadyDisabled 


Exception thrown by the (8.15) {@link 
RTIambassador#disableAsynchronousDelivery 

disableAsynchronousDelivery} method when asynchronous delivery is 
already disabled for the federate. 


AsynchronousDeliveryAlreadyEnabled 


Exception thrown by the (8.14) {@link 

RTIambassador#enableAsynchronousDelivery enableAsynchronousDelivery} 
method when asynchronous delivery is already enabled for the 
federate. 


AttributeAcquisitionWasNotCanceled 


Exception that should be thrown by the (7.15) {@link 
FederateAmbassador#confirmAttributeOwnershipAcquisitionCancellation 
confirmAttributeOwnershipAcquisitionCancellation} callback if the 
federate wishes to repudiate the attribute ownership acquisition 
cancellation. 


AttributeAcquisitionWasNotRequested 


Exception thrown by the (7.14) {@link 
RTIambassador#cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition} method when the attribute 
ownership acquisition request to cancel was not previously made. 

<p> 

It should also be thrown by the (7.7) {@link 
FederateAmbassador#attributeOwnershipAcquisitionNotification 
attributeOwnershipAcquisitionNotification} and (7.10) {©link 
FederateAmbassadorftattributeOwnershipUnavailable 

attributeOwnershipUnavailable} callbacks when the attribute ownership 
acquisition being granted or denied (respectively) is not recognised 
as having been previously requested. 


AttributeAlreadyBeingAcquired 


Exception thrown by the (7.9) {@link 

RTIambassador#attributeOwnershipAcquisitionIfAvailable 
attributeOwnershipAcquisitionlfAvailable} method when an 
unconditional attribute ownership acquisition request is pending for 
the specified attribute instances. 


378 


DRDC Valcartier TR 2007-412 














<exception_name> 


<exception_description> 


AttributeAlreadyBeingDivested 


Exception thrown by the (7.3) {@link 

RTIambassador#negotiatedAttributeOwnershipDivestiture 
negotiatedAttributeOwnershipDivestiture} method when an attribute 
ownership divestiture request is already pending for the specified 
attribute instances. 


AttributeAlreadyOwned 


Exception thrown by the (7.14) {@link 
RTIambassador#cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition} method when the federate’s 
attribute ownership acquisition cancellation occurs too late (i.e. it 
has already been granted ownership). 

<p> 

It should also be thrown by the (7.4) {©link 
FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption}, (7.7) {@link 

FederateAmbassador#attributeOwnershipAcquisitionNotification 
attributeOwnershipAcquisitionNotification}, (7.10) {®link 

FederateAmbassador#attributeOwnershipUnavailable 
attributeOwnershipUnavailable} and (7.15) {®link 

FederateAmbassadorttconfirmAttributeOwnershipAcquisitionCancellation 
confirmAttributeOwnershipAcquisitionCancellation} callbacks when the 
attribute ownership acquisition being offered, granted, denied or 
cancelled (respectively) conflicts with the federate's perceived 
ownership. 


AttributeDivestitureWasNotRequested 


Exception thrown by the (7.14) {@link 
RTIambassador#cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition} method when the federate's 
attribute ownership acquisition cancellation occurs too late (i.e. it 
has already been granted ownership). 

<p> 

It should also be thrown by the (7.4) {@link 

FederateAmbassador#requestAttributeOwnershipAssumption 

requestAttributeOwnershipAssumption}, (7.7) {©link 

FederateAmbassador#attributeOwnershipAcquisitionNotification 

attributeOwnershipAcquisitionNotification}, (7.10) {@link 

FederateAmbassador#attributeOwnershipUnavailable 

attributeOwnershipUnavailable} and (7.15) {©link 

FederateAmbassador#confirmAttributeOwnershipAcquisitionCancellation 
confirmAttributeOwnershipAcquisitionCancellation} callbacks when the 
attribute ownership acquisition being offered, granted, denied or 
cancelled (respectively) conflicts with the federate's perceived 
ownership. 


DRDC Valcartier TR 2007-412 


379 










<exception_name> 


<exception_description> 


At tributeNotDefined 


Exception thrown when the specified attribute could not be recognised 
within the supplied context. The following RTIambassador methods 
throw it: <ul> <li>{@link RTIambassador#publishObjectClassAttributes 
publish} / {@link RTIambassador#unpublishObjectClassAttributes 
unpublish} ObjectClassAttributes <li>{@link 

RTIambassador#subscribeObjectClassAttributes subscribe} (including 
{@link RTIambassador#subscribeObj ectClassAttributesPassively 
Passively} / {©link RTIambassador#unsubscribeObjectClassAttributes 
unsubscribe} ObjectClassAttributes <li>{@link 

RTIambassadorttupdateAttributeValues updateAttributeValues} (both 
forms) <li>changeAttribute {@link 

RTIambassadorttchangeAttributeTransportationType Transportation} / 
{@link RTIambassador#changeAttributeOrderType Order} Type <li>{@link 
RTIambassador#requestAttributeValueUpdate 
requestAttributeValueUpdate} (both forms) {@link 

RTIambassadorttrequestAttributeValueUpdateWithRegions [WithRegions]} 
<li>{@link RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditional} / {@link 

RTIambassador#negotiatedAttributeOwnershipDivestiture negotiated} 
AttributeOwnershipDivestiture {@link 

RTIambassador#attributeOwnershipDivestitureIfWanted [Ifwanted]} 
<li>{@link 

RTIambassadorttcancelNegotiatedAttributeOwnershipDivestiture 
cancelNegotiatedAttributeOwnershipDivestiture} <li>{@link 
RTIambassador#confirmDivestiture confirmDivestiture} <li>{@link 
RTIambassador#cancelAttributeOwnershipAcquisition [cancel]} {@link 
RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} {@link 

RTIambassadorttattributeOwnershipAcquisitionlfAvailable [IfAvailable]} 
<li>{@link RTIambassador#queryAttributeOwnership 
queryAttributeOwnership} <li>{@link 

RTIambassadorttisAttributeOwnedByFederate isAttributeOwnedByFederate} 
<li>{@link RTIambassador#registerObj ectlnstanceWithRegions 
registerObjectlnstanceWithRegions} (both forms) <li>{@link 
RTIambassadorttassociateRegionsForUpdates associate} / {®link 
RTIambassador#-unassociateRegionsForUpdates unassociate} 
RegionsForUpdates <li>{@link 

RTIambassador#subscribeObjectClassAttributesWithRegions subscribe} 
(including {@link 

RTIambassador#subscribeObjectClassAttributesPassivelyWithRegions 
Passively}) / (@link 

RTIambassador#unsubscribeObj ectClassAttributesWithRegions 
unsubscribe} ObjectClassAttributesWithRegions <li>{@link 
RTIambassador#getAttributeName getAttributeName} <li>{@link 
RTIambassador#getAvai1ableDimensionsForClassAttribute 
getAvailableDimensionsForClassAttribute} </ul> 


380 


DRDC Valcartier TR 2007-412 






<exception_name> 


<exception_description> 


At tributeNotOwned 


Exception thrown when the specified attribute instance(s) was(were) 
not owned by the federate. The following RTIambassador methods throw 
it: <ul> <li>{@link RTIambassador#updateAttributeValues 
updateAttributeValues} (both forms) <li>changeAttribute {@link 
RTIambassador#changeAttributeTransportationType Transportation} / 
{@link RTIambassador#changeAttributeOrderType Order} Type <li>{@link 
RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditional} / {©link 

RTIambassador#negotiatedAttributeOwnershipDivestiture negotiated} 
AttributeOwnershipDivestiture {@link 

RTIambassador#attributeOwnershipDivestiturelfWanted [IfWanted]} 
<li>{@link 

RTIambassadorttcancelNegotiatedAttributeOwnershipDivestiture 
cancelNegotiatedAttributeOwnershipDivestiture} <li>{@link 
RTIambassadorttconfirmDivestiture confirmDivestiture} </ul> 

<p> 

It should also be thrown by the following FederateAmbassador 
callbacks when the federate repudiates ownership of the specified 
attribute instances: <ul> <li>{@link 
FederateAmbassador#provideAttributeValueUpdate 
provideAttributeValueUpdate} <li>turnUpdates {@link 
FederateAmbassador#turnUpdatesOnForObjectInstance On} / {@link 
FederateAmbassador#turnUpdatesOffForObjectInstance Off} 

ForObjectInstance <li>{@link 

FederateAmbassador#requestDivestitureConfirmation 
requestDivestitureConfirmation} <li>{@link 
FederateAmbassador#requestAttributeOwnershipRelease 
requestAttributeOwnershipRelease} </ul> 


At tributeNotPublished 


Exception thrown by the (7.8/7.9) {@link 
RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} {©link 

RTIambassador#attributeOwnershipAcquisitionIfAvailable [IfAvailable]} 
and (9.5) {@link RTIambassadorttregisterObjectInstanceWithRegions 
registerObjectInstanceWithRegions} (both forms) methods when some of 
the attributes to acquire or register aren't published. 

<p> 

It should also be thrown by the (7.4) {@link 
FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} and (7.7) {©link 
FederateAmbassador#attributeOwnershipAcquisitionNotification 
attributeOwnershipAcquisitionNotification} callbacks when some of the 
offered or granted attributes aren't published in the federate's 
opinion. 


DRDC Valcartier TR 2007-412 


381 








<exception_name> 


<exception_description> 


AttributeNotRecognized 


Exception that should be thrown when the specified attributes aren’t 
recognized by the federate in the supplied object class context. The 
following FederateAmbassador callbacks should throw it:<ul> 

<li>{@link FederateAmbassador#reflectAttributeValues 
reflectAttributeValues} (all six forms) <liattributes {@link 
FederateAmbassador#attributesInScope In} / {@link 
FederateAmbassador#attributesOutOfScope OutOf} Scope <li>{@link 
FederateAmbassador#provideAttributeValueUpdate 
provideAttributeValueUpdate} <li>turnUpdates (@link 
FederateAmbassador#turnUpdatesOnForObjectInstance On} / {@link 
FederateAmbassador#turnUpdatesOffForObjectlnstance Off} 

ForObjectInstance <li>{@link 

FederateAmbassador#requestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption} <li>{@link 
FederateAmbassador#requestDivestitureConfirmation 
requestDivestitureConfirmation} <1i>{@link 

FederateAmbassador#attributeOwnershipAcquisitionNotification 

attributeOwnershipAcquisitionNotification} <li>{@link 

FederateAmbassador#attributeOwnershipUnavailable 

attributeOwnershipUnavailable} <li>{@link 

FederateAmbassador#requestAttributeOwnershipRelease 

requestAttributeOwnershipRelease} <li>{@link 

FederateAmbassador#confirmAttributeOwnershipAcquisitionCancellation 
confirmAttributeOwnershipAcquisitionCancellation} <li>{@link 
FederateAmbassador#informAttributeOwnership informAttributeOwnership} 
<li>{@link FederateAmbassadorttattributelsNotOwned 
attributelsNotOwned} <li>{@link 

FederateAmbassador#attributeIsOwnedByRTI attributelsOwnedByRTI} </ul> 


AttributeNotSubscribed 


Exception that should be thrown by the (6.7) {@link 
FederateAmbassador#reflectAttributeValues reflectAttributeValues} 
(all six forms) and (6.15/6.16) attributes {@link 
FederateAmbassador#attributesInScope In} / {®link 

FederateAmbassador#attributesOutOfScope OutOf} Scope callbacks when 
the specified attributes aren't published by the federate in its 
opinion. 


AttributeRelevanceAdvisorySwitchlsOff 


Exception thrown by the (10.25) {@link 
RTIambassador#disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch} method when the attribute 
relevance advisory switch is already off. 


382 


DRDC Valcartier TR 2007-412 










<exception name> 

<exception description> 

AttributeRelevanceAdvisorySwitchlsOn 

Exception thrown by the (10.24) {@link 
RTIambassador#enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch} method when the attribute 
relevance advisory switch is already on. 

AttributeScopeAdvisorySwitchlsOff 

Exception thrown by the (10.27) {@link 
RTIambassadorttdisableAttributeScopeAdvisorySwitch 

disableAttributeScopeAdvisorySwitch} method when the attribute scope 
advisory switch is already off. 

AttributeScopeAdvisorySwitchlsOn 

Exception thrown by the (10.26) {©link 
RTIambassador#enableAttributeScopeAdvisorySwitch 

enableAttributeScopeAdvisorySwitch} method when the attribute scope 
advisory switch is already on. 

CouldNotDecode 

Exception thrown by the <code>decode</code> method of a factory class 
when it fails to decode the specified byte buffer into an instance of 
the factory's target class. The following factory classes throw 
it:<ul> <li>{®link AttributeHandleFactory} <li>{®link 
DimensionHandleFactory} <li>{@link FederateHandleFactory} <li>{@link 
InteractionClassHandleFactory} <li>{@link LogicalTimeFactory} 

<li>{@link LogicalTimelntervalFactory} <li>{@link 

ObjectClassHandleFactory} <li>{®link ObjectInstanceHandleFactory} 
<li>{@link ParameterHandleFactory} <li>{@link OrderType} <li>{@link 
TransportationType} </ul> 

CouldNotDiscover 

Exception that should be thrown by the (6.5) {®link 
FederateAmbassador#discoverObjectInstance discoverObjectInstance} 
callback when it fails for some reason other than an unrecognized 
object class. 

CouldNotInitiateRestore 

Exception that should be thrown by the (4.21) {®link 
FederateAmbassador#initiateFederateRestore initiateFederateRestore} 
callback when it fails for some reason other than an unrecognized 
save label. 


DRDC Valcartier TR 2007-412 


383 
















<exception name> 

<exception description> 

CouldNotOpenFDD 

Exception thrown by the (4.2) {@link 

RTIambassador#createFederationExecution createFederationExecution} 
method when it fails to reach or open the specified FOM Document Data 
(FDD) file. 

DeletePrivilegeNotHeld 

Exception thrown by the (4.2) {@link 

RTIambassador#createFederationExecution createFederationExecution} 
method when it fails to reach or open the specified FOM Document Data 
(FDD) file. 

ErrorReadingFDD 

Exception thrown by the (4.2) (@link 

RTIambassador#createFederationExecution createFederationExecution} 
method when the contents of the FOM Document Data (FDD) file prove 
unsuitable. 

FederateAlreadyExecutionMember 

Exception thrown by the (4.4) (@link 

RTIambassador#]oinFederationExecution joinFederationExecution} method 
when the federate (as represented by the {@link RTIambassador} 
instance) is already joined to any federation execution (not just the 
specified one). 

FederateHasNotBegunSave 

Exception thrown by the (4.14) RTIambassador.federateSave {@link 
RTIambassador#federateSaveNotComplete [Not]} {@link 

RTIambassador#federateSaveComplete Complete} methods if the federate 
is not in the Saving state. 

FederatelnternalError 

Exception that should be thrown by all of the {@link 

FederateAmbassador}'s callbacks when something goes wrong unless a 
more specific exception is appropriate. 

FederateNotExecutionMember 

Exception thrown by nearly all of the {@link RTIambassador}’s methods 
if the federate isn’t joined. 


384 


DRDC Valcartier TR 2007-412 


















<exception_name> 


<exception_description> 


FederateOwnsAttributes 


Exception thrown by the (4.5) {@link 

RTIambassador#resignFederationExecution resignFederationExecution}, 
(6.12) {©link RTIambassador#localDeleteObjectlnstance 
localDeleteObjectlnstance} and (7.8/7.9) {@link 
RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} {@link 

RTIambassador#attributeOwnershipAcquisitionIfAvailable [IfAvailable]} 
methods if the federate, in the first case, owns some instance 
attributes and hasn’t specified a disposal policy; or, in the latter 
cases, owns some of the attributes it is trying to locally delete or 
acquire. 


FederatesCurrentlyJoined 


Exception thrown by the (4.3) {@link 

RTIambassador#destroyFederationExecution destroyFederationExecution} 
method if the federation execution isn't empty. 


FederateServicelnvocationsAreBeingReportedViaMOM 


Exception thrown by the (5.8/9.10) {@link 

RTIambassador#subscribeInteractionClass subscribelnteractionClass} 
{@link RTIambassador#subscribeInteractionClassPassively [Passively]} 
{@link RTIambassador#subscribeInteractionClassWithRegions 
[WithRegions]} methods if service invocations are currently being 
reported via MOM interactions and the specified interaction class is 
<code>HLAmanager.HLAfederate.HLAreport.HLAreportServiceInvocation</co 
de>. Such a subscription would cause an infinite loop (the first 
invocation would trigger a report of itself and so on). 


FederateUnableToUseTime 


Exception thrown by the (4.11) {@link 

RTIambassador#requestFederationSave(String,LogicalTime)} (time- 
stamped form) method if the specified time-stamp, although not in the 
federate's past, is nevertheless too soon to be achievable. 


FederationExecutionAlreadyExists 


Exception thrown by the (4.2) {@link 

RTIambassador#createFederationExecution createFederationExecution} 
method if the specified federation execution already exists. 


DRDC Valcartier TR 2007-412 


385 














<exception_name> 


<exception_description> 


FederationExecutionDoesNotExist 


Exception thrown by the (4.3) {@link 

RTIambassador#destroyFederationExecution destroyFederationExecution} 
and (4.4) {@link RTIambassador#joinFederationExecution 
joinFederationExecution} methods if the specified federation 
execution does not exist. 


IllegalName 


Exception thrown by the (6.2) {@link 

RTIambassadorttreserveObj ectlnstanceName reserveObjectInstanceName} 
method if the specified object instance name is ill-formed. 

<p> 

Object instance names may not be the empty String (’"'); nor begin 
with "HLA" (including all case variations such as "hla" or "Hla"), 
nor equal "na"; there are no other restrictions. 

<p> 

Names are constructed from a combination of letters (a..z and A..Z), 
digits (0. . 9), hyphens and underscores. The period is used to qualify 
a class; it is the "path" character linking a super-class with its 
sub-class. These rules apply to object and interaction classes, 
attributes and parameters, datatypes (including enumerators and 
values), record fields, dimensions, transportation types, 
synchronization point labels and OMT note labels. It is not made 
clear anywhere whether these rules apply to object instance names, 
although this is probably a safe assumption. 


IllegalTimeArithmetic 


Exception thrown by the LogicalTime {@link LogicalTimettadd add} and 
{@link LogicalTime#subtract subtract} methods if adding (subtracting) 
the specified {@link LogicalTimelnterval} would result in a 
<code>LogicalTime</code> lying after (before) the final (initial) 
<code>LogicalTime</code>. 


386 


DRDC Valcartier TR 2007-412 










<exception_name> 


<exception_description> 


InteractionClassNotDefined 


Exception thrown by the (5.4/5.5) {@link 
RTIambassador#publishInteractionClass publish} / {@link 
RTIambassador#unpublishInteractionClass unpublish} InteractionClass, 
(5.8/9.10) {@link RTIambassador#subscribeInteractionClass 
subscribelnteractionClass} {@link 

RTIambassador#subscribeInteractionClassPassively [Passively]} {@link 
RTIambassador#subscribeInteractionClassWithRegions [WithRegions]}, 
(5.9/9.11) {@link RTIambassador#unsubscribeInteractionClass 
unsubscribelnteractionClass} {@link 

RTIambassador#unsubscribeInteractionClassWithRegions [WithRegions]}, 
(6.8/9.12) {©link RTIambassador#sendInteraction sendlnteraction} 
{@link RTIambassadorftsendlnteractionWithRegions [WithRegions]} (all 
forms) and (6.14/8.24) changelnteraction {@link 

RTIambassador#changeInteractionTransportationType Transportation} / 
{@link RTIambassador#changeInteractionOrderType Order} Type methods 
when the specified interaction class isn't recognized. 


InteractionClassNotPublished 


Exception thrown by the (6.8/9.12) {@link 
RTIambassador#sendInteraction sendlnteraction} {®link 
RTIambassador#sendInteractionWithRegions [WithRegions]} (all forms) 
and (6.14/8.24) changelnteraction {©link 

RTIambassador#changeInteractionTransportationType Transportation} / 
{©link RTIambassador#changeInteractionOrderType Order} Type methods 
when the specified interaction class isn't currently published by the 
federate. 

<p> 

It should also be thrown by the (5.12/5.13) 

FederateAmbassador.turnlnteractions {@link 
FederateAmbassador#turnInteractionsOn On} / {©link 

FederateAmbassador#turnInteractionsOff Off} callbacks if the federate 
denies publishing the specified interaction class. 


InteractionClassNotRecognized 


Exception that should be thrown by the (6.9) {®link 

FederateAmbassadorttreceivelnteraction receivelnteraction} (all forms) 
callback if the federate does not recognize the supplied interaction 
class. 


InteractionClassNotSubscribed 


Exception that should be thrown by the (6.9) {©link 

FederateAmbassador#receiveInteraction receivelnteraction} (all forms) 
callback if the federate denies subscribing to the supplied 
interaction class. 


DRDC Valcartier TR 2007-412 


387 












<exception name> 

<exception description> 

InteractionParameterNotDefined 

Exception thrown by the (6.8/9.12) {@link 

RTIambassador#sendInteraction sendlnteraction} {@link 
RTIambassadorttsendlnteractionWithRegions [WithRegions]} (both forms) 
and (10.9) {@link RTIambassador#getParameterName getParameterName} 
methods when (at least one of) the specified parameter(s) isn’t 
defined in the context of the specified interaction class. 

InteractionParameterNotRecognized 

Exception that should be thrown by the (6.9) {@link 

FederateAmbassadorttreceivelnteraction receivelnteraction} (all forms) 
callback if at least one of the supplied parameters isn't recognized 
in the context of the specified interaction class. 

InteractionRelevanceAdvisorySwitchlsOff 

Exception thrown by the (10.29) {@link 

RTIambassador#disableInteractionRelevanceAdvisorySwitch 
disableInter actionRelevanceAdvisorySwitchj method whsn the 
interaction relevance advisory switch is already off. 

InteractionRelevanceAdvisorySwitchlsOn 

Exception thrown by the (10.28) {@link 

RTIambassador#enablelnteractionRelevanceAdvisorySwitch 
enablelnteractionRelevanceAdvisorySwitch} method when the interaction 
relevance advisory switch is already on. 

InTimeAdvancingState 

Exception thrown by the (8.2) {©link 

RTIambassador#enableTimeRegulation enableTimeRegulation}, (8.5) 

{@link RTIambassador#enableTimeConstrained enableTimeConstrained}, 

(8.8/8.9){@link RTIambassadortttimeAdvanceRequest timeAdvanceRequest} 
{@link RTIambassador#timeAdvanceRequestAvailable [Available]}, 
(8.10/8.11) {@link RTIambassador#nextMessageRequest 

nextMessageRequest} {@link RTIambassador#nextMessageRequestAvailable 
[Available]}, (8.12) {@link RTIambassador#flushQueueRequest 
flushQueueRequest} and (8.19) {@link RTIambassador#modifyLookahead 
modifyLookahead} methods when the federate is in the Time Advancing 
state. 

InvalidAttributeHandle 

Exception thrown by the (10.5) {@link RTIambassador#getAttributeName 
getAttributeName} and (10.15) {@link 

RTIambassador#getAvai1ableDimensionsForClassAttribute 
getAvailableDimensionsForClassAttribute} methods when the specified 
attribute handle doesn't exist (in any object class context). 


388 


DRDC Valcartier TR 2007-412 
















<exception_name> 


<exception_description> 


InvalidDimensionHandle 


Exception thrown by the (9.2) {@link RTIambassadorttcreateRegion 
createRegion}, (10.13) {@link RTIambassador#getDimensionName 

getDirnensionName} and (10.14) {@link 

RTIarnbassador#getDimensionUpperBound getDimensionUpperBound} methods 
when (one of) the specified dimension handle(s) doesn’t exist. 


InvalidFederateHandle 


Exception thrown by the (10.33) {@link 

RTIambassador#normalizeFederateHandle normalizeFederateHandle} method 
when the specified federate handle is invalid. 

<p> 

Note that when the (4.6) {@link 

RTIambassador#registerFederationSynchronizationPoint(String,byte[],Fe 

derateHandleSet)} method is supplied a {@link FederateHandleSet} that 

includes one or more invalid federate handles, it does not throw this 

exception. Instead the RTI invokes the {@link 

FederateAmbassador#synchronizationPointRegistrationFailed 

synchronizationPointRegistrationFailed} callback with the reason 

<COde>SYNCHRONIZATION_SET_MEMBER_NOT_JOINED</code>. 


InvalidlnteractionClassHandle 


Exception thrown by the (10.7) {@link 

RTIambassador#getInteractionClassName getlnteractionClassName}, 

(10.8) {@link RTIambassadorttgetParameterHandle getParameterHandle}, 

(10.9) {@link RTIambassadorttgetParameterName getParameterName} and 
(10.17) {@link 

RTIambassador#getAvailableDimensionsForInteractionClass 
getAvailableDimensionsForlnteractionClass} methods when the specified 
interaction class handle is invalid. 


DRDC Valcartier TR 2007-412 


389 










<exception_name> 


<exception_description> 


InvalidLogicalTime 


Exception thrown by the (4.11) {@link 

RTIambassador#requestFederationSave(String,LogicalTime)}, (6.6) 

{@link 

RTIarnbassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHan 
dleValueMap,byte[],LogicalTime)}, (6.8) {@link 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleV 
alueMap,byte[],LogicalTime)}, (9.12) {@link 

RTIambassador#sendInteractionWithRegions(InteractionClassHandle,Param 
eterHandleValueMap,RegionHandleSet,byte[],LogicalTime)}, (6.10) 

{@link 

RTIambassador#deleteObj ectInstance(ObjectInstanceHandle,byte[],Logica 
lTime)}, (8.8/8.9) {@link RTIambassadortttimeAdvanceRequest 
timeAdvanceRequest} {@link RTIambassadortttimeAdvanceRequestAvailable 
[Available]}, (8.10/8.11) {@link RTIambassadorttnextMessageRequest 
nextMessageRequest} {@link RTIambassadorttnextMessageRequestAvailable 
[Available]} and (8.12) {@link RTIambassador#flushQueueRequest 
flushQueueRequest} methods when the specified time-stamp is invalid. 

<p> 

It should also be thrown by the (4.12) {®link 

FederateAmbassador#initiateFederateSave(String,LogicalTime)}, (6.7) 

{©link 

FederateAmbassadorftreflectAttributeValues(Obj ectInstanceHandle, Attrib 
uteHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Ord 
erType,MessageRetractionHandle)}, {@link 

FederateAmbassador#reflectAttributeValues(Obj ectInstanceHandle,Attrib 
uteHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Ord 
erType,MessageRetractionHandle,RegionHandleSet)}, (6.9) {@link 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Paramete 
rHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Order 
Type,MessageRetractionHandle)}, {@link 

FederateAmbassador#receiveInteraction(InteractionClassHandle,Paramete 
rHandleValueMap,byte[],OrderType,TransportationType,LogicalTime,Order 
Type,MessageRetractionHandle,RegionHandleSet)}, (6.11) {©link 

FederateAmbassadorftremoveObjectlnstance(ObjectlnstanceHandle,byte[] ,0 
rderType,LogicalTime,OrderType,MessageRetractionHandle)}, (8.3) 

{@link FederateAmbassador#timeRegulationEnabled 
timeRegulationEnabled}, (8.6) {@link 

FederateAmbassadorfttimeConstrainedEnabled timeConstrainedEnabled} and 
(8.13) {@link FederateAmbassador#timeAdvanceGrant timeAdvanceGrant} 
callbacks if the federate considers the time-stamp invalid. 


InvalidLookahead 


Exception thrown by the (8.2) {@link 

RTIambassador#enableTimeRegulation enableTimeRegulation} and (8.19) 
{@link RTIambassador#modifyLookahead modifyLookahead} methods when 
the supplied lookahead {@link LogicalTimelnterval} is invalid. 


390 


DRDC Valcartier TR 2007-412 








<exception name> 

<exception description> 

InvalidMessageRetractionHandle 

Exception thrown by the (8.21) {@link RTIambassadorttretract retract} 
method when the supplied {@link MessageRetractionHandle} is invalid. 

InvalidObjectClassHandle 

Exception thrown by the (10.3) {@link 

RTIambassador#getObjectClassName getObjectClassName}, (10.4) {@link 

RTIambassadorftgetAttributeHandle getAttributeHandle}, (10.5) {@link 

RTIambassador#getAttributeName getAttributeName} and (10.15) {@link 

RTIambassador#getAvailableDimensionsForClassAttribute 
getAvailableDimensionsForClassAttribute} methods when the supplied 
{@link ObjectClassHandle} is invalid. 

InvalidOrderName 

Exception thrown by the (10.20) {@link RTIambassador#getOrderType 
getOrderType} method when the supplied order type name is invalid. 

<p> 

As specified in {©link OrderType}, the two possible order type names 
are <code>RECEIVE</code> and <code>TIMESTAMP</code>. 

InvalidOrderType 

Exception thrown by the (10.21) {@link RTIambassador#getOrderName 
getOrderName} method when the supplied {@link OrderType} is invalid. 

InvalidParameterHandle 

Exception thrown by the (10.9) {@link RTIambassador#getParameterName 
getParameterName} method when the supplied {@link ParameterHandle} is 
invalid. 

InvalidRangeBound 

Exception thrown by the (10.32) {@link RTIambassador#setRangeBounds 
setRangeBounds} method when the supplied {©link RangeBounds} is 
invalid. 


DRDC Valcartier TR 2007-412 


391 
















<exception_name> 


<exception_description> 


InvalidRegion 


Exception thrown by the (9.3) {@link 

RTIambassador#commitRegionModifications commitRegionModifications}, 
(9.4) {@link RTIambassador#deleteRegion deleteRegion}, (9.5) {@link 

RTIambassador#registerObj ectInstanceWithRegions 
registerObjectlnstanceWithRegions} (both forms), (9.6) {@link 
RTIambassador#associateRegionsForUpdates associateRegionsForUpdates}, 
(9.7) {©link RTIambassador#unassociateRegionsForUpdates 
unassociateRegionsForUpdates}, (9.8) {@link 

RTIambassador#subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions} {@link 
RTIambassador#subscribeObjectClassAttributesPassivelyWithRegions 
[Passively]}, (9.9) {@link 

RTIambassador#unsubscribeObjectClassAttributesWithRegions 
unsubscribeObjectClassAttributesWithRegions}, (9.10) {@link 

RTIambassador#subscribeInteractionClassWithRegions 
subscribeInteractionClassWithRegions} {©link 
RTIambassador#subscribeInteractionClassPassivelyWithRegions 
[Passively]}, (9.11) {@link 

RTIambassadorttunsubscribelnteractionClassWithRegions 
unsubscribelnteractionClassWithRegions}, (9.12) {@link 

RTIambassador#sendInteractionWithRegions sendlnteractionWithRegions} 
(both forms), (9.13) {@link 

RTIambassadorttrequestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions}, (10.30) {@link 

RTIambassador#getDimensionHandleSet getDimensionHandleSet}, (10.31) 

{@link RTIambassador#getRangeBounds getRangeBounds} and (10.32) 

{@link RTIambassador#setRangeBounds setRangeBounds} methods when the 
supplied {@link RegionHandle} (which for most methods is included in 
a {@link RegionHandleSet} or {©link AttributeSetRegionSetPairList}) 
is invalid. 

<P> 

In particular, {@link RTIambassadorttcommitRegionModifications 
commitRegionModifications} throws this exception if any of a region 
template's specified dimensions have not had their RangeBounds set 
beforehand. 


392 


DRDC Valcartier TR 2007-412 






<exception_name> 


<exception_description> 


InvalidRegionCont ext 


Exception thrown by the (9.5) {@link 
RTIambassador#registerObj ectlnstanceWithRegions 
registerObjectInstanceWithRegions} (both forms), (9.6) {@link 
RTIarnbassador#associateRegionsForUpdates associateRegionsForUpdates}, 
(9.8) {©link RTIambassador#subscribeObjectClassAttributesWithRegions 
subscribeObj ectClassAttributesWithRegions} {@link 
RTIambassador#subscribeObjectClassAttributesPassivelyWithRegions 
[Passively]}, (9.10) {@link 

RTIambassador#subscribeInteractionClassWithRegions 
subscribeInteractionClassWithRegions} {@link 
RTIambassador#subscribeInteractionClassPassivelyWithRegions 
[Passively]}, (9.12) {@link RTIambassadorftsendlnteractionWithRegions 
sendlnteractionWithRegions} (both forms) and (9.13) {®link 
RTIambassador#requestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions} methods when the specified 
dimensions of one of the <code>Region</code>s (supplied by a {@link 
RegionHandleSet} or {@link AttributeSetRegionSetPairList} argument) 
are not a subset of the available dimensions of the specified class 
attributes (as described by the FOM Document Data). 


InvalidServiceGroup 


Exception thrown by the (10.34) {@link 

RTIambassador#normalizeServiceGroup normalizeServiceGroup} method 
when the specified {@link ServiceGroup} is invalid. 


InvalidTransportationName 


Exception thrown by the (10.18) {@link 

RTIambassador#getTransportationType getTransportationType} method 
when the specified transportation type name is invalid. 

<p> 

As specified in {@link TransportationType}, the two core 
transportation type names are <code>HLAreliable</code> and 
<code>HLAbestEffort</code>; additional 

<code>TransportationType</code>s may be provided by specific RTIs. 


InvalidTransportationType 


Exception thrown by the (10.19) {@link 

RTIambassador#getTransportationName getTransportationName} method 
when the specified {@link TransportationType} is invalid. 


JoinedFederatelsNotlnTimeAdvancingState 


Exception that should be thrown by the (8.13) {@link 

FederateAmbassadortttimeAdvanceGrant timeAdvanceGrant} callback if the 
federate does not consider itself in the Time Advancing state. 


DRDC Valcartier TR 2007-412 


393 














<exception_name> 


<exception_description> 


LogicalTimeAlreadyPassed 


Exception thrown by the (4.11) {@link 

RTIambassador#requestFederationSave requestFederationSave}, (8.8/8.9) 

{@link RTIambassador#timeAdvanceRequest timeAdvanceRequest} {@link 
RTIambassadortttimeAdvanceRequestAvailable [Available]}, (8.10/8.11) 

{@link RTIambassador#nextMessageRequest nextMessageRequest} {@link 
RTIambassador#nextMessageRequestAvailable [Available]} and (8.12) 
{@link RTIambassadorttflushQueueRequest flushQueueRequest} methods 
when the specified (@link LogicalTime} is in the federation’s past. 


MessageCanNoLongerBeRetracted 


Exception thrown by the (8.21) (@link RTIambassador#retract retract} 
method when the message associated with the specified {@link 
MessageRetractionHandle} can no longer be retracted. A federate in 
the Time Granted state can only retract messages with time stamps 
larger than the federate's current logical time plus its actual 
lookahead. A federate in the Time Advancing state can only retract 
messages with time stamps larger than the logical time specified in 
the federate’s most recent (8.8) {@link 

RTIambassador#timeAdvanceRequest timeAdvanceRequest} plus its actual 
lookahead. 


NameNotFound 


Exception thrown by the (10.2) (@link 

RTIambassador#getObjectClassHandle getobjectClassHandle}, (10.4) 

{@link RTIambassador#getAttributeHandle getAttributeHandle}, (10.6) 

{@link RTIambassador#getInteractionalassHandle 
getlnteractionClassHandle}, (10.8) {@link 

RTIambassador#getParameterHandle getParameterHandle} and (10.12) 
{@link RTIambassador#getDimensionHandle getDimensionHandle} methods 
when the specified name isn’t recognized. 


NoAcquisitionPending 


Exception thrown by the (7.6) (@link RTIambassador#confirmDivestiture 
confirmDivestiture} method when, although there is a negotiated 
divestiture request pending for the specified attributes, the (7.5) 
{@link FederateAmbassador#requestDivestitureConfirmation 
requestDivestitureConfirmation} callback has not yet occurred. The 
exception was missing from Annex B but not from the 7.6 clause. 

<p> 

Pitch pRTI 1516 version 2.3 states that "This is deliberately not a 
final class" without explaining why. 


394 


DRDC Valcartier TR 2007-412 












<exception_name> 


<exception_description> 


NoRequestToEnableTimeConstrainedWasPending 


Exception that should be thrown by the (8.6) {@link 
FederateAmbassador#timeConstrainedEnabled timeConstrainedEnabled} 
callback if the federate wants to repudiate its request to become 
time-constrained. 


NoRequestToEnableTimeRegulationWasPending 


Exception that should be thrown by the (8.3) {@link 
FederateAmbassadortttimeRegulationEnabled timeRegulationEnabled} 
callback if the federate wants to repudiate its request to become 
time-regulating. 


Obj ectClassNotDefined 


Exception thrown by the {@link 
RTIambassadorttpublishObjectClassAttributes 
publishObjectClassAttributes}, {@link 

RTIambassador#unpublishObjectClass unpublishObjectClass}, {@link 

RTIambassador#unpublishObj ectClassAttributes 

unpublishObjectClassAttributes}, {@link 

RTIambassador#subscribeObj ectClassAttributes 

subscribeObj ectClassAttributes} {@link 

RTIambassador#subscribeObjectClassAttributesPassively [Passively] } 
{@link RTIambassador#subscribeObjectClassAttributesWithRegions 
[WithRegions]}, {©link RTIambassador#unsubscribeObjectClass 
unsubscribeObjectClass}, {@link 
RTIambassador#unsubscribeObjectClassAttributes 
unsubscribeObj ectClassAttributes} {©link 

RTIambassadorttunsubscribeObjectClassAttributesWithRegions 
[WithRegions]}, {@link RTIambassador#registerObjectlnstance 
registerObjectlnstance} {@link 

RTIambassador#registerObjectlnstanceWithRegions [WithRegions]} (all 
forms), {@link 

RTIambassador#requestAttributeValueUpdate(Obj ectClassHandle,Attribute 
HandleSet,byte[])} and {©link 

RTIambassador#requestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions} methods when the supplied 
{@link ObjectClassHandle} isn't recognized. 


DRDC Valcartier TR 2007-412 


395 










<exception_name> 


<exception_description> 


Obj ectClassNotPublished 


Exception thrown by the (6.4/9.5) {@link 

RTIambassador#registerObjectInstance registerObjectInstance} {@link 
RTIambassador#registerObjectInstanceWithRegions [WithRegions]} (all 
forms) and (7.8/7.9) {@link 
RTIarnbassador#attributeOwnershipAcqulsition 
attributeOwnershipAcquisition} {@link 

RTIambassador#attributeOwnershipAcquisitionIfAvailable [IfAvailable]} 
methods when the supplied object class isn't currently published by 
the federate. 

<p> 

It should also be thrown by the (5.10) {@link 

FederateAmbassador#startRegistrationForObjectClass start} / (5.11) 
{@link FederateAmbassador#stopRegistrationForObjectClass stop} 
RegistrationForObjectClass callbacks if the federate does not publish 
the specified object class. 


Obj ectClassNotRecognized 


Exception that should be thrown by the (6.5) {@link 
FederateAmbassador#discoverObj ectInstance discoverObj ectInstance} 
callback if the federate does not recognize the specified object 
class. 


Obj ectClassRelevanceAdvisorySwitchlsOff 


Exception thrown by the (10.23) {@link 

RTIambassadorttdisableObj ectClassRelevanceAdvisorySwitch 
disableObjectClassRelevanceAdvisorySwitch} method when the object 
class relevance advisory switch is already off. 


Obj ectClassRelevanceAdvisorySwitchlsOn 


Exception thrown by the (10.22) {@link 
RTIambassador#enableObj ectClassRelevanceAdvisorySwitch 
enableObjectClassRelevanceAdvisorySwitch} method when the object 
class relevance advisory switch is already on. 


Obj ectInstanceNamelnUse 


Exception thrown by the (6.4) {@link 

RTIambassador#registerObjectlnstance(ObjectClassHandle,String)} and 
(9.5) {@link 

RTIambassador#registerObj ectInstanceWithRegions(Obj ectClassHandle,Att 
ributeSetRegionSetPairList,String)} methods when the specified object 
instance name has already been used. An object instance name may not 
be re-used during the lifetime of the federation execution even if 
the object instance is deleted. 


396 


DRDC Valcartier TR 2007-412 














<exception_name> 


<exception_description> 


Obj ectInstanceNameNotReserved 


Exception thrown by the (6.4) {@link 

RTIambassador#registerObjectlnstance(ObjectClassHandle,String)} and 
(9.5) {©link 

RTIarnbassador#registerObj ectlnstanceWithRegions(Obj ectClassHandle,Att 
ributeSetRegionSetPairList,String)} methods when the specified object 
instance name could not be reserved for some reason other than its 
having already been used. 

<p> 

Object instance names may not begin with "HLA" (including any case 
variations such as "Hla"). For details on name construction, see the 
{@link IllegalName} exception. 

<p> 

An object instance name may not be re-used during the lifetime of the 
federation execution even if the object instance is deleted. 


DRDC Valcartier TR 2007-412 


397 






<exception_name> 


<exception_description> 


Obj ectInstanceNotKnown 


Exception thrown by the {@link RTIambassador#updateAttributeValues 
updateAttributeValues} (both forms), {@link 
RTIambassadorftlocalDeleteObjectlnstance [local]} {@link 
RTIambassadorttdeleteObjectlnstance deleteObjectlnstance} (all forms), 
changeAttribute {©link 

RTIambassadorttchangeAttributeTransportationType Transportation} / 
{@link RTIambassador#changeAttributeOrderType Order} Type, {@link 
RTIambassadortt-requestAttributeValueUpdate(Obj ectlnstanceHandle,Attrib 
uteHandleSet,byte[])}, {@link 

RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditional} / {©link 

RTIambassadorttnegotiatedAttributeOwnershipDivestiture negotiated} 
AttributeOwnershipDivestiture, {@link 

RTIambassadorttconfirmDivestiture confirmDivestiture}, {@link 
RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} {@link 

RTIambassadorttattributeOwnershipAcquisitionlfAvailable 
[IfAvailable]}, {@link 

RTIambassador#attributeOwnershipDivestitureIfWanted 
attributeOwnershipDivestiturelfWanted}, {@link 
RTIambassador#cancelNegotiatedAttributeOwnershipDivestiture 
cancelNegotiatedAttributeOwnershipDivestiture}, {@link 
RTIambassadorttcancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition}, {©link 

RTIambassador#queryAttributeOwnership queryAttributeOwnership}, 

{@link RTIambassador#isAttributeOwnedByFederate 
isAttributeOwnedByFederate}, {©link 

RTIambassador#associateRegionsForUpdates associateRegionsForUpdates}, 
{@link RTIambassador#unassociateRegionsForUpdates 
unassociateRegionsForUpdates}, getobjectlnstance {@link 
RTIambassador#getObjectInstanceHandle Handle} / {©link 
RTIambassadorttgetObjectlnstanceName Name} and {@link 
RTIambassador#getKnownObjectClassHandle getKnownObjectClassHandle} 
methods when the RTI considers that the specified {@link 
ObjectInstanceHandle} hasn't been discovered by the federate. 

<p> 

(continued next page) 


398 


DRDC Valcartier TR 2007-412 






<exception_name> 


<exception_description> 


ObjectInstanceNotKnown (continued from previous page) 


It should also be thrown by the {@link 

FederateAmbassador#reflectAttributeValues reflectAttributeValues} 
(all forms), {@link FederateAmbassador#removeObjectInstance 
removeObjectInstance} (both forms), attributes {@link 
FederateAmbassador#attributesInScope In} / {@link 
FederateAmbassador#attributesOutOfScope OutOf} Scope, {@link 
FederateAmbassador#provideAttributeValueUpdate 
provideAttributeValueUpdate}, turnUpdates {@link 
FederateAmbassadorttturnUpdatesOnForObjectlnstance On} / {@link 
FederateAmbassador#turnUpdatesOffForObjectInstance Off} 

ForObjectlnstance, requestAttributeOwnership {@link 

FederateAmbassador#requestAttributeOwnershipAssumption Assumption} / 
{©link FederateAmbassadorttrequestAttributeOwnershipRelease Release}, 
{@link FederateAmbassadorttrequestDivestitureConfirmation 
requestDivestitureConfirmation}, {@link 

FederateAmbassador#attributeOwnershipAcquisitionNotification 
attributeOwnershipAcquisitionNotification}, {@link 
FederateAmbassador#attributeOwnershipUnavailable 
attributeOwnershipUnavailable}, {©link 

FederateAmbassador#confirmAttributeOwnershipAcquisitionCancellation 
confirmAttributeOwnershipAcquisitionCancellation}, {@link 
FederateAmbassador#informAttributeOwnership 
informAttributeOwnership}, {@link 

FederateAmbassador#attributeIsNotOwned attributelsNotOwned} and 
{@link FederateAmbassadorttattributelsOwnedByRTI 

attributelsOwnedByRTI} callbacks if the federate denies having 
previously discovered the object instance. 


OwnershipAcquisitionPending 


Exception thrown by the (4.5) {@link 

RTIambassador#resignFederationExecution resignFederationExecution}, 
(5.3) {@link RTIambassador#unpublishObjectClass 
unpublishobjectClass}, {@link 
RTIambassador#unpublishObj ectClassAttributes 
unpublishobjectClassAttributes} and (6.12) {©link 

RTIambassador#localDeleteObjectInstance localDeleteObjectlnstance} 
methods when there is at least one ownership acquisition pending for 
the specified object class (or any object class in the 
resignFederationExecution case). 


RegionDoesNotContainSpecif iedD intension 


Exception thrown by the (10.31) {@link RTIambassador#getRangeBounds 
getRangeBounds} and (10.32) {@link RTIambassador#setRangeBounds 
setRangeBounds} methods when the specified {©link DimensionHandle} is 
not bound to the specified {@link RegionHandle}. 


DRDC Valcartier TR 2007-412 


399 










<exception_name> 


<exception_description> 


RegionlnUseForUpdateOrSubscription 


Exception thrown by the (9.4) {@link RTIambassador#deleteRegion 
deleteRegion} method when the specified <code>Region</code> is still 
in use by the federation. 


RegionNotCreatedByThisFederate 


Exception thrown by the (9.3) {@link 

RTIambassador#commitRegionModifications commitRegionModifications}, 
(9.4) {@link RTIambassadorttdeleteRegion deleteRegion}, (9.5) {@link 
RTIambassador#registerObj ectlnstanceWithRegions 
registerObjectlnstanceWithRegions} (both forms), (9.6) {®link 
RTIambassadorttassociateRegionsForUpdates associateRegionsForUpdates}, 
(9.7) {©link RTIambassador#unassociateRegionsForUpdates 
unassociateRegionsForUpdates}, (9.8) {@link 

RTIambassador#subscribeObjectClassAttributesWithRegions 
subscribeObjectClassAttributesWithRegions} (both forms), (9.9) {@link 
RTIambassadorttunsubscribeObj ectClassAttributesWithRegions 
unsubscribeObjectClassAttributesWithRegions}, (9.10) {@link 

RTIambassadorttsubscribelnteractionClassWithRegions 
subscribelnteractionClassWithRegions} {@link 
RTIambassador#subscribeInteractionClassPassivelyWithRegions 
[Passively]}, (9.11) {@link 

RTIambassador#unsubscribeInteractionClassWithRegions 
unsubscribelnteractionClassWithRegions}, (9.12) {@link 

RTIambassador#sendInteractionWithRegions sendlnteractionWithRegions} 
(both forms), (9.13) {@link 

RTIambassador#requestAttributeValueUpdateWithRegions 
requestAttributeValueUpdateWithRegions} and (10.32) {©link 
RTIambassadorttsetRangeBounds setRangeBounds} methods when the 
federate attempts to modify or use a <code>Region</code> it did not 
create. 


RequestForTimeConstrainedPending 


Exception thrown by the (8.5) {@link 

RTIambassador#enableTimeConstrained enableTimeConstrained}, (8.8/8.9) 

{@link RTIambassador#timeAdvanceRequest timeAdvanceRequest} {@link 
RTIambassador#timeAdvanceRequestAvailable [Available]}, (8.10/8.11) 

{@link RTIambassador#nextMessageRequest nextMessageRequest} {@link 
RTIambassador#nextMessageRequestAvailable [Available]} and (8.12) 
{@link RTIambassador#flushQueueRequest flushQueueRequest} methods 
when an {@link RTIambassador#enableTimeConstrained 
enableTimeConstrained} request is pending. 


400 


DRDC Valcartier TR 2007-412 










<exception_name> 


<exception description> 


RequestForTimeRegulationPending 


Exception thrown by the (8.2) {@link 

RTIambassadorttenableTimeRegulation enableTimeRegulation}, (8.8/8.9) 
{@link RTIambassador#timeAdvanceRequest timeAdvanceRequest} {@link 
RTIambassador#timeAdvanceRequestAvailable [Available] }, (8.10/8.11) 

{@link RTIambassador#nextMessageRequest nextMessageRequest} {@link 
RTIambassador#nextMessageRequestAvailable [Available]} and (8.12) 
{@link RTIambassadorttflushQueueRequest flushQueueRequest} methods 
when an {©link RTIarnbassadorttenableTimeRegulation 
enableTimeRegulation} request is pending. 


RestoreInProgress 


Exception thrown by nearly all of the {@link RTIambassador}’s methods 
when a federation restore is in progress. The methods that do not 
throw it are {@link RTIambassador#createFederationExecution create} / 
{@link RTIambassador#destroyFederationExecution destroy} / {@link 
RTIambassador#resignFederationExecution resign} FederationExecution, 
federateRestore {©link RTIambassadorttfederateRestoreNotComplete 
[Not]} {@link RTIambassadorttfederateRestoreComplete Complete}, {@link 
RTIambassador#queryFederationRestoreStatus 

queryFederationRestoreStatus}, all of the various <code>get</code> 
methods, normalize {@link RTIambassadorttnormalizeFederateHandle 
FederateHandle} / {@link RTIambassadorttnormalizeServiceGroup 
ServiceGroup}, {@link RTIambassadorttevokeCallback evokeCallback} and 
{@link RTIambassador#evokeMultipleCallbacks evokeMultipleCallbacks}. 


RestoreNotRequested 


Exception thrown by the RTIambassador's (4.22) federateRestore {@link 
RTIambassador#federateRestoreNotComplete [Not]} {@link 
RTIambassador#federateRestoreComplete Complete} methods when a 
federation restore was not previously requested. 


RTIinternalError 


Exception thrown by all of the {@link RTIambassador}'s methods when 
something goes wrong and none of the more specific exceptions is 
appropriate. 


DRDC Valcartier TR 2007-412 


401 












<exception name> 

<exception description> 

SaveInProgress 

Exception thrown by nearly all of the {@link RTIambassador}'s methods 
when a federation save is in progress. The methods that do not throw 
it are {@link RTIambassador#createFederationExecution create} / 

{@link RTIambassador#destroyFederationExecution destroy} / {®link 
RTIambassadorttresignFederationExecution resign} FederationExecution, 
federateSave {©link RTIambassador#federateSaveBegun Begun} / {@link 
RTIambassador#federateSaveNotComplete [Not]} {@link 
RTIambassador#federateSaveComplete Complete} {@link 
RTIambassador#queryFederationSaveStatus queryFederationSaveStatus}, 
all of the various <code>get</code> methods, normalize {@link 
RTIambassador#normalizeFederateHandle FederateHandle} / {@link 
RTIambassador#normalizeServiceGroup ServiceGroup}, {@link 
RTIambassador#evokeCallback evokeCallback} and {@link 
RTIambassador#evokeMultipleCallbacks evokeMultipleCallbacks}. 

SaveNotInitiated 

Exception thrown by the (4.13) {@link RTIambassadorttfederateSaveBegun 
federateSaveBegun} method when a federation save was not previously 
requested. 

SpecifiedSaveLabelDoesNotExist 

Exception that should be thrown by the (4.21) {@link 
FederateAmbassadorttinitiateFederateRestore initiateFederateRestore} 
callback if the federate cannot find the specified save label. 

SynchronizationPointLabelNotAnnounced 

Exception thrown by the (4.9) {@link 

RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved} method when the specified 
synchronization point was not previously announced. 

TimeConstrainedAlreadyEnabled 

Exception thrown by the (8.5) {@link 

RTIambassador#enableTimeConstrained enableTimeConstrained} method 
when time-constraint is already enabled. 

TimeConstrainedlsNotEnabled 

Exception thrown by the (8.7) {@link 

RTIambassador#disableTimeConstrained disableTimeConstrained} method 
when time-constraint is already disabled. 


402 


DRDC Valcartier TR 2007-412 
















<exception_name> 


<exception_description> 


TimeRegulationAlreadyEnabled 


Exception thrown by the (8.2) {@link 

RTIambassadorttenableTimeRegulation enableTimeRegulation} method when 
time-regulation is already enabled. 


TimeRegulationlsNotEnabled 


Exception thrown by the (8.4) {@link 

RTIambassador#disableTimeRegulation disableTimeRegulation}, 

(8.19/8.20) {@link RTIambassador#modifyLookahead modifyLookahead}, 
{@link RTIambassadorttqueryLookahead queryLookahead} and (8.21) {@link 
RTIambassador#retract retract} methods when time-regulation is 
(already) disabled. 


UnableToPerformSave 


Exception that should be thrown by the (4.12) {@link 
FederateAmbassador#initiateFederateSave initiateFederateSave} (both 
forms) callback if the federate considers itself unable to proceed 
into the Saving state. 

<p> 

This exception should be thrown if a quick check by the federate 
leads it to conclude that an attempt to save is doomed to failure. 
Normally, the federate will start its save operation and later report 
success or failure through the (4.14) RTIambassador.federateSave 
{@link RTIambassador#federateSaveNotComplete [Not]} {®link 
RTIambassador#federateSaveComplete Complete} methods. 


UnknownName 


Exception that should be thrown by the (6.3) {©link 

FederateAmbassador#objectInstanceNameReservationSucceeded 

objectInstanceNameReservationSucceeded} and {@link 

FederateAmbassador#objectInstanceNameReservationFailed 

objectInstanceNameReservationFailed} callbacks if the federate wishes 

to repudiate the name. 


DRDC Valcartier TR 2007-412 


403 












// File : InvalidLogicalTimeInterval.j ava 

package hla.rtil516; //the package name was changed by DoD 
Interpretations of IEEE 1516-2000v2 

j * * 

* NOTE: This exception is NOT part of IEEE 1516-2000 nor 

* specified by the DoD Interpretations; it is tentatively added 

* based on an analysis of apparent inconsistencies between the 

* Java, Ada and C++ specification clauses and normative annexes. 

* <p> 

* Exception thrown by the <code>LogicalTimeInterval.setTo</code> 

* and {@link LogicalTimeInterval#subtract subtract} methods when 

* the supplied <code>LogicalTimeInterval</code> is invalid or 

* would result in an invalid one. 

* @author Daniel U. Thibault 

* ©version 1516.1.5 (DoD v2+l) 

*/ 

public final class 
InvalidLogicalTimeInterval 
extends RTIexception 

{ 

j * * 

* Constructs a new exception with the specified detail message. 

* The cause is not initialized, and may subsequently be 
initialized by a call to 

* {@link j ava.lang.Throwable#initCause(java.lang.Throwable) }. 

* @param msg a {@link java.lang.String} holding the detail 
message, which can be later retrieved by the {@link 

j ava.lang.Throwable#getMessage} method 
*/ 

public 

InvalidLogicalTimelnterval (String msg) 

{ 

super (msg) ,- 


//end InvalidLogicalTimelnterval 


404 


DRDC Valcartier TR 2007-412 



Annex C - DRDC HLA 1516 OMT Supporting 
Classes 


The ca .gc . drdc rddc .hla. rtiisie. omt package implements the 1516.2-2000 
Object Model Template (OMT) datatypes and their predefined encodings, as laid out 
in 4.12. Although a federation is free to define arbitrary data representation schemes 
for federate-to-federate interaction parameters and object attribute values, the RTI- 
owned objects and the RTI-issued interactions follow the 1516.2 predefined 
encodings. The standard currently provides no support whatsoever, but this may 
hopefully change with later editions. In the meantime, it is hoped the supporting 
classes laid out herein will prove flexible enough to fill the need. 


HLA recognises five broad categories of datatypes: basic, simple, enumerated, array 
and record. In what follows, we’ll examine each set of classes briefly, and outline 
how user-defined classes should be implemented to follow the design patterns 
established here. The mandated datatypes and those added by the Management 
Object Model (MOM) were discussed in Annex A’s Encoding/Decoding Values 
sub-heading. 

Basic datatypes 

The basic datatypes are the underpinnings of all others, and generally map directly to 
a given language’s primitive types. They represent integers, floating-point numbers 
and characters, in various byte widths and byte sexes (big or little endian). They 
also form an almost closed set, in the sense that a federation will rarely have to 
declare additional basic datatypes. 

The basic datatypes map readily to Java’s primitive types. We captured the 
functionality of the datatypes in the HLAdatatype interface, a subset of which is the 
HLAencodable interface. This facilitates the construction of the more elaborate 
datatypes later on. 

In order to facilitate the construction of user-defined array datatypes, we felt it 
necessary to add the HLAnull basic datatype. It is trivial to represent, having no 
width (zero bits) and thus taking up no room in the byte [ ] representations being 
ferried around by the RTI. 


Simple datatypes 

The implementation of the simple datatypes was mostly a matter of casting as broad 
a net of constructors as possible. Intermediate abstract classes HLAoctetPair, 
HLAintegerlS, HLAinteger32, HLAinteger64, HLAfloat32 and HLAfloat64 
capture the behaviour (and underlying storage) common to the big-endian (be) and 
little-endian (le) forms. 


DRDC Valcartier TR 2007-412 


405 








Enumerated datatypes 

These datatypes describe data elements that can take on a finite discrete set of 
possible values. They use a basic datatype for internal representation, and are 
defined by an Enumerator, an exhaustive list of names designating the immutable 
instance prototypes. The specification allows for a given enumeration member to 
take on multiple values (for example, the HLAboolean value HLAtrue could have 
been defined as “not zero”). This causes a number of problems, so we’ve chosen to 
restrict each enumeration member to a single value (although constructors may 
accept a wider range of input values). Also, the specification does not mention 
whether enumerated types are ordered or not. We chose here to assume the 
enumeration sequence is fixed and ordered. 

The additional functionality of the enumerated datatypes is captured in the 

HLAenumerateddatatype interface, which extends HLAdatatype by adding a 
couple of iterator members. 

In order to simplify as much as possible the task of creating new federation-specific 
enumerated datatypes, we implemented an HLAenumeratediterator class that 
automates, using Java object reflection, the task of giving the class an iterator 
interface. Although it has not been done here, adding an immutable static List 
member to each class would facilitate normalization and unnormalization 
considerably. 

Three of the MOM-defined enumerated datatypes map directly to IEEE 1516 
classes: HLAresignAction (ResignAction), HLAorderType (OrderType) , and 
HLAserviceGroupName (ServiceGroup). It should be a very simple matter to 
modify the implementations given here in order to allow constructors to accept the 
mapped objects as inputs (e.g. it should be possible to write HLAserviceGroupName 
sgn_ss = new HLAserviceGroupName(ServiceGroup . SUPPORT_SERVICES). 

Array datatypes 

These datatypes describe indexed homogeneous collections of datatypes. The 
collection’s size is either fixed or variable, and the elements that make them up are 
all of the same datatype: simple, enumerated, array or record. 

The additional functionality of the array datatypes is captured in the 
HLAarraydatatype interface, which extends HLAdatatype and List. Common 
behaviour is again taken care of by ancestor abstract classes, in a two-tier structure 
(HLAarrayType and its descendents HLAvariableArrayType and 
HLAf ixedArrayType). The implementation provides a concrete class, 

HLAob j ectArray, which provides most of the behaviour required of non-trivial 
variable array types. 


406 


DRDC Valcartier TR 2007-412 



Fixed record datatypes 

These datatypes describe heterogeneous collections of datatypes. The individual 
elements (considered to appear in a fixed sequence) are potentially each of a 
different datatype: simple, enumerated, array or record. 

The additional functionality of the fixed record datatypes is captured in the 

HLAfixedrecorddatatype interface, which extends HLAdatatype and Map. 

Common behaviour is again taken care of by an ancestor abstract class, 

HLAf ixedRecordType, which relies on HLAf ixedRecordl t erator to automate the 
construction of iterators, in a manner analogous to enumerated datatypes. 

Variant record datatypes 

These datatypes describe discriminated unions of datatypes. They are characterised 
by a discriminant, an enumerated datatype value which is used to switch the 
interpretation of the record’s contents between a number of alternatives. Each 
alternative is either null (absent) or some other datatype: simple, enumerated, array 
or record. 

The additional functionality of the variant record datatypes is captured in the 

HLAvariantrecorddatatype interface, which extends HLAdatatype. Common 
behaviour is again taken care of by an ancestor abstract class, 

HLAvariantRecordType. 


DRDC Valcartier TR 2007-412 


407 



The ByteWrapper class is the workhorse of the package; it implements all of the 
encoding and decoding behaviours. 


// File: ByteWrapper.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

j * * 

* Utility class for managing data in byte arrays. 

* <p> 

* It is similar to java.nio.ByteBuffer but considerably simpler. The 
key components are: 

* <ul > 

* <li>A backing store (returned by the array() method), which is 

* either a wrapped pre-existing byte[] or a newly created one.</li> 

* <li>An inclusive lower bound (returned by the lowerBoundO method) 
which is 

* the zero-based index of the first accessible byte.</li> 

* <li>An exclusive upper bound (returned by the upperBoundO method) 
which is 

* the zero-based index of the byte before which the last accessible 
byte lies.</li> 

* <li>A cursor, (returned by the pos() method), which is 

* the zero-based index of the current byte (i.e. the next byte to 
read or write). 

* The cursor always lies between the lower bound (included) and the 
upper bound (included). 

* When the ByteWrapper is created, its cursor is always set to the 
lower bound.</li> 

* </ul> 

* <p> 

* Typical use: 

* <ul><code> 

* //To encode an HLA data type into a byte array,<br> 

* //we can get the byte array directly through the toByteArray() 
method:<br> 

* HLAinteger32BE pre = new HLAinteger32BE (MY_NUMBER) ,-<br> 

* //final byte[] bytes = pre . toByteArray (),-<br> 

* //<br> 

* //A ByteWrapper is more flexible, though, since we can use it to 
serially encode values into it<br> 

* ByteWrapper bw = new ByteWrapper(prel.encodedLength() + 
pre2.encodedLength());<br> 

* prel.encode (bw) ,-<br> 

* pre2 .encode (bw) ,- <br> 

* //Extract the byte[] representation<br> 

* final byte[] bytes = bw. array (),-<br> 

* //<br> 


408 


DRDC Valcartier TR 2007-412 



* //To decode an HLA data type from a byte array<br> 

* ByteWrapper bw = new ByteWrapper(bytes);<br> 

* HLAinteger32BE post = new HLAinteger32BE(); //default value of 
zero<br> 

* post.decode(bw);<br> 

* //Alternately, decode directly from the byte array...<br> 

* HLAinteger32BE post = new HLAinteger32BE(bytes);<br> 

* //...or the byte wrapper<br> 

* HLAinteger32BE post = new HLAinteger32BE (bw) <br> 

* </code></ul> 

* @author Mikael Karlsson ({@link http://www.pitch.se Pitch AB}) and 
{@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. Thibault} 

({@link http://www.valeartier.drdc-rddc.go.ca DRDC Valcartier}) 

* @version 1.1 

*/ 

public class 
ByteWrapper 

implements j ava.lang.Cloneable 

{ 

private byte[] _buffer; 
private int _lowerBound; 
private int _upperBound; 
private int _pos; 

j * * 

* Constructs a new ByteWrapper backed by a new byte array of the 
specified length. 

* Lower bound will be zero, upper bound will be length. 

* The entire array is read/write enabled. 

* @param length the size (in bytes) of the byte[] to create to 
back the new ByteWrapper 

*/ 

public 

ByteWrapper(int length) 

{ 

this (new byte [length] ) ,- //exception if length zero? 


j * * 

* Constructs a new ByteWrapper backed by the specified pre¬ 
existing byte[] buffer. 

* Lower bound will be zero, upper bound will be the buffer.length. 

* (Changes to the Byte Wrapper will write through to buffer) 

* The entire array is read/write enabled. 

* @param buffer the byte[] to use to back the new ByteWrapper 
*/ 

public 

ByteWrapper(byte[] buffer) 

{ 

this(buffer, 0, buf fer. length) ,- 


DRDC Valcartier TR 2007-412 


409 



* * 


* Constructs a new ByteWrapper backed by the specified pre¬ 
existing byte[] buffer and 

* specifies the buffer's lower bound. 

* Upper bound will be the buffer.length. 

* (Changes to the Byte Wrapper will write through to buffer) 

* The array is read/write enabled from the lower bound (included) 
to the upper bound (excluded) . 

* @param buffer the byte[] to use to back the new ByteWrapper 

* @param lowerBound the first accessible position within the 
byte[] 

* @throws ArraylndexOutOfBoundsException if the lowerBound is 
greater than the buffer.length 

*/ 

public 

ByteWrapper(byte[] buffer, int lowerBound) 

{ 

this (buffer, lowerBound, buf fer . length) ,- 


j * * 

* Constructs a new ByteWrapper backed by the specified pre¬ 
existing byte[] buffer and 

* specifies the buffer's lower and upper bounds. 

* (Changes to the Byte Wrapper will write through to buffer) 

* The array is read/write enabled from the lower bound (included) 
to the upper bound (excluded). 

* @param buffer the byte[] to use to back the new ByteWrapper 

* @param lowerBound the first accessible position within the 
byte[] 

* @param upperBound the position within the byte[] before which 
the last accessible byte lies 

* @throws ArraylndexOutOfBoundsException if the lowerBound is 
greater than the upperBound or if the upperBound is greater than the 
buffer.length 

*/ 

public 

ByteWrapper(byte[] buffer, int lowerBound, int upperBound) 

{ 

_buffer = buffer ,- 
_lowerBound = lowerBound; 

_pos = _lowerBound; 

_upperBound = upperBound ,- 

if (_upperBound > buffer.length) throw new 
ArraylndexOutOfBoundsException (_upperBound) ,- 
verify (0) ,- 


410 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a new ByteWrapper from the specified AttributeHandle 
Object. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the AttributeHandle to encode into the new ByteWrapper 
*/ 

public 

ByteWrapper(hla.rtil516.AttributeHandle o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o . encode (bytes , 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


j * * 

* Constructs a new ByteWrapper from the specified DimensionHandle 
Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the DimensionHandle to encode into the new ByteWrapper 
*/ 

public 

ByteWrapper(hla.rtil516.DimensionHandle o) 

{ 

final byte[] bytes = new byte [o. encodedLength ()] ,- 
o . encode (bytes , 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


DRDC Valcartier TR 2007-412 


411 



* * 


* Constructs a new ByteWrapper from the specified FederateHandle 
Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the FederateHandle to encode into the new ByteWrapper 
*/ 

public 

ByteWrapper(hia.rtil516.FederateHandle o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o .encode (bytes, 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


j * * 

* Constructs a new ByteWrapper from the specified 
InteractionClassHandle Object. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the InteractionClassHandle to encode into the new 
ByteWrapper 

*/ 

public 

ByteWrapper(hia.rtil516.InteractionClassHandle o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o .encode (bytes, 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


412 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a new ByteWrapper from the specified LogicalTime 
Object. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the LogicalTime to encode into the new ByteWrapper 
*/ 

public 

ByteWrapper(hla.rtil516.LogicalTime o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o . encode (bytes , 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


j * * 

* Constructs a new ByteWrapper from the specified 
LogicalTimelnterval Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the LogicalTimelnterval to encode into the new 
ByteWrapper 

*/ 

public 

ByteWrapper(hla.rtil516.LogicalTimelnterval o) 

{ 

final byte[] bytes = new byte [o. encodedLength ()] ,- 
o . encode (bytes , 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


DRDC Valcartier TR 2007-412 


413 



* * 


* Constructs a new ByteWrapper from the specified 
Obj ectClassHandle Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the ObjectClassHandle to encode into the new 
ByteWrapper 

*/ 

public 

ByteWrapper(hia.rtil516.ObjectClassHandle o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o .encode (bytes, 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


j * * 

* Constructs a new ByteWrapper from the specified 
Obj ectlnstanceHandle Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the ObjectlnstanceHandle to encode into the new 
ByteWrapper 

*/ 

public 

ByteWrapper(hia.rtil516.ObjectlnstanceHandle o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o .encode (bytes, 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


414 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a new ByteWrapper from the specified OrderType 
Object. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the OrderType to encode into the new ByteWrapper 
*/ 

public 

ByteWrapper(hla.rtil516.OrderType o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o . encode (bytes , 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


j * * 

* Constructs a new ByteWrapper from the specified ParameterHandle 
Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the ParameterHandle to encode into the new ByteWrapper 
*/ 

public 

ByteWrapper(hla.rtil516.ParameterHandle o) 

{ 

final byte[] bytes = new byte [o. encodedLength ()] ,- 
o . encode (bytes , 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


DRDC Valcartier TR 2007-412 


415 



* * 


* Constructs a new ByteWrapper from the specified 
TransportationType Obj ect. 

* This is a convenience constructor, provided to facilitate using 
this HLA object. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the TransportationType to encode into the new 
ByteWrapper 

*/ 

public 

ByteWrapper(hia.rtil516.TransportationType o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o .encode (bytes, 0) ,- 
_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


j * * 

* Constructs a new ByteWrapper from the specified HLAencodable 
Obj ect. 

* This is a convenience constructor, provided to facilitate using 
the HLA objects. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* @param o the HLAencodable Object to encode into the new 
ByteWrapper 

*/ 

public 

ByteWrapper(HLAencodable o) 

{ 

final byte[] bytes = new byte [o . encodedLength ()] ,- 
o .encode (bytes, 0) ,- 

//Now we can pass this to the (byte[]) constructor: 

// this (bytes) ,- 

//Which passes it to the (byte[], int, int) constructor: 

// this (bytes, 0, bytes . length) ,- 
//Which does: 

_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 


416 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a new ByteWrapper from the specified Object, which is 
presumed to have 

* the encode(byte[] buffer, int offset) and encodedLength() 
methods. 

* This is a convenience constructor, provided to facilitate using 
the HLA objects. 

* Lower bound will be zero, upper bound will be the encodedLength. 

* The entire array is read/write enabled. 

* <p> 

* Things would be an awful lot simpler if IEEE 1516 specified an 
Encodable interface 

* consisting of those two methods (see the constructor that 
precedes this one). 

* @param o the Object to encode into the new ByteWrapper 
public 

ByteWrapper(Obj ect o) 

// throws IllegalArgumentException //if the Object does not support 
the encode and encodedLength methods 
{ 

try 


java.lang.reflect.Method eL = 
o . get Class () . getMethod (" encodedLength' 1 , null) ,- 

//throws NoSuchMethodException, SecurityException 
final byte[] bytes = new byte[((Integer)(eL.invoke(o, 
null) ) ) . intValue () ] ,- 

j ava . lang .re fleet. Met hod e = o.getClass () .getMethod(" encode' 1 
new Class [] { byte [].class, int.class }),- 

e.invoke(o, new object [] { bytes, new Integer(O) }),- 

//throws IllegalAccessException, IllegalArgumentException, 
InvocationTargetException 

//The rest wouldn't need to be inside the try if it weren't 
for bytes being local to it 

//Now we can pass this to the (byte[]) constructor: 

// this (bytes) ,- 

//Which passes it to the (byte[], int, int) constructor: 

// this (bytes, 0, bytes . length) ,- 

//Which does : 

_lowerBound = 0; 

_pos = _lowerBound; 

_upperBound = bytes.length; 
verify (0) ,- 

} catch (Exception ex) { 

//For some unfathomable reason, throwing this here and 
declaring it above does not compile. 

//Since all HLA objects do support HLAencodable, it cannot 
occur anyway. 

// throw new 

IllegalArgumentException (ex .getLocalizedMessage () ) . initCause (ex) ,- 


*/ 


DRDC Valcartier TR 2007-412 


417 



* * 


* Returns the complete backing array. 

* The returned array runs from zero to length, not just from the 
lower to the upper bound. 

* @return the complete byte[] backing the ByteWrapper 
*/ 

public final byte[] 
array () 

{ 

return _buffer; 


j * * 

* Returns the lower bound. 

* @return the ByteWrapper's lower bound 
*/ 

public final int 
lowerBound () 

{ 

return lowerBound; 


j * * 

* Returns the upper bound. 

* @return the ByteWrapper's upper bound 
*/ 

public final int 
upperBound () 

{ 

return _upperBound; 


j * * 

* Returns the current position. 

* @return the current read/write position of the ByteWrapper 
*/ 

public final int 
pos () 


return _pos; 


j * * 

* Resets the current position to the first accessible byte (the 
lower bound) of the ByteWrapper. 

*/ 

public void 
reset () 

{ 

_pos = _lowerBound; 


418 


DRDC Valcartier TR 2007-412 



* * 


* Throws an exception if there aren't at least <code>length</code> 
accessible bytes from the current position onward. 

* In other words, verifies that the current position plus 
<code>length</code> does not overshoot the upper bound. 

* @param length the length to verify the ByteWrapper for, measured 
from the current position 

* @throws ArraylndexOutOfBoundsException if the current position 
plus length is beyond the upperBound of the ByteWrapper 

*/ 

private final void 
verify(int length) 

{ 

if ((_pos + length) > _upperBound) throw new 
ArraylndexOutOfBoundsException (_pos + length) ,- 


j * * 

* Gets the next n bytes (a power of two, normally) from the 
wrapped byte array 

* as a big-endian 64-bit integer. 

* The ByteWrapper's current position is increased by n. 

* @param n the number of bytes to get 

* @param bigendian whether the source bytes are in big-endian 
order or not 

* @return a long decoded value 

* @throws IllegalArgumentException if n is not within the 0..8 
range 

* @throws ArraylndexOutOfBoundsException if there are not at least 
n bytes left in the wrapped byte array 

*/ 

private long 
getBytes(int n, 

boolean bigendian) 
throws IllegalArgumentException 


if ((n < 0) || (n > 8)) throw new 

IllegalArgumentExcept ion (Integer . toString (n) ) ,- 
verify (n) ,- 
long value = 0; 
if (bigendian) 


for (int nn 
value += 


n - 1; nn >= 0; nn--) 

buffer[_pos++] & OxOOFFL) << (8*nn); 


else 


for (int nn 
value += 


0; nn < n,- nn++) 

buffer[_pos++] & OxOOFFL) << (8*nn); 


return value,- 


DRDC Valcartier TR 2007-412 


419 



* * 


* Gets the next eight bytes from the wrapped byte array as a big- 
endian 64-bit integer. 

* The ByteWrapper's current position is increased by 8. 

* @return a long decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up a long 

*/ 

public final long 
getLong() 

{ 

return getBytes(8, true); 


j * * 

* Gets the next eight bytes from the wrapped byte array as a 
little-endian 64-bit integer. 

* The ByteWrapper's current position is increased by 8. 

* @return a long decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up a long 

*/ 

public final long 
getLongLE() 

{ 

return getBytes(8, false); 


j * * 

* Gets the next four bytes from the wrapped byte array as a big- 
endian 32-bit integer. 

* The ByteWrapper's current position is increased by 4. 

* @return an int decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up an int 

*/ 

public final int 
getlnt() 

{ 

return (int)getBytes(4 , true); 


j * * 

* Gets the next four bytes from the wrapped byte array as a 
little-endian 32-bit integer. 

* The ByteWrapper's current position is increased by 4. 

* @return an int decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up an int 

*/ 

public final int 
getlntLE() 

{ 

return (int)getBytes(4 , false); 


420 


DRDC Valcartier TR 2007-412 



* * 


* Gets the next two bytes from the wrapped byte array as a big- 
endian 16-bit integer. 

* The ByteWrapper's current position is increased by 2. 

* @return a short decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up a short 

*/ 

public final short 
getShort () 

{ 

return (short)getBytes(2, true); 


j * * 

* Gets the next two bytes from the wrapped byte array as a little- 
endian 16-bit integer. 

* The ByteWrapper's current position is increased by 2. 

* @return a short decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up a short 

*/ 

public final short 
getShortLE() 

{ 

return (short)getBytes(2, false); 


j * * 

* Gets the next two bytes from the wrapped byte array as an 
unsigned 16-bit char. 

* The ByteWrapper's current position is increased by 2. 

* @return a char decoded value 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to make up a char 

*/ 

public final char 
getChar() 

{ 

return (char)getBytes(2, true); 


j * * 

* Gets the next byte from the wrapped byte array. 

* The ByteWrapper's current position is increased by 1. 

* @return an int decoded value (representing a single byte) 

* @throws ArraylndexOutOfBoundsException if there isn't at least 
one byte left in the wrapped byte array 

*/ 

public final byte 
getByte() 

{ 

// return (byte)getBytes (1, true); 
verify(1); 

// return (_buffer[_pos++] & OxFF); 

return _buffer[_pos++]; 


DRDC Valcartier TR 2007-412 


421 



* * 


* Writes to the specified byte array from the wrapped byte array. 

* The ByteWrapper's current position is increased by dest.length. 

* @param dest the byte[] to fill from the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to fill the dest byte[] 

*/ 

public final ByteWrapper 
write (byte [] dest) 

{ 

verify(dest.length),- 

System.arraycopy(_buffer, _pos, dest, 0, dest. length) ,- 
_pos += dest.length; 
return this; 


j * * 

* Puts the value into the wrapped byte array; it is n bytes wide 
(a power of two, normally) 

* and is big-endian if the boolean is true. 

* @param value a long holding the value to put in 

* @param n the number of bytes to put in 

* @param bigendian whether the value should be written big-endian 
or not 

* @throws IllegalArgumentException if n is not within the 0..8 
range 

* @throws ArraylndexOutOfBoundsException if there are not at least 
n bytes left in the wrapped byte array 

*/ 

private void 
putBytes(long value, 

int n, 

boolean bigendian) 
throws IllegalArgumentException 

{ 

if ((n < 0) || (n > 8)) throw new 

IllegalArgumentException (Integer. toString (n) ) ,- 
verify (n) ,- 
if (bigendian) 

{ 

for (int nn = n - 1,- nn >= 0,- nn--) 

_buf fer [_pos + + ] = (byte) ((value >>> (8*nn)) & OxFF); 

} 

else 

{ 

for (int nn = 0; nn < n,- nn++) 

_buf fer [_pos + + ] = (byte) ((value >>> (8*nn)) & OxFF); 


422 


DRDC Valcartier TR 2007-412 



* * 


* Puts value into the wrapped byte array as a big-endian 64-bit 
integer. 

* The ByteWrapper's current position is increased by 8. 

* @param value the long to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write a long into 

*/ 

public final ByteWrapper 
putLong(long value) 

{ 

putBytes(value, 8, true); 
return this; 


j * * 

* Puts value into the wrapped byte array as a little-endian 64-bit 
integer. 

* The ByteWrapper's current position is increased by 8. 

* @param value the long to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write a long into 

*/ 

public final ByteWrapper 
putLongLE(long value) 

{ 

putBytes(value, 8, false); 
return this; 


j * * 

* Puts value into the wrapped byte array as a big-endian 32-bit 
integer. 

* The ByteWrapper's current position is increased by 4. 

* @param value the int to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write an int into 

*/ 

public final ByteWrapper 
putlnt(int value) 

{ 

putBytes(value, 4, true); 
return this; 


DRDC Valcartier TR 2007-412 


423 



* * 


* Puts value into the wrapped byte array as a little-endian 32-bit 
integer. 

* The ByteWrapper's current position is increased by 4. 

* @param value the int to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write an int into 

*/ 

public final ByteWrapper 
putlntLE(int value) 

{ 

putBytes(value, 4, false); 
return this; 


j * * 

* Puts value into the wrapped byte array as a big-endian 16-bit 
integer. 

* The ByteWrapper's current position is increased by 2. 

* @param value the short to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write a short into 

*/ 

public final ByteWrapper 
putShort(short value) 

{ 

putBytes (value, 2, true); 
return this,- 


j * * 

* Puts value into the wrapped byte array as a little-endian 16-bit 
integer. 

* The ByteWrapper's current position is increased by 2. 

* @param value the short to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write a short into 

*/ 

public final ByteWrapper 
putShortLE(short value) 

{ 

putBytes(value, 2, false); 
return this,- 


424 


DRDC Valcartier TR 2007-412 



* * 


* Puts value into the wrapped byte array as an unsigned 16-bit 
char. 

* The ByteWrapper's current position is increased by 2. 

* @param value the char to write to the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to write a char into 

*/ 

public final ByteWrapper 
putChar(char value) 

{ 

putBytes(value, 2, true); 
return this; 


j * * 

* Puts the byte b into the wrapped byte array. 

* The ByteWrapper's current position is increased by 1. 

* @param b int to put into the wrapped byte array's current byte 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there isn't at least 
one byte left in the wrapped byte array to write to 

*/ 

public final ByteWrapper 
putByte(byte b) 

{ 

// putBytes(value, 1, true); 
verify(1); 

_buffer[_pos++] = b; 
return this; 


j * * 

* Reads a byte array into the wrapped byte array. 

* The ByteWrapper's current position increases by the array's 
size. 

* @param src byte[] to read into the wrapped byte array 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to read the src byte[] into 

*/ 

public final ByteWrapper 
read(byte[] src) 

{ 

verify(src.length); 

System.arraycopy(src, 0, _buffer, _pos, src.length); 

_pos += src.length; 
return this; 


DRDC Valcartier TR 2007-412 


425 



* * 


* Skips n bytes without reading from or writing to them. 

* @param n an int specifying by how many bytes to advance the 
current position 

* @return this ByteWrapper 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to skip ahead as requested 

*/ 

public final ByteWrapper 
skip(int n) 

{ 

verify(n) ; 

_pos += n; 
return this; 


j * * 

* Advances the current position until the specified byte alignment 
is achieved (typically a power of 2). 

* @param alignment an int specifying what the current position 
should be a whole multiple of 

* @throws ArraylndexOutOfBoundsException if there are not enough 
bytes left in the wrapped byte array to align as requested 

*/ 

public final void 
align(int alignment) 

{ 

while ((_pos % alignment) != 0) skip(l); 


j * * 

* Creates a new ByteWrapper backed by the same byte array but 
using the current position as its lower bound. 

* The upper bound is inherited. 

* @return a new ByteWrapper backed by the same byte[] and whose 
lower bound is the current position 

*/ 

public final ByteWrapper 
slice () 

{ 

return new ByteWrapper(_buffer, _pos, _upperBound); 


426 


DRDC Valcartier TR 2007-412 



* * 


* Creates a new ByteWrapper backed by the same byte array but 
using the current 

* position as its lower Bound and the specified length to mark the 
upper bound. 

* @param length an int specifying the new ByteWrapper's upper 
bound, measured from the current position 

* @return a new ByteWrapper backed by the same byte[], but whose 
accessible bytes run from the current position (included) to length 
bytes further 

* @throws ArraylndexOutOfBoundsException if there are not at least 
length bytes left in the ByteWrapper 

*/ 

public final ByteWrapper 
slice (int length) 

{ 

verify(length); 

return new ByteWrapper(_buffer, _pos, _pos + length); 


//j ava.lang.Object methods 

j * * 

* Creates and returns a copy of this object. 

* The cloned Object will be backed by a copy of the original 
byte [ ] . 

* @return an independent copy of this Object 

* @throws CloneNotSupportedException if the object's class is not 
Cloneable or if the instance cannot be cloned 

*/ 

public Object 
clone () 

throws CloneNotSupportedException 

{ 

// throw new CloneNotSupportedException(); 

ByteWrapper theClone = new ByteWrapper(_buffer.length); 

theClone._lowerBound = this._lowerBound; 

theClone._pos = this._pos; 

theClone._upperBound = this._upperBound; 

System.arraycopy(this._buffer, 0, theClone._buffer, 0, 
theClone._buffer.length) ; 

return theClone; 

// return (Object)theClone; 


DRDC Valcartier TR 2007-412 


427 



j k k 

* Compares the specified object with this one for equality. 

* Returns <tt>true</tt> if and only if the specified object is 
also a 

* ByteWrapper (or descendant), and both have the same backing 
store and bounds. 

* @param obj the Object to be compared for equality with this one 

* @return <tt>true</tt> if the specified Object is equal to this 

one 

*/ 

public boolean 
equals(Obj ect obj) 

{ 

//The java.lang.Object implementation is simply: 

// return (this == obj); 

//Trivial case: both this and obj are references to the same 

obj ect 

if (obj == this) return true; 

//obj must be an instance of this class or a descendant. 
//However, we do NOT want sibling classes to be "equal". 

//If we did this: 

// if (l(obj instanceof ByteWrapper)) return false; 

//Then two sibling classes (that descend from ByteWrapper along 
diverging paths) 

//would nevertheless be considered equal since their inherited 
equals() 

//would compare them to their common super-class, ByteWrapper. 
//Doing this: 

// if (l this.getclass().islnstance(obj)) return false; 

//Insures that obj's class descends from this' class, but the 
method is then not symmetric 

//So we match the classes instead: 

if (l this.getclass().equals(obj.getclass())) return false; 

//So far so good; now compare relevant fields 

return ((_buffer == ((ByteWrapper)obj).array() ) && 

(_lowerBound == ((ByteWrapper)obj).lowerBound()) && 
(_ u PP e rB° un d == ( (ByteWrapper) obj ) . upperBound () ) ) ,- 

//The cursor (i.e. _pos vs obj.posO) is not relevant 


//end ByteWrapper 


428 


DRDC Valcartier TR 2007-412 



The HLAencodable interface is supported by just about all HLA objects. 


// File: HLAencodable.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

j * * 

* Interface which just about all HLA interfaces and object types 
support. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface 
HLAencodable 
{ 

j * * 


* Returns 

the 

length 

(in bytes) 

of 

the 

<code>byte[ 

] </code> 

representation 

of 

<code>this</code> 





* @return 

the 

length 

(in bytes) 

of 

the 

<code>byte[ 

] </code> 


representation of <code>this</code> 

*/ 

public int 
encodedLength() ; 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

* @return how many bytes were written to the buffer, including any 
prefix padding bytes 

*/ 

public int 

encode(byte[] buffer, 
int offset) ,- 

} 

//end HLAencodable 


DRDC Valcartier TR 2007-412 


429 



The HLAdatatype interface is the minimal one supported by all HLA datatypes. 


// File: HLAdatatype.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Interface implemented by the various HLA data types. 

* <p> 

* In addition to this interface, the HLA data type classes are 
expected to supply: 

* <ul > 

* <li> Constructors (default and specified-value)</li> 

* <li> Constructor (byte[] buffer) throws CouldNotDecode</li> 

* <li> Constructor (byte[] buffer, int offset) throws 
CouldNotDecode</li> 

* <li> Constructor (ByteWrapper byteWrapper) throws 
CouldNotDecode</li> 

* <li> java.lang.Object methods toStringO; equals(Object 
otherObject) and hashCode ()</li> 

* <li> Class-specific extensions to get and set the value as a basic 
Java data type (int, boolean, etc.)</li> 

* </ul> 

* Note that even though encodedLength (sometimes) and octetBoundary 
(always) could be static methods, Java forbids an 

* interface method from being static, and also forbids an interface 
method implementation from being static. 

* This is because static invocation mode isn't like virtual 
invocation mode in the sense that the method invoked will be the 

* *local* one instead of the run-time class'. For example, suppose 
XX descends from X, and that X defines methods M and MM. 

* XX overrides MM but not M. When XX.M is invoked, its resolution is 
passed to X.M. If MM is non-static, then a 

* (virtual) invocation of MM by X.M will invoke XX.MM. If MM is 
static, on the other hand, then a (static) invocation of MM by 

* X.M will invoke X.MM instead. Thus, to ensure proper polymorphism 
one must not use static methods. 

* <p> 

* Nevertheless, to allow obtaining a class' octetBoundary and/or 
encodedLength, when these are defined at the class level, one 

* need only declare (public static final) *fields* of those names. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 


430 


DRDC Valcartier TR 2007-412 



public interface 
HLAdatatype 

extends HLAencodable 

{ 

j * * 

* As a general rule, Variant Records [HLAvariantRecord], Dynamic 
Arrays [HLAvariableArray], and any 

* Fixed Arrays [HLAfixedArray] or Fixed Records [HLAfixedRecord] 
containing either of these first two 

* cannot have a constant encodedLength. 

*/ 

j * * 

* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* <p> 

* In all cases, octetBoundary is constant. 

* @return the octet boundary of <code>this</code> 

*/ 

int 

octetBoundary () ,- 

j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

ByteWrapper 

encode (ByteWrapper byteWrapper) ,- 
j ± ± 

* Encodes <code>this</code> into a new <code>byte[]</code>. 

* @return a <code>byte[]</code> encoding <code>this</code> 

*/ 

byte[] 

toByteArray () ,- 

j * * 

* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the data type 

* @return how many bytes were read from the <code>byte[]</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer) 

throws CouldNotDecode,- 


DRDC Valcartier TR 2007-412 


431 



* * 


* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> <code>this</code> 
representation begins 

* @return where in the <code>buffer</code> <code>this</code> 
representation ends 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer, 
int offset) 
throws CouldNotDecode; 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode; 

} 

//end HLAdatatype 


432 


DRDC Valcartier TR 2007-412 



The HLAbasicType abstract class regroups behaviour common to the HLA basic 
datatypes. 


// File: HLAbasicType.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Abstract ancestor for the type-safe simple and basic data types. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public abstract class 
HLAbasicType 

implements j ava.io.Serializable, 
j ava.lang.Cloneable, 

HLAdatatype 

{ 

//HLAdatatype interface implementation 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

* @return how many bytes were written to the buffer, including any 
prefix padding bytes 

*/ 

public int 

encode(byte[] buffer, 
int offset) 

{ 

return encode(new ByteWrapper(buffer, offset)) .pos () - offset; 


j * * 

* Encodes <code>this</code> into a new <code>byte[]</code>. 

* @return a <code>byte[]</code> encoding <code>this</code> 
*/ 

public byte[] 
toByteArray() 

{ 

return encode (new ByteWrapper (encodedLength () ) ) . array () ,- 


DRDC Valcartier TR 2007-412 


433 



* * 


* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @return how many bytes were read from the <code>byte[]</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer) 

throws CouldNotDecode 

{ 

return decode(buffer, 0); 


j * * 

* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> <code>this</code> 
representation begins 

* @return where in the <code>buffer</code> <code>this</code> 
representation ends 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

try 


return decode(new ByteWrapper(buffer, offset)).pos(); 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


434 


DRDC Valcartier TR 2007-412 



//Cloneable implementation 

j * * 

* Creates and returns a copy of this object. 

* @return an independent copy of this Object 

* @throws CloneNotSupportedException if the object's class is not 
Cloneable or if the instance cannot be cloned 

*/ 

public Object 
clone () 

throws CloneNotSupportedException 

{ 

// throw new CloneNotSupportedException(); 
return super.clone(); 


//end HLAbasicType 


DRDC Valcartier TR 2007-412 


435 



The next twenty classes implement the HLA basic datatypes, including our HLAnull 
addition. 

The pattern is constant: each class declares a protected value-holder field, final static 
fields for encodedLength and octetBoundary, then the constructors (default, 
class-specific, byte [] , byte[] with offset, ByteWrapper), and the 
j ava. lang .Obj ect methods toString, equals and hashCode. Next, the 
HLAdatatype interface, already partially implemented by HLAbasicType, is 
completed: the encodedLength and octetBoundary methods simply reflect the 
static fields (something which the more complex datatypes cannot do), and the 
encode (ByteWrapper) and decode (ByteWrapper) methods (which 
HLAbasicType delegates to) are supplied. Finally, any class-specific extensions 
(get/ setvalue) are added. 

Each of the big-endian/little-endian datatype pairs is implemented first through an 
abstract class that regroups common fields and methods. 


/ / File: HLAnul1.j ava 

package ca.go.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Type-safe null basic data type. 

* <p> 

* <code>HLAnull</code> is not part of the HLA spec; it is used only 
to make the HLAobjectArray class 

* concrete by providing a zero-size implementation of HLAdatatype. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAnull 

extends HLAbasicType 

{ 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 0; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 1; 


436 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAnull</code>. 

*/ 

public 
HLAnull () 

{ 

//super () not called because super-class is abstract 


j * * 

* Creates a <code>HLAnull</code> from the network representation 
in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAnull</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAnull(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAnull</code> from the network representation 
in the provided <code>byte[]</code> at the indicated 

<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAnull</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAnull</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAnull(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


437 



* * 


* Creates a <code>HLAnull</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAnull</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAnull(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//j ava.lang.Obj ect methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

return "null"; 


j * * 

* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

//This form is more inheritable: match classes 
return this.getClass() .equals(otherObj ect.getClass()) ; 


438 


DRDC Valcartier TR 2007-412 



* * 


* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(j ava.lang.Object) 

Object.equals(j ava.lang.Object) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return 0; 


//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


j * * 

* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()); //Won't move cursor 
return byteWrapper; //No change 


DRDC Valcartier TR 2007-412 


439 



* * 


* Sets <code>this</code> value from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 

{ 

byteWrapper.align(octetBoundary()); //Won't move 
return byteWrapper; //No change 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


//end HLAnull 


440 


DRDC Valcartier TR 2007-412 



// File: HLAoctet.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 
import hla.rtil516.CouldNotDecode; 
j * * 

* Type-safe 8-bit byte basic data type. 

* <p> 

* <code>HLAoctet</code>s are normally never obtained directly, as the 
RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAoctetFactory</code>'s decode method on a <code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAoctet 

extends HLAbasicType 

{ 

/** The 8-bit byte value: a Java byte. */ 
protected byte _value,- 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 1; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 1; 

j * * 

* Constructs a <code>HLAoctet</code> of default value (zero). 

*/ 

public 
HLAoctet() 

{ 

//super() not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAoctet</code> of the specified value. 

* @param value a byte specifying <code>this</code>' value 
*/ 

public 

HLAoctet(byte value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


441 



* * 


* Creates a <code>HLAoctet</code> from the network representation 
in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAoctet</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAoctet(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAoctet</code> from the network representation 
in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAoctet</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAoctet</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAoctet(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAoctet</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAoctet</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAoctet(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


442 


DRDC Valcartier TR 2007-412 



//j ava.lang.Object methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return Byte.toString(getValue() ) ; 


j * * 

* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode () 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals (Object otherObject) 

{ 

if (this == otherObject) return true; 

// if (l(otherObject instanceof HLAoctet)) return false; 

// final HLAoctet other = (HLAoctet)otherObject; 

// return (getValue() == other.getValue()); 

//This form is more inheritable: first, match the classes 
if (l this.getClass().equals(otherObj ect.getClass())) return 

false; 

return (getValue() == ((HLAoctet)otherObj ect) .getValue()) ; 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Obj ect#equals(j ava.lang.Obj ect) 

Object.equals(j ava.lang.Object) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Byte(getValue()).hashCode(); 


DRDC Valcartier TR 2007-412 


443 



//HLAdatatype interface implementation 


j k k 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


j k k 

* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j k k 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()); 
return byteWrapper.putByte(getValue()); 


444 


DRDC Valcartier TR 2007-412 



* * 


* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 
setValue(byteWrapper.getByte()); 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


//Class-specific extensions 

j * * 

* Returns the byte value of <code>this</code>. 

* @return the byte value of <code>this</code> 

* @see #setValue 

*/ 

public byte 
getValue() 

{ 

return _value; 


j * * 

* Sets the byte value of <code>this</code>. 

* @param value the byte new value for <code>this</code> 

* @see #getValue 
*/ 

public void 
setValue(byte value) 

{ 

value = value; 


//end HLAoctet 


DRDC Valcartier TR 2007-412 


445 



// File: HLAoctetPair.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Abstract type-safe 16-bit octet-pair basic data type. 

* It uses the <code>char</code> Java type (an unsigned 16-bit 
integer) to store the value 

* and is the ancestor of the HLAoctetPairBE and HLAoctetPairLE 
concrete classes. 

* <p> 

* Note that HLAoctetPair is the only data type to actually store the 
unmodified byte sequence; 

* all other types instead store the value represented by the byte 
sequence. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAoctetPair 

extends HLAbasicType 

{ 

j * * 

* The 16-bit octet-pair value: a Java char. 

* As an unsigned 16-bit, the bytes will be in appropriate endian 
order. 

*/ 

protected char _value; 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 2; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 2; 


446 


DRDC Valcartier TR 2007-412 



//j ava.lang.Object methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

String s = "Ox"; 

if (getFirstByte() < 0x0010) s = s + "0"; 

s = s + Integer.toHexString(getFirstByte()); 

S = S + " Ox"; 

if (getSecondByte() < 0x0010) s = s + "0"; 

s = s + Integer.toHexString(getSecondByte()) ; 
return s; 


j * * 

* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode () 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals (Object otherObject) 

{ 

if (this == otherObject) return true; 

if (l this.getclass().equals(otherObj ect.getClass())) return 

false; 

// if (this.isBigEndian () l = 

((HLAoctetPair)otherObj ect) .isBigEndian ()) return false; 

return (getValue() == ((HLAoctetPair)otherObj ect) .getValue()) ; 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Obj ect#equals(j ava.lang.Obj ect) 

Object.equals(j ava.lang.Object) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Character(getValue()).hashCode(); 


DRDC Valcartier TR 2007-412 


447 



//HLAdatatype interface implementation 


j k k 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


j k k 

* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j k k 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()); 
return byteWrapper.putChar(getValue()); 


448 


DRDC Valcartier TR 2007-412 



* * 


* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 
setValue(byteWrapper.getChar()); 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


//Class-specific extensions 


j * * 

* Returns the char value of <code>this</code>. 

* The char's bytes will be in the appropriate endian order; 

* in other words, returns the unmodified byte sequence. 

* @return the char value of <code>this</code> 

* @see #setValue 
*/ 

protected char 
getValue() 

{ 

return _value; 


j * * 

* Returns the first byte value of <code>this</code>. 

* @return the first byte value of <code>this</code> 

* @see #setFirstByte 

*/ 

public byte 
getFirstByte() 

{ 

return (byte)(_value >>> 8); // >>> is right-shift with zero- 
extension 


DRDC Valcartier TR 2007-412 


449 



j k k 

* Returns the second byte value of <code>this</code>. 

* @return the second byte value of <code>this</code> 

* @see #setSecondByte 
*/ 

public byte 
getSecondByte() 

{ 

return (byte)(_value & OxOOFF); 


j k k 

* Returns the high byte value of <code>this</code>. 

* @return the high byte value of <code>this</code> 

* @see #setHighByte 

*/ 

public byte 
getHighByte() 

{ 

return ( IsBigEndian() ? getFirstByte() : getSecondByte() ); 


j k k 

* Returns the low byte value of <code>this</code>. 

* @return the low byte value of <code>this</code> 

* @see #setLowByte 

*/ 

public byte 
getLowByte() 

{ 

return ( IsBigEndian() ? getSecondByte() : getFirstByte() ); 


j k k 

* Sets the char value of <code>this</code>. 

* The char's bytes will be stored in unmodified sequence; 

* in other words, the char should be the appropriate-endian 
representation of the octet pair. 

* @param value the char new value for <code>this</code> 

* @see #getValue 
*/ 

protected void 
setValue(char value) 

{ 

_value = value; 


450 


DRDC Valcartier TR 2007-412 



j k k 

* Sets the first byte value of <code>this</code>. 

* @param firstByte the new byte value for <code>this</code>' first 

byte 

* @see #getFirstByte 

*/ 

public void 

setFirstByte(byte firstByte) 

{ 

_value = (char)((_value & OxOOFF) | ( ((int)firstByte) << 8 )); 


j k k 

* Sets the second byte value of <code>this</code>. 

* @param secondByte the new byte value for <code>this</code>' 
second byte 

* @see #getSecondByte 
*/ 

public void 

setSecondByte(byte secondByte) 

{ 

_value = (char)((_value & OxFFOO) | secondByte); 


j k k 

* Sets the high byte value of <code>this</code>. 

* @param highByte the new byte value for <code>this</code>' high 

byte 

* @see #getHighByte 

*/ 

public void 

setHighByte(byte highByte) 

{ 

if (isBigEndian()) { setFirstByte(highByte); } else { 

setSecondByte(highByte); } 


j k k 

* Sets the low byte value of <code>this</code>. 

* @param lowByte the new byte value for <code>this</code>' low 

byte 

* @see #getLowByte 
*/ 

public void 

setLowByte(byte lowByte) 

{ 

if (isBigEndian()) { setSecondByte(lowByte); } else { 

setFirstByte(lowByte); } 


DRDC Valcartier TR 2007-412 


451 



* * 


* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public abstract boolean 
isBigEndian(),- 

//If we declare isBigEndian() static, it won't work: static 
invocation mode isn't like virtual invocation mode in the sense 

//that the method invoked will be the *local* one instead of the 
run-time class'. In other words, when a descendant of 

//HLAoctetPair invokes one of the inherited methods defined here, 
if isBigEndian is static then HLAoctetPair's isBigEndian 
//will be invoked, not the descendant's... 

// 

//Likewise, we cannot rely on a field, because fields are never 
virtual in their invocation mode. 

//Finally, declaring a "blank final" (non-static) field set by the 
constructors works for this class but fails for the 

//descendants (which cannot assign to the inherited final). 

} 

//end HLAoctetPair 


452 


DRDC Valcartier TR 2007-412 



// File: HLAoctetPairBE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 16-bit big-endian octet-pair basic data type. 

* Note that HLAoctetPair is the only data type to actually store the 
unmodified byte sequence,- 

* all other types instead store the value represented by the byte 
sequence. 

* <p> 

* <code>HLAoctetPairBE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAoctetPairBEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAoctetPairBE 

extends HLAoctetPair 

{ 

j * * 

* Constructs a <code>HLAoctetPairBE</code> of default value (zero 
or Unicode null). 

*/ 

public 

HLAoctetPairBE() 

{ 

//super() not called because super-class is abstract 
// setValue('\uOOOO'); 


j * * 

* Constructs a <code>HLAoctetPairBE</code> of the specified char 
value. 

* @param value a char specifying <code>this</code>' value 
*/ 

public 

HLAoctetPairBE(char value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


453 



* * 


* Constructs a <code>HLAoctetPairBE</code> of the specified short 
value. 

* The short's bytes are stored in unmodified sequence (thus first 
-> high; second -> low). 

* @param value a short specifying <code>this</code>' value 
*/ 

public 

HLAoctetPairBE(short value) 

{ 

this((char)value); 


j * * 

* Constructs a <code>HLAoctetPairBE</code> of the specified value, 
using high and low bytes. 

* @param highByte a byte specifying the high byte of 
<code>this</code>' value 

* @param lowByte a byte specifying the low byte of 
<code>this</code>' value 

*/ 

public 

HLAoctetPairBE(byte highByte, 
byte lowByte) 

{ 

//Note the byte order reversal when compared with HLAoctetPairLE 
this ( (char) (( ( (int) highByte) << 8 ) | lowByte) ),- 


j * * 

* Creates a <code>HLAoctetPairBE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAoctetPairBE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAoctetPairBE(byte[] buffer) 
throws CouldNotDecode 

{ 

this (buffer, 0) ,- 


454 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAoctetPairBE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAoctetPairBE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAoctetPairBE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAoctetPairBE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAoctetPairBE</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAoctetPairBE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAoctetPairBE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


//Class-specific extensions 


j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian () 

{ 

return true; 


//end HLAoctetPairBE 


DRDC Valcartier TR 2007-412 


455 



// File: HLAoctetPairLE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 16-bit little-endian octet-pair basic data type. 

* <p> 

* <code>HLAoctetPairLE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAoctetPairLEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAoctetPairLE 

extends HLAoctetPair 

{ 

j * * 

* Constructs a <code>HLAoctetPairLE</code> of default value (zero 
or Unicode null). 

*/ 

public 

HLAoctetPairLE() 

{ 

//super () not called because super-class is abstract 
// setValue('\uOOOO'); 


j * * 

* Constructs a <code>HLAoctetPairLE</code> of the specified char 
value. 

* @param value a char specifying <code>this</code>' value 
*/ 

public 

HLAoctetPairLE(char value) 

{ 

this ( ) ; 

setValue (value) ,- 


456 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAoctetPairLE</code> of the specified short 
value. 

* The short's bytes are stored in unmodified sequence (thus first 
-> low; second -> high). 

* @param value a short specifying <code>this</code>' value 
*/ 

public 

HLAoctetPairLE(short value) 

{ 

this((char)value) ; 


j * * 

* Constructs a <code>HLAoctetPairLE</code> of the specified value, 
using high and low bytes. 

* @param highByte a byte specifying the high byte of 
<code>this</code>' value 

* @param lowByte a byte specifying the low byte of 
<code>this</code>' value 

*/ 

public 

HLAoctetPairLE(byte highByte, 
byte lowByte) 

{ 

//Note the byte order reversal when compared with HLAoctetPairBE 
this( (char) (( ((int) lowByte) << 8 ) | highByte) ),- 


j * * 

* Creates a <code>HLAoctetPairLE</code> from the network 
representation in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAoctetPairLE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAoctetPairLE(byte[] buffer) 
throws CouldNotDecode 

{ 

this (buffer, 0) ,- 


DRDC Valcartier TR 2007-412 


457 



* * 


* Creates a <code>HLAoctetPairLE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAoctetPairLE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAoctetPairLE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAoctetPairLE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates a <code>HLAoctetPairLE</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAoctetPairLE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAoctetPairLE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//Class-specific extensions 


j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian() 

{ 

return false; 


//end HLAoctetPairLE 


458 


DRDC Valcartier TR 2007-412 



// File: HLAintegerl6.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Abstract type-safe 16-bit integer basic data type. 

* It uses the <code>short</code> Java type to store the value 

* and is the ancestor of the HLAintegerlSBE and HLAintegerlSLE 
concrete classes. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAintegerlS 

extends HLAbasicType 

{ 

/** The 16-bit integer value: a Java short. */ 
protected short _value; 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 2; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 2; 

//j ava.lang.Object methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return Short.toString(getValue() ) ; 


DRDC Valcartier TR 2007-412 


459 



* * 


* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

if (l this.getClass().equals(otherObj ect.getClass ())) return 

false; 

// if (this.isBigEndian() l= 

((HLAintegerlS)otherObj ect) .isBigEndian()) return false; 

return (getValue() == ((HLAintegerlS)otherObj ect) .getValue()) ; 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(java.lang.Object) 

Obj ect.equals(j ava.lang.Obj ect) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Short(getValue()).hashCode(); 


//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


460 


DRDC Valcartier TR 2007-412 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 

return ( IsBigEndian() ? byteWrapper.putShort(getValue()) : 

byteWrapper.putShortLE(getValue()) ); 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 
if (IsBigEndian()) 

{ setValue(byteWrapper.getShort() ) ; } 
else 

{ setValue(byteWrapper.getShortLE()); } 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


DRDC Valcartier TR 2007-412 


461 



//Class-specific extensions 

j * * 

* Returns the short value of <code>this</code>. 

* @return the short value of <code>this</code> 

* @see #setValue 

*/ 

public short 
getValue() 

{ 

return value; 


j * * 

* Sets the short value of <code>this</code>. 

* @param value the short new value for <code>this</code> 

* @see #getValue 
*/ 

public void 
setValue(short value) 

{ 

value = value; 


j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public abstract boolean 
IsBigEndian(); 

} 

//end HLAintegerlS 


462 


DRDC Valcartier TR 2007-412 



// File: HLAintegerlSBE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 16-bit big-endian integer basic data type. 

* It uses the <code>short</code> Java type to store the value. 

* <p> 

* <code>HLAintegerl6BE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAintegerl6BEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAintegerlSBE 

extends HLAintegerlS 

{ 

j * * 

* Constructs a <code>HLAintegerl6BE</code> of default value 
(zero) . 

*/ 

public 

HLAintegerlSBE() 

{ 

//super() not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAintegerl6BE</code> of the specified value. 

* @param value a short specifying <code>this</code>' value 
*/ 

public 

HLAintegerlSBE(short value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


463 



* * 


* Creates a <code>HLAinteger!6BE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAinteger!6BE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAintegerlSBE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAintegerl6BE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAintegerl6BE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAintegerl6BE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAintegerlSBE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAintegerl6BE</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAintegerl6BE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAintegerlSBE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


464 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian () 

{ 

return true; 


//end HLAintegerlSBE 


DRDC Valcartier TR 2007-412 


465 



// File: HLAintegerlSLE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 16-bit little-endian integer basic data type. 

* It uses the <code>short</code> Java type to store the value. 

* <p> 

* <code>HLAintegerl6LE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAintegerl6LEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAintegerlSLE 

extends HLAintegerlS 

{ 

j * * 

* Constructs a <code>HLAintegerl6LE</code> of default value 
(zero) . 

*/ 

public 

HLAintegerlSLE() 

{ 

//super () not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAintegerl6LE</code> of the specified value. 

* @param value a short specifying <code>this</code>' value 
*/ 

public 

HLAintegerlSLE(short value) 

{ 

this ( ) ; 

setValue (value) ,- 


466 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAinteger!6LE</code> from the network 
representation in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAinteger!6LE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAintegerlSLE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAintegerl6LE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAintegerl6LE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAintegerl6LE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAintegerlSLE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAintegerl6LE</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAintegerl6LE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAintegerlSLE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


467 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
IsBigEndian() 

{ 

return false; 


//end HLAintegerlSLE 


468 


DRDC Valcartier TR 2007-412 



// File: HLAinteger32.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Abstract type-safe 32-bit integer basic data type. 

* It uses the <code>int</code> Java type to store the value (not the 
byte sequence). 

* and is the ancestor of the HLAinteger32BE and HLAinteger32LE 
concrete classes. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAinteger32 

extends HLAbasicType 

{ 

/** The 32-bit integer value: a Java int. */ 
protected int _value; 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 4; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 4; 

//j ava.lang.Object methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return Integer.toString(getValue() ) ; 


DRDC Valcartier TR 2007-412 


469 



* * 


* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

if (l this.getClass().equals(otherObj ect.getClass ())) return 

false; 

// if (this.isBigEndian() l= 

((HLAinteger3 2)otherObj ect) .isBigEndian()) return false; 

return (getValue() == ((HLAinteger3 2)otherObj ect) .getValue()) ; 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(java.lang.Object) 

Obj ect.equals(j ava.lang.Obj ect) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Integer(getValue()).hashCode(); 


//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


470 


DRDC Valcartier TR 2007-412 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 

return ( IsBigEndian() ? byteWrapper.putlnt(getValue()) : 

byteWrapper.putIntLE(getValue()) ); 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 
if (IsBigEndian()) 

{ setValue(byteWrapper.getInt() ) ; } 
else 

{ setValue(byteWrapper.getIntLE()); } 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


DRDC Valcartier TR 2007-412 


471 



//Class-specific extensions 

j * * 

* Returns the int value of <code>this</code>. 

* @return the int value of <code>this</code> 

* @see #setValue 

*/ 

public int 
getValue() 

{ 

return value; 


j * * 

* Sets the int value of <code>this</code>. 

* @param value the int new value for <code>this</code> 

* @see #getValue 
*/ 

public void 
setValue(int value) 

{ 

value = value; 


j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public abstract boolean 
IsBigEndian(); 

} 

//end HLAinteger32 


472 


DRDC Valcartier TR 2007-412 



// File: HLAinteger32BE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 32-bit big-endian integer basic data type. 

* It uses the <code>int</code> Java type to store the value (not the 
byte sequence). 

* <p> 

* <code>HLAinteger32BE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAinteger32BEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAinteger32BE 

extends HLAinteger32 

{ 

j * * 

* Constructs a <code>HLAinteger32BE</code> of default value 
(zero) . 

*/ 

public 

HLAinteger32BE() 

{ 

//super() not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAinteger32BE</code> of the specified value. 

* @param value an int specifying <code>this</code>' value 
*/ 

public 

HLAinteger32BE(int value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


473 



* * 


* Creates a <code>HLAinteger32BE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAinteger32BE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger32BE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAinteger32BE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAinteger32BE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAinteger32BE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger32BE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAinteger32BE</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAinteger32BE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteger32BE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


474 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian () 

{ 

return true; 


//end HLAinteger32BE 


DRDC Valcartier TR 2007-412 


475 



// File: HLAinteger32LE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 32-bit little-endian integer basic data type. 

* It uses the <code>int</code> Java type to store the value (not the 
byte sequence). 

* <p> 

* <code>HLAinteger32LE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAinteger32LEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAinteger32LE 

extends HLAinteger32 

{ 

j * * 

* Constructs a <code>HLAinteger32LE</code> of default value 
(zero) . 

*/ 

public 

HLAinteger32LE() 

{ 

//super () not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAinteger32LE</code> of the specified value. 

* @param value an int specifying <code>this</code>' value 
*/ 

public 

HLAinteger32LE(int value) 

{ 

this ( ) ; 

setValue (value) ,- 


476 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAinteger32LE</code> from the network 
representation in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAinteger32LE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger32LE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAinteger32LE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAinteger32LE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAinteger32LE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger32LE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAinteger32LE</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAinteger32LE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteger32LE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


477 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
IsBigEndian() 

{ 

return false; 


//end HLAinteger32LE 


478 


DRDC Valcartier TR 2007-412 



// File: HLAinteger64.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Abstract type-safe 64-bit integer basic data type. 

* It uses the <code>long</code> Java type to store the value (not the 
byte sequence) 

* and is the ancestor of the HLAinteger64BE and HLAinteger64LE 
concrete classes. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAinteger64 

extends HLAbasicType 

{ 

/** The 64-bit integer value: a Java long. */ 
protected long _value; 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 8; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 8; 

//j ava.lang.Object methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return Long.toString(getValue() ) ; 


DRDC Valcartier TR 2007-412 


479 



* * 


* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

if (l this.getClass().equals(otherObj ect.getClass ())) return 

false; 

// if (this.isBigEndian() l= 

((HLAinteger64)otherObj ect) .isBigEndian()) return false; 

return (getValue() == ((HLAinteger64)otherObj ect) .getValue()) ; 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(java.lang.Object) 

Obj ect.equals(j ava.lang.Obj ect) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Long(getValue() ) .hashCode(); 


//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


480 


DRDC Valcartier TR 2007-412 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 

return ( IsBigEndian() ? byteWrapper.putLong(getValue()) : 

byteWrapper.putLongLE(getValue()) ); 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 
if (IsBigEndian()) 

{ setValue(byteWrapper.getLong() ) ; } 
else 

{ setValue(byteWrapper.getLongLE()); } 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


DRDC Valcartier TR 2007-412 


481 



//Class-specific extensions 

j * * 

* Returns the long value of <code>this</code>. 

* @return the long value of <code>this</code> 

* @see #setValue 

*/ 

public long 
getValue() 

{ 

return value; 


j * * 

* Sets the long value of <code>this</code>. 

* @param value the long new value for <code>this</code> 

* @see #getValue 
*/ 

public void 
setValue(long value) 

{ 

value = value; 


j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public abstract boolean 
IsBigEndian(); 

} 

//end HLAinteger64 


482 


DRDC Valcartier TR 2007-412 



// File: HLAinteger64BE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 64-bit big-endian integer basic data type. 

* It uses the <code>long</code> Java type to store the value (not the 
byte sequence). 

* <p> 

* <code>HLAinteger64BE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAinteger64BEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAinteger64BE 

extends HLAinteger64 

{ 

j * * 

* Constructs a <code>HLAinteger64BE</code> of default value 
(zero) . 

*/ 

public 

HLAinteger64BE() 

{ 

//super() not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAinteger64BE</code> of the specified value. 

* @param value a long specifying <code>this</code>' value 
*/ 

public 

HLAinteger64BE(long value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


483 



* * 


* Creates a <code>HLAinteger64BE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAinteger64BE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger64BE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAinteger64BE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAinteger64BE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAinteger64BE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger64BE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAinteger64BE</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAinteger64BE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public HLAinteger64BE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


484 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian () 

{ 

return true; 


//end HLAinteger64BE 


DRDC Valcartier TR 2007-412 


485 



// File: HLAinteger64LE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 64-bit little-endian integer basic data type. 

* It uses the <code>long</code> Java type to store the value (not the 
byte sequence). 

* <p> 

* <code>HLAinteger64LE</code>s are normally never obtained directly, 
as the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAinteger64LEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAinteger64LE 

extends HLAinteger64 

{ 

j * * 

* Constructs a <code>HLAinteger64LE</code> of default value 
(zero) . 

*/ 

public 

HLAinteger64LE() 

{ 

//super () not called because super-class is abstract 
//Default _value is zero 


j * * 

* Constructs a <code>HLAinteger64LE</code> of the specified value. 

* @param value a long specifying <code>this</code>' value 
*/ 

public 

HLAinteger64LE(long value) 

{ 

this ( ) ; 

setValue (value) ,- 


486 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAinteger64LE</code> from the network 
representation in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAinteger64LE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger64LE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAinteger64LE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAinteger64LE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAinteger64LE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteger64LE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAinteger64LE</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAinteger64LE</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteger64LE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


487 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
IsBigEndian() 

{ 

return false; 


//end HLAinteger64LE 


488 


DRDC Valcartier TR 2007-412 



// File: HLAfloat3 2.j ava 

package ca.gc.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Abstract type-safe 32-bit IEEE 754-1985 floating point basic data 
type. 

* It uses the <code>float</code> Java type to store the value (not 
the byte sequence) 

* and is the ancestor of the HLAfloat32BE and HLAfloat32LE concrete 
classes. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAfloat3 2 

extends HLAbasicType 

{ 

/** The stored 32-bit IEEE 754-1985 floating point value: a Java 
float. */ 

protected float _value; 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 4; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 4; 

//j ava.lang.Object methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return Float.toString(getValue() ) ; 


DRDC Valcartier TR 2007-412 


489 



* * 


* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

if (l this.getClass().equals(otherObj ect.getClass ())) return 

false; 

// if (this.isBigEndian() l= 

((HLAfloat3 2)otherObj ect) .isBigEndian ()) return false; 

return (getValueO == ((HLAfloat32)otherObject).getValue()); 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(java.lang.Object) 

Obj ect.equals(j ava.lang.Obj ect) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Float(getValue()).hashCode(); 


//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


490 


DRDC Valcartier TR 2007-412 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 
return ( IsBigEndian() ? 

byteWrapper.putInt(Float.floatToRawIntBits(getValue())) : 

byteWrapper.putIntLE(Float.floatToRawIntBits(getValue())) ); 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 
if (IsBigEndian()) 

{ setValue(Float.intBitsToFloat(byteWrapper.getInt())); } 
else 

{ setValue(Float.IntBitsToFloat(byteWrapper.getIntLE())); } 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


DRDC Valcartier TR 2007-412 


491 



//Class-specific extensions 

j * * 

* Returns the float value of <code>this</code>. 

* @return the float value of <code>this</code> 

* @see #setValue 

*/ 

public float 
getValue() 

{ 

return value; 


j * * 

* Sets the float value of <code>this</code>. 

* @param value the float new value for <code>this</code> 

* @see #getValue 
*/ 

public void 
setValue(float value) 

{ 

value = value; 


j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public abstract boolean 
IsBigEndian(); 

} 

//end HLAfloat32 


492 


DRDC Valcartier TR 2007-412 



// File: HLAfloat3 2BE.j ava 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 32-bit big-endian IEEE 754-1985 floating point basic data 
type. 

* It uses the <code>float</code> Java type to store the value (not 
the byte sequence). 

* <p> 

* <code>HLAfloat32BE</code>s are normally never obtained directly, as 
the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAfloat32BEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAfloat32BE 

extends HLAfloat32 

{ 

j * * 

* Constructs a <code>HLAfloat32BE</code> of default value (NaN). 

*/ 

public 

HLAfloat32BE() 

{ 

//super() not called because super-class is abstract 
setValue (Float .NaN) ,- //Java's default is "positive zero" 


j * * 

* Constructs a <code>HLAfloat32BE</code> of the specified value. 

* @param value a float specifying <code>this</code>' value 
*/ 

public 

HLAfloat32BE(float value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


493 



* * 


* Creates a <code>HLAfloat32BE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfloat32BE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat32BE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAfloat32BE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAfloat32BE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfloat32BE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat32BE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAfloat32BE</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAfloat32BE</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAfloat32BE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


494 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian () 

{ 

return true; 


//end HLAfloat32BE 


DRDC Valcartier TR 2007-412 


495 



// File: HLAfloat32LE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 32-bit little-endian IEEE 754-1985 floating point basic 
data type. 

* It uses the <code>float</code> Java type to store the value (not 
the byte sequence). 

* <p> 

* <code>HLAfloat32LE</code>s are normally never obtained directly, as 
the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAfloat32LEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAfloat32LE 

extends HLAfloat32 

{ 

j * * 

* Constructs a <code>HLAfloat32LE</code> of default value (NaN). 

*/ 

public 

HLAfloat32LE() 


//super () not called because super-class is abstract 
setValue (Float. NaN) ,- //Java's default is "positive zero" 


j * * 

* Constructs a <code>HLAfloat32LE</code> of the specified value. 

* @param value a float specifying <code>this</code>' value 
*/ 

public 

HLAfloat32LE(float value) 

{ 

this ( ) ; 

setValue (value) ,- 


496 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAfloat32LE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAfloat32LE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat32LE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAfloat32LE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfloat32LE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfloat32LE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat32LE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAfloat32LE</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAfloat32LE</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAfloat32LE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


497 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
IsBigEndian() 

{ 

return false; 


//end HLAfloat32LE 


498 


DRDC Valcartier TR 2007-412 



// File: HLAfloat 64.j ava 

package ca.gc.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Abstract type-safe 64-bit IEEE 754-1985 floating point basic data 
type. 

* It uses the <code>double</code> Java type to store the value (not 
the byte sequence) 

* and is the ancestor of the HLAfloat64BE and HLAfloat64LE concrete 
classes. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAfloat 64 

extends HLAbasicType 

{ 

/** The 64-bit IEEE 754-1985 floating point value: a Java double. 

*/ 

protected double _value; 

/** Length (in bytes) of the <code>byte[]</code> representation of 
this class. */ 

public final static int 
encodedLength = 8; 

/** Octet boundary of this class. */ 
public final static int 
octetBoundary = 8; 

//j ava.lang.Object methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return Double.toString(getValue() ) ; 


DRDC Valcartier TR 2007-412 


499 



* * 


* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

if (l this.getClass().equals(otherObj ect.getClass ())) return 

false; 

// if (this.isBigEndian() l= 

((HLAfloat64)otherObj ect) .isBigEndian ()) return false; 

return (getValueO == ((HLAfloat64)otherObject).getValue()); 


j * * 

* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(java.lang.Object) 

Obj ect.equals(j ava.lang.Obj ect) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return new Double(getValue()).hashCode(); 


//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return encodedLength; 


500 


DRDC Valcartier TR 2007-412 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 
return ( IsBigEndian() ? 

byteWrapper.putLong(Double.doubleToRawLongBits(getValue())) : 

byteWrapper.putLongLE(Double.doubleToRawLongBits(getValue())) ); 


DRDC Valcartier TR 2007-412 


501 



* * 


* Sets <code>this</code> value from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary()); 
if (IsBigEndian() ) 

{ setValue(Double.longBitsToDouble(byteWrapper.getLong())); } 
else 

{ setValue(Double.longBitsToDouble(byteWrapper.getLongLE())); 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


//Class-specific extensions 

j * * 

* Returns the double value of <code>this</code>. 

* @return the double value of <code>this</code> 

* @see #setValue 

*/ 

public double 
getValue() 

{ 

return value; 


j * * 

* Sets the double value of <code>this</code>. 

* @param value the double new value for <code>this</code> 

* @see #getValue 
*/ 

public void 
setValue(double value) 

{ 

_value = value; 


502 


DRDC Valcartier TR 2007-412 



* * 


* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public abstract boolean 
isBigEndian(); 

} 

//end HLAfloat64 


DRDC Valcartier TR 2007-412 


503 



// File: HLAfloat64BE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 64-bit big-endian IEEE 754-1985 floating point basic data 
type. 

* It uses the <code>double</code> Java type to store the value (not 
the byte sequence). 

* <p> 

* <code>HLAfloat64BE</code>s are normally never obtained directly, as 
the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAfloat64BEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAfloat64BE 

extends HLAfloat64 

{ 

j * * 

* Constructs a <code>HLAfloat64BE</code> of default value (NaN). 

*/ 

public 

HLAfloat64BE() 


//super () not called because super-class is abstract 

setValue (Double. NaN) ,- //Java's default value is "positive zero" 


j * * 

* Constructs a <code>HLAfloat64BE</code> of the specified value. 

* @param value a double specifying <code>this</code>' value 
*/ 

public 

HLAfloat64BE(double value) 

{ 

this ( ) ; 

setValue (value) ,- 


504 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAfloat64BE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAfloat64BE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat64BE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAfloat64BE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfloat64BE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfloat64BE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat64BE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAfloat64BE</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAfloat64BE</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAfloat64BE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


505 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
IsBigEndian() 

{ 

return true; 


//end HLAfloat64BE 


506 


DRDC Valcartier TR 2007-412 



// File: HLAfloat64LE.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 64-bit little-endian IEEE 754-1985 floating point basic 
data type. 

* It uses the <code>double</code> Java type to store the value (not 
the byte sequence). 

* <p> 

* <code>HLAfloat64LE</code>s are normally never obtained directly, as 
the RTI uses simple data types instead. 

* <p> 

* They could also be obtained by using an eventual 
<code>HLAfloat64LEfactory</code>'s decode method on a 
<code>byte[]</code> 

* received as part of an attribute update or interaction. However, no 
such factory is currently supplied by the RTIambassador. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAfloat64LE 

extends HLAfloat64 

{ 

j * * 

* Constructs a <code>HLAfloat64LE</code> of default value (NaN). 

*/ 

public 

HLAfloat64LE() 

{ 

//super() not called because super-class is abstract 

setValue (Double .NaN) ,- //Java's default value is "positive zero" 


j * * 

* Constructs a <code>HLAfloat64LE</code> of the specified value. 

* @param value a double specifying <code>this</code>' value 
*/ 

public 

HLAfloat64LE(double value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


507 



* * 


* Creates a <code>HLAfloat64LE</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfloat64LE</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat64LE(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAfloat64LE</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAfloat64LE</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfloat64LE</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfloat64LE(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAfloat64LE</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAfloat64LE</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAfloat64LE(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


508 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 

j * * 

* Returns true if the class is big-endian. 

* @return a boolean which is true if the class is big-endian 

*/ 

public boolean 
isBigEndian () 

{ 

return false; 


//end HLAfloat64LE 


DRDC Valcartier TR 2007-412 


509 



The next three classes implement the HLA simple datatypes. In most cases the 
underlying basic datatype is simply extended and the constructors redeclared, but the 
hlaasci I char and HLAunicodeChar classes need a little extra because of the way 
Java treats characters. 


/ / File: HLAbyt e.j ava 

package ca.gc.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Type-safe 8-bit byte simple data type. 

* It uses the <code>HLAoctet</code> basic data type. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAbyte 

extends HLAoctet 

{ 

j * * 

* Constructs a <code>HLAbyte</code> of default value (zero). 

*/ 

public 
HLAbyte() 

{ 

super(); 


j * * 

* Constructs a <code>HLAbyte</code> of the specified value. 

* @param value a byte specifying <code>this</code>' value 
*/ 

public 

HLAbyte(byte value) 

{ 

super(value); 


j * * 

* Creates a <code>HLAbyte</code> from the network representation 
in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAbyte</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAbyte(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


510 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAbyte</code> from the network representation 
in the provided <code>byte[]</code> at the indicated 

<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAbyte</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAbyte</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAbyte(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


j * * 

* Creates a <code>HLAbyte</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAbyte</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAbyte(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super (byteWrapper) ,- 


//end HLAbyte 


DRDC Valcartier TR 2007-412 


511 



// File: HLAASCIIchar.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 8-bit ASCII character simple data type. 

* It uses the <code>HLAoctet</code> basic data type. 

* The first 128 characters of the Unicode character encoding are the 
ASCII characters (cf. ANSI/INCITS 4-1986(R1997)) . 

* The Java <code>char</code> primitive type is a 16-bit unsigned 
integer representing Unicode characters. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAASCIIchar 

extends HLAoctet 

{ 

j * * 

* Constructs a <code>HLAASCIIchar</code> of default value (Unicode 
Null) . 

*/ 

public 

HLAASCIIchar() 

{ 

super(); 


j * * 

* Constructs a <code>HLAASCIIchar</code> of the specified value. 

* An exception occurs if the specified char is not ASCII. 

* @param value a char specifying <code>this</code>' value 

* @throws IllegalArgumentException if the value isn't ASCII 
(numeric range 0..127) 

*/ 

public 

HLAASCIIchar(char value) 

throws IllegalArgumentException 

{ 

super(verify(value)); 


512 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAASCIIchar</code> from the specified 
String. 

* @param s a String whose charAt(O) specifies <code>this</code>' 
value 

* @throws IllegalArgumentException if the String is empty or its 
first character isn't ASCII 

*/ 

public 

HLAASCIIchar(String s) 

throws IllegalArgumentException 

{ 

super(verify(s)); //This includes the zero-length string 
exception 


j * * 

* Constructs a <code>HLAASCIIchar</code> from the specified 
Obj ect. 

* @param o an Object whose toString().charAt(0) specifies 
<code>this</code>' value 

* @throws IllegalArgumentException if Object.toString () is empty 
or its first character isn't ASCII 

*/ 

public 

HLAASCIIchar(Object o) 

throws IllegalArgumentException 

{ 

this(o.toString()); 


j * * 

* Creates a <code>HLAASCIIchar</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAASCIIchar</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAASCIIchar(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


513 



* * 


* Creates a <code>HLAASCIIchar</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAASCIIchar</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAASCIIchar</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAASCIIchar(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates a <code>HLAASCIIchar</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAASCIIchar</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAASCIIchar(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


514 


DRDC Valcartier TR 2007-412 



* * 


* Verifies if the char value is ASCII and returns its byte value. 

* @param value the char to verify 

* @return the byte representation of the ASCII character 

* @throws IllegalArgumentException if value is not in the 00.. 7F 
range 

*/ 

protected final static byte 
verify(char value) 

throws IllegalArgumentException 

{ 

if (value > OxOFFF) 

{ 

throw new IllegalArgumentException (" Ox' 1 + 

Integer.toHexString((int)value)); 

} 

else if (value > OxOOFF) 

{ 

throw new IllegalArgumentException ( 11 0x0 11 + 

Integer.toHexString((int)value)); 

} 

else if (value > 0x007F) 

{ 

throw new IllegalArgumentExcept ion ( 11 0x0 0 11 + 

Integer.toHexString((int)value)); 

} 

else 

{ 

//Verification succeeded 
return (byte)value; 


j * * 

* Verifies if the specified String is ASCII and returns the byte 
value of its first character. 

* @param s the String to verify 

* @return the byte representation of the String's first character 
(ASCII) 

* @throws IllegalArgumentException if value is not in the 00..7F 
range 

*/ 

protected final static byte 
verify(String s) 

throws IllegalArgumentException 

{ 

if (s.length() <= 0) throw new IllegalArgumentException(); 
return verify(s.charAt(0)); 


DRDC Valcartier TR 2007-412 


515 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

return Character.toString(getChar()); 


//Class-specific extensions 


j * * 

* Returns the char value of <code>this</code>. 

* @return the char value of <code>this</code> 
*/ 

public char 
getChar() 

{ 

return (char)getValue(); 


j * * 

* Returns <code>this</code> value as a Character. 

* @return the Character representation of <code>this</code> value 
*/ 

protected Character 
getCharacter() 

{ 

return new Character(getChar()); 


//Override to force verify 

j * * 

* Sets the byte value of <code>this</code>. 

* @param value the byte new value for <code>this</code> 

* @throws IllegalArgumentException if the value isn't ASCII 

*/ 

public void 
setValue(byte value) 

{ 

super.setValue(verify((char)value)); 


516 


DRDC Valcartier TR 2007-412 



* * 


* Sets the char value of <code>this</code>. 

* @param value the char new value for <code>this</code> 

* @throws IllegalArgumentException if the value isn't ASCII 

*/ 

public void 
setValue(char value) 

{ 

//We could also write "setValue(verify(value));" but this would 
end up calling verify twice 

super.setValue(verify(value)); 


//end HLAASCIIchar 


DRDC Valcartier TR 2007-412 


517 



// File: HLAunicodeChar.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 16-bit Unicode character simple data type. 

* It uses the <code>HLAoctetPairBE</code> basic data type. 

* The Java <code>char</code> primitive type is a 16-bit unsigned 
integer representing Unicode characters. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAunicodeChar 

extends HLAoctetPairBE 

{ 

j * * 

* Constructs a <code>HLAunicodeChar</code> of default value 
(Unicode Null). 

*/ 

public 

HLAunicodeChar() 

{ 

super(); 


j * * 

* Constructs a <code>HLAunicodeChar</code> of the specified value. 

* @param value a char specifying <code>this</code>' value 
*/ 

public 

HLAunicodeChar(char value) 

{ 

super(value); 


j * * 

* Constructs a <code>HLAunicodeChar</code> from the specified 
String. 

* @param s a String whose charAt(O) specifies <code>this</code> 

* @throws IllegalArgumentException if s is empty. 

*/ 

public 

HLAunicodeChar(String s) 

throws IllegalArgumentException 

{ 

this ( ) ; 

if (s.length() <= 0) throw new IllegalArgumentException() ; 
setValue(s.charAt(0)); 


518 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAunicodeChar</code> from the specified 
Object. 

* @param o an Object whose toString().charAt(0) specifies 
<code>this</code>' value 

*/ 

public 

HLAunicodeChar(Obj ect o) 

{ 

this(o.toString()); 


j * * 

* Creates a <code>HLAunicodeChar</code> from the network 
representation in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAunicodeChar</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAunicodeChar(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAunicodeChar</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAunicodeChar</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAunicodeChar</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAunicodeChar(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


519 



* * 


* Creates a <code>HLAunicodeChar</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAunicodeChar</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAunicodeChar(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//j ava.lang.Obj ect methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

return Character.toString(getValue()); 


//Class-specific extensions 

// getValue already returns a char. 

j * * 

* Returns <code>this</code> value as a Character. 

* @return the Character representation of <code>this</code> value 
*/ 

protected Character 
getCharacter() 

{ 

return new Character(getValue()); 


//Overload 

j * * 

* Sets the short value of <code>this</code>. 

* @param value the short new value for <code>this</code> 
*/ 

public void 
setValue(short value) 

{ 

setValue((char)value); 


//end HLAunicodeChar 


520 


DRDC Valcartier TR 2007-412 



The next four classes implement the HLA MOM simple datatypes. 


// File: HLAcount.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Type-safe 32-bit big-endian integer basic data type used by the 
Management Object Model (MOM). 

* It is an HLAinteger32BE. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAcount 

extends HLAinteger32BE 

{ 

j * * 

* Constructs an <code>HLAcount</code> of default value (zero). 
*/ 

public 
HLAcount() 

{ 

super(); //Default _value is zero 


j * * 

* Constructs a <code>HLAcount</code> of the specified value. 

* @param value an int specifying <code>this</code>' value 
*/ 

public 

HLAcount(int value) 

{ 

this ( ) ; 

setValue(value); 


j * * 

* Creates a <code>HLAcount</code> from the network representation 
in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAcount</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAcount(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


521 



* * 


* Creates a <code>HLAcount</code> from the network representation 
in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAcount</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAcount</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAcount(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j k k 

* Creates a <code>HLAcount</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAcount</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAcount(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//end HLAcount 


522 


DRDC Valcartier TR 2007-412 



// File: HLAfederateHandle.java 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe 32-bit big-endian integer basic data type used by the 
Management Object Model (MOM). 

* It is the type of the argument to the normalizeFederateHandle 
service, that is to say, FederateHandle. 

* Stored as an HLAinteger32BE, it is however a pointer to an RTI 
defined programming language object, NOT a true HLAInteger32BE. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAfederateHandle 

extends HLAinteger32BE 

{ 

j * * 

* Constructs an <code>HLAfederateHandle</code> of default value 
(zero) . 

*/ 

public 

HLAfederateHandle() 

{ 

super(); //Default _value is zero 


j * * 

* Constructs a <code>HLAfederateHandle</code> of the specified 
value. 

* @param value an int specifying <code>this</code>' value 
*/ 

public 

HLAfederateHandle(int value) 

{ 

this ( ) ; 

setValue (value) ,- 


DRDC Valcartier TR 2007-412 


523 



* * 


* Creates a <code>HLAfederateHandle</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfederateHandle</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfederateHandle(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAfederateHandle</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfederateHandle</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfederateHandle</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfederateHandle(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Creates a <code>HLAfederateHandle</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAfederateHandle</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAfederateHandle(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


//end HLAfederateHandle 


524 


DRDC Valcartier TR 2007-412 



// File: HLAmsec.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Type-safe 32-bit big-endian integer basic data type used by the 
Management Object Model (MOM). 

* It is an HLAinteger32BE. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAmsec 

extends HLAinteger32BE 

{ 

j * * 

* Constructs an <code>HLAmsec</code> of default value (zero). 

*/ 

public 
HLAmsec() 

{ 

super(); //Default _value is zero 


j * * 

* Constructs a <code>HLAmsec</code> of the specified value. 

* @param value an int specifying <code>this</code>' value 
*/ 

public 

HLAmsec(int value) 

{ 

this ( ) ; 

setValue(value); 


j * * 

* Creates a <code>HLAmsec</code> from the network representation 
in the provided <code>byte[] </code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAmsec</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAmsec(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


525 



* * 


* Creates a <code>HLAmsec</code> from the network representation 
in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAmsec</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAmsec</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAmsec(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j k k 

* Creates a <code>HLAmsec</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAmsec</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAmsec(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//end HLAmsec 


526 


DRDC Valcartier TR 2007-412 



// File: HLAseconds.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 
import hla.rtil516.CouldNotDecode; 
j * * 

* Type-safe 32-bit big-endian integer basic data type used by the 
Management Object Model (MOM). 

* It is an HLAinteger32BE. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAseconds 

extends HLAinteger32BE 

{ 

j * * 

* Constructs an <code>HLAseconds</code> of default value (zero). 
*/ 

public 
HLAseconds() 

{ 

super(); //Default _value is zero 


j * * 

* Constructs a <code>HLAseconds</code> of the specified value. 

* @param value an int specifying <code>this</code>' value 
*/ 

public 

HLAseconds(int value) 

{ 

this ( ) ; 

setValue(value); 


j * * 

* Creates a <code>HLAseconds</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAseconds</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAseconds(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


527 



* * 


* Creates a <code>HLAseconds</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAseconds</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAseconds</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAseconds(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates a <code>HLAseconds</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAseconds</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAseconds(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//end HLAseconds 


528 


DRDC Valcartier TR 2007-412 



In constructing enumerated datatypes, it was assumed the pattern established by 
such classes as ResignAction would be followed. 


// File: HLAenumerateddatatype.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import j ava.util.Iterator; 

j * * 

* Interface implemented by the HLA enumerated data types. 

* <p> 

* An enumerated data type extends a basic data type (like a simple 
data type does) and 

* specifies an immutable finite set of prototype values (not 
necessarily contiguous nor ordered). 

* <p> 

* Design guidelines: 

* <ul > 

* <li>A private constructor should be used to generate the static 
values (the enumerators).</li> 

* <li>The java.lang.Object methods <code>toString()</code>, 
<code>equals()</code> and <code>hashCode()</code> may or may not need 
to be overridden.</li> 

* <li>Although the inherited <code>getValue()</code> does not need to 
be overridden, this may be useful if only to change the Javadoc.</li> 

* <li>The inherited <code>setValue</code>, on the other hand, will 
definitely need to be overridden so that it throws an 

* exception when a value other than an acceptable one is passed in, 
or an <code>UnsupportedOperationException</code> 

* when applied to one of the static values.</li> 

* <li>Specialised <code>get/set</code> methods can be supplied if 
needed.</li> 

* <li>A complete set of prototype immutable (public static final) 
instances must be generated by the class initializer.</li> 

* <li>There must be a <code>public static Iterator iterator()</code> 
method that returns an Iterator over the enumeration's elements 
(prototype immutable instances). 

* This Iterator must throw an 

<code>UnsupportedOperationException</code> in response to its 
<code>remove()</code> method.</li> 

* <li>There must also be a <code>public static Iterator 

namelterator()</code> method which returns an Iterator over the names 
of the enumeration's elements, in the same sequence as 
<code>iterator()</code>.</li> 

* </ul> 

* In order to facilitate the implementation, the class 
HLAenumeratedIterator is supplied; 

* it defines constructors which should fulfill the contracts without 
modification. 

* See the comments below and the HLAboolean class for examples. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 


DRDC Valcartier TR 2007-412 


529 



public interface 
HLAenumerateddatatype 
extends HLAdatatype 

{ 

j * * 

* Returns an <code>Iterator</code> over the enumeration's 
elements. 

* Note that the <code>Iterator</code> returned by this method 
should throw an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException; 

// { 

// //You can use the self-defining Iterator: 

// return new HLAenumeratedIterator(HLAboolean.class, false); 

// //Or you can specify the enumerators manually: 

// return new HLAenumeratedlterator(new Object[] { 

HLAboolean.HLAfalse, HLAboolean.HLAtrue }, false),- 


j * * 

* Returns an <code>Iterator</code> over the enumeration's element 
names. 

* Note that the <code>Iterator</code> returned by this method 
throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This <code>nameIterator</code> is guaranteed to match the 
sequence of the other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException,- 

// { 

// //You can use the self-defining Iterator: 

// return new HLAenumeratedIterator(HLAboolean.class, true) ,- 
// //Or you can specify the enumerators manually: 

// return new HLAenumeratedlterator(new Object[] { 

HLAboolean.HLAfalse, HLAboolean.HLAtrue }, true); 

// } 


530 


DRDC Valcartier TR 2007-412 



* * 


* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

Class 

getElementClass () ; 

// { 

// return this.getclass().getSuperclass(); 


j * * 

* Returns true if the instance is immutable. 

* This is useful to distinguish between the class-supplied 
prototype instances and 

* the user-created ones (it is not possible to segregate them 
completely, since a user-defined 

* reference may end up pointing to a class-supplied immutable 
instance). 

* @return a boolean which is true if the instance is immutable 

*/ 

boolean 
islmmutable(); 

} 

//end HLAenumerateddatatype 


DRDC Valcartier TR 2007-412 


531 



// File: HLAenumeratedIterator.java 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import j ava.util. Iterator,- 

import j ava.util.NoSuchElementException; 

import j ava.util. ArrayList,- 

import j ava.lang.refleet.Field; 

import j ava.lang.reflect.Modifier; 

j * * 

* Iterator implementation for HLA enumerated types. 

* Since the backing object (an HLA enumerated data type class) is 
supposed to be immutable, 

* the Iterator is considerably simplified. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAenumeratedIterator 
implements Iterator 

{ 

j * * 

* The enumerators over which to iterate. 

*/ 

private Object 
enumerators[]; 

j * * 

* Index of enumerator to be returned by subsequent call to next(). 

*/ 

private int 
cursor; 

j * * 

* Constructs the <code>Iterator</code> from a <code>Class</code> 
reference. 

* If the <code>boolean asStrings</code> is false, the 
<code>Iterator</code> will enumerate the <code>Obj ect</code>s ,- 

* otherwise it will enumerate the field names as 
<code>String</code>s. 

* <p> 

* Examples: <code>Iterator itr = new 
HLAenumeratedI ter a tor (HLAboolean. class, false) ,-</code> 

* <code>Iterator nameltr = new 
HLAenumeratedI ter a tor (HLAboolean. class, true) ,- </code> 

* @param theClass the Class whose public static final instances 
are to be enumerated 

* @param asStrings a boolean which is false if the enumeration 
should supply Objects, true if it should supply the field names (as 
Strings) instead 

* @throws ClassCastException if thelnstance doesn't implement the 
HLAenumerateddatatype interface (or an IllegalAccessException occurred 
internally) 

*/ 


532 


DRDC Valcartier TR 2007-412 



public 

HLAenumeratedlterator(Class theClass, boolean asStrings) 
throws ClassCastException 

{ 

if (lHLAenumerateddatatype.class.IsAssignableFrom(theClass)) 
throw new ClassCastException(theClass.toString()),- 
int mods; 
cursor = 0; 

ArrayList al = new ArrayListO; 

//Obtain the class' fields 

Field[] theFields = theClass . getFields () ,- 

for (int i = 0; i < theFields.length; i++) 

{ 

//We're looking for fields which are instances of the class 

itself 

if (theFields[i].getType().equals(theClass)) 

{ 

//Must also be Final, Public and Static 
mods = theFields[i] .getModifiers (),- 

if (Modifier.isFinal(mods) && Modifier.isPublic(mods) && 
Modifier.isStatic(mods)) 

{ 

if (asStrings) 

{ 

al.add(theFields[i] .getName () ) ,- 

} 

else 


//To simplify the constructor, the 
IllegalAccessException that this may throw is wrapped in a 
ClassCastException 

try 


al. add (theFields [i] .get (null) ) ,- 
} catch (IllegalAccessException e) 

{ 

ClassCastException cce = new 
ClassCastException(e.getMessage()); 

throw (ClassCastException) cce . initCause (e) ,- 


al. trimToSize () ,- 
enumerators = al. toArray () ,- 


DRDC Valcartier TR 2007-412 


533 



* Constructs the enumeration using the specified enumerators. 

* This can be used to change the enumeration order, repeat or omit 
enumerators. 

* If the <code>boolean asStrings</code> is false, the 
<code>Iterator</code> will enumerate the <code>Ob j ect </code>s ,- 

* otherwise it will enumerate the prototype field names as 
<code>String</code>s. 

* <p> 

* A prototype field is a field of a class or instance whose class 
is the same as the class or instance's class. 

* For example, the prototype fields of the <code>HLAboolean</code> 
class are <code>HLAfalse</code> and <code>HLAtrue</code>. 

* <p> 

* The names of <code>theEnumerators</code> that are not prototype 
fields of their classes will appear <code>null</code>. 

* Note that the constructor expects <code>theEnumerators</code> to 
all be <code>Object</code>s of the same <code>Class</code>, 

* which must implement the HLAenumerateddatatype interface. 

* However, it does not demand that the fields be <code>public 
static final</code>. 

* <p> 

* Examples: <code>Iterator itr = new HLAenumeratedlterator(new 

Object [] { HLAboolean.HLAfalse, HLAboolean.HLAtrue }, false ),-</code> 

* <code>Iterator nameltr = new HLAenumeratedlterator(new Object[] 

{ HLAboolean.HLAfalse, HLAboolean.HLAtrue }, true) ,-</code> 

* @param theEnumerators an Object[] specifying the enumerators and 
their order 

* @param asStrings a boolean which is false if the enumeration 
should supply theEnumerators, true if it should supply their field 
names (as Strings) instead 

* @throws ClassCastException if thelnstance doesn't implement the 
HLAenumerateddatatype interface (or an IllegalAccessException occurred 
internally) 

*/ 


534 


DRDC Valcartier TR 2007-412 



public 

HLAenumeratediterator(Object[] theEnumerators, boolean asStrings) 
throws ClassCastException 

{ 

//Validate theEnumerators 

for (int i = 0; i < theEnumerators.length; i++) 

{ 

if 

(lHLAenumerateddatatype.class.IsAssignableFrom(theEnumerators[i].getCl 
ass ())) throw new 

ClassCastException(theEnumerators[i].getclass().toString()); 
if (i > 0) 

{ 

//Make sure they're both the same class (if each one is 
castable to the other, then they must be of precisely the same class) 
if (I ( 

theEnumerators [i] .getclass () .isInstance(theEnumerators[i-1] ) && 
theEnumerators[i-1].getclass().isInstance(theEnumerators[i]) ) ) throw 

new ClassCastException(theEnumerators[i].getclass().toString()); 


cursor = 0; 
if (lasStrings) 

{ 

enumerators = theEnumerators; 
return; 


DRDC Valcartier TR 2007-412 


535 



//Set up a String enumeration 

enumerators = new Object[theEnumerators.length],- 
for (int i = 0; i < enumerators.length; i++) 

{ 

//Obtain the class' fields 
j ava.lang.refleet.Field[ ] theFields = 
theEnumerators[i] .getClass() .getFields() ,- 

for (int j = 0; j < theFields.length; j++) 

{ 

//To simplify the constructor, the IllegalAccessException 
that this may throw is wrapped in a ClassCastException 
try 


if 

(theFields [ j] .getType() .equals(theEnumerators[i].getClass()) && 
(theFields[j] .get(null) == theEnumerators[i] )) 

{ 

// enumerators[i] = 

theEnumerators[i] .getClass() .getName() + "." + theFields[i] .getName() ,- 
enumerators[i] = 
theFields[j].getName(),- 
break; 

} 

} catch (IllegalAccessException e) { 

ClassCastException cce = new 
ClassCastException(e.getMessage() ) ; 

throw (ClassCastException)cce.initCause(e),- 


//Iterator implementation 

j * * 

* Returns <code>true</code> if the iteration has more elements. 

* In other words, returns <code>true</code> if <code>next()</code> 
would return an element rather than throwing an exception. 

* @return a boolean which is <code>true</code> if the iterator has 
more elements 

*/ 

public boolean 
hasNext () 

{ 

return cursor < enumerators.length; 


536 


DRDC Valcartier TR 2007-412 



* * 


* Returns the next element in the iteration. 

* @return the next element in the iteration 

* @throws NoSuchElementException if the iteration has no more 
elements 

*/ 

public Object 
next () 

{ 

if (hasNextO) return enumerators[cursor++]; 
throw new NoSuchElementException(); 


j * * 

* Removes from the underlying collection the last element returned 
by the iterator (optional operation). 

* This method can be called only once per call to 
<code>next()</code>. 

* The behaviour of an <code>Iterator</code> is unspecified if the 
underlying collection is modified 

* while the iteration is in progress in any way other than by 
calling this method. 

* @throws UnsupportedOperationException if this operation is not 
supported by this Iterator 

* @throws IllegalStateException if <code>next()</code> has not yet 
been called, or <code>remove()</code> has already been called since 
the last call to <code>next()</code>. 

*/ 

public void 
remove() 

{ 

throw new UnsupportedOperationException(); 


//end HLAenumeratediterator 


DRDC Valcartier TR 2007-412 


537 



There is only one OMT-specified enumerated datatype: HLAboolean. The MOM, 
on the other hand, adds eight more. 


// File: HLAboolean.java 

package ca.go.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode,- 
import j ava.util.Iterator; 

j * * 

* Type-safe boolean enumerated data type. 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
HLAfalse and 1 for HLAtrue. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* It can be used as a template for other HLA enumerated data types. 

* <p> 

* Design guidelines: 

* <ul > 

* <li>A private constructor should be used to generate the static 
values (the enumerators) . </li> 

* <li>The java.lang.Object methods toStringO, equals () and 
hashCodeO may or may not need to be overridden.</li> 

* <li>Although the inherited getValueO does not need to be 
overridden, this may be useful if only to change the Javadoc.</li> 

* <li>The inherited setValue, on the other hand, will definitely need 
to be overridden so that it throws an 

* exception when a value other than an acceptable one is passed in, 
or an UnsupportedOperationException 

* when applied to one of the static values.</li> 

* <li>Specialised get/set methods can be supplied if needed.</li> 

* <li>The enumerators should appear as a series of static public 
final instances.</li> 

* </ul> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.01 //Deleted commented-out inherited setValue 
*/ 

public class 
HLAboolean 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE (0) ,- 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_1owestValue.getValue()); 


538 


DRDC Valcartier TR 2007-412 



//Whether this instance is immutable 
private final boolean 
_immutable; 

j k * 

* Constructs a <code>HLAboolean</code> of default (false) value. 
*/ 

public 
HLAboolean () 

{ 

super(); 

immutable = false; 


j k * 

* Constructs a <code>HLAboolean</code> of the specified boolean 
value. 

* @param value a boolean specifying <code>this</code>' value 
*/ 

public 

HLAboolean(boolean value) 

{ 

this ( ) ; 

setBoolean(value); 


j k k 

* Constructs a <code>HLAboolean</code> from another one. 

* @param otherHLAboolean must be a defined static value or another 
instance 

*/ 

public 

HLAboolean(HLAboolean otherHLAboolean) 

{ 

this(otherHLAboolean.getBoolean()); 


j k k 

* Creates a <code>HLAboolean</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAboolean</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAboolean(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


539 



* * 


* Creates a <code>HLAboolean</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAboolean</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAboolean</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAboolean(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates a <code>HLAboolean</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAboolean</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAboolean(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAboolean(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 1); 


540 


DRDC Valcartier TR 2007-412 



//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator() 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAboolean.class, false); 


j * * 

* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>namelterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAboolean.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass () .getSuperclass() ; //non-static only 


DRDC Valcartier TR 2007-412 


541 



* * 


* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable() 

{ 

return immutable; 


//j ava.lang.Obj ect methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* This implementation should work with all HLAenumerateddatatypes; 
HLAboolean is peculiar. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

// public String 
// toStringO 

// { 

// Iterator i = iterator (); 

// Iterator n = namelterator () ; 

// String s; 

// while (i.hasNext ()) 

// { 

// s = (String)n.next(); 

// if (i.next().equals(this)) return s; 

// } 

// //Cannot happen, but the compiler doesn't know this 

// return 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

return Boolean.toString(getBoolean()); 


542 


DRDC Valcartier TR 2007-412 



* * 


* Returns a hash code for <code>this</code>; two objects for which 
<code>equals()</code> is <code>true</code> should yield the same hash 
code. 

* @return an <code>int</code> hash code 

* @see Object#equals(j ava.lang.Object) 

Object.equals(j ava.lang.Object) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return Boolean.valueOf(getBoolean() ) .hashCode() ; 


//Class-specific extensions 


j * * 

* The inherited setValue sets <code>this</code> value from an int. 

* A value of zero means false, any other value means true (but 
will be stored as 1). 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException 

{ 

setBoolean(value != 0); 


j * * 

* Returns the boolean value of <code>this</code>. 

* @return the boolean value of <code>this</code> 

* @see #setBoolean 
*/ 

public boolean 
getBoolean() 

{ 

return (getValueO != 0); 


DRDC Valcartier TR 2007-412 


543 



* * 


* Sets the boolean value of <code>this</code>. 

* @param value the boolean new value for <code>this</code> 

* @throws UnsupportedOperationException if applied to an 
enumerator instance 

* @see #getBoolean 
*/ 

public void 

setBoolean(boolean value) 

throws UnsupportedOperationException 

{ 

if (_immutable) throw new UnsupportedOperationException(); 
//"Cannot setBoolean of immutable instance" 
if (value) 

{ 

//Must call super.setValue explicitly because setValue calls 
setBooleanl 

super.setValue(1); //HLAtrue 

} 

else 

{ 

super.setValue(0); //HLAfalse 


//The prototype immutable instances (the enumerators) 

j * * 

* False. 

*/ 

static public final HLAboolean 
HLAfalse = new HLAboolean(_nextToAssign); 

j * * 

* True. 

*/ 

static public final HLAboolean 
HLAtrue = new HLAboolean(_nextToAssign); 

} 

//end HLAboolean 


544 


DRDC Valcartier TR 2007-412 



// File: HLAfederateState.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe federateState enumerated data type, used by the 
Management Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 1 for 
ActiveFederate, 

* 3 for FederateSavelnProgress and 5 for FederateRestorelnProgress. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAfederateState 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE(1); 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE(2) ; 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_lowestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAfederateState</code> of default 
(ActiveFederate) value. 

*/ 

public 

HLAfederateState() 

{ 

super(1); 

_immutable = false; 


DRDC Valcartier TR 2007-412 


545 



* * 


* Constructs a <code>HLAfederateState</code> from another one. 

* @param otherHLAfederateState must be a defined static value or 
another instance 

*/ 

public 

HLAfederateState(HLAfederateState otherHLAfederateState) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAfederateState.getValue()); 


j * * 

* Creates a <code>HLAfederateState</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfederateState</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfederateState(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAfederateState</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAfederateState</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfederateState</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAfederateState(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


546 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAfederateState</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAfederateState</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAfederateState(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAfederateState(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue() ) ; 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator() 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAfederateState.class, false); 


DRDC Valcartier TR 2007-412 


547 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAfederateState.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass() .getSuperclass (); //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable() 

{ 

return _immutable; 


548 


DRDC Valcartier TR 2007-412 



//j ava.lang.Object methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

Iterator i = iterator(); 

Iterator n = namelterator() ; 

String s; 

while (i.hasNext()) 

{ 

s = (String)n.next() ; 

if (i.next().equals(this) ) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return " 11 ; 


DRDC Valcartier TR 2007-412 


549 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAresignAction)i.next()).getValue() == value) 

super.setValue(value),- 
o = i. next () 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class [])null) ; //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super. setValue (value) ,- 
return; 

} 

} catch (Exception ignored) {} 

} 

throw new IllegalArgumentException () ,- 


550 


DRDC Valcartier TR 2007-412 



//The prototype immutable instances (the enumerators) 


j k k 

* ActiveFederate. 

*/ 

static public final HLAfederateState 

ActiveFederate = new HLAfederateState(_nextToAssign); 

j k k 

* FederateSavelnProgress. 

*/ 

static public final HLAfederateState 

FederateSavelnProgress = new HLAfederateState(_nextToAssign); 

j k k 

* FederateRestorelnProgress. 

*/ 

static public final HLAfederateState 

FederateRestorelnProgress = new HLAfederateState(_nextToAssign); 

} 

//end HLAfederateState 


DRDC Valcartier TR 2007-412 


551 



// File: HLAorderType.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe orderType enumerated data type, used by the Management 
Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
Receive 

* and 1 for Timestamp. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAorderType 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE (0) ; 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE (1); 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_1owestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAorderType</code> of default 
(ActiveFederate) value. 

*/ 

public 

HLAorderType() 

{ 

super () 

_immutable = false; 


552 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAorderType</code> from another one. 

* @param otherHLAorderType must be a defined static value or 
another instance 

*/ 

public 

HLAorderType(HLAorderType otherHLAorderType) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAorderType.getValue()); 


j * * 

* Creates a <code>HLAorderType</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAorderType</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAorderType(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAorderType</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAorderType</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAorderType</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAorderType(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


553 



* * 


* Creates a <code>HLAorderType</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAorderType</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAorderType(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAorderType(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue()); 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAorderType.class, false); 


554 


DRDC Valcartier TR 2007-412 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAorderType.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass () .getSuperclass() ; //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable () 

{ 

return _immutable; 


DRDC Valcartier TR 2007-412 


555 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

Iterator i = iterator (); 

Iterator n = namelterator () ; 

String s; 

while (i.hasNext ()) 

{ 

s = (String) n. next () ; 

if (i.next().equals(this)) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return 


556 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAorderType)i.next()).getValue() == value) 

super.setValue(value),- 
o = i.next () ,- 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class[])null); //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super . setValue (value) ,- 
return; 

} 

} catch (Exception ignored) { } 

} 

throw new IllegalArgumentException () ,- 


//The prototype immutable instances (the enumerators) 


j k k 

* Receive. 

*/ 

static public final HLAorderType 
Receive = new HLAorderType (_nextToAssign) ,- 

j k k 

* Timestamp. 

*/ 

static public final HLAorderType 
Timestamp = new HLAorderType (_nextToAssign) ,- 

} 

//end HLAorderType 


DRDC Valcartier TR 2007-412 


557 



// File: HLAownership.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe ownership enumerated data type, used by the Management 
Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
Unowned 

* and 1 for Owned. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAownership 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE (0) ; 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE (1); 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_1owestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAownership</code> of default 
(ActiveFederate) value. 

*/ 

public 

HLAownership() 

{ 

super () 

_immutable = false; 


558 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAownership</code> from another one. 

* @param otherHLAownership must be a defined static value or 
another instance 

*/ 

public 

HLAownership(HLAownership otherHLAownership) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAownership.getValue()); 


j * * 

* Creates a <code>HLAownership</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAownership</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAownership(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAownership</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAownership</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAownership</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAownership(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


559 



* * 


* Creates a <code>HLAownership</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAownership</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAownership(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAownership(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue () + 

_step.getValue()); 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAownership.class, false); 


560 


DRDC Valcartier TR 2007-412 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAownership.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass () .getSuperclass() ; //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable () 

{ 

return _immutable; 


DRDC Valcartier TR 2007-412 


561 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

Iterator i = iterator (); 

Iterator n = namelterator () ; 

String s; 

while (i.hasNext ()) 

{ 

s = (String) n. next () ; 

if (i.next().equals(this)) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return 


562 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAresignAction)i.next()).getValue() == value) 

super.setValue(value),- 
o = i.next () ,- 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class[])null); //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super . setValue (value) ,- 
return; 

} 

} catch (Exception ignored) { } 

} 

throw new IllegalArgumentException () ,- 


//The prototype immutable instances (the enumerators) 


j k k 

* Unowned. 

*/ 

static public final HLAownership 
Unowned = new HLAownership (_nextToAssign) ,- 

j k k 

* Owned. 

*/ 

static public final HLAownership 
Owned = new HLAownership (_nextToAssign) ,- 

} 

//end HLAownership 


DRDC Valcartier TR 2007-412 


563 



// File: HLAresignAction.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe resignAction enumerated data type, used by the Management 
Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 1 for 
DivestOwnership 

* through 6 for NoAction. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAr e signAc tion 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE (1) ; 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE (1); 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_1owestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAresignAction</code> of default 
(ActiveFederate) value. 

*/ 

public 

HLAresignAction() 

{ 

super () 

_immutable = false; 


564 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAresignAction</code> from another one. 

* @param otherHLAresignAction must be a defined static value or 
another instance 

*/ 

public 

HLAresignAction(HLAresignAction otherHLAresignAction) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAresignAction.getValue()); 


j * * 

* Creates a <code>HLAresignAction</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAresignAction</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAresignAction(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAresignAction</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAresignAction</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAresignAction</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAresignAction(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


565 



* * 


* Creates a <code>HLAresignAction</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAresignAction</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAresignAction(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAresignAction(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue()); 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAresignAction.class, false); 


566 


DRDC Valcartier TR 2007-412 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAresignAction.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass () .getSuperclass() ; //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable () 

{ 

return _immutable; 


DRDC Valcartier TR 2007-412 


567 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

Iterator i = iterator (); 

Iterator n = namelterator () ; 

String s; 

while (i.hasNext ()) 

{ 

s = (String) n. next () ; 

if (i.next().equals(this)) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return 


568 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAresignAction)i.next()).getValue() == value) 

super.setValue(value),- 
o = i.next () ,- 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class[])null); //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super . setValue (value) ,- 
return; 

} 

} catch (Exception ignored) { } 

} 

throw new IllegalArgumentException () ,- 


DRDC Valcartier TR 2007-412 


569 



//The prototype immutable instances (the enumerators) 

j * * 

* DivestOwnership. 

*/ 

static public final HLAresignAction 

DivestOwnership = new HLAresignAction(_nextToAssign); 

j * * 

* DeleteObj ectInstances. 

*/ 

static public final HLAresignAction 

DeleteObjectlnstances = new HLAresignAction(_nextToAssign); 

j * * 

* CancelPendingAcquisitions. 

*/ 

static public final HLAresignAction 

CancelPendingAcquisitions = new HLAresignAction(_nextToAssign); 

j * * 

* DeleteObj ectlnstancesThenDivestOwnership. 

*/ 

static public final HLAresignAction 
DeleteObj ectInstancesThenDivestOwnership = new 
HLAresignAction(_nextToAssign); 

j * * 

* 

CancelPendingAcquisitionsThenDeleteObjectInstancesThenDivestOwnership. 
*/ 

static public final HLAresignAction 

CancelPendingAcquisitionsThenDeleteObj ectInstancesThenDivestOwnership 
= new HLAresignAction(_nextToAssign); 

j * * 

* NoAction. 

*/ 

static public final HLAresignAction 
NoAction = new HLAresignAction(_nextToAssign); 

} 

//end HLAre signAc tion 


570 


DRDC Valcartier TR 2007-412 



// File: HLAserviceGroupName.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe serviceGroupName enumerated data type, used by the 
Management Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
FederationManagement 

* through 6 for SupportServices. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAserviceGroupName 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE(0); 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE(1) ; 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_lowestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAserviceGroupName</code> of default 
(FederationManagement) value. 

*/ 

public 

HLAserviceGroupName() 

{ 

super () 

_immutable = false; 


DRDC Valcartier TR 2007-412 


571 



* * 


* Constructs a <code>HLAserviceGroupName</code> from another one. 

* @param otherHLAserviceGroupName must be a defined static value 
or another instance 

*/ 

public 

HLAserviceGroupName(HLAserviceGroupName otherHLAserviceGroupName) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAserviceGroupName.getValue()); 


j * * 

* Creates a <code>HLAserviceGroupName</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAserviceGroupName</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAserviceGroupName(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAserviceGroupName</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAserviceGroupName</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAserviceGroupName</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAserviceGroupName(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


572 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAserviceGroupName</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAserviceGroupName</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAserviceGroupName(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAserviceGroupName(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue() ) ; 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAserviceGroupName.class, 
false) ; 


DRDC Valcartier TR 2007-412 


573 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAserviceGroupName.class, 

true) ; 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass() .getSuperclass (); //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable() 

{ 

return _immutable; 


574 


DRDC Valcartier TR 2007-412 



//j ava.lang.Object methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

Iterator i = iterator(); 

Iterator n = namelterator() ; 

String s; 

while (i.hasNext()) 

{ 

s = (String)n.next() ; 

if (i.next().equals(this) ) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return " 11 ; 


DRDC Valcartier TR 2007-412 


575 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAserviceGroupName)i.next()).getValue() == value) 

super.setValue(value),- 
o = i. next () 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class [])null) ; //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super. setValue (value) ,- 
return; 

} 

} catch (Exception ignored) {} 

} 

throw new IllegalArgumentException () ,- 


576 


DRDC Valcartier TR 2007-412 



//The prototype immutable instances (the enumerators) 


j k k 

* FederationManagement. 

*/ 

static public final HLAserviceGroupName 

FederationManagement = new HLAserviceGroupName(_nextToAssign); 

j k k 

* DeclarationManagement. 

*/ 

static public final HLAserviceGroupName 

DeclarationManagement = new HLAserviceGroupName(_nextToAssign); 

j k k 

* Obj ectManagement. 

*/ 

static public final HLAserviceGroupName 

ObjectManagement = new HLAserviceGroupName(_nextToAssign); 

j k k 

* OwnershipManagement. 

*/ 

static public final HLAserviceGroupName 

OwnershipManagement = new HLAserviceGroupName(_nextToAssign); 

j k k 

* TimeManagement. 

*/ 

static public final HLAserviceGroupName 

TimeManagement = new HLAserviceGroupName(_nextToAssign); 

j k k 

* DataDistributionManagement. 

*/ 

static public final HLAserviceGroupName 
DataDistributionManagement = new 
HLAserviceGroupName(_nextToAssign); 

j k k 

* SupportServices. 

*/ 

static public final HLAserviceGroupName 

SupportServices = new HLAserviceGroupName(_nextToAssign); 

} 

//end HLAserviceGroupName 


DRDC Valcartier TR 2007-412 


577 



// File: HLAswitch.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe switch enumerated data type, used by the Management 
Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
Disabled 

* and 1 for Enabled. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAswitch 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE (0) ; 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE (1); 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_1owestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAswitch</code> of default (ActiveFederate) 
value. 

*/ 

public 
HLAswitch() 

{ 

super () 

_immutable = false; 


578 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAswitch</code> from another one. 

* @param otherHLAswitch must be a defined static value or another 
instance 

*/ 

public 

HLAswitch(HLAswitch otherHLAswitch) 

{ 

this(); 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAswitch.getValue()); 


j * * 

* Creates a <code>HLAswitch</code> from the network representation 
in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAswitch</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAswitch(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAswitch</code> from the network representation 
in the provided <code>byte[]</code> at the indicated 

<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAswitch</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAswitch</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAswitch(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


579 



* * 


* Creates a <code>HLAswitch</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAswitch</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAswitch(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAswitch(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue()); 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAswitch.class, false); 


580 


DRDC Valcartier TR 2007-412 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAswitch.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass () .getSuperclass() ; //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable () 

{ 

return _immutable; 


DRDC Valcartier TR 2007-412 


581 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

Iterator i = iterator (); 

Iterator n = namelterator () ; 

String s; 

while (i.hasNext ()) 

{ 

s = (String) n. next () ; 

if (i.next().equals(this)) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return 


582 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAswitch)i.next()).getValue() == value) 

super.setValue(value),- 
o = i.next () ,- 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class[])null); //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super . setValue (value) ,- 
return; 

} 

} catch (Exception ignored) { } 

} 

throw new IllegalArgumentException () ,- 


//The prototype immutable instances (the enumerators) 


j k k 

* Disabled. 

*/ 

static public final HLAswitch 
Disabled = new HLAswitch (_nextToAssign) ,- 

j k k 

* Enabled. 

*/ 

static public final HLAswitch 
Enabled = new HLAswitch (_nextToAssign) ,- 

} 

//end HLAswitch 


DRDC Valcartier TR 2007-412 


583 



// File: HLAsyncPointStatus.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe syncPointStatus enumerated data type, used by the 
Management Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
NoActivity 

* through 3 for WaitingForRestOfFederation. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAsyncPointStatus 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE (0) ; 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE (1); 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_1owestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAsyncPointStatus</code> of default 
(ActiveFederate) value. 

*/ 

public 

HLAsyncPointStatus() 

{ 

super () 

_immutable = false; 


584 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAsyncPointStatus</code> from another one. 

* @param otherHLAsyncPointStatus must be a defined static value or 
another instance 

*/ 

public 

HLAsyncPointStatus(HLAsyncPointStatus otherHLAsyncPointStatus) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAsyncPointStatus.getValue()); 


j * * 

* Creates a <code>HLAsyncPointStatus</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAsyncPointStatus</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointStatus(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0),- 


j * * 

* Creates a <code>HLAsyncPointStatus</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAsyncPointStatus</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAsyncPointStatus</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointStatus(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


DRDC Valcartier TR 2007-412 


585 



* * 


* Creates a <code>HLAsyncPointStatus</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAsyncPointStatus</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAsyncPointStatus(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAsyncPointStatus(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue()); 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAsyncPointStatus.class, 
false) ; 


586 


DRDC Valcartier TR 2007-412 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedIterator(HLAsyncPointStatus.class, 

true) ; 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass () .getSuperclass() ; //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable () 

{ 

return _immutable; 


DRDC Valcartier TR 2007-412 


587 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

Iterator i = iterator (); 

Iterator n = namelterator () ; 

String s; 

while (i.hasNext ()) 

{ 

s = (String) n. next () ; 

if (i.next().equals(this)) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return 


588 


DRDC Valcartier TR 2007-412 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAsyncPointStatus)i.next()).getValue() == value) 

super.setValue(value),- 
o = i.next () ,- 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class[])null); //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super . setValue (value) ,- 
return; 

} 

} catch (Exception ignored) { } 

} 

throw new IllegalArgumentException () ,- 


DRDC Valcartier TR 2007-412 


589 



//The prototype immutable instances (the enumerators) 

j * * 

* NoActivity. 

*/ 

static public final HLAsyncPointStatus 
NoActivity = new HLAsyncPointStatus(_nextToAssign); 

j * * 

* AttemptingToRegisterSyncPoint. 

*/ 

static public final HLAsyncPointStatus 
AttemptingToRegisterSyncPoint = new 
HLAsyncPointStatus(_nextToAssign); 

j * * 

* MovingToSyncPoint. 

*/ 

static public final HLAsyncPointStatus 

MovingToSyncPoint = new HLAsyncPointStatus(_nextToAssign); 

j * * 

* WaitingForRestOfFederation. 

*/ 

static public final HLAsyncPointStatus 

WaitingForRestOfFederation = new HLAsyncPointStatus(_nextToAssign); 

} 

//end HLAsyncPointStatus 


590 


DRDC Valcartier TR 2007-412 



// File: HLAtimeState.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Iterator; 

j * * 

* Type-safe timeState enumerated data type, used by the Management 
Object Model (MOM). 

* Uses the <code>HLAinteger32BE</code> basic data type with 0 for 
TimeGranted 

* and 1 for TimeAdvancing. 

* Note that a cloned immutable instance (a cloned enumerator) will be 
immutable also. 

* <p> 

* See {@link HLAboolean} and {@link HLAenumerateddatatype} for the 
design guidelines. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAtimeState 

extends HLAinteger32BE 
implements HLAenumerateddatatype 

{ 

//Initial value for enumeration 
private static final HLAinteger32BE 
_lowestValue = new HLAinteger32BE(0); 

//Enumeration step 

private static final HLAinteger32BE 
_step = new HLAinteger32BE(1) ; 

//The enumeration begins at the lowest value, 
private static HLAinteger32BE 

_nextToAssign = new HLAinteger32BE(_lowestValue.getValue()); 

//Whether this instance is immutable 
private final boolean 
_immutable; 

j * * 

* Constructs a <code>HLAtimeState</code> of default 
(ActiveFederate) value. 

*/ 

public 

HLAtimeState() 

{ 

super () 

_immutable = false; 


DRDC Valcartier TR 2007-412 


591 



* * 


* Constructs a <code>HLAtimeState</code> from another one. 

* @param otherHLAtimeState must be a defined static value or 
another instance 

*/ 

public 

HLAtimeState(HLAtimeState otherHLAtimeState) 

{ 

this ( ) ; 

//Calling super.setValue directly skips the validation 
super.setValue(otherHLAtimeState.getValue()); 


j * * 

* Creates a <code>HLAtimeState</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAtimeState</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtimeState(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Creates a <code>HLAtimeState</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAtimeState</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAtimeState</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtimeState(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


592 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAtimeState</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAtimeState</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAtimeState(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Class and subclass constructor; it is used to generate the 
static values. 

*/ 

private 

HLAtimeState(HLAinteger32BE nextToAssign) 

{ 

super(); 

_immutable = true; 

//Calling super.setValue directly skips the validation 
super.setValue(nextToAssign.getValue()); 
nextToAssign.setValue(nextToAssign.getValue() + 

_step.getValue() ) ; 


//HLAenumerateddatatype implementation 

j * * 

* Returns an Iterator over the enumeration's elements. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* @return an Iterator over the elements in this enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
iterator() 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAtimeState.class, false); 


DRDC Valcartier TR 2007-412 


593 



* * 


* Returns an Iterator over the enumeration's element names. 

* Note that the iterator returned by this method throws an 

* <code>UnsupportedOperationException</code> in response to its 

* <code>remove()</code> method. 

* <p> 

* This namelterator is guaranteed to match the sequence of the 
other one. 

* This means you can obtain <code>iterator()</code> and 
<code>nameIterator()</code> and then 

* go <code>next()</code> in lock-step to enumerate both the 
immutable instances and their names. 

* @return an Iterator over the names of the elements in this 
enumeration 

* @throws ClassCastException if the Iterator construction fails 

*/ 

public Iterator 
namelterator () 

throws ClassCastException 

{ 

return new HLAenumeratedlterator(HLAtimeState.class, true); 


j * * 

* Returns the underlying Class of the enumeration's elements (the 
elements' representation Class). 

* @return the underlying Class of the enumeration's elements 
*/ 

public Class 
getElementClass () 

{ 

return HLAinteger32BE.class; 

// return this.getClass() .getSuperclass (); //non-static only 


j * * 

* Returns true if the instance is immutable. 

* @return a boolean which is true if the instance is immutable 

*/ 

public boolean 
islmmutable() 

{ 

return _immutable; 


594 


DRDC Valcartier TR 2007-412 



//j ava.lang.Object methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

Iterator i = iterator(); 

Iterator n = namelterator() ; 

String s; 

while (i.hasNext()) 

{ 

s = (String)n.next() ; 

if (i.next().equals(this) ) return s; 

} 

//Cannot happen, but the compiler doesn't know this 
return " 11 ; 


DRDC Valcartier TR 2007-412 


595 



//Class-specific extensions 


j k k 

* The inherited setValue sets <code>this</code> value from an int. 

* @param value the int new value for <code>this</code> 

* @throws UnsupportedOperationException if used on an enumerator 
instance 

* @throws IllegalArgumentException if the value isn't one of the 
enumerators' 

*/ 

public void 
setValue(int value) 

throws UnsupportedOperationException, 

IllegalArgumentException 

{ 

if (islmmutable()) throw new UnsupportedOperationException () ,- 
Iterator i = iterator (),- 
Object o; 

while (i.hasNext()) 

{ 

// if (((HLAresignAction)i.next()).getValue() == value) 

super.setValue(value),- 
o = i. next () 
try { 

java.lang.reflect.Method gV = 

o.getClass().getMethod("getValue", (Class [])null) ; //throws 
NoSuchMethodException, SecurityException 

if (value == ((Integer)(gV.invoke(o, 

(Object[])null))).intValue()) //throws IllegalAccessException, 
IllegalArgumentException, InvocationTargetException 
{ 

super. setValue (value) ,- 
return; 

} 

} catch (Exception ignored) {} 

} 

throw new IllegalArgumentException () ,- 


//The prototype immutable instances (the enumerators) 

j k k 

* ActiveFederate. 

*/ 

static public final HLAtimeState 
TimeGranted = new HLAtimeState (_nextToAssign) ,- 

j k k 

* TimeAdvancing. 

*/ 

static public final HLAtimeState 

TimeAdvancing = new HLAtimeState (_nextToAssign) ,- 

} 

//end HLAtimeState 


596 


DRDC Valcartier TR 2007-412 



The HLAarraydatatype interface combines HLAdatatype with Java’s List. The 
HLAarrayType abstract class extends Java’s AbstractList and provides the 
foundation for the two (abstract) subclasses HLAvariableArrayType and 
HLAfixedArrayType. 


// File: HLAarraydatatype.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

j * * 

* Interface implemented by the various HLA array data types. 

* <p> 

* In addition to this interface, the HLA array data type classes are 
expected to supply: 

* <ul > 

* <li> Constructors (default and specified-value)</li> 

* <li> Constructor (byte[] buffer) throws CouldNotDecode</li> 

* <li> Constructor (byte[] buffer, int offset) throws 
CouldNotDecode</li> 

* <li> Constructor (ByteWrapper byteWrapper) throws 
CouldNotDecode</li> 

* <li> java.lang.Object methods toStringO; equals (Object 
otherObject) and hashCode()</li> 

* <li> Class-specific extensions to get and set the value as a basic 
java data type (int, boolean, etc.)</li> 

* </ul> 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface 
HLAarraydatatype 

extends HLAdatatype, 

j ava.util.List 


j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

Class 

getElementClass () ,- 

j * * 

* Returns a boolean which is <code>true</code> if the array is 
dynamic. 

* @return a boolean which is true if the array is dynamic 
*/ 

boolean 
isDynamic () ,- 

} 

//end HLAarraydatatype 


DRDC Valcartier TR 2007-412 


597 



// File: HLAarrayType.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode,- 
import j ava.util.Iterator; 

j * * 

* Abstract ancestor for the type-safe array data types. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public abstract class 
HLAar r ayTyp e 

extends java.util.AbstractList // thus implements java.util.List 
implements j ava.io.Serializable, 
j ava.lang.Cloneable, 
j ava.util.RandomAccess, 

HLAarraydatatype 

{ 

//If at all possible, it is strongly recommended that the concrete 
class declare this field: 

// public static final int 
// octetBoundary = <whatever>; 

//HLAdatatype interface implementation 

j * * 

* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

* @return how many bytes were written to the buffer, including any 
prefix padding bytes 

*/ 

public int 

encode(byte[] buffer, 
int offset) 

{ 

return encode(new ByteWrapper(buffer, offset)) .pos () - offset; 


598 


DRDC Valcartier TR 2007-412 



* * 


* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 

//Variable arrays prefix the encode with the number of elements; 
//static arrays do not 
if (isDynamic()) (new 

HLAinteger32BE(size())).encode(byteWrapper); 

//And then one just encodes the individual elements 
Iterator i = iterator (); 
while (i.hasNext()) 

((HLAdatatype) (i.next())) .encode(byteWrapper) ; 
return byteWrapper; 


j * * 

* Encodes <code>this</code> into a new <code>byte[]</code>. 

* @return a <code>byte[]</code> encoding <code>this</code> 
*/ 

public byte[] 
toByteArray() 

{ 

return encode(new ByteWrapper(encodedLength())).array(); 


j * * 

* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the data type 

* @return how many bytes were read from the <code>byte[]</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer) 

throws CouldNotDecode 

{ 

return decode(buffer, 0); 


DRDC Valcartier TR 2007-412 


599 



* * 


* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> <code>this</code> 
representation begins 

* @return where in the <code>buffer</code> <code>this</code> 
representation ends 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

try 


return decode(new ByteWrapper(buffer, offset)) .pos () ; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


int count; 

// java.lang.reflect.Constructor cons = 

getElementClass().getConstruetor(new Class[] { 

Class . f orName (" ca . go . drdc_rddc . hla.rtil516. ByteWrapper 11 ) }) ; 

j ava.lang.reflect.Constructor cons = 
getElementClass() .getConstruetor(new Class [] { ByteWrapper.class }) ; 


600 


DRDC Valcartier TR 2007-412 



byteWrapper.align(octetBoundary() ) ; 
if (isDynamic() ) 

{ 

//Dynamic arrays 
clear(); 

//First we read the number of elements to decode 
count = byteWrapper.getInt(); 

//Then we decode the individual elements 

for (int i = 0; i < count; i++) add(cons.newlnstance(new 
Object [] { byteWrapper })); 

} 

else 


//Static arrays 
count = size(); 

//Decode the individual elements 
for (int i = 0; i < count; i++) set(i, 
cons.newlnstance(new object[] { byteWrapper })); 

} 

return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage ()); 
throw (CouldNotDecode)end.initCause(e); 


//j ava.lang.Object methods 

j * * 

* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode () 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals (Object otherObject) 

{ 

if (lsuper.equals(otherObject)) return false; 

//At this point, we know both this and otherObject implement the 
List interface 

//and have the same iteration of elements (using equals at their 

level) 

//All we need do here is make sure otherObject is of this' class 
return this.getclass().equals(otherObj ect.getClass()) ; 


DRDC Valcartier TR 2007-412 


601 



//Cloneable implementation 

j * * 

* Creates and returns a copy of this object. 

* @return an independent copy of this Object 

* @throws CloneNotSupportedException if the object's class is not 
Cloneable or if the instance cannot be cloned 

*/ 

public Object 
clone () 

throws CloneNotSupportedException 

{ 

// throw new CloneNotSupportedException(); 
return super.clone(); 


//end HLAarrayType 


602 


DRDC Valcartier TR 2007-412 



// File: HLAfixedArrayType.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

j * * 

* Abstract ancestor for the type-safe fixed array data types. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public abstract class 
HLAfixedArrayType 

extends HLAarrayType 

{ 

//HLAarraydatatype interface implementation 

//Being based on java.util.AbstractList, concrete fixed array 
classes will need to 

//provide implementations for: 

//get(int index) 

//size () 

//set(int index, Object element) 

//You should provide two constructors (void and collection 
arguments). 

//You do not have to provide an Iterator implementation. 

//List methods may be overridden if a more efficient implementation 
is possible. 

j * * 

* Returns a boolean which is <code>true</code> if the array is 
dynamic. 

* @return a boolean which is true if the array is dynamic 
*/ 

public final boolean 
isDynamic() 

{ 

return false; 


//end HLAfixedArrayType 


DRDC Valcartier TR 2007-412 


603 



// File : HLAvariableArrayType.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

j * * 

* Abstract ancestor for the type-safe dynamic array data types. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public abstract class 
HLAvariableArrayType 
extends HLAarrayType 

{ 

//HLAarraydatatype interface implementation 

//Being based on java.util.AbstractList, concrete variable array 
classes will need to 

//provide implementations for: 

//get(int index) 

//size() 

//set(int index, Object element) 

//add(int index, Object element) 

//remove(int index) 

//You should provide two constructors (void and collection 
arguments). 

//You do not have to provide an Iterator implementation. 

//List methods may be overridden if a more efficient implementation 
is possible. 

j * * 

* Returns a boolean which is <code>true</code> if the array is 
dynamic. 

* @return a boolean which is true if the array is dynamic 
*/ 

public final boolean 
isDynamic() 

{ 

return true; 


//end HLAvariableArrayType 


604 


DRDC Valcartier TR 2007-412 



We implement the OMT’s HLAopaqueData, HLAASCII string and 
HLAunicodeString, grouping the last two under the abstract HLAstring class. 
Our concrete HLAob j ectArray will serve as ancestor for most remaining array 
datatypes. 


// File: HLAopaqueData.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 
import j ava.util.Iterator; 

j * * 

* Type-safe variable byte array data type. 

* It uses <code>HLAbyte</code> elements and a Java 
<code>byte[]</code> internally. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAopaqueData 

extends HLAvariableArrayType 

{ 

/** Octet boundary of this class. */ 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

/** The array of bytes. */ 
protected transient byte[] _values; 

j * * 

* Constructs an empty <code>HLAopaqueData</code>. 

*/ 

public 

HLAopaqueData() 

{ 

//super() not called because super-class is abstract 
_values = new byte[0]; 


DRDC Valcartier TR 2007-412 


605 



* * 


* Constructs an <code>HLAopaqueData</code> from a Collection of 
HLAbyte. 

* @param c a Collection of HLAbyte objects 
*/ 

public 

HLAopaqueData(Collection c) 

{ 

//We could start with an empty _values (by invoking thisO) 
//and then add() using the c.iterator () , but that is relatively 
inefficient. 

_values = new byte[c.size()]; 

Iterator it = c.iterator(); 

for (int i = 0; it.hasNext(); i++) 

{ 

set (i, it.next ()); 


j * * 

* Constructs an <code>HLAopaqueData</code> containing the 
specified byte value. 

* @param value a byte specifying <code>this</code>' value 
*/ 

public 

HLAopaqueData (byte value) 

{ 

this(); 

add(new Byte(value) ) ; 


j * * 

* Creates an <code>HLAopaqueData</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAopaqueData</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAopaqueData(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ; 


606 


DRDC Valcartier TR 2007-412 



* * 


* Creates an <code>HLAopaqueData</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAopaqueData</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAopaqueData</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAopaqueData(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates an <code>HLAopaqueData</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAopaqueData</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAopaqueData(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


j * * 

* Sets the size of the array to the specified value. 

* Reducing the size will result in the loss of the "chopped off" 
bytes. 

* @param newSize an int specifying the array's desired new size 

*/ 

protected void 
setSize(int newSize) 

{ 

modCount + + ,- 

int bytesToCopy = _values.length; 

if (newSize < bytesToCopy) bytesToCopy = newSize,- 
byte oldValues[] = _values,- 
_values = new byte [newSize] ,- 

System. arraycopy (oldValues , 0, _values, 0, bytesToCopy) ,- 


DRDC Valcartier TR 2007-412 


607 



//List interface implementation 


j k k 

* Inserts the specified element at the specified position in this 
array. 

* Elements must be compatible with HLAbyte; this is why this 
implementation accepts only Byte and HLAoctet (and their descendants). 

* @param index an int indicating the position before which to 
insert the element 

* @param element an Object to insert before index 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws ClassCastException if the class of the specified element 
prevents it from being added to this list 

* @throws NullPointerException if the specified element is null 
and this list does not support null elements 

* @throws IllegalArgumentException if some aspect of this element 
prevents it from being added to this list 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public void 
add (int index, 

Object element) 

{ 

if ((index > sizeO) || (index < 0)) throw new 
IndexOutOfBoundsException(Integer.toString(index)),- 

if (element == null) throw new NullPointerException () ,- 
byte value,- 

if (element instanceof Byte) 

{ 

value = ((Byte)element).byteValue(),- 

} 

else if (element instanceof HLAoctet) 

{ 

value = ((HLAoctet)element).getValue(),- 

} 

else 

{ 

throw new ClassCastException(element.getClass().toString()),- 

} 

setSize (size () + 1); //increments modCount 

System.arraycopy(_values, index, _values, index + 1, size() - 
(index + 1)) ; 

_values [index] = value,- 


608 


DRDC Valcartier TR 2007-412 



* * 


* Inserts all of the elements in the specified collection into 
this array at the specified position. 

* @param index an int indicating before which element to insert 
the collection 

* @param c a Collection of elements to insert 

* @return a boolean which is true if this array changed as a 
result of this call 

* @throws IllegalArgumentException if any character to append is 
not in the 00..7F range 

*/ 

public boolean 

addAll(int index, 

Collection c) 

//This implementation preserves the array if the method ends 
abnormally 
{ 

boolean modified = false,- 
//Presume abnormal termination 
boolean abnormal = true; 

//Preserve the old array and modCount 

byte oldValues[] = new byte [size ()] ,- 

System. arraycopy (_values, 0, oldValues, 0, sizeO); 

int m = modCount; 

try 


modified = super.addAll(index, c); 
abnormal = false,- 

} 

finally 

{ 

if (abnormal) 

{ 

//If any of the add() failed, restore the old String and 

modCount 

_values = oldValues,- 
modCount = mu- 
modified = false,- 


return modified; //If one has a return within a finally, one 
gets a warning 


j * * 

* Removes all of the elements from this array. 

*/ 

public void 
clear () 

//This implementation is more efficient than AbstractList.clear () 

{ 

_values = new byte[0] ,- 

//Provide fail-fast iterators (and list iterators) 
modCount + + ,- 


DRDC Valcartier TR 2007-412 


609 



j k k 

* Returns the element (a Byte) at the specified position in this 
array. 

* @param index an int specifying the element to return 

* @return the requested Object (a Byte) 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
get (int index) 

{ 

return new HLAbyte(_values[index] ) ; 


j k k 

* Removes the element at the specified position in this array and 
returns it. 

* @param index an int indicating the position from which to remove 
the element 

* @return the element that was removed from the list 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
remove(int index) 

{ 

if ((index > sizeO) || (index < 0)) throw new 
IndexOutOfBoundsException(Integer.toString(index)); 

Object o = get(index); 

System.arraycopy(_values, index + 1, _values, index, size() - 
(index + 1)) ; 

setSize (size () - 1); //increments modCount 

return o; 


610 


DRDC Valcartier TR 2007-412 



* * 


* Replaces the element at the specified position in this array 
with the specified element. 

* The element must be compatible with HLAbyte; this is why this 
implementation accepts only Byte and HLAoctet (and their descendants). 

* @param index an int specifying the index of the element to 
replace 

* @param element the Object to use in replacing the element 

* @return the element previously at the specified position 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws ClassCastException if the class of the specified element 
prevents it from being added to this list 

* @throws NullPointerException if the specified element is null 
and this list does not support null elements 

* @throws IllegalArgumentException if some aspect of the specified 
element prevents it from being added to this list 

* @throws IndexOutOfBoundsException if the index is outside the 
[ 0 . . size () [ range 

*/ 

public Object 
set(int index, 

Object element) 

{ 

if ((index > sizeO) || (index < 0)) throw new 
IndexOutOfBoundsException(Integer.toString(index)); 

if (element == null) throw new NullPointerException() ; 
byte value; 

if (element instanceof Byte) 

{ 

value = ((Byte)element).byteValue(); 

} 

else if (element instanceof HLAoctet) 

{ 

value = ((HLAoctet)element).getValue(); 

} 

else 

{ 

throw new ClassCastException(element.getClass().toString()); 

} 

Object o = get(index); 

_values[index] = value; 

//Note that set() does not modify the array <i>structurally</i> 
return o; 


j * * 

* Returns the number of elements in this array. 

* @return an int specifying the number of elements in this array 

*/ 

public int 
size() 

{ 

return _values.length; 


DRDC Valcartier TR 2007-412 


611 



//j ava.lang.Obj ect methods 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* Here we choose to use the form " [ xx xx ] 11 where xx is the 
hexadecimal representation of each byte. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString () 

{ 

String s = " 

Iterator i = iterator (); 
while (i.hasNext()) s = s + 

Integer.toHexString((int)((HLAoctet)i.next()).getValue()) + " "; 
return "[" + s + "]"; 


//HLAdatatype interface implementation 

j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* This implementation is more efficient than the ancestor's. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()); 

(new HLAinteger32BE(size())).encode(byteWrapper); 
byteWrapper.read(_values); 
return byteWrapper; 


j * * 

* Encodes <code>this</code> into a new <code>byte[]</code>. 

* This implementation is more efficient than the ancestor's. 

* @return a <code>byte[]</code> encoding <code>this</code> 

*/ 

public byte[] 
toByteArray() 

{ 

return _values; 


612 


DRDC Valcartier TR 2007-412 



* * 


* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* This implementation is more efficient than the ancestor's. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 


byteWrapper.align(octetBoundary() ) ; 

//First we read the number of elements to decode 
int count = byteWrapper.getInt() ; 
setSize(count); //increments modCount 
//Then we decode the individual elements 
byteWrapper.write(_values) ; 
return byteWrapper; 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* <p> 

* As a general rule, Variant Records [HLAvariantRecord], Dynamic 
Arrays [HLAvariableArray], and any 

* Fixed Arrays [HLAfixedArray] or Fixed Records [HLAfixedRecord] 
containing either of these first two 

* cannot have a constant encodedLength. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

return HLAinteger32BE.encodedLength + size(); 


DRDC Valcartier TR 2007-412 


613 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* For dynamic arrays, octet boundary is thus the largest of the 
count (an HLAinteger32BE) and the element. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary,- 


//HLAarraydatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAbyte. class ,- 


//end HLAopaqueData 


614 


DRDC Valcartier TR 2007-412 



// File: HLAstring.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

//import j ava.util.Collection; 

j * * 

* Type-safe abstract String variable array data type. 

* It uses <code>char</code> elements and a Java <code>String</code> 
internally; 

* it is the ancestor of the HLAASCII string and HLAunicodeString 
concrete classes. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public abstract class 
HLAstring 

extends HLAvariableArrayType 

{ 

/** Octet boundary of this class. */ 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

/** The String variable array: a Java String. */ 
protected String _value; 


DRDC Valcartier TR 2007-412 


615 



//List interface implementation 


j k k 

* Inserts the specified element at the specified position in this 
array. 

* Elements must be compatible with HLAunicodeChar; this is true as 
long as the element's toStringO method 

* returns a non-zero length String. Zero-length Strings are not 
acceptable. 

* @param index an int indicating the position before which to 
insert the element 

* @param element an Object to insert before index 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws ClassCastException if the class of the specified element 
prevents it from being added to this list 

* @throws NullPointerException if the specified element is null 
and this list does not support null elements 

* @throws IllegalArgumentException if some aspect of this element 
prevents it from being added to this list 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public void 
add (int index, 

Object element) 

{ 

try 


_value = _value.substring(0, index) + 
verify(element.tostring().substring(0, 1)) + _value.substring(index); 
} 

catch (IndexOutOfBoundsException e) 

{ 

//element.toString() must have returned a zero-length String 
IllegalArgumentException iae = new 
IllegalArgumentException(e.getMessage() ) ; 

throw (IllegalArgumentException)iae.initCause(e); 

} 

//Provide fail-fast iterators (and list iterators) 
modCount++; 


616 


DRDC Valcartier TR 2007-412 



* * 


* Inserts all of the elements in the specified collection into 
this array at the specified position. 

* @param index an int indicating before which element to insert 
the collection 

* @param c a Collection of elements to append 

* @return a boolean which is true if this array changed as a 
result of this call 

* @throws IllegalArgumentException if any character to append is 
not in the 00..7F range 

*/ 

public boolean 

addAll(int index, 

Collection c) 

//This implementation preserves the array if the method ends 
abnormally 
{ 

boolean modified = false,- 
//Presume abnormal termination 
boolean abnormal = true; 

//Preserve the old String and modCount 
String s = _value,- 

//Strings are immutable, so although s and _value now reference 
the same object, 

//changing _value later will change the _value reference away 

from s 

int m = modCount; 
try 


modified = super.addAll(index, c); 
abnormal = false,- 

} 

finally 

{ 

if (abnormal) 

{ 

//If any of the add() failed, restore the old String and 

modCount 

_value = s,- 
modCount = mu- 
modified = false,- 


return modified; //If one has a return within a finally, one 
gets a warning 


DRDC Valcartier TR 2007-412 


617 



* * 


* Removes all of the elements from this array. 

*/ 

public void 
clear () 

//This implementation is more efficient than AbstractList.clear() 

{ 

_value = " 11 ; 

//Provide fail-fast iterators (and list iterators) 
modCount++; 


j * * 

* Returns true if this array contains the specified element. 

* The method looks for Object.toString().substring(0, 1) in the 
array. 

* A zero-length String element will return false. 

* @param o the Object sought in the array 

* @return a boolean which is true if the array contains 
o.toString().charAt(0) 

*/ 

public boolean 
contains(Object o) 

//This implementation is more efficient than 
AbstractCollection.contains(Object) 

//I'm a little surprised this isn't in AbstractList already... 

{ 

return (indexOf(o) > -1); 


j * * 

* Returns the element (a char) at the specified position in this 
array. 

* @param index an int specifying the element to return 

* @return the requested Object (a char) 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
get (int index) 

{ 

return new Character(_value.charAt(index)); 


618 


DRDC Valcartier TR 2007-412 



* * 


* Returns the index in this array of the first occurrence of the 
specified element, 

* or -1 if this array does not contain this element (zero-length 
Strings will return -1). 

* @param o the Object whose toStringO is sought 

* @return the index of the first occurrence of the specified 
element (-1 if not found) 

*/ 

public int 
indexOf(Object o) 

//This implementation is more efficient than 
AbstractList.indexOf(Object) 

{ 

if (o.toString().length() <= 0) return -1; 

return _value.indexOf(o.toString() .substring (0, 1)) ; 


j * * 

* Returns the index in this array of the last occurrence of the 
specified element, 

* or -1 if this array does not contain this element (zero-length 
Strings will return -1). 

* @param o the Object sought 

* @return an int specifying the last occurrence of the specified 
element (-1 if not found) 

*/ 

public int 

lastIndexOf(Object o) 

//This implementation is more efficient than 
AbstractList.lastIndexOf(Object) 

{ 

if (o.toString().length() <= 0) return -1; 

return _value.lastIndexOf(o.toString() .substring (0, 1)) ; 


j * * 

* Removes the element at the specified position in this array and 
returns it. 

* @param index an int indicating the position from which to remove 
the element 

* @return the element that was removed from the list 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
remove(int index) 

{ 

Object o = get(index); 

_value = _value.substring(0, index) + _value.substring(index + 

1 ) ; 

//Provide fail-fast iterators (and list iterators) 
modCount++; 
return o; 


DRDC Valcartier TR 2007-412 


619 



* * 


* Retains only the elements in this array that are contained in 
the specified collection. 

* The AbstractCollection implementation clarifies the semantics as 
follows: 

* One should iterate over the list and, for each element not 
contained in the collection, remove it. 

* This means all elements that appear at least once in the 
collection are retained, 

* and that the list retains its original sort order. 

* @param c the Collection of elements to retain from this array 

* @return a boolean which is true if this has changed 

* @throws UnsupportedOperationException if this method is not 
supported 

* @throws ClassCastException if the elements of the array and 
collection are incompatible 

* @throws NullPointerException if the specified collection is null 

*/ 

// public boolean 
// retainAll(Collection c) 

//Provided by AbstractCollection 

j * * 

* Replaces the element at the specified position in this array 
with the specified element. 

* @param index an int specifying the index of the element to 
replace 

* @param element the Object to use in replacing the element 

* @return the element previously at the specified position 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws ClassCastException if the class of the specified element 
prevents it from being added to this list 

* @throws NullPointerException if the specified element is null 
and this list does not support null elements 

* @throws IllegalArgumentException if some aspect of the specified 
element prevents it from being added to this list 

* @throws IndexOutOfBoundsException if the index is outside the 
[ 0..size () [ range 

*/ 

public Object 
set (int index, 

Object element) 

{ 

if (element.toString().length() <= 0) throw new 
IllegalArgumentException () ,- 
Object o = get (index) ,- 

_value = _value.substring(0, index) + 
verify(element.toString().substring(0, 1)) + _value.substring(index + 
1 ) ; 

//Note that set() does not modify the array <i>structurally</i> 
return o; 


620 


DRDC Valcartier TR 2007-412 



* * 


* Returns the number of elements in this array. 

* @return an int specifying the number of elements in this array 

*/ 

public int 
size () 

{ 

return _value. length (),- 


//j ava.lang.Object methods 

j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting <code>this</code> 
value 

*/ 

public String 
toString() 

{ 

return _value,- 


//HLAdatatype interface implementation 

j * * 

* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* For dynamic arrays, octet boundary is thus the largest of the 
count (an HLAinteger32BE) and the element. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

return octetBoundary,- 


//Class-specific extensions 


j * * 

* Verifies if the String value is acceptable. 

* @param value the String to verify 

* @return the String value 

* @throws IllegalArgumentException if any character in the value 
is unacceptable 

*/ 

protected abstract String 
verify(String value) 

throws 11 legal Argument Except ion ,- 


DRDC Valcartier TR 2007-412 


621 



* * 


* Returns the String value of <code>this</code>. 

* @return the String value of <code>this</code> 

* @see #setValue 

*/ 

public String 
getValue() 

{ 

return value; 


j * * 

* Sets the String value of <code>this</code>. 

* @param value the String new value for <code>this</code> 

* @throws IllegalArgumentException if the value isn't Unicode 

* @see #getValue 
*/ 

public void 
setValue(String value) 

{ 

_value = verify(value); 

//Provide fail-fast iterators (and list iterators) 
modCount++; 


j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return char.class; 


//end HLAstring 


622 


DRDC Valcartier TR 2007-412 



// File: HLAASCIIstring.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe ASCII string variable array data type. 

* It uses <code>HLAASCIIchar</code> elements. 

* A Java <code>String</code> is used internally. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAASCII string 

extends HLAstring 

{ 

j * * 

* Constructs a <code>HLAASCIIstring</code> of default value (empty 
ASCII string). 

*/ 

public 

HLAASCIIstring() 

{ 

//super() not called because HLAstring is abstract 
setValue(""); 


j * * 

* Constructs a <code>HLAASCIIstring</code> from the specified 
Collection. 

* An exception occurs if the Collection doesn't return a series of 
ASCII characters. 

* @param c a Collection specifying <code>this</code>' value 

* @throws IllegalArgumentException if value isn't ASCII (all 
characters in numeric range 0..127) 

*/ 

public 

HLAASCIIstring(Collection c) 

throws IllegalArgumentException 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

this ( ) ; 
addAll(c); 


DRDC Valcartier TR 2007-412 


623 



* * 


* Constructs a <code>HLAASCIIstring</code> from the specified 
String value. 

* An exception occurs if any part of value String is not ASCII. 

* @param value a String specifying <code>this</code>' value 

* @throws IllegalArgumentException if value isn't ASCII (all 
characters in numeric range 0..127) 

*/ 

public 

HLAASCII string(String value) 

throws IllegalArgumentException 

{ 

this ( ) ; 

setValue(value); 


j * * 

* Constructs a <code>HLAASCIIstring</code> from the specified 
Obj ect. 

* @param o an Object whose toStringO specifies <code>this</code> 
*/ 

public 

HLAASCII string(Object o) 

{ 

this ( ) ; 

setValue(o.toString() ) ; 


j * * 

* Creates a <code>HLAASCIIstring</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAASCIIstring</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAASCII string(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ; 


624 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAASCIIstring</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAASCIIstring</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAASCIIstring</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAASCIIstring(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Creates a <code>HLAASCIIstring</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAASCIIstring</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAASCIIstring(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


625 



* * 


* Verifies if the String value is ASCII. 

* @param value the String to verify 

* @return the value String 

* @throws IllegalArgumentException if any character in the value 
is not in the 00..7F range 

*/ 

protected final String 
verify(String value) 

throws IllegalArgumentException 

{ 

for (int i = 0; i < value.length(); i++) 

HLAASCIIchar.verify(value.charAt(i)); 

// { 

// if (value.charAt(i) < 0x0080) continue; 

// if (value.charAt(i) > OxOFFF) 


// throw new IllegalArgumentException 

Integer.toHexString((int)value.charAt(i))); 

// } 

// else if (value.charAt(i) > OxOOFF) 

// { 

// throw new IllegalArgumentException 

Integer.toHexString((int)value.charAt(i))); 

// } 

// else // (value.charAt(i) > 0x007F) 

// { 

// throw new IllegalArgumentException 

Integer.toHexString((int)value.charAt(i))); 


i + "] = Ox" + 


i + "] = 0x0" + 


i + "] = 0x00" + 


return value; 


//List interface implementation 

j * * 

* Returns the element (an HLAASCIIchar) at the specified position 
in this array. 

* @param index an int specifying the element to return 

* @return the requested Object (an HLAASCIIchar) 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
get (int index) 

{ 

return new HLAASCIIchar(super.get(index)); 


626 


DRDC Valcartier TR 2007-412 



//HLAdatatype interface implementation 


j k k 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength() 

{ 

// return HLAinteger32BE.encodedLength + size(); 

return HLAinteger32BE.encodedLength + 

HLAASCIIchar.encodedLength* size() ; 


public Class 
getElementClass () 

{ 

return HLAASCIIchar.class; 


//end HLAASCII string 


DRDC Valcartier TR 2007-412 


627 



// File: HLAunicodeString.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe Unicode string variable array data type. 

* It uses <code>HLAunicodeChar</code> elements. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAunicodeString 

extends HLAstring 

{ 

j * * 

* Constructs a <code>HLAunicodeString</code> of default value 
(empty Unicode string). 

*/ 

public 

HLAunicodeString() 

{ 

//super () not called because HLAstring is abstract 
setValue(""); 


j * * 

* Constructs a <code>HLAunicodeString</code> from the specified 
Collection. 

* An exception occurs if the Collection doesn't return a series of 
Unicode characters. 

* @param c a Collection specifying <code>this</code>' value 

* @throws IllegalArgumentException if value isn't Unicode 

*/ 

public 

HLAunicodeString(Collection c) 

throws IllegalArgumentException 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

this ( ) ; 
addAll (c) ; 


628 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAunicodeString</code> from the specified 
String value. 

* An exception occurs if any part of value String is not Unicode. 

* @param value a String specifying <code>this</code>' value 

* @throws IllegalArgumentException if value isn't Unicode 

*/ 

public 

HLAunicodeString(String value) 

throws IllegalArgumentException 

{ 

this ( ) ; 

setValue(value) ; 


j * * 

* Constructs a <code>HLAunicodeString</code> from the specified 
Obj ect. 

* @param o an Object whose toStringO specifies <code>this</code> 
*/ 

public 

HLAunicodeString(Obj ect o) 

{ 

this ( ) ; 

setValue(o.toString()); 


j * * 

* Creates a <code>HLAunicodeString</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAunicodeString</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAunicodeString(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


629 



* * 


* Creates a <code>HLAunicodeString</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAunicodeString</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAunicodeString</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAunicodestring(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates a <code>HLAunicodeString</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAunicodeString</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAunicodeString(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Verifies if the String value is acceptable. 

* @param value the String to verify 

* @return the String value 

* @throws IllegalArgumentException if any character in the value 
is unacceptable 

*/ 

protected String 
verify(String value) 

throws IllegalArgumentException 

{ 

//All Java Strings are acceptable because they are Unicode 
return value; 


630 


DRDC Valcartier TR 2007-412 



//List interface implementation 


j k k 

* Returns the element (an HLAunicodeChar) at the specified 
position in this array. 

* @param index an int specifying the element to return 

* @return the requested Object (an HLAunicodeChar) 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
get(int index) 

{ 

return new HLAunicodeChar(super.get(index)); 


//HLAdatatype interface implementation 

j k k 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength() 

{ 

// return HLAinteger32BE.encodedLength() + 2*size(); 

return HLAinteger32BE.encodedLength + 

HLAunicodeChar.encodedLength*size() ; 


j k k 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAunicodeChar.class; 


//end HLAunicodestring 


DRDC Valcartier TR 2007-412 


631 



// File: HLAobjectArray.java 

package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode,- 
import j ava.util.Collection; 
import j ava.util.Iterator; 

j * * 

* Type-safe variable HLAnull array data type. 

* It uses <code>HLAnull</code> elements and a Java 
<code>Object[]</code> internally. 

* It is designed as a generic concrete ancestor to various non-basic 
data type HLA variable arrays. 

* <p> 

* Instead of using the HLAdatatype interface as element class, we 
used HLAnull, 

* simply in order to make this decodable. 

* <p> 

* The HLAunicodeString and HLAopaqueData classes use String and 
byte[], respectively, 

* to store HLAunicodeChar and HLAbyte elements, respectively, so 
their implementations 

* are different in order to be more efficient. 

* <p> 

* Descendant array types need only supply constructors that invoke 
super, 

* and override List methods when better implementations are possible. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAobj ectArray 

extends HLAvariableArrayType 

{ 

/** Octet boundary of this class. */ 

//The element count is HLAinteger32BE.octetBoundary, but the 
elements 

//themselves may be wider (e.g. an array of HLAinteger64BE), 

//in which case this field should be redeclared 
public static final int 

octetBoundary = HLAinteger32BE . octetBoundary,- 

/** The array of Objects. */ 
protected transient Object [] _values,- 

j * * 

* Constructs an empty <code>HLAobjectArray</code>. 

*/ 

public 

HLAobj ectArray() 

{ 

//super () not called because super-class is abstract 
_values = new Object [0] ,- 


632 


DRDC Valcartier TR 2007-412 



* * 


* Constructs an <code>HLAobjectArray</code> from a Collection of 
Obj ects. 

* @param c a Collection of Objects 
*/ 

public 

HLAobj ectArray(Collection c) 

{ 

//super() not called because super-class is abstract 
//We could start with an empty _values (by invoking thisO) 
//and then add() using the c.iterator () , but that is relatively 
inefficient. 

_values = new Obj ect [c . size ()] ; 

Iterator it = c . iterator() ; 

for (int i = 0; it.hasNext (); i + +) 

{ 

set (i, it.next()) ; 


j * * 

* Constructs an <code>HLAobjectArray</code> containing the 
specified Object reference. 

* The Object must be of the element class or a descendant. 

* @param o an Object specifying <code>this</code>' value 
*/ 

public 

HLAobj ectArray(Obj ect o) 

{ 

this(); 
add (o) ; 


j * * 

* Creates an <code>HLAobjectArray</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAobjectArray</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAobj ectArray(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


633 



* * 


* Creates an <code>HLAobjectArray</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAobjectArray</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAobj ectArray</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAobj ectArray(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates an <code>HLAobjectArray</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAobj ectArray</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAobj ectArray(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Sets the size of the array to the specified value. 

* Reducing the size will result in the loss of the "chopped off" 
bytes. 

* @param newSize an int specifying the array's desired new size 

*/ 

protected void 
setSize(int newSize) 

{ 

modCount++; 

int objectsToCopy = _values.length; 

if (newSize < objectsToCopy) objectsToCopy = newSize; 

Object oldValues[] = _values; 

_values = new Object[newSize]; 

System.arraycopy(oldValues, 0, _values, 0, objectsToCopy); 


634 


DRDC Valcartier TR 2007-412 



//List interface implementation 


j k k 

* Inserts the specified element at the specified position in this 
array. 

* Elements must be compatible with the array's element data type. 

* @param index an int indicating the position before which to 
insert the element 

* @param element an Object to insert before index 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws ClassCastException if the class of the specified element 
prevents it from being added to this list 

* @throws NullPointerException if the specified element is null 
and this list does not support null elements 

* @throws IllegalArgumentException if some aspect of this element 
prevents it from being added to this list 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public void 
add(int index, 

Object element) 

{ 

if ((index > sizeO) || (index < 0)) throw new 
IndexOutOfBoundsException(Integer.toString(index)),- 

if (element == null) throw new NullPointerException () ,- 
// if (l(element instanceof <element class>)) 

// if (lgetElementClass() .isAssignableFrom(element.getClass() ) ) 
//same as: 

if (lgetElementClass().islnstance(element)) //true if element is 
of getElementClass or a sub-class 

// if (lgetElementClass().equals(element.getClass())) //true only 
if classes match exactly 

{ 

throw new ClassCastException(element.getClass().toString()),- 

} 

setSize (size() + 1); //increments modCount 

System.arraycopy(_values, index, _values, index + 1, size() - 
(index + 1) ) ; 

_values[index] = element; 


DRDC Valcartier TR 2007-412 


635 



* * 


* Inserts all of the elements in the specified collection into 
this array at the specified position. 

* @param index an int indicating before which element to insert 
the collection 

* @param c a Collection of elements to insert 

* @return a boolean which is true if this array changed as a 
result of this call 

* @throws IllegalArgumentException if some aspect of this element 
prevents it from being added to this list 

*/ 

public boolean 
addAll(int index, 

Collection c) 

//This implementation preserves the array if the method ends 
abnormally 
{ 

boolean modified = false,- 
//Presume abnormal termination 
boolean abnormal = true; 

//Preserve the old array and modCount 

Object oldValues[] = new Obj ect [size () ] ,- 

System. arraycopy (_values, 0, oldValues, 0, sizeO); 

int m = modCount; 

try 


modified = super.addAll(index, c); 
abnormal = false,- 

} 

finally 

{ 

if (abnormal) 

{ 

//If any of the add() failed, restore the old String and 

modCount 

_values = oldValues,- 
modCount = mu- 
modified = false,- 


return modified; //If one has a return within a finally, one 
gets a warning 


j * * 

* Removes all of the elements from this array. 

*/ 

public void 
clear () 

//This implementation is more efficient than AbstractList.clear() 

{ 

_values = new Object [0] ,- 

//Provide fail-fast iterators (and list iterators) 
modCount++ ,- 


636 


DRDC Valcartier TR 2007-412 



* * 


* Returns the element (as an Object) at the specified position in 
this array. 

* @param index an int specifying the element to return 

* @return the requested Object 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
get(int index) 

{ 

return values[index] ; 


j * * 

* Removes the element at the specified position in this array and 
returns it. 

* @param index an int indicating the position from which to remove 
the element 

* @return the element that was removed from the list 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws IndexOutOfBoundsException if <code>index</code> is 
negative or larger than <code>size()</code> 

*/ 

public Object 
remove(int index) 

{ 

if ((index > sizeO) || (index < 0)) throw new 
IndexOutOfBoundsException(Integer.toString(index)); 

Object o = get(index); 

System.arraycopy(_values, index + 1, _values, index, size() - 
(index + 1)); 

setSize (size() - 1); //increments modCount 

return o; 


DRDC Valcartier TR 2007-412 


637 



* * 


* Replaces the element at the specified position in this array 
with the specified element. 

* The element must be compatible with the element class. 

* @param index an int specifying the index of the element to 
replace 

* @param element the Object to use in replacing the element 

* @return the element previously at the specified position 

* @throws UnsupportedOperationException if this method is not 
supported by this list 

* @throws ClassCastException if the class of the specified element 
prevents it from being added to this list 

* @throws NullPointerException if the specified element is null 
and this list does not support null elements 

* @throws IllegalArgumentException if some aspect of the specified 
element prevents it from being added to this list 

* @throws IndexOutOfBoundsException if the index is outside the 
[0..size() [ range 

*/ 

public Object 
set (int index, 

Object element) 

{ 

if ((index > sizeO) || (index < 0)) throw new 
IndexOutOfBoundsException(Integer.toString(index)); 

if (element == null) throw new NullPointerException(); 

// if (l (element instanceof <element class>)) 

// if (lgetElementClass() .IsAssignableFrom(element.getClass() ) ) 
//same as: 

if (lgetElementClass().islnstance(element)) //true if element is 
of getElementClass or a sub-class 

// if (JgetElementClass().equals(element.getClass())) //true only 
if classes match exactly 
{ 

throw new ClassCastException(element.getClass().toString()); 

} 

Object o = get(index); 

_values[index] = element; 

//Note that set() does not modify the array <i>structurally</i> 
return o; 


j * * 

* Returns the number of elements in this array. 

* @return an int specifying the number of elements in this array 

*/ 

public int 
size () 

{ 

return _values.length; 


638 


DRDC Valcartier TR 2007-412 



//HLAdatatype interface implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* <p> 

* As a general rule, Variant Records [HLAvariantRecord], Dynamic 
Arrays [HLAvariableArray], and any 

* Fixed Arrays [HLAfixedArray] or Fixed Records [HLAfixedRecord] 
containing either of these first two 

* cannot have a constant encodedLength. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public int 
encodedLength() 

{ 

//If the element has a fixed size, we can predict the encoded 

size,- 

//such arrays should override this implementation 
HLAdatatype element ,- 

//Encoding starts with the element count 
int theLength = HLAinteger32BE.encodedLength; 
for (int i = 0 ; i < size(); i++) 

{ 

//Each element is encoded after being aligned to its 
octetBoundary 

element = (HLAdatatype) get (i) ,- 

while ((theLength % element.octetBoundary()) != 0) 

theLength++ ,- 

theLength += element. encodedLength () ,- 
} //for 

//Note that the last element won't be padded 
return theLength,- 


DRDC Valcartier TR 2007-412 


639 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* For dynamic arrays, octet boundary is thus the largest of the 
count (an HLAinteger32BE) and the element. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

//If "this" has a static octetBoundary field, use it 
Obj ect o = getThisClassField (this . get Class () , " octetBoundary") ,- 
if (o l= null) return ((Integer)o).intValue(); 
int cw = HLAinteger32BE. octetBoundary,- //element counter's 
octetBoundary 

int ew = 0; 

//Dynamically compare with the element octetBoundary 
o = getThisClassField (getElementClass () , " octetBoundary") ,- 
if (o l= null) 

{ 

ew = ((Integer) o) . intValue () ,- 
} else { 

//Element class did not have a static octetBoundary 
//Must needs invoke an element instance's octetBoundary 
method instead 

if (size () > 0) 

{ 

//Use the first element 
o = get (0) ,- 
} else { 

//Construct a throwaway default element 
try 


o = getElementClass () . newlnstance () ,- 
} catch (Exception e) { //InstantiationException 
IllegalAccessException 

//Give upl 
return cw,- 


ew = ( (HLAdatatype) o) . octetBoundary () ,- 

} 

return (ew > cw) ? ew : cw,- 


640 


DRDC Valcartier TR 2007-412 



//HLAarraydatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

// return HLAdatatype.class; //HLAdatatype is an interface, so it 
has no constructor --hence decode fails 
return HLAnull.class,- 


//Supporting classes and methods 

j * * 

* Returns the specified (static) field's value of the specified 
Class as an Object. 

* @param aClass the Class whose static field is looked up 

* @param fieldName a String specifying the field's name 

* @return the requested field value, as an Object (null in case of 
failure) 

*/ 

private Object 

getThisClassField(Class aClass, String fieldName) 

{ 

try { 

return aClass.getField (fieldName) .get (null) ,- 
} catch (Exception e) { //NoSuchFieldException, 
IllegalAccessException 
return null; 


//end HLAobj ectArray 


DRDC Valcartier TR 2007-412 


641 



The MOM array datatypes descend from HLAunicodeString 

(HLAtransportationName), HLAopaqueData (HLAhandle, HLAlogicalTime, and 
HLAtimelnterval), or HLAobj ectArray (the remaining seven). The first four 
simply declare constructors and do nothing else. The last seven additionally 
override the getElementclass method (HLAobj ectArray does the rest). 


// File: HLAtransportationName.java 
package ca.go.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe transportation name (Unicode string) variable array data 
type. 

* It is essentially identical to <code>HLAunicodeString</code> 
elements, 

* with an added convenience constructor. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAtransportationName 

extends HLAunicodeString 

{ 

j * * 

* Constructs a <code>HLAtransportationName</code> of default value 
(empty Unicode string). 

*/ 

public 

HLAtransportationName() 

{ 

super(); 


j * * 

* Constructs a <code>HLAtransportationName</code> from the 
specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
Unicode characters. 

* @param c a Collection specifying <code>this</code>' value 

* @throws IllegalArgumentException if value isn't Unicode 

*/ 

public 

HLAtransportationName(Collection c) 
throws IllegalArgumentException 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


642 


DRDC Valcartier TR 2007-412 



* * 


* Constructs a <code>HLAtransportationName</code> from the 
specified String value. 

* An exception occurs if any part of value String is not Unicode. 

* @param value a String specifying <code>this</code>' value 

* @throws IllegalArgumentException if value isn't Unicode 

*/ 

public 

HLAtransportationName(String value) 
throws IllegalArgumentException 

{ 

super(value); 


j * * 

* Constructs a <code>HLAtransportationName</code> from the 
specified Object. 

* @param o an Object whose toStringO specifies <code>this</code> 
*/ 

public 

HLAtransportationName(Object o) 

{ 

super(o) ; 


j * * 

* Creates a <code>HLAtransportationName</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAtransportationName</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtransportationName(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


DRDC Valcartier TR 2007-412 


643 



* * 


* Creates a <code>HLAtransportationName</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAtransportationName</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAunicodeString</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtransportationName(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


j k k 

* Creates a <code>HLAtransportationName</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAtransportationName</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAtransportationName(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super (byteWrapper) ,- 


//end HLAtransportationName 


644 


DRDC Valcartier TR 2007-412 



// File: HLAhandle.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.*; //For CouldNotDecode and the various handle 
types 

import j ava.util.Collection; 

//import j ava.util.Iterator; 

j * * 

* Type-safe variable byte array data type, used to store various HLA 
handle types. 

* It is essentially identical to HLAopaqueData, with added 
convenience constructors for 

* AttributeHandle, DimensionHandle, FederateHandle, 

InteractionClassHandle, Obj ectClassHandle, 

* ObjectlnstanceHandle and ParameterHandle but not 
MessageRetractionHandle and RegionHandle, 

* which lack the encodedLength and encode methods. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAhandle 

extends HLAopaqueData 

{ 

j * * 

* Constructs an empty <code>HLAhandle</code>. 

*/ 

public 
HLAhandle() 

{ 

super(); 


j * * 

* Constructs an <code>HLAhandle</code> from a Collection of 
HLAbyte. 

* @param c a Collection of HLAbyte objects 
*/ 

public 

HLAhandle(Collection c) 

{ 

super(c); 


DRDC Valcartier TR 2007-412 


645 



* * 


* Constructs an <code>HLAhandle</code> containing the specified 
byte value. 

* @param value a byte specifying <code>this</code>' value 
*/ 

public 

HLAhandle(byte value) 

{ 

super(value); 


j * * 

* Creates an <code>HLAhandle</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAhandle</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Creates an <code>HLAhandle</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAhandle</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAhandle</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


646 


DRDC Valcartier TR 2007-412 



* * 


* Creates an <code>HLAhandle</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>HLAhandle</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAhandle(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper) ; 


j * * 

* Constructs an <code>HLAhandle</code> containing the specified 
AttributeHandle. 

* @param value an AttributeHandle specifying <code>this</code>' 
value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(AttributeHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte[value.encodedLength()] ; 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0)); 


j * * 

* Constructs an <code>HLAhandle</code> containing the specified 
DimensionHandle. 

* @param value a DimensionHandle specifying <code>this</code>' 
value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(DimensionHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte[value.encodedLength()] ; 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0)); 


DRDC Valcartier TR 2007-412 


647 



* * 


* Constructs an <code>HLAhandle</code> containing the specified 
FederateHandle. 

* @param value a FederateHandle specifying <code>this</code>' 
value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(FederateHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte [value . encodedLength ()] ,- 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0)); 


j * * 

* Constructs an <code>HLAhandle</code> containing the specified 
InteractionClassHandle. 

* @param value an InteractionClassHandle specifying 
<code>this</code>' value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(InteractionClassHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte [value . encodedLength ()] ,- 

value.encode(buffer, 0) ; 

decode (new ByteWrapper (buffer, 0) ) ,- 


j * * 

* Constructs an <code>HLAhandle</code> containing the specified 
Obj ectClassHandle. 

* @param value an ObjectClassHandle specifying <code>this</code>' 
value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(Obj ectClassHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte [value . encodedLength ()] ,- 

value . encode (buffer, 0) ,- 

decode (new ByteWrapper (buffer, 0) ) ,- 


648 


DRDC Valcartier TR 2007-412 



* * 


* Constructs an <code>HLAhandle</code> containing the specified 
Obj ectlnstanceHandle. 

* @param value an ObjectlnstanceHandle specifying 
<code>this</code>' value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(ObjectlnstanceHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte[value.encodedLength()] ; 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0)); 


j * * 

* Constructs an <code>HLAhandle</code> containing the specified 
ParameterHandle. 

* @param value a ParameterHandle specifying <code>this</code>' 
value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandle(ParameterHandle value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte[value.encodedLength()] ; 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0)); 


//end HLAhandle 


DRDC Valcartier TR 2007-412 


649 



// File: HLAlogicalTime.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.*; //For CouldNotDecode and the various handle 
types 

import j ava.util.Collection; 

//import j ava.util.Iterator; 

j * * 

* Type-safe variable byte array data type, used to store a logical 
time. 

* It is essentially identical to HLAopaqueData, with an added 
convenience constructor for LogicalTime. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 
*/ 

public class 
HLAlogicalTime 

extends HLAopaqueData 

{ 

/** Octet boundary of this class. */ 

// public final static int 

// octetBoundary = HLAinteger32BE.octetBoundary; 

j * * 

* Constructs an empty <code>HLAlogicalTime</code>. 

*/ 

public 

HLAlogicalTime() 

{ 

super(); 


j * * 

* Constructs an <code>HLAlogicalTime</code> from a Collection of 
HLAbyte. 

* @param c a Collection of HLAbyte objects 
*/ 

public 

HLAlogicalTime(Collection c) 

{ 

super(c); 


j * * 

* Constructs an <code>HLAlogicalTime</code> containing the 
specified byte value. 

* @param value a byte specifying <code>this</code>' value 
*/ 

public 

HLAlogicalTime (byte value) 

{ 

super(value); 


650 


DRDC Valcartier TR 2007-412 



* * 


* Creates an <code>HLAlogicalTime</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAlogicalTime</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAlogicalTime(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Creates an <code>HLAlogicalTime</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAlogicalTime</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAlogicalTime</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAlogicalTime(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


j * * 

* Creates an <code>HLAlogicalTime</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAlogicalTime</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAlogicalTime(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


651 



* * 


* Constructs an <code>HLAlogicalTime</code> containing the 
specified LogicalTime. 

* @param value a LogicalTime specifying <code>this</code>' value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAlogicalTime(LogicalTime value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte[value.encodedLength()]; 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0) ) ; 


//end HLAlogicalTime 


652 


DRDC Valcartier TR 2007-412 



// File: HLAtimelnterval.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.*; //For CouldNotDecode and the various handle 
types 

import j ava.util.Collection; 

//import j ava.util.Iterator; 

j * * 

* Type-safe variable byte array data type, used to store a logical 
time interval. 

* It is essentially identical to HLAopaqueData, with an added 
convenience constructor for LogicalTimelnterval. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 
*/ 

public class 
HLAtimelnterval 

extends HLAopaqueData 

{ 

/** Octet boundary of this class. */ 

// public final static int 

// octetBoundary = HLAinteger32BE.octetBoundary; 

j * * 

* Constructs an empty <code>HLAtimeInterval</code>. 

*/ 

public 

HLAtimelnterval() 

{ 

super(); 


j * * 

* Constructs an <code>HLAtimeInterval</code> from a Collection of 
HLAbyte. 

* @param c a Collection of HLAbyte objects 
*/ 

public 

HLAtimelnterval(Collection c) 

{ 

super(c); 


j * * 

* Constructs an <code>HLAtimeInterval</code> containing the 
specified byte value. 

* @param value a byte specifying <code>this</code>' value 
*/ 

public 

HLAtimelnterval (byte value) 

{ 

super(value); 


DRDC Valcartier TR 2007-412 


653 



* * 


* Creates an <code>HLAtimeInterval</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAtimeInterval</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtimelnterval(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Creates an <code>HLAtimeInterval</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAtimeInterval</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAtimeInterval</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtimelnterval(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


j * * 

* Creates an <code>HLAtimeInterval</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAtimeInterval</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAtimelnterval(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super (byteWrapper) ,- 


654 


DRDC Valcartier TR 2007-412 



* * 


* Constructs an <code>HLAtimeInterval</code> containing the 
specified LogicalTimelnterval. 

* @param value a LogicalTimelnterval specifying <code>this</code>' 
value 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAtimelnterval(LogicalTimelnterval value) 
throws CouldNotDecode 

{ 

this ( ) ; 

byte[] buffer = new byte[value.encodedLength()] ; 

value.encode(buffer, 0) ; 

decode(new ByteWrapper(buffer, 0)); 


//end HLAtimelnterval 


DRDC Valcartier TR 2007-412 


655 



// File: HLAargumentList.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe MOM HLAargumentList variable array data type. 

* It uses <code>HLAunicodeString</code> elements. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAargumentList 

extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

j * * 

* Constructs <code>this</code> of default value (empty array). 
*/ 

public 

HLAargumentList() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects. 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAargumentList(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


656 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAargumentList (Object o) 

{ 

super(o); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAargumentList(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAargumentList(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


DRDC Valcartier TR 2007-412 


657 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAargumentList(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper); 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAunicodestring.class; 


//end HLAargumentList 


658 


DRDC Valcartier TR 2007-412 



// File: HLAhandleList.java 

package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

//import j ava.util.Iterator; 

j * * 

* Type-safe MOM HLAhandleList variable array data type. 

* It uses <code>HLAhandle</code> elements (themselves HLAbyte 
variable arrays). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.2 

*/ 

public class 
HLAhandleList 

extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

j * * 

* Constructs <code>this</code> of default value (empty array). 
*/ 

public 

HLAhandleLis t() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects . 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAhandleList(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


DRDC Valcartier TR 2007-412 


659 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAhandleList(Object o) 

{ 

super(o); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandleList(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAhandleList(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


660 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAhandleList(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper) ; 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAhandle.class; 


//end HLAhandleList 


DRDC Valcartier TR 2007-412 


661 



// File: HLAinteractionCounts.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe MOM HLAinteractionCounts variable array data type. 

* It uses <code>HLAinteractionCount</code> elements (themselves fixed 
records). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAinteractionCounts 

extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

//Fields are HLAhandle and HLAcount (both HLAinteger32BE) 

j * * 

* Constructs <code>this</code> of default value (empty array). 

*/ 

public 

HLAinteractionCounts() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects. 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAinteractionCounts(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


662 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAinteractionCounts(Object o) 

{ 

super(o); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionCounts(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionCounts(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


DRDC Valcartier TR 2007-412 


663 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteractionCounts(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper); 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAinteractionCount.class; 


//end HLAinteractionCounts 


664 


DRDC Valcartier TR 2007-412 



// File: HLAinteractionSubList.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe MOM HLAinteractionSubList variable array data type. 

* It uses <code>HLAinteractionSubscription</code> elements 
(themselves fixed records). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAinteractionSubList 

extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

//Fields are HLAhandle (HLAinteger32BE) and HLAboolean (likewise) 

j * * 

* Constructs <code>this</code> of default value (empty array). 

*/ 

public 

HLAinteractionSubList() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects . 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAinteractionSubList(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


DRDC Valcartier TR 2007-412 


665 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAinteractionSubList(Object o) 

{ 

super(o) ; 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionSubList(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionSubList(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


666 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteractionSubList(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper) ; 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAinteractionSubscription.class; 


//end HLAinteractionSubList 


DRDC Valcartier TR 2007-412 


667 



// File: HLAobj ectClassBasedCounts.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe MOM HLAobjectClassBasedCounts variable array data type. 

* It uses <code>HLAobjectClassBasedCount</code> elements (themselves 
fixed records). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

HLAobj ectClassBasedCounts 
extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

//Fields are HLAhandle and HLAcount (both HLAinteger32BE) 

j * * 

* Constructs <code>this</code> of default value (empty array). 

*/ 

public 

HLAobjectClassBasedCounts() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects. 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAobjectClassBasedCounts(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


668 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAobj ectClassBasedCounts(Object o) 

{ 

super(o); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAobj ectClassBasedCounts(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAobj ectClassBasedCounts(byte[] buffer, 

int offset) 

throws CouldNotDecode 

{ 

super(buffer, offset); 


DRDC Valcartier TR 2007-412 


669 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAobj ectClassBasedCounts(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper); 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAobj ectClassBasedCount.class; 


//end HLAobj ectClassBasedCounts 


670 


DRDC Valcartier TR 2007-412 



// File: HLAsyncPointFederateList.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe MOM HLAsyncPointFederateList variable array data type. 

* It uses <code>HLAsyncPointFederate</code> elements (themselves 
fixed records). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

HLAsyncPointFederateList 
extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

//Fields are HLAhandle (HLAinteger32BE) and HLAsyncPointStatus 
(HLAinteger32BE enumerated) 

j * * 

* Constructs <code>this</code> of default value (empty array). 
*/ 

public 

HLAsyncPointFederateList() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects . 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAsyncPointFederateList(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


DRDC Valcartier TR 2007-412 


671 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAsyncPointFederateList(Object o) 

{ 

super(o); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointFederateList(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointFederateList(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


672 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAsyncPointFederateList(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper) ; 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAsyncPointFederate.class; 


//end HLAsyncPointFederateList 


DRDC Valcartier TR 2007-412 


673 



// File: HLAsyncPointList.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 
import j ava.util.Collection; 

j * * 

* Type-safe MOM HLAsyncPointList variable array data type. 

* It uses <code>HLAunicodeString</code> elements. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAsyncPointList 

extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary; 

j * * 

* Constructs <code>this</code> of default value (empty array). 
*/ 

public 

HLAsyncPointList() 

{ 

super(); 


j * * 

* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects. 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

HLAsyncPointList(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


674 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

HLAsyncPointList(Object o) 

{ 

super(o); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointList(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointList(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


DRDC Valcartier TR 2007-412 


675 



* * 


* Constructs <code>this</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAsyncPointList(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super(byteWrapper); 


//HLAdatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return HLAunicodestring.class; 


//end HLAsyncPointList 


676 


DRDC Valcartier TR 2007-412 



The HLAf ixedrecorddatatype interface combines HLAdatatype with Java’s 
Map. The HLAf ixedRecordType abstract class extends Java’s AbstractMap. 


// File: HLAfixedrecorddatatype.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import j ava.util.Iterator; 

j * * 

* Interface implemented by the various HLA fixed record data types. 

* <p> 

* In addition to this interface, the HLA fixed record data type 
classes are expected to supply: 

* <ul > 

* <li> Constructors (default and specified-value)</li> 

* <li> Constructor (byte[] buffer) throws CouldNotDecode</li> 

* <li> Constructor (byte[] buffer, int offset) throws 
CouldNotDecode</li> 

* <li> Constructor (ByteWrapper byteWrapper) throws 
CouldNotDecode</li> 

* <li> java.lang.Object methods toStringO; equals (Object 
otherObject) and hashCode()</li> 

* <li> Class-specific extensions to get and set the value as a basic 
java data type (int, boolean, etc.)</li> 

* </ul> 

* A fixed record is a finite unvarying sequence of fields (at the 
class level). 

* Each fixed record field has a Name and a Class. 

* We'll need two Iterators over the fields (one for the names, 
another for the classes), get/set methods 

* indexed by Name for each field. 

* The octetBoundary is static for fixed records, being equal to the 
largest octetBoundary of the record's fields. 

* The encodedLength will obviously depend on the total encodedLengths 
of the various fields 

* (some of which may be dynamic arrays, for example). 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface 
HLAfixedrecorddatatype 
extends j ava.util.Map, 

j ava.io.Serializable, 
j ava.lang.Cloneable, 

HLAdatatype 

{ 

j * * 

* Returns an Iterator over the record's fields (as HLAdatatypes). 

* @return an Iterator over the record's fields (as HLAdatatypes) 

*/ 

Iterator 
iterator () ,- 


DRDC Valcartier TR 2007-412 


677 



* * 


* Returns an Iterator over the record's fields' names (as 
Strings). 

* @return an Iterator over the record's fields' names (as Strings) 
*/ 

Iterator 
namelterator(); 

} 

//end HLAfixedrecorddatatype 


678 


DRDC Valcartier TR 2007-412 



// File: HLAfixedRecordlterator.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import j ava. util. Iterator,- 

import j ava.util.NoSuchElementException,- 

import j ava.util.ArrayList,- 

import j ava.lang.reflect.Field; 

j * * 

* Iterator implementation for HLA fixed record types. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAfixedRecordlterator 
implements Iterator 

{ 

j * * 

* The enumerators over which to iterate. 

*/ 

private Object 
enumerators[]; 

j * * 

* Index of enumerator to be returned by subsequent call to next(). 
*/ 

private int 
cursor; 

j * * 

* Constructs the <code>Iterator</code> from an instance reference. 

* If the <code>boolean asStrings</code> is false, the 
<code>Iterator</code> will enumerate the <code>Ob j ect </code>s ,- 

* otherwise it will enumerate the field names as 
<code>String</code>s. 

* Note that unlike HLAenumeratedlterator, the argument must be an 
instance (instead of a Class reference) 

* because the actual field values must be enumerated. 

* <p> 

* Examples: <code>Iterator itr = new HLAfixedRecordlterator(this, 
false);</code> 

* <code>Iterator nameltr = new HLAfixedRecordlterator(this, 
true);</code> 

* <p> 

* @param thelnstance the instance whose public fields are to be 
enumerated 

* @param asStrings a boolean which is false if the enumeration 
should supply Objects, true if it should supply the field names (as 
Strings) instead 

* @throws ClassCastException if thelnstance doesn't implement the 
HLAfixedrecorddatatype interface (or an IllegalAccessException 
occurred internally) 

*/ 


DRDC Valcartier TR 2007-412 


679 



public 

HLAfixedRecordlterator(Object theInstance, boolean asStrings) 
throws ClassCastException 

{ 

if (lHLAfixedrecorddatatype.class.isInstance(theInstance)) throw 
new ClassCastException(thelnstance.getclass().toString()); 
cursor = 0; 

ArrayList al = new ArrayListO; 

//Obtain the object's accessible public fields 

Field[] theFields = thelnstance.getclass().getFieldsO; 

for (int i = 0; i < theFields.length; i++) 

{ 

//Skip fields which do not implement the HLAdatatype 

interface 

//To simplify the constructor, the IllegalAccessException 
that this may throw is wrapped in a ClassCastException 
try 


if 

(HLAdatatype.class.isInstance(theFields[i].get(thelnstance))) 

{ 

if (asStrings) 

{ 

al. add (theFields [ i] .getName () ) ,- 

} 

else 

{ 

al. add (theFields [ i] .get (thelnstance) ) ,- 


} catch (IllegalAccessException e) 

{ 

ClassCastException cce = new 
ClassCastException(e.getMessage() ) ; 

throw (ClassCastException) cce . initCause (e) ,- 


al. trimToSize () ,- 
enumerators = al. toArray () ,- 


680 


DRDC Valcartier TR 2007-412 



* * 


* Constructs the <code>Iterator</code> from an instance reference, 
returning Map.Entry elements. 

* <p> 

* HLAnullFixedRecord.entrySet().iterator() uses this constructor. 

* @param thelnstance the instance whose public fields are to be 
enumerated 

* @throws ClassCastException if thelnstance doesn't implement the 
HLAfixedrecorddatatype interface (or an IllegalAccessException 
occurred internally) 

*/ 

public 

HLAfixedRecordlterator(Obj ect thelnstance) 
throws ClassCastException 

{ 

if (lHLAfixedrecorddatatype.class.isInstance(thelnstance)) throw 
new ClassCastException(thelnstance.getClass() .toString ()) ; 
cursor = 0; 

ArrayList al = new ArrayListO; 

//Obtain the object's accessible public fields 

Field[] theFields = thelnstance.getClass().getFields(),- 

for (int i = 0; i < theFields.length; i++) 

{ 

//Skip fields which do not implement the HLAdatatype 

interface 

//To simplify the constructor, the IllegalAccessException 
that this may throw is wrapped in a ClassCastException 
try 


if 

(HLAdatatype.class.isInstance(theFields[i].get(thelnstance))) 

{ 

al.add (new 

HLAfixedRecordlterator.HLAfixedRecordMapEntry(theFields[i].getName() 
(HLAf ixedrecorddatatype) thelnstance) ) ,- 
} 

} catch (IllegalAccessException e) 

{ 

ClassCastException cce = new 
ClassCastException(e.getMessage()); 

throw (ClassCastException) cce . initCause (e) ,- 


al. trimToSize () ,- 
enumerators = al. toArray () ,- 


DRDC Valcartier TR 2007-412 


681 



//j ava.util.Map.Entry implementation 

j * * 

* The Map record class. 

* We enforce the expected types in the constructor and use the 
underlying Object as the backing Map. 

*/ 

static class 

HLAfIxedRecordMapEntry 

implements j ava.util.Map.Entry 

{ 

//The name of the field 

String 

key ; 

//The instance whose field it is (note that the field value 
isn't stored) 

HLAfixedrecorddatatype 
instance; 

j * * 

* Constructs a new Map.Entry from the specified String key and 
HLAfixedrecorddatatype instance. 

* @param key a String specifying the name of the instance's 

field 

* @param instance an HLAfixedrecorddatatype interface whose 
field is being mapped 

* @throws IllegalArgumentException if the key or instance is 
<code>null</code> 

*/ 

public 

HLAfixedRecordMapEntry(String key, 

HLAfixedrecorddatatype instance) 
throws IllegalArgumentException 

{ 

if ((key == null) || (instance == null)) throw new 
IllegalArgumentException(); 

this.key = key; 

this.instance = instance; 


j * * 

* Returns the key (a String field name) corresponding to this 

entry. 

* @return the key corresponding to this entry 
*/ 

public Object 
getKey() 

{ 

return (Object)key; 


682 


DRDC Valcartier TR 2007-412 



* * 


* Returns the value (an HLAfixedrecorddatatype instance) 
corresponding to this entry. 

* We return the actual value stored in the backing Object. 

* Because Map.Entry does not allow this method to throw any 
exceptions, 

* should one occur we return <code>null</code> instead. 

* @return the value corresponding to this entry (or 
<code>null</code> if an exception occurred internally) 

*/ 

public Object 
getValue() 

{ 

try 


return instance.getclass().getField(key).get(instance); 

} 

catch (Exception e) 

{ 

return null; 


DRDC Valcartier TR 2007-412 


683 



* Replaces the value corresponding to this entry with the 
specified value. 

* Writes through to the Map. 

* The behaviour of this call is undefined if the mapping has 
already been removed from the map 

* (by the iterator's remove operation). 

* @param value an Object (HLAfixedrecorddatatype instance) to 
store in this entry 

* @return the old value that was stored in this entry 

* @throws UnsupportedOperationException if the operation is not 
supported by the backing Map 

* @throws ClassCastException if the class of the specified 
value prevents it from being stored in the backing Map 

* @throws IllegalArgumentException if some aspect of this value 
prevents it from being stored in the backing Map 

* @throws NullPointerException if the backing Map does not 
permit null values and the specified value is null 

*/ 

public Object 
setValue(Obj ect value) 

{ 

//Likewise, here we set the actual value, not the stored 
instance reference 

if (value == null) throw new NullPointerException () ,- 

//We wrap the other exceptions in an IllegalArgumentException 

try 


Object oldValue = 

instance. getclass () .getField (key) . get (instance) ,- 

instance. getclass () .getField (key) .set (instance, value) ,- 
return oldValue,- 

} 

catch (Exception e) //NoSuchFieldException, 
IllegalAccessException 
{ 

IllegalArgumentException iae = new 
IllegalArgumentException(e.getMessage()); 

throw (IllegalArgumentException) iae . initCause (e) ,- 


684 


DRDC Valcartier TR 2007-412 



* * 


* Returns true iff <code>this</code> and 
<code>otherObject</code> represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied 

<code>otherObject</code> is of the same type as <code>this</code> and 
has the same value 

* @see Object#hashCode Object.hashCode () 

* @see java.util.Hashtable Hashtable 

*/ 

public boolean 
equals(Object o) 

{ 

if (J(o instanceof java.util.Map.Entry)) return false; 
java.util.Map.Entry e = (java.util.Map.Entry)o; 
return key.equals(e.getKey()) && 
getValue().equals(e.getValue()); 


j * * 

* Returns a hash code for <code>this</code>; two objects for 
which <code>equals()</code> is <code>true</code> should yield the same 
hash code. 

* @return an <code>int</code> hash code 

* @see Obj ect#equals(j ava.lang.Obj ect) 

Object.equals(j ava.lang.Object) 

* @see java.util.Hashtable Hashtable 

*/ 

public int 
hashCode() 

{ 

return key.hashCode() ^ getValue().hashCode() ; //bitwise XOR 


j * * 

* Returns a <code>String</code> representation of 
<code>this</code>. 

* @return a {@link java.lang.String} reflecting 
<code>this</code> value 

*/ 

public String 
toString () 

{ 

return key + "=" + getValue().toString(); 


DRDC Valcartier TR 2007-412 


685 



//Iterator implementation 


j k k 

* Returns <code>true</code> if the iteration has more elements. 

* In other words, returns <code>true</code> if <code>next()</code> 
would return an element rather than throwing an exception. 

* @return a boolean which is <code>true</code> if the iterator has 
more elements 

*/ 

public boolean 
hasNext () 

{ 

return cursor < enumerators.length; 


j k k 

* Returns the next element in the iteration. 

* @return the next element in the iteration 

* @throws NoSuchElementException if the iteration has no more 
elements 

*/ 

public Object 
next () 

{ 

if (hasNext ()) return enumerators [cursor+ + ] ,- 
throw new NoSuchElementException(); 


j k k 

* Removes from the underlying collection the last element returned 
by the iterator (optional operation). 

* This method can be called only once per call to 
<code>next()</code>. 

* The behaviour of an <code>Iterator</code> is unspecified if the 
underlying collection is modified 

* while the iteration is in progress in any way other than by 
calling this method. 

* @throws UnsupportedOperationException if this operation is not 
supported by this Iterator 

* @throws IllegalStateException if <code>next()</code> has not yet 
been called, or <code>remove()</code> has already been called since 
the last call to <code>next()</code>. 

*/ 

public void 
remove() 

{ 

throw new UnsupportedOperationException () ,- 


//end HLAfixedRecordlterator 


686 


DRDC Valcartier TR 2007-412 



// File: HLAfixedRecordType.java 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode,- 
import j ava. util. Set,- 
import j ava. util. Iterator,- 
import j ava. util. Abstract Set,- 
import j ava.lang.reflect.Field; 

j * * 

* Abstract implementation of the HLA fixed record type. 

* User-defined HLA fixed record types can be quickly defined as 
extensions of this class, 

* defining the public fields and the constructors --no other code 
needed. 

* Note that this class is field-less. 

* <p> 

* The <code>Map</code> is specified as mapping String keys 
(representing the field names) to their values 
(<code>HLAdatatype</code> implementations). 

* The map <code>size()</code> will be unchanging, since the record 
will always have the same fields in the same order. 

* Values may not be <code>null</code> since they all must be HLA data 
types (i.e. all references will exist). 

* <p> 

* The <code>put</code> method behaves exactly as direct access,- that 
is to say, 

* <code>put (" f ieldName' 1 , someObj ect) </code> is equivalent to 
<code>fieldName = someObject</code>. 

* The <code>remove</code> method throws an 
<code>UnsupportedOperationException</code>. 

* <p> 

* The helper class <code>HLAfixedRecordIterator</code> is used to 
generate the various <code>Iterator</code>s. 

* The <code>Map</code> interface recommends supplying a void 
constructor and a <code>Map</code> constructor. 

* See below for constructor templates. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAfixedRecordType 

extends j ava.util.AbstractMap 
implements HLAfixedrecorddatatype 

{ 

//If at all possible, it is strongly recommended that the concrete 
class declare this field: 

// public static final int 
// octetBoundary = <whatever>; 

//The fixed record's fields should be declared here, in order. 
//Only those accessible public fields which implement the 
HLAdatatype interface will be considered. 

//This abstract class declares no such fields. 


DRDC Valcartier TR 2007-412 


687 



j k k 

* Constructs a <code>HLAfixedRecordType</code> of default values. 
*/ 

// public 

// HLAfIxedRecordType() 

// throws CouldNotDecode 

// { 

// try 


// initializeFields() ,- 

// } 

// catch (InstantiationException e) 

// { 

// CouldNotDecode end = new CouldNotDecode (e.getMessage ()) ,- 

// throw (CouldNotDecode)end.initCause(e); 


j k k 

* Creates a <code>HLAfixedRecordType</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAfixedRecordType</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

// public 

// HLAfIxedRecordType(byte[] buffer) 

// throws CouldNotDecode 

// { 

// this(buffer, 0); 


j k k 

* Creates a <code>HLAfixedRecordType</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAfixedRecordType</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAfIxedRecordType</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

// public 

// HLAfIxedRecordType(byte[] buffer, 

// int offset) 

// throws CouldNotDecode 

// { 

// this(new ByteWrapper(buffer, offset)); 

// } 


688 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAfixedRecordType</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 

<code>HLAfixedRecordType</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

// public 

// HLAfIxedRecordType(ByteWrapper byteWrapper) 

// throws CouldNotDecode 

// { 

// this () ; 

// decode(byteWrapper); 


j * * 

* Creates a <code>HLAfixedRecordType</code> from the provided 
<code>Map</code>. 

* @param theMap the <code>Map</code> representation of the 
<code>HLAfixedRecordType</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

// public 

// HLAfIxedRecordType(java.util.Map theMap) 
throws CouldNotDecode 

this () ; 

//Wrap all exceptions as CouldNotDecode 
try { putAll(theMap); } 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 



DRDC Valcartier TR 2007-412 


689 



* * 


* Calls the void constructor on each of the HLAdatatype fields. 

* @throws InstantiationException if the class to instantiate is 
abstract or an interface (or some other problem occurs) 

*/ 

protected void 
initializeFields () 

throws InstantiationException 

{ 

//Obtain the object's accessible public fields 
Field[] theFields = this . getClass () . getFields () ,- 
for (int i = 0; i < theFields.length; i++) 

{ 

//We're looking for fields which implement the HLAdatatype 

interface 

// I first thought of scanning getlnterfaces() for 
HLAdatatype.class, but 

// that method only returns the interfaces * immediately* 
implemented by the 

// class --it does not fetch the inherited interfaces! 
if 

(HLAdatatype.class.IsAssignableFrom(theFields[i] .getType())) 

{ 

//To simplify exception handling, we'll wrap the 
IllegalAccessException in an InstantiationException 
try 


theFields [i] .set (this, 
theFields[i].getType().newlnstance()); 

} 

catch (IllegalAccessException e) 

{ 

InstantiationException ie = new 
InstantiationException(e.getMessage()); 

throw (InstantiationException) ie . initCause (e) ,- 


690 


DRDC Valcartier TR 2007-412 



//Map implementation 


//Map implementation: Modification Operations 

j * * 

* Associates the specified value with the specified key in this 
map (optional operation). 

* If the map previously contained a mapping for this key, the old 
value is replaced. 

* @param key the Object key with which the specified value is to 
be associated 

* @param value the Object value to be associated with the 
specified key 

* @return previous value associated with the specified key, or 

* <tt>null</tt> if there was no mapping for the key. 

* A <tt>null</tt> return can also indicate that the map 
previously associated 

* <tt>null</tt> with the specified key, if the 
implementation supports <tt>null</tt> values. 

* @throws UnsupportedOperationException if the operation is not 
supported by this map 

* @throws ClassCastException if the class of the specified key or 
value prevents it from being stored in this map 

* @throws IllegalArgumentException if some aspect of this key or 
value prevents it from being stored in this map 

* @throws NullPointerException if this map does not permit 
<tt>null</tt> keys or values, and the specified key or value is 
<tt>null</tt> 

*/ 

public Object 

put(Object key, Object value) 

{ 

try //We'll wrap the other exceptions in 
IllegalArgumentException 
{ 

Object o = this .getclass () .getField ( (String) key) .get (this) ,- 
this.getclass() .getField((String) key) .set (this, value); 
return o; 

} 

catch (Exception e) //NoSuchFieldException, 

IllegalAccessException 

{ 

IllegalArgumentException iae = new 
IllegalArgumentException(e.getMessage()); 

throw (IllegalArgumentException) iae . initCause (e) ,- 


DRDC Valcartier TR 2007-412 


691 



* * 


* Removes the mapping for this key from this map if present 
(optional operation). 

* Since the underlying Iterator does not allow remove(), neither 
does this implementation. 

* @param key the Object key whose mapping is to be removed from 
the map 

* @return the previous value associated with the specified key, or 

* <tt>null</tt> if there was no entry for the key. 

* A <tt>null</tt> return can also indicate that the map 
previously associated 

* <tt>null</tt> with the specified key, if the 
implementation supports <tt>null</tt> values. 

* @throws UnsupportedOperationException if the operation is not 
supported by this map 

*/ 

public Object 
remove(Obj ect key) 

{ 

throw new UnsupportedOperationException () ,- 


//Map implementation: Views 

j * * 

* This field is initialized to contain an instance of the Set the 
first time it is requested. 

* The view is stateless, so there's no reason to create more than 

one. 

*/ 

transient volatile Set entrySet = null; 

j * * 

* Returns a Set view of the mappings contained in this map. 

* Each element in this set is a Map.Entry. 

* The set is backed by the map, so changes to the map are 
reflected in the set, and vice-versa. 

* If the map is modified while an iteration over the set is in 
progress, the results of the iteration are undefined. 

* The set supports element removal, which removes the 
corresponding entry from the map, via the 

* <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, 

<tt>removeAll</tt>, <tt>retainAll</tt> and 

* <tt>clear</tt> operations. It does not support the <tt>add</tt> 
or <tt>addAll</tt> operations. 

* @return a Set view of the mappings contained in this map. 

*/ 

public Set 
entrySet() 

{ 

if (entrySet == null) 

{ 

//Most of the Set implementation is supplied by 
AbstractCollection and AbstractSet. 

//By default add(Object) throws 
UnsupportedOperationException, which is fine for our purpose. 


692 


DRDC Valcartier TR 2007-412 



entrySet = new AbstractSet() 

{ 

transient volatile boolean sizeKnown = false; 
transient volatile int size = 0; 

j * * 

* Returns an Iterator over the elements in this Set 

* The elements are returned in no particular order 

* unless this Set is an instance of some class that 
provides such a guarantee. 

* @return an Iterator over the elements in this Set 
*/ 

public Iterator 
iterator () 

{ 

//We're not allowed to throw anything here 
try 


return new 

HLAfixedRecordlterator(HLAfixedRecordType.this); 

} 

catch (ClassCastException iae) { return null; } 


//AbstractMap.size() defers to this method 

j * * 

* Returns the number of elements in this Set (its 

cardinality). 

* If this Set contains more than Integer.MAX_VALUE 
elements, returns Integer.MAX_VALUE. 

* @return the number of elements in this Set 

*/ 

public int 
size () 

{ 

//First time we're asked? 
if (lsizeKnown) 

{ 

Iterator i = iterator (); 
while (i.hasNext()) 

{ 

size++ ; 
i.next () ; 

} 

sizeKnown = true; 

} 

return size; 

} 

}; //end of anonymous inner class 

} 

return entrySet; 


DRDC Valcartier TR 2007-412 


693 



//HLAfixedrecorddatatype implementation 

j * * 

* Returns an Iterator over the record's fields (as HLAdatatypes). 

* @return an Iterator over the record's fields (as HLAdatatypes) 

*/ 

public Iterator 
iterator () 

{ 

//We're not allowed to throw anything here 
try 


return new HLAfixedRecordlterator (this, false); 

} 

catch (ClassCastException iae) { return null; } 


j * * 

* Returns an Iterator over the record's fields' names (as 
Strings). 

* @return an Iterator over the record's fields' names (as Strings) 
*/ 

public Iterator 
namelterator () 

{ 

//We're not allowed to throw anything here 
try 
{ 

return new HLAfixedRecordlterator (this, true); 

} 

catch (ClassCastException iae) { return null; } 


//j ava.lang.Obj ect methods 

//java.lang.Object.toString supplied by AbstractMap 


694 


DRDC Valcartier TR 2007-412 



//equals, as supplied by AbstractMap, isn't quite satisfactory as 
it does not ensure 

//the field sequences are the same, or that the other object 
descends from this class 
j * * 

* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode () 

* @see java.ut11.Hashtable Hashtable 
*/ 

public boolean 

equals (Object otherObject) 

{ 

if (this == otherObject) return true; 

//This form is more inheritable, and will ensure that 
otherObject is an instance of this' class 

if (l this.getClass().equals(otherObj ect.getClass())) return 

false,- 

//Iterate over the fields,- they should be in lock-step 
Iterator itr = iterator (); 

Iterator itrOther = 

( (HLAf IxedRecordType) otherObj ect) .iterator () ,- 

while (itr.hasNext() && itrOther.hasNext()) 

{ 

if (l itr .next () . equals (itrOther.next () ) ) return false; 

} 

return l (itr.hasNext () | | itrOther.hasNext () ) ,- 


//java.lang.Object.hashCode is supplied by AbstractMap 
//HLAdatatype interface implementation 

//Several of these methods are repeats from HLAbasicType (because 
we can't inherit from both it and AbstractMap) 


DRDC Valcartier TR 2007-412 


695 



* * 


* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 


HLAdatatype field; 
int theLength = 0; 
//Iterate over the fields 
Iterator itr = iterator(); 
while (itr.hasNext()) 


field = (HLAdatatype)itr.next() ; 

while ((theLength % field.octetBoundary()) != 0) theLength++; 

theLength += field.encodedLength(); 

} 

return theLength; 


j * * 

* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

Object o = getThisField("octetBoundary"); 
if (o l= null) return ((Integer)o).intValue(); 

int fieldBoundary; 
int theBoundary = 1; 

//Iterate over the fields 
Iterator itr = iterator(); 
while (itr.hasNext()) 

{ 

fieldBoundary = ((HLAdatatype)itr.next()).octetBoundary(); 
if (fieldBoundary > theBoundary) theBoundary = fieldBoundary; 

} 

return theBoundary; 


696 


DRDC Valcartier TR 2007-412 



* * 


* Encodes <code>this</code> into the <code>byte[]</code> at the 
specified <code>offset</code>. 

* @param buffer the <code>byte[]</code> into which to encode 
<code>this</code> 

* @param offset the offset into the <code>byte[]</code> at which 
to encode <code>this</code> 

* @return how many bytes were written to the buffer, including any 
prefix padding bytes 

*/ 

public int 

encode(byte[] buffer, 
int offset) 

{ 

return encode(new ByteWrapper(buffer, offset)) .pos () - offset; 


j * * 

* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 

//Iterate over the fields 
Iterator itr = iterator(); 
while (itr.hasNext()) 

( (HLAdatatype) itr . next () ) . encode (byteWrapper) ,- 
return byteWrapper,- 


j * * 

* Encodes <code>this</code> into a new <code>byte[]</code>. 

* @return a <code>byte[]</code> encoding <code>this</code> 
*/ 

public byte[] 
toByteArray() 

{ 

return encode (new ByteWrapper (encodedLength () ) ) . array () ,- 


DRDC Valcartier TR 2007-412 


697 



* * 


* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @return how many bytes were read from the <code>byte[]</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer) 

throws CouldNotDecode 

{ 

return decode(buffer, 0); 


j * * 

* Sets <code>this</code> value from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> <code>this</code> 
representation begins 

* @return where in the <code>buffer</code> <code>this</code> 
representation ends 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public int 

decode(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

try 


return decode(new ByteWrapper(buffer, offset)).pos(); 

} 

catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


698 


DRDC Valcartier TR 2007-412 



* * 


* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

byteWrapper.align(octetBoundary()); 

//Iterate over the fields 
Iterator itr = iterator(); 
while (itr.hasNext()) 

((HLAdatatype)itr.next()).decode(byteWrapper); 
return byteWrapper; 


//Cloneable implementation 


j * * 

* Creates and returns an independent copy of this object. 

* @return an independent copy of this Object 

* @throws CloneNotSupportedException if the object's class is not 
Cloneable or if the instance cannot be cloned 

*/ 

public Object 
clone () 

throws CloneNotSupportedException 

{ 

//The method inherited from AbstractMap does a shallow copy; 
//the fields will have been copied too, so the clone's fields 
//will hold references to the same objects as the original. 

try 


// return new HLAfixedRecordType(toByteArray()); 

return this.getClassO .getConstruetor(new Class[] { 

byte[].class } ).newlnstance(new Object[] { this.toByteArray() } ); 

} 

//Something is seriously wrong with the class if it can't encode 
and then decode itself... 

catch (Exception e) //CouldNotDecode 

{ 

CloneNotSupportedException ense = new 
CloneNotSupportedException(e.getMessage()); 

throw (CloneNotSupportedException)cnse.initCause(e) ; 


DRDC Valcartier TR 2007-412 


699 



//Supporting classes and methods 

j * * 

* Returns the specified (static) field's value as an Object. 

* This is just an instance-proxy for the various class fields. 

* @param fieldName a String specifying the field's name 

* @return the requested field, as an Object (null in case of 
failure) 

*/ 

private Object 

getThisField(String fieldName) 

{ 

try 

{ 

return this.getClassO .getField(fieldName) .get (null) ; 

} 

catch (Exception e) //NoSuchFieldException, 
IllegalAccessException 
{ 

return null; 


//end HLAfixedRecordType 


700 


DRDC Valcartier TR 2007-412 



The MOM’s fixed record types (HLAinteractionCount, 
HLAinteractionSubscription, HLAobjectClassBasedCount, and 
HLAsyncPointFederate) serve as demonstrations of the HLAf ixedRecordType 

design pattern. 


// File: HLAinteractionCount.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe MOM HLAinteractionCount fixed record data type. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAinteractionCount 

extends HLAfixedRecordType 

{ 

/** First field of <code>HLAinteractionCount</code>: an HLAhandle. 

*/ 

public HLAhandle HLAinteractionClass; 

/** Second field of <code>HLAinteractionCount</code>: an HLAcount. 

*/ 

public HLAcount HLAinteractionCount; 

j * * 

* Constructs <code>this</code> with default values. 

* @throws CouldNotDecode if an {@link InstantiationException} 
occurs 

*/ 

public 

HLAinteractionCount() 

throws CouldNotDecode 

{ 

//super() not called because super-class is abstract 
try 


initializeFields(); 

} 

catch (InstantiationException e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


DRDC Valcartier TR 2007-412 


701 



* * 


* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionCount(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ,- 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionCount(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

this (new ByteWrapper (buf f er, offset)),- 


j * * 

* Constructs <code>this</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteractionCount(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


702 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the provided <code>Map</code>. 

* @param theMap the <code>Map</code> representation of the 
<code>this</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

public 

HLAinteractionCount(j ava.util.Map theMap) 
throws CouldNotDecode 

{ 

this ( ) ; 
try 


putAll(theMap) ; 

} 

//Wrap all exceptions as CouldNotDecode 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


//end HLAinteractionCount 


DRDC Valcartier TR 2007-412 


703 



// File : HLAinteractionSubscription.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe MOM HLAinteractionSubscription fixed record type. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 

HLAinteractionSubscription 
extends HLAfixedRecordType 

{ 

/** First field. */ 

public HLAhandle HLAinteractionClass; 

/** Second field. */ 
public HLAboolean HLAactive; 

j * * 

* Constructs <code>this</code> of default values. 

* @throws CouldNotDecode if an {@link InstantiationException} 
occurs 

*/ 

public 

HLAinteractionSubscription () 
throws CouldNotDecode 

{ 

//super () not called because super-class is abstract 
try 


initializeFields() ; 

} 

catch (InstantiationException e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionSubscription(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ; 


704 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAinteractionSubscription(byte[] buffer, 

int offset) 

throws CouldNotDecode 

{ 

this (new ByteWrapper (buffer, offset) ) ,- 


j * * 

* Constructs <code>this</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAinteractionSubscription(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode (byteWrapper) ,- 


DRDC Valcartier TR 2007-412 


705 



* * 


* Constructs <code>this</code> from the provided <code>Map</code>. 

* @param theMap the <code>Map</code> representation of 
<code>this</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

public 

HLAinteractionSubscription(j ava.util.Map theMap) 
throws CouldNotDecode 

{ 

this ( ) ; 
try 


putAll(theMap) ; 

} 

//Wrap all exceptions as CouldNotDecode 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


//end HLAinteractionSubscription 


706 


DRDC Valcartier TR 2007-412 



// File: HLAobj ectClassBasedCount.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe MOM HLAobjectClassBasedCount fixed record data type. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 

HLAobj ectClassBasedCount 

extends HLAfixedRecordType 

{ 

/** First field. */ 

public HLAhandle HLAinteractionClass; 

/** Second field. */ 

public HLAcount HLAinteractionCount; 

j * * 

* Constructs <code>this</code> with default values. 

* @throws CouldNotDecode if an {@link InstantiationException} 
occurs 

*/ 

public 

HLAobjectClassBasedCount() 
throws CouldNotDecode 

{ 

//super() not called because super-class is abstract 
try 


initializeFields(); 

} 

catch (InstantiationException e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAobj ectClassBasedCount(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0); 


DRDC Valcartier TR 2007-412 


707 



* * 


* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAobj ectClassBasedCount(byte[] buffer, 

int offset) 

throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Constructs <code>this</code> from the supplied 
<code>ByteWrapperc/code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAobj ectClassBasedCount(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


708 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the provided <code>Map</code>. 

* @param theMap the <code>Map</code> representation of the 
<code>this</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

public 

HLAobj ectClassBasedCount(j ava.util.Map theMap) 
throws CouldNotDecode 

{ 

this ( ) ; 
try 


putAll(theMap) ; 

} 

//Wrap all exceptions as CouldNotDecode 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


//end HLAobj ectClassBasedCount 


DRDC Valcartier TR 2007-412 


709 



// File: HLAsyncPointFederate.java 
package ca.gc.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* Type-safe MOM HLAsyncPointFederate fixed record data type. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
HLAsyncPointFederate 

extends HLAfixedRecordType 

{ 

/** First field. */ 

public HLAhandle HLAfederate; 

/** Second field. */ 

public HLAsyncPointStatus HLAfederateSyncStatus; 

j * * 

* Constructs <code>this</code> with default values. 

* @throws CouldNotDecode if an {@link InstantiationException} 
occurs 

*/ 

public 

HLAsyncPointFederate() 
throws CouldNotDecode 

{ 

//super () not called because super-class is abstract 
try 


initializeFields() ; 

} 

catch (InstantiationException e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 


j * * 

* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of <code>this</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointFederate(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ; 


710 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the network representation in 
the provided <code>byte[]</code> at the indicated <code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of <code>this</code> 

* @param offset where in the <code>buffer</code> the 
representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAsyncPointFederate(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Constructs <code>this</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of <code>this</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAsyncPointFederate(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


DRDC Valcartier TR 2007-412 


711 



* * 


* Constructs <code>this</code> from the provided <code>Map</code>. 

* @param theMap the <code>Map</code> representation of the 
<code>this</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

public 

HLAsyncPointFederate(j ava.util.Map theMap) 
throws CouldNotDecode 

{ 

this ( ) ; 
try 
{ 

putAll(theMap) ; 

} 

//Wrap all exceptions as CouldNotDecode 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


//end HLAsyncPointFederate 


712 


DRDC Valcartier TR 2007-412 



The HLAvariantrecorddatatype interface extends HLAdatatype. The 
HLAvariantRecordType abstract class extends HLAbasicType. Oddly, variant 
record and fixed record classes have relatively little in common. 


// File: HLAvariantrecorddatatype.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode,- 
import j ava.util.Iterator; 

j * * 

* Interface implemented by the HLA variant record data types. 

* <p> 

* In addition to this interface, the HLA variant record data type 
classes are expected to supply: 

* <ul > 

* <li> Constructors (default and specified-value)</li> 

* <li> Constructor (byte[] buffer) throws CouldNotDecode</li> 

* <li> Constructor (byte[] buffer, int offset) throws 
CouldNotDecode</li> 

* <li> Constructor (ByteWrapper byteWrapper) throws 
CouldNotDecode</li> 

* <li> java.lang.Object methods toStringO; equals (Object 
otherObject) and hashCode()</li> 

* <li> Class-specific extensions as necessary</li> 

* </ul> 

* A variant record consists of a discriminant field (an enumerated 
type), to each value of which 

* corresponds a (possibly different or null) alternative field (any 
type) . 

* The octetBoundary of a variant records is the largest of the 
octetBoundaries of the discriminant 

* and the various possible alternatives. 

* encodedLength will obviously depend on the encodedLengths of the 
various fields, discriminants and alternatives. 

* <p> 

* The behaviour of the type isn't clearly defined by the 
specification; my assumptions follow. 

* Unlike the fixed record type, the variant record type's 
discriminant and alternative fields 

* will be protected and access will occur through get and set 
methods. 

* Changing the discriminant value will clear the previous alternative 
and generate a default alternative. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 


DRDC Valcartier TR 2007-412 


713 



public interface 
HLAvariantrecorddatatype 
extends HLAdatatype 

{ 

j * * 

* Returns an Iterator over the discriminant values. 

* This will be the same as the discriminant's class' iterator () . 

* @return the requested Iterator 

*/ 

Iterator 

discriminantlterator() ; 

j * * 

* Returns an Iterator over the alternative names (as Strings) by 
discriminant value. 

* This will be in lock-step with the discriminantlterator. 

* Null alternatives will have the zero-length String as name. 

* @return the requested Iterator 

*/ 

Iterator 

alternativeNamesIterator(); 

j * * 

* Returns an Iterator over the alternative Classes by discriminant 
value. 

* This will be in lock-step with the discriminantlterator. 

* @return the requested Iterator 

*/ 

Iterator 

alternativeClassIterator(); 

j * * 

* Returns a copy (clone) of the variant record's discriminant (an 
HLA enumerated type instance). 

* @return the requested discriminant 

* @see #setDiscriminant 

*/ 

HLAenumerateddatatype 
getDiscriminant(); 

j * * 

* Returns the variant record's discriminant's name (as a String). 

* @return the requested discriminant's name (as a String) 

*/ 

String 

getDiscriminantName(); 


714 


DRDC Valcartier TR 2007-412 



* * 


* Sets the discriminant's value. 

* @param newDiscriminant an HLAenumerateddatatype (whose class 
must match the discriminant's) which will be copied to the 
discriminant 

* @return a String specifying the resulting Alternative's name 
(could be null) 

* @throws CouldNotDecode if something goes awry 

* @see #getDiscriminant 

*/ 

String 

setDiscriminant(HLAenumerateddatatype newDiscriminant) 
throws CouldNotDecode; 


j * * 

* Returns true if an alternative exists for the variant record's 
current discriminant value (false if null). 

* @return a boolean which is true if there is a current 
alternative 

*/ 

boolean 

hasAlternative(); 

j * * 

* Returns a copy of the variant record's current alternative 
(either null or some HLA data type instance). 

* @return the requested alternative 

* @see #setAlternative 

*/ 

HLAdatatype 
getAlternative(); 

j * * 

* Returns the Class of the variant record alternative associated 
with the specified discriminant value. 

* @param otherDiscriminant an HLAenumerateddatatype specifying the 
discriminant value to query the alternatives with 

* @return the requested Class (could be null) 

* @throws IllegalArgumentException if the discriminant is not of 
the correct class 

*/ 

Class 

getAlternativeClass(HLAenumerateddatatype otherDiscriminant) 
throws IllegalArgumentException; 


j * * 

* Returns the variant record's current alternative's name (as a 
String). 

* @return the requested alternative's name (as a String) 

*/ 

String 

getAlternativeName() ; 


DRDC Valcartier TR 2007-412 


715 



* * 


* Returns the name (as a String) of the variant record's 
alternative associated with the specified discriminant value. 

* @param discriminant an HLAenumerateddatatype specifying the 
discriminant value to query the alternatives with 

* @return the requested alternative's name (as a String) 

* @throws IllegalArgumentException if the discriminant is not of 
the correct class 

*/ 

String 

getAlternativeName(HLAenumerateddatatype discriminant) 
throws IllegalArgumentException; 


j * * 

* Sets the variant record's current alternative to the specified 
value. 

* @param newAlternative an HLAdatatype (whose class must match the 
current alternative's) whose value will be copied to the record's 
alternative 

* @return the current alternative's previous HLAdatatype value 

* @throws CouldNotDecode if something goes awry 

* @see #getAlternative 

*/ 

HLAdatatype 

setAlternative(HLAdatatype newAlternative) 
throws CouldNotDecode; 

} 

//end HLAvariantrecorddatatype 


716 


DRDC Valcartier TR 2007-412 



// File: HLAvariantRecordType.j ava 
package ca.gc.drdc_rddc.hla.rtil516.omt,- 

import hla.rtil516.CouldNotDecode,- 
import j ava. util. Collect ion,- 
import j ava. util. Iterator,- 
import j ava.util.ArrayList; 

j * * 

* HLA variant record data type abstract base class. 

* All user-defined variant record data types should descend from this 
class and need only specify constructors. 

* <p> 

* The discriminant and alternatives held by this class will never be 
exposed to the outside,- 

* any references passed in will have clones stored, and any instances 
emanating from the class 

* will be clones of the stored instances. 

* <p> 

* See HLAdemoVariantRecord for an example of how to use this class 
with variant record data types. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public abstract class 
HLAvariantRecordType 

extends HLAbasicType 
implements HLAvariantrecorddatatype 

{ 

//If at all possible, it is strongly recommended that the concrete 
class declare this field: 

// public static final int 
// octetBoundary = <whatever>; 

//These fields are required of the concrete class: 

//The discriminant Class 
// public static final Class 
// discriminantClass = HLAboolean. class ,- 

//The discriminant name 
// public static final String 
// discriminantName = "bool"; 

//The array of alternative classes 
// public static final Class [] 

// alternativeClass = { null, HLAunicodeString. class 

//The array of alternative names 
// public static final String[] 

// alternativeName = { "NA", "theString" 

//The remaining fields are for this class' consumption 


DRDC Valcartier TR 2007-412 


717 



/** The discriminant value. */ 
protected HLAenumerateddatatype 
_discriminant; 

/** The discriminant index (into its Iterator) */ 

protected int 

_disoriminantIndex; 

/** The discriminant cardinality. */ 

protected int 

_disoriminantCardinality; 

/** The current alternative. */ 
protected HLAdatatype 
_alternative; 


718 


DRDC Valcartier TR 2007-412 



* * 


* Initializes the <code>HLAvariantRecordType</code> from the class 
parametres. 

* For the concrete class to function, initializeO *must* be 
called by the void constructor. 

* <p> 

* The discriminant is created using its void constructor, and the 
corresponding 

* alternative (if any) created likewise. 

* The arrays of alternative classes and names must have their 
lengths equal to 

* the cardinality of the discriminant's class' Iterator. 

* Null alternatives must have null classes and be named "NA". 

* @throws CouldNotDecode if any of the requirements are not met or 
something else goes wrong 

*/ 

public void 
initialize () 

throws CouldNotDecode 

{ 

//Wrap all exceptions in CouldNotDecode 
try { 

_discriminantlndex = -1; 

_discriminant = 

(HLAenumerateddatatype) discriminant Class () . newlnstance () ,- 

//Using the discriminant's Iterator, find its cardinality 
//and identify the current discriminantlndex in passing 
Iterator itr = discriminantlterator () ,- 
_discriminantCardinality = 0; 
while (itr.hasNext()) 

{ 

if (itr.next().equals(_discriminant)) _discriminantlndex = 
_discriminantCardinality; 

_di sc riminant Cardinal ity++ ,- 

} 

//Badly behaved HLAenumerateddatatype will either return a 
zero discriminantSize or fail to index itself 
if (_discriminantlndex < 0) throw new 
IllegalArgumentException(discriminantClass().getName()); 

//alternativeName and alternativeClass must have the same 
cardinality as the discriminantClass 

if (_discriminantCardinality != 

((String[])getThisField("alternativeName")).length) throw new 
IllegalArgumentException("alternativeName.length J = " + 
discriminantClass () . get Name () + " cardinality") ,- 
if (_discriminantCardinality != 

( (Class [] )getThisField("alternativeClass")) .length) throw new 
IllegalArgumentException("alternativeClass.length J = " + 
discriminantClass () . get Name () + " cardinality" ),- 


DRDC Valcartier TR 2007-412 


719 



//Validate the alternatives 

for (int 1=0; i < _discriminantCardinality; i++) 

{ 

if (alternativeClass(i) == null) 

{ 

if (alternativeName(i).compareToIgnoreCase("NA") != 0) 

throw new IllegalArgumentException ("alternativeName [ 11 + i + 11 ] 1 = 

/"NA/""); 

} else { 

if (alternativeName (i) .equals ( 1111 ) | | 

(alternativeName (i). compareToIgnoreCase ("NA 11 ) == 0)) throw new 
IllegalArgumentException("alternativeName[" + i + "] =\""+ 
alternativeName(i) + "\""); 
if 

(iHLAdatatype.class.IsAssignableFrom(alternativeClass(i))) throw new 
IllegalArgumentException(alternativeClass(i).getName() + " l= 
HLAdatatype"); 


if (hasAlternative()) _alternative = 

(HLAdatatype)alternativeClass(_discriminantlndex).newlnstance(); 

} catch (Exception e) { //InstantiationException, 
IllegalArgumentException 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


//HLAdatatype implementation 

j * * 

* Returns the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code>. 

* <p> 

* As a general rule, Variant Records [HLAvariantRecord], Dynamic 
Arrays [HLAvariableArray], and any 

* Fixed Arrays [HLAfixedArray] or Fixed Records [HLAfixedRecord] 
containing either of these first two 

* cannot have a constant encodedLength. 

* @return the length (in bytes) of the <code>byte[]</code> 
representation of <code>this</code> 

*/ 

public final int 
encodedLength() 

{ 

//Note that the null-alternative encodedLength may be different 
from _discriminant.encodedLength() 

if (lhasAlternative()) return _discriminant.encodedLength(); 
return octetBoundary() + _alternative.encodedLength(); 


720 


DRDC Valcartier TR 2007-412 



* * 


* Returns the octet boundary of <code>this</code>. 

* The octet boundary value is defined as the smallest power of 2 
which is greater than or equal to the size of the datatype in bytes. 

* For a constructed datatype, it is the maximum octet boundary 
value of all components within it. 

* <p> 

* In all cases octetBoundary is constant. 

* For HLAvariantRecord, the octet boundary is determined as the 
largest octet boundary of the 

* discriminant and all possible alternatives. 

* @return the octet boundary of <code>this</code> 

*/ 

public final int 
octetBoundary() 

{ 

Object o = getThisField("octetBoundary") ; 
if (o l= null) return ((Integer)o).intValue(); 


DRDC Valcartier TR 2007-412 


721 



Class alt; 

int altBoundary,- 

int theBoundary = _discriminant. octetBoundary () ,- 
//Iterate over the possible alternatives 
Iterator itr = alternativeClassIterator () ,- 
while (itr.hasNext() ) 

{ 

alt = (Class)itr.next() ; 

//We skip the case where one of the alternatives is self, to 
avoid infinite recursion 

//Note that this isn't fool-proof, since we could have, for 

example, 

//an alternative which is a dynamic array of this class... 
if ((alt l= null) && (lalt.equals(this.getClass()))) 

{ 

altBoundary = 0; 
try 


altBoundary = 

alt.getField( "octetBoundary' 1 ) . get Int (null) ,- 

} 

catch (Exception e) //NoSuchFieldException, 
IllegalAccessException 
{ 

//Most likely the class does not have a static 
octetBoundary field 
try 


altBoundary = 

( (HLAdatatype) alt. newlnstance () ) . octetBoundary () ,- 

} 

catch (Exception ee) //ClassCastException, 
IllegalAccessException, InstantiationException, 
ExceptionlnlnitializerError, SecurityException 
{ 

//Give upl 


if (altBoundary > theBoundary) theBoundary = altBoundary,- 


return theBoundary,- 


722 


DRDC Valcartier TR 2007-412 



* * 


* Encodes <code>this</code> into the <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> into which to 
encode <code>this</code> 

* @return the <code>ByteWrapper</code> 

*/ 

public ByteWrapper 

encode(ByteWrapper byteWrapper) 

{ 

byteWrapper.align(octetBoundary()) ; 

_discriminant.encode(byteWrapper); 

if (hasAlternative()) _alternative.encode(byteWrapper); 
return byteWrapper; 


j * * 

* Sets <code>this</code> value from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the data type begins 

* @return the <code>ByteWrapper</code> 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public ByteWrapper 
decode(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

try 

{ 

byteWrapper.align(octetBoundary() ) ; 

_discriminant.decode(byteWrapper); 

_discriminantlndex = getlndex(_discriminant); 
if (lhasAlternative()) return byteWrapper; 

_alternative = 

(HLAdatatype)alternativeClass(_discriminantIndex).newlnstance(); 

_alternative.decode(byteWrapper); 
return byteWrapper; 

} 

catch (Exception e) //InstantiationException, 

IllegalAccessException 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


DRDC Valcartier TR 2007-412 


723 



//HLAvariantrecorddatatype implementation 


j k k 

* Returns an Iterator over the discriminant values. 

* This will be the same as the discriminant's class' iterator(). 

* @return the requested Iterator 

*/ 

public Iterator 
discriminantIterator() 

{ 

return discriminant.iterator () ; 


j k k 

* Returns an Iterator over the alternative names (as Strings) by 
discriminant value. 

* This will be in lock-step with the discriminantlterator. 

* Null alternatives will have the zero-length String as name. 

* @return the requested Iterator 

*/ 

public Iterator 
alternativeNamesIterator() 

{ 

immutableArrayList ial = new 
immutableArrayList(_discriminantCardinality); 

for (int i = 0; i < _discriminantCardinality; i++) 
ial.add(alternativeName(i) ) ; 
ial.trimToSize() ; 
return ial.iteratorO ; 


j k k 

* Returns an Iterator over the alternative Classes by discriminant 
value. 

* This will be in lock-step with the discriminantlterator. 

* @return the requested Iterator 

*/ 

public Iterator 
alternativeClassIterator() 

{ 

//You know, it's really annoying that ArrayList doesn't have an 
(Object [] ) constructor... 

immutableArrayList ial = new 
immutableArrayList(_discriminantCardinality); 

//No need to clone the Class objects as there are no methods 
that could change their state 

for (int i = 0; i < _discriminantCardinality; i++) 
ial.add(alternativeClass(i) ) ; 
ial.trimToSize() ; 
return ial.iteratorO ; 


724 


DRDC Valcartier TR 2007-412 



* * 


* Returns a copy (clone) of the variant record's discriminant (an 
HLA enumerated type instance). 

* @return the requested discriminant 

* @see #setDiscriminant 

*/ 

public HLAenumerateddatatype 
getDiscriminant () 

{ 

try 


return 

(HLAenumerateddatatype)cloneThroughlnterface(_discriminant); 

} 

catch (Exception e) //(InstantiationException), CouldNotDecode 

{ 

return null; 


j * * 

* Returns the variant record's discriminant's name (as a String). 

* @return the requested discriminant's name (as a String) 

*/ 

public String 
getDiscriminantName() 

{ 

return (String)this.getThisField("discriminantName") ; 


DRDC Valcartier TR 2007-412 


725 



* * 


* Sets the discriminant's value. 

* @param newDiscriminant an HLAenumerateddatatype (whose class 
must match the discriminant's) which will be copied to the 
discriminant 

* @return a String specifying the resulting Alternative's name 
(could be null) 

* @throws CouldNotDecode if something goes awry 

* @see #getDiscriminant 

*/ 

public String 

setDiscriminant(HLAenumerateddatatype newDiscriminant) 
throws CouldNotDecode 

{ 

int oldlndex = _discriminantlndex; 

_discriminant.decode(newDiscriminant.toByteArray()); 
_discriminantlndex = getlndex(_discriminant); 

if (_discriminantlndex == oldlndex) return getAlternativeName() ; 
_alternative = null; 

if (lhasAlternative()) return getAlternativeName(); 
try 


_alternative = 

(HLAdatatype)alternativeClass(_discriminantlndex) .newlnstance () ; 

} 

catch (Exception e) //InstantiationException, 
IllegalAccessException 
{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e) ; 

} 

return getAlternativeName(); 


j * * 

* Returns true if an alternative exists for the variant record's 
current discriminant value (false if null). 

* @return a boolean which is true if there is a current 
alternative 

*/ 

public boolean 
hasAlternative() 

{ 

return (null != alternativeClass(_discriminantlndex)); 


726 


DRDC Valcartier TR 2007-412 



* * 


* Returns a copy (clone) of the variant record's current 
alternative (either null or some HLA data type instance). 

* @return the requested alternative 

* @see #setAlternative 

*/ 

public HLAdatatype 
getAlternative() 

{ 

if (lhasAlternative()) return null; 
try 


return cloneThroughlnterface(_alternative); 

} 

catch (Exception e) //(InstantiationException), CouldNotDecode 

{ 

return null; 


j * * 

* Returns the Class of the variant record alternative associated 
with the specified discriminant value. 

* @param otherDiscriminant an HLAenumerateddatatype specifying the 
discriminant value to query the alternatives with 

* @return the requested Class (could be null) 

* @throws IllegalArgumentException if the discriminant is not of 
the correct class 

*/ 

public Class 

getAlternativeClass(HLAenumerateddatatype otherDiscriminant) 
throws IllegalArgumentException 

{ 

if (ldiscriminantClass().equals(otherDiscriminant.getClass())) 
throw new IllegalArgumentException(); 

int index = getlndex(otherDiscriminant); 

if (index < 0) throw new IllegalArgumentException(); 

return alternativeClass(index); 


j * * 

* Returns the variant record's current alternative's name (as a 
String). 

* @return the requested alternative's name (as a String) 

*/ 

public String 
getAlternativeName() 

{ 

return alternativeName(_discriminantlndex); 


DRDC Valcartier TR 2007-412 


727 



* * 


* Returns the name (as a String) of the variant record's 
alternative associated with the specified discriminant value. 

* @param otherDiscriminant an HLAenumerateddatatype specifying the 
discriminant value to query the alternatives with 

* @return the requested alternative's name (as a String) 

* @throws IllegalArgumentException if the discriminant is not of 
the correct class 

*/ 

public String 

getAlternativeName(HLAenumerateddatatype otherDiscriminant) 
throws IllegalArgumentException 

{ 

if (ldiscriminantClass().equals(otherDiscriminant.getClass())) 
throw new IllegalArgumentException(); 

int index = getlndex(otherDiscriminant); 

if (index < 0) throw new IllegalArgumentException() ; 

return alternativeName(index); 


j * * 

* Sets the variant record's current alternative to the specified 
value. 

* @param newAlternative an HLAdatatype (whose class must match the 
current alternative's) whose value will be copied to the record's 
alternative 

* @return the current alternative's previous HLAdatatype value 

* @throws CouldNotDecode if something goes awry 

* @see #getAlternative 

*/ 

public HLAdatatype 

setAlternative(HLAdatatype newAlternative) 
throws CouldNotDecode 

{ 

//Setting null to null is the trivial operation 
if ((newAlternative == null) && (_alternative == null)) return 

null; 

//Switching from null to non-null or vice-versa is not allowed 
if ((newAlternative == null) || (_alternative == null)) throw 
new CouldNotDecode("NullPointerException"); 

//Classes must otherwise match 
if 

(lalternativeClass(_discriminantIndex).equals(newAlternative.getClass( 
))) throw new CouldNotDecode(newAlternative.getClass().getName()); 

//Prepare the clone that will be returned 
HLAdatatype r = cloneThroughlnterface(_alternative); 

//Update the stored instance's value 
_alternative.decode(newAlternative.toByteArray()); 
return r; 


728 


DRDC Valcartier TR 2007-412 



//j ava.lang.Object methods 


j * * 

* Returns a String representation of this. 

* The String representation consists of fixed-record-like list of 
key-value mappings 

* (listing the discriminant and then the alternative) enclosed in 
braces 

* (<tt>"{}"</tt>) and separated by the characters <tt>", "</tt> 
(comma and space). 

* Each key-value mapping is rendered as the key followed by an 
equals sign (<tt>" = 11 </tt>) followed by the associated value. 

* Keys and values are converted to strings as by 
<tt >String.valueOf(Object)</tt >. 

* In the special case of null alternatives, the key is represented 
by "NA" and the value rendered as "null". 

* <p> 

* @return a String representation of this 

*/ 

public String 
toString() 

{ 

StringBuffer buf = new StringBuffer(); 

buf.append("{" + getDiscriminantName() + "=" + 

_discriminant. toString () + ", "),- 

buf.append(getAlternativeName() + " = "),- 

buf . append (hasAlternative () ? _alternat ive . toString () : "null") ,- 

buf.append("}") ; 
return buf. toString () ,- 


DRDC Valcartier TR 2007-412 


729 



* * 


* Returns true iff <code>this</code> and <code>otherObject</code> 
represent the same object. 

* @param otherObject the <code>Object</code> to compare with 

* @return <code>true</code> iff supplied <code>otherObject</code> 
is of the same type as <code>this</code> and has the same value 

* @see Object#hashCode Object.hashCode() 

* @see java.util.Hashtable Hashtable 
*/ 

public boolean 

equals(Object otherObject) 

{ 

if (this == otherObject) return true; 

//This form is more inheritable, and will ensure that 
otherObject is an instance of this' class (or a sub-class) 

//We disallow subclassing 

if (l this.getClass().equals(otherObj ect.getClass ())) return 

false; 

// if (l this.getClass().islnstance(otherObject)) return false; 
if 

(!_discriminant.equals(((HLAvariantrecorddatatype)otherObj ect) .getDisc 
riminantO)) return false; 

//Compare alternatives now 
HLAdatatype otherField = 

((HLAvariantrecorddatatype)otherObj ect) .getAlternative(); 

if ((_alternative == null) && (otherField == null)) return true; 
if ((_alternative == null) || (otherField == null)) return 

false; 

return _alternative.equals(otherField); 


j * * 

* Returns the hash code value for this. 

* @return the hash code value for this 

* @see j ava.util.Map.Entry#hashCode() 

* @see Object#hashCode() 

* @see Object#equals(Object) 

*/ 

public int 
hashCode() 

{ 

int h = _discriminant.hashCode() ; 

return (hasAlternative() ? h + _alternative.hashCode() : h); 


730 


DRDC Valcartier TR 2007-412 



//Cloneable implementation 


j k k 

* Creates and returns an independent copy of this object. 

* @return an independent copy of this Object 

* @throws CloneNotSupportedException if the object's class is not 
Cloneable or if the instance cannot be cloned 

*/ 

public Object 
clone () 

throws CloneNotSupportedException 

{ 

//The method inherited from Object does a shallow copy; 

//the fields will have been copied too, so the clone's fields 
//will hold references to the same objects as the original. 

try 

{ 

// return new HLAvariantRecordType(toByteArray()); //This class 

doesn't have this constructor 

// return new HLAvariantRecordType(_discriminant, 

_discriminantName, _alternatives, _alternativeNames),- 
return cloneThroughlnterface(this),- 

} 

//Something is seriously wrong with the class if it can't encode 
and then decode itself... 

catch (Exception e) //CouldNotDecode 

{ 

CloneNotSupportedException cnse = new 
CloneNotSupportedException(e.getMessage()); 

throw (CloneNotSupportedException)cnse.initCause(e),- 


//Supporting classes and methods 

j k k 

* Returns the specified (static) field's value as an Object. 

* This is just an instance-proxy for the various class fields. 

* @param fieldName a String specifying the field's name 

* @return the requested field, as an Object (null in case of 
failure) 

*/ 

private Object 

getThisField(String fieldName) 

{ 

try 


return this.getClassO . get Field (fieldName) .get (null) ,- 

} 

catch (Exception e) //NoSuchFieldException, 
IllegalAccessException 
{ 

return null; 


DRDC Valcartier TR 2007-412 


731 



* * 


* Returns the discriminant Class. 

* This is just an instance-proxy for the class field. 

* @return the discriminant Class 

*/ 

private Class 
discriminantClass() 

{ 

return (Class)getThisField (' 1 discriminantClass") ; 


j * * 

* Returns the alternative name at the specified position within 
the array. 

* This is just an instance-proxy for the class field, with 
indexing. 

* @param index an int specifying the position to look up within 
the array 

* @return the alternative name requested 

*/ 

private String 
alternativeName(int index) 

{ 

return ((String[])getThisField("alternativeName"))[index]; 


j * * 

* Returns the alternative Class at the specified position within 
the array. 

* This is just an instance-proxy for the class field, with 
indexing. 

* @param index an int specifying the position to look up within 
the array 

* @return the requested Class 

*/ 

private Class 

alternativeClass(int index) 

{ 

return ( (Class [] ) getThisField (" alternativeClass") ) [ index] ,- 


732 


DRDC Valcartier TR 2007-412 



//Clone an HLAdatatype object through its byte[] constructor, 
private HLAdatatype 

cloneThroughlnterface(HLAdatatype source) 
throws CouldNotDecode 

{ 

if (source == null) return null; 
try 


//In plain English, we fetch the object's byte[] constructor 
and invoke it on the object's toByteArray() encoding 

return (HLAdatatype)source.getClass().getConstruetor(new 
Class[] { byte[].class } ).newlnstance(new Object[] { 

source.toByteArray() } ); 

//Equivalently: 

// HLAdatatype theClone = 

(HLAdatatype)source.getClass().newlnstance(); 

// theClone.decode(source.toByteArray()); 

// return theClone; 

} 

catch (Exception e) //NoSuchMethodException, 

InstantiationException 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()) ; 
throw (CouldNotDecode)end.initCause(e); 


//Compute the index of the specified discriminant value into the 
discriminant's Iterator, 
private int 

getIndex(HLAenumerateddatatype theDiscriminant) 

{ 

int index = -1; 

Iterator itr = discriminantlterator () ; 
while (itr.hasNext()) 

{ 

index++; 

if (itr.next () .equals(theDiscriminant)) return index; 

} 

return -1; 


//An ArrayList that denies the iterator's remove() and its kin 
private class 
ImmutableArrayList 
extends ArrayList 

{ 

ImmutableArrayList() 

{ 

super () 


ImmutableArrayList(Collection c) 

{ 

super(c); 


DRDC Valcartier TR 2007-412 


733 



immutableArrayList(int initialCapacity) 


super(initialCapacity); 


public Object 
remove(int index) 

{ 

throw new UnsupportedOperationException(); 


//ArrayList's implementation does not rely on its remove() 
we must override this method too 
public void 
clear () 

{ 

throw new UnsupportedOperationException(); 


//These we do not need to override; they are inherited from 
AbstractCollection and rely on remove(int) 

// public boolean 

// remove(Object o) 

// public boolean 

// removeAll(Collection c) 

// public boolean 

// retainAll(Collection c) 


//end HLAvariantRecordType 


so 


734 


DRDC Valcartier TR 2007-412 



Since the MOM does not provide any variant record examples, we illustrate our 
design pattern through the HLAdemoVariantRecord demonstration class. 


// File: HLAdemoVariantRecord.j ava 
package ca.go.drdc_rddc.hla.rtil516.omt; 

import hla.rtil516.CouldNotDecode; 

j * * 

* HLA demo variant record data type. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
HLAdemoVariantRecord 

extends HLAvariantRecordType 

{ 

/** The discriminant Class. */ 
public static final Class 
discriminantClass = HLAboolean.class; 

/** The discriminant name. */ 
public static final String 
discriminantName = "bool"; 

/** The array of alternative classes. */ 
public static final Class [] 

alternativeClass = { null, HLAunicodeString.class }; 

/** The array of alternative names. */ 
public static final String[] 
alternativeName = { "NA", "theString" }; 

j * * 

* Constructs a default <code>HLAdemoVariantRecord</code>. 

* @throws CouldNotDecode if initialization fails 

*/ 

public 

HLAdemoVariantRecord() 
throws CouldNotDecode 

{ 

//super() not called because super-class is abstract 
initialize(); 


DRDC Valcartier TR 2007-412 


735 



* * 


* Constructs a <code>HLAdemoVariantRecord</code> from another one. 

* @param other the HLAdemoVariantRecord instance to copy 

* @throws CouldNotDecode if initialization fails 

*/ 

public 

HLAdemoVariantRecord(HLAdemoVariantRecord other) 
throws CouldNotDecode 

{ 

this ( ) ; 

setDiscriminant(other.getDiscriminant() ) ; 
setAlternative(other.getAlternative()); 


//The remaining constructors are boiler-plate 

j * * 

* Creates a <code>HLAdemoVariantRecord</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>HLAdemoVariantRecord</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAdemoVariantRecord(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ; 


j * * 

* Creates a <code>HLAdemoVariantRecord</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>HLAdemoVariantRecord</code> 

* @param offset where in the <code>buffer</code> the 
<code>HLAdemoVariantRecord</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

HLAdemoVariantRecord(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


736 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>HLAdemoVariantRecord</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>HLAdemoVariantRecord</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

HLAdemoVariantRecord(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


//end HLAdemoVariantRecord 


DRDC Valcartier TR 2007-412 


737 



The Normalization class implements a number of normalization and 
unnormalization methods statically. 


// File: Normalization.java 

package ca.go.drdc_rddc.hla.rtil516.omt,- 

import j ava.math.Biglnteger,- 
import hla.rtil516.*; 

j * * 

* Utility class for normalizing values over dimensions. 

* This first draft uses only static methods, but that is clearly 
inefficient. 

* I think we should have a Normalization constructor that expects two 
parametres: 

* the RTIambassador instance and the DimensionHandle (or, 
equivalently, the dimension's name). 

* This would allow the Normalization instance to cache the 
dimension's upper bound at the outset, 

* and all further methods would be slaved to that specific dimension. 

* This pattern could be further extended by passing the domain's 
bounds to the constructor as well. 

* In that latter case, not all members would be accessible (an 
enumerated set domain, for example, 

* would not allow the other normalization methods). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.2 
*/ 


738 


DRDC Valcartier TR 2007-412 



public class 
Normalization 
{ 

j * * 

* Linear normalization function for integer values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domainLower the lower bound on the possible values of 
domain 

* @param domainUpper the upper bound on the possible values of 
domain 

* @param domain a nonenumerated integer value known to the 
federate using the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
linear(RTIambassador rti, 

DimensionHandle dimension, 

long domainLower, 

long domainUpper, 

long domain) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


// [(domain - domainLower) / (domainUpper - domainLower)] * (DUB 

- 1 ) 

// or more accurately 

// [(domain - domainLower) * (DUB - 1) ] / (domainUpper - 

domainLower) 

Biglnteger dub = new 

Biglnteger(Long.toString(rti.getDimensionUpperBound(dimension) - 1)); 

Biglnteger 1 = new Biglnteger (Long. toString (domainLower) ) ,- 
Biglnteger u = new Biglnteger (Long. toString (domainUpper) ) ,- 
Biglnteger d = new Biglnteger (Long. toString (domain) ) ,- 
// return 

( ( (d. subtract (1) ) .multiply (dub) ) . divide (u. subtract (1))) . longValue () ,- 
return 

d.subtract(l) . mult iply (dub) . divide (u. subtract (1) ) . longValue () ,- 
} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


739 



* * 


* Linear unnormalization function. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domainLower the lower bound on the possible values of 
domain 

* @param domainUpper the upper bound on the possible values of 


domain 

* @return a nonenumerated integer value known to the federate 
using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 


public static long 

uniinear(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

long domainLower 

long domainUpper! 

throws InvalidDimensionHandle, 

FederateNotExecutionMember 
RTIinternalError, 
FederatelnternalError 


try 


// domainLower + ceiling([normalized * (domainUpper - 

domainLower)] / (DUB - 1)) 

Biglnteger dub = new 

Biglnteger(Long.tostring(rti.getDimensionUpperBound(dimension) - 1)); 
Biglnteger n = new Biglnteger (Long. toString (normalized) ) ,- 
Biglnteger 1 = new Biglnteger (Long. toString (domainLower) ) ,- 
Biglnteger u = new Biglnteger (Long. toString (domainUpper) ) ,- 
return 1.add(ceiling(n.multiply(u.subtract(1)), 
dub) ) . longValue () ,- 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


740 


DRDC Valcartier TR 2007-412 



* * 


* Linear normalization function for floating-point values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domainLower the lower bound on the possible values of 
domain 

* @param domainUpper the upper bound on the possible values of 
domain 

* @param domain a floating-point value known to the federate using 
the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
linear(RTIambassador rti, 

DimensionHandle dimension, 

double domainLower, 

double domainUpper, 

double domain) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 

{ 

try 

{ 

// [(domain - domainLower) / (domainUpper - domainLower)] * (DUB 

- 1 ) 

//Converting between double and long is sure a pain in the 
behind, because of the "possible loss of precision" compiler error... 
double dub = 

Double.valueOf(Long.tostring(rti.getDimensionUpperBound(dimension) - 
1) ) .doubleValue () ,- 

return new Double(dub*(domain - domainLower)/(domainUpper - 
domainLower) ) . longValue () ,- 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


741 



* * 


* Linear unnormalization function for floating-point values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domainLower the floating-point lower bound on the 
possible values of domain 

* @param domainUpper the floating-point upper bound on the 
possible values of domain 

* @return a floating-point value known to the federate using the 
dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static double 

uniinear(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

double domainLower, 

double domainUpper) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


// domainLower + ceiling([normalized * (domainUpper - 

domainLower)] / (DUB - 1)) 
double dub = 

Double.valueOf(Long.toString(rti.getDimensionUpperBound(dimension) - 
1) ) . doubleValue () ,- 
double n = 

Double .valueOf (Long .toString (normalized) ) . doubleValue () ,- 

//Converting between double and long is sure a pain in the 
behind, because of the "possible loss of precision" compiler error... 
return domainLower + n*(domainUpper-domainLower)/dub; 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


742 


DRDC Valcartier TR 2007-412 



* * 


* Linear enumerated normalization function. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domain an enumerated data type value known to the 
federate using the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 

linearEnumerated(RTIambassador rti, 

DimensionHandle dimension, 

HLAenumerateddatatype domain) 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


// [positionlnMappedSet(domain) /(mappedSetLength - 1)] * (DUB - 

1 ) 

long pos = -l; 

long lngth = 0; //This will count the cardinality of the 
enumerated data type 

for (java.util.Iterator i = domain.iterator(); i.hasNextO; 

lngth++) 


if (i.next().equals(domain)) pos = lngth; 

} 

Biglnteger dub = new 

Biglnteger(Long.toString(rti.getDimensionUpperBound(dimension) - 1)); 
Biglnteger p = new Biglnteger(Long.toString(pos)); 

Biglnteger 1 = new Biglnteger(Long.toString(lngth-1)); 
return ((p.multiply(dub)).divide(1)).longValue(); 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


743 



* * 


* Linear enumerated unnormalization function. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domain an enumerated data type value known to the 
federate using the dimension 

* @return an Object (an enumerated data type instance) known to 
the federate using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static Object 

unlinearEnumerated(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

HLAenumerateddatatype domain) 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 

{ 

try 

{ 

// mappedSet[ normalized * (mappedSetLength - 1) / (DUB - 1) ] 

//Because HLAenumerateddatatype has no "length" or 
"cardinality" member, we must loop twicel 

//Count the cardinality of the enumerated data type 
long lngth = 0; 

for (j ava . util. Iterator i = domain. iterator () ,- i.hasNextO; 
i.next ()) { lngth++; } 

//Now that we know the enumerated type's cardinality, we can 
decode the normalized value 

Biglnteger dub = new 

Biglnteger(Long.tostring(rti.getDimensionUpperBound(dimension) - 1)); 
Biglnteger n = new Biglnteger (Long. toString (normalized) ) ,- 
Biglnteger 1 = new Biglnteger(Long.toString(lngth-1)); 
long pos = n. multiply (1) . divide (dub) . longValue () ,- 
for (j ava . util. Iterator i = domain. iterator () ,- i.hasNextO; 

) 

{ 

if (pos == 0) return i.nextO; 
pos - - ,- 

} 

return null; 

catch (NumberFormatException e) { 
throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


i.next () 


744 



* * 


* Enumerated set normalization function. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param theMap a Map whose entries have the domain values as keys 
and the long values as values 

* (or null to use the enumerated data type's 
getValue method) 

* @param domain an enumerated data type value known to the 
federate using the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 

enumeratedSet(RTIambassador rti, 

DimensionHandle dimension, 

j ava.ut11.Map theMap, 

HLAenumerateddatatype domain) 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


if (theMap == null) 

{ 

//An HLAenumerateddatatype normally descends from an 
HLAbasictype or HLAbasictype 

//And should thus have a getValue() method (which can 
return anything from a byte to a double or even a String) 

return unwrap(domain.getClass().getMethod("getValue", 
(Class [ ] ) null) . invoke (domain, (Object [ ] ) null) ) ,- 
} else { 

return unwrap (theMap . get (domain) ) ,- 

} 

} catch (Exception e) { 

//ClassCastException, NullPointerException, 
NoSuchMethodException, SecurityException, IllegalAccessException, 
IllegalArgumentException, j ava.lang.reflect.InvocationTargetException 
ExceptionlnlnitializerError 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


745 



* * 


* Enumerated set unnormalization function. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param theMap a Map whose entries have the domain values as keys 
and the long values as values 

* (or null to use the enumerated data type's long 
constructor) 

* @param domain an enumerated data type value known to the 
federate using the dimension 

* @return an Object (an enumerated data type instance) known to 
the federate using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 


746 


DRDC Valcartier TR 2007-412 



public static Object 
unenumeratedSet(RTIambassador 

DimensionHandle 

long 

j ava.ut11.Map 
HLAenumerateddatatype 
throws InvalidDimensionHandle, 

FederateNotExecutionMember, 
RTIinternalError, 
FederatelnternalError 


rti, 

dimension, 
normalized 
theMap, 
domain) 


try 


if (theMap == null) 

{ 

//An HLAenumerateddatatype normally descends from an 
HLAbasictype or HLAbasictype 

//And should thus have a setValueO method (which can take 
anything as its argument, from a byte to a double or even a String) 
//Here we assume there is a (long) constructor 
//We should really get all Constructors () and scan its 
getParameterTypes() in order of preference for long-compatible 
forms... 

//Like we do with the unwrap method. 

return domain.getClass() .getConstruetor(new Class [] 

{long .class }) . newlnstance (new Object [ ] {new Long (normalized) }) ,- 

//Oddly, the Object[] required by the newlnstance does get 
converted back to the primitives required by our chosen constructor... 
} else { 

for (j ava .util. Iterator i = theMap. entrySet (). iterator () ,- 
i . hasNext () ,- ) 


j ava . util. Map. Entry me = (j ava . ut il. Map . Entry) i . next () ,- 
if (unwrap(me.getValue()) == normalized) return 

me . getKey () ,- 


return null; 

} 

} catch (Exception e) { 

//NoSuchMethodException, SecurityException, 

InstantiationException, IllegalAccessException, 

IllegalArgumentException, j ava.lang.reflect.InvocationTargetException 
throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


747 



* * 


* Logarithmic normalization function for integer values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domainLower the lower bound on the possible values of 
domain 

* @param domainUpper the upper bound on the possible values of 
domain 

* @param domain a nonenumerated integer value known to the 
federate using the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
logarithmic(RTIambassador rti, 

DimensionHandle dimension, 

long domainLower, 

long domainUpper, 

long domain) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


//Note that the result is independent of the logarithm's 
base,- here we use the natural logarithm 

// [log(domain/domainLower) / log(domainUpper/domainLower)] * 

(DUB - 1) 

double dub = 

Double.valueOf(Long.toString(rti.getDimensionUpperBound(dimension) - 
1) ) . doubleValue () ,- 
return new 

Double(dub*j ava.lang.Math.log(((double)domain)/(double)domainLower)/j a 
va.lang.Math.log(((double)domainUpper)/(double)domainLower)).longValue 
0 ; 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


748 


DRDC Valcartier TR 2007-412 



* * 


* Logarithmic unnormalization function for integer values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domainLower the lower bound on the possible values of 
domain 

* @param domainUpper the upper bound on the possible values of 
domain 

* @return a long known to the federate using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 

unlogarithmic(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

long domainLower, 

long domainUpper) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 

{ 

try 

{ 

//Note that the result is independent of the logarithm's 
base,- here we use the natural logarithm 

// domainLower * exp(log(du/dl)*normalized/(DUB - 1)) 

double dub = 

Double.valueOf(Long.tostring(rti.getDimensionUpperBound(dimension) - 
1) ) .doubleValue () ,- 
double n = 

Double .valueOf (Long. toString (normalized) ) . doubleValue () ,- 
double dl = 

Double .valueOf (Long .toString (domainLower) ) . doubleValue () ,- 
double du = 

Double .valueOf (Long .toString (domainUpper) ) . doubleValue () ,- 
return 

ceiling (dl* j ava . lang. Math. exp (j ava. lang .Math. log (du/dl) *n/dub) ) ,- 
} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


749 



* * 


* Logarithmic normalization function for floating-point values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domainLower the floating-point lower bound on the 
possible values of domain 

* @param domainUpper the floating-point upper bound on the 
possible values of domain 

* @param domain a floating-point value known to the federate using 
the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
logarithmic(RTIambassador rti, 

DimensionHandle dimension, 

double domainLower, 

double domainUpper, 

double domain) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 

{ 

try 

{ 

// [log(domain/domainLower) / log(domainUpper/domainLower)] * 

(DUB - 1) 

double dub = 

Double.valueOf(Long.toString(rti.getDimensionUpperBound(dimension) - 
1)).doubleValue(); 

return new 

Double(dub*j ava.lang.Math.log(domain/domainLower)/j ava.lang.Math.log(d 
omainUpper/domainLower)).longValueO; 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


750 


DRDC Valcartier TR 2007-412 



* * 


* Logarithmic unnormalization function for floating-point values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domainLower the floating-point lower bound on the 
possible values of domain 

* @param domainUpper the floating-point upper bound on the 
possible values of domain 

* @return a double known to the federate using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static double 
unlogarithmic(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

double domainLower, 

double domainUpper) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 

{ 

try 

{ 

//Note that the result is independent of the logarithm's 
base,- here we use the natural logarithm 

// domainLower * exp(log(du/dl)*normalized/(DUB - 1)) 

double dub = 

Double.valueOf(Long.tostring(rti.getDimensionUpperBound(dimension) - 
1) ) .doubleValue () ,- 
double n = 

Double .valueOf (Long. toString (normalized) ) . doubleValue () ,- 
return 

domainLower*]ava.lang.Math.exp(j ava.lang.Math.log(domainUpper/domainLo 
wer) *n/dub) ,- 

} catch (NumberFormatException e) { 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


751 



* * 


* Hyperbolic tangent normalization function for integer values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domainCentre the value of domain around which the user 
desires the greatest precision 

* @param domainSize a generic measure of the distance around the 
domainCentre for which the user desires the relatively high precision 

* @param domain a non-enumerated integer value known to the 
federate using the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
tanh(RTIambassador rti, 

DimensionHandle dimension, 
long domainCentre, 

long domainSize, 

long domain) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 

{ 

try 

{ 

// [{tanh([domain - domainCenter]/domainSize) + l}/2] * (DUB - 

1 ) 

double dub = 

Double.valueOf(Long.toString(rti.getDimensionUpperBound(dimension) - 
1) ) . doubleValue () ,- 

return new Double(dub*(tanh((((double)domain)- 
(double) domainCentre) / (double) domainSize) + l. 0) / 2.0) . longValue () ,- 
} catch (Exception e) { //NumberFormatException 

throw new FederatelnternalError(e.getMessage()); 


752 


DRDC Valcartier TR 2007-412 



* * 


* Hyperbolic tangent unnormalization function for integer values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domainCentre the value of domain around which the user 
desires the greatest precision 

* @param domainSize a generic measure of the distance around the 
domainCentre for which the user desires the relatively high precision 

* @return a non-enumerated integer value known to the federate 
using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
untanh(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

long domainCentre, 

long domainSize) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


// domainCentre + domainSize*atanh([2*normalized/(DUB - 1)] - 1) 

double dub = 

Double.valueOf(Long.tostring(rti.getDimensionUpperBound(dimension) - 
1) ) .doubleValue () ,- 
double n = 

Double .valueOf (Long. toString (normalized) ) . doubleValue () ,- 
double do = 

Double .valueOf (Long .toString (domainCentre) ) . doubleValue () ,- 
double ds = 

Double .valueOf (Long .toString (domainSize) ) . doubleValue () ,- 
// return new Double(dc + ds*atanh((2.0*n/dub) - 

1.0)) . longValue () ,- 

return ceiling (do + ds*atanh ( (2.0*n/dub) - 1.0)),- 
} catch (Exception e) { //NumberFormatException 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


753 



* * 


* Hyperbolic tangent normalization function for floating-point 
values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension unto 
which to normalize the domain 

* @param domainCentre the floating-point value of domain around 
which the user desires the greatest precision 

* @param domainSize a generic measure of the distance around the 
domainCentre for which the user desires the relatively high precision 

* @param domain a floating-point value known to the federate using 
the dimension 

* @return a long falling within the dimension's {@link 
RangeBounds} 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static long 
tanh(RTIambassador rti, 

DimensionHandle dimension, 
double domainCentre, 

double domainSize, 

double domain) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


// [{tanh([domain - domainCenter]/domainSize) + l}/2] * (DUB - 

1 ) 

double dub = 

Double.valueOf(Long.toString(rti.getDimensionUpperBound(dimension) - 
1)).doubleValue(); 

return new Double(dub*(tanh((domain-domainCentre)/domainSize) 
+ l.0)/2.0).longValue(); 

} catch (Exception e) { //NumberFormatException 

throw new FederatelnternalError(e.getMessage()); 


754 


DRDC Valcartier TR 2007-412 



* * 


* Hyperbolic tangent unnormalization function for floating-point 
values. 

* @param rti the RTIambassador to use 

* @param dimension a DimensionHandle specifying the dimension 
whence the normalized value comes 

* @param normalized a long falling within the dimension's {@link 
RangeBounds} 

* @param domainCentre the floating-point value of the domain 
around which the user desires the greatest precision 

* @param domainSize a generic measure of the distance around the 
domainCentre for which the user desires the relatively high precision 

* @return a non-enumerated integer value known to the federate 
using the dimension 

* @throws InvalidDimensionHandle if the {@link DimensionHandle} is 
invalid 

* @throws FederateNotExecutionMember if the federate is not 
currently joined to a federation execution 

* @throws RTIinternalError if something else goes wrong within an 
RTIambassador call 

* @throws FederatelnternalError if something goes wrong with the 
rest of the method 

*/ 

public static double 
untanh(RTIambassador rti, 

DimensionHandle dimension, 

long normalized, 

double domainCentre, 

double domainSize) 

throws InvalidDimensionHandle, 

FederateNotExecutionMember, 

RTIinternalError, 

FederatelnternalError 


try 


// domainCentre + domainSize*atanh([2*normalized/(DUB - 1)] - 1) 

double dub = 

Double.valueOf(Long.tostring(rti.getDimensionUpperBound(dimension) - 
1) ) .doubleValue () ,- 
double n = 

Double .valueOf (Long. toString (normalized) ) . doubleValue () ,- 

return domainCentre + domainSize*atanh((2.0*n/dub) - 1.0); 

} catch (Exception e) { //NumberFormatException 

throw new FederatelnternalError(e.getMessage()); 


DRDC Valcartier TR 2007-412 


755 



//Support methods 


j k k 

* Returns the ceiling of the integer division of the dividend by 
the divisor. 

* The ceiling is defined as the smallest integer to be larger than 
or equal to the real quotient. 

* Thus ceiling(3, 2) is 2 but ceiling(-3, 2) and ceiling(3, -2) is 

-1 

* @param dividend a Biglnteger dividend 

* @param divisor a Biglnteger divisor 

* @return a Biglnteger representing the ceiling of the quotient 

* @throws ArithmeticException if the divisor is Biglnteger.ZERO 

*/ 

public static Biglnteger 
ceiling(Biglnteger dividend, 

Biglnteger divisor) 
throws ArithmeticException 
{ 

//In Java, division of a negative by a positive yields a 
negative (or zero) remainder 

// division of a positive by a negative yields a 

positive (or zero) remainder 

Biglnteger [] ab = dividend. divideAndRemainder (divisor) ,- 
if ((divisor.signum()*ab[1].signum()) > 0) 

{ return ab [ 0] . add (Biglnteger . ONE) ,- } 
else 

{ return ab [0] ,- } 


j k k 

* Returns the floor of the integer division of the dividend by the 
divisor. 

* The floor is defined as the largest integer to be smaller than 
or equal to the real quotient. 

* Thus floor (3, 2) is 1 but floor(-3, 2) and floor(3, -2) is -2 

* @param dividend a Biglnteger dividend 

* @param divisor a Biglnteger divisor 

* @return a Biglnteger representing the floor of the quotient 

* @throws ArithmeticException if the divisor is Biglnteger.ZERO 

*/ 

public static Biglnteger 
floor(Biglnteger dividend, 

Biglnteger divisor) 
throws ArithmeticException 
{ 

//In Java, division of a negative by a positive yields a 
negative (or zero) remainder 

// division of a positive by a negative yields a 

positive (or zero) remainder 

Biglnteger [] ab = dividend. divideAndRemainder (divisor) ,- 
if ((divisor.signum()*ab[1].signum()) < 0) 

{ return ab [ 0] . subtract (Biglnteger . ONE) ,- } 
else 

{ return ab [0] ,- } 


756 


DRDC Valcartier TR 2007-412 



* * 


* Returns the ceiling of the specified double as a long. 

* The ceiling is defined as the smallest integer to be larger than 
or equal to the specified double. 

* Thus ceiling(1.5) is 2 but ceiling(-1.5) is -1 

* @param aDouble a double value to convert 

* @return a long representing the ceiling of the specified double 

* @throws ArithmeticException if the double is Double.NaN, 

Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, or outside the 
range Long.MIN_VALUE to Long.MAX_VALUE 

*/ 

public static long 
ceiling(double aDouble) 
throws ArithmeticException 
{ 

if (Double.isNaN(aDouble) || Double.islnfinite(aDouble) || 
(aDouble > (double)Long.MAX_VALUE) || (aDouble < 

(double)Long.MIN_VALUE)) 

throw new ArithmeticException () ,- 
Double d = new Double (aDouble) ,- 
//d.longValue() truncates, so... 

//...We convert the resulting long back into a double: 

// Double dd = new Double(new Long (d. longValue ()). toString ()) ,- 
double dd = (double) d.longValue () ,- 

//If the original double is larger, there is some remainder 
if (aDouble > dd) 

{ return d. longValue ()+1,- } 
else 

{ return d. longValue () ,- } 


j * * 

* Returns the hyperbolic tangent of the specified value. 

* Weirdly, this method isn't supplied by java.lang.Math. 

* <p> 

* tanh(z) = sinh(z)/cosh(z) = (exp(z)-exp(-z))/(exp(z)+exp(-z)) = 
(exp(2 * z)-1)/(exp(2 * z)+1) 

* @param z a double specifying the value whose hyperbolic tangent 
is desired 

* @return a double specifying the hyperbolic tangent of the 
specified value 

*/ 

public static double 
tanh(double z) 

{ 

double r = j ava . lang. Math. exp (z + z) ,- 
return (r - 1.0)/(r + 1.0); 


DRDC Valcartier TR 2007-412 


757 



* * 


* Returns the hyperbolic arc-tangent of the specified value. 

* Weirdly, this method isn't supplied by java.lang.Math. 

* <p> 

* atanh(z) = 1/2 In((1+z)/(1-z)) 

* @param z a double specifying the value whose hyperbolic arc¬ 
tangent is desired 

* @return a double specifying the hyperbolic arc-tangent of the 
specified value 

*/ 

public static double 
atanh(double z) 

{ 

return j ava.lang.Math.log((1 + z)/(1-z ))/2 . 0; 


j * * 

* Unwraps the primitive contained in the specified Object. 

* @param o an Object which should be a wrapper around a primitive 

type 

* @return a long representing the primitive wrapped by the 
specified Object 

* @throws ClassCastException if the Object does not wrap a 
primitive type (or it wraps the Void.TYPE) 

*/ 

public static long 
unwrap(Object o) 

throws ClassCastException 

{ 

//Must unwrap the primitive 
Class c = o.getClass() ; 
if (c.equals(Boolean.TYPE)) 

{ return (((Boolean)o ).booleanValue() ? l : 0); } 
else if (c.equals(Character.TYPE) ) 

{ return ( (Character)o).charValue(); } 
else if (c.equals(Byte.TYPE) ) 

{ return ( (Byte)o ).longValue(); } 

else if (c.equals(Short.TYPE) ) 

{ return ( (Short)o ).longValue(); } 
else if (c.equals(Integer.TYPE)) 

{ return ( (Integer)o ).longValue(); } 
else if (c.equals(Long.TYPE)) 

{ return ( (Long)o ).longValue(); } 

else if (c.equals(Float.TYPE)) 

{ return ( (Float)o ).longValue(); } 
else if (c.equals(Double.TYPE)) 

{ return ( (Double)o ).longValue(); } 

else //includes Void.TYPE and all non-primitive others 
{ throw new ClassCastException(); } 


//end Normalization 


758 


DRDC Valcartier TR 2007-412 



Annex D - DRDC HLA 1516 FederateAmbassador 
Supporting Classes 


The ca .gc . drdc_rddc .hla. rtiisis. FedAmb package consist of three sets of 
classes. The first (validate...) defines callback validation interfaces, allowing 
callback handling to be broken down into a validation step followed by the event 
handling proper. The second (FederateAmbassador... and FedAmb...) breaks up the 
FederateAmbassador interface so that it can be implemented piecemeal. In 
particular, this allows the federate to dynamically change parts of its implementation 
during execution, by allocating responsibility to distinct event handlers. 

The third, NativeFederateAmbassador, which is not included here because it is 
somewhat out of the scope of this work, is a utility class designed to facilitate the 
implementation of FederateAmbassador as a native class. That is to say, it allows 
other languages than Java to integrate themselves into a Java-mediated HLA 
federation by supplying a library (a Windows DLL or a Unix SO). The “foreign” 
application is expected to access the RTlambassador through the Java Native 
Interface (JNI), using the NativeFederateAmbassador class to hook its library in. 
This library is invoked by the federate service thread during FederateAmbassador 
callbacks; after doing validation as required, the library then hands off any 
remaining processing to another thread, just like in Java. Under Windows, this 
hand-off can be achieved through messaging. A Delphi 7 prototype demonstrator is 
available upon request._ 


In implementing the FederateAmbassador interface, keeping all of the code in a 
single class is extremely unwieldy. In any case, because of the ConcurrentAccess 
limitation, the amount of actual work done by the class invoked within the federate 
service thread by the RTI is perforce quite limited. For a given callback, the only 
processing that must occur immediately is the callback validation, because the RTI 
expects various exceptions to be thrown by the federate ambassador if tilings appear 
awry to the federate. Once that validation is done, any lengthy work is best threaded 
off to another part of the federate, and such hand-off becomes imperative if 
RTlambassador calls are to be made as part of the event handling. 

A frequent design pattern in graphical user-interfaces (GUI) applications is to have 
handlers attached to events. Typically, an event corresponds to a user action, such 
as button click, but events can also correspond to internal state changes or operating 
system messages. Elements of the GUI can be re-used when the context changes, 
simply by changing some of their aspect (e.g. a caption changes from “Log On” to 
“Log Off’) and re-assigning one or more event handlers. This avoids having a 
single larger handler begin with inefficient and repetitive context detection code (if 
such and such flags are set, etc.), and simplifies code maintenance. 


DRDC Valcartier TR 2007-412 


759 









In similar fashion, the FederateAmbassador interface can be broken down into 
sub-interfaces (FederateAmbassador...), each one regrouping callbacks relevant to 
a distinct aspect of the HLA. The sub-interface set is complete, in the sense that the 
FederateAmbassador interface is the union of all the sub-interfaces (every 
FederateAmbassador callback occurs in exactly one of the sub-interfaces, and 
every FederateAmbassador... callback occurs in the FederateAmbassador 
interface). 

We provide a null-like implementation for each such sub-interface, allowing the 
designer to override just those few callbacks of interest to him. To facilitate the 
design further, callbacks that occur in varying forms are “rolled-up” by these 
implementations into the most complete form, substituting nulls where appropriate. 


760 


DRDC Valcartier TR 2007-412 



There is one Validate... interface for each of the FederateAmbassador callbacks. 
Each interface has but one method, validate, which expects the same arguments as 
the callback and throws the same exceptions. When the callback is overloaded 

(initiateFederateSave, ReceiveInteraction, ReflectAttributeValues, 
and RemoveObj ectlnstance), so is the validate method. 


// File: ValidateAnnounceSynchronizationPoint.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rt11516; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateAnnounceSynchronizationPoint 

{ 

j * * 

* Validates the announceSynchronizationPoint callback arguments. 

* @param synchronizationPointLabel a String giving the 
synchronization point's identifier 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#announceSynchronizationPoint 

*/ 

public void 
validate( 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 
throws FederatelnternalError,- 

} 

//end ValidateAnnounceSynchronizationPoint 


DRDC Valcartier TR 2007-412 


761 



// File: ValidateAttributelsNotOwned.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateAttributelsNotOwned 
{ 

j * * 

* Validates the attributelsNotOwned callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttribute an AttributeHandle specifying the attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#attributeIsNotOwned 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 

} 

//end ValidateAttributelsNotOwned 


762 


DRDC Valcartier TR 2007-412 



// File: ValidateAttributelsOwnedByRTI.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateAttributelsOwnedByRTI 
{ 

j * * 

* Validates the attributelsOwnedByRTI callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttribute an AttributeHandle specifying the attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#attributelsOwnedByRTI 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 

} 

//end ValidateAttributelsOwnedByRTI 


DRDC Valcartier TR 2007-412 


763 



// File: ValidateAttributeOwnershipAcquisitionNotification.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateAttributeOwnershipAcquisitionNotification 


764 


DRDC Valcartier TR 2007-412 



* * 


* Validates the attributeOwnershipAcquisitionNotification 
callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param securedAttributes an AttributeHandleSet specifying the 
secured attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAcquisitionWasNotRequested should be thrown if 
the federate repudiates its attribute ownership acquisition request 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeNotPublished should be thrown if the federate 
denies publishing an attribute 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#attributeOwnershipAcquisitionNotificati 
on 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError ,- 

} 

//end ValidateAttributeOwnershipAcquisitionNotification 


DRDC Valcartier TR 2007-412 


765 



// File : ValidateAttributeOwnershipUnavaliable.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateAttributeOwnershipUnavailable 

{ 

j * * 

* Validates the attributeOwnershipUnavailable callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleSet specifying the 
declined attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeAcquisitionWasNotRequested should be thrown if 
the federate repudiates its attribute ownership acquisition request 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#attributeOwnershipUnavailable 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotRequested, 

FederatelnternalError ,- 

} 

//end ValidateAttributeOwnershipUnavaliable 


766 


DRDC Valcartier TR 2007-412 



// File: ValidateAttributesInScope.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateAttributesInScope 
{ 

j * * 

* Validates the attributesInScope callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleSet specifying the 
pertinent attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#attributesInScope 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 

} 

//end ValidateAttributesInScope 


DRDC Valcartier TR 2007-412 


767 



// File: ValidateAttributesOutOfScope.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateAttributesOutOfScope 
{ 

j * * 

* Validates the attributesOutOfScope callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleSet specifying the 
pertinent attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#attributesOutOfScope 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 

} 

//end ValidateAttributesOutOfScope 


768 


DRDC Valcartier TR 2007-412 



// File: ValidateConfirmAttributeOwnershipAcquisitionCancellation.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateConfirmAttributeOwnershipAcquisitionCancellation 

{ 

j * * 

* Validates the confirmAttributeOwnershipAcquisitionCancellation 
callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleSet specifying the 
subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeAcquisitionWasNotCanceled should be thrown if 
the federate repudiates the attribute ownership acquisition 
cancellation 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#confirmAttributeOwnershipAcquisitionCan 
cellation 
*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 

FederatelnternalError ,- 

} 

//end ValidateConfirmAttributeOwnershipAcquisitionCancellation 


DRDC Valcartier TR 2007-412 


769 



// File : ValidateDiscoverObj ectInstance.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateDiscoverOb]ectInstance 
{ 

j * * 

* Validates the discoverObjectlnstance callback. 

* @param theObject the ObjectlnstanceHandle of the newly 
discovered object instance 

* @param theObjectClass the ObjectClassHandle of the class the 
instance was discovered as 

* @param objectName a String holding the newly discovered object 
instance's name 

* @throws CouldNotDiscover should be thrown if the object instance 
could not be discovered for some reason other than an unrecognized 
object class 

* @throws ObjectClassNotRecognized should be thrown if the 
federate does not recognize <code>theObjectClass</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#discoverObjectlnstance 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederatelnternalError ,- 

} 

//end ValidateDiscoverObj ectlnstance 


770 


DRDC Valcartier TR 2007-412 



// File: ValidateFederationNotRestored.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateFederationNotRestored 
{ 

j * * 

* Validates the federationNotRestored callback. 

* @param reason a RestoreFailureReason specifying the reason for 
the failure 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federationNotRestored 

*/ 

public void 
validate( 

RestoreFailureReason reason) 
throws FederatelnternalError,- 

} 

//end ValidateFederationNotRestored 


DRDC Valcartier TR 2007-412 


771 



// File: ValidateFederationNotSaved.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateFederationNotSaved 
{ 

j * * 

* Validates the federationNotSaved callback. 

* @param reason a SaveFailureReason specifying why the save failed 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federationNotSaved 

*/ 

public void 
validate( 

SaveFailureReason reason) 
throws FederatelnternalError,- 

} 

//end ValidateFederationNotSaved 


772 


DRDC Valcartier TR 2007-412 



// File: ValidateFederationRestoreBegun.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateFederationRestoreBegun 
{ 

j * * 

* Validates the federationRestoreBegun callback. 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federationRestoreBegun 

*/ 

public void 
validate() 

throws FederatelnternalError,- 

} 

//end ValidateFederationRestoreBegun 


DRDC Valcartier TR 2007-412 


773 



// File : ValidateFederationRestored.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateFederationRestored 
{ 

j * * 

* Validates the federationRestored callback. 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federationRestored 

*/ 

public void 
validate() 

throws FederatelnternalError,- 

} 

//end ValidateFederationRestored 


774 


DRDC Valcartier TR 2007-412 



// File: ValidateFederationRestoreStatusResponse.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateFederationRestoreStatusResponse 

{ 

j * * 

* Validates the federationRestoreStatusResponse callback. 

* @param response a FederateHandleRestoreStatusPair[] specifying 
the RestoreStatus of each federate 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see 

hla.rtil516.FederateAmbassador#federationRestoreStatusResponse 

*/ 

public void 
validate( 

FederateHandleRestoreStatusPair[] response) 
throws FederatelnternalError,- 

} 

//end ValidateFederationRestoreStatusResponse 


DRDC Valcartier TR 2007-412 


775 



// File : ValidateFederationSaved.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateFederationSaved 
{ 

j * * 

* Validates the federationSaved callback. 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federationSaved 

*/ 

public void 
validate() 

throws FederatelnternalError,- 

} 

//end ValidateFederationSaved 


776 


DRDC Valcartier TR 2007-412 



// File: ValidateFederationSaveStatusResponse.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateFederationSaveStatusResponse 

{ 

j * * 

* Validates the federationSaveStatusResponse callback. 

* @param response a FederateHandleSaveStatusPair[] specifying the 
SaveStatus of each federate 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federatIonSaveStatusResponse 

*/ 

public void 
validate( 

FederateHandleSaveStatusPair[] response) 
throws FederatelnternalError,- 

} 

//end ValidateFederatIonSaveStatusResponse 


DRDC Valcartier TR 2007-412 


777 



// File: ValidateFederationSynchronized.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateFederationSynchronized 
{ 

j * * 

* Validates the federationSynchronized callback arguments. 

* @param synchronizationPointLabel a String giving the 
synchronization point's identifier 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#federationSynchronized 

*/ 

public void 
validate( 

String synchronizationPointLabel) 
throws FederatelnternalError,- 

} 

//end ValidateFederationSynchronized 


778 


DRDC Valcartier TR 2007-412 



// File: ValidatelnformAttributeOwnership.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidatelnformAttributeOwnership 

{ 

j * * 

* Validates the informAttributeOwnership callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttribute an AttributeHandle specifying the attribute 

* @param theOwner the FederateHandle of the federate owning the 
attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#informAttributeOwnership 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute, 

FederateHandle theOwner) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 

} 

//end ValidatelnformAttributeOwnership 


DRDC Valcartier TR 2007-412 


779 



// File: ValidatelnitiateFederateRestore.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidatelnitiateFederateRestore 
{ 

j * * 

* Validates the initiateFederateRestore callback. 

* @param label a String holding the saved state's identifier 

* @param federateHandle the FederateHandle that the federate will 
assume if and once it receives the federationRestored callback 

* @throws SpecifiedSaveLabelDoesNotExist should be thrown if the 
label isn't recognized 

* @throws CouldNotlnitiateRestore should be thrown if the federate 
is unwilling or unable to initiate the restore operation 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#initiateFederateRestore 

*/ 

public void 
validate( 

String label, 

FederateHandle federateHandle) 
throws SpecifiedSaveLabelDoesNotExist, 

CouldNotlnitiateRestore, 

FederatelnternalError ,- 

} 

//end ValidatelnitiateFederateRestore 


780 


DRDC Valcartier TR 2007-412 



// File: ValidatelnitiateFederateSave.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidatelnitiateFederateSave 
{ 

j * * 

* Validates the initiateFederateSave callback arguments (timeless 
form) . 

* @param label a String holding the saved state's identifier 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#initiateFederateSave 

*/ 

public void 
validate( 

String label) 

throws UnableToPerformSave, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


781 



* * 


* Validates the initiateFederateSave callback arguments (timefull 
form) . 

* @param label a String holding the saved state's identifier 

* @param time a LogicalTime specifying when the save was scheduled 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#initiateFederateSave 

*/ 

public void 
validate( 

String label, 

LogicalTime time) 
throws InvalidLogicalTime, 

UnableToPerformSave, 

FederatelnternalError; 

} 

//end ValIdatelnitIateFederateSave 


782 


DRDC Valcartier TR 2007-412 



// File: ValidateObj ectInstanceNameReservationFailed.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateObj ectInstanceNameReservationFailed 

{ 

j * * 

* Validates the objectlnstanceNameReservationFailed callback. 

* @param objectName a String holding the requested object name 

* @throws UnknownName should be thrown if the federate denies 
requesting to reserve the <code>objectName</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#objectInstanceNameReservationFailed 

*/ 

public void 
validate( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError ,- 

} 

//end ValidateObj ectInstanceNameReservationFailed 


DRDC Valcartier TR 2007-412 


783 



// File: ValidateObj ectInstanceNameReservationSucceeded.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateObj ectInstanceNameReservationSucceeded 

{ 

j * * 

* Validates the objectlnstanceNameReservationSucceeded callback. 

* @param objectName a String holding the requested object name 

* @throws UnknownName should be thrown if the federate denies 
requesting to reserve the <code>objectName</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#obj ectInstanceNameReservationSucceeded 

*/ 

public void 
validate( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError ,- 

} 

//end ValidateObj ectInstanceNameReservationSucceeded 


784 


DRDC Valcartier TR 2007-412 



// File: ValidateProvideAttributeValueUpdate.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateProvideAttributeValueUpdate 

{ 

j * * 

* Validates the provideAttributeValueUpdate callback. 

* @param theObject the ObjectlnstanceHandle of the subject object 
instance 

* @param theAttributes an AttributeHandleSet specifying the 
requested attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#provideAttributeValueUpdate 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 

} 

//end ValidateProvideAttributeValueUpdate 


DRDC Valcartier TR 2007-412 


785 



// File: ValidateReceiveInteraction.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface 
ValidateReceiveInteraction 
{ 

j * * 

* Validates the receivelnteraction callback (base form). 

* @param interactionClass the InteractionClassHandle of the 
received interaction 

* @param theParameters a ParameterHandleValueMap specifying the 
interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the interaction was sent as 

* @param theTransport the TransportationType used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#receiveInteraction 

*/ 

public void 
validate( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


786 


DRDC Valcartier TR 2007-412 



* * 


* Validates the receivelnteraction callback (second form). 

* @param interactionClass the InteractionClassHandle of the 
received interaction 

* @param theParameters a ParameterHandleValueMap specifying the 
interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the interaction was sent as 

* @param theTransport the TransportationType used to send the 
interaction 

* @param sentRegions the RegionHandleSet used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#receiveInteraction 

*/ 

public void 
validate( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


787 



* * 


* Validates the receivelnteraction callback (third form). 

* @param interactionClass the InteractionClassHandle of the 
received interaction 

* @param theParameters a ParameterHandleValueMap specifying the 
interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the interaction was sent as 

* @param theTransport the TransportationType used to send the 
interaction 

* @param theTime the LogicalTime at which the interaction occurs 

* @param receivedOrdering the OrderType the passel was received as 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#receiveInteraction 

*/ 

public void 
validate( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


788 


DRDC Valcartier TR 2007-412 



* * 


* Validates the receivelnteraction callback (fourth form). 

* @param interactionClass the InteractionClassHandle of the 
received interaction 

* @param theParameters a ParameterHandleValueMap specifying the 
interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the interaction was sent as 

* @param theTransport the TransportationType used to send the 
interaction 

* @param theTime the LogicalTime at which the interaction occurs 

* @param receivedOrdering the OrderType the passel was received as 

* @param sentRegions the RegionHandleSet used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#receiveInteraction 

*/ 

public void 
validate( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


789 



* * 


* Validates the receivelnteraction callback (fifth form). 

* @param interactionClass the InteractionClassHandle of the 
received interaction 

* @param theParameters a ParameterHandleValueMap specifying the 
interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the interaction was sent as 

* @param theTransport the TransportationType used to send the 
interaction 

* @param theTime the LogicalTime at which the interaction occurs 

* @param receivedOrdering the OrderType the passel was received as 

* @param messageRetractionHandle the MessageRetractionHandle of 
the message 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#receiveInteraction 

*/ 

public void 
validate( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle) 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


790 


DRDC Valcartier TR 2007-412 



* * 


* Validates the receivelnteraction callback (full form). 

* @param interactionClass the InteractionClassHandle of the 
received interaction 

* @param theParameters a ParameterHandleValueMap specifying the 
interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the interaction was sent as 

* @param theTransport the TransportationType used to send the 
interaction 

* @param theTime the LogicalTime at which the interaction occurs 

* @param receivedOrdering the OrderType the passel was received as 

* @param messageRetractionHandle the MessageRetractionHandle of 
the message 

* @param sentRegions the RegionHandleSet used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#receiveInteraction 

*/ 

public void 
validate( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 

} 

//end ValidateReceivelnteraction 


DRDC Valcartier TR 2007-412 


791 



// File: ValidateReflectAttributeValues.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateReflectAttributeValues 
{ 

j * * 

* Validates the reflectAttributeValues callback (base form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleValueMap specifying the 
new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the passel was sent as 

* @param theTransport the TransportationType used to send the 
passel 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#reflectAttributeValues 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


792 


DRDC Valcartier TR 2007-412 



* * 


* Validates the reflectAttributeValues callback (second form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleValueMap specifying the 
new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the passel was sent as 

* @param theTransport the TransportationType used to send the 
passel 

* @param sentRegions the RegionHandleSet used to send the update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#reflectAttributeValues 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


793 



* * 


* Validates the reflectAttributeValues callback (third form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleValueMap specifying the 
new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the passel was sent as 

* @param theTransport the TransportationType used to send the 
passel 

* @param theTime the LogicalTime at which the update comes into 
effect 

* @param receivedOrdering the OrderType the passel was received as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#reflectAttributeValues 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


794 


DRDC Valcartier TR 2007-412 



* * 


* Validates the reflectAttributeValues callback (fourth form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleValueMap specifying the 
new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the passel was sent as 

* @param theTransport the TransportationType used to send the 
passel 

* @param theTime the LogicalTime at which the update comes into 
effect 

* @param receivedOrdering the OrderType the passel was received as 

* @param sentRegions the RegionHandleSet used to send the update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#reflectAttributeValues 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


795 



* * 


* Validates the reflectAttributeValues callback (fifth form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleValueMap specifying the 
new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the passel was sent as 

* @param theTransport the TransportationType used to send the 
passel 

* @param theTime the LogicalTime at which the update comes into 
effect 

* @param receivedOrdering the OrderType the passel was received as 

* @param retractionHandle the MessageRetractionHandle of the 
message 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#reflectAttributeValues 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


796 


DRDC Valcartier TR 2007-412 



* * 


* Validates the reflectAttributeValues callback (full form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param theAttributes an AttributeHandleValueMap specifying the 
new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the passel was sent as 

* @param theTransport the TransportationType used to send the 
passel 

* @param theTime the LogicalTime at which the update comes into 
effect 

* @param receivedOrdering the OrderType the passel was received as 

* @param retractionHandle the MessageRetractionHandle of the 
message 

* @param sentRegions the RegionHandleSet used to send the update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#reflectAttributeValues 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 

} 

//end ValidateReflectAttributeValues 


DRDC Valcartier TR 2007-412 


797 



// File : ValidateRemoveObjectInstance.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateRemoveObj ectInstance 
{ 

j * * 

* Validates the removeObjectlnstance callback (base form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the message was sent as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#removeObj ectlnstance 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag, 

OrderType sentOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError ,- 


798 


DRDC Valcartier TR 2007-412 



* * 


* Validates the removeObjectlnstance callback (second form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the message was sent as 

* @param theTime the LogicalTime at which the deletion occurs 

* @param receivedOrdering the OrderType the message was received 
as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hia.rt11516.FederateAmbassador#removeObj ectlnstance 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


799 



* * 


* Validates the removeObjectlnstance callback (full form). 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the OrderType the message was sent as 

* @param theTime the LogicalTime at which the deletion occurs 

* @param receivedOrdering the OrderType the message was received 
as 

* @param retractionHandle the MessageRetractionHandle of the 
message 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#removeObj ectlnstance 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 

InvalidLogicalTime, 

FederatelnternalError ,- 

} 

//end ValidateRemoveObj ectlnstance 


800 


DRDC Valcartier TR 2007-412 



// File: ValidateRequestAttributeOwnershipAssumption.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valcartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateRequestAttributeOwnershipAssumption 

{ 

j * * 

* Validates the requestAttributeOwnershipAssumption callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param offeredAttributes an AttributeHandleSet specifying the 
offered attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeNotPublished should be thrown if the federate 
denies publishing an attribute 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#requestAttributeOwnershipAssumption 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError ,- 

} 

//end ValidateRequestAttributeOwnershipAssumption 


DRDC Valcartier TR 2007-412 


801 



// File: ValidateRequestAttributeOwnershipRelease.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateRequestAttributeOwnershipRelease 

{ 

j * * 

* Validates the requestAttributeOwnershipRelease callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param candidateAttributes an AttributeHandleSet specifying the 
candidate attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#requestAttributeOwnershipRelease 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet candidateAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 

} 

//end ValidateRequestAttributeOwnershipRelease 


802 


DRDC Valcartier TR 2007-412 



// File: ValidateRequestDivestitureConfirmation.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valcartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateRequestDivestitureConfirmation 

{ 

j * * 

* Validates the requestDivestitureConfirmation callback. 

* @param theObject the ObjectlnstanceHandle of the concerned 
object instance 

* @param offeredAttributes an AttributeHandleSet specifying the 
offered attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws AttributeDivestitureWasNotRequested should be thrown if 
the federate repudiates the divestiture 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#requestDivestitureConfirmation 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested, 

FederatelnternalError ,- 

} 

//end ValidateRequestDivestitureConfirmation 


DRDC Valcartier TR 2007-412 


803 



// File : ValidateRequestFederationRestoreFailed.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateRequestFederationRestoreFailed 

{ 

j * * 

* Validates the requestFederationRestoreFailed callback. 

* @param label a String holding the saved state's identifier 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see 

hla.rtil516.FederateAmbassador#requestFederationRestoreFailed 

*/ 

public void 
validate( 

String label) 

throws FederatelnternalError,- 

} 

//end ValidateRequestFederationRestoreFailed 


804 


DRDC Valcartier TR 2007-412 



// File: ValidateRequestFederationRestoreSucceeded.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateRequestFederationRestoreSucceeded 

{ 

j * * 

* Validates the requestFederationRestoreSucceeded callback. 

* @param label a String holding the saved state's identifier 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see 

hla.rtil516.FederateAmbassador#requestFederationRestoreSucceeded 

*/ 

public void 
validate( 

String label) 

throws FederatelnternalError,- 

} 

//end ValidateRequestFederationRestoreSucceeded 


DRDC Valcartier TR 2007-412 


805 



// File: ValidateRequestRetraction.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateRequestRetraction 
{ 

j * * 

* Validates the requestRetraction callback. 

* @param theHandle the MessageRetractionHandle specifying the 
retracted message 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see hla.rtil516.FederateAmbassador#requestRetraction 

*/ 

public void 
validate( 

MessageRetractionHandle theHandle) 
throws FederatelnternalError,- 

} 

//end ValidateRequestRetraction 


806 


DRDC Valcartier TR 2007-412 



// File: ValidateStartRegistrationForObj ectClass.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateStartRegistrationForObj ectClass 

{ 

j * * 

* Validates the startRegistrationForObjectClass callback. 

* @param theClass the ObjectClassHandle of the subject object 
class 

* @throws ObjectClassNotPublished should be thrown if the federate 
denies publishing <code>theClass</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#startRegistrationForObjectClass 

*/ 

public void 
validate( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError ,- 

} 

//end ValidateStartRegistrationForObj ectClass 


DRDC Valcartier TR 2007-412 


807 



// File: ValidateStopRegistrationForObjectClass.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateStopRegistrationForObj ectClass 

{ 

j * * 

* Validates the stopRegistrationForObjectClass callback. 

* @param theClass the ObjectClassHandle of the subject object 
class 

* @throws ObjectClassNotPublished should be thrown if the federate 
denies publishing <code>theClass</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#stopRegistrationForObjectClass 

*/ 

public void 
validate( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError ,- 

} 

//end ValidateStopRegistrationForObj ectClass 


808 


DRDC Valcartier TR 2007-412 



// File: ValidateSynchronizationPointRegistrationFailed.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateSynchronizationPointRegistrationFailed 

{ 

j * * 

* Validates the synchronizationPointRegistrationFailed callback 
arguments. 

* @param synchronizationPointLabel a String giving the 
synchronization point's identifier 

* @param reason a SynchronizationPointFailureReason specifying 
what went wrong 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see 

hla.rtil516.FederateAmbassador#synchronizationPointRegistrationFailed 

*/ 

public void 
validate( 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 
throws FederatelnternalError,- 

} 

//end ValidateSynchronizatIonPointRegistrationFailed 


DRDC Valcartier TR 2007-412 


809 



// File: ValidateSynchronizationPointRegistrationSucceeded.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateSynchronizationPointRegistrationSucceeded 

{ 

j * * 

* Validates the SynchronizationPointRegistrationSucceeded callback 
arguments. 

* @param synchronizationPointLabel a String giving the 
synchronization point's identifier 

* @throws FederatelnternalError should be thrown if something is 
wrong 

* @see 

hla.rtil516.FederateAmbassador#synchronizationPointRegistrationSucceed 
ed 

*/ 

public void 
validate( 

String synchronizationPointLabel) 
throws FederatelnternalError,- 

} 

//end ValidateSynchronizationPointRegistrationSucceeded 


810 


DRDC Valcartier TR 2007-412 



// File: ValidateTimeAdvanceGrant.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateTimeAdvanceGrant 
{ 

j * * 

* Validates the timeAdvanceGrant callback. 

* @param theTime the LogicalTime to which the federate's clock has 
been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid 

* @throws JoinedFederatelsNotlnTimeAdvancingState should be thrown 
if the federate does not consider itself in the time-advancing state 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#timeAdvanceGrant 

*/ 

public void 
validate( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

JoinedFederatelsNotInTimeAdvancingState, 
FederatelnternalError ,- 

} 

//end ValidateTimeAdvanceGrant 


DRDC Valcartier TR 2007-412 


811 



// File: ValidateTimeConstrainedEnabled.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateTimeConstrainedEnabled 
{ 

j * * 

* Validates the timeConstrainedEnabled callback. 

* @param time the LogicalTime to which the federate's clock has 
been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws NoRequestToEnableTimeConstrainedWasPending should be 
thrown if the federate repudiates the time constraint request 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#timeConstrainedEnabled 

*/ 

public void 
validate( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeConstrainedWasPending, 
FederatelnternalError ,- 

} 

//end ValidateTimeConstrainedEnabled 


812 


DRDC Valcartier TR 2007-412 



// File: ValidateTimeRegulationEnabled.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateTimeRegulationEnabled 
{ 

j * * 

* Validates the timeRegulationEnabled callback. 

* @param time the LogicalTime to which the federate's clock has 
been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid 

* @throws NoRequestToEnableTimeRegulationWasPending should be 
thrown if the federate repudiates the time regulation request 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#timeRegulationEnabled 

*/ 

public void 
validate( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeRegulationWaspending, 
FederatelnternalError ,- 

} 

//end ValidateTimeRegulationEnabled 


DRDC Valcartier TR 2007-412 


813 



// File: ValidateTurnlnteractionsOff.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateTurnlnteractionsOff 
{ 

j * * 

* Validates the turnlnteractionsOff callback. 

* @param theHandle the InteractionClassHandle of the subject 
interaction class 

* @throws InteractionClassNotPublished should be thrown if the 
federate denies publishing <code>theHandle</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#turnInteractionsOff 

*/ 

public void 
validate( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError ,- 

} 

//end ValidateTurnlnteractionsOff 


814 


DRDC Valcartier TR 2007-412 



// File: ValidateTurnlnteractionsOn.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 
ValidateTurnlnteractionsOn 
{ 

j * * 

* Validates the turnlnteractionsOn callback. 

* @param theHandle the InteractionClassHandle of the subject 
interaction class 

* @throws InteractionClassNotPublished should be thrown if the 
federate denies publishing <code>theHandle</code> 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see hla.rtil516.FederateAmbassador#turnlnteractionsOn 

*/ 

public void 
validate( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError ,- 

} 

//end ValidateTurnlnteractionsOn 


DRDC Valcartier TR 2007-412 


815 



// File: ValidateTurnUpdatesOffForObj ectInstance.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate!), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateTurnUpdatesOffForObj ectInstance 

{ 

j * * 

* Validates the turnUpdatesOffForObjectlnstance callback. 

* @param theObject the ObjectlnstanceHandle of the subject object 
instance 

* @param theAttributes an AttributeHandleSet specifying the 
subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#turnUpdatesOffForObjectlnstance 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 

} 

//end ValidateTurnUpdatesOffForObj ectlnstance 


816 


DRDC Valcartier TR 2007-412 



// File: ValidateTurnUpdatesOnForObj ectInstance.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* This interface is meant to be implemented by validation handlers; 

* these are called first by the callback handler. 

* In each case, there is but one method: validate(), which accepts 

* the same arguments as the corresponding callback (overloaded as 

* needed). Likewise, the method throws the same exceptions as the 

* callback. If no exception is thrown, all is well. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public interface 

ValidateTurnUpdatesOnForOb]ectInstance 

{ 

j * * 

* Validates the turnUpdatesOnForObjectlnstance callback. 

* @param theObject the ObjectlnstanceHandle of the subject object 
instance 

* @param theAttributes an AttributeHandleSet specifying the 
subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
is wrong 

* @see 

hla.rtil516.FederateAmbassador#turnUpdatesOnForObjectlnstance 

*/ 

public void 
validate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 

} 

//end ValidateTurnUpdatesOnForObj ectlnstance 


DRDC Valcartier TR 2007-412 


817 



The FederateAmbassadorSynchronization interface is the 
FederateAmbassador part devoted to the federation synchronization callbacks. 


// File: FederateAmbassadorSynchronization.java 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Synchronization callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorSynchronization 


// Federation Management Services - Synchronization 


II 4.7 

j * * 

* Notifies the federate that it has successfully registered a 
federation synchronization point. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see #announceSynchronizationPoint announceSynchronizationPoint 

* @see #federationSynchronized federationSynchronized 

*/ 

public void 

synchronizationPointRegistrationSucceeded( 

String synchronizationPointLabel) 

throws FederatelnternalError; 


818 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that it has failed to registered a 
federation synchronization point. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @param reason a {@link SynchronizationPointFailureReason} 
specifying what went wrong 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see #announceSynchronizationPoint announceSynchronizationPoint 

* @see #federationSynchronized federationSynchronized 

*/ 

public void 

synchronizationPointRegistrationFailed( 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 
throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


819 



* Notifies the federate that a synchronization point exists. 

* Achievement of the point is signalled to the RTI through the 

* {@link RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved} method. 

* <p> 

* Federates are by default part of the synchronization set, unless 
a {@link FederateHandleSet} has been specifically 

* supplied to the {@link 

RTIambassador#registerFederationSynchronizationPoint(String,byte[],Fed 
erateHandleSet)} method. 

* A federate that resigns is simply removed from the 
synchronization set. 

* The synchronization point exists until it has been achieved by 
all concerned federates, which could be 

* until the federation execution concludes. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see #synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see #federationSynchronized federationSynchronized 

*/ 

public void 

announceSynchronizationPoint( 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 
throws FederatelnternalError,- 


820 


DRDC Valcartier TR 2007-412 



* * 


* Informs the joined federate that all members of the 
synchronization set of the specified synchronization point 

* have invoked the {@link 
RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved} method for that point. 

* The synchronization point ceases to exist once this callback has 
been invoked on all concerned federates. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see RTIambassador#synchronizationPointAchieved 
synchronizationPointAchieved 

* @see #synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see #synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

* @see #announceSynchronizationPoint announceSynchronizationPoint 
*/ 

public void 

federationSynchronized( 

String synchronizationPointLabel) 
throws FederatelnternalError; 

} 

//end FederateAmbassadorSynchronization 


DRDC Valcartier TR 2007-412 


821 



The FederateAmbassadorSave interface is the FederateAmbassador part 
devoted to the federation save callbacks. 


// File : FederateAmbassadorSave.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Save callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorSave 


822 


DRDC Valcartier TR 2007-412 



// Federation Management Services 


Save 


1111111111111111111111111111111111111111 

// 4.12 

j * * 

* Instructs the joined federate that it is now in the Instructed 
To Save state 

* and should therefore save state as soon as possible. 

* The joined federate should use the supplied <code>label</code>, 

* the name of the federation execution (see the 
<code>federationExecutionName</code> 

* of the {@link RTIambassador#joinFederationExecution 
joinFederationExecution} invocation), 

* its joined federate designator (returned by the aforementioned 
invocation) and 

* its federate type (the aforementioned invocation's 
<code>federateType</code> argument) 

* to distinguish the saved state information. 

* <p> 

* A federate that is not time constrained should expect this 
callback at any point. 

* A time constrained federate can receive this callback only 
whilst in the Time Advancing state. 

* Once in the Instructed To Save state, the federate is severely 
limited in which RTIambassador 

* methods it can invoke. This lasts through the Saving and Waiting 
For Federation To Save states, 

* concluding with the {@link #federationSaved federationSaved} or 

* {@link #federationNotSaved federationNotSaved} callbacks. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 
initiateFederateSave( 

String label) 

throws UnableToPerformSave, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


823 



* * 


* Instructs the joined federate that it is now in the Instructed 
To Save state 

* (as of the specified <code>time</code>) and should therefore 
save state as soon as possible. 

* <p> 

* For details, see the {@link #initiateFederateSave(String)} 
callback. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param time a {@link LogicalTime} specifying when the save was 
scheduled 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #federationSaved federationSaved 

* @see #federationNotSaved federationNotSaved 

* @see #federationSaveStatusResponse federationSaveStatusResponse 

*/ 

public void 
initiateFederateSave( 

String label, 

LogicalTime time) 
throws InvalidLogicalTime, 

UnableToPerformSave, 

FederatelnternalError ,- 


824 


DRDC Valcartier TR 2007-412 



II 4.15 

j * * 

* Informs the joined federate that the federation save process is 
complete and successfull. 

* <p> 

* All joined federates at which the {@link #initiateFederateSave 
initiateFederateSave} callback 

* was invoked have in turn invoked the {@link 
RTIambassador#federateSaveComplete federateSaveComplete} method. 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #initiateFederateSave initiateFederateSave 

* @see #federationNotSaved federationNotSaved 

* @see #federationSaveStatusResponse federationSaveStatusResponse 

*/ 

public void 

federationSaved() 

throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


825 



* * 


* Informs the joined federate that the federation save process has 
completed in failure. 

* <p> 

* The possible save failure reasons are: 

* <ul > 

* <li> RTI_UNABLE_TO_SAVE: The RTI was unable to save 

* <li> FEDERATE_REPORTED_FAILURE: One or more joined federates 
have invoked the {@link RTIambassador#federateSaveNotComplete 
federateSaveNotComplete} method 

* <li> FEDERATE_RESIGNED: One or more joined federates have 
resigned from the federation execution 

* <li> RTI_DETECTED_FAILURE: The RTI has detected failure at one 
or more of the joined federates 

* <li> SAVE_TIME_CANNOT_BE_HONORED: The time stamp specified by 
the {@link RTIambassador#requestFederationSave(String,LogicalTime)} 

* request cannot be honored, due to possible race conditions in 
the distributed calculation of GALT (Greatest Available Logical Time) 

* </ul> 

* @param reason a {@link SaveFailureReason} specifying why the 
save failed 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #initiateFederateSave initiateFederateSave 

* @see #federationSaved federationSaved 

* @see #federationSaveStatusResponse federationSaveStatusResponse 

*/ 

public void 
federationNotSaved( 

SaveFailureReason reason) 
throws FederatelnternalError,- 


826 


DRDC Valcartier TR 2007-412 



II 4.17 

j * * 

* Supplies the federate with the previously requested save status 
indicators. 

* @param response a {@link FederateHandleSaveStatusPair}[] 
specifying the {@link SaveStatus} of each federate 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationSave requestFederationSave 

* @see RTIambassador#federateSaveBegun federateSaveBegun 

* @see RTIambassador#federateSaveComplete federateSaveComplete 

* @see RTIambassador#federateSaveNotComplete 
federateSaveNotComplete 

* @see RTIambassador#queryFederationSaveStatus 
queryFederationSaveStatus 

* @see #initiateFederateSave InitiateFederateSave 

* @see #federationSaved federationSaved 

* @see #federationNotSaved federationNotSaved 
*/ 

public void 

federationSaveStatusResponse( 

FederateHandleSaveStatusPair[] response) 
throws FederatelnternalError; 

} 

//end FederateAmbassadorSave 


DRDC Valcartier TR 2007-412 


827 



The FederateAmbassadorRestore interface is the FederateAmbassador part 
devoted to the federation restoration callbacks. 


// File : FederateAmbassadorRestore.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Restore callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorRestore 


828 


DRDC Valcartier TR 2007-412 



1111111111111111111111111111111111111111111 

// Federation Management Services - Restore 


// 4.19 

j * * 

* Indicates that the federate's previous {@link 
RTIambassador#requestFederationRestore requestFederationRestore} has 
been granted. 

* <p> 

* This means the RTI has located the RTI-specific saved state 
information matching the previously supplied 

* <code>label</code>, {@link RTIambassador#]oinFederationExecution 

federationExecutionName} and 

* {@link RTIambassador#createFederationExecution fdd}, and that 
the census of currently joined 

* federates matches in number and {@link 
RTIambassador#joinFederationExecution federateType} that of the 

* RTI's saved state. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

requestFederationRestoreSucceeded( 

String label) 

throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


829 



* Indicates that the federate's previous {@link 
RTIambassador#requestFederationRestore requestFederationRestore} has 
been denied. 

* <p> 

* This means the RTI failed to locate its specific saved state 
information or that the census of 

* currently joined federates does not match in number and {@link 
RTIambassador#]oinFederationExecution federateType} 

* that of the retrieved RTI saved state. 

* Failures by individual federates to complete the restoration 
process lead to the 

* {@link #federationNotRestored federationNotRestored} callback 
instead. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestorestatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 

requestFederationRestoreFailed( 

String label) 

throws FederatelnternalError; 


830 


DRDC Valcartier TR 2007-412 



* * 


* Instructs the joined federate that it is now in the Prepared To 
Restore state 

* and should prepare to proceed with saved state restoration. The 
necessary information 

* is later provided by the {@link #initiateFederateRestore 
initiateFederateRestore} callback. 

* <p> 

* Once in the Prepared To Restore state, the federate is severely 
limited in which RTIambassador 

* methods it can invoke. This lasts through the Restoring and 
Waiting For Federation To Restore states, 

* concluding with the {@link #federationRestored 
federationRestored} or 

* {@link #federationNotRestored federationNotRestored} callbacks. 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

federationRestoreBegun() 
throws FederatelnternalError,- 


DRDC Valcartier TR 2007-412 


831 



II 4.21 

j * * 

* Instructs the joined federate to return to a previously saved 
state. 

* The joined federate should use the supplied <code>label</code>, 

* the name of the federation execution (see the 
<code>federationExecutionName</code> 

* of the {@link RTIambassador#joinFederationExecution 
joinFederationExecution} invocation), 

* the supplied federate designator (<code>federateHandle</code>) 

and 

* its federate type (the aforementioned invocation's 
<code>federateType</code> argument) 

* to retrieve the saved state information. 

* <p> 

* Note that the supplied <code>federateHandle</code> may differ 
from the federate's current {@link FederateHandle}; 

* it will assume this new designator if and once it receives the 
{@link #federationRestored federationRestored} callback. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param federateHandle the {@link FederateHandle} that the 
federate will assume if and once it receives the {@link 

#federationRestored federationRestored} callback 

* @throws SpecifiedSaveLabelDoesNotExist should be thrown if the 
label isn't recognized 

* @throws CouldNotlnitiateRestore should be thrown if the federate 
is unwilling or unable to initiate the restore operation 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestorestatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 

initiateFederateRestore( 

String label, 

FederateHandle federateHandle) 

throws SpecifiedSaveLabelDoesNotExist, 

CouldNotlnitiateRestore, 

FederatelnternalError; 


832 


DRDC Valcartier TR 2007-412 



// 4.23 

j * * 

* Informs the joined federate that the federation restore process 
is complete and successfull. 

* This means that all joined federates which received the {@link 
#federationRestoreBegun federationRestoreBegun} 

* callback have invoked the {@link 

RTIambassador#federateRestoreComplete federateRestoreComplete} method. 

* The federate's {@link FederateHandle} is now the one that was 
supplied by the {@link #initiateFederateRestore 

initiateFederateRestore} callback. 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationNotRestored federationNotRestored 

* @see #federationRestoreStatusResponse 
federationRestoreStatusResponse 

*/ 

public void 

federationRestored () 

throws FederatelnternalError; 


DRDC Valcartier TR 2007-412 


833 



* Informs the joined federate that the federation restore process 
has completed in failure. 

* <p> 

* The possible save failure reasons are: 

* <ul > 

* <li> RTI_UNABLE_TO_RESTORE: The RTI was unable to restore 

* <li> FEDERATE_REPORTED_FAILURE: One or more federates have 
invoked the {@link RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete} method 

* <li> FEDERATE_RESIGNED: One or more joined federates have 
resigned from the federation execution 

* <li> RTI_DETECTED_FAILURE: The RTI has detected failure at one 
or more of the joined federates 

* </ul> 

* @param reason a {@link RestoreFailureReason} specifying the 
reason for the failure 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestorestatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationRestorestatusResponse 
federationRestorestatusResponse 

*/ 

public void 
federationNotRestored( 

RestoreFailureReason reason) 
throws FederatelnternalError; 


834 


DRDC Valcartier TR 2007-412 



// 4.25 

j * * 

* Supplies the federate with the previously requested restore 
status indicators. 

* @param response a {@link FederateHandleRestoreStatusPair} [] 
specifying the {@link RestoreStatus} of each federate 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see RTIambassador#federateRestoreComplete 
federateRestoreComplete 

* @see RTIambassador#federateRestoreNotComplete 
federateRestoreNotComplete 

* @see RTIambassador#queryFederationRestoreStatus 
queryFederationRestoreStatus 

* @see #requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see #requestFederationRestoreFailed 
requestFederationRestoreFailed 

* @see #federationRestoreBegun federationRestoreBegun 

* @see #initiateFederateRestore initiateFederateRestore 

* @see #federationRestored federationRestored 

* @see #federationNotRestored federationNotRestored 
*/ 

public void 

federationRestoreStatusResponse( 

FederateHandleRestoreStatusPair[] response) 
throws FederatelnternalError; 

} 

//end FederateAmbassadorRestore 


DRDC Valcartier TR 2007-412 


835 



The FederateAmbassadorObj ectRegistrat ionAdvisory interface is the 
FederateAmbassador part devoted to the object class relevance advisories. 


// File: FederateAmbassadorObj ectRegistrationAdvisory.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the object class relevance advisories (i.e. the 
Registration Advisory callbacks). 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorObj ectRegistrationAdvisory 


// Declaration Management Services - Registration Advisories 


// 5.10 

j * * 

* Notifies the federate that registration of new object instances 
of the specified object class 

* is advised because at least one of the federate-published class 
attributes is actively subscribed to 

* by at least one other federate. 

* This occurs only if the federate's Object Class Relevance 
Advisory Switch is turned on. 

* @param theClass the {@link ObjectClassHandle} of the subject 
object class 

* @throws ObjectClassNotPublished should be thrown if the federate 
denies publishing <code>theClass</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #stopRegistrationForObj ectClass 
stopRegistrationForObj ectClass 

* @see RTIambassador#enableObjectClassRelevanceAdvisorySwitch 
enableObj ectClassRelevanceAdvisorySwitch 

* @see RTIambassador#disableObj ectClassRelevanceAdvisorySwitch 
disableObj ectClassRelevanceAdvisorySwitch 

*/ 

public void 

startRegistrationForObj ectClass( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError; 


836 


DRDC Valcartier TR 2007-412 



II 5.11 

j * * 

* Notifies the federate that registration of new object instances 
of the specified object class 

* is not advised because there are no active subscribers to any of 
the federate-published class attributes. 

* This occurs only if the federate's Object Class Relevance 
Advisory Switch is turned on. 

* @param theClass the {@link ObjectClassHandle} of the subject 
object class 

* @throws ObjectClassNotPublished should be thrown if the federate 
denies publishing <code>theClass</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #startRegistrationForObj ectClass 
startRegistrationForObj ectClass 

* @see RTIambassador#enableObjectClassRelevanceAdvisorySwitch 
enableObj ectClassRelevanceAdvisorySwitch 

* @see RTIambassador#disableObj ectClassRelevanceAdvisorySwitch 
disableObj ectClassRelevanceAdvisorySwitch 

*/ 

public void 

stopRegistrationForObjectClass( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError; 

} 

//end FederateAmbassadorObjectRegistrationAdvisory 


DRDC Valcartier TR 2007-412 


837 



The FederateAmbassadorlnteractionAdvisory interface is the 
FederateAmbassador part devoted to the server (publisher) interaction scope 
advisories. 


// File : FederateAmbassadorInteractionAdvisory.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Interaction Scope Advisory callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorInteractionAdvisory 


// Declaration Management Services - Interaction Advisory 


// 5.12 

j * * 

* Notifies the federate that the specified class of interactions 
is relevant because 

* there is at least one active subscription by another federate. 

* This occurs only if the federate's Interaction Relevance 
Advisory Switch is turned on. 

* @param theHandle the {@link InteractionClassHandle} of the 
subject interaction class 

* @throws InteractionClassNotPublished should be thrown if the 
federate denies publishing <code>theHandle</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnInteractionsOff turnlnteractionsOff 

* @see RTIambassador#enableInteractionRelevanceAdvisorySwitch 
enableInteractionRelevanceAdvisorySwitch 

* @see RTIambassador#disablelnteractionRelevanceAdvisorySwitch 
disableInteractionRelevanceAdvisorySwitch 

*/ 

public void 
turnlnteractionsOn( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError; 


838 


DRDC Valcartier TR 2007-412 



// 5.13 

j * * 

* Notifies the federate that the specified class of interactions 
is not relevant because 

* there are no active subscriptions by other federates. 

* This occurs only if the federate's Interaction Relevance 
Advisory Switch is turned on. 

* @param theHandle the {@link InteractionClassHandle} of the 
subject interaction class 

* @throws InteractionClassNotPublished should be thrown if the 
federate denies publishing <code>theHandle</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnInteractionsOn turnlnteractionsOn 

* @see RTIambassador#enableInteractionRelevanceAdvisorySwitch 
enableInteractionRelevanceAdvisorySwitch 

* @see RTIambassador#disableInteractionRelevanceAdvisorySwitch 
disableInteractionRelevanceAdvisorySwitch 

*/ 

public void 
turnlnteractionsOff( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError; 

} 

//end FederateAmbassadorlnteractionAdvisory 


DRDC Valcartier TR 2007-412 


839 



The FederateAmbassadorNameReservation interface is the 
FederateAmbassador part devoted to the name reservation outcome callbacks. 


// File: FederateAmbassadorNameReservation.java 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Name Reservation callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorNameReservation 


// Object Management Services - Name Reservation 


j * * 

* Notifies the federate that the <code>objectName</code> provided 
in a previous invocation of the 

* {@link RTIambassador#reserveObjectInstanceName 
reserveObjectInstanceName} method has been reserved. 

* <p> 

* DoD Interpretations of IEEE 1516-2000v2 changes the service name 
from "<code>obj ectInstanceNameReservationSuccededc/code> 11 

* to 11 <code>ob j ect Ins t anceNameReserva tionSucceeded</code > 11 . 

* @param objectName a {@link java.lang.String} holding the 
requested object name 

* @throws UnknownName should be thrown if the federate denies 
requesting to reserve the <code>objectName</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#reserveObjectInstanceName 
reserveObj ectInstanceName 

* @see #obj ectlnstanceNameReservationFailed 
obj ectInstanceNameReservationFailed 

*/ 

public void 

obj ectlnstanceNameReservationSucceeded( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError; 


840 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that the <code>objectName</code> provided 
in a previous invocation of the 

* {@link RTIambassador#reserveObj ectlnstanceName 
reserveObjectlnstanceName} method could not be reserved. 

* @param objectName a {@link java.lang.String} holding the 
requested object name 

* @throws UnknownName should be thrown if the federate denies 
requesting to reserve the <code>objectName</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#reserveObj ectlnstanceName 
reserveObj ectlnstanceName 

* @see #obj ectInstanceNameReservationSucceeded 
obj ectInstanceNameReservationSucceeded 

*/ 

public void 

obj ectlnstanceNameReservationFailed( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError; 

} 

//end FederateAmbassadorNameReservation 


DRDC Valcartier TR 2007-412 


841 



The FederateAmbassadorObj ectDiscovery interface is the 
FederateAmbassador part devoted to the object discovery callbacks. 


// File: FederateAmbassadorObj ectDiscovery.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Object Discovery callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorObj ectDiscovery 


// Object Management Services - Object Discovery 


j * * 

* Notifies the federate that it has discovered an object instance. 

* @param theObject the {@link ObjectInstanceHandle} of the newly 
discovered object instance 

* @param theObjectClass the {@link ObjectClassHandle} of the class 
the instance was discovered as 

* @param objectName a {@link java.lang.String} holding the newly 
discovered object instance's name 

* @throws CouldNotDiscover should be thrown if the object instance 
could not be discovered for some reason other than an unrecognized 
object class 

* @throws ObjectClassNotRecognized should be thrown if the 
federate does not recognize <code>theObjectClass</code> 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#registerObj ectInstance registerObj ectInstance 

*/ 

public void 

discoverObjectlnstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorObj ectDiscovery 


842 


DRDC Valcartier TR 2007-412 



The FederateAmbassadorAttributeUpdateClient interface is the 
FederateAmbassador part devoted to the client (subscriber) object instance 
attribute updates. 


// File: FederateAmbassadorAttributeUpdateClient.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Instance Attribute Update (Receive) callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorAttributeUpdateClient 


// Object Management Services - Instance Attribute Update (Receive) 


j * * 

* Provides the federate with new values for the specified instance 
attributes. 

* This callback, coupled with the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 
<code>sentOrdering</code> and <code>theTransport</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


843 



* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[] ) 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


844 


DRDC Valcartier TR 2007-412 



* Provides the federate with new values for the specified instance 
attributes 

* and specifies the update regions used. 

* This callback, coupled with the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided, 

* the instance attributes have available dimensions, the 
federate's Convey Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType}, {@link InvalidRegion} or 
{@link InvalidRegionContext} 

* exceptions (nor a notional new <code>InvalidRegionSet</code> 
exception) ,- in other words the RTI 

* guarantees the validity and pertinence of the supplied 
<code>sentOrdering</code>, 

* <code>theTransport</code> and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


845 



* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[] ) 

* @see RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


846 


DRDC Valcartier TR 2007-412 



* Provides the federate with new values for the specified instance 
attributes 

* and specifies the time-stamp at which this comes into effect. 

* This callback, coupled with the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the <code>receivedOrdering</code> is also 
RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType} or {@link InvalidLogicalTime} 

* exceptions; in other words the RTI guarantees the validity of 
the supplied 

* <code>sentOrdering</code>, <code>theTransport</code>, 

<code>theTimec/code> 

* and <code>receivedOrdering</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


847 



* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


848 


DRDC Valcartier TR 2007-412 



* Provides the federate with new values for the specified instance 
attributes, 

* specifies the update regions used 

* and specifies the time-stamp at which this comes into effect. 

* This callback, coupled with the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided, 

* the instance attributes have available dimensions, the 
federate's 

* Convey Region Designator Sets Switch is enabled and an update 
region set 

* was used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the <code>receivedOrdering</code> is also 
RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType}, {@link InvalidLogicalTime}, 
{@link InvalidRegion} or 

* {@link InvalidRegionContext} exceptions (nor a notional new 
<code>InvalidRegionSet</code> 

* exception) ,- in other words the RTI guarantees the validity of 
the supplied 

* <code>sentOrdering</code>, <code>theTransport</code>, 

<code>theTimec/code>, 

* <code>receivedOrdering</code> and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


849 



* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

* @see RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


850 


DRDC Valcartier TR 2007-412 



* Provides the federate with new values for the specified instance 
attributes 

* and specifies the time-stamp at which this comes into effect as 
well as a retraction handle. 

* This callback, coupled with the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided) 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType} or {@link 
InvalidMessageRetractionHandle} exceptions ,- 

* in other words the RTI guarantees the validity of the supplied 

* <code>sentOrdering</code>, <code>theTransport</code>, 
<code>receivedOrdering</code> and 

* <code>retractionHandlec/code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


851 



* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


852 


DRDC Valcartier TR 2007-412 



* Provides the federate with new values for the specified instance 
attributes, 

* specifies the update regions used 

* and specifies the time-stamp at which this comes into effect as 
well as a retraction handle. 

* This callback, coupled with the {@link 
RTIambassador#updateAttributeValues updateAttributeValues} method, 

* forms the primary data exchange mechanism supported by the RTI. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided), 

* the instance attributes have available dimensions, the 
federate's Convey Region Designator Sets Switch 

* is enabled and an update region set was used by the sender. 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType}, {@link 
InvalidMessageRetractionHandle}, 

* {@link InvalidRegion} or {@link InvalidRegionContext} exceptions 
(nor a notional 

* new <code>InvalidRegionSet</code> exception); in other words the 
RTI guarantees the validity 

* of the supplied <code>sentOrdering</code>, 
<code>theTransport</code>, <code>receivedOrdering</code>, 

* <code>retractionHandle</code> and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


853 



* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#updateAttributeValues(Obj ectInstanceHandle,AttributeHand 
leValueMap,byte[],LogicalTime) 

* @see RTIambassador#associateRegionsForUpdates 
associateRegionsForUpdates 

*/ 

public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorAttributeUpdateClient 


854 


DRDC Valcartier TR 2007-412 



The FederateAmbassadorlnteractionOccurrence interface is the 
FederateAmbassador part devoted to interaction occurrence reception. 


// File: FederateAmbassadorInteractionOccurrence.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Interaction Update callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorInteractionOccurrence 


// Object Management Services - Interaction Update 


j * * 

* Provides the federate with a sent interaction. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 
<code>sentOrdering</code> and <code>theTransport</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


855 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[]) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


856 


DRDC Valcartier TR 2007-412 



* Provides the federate with a sent interaction and 

* specifies the broadcasting regions used. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* no time-stamp was provided, 

* the parameters have available dimensions, the federate's Convey 
Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType}, {@link InvalidRegion} or 
{@link InvalidRegionContext} exceptions 

* (nor a notional new <code>InvalidRegionSet</code> exception); in 
other words the RTI guarantees 

* the validity of the supplied <code>sentOrdering</code>, 
<code>theTransport</code> 

* and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


857 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteractionWithRegions(InteractionClassHandle,Parame 
terHandleValueMap,RegionHandleSet,byte[] ) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


858 


DRDC Valcartier TR 2007-412 



* Provides the federate with a sent interaction 

* and specifies the time-stamp at which this occurs. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 
<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType} or {@link InvalidLogicalTime} 
exceptions; in other words the 

* RTI guarantees the validity of the supplied 
<code>sentOrdering</code>, <code>theTransport</code>, 

* <code>receivedOrdering</code> and <code>theTime</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


859 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[],LogicalTime) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


860 


DRDC Valcartier TR 2007-412 



* Provides the federate with a sent interaction, 

* specifies the broadcasting regions used 

* and specifies the time-stamp at which this occurs. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE, 

* a time-stamp was provided, 

* the parameters have available dimensions, the federate's Convey 
Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* absence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is RECEIVE 

* (and that therefore the received ordering is also RECEIVE). 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 
<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType}, {@link InvalidLogicalTime}, 
{@link InvalidRegion} or 

* {@link InvalidRegionContext} exceptions (nor a notional new 
<code>InvalidRegionSet</code> exception) ,- 

* in other words the RTI guarantees the validity of the supplied 
<code>sentOrdering</code>, 

* <code>theTransport</code>, <code>receivedOrdering</code>, 

<code>theTimec/code> 

* and <code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


861 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteractionWithRegions(InteractionClassHandle,Parame 
terHandleValueMap,RegionHandleSet,byte[],LogicalTime) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

FederatelnternalError ,- 


862 


DRDC Valcartier TR 2007-412 



* Provides the federate with a sent interaction 

* and specifies the time-stamp at which this occurs as well as a 
retraction handle. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided) 

* and an update region set was not used by the sender (or is not 
pertinent or is 

* being filtered out by the receiver). 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 
<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType} or {@link 
InvalidMessageRetractionHandle} exceptions; 

* in other words the RTI guarantees the validity of the supplied 
<code>sentOrdering</code>, 

* <code>theTransport</code>, <code>receivedOrdering</code> and 
<code>messageRetractionHandle</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


863 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param messageRetractionHandle the {@link 
MessageRetractionHandle} of the message 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see 

RTIambassador#sendInteraction(InteractionClassHandle,ParameterHandleVa 
lueMap,byte[],LogicalTime) 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle) 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 


864 


DRDC Valcartier TR 2007-412 



* Provides the federate with a sent interaction, 

* specifies the broadcasting regions used 

* and specifies the time-stamp at which this occurs as well as a 
retraction handle. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (thus a time-stamp was provided), 

* the parameters have available dimensions, the federate's Convey 
Region 

* Designator Sets Switch is enabled and an update region set was 
used by the sender. 

* <p> 

* Note that the 

* presence of a {@link MessageRetractionHandle} implies the 
<code>sentOrdering</code> is TIMESTAMP. 

* <p> 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} or 

* {@link InvalidTransportationType} exceptions; in other words the 

RTI 

* guarantees the validity of the supplied 
<code>sentOrdering</code> and <code>theTransport</code>. 

* Note that the federate is not expected to throw the {@link 
InvalidOrderType} , 

* {@link InvalidTransportationType}, {@link 
InvalidMessageRetractionHandle}, 

* {@link InvalidRegion} or {@link InvalidRegionContext} exceptions 
(nor a notional 

* new <code>InvalidRegionSet</code> exception); in other words the 
RTI guarantees the validity 

* of the supplied <code>sentOrdering</code>, 
<code>theTransport</code>, <code>receivedOrdering</code>, 

* <code>messageRetractionHandle</code> and 
<code>sentRegions</code>. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 


DRDC Valcartier TR 2007-412 


865 



* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param messageRetractionHandle the {@link 
MessageRetractionHandle} of the message 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws InteractionClassNotRecognized should be thrown if the 
federate does not recognize the interaction class 

* @throws InteractionParameterNotRecognized should be thrown if 
one of the supplied parameters isn't recognized in the supplied 
context 

* @throws InteractionClassNotSubscribed should be thrown if the 
federate denies subscribing to the interaction 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#sendInteractionWithRegions 
sendlnteractionWithRegions 

*/ 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 

ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorlnteractionOccurrence 


866 


DRDC Valcartier TR 2007-412 



The FederateAmbassadorObj ectRemoval interface is the FederateAmbassador 

part devoted to the object instance removal callbacks. 


// File: FederateAmbassadorObj ectRemoval.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rtil516.FederateAmbassador interface that 
contains only the Object Removal callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorObj ectRemoval 


// Object Management Services - Object Removal 


II 6.11 

j * * 

* Notifies the federate that an object instance has been deleted 
from the federation execution. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE 

* and no time-stamp was provided. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#deleteObjectInstance deleteObj ectInstance 

*/ 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag, 

OrderType sentOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


867 



* * 


* Notifies the federate that an object instance has been deleted 
from the federation execution 

* at the specified time stamp. 

* This form is invoked by the RTI only if the sent order type was 
RECEIVE 

* and a time-stamp was provided. 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @param theTime the {@link LogicalTime} at which the deletion 
occurs 

* @param receivedOrdering the {@link OrderType} the message was 
received as 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#deleteObj ectInstance deleteObj ectInstance 

*/ 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError ,- 


868 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that an object instance has been deleted 
from the federation execution 

* at the specified time stamp and specifies a retraction handle. 

* This form is invoked by the RTI only if the sent order type was 
TIMESTAMP 

* (and thus a time-stamp was provided). 

* <p> 

* The time stamp and receive message order type arguments are 
supplied together or not at all, 

* which explains the absence of some other possible forms of this 
callback. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @param theTime the {@link LogicalTime} at which the deletion 
occurs 

* @param receivedOrdering the {@link OrderType} the message was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid (only if the 
<code>receivedOrdering</code> is TIMESTAMP) 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#deleteObj ectInstance deleteObj ectInstance 

*/ 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 

InvalidLogicalTime, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorObjectRemoval 


DRDC Valcartier TR 2007-412 


869 



The FederateAmbassadorAttributeScopeAdvisoryClient interface is the 
FederateAmbassador part devoted to the client (subscriber) object instance 
attribute scope advisories. 


// File : FederateAmbassadorAttributeScopeAdvisoryCllent.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Instance Attribute Scope Advisory callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorAttributeScopeAdvisoryClient 


870 


DRDC Valcartier TR 2007-412 



// Object Management Services - Instance Attribute Scope Advisory 
(Receive) 


// 6.15 

j * * 

* Notifies the federate that the specified attributes for the 
object instance are in its scope. 

* This occurs only if the Attribute Scope Advisory Switch is on 
for the federate. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the pertinent attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #attributesOutOfScope attributesOutOfScope 

* @see RTIambassador#enableAttributeScopeAdvisorySwitch 
enableAttributeScopeAdvisorySwitch 

* @see RTIambassador#disableAttributeScopeAdvisorySwitch 
disableAttributeScopeAdvisorySwitch 

*/ 

public void 
attributesInScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


871 



* * 


* Notifies the federate that the specified attributes for the 
object instance are out of its scope. 

* This occurs only if the Attribute Scope Advisory Switch is on 
for the federate. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the pertinent attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotSubscribed should be thrown if the federate 
denies subscribing to one of the attributes 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #attributesInScope attributesInScope 

* @see RTIambassador#enableAttributeScopeAdvisorySwitch 
enableAttributeScopeAdvisorySwitch 

* @see RTIambassador#disableAttributeScopeAdvisorySwitch 
disableAttributeScopeAdvisorySwitch 

*/ 

public void 
attributesOutOfScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorAttributeScopeAdvisoryClient 


872 


DRDC Valcartier TR 2007-412 



The FederateAmbassadorAttributeUpdateServer interface is the 
FederateAmbassador part devoted to the server (publisher) object instance 
attribute update request callback. 


// File: FederateAmbassadorAttributeUpdateServer.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Instance Attribute Update (Send) callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorAttributeUpdateServer 


DRDC Valcartier TR 2007-412 


873 



// Object Management Services 


Instance Attribute Update (Send) 


1111111111111111111111111111111111111111111111111111111111111111 

// 6.18 

j * * 

* Requests of the federate the current values of the specified 
instance attributes, which it owns. 

* The federate should respond through the {@link 

RTIambassador#updateAttributeValues updateAttributeValues} method. 

* @param theObject the {@link ObjectInstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the requested attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#requestAttributeValueUpdate 
requestAttributeValueUpdate 

*/ 

public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorAttributeUpdateServer 


874 


DRDC Valcartier TR 2007-412 



The FederateAmbassadorAttributeScopeAdvisoryServer interface is the 
FederateAmbassador part devoted to the server (publisher) object instance 
attribute scope advisories. 


// File: FederateAmbassadorAttributeScopeAdvisoryServer.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Instance Attribute Scope Advisory (Send) callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorAttributeScopeAdvisoryServer 


DRDC Valcartier TR 2007-412 


875 



// Object Management Services - Instance Attribute Scope Advisory 
(Send) 


j * * 

* Indicates to the federate that the values of the specified 
instance attributes are required somewhere 

* in the federation execution. The federate should therefore 
update them as needed. 

* This occurs only if the Attribute Relevance Advisory Switch is 
on for the federate. 

* @param theObject the {@link ObjectInstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnUpdatesOffForObj ectInstance 
turnUpdatesOffForObj ectInstance 

* @see RTIambassador#enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#updateAttributeValues updateAttributeValues 

*/ 

public void 

turnUpdatesOnForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 


876 


DRDC Valcartier TR 2007-412 



* * 


* Indicates to the federate that the values of the specified 
instance attributes are no 

* longer required anywhere in the federation execution. 

* This occurs only if the Attribute Relevance Advisory Switch is 
on for the federate. 

* @param theObject the {@link ObjectlnstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see #turnUpdatesOnForObj ectlnstance 
turnUpdatesOnForObj ectlnstance 

* @see RTIambassador#enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#updateAttributeValues updateAttributeValues 

*/ 

public void 

turnUpdatesOffForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorAttributeScopeAdvisoryServer 


DRDC Valcartier TR 2007-412 


877 



The FederateAmbassadorAttributeOwnership interface is the 
FederateAmbassador part devoted to object ownership management. 


// File : FederateAmbassadorAttributeOwnership.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Instance Attribute Ownership callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorAttributeOwnership 


878 


DRDC Valcartier TR 2007-412 



// Ownership Management Services 



* Requests that the federate acquire ownership of the specified 
instance attributes. 

* This can occur because the original owner invoked {@link 
RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditionalAttributeOwnershipDivestiture}, 

* {@link RTIambassador#unpublishObjectClassAttributes 
unpublishObj ectClassAttributes} or {@link 

RTIambassador#resignFederationExecution resignFederationExecution} 
(with 

* the UNCONDITIONALLY_DIVEST_ATTRIBUTES, 

DELETE_OBJECTS_THEN_DIVEST or CANCEL_THEN_DELETE_THEN_DIVEST policy). 

* <p> 

* The federate may return a subset of the 
<code>offeredAttributes</code> for which it is willing to assume 
ownership 

* through the {@link RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} or {@link 
RTIambassador#attributeOwnershipAcquisitionIfAvailable 
attributeOwnershipAcquisitionlfAvailable} 

* methods. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param offeredAttributes an {@link AttributeHandleSet} 
specifying the offered attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeNotPublished should be thrown if the federate 
denies publishing an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


879 



* * 


* Notifies the federate that potential new owners have been found 
for the specified instance attributes and that 

* the negotiated divestiture of these can now be completed. The 
federate can either complete the negotiated 

* divestiture using {@link RTIambassador#confirmDivestiture 
confirmDivestiture}, divest ownership of the instance attributes by 

* some other means (e.g. ; using {@link 

RTIambassador#unconditionalAttributeOwnershipDivestiture 
unconditionalAttributeOwnershipDivestiture}) or it can 

* {@link 

RTIambassador#cancelNegotiatedAttributeOwnershipDivestiture 
cancelNegotiatedAttributeOwnershipDivestiture}. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param offeredAttributes an {@link AttributeHandleSet} 
specifying the offered attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws AttributeDivestitureWasNotRequested should be thrown if 
the federate repudiates the divestiture 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested, 

FederatelnternalError ,- 


880 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that it now owns the specified set of 
instance attributes. 

* The federate may receive multiple notifications for a single 
invocation of 

* {@link RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition} or 

* {@link RTIambassador#attributeOwnershipAcquisitionlfAvailable 
attributeOwnershipAcquisitionlfAvailable} if the requested 

* instance attributes are owned by different federates. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param securedAttributes an {@link AttributeHandleSet} 
specifying the secured attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAcquisitionWasNotRequested should be thrown if 
the federate repudiates its attribute ownership acquisition request 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeNotPublished should be thrown if the federate 
denies publishing an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

*/ 

public void 

attributeOwnershipAcquisitionNotification( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


881 



* * 


* Notifies the federate that the specified instance attributes 
were not available for ownership acquisition. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the declined attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeAcquisitionWasNotRequested should be thrown if 
the federate repudiates its attribute ownership acquisition request 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#attributeOwnershipAcquisitionlfAvaliable 
attributeOwnershipAcquisitionlfAvailable 

*/ 

public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotRequested, 

FederatelnternalError ,- 


882 


DRDC Valcartier TR 2007-412 



II 7.11 

j * * 

* Requests that the federate release ownership of the specified 
instance attributes. 

* The federate may return the subset of instance attributes for 
which it is willing 

* to release ownership through {@link 
RTIambassador#attributeOwnershipDivestiturelfWanted 
attributeOwnershipDivestiturelfWanted} , 

* {@link RTIambassador#unconditionalAttributeOwnershipDivest!ture 
unconditionalAttributeOwnershipDivestiture} or 

* {@link RTIambassador#negotiatedAttributeOwnershipDivestiture 
negotiatedAttributeOwnershipDivestiture}. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param candidateAttributes an {@link AttributeHandleSet} 
specifying the candidate attributes 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeNotOwned should be thrown if the federate 
denies owning an attribute 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#attributeOwnershipAcquisition 
attributeOwnershipAcquisition 

*/ 

public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet candidateAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


883 



II 7.15 

j * * 

* Notifies the federate that the pending attribute ownership 
acquisition requests for the 

* specified instance attributes have been canceled as requested. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws AttributeAlreadyOwned should be thrown if the federate 
thinks it already owns an attribute 

* @throws AttributeAcquisitionWasNotCanceled should be thrown if 
the federate repudiates the attribute ownership acquisition 
cancellation 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#cancelAttributeOwnershipAcquisition 
cancelAttributeOwnershipAcquisition 

*/ 

public void 

confirmAttributeOwnershipAcquisitionCancellation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 

FederatelnternalError ,- 


884 


DRDC Valcartier TR 2007-412 



II 7.17 

j * * 

* In response to an attribute ownership query by the federate, 
specifies the instance attribute's owner: another federate. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
attribute 

* @param theOwner the {@link FederateHandle} of the federate 
owning the attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#queryAttributeOwnership 
queryAttributeOwnership 

*/ 

public void 

informAttributeOwnership( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute, 

FederateHandle theOwner) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError,- 


j * * 

* In response to an attribute ownership query by the federate, 
specifies that the instance attribute is unowned. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#queryAttributeOwnership 
queryAttributeOwnership 

*/ 

public void 
attributeIsNotOwned( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


885 



* * 


* In response to an attribute ownership query by the federate, 
specifies the instance attribute's owner: the RTI. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttribute an {@link AttributeHandle} specifying the 
attribute 

* @throws ObjectlnstanceNotKnown should be thrown if the federate 
denies having previously discovered the object instance 

* @throws AttributeNotRecognized should be thrown if one of the 
supplied attributes isn't recognized in the supplied context 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#queryAttributeOwnership 
queryAttributeOwnership 

*/ 

public void 
attributelsOwnedByRTI( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederatelnternalError ,- 

} 

//end FederateAmbassadorAttributeOwnership 


886 


DRDC Valcartier TR 2007-412 



The FederateAmbassadorTime interface is the FederateAmbassador part 
devoted to the time management callbacks. 


// File: FederateAmbassadorTime.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A subset of the hla.rti!516.FederateAmbassador interface that 
contains only the Time callbacks. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public interface FederateAmbassadorTime 


// Time Management Services // 


j * * 

* Notifies the federate that its request to enable time-regulation 
has been honored. 

* @param time the {@link LogicalTime} to which the federate's 
clock has been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTime</code> is invalid 

* @throws NoRequestToEnableTimeRegulationWasPending should be 
thrown if the federate repudiates the time regulation request 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#enableTimeRegulation enableTimeRegulation 

*/ 

public void 
timeRegulationEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeRegulationWaspending, 
FederatelnternalError ,- 


DRDC Valcartier TR 2007-412 


887 



* * 


* Notifies the federate that its request to enable time-constraint 
has been honored. 

* @param time the {@link LogicalTime} to which the federate's 
clock has been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws NoRequestToEnableTimeConstrainedWasPending should be 
thrown if the federate repudiates the time constraint request 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#enableTimeConstrained enableTimeConstrained 

*/ 

public void 

timeConstrainedEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeConstrainedWasPending, 
FederatelnternalError; 


// 8.13 

j * * 

* Notifies the federate that its request to advance its logical 
time has been honored. 

* @param theTime the {@link LogicalTime} to which the federate's 
clock has been set 

* @throws InvalidLogicalTime should be thrown if the specified 
<code>LogicalTimec/code> is invalid 

* @throws JoinedFederatelsNotlnTimeAdvancingState should be thrown 
if the federate does not consider itself in the time-advancing state 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#timeAdvanceRequest timeAdvanceRequest 

* @see RTIambassador#timeAdvanceRequestAvaliable 
timeAdvanceRequestAvailable 

* @see RTIambassador#nextMessageRequest nextMessageRequest 

* @see RTIambassador#nextMessageRequestAvaliable 
nextMessageRequestAvailable 

* @see RTIambassador#flushQueueRequest flushQueueRequest 

*/ 

public void 
timeAdvanceGrant( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

JoinedFederatelsNotInTimeAdvancingState, 
FederatelnternalError; 


888 


DRDC Valcartier TR 2007-412 



* * 


* Notifies the federate that the previously delivered message 
specified by the supplied 

* {@link MessageRetractionHandle} has been retracted. 

* <p> 

* Time-constrained federates that do not use the {@link 
RTIambassador#flushQueueRequest flushQueueRequest} method 

* are not subject to invocation of this service because they will 
never receive a 

* {@link OrderType TIMESTAMP} message eligible for retraction. 

* Non-constrained federates, however, must be prepared to deal 
with invocations of this 

* service because any received message that was sent {@link 
OrderType TIMESTAMP} may be eligible for retraction. 

* @param theHandle the {@link MessageRetractionHandle} specifying 
the retracted message 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#retract retract 

*/ 

public void 
requestRetraction( 

MessageRetractionHandle theHandle) 
throws FederatelnternalError,- 

} 

//end FederateAmbassadorTime 


DRDC Valcartier TR 2007-412 


889 



The FedAmbAttributeScopeAdvisoryListener class implements the 
FederateAmbassadorAttributeScopeAdvisoryClient interface. It funnels 
both callbacks to a single method, doscope (by appending a Boolean argument), 
allowing the programmer to either override the latter or the individual 
FederateAmbassador attributesln/OutofScope methods, depending on what 
is more convenient. Being a null implementation, it does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doscope. 


// File: FedAmbAttributeScopeAdvisoryListener.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of 

FederateAmbassadorAttributeScopeAdvisoryClient interface. 

* This implementation funnels both callbacks to the doScope method, 

* so you can either override the attributesIn/OutOfScope methods or 
doScope. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmbAttributeScopeAdvisoryListener 

implements FederateAmbassadorAttributeScopeAdvisoryClient 

{ 

j * * 

* The ValidateAttributesInScope validation interface. 

*/ 

public ValidateAttributesInScope 
attributesInScopeValidator; 

j * * 

* The ValidateAttributesOutOfScope validation interface. 

*/ 

public ValidateAttributesOutOfScope 
attributesOutOfScopeValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbAttributeScopeAdvisoryListener() 


890 


DRDC Valcartier TR 2007-412 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param attributesInScope_Validator A ValidateAttributesInScope 
interface 

* @param attributesOutOfScope_Validator A 
ValIdateAttributesOutOfScope interface 

*/ 

public 

FedAmbAttributeScopeAdvisoryListener( 

ValidateAttributesInScope attributesInScope_Validator, 

ValIdateAttributesOutOfScope attributesOutOfScope_Validator) 

{ 

// this () ; 

attributesInScopeValidator = attributesInScope_Validator,- 
attributesOutOfScopeValidator = attributesOutOfScope_Validator,- 


//FederateAmbassadorAttributeScopeAdvisoryClient implementation 

public void 
attributesInScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederateInternalError 

{ 

if (null l= attributesInScopeValidator) 
attributesInScopeValidator.validate(theObj ect, theAttributes) ,- 
doScope(theObj ect, theAttributes, true) ,- 


public void 
attributesOutOfScope ( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederateInternalError 

{ 

if (null l= attributesOutOfScopeValidator) 
attributesOutOf ScopeValidat or .validate (theObj ect, theAttributes) ,- 
doScope (theObj ect, theAttributes , false) ,- 


DRDC Valcartier TR 2007-412 


891 



j k k 

* This implementation simply funnels both callbacks to this 
method, 

* so you can either override the attributesIn/OutOfScope methods 
or this one. 

* Validation is handled by the callbacks. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the pertinent attributes 

* @param inScope a boolean indicating whether the specified 
attributes are in or out of scope 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see FederateAmbassador#attributesInScope attributesInScope 

* @see FederateAmbassador#attributesOutOfScope 
attributesOutOfScope 

* @see RTIambassador#enableAttributeScopeAdvisorySwitch 
enableAttributeScopeAdvisorySwitch 

* @see RTIambassador#disableAttributeScopeAdvisorySwitch 
disableAttributeScopeAdvisorySwitch 

*/ 

protected void 
doScope ( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
boolean inScope) 

throws FederatelnternalError 


//end FedAmbAttributeScopeAdvisoryListener 


892 


DRDC Valcartier TR 2007-412 



The FedAmbAttributeScopeAdvisoryResponder class implements the 
FederateAmbassadorAttributeScopeAdvisoryServer interface. It funnels 
both callbacks to a single method, doscope (by appending a Boolean argument), 
allowing the programmer to either override the latter or the individual 
FederateAmbassador turnUpdatesOn/Of f ForObj ect Instance methods, 
depending on what is more convenient. Being a null implementation, it does 
nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doscope. 


// File: FedAmbAttributeScopeAdvisoryResponder.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of 

FederateAmbassadorAttributeScopeAdvisoryServer interface. 

* This implementation funnels both callbacks to the doScope method, 

* so you can either override the turnUpdatesOn/OffForObjectlnstance 
methods or doScope. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmbAttributeScopeAdvisoryResponder 

implements FederateAmbassadorAttributeScopeAdvisoryServer 

{ 

j * * 

* The ValidateTurnUpdatesOnForObjectlnstance validation interface. 

*/ 

public ValidateTurnUpdatesOnForObj ectlnstance 
turnUpdatesOnForObj ectInstanceValidator; 

j * * 

* The ValidateTurnUpdatesOffForObjectlnstance validation 
interface. 

*/ 

public ValidateTurnUpdatesOffForObj ectlnstance 
turnUpdatesOffForObj ectInstanceValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbAttributeScopeAdvisoryResponder() 


DRDC Valcartier TR 2007-412 


893 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param turnUpdatesOnForObj ectInstance_Validator A 
ValidateTurnUpdatesOnForObj ectInstance interface 

* @param turnUpdatesOffForObj ectInstance_Validator A 
ValidateTurnUpdatesOffForObj ectInstance interface 

*/ 

public 

FedAmbAttributeScopeAdvisoryResponder( 
ValidateTurnUpdatesOnForObj ectInstance 
turnUpdatesOnForObj ectInstance_Validator, 

ValidateTurnUpdatesOffForObj ectInstance 
turnUpdatesOffForObj ectInstance_Validator) 

{ 

// this () ; 

turnUpdatesOnForOb]ectInstanceValidator 
turnUpdatesOnForOb]ectInstance_Validator,- 

turnUpdatesOffForObj ectInstanceValidator = 
turnUpdatesOffForObj ectInstance_Validator,- 


//FederateAmbassadorAttributeScopeAdvisoryServer implementation 
public void 

turnUpdatesOnForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (null l= turnUpdatesOnForObj ectInstanceValidator) 
turnUpdatesOnForObj ectlnstanceValidator.validate(theObj ect, 
theAttributes) ,- 

doScope (theObject, theAttributes, true) ,- 


public void 

turnUpdatesOffForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (null l= turnUpdatesOffForObj ectlnstanceValidator) 
turnUpdatesOffForObj ectlnstanceValidator.validate(theObj ect 
theAttributes) ,- 

doScope (theObject, theAttributes, false) ,- 


894 


DRDC Valcartier TR 2007-412 



j k k 

* This implementation simply funnels both callbacks to this 
method, 

* so you can either override the 
turnUpdatesOn/OffForObjectlnstance methods or this one. 

* Validation is handled by the callbacks. 

* @param theObject the {@link ObjectlnstanceHandle} of the subject 
object instance 

* @param theAttributes an {@link AttributeHandleSet} specifying 
the subject attributes 

* @param inScope a boolean indicating whether the updates should 
be turned on or not 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#turnUpdatesOnForObjectlnstance 
turnUpdatesOnForObj ectlnstance 

* @see FederateAmbassador#turnUpdatesOffForObjectlnstance 
turnUpdatesOffForObj ectlnstance 

* @see RTIambassador#enableAttributeRelevanceAdvisorySwitch 
enableAttributeRelevanceAdvisorySwitch 

* @see RTIambassador#disableAttributeRelevanceAdvisorySwitch 
disableAttributeRelevanceAdvisorySwitch 

*/ 

protected void 
doScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
boolean inScope) 

throws FederatelnternalError 


//end FedAmbAttributeScopeAdvisoryResponder 


DRDC Valcartier TR 2007-412 


895 



The FedAmbDiscoveryListener class implements the 

FederateAmbassadorObj ectDiscovery interface. Being a null implementation, 
it does nothing with the callback. 

The class has a public member holding the validation interface reference. The 
callback method invokes this if specified. 


// File : FedAmbDiscoveryListener.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorObjectDiscovery interface. 

* The user should extend this class and override the 
discoverObj ectInstance method. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
FedAmbDiscoveryListener 

implements FederateAmbassadorObj ectDiscovery 

{ 

j * * 

* The ValidateDiscoverObjectlnstance validation interface. 

*/ 

public ValidateDiscoverObj ectlnstance 
discoverObj ectInstanceValidator; 

j * * 

* Default constructor. Creates an instance with no validator in 
place. 

*/ 

public 

FedAmbDiscoveryListener() 


j * * 

* Alternate constructor. Creates an instance with the specified 
validator in place. 

* @param discoverObjectInstance_Validator A 
ValidateDiscoverObj ectlnstance interface 

*/ 

public 

FedAmbDiscoveryListener( 

ValidateDiscoverObj ectlnstance discoverObj ectInstance_Validator) 

{ 

// this () ; 

discoverObj ectInstanceValidator = 
discoverObj ectInstance_Validator; 


896 


DRDC Valcartier TR 2007-412 



//FederateAmbassadorObj ectDiscovery implementation 


public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederateInternalError 

{ 

if (null l= discoverObjectlnstanceValidator) 
discoverObj ectlnstanceValidator.validate(theObj ect 
obj ectName) ; 


//end FedAmbDiscoveryListener 


theObj ectClass 


DRDC Valcartier TR 2007-412 


897 



The FedAmblnstanceAttributeListener class implements the 
FederateAmbassadorAttributeUpdateClient interface. It funnels all six forms 
of the callback to a single method, doupdate (by supplying nulls for any missing 
arguments), allowing the programmer to either override the latter or the individual 
FederateAmbassador ref lectAttributeValues methods, depending on what is 
more convenient. Being a null implementation, it does nothing with the callbacks. 

The class has a public member holding the validation interface reference. The 
callback methods invoke this if specified, before handing off to doupdate. 


// File : FedAmblnstanceAttributeListener.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorAttributeUpdateClient 
interface. 

* All of the reflectAttributeValues callbacks are funneled to the 
doUpdate method, 

* so you can either override the relevant callback(s) or doUpdate. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 

FedAmblnstanceAttributeListener 

implements FederateAmbassadorAttributeUpdateClient 

{ 

j * * 

* The ValidateReflectAttributeValues validation interface. 

*/ 

public ValidateReflectAttributeValues 
reflectAttributeValuesValidator; 

j * * 

* Default constructor. Creates an instance with no validator in 
place. 

*/ 

public 

FedAmblnstanceAttributeListener() 


898 


DRDC Valcartier TR 2007-412 



* * 


* Alternate constructor. Creates an instance with the specified 
validator in place. 

* @param reflectAttributeValues_Validator A 
ValidateReflectAttributeValues interface 

*/ 

public 

FedAmblnstanceAttributeListener( 

ValidateReflectAttributeValues reflectAttributeValues_Validator) 

{ 

// this () ; 

reflectAttributeValuesValidator = 
reflectAttributeValues Validator,- 


//FederateAmbassadorAttributeUpdateClient implementation 
public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederateInternalError 

{ 

if (null l= reflectAttributeValuesValidator) 
reflectAttributeValuesValidator.validate( 

theObj ect, theAttributes, userSuppliedTag, sentOrdering, 
theTransport) ,- 

doUpdate(theObj ect, theAttributes, userSuppliedTag, 
sentOrdering, theTransport, null, null, null, null); 


public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 
RegionHandleSet 
throws Obj ectlnstanceNotKnown 
AttributeNotRecognized 
AttributeNotSubscribed 
FederateInternalError 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
sentRegions) 


if (null l= reflectAttributeValuesValidator) 
reflectAttributeValuesValidator.validate( 

theObj ect, theAttributes, userSuppliedTag, sentOrdering, 
theTransport, sentRegions) ,- 

doUpdate(theObj ect, theAttributes, userSuppliedTag, 
sentOrdering, theTransport, null, null, null, sentRegions),- 


DRDC Valcartier TR 2007-412 


899 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError 

{ 

if (null l= reflectAttributeValuesValidator) 
ref1ectAttributeValuesValidator.validate( 

theObj ect, theAttributes, userSuppliedTag, sentOrdering, 
theTransport, theTime, receivedOrdering) ,- 

doUpdate(theObj ect, theAttributes, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, null, null); 


public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[ ] 

OrderType 

TransportationType 
LogicalTime 
OrderType 
RegionHandleSet 
throws Obj ectlnstanceNotKnown 
AttributeNotRecognized 
AttributeNotSubscribed 
FederatelnternalError 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
sentRegions) 


if (null l= reflectAttributeValuesValidator) 
ref1ectAttributeValuesValidator.validate( 

theObj ect, theAttributes, userSuppliedTag, sentOrdering 
theTransport, theTime, receivedOrdering, sentRegions) ,- 

doUpdate(theObj ect, theAttributes, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, null, 
sentRegions) ,- 


900 


DRDC Valcartier TR 2007-412 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle) 


throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotSubscribed, 
InvalidLogicalTime, 
FederateInternalError 


if (null l= reflectAttributeValuesValidator) 
reflectAttributeValuesValidator.validate( 

theObj ect, theAttributes, userSuppliedTag, sentOrdering, 
theTransport, theTime, receivedOrdering, retractionHandle) ,- 
doUpdate(theObj ect, theAttributes, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, 
retractionHandle, null) ,- 


public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 
RegionHandleSet 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
sentRegions) 


throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotSubscribed, 
InvalidLogicalTime, 
FederateInternalError 


if (null l= reflectAttributeValuesValidator) 
reflectAttributeValuesValidator.validate( 

theObj ect, theAttributes, userSuppliedTag, sentOrdering, 
theTransport, theTime, receivedOrdering, retractionHandle, 
sentRegions) ,- 

doUpdate(theObj ect, theAttributes, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, 
retractionHandle, sentRegions) ,- 


DRDC Valcartier TR 2007-412 


901 



* * 


* This implementation simply funnels all reflectAttributeValues 
callbacks to this method, 

* so you can either override the relevant method(s) or this one. 

* Missing arguments will be null. 

* Validation is handled by the callbacks. 

* @param theObject the {@link ObjectInstanceHandle} of the 
concerned object instance 

* @param theAttributes an {@link AttributeHandleValueMap} 
specifying the new attribute values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the passel was sent as 

* @param theTransport the {@link TransportationType} used to send 
the passel 

* @param theTime the {@link LogicalTime} at which the update comes 
into effect 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @param sentRegions the {@link RegionHandleSet} used to send the 
update 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#reflectAttributeValues 
reflectAttributeValues 

*/ 

protected void 
doUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle, 

RegionHandleSet sentRegions) 

throws FederatelnternalError 


//end FedAmblnstanceAttributeListener 


902 


DRDC Valcartier TR 2007-412 



The FedAmblnstanceAttributeResponder class implements the 
FederateAmbassadorAttributeUpdateServer interface. Being a null 
implementation, it does nothing with the callback. 

The class has a public member holding the validation interface reference. The 
callback method invokes this if specified. 


// File: FedAmblnstanceAttributeResponder.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorAttributeUpdateServer 
interface. 

* The user should extend this class and override the 
provideValueUpdate method. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmblnstanceAttributeResponder 

implements FederateAmbassadorAttributeUpdateServer 

{ 

j * * 

* The ValidateProvideAttributeValueUpdate validation interface. 

*/ 

public ValidateProvideAttributeValueUpdate 
provideAttributeValueUpdateValidator; 

j * * 

* Default constructor. Creates an instance with no validator in 
place. 

*/ 

public 

FedAmblnstanceAttributeResponder() 


DRDC Valcartier TR 2007-412 


903 



* * 


* Alternate constructor. Creates an instance with the specified 
validator in place. 

* @param provideAttributeValueUpdate_Validator A 
ValidateProvideAttributeValueUpdate interface 

*/ 

public 

FedAmblnstanceAttributeResponder( 

ValidateProvideAttributeValueUpdate 
provideAttributeValueUpdate_Validator) 

{ 

// this () ; 

provideAttributeValueUpdateValidator = 
provideAttributeValueUpdate_Validator,- 


//FederateAmbassadorAttributeUpdateServer implementation 
public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (null l= provideAttributeValueUpdateValidator) 
provideAttributeValueUpdateValidator.validate(theObj ect, 
theAttributes, userSuppliedTag) ,- 


//end FedAmblnstanceAttributeResponder 


904 


DRDC Valcartier TR 2007-412 



The FedAmblnteractionAdvisoryResponder class implements the 
FederateAmbassadorlnteractionAdvisory interface. It funnels both callbacks 
to a single method, doRelevance (by appending a Boolean argument), allowing the 
programmer to either override the latter or the individual FederateAmbassador 
turninteractionOn/of f methods, depending on what is more convenient. Being 
a null implementation, it does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doRelevance. 


// File: FedAmbInteractionAdvisoryResponder.j ava 
package ca.gc.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rt11516; 

j * * 

* Null implementation of FederateAmbassadorlnteractionAdvisory 
interface. 

* This implementation funnels both callbacks to the doRelevance 
method, 

* so you can either override the turnlnteractionsOn/Off methods or 
doRelevance. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmbInteractionAdvisoryResponder 

implements FederateAmbassadorInteractionAdvisory 

{ 

j * * 

* The ValidateTurnlnteractionsOn validation interface. 

*/ 

public ValidateTurnlnteractionsOn 
turnlnteractionsOnValidator; 

j * * 

* The ValidateTurnlnteractionsOff validation interface. 

*/ 

public ValidateTurnlnteractionsOff 
turnlnteractionsOffValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmblnteractionAdvisoryResponder() 


DRDC Valcartier TR 2007-412 


905 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param turnlnteractionsOn_Validator A ValidateTurnlnteractionsOn 
interface 

* @param turnlnteractionsOff_Validator A 
ValidateTurnlnteractionsOff interface 

*/ 

public 

FedAmbInteractionAdvisoryResponder( 

ValidateTurnlnteractionsOn turnlnteractionsOn_ValIdator, 
ValidateTurnlnteractionsOff turnlnteractionsOff_ValIdator) 

{ 

// this () ; 

turnlnteractionsOnValIdator = turnlnteractionsOn_Validator,- 
turnlnteractionsOffValidator = turnlnteractionsOff Validator,- 


//FederateAmbassadorlnteractionAdvisory implementation 

public void 
turnlnteractionsOn( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 
FederatelnternalError 

{ 

if (null l= turnlnteractionsOnValidator) 
turnlnteractIonsOnValIdator.validate(theHandle),- 
doRelevance (theHandle, true) ,- 


public void 
turnlnteractionsOff( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 
FederatelnternalError 

{ 

if (null l= turnlnteractionsOffValidator) 
turnlnteractionsOf fValidator .validate (theHandle) ,- 
doRelevance (theHandle, false) ,- 


906 


DRDC Valcartier TR 2007-412 



j k k 

* This implementation simply funnels both callbacks to this 
method, 

* so you can either override the turnlnteractionsOn/Off methods or 
this one. 

* Validation is handled by the callbacks. 

* @param theHandle the {@link InteractionClassHandle} of the 
subject interaction class 

* @param relevant a boolean indicating whether the specified 
interaction class is relevant or not 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#turnInteractionsOn turnlnteractionsOn 

* @see FederateAmbassador#turnlnteractionsOff turnlnteractionsOff 

* @see RTIambassador#enableInteractionRelevanceAdvisorySwitch 
enableInteractionRelevanceAdvisorySwitch 

* @see RTIambassador#disableInteractionRelevanceAdvisorySwitch 
disableInteractionRelevanceAdvisorySwitch 

*/ 

protected void 
doRelevance( 

InteractionClassHandle theHandle, 
boolean relevant) 

throws FederatelnternalError 


//end FedAmbInteractionAdvisoryResponder 


DRDC Valcartier TR 2007-412 


907 



The FedAmblnteractionListener class implements the 

FederateAmbassadorlnteractionOccurrence interface. It funnels all six forms 
of the callback to a single method, dointeraction (by supplying nulls for any 
missing arguments), allowing the programmer to either override the latter or the 
individual FederateAmbassador receivelnteraction methods, depending on 
what is more convenient. Being a null implementation, it does nothing with the 
callbacks. 

The class has a public member holding the validation interface reference. The 
callback methods invoke this if specified, before handing off to dointeraction. 


// File : FedAmblnteractionListener.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorlnteractionOccurrence 
interface. 

* This implementation funnels all callbacks to the dointeraction 
method, 

* so you can either override the relevant callback(s) or 
dointeraction. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmblnteractionListener 

implements FederateAmbassadorInteractionOccurrence 

{ 

j * * 

* The ValidateReceivelnteraction validation interface. 

*/ 

public ValidateReceivelnteraction 
receiveInteractionValidator; 

j * * 

* Default constructor. Creates an instance with no validator in 
place. 

*/ 

public 

FedAmblnteractionListener() 


908 


DRDC Valcartier TR 2007-412 



* * 


* Alternate constructor. Creates an instance with the specified 
validator in place. 

* @param receiveInteraction_Validator A ValidateReceiveInteraction 
interface 

*/ 

public 

FedAmblnteractionListener( 

ValidateReceiveInteraction receiveInteraction_Validator) 

{ 

// this () ; 

receivelnteractionValidator = receivelnteraction Validator,- 


//FederateAmbassadorInteractionOccurrence implementation 

public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 

FederateInternalError 

{ 

if (null l= receivelnteractionValidator) 
receivelnteractionValidator.validate( 

interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport) ,- 

doInteraction(interactionClass, theParameters, userSuppliedTag 
sentOrdering, theTransport, null, null, null, null); 


public void 
receivelnteraction( 

InteractionClassHandle interactionClass 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederateInternalError 


if (null l= receivelnteractionValidator) 
receivelnteractionValidator.validate( 

interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, sentRegions) ,- 

doInteraction(interactionClass, theParameters, userSuppliedTag 
sentOrdering, theTransport, null, null, null, sentRegions); 


DRDC Valcartier TR 2007-412 


909 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 

FederatelnternalError 

{ 

if (null l= receivelnteractionValidator) 
receivelnteractionValidator.validate( 

interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering) ,- 

dolnteraction(interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, null, null); 


public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 

FederatelnternalError 

{ 

if (null l= receivelnteractionValidator) 
receivelnteractionValidator.validate( 

interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, sentRegions) ,- 
dolnteraction(interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, null, 
sentRegions) ,- 


910 


DRDC Valcartier TR 2007-412 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle) 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederateInternalError 


if (null l= receivelnteractionValidator) 
receivelnteractionValidator.validate( 

interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, 
messageRetractionHandle) ,- 

doInteraction(interactionClass, theParameters, userSuppliedTag 
sentOrdering, theTransport, theTime, receivedOrdering, 
messageRetractionHandle, null) ,- 


public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle 
RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederateInternalError 


if (null l= receivelnteractionValidator) 
receivelnteractionValidator.validate( 

interactionClass, theParameters, userSuppliedTag, 
sentOrdering, theTransport, theTime, receivedOrdering, 
messageRetractionHandle, sentRegions) ,- 

doInteraction(interactionClass, theParameters, userSuppliedTag 
sentOrdering, theTransport, theTime, receivedOrdering, 
messageRetractionHandle, sentRegions) ,- 


DRDC Valcartier TR 2007-412 


911 



j k k 

* This implementation funnels all callbacks to the dolnteraction 
method, 

* so you can either override the relevant callback(s) or 
dolnteraction. 

* Missing arguments will be null. 

* Validation is handled by the callbacks. 

* @param interactionClass the {@link InteractionClassHandle} of 
the received interaction 

* @param theParameters a {@link ParameterHandleValueMap} 
specifying the interaction parameter values 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the interaction was 
sent as 

* @param theTransport the {@link TransportationType} used to send 
the interaction 

* @param theTime the {@link LogicalTime} at which the interaction 
occurs 

* @param receivedOrdering the {@link OrderType} the passel was 
received as 

* @param messageRetractionHandle the {@link 
MessageRetractionHandle} of the message 

* @param sentRegions the {@link RegionHandleSet} used to send the 
interaction 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#receiveInteraction receivelnteraction 

*/ 

protected void 
dolnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle, 
RegionHandleSet sentRegions) 

throws FederatelnternalError 


//end FedAmblnteractionListener 


912 


DRDC Valcartier TR 2007-412 



The FedAmbNameReservationListener class implements the 
FederateAmbassadorNameReservation interface. It funnels both callbacks to a 
single method, doReservation (by appending a Boolean argument), allowing the 
programmer to either override the latter or the individual FederateAmbassador 
obj ectlnstanceNameReservationSucceeded/Failed methods, depending on 
what is more convenient. Being a null implementation, it does nothing with the 
callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doReservation. 


// File: FedAmbNameReservationListener.java 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorNameReservation interface. 

* This implementation funnels both callbacks to the doReservation 
method, 

* so you can either override the 

obj ectInstanceNameReservationSucceeded/Failed methods or 
doReservation. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmbNameReservationListener 

implements FederateAmbassadorNameReservation 

{ 

j * * 

* The ValidateObjectlnstanceNameReservationSucceeded validation 
interface. 

*/ 

public ValidateObj ectInstanceNameReservationSucceeded 
obj ectInstanceNameReservationSucceededValidator; 

j * * 

* The ValidateObjectlnstanceNameReservationFailed validation 
interface. 

*/ 

public ValidateObj ectInstanceNameReservationFailed 
obj ectInstanceNameReservationFailedValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbNameReservationListener() 


DRDC Valcartier TR 2007-412 


913 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param objectInstanceNameReservationSucceeded_Validator A 
ValidateObj ectlnstanceNameReservationSucceeded interface 

* @param obj ectInstanceNameReservationFailed_ValIdator A 
ValidateObj ectlnstanceNameReservationFalied interface 

*/ 

public 

FedAmbNameReservationListener( 

ValidateObj ectlnstanceNameReservationSucceeded 
obj ectInstanceNameReservationSucceeded_ValIdator, 

ValidateObj ectlnstanceNameReservationFalied 
obj ectInstanceNameReservationFa11ed_ValIdator) 

{ 

// this () ; 

obj ectInstanceNameReservationSucceededValidator = 
obj ectInstanceNameReservationSucceeded_ValIdator; 

obj ectInstanceNameReservationFa11edValIdator 
obj ectInstanceNameReservationFa11ed_ValIdator; 


//FederateAmbassadorNameReservation implementation 
public void 

obj ectlnstanceNameReservationSucceeded( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError 

{ 

if (null l= obj ectlnstanceNameReservationSucceededValidator) 
obj ectlnstanceNameReservationSucceededValidator.validate(obj ectName); 
doReservation(objectName, true); 


public void 

obj ectInstanceNameReservationFalied( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError 

{ 

if (null l= obj ectInstanceNameReservationFa11edValIdator) 
obj ectInstanceNameReservationFa11edValIdator.validate(obj ectName) ; 
doReservation(objectName, false); 


914 


DRDC Valcartier TR 2007-412 



j k k 

* This implementation simply funnels both callbacks to this 
method, 

* so you can either override the 

objectlnstanceNameReservationSucceeded/Failed methods or this one. 

* Validation is handled by the callbacks. 

* @param objectName a {@link java.lang.String} holding the 
requested object name 

* @param succeeded a boolean indicating whether the reservation 
succeeded or not 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see RTIambassador#reserveObj ectInstanceName 
reserveObj ectInstanceName 

* @see FederateAmbassador#objectInstanceNameReservationSucceeded 
obj ectInstanceNameReservationSucceeded 

* @see FederateAmbassador#objectInstanceNameReservationFailed 
obj ectInstanceNameReservationFailed 

*/ 

protected void 
doReservation( 

String obj ectName, 
boolean succeeded) 
throws FederatelnternalError 


//end FedAmbNameReservationListener 


DRDC Valcartier TR 2007-412 


915 



The FedAmbobj ectclassAdvisoryResponder class implements the 
FederateAmbassadorObj ectRegistrationAdvisory interface. It funnels both 
callbacks to a single method, doRelevance (by appending a Boolean argument), 
allowing the programmer to either override the latter or the individual 
FederateAmbassador start/stopRegistrationForObj ectClass methods, 
depending on what is more convenient. Being a null implementation, it does 
nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doRelevance. 


// File: FedAmbobj ectclassAdvisoryResponder.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorObj ectRegistrationAdvisory 
interface. 

* This implementation funnels both callbacks to the doRelevance 
method, 

* so you can either override the start/stopRegistrationForObjectClass 
methods or doRelevance. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 

FedAmbobj ectclassAdvisoryResponder 

implements FederateAmbassadorObj ectRegistrationAdvisory 

{ 

j * * 

* The ValidateStartRegistratIonForObj ectClass validation 
interface. 

*/ 

public ValidateStartRegistratIonForObj ectClass 
startRegistratIonForObj ectClassValidator; 

j * * 

* The ValidatestopRegistratIonForObjectClass validation interface. 

*/ 

public ValidatestopRegistratIonForObjectClass 
stopRegistratIonForObj ectClassValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbobj ectclassAdvisoryResponder() 


916 


DRDC Valcartier TR 2007-412 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param startRegistrationForObj ectClass_Validator A 
ValidateStartRegistrationForObjectClass interface 

* @param stopRegistrationForObj ectClass_Validator A 
ValidateStopRegistrationForObj ectClass interface 

*/ 

public 

FedAmbObj ectClassAdvisoryResponder( 

ValidateStartRegistrationForOb]ectClass 
startRegistrationForObj ectClass_Validator, 

ValidateStopRegistratIonForObj ectClass 
stopRegistrationForObj ectClass_Validator) 

{ 

// this () ; 

startRegistrationForObj ectClassValidator = 
startRegistrationForObj ectClass_Validator,- 

stopRegistrationForObj ectClassValidator 
stopRegistrationForObj ectClass_Validator,- 


//FederateAmbassadorObj ectRegistrationAdvisory implementation 
public void 

startRegistrationForObj ectClass( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederateInternalError 

{ 

if (null l= startRegistrationForObj ectClassValidator) 
startRegistrationForObj ectClassValidator.validate(theClass) ,- 
doRelevance(theClass, true),- 


public void 

stopRegistrationForObjectClass( 

Obj ectClassHandle theClass) 
throws Obj ectelassNotPublished, 

FederateInternalError 

{ 

if (null l= stopRegistrationForObjectClassValidator) 
stopRegistrationForObj ectClassValidator .validate (theClass) ,- 
doRelevance (theClass , false) ,- 


DRDC Valcartier TR 2007-412 


917 



j k k 

* This implementation simply funnels both callbacks to this 
method, 

* so you can either override the 
start/stopRegistrationForObjectClass methods or this one. 

* Validation is handled by the callbacks. 

* @param theClass the {@link ObjectClassHandle} of the subject 
object class 

* @param relevant a boolean indicating whether the object class is 
relevant or not 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#startRegistrationForObj ectClass 
startRegistrationForObj ectClass 

* @see FederateAmbassador#stopRegistrationForObjectClass 
stopRegistrationForObj ectClass 

* @see RTIambassador#enableObj ectClassRelevanceAdvisorySwitch 
enableObj ectClassRelevanceAdvisorySwitch 

* @see RTIambassador#disableObjectClassRelevanceAdvisorySwitch 
disableObj ectClassRelevanceAdvisorySwitch 

*/ 

protected void 
doRelevance( 

Obj ectClassHandle theClass, 
boolean relevant) 

throws FederatelnternalError 


//end FedAmbObj ectClassAdvisoryResponder 


918 


DRDC Valcartier TR 2007-412 



The FedAmbOwnershipListener class implements the 

FederateAmbassadorAttributeOwnership interface. Of the nine callbacks, 
three (informAttributeOwnership, attributelsNotOwned, and 
attributel sOwnedByRTl) are funnelled to a single method, dolnf ormOwnership 

(by appending a couple of Boolean arguments and supplying a null for an eventual 
missing argument), allowing the programmer to either override the latter or the 
individual FederateAmbassador methods, depending on what is more convenient. 
Being a null implementation, it does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to 

dolnf ormOwnership (if applicable). 


// File: FedAmbOwnershipListener.java 
package ca.go.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A null implementation of the FederateAmbassadorAttributeOwnership 
interface. 

* This implementation funnels the informAttributeOwnership, 
attributelsNotOwned 

* and attributelsOwnedByRTl callbacks to the dolnformOwnership 
method, 

* so you can either override the relevant callback(s) or 
dolnformOwnership. 

* <p> 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
FedAmbOwnershipListener 

implements FederateAmbassadorAttributeOwnership 

{ 

j * * 

* The ValidateRequestAttributeOwnershipAssumption validation 
interface. 

*/ 

public ValidateRequestAttributeOwnershipAssumption 
request At tributeOwnershipAssumpt ionValidator,- 

j * * 

* The ValidateRequestDivestitureConfirmation validation interface. 

*/ 

public ValidateRequestDivestitureConfirmation 
requestDivestitureConf irmat ionValidator ,- 


DRDC Valcartier TR 2007-412 


919 



* * 


* The ValidateAttributeOwnershipAcquisitionNotification validation 
interface. 

*/ 

public ValidateAttributeOwnershipAcquisitionNotification 
attributeOwnershipAcquisitionNotificationValidator; 

j * * 

* The ValidateAttributeOwnershipUnavailable validation interface. 

*/ 

public ValIdateAttributeOwnershipUnavaliable 
attributeOwnershipUnavailableValidator; 

j * * 

* The ValidateRequestAttributeOwnershipRelease validation 
interface. 

*/ 

public ValIdateRequestAttributeOwnershipRelease 
requestAttributeOwnershipReleaseValidator; 

j * * 

* The ValidateConfIrmAttributeOwnershipAcquisitionCancellation 
validation interface. 

*/ 

public ValidateConfirmAttributeOwnershipAcquisitionCancellation 
confIrmAttributeOwnershipAcquisitionCancellationValidator; 

j * * 

* The ValidatelnformAttributeOwnership validation interface. 

*/ 

public ValidatelnformAttributeOwnership 
informAttributeOwnershipValidator; 

j * * 

* The ValidateAttributelsNotOwned validation interface. 

*/ 

public ValidateAttributelsNotOwned 
attributelsNotOwnedValidator; 

j * * 

* The ValidateAttributelsOwnedByRTI validation interface. 

*/ 

public ValidateAttributelsOwnedByRTI 
attributelsOwnedByRTIValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbOwnershipListener() 


920 


DRDC Valcartier TR 2007-412 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param requestAttributeOwnershipAssumption_Validator A 
ValidateRequestAttributeOwnershipAssumption interface 

* @param requestDivestitureConfirmation_Validator A 
ValidateRequestDivestitureConfirmation interface 

* @param attributeOwnershipAcquisitionNotification_Validator A 
ValidateAttributeOwnershipAcquisitionNotification interface 

* @param attributeOwnershipUnavailable_Validator A 
ValIdateAttributeOwnershipUnavaliable interface 

* @param requestAttributeOwnershipRelease_Validator A 
ValIdateRequestAttributeOwnershipRelease interface 

* @param 

confIrmAttributeOwnershipAcquisitionCancellation_Validator A 
ValidateConfIrmAttributeOwnershipAcquisitionCancellation interface 

* @param informAttributeOwnership_Validator A 
ValidatelnformAttributeOwnership interface 

* @param attributeIsNotOwned_Validator A 
ValIdateAttributeIsNotOwned interface 

* @param attributeIsOwnedByRTI_Validator A 
ValIdateAttributeIsOwnedByRTI interface 

*/ 


DRDC Valcartier TR 2007-412 


921 



public 

FedAmbOwnershipListener( 

ValidateRequestAttributeOwnershipAssumption 
requestAttributeOwnershipAssumption_Validator, 
ValidateRequestDivestitureConfirmation 
requestDivestitureConfirmation_Validator, 

ValidateAttributeOwnershipAcquisitionNotification 
attributeOwnershipAcquisitionNotification_Validator, 

ValidateAttributeOwnershipUnavaliable 
attributeOwnershipUnavailable_Validator, 

ValidateRequestAttributeOwnershipRelease 
requestAttributeOwnershipRelease_Validator, 

ValidateConfIrmAttributeOwnershipAcquisitionCancellation 
confirmAttrIbuteOwnershipAcquisitionCancellation_Validator, 

ValidatelnformAttributeOwnership 
informAttributeOwnership_Validator, 

ValidateAttributeIsNotOwned 
attributelsNotOwned_Validator, 

ValIdateAttributeIsOwnedByRTI 
attributelsOwnedByRTI_Validator) 

{ 

// this () ; 

requestAttributeOwnershipAssumptionValidator 
requestAttributeOwnershipAssumption_Validator; 

requestDivestitureConfirmationValidator 
requestDivestitureConfirmation_Validator; 

attributeOwnershipAcquisitionNotificationValidator 
attributeOwnershipAcquisitionNotification_Validator; 

attributeOwnershipUnavailableValidator 
attributeOwnershipUnavailable_Validator; 

requestAttributeOwnershipReleaseValidator 
requestAttributeOwnershipRelease_Validator; 

confirmAttributeOwnershipAcquisitionCancellationValidator = 
confirmAttributeOwnershipAcquisitionCancellation_Validator; 

informAttributeOwnershipValidator 
informAttributeOwnership_Validator; 

attributelsNotOwnedValidator 
attributelsNotOwned_Validator; 

attributelsOwnedByRTIValidator 
attributelsOwnedByRTI_Validator; 


922 


DRDC Valcartier TR 2007-412 



//FederateAmbassadorAttributeOwnership implementation 


public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederateInternalError 

{ 

if (null l= requestAttributeOwnershipAssumptionValidator) 
requestAttributeOwnershipAssumptionValidator.validate(theObj ect 
offeredAttributes, userSuppliedTag),- 


public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested, 

FederateInternalError 

{ 

if (null l= requestDivestitureConfirmationValidator) 
requestDivestitureConfirmationValidator.validate(theObj ect 
offeredAttributes) ,- 


public void 

attributeOwnershipAcquisitionNotification( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederateInternalError 

{ 

if (null l= attributeOwnershipAcquisitionNotificationValidator) 
attributeOwnershipAcquisitionNotificationValidator.validate(theObj ect 
securedAttributes, userSuppliedTag) ,- 


DRDC Valcartier TR 2007-412 


923 



public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotRequested, 
FederatelnternalError 

{ 

if (null l= attributeOwnershipUnavailableValidator) 
attributeOwnershipUnavailableValidator.validate(theObj ect 
theAttributes),- 


public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet candidateAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (null l= requestAttributeOwnershipReleaseValidator) 
requestAttributeOwnershipReleaseValidator.validate(theObj ect 
candidateAttributes, userSuppliedTag) ,- 


public void 

confIrmAttributeOwnershipAcquisitionCancellation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 

FederatelnternalError 

{ 

if (null l= 

confirmAttributeOwnershipAcquisitionCancellationValidator) 

confirmAttributeOwnershipAcquisitionCancellationValidator.validate(the 

Object, theAttributes) ,- 


924 


DRDC Valcartier TR 2007-412 



public void 

informAttributeOwnership( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute, 

FederateHandle theOwner) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederateInternalError 

{ 

if (null l= InformAttributeOwnershipValidator) 
informAttributeOwnershipValidator.validate(theObj ect, theAttribute 
theOwner),- 

doInformOwnership(theObj ect, theAttribute, false, false, 
theOwner) ,- 


public void 
attributeIsNotOwned( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

FederateInternalError 

{ 

if (null l= attributelsNotOwnedValidator) 
attributelsNotOwnedValidator.validate(theObj ect 
dolnformOwnership(theObj ect, theAttribute 


theAttribute) ,- 
true, false, null); 


public void 
attributelsOwnedByRTI( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

FederateInternalError 

{ 

if (null l= attributelsOwnedByRTIValidator) 
attributel sOwnedByRTI Validator .validate (theObj ect, theAttribute) ,- 

dolnformOwnership(theObject, theAttribute, false, true, null); 


DRDC Valcartier TR 2007-412 


925 



* * 


* This implementation funnels the informAttributeOwnership, 
attributelsNotOwned and 

* attributelsOwnedByRTI callbacks to the doInformOwnership method, 

* so you can either override the relevant callback(s) or 
doInformOwnership. 

* Missing arguments will be null. 

* Validation is handled by the callbacks. 

* @param theObject the {@link ObjectInstanceHandle} of the Object 
whose instance attribute ownership is reported 

* @param theAttribute the {@link AttributeHandle} of the Attribute 
whose ownership is reported 

* @param isUnowned a boolean which is true if the attribute is 
unowned (isOwnedByRTI will be false and theOwner will be null), false 
otherwise 

* @param isOwnedByRTI a boolean which is true if the attribute is 
owned by the RTI (isUnowned will be false and theOwner will be null), 
false otherwise 

* @param theOwner the {@link FederateHandle} of the owning 
federate (when isUnowned and isOwnedByRTI are false), null otherwise 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#informAttributeOwnership 
informAttributeOwnership 

* @see FederateAmbassador#attributeIsNotOwned attributelsNotOwned 

* @see FederateAmbassador#attributeIsOwnedByRTI 
attributelsOwnedByRTI 

*/ 

public void 
doInformOwnership( 

final Obj ectlnstanceHandle theObj ect, 

final AttributeHandle theAttribute, 

final boolean isUnowned, 

final boolean IsOwnedByRTI, 

final FederateHandle theOwner) 

throws FederatelnternalError 


//end FedAmbOwnershipListener 


926 


DRDC Valcartier TR 2007-412 



The FedAmbRemovalResponder class implements the 

FederateAmbassadorObj ectRemoval interface. It funnels all three forms of the 
callback to a single method, doRemove (by supplying nulls for any missing 
arguments), allowing the programmer to either override the latter or the individual 

FederateAmbassador removeObj ectlnstance methods, depending on what is 
more convenient. Being a null implementation, it does nothing with the callbacks. 

The class has a public member holding the validation interface reference. The 
callback methods invoke this if specified, before handing off to doRemove. 


// File: FedAmbRemovalResponder.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* Null implementation of FederateAmbassadorObjectRemoval interface. 

* This implementation funnels all callbacks to the doRemove method, 

* so you can either override the relevant removeObjectlnstance 
method(s) or doRemove. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
FedAmbRemovalResponder 

implements FederateAmbassadorObj ectRemoval 

{ 

j * * 

* The ValidateRemoveObjectlnstance validation interface. 

*/ 

public ValidateRemoveObj ectlnstance 
removeObj ectInstanceValidator; 

j * * 

* Default constructor. Creates an instance with no validator in 
place. 

*/ 

public 

FedAmbRemovalResponder() 


DRDC Valcartier TR 2007-412 


927 



* * 


* Alternate constructor. Creates an instance with the specified 
validator in place. 

* @param removeObjectInstance_Validator A 
ValidateRemoveObjectInstance interface 

*/ 

public 

FedAmbRemovalResponder( 

ValidateRemoveObj ectInstance removeObj ectInstance_Validator) 

{ 

// this () ; 

removeObj ectInstanceValidator = removeObj ectInstance_Validator,- 


//FederateAmbassadorObj ectRemoval implementation 

public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag, 

OrderType sentOrdering) 

throws Obj ectlnstanceNotKnown, 

FederatelnternalError 

{ 

if (null l= removeObjectlnstanceValidator) 
removeObj ectlnstanceValidator.validate( 

theObj ect, userSuppliedTag, sentOrdering) ,- 
doRemove(theObject, userSuppliedTag, sentOrdering, null, null 

null) ,- 


public void 
removeObj ectlnstance 
Obj ectlnstanceHandle 
byte[] 

OrderType 
LogicalTime 
OrderType 
throws Obj ectlnstanceNotKnown 
FederatelnternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering) 


if (null l= removeObjectlnstanceValidator) 
removeObj ectlnstanceValidator.validate( 

theObj ect, userSuppliedTag, sentOrdering, theTime, 
receivedOrdering) ,- 

doRemove(theObj ect, userSuppliedTag, sentOrdering, theTime 
receivedOrdering, null) ,- 


928 


DRDC Valcartier TR 2007-412 



public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle 
byte[] 

OrderType 
LogicalTime 
OrderType 

MessageRetractionHandle retractionHandle 
throws Obj ectlnstanceNotKnown, 
InvalidLogicalTime, 

FederateInternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 


if (null l= removeObjectlnstanceValidator) 
removeObj ectlnstanceValidator.validate( 

theObj ect, userSuppliedTag, sentOrdering, theTime, 
receivedOrdering, retract ionHandle) ,- 

doRemove(theObj ect, userSuppliedTag, sentOrdering, theTime 
receivedOrdering, retract ionHandle) ,- 


* This implementation funnels all removeObjectlnstance callbacks 
to this method, 

* so you can either override the relevant callback(s) or this 
method. 

* Missing arguments will be null. 

* Validation is handled by the callbacks. 

* @param theObject the {@link ObjectlnstanceHandle} of the 
concerned object instance 

* @param userSuppliedTag a <code>byte[]</code> tag (this parameter 
may be <code>null</code>) 

* @param sentOrdering the {@link OrderType} the message was sent 
as 

* @param theTime the {@link LogicalTime} at which the deletion 


occurs 

* @param receivedOrdering the {@link OrderType} the message was 
received as 

* @param retractionHandle the {@link MessageRetractionHandle} of 
the message 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#removeObjectlnstance 
removeObj ectlnstance 


protected void 
doRemove( 

Obj ectlnstanceHandle 
byte[] 

OrderType 
LogicalTime 
OrderType 

MessageRetractionHandle retractionHandle 
throws FederatelnternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 


//end FedAmbRemovalResponder 


DRDC Valcartier TR 2007-412 


929 



The FedAmbRestoreListener class implements the 

FederateAmbassadorRestore interface. Of the seven callbacks, two pairs 

(requestFederationRestoreSucceeded/Failed and 

federation [Not] Restored) are funnelled to a single method each, doRequest 
and doRestore (by appending a Boolean argument in each case), allowing the 
programmer to either override the latter or the individual FederateAmbassador 
methods, depending on what is more convenient. Being a null implementation, it 
does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doRequest or 
doRestore (if applicable). 


// File: FedAmbRestoreListener.java 
package ca.go.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A null implementation of the FederateAmbassadorRestore interface. 

* This implementation funnels requestFederationRestoreSucceeded/Failed 
to the doRequest method, 

* so you can either override those callbacks or doRequest. 

* Likewise, the federation[Not]Restored callbacks are funneled to the 
doRestore method, 

* so you can either override those callbacks or doRestore. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 
FedAmbRestoreListener 

implements FederateAmbassadorRestore 

{ 

j * * 

* The ValidateRequestFederationRestoreSucceeded validation 
interface. 

*/ 

public ValidateRequestFederationRestoreSucceeded 
requestFederat ionRestoreSucceededValidat or,- 

j * * 

* The ValidateRequestFederationRestoreFailed validation interface. 

*/ 

public ValidateRequestFederationRestoreFailed 
requestFederat ionRestoreFailedValidat or,- 

j * * 

* The ValidateFederationRestoreBegun validation interface. 

*/ 

public ValidateFederationRestoreBegun 
f ederat ionRestoreBegunValidator ,- 


930 


DRDC Valcartier TR 2007-412 



* * 


* The ValidatelnitiateFederateRestore validation interface. 

*/ 

public ValidatelnitiateFederateRestore 
initiateFederateRestoreValidator; 

j * * 

* The ValidateFederationRestored validation interface. 

*/ 

public ValidateFederationRestored 
federationRestoredValidator; 

j * * 

* The ValidateFederationNotRestored validation interface. 

*/ 

public ValidateFederationNotRestored 
federationNotRestoredValidator; 

j * * 

* The ValidateFederationRestoreStatusResponse validation 
interface. 

*/ 

public ValidateFederationRestoreStatusResponse 
federationRestoreStatusResponseValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbRestoreListener() 


DRDC Valcartier TR 2007-412 


931 



* * 


* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param requestFederationRestoreSucceeded_Validator A 
ValidateRequestFederationRestoreSucceeded interface 

* @param requestFederationRestoreFailed_Validator A 
ValidateRequestFederationRestoreFalied interface 

* @param federationRestoreBegun_Validator A 
ValidateFederationRestoreBegun interface 

* @param initiateFederateRestore_Validator A 
ValidatelnitiateFederateRestore interface 

* @param federationRestored_Validator A ValidateFederationRestored 
interface 

* @param federationNotRestored_Validator A 
ValidateFederationNotRestored interface 

* @param federationRestoreStatusResponse_Validator A 
ValidateFederationRestoreStatusResponse interface 

*/ 

public 

FedAmbRestoreListener( 

ValidateRequestFederatIonRestoreSucceeded 
requestFederationRestoreSucceeded_Validator, 

ValidateRequestFederationRestoreFalied 
requestFederationRestoreFailed_Validator, 

ValidateFederatIonRestoreBegun 
federationRestoreBegun_ValIdator, 

ValidatelnitIateFederateRestore 
initiateFederateRestore_Validator, 

ValidateFederationRestored 
federationRestored_ValIdator, 

ValidateFederationNotRestored 
federationNotRestored_ValIdator, 

ValidateFederationRestoreStatusResponse 
federationRestorestatusResponse_Validator) 

{ 

// this () ; 

requestFederationRestoreSucceededValidator = 
requestFederationRestoreSucceeded_Validator; 

requestFederationRestoreFailedValidator 
requestFederationRestoreFailed_Validator; 

federationRestoreBegunValIdator 
federationRestoreBegun_ValIdator; 

initiateFederateRestoreValidator 
initiateFederateRestore_Validator; 

federationRestoredValIdator 
federationRestored_ValIdator; 

federationNotRestoredValIdator 
federationNotRestored_ValIdator; 

federationRestorestatusResponseValIdator 
federationRestorestatusResponse_Validator; 


932 


DRDC Valcartier TR 2007-412 



//FederateAmbassadorRestore implementation 


public void 

requestFederationRestoreSucceeded( 

String label) 

throws FederateInternalError 

{ 

if (null l= requestFederationRestoreSucceededValidator) 
requestFederationRestoreSucceededValidator.validate(label),- 
doRequest(label, true) ,- 


public void 

requestFederationRestoreFailed( 

String label) 

throws FederateInternalError 

{ 

if (null l= requestFederationRestoreFailedValidator) 
requestFederationRestoreFailedValidator.validate(label),- 
doRequest (label, false) ,- 


public void 

federationRestoreBegun () 
throws FederateInternalError 
{ 

if (null l= federationRestoreBegunValidator) 
federationRestoreBegunValidator .validate () ,- 


public void 

initiateFederateRestore ( 

String label, 

FederateHandle federateHandle) 
throws SpecifiedSaveLabelDoesNotExist, 

CouldNotInitiateRestore, 

FederateInternalError 

{ 

if (null l= InitiateFederateRestoreValidator) 
InitiateFederateRestoreValidator .validate (label, federateHandle) ,- 

throw new CouldNotlnitiateRestore("FedAmbRestoreListener cannot 
initiate a federation restore' 1 ); 


public void 
federationRestored () 
throws FederateInternalError 
{ 

if (null l= federationRestoredValidator) 
federationRestoredValidator .validate () ,- 
doRestore (null) ,- 


DRDC Valcartier TR 2007-412 


933 



public void 
federationNotRestored( 

RestoreFailureReason reason) 
throws FederatelnternalError 
{ 

if (null l= federationNotRestoredValidator) 
federationNotRestoredValidator.validate(reason),- 
doRestore(reason),- 


public void 

federationRestoreStatusResponse( 

FederateHandleRestoreStatusPair [] response) 
throws FederatelnternalError 
{ 

if (null l= federationRestorestatusResponseValIdator) 
federationRestorestatusResponseValIdator.validate(response); 


j * * 

* This implementation funnels the 

requestFederationRestoreSucceeded/Failed callbacks to this method, 

* so you can either override the relevant callback(s) or this 
method. 

* Validation is handled by the callbacks. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param succeeded a boolean indicating whether the request 
succeeded or not 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#requestFederationRestore 
requestFederationRestore 

* @see FederateAmbassador#requestFederationRestoreSucceeded 
requestFederationRestoreSucceeded 

* @see FederateAmbassador#requestFederationRestoreFailed 
requestFederationRestoreFailed 

*/ 

protected void 
doRequest ( 

String label, 
boolean succeeded) 
throws FederatelnternalError 


934 


DRDC Valcartier TR 2007-412 



* * 


* This implementation funnels the federation[Not]Restored 
callbacks to this method, 

* so you can either override the relevant callback (s) or this 
method. 

* Validation is handled by the callbacks. 

* @param reason a {@link RestoreFailureReason} specifying the 
reason for the failure,- 

* if null, it means the restore succeeded 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see FederateAmbassador#federationRestored federationRestored 

* @see FederateAmbassador#federationNotRestored 
federationNotRestored 

*/ 

protected void 
doRestore( 

RestoreFailureReason reason) 
throws FederatelnternalError 


//end FedAmbRestoreListener 


DRDC Valcartier TR 2007-412 


935 



The FedAmbSaveListener class implements the FederateAmbassadorSave 

interface. Of the four callbacks, one pair (federation [Not] Saved) is funnelled to 
a single method, dosave (by appending a Boolean argument), and the two forms of 
another (initiateFederateSave) are funnelled to another single method, 
doinitiateSave (by supplying a null for an eventual missing argument). This 
allows the programmer to either override the latter or the individual 
FederateAmbassador methods, depending on what is more convenient. Being a 
null implementation, it does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to dosave or 
doinitiateSave (if applicable). 


// File: FedAmbSaveListener.java 

package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A null implementation of the FederateAmbassadorSave interface. 

* This implementation funnels the federation[Not]Saved callbacks to 
the doSave method, 

* so you can either override the relevant callback(s) or doSave. 

* Likewise, the initiateFederateSave callbacks are funnelled to the 
doinitiateSave method, 

* so you can either override the relevant callback (s) or 
doinitiateSave. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
FedAmbSaveListener 

implements FederateAmbassadorSave 

{ 

j * * 

* The ValidatelnitiateFederateSave validation interface. 

*/ 

public ValidatelnitiateFederateSave 
init iateFederateSaveValidator,- 

j * * 

* The ValidateFederationSaved validation interface. 

*/ 

public ValidateFederationSaved 
f ederat ionSavedValidator,- 

j * * 

* The ValidateFederationNotSaved validation interface. 

*/ 

public ValidateFederationNotSaved 
f ederat ionNotSavedVali da tor ,- 


936 


DRDC Valcartier TR 2007-412 



* * 


* The ValidateFederationSaveStatusResponse validation interface. 

*/ 

public ValidateFederationSaveStatusResponse 
federationSaveStatusResponseValidator; 

j * * 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbSaveListener() 


j * * 

* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param initiateFederateSave_Validator A 
ValidatelnitiateFederateSave interface 

* @param federationSaved_Validator A ValidateFederationSaved 
interface 

* @param federationNotSaved_Validator A ValidateFederationNotSaved 
interface 

* @param federationSaveStatusResponse_Validator A 
ValidateFederatIonSaveStatusResponse interface 

*/ 

public 

FedAmbSaveListener( 

ValidatelnitIateFederateSave 
initiateFederateSave_Validator, 

ValidateFederationSaved federationSaved_Validator, 

ValidateFederationNotSaved 
federationNotSaved_Validator, 

ValidateFederatIonSaveStatusResponse 
federationSaveStatusResponse_Validator) 

{ 

// this () ; 

InitiateFederateSaveValidator 
initiateFederateSave_Validator; 

federationSavedValidator 
federationSaved_Validator; 

federationNotSavedValidator 
federationNotSaved_Validator; 

federationSaveStatusResponseValidator = 
federationSaveStatusResponse_Validator; 


DRDC Valcartier TR 2007-412 


937 



//FederateAmbassadorSave implementation 


public void 
initiateFederateSave( 

String label) 

throws UnableToPerformSave, 
FederatelnternalError 

{ 

if (null l= InitiateFederateSaveValidator) 
InitiateFederateSaveValidator.validate(label),- 
doInitiateSave(label, null),- 


public void 
initiateFederateSave( 

String label, 

LogicalTime time) 
throws InvalidLogicalTime, 

UnableToPerformSave, 

FederatelnternalError 

{ 

if (null l= InitiateFederateSaveValidator) 
init iateFederateSaveValidator .validate (label, t ime) ,- 
doInitiateSave (label, time) ,- 


public void 
federationSaved() 
throws FederatelnternalError 
{ 

if (null l= federationSavedValidator) 
federationSavedValidator .validate () ,- 
doSave (null) ,- 


public void 
federationNotSaved( 

SaveFailureReason reason) 
throws FederatelnternalError 
{ 

if (null l= federationNotSavedValidator) 
federationNotSavedValidator .validate (reason) ,- 
doSave (reason) ,- 


public void 

federationSaveStatusResponse ( 

FederateHandleSaveStatusPair [] response) 
throws FederatelnternalError 
{ 

if (null l= federationSaveStatusResponseValidator) 
federationSaveStatusResponseValidator .validate (response) ,- 


938 


DRDC Valcartier TR 2007-412 



* * 


* This implementation funnels the initiateFederateSave callbacks 
to this method, 

* so you can either override the relevant callback(s) or this 
method. 

* Missing arguments will be null. 

* Validation is handled by the callbacks. 

* @param label a {@link java.lang.String} holding the saved 
state's identifier 

* @param time a {@link LogicalTime} specifying when the save was 
scheduled 

* @throws UnableToPerformSave should be thrown if the save 
operation seems doomed 

* @throws FederatelnternalError should be thrown if something else 
goes wrong 

* @see FederateAmbassador#initiateFederateSave 
initiateFederateSave 

*/ 

protected void 
doInitiateSave( 

String label, 

LogicalTime time) 
throws UnableToPerformSave, 

FederatelnternalError 


j * * 

* This implementation funnels the federation[Not]Saved callbacks 
to this method, 

* so you can either override the relevant callback (s) or this 
method. 

* Validation is handled by the callbacks. 

* @param reason a {@link SaveFailureReason} specifying the reason 
for the failure; 

* if null, it means the save succeeded 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see FederateAmbassador#federationSaved federationSaved 

* @see FederateAmbassador#federationNotSaved federationNotSaved 

*/ 

protected void 
doSave( 

SaveFailureReason reason) 
throws FederatelnternalError 


//end FedAmbSaveListener 


DRDC Valcartier TR 2007-412 


939 



The FedAmbSynchronizationListener class implements the 

Feder a teAmbassador Synchronization interface. Of the four callbacks, it 

funnels a pair (synchronizationPointRegistrationSucceeded/Failed) to a 

single method, doRegistration (by supplying a null for an eventual missing 
argument), allowing the programmer to either override the latter or the individual 
FederateAmbassador methods, depending on what is more convenient. Being a 
null implementation, it does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified, before handing off to doRegistration 
(if applicable). 


// File: FedAmbSynchronizationListener.j ava 
package ca.go.drdc_rddc.hla.rtil516.FedAmb; 

import hla.rtil516.*; 

j * * 

* A null implementation of the FederateAmbassadorSynchronization 
interface. 

* Note that a more satisfactory implementation would respond to the 
announceSynchronizationPoint 

* callback with 

_RTIambassador.synchronizationPointAchieved(synchronizationPointLabel) 

* but this cannot be done here as we're lacking an RTIambassador 
reference. 

* This implementation also funnels 

synchronizationPointRegistrationSucceeded/Failed to the doRegistration 
method, 

* so you can either override those callbacks or doRegistration. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 

public class 

FedAmbSynchronizationListener 

implements FederateAmbassadorSynchronization 

{ 

j * * 

* The ValidateSynchronizationPointRegistrationSucceeded validation 
interface. 

*/ 

public ValidateSynchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceededValidator; 

j * * 

* The ValidateSynchronizationPointRegistrationFailed validation 
interface. 

*/ 

public ValidateSynchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailedValidator; 


940 


DRDC Valcartier TR 2007-412 



j k k 

* The ValidateAnnounceSynchronizationPoint validation interface. 
*/ 

public ValidateAnnounceSynchronizationPoint 
announceSynchronizationPointValidator; 

j k k 

* The ValidateFederationSynchronized validation interface. 

*/ 

public ValidateFederationSynchronized 
federationSynchronizedValidator; 

j k k 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbSynchronizationListener () 


j k k 

* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param synchronizationPointRegistrationSucceeded_Validator A 
ValidateSynchronizationPointRegistrationSucceeded interface 

* @param synchronizationPointRegistrationFailed_Validator A 
ValidateSynchronizationPointRegistrationFailed interface 

* @param announceSynchronizationPoint_Validator A 
ValidateAnnounceSynchronizationPoint interface 

* @param federationSynchronized_Validator A 
ValidateFederationSynchronized interface 

*/ 

public 

FedAmbSynchronizationListener( 

ValidateSynchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded_Validator, 
ValidateSynchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed_Validator, 
ValidateAnnounceSynchronizationPoint 
announceSynchronizationPoint_Validator, 
ValidateFederationSynchronized 
federationSynchronized_Validator) 

{ 

// this () ; 

synchronizationPointRegistrationSucceededValidator = 
synchronizationPointRegistrationSucceeded_Validator; 

synchronizationPointRegistrationFailedValidator 

synchronizationPointRegistrationFailed_Validator; 

announceSynchronizationPointValidator 
announceSynchronizationPoint_Validator; 

federationSynchronizedValidator 
federationSynchronized_Validator; 


DRDC Valcartier TR 2007-412 


941 



//FederateAmbassadorSynchronization implementation 


public void 

synchronizationPointRegistrationSucceeded( 

String synchronizationPointLabel) 
throws FederatelnternalError 
{ 

if (null l= synchronizationPointRegistrationSucceededValidator) 
synchronizationPointRegistrationSucceededValidator.validate(synchroniz 
ationPointLabel); 

doRegistration(synchronizationPointLabel, null); 


public void 

synchronizationPointRegistrationFailed( 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 
throws FederatelnternalError 
{ 

if (null l= synchronizationPointRegistrationFailedValidator) 
synchronizationPointRegistrationFailedValidator.validate(synchronizati 
onPointLabel, reason) ; 

doRegistration(synchronizationPointLabel, reason); 


public void 

announceSynchronizationPoint( 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 
throws FederatelnternalError 
{ 

if (null l= announceSynchronizationPointValidator) 
announceSynchronizationPointValidator.validate(synchronizationPointLab 
el, userSuppliedTag); 

//A true null implementation would immediately fire back this 
RTIambassador call: 

// 

_RTIambassador.synchronizationPointAchieved(synchronizationPointLabel) 


public void 

federationSynchronized( 

String synchronizationPointLabel) 
throws FederatelnternalError 
{ 

if (null l= federationSynchronizedValidator) 
federationSynchronizedValidator.validate(synchronizationPointLabel); 


942 


DRDC Valcartier TR 2007-412 



* * 


* This implementation funnels the 

synchronizationPointRegistrationSucceeded/Failed callbacks to this 
method, 

* so you can either override the relevant callback(s) or this 
method. 

* Validation is handled by the callbacks. 

* @param synchronizationPointLabel a {@link java.lang.String} 
giving the synchronization point's identifier 

* @param reason a {@link SynchronizationPointFailureReason} 
specifying what went wrong,- 

if null, it means the registration succeeded 

* @throws FederatelnternalError should be thrown if something goes 
wrong 

* @see RTIambassador#registerFederationSynchronizationPoint 
registerFederationSynchronizationPoint 

* @see 

FederateAmbassador#synchronizationPointRegistrationSucceeded 
synchronizationPointRegistrationSucceeded 

* @see FederateAmbassador#synchronizationPointRegistrationFailed 
synchronizationPointRegistrationFailed 

*/ 

protected void 
doRegistration( 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 
throws FederatelnternalError 


//end FedAmbSynchronizationListener 


DRDC Valcartier TR 2007-412 


943 



The FedAmbTimeListener class implements the FederateAmbassadorTime 

interface. Being a null implementation, it does nothing with the callbacks. 

The class has public members holding the validation interface references. The 
callback methods invoke these if specified. 


// File: FedAmbTimeListener.java 

package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import hla.rtil516.*; 

j * * 

* A null implementation of the FederateAmbassadorTime interface. 

* <p> 

* The requestRetraction callback is tricky to dispatch. It refers to 

* a previously received reflectAttributeValues, receivelnteraction, 

* or removeObjectlnstance callback. The second can be associated with 

* an InteractionClassHandle and the other two with an 

* ObjectInstanceHandle, but the Map between MessageRetractionHandles 

* and those is beyond the scope of a simple wrapper. 

* It may be pertinent to have some kind of "retraction co-ordinator" 

* associated with interaction classes and object instances, but such 

* handlers would need to be invoked separately by the Interaction 

* Listeners, Instance Attribute Listeners and the Time Listener. 

* Note that the Time Advance Grants would also have to be passed to 

* such a retraction co-ordinator, in order to dispose of retraction 

* handles that have become un-retractable. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 

*/ 

public class 
FedAmbTimeListener 

implements FederateAmbassadorTime 

{ 

j * * 

* The ValidateRequestRetraction validation interface. 

*/ 

public ValidateRequestRetraction 
request Re tract ionValidator,- 

j * * 

* The ValidateTimeAdvanceGrant validation interface. 

*/ 

public ValidateTimeAdvanceGrant 
timeAdvanceGr ant Validator,- 

j * * 

* The ValidateTimeConstrainedEnabled validation interface. 

*/ 

public ValidateTimeConstrainedEnabled 
t ImeConstrainedEnabledValidator ,- 


944 


DRDC Valcartier TR 2007-412 



j k k 

* The ValidateTimeRegulationEnabled validation interface. 

*/ 

public ValidateTimeRegulationEnabled 
timeRegulationEnabledValidator; 

j k k 

* Default constructor. Creates an instance with no validators in 
place. 

*/ 

public 

FedAmbTimeListener () 


j k k 

* Alternate constructor. Creates an instance with the specified 
validators in place. 

* @param requestRetraction_Validator A ValidateRequestRetraction 
interface 

* @param timeAdvanceGrant_Validator A ValidateTimeAdvanceGrant 
interface 

* @param timeConstrainedEnabled_Validator A 
ValidateTimeConstrainedEnabled interface 

* @param timeRegulationEnabled_Validator A 
ValidateTimeRegulationEnabled interface 

*/ 

public 

FedAmbTimeListener( 

ValidateRequestRetraction requestRetraction_Validator, 

ValidateTimeAdvanceGrant timeAdvanceGrant_Validator, 

ValidateTimeConstrainedEnabled timeConstrainedEnabled_Validator 
ValidateTimeRegulationEnabled timeRegulationEnabled_Validator) 

{ 

// this () ; 

requestRetractionValidator = requestRetraction_Validator; 

tImeAdvanceGrantValidator = timeAdvanceGrant_Validator; 

tImeConstrainedEnabledValidator = 
timeConstrainedEnabled_Validator; 

timeRegulatIonEnabledValidator 
timeRegulationEnabled_Validator; 


//FederateAmbassadorTime implementation 

public void 
timeRegulationEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeRegulationWaspending 
FederateInternalError 

{ 

if (null l= timeRegulationEnabledValidator) 
timeRegulatIonEnabledValidator.validate(time); 


DRDC Valcartier TR 2007-412 


945 



public void 

timeConstrainedEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeConstrainedWasPending 
FederatelnternalError 

{ 

if (null l= timeConstrainedEnabledValidator) 
timeConstrainedEnabledValidator.validate(time); 


public void 
timeAdvanceGrant( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

JoinedFederatelsNotInTimeAdvancingState 
FederatelnternalError 

{ 

if (null l= timeAdvanceGrantValidator) 
timeAdvanceGrantValidator.validate(theTime); 


public void 
requestRetraction( 

MessageRetractionHandle theHandle) 
throws FederatelnternalError 
{ 

if (null l= requestRetractionValidator) 
requestRetractionValidator.validate(theHandle); 


//end FedAmbTimeListener 


946 


DRDC Valcartier TR 2007-412 



The FedAmbWrapper class implements the FederateAmbassador interface by 
serving as a dispatching layer between the callbacks and the event handlers. For 
each of the FederateAmbassador... sub-interfaces, FedAmbWrapper maintains a 
hash map of implementing objects, keyed by what is usually an object instance 
handle. When no handlers are registered for a given callback set, FedAmbWrapper 
acts as a null implementation. 

Handlers can be registered in hierarchical fashion, at the object instance, object 
class, and default levels. For example, when a ref lectAttributeValues callback 
is received, FedAmbWrapper will first look for a handler registered at the specific 
object instance handle received; failing that, it will look for a handler registered to 
the object instance’s class; failing that again, it will look for a default handler 
(registered under the null key). Sub-interfaces keyed to object class handles (e.g. 
obj ectDiscovery) start the look-up process at the class level. The 
Synchronization and NameReservation sub-interfaces use strings 
(synchronization labels and object instance names, respectively) as keys. The 
Restore, Save, and Time sub-interfaces, finally, admit a single handler. 

Because it incurs an overhead that may be significant, FedAmbWrapper should be 
used only when flexibility is more important than performance. 


DRDC Valcartier TR 2007-412 


947 




// File: FedAmbWrapper.java 

package ca.gc.drdc_rddc.hla.rtil516.FedAmb,- 

import j ava.util.HashMap,- 
import hla.rtil516.*; 

j * * 

* This FederateAmbassador Wrapper class serves as a dispatcher; 

* before doing an RTIambassador call that expects FederateAmbassador 

* callbacks, you register a listener or responder with the 

* appropriate class of service and the designated key. When the 

* expected callback occurs, the FedAmbWrapper dispatches it to the 

* specified listener/responder. It is the listener/responder's 

* responsibility to validate the arguments it receives (throwing any 

* of the prescribed exceptions as required) and then thread-off any 

* remaining work. 

* <p> 

* Services that are invoked at the Instance level can have 

* listeners/responders registered at that level or at the Class 

* level. As a general rule, FedAmbWrapper will look for a registered 

* listener in the following sequence: 

* <ul > 

* <li> at the Instance level (Obj ectlnstanceHandle key); 

* <li> at the known Object Class level (ObjectClassHandle key); 

* <li> at the default level listener (null key); or 

* <li> do nothing. 

* </ul> 

* Notable exceptions are the discoveryListener, interactionListener, 

* interactionAdvisoryResponder and registrationResponder services 

* (which stop at the Class level); the nameReservationListener 

* service (which can only be refined at the name level); the 

* federationSynchronizationListener service (which can only be 

* refined at the synchronization label level); and the 

* federationSaveListener, federationRestoreListener and timeListener 

* services (which are undifferentiated). 

* <p> 

* Note that, because of the overloading, you'll need to typecast the 

* null to either ObjectClassHandle or ObjectlnstanceHandle for the 

* set* method to be disambiguated. For example: 

* <p> 

* _fedAmbWrapper.setAttributeScopeListener((Obj ectClassHandle)null, 
new MyFederateAmbassadorAttributeScopeAdvisoryClient 
attributeScopeListener()); 

* <p> 

* Under IEEE 1516, the RTI is normally multi-threaded and thus each 

* FederateAmbassador callback occurs from a "Federate Service Thread" 

* belonging to the RTI (one per federate). 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.gc.ca RDDC 

Valcartier}) 

* @version 1.1 
*/ 


948 


DRDC Valcartier TR 2007-412 



public class 
FedAmbWrapper 

implements FederateAmbassador 

{ 

/** We need an RTIambassador reference for some services. */ 
private RTIambassador 
_rti ; 

/** FederateAmbassadorAttributeScopeAdvisoryClient HashMap. */ 
protected HashMap 
attributeScopeListeners; 

/** FederateAmbassadorAttributeScopeAdvisoryServer HashMap. */ 
protected HashMap 
attributeScopeResponders; 

/** FederateAmbassadorAttributeUpdateClient HashMap. */ 
protected HashMap 
attributeUpdateListeners; 

/** FederateAmbassadorAttributeUpdateServer HashMap. */ 
protected HashMap 
attributeUpdateResponders; 

/** FederateAmbassadorObjectDiscovery HashMap. */ 
protected HashMap 
discoveryListeners; 

/** FederateAmbassadorObjectRemoval HashMap. */ 
protected HashMap 
removalResponders; 

/** FederateAmbassadorRestore HashMap. */ 
protected HashMap 
federationRestoreListeners; 

/** FederateAmbassadorSave HashMap. */ 
protected HashMap 
federationSaveListeners; 

/** FederateAmbassadorSynchronization HashMap. */ 
protected HashMap 

federationSynchronizationListeners; 

/** FederateAmbassadorlnteractionAdvisory HashMap. */ 

protected HashMap 

interactionAdvisoryResponders; 

/** FederateAmbassadorInteractionOccurrence HashMap. */ 
protected HashMap 
interactionListeners; 

/** FederateAmbassadorNameReservation HashMap. */ 
protected HashMap 
nameReservationListeners; 


DRDC Valcartier TR 2007-412 


949 



/** FederateAmbassadorAttributeOwnership HashMap. */ 
protected HashMap 
ownershipListeners; 

/** FederateAmbassadorObjectRegistrationAdvisory HashMap. */ 
protected HashMap 
registrationResponders; 

/** FederateAmbassadorTime HashMap. */ 
protected HashMap 
timeListeners; 


j * * 

* Constructor. 

* @param rti an RTIambassador to be used by some services 
*/ 

public 

FedAmbWrapper(RTIambassador rti) 


_rti = rti; 

attributeScopeListeners 

attributeScopeResponders 

attributeUpdateResponders 

attributeUpdateListeners 

disc ove ryLis t ene r s 

removalResponders 

federationRestoreListeners 

federationSaveListeners 

federationSynchronizationListeners 

interactionAdvisoryResponders 

interactionListeners 

nameReservationListeners 

ownershipListeners 

registrationResponders 

timeListeners 


new HashMap(); 
new HashMap(); 
new HashMap() ; 
new HashMap () ; 
new HashMap (); 
new HashMap () ; 
new HashMap (); 
new HashMap (); 
new HashMap (); 
new HashMap (); 
new HashMap (); 
new HashMap (); 
new HashMap (); 
new HashMap (); 
new HashMap (); 


950 


DRDC Valcartier TR 2007-412 



* * 


* Associates an attributeScopeListener with a specified 
Obj ectlnstanceHandle. 

* The null ObjectlnstanceHandle designates the default (fall- 
through) listener. 

* A null FederateAmbassadorAttributeScopeAdvisoryClient 
unassociates the Obj ectlnstanceHandle. 

* @param theObject the ObjectlnstanceHandle with which to 
associate the listener; 

* the null value is the default (fall-through) listener 

* @param attributeScopeListener the 
FederateAmbassadorAttributeScopeAdvisoryClient to associate with 

* the specified ObjectlnstanceHandle; if null, behaves as a 
remove() 

* @return the previous attributeScopeListener associated with the 
Obj ectlnstanceHandle 

* (null if there was no previous mapping) 

*/ 

public Object 
setAttributeScopeListener( 

Obj ectlnstanceHandle theObj ect, 

FederateAmbassadorAttributeScopeAdvisoryClient 
attributeScopeListener) 

{ 

if (null==attributeScopeListener) 

{ 

return attributeScopeListeners.remove(theObj ect) ; 

} 

else 

{ 

return attributeScopeListeners.put(theObj ect, 
attributeScopeListener); 


DRDC Valcartier TR 2007-412 


951 



* * 


* Associates an attributeScopeListener with a specified 
Obj ectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
listener. 

* A null FederateAmbassadorAttributeScopeAdvisoryClient 
unassociates the Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param attributeScopeListener the 
FederateAmbassadorAttributeScopeAdvisoryClient to associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous attributeScopeListener associated with the 
Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 
setAttributeScopeListener( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorAttributeScopeAdvisoryClient 
attributeScopeListener) 

{ 

if (null==attributeScopeListener) 

{ 

return attributeScopeListeners . remove (theOb j ectClass) ,- 

} 

else 

{ 

return attributeScopeListeners.put(theObj ectClass, 
attributeScopeListener) ,- 


952 


DRDC Valcartier TR 2007-412 



* * 


* Associates an attributeScopeResponder with a specified 
Obj ectlnstanceHandle. 

* The null ObjectlnstanceHandle designates the default (fall- 
through) responder. 

* A null FederateAmbassadorAttributeScopeAdvisoryServer 
unassociates the Obj ectlnstanceHandle. 

* @param theObject the ObjectlnstanceHandle with which to 
associate the responder,- 

* the null value is the default (fall-through) responder 

* @param attributeScopeResponder the 
FederateAmbassadorAttributeScopeAdvisoryServer to associate with 

* the specified ObjectlnstanceHandle; if null, behaves as a 
remove() 

* @return the previous attributeScopeResponder associated with the 
Obj ectlnstanceHandle 

* (null if there was no previous mapping) 

*/ 

public Object 

setAttributeScopeResponder( 

Obj ectlnstanceHandle theObj ect, 

FederateAmbassadorAttributeScopeAdvisoryServer 
attributeScopeResponder) 

{ 

if (null==attributeScopeResponder) 

{ 

return attributeScopeResponders.remove(theObj ect),- 

} 

else 

{ 

return attributeScopeResponders.put(theObject, 
attributeScopeResponder) ,- 


DRDC Valcartier TR 2007-412 


953 



* * 


* Associates an attributeScopeResponder with a specified 
Obj ectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
responder. 

* A null FederateAmbassadorAttributeScopeAdvisoryServer 
unassociates the Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the responder,- 

* the null value is the default (fall- 
through) responder 

* @param attributeScopeResponder the 
FederateAmbassadorAttributeScopeAdvisoryServer to associate with 

* the specified ObjectClassHandle,- 
if null, behaves as a remove() 

* @return the previous attributeScopeResponder associated with the 
Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 

setAttributeScopeResponder( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorAttributeScopeAdvisoryServer 
attributeScopeResponder) 

{ 

if (null==attributeScopeResponder) 

{ 

return attributeScopeResponders . remove (theObj ectClass) ,- 

} 

else 

{ 

return attributeScopeResponders.put(theObj ectClass, 
attributeScopeResponder) ,- 


954 


DRDC Valcartier TR 2007-412 



* * 


* Associates an attributeUpdateListener with a specified 
Obj ectlnstanceHandle. 

* The null ObjectlnstanceHandle designates the default (fall- 
through) listener. 

* A null FederateAmbassadorAttributeUpdateClient unassociates the 
Obj ectlnstanceHandle. 

* @param theObject the ObjectlnstanceHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param attributeUpdateListener the 
FederateAmbassadorAttributeUpdateClient to associate with 

* the specified ObjectlnstanceHandle; if null, behaves as a 
remove() 

* @return the previous attributeUpdateListener associated with the 
Obj ectlnstanceHandle 

* (null if there was no previous mapping) 

*/ 

public Object 

setAttributeUpdateListener( 

Obj ectlnstanceHandle theObj ect, 

FederateAmbassadorAttributeUpdateClient attributeUpdateListener) 

{ 

if (null==attributeUpdateListener) 

{ 

return attributeUpdateListeners.remove(theObj ect),- 

} 

else 

{ 

return attributeUpdateListeners.put(theObject, 
attributeUpdateListener) ,- 


DRDC Valcartier TR 2007-412 


955 



* * 


* Associates an attributeUpdateListener with a specified 
Obj ectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
listener. 

* A null FederateAmbassadorAttributeUpdateClient unassociates the 
Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param attributeUpdateListener the 
FederateAmbassadorAttributeUpdateClient to associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous attributeUpdateListener associated with the 
Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 

setAttributeUpdateListener( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorAttributeUpdateClient attributeUpdateListener) 

{ 

if (null==attributeUpdateListener) 

{ 

return attributeUpdateListeners.remove(theObj ectClass) ,- 

} 

else 

{ 

return attributeUpdateListeners.put(theObj ectClass, 
attributeUpdateListener) ,- 


956 


DRDC Valcartier TR 2007-412 



* * 


* Associates an attributeUpdateResponder with a specified 
Obj ectlnstanceHandle. 

* The null ObjectlnstanceHandle designates the default (fall- 
through) responder. 

* A null FederateAmbassadorAttributeUpdateServer unassociates the 
Obj ectlnstanceHandle. 

* @param theObject the ObjectlnstanceHandle with which to 
associate the responder; 

* the null value is the default (fall-through) responder 

* @param attributeUpdateResponder the 
FederateAmbassadorAttributeUpdateServer to associate with 

* the specified ObjectlnstanceHandle; if null, behaves as a 
remove() 

* @return the previous attributeUpdateResponder associated with 
the Obj ectlnstanceHandle 

* (null if there was no previous mapping) 

*/ 

public Object 

setAttributeUpdateResponder( 

Obj ectlnstanceHandle theObj ect, 

FederateAmbassadorAttributeUpdateServer 
attributeUpdateResponder) 

{ 

if (null==attributeUpdateResponder) 

{ 

return attributeUpdateResponders.remove(theObj ect) ; 

} 

else 

{ 

return attributeUpdateResponders.put(theObject, 
attributeUpdateResponder) ; 


DRDC Valcartier TR 2007-412 


957 



* * 


* Associates an attributeUpdateResponder with a specified 
Obj ectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
responder. 

* A null FederateAmbassadorAttributeUpdateServer unassociates the 
Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the responder; 

* the null value is the default (fall-through) responder 

* @param attributeUpdateResponder the 
FederateAmbassadorAttributeUpdateServer to associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous attributeUpdateResponder associated with 
the Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 

setAttributeUpdateResponder( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorAttributeUpdateServer 
attributeUpdateResponder) 

{ 

if (null==attributeUpdateResponder) 

{ 

return attributeUpdateResponders.remove(theObj ectClass) ; 

} 

else 

{ 

return attributeUpdateResponders.put(theObj ectClass, 
attributeUpdateResponder); 


958 


DRDC Valcartier TR 2007-412 



* * 


* Associates a discoveryListener with a specified 
ObjectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
listener. 

* A null FederateAmbassadorObjectDiscovery unassociates the 
Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param discoveryListener the FederateAmbassadorObjectDiscovery 
to associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous discoveryListener associated with the 
Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 
setDiscoveryListener( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorObj ectDiscovery discoveryListener) 

{ 

if (null==discoveryListener) 

{ 

return discoveryListeners . remove (theObj ectClass) ,- 

} 

else 

{ 

return discoveryListeners.put(theObjectClass, 
discoveryListener) ,- 


DRDC Valcartier TR 2007-412 


959 



* * 


* Associates a removalResponder with a specified 
Obj ectInstanceHandle. 

* The null ObjectlnstanceHandle designates the default (fall- 
through) listener. 

* A null FederateAmbassadorObjectRemoval unassociates the 
Obj ectlnstanceHandle. 

* @param theObject the ObjectlnstanceHandle with which to 
associate the listener; 

* the null value is the default (fall-through) listener 

* @param removalResponder the FederateAmbassadorObjectRemoval to 
associate with 

* the specified ObjectlnstanceHandle; if null, behaves as a 
remove() 

* @return the previous removalResponder associated with the 
Obj ectlnstanceHandle 

* (null if there was no previous mapping) 

*/ 

public Object 
setRemovalResponder( 

Obj ectlnstanceHandle theObj ect, 

FederateAmbassadorObj ectRemoval removalResponder) 

{ 

if (null==removalResponder) 

{ 

return removalResponders.remove(theObject); 

} 

else 

{ 

return removalResponders.put(theObject, removalResponder); 


960 


DRDC Valcartier TR 2007-412 



* * 


* Associates a removalResponder with a specified 
ObjectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
listener. 

* A null FederateAmbassadorObjectRemoval unassociates the 
Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param removalResponder the FederateAmbassadorObjectRemoval to 
associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous removalResponder associated with the 
Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 
setRemovalResponder( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorObj ectRemoval removalResponder) 

{ 

if (null==removalResponder) 

{ 

return removalResponders .remove (theObj ectClass) ,- 

} 

else 

{ 

return removalResponders.put(theObj ectClass, 
removalResponder) ,- 


DRDC Valcartier TR 2007-412 


961 



* * 


* Sets the federationRestoreListener. 

* Unlike the other callback subsets, no dispatching occurs (ther 
can be only one listener). 

* A null FederateAmbassadorRestore is allowed. 

* @param federationRestoreListener the FederateAmbassadorRestore 
to associate; 

* if null, behaves as a remove() 

* @return the previous federationRestoreListener (null if there 
was no previous mapping) 

*/ 

public Object 

setFederationRestoreListener ( 

FederateAmbassadorRestore federationRestoreListener) 

{ 

if (null==federationRestoreListener) 

{ 

return f ederat ionRestoreListeners . remove (null) ,- 

} 

else 

{ 

return federatIonRestoreListeners.put(null, 
federationRestoreListener) ,- 


j * * 

* Sets the federationSaveListener. 

* Unlike the other callback subsets, no dispatching occurs (ther 
can be only one listener). 

* A null FederateAmbassadorSave is allowed. 

* @param federationSaveListener the FederateAmbassadorSave to 
associate; 

* if null, behaves as a remove() 

* @return the previous federationSaveListener (null if there was 
no previous mapping) 

*/ 

public Object 
setFederationSaveListener( 

FederateAmbassadorSave federationSaveListener) 

{ 

if (null==federationSaveListener) 

{ 

return f ederat ionSaveListeners . remove (null) ,- 

} 

else 

{ 

return federatIonSaveListeners.put (null, 
federationSaveListener) ,- 


962 


DRDC Valcartier TR 2007-412 



* * 


* Associates a federationSynchronizationListener with a specified 
synchronization label. 

* The null String (not the empty String) designates the default 
(fall-through) listener. 

* A null FederateAmbassadorSynchronization unassociates the 
String. 

* @param synchronizationPointLabel the String with which to 
associate the listener; 

* the null value is the default (fall-through) listener 

* @param federationSynchronizationListener the 
FederateAmbassadorSynchronization to associate with 

* the specified String; if null, behaves as a remove() 

* @return the previous federationSynchronizationListener 
associated with the String 

* (null if there was no previous mapping) 

*/ 

public Object 

setFederationSynchronizationListener ( 

String synchronizationPointLabel, 

FederateAmbassadorSynchronization 
federationSynchronizationListener) 

{ 

if (null==federationSynchronizationListener) 

{ 

return 

federationSynchronizationListeners.remove(synchronizationPointLabel); 

} 

else 

{ 

return 

federationSynchronizationListeners.put(synchronizationPointLabel, 
federationSynchronizationListener); 


DRDC Valcartier TR 2007-412 


963 



//FederateAmbassadorlnteractionAdvisory 

j * * 

* Associates an interactionAdvisoryResponder with a specified 
InteractionClassHandle. 

* The null InteractionClassHandle designates the default (fall- 
through) listener. 

* A null FederateAmbassadorlnteractionAdvisory unassociates the 
InteractionClassHandle. 

* @param interactionClass the InteractionClassHandle with which to 
associate the listener; 

* the null value is the default (fall-through) listener 

* @param interactionAdvisoryResponder the 
FederateAmbassadorlnteractionAdvisory to associate with 

* the specified interactionClass; if null, behaves as a remove() 

* @return the previous interactionAdvisoryResponder associated 
with the interactionClass 

* (null if there was no previous mapping) 

*/ 

public Object 

setInteractionAdvisoryResponder( 

InteractionClassHandle interactionClass, 

FederateAmbassadorlnteractionAdvisory 
interactionAdvisoryResponder) 

{ 

if (null==interactionAdvisoryResponder) 

{ 

return 

interactionAdvisoryResponders.remove(interactionClass); 

} 

else 

{ 

return interactionAdvisoryResponders.put(interactionClass, 
interactionAdvisoryResponder); 


964 


DRDC Valcartier TR 2007-412 



* * 


* Associates an interactionListener with a specified 
InteractionClassHandle. 

* The null InteractionClassHandle designates the default (fall- 
through) listener. 

* A null FederateAmbassadorlnteractionOccurrence unassociates the 
InteractionClassHandle. 

* @param interactionClass the InteractionClassHandle with which to 
associate the listener; 

* the null value is the default (fall-through) listener 

* @param interactionListener the 
FederateAmbassadorlnteractionOccurrence to associate with 

* the specified interactionClass; if null, behaves as a remove() 

* @return the previous interactionListener associated with the 
interactionClass 

* (null if there was no previous mapping) 

*/ 

public Object 
setlnteractionListener ( 

InteractionClassHandle interactionClass, 

FederateAmbassadorlnteractionOccurrence interactionListener) 

{ 

if (null==interactionListener) 

{ 

return interactionListeners.remove(interactionClass); 

} 

else 

{ 

return interactionListeners.put(interactionClass, 
interactionListener); 


DRDC Valcartier TR 2007-412 


965 



* * 


* Associates a nameReservationListener with a specified String. 

* The null String (not the empty String) designates the default 
(fall-through) listener. 

* A null FederateAmbassadorNameReservation unassociates the 
String. 

* @param objectName the String with which to associate the 
listener; 

* the null value is the default (fall-through) listener 

* @param nameReservationListener the 
FederateAmbassadorNameReservation to associate with 

* the specified objectName; if null, behaves as a remove() 

* @return the previous nameReservationListener associated with the 
obj ectName 

* (null if there was no previous mapping) 

*/ 

public Object 

setNameReservationListener( 

String obj ectName, 

FederateAmbassadorNameReservation nameReservationListener) 

{ 

if (null==nameReservationListener) 

{ 

return nameReservationListeners . remove (obj ectName) ,- 

} 

else 

{ 

return nameReservationListeners.put(obj ectName, 
nameReservationListener) ,- 


966 


DRDC Valcartier TR 2007-412 



* * 


* Associates an InstanceAttributeOwnershipListener with a 
specified ObjectlnstanceHandle. 

* The null ObjectlnstanceHandle designates the default (fall- 
through) listener. 

* A null FederateAmbassadorAttributeOwnership unassociates the 
Obj ectlnstanceHandle. 

* @param theObject the ObjectlnstanceHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param ownershipListener the 
FederateAmbassadorAttributeOwnership to associate with 

* the specified ObjectlnstanceHandle; if null, behaves as a 
remove() 

* @return the previous ownershipListener associated with the 
theObj ect 

* (null if there was no previous mapping) 

*/ 

public Object 
setOwnershipListener( 

Obj ectlnstanceHandle theObj ect, 

FederateAmbassadorAttributeOwnership ownershipListener) 

{ 

if (null==ownershipListener) 

{ 

return ownershipListeners.remove(theObj ect),- 

} 

else 

{ 

return ownershipListeners . put (theObject, ownershipListener) ,- 


DRDC Valcartier TR 2007-412 


967 



* * 


* Associates an InstanceAttributeOwnershipListener with a 
specified Obj ectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
listener. 

* A null FederateAmbassadorAttributeOwnership unassociates the 
Obj ectClassHandle. 

* @param theObjectClass the ObjectClassHandle with which to 
associate the listener,- 

* the null value is the default (fall-through) listener 

* @param ownershipListener the 
FederateAmbassadorAttributeOwnership to associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous ownershipListener associated with the 
Obj ectClassHandle 

* (null if there was no previous mapping) 

*/ 

public Object 
setOwnershipListener( 

Obj ectClassHandle theObj ectClass, 

FederateAmbassadorAttributeOwnership ownershipListener) 

{ 

if (null==ownershipListener) 

{ 

return ownershipListeners.remove(theObj ectClass) ,- 

} 

else 

{ 

return ownershipListeners.put(theObj ectClass, 
ownershipListener) ,- 


968 


DRDC Valcartier TR 2007-412 



* * 


* Associates a RegistrationAdvisoryResponder with a specified 
ObjectClassHandle. 

* The null ObjectClassHandle designates the default (fall-through) 
responder. 

* A null FederateAmbassadorObjectRegistrationAdvisory unassociates 
the Obj ectClassHandle. 

* @param theClass the ObjectClassHandle with which to associate 
the responder; 

* the null value is the default (fall-through) responder 

* @param registrationResponder the 
FederateAmbassadorObjectRegistrationAdvisory to associate with 

* the specified ObjectClassHandle; if null, behaves as a remove() 

* @return the previous registrationResponder associated with the 
theClass 

* (null if there was no previous mapping) 

*/ 

public Object 
setRegistrationResponder( 

Obj ectClassHandle theClass, 

FederateAmbassadorObj ectRegistrationAdvisory 
registrationResponder) 

{ 

if (null==registrationResponder) 

{ 

return registrationResponders.remove(theClass),- 

} 

else 

{ 

return registrationResponders.put(theClass, 
registrationResponder); 


j * * 

* Sets the timeListener. 

* Unlike the other callback subsets, no dispatching occurs (ther 
can be only one listener). 

* A null FederateAmbassadorTime is allowed. 

* @param timeListener the FederateAmbassadorTime to associate,- if 
null, behaves as a remove() 

* @return the previous federationTimeListener (null if there was 
no previous mapping) 

*/ 

public Object 
setTimeListener( 

FederateAmbassadorTime timeListener) 

{ 

if (null==timeListener) 

{ 

return t imeListeners . remove (null) ,- 

} 

else 

{ 

return timeListeners . put (null, timeListener) ,- 


DRDC Valcartier TR 2007-412 


969 



// FederateAmbassador implementation // 


111111111111111111111111111111111111111 

//FederateAmbassadorAttributeOwnership part 

private FederateAmbassadorAttributeOwnership 
getOwnershipListener( 

Obj ectInstanceHandle theObj ect) 

{ 

Obj ect listener = ownershipListeners.get(theObj ect) ,- 

//Fall-through to Class level? 

try 


if (null==listener) listener = 

ownershipListeners- get(_rti.getKnownObj ectClassHandle(theObj ect)) ,- 
//Fall-through to default handler? 

if (null==listener) listener = ownershipListeners .get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorAttributeOwnership)listener,- 

} 

//ObjectlnstanceNotKnown, etc. can't happen 
catch (RTIexception ignored) { return null; } 


public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 

AttributeNotPublished, 
FederatelnternalError 


try 


getOwnershipListener(theObj ect) .requestAttributeOwnershipAssumption(th 
eObject, offeredAttributes, userSuppliedTag) ,- 
} 

catch (NullPointerException ignored) {} 


970 


DRDC Valcartier TR 2007-412 



public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotOwned, 

AttributeDivestItureWasNotRequested 
FederateInternalError 


try 


getOwnershipListener(theObj ect) .requestDivestitureConfirmation(theObj e 
ct, offeredAttributes),- 
} 

catch (NullPointerException ignored) {} 


public void 

attributeOwnershipAcquisitionNotification( 
Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeAcquisitionWasNotRequested 
AttributeAlreadyOwned, 
AttributeNotPublished, 

FederateInternalError 


try 


getOwnershipListener(theObj ect) .attributeOwnershipAcquisitionNotificat 
ion (theObj ect, securedAttributes, userSuppliedTag) ,- 
} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


971 



public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeAcquisitionWasNotRequested 
FederatelnternalError 


try 


getOwnershipListener(theObj ect) .attributeOwnershipUnavailable(theObj ec 
t, theAttributes),- 
} 

catch (NullPointerException ignored) {} 


public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet candidateAttributes 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try 


getOwnershipListener(theObj ect) .requestAttributeOwnershipRelease(theOb 
ject, candidateAttributes, userSuppliedTag) ,- 
} 

catch (NullPointerException ignored) {} 


public void 

confIrmAttributeOwnershipAcquisitionCancellation( 
Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 
FederatelnternalError 


try 


getOwnershipListener(theObj ect) .confIrmAttributeOwnershipAcquisitionCa 
ncellation (theObj ect, theAttributes) ,- 
} 

catch (NullPointerException ignored) {} 


972 


DRDC Valcartier TR 2007-412 



public void 

informAttributeOwnership( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandle theAttribute 

FederateHandle theOwner) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
FederateInternalError 


try 


getOwnershipListener(theObj ect) .informAttributeOwnership(theObj ect 
theAttribute, theOwner),- 
} 

catch (NullPointerException ignored) {} 


public void 
attributeIsNotOwned( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
FederateInternalError 


try 


getOwnershipListener(theObj ect) .attributelsNotOwned(theObj ect 
theAttribute) ,- 
} 

catch (NullPointerException ignored) {} 


public void 
attributelsOwnedByRTI( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
FederateInternalError 


try 


getOwnershipListener(theObj ect) .attributelsOwnedByRTI(theObj ect 
theAttribute) ,- 
} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


973 



//FederateAmbassadorAttributeScopeAdvisoryClient part 


private FederateAmbassadorAttributeScopeAdvisoryClient 
getAttributeScopeListener( 

Obj ectInstanceHandle theObj ect) 

{ 

Obj ect listener = attributeScopeListeners.get(theObj ect),- 

//Fall-through to Class level? 

try 


if (null==listener) listener = 

attributeScopeListeners.get(_rti.getKnownObj ectClassHandle(theObj ect)) 

//Fall-through to default handler? 
if (null==listener) listener = 
attributeScopeListeners-get(null) ,- 
//Otherwise, give up 
if (null==listener) return null; 
return 

(FederateAmbassadorAttributeScopeAdvisoryClient)listener,- 

} 

//ObjectlnstanceNotKnown, etc. can't happen 
catch (RTIexception ignored) { return null; } 


public void 
attributesInScope( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 


try 


getAttributeScopeListener (theObj ect) .attributesInScope (theObj ect 
theAttributes) ,- 
} 

catch (NullPointerException ignored) {} 


974 


DRDC Valcartier TR 2007-412 



public void 
attributesOutOfScope( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotSubscribed, 

FederateInternalError 


try 


getAttributeScopeListener(theObj ect) .attributesOutOfScope (theObj ect 
theAttributes); 

} 

catch (NullPointerException ignored) {} 


//FederateAmbassadorAttributeScopeAdvisoryServer part 

private FederateAmbassadorAttributeScopeAdvisoryServer 
getAttributeScopeResponder( 

Obj ectlnstanceHandle theObj ect) 

{ 

Object listener = attributeScopeResponders.get(theObject); 

//Fall-through to Class level? 

try 


if (null==listener) listener = 

attributeScopeResponders- get(_rti.getKnownObjectClassHandle(theObj ect) 

) ; 

//Fall-through to default handler? 
if (null==listener) listener = 
attributeScopeResponders.get(null); 

//Otherwise, give up 

if (null==listener) return null; 

return 

(FederateAmbassadorAttributeScopeAdvisoryServer)listener; 

} 

//ObjectInstanceNotKnown, etc. can't happen 
catch (RTIexception ignored) { return null; } 


DRDC Valcartier TR 2007-412 


975 



public void 

turnUpdatesOnForObjectlnstance( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try 


getAttributeScopeResponder(theObj ect) .turnUpdatesOnForOb]ectlnstance(t 
heObject, theAttributes) ,- 
} 

catch (NullPointerException ignored) {} 


public void 

turnUpdatesOffForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 
throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try 


getAttributeScopeResponder(theObj ect) .turnUpdatesOffForObj ectlnstance( 
theObject, theAttributes) ,- 
} 

catch (NullPointerException ignored) {} 


976 


DRDC Valcartier TR 2007-412 



//FederateAmbassadorAttributeUpdateClient part 

private FederateAmbassadorAttributeUpdateClient 
getAttributeUpdateListener( 

Obj ectInstanceHandle theObject) 

{ 

Object listener = attributeUpdateListeners.get(theObject),- 
//Fall-through to Class level? 
try 
{ 

if (null==listener) listener = 

attributeUpdateListeners- get(_rti.getKnownObjectClassHandle(theObj ect) 

) ; 

//Fall-through to default handler? 
if (null==listener) listener = 
attributeUpdateListeners-get(null),- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorAttributeUpdateClient)listener,- 

} 

//ObjectInstanceNotKnown, etc. can't happen 
catch (RTIexception ignored) { return null; } 


public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag 

OrderType sentOrdering, 

TransportationType theTransport) 

throws Obj ectInstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotSubscribed, 

FederateInternalError 

{ 

try 


getAttributeUpdateListener(theObj ect) .reflectAttributeValues(theObj ect 
, theAttributes, userSuppliedTag, sentOrdering, theTransport); 

} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


977 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 


try 


getAttributeUpdateListener(theObj ect) .reflectAttributeValues(theObj ect 
, theAttributes, userSuppliedTag, sentOrdering, theTransport, 
sentRegions) ,- 
} 

catch (NullPointerException ignored) {} 


public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 


try 


getAttributeUpdateListener(theObj ect) .reflectAttributeValues(theObj ect 
, theAttributes, userSuppliedTag, sentOrdering, theTransport, theTime, 
receivedOrdering) ,- 
} 

catch (NullPointerException ignored) {} 


978 


DRDC Valcartier TR 2007-412 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 
LogicalTime 
OrderType 
RegionHandleSet 
throws Obj ectlnstanceNotKnown 
AttributeNotRecognized 
AttributeNotSubscribed 
FederateInternalError 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
sentRegions) 


try 


getAttributeUpdateListener(theObject) .reflectAttributeValues(theObj ect 
, theAttributes, userSuppliedTag, sentOrdering, theTransport, theTime, 
receivedOrdering, sentRegions) ,- 
} 

catch (NullPointerException ignored) {} 


public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle) 


throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotSubscribed, 
InvalidLogicalTime, 
FederateInternalError 


try 


getAttributeUpdateListener(theObj ect) .reflectAttributeValues(theObj ect 
, theAttributes, userSuppliedTag, sentOrdering, theTransport, theTime, 
receivedOrdering, retract ionHandle) ,- 
} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


979 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[ ] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 

RegionHandleSet 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
sentRegions) 


throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
At tributeNotSubscribed, 
InvalidLogicalTime, 
FederatelnternalError 


try 


getAttributeUpdateListener(theObject) .reflectAttributeValues(theObj ect 
, theAttributes, userSuppliedTag, sentOrdering, theTransport, theTime, 
receivedOrdering, retractionHandle, sentRegions) ,- 
} 

catch (NullPointerException ignored) {} 


//FederateAmbassadorAttributeUpdateServer part 

private FederateAmbassadorAttributeUpdateServer 
getAttributeUpdateResponder( 

Obj ectlnstanceHandle theObj ect) 

{ 

Obj ect listener = attributeUpdateResponders - get (theOb j ect) ,- 

//Fall-through to Class level? 

try 


if (null==listener) listener = 

attributeUpdateResponders-get(_rti.getKnownObj ectClassHandle (theObj ect 

) ) ; 

//Fall-through to default handler? 
if (null==listener) listener = 
attributeUpdateResponders -get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorAttributeUpdateServer) listener ,- 

} 

//ObjectlnstanceNotKnown, etc. can't happen 
catch (RTIexception ignored) { return null; } 


980 


DRDC Valcartier TR 2007-412 



public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeNotOwned, 

FederateInternalError 


try 


getAttributeUpdateResponder(theObject).provideAttributeValueUpdate(the 
Object, theAttributes, userSuppliedTag),- 
} 

catch (NullPointerException ignored) {} 


//FederateAmbassadorObj ectDiscovery part 

private FederateAmbassadorObj ectDiscovery 
getDiscoveryListener( 

Obj ectClassHandle theObj ectClass) 

{ 

Object listener = discoveryListeners.get(theObjectClass),- 
//Fall-through to default handler? 

if (null==listener) listener = discoveryListeners .get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorObj ectDiscovery) listener ,- 


public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 
FederateInternalError 


try 


getDiscoveryListener(theObj ectClass) .discoverObj ectInstance(theObj ect 
theObj ectClass , objectName) ,- 
} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


981 



//FederateAmbassadorObj ectRemoval part 


private FederateAmbassadorOb]ectRemoval 
getRemovalResponder( 

Obj ectInstanceHandle theObj ect) 

{ 

Obj ect listener = removalResponders.get(theObj ect),- 

//Fall-through to Class level? 

try 


if (null==listener) listener = 

removalResponders.get(_rti.getKnownObj ectClassHandle(theObj ect)) ,- 
//Fall-through to default handler? 

if (null==listener) listener = removalResponders . get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorObj ectRemoval)listener,- 

} 

//ObjectlnstanceNotKnown, etc. can't happen 
catch (RTIexception ignored) { return null; } 


public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag 

OrderType sentOrdering) 

throws Obj ectlnstanceNotKnown, 
FederatelnternalError 


try 


getRemovalResponder(theObj ect) .removeObj ectlnstance(theObj ect 
userSuppliedTag, sentOrdering) ,- 
} 

catch (NullPointerException ignored) {} 


public void 
removeObj ectlnstance 
Obj ectlnstanceHandle 
byte[ ] 

OrderType 
LogicalTime 
OrderType 
throws Obj ectlnstanceNotKnown 
FederatelnternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering) 


try 


getRemovalResponder(theObj ect) .removeObj ectlnstance(theObj ect 
userSuppliedTag, sentOrdering, theTime, receivedOrdering) ,- 
} 

catch (NullPointerException ignored) {} 


982 


DRDC Valcartier TR 2007-412 



public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle 
byte[] 

OrderType 
LogicalTime 
OrderType 

MessageRetractionHandle retractionHandle 
throws Obj ectlnstanceNotKnown, 
InvalidLogicalTime, 

FederateInternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 


try 


getRemovalResponder(theObj ect) .removeObj ectlnstance(theObj ect 
userSuppliedTag, sentOrdering, theTime, receivedOrdering, 
retractionHandle) ,- 
} 

catch (NullPointerException ignored) {} 


//FederateAmbassadorRestore part 

private FederateAmbassadorRestore 
getFederationRestoreListener () 

{ 

Object listener = federationRestoreListeners .get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 
return (FederateAmbassadorRestore) listener,- 


public void 

requestFederationRestoreSucceeded( 
String label) 

throws FederateInternalError 

{ 

try 


getFederationRestoreListener().requestFederationRestoreSucceeded(label 


catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


983 



public void 

requestFederationRestoreFailed( 
String label) 

throws FederatelnternalError 

{ 

try 


getFederationRestoreListener().requestFederationRestoreFailed(label); 

} 

catch (NullPointerException ignored) {} 


public void 

federationRestoreBegun () 
throws FederatelnternalError 
{ 

try 


getFederationRestoreListener().federationRestoreBegun(); 

} 

catch (NullPointerException ignored) {} 


public void 

InitiateFederateRestore( 

String label, 

FederateHandle federateHandle) 
throws SpecifiedSaveLabelDoesNotExist 
CouldNotInitiateRestore, 
FederatelnternalError 


try 

{ 

getFederationRestoreListener () .InitiateFederateRestore(label 
federateHandle); 

} 

catch (NullPointerException ignored) {} 


public void 
federationRestored () 
throws FederatelnternalError 
{ 

try 


getFederationRestoreListener().federationRestored(); 

} 

catch (NullPointerException ignored) {} 


984 


DRDC Valcartier TR 2007-412 



public void 
federationNotRestored( 

RestoreFailureReason reason) 
throws FederateInternalError 
{ 

try 


getFederationRestoreListener().federationNotRestored(reason); 

} 

catch (NullPointerException ignored) {} 


public void 

federationRestoreStatusResponse( 

FederateHandleRestoreStatusPair[] response) 
throws FederateInternalError 
{ 

try 


getFederationRestoreListener().federationRestoreStatusResponse(respons 
e) ; 


catch (NullPointerException ignored) {} 


//FederateAmbassadorSave part 

private FederateAmbassadorSave 
getFederationSaveListener() 

{ 

Object listener = federationSaveListeners.get(null); 
//Otherwise, give up 
if (null==listener) return null; 
return (FederateAmbassadorSave)listener; 


public void 
initiateFederateSave( 

String label) 

throws UnableToPerformSave, 
FederateInternalError 


try 


getFederationSaveListener().initiateFederateSave(label); 

} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


985 



public void 
initiateFederateSave( 

String label, 

LogicalTime time) 
throws InvalidLogicalTime, 
UnableToPerformSave, 
FederatelnternalError 


try 


getFederationSaveListener().InitiateFederateSave(label 

time) 


catch (NullPointerException ignored) {} 


public void 
federationSaved() 
throws FederatelnternalError 
{ 

try 


getFederationSaveListener().federationSaved(); 

} 

catch (NullPointerException ignored) {} 


public void 
federationNotSaved( 

SaveFailureReason reason) 
throws FederatelnternalError 
{ 

try 


getFederationSaveListener().federationNotSaved(reason); 

} 

catch (NullPointerException ignored) {} 


public void 

federationSaveStatusResponse( 

FederateHandleSaveStatusPair[] response) 
throws FederatelnternalError 
{ 

try 


getFederationSaveListener().federationSaveStatusResponse(response); 

} 

catch (NullPointerException ignored) {} 


986 


DRDC Valcartier TR 2007-412 



//FederateAmbassadorSynchronization part 


private FederateAmbassadorSynchronization 
getFederationSynchronizationListener ( 

String synchronizationPointLabel) 

{ 

Object listener = 

federationSynchronizationListeners- get(synchronizationPointLabel) ; 
//Fall-through to default handler? 
if (null==listener) listener = 
federationSynchronizationListeners.get(null); 

//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorSynchronization)listener; 


public void 

synchronizationPointRegistrationSucceeded( 
String synchronizationPointLabel) 
throws FederateInternalError 
{ 

try 


getFederationSynchronizationListener(synchronizationPointLabel).synchr 
onizationPointRegistrationSucceeded(synchronizationPointLabel); 

} 

catch (NullPointerException ignored) {} 


public void 

synchronizationPointRegistrationFailed( 

String synchronizationPointLabel 

SynchronizationPointFailureReason reason) 
throws FederateInternalError 
{ 

try 


getFederationSynchronizationListener(synchronizationPointLabel).synchr 
onizationPointRegistrationFailed(synchronizationPointLabel, reason); 

} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


987 



public void 

announceSynchronizationPoint( 

String synchronizationPointLabel 
byte[] userSuppliedTag) 
throws FederatelnternalError 
{ 

try 


getFederationSynchronizationListener(synchronizationPointLabel).announ 
ceSynchronizationPoint(synchronizationPointLabel, userSuppliedTag); 

} 

catch (NullPointerException ignored) {} 


public void 

federationSynchronized( 

String synchronizatIonPointLabel) 
throws FederatelnternalError 
{ 

try 


getFederationSynchronizationListener(synchronizatIonPointLabel).federa 
tionSynchronized(synchronizatIonPointLabel); 

} 

catch (NullPointerException ignored) {} 


//FederateAmbassadorlnteractionAdvisory part 

private FederateAmbassadorlnteractionAdvisory 
getInteract!onAdvisoryResponder( 

InteractionClassHandle interactionClass) 

{ 

Object listener = 

InteractionAdvisoryResponders-get(interactionClass); 
//Fall-through to default handler? 
if (null==listener) listener = 
InteractionAdvisoryResponders-get(null) ; 

//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorlnteractionAdvisory)listener; 


988 


DRDC Valcartier TR 2007-412 



public void 
turnlnteractionsOn( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 
FederateInternalError 


try 


getlnteractionAdvisoryResponder(theHandle).turnlnteractionsOn(theHandl 
e) ; 


catch (NullPointerException ignored) {} 


public void 
turnlnteractionsOff( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 
FederateInternalError 


try 


getlnteractionAdvisoryResponder(theHandle).turnlnteractionsOff(theHand 
le) ,- 


catch (NullPointerException ignored) {} 


//FederateAmbassadorInteractionOccurrence part 

private FederateAmbassadorInteractionOccurrence 
getlnteractionListener ( 

InteractionClassHandle interactionClass) 

{ 

Object listener = interact ionListeners - get (interact ionClass) ,- 
//Fall-through to default handler? 

if (null ==listener) listener = interactionListeners .get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassador Inter act ionOccurrence) listener,- 


DRDC Valcartier TR 2007-412 


989 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederatelnternalError 


try 


getInteractionListener(interactionClass).receivelnteraction(interactio 
nClass, theParameters, userSuppliedTag, sentOrdering, theTransport) ,- 
} 

catch (NullPointerException ignored) {} 


public void 
receivelnteraction( 

InteractionClassHandle interactionClass 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederatelnternalError 


try 


getInteractionListener(interactionClass).receivelnteraction(interactio 
nClass, theParameters, userSuppliedTag, sentOrdering, theTransport, 
sentRegions) ,- 
} 

catch (NullPointerException ignored) {} 


990 


DRDC Valcartier TR 2007-412 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederateInternalError 


try 


getInteractionListener(interactionClass).receivelnteraction(interactio 
nClass, theParameters, userSuppliedTag, sentOrdering, theTransport, 
theTime, receivedOrdering) ,- 
} 

catch (NullPointerException ignored) {} 


public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederateInternalError 


try 


getInteractionListener(interactionClass).receivelnteraction(interactio 
nClass, theParameters, userSuppliedTag, sentOrdering, theTransport, 
theTime, receivedOrdering, sentRegions) ,- 
} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


991 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle) 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederatelnternalError 


try 


getInteractionListener(interactionClass).receivelnteraction(interactio 
nClass, theParameters, userSuppliedTag, sentOrdering, theTransport, 
theTime, receivedOrdering, messageRetractionHandle) ,- 
} 

catch (NullPointerException ignored) {} 


public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle 
RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederatelnternalError 


try 


getInteractionListener(interactionClass).receivelnteraction(interactio 
nClass, theParameters, userSuppliedTag, sentOrdering, theTransport, 
theTime, receivedOrdering, messageRetractionHandle, sentRegions) ,- 
} 

catch (NullPointerException ignored) {} 


992 


DRDC Valcartier TR 2007-412 



//FederateAmbassadorNameReservation part 


private FederateAmbassadorNameReservation 
getNameReservationListener( 

String objectName) 

{ 

Object listener = nameReservationListeners- get(obj ectName); 
//Fall-through to default handler? 
if (null==listener) listener = 
nameReservationListeners-get(null); 

//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorNameReservation)listener; 


public void 

obj ectlnstanceNameReservationSucceeded( 
String obj ectName) 
throws UnknownName, 

FederateInternalError 


try 


getNameReservationListener(obj ectName) .obj ectlnstanceNameReservationSu 
cceeded(objectName); 

} 

catch (NullPointerException ignored) {} 


public void 

obj ectlnstanceNameReservationFailed( 
String obj ectName) 
throws UnknownName, 

FederateInternalError 


try 


getNameReservationListener(obj ectName) .obj ectlnstanceNameReservationFa 
iled(objectName); 

} 

catch (NullPointerException ignored) {} 


DRDC Valcartier TR 2007-412 


993 



//FederateAmbassadorObjectRegistrationAdvisory part 


private FederateAmbassadorOb]ectRegistrationAdvisory 
getRegistrationResponder( 

Obj ectClassHandle theClass) 


Object listener = registrationResponders.get(theClass),- 
//Fall-through to default handler? 

if (null==listener) listener = registrationResponders .get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 

return (FederateAmbassadorOb]ectRegistrationAdvisory)listener,- 


public void 

startRegistrationForObjectClass( 
Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 
FederatelnternalError 


try 


getRegistrationResponder (theClass) .startRegistrationForObj ectClass(the 
Class) ,- 


catch (NullPointerException ignored) {} 


public void 

stopRegistrationForObjectClass( 
Obj ectClassHandle theClass) 
throws Obj ectelassNotPublished, 
FederatelnternalError 


try 


getRegistrationResponder(theClass) .stopRegistrationForObj ectClass(theC 
lass) ,- 


catch (NullPointerException ignored) {} 


//FederateAmbassadorTime part 

private FederateAmbassadorTime 
getTimeListener () 

{ 

Object listener = timeListeners .get (null) ,- 
//Otherwise, give up 
if (null==listener) return null; 
return (FederateAmbassadorTime) listener,- 


994 


DRDC Valcartier TR 2007-412 



public void 
timeRegulationEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeRegulationWaspending 
FederateInternalError 


try 


getTimeListener().timeRegulationEnabled(time),- 

} 

catch (NullPointerException ignored) {} 


public void 

timeConstrainedEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeConstrainedWasPending, 
FederateInternalError 


try 


getTimeListener().timeConstrainedEnabled(time) 

} 

catch (NullPointerException ignored) {} 


public void 
timeAdvanceGrant( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

JoinedFederatelsNotInTimeAdvancingState 
FederateInternalError 


try 


getTimeListener () . timeAdvanceGrant (theTime) ,- 

} 

catch (NullPointerException ignored) {} 


public void 
requestRetraction( 

MessageRetractionHandle theHandle) 
throws FederateInternalError 
{ 

try 


getTimeListener().requestRetraction(theHandle) 

} 

catch (NullPointerException ignored) {} 


//end FedAmbWrapper 


DRDC Valcartier TR 2007-412 



This page intentionally left blank. 


996 


DRDC Valcartier TR 2007-412 



Annex E - The Java Chat Client 


The Java Chat Client is a graphical user-interface (GUI) application. A single 
window is used, with various context-sensitive controls. 



Figure 30. The Java Chat client in the disconnected state 
The Log in button is enabled only when the text box beside is not empty. 
The remaining controls are disabled. 



Figure 31. The Java Chat cHent in the joined state 
The text box beside the Log Out button is disabled. 

The Send button is enabled only when the text box beside is not empty. 


DRDC Valcartier TR 2007-412 


997 


































The chatRoomRegistryEntries class implements the HLA ChatRoomRegistry’s 
list attribute object datatype (an HLAvariableArrayType of 
ChatRoomRegistryEntry). 


// File : ChatRoomRegistryEntries.j ava 
package chat; 

import hla.rtil516.CouldNotDecode,- 
import ca.go.drdc_rddc.hla.rtil516.omt.*,- 
import j ava.util.Collection; 

j * * 

* A type-safe HLAvariableArrayType used by the ChatRoomRegistry 
obj ect. 

* It uses <code>ChatRoomRegistryEntry</code> elements. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdc-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.0 
*/ 

public class 
ChatRoomRegistryEntries 
extends HLAobj ectArray 

{ 

/** Octet boundary of this class. */ 

//Although not necessary, declaring this is more efficient 
public final static int 

octetBoundary = HLAinteger32BE.octetBoundary,- 
//ChatRoomRegistryEntry.octetBoundary; 

//Since ChatRoomRegistryEntry consists of 

// - an HLAunicodeString (a variable array type, of octetBoundary 4 
for the count and 2 for the HLAunicodeChar) and 
// - an HLAintegerlSBE (octetBoundary 2) 


j * * 

* Constructs an empty <code>ChatRoomRegistryEntries</code>. 
*/ 

public 

ChatRoomRegistryEntries() 

{ 

super () ,- 


998 


DRDC Valcartier TR 2007-412 



* * 


* Constructs <code>this</code> from the specified Collection. 

* An exception occurs if the Collection doesn't return a series of 
element-compatible objects . 

* @param c a Collection specifying <code>this</code>' value 
*/ 

public 

ChatRoomRegistryEntries(Collection c) 

//The only reason this isn't in AbstractList already is because of 
the constructor signature 
{ 

super(c); 


j * * 

* Constructs <code>this</code> from the specified Object (a 
single-element array). 

* @param o an element-compatible Object specifying 
<code>this</code>' first value 

*/ 

public 

ChatRoomRegistryEntries(Object o) 

{ 

super(o); 


j * * 

* Creates an <code>ChatRoomRegistryEntries</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>ChatRoomRegistryEntries</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

ChatRoomRegistryEntries(byte[] buffer) 
throws CouldNotDecode 

{ 

super(buffer); 


DRDC Valcartier TR 2007-412 


999 



* * 


* Creates an <code>ChatRoomRegistryEntries</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>ChatRoomRegistryEntries</code> 

* @param offset where in the <code>buffer</code> the 
<code>ChatRoomRegistryEntries</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

ChatRoomRegistryEntries(byte[] buffer, 

int offset) 

throws CouldNotDecode 

{ 

super (buffer, offset) ,- 


j * * 

* Creates an <code>ChatRoomRegistryEntries</code> from the 
supplied <code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>ChatRoomRegistryEntries</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

ChatRoomRegistryEntries(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

super (byteWrapper) ,- 


//HLAarraydatatype interface implementation 

j * * 

* Returns the Class of the array's elements. 

* @return the Class of the array's elements 

*/ 

public Class 
getElementClass () 

{ 

return ChatRoomRegistryEntry. class ,- 


//end ChatRoomRegistryEntries 


1000 


DRDC Valcartier TR 2007-412 



The chatRoomRegistryEntry class implements the HLA ChatRoomRegistryEntry 
fixed record datatype. 


// File: ChatRoomRegistryEntry.j ava 
package chat; 

import hla.rtil516.CouldNotDecode; 
import ca.go.drdc_rddc.hia.rtil516.omt.*; 

/* 

* A type-safe HLAfixedRecordType used by the ChatRoomRegistryEntries 
type. 

* It consists of two fields, an HLAunicodeString name and an 
HLAintegerlSBE slot. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.0 
*/ 

public class 
ChatRoomRegistryEntry 

extends HLAfixedRecordType 

{ 

//The first field's count; the HLAunicodeString elements 
(HLAunicodeChar) 

//and the HLAintegerlSBE field have an octetBoundary of 2 each 
public static final int 

octetBoundary = HLAinteger32BE.octetBoundary; 

//The fields that make up our record: 
public HLAunicodeString name; 
public HLAintegerlSBE slot; 

j * * 

* Constructs a <code>ChatRoomRegistryEntry</code> of default 
values. 

*/ 

public 

ChatRoomRegistryEntry() 
throws CouldNotDecode 

{ 

try 


initializeFields(); 

} 

catch (InstantiationException e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


DRDC Valcartier TR 2007-412 


1001 



* * 


* Creates a <code>ChatRoomRegistryEntry</code> from the specified 
field values. 

* @param aName an HLAunicodeString to copy into the 
<code>name</code> field 

* @param aSlot an HLAintegerlSBE to copy into the 
<code>slot</code> field 

* @throws CouldNotDecode if somethings goes wrong 
*/ 

public 

ChatRoomRegistryEntry(HLAunicodeString aName, 

HLAintegerlSBE aSlot) 
throws CouldNotDecode 

{ 

this(); 

name.setValue(aName.getValue()); 
slot.setValue(aSlot.getValue()); 


j * * 

* Creates a <code>ChatRoomRegistryEntry</code> from the specified 
field values. 

* @param aName a String to copy into the <code>name</code> field 

* @param aSlot an HLAintegerlSBE to copy into the 
<code>slot</code> field 

* @throws CouldNotDecode if somethings goes wrong 
*/ 

public 

ChatRoomRegistryEntry(String aName, 

HLAintegerlSBE aSlot) 
throws CouldNotDecode 

{ 

this(); 

name . setValue (aName) ; 

slot.setValue(aSlot.getValue()); 


j * * 

* Creates a <code>ChatRoomRegistryEntry</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>ChatRoomRegistryEntry</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

ChatRoomRegistryEntry(byte[] buffer) 
throws CouldNotDecode 

{ 

this(buffer, 0) ; 


1002 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>ChatRoomRegistryEntry</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>ChatRoomRegistryEntry</code> 

* @param offset where in the <code>buffer</code> the 
<code>ChatRoomRegistryEntry</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

ChatRoomRegistryEntry(byte[] buffer, 

int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


j * * 

* Creates a <code>ChatRoomRegistryEntry</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the 
<code>ChatRoomRegistryEntry</code> begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

ChatRoomRegistryEntry(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


DRDC Valcartier TR 2007-412 


1003 



* * 


* Creates a <code>ChatRoomRegistryEntry</code> from the provided 
<code>Map</code>. 

* The <code>Map</code> is specified as mapping String keys 
(representing the field names) to their values 
(<code>HLAdatatype</code> implementations). 

* The map <code>size()</code> will be unchanging, since the record 
will always have the same fields in the same order. 

* Values may not be <code>null</code> since they all must be HLA 
data types (i.e. all references will exist). 

* @param theMap the <code>Map</code> representation of the 
<code>ChatRoomRegistryEntry</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

public 

ChatRoomRegistryEntry(java.util.Map theMap) 
throws CouldNotDecode 

{ 

this ( ) ; 
try 


put All (theMap) 

} 

//Wrap all exceptions as CouldNotDecode 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


//end ChatRoomRegistryEntry 


1004 


DRDC Valcartier TR 2007-412 



The Participant class implements the HLA Participant fixed record datatype. 


// File: Participant.java 
package chat; 

import hla.rtil516.CouldNotDecode; 
import ca.go.drdc_rddc.hla.rtil516.omt.*; 

/* 

* A type-safe HLAfixedRecordType used to represent a Participant 
obj ect. 

* It consists of three fields, an HLAboolean logged_in, an 
HLAinteger32BE user_handle and an HLAintegerlSBE chat_room_slot. 

* @author {@link mailto:Daniel.Thibault@DRDC-RDDC.gc.ca Daniel U. 

Thibault} ({@link http://www.valeartier.drdo-rddc.go.ca DRDC 

Valcartier}) 

* @version 1.0 
*/ 

public class 
Participant 

extends HLAfixedRecordType 

{ 

public static final int 

octetBoundary = HLAinteger32BE.octetBoundary; //4 

//The fields that make up our record: 
public HLAboolean logged_in; 

public HLAinteger32BE user_handle; 
public HLAintegerlSBE chat_room_slot; 

j * * 

* Constructs a <code>Participant</code> of default values. 

*/ 

public 

Participant () 

throws CouldNotDecode 

{ 

try 


initializeFields(); 

} 

catch (InstantiationException e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


DRDC Valcartier TR 2007-412 


1005 



* * 


* Creates a <code>Participant</code> from the specified field 
values. 

* @param aLoggedln an HLAboolean to copy into the 
<code>1ogged_in</code> field 

* @param aUserHandle an HLAintegerlSBE to copy into the 
<code>user_handle</code> field 

* @param aChatRoomSlot an HLAintegerlSBE to copy into the 
<code>chat_room_slot</code> field 

* @throws CouldNotDecode if somethings goes wrong 
*/ 

public 

Participant(HLAboolean aLoggedln, 

HLAinteger32BE aUserhandle, 

HLAintegerlSBE aChatRoomSlot) 
throws CouldNotDecode 

{ 

this ( ) ; 

logged_in.setValue(aLoggedln.getValue()); 
user_handle.setValue(aUserhandle.getValue()); 
chat_room_slot.setValue(aChatRoomSlot.getValue()); 


j * * 

* Creates a <code>Participant</code> from the network 
representation in the provided <code>byte[]</code>. 

* @param buffer the network-provided <code>byte[]</code> 
representation of the <code>Participant</code> 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

Participant(byte[] buffer) 
throws CouldNotDecode 

{ 

this (buffer, 0) ,- 


j * * 

* Creates a <code>Participant</code> from the network 
representation in the provided <code>byte[]</code> at the indicated 
<code>offset</code>. 

* @param buffer the network-provided <code>byte[] </code> 
representation of the <code>Participant</code> 

* @param offset where in the <code>buffer</code> the 
<code>Participant</code> representation begins 

* @throws CouldNotDecode if the <code>buffer</code> could not be 
decoded 

*/ 

public 

Participant(byte[] buffer, 
int offset) 
throws CouldNotDecode 

{ 

this(new ByteWrapper(buffer, offset)); 


1006 


DRDC Valcartier TR 2007-412 



* * 


* Creates a <code>Participant</code> from the supplied 
<code>ByteWrapper</code>. 

* @param byteWrapper the <code>ByteWrapper</code> at whose current 
<code>pos()</code> the representation of the <code>Participant</code> 
begins 

* @throws CouldNotDecode if the <code>ByteWrapper</code> could not 
be decoded 

*/ 

public 

Participant(ByteWrapper byteWrapper) 
throws CouldNotDecode 

{ 

this ( ) ; 

decode(byteWrapper); 


j * * 

* Creates a <code>Participant</code> from the provided 
<code>Map</code>. 

* The <code>Map</code> is specified as mapping String keys 
(representing the field names) to their values 
(<code>HLAdatatype</code> implementations). 

* The map <code>size()</code> will be unchanging, since the record 
will always have the same fields in the same order. 

* Values may not be <code>null</code> since they all must be HLA 
data types (i.e. all references will exist). 

* @param theMap the <code>Map</code> representation of the 
<codeParticipant</code> 

* @throws CouldNotDecode if the <code>Map</code> could not be 
decoded 

*/ 

public 

Participant(java.util.Map theMap) 
throws CouldNotDecode 

{ 

this ( ) ; 
try 


putAll (theMap) 

} 

//Wrap all exceptions as CouldNotDecode 
catch (Exception e) 

{ 

CouldNotDecode end = new CouldNotDecode(e.getMessage()); 
throw (CouldNotDecode)end.initCause(e); 


//end Participant 


DRDC Valcartier TR 2007-412 


1007 



The Mychat class implements the Java HLA Chat Client. This is a large class in 
part because it contains a multitude of inner classes. It was mostly developed using 
the (free) NetBeans 3 integrated development environment (IDE), which makes 
navigating the code in object view fairly easy and efficient. The comments which 
NetBeans inserts to recognise its own protected (user read-only) blocks have been 
removed in order to make the source more legible. 


// File: MyChat.java 

package chat; 

import j ava. io. File,- 
import j ava.util.HashMap,- 

//Needed to iterate through the Interaction key set: 

import j ava.util. Iterator,- 

//Event-handling thread utilities 

import j avax.swing.SwingUtilities ,- 

//HLA interfaces and normative classes 

import hla . rtil516 . * 

//The RTI implemented class 
import se . pitch. prt 11516 . RTI,- 
//Our encoder facilities 

import ca.go.drdc_rddc.hla.rtil516.omt.*,- 
//Our FedAmbWrapper 

import ca.go.drdc_rddc.hla.rtil516.FedAmb.*; 

j * * 

* A Chat client that uses the HLA IEEE 1516 RTI as its backbone. 

* Demonstrates Interactions, Objects, and Data Distribution 

* Management. 

* <p> 

* Although the ConcurrentAccess exception from 1.3 is no more, 

* IEEE 1516 will throw "RTIinternalError: Concurrent access 

* attempted to cmethod name>" if the RTIambassador is invoked 

* from the Federate service thread --but only for certain 

* services (unlike 1.3). getObjectlnstanceName and 

* getAttributeHandleValueMapFactory won't throw the exception, 

* for example. 

* <p> 

* The Chat client joins the federation right away, sets up 

* listeners and responders, and publishes and subscribes to 

* objects and interactions. 

* <p> 

* At first, it was thought to have the federate refrain from 

* subscribing until it logs on, but it became clear that, far 

* from diminishing message traffic, the added complexity of 

* managing known/unknown objects, up-to-date and out-dated 

* reflections, ownership negotiations and so on could in fact 

* increase traffic under certain conditions, and certainly made 

* the multi-threaded program hellishly difficult to design and 

* debug. 

* <p> 


1008 


DRDC Valcartier TR 2007-412 



* The federation has one unique object, named 

* "_ChatRoomRegistry", of the ChatRoomRegistry class. This 

* object has one attribute, "list", which is an HLAvariableArray 

* of ChatRoomRegistryEntry objects, themselves of type 

* HLAfixedRecord. These have two fields, "name" 

* (HLAunicodeString) and "slot" (HLAintegerlSBE). The 

* ChatRoomRegistry's purpose is to assign a unique slot to each 

* ChatRoom object (see below) when it is created. The list keeps 

* track of all extant ChatRooms, and can be used by a ChatRoom 

* creator to ensure the uniqueness of the slot. 

* <p> 

* In circumstances where certain operations are preferred to be 

* performed by only one federate at a time, the ChatRoomRegistry 

* could be used as a "baton", ownership being passed between 

* federates as a token of their right in performing the 

* operation in question. This was not used here. 

* <p> 

* The ChatRoom objects are created and deleted as needed by the 

* federates. They have two attributes, "slot" (HLAintegerlSBE) 

* and "name" (HLAunicodeString). There are three special 

* ChatRooms: 

* <ul > 

* <li>The "nowhere" ChatRoom is never instantiated and has 

* reserved slot 0. No federate ever subscribes to this region. 

* It is used (through AssociateRegionForUpdates) to temporarily 

* withdraw a Participant object from visibility and thus force 

* advisories to trigger. Participants are constantly associated 

* with the nowhere region. When a Participant switches 

* ChatRooms, it is first unassociated from its current ChatRoom 

* then re-associated with the new one. In between, it remains 

* associated with the nowhere region just to prevent it from 

* reverting to the default region. Note that I'd rather have 

* used slot -l, but dimensions are specified as running from 0 

* upward, and I did not want to use normalization... 

* </li> 

* <li>The "_waiting_room" is slot 1 and is never deleted. This 

* is where Participants are parked whilst logged out. All 

* federates constantly subscribe to the "_waiting_room". 

* </li> 

* <li>The "_<General>" ChatRoom, finally, has slot 2. It is the 

* ChatRoom every Participant initially logs into. 

* </li> 

* </ul> 

* <p> 

* When a Participant switches ChatRooms or logs out, if the 

* current list of other Participants in the ChatRoom (filtered 

* using the slot) is empty, then the ChatRoom must be deleted. 

* We could delay the inevitable by transferring ownership to 

* some other Participant who happens to be elsewhere,- 

* nevertheless, since there'll eventually be a time when there 

* is only one Participant logged into the federation, we might 

* as well delete ChatRooms at that time. This means that the 

* <General> ChatRoom may be deleted and recreated repeatedly 

* (imagine the lone Participant keeps switching ChatRooms). For 

* this reason, we do *not* use the HLA name reservation service 

* with ChatRooms (except for the "_waiting_room", which is a 

* fixture); we'll rely on the ChatRoomRegistry for this. 

* <p> 


DRDC Valcartier TR 2007-412 


1009 



so a user 


* User-created ChatRooms have names prefixed with "c", 

* could create another "<General>" ("c<General>"). 

* <p> 

* Participant objects, finally, have three attributes: 

* "logged_in" (HLAboolean), "user_handle" (HLAinteger32BE) and 

* 11 chat_room_slot 11 (HLAintegerlSBE). Logged_in is redundant, 

* since a user is logged-in if his Participant token is in a 

* chat_room_slot other than 0 or 1 (a federate may own several 

* Participant objects, but only one of them can be elsewhere 

* than slots 0 or 1). We use the name reservation service to 

* ensure the uniqueness of user names. The user_handles are 

* associated with a dimension for DDM purposes, allowing private 

* messages between users. 

* <p> 

* When a user requests to log in as a certain name, we attempt 

* reservation. If it succeeds, the name is new and the 

* correspondingly-named Participant object is created. If it 

* fails, the Participant object is either already in use (in 

* which case the log-in fails) or is pre-extant but unused (in 

* which case we need only acquire it to complete the log-in). 

* The Participant objects cannot be deleted once created --the 

* name reservation mechanism entails that deletion is 

* irrevocable. 

* Therefore, ownership of logged-out Participant objects is 

* transferred between federates as needed. 

* A federate that shuts down must divest any Participants it 

* owns (which will perforce all be in the ' l _waiting_room' 1 ) . The 

* last federate to leave the federation deletes everything. 

* <p> 

* DDM is used in two ways. The basic way uses the ChatRoomSlots 

* dimension, and tracks which Participants are in the same 

* ChatRoom as each federate. Normal messaging is within the 

* ChatRoom only. The other way is using the UserHandle 

* dimension, and allows private messaging between two users. 

* Because the interface only shows those Participants in the 

* same ChatRoom, private messaging is thus a sub-case, but in 

* theory you could send private messages to anyone else in the 

* federation. 

* <p> 

* A federate is in one of three states: logged out, logged in or 

* logging in (a transitional state). This is represented by the 

* booleans _me_logged_in and _me_logging_in (F, F = logged out; 

* T, F = logged in,- F, T = logging in,- T, T = not possible) . 

* <p> 

* @author Daniel U. Thibault <Daniel.Thibault@DRDC-RDDC.GC.Ca> 
*/ 


1010 


DRDC Valcartier TR 2007-412 



public class 
MyChat 

extends j avax.swing.JFrame 

implements j ava.awt.event.ActionListener, 

j avax.swing.event.DocumentListener 
j ava.awt.event.WindowListener, 
j ava.awt.event.ItemListener 


private 

static 

final 

int 

CRC_PORT 


= 8989; 

private 

static 

final 

String 

name ChatRoomRegistry 

= 

" ChatRoomRegistry' 1 ; 





private 

static 

final 

String 

name nowhere 

ChatRoom 

= 

11 nowhere' 1 . 







private 

static 

final 

String 

name waiting 

room ChatRoom = 

" waiting room' 1 ; 






private 

static 

final 

String 

name general 

ChatRoom 

= 

" <General: 

>" ; 






private 

static 

final 

short 

slot nowhere 

ChatRoom 

= 0; 

private 

static 

final 

short 

slot waiting 

room ChatRoom 

= 1; 

private 

static 

final 

short 

slot general 

ChatRoom 

= 2 ; 

private 

static 

final 

short 

slot FirstFreeChatRoomSlot 

= 3 ; 

private 

String 



args [ ] ; 



private 

String 



rtiHost = 

"localhost"; 

//args[0 

private 

String 



fdd 

"D:\\Documents and 

Settings\\dthibault\\Me; 

s DocumentsWJava Proj ects\\MyChat. 

xml" ; 

//args [1] 







private 

String 



fedex 

"MyChatRoom"; 

//args[ 

private 

String 



fedname = 

"MyChatter"; 

//args[3 


private FederateHandle 
private RTIambassador 
private FedAmbWrapper 

private InteractionClassHandle 
private ParameterHandle 
private ParameterHandle 


_federateHandle; 

_rt iAmbassador ; 

_fedAmbassador ; 

_ich_Communication; 
_iph_Communication_message; 
_iph_Communication_sender; 


och_ChatRoomRegistry; 
oahs_ChatRoomRegistry; 
oahs_ChatRoomRegistry_forUpdate. 


private Obj ectClassHandle 
private AttributeHandleSet 
private AttributeHandleSet 
private AttributeHandle 
_oah_ChatRoomRegistry_DeletePrivilege; 

private AttributeHandle _oah_ChatRoomRegistry_list; 

private AttributeHandleValueMap _oahvm_ChatRoomRegistry; 


private 

private 

private 

private 

private 

private 


Obj ectClassHandle 

AttributeHandleSet 

AttributeHandleSet 

AttributeHandle 

AttributeHandle 

AttributeHandle 


och_ChatRoom; 
oahs_ChatRoom; 
oahs_ChatRoom_forUpdate; 
oah_ChatRoom_DeletePrivilege; 
oah_ChatRoom_slot; 
oah_ChatRoom_name; 


DRDC Valcartier TR 2007-412 


1011 



private ObjectClassHandle 
private AttributeHandleSet 
private AttributeHandleSet 
private AttributeHandle 
private AttributeHandle 
private AttributeHandle 
private AttributeHandle 


och_Participant,- 
oahs_Participant,- 
oahs_Part icipant_f orUpdate,- 
oah_Participant_DeletePrivilege,- 
oah_Participant_logged_in; 
oah_Participant_user_handle,- 
oah_Participant_chat_room_slot,- 


private 

private 

private 

private 


DimensionHandle 

DimensionHandleSet 

DimensionHandle 

DimensionHandleSet 


dh_UserHandleSlots,- 
dhs_UserHandleSlotsSet,- 
dh_ChatRoomSlots,- 
dhs_ChatRoomSlotsSet,- 


//The handle of the Region matched to "_nowhere" (slot 0) 
private RegionHandle _rh_nowhere_ChatRoom,- 

private RegionHandleSet _rhs_nowhere_ChatRoom,- 

//The handle of the Region matched to the "_waiting_room" ChatRoom 
(slot 1) 

private RegionHandle _rh_waiting_room_ChatRoom; 

private RegionHandleSet _rhs_waiting_room_ChatRoom; 

//The handle of the Region matched to the 11 <General>" ChatRoom 
(slot 2) 

private RegionHandle _rh_general_ChatRoom,- 

private RegionHandleSet _rhs_general_ChatRoom,- 

//The handle of the Region matched to our current ChatRoom, if any 
(null otherwise) 

private RegionHandle _rh_current_ChatRoom; 

private RegionHandleSet _rhs_current_ChatRoom; 

//The handle of the Region matched to our current UserHandle, if 
any (null otherwise) 

private RegionHandle _rh_myParticipantRegion,- 

private RegionHandleSet _rhs_myParticipantRegion; 

//The list (size 2) of AttributeSet-RegionSet pairs used for 
Participant publish/subscribe 

//The AttributeSet will always be _oahs_Participant_forUpdate,- 
//the RegionSet will always be one of _rh_nowhere_ChatRoom, 
_rh_waiting_room_ChatRoom or _rh_current_ChatRoom 

private AttributeSetRegionSetPairList _asrspl_Participant_nowhere,- 
private AttributeSetRegionSetPairList 
_asrspl_Participant_waiting_room; 

private AttributeSetRegionSetPairList _asrspl_Participant_current,- 


private 

Semaphore 

sem reservation = 

new Semaphore 

private 

Semaphore 

sem discovery 

new Semaphore 

private 

Semaphore 

sem acquisition = 

new Semaphore 

private 

Semaphore 

sem divestiture = 

new Semaphore 

private 

boolean 

me logged in 

= false,- 

private 

boolean 

me logging in 

= false,- 

private 

boolean 

alone 

= true,- 

private 

boolean 

me shutting down 

= false,- 


//To allow user names and chat room names to be anything, the 
latter will be prefixed 

//by "p" and "o' 1 , respectively, whilst our reserved names will be 
prefixed by 


1012 


DRDC Valcartier TR 2007-412 



//The unique ChatRoomRegistry object 
private class 
aChatRoomRegistry 
{ 

//Whether we own the object or not 
public boolean 
owned = false; 

//Whether we subscribe to the object class or not 
//(and therefore whether the value is up to date or not) 
public boolean 
subscribed = false; 

//Whether we are divesting the object or not (makes sense only 
if owned) 

public boolean 
divesting = false; 

//The ChatRoomRegistry object's name 

final public String 

name = _name_ChatRoomRegistry; 

//The ChatRoomRegistry object's handle 
public ObjectInstanceHandle 
handle = null; 

//The ChatRoomRegistry object's list field 

public ChatRoomRegistryEntries 

list; 

j * * 

* Default constructor; the name is unique and the list pre- 
loaded with the "waiting_room" and <General>" ChatRooms. 

*/ 

public 

aChatRoomRegistry() 

throws CouldNotDecode 

{ 

list = new ChatRoomRegistryEntries(); 
list.add(list.size () , new ChatRoomRegistryEntry(new 
HLAunicodestring(_name_waiting_room_ChatRoom), new 
HLAintegerlSBE(_slot_waiting_room_ChatRoom))); 

list.add(list.size(), new ChatRoomRegistryEntry(new 
HLAunicodeString(_name_general_ChatRoom), new 
HLAintegerlSBE(_slot_general_ChatRoom))); 


private aChatRoomRegistry _ChatRoomRegistry = null; 


DRDC Valcartier TR 2007-412 


1013 



private class 
aChatRoom 
{ 

//Whether we own the object or not 
public boolean 
owned = false,- 

//Whether we subscribe to the object class or not 
//(and therefore whether the value is up to date or not) 
public boolean 
subscribed = false,- 

//Whether we are divesting the object or not (makes sense only 
if owned) 

public boolean 
divesting = false,- 
//The object's handle 
public Obj ectlnstanceHandle 
handle = null; 

//The ChatRoom object's name field 
public HLAunicodestring 
name ,- 

//The ChatRoom object's slot field 
public HLAintegerlSBE 
slot; 

j * * 

* Constructs a chat room of the specified name and slot. 

* @param aName a String specifying the ChatRoom's name field 

value 

* @param aSlot a Short specifying the ChatRoom's slot field 

value 

*/ 

public 

aChatRoom(String aName, short aSlot) 

{ 

slot = new HLAintegerlSBE (aSlot) ; 
name = new HLAunicodeString (aName) ,- 


//The nowhere_ChatRoom is never instantiated 
//The waiting_room ChatRoom 

final private aChatRoom _waiting_room_ChatRoom = new 
aChatRoom(_name_waiting_room_ChatRoom, _slot_waiting_room_ChatRoom),- 
//The general ChatRoom 

private aChatRoom _general_ChatRoom; // = new 
aChatRoom(_name_general_ChatRoom, _slot_general_ChatRoom),- 
//The ChatRoom we're in 
private aChatRoom _myChatRoom,- 

//The set of ChatRooms (keys are ObjectlnstanceHandle, values are 
aChatRoom) 

private HashMap _theChatRooms = new HashMapO; 


1014 


DRDC Valcartier TR 2007-412 



//Our Participant object 
private class 
aParticipant 
{ 

//Whether we own the object or not 
public boolean 
owned = false; 

//Whether we subscribe to the object class or not 
//(and therefore whether the value is up to date or not) 
public boolean 
subscribed = false; 

//Whether we are divesting the object or not (makes sense only 
if owned) 

public boolean 
divesting = false; 

//Whether the object is in scope or not (relevant only if owne 
is false) 

//(we're forced to do this instead of localDelete) 
public boolean 
inscope = false; 

//The object's handle 
public ObjectInstanceHandle 
handle = null; 

//The object's name 

public HLAunicodestring 

name = new HLAunicodeString(); 

//The logged-in field 
private HLAboolean 
logged_in; 

//The user handle field 
private HLAinteger32BE 
user_handle; 

//The current chat room slot field 
private HLAintegerlSBE 
chat_room_slot; 

j * * 

* Default constructor; the name is empty, logged_in is 
HLAfalse, 

* user_handle is 0 and chat_room_slot is 0 (nowhere). 

*/ 

public 

aParticipant () 

{ 

logged_in = new HLAboolean (false) ; 
user_handle = new HLAinteger32BE(0); 

chat_room_slot = new HLAintegerlSBE(_slot_nowhere_ChatRoom) 


private aParticipant _me = new aParticipant(); 

//List of known Participants (including ourselves); keys are 
ObjectlnstanceHandles, values are aParticipant objects 
private HashMap _theParticipants = new HashMapO; 


DRDC Valcartier TR 2007-412 



/** Creates new form MyChat */ 
public MyChat(String args[]) 

{ 

//This runs in the main thread ("main' 1 ) 

_args = args; 
initComponents(); 

txtUsername.getDocument().addDocumentListener(this); 
txtMessage.getDocument().addDocumentListener(this); 


j * * 

* This method is called from within the constructor to 

* initialize the form. 

* WARNING: Do NOT modify this code. The content of this method is 

* always regenerated by the Form Editor. 

*/ 

private void initComponents() 

{ 

jPanell = new javax.swing.JPanel() ; 
jPanel3 = new javax.swing.JPanel() ; 
btnLogon = new javax.swing.JButton(); 
txtUsername = new javax.swing.JTextField() ; 
jPanel4 = new javax.swing.JPanel(); 
btnSendMessage = new javax.swing.JButton(); 
txtMessage = new javax.swing.JTextField () ; 
jPanelS = new javax.swing.JPanel() ; 
jPanelS = new javax.swing.JPanel() ; 
lblChatRoom = new javax.swing.JLabel() ; 

IstChatRooms = new javax.swing.JComboBox(); 
btnNewChatRoom = new javax.swing.JButton () ; 
jPanel7 = new javax.swing.JPanel() ; 
lblSendTo = new javax.swing.JLabel() ; 

IstSendTo = new javax.swing.JComboBox(); 
txtArea = new javax.swing.JTextArea(); 
jPanel2 = new javax.swing.JPanel() ; 
lblStatus = new javax.swing.JLabel(); 


setDefaultCloseOperation(j avax.swing.WindowConstants.EXIT_ON_CLOSE) ; 
setFont(new java.awt.Font("Arial", 0, 12)); 
setName("frmMyChat"); 
addWindowListener(this) ; 

j Panel1.setLayout(new j ava.awt.BorderLayout()) ; 

j Panel3.setLayout(new j ava.awt.BorderLayout()) ; 

btnLogon.setText("Log In"); 
btnLogon.setEnabled(false) ; 
btnLogon.addActionListener(this) ; 

j Panel3.add(btnLogon, j ava.awt.BorderLayout.WEST) ; 
txtUsername.setEnabled(false) ; 

j Panel3.add(txtUsername, j ava.awt.BorderLayout.CENTER) ; 
jPanell.add(jPanel3, java.awt.BorderLayout.NORTH); 


1016 


DRDC Valcartier TR 2007-412 



j Panel4.setLayout(new j ava.awt.BorderLayout()); 


btnSendMessage.setText("Send") ; 
btnSendMessage.setEnabled(false); 
btnSendMessage.addActionListener(this); 

j Panel4.add(btnSendMessage, j ava.awt.BorderLayout.WEST) ; 
txtMessage.setEnabled(false); 

j Panel4.add(txtMessage, j ava.awt.BorderLayout.CENTER) ; 
jPanell.add(jPanel4, java.awt.BorderLayout.CENTER); 
j Panels.setLayout(new 

j ava.awt.FlowLayout(j ava.awt.FlowLayout.LEFT)); 
j Panels.setLayout(new 

j ava.awt.FlowLayout(j ava.awt.FlowLayout.LEFT)); 

lblChatRoom.setText("Chat Room:"); 
lblChatRoom.setEnabled(false) ; 
jPanels.add(lblChatRoom); 

IstChatRooms.setModel(new j avax.swing.DefaultComboBoxModel(new 
String[] { "<General>" })); 

IstChatRooms.setEnabled(false) ; 

IstChatRooms.addltemListener(this) ; 

jPanels.add(IstChatRooms); 

btnNewChatRoom. setText ("New") 

btnNewChatRoom.setActionCommand("NewChatRoom"); 
btnNewChatRoom.setEnabled(false) ; 
btnNewChatRoom.addActionListener(this); 

jPanels.add(btnNewChatRoom); 

jPanels.add(jPanels) ; 

j Panel7.setLayout(new 

j ava.awt.FlowLayout(j ava.awt.FlowLayout.LEFT)); 

lblSendTo.setText("Send To:") ; 
lblSendTo.setEnabled(false) ; 
j Panel7.add(lblSendTo) ; 

IstSendTo.setModel(new j avax.swing.DefaultComboBoxModel(new 
String[] { "<All>" })); 

IstSendTo.setEnabled(false) ; 
j Panel7.add(IstSendTo) ; 

j Panels . add (j Panel7) 

jPanell.add(jPanels, java.awt.BorderLayout.SOUTH); 

getContentPane() .add (j Panell, j ava.awt.BorderLayout.NORTH); 


DRDC Valcartier TR 2007-412 


1017 



txtArea.setBackground(new j ava.awt.Color(255, 255, 255)); 
txtArea.setEditable(false) ,- 
txtArea . setName (" txtArea' 1 ) ,- 

getContentPane().add(txtArea, java.awt.BorderLayout.CENTER),- 

j Panel2.setLayout(new j ava.awt.BorderLayout()),- 

lblStatus.setText("MyChat is initialising - Please wait...' 1 ); 
lblStatus.setName("lblStatus"),- 

j Panel2.add(lblStatus, j ava.awt.BorderLayout.SOUTH) ,- 
getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH),- 
pack () 

} 

// Code for dispatching events from components to event handlers. 

public void actionPerformed(java.awt.event.ActionEvent evt) 

{ 

if (evt.getSource() == btnLogon) 

{ 

MyChat.this.btnLogonActionPerformed(evt),- 

} 

else if (evt.getSource() == btnSendMessage) 

{ 

MyChat.this.btnSendMessageActionPerformed(evt),- 

} 

else if (evt.getSource() == btnNewChatRoom) 

{ 

MyChat.this.btnNewChatRoomActionPerformed(evt),- 

} 

} 

public void itemStateChanged(j ava.awt.event.ItemEvent evt) 

{ 

if (evt.getSource() == IstChatRooms) 

{ 

MyChat.this.IstChatRoomsItemStateChanged(evt),- 

} 

} 

public void windowActivated(java.awt.event.WindowEvent evt) 

{ 

} 

public void windowClosed(java.awt.event.WindowEvent evt) 

{ 

} 

public void windowclosing(java.awt.event.WindowEvent evt) 

{ 

if (evt.getSource() == MyChat.this) 

{ 

MyChat.this.exitForm(evt),- 


1018 


DRDC Valcartier TR 2007-412 



public void windowDeactivated(java.awt.event.WindowEvent evt) 


public void windowDeiconifled(java.awt.event.WindowEvent evt) 


public void windowlconifled(j ava.awt.event.WindowEvent evt) 


public void windowOpened(j ava.awt.event.WindowEvent evt) 

{ 

if (evt.getSource() == MyChat.this) 

{ 

MyChat.this.openForm(evt),- 


private void 

btnNewChatRoomActionPerformed(j ava.awt.event.ActionEvent evt) 

{ 

//To allow user names and chat room names to be anything, the 
latter will be prefixed 

//by "p" and "c", respectively, whilst our reserved names will 
be prefixed by 

String newChatRoomName = 

j avax.swing.JOptionPane.showlnputDialog( 11 Enter the new chat room's 
name:") ; 

if (newChatRoomName.equals("") ) return; 
synchronized(AcquireChatRoomRegistry()) 

{ 

aChatRoom _ChatRoom = 

AddChatRoomAndUpdateRegistry (newChatRoomName) ,- 
IstChatRooms .addltem (newChatRoomName) ,- 
//addl tem (_ChatRoom. name . toString () . substring (1) ) ,- 
} //synchronized(AcquireChatRoomRegistry()) 

IstChatRooms . setSelectedltem (newChatRoomName) ,- 


DRDC Valcartier TR 2007-412 


1019 



private void IstChatRoomsItemStateChanged(j ava.awt.event.ItemEvent 
evt) 


//getltemSelectable //the originator of the event, a 
j avax.swing.JComboBox 

//getltem //the item affected by the event, a java.lang.String 
(or whatever was added to the list) 

if ((l_me_logged_in) || (evt.getStateChange() l= evt.SELECTED)) 
return; 

//Moving to the evt.getltem().toString() ChatRoom 
try { 

String _newChatRoomName,- 
if 

(((j avax.swing.JComboBox)evt.getltemSelectable()) .getSelectedlndex() 


_newChatRoomName = _name_general_ChatRoom,- //"_" + 
evt.getItem().toStringO; //General ChatRoom 
} else { 

_newChatRoomName = "o' 1 + evt.getltem().toString(); 

} //if 

//The change of ChatRooms cannot be from nowhere or 
waiting_room,- it has 

//to be from an active ChatRoom, including the <General> 

ChatRoom. 

_rtiAmbassador.unassociateRegionsForUpdates(_me.handle, 
_asrspl_Participant_current) ,- 

//At this point, _me.handle is only associated with 
_asrspl_Participant_nowhere 

//Unsubscribe from the current ChatRoom 

_rtiAmbassador.unsubscribelnteractionClassWithRegions(_ich_Communicati 
on, _rhs_current_ChatRoom) ,- 

//Look at the ChatRoom we're leaving to decide whether to 
delete it or not 

int count = 0; 

synchronized(_theParticipants) 

{ 

aParticipant _iParticipant,- 

for (Iterator i = _theParticipants .values (). iterator () ,- 
i .hasNext () ,-) 


_i Part icipant = (aPart icipant) i . next () ,- 

//Out of scope Participants have unreliable attributes; 
they cannot be in our ChatRoom in any case 

//The only exceptions are owned Participants: any owned 
orphans can only be in the waiting_room 
//_me isn't counted 

if ((!_me.handle.equals(_iParticipant.handle)) && 
(_iParticipant.inscope) && 


(_me . chat_room_slot. equals (_i Part icipant. chat_room_slot) ) ) count+ + ,- 

} //for 

} //synchronized(_theParticipants) 


1020 


DRDC Valcartier TR 2007-412 



//This'll cause the Participants in our ChatRoom to go out of 

scope 

_rtiAmbassador.unsubscribeObj ectClassAttributesWithRegions(_och_Partic 
ipant, _asrspl_Participant_current); 

//What if someone logs into the ChatRoom after we've counted 
its Participants but before we actually delete it? 

aChatRoom _previousChatRoom = _myChatRoom; 
if (_newChatRoomName.equals(_name_general_ChatRoom)) 

{ 

//Does the General ChatRoom exist? 

_general_ChatRoom = 

SeekChatRoomBySlot(_slot_general_ChatRoom); 

//General ChatRoom may not be in _theChatRooms, since it 
is never explicitly recreated 

if (null == _general_ChatRoom) 

{ 

synchronized(AcquireChatRoomRegistry()) 

{ 

_general_ChatRoom = new 

aChatRoom(_name_general_ChatRoom, _slot_general_ChatRoom); 

_general_ChatRoom.owned = 

_general_ChatRoom.subscribed = true; 

// _general_ChatRoom.divesting = false; 

synchronized(_theChatRooms) 

{ 

_theChatRooms.put(_general_ChatRoom.handle = 
_rtiAmbassador.registerObj ectlnstance(_och_ChatRoom), 
_general_ChatRoom); 

//No need to add the General ChatRoom to the 
_ChatRoomRegistry, as it is already listed 

} //synchronized(_theChatRooms) 

} //synchronized(AcquireChatRoomRegistry()) 

} //if 

_myChatRoom = _general_ChatRoom; 

} else { 

_myChatRoom = SeekChatRoomByName(_newChatRoomName); 
//Cannot fail 

} //if 


DRDC Valcartier TR 2007-412 


1021 



//Modify asrspl and delete old region, unless it was the 
General ChatRoom 

RegionHandle _rh_previous_ChatRoom = _rh_current_ChatRoom; 

//= (RegionHandle)_rhs_current_ChatRoom.toArray() [0] ,- 
_asrspl_Participant_current.remove(0); 

_rhs_current_ChatRoom.remove(_rh_previous_ChatRoom),- 
if (!_rh_previous_ChatRoom.equals(_rh_general_ChatRoom)) 

{ 

_rtiAmbassador.deleteRegion(_rh_previous_ChatRoom),- 

} //if 

//New region 

if (_newChatRoomName.equals(_name_general_ChatRoom)) 

{ 

_rh_current_ChatRoom = _rh_general_ChatRoom,- 
} else { 

_rh_current_ChatRoom = 

_rtiAmbassador.createRegion(_dhs_ChatRoomSlotsSet),- 

_rtiAmbassador.setRangeBounds(_rh_current_ChatRoom, 
_dh_ChatRoomSlots, new RangeBounds(_myChatRoom.slot.getValue() , 1 + 
_myChatRoom.slot.getValue())),- 

} //if 

_rhs_current_ChatRoom.add(_rh_current_ChatRoom),- 

_rtiAmbassador.commitRegionModifications(_rhs_current_ChatRoom),- 
//Won't complain if there are no mods to commit 
//Regenerate asrspl 

_asrspl_Participant_current.add(new 
AttributeRegionAssociation(_oahs_Participant_forUpdate, 
_rhs_current_ChatRoom)),- 

_me.chat_room_slot.setValue(_myChatRoom.slot.getValue()); 

//Go back in 

//This'll reveal the participants in the new ChatRoom 

_rtiAmbassador.subscribeObj ectClassAttributesWithRegions(_och_Particip 
ant, _asrspl_Participant_current) ,- 

//Re-open the communication channel for the new ChatRoom 

_rtiAmbassador.subscribelnteractionClassWithRegions(_ich_Communication 
, _rhs_current_ChatRoom) ,- 

//Reveal ourselves to the new ChatRoom 
_rtiAmbassador.associateRegionsForUpdates(_me.handle, 
_asrspl_Participant_current) ,- 


1022 


DRDC Valcartier TR 2007-412 



//Delete old ChatRoom? 

if (count <= 0) //Should be just ==0 but you never know 
(because of inscope, _me isn't counted) 

{ 

//We were the only Participant left in the old ChatRoom,- 
delete it as we leave (we must be the owner, obviously) 
synchronized(AcquireChatRoomRegistry()) 

{ 

//Because we're the owner, we won't get a 
RemoveObj ectInstance notification 

//The remove returns the removed value, which is 
_previousChatRoom 

synchronized(_theChatRooms) 


_rtiAmbassador.deleteObj ectlnstance(((aChatRoom)_theChatRooms.remove( 
previousChatRoom.handle) ) .handle, null) ,- 

} //synchronized(_theChatRooms) 

RemoveChatRoomAndUpdateRegistry(_previousChatRoom.slot.getValue()); 
if 

(!_previousChatRoom.name.toString().equals(_name_general_ChatRoom)) 


IstChatRooms.removeItern(_previousChatRoom.name.toString().substring(1) 

) ; 

} //if 

} //synchronized(AcquireChatRoomRegistry()) 

} else if (_previousChatRoom.owned) 

{ 

//There are other Participants but we were the owner: 
transfer ownership 

_previousChatRoom.divesting = true; 

_rtiAmbassador.negotiatedAttributeOwnershipDivestiture(_previousChatRo 
om.handle, _oahs_ChatRoom, null) ,- 

} //if 

} catch (Exception e) { 
e. printStackTrace () ,- 
} finally { 


//Start of DocumentListener implementation and dispatching code 

j * * 

* The NetBeans IDE unfortunately does not expose/integrate this 
critical bit, 

* so we have to hook it up manually. 

*/ 

public void changedUpdate(j avax.swing.event.DocumentEvent evt) 


DRDC Valcartier TR 2007-412 


1023 



public void insertUpdate(javax.swing.event.DocumentEvent evt) 

{ 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
if (evt.getDocument().equals(txtUsername.getDocument())) 

{ 

MyChat.this.txtUsernameDocumentChanged(evt); 

} else if (evt.getDocument().equals(txtMessage.getDocument())) 

{ 

MyChat.this.txtMessageDocumentChanged(evt); 

} //if 


public void removeUpdate(j avax.swing.event.DocumentEvent evt) 

{ 

if (evt.getDocument().equals(txtUsername.getDocument())) 

{ 

MyChat.this.txtUsernameDocumentChanged(evt); 

} else if (evt.getDocument().equals(txtMessage.getDocument())) 
{ 

MyChat.this.txtMessageDocumentChanged(evt); 

} //if 


//User-specified handlers 

j * * 

* This handler watches the txtUsername's text; the btnLogon is 
enabled 

* only when that text is other than the empty string. 

*/ 

public void 

txtUsernameDocumentChanged(j avax.swing.event.DocumentEvent evt) 

{ 

//This runs in the event-handling thread ("AWT-EventQueue-0") 

// A user name must be specified before btnLogon may be clicked 
if (txtUsername.getText().length() > 0) 

{ 

btnLogon.setEnabled(true) ; 

btnLogon.getRootPane().setDefaultButton(btnLogon); 

} else { 

btnLogon.setEnabled(false); 

} //if 


1024 


DRDC Valcartier TR 2007-412 



* * 


* This handler watches the txtMessage's text; the btnSendMessage 

* is enabled only when that text is other than the empty string. 
*/ 

public void 

txtMessageDocumentChanged(j avax.swing.event.DocumentEvent evt) 

{ 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
// A message must be specified before btnSendMessage may be 
clicked 

if (txtMessage.getText().length() > 0) 

{ 

btnSendMessage.setEnabled(true); 

btnSendMessage.getRootPane().setDefaultButton(btnSendMessage); 

} else { 

btnSendMessage.setEnabled(false) ; 

} //if 


//End of DocumentListener implementation and dispatching code 


DRDC Valcartier TR 2007-412 


1025 



j k k 

* Occurs when the window is first opened. 

*/ 

private void openForm(java.awt.event.WindowEvent evt) 

{ 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
lblStatus.setText("MyChat initialising - RTIambassador 
obtained' 1 ) ; 

new Thread() { public void run () { 

//Join federation 

if (ljoinFederation()) return; 

try { 

_ChatRoomRegistry = new aChatRoomRegistry(); //We couldn't 
do this in the field declarations because of the escaping Exception 
} catch (CouldNotDecode ignored) { 

} //try 

//The ChatRoomRegistry is created with the ,l waiting_room' 1 and 
"<General>" slots already filled in 
if (JgetHandles()) return; 
if (lsetupChatRoomRegistry()) return; 
if (lsetupChatRooms()) return; 
if (lsetupParticipants ()) return; 

SwingUtilities.invokeLater(new Runnable() { public void run() 

{ 

//Remaining initialisation 
try { 

txtUsername.setEnabled(true); //This'll allow btnLogon 
to become enabled 

txtUsername.requestFocus() ; 

lblStatus.setText("Welcome to MyChat - Please log in"); 
} catch (Exception e) { 
e.printStackTrace(); 

} //try 

} } ); //Runnable 
} }. start(); //Thread 


1026 


DRDC Valcartier TR 2007-412 



private boolean 
j oinFederation() 


//Runs on a separate thread --not the event dispatch thread 
//Remaining initialisation 
try { 

//Process the command-line arguments 
if (_args.length > 0) rtiHost = _args[0]; 

//NetBeans runs this in its root directory, e.g. "C:\Program 
Files/j2 sdk_nb\netbeans3.6\" 

if (_args.length > 1) fdd = _args[l]; 

if (_args.length > 2) fedex = _args[2]; 

if (_args.length > 3) fedname = _args[3]; 

//Get the RTIambassador 
try { 

_rtiAmbassador = RTI.getRTIambassador(rtiHost, CRC_PORT); 

} catch (Exception e) { 

SwingUtilities.invokeLater(new Runnable() { public void 

lblStatus.setText("Unable to connect to CRC on " + 

+ " : " + CRC_PORT); 

} } ); //Runnable 
return false; 

} //try 

SwingUtilities.invokeLater(new Runnable() { public void run () 

lblStatus.setText("MyChat initialising - RTIambassador 

obtained"); 

} } ); //Runnable 

//Get the FederateAmbassador 

//FedAmbWrapper provides a dispatching layer around the 
FederateAmbassador itself 
try { 

_fedAmbassador = new FedAmbWrapper(_rtiAmbassador); 

} catch (Exception e) { 

SwingUtilities.invokeLater(new Runnable() { public void 

run() { 

lblStatus.setText("Unable to create new 
FedAmbWrapper"); 

} } ); //Runnable 
return false; 

} //try 

SwingUtilities.invokeLater(new Runnable() { public void run () 

{ 

lblStatus.setText("MyChat initialising - FedAmbassador 

obtained"); 

} } ); //Runnable 


run() { 
rtiHost 


DRDC Valcartier TR 2007-412 


1027 



//Destroy any lingering empty federation execution 
try { 

_rtiAmbassador.destroyFederationExecution(fedex),- 
SwingUtilities.invokeLater(new Runnable() { public void 

run () { 

lblStatus.setText("MyChat initialising - Previous " + 
fedex + 11 federation destroyed' 1 ); 

} } ); //Runnable 

} catch (FederatesCurrentlyJoined ignored) { 

} catch (FederationExecutionDoesNotExist ignored) { 

} //try 

//Create the federation execution 
final File fddFile = new File(fdd); 
try { 

_rtiAmbassador.createFederationExecution(fedex, 
fddFile.toURL()); 

SwingUtilities.invokeLater(new Runnable() { public void 

run () { 

lblStatus.setText("MyChat initialising - " + fedex + " 
federation created"),- 

} } ); //Runnable 

} catch (FederationExecutionAlreadyExists ignored) { 

} catch (CouldNotOpenFDD cnof) { 

SwingUtilities.invokeLater(new Runnable() { public void 

run () { 

lblStatus.setText("Could not open FDD «" + 
fddFile .getAbsoluteFile (). toString () + "»"),- 
} } ); //Runnable 
return false,- 

} catch (ErrorReadingFDD erf) { 

SwingUtilities.invokeLater(new Runnable() { public void 

run () { 

lblStatus.setText("Corrupt FDD «" + 
fddFile .getAbsoluteFile (). toString () + "»"),- 
} } ); //Runnable 
return false,- 

} //try 

//Join the federation execution 
_federateHandle = 

_rtiAmbassador.j oinFederationExecution(fedname, fedex, _fedAmbassador, 
null) ,- 

SwingUtilities.invokeLater(new Runnable() { public void run() 

{ 

lblStatus.setText("MyChat initialising - Joined as " + 
_federateHandle) ,- 

} } ),- //Runnable 
return true; 

} catch (Exception e) { 
e . printStackTrace () ,- 
return false,- 
} //try 


1028 


DRDC Valcartier TR 2007-412 



private boolean 
getHandles () 


//Runs on a separate thread --not the event dispatch thread 
try { 

//Obtain object/interaction and parameter/attribute handles 
_ich_Communication = 

_rtiAmbassador.getInteractionClassHandle("Communication' 1 ) ; 
_iph_Communication_message = 

_rtiAmbassador.getParameterHandle(_ich_Communication, "message"); 
_iph_Communication_sender = 

_rtiAmbassador.getParameterHandle(_ich_Communication, "sender"); 
_och_ChatRoomRegistry = 

_rtiAmbassador.getObjectClassHandle("ChatRoomRegistry"); 

_oah_ChatRoomRegistry_DeletePrivilege = 

_rtiAmbassador.getAttributeHandle(_och_ChatRoomRegistry, 

RTI.PrivilegeToDeleteObj ectName) ; //"HLAprivilegeToDeleteObject") ; 
_oah_ChatRoomRegistry_list 

_rtiAmbassador.getAttributeHandle(_och_ChatRoomRegistry, "list"); 
//Build the attribute handle sets 
_oahs_ChatRoomRegistry = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

_oahs_ChatRoomRegistry.add(_oah_ChatRoomRegistry_list); 

_oahs_ChatRoomRegistry.add(_oah_ChatRoomRegistry_DeletePrivilege); 

_oahs_ChatRoomRegistry_forUpdate = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

_oahs_ChatRoomRegistry_forUpdate.add(_oah_ChatRoomRegistry_list); 

_och_ChatRoom = 

_rtiAmbassador.getObjectClassHandle("ChatRoom"); 

_oah_ChatRoom_DeletePrivilege = 

_rtiAmbassador.getAttributeHandle(_och_ChatRoom, 

RTI.PrivilegeToDeleteObj ectName) ; 

_oah_ChatRoom_name = 

_rtiAmbassador.getAttributeHandle(_och_ChatRoom, "name"); 
_oah_ChatRoom_slot = 

_rtiAmbassador.getAttributeHandle(_och_ChatRoom, "slot"); 

//Build the attribute handle sets 
_oahs_ChatRoom = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

_oahs_ChatRoom.add(_oah_ChatRoom_DeletePrivilege); 
_oahs_ChatRoom.add(_oah_ChatRoom_name); 

_oahs_ChatRoom.add(_oah_ChatRoom_slot); 

_oahs_ChatRoom_forUpdate = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

_oahs_ChatRoom_forUpdate.add(_oah_ChatRoom_name); 
_oahs_ChatRoom_forUpdate.add(_oah_ChatRoom_slot); 


DRDC Valcartier TR 2007-412 


1029 



_och_Participant = 

_rtiAmbassador.getObj ectClassHandle("Participant"),- 
_oah_Participant_DeletePrivilege = 

_rtiAmbassador.getAttributeHandle(_och_Participant, 

RTI.PrivilegeToDeleteObj ectName) ,- 

_oah_Participant_logged_in 

_rtiAmbassador.getAttributeHandle(_och_Participant, 11 logged_in") ,- 
_oah_Participant_user_handle 

_rti Ambassador .getAttributeHandle (_och_Part icipant, "user_handle") ,- 
_oah_Participant_chat_room_slot 

_rtiAmbassador.getAttributeHandle (_och_Participant, 11 chat_room_slot 11 ) ,- 
//Build the attribute handle sets 
_oahs_Participant = 

_rt iAmbassador. getAttributeHandleSetFactory () .create () ,- 

_oahs_Participant. add (_oah_Participant_DeletePrivilege) ,- 
_oahs_Participant. add (_oah_Participant_logged_in) ,- 
_oahs_Participant. add (_oah_Participant_user_handle) ,- 
_oahs_Participant. add (_oah_Participant_chat_room_slot) ,- 
_oahs_Participant_forUpdate = 

_rt iAmbassador. getAttributeHandleSetFactory () .create () ,- 

_oahs_Participant_forUpdate . add (_oah_Participant_logged_in) ,- 

_oahs_Participant_f orUpdate . add (_oah_Participant_user_handle) ,- 

_oahs_Participant_f orUpdate . add (_oah_Part icipant_chat_room_slot) ,- 

_dh_UserHandleSlots = 

_rt iAmbassador. getDimensionHandle ("UserHandleSlot s' 1 ) ,- 
_dh_ChatRoomSlots 

_rtiAmbassador.getDimensionHandle ( 11 ChatRoomSlots 11 ) ,- 
_dhs_UserHandleSlotsSet = 

_rt iAmbassador. getDimensionHandleSetFactory () .create () ,- 

_dhs_UserHandleSlotsSet. add (_dh_UserHandleSlots) ,- 
_dhs_ChatRoomSlotsSet = 

_rt iAmbassador. getDimensionHandleSetFactory () .create () ,- 
_dhs_ChatRoomSlotsSet. add (_dh_ChatRoomSlot s) ,- 

_rhs_nowhere_ChatRoom = 

_rt iAmbassador. getRegionHandleSetFactory () .create () ,- 
_rh_nowhere_ChatRoom = 

_rt iAmbassador. createRegion (_dhs_ChatRoomSlot sSet) ,- 
//_nowhere_ChatRoom is slot 0 

_rtiAmbassador.setRangeBounds(_rh_nowhere_ChatRoom, 
_dh_ChatRoomSlots, new RangeBounds(_slot_nowhere_ChatRoom, 1 + 
_slot_nowhere_ChatRoom) ) ,- 

_rhs_nowhere_ChatRoom. add (_rh_nowhere_ChatRoom) ,- 

_rt iAmbassador. commitRegionModif icat ions (_rhs_nowhere_ChatRoom) ,- 


1030 


DRDC Valcartier TR 2007-412 



_rhs_waiting_room_ChatRoom = 
rtiAmbassador.getRegionHandleSetFactory().create(); 

_rh_waiting_room_ChatRoom = 
rtiAmbassador.createRegion(_dhs_ChatRoomSlotsSet); 
//_waiting_room_ChatRoom is slot 1 

_rtiAmbassador.setRangeBounds(_rh_waiting_room_ChatRoom ; 
dh_ChatRoomSlots, new RangeBounds(_slot_waiting_room_ChatRoom ; 1 + 
slot_waiting_room_ChatRoom)); 

_rhs_waiting_room_ChatRoom.add(_rh_waiting_room_ChatRoom); 

rtiAmbassador.commitRegionModifications(_rhs_waiting_room_ChatRoom); 

//The General ChatRoom 
_rhs_general_ChatRoom = 

rtiAmbassador.getRegionHandleSetFactory().create(); 
_rh_general_ChatRoom = 

rtiAmbassador.createRegion(_dhs_ChatRoomSlotsSet); 

//General ChatRoom is slot 2 

_rtiAmbassador.setRangeBounds(_rh_general_ChatRoom, 
dh_ChatRoomSlots, new RangeBounds(_slot_general_ChatRoom, 1 + 
slot_general_ChatRoom) ) ; 

_rhs_general_ChatRoom.add(_rh_general_ChatRoom); 
rtiAmbassador.commitRegionModifications(_rhs_general_ChatRoom); 


DRDC Valcartier TR 2007-412 


1031 



// _rh_current_ChatRoom = null; 

// _rh_myParticipantRegion = null; 

//For chat_room_slot filtering, we associate all "forUpdate" 
attributes to _dh_ChatRoomSlots regions 

//We'd get InvalidRegionContext when subscribing if we 
included the DeletePrivilege 

_asrspl_Participant_nowhere 

_rtiAmbassador.getAttributeSetRegionsetPairListFactory().create(1); 

_asrspl_Participant_nowhere.add( new 

AttributeRegionAssociation(_oahs_Participant_forUpdate, 
_rhs_nowhere_ChatRoom)); 

_asrspl_Participant_waiting_room = 

_rtiAmbassador.getAttributeSetRegionsetPairListFactory() .create (1) ; 

_asrspl_Participant_waiting_room.add(new 
AttributeRegionAssociation(_oahs_Participant_forUpdate, 
_rhs_waiting_room_ChatRoom)); 

//There'll be no Communication traffic through the 
waiting_room; this is used only to find out 

//(through the Interaction Advisories) whether there are 
other federates or not. 

_fedAmbassador.setInteractionAdvisoryResponder(_ich_Communication, new 
MyCommunicationAdvisoryResponder()); 

_fedAmbassador.setlnteractionListener(_ich_Communication, new 
MyCommunicationlnteractionListener()); 

_rtiAmbassador.publishlnteractionClass(_ich_Communication); 

_rtiAmbassador.subscribelnteractionClassWithRegions(_ich_Communication 
, _rhs_waiting_room_ChatRoom); 
return true; 

} catch (Exception e) { 
e.printStackTrace() ; 
return false; 

} //try 


1032 


DRDC Valcartier TR 2007-412 



private boolean 
setupChatRoomRegistry() 

{ 

try { 

//With all objects, we cannot allow orphans (objects which 
have no instances owned by any federate) 

//because they become undiscoverable. Therefore we can expect 
ownership of the "common objects" 

//(i.e. the ChatRoomRegistry, the ChatRoom objects and, to a 
certain extent, the Participant objects) 

//to flow between the federates as they join and leave the 
federation as well as when they require 

//ownership for modification purposes. 

//Thus, for each class we must set up the following services: 
discovery, removal, attribute update (listen 

//and respond) and ownership. Whichever federate owns 
(temporarily) an object will keep an image of 

//that object, using the aChatRoomRegistry, aChatRoom and 
aParticipant objects. 

_fedAmbassador.setAttributeUpdateResponder(_och_ChatRoomRegistry, new 
MyChatRoomRegistrylnstanceAttributeResponder()); 

_rtiAmbassador.publishObj ectClassAttributes(_och_ChatRoomRegistry, 
_oahs_ChatRoomRegistry_forUpdate) ,- 

_fedAmbassador.setAttributeUpdateListener(_och_ChatRoomRegistry, new 
MyChatRoomRegistrylnstanceAttributeListener()); 

_fedAmbassador.setOwnershipListener(_och_ChatRoomRegistry, 
new MyChatRoomRegistryOwnershipListener (null) ) ,- 

//Get the ChatRoomRegistry, create it if necessary 
// Reserve name 

boolean reservation_succeeded; 
synchronized(_sem_reservation) 

{ 

_sem_reservation.value = false; 

_fedAmbassador.setNameReservationListener(_name_ChatRoomRegistry, new 
MyNameReservationListener (_sem_reservation) ) ,- 

_rtiAmbassador . reserveObj ectlnstanceName (_name_ChatRoomRegistry) ,- 
// Wait for reservation succeeded/failed 
waitFor (_sem_reservation) ,- 

_fedAmbassador.setNameReservationListener(_name_ChatRoomRegistry, 
null) ,- 

reservat ion_succeeded = _s em_r e servat ion. value ,- 
} //synchronized(_sem_reservation) 


DRDC Valcartier TR 2007-412 


1033 



if (reservation_succeeded) 

{ 

//Having reserved the name, we know we're the first 
federate to reach this point, 

//so we must create the ChatRoomRegistry. 
synchronized(_ChatRoomRegistry) 

{ 

_ChatRoomRegistry.owned = _ChatRoomRegistry.subscribed 

= true; 

// _ChatRoomRegistry.divesting = false; 

_ChatRoomRegistry.handle = 

_rtiAmbassador.registerObj ectInstance(_och_ChatRoomRegistry, 
_name_ChatRoomRegistry) ,- 

//Update responder is already in place 

_rtiAmbassador.subscribeObj ectClassAttributes(_och_ChatRoomRegistry, 
_oahs_ChatRoomRegistry_forUpdate) ,- 

//Update listener is already in place 
} //synchronized(_ChatRoomRegistry) 

} else { 

//Name reservation failed, which means there is an already 
extant instance 

synchronized(_sem_discovery) 

{ 

_sem_discovery.value = false; 

_fedAmbassador.setDiscoveryListener(_och_ChatRoomRegistry, new 
MyChatRoomRegistryDiscoveryListener (_sem_discovery) ) ,- 

//No removal responder required since the object is 

never deleted 

_ChatRoomRegistry.subscribed = true; 

_rtiAmbassador.subscribeObj ectClassAttributes(_och_ChatRoomRegistry, 
_oahs_ChatRoomRegistry_forUpdate) ,- 

//Update listener is already in place 
waitFor (_sem_discovery) ,- 

_fedAmbassador. setDiscoveryListener (_och_ChatRoomRegistry, null) ,- 
} //synchronized(_sem_discovery) 

} //if 

return true; 

} catch (Exception e) { 
e . printStackTrace () ,- 
return false; 

} finally { 

} //try 


1034 


DRDC Valcartier TR 2007-412 



private boolean 
setupChatRooms() 

{ 

try { 

_fedAmbassador.setDiscoveryListener(_och_ChatRoom, new 
MyChatRoomDiscoveryListener(null)); 

_fedAmbassador.setRemovalResponder(_och_ChatRoom, new 
MyChatRoomRemovalResponder()); 

_fedAmbassador.setOwnershipListener(_och_ChatRoom, new 
MyChatRoomOwnershipListener(null, null)); 

_fedAmbassador.setAttributeUpdateListener(_och_ChatRoom, new 
MyChatRoomlnstanceAttributeListener()); 

// Note that if we wanted an instance-specific responder, we 
could not put it in place before getting 

// _oh_myChatRoom back from registerObjectlnstance or 
getObjectInstanceHandle, so we could 

// conceivably miss a provideAttributeValueUpdate request 
issued by another federate between the 

// registration and the setting up of the responder --unless 
both statements are put in a single synchronized block. 

_fedAmbassador.setAttributeUpdateResponder(_och_ChatRoom, new 
MyChatRoomlnstanceAttributeResponder()); 

_rtiAmbassador.publishObj ectClassAttributes(_och_ChatRoom, 
_oahs_ChatRoom_forUpdate) ; 

// Reserve name 

boolean reservation_succeeded; 
synchronized(_sem_reservation) 

{ 

_sem_reservation.value = false; 

_fedAmbassador.setNameReservationListener(_name_waiting_room_ChatRoom, 
new MyNameReservationListener(_sem_reservation)); 

_rtiAmbassador.reserveObj ectlnstanceName(_name_waiting_room_ChatRoom) ; 
// Wait for reservation succeeded/failed 
waitFor(_sem_reservation); 

_fedAmbassador.setNameReservationListener(_name_waiting_room_ChatRoom, 
null) ; 

reservation_succeeded = _sem_reservation.value; 

} //synchronized(_sem_reservation) 


DRDC Valcartier TR 2007-412 


1035 



if (reservation_succeeded) 

{ 

//Having reserved the name, we know we're the first 
federate to reach this point, 

//so we must create the ChatRoom 
synchronized(AcquireChatRoomRegistry()) 

{ 

synchronized(_theChatRooms) 

{ 

_waiting_room_ChatRoom.owned = 
_waiting_room_ChatRoom.subscribed = true; 

// _waiting_room_ChatRoom.divesting = false; 

//Update responder is already in place 
_theChatRooms.put(_waiting_room_ChatRoom.handle = 

_rtiAmbassador.registerObj ectInstance(_och_ChatRoom, 

_wait ing_room_ChatRoom. name . toString () ) , _waiting_room_ChatRoom) ,- 

_rtiAmbassador.subscribeObj ectClassAttributes(_och_ChatRoom, 
_oahs_ChatRoom_forUpdate) ,- 

//The waiting_room ChatRoom is already in the 
_ChatRoomRegistry, so no need to update it 

} //synchronized(_theChatRooms) 

} //synchronized(AcquireChatRoomRegistry()) 

} else { 

//Name reservation failed, which means there is an already 
extant instance 

synchronized(_sem_discovery) 

{ 

_sem_discovery.value = false; 

_fedAmbassador.setDiscoveryListener(_och_ChatRoom, new 
MyChatRoomDiscoveryListener (_sem_discovery) ) ,- 

//This is the only pre-existing aChatRoom, so we must 
set its subscribed property here 

_waiting_room_ChatRoom .subscribed = true ,- 

_rtiAmbassador.subscribeObj ectClassAttributes(_och_ChatRoom, 
_oahs_ChatRoom_forUpdate) ,- 

//Update listener is already in place 
waitFor (_sem_discovery) ,- 

_fedAmbassador.setDiscoveryListener(_och_ChatRoom, new 
MyChatRoomDiscoveryListener (null) ) ,- 

} //synchronized(_sem_discovery) 

} //if 

//The General ChatRoom may or may not exist initially 

return true; 

} catch (Exception e) { 
e . printStackTrace () ,- 
return false; 

} finally { 

} //try 


1036 


DRDC Valcartier TR 2007-412 



private boolean 
setupParticipants () 

{ 

try { 

_fedAmbassador.setDiscoveryListener(_och_Participant, new 
MyParticipantDiscoveryListener(null, null)),- 

//These objects are never deleted, so removal is impossible 
//Instead, they go in/out of scope 

_fedAmbassador.setAttributeScopeListener(_och_Participant, 
new MyParticipantAttributeScopeListener () ) ,- 

_fedAmbassador.setOwnershipListener(_och_Participant, new 
MyPart icipantOwnershipListener (null, null) ) ,- 

_fedAmbassador.setAttributeUpdateListener(_och_Participant, 
new MyParticipantInstanceAttributeListener()); 

// Note that if we wanted an instance-specific responder, we 
could not put it in place before getting 

// _oih_myParticipant back from registerObjectlnstance or 
getObjectInstanceHandle, so we could 

// conceivably miss a provideAttributeValueUpdate request 
issued by another federate between the 

// registration and the setting up of the responder --unless 
both statements are put in a single synchronized block. 

_fedAmbassador.setAttributeUpdateResponder(_och_Participant, 
new MyParticipantlnstanceAttributeResponder()); 

_rtiAmbassador.publishObj ectClassAttributes(_och_Participant, 
_oahs_Participant_forUpdate) ,- 

//Note that associateRegionsForUpdates can be done only on a 
per-instance basis 

//We publish federation-wide but will update and subscribe 
through DDM 

//No federate *ever* subscribes to the nowhere "ChatRoom" 

_rtiAmbassador.subscribeObj ectClassAttributesWithRegions(_och_Particip 
ant, _asrspl_Participant_waiting_room) ,- 

//Update listener is already in place 

return true; 

} catch (Exception e) { 
e. printStackTrace () ,- 
return false; 

} finally { 

} //try 


DRDC Valcartier TR 2007-412 


1037 



* * 


* Used by various methods to acquire ownership of the 
ChatRoomRegistry. 

* It is expected to be called by a statement like: 

* synchronized(AcquireChatRoomRegistry() ) {} 

*/ 

private aChatRoomRegistry 
AcquireChatRoomRegistry() 

{ 

//Can't synchronize on _ChatRoomRegistry because the waitFor 
will only release its Semaphore 

//argument, and the AcquisitionNotification will need to 
synchronize on _ChatRoomRegistry. 

//The Java wait method only frees up the monitor of the object 
it is invoked on --there is no way to 

//"wait" for a *set* of monitors. 

// synchronized(_ChatRoomRegistry) 

// { 

if (_ChatRoomRegistry.owned) return _ChatRoomRegistry; 
synchronized(_sem_acquisition) 

{ 

try { 

FederateAmbassadorAttributeOwnership previous = 
(FederateAmbassadorAttributeOwnership)_fedAmbassador.setOwnershipListe 
ner(_och_ChatRoomRegistry, new 

MyChatRoomRegistryOwnershipListener(_sem_acquisition)); 
_sem_acquisition.value = false; 

_rtiAmbassador.attributeOwnershipAcquisition(_ChatRoomRegistry.handle, 
_oahs_ChatRoomRegistry, null); 

waitFor(_sem_acquisition); 

_fedAmbassador.setOwnershipListener(_och_ChatRoomRegistry, previous); 
return _ChatRoomRegistry; 

} catch (Exception ignored) { 

} //try 

} //synchronized(_sem_acquisition) 

//Failure to acquire is not an option 
return null; 

// } //synchronized(_ChatRoomRegistry) 


1038 


DRDC Valcartier TR 2007-412 



* * 


* Used by various methods to remove a ChatRoom from the registry 
and update the latter. 

* Remember that the ChatRoomRegistry only maps ChatRoom names to 
slots; it does not link 

* to ChatRoom object instances at all. 

* @param slot a short specifying the ChatRoom entry to remove 
*/ 

private void 

RemoveChatRoomAndUpdateRegistry(short slot) 

{ 

//Presumes _ChatRoomRegistry has been synchronized on 
try { 

boolean updateNeeded = false; 

if (slot <= _slot_general_ChatRoom) return; //waiting_room 
and General are fixtures 

for (int i = 0; i < _ChatRoomRegistry.list.size() ; i + +) 

{ 

if (slot == 

((ChatRoomRegistryEntry)_ChatRoomRegistry.list.get(i)).slot.getValue() 


_ChatRoomRegistry.list.remove(i); 

updateNeeded = true; 

break; 

} //if 

} //for 

if (lupdateNeeded) return; 

AttributeHandleValueMap _ahvm_ChatRoomRegistry = 

_rtiAmbassador.getAttributeHandleValueMapFactory().create(_oahs_ChatRo 
omRegistry_forUpdate .size()); 

_ahvm_ChatRoomRegistry.put(_oah_ChatRoomRegistry_list, 
_ChatRoomRegistry.list.toByteArray()); 

_rtiAmbassador.updateAttributeValues(_ChatRoomRegistry.handle, 
_ahvm_ChatRoomRegistry, null); 

} catch (Exception ignored) { 

} finally { 

} //try 


DRDC Valcartier TR 2007-412 


1039 



* * 


* Used by various methods to add a ChatRoom to the registry and 
update the latter. 

* The ChatRoom is also added to _theChatRooms 

* @param name a String specifying the ChatRoom name to give to the 
new entry (it'll be prefixed by the method) 

* @return the newly created aChatRoom object (null in case of 
failure) 

*/ 

private aChatRoom 

AddChatRoomAndUpdateRegistry(String name) 

{ 

//Must be called from the event-handling thread 
//Presumes _ChatRoomRegistry has been synchronized on 
try { 

//To allow user names and chat room names to be anything, the 
latter will be prefixed 

//by "p" and "o' 1 , respectively, whilst our reserved names 
will be prefixed by ,l _' 1 

String newChatRoomName = "o' 1 + name; 

aChatRoom _ChatRoom = SeekChatRoomByName (newChatRoomName) ,- 
if (_ChatRoom l= null) 

{ 

j avax.swing.JOptionPane.showMessageDialog(null, "The chat 
room name «" + name + "» already exists. Sorry!' 1 , 

_federateHandle.toString(), 

j avax .swing. JOpt ionPane . INFORMATI ON_MESSAGE) ,- 
return null; 

} //if 

//At this point we know the name is OK; now find a slot 

number 

short candidate = _slot_FirstFreeChatRoomSlot ,- 
//Each SeekChatRoom method synchronizes on _theChatRooms 
for ( ,- null ! = SeekChatRoomBySlot (candidate) ,- candidate++) ,- 
//We'll use candidate for the slot value 

_ChatRoomRegistry.list.add(_ChatRoomRegistry.list.sizeO, new 
ChatRoomRegistryEntry(newChatRoomName, new 
HLAintegerlSBE (candidate) ) ) ,- 

AttributeHandleValueMap _ahvm_ChatRoomRegistry = 

_rtiAmbassador.getAttributeHandleValueMapFactory().create(_oahs_ChatRo 
omRegistry_forUpdate.size()); 

_ahvm_ChatRoomRegistry.put(_oah_ChatRoomRegistry_list, 
_ChatRoomRegistry.list.toByteArray()); 

_rtiAmbassador.updateAttributeValues(_ChatRoomRegistry.handle, 
_ahvm_ChatRoomRegistry, null) ,- 


1040 


DRDC Valcartier TR 2007-412 



_ChatRoom = new aChatRoom(newChatRoomName, candidate); 
_ChatRoom.subscribed = _ChatRoom.owned = true; 
synchronized(_theChatRooms) 

{ 

_theChatRooms.put(_ChatRoom.handle = 
rtiAmbassador.registerObj ectlnstance(_och_ChatRoom), _ChatRoom),- 
} //synchronized(_theChatRooms) 
return _ChatRoom,- 
} catch (Exception ignored) { 

} finally { 

} //try 
return null; 


/** Exit the Application */ 

private void exitForm(java.awt.event.WindowEvent evt) 

{ 

try { 

_me_shutting_down = true; 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
if (_rtiAmbassadorl=null) 

{ 

lblStatus.setText("MyChat shutting down..."); 
if (_me_logged_in) doLogoutO; 

// if ("Log Out". equals (btnLogon. getText ()) ) doLogoutO; 

doUnsubscribe () ,- 
if (J_alone) doForceDivest () ,- 
doUnpublish () ,- 
try { 

//Any remaining owned objects will be deleted (there 
should be none when !_alone, really) (well, maybe some Region 
obj ects...) 

_rtiAmbassador.resignFederationExecution(ResignAction.DELETE_OBJECTS_T 
HEN_DIVEST); 

//OwnershipAcquisitionPending, FederateOwnsAttributes, 
FederateNotExecutionMember, RTIinternalError 

lblStatus.setText("MyChat shutting down - Resigning 
from federation"),- 

_rtiAmbassador.destroyFederationExecution(fedex),- 
//FederatesCurrentlyJoined, 

FederationExecutionDoesNotExist, RTIinternalError 

lblStatus.setText("MyChat shutting down - Federation " 

+ fedex + " destroyed") ,- 

} catch (RTIexception ignored) { 

} //try 

} //if 

} finally { 

System.exit (0) ,- 
} //try 


DRDC Valcartier TR 2007-412 


1041 



private void 
doUnsubscribe() 


try { 

_rtiAmbassador.unsubscribelnteractionClassWithRegions(_ich_Communicati 
on, _rhs_waiting_room_ChatRoom); 


_rtiAmbassador.unsubscribeObjectClassAttributes(_och_ChatRoom, 
_oahs_ChatRoom_forUpdate); 

_rtiAmbassador.unsubscribeObjectClassAttributesWithRegions(_och_Partic 
ipant, _asrspl_Participant_waiting_room); 


rtiAmbassador.unsubscribeObjectClassAttributes(_och_ChatRoomRegistry, 
oahs_ChatRoomRegistry_forUpdate); 

} catch (Exception e) { 
e.printStackTrace() ; 

} finally { 


private void 
doUnpublish() 

{ 

try { 

_rtiAmbassador.unpublishlnteractionClass(_ich_Communication); 

_rtiAmbassador.unpublishObj ectClassAttributes(_och_ChatRoom, 
_oahs_ChatRoom_forUpdate); 

//unassociateRegionsForUpdates can only be done on a per- 
instance basis 

_rtiAmbassador.unpublishObj ectClassAttributes(_och_Participant, 
_oahs_Participant_forUpdate); 


rtiAmbassador.unpublishObj ectClassAttributes(_och_ChatRoomRegistry, 
oahs_ChatRoomRegistry_forUpdate); 

} catch (Exception e) { 
e . printStackTrace() ; 

} finally { 

} //try 


1042 


DRDC Valcartier TR 2007-412 



private void 
divestChatRoomRegistry() 

{ 

//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

//This usually runs in the event-handling thread ("AWT- 
EventQueue-0") but can be called from other threads 
try { 

if (!_ChatRoomRegistry.owned) return; 

Semaphore _sem_divest = new Semaphore (),- 
synchronized(_sem_divest) 

{ 

_sem_divest.value = false,- 
java.lang.Object _oldListener = 

_fedAmbassador.setOwnershipListener(_och_ChatRoomRegistry, new 
MyChat.MyChatRoomRegistryOwnershipListener(_sem_divest)),- 
_ChatRoomRegistry.divesting = true; 

_rtiAmbassador.negotiatedAttributeOwnershipDivestiture(_ChatRoomRegist 
ry.handle, _oahs_ChatRoomRegistry, null),- 
//Other federates will receive 
requestAttributeOwnershipAssumption and 

//respond with attributeOwnershipAcquisitionlfAvailable. 
//We'll get requestDivestitureConfirmation, to which we'll 
confirmDivestiture 

//Once that is done, we no longer own _ChatRoomRegistry 
and can resign normally. 

waitFor (_sem_divest) ,- 

// _fedAmbassador.setOwnershipListener(_och_ChatRoomRegistry, 

null) ,- 

_fedAmbassador.setOwnershipListener(_och_ChatRoomRegistry, 
(FederateAmbassadorAttributeOwnership) _oldListener) ,- 
} //synchronized(_sem_divest) 

} catch (Exception e) { 
e. printStackTrace () ,- 
} finally { 

} //try 


DRDC Valcartier TR 2007-412 


1043 



private void 
divestChatRooms() 

{ 

//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

//This usually runs in the event-handling thread ("AWT- 
EventQueue-O") but can run from other threads 
try { 

//ChatRoom objects 
aChatRoom _ChatRoom,- 

Semaphore _sem_divest = new Semaphore (),- 
synchronized(_sem_divest) 

{ 

java.lang.Object _oldListener = 

_fedAmbassador.setOwnershipListener(_och_ChatRoom, new 
MyChat.MyChatRoomOwnershipListener(_sem_divest, null)),- 

//Any federate callbacks requesting ownership assumption 
will be turned down right away; 

//however, ownership acquisition notifications could 
conceivably squeak through 

//(if another federate started shutting down just before 
this one does) and would lock 

//up on the synchronized(_theChatRooms), so we take a 
snapshot and release the monitor right away. 
aChatRoom[] _ChatRooms,- 
synchronized(_theChatRooms) 

{ 

_ChatRooms = (aChatRoom[]) 

_theChatRooms.values().toArray(new aChatRoom[0]),- 
} //synchronized(_theChatRooms) 

// for (Iterator i = _theChatRooms.entrySet().iterator(),- 

i.hasNext();) 

for (int i = 0; i < _ChatRooms.length; i++) 

{ 

// _ChatRoom = 

(aChatRoom)((java.util.Map.Entry)i.next()).getValue(),- 
_ChatRoom = _ChatRooms[i] ,- 

+ " 

slot: 11 + _ChatRoom. slot. toString () 

+ " 

handle: 11 + _ChatRoom. handle . toString ()) ,- 
if (_ChatRoom.owned) 

{ 

_sem_divest.increaseCount(),- 
_ChatRoom.divesting = true; 

_rtiAmbassador.negotiatedAttributeOwnershipDivestiture(_ChatRoom.handl 
e, _oahs_ChatRoom, null); 

//Other federates will receive 
requestAttributeOwnershipAssumption and 
//respond with 

attributeOwnershipAcquisitionlfAvailable. 

//We'll get requestDivestitureConfirmation, to which 
we'11 confirmDivestiture 

//Once that is done, we no longer own any ChatRooms 
and can resign normally. 

} //if 

} //for 


1044 


DRDC Valcartier TR 2007-412 



if (!_sem_divest.zero() ) 

{ 

waitFor(_sem_divest); 

} //if 

// _fedAmbassador.setOwnershipListener(_och_ChatRoom, new 

MyChat.MyChatRoomOwnershipListener(null, null)); 

_fedAmbassador.setOwnershipListener(_och_ChatRoom, 
(FederateAmbassadorAttributeOwnership)_oldListener); 

} //synchronized(_sem_divest) 

} catch (Exception e) { 
e.printStackTrace (); 

} finally { 


private void 
divestParticipants () 

{ 

//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

//This usually runs in the event-handling thread ("AWT- 
EventQueue-0") but could be called from other threads 
try { 

//Participant objects 
aParticipant _Participant; 

Semaphore _sem_divest = new Semaphore(); 
synchronized(_sem_divest) 

{ 

java.lang.Object _oldListener = 

_fedAmbassador.setOwnershipListener(_och_Participant, new 
MyChat.MyParticipantOwnershipListener(_sem_divest, null)); 

//Any federate callbacks requesting ownership assumption 
will be turned down right away; 

//however, ownership acquisition notifications could 
conceivably squeak through 

//(if another federate started shutting down just before 
this one does) and would lock 

//up on the synchronized(_theParticipants), so we take a 
snapshot and release the monitor right away. 

aParticipant[] -Participants; 
synchronized(_theParticipants) 

{ 

_Participants = (aParticipant[] ) 

_theParticipants.values() .toArray(new aParticipant [0] ) ; 

} //synchronized(_theParticipants) 


DRDC Valcartier TR 2007-412 


1045 



theParticipants.entrySet(). iterator (); 


// for (Iterator i = 

i.hasNext();) 

for (int i = 0; i < _Participants.length; i++) 

{ 

// _Participant = 

(aParticipant) ((j ava.util.Map.Entry)i.next()) .getValue(); 

_Participant = _Participants[i] ; 

+ " 

slot: 11 + _Part icipant. chat_room_slot. toString () 

+ " 

handle : 11 + _Part icipant. user_handle . toString () ) ; 
if (_Participant.owned) 

{ 

_sem_divest.increaseCount(); 

_Participant.divesting = true; 

_rtiAmbassador.negotiatedAttributeOwnershipDivestiture(_Participant.ha 
ndle, _oahs_Participant, null); 

//Other federates will receive 
requestAttributeOwnershipAssumption and 
//respond with 

attributeOwnershipAcquisitionlfAvailable. 

//We'll get requestDivestitureConfirmation, to which 
we'11 confirmDivestiture 

//Once that is done, we no longer own any 
Participants and can resign normally. 

} //if 

} //for 

if (!_sem_divest.zero() ) 

{ 

waitFor(_sem_divest); 

} //if 

// _fedAmbassador.setOwnershipListener(_och_Participant, new 

MyChat.MyParticipantOwnershipListener(null, null)); 

_fedAmbassador.setOwnershipListener(_och_Participant, 
(FederateAmbassadorAttributeOwnership)_oldListener); 

} //synchronized(_sem_divest) 

} catch (Exception e) { 
e . printStackTrace() ; 

} finally { 

} //try 


1046 


DRDC Valcartier TR 2007-412 



private void 
doForceDivest() 

{ 

//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

//This runs in the event-handling thread ("AWT-EventQueue-O") 
try { 

//ChatRoomRegistry object 
divestChatRoomRegistry(); 

//ChatRoom obj ects 
divestChatRooms(); 

//Participant objects 
divestParticipants() ; 

} catch (Exception e) { 
e.printStackTrace() ; 

} finally { 


j * * 

* The btnLogon is used to Log On and to Log Out. 

*/ 

private void btnLogonActionPerformed(java.awt.event.ActionEvent 
evt) 


//This runs in the event-handling thread ("AWT-EventQueue-O") 
if (_me_logged_in) // ("Log Outequals (btnLogon.getText())) 

{ 

//Log out procedure 
doLogout(); 

} else { 

//Log In procedure 
doLogin(); 

} //if 


DRDC Valcartier TR 2007-412 


1047 



private void 
doLogin() 


try { 

//This runs in the event-handling thread ("AWT-EventQueue-O' 1 ) 
_me_logging_in = true; 
if (lregisterParticipant() ) 

{ 

_me_logging_in = false; 
return; 

} //if 

_me_logged_in = true; 

_rtiAmbassador.subscribelnteractionClassWithRegions(_ich_Communication 
, _rhs_current_ChatRoom); 

_rtiAmbassador.subscribelnteractionClassWithRegions(_ich_Communication 
, _rhs_myParticipantRegion) ; 

_me_logging_in = false; 
txtUsername.setEnabled(false) ; 
btnLogon.setText("Log Out"); 

// btnSendMessage.setEnabled(true); 

txtMessage.setEnabled(true); 
lblChatRoom.setEnabled(true); 

IstChatRooms.setEnabled(true) ; 
btnNewChatRoom.setEnabled(true) ; 
lblSendTo.setEnabled(true); 

IstSendTo.setEnabled(true); 
txtMessage.requestFocus() ; 

} catch (Exception e) { 
e . printStackTrace() ; 

} finally { 

} //try 


1048 


DRDC Valcartier TR 2007-412 



private boolean 
registerParticipant() 


java.util.Map.Entry _m; 

Obj ectlnstanceHandle _h; 
aParticipant _p,- 
aParticipant _Participant,- 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
because it is called from it 

//This method's purpose is to validate the user name; 

//if it succeeds, the Participant object with the 
//requested user name is now owned by this federate. 

//We know it won't be an empty String because the button is 
disabled when the txtUsername is empty. 

_me.name.setValue("p" + txtUsername.getText()); 

// _me.handle = null; //ObjectlnstanceHandle of the Participant 
obj ect 

// _me.user_handle.setValue(0); //Same value, as an HLAint32 for 
DDM purposes 
try { 

// Reserve name 

boolean reservation_succeeded; 
synchronized(_sem_reservation) 

{ 

_sem_reservation.value = false; 

_fedAmbassador.setNameReservationListener(_me.name.toString(), new 
MyNameReservationListener (_sem_reservation) ) ,- 

_rt iAmbassador . reserveObj ectlnstanceName (_me . name . toString () ) ,- 
// Wait for reservation succeeded/failed 
waitFor (_sem_reservation) ,- 

_fedAmbassador.setNameReservationListener(_me.name.toString(), null) 
reservat ion_succeeded = _s em_r e servat ion. value ,- 
} //synchronized(_sem_reservation) 


DRDC Valcartier TR 2007-412 



//Prepare the <General> ChatRoom 
_rhs_current_ChatRoom = 

rtiAmbassador.getRegionHandleSetFactory().create(),- 
//Arrival (<General>) ChatRoom is slot 2 
_rh_current_ChatRoom = _rh_general_ChatRoom,- 
rhs current ChatRoom.add( rh current ChatRoom); 


_rtiAmbassador.commitRegionModifications(_rhs_current_ChatRoom),- 
//Won't complain if there are no mods to commit 
_asrspl_Participant_current = 

_rtiAmbassador.getAttributeSetRegionsetPairListFactory().create(1); 

_asrspl_Participant_current.add(new 
AttributeRegionAssociation(_oahs_Participant_forUpdate, 
_rhs_current_ChatRoom)),- 

//Note that the prepared association has not been applied yet 
if (reservation_succeeded) 


//For chat_room_slot filtering, we associate all 
"forUpdate" attributes to _dh_ChatRoomSlots regions 

//We'd get InvalidRegionContext when subscribing if we 
included the DeletePrivilege 
synchronized(_me) 


_me.logged_in.setBoolean(_me.owned = _me.subscribed = 
l(_me.inscope = _me.divesting = false)); 

_me.chat_room_slot.setValue(_slot_nowhere_ChatRoom),- 
//If there were any federates subscribed to the 
creation region (nowhere), 

//there would be Discovery and Auto-Update would 
trigger our InstanceAttributeResponder and all that; 

//Hence the atomic register-and-put; the 
synchronized(_me) would delay a bit until the _me.user_handle is set 
//But since no-one subscribes to nowhere, there is no 


rush 


synchronized(_theParticipants) 


_theParticipants.put(_me.handle = 

_rtiAmbassador.registerObj ectInstanceWithRegions(_och_Participant 
_asrspl_Part icipant_nowhere, _me. name . toString () ) , _me) ,- 
} //synchronized(_theParticipants) 

// 

_me . user_handle . setValue (Obj ect InstanceHandleToInt (_me . handle) ) ,- 
_me.user_handle.setValue(_me.handle.hashCode()); 

} //synchronized(_me) 


1050 


DRDC Valcartier TR 2007-412 



} else { 

//At this point, we know the desired Participant object 
exists --we just don't know where it is. 

//If it is logged-out, it'll be in the waiting_room and we 
will discover it there and can then acquire it. 

//It is logged-in by someone else, it'll be in some other 
ChatRoom (2+) and we won't discover it 

//and cannot use it. There is no "fail-fast" in that 
situation, however. 

//It is reasonably safe to assume that if we don't know of 
the sought Participant, it must be logged in by someone else. 

//Is the object known? 
try { 
try { 

_Participant = 

SeekParticipant(_rtiAmbassador.getObj ectlnstanceHandle(_me.name.toStri 

ng () ) ) ; 

} catch (ObjectlnstanceNotKnown ex) { 

//The Participant was unknown,- it cannot be in the 

waiting_room 

lblStatus.setText(_me.name.toStringO .substring(1) + 
" is already logged-in. Sorry!"),- 

_me .name . setValue ("") ,- 
return false,- 
} //try 
} finally { 

} //try 

//At this point, the sought Participant is known 

//If freshly discovered, we could wait for its user_handle 
to be updated by reflectAttributeValues (this is the 

//only field guaranteed to change) so that we can then 
safely look up its logged_in or chat_room_slot values. 

//Instead, we'll request ownership right away,- a logged-in 
Participant will fail. 

//It could be already owned (if it was an unused 
Participant we just happened to have the custody of) 
if (!_Participant.owned) 

{ 

//For a Participant to be eligible for acquisition, it 

must be in the 

//_waiting_room and therefore inscope 
boolean acquisition_succeeded = false,- 


DRDC Valcartier TR 2007-412 


1051 



//If the _Participant goes out of scope before we 
get to the attributeOwnershipAcquisition call, 

//we'll be stuck at the semaphore. This may happen 
if there is a race for the same Participant. 

//About the only way around this risk I can see may 
be to have the acquiring federates first 

//grab the ChatRoomRegistry (before testing 
inscope), releasing it once the Participant 

//acquisition is completed. 

//This is a form of queueing, where the federates 
are passing between themselves a token 

//(the ChatRoomRegistry) which gives them the 
"right' 1 to attempt acquisition. The 

//disadvantage is that it creates an artificial 
bottleneck (and extra traffic). 

synchronized(_sem_acquisition) 

{ 

_sem_acquisition.value = false; 

_fedAmbassador.setOwnershipListener(_och_Participant, new 
MyParticipantOwnershipListener(_sem_acquisition, 

_Participant .handle) ) ,- 

//Before acquiring, set up update regions so they 
do not lapse during ownership transfer 

_rtiAmbassador.associateRegionsForUpdates(_Participant.handle, 
_asrspl_Participant_nowhere) ,- 

_rtiAmbassador.associateRegionsForUpdates(_Participant.handle, 
_asrspl_Participant_waiting_room) ,- 

_rtiAmbassador.attributeOwnershipAcquisition(_Participant.handle, 
_oahs_Participant, null) ,- 

waitFor (_sem_acquisition) ,- 

_fedAmbassador.setOwnershipListener(_och_Participant, new 
MyParticipantOwnershipListener (null, null) ) ,- 

acquis it ion_succeeded = _sem_acquisit ion .value ,- 
} //synchronized(_sem_acquisition) 

} //if 

if (!acquisition_succeeded) 

{ 

//Acquisition failed: someone else is logged in 
under that Participant 

lblStatus.setText(_me.name.toString().substring(1) + 
" is already logged-in. Sorry!"),- 

_me . name. setValue ("") ,- 
return false,- 

} //if 

//Acquisition succeeded: that Participant was available 

} //if 


1052 


DRDC Valcartier TR 2007-412 



synchronized(_me) 


_me = -Participant; 

// _me.divesting = false; //could be still true; will be 

fixed later 

_me.logged_in.setBoolean(_me.owned = true); 

// 

_me.user_handle.setValue(Obj ectInstanceHandleToInt(_me.handle)) ; 

_me.user_handle.setValue(_me.handle.hashCode()); 
//Removing _me from the waiting_room will trip 
Attribute Scope Advisories 

_rtiAmbassador.unassociateRegionsForUpdates(_me.handle 
_asrspl_Participant_waiting_room); 

//At this point, _me.handle is only associated with 
_asrspl_Participant_nowhere 

_me.chat_room_slot.setValue(_slot_nowhere_ChatRoom); 

} //synchronized(_me) 

} //if 

//Does the General ChatRoom exist? 
synchronized(_theChatRooms) 

{ 

_general_ChatRoom = 

SeekChatRoomBySlot(_slot_general_ChatRoom); 

if (null == _general_ChatRoom) 

{ 

synchronized(AcquireChatRoomRegistry()) 

{ 

_general_ChatRoom = new 

aChatRoom(_name_general_ChatRoom, _slot_general_ChatRoom); 

_general_ChatRoom.owned = 

_general_ChatRoom.subscribed = true; 

// _general_ChatRoom.divesting = false; 

_theChatRooms.put(_general_ChatRoom.handle = 
_rtiAmbassador.registerObj ectlnstance(_och_ChatRoom), 
_general_ChatRoom); 

//No need to add the General ChatRoom to the 
_ChatRoomRegistry, as it is already listed 

} //synchronized(AcquireChatRoomRegistry()) 

} else { 

} //if 

} //synchronized(_theChatRooms) 


DRDC Valcartier TR 2007-412 



//It is just barely possible, given thread sequencing and RTI 
transmission delays, that two (or more) 

//copies of the general chat room (or any other chat room 
except for the waiting room) may end up 

//being created. This does not matter for Participant 
regions since the slots won't be affected 

//(the ChatRoomRegistry controls slot assignment, and its 
ownership is passed from federate to federate). 

//We could try to cut down on such situations by checking 
upon Discovery --if one discovers a ChatRoom 

//duplicate (same name and therefore slot), and one owns one 
of the two, acquire the Registry (this 

//being a race condition, the owner of the duplicate could be 
trying to do the same, so this acquisition 

//acts as a tie-breaker) then, if the condition still holds, 
acquire aggressively the duplicate. 

//Once that is achieved, delete the duplicate. Removal 
responders would need to check for duplicates 

//in their lists of ChatRooms, so if one is advised of the 
removal of _general_ChatRoom or _myChatRoom 

//(the only two that matter), effect the substitution rather 
than setting the member to null. 

//Substitution would also inhibit deletion of the entry in 
IstChatRooms. 

//When shutting down a chat room, we should also delete 
repeatedly until the name does not appear in 
//the list any more. 

//The converse is also just barely possible: one federate 
could delete a ChatRoom just as another 

//is in the process of joining it. Again, this is a matter 
for the Removal responder. If one is 

//advised of the Removal of a ChatRoom that matters, and 
there is no duplicate extant, then one 

//must recreate the ChatRoom object. 

//Another possible solution to these kinds of problems would 
be to make the federates time-constrained 

//and time-regulating. Time-stamping the deletions and 
creations of chat rooms could be used to ensure 

//that all federate callbacks are processed before any action 

is taken. 


//For expediency's sake, this level of coding has not been 
implemented here. 


1054 


DRDC Valcartier TR 2007-412 



//This association will trigger Attribute Scope Advisories, 
Discovery: 

_myChatRoom = _general_ChatRoom; 

_me.chat_room_slot.setValue(_slot_general_ChatRoom),- 
_me_logged_in = l(_me_logging_in = false),- 

//If you associate first and then subscribe, a previously 
known object won't trip the scope advisories (?) 

_rtiAmbassador.subscribeObj ectClassAttributesWithRegions(_och_Particip 
ant, _asrspl_Participant_current) ,- 

//Add the _general ChatRoom association to the pre-existing 
_nowhere ChatRoom association 

_rtiAmbassador.associateRegionsForUpdates(_me.handle, 
_asrspl_Participant_current) ,- 

//Subscription will refresh subscribed Participants ,- 
//since we use Auto-Provide, an explicit Update request is 
not needed 

lblStatus.setText("Welcome, " + 

_me .name .toStringO . substring (1) ) ,- 

//Subscribe to the interaction 

//We'll be listening to interactions that come in on our 
user-handle channel in addition to the chat-room-slot channel 

//It is the interaction sender's responsibility to pick the 
channels to use 

_rh_myParticipantRegion = 

_rt iAmbassador . createRegion (_dhs_UserHandleSlot sSet) ,- 

//setRangeBounds must be invoked at least once for each 
dimension specified. 

//Only then can commitRegionModifications be invoked to turn 
the region template into a region specification. 

_rtiAmbassador.setRangeBounds(_rh_myParticipantRegion, 
_dh_UserHandleSlots, new RangeBounds(_me.user_handle.getValue(), 

_me .user_handle .getValue () + 1) ) ,- 

_rhs_myParticipantRegion = 

_rt iAmbassador . getRegionHandleSetFactory () .create () ,- 

_rhs_myPart icipant Region. add (_rh_myPart icipant Region) ,- 

_rtiAmbassador . commitRegionModif ications (_rhs_myParticipantRegion) ,- 
//subsoribeInteractionClassWithRegions done by doLogin 

return true; 

} catch (RTIexception e) { 
e. printStackTrace () ,- 
return false; 

} finally { 

} //try 


DRDC Valcartier TR 2007-412 


1055 



private void 
doLogout () 

{ 

try { 

//This runs in the event-handling thread ("AWT-EventQueue-O' 1 ) 
//Log out procedure 
_me_logged_in = false,- 

//Move from "current" ChatRoom to "waiting_room" ChatRoom 
//Unsubscribe from the current ChatRoom 

_rtiAmbassador.unsubscribelnteractionClassWithRegions(_ich_Communicati 
on, _rhs_current_ChatRoom),- 

//Unsubscribe from the user handle channel 

_rtiAmbassador.unsubscribelnteractionClassWithRegions(_ich_Communicati 
on, _rhs_myParticipantRegion) ,- 

//Look at the ChatRoom we're leaving to decide whether to 
delete it or not 

int count = 0; 

synchronized(_theParticipants) 

{ 

aParticipant _iParticipant,- 

for (Iterator i = _theParticipants .values (). iterator () ,- 
i .hasNext () ,-) 


_i Part icipant = (aPart icipant) i . next () ,- 

//Out of scope Participants have unreliable attributes; 
they cannot be in our ChatRoom in any case 

//The only exceptions are owned Participants: any owned 
orphans can only be in the waiting_room 
//_me isn't counted 

if ((!_me.handle.equals(_iParticipant.handle)) && 

(_iParticipant.inscope) && 

(_me . chat_room_slot. equals (_i Part icipant. chat_room_slot) ) ) count+ + ,- 
} //for 

} //synchronized(_theParticipants) 

//This'll cause the Participants in our ChatRoom to go out of 

scope 

_rtiAmbassador.unsubscribeObjectClassAttributesWithRegions(_och_Partic 
ipant, _asrspl_Participant_current) ,- 

//What if someone logs into the ChatRoom after we've counted 
its Participants but before we actually delete it? 


1056 


DRDC Valcartier TR 2007-412 



//Doesn't seem worth synchronizing on _myChatRoom 
if (count <= 0) //Should be just ==0 but you never know 
(because of inscope, _me isn't counted) 

{ 

//We were the only Participant left in the ChatRoom,- 
delete it as we leave (we must be the owner, obviously) 
synchronized(AcquireChatRoomRegistry()) 

{ 

// _theChatRooms . remove (_myChatRoom. handle) ,- //Because 

we're the owner, we won't get a RemoveObjectlnstance notification 
// _rtiAmbassador.deleteObj ectlnstance(_myChatRoom.handle 

null) ,- 

//Because we're the owner, we won't get a 
RemoveObj ectlnstance notification 

//The remove returns the removed value, which is 

_myChatRoom 

_rtiAmbassador.deleteObj ectlnstance(((aChatRoom)_theChatRooms.remove( 
myChatRoom.handle) ) .handle, null) ,- 

RemoveChatRoomAndUpdateRegistry(_myChatRoom.slot.getValue()); 
if 

(!_myChatRoom.name.toString().equals(_name_general_ChatRoom)) 


IstChat Rooms . remove I tern (_myChatRoom. name.toString () .substring (1)) ,- 

} //if 

} //synchronized(AcquireChatRoomRegistry()) 

} else if (_myChatRoom.owned) 


//There are other Participants but we were the owner: 
transfer ownership 

_myChatRoom.divesting = true; 


_rtiAmbassador.negotiatedAttributeOwnershipDivestiture(_myChatRoom.han 
die, _oahs_ChatRoom, null); 

} //if 

_myChatRoom = null; //Should be OK; if being divested, it 
still has a reference from _theChatRooms and therefore won't be 
garbaged 


DRDC Valcartier TR 2007-412 


1057 



//The _me Participant is the only one that can be elsewhere 
than the waiting_room and be owned; 

//by definition, an owned Participant stands in for the 
federate in whichever ChatRoom it is 

//Move it from current to waiting_room 

_rtiAmbassador.unassociateRegionsForUpdates(_me.handle, 
_asrspl_Participant_current); 
synchronized(_me) 

{ 

_me.logged_in.setBoolean(false); 

_me.chat_room_slot.setValue(_slot_waiting_room_ChatRoom); 
_rtiAmbassador.associateRegionsForUpdates(_me.handle, 
_asrspl_Participant_waiting_room); 

//AutoProvide will fetch our attribute update (since all 
federates subscribe to the waiting_room ChatRoom at all times) 

} //synchronized(_me) 

_me = new aParticipant(); 

//Delete the now unused regions 

_rhs_myParticipantRegion.remove(_rh_myParticipantRegion); 
_rtiAmbassador.deleteRegion(_rh_myParticipantRegion); 
_rh_myParticipantRegion = null; 

_rhs_myParticipantRegion = null; 

if (l_rh_current_ChatRoom.equals(_rh_general_ChatRoom)) 

{ 

_rtiAmbassador.deleteRegion(_rh_current_ChatRoom); 
_rh_current_ChatRoom = null; 

} //if 


//The IstSendTo will be emptied by the AttributeScopeListener 
// for (int i = l; i < IstSendTo.getItemCount(); i++) 

IstSendTo.removeItemAt(i); 

// btnSendMessage.setEnabled(false) ; 

txtMessage.setEnabled(false); 
lblChatRoom.setEnabled(false) ; 

IstChatRooms.setSelectedlndex(0); //So that we log back into 
the _<General> chat room 

IstChatRooms.setEnabled(false) ; 
btnNewChatRoom.setEnabled(false); 
lblSendTo.setEnabled(false) ; 

IstSendTo.setEnabled(false) ; 
btnLogon.setText("Log In"); 
txtUsername.setEnabled(true); 
txtUsername.requestFocus() ; 

btnLogon.getRootPane().setDefaultButton(btnLogon); 
lblStatus.setText("Welcome to MyChat - Please log in"); 

} catch (Exception e) { 
e . printStackTrace() ; 

} finally { 

} //try 


1058 


DRDC Valcartier TR 2007-412 



* * 


* The btnSendMessage is used to broadcast a chat message line. 

*/ 

private void 

btnSendMessageActionPerformed(j ava.awt.event.ActionEvent evt) 

{ 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
try { 

//We know the message won't be empty because the button is 
disabled when that is the case 

HLAunicodeString us_cmdline = new 
HLAunicodeString(txtMessage.getText()); 

//Note that there is no such thing as a ParameterHandleSet 
ParameterHandleValueMap _phvm_parameters = 

_rtiAmbassador.getParameterHandleValueMapFactory().create(2),- 
_phvm_parameters.put(_iph_Communication_message, 
us_cmdline.toByteArray()),- 

_phvm_parameters.put(_iph_Communication_sender, 

_me.name.toByteArray() ) ; 

//The IstSendTo can be used to send a private message (to a 
single user) instead of all users in the current chat room 
if (IstSendTo.getSelectedlndex () == 0) 

{ 

//This'll become WithRegions to handle ChatRooms... 

// _rtiAmbassador.sendlnteraction(_ich_Communication ; 

_phvm_parameters, null),- 

_rtiAmbassador.sendlnteractionWithRegions(_ich_Communication ; 
_phvm_parameters, _rhs_current_ChatRoom, null),- 

txtArea.append(_me.name.toString().substring(1) + " : " + 
us_cmdline + "\n"); 

lblStatus.setText("Message sent"),- 
} else { 

//We'll use DDM to send the message to a single user 
(within the same chat room) 

//The Participant object has three attributes, all three 
of which are bound 

//to the ChatRoomSlots dimension; in addition, user_handle 
is bound to UserHandleSlots. 

//To allow user names and chat room names to be anything, 
the latter will be prefixed 

//by "p" and "c", respectively, whilst our reserved names 
will be prefixed by 

HLAunicodeString _us_TargetName = new HLAunicodeString("p" 
+ IstSendTo . get Select edit em () . toString () ) ,- 

//Although the IstSendTo cannot change on us (because 
we're in the event-handling thread too), 

//the Participants could, so we must synchronize 


DRDC Valcartier TR 2007-412 


1059 



synchronized(_theParticipants) 

{ 

//_us_TargetName is the name of a Participant object, 
perforce known to us 

// ObjectlnstanceHandle key = 

_rtiAmbassador.getObj ectlnstanceHandle(_us_TargetName.toString()) ,- 
aParticipant _Participant = 

SeekParticipantByName(_us_TargetName.toString()); 
if (_Participant == null) 

{ 

j avax.swing.JOptionPane.showMessageDialog(null, 
_us_TargetName.toString().substring(1) + " unexpectedly logged out. 
Message not sent.' 1 , _f ederateHandle . toString () , 
j avax .swing. JOpt ionPane . P LAI N_MES SAGE) ,- 
return; 

} //if 

// Obj ectlnstanceHandle key = -Participant .handle,- 

// //long key_long = (long) 

Obj ectlnstanceHandleToInt (key) ,- 

// long key_long = (long) key. hashCode () ,- 

//The _ich_Communication interaction has two 
dimensions: UserHandleSlots and ChatRoomSlots 
// DimensionHandleSet dimensions = 

_rtiAmbassador.getAvailableDimensionsForInteractionClass(_ich_Communic 
ation) ,- 

RegionHandle _rh_aParticipant = 

_rt iAmbassador. createRegion (_dhs_UserHandleSlot sSet) ,- 
// _rtiAmbassador.setRangeBounds(_rh_aParticipant, 

_dh_UserHandleSlots, new RangeBounds(key_long, key_long + 1)); 

_rtiAmbassador.setRangeBounds(_rh_aParticipant, 
_dh_UserHandleSlots, new 

RangeBounds(_Participant.user_handle.getValue(), 

_Part icipant. user_handle . getValue () + 1) ) ,- 

RegionHandleSet _rhs_aParticipant = 

_rt iAmbassador. getRegionHandleSetFactory () .create () ,- 

_rhs_aPart icipant. add (_rh_aPart icipant) ,- 

_rtiAmbassador. commitRegionModifications (_rhs_aParticipant) ,- 

_rtiAmbassador.sendlnteractionWithRegions(_ich_Communication, 
_phvm_parameters , _rhs_aParticipant, null) ,- 
//Now throw the region away 

_rhs_aParticipant. remove (_rh_aParticipant) ,- 
_rt iAmbassador . deleteRegion (_rh_aPart icipant) ,- 
} //synchronized(_theParticipants) 

txtArea.append(_me.name.toString().substring(1) + " (to " 

+ IstSendTo . getSelectedl tern (). toString () + ") : " + us_cmdline + "\n"),- 
lblStatus . setText (" Private message sent") ,- 

} //if 

txtMessage . setText ("") ,- 
} catch (RTIexception e) { 

lblStatus.setText(e.getLocalizedMessage()); 

} finally { 

} //try 


1060 


DRDC Valcartier TR 2007-412 



* * 


* This utility method finds the Participant object in the hashmap 
by its ObjectInstanceHandle. 

* @param theObject an ObjectlnstanceHandle specifying the 
Participant sought 

* @return the sought Participant object, or null if not present 
*/ 

private aParticipant 

SeekParticipant(ObjectlnstanceHandle theObject) 

{ 

synchronized(_theParticipants) 

{ 

return (aParticipant)_theParticipants.get(theObject),- 
} //synchronized(_theParticipants) 


j * * 

* This utility method finds the ChatRoom object in the hashmap by 
its Obj ectlnstanceHandle. 

* @param theObject an ObjectlnstanceHandle specifying the ChatRoom 
sought 

* @return the sought ChatRoom object, or null if not present 
*/ 

private aChatRoom 

SeekChatRoom(Obj ectlnstanceHandle theObj ect) 

{ 

synchronized(_theChatRooms) 

{ 

return (aChatRoom) _theChatRooms . get (theObject) ,- 
} //synchronized(_theChatRooms) 


j * * 

* This utility method finds the ChatRoom object in the hashmap by 
its name. 

* @param name a String specifying the ChatRoom.name sought 

* @return the sought ChatRoom object, or null if not present 
*/ 

private aChatRoom 
SeekChatRoomByName(String name) 

{ 

aChatRoom _ChatRoom,- 
synchronized(_theChatRooms) 

{ 

for (Iterator i = _theChatRooms . entrySet (). iterator () ,- 
i . hasNext () ,-) 


_ChatRoom = 

(aChatRoom) ( (j ava . ut il. Map . Entry) i . next () ) . getValue () ,- 
if (_ChatRoom.name.toString().equals(name)) 

_ChatRoom,- 

} //for 
return null; 

} //synchronized(_theChatRooms) 


return 


DRDC Valcartier TR 2007-412 


1061 



* * 


* This utility method finds the ChatRoom object in the hashmap by 
its slot. 

* @param slot a short specifying the ChatRoom.slot sought 

* @return the sought ChatRoom object, or null if not present 
*/ 

private aChatRoom 
SeekChatRoomBySlot(short slot) 

{ 

aChatRoom _ChatRoom; 
synchronized(_theChatRooms) 

{ 

for (Iterator i = _theChatRooms.entrySet().iterator(),- 
i.hasNext();) 


_ChatRoom = 

(aChatRoom) ( (java .util.Map.Entry)i.next() ) .getValue() ,- 

if (_ChatRoom.slot.getValue() == slot) return _ChatRoom; 
} //for 
return null; 

} //synchronized(_theChatRooms) 


j * * 

* This utility method finds the Participant object in the hashmap 
by its name. 

* @param name a String specifying the Participant.name sought 

* @return the sought Participant object, or null if not present 
*/ 

private aParticipant 
SeekParticipantByName(String name) 

{ 

aPart icipant _Part icipant ,- 
synchronized(_theParticipants) 

{ 

for (Iterator i = _theParticipants .entrySet (). iterator () ,- 
i .hasNext () ,-) 


_Participant = 

(aPart icipant) ( (j ava .util .Map . Entry) i .next () ) . getValue () ,- 

if (_Participant.name.toString().equals(name)) return 
_Participant ,- 

} //for 
return null; 

} //synchronized(_theParticipants) 


1062 


DRDC Valcartier TR 2007-412 



* * 


* This utility method finds the Participant object in the hashmap 
by its user_handle. 

* @param user_handle an int specifying the Participant.user_handle 
sought 

* @return the sought Participant object, or null if not present 
*/ 

private aParticipant 

SeekParticipantByUserHandle(int user_handle) 

{ 

aParticipant _Participant; 
synchronized(_theParticipants) 

{ 

for (Iterator i = _theParticipants.entrySet().iterator() ; 
i.hasNext();) 


_Participant = 

(aParticipant) ((j ava.util.Map.Entry)i.next()) .getValue() ; 

if (_Participant.user_handle.getValue() == user_handle) 
return -Participant; 

} //for 

return null; 

} //synchronized(_theParticipants) 


j * * 

* This utility method provides the missing toByteArray method of 
Obj ectlnstanceHandle. 

* @param o the ObjectlnstanceHandle to encode 

* @return the byte[] representation of the ObjectlnstanceHandle 

* @throws CouldNotDecode if something goes wrong 
*/ 

private byte [] 

Obj ectInstanceHandleToByteArray(Obj ectlnstanceHandle o) 
throws CouldNotDecode 

{ 

byte[] b = new byte[o.encodedLength()]; 
o.encode(b, 0); 
return b; 


DRDC Valcartier TR 2007-412 


1063 



* * 


* This utility method converts an ObjectlnstanceHandle into an 
integer (HLAinteger32BE). 

* This could break with later implementations of the RTI, should 
it switch to 64-bit handles. 

* @param o the ObjectlnstanceHandle to convert 

* @return the int representation of the ObjectlnstanceHandle 

* @throws CouldNotDecode if something goes wrong 
*/ 

j * * 

private int 

Obj ectInstanceHandleToInt(Obj ectlnstanceHandle o) 
throws CouldNotDecode 

{ 

//ObjectlnstanceHandle has an encodedLength of 4 
final byte[] bytes = new byte[o.encodedLength() ] ; 
o.encode(bytes, 0); 

return new HLAinteger32BE(bytes).getValueO; 


*/ 

private void 

waitFor(Object theSemaphore) 

{ 

//This runs in the event-handling thread ("AWT-EventQueue-0") 
because it is called from it 
try { 

synchronized(theSemaphore) 

{ 

theSemaphore.wait () ; 

} //synchronized(theSemaphore) 

} catch (InterruptedException ignored) { 

} //try 


j * * 

* A simple class whose only purpose is to act as a semaphore 

* between Threads and carry a boolean payload (initially false). 
*/ 

public class 
Semaphore 

extends Object 

public boolean 
value = false; 

private int 
count; 
j * * 

* Default constructor 

*/ 

public 
Semaphore () 

{ 

this (0) ; 



1064 


DRDC Valcartier TR 2007-412 



j k k 

* Constructs a Semaphore of the specified initial count. 

* @param count an int specifying the Semaphore's initial count 
*/ 

public 

Semaphore(int theCount) 

{ 

count = theCount; 


j k k 

* Whether the count has reached zero or not. 

* @return a boolean indicating whether the count has reached 
zero or not 

*/ 

public boolean 
zero () 

{ 

return (count == 0); 


j k k 

* Decreases the Semaphore's 

* The count cannot decrease 
*/ 

public void 
decreaseCount() 

{ 

decreaseCount(1); 


j k k 

* Decreases the Semaphore's count by the specified amount. 

* The count cannot decrease below zero. 

* @param amount an int to decrease the count by 
*/ 

public void 

decreaseCount(int amount) 

{ 

if (count > amount) 

{ 

count -= amount; 

} else { 

count = 0; 

} //if 


j k k 

* Increases the Semaphore's count by one. 
*/ 

public void 
increaseCount() 

{ 

increaseCount(1); 


count by one. 
below zero. 


DRDC Valcartier TR 2007-412 


1065 



Increases the Semaphore's count by the specified amount. 
@param amount an int to increase the count by 


*/ 

public void 

increaseCount (int amount) 

{ 

count += amount; 


// FederateAmbassador implementation bits // 


//These are all called from the Federate Service Thread 
service thread") 

//Name Reservation 

j * * 

* Used with ChatRoomRegistry and Participant. 

* Note that we do not admit a null Semaphore. 

*/ 

public class 

MyNameReservationListener 

extends FedAmbNameReservationListener 

{ 

private Semaphore whichSemaphore; 

//Constructor 
public 

MyNameReservationListener (Semaphore aSemaphore) 

{ 

whichSemaphore = aSemaphore; 


protected void 
doReservation( 

String obj ectName, 
boolean succeeded) 
throws UnknownName, 

FederatelnternalError 

{ 

synchronized(whichSemaphore) 

{ 

whichSemaphore.value = succeeded; 
whichSemaphore.notify(); 

} //synchronized(whichSemaphore) 

} //method doReservation 
} //class MyNameReservationListener 


("Federate 


1066 


DRDC Valcartier TR 2007-412 



//Interactions 


public class 

MyCommunicationlnteractionListener 
extends FedAmbInteractionListener 

{ 

protected void 
dolnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle 
RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederatelnternalError 


try { 

final HLAunicodeString _message = new HLAunicodeString () ,- 
final HLAunicodeString _sender = new HLAunicodeString () ,- 
for (Iterator i = theParameters . keyset (). iterator () ,- 
i . hasNext () ,- ) 


ParameterHandle _parameterHandle = 
(ParameterHandle) i . next () ,- 
if 

(_parameterHandle.equals(_iph_Communication_message)) 


_message .decode ( (byte [] ) theParameters . get (_parameterHandle) ) ,- 
// _message = new 

String ( (byte [ ] ) _theParameters . get (_parameterHandle) ) ,- 
} else if 

(_parameterHandle.equals(_iph_Communication_sender)) { 

_sender . decode ( (byte [ ] ) theParameters . get (_parameterHandle) ) ,- 
// _sender = new 

String ( (byte [ ] ) _theParameters . get (_parameterHandle) ) ,- 

} //if 

} //for 

SwingUtilities.invokeLater(new Runnable() { public void 

run() { 

txtArea. append (_sender . toString (). substring (1) + " : 11 + 
_message + "\n"); 

} } ) ,- //Runnable 
} catch (CouldNotDecode e) { 
e . print St ackTr ace () ,- 
} finally { 

} //try 

} //method dolnteraction 
} //class MyCommunicationlnteractionListener 


DRDC Valcartier TR 2007-412 


1067 



//Discovery and Removal 


public class 

MyChatRoomRegistryDiscoveryListener 
extends FedAmbDiscoveryListener 

{ 

private Semaphore whichSemaphore,- 

//Constructor 
public 

MyChatRoomRegistryDiscoveryListener(Semaphore theSemaphore) 

{ 

whichSemaphore = theSemaphore,- 


public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederatelnternalError 

{ 

try { 

if (ltheObj ectClass.equals(_och_ChatRoomRegistry)) throw 
new ObjectClassNotRecognized("Unexpected object class"),- 

if (_ChatRoomRegistry.handle != null) throw new 
CouldNotDiscover("ChatRoomRegistry already discovered"),- 
if (!_ChatRoomRegistry.subscribed) throw new 
FederatelnternalError("ChatRoomRegistry not subscribed") ,- 

//Assuming AutoProvide, this'll be immediately followed by 
an Update, so we cannot thread off 

_ChatRoomRegistry. handle = theObj ect; 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore.value = true; 
whichSemaphore . not ify () ,- 
} //synchronized(whichSemaphore) 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method discoverObjectlnstance 
} //class MyChatRoomRegistryDiscoveryListener 


1068 


DRDC Valcartier TR 2007-412 



public class 

MyChatRoomDiscoveryListener 

extends FedAmbDiscoveryListener 

{ 

private Semaphore whichSemaphore,- 

//Constructor 

public 

MyChatRoomDiscoveryListener(Semaphore theSemaphore) 

{ 

whichSemaphore = theSemaphore,- 


public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 
FederatelnternalError 


try { 

if (ltheObj ectClass.equals(_och_ChatRoom)) throw new 
ObjectClassNotRecognized("Unexpected object class"),- 

//Assuming AutoProvide, this'll be immediately followed by 
an Update, so we cannot thread off 

synchronized(_theChatRooms) 

{ 

aChatRoom _ChatRoom,- 

if (objectName.equals(_name_waiting_room_ChatRoom)) 

{ 

_ChatRoom = _wait ing_room_ChatRoom,- 
} else { 

_ChatRoom = new aChatRoom("unknown", (short)-1); 

} //if 

_ChatRoom. handle = theObj ect ,- 
_ChatRoom.subscribed = true; 

// _ChatRoom.name and slot will come from Update,- we must 

wait until then before updating the GUI 

_theChatRooms . put (theObject, _ChatRoom) ,- 
if (whichSemaphore == null) return,- 
} //synchronized(_theChatRooms) 
synchronized(whichSemaphore) 

{ 

whichSemaphore.value = true; 
whichSemaphore . not ify () ,- 
} //synchronized(whichSemaphore) 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method discoverObjectlnstance 
} //class MyChatRoomDiscoveryListener 


DRDC Valcartier TR 2007-412 


1069 



public class 

MyChatRoomRemovalResponder 

extends FedAmbRemovalResponder 


protected void 
doRemove( 

Obj ectlnstanceHandle 
byte [] 

OrderType 
LogicalTime 
OrderType 

MessageRetractionHandle retractionHandle 
throws Obj ectlnstanceNotKnown, 
InvalidLogicalTime, 
FederatelnternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 


try { 

final aChatRoom _ChatRoom = 

(aChatRoom)_theChatRooms.remove(theObj ect) ; 

if (_ChatRoom == null) throw new 
ObjectlnstanceNotKnown("Unexpected object instance"); 
if 

(_ChatRoom.name.toString().equals(_name_general_ChatRoom)) return; 

SwingUtilities.invokeLater(new Runnable() { public void 

run () { 

//Strip leading character 
String theChatRoomName = 

_ChatRoom.name.toString().substring(1); 

IstChatRooms.removeltem(theChatRoomName); 

} } ); //Runnable 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method doRemove 
} //class MyChatRoomRemovalResponder 

public class 

MyPartIcipantDiscoveryListener 

extends FedAmbDiscoveryListener 

{ 

private Semaphore 
whichSemaphore; 
private String 
whichName; 

//Constructor 
public 

MyParticipantDiscoveryListener(Semaphore aSemaphore, String 
anObj ectName) 

{ 

whichSemaphore = aSemaphore; 
whichName = anObjectName; 


1070 


DRDC Valcartier TR 2007-412 



public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederatelnternalError 

{ 

try { 

if (ltheObjectClass.equals(_och_Participant)) throw new 
ObjectClassNotRecognized("Unexpected object class"),- 

//Because the discovery is immediately followed by the 
firing of an InScope advisory, we cannot thread off 

//Maintain list of Participants (within the current 

ChatRoom) 

try { 


DRDC Valcartier TR 2007-412 


1071 



synchronized(_theParticipants) 


aParticipant _Participant = new aParticipant () ,- 
_Participant.subscribed = true; 

// _Participant.inscope = false; //Default; the InScope 

advisory will follow discovery in any case 

_Participant.handle = theObject; 


_Participant.name.setValue(_rtiAmbassador.getObjectInstanceName(theObj 
ect) ) ; 

_Participant.name.setValue(obj ectName),- 
_theParticipants.put(theObject, _Participant),- 
if (_me_shutting_down) return; 

//We use the Auto-Provide switch, so an explicit 
Update request is not needed 

//We could add the discovered Participant's name to 
IstSendTo right away, 

//but we need to know in which ChatRoom slot it 
resides, so we must wait for the InScope advisory 

//(because we subscribe to two regions at any given 
time, we can discover instances in either one) 

//Unfortunately, even with ConveyRegionDesignators 
set to true, this does not happen with the Discovery call 
if (whichSemaphore == null) return,- 

//toString required because whichName is String but 
_Participant.name is HLAunicodeString 

if (lwhichName.equals(_Participant.name.toString())) 

return; 

} //synchronized(_theParticipants) 

} finally { 

} //try 

synchronized(whichSemaphore) 

{ 

whichSemaphore.value = true; 
whichSemaphore . not ify () ,- 
} //synchronized(whichSemaphore) 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method discoverObjectlnstance 
} //class MyParticipantDiscoveryListener 

//Ownership 


public class 

MyChatRoomRegistryOwnershipListener 
extends FedAmbOwnershipListener 

{ 

private Semaphore whichSemaphore,- 

//Constructor 
public 

MyChatRoomRegistryOwnershipListener(Semaphore aSemaphore) 

{ 

whichSemaphore = aSemaphore,- 


1072 


DRDC Valcartier TR 2007-412 



public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeNotPublished, 
FederatelnternalError 


try { 

//Decline if we're in the process of shutting down (and 
thus divesting) 

if (_me_shutting_down) return; 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
Obj ectlnstanceNotKnown ("Unexpected ChatRoomRegistry handle") ,- 
if 

(lofferedAttributes.containsAll(_oahs_ChatRoomRegistry)) throw new 
AttributeNotRecognized ("Unexpected attribute set offered") ,- 
if (_ChatRoomRegistry.owned) throw new 
AttributeAlreadyOwned ("ChatRoomRegistry already owned") ,- 
//Acquiesce if able 

//This condition is similar to !_me_logged_in but better 
if (!_ChatRoomRegistry. subscribed) return,- //If not 
subscribed, probably not up to date --decline 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

try { 

//Note that the divesting federate will have offered 
ownership to all federates, and that even if they all acquiesce, 

//only one will receive an 
ownershipAcquisitionNotification,- if we use 
attributeOwnershipAcquisition, there won't be any 

//negative feedback if we fail to get ownership -- 
and we'll have an outstanding acquisition request. 

//This is why it is preferable to use 
attributeOwnershipAcquisitionlfAvailable 

_rtiAmbassador.attributeOwnershipAcquisitionlfAvaliable(_ChatRoomRegis 
try .handle, _oahs_ChatRoomRegistry) ,- 

} catch(Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestAttributeOwnershipAssumption 


DRDC Valcartier TR 2007-412 


1073 



public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested 
FederatelnternalError 


try { 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
ObjectlnstanceNotKnown("Unexpected ChatRoomRegistry handle"),- 
if 

(lofferedAttributes.containsAll(_oahs_ChatRoomRegistry)) throw new 
AttributeNotRecognized("Unexpected attribute set being divested"),- 
if (!_ChatRoomRegistry.owned) throw new 
AttributeNotOwned("ChatRoomRegistry not owned"),- 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

try { 

synchronized(_ChatRoomRegistry) 


rtiAmbassador.confirmDivestiture(_ChatRoomRegistry.handle, 
oahs_ChatRoomRegistry, null) ,- 

_ChatRoomRegistry.owned = 

ChatRoomRegistry.divesting = false; 

} //synchronized(_ChatRoomRegistry) 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore .value = true,- //that would be 

sem_divestiture 

whichSemaphore . not ify () ,- 
} //synchronized(whichSemaphore) 

} catch(Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestDivestitureConfirmation 


1074 


DRDC Valcartier TR 2007-412 



public void 

attributeOwnershipAcquisitionNotification( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 
AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError 

{ 

try { 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
Obj ectlnstanceNotKnown ("Unexpected ChatRoomRegistry handle") ,- 
if 

(lsecuredAttributes.containsAll(_oahs_ChatRoomRegistry)) throw new 
AttributeNotRecognized ("Unexpected attribute set secured") ,- 
if (_ChatRoomRegistry.owned) throw new 
AttributeAlreadyOwned ("ChatRoomRegistry already owned") ,- 
if (!_ChatRoomRegistry.subscribed) throw new 
AttributeAcquisitIonWasNotRequested("ChatRoomRegistry not 
subscribed") ,- 

//This completes the ownership transfer process 

synchronized(_ChatRoomRegistry) 

{ 

_ChatRoomRegistry.owned = true || 

(_ChatRoomRegistry. divesting = _me_shutting_down) ,- 
} //synchronized(_ChatRoomRegistry) 
if (whichSemaphore l= null) 

{ 

synchronized(whichSemaphore) 

{ 

whichSemaphore .value = true,- //that would be 

_sem_acquisition 

whichSemaphore . not ify () ,- 
} //synchronized(whichSemaphore) 

} //if 

//Just in case we somehow managed to acquire whilst 
switching to shutting down mode 

if (_me_shutting_down) 

{ 

new Thread() { public void run() { 

try { 

divestChatRoomRegistry () ,- 
} catch (Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 

} //if 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method attributeOwnershipAcquisitionNotifloation 


DRDC Valcartier TR 2007-412 


1075 



public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeAcquisitionWasNotRequested 
FederatelnternalError 


try { 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
ObjectlnstanceNotKnown("Unexpected ChatRoomRegistry handle"),- 

if (ltheAttributes.containsAll(_oahs_ChatRoomRegistry)) 
throw new AttributeNotRecognized("Unexpected attribute set turned 
down") ; 

if (_ChatRoomRegistry.owned) throw new 
AttributeAlreadyOwned("ChatRoomRegistry already owned"),- 
if (!_ChatRoomRegistry.subscribed) throw new 
AttributeAcquisitionWasNotRequested("ChatRoomRegistry not 
subscribed"),- 


if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore.value = false; //that would be 
sem_acquisition 

whichSemaphore.notify(),- 
} //synchronized(whichSemaphore) 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method attributeOwnershipUnavailable 
public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet candidateAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 


try { 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
Obj ectlnstanceNotKnown ("Unexpected ChatRoomRegistry handle") ,- 
if 

(lcandidateAttributes.containsAll(_oahs_ChatRoomRegistry)) throw new 
AttributeNotRecognized ("Unexpected attribute set requested") ,- 
if (!_ChatRoomRegistry.owned) throw new 
AttributeNotOwned (" ChatRoomRegistry not owned") ,- 
// if (!_ChatRoomRegistry.subscribed) throw new 

FederatelnternalError (" ChatRoomRegistry not subscribed") ,- 
//Acquiesce 


1076 


DRDC Valcartier TR 2007-412 



//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run () { 

try { 

//If we're currently busy with the ChatRoomRegistry, 
//we'll be synchronized on it and this thread will 
//have to wait 

synchronized(_ChatRoomRegistry) 

{ 

if 

(!_oahs_ChatRoomRegistry.containsAll(_rtiAmbassador.attributeOwnership 
DivestiturelfWanted(_ChatRoomRegistry.handle, 

_oahs_ChatRoomRegistry))) return; 

_ChatRoomRegistry.owned = 

_ChatRoomRegistry.divesting = false; 

} //synchronized(_ChatRoomRegistry) 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore.value = true; //that would be 

_sem_divestiture 

whichSemaphore.notify(); 

} //synchronized(whichSemaphore) 

} catch(Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestAttributeOwnershipRelease 


DRDC Valcartier TR 2007-412 


1077 



public void 

confIrmAttributeOwnershipAcquisitionCancellation( 
Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 
FederatelnternalError 


if (_ChatRoomRegistry.handle l= theObject) throw new 
ObjectlnstanceNotKnown("Unknown ChatRoomRegistry offered"),- 

if (ltheAttributes.containsAll(_oahs_ChatRoomRegistry)) throw 
new AttributeNotRecognized("Unexpected attribute set cancelled"); 

if (_ChatRoomRegistry.owned) throw new 
AttributeAlreadyOwned("ChatRoomRegistry already owned"),- 

throw new AttributeAcquisitionWasNotCanceled("I don't think 

so. . .") ; 

} //method confIrmAttributeOwnershipAcquisitionCancellation 

/ * * 


public void 
dolnformOwnership( 

final Obj ectlnstanceHandle 
final AttributeHandle 
final boolean 
final boolean 
final FederateHandle 
throws Obj ectlnstanceNotKnown 
AttributeNotRecognized 
FederatelnternalError 


theObj ect, 

theAttribute 

isUnowned, 

IsOwnedByRTI 

theOwner) 


*/ 


} //method dolnformOwnership 
//class MyChatRoomRegistryOwnershipListener 


public class 

MyChatRoomOwnershipListener 

extends FedAmbOwnershipListener 


private Semaphore whichSemaphore,- 

private Obj ectlnstanceHandle whichObj ect,- 

//The Semaphore and ObjectlnstanceHandle serve two purposes: 

// - In Acquisition mode, Semaphore.value will be set once an 
acquisitionNotification or 

// Unavailable callback is received for the 

ObjectlnstanceHandle, and then the Semaphore is notified. 

// - In Divestiture mode, each requestDivestitureConfirmation 
and requestAttributeOwnershipRelease 

// results in a Semaphore . decreaseCount,- once Semaphore . zero () 

is true, it is notified. 


1078 


DRDC Valcartier TR 2007-412 



//Constructor 

public 

MyChatRoomOwnershipListener(Semaphore aSemaphore 
ObjectInstanceHandle anObj ect) 

{ 

whichSemaphore = aSemaphore; 
whichObject = anObject; 


DRDC Valcartier TR 2007-412 


1079 



public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeNotPublished, 
FederatelnternalError 


try { 

//Decline if we're in the process of shutting down (and 
thus divesting) 

if (_me_shutting_down) return; 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
ObjectlnstanceNotKnown("Unknown ChatRoom offered"),- 

if (lofferedAttributes.containsAll(_oahs_ChatRoom)) throw 
new AttributeNotRecognized("Unexpected attribute set offered"); 

if (_ChatRoom.owned) throw new 
AttributeAlreadyOwned("ChatRoom already owned"),- 
//Also decline if: 

//We're not subscribed, thus the values are probably not 
up to date; or 

//We're logged out and the ChatRoom slot is other than the 

waiting_room 

if ((!_ChatRoom.subscribed) || ((!_me_logged_in) && 

(_ChatRoom.slot.getValue() l= _slot_waiting_room_ChatRoom))) return; 

//Either we're logged in, and/or the chat room is the 
waiting room; 

//If not the waiting room, accept only if its our current 

chat room 

if ((_ChatRoom.slot.getValue() != 

_slot_waiting_room_ChatRoom) && 

(!_ChatRoom. slot. equals (_myChatRoom. slot) ) ) return,- 


Concurrent 


date) 


//If not threaded off, this throws RTIinternalError: 
access attempted to cmethod name> 
new Thread() { public void run() { 

try { 

//Accept only if subscribed (and presumably up to 


_rtiAmbassador.attributeOwnershipAcquisitionlfAvailable(_ChatRoom.hand 
le, _oahs_ChatRoom) ,- //or theObject 

} catch(Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestAttributeOwnershipAssumption 


1080 


DRDC Valcartier TR 2007-412 



public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested 

FederatelnternalError 


try { 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
Obj ectlnstanceNotKnown ("Unknown ChatRoom offered") ,- 

if (lofferedAttributes.containsAll(_oahs_ChatRoom)) throw 
new AttributeNotRecognized ("Unexpected attribute set requested") ,- 
if (!_ChatRoom.owned) throw new 
AttributeNotOwned (" ChatRoom not owned"),- 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

try { 

//Confirm 

synchronized(_ChatRoom) 


_rtiAmbassador.confirmDivestiture(_ChatRoom.handle, _oahs_ChatRoom, 
null) ,- 

_ChatRoom.owned = _ChatRoom.divesting = false; 
} //synchronized(_ChatRoom) 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore . decreaseCount () ,- 
if (whichSemaphore.zero ()) { 

whichSemaphore . not ify () ,- } 

} //synchronized(whichSemaphore) 

} catch(Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestDivestitureConfirmation 


DRDC Valcartier TR 2007-412 


1081 



public void 

attributeOwnershipAcquisitionNotification( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 
AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError 

{ 

try { 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
ObjectlnstanceNotKnown("Unknown ChatRoom offered"),- 

if (lsecuredAttributes.containsAll(_oahs_ChatRoom)) throw 
new AttributeNotRecognized("Unexpected attribute set acquired"); 

if (_ChatRoom.owned) throw new 
AttributeAlreadyOwned("ChatRoom already owned"),- 

synchronized(_ChatRoom) 

{ 

_ChatRoom.owned = l(_ChatRoom.divesting = false); 

} //synchronized(_ChatRoom) 
if (whichSemaphore != null) 

{ 

synchronized(whichSemaphore) 

{ 

whichSemaphore.value = 

(_ChatRoom.handle.equals(whichObj ect)),- 

if (whichSemaphore.value) whichSemaphore.notify(),- 
} //synchronized(whichSemaphore) 

} //if 

//Just in case we somehow managed to acquire whilst 
switching to shutting down mode 

if (_me_shutting_down) 

{ 

new Thread() { public void run() { 

try { 

divestChatRooms (),- 
} catch (Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 

} //if 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method attributeOwnershipAcquisitionNotification 


1082 


DRDC Valcartier TR 2007-412 



public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeAcquisitionWasNotRequested 
FederatelnternalError 


try { 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
Obj ectlnstanceNotKnown ("Unknown ChatRoom offered") ,- 

if (ltheAttributes.containsAll(_oahs_ChatRoom)) throw new 
AttributeNotRecognized ("Unexpected attribute set denied") ,- 
if (_ChatRoom.owned) throw new 
AttributeAlreadyOwned ("ChatRoom already owned") ,- 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore.value = false; 
if (_ChatRoom.handle.equals(whichObject)) 
whichSemaphore . not ify () ,- 

} //synchronized(whichSemaphore) 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method attributeOwnershipUnavailable 


DRDC Valcartier TR 2007-412 


1083 



public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet candidateAttributes 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try { 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
ObjectlnstanceNotKnown("Unknown ChatRoom offered"),- 

if (lcandidateAttributes.containsAll(_oahs_ChatRoom)) 
throw new AttributeNotRecognized("Unexpected attribute set 
requested"),- 

if (!_ChatRoom.owned) throw new 
AttributeNotOwned("ChatRoom not owned"),- 
//Acquiesce 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

try { 
if 

(!_oahs_ChatRoom.containsAll(_rtiAmbassador.attributeOwnershipDivestit 
urelfWanted(_ChatRoom.handle, _oahs_ChatRoom))) return; 

//Successl 

synchronized(_ChatRoom) 

{ 

_ChatRoom.owned = _ChatRoom.divesting = false; 

} //synchronized(_ChatRoom) 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore . decreaseCount () ,- 
if (whichSemaphore.zero()) { 

whichSemaphore. not ify () ,- } 

} //synchronized(whichSemaphore) 

} catch (RTIexception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestAttributeOwnershipRelease 


1084 


DRDC Valcartier TR 2007-412 



public void 

confIrmAttributeOwnershipAcquisitionCancellation( 
Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 
FederatelnternalError 


final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
Obj ectlnstanceNotKnown ("Unknown ChatRoom offered") ,- 

if (ltheAttributes.containsAll(_oahs_ChatRoom)) throw new 
AttributeNotRecognized ("Unexpected attribute set cancelled") ,- 
if (_ChatRoom.owned) throw new 
AttributeAlreadyOwned ("ChatRoom already owned") ,- 

throw new AttributeAcquisitionWasNotCanceled("I don't think 

so. . .") ; 

} //method confIrmAttributeOwnershipAcquisitionCancellation 

/ * * 


public void 
dolnformOwnership( 

final Obj ectlnstanceHandle 
final AttributeHandle 
final boolean 
final boolean 
final FederateHandle 
throws Obj ectlnstanceNotKnown 
AttributeNotRecognized 
FederatelnternalError 


theObj ect, 

theAttribute 

isUnowned, 

IsOwnedByRTI 

theOwner) 


*/ 


} //method doInformOwnership 
//class MyChatRoomOwnershipListener 


DRDC Valcartier TR 2007-412 


1085 



public class 

MyParticipantOwnershipListener 

extends FedAmbOwnershipListener 

{ 

private Semaphore whichSemaphore,- 

private Obj ectlnstanceHandle whichObj ect,- 

//The Semaphore and ObjectlnstanceHandle serve two purposes: 

// - In Acquisition mode, Semaphore.value will be set once an 
acquisitionNotification or 

// Unavailable callback is received for the 

ObjectlnstanceHandle, and then the Semaphore is notified. 

// - In Divestiture mode, each requestDivestitureConfirmation 
and requestAttributeOwnershipRelease 

// results in a Semaphore . decreaseCount,- once Semaphore . zero () 

is true, it is notified. 

//Constructor 
public 

MyParticipantOwnershipListener(Semaphore aSemaphore, 

Obj ectlnstanceHandle anObj ect) 

{ 

whichSemaphore = aSemaphore,- 
whichObject = anObject; 

} //method MyParticipantOwnershipListener 


1086 


DRDC Valcartier TR 2007-412 



public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeNotPublished, 
FederatelnternalError 


try { 

//Decline if we're in the process of shutting down (and 
thus divesting) 

if (_me_shutting_down) return; 
final aParticipant _Participant = 

SeekParticipant (theObject) ,- 

if (_Participant == null) throw new 
Obj ectlnstanceNotKnown ("Unknown Participant offered") ,- 

if (lofferedAttributes.containsAll(_oahs_Participant)) 
throw new AttributeNotRecognized ("Unexpected attribute set offered") ,- 
if (_Participant.owned) throw new 
AttributeAlreadyOwned ("Participant already owned") ,- 

//Accept only if subscribed (and presumably up to date) 
//The inscope attribute is similar, but subscribed will do 

just fine 

if (!_Participant. subscribed) return,- //If not subscribed, 
probably not up to date --decline 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

try { 

//Before acquiring, set up update regions so they do 
not lapse during ownership transfer 

synchronized(_Participant) 


_rtiAmbassador.associateRegionsForUpdates(_Participant.handle, 
_asrspl_Participant_nowhere) ,- 

_rtiAmbassador.associateRegionsForUpdates(_Participant.handle, 
_asrspl_Participant_waiting_room) ,- 

} //synchronized(_Participant) 

_rtiAmbassador.attributeOwnershipAcquisitionlfAvaliable(_Participant.h 
andle, _oahs_Participant) ,- //or theObject 

} catch(Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestAttributeOwnershipAssumption 


DRDC Valcartier TR 2007-412 


1087 



public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestitureWasNotRequested 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant(theObject),- 

if (_Participant == null) throw new 
ObjectlnstanceNotKnown("Unknown Participant offered"),- 

if (lofferedAttributes.containsAll(_oahs_Participant)) 
throw new AttributeNotRecognized("Unexpected attribute set 
requested"),- 

if (!_Participant.owned) throw new 
AttributeNotOwned("Participant not owned"),- 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

MyPartIcipantOwnershipListener: requestDivestitureConfirmation thread 
begins") ,- 

try { 

//Confirm 

synchronized(_Participant) 


rtiAmbassador.confirmDivestiture(_Participant.handle, 
oahs_Participant, null) ,- 

_Participant.owned = _Participant.divesting = 


false,- 


} //synchronized(_Participant) 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 


whichSemaphore . decreaseCount () ,- 
if (whichSemaphore.zero()) { 

whichSemaphore. not ify () ,- } 

} //synchronized(whichSemaphore) 

} catch(Exception ignored) { 

} finally { 


} }.start(); //Thread 
} catch (Exception intercepted) { 
} finally { 


} //method requestDivestitureConfirmation 


1088 


DRDC Valcartier TR 2007-412 



public void 

attributeOwnershipAcquisitionNotification( 
Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
AttributeAcquisitionWasNotRequested 
AttributeAlreadyOwned, 
AttributeNotPublished, 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant (theObject) ,- 

if (_Participant == null) throw new 
Obj ectlnstanceNotKnown ("Unknown Participant offered") ,- 

if (lsecuredAttributes.containsAll(_oahs_Participant)) 
throw new AttributeNotRecognized ("Unexpected attribute set acquired") ,- 
if (_Participant.owned) throw new 
AttributeAlreadyOwned ("Participant already owned") ,- 

//Must switch these right away, otherwise a Federate 
Responder could be called before the thread has time to launch 
_Participant.owned = l(_Participant.inscope = 

_Participant.divesting = false); 

//There are two circumstances where we acquire 
Participants: 

//When we want to log in, and when another federate logs 
out and shuts down. 

//In both cases we set up the ForUpdate Regions such that 
the Participant 

//arrives associated with _nowhere and _waiting_room. 

//In the first circumstance, the 
plnHLA_Participant_NameReservation waits on the 

//sem_Participant_acquisition and will move the 
Participant to the _general ChatRoom. 

if (whichSemaphore != null) 

{ 

synchronized(whichSemaphore) 

{ 

whichSemaphore.value = 

(_Part icipant. handle . equals (whichObj ect) ) ,- 

if (whichSemaphore .value) whichSemaphore. notify () ,- 
} //synchronized(whichSemaphore) 

} //if 

//Just in case we somehow managed to acquire whilst 
switching to shutting down mode 

if (!_me_shutting_down) return; 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run () { 

divestParticipants () ,- 
} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method attributeOwnershipAcquisitionNotification 


DRDC Valcartier TR 2007-412 


1089 



public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
AttributeAlreadyOwned, 
AttributeAcquisitionWasNotRequested 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant(theObject),- 

if (_Participant == null) throw new 
ObjectlnstanceNotKnown("Unknown Participant offered"),- 

if (ltheAttributes.containsAll(_oahs_Participant)) throw 
new AttributeNotRecognized("Unexpected attribute set denied"); 

if (_Participant.owned) throw new 
AttributeAlreadyOwned("Participant already owned"),- 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore.value = false,- 
if (_Participant.handle.equals(whichObj ect)) 
whichSemaphore.notify(),- 

} //synchronized(whichSemaphore) 

} catch(Exception intercepted) { 

} finally { 

} //try 

} //method attributeOwnershipUnavailable 


1090 


DRDC Valcartier TR 2007-412 



public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet candidateAttributes 

byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant (theObject) ,- 

if (_Participant == null) throw new 
Obj ectlnstanceNotKnown ("Unknown Participant offered") ,- 

if (lcandidateAttributes.containsAll(_oahs_Participant)) 
throw new AttributeNotRecognized("Unexpected attribute set 
requested") ,- 

if (!_Participant.owned) throw new 
AttributeNotOwned (" Part icipant not owned") ,- 

//If request targets the logged-in _me, refuse (there is 
no RTI call to tell the requester to piss off) 

//Should be just if (_Participant.equals(_me)) since _me 
is just a placeholder 

//Participant object (not in the HLA fed) when the 
federate is not logged in 

if (_me_logged_in && _Participant.equals(_me)) 

{ 

return; 

} //if 


DRDC Valcartier TR 2007-412 


1091 



//Otherwise, acquiesce 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run () { 

try { 
if 

(!_oahs_Participant.containsAll(_rtiAmbassador.attributeOwnershipDives 
titurelfWanted(_Participant.handle, _oahs_Participant))) return; 

//Successl 

synchronized(_Participant) 

{ 

_Participant.owned = _Participant.divesting = 
_Participant.inscope = false; 

//Region associations are automatically lost 

along with ownership 

} //synchronized(_Participant) 
if (whichSemaphore == null) return; 
synchronized(whichSemaphore) 

{ 

whichSemaphore.decreaseCount() ; 
if (whichSemaphore.zero() ) { 

whichSemaphore.notify(); } 

} //synchronized(whichSemaphore) 

} catch (RTIexception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method requestAttributeOwnershipRelease 


1092 


DRDC Valcartier TR 2007-412 



public void 

confIrmAttributeOwnershipAcquisitionCancellation( 
Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant (theObject) ,- 

if (_Participant == null) throw new 
Obj ectlnstanceNotKnown ("Unknown Participant offered") ,- 

if (ltheAttributes.containsAll(_oahs_Participant)) throw 
new AttributeNotRecognized ("Unexpected attribute set cancelled") ,- 
if (_Participant.owned) throw new 
AttributeAlreadyOwned ("Participant already owned") ,- 

throw new AttributeAcquisitionWasNotCanceled("I don't 
think so..."); 

} catch (Exception intercepted) { 

} finally { 


j * * 


} //method confIrmAttributeOwnershipAcquisitionCancellation 


public void 
dolnformOwnership( 

final Obj ectlnstanceHandle 
final AttributeHandle 
final boolean 
final boolean 
final FederateHandle 
throws Obj ectlnstanceNotKnown 
AttributeNotRecognized 
FederatelnternalError 


theObj ect, 

theAttribute 

isUnowned, 

IsOwnedByRTI 

theOwner) 


*/ 


} //method doInformOwnership 
//class MyPartIcipantOwnershipListener 


//Interaction Scope Advisories 
public class 

MyCommunicationAdvisoryResponder 

extends FedAmbInteractIonAdvisoryResponder 


protected void 
doRelevance( 

InteractionClassHandle theHandle 
boolean relevant) 

throws InteractionClassNotPublished 
FederatelnternalError 


_alone = lrelevant; 

} //method doRelevance 
} //class MyCommunicatIonAdvisoryResponder 


DRDC Valcartier TR 2007-412 


1093 



//Attribute Scope Advisories 


public class 

MyPartIcipantAttributeScopeListener 

extends FedAmbAttributeScopeAdvisoryListener 

{ 

j * * 

* Default constructor in use. 

*/ 

protected void 
doScope( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes, 
boolean inScope) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 


try { 

//The Participant has just come into or gone out of scope 
--either we or it has changed ChatRooms (it cannot have been truly 
deleted) 

final aParticipant _Participant = 

SeekParticipant(theObject),- 

if (_Participant == null) throw new 
ObjectlnstanceNotKnown("Unexpected Participant handle"),- 
if 

(ltheAttributes.containsAll(_oahs_Participant_forUpdate)) throw new 
AttributeNotRecognized("Unexpected attribute set provided"),- 
if (!_Participant.subscribed) throw new 
AttributeNotSubscribed("Participant not subscribed"),- 

//If we could localDelete Participants as they go out of 
scope, we would always get 

//a Discovery right before the InScope callback; but we 
can't do that because of the 

//pRTI RTIambassador-Federate Service Thread synch bug 
(putting the Federate Service 

//Thread in any kind of synch-wait state (a Semaphore, 
say) causes a federate-triggering 

//RTIambassador call by *any* thread to hang, even if the 
latter RTIambassador-caller 

//isn't owning any monitors). 

//So we use the inScope property of aParticipant to work 

around it. 

//Note that we get advisories even for owned objects 

_Participant. inscope = inScope,- 

//Strip leading character 

final String theParticipantName = 

_Part icipant. name . toString () . substring (1) ,- 


1094 


DRDC Valcartier TR 2007-412 



if (inScope) 


//Freshly discovered object, or object that went out of 
and back in scope 

//_Participant.subscribed, handle and name are set 
(owned, divesting at default) ,- 

//logged_in and chat_room_slot will have to await the 

update listener 

//A newly discovered _Participant will have a 
chat_room_slot of slot_nowhere_ChatRoom, 

//which is not possible once we get at least one update 
(because no federate ever 

//subscribes to the nowhere ChatRoom) 


ChatRoom 


//Maintain list of Participants (within the current 


final boolean mustAdd = _me_logged_in && 
Participant. chat_room_slot. equals (_me . chat_room_slot) ,- 
if (mustAdd) 


void run 




SwingUtilities.invokeLater(new Runnable() { public 

try { 

//Note that we skip the <All> item 

for (int i = 1; i < IstSendTo . get ItemCount () ,- 


if 

(theParticipantName.compareTo((String)IstSendTo.getItemAt(i)) == 0) 

{ 

//The Participant is already listed 
return; 

} else if 

(theParticipantName.compareTo((String)IstSendTo.getItemAt(i)) < 0) 

{ 

//Previously unknown Participant, who 
sorts before the current one (i) 


IstSendTo . insertltemAt (theParticipantName, i) ,- 

lblStatus.setText(theParticipantName + " 

has j oined. 11 ) ,- 

return; 

} //if 

} //for 

//If we make it through the list, must append 
the previously unknown Participant 

IstSendTo.insertltemAt(theParticipantName, 
IstSendTo.getltemCount()); 

lblStatus . setText (theParticipantName + 11 has 

j oined.") ; 

} finally { 


} } ) ,- //Runnable 
else { 

//if 


DRDC Valcartier TR 2007-412 


1095 



ChatRoom) 


} else { 

//Maintain list of Participants (within the current 

//Because the _Participant will come back into scope 
*before* we get an Update, 

//we'll mark it as "nowhere" so it behaves as a newly 
discovered one should 

//it come back into scope 

final boolean mustAdvise = _me_logged_in && 

_Participant.chat_room_slot.equals(_me.chat_room_slot),- 

_Participant.chat_room_slot.setValue(_slot_nowhere_ChatRoom),- 

SwingUtilities.invokeLater(new Runnable() { public void 

run () { 

if (mustAdvise) lblStatus.setText(theParticipantName 

+ " has left."); 

IstSendTo.removeltem(theParticipantName) ,- 
} } ); //Runnable 

//What we wanted to do here was localDelete the 
_Participant that just went out of scope. 

//We would have had to ask another thread to do this 
RTIambassador call, and we would have 

//had to wait for that other thread to conclude, 
otherwise the _Participant could come back 

//into scope (and trigger this listener again) before 
the other thread had time to localDelete, 

//leading to a situation where the RTI thinks we know 
the _Participant but we've 

//already stricken it off our list... 

//However, the pRTI RTIambassador-Federate Service 
Thread synch bug is such that if we 

//put the Federate Service Thread in any kind of synch- 
wait state (a Semaphore, say), 

//a federate-triggering RTIambassador call by *any* 
thread hangs, even if the latter 

//RTIambassador-caller isn't owning any monitors. 
//Conclusion: We cannot localDelete at all. 

} //if 

} catch (Exception intercepted) { 

} finally { 

} //try 

} //method doScope 

} //class MyParticipantAttributeScopeListener 


1096 


DRDC Valcartier TR 2007-412 



//Attribute Updates (Listen and Respond) 


public class 

MyChatRoomRegistrylnstanceAttributeListener 
extends FedAmblnstanceAttributeListener 

{ 

protected void 
doUpdate( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering 

MessageRetractionHandle retractionHandle 
RegionHandleSet sentRegions) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 
InvalidLogicalTime, 
FederatelnternalError 


try { 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
Obj ectlnstanceNotKnown ("Unexpected ChatRoomRegistry handle") ,- 
if 

(ltheAttributes.keyset().containsAll(_oahs_ChatRoomRegistry_forUpdate) 

) throw new AttributeNotRecognized("Unexpected attribute set 
provided") ,- 

if (_ChatRoomRegistry.owned) throw new 
FederatelnternalError ("ChatRoomRegistry owned") ,- 

if (!_ChatRoomRegistry.subscribed) throw new 
AttributeNotSubscribed (" ChatRoomRegistry not subscribed") ,- 

//HLAprivilegeToDeleteObject has no content, so we won't 

decode it 

_ChatRoomRegistry.list.decode((byte[])theAttributes-get(_oah_ChatRoomR 
egistry_list) ) ,- 

} catch (RTIexception intercepted) { 

} finally { 

} //try 

} //method doUpdate 

} //class MyChatRoomRegistrylnstanceAttributeListener 


DRDC Valcartier TR 2007-412 


1097 



public class 

MyChatRoomlnstanceAttributeListener 

extends FedAmblnstanceAttributeListener 


protected void 
doUpdate( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte [] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 
RegionHandleSet 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
sentRegions) 


throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
At tributeNotSubscribed, 
InvalidLogicalTime, 
FederatelnternalError 


try { 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
ObjectlnstanceNotKnown("Unknown ChatRoom supplied"),- 
if 

(ltheAttributes.keyset().containsAll(_oahs_ChatRoom_forUpdate)) throw 
new AttributeNotRecognized("Unexpected attribute set supplied"); 

if (!_ChatRoom.subscribed) throw new 
AttributeNotSubscribed("ChatRoom not subscribed"),- 

//No need to thread off since no RTI calls 
synchronized(_ChatRoom) 

{ 

//Name is a true attribute, not the object's HLA name 
_ChatRoom.name.decode((byte[])theAttributes.get(_oah_ChatRoom_name)),- 


ChatRoom.slot.decode((byte[])theAttributes.get(_oah_ChatRoom_slot)),- 
//Alternately, we could load the IstChatRooms at log-in 


time. . . 


if 

((_ChatRoom.name.toString () .equals(_name_general_ChatRoom)) | | 

(_ChatRoom.name.toString().equals(_name_waiting_room_ChatRoom))) 
return; 

final String theChatRoomName = 

_ChatRoom.name. toString () .substring (1) ,- 


1098 


DRDC Valcartier TR 2007-412 



SwingUtilities.invokeLater(new Runnable() { public void 

run() { 

//Note that we skip the <General> item 

for (int i = 1; i < IstChatRooms.getltemCount() ; 

i + +) 


//If already listed, done 
if 

(theChatRoomName.compareTo((String)IstChatRooms.getItemAt(i)) == 0) 
return; 

//Point of insertion found 
if 

(theChatRoomName.compareTo((String)IstChatRooms.getItemAt(i)) < 0) 


IstChatRooms.insertltemAt(theChatRoomName 
return; 


} //if 

} //for 

//List scanned without finding insertion point: 

append 


IstChatRooms.insertltemAt(theChatRoomName 
IstChatRooms.getltemCount()); 

} } ); //Runnable 
} //synchronized(_ChatRoom) 

} catch (RTIexception intercepted) { 

} finally { 


i) ; 


} //method doUpdate 

} //class MyChatRoomlnstanceAttributeListener 


DRDC Valcartier TR 2007-412 


1099 



public class 

MyParticipantInstanceAttributeListener 

extends FedAmblnstanceAttributeListener 


protected void 
doUpdate( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte [] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 
RegionHandleSet 


theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
sentRegions) 


throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
At tributeNotSubscribed, 
InvalidLogicalTime, 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant(theObject); 

if (_Participant == null) throw new 
ObjectlnstanceNotKnown("Unknown Participant supplied"); 
if 

(ltheAttributes.keyset().containsAll(_oahs_Participant_forUpdate)) 
throw new AttributeNotRecognized("Unexpected attribute set supplied"); 

if (!_Participant.subscribed) throw new 
AttributeNotSubscribed("Participant not subscribed"); 

//Does this need to be threaded off? 
synchronized(_Participant) 


1100 


DRDC Valcartier TR 2007-412 



//Name updated at Discovery time 

// 

_Participant.name.setValue(_rtiAmbassador.getObjectInstanceName(_theOb 
j ect) ) ; 

_Participant.logged_in.decode( 

(byte[])theAttributes-get(_oah_Participant_logged_in)),- 
_Participant.user_handle.decode( 

(byte[])theAttributes-get(_oah_Participant_user_handle)),- 

_Participant.chat_room_slot.decode((byte[])theAttributes.get(_oah_Part 
icipant_chat_room_slot)),- 

//Ideally, it would make more sense to maintain 
IstSendTo on the Scope Advisory callbacks; 

//however, when those first occur, we do not know the 
Participant's attributes yet, so we can't 

//tell between those in the "waiting_room" and those in 

our ChatRoom. 

//When a Participant logs out (from our ChatRoom), it 
moves from a given ChatRoom to the 

//"waiting_room" by first withdrawing to "nowhere", so 
it will trigger Scope Advisories 

//twice (since we subscribe to "waiting_room" and our 
current ChatRoom at all times). 

// if (_me_logged_in && 

(_Participant.chat_room_slot.getValue() J= 0)) 

// if (!_me_logged_in) return; 

final String theParticipantName = 

_Part icipant. name . toString () . substring (1) ,- 

//When logged out, _me.chat_room_slot would be 
waiting_room, so we don't want to add those 

final boolean mustAdd = _me_logged_in && 

_Part icipant. chat_room_slot. equals (_me . chat_room_slot) ,- 


DRDC Valcartier TR 2007-412 


1101 



run () 


SwingUtilities.invokeLater(new Runnable() { public void 


try { 

//Note that we skip the <All> item 

for (int 1=1; i < IstSendTo. get I temCount () ,- 


if 

(theParticipantName.compareTo((String)IstSendTo.getItemAt(i)) == 0) 


//The Participant is already listed 
if (mustAdd) return; 

IstSendTo.remove(i); 
if (_me_logged_in) 

lblStatus.setText(theParticipantName + " has left."); 

return; 

} else if 

(theParticipantName.compareTo((String)IstSendTo.getItemAt(i)) < 0) 


before the current one 


i) ; 

has j oined.") ; 


//Previously unknown Participant, who sorts 
if (imustAdd) return; 

IstSendTo.insertItemAt(theParticipantName, 
lblStatus.setText(theParticipantName + " 


return; 


} //if 

} //for 

if (ImustAdd) return,- 

//If we make it through the list, must append 
previously unknown Participant 

IstSendTo.insertItemAt(theParticipantName, 
IstSendTo.getItemCount()); 

lblStatus.setText(theParticipantName + " has 


j oined.") ,- 


} finally { 


the 


} } ),- //Runnable 
} //synchronized(_Participant) 

} catch (RTIexception intercepted) { 
} finally { 


} //method doUpdate 

} //class MyParticipantlnstanceAttributeListener 


1102 


DRDC Valcartier TR 2007-412 



public class 

MyChatRoomRegistrylnstanceAttributeResponder 
extends FedAmblnstanceAttributeResponder 

{ 

public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try { 

if (ltheObj ect.equals(_ChatRoomRegistry.handle)) throw new 
Obj ectlnstanceNotKnown ("Unexpected ChatRoomRegistry handle") ,- 
if 

(ltheAttributes.containsAll(_oahs_ChatRoomRegistry_forUpdate)) throw 
new AttributeNotRecognized ("Unexpected attribute set requested") ,- 
if (!_ChatRoomRegistry.owned) throw new 
AttributeNotOwned ("ChatRoomRegistry not owned") ,- 
// if (!_ChatRoomRegistry.subscribed) throw new 

FederatelnternalError ("ChatRoomRegistry not subscribed") ,- 

//If not threaded off, this throws RTIinternalError: 
Concurrent access attempted to cmethod name> 

new Thread() { public void run() { 

try { 

synchronized(_ChatRoomRegistry) 

{ 

final AttributeHandleValueMap 
_ahvm_attributeValues = 

_rtiAmbassador.getAttributeHandleValueMapFactory().create(_oahs_ChatRo 
omRegistry_forUpdate. size () ) ,- 

// 

_ahvm_attributeValues.put(_oah_ChatRoomRegistry_DeletePrivilege, 
null); //HLAprivilegeToDeleteObject is of undefined type (it has no 
content) 

_ahvm_attributeValues.put(_oah_ChatRoomRegistry_list, 

_ChatRoomRegistry. list. toByteArray () ) ,- 

_rtiAmbassador.updateAttributeValues(_ChatRoomRegistry.handle, 
_ahvm_attributeValues, null) ,- 

} //synchronized(_ChatRoomRegistry) 

} catch (Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method provideAttributeValueUpdate 
} //class MyChatRoomRegistrylnstanceAttributeResponder 


DRDC Valcartier TR 2007-412 


1103 



public class 

MyChatRoomlnstanceAttributeResponder 

extends FedAmblnstanceAttributeResponder 

{ 

public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

try { 

final aChatRoom _ChatRoom = SeekChatRoom (theObj ect) ,- 
if (_ChatRoom == null) throw new 
Obj ect InstanceNotKnown (" ChatRoom instance not known' 1 ) ,- 

if (ltheAttributes.containsAll(_oahs_ChatRoom_forUpdate)) 
throw new AttributeNotRecognized("Unexpected attribute set 
requested"),- 

if (!_ChatRoom.owned) throw new 
AttributeNotOwned("Requested ChatRoom not owned"); 

new Thread() { public void run() { 

try { 

synchronized(_ChatRoom) 

{ 

final AttributeHandleValueMap 
_ahvm_attributeValues = 

_rtiAmbassador.getAttributeHandleValueMapFactory().create(_oahs_ChatRo 
om_forUpdate .size()); 

_ahvm_attributeValues.put(_oah_ChatRoom_name, 
_ChatRoom.name.toByteArray()),- 

_ahvm_attributeValues.put(_oah_ChatRoom_slot, 
_ChatRoom.slot.toByteArray()); 

//If not threaded off, this throws 
RTIinternalError: Concurrent access attempted to cmethod name> 

_rtiAmbassador.updateAttributeValues(_ChatRoom.handle, 
_ahvm_attributeValues, null) ,- 

} //synchronized(_ChatRoom) 

} catch (Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method provideAttributeValueUpdate 
} //class MyChatRoomlnstanceAttributeResponder 


1104 


DRDC Valcartier TR 2007-412 



public class 

MyPartIcipantlnstanceAttributeResponder 

extends FedAmblnstanceAttributeResponder 

{ 

public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 
FederatelnternalError 


try { 

final aParticipant _Participant = 

SeekParticipant (theObject) ,- 

if (_Participant == null) throw new 
Ob j ect InstanceNotKnown (" Participant instance not known' 1 ) ,- 
if 

(ltheAttributes.containsAll(_oahs_Participant_forUpdate)) throw new 
AttributeNotRecognized ("Unexpected attribute set requested") ,- 
if (!_Participant.owned) throw new 
AttributeNotOwned ("Requested Participant not owned") ,- 

//We already knew that _rtiAmbassador calls from within 
_fedAmbassador callbacks had to be threaded off 

//to avoid "RTIinternalError: Concurrent access attempted 
to cmethod name>"; now a bug in pRTI causes 

//ANY _rtiAmbassador-calling thread to freeze if it the 
call triggers any _fedAmbassador callbacks and the 

//federate thread is currently waiting for a 
synchronization monitor. 

//So we must avoid having the federate service thread 
going into a wait state, which means more threading offl 

//(Or, in this case, moving the synchronization call into 
the child thread) 


DRDC Valcartier TR 2007-412 


1105 



new Thread() { public void run() { 

try { 

//No need to synchronize earlier on _Participant 
since the discovery and ownership handlers also synchronize on 
_theParticipants 

//It is crucial to synchronize here, however, since 
the object's registration may trigger this handler right away 

//(because of Auto-Provide) --and the object cannot 
fill its user_handle field in the same atomic operation, 
synchronized(_Participant) 

{ 

final AttributeHandleValueMap 
_ahvm_attributeValues = 

_rtiAmbassador.getAttributeHandleValueMapFactory().create(_oahs_Partic 
ipant_f orUpdate . size () ) ,- 

_ahvm_attributeValues.put(_oah_Participant_logged_in, 

_Participant.logged_in.toByteArray()); 

_ahvm_attributeValues.put(_oah_Participant_user_handle, 

_Participant.user_handle.toByteArray()); 

_ahvm_attributeValues.put(_oah_Participant_chat_room_slot, 

_Participant.chat_room_slot.toByteArray()); 


rtiAmbassador.updateAttributeValues(_Participant.handle 
ahvm_attributeValues, null) ,- 

} //synchronized(_Participant) 

} catch (Exception ignored) { 

} finally { 

} //try 

} }.start (); //Thread 
} catch (Exception intercepted) { 

} finally { 

} //try 

} //method provideAttributeValueUpdate 
} //class MyParticipantInstanceAttributeResponder 


1106 


DRDC Valcartier TR 2007-412 



* * 


* Entry point for java exec command. 

* args[0] (optional) is the RTI host ("localhost" by default) 

* args[l] (optional) is the FDD file path (may be relative or 
absolute; "MyChat.xml" by default) 

* args[2] (optional) is the federation execution name 
("MyChatRoom" by default) 

* args[3] (optional) is the federate name ("MyChatter" by default) 

* @param args the String[] command line arguments 
*/ 

public static void main(String args[]) 

{ 

new MyChat(args).show(); 


// Variables declaration - do not modify 
private j avax.swing.JButton btnLogon; 
private j avax.swing.JButton btnNewChatRoom; 
private j avax.swing.JButton btnSendMessage; 
private j avax.swing.JPanel j Panell; 
private j avax.swing.JPanel j Panel2; 
private j avax.swing.JPanel j Panel3; 
private j avax.swing.JPanel j Panel4; 
private j avax.swing.JPanel j Panels; 
private j avax.swing.JPanel j Panels; 
private j avax.swing.JPanel j Panel7; 
private j avax.swing.JLabel lblChatRoom; 
private j avax.swing.JLabel lblSendTo; 
private j avax.swing.JLabel lblStatus; 
private j avax.swing.JComboBox IstChatRooms; 
private j avax.swing.JComboBox IstSendTo; 
private j avax.swing.JTextArea txtArea; 
private j avax.swing.JTextField txtMessage; 
private j avax.swing.JTextField txtUsername; 
// End of variables declaration 

} 

//end MyChat 


DRDC Valcartier TR 2007-412 


1107 



This page intentionally left blank. 


1108 


DRDC Valcartier TR 2007-412 



Annex F - The JACK Chat Client 


The JACK Chat Client is a command-line user-interface (CLI) application. This 
was done simply to provide a visual distinction between the two clients; nothing 
prevents JACK from using a GUI. However, one notes that JACK development 
cannot be conducted from within a Java IDE, since JAL is no longer Java. One 
would have to develop the GUI separately and then import it into JACK. 

On the other hand, JACK’S built-in thread handling simplifies cross-task 
synchronization considerably. We started off by importing blocks of the Java client 
code, but soon realized that it was too “lumpy”; that is to say, tasks had not been 
broken down into small enough component steps. The way JACK implements 
semaphores, among other tilings, forced us to re-distribute the code between the 
plans. The end result is quite pleasing, JACK plans being a lot easier to read than 
our original Java chat client code. 

The first part of this annex documents the capHLAisie capability, which is the re¬ 
usable part of the JACK-HLA interface. The second part details the JACK Chat 
Client itself. 


DRDC Valcartier TR 2007-412 


1109 




Part One - The capHLA1516 Capability 


The JACK capHLAisis capability acts as an adaptor between JACK and HLA. 
Because JACK introduces a lot of automatic code, rather than give a full textual 
listing of the various files that make up the JACK Chat client, we’ve opted for a 
summary description similar to the arborescent view used by the JACK 
Development Environment. 


// File: HLA1516.prj 
"ProjectName" node: HLA1516 
"Documentation" node 

This is the JACK Repository project file for the HLA1516 
package. 

See the "HLA1516 Capability Read Me.txt" file (under Other 
Files) for details. 

Daniel U. Thibault 
Daniel.Thibault@DRDC-RDDC.GC.Ca 
2004 December 03 
revised 2004 January 13 
"Design Views" node 
"Overview" node 

"Documentation" node 

Overview of the capHLA1516 capability's architecture 
"Agent Model" node 
"Agent Types" node 
(empty) 

"Capability Types" node 
"HLA1516" node 
"capHLA1516" 


1110 


DRDC Valcartier TR 2007-412 



"Plan Types" node 
"HLA1516" node 

"plnHLAannounceSynchronizationPoint" 

"plnHLAattributelsNotOwned" 

"plnHLAattributelsOwnedByRTI" 

"plnHLAattributeOwnershipAcquisitionNotifloation" 
"plnHLAattributeOwnershipUnavailable" 

"plnHLAattributesInScope" 

"plnHLAattributesOutOfScope" 

"plnHLAconfIrmAttributeOwnershipAcquisitionCancellation" 
"plnHLAdiscoverObj ectInstance" 

"plnHLAfederationNotRestored" 

"plnHLAfederationNotSaved" 

"plnHLAfederationRestoreBegun" 

"plnHLAfederationRestored" 

"plnHLAfederationRestoreStatusResponse" 

"plnHLAfederationSaved" 

"plnHLAfederationSaveStatusResponse" 

"plnHLAfederationSynchronized" 

"plnHLAinformAttributeOwnership" 

"plnHLAinitiateFederateRestore" 

"plnHLAinitiateFederateSave" 

"plnHLAobj ectlnstanceNameReservationFailed" 

"plnHLAobj ectlnstanceNameReservationSucceeded" 
"plnHLAprovideAttributeValueUpdate" 

"plnHLAreceiveInteraction" 

"plnHLAreflectAttributeValues" 

"plnHLAremoveObjectInstance" 

"plnHLArequestAttributeOwnershipAssumption" 
"plnHLArequestAttributeOwnershipRelease" 
"plnHLArequestDivestitureConfirmation" 

"plnHLArequestFederationRestoreFalied" 

"plnHLArequestFederationRestoreSucceeded" 

"plnHLArequestRetract ion" 

"plnHLAstartRegistrationForObj ectClass" 
"plnHLAstopRegistrationForObj ectClass" 
"plnHLAsynchronizationPointRegistrationFailed" 
"plnHLAsynchronizationPointRegistrationSucceeded" 
"plnHLAtImeAdvanceGrant" 

"plnHLAtImeConstrainedEnabled" 

"plnHLAtimeRegulationEnabled" 

"plnHLAturnlnteractionsOff" 

"plnHLAturnlnteractionsOn" 

"plnHLAturnUpdatesOffForObjectInstance" 

"plnHLAturnUpdatesOnForObj ectInstance" 


DRDC Valcartier TR 2007-412 


1111 



"Event Types" node 
"HLA1516" node 

"evtHLAannounceSynchronizationPoint" 

"evtHLAattributelsNotOwned" 

"evtHLAattributelsOwnedByRTI" 

"evtHLAattributeOwnershipAcquisitionNotification" 

"evtHLAattributeOwnershipUnavailable" 

"evtHLAattributesInScope" 

"evtHLAattributesOutOfScope" 

"evtHLAconfirmAttributeOwnershipAcquisitionCancellation" 
"evtHLAdiscoverObj ectInstance" 

"evtHLAfederationNotRestored" 

"evtHLAfederationNotSaved" 

"evtHLAfederationRestoreBegun" 

"evtHLAfederationRestored" 

"evtHLAfederationRestoreStatusResponse" 

"evtHLAfederationSaved" 

"evtHLAfederationSaveStatusResponse" 

"evtHLAfederationSynchronized" 

"evtHLAinformAttributeOwnership" 

"evtHLAinitiateFederateRestore" 

"evtHLAinitiateFederateSave" 

"evtHLAobj ectInstanceNameReservationFailed" 

"evtHLAobj ectInstanceNameReservationSucceeded" 

"evtHLAprovideAttributeValueUpdate" 

"evtHLAreceiveInteraction" 

"evtHLAreflectAttributeValues" 

"evtHLAremoveObj ectInstance" 

"evtHLArequestAttributeOwnershipAssumption" 

"evtHLArequestAttributeOwnershipRelease" 

"evtHLArequestDivestitureConfirmation" 

"evtHLArequestFederationRestoreFailed" 

"evtHLArequestFederationRestoreSucceeded" 

"evtHLArequestRetraction" 

"evtHLAstartRegistrationForObj ectClass" 

"evtHLAstopRegistrationForObj ectClass" 

"evtHLAsynchronizationPointRegistrationFailed" 

"evtHLAsynchronizationPointRegistrationSucceeded" 

"evtHLAtimeAdvanceGrant" 

"evtHLAtimeConstrainedEnabled" 

"evtHLAtimeRegulationEnabled" 

"evtHLAturnlnteractionsOff" 

"evtHLAturnlnteractionsOn" 

"evtHLAturnUpdatesOffForObj ectInstance" 

"evtHLAturnUpdatesOnForObj ectInstance" 


1112 


DRDC Valcartier TR 2007-412 



"Named Data" node 
"HLA1516" node 

"blfHLA datHLA" 

"Data Model" node 

"Beliefset Types" node 
"HLA1516" node 
"blfHLA" 

"View Types" node 
(empty) 

"External Classes" node 
(empty) 

"Other Files" node 

"HLA1516 Capability Read Me.txt" 
//end HLA1516 


DRDC Valcartier TR 2007-412 


1113 



The capHLAis16 .cap file contains large boiler-plate blocks; after the comment 
header (which explains in detail how to use the capability), there are long lists of 
handled events, posted events, and used plans. In the inner HLAf ederate class 
itself, there is a long list of private members holding the various Validation 
handler references, followed later on by a similar list of get/ set methods. Finally, 
there is the FederateAmbassador implementation, which follows a simple design 
pattern of invoking the Validation handler if specified, and then posting the event 
that corresponds to the callback. 


// File: capHLA1516.cap 

package ca.go.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hla.rtil516.FedAmb.*,- 
import hla.rtil516.*; 

j * * 

Encapsulation of the HLA IEEE 1516 interface. 

To use the capHLA1516 capability: 

1) Import the capability into your project (see HLA1516 Capability 
Read Me.txt for details). 

2) Let the agent (or capability) have the capHLA1516 capability. 

3) Create a Named Data instance of type 

ca.gc.drdc_rddc.hla.rt11516.jack.blfHLA and drag it to the 
capability's external belief data import to replace the default one if 
you wish. 

4) At some point in your code (quite possibly the agent's constructor, 
but this need not be), create one or more instances of the 
capability's inner class capHLA1516.HLAfederate (see HLA1516 
Capability Read Me.txt to learn how to invoke the constructor). 

The cunique string identifier> used when creating the HLAfederate 
instances is included as the identifier field of each of the HLA 
events that will be posted to the enclosing agent/capability. 

It is intended to be used by the latter to distinguish as needed 
between the HLAfederate instances it may have created. 

Each HLAfederate can be passed as a FederateAmbassador argument to the 
RTIambassador's j oinFederationExecution service invocation. 

By creating multiple RTIambassador and HLAfederate instances, an agent 
can thus play the roles of several HLA federates. 

See HLA1516 Capability Read Me.txt to learn how to extend HLAfederate 
as needed. 

The capability's inner class (capHLA1516.HLAfederate) implements the 
whole FederateAmbassador interface. 

Each HLA callback is translated into a JACK HLA event and posted to 
the enclosing agent (or capability). 

Overloaded callbacks are rolled into a single event with appropriate 
nulls. 


1114 


DRDC Valcartier TR 2007-412 



The HLAfederate identifier can be queried with getldentifier and even 
changed with setldentifier. 

An RTIambassador field (rtiAmbassador) is supplied for convenience 
(HLAfederate does not use it). 

The imported belief data set datHLA stores the associations between 
HLAfederate identifiers and instance references. 

It also insures the uniqueness of identifiers within its enclosing 
agent's scope; an attempt to create or rename an HLAfederate using an 
already-extant identifier will throw a BeliefSetException. 

DISPOSING OF THE HLAFEDERATE INSTANCE: 

Once the HLAfederate instance has outlived its usefullness, it can be 
removed from datHLA through the removelnstance query. 

HLAfederate instances attempt to remove themselves from datHLA when 
garbage-collected (System.go()), just in case they were disposed of by 
abnormal means. 

WRITING PLANS TO HANDLE HLA EVENTS: 

The enclosing agent/capability should declare it handles only those 
HLA events that matter to it; the capability handles each of the 
events it posts using irrelevant plans; this simple trick prevents the 
run-time from complaining that some events are not handled. 

When an agent handles multiple federates, plans can bind to the 
correct HLAfederate instance by: 

1) Declaring "HLA1516.capHLA1516.HLAfederate <HLAfederate_instance>;",- 

2) Reading the belief data set (add "#reads data blfHLA datHLA;" to 
the plan code or simply drop the capability's imported datHLA on the 
plan's Belief Data); and 

3) Starting the context() method with: 

( null l= ( <HLAfederate_instance> = datHLA.getlnstance( 
<handled_event>.identifier ) ) ) 

Once this context step has succeeded, <HLAfederate_instance> is bound 
to the HLAfederate instance reference that matches the event's 
identifier field. Equivalently, you can declare an additional logical 
variable Object <Object_instance> and start the context() with: 

datHLA.get( <handled_event>.identifier, <Object_instance> ) && 
( null l= (<HLAfederate_instance> = 

(HLAfederate)<Obj ect_instance>.as_obj ect())),- 

The latter form may be more convenient if you wish to typecast 
directly to your HLAfederate sub-class --you'd replace the 
(HLAfederate) typecast accordingly, of course. 


DRDC Valcartier TR 2007-412 


1115 



WRITING HLA EVENT VALIDATORS: 


Each of the 43 HLA events has a corresponding Validate interface in 
the ca.gc.drdc_rddc.hla.rtil516.FedAmb package. 

For example, evtHLAannounceSynchronizationPoint has a 
ValidateAnnounceSynchronizationPoint interface. 

To have the HLAfederate invoke a validation handler when it receives 
the HLA callback (within the Federate Service Thread), you need only 
register it with the HLAfederate instance at any time using the 
corresponding set method (e.g. 
setValidateAnnounceSynchronizationPoint()). 

ON PLAYING WITH MULTIPLE FEDERATION EXECUTIONS AT ONCE: 

The HLA spec and RTI implementations are quirky at this level. 

Nothing prevents a single RTIambassador instance from creating and 
deleting multiple federation executions, but it may join only one at a 
time. 

This is because the RTI identifies the federate with the RTIambassador 
instance, and it considers the RTIambassador committed to the 
federation execution it joined until it resigns from it. 

ON THE USE OF IRRELEVANT PLANS: 

In JACK, internal capabilities are always more prominent than plans, 
so we have a small problem. 

If we let capHLA1516 simply post the gamut of HLA events, the run-time 
will complain that some events are not being handled unless the user 
supplies "null plans" for each of those events he's not interested in. 
This is an annoyance. 

To solve this, we built into capHLA1516 an event-handling capability 
for each of the HLA events. 

None of the capability's internal plans actually *do* anything, which 
is what we want for null handlers. 

But because internal capabilities are more prominent than the agent's 
plans, if the user wanted to write meaningful handlers for the HLA 
events he would have to wrap them into a capability of his own, and 
then make sure that his capability is more prominent than the 
capHLA1516. 

This is workable but unsafe. 

To make capHLA1516 foolproof, we simply made each of our internal HLA 
plans irrelevant --that is to say, they all return false as their 
relevance() method. 

This way, the run-time is satisfied, and the user can have his own 
picked HLA handling plans wherever he wishes them to be. 

Our plans will never be invoked and will thus always be glossed over 
should they be more prominent. 

The fact that otherwise-unhandled events end up with no applicable 
plans at all does not bother JACK overmuch. 

*/ 


1116 


DRDC Valcartier TR 2007-412 



public capability 
capHLA1516 

extends Capability 

{ 

#handles external event evtHLAannounceSynchronizationPoint; 
#handles external event evtHLAattributelsNotOwned; 

#handles external event evtHLAattributelsOwnedByRTI; 

#handles external event 

evtHLAattributeOwnershipAcquisitionNotification; 

#handles external event evtHLAattributeOwnershipUnavailable; 
#handles external event evtHLAattributesInScope; 

#handles external event evtHLAattributesOutOfScope; 

#handles external event 

evtHLAconfirmAttributeOwnershipAcquisitionCancellation; 

#handles external event evtHLAdiscoverObj ectInstance; 

#handles external event evtHLAfederationNotRestored; 

#handles external event evtHLAfederationNotSaved; 

#handles external event evtHLAfederationRestoreBegun; 

#handles external event evtHLAfederationRestored; 

#handles external event evtHLAfederationRestoreStatusResponse; 
#handles external event evtHLAfederationSaved; 

#handles external event evtHLAfederationSaveStatusResponse; 
#handles external event evtHLAfederationSynchronized; 

#handles external event evtHLAinformAttributeOwnership; 

#handles external event evtHLAinitiateFederateRestore; 

#handles external event evtHLAinitiateFederateSave; 

#handles external event evtHLAobj ectInstanceNameReservationFailed; 
#handles external event 
evtHLAobj ectInstanceNameReservationSucceeded; 

#handles external event evtHLAprovideAttributeValueUpdate; 

#handles external event evtHLAreceivelnteraction; 

#handles external event evtHLAreflectAttributeValues; 

#handles external event evtHLAremoveObjectInstance; 

#handles external event evtHLArequestAttributeOwnershipAssumption; 
#handles external event evtHLArequestAttributeOwnershipRelease; 
#handles external event evtHLArequestDivestitureConfirmation; 
#handles external event evtHLArequestFederationRestoreFalied; 
#handles external event evtHLArequestFederationRestoreSucceeded; 
#handles external event evtHLArequestRetraction; 

#handles external event evtHLAstartRegistrationForObj ectClass; 
#handles external event evtHLAstopRegistrationForObj ectClass; 
#handles external event 
evtHLAsynchronizationPointRegistrationFailed; 

#handles external event 

evtHLAsynchronizationPointRegistrationSucceeded; 

#handles external event evtHLAtimeAdvanceGrant; 

#handles external event evtHLAtimeConstrainedEnabled; 

#handles external event evtHLAtimeRegulationEnabled; 

#handles external event evtHLAturnlnteractionsOff; 

#handles external event evtHLAturnlnteractionsOn; 

#handles external event evtHLAturnUpdatesOffForObj ectInstance; 
#handles external event evtHLAturnUpdatesOnForObj ectInstance; 


DRDC Valcartier TR 2007-412 


1117 



#posts external event evtHLAannounceSynchronizationPoint 
evHLAannounceSynchronizationPoint; 

#posts external event evtHLAattributelsNotOwned 
evHLAattributelsNotOwned; 

#posts external event evtHLAattributelsOwnedByRTI 
evHLAattributelsOwnedByRTI ; 

#posts external event 

evtHLAattributeOwnershipAcquisitionNotification 
evHLAattributeOwnershipAcquisitionNotification; 

#posts external event evtHLAattributeOwnershipUnavaliable 
evHLAattributeOwnershipUnavailable; 

#posts external event evtHLAattributesInScope 
evHLAattributesInScope; 

#posts external event evtHLAattributesOutOfScope 
evHLAattributesOutOfScope; 

#posts external event 

evtHLAconfIrmAttributeOwnershipAcquisitionCancellation 
evHLAconfIrmAttributeOwnershipAcquisitionCancellation; 

#posts external event evtHLAdiscoverObj ectlnstance 
evHLAdiscoverObj ectlnstance; 

#posts external event evtHLAfederationNotRestored 
evHLAfederationNotRestored; 

#posts external event evtHLAfederationNotSaved 
evHLAfederationNotSaved; 

#posts external event evtHLAfederationRestoreBegun 
evHLAfederatIonRestoreBegun; 

#posts external event evtHLAfederationRestored 
evHLAfederationRestored; 

#posts external event evtHLAfederationRestoreStatusResponse 
evHLAfederationRestoreStatusResponse; 

#posts external event evtHLAfederationSaved evHLAfederationSaved; 
#posts external event evtHLAfederationSaveStatusResponse 
evHLAfederationSaveStatusResponse; 

#posts external event evtHLAfederationSynchronized 
evHLAfederationSynchronized; 

#posts external event evtHLAinformAttributeOwnership 
evHLAinformAttributeOwnership; 

#posts external event evtHLAinitiateFederateRestore 
evHLAinitiateFederateRestore; 

#posts external event evtHLAinitiateFederateSave 
evHLAinitiateFederateSave; 

#posts external event evtHLAobj ectInstanceNameReservationFailed 
evHLAobj ectInstanceNameReservationFailed; 

#posts external event evtHLAobj ectInstanceNameReservationSucceeded 
evHLAobjectInstanceNameReservationSucceeded; 


1118 


DRDC Valcartier TR 2007-412 



#posts external event evtHLAprovideAttributeValueUpdate 
evHLAprovideAttributeValueUpdate; 

#posts external event evtHLAreceivelnteraction 
evHLAr e c eiveInteraction; 

#posts external event evtHLAreflectAttributeValues 
evHLAreflectAttributeValues; 

#posts external event evtHLAremoveObjectlnstance 
evHLAremoveObj ectInstance; 

#posts external event evtHLArequestAttributeOwnershipAssumption 
evHLArequestAttributeOwnershipAssumption; 

#posts external event evtHLArequestAttributeOwnershipRelease 
evHLArequestAttributeOwnershipRelease; 

#posts external event evtHLArequestDivestitureConfirmation 
evHLArequestDivestitureConfirmation; 

#posts external event evtHLArequestFederationRestoreFalied 
evHLArequestFederationRestoreFailed; 

#posts external event evtHLArequestFederationRestoreSucceeded 
evHLArequestFederationRestoreSucceeded; 

#posts external event evtHLArequestRetraction 
evHLArequestRetraction; 

#posts external event evtHLAstartRegistrationForObj ectClass 
evHLAstartRegistrationForObj ectClass; 

#posts external event evtHLAstopRegistratIonForObj ectClass 
evHLAstopRegistrationForObj ectClass; 

#posts external event evtHLAsynchronizationPointRegistrationFailed 
evHLAsynchronizationPointRegistrationFailed; 

#posts external event 

evtHLAsynchronizatIonPointRegistrationSucceeded 
evHLAsynchronizationPointRegistrationSucceeded; 

#posts external event evtHLAtImeAdvanceGrant evHLAtImeAdvanceGrant; 
#posts external event evtHLAtImeConstrainedEnabled 
evHLAtimeConstrainedEnabled; 

#posts external event evtHLAtimeRegulationEnabled 
evHLAtimeRegulationEnabled; 

#posts external event evtHLAturnlnteractionsOff 
evHLAturnlnteractionsOff; 

#posts external event evtHLAturnlnteractionsOn 
evHLAturnlnteractionsOn; 

#posts external event evtHLAturnUpdatesOffForObjectInstance 
evHLAturnUpdatesOffForObjectInstance; 

#posts external event evtHLAturnUpdatesOnForObjectInstance 
evHLAturnUpdatesOnForObjectInstance; 


DRDC Valcartier TR 2007-412 


1119 



#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 

#uses 


plan plnHLAannounceSynchronizationPoint; 
plan plnHLAattributelsNotOwned; 
plan plnHLAattributelsOwnedByRTI; 

plan plnHLAattributeOwnershipAcquisitionNotification; 
plan plnHLAattributeOwnershipUnavaliable; 
plan plnHLAattributesInScope; 
plan plnHLAattributesOutOfScope; 

plan plnHLAconfirmAttributeOwnershipAcquisitionCancellation; 

plan plnHLAdiscoverObj ectInstance; 

plan plnHLAfederationNotRestored; 

plan plnHLAfederationNotSaved; 

plan plnHLAfederationRestoreBegun; 

plan plnHLAfederationRestored; 

plan plnHLAfederationRestoreStatusResponse; 

plan plnHLAfederationSaved; 

plan plnHLAfederationSaveStatusResponse; 

plan plnHLAfederationSynchronized; 

plan plnHLAinformAttributeOwnership; 

plan plnHLAinitiateFederateRestore; 

plan plnHLAinitiateFederateSave; 

plan plnHLAobj ectlnstanceNameReservationFailed; 

plan plnHLAobj ectlnstanceNameReservationSucceeded; 

plan plnHLAprovideAttributeValueUpdate; 

plan plnHLAreceivelnteraction; 

plan plnHLAreflectAttributeValues; 

plan plnHLAremoveObjectInstance; 

plan plnHLArequestAttributeOwnershipAssumption; 

plan plnHLArequestAttributeOwnershipRelease; 

plan plnHLArequestDivestitureConfirmation; 

plan plnHLArequestFederationRestoreFalied; 

plan plnHLArequestFederationRestoreSucceeded; 

plan plnHLArequestRetraction; 

plan plnHLAstartRegistrationForObj ectClass; 

plan plnHLAstopRegistrationForObj ectClass; 

plan plnHLAsynchronizationPointRegistrationFailed; 

plan plnHLAsynchronizationPointRegistrationSucceeded; 

plan plnHLAtimeAdvanceGrant; 

plan plnHLAtImeConstrainedEnabled; 

plan plnHLAtimeRegulationEnabled; 

plan plnHLAturnlnteractionsOff; 

plan plnHLAturnlnteractionsOn; 

plan plnHLAturnUpdatesOffForObj ectInstance; 

plan plnHLAturnUpdatesOnForObj ectInstance; 


#imports data blfHLA datHLAO; 


1120 


DRDC Valcartier TR 2007-412 



public HLAfederate 

getNewHLAfederate(String identifier) 

throws aos.jack.jak.beliefset.BeliefSetException 

{ 

return new HLAfederate(identifier) ; 


public class 
HLAfederate 

implements FederateAmbassador 

j * * 

* Method signature conflicts prevent all Validate interfaces 
from being 

* accommodated by a single class. If this had not been the case 

* HLAfederate could have implemented all of them and used 
itself as a 

* null handler. Instead we'll guard each invocation. 

*/ 


//The instance's identifier 
private String _identifier; 

//Convenience RTIambassador reference 
public RTIambassador rtiAmbassador; 


DRDC Valcartier TR 2007-412 


1121 



//Validation handlers 
private 

ValidateAnnounceSynchronizationPoint 
validateAnnounceSynchronizationPoint; 
private 

ValidateAttributeIsNotOwned validateAttributeIsNotOwned; 
private 

ValIdateAttributeIsOwnedByRTI valIdateAttributeIsOwnedByRTI; 
private 

ValidateAttributeOwnershipAcquisitionNotifloation 
validateAttributeOwnershipAcquisitionNotification; 
private 

ValidateAttributeOwnershipUnavaliable 
validateAttributeOwnershipUnavailable; 
private 

ValidateAttributesInScope validateAttributesInScope; 
private 

ValidateAttributesOutOfScope validateAttributesOutOfScope; 
private 

ValidateConfirmAttributeOwnershipAcquisitionCancellation 
validateConfirmAttributeOwnershipAcquisitionCancellation; 
private 

ValidateDiscoverObj ectInstance validateDiscoverObj ectInstance; 
private 

ValidateFederationNotRestored validateFederationNotRestored; 
private 

ValidateFederationNotSaved validateFederationNotSaved; 
private 

ValidateFederationRestoreBegun validateFederationRestoreBegun; 
private 

ValidateFederationRestored validateFederationRestored; 
private 

ValidateFederationRestoreStatusResponse 
validateFederationRestoreStatusResponse; 
private 

ValidateFederationSaved validateFederationSaved; 
private 

ValidateFederationSaveStatusResponse 
validateFederationSaveStatusResponse; 
private 

ValidateFederationSynchronized validateFederationSynchronized; 
private 

ValidatelnformAttributeOwnership 
validatelnformAttributeOwnership; 
private 

ValidatelnitiateFederateRestore validatelnitiateFederateRestore; 
private 

ValidatelnitiateFederateSave validateInitiateFederateSave; 
private 

ValidateObj ectlnstanceNameReservationFailed 
validateObj ectlnstanceNameReservationFailed; 
private 

ValidateObj ectlnstanceNameReservationSucceeded 
validateOb]ectlnstanceNameReservationSucceeded; 


1122 


DRDC Valcartier TR 2007-412 



private 

ValidateProvideAttributeValueUpdate 
validateProvideAttributeValueUpdate; 
private 

ValidateReceiveInteraction validateReceiveInteraction; 
private 

ValidateReflectAttributeValues validateReflectAttributeValues; 
private 

ValidateRemoveObj ectInstance validateRemoveObj ectInstance; 
private 

ValidateRequestAttributeOwnershipAssumption 
validateRequestAttributeOwnershipAssumption; 
private 

ValidateRequestAttributeOwnershipRelease 
validateRequestAttributeOwnershipRelease; 
private 

ValidateRequestDivestitureConfirmation 
validateRequestDivestitureConfirmation; 
private 

ValidateRequestFederationRestoreFailed 
validateRequestFederationRestoreFailed; 
private 

ValidateRequestFederationRestoreSucceeded 
validateRequestFederationRestoreSucceeded; 
private 

ValidateRequestRetraction validateRequestRetraction; 
private 

ValidateStartRegistrationForObj ectClass 
validateStartRegistrationForObj ectClass; 
private 

ValidateStopRegistrationForObj ectClass 
validateStopRegistrationForObj ectClass; 
private 

ValidateSynchronizationPointRegistrationFailed 

validateSynchronizationPointRegistrationFailed; 

private 

ValidateSynchronizationPointRegistrationSucceeded 

validateSynchronizationPointRegistrationSucceeded; 

private 

ValidateTimeAdvanceGrant validateTimeAdvanceGrant; 
private 

ValidateTimeConstrainedEnabled validateTimeConstrainedEnabled; 
private 

ValidateTimeRegulationEnabled validateTimeRegulationEnabled; 
private 

ValidateTurnlnteractionsOff validateTurnlnteractionsOff; 
private 

ValidateTurnlnteractionsOn validateTurnlnteractionsOn; 
private 

ValidateTurnUpdatesOffForObj ectInstance 
validateTurnUpdatesOffForObj ectInstance; 
private 

ValidateTurnUpdatesOnForObj ectInstance 
validateTurnUpdatesOnForObj ectInstance; 


DRDC Valcartier TR 2007-412 


1123 



* * 


* Constructor. 

* @param identifier A String used to distinguish this instance 
from others. 

* @throws BeliefSetException if the identifier is already in 

use 

*/ 

public 

HLAfederate(String identifier) 

throws aos.jack.jak.beliefset.BeliefSetException 

{ 

if (datHLA.hasKey(identifier)) throw new 
aos.jack.jak.beliefset.BeliefSetException("Identifier already in use: 

'" + identifier + "'"); 

_identifier = identifier; 
datHLA.add( _identifier, this ); 

} //Constructor 


j * * 

* Called by the garbage collector on this object before 
disposing of it. 

* @throws Throwable if something goes wrong 
*/ 

protected void 
finalize () 

throws Throwable 

{ 

datHLA.remove( _identifier, this ); 

} //finalize 


j * * 

* Gets the current identifier. 

* @return the current String identifier 

*/ 

public String 
getldentifier () 

{ 

return _identifier; 


1124 


DRDC Valcartier TR 2007-412 



* * 


* Sets the identifier to the new value and returns the previous 

one. 

* @param newldentifier the new String identifier 

* @return the previous identifier 

* @throws BeliefSetException if the newldentifier is already in 

use 

*/ 

public String 

setldentifier(String newldentifier) 

throws aos.jack.jak.beliefset.BeliefSetException 

{ 

//Is newldentifier already in use? 
if (datHLA.hasKey(newldentifier)) throw new 
aos.jack.jak.beliefset.BeliefSetException("Identifier already in use: 
1,1 + newldentif ier + "'"); 

String r = _identifier; 

_identifier = newldentifier; 
datHLA.remove( r, this ); 
datHLA.add( _identifier, this ); 
return r; 


j * * 

* #################################### 

* Validation handlers access functions 

* #################################### 

*/ 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAnnounceSynchronizationPoint 
getValidateAnnounceSynchronizationPoint() 

{ 

return ValidateAnnounceSynchronizationPoint; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateAnnounceSynchronizationPoint 

setValidateAnnounceSynchronizationPoint(ValidateAnnounceSynchronizatio 
nPoint newValidationHandler) 

{ 

ValidateAnnounceSynchronizationPoint r = 
ValidateAnnounceSynchronizationPoint; 

ValidateAnnounceSynchronizationPoint = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1125 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAttributeIsNotOwned 
getValidateAttributelsNotOwned() 

{ 

return valIdateAttributeIsNotOwned; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValIdateAttributeIsNotOwned 

setValidateAttributelsNotOwned(ValIdateAttributeIsNotOwned 
newValidationHandler) 

{ 

ValidateAttributelsNotOwned r = ValidateAttributelsNotOwned; 
validateAttributelsNotOwned = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAttributelsOwnedByRTI 
getValidateAttributelsOwnedByRTI() 

{ 

return validateAttributelsOwnedByRTI; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 

*/ 

public ValidateAttributelsOwnedByRTI 

setValidateAttributelsOwnedByRTI(ValidateAttributelsOwnedByRTI 
newValidationHandler) 

{ 

ValidateAttributelsOwnedByRTI r = 
validateAttributelsOwnedByRTI; 

ValidateAttributelsOwnedByRTI = newValidationHandler; 

return r; 


1126 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAttributeOwnershipAcquisitionNotifloation 
getValidateAttributeOwnershipAcquisitionNotifloation() 

{ 

return validateAttributeOwnershipAcquisitionNotification; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateAttributeOwnershipAcquisitionNotifloation 

setValidateAttributeOwnershipAcquisitionNotification(ValidateAttribute 
OwnershipAcquisitionNotification newValidationHandler) 

{ 

ValidateAttributeOwnershipAcquisitionNotification r = 
validateAttributeOwnershipAcquisitionNotification; 

validateAttributeOwnershipAcquisitionNotification = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAttributeOwnershipUnavaliable 
getValidateAttributeOwnershipUnavailable() 

{ 

return validateAttributeOwnershipUnavaliable; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateAttributeOwnershipUnavaliable 

setValidateAttributeOwnershipUnavailable(ValidateAttributeOwnershipUna 
valiable newValidationHandler) 

{ 

ValidateAttributeOwnershipUnavailable r = 
validateAttributeOwnershipUnavailable; 

validateAttributeOwnershipUnavailable = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1127 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAttributesInScope 
getValidateAttributesInScope () 

{ 

return validateAttributesInScope; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateAttributesInScope 

setValIdateAttributesInScope(ValidateAttributesInScope 
newValidationHandler) 

{ 

ValidateAttributesInScope r = validateAttributesInScope; 
validateAttributesInScope = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateAttributesOutOfScope 
getValidateAttributesOutOfScope() 

{ 

return ValidateAttributesOutOfScope; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateAttributesOutOfScope 

setValidateAttributesOutOfScope(ValidateAttributesOutOfScope 
newValidationHandler) 

{ 

ValidateAttributesOutOfScope r = 

ValidateAttributesOutOfScope; 

ValidateAttributesOutOfScope = newValidationHandler; 
return r; 


1128 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateConfIrmAttributeOwnershipAcquisitionCancellation 
getValidateConfIrmAttributeOwnershipAcquisitionCancellation() 

{ 

return 

validateConfirmAttributeOwnershipAcquisitionCancellation; 


j ± ± 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateConfirmAttributeOwnershipAcquisitionCancellation 

setValidateConfirmAttributeOwnershipAcquisitionCancellation(ValidateCo 
nfirmAttributeOwnershipAcquisitionCancellation newValidationHandler) 

{ 

ValidateConfIrmAttributeOwnershipAcquisitionCancellation r = 
validateConfirmAttributeOwnershipAcquisitionCancellation; 

validateConfirmAttributeOwnershipAcquisitionCancellation = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateDiscoverObj ectInstance 
getValidateDiscoverObj ectInstance () 

{ 

return validateDiscoverObj ectInstance; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 

*/ 

public ValidateDiscoverObj ectInstance 

setValidateDiscoverObj ectInstance(ValidateDiscoverObj ectInstance 
newValidationHandler) 

{ 

ValidateDiscoverObj ectInstance r = 
validateDiscoverObj ectlnstance; 

validateDiscoverObj ectInstance = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1129 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationNotRestored 
getValidateFederationNotRestored() 

{ 

return valIdateFederationNotRestored; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederationNotRestored 

setValIdateFederationNotRestored(ValidateFederationNotRestored 
newValidationHandler) 

{ 

ValidateFederationNotRestored r = 

ValidateFederatIonNotRestored; 

valIdateFederatIonNotRestored = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationNotSaved 
getValidateFederationNotSaved() 

{ 

return ValidateFederationNotSaved; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederationNotSaved 

setValIdateFederationNotSaved(ValidateFederationNotSaved 
newValidationHandler) 

{ 

ValidateFederationNotSaved r = ValidateFederationNotSaved; 
valIdateFederationNotSaved = newValidationHandler; 
return r; 


1130 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationRestoreBegun 
getValidateFederationRestoreBegun() 

{ 

return ValidateFederationRestoreBegun; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederationRestoreBegun 

setValidateFederatIonRestoreBegun(ValidateFederationRestoreBegun 
newValidationHandler) 

{ 

ValidateFederationRestoreBegun r = 
ValidateFederationRestoreBegun; 

ValidateFederationRestoreBegun = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationRestored 
getValidateFederationRestored() 

{ 

return ValidateFederationRestored; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederationRestored 

setValIdateFederationRestored(ValidateFederationRestored 
newValidationHandler) 

{ 

ValidateFederationRestored r = ValidateFederationRestored; 
ValidateFederationRestored = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1131 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationRestoreStatusResponse 
getValidateFederationRestoreStatusResponse () 

{ 

return valIdateFederationRestoreStatusResponse; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederationRestoreStatusResponse 

setValidateFederationRestoreStatusResponse(ValidateFederationRestoreSt 
atusResponse newValidationHandler) 

{ 

ValidateFederationRestoreStatusResponse r = 

ValidateFederationRestoreStatusResponse; 

ValidateFederationRestoreStatusResponse = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationSaved 
getValidateFederationSaved() 

{ 

return validateFederationSaved; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederationSaved 

setValidateFederationSaved(ValidateFederationSaved 
newValidationHandler) 

{ 

ValidateFederationSaved r = validateFederationSaved; 
validateFederationSaved = newValidationHandler; 
return r; 


1132 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationSaveStatusResponse 
getValidateFederationSaveStatusResponse () 

{ 

return validateFederatIonSaveStatusResponse; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateFederatIonSaveStatusResponse 

setValidateFederatIonSaveStatusResponse(ValidateFederationSaveStatusRe 
sponse newValidationHandler) 

{ 

ValidateFederatIonSaveStatusResponse r = 
validateFederatIonSaveStatusResponse; 

valIdateFederatIonSaveStatusResponse = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateFederationSynchronized 
getValidateFederationSynchronized() 

{ 

return validateFederationSynchronized; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 

*/ 

public ValidateFederationSynchronized 

setValIdateFederationSynchronized(ValidateFederationSynchronized 
newValidationHandler) 

{ 

ValidateFederationSynchronized r = 
validateFederationSynchronized; 

valIdateFederationSynchronized = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1133 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidatelnformAttributeOwnership 
getValidatelnformAttributeOwnership() 

{ 

return validatelnformAttributeOwnership; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidatelnformAttributeOwnership 

setValidatelnformAttributeOwnership(ValidatelnformAttributeOwnership 
newValidationHandler) 

{ 

ValidatelnformAttributeOwnership r = 
validatelnformAttributeOwnership; 

validatelnformAttributeOwnership = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidatelnftiateFederateRestore 
getValidatelnitiateFederateRestore() 

{ 

return ValidatelnitiateFederateRestore; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidatelnitiateFederateRestore 

setValidatelnitiateFederateRestore(ValidateInitiateFederateRestore 
newValidationHandler) 

{ 

ValidatelnitIateFederateRestore r = 
valIdatelnitIateFederateRestore; 

validatelnitIateFederateRestore = newValidationHandler; 
return r; 


1134 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateInitiateFederateSave 
getValidatelnitiateFederateSave() 

{ 

return validateInitIateFederateSave; 


j k k 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 

*/ 

public ValidateInitIateFederateSave 

setValidatelnitIateFederateSave(ValIdatelnitIateFederateSave 
newValidationHandler) 

{ 

ValidatelnitiateFederateSave r = 
validatelnitIateFederateSave; 

validatelnitIateFederateSave = newValidationHandler; 
return r; 


j k k 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateObj ectInstanceNameReservationFailed 
getValidateObj ectInstanceNameReservationFailed() 

{ 

return validateObj ectInstanceNameReservationFailed; 


j k k 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateObj ectInstanceNameReservationFailed 

setValidateObj ectInstanceNameReservationFailed(ValidateObj ectInstanceN 
ameReservationFailed newValidationHandler) 

{ 

ValidateObj ectInstanceNameReservationFailed r = 

ValidateObj ectInstanceNameReservationFalied; 

ValidateObj ectInstanceNameReservationFailed = 
newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1135 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateObj ectInstanceNameReservationSucceeded 
getValidateObj ectInstanceNameReservationSucceeded() 

{ 

return validateObj ectInstanceNameReservationSucceeded; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateObj ectInstanceNameReservationSucceeded 

setValidateObjectInstanceNameReservationSucceeded(ValidateObj ectInstan 
ceNameReservationSucceeded newValidationHandler) 

{ 

ValidateObj ectInstanceNameReservationSucceeded r = 
validateObj ectInstanceNameReservationSucceeded; 

validateObj ectInstanceNameReservationSucceeded = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateProvideAttributeValueUpdate 
getValidateProvideAttributeValueUpdate() 

{ 

return validateProvideAttributeValueUpdate; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateProvideAttributeValueUpdate 

setValidateProvideAttributeValueUpdate(ValidateProvideAttributeValueUp 
date newValidationHandler) 

{ 

ValidateProvideAttributeValueUpdate r = 
validateProvideAttributeValueUpdate; 

validateProvideAttributeValueUpdate = newValidationHandler; 
return r; 


1136 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateReceivelnteraction 
getValidateReceiveInteraction() 

{ 

return ValidateReceivelnteraction; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateReceivelnteraction 

setValIdateReceiveInteraction(ValidateReceivelnteraction 
newValidationHandler) 

{ 

ValidateReceivelnteraction r = ValidateReceivelnteraction; 
valIdateReceiveInteraction = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateReflectAttributeValues 
getValidateReflectAttributeValues() 

{ 

return validateReflectAttributeValues; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateReflectAttributeValues 

setValidateReflectAttributeValues(ValidateReflectAttributeValues 
newValidationHandler) 

{ 

ValidateReflectAttributeValues r = 

ValidateReflectAttributeValues; 

ValidateReflectAttributeValues = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1137 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRemoveObjectInstance 
getValidateRemoveObjectInstance() 

{ 

return validateRemoveObj ectlnstance; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 

*/ 

public ValidateRemoveObj ectlnstance 

setValidateRemoveObjectlnstance(ValidateRemoveObj ectlnstance 
newValidationHandler) 

{ 

ValidateRemoveObjectlnstance r = 
validateRemoveObj ectlnstance; 

validateRemoveObj ectlnstance = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRequestAttributeOwnershipAssumption 
getValidateRequestAttributeOwnershipAssumption() 

{ 

return valIdateRequestAttributeOwnershipAssumption; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateRequestAttributeOwnershipAssumption 

setValidateRequestAttributeOwnershipAssumption(ValidateRequestAttribut 
eOwnershipAssumption newValidationHandler) 

{ 

ValidateRequestAttributeOwnershipAssumption r = 
validateRequestAttributeOwnershipAssumption; 

validateRequestAttributeOwnershipAssumption = 
newValidationHandler; 
return r; 


1138 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRequestAttributeOwnershipRelease 
getValidateRequestAttributeOwnershipRelease () 

{ 

return validateRequestAttributeOwnershipRelease; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateRequestAttributeOwnershipRelease 

setValidateRequestAttributeOwnershipRelease(ValidateRequestAttributeOw 
nershipRelease newValidationHandler) 

{ 

ValidateRequestAttributeOwnershipRelease r = 
validateRequestAttributeOwnershipRelease; 

validateRequestAttributeOwnershipRelease = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRequestDivestitureConfirmation 
getValidateRequestDivestitureConfirmation() 

{ 

return ValidateRequestDivestitureConfirmation; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateRequestDivestitureConfirmation 

setValIdateRequestDivestitureConfirmation(ValidateRequestDivestitureCo 
nfirmation newValidationHandler) 

{ 

ValidateRequestDivestitureConfirmation r = 
ValidateRequestDivestitureConfirmation; 

ValidateRequestDivestitureConfirmation = 
newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1139 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRequestFederationRestoreFailed 
getValidateRequestFederationRestoreFailed() 

{ 

return ValidateRequestFederatIonRestoreFailed; 


* 

previous 

* 

* 


Sets the Validation handler to the new value and returns 
one. 

@param newValidationHandler the new Validation handler 
@return the previous Validation handler 


*/ 

public ValidateRequestFederatIonRestoreFailed 


the 


setValidateRequestFederatIonRestoreFailed(ValidateRequestFederationRes 
toreFailed newValidationHandler) 


ValidateRequestFederatIonRestoreFailed r = 
ValidateRequestFederatIonRestoreFailed; 

validateRequestFederatIonRestoreFailed = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRequestFederationRestoreSucceeded 
getValidateRequestFederationRestoreSucceeded() 

{ 

return validateRequestFederationRestoreSucceeded; 


* 

previous 

* 

* 


Sets the Validation handler to the new value and returns the 
one. 

@param newValidationHandler the new Validation handler 
@return the previous Validation handler 


*/ 

public ValidateRequestFederationRestoreSucceeded 


setValidateRequestFederationRestoreSucceeded(ValidateRequestFederation 
RestoreSucceeded newValidationHandler) 


ValidateRequestFederationRestoreSucceeded r = 
ValidateRequestFederationRestoreSucceeded; 

valIdateRequestFederationRestoreSucceeded = 
newValidationHandler; 
return r; 


1140 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateRequestRetraction 
getValidateRequestRetraction() 

{ 

return validateRequestRetraction; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValIdateRequestRetraction 

setValIdateRequestRetraction(ValidateRequestRetraction 
newValidationHandler) 

{ 

ValIdateRequestRetraction r = valIdateRequestRetraction; 
valIdateRequestRetraction = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateStartRegistrationForObj ectClass 
getValidateStartRegistrationForObj ectClass () 

{ 

return ValidateStartRegistratIonForObj ectClass; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateStartRegistratIonForObj ectClass 

setValIdateStartRegistratIonForObjectClass(ValidateStartRegistrationFo 
rObj ectClass newValidationHandler) 

{ 

ValidateStartRegistratIonForObj ectClass r = 
valIdateStartRegistratIonForObj ectClass; 

ValidateStartRegistratIonForObj ectClass = 
newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1141 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateStopRegistrationForObj ectClass 
getValidateStopRegistrationForObj ectClass() 

{ 

return ValidateStopRegistratIonForObj ectClass; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateStopRegistratIonForObj ectClass 

setValidateStopRegistratIonForObj ectClass(ValidateStopRegistrationForO 
bjectClass newValidationHandler) 

{ 

ValidateStopRegistratIonForObj ectClass r = 
ValidateStopRegistratIonForObj ectClass; 

ValidateStopRegistratIonForObj ectClass = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateSynchronizationPointRegistrationFailed 
getValidateSynchronizationPointRegistrationFailed() 

{ 

return validateSynchronizatIonPointRegistrationFailed; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateSynchronizatIonPointRegistrationFailed 

setValidateSynchronizatIonPointRegistrationFailed(ValidateSynchronizat 
IonPointRegistrationFailed newValidationHandler) 

{ 

ValidateSynchronizatIonPointRegistrationFailed r = 
validateSynchronizatIonPointRegistrationFailed; 

validateSynchronizatIonPointRegistrationFailed = 
newValidationHandler; 
return r; 


1142 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateSynchronizationPointRegistrationSucceeded 
getValidateSynchronizationPointRegistrationSucceeded() 

{ 

return ValidateSynchronizatIonPointRegistrationSucceeded; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateSynchronizatIonPointRegistrationSucceeded 

setValidateSynchronizatIonPointRegistrationSucceeded(ValidateSynchroni 
zatIonPointRegistrationSucceeded newValidationHandler) 

{ 

ValidateSynchronizatIonPointRegistrationSucceeded r = 
ValidateSynchronizatIonPointRegistrationSucceeded; 

validateSynchronizatIonPointRegistrationSucceeded = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTimeAdvanceGrant 
getValidateTimeAdvanceGrant() 

{ 

return ValidateTimeAdvanceGrant; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTimeAdvanceGrant 

setValidateTimeAdvanceGrant(ValidateTimeAdvanceGrant 
newValidationHandler) 

{ 

ValidateTimeAdvanceGrant r = ValidateTimeAdvanceGrant; 
ValidateTimeAdvanceGrant = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1143 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTimeConstrainedEnabled 
getValidateTimeConstrainedEnabled() 

{ 

return ValidateTimeConstrainedEnabled; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTimeConstrainedEnabled 

setValidateTimeConstrainedEnabled(ValidateTimeConstrainedEnabled 
newValidationHandler) 

{ 

ValidateTimeConstrainedEnabled r = 
ValidateTimeConstrainedEnabled; 

ValidateTimeConstrainedEnabled = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTimeRegulationEnabled 
getValidateTimeRegulationEnabled() 

{ 

return ValidateTimeRegulationEnabled; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTimeRegulationEnabled 

setValidateTimeRegulationEnabled(ValidateTimeRegulationEnabled 
newValidationHandler) 

{ 

ValidateTimeRegulationEnabled r = 
ValidateTimeRegulationEnabled; 

ValidateTimeRegulationEnabled = newValidationHandler; 
return r; 


1144 


DRDC Valcartier TR 2007-412 



* * 


* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTurnlnteractionsOff 
getValidateTurnlnteractionsOff() 

{ 

return ValidateTurnlnteractionsOff; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTurnlnteractionsOff 

setValidateTurnlnteractionsOff(ValidateTurnlnteractionsOff 
newValidationHandler) 

{ 

ValidateTurnlnteractionsOff r = ValidateTurnlnteractionsOff; 
validateTurnlnteractionsOff = newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTurnlnteractionsOn 
getValidateTurnlnteractionsOn() 

{ 

return ValidateTurnlnteractionsOn; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTurnlnteractionsOn 

setValIdateTurnlnteractionsOn(ValidateTurnlnteractionsOn 
newValidationHandler) 

{ 

ValidateTurnlnteractionsOn r = ValidateTurnlnteractionsOn; 
validateTurnlnteractionsOn = newValidationHandler; 
return r; 


DRDC Valcartier TR 2007-412 


1145 



* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTurnUpdatesOffForObj ectInstance 
getValidateTurnUpdatesOffForObj ectlnstance() 

{ 

return ValidateTurnUpdatesOffForObj ectlnstance; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTurnUpdatesOffForObj ectlnstance 

setValidateTurnUpdatesOffForObj ectlnstance(ValidateTurnUpdatesOffForOb 
j ectlnstance newValidationHandler) 

{ 

ValidateTurnUpdatesOffForObj ectlnstance r = 
ValidateTurnUpdatesOffForObj ectlnstance; 

ValidateTurnUpdatesOffForObj ectlnstance = 
newValidationHandler; 
return r; 


j * * 

* Gets the current Validation handler. 

* @return the current Validation handler 

*/ 

public ValidateTurnUpdatesOnForObj ectlnstance 
getValidateTurnUpdatesOnForObj ectlnstance() 

{ 

return ValidateTurnUpdatesOnForObj ectlnstance; 


j * * 

* Sets the Validation handler to the new value and returns the 
previous one. 

* @param newValidationHandler the new Validation handler 

* @return the previous Validation handler 
*/ 

public ValidateTurnUpdatesOnForObj ectlnstance 

setValidateTurnUpdatesOnForObjectlnstance(ValidateTurnUpdatesOnForObj e 
ctInstance newValidationHandler) 

{ 

ValidateTurnUpdatesOnForObj ectlnstance r = 
ValidateTurnUpdatesOnForObj ectlnstance; 

ValidateTurnUpdatesOnForObj ectlnstance = 
newValidationHandler; 
return r; 


1146 


DRDC Valcartier TR 2007-412 



* * 


* ############################ 

* FederateAmbassador interface 

* ############################ 

*/ 

public void 

synchronizationPointRegistrationSucceeded( 

String synchronizationPointLabel) 
throws FederatelnternalError 
{ 

if (nulll=validateSynchronizationPointRegistrationSucceeded) 

validateSynchronizationPointRegistrationSucceeded.validate( 
synchronizationPointLabel); 

postEvent(evHLAsynchronizationPointRegistrationSucceeded.create( 
_identifier, 

synchronizationPointLabel) 

) ; 

} //synchronizationPointRegistrationSucceeded 
public void 

synchronizationPointRegistrationFailed( 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 
throws FederatelnternalError 
{ 

if (nulll=validateSynchronizationPointRegistrationFailed) 
validateSynchronizationPointRegistrationFailed.validate( 
synchronizationPointLabel, 
reason); 

postEvent(evHLAsynchronizationPointRegistrationFailed.create( 
_identifier, 

synchronizationPointLabel, 
reason) 

) ; 

} //synchronizationPointRegistrationFailed 
public void 

announceSynchronizationPoint( 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 
throws FederatelnternalError 
{ 

if (nulll=validateAnnounceSynchronizationPoint) 
validateAnnounceSynchronizationPoint.validate( 
synchronizationPointLabel, 
userSuppliedTag); 

postEvent(evHLAannounceSynchronizationPoint.create( 
_identifier, 

synchronizationPointLabel, 
userSuppliedTag) 

) ; 

} //announceSynchronizationPoint 


DRDC Valcartier TR 2007-412 


1147 



public void 

federationSynchronized( 

String synchronizationPointLabel) 
throws FederatelnternalError 
{ 

if (nulll=validateFederationSynchronized) 
validateFederationSynchronized.validate( 
synchronizationPointLabel); 

postEvent(evHLAfederationSynchronized.create( 
_identifier, 

synchronizationPointLabel) 

) ; 

} //federationSynchronized 

public void 
InitiateFederateSave( 

String label) 

throws UnableToPerformSave, 

FederatelnternalError 

{ 

if (nulll=validateInitiateFederateSave) 
validatelnitiateFederateSave.validate( 
label) ; 

postEvent(evHLAinitiateFederateSave.create( 
_identifier, 
label, 
null) 

) ; 

} //InitiateFederateSave 

public void 
InitiateFederateSave( 

String label, 

LogicalTime time) 
throws InvalidLogicalTime, 

UnableToPerformSave, 

FederatelnternalError 

{ 

if (nulll=validatelnitIateFederateSave) 
validatelnitiateFederateSave.validate( 
label, 
time) 

postEvent(evHLAinitIateFederateSave.create( 
_identifier, 
label, 
time) 

) ; 

} //InitiateFederateSave 


1148 


DRDC Valcartier TR 2007-412 



public void 
federationSaved() 
throws FederatelnternalError 
{ 

if (nulll=validateFederationSaved) 

validateFederationSaved.validate(); 

postEvent(evHLAfederationSaved.create( 

_identifier) 

) ; 

} //federationSaved 

public void 
federationNotSaved( 

SaveFailureReason reason) 
throws FederatelnternalError 
{ 

if (nulll=validateFederationNotSaved) 
validateFederationNotSaved.validate( 
reason); 

postEvent(evHLAfederationNotSaved.create( 

_identifier, 

reason) 

) ; 

} //federationNotSaved 
public void 

federationSaveStatusResponse( 

FederateHandleSaveStatusPair[] response) 
throws FederatelnternalError 
{ 

if (nulll=validateFederationSaveStatusResponse) 
validateFederationSaveStatusResponse.validate( 
response); 

postEvent(evHLAfederatIonSaveStatusResponse.create( 
_identifier, 
response) 

) ; 

} //federationSaveStatusResponse 
public void 

requestFederationRestoreSucceeded( 

String label) 

throws FederatelnternalError 

{ 

if (nulll=validateRequestFederatIonRestoreSucceeded) 
validateRequestFederatIonRestoreSucceeded.validate( 
label) ; 

postEvent(evHLArequestFederatIonRestoreSucceeded.create( 
_identifier, 
label) 

) ; 

} //requestFederatIonRestoreSucceeded 


DRDC Valcartier TR 2007-412 


1149 



public void 

requestFederationRestoreFailed( 

String label) 

throws FederatelnternalError 

{ 

if (nulll=validateRequestFederationRestoreFailed) 
validateRequestFederationRestoreFalied.validate( 
label) ; 

postEvent(evHLArequestFederationRestoreFailed.create( 
_identifier, 
label) 

) ; 

} //requestFederationRestoreFailed 
public void 

federationRestoreBegun() 
throws FederatelnternalError 
{ 

if (nulll=validateFederationRestoreBegun) 

validateFederationRestoreBegun.validate(); 

postEvent(evHLAfederationRestoreBegun.create( 
_identifier) 

) ; 

} //federationRestoreBegun 
public void 

InitiateFederateRestore( 

String label, 

FederateHandle federateHandle) 
throws SpecifiedSaveLabelDoesNotExist, 

CouldNotInitiateRestore, 

FederatelnternalError 

{ 

if (nulll=valIdatelnitiateFederateRestore) 
validatelnitiateFederateRestore.validate( 
label, 

federateHandle); 

postEvent(evHLAinitIateFederateRestore.create( 
_identifier, 
label, 

federateHandle) 

) ; 

} //InitiateFederateRestore 

public void 
federationRestored() 
throws FederatelnternalError 
{ 

if (nulll=validateFederationRestored) 

validateFederationRestored.validate(); 

postEvent(evHLAfederationRestored.create( 

_identifier) 

) ; 

} //federationRestored 


1150 


DRDC Valcartier TR 2007-412 



public void 
federationNotRestored( 

RestoreFailureReason reason) 
throws FederatelnternalError 
{ 

if (nulll=validateFederationNotRestored) 
validateFederationNotRestored.validate( 
reason); 

postEvent(evHLAfederationNotRestored.create( 
_identifier, 
reason) 

) ; 

} //federationNotRestored 
public void 

federationRestoreStatusResponse( 

FederateHandleRestoreStatusPair[] response) 
throws FederatelnternalError 
{ 

if (nulll=validateFederationRestoreStatusResponse) 
validateFederationRestoreStatusResponse.validate( 
response); 

postEvent(evHLAfederationRestoreStatusResponse.create( 
_identifier, 
response) 

) ; 

} //federationRestoreStatusResponse 
public void 

startRegistrationForObj ectClass( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError 

{ 

if (nulll=validateStartRegistrationForObj ectClass) 
validateStartRegistrationForObj ectClass.validate( 
theClass),- 

postEvent(evHLAstartRegistrationForObj ectClass.create) 
_identifier, 
theClass) 

) ; 

} //startRegistrationForObj ectClass 
public void 

stopRegistrationForObjectClass( 

Obj ectClassHandle theClass) 
throws Obj ectClassNotPublished, 

FederatelnternalError 

{ 

if (nulll=validateStopRegistrationForObj ectClass) 
validateStopRegistrationForObj ectClass.validate( 
theClass); 

postEvent(evHLAstopRegistrationForObjectClass.create) 
_identifier, 
theClass) 

) ; 

} //stopRegistratIonForObj ectClass 


DRDC Valcartier TR 2007-412 


1151 



public void 
turnlnteractionsOn( 

InteractionClassHandle theHandle) 
throws InteractionClassNotPublished, 

FederatelnternalError 

{ 

if (nulll=validateTurnInteractionsOn) 
validateTurnlnteractionsOn.validate( 
theHandle); 

postEvent(evHLAturnlnteractionsOn.create ( 

_identifier, 

theHandle) 

) ; 

} //turnlnteractionsOn 

public void 
turnlnteractionsOff( 

InteractionClassHandle theHandle) 
throws InteractIonClassNotPublished, 

FederatelnternalError 

{ 

if (nulll=validateTurnInteractionsOff) 
validateTurnlnteractionsOff.validate( 
theHandle); 

postEvent(evHLAturnlnteractionsOff.create( 

_identifier, 

theHandle) 

) ; 

} //turnlnteractionsOff 
public void 

obj ectlnstanceNameReservationSucceeded( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError 

{ 

if (nulll=validateObj ectlnstanceNameReservationSucceeded) 
validateObj ectlnstanceNameReservationSucceeded.validate( 
obj ectName) ; 

postEvent(evHLAobj ectlnstanceNameReservationSucceeded.create( 
_identifier, 
obj ectName) 

) ; 

} //obj ectlnstanceNameReservationSucceeded 


1152 


DRDC Valcartier TR 2007-412 



public void 

obj ectlnstanceNameReservationFailed( 

String obj ectName) 
throws UnknownName, 

FederatelnternalError 

{ 

if (nulll=validateObj ectlnstanceNameReservationFailed) 
validateObj ectInstanceNameReservationFalied.validate( 
obj ectName) ; 

postEvent(evHLAobj ectInstanceNameReservationFalied.create( 
_identifier, 
obj ectName) 

) ; 

} //obj ectInstanceNameReservationFalied 
public void 

discoverObj ectInstance( 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass, 

String obj ectName) 

throws CouldNotDiscover, 

Obj ectClassNotRecognized, 

FederatelnternalError 

{ 

if (nulll=validateDiscoverObj ectInstance) 
validateDiscoverObj ectInstance.validate( 
theObj ect, 
theObj ectClass, 
obj ectName) ; 

postEvent(evHLAdiscoverObj ectInstance.create( 

_identifier, 
theObj ect, 
theObj ectClass, 
obj ectName) 

) ; 

} //discoverObj ectInstance 


DRDC Valcartier TR 2007-412 


1153 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateReflectAttributeValues) 
validateReflectAttributeValues.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport) ,- 

postEvent(evHLAreflectAttributeValues.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
null, 
null, 
null, 
null) 

) ; 

} //reflectAttributeValues 


1154 


DRDC Valcartier TR 2007-412 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateReflectAttributeValues) 
validateReflectAttributeValues.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
sentRegions) ,- 

postEvent(evHLAreflectAttributeValues.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
null, 
null, 
null, 

sentRegions) 

) ; 

} //reflectAttributeValues 


DRDC Valcartier TR 2007-412 


1155 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateReflectAttributeValues) 
validateReflectAttributeValues.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering) ,- 

postEvent(evHLAreflectAttributeValues.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 

null, 

null) 

) ; 

} //reflectAttributeValues 


1156 


DRDC Valcartier TR 2007-412 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 
LogicalTime 
OrderType 
RegionHandleSet 
throws ObjectInstanceNotKnown 
AttributeNotRecognized, 

At tributeNotSubscribed, 
FederatelnternalError 


theObject, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
sentRegions) 


if (nulll=validateReflectAttributeValues) 
validateReflectAttributeValues.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
sentRegions) ,- 

postEvent(evHLAreflectAttributeValues.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 

null, 

sentRegions) 

) ; 

} //reflectAttributeValues 


DRDC Valcartier TR 2007-412 


1157 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError 

{ 

if (nulll=validateReflectAttributeValues) 
validateReflectAttributeValues.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle) ,- 

postEvent(evHLAreflectAttributeValues.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
null) 

) ; 

} //reflectAttributeValues 


1158 


DRDC Valcartier TR 2007-412 



public void 

reflectAttributeValues( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleValueMap theAttributes, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle, 
RegionHandleSet sentRegions) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

InvalidLogicalTime, 

FederatelnternalError 

{ 

if (nulll=validateReflectAttributeValues) 
validateReflectAttributeValues.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
sentRegions) ,- 

postEvent(evHLAreflectAttributeValues.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
retractionHandle, 
sentRegions) 

) ; 

} //reflectAttributeValues 


DRDC Valcartier TR 2007-412 


1159 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateReceiveInteraction) 
validateReceiveInteraction.validate( 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport) ,- 

postEvent(evHLAreceiveInteraction.create( 
_identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
null, 
null, 
null, 
null) 

) ; 

} //receivelnteraction 


1160 


DRDC Valcartier TR 2007-412 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateReceiveInteraction) 
validateReceiveInteraction.validate( 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
sentRegions) ,- 

postEvent(evHLAreceiveInteraction.create( 
_identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
null, 
null, 
null, 

sentRegions) 

) ; 

} //receivelnteraction 


DRDC Valcartier TR 2007-412 


1161 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 
InteractionClassNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateReceiveInteraction) 
validateReceiveInteraction.validate( 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering) ,- 

postEvent(evHLAreceiveInteraction.create( 
_identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 

null, 

null) 

) ; 

} //receivelnteraction 


1162 


DRDC Valcartier TR 2007-412 



public void 
receivelnteraction( 

InteractionClassHandle 


interactionClass 


ParameterHandleValueMap theParameters 


byte[] 

OrderType 

TransportationType 
LogicalTime 
OrderType 
RegionHandleSet 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized 
InteractionClassNotSubscribed, 
FederatelnternalError 


userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
sentRegions) 


if (nulll=validateReceiveInteraction) 
validateReceiveInteraction.validate( 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
sentRegions) ,- 

postEvent(evHLAreceiveInteraction.create( 
_identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 

null, 

sentRegions) 

) ; 

} //receivelnteraction 


DRDC Valcartier TR 2007-412 


1163 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle) 
throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederatelnternalError 

{ 

if (nulll=validateReceiveInteraction) 
validateReceiveInteraction.validate( 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
messageRetractionHandle) ,- 
postEvent(evHLAreceiveInteraction.create( 
_identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
messageRetractionHandle, 
null) 

) ; 

} //receivelnteraction 


1164 


DRDC Valcartier TR 2007-412 



public void 
receivelnteraction( 

InteractionClassHandle interactionClass, 
ParameterHandleValueMap theParameters, 
byte[] userSuppliedTag, 

OrderType sentOrdering, 

TransportationType theTransport, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle messageRetractionHandle 
RegionHandleSet sentRegions) 

throws InteractionClassNotRecognized, 

InteractionParameterNotRecognized, 

InteractionClassNotSubscribed, 
InvalidLogicalTime, 

FederatelnternalError 

{ 

if (nulll=validateReceiveInteraction) 
validateReceiveInteraction.validate( 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
messageRetractionHandle, 
sentRegions) ,- 

postEvent(evHLAreceiveInteraction.create( 
_identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
messageRetractionHandle, 
sentRegions) 

) ; 

} //receivelnteraction 


DRDC Valcartier TR 2007-412 


1165 



public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 
byte[] userSuppliedTag 

OrderType sentOrdering) 

throws Obj ectlnstanceNotKnown, 
FederatelnternalError 


if (nulll=validateRemoveObj ectlnstance) 
validateRemoveObj ectlnstance.validate( 
theObj ect, 
userSuppliedTag, 
sentOrdering),- 

postEvent(evHLAremoveObj ectlnstance.create( 
_identifier, 
theObj ect, 
userSuppliedTag, 
sentOrdering, 
null, 
null, 
null) 

) ; 

} //removeObj ectlnstance 


public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle 
byte [] 

OrderType 
LogicalTime 
OrderType 
throws Obj ectlnstanceNotKnown 
FederatelnternalError 


theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering) 


if (nulll=validateRemoveObj ectlnstance) 
validateRemoveObj ectlnstance.validate( 
theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering) ,- 

postEvent(evHLAremoveObj ectlnstance.create( 
_identifier, 
theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 

null) 

) ; 

} //removeObj ectlnstance 


1166 


DRDC Valcartier TR 2007-412 



public void 
removeObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

byte[] userSuppliedTag, 

OrderType sentOrdering, 

LogicalTime theTime, 

OrderType receivedOrdering, 

MessageRetractionHandle retractionHandle) 
throws Obj ectInstanceNotKnown, 
InvalidLogicalTime, 
FederatelnternalError 

{ 

if (nulll=validateRemoveObjectlnstance) 
validateRemoveObj ectInstance.validate( 
theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 
retractionHandle) ,- 

postEvent(evHLAremoveObj ectlnstance.create( 
_identifier, 
theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 

retractionHandle) 

) ; 

} //removeObj ectlnstance 

public void 
attributesInScope( 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 
FederatelnternalError 

{ 

if (nulll=validateAttributesInScope) 
valIdateAttributesInScope.validate( 
theObj ect, 
theAttributes) ,- 

postEvent(evHLAattributesInScope.create( 
_identifier, 
theObj ect, 
theAttributes) 

) ; 

} //attributesInScope 


DRDC Valcartier TR 2007-412 


1167 



public void 
attributesOutOfScope( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotSubscribed, 

FederatelnternalError 

{ 

if (nulll=validateAttributesOutOfScope) 
validateAttributesOutOfScope.validate( 
theObj ect, 
theAttributes),- 

postEvent(evHLAattributesOutOfScope.create( 
_identifier, 
theObj ect, 
theAttributes) 

) ; 

} //attributesOutOfScope 
public void 

provideAttributeValueUpdate( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (nulll=validateProvideAttributeValueUpdate) 
validateProvideAttributeValueUpdate.validate( 
theObj ect, 
theAttributes, 
userSuppliedTag) ,- 

postEvent(evHLAprovideAttributeValueUpdate.create( 
_identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag) 

) ; 

} //provideAttributeValueUpdate 


1168 


DRDC Valcartier TR 2007-412 



public void 

turnUpdatesOnForObjectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (nulll=validateTurnUpdatesOnForObj ectlnstance) 
validateTurnUpdatesOnForObj ectlnstance.validate( 
theObj ect, 
theAttributes) ,- 

postEvent(evHLAturnUpdatesOnForObj ectlnstance.create( 
_identifier, 
theObj ect, 
theAttributes) 

) ; 

} //turnUpdatesOnForObj ectlnstance 
public void 

turnUpdatesOffForObj ectlnstance( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 
throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (nulll=validateTurnUpdatesOffForObj ectlnstance) 
valIdateTurnUpdatesOffForObjectlnstance.validate( 
theObj ect, 
theAttributes) ,- 

postEvent(evHLAturnUpdatesOffForObj ectlnstance.create ( 
_identifier, 
theObj ect, 
theAttributes) 

) ; 

} //turnUpdatesOffForObj ectlnstance 


DRDC Valcartier TR 2007-412 


1169 



public void 

requestAttributeOwnershipAssumption( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes, 

byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError 

{ 

if (nulll=validateRequestAttributeOwnershipAssumption) 
validateRequestAttributeOwnershipAssumption.validate( 
theObj ect, 
offeredAttributes, 
userSuppliedTag),- 

postEvent(evHLArequestAttributeOwnershipAssumption.create( 
_identifier, 
theObj ect, 
offeredAttributes, 
userSuppliedTag) 

) ; 

} //requestAttributeOwnershipAssumption 
public void 

requestDivestitureConfirmation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

AttributeDivestItureWasNotRequested, 
FederatelnternalError 

{ 

if (nulll=validateRequestDivestitureConfirmation) 
validateRequestDivestitureConfirmation.validate( 
theObj ect, 
offeredAttributes) ,- 

postEvent(evHLArequestDivestitureConfirmation.create( 
_identifier, 
theObj ect, 
offeredAttributes) 

) ; 

} //requestDivestitureConfirmation 


1170 


DRDC Valcartier TR 2007-412 



public void 

attributeOwnershipAcquisitionNotification( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet securedAttributes, 
byte[] userSuppliedTag) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeAcquisitionWasNotRequested, 
AttributeAlreadyOwned, 

AttributeNotPublished, 

FederatelnternalError 

{ 

if (nulll=■validateAttributeOwnershipAcquisitionNotifloation) 

validateAttributeOwnershipAcquisitionNotification.validate( 
theObj ect, 
securedAttributes, 
userSuppliedTag) ,- 

postEvent(evHLAattributeOwnershipAcquisitionNotifloation.create( 
_identifier, 
theObj ect, 
securedAttributes, 
userSuppliedTag) 

) ; 

} //attributeOwnershipAcquisitionNotification 
public void 

attributeOwnershipUnavailable( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitIonWasNotRequested, 
FederatelnternalError 

{ 

if (nulll=validateAttributeOwnershipUnavailable) 
valIdateAttributeOwnershipUnavaliable.validate( 
theObj ect, 
theAttributes) ,- 

postEvent(evHLAattributeOwnershipUnavailable.create( 
_identifier, 
theObj ect, 
theAttributes) 

) ; 

} //attributeOwnershipUnavailable 


DRDC Valcartier TR 2007-412 


1171 



public void 

requestAttributeOwnershipRelease( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet candidateAttributes, 
byte[] userSuppliedTag) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeNotOwned, 

FederatelnternalError 

{ 

if (nulll=validateRequestAttributeOwnershipRelease) 
validateRequestAttributeOwnershipRelease.validate( 
theObj ect, 

candidateAttributes, 
userSuppliedTag),- 

postEvent(evHLArequestAttributeOwnershipRelease.create( 
_identifier, 
theObj ect, 

candidateAttributes, 
userSuppliedTag) 

) ; 

} //requestAttributeOwnershipRelease 
public void 

confIrmAttributeOwnershipAcquisitionCancellation( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

throws Obj ectlnstanceNotKnown, 

AttributeNotRecognized, 

AttributeAlreadyOwned, 

AttributeAcquisitionWasNotCanceled, 
FederatelnternalError 


if 

(nulll=validateConfIrmAttributeOwnershipAcquisitionCancellation) 

validateConfIrmAttributeOwnershipAcquisitionCancellation.validate( 
theObj ect, 
theAttributes) ,- 

postEvent(evHLAconfIrmAttributeOwnershipAcquisitionCancellation.create 

( 

_identifier, 
theObj ect, 
theAttributes) 

) ; 

} //confIrmAttributeOwnershipAcquisitionCancellation 


1172 


DRDC Valcartier TR 2007-412 



public void 

informAttributeOwnership( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute, 

FederateHandle theOwner) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
FederatelnternalError 

{ 

if (nulll=validateInformAttributeOwnership) 
validatelnformAttributeOwnership.validate( 
theObj ect, 
theAttribute, 
theOwner) ,- 

postEvent(evHLAinformAttributeOwnership.create( 
_identifier, 
theObj ect, 
theAttribute, 
theOwner) 

) ; 

} //informAttributeOwnership 

public void 
attributelsNotOwned( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectInstanceNotKnown, 

AttributeNotRecognized, 
FederatelnternalError 

{ 

if (nulll=validateAttributeIsNotOwned) 
valIdateAttributeIsNotOwned.validate( 
theObj ect, 
theAttribute) ,- 

postEvent(evHLAattributelsNotOwned.create( 
_identifier, 
theObj ect, 
theAttribute) 

) ; 

} //attributelsNotOwned 


DRDC Valcartier TR 2007-412 


1173 



public void 
attributelsOwnedByRTI( 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

throws Obj ectlnstanceNotKnown, 
AttributeNotRecognized, 
FederatelnternalError 

{ 

if (nulll=validateAttributeIsOwnedByRTI) 
validateAttributelsOwnedByRTI.validate( 
theObj ect, 
theAttribute); 

postEvent(evHLAattributelsOwnedByRTI.create( 
_identifier, 
theObj ect, 
theAttribute) 

) ; 

} //attributelsOwnedByRTI 

public void 
timeRegulationEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeRegulationWaspending, 
FederatelnternalError 

{ 

if (nulll=validateTimeRegulationEnabled) 
validateTimeRegulationEnabled.validate( 
time) ; 

postEvent(evHLAtimeRegulationEnabled.create ( 
_identifier, 
time) 

) ; 

} //timeRegulationEnabled 
public void 

timeConstrainedEnabled( 

LogicalTime time) 
throws InvalidLogicalTime, 

NoRequestToEnableTimeConstrainedWasPending 

FederatelnternalError 

{ 

if (nulll=validateTimeConstrainedEnabled) 
validateTimeConstrainedEnabled.validate( 
time) ; 

postEvent(evHLAtImeConstrainedEnabled.create( 
_identifier, 
time) 

) ; 

} //timeConstrainedEnabled 


1174 


DRDC Valcartier TR 2007-412 



public void 
timeAdvanceGrant( 

LogicalTime theTime) 
throws InvalidLogicalTime, 

JoinedFederatelsNotInTimeAdvancingState 
FederatelnternalError 

{ 

if (nulll=validateTimeAdvanceGrant) 
validateTimeAdvanceGrant.validate( 
theTime); 

postEvent(evHLAtimeAdvanceGrant.create( 
_identifier, 
theTime) 

) ; 

} //timeAdvanceGrant 

public void 
requestRetraction( 

MessageRetractionHandle theHandle) 
throws FederatelnternalError 
{ 

if (nulll=validateRequestRetraction) 
valIdateRequestRetraction.validate( 
theHandle); 

postEvent(evHLArequestRetraction.create( 
_identifier, 
theHandle) 

) ; 

} //requestRetraction 
} //HLAfederate 

} 

//end capHLA1516 


DRDC Valcartier TR 2007-412 


1175 



The blfHLA belief set is a simple hash map used by the event-handling plans to 
retrieve the HLAf ederate instance associated with the callback. 


// File: blfHLA.bel 

package ca.gc.drdc_rddc.hla.rtil516.jack; 

j * * 

Matches the HLAfederate identifiers with their instance references 
The complex queries hasKey, getlnstance and removelnstance all expect 
an identifier String argument. 

The first one returns true if a tuple featuring this identifier 
exists, false otherwise. 

The second one returns the HLAfederate instance matched to the 
identifier, null otherwise. 

The last one returns true if the tuple was removed, false otherwise. 

*/ 

public beliefset 
blfHLA 

extends ClosedWorld 

{ 

#key field String identifier; 

#value field Object instance,- 

#indexed query get (String identifier, Object instance) ,- 
#indexed query get (logical String identifier, Object instance) ,- 
#indexed query get (String identifier, logical Object instance) ,- 
#indexed query get(logical String identifier, logical Object 
instance) ,- 

#function query public boolean hasKey(String identifier) 

{ 

logical Object $some_instance,- 
try 


// Check whether or not there already exists an instance with 
that identifier 

return get( identifier, $some_instance ).next(); 

} catch (aos.jack.jak.beliefset.BeliefSetException bse) { 
bse . printStackTrace () ,- 
} //try 
return false; 

} //hasKey 


1176 


DRDC Valcartier TR 2007-412 



#function query public capHLA1516.HLAfederate getlnstance(String 
identifier) 

{ 

logical Object $some_instance,- 
try 


if (l get( identifier, $some_instance ).next() ) return null; 
return (capHLA1516.HLAfederate) ($some_instance.as_obj ect () ) ,- 
} catch (aos.jack.jak.beliefset.BeliefSetException bse) { 
bse.printStackTrace(),- 
} //try 
return null; 

} //getlnstance 

#function query public boolean removelnstance(String identifier) 

{ 

logical Object $some_instance,- 
try 


if (get( identifier, $some_instance ).next()) 

{ 

remove (identifier, $some_instance . as_ob j ect () ) ,- 
return true; 

} //if 

} catch (aos.jack.jak.beliefset.BeliefSetException bse) { 
bse . printStackTrace () ,- 
} //try 
return false; 

} //removelnstance 

} 

//end blfHLA 


DRDC Valcartier TR 2007-412 


1177 



The 43 events all follow the same pattern: their fields consist of a string identifier 
and the callback’s parameters. They have just one constructor each. When a 
byte [ ] appears in the parameters, it is wrapped in an OMT HLAopaqueData to 
avoid JACK compilation errors. 


// File : evtHLAannounceSynchronizationPoint.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hla.rtil516.omt.*; 
import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that a new synchronization 
point has been registered. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLAannounceSynchronizationPoint extends MessageEvent { 
public String identifier- 
public String synchronizationPointLabel; 
public HLAopaqueData userSuppliedTag; 

#posted as 
create ( 

String identifier, 

String synchronizationPointLabel, 
byte[] userSuppliedTag) 

{ 

this.identifier = identifier; 

this.synchronizationPointLabel = synchronizationPointLabel; 
try { 

this.userSuppliedTag = new HLAopaqueData(userSuppliedTag); 

} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 


//end evtHLAannounceSynchronizationPoint 


1178 


DRDC Valcartier TR 2007-412 



// File: evtHLAattributeIsNotOwned.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 


Occurs when the RTI answers the federate's QueryAttributeOwnership 
request. 

The specified attribute is unowned. 

*/ 

public event evtHLAattributelsNotOwned extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObject; 
public AttributeHandle theAttribute; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

{ 

this.identifier = identifier; 

this.theObject = theObject; 

this.theAttribute = theAttribute; 


//end evtHLAattributelsNotOwned 

// File: evtHLAattributelsOwnedByRTI.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 


Occurs when the RTI answers the federate's QueryAttributeOwnership 
request. 

The specified attribute is owned by the RTI. 

*/ 

public event evtHLAattributelsOwnedByRTI extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect; 
public AttributeHandle theAttribute; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandle theAttribute) 

{ 

this.identifier = identifier; 

this.theObject = theObject; 

this.theAttribute = theAttribute; 


//end evtHLAattributelsOwnedByRTI 


DRDC Valcartier TR 2007-412 


1179 



// File: evtHLAattributeOwnershipAcquisitionNotification.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hla.rtil516.omt.*,- 
import hla.rtil516.*; 


j * * 

Occurs when the RTI notifies the federate that the latter now owns the 
specified attribute instances. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLAattributeOwnershipAcquisitionNotification extends 
MessageEvent { 

public String identifier- 
public Obj ectlnstanceHandle theObj ect,- 
public AttributeHandleSet securedAttributes,- 
public HLAopaqueData userSuppliedTag,- 


#posted as 
create ( 

String 

Obj ectlnstanceHandle 
AttributeHandleSet 
byte[] 


identifier, 
theObj ect, 
securedAttributes 
userSuppliedTag) 


this . identifier = identifier,- 

this . theObj ect = theObj ect ,- 

this . securedAttributes = securedAttributes ,- 

try { 

this .userSuppliedTag = new HLAopaqueData (userSuppliedTag) ,- 
} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 


//end evtHLAattributeOwnershipAcquisitionNotification 


1180 


DRDC Valcartier TR 2007-412 



// File: evtHLAattributeOwnershipUnavaliable.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516; 

j * * 

Occurs when the RTI informs the federate that the specified attribute 
instances are not available for acquisition. 

*/ 

public event evtHLAattributeOwnershipUnavailable extends MessageEvent 

{ 

public String identifier- 

public Obj ectlnstanceHandle theObject; 

public AttributeHandleSet theAttributes; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

{ 

this.identifier = identifier; 
this.theObject = theObject; 

this.theAttributes = theAttributes; 


//end evtHLAattributeOwnershipUnavailable 

// File: evtHLAattributesInScope.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI advises the federate that the specified attribute 
instances are now in scope. 

*/ 

public event evtHLAattributesInScope extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect; 
public AttributeHandleSet theAttributes; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

{ 

this.identifier = identifier; 
this.theObject = theObject; 

this.theAttributes = theAttributes; 


//end evtHLAattributesInScope 


DRDC Valcartier TR 2007-412 


1181 



// File: evtHLAattributesOutOfScope.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI advises the federate that the specified attribute 
instances are now out of scope. 

*/ 

public event evtHLAattributesOutOfScope extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect; 
public AttributeHandleSet theAttributes; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

{ 

this.identifier = identifier; 
this.theObject = theObject; 

this.theAttributes = theAttributes; 


//end evtHLAattributesOutOfScope 

// File: evtHLAconfIrmAttributeOwnershipAcquisitionCancellation.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI requests that the federate confirm its intent to 
cancel the pending acquisition of the specified instance attributes. 

*/ 

public event evtHLAconfirmAttributeOwnershipAcquisitionCancellation 
extends MessageEvent { 

public String identifier- 

public Obj ectlnstanceHandle theObj ect; 

public AttributeHandleSet theAttributes; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

{ 

this.identifier = identifier; 
this.theObject = theObject; 

this.theAttributes = theAttributes; 


//end evtHLAconfIrmAttributeOwnershipAcquisitionCancellation 


1182 


DRDC Valcartier TR 2007-412 



// File: evtHLAdiscoverObj ectInstance.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 


j * * 

Occurs when the federate discovers a new object instance. 
*/ 


public event evtHLAdiscoverObjectlnstance extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect; 
public Obj ectClassHandle theObj ectClass; 
public String objectName; 


#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

Obj ectClassHandle theObj ectClass 

String obj ectName) 


this.identifier = identifier; 

this.theObject = theObject; 

this.theObj ectClass = theObj ectClass; 

this.objectName = objectName; 


//end evtHLAdiscoverObj ectlnstance 

// File: evtHLAfederationNotRestored.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that the federation restore 
concluded unsuccessfully. 

*/ 

public event evtHLAfederationNotRestored extends MessageEvent { 
public String identifier- 
public RestoreFailureReason reason; 

#posted as 
create ( 

String identifier, 

RestoreFailureReason reason) 

{ 

this.identifier = identifier; 
this.reason = reason; 


//end evtHLAfederationNotRestored 


DRDC Valcartier TR 2007-412 


1183 



// File: evtHLAfederationNotSaved.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that the federation save 
concluded unsuccessfully. 

*/ 

public event evtHLAfederationNotSaved extends MessageEvent { 
public String identifier- 
public SaveFailureReason reason; 

#posted as 
create ( 

String identifier, 

SaveFailureReason reason) 

{ 

this.identifier = identifier; 
this.reason = reason; 


//end evtHLAfederationNotSaved 

// File: evtHLAfederationRestoreBegun.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that the federation restore 
has begun. 

*/ 

public event evtHLAfederationRestoreBegun extends MessageEvent { 
public String identifier; 

#posted as 
create ( 

String identifier) 

{ 

this.identifier = identifier; 


//end evtHLAfederationRestoreBegun 


1184 


DRDC Valcartier TR 2007-412 



// File: evtHLAfederationRestored.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI notifies the federate that the federation restore 
concluded successfully. 

*/ 

public event evtHLAfederationRestored extends MessageEvent { 
public String identifier; 

#posted as 
create( 

String identifier) 

{ 

this.identifier = identifier; 


//end evtHLAfederationRestored 

// File: evtHLAfederationRestoreStatusResponse.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI responds to the federate's query about the 
federation restore status. 

*/ 

public event evtHLAfederationRestoreStatusResponse extends 
MessageEvent { 

public String identifier- 

public FederateHandleRestoreStatusPair[] response; 

#posted as 
create ( 

String identifier, 

FederateHandleRestoreStatusPair[] response) 

{ 

this.identifier = identifier; 
this.response = response; 


//end evtHLAfederationRestoreStatusResponse 


DRDC Valcartier TR 2007-412 


1185 



// File: evtHLAfederationSaved.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that the federation save 
concluded successfully. 

*/ 

public event evtHLAfederationSaved extends MessageEvent { 
public String identifier; 

#posted as 
create ( 

String identifier) 

{ 

this.identifier = identifier; 


//end evtHLAfederationSaved 

// File: evtHLAfederationSaveStatusResponse.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI responds to the federate's query about the 
federation save status. 

*/ 

public event evtHLAfederationSaveStatusResponse extends MessageEvent { 
public String identifier- 

public FederateHandleSaveStatusPair[] response; 

#posted as 
create ( 

String identifier, 

FederateHandleSaveStatusPair[] response) 

{ 

this.identifier = identifier; 
this.response = response; 


//end evtHLAfederationSaveStatusResponse 


1186 


DRDC Valcartier TR 2007-412 



// File: evtHLAfederationSynchronized.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI notifies the federate that the specified 
synchronization point has been achieved. 

*/ 

public event evtHLAfederationSynchronized extends MessageEvent { 
public String identifier- 
public String synchronizationPointLabel; 

#posted as 
create ( 

String identifier, 

String synchronizationPointLabel) 

{ 

this.identifier = identifier; 

this.synchronizationPointLabel = synchronizationPointLabel; 


//end evtHLAfederationSynchronized 


// File: evtHLAinformAttributeOwnership.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 


j * * 

Occurs when the RTI answers the federate's QueryAttributeOwnership 
request. 

The specified attribute is owned by the specified federate. 

*/ 


public event evtHLAinformAttributeOwnership extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect; 
public AttributeHandle theAttribute; 
public FederateHandle theOwner; 


#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 
AttributeHandle theAttribute 

FederateHandle theOwner) 


this.identifier = identifier; 

this.theObject = theObject; 

this.theAttribute = theAttribute; 

this.theOwner = theOwner; 


//end evtHLAinformAttributeOwnership 


DRDC Valcartier TR 2007-412 


1187 



// File: evtHLAinitiateFederateRestore.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that it should start 
restoring its state. 

*/ 

public event evtHLAinitiateFederateRestore extends MessageEvent { 
public String identifier- 
public String label; 

public FederateHandle federateHandle,- 

#posted as 
create ( 

String identifier, 

String label, 

FederateHandle federateHandle) 

{ 

this.identifier = identifier; 

this.label = label; 

this.federateHandle = federateHandle,- 


//end evtHLAinitiateFederateRestore 

// File: evtHLAinitiateFederateSave.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that it should start saving 
its state. 

If a time is specified, that is the time at which the save should 
occur. 

*/ 

public event evtHLAinitiateFederateSave extends MessageEvent { 
public String identifier- 
public String label; 
public LogicalTime time; 

#posted as 
create ( 

String identifier, 

String label, 

LogicalTime time) 

{ 

this . identifier = identifier,- 
this.label = label; 

this.time = time; 


//end evtHLAinitiateFederateSave 


1188 


DRDC Valcartier TR 2007-412 



// File: evtHLAobj ectInstanceNameReservationFailed.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI notifies the federate that its name reservation 
request failed. 

*/ 

public event evtHLAobj ectInstanceNameReservationFailed extends 
MessageEvent { 

public String identifier- 
public String objectName; 

#posted as 
create ( 

String identifier, 

String obj ectName) 

{ 

this.identifier = identifier; 
this.objectName = objectName; 

} 

} 

//end evtHLAobj ectInstanceNameReservationFailed 

// File: evtHLAobj ectInstanceNameReservationSucceeded.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that its name reservation 
request succeeded. 

*/ 

public event evtHLAobj ectInstanceNameReservationSucceeded extends 
MessageEvent { 

public String identifier- 
public String objectName; 

#posted as 
create ( 

String identifier, 

String obj ectName) 

{ 

this.identifier = identifier; 
this.objectName = objectName; 

} 

} 

//end evtHLAobj ectInstanceNameReservationSucceeded 


DRDC Valcartier TR 2007-412 


1189 



// File : evtHLAprovideAttributeValueUpdate.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hla.rtil516.omt.*,- 
import hla.rtil516.*; 


j * * 

Occurs when the RTI requests an update of some of an object's 
attribute values. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLAprovideAttributeValueUpdate extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect,- 
public AttributeHandleSet theAttributes,- 
public HLAopaqueData userSuppliedTag,- 


#posted as 
create ( 

String 

Obj ectlnstanceHandle 
AttributeHandleSet 
byte[] 


identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag) 


this . identifier = identifier,- 

this.theObject = theObject; 

this . theAttributes = theAttributes ,- 

try { 

this .userSuppliedTag = new HLAopaqueData (userSuppliedTag) ,- 
} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 


//end evtHLAprovideAttributeValueUpdate 


1190 


DRDC Valcartier TR 2007-412 



// File: evtHLAreceivelnteraction.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hia.rt11516.omt.*,- 
import hla.rtil516.*; 


j * * 

Occurs when an interaction happens. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLAreceivelnteraction extends MessageEvent { 
public String identifier- 

public InteractionClassHandle interactionClass,- 

public ParameterHandleValueMap theParameters,- 

public HLAopaqueData userSuppliedTag,- 

public OrderType sentOrdering,- 

public TransportationType theTransport,- 

public LogicalTime theTime; 

public OrderType receivedOrdering,- 

public MessageRetractionHandle me ssageRe tract ionHandle,- 
public RegionHandleSet sentRegions,- 


#posted as 
create ( 

String 

InteractionClassHandle 
ParameterHandleValueMap 
byte[] 

OrderType 

TransportationType 
LogicalTime 
OrderType 

MessageRetractionHandle 
RegionHandleSet 

{ 

this.identifier 
this.interactionClass = 
this.theParameters 
try { 

this.userSuppliedTag 
} catch (Exception igno 
userSuppliedTag 

this.sentOrdering 
this.theTransport 
this.theTime 
this.receivedOrdering 
this.messageRetractionHandle 
this.sentRegions 


identifier, 
interactionClass, 
theParameters, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering, 
messageRetractionHandle, 
sentRegions) 

identifier; 
interact ionClass ,- 
theParameters ,- 

= new HLAopaqueData (userSuppliedTag) ,- 
d) {} //CouldNotDecode, null 

= sentOrdering; 

= theTransport ,- 
= theTime ,- 
= rece ivedOr dering ,- 
= me ssageRetr act ionHandle ,- 
= sentRegions ,- 


//end evtHLAreceivelnteraction 


DRDC Valcartier TR 2007-412 


1191 



// File : evtHLAreflectAttributeValues.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hla.rtil516.omt.*,- 
import hla.rtil516.*; 


j * * 

Occurs when the RTI supplies an update for a subscribed object's 
attribute(s). 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLAreflectAttributeValues extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect,- 
public AttributeHandleValueMap theAttributes,- 
public HLAopaqueData userSuppliedTag,- 
public OrderType sentOrdering,- 
public TransportationType theTransport,- 
public LogicalTime theTime; 
public OrderType receivedOrdering; 
public MessageRetractionHandle retract ionHandle,- 
public RegionHandleSet sentRegions,- 


#posted as 
create ( 

String 

Obj ectlnstanceHandle 
AttributeHandleValueMap 
byte[] 

OrderType 

TransportationType 

LogicalTime 

OrderType 

MessageRetractionHandle 

RegionHandleSet 


identifier, 
theObj ect, 
theAttributes, 
userSuppliedTag, 
sentOrdering, 
theTransport, 
theTime, 

receivedOrdering 
retractionHandle 
sentRegions) 


this . identifier = identifier,- 

this . theObj ect = theObj ect ,- 

this . theAttributes = theAttributes ,- 
try { 

this .userSuppliedTag = new HLAopaqueData (userSuppliedTag) ,- 
} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 

this.sentOrdering = sentOrdering,- 

this . theTransport = theTransport ,- 

this.theTime = theTime; 

this . receivedOrdering = receivedOrdering,- 
this . retract ionHandle = retract ionHandle ,- 
this . sentRegions = sentRegions ,- 


//end evtHLAreflectAttributeValues 


1192 


DRDC Valcartier TR 2007-412 



// File: evtHLAremoveObjectInstance.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hia.rt11516.omt.*,- 
import hla.rtil516.*; 


j * * 

Occurs when the RTI informs the federate that an object instance has 
been deleted. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLAremoveObjectlnstance extends MessageEvent { 
public String identifier- 
public Obj ectlnstanceHandle theObj ect; 
public HLAopaqueData userSuppliedTag,- 
public OrderType sentOrdering,- 
public LogicalTime theTime; 
public OrderType receivedOrdering,- 
public MessageRetractionHandle retractionHandle,- 


#posted as 
create ( 

String 

Obj ectlnstanceHandle 
byte[ ] 

OrderType 

LogicalTime 

OrderType 

MessageRetractionHandle 


identifier, 
theObj ect, 
userSuppliedTag, 
sentOrdering, 
theTime, 

receivedOrdering, 
retractionHandle) 


this.identifier = identifier; 

this.theObject = theObject; 

try { 


this .userSuppliedTag = new HLAopaqueData (userSuppliedTag) ,- 
} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 

sentOrdering; 
theTime ,- 

receivedOrdering,- 
retract ionHandle ,- 


this.sentOrdering 
this.theTime 
this.receivedOrdering 
this.retractionHandle 


//end evtHLAremoveObj ectInstance 


DRDC Valcartier TR 2007-412 


1193 



// File: evtHLArequestAttributeOwnershipAssumption.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hla.rtil516.omt.*,- 
import hla.rtil516.*; 


j * * 

Occurs when the RTI requests that the federate assume ownership of 
some attribute instances. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLArequestAttributeOwnershipAssumption extends 
MessageEvent { 

public String identifier- 
public Obj ectlnstanceHandle theObj ect,- 
public AttributeHandleSet offeredAttributes,- 
public HLAopaqueData userSuppliedTag,- 


#posted as 
create ( 

String 

Obj ectlnstanceHandle 
AttributeHandleSet 
byte[] 


identifier, 
theObj ect, 
offeredAttributes 
userSuppliedTag) 


this . identifier = identifier,- 

this . theObj ect = theObj ect ,- 

this . of feredAttributes = of feredAttributes ,- 

try { 

this .userSuppliedTag = new HLAopaqueData (userSuppliedTag) ,- 
} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 


//end evtHLArequestAttributeOwnershipAssumption 


1194 


DRDC Valcartier TR 2007-412 



// File: evtHLArequestAttributeOwnershipRelease.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import ca.gc.drdc_rddc.hia.rt11516.omt.*,- 
import hla.rtil516.*; 


Occurs when the RTI requests that the federate relinquish ownership of 
the specified attribute instances. 

Note that JACK baulks at byte[] fields, so we use an HLAopaqueData 
field to wrap the userSuppliedTag. 

*/ 

public event evtHLArequestAttributeOwnershipRelease extends 
MessageEvent { 

public String identifier- 

public Obj ectlnstanceHandle theObject; 

public AttributeHandleSet candidateAttributes,- 

public HLAopaqueData userSuppliedTag,- 


#posted as 
create ( 

String 

Obj ectlnstanceHandle 
AttributeHandleSet 
byte[ ] 


identifier, 
theObject, 
candidateAttributes 
userSuppliedTag) 


this.identifier = identifier; 

this.theObject = theObject; 

this . candidateAt tributes = candidateAt tributes ,- 

try { 

this .userSuppliedTag = new HLAopaqueData (userSuppliedTag) ,- 
} catch (Exception ignored) {} //CouldNotDecode, null 
userSuppliedTag 


//end evtHLArequestAttributeOwnershipRelease 


DRDC Valcartier TR 2007-412 


1195 



// File: evtHLArequestDivestitureConfirmation.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI requests that the federate confirm its intent to 
divest itself of some attribute instances. 

*/ 

public event evtHLArequestDivestitureConfirmation extends MessageEvent 

{ 

public String identifier- 

public Obj ectlnstanceHandle theObj ect; 

public AttributeHandleSet offeredAttributes; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet offeredAttributes) 

{ 

this.identifier = identifier; 

this.theObject = theObject; 

this.offeredAttributes = offeredAttributes; 


//end evtHLArequestDivestitureConfirmation 

// File: evtHLArequestFederationRestoreFailed.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI reports that the federate's specified federation 
restore request completed unsuccessfully. 

*/ 

public event evtHLArequestFederationRestoreFailed extends MessageEvent 

{ 

public String identifier- 
public String label; 

#posted as 
create ( 

String identifier, 

String label) 

{ 

this.identifier = identifier; 
this.label = label; 


//end evtHLArequestFederationRestoreFailed 


1196 


DRDC Valcartier TR 2007-412 



// File: evtHLArequestFederationRestoreSucceeded.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI reports that the federate's specified federation 
restore request completed successfully. 

*/ 

public event evtHLArequestFederationRestoreSucceeded extends 
MessageEvent { 

public String identifier- 
public String label; 

#posted as 
create ( 

String identifier, 

String label) 

{ 

this.identifier = identifier; 
this.label = label; 


//end evtHLArequestFederationRestoreSucceeded 

// File: evtHLArequestRetraction.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that the specified event has 
been retracted. 

*/ 

public event evtHLArequestRetraction extends MessageEvent { 
public String identifier- 

public MessageRetractionHandle theHandle; 

#posted as 
create ( 

String identifier, 

MessageRetractionHandle theHandle) 

{ 

this.identifier = identifier; 
this.theHandle = theHandle; 


//end evtHLArequestRetraction 


DRDC Valcartier TR 2007-412 


1197 



// File: evtHLAstartRegistrationForObjectClass.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that there are active 
subscribers for the specified object class. 

*/ 

public event evtHLAstartRegistrationForObj ectClass extends 
MessageEvent { 

public String identifier- 

public Obj ectClassHandle theClass; 

#posted as 
create ( 

String identifier, 

Obj ectClassHandle theClass) 

{ 

this.identifier = identifier; 
this.theClass = theClass; 


//end evtHLAstartRegistrationForObj ectClass 


// File: evtHLAstopRegistrationForObj ectClass.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 


j * * 

Occurs when the RTI notifies the federate that there are no active 
subscribers for the specified object class. 

*/ 

public event evtHLAstopRegistrationForObjectClass extends MessageEvent 

{ 

public String identifier- 

public Obj ectClassHandle theClass; 


#posted as 
create ( 

String identifier 

Obj ectClassHandle theClass) 


this.identifier = identifier; 
this.theClass = theClass; 


//end evtHLAstopRegistrationForObjectClass 


1198 


DRDC Valcartier TR 2007-412 



// File: evtHLAsynchronizationPointRegistrationFailed.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI signals that a synchronization point registration 
was unsuccessfull. 

*/ 

public event evtHLAsynchronizationPointRegistrationFailed extends 
MessageEvent { 

public String identifier- 

public String synchronizationPointLabel; 

public SynchronizationPointFailureReason reason; 

#posted as 
create ( 

String identifier, 

String synchronizationPointLabel, 

SynchronizationPointFailureReason reason) 

{ 

this.identifier = identifier; 

this.synchronizationPointLabel = synchronizationPointLabel; 

this.reason = reason; 


//end evtHLAsynchronizationPointRegistrationFailed 

// File: evtHLAsynchronizationPointRegistrationSucceeded.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI signals that a synchronization point registration 
was successfull. 

*/ 

public event evtHLAsynchronizationPointRegistrationSucceeded extends 
MessageEvent { 

public String identifier- 

public String synchronizationPointLabel; 

#posted as 
create ( 

String identifier, 

String synchronizationPointLabel) 

{ 

this.identifier = identifier; 

this.synchronizationPointLabel = synchronizationPointLabel; 


//end evtHLAsynchronizationPointRegistrationSucceeded 


DRDC Valcartier TR 2007-412 


1199 



// File : evtHLAtimeAdvanceGrant.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that it is has been granted 
an advance to the specified time. 

*/ 

public event evtHLAtimeAdvanceGrant extends MessageEvent { 
public String identifier- 
public LogicalTime time; 

#posted as 
create ( 

String identifier, 

LogicalTime time) 

{ 

this.identifier = identifier; 
this.time = time; 


//end evtHLAtimeAdvanceGrant 

// File : evtHLAtimeConstrainedEnabled.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that it is time-constrained 
as of the specified time. 

*/ 

public event evtHLAtimeConstrainedEnabled extends MessageEvent { 
public String identifier- 
public LogicalTime time; 

#posted as 
create ( 

String identifier, 

LogicalTime time) 

{ 

this.identifier = identifier; 
this.time = time; 


//end evtHLAtimeConstrainedEnabled 


1200 


DRDC Valcartier TR 2007-412 



// File: evtHLAtimeRegulationEnabled.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI notifies the federate that it is time-regulating 
as of the specified time. 

*/ 

public event evtHLAtimeRegulationEnabled extends MessageEvent { 
public String identifier- 
public LogicalTime time; 

#posted as 
create ( 

String identifier, 

LogicalTime time) 

{ 

this.identifier = identifier; 
this.time = time; 


//end evtHLAtimeRegulationEnabled 

// File: evtHLAturnlnteractionsOff.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that there are no active 
subscribers for the specified interaction class. 

*/ 

public event evtHLAturnlnteractionsOff extends MessageEvent { 
public String identifier- 
public InteractionClassHandle theHandle; 

#posted as 
create ( 

String identifier, 

InteractionClassHandle theHandle) 

{ 

this.identifier = identifier; 
this.theHandle = theHandle; 


//end evtHLAturnlnteractionsOff 


DRDC Valcartier TR 2007-412 


1201 



// File: evtHLAturnlnteractionsOn.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 

j * * 

Occurs when the RTI notifies the federate that there are active 
subscribers for the specified interaction class. 

*/ 

public event evtHLAturnlnteractionsOn extends MessageEvent { 
public String identifier- 
public InteractionClassHandle theHandle; 

#posted as 
create ( 

String identifier, 

InteractionClassHandle theHandle) 

{ 

this.identifier = identifier; 
this.theHandle = theHandle; 


//end evtHLAturnlnteractionsOn 


// File : evtHLAturnUpdatesOffForObj ectInstance.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rtil516.*; 


j * * 

Occurs when the RTI notifies the federate that there are no active 
subscribers for the specified object instance attributes. 

*/ 

public event evtHLAturnUpdatesOffForObj ectInstance extends 
MessageEvent { 

public String identifier- 

public Obj ectlnstanceHandle theObj ect; 

public AttributeHandleSet theAttributes; 


#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 
AttributeHandleSet theAttributes) 


this.identifier = identifier; 
this.theObject = theObject; 

this.theAttributes = theAttributes; 


//end evtHLAturnUpdatesOffForObj ectInstance 


1202 


DRDC Valcartier TR 2007-412 



// File: evtHLAturnUpdatesOnForObjectInstance.event 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

import hla.rt11516.*; 

j * * 

Occurs when the RTI notifies the federate that there are active 
subscribers for the specified object instance attributes. 

*/ 

public event evtHLAturnUpdatesOnForObj ectInstance extends MessageEvent 

{ 

public String identifier- 

public Obj ectlnstanceHandle theObj ect; 

public AttributeHandleSet theAttributes; 

#posted as 
create ( 

String identifier, 

Obj ectlnstanceHandle theObj ect, 

AttributeHandleSet theAttributes) 

{ 

this.identifier = identifier; 
this.theObject = theObject; 

this.theAttributes = theAttributes; 


//end evtHLAturnUpdatesOnForObj ectInstance 


DRDC Valcartier TR 2007-412 


1203 



The 43 plans are all built from the same very simple pattern. For this reason, a 
template is provided below. The only variable is the <callback_name> term, 
which can be any of the corresponding 43 event names. 


// File: pln<callback_name>.plan 
package ca.gc.drdc_rddc.hla.rtil516.jack; 

j * * 

Null handler for the evt<callback_name>. 

These plans are only meant to keep the run-time from complaining when 
the agent using this capability is instantiated. 

*/ 

public plan 
pln<callback_name> 
extends Plan 

{ 

#handles event evt<callback_name> ev; 

static boolean relevant(evt<callback_name> ev) 

{ 

return false; 


context() 

{ 

true ; 


#reasoning method 
body () 


//end pln<callback_name> 


1204 


DRDC Valcartier TR 2007-412 



Part Two - The JACK Chat Client Proper 


// File: HLAchat.prj 
"ProjectName" node: HLAchat 
11 Introduction' 1 node 

(textual description of the chat client) 

"Design Views" node 

"Design Views (Federation Architecture)" node 
"Overview_ChatRoomSlots" node 

(explanatory diagram and "Documentation" node) 
"Overview_Interactions" node 

(explanatory diagram and "Documentation" node) 
"Overview_Obj ects" node 

(explanatory diagram and "Documentation" node) 
"Overview_UserHandleSlots" node 

(explanatory diagram and "Documentation" node) 
"Design Views (Application Architecture)" node 
"Application_Overview" node 

(explanatory diagram and "Documentation" node) 
"Data_Control" node 

(explanatory diagram and "Documentation" node) 

("Group_Who" diagram and "Documentation" node) 

("Joining_Group" diagram and "Documentation" node) 

("Leaving_Group" diagram and "Documentation" node) 

("Listing_Groups" diagram and "Documentation" node) 

("Logging_Out" diagram and "Documentation" node) 

("Logging_In" diagram and "Documentation" node) 

("ProcessChat" diagram and "Documentation" node) 

("ProcessData" diagram and "Documentation" node) 

("Sending_Message_Group" diagram and "Documentation 
("Sending_Message_User" diagram and "Documentation" 
("StartClient" diagram and "Documentation" node) 

("StartServer" diagram and "Documentation" node) 
"Agent Model" node 
"Agent Types" node 
"Client" 

"Server" 

"Capability Types" node 
"capHLA1516" 

"capProcessChat" 

"capProcessData" 

"Plan Types" node 

"Plan Types - Client" node 
"plnProcessGrpNames" 

"plnProcessGrpWhoRes" 

"plnProcessJoinRes" 

"plnProcessLeaveGrpRes" 

"plnProcessLoginRes" 

"plnProcessMessageUsrRes" 

"plnProcessNoGrp" 

"plnProcessRelayMessg" 


node) 

node) 


DRDC Valcartier TR 2007-412 


1205 



"Plan Types - HLA" node 
"ChatRoom" node 

"plnHLA_ChatRoom_Discovery" 

"plnHLA_ChatRoom_OwnershipAcquisitionFailed" 
"plnHLA_ChatRoom_OwnershipAcquisitionNotification" 
"plnHLA_ChatRoom_OwnershipAssumptionRequest" 
"plnHLA_ChatRoom_OwnershipDivestitureConfirmationRequest" 
"plnHLA_ChatRoom_OwnershipReleaseRequest" 
"plnHLA_ChatRoom_ProvideAttributeValueUpdate" 
"plnHLA_ChatRoom_ReflectAttributeValueUpdate" 

"plnHLA_ChatRoom_Removal" 

"plnHLA_WaitingRoom_NameReservation_Failed" 
"plnHLA_WaitingRoom_NameReservation_Succeeded" 

"ChatRoomRegistry" node 

"plnHLA_AcquireChatRoomRegistry" 
"plnHLA_ChatRoomRegistry_Discovery" 
"plnHLA_ChatRoomRegistry_NameReservation_Failed" 
"plnHLA_ChatRoomRegistry_NameReservation_Succeeded" 
"plnHLA_ChatRoomRegistry_OwnershipAcquisitionFailed" 
"plnHLA_ChatRoomRegistry_OwnershipAcquisitionNotification" 

"plnHLA_ChatRoomRegistry_OwnershipAssumptionRequest" 

"plnHLA_ChatRoomRegistry_OwnershipDivestitureConfirmationRequest" 
"plnHLA_ChatRoomRegistry_OwnershipReleaseRequest" 
"plnHLA_ChatRoomRegistry_ProvideAttributeValueUpdate" 
"plnHLA_ChatRoomRegistry_ReflectAttributeValueUpdate" 
"Interaction" node 
"plnHLA_Interaction" 

"plnHLA_InteractionScopeAdvisory_Off" 

"plnHLA_InteractionScopeAdvisory_On" 

"Participant" node 

"plnHLA_Participant_AttributeScopeAdvisory_In" 
"plnHLA_Participant_AttributeScopeAdvisory_Out" 
"plnHLA_Participant_Discovery" 

"plnHLA_Participant_NameReservation_Failed" 
"plnHLA_Participant_NameReservation_Succeeded" 
"plnHLA_Participant_OwnershipAcquisitionFailed" 

"plnHLA_Participant_OwnershipAcquisitionNotification" 
"plnHLA_Participant_OwnershipAssumptionRequest" 
"plnHLA_Participant_OwnershipDivestitureConfirmationRequest" 
"plnHLA_Participant_OwnershipReleaseRequest" 
"plnHLA_Participant_ProvideAttributeValueUpdate" 
"plnHLA_Participant_ReflectAttributeValueUpdate" 
"plnHLA_ParticipantEntersGeneralChatRoom" 

"plnHLA_ForceDivest" 

"Plan Types - Server" node 
"plnJoinGrp" 

"plnLeaveGrp" 

"plnListGrp" 

"plnLoginUser" 

"plnLogoutUsr" 

"plnMessageGrp" 

"plnMessageUsr" 

"plnRequestGrpWho" 

"from [ca.go.drdc_rddc.hla.rtil516.jack]" node 
("pln<callback_name>" plans) 


1206 


DRDC Valcartier TR 2007-412 



"Event Types" node 

"Event Types - Client" node 
"evtJoinGrp" 

"evtLeaveGrp" 

"evtListGrp" 

"evtLogout" 

"evtMessageGrp" 

"evtMessageUsr" 

"evtRequestGrpWho" 

"evtUserLogin" 

"Event Types - HLA" node 

"evtHLA_AcquireChatRoomRegistry" 

"evtHLA_ForceDivest" 

"evtHLA_ParticipantEntersGeneralChatRoom" 
"Event Types - Server" node 
"evtGrpName" 

"evtGrpWhoRes" 

"evtJoinRes" 

"evtLeaveGrpRes" 

"evtLoginRes" 

"evtMessageUsrRes" 

"evtNoGrp" 

"evtRelayMessg" 

"from [ca.go.drdc_rddc.hla.rt11516.jack]" node 
("evt<callback_name>" events) 

"Named Data" node 
"blfHLA datHLA" 

"blfUsers blfdatUsers" 

"viewKeyboard vewdatKeyboard" 

"Data Model" node 

"Beliefset Types" node 
"blfUsers" 

"from [ca.go.drdc_rddc.hla.rt11516.jack]" node 
"blfHLA" 

"View Types" node 
"viewKeyboard" 

"External Classes" node 
(empty) 

"Other Files" node 

"server\MyObservable.j ava" 

"StartCllent.j ava" 

"StartServer.j ava" 

//end HLAchat 


DRDC Valcartier TR 2007-412 


1207 



The startclient class is used to bootstrap the JACK Chat client. It is invoked 
simply by “java Startclient [<server_host>] <server_port>”, where 
<server_host > defaults to "localhost". It connects the client to the server and 
then processes a minimal set of commands (quit/exit or login) until a login is 
successful, at which point the Client agent takes over. 


// File: Startclient.java 

import aos.jack.jak.core.Dei; 

import aos.jack.jak.core.DeiException; 

import aos.dci.Portal; 

import aos.j ack.Kernel; 


import j ava.io.*; 

import j ava.util.StringTokenizer; 

import java.lang.Thread; // for yield() 

import java.net.InetAddress; // for getting the host 

import j ava.net.UnknownHostException; 

import j ava.util.Random; 


address 


import client.*; 


public class Startclient 


static BufferedReader buf; 

// static final int MAX USER PER IP = 1000; 


public static void main(String[] args) 

{ 

String host, port; 

args = Kernel.init(args); 

if ((args.length < 1) || (args.length > 2)) 

{ 

System. err .printIn ( 11 Chat client usage : [ <server_host >] 

<server_port>") ; 

System.exit(0) ; 


System. out. print In ("Starting chat client 
System.out.printIn("Identifying local host..."); 
if ( args.length == 1 ) 

{ host = "localhost"; port = args[0]; } 
else 

{ host = args[0]; port = args[1]; } 

//Note that we can't create name inside the try block 
//(it becomes local to it) and that we must initialise it 
//to satisfy the compiler (which is worried we may escape 
//from the try/catch without setting 'name') 

String name = ""; 


1208 


DRDC Valcartier TR 2007-412 



try 


/* Get the IP address of this machine and 

create a unique portal name for this process. 

The original code drew a random number for its portal 
and hoped for the best: 

name = (new Random()).nextlnt(MAX_USER_PER_IP) + ":" + 

(InetAddress.getLocalHost()).getHostAddress(); 

Here we use the System.currentTimeMillis() to improve our 

chances. 

I guess we could also use the hashCodeO of a throwaway 

obj ect. 

*/ 

name = System. currentTimeMillis () + 11 : 11 + 

(InetAddress.getLocalHost()).getHostAddress(); 

} catch (UnknownHostException uhe) { 

System.err.println(uhe); 

System.err.println("Unable to retrieve the host. 

Exiting..."); 

System.exit(0) ; 

} 

System.out.println("Local host identified."); 

System.out.println("Looking up chat server..."); 
try 


/* Create a portal for this process with the name being the 

* local host address with a pseudo-random number prefixed 

* (see above). 

* Since we have not provided a specific port number for the 

* local portal, we will be given a random free port. 

*/ 

Dei . create(name, "") ; 

System.out.println("Local Portal created as \"" + name + 

ii ii ii j . 

System.out .println ("Local Portal host is " + Dei.getHost()); 
System.out.println("Local Portal port is " + Dei.getPort()); 

/* Connect to the nameserver */ 

String rdesc = (host + ":" + port); 

Dei.nameserver(rdesc) ; 

System.out.println("Nameserver address is \"" + rdesc + 

ii ii ii j . 


DRDC Valcartier TR 2007-412 


1209 



// Try to ping the server agent. This will try a few times, 
if (Dei.multiPingOk("ChatServer@ServerPortal")) 

{ 

System.out.printIn("Found Server agent 
ChatServer@ServerPortal"); 

startChat(); 

} else { 

System.err.println("Chat Server agent doesn't exist!"); 

} 

} catch (DciException de) { 

System.err.println("DCI Exception caughtl"); 

System.err.println(de); 

// System.exit(0) ; 


public static void startChat() 

{ 

buf = new BufferedReader(new InputStreamReader(System.in)); 
try 


System.out.println( 
System.out.println( 
System.out.println( 
System.out.println( 
System.out.println( 


'yj^'yj^***************************’f ) * 

Tf * * " ) • 

"* WELCOME TO \"AGENT-CHAT\" *"); 
n * * ,f ) ; 

’f***************************\^n") * 


String line = ""; 

//This'll loop until a Quit/Exit or a successfull login 
do 


System.err.print("ChatServer@ServerPortal: "); 
line = buf.readLine(); // read in commands. 

} 

while (iprocessLine(line)) ; 

//Once out of this, the ProcessLogRes Plan will generate 

Events 


catch (IOException ioe) 

{ 

System.err.println(ioe); 


1210 


DRDC Valcartier TR 2007-412 



public static boolean processLine(String line) 

{ 

StringTokenizer tokenizer = new StringTokenizer (line, " 11 ) ; 
//blank command line? 

if ( ltokenizer.hasMoreTokens() ) return false; 

int numTokens = tokenizer.countTokens () ; 

String command = tokenizer.nextToken(); 

if ( (command. equals ("quit 11 ) ) || (command. equals (" exit") ) ) 

{ 

//'Quit'/'Exit' command 

System.out.println("\nExiting.. .") ; 

System.exit(0) ; 

return true; //to satisfy the compiler 

} 

else if ( command.equals("login") && (numTokens == 2) ) 

{ 

//'Login <username>' command 

String username = tokenizer.nextToken(); 

System.out.println("Creating Client '" + username + "'"); 
//Try launching a Client agent 
Client user = new Client(username); 

//The original code launched the login process like this: 
// user.send("ChatServer@ServerPortal", ((new 

UserLogin()) .login(username)) ) ; 

//That line now appears in the Client's constructor 

//Wait for the login request to be processed 
do 


Thread.yield() ; 

} 

while ( user.getLoginPendingStatus() ); 

//Now it's safe to check the login status 
if (user.getLogStatus() == false) 

{ 

System.out.printIn("Login failed."); 
return false; 

} else { 

//Login successful; exit the StartClient command loop 
System.out.println("Login successfull."); 
return true; 


} else { 

//Unrecognised command 

System.out.println("***Use either 'login <username>' ; 'quit' 
or 'exit'"); 

return false; 


//end StartClient 


DRDC Valcartier TR 2007-412 


1211 



The startserver class is used to launch the JACK Chat server. It is invoked 
simply by “ java Startserver [<server_port>] ", where <server_port> 

defaults to " 5000 ". It sets up the JACK networking required for Client-Server 
connections and serves to report Server activity. 


// File: Startserver.java 
import aos.jack.jak.core.Dei; 
import aos.jack.jak.core.DeiException; 
import aos.j ack.Kernel; 

import j ava.io.*; 

import server.*; 

public class Startserver 

{ 

static BufferedReader buf; 

public static void main(String[] args) 

{ 

args = Kernel.init(args); 

String port; 

String[] HLAargs; //Will be passed to HLAmyChat 
//HLAargs is args.subarray(1); 
if (args.length >= 1) 

{ 

port = args[0]; // grab port number from extra args 

//Oddly, there is no Array (or java.util) method 
//to extract a sub-array (like String.substring) 
HLAargs = new String[args.length - 1]; 

for (int i = 1; i < args.length; i++) HLAargs[i - 1 ] = 

args [i] ; 

} else { 

port = "5000"; // use default port number 

HLAargs = new String[0]; //Not the same as null! 


1212 


DRDC Valcartier TR 2007-412 



try 


Dei.nameserver(port); // create a nameserver 

System.out.printIn("New 'nameserver' created; 

//Dei.create may throw aos.jack.jak.core.DeiException 
//but there is no known recovery method; the Dei service 
//is left in a bad state and we cannot just try creating 
//on a different port, 
try 


Dei.create("ServerPortal", port); // create a new portal 
for the server agent 

} catch (aos.jack.jak.core.DciException de) { 

System.err.println("+++ ServerPortal could not be created 


System.err.println("+++ Try again with a different port 


System.exit(0); 


System.out.println("ServerPortal created."); 

System. out. println (" Server Host: " + Dei .getHost () ) ,- 
System.out.println("Server Port: " + Dei .getPort () ) ,- 

Server server = new Server("ChatServer", HLAargs); // 
create server agent 

System.out.println("Server agent '" + server.name() + " 
created."); 

System.out.println("+++ Server startup concluded + + +"),- 


//The original code did not need any finalizer, so it just 
waited for the app to be interrupted: 

// System.out.println("Hit Ctrl-C to terminate."),- 

//We cannot afford that, so we do this instead: 
try 


//When run from the Compiler Utility, the JDE owns 
System.in, so this does not work 

System. err. print ("\nHit any key to terminate : \n") ,- 
buf = new BufferedReader(new 
InputStreamReader (System, in) ) ,- 

String line = buf. readLine () ,- // read in any key 


catch (IOException ioe) 


System. err. println (ioe) ,- 


DRDC Valcartier TR 2007-412 


1213 



//Shut down cleanly 
//LogoutUsr plan will do this: 

// HLAchat.finalize(); 

//Essentially, we need to post a LogoutAllUsersIGE 
//whose plan, like MsgGrpPlan, retrieves all Client users 
//and posts a Logout event for each. 

System. out .println (" + + + Server shut down + + +"),- 
System. exit (0) ,- 
} catch (DciException de) { 

System. err .println ("DCI Exception caught l 11 ) ,- 
System. err .println (de) ,- 
System. exit (0) ,- 


//end StartServer 


1214 


DRDC Valcartier TR 2007-412 



The client.agent was only modified from the AOS-supplied demonstration to 
the extent of fixing one broken line (the demonstration apparently predates version 
4) and changing most identifiers to make them more intelligible. The line that sends 
the UserLogin event was also moved from startclient to the client constructor. 


// File: Client.agent 
package client; 

import j ava.io.*; 
import server.evtGrpName; 
import server.evtLeaveGrpRes; 
import server.evtJoinRes; 
import server.evtNoGrp; 
import server.evtGrpWhoRes; 
import server.evtMessageUsrRes; 
import server.evtRelayMessg; 
import server.evtLoginRes; 

j * * 

The Client agent represents a single user within the chat network. 

*/ 

public agent 
Client 

extends Agent 

{ 

#has capability capProcessChat cap; 

#handles event evtGrpName; 

#handles event evtGrpWhoRes; 

#handles event evtJoinRes; 

#handles event evtLeaveGrpRes; 

#handles event evtLoginRes; 

#handles event evtMessageUsrRes; 

#handles event evtNoGrp; 

#handles event evtRelayMessg; 

#sends event evtJoinGrp evJoinGrp; 

#sends event evtLeaveGrp evLeaveGrp; 

#sends event evtListGrp evListGrp; 

#sends event evtLogout evLogout; 

#sends event evtMessageGrp evMessageGrp; 

#sends event evtMessageUsr evMessageUsr; 

#sends event evtRequestGrpWho evRequestGrpWho; 

#sends event evtUserLogin evUserLogin; 

#uses plan plnProcessGrpNames; 

#uses plan plnProcessGrpWhoRes; 

#uses plan plnProcessJoinRes; 

#uses plan plnProcessLeaveGrpRes; 

#uses plan plnProcessLoginRes; 

#uses plan plnProcessMessageUsrRes; 

#uses plan plnProcessNoGrp; 

#uses plan plnProcessRelayMessg; 

#private data viewKeyboard vewdatKeyboard(); 


DRDC Valcartier TR 2007-412 


1215 



//Final result of login request 
private boolean logged = false; 

//True while a login request is pending 
private boolean login_pending = false; 

//Current group to which the client belongs 
private String group; 

//Login name of the user 
private String name; 

public Client(String name) 

{ 

super(name); 

//Initiate login request 
setLoginPendingStatus(true) ; 

send (" ChatServer@ServerPortal 11 , evUserLogin .login (name) ) ; 


public boolean getLoginPendingStatus() 

{ 

return login_pending; 

} 

public boolean getLogStatus () 

{ 

return logged; 


String getGroupO 

{ 

return group; 


String getUserName() 

{ 

//Was getNameO but this now conflicts with an inherited final 
(?) method 

return name; 


void setGroup(String group) 

{ 

this.group = group; 

} 

public void setLoginPendingStatus(boolean status) 

{ 

login_pending = status; 

} 

public void setLogStatus(boolean status) 

{ 

logged = status; 


1216 


DRDC Valcartier TR 2007-412 



void setName(String name) 

{ 

this.name = name; 


//end Client 


The capProcessChat capability simply regroups a subset of the client events: it 
handles the result of the login request and manages the client command-line parsing. 
It is not clear why AOS chose to put just the c 1 i ent-packaged events (except for 
evtUserLogin) in this capability. 


// File: capProcessChat.cap 
package client; 

import server.evtLoginRes; 

j * * 

This capability implements the processing of the Client agent's chat 
session commands. 

*/ 

public capability capProcessChat extends Capability { 

#handles external event evtLoginRes; 

#sends event evtJoinGrp ev; 

#sends event evtLeaveGrp evl; 

#sends event evtListGrp ev5; 

#sends event evtLogout ev6; 

#sends event evtMessageGrp ev4; 

#sends event evtMessageUsr ev2; 

#sends event evtRequestGrpWho ev3; 

#uses plan plnProcessLoginRes; 

#imports data viewKeyboard vewdatKeyboard(); 

} 

//end capProcessChat 


DRDC Valcartier TR 2007-412 


1217 



The viewKeyboard view wraps the keyboard primitives, turning command-line 
input into events sent to the Server. The Eventsource interface mentioned here is 
not documented at all by AOS. 


// File: viewKeyboard.view 
package client; 

import java.util.StringTokenizer; 
import aos.j ack.j ak.agent.Agent; 

j * * 

This view wraps some keyboard primitives. 

*/ 

public view 
viewKeyboard 

implements Eventsource 

{ 

EventRecipient self; 
evtJoinGrp j oinGrpEv; 
evtLeaveGrp leaveGrpEv; 
evtListGrp listGrpEv; 
evtMessageGrp msgGrpEv; 
evtMessageUsr msgUsrEv; 
evtRequestGrpWho grpWhoEv; 

public boolean attach(EventRecipient er) 

{ 

self = er; 

joinGrpEv = (evtJoinGrp) er.findEvent( 
evtJoinGrp.class.getName() ); 

leaveGrpEv = (evtLeaveGrp) er.findEvent( 
evtLeaveGrp.class.getName() ); 

grpWhoEv = (evtRequestGrpWho) er.findEvent( 
evtRequestGrpWho.class.getName() ); 

msgGrpEv = (evtMessageGrp) er.findEvent( 
evtMessageGrp.class.getName() ); 

msgUsrEv = (evtMessageUsr) er.findEvent( 
evtMessageUsr.class.getName() ); 

listGrpEv = (evtListGrp) er.findEvent( 
evtListGrp.class.getName() ); 
return true; 


1218 


DRDC Valcartier TR 2007-412 



public MessageEvent processLine(String line) 

{ 

StringTokenizer tokenizer = new StringTokenizer (line, " 11 ) ; 
String cmd = 

if ( tokenizer.hasMoreTokens() ) cmd = tokenizer.nextTokenO; 

if ( cmd. equals ( 11 j oin' 1 ) ) 

{ 

if ( tokenizer.hasMoreTokens() ) 

{ 

String group = tokenizer.nextTokenO; 

System. out.println ( 11 ***Now joining group: 11 + group) ; 
return joinGrpEv.join(group, ((Client) 

self).getUserName()); 

} else { 

System. err. println ( 11 * **ERROR: Specify the group to join' 1 ); 


else if ( cmd.equals("leave") ) 

{ 

if ( tokenizer.hasMoreTokens() ) 

{ 

String group = tokenizer.nextTokenO; 

System.out.println("***Now leaving group: " + group); 
return leaveGrpEv.leave( group, ((Client) 
self) . getUserName () ) ,- 

} else { 

System.err.println("***ERROR: Specify the group to 

leave") ,- 


else if ( cmd.equals("who") ) 

{ 

if ( tokenizer.hasMoreTokens() ) // 'who group_name' 

{ 

String group = tokenizer.nextTokenO; 
return grpWhoEv.grpWho ( group ),- 
} else { 

// 'who' 

return grpWhoEv.grpWho ( ((Client) self) .getGroup () ),- 


else if ( cmd.equals("msg") ) 

{ 

String mesg = "" ,- 

while ( tokenizer.hasMoreTokens() ) 

{ 

mesg += tokenizer.nextTokenO + " 'O' 

} 

System.out.println( "***Message was sent to the '" + 
((Client) self) .getGroup () + "' group."),- 

return msgGrpEv.msgGrp( mesg, ((Client) self) .getGroup () 
((Client) self) .getUserName () ),- 


DRDC Valcartier TR 2007-412 


1219 



else if ( cmd.equals("msgusr") ) 

{ 

if ( tokenizer.hasMoreTokens() ) 

{ 

String user = tokenizer . nextToken () ,- 
String mesg = 

// read in the message 

while ( tokenizer.hasMoreTokens() ) 

{ 

mesg += tokenizer. nextToken () + 11 ",- 

} 

// send message to user 

return msgUsrEv.message(mesg, user, ((Client) 
self) . getUserName () ) ,- 
} else { 

System. err . println ( 11 ** *ERROR: Specify the destination 

username' 1 ) ,- 


else if ( cmd.equals("group") ) 

{ 

return listGrpEv.list () ,- 

} 

else if ( cmd.equals("help") ) 

{ 

System, out .printIn ("\nCOMMANDS :") ,- 

System.out.printIn("= === = = = =") ; 

System.out.println("\nmsg <message_text> \t Send a message to 
everyone in the current group."),- 

System.out.println("\nmsgusr <username> <message_text> \t 
Send a message to the user 'username'."); 

System.out.println("\nwho \t\t\t Lists all users in the 
current group."); 

System.out.println("\nwho <group_name> \t Lists all users in 
the group 'group_name'."),- 

System.out.println("\njoin <group_name> \t Join the group 
'group_name'."),- 

System.out.println("\nleave <group_name> \t Leave the group 
'group_name' (Get removed from it) ." ),- 

System.out.println("\ngroup \t\t\t Lists all the groups that 
exist." ) ,- 

System.out.println("\nlogout \t\t\t Logout (Exit program).\n" 


else if ( cmd.equals("") ) 

{ 

// nothing entered. Do nothing, 
return null; 

} else { 

System.err.println("\n***ERROR: Unrecognised command. Type 
'help' for a list of commands.") ,- 
return null; 

} 

return null; 


//end viewKeyboard 


1220 


DRDC Valcartier TR 2007-412 





The evtUserLogin event represents a login request. The user is the requested 
user name. 


// File: evtUserLogin.event 
package client; 

j * * 

This event is sent by the Client to the Server, to request a login. 
*/ 

public event 
evtUserLogin 

extends MessageEvent 

{ 

public String username,- 

#posted as 
login(String user) 

{ 

username = user; 


//end evtUserLogin 


The evtLoginRes event represents the outcome of the login request. The status 
indicates whether it was successful or not, user is the requested username and 
location the network-name of the originating JACK agent. 


// File: evtLoginRes.event 
package server; 

j * * 

This event is an envelope for the data that is sent back to the client 
From the server, as a result of the login procedure. 

*/ 

public event 
evtLoginRes 

extends MessageEvent 

{ 

public boolean status,- 
public String location- 
public String user; 

#posted as 

result(String username, String location, boolean logStatus) 

{ 

user = username; 

this.location = location- 

status = logStatus,- 


//end evtLoginRes 


DRDC Valcartier TR 2007-412 


1221 



The plnProcessLoginRes plan processes the outcome of the login request. If a 
failure, it shuts down the agent, and control returns to the startclient command¬ 
line loop. Otherwise, it starts prompting viewKeyboard to parse the user 
commands. 


// File: plnProcessLoginRes.plan 
package client; 

import java. io. * ; 

import j ava.util.StringTokenizer; 

import server.*; 

import server.evtLoginRes; 

j * * 

This plan processes the outcome of the login request; 

if successfull, it initiates the processing of the Client agent's chat 
commands. 

*/ 

public plan 
plnProcessLoginRes 
extends Plan 

{ 

public static BufferedReader 

buf = new BufferedReader( new InputStreamReader( System.in ) ); 

#handles event evtLoginRes logResEv; 

#sends event evtJoinGrp joinGrpEv; 

#sends event evtLeaveGrp leaveGrpEv; 

#sends event evtListGrp listGrpEv; 

#sends event evtLogout logoutEv; 

#sends event evtMessageGrp msgGrpEv; 

#sends event evtMessageUsr msgUsrEv; 

#sends event evtRequestGrpWho grpWhoEv; 

#uses interface Client self; 

#uses data viewKeyboard vewdatKeyboard; 

static boolean relevant(evtLoginRes ev) 

{ 

return true; 


context() 

{ 

true ; 


1222 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 

{ 

self.setLogStatus(logResEv.status); 
self.setLoginPendingStatus (false) ; 
self.setName(logResEv.user); 

if (logResEv.status == true) 

{ 

self.setGroup("General"); 

System. out. print In ( 11 \n\n- 

\n") ; 

System.out.println("Welcome to the \"General\" chat 
groupl\n"); 

System.out.printIn("- 

\n\n") ; 

//See below for an explanation why this line is no good: 
// System.out.print( (logResEv.getAgent()).name() + "); 

// System.out.println( "***You are + 

(logResEv.getAgent()).name() + ***"); 

System.out.println( "***You are + self.getUserName() + 

***'!) . 

String line = 

@action() 

{ 

try 


line = buf.readLine(); 

} catch (IOException ioe) { 
System.err.println(ioe); 


DRDC Valcartier TR 2007-412 


1223 





StringTokenizer tokenizer = new StringTokenizer (line, " 11 ) ; 
boolean logout = false,- 

while ( l line . equals ( 11 logout 11 ) ) 

{ 

MessageEvent me = vewdatKeyboard.processLine(line),- 
if ( me l= null ) @send ( logResEv. from, me ),- 


II 

some 

it ’ s 


//There is no good way to have this chat application 
//write a prompt line. This old code: 

System. out. print ( (logResEv. getAgent ()). name () + 11 : 11 ) ; 
//does not work because it writes the prompt, goes into 
//buffer read-line mode, and *then* the other plan threads 
//spit out various feedback, which gets tacked at the end 
//of the prompt as a result. Maybe we could implement 

//kind of critical-section semaphore or some such, but 


//not worth the effort. So we settle for this sort-of 

prompt: 

II System. out. println ( "***You are 1,1 + 

(logResEv. getAgent ()). name () + "' ***"),- 

System. out. println ( "***You are 1,1 + self . getUserName () + 

'i i * * * 'i \ . 


@action () 


try 


line = buf . readLine () ,- 
} catch (IOException ioe) { 
System. err . println (ioe) ,- 


if ( line . equals ( 11 logout 11 ) ) 

{ 

@send ( logResEv. from, logoutEv. logout (logResEv. user) ) ,- 

System. out. println ( "***Now exiting..." ),- 
System. exit (0) ,- 


} else { 

System.err.println("***ERROR: User + logResEv.user + 
already logged in...Please wait. 

//Don't we need to kill the agent here? This was missing, 
self . finish () ,- 


I /end plnProcessLoginRes 


1224 


DRDC Valcartier TR 2007-412 



The evt JoinGrp event represents a request to join (and create, if necessary) a 
group. The group is the name of the group being joined, and user the name of the 
user joining the group. 


// File: evtJoinGrp.event 
package client; 

j * * 

This event is sent from the Client to the Server agent as a request to 
join a group. 

*/ 

public event 
evtJoinGrp 

extends MessageEvent 

{ 

public String group,- 
public String user; 

#posted as 

join(String grp, String usr) 

{ 

group = grp; 
user = usr; 


//end evtJoinGrp 


The evtLeaveGrp event represents a request to leave a group. The group is the 
name of the group being left behind, and user the name of the user leaving the 
group. 


// File: evtLeaveGrp.event 
package client; 

j * * 

This event triggers the removal of the user (sender) from the group 
specified. 

*/ 

public event 
evtLeaveGrp 

extends MessageEvent 

{ 

public String group,- 
public String user; 

#posted as 

leave(String grp, String usr) 

{ 

group = grp,- 
user = usr; 


//end evtLeaveGrp 


DRDC Valcartier TR 2007-412 


1225 



The evtListGrp event represents a request to list the extant groups. It has no 
members. 


// File: evtListGrp.event 
package client; 

j * * 

This event is sent from the Client agent to initiate the retrieval of 
the group names that exist in the GroupList beliefset. 

*/ 

public event 
evtListGrp 

extends MessageEvent 

{ 

#posted as 
list() { ; } 

} 

//end evtListGrp 


The evtLogout event indicates to the Server that the Client is withdrawing from 
the Chat network and shutting down. The user member is the name of the user 
shutting down. 


// File: evtLogout.event 
package client; 

j * * 

This event initiates the logout procedure. 

*/ 

public event 
evtLogout 

extends MessageEvent 

{ 

public String user; 

#posted as 

logout(String username) 

{ 

user = username; 


//end evtLogout 


1226 


DRDC Valcartier TR 2007-412 



The evtMessageGrp represents a message being sent by the client to the members 
of a given group. The f romuser is the name of the user sending the message, the 
group is the target group, and messg is the message being sent. 


// File: evtMessageGrp.event 
package client; 

j * * 

This event is an envelope for the data (including the message) 
required to send a message from one user to all users of a particular 
group. 

*/ 

public event evtMessageGrp extends MessageEvent { 
public String fromUsr,- 
public String group,- 
public String messg,- 

#posted as 

msgGrp(String msg, String grp, String user) 

{ 

messg = msg; 
group = grp; 
fromUsr = user; 


//end evtMessageGrp 


The evtMessageUsr represents a private message being sent by the client to a 
specific other user. The f romuser is the name of the user sending the message, the 
toUser is the target user, and messg is the message being sent. 


// File: evtMessageUsr.event 
package client; 


j * * 

This event is an envelope for the data required (including the 
message) to send a message from one user to another. 

*/ 

public event evtMessageUsr extends MessageEvent { 
public String fromUsr,- 
public String messg,- 
public String toUsr,- 

#posted as 

message(String msg, String to, String from) 

{ 

messg = msg,- 
toUsr = to; 
fromUsr = from; 

} 

}//end evtMessageUsr 


DRDC Valcartier TR 2007-412 


1227 



The evtRequestGrpwho event represents a request to list the currently visible other 
users (those in the same group). The grp is the group being queried (which could 
have been different from the current group in the original JACK demonstration. 


// File: evtRequestGrpwho.event 
package client; 

j * * 

This event initiates the processing of the 'who' command. 
*/ 

public event evtRequestGrpwho extends MessageEvent { 
public String group; 

#posted as 
grpWho(String grp) 

{ 

group = grp; 


//end evtRequestGrpwho 


1228 


DRDC Valcartier TR 2007-412 



The MyObservable class is a descendant of j ava .util .observable adapted for 

use with the aos. jack. util, cursor. Change class. 


// File: MyObservable.java 
package server; 

/* 

* MyObservable.j ava 

* 

* A simple, usable Observable. 

*/ 

public class 
MyObservable 

extends j ava.util.Observable 

{ 

//Stupidly, both clearChanged() and setChangedO are protected 
//preventing use "out of the box" of java.util.Observable 

//Changing visibility from protected to public 
//Also changing behaviour somewhat: 

//if there are no observers yet, we simply flip to "changed" ,- 
//otherwise we flip to "changed" and then notifyObservers 
//(and thus revert to unchanged). 
public void 
setChanged() 

{ 

if (countObservers() > 0) 

{ 

super . setChanged () ,- 
notifyObservers () ,- 
} else { 

super . setChanged () ,- 


//Changing visibility from protected to public 
public void 
clearChanged() 

{ 

super . clearChanged () ,- 


//end MyObservable 


DRDC Valcartier TR 2007-412 


1229 



The Server. agent was extensively rewritten to adapt JACK to an HLA context. It 
is fairly large because of the HLAchat inner class, which reproduces the lower-level 
functionality of the Java Chat client. 

A second development cycle would consist in re-organizing the Java code to follow 
more closely the JACK structure, and in merging the JACK Client and Server into a 
single Chatter agent. The Java FederateAmbassador functionalities could be 
separated from the GUI-related code and encapsulated into a stand-alone class. 
Mychat could then declare an inner class that descends directly from this class, and 
the agent’s HLAchat inner class could do likewise. This would remove a large 
amount of code duplication. 


1230 


DRDC Valcartier TR 2007-412 



// File: Server.agent 
package server; 

import j ava.io.File; 

import j ava.util.HashMap; 

import j ava.util.Iterator; 

import hla.rt11516; 

import se.pitch.prt11516.RTI; 

import ca.go.drdc_rddc.hla.rtil516.omt.*; 

import ca.go.drdc_rddc.hla.rtil516.FedAmb.*; 

import ca.gc.drdc_rddc.hla.rt11516.jack.capHLA1516; 

import ca.go.drdc_rddc.hla.rt11516.jack.blfHLA; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipAcquisitionNo 

tification; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipUnavaliable; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAattributesInScope; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAattributesOutOfScope; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAdiscoverObj ectInstance; 
import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationFa 

lied; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationSu 

cceeded; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAprovideAttributeValueUpdate; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAreceiveInteraction; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAreflectAttributeValues; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAremoveObj ectInstance; 
import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipAssump 

tion; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipReleas 
e ; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLArequestDivestitureConfirmation; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAturnlnteractionsOff; 
import ca.gc.drdc_rddc.hia.rt11516.jack.evtHLAturnlnteractionsOn; 
import client.evtUserLogin; 

j * * 

The Server agent represents the central server which processes all 
data incoming from the users logged onto the chat network. 

*/ 

public agent 
Server 

extends Agent 

{ 

#has capability capHLA1516 capHLA; 

#has capability capProcessData cap; 


DRDC Valcartier TR 2007-412 


1231 



#handles event evtHLA_AcquireChatRoomRegistry; 

#handles event evtHLA_ForceDivest; 

#handles event evtHLA_ParticipantEntersGeneralChatRoom; 

#handles event evtHLAattributeOwnershipAcquisitionNotification; 
#handles event evtHLAattributeOwnershipUnavailable; 

#handles event evtHLAattributesInScope; 

#handles event evtHLAattributesOutOfScope; 

#handles event evtHLAdiscoverObj ectInstance; 

#handles event evtHLAobj ectInstanceNameReservationFailed; 

#handles event evtHLAobj ectInstanceNameReservationSucceeded; 
#handles event evtHLAprovideAttributeValueUpdate; 

#handles event evtHLAreceiveInteraction; 

#handles event evtHLAreflectAttributeValues; 

#handles event evtHLAremoveObj ectlnstance; 

#handles event evtHLArequestAttributeOwnershipAssumption; 

#handles event evtHLArequestAttributeOwnershipRelease; 

#handles event evtHLArequestDivestitureConfirmation; 

#handles event evtHLAturnlnteractionsOff; 

#handles event evtHLAturnlnteractionsOn; 

#handles event evtUserLogin; 

#posts event evtHLA_AcquireChatRoomRegistry 
evHLA_AcquireChatRoomRegistry; 

#posts event evtHLA_ForceDivest evHLA_ForceDivest; 

#posts event evtHLA_ParticipantEntersGeneralChatRoom 
evHLA_ParticipantEntersGeneralChatRoom; 

#sends event evtLoginRes evLoginRes; 

#sends event evtRelayMessg evRelayMessg; 

#uses plan plnHLA_AcquireChatRoomRegistry; 

#uses plan plnHLA_ChatRoom_Discovery; 

#uses plan plnHLA_ChatRoom_OwnershipAcquisitionFailed; 

#uses plan plnHLA_ChatRoom_OwnershipAcquisitionNotifloation; 

#uses plan plnHLA_ChatRoom_OwnershipAssumptionRequest; 

#uses plan plnHLA_ChatRoom_OwnershipDivestitureConfirmationRequest; 
#uses plan plnHLA_ChatRoom_OwnershipReleaseRequest; 

#uses plan plnHLA_ChatRoom_ProvideAttributeValueUpdate; 

#uses plan plnHLA_ChatRoom_ReflectAttributeValueUpdate; 

#uses plan plnHLA_ChatRoom_Removal; 

#uses plan plnHLA_ChatRoomRegistry_Discovery; 

#uses plan plnHLA_ChatRoomRegistry_NameReservation_Failed; 

#uses plan plnHLA_ChatRoomRegistry_NameReservation_Succeeded; 

#uses plan plnHLA_ChatRoomRegistry_OwnershipAcquisitionFailed; 

#uses plan 

plnHLA_ChatRoomRegistry_OwnershipAcquisitionNotification; 

#uses plan plnHLA_ChatRoomRegistry_OwnershipAssumptionRequest; 

#uses plan 

plnHLA_ChatRoomRegistry_OwnershipDivestitureConfirmationRequest; 

#uses plan plnHLA_ChatRoomRegistry_OwnershipReleaseRequest; 

#uses plan plnHLA_ChatRoomRegistry_ProvideAttributeValueUpdate; 
#uses plan plnHLA_ChatRoomRegistry_ReflectAttributeValueUpdate; 


1232 


DRDC Valcartier TR 2007-412 



#uses plan plnHLA_ForceDivest,- 
#uses plan plnHLA_Interaction,- 

#uses plan plnHLA_Interact ionScopeAdvisory_Of f,- 
#uses plan plnHLA_InteractionScopeAdvisory_On,- 

#uses plan plnHLA_Participant_AttributeScopeAdvisory_In; 

#uses plan plnHLA_Participant_AttributeScopeAdvisory_Out,- 

#uses plan plnHLA_Part icipant_Discovery,- 

#uses plan plnHLA_Participant_NameReservation_Failed; 

#uses plan plnHLA_Participant_NameReservation_Succeeded; 

#uses plan plnHLA_Participant_OwnershipAcquisitionFailed; 

#uses plan plnHLA_Participant_OwnershipAcquisitionNotification; 
#uses plan plnHLA_Participant_OwnershipAssumptionRequest,- 
#uses plan 

plnHLA_Part icipant_Owner shipDi vest! tureConfirmat ionRequest,- 
#uses plan plnHLA_Participant_OwnershipReleaseRequest,- 
#uses plan plnHLA_Part icipant_ProvideAttributeValueUpdate,- 
#uses plan plnHLA_Part icipant_Ref lectAttributeValueUpdate,- 
#uses plan plnHLA_ParticipantEntersGeneralChatRoom,- 
#uses plan plnHLA_WaitingRoom_NameReservation_Failed; 

#uses plan plnHLA_WaitingRoom_NameReservation_Succeeded; 

#uses plan plnLoginUser; 

#private data blfHLA datHLAO; 

#private data blfUsers blfdatUsers(); 

j * * 

* Server Agent constructor. 

*/ 

public Server(String name, String [] HLAargs) 

{ 

super(name); 

//Note that super() must be the first statement, 

//so storing the HLAargs can't occur until the super's 
//consequences have run out (including the UserData View 
constructor). 

//This is another reason why having any constructor invoke 
//_HLAchat.connect() is a bad idea. 

_HLAargs = HLAargs ,- 
} //constructor 

public String[] _HLAargs,- 


DRDC Valcartier TR 2007-412 


1233 



* * 


//Exposing the event factories could be done like this: 
public evtHLAattributeOwnershipAcquisitionNotification 
getEvtHLAattributeOwnershipAcquisitionNotification() 

{ 

return evHLAattributeOwnershipAcquisitionNotification; 

} //getEvtHLAattributeOwnershipAcquisitionNotification 
and so on... 

*/ 

//Exposing the inner class constructor 

//to circumvent a Plan pre-processor bug; once that is fixed, 

//we can replace calls to this with: 

// self.new HLAchat(capHLA, the_username) 

//where self is a Server instance reference and 

//capHLA is the HLAfederate's enclosing capHLA1516 instance. 

public HLAchat 

newHLAchat(String the_username) 

throws aos.jack.jak.beliefset.BeliefSetException 

{ 

return this.new HLAchat (capHLA, the_username) ,- 
} //newHLAchat 

// ################################################### 

// ##################### HLAchat ##################### 

// ################################################### 

/* 

* HLAchat.java 

* 

* Based on the NetBeans MyChat.java application, this handles the 

* HLA interface of the JACK chat federation. 

* Besides the chat-specific stuff, the key interface layer here 

* consists of the FedAmbWrapper listener/responder stubs, which 

* simply rewrap the callback parameters into a JACK event. 

* An agent instance reference is needed for two main reasons: 

* 1) the agent supplies the postEvent and send methods 

* 2) the agent exposes (privately) the Event factories 

* (as long as the agent declares that it posts or sends them) 

* Because the Event factories are built by the pre-processor, 

* their accessibility cannot be modified directly here,- the best 

* that could be done would be to provide an access method. 

* Having the HLAchat class inner to the agent solves these 

* problems nicely. 

* 

* Note that the pRTI1516 classes dragged in by the RTIambassador 

* and FederateAmbassador turn out to be non-serializable (in their 

* innards), which means an HLAchat class cannot be wrapped into a 

* sent message (although it could still be posted). Since the 

* agent must manage several HLAchat instances in any case, putting 

* their references in a BeliefSet makes more sense. It becomes 

* relatively easy to recover the HLAchat reference as part of each 

* plan's context() method. 

*/ 


1234 


DRDC Valcartier TR 2007-412 



public class 
HLAchat 

extends ca.gc.drdc_rddc.hla.rtil516.jack.capHLA1516.HLAfederate 

{ 

public static final int CRC_PORT = 8989; 
public static final String _name_ChatRoomRegistry 
"_ChatRoomRegistry"; 

public static final String _name_nowhere_ChatRoom 
"_nowhere" ; 

public static final String _name_waiting_room_ChatRoom = 


"_waiting_room"; 

public static final String _name_general_ChatRoom 
"_<General>" ; 

public static final short _slot_nowhere_ChatRoom = 0; 

public static final short _slot_waiting_room_ChatRoom = 1; 

public static final short _slot_general_ChatRoom = 2; 

public static final short _slot_FirstFreeChatRoomSlot = 3; 


private String rtiHost = "localhost"; 

//HLAargs [0] 

// private String fdd = 11 C:\\Program 

Files\\pRTI1516\\Samples\\chat\\MyChat.xml"; //HLAargs[1] 

private String fdd = "D:\\Documents and 

Settings\\dthibault\\Mes Documents\\Java Proj ects\\MyChat.xml 11 ; 

//HLAargs[1] 

private String fedex = "MyChatRoom"; 

//HLAargs[2 ] 

private String fedname = "MyChatter"; 

//HLAargs[3 ] 

private FederateHandle _federateHandle; 

//References to the RTI and Federate ambassadors 
public RTIambassador _rtiAmbassador; //returns 

super.rtiAmbassador 

public FedAmbWrapper _fedAmbassador; 

//The JACK username 

//Used to identify the HLAchat instance 
// public String username; //use 

super.getIdentifier() instead 

//Whether HLA is connected or not (ie, whether the federate has 
j oined) 

public boolean connected = false; 

public InteractionClassHandle _ich_Communication; 
public ParameterHandle _iph_Communication_message; 

public ParameterHandle _iph_Communication_sender; 

public Obj ectClassHandle _och_ChatRoomRegistry; 

public AttributeHandleSet _oahs_ChatRoomRegistry; 

public AttributeHandleSet _oahs_ChatRoomRegistry_forUpdate; 

public AttributeHandle 
_oah_ChatRoomRegistry_DeletePrivilege; 

public AttributeHandle _oah_ChatRoomRegistry_list; 

public AttributeHandleValueMap _oahvm_ChatRoomRegistry; 


DRDC Valcartier TR 2007-412 


1235 



public 
public 
public 
public 
public 
public 
// public 


Obj ectClassHandle 

AttributeHandleSet 

AttributeHandleSet 

AttributeHandle 

AttributeHandle 

AttributeHandle 

AttributeHandleValueMap 


och_ChatRoom; 
oahs_ChatRoom; 
oahs_ChatRoom_forUpdate; 
oah_ChatRoom_DeletePrivilege; 
oah_ChatRoom_slot; 
oah_ChatRoom_name; 
oahvm_ChatRoom; 


public 
public 
public 
// public 

public 
public 
public 
public 
// public 


Obj ectClassHandle 

AttributeHandleSet 

AttributeHandleSet 

AttributeHandleSet 

AttributeHandle 

AttributeHandle 

AttributeHandle 

AttributeHandle 

AttributeHandleValueMap 


och_Participant; 
oahs_Participant; 
oahs_Participant_forUpdate; 
oahs_Participant_chat_room_slot; 
oah_Participant_DeletePrivilege; 
oah_Participant_logged_in; 
oah_Participant_user_handle; 
oah_Participant_chat_room_slot; 
oahvm_Participant; 


public DimensionHandle 
public DimensionHandleSet 
public DimensionHandle 
public DimensIonHandleSet 


dh_UserHandleSlots; 
dhs_UserHandleSlotsSet; 
dh_ChatRoomSlots; 
dhs_ChatRoomSlotsSet; 


//The handle of the Region 
public RegionHandle 
public RegionHandleSet 
//The handle of the Region 
ChatRoom (slot 1) 

public RegionHandle 
public RegionHandleSet 
//The handle of the Region 
(slot 2) 

public RegionHandle 
public RegionHandleSet 
//The handle of the Region 
any (null otherwise) 

public RegionHandle 
public RegionHandleSet 
//The handle of the Region 
any (null otherwise) 

public RegionHandle 
public RegionHandleSet 


matched to "_nowhere" (slot 0) 
_rh_nowhere_ChatRoom; 
_rhs_nowhere_ChatRoom; 
matched to the "_waiting_room" 

_rh_waiting_room_ChatRoom; 
_rhs_waiting_room_ChatRoom; 
matched to the 11 <General>" ChatRoom 

_rh_general_ChatRoom; 
_rhs_general_ChatRoom; 
matched to our current ChatRoom, if 

_rh_current_ChatRoom; 
_rhs_current_ChatRoom; 
matched to our current UserHandle, if 

_rh_myParticipantRegion; 
_rhs_myParticipantRegion; 


//The list (size 2) of AttributeSet-RegionSet pairs used for 
Participant publish/subscribe 

//The AttributeSet will always be _oahs_Participant_forUpdate; 
//the RegionSet will always be one of _rh_nowhere_ChatRoom, 
_rh_waiting_room_ChatRoom or _rh_current_ChatRoom 
public AttributeSetRegionSetPairList 
_asrspl_Participant_nowhere; 

public AttributeSetRegionSetPairList 
_asrspl_Participant_waiting_room; 

public AttributeSetRegionSetPairList 
_asrspl_Participant_current; 


1236 


DRDC Valcartier TR 2007-412 



public boolean _me_logged_in = false,- 

public boolean _me_logging_in = false,- 

public boolean _alone = true; 

public boolean _me_shutting_down = false,- 


//The unique ChatRoomRegistry object instance 
public aChatRoomRegistry _ChatRoomRegistry = null; 

//The ChatRoomRegistry Semaphore, used in lieu of 
synchronized(_ChatRoomRegistry) 

public aos.jack.util.thread.Semaphore _sem_ChatRoomRegistry = 
new aos.jack.util.thread.Semaphore(),- 

//The nowhere_ChatRoom is never instantiated 
//The waiting_room ChatRoom 

final public aChatRoom _waiting_room_ChatRoom = new 
aChatRoom(_name_waiting_room_ChatRoom, _slot_waiting_room_ChatRoom),- 
//The general ChatRoom 

public aChatRoom _general_ChatRoom; // = new 
aChatRoom(_name_general_ChatRoom, _slot_general_ChatRoom),- 
//The ChatRoom we're in 
public aChatRoom _myChatRoom,- 

//The set of ChatRooms (keys are ObjectInstanceHandle, values 
are aChatRoom) 

public HashMap _theChatRooms = new HashMapO; 

//The ChatRooms Semaphore, used in lieu of 
synchronized(_theChatRooms) 

public aos.jack.util.thread.Semaphore _sem_theChatRooms = new 
aos.jack. util.thread. Semaphore () ,- 

//Note that JACK usually defines a Semaphore at the Agent level, 
//but in our case it must be at the HLAchat instance level 

public aParticipant _me = new aParticipant () ,- 
//The _me Semaphore, used in lieu of synchronized(_me) 
public aos.jack.util.thread.Semaphore _sem_me = new 
aos.jack. util.thread. Semaphore () ,- 

//List of known Participants (including ourselves); keys are 
ObjectlnstanceHandles, values are aParticipant objects 
public HashMap _theParticipants = new HashMapO; 

//The Participants Semaphore, used in lieu of 
synchronized(_theParticipants) 

public aos.jack.util.thread.Semaphore _sem_theParticipants = new 
aos.jack. util.thread. Semaphore () ,- 


DRDC Valcartier TR 2007-412 


1237 



//Set of observable semaphores 

//Name reservation semaphore 

public MyObservable sem_name_reservation = new MyObservable(); 

//ChatRoomRegistry Discovery semaphore 

public MyObservable sem_ChatRoomRegistry_discovery = new 
MyObservable(); 

//ChatRoomRegistry Acquisition semaphore 

public MyObservable sem_ChatRoomRegistry_acquisition = new 
MyObservable() ; 

//ChatRoomRegistry Divestiture semaphore 

public MyObservable sem_ChatRoomRegistry_divestiture = new 
MyObservable(); 

//ChatRoom Discovery semaphore 

public MyObservable sem_ChatRoom_discovery = new MyObservable(); 

//ChatRoom Acquisition semaphore 

public MyObservable sem_ChatRoom_acquisition = new 
MyObservable(); 

//ChatRoom Divestiture semaphore 

public MyObservable sem_ChatRoom_divestiture = new 
MyObservable() ; 

//Participant Discovery semaphore 

public MyObservable sem_Participant_discovery = new 
MyObservable(); 

//Participant Acquisition semaphore 

public MyObservable sem_Participant_acquisition = new 
MyObservable() ; 

//Participant Divestiture semaphore 

public MyObservable sem_Participant_divestiture = new 
MyObservable() ; 


1238 


DRDC Valcartier TR 2007-412 



* * 


* Constructor for HLAchat. 

* Because HLAchat extends 

ca.go.drdc_rddc.hla.rtil516.jack.capHLA1516.HLAfederate, 

* the constructor needs a reference to the HLAfederate's 
enclosing instance (the capability) 

*/ 

public 

HLAchat(ca.gc.drdc_rddc.hla.rtil516.jack.capHLA1516 the_cap, 
String the_username) 

throws aos.jack.jak.beliefset.BeliefSetException 

{ 

//Until the pre-processor bug is fixed, we cannot do this: 

// the_cap.super(the_username) ,- 

//To get around the bug, compile with the above line 
//commented out, then edit Server.java to uncomment the line 
//and recompile Server.class. 

//super constructor registers the_username with datHLA; 

//throws aos.jack.jak.beliefset.BeliefSetException if already 

in use 

System. out. println ( "HLAchat connecting..." ),- 
connected = j oinFederat ion () ,- 
if (lconnected) return; 

System. out. println ( "HLAchat connected..." ),- 
if (J getHandles () ) return,- 

System. out. println ( "HLAchat handles obtained..." ),- 
try { 

_ChatRoomRegistry = new aChatRoomRegistry () ,- //We couldn't 
do this in the field declarations because of the escaping Exception 
} catch (CouldNotDecode ignored) {} //try 

//We let the plans do the dispatching at the Relevance level, 

so we do: 


//Freeing up the other Semaphores 
_sem_ChatRoomRegistry. signal () ,- 
_sem_theChatRooms . signal () ,- 
_sem_theParticipants . signal () ,- 
_sem_me. signal () ,- 

System.out.println ( "HLAchat initialisation complete" ),- 
} //constructor 

private boolean 
j oinFederation () 

{ 

//Remaining initialisation 
try 
{ 

//Process the command-line arguments, if any 


if 

(Server.this. HLAargs l 

= null) 



if 

j 

(_: 

HLAargs l= null) 





1 

if 

( HLAargs.length 

> 0 

) rtiHost = 

HLAargs 

[0 


if 

( HLAargs.length 

> l 

) fdd 

HLAargs 

[1 


if 

( HLAargs.length 

> 2 

) fedex 

HLAargs 

[2 


if 

( HLAargs.length 

> 3 

) fedname = 

HLAargs 

[3 


} //if 


DRDC Valcartier TR 2007-412 


1239 



//Get the RTIambassador 
try 
{ 

_rtiAmbassador = rtiAmbassador = RTI.getRTIambassador( 
rtiHost, CRC_PORT ); 

} catch (Exception e) { 

System.out.println( "+++ HLAchat: Unable to connect to 
CRC on " + rtiHost + ":" + CRC_PORT ); 
return false,- 

} //try 

System.out.println( "HLAchat initialising - RTIambassador 

obtained" ),- 

//Destroy any lingering empty federation execution 
try 
{ 

_rtiAmbassador.destroyFederationExecution( fedex ),- 
System.out.println( "HLAchat initialising - Previous " 

+ fedex + " federation destroyed" ),- 

} catch (FederatesCurrentlyJoined ignored) { 

} catch (FederationExecutionDoesNotExist ignored) { 

} //try 

//Create the federation execution 
final File fddFile = new File(fdd); 
try 
{ 

_rtiAmbassador.createFederationExecution( fedex, 
fddFile.toURL() ); 

System.out.println( "HLAchat initialising - " + fedex + 
" federation created" ) ,- 

} catch (FederationExecutionAlreadyExists ignored) { 

} catch (CouldNotOpenFDD cnof) { 

System.out.println( "+++ HLAchat: Could not open FDD '" 
+ fddFile.getAbsoluteFile().toString() + "'" ),- 
return false,- 

} catch (ErrorReadingFDD erf) { 

System.out.println( "+++ HLAchat: Corrupt FDD '" + 
fddFile.getAbsoluteFile().toString() + "'" ),- 
return false,- 

} //try 

//Join the federation execution 

_federateHandle = _rtiAmbassador.j oinFederationExecution( 
fedname, fedex, this, null ),- 

System.out.println( "HLAchat initialising - Joined as " + 
_federateHandle ) ,- 

return true; 

} catch (Exception e) { 
e .printStackTrace () ,- 
return false,- 
} //try 

} //j oinFederation 


1240 


DRDC Valcartier TR 2007-412 



public void 

resignFederationExecution() 

{ 

try 


//Any remaining owned objects will be deleted (there 
should be none when !_alone, really) (well, maybe some Region 
obj ects...) 

System.out.println( "HLAchat shutting down - Resigning 
from federation" ),- 

_rtiAmbassador.resignFederationExecution( 

ResignAction.DELETE_OBJECTS_THEN_DIVEST ); 

//OwnershipAcquisitionPending, FederateOwnsAttributes, 
FederateNotExecutionMember, RTIinternalError 

try 


_rtiAmbassador.destroyFederationExecution( fedex ),- 
//FederatesCurrentlyJoined, 

FederationExecutionDoesNotExist, RTIinternalError 

} catch (FederatesCurrentlyJoined ignored) { 

} 

System.out.println( "HLAchat shutting down - Federation 
+ fedex + " destroyed" ) ,- 

connected = false; 

} catch (RTIexception e) { 
e . print St ackTr ace () ,- 
} //try 

} //resignFederationExecution 

private boolean 
getHandles () 

{ 

try 


handles 


obj ect/interaction and parameter/attribute 


_ich_Communication = 

rtiAmbassador . get Interact ionClassHandle ( "Communication" ) ,- 
_iph_Communication_message = 

rtiAmbassador . getParameterHandle ( _ich_Communication, "message" ) ,- 
_iph_Communication_sender = 

rtiAmbassador . getParameterHandle ( _ich_Communication, "sender" ) ,- 


DRDC Valcartier TR 2007-412 



_och_ChatRoomRegistry = 

_rtiAmbassador.getObjectClassHandle( "ChatRoomRegistry" ); 

_oah_ChatRoomRegistry_DeletePrivilege = 

_rtiAmbassador.getAttributeHandle( _och_ChatRoomRegistry, 

RTI.PrivilegeToDeleteObjectName ); //"HLAprivilegeToDeleteObject" ); 
_oah_ChatRoomRegistry_list 

_rtiAmbassador.getAttributeHandle( _och_ChatRoomRegistry, "list" ); 
//Build the attribute handle sets 
_oahs_ChatRoomRegistry = 

_rtiAmbassador.getAttributeHandleSetFactory() .create () ; 

_oahs_ChatRoomRegistry.add( _oah_ChatRoomRegistry_list ); 
_oahs_ChatRoomRegistry.add( 
_oah_ChatRoomRegistry_DeletePrivilege ); 

_oahs_ChatRoomRegistry_forUpdate = 

_rtiAmbassador.getAttributeHandleSetFactory().create(); 

_oahs_ChatRoomRegistry_forUpdate.add( 
_oah_ChatRoomRegistry_list ); 

_och_ChatRoom = _rtiAmbassador.getObj ectClassHandle( 

"ChatRoom" ); 

_oah_ChatRoom_DeletePrivilege = 

_rtiAmbassador.getAttributeHandle( _och_ChatRoom, 

RTI.PrivilegeToDeleteObjectName ); 

_oah_ChatRoom_name = _rtiAmbassador.getAttributeHandle( 
_och_ChatRoom, "name" ) ; 

_oah_ChatRoom_slot = _rtiAmbassador.getAttributeHandle( 
_och_ChatRoom, "slot" ); 

//Build the attribute handle sets 
_oahs_ChatRoom = 

_rtiAmbassador.getAttributeHandleSetFactory() .create() ; 

_oahs_ChatRoom.add( _oah_ChatRoom_DeletePrivilege ); 
_oahs_ChatRoom.add( _oah_ChatRoom_name ); 

_oahs_ChatRoom.add( _oah_ChatRoom_slot ); 

_oahs_ChatRoom_forUpdate = 

_rtiAmbassador.getAttributeHandleSetFactory() .create () ; 

_oahs_ChatRoom_forUpdate.add( _oah_ChatRoom_name ); 
_oahs_ChatRoom_forUpdate.add( _oah_ChatRoom_slot ); 

_och_Participant = _rtiAmbassador.getObj ectClassHandle( 
"Participant" ); 

_oah_Participant_DeletePrivilege = 

_rtiAmbassador.getAttributeHandle( _och_Participant, 

RTI.PrivilegeToDeleteObjectName ) ; 

_oah_Participant_logged_in 

_rtiAmbassador.getAttributeHandle( _och_Participant, "logged_in" ); 
_oah_Participant_user_handle 

_rtiAmbassador.getAttributeHandle( _och_Participant, "user_handle" ); 
_oah_Participant_chat_room_slot 

_rtiAmbassador.getAttributeHandle( _och_Participant, "chat_room_slot" 
) ; 


1242 


DRDC Valcartier TR 2007-412 



//Build the attribute handle sets 
_oahs_Participant = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

_oahs_Participant.add( _oah_Participant_DeletePrivilege ); 
_oahs_Participant.add( _oah_Participant_logged_in ); 
_oahs_Participant.add( _oah_Participant_user_handle ); 
_oahs_Participant.add( _oah_Participant_chat_room_slot ); 
_oahs_Participant_forUpdate = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

_oahs_Participant_forUpdate.add( 
_oah_Participant_logged_in ); 

_oahs_Participant_forUpdate.add( 
_oah_Participant_user_handle ); 

_oahs_Participant_forUpdate.add( 

_oah_Participant_chat_room_slot ); 

// _oahs_Participant_chat_room_slot = 

_rtiAmbassador.getAttributeHandleSetFactory().created; 

// _oahs_Participant_chat_room_slot.add( 

_oah_Participant_chat_room_slot ); 

_dh_UserHandleSlots = _rtiAmbassador.getDimensionHandle( 
"UserHandleSlots" ); 

_dh_ChatRoomSlots = _rtiAmbassador.getDimensionHandle( 
"ChatRoomSlots" ); 

_dhs_UserHandleSlotsSet = 

_rtiAmbassador.getDimensionHandleSetFactory().created; 

_dhs_UserHandleSlotsSet.add( _dh_UserHandleSlots ); 
_dhs_ChatRoomSlotsSet = 

_rtiAmbassador.getDimensionHandleSetFactory().created; 

_dhs_ChatRoomSlotsSet.add( _dh_ChatRoomSlots ); 

_rhs_nowhere_ChatRoom = 

_rtiAmbassador.getRegionHandleSetFactory().create(); 

_rh_nowhere_ChatRoom = _rtiAmbassador.createRegion( 
_dhs_ChatRoomSlotsSet ) ; 

//_nowhere_ChatRoom is slot 0 

_rtiAmbassador.setRangeBounds( _rh_nowhere_ChatRoom, 
_dh_ChatRoomSlots, new RangeBounds( _slot_nowhere_ChatRoom, 1 + 
_slot_nowhere_ChatRoom ) ) ; 

_rhs_nowhere_ChatRoom.add( _rh_nowhere_ChatRoom ); 

_rtiAmbassador.commitRegionModifications( 
rhs nowhere ChatRoom ); 


_rhs_waiting_room_ChatRoom = 
rtiAmbassador.getRegionHandleSetFactory().create(); 

_rh_waiting_room_ChatRoom = _rtiAmbassador.createRegion( 
dhs_ChatRoomSlotsSet ) ; 

//_waiting_room_ChatRoom is slot 1 

_rtiAmbassador.setRangeBounds( _rh_waiting_room_ChatRoom, 
dh_ChatRoomSlots, new RangeBounds( _slot_waiting_room_ChatRoom, 1 + 
slot_waiting_room_ChatRoom ) ); 

_rhs_waiting_room_ChatRoom.add( _rh_waiting_room_ChatRoom 


_rtiAmbassador.commitRegionModifications( 
rhs_waiting_room_ChatRoom ); 


DRDC Valcartier TR 2007-412 


1243 



//The General ChatRoom 
_rhs_general_ChatRoom = 

_rtiAmbassador.getRegionHandleSetFactory() .create () ; 

_rh_general_ChatRoom = _rtiAmbassador.createRegion( 
_dhs_ChatRoomSlotsSet ) ; 

//General ChatRoom is slot 2 

_rtiAmbassador.setRangeBounds( _rh_general_ChatRoom, 
_dh_ChatRoomSlots, new RangeBounds( _slot_general_ChatRoom, 1 + 
_slot_general_ChatRoom ) ); 

_rhs_general_ChatRoom.add( _rh_general_ChatRoom ); 

_rtiAmbassador.commitRegionModifications( 
_rhs_general_ChatRoom ); 

// _rh_current_ChatRoom = null; 

// _rh_myParticipantRegion = null; 

//For chat_room_slot filtering, we associate all 
"forUpdate" attributes to _dh_ChatRoomSlots regions 

//We'd get InvalidRegionContext when subscribing if we 
included the DeletePrivilege 

_asrspl_Participant_nowhere = 

_rtiAmbassador.getAttributeSetRegionsetPairListFactory().create(1); 

_asrspl_Participant_nowhere.add( new 
AttributeRegionAssociation( _oahs_Participant_forUpdate, 
_rhs_nowhere_ChatRoom ) ); 

_asrspl_Participant_waiting_room = 

_rtiAmbassador.getAttributeSetRegionsetPairListFactory() .create (1) ; 

_asrspl_Participant_waiting_room.add( new 
AttributeRegionAssociation( _oahs_Participant_forUpdate, 
_rhs_waiting_room_ChatRoom ) ); 

//There'll be no Communication traffic through the 
waiting_room; this is used only to find out 

//(through the Interaction Advisories) whether there are 
other federates or not. 

return true; 

} catch (Exception e) { 
e .printStackTrace() ; 
return false; 

} //try 

} //getHandles 


1244 


DRDC Valcartier TR 2007-412 



public void 
doUnsubscribe() 
{ 

try 


_rtiAmbassador.unsubscribelnteractionClassWithRegions( 
ich_Communication, _rhs_waiting_room_ChatRoom ); 

_rtiAmbassador.unsubscribeObj ectClassAttributes( 
och_ChatRoom, _oahs_ChatRoom_forUpdate ); 

rtiAmbassador.unsubscribeObj ectClassAttributesWithRegions( 
och_Participant, _asrspl_Participant_waiting_room ); 

_rtiAmbassador.unsubscribeObj ectClassAttributes( 
och_ChatRoomRegistry, _oahs_ChatRoomRegistry_forUpdate ); 

} catch (Exception e) { 
e.printStackTrace() ; 

} //try 

} //doUnsubscribe 

public void 
doUnpublish() 

{ 

try 


_rtiAmbassador.unpublishlnteractionClass( 
_ich_Communication ); 

_rtiAmbassador.unpublishObj ectClassAttributes( 
_och_ChatRoom, _oahs_ChatRoom_forUpdate ); 

//unassociateRegionsForUpdates can only be done on a per- 
instance basis 

_rtiAmbassador.unpublishObj ectClassAttributes ( 
_och_Participant, _oahs_Participant_forUpdate ); 

_rtiAmbassador.unpublishObj ectClassAttributes( 
_och_ChatRoomRegistry, _oahs_ChatRoomRegistry_forUpdate ); 

} catch (Exception e) { 
e.printStackTrace() ; 

} //try 

} //doUnpublish 

//Should be called when shutting down (by the garbage collector) 
public void finalize () 
throws Throwable 

{ 

super.finalize(); 

} //finalize 


DRDC Valcartier TR 2007-412 


1245 



II ########################### Utilities ########################### 


j k k 

* The various Seek utilities need to synchronize on the HashMap 

* being searched; within a Java thread, this is done through 

* the Semaphore.threadWait() method. 

* Within a Plan, however, this is done through 

* @wait_for( Semaphore.planWait() ) and the two shall not mix. 

* Although these methods are within a Java object, they are all 

* called from within a Plan, so what shall we do? 

* We could make them subtasks (i.e. stand-alone Plans with 

* corresponding Events) but this seems too much overhead. 

* So instead we move the synchronization outside the methods, 

* to the invoking Plans. 

* 

* There turns out to be much less need for synchronization 

* anyway; since there is but one Server agent, it keeps only 

* one Plan active at a time, and the default 

* SimpleTaskManager takes a "depth-first" approach. This means 

* a Plan is suspended only by a wait_for. FederateAmbassador 

* callbacks are all sent to the Server's posting queue, so a 

* certain sequentiality is maintained. 

* The Java HLA chat agent was much harder to code because it 

* involved a proliferation of threads. 

*/ 


j k k 

* This utility method finds the Participant object in the 
hashmap by its ObjectlnstanceHandle. 

* @param theObject an ObjectlnstanceHandle specifying the 
Participant sought 

* @return the sought Participant object, or null if not present 
*/ 

public aParticipant 

SeekParticipant(ObjectlnstanceHandle theObject) 

{ 

return (aPart icipant) _theParticipant s . get (theObj ect) ,- 
} //SeekParticipant 

j k k 

* This utility method finds the ChatRoom object in the hashmap 
by its ObjectlnstanceHandle. 

* @param theObject an ObjectlnstanceHandle specifying the 
ChatRoom sought 

* @return the sought ChatRoom object, or null if not present 
*/ 

public aChatRoom 

SeekChatRoom(Obj ectlnstanceHandle theObj ect) 

{ 

return (aChatRoom) _theChatRooms . get (theObj ect) ,- 
} //SeekChatRoom 


1246 


DRDC Valcartier TR 2007-412 



* * 


* This utility method finds the ChatRoom object in the hashmap 
by its name. 

* @param name a String specifying the ChatRoom.name sought 

* @return the sought ChatRoom object, or null if not present 
*/ 

public aChatRoom 
SeekChatRoomByName(String name) 

{ 

aChatRoom _ChatRoom,- 

for (Iterator i = _theChatRooms.entrySet().iterator(),- 
i.hasNext();) 


_ChatRoom = 

(aChatRoom) ((j ava.util.Map.Entry)i.next()) .getValue() ,- 

if (_ChatRoom.name.toString().equals(name)) return 

_ChatRoom; 

} //for 
return null; 

} //SeekChatRoomByName 

j * * 

* This utility method finds the ChatRoom object in the hashmap 
by its slot. 

* @param slot a short specifying the ChatRoom.slot sought 

* @return the sought ChatRoom object, or null if not present 
*/ 

public aChatRoom 
SeekChatRoomBySlot(short slot) 

{ 

aChatRoom _ChatRoom,- 

for (Iterator i = _theChatRooms . entrySet (). iterator () ,- 
i . hasNext () ,-) 


_ChatRoom = 

(aChatRoom) ( (j ava . ut il. Map . Entry) i . next () ) . getValue () ,- 

if (_ChatRoom. slot.getValue () == slot) return _ChatRoom,- 
} //for 
return null; 

} //SeekChatRoomBySlot 


DRDC Valcartier TR 2007-412 


1247 



* This utility method finds the Participant object in the 
hashmap by its name. 

* @param name a String specifying the Participant.name sought 

* @return the sought Participant object, or null if not present 
*/ 

public aParticipant 
SeekParticipantByName(String name) 

{ 

aParticipant _Participant,- 

for (Iterator i = _theParticipants .entrySet (). iterator () ,- 
i.hasNext();) 


_Participant = 

(aParticipant) ((j ava.util.Map.Entry)i.next()) .getValue(),- 

if (_Participant.name.toString () .equals(name)) return 
_Participant,- 

} //for 
return null; 

} //SeekParticipantByName 

j * * 

* This utility method finds the Participant object in the 
hashmap by its user_handle. 

* @param user_handle an int specifying the 
Participant.user_handle sought 

* @return the sought Participant object, or null if not present 
*/ 

public aParticipant 

SeekParticipantByUserHandle(int user_handle) 

{ 

aPart icipant _Part icipant ,- 

for (Iterator i = _theParticipants .entrySet (). iterator () ,- 
i .hasNext () ,-) 


_Participant = 

(aPart icipant) ( (j ava .util .Map . Entry) i .next () ) . getValue () ,- 

if (_Participant.user_handle.getValue() == user_handle) 
return -Participant,- 
} //for 
return null; 

} //SeekParticipantByUserHandle 


1248 


DRDC Valcartier TR 2007-412 



II ######################## aChatRoomRegistry ######################## 


public class 
aChatRoomRegistry 
{ 

//Whether we own the object or not 
public boolean 
owned = false; 

//Whether we subscribe to the object class or not 
II (and therefore whether the value is up to date or not) 
public boolean 
subscribed = false; 

//Whether we are divesting the object or not (makes sense 
only if owned) 

public boolean 
divesting = false; 

//The ChatRoomRegistry object's name 

final public String 

name = _name_ChatRoomRegistry; 

//The ChatRoomRegistry object's handle 
public Obj ectlnstanceHandle 
handle = null; 

//The ChatRoomRegistry object's list field 

public HLAChatRoomRegistryEntries 

list; 

j * * 

* Default constructor; the name is unique and the list pre- 
loaded with the "waiting_room" and <General>" ChatRooms. 

*/ 

public 

aChatRoomRegistry() 

throws CouldNotDecode 

{ 

list = new HLAChatRoomRegistryEntries() ; 

list.add ( list.size (), new HLAChatRoomRegistryEntry( new 
HLAunicodeString( _name_waiting_room_ChatRoom ), new HLAintegerlSBE( 
_slot_waiting_room_ChatRoom ) ) ); 

list.add ( list.size (), new HLAChatRoomRegistryEntry( new 
HLAunicodeString( _name_general_ChatRoom ), new HLAintegerlSBE( 
_slot_general_ChatRoom ) ) ) ; 

} //constructor 
} I /aChatRoomRegistry 

j * * 

//Exposing the constructor 
public aChatRoomRegistry 
getNewChatRoomRegistry() 

{ 

return new aChatRoomRegistry(); 

} I /getNewChatRoomRegistry 
*/ 


DRDC Valcartier TR 2007-412 


1249 



* Used by various methods to remove a ChatRoom from the 
registry and update the latter. 

* Remember that the ChatRoomRegistry only maps ChatRoom names 
to slots; it does not link 

* to ChatRoom object instances at all. 

* @param slot a short specifying the ChatRoom entry to remove 
*/ 

public void 

RemoveChatRoomAndUpdateRegistry(short slot) 

{ 

//Presumes _ChatRoomRegistry has been synchronized on 
try 


boolean updateNeeded = false; 

if (slot <= _slot_general_ChatRoom) return; //waiting_room 
and General are fixtures 

for ( int i = 0; i < _ChatRoomRegistry.list.size(); i++ ) 

{ 

if ( slot == ( 

(HLAChatRoomRegistryEntry)_ChatRoomRegistry.list.get(i) 

).slot.getValue() ) 


_ChatRoomRegistry.list.remove(i); 

updateNeeded = true; 

break; 

} //if 

} //for 

if (lupdateNeeded) return; 

AttributeHandleValueMap _ahvm_ChatRoomRegistry = 
rtiAmbassador.getAttributeHandleValueMapFactory() .create ( 
oahs_ChatRoomRegistry_forUpdate.size() ); 

_ahvm_ChatRoomRegistry.put( _oah_ChatRoomRegistry_list 
ChatRoomRegistry.list.toByteArray() ); 

_rtiAmbassador.updateAttributeValues( 

ChatRoomRegistry.handle, _ahvm_ChatRoomRegistry, null ); 

} catch (Exception ignored) { 

} 

} //RemoveChatRoomAndUpdateRegistry 


1250 


DRDC Valcartier TR 2007-412 



* * 


* Used by various methods to add a ChatRoom to the registry and 
update the latter. 

* The ChatRoom is also added to _theChatRooms 

* @param name a String specifying the ChatRoom name to give to 
the new entry (it'll be prefixed by the method) 

* @return the newly created aChatRoom object (null in case of 
failure) 

*/ 

public aChatRoom 

AddChatRoomAndUpdateRegistry(String name) 

{ 

//Presumes _ChatRoomRegistry has been synchronized on 
try 


//To allow user names and chat room names to be anything, 
the latter will be prefixed 

//by "p" and "o' 1 , respectively, whilst our reserved names 
will be prefixed by ,l _' 1 

String newChatRoomName = "o' 1 + name; 

aChatRoom _ChatRoom = SeekChatRoomByName (newChatRoomName) ,- 
if (_ChatRoom != null) return null; 

//At this point we know the name is OK; now find a slot 

number 

short candidate = _slot_FirstFreeChatRoomSlot ,- 
//Synchronization on _theChatRooms would normally be 
required but we'll omit it here 

for ( ,- null l= SeekChatRoomBySlot (candidate) ,- 
candidate++) ,- 

//We'll use candidate for the slot value 

_ChatRoomRegistry.list.add( _ChatRoomRegistry.list.size(), 
new HLAChatRoomRegistryEntry( newChatRoomName, new HLAintegerlSBE( 
candidate ) ) ); 

AttributeHandleValueMap _ahvm_ChatRoomRegistry = 

_rtiAmbassador.getAttributeHandleValueMapFactory().create( 
_oahs_ChatRoomRegistry_forUpdate . size () ) ,- 

_ahvm_ChatRoomRegistry.put( _oah_ChatRoomRegistry_list, 
_ChatRoomRegistry. list. toByteArray () ) ,- 

_rtiAmbassador.updateAttributeValues( 

_ChatRoomRegistry.handle, _ahvm_ChatRoomRegistry, null ) ,- 

_ChatRoom = new aChatRoom ( newChatRoomName, candidate ),- 
_ChatRoom.owned = _ChatRoom.subscribed = true; 

// synchronized(_theChatRooms) 

{ 

_theChatRooms.put( _ChatRoom.handle = 

_rtiAmbassador . registerObj ectlnstance ( _och_ChatRoom ) , _ChatRoom ) ,- 
} //synchronized(_theChatRooms) 
return _ChatRoom,- 
} catch (Exception ignored) { 

} 

return null; 

} //AddChatRoomAndUpdateRegistry 


DRDC Valcartier TR 2007-412 


1251 



II ########################### aChatRoom ########################### 


public class 
aChatRoom 
{ 

//Whether we own the object or not 
public boolean 
owned = false,- 

//Whether we subscribe to the object class or not 
//(and therefore whether the value is up to date or not) 
public boolean 
subscribed = false,- 

//Whether we are divesting the object or not (makes sense 
only if owned) 

public boolean 
divesting = false,- 
//The object's handle 
public Obj ectlnstanceHandle 
handle = null; 

//The ChatRoom object's name field 
public HLAunicodestring 
name ,- 

//The ChatRoom object's slot field 
public HLAintegerlSBE 
slot; 

j * * 

* Constructs a chat room named "unknown" with slot -1 (an 
illegal value, really). 

*/ 

public 
aChatRoom() 

{ 

this ( "unknown", (short)-1 ),- 
} //constructor 


value 

value 


j * * 

* Constructs a chat room of the specified name and slot. 

* @param aName a String specifying the ChatRoom's name field 

* @param aSlot a Short specifying the ChatRoom's slot field 


*/ 

public 

aChatRoom(String aName, short aSlot) 


slot = new HLAintegerlSBE (aSlot) ,- 
name = new HLAunicodeString (aName) ,- 
} //constructor 
} //aChatRoom 


1252 


DRDC Valcartier TR 2007-412 



//Exposing the constructors (until the Plan pre-processor bug is 

fixed) 

public aChatRoom 
getNewChatRoom () 

{ 

return new aChatRoom("unknown", (short)-1); 

} //getNewChatRoom 

public aChatRoom 

getNewChatRoom(String aName, short aSlot) 

{ 

return new aChatRoom(aName, aSlot); 

} //getNewChatRoom 

// ########################## aParticipant ########################## 

public class 
aParticipant 
{ 

//Whether we own the object or not 
public boolean 
owned = false; 

//Whether we subscribe to the object class or not 
//(and therefore whether the value is up to date or not) 
public boolean 
subscribed = false; 

//Whether we are divesting the object or not (makes sense 
only if owned) 

public boolean 
divesting = false; 

//Whether the object is in scope or not (relevant only if 
owned is false) 

//(we're forced to do this instead of localDelete) 
public boolean 
inscope = false; 

//The object's handle 
public Obj ectlnstanceHandle 
handle = null; 

//The object's name 

public HLAunicodeString 

name = new HLAunicodeString(); 

//The logged-in field 
public HLAboolean 
logged_in; 

//The user handle field 
public HLAinteger32BE 
user_handle; 

//The current chat room slot field 
public HLAintegerlSBE 
chat_room_slot; 


DRDC Valcartier TR 2007-412 


1253 



* * 


* Default constructor; the name is empty, logged_in is 

HLAfalse, 

* user_handle is 0 and chat_room_slot is 0 (waiting_room). 

*/ 

public 

aParticipant() 

{ 

logged_in = new HLAboolean (false) ,- 
user_handle = new HLAinteger32BE (0) ,- 
chat_room_slot = new HLAintegerlSBE( 

_slot_nowhere_ChatRoom ),- 
} //constructor 
} //aParticipant 

//Exposing the constructor (until the Plan pre-processor bug is 

fixed) 

public aParticipant 
getNewParticipant () 

{ 

return new aParticipant () ,- 
} //getNewParticipant 

// #################### Listeners and Responders #################### 

j * * 

* Where the Java application builds various FedAmb 

* Listener/Responder classes which the FedAmbWrapper dispatches 

* based on the callback's key parameter (typically the 

* interaction or object class), here we instead rely on the 

* generic listeners/responders which each post an event --the 

* FedAmbWrapper would have these set up using the null 

* discriminant. Dispatching now occurs at the plan level: each 

* HLA event is handled by a variety of plans, each with 

* different Relevance conditions (based on the event's key 

* field). 

*/ 


j * * 

* To invoke an inner constructor from outside the class, 

* you must use an instance of the enclosing class, like this: 

* instance_of_Server.new 

MylnteractionAdvisoryResponder(instance_of_HLAchat) 

*/ 


1254 


DRDC Valcartier TR 2007-412 



* * 


* Because the JACK event classes are public, in the same 

* package, and expose publicly the posting methods, we 

* could systematically have each handler do: 

* _server.postEvent( (new 

evtHLAinteractionScopeAdvisory () ) .create (_HLAchat, <HLA arguments>) ) ,- 

* ...except that this causes a NullPointerException in the JACK 

* posting internals. 

* Instead, we must have the Server agent "post" each event to 

* force it to create the factories, and then add public methods 

* to make these (private) factories available here: 

* _server.postEvent( 

_server.getEvtHLAinteractionScopeAdvisory().create(_HLAchat, <HLA 
arguments>) ) ,- 

* Alternately, any inner class of the agent can access the 

* instances directly since private access extends to the 

* enclosing class' body (in this case the agent). 

*/ 

} //HLAchat 

} 

//end Server 


The blfusers belief set is used by the Server to map usernames to the Client agent 
instance names. 


// File: blfusers.bel 
package server,- 

j * * 

The Users beliefset maps a username to the corresponding agent's full 
name (with the portal name). 

*/ 

public beliefset blfusers extends ClosedWorld { 

#key field String location,- 
#key field String username,- 

#indexed query get (String location, String username) ,- 
#indexed query get (logical String location, String username) ,- 
#indexed query get(logical String location, logical String 
username) ,- 

#indexed query get (String location, logical String username) ,- 

} 

//end blfusers 


DRDC Valcartier TR 2007-412 


1255 



The capProcessData capability regroups the events the Server receives from its 
Clients. 


// File: capProcessData.cap 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

import client.evtJoinGrp; 

import client.evtLeaveGrp; 

import client.evtListGrp; 

import client.evtLogout; 

import client.evtMessageGrp; 

import client.evtMessageUsr; 

import client.evtRequestGrpWho; 

j * * 

This capability implements the Server agent's data processing. 

*/ 

public capability 
capProcessData 

extends Capability 

{ 

#handles external event evtJoinGrp; 

#handles external event evtLeaveGrp; 

#handles external event evtListGrp; 

#handles external event evtLogout; 

#handles external event evtMessageGrp; 

#handles external event evtMessageUsr; 

#handles external event evtRequestGrpWho; 

#posts external event evtHLA_AcquireChatRoomRegistry 
evHLA_AcquireChatRoomRegistry; 

#posts external event evtHLA_ForceDivest evHLA_ForceDivest; 
#posts external event evtJoinGrp evJoinGrp; 

#sends event evtGrpName evGrpName; 

#sends event evtGrpWhoRes evGrpWhoRes; 

#sends event evtJoinRes evJoinRes; 

#sends event evtLeaveGrpRes evLeaveGrpRes; 

#sends event evtMessageUsrRes evMessageUsrRes; 

#sends event evtNoGrp evNoGrp; 

#uses plan plnJoinGrp; 

#uses plan plnLeaveGrp; 

#uses plan plnListGrp; 

#uses plan plnLogoutUsr; 

#uses plan plnMessageGrp; 

#uses plan plnMessageUsr; 

#uses plan plnRequestGrpWho; 

#imports data blfHLA datHLAO; 

#imports data blfUsers blfdatUsers(); 

} 

//end capProcessData 


1256 


DRDC Valcartier TR 2007-412 



The evtGrpName event represents a group name being sent to a Client in response 
to a request for a listing of current groups. The name is the group name instance 
carried. 


// File: evtGrpName.event 
package server; 

j * * 

This event is an envelope for the name of a group that currently exist 
in the chat network. 

*/ 

public event 
evtGrpName 

extends MessageEvent 

{ 

public String name; 

#posted as 
group(String name) 

{ 

this.name = name; 


//end evtGrpName 


The evtGrpwhoRes event represents a user name being sent to a Client in response 
to a request for a listing of those users sharing the current group. The user is the 
user name instance carried. 


// File: evtGrpwhoRes.event 
package server; 

j * * 

This event is an envelope for the username retrieved by the GrpWhoPlan 
plan. 

*/ 

public event 
evtGrpwhoRes 

extends MessageEvent 

{ 

public String user; 

#posted as 
result(String usr) 

{ 

user = usr; 


//end evtGrpwhoRes 


DRDC Valcartier TR 2007-412 


1257 



The evt JoinRes event represents the outcome of a user’s request to join a Chat 
group. The group is the name of the group the user wished to join; the result is 
the Boolean outcome. 


// File: evtJoinRes.event 
package server; 

j * * 

This event is an envelope for the data that is sent back to the Client 
agent, from the server, as a result of the join group procedure. The 
data stored in this event indicates the success or failure of the 
procedure. 

*/ 

public event 
evtJoinRes 

extends MessageEvent 

{ 

public boolean result; 
public String group,- 

#posted as 

result(String grp, boolean res) 

{ 

group = grp ,- 
result = res; 


//end evtJoinRes 


1258 


DRDC Valcartier TR 2007-412 



The evtLeaveGrpRes event represents the outcome of the user’s request to leave a 
Chat group. The group is the name of the group the user wished to leave; the 
result is the Boolean outcome. 


// File: evtLeaveGrpRes.event 
package server; 

j * * 

This event holds data which represents the success or failure of the 
removal of a user from a specified group. It stores this information 
in the form of a boolean to indicate the result and the name of the 
group. 

*/ 

public event 
evtLeaveGrpRes 

extends MessageEvent 

{ 

public boolean result; 
public String group; 

#posted as 

result(boolean res, String grp) 

{ 

result = res; 
group = grp; 


//end evtLeaveGrpRes 


DRDC Valcartier TR 2007-412 


1259 



The evtLoginRes event represents the outcome of a user’s request to log into the 
Chat federation. The status is the Boolean outcome; the location is the name of 
the JACK Client agent; the user is the user name. 


// File: evtLoginRes.event 
package server; 

j * * 

This event is an envelope for the data that is sent back to the client 
from the server, as a result of the login procedure. 

*/ 

public event 
evtLoginRes 

extends MessageEvent 

{ 

public boolean status; 
public String location- 
public String user; 

#posted as 

result(String username, String location, boolean logStatus) 

{ 

user = username ,- 

this . location = location- 

status = logStatus,- 


//end evtLoginRes 


The evtMessageUsrRes event represents the outcome of a request to send a private 
message to some other user. The user is the target user name; the result is the 
Boolean outcome. 


// File: evtMessageUsrRes.event 
package server,- 

j * * 

This event holds data which indicates whether or not the message was 
successfully sent to the user. 

*/ 

public event 
evtMessageUsrRes 

extends MessageEvent 

{ 

public boolean result; 
public String user; 

#posted as 

result(boolean status, String user) 

{ 

this.result = status,- 
this.user = user; 


//end evtMessageUsrRes 


1260 


DRDC Valcartier TR 2007-412 



The evtNoGrp event is sent to the Client when it requests a listing of users for a 
non-existent chat group. The group is the name of the requested group. 


// File: evtNoGrp.event 
package server; 

j * * 

This event is sent to the Client agent to indicate that no group 
exists with that name. 

*/ 

public event 
evtNoGrp 

extends MessageEvent 

{ 

public String group; 

#posted as 
group(String grp) 

{ 

group = grp; 


//end evtNoGrp 


The evtRelayMessg event represents a message being relayed by the Server to the 
Client. Note that no distinction is made between public and private messages. The 
messg is the relayed message; the fromUsr is the originating user’s name. 


// File: evtRelayMessg.event 
package server; 

j * * 

This event is an envelope for the message being sent. 

*/ 

public event 
evtRelayMessg 

extends MessageEvent 

{ 

public String fromUsr; 
public String messg; 

#posted as 

relay(String msg, String user) 

{ 

messg = msg; 
fromUsr = user; 


//end evtRelayMessg 


DRDC Valcartier TR 2007-412 


1261 



The evtHLA_AcquireChatRoomRegistry event represents the sub-task of 
acquiring the ChatRoomRegistry. It is posted by the Server to itself. The 
identifier indicates which HLAchat is involved. 


// File : evtHLA_AcquireChatRoomRegistry.event 
package server; 

j * * 

Occurs when a plan needs to subtask the acquisition of the 
ChatRoomRegistry. 

*/ 

public event 

evtHLA_AcquireChatRoomRegistry 
extends Event 

{ 

public String identifier; 

#posted as 

create(String identifier) 

{ 

this.identifier = identifier; 


//end evtHLA_AcquireChatRoomRegistry 


The evtHLA ForceDivest event represents the sub-task of aggressively divesting 
all of a federate’s owned objects, as part of its log out procedure. It is posted by the 
Server to itself. The identifier indicates which HLAchat is involved. 


// File: evtHLA_ForceDivest.event 
package server; 

j * * 

Occurs when a JACK client wants to shutdown and must therefore divest 
itself of any owned objects. 

*/ 

public event 
evtHLA_ForceDivest 
extends Event 

{ 

public String identifier; 

#posted as 

create(String identifier) 

{ 

this.identifier = identifier; 


//end evtHLA_ForceDivest 


1262 


DRDC Valcartier TR 2007-412 



The evtHLA_ParticipantEntersGeneralchatRoom event represents the sub¬ 
task of entering the Participant object in the General ChatRoom, as part of the log in 
procedure. It is posted by the Server to itself. The identifier indicates which 
HLAchat is involved. 


// File: evtHLA_ParticipantEntersGeneralChatRoom.event 
package server; 

j * * 

* Handles the process of entering the (owned) Participant 

* into the General ChatRoom 
*/ 

public event 

evtHLA_ParticipantEntersGeneralChatRoom 
extends Event 

{ 

public String identifier; 

#posted as 

create(String identifier) 

{ 

this.identifier = identifier; 


//end evtHLA_ParticipantEntersGeneralChatRoom 


DRDC Valcartier TR 2007-412 


1263 



The plnJoinGrp plan handles the process of joining a chat group. 


// File: plnJoinGrp.java 
package server; 

import hla . rtil516 . * 
import client.evtJoinGrp,- 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

This plan handles the evtJoinGrp event, sent by the Client when it 
wants to Join a Group (ChatRoom). 

It initially checks whether or not the group specified already exists. 
If the group exists then the user is added to the group. 

Otherwise a new group is created and the user is added to it. 

In both cases, to follow the HLA chat rules we combine the actual join 
with a Leave Group. 

*/ 

public plan 
plnJoinGrp 

extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtJoinGrp ev,- 
#posts event evtHLA_AcquireChatRoomRegistry 
evHLA_AcquireChatRoomRegistry ,- 

#sends event evtJoinRes evJoinRes,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 

static boolean relevant(evtJoinGrp ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.user, _HLA ) && 

( (HLA = (Server . HLAchat) _HLA. as_obj ect () ) l= null); 


1264 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 


//Because the viewKeyboard.processLine uses a StringTokenizer, 
//the ev.group String is guaranteed to be non-trivial 
//(not zero length, nor with leading or trailing blanks). 
//However, in the old JACK code, you could "Join" the default 
//ChatRoom ("General"),- within the HLA chat rules, you cannot. 
//You use the Leave command for that. 

//Since the operation is essentially the same, we will change 
//the plnLeaveGrp so it simply posts an evtJoinGrp with 
//"_<General>" as the target. 

//We could implement this by either: 

// 1) Adding a boolean field to the evtJoinGrp so we can 
distinguish between Join and Leave,- or 

// 2) Exploiting the known characteristics of ev.group by 
sending a zero-length ev.group. 

//We cannot do 1) because that would entail changing the 
//viewKeyboard in the client package. Hence, we stipulate Leave 
//will post an evtJoinGrp with a zero-length ev.group 

//If joining the _<General> ChatRoom, no need to change 
ChatRoomRegistry 

String _newChatRoomName ,- 

Server . HLAchat. aChatRoom _newChatRoom,- 

//Whether the target ChatRoom existed already or not 

//(also used in the evtJoinRes fired back at the Client) 

boolean extantGroup ,- 

if ( ev.group.length() != 0 ) 

{ 

_newChatRoomName = "c" + ev. group,- 
@wait_for ( HLA._sem_theChatRooms . planWait () ) ,- 
// synchronized(_theChatRooms) 

{ 

_newChatRoom = HLA. SeekChatRoomByName ( _newChatRoomName ),- 
} //synchronized(_theChatRooms) 

HLA._sem_theChatRooms . signal () ,- 
extantGroup = (null != _newChatRoom) ,- 
//If not found, create it 
if (lextantGroup) 

{ 

@subtask( evHLA_AcquireChatRoomRegistry.create( ev.user ) 

) ,- //HLA.username 

// synchronized(HLA.AcquireChatRoomRegistry()) 

{ 

_newChatRoom = 

HLA.AddChatRoomAndUpdateRegistry (ev. group) ,- 
//_newChatRoomName.substring(1) 

} //synchronized(AcquireChatRoomRegistry()) 
HLA._sem_ChatRoomRegistry. signal () ,- 

} //if 

} else { 

_newChatRoomName = HLA._name_general_ChatRoom,- 
@wait_for ( HLA._sem_theChatRooms . planWait () ) ,- 
_newChatRoom = HLA._general_ChatRoom = 

HLA.SeekChatRoomBySlot ( HLA._slot_general_ChatRoom ),- 
HLA._sem_theChatRooms . signal () ,- 
extantGroup = (null != _newChatRoom) ,- 


DRDC Valcartier TR 2007-412 


1265 



//If not found, create it 
if (lextantGroup) 

{ 

@subtask( evHLA_AcquireChatRoomRegistry.create) ev.user ) 

); //HLA.username 

// synchronized(HLA.AcquireChatRoomRegistry()) 

{ 

// HLA._general_ChatRoom = HLA.new aChatRoom) 

HLA._name_general_ChatRoom, HLA._slot_general_ChatRoom ),- 
HLA._general_ChatRoom = HLA.getNewChatRoom( 
HLA._name_general_ChatRoom, HLA._slot_general_ChatRoom ); //Awaiting 
bug fix 

HLA._general_ChatRoom.owned = 

HLA._general_ChatRoom.subscribed = true; 

// HLA._general_ChatRoom.divesting = false,- 

@wait_for( HLA._sem_theChatRooms.planWait() ),- 

// synchronized(_theChatRooms) 

{ 

HLA._theChatRooms.put( HLA._general_ChatRoom.handle 
= HLA._rtiAmbassador.registerObjectInstance( HLA._och_ChatRoom) , 
HLA._general_ChatRoom ),- 

//No need to add the General ChatRoom to the 
_ChatRoomRegistry, as it is already listed 

} //synchronized(_theChatRooms) 

HLA._sem_theChatRooms.signal(),- 
} //synchronized(AcquireChatRoomRegistry()) 
HLA._sem_ChatRoomRegistry.signal() ,- 
_newChatRoom = HLA._general_ChatRoom; 

} //if 
} //if 

//At this point, _newChatRoom exists 
//Moving to the _newChatRoom 

//The change of ChatRooms cannot be from nowhere or 
//waiting_room,- it has to be from an active ChatRoom, including 
//the "_<General>" ChatRoom. 

HLA._rtiAmbassador.unassociateRegionsForUpdates( HLA._me.handle 
HLA._asrspl_Participant_current ) ,- 

//At this point, _me.handle is only associated with 
_asrspl_Participant_nowhere 


1266 


DRDC Valcartier TR 2007-412 



//Unsubscribe from the current ChatRoom 

HLA._rtiAmbassador.unsubscribelnteractionClassWithRegions( 
HLA._ich_Communication, HLA._rhs_current_ChatRoom ); 

//Look at the ChatRoom we're leaving to decide whether to delete 
it or not 

int count = 0; 

@wait_for( HLA._sem_theParticipants.planWait() ); 

// synchronized(_theParticipants) 

{ 

Server.HLAchat.aParticipant _iParticipant; 
for (java.util.Iterator i = 

HLA._theParticipants.values().iterator(); i.hasNext () ;) 

{ 

_iParticipant = (Server.HLAchat.aParticipant)i.next(); 
//Out of scope Participants have unreliable attributes; 
they cannot be in our ChatRoom in any case 

//The only exceptions are owned Participants: any owned 
orphans can only be in the waiting_room 
//_me isn't counted 

if ((lHLA._me.equals(_iParticipant.handle)) && 
(_iParticipant.inscope) && 

(HLA._me.chat_room_slot.equals(_iParticipant.chat_room_slot)) ) 

count++; 

} //for 

} //synchronized(_theParticipants) 

HLA._sem_theParticipants.signal(); 

//This'll cause the Participants in our ChatRoom to go out of 

scope 

HLA._rtiAmbassador.unsubscribeObj ectClassAttributesWithRegions( 
HLA._och_Participant, HLA._asrspl_Participant_current ); 

//What if someone logs into the ChatRoom after we've counted its 
Participants but before we actually delete it? 

Server.HLAchat.aChatRoom _previousChatRoom = HLA._myChatRoom; 
HLA._myChatRoom = _newChatRoom; 

//Modify asrspl and delete old region, unless it was the General 
ChatRoom 

RegionHandle _rh_previous_ChatRoom = HLA._rh_current_ChatRoom; 
//= (RegionHandle)_rhs_current_ChatRoom.toArray()[0]; 
HLA._asrspl_Participant_current.remove(0); 

HLA._rhs_current_ChatRoom.remove( _rh_previous_ChatRoom ); 
if (!_rh_previous_ChatRoom.equals( HLA._rh_general_ChatRoom )) 

{ 

HLA._rtiAmbassador.deleteRegion( _rh_previous_ChatRoom ); 

} //if 


DRDC Valcartier TR 2007-412 


1267 



//New region 

if (_newChatRoomName.equals(HLA._name_general_ChatRoom)) 

{ 

HLA._rh_current_ChatRoom = HLA._rh_general_ChatRoom; 

} else { 

HLA._rh_current_ChatRoom = HLA._rtiAmbassador.createRegion( 
HLA._dhs_ChatRoomSlotsSet ) ; 

HLA._rtiAmbassador.setRangeBounds( HLA._rh_current_ChatRoom ; 
HLA._dh_ChatRoomSlots, new RangeBounds( 

HLA._myChatRoom.slot.getValue(), 1 + HLA._myChatRoom.slot.getValue() ) 

) ; 

} //if 

HLA._rhs_current_ChatRoom.add( HLA._rh_current_ChatRoom ); 
HLA._rtiAmbassador.commitRegionModifloations( 
HLA._rhs_current_ChatRoom ); //Won't complain if there are no mods to 
commit 

//Regenerate asrspl 

HLA._asrspl_Participant_current.add( new 
AttributeRegionAssociation( HLA._oahs_Participant_forUpdate, 
HLA._rhs_current_ChatRoom ) ); 

HLA._me.chat_room_slot.setValue( HLA._myChatRoom.slot.getValue() 

) ; 

//Go back in 

//This'll reveal the participants in the new ChatRoom 
HLA._rtiAmbassador.subscribeObj ectClassAttributesWithRegions( 
HLA._och_Participant, HLA._asrspl_Participant_current ); 

//Re-open the communication channel for the new ChatRoom 
HLA._rtiAmbassador.subscribelnteractionClassWithRegions( 
HLA._ich_Communication ; HLA._rhs_current_ChatRoom ); 

//Reveal ourselves to the new ChatRoom 

HLA._rtiAmbassador.associateRegionsForUpdates( HLA._me.handle, 
HLA._asrspl_Participant_current ); 


1268 


DRDC Valcartier TR 2007-412 



//Delete old ChatRoom? 

if (count <= 0) //Should be just ==0 but you never know (because 
of inscope, _me isn't counted) 

{ 

//We were the only Participant left in the old ChatRoom,- 
delete it as we leave (we must be the owner, obviously) 

@subtask( evHLA_AcquireChatRoomRegistry. create ( ev.user ) ),- 

//HLA.username 

// synchronized(HLA.AcquireChatRoomRegistry()) 

{ 

//Because we're the owner, we won't get a 
RemoveObj ectInstance notification 

//The remove returns the removed value, which is 
_previousChatRoom 

@wait_for ( HLA._sem_theChatRooms . planWait () ) ,- 

// synchronized(_theChatRooms) 

{ 

HLA._rtiAmbassador.deleteObj ectInstance( 

((Server.HLAchat.aChatRoom)HLA._theChatRooms.remove( 

_previousChatRoom.handle ) ).handle, null ),- 

} //synchronized(_theChatRooms) 

HLA._sem_theChatRooms . signal () ,- 
HLA.RemoveChatRoomAndUpdateRegistry( 

_previous ChatRoom. slot. get Value () ) ,- 

} //synchronized(AcquireChatRoomRegistry()) 
HLA._sem_ChatRoomRegistry. signal () ,- 
} else if (_previousChatRoom.owned) { 

//There are other Participants but we were the owner: 
transfer ownership 

_previousChatRoom. divesting = true ,- 

HLA._rtiAmbassador.negotiatedAttributeOwnershipDivestiture( 
_previousChatRoom.handle, HLA._oahs_ChatRoom, null ) ,- 

} //if 

// send an acknowledgement message event back to the user 
if (!_newChatRoomName.equals(HLA._name_general_ChatRoom)) 

// if (lev.group.equals("") ) 

{ 

@send( ev.from, evJoinRes. result ( ev.group, extantGroup ) ),- 

System.err.println( " (joining '" + ev.user + "' to group 
' " + ev.group + " ' ) " ) ,- 
} 

// When ev.group is this plan was invoked as a subtask of 

plnLeaveGrp ,- 

// we must then defer to it to send the acknowledgement back 
// (since we've lost track of the ev.from) 


//end plnJoinGrp 


DRDC Valcartier TR 2007-412 


1269 



The plnLeaveGrp plan handles the overall process of removing a Client from its 
current group. 


// File: plnLeaveGrp.java 
package server; 

import client.evtJoinGrp,- 
import client.evtLeaveGrp,- 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

This plan handles the evtLeaveGrp event, sent by the Client when it 
wants to Leave a Group (ChatRoom). 

It removes the user from a specified group if the group exists. 

It also removes the group from the network if that group is empty. 
Because of the HLA chat rules, the Client will always Leave its 
current group (because it can no longer belong to more than one 
group) . 

*/ 

public plan 
plnLeaveGrp 

extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtLeaveGrp ev,- 
#posts event evtJoinGrp evJoinGrp,- 
#sends event evtJoinRes evJoinRes,- 
#sends event evtLeaveGrpRes evLeaveGrpRes,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 

static boolean relevant(evtLeaveGrp ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.user, _HLA ) && 

( (HLA = (Server . HLAchat) _HLA. as_obj ect () ) l= null); 


1270 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 


//We re-use the plnJoinGrp by sub-tasking 
//See if Leaving correct group (the current one) 
if (HLA._myChatRoom.name.toString().substring(1).equals( 
ev.group )) 


//Yes (treat as Joining the _<General> ChatRoom) 

@subtask( evJoinGrp. j oin ( " 11 , ev.user) ),- 

@send( ev.from, evLeaveGrpRes.result( true, ev.group ) ),- 
System.out.println ( 11 (removing 1,1 + ev.user + 11 ' from 
group ' 11 + ev.group + 11 ' ) 11 ) ,- 

@send( ev.from, evJoinRes. result ( "<General>", true ) ),- 

System.out.println ( 11 (joining 1,1 + ev.user + 11 ' to group 
' <General >' ) " ) ,- 
} else { 

//No 

@send( ev.from, evLeaveGrpRes. result ( false, ev.group ) ),- 
System. err . println ( 11 (group 1,1 + ev.group + 11 ' incorrect)' 1 

) ; 

} //if 


//end plnLeaveGrp 


The plnListGrp plan handles the overall process of giving the Client a list of all 
current groups. 


// File: plnListGrp.java 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import client. evtListGrp,- 

j * * 

This plan handles the evtListGrp event, which occurs when the Client 
sends the "group" command. 

Originally, it posted an Inference Goal Event (evtListGrpIGE) to 
retrieve all group names from blfdatGrpList. 

*/ 

public plan 
plnListGrp 

extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtListGrp ev,- 
#sends event evtGrpName evGrpName,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 


DRDC Valcartier TR 2007-412 


1271 



static boolean relevant(evtListGrp ev) 

{ 

return true; 


context () 

{ 

//Where most other events sent by the Client specify the 
username 

//(in the ev.user field, filled from ((Client) 
self) .getUserName()) , 

//this evtListGrp does not. Luckily, we can recover it 
//from the ev.from, which will be of the form 
"username@portalname". 

datHLA.get( ev.from.substring(0, ev.from.indexOf("@")), _HLA ) 

&& 

( (HLA = (Server . HLAchat) _HLA. as_obj ect () ) l= null); 


#reasoning method 
body () 

{ 

System. out. println ( 11 (retrieving group names)' 1 ),- 
@wait_for ( HLA._sem_theChatRooms . planWait () ) ,- 
{ 

for (java.util.Iterator i = 

HLA._theChatRooms .values (). iterator () ,- i . hasNext () ,- ) 

{ 

Server.HLAchat.aChatRoom _ChatRoom = 

(Server .HLAchat. aChatRoom) i . next () ,- 
//Skip _waiting_room 

if (!_ChatRoom.name.toString() .equals ( 
HLA._name_waiting_room_ChatRoom )) 

{ 

//Report General room differently 

if (_ChatRoom.name.equals( HLA._name_general_ChatRoom 


@send ( ev.from, evGrpName .group ( "General" ) ),- 
} else { 

@send( ev.from, evGrpName.group( 

ChatRoom. name. toString () . substring (1) ) ) ,- 

} 

System.out.println( " (reporting group '" + 
ChatRoom. name. toString () + " ' ) " ),- 
} 

} //for 

} //synchronized (_theChatRooms) 

HLA._sem_theChatRooms . signal () ,- 


//end plnListGrp 


1272 


DRDC Valcartier TR 2007-412 



The plnLoginUser plan handles the delicate process of logging a user in. 


// File: plnLoginUser.java 
package server; 

import j ava.io.*; 

import j ava.util.StringTokenizer; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

import client.evtUserLogin; 

j * * 

This plan is responsible for adding a new user to the chat network. 

It only adds the user if there is no user currently logged on with the 
specified username. 

*/ 

public plan 
plnLoginUser 

extends Plan 

{ 

BufferedReader buf; 

#handles event evtUserLogin ev; 

#posts event evtHLA_ForceDivest evHLA_ForceDivest; 

#sends event evtLoginRes evLoginRes; 

#uses interface Server server; 

#uses data blfHLA datHLA; 

#uses data blfUsers blfdatUsers; 

static boolean relevant(evtUserLogin ev) 

{ 

return true; 


context() 

{ 

true ; 


DRDC Valcartier TR 2007-412 


1273 



#reasoning method 
body () 


/* If another Client was created on the same host machine 
at the same time (to within 1 ms), it'll have the same 
portal name (ev.from) (see StartClient to see why). 

We could detect this rare occurrence but there's nothing we 
could do about it since any messages fired back at that 
portal would have only a 50% chance of reaching the right 
agent. This could be improved by using the username as a 
discriminator, but what if they *also* try to log in 
under the same name? 

*/ 

j * * 

* In the original code, the plan skipped straight to a 

* vewdatUserData.addUser query, which decided whether or 

* not the login was successful. 

* With HLA, things are more complicated, so we must 

* do things at the plan level before querying any 

* Views or Belief Sets. 

*/ 

System. out. println ( "Logging user in as '" + ev.username + ),- 

//Create the HLAchat instance for the client 
Server.HLAchat HLA; 
try { 

// HLA = server.new HLAchat (ev.username) ,- 

HLA = server . newHLAchat (ev. username) ,- 
} catch (aos.jack.jak.beliefset.BeliefSetException e) { 

// Send a MessageEvent back to the client to indicate that 
// the login procedure was a failure. 

@send( ev.from, evLoginRes.result( ev.username, ev.from, 
false ) ) ,- 

System.err.println( "Couldn't log user in. HLA RTI connection 
failed or username already logged in." ),- 

return true,- //Plan succeeds (but login fails) 


System. out. println ( " HLA federate created" ),- 
//HLAchat's constructor joins the federation and obtains the 
//various handles,- it sets up its generic FederateAmbassador 
//callbacks and creates the ChatRoomRegistry Java object but 
//does not publish/subscribe anything. 

// 

//Note that if HLA isn't stored it'll go out of scope once this 
//plan concludes and will be garbage-collected. Its finalize() 
// method invokes disconnect() if it made it as far as joining 
//the federation, 
if (HLA.connected) 

{ 

//We don't need to store a reference to the Server.HLAchat 
//instance because its constructor stores itself (at the 
//HLA1516.capHLA1516.HLAfederate level) in datHLA (and the 
//class of the stored instance is indeed HLAchat) 


1274 


DRDC Valcartier TR 2007-412 



//Publish/Subscribe the interaction 
HLA._rtiAmbassador.publishlnteractionClass ( 
HLA._ich_Communication ) ,- 

HLA._rtiAmbassador.subscribelnteractionClassWithRegions( 
HLA._ich_Communication, HLA._rhs_waiting_room_ChatRoom ),- 

//By subscribing through the waiting room only, we only 
//trigger the advisories, without risking to get any 
//Communications (because the waiting room is not a valid 
//Communication "target"). 

//Note that at this point the waiting room ChatRoom may not 
//exist yet. 

//Set up ChatRoomRegistry, creating the HLA object if 

necessary 

HLA._rtiAmbassador.publishObj ectClassAttributes( 
HLA._och_ChatRoomRegistry, HLA._oahs_ChatRoomRegistry_forUpdate ) ,- 
// Reserve name 

HLA. sem_name_reservat ion. cl ear Changed () ,- 
//We must create the semaphore before calling 
//reserveObjectlnstanceName in the (unlikely) case that the 
//nameReservationOutcome callback occurs before this task 
//reaches the wait_for statement. 

//With a single-threaded Agent, this cannot occur anyway. 
System. out. println ( "Looking up Chat Room Registry..." ),- 
HLA._rtiAmbassador.reserveObj ectlnstanceName( 

HLA._ChatRoomRegistry.name ) ,- 

//Wait for reservation succeeded/failed 

//The name reservation handler for ChatRoomRegistry takes 
//care of creating the ChatRoomRegistry (if the reservation 
//was successfull) or of waiting for its discovery (if not) 
//The flag takes care of the case where the callback occurs 
before we reach the wait_for 

@wait_for( new aos.jack.util.cursor.Change ( 

HLA. sem_name_reservation, HLA. sem_name_reservat ion. hasChanged () ) ) ,- 

//Assert: At this point, HLA._ChatRoomRegistry is known 

//Set up ChatRooms, creating the _waiting_room HLA object if 

necessary 

HLA._rtiAmbassador.publishObj ectClassAttributes( 

HLA._och_ChatRoom, HLA._oahs_ChatRoom_forUpdate ) ,- 
// Reserve _waiting_room name 

HLA. sem_name_reservation. clearChanged () ,- //Alternative to 
new MyObservable () ,- 

HLA._rtiAmbassador.reserveObj ectlnstanceName( 

HLA._name_waiting_room_ChatRoom ) ,- 

//Wait for reservation succeeded/failed 

//The flag takes care of the case where the callback occurs 
before we reach the wait_for 

System. out. println ( "Looking up Waiting Room..." ),- 
@wait_for( new aos.jack.util.cursor.Change( 

HLA. sem_name_reservation, HLA. sem_name_reservat ion. hasChanged () ) ) ,- 

//Assert: At this point, HLA._waiting_room_ChatRoom is known 
//There is a small chance that the waiting room's attributes 

have 

//not been updated yet, but that should sort itself out 
pretty quickly. 


DRDC Valcartier TR 2007-412 


1275 



//Setup Participants 

HLA._rtiAmbassador.publishObj ectClassAttributes( 
HLA._och_Participant, HLA._oahs_Participant_forUpdate ),- 

//Note that associateRegionsForUpdates can be done only on a 
per-instance basis 

//We publish federation-wide but will update and subscribe 
through DDM 

//No federate *ever* subscribes to the nowhere "ChatRoom" 
HLA._rtiAmbassador.subscribeObj ectClassAttributesWithRegions( 
HLA._och_Participant, HLA._asrspl_Participant_waiting_room ),- 

//Log in proper 
HLA._me_logging_in = true; 

HLA._me.name.setValue( "p" + ev.username ),- //HLA.username ),- 
// HLA._me.handle = null; //ObjectInstanceHandle of the 

Participant obj ect 

// HLA._me.user_handle.setValue(0); //Same value, as an HLAint32 

for DDM purposes 

// Reserve username 

HLA.sem_name_reservation.clearChanged(); //Alternative to 
new MyObservable(),- 

HLA._rtiAmbassador.reserveObj ectInstanceName( 

HLA._me.name.toString() ),- 

// Wait for reservation succeeded/failed 

System. out .println ( "Looking up + ev.username + ),- 

//HLA.username 

@wait_for( new aos.jack.util.cursor.Change( 

HLA.sem_name_reservation, HLA.sem_name_reservation.hasChanged() ) ),- 

if (HLA._me_logged_in) 

{ 

HLA._rtiAmbassador.subscribelnteractionClassWithRegions( 
HLA._ich_Communication, HLA._rhs_current_ChatRoom ); 

HLA._rtiAmbassador.subscribelnteractionClassWithRegions( 
HLA._ich_Communication, HLA._rhs_myParticipantRegion ); 

} else { 

//Log in failed, remove ourselves from belief set 

datHLA. remove ( ev. username, HLA ),- 

} //if 
} //if 


1276 


DRDC Valcartier TR 2007-412 



if (lHLA.connected) 


//If the constructor succeeded, ev.username has been 
registered, even if the connection later failed 
datHLA.remove ( ev.username, HLA ),- 

// Send a MessageEvent back to the client to indicate that 
// the login procedure was a failure. 

@send( ev.from, evLoginRes.result( ev.username, ev.from, 
false ) ) ,- 

System.err.println( "Couldn't log user in. HLA RTI connection 
failed." ) ,- 

} else if (!HLA._me_logged_in) { 

@send( ev.from, evLoginRes.result( ev.username, ev.from, 
false ) ) ,- 

System.err.println( "Couldn't log user in. Username already 
exists ." ) ,- 

//Must disconnect now 
HLA._me_shutting_down = true; 

HLA. doUnsubscribe () ,- 

@subtask( evHLA_ForceDivest. create ( ev.username ) ),- 
HLA. doUnpublish () ,- 
HLA. resignFederationExecution () ,- 
//Garbage collector should deal with HLA now 
System .go () ,- 
} else { 

// Add new user to the Users beliefset 
// CAREFUL: Sorting the fields of a beliefset changes 
// the sequence of parameters in the add/remove methods! 
blfdatUsers . add ( ev.from, ev.username ),- 

System.out.println("Added '" + ev.username + "' to Users 
belief set."); 

// Send a MessageEvent back to the client to indicate that 
// the login procedure was a success. 

@send( ev.from, evLoginRes.result( ev.username, ev.from, true 

) ) ; 

System. out. println ( "User successfully logged in." ),- 

} //if 


//end plnLoginUser 


DRDC Valcartier TR 2007-412 


1277 



The plnLogoutUsr plan handles the process of logging a user out. 


// File: plnLogoutUsr.java 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import client.evtLogout; 

j * * 

This plan handles the evtLogout event which occurs when the Client 
logs out. 

After the considerable HLA clean up, it removes the username from the 
Users (and datHLA) belief set(s). 

*/ 

public plan 
plnLogoutUsr 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtLogout ev,- 

#posts event evtHLA_AcquireChatRoomRegistry 
evHLA_AcquireChatRoomRegistry; 

#posts event evtHLA_ForceDivest evHLA_ForceDivest,- 
#uses interface Server server; 

#uses data blfHLA datHLA; 

#uses data blfUsers blfdatUsers; 

static boolean relevant(evtLogout ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.user, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body () 


//Log out procedure 

System. out. print In ("HLAchat shutting down ..."),- 
HLA._me_shutting_down = true; 

HLA._me_logged_in = false; 

//Move from "current" ChatRoom to "waiting_room" ChatRoom 
//Unsubscribe from the current ChatRoom 

HLA._rtiAmbassador.unsubscribelnteractionClassWithRegions(HLA._ich_Com 
munication, HLA._rhs_current_ChatRoom); 

//Unsubscribe from the user handle channel 

HLA._rtiAmbassador.unsubscribelnteractionClassWithRegions(HLA._ich_Com 
munication, HLA._rhs_myParticipantRegion) ,- 


1278 


DRDC Valcartier TR 2007-412 



//Look at the ChatRoom we're leaving to decide whether to delete 
it or not 

int count = 0; 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 
{ 

Server.HLAchat.aParticipant _iParticipant,- 
for ( java.util.Iterator i = 

HLA._theParticipants.values().iterator(); i.hasNext();) 

{ 

_iParticipant = (Server.HLAchat.aParticipant)i.next(),- 
//Out of scope Participants have unreliable attributes; 
they cannot be in our ChatRoom in any case 

//The only exceptions are owned Participants: any owned 
orphans can only be in the waiting_room 
//_me isn't counted 

if ( ( lHLA._me.handle.equals(_iParticipant.handle) ) && 

( _iParticipant.inscope ) && 

( HLA._me.chat_room_slot.equals( 

_iParticipant.chat_room_slot ) ) ) count++; 

} 

} //synchronized(_theParticipants) 

HLA._sem_theParticipants.signal(),- 

//This'll cause the Participants in our ChatRoom to go out of 

scope 

HLA._rtiAmbassador.unsubscribeObj ectClassAttributesWithRegions( 
HLA._och_Participant, HLA._asrspl_Participant_current ),- 

//What if someone logs into the ChatRoom after we've counted its 
Participants but before we actually delete it? 

//Doesn't seem worth synchronizing on _myChatRoom 
if (count <= 0) //Should be just ==0 but you never know (because 
of inscope, _me isn't counted) 

{ 

//We were the only Participant left in the ChatRoom; delete 
it as we leave (we must be the owner, obviously) 

@subtask( evHLA_AcquireChatRoomRegistry. create ( ev.user ) ),- 

//HLA.username 
{ 

// HLA._theChatRooms . remove ( HLA._myChatRoom.handle ) ,- 

//Because we're the owner, we won't get a RemoveObjectlnstance 
notification 

// HLA._rtiAmbassador.deleteObj ectlnstance( 

HLA._myChatRoom.handle, null ),- 

//Because we're the owner, we won't get a 
RemoveObj ectlnstance notification 

//The remove returns the removed value, which is 

_myChatRoom 

HLA._rtiAmbassador.deleteObj ectlnstance( ( 

(Server.HLAchat.aChatRoom)HLA._theChatRooms.remove( 

HLA._myChatRoom.handle ) ) .handle, null ) ,- 

HLA.RemoveChatRoomAndUpdateRegistry( 

HLA._myChatRoom. slot. getValue () ) ,- 

} //synchronized(AcquireChatRoomRegistry()) 
HLA._sem_ChatRoomRegistry. signal () ,- 


DRDC Valcartier TR 2007-412 


1279 



This is now done in doForceDivest: 
else if (HLA._myChatRoom.owned) 

{ 

//There are other Participants but we were the owner: 
transfer ownership 

HLA._myChatRoom.divesting = true,- 

HLA._rtiAmbassador.negotiatedAttributeOwnershipDivestiture( 
HLA._myChatRoom.handle, HLA._oahs_ChatRoom, null ),- 
} 

*/ 

HLA._myChatRoom = null; 

//The _me Participant is the only one that can be elsewhere than 
the waiting_room and be owned; 

//by definition, an owned Participant stands in for the federate 
in whichever ChatRoom it is 

//Move it from current to waiting_room 

HLA._rtiAmbassador.unassociateRegionsForUpdates( HLA._me.handle, 
HLA._asrspl_Participant_current ) ,- 

@wait_f or ( HLA._sem_me . planWait () ) ,- 

{ 

HLA._me . logged_in. setBoolean (false) ,- 
HLA._me.chat_room_slot.setValue( 
HLA._slot_waiting_room_ChatRoom ) ,- 

HLA._rtiAmbassador.associateRegionsForUpdates( 

HLA._me .handle, HLA._asrspl_Participant_waiting_room ) ,- 

//AutoProvide will fetch our attribute update (since all 
federates subscribe to the waiting_room ChatRoom at all times) 

} //synchronized(_me) 

HLA._sem_me . signal () ,- 

HLA._me = HLA.getNewParticipant(); 

// HLA._me = HLA.new aParticipant () ,- //awaiting bug fix 

//Delete the now unused regions 

HLA._rhs_myParticipantRegion.remove( HLA._rh_myParticipantRegion 

) ; 

HLA._rtiAmbassador . deleteRegion ( HLA._rh_myParticipantRegion ) ,- 
HLA._rh_myParticipantRegion = null ,- 
HLA._rhs_myParticipantRegion = null ,- 

if ( lHLA._rh_current_ChatRoom.equals(HLA._rh_general_ChatRoom) 

) 

{ 

HLA._rtiAmbassador . deleteRegion ( HLA._rh_current_ChatRoom ) ,- 
HLA._rh_current_ChatRoom = null; 


//Here begins the exitForm equivalent 
HLA. doUnsubscribe () ,- 

@subtask( evHLA_ForceDivest. create ( ev.user ) ),- //or 

HLA.username 

HLA. doUnpubl i sh () ,- 

HLA. resignFederationExecution () ,- 


1280 


DRDC Valcartier TR 2007-412 



//Remove ourselves from datHLA 

System.out.println("Logging + ev.user + out."); 

datHLA.remove( ev.user, HLA ),- 

// Remove user from the Users beliefset. 

logical String location,- 

blfdatUsers .get ( location, ev.user ),- 

blfdatUsers. remove ( location. as_string () , ev.user ),- 

System. out. println ( "Logged user '" + ev.user + "' out." ),- 

//Garbage collector should deal with HLA now 

System.go(),- 


//end plnLogoutUsr 


The plnMessageGrp plan handles the sending of a message to the current group. 


// File: plnMessageGrp.java 
package server; 

import client. evtMessageGrp ,- 
import ca .go . drdc_rddc . hi a . rt 11516 . omt. * ,- 
import ca.go.drdc_rddc.hla.rt11516.jack.blfHLA; 
import hla. rt 11516 

j * * 

This plan handles the evtMessageGrp, which occurs when a Client sends 
"msg" to its current group. 

Like plnRequestGrpWho, the original design posted an Inference Goal 
Event to unify over the various usernames associated to the current 
group. 

Here we simply send the HLA interaction. 

*/ 

public plan 
plnMessageGrp 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtMessageGrp ev,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 

static boolean relevant(evtMessageGrp ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.fromUsr, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


DRDC Valcartier TR 2007-412 


1281 



#reasoning method 
body () 


// @post( msgGrpIGE.message( ev.group, ev.messg, ev.from, 
ev.fromUsr ) ) ,- 

System. out.println ( " (sending message to group 1,1 + ev.group 
+ " ’ ) " ) ; 

//The message could be the zero-length String 

HLAunicodeString us_cmdline = new HLAunicodeString (ev. messg) ,- 
//Note that there is no such thing as a ParameterHandleSet 
ParameterHandleValueMap _phvm_parameters = 

HLA._rtiAmbassador.getParameterHandleValueMapFactory().create(2),- 
_phvm_parameters.put( HLA._iph_Communication_message, 
us_cmdline.toByteArray() ),- 

_phvm_parameters.put( HLA._iph_Communication_sender, 

HLA._me.name.toByteArray() ) ,- 

HLA._rtiAmbassador.sendlnteractionWithRegions( 
HLA._ich_Communication, _phvm_parameters, HLA._rhs_current_ChatRoom, 
null ) ; 


//end plnMessageGrp 


The plnMessageUsr plan handles the sending of a message to a specific user. 


// File: plnMessageUsr.java 
package server; 

import ca.go.drdc_rddc.hla.rtil516.omt.*,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import hla.rtil516.*; 
import client.evtMessageUsr; 

j * * 

This plan handles the evtMessageUsr event, which occurs when the 
Client uses "msgusr" to send a message to a specific user. 

If the target user is not within the same ChatRoom, then a 
MessageUsrRes with false as the field value for 'result 1 will be sent 
back to the sending user. 

This is because the HLA rules restrict private messaging to within the 
current ChatRoom. 

*/ 

public plan 
plnMessageUsr 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtMessageUsr ev,- 

#sends event evtMessageUsrRes evMessageUsrRes ,- 

#uses interface Server server,- 

#reads data blfHLA datHLA; 


1282 


DRDC Valcartier TR 2007-412 



static boolean relevant(evtMessageUsr ev) 


return true; 


context() 

{ 

datHLA.get( ev.fromUsr, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body() 

{ 

//The message could be the zero-length String 

HLAunicodeString us_cmdline = new HLAunicodeString (ev.messg) ,- 
//Note that there is no such thing as a ParameterHandleSet 
ParameterHandleValueMap _phvm_parameters = 

HLA._rtiAmbassador.getParameterHandleValueMapFactory(). create (2 ) ,- 
_phvm_parameters.put( HLA._iph_Communication_message, 
us_cmdline.toByteArray() ),- 

_phvm_parameters.put( HLA._iph_Communication_sender, 

HLA._me.name.toByteArray() ),- 

//We'll use DDM to send the message to a single user (within the 
same chat room) 

//The Participant object has three attributes, all three of 
which are bound 

//to the ChatRoomSlots dimension; in addition, user_handle is 
bound to UserHandleSlots. 

//To allow user names and chat room names to be anything, the 
latter will be prefixed 

//by "p" and "c", respectively, whilst our reserved names will 
be prefixed by 

HLAunicodeString _us_TargetName = new HLAunicodeString("p" + 
ev. toUsr) ,- 

@wait_f or ( HLA._sem_thePart icipants . planWait () ) ,- 
// synchronized(_theParticipants) 

{ 

//Target may or may not be known or even extant, since the 
Client can specify any ID 
// ObjectlnstanceHandle key = 

HLA._rt iAmbassador . getObj ectlnstanceHandle ( "p" + ev. toUsr ),- 
Server.HLAchat.aParticipant _Participant = 
HLA.SeekParticipantByName ( _us_TargetName . toString () ) ,- 

//_me is usually not in scope (being owned), so you cannot 
talk to yourself 


DRDC Valcartier TR 2007-412 


1283 



if ((-Participant == null) || (l_Participant.inscope) || 

(!_Participant.logged_in.getBoolean())) 

{ 

@send ( ev.from, evMessageUsrRes.result( false, ev.toUsr ) 

) ; 

System. err . println ( " (target user 1,1 + ev.toUsr + " ' 
not found) 11 ) ,- 

HLA._sem_theParticipants.signal(),- 
return true,- 


//The _ich_Communication interaction has two dimensions: 
UserHandleSlots and ChatRoomSlots 

RegionHandle _rh_aParticipant = 

HLA._rtiAmbassador.createRegion( HLA._dhs_UserHandleSlotsSet ),- 
HLA._rtiAmbassador.setRangeBounds( _rh_aParticipant, 
HLA._dh_UserHandleSlots, new RangeBounds( 

_Participant.user_handle.getValue(), 

_Participant.user_handle.getValue() + 1 ) ),- 

RegionHandleSet _rhs_aParticipant = 

HLA._rtiAmbassador.getRegionHandleSetFactory().create(),- 
_rhs_aParticipant.add(_rh_aParticipant),- 
HLA._rtiAmbassador.commitRegionModifications( 
_rhs_aParticipant ),- 

HLA._rtiAmbassador.sendlnteractionWithRegions( 
HLA._ich_Communication, _phvm_parameters, _rhs_aParticipant, null ),- 
//Now throw the region away 

_rhs_aParticipant.remove( _rh_aParticipant ),- 
HLA._rtiAmbassador.deleteRegion( _rh_aParticipant ),- 
} //synchronized(_theParticipants) 

HLA._sem_theParticipants.signal(); 

// Send an acknowledgement message back to the sending user. 
@send ( ev.from, evMessageUsrRes .result (true, ev.toUsr) ),- 
System. out. println ( 11 (sending message to 1,1 + ev.toUsr + 11 ') 11 


//end plnMessageUsr 


1284 


DRDC Valcartier TR 2007-412 



The plnRequestGrpwho plan handles a Client request for a list of other users 
within the same group. 


// File: plnRequestGrpwho.java 
package server; 

import client.evtRequestGrpWho,- 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

This plan handles the evtRequestGrpWho, which occurs when a Client 
asks "who' 1 belongs to a given Group (could be its current one) . 

It checks whether the group exists (is known); if it does, in the 
original design it posts an evtGrpWhoIGE; if it does not, it sends 
back an evtNoGrp. 

Since evtGrpWhoIGE is an Inference Goal Event, it runs all applicable 
instances of Plans,- the plnGrpWho then used its context () to unify 
over all usernames found associated with the requested group. 

This rather clever use of an IGE is not applicable here, so we do away 
with the event and plan altogether (We can do this because they are 
internal to server). We only keep the original's outcome, the series 
of evtGrpWhoRes events it sends back to the Client. 

*/ 

public plan 
plnRequestGrpwho 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtRequestGrpWho ev,- 
#sends event evtGrpWhoRes evGrpWhoRes,- 
#sends event evtNoGrp evNoGrp,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 

static boolean relevant(evtRequestGrpWho ev) 

{ 

return true; 


DRDC Valcartier TR 2007-412 


1285 



context () 


//Where the other events sent by the Client specify the 
username 

//(in the ev.user field, filled from ((Client) 
self) .getUserName ()), 

//this evtRequestGrpWho does not. Luckily, we can recover it 
//from the ev.from, which will be of the form 
"username@portalname". 

// datHLA.get( ev.owner, _HLA ) && 

// server .println ( Thread. currentThread () + 11 

plnRequestGrpWho.context: username is <" + ev.from.substring (0, 
ev.from.indexOf("@")) + ">" ) && 

datHLA.get( ev.from.substring(0, ev.from.indexOf("@")), _HLA ) 

&& 

( (HLA = (Server . HLAchat) _HLA. as_obj ect () ) l= null); 


#reasoning method 
body() 

{ 

Server . HLAchat. aChatRoom _ChatRoom,- 
@wait_for ( HLA._sem_theChatRooms . planWait () ) ,- 
{ 

//The Client will ask for "General" when it means 
"_<General>" 

//(it is allowed to "Join General", which creates 
" cGeneral") ,- 

//the local name will hide the global. 

_ChatRoom = HLA. SeekChatRoomByName (" c" + ev. group) ,- 

} 

HLA._sem_theChatRooms . signal () ,- 

if ((_ChatRoom == null) && (ev.group.equals("General"))) 
_ChatRoom = HLA. _general_Chat Room ,- 


1286 


DRDC Valcartier TR 2007-412 



if 


(_ChatRoom l= null) 


// group does exist 
//Original design was: 

// @post( evGrpWhoIGE.who( ev.group, ev.from ) ),- 

// System. out. println ( " (retrieving members of group 1,1 + 

ev.group + 11 ' ) 11 ),- 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 

{ 

for (java.util.Iterator i = 

HLA._theParticipants.values().iterator(); i.hasNext () ,- ) 


Server.HLAchat.aParticipant _Participant = 
(Server.HLAchat.aParticipant)i.next(),- 

// me is filtered out because it is not in 


owned) 


if 

Participant.chat 


(_Participant.inscope && 
room_slot.equals( _ChatRoom.slot ) ) 


scope 


(being 


@send( ev.from, evGrpWhoRes.result( 

Part icipant. name . toString () . substring (1) ) ) ,- 

System. out. println ( 11 (reporting group member 1,1 + 
Part icipant. name . toString () + 11 ' ) 11 ),- 

} //if 

} //for 
//Add _me 

if (HLA._me.chat_room_slot.equals( _ChatRoom.slot )) 


// HLA.username is: 

//ev.from.substring(0, ev.from.indexOf("@")) 

// or equivalently 

//HLA._me.name.toString().substring(1) 

@send ( ev.from, evGrpWhoRes.result( 

HLA._me . name . toString (). substring (1) ) ) ,- 

// System.out.println ( 11 (reporting group member 'p" + 

HLA. _me . name . toString (). substring (1) + 11 ' ) 11 ),- //HLA. username 

System. out. println ( 11 (reporting group member 1,1 + 
HLA. me.name + "' ) " ),- 


} //synchronized(_theParticipants) 
HLA._sem_theParticipants . signal () ,- 
} else { 

// group doesn't exist 

@send( ev.from, evNoGrp. group ( ev.group ) ),- 

System. err . println ( 11 (group 1,1 + ev. group + 11 ' not 
extant) " ) ,- 

} //if 


//end plnRequestGrpWho 


DRDC Valcartier TR 2007-412 


1287 



The plnHLA AcquireChatRoomRegistry plan handles the (frequent) sub-task of 
securing ownership of the ChatRoomRegistry. 


// File : plnHLA_AcquireChatRoomRegistry.j ava 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

This subtask takes care of acquiring the ChatRoomRegistry for a 
specific HLAchat instance. It is meant to be called as a @subtask() 

*/ 

public plan 

plnHLA_AcquireChatRoomRegistry 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLA_AcquireChatRoomRegistry ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLA_AcquireChatRoomRegistry ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body () 

{ 

@wait_for( HLA._sem_ChatRoomRegistry.planWait() ),- 

//Presumably the Semaphore will remain grabbed by this thread 
//and will therefore pass from this plan to the invoking one 
if (HLA._ChatRoomRegistry.owned) return true; 

HLA.sem_ChatRoomRegistry_acquisition.clearChanged(),- 
HLA._rtiAmbassador.attributeOwnershipAcquisition( 

HLA._ChatRoomRegistry.handle, HLA._oahs_ChatRoomRegistry, null ) ,- 
@wait_for( new aos.jack.util.cursor.Change( 

HLA.sem_ChatRoomRegistry_acquisition, 

HLA. sem_ChatRoomRegistry_acquisit ion. hasChanged () ) ) ,- 

//Failure to acquire is not an option 


//end plnHLA_AcquireChatRoomRegistry 


1288 


DRDC Valcartier TR 2007-412 



The plnHLAForceDivest plan handles the sub-task of aggressively divesting 
ownership of any still-owned objects, in order to complete a Client’s withdrawal 
from the Chat federation. 


// File: plnHLA_ForceDivest.java 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

This subtask takes care of divesting any owned objects during 
shutdown. It is meant to be called as a @subtask() 

*/ 

public plan 
plnHLA_ForceDivest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLA_ForceDivest ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLA_ForceDivest ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null); 


#reasoning method 
divestChatRoomRegistry() 

{ 

//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

if (lHLA._ChatRoomRegistry.owned) return true; 

HLA.sem_ChatRoomRegistry_divestiture.clearChanged(),- 
HLA._ChatRoomRegistry.divesting = true,- 

HLA._rtiAmbassador.negotiatedAttributeOwnershipDivestiture( 

HLA._ChatRoomRegistry.handle, HLA._oahs_ChatRoomRegistry, null ) ,- 
@wait_for( new aos.j ack.util.cursor.Change( 

HLA.sem_ChatRoomRegistry_divestiture, 

HLA. sem_ChatRoomRegistry_divest iture . hasChanged () ) ) ,- 

//Other federates will receive 
requestAttributeOwnershipAssumption and 

//respond with attributeOwnershipAcquisitionlfAvailable. 

//We'll get requestDivestitureConfirmation, to which we'll 
confirmDivestiture 

//Once that is done, we no longer own _ChatRoomRegistry and can 
resign normally. 

} //divestChatRoomRegistry 


DRDC Valcartier TR 2007-412 


1289 



#reasoning method 
divestChatRooms () 


//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

//Any federate callbacks requesting ownership assumption will be 
turned down right away; 

//however, ownership acquisition notifications could conceivably 
squeak through 

//(if another federate started shutting down just before this 
one does) and would lock 

//up on the synchronized(_theChatRooms), so we take a snapshot 
and release the monitor right away. 

Server.HLAchat.aChatRoom[] _ChatRooms; 

@wait_for( HLA._sem_theChatRooms.planWait() ); 

{ 

_ChatRooms = (Server.HLAchat.aChatRoom[]) 

HLA._theChatRooms.values().toArray( new Server.HLAchat.aChatRoom[0] ); 

} //synchronized(_theChatRooms) 

HLA._sem_theChatRooms.signal(); 

// for (Iterator i = HLA._theChatRooms.entrySet().iterator() ; 
i.hasNext();) 

for (int i = 0; i < _ChatRooms.length; i++) 

{ 

// _ChatRoom = (Server.HLAchat.aChatRoom)( 

(java.util.Map.Entry)i.next() ).getValue(); 

Server.HLAchat.aChatRoom _ChatRoom = _ChatRooms[i]; 
if (_ChatRoom.owned) 

{ 

HLA.sem_ChatRoom_divestiture.clearChanged(); 

_ChatRoom.divesting = true; 

HLA._rtiAmbassador.negotiatedAttributeOwnershipDivestiture( 

_ChatRoom.handle, HLA._oahs_ChatRoom, null ); 

@wait_for( new aos.jack.util.cursor.Change( 

HLA.sem_ChatRoom_divestiture, 

HLA.sem_ChatRoom_divestiture.hasChanged() ) ); 

} //if 

} //for 

} //divestChatRooms 


1290 


DRDC Valcartier TR 2007-412 



#reasoning method 
divestParticipants() 


//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 

//Any federate callbacks requesting ownership assumption will be 
turned down right away; 

//however, ownership acquisition notifications could conceivably 
squeak through 

//(if another federate started shutting down just before this 
one does) and would lock 

//up on the synchronized(_theParticipants), so we take a 
snapshot and release the monitor right away. 

Server.HLAchat.aParticipant[] _Participants,- 
@wait_for( HLA._sem_theParticipants.planWait() ) ,- 
{ 

_Participants = (Server.HLAchat.aParticipant[] ) 
HLA._theParticipants.values().toArray( new 
Server.HLAchat.aParticipant[0] ) ,- 

} //synchronized(_theParticipants) 

HLA._sem_theParticipants.signal(),- 
// for (Iterator i = HLA._theParticipants . entrySet (). iterator () ,- 
i.hasNext();) 

for (int i = 0; i < _Participants.length; i++) 

{ 

// _Participant = (Server.HLAchat.aParticipant)( 

(j ava.util.Map.Entry)i.next() ) .getValue() ,- 

Server.HLAchat.aParticipant _Participant = _Participants[i],- 
if (_Participant.owned) 

{ 

HLA.sem_Participant_divestiture.clearChanged(),- 
_Participant.divesting = true; 

HLA._rtiAmbassador.negotiatedAttributeOwnershipDivestiture( 
_Participant .handle, HLA._oahs_Participant, null ) ,- 

@wait_for( new aos.j ack.util.cursor.Change( 

HLA.sem_Participant_divestiture, 

HLA. sem_Participant_divest iture . hasChanged () ) ) ,- 

} //if 

} //for 

} //divestParticipants 

#reasoning method 
body() 


//No action required if last federate out 
if (HLA._alone) return true; 

//This method is invoked when the federate wants to shut down 
but still owns some instance attributes 
//ChatRoomRegistry object 
divestChatRoomRegistry () ,- 
//ChatRoom objects 
divestChatRooms () ,- 
//Participant obj ects 
divestParticipants () ,- 


//end plnHLA_ForceDivest 


DRDC Valcartier TR 2007-412 


1291 



The plnHLA_chatRoomRegistry_Discovery plan handles the discovery ofthe 
ChatRoomRegistry object. 


// File : plnHLA_ChatRoomRegistry_Discovery.j ava 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAdiscoverObj ectInstance- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles HLA ChatRoomRegistry Discovery 
*/ 

public plan 

plnHLA_ChatRoomRegistry_Discovery 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAdiscoverObjectlnstance ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAdiscoverObjectlnstance ev) 

{ 

return ev.objectName.equals( 

Server.HLAchat._name_ChatRoomRegistry ); 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
ev.theObjectClass.equals( HLA._och_ChatRoomRegistry ); 


#reasoning method 
body () 


// Server.HLAchat HLA = (Server.HLAchat)_HLA.as_object(); 
HLA._ChatRoomRegistry.handle = ev.theObj ect; 

//Signal the waiting plnHLA_ChatRoomRegistryNameReservation that 
we're done 

HLA.sem_ChatRoomRegistry_discovery.setChanged(); 


//end plnHLA_ChatRoomRegistry_Discovery 


1292 


DRDC Valcartier TR 2007-412 



The plnHLA_ChatRoomRegistry_NameReservation_Failed plan handles the 
failed outcome of the ChatRoomRegistry name reservation. 


// File: plnHLA_ChatRoomRegistry_NameReservation_Failed.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationFa 
iled; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the evtHLAobj ectInstanceNameReservationFailed for 
ChatRoomRegistry 
*/ 

public plan 

plnHLA_ChatRoomRegistry_NameReservation_Failed 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAobj ectInstanceNameReservationFailed ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAobj ectInstanceNameReservationFailed 

ev) 


return 

ev.obj ectName.equals(Server.HLAchat._name_ChatRoomRegistry) ,- 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body() 

{ 

//Name reservation failed, which means there is an already 
extant instance 

HLA. sem_ChatRoomRegistry_discovery. clearChanged () ,- 
HLA._ChatRoomRegistry. subscribed = true ,- 
HLA._rtiAmbassador.subscribeObj ectClassAttributes( 
HLA._och_ChatRoomRegistry, HLA._oahs_ChatRoomRegistry_forUpdate ) ,- 
@wait_for( new aos.j ack.util.cursor.Change( 

HLA.sem_ChatRoomRegistry_discovery, 

HLA. sem_ChatRoomRegistry_discovery. hasChanged () ) ) ,- 

//Signal the waiting plnLoginUser that we're done 
HLA. sem_name_reservat ion. setChanged () ,- 


//end plnHLA_ChatRoomRegistry_NameReservation_Failed 


DRDC Valcartier TR 2007-412 


1293 



The plnHLA_ChatRoomRegistry_NameReservation_Succeeded plan handles 
the successful outcome of the ChatRoomRegistry name reservation. 


// File : plnHLA_ChatRoomRegistry_NameReservation_Succeeded.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationSu 
cceeded; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the evtHLAobj ectInstanceNameReservationSucceeded for 
ChatRoomRegistry 
*/ 

public plan 

plnHLA_ChatRoomRegistry_NameReservation_Succeeded 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAobj ectInstanceNameReservationSucceeded ev; 
#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean 

relevant(evtHLAobj ectInstanceNameReservationSucceeded ev) 

{ 

return 

ev.obj ectName.equals(Server.HLAchat._name_ChatRoomRegistry) ,- 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body () 

{ 

//Having reserved the name, we know we're the first federate 
//to reach this point, so we must create the ChatRoomRegistry. 
HLA._ChatRoomRegistry.owned = HLA._ChatRoomRegistry.subscribed = 

true ,- 

// HLA._ChatRoomRegistry.divesting = false; 

HLA._ChatRoomRegistry.handle = 

HLA._rtiAmbassador.registerObj ectlnstance( HLA._och_ChatRoomRegistry, 
HLA._ChatRoomRegistry.name ) ,- 

HLA._rtiAmbassador.subscribeObj ectClassAttributes( 
HLA._och_ChatRoomRegistry, HLA._oahs_ChatRoomRegistry_forUpdate ) ,- 
//Signal the waiting plnLoginUser that we're done 
HLA. sem_name_reservat ion. set Changed () ,- 


//end plnHLA_ChatRoomRegistry_NameReservation_Succeeded 


1294 


DRDC Valcartier TR 2007-412 



The plnHLA_ChatRoomRegistry_OwnershipAcquisitionFailed plan handles 
the failed outcome of a ChatRoomRegistry ownership acquisition attempt. 


// File: plnHLA_ChatRoomRegistry_OwnershipAcquisitionFailed.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipUnavaliable; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the AttributeOwnershipUnavailable notification for 
ChatRoomRegistry 
*/ 

public plan 

plnHLA_ChatRoomRegistry_OwnershipAcquisitionFailed 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributeOwnershipUnavailable ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAattributeOwnershipUnavailable ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 

// ev.theObj ectClass.equals( 

((Server.HLAchat)_HLA.as_object())._och_ChatRoomRegistry ); 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoomRegistry ); 


#reasoning method 
body() 

{ 

// Server.HLAchat HLA = (Server.HLAchat)_HLA.as_object(); 
HLA.sem_ChatRoomRegistry_acquisition.setChanged(); 


//end plnHLA_ChatRoomRegistry_OwnershipAcquisitionFailed 


DRDC Valcartier TR 2007-412 


1295 



The plnHLA_ChatRoomRegistry_OwnershipAcquisitionNotification plan 
handles the successful outcome of a ChatRoomRegistry ownership acquisition 
attempt. 


// File: plnHLA_ChatRoomRegistry_OwnershipAcquisitionNotification.java 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipAcquisitionNo 
tification; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the attribute ownership notification for ChatRoomRegistry 

*/ 

public plan 

plnHLA_ChatRoomRegistry_OwnershipAcquisitionNotification 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributeOwnershipAcquisitionNotification ev; 
#posts event evtHLA_ForceDivest evHLA_ForceDivest; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean 

relevant(evtHLAattributeOwnershipAcquisitionNotification ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoomRegistry ); 


1296 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 

{ 

// Server.HLAchat HLA = (Server.HLAchat)_HLA.as_object(); 

@wait_for( HLA._sem_ChatRoomRegistry.planWait() ); 

// synchronized(HLA._ChatRoomRegistry) 

{ 

HLA._ChatRoomRegistry.owned = true || ( 

HLA._ChatRoomRegistry.divesting = HLA._me_shutting_down ); 

} //synchronized(HLA._ChatRoomRegistry) 

HLA._sem_ChatRoomRegistry.signal(); 

HLA.sem_ChatRoomRegistry_acquisition.setChanged(); 

//Just in case we somehow managed to acquire whilst switching to 
shutting down mode 

if (HLA._me_shutting_down) server.postEvent( 
evHLA ForceDivest.create( ev.identifier ) ); 


//end plnHLA_ChatRoomRegistry_OwnershipAcquisitionNotification 


The plnHLA_ChatRoomRegistry_OwnershipAssumptionRequest plan handles 
ownership assumption requests for the ChatRoomRegistry object. 


// File: plnHLA_ChatRoomRegistry_OwnershipAssumptionRequest.j ava 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipAssump 
tion; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles OwnershipAssumptionRequests for ChatRoomRegistry 
*/ 

public plan 

plnHLA_ChatRoomRegistry_OwnershipAssumptionRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestAttributeOwnershipAssumption ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestAttributeOwnershipAssumption 

ev) 


return true; 


DRDC Valcartier TR 2007-412 


1297 



context () 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_ChatRoomRegistry ),- 


#reasoning method 
body () 

{ 

// Server . HLAchat HLA = (Server . HLAchat) _HLA. as_obj ect () ,- 

//Decline if we're in the process of shutting down (and thus 
divesting) 

//Note that we return true because the plan was a success 
//even though we simply decided to ignore the request 
if (HLA._me_shutting_down) return true; 

//Acquiesce if able 

//This condition is similar to !_me_logged_in but better 
//If not subscribed, probably not up to date --decline 
if (!HLA._ChatRoomRegistry.subscribed) return true; 

//Note that the divesting federate will have offered ownership 
to all federates, and that even if they all acquiesce, 

//only one will receive an ownershipAcquisitionNotification,- if 
we use attributeOwnershipAcquisition, there won't be any 

//negative feedback if we fail to get ownership --and we'll have 
an outstanding acquisition request. 

//This is why it is preferable to use 
attributeOwnershipAcquisitionlfAvailable 

HLA._rtiAmbassador.attributeOwnershipAcquisitionlfAvailable( 

HLA. _ChatRoomRegis try .handle, HLA._oahs_ChatRoomRegistry) ,- 


//end plnHLA_ChatRoomRegistry_OwnershipAssumptionRequest 


1298 


DRDC Valcartier TR 2007-412 



The 

plnHLA_ChatRoomRegistry_OwnershipDivestitureConfirmationRequest 

plan handles requests for confirmation of divestiture of the ChatRoomRegistry 
object. 


// File: 

plnHLA_ChatRoomRegistry_OwnershipDivestitureConfirmationRequest.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLArequestDivestitureConfirmation; 
import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles requests for confirmation of ownership divestiture of 
ChatRoomRegistry 
*/ 

public plan 

plnHLA_ChatRoomRegistry_OwnershipDivestitureConfirmationRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestDivestitureConfirmation ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestDivestitureConfirmation ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null) && 

// ev.theObj ectClass.equals( 

((Server.HLAchat)_HLA.as_object())._och_ChatRoomRegistry ); 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoomRegistry ); 


DRDC Valcartier TR 2007-412 


1299 



#reasoning method 
body () 

{ 

// Server . HLAchat HLA = (Server . HLAchat) _HLA. as_obj ect () ; 

@wait_for( HLA._sem_ChatRoomRegistry.planWait() ); 

// synchronized(HLA._ChatRoomRegistry) 

{ 

HLA._rtiAmbassador.confirmDivestiture( 

HLA._ChatRoomRegistry.handle, HLA._oahs_ChatRoomRegistry, null ); 

HLA._ChatRoomRegistry.owned = HLA._ChatRoomRegistry.divesting 

= false; 

} //synchronized(HLA._ChatRoomRegistry) 

HLA._sem_ChatRoomRegistry.signal(); 

//There'll be a divestiture semaphore of some sort when logging 

off 

HLA.sem_ChatRoomRegistry_divestiture.setChanged(); 


//end plnHLA_ChatRoomRegistry_OwnershipDivestitureConfirmationRequest 


The plnHLA_ChatRoomRegistry_OwnershipReleaseRequest planhandles 
ownership release requests for the ChatRoomRegistry object. 


// File: plnHLA_ChatRoomRegistry_OwnershipReleaseRequest.j ava 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipReleas 
e; 


j * * 

Handles requests for ownership release of ChatRoomRegistry 
*/ 

public plan 

plnHLA_ChatRoomRegistry_OwnershipReleaseRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestAttributeOwnershipRelease ev,- 
#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestAttributeOwnershipRelease ev) 

{ 

return true; 


1300 


DRDC Valcartier TR 2007-412 



context() 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_ChatRoomRegistry ),- 


#reasoning method 
body() 

{ 

// Server.HLAchat HLA = (Server. HLAchat) _HLA. as_obj ect () ,- 
//Acquiesce 

@wait_for( HLA._sem_ChatRoomRegistry.planWait() ),- 

// synchronized(HLA._ChatRoomRegistry) 

{ 

//Plan succeeds even though divestiture fails 
if (lHLA._oahs_ChatRoomRegistry.containsAll( 

HLA._rtiAmbassador.attributeOwnershipDivestiturelfWanted( 

HLA._ChatRoomRegistry.handle, HLA._oahs_ChatRoomRegistry))) return 
true,- 

HLA._ChatRoomRegistry.owned = HLA._ChatRoomRegistry.divesting 

= false,- 

} //synchronized(_ChatRoomRegistry) 

HLA._sem_ChatRoomRegistry. signal () ,- 

HLA. sem_ChatRoomRegistry_divestiture . setChanged () ,- 


//end plnHLA_ChatRoomRegistry_OwnershipReleaseRequest 


The plnHLA_ChatRoomRegistry_ProvideAttributeValueUpdate plan handles 
requests for ChatRoomRegistry attribute value updates. 


// File: plnHLA_ChatRoomRegistry_ProvideAttributeValueUpdate.j ava 
package server; 

import 

ca . go . drdc_rddc .hla.rtil516.jack. evtHLAprovideAttributeValueUpdate ,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import hla.rtil516.*; 

j * * 

Handles attribute value update requests received from the RTI for the 
ChatRoomRegistry. 

*/ 

public plan 

plnHLA_ChatRoomRegistry_ProvideAttributeValueUpdate 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAprovideAttributeValueUpdate ev,- 
#uses interface Server server; 

#reads data blfHLA datHLA; 


DRDC Valcartier TR 2007-412 


1301 



static boolean relevant(evtHLAprovideAttributeValueUpdate ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_ChatRoomRegistry ),- 


#reasoning method 
body () 

{ 

AttributeHandleValueMap _ahvm_attributeValues = 

HLA._rtiAmbassador.getAttributeHandleValueMapFactory() .create ( 

HLA._oahs_ChatRoomRegistry_forUpdate.size() ),- 

//HLAprivilegeToDeleteObject is of undefined type (it has no 
content) 

// _ahvm_attributeValues.put( 

HLA._oah_ChatRoomRegistry_DeletePrivilege, null),- 

_ahvm_attributeValues.put( HLA._oah_ChatRoomRegistry_list, 
HLA._ChatRoomRegistry.list.toByteArray() ),- 

HLA._rtiAmbassador.updateAttributeValues( 

HLA._ChatRoomRegistry.handle, _ahvm_attributeValues , null ) ,- 


//end plnHLA_ChatRoomRegistry_ProvideAttributeValueUpdate 


The plnHLA_ChatRoomRegistry_RefleetAttributeValueUpdate plan handles 
ChatRoomRegistry attribute value update reflections. 


// File : plnHLA_ChatRoomRegistry_RefleetAttributeValueUpdate.j ava 
package server; 

import ca . go . drdc_rddc .hla.rtil516.jack. evtHLAref lectAttributeValues,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles attribute value updates received from the RTI for the 
ChatRoomRegistry. 

*/ 

public plan 

plnHLA_ChatRoomRegistry_Ref1ectAttributeValueUpdate 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAref lectAttributeValues ev,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 


1302 


DRDC Valcartier TR 2007-412 



static boolean relevant(evtHLAreflectAttributeValues ev) 


return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_ChatRoomRegistry ),- 


#reasoning method 
body() 

{ 

//HLAprivilegeToDeleteObject has no content, so we won't decode 
it 

HLA._ChatRoomRegistry.list.decode( (byte[])ev.theAttributes.get( 
HLA._oah_ChatRoomRegistry_list ) ) ,- 


//end plnHLA_ChatRoomRegistry_RefleetAttributeValueUpdate 


The plnHLA ChatRoom Discovery plan handles the discovery of ChatRoom 
objects (including the Waiting Room). 


// File: plnHLA_ChatRoom_Discovery.j ava 
package server; 

import ca .go . drdc_rddc .hla.rtil516.jack. evtHLAdiscoverOb j ect Instance ,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles discovery of ChatRooms, including the ,l _waiting_room' 1 . 

*/ 

public plan 

plnHLA_ChatRoom_Discovery 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAdiscoverObj ectlnstance ev,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 

static boolean relevant(evtHLAdiscoverObjectlnstance ev) 

{ 

return true; 


DRDC Valcartier TR 2007-412 


1303 



context () 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
ev.theObj ectClass.equals( HLA._och_ChatRoom ) ; 


#reasoning method 
body () 

{ 

// Server . HLAchat HLA = (Server . HLAchat) _HLA. as_obj ect () ; 

//Assuming AutoProvide, this'll be immediately followed by an 

Update 

Server.HLAchat.aChatRoom _ChatRoom; 
if (ev.obj ectName.equals( 

Server.HLAchat._name_waiting_room_ChatRoom )) 

{ 

_ChatRoom = HLA._waiting_room_ChatRoom; 

} else { 

// _ChatRoom = HLA.getNewChatRoom(); //Awaiting bug fix 

_ChatRoom = HLA.new aChatRoomO; 

} 

_ChatRoom.handle = ev.theObject; 

_ChatRoom.subscribed = true; 

// _ChatRoom.name and slot will come from Update; we must wait 
until then before updating the GUI 

@wait_for( HLA._sem_theChatRooms.planWait() ); 

HLA._theChatRooms.put( ev.theObject, _ChatRoom ); 
HLA._sem_theChatRooms.signal(); 

//It is premature to add the ChatRoom to the blfdatGrpList, 

since 

//all we know at this point is the HLA name (ev.objectName), 

*not* 

//the ChatRoom's "name" attribute. 

//Special case: waiting room 

//The discovery of this never-deleted ChatRoom is always waited 

upon 

//We do not want to trip the discovery semaphore (waiting for a 
Participant) with a ChatRoom discovery 
if ( lev.objectName.equals( 

Server.HLAchat._name_waiting_room_ChatRoom ) ) return true; 

//Signal the waiting plnHLA_WaitingRoomNameReservation that 
we're done 

HLA.sem_ChatRoom_discovery.setChanged(); 


//end plnHLA_ChatRoom_Discovery 


1304 


DRDC Valcartier TR 2007-412 



The plnHLA_chatRoom_OwnershipAcquisitionFailed plan handles the failed 
outcome of ChatRoom attribute ownership requests. 


// File: plnHLA_ChatRoom_OwnershipAcquisitionFailed.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipUnavaliable; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the AttributeOwnershipUnavailable notification for ChatRooms 
*/ 

public plan 

plnHLA_ChatRoom_OwnershipAcquisitionFailed 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributeOwnershipUnavailable ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAattributeOwnershipUnavailable ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 

// ev.theObj ectClass.equals( 

((Server.HLAchat)_HLA.as_object())._och_ChatRoomRegistry ); 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoom ); 


#reasoning method 
body() 

{ 

HLA.sem_ChatRoom_acquisition.setChanged(); 


//end plnHLA_ChatRoom_OwnershipAcquisitionFailed 


DRDC Valcartier TR 2007-412 


1305 



The plnHLA_chatRoom_OwnershipAcquisitionNotification plan handles the 
successful outcome of ChatRoom attribute ownership requests. 


// File: plnHLA_ChatRoom_OwnershipAcquisitionNotification.j ava 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipAcquisitionNo 
tification; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the attribute ownership notification for ChatRooms 

*/ 

public plan 

plnHLA_ChatRoom_OwnershipAcquisitionNotification 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributeOwnershipAcquisitionNotification ev; 
#posts event evtHLA_ForceDivest evHLA_ForceDivest; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean 

relevant(evtHLAattributeOwnershipAcquisitionNotification ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoom ); 


1306 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 

{ 

@wait_for( HLA._sem_theChatRooms.planWait() ); 

// synchronized(HLA._theChatRooms) 

Server.HLAchat.aChatRoom _ChatRoom = 

HLA.SeekChatRoom(ev.theObj ect) ; 

// //end of synchronized(HLA._theChatRooms) 

HLA._sem_theChatRooms.signal() ; 

_ChatRoom.owned = l(_ChatRoom.divesting = false); 

HLA.sem_ChatRoom_acquisition.setChanged () ; 

//Just in case we somehow managed to acquire whilst switching to 
shutting down mode 

if (HLA._me_shutting_down) server.postEvent( 
evHLA_ForceDivest.create(ev.identifier) ); 


//end plnHLA_ChatRoom_OwnershipAcquisitionNotification 


The plnHLA_chatRoom_OwnershipAssumptionRequest plan handles ownership 
assumption requests for ChatRoom objects. 


// File: plnHLA_ChatRoom_OwnershipAssumptionRequest.j ava 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipAssump 
tion; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles OwnershipAssumptionRequests for ChatRooms 
*/ 

public plan 

plnHLA_ChatRoom_OwnershipAssumptionRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestAttributeOwnershipAssumption ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestAttributeOwnershipAssumption 

ev) 


return true; 


DRDC Valcartier TR 2007-412 


1307 



context () 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 

// ev.theObj ectClass.equals ( 

((Server.HLAchat)_HLA.as_obj ect()) ._och_ChatRoom ),- 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoom ),- 


#reasoning method 
body () 

{ 

// Server . HLAchat HLA = (Server . HLAchat) _HLA. as_obj ect () ,- 

//Decline if we're in the process of shutting down (and thus 
divesting) 

//Note that we return true because the plan was a success 
//even though we simply decided to ignore the request 
if (HLA._me_shutting_down) return true; 

//Acquiesce if able 

@wait_for( HLA._sem_theChatRooms.planWait() ) ,- 
Server.HLAchat.aChatRoom _ChatRoom = 

HLA.SeekChatRoom(ev.theObj ect) ,- 

HLA._sem_theChatRooms.signal(),- 

// if (_ChatRoom == null) throw new ObjectInstanceNotKnown("Unknown 
ChatRoom offered"),- 

//Also decline if: 

//We're not subscribed, thus the values are probably not up to 

date 

if (!_ChatRoom.subscribed) return true; 

//The HLA federates also check to see if they're logged out and 
//the ChatRoom slot is other than the waiting_room, because they 
//can remain joined whilst logged out --not so the JACK 
//federates, which resign and shut down when they log out. 
//Since ownership is offered only when the owner leaves a 
//ChatRoom and knows there are other federates in that ChatRoom, 
//accept only if a) it's the waiting room (which is persistent) 
//or b) we're in the room being offered 

//Could use _me.chat_room_slot instead of _myChatRoom.slot 
if ((!_ChatRoom.slot.equals( HLA._waiting_room_ChatRoom )) && 

(!_ChatRoom.slot.equals( HLA._myChatRoom.slot ) ) ) 

return true; 

//Note that the divesting federate will have offered ownership 
//to all federates, and that even if they all acquiesce, only 
//one will receive an ownershipAcquisitionNotification,- if we 
//use attributeOwnershipAcquisition, there won't be any negative 
//feedback if we fail to get ownership --and we'll have an 
//outstanding acquisition request. 

//This is why it is preferable to use 
attributeOwnershipAcquisitionlfAvailable 

HLA._rtiAmbassador.attributeOwnershipAcquisitionlfAvailable( 
_ChatRoom.handle, HLA._oahs_ChatRoom) ,- //or theObject 


//end plnHLA_ChatRoom_OwnershipAssumptionRequest 


1308 


DRDC Valcartier TR 2007-412 



The plnHLA_ChatRoom_OwnershipDivestitureConfirmationRequest plan 
handles requests for confirmation of divestiture of ChatRoom objects. 


// File: plnHLA_ChatRoom_OwnershipDivestitureConfirmationRequest.j ava 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestDivestitureConfirmation; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles requests for confirmation of ownership divestiture of 
ChatRooms 
*/ 

public plan 

plnHLA_ChatRoom_OwnershipDivestitureConfirmationRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestDivestitureConfirmation ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestDivestitureConfirmation ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 

// ev.theObj ectClass.equals( 

((Server.HLAchat)_HLA.as_obj ect()) ._och_ChatRoom ) ; 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoom ); 


DRDC Valcartier TR 2007-412 


1309 



#reasoning method 
body () 


// Server . HLAchat HLA = (Server . HLAchat) _HLA. as_obj ect () ; 

// synchronized(HLA._theChatRooms) 

@wait_for( HLA._sem_theChatRooms.planWait() ); 

Server.HLAchat.aChatRoom _ChatRoom = 

HLA.SeekChatRoom(ev.theObj ect) ; 

// //end of synchronized(HLA._theChatRooms) 

HLA._sem_theChatRooms.signal(); 

HLA._rtiAmbassador.confirmDivestiture( _ChatRoom.handle, 
HLA._oahs_ChatRoom, null ); 

_ChatRoom.owned = _ChatRoom.divesting = false; 

//There'll be a divestiture semaphore of some sort when logging 

off 

HLA.sem_ChatRoom_divestiture.setChanged(); 


//end plnHLA_ChatRoom_OwnershipDivestitureConfirmationRequest 


The plnHLA_chatRoom_OwnershipReleaseRequest plan handles ownership 
release requests for ChatRoom objects. 


// File: plnHLA_ChatRoom_OwnershipReleaseRequest.java 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipReleas 
e; 


j * * 

Handles requests for ownership release of ChatRooms 
*/ 

public plan 

plnHLA_ChatRoom_OwnershipReleaseRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestAttributeOwnershipRelease ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestAttributeOwnershipRelease ev) 

{ 

return true; 


1310 


DRDC Valcartier TR 2007-412 



context() 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_ChatRoom ),- 


#reasoning method 
body() 


//Acquiesce 

@wait_for( HLA._sem_theChatRooms.planWait () ) ,- 

// synchronized(HLA._theChatRooms) 

{ 

Server.HLAchat.aChatRoom _ChatRoom = 

HLA.SeekChatRoom(ev.theObject),- 

//Plan succeeds even though divestiture fails 
if (lHLA._oahs_ChatRoom.containsAll( 

HLA._rtiAmbassador.attributeOwnershipDivestiturelfWanted( 
_ChatRoom.handle, HLA._oahs_ChatRoom))) return true; 

_ChatRoom.owned = _ChatRoom.divesting = false; 

} //synchronized(_theChatRooms) 
HLA._sem_theChatRooms . signal () ,- 
HLA. sem_ChatRoom_divest iture. set Changed () ,- 


//end plnHLA_ChatRoom_OwnershipReleaseRequest 


The plnHLA_chatRoom_ProvideAttributeValueUpdate plan handles requests 
for ChatRoom instance attribute value updates. 


// File: plnHLA_ChatRoom_ProvideAttributeValueUpdate.j ava 
package server; 

import 

ca . go . drdc_rddc .hla.rtil516.jack. evtHLAprovideAttributeValueUpdate ,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import hla.rtil516.*; 

j * * 

Handles attribute value update requests received from the RTI for the 
ChatRooms. 

*/ 

public plan 

plnHLA_ChatRoom_ProvideAttributeValueUpdate 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAprovideAttributeValueUpdate ev,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 


DRDC Valcartier TR 2007-412 


1311 



static boolean relevant(evtHLAprovideAttributeValueUpdate ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_ChatRoom ); 


#reasoning method 
body () 

{ 

@wait_for( HLA._sem_theChatRooms.planWait() ) ; 

Server.HLAchat.aChatRoom _ChatRoom = 

HLA.SeekChatRoom(ev.theObj ect) ; 

HLA._sem_theChatRooms.signal(); 

AttributeHandleValueMap _ahvm_attributeValues = 

HLA._rtiAmbassador.getAttributeHandleValueMapFactory() .create ( 
HLA._oahs_ChatRoom_forUpdate.size() ); 

_ahvm_attributeValues.put( HLA._oah_ChatRoom_name, 
_ChatRoom.name.toByteArray() ); 

_ahvm_attributeValues.put( HLA._oah_ChatRoom_slot, 
_ChatRoom.slot.toByteArray() ); 

HLA._rtiAmbassador.updateAttributeValues( _ChatRoom.handle 
ahvm attributeValues, null ); 


//end plnHLA_ChatRoom_ProvideAttributeValueUpdate 


The plnHLA_ChatRoom_ReflectAttributeValueUpdate plan handles 
ChatRoom instance attribute value update reflections. 


// File: plnHLA_ChatRoom_ReflectAttributeValueUpdate.j ava 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.evtHLAreflectAttributeValues; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles attribute value updates received from the RTI for the 
ChatRooms. 

*/ 

public plan 

plnHLA_ChatRoom_ReflectAttributeValueUpdate 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAreflectAttributeValues ev,- 
#uses interface Server server; 

#reads data blfHLA datHLA; 


1312 


DRDC Valcartier TR 2007-412 



static boolean relevant(evtHLAreflectAttributeValues ev) 


return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
) .equals( HLA._och_ChatRoom ) ,- 


#reasoning method 
body() 

{ 

@wait_for( HLA._sem_theChatRooms.planWait() ),- 

Server.HLAchat.aChatRoom _ChatRoom = 

HLA.SeekChatRoom(ev.theObject),- 

HLA._sem_theChatRooms.signal(),- 
{ 

//Name is a true attribute, not the object's HLA name 
_ChatRoom.name.decode( (byte[])ev.theAttributes.get( 
HLA._oah_ChatRoom_name ) ) ,- 

_ChatRoom.slot.decode( (byte[])ev.theAttributes.get( 
HLA._oah_ChatRoom_slot ) ) ,- 

//ChatRooms (Groups) will be stored using their full HLA 
//names,- the leading character will be added/stripped at the 
//client/server agent interface 

//Adding the ChatRoom's name to the list every time we get an 
//update could be a waste of time,- fortunately, ChatRoom 
//attributes never change so we'll only get this event after 
//a discovery. 

//We will, however, get it once for each Client... 

// if (!_ChatRoom.name.toString () .equals( 

HLA._name_waiting_room_ChatRoom )) 

// blfdatGrpList. add ( _ChatRoom. name . toString () . substring (1) ) ,- 


//end plnHLA_ChatRoom_RefleetAttributeValueUpdate 


DRDC Valcartier TR 2007-412 


1313 



The plnHLA ChatRoom Removal plan handles ChatRoom object instance 
removals. 


// File: plnHLA_ChatRoom_Removal.j ava 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAremoveObjectlnstance,- 
import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the removal of ChatRoom objects. 

*/ 

public plan 

plnHLA_ChatRoom_Removal 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAremoveObjectlnstance ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAremoveObj ectlnstance ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_ChatRoom ),- 


#reasoning method 
body () 

{ 

// Server.HLAchat HLA = (Server . HLAchat) _HLA. as_obj ect () ,- 
Server.HLAchat.aChatRoom _ChatRoom = 

(Server.HLAchat.aChatRoom)HLA._theChatRooms.remove( ev.theObj ect ) ; 
//In the HLA GUI Chat, the <General> ChatRoom remains on the 

list 

//of ChatRooms even whilst non-existent. There is no such list 

here. 

// if (_ChatRoom.name.toString().equals( HLA._name_general_ChatRoom 
)) return true; 

//This must be true 
// remove group from groupList 
// blfdatGrpList .remove ( _ChatRoom.name . toString () ) ,- 


//end plnHLA_ChatRoom_Removal 


1314 


DRDC Valcartier TR 2007-412 



The plnHLA_WaitingRoom_NameReservation_Failed plan handles the failed 
outcome of the Waiting Room name reservation. 


// File: plnHLA_WaitingRoom_NameReservation_Failed.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationFa 
iled; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles reservation of the "_waiting_room" ChatRoom name. 

*/ 

public plan 

plnHLA_WaitingRoom_NameReservation_Failed 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAobj ectInstanceNameReservationFailed ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAobj ectInstanceNameReservationFailed 

ev) 


return 

ev.obj ectName.equals(Server.HLAchat._name_waiting_room_ChatRoom),- 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body() 

{ 

//Name reservation failed, which means there is an already 
extant instance 

HLA.sem_ChatRoom_discovery.clearChanged(),- 
HLA._waiting_room_ChatRoom.subscribed = true,- 
HLA._rtiAmbassador.subscribeObj ectClassAttributes( 

HLA._och_ChatRoom, HLA._oahs_ChatRoom_forUpdate ) ,- 
@wait_for( new aos.j ack.util.cursor.Change( 

HLA.sem_ChatRoom_discovery, HLA.sem_ChatRoom_discovery.hasChanged() ) 

) ; 

//Signal the waiting plnLoginUser that we're done 
HLA. sem_name_reservat ion. setChanged () ,- 


//end plnHLA_WaitingRoom_NameReservation_Failed 


DRDC Valcartier TR 2007-412 


1315 



The plnHLA_WaitingRoom_NameReservation_Succeeded plan handles the 
successful outcome of the Waiting Room name reservation. 


// File: plnHLA_WaitingRoom_NameReservation_Succeeded.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationSu 
cceeded; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles reservation of the "_waiting_room" ChatRoom name. 

*/ 

public plan 

plnHLA_WaitingRoom_NameReservation_Succeeded 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAobj ectInstanceNameReservationSucceeded ev; 
#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean 

relevant(evtHLAobj ectInstanceNameReservationSucceeded ev) 

{ 

return 

ev.obj ectName.equals(Server.HLAchat._name_waiting_room_ChatRoom) ; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


1316 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 

{ 

//Having reserved the name, we know we're the first federate 
//to reach this point, so we must create the _waiting_room 
ChatRoom. 

HLA._wait ing_room_ChatRoom. owned = true ,- 
HLA._waiting_room_ChatRoom. subscribed = true,- 
// HLA._waiting_room_ChatRoom.divesting = false; 

@wait_for ( HLA._sem_theChatRooms . planWait () ) ,- 

HLA._theChatRooms.put( HLA._waiting_room_ChatRoom.handle = 
HLA._rtiAmbassador.registerObj ectlnstance( HLA._och_ChatRoom, 
HLA._waiting_room_ChatRoom.name.toString()), 
HLA._waiting_room_ChatRoom ) ,- 

HLA._sem_theChatRooms . signal () ,- 

HLA._rtiAmbassador.subscribeObj ectClassAttributes( 
HLA._och_ChatRoom, HLA._oahs_ChatRoom_forUpdate ) ,- 

//Signal the waiting plnLoginUser that we're done 
HLA. sem_name_reservat ion. setChanged () ,- 


//end plnHLA_WaitingRoom_NameReservation_Succeeded 


The plnHLA_ParticipantEntersGeneralchatRoom plan handles the subtask of 
“entering” a Client’s Participant avatar into the General ChatRoom. 


// File: plnHLA_ParticipantEntersGeneralChatRoom.j ava 
package server; 

import ca.go.drdc_rddc.hla.rt11516.jack.blfHLA; 
import hla.rtil516.*; 

j * * 

Handles the subtask of entering the (owned) Participant into the 
General ChatRoom. 

*/ 

public plan 

plnHLA_ParticipantEntersGeneralChatRoom 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLA_Part icipant Enter sGeneralChatRoom ev,- 
#posts event evtHLA_AcquireChatRoomRegistry ev_CRR; 

#uses interface Server server,- 
#reads data blfHLA datHLA; 

static boolean relevant( evtHLA_ParticipantEntersGeneralChatRoom ev 


return true; 


DRDC Valcartier TR 2007-412 


1317 



context () 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 


#reasoning method 
body () 

{ 

//Complete log-in process by entering owned Participant into the 
General ChatRoom 

//Does the General ChatRoom exist? 

@wait_for( HLA._sem_theChatRooms.planWait() ) ,- 

{ 

HLA._general_ChatRoom = HLA.SeekChatRoomBySlot( 
HLA._slot_general_ChatRoom ),- 

if (null == HLA._general_ChatRoom) 

{ 

@subtask( ev_CRR.create( ev.identifier ) ),- 

// synchronized(AcquireChatRoomRegistry() ) 

{ 

// HLA._general_ChatRoom = HLA.new ChatRoom( 

HLA._name_general_ChatRoom, HLA._slot_general_ChatRoom) ,- 

HLA._general_ChatRoom = HLA.getNewChatRoom( 

HLA._name_general_ChatRoom, HLA._slot_general_ChatRoom) ,- 
HLA._general_ChatRoom.owned = 

HLA._general_ChatRoom.subscribed = true; 

// HLA._general_ChatRoom.divesting = false; 

HLA._theChatRooms.put( HLA._general_ChatRoom.handle = 
HLA._rtiAmbassador.registerObj ectlnstance( HLA._och_ChatRoom ), 
HLA._general_ChatRoom ) ,- 

//No need to add the General ChatRoom to the 
_ChatRoomRegistry, as it is already listed 

} //synchronized(AcquireChatRoomRegistry()) 
HLA._sem_ChatRoomRegistry. signal () ,- 
} else { 

} //if 

} //synchronized(_theChatRooms) 

HLA._sem_theChatRooms . signal () ,- 

//This association will trigger Attribute Scope Advisories, 
Discovery: 

HLA._myChatRoom = HLA._general_ChatRoom,- 

HLA._me . chat_room_slot. setValue ( HLA._slot_general_ChatRoom ) ,- 
HLA._me_logged_in = l (HLA._me_logging_in = false) ,- 
HLA._rtiAmbassador.associateRegionsForUpdates( HLA._me.handle, 
HLA._asrspl_Participant_current ) ,- 

HLA._rtiAmbassador.subscribeObj ectClassAttributesWithRegions( 
HLA._och_Participant, HLA._asrspl_Participant_current) ,- 

//Subscription will refresh subscribed Participants ,- 

//since we use Auto-Provide, an explicit Update request is not 

needed 


1318 


DRDC Valcartier TR 2007-412 



//Subscribe to the interaction 

//We'll be listening to interactions that come in on our user- 
handle channel in addition to the chat-room-slot channel 

//It is the interaction sender's responsibility to pick the 
channels to use 

HLA._rh_myParticipantRegion = HLA._rtiAmbassador.createRegion( 
HLA._dhs_UserHandleSlotsSet ) ; 

//setRangeBounds must be invoked at least once for each 
dimension specified. 

//Only then can commitRegionModifications be invoked to turn the 
region template into a region specification. 

HLA._rtiAmbassador.setRangeBounds( HLA._rh_myParticipantRegion, 
HLA._dh_UserHandleSlots, new RangeBounds( 

HLA._me.user_handle.getValue(), HLA._me.user_handle.getValue() + 1 ) 

) ; 

HLA._rhs_myParticipantRegion = 

HLA._rtiAmbassador.getRegionHandleSetFactory().create(); 

HLA._rhs_myParticipantRegion.add( HLA._rh_myParticipantRegion ); 

HLA._rtiAmbassador.commitRegionModifications( 
HLA._rhs_myParticipantRegion ); 

//subscribelnteractionClassWithRegions done by plnLoginUser 


//end plnHLA_ParticipantEntersGeneralChatRoom 


The plnHLA_Participant_AttributeScopeAdvisory_ln plan handles the 
attribute scope advisory for a Participant instance coming into scope. 


// File: plnHLA_Participant_AttributeScopeAdvisory_In.j ava 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

import ca.go.drdc_rddc.hla.rtil516.jack.evtHLAattributesInScope; 

j * * 

Handles the Attribute Scope Advisories for Participants. 

*/ 

public plan 

plnHLA_Participant_AttributeScopeAdvisory_In 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributesInScope ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAattributesInScope ev) 

{ 

return true; 


DRDC Valcartier TR 2007-412 


1319 



context () 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_Participant ),- 


#reasoning method 
body () 


//The Participant has just come into or gone out of scope, 
//which means either we or it has changed ChatRooms 
//(it cannot have been truly deleted) 

@wait_f or ( HLA._sem_thePart icipant s . planWait () ) ,- 

Server.HLAchat.aParticipant _Participant = 

HLA. SeekParticipant (ev. theObj ect) ,- 

HLA._sem_theParticipants . signal () ,- 

//If we could localDelete Participants as they go out of scope, 
//we would always get a Discovery right before the InScope 
//callback; but we can't do that because of the pRTI 
//RTIambassador-Federate Service Thread synch bug (putting the 
//Federate Service Thread in any kind of synch-wait state (a 
//Semaphore, say) causes a federate-triggering RTIambassador 
//call by *any* thread to hang, even if the latter 
//RTIambassador-caller isn't owning any monitors). 

//So we use the inScope property of aParticipant to work around 

it. 

//We know we do not own theObject, since we wouldn't get any 
advisories in that case 

_Participant.inscope = true; 

//The Java Chat federate uses this event to add/remove 
//Participants to its drop-down list of private message targets,- 
//the JACK Chat federates resolve that list only when a Client 
//sends an evtRequestGrpWho, so there is no further processing 
//required here. 


//end plnHLA_Participant_AttributeScopeAdvisory_In 


1320 


DRDC Valcartier TR 2007-412 



The plnHLA_Participant_AttributeScopeAdvisory_Out plan handles the 
attribute scope advisory for a Participant instance going out of scope. 


// File: plnHLA_Participant_AttributeScopeAdvisory_Out.j ava 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAattributesOutOfScope; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the Attribute Scope Advisories for Participants. 

*/ 

public plan plnHLA_Participant_AttributeScopeAdvisory_Out extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributesOutOfScope ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAattributesOutOfScope ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_Participant ); 


DRDC Valcartier TR 2007-412 


1321 



#reasoning method 
body () 


//The Participant has just gone out of scope, 

//which means either we or it has changed ChatRooms 
//(it cannot have been truly deleted) 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 

Server.HLAchat.aParticipant _Participant = 

HLA.SeekParticipant(ev.theObject),- 

HLA._sem_theParticipants.signal(),- 

//If we could localDelete Participants as they go out of scope, 
//we would always get a Discovery right before the InScope 
//callback; but we can't do that because of the pRTI 
//RTIambassador-Federate Service Thread synch bug (putting the 
//Federate Service Thread in any kind of synch-wait state (a 
//Semaphore, say) causes a federate-triggering RTIambassador 
//call by *any* thread to hang, even if the latter 
//RTIambassador-caller isn't owning any monitors). 

//So we use the inScope property of aParticipant to work around 

it. 

//We know we do not own theObject, since we wouldn't get any 
advisories in that case 

_Participant.inscope = false,- 

//The Java Chat federate uses this event to add/remove 
//Participants to its drop-down list of private message targets,- 
//the JACK Chat federates resolve that list only when a Client 
//sends an evtRequestGrpWho, so there is no further processing 
//required here. 


//end plnHLA_Participant_AttributeScopeAdvisory_Out 


The plnHLAParticipantDiscovery plan handles the discovery of other 
Participant instances. 


// File: plnHLA_Participant_Discovery.j ava 
package server; 

import ca . go . drdc_rddc .hla.rtil516.jack. evtHLAdiscoverObj ect Instance,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the discovery of Participant objects 

*/ 

public plan 

plnHLA_Participant_Discovery 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAdiscoverObj ectlnstance ev,- 
#uses interface Server server,- 
#uses data blfHLA datHLA; 


1322 


DRDC Valcartier TR 2007-412 



static boolean relevant(evtHLAdiscoverObjectlnstance ev) 


return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
ev.theObj ectClass.equals( HLA._och_Participant ) ,- 


#reasoning method 
body() 

{ 

logical Object $HLA2,- 

Server.HLAchat.aParticipant _Participant = 

HLA.getNewParticipant(),- 

// Server.HLAchat.aParticipant _Participant = HLA.new 

Participant(),- 

_Participant.subscribed = true; 

// _Participant.inscope = false; //Default; the InScope advisory 
will follow discovery in any case 

_Participant.handle = ev.theObj ect ,- 
// _Participant.name.setValue( 

HLA._rtiAmbassador.getObjectlnstanceName( ev.theObject ) ),- 

_Participant.name.setValue( ev.obj ectName ) ,- 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 
HLA._theParticipants.put( ev.theObj ect, _Participant) ,- 
HLA._sem_theParticipants.signal(),- 

//When we first tried to maintain the old JACK belief sets, this 
//got complicated here. 

//At this point we don't know which ChatRoom slot the 
//Participant is in, so we couldn't add to blfdatGroups (mapping 
//of usernames to groups); we'd have to await an Update for 
//that. 

//Whether the Participant discovered by this JACK client is 
//another JACK client or not we can tell because a JACK client 
//first adds itself to blfdatHLA before logging in. Not so with 
//blfdatUsers, which is added to after the log in is complete. 

// 

//Now, in using only the blfdatHLA, we don't need to bother. 
//What the Participant objects map to becomes irrelevant; 
//interaction send and receive is done through the RTI instead 
//of through direct Server intervention. Basically, the Server 
//relays the send to the RTI, which then callbacks the pertinent 
//JACK clients; this goes through the Server again, which then 
//delivers the interaction instances to each Client instance. 

// if (HLA._me_shutting_down) return true; 

//We use the Auto-Provide switch, so an explicit Update request 
is not needed 


//end plnHLA_Participant_Discovery 


DRDC Valcartier TR 2007-412 


1323 



The plnHLA_Participant_NameReservation_Failed plan handles the failed 
outcome of Participant name reservations. 


// File: plnHLA_Participant_NameReservation_Failed.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationFa 
iled; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 
import hla.rtil516.*; 

j * * 

Handles outcome of Participant (username) name reservation request. 

*/ 

public plan 

plnHLA_Participant_NameReservation_Failed 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAobj ectInstanceNameReservationFailed ev; 

#posts event evtHLA_ParticipantEntersGeneralChatRoom ev_PEGCR; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant( evtHLAobj ectlnstanceNameReservationFailed 
ev ) 


return ( ev.objectName.charAt(0) == 'p' ); 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null); 


1324 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 


j k k 

* blfdatUsers does not list non-JACK clients (usernames) 

*/ 

//Prepare the general chat room association 
HLA._rhs_current_ChatRoom = 

HLA._rtiAmbassador.getRegionHandleSetFactory().create(),- 

//Arrival ( <General> ) ChatRoom will be slot 2, so we set up 
" current 11 accordingly 

HLA._rh_current_ChatRoom = HLA._rh_general_ChatRoom; 
HLA._rhs_current_ChatRoom.add( HLA._rh_current_ChatRoom ),- 
HLA._rtiAmbassador.commitRegionModifloations( 
HLA._rhs_current_ChatRoom ),- //Won't complain if there are no mods to 
commit 

HLA._asrspl_Participant_current = 

HLA._rtiAmbassador.getAttributeSetRegionSetPairListFactory() .create (1) 

HLA._asrspl_Participant_current.add( new 
AttributeRegionAssociation( HLA._oahs_Participant_forUpdate, 
HLA._rhs_current_ChatRoom )),- 

//Note that the association has not been applied yet. 

//Name reservation failed, which means there is an already 
extant instance. 

//At this point, we know the desired Participant object exists - 
-we just don't know where it is. 

//If it is logged-out, it'll be in the waiting_room and we will 
//discover it there and can then acquire it. 

//It is logged-in by someone else, it'll be in some other 
//ChatRoom (2+) and we won't discover it and cannot use it. 
//There is no "fail-fast" in that situation, however. 

//It is reasonably safe to assume that if we don't know of the 
//sought Participant, it must be logged in by someone else. 

//Is the object known? 

Server . HLAchat. aPart icipant _Part icipant ,- 
try 


@wait_for ( HLA._sem_thePart icipant s . planWait () ) ,- 

//getObjectlnstanceHandle will throw an exception if the 
object is unknown 

//We put a try-finally around it to avoid having to signal() 
within the outer catch block 
try 


_Participant = HLA.SeekParticipant( 

HLA._rtiAmbassador.getObj ectlnstanceHandle( HLA._me.name.toString() ) 

) ; 

} finally { 

HLA._sem_theParticipants . signal () ,- 


//No exception occurred, therefore the object is known,- could 
//be anywhere, however 


DRDC Valcartier TR 2007-412 


1325 



//If freshly discovered, we could wait for its user_handle to 
//be updated by reflectAttributeValues (this is the only 
//field guaranteed to change) so that we can then safely 
//look up its logged_in or chat_room_slot values. 

//Instead, we'll request ownership right away,- a logged-in 
//Participant will fail. 

//It could be already owned (if it was an unused Participant 
we just happened to have the custody of) 
if (!_Participant.owned) 

{ 

//For a Participant to be eligible for acquisition, it 
//must be in the _waiting_room and therefore inscope 
if (_Participant.inscope) 

{ 

HLA. sem_Part icipant_acquisit ion. cl ear Changed () ,- 
//Before acquiring, set up update regions so they do 
not lapse during ownership transfer 

HLA._rtiAmbassador.associateRegionsForUpdates( 
_Participant .handle, HLA._asrspl_Participant_nowhere ) ,- 

HLA._rtiAmbassador.associateRegionsForUpdates( 
_Participant .handle, HLA._asrspl_Participant_waiting_room ) ,- 

HLA._rtiAmbassador.attributeOwnershipAcquisition( 
_Participant .handle, HLA._oahs_Participant, null ) ,- 

@wait_for( new aos.jack.util.cursor.Change( 

HLA.sem_Participant_acquisition, 

HLA. sem_Part icipant_acquisit ion .hasChanged () ) ) ,- 

//The plan handling the acquisition request outcome 
//will set HLA._me_logging_in to false (and 
//HLA._me.name.setValue("")) in case of failure (which 
//happens if the object was discovered in the 
//waiting_room and then logged-in by someone else 
//before we could get to it) . 

} else { 

HLA._me_logging_in = false; 

HLA._me . name . setValue ( 1111 ) ,- 

} //if 
} //if 


1326 


DRDC Valcartier TR 2007-412 



if (HLA._me_logging_in) 

{ 

//Acquisition succeeded: that Participant was available 
@wait_for( HLA._sem_me.planWait() ); 

{ 

HLA._me = -Participant; 

//Enter the <General> ChatRoom 

// HLA._me.divesting = false; //could be still true; will 

be fixed later 

HLA._me.logged_in.setBoolean( HLA._me.owned = true ); 
HLA._me.user_handle.setValue( HLA._me.handle.hashCode() 

) ; 

//Removing _me from the waiting_room will trip 
Attribute Scope Advisories 

HLA._rtiAmbassador.unassociateRegionsForUpdates( 
HLA._me.handle, HLA._asrspl_Participant_waiting_room); 

//At this point, _me.handle is only associated with 
_asrspl_Participant_nowhere 

HLA._me.chat_room_slot.setValue( 
HLA._slot_nowhere_ChatRoom ); 

} //synchronized(_me) 

HLA._sem_me.signal(); 

} //if 

} catch (ObjectlnstanceNotKnown ex) { 

//The Participant was unknown; it cannot be in the 
waiting_room 

HLA._me_logging_in = false; 

HLA. me.name.setValue(""); 


//Note that a created Participant goes only _nowhere; it does 
not pass through _waiting_room. 

//At this point the _Participant is only _nowhere. 
if (HLA._me_logging_in) 

{ 

@subtask( ev_PEGCR.create( ev.identifier ) ); 

} 

//Signal the waiting plnLoginUser that we're done 
HLA.sem_name_reservation.setChanged( ); 


//end plnHLA_Participant_NameReservation_Failed 


DRDC Valcartier TR 2007-412 


1327 



The plnHLA_Participant_NameReservation_Succeeded plan handles the 
successful outcome of Participant name reservations. 


// File: plnHLA_Participant_NameReservation_Succeeded.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAobj ectInstanceNameReservationSu 
cceeded; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 
import hla.rtil516.*; 

j * * 

Handles outcome of Participant (username) name reservation request. 

*/ 

public plan 

plnHLA_Participant_NameReservation_Succeeded 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAobj ectInstanceNameReservationSucceeded ev; 
#posts event evtHLA_ParticipantEntersGeneralChatRoom ev_PEGCR; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant( 

evtHLAobj ectInstanceNameReservationSucceeded ev ) 

{ 

return ( ev.objectName.charAt(0) == 'p' ); 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null); 


1328 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 


j k k 

* blfdatUsers does not list non-JACK clients (usernames) 

*/ 

//Prepare the general chat room association 
HLA._rhs_current_ChatRoom = 

HLA._rtiAmbassador.getRegionHandleSetFactory().create(),- 

//Arrival ( <General> ) ChatRoom will be slot 2, so we set up 
" current 11 accordingly 

HLA._rh_current_ChatRoom = HLA._rh_general_ChatRoom; 
HLA._rhs_current_ChatRoom.add( HLA._rh_current_ChatRoom ),- 
HLA._rtiAmbassador.commitRegionModifloations( 
HLA._rhs_current_ChatRoom ),- //Won't complain if there are no mods to 
commit 

HLA._asrspl_Participant_current = 

HLA._rtiAmbassador.getAttributeSetRegionSetPairListFactory() .create (1) 

HLA._asrspl_Participant_current.add( new 
AttributeRegionAssociation( HLA._oahs_Participant_forUpdate, 
HLA._rhs_current_ChatRoom )),- 

//Note that the association has not been applied yet. 

//For chat_room_slot filtering, we associate all "forUpdate" 
attributes to _dh_ChatRoomSlots regions. 

//We'd get InvalidRegionContext when subscribing if we included 
the DeletePrivilege. 

@wait_for( HLA._sem_me.planWait() ) ,- 

{ 

HLA._me.logged_in.setBoolean( HLA._me.owned = 

HLA._me.subscribed = !( HLA._me.inscope = HLA._me.divesting = false ) 

) ; 

HLA._me.chat_room_slot.setValue( HLA._slot_nowhere_ChatRoom 

) ; 

//The <General> ChatRoom; must have been "waiting_room" 

//( slot 1 ) previously. If there were any federates 
//subscribed to the creation region (nowhere), there would be 
//Discovery and Auto-Update would trigger our 
//InstanceAttributeResponder and all that; 

//Hence the atomic register-and-put; the synchronized(_me) 
//would delay a bit until the _me.user_handle is set. 

//But since no-one subscribes to nowhere, there is no rush 
@wait_for ( HLA._sem_thePart icipant s . planWait () ) ,- 

{ 

HLA._theParticipants.put( HLA._me.handle = 

HLA._rtiAmbassador.registerObj ectlnstanceWithRegions( 

HLA._och_Participant, HLA._asrspl_Participant_nowhere, 

HLA._me . name . toString () ), HLA._me ),- 

} //synchronized( _theParticipants ) 

HLA._sem_theParticipants . signal () ,- 

HLA._me. user_handle. setValue ( HLA._me. handle . hashCode () ) ,- 
} //synchronized( _me ) 

HLA._sem_me . signal () ,- 


DRDC Valcartier TR 2007-412 


1329 



//Note that a created Participant goes only _nowhere; it does 
not pass through _waiting_room. 

//At this point the _Participant is only _nowhere. 
if (HLA._me_logging_in) 

{ 

@subtask( ev_PEGCR.create( ev.identifier ) ); 

} //if 

//Signal the waiting plnLoginUser that we're done 
HLA.sem_name_reservation.setChanged( ); 


//end plnHLA_Participant_NameReservation_Succeeded 


The plnHLA_Participant_OwnershipAcquisitionFailed plan handles the 
failed outcome of a Participant attribute ownership acquisition attempt. 


// File: plnHLA_Participant_OwnershipAcquisitionFailed.java 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipUnavailable; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the AttributeOwnershipUnavailable notification for 
Participants 

*/ 

public plan 

plnHLA_Participant_OwnershipAcquisitionFailed 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributeOwnershipUnavailable ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAattributeOwnershipUnavailable ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null) && 

// ev.theObj ectClass.equals( 

((Server.HLAchat)_HLA.as_object())._och_ChatRoomRegistry ); 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_Participant ); 


1330 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 


HLA.sem_Participant_acquisition.setChanged() ; 


//end plnHLA_Participant_OwnershipAcquisitionFailed 


The plnHLA_Participant_OwnershipAcquisitionNotification plan handles 
the successful outcome of a Participant attribute ownership acquisition attempt. 


// File: plnHLA_Participant_OwnershipAcquisitionNotification.j ava 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLAattributeOwnershipAcquisitionNo 
tification; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the attribute ownership notification for Participants 

*/ 

public plan 

plnHLA_Participant_OwnershipAcquisitionNotification 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAattributeOwnershipAcquisitionNotification ev; 
#posts event evtHLA_ForceDivest evHLA_ForceDivest; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean 

relevant(evtHLAattributeOwnershipAcquisitionNotification ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) J= null) && 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_Participant ); 


DRDC Valcartier TR 2007-412 


1331 



#reasoning method 
body () 


@wait_for( HLA._sem_theParticipants.planWait() ) ,- 

// synchronized(HLA._theParticipants) 

Server.HLAchat.aParticipant _Participant = 

HLA.SeekParticipant(ev.theObject),- 
// //end of synchronized(HLA._theParticipants) 

HLA._sem_theParticipants.signal(),- 
_Participant.owned = l(_Participant.inscope = 

_Participant.divesting = false); 

//There are two circumstances where we acquire Participants: 
//When we want to log in, and when another federate logs out and 
shuts down. 

//In both cases we set up the ForUpdate Regions such that the 
//Participant arrives associated with _nowhere and 
//_waiting_room. In the first circumstance, the 
//plnHLA_Participant_NameReservation waits on the 
//sem_Participant_acquisition and will move the Participant to 
//the _general ChatRoom. 

HLA. sem_Part icipant_acquisit ion. set Changed () ,- 

//Just in case we somehow managed to acquire whilst switching to 
shutting down mode 

if (HLA._me_shutting_down) server.postEvent( 
evHLA ForceDivest. create ( ev. identifier ) ),- 


//end plnHLA_Participant_OwnershipAcquisitionNotification 


The plnHLA_Participant_OwnershipAssumptionRequest plan handles 
ownership assumption requests for Participant object attributes. 


// File: plnHLA_Participant_OwnershipAssumptionRequest.java 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipAssump 
tion,- 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles OwnershipAssumptionRequests for Participants 

*/ 

public plan 

plnHLA_Participant_OwnershipAssumptionRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evt HLAr eque s t At tributeOwner shipAs sumpt ion ev,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 


1332 


DRDC Valcartier TR 2007-412 



static boolean relevant(evtHLArequestAttributeOwnershipAssumption 


ev) 


return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_Participant ),- 


#reasoning method 
body() 

{ 

// Server.HLAchat HLA = (Server. HLAchat) _HLA. as_obj ect () ,- 

//Decline if we're in the process of shutting down (and thus 
divesting). 

//Note that we return true because the plan was a success 
//even though we simply decided to ignore the request, 
if (HLA._me_shutting_down) return true; 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 
Server.HLAchat.aParticipant _Participant = HLA.SeekParticipant( 
ev.theObj ect ) ,- 

HLA._sem_theParticipants.signal(),- 
//Acquiesce if able 

//If not subscribed, probably not up to date --decline 
if (!_Participant.subscribed) return true; 

//Note that the divesting federate will have offered ownership 
//to all federates, and that even if they all acquiesce, only 
//one will receive an ownershipAcquisitionNotification,- if we 
//use attributeOwnershipAcquisition, there won't be any negative 
//feedback if we fail to get ownership --and we'll have an 
//outstanding acquisition request. 

//This is why it is preferable to use 
attributeOwnershipAcquisitionlfAvailable 
// 

//Before acquiring, set up update regions so they do not lapse 
during ownership transfer 

HLA._rtiAmbassador.associateRegionsForUpdates( 

_Participant .handle, HLA._asrspl_Participant_nowhere ) ,- 
HLA._rtiAmbassador.associateRegionsForUpdates( 

_Participant .handle, HLA._asrspl_Participant_waiting_room ) ,- 

HLA._rtiAmbassador.attributeOwnershipAcquisitionlfAvailable( 
_Participant .handle, HLA._oahs_Participant ),- //or theObject 


//end plnHLA_Participant_OwnershipAssumptionRequest 


DRDC Valcartier TR 2007-412 


1333 



The plnHLA_Participant_OwnershipDivestitureConfirmationRequest 

plan handles requests for confirmation of divestiture of Participant object attributes. 


// File: 

plnHLA_Participant_OwnershipDivestitureConfirmationRequest.j ava 
package server; 

import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestDivestitureConfirmation; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles requests for confirmation of ownership divestiture of 
Participants 

*/ 

public plan 

plnHLA_Participant_OwnershipDivestitureConfirmationRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestDivestitureConfirmation ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestDivestitureConfirmation ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_Participant ); 


1334 


DRDC Valcartier TR 2007-412 



#reasoning method 
body() 

{ 

@wait_for( HLA._sem_theParticipants.planWait() ); 

Server.HLAchat.aParticipant _Participant = 

HLA.SeekParticipant(ev.theObject); 

// synchronized(HLA._theParticipants) 

{ 

HLA._rtiAmbassador.confirmDivestiture( _Participant.handle, 
HLA._oahs_Participant, null ); 

_Participant.owned = _Participant.divesting = false; 

} //synchronized(HLA._theParticipants) 

HLA._sem_theParticipants.signal(); 

//There'll be a divestiture semaphore of some sort when logging 

off 

HLA.sem_Participant_divestiture.setChanged(); 


//end plnHLA_Participant_OwnershipDivestitureConfirmationRequest 


The plnHLA_Participant_OwnershipReleaseRequest plan handles ownership 
release requests for Participant object attributes. 


// File: plnHLA_Participant_OwnershipReleaseRequest.j ava 
package server; 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import 

ca.go.drdc_rddc.hla.rtil516.jack.evtHLArequestAttributeOwnershipReleas 
e; 


j * * 

Handles requests for ownership release of Participants 

*/ 

public plan 

plnHLA_Participant_OwnershipReleaseRequest 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLArequestAttributeOwnershipRelease ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLArequestAttributeOwnershipRelease ev) 

{ 

return true; 


DRDC Valcartier TR 2007-412 


1335 



context () 


datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_Participant ),- 


#reasoning method 
body () 


//Acquiesce 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 

// synchronized(HLA._theParticipants) 

{ 

Server.HLAchat.aParticipant _Participant = 

HLA.SeekParticipant(ev.theObject),- 

//If _me, refuse (there is no RTI call to tell the requester 
to piss off). 

//Here we fail the plan as a means of signalling our refusal. 
//Note that the JACK federates resign and shut down when not 
//logged-in, so the Java test on _me_logged_in becomes 
//redundant here. 

if (HLA._me_logged_in && _Participant.equals(HLA._me)) return 

false; 

//Otherwise, acquiesce 

//Plan succeeds even though divestiture fails 
if (lHLA._oahs_Participant.containsAll( 

HLA._rtiAmbassador.attributeOwnershipDivestiturelfWanted( 

_Participant.handle, HLA._oahs_Participant))) return true; 

_Participant.owned = _Participant.divesting = 

_Participant.inscope = false; 

//Region associations are automatically lost along with 

ownership 

} //synchronized(_theParticipants) 

HLA._sem_theParticipants . signal () ,- 

HLA. sem_Participant_divestiture . setChanged () ,- 


//end plnHLA_Participant_OwnershipReleaseRequest 


1336 


DRDC Valcartier TR 2007-412 



The plnHLA_Participant_ProvideAttributeValueUpdate plan handles 
requests for Participant instance attribute value updates. 


// File: plnHLA_Participant_ProvideAttributeValueUpdate.j ava 
package server; 

import 

ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAprovideAttributeValueUpdate; 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 
import hla.rtil516.*; 

j * * 

Handles attribute value update requests received from the RTI for the 
Participants. 

*/ 

public plan 

plnHLA_Participant_ProvideAttributeValueUpdate 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAprovideAttributeValueUpdate ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAprovideAttributeValueUpdate ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 

HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObj ect 
).equals( HLA._och_Participant ); 


DRDC Valcartier TR 2007-412 


1337 



#reasoning method 
body () 

{ 

@wait_for( HLA._sem_theParticipants.planWait() ) ,- 

Server.HLAchat.aParticipant _Participant = 

HLA.SeekParticipant(ev.theObject),- 

HLA._sem_theParticipants.signal(),- 
AttributeHandleValueMap _ahvm_attributeValues = 

HLA._rtiAmbassador.getAttributeHandleValueMapFactory().create( 
HLA._oahs_Participant_forUpdate.size() ) ,- 

//In the HLA Chat federates, it is crucial to synchronize on 
//_Participant here, since the object's registration may trigger 
//this handler right away (because of Auto-Provide) --and the 
//object cannot fill its user_handle field in the same atomic 
//operation. 

//In JACK Clients, on the other hand, the callbacks are queued 
//up as posts on a single agent (the Server), hence this is not 
//a problem. 

_ahvm_attributeValues.put( HLA._oah_Participant_logged_in, 

_Part icipant. logged_in. toByteArray () ) ,- 

_ahvm_attributeValues.put( HLA._oah_Participant_user_handle, 
_Part icipant. user_handle . toByteArray () ) ,- 

_ahvm_attributeValues.put( HLA._oah_Participant_chat_room_slot, 
_Participant. chat_room_slot. toByteArray () ) ,- 

HLA._rtiAmbassador.updateAttributeValues( _Participant.handle, 
ahvm attributeValues, null ),- 


//end plnHLA_Participant_ProvideAttributeValueUpdate 


The plnHLA_Participant_ReflectAttributeValueUpdate plan handles 
Participant instance attribute value update reflections. 


// File : plnHLA_Participant_ReflectAttributeValueUpdate.j ava 
package server; 

import ca . go . drdc_rddc .hla.rtil516.jack. evtHLAref lect AttributeValues ,- 
import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles attribute value updates received from the RTI for the 
Participants. 

*/ 

public plan 

plnHLA_Participant_ReflectAttributeValueUpdate 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAreflectAttributeValues ev,- 
#uses interface Server server,- 
#reads data blfHLA datHLA; 


1338 


DRDC Valcartier TR 2007-412 



static boolean relevant(evtHLAreflectAttributeValues ev) 


return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null) && 
HLA._rtiAmbassador.getKnownObj ectClassHandle( ev.theObject 
).equals( HLA._och_Participant ),- 


#reasoning method 
body() 

{ 

//HLAprivilegeToDeleteObject has no content, so we won't decode 
it 

@wait_f or ( HLA._sem_thePart icipants . planWait () ) ,- 
Server.HLAchat.aParticipant _Participant = 

HLA.SeekParticipant (ev. theObj ect) ,- 

HLA._sem_theParticipants . signal () ,- 

{ 

//The attribute Name matches the object's HLA name and is 
updated at Discovery time 
// _Participant.name.setValue( 

HLA._rt iAmbassador . getOb j ectlnstanceName ( ev. theOb j ect) ) ,- 

_Participant.logged_in.decode( 

(byte [ ] ) ev. theAttributes . get ( HLA._oah_Part icipant_logged_in ) ) ,- 
_Participant.user_handle.decode( 

(byte [ ] ) ev. theAttributes . get ( HLA._oah_Part icipant_user_handle ) ) ,- 

_Participant.chat_room_slot.decode((byte[])ev.theAttributes.get( 
HLA._oah_Participant_chat_room_slot ) ) ,- 

//This is where the JACK belief set model would need to put 
//the Participant in the proper ChatRoom. 

//Using either the _ChatRoomRegistry.list or 
//HLA.SeekChatRoomBySlot, one can find which ChatRoom name 
//corresponds to the Participant's chat_room_slot,- then one 
//can add to blfdatGroups. 

} 

//Unlike the HLA Chat federates, a JACK Client that is not 
logged in cannot subscribe 

// if (!HLA._me_logged_in) return true; 


//end plnHLA_Participant_RefleetAttributeValueUpdate 


DRDC Valcartier TR 2007-412 


1339 



The plnHLAinteraction plan handles reception of messages. 


// File: plnHLA_Interaction.java 
package server; 

import hla . rtil516 . * 

import ca.go.drdc_rddc.hla.rtil516.omt.*,- 
import j ava.util. Iterator,- 

import ca.go.drdc_rddc.hla.rtil516.jack.blfHLA; 

import ca.go.drdc_rddc.hla.rtil516.jack.evtHLAreceivelnteraction,- 
import client.evtMessageUsr; 

j * * 

Handles the evtHLAinteraction event 

*/ 

public plan 
plnHLA_Interaction 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAreceivelnteraction ev; 

#sends event evtRelayMessg evRelayMessg,- 
#uses interface Server server; 

#reads data blfUsers blfdatUsers; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAreceivelnteraction ev) 

{ 

//We could check the interaction class handle, but there is only 

one 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server . HLAchat) _HLA. as_obj ect () ) l= null) ,- 


1340 


DRDC Valcartier TR 2007-412 



#reasoning method 
body () 

{ 

HLAunicodeString _message = new HLAunicodeString(); 
HLAunicodeString _sender = new HLAunicodeString(); 
for (Iterator i = ev. theParameters.keyset().iterator() ; 
i.hasNext(); ) 


ParameterHandle _parameterHandle = (ParameterHandle)i.next(); 
if (_parameterHandle.equals(HLA._iph_Communication_message)) 

{ 

_message.decode( 

(byte[])ev.theParameters.get(_parameterHandle) ); 

// _message = new String( 

(byte[])_theParameters.get(_parameterHandle) ); 

} else if 

(_parameterHandle.equals(HLA._iph_Communication_sender)) 

{ 

_sender.decode( 

(byte[])ev.theParameters.get(_parameterHandle) ); 

// _sender = new String( 

(byte[])_theParameters.get(_parameterHandle) ); 

} //if 

} //for 

// server.postEvent( evMessageUsr.message( 

_sender.toString().substring(1), _message.toString(), HLA.username ) 

) ; 

logical String location; 

blfdatUsers.get( location, ev.identifier ); //HLA.username 
@send( location.as_string(), evRelayMessg.relay( 

_message.toString(), _sender.toString().substring(1) ) ); 

System. out. println ( " (relaying message to 1,1 + ev. identifier 
+ " ') " ),- // HLA.username 


//end plnHLA_Interaction 


DRDC Valcartier TR 2007-412 


1341 



The plnHLA_lnteractionScopeAdvisory_of f plan handles the interaction scope 
advisory in the “turn off’ case; this simply means the Client is “alone” in the Chat 
federation. 


// File: plnHLA_InteractionScopeAdvisory_Off.j ava 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAturnlnteractionsOff; 
import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

j * * 

Handles the HLAinteractionScopeAdvisory event. 

*/ 

public plan 

plnHLA_InteractionScopeAdvisory_Off 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAturnlnteractionsOff ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAturnlnteractionsOff ev) 

{ 

return true; 


context() 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 
//No need to test (InteractionClassHandle)ev.theHandle 
//since we only subscribe to one interaction 


#reasoning method 
body () 

{ 

HLA._alone = true; 


//end plnHLA_InteractionScopeAdvisory_Off 


1342 


DRDC Valcartier TR 2007-412 



The plnHLA_lnteractionScopeAdvisory_On plan handles the interaction scope 
advisory in the “turn on” case; this simply means the Client is no longer “alone” in 
the Chat federation. 


// File: plnHLA_InteractionScopeAdvisory_On.j ava 
package server; 

import ca.gc.drdc_rddc.hla.rtil516.jack.blfHLA; 

import ca.gc.drdc_rddc.hla.rtil516.jack.evtHLAturnlnteractionsOn; 

j * * 

Handles the HLAinteractionScopeAdvisory event. 

*/ 

public plan 

plnHLA_InteractionScopeAdvisory_On 
extends Plan 

{ 

logical Object _HLA; 

Server.HLAchat HLA; 

#handles event evtHLAturnlnteractionsOn ev; 

#uses interface Server server; 

#reads data blfHLA datHLA; 

static boolean relevant(evtHLAturnlnteractionsOn ev) 

{ 

return true; 


context() 

{ 

datHLA.get( ev.identifier, _HLA ) && 

( (HLA = (Server.HLAchat)_HLA.as_object()) l= null); 
//No need to test (InteractionClassHandle)ev.theHandle 
//since we only subscribe to one interaction 


#reasoning method 
body() 

{ 

HLA._alone = false; 


//end plnHLA_InteractionScopeAdvisory_On 


DRDC Valcartier TR 2007-412 


1343 



This page intentionally left blank. 


1344 


DRDC Valcartier TR 2007-412 



References 


[1] Daigle, Catherine (2001). Conformation a et exploitation de HLA parASIP 
(ASIP Compliance to and Exploitation of HLA), DRDC Valcartier, Contract W7701- 
0-2147 

[2] Liang, Dr. Yawei, and Fug ere, Dr. Benoit Jean (2000). Towards a Naturalistic 
Broad Agent Design, in Proceedings of the Ninth Conference on Computer 
Generated Forces (9th-CGF-076), 2000 May 16-18, Orlando, FL 

[3] Liang, Dr. Yawei; Robichaud, F.; Fugere, Dr. Benoit Jean; and Ackles, Kenneth 
N. (2001). Implementing a Naturalistic Command Agent Design, in Proceedings of 
the Tenth Conference on Computer Generated Forces (10th-CGF-075), 2001 May 
15-17, Norfolk, VA, pp. 379-386 

[4] Robichaud, 2Lt F. (2001). Implementing Naturalistic Decision Model, M.Sc. 
Thesis, Royal Military College (RMC), 2001 

[5] Liang, Dr. Yawei, and Fugere, Dr. Benoit Jean (2002). Comparing Fuzzy Logic 
and Bayesian Probabilistic Reasoning in Decision Analysis, in Proceedings 
International Congress of Mathematicians (ICM) 2002, vol. 1, pp. 178-179, 2002 
Aug 20-28, Beijing, China 

[6] Jaillet, Christophe; Krajecki, Michael; and Fugere, Dr. Benoit Jean (2002). 
Parallelisation en memoire partagee d'un moteur de simulation du commandement 
militaire base sur une modelisation par automates cellulaires, RenPar 14 
(Rencontres francophones du parallelisme), Hammamet (Tunisia), April 2002 

[7] Fortin, Roger (2001a). Development of a Topographical Map Display 
(ToMaDi), DREV-TM-9839 

[8] Fortin, Roger (2001b). Development of a Second Generation Topographical 
Map Display (ToMaDi Mkll), DRDC Valcartier TM-2001-228 

[9] Fortin, Roger (2001c). Novel Display Devices for Command & Control 
Applications, Society for Photo-Optical Instrumentation Engineers (SPIE) 
Proceedings, Orlando, 2001 Apr 16-18 

[10] Letoumeau, Francis; Lemieux, Frant^ois; and Martel, Christian (2003). 
Challenges Related to 3D Urban Model Creation, DRDC Valcartier TR-2003-367 

[11] Martel, Christian; and Letoumeau, Francis (2003). Realisation d'un modele 
3D de la ville de Quebec avecMultiGen Creator, DRDC Valcartier TAJ-2003-020 

[12] Thomas, John (2004). Final Report (Technical) On: Display Assessment and 
Enabling Technology Research for New Military Displays, General Dynamics 
Canada X04457AA (draft) 


DRDC Valcartier TR 2007-412 


1345 



[13] Cosby, L. Neal (1999). SIMNET - An Insider’s Perspective, SISO Simulation 
Technology newsletter, Vol. 2 No. lg, 1999 Sep 10 

http://www.sisostds.org/webletter/siso/iss 39/art 202.htm (accessed 2005 Jun 07) 

[14] DIS (1992). Standard for Distributed Interactive Simulation - Application 
Protocols, Version 1.0 Draft 

[15] IEEE (1993). IEEE 1278-1993 - Standard for Distributed Interactive 
Simulation - Application protocols 

[16] MITRE (1993). Aggregate Level Simulation Protocol (ALSP) Program Status 
and History, The MITRE Corporation (March 1993) http://alsp.ie.org/alsp/biblio/89- 
92 historv/89-92 historv.html (accessed 2005 Jun 07) 

[17] Kuhl, Frederic; Weatherly, Richard M.; and Dahmann, Judith (1999). Creating 
Computer Simulation Systems: An Introduction to the High Level Architecture, 
Prentice Hall, 1999, ISBN 0-1302-2511-8 

[18] DoD (1996). U.S. Department of Defense, Under Secretary of Defense for 
Acquisition and Technology (USD (A&T)), memorandum, DoD High Level 
Architecture (HLA) for Simulations (1996 Sep 10) 

[19] OMG (1998 a). Facility for Distributed Simulation Systems 1.0, Object 
Management Group (November 1998) 

[20] IEEE (2000). IEEE 1516-2000 Standard for Modeling and Simulation (M&S) 
High Level Architecture (HLA) - Framework and Rules (2000 Sep 21) 

[21] OMG (1998b). The Common Object Request Broker: Architecture and 
Specification, Revision 2.2, Object Management Group (February 1998) 

[22] OMG (2002). Facility for Distributed Simulation Systems 2.0, Object 
Management Group (2002 Feb 07) 

[23] DoD (2000). U.S. Department of Defense DoD 4120.24-M, Defense 
Standardization Program (DSP) Policies and Procedures (2000 Mar 09) 

[24] NATO (1999). Standardisation Agreement (STANAG) 4574, Standardized 
Modelling and Simulation Information for High Level Architecture (HLA) North 
Atlantic Treaty Organization (NATO) (draft, circulated for comment 1999 Mar 09) 

[25] NATO (1995). Standardisation Agreement (STANAG) 4482, Standardised 
Information Technology’ Protocols for Distributed Interactive Simulation (DIS) 

North Atlantic Treaty Organization (NATO) (1995 Jun 28) 

[26] SISO (1999a). SISO- SISO-STD-OOl-1999, Guidance, Rationale, and 
Interoperability Modalities (GRIM) for the Real-time Platform Reference Federation 
Object Model (RPR FOM), Version 1.0v2, Simulation Interoperability Standards 
Organization (1999 Sep 10) 


1346 


DR DC Valcartier TR 2007-412 





[27] SISO (1999b). SISO- SISO-STD-OOl.1-1999, RPR-FOM Version 1.0, 
Simulation Interoperability Standards Organization (1999 Aug 24) 

[28] SISO (2003). Real-time Platform Reference Federation Object Model (RPR 
FOM), Version 2.0D17, Simulation Interoperability Standards Organization (2003 
Sep 10) 

[29] Hard, David (1987). Statecharts: A Visual Formalism for Complex Systems, 
Science of Computer Programming (Netherlands), vol. 8, no. 3, pp. 231-274, June 
1987. 

[30] Fujimoto, Richard M.; and Weatherly, Richard M. (1996). Time Management 
in the DoD High Level Architecture, Proceedings of the Tenth Workshop on Parallel 
and Distributed Simulation, Philadelphia (PA), United States, pp. 60-67, 1996, ISBN 
0-8186-7539-X 

[31] Carothers, Christopher; Fujimoto, Richard M.; Weatherly, Richard M.; and 
Wilson, Annette (1997). Design and Implementation ofHLA Time Management in 
the RTI version F.0, Proceedings of the 1997 Winter Simulation Conference, Atlanta 
(GA), United States, pp. 373-380, 1997 

[32] DISTI (1997). Introduction to High Level Architecture, Fourth Edition, 
Distributed Simulation Technology Inc., Altamonte Springs (FL), October 1997 

[33] Shoham, Yoav(1993). Agent-Oriented Programming, Artificial Intelligence, 
vol. 60, no. 1, pp. 51-92, 1993 

[34] Wooldridge, Michael; and Jennings, Nicholas R. (1995). Intelligent Agents: 
Theory> and Practice, The Knowledge Engineering Review, vol. 10, no. 12, pp. 115- 
152, 1995. 

[35] Franklin, Stan; and Graesser, Art (1996). Is it an Agent, or just a Program?: A 
Taxonomy for Autonomous Agents, in Proceedings of the Third International 
Workshop on Agent Theories, Architectures, and Languages, Springer-Veilag, pp. 
21-35, 1996 

[36] Bratman, Michael E. (1999). Intention, Plans, and Practical Reason, Stanford 
University Center for the Study of Language and Information, 1999, ISBN 1-5758- 
6192-5 

[37] Hardy, Ian R. (1996). The Evolution of ARPANET email. University of 
California at Berkeley, 1996 http://www.ifla.org/documents/intemet/haril.txt 
(accessed 2005 Jun 08) 

[38] Kantor, Peter L. (2003). Internet Relay Chat, CISS 220 Web Page 
Development and Design Web Tutorials, Hudson Valley Community College, 2003 
http://academ.hvcc.edu/~kantopet/ciss 220/index.php?page=irc&parent=leetures 

(accessed 2005 Jun 08) 


DRDC Valcartier TR 2007-412 


1347 




[39] DoD (2003). U.S. Department of Defense Interpretations of the IEEE 1516- 
2000 series of standards, IEEE Std 1516-2000, IEEE Std 1516.1-2000, and IEEE 
Std 1516.2-2000: Release 2 (2003 Jul 01) 

[40] Bray, Tim; Paoli, Jean; Sperberg-McQueen, C. M.; Maler, Eve; Yergeau, 
Francis; Cowan, John; editors, Extensible Markup Language (XML) 1.1 (Second 
Edition), W3C Recommendation 16 August 2006, World Wide Web Consortium 
(W3C) http://www.w3.org/TR/2006/REC-xmll 1-20060816/ (accessed 2007 Jan 22) 


1348 


DR DC Valcartier TR 2007-412 



Bibliography 


Distributed Interactive Simulation (DIS) Protocol: 

DIS (1992). Standard for Distributed Interactive Simulation - Application 
Protocols, Version 1.0 Draft 

DIS (1993a). DIS Version 2 - IEEE 1278-1993 

DIS (1993b). DIS Version 3 - Standard for Distributed Interactive Simulation - 
Application Protocols, Version 2.0 Third Draft (May 1993) 

DIS (1994). DIS Version 4 - Standard for Distributed Interactive Simulation - 
Application Protocols, Version 2.0 Fourth Draft (March 1994) 

SISO (1999a). SISO- SISO-STD-OOl-1999, Guidance, Rationale, and 
Interoperability Modalities (GRIM) for the Real-time Platform Reference Federation 
Object Model (RPR FOM), Version 1.0v2, Simulation Interoperability Standards 
Organization (1999 Sep 10) 

SISO (1999b). SISO- SISO-STD-OOl. 1-1999, RPR-FOM Version 1.0, Simulation 
Interoperability Standards Organization (1999 Aug 24) 

SISO (2001). Guidance, Rationale, and Interoperability Manual (GRIM) for the 
Real-time Platform Reference Federation Object Model (RPR FOM), Version 
2.0D9v2, Simulation Interoperability Standards Organization (2001 Nov 01) 

SISO (2003). Real-time Platform Reference Federation Object Model (RPR FOM), 
Version 2.0D17, Simulation Interoperability Standards Organization (2003 Sep 10) 

SISO (2005). SISO-REF-010-2005, Enumeration and Bit Encoded Values for use 
with Protocols for Distributed Interactive Simulation Applications, Simulation 
Interoperability Standards Organization (2005 Mar 25) 


DRDC Valcartier TR 2007-412 


1349 



IEEE 1278 Distributed Interactive Simulation (DIS) Protocol: 

IEEE (1993). IEEE 1278-1993 - Standard for Distributed Interactive Simulation - 
Application protocols 

IEEE (1995a). IEEE 1278.1-1995 - Standard for Distributed Interactive Simulation 

- Application protocols 

IEEE (1998a). IEEE 1278.1A-1998 - Standard for Distrib uted Interactive 
Simulation - Application protocols 

IEEE (1995b). IEEE-127 8.2-199 5 - Standard for Distributed Interactive Simulation 

- Communication Services and Profiles 

IEEE (1996). IEEE 1278.3-1996 - Recommended Practice for Distributed 
Interactive Simulation - Exercise Management and Feedback 

IEEE (1997). IEEE 1278.4-1997 - Recommended Practice for Distributed 
Interactive Simulation - Verification Validation & Accreditation 

IEEE (unpublished). IEEE 1278.5-XXXX - Fidelity Description Requirements 
(never published) 

Aggregate Level Simulation Protocol (ALSP): 

MITRE (1993). Aggregate Level Simulation Protocol (ALSP) Program Status and 
History , the MITRE CoqDoration (March 1993) http://alsp.ie.org/alsp/biblio/89- 
92 historv/89-92 historv.html (accessed 2005-jun-07) 

Full ALSP bibliography at http://alsp.ie.org/alsp/biblio/alspbibliography.html 
(accessed 2005 Jun 07) 


1350 


DR DC Valcartier TR 2007-412 





High Level Architecture (HLA) 1.3: 

HLA (2001a). HLA 1.3NG Appendix A - RTIAmbassador Specification (2001 Jun 
21 ) 

HLA (2001b). HLA 1.3NG Appendix B - RTIFederateAmbassador Specification 
(2001 Jun 21) 

HLA (2001c). HLA 1.3NG Appendix C - Classes and Supporting Types (2001 Jun 
21 ) 

HLA (1998a). HLA Interface Specification 1.3 Draft 11 - Body & Annex E - 
Bibliography (1998 Apr 20) 

HLA (1998b). HLA Object Model Template (OMT) Specification 1.3 (1998 Feb 05) 

OMG (1998). Facility for Distributed Simulation Systems 1.0, Object Management 
Group (November 1998) 

DoD (2002). U.S. Department ofDefense, Interpretations of HLA Interface 
Specification 1.3v3 (2002 May 08) 

High Level Architecture (HLA) IEEE Proposal (P1516): 

IEEE (1998b). HLA Interface Specification 1.3 (IEEE P1516.1) Annex A - IDL API 
(1998 Apr 20) 

IEEE (1998c). HLA Interface Specification 1.3 (IEEE P1516.1) Annex B - C++ API 
(1998 Apr 20) 

IEEE (1998d). HLA Interface Specification 1.3 (IEEEP1516.1) Annex C - Ada 95 
API (1998 Apr 20) 

IEEE (1998e). HLA Interface Specification 1.3 (IEEE P1516.1) Annex D - Java API 
(1998 Apr 20) 

IEEE (19981). HLA Interface Specification 1.3 (IEEE P1516.1)Body & Annex E - 
Bibliography (1998 Apr 20) 

IEEE (1998g). HLA Rules 1.3 (IEEE P1516.1) (1998 Apr 05) 


DRDC Valcartier TR 2007-412 


1351 



IEEE 1516 High Level Architecture (HLA): 

IEEE (2000a). IEEE 1516-2000 Standard for Modeling and Simulation (M&S) 

High Level Architecture (HLA) - Framework and Rules (2000 Sep 21) 

IEEE (2000b). IEEE 1516.1-2000 Standard for Modeling and Simulation (M&S) 
High Level Architecture (HLA) - Federate Interface Specification (2000 Sep 21) 

IEEE (2000c). IEEE 1516.1-2000 Errata (2003 Oct 16) 

IEEE (2000d). IEEE 1516.2-2000 Standard for Modeling and Simulation (M&S) 
High Level Architecture (HLA) - Object Model Template (OMT) Specification (2000 
Sep 21) 

IEEE (2003). IEEE 1516.3-2003 Recommended Practice for HLA FEDEP (2003 
Apr 23) 

DoD (2003). U.S. Department of Defense Interpretations of the IEEE 1516-2000 
series of standards, IEEE Std 1516-2000, IEEE Std 1516.1-2000, andlEEEStd 
1516.2-2000: Release 2 (2003 Jul 01) 

OMG (2002) Facility for Distributed Simulation Systems 2.0, Object Management 
Group (2002 Feb 07) 

JACK ™ Intelligent Agents: 

AOS (2004). JACK™ Intelligent Agents Agent Manual, Agent Oriented Software 
Pty. Ltd., 2004 


1352 


DRDC Valcartier TR 2007-412 



Other Documents: 


DMSO (1996). Defense Modeling and Simulation Office, HLA Time Management: 
Design Document Version 1.0, 1996 Aug 15 

http://www.cc.gatech.edU/computing/pads/PAPERS/HLA-TM-l.0.pdf 

Gosling, James; Joy, Bill; Steele, Guy; and Bracha, Gilad (1996-2000). The Java ™ 
Language Specification Second Edition, Sun Microsystems 

IEEE (1985). ANSI/IEEE 754-1985, Standard for Binary? Floating-Point Arithmetic 

INCITS (1997). ANSI/INCITS 4-1986(R1997), Information Processing - Coded 
Character Sets - 7-Bit American National Standard Code for Information 
Interchange (7-bit ASCII), InterNational Committee for Information Technology 
Standards 

ISO (1995). ISO/IEC 8652:1995, Information Technology - Programming 
Languages - Ada (a.k.a. Ada 95 Reference Manual), Intermetrics, Inc. 1992-1995 

ISO (1998). ISO/IEC 14882:1998, Information Technology - Programming 
Languages -C++, American National Standards Institute, 1998 Jul 27 


DRDC Valcartier TR 2007-412 


1353 



This page intentionally left blank. 


1354 


DRDC Valcartier TR 2007-412 



List of 

symbols/abbreviations/acronyms/initialisms 


3D 

Three-Dimensional 

ALSP 

Aggregate Level Simulation Protocol 

AMLCD 

Active Matrix Liquid Crystal Display 

ANSI 

American National Standards Institute www.ansi.ors 

AOS 

Asent-Oriented Software Ptv. Ltd. www.asent-software.com 

API 

Application Programming Interface 

ASCII 

American Standard Code for Information Interchange 

ASIP 

All-Source Intelligence Prototype/Producer 

BDI 

Belief Desire Intention 

C 2 

Command and Control 

C 2 IS 

Command and Control Information System 

CCIS 

see C 2 IS 

CD 

Compact Disc 

CD-ROM 

Compact Disc - Read-Only Memory 

CGF 

Computer-Generated Forces 

CLI 

Command-Line user-interface 

CMF 

Collaborative Metaprogramming Framework 

CORBA 

Common Object Request Broker Architecture www.corba.ors 

DARPA 

U. S. Defense Advanced Research Projects Asencv www.darpa.mil 

DDM 

Data Distribution Management 

DIF 

Data Interchange Format 

DIR 

Defence Industrial Research 


DRDC Valcartier TR 2007-412 


1355 







DIS 

Distributed Interactive Simulation 

DISH 

Distributed Simulation Technolosv Inc. www.simulation.com 

DLL 

Dynamic Link Library 

DMSO 

U. S. Defense Modelins and Simulation Office www.dmso.mil 

DND 

Department of National Defence www.dnd.ca 

DoD 

U. S. Department of Defense www.dod.20v 

DRDC 

Defence R&D Canada www.drdc-rddc.sc.ca 

DRP 

Document Review Panel 

DSP 

Defense Standardization Prosram www.dsp.dla.mil 

DSS 

Decision Support Systems 

DTD 

Document Type Definition 

DUB 

Dimension Upper Bound 

FDD 

FOM Document Data 

FED 

Field Emission Display 

FEDEP 

Federation Development Process 

FIFO 

First-In, First-Out 

FOM 

Federation Object Model 

GALT 

Greatest Available Logical Time 

GEO-TIDE 

Geospatial Technologies for Information Decisions 

GUI 

Graphical User-Interface 

HLA 

High Level Architecture 

HPCVL 

High Performance Computing Virtual Laboratory 

ICM 

International Congress of Mathematicians 

IDE 

Integrated Development Environment 

IDL 

Interface Definition Language 

1356 

DRDC Valcartier TR 2007-412 








IEC 

International Electrotechnical Commission www.iec.ch 

IEEE 

Institute of Electrical and Electronics Engineers www.ieee.org 

INCUS 

InterNational Committee for Information Technology Standards 

www.incits.org 

IRC 

Internet Relay Chat 

ISBN 

International Standard Book Number 

ISO 

International Organization for Standardization www.iso.ch 

1 ST 

(University of Central Florida) Institute for Simulation and Training 
www.ist.ucf.edu 

JACK 

Originally stood for Java Agent Compiler and Kernel 

JAL 

JACK Agent Language 

JDE 

JACK Development Environment 

JNI 

Java Native Interface 

JTC 

Joint Training Confederation 

LFCS 

Land Forces Command System 

LITS 

Least Incoming Time Stamp 

LRC 

Local RTI Component 

M&S 

Modelling and Simulation 

MAGNETAR 

Metaprogrammable AGent NETwork ARchitecture www.magnetar.org 

MOM 

Management Object Model 

NATO 

North Atlantic Treaty Organization www.nato.int 

OLED 

Organic Light-Emitting Diode 

OMG 

Object Management Group www.omg.org 

OMT 

Object Model Template 

OO 

Object-Oriented 

OOAD 

Object-Oriented Analysis and Design 


DRDC Valcartier TR 2007-412 


1357 










OOTW 

Operations Other Than War 

ORB 

Object Request Broker 

PDG 

Product Development Group 

R&D 

Research and Development 

RMC 

Roval Military College www.nnc.ca 

RPR-FOM 

Realtime Platform Reference FOM 

RTI 

Run-Time Infrastructure 

SIMNET 

SIMulator NETwork, later became SIMulation NETwork 

SIREQ 

Soldier Information Requirements 

SISO 

Simulation Interoperability Standards Organization www.sisostds.org 

SO 

Shared Object 

SOM 

Simulation Object Model 

SPIE 

Society for Photo-Optical Instrumentation Engineers www.spie.org 

STANAG 

Standardisation Agreement www.cri.ensmp.fr/OTAN/Seiveur2.html 

TCP/IP 

Transmission Control Protocol/Intemet Protocol 

TD 

Technology Demonstration 

TFT-LCD 

Thin Film Transistor - Liquid Crystal Display 

ToMaDi 

Topographic Map Display 

TSO 

Time-Stamp Order 

UCF 

University of Central Florida www.ucf.edu 

UDP 

User Datagram Protocol 

USD (A&T) 

U.S. Under Secretaiy of Defense for Acquisition and Technology 
www. acq. osd.mil 

W3C 

World Wide Web Consortium www.w3.org 

XML 

extensible Markup Language www.xml.org 

1358 

DRDC Valcartier TR 2007-412 










XRTI 


extensible Run-Time Infrastructure www.npsnet.org/~npsnet/xrti 


DRDC Valcartier TR 2007-412 


1359 



This page intentionally left blank. 


1360 


DRDC Valcartier TR 2007-412 



Distribution list 


Internal distribution (DRDC Valcartier) 

2 Thibault, D. U. (1 CD and 1 printed) 

4 Library (1 CD and 3 printed) 

Force Protection & Weapon Systems: 

1 Electro-optical Warfare (EOW; Nathalie Harrison) (1 CD) 
C4ISR Sector: 

1 C 2 Decision Support Systems (C 2 DSS) (1 CD) 

1 Intelligence and Information (I 2 ) (1 CD) 

1 System of Systems (SoS ) (1 CD) 

10 TOTAL LIST PART 1 (6 CDs and 4 printed) 

External distribution 

1 DAD (LCols Hall & McPhearson) (1 CD) 

Directorate of Army Doctrine 
Canadian Forces Base Kingston 
P.O. Box 17000 Stn Forces 
Kingston ON K7K 7B4 

1 DLR 5 (LCol Bodner) (1 CD) 

Directorate of Land Requirements 
Canadian Forces Base Kingston 
P.O. Box 17000 Stn Forces 
Kingston ON K7K 7B4 

1 DLR 8 (LCol Lefebvre) (l CD) 

Directorate Land Requirements 
National Defence Headquarters 
MGen George R. Pearkes Building 
101 Colonel By Drive 
Ottawa ON K1A 0K2 

1 DRDKIM (1 CD) 


DRDC Valcartier TR 2007-412 


1361 



1 DLSC (LCols Maurer & Williams) (l CD) 

Directorate of Land Strategic Concepts 
Canadian Forces Base Kingston 
P.O. Box 17000 Stn Forces 
Kingston ON K7K 7B4 

1 DLSE/ASECO (Maj James S. Denford & Mr. Paul Roman) (1 CD) 
Directorate Land Synthetic Environment 
Army Synthetic Environment Coordination Office 
Land Force Doctrine and Training System 
P.O. Box 17000 Station Forces 
Canadian Forces Base Kingston 
Kingston, ON K7K 7B4 

1 DND SECO (Mr. D. Robert Elliott) (1 CD) 

Canadian Forces Experiment Centre 
Synthetic Environment Coordination Office 
DREO/CRC Shirley’s Bay Campus 
3701 Carling Avenue 
Ottawa, ON K1A0K2 

1 DRDC Atlantic - VCS Group (Mr. Brad Dillman) (1 CD) 

Defence R&D Canada - Atlantic 
9 Grove Street 
Dartmouth, NS B2Y3Z7 

1 DRDC Ottawa FFSE (Dr. Andrew L. Vallerand & Dr. Paul Pace) (1 CD) 
Defence R&D Canada - Ottawa 
Future Forces Synthetic Environments 
3701 Carling Avenue 
Ottawa, Ontario, K1A 0Z4 

1 DSTL 8 (Mr. Benoit Cantin, Thrust Co-ordinator 12o “Command”) (1 CD) 
Directorate Science and Technology Land 
National Defence Headquarters 
MGen George R. Pearkes Building 
101 Colonel By Drive 
Ottawa ON K1A0K2 

I LSEC (Capt Chris Taff) (1 CD) 

Land Software Engineering Centre 
National Defence Headquarters 
MGen George R. Pearkes Building 
101 Colonel By Drive 

Ottawa ON K1A0K2 

II TOTAL LIST PART 2 (11 CDs) 

21 TOTAL COPIES REQUIRED 


1362 


DRDC ValcartierTR 2007-412 



UNCLASSIFIED 

SECURITY CLASSIFICATION OF FORM 
(Highest Classification of Title, Abstract, Keywords) 


DOCUMENT CONTROL DATA 


3. TITLE (Its classification should be indicated by the appropriate abbreviation (S, C, R or U) 
(U) Simulation technologies for C 2 IS development & training - Final report 


4. AUTHORS (Last name, first name, middle initial. If military, show rank, e.g. Doe, Maj. John E.) 
Thibault, Daniel U. 


6a. NO. OF PAGES 
1380 


7. DESCRIPTIVE NOTES (the category of the document, e.g. technical report, technical note or memorandum. Give the 
inclusive dates when a specific reporting period is covered.) 

Project final report 


8. SPONSORING ACTIVITY (name and address) 
DLSC (Directorate of Land Strategic Concepts) 
Box 17000 Stn Forces 
Kingston ON K7K 7B4 


11. DOCUMENT AVAILABILITY (any limitations on further dissemination of the document, other than those imposed by security 
classification) 

13 Unlimited distribution 

□ Restricted to contractors in approved countries (specify) 

□ Restricted to Canadian contractors (with need-to-know) 

□ Restricted to Government (with need-to-know) 

□ Restricted to Defense departments 

□ Others 

12. DOCUMENT ANNOUNCEMENT (any limitation to the bibliographic announcement of this document. This will normally 
correspond to the Document Availability (11). However, where further distribution (beyond the audience specified in 11) is 
possible, a wider announcement audience may be selected.) 


9b. CONTRACT NO. 


10b. OTHER DOCUMENT NOS 

N/A 


9a. PROJECT OR GRANT NO. (Please specify whether project or 
grant) 

12sd (12kr) 

10a. ORIGINATOR'S DOCUMENT NUMBER 
DRDC Valcartier TR 2007-412 


6b .NO. OF REFERENCES 
40 


5. DATE OF PUBLICATION (month and year) 
February 2008 


2. SECURITY CLASSIFICATION 

(Including special warning terms if applicable) 

UNCLASSIFIED 


1. ORIGINATOR (name and address) 
DRDC Valcartier 
2459 boul. Pie-XI nord 
Quebec QC G3J 1X5 


UNCLASSIFIED 


SECURITY CLASSIFICATION OF FORM 
(Highest Classification of Title, Abstract, Keywords) 


dcd03e rev.(10-1999) 























UNCLASSIFIED 

SECURITY CLASSIFICATION OF FORM 
(Highest Classification of Title, Abstract, Keywords) 


dcd03e rev.(10-1999) 









Defence R&D Canada 


R £r D pour la defense Canada 


Canada's Leader in Defence 
and National Security 
Science and Technology 


Chef de file an Canada en matiere 
de science et de technologie pour 
la defense et la securite nationale 


DEFENCE 



www.drdc-rddc.gc.ca 


