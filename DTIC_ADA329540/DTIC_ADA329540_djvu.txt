AEROSPACE REPORT NO. 
ATR-93(3778)-2 


A Formal Description of the Incremental 
Translation of Stage 3 VHDL into State Deltas 
in SDVS 


30 September 1993 


Prepared by 
I. V. FILIPPENKO 

Trusted Computer Systems Department 
Computer Science and Technology Subdivision 
Computer Systems Division 
Engineering and Technology Group 


Prepared for 

DEPARTMENT OF DEFENSE 
Ft. George G. Meade, MD 20744-6000 


quality inspected z 


Engineering and Technology Group 


I THE AEROSPACE 

CORPORATION 

El Segundo, California 


APPROVED FOR PUBLIC RELEASE; 
DISTRIBUTION IS UNLIMITED 


19971001 037 








AEROSPACE REPORT NO. 
ATR-93(3778)-2 


A FORMAL DESCRIPTION OF THE INCREMENTAL TRANSLATION OF 
STAGE 3 VHDL INTO STATE DELTAS IN SDVS 


Prepared by 


I. V. FILIPPENKO 

Trusted Computer Systems Department 
Computer Science and Technology Subdivision 
Computer Systems Division 
Engineering and Technology Group 


30 September 1993 


Engineering and Technology Group 


THE AEROSPACE CORPORATION 
El Segundo, CA 90245-4691 


Prepared for 

DEPARTMENT OF DEFENSE 
Ft. George G. Meade, MD 20744-6000 


APPROVED FOR PUBLIC RELEASE; 
DISTRIBUTION IS UNLIMITED 



Report No. 
ATR-93(3778)-2 


A FORMAL DESCRIPTION OF THE INCREMENTAL TRANSLATION 
OF STAGE 3 VHDL INTO STATE DELTAS IN SDVS 


Prepared 

X. y/ 

I. V. Filippenko '' B. H. Levy, Principal Investigator 

Computer Assurance Section 


Approved 



D. B. Baker, Director 

Trusted Computer Systems Department 



C. A. Sunshine, Principal Director 
Computer Science and Technology Subdivision 


iii 



Abstract 


This report documents a formal semantic specification of Stage 3 VHDL, a subset of the 
VHSIC Hardware Description Language (VHDL), via translation into the temporal logic 
of the State Delta Verification System (SDVS). Stage 3 VHDL is the fourth of successively 
more sophisticated VHDL subsets to be interfaced to SDVS. 

The specification is a continuation-style denotational semantics of Stage 3 VHDL in terms 
of state deltas , the distinguishing logical formulas used by SDVS to describe state transi¬ 
tions. The semantics is basically specified in two phases. The first phase performs static 
semantic analysis, including type checking and other static error checking, and collects an 
environment for use by the second phase. The second phase performs the actual transla¬ 
tion of the subject Stage 3 VHDL description into state deltas. An abstract syntax tree 
transformation is interposed between the two translation phases. 

The translator specification was, for the most part, written in DL, the semantic metalan¬ 
guage of a denotational semantics specification system called DENOTE. DENOTE enables 
the semantic equations of the specification to be realized both as a printable representation 
(included in this report) and an executable Common Lisp program that constitutes the 
translator’s implementation. However, the second phase semantics of the VHDL simulation 
cycle has a direct operational implementation in the VHDL translator code. 



Acknowledgments 


The author thanks his colleagues in the Computer Assurance Section for their support in the 
adaptation of SDVS to VHDL, and particularly to Tim Aiken, Jeff Cook, Beth Levy, Leo 
Marcus, and Dave Martin for their contributions to the formal semantic definition described 
in this report. 


vi 



Contents 


Abstract v 

Acknowledgments vi 

1 Introduction 1 

2 History of Our Semantic Approach to VHDL 5 

3 Overview of Stage 3 VHDL 7 

3.1 General Remarks. 7 

3.2 Stage 3 VHDL Language Summary. 8 

4 Preliminaries 11 

4.1 Environments. 11 

4.2 Continuations. 14 

4.3 Other Notation and Functions. 14 

5 Syntax of Stage 3 VHDL 17 

5.1 Syntactic Domains. 18 

5.2 Syntax Equations. 18 

5.2.1 Concrete Syntax .... 18 

5.2.2 Abstract Syntax: Phase 1. 31 

5.2.3 Abstract Syntax: Phase 2. 35 

6 Phase 1: Static Semantic Analysis and Environment Collection 37 

6.1 Overview . 37 

6.2 Descriptors, Types, and Type Modes. 38 

6.2.1 Type and type descriptor predicates. 43 

6.2.2 Additional primitive accessors and predicates. 45 

6.3 Special-Purpose Environment Components and Functions. 47 

6.4 Phase 1 Semantic Domains and Functions. 48 

6.4.1 Phase 1 Semantic Domains. 49 

vii 






















6.4.2 Phase 1 Semantic Functions. 50 

6.5 Phase 1 Semantic Equations. 52 

6.5.1 Stage 3 VHDL Design Files. 52 

6.5.2 Entity Declarations. 53 

6.5.3 Architecture Bodies. 54 

6.5.4 Port Declarations .. 54 

6.5.5 Declarations .. 55 

6.5.6 Concurrent Statements . . . .. 72 

6.5.7 Sensitivity Lists .. 75 

6.5.8 Sequential Statements. 75 

6.5.9 Case Alternatives .. 83 

6.5.10 Discrete Ranges .. 84 

6.5.11 Waveforms and Transactions. 85 

6.5.12 Expressions. 86 

6.5.13 Primitive Semantic Equations. 92 

7 Interphase Abstract Syntax Tree Transformation 93 

7.1 Interphase Semantic Functions .. 93 

7.2 Transformed Abstract Syntax of Names . .... 94 

7.3 Interphase Semantic Equations. 95 

7.3.1 Stage 3 VHDL Design Files .. 95 

7.3.2 Entity Declarations. 95 

7.3.3 Architecture Bodies . 95 

7.3.4 Port Declarations. 95 

7.3.5 Declarations. 96 

7.3.6 Concurrent Statements . 97 

7.3.7 Sensitivity Lists . 98 

7.3.8 Sequential Statements. 98 

7.3.9 Case Alternatives. 99 

7.3.10 Discrete Ranges . 99 

7.3.11 Waveforms and Transactions .. 100 

viii 
































7.3.12 Expressions .. 100 

8 Phase 2: State Delta Generation 105 

8.1 Phase 2 Semantic Domains and Functions. 105 

8.1.1 Phase 2 Semantic Domains. 106 

8.1.2 Phase 2 Semantic Functions. 107 

8.2 Phase 2 Execution State. 109 

8.2.1 Unique Name Qualification. 109 

8.2.2 Universe Structure for Unique Dynamic Naming. 109 

8.2.3 Execution Stack . 112 

8.3 Special Functions. 114 

8.3.1 Operational Semantic Functions . 114 

8.3.2 Constructing State Deltas. 115 

8.3.3 Error Reporting . 116 

8.4 Phase 2 Semantic Equations. 117 

8.4.1 Stage 3 VHDL Design Files. 117 

8.4.2 Entity Declarations. 122 

8.4.3 Architecture Bodies . 122 

8.4.4 Declarations. 123 

8.4.5 Concurrent Statements . 141 

8.4.6 Sequential Statements. 142 

8.4.7 Waveforms and Transactions. 161 

8.4.8 Expressions. 162 

8.4.9 Expression Types. 166 

8.4.10 Primitive Semantic Equations. 168 

9 Conclusion 169 

References 171 


IX 


























1 Introduction 


The State Delta Verification System (SDVS), under development over the course of several 
years at The Aerospace Corporation, is an automated verification system that aids in writing 
and checking proofs that a computer program or (design of a) digital device satisfies a formal 
specification. 

The long-term goal of the SDVS project is to create a production-quality verification system 
that is useful at all levels of the hierarchy of digital computer systems; our aim is to verify 
hardware from gate-level designs to high-level architecture, and to verify software from the 
microcode level to application programs written in high-level programming languages. We 
are currently extending the applicability of SDVS to both lower levels of hardware design 
and higher levels of computer programs. A technical overview of the system is provided by 
[1] and [2], while detailed information on the system may be found in [3] and [4]. 

Several features distinguish SDVS from other verification systems (refer to [5] for a detailed 
discussion). The underlying temporal logic of SDVS, called the state delta logic , has a 
formal model-theoretic semantics. SDVS is equipped with a theorem prover that runs in 
interactive or batch modes; the useT supplies high-level proof commands, while many low- 
level proof steps are executed automatically. One of the more distinctive features of SDVS 
is its flexibility — there is a well-defined and relatively straightforward method of adapting 
the system to arbitrary application languages (to date: ISPS, Ada, and VHDL). Further¬ 
more, descriptions in the application languages potentially serve as either specifications or 
implementations in the verification paradigm. Incorporation of a given application language 
is accomplished by translation to the state delta logic via a Common Lisp translator pro¬ 
gram, which is (generally) automatically derived from a formal denotational semantics for 
the application language. 

Prior to 1987 we adapted SDVS to handle a subset of the hardware description language 
ISPS. However, ISPS has serious limitations regarding the specification of hardware at levels 
other than the register transfer level. In fiscal year 1988 we documented a study of some 
of the hardware verification research being conducted outside Aerospace and investigated 
VHDL (VHSIC Hardware Description Language), an IEEE and DoD standard hardware 
description language released in December 1987. We selected VHDL as a possible medium 
for hardware description within SDVS. 

The aim of the ongoing formal hardware verification effort in SDVS is to verify hardware 
descriptions written in VHDL. This choice of hardware description language is particu¬ 
larly well-suited to our overall aim of verifying hardware designs across the spectrum from 
gate-level designs to high-level architectures. Indeed, the primary hardware abstraction in 
VHDL, the design entity , represents any portion of a hardware design that has well-defined 
inputs and outputs and performs a well-defined function. As such, “a design entity may 
represent an entire system, a sub-system, a board, a chip, a macro-cell, a logic gate, or any 
level of abstraction in between” [6]. 

Prerequisites for adapting SDVS to VHDL are (1) to define VHDL semantics formally in 
terms of SDVS’s underlying logic (the state delta logic) and (2) to implement a translator 
from VHDL to the state delta logic. As with the incorporation of Ada into SDVS [7], the 


1 




approach taken with VHDL has been to implement increasingly complex language subsets; 
this has enabled a graded, structured approach to hardware verification. 

In fiscal year 1989 we defined an initial subset of VHDL, called Core VHDL, that cap¬ 
tured the most essential behavioral features of VHDL, including: ENTITY declarations; 
ARCHITECTURE bodies; CONSTANT, VARIABLE, SIGNAL, and PORT declarations; predefined 
types BOOLEAN, BIT, BIT_VECTOR, and INTEGER; variable and signal assignment statements; 
IF, CASE, WAIT, and NULL statements; and concurrent PROCESS statements. We defined both 
the concrete syntax and the abstract syntax for Core VHDL, formally specified its seman¬ 
tics and, on the basis of this semantic definition, implemented a Core-VHDL-to-state-delta 
translator [8]. 

In fiscal year 1990, SDVS was enhanced to provide the capability of verifying hardware 
descriptions written in Core VHDL [9, 10]. In fiscal year 1991, the translator underwent ex¬ 
tensive revision to accommodate a second VHDL subset, Stage 1 VHDL [11], which included: 
WAIT statements in arbitrary contexts; LOOP, WHILE, and EXIT statements; TRANSPORT delay; 
aggregate signal assignments; and a revised translator structure. 

Implemented in fiscal year 1992, Stage 2 VHDL provided a considerably more complex and 
capable VHDL language subset. Stage 2 VHDL extended Stage 1 VHDL with the addition 
of the following VHDL language features: (restricted) design files, declarative parts in 
entity declarations, package STANDARD (containing predefined types BOOLEAN, BIT, INTEGER, 
TIME, CHARACTER, REAL, STRING, and BIT_VECTOR), user-defined packages, USE clauses, array 
type declarations, enumeration types, subprograms (procedures and functions, excluding 
parameters of object class SIGNAL), concurrent signal assignment statements, FOR loops, 
octal and hexadecimal representations of bitstrings, default object class SIGNAL for ports, 
and general expressions of type TIME in AFTER clauses. 

The VHDL language subset implemented in fiscal year 1993, Stage 3 VHDL, extends Stage 
2 VHDL with the addition of subtypes of scalar types, integer type definitions, and type 
conversions between integer types. Furthermore, the SDVS user can now set “statement 
marks” (in the form of interpreted comments) for sequential statements. Finally, a facility 
for specifying, proving, and invoking the behavior of a VHDL subprogram — VHDL offline 
characterization — has been implemented [3]. The SDVS VHDL and Ada translators have 
been reengineered to a uniform implementation reflecting language similarities where these 
exist, and optimized for greater space- and time-efficiency. 

As far as immediate plans are concerned, the scope of VHDL descriptions amenable to 
SDVS, as well as the specifications that could be proved about them, will be significantly 
broadened by (1) enhancing the SDVS Simplifier with support for reasoning about sym¬ 
bolic representations of VHDL time, and (2) augmenting the SDVS proof language with 
a command for induction over VHDL simulation cycles (or adapting the existing induct 
command for that purpose). 

The purpose of the present report is to provide a formal description of the translation of 
Stage 3 VHDL hardware descriptions into state deltas. This amounts to a formal semantic 
specification of Stage 3 VHDL, presented herein as a continuation-style denotational seman¬ 
tics [12] for which the state delta language provides the semantic domain. The translation 
basically consists of parsing followed by two semantic analysis phases. 


2 



The first phase receives the abstract syntax tree generated by the Stage 3 VHDL parser for 
a given hardware description, and: 

• performs static semantic analysis, including type checking; 

• collects an environment that associates all names declared in the subject Stage 3 
VHDL hardware description with their attributes; 

• appropriately disambiguates identical names declared in different scopes, as required 
by the static block structure of the hardware description; and 

• for the convenience of the second phase, transforms the abstract syntax tree of the 
subject hardware description. 

Phase 2 receives the transformed abstract syntax tree and the environment constructed by 
Phase 1, and uses these to translate the Stage 3 VHDL hardware description into state 
deltas. This translation is incremental, in the sense that it is driven by symbolic execution 
of the hardware description, producing further state deltas as symbolic execution proceeds. 

The Stage 3 VHDL formal description is an extensive revision and expansion of the formal 
specifications of the Core VHDL, Stage 1 VHDL, and Stage 2 VHDL translators [8, 11, 13]. 
The Stage 3 VHDL translator specification was written in DL, the semantic metalanguage of 
a denotational semantics specification system called DENOTE [14]. DENOTE enables the 
semantic equations of the specification to be automatically translated into both a printable 
representation (included in this report) and an executable Common Lisp program that 
constitutes the translator’s implementation. 

This report is organized as follows. 

• Our approach to the semantics of Stage 3 VHDL is discussed in Section 2. 

• Section 3 contains an overview of the Stage 3 VHDL subset. 

• Section 4 provides preliminary information (background and notation) on the partic¬ 
ular method of semantic description used. 

• Section 5 lists both the concrete and abstract syntax of Stage 3 VHDL. 

• Section 6 presents the Stage 3 VHDL static semantics. 

• Section 7 presents the interphase abstract syntax tree transformation. 

• Section 8 presents the Stage 3 VHDL dynamic semantics in terms of state deltas. 

• Finally, some concluding remarks are made in Section 9. 


3 


2 History of Our Semantic Approach to VHDL 


The VHDL translator essentially functions as a simulator kernel, maintaining a clock and 
a list of future events that are defined as state deltas. For Core VHDL (fiscal years 1989 
and 1990), the translator transformed possibly multiple Core VHDL statements: sequential 
statements between WAIT statements within a process were all translated and then composed 
into a single state delta. The translator updated the clock to the next time at which a signal 
driver became active or a process resumed. As the clock advanced, the translator merged 
the composite state deltas into a single state delta that specified the behavior of all processes 
at that point in the execution. 

For Stage 1 VHDL (fiscal year 1991), we re-evaluated the feasibility of using composition 
in the translation of VHDL to state deltas, and concluded that although composition had 
initially seemed viable in the case of Core VHDL, it is impossible in principle to apply 
the technique to more complex VHDL subsets, as the attempt would require the ability to 
compose over sections of VHDL code that would necessitate static proof in SDVS. More 
generally, the ability to compose over arbitrary WAIT-bracketed code in PROCESS statements 
would be tantamount to the automatic construction of correctness proofs without user 
intervention — a theoretically undecidable problem. 

Therefore, we abandoned composition for Stage 1 VHDL and subsequent SDVS VHDL 
subsets. Instead, within a given execution (simulation) cycle, processes are translated se¬ 
quentially, in the order in which they appear in the VHDL description, and the user has 
control over stepping through the sequential statements within each process. Thus, rather 
than trying to have the VHDL translator model the concurrency of the processes, we choose 
to take for granted a certain “metatheorem” about VHDL: that any two sequentializations 
of the processes are equivalent. A brief justification for this point of view is that the problem 
of mutual exclusion is not a concern in VHDL, since 

• all variables are local to the process in which they are declared, and 

• distinct processes modify distinct drivers of a given signal (known as a resolved signal ), 
and the ultimate signal value is obtained by application of a user-defined resolution 
function} 

A gratifying benefit of the revised translation strategy is that the understandability of the 
resulting proofs has been remarkably improved — the dynamic flow of process execution 
precisely reflects the simulation semantics of VHDL (as defined in the VHDL Language 
Reference Manual [6]), but with the crucial aspect of symbolic execution (use of abstract 
values rather than concrete) thrown in. The current Stage 3 VHDL translator thus functions 
as a “symbolic simulator,” with the effect of being reasonably intuitive as a proof engine. 


1 As of Stage 3 VHDL, however, resolved signals are still disallowed. 


5 



3 Overview of Stage 3 VHDL 


Stage 3 VHDL comprises a relatively powerful behavioral subset of VHDL. That is to 
say, Stage 3 VHDL descriptions are confined to the specification of hardware behavior 
or data flow, rather than structure. More comprehensive VHDL subsets for SDVS will 
include constructs for the structural description of hardware in terms of its hierarchical 
decomposition into connected subcomponents; this enhancement may be implemented in 
Stage 4 VHDL. 


3.1 General Remarks 

The primary VHDL abstraction for modeling a digital device is the design entity . A design 
entity consists of two parts: an entity declaration , providing an external view of the compo¬ 
nent by declaring the input and output ports , and an architecture body , giving an internal 
view in terms of component behavior or structure. 

In Stage 3 VHDL, each architecture body is constrained to be behavioral , consisting of a 
set of declarations and concurrent statements defining the functional interpretation of the 
device being modeled. The allowable concurrent statements are of two kinds: PROCESS 
statements and concurrent signal assignment statements, to be discussed below. 

A PROCESS statement, the most fundamental kind of behavioral concurrent statement in 
VHDL, is a block of sequential zero-time statements that execute sequentially but “in¬ 
stantaneously” in zero time [15], and some (possibly none) distinguished sequential WAIT 
statements whose purpose is to suspend process execution and allow time to elapse. 

A process typically schedules future values to appear on data holders called signals , by 
means of sequential signal assignment statements. The execution of a signal assignment 
statement does not immediately update the value of the target signal (the signal assigned 
to); rather, it updates the target signal’s associated driver signal by placing (at least one) 
new transaction , or time-value pair, on the waveform that is the list of such transactions 
contained in the driver. Each transaction projects that the signal will assume the indicated 
value at the indicated time; the time is computed as the sum of the current clock time of the 
model and the delay specified (explicitly or implicitly) by the signal assignment statement. 

Two types of time delay can be specified by a sequential signal assignment statement, and 
Stage 3 VHDL encompasses both. Inertial delay , the default, models a target signal’s inertia 
that must be overcome in order for the signal to change value; that is, the scheduled new 
value must persist for at least the time period specified by the delay in order actually to 
be attained by the target signal. Transport delay , on the other hand, must be explicitly 
indicated in the signal assignment statement with the reserved word TRANSPORT, and models 
a “wire delay” wherein any pulse of whatever duration is propagated to the target signal 
after the specified delay. 

In lieu of explicit WAITs, a process may have a sensitivity list of signals that activate process 
resumption upon receiving a distinct new value (an event). The sensitivity list implicitly 
inserts a WAIT statement as the last statement of the process body. 


7 



The other class of concurrent statement in Stage 3 VHDL is that of concurrent signal 
assignment statements. These always represent equivalent PROCESS statements, and come 
in two varieties: conditional signal assignment and selected signal assignment. A conditional 
signal assignment is equivalent to a process with an embedded IF statement whose branches 
are sequential signal assignments; similarly, a selected signal assignment is equivalent to 
a process with an embedded (possibly degenerate) CASE statement whose branches are 
sequential signal assignments. The VHDL translator syntactically transforms concurrent 
signal assignment statements to their corresponding PROCESS statements prior to translation 
into state deltas. 

Signals act as data pathways between processes. Each process applies operations to values 
being passed through the design entity. We may regard a process as a program implementing 
an algorithm, and a Stage 3 VHDL description as a collection of independent programs 
running in parallel. 

In full VHDL, a target signal can be assigned to in multiple processes, with a separate driver 
for updating by each process; the value taken on by the signal at any particular time is 
then computed by a user-defined resolution function of these drivers. As did previous SDVS 
VHDL subsets, Stage 3 VHDL disallows such resolved signals: a signal is not permitted to 
appear as the target of a sequential signal assignment statement in more than one process 
body; equivalently, every signal has a unique driver. Resolved signals and their resolution 
functions will be implemented in a future version of SDVS. 

The Stage 3 VHDL data types are: BOOLEAN, BIT, UNIVERSAL-INTEGER, INTEGER, REAL (pre¬ 
liminary version), TIME (a predefined physical type of INTEGER range), CHARACTER, STRING 
(arrays of characters), BIT-VECTOR (arrays of bits), user-defined enumeration types , user- 
defined array types , subtypes of scalar types, and integer type definitions. Furthermore, 
explicit type conversions between integer types are allowed. The preliminary implemen¬ 
tation allows VHDL descriptions involving type REAL to be parsed and translated, but 
provides no support for reasoning about floating point numbers. 


3.2 Stage 3 VHDL Language Summary 

Concrete and abstract syntaxes for Stage 3 VHDL have been defined — see Section 5 — as 
required, of course, for the implementation of the Stage 3 VHDL translator. The foDowing 
is a convenient synopsis of the Stage 3 VHDL language subset. 

• VHDL design files 

- entity declarations, architecture bodies 

- restriction: unique entity and architecture per file 

• package STANDARD 

- predefined types: 

BOOLEAN, BIT, UNIVERSAL-INTEGER, INTEGER, TIME, CHARACTER, REAL, 

STRING,BIT-VECTOR 

- various units of type TIME: FS, PS, NS, US, MS, SEC, MIN, HR 


8 



- restriction : the implementation of type REAL is preliminary 

• user-defined packages 

- package declarations 

- package bodies 

• USE clauses for accessing packages 

- restriction : packages must be used in their entirety 

• entity declarations 

- entity header: port declarations 

- entity declarative part: other declarations 

• architecture bodies 

• object declarations 

- CONSTANT, VARIABLE, SIGNAL 

- octal and hexadecimal representations of bitstrings 

- default object class SIGNAL for entity ports 

• array type declarations 

- arrays of arbitrary element type 

- bidirectional arrays, unconstrained arrays 

• user-defined enumeration types 

• subtypes of scalar types 

• integer type definitions 

• type conversion 

• signals of arbitrary types 

• subprograms 

- procedures and functions: declarations and bodies 

- restriction: excluding parameters of object class SIGNAL 

• concurrent statements 

- PROCESS statements 

- conditional signal assignments 

- selected signal assignments 

• sequential statements 


9 



- null statement: NULL 

- variable assignments (scalar & composite) 

- signal assignments (scalar & composite, inertial or TRANSPORT delay) 

- conditionals: IF, CASE 

- loops: LOOP, WHILE, FOR 

- loop exits: EXIT 

- subprogram calls 

- subprogram return: RETURN 

- process suspension: WAIT 

• operators 

- numeric unary operators: ABS, +, - 

- numeric binary operators: +, *, /, ** (exponentiation), 

HOD (modulus), REM (remainder) 

- boolean and bit operators: NOT, AND, NAND, OR, NOR, XOR 

- relational operators: =, /=, <, <=, >, and >= 

- array concatenation operator: & 

- restriction : =, /=, and k are the only Stage 3 VHDL operators defined for com¬ 
posite types (i.e., BIT-VECTOR and user-defined array types). 


10 



4 Preliminaries 


The purpose of this section is to provide some of the background and notation necessary 
for the research documented in this report. It is assumed that the reader is familiar with 

• the descriptive aspects of the denotational technique for expressing the semantics 
of programming languages (including concepts such as syntax, semantic functions, 
lambda notation, curried function notation, environments, and continuations) as pre¬ 
sented in [12]; and 

• the theory and practice of state deltas [3, 16, 17]. 

Denotational semantic definitions of programming languages consist of two parts: syntax 
and semantics. The syntax part consists of domain equations (equivalent to productions of 
a context-free grammar) that define the syntactic variables (analogous to grammar nonter¬ 
minals) and the (abstract) syntactic elements of the language. The semantic part defines a 
semantic function for each syntactic variable and the definition (by syntactic cases) of these 
functions; it also defines auxiliary functions that are used in the definition of the semantic 
functions. The semantic functions constitute a syntax-directed mapping from the syntactic 
constructs of the language to their corresponding semantics. 

Certain principal notions, among which are environments and continuations , are central to 
standard denotational semantic definitions of programming languages. 

4.1 Environments 

Environments are functions from identifiers to their “definitions”; these definitions are called 
denotable values . Identifiers that have no corresponding definition are formally bound to 
the special token *UNBOUND*. The identifiers are names for objects (e.g. constants, 
variables, procedures, and exceptions) in a program written in the language being defined. 
Environments are usually created and modified by the elaboration of declarations in the 
language. 

The domain of environments, Env, is typically 

Env = Id (Dv + ^UNBOUND*) 

where Id and Dv are, respectively, the domains of identifiers and denotable values. If r is an 
environment, then r(id) is the value (*UNBOUND* or a Dv-value) bound to the identi¬ 
fier id. The empty environment rO is the environment in which rO(id) = *UNBOUND* 
for every identifier id. In definitions of languages that have block-structured scoping, it 
is necessary to combine two environments that may each associate a denotable value with 
the same identifier. If rl and r2 are environments, then rl[r2] is a combined environment 
defined by 

rl[r2](id) = (r2(id) = "“UNBOUND* rl(id), r2(id)) 

where (a —*• b,c) is an abbreviation for if a then b else c. That is, in rl[r2], the r2-value 
of an identifier “overrides” the rl-value of that same identifier, except when its r2-value is 


11 




*UNBOUND*. An environment can be changed by this means. If r is an environment, 
d a value, and id an identifier, then r[d/id] denotes an environment that is the same as r 
except that (r[d/id])(id) = d. 

Tree-Structured Environments 

When the use of the above combination of environments is inconvenient or inappropriate, 
it is sometimes necessary to use a structured collection of environments. A tree-structured 
environment (TSE) is a tree whose nodes are environments and whose edges are labeled by 
identifiers or numerals, called edge labels , where no two edges emanating from a given node 
can have the same label. A path is a list of zero or more edge labels. Such a path denotes 
a sequence of connected edges from the root node to another node of a tree-structured 
environment. A path p can be extended by an edge labeled elbl via %(p)(elbl), where 

%(path)(id) — append(path,(id)) 

Formally, a TSE can be regarded as a partial function from paths to environments. Thus 
the set of paths in a TSE t is precisely the set of paths p for which t(p) is defined. If t is 
a TSE and p is a path in t, then t(p) denotes the unique environment in t located at the 
end of p. 

If t is a TSE and p is one of its paths, the pair (t,p) can be used to represent the set of 
environments containing all of the identifier bindings visible at a given point in a Stage 3 
VHDL hardware description, where the identifiers in p are the names of the lexical scopes 
whose local environments are on the path p. At the program point whose identifier bindings 
are represented by (t, (elbb, ..., elbl n )), t((elbl!, ..., elbl n )) is the most local set of 
bindings, ..., and t(e) is the most global set of bindings, where e denotes the empty path. 
Thus t(p)(id) is the value bound to id in the most local environment of (t,p). 

Qualified Names 

The same identifier is bound in every component environment of a TSE, although many 
(if not most) of those bindings may be to ^UNBOUND*. It is convenient to be able to 
distinguish uniquely an occurrence of an identifier by prefixing to the identifier a represen¬ 
tation of the path that designates the location in the TSE of the environment associated 
with that instance. Such a uniquely distinguished identifier will be called a fully qualified 
name. Thus if t is a TSE, p one of its paths, and id an identifier, then $(p)(id) is id’s fully 
qualified name relative to t(p). If p = (elbl 1? ..elbl n ), then $(p)(id) is represented as 

elbli.elbl 2 .elbl n .id. When p = c (empty path), $(e)(id) is simply represented by 

id. 8 is defined by 

$(path)(id) = (path = e —+ id, $(rest(path))(catenate(last(path),“.”,id))) 

The function rest returns a list consisting of the first n - 1 elements of an n-element list, 
and catenate is a curried function that concatenates its (variable number of) arguments 
into an atom. 

Identifiers qualified with the fuD TSE path that locates their associated component envi¬ 
ronment are cumbersome and hard to read. If only those instances of identifiers not bound 
to ^UNBOUND* are of interest, then such full name qualification may be unnecessary. 


12 



Often a suffix of this path is sufficient to distinguish uniquely an instance of such an iden¬ 
tifier. An identifier so qualified is said to be uniquely qualified. In the limit, if all identifiers 
not bound to *UNBOUND* were distinct, then no qualification (an empty suffix) would 
be necessary to distinguish them. Given a TSE, it is possible to determine the minimum 
path suffix necessary to distinguish uniquely each identifier instance; this is done in our 
implementation of Stage 3 VHDL. 

Descriptors 

The denotable values to which identifiers are bound in the component environments of a 
TSE are called descriptors. 

A descriptor contains several fields of information, each of which holds an attribute of the 
identifier instance to which the descriptor is bound in a given TSE component environment. 
The number of fields in a descriptor depends on the attributes of its associated identifier, 
but each descriptor always has fields that contain the identifier to which it is bound, the 
identifier instance’s statically uniquely qualified name (see Section 8.2.1), and a tag that 
identifies the kind of descriptor (and hence its remaining fields). 

Descriptors for Stage 3 VHDL are discussed in detail in Section 6.2. 

Tree-Structured Environment Access 

Certain non-*UNBOUND* (i.e., denotable) values of an identifier id in (t,p) can be 
accessed by the functions lookup and lookup-local. These functions are given later in the 
context of semantic equations in which they are used. 

Tree-Structured Environment Modification 

A TSE’s component environments can be modified (in particular, descriptors can be bound 
to unbound identifiers or existing descriptors can be modified) via a function built into 
DENOTE. This function, enter, is used extensively in the DENOTE description of the 
Stage 3 VHDL translator. enter(t)(p)(id)(d), where t is a TSE, p a path in t, id an 
identifier, and d a partial descriptor (containing all its fields except the identifier field), 
yields a TSE that is the same as t except that its component environment t(p) is replaced 
by the environment 

t(p)[d’/id], where if d = (qid, tag, ... ), then d’ = (id, qid, tag, ... ). 
Tree-Structured Environment Extension 

One can add additional component environments to a TSE by extending it. If t is a TSE, 
p a path in t, and elbl an edge label, and if %(p)(elbl) is not a path in t, then 

extend(t)(p)(elbl) 

denotes the TSE that is the same as t except that 

(extend(t)(p)(elbl))(%(p)(elbl)) = rO. 

Thus one can extend t along one of its paths p by adding a legally labeled edge onto the 
end of p and placing a node that is the empty environment rO at the end of that extended 
path %(p)(elbl). 


13 




4.2 Continuations 


Continuations are a technical device for capturing the semantics of transfers of control, 
whether they be explicit (gotos, returns from procedures and functions) or implicit (normal 
sequential flow of control to the next program element, abnormal termination of program 
execution). Continuations are functions intended to map the “normal” result of a semantic 
function to some ultimate “final answer” [some final value(s) or an error message]. If the 
semantic function does not produce a normal result, its continuation can be ignored and 
some “abnormal” final answer (such as an error message) can be produced instead. 

For example, in the first phase of our formal description of the Stage 3 VHDL translator, a 
continuation supplied to a semantic function that elaborates declarations normally maps a 
new “translation state” to a final answer, but if a declaration illegally duplicates or conflicts 
with an existing definition, then the continuation is ignored and an error message (such as 
DUPLICATE-DECLARATION) is the resulting final answer. 

The initiation of the second phase of our formal description of the Stage 3 VHDL translator 
assumes that the program has first “passed” the first phase without error. In fact, the 
second phase is used as the continuation for the first. 

4.3 Other Notation and Functions 

Fairly standard lambda notation (see [12]) is used in this report, except that structured 
arguments are permitted in lambda-abstractions. Lambda-abstractions normally have the 
form Ax.body, where body is a lambda-term and x may be free in body. The term 
Ax.Ay.body is printed as Ax,y.body. If x is, for example, a pair, then the components of 
x can be represented in body by the application of projection functions to x. Instead, the 
individual components of x can be bound to variables y and z that appear free in body 
(instead of projection functions applied to x) by using the abstraction A(y,z).body . This 
is defined if and only if the value of x is indeed a pair. This notation will be used only when 
its result is defined. 

A list is represented in the usual way: (x,y,z). Standard Lisp functions are used, but they 
are curried, as in cons(x)(y) and append(x)(y). If x is a nonempty sequence (list), then 
hd(x) denotes its first element and tl(x) the sequence (list) of its remaining components; 
x = cons(hd(x))(tl(x)). 

Some general-purpose functions are second, third, fourth, fifth, sixth, and last, which 
return the second, third, fourth, fifth, sixth, and last elements, respectively, of a list. Ad¬ 
ditionally, we have rest, which returns a list consisting of the first n - 1 elements of an 
n-element list, and length, which returns the integer length of a list. 

second(x) = hd(tl(x)) 

third(x) = hd(tl(tl(x))) 

fourth(x) = hd(tl(tl(tl(x)))) 

fifth(x) = hd(tl(tl(tl(tl(x))))) 


14 



sixth(x) = hd(tl(tl(tl(tl(tl(x)))))) 
last(id + ) = (null(tl(id + ))—♦ hd(id + ), last(tl(id + ))) 
rest(id + ) = (null(tl(id + ))—► e, cons(hd(id + ),rest(tl(id + )))) 
length(x) = (null(x)—► 0, l+length(tl(x))) 


15 



5 Syntax of Stage 3 VHDL 


Three Stage 3 VHDL syntaxes are used by the translator: a concrete syntax , which is 
SLR(l) and is used for parsing Stage 3 VHDL hardware descriptions; and two abstract 
syntaxes , which are used, respectively, in Phases 1 and 2 of the semantic definition. The 
concrete syntax is intended to be the “reference” grammar for the Stage 3 VHDL language 
subset. 

In all three syntaxes the syntactic constructs are the members of syntactic domains , which 
are of two kinds: primitive and compound . The primitive syntactic domains are given. 
The compound syntactic domains are functions of the primitive domains; these functional 
dependencies are expressed as a set of syntax equations represented as productions of a 
context-free grammar. Terminals and nonterminals of this grammar range, respectively, 
over the primitive and compound syntactic domains. Only those syntactic domains of the 
abstract syntax that actually appear in a semantic equation will be given explicit names; 
other syntactic domains will be unnamed, as these names are not used in the specification. 

The terminal classes are: identifiers, unsigned decimal numerals, bit literals, character 
literals, bitstrings (binary, octal, and hexadecimal), and strings. The remaining terminal 
symbols serve as reserved words. 

The concrete syntax of Stage 3 VHDL, being SLR(l), is unambiguous. The abstract syn¬ 
taxes are considerably smaller than the concrete syntax, because they are not concerned with 
providing a parsable representation of Stage 3 VHDL, but rather simply provide the min¬ 
imum syntactic information necessary for a syntax-directed semantic specification. Their 
use yields a more compact formal definition. 

The translation of a hardware description (from concrete syntax) to its abstract syntax 
representation is accomplished by semantic action routines in the Stage 3 VHDL parser. 
This process is straightforward, and a formal specification of how the Phase 1 abstract 
syntax is derived from the concrete syntax is omitted from this Teport. It is felt that the 
correspondence between the concrete and Phase 1 syntaxes is so close that no such formal 
specification is needed. The derivation of Phase 2 syntactic objects from corresponding 
Phase 1 syntactic objects is explicit in the specification of the interphase abstract syntax 
tree transformation; see Section 7. 

There are some minor variations between the concrete and abstract syntaxes of Stage 3 
VHDL. For example, in the concrete syntax, labels for PROCESS statements and loops (LOOP, 
WHILE, FOR statements) are optional. It was found, however, that the semantics of Stage 
3 VHDL requires that every process and loop have a label. Thus in the abstract syntaxes 
(which drive the semantics), process and loop labels are required. This is enforced by 
having the parser and the constructor of the Phase 1 abstract syntax tree supply a distinct 
system-generated label for each unnamed process and loop. These labels are taken from a 
primitive syntactic domain Sysld of system-generated identifiers , disjoint from the primitive 
syntactic domain Id of identifiers. Similarly, anonymous array types are given distinct 
system-generated names. 

The following subsections present the syntactic domains and equations for Stage 3 VHDL. 


17 



5.1 Syntactic Domains 
Primitive Syntactic Domains 


id : Id 
Sysld 

bit : BitLit 
constant : NumLit 
char : CharLit 

bitstring, octstring, hexstring : BitStr 
string : Str 

Compound Syntactic Domains 


design-file : Design 
ent-decl : Ent 
arch-body : Arch 
port-decl : PDec 

decl, pkg-decl, pkg-body, use-clause : Dec 

con-stat : CStat 

seq-stat : SStat 

case-alt : Alt 

discrete-range : Drg 

waveform : Wave 

transaction : Trans 

expr : Expr 

ref : Ref 

unary-op : Uop 

binary-op : Bop 

relational-op : Bop 

5.2 Syntax Equations 


identifiers 

system-generated identifiers (disjoint from Id) 
bit literals 

numeric literals (unsigned decimal numerals) 
character literals 
bitstring literals 
string literals 


design files 

entity specifications 

architecture body specifications 

port declarations 

declarations 

concurrent statements 

sequential statements 

case alternatives 

discrete ranges 

waveforms 

transactions 

expressions 

references 

unary operators 

binary operators 

relational operators 


In Sections 5.2.1, 5.2.2, and 5.2.3 we present, respectively, the concrete syntax for Stage 
3 VHDL hardware descriptions admissible as input to the SDVS VHDL language parser, 
the syntax of VHDL abstract parse trees generated by the parser for use by Phase 1 of the 
VHDL translator, and the syntax of transformed parse trees produced during Phase 1 for 
use by translator Phase 2. 


5.2.1 Concrete Syntax 

The concrete syntax for Stage 3 VHDL is shown below. 

The productions are numbered for reference purposes. The first production and the nonter¬ 
minal **start** are inserted by the SLR(l) grammar analyzer to facilitate SLR(l) parsing, 


18 



and the (terminal) symbol *E* denotes the beginning or end of a file. Terminal symbols 
appear in uppercase letters, while nonterminal symbols and pseudo-terminals (terminals 
denoting a set of values) are in lowercase; pseudo-terminals are prefixed by a “dot” (.). 

STAGE 3 VHDL CONCRETE SYNTAX 


1 **start** 

:; = *£* design-file *E* 


2 


design-file 

::= DESIGN_FILE .id 
use-clause-list 


IS init pkg-decl-list pkg-body-list 
entity-declaration architecture-body 


3 init 


4 pkg-decl-list 

5 I pkg-decl-list pkg-decl 

6 pkg-decl 

PACKAGE .id IS pkg-decl-part END opt-id ; 


7 pkg-decl-part 

::= pkg-decl-item-list 

8 pkg-decl-item-list 

9 I pkg-decl-item-list pkg-decl-item 


10 

11 

12 

13 

14 

15 


pkg-decl-item 

::= const-decl 
I sig-decl 
| type-decl 
1 subtype-decl 
I subprog-decl 
I use-clause 


16 opt-id 

17 I .id 


18 pkg-body-list 

19 I pkg-body pkg-body-list 

20 pkg-body 

::= PACKAGE BODY .id IS pkg-body-decl-part END opt-id ; 

21 pkg-body-decl-part 

::= pkg-body-decl-item-list 

22 pkg-body-decl-item-list 

23 I pkg-body-decl-item-list pkg-body-decl-item 


19 



24 pkg-body-decl-item 



: : = 

const-decl 

25 

1 

type-decl 

26 

1 

subtype-decl 

27 

1 

subprog-decl 

28 

1 

subprog-body 

29 

1 

use-clause 


30 use-clause-list 

31 | use-clause-list use-clause 

32 use-clause 

USE dotted-name-list ; 

33 dotted-name-list 

dotted-name 

34 | dotted-name-list , dotted-name 

35 dotted-name 

:.id 

36 | dotted-name . .id 

37 entity-declaration 

: := ENTITY .id IS ent-header END opt-id ; 

38 I ENTITY .id IS ent-header ent-decl-part END opt-id 

39 ent-header 

::= opt-port-clause 

40 opt-port-clause 

• ; = 

41 | port-clause 



53 arch-decl-part 

:: = arch-decl-item-list 


20 




54 arch-decl-item-list 


55 1 arch-decl-item-list arch-decl-item 


56 

57 

58 

59 

60 
61 
62 


arch-decl-item 

::= const-decl 
I sig-decl 
1 type-decl 
j subtype-decl 
I subprog-decl 
I subprog-body 
I use-clause 


63 arch-stat-part 

::= con-stats 


64 port-clause 

::= PORT ( port-list ) ; 

65 port-list 

::= interface-list 

66 interface-list 

::= interface-sig-decl 

67 I interface-list ; interface-sig-decl 

68 interface-sig-decl 

::= opt-signal id-list : opt-mode type-mark opt-init 

69 | opt-signal id-list : opt-mode slice-name opt-init 

70 opt-signal 

71 1 SIGNAL 

72 id-list 

::* .id 

73 I id-list , .id 

74 opt-mode 

75 I mode 

76 mode 

: := IN 

77 ! OUT 

78 I INOUT 

79 I BUFFER 

80 type-mark 

::= dotted-name 

81 slice-name 

::= type-mark ( discrete-range ) 

82 discrete-range 

::= range 


21 





simple-expr direction simple-expr 


83 range 


84 direction 
: TO 


85 

1 D0WNT0 




86 

opt-init 




87 

1 := expr 




88 

const-decl 





CONSTANT 

id-list 

: type-mark 

:= expr 

89 

I CONSTANT 

id-list : 

: slice-name 

:= expr 

90 

var-decl 





VARIABLE 

id-list : 

: type-mark 

opt-init 

91 

1 VARIABLE 

id-list 

: slice-name 

opt-init 


92 sig-decl 

::= SIGNAL id-list : type-mark opt-init ; 

93 | SIGNAL id-list : slice-name opt-init ; 

94 type-decl 

enum-type-decl 

95 I array-type-decl 

96 I integer-type-decl 

97 enum-type-decl 

TYPE .id IS enum-type-def ; 

98 enum-type-def 

( id-list ) 

99 j ( char-list ) 

100 char-list 

::= character-literal 

101 I char-list , character-literal 

102 array-type-decl 

TYPE .id IS array-type-def ; 

103 array-type-def 

::= ARRAY ( discrete-range ) OF type-mark 

104 integer-type-decl 

::= TYPE .id IS RANGE discrete-range ; 

105 subtype-decl 

::* SUBTYPE .id IS type-mark opt-constraint 

106 opt-constraint 

107 | constraint 

108 constraint 


22 




range-constraint 


109 

range-constraint 

::= RANGE discrete-range 


110 

subprog-decl 

subprog-spec ; 


111 

subprog-spec 



::= PROCEDURE , id opt-procedure-formal-part 

112 

I FUNCTION .id opt-function 

-formal-part RETURN type-mark 

113 

opt-procedure-formal-part 


114 

i ( procedure-par-spec-list 

) 

115 

opt-function-formal-part 


116 

| ( function-par-spec-list 

) 

117 

procedure-par-spec-list 

::= procedure-par-spec 


118 

| procedure-par-spec-list ; 

procedure-par-spec 

119 

function-par-spec-list 
::= function-par-spec 


120 

I function-par-spec-list ; 

f tine t ion-par-spec 

121 

procedure-par-spec 



::= proc-object-class id-list 
type-mark opt-expr 

: procedure-par-mode 

122 

1 id-list : IN type-mark 

opt-expr 

123 

1 id-list : OUT type-mark 

opt-expr 

124 

I id-list : INOUT type-mark opt-expr 

125 

f unct ion-par-spec 



::= fn-object-class id-list 
opt-expr 

function-par-mode type-mark 

126 

proc-object-class 
::= CONSTANT 


127 

I VARIABLE 


128 

fn-object-class 


129 

I CONSTANT 


130 

procedure-par-mode 


131 

1 IN 


132 

I OUT 


133 

1 INOUT 


134 

function-par-mode 


135 

1 IN 



23 




136 subprog-body 

::= subprog-spec IS subprog-decl-part BEGIN 
subprog-stat-part END opt-id ; 

137 subprog-decl-part 

subprog-decl-item-list 

138 subprog-decl-item-list 

; ; = 

139 | subprog-decl-item-list subprog-decl-item 

140 subprog-decl-item 


141 

i 

const-decl 

var-decl 

142 

i 

type-decl 

143 

i 

subtype-decl 

144 

i 

subprog-decl 

145 

i 

subprog-body 

146 

i 

use-clause 


147 subprog-stat-part 

::= seq-stats 

148 con-stats 

149 | con-stats con-stat 

150 con-stat 

::= process-stat 

151 I concurrent-sig-assn-stat 

152 process-stat 

::= opt-unit-label PROCESS process-decl-part BEGIN 
process-stat-part END PROCESS opt-id ; 

153 | opt-unit-label PROCESS ( sensitivity-list ) 

process-decl-part BEGIN process-stat-part END PROCESS 
opt-id ; 

154 opt-unit-label 

155 | .id : 

156 process-decl-part 

process-decl-item-list 

157 process-decl-item-list 

158 I process-decl-item-list process-decl-item 


159 

160 
161 
162 

163 

164 

165 


process-decl-item 
::= const-decl 
I var-decl 
I type-decl 
I subtype-decl 
i subprog-decl 
I subprog-body 
I use-clause 


24 





166 process-stat-part 

::= seq-stats 

167 concurrent-sig-assn-stat 

::= selected-sig-assn-stat 

168 I conditional-sig-assn-stat 

169 selected-sig-assn-stat 

::= opt-unit-label WITH expr SELECT 

target <= opt-transport selected-waveforms ; 

170 I .atmark 

opt-unit-label WITH expr SELECT 

target <= opt-transport selected-waveforms ; 

171 opt-transport 

172 I TRANSPORT 

173 selected-waveforms 

::= selected-waveform 

174 I selected-waveforms , selected-waveform 

175 selected-waveform 

::= waveform WHEN choices 

176 conditional-sig-assn-stat 

::= target <= opt-transport conditional-waveforms waveform ; 

177 I .atmark 

target <= opt-transport conditional-waveforms waveform ; 

178 1 .id : target <* opt-transport conditional-waveforms waveform 

179 I .atmark 

.id : target <= opt-transport conditional-waveforms waveform 

180 conditional-waveforms 

181 I conditional-waveforms conditional-waveform 

182 conditional-waveform 

::= waveform WHEN expr ELSE 

183 waveform 

::= waveform-elt-list 

184 waveform-elt-list 

::= waveform-elt 

185 I waveform-elt-list , waveform-elt 

186 waveform-elt 

::= expr 

187 I expr AFTER expr 

188 seq-stats 

189 I seq-stats seq-stat 

190 seq-stat 


25 



191 

192 

193 

194 

195 

196 

197 

198 

199 


::= null-stat 
I var-assn-stat 
I sig-assn-stat 
I if-stat 
I case-stat 
I loop-stat 
I exit-stat 
I return-stat 
I proc-call-stat 
| wait-stat 


200 null-stat 

::= MULL ; 

201 | .atmark NULL 


202 var-assn-stat 

name := expr ; 

203 | .atmark name := expr ; 


204 sig-assn-stat 

::= target <= opt-transport waveform ; 

205 | .atmark target <= opt-transport waveform ; 

206 if-stat 

::= if-head if-tail 

207 I .atmark if-head if-tail 

208 if-head 

IF expr THEN seq-stats 

209 I if-head ELSIF expr THEN seq-stats 

210 if-tail 

END IF ; 

211 I ELSE seq-stats END IF ; 


212 case-stat 

= CASE expr IS case-alt-list END CASE ; 

213 | .atmark CASE expr IS case-alt-list END CASE 

214 case-alt-list 

::= case-alt 

215 | case-other-alt 

216 | case-alt case-alt-list 


217 case-alt 

WHEN choices => seq-stats 

218 case-other-alt 

::= WHEN OTHERS => seq-stats 

219 choices 

::= choice 

220 | choices 1 choice 

221 choice 

simple-expr 

222 I discrete-range 


26 



223 


loop-stat 

: := simple-loop 

224 I while-loop 

225 I for-loop 

226 simple-loop 

opt-unit-label LOOP seq-stats END LOOP opt-id ; 

227 I .atmark opt-unit-label LOOP seq-stats END LOOP 

opt-id ; 

228 while-loop 

opt-unit-label WHILE expr LOOP seq-stats END LOOP 
opt-id ; 

229 I .atmark opt-unit-label WHILE expr LOOP seq-stats END 

LOOP opt-id ; 

230 for-loop 

::= opt-unit-label FOR name IN discrete-range LOOP 
seq-stats END LOOP opt-id ; 

231 I .atmark opt-unit-label FOR name IN discrete-range 

LOOP seq-stats END LOOP opt-id ; 

232 exit-stat 

::= EXIT opt-dotted-name opt-when-cond ; 

233 I .atmark EXIT opt-dotted-name opt-when-cond ; 

234 opt-dotted-name 

235 I dotted-name 

236 opt-when-cond 

237 I WHEN expr 

238 proc-call-stat 

::= name ; 

239 I .atmark name ; 

240 return-stat 

RETURN ; 

241 I .atmark RETURN ; 

242 I RETURN expr ; 

243 I . atmark RETURN expr ; 

244 wait-stat 

::= WAIT opt-sensitivity-clause opt-condition-clause 
opt-timeout-clause ; 

245 I .atmark WAIT opt-sensitivity-clause 

opt-condition-clause opt-timeout-clause ; 

246 opt-sensitivity-clause 

247 I sensitivity-clause 

248 sensitivity-clause 

ON sensitivity-list 


27 


249 sensitivity-list 

::* name-list 

250 name-list 

: := name 

251 | name-list , name 

252 opt-condition-clause 

; ; s 

253 | condition-clause 

254 condition-clause 

::= UNTIL expr 

255 opt-timeout-clause 

256 I timeout-clause 

257 timeout-clause 

: : = FDR expr 

258 expr-list 

: : = expr 

259 | expr-list , expr 

260 opt-expr 

261 | expr 

262 expr 

::= rel 

263 | rel and-expr 

264 | rel nand-expr 

265 | rel or-expr 

266 | rel nor-expr 

267 | rel xor-expr 

268 rel 

::= simple-expr 

269 I simple-expr relop simple-expr 

270 and-expr 

::= and-part 

271 | and-part and-expr 

272 and-part 

::= AND rel 

273 nand-expr 

::= nand-part 

274 | nand-part nand-expr 

275 nand-part 

NAND rel 

276 or-expr 


28 


277 


::= or-part 

| or-part or-expr 

278 or-part 

OH rel 

279 nor-expr 

::= nor-part 

280 I nor-part nor-expr 

281 nor-part 

::= NOR rel 

282 xor-expr 

::= xor-part 

283 I xor-part xor-expr 

284 xor-part 

::= XOR rel 


285 

simple-expr 

::= simple-exprl 

286 

| + simple-exprl 

287 

I - simple-exprl 

288 

simple-exprl 
::= term 

289 

1 simple-exprl addop term 

290 

term 

: := factor 

291 

| term mulop factor 

292 

factor 

::- primary 

293 

1 primary ** primary 

294 

I ABS primary 

295 

| NOT primary 

296 

primary 

: := primary1 

297 

1 aggregate 

298 

1 C expr ) 

299 

primaryl 

::= literal 

300 

I .atmark 

301 

1 name 

302 

literal 

::= boolean-literal 

303 

I bit-literal 

304 

I character-literal 

305 

I numeric-literal 

306 

I time-literal 

307 

| bitstring-literal 

308 

I string-literal 


29 



309 boolean-literal 

::= FALSE 

310 I TRUE 

311 bit-literal 

::= .bit 

312 character-literal 

::* .char 

313 numeric-literal 

::= .constant 

314 time-literal 

::= opt-time-const ant time-unit 


315 

opt-time-constant 

316 

| .constant 

317 

time-unit 


: := FS 

318 

1 PS 

319 

1 NS 

320 

1 US 

321 

I MS 

322 

1 SEC 

323 

I MIN 

324 

I HR 

325 

bitstring-literal 


.bitstring 

326 

1 .octstring 

327 

1 .hexstring 

328 

string-literal 


: : * . string 


329 aggregate 

::= ( 2-expr-list ) 


330 

2-expr- 

■list 


• • ss 

expr , expr 

331 

1 

2-expr-list , expr 

332 

target 



• * S 

name 

333 

name 



: : = 

namel 

334 

namel 



: : = 

selector 

335 

1 

namel . selector 

336 

1 

namel ( expr-list ) 


30 



337 

selector 


: : = 

. id 

338 

relop 



; . - 

= 

339 

1 

/= 

340 

1 

< 

341 

1 

<= 

342 

1 

> 

343 

1 

>= 

344 

addop 



: : = 

+ 

34S 

1 

- 

346 

1 

& 

347 

mul op 



: : = 

* 

348 

1 

/ 


349 I MOD 

350 I REM 

5.2.2 Abstract Syntax: Phase 1 

The abstract syntax of Stage 3 VHDL used during Phase 1 translation is shown below. 

The superscript denotes Kleene closure (e.g. “decl*” denotes zero or more occurrences 
of the syntactic object “decl”), and a superscript “+” denotes one or more occurrences. In 
a syntactic clause, subscripts denote (possibly) different objects of the same class. 

As in the concrete syntax, terminal symbols appear in upper case, while all other symbols 
are either nonterminals or pseudo-terminals (id, bitlit, and constant). 

STAGE 3 VHDL ABSTRACT SYNTAX: PHASE 1 


design-file ::= DESIGN-FILE id pkg-decl* pkg-body* use-clause* ent-decl arch-body 

pkg-decl ::= PACKAGE id decl* opt-id 

pkg-body ::= PACKAGEBODY id decl* opt-id 

use-clause :: = USE dotted-name^ - 
dotted-name ::= id + 

ent-decl ::= ENTITY id port-decl* decl* opt-id 

arch-body ARCHITECTURE idj id 2 decl* con-stat* opt-id 

port-decl ::= DEC PORT id+ mode type-mark opt-expr 

| SLCDEC PQRT id+ mode slice-name opt-expr 


31 



mode ::= IN | OUT | INOUT | BUFFER 

type-mark dotted-name 

slice-name type-mark discrete-range 

discrete-range ::= direction expri expr2 
direction ::= TO | DOWNTO 

arch-body :ARCHITECTURE id| id2 decl* con-stat* opt-id 

decl ::= object-decl 
I type-decl 
I subtype-decl 
I pkg-decl 
| pkg-body 
I subprog-decl 
I subprog-body 
I use-clause 

object-decl : := DEC object-class id"*" type-mark opt-expr 

I SLCDEC object-class id + slice-name opt-expr 

object-class ::= CONST I VAR | SIG 

type-decl ::= enum-type-decl 
I array-type-decl 
I integer-type-decl 

enum-type-decl ETDEC id id+ 

array-type-decl :: = ATDEC id discrete-range type-mark 
integer-type-decl ::= ITDEC id discrete-range 
subtype-decl ::= STDEC id type-mark opt-discrete-range 
subprog-decl ::= subprog-spec 

subprog-spec :PROCEDURE id proc-par-spec* type-mark 
I FUNCTION id func-par-spec* type-mark 

proc-par-spec ::= object-class id+ proc-par-mode type-mark opt-expr 
func-par-spec ::= object-class id + func-par-mode type-mark opt-expr 


32 




proc-par-mode : := IN | OUT | INOUT 
func-par-mode ::= IN 

subprog-body : := SUBPROGBODY subprog-spec decl* seq-stat* opt-id 

con-stat ::= process-stat 

| selected-sig-assn-stat 
I conditional-sig-assn-stat 

process-stat ::= PROCESS id ref* decl* seq-stat* opt-id 

selected-sig-assn-stat ::= SEL-SIGASSN delay-type id expr ref selected-waveform* 
selected-waveform ::= SEL-WAVE waveform discrete-range* 

conditional-sig-assn-stat ::= COND-SIGASSN delay-type id ref cond-waveform* waveform 
cond-waveform COND-WAVE waveform expr 


seq-stat ::= null-stat 

I var-assn-stat 
I sig-assn-stat 
I if-stat 
I case-stat 
I loop-stat 
I while-stat 
I for-stat 
I exit-stat 
| call-stat 
I return-stat 
I wait-stat 


null-stat : 


= NULL 


var-assn-stat ::= VARASSN ref expr 


sig-assn-stat ::= SIGASSN delay-type ref waveform 

delay-type ::= INERTIAL I TRANSPORT 

waveform ::*= WAVE transaction^ 
transaction ::= TRANS expr opt-expr 


if-stat ::= IF cond-part+ else-part 
cond-part ::= expr seq-stat* 
else-part seq-stat* 


case-stat ::= CASE expr case-alt + 




case-alt 


::= CASECHOICE discrete-range* seq-stat* 

I CASEOTHERS seq-stat* 

loop-stat ::= LOOP id seq-stat* opt-id 

while-stat WHILE id expr seq-stat* opt-id 

for-stat FOR id ref discrete-range seq-stat* opt-id 

exit-stat EXIT opt-dotted-name opt-expr 

call-stat ::= CALL ref 

return-stat ::= RETURN opt-expr 

wait-stat WAIT ref* opt-expri opt-expr2 

expr :6 

I bool-lit 
I bit-lit 
I num-lit 
I time-lit 
I char-lit 
I bitstr-lit 
I str-lit 
I ref 

I positional-aggregate 
I unary-op expr 
I binary-op exprj expr 2 
I relational-op expri expr 2 

bool-lit ::= FALSE I TRUE 

bit-lit ::= BIT bitlit 

num-lit ::= NUM constant 

time-lit ::= TIME constant time-unit 

char-lit ::= CHAR constant 

bitstr-lit ::= BITSTR bit-lit* 

str-lit ::= STR char-lit* 

ref ::= REF name 


34 



name 


: := id 
I name id 
I name expr* 

positional-aggregate ::= PAGGR expr* 

unary-op ::= NOT | PLUS | NEG | ABS 

binary-op AND I NAND I OR I NOR | XOR 

| ADD | SUB | MUL | DIV | MOD | REM | EXP 
I CONCAT 

relational-op ::= EQ I NE | LT I LE I GT I GE 
time-unit :FS | PS | NS | US | MS | SEC | MIN | HR 
opt-id ::= e I id 

opt-discrete-range ::= e \ discrete-range 
opt-dotted-name ::= € I dotted-name 
opt-expr ::= € I expr 


5.2.3 Abstract Syntax: Phase 2 

The abstract syntax of Stage 3 VHDL used during Phase 2 translation differs in certain 
respects from that employed by Phase 1, at exactly those points indicated below. 

The abstract syntax transformation occurs at the very end of Phase 1, and just prior to the 
invocation of Phase 2, as described in Section 7. 

The most significant transformations of Phase 1 syntax to that of Phase 2 are: (1) the 
“desugaring” (i.e., reduction to more basic constructs) of concurrent signal assignment 
statements (conditional signal assignment and selected signal assignment) into equivalent 
PROCESS statements; and (2) the disambiguation of REFs into simple references, array refer¬ 
ences, record field accesses (not fully supported by Stage 3 VHDL), and subprogram calls. 


STAGE 3 VHDL ABSTRACT SYNTAX: PHASE 2 
ent-decl ::= ENTITY id decl*i decl * 2 opt-id phasel-hook 
con-stat ::= process-stat 


35 



process-stat :PROCESS id decl* seq-stat* opt-id phasel-hook 

expr ::= f 

I bool-lit 
I bit-lit 
I num-lit 
I time-lit 
I char-lit 
I enum-lit 
I bitstr-lit 
I str-lit 
I ref 

I positional-aggregate 
I type-conversion 
I unary-op expr 
I binary-op expr] expr2 
I relational-op expri expr2 

time-lit ::= TIME constant FS 

enum-lit ::= ENUMLIT id 

ref ::= REF modifier" 1 " 

modifier SREF id + id 
I INDEX expr 
I SELECTOR id 
I PARLIST expr* 

type-conversion ::= TYPECONV expr type-mark 

unary-op ::= NOT | BNOT | PLUS | NEG | ABS | RNEG | RABS 

binary-op ::= AND | NAND | OR | NOR | XOR 

I BAND | BNAND | BOR | BNOR I BXOR 

I ADD | SUB | MUL | DIV | MOD | REM | EXP 

I RPLUS | RMINUS | RTIMES | RDIV I REXPT 

I CONCAT 

relational-op ::= EQ I NE I LT I LE I GT | GE 
I RLT I RLE | RGT | RGE 

The occurrences of phasel-hook in the Phase 2 abstract syntax for ent-decl and process-stat 
point to the Phase 1 abstract syntax for the respective constructs, for the purposes of the 
SDVS VHDL Symbolic Execution Trace Window. 


36 



6 Phase 1: Static Semantic Analysis and Environment Col¬ 
lection 

Now that the necessary background has been established, we are ready to examine the 
formal description of the Stage 3 VHDL translator. 

In this section, an overview of Phase 1 and its relation to Phase 2 will be presented, followed 
by detailed discussions of the environment manipulated by the translator and the Phase 1 
semantic domains and function types, and finally the Phase 1 semantic equations themselves. 


6.1 Overview 

A Stage 3 VHDL hardware description is first parsed according to the Stage 3 VHDL 
concrete grammar, producing an abstract syntax tree that serves as the input to Phase 1 
translation. 

Phase 1 of the translation accomplishes the following. 


• Performs static semantic checks to verify that certain conditions are met, including: 

- Objects, subprograms, packages, and process and loop labels must be declared 
prior to use. 

- Identifiers with the same name cannot be declared in the same local context. 

- References to objects and labels must be proper, e.g. scalar objects must not 
be indexed, array references must have the correct number of indices, and EXIT 
statements must reference a loop label. 

- All components of statements and expressions must have the proper type, e.g. 
expressions used as conditions must be boolean, array indices must be of the 
proper type, operators must receive operands of the correct type, procedure and 
function calls must receive actual parameters of the proper type, function calls 
must return a result of a type appropriate for their use in an expression. 

- Sensitivity lists in PROCESS and WAIT statements must contain signal identifiers. 

— The collection of discrete ranges defining a CASE statement alternative must be 
exhaustive and mutually exclusive. 

- The time delays in the AFTER clause of a signal assignment statement must be 
increasing. 

• Creates a new abstract syntax tree — a transformed version of the original abstract 
syntax tree (used by Phase 1) — that will be more conveniently utilized by Phase 2 
of the translation. 

• Creates and manipulates a tree-structured environment (TSE) that, in the absence of 
errors, is provided to Phase 2 of the translation. 


37 



If the VHDL translator completes Phase 1 without error, then it can proceed with Phase 
2, state delta generation. Phase 2 requires two inputs: the transformed abstract syntax 
tree and the tree-structured environment for the hardware description, both constructed by 
Phase 1. 

The tree-structured environment contains a complete record of the name/attribute associ¬ 
ations corresponding to the hardware description’s declarations, and its structure reflects 
that of the description. Referring to this TSE, Phase 2 incrementally generates and (per 
user proof commands) applies state deltas via symbolic execution and the theories built 
into the Simplifier. 


6.2 Descriptors, Types, and Type Modes 


When a declaration of an identifier is processed by Phase 1, that identifier is bound in 
the TSE to a descriptor, a structured object that contains the attributes of the identifier 
instance associated to it by that declaration. 

At the time a descriptor is created and entered into the TSE, its qid field is set to t. 
The value of the qid field is eventually set to the proper statically uniquely qualified name 
( SUQN ), when such a qualified name makes sense; see Section 8.2.1. These updates to the 
qid fields become possible only once the TSE is fully constructed, i.e., at the very end of 
Phase 1 — or in other words, at the very beginning of Phase 2, the phase in which these 
uniquely qualified names are needed. 

Eight kinds of descriptor are used in Phase 1: object, package, process name, loop name, 
function, procedure, enumeration type element, and type. Their structures are as follows: 


object 


< id, qid, tag, path, exported, type, value, process > 


The id field contains the identifier to which this descriptor is bound, and the qid 
field contains its statically uniquely qualified name (SUQN). The tag field contains 
*OBJECT*. The path field contains the path in the tree-structured environment to 
the component environment in which this instance of the identifier is bound. The ex¬ 
ported field indicates whether the definition of this identifier instance can be exported 
to other environments. A value true (represented by DENOTE symbol tt) indicates 
exportation is permitted, and a value false (represented by DENOTE symbol ff) 
indicates that it is not. This becomes an issue when the declaration whose elabora¬ 
tion created this descriptor was contained in a package specification (exportable) or 
package body (not exportable). 


If the identifier id represents a constant initialized via a static expression, then the 
value field contains the initial value; otherwise it contains *UNDEF* (undefined). 
Array and record references never represent static values in VHDL, so the value field 
of corresponding object descriptors contains *UNDEF*. 

If the identifier id represents a signal, then the label of the first PROCESS statement 
in which id is the target of a signal assignment is entered into the process field, to 
enable the detection of assignments to the signal by multiple processes (disallowed in 
Stage 3 VHDL). 


38 



Finally, the object descriptor’s type field contains the type of the identifier, repre¬ 
sented by a pair < tmode,tdesc >: 


• tmode is the type mode , itself a pair; 
normally, 

tmode = <object-class, ref-mode>, 
where object-class € {CONST, VAR, SIG} 
and ref-mode E {VAL, REF, OUT). 

The tmode indicates, first, whether the object is a constant (object-class = 
CONST), variable (object-class = VAR), or signal (object-class = SIG), 
and second, whether the object is read-only (ref-mode = VAL), read-write 
(ref-mode = REF), or write-only (ref-mode = OUT). 

For technical purposes, it is also occasionally convenient for Phase 1 transla¬ 
tion to manipulate “dummy” type modes of the form < DUMMY, VAL >, 

< DUMMY, OBJ >, < DUMMY, ACC >, < DUMMY, AGR >, and 

< DUMMY, TYP >, as well as “path” type modes of the form < PATH,p > 
where p is a path in the TSE. 

t tdesc is the type descriptor (see below). It gives the object’s basic type , irre¬ 
spective of the type mode. 


To introduce a bit more terminology, a type in which the ref-mode is REF or OUT 
will be called a reference type , while one whose ref-mode is VAL will be called a 
value type. A reference type indicates that the associated object can have its value 
altered (by an assignment, say), as opposed to a value type. 

Finally, the type descriptor d = tdesc is the basic type of the type < tmode, tdesc > 
of which it is the second component. 

package : 

< id, qid, * PACK AGE*, path, exported, pbody > 

The id, qid, path, and exported fields are as above. The tag field contains *PACK- 
AGE*. If this package has a body, the pbody field contains the transformed abstract 
syntax tree of the package body; otherwise it contains e. 


process name : 

< id, qid, +PROCESSNAME+, path > 

The id and path fields are as above. The tag field contains *PROCESSNAME* 
(the process label). The qid field has no relevance here, and contains e. 


loop name : 


< id, qid, *LOOPNAME*, path > 

The id, qid, and path fields are as in a process name. 
*LOOPNAME* (the loop label). 


The tag field contains 


function : 

< id, qid, +FUNCTION*,path, exported, signatures, body, characterizations > 

The id, qid, exported, and path fields are as above. The tag field contains 
♦FUNCTION*. 


39 



The signatures field contains a list of signatures, that is, < pars,rtype > pairs; this 
list will be a singleton unless the function is overloaded. The pars field of a signature 
is a list that indicates the names and types of the function’s formal parameters. Each 
list element is a pair, whose first component is the identifier that denotes the formal 
parameter’s name and whose second component is its type. The rtype (result type) 
field of a signature contains the type of the function’s result for these particular 
parameter types; this type is always a value type . 

The body field of a function descriptor contains the transformed abstract syntax 
tree of the function’s body (including its local declarations) if a body exists, and e 
otherwise. The characterizations field of a function descriptor always contains e 
(see procedure descriptors for a description of this field). 

procedure : 

< id, qid, ^PROCEDURE*, path, exported, signatures, body, characterizations > 

The id, qid, path, exported, signatures, body, and characterizations fields are 
as in the function descriptor. The tag field contains ^PROCEDURE* (procedure). 
Since procedures return no result, all rtype fields in each signature contain the void 
standard value type (see below). 

The characterizations field of a procedure descriptor, unlike that of a function 
descriptor, is potentially nonempty. One of either the body or the characterizations 
must contain e; either a procedure has a body that may be symbolically executed, or 
it has been characterized by a set of state deltas. 

A characterization is a 6-tuple containing the following information: 

• the path to the procedure; 

• the identifier that names the procedure; 

• a list of the identifiers that name the arguments to the procedure; 

• a (possibly empty) precondition that determines under which conditions this 
characterization may be used; 

• a modification list of the names of variables changed by this procedure; and 

• a postcondition that states the effects of the procedure. 

The last three items in the tuple must be given in SDVS internal state delta notation, 
as they form the basis for a state delta that characterizes the actions of the procedure. 

enumeration type element : 

< id, qid, *ENUMELT*, path, exported, type > 

The id field contains the name of an enumeration type element, the tag field is 
*ENUMELT*, and the type field contains the descriptor of the enumeration type. 

type : 

There are six kinds of type descriptor: those for standard types, enumeration types, 
array types, subtypes, integer definition types, and record types. Although record 


40 



types are not actually incorporated in the Stage 3 VHDL language subset, the Stage 
3 VHDL translator contains support for their eventual implementation. 

Each type descriptor has an id field (containing the name of that type), a correspond¬ 
ing qid field, a tag field (indicating the kind of type descriptor), path and exported 
fields (that serve the usual purpose), and additional fields that contain information 
appropriate to the type represented by the descriptor. The detailed structures of the 
type descriptors are as follows: 

standard type : 

< id, qid, tag, path, exported > 

Standard types are those considered to be predeclared; they are always ex- 
portable. In Stage 3 VHDL, the standard types are boolean, bit, integer, real, 
time, character, bitjvector, and string; they cannot be redeclared. 

The id and tag fields denote the following Stage 3 VHDL standard types: 


id = BOOLEAN, 

tag = *BOOL* 

id = BIT, 

tag = *BIT* 

id = UNIVERSAL JNTEGER, 

tag = *INT* 

id = INTEGER, 

tag = *INT* 

id = REAL, 

tag = *REAL* 

id = TIME, 

tag = *TIME* 

id = BITJVECTOR, 

tag = *ARRAYTYPE* 

id .= STRING, 

tag = *ARRAYTYPE* 


For completeness, we also provide void and polymorphic standard types for Stage 
3 VHDL: 

id = VOID, tag = *VOID* 

id = POLY, tag = *POLY* 

Functions are available that look up the type descriptors for the standard types; 
during translation Phase 1, these type descriptors are bound to the type identi¬ 
fiers in the t((STANDARD)) component environment of the TSE t: 

bool-type-desc(t) = t((STANDARD) )(BOOLEAN ) 

bit-type-desc(t) = t((STANDARD) )(BIT ) 

univint-type-desc(t) = t((STANDARD) )(UNIVERSALJNTEGER ) 
int-type-desc(t) = t((STANDARD) )(INTEGER ) 


41 


real-type-desc(t) = t((STANDARD) )(REAL ) 
time-type-desc(t) = t((STANDARD) )(TIME ) 
void-type-desc(t) = t((STANDARD) )(VOID ) 
poly-type-desc(t) = t((STANDARD) )(POLY ) 

In each of the above cases, the type descriptor has the form: 

< id, epsilon, tag, (STANDARD), tt, lb,ub > 

char-type-desc(t) = t((STANDARD) )(CHARACTER ) 

The type descriptor for the CHARACTER type has the form: 

< CHARACTER, epsilon, tENUMTYPE*, (STANDARD), tt, (CHAR 0),(CHAR 127), literals > 


bitvector-type-desc(t) = t((STANDARD) )(BIT_VECTOR ) 

The type descriptor for the BIT.VECTOR type has the form: 

< BITJVECTOR, epsilon, *ARRAYTYPE*, (STANDARD), tt, TO, (NUM 0), epsilon,bittypedesc > 


string-type-desc(t) = t((STANDARD) )(STRING ) 

The type descriptor for the STRING type has the form: 

< STRING,epsilon, *ARRAYTYPE*, (STANDARD), tt, TO, (NUM 1), epsilon, chartypedesc > 

enumeration type : 

< id, qid, *ENUMTYPE*, path, exported, literals > 

The literals field is a nonempty list of identifiers giving the enumeration literals 
(in order) for this type. Both characters and identifiers are admissible enumera¬ 
tion literals in Stage 3 VHDL. 

array type : 

< id, qid, *ARRAYTYPE+, path, exported, direction,lb, ub, elty > 

Every array type has a name; unique names are generated for anonymous ar¬ 
ray types. Arrays in Stage 3 VHDL are one-dimensional , of index type UNI- 
VERSAL.INTEGER. Note that the standard types BIT.VECTOR and 
STRING are array types. 

The direction field contains either TO or DOWNTO, indicating whether the 
indices of the array increase or decrease, respectively. The lb and ub fields 
contain, respectively, abstract syntax trees for expressions that denote the array 
type’s lower and upper bounds. The elty (element type) field contains the de¬ 
scriptor of the type of the array’s elements. The values of the array’s lower and 
upper bounds are not necessarily static; therefore, array bounds-checking gen¬ 
erally cannot be performed in Phase 1, but must be deferred to Phase 2 (“run 
time”), when state deltas are applied (“executed”). 

The following function accepts arguments for the creation of an array type: 


42 


array-type-desc(array-name,qid,path,exported,direction,lower-bound,upper-bound,element-type) 

= < array-name,qid,*ARRAYTYPE* ,path,exported,direction,lower-bound,upper-bound,element-type> 


subtype : 

< id, qid, *SUBTYPE*, path, exported, lb,ub,basetype > 

The lb and ub fields contain, respectively, abstract syntax trees for expressions 
that denote the subtype’s lower and upper bounds. The basetype field contains 
the descriptor of the subtype’s base type. 

integer definition type : 

< id, qid, *INT_TYPE*, path, exported, lb, ub, parenttype > 

The lb and ub fields contain, respectively, abstract syntax trees for expressions 
that denote the integer definition type’s lower and upper bounds. The parent- 
type field contains the descriptor of the integer definition type’s parent type, 
which is always UNIVERSAL-INTEGER. 

record type : 

< id, qid, *RECORDTYPE*, path, exported, components > 

The components field is a nonempty list of triplets; each triplet represents a 
field of this record type. The first element of each triplet is an identifier that 
is this field’s name. The second element is a descriptor representing this field’s 
basic type. The third element either is empty or contains an abstract syntax 
tree for Phase 2 initialization for components of objects declared to be of this 
record type. As noted above, records are not implemented as part of Stage 3 
VHDL, and record types are included simply in preparation for the anticipated 
implementation of records. 


6.2.1 Type and type descriptor predicates 

Predicates are available for distinguishing specific types and type descriptors: 
is-boolean?(type) = is-boolean-tdesc?(tdesc(type)) 
is-boolean-tdesc?(d) = idf(d)= BOOLEAN 


is-bit?(type) = is-bit-tdesc?(tdesc(type)) 
is-bit-tdesc?(d) = idf(d)= BIT 

is-integer?(type) = is-integer-tdesc?(tdesc(type)) 
is-integer-tdesc?(d) = tag(d)G (*INT* *INT_TYPE*) 

is-real?(type) = is-real-tdesc?(tdesc(type)) 


43 



is-real-tdesc?(d) = idf(d)= REAL 


is-time?(type) = is-time-tdesc?(tdesc(type)) 
is-time-tdesc?(d) = idf(d)= TIME 

is-void?(type) = is-void-tdesc?(tdesc(type)) 
is-void-tdesc?(d) = idf(d)= VOID 

is-poly?(type) = is-poly-tdesc?(tdesc(type)) 
is-poly-tdesc?(d) = idf(d)= POLY 

is-character?(type) = is-character-tdesc?(tdesc(type)) 
is-character-tdesc?(d) = idf(d)= CHARACTER 

is-array?(type) = is-array-tdesc?(tdesc(type)) 
is-array-tdesc?(d) = tag(d)= *ARRAYTYPE* 

is-record?(type) = is-record-tdesc?(tdesc(type)) 
is-record-tdesc?(d) = tag(d)= *RECORDTYPE* 

is-bitvector?(type) = is-bitvector-tdesc?(tdesc(type)) 

is-bitvector-tdesc?(d) 

= let idf = idf(d) in 

idf = RIT^VECTOR V (consp(idf)A hd(idf)= BIT_VECTOR ) 

is-string?(type) = is-string-tdesc?(tdesc(type)) 

is-string-tdesc?(d) 

= let idf = idf(d) in 

idf = STRING V (consp(idf)A hd(idf)= STRING ) 

is-const?(type) = object-class(tmode(type))= CONST 
is-var?(type) = object-class(tmode(type))= VAR 
is-sig?(type) — object-class(tmode(type))= SIG 


44 



6.2.2 Additional primitive accessors and predicates 

Certain primitive functions can be applied to descriptors. For each kind of descriptor and 
field there exists an access function, ordinarily with the same name as the field (the only 
exception being idf instead of id). When applied to a descriptor of the proper kind, the 
access function extracts the contents of that descriptor’s corresponding field. For example, 
if d is an object descriptor, then tag(d) = *OBJECT*. 

If d is any descriptor, then the fully qualified name of the corresponding identifier instance 
is returned by function namef: 

namef(d) = $(path(d))(idf(d)) 

Defined below are the descriptor component access functions, a few related constructor and 
access functions, and some convenient additional predicates. 

idf(d) = hd(d) 

qid(d) = hd(tl(d)) 

tag(d) = hd(tl(tl(d))) 

path(d) = hd(tl(tl(tl(d)))) 

exported(d) = hd(tl(tl(tl(tl(d))))) 

type-tick-low(d) = hd(tl(tl(tl(tl(tl(d)))))) 

type-tick-high(d) = hd( tl(tl(tl(tl( tl(tl(d))))))) 

base-type(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

parent-type(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

literals(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))»))) 

pbody(d) = hd(tl(tl(tl(tl(tl(d)))))) 

type(d) = hd(tl(tl(tl(tl(tl(d)))))) 

value(d) = hd(tl(tl(tl(tl(tl(tl(d))))))) 

process(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

signatures(d) = hd(tl(tl(tl(tl(tl(d)))))) 

body(d) = hd(tl(tl(tl(tl(tl(tl(d)))))» 

characterizations(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

direction(d) = hd(tl(tl(tl(tl(tl(d)))))) 

lb(d) = hd(tl(tl(tl(tl(tl(tl(d))))))) 

ub(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 


45 



elty(d) = hd(tl(tl(tl(tl(tl(tl(tl(tl(d))))))))) 
components(d) = hd(tl(tl(tl(tl(tl(d)))))) 

pars(signature) = hd(signature) 
rtype(signature) = hd(tl(signature)) 

get-base-type(d) = (tag(d)= *SUBTYPE* -► base-type(d), d) 
get-parent-type(d) 

= (tag(d)G (*INT_TYPE* *DERIVEDJTYPE*) - parent-type^), 
error(cat(“Wot a derived type: ”)(d))) 

mk-type(tmode)(tdesc) = (tmode,tdesc) 
tmode(type) = hd(type) 
tdesc(type) = hd(tl(type)) 

mk-tmode(object-class) (ref-mode) = (object-class,ref-mode) 
object-class(tmode) — hd(tmode) 
ref-mode(tmode) = hd(tl(tmode)) 

is-const?(type) — object-class(tmode(type))= CONST 
is-var?(type) = object-class(tmode(type))= VAR 
is-sig?(type) = object-class(tmode(type))= SIG 

is-readable?(type) = ref-mode(tmode(type))E (VAL REF) 
is-writable?(type) = ref-mode(tmode(type))E (REF OUT) 

is-ref?(expr) = hd(expr)= REF 
is-paggr?(expr) = hd(expr)= PAGGR 

is-unary-op?(op) = op E (NOT PLUS NEG ABS) 
is-binary-op?(op) 

= op E (AND NAND OR NOR XOR ADD SUB MUL DIV MOD REM EXP CONCAT) 
is-relational-op?(op) = op E (EQ NE LT LE GT GE) 


46 



6.3 Special-Purpose Environment Components and Functions 

Certain component environments r of the tree-structured environment (TSE) part of the 
translation state have special identifier-like names that are bound to values specific to that 
environment’s associated program unit (design file, package, entity, architecture, process, 
procedure, function, or loop): 

*UNIT* : 

r(*UNIT*) contains a tag that identifies what kind of program unit led to the cre¬ 
ation of r. These tags are *DESIGN-FILE* (design file), *PACKAGE* (package), 
♦ENTITY* (entity), *ARCHITECTURE* (architecture), *PROCESS* (pro¬ 
cess), *PROCEDURE* (procedure), *FUNCTION* (function), and *LOOP* 
(loop). These tags are used to locate the innermost instance of a specific kind of 
environment (such as one associated with a process) on the current lookup path in 
the TSE. 

*LAB* : 

When the tag of r(*UNIT*) is * ARCHITECTURE*, the value bound to r(*LAB*) 
contains an identifier list of all the process labels declared in the program unit. When 
the tag of r(*UNIT*) is *PROCESS*, *PROCEDURE*, *FUNCTION*, or 
♦LOOP*, the value bound to r(*LAB*) contains an identifier list of all the loop 
labels declared in the program unit. These lists are used to ensure that the identifiers 
serving as process and loop labels are distinct in (the top-level scope of) each program 
unit. 

♦USED* : 

The environment corresponding to any program unit admitting USE clauses in its 
declarative part has a *USED* component. In this case, r(*USED*) is a list repre¬ 
senting the set of fully qualified names of packages named in USE clauses appearing in 
that declarative part, omitting the qualified names of packages that textually enclose 
those USE clauses. In order to ensure that the TSE used in Phase 2 of the Stage 3 
VHDL translator can remain fixed as that generated by Phase 1, a slight restriction 
is imposed on the concrete syntax of Stage 3 VHDL. This restriction requires that 
all of the USE clauses in a declarative part appear only at the end of that declarative 
part. This will be discussed more fully later. 

*IMPT* : 

Whenever a program unit has a *USED* component, it also has a *IMPT* com¬ 
ponent. r(*IMPT*) is a list of the fully qualified names of those items that can be 
imported into the program unit’s environment by the elaboration of the USE clauses 
in its declarative part. Consequently, no two of these fully qualified names can have 
the same last identifier (unqualified name), nor can the last identifier of any of these 
fully qualified names be the same as an identifier whose (local) declaration appears in 
this program unit’s declarative part. 

*SENS* : 

When the tag of r(*UNIT*) is *PROCESS*, the value bound to r(*SENS*) con- 


47 


tains a list of the transformed abstract syntax trees of the refs appearing in that pro¬ 
cess’ sensitivity list. Phase 1 translation of a WAIT statement occurring in a PROCESS 
statement checks to make sure this *SENS* list is empty; otherwise, the WAIT occurs 
illegally in a process with a sensitivity list. 


Special Phase 1 Functions 

Three special-purpose Phase 1 functions defined by SDVS are set-difference, new-array- 
type-name, and delete-duplicates; these are provided by SDVS because of the difficulty 
of writing their definitions in the DENOTE language (DL). 

Function set-difference returns the set difference of two lists. Function new-array- 
type-name returns a new unique name for an anonymous array type. Function delete- 
duplicates destructively deletes duplicate items from a list. 


Error Reporting 

Phase 1 errors are reported by three SDVS functions: error, which takes a string-valued er¬ 
ror message; error-pp, which takes a string-valued error message and an additional VHDL 
abstract syntax subtree to be pretty-printed; and cat, which makes a string from its (vari¬ 
able number of) arguments, each of which is made into a string. 

6.4 Phase 1 Semantic Domains and Functions 

The formal description of Phase 1 translation consists of semantic domains and semantic 
functions , the latter being functions from syntactic to semantic domains. Compound se¬ 
mantic domains are defined in terms of primitive semantic domains. Similarly, primitive 
semantic functions are unspecified (their definitions being understood implicitly) and the 
remaining semantic functions are defined (by syntactic cases) via semantic equations. 

The principal Phase 1 semantic functions (and corresponding Stage 3 VHDL language 
constructs for which they perform static analysis) are: DFT (design files), ENT (entity 
declarations), ART (architecture bodies), PDT (port declarations), DT (declarations), 
CST (concurrent statements), SLT (sensitivity lists), SST (sequential statements), AT 
(case alternatives), DRT (discrete ranges), WT (waveforms), TRT (transactions), MET 
(reference lists), ET and RT (expressions), OT1 (unary operators), OT2 (binary and 
relational operators), B (bit literals), and N (numeric literals). 

Each of the principal semantic functions requires an appropriate syntactic argument — an 
abstract syntactic object (tree) generated by the Stage 3 VHDL language parser. Most of 
the semantic functions take (at least) the following additional arguments: 


• a path , indicating the currently visible portion of the (partially constructed) tree- 
structured environment; 

• a continuation , specifying which Phase 1 semantic function to invoke next; and 


48 


• a (partially constructed) TSE, containing the information gathered from declarations 
previously elaborated and checked. 

In the absence of errors, the Phase 1 semantic functions update the TSE. Moreover, ET 
and RT also construct a pair consisting of an expression’s type and its static value. The 
type is either a value type or a reference type ; see Section 6.2. Only an expression with a 
reference type may be the target of an assignment operation. 

An expression’s static value is *UNDEF* (“undefined”) unless it is a static expression, in 
which case its static value is determined as follows. A static expression is: 


• a boolean, bit, numeric, or character literal: the static value is the value of the 
corresponding constant; 

• an identifier explicitly declared as a scalar constant and initialized by a static expres¬ 
sion: the static value is the static value of the initialization expression; 

• an operator applied to operands that are static expressions: the static value is deter¬ 
mined by the semantics of the operator and the static value of the operands; 

• a static expression enclosed in parentheses: the static value is the static value of the 
enclosed static expression. 

Note that a subscripted array reference, even if the subscript is a static expression and the 
array was declared as a constant initialized with a list of static expressions, is not a static 
expression. (The same is true for a selected record component.) 


6.4.1 Phase 1 Semantic Domains 


The semantic domains and function types for Phase 1 of the Stage 3 VHDL translator are 
as follows. 

Primitive Semantic Domains 


Bool = 
Bit 

Char = 
n : N = 

{FALSE, TRUE} 

{0, 1} 

{(CHAR 0), ..., (CHAR 127)} 

{ 0 , 1 , 2 , ...} 

id : Id 
Sysld 


t : TEnv 
d : Desc 

sd : SD 



boolean constants 
bit constants 

character constants (ASCII-128 representations) 
numeric constants (natural numbers) 

identifiers 

system-generated identifiers (disjoint from Id) 

tree-structured environments (TSEs) 
descriptors (see Section 6.2) 

state deltas 


49 



Assert 

Error 

Compound Semantic Domains 


SDVS Simplifier assertions 
error messages 


elbl : Elbl = Id + Sysld 
p, q: Path = Elbl* 
qname: Name = Elbl (. Elbl) 

d : Dv = Desc 


TSE edge labels 
TSE paths 
qualified names 

denotable values (descriptors) 
environments 


r : Env = Id -+ (Dv + {*UNBOUND*}) 


Tmode = {PATH} x Id* + type modes 

({CONST, VAR, SIG, DUMMY} x 
{VAL, OUT, REF, OBJ, ACC, TYP}) 


w : Type = Tmode x Desc types 

e : Value values 


h : CSet = P(Bool) + P(Char) + P,(N) 
+ {INT} + {ENUM} 


case selection sets [P(«) denotes “powerset of” 
and P/(«) denotes “set of finite subsets of”] 


u : TDc = TEnv —► Ans 
c : TSc = TDc 

k : TEc = (Type x Value) -> TSc 
h : TMc = (Type* x Value*) —* TSc 
y : TAc = CSet -► TSc 
v : TTc = Type —► Ans 
z : Desc —> TDc 


declaration & concurrent statement continuations 

sequential statement continuations 

expression continuations 

reference list continuations 

case alternative continuations 

type continuations 

descriptor continuations 


Ans = (SD + Assert)* + Error 


final answers 


6.4.2 Phase 1 Semantic Functions 


The semantic functions for Phase 1 of the Stage 3 VHDL translator are as follows. 


DFT : Design —► Ans 


design file static semantics 


ENT : Ent —> Path —► TDc —► TDc entity declaration static semantics 

ART : Arch —> Path —► TDc TDc architecture body static semantics 


PDT : PDec* —► Path — ► Bool — > TDc —► TDc port declaration static semantics 
DT : Dec* —► Path — > Bool —> TDc —► TDc declaration static semantics 


50 



CST : 
SLT : 

SST : 

AT : 
DRT : 

WT : 
TRT : 

MET 
ET : 
RT : 
OT1 : 
OT2 : 

B : 

N : 


CStat* -► Path — TDc -*• TDc 
Ref Path -*• TDc -* TDc 

SStat* -*• Path -> TSc -+■ TSc 

Alt* — Type -► Path -* TAc — TSc 
Drg —+ Type —> Path —+ TAc —*• TSc 

Wave —♦ Path —> TEc —► TSc 
Trans* —► Path —► TEc —► TSc 

: Ref* Path -*■ TMc — TSc 
Expr — Path -*■ TEc -* TSc 
Expr Path — TEc -» TSc 
Uop -► TEc -*• TEc 
Bop —>• TEc —> (Type x Value) —*• TEc 

BitLit -+ Bit 
NumLit -» N 


concurrent statement static semantics 
sensitivity list static semantics 

sequential statement static semantics 

case alternative static semantics 
discrete range static semantics 

waveform static semantics 
transaction static semantics 

reference list static semantics 

expression static semantics 

expression static semantics 

unary operator static semantics 

binary, relational operator static semantics 

bit values of bit literals (primitive) 
integer values of numeric literals (primitive) 


51 


6.5 Phase 1 Semantic Equations 


6.5.1 Stage 3 VHDL Design Files 

(DFTl) DFT [ DESIGN-FILE id pkg-decl* pkg-body* use-clause* ent-decl arch-body J 
= let t 0 = mk-initial-tse() 

and p 0 = %(e)(id) in 
let idi = hd(tl(ent-decl)) in 
let ti = enter-standard(to) 
and pi = %(p 0 )(idi) in 

let t 2 = enter(ti)(e)(id)(<e,*DESIGN-FILE* ,e,tt>) in 
let t 3 = enter(extend(t 2 )(£)(id))(p 0 )(*UNIT* )(<£ *DESIGN-FILE* >) in 
let t 4 = enter(t 3 )(p 0 )(*LAB* )(<e,e>) in 
let t 5 = enter(t 4 )(p 0 )(*USED* )(<£,£>) in 
let t 6 = enter(t 5 )(p 0 )(*IMPT* )(<e,e,e>) in 
enter-objects 

((VHDLTIME ,VHDLTIME_PREVIOUS )) 

(<e,*OBJECT* |Cj tt, 

((DUMMY ,VAL ),vhdltime-type-desc(t 0 )),*UNDEF* ,e>)(t 6 )(e)(u) 
where 

u = At.let use-clause = (USE ,((STANDARD ,ALL ))) in 
DT [[ use-clause ] (e)(tt)(ui)(t) 
where ui = At. DT l pkg-decl* ] (p 0 )(tt)(u 2 )(t) 
where u 2 = At.DT [[ pkg-body* } (p 0 )(tt)(u 3 )(t) 
where u 3 = At. DT [ use-clause* | (p 0 )(tt)(u 4 )(t) 
where u 4 = At. ENT [[ ent-decl ] (p 0 )(u 5 )(t) 
where u 5 = At. ART [[ arch-body ]] (pi)(u 6 )(t) 
where 

u 6 = At.let unit = DFX [ design-file ] (t) in 
phase2(unit)(t) 


enter-standard(t) 

= let ti = enter-package(t)(£)(STANDARD ) in 
let t 2 = enter-package(ti)(5)(TEXTIO ) in 
let t 3 — enter(t 2 )(e)(*USED* )(<e,e>) in 
let t 4 = enter(t 3 )(e)(*IMPT* )(<e,£,e>) in 
let t 5 = enter-predefined(t 4 )( (STANDARD) ) in 

t5 


enter-package(t)(p)(id) 

= let pi = %(p)(id) in 

let package-desc = <e,*PACKAGE* ,p,tt,e> in 
let ti = enter(t)(p)(id)(package-desc) in 
let t 2 = enter(extend(ti )(p)(id))(pi )(*UNIT* )(<e ^PACKAGE* >) in 
let t 3 = enter(t 2 )(pi )(*USED* )(<e,e>) in 
let t 4 = enter(t 3 )(pi)(*IMPT* )(<£,£,£>) in 
t 4 


enter-predefined(t)(p) 

= let t, = enter(t)(p)(BOOLEAN ){<e *BOOL* ,(STANDARD) ,tt,FALSE ,TRUE >) in 
let t 2 = enter 

(t,)(p)(BIT) 

(<e,*BIT* ,(STANDARD) ,tt,mk-bit-simp-symbol(0), 
mk-bit-simp-symbol(l)>) in 

let t 3 = enter(t 2 )(p)(UNIVERSAL-INTEGER )(<e,*INT* ,(STANDARD) ,tt,e,e>) in 
let t 4 = enter(t 3 )(p)(INTEGER)(<£,*INT* .(STANDARD) ,tt,e,e>) in 
let t 5 = enter(t 4 )(p)(REAL )(<e ,*REAL* .(STANDARD) ,«,£,£>) in 


52 


let t 6 = enter(t 5 )(p)(TIME )(<e,*TIME* .(STANDARD) ,tt,e,e>) in 
let t 7 = enter(t 6 )(p)(VHDLTIME )(<e,*VHDLTIME* .(STANDARD) ,tt,e,e>) in 
let t 8 = enter(t 7 )(p)(VOID )(<e,*VOID* .(STANDARD) ,tt,e,e>) in 
let t 9 = enter(t 8 )(p)(POLY )(<e,*POLY* .(STANDARD) ,tt.e,£>) in 
let tiO = enter 

(t 9 )(p)(BIT_VECTOR ) 

(tl(array-type-desc 

(BIT.VECTOR )(e)((STANDARD) )(tt)(TO )((NUM 0) )(e) 
(bit-type-desc(t 8 )))) in 
let til = enter-characters(tiO)(p) in 
let ti 2 = enter-string(ti l)(p) in 
ti2 

enter-characters(t)(p) 

= let id + = gen-characters(0)(127) in 

let field-values! = <e,*ENUMTYPE* ,p,tt,hd(id + ),last(id + ),id + > in 
let char-type-desc = cons(CHARACTER ,field-values i) in 
let field-values 2 = <£,*ENUMELT* ,p,tt,mk-type((CONST VAL) ) (char-type-desc) > in 
enter-objects(id + ) (field-values 2 )(t)(p)(u) 
where u = Ati .enter(ti)(p)(CHARACTER )(field-valuesi) 

enter-string(t)(p) 

= let expr = (NUM 1) in 

let string-type-desc = array-type-desc 

(STRING )(e)(p)(tt)(TO )(second(EX [ expr ] (p)(t)))(fi) 
(char-type-desc(t)) in 
enter(t)(p)(STRING )(tl(string-type-desc)) 


gen-characters(start) (finish) 

= (start = finish —* ((CHAR ,finish)), 

cons((CHAR ,start),gen-characters(start-l-l)(finish))) 


enter-objects(id* )(field-values)(t)(p)(u) 

= (null(id*)—► u(t), 
let id = hd(id*) in 

(t(p)(id)^ ^UNBOUND* —► error(cat( “Duplicate object declaration: ”)($(p) 

(id))), 

let ti = enter(t)(p)(id)(field-values) in 
enter-objects(tl(id*))(field-values)(ti )(p)(u))) 


6.5*2 Entity Declarations 

(ENTl) ENT [ ENTITY id port-decl* decP opt-id ] (p)(u)(t) 

= (-mull (opt-id) A opt-id ^ id 
—+ error 

(cat(“Entity declaration ”)(id) 

( tt ended with incorrect identifier: ”)(opt-id)), 
let ti = enter(t)(p)(id)(<e,*ENTITY* ,e,ff>) in 
let pi = %(p)(id) in 

let t 2 = enter(extend(ti)(p)(id))(pi)(*UNIT* )(<£,*ENTITY* >) in 
let t 3 = enter(t 2 )(pi)(*LAB* )(<e,e>) in 
let t 4 = enter(t 3 )(pi)(*USED* )(<e,e>) in 
let ts = enter(t 4 )(pi)(*IMPT* )(<e,e,e>) in 
PDT [ port-decl* J (pi)(tt)(ui)(t 5 ) 
where ui = At. DT [ decP J (pi)(tt)(u)(t)) 


53 



6.5.3 Architecture Bodies 


(ART1) ART l ARCHITECTURE idi id 2 decl* con-stat* opt-id ] (p)(u)(t) 

= (-mull(opt-id)A opt-id ^ idi 
—► error 

(cat(“Architecture body ”)(idi) 

(“ ended with incorrect identifier ”)(opt-id)), 
let d = lookup(t)(p)(id2) in 
(d = ^UNBOUND* V tag(d)^ *ENTITY* 

—+ error(cat(“No entity ”)(ids)(“ for architecture body ”)(idi)), 
let pi = %(p)(idi) in 

let t! = enter(t)(p)(idi)(<e^ARCHITECTURE* ,p,ff>) in 
let t 2 = enter(extend(ti)(p)(idi))(pi)(*UNIT* )(<e ^ARCHITECTURE* >) in 
let t 3 = enter(t 2 )(pi )(*LAB* )(<e,e>) in 
let t 4 = enter(t 3 )(pi )(*USED* )(<e,e>) in 
let t 5 = enter(t 4 )(pi)(*IMPT* )(<e,e,£>) in 
DT[ded* 1 ( Pl )(tt)( Ul )(t 5 ) 
where ui = At 6 .CST [ con-stat* | (pi)(u)(t 6 ))) 


6.5.4 Port Declarations 

(PDTO) PDT l e ] (p)(vis)(u)(t) = u(t) 

(PDTl) PDT [ port-decl port-decl* ] (p)(vis)(u)(t) 

= PDT [ port-decl ] (p)(vis)(ux )(t) 

where ui = At. PDT [port-decl* ] (p)(vis)(u)(t) 


The elaboration and checking of a sequence of port declarations proceeds from the first to 
the last declaration in the sequence. 

(PDT2) PDT [[ DEC PORT id + mode type-mark opt-expr ] (p)(vis)(u)(t) 

= lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let type = (case mode 

IN - mk-type((SIG VAL) )(d), 

OUT mk-type((SIG OUT) )(d), 

(INOUT ,BUFFER ) - mk-type((SIG REF) )(d), 

OTHERWISE 
—► error 

(cat(“Illegal mode in port declaration: ”) 

(port-decl))) in 

process-dec(id + )(type)(opt-expr)(p)(vis)(u)(t) 


Refer to the discussion following semantic equation DT5 in Section 6.5.5. 

(PDT3) PDT [ SLCDEC PORT id + mode slice-name opt-expr ] (p)(vis)(u)(t) 

= let (type-mark,discrete-range) = slice-name in 
lookup- type(type-mark)(p)(z)(t) 
where 

z = Ad.let type = (case mode 

IN — mk-type((SIG VAL) )(d), 

OUT — mk-type((SIG OUT) )(d), 

(INOUT ,BUFFER ) — mk-type((SIG REF) )(d), 


54 



OTHERWISE 

—► error 

(cat(“Illegal mode in port declaration: ”) 
(port-decl))) in 

process-slcdec 

(id + )(type)(discrete-range)(opt-expr)(p)(vis)(u)(t) 

Refer to the discussion following semantic equation DT6 in Section 6.5.5. 


6.5.5 Declarations 

(DTO) DT | e J (p)(vis)(u)(t) = u(t) 

(DTI) DT l decl decl* J (p)(vis)(u)(t) 

= DT l decl ] (p)(vis)(ui )(t) 

where ui = At.DT [ decl* ] (p)(vis)(u)(t) 

(DT2) DT [ pkg-decl pkg-decl* ] (p)(vis)(u)(t) 

= DT I pkg-decl ] (p)(vis)(ui )(t) 

where ui — At. DT [[ pkg-decl* ] (p)(vis)(u)(t) 

(DT3) DT [ pkg-body pkg-body* ] (p)(vis)(u)(t) 

= DT | pkg-body 1 (p)(vis)(ui )(t) 

where ui = At. DT |[ pkg-body* ]] (p)(vis)(u)(t) 

(DT4) DT U use-clause use-clause* | (p)(vis)(u)(t) 

= DT [ use-clause J (p)(vis)(ui )(t) 

where ui = At. DT [[ use-clause* J (p)(vis)(u)(t) 


The elaboration and checking of a sequence of declarations proceeds from the first to the 
last declaration in the sequence. 

(DT5) DT [ DEC object-class id + type-mark opt-expr ] (p)(vis)(u)(t) 

= let q = find-progunit-env(t)(p) in 
let d = t(q)(*UNIT* ) in 
let tg = tag(d) in 
(case object-class 

(CONST ^YSGEN ) —► lookup-type(type-mark)(p)(z)(t), 

VAR 

—v (case tg 

(♦PACKAGE* *ENTITY* ^ARCHITECTURE* ) 

—► error 

(cat(“Illegal VARIABLE declaration in ”)(tg)(“ context: ”) 

(decl)), 

OTHERWISE —*• lookup-type(type-mark)(p)(z)(t)), 

SIG 

—*• (case tg 

(♦PROCESS* ,*PROCEDURE* ,*FUNCTION* ) 

—+ error 

(cat(“Illegal SIGNAL declaration in ”)(tg)(“ context: ”) 

(decl)), 

OTHERWISE —► lookup-type(type-mark)(p)(z)(t)), 

OTHERWISE —► error 

(cat(“Illegal object class in declaration: ”)(decl))) 

where 

z = Ad.let type = (object-class = CONST —+ mk-type((CONST VAL) )(d), 
mk-type(mk-tmode(object-class)(REF ))(d)) in 
process-dec(id + )(type)(opt-expr)(p)(vis)(u)(t) 


55 


find-progunit-env(t)(p) 

= (t(p)(*UNIT* )? UNBOUND* — p, 

(null(p)—♦ error(“No program unit ??! ”), 
find-progunit-env(t)(rest(p)))) 

lookup-type(id*)(p)(z)(t) 

= (null(id*) —► z(void-type-desc(t)), 
name-type(id*)(e)(p)(t)(v) 
where 

v = Aw.(second(tmode(w))= TYP —+ z(tdesc(w)), 

error(cat( u Not a type: ”)(namef(tdesc(w)))))) 

name-type(name)(w)(p)(t)(v) 

= (null(w) 

—► let wj = lookup2(t)(p)(e)(hd(name)) in 

(wi = ^UNBOUND* —► error (cat (“Unbound identifier: ”)($(p)(hd(name)))), 
let tm = tmode(wi) 

and d = tdesc(wi) in 

(second(tm)G (OBJ TYP) —► name-type(tl(name))(wi)(p)(t)(v), 
hd(tm)= PATH 

—* (-»validate-access(name)(wi )(second(tm)) 

—► error(cat(“Illegal access via: ”)(namef(d))), 
name-type(tl(name))(((PATH ,tl(second(tm))),d))(p)(t)(v)), 
error 

(cat(“Shouldn’t happen in auxiliary semantic function NAME-TYPE: ”) 

( w i)))). 

let d = tdesc(w) in 
let tg = tag(d) in 
(null(name) 

— (tg G (^PROCEDURE* ^FUNCTION*) 

—► (null(pars(hd(signatures(d))))—► v(extract-rtype(d)), 

error(cat(“Missing subprogram arguments: ”)(namef(d)))), 
v(w)), 

let x = hd(name) 

and tm — tmode(w) in 
(consp(x) 

—► (second(tm)= TYP 
—*• (null(tl(x)) 

—► name-type(tl(name))(((DUMMY ,VAL ),d))(p)(t)(v), 
error 

(cat(“Explicit conversion of multiple expressions to type: ”) 
(namef(d)))), 
list-type(x)(p)(t)(vv) 
where 

vv — AwJ\((second(tm)= OBJ A is-array?(type(d))) 

V (second(tm)G (REF VAL) A is-array-tdesc?(d)) 

—► (length(x)> 1 
—♦ error 

(cat(“Too many array indices for: ”)(namef 

(«*))), 

(is-integer-tdesc?(get-base-type(tdesc(hd(w*)))) 

— name-type 

(tl(name)) 

((second(tm)= OBJ 
—► mk-type 

(tmode(type(d)))(elty(tdesc(type(d)))), 

mk-type(tm)(elty(d))))(p)(t)(v), 


56 



error 

(cat(“Non-integer array index for: ”)(namef 

(<*))))), 

tg e (^PROCEDURE* *FUNCTION*) 

—► let rtype = compatible-signatures^^ )(signatures(d)) in 
(null(rtype) 

—► error 

(cat(“Incompatible parameter types for: ”) 

(namef(d))), 

name-type(tl(name))(rtype)(p)(t)(v)), 
error(cat(“Cannot have an argument list: ”)(namef 

(<!))))), 

((second(tm)= OBJ A is-record?(type(d))) 

V (second(tm)G (REF VAL) A is-record-tdesc?(d)) 

—+ let di = (second(tm)= OBJ —► tdesc(type(d)), d) in 
let d 2 = lookup-record-field(components(di ))(x) in 
(d 2 = *UNBOUND* error (cat (“Unknown record field: ”)(x)), 
let tmm — (second(tm)= OBJ —► tmode(type(d)), tm) in 

name-type(tl(name))(mk-type(tmm)(d 2 ))(p)(t)(v)), 

second(tm)^ OBJ V second(tm)^ TYP 

—► let wi = lookup-local(x)(%(path(d))(idf(d)))(p)(t) in 

( Wl = *UNBOUND* 

—♦ error(cat( “Unknown identifier: ”)($(%(path(d))(idf(d)))(x))), 
second(tmode(wi))/ ACC —► name-type(tl(name))(wi)(p)(t)(v), 

hd(tm)= PATH 

—♦ (-»null(tl(name))A -«validate-access(name)(wi )(second(tm)) 

—► error(cat(“Illegal access via: ”)(namef(tdesc(wi)))), 
name-type 

(tl(name))(((PATH ,tl(second(tm))),tdesc(wi )))(p)(t) 

(v)), 

error 

(cat(“Shouldn’t happen in auxiliary semantic function NAME-TYPE: ”) 

( w 0))> 

error(cat(“Illegal access via: ”)(namef(d))))))) 

lookup2(t)(p)(q)(id) 

= let d = t(p)(id) in 
(d = *UNBOUND* 

(-inull(p)—► lookup2(t)(rest(p))(cons(last(p),q))(id), ^UNBOUND* ), 

(case tag(d) 

(♦OBJECT* ,*ENUMELT* ) — ((DUMMY ,OBJ ),d), 

(♦PACKAGE* ,*PROCESS* ,*PROCEDURE* ,*FUNCTION* , 
♦LOOPNAME* *PROCESSNAME* ) 

- ((PATH ,q),d), 

OTHERWISE — ((DUMMY ,TYP ),d))) 

validate-access(name)(w)(q) 

= let tg = tag(tdesc(w)) in 

(tg G (+PROCEDURE* *FUNCTION*) 

A (-«null(tl(name))A -«consp(hd(tl(name)))) 

—► -mull(q)A hd(name)= hd(q), 
tt) 

list-type(expr* )(p)(t)(vv) 

= (null(expr*)—+ vv(e), 

let expr = hd(expr*) in 
ET )[expr ] (p)(k)(t) 


57 



where 
k = A(w,e),t. 

(second(tmode(w))= ACC 

error(cat( “Non-value (an access): ”)(namef(tdesc(w)))(expr)), 
list-type(tl(expr*))(p)(t)(Aw*.vv(cons(w,w*))))) 

lookup-Iocal(id) (definition-path) (occurrence-path) (t) 

= let d = t(definition-path)(id) in 

(d = ^UNBOUND* — ^UNBOUND* , 
let tg = tag(d) in 

(tg G (*LOOPNAME* *PROCESSNAME*) -4 ((DUMMY ,ACC ),d), 

(prefix-path(definition-path)(occurrence-path)V exported(d) 

—► (case tg 

(*OBJECT* ,*ENUMELT* ) - ((DUMMY ,OBJ ),d), 

(^PACKAGE* *PROCESS* ,*PROCEDURE* ,*FUNCTION* ) — ((DUMMY ,ACC ),d), 
OTHERWISE -+ ((DUMMY ,TYP ),d)), 

♦UNBOUND* ))) 

compatible-signatures( types) (signatures) 

= (null(signatures)—► e, 

let signature = hd(signatures) in 
(compatible-par-types(types)(extract-par-types(pars(signature))) 

—+ rtype(signature), 

compatible-signatures(types)(tl(signatures)))) 

compatible-par-types(actuais)(formals) 

= (length(actuals)^ length(formals)—> fF, 

Iength(actuals)= 0 —tt, 
let wi = hd(actuals) 

and w 2 = hd(formals) in 
(match-types(tdesc(wi),tdesc(w 2 )) 

—► let mi = ref-mode(tmode(wi)) 

and m 2 = ref-mode(tmode(w 2 )) in 

(mi = REF V mi = m 2 —► compatible-par-types(tl(actuals))(tl(formals)), fF), 
fF)) 

extract-par-types(pars) 

= (null(pars)—► e, cons(second(hd(pars)),extract-par-types(tl(pars)))) 
extract-rtype(d) 

= let signature = hd(signatures(d)) in 
rtype(signature) 

lookup-record-field(comp* )(id) 

= (null(comp*)— ^UNBOUND* , 
let (x,d) = hd(comp*) in 
(x = id —► d, lookup-record-field(tl(comp*))(id))) 

process-dec(id + )(w)(opt-expr)(p)(vis)(u)(t) 

= (null(opt-expr) 

—* (is-const?(w)~► error(cat(“Uninitialized constant: ”)($(p)(hd(id + )))), 
enter-objects(id + )(<e,*OBJECT* ,p, vis,w,*UNDEF* ,£>)(t)(p)(u)), 
let expr = opt-expr in 
R£[[exprJ(p)(k)(t) 
where 

k = A(wi ,e),t. 

let d = tdesc(w) 


58 



and di = tdesc(wi) in 
(match-types(d,di) 

—► let init-val = ((is-sysgen?(w)V is-const?(w)) 

A -»(is-array?(w)V is-record?(w)) 


e, 


*UNDEF* ) in 

enter-objects(id + )(<e,*OBJECT* ,p,vis,w,init-val,e>)(t)(p)(u), 
error(cat(“Initialization type mismatch: ” )(d)(di)))) 


match-types(di ,d 2 ) 

= (case tag(di) 

(*BOOL* *BIT* ,*REAL* *TIME* *ENUMTYPE* ) di = get-base-type(d 2 ), 
(*INT* *INT_TYPE* ) 

—► is-integer-tdesc?(get-base-type(d 2 )) 

A match-integer-types(di )(get-base-type(d 2 )), 

*SUBTYPE* —► match-types(get-base-type(di ),get-base-type(d 2 )), 

*ARRAYTYPE* 

—► tag(d 2 )= *ARRAYTYPE* A match-array-type-names(di ,d 2 ), 

*RECORDTYPE* 

— tag(d 2 )= *RECORDTYPE* 

A null(set-difFerence(hlter-components(type(di )))(filter-components(type(d 2 )))), 
OTHERWISE —► match-type-names(idf(di),idf(d 2 ))) 


match-integer-types(di ,d 2 ) 

= idf(di)= UNIVERSAL-INTEGER V idf(d 2 )= UNIVERSAL-INTEGER 

get-base-type(d) = (tag(d)= *SUBTYPE* — base-type(d), d) 

match-array-type-names(di ,d 2 ) 

= let idfi = hd(di) 

and idf 2 = hd(d 2 ) in 

(consp(idfi )A consp(idf 2 )—► match-type-names(hd(idfi ),hd(idf 2 )), 
consp(idfi)—+ match-type-names(hd(idfi ),idf 2 ), 
consp(idf 2 )-+ match-type-names(idfi ,hd(idf 2 )), 
match-type-names(idfi ,idf 2 )) 

match-type-names(idi ,id 2 ) 

= idi == * ANONYMOUS* V id 2 = *ANONYMOUS* 


array-size (d) 

= (ub(d)A lb(d) 

—► let lbaund = hd(tl(lb(d))) 

and ubound = hd(tl(ub(d))) in 
(ubound—lbound)-fl> 

- 1 ) 


filter-components(components) 

= (null(components)—► e, 

let component = hd(components) in 
cons((hd(component),second(component)), 
filter-components(tl(components)))) 


An object declaration declares a list of identifiers to be of the type given by the type-mark, 
which must be the name of a type that has already been entered in the visible part of the 
TSE. The identifiers must be distinct. The first of these identifiers is used in error messages. 


59 



If the identifiers are being declared as constants but no initialization expression is present, 
then an UNINITIALIZED-CONSTANT error is reported. If constants are being declared, 
then their type is a value type ; variables and signals have reference types. If variables 
or signals are being declared without an initialization expression, then the identifiers are 
entered into the TSE with an undefined initial value *UNDEF* by the function enter- 
objects, whose operation is explained below. If present, the initialization expression is 
checked and its type compared to the value type of the declared identifiers. If these types 
are not equal, then an initialization type mismatch is reported. If the identifiers are being 
declared as constants, they are entered into the TSE with an initial value equal to the 
(static) value of the initialization expression. 

The function enter-objects enters into the TSE a scalar descriptor for each of a list of 
identifiers. Duplicate declarations are detected. The descriptors are created from (1) the 
identifiers and (2) a list of remaining field values input to enter-objects. 

The function name-type returns the type (consisting of a type mode and a type descriptor ) 
of a reference (ref). In Phase 1 , refs are essentially sequences of identifiers and expression 
lists; refs must begin with an identifier. As name-type processes a ref, it carries along 
(in parameters name and w, respectively) the remainder of the ref to be processed and 
the type to be computed for that portion of the original ref processed thus far. During 
this processing, special type modes that ate identifier lists may be used to validate accesses 
to items declared inside packages or subprograms; validate-access checks these accesses. 
The function list-type returns the list of the types of its components; when a list is used 
as an actual parameter list in a subprogram call, compatible-par-types checks whether 
the types of this list’s components are compatible with (not necessarily equal to) the types 
of the corresponding formal parameters of the subprogram. 


(DT6) DT I SLCDEC object-class id + slice-name opt-expr ] (p)(vis)(u)(t) 

= let (type-mark,discrete-range) = slice-name in 
let q = find-progunit-env(t)(p) in 
let d = t(q)(*UNIT* ) in 
let tg = tag(d) in 
(case object-class 

(CONST ,SYSGEN ) —+ lookup-type(type-mark)(p)(z)(t), 

VAR 
—► (case tg 

(*PACKAGE* ,*ENTITY* ^ARCHITECTURE* ) 

—► error 

(cat(“Illegal VARIABLE declaration in ”)(tg) 

(“ context: ”)(decl)), 

OTHERWISE —► lookup-type(type-mark)(p)(z)(t)), 

SIG 

—► (case tg 

(*PROCESS* ,*PROCEDURE* *FUNCTION* ) 

—► error 

(cat(“Illegal SIGNAL declaration in ”)(tg)(“ context: ”) 
(decl)), 

OTHERWISE —► lookup-type(type-mark)(p)(z)(t)), 

OTHERWISE 

—*■ error(cat(“Illegal object class in declaration: ”)(decl))) 
where 

z = Ad.let type = (object-class = CONST — mk-type((CONST VAL) )(d), 


60 



mk-type(mk-tmode(object-class)(REF ))(d)) in 
process-slcdec(id + )(type)(discrete-range)(opt-expr)(p)(vis)(u)(t) 


process-slcdec(id + )(w)(discrete-range)(opt-expr)(p)(vis)(u)(t) 

= let d = tdesc(w) in 

(-iis-array?(w)— ♦ error(cat(“Can't form slice of non-array type: ”)(d)), 
let ( direction,expri ,expr 2 ) = discrete-range in 
RT [ expri ] (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

WT [ expr 2 ] (p)(k 2 )(t) 
where 

k 2 = A(w 2 ,e 2 ),t. 

(-i(is-integer-tdesc?(get-base-type(tdesc(wi))) 

A is-integer-tdesc?(get-base-type(tdesc(w 2 )))) 

—► error 

(cat(“Non-integer array bound for: ”)($(p) 

(hd(id+)))), 

let field-values = tl(array-type-desc 

(TEMPJMAME )(e)(p)(vis) 

(direction) 

((direction — TO 

— (ei = *UNDEF* 

—► second(EX J expn ] (p)(t)), 
(NUM ,ei)), 

(e 2 = *UNDEF* 

—► second ( EX [[ expr 2 ] (p)(t)), 
(NUM ,e 2 )))) 

((direction = TO 

- (e 2 = *UNDEF* 

—► second(EX [[ expr 2 J (p)(t)), 
(NUM ,e 2 )), 

(ei = *UNDEF* 

—► second ( EX [ expri J (p)(t)), 
(NUM ,e 1 ))))(elty(d))) in 

(null(opt-expr) 

—*• enter-array-objects 

(id + )(idf(d))(tmode(w))(field-values)(t)(p)(vis) 

(u). 

check-array-aggregate(opt-expr)(p)(v)(t) 

where 

v = Aw 3 .(match-types(elty(d),tdesc(w 3 )) 

—*• enter-array-objects 

(id + )(idf(d))(tmode(w)) 
(field-values)(t)(p)(vis)(u), 

error 

(cat(“Initialization type mismatch for: ”) 

($( P )(hd(id+)))))))) 

enter-array-objects(id*)(array-type-name)(tmode)(field-values)(t)(p)(vis)(u) 

= (null(id*)^ u(t), 

let idi = hd(id*) in 

let id 2 = new-array-type-name(array-type-name) in 
let di = cons(id 2 , field- values) in 
let ti = enter(t)(p)(id 2 )(field-values) in 
let new-type = mk-type(tmode)(di) in 

(t(p)(idi)# ^UNBOUND* 


61 



—► error(cat(“Duplicate array declaration: ”)($(p)(idi))), 
let d 2 = <£,*OBJECT* ,p,vis,new-type,*UNDEF* ,e> in 
let t 2 = enter(ti)(p)(idi )(d 2 ) in 
enter-array-objects 

(tl(id*))(array-type-name)(tmode)(field-values)(t 2 )(p)(vis)(u))) 

check-array-aggregate(expr)(p)(v)(t) 

= let (tg,expr + ) = expr in 

(tg ^ BITSTR A tg ^ STR 

—*- error(cat(“Improper array initialization aggregate: ”)(expr)), 
let expri = hd(expr+) in 
RT I expn 1 (p)(k)(t) 

where k = A(wi ,ei ),t.check-exprs(wi)(tl(expr + ))(p)(v)(t)) 

check-exprs(w)(expr*)(p)(v)(t) 

— (null(expr*)—► v(w), 

let expr = hd(expr*) in 
RT [expr | (p)(k)(t) 
where 

k = A(w 1 ,ei),t. 

(wi ^ w —► “Nonuniform array aggregate ”, 
check-exprs(w)(tl(expr*))(p)(v)(t))) 


A declaration of a slice of a (previously defined) array type is a special form of object 
declaration for arrays of anonymous type. Because a declaration of a list of identifiers is 
considered to be an abbreviated representation of the sequence of corresponding declarations 
of each of the individual identifiers in the list, the (anonymous) type of each of the declared 
identifiers is distinct. Each of these distinct anonymous array types is given a distinct, 
new, system-generated name in Phase 1 of the Stage 3 VHDL translator (via the function 
new-array-type-name) , and corresponding distinct type descriptors are entered into the 
TSE. If present, the initialization part of the declaration is a list of scalar expressions. 

The elaboration and checking of a slice declaration begins in the same way as for a scalar 
declaration. The slice bound expressions are then evaluated and checked to ensure that 
both are integers. If the initialization part is absent, then descriptors for the declared array 
identifiers, together with the descriptors for the corresponding anonymous array types, are 
entered into the environment by enter-array-objects. 

If the initialization part is present, then it is first processed by check-array-aggregate, 
which invokes check-exprs to ensure that each element of the initialization part has the 
same (value) type; check-aggregate returns this type, which is then compared to the ar¬ 
ray’s declared value type. Finally, enter-array-objects is invoked to enter the descriptors 
for the declared arrays into the environment. 

Refer also semantic equation DT8, shown below. 

(DT7) DT l ETDEC id id+ ] (p)(vis)(u)(t) 

= let field-valuesi = <e,*ENUMTYPE* ,p,vis,mk-enumlit(hd(id + )), 
mk-enumlit(last(id + )),id + > in 
(check-enum-lits(t)(p)(id)(id + ) 

—► enter-objects((id))(field-vaJuesi )(t)(p)(ui), 
nil) 

where 


62 



ui = Ati .let d = cons(id,field-valuesi) in 

let field-values 2 = <e,*ENUMELT* ,p,vis, 

mk-type((CONST VAL) )(d)> in 
en ter-objects(id + ) (field-values 2 ) (1 1 ) (p) (u) 

check-enum-lits(t)(p)(id)(id*) 

= (nuU(kT)— tt, 

let idi = hd(id*) in 

(lookup(t)(p)(idi)= ^UNBOUND* - check-enum-Uts(t)(p)(id)(tl(id*)), 
error 

(cat(“Illegal overloading for enumeration literal: ”)(idi) 

(“ in enumeration type: ”)(S(p)(id))))) 


An enumeration type declaration causes corresponding enumeration type descriptors to be 
entered into the TSE. At the same time, descriptors for the individual elements of the 
enumeration type are entered into the TSE; these elements are treated as constants. 

(DT8) DT l ATDEC id discrete-range type-mark J (p)(vis)(u)(t) 

= lookup- type(type-mark)(p)(z)(t) 
where 

z = Ad. let (direction,expri ,expr 2 ) = discrete-range in 
let array-type-desc = array-type-desc 

(id) (e) (p) (vis) (direction) 

((direction = TO 
—•► second ( EX [[expri ] (p)(t)), 
secondfEX [ expr 2 ] (p)(t)))) 

((direction = TO 
-► secondfEX [ expr 2 1 (p)(t)), 
secondf EX [ expri ] (p)(t))))(d) in 

attributes-low-high 

((id,expri ,expr 2 ,array-type-desc,(UNIVERSAL-INTEGER) ))(p) 

(vis)(u)(t) 

attributes-low-high(id,expri ,expr 2) type-desc,attribute-type-mark) (p)( vis) (u)(t) 

= let decli = (DEC ,SYSGEN ,(mk-tick-low(id)),attribute-type-mark,expri) 

and decl 2 = (DEC ,SYSGEN ,(mk-tick-high(id)),attribute-type-mark,expr 2 ) in 
enter-objects((id))(tl(type-desc))(t)(p)(ui) 
where ui = Ati . DT IT decli J (p)(vis)(u 2 )(ti) 
where u 2 = At 2 .DT J decl 2 ]] (p)(vis)(u)(t 2 ) 

mk-tick-low(id) = catenate(id, w, LOW”) 

mk-tick-high(id) = catenate(id, w, HIGH”) 

An array type declaration causes corresponding array type descriptors to be entered into the 
TSE. The array type attributes ’low and ’high, representing the lower and upper bounds, 
respectively, are declared as system-generated identifiers. 

(DT9) DT I PACKAGE id decl* opt-id J (p)(vis)(u)(t) 

= (t(p)(id)/ "“UNBOUND* 

—» error(cat(“Duplicate package declaration: ”)($(p)(id))), 

(-inull(opt-id)A opt-id ^ id 
— error 

(cat(“Package ”)($(p)(id))(“ ended with incorrect identifier: ”) 


63 




(opt-id)), 

let d = <£,*PACKAGE* ,p,vis,e> in 
let ti = enter(t)(p)(id)(d) in 

let t 2 =enter(extend(t 1 )(p)(id))(%(p)(id))(*UNIT* )(<£ "PACKAGE* >) in 
let t 3 = enter(t 2 )(%(p)(id))(*USED* )(<e,e>) in 
let t 4 = enter(t 3 )(%(p)(id))(*IMPT* )(<e,e,e>) in 

Ul(t 4 ) 

where m = At.DT [decl* J (%(p)(id))(tt)(u)(t))) 

(DT10) DT [ PACKAGEBODY id decl* opt-id J (p)(vis)(u)(t) 

= let d = t(p)(id) in 

(d = "UNBOUND* —► error(cat(“Missing package declaration: ”)($(p) 

( id )))> 

tag(d)y£ "PACKAGE* —* error(cat(“Not a package declaration: ”)($(p) 

(id))). 

-.null(pbody(d))—► error(cat(“Duplicate package body: ”)($(p)(id))), 

-.null(opt-id)A opt-id ^ id 
—► error 

(cat(“Package body ”)($(p)(id))(“ ended with incorrect identifier: ”) 
(opt-id)), 

let q = %(path(d))(id) in 
let ti = enter(t)(q)(*LAB* )(<e,e>) in 
let t 2 = enter(ti)(p)(id)(<e,"PACKAGE* ,path(d),exported(d),*BODY* >) in 
DT [ decl* J (q)(ff)(u)(t 2 )) 


A package is an encapsulated collection of declarations (including other packages) of logi¬ 
cally related entities identified by the package’s name. A package is generally provided in 
two parts: the package declaration and the package body. The package declaration provides 
declarations of those items that are exported (i.e., made visible) by the package. The package 
body provides the bodies of items whose declarations appear in the package declaration, to¬ 
gether with the declarations and bodies of additional items that support the items exported 
by the package. These latter items are not exported by the package, i.e., they cannot be 
made visible outside the package. In our implementation, the descriptors of exported and 
nonexported items alike are entered into the same local environment. The exported field of 
these descriptors distinguishes between the two kinds of items. If an item can be exported 
by a USE clause, then the exported field of its descriptor contains tt (denoting true; if not, 
then this field contains ff (false). 

The items declared in a package declaration are not directly visible outside the package, but 
they can be accessed by using a dotted name beginning with the package name, provided 
that the package name is visible at the point of access. A descriptor for the package 
declaration is entered into the current environment. In order to encapsulate the items 
within a package, the resulting TSE is then extended along the current path by an edge 
labeled with the package name; the new environment is marked (in its *UNIT* cell) as a 
package environment. Then the constituent declarations of the package are elaborated and 
checked in the new environment. 

The items declared in a package body are not exported from the package and thus must 
not be accessible by an extended name. Therefore the exported field of the descriptors for 
the inaccessible entities must be set to ff, thus marking them as not exportable. 

(DTll) DT [ PROCEDURE id proc-par-spec’ ]] (p)(vis)(u)(t) 


64 



= (t(p)(id)^ ^UNBOUND* 

—► error(cat(“Duplicate procedure declaration for: ”)($(p)(id))), 
let pi = %(p)(id) in 

let t! = enter(extend(t)(p)(id))( Pl )(*UNIT* )(<c ,*PROCEDURE* >) in 
enter-formal-pars(*PROCEDURE* )(proc-par-spec*)(t* )(pi )(ui) 
where 

m = At 2 .let formals = let id + = collect-fids(proc-par-spec*) in 
collect-formal-pars(id + )(t 2 )(pi) in 
let d = <e,*PROCEDURE* ,p,vis, 

((formals, 

mk-type((CONST VAL) )(void-type-desc(t)))),e,e> in 
u(enter(t 2 )(p)(id)(d))) 

(DT12) DT [ FUNCTION id func-par-spec* type-mark ] (p)(vis)(u)(t) 

= (t(p)(id)^ ^UNBOUND* 

—► error(cat(“Duplicate function declaration for: ”)(S(p)(id))), 
let pi = %(p)(id) in 
lookup-type(type-mark)(p)(z)(t) 
where 

z = Adi .let ti = enter 

(extend(t)(p)(id))(pi)(*UNIT* )(<e ^FUNCTION* >) in 
enter-formal-pars(*FUNCTION* )(func-par-spec*)(ti)(pi )(ui) 
where 

m = At 2 . 1 et formals == let id + — collect-fids 

(func-par-spec*) in 
collect-formal-pars 
(id+)(t 2 )( Pl ) in 

let d = < £ ,*FUNCTION* ,p,vis, 

((formals,mk-type((VAR VAL) )(di ))),£,£> in 
u(enter(t 2 )(p)(id)(d))) 

enter-formal-pars(tg)(par-spec*)(t)(p)(u) 

= (null(par-spec*)-^ u(t), 

let par-spec = hd(par-spec*) in 
let (object-class,id + ,mode,type-mark,opt-expr) = par-spec in 
(case tg 

♦PROCEDURE* 

—► (case object-class 

(CONST ,VAR ) 

—► (case mode 

(IN ,OUT ,INOUT ) lookup-type(type-mark)(p)(z)(t), 

OTHERWISE 
—► error 

(cat(“Illegal mode for procedure parameters: ”)($(p) 

(hd(w+))))), 

OTHERWISE 
—► error 

(cat(“Unimplemented object class ”)(object-class) 

(“ for procedure parameters: ”)(^(p)( hd(id“*"))))), 

^FUNCTION* 

—► (case object-class 
CONST 
—*■ (case mode 

IN —► lookup-type(type-mark)(p)(z)(t), 

OTHERWISE 

—► error 

(cat(“Illegal mode for function parameters: ”)($(p) 


65 




(hd(id + ))))) 


OTHERWISE 

—+ error 

(cat(“Unimplemented object class ”)(object-class) 

(“ for function parameters: ”)($(p)(hd(id + ))))), 

OTHERWISE —► error(cat(“Illegal subprogram tag: ”)(tg))) 
where 

z = Ad.let type = (case mode 

IN —► mk-type(mk-tmode(object-class)(VAL ))(d), 

OUT —► mk-type(mk-tmode(object-class)(OUT ))(d), 
OTHERWISE —* mk-type(mk-tmode(object-class)(REF ))(d)) in 
let fv = <e,*OBJECT* ,p,tt,type,*UNDEF* ,s> in 
enter-objects(id + )(fv)(t)(p)(ui) 
where ui — At.enter-formal-pars(tg)(tl(par-spec*))(t)(p)(u)) 

collect-fids(par-spec*) 

= (null(par-spec*)—»- e, 

let par-spec = hd(par-spec*) in 
let (object-class,id + ,mode,type-mark,opt-expr) = par-spec in 
append(id + ,collect-;fids(tl (par-spec*)))) 

collect-formal-pars(id* )(t)(p) 

= (null(id*)— 6, 

let d = t(p)(hd(id*)) in 

cons((hd(id*),type(d)),collect-formal-pars(tl(id*))(t)(p))) 


Checking a subprogram (procedure or function) declaration first extends the TSE and iden¬ 
tifies the new environment at the end of the extended path (in its *UNIT* cell) as a 
procedure or function environment. Then descriptors for the subprogram’s formal parame¬ 
ters are entered (by enter-formal-pars) into this new environment. Finally, a descriptor 
for the subprogram (with a body field of ff, indicating that no body for this subprogram 
has been encountered) is entered into the environment in which the subprogram is declared 
locally. Procedures are always given a void return type. The function enter-formal-pars 
accepts a tag *PROCEDURE* or *FUNCTION* (procedure or function) to enable 
it to check that the formal parameters are appropriate to the subprogram. For example, 
functions can have only IN parameters. 

(DT13) DT | SUBPROGBODY subprog-spec decl* seq-stat* opt-id ] (p)(vis)(u)(t) 

= let (tg,id,par-spec*,type-mark) = subprog-spec in 
let qname = $(p)(id) 
and d = t(p)(id) in 
(d = ^UNBOUND* 

—*• let decl = subprog-spec in 
DT [ decl ] (p)(vis)(ui )(t) 
where 

ui = At.let d — t(p)(id) in 
process-subprog-body 

(t)(p)(id)(d)(decl*)(seq-stat*)(u), 

-(tag(d)e (^PROCEDURE* ^FUNCTION*) ) 

—► error(cat(qname)(“ is not a subprogram specification”)), 

(tg = PROCEDURE A tag(d)= ^FUNCTION* ) 

V (tg = FUNCTION A tag(d)= ^PROCEDURE* ) 

—► error (cat (“Wrong kind of subprogram body: ”)(qname)), 

-inull(body(d))—► error(cat(“Duplicate subprogram body: ”)(qname)), 


66 



-mull(opt-id)A opt-id ^ id 
—► error 

(cat( “Subprogram body ”)(qname) 

(“ ended with incorrect identifier ”)(opt-id)), 
let formals = let id* = collect-fids(par-spec*) in 

collect-formal-pars(id + )(t)(%(p)(id)) in 
(formals / pars(hd(signatures(d))) 

—► error 

(cat (“Nonconforming formal parameters for subprogram: ”)(qname)), 
lookup-type(type-mark)(p)(z)(t) 
where 

z = Adi.(di ^ tdesc(extract-rtype(d)) 

—► error 

(cat(“Unequal result types for subprogram: ”) 

(qname)), 

process-subprog-body(t)(p)(id)(d)(decl*)(seq-stat*)(u)))) 

process-subprog-body (t)(p) (id )(d) (decl* ) (seq-stat* )(u) 

= let pi = %(p)(id) in 

let ti = enter(t)(pi)(*LAB* )((e,e)) in 
let t 5 = enter(ti)(pi)(*USED* )(<£,£>) in 
let t 6 = enter(t 5 )(pi)(*IMPT* )(<£,£,£>) in 
let t 7 = enter 

(t 6 )(p)(id)(<£,tag(d),path(d),exported(d),signatures(d),£,£>) in 
DT [decl* l(pi)(tt)(ui)(t r ) 
where ui = At^. SST [ seq-stat* J (pi)(u 2 )(t 2 ) 
where 

U 2 = At3.1et t 4 = enter 

(t 3 )(p)(id) 

(<e,tag(d),path(d),exported(d),signatures(d), 

(DX IT decl* 1 (p, )(t 3 ),SSX IF seq-stat* J (pi)(t 3 )),e>) in 

u(t 4 ) 


Checking the declaration of a subprogram body first checks whether a declaration for the 
subprogram has already been encountered. If not, then descriptors for the subprogram 
and its formal parameters must be entered into the TSE as above. Otherwise, the declara¬ 
tion part of the subprogram body must be checked for conformity with the corresponding 
information previously entered in the TSE. In Stage 3 VHDL conformity is very strict: 
subprogram types and formal parameter names and types must agree exactly , except that 
formal parameters with no explicit mode are regarded as having been specified with mode 
IN. The subprogram’s body (which consists of local declarations followed by statements) is 
checked by process-subprog-body, where initial entries are made into its environment’s 
*LAB*, *USED*, and *IMPT* cells, and its transformed abstract syntax tree is entered 
into the body field of the subprogram’s descriptor. Note that a dummy value *BODY* is 
temporarily entered in the descriptor’s body field, so that recursive calls of this subprogram 
wifi not incorrectly indicate that a call is being made to a subprogram for which a body 
has not been supplied (see the Phase 1 semantics of subprogram calls). 

(DT14) DT I USE dotted-name + 1 (p)(vis)(u)(t) 

= let pkgs-used-here = tl(dotted-name + )U {hd(dotted-name + )} in 
process-use-clause(pkgs-used-here)(p) (vis) (u)(t) 

process-use-clause(dotted-name + )(p)(vis)(u)(t) 


67 



= check-pkg-names(dotted-name + )(e)(p)(vis)(j)(t) 
where 

j = Apkg-qualified-names. 

let pkg-qnames = remove-enclosing-pkgs(p)(t)(pkg-qualified-names) in 
let local-pkgs-used = third(t(p)(*USED* )) in 
let ti = enter 

(t)(p)(*USED* ) 

((e, pkg-qnames U local-pkgs-used)) in 
let t 2 = let d = t(p)(*IMPT* ) in 
let qname-list = third(d) 

and id-list = fourth(d) in 
import-qualified-names 

(pkg-qnames)(qname-list)(id-list)(p)(ti) in 

u(t 2 ) 

check-pkg-names(dotted-name*)(pkg-qualified-names)(p)(vis)(j)(t) 

= (null(dotted-name*)—» j(pkg-qualified-names), 
let dn = hd(dotted-name*) in 
let suffix = last(dn) in 
(suffix ^ ALL 

—+ error(cat(“Selected name in USE clause must end ¥ith suffix ALL: ”)(dn)), 
name-type(rest(dn))(e)(p)(t)(v) 
where 

v = Aw.let d = tdesc(w) in 

(tag(d)^ *PACKAGE* 

—► error(cat(“Non-package name in USE clause: ”)(namef 

(<*))). 

check-pkg-names 

(tl(dotted-name*))(cons(%(path(d))(idf(d)),pkg-qualified-names)) 

(p)(vis)(j)(t)))) 

remove-enclosing-pkgs(p)(t)(pkg-set) 

= (null(p)—► pkg-set, 

let d = t(p)(*UNIT* ) in 

(d = ^UNBOUND* —► remove-enclosing-pkgs(rest(p))(t)(pkg-set), 

(third(d)= ^PACKAGE* 

—► remove-enclosing-pkgs(rest(p))(t)(set-difFerence(pkg-set)((p))), 
remove-enclosing-pkgs(rest(p))(t)(pkg-set)))) 

import-qualified-names(pkg-qualified-names) (item-qualified-names) (ids-used) (p)(t) 

= (pkg-qualified-names = e 

—*■ enter(t)(p)(*IMPT* )((e,item-qualified-names,ids-used)), 
let pkg-qn = hd(pkg-qualified-names) in 
let pkg-env = t(pkg-qn) in 

let exported-qnames = export-qualified-names(pkg-env)(e) in 
let local-env = t(p) in 
let (qname*,id*) = import-legal 

(exported-qnames) (item-qualified-names) (ids-used) 
(local-env) in 

import-qualified-names(tl(pkg-qualified-names))(qname*)(id*)(p)(t)) 

import-legal(exported-qnames)(qname-list)(id-list)(env) 

= (null(exported-qnames)—+ (qname-list,id-list), 
let qname = hd(exported-qnames) in 
let id = last(qname) in 

let remaining-exported-qnames — tl(exported-qnames) in 
(id G id-list 


68 



—► let qn = simple-name-match(id)(qname-list) in 
(null(qn) 

—> import-legal(remaining-exported-qnames) (qname-list) (id-list) (env), 
import-legal 

(remaining-exported-qnames)(set-difference(qname-list)((qn))) 

(id-list)(env)), 
let d = env(id) in 
(d = ^UNBOUND* 

—► import-legal 

(remaining-exported-qnames)(cons(qname,qname-list)) 

(cons(id,id-list))(env), 

import-legal 

(remaining-exported-qnames)(qname-list)(cons(id,id-list))(env)))) 

simple-name-match(id)(qname*) 

= (nuil(qname*)—► e, 

(id = last(hd(qname*))—► hd(qname*), simple-name-match(id)(tl(qname*)))) 

export-qualified-names(env) (qualified-names) 

= (null(env)—+ qualified-names, 
let d = hd(env) in 
let id = idf(d) in 
(case id 

(*UNIT* *LAB* ,*USED* ,*IMPT* ) 

—► export-qualified-names(tl(env)) (qualified-names), 

OTHERWISE 

—► (exported(d) 

—► export-qualified-names(tl(env))(cons(%(path(d))(id),qualified-names)), 
export-qualified-names(tl(env)) (qualified-names)))) 

A USE clause is a declaration that makes items declared in a package specification visible 
at the location of the USE clause. Each of the dotted names in a USE clause, neglecting 
the (obligatory) suffix ALL, must denote the name of a package. In essence, a USE clause 
combines the exported environments associated with its named packages both with each 
other and with the local environment (among whose declarations the USE clause appears). 
Such a combination of environments may introduce conflicts, since there may be several 
different declarations of an object of the same name in the packages (as well as one locally). 
Therefore, certain constraints must govern how environments are combined: 

1. If an object x is declared locally, then no declarations of x may be imported to the 
local environment by the USE clause. 

2. If an object x is declared in more than one of the packages named in the USE clause, 
then none of these declarations of x may be imported to the local environment by the 
USE clause, even if x is not declared locally. 

These constraints ensure that (1) no local declaration is masked by an imported one, and 
(2) no duplicate or conflicting declarations are imported. 

USE clauses are treated by process-use-clause, which assumes that all the USE clauses in 
a program unit’s declarative part are located together at the end of that declarative part. 


69 



This restriction on the location and grouping of USE clauses enables a determination of 
those items imported into a local environment to be made once and for all by the time the 
unit's declarative part has been processed . This ensures that the list of items imported into 
an environment (stored in its *IMPT* cell) need not vary in Phase 2, thereby ensuring 
that the entire TSE is fixed throughout Phase 2. If declarations other than USE clauses were 
allowed to appear between USE clauses, then the set of importable items may change before 
and after such interposed declarations, requiring a dynamic evaluation of the import list 
during Phase 2. We feel that such generality is unnecessary, because the names of items 
can always be changed so that their interposed declarations can be moved in front of the 
group of USE clauses. 

First, the list of names appearing in this USE clause (with duplicates removed) is given to 
process-use-clause. Then these names are checked by check-pkg-names to ensure that 
they denote packages; a list of fully qualified package names is returned. The names of 
packages that enclose packages in this list are removed by remove-enclosing-packages. 
The (set-theoretic) union of the resulting set of package names (called pkg-qnames) and 
the set of names of packages already appearing in USE clauses in this declarative part (stored 
in the *USED* cell of this environment) is computed (in order to avoid duplication); the 
resulting set of package names is entered back into the *USED* cell. Next, the current set 
of fully qualified names of items imported into this environment (qname-list) is retrieved 
from its *IMPT* cell. A separate list of simple identifiers (id-list) is also maintained in 
the *IMPT* cell; this list is used to prevent illegal importations into the current envi¬ 
ronment. Then pkg-qnames, qname-list, and id-list are passed to import-qualified- 
names, which adds the fully qualified names of those items that can be legally imported 
into the local environment by the USE clause being processed. The auxiliary functions 
export-qualified-names and import-legal are used by import-qualified-names. 

(DT15) DT [[ STDEC id type-mark opt-discrete-range J (p)(vis)(u)(t) 

= lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let base-type-desc = get-base-type(d) in 
(null(opt-discrete-range) 

—► let field-values = <e,*SUBTYPE* ,p,vis,type-tick-low(d), 
type-tick-high(d),base-type-desc > in 
attributes((id,e,e,d,field-values))(p)(vis)(u)(t), 
let (direction,expri ,expr 2 ) = opt-discrete-range in 
RT [ expri J (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT l expr 2 ]] (p)(k 2 )(t) 

where 

k 2 = A(w 2 ,e 2 ),t. 

(match-types(tdesc( wi),base-type-desc) 

A match-types(tdesc(w 2 ),base-type-desc) 

— let field-values = <e,*SUBTYPE* ,p,vis, 

(direction = TO 
- (e, = *UNDEF* 

—► second 

( EX l expri 1 
(p)(t)), 

(NUM ,ei)), 

(e 2 = *UNDEF* 


70 



—* second 

(EX [ expr 2 J 

(P)(t)), 

(NUM ,e 2 ))), 

(direction = TO 
— (e 2 = *UNDEF* 

—► second 

(EX I expr 2 J 
(P)(t)), 

(NUM ,e 2 )), 

(e, = *UNDEF* 

—* second 

(EX I expn ] 

(P)(t)), 

(NUM ,ei))),base-type-desc> in 

attributes 

((id. 

(direction = TO —► expri > 
expr 2 ), 

(direction = TO —► expr 2 , 
expri ),d,field-vaJues))(p) 

(vis)(u)(t), 

error 

(cat(“Range constraint for subtype incompatible with base type 
(base-type-desc)(tdesc(wi)) 

(tdesc(w 2 ))(decl)))) 

attributes(id, lower-bound, upper-bound, d,field-values) (p) (vis) (u)(t) 

= let decli = (DEC ,SYSGEN ,(mk-tick-low(id)),(idf(d)),lower-bound) 

and decl 2 = (DEC ,SYSGEN ,(mk-tick-high(id)),(idf(d)),upper-bound) in 
enter-objects((id))(field-values)(t)(p)(ui) 
where ui = Ati. DT [decli 1 (p)(vis)(u 2 )(ti) 
where u 2 = At 2 . DT [ decl 2 J (p)(vis)(u)(t 2 ) 

Static semantic analysis of a subtype declaration involves making certain that the lower 
and upper bounds of the range constraint are compatible with the subtype’s base type; 
declaring the ’low and ’high attributes (representing these bounds) as system-generated 
identifiers; and entering a subtype descriptor in the TSE. 

(DT16) DT [ ITDEC id discrete-range J (p)(vis)(u)(t) 

= let parent-type-desc = univint-type-desc(t) in 
let (direction,expri ,expr 2 ) = discrete-range in 
RT [ expn 1 (p)(ki)(t) 
where 

ki — A(wi,ei),t. 

RT [ expr 2 ] (p)(k 2 )(t) 
where 

k 2 = A(w 2 ,e 2 ),t. 

(ei = *UNDEF* V e 2 = *UNDEF* 

—► error 

(cat(“Non-static bound in range constraint: w ) 

(decl)), 

(match-types(tdesc(wi),parent-type-desc) 

A match-types(tdesc(w 2 ),parent-type-desc) 
let field-values = <e,*INT-TYPE* ,p,vis, 


71 


(direction = TO 

— (NUM ,ei), 

(NUM ,e 2 )), 

(direction = TO 

- (NUM ,e 2 ), 

(NUM ,ei)),parent-type-desc> in 

attributes 

((id,(direction = TO —► expr 1? expr 2 ), 

(direction = TO —► expr 2 , exprj ),parent-type-desc,field-values)) 
(p)(vis)(u)(t), 

error 

(cat(“Incompatible range constraint for integer type: w ) 
(tdesc(wi))(tdesc(w 2 ))(decl)))) 

Static semantic analysis of an integer definition type involves making certain that the lower 
and upper bounds of the range constraint are static expressions compatible with the integer 
type’s parent type (UNIVERSAL-INTEGER); declaring the ’low and ’high attributes (rep¬ 
resenting these bounds) as system-generated identifiers; and entering an integer definition 
type descriptor in the TSE. 


6.5.6 Concurrent Statements 

(CSTO) CST I e ] (p)(u)(t) = u(t) 

(CSTl) CST [ con-stat con-stat* ] (p)(u)(t) 

= CST [ con-stat ] (p)(ui)(t) 

where ui = At. CST [[con-stat* J (p)(u)(t) 


Concurrent statements are statically checked in the textual order of their appearance in the 
hardware description. 

(CST2) CST [ PROCESS id ref* decl* seq-stat* opt-id ] (p)(u)(t) 

= let q = find-architecture-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 
(id £ labels —► error(cat(“Duplicate process label: ”)($(q)(id))), 
let ti = enter(t)(q)(*LAB* )((e,cons(id,labels))) in 
(-inull(opt-id)A opt-id ^ id 
—► error 

(cat( “PROCESS statement ” )(id) 

(“ ended with incorrect identifier: ”)(opt-id)), 
let t 2 = enter(ti)(q)(id)(<c,*PROCESSNAME* ,p,fF,ref*>) in 
let pi = %(p)(id) in 

let t 3 = enter(extend(t 2 )(p)(id))( Pl )(*UNIT* )(<£,*PROCESS* >) in 
let t 4 = enter(t 3 )(pi)(*LAB* )(<£,£>) in 
let t 5 = enter(t 4 )(pi)(*USED* )(<£,£>) in 
let t 6 = enter(t 5 )(pi )(*IMPT* )(<e,e,e>) in 
let tj = enter(te)(pi)(*SENS* )(<£,£>) in 
SLT [ ref* J ( P i)(u 2 )(t 7 ) 
where u 2 = At. DT [ decl* J (pi)(tt)(ui)(t) 
where Ui = At. SST [[seq-stat* ] (pi)(u)(t))) 


find-architecture-env(t)(p) 

= (null(p)V tag(t(p)(*UNIT* ))= * ARCHITECTURE* — p, 
find-architecture-env(t)(rest(p))) 


72 



(CST3) CST [[ SEL-SIGASSN atmark delay-type id expr ref selected-waveform* J (p)(u)(t) 
= let expr* = cons(expr, 

collect-expressions-from-selected- waveforms 
(selected-waveform*)) in 
let ref* = delete-duplicates 

(collect-signals-from-expr-list(expr*)(t)(p)(f:)) in 
let case-alt* = construct-case-alternatives 

(ref)(delay-type)(selected-waveform*) in 
let case-stat = (CASE ,atmark,expr,case-alt*) in 
let process-stat = (PROCESS ,id,ref*,£,(case-stat),id) in 
CST [[ process-stat ]] (p)(u)(t) 

collect-expressions-from-selected-waveforms(selected-waveform*) 

= (null(selected-waveform*)—► e, 

let selected-waveform = hd(selected-waveform*) in 
let waveform = second (selected-waveform) 

and discrete-range* = third(selected-waveform) in 
let transaction-exprs = collect-transaction-expressions(second(waveform)) in 
nconc 

(transaction-exprs, 
cons(second(discrete-range*), 
cons(third(discrete-range*), 
collect-expressions-from-selected-waveforms 
(tl(selected-waveform*)))))) 

collect-transaction-expressions(trans*) 

= (null(trans*)~* e, 

let transaction = hd(trans*) in 

cons(second(transaction),collect-transaction-expressions(tl(trans*)))) 

collect-signals-from-expr-list(expr* )(t)(p) (signal- refs) 

= (null(expr*)~+ signal-refs, 
let expr = hd(expr*) in 
collect-signals-from-expr 

(expr) (t)(p) (collect-signals-from-expr-list (tl(expr* ))(t)(p) (signal-refs))) 

collect-signals-from-expr(expr)(t)(p)(signal-refs) 

= (-iconsp(expr)—* signal-refs, 
is-ref?(expr) 

—► let d = lookup-desc-for-ref(expr)(p)(t) in 
(tag(d)= *OBJECT* A is-sig?(type(d)) 

—► cons(expr, 

(consp(second(expr)) 

—♦ collect-signals-from-expr-list(second(expr))(t)(p) (signal-refs), 
collect-signals-from-expr(second(expr)) (t) (p) (signal-refs))), 

(consp(second(expr)) 

—► collect-signals-from-expr-list(second(expr))(t)(p) (signal-refs), 
collect-sign als-from-expr(second(expr))(t)(p) (signal-refs))), 
is-paggr?(expr) 

—» collect-signals-from-expr-list(second(expr))(t)(p)(signal-refs), 
is-unary-op?(hd(expr)) 

—► collect-signals-from-expr(second(expr))(t)(p)(signal-refs), 
is-binary-op?(hd(expr))V is-relational-op?(hd(expr)) 

—► collect-signals-from-expr 
(second(expr))(t)(p) 

(collect-signals-from-expr(third (expr) )(t)(p) (signal-refs)), 
collect-signals-from-expr-list(expr)(t)(p) (signal-refs)) 


73 




lookup-desc-for-ref(ref)(p)(t) 

= let name = second(ref) in 

let id + = (consp(last(name))—► rest(name), name) in 
let q = access(rest(id + ))(t)(p) in 
lookup-desc-on-path(t)(q)(last(id + )) 

lookup-desc-on-path(t)(p)(id) 

= let d = t(p)(id) in 

(d = ^UNBOUND* —► lookup-desc-on-path(t)(rest(p))(id), d) 

accessed* )(t)(p) 

= (null(id*) —► p, 

let id = hd(id*) in 
let d = lookup(t)(p)(id) in 

(d = ^UNBOUND* —+ error (cat (“Unbound identifier: ”)(id)), 
access(tl(id*))(t)(%(path(d))(idf(d))))) 

construct-case-alternatives(ref) (delay-type) (selected-waveform*) 

= (null(selected-waveform*)—♦ e, 

let selected-waveform = hd(selected-waveform*) in 
let waveform = second (selected-waveform) 

and discrete-range" 1 " = third(selected-waveform) in 
let sig-assn-stat = (SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform) in 
let case-alt = (CASECHOICE ,discrete-range + ,(sig-assn-stat)) in 
cons(case-alt, 

construct-case-alternatives(ref) (delay-type) (tl(selected-waveform*)))) 


(CST4) CST f COND-SIGASSN atmark delay-type id ref cond-waveform* waveform J (p)(u)(t) 
= let expr* = nconc 

(collect-expressions- from-conditional-waveforms 
(cond-waveform *), 

collect-transaction-expressions(second(waveform))) in 
let ref* = delete-duplicates 

(coUect-signals-from-expr-list(expr*)(t)(p)(e)) in 
(null(cond-waveform*) 

—*• let sig-assn-stat = (SIGASSN ,(AT ,mk-atmark()),delay-type,ref, waveform) in 
let process-stat = (PROCESS ,id,ref*, e, (sig-assn-stat),id) in 
CST J process-stat | (p)(u)(t), 
let cond-part + — construct-cond-parts 

(ref) (delay-type) (cond-waveform*) 

and else-part = ((SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform)) in 
let if-stat = (IF ,atmark,cond-part + ,else-part) in 
let process-stat = (PROCESS ,id,ref*, e, (if-stat),id) in 
CST [ process-stat ] (p)(u)(t)) 

collect-expressions-from-conditional-waveforms(cond-waveform*) 

= (null(cond-waveform*)—► e, 

let cond-waveform = hd(cond-waveform*) in 
let waveform = second(cond-waveform) 

and condition = third(cond-waveform) in 
let transaction-exprs = collect-transaction-expressions(second(waveform)) in 
nconc 

(transaction-exprs, 
cons(condition, 

coUect-expressions-from-conditional-waveforms(tl(cond-waveform*))))) 


74 



construct-cond-parts(ref) (delay- type) (cond- waveform*) 

= (null(cond-waveform*)—* e , 

let cond-waveform = hd(cond-waveform*) in 
let waveform = second(cond-waveform) 

and condition = third(cond-waveform) in 
let sig-assn-stat = (SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform) in 
let cond-part = (condition,(sig-assn-stat)) in 
cons(cond-part,construct-cond-parts(ref) (del ay-type) (tl(cond-waveform*)))) 


6,5.7 Sensitivity Lists 

(SLTO)SLT[e](p)(u)(t) = u(t) 

(SLTl) SLT [ref ref* ] (p)(n)(t) 

= SLT[ref](p)(u 1 )(t) 

where ui = At. SLT [ ref* ] (p)(u)(t) 


The refs in the sensitivity list of a PROCESS statement are checked in sequential order. 

(SLT2) SLT [ REF name ] (p)(u)(t) 

= let expr = ref in 

ET [expr](p)(k)(t) 

where 

k = A(w,e),t. 

let d = tdesc(w) in 
(-»is-sig?(w) 

—*■ error 

(cat(“Non-signal in process sensitivity list: ”)(ref)), 
let di = lookup(t)(p)(*SENS* ) in 
let ti = enter 

(t)(p)(*SENS* ) 

(<e,(cons(SLX [ ref J (p)(t),sensitivity(di )))>) in 

u(tl)) 


6.5.8 Sequential Statements 

(SSTO) SST[«](p)(c)(t) = c(t) 

(SST1) SST I seq-stat seq-stat* ]] (p)(c)(t) 

= SST J seq-stat ]] (p)(ci)(t) 

where ci = At. SST J seq-stat’ J (p)(c)(t) 


Sequential statements are statically checked in the textual order of their appearance in the 
hardware description. 

(SST2) SST [ NULL atmark J (p)(c)(t) = c(t) 


NULL statements require no checking. 


75 



(SST3) SST [ VARASSN atmark ref expr ] (p)(c)(t) 

= let expr 0 = ref in 
ET ffexpro J (p)(k)(t) 
where 
k = A(w,e),t. 

let d = tdesc(w) in 
(-us-var?(w) 

—+ error 

(cat(“Illegal target in variable assignment statement: ”) 
(seq-stat)), 

”iis-writ able?( w) 

—► error(cat(“Read-only variable: ”)(namef(d))), 

RT [expr 1 (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

let dj — tdesc(wi) in 
(match-types(d,di)—► c(t), 

error(cat(“Assignment type mismatch: ”)(d)(di)))) 


find-process-env(t)(p) 

= (nnll(p)V tag(t(p)(*UNIT* ))= *PROCESS* - p, find-process~env(t)(rest(p))) 

First the left part of a variable assignment statement is checked, and then the right part. 
The left part must be a variable of reference type (checked by is-var? and is-writable?), 
and the basic types of the left and right parts must be the same, as verified by match-types 
(refer to the definitions following semantic function DT5). 

(SST4) SST [[ SIGASSN atmark delay-type ref waveform ] (p)(c)(t) 

= let expr = ref in 
ET [expr J (p)(k)(t) 
where 
k = A(w,e),t. 

let d = tdesc(w) 

and q = find-process-env(t)(p) in 
(-iis-sig?(w) 

—► error 

(cat(“Illegal target of signal assignment statement: ”) 

(namef(d))), 

-ns-writable?(w)^ error 

(cat(“Read-only signal: ”)(namef 

(<»))), 

null(q) 

—► error 

(cat(“Sequential signal assignment statement not in a process: ”) 
(seq-stat)), 

let di = lookup-desc-for-ref(ref)(p)(t) in 
(null(process(di)) 

—► let ti = enter 

(t)(path(di))(idf(di)) 

(<e,*OBJECT* ,path(di ),exported(di),type(di), 
value(di ),last(q)>) in 

ci(ti), 

process(di)= last(q)-^ ci(t), 
error 

(cat(“Target of signal assignments in multiple processes: ”) 


76 



(namef(di)))) 

where 

ci = Ati WT [[ waveform ] (p)(ki )(t) 
where 

ki = A(wi,ei),t. 

let di = tdesc(wi) in 
(match-types(d,di)“> c(t), 
error 

(cat (“Assignment type mismatch: ”) 
(d)(di)))) 


(SST5) SST J IF atmark cond-part + else-part ] (p)(c)(t) 

= let seq-stat* = else-part in 
check-if(cond-part + )(p)(ci )(t) 

where ci = At.(null(seq-stat*)—♦ c(t), SST [ seq-stat* ] (p)(c)(t)) 

check-if(cond-part*)(p)(c)(t) 

= (null(cond-part*)— c(t), 

let (expr,seq-stat*) = hd(cond-part*) in 
RT [expr | (p)(k)(t) 
where 
k = A(w,e),t. 

(is-boolean?(w) 

—► SST [ seq-stat* | (p)(ci)(t) 

where ci = At.check-if(tl(cond-part*))(p)(c)(t), 
error(cat(“Non-boolean condition in IF statement: w )(tdesc 

(w))))) 

A Stage 3 VHDL IF statement consists of one or more conditional parts (cond-parts) 
followed by a (possibly empty) else-part. Each cond-part consists of a test expression 
followed by sequential statements that are to be executed when the test expression is the 
first to evaluate to true; the sequential statements constituting the else-part are to be 
executed when none of the test expressions is true. 

The cond-parts are first checked, in order, by auxiliary semantic function check-if, after 
which the else-part, if nonempty, is checked by SST. Checking each cond-part involves 
first ascertaining that the basic type of its test expression is boolean, and then invoking 
SST to check its sequential statements. 

(SST6) SST [[ CASE atmark expr case-alt + ] (p)(c)(t) 

= RT [ expr ] (p)(k)(t) 
where 

k = A(w,e),ti. 

let d = get-base-type(tdesc(w)) in 
AT [ case-alt + ] (d)(p)(y)(ti) 
where 
y = Ah,t 2 . 

(“icase-1 ype- ok (d) 

—► error 

(cat(“Illegal CASE selector type: ”)(namef(d)) 

(seq-stat)), 

->case-coverage(d)(h) 

—► error 

(cat(“Incomplete CASE coverage for type: ”) 

(namef(d))(seq-stat)), 

c(t 2 )) 


77 




case-type-ok(d) 

= is-boolean-tdesc?(d)V is-bit-tdesc?(d) 
case-coverage(d)(h) 

— (is-boolean-tdesc?(d)A set-card(h)= 2) 
V (is-bit-tdesc?(d)A set-card(h)= 2) 

set-card(x) = length(x) 


A Stage 3 VHDL CASE statement consists of a selector expression followed by one or more 
case alternatives, each consisting of sequential statements preceded either by a nonempty 
sequence of discrete ranges or by the reserved word OTHERS. This discrete range sequence 
defines a case selection set for the particular case alternative. 

The Stage 3 VHDL concrete syntax allows the statements in a case alternative to be preceded 
by a list of discrete ranges and expressions; for uniformity, in the Phase 1 abstract syntax 
(generated by the Stage 3 VHDL parser) these expressions are converted into equivalent 
one-element discrete ranges. 

A CASE statement must be checked for the following: 

• The basic type of all the case selection sets (and thus of the expressions that define 
the discrete ranges) must be the same, and must match that of the selector expression. 
In Stage 3 VHDL, the only such basic types are BOOLEAN, BIT, INTEGER, and 
enumeration types (including CHARACTER). 

• Every expression of every discrete range in a CASE statement must be static, i.e., must 
have a value defined by Phase 1. This enables the contents of each case selection set 
to be determined during Phase 1. The OTHERS alternative, if present, defines a case 
selection set that is the complement of the union of the other case selection sets with 
respect to the set of values associated with the basic type. The BOOLEAN basic 
type is associated with the set of truth values {FALSE, TRUE}, the BIT basic type 
with the set of bit values {0, 1}, the INTEGER basic type with the set of integers 
{..., -2, -1, 0, 1, 2, ...}, the CHARACTER basic type with the set {(CHAR 
0), ..., (CHAR 127)} of ASCII-128 character representations, and an arbitrary 
enumeration type with the set of its enumeration literals. 

• The selection sets for each case alternative must be mutually disjoint, and their union 
must be the set associated with the basic type of the selector expression. The case 
selection subsets defined by the discrete ranges within each case alternative need 
not be disjoint. Note that a CASE statement with a selection expression of basic 
type INTEGER must have an OTHERS alternative, as the set of integers cannot be 
covered by a finite number of case alternatives, each with only a finite number of 
(finite) discrete ranges. 

The basic type of the selector expression is first determined. Then semantic function AT is 
invoked with this basic type to check the case alternatives. Refer to the discussion of AT, 
which returns the union of the case selection sets associated with all of the case alternatives, 
a union that must cover the set associated with the selector expression’s basic type. 


78 



(SST7) SST j[ LOOP atmark id seq-stat* opt-id ]] (p)(c)(t) 

= let q = find-looplabel-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 
(id £ labels —► error(cat(“Duplicate loop label: ”)($(q)(id))), 
let ti = enter(t)(q)(*LAB* )((e,cons(id,labels))) in 
(-mull(opt-id)A opt-id / id 
—► error 

(cat(“Loop ”)(id)(“ ended with incorrect identifier: ”)(opt-id)), 
let t 2 = enter(ti)(q)(id)(<e,*LOOPNAME* ,p>) in 
let pi = %(p)(id) in 

let t 3 = enter(extend(t 2 )(p)(id))(pi)(*UNlT* )(<e,*LOOP* >) in 
let t 4 = enter(t 3 )(pi)(*LAB* )(<£,£>) in 
let t 5 = enter(t 4 )(p)(id)(<£,*LOOPNAME* ,p>) in 
let ci = At. SST [seq-stat* J (pi)(c)(t) in 
c i(t*))) 

(SST8) SST [ WHILE atmark id expr seq-stat* opt-id ] (p)(c)(t) 

= let q = find-looplabel-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 
(id £ labels —► error(cat(“Duplicate loop label: ”)($(q)(id))), 
let ti = enter(t)(q)(*LAB* )((e,cons(id,labels))) in 
(opt-id rfz e A opt-id ^ id 
—► error 

(cat(“Loop ”)(id)(“ ended with incorrect identifier: ”)(opt-id)), 
let t 2 = enter(ti)(q)(id)(<c,*LOOPNAME* ,p>) in 
let pi = %(p)(id) in 

let t 3 =enter(extend(t 2 )(p)(id))( Pl )(*UNIT* )(<e*LOOP* >) in 
let t 4 = enter(t 3 )(pi)(*LAB* )(<e,e>) in 
let t 5 = enter(t 4 )(p)(id)(<e *LOOPNAME* >P >) in 
let ci = At. SST [seq-stat* J (pi)(c)(t) in 
RT [expr ] (pi)(k)(t s ) 
where 
k = A(w,e),t. 

(is-boolean?(w)—► ci(t), 
error 

(cat(“Non-boolean condition in WHILE statement: ”) 
(tdesc(w)))))) 

(SST9) SST [ FOR atmark id ref discrete-range seq-stat* opt-id ] (p)(c)(t) 

= let q = find-looplabel-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 
(id £ labels —► error(cat(“Duplicate loop label: ”)($(q)(id))), 
let ti = enter(t)(q)(*LAB* )((e,cons(id,labels))) in 
(-mull(opt-id)A opt-id ^ id 
—► error 

(cat(“Loop ”)(id)(“ ended with incorrect identifier: ”)(opt-id)), 
let t 2 = enter(t 1 )(q)(id)(<e,*LOOPNAME* ,p>) in 
let pi = %(p)(id) in 

let t 3 =enter(extend(t 2 )(p)(id))( Pl )(*UNIT*)(<£*LOOP* >) in 
let t 4 = enter(t 3 )(pi)(*LAB* )(<e,e>) in 
let t 6 = enter(t 4 )(p)(id)(<e *LOOPNAME* ,p>) in 

let (direction,expri ,expr 2 ) = discrete-range in 
RT [ expri ] (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

let di = tdesc(wi) in 
RT [ expr 2 ] (p)(k 2 )(t) 


79 



where 

k 2 = A(w 2 ,e 2 ),t. 

let d 2 = tdesc(w 2 ) in 
(match-types(di ^ 2 ) 

— let decl = (DEC ,CONST , 

(hd(hd(tl(ref)))), 

(hd(di)), 

hd(tl(discrete-range))) in 
DTI decl l( Pl )(tt)(u)(t 5 ), 
error 

(cat(“Bounds type mismatch in FOR statement: ”) 
(seq-stat))) 

where 

u — At 6 .ci(t 6 ) 

where ci = At 7 . SST |[ seq-stat* J (pi )(c)(t 7 ))) 


find-looplabel-env(t)(p) 

= let tg = tag(t(p)(*UNIT* )) in 

(nuU(p)V tg e (*PROCESS* *PROCEDURE* *FUNCTION* *LOOP*) - p, 
find-looplabel-env(t)(rest(p))) 


In Stage 3 VHDL, entering a loop (i.e., a LOOP, WHILE or FOR statement) creates a new com¬ 
ponent environment of the TSE, just as in the case of entering a subprogram (see below). 
The identifier that is the loop’s label must be checked for uniqueness among the identifiers 
used thus far as labels in the innermost enclosing program unit (process, procedure, func¬ 
tion, or loop). If unique, the identifier is appended to the innermost enclosing unit’s label 
identifier list (bound to the special identifier *LAB* of the corresponding environment). 

A *LOOPNAME* descriptor is then entered into the current environment. The resulting 
TSE is extended to reflect loop entry; the *UNIT* entry in the extended TSE is set 
to *LOOP* to associate the extended TSE with the loop, and the *LOOPNAME* 
descriptor is also entered into the extended TSE. This latter descriptor is used by EXIT 
statements contained in this loop to validate the visibility of their loop names. 

In the case of a WHILE loop, the basic type of the iteration control expression is checked to 
be BOOLEAN, and the loop body is also checked by SST. 

In the case of a FOR loop, the basic types of the iteration bounds expressions are checked to 
match, the implicit declaration of the iteration parameter is processed by semantic function 
DT, and the loop body is checked with SST. 

(SST10) SST I EXIT atmark opt-dotted-name opt-expr J (p)(c)(t) 

= (null(find-loop-env(t)(p)) 

—► error(cat(“EXIT statement not in a loop: ”)(seq-stat)), 

(null(opt-dotted-name)—► ci(t), 
name-type(opt-dotted-name)(e)(p)(t)(v) 
where 

v = Aw.(tag(tdesc(w))^ *LOOPNAME* 

—► error(cat(“Not a loop name: ”)(namef(tdesc(w)))), 

ci(t))) 

where 

ci = At.(nuil(opt-expr)—► c(t), 
let expr = opt-expr in 


80 



RT | expr J (p)(k)(t) 

where 

k = A(w,e),t. 

(is-boolean?(w)—► c(t), 
error 

(cat(“Non-boolean condition in EXIT statement: ”) 
(tdesc(w)))))) 


An EXIT statement must be contained within a loop; otherwise, an error is raised. If an 
exit control expression is present, its basic type is checked; if not BOOLEAN, an error is 
raised. 

(SSTll) SST IT CALL atmark ref | (p)(c)(t) 

= let expr = ref in 
ET I expr ] (p)(k)(t) 
where 
k = A(w,e),t. 

(tag(tdesc(w))= *VOID* — 1 - c(t), 
error(cat(“Invalid procedure call: ”)(seq-stat))) 


A procedure call statement boils down to an expression that is a Stage 3 VHDL name. This 
expression is checked by ET, and must have a VOID basic type. 

(SST12) SST [ RETURN atmark opt-expr J (p)(c)(t) 

= let d = context(t)(p) in 
let tg = tag(d) 

and cname — namef(d) in 
(null(opt-expr) 

— (tg £ ^PROCEDURE* 

—► error 

(cat(“RETURN without expression in context of non-procedure: ”) 
(cname)(seq-stat)), 

c(t)), 

(tg / ^FUNCTION* 

—► error 

(cat(“RETURN with expression in context of non-function: ”) 
(cname)(seq-stat)), 
let expr = opt-expr in 
RT I expr ] (p)(k)(t) 
where 
k = A(w,e),t. 

(map-match-types(tdesc(w))(extract-rtypes(signatures(d))) 

—■ c (t). 

error 

(cat(“Incorrect return expression type in function: ”) 
(cname)(seq-stat))))) 


context(t)(path) 

= let d = t(path)(*UNIT* ) in 

(d = ^UNBOUND* — context(t)(rest(path)), 

(case tag(d) 

(♦PROCEDURE* ,*FUNCTION* *PACKAGE* ) — t(rest(path))(last(path)), 
OTHERWISE — context(t)(rest(path)))) 


81 



extract-rtypes(signatures) 

= (null(signatures)—► e, 

cons(tdesc(rtype(hd(signatures))),extract-rtypes(tl(signatures)))) 


RETURN statements have two forms, depending on the PROCEDURE or FUNCTION context in 
which they can appear. Auxiliary semantic function context returns the descriptor of the 
smallest subprogram or package enclosing the program text whose local environment is at 
the end of the current path. It is first determined whether the RETURN statement is in the 
proper context. If so, then if the RETURN statement has an expression, its basic type must 
be equal to the basic type of the result type of the function in which it appears. 


(SST13) SST [WAIT atmark ref* opt-expri opt-expr 2 J (p)(c)(t) 

— let ci = At.let d = lookup(t)(p)(*SENS* ) in 
(-inull(sensitivity(d)) 

—* error 

(cat(“WAIT statement ”)(seq-stat) 

(“ illegal in process with sensitivity list: ”) 

(last(p))), 

let C 2 = At.(null(opt-expr 2 )—► c(t), 
let expr 2 = opt-expr 2 in 
RT | expr 2 ] (p)(k 2 )(t) 
where 

k 2 = A(w 2 ,e 2 ),t 2 . 

(is-time?(w 2 )~-► c(t 2 ), 
error 

(cat(“Ill-typed timeout clause in WAIT statement: ”) 
(seq-stat)))) in 
(null(opt-expri H c 2 (t), 
let expri = opt-expri in 
RT [ expn 1 (p)(ki)(t) 
where 

ki = A(wi,ei),ti. 

(is-boolean?(wi )—*• c 2 (ti), 
error 

(cat(“Non-boolean condition clause in WAIT statement: ”) 
(seq-stat))))) in 

check-wait-refs(seq-stat) (ref* )(p)(ci)(t) 

check-wait-refs(seq-stat)(ref*)(p)(c)(t) 

~ (null( [[ ref* J )—► c(t), 
let ref = hd(ref*) 

and ci = At.check-wait-refs(seq-stat)(tl(ref*))(p)(c)(t) in 
check- wait-ref (seq-stat) (ref) (p)(ci)(t)) 


check-wait-ref(seq-stat) (ref) (p)(c)(t) 

= let expr = ref in 

ET [ expr J (p)(k)(t) 

where 

k = A(w,e),t. 

let d — tdesc(w) in 

(d = ^UNBOUND* —*• error(cat(“Unbound identifier: 

(is-sig?(w)—» c(t), 
error 

(cat(“Mon-signal ”)(ref) 

(“ in sensitivity clause of WAIT statement: ”) 
(seq-stat)))) 


'^(namef 

(d))), 


82 




Semantic equation SST13 specifies the static semantics of the WAIT statement, which con¬ 
sists of a sensitivity list ref, an optional condition opt-expr!, and an optional timeout 
expression opt-expr 2 . First, auxiliary semantic function check-wait-refs recursively tra¬ 
verses the sensitivity list, checking that each ref denotes a declared signal. Next, a descriptor 
for the special identifier *SENS* is looked up, and if its sensitivity field is nonempty, then 
the WAIT statement illegally appears inside a PROCESS statement with a sensitivity list. If 
present, the condition is checked to have basic type BOOLEAN. Finally, if present, the 
timeout expression is checked to have basic type TIME. 


6.5.9 Case Alternatives 

(ATO) AT [ e ] (d)(p)(y)(t) = y(emptyset)(t) 

(ATI) AT [ case-alt* case-alt J (d)(p)(y)(t) 

= AT [ case-alt* J (d)(p)(yi)(t) 
where 
yi = Ahi,ti. 

AT [case-alt ] (d)(p)(y 2 )(ti) 
where 
y 2 = Ah 2 ,t 2 . 

(case-overlap(d)((hi ,h 2 )) 

—► error 

(cat(“Overlapping case alternatives for type: ”) 
(namef(d))), 

y(case-union(d)((hi ,h 2 )))(t 2 )) 

(AT2) AT [ CASECHOICE discrete-range* seq-stat* 1 (d)(p)(y)(t) 

= DRT [ discrete-range* J (d)(p)(yi)(t) 
where 

yi = Ah,ti. 

SST [seq-stat* ] (p)(c)(ti) 
where c = At 2 .y(h)(t 2 ) 

(AT3) AT [ CASEOTHERS seq-stat* ] (d)(p)(y)(t) 

= SST [ seq-stat* ] (p)(c)(t) 
where 

c = Ati .y((is-boolean-tdesc?(d)—► {FALSE ,TRUE }, 
is-bit-tdesc?(d)~** {0,1}, 
is-integer-tdesc?(d)—► INT , 
is-enumeration-tdesc?(d)—♦ ENUM , 
error 

(cat( u Illegal CASE selector type: ”)(namef(d))(case-alt)))) 
(ti) 


ca^e-overlap(d)(x,y) 

— ((is-integer-tdesc?(d)A (x = INT V y = INT )) 

V (is-enumeration-tdesc?(d)A (x = ENUM V y = ENUM )) 

- ff , 

x n y emptyset) 
case-union(d)(x,y) 

= (is-integer-tdesc?(d)A (x = INT V y = INT ) —► INT , 

is-enumeration-tdesc?(d)A (x = ENUM V y = ENUM ) —► ENUM , 
xUy) 


83 



Semantic function AT processes each case alternative in turn, beginning with the last one. 
As the case selection set of each alternative is computed, it is checked for disjointness with 
the union of the selection sets of the preceding alternatives. If disjoint, then the union of 
these two case selection sets is returned; otherwise an error is raised. 

Note that the case selection set of an OTHERS alternative (represented by CASEOTHERS in 
the abstract syntax) is always disjoint from the union of the selection sets of the preceding 
alternatives, because (1) a CASE statement can contain at most one such alternative; (2) if 
such an alternative is present, it must be the last alternative; and (3) the case selection set 
of an OTHERS alternative is the relative complement of the union of the case selection sets 
of the preceding alternatives. 

AT invokes the semantic function DRT to compute the case selection set defined by the 
sequence of discrete ranges of a particular case alternative. 


6.5.10 Discrete Ranges 

(DRTO) DRT [ e ] (d)(p)(y)(t) = y(emptyset)(t) 

(DRTl) DRT [discrete-range discrete-range* ] (d)(p)(y)(t) 
= DRT [ discrete-range ] (d)(p)(yi )(t) 
where 
yi = Ahi,ti. 

DRT [ discrete-range* ] (d)(p)(y 2 )(ti) 
where y 2 = Ah 2j t 2 .y(hi U h 2 )(t 2 ) 


A sequence of discrete ranges is processed in order, from left to right. 


(DRT2) DRT [ discrete-range ] (d)(p)(y)(t) 

= let (direction,exprx ,expr 2 ) = discrete-range in 
RT [expri ] (p)(ki)(t) 
where 

ki = A(wi,ei),ti. 

(^match-types(d,tdesc(wi)) 

—► error(cat(“CASE type mismatch: ”)(d)(tdesc(w 1 ))), 
ei = *UNDEF* 

error(cat(“Non-static CASE expression: ”) [expri | ), 
RT [expr 2 ] (p)(k 2 )(ti) 
where 


k 2 


A(w 2 ,e 2 ),t 2 . 

(-■match-types(d, tdesc(w 2 )) 

—► error 

(cat(“CASE type mismatch: 


e 2 = *UNDEF* 


”)(d)(tdesc 

(w 2 ))), 


— error 

(cat(“Non-static CASE expression: ”) 
I expr 2 ]] ), 

y(mk-set(d)((direction,ei ,e 2 )))(t 2 ))) 


mk-set(d)(direction,ei ,e 2 ) 
= (case tag(d) 


*BOOL* 


84 



-+ (ei = e 2 -* {ei}, 

(direction = TO -» (e, = FALSE A e 2 = TRUE — {FALSE ,TRUE }, emptyset), 

(e, = TRUE A e 2 = FALSE — {TRUE .FALSE }, emptyset))), 

♦BIT* 

— (ei = e 2 — {ei}, 

(direction = TO —* (ei = 0 A e 2 = 1 —► {0,1}, emptyset), (ei = 1 A e 2 = 0 -* {1.0}, emptyset))), 

(*INT* ,*INT_TYPE* ) 

—► (direction = TO 

—► (ei < e 2 —► {ei} U mk-set(d)((direction,(ei-fl),e 2 )), emptyset), 

(ei > e 2 —► {ei} U mk-set(d)((direction,(ei-l),e 2 )), emptyset)), 

*ENUMTYPE* 

(direction = TO —* mk-enum-set(literals(d))(ei )(e 2 ), 
mk-enum-set(reverse(literals(d)))(ei )(e 2 )), 

OTHERWISE —► error(cat(“Illegal CASE expression type tag: ”)(tag(d)))) 

mk-enum-set(id + )(idi )(id 2 ) 

= let ni = position(idi )(id + ) 

and n 2 = position (id 2 )(id + ) in 
(n 2 < ni —► e, 

nth-tl(ni )(reverse(nth-tl(length(id + ) — (n 2 + 1))( re verse (id + ))))) 
nth-tl(n)(x) = (n = 0 —► x, nth-tl(n—l)(tl(x))) 
position(a)(x) = position-aux(a)(x)(0) 
position-aux(a)(x)(n) 

= (null(x)-+ fF, (a = hd(x)—► n, position-aux(a)(tl(x))(l+n))) 
reverse(x) = reverse-aux(x)(e) 

reverse-aux(x)(y) = (null(x)—► y, reverse-aux(tl(x))(cons(hd(x),y))) 


Semantic function DRT receives a case selector expression’s basic type from AT. DRT 
detects a mismatch between the basic type of a discrete range and that of the selector 
expression; it also detects the presence of nonstatic expressions in a discrete range. Case 
selection sets are constructed by the function mk-set (“make set”), which takes a type 
descriptor and a pair of translated static expressions that represent a discrete range (that 
the expressions are static is checked in Phase 1) and returns the corresponding set of values. 


6.5.11 Waveforms and Transactions 

(WTl) WT | WAVE transaction* ] (p)(k)(t) = TRT [ transaction* ] (p)(k)(t) 

(TRTl) TRT J transaction transaction* J (p)(k)(t) 

= TRT [ transaction J (p)(ki)(t) 
where 

ki = A(wi,ei),t l . 

let di = tdesc(wi) in 
(null(transaction*)—► k((wi ,ei ))(ti), 
let transaction]*" = transaction* in 
TRT |[ transaction^ ]] (p)(k 2 )(ti) 
where 

k 2 = A(w 2 ,e 2 ),t 2 . 

let d 2 = tdesc(w 2 ) in 


85 



(-imatch-types(di ,d 2 ) 
error 

(cat(“Type mismatch for waveform transactions: ”) 
(transaction) (hd(transaction^))), 
ei ^ *UNDEF* A e 2 ^ *UNDEF* 

—* (ei > e 2 
—► error 

(cat(“Nonascending times for waveform transactions: ”) 
(transaction)(hd(transactionjJ'))), 
k((w 2 ,e 2 ))(t 2 )), 
k((w 2 ,ei))(t 2 ))) 

(TRT2) TRT I TRANS expr opt-expr ] (p)(k)(t) 

= RT I expr | (p)(ki)(t) 
where 

ki = A(wi,ei),ti. 

(null(opt-expr)—► k((wi,0))(ti), 
let expr 2 = opt-expr in 
RT [expr 2 J (p)(k 2 )(ti) 
where 

k 2 = A(w 2 ,e 2 ),t 2 . 

(-iis-time?(w 2 ) 

error 

(cat(“Transaction has ill-typed time expression: ”) 
(tdesc(w 2 ))), 
e 2 ? *UNDEF* 

— (e 2 < 0 
—* error 

(cat(“Transaction has negative time expression: ”) 

(e 2 )), 

k((w l5 e 2 ))(t 2 )), 
k((wj ,e 2 ))(t 2 ))) 


6.5.12 Expressions 

(ETO) ET [c ] ( P )(k)(t) = k((e,e))(t) 

(ETl) ET [ FALSE ] (p)(k)(t) = k((mk-type((CONST VAL) )(bool-type-desc(t)),FALSE ))(t) 

(ET2) ET [ TRUE ] (p)(k)(t) = k((mk-type((CONST VAL) )(bool-type-desc(t)),TRUE ))(t) 

(ET3) ET [ BIT bitlit J (p)(k)(t) 

= k((mk-type((CONST VAL) )(bit-type-desc(t)),|J [ bitlit ] ))(t) 

(ET4) ET [ NUM constant J (p)(k)(t) 

= k((mk-type((CONST VAL) )(int-type-desc(t)),N [ constant ] ))(t) 


(ET5) ET [ TIME constant time-unit | (p)(k)(t) 

= let normalized-constant = (case time-unit 

FS —)► N [ constant J , 

PS —*• lOOOxN [ constant ] , 

NS —+ lOOOOOOxN [ constant ] , 

US —* lOOOOOOOOOxN [ constant | , 

MS 1000000000000 xN ([constant J , 
SEC — lOOOOOOOOOOOOOOOxN [constant J , 


86 



MIN — 60x(1000000000000000xN |[ constant ] ), 

HR 3600x(1000000000000000xN ft constant 1 ), 

OTHERWISE 

error 

(cat(“Illegal unit name for physical type TIME: ”) 
(time-unit))) in 

k((mk-type((CONST VAL) )(time-type-desc(t)),normalized-constant))(t) 

(ET6) ET l CHAR constant ] (p)(k)(t) 

= let expr = (CHAR ,constant) in 

let d = lookup(t)((STANDARD) )(expr) in 
k((type(d),idf(d)))(t) 


(ET7) ET ft BITSTR bit-lit* ] (p)(k)(t) 

= let expr* = bit-lit* in 
(null(expr*) 

- k((mk-type((CONST VAL) )(lookup(t)(e)(BIT_VECTOR )),*UNDEF* ))(t), 

list-type(expr*)(p)(t)(vv) 

where vv = Aw*.array-type(BIT_VECTOR )(expr*)(w*)(t)(p)(k)) 

(ET8) ET l STR char-lit* ] (p)(k)(t) 

= let expr* = char-lit* in 

(null(expr*)—► k((mk-type((CONST VAL) )(lookup(t)(e)(STRING )) *UNDEF* ))(t), 

list-type(expr* )(p)(t)(vv) 

where vv = Aw*.array-type(STRING )(expr*)(w*)(t)(p)(k)) 

array-type(array-type-name)(expr*)(w*)(t)(p)(k) 

= let d = tdesc(hd(w*)) in 
(chk-array-type(d)(tl(w*)) 

—► let array-type-desc = array-type-desc 

(new-array-type-name( array-type-name) )(e)(p)(tt) 

(TO )((NUM 1) )((NUM ,length(w*)))(d) in 
k((mk-type(tmode(hd(w*)))(array-type-desc),*UNDEF* ))(t), 
error(cat( “Array aggregate of inhomogeneous type: ”)(expr*))) 

chk-array-type(d)(w*) 

= (null(w*)—► tt, 

match-types(d)(tdesc(hd(w*)))—♦ chk-array-type(d)(tl(w*)), 

ff) 

(ET9) ET l REF name ] (p)(k)(t) 

= name-type(name)(e)(p)(t)(v) 

where 

v = Aw.let d = tdesc(w) in 

(second(tmode(w))= TYP 

—*■ error(cat( “Wrong context for a type: ”)(namef(d))(expr)), 
tag(d)= *OBJECT* — k((type(d),value(d)))(t), 
tag(d)= *ENUMELT* - k((type(d),idf(d)))(t), 
k((w,*UNDEF* ))(t)) 


(ET10) ET [ PAGGR expr* J (p)(k)(t) 

= (length(expr*)= 1 

—► let expr = hd(expr*) in 
ET l expr J (p)(k)(t), 
iist-type(expr*)(p)(t)(vv) 

where vv = Aw*.array-type(*ANONYMOUS* )(expr*)(w*)(t)(p)(k)) 


87 


(ETll) ET [ unary-op expr ] (p)(k)(t) 

= BUL [ ex P r 1 (p)(ki)(t) 

where ki = A(w,e),t.OTl [ unary-op J (k)((w,e))(t) 

(ET12) ET [ binary-op expri expr 2 ] (p)(k)(t) 

= RT l expri ] (p)(ki)(t) 

where 

ki = A(w 1 ,ei),t. 

RT [ expr 2 ] (p)(k 2 )(t) 
where k 2 = A(w 2 ,e 2 ),t. 

OT2 If binary-op | (k)((wi,ei ))((w 2 ,e 2 ))(t) 

(ET13) ET [ relational-op expri expr 2 | (p)(k)(t) 

= EX [[expri 1 (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT [ expr 2 ] (p)(k 2 )(t) 
where 

k 2 = A(w 2 ,e 2 ),t. 

-Q Tg [relational-op ] (k)((wi,ei))((w 2 ,e 2 ))(t) 


(RT1) RT [ expr ] (p)(k)(t) 

= ET [ expr ] (p)(ki)(t) 
where 

ki = A(w,e),t. 

let tm — tmode(w) 

and d = tdesc(w) in 
(second(tm)= ACC —► error 

(cat(“Non-value (an access): ”)(expr)), 

second(tm)= OUT 
—► error 

(cat(“Cannot dereference formal OUT parameter: ”)(expr)), 
second(tm)= VAL A is-void-tdesc?(d) 

—► error(cat(“Void value: ”)(expr)), 

let wi = ((second(tm)= AGR — (DUMMY AGR) , (DUMMY VAL) ),tdesc(w)) in 

k((wi ,e))(t)) 


(OTl.l) OTl | unary-op ] (k)(w,e)(t) 

= let d = tdesc(w) in 

(match-types(d,argtypesl(unary-op)(d)) 

—► k((restypel(unary-op)(d),resvall(unary-op)(e)(d)))(t), 
error 

(cat(“Argument type mismatch for unary operator: ”)(unary-op)(d))) 

argtypesl (unary-op)(d) 

= (case unary-op 
NOT 

—► (is-boolean-tdesc?(d)V is-bit-tdesc?(d)—► d, 
argtypesl-error(unary-op)(d)), 

(PLUS ,NEG ,ABS ) 

—► (is-integer-tdesc?(d)V is-time-tdesc?(d)^ d, 
argtypesl-error(unary-op)(d)), 

OTHERWISE — error 

(cat(“Unrecognized Stage 3 VHDL unary operator: ”)(unary-op))) 


88 


argtypesl-error(unary-op)(d) 

— error(cat(“Unary operator ”)(unary-op)(“ not implemented for type: ”)(d)) 
restypel(unary-op)(d) = mk-type((DUMMY VAL) )(d) 
resvall(unary-op)(e)(d) 

= (e = HJNDEF* — *UNDEF* , 

(case unary-op 
NOT 

—*■ (is-boolean-tdesc?(d)—> -ie, 

is-bit-tdesc?(d)—► invert-bit(e), 

*UNDEF* ), 

PLUS - e, 

NEG - -e, 

ABS —► abs(e), 

OTHERWISE — *UNDEF* )) 

invert-bit(bitlit) = mk-bit-simp-symbol((--bitlit)+l) 

mk-bit-simp-symbol(bitlit) 

= (case bitlit 

0 — (BS 0 1) , 

1 — (BS 1 1) , 

OTHERWISE —► error(cat(“Can't construct simp symbol for bit: ”)(bitlit))) 


(OT2.1) QT2 l binary-op J (k)(wi,ei)(w 2 ,e 2 )(t) 

= let di = tdesc(wi) 

and d 2 = tdesc(w 2 ) in 
(argtypes2(binary-op)((di ,d 2 )) 

-► k((restype2(binary-op)((di ,d 2 ))(t), 

resval2((di ,d 2 ))(binary-op)((ei ,e 2 ))))(t), 

error 

(cat(“Argument type mismatch for binary operator: ”)(binary-op)(di) 

(d 2 ))) 

(OT2.2) OT2 l relational-op ] (k)(wj,e 1 )(w 2 ,e 2 )(t) 

= let di = tdesc(wi) 

and d 2 = tdesc(w 2 ) in 
(argtypes2(relational-op)((di ,d 2 )) 

k((mk-type((DUMMY VAL) )(bool-type-desc(t)), 
resval2((di ,d 2 ))(relational-op)((ei ,e 2 ))))(t), 

error 

(cat(“Argument type mismatch for relational operator: ”) 
(relational-op) (di )(d 2 ))) 

argtypes2(op)(di ,d 2 ) 

= (case op 

(AND ,NAND ,OR ,NOR ,XOR ) 

—► (case hd(di) 

BOOLEAN —► is-boolean-tdesc?(d 2 )V argtypes2-error(op)(di )(d 2 ), 

BIT —* is-bit-tdesc?(d 2 )V argtypes2-error(op)(di )(d 2 ), 

OTHERWISE — argtypes2-error(op)(d 1 )(d 2 )), 

(ADD ,SUB ) 

—+ (case hd(di) 

(UNIVERSAL.INTEGER JNTEGER ) 

—► match-types(di)(d 2 )V argtypes2-error(op)(di )(d 2 ), 


89 



(TIME ,REAL ) —► di = d 2 V argtypes2~error(op)(di )(d 2 ), 

OTHERWISE —+ argtypes2-error(op)(di )(d 2 )), 

MUL 

—*• (case hd(di) 

(UNIVERSAL-INTEGER INTEGER ,REAL ) 

—► match-types(di)(d 2 )V is-time-tdesc?(d 2 ), 

TIME 

—*■ is-integer-tdesc?(d 2 )V is-real-tdesc?(d 2 ), 

OTHERWISE —► argtypes2-error(op)(di )(d 2 )), 

DIV 

—► (case hd(di) 

(UNIVERSAL JNTEGER INTEGER ,REAL ) 

—*■ match-types(di)(d 2 )V argtypes2-error(op)(di )(d 2 ), 

TIME 

—*■ is-integer-tdesc?(d 2 )V is-real-tdesc?(d 2 ), 

OTHERWISE —► argtypes2-error(op)(di )(d 2 )), 

(MOD ,REM ) 

—► (case hd(di) 

(UNIVERSALJNTEGER INTEGER ) 

—► is-integer-tdesc?(d 2 )V argtypes2-error(op)(di )(d 2 ), 

OTHERWISE —► argtypes2-error(op)(dj )(d 2 )), 

EXP 

—► (case hd(di) 

(UNIVERSAL JNTEGER INTEGER ,REAL ) 

—* is-integer-tdesc?(d 2 )V argtypes2-error(op)(di )(d 2 ), 

OTHERWISE —♦ argtypes2-error(op)(di )(d 2 )), 

CONCAT 

—► (is-bit-tdesc?(di) 

—+ is-bit-tdesc?(d 2 )V is-bit vector-tdesc?(d 2 ), 

(is-bit-tdesc?(d 2 ) 

—+ is-bit-tdesc?(di )V is-bitvector-tdesc?(di), 

(is-array-tdesc?(di )A is-array-tdesc?(d 2 ) 

—► match-array-type-names(idf(di ),idf(d 2 )) 

A match-types(elty(di),elty(d 2 )), 
argtypes2-error(op)(di )(d 2 )))), 

(EQ ,NE ) —♦ match-types(di,d 2 )V argtypes2-error(op)(di )(d 2 ), 

(LT ,LE ,GT ,GE ) 

—► (is-scaJar-tdesc?(di )A is-scalar-tdesc?(d 2 ) 

—► match-types(di)(d 2 )V argtypes2-error(op)(di )(d 2 ), 
is-bitvector-tdesc?(di )A is-bitvector-tdesc?(d 2 )— 1 ► tt, 
argtypes2-error(op)(di )(d 2 )), 

OTHERWISE —* error(cat(“Unrecognized Stage 3 VHDL operator: ”)(op))) 

argtypes2-error(op)(di )(d 2 ) 

= error(cat(“Operator ”)(op)(“ not implemented for pair of types: ”)(di)(d 2 )) 

restype2(binary-op)(di ,d 2 )(t) 

= (case binary-op 

(AND ,NAND ,OR ,NOR ,XOR ,ADD ,SUB ,MOD ,REM ,EXP) 

— mk-type((DUMMY VAL) )(d,), 

MUL 

—> (case hd(di) 

(UNIVERSALJNTEGER INTEGER ,REAL ) mk-type((DUMMY VAL) )(d 2 ), 
TIME — mk-type((DUMMY VAL) )(di), 

OTHERWISE —► error( “Shouldn’t happen!”)), 

DIV 

—► (case hd(di) 


90 



(UNIVERSAL-INTEGER ,INTEGER ,REAL ) -+ mk-type((DUMMY VAL) )(d 2 ), 
TIME 

—+ (case hd(d 2 ) 

(UNIVERSALJNTEGER ,INTEGER ,REAL ) — mk-type((DUMMY VAL) )(di), 
TIME -+ mk-type((DUMMY VAL) )(univint-type-desc(t)), 

OTHERWISE —v error( “Shouldn’t happen!”)), 

OTHERWISE —► error(“Shouldn't happen!”)), 

CONCAT —*• mk-type((DUMMY VAL) )(mk-concat-tdesc(di )(d 2 )(t)), 

OTHERWISE 

—♦ error(cat(“Unrecognized Stage 3 VHDL binary operator: ”)(binary-op))) 

mk-concat-tdesc(di )(d 2 )(t) 

= (is-bit-tdesc?(di )V is-bitvector-tdesc?(di) 

—+ array-type-desc 

(new-array-type-name(BIT_VECTOR ))(£)(e)(tt)(direction(di))(ib(di))(e) 

(bit-type-desc(t)), 
let idfi = idf(di) in 
array-type-desc 

(new-array-type-name((consp(idfi)—» hd(idfi), idfi )))(e)(e)(tt) 

(direction(di ))(lb(di ))(e)(elty(di))) 

resval 2 (di ,d 2 )(op)(el,e 2 ) 

= (el = *UNDEF* V e2 = *UNDEF* — *UNDEF* , 
let tg = tag(di) in 
(case tg 
*BOOL* 

—+ (case op 

AND —* el A e2, 

NAND —► —(el A e2), 

OR -h. el V e2, 

NOR — -(el V e2), 

XOR -► (el = e2 — ff, tt), 

EQ — el = e 2 , 

NE — el i=- e 2 , 

LT —* —el A e2, 

LE —► —el V e2, 

GT -+ el A —e2, 

GE el V —e2, 

OTHERWISE 
—► error 

(cat(“Unrecognized Stage 3 VHDL ( boolean’ binary operator: ”)(op))), 

*BIT* 

—► (case op 

AND 

—► (el = 1 A e2 = 1 —► mk-bit-simp-symbol(l), mk-bit-simp-symbol(O)), 

NAND 

—+ (el = 0 V e2 = 0 —► mk-bit-sirap-symbol(l), mk-bit-simp-symbol(O)), 

OR 

—► (el — 1 V e2 = 1 —► mk-bit-simp-symbol(l), mk-bit-simp-symbol(O)), 

NOR 

—+ (el = 0 A e2 = 0 —► mk-bit-simp-symbol(l), mk-bit-simp-symbol(O)), 

XOR —+ (el = e2 —> mk-bit-simp-symbol(O), mk-bit-simp-symbol(l)), 

EQ — el = e 2 , 

NE —► el 7 ^ e 2 , 

LT —► el = 0 A e2 — 1, 

LE —♦ el = 0 V e2 = 1, 

GT — el = 1 A e2 = 0, 


91 




GE —► el = 1 V e2 = 0, 

OTHERWISE 
—► error 

(cat(“Unrecognized Stage 3 VHDL 'bit 5 binary operator: ”)(op))), 

(*INT* ,*TIME* ) 

—► (case op 

ADD —► el+e2, 

SUB —► el—e2, 

MUL —► el xe2, 

DIV —► (e2 = 0 —* error(“Illegal division by zero!”), 
el/e2), 

MOD —► mod(el,e2), 

REM —► rem(el,e2), 

EXP —► el “ e2, 

EQ — el = e2, 

NE —► el ^ e2, 

LT —► el < e2, 

LE —► el < e2, 

GT — el > e2, 

GE —+■ el > e2, 

OTHERWISE 

—► error 

(cat( “Unrecognized Stage 3 VHDL ‘ integer’ binary operator: ”)(op))), 
*REAL* —► error(cat(“Floating point operator not yet implemented: ”)(op)), 
*ENUMTYPE* 

—► (case op 

EQ ^ el = e2, 

NE -•+ el e2, 

LT —► enum-lt(el)(e2)(literals(di)), 

LE —► enum-le(el)(e2)(literals(di)), 

GT —► enum-lt(e2)(el)(literals(di)), 

GE —+ enum-le(e2)(el)(Iiterals(di)), 

OTHERWISE 

—► error 

(cat(“Unrecognized Stage 3 VHDL 'enumeration type’ binary operator: ”) 
(op))), 

*ARRAYTYPE* — *UNDEF* , 

OTHERWISE 

—» error(cat(“Unrecognized Stage 3 VHDL binary operator type: ”)(tg)))) 

enum-lt(el)(e2)(enum-lits) 

= let elpos = position(el)(enum-lits) 

and e2pos = position(e2)(enum-lits) in 
elpos < e2pos 

enum-le(el)(e2)(enum-lits) 

= let elpos = positional)(enum-lits) 

and e2pos = position(e2)(enum-lits) in 
elpos < e2pos 


6.5.13 Primitive Semantic Equations 

(Nl) N J constant ] = constant 


(Bl) B [ bitlit | = bitlit 


92 



7 Interphase Abstract Syntax Tree Transformation 


Owing to the relative simplicity of the Stage 1 VHDL language subset, Phases 1 and 2 of 
the Stage 1 VHDL translator were able to use the same abstract syntax. 

Stage 2 VHDL was a considerably more sophisticated language subset. Consequently, it 
became convenient to allow Phase 2 of the VHDL translator for Stage 2 VHDL and subse¬ 
quent stages — viz. Stage 3 VHDL — to employ a different abstract syntax for the language 
than does Phase 1, for reasons discussed below. 

Accordingly, as the final act of Phase 1 translation of a given Stage 3 VHDL hardware 
description, an “interphase” abstract syntax tree transformation is performed that yields a 
new abstract syntax tree (AST) for use by Phase 2. This transformation does not modify 
the original AST. Although the resulting transformed AST may resemble the original in 
many respects, there will also be substantial differences. 

We should recall that in Phase 1, when abstract syntax trees are occasionally injected 
into the TSE, it is their transformed versions that are used; this occurs with array type 
descriptors created by functions process-slcdec and DT8, subprogram descriptors created 
by function process-subprog-body, and *SENS* (sensitivity list) descriptors updated 
with new refs by function SLT2. 


7.1 Interphase Semantic Functions 

The abstract syntax tree transformation is carried out by principal semantic functions 
DFX (design files), ENX (entity declarations), ARX (architecture bodies), PDX (port 
declarations), DX (declarations), CSX (concurrent statements), SLX (sensitivity lists), 
SSX (sequential statements), AX (case alternatives), DRX (discrete ranges), WX (wave¬ 
forms), TRX (transactions), MEX (reference lists), and EX and RX (expressions). These 
are assisted by several important auxiliary semantic functions, most notably the function 
transform-name. 

Following Phase 1 construction of the tree-structured environment (TSE), semantic func¬ 
tion DFX is applied to the original AST to initiate the transformation, which uses (but 
does not modify) the TSE. Once the AST transformation is complete, Phase 1 auxiliary 
semantic function phase2 is invoked with the transformed AST and the TSE as syntactic 
and semantic arguments, respectively, to initiate Phase 2 translation (see Section 8). 

Generally speaking, the AST-transforming semantic functions straightforwardly reconstruct 
their syntactic arguments from their transformed immediate syntactic constituents, with the 
following exceptions: 

• transformation of PORT declarations into SIGNAL declarations 

• “desugaring” of sensitivity lists in PROCESS statements: 
converting them into explicit final WAIT statements 

• “desugaring” of concurrent signal assignment statements: 


93 




converting them into equivalent PROCESS statements 

• “desugaring” of secondary units of physical type TIME: 
converting them into the base unit FS ( femtoseconds ) 

• disambiguation of refs as either array references or subprogram calls 

• overload resolution between BOOLEAN and BIT operators 

• overload resolution between INTEGER and REAL operators 

7.2 Transformed Abstract Syntax of Names 

An important case in point is the translation of names, e.g. refs, which are heavily over¬ 
loaded: the Phase 1 semantic function name-type, which checks them and determines 
their type, is necessarily complex. Given the identical abstract syntax, a Phase 2 semantic 
function for refs would exhibit analogous complexity; instead, it was deemed preferable to 
transform the abstract syntax of refs into a form more suitable for Phase 2. 

Thus, the abstract syntax of refs used in Phase 1 is: 


ref ::= REF name 

name ::= id | name id | name expr* 


while the abstract syntax of refs used in Phase 2 is: 


ref ::= REF basic-ref 
basic-ref ::= modifier + 
modifier SREF id + id 

I INDEX expr 
I SELECTOR id 
I PARLIST expr* 

Although not reflected in the syntax shown above, a basic-ref (basic reference) must begin 
with a simple reference SREF id+ id, which has for convenience been classified with the 
modifiers. The id is the root identifier , and id+ is the TSE access path for this ref. The 
structures following this root basic reference are called modifiers. An INDEX modifier 
denotes an array reference, a SELECTOR modifier denotes a record field access (not used 
in Stage 3 VHDL), and a PARLIST modifier denotes a subprogram call. This linear 
arrangement of a simple reference followed by zero or more modifiers makes the translation 
of refs in Phase 2 relatively straightforward, as the components of a ref are grouped from 
the left and thus a ref can be translated from left to right. 


94 



7,3 Interphase Semantic Equations 

Most of the semantic equations for the interphase abstract syntax tree transformation, being 
straightforward, will be displayed without comment. 


7.3.1 Stage 3 VHDL Design Files 

(DFX1) DFX f DESIGN-FILE id pkg-decl* pkg-body* use-clause* ent-decl arch-body ] (t) 
= let p 0 = %(e)(id) in 

(DESIGN-FILE ,id,DX | pkg-decl* J ( P o)(t),DX [ pkg-body* ] (p 0 )(t), 

DX [[ use-clause* ] (po)(t), ENX f ent-decl ] (p 0 )(t), 

ARX l arch-body ] (po)(t)) 


7.3.2 Entity Declarations 

(ENX1) ENX [ ENTITY id port-decl* decl* opt-id ] (p)(t) 

= insert-phasel-hook 

((ENTITY ,id,PDX [ port-decl* J (%(p)(id))(t),DX [ decl* ] (%(p)(id))(t),opt-id)) 
(ent-decl) 


7.3.3 Architecture Bodies 

(ARX1) ARX [ ARCHITECTURE idi id 2 decl* con-stat* opt-id ] (p)(t) 

= let pi = %(%(p)(id 2 ))(idi) in 

(ARCHITECTURE ,idi,id 2 ,DX l decl* ] (pi)(t), CSX [ con-stat* ] (pi)(t),opt-id) 


7.3.4 Port Declarations 

(PDXO) PDX [[ e ] (p)(t) = e 


(PDXl) PDX I port-decl port-decl* J (p)(t) 

= cons(PDX |[ port-decl ] (p)(t),PDX [ port-decl* J (p)(t)) 


(PDX2) PDX [ DEC PORT id + mode type-mark opt-expr | (p)(t) 
= (DEC ,SIG ,id + ,type-mark, 
let expr = opt-expr in 
second( EX ([ expr J (p)(t))) 


(PDX3) PDX [ SLCDEC PORT id + mode slice-name opt-expr J (p)(t) 
= (SLCDEC ,SIG ,id + , 

let (type-mark,discrete-range) = slice-name in 
(type-mark, DRX J discrete-range ] (p)(t)), 
let expr = opt-expr in 
secondf EX J expr J (p)(t))) 


95 



7.3.5 Declarations 


(DXO) DX | £ ] (p)(t) = e 


(DX1) DX [ ded decl* ] (p)(t) = consQDX [ decl J (p)(t),DX [ ded* ] (p)(t)) 

(DX2) DX [ pkg-ded pkg-ded* ] (p)(t) 

= cons(DX [ pkg-ded J (p)(t),DX [ pkg-ded* ] (p)(t)) 

(DX3) DX [ pkg-body pkg-body* ] (p)(t) 

= consQDX [ pkg-body J (p)(t),DX [ pkg-body* ] (p)(t)) 

(DX4) DX [ use-clause use-dause* ] (p)(t) 

= consf DX [ use-dause J (p)(t),DX [ use-dause* J (p)(t)) 

(DX5) DX [ DEC object-dass id + type-mark opt-expr ] (p)(t) 

— (DEC , object-class, id + ,type-mark, 
let expr = opt-expr in 
second ( EX [ expr ] (p)(t))) 


(DX6) DX [ SLCDEC object-class id + slice-name opt-expr J (p)(t) 
= (SLCDEC ,object-class,id + , 

let (type-mark,discrete-range) = slice-name in 
(type-mark,DRX [[ discrete-range ] (p)(t)), 
let expr — opt-expr in 
second (EX [ expr ] (p)(t))) 

(DX7) DX [ ETDEC id id+ ] (p)(t) = (ETDEC ,id,id+) 

(DX8) DX [ ATDEC id discrete-range type-mark ]] (p)(t) 

= (ATDEC ,id,DRX [ discrete-range ] (p)(t),type-mark) 

(DX9) DX [ PACKAGE id ded* opt-id ] (p)(t) 

= (PACKAGE ,id,DX [decl* ] (%(p)(id))(t),opt-id) 


(DX10) DX [ PACKAGEBODY id decl* opt-id J (p)(t) 

= let d = t(p)(id) in 

let q = %(path(d))(id) in 
(PACKAGEBODY ,id,DX J decl* ] (q)(t),opt-id) 


(DX11) DX l PROCEDURE id proc-par-spec* ] (p)(t) 

= let d = t(p)(id) in 

(null(body(d))-H* error(cat(“Missing subprogram body: 
(PROCEDURE ,id,proc-par-spec*)) 


”)(namef 

(d))), 


(DX12) DX [[ FUNCTION id func-par-spec* type-mark ] (p)(t) 

= let d = t(p)(id) in 

(null(body(d))—► error(cat(“Missing subprogram body: ”)(namef 

(d))), 


(FUNCTION ,id,func-par-spec*,type-mark)) 


(DX13) DX |[ SUBPROGBODY subprog-spec decl* seq-stat* opt-id J (p)(t) 

= let (tg,id,par-spec*,type-mark) = subprog-spec in 
let pi = %(p)(id) in 
(SUBPROGBODY , 
let ded = subprog-spec in 

EX I decl ] (p)(t),DX [ded* J ( P i)(t),SSX [ seq-stat* ] (pi)(t),opt-id) 


96 



(DX14) DX [[ USE dotted-name + J (p)(t) = (USE ,dotted-name + ) 


(DX15) DX J STDEC id type-mark opt-discrete-range ] (p)(t) 

= (STDEC ,id,type-mark, 

(nuU(opt-discrete-range)—► e, 

let (direction,expri ,expr 2 ) = opt-discrete-range in 
(direction,second( EX J expri 1 (p)(t)),second( EX [[ expr 2 | (p)(t))))) 


(DX16) DX [[ ITDEC id discrete-range ] (p)(t) 

= (ITDEC ,id, 

let (direction,expri ,expr 2 ) = discrete-range 
(direction,second (EX [ expri ] (p)(t)),second(EX [[ expr 2 J (p)(t)))) 


7,3.6 Concurrent Statements 

(CSXO) CSX [e] (p)(t) = £ 

(CSX1) CSX [con-stat con-stat* ] (p)(t) 

= cons( CSX [ con-stat J (p)(t),CSX [ con-stat* J (p)(t)) 

(CSX2) CSX [ PROCESS id ref* decl* seq-stat* opt-id J (p)(t) 

= let pi =s %(p)(id) in 

(PROCESS ,id,DX [ decl* ] ( Pl )(t), 
let seq-stat J = (null (seq-stat*) 

— ((WAIT ,(AT ,mk-atmark()),ref* ,£,«)), 

(null(ref*)-*- seq-stat*, 
append 

(seq-stat*, 

((WAIT ,(AT ,mk-atmark()),ref*,£,£))))) in 
SSX [ seq-stat^ ] (pi )(t),opt-id) 

(CSX3) CSX [ SEL-SIGASSN atmark delay-type id expr ref selected-waveform + ] (p)(t) 

= let expr* = cons(expr, 

collect-expressions-from-selected-waveforms 
(selected-waveform*)) in 
let ref* = delete-duplicates 

(collect-signals-from-expr-list(expr* )(t)(p)(e:)) in 
let case-alt* = construct-case-alternatives 

(ref)(delay-type)(selected-waveform*) in 
let case-stat = (CASE ,atmark,expr,case-alt*) in 
let process-stat = (PROCESS ,id,ref*,e,(case-stat),id) in 
insert-phasel-hook(CSX [[process-stat J (p)(t))(con-stat) 

(CSX4) CSX [ COND-SIGASSN atmark delay-type id ref cond-waveform* waveform ] (p)(t) 
= let expr* = nconc 

(collect-expressions-from-conditional-waveforms 
(cond-waveform*), 

collect-transaction-expressions(second(waveform))) in 
let ref* = delete-duplicates 

(collect-signals-from-expr-list(expr* )(t)(p)(e)) in 
(null(cond-waveform* ) 

—► let sig-assn-stat = (SIGASSN ,atmark,delay-type,ref,waveform) in 
let process-stat = (PROCESS ,id,ref*,e,(sig-assn-stat),id) in 


97 



insert-phasel-hook( CSX [ process-stat ]] (p)(t))(con-stat), 
let cond-part+ = construct-cond-parts 

(ref) (delay-type)(cond-waveform*) 

and else-part = ((SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform)) in 
let if-stat = (IF ,atmark,cond-part + ,else-part) in 
let process-stat = (PROCESS ,id,ref*,e,(if-stat),id) in 
insert-phasel-hook(CSX [[process-stat ] (p)(t))(con-stat)) 


7.3.7 Sensitivity Lists 

(SLXO) SLX ITc H (p)(t) = e 

(SLX1) SLX [ ref ref* | (p)(t) = cons(SLX [ ref ] (p)(t),SLX [ ref* ] (p)(t)) 

(SLX2) SLX [ REF name J (p)(t) 

= let expr = ref in 

second( EX [ expr ] (p)(t)) 


7.3.8 Sequential Statements 

(SSX1) SSX [[ seq-stat seq-stat* | (p)(t) 

— consf SSX l seq-stat J (p)(t),SSX [[ seq-stat* ] (p)(t)) 

(SSX2) SSX l NULL atmark J (p)(t) = (NULL ,atmark) 

(SSX3) SSX [[ VARASSN atmark ref expr J (p)(t) 

= (VARASSN ,atmark, 
let expr 0 = ref in 

secondf EX |[ expro ] (p)(t)),second(EX [ expr | (p)(t))) 

(SSX4) SSX [[ SIGASSN atmark delay-type ref waveform J (p)(t) 

= (SIGASSN ,atmark,delay-type, 
let expr = ref in 

second ( EX [ expr ] (p)(t)), WX [[ waveform ] (p)(t)) 

(SSX5) SSX [[ IF atmark cond-part + else-part ] (p)(t) 

= let seq-stat* = else-part in 

(IF ,atmark,transform-if(cond-part + )(p)(t),SSX [[seq-stat* ] (p)(t)) 

transform-if(cond-part*)(p)(t) 

= (null(cond-part*)—► e, 

let (expr,seq-stat*) = hd(cond-part*) in 
cons((second(EX [ expr ] (p)(t)),SSX [ seq-stat* | (p)(t)), 
transform-if(tl(cond-part*))(p)(t))) 

(SSX6) SSX [ CASE atmark expr case-alt + ] (p)(t) 

= (CASE ,atmark,second(EX [[ expr ] (p)(t)),AX [[ case-alt + J (p)(t)) 

(SSXT) SSX f LOOP atmark id seq-stat* opt-id J (p)(t) 

= (LOOP , at mark, id, SSX | seq-stat* ] (%(p)(id))(t), opt-id) 


98 




(SSX8) SSX [ WHILE atmark id expr seq-stat* opt-id ] (p)(t) 

_ (WHILE , atmark,id,secondfEX J expr ] (%(p)(id))(t)), 

SSX l seq-stat* ] (%(p)(id))(t),opt-id) 

(SSX9) SSX [ FOR atmark id ref discrete-range seq-stat* opt-id ] (p)(t) 

= (FOR ,atmark,id,secondQEX [ ref ] (%(p)(id))(t)), 

DRX [[discrete-range ] (%(p)(id))(t),SSX [[ seq-stat* ] (%(p)(id))(t), opt-id) 

(SSX10) SSX [ EXIT atmark opt-dotted-name opt-expr ] (p)(t) 

= (EXIT ,atmark,opt-dotted-name, 
let expr = opt-expr in 
second ( EX [[ expr J (p)(t))) 

(SSX11) SSX [ CALL atmark ref] (p)(t) 

= (CALL ,atmark, 
let expr = ref in 
secondf EX [ expr ] (p)(t))) 

(SSX12) SSX [[ RETURN atmark opt-expr ] (p)(t) 

= (RETURN ,atmark, 
let expr = opt-expr in 
secondf EX [ expr ] (p)(t))) 

(SSX13) SSX [ WAIT atmark ref* opt-expn opt-expr 2 ] (p)(t) 

= let expri = opt-expri 

and expr 2 = opt-expr 2 in 

(WAIT ,atmark,MIX [ reF ] (p)(t),second(EX [ exprj ] (p)(t)), 
secondfEX [[ expr 2 ] (p)(t))) 


7.3.9 Case Alternatives 

(AXO) AX [ e ] (p)(t) = e 

(AX1) AX [[ case-alt case-alt* ] (p)(t) 

— consf AX l case-alt ] (p)(t),AX [[ case-alt* ] (p)(t)) 

(AX2) AX l CASECHOICE discrete-range+ seq-stat* ] (p)(t) 

= (CASECHOICE ,DRX [ discrete-range + ] (p)(t), SSX [ seq-stat* ] (p)(t)) 

(AX3) AX l CASEOTHERS seq-stat* ] (p)(t) = (CASEOTHERS ,SSX [[ seq-stat* ] (p)(t)) 


7.3.10 Discrete Ranges 

(DRXO) DRX [ e J (p)(t) = e 

(DRX1) DRX [discrete-range discrete-range* ] (p)(t) 

= consf DRX [ discrete-range ] (p)(t), DRX [ discrete-range* ] (p)(t)) 

(DRX2) DRX [ discrete-range ] (p)(t) 

= let (direction,expri ,expr 2 ) = discrete-range in 

(direction.secondf EX [ expri ] (p) ft)),secondf EX [ expr 2 ] (p)(t))) 


99 



7.3.11 Waveforms and Transactions 

(WXl) WX [ WAVE transaction* J (p)(t) = (WAVE ,TRX [ transaction* ] (p)(t)) 


(TRXl) TRX [ transaction transaction* | (p)(t) 

= (null(transaction*)—+ ( TRX [transaction ] (p)(t)), 
let transaction^ = transaction* in 
consf TRX [ transaction J (p)(t),TRX [ transaction^ | (p)(t))) 

(TRX2) TRX [ TRANS expr opt-expr | (p)(t) 

= (TRANS ,second ( EX [expr ] (p)(t)), 
let expri = opt-expr in 
second (EX [ expri ] (p)(t))) 


7.3.12 Expressions 

(MEXO) MEX [ e ] (p)(t) = e 

(MEX1) M EX [ ref ref* ] (p)(t) = cons(second(EX [ ref ] (p)(t)), MEX [ ref* ] (p)(t)) 

(EXO) EX [ e ] (p)(t) = (void-type-desc(t),e) 

(EXl) EX [ FALSE ] (p)(t) = (bool-type-desc(t), (FALSE) ) 

(EX2) EX [ TRUE J (p)(t) = (bool-type-desc(t),(TRUE) ) 

(EX3) EX [ BIT bitlit ] (p)(t) = (bit-type-desc(t),(BIT ,bitlit)) 

(EX4) EX [ NUM constant J (p)(t) = (int-type-desc(t),(NUM .constant)) 

(EX5) EX [ TIME constant time-unit J (p)(t) 

= let normalized-constant = (case time-unit 

FS —► N |f constant J , 

PS —► lOOOxN [ constant ] , 

NS —► lOOOOOOxN [constant ] , 

US —► 1000000000 xN [ constant ] , 

MS —+ 1000000000000XN [constant | , 

SEC — 1000000000000000XN [ constant ] , 

MIN -+ 60x(1000000000000000xN [constant J ), 

HR — 3600x(1000000000000000xN [constant ] ), 
OTHERWISE 
—► error 

(cat(“Illegal unit name for physical type TIME: ”) 
(time-unit))) in 

(time-type-desc(t),(TIME ,normalized-constant,FS )) 

(EX6) EX [ CHAR constant ] (p)(t) 

= let d = lookup(t)((STANDARD) )(expr) in 
(type(d),(CHAR constant)) 

(EXT) EX [ BITSTR bit-lit* ] (p)(t) = (e,(BITSTR ,bit-lit*)) 

(EX8) EX [ STR char-lit* ] (p)(t) = (e,(STR ,char-lit*)) 

(EX9) EX [ REF name ] (p)(t) — transform-name(name)(e)(e)(p)(t) 


100 



transform-name(name)(w)(astJ )(p)(t) 

= (null(w) 

let wi = lookup2(t)(p)(e)(hd(name)) in 
(wi = *UNBOUND* error(cat(“Unbound identifier: ”)(S(p)(hd(name)))), 
(second(tmode(wi ))= TYP —► transform-name(tl(name))(wi )(e)(p)(t), 
transform-name 

(tl(name))(wi)(((SREF ,path(tdesc(wi)),idf(tdesc(wi)))))(p)(t))), 
let d = tdesc(w) 

and tm = tmode(w) in 
let tg = tag(d) in 
(null(name) 

— (second(tm)^ TYP —► transform-name-aux(*CONVERSION* )(d)(astj), 
transform-name-aux(tg)(d)(astJ)), 
let x = hd(name) in 
(consp(x) 

let ast* — transform-list(x)(p)(t) in 
(second(tm)= TYP 
—► transform-name 

(tl(name))(w)((TYPECONV ,hd(astj),%(path(d))(idf(d))))(p)(t), 
second(tm)= OBJ A is-array-tdesc?(d) 

—► transform-name 

(tl(name))((tm,elty(d))) 

(nconc(astJ,((INDEX ,hd(astj)))))(p)(t), 

(second(tm)= OBJ A is-array?(type(d))) 

V (second(tm)e (REF VAL) A is-array-tdesc?(d)) 

—v transform-name 
(tl(name)) 

((second(tm)= OBJ 

—► mk-type(tmode(type(d)))(elty(tdesc(type(d)))), 
mk-type(tm)(elty(d)))) 

(nconc(astJ,((INDEX ,hd(astj)))))(p)(t), 
transform-name 

(tl(name))(extract-rtype(d)) 

(nconc(astJ,((PARLIST f astl))))(p)(t)), 

((second(tm)= OBJ A is-record?(type(d))) 

V (second(tm)E (REF VAL) A is-record-tdesc?(d)) 

—► let di = (second(tm)= OBJ —► tdesc(type(d)), d) in 
let d2 = lookup-record-fieid(components(di ))(x) in 
transform-name 

(tl(name))(mk-type(tm)(d 2 ))(nconc(astJ,((SELECTOR ,x)))) 

(p)(t). 

second(tm)= OBJ A is-record-tdesc?(d) 

—► let d2 = lookup-record-field(components(d))(x) in 
transform-name 

(tl(name))(mk-type(tm)(d 2 ))(nconc(astJ,((SELECTOR ,x)))) 

(P)(t), 

let wi = lookup-local(x)(%(path(d))(idf(d)))(p)(t) in 

( Wl = ^UNBOUND* 

—► error(cat(“Unknown identifier: ”)($(%(path(d))(idf(d)))(x))), 
transform-name 

(tl(name))(wi)(((SREF ,path(tdesc(wi )),idf(tdesc(wi)))))(p) 

(t)))))) 

transform-name-aux(tg)(d)(ast) 

= (case tg 

♦OBJECT* — (second(type(d)),(REF ,ast)) t 
♦ENUMELT* —► (second(type(d)),(ENUMLIT ,idf(d))), 


101 



(♦PROCEDURE* ,*FUNCTION* ) 

—► (second(rtype(hd(signatures(d)))), 

(REF ,nconc(ast,((PARLIST ,e))))), 
♦CONVERSION* — (d.ast), 

♦PACKAGE* — (d,(REF ,ast)), 

OTHERWISE — (d,(REF ,ast))) 

transform-Iist(x)(p)(t) 

= (null(x)—► e, 

let expr = hd(x) in 

cons(second( EX J expr ] (p)(t)),transform-list(tl(x))(p)(t))) 


The functions transform-name, transform-name-aux, and transform-list produce the 
linear form of the basic references discussed above. 

(EX10) EX [ PAGGR expr* J (p)(t) 

= (length(expr*)= 1 

let expr — hd(expr*) in 
EX [ expr J (p)(t), 

(e,(PAGGR ,ex-paggr(expr*)(p)(t)))) 


(EXll) EX l unary-op expr J (p)(t) 

— let (d,e) = EX | expr ] (p)(t) in 

(case unary-op 
PLUS — (d,e), 

NOT —*■ (d,(scalar-op(unary-op)(d),e)), 

NEG —► (d,(scalar-op(unary-op)(d),e)), 

ABS —*■ (d,(scalar-op(unary-op)(d),e)), 

OTHERWISE 
—► error 

(cat(“Unrecognized Stage 3 VHDL unary operator: ”)(unary-op))) 

(EX12) EX | binary-op expn expr 2 ]] (p)(t) 

= let (di,ei) = EX [[ expn ] (p)(t) in 
let (d 2 ,e 2 ) = EX [ expr 2 ] (p)(t) in 
(di ,(scalar-op(binary-op)(di ),ei,e 2 )) 

(EX13) EX | relational-op expn expr 2 ] (p)(t) 

— let (di,ei) = EX [expri J (p)(t) in 

let (d 2 ,e 2 ) = EX [ expr 2 1 (p)(t) in 
(bool-type-desc(t),(scalar-op(relational-op)(di ),ei ,e 2 )) 

scalar-op(op)(d) 

= (is-bit-tdesc?(d)V is-bitvector-tdesc?(d)—+ bits-op(op), 
is-real-tdesc?(d)—* real-op(op), 
op) 

bits-op(op) 

= (case op 

EQ -► EQ , 

NE —► NE , 

LT —► LT , 

LE — LE , 

GT GT , 

GE —► GE , 


102 



NOT -> BNOT , 

AND — BAND , 

NAND — BNAND , 

OR - BOR, 

NOR - BNOR , 

XOR - BXOR, 

OTHERWISE —► error(cat(Undefined bitwise operator: )(op))) 


real-op(op) 

= (case op 

EQ -► EQ , 

NE -♦ NE , 

LT — RLT , 

LE — RLE , 

GT — RGT, 

GE - RGE, 

NEG — RNEG, 

ABS — RABS, 

ADD — RPLUS , 

SUB - RMINUS , 

MUL — RTIMES , 

DIV - RDIV , 

EXP — REXPT , 

OTHERWISE —► error(cat(Undefined ‘real 1 operator: )(op))) 


The functions scalar-op, bits-op, and real-op do overload resolution between INTEGER, 
BIT, and REAL operators. 

(RX1) RX [ expr ] (p)(t) = EX [ expr ] (p)(t) 


103 





8 Phase 2: State Delta Generation 


If Phase 1 of the Stage 3 VHDL translator completes without error, then after the interphase 
abstract syntax tree transformation has been accomplished (see Section 7), Phase 2, state 
delta generation, can proceed. Several kinds of checks have already been performed on the 
hardware description in Phase 1, the most significant being the detection of missing prior 
declarations of items such as variables and labels, the improper use of names, and static 
type checking. Thus, these checks do not have to be duplicated in Phase 2. 

Phase 2 receives from Phase 1 the transformed abstract syntax tree (AST) for the hardware 
description, together with the tree-structured environment (TSE) — a complete record of 
the name/attribute associations corresponding to the hardware description’s declarations 
and whose structure reflects that of the description. The TSE remains fixed throughout 
Phase 2. It contains all definitions needed to execute its corresponding Stage 3 VHDL 
hardware description, and Phase 1 has ensured that only that portion of the TSE visible at 
any given textual point of the description can be accessed during Phase 2. With the aid of 
the TSE, Phase 2 incrementally generates SDVS Simplifier assertions and state deltas. 


8.1 Phase 2 Semantic Domains and Functions 

The formal description of Phase 2 translation consists of semantic domains and semantic 
functions , the latter being functions from syntactic to semantic domains. Compound se¬ 
mantic domains are defined in terms of primitive semantic domains. Similarly, primitive 
semantic functions are unspecified (their definitions being understood implicitly) and the 
remaining semantic functions are defined (by syntactic cases) via semantic equations. 

The principal Phase 2 semantic functions (and corresponding Stage 3 VHDL language 
constructs to which they assign meanings) are: DF (design files), EN (entity declarations), 
AR (architecture bodies), D (declarations), CS (concurrent statements), SS (sequential 
statements), W (waveforms), TRM and TR (transactions), ME and MR (expression 
fists), E and R (expressions), T (expression types), B (bit literals), and N (numeric literals). 

Each of the principal semantic functions requires an appropriate syntactic argument — an 
abstract syntactic object (tree) produced by the interphase abstract syntax tree transforma¬ 
tion (see Section 7). Most of the semantic functions take (at least) the following additional 
arguments: 


• the tree-structured environment (TSE) generated in Phase 1; 

• a path , indicating the currently “visible” portion of the TSE; 

• a continuation , specifying which Phase 2 semantic function to invoke next; 

• a universe structure ; and 

• an execution stack. 


105 



In the absence of errors, the Phase 2 semantic functions return a list of Simplifier assertions 
and state deltas. Moreover, E and R also return a translated expression and list of guard 
formulas. Guard formulas are inserted in the precondition of generated state deltas to 
ensure that certain conditions are met in the proof in which the state deltas appear. For 
example, if an array name is indexed by an expression, then Phase 2 generates a guard 
formula asserting that the index value is not out of range. 

The execution state manipulated by Phase 2 translation involves two components: a universe 
structure (see Section 8.2.2) and an execution stack (see Section 8.2.3). An analogy with 
conventional denotational semantics can be applied: the execution state corresponds to the 
store, translated expressions and guard formulas correspond to expression values, and state 
delta/assertion lists correspond to non-error final answers. 

When state deltas are generated by a semantic function, the continuation that is input to 
that function plays a slightly unconventional role: the result of applying to an execution 
state the continuation, or other continuations derived from the continuation, is appended to 
the postconditions of the generated state deltas. In the absence of errors, the item appended 
represents a list of state deltas. Such a continuation is evaluated and applied only when the 
state delta in whose postcondition it appears is applied. 

For example, an IF statement having no ELSE part generates two state deltas: one for the 
case in which its condition evaluates to true, the other for the false case. The continuation 
for the true case represents the execution of the body of the IF statement succeeded by 
the execution of the statement following the IF statement. The continuation for the false 
case skips the body, and proceeds directly to the statement following the IF statement. 
Whichever of these two state deltas is applied determines which continuation is evaluated 
and applied to an execution state, and therefore which additional state deltas are subse¬ 
quently generated. 


8.1.1 Phase 2 Semantic Domains 

The semantic domains and function types for Phase 2 of the Stage 3 VHDL translator are 
as follows. 

Primitive Semantic Domains 


Bool = 
Bit = 
Char = 
n : N = 

{FALSE, TRUE} 

{(BS 0 1), (BS 1 1)} 

{(CHAR 0), ..., (CHAR 127)} 
{0,1,2,...} 

id : Id 
Sysld 



Simplifier propositional (boolean) constants 
Simplifier bit constants (length 1 bitstrings) 
Simplifier character constants 
Simplifier natural number constants 

identifiers 

system-generated identifiers (disjoint from Id) 


t : TEnv 
d : Desc 
v : UStruct 


106 


tree-structured environments (TSEs) 
descriptors (see Section 6.2) 
universe structures (see Section 8.2.2) 



stk : Stk 


execution stacks (see Section 8.2.3) 


e : TExpr 
trans : TTrans 
f, guard : GForm 


translated expressions 
translated transactions 
lists of guard formulas 


sd : SD 
Assert 


state deltas 

SDVS Simplifier assertions 


Error 


error messages 


Compound Semantic Domains 

elbl : Elbl = Id + Sysld 

p, q: Path = Elbl* 

qname: Name = Elbl (. Elbl)* 

d : Dv — Desc 

r : Env = Id -+ (Dv + {*UNBOUND*}) 


TSE edge labels 
TSE paths 
qualified names 

denotable values (descriptors) 
environments 


Tmode = {PATH} X Id* + type modes 

({CONST, VAR, SIG, DUMMY) x 
{VAL, OUT, REF, OBJ, ACC, TYP}) 


w : Type = Tmode x Desc 

u : Dc = UStruct —* Stk —► Ans 
c : Sc = Dc 

k : Ec = (TExpr x GForm) —► Sc 
h : Me = (TExpr* x GForm*) -> Sc 
wave-cont : Wc = (TTrans* X GForm*) —► Sc 
trans-cont : Tc = (TTrans x GForm) —► Sc 

Ans = (SD + Assert)* + Error 


types 

declaration fe concurrent statement continuations 

sequential statement continuations 

expression continuations 

expression list continuations 

waveform continuations 

transaction continuations 

final answers 


8.1.2 Phase 2 Semantic Functions 

The semantic functions for Phase 2 of the Stage 3 VHDL translator are as follows. 


DF : 

Design 

->■ TEnv —> Ans 


design file dynamic semantics 

EN : 
AR : 

Ent —► TEnv —> Path —» Dc - 
Arch —► TEnv -*■ Path —► Dc 

+ Dc 
-*■ Dc 

entity declaration dynamic semantics 
architecture body dynamic semantics 

D : 

Dec* -* 

TEnv —>■ Path —► Dc 

- Dc 

declaration dynamic semantics 


107 



CS : 

CStat* 

-* TEnv —*■ Path —► Dc —*■ Dc 

concurrent statement dynamic semantics 

SS : 

SStat* —»■ TEnv —*• Path —* Sc -+ Sc 

sequential statement dynamic semantics 

W : 

TRM : 
TR : 

Wave —» 

Trans* - 

Trans —; 

TEnv —► Path —* Wc —► Sc 
-* TEnv —► Path — * Wc -* Sc 
► TEnv —♦ Path —> Tc -+ Sc 

waveform dynamic semantics 
transaction list dynamic semantics 
transaction dynamic semantics 

ME : 
MR : 

E : 

R : 

Expr* — 
Expr* - 
Expr —> 
Expr —► 

*■ TEnv Path —> Me —»■ Sc 

► TEnv —► Path —»■ Me —> Sc 
TEnv —► Path —»• Ec —* Sc 
TEnv —»• Path —> Ec —> Sc 

expression list dynamic semantics [Lvalues) 
expression list dynamic semantics (r-values) 
expression dynamic semantics [Lvalues) 
expression dynamic semantics ( r-values ) 

T : 

Expr -> 

TEnv Path ->• Desc 

expression types 

B : 

N : 

BitLit —► Bit 

NumLit -» N 

bit values of bit literals (primitive) 
integer values of numeric literals (primitive) 


108 




8.2 Phase 2 Execution State 


As mentioned in Section 8.1, the execution state manipulated by Phase 2 translation consists 
of a universe structure and an execution stack. The purpose of this section is to elucidate 
the nature and role of these aspects of the execution state. 


8.2.1 Unique Name Qualification 

Except for quantification, the language of state deltas has no scoping, i.e., it is “flat.” Even 
with quantification, the state deltas generated by the Stage 3 VHDL translator certainly 
do not have a scoping structure that naturally parallels the scopes of their corresponding 
Stage 3 VHDL hardware description. Furthermore, even if there were such a correspondence 
between source (Stage 3 VHDL) and target (state deltas) scopes, it would still be convenient 
to generate unique names for the SDVS user to use in proofs. 

For example, a PROCESS statement may contain a declaration of a variable x of the same 
name as a signal in the enclosing architecture body. The inner instance of x can be distin¬ 
guished from the outer instance by prefixing or qualifying it with the name (user-supplied 
or system-generated) of the process in which the inner instance is declared. We shall call 
such a qualified name, derived from the static structure of the Stage 3 VHDL hardware 
description, a statically uniquely qualified name or SUQN . At the beginning of Phase 2 
translation (after the interphase AST transformation — see Section 7), the SUQN of any 
object (for which such a name makes sense) is recorded in the qid field associated with the 
object in the TSE. 

Another important kind of unique name qualification is based on the dynamic execution 
of a Stage 3 VHDL description. A program unit can be reentered, either by repetition or 
recursion, and local declarations in the reentered program will be re-elaborated, creating 
new dynamic instances of entities that cannot be distinguished on the basis of static program 
structure. In this case new names that are distinct dynamic instances of the same statically 
uniquely qualified name are sufficient to enable the SDVS user to distinguish all instances 
of names for use in proofs. The separate dynamic instances of a name are indicated by 
appending !n to it, where n is a dynamic instance index for that name (e.g. a.x, a.x!2, 
a.x!3, ..., where a.x!l is simply denoted a.x). These names are called dynamically uniquely 
qualified names (DUQNs). 

Only statically and dynamically uniquely qualified names appear in the state deltas gener¬ 
ated by Phase 2 translation. 


8.2.2 Universe Structure for Unique Dynamic Naming 

Given that there may be several dynamic instances of the same SUQN in a Stage 3 VHDL 
hardware description, Phase 2 translation employs a mechanism called a universe structure 
(together with functions that access and manipulate it) to manage the creation of new 
dynamic instances of each distinct SUQN, as well as to ensure that the correct dynamic 
instance of each SUQN is available at any given time. 


109 




A universe structure consists of four components: 


universe name : 

The name of the current universe. A universe name has the form z\u\n, where z is 
the name of the main program and n is the current universe’s ordinal number (n = 
1 , 2 ,...). 


universe counter : 

The current universe’s ordinal number. 

universe stack : 

A stack of universe names used to save and restore prior universes in accordance with 
the changes of environment in a Stage 3 VHDL hardware description. 

universe variables : 

The current universe’s environment of statically and dynamically uniquely qualified 
names. This is a list of entries of the form (SUQN, ordinal-number, ordinal- 
stack), one for each distinct SUQN. The ordinal number denotes the most recently 
created dynamic instance of that SUQN. The ordinal stack is a stack of this SUQN’s 
ordinal numbers, whose top element denotes the current dynamic instance of this 
SUQN. This stack is used to save and restore prior dynamic instances of this SUQN in 
accordance with the changes of environment in a Stage 3 VHDL hardware description. 


mk-initial-universe(z) 

= let uname = catenate(z,“\u”,l) in 

make-universe-data(uname, 1, (uname),((z, 1,(1)))) 

make-universe-data(uname,ucounter,ustack,uvars) 

= (uname, ucounter,ustack,uvars) 

universe-name(v) = hd(v) 

universe-counter(v) = second(v) 

universe-stack(v) = third(v) 

universe-vars(v) = fourth(v) 

push-universe(v,z,suqn*) 

= let ucounter = l+universe-counter(v) in 
let uname = catenate(z,“\u”,ucounter) in 
let ustack = cons(uname,universe-stack(v)) in 
make-universe-data 

(uname, ucounter,ustack,push-universe-vars(suqn*,universe-vars(v))) 

push-universe-vars(suqn* ,vars) 

= (null(suqn* )—► vars, 

let suqn = hd(suqn*) in 
let v = assoc(suqn,vars) in 

(null(v)—*■ push-universe-vars(tl(suqn*),cons(init-var(suqn),vars)), 
push-universe-vars(tl(suqn* ),cons(push-var(v),vars)))) 


no 



push-var(v) 

= let n = next-var(second(v)) in 
(hd(v),n,cons(n,third(v))) 

next-var(n) 

= (numberp(n)—> n+1, 

(symbolp(n)—► mk-exp2(ADD ,n,l), 
let m = third(n) in 

(numberp(m)—► mk-exp2(ADD ,second(n),m+l), 
mk-exp2(ADD ,second(n),mk-exp2(ADD ,m,l))))) 

init-var(suqn) = (suqn,1,(1)) 

pop-universe(v)(suqn*) 

= let ustack = tl(universe-stack(v)) in 
let uname = hd(ustack) in 
make-universe-data 

(uname,universe-counter(v),ustack, 
pop-universe-vars(suqn*)(universe-vars(v))) 

pop-universe-vars(suqn* ,vars) 

= (null(suqn*)—► vars, 

let suqn = hd(suqn*) in 
let v = assoc(suqn,vars) in 
pop-universe-vars(tl(suqn*),cons(pop-var(v),vars))) 

pop-var(v) = (hd(v),second(v),tl(third(v))) 

get-qualified-ids (suqn* )(v) 

= (null(suqn*)—► e, 

cons(qualified-id(hd(suqn* ))(v),get-qualified-ids(tl(suqn* ))(v))) 

qualified-id(suqn)(v) 

= let vars = universe-vars(v) in 

let suqn-triple = assoc(suqn,vars) in 
(suqn-triple 

—•> let n = hd(third(suqn-triple)) in 
name-qualified-id(suqn)(n), 
name-qualified-id(suqn)(l)) 

name-qualified-id (suqn)(n) 

= (new-declarations()—► (PLACELEMENT ,suqn,n), 

(n = 1 —► suqn, catenate(suqn,“! ”,n))) 


Currently, the only part of the universe structure that is actually used for dynamic name 
qualification is the universe variables component. Each time a program unit that may 
have a declarative part (packages, entities, architectures, processes, subprogram bodies) is 
entered, the current universe is saved and an updated universe structure is created by push- 
universe. The universe structure’s counter (ordinal) is incremented by one, a corresponding 
new universe name is created, and the old universe name is pushed onto the universe stack. 
In the universe variables component of the universe structure, the triple for each SUQN 
corresponding to each name declared in the unit’s declarative part (except types) is updated: 
the value of its ordinal is incremented by one and this new ordinal value is pushed onto the 
ordinal stack of the SUQN’s triple. Whenever any SUQN needs to be dynamically uniquely 


111 




qualified, the top element of its ordinal stack is used to find the index of the current dynamic 
instance of that SUQN. 

When such a program unit is exited, pop-universe restores the universe name by popping 
it from the universe stack. The ordinal stack of the triple of the SUQN of each (non-type) 
name declared in this unit is popped, restoring the current dynamic qualification of that 
SUQN to a former value. 

The functions get-qualified-ids, qualified-id, and name-qualified-id accomplish the 
dynamic qualification of SUQNs relative to a universe structure. 


8.2.3 Execution Stack 

The elements of the execution stack are descriptors that contain information to control nor¬ 
mal returns and exits from program units, as well as the undeclaration of objects, packages, 
subprograms, and formal parameters. 

There are several kinds of execution stack descriptors, and more detailed explanations of 
their roles will be provided at the points in the semantics where they are used. For now, we 
note that each descriptor has four components: an identifying tag ; an identifier , identifier 
sequence, or fully qualified name that associates the descriptor with some program unit; a 
path that may replace the current path to effect a change of environment; and a function, 
which may be a continuation or continuation transformer, that will effect a change of control 
and environment corresponding to the descriptor’s purpose. 

stack bottom : 

< *STKBOTTOM*, id, e, c > 

This descriptor is the execution stack “bottom marker,” used to terminate model 
execution and to prevent execution stack underflow. The identifier id is the name of 
the Stage 3 VHDL design file. 

package body exit : 

< *PACKAGE-BODY-EXIT*, id, p, u > 

This descriptor is pushed onto the execution stack just prior to the elaboration of 
a package body. The identifier id is the package name, and u: Dc is a declaration 
continuation that will continue execution (most likely elaboration) at the package 
body’s successor in the environment denoted by p. 

subprogram return : 

< *SUBPROGRAM-RETURN*, id, p, c > 

This descriptor is pushed onto the execution stack after a subprogram (procedure 
or function) is entered, but just before the elaboration of the subprogram’s local 
declarations. The identifier id is the subprogram name, and c: Sc is a continuation 
that will continue execution at the successor of the subprogram call in the environment 
denoted by p. 


112 



loop exit : 


< *LOOP-EXIT*, id, p, c > 

This descriptor is pushed onto the execution stack when a loop statement (LOOP, 
WHILE, or FOR) is entered. The identifier id is the loop label, and c: Sc is a continuation 
that will continue execution at the loop’s successor in the environment denoted by p. 

block exit : 

< *BLOCK-EXIT*, id, p, c > 

This descriptor is pushed onto the execution stack just before the elaboration of a FOR 
loop’s iteration parameter, which implicitly establishes a block scope. The identifier 
id is the FOR loop label, and c: Sc is a continuation that will continue execution at 
the FOR loop’s successor statement in the environment denoted by p. 

begin marker : 

< *BEGIN*, id, p, c > 

This descriptor is pushed onto the execution stack immediately after the local declara¬ 
tions of a subprogram, or the iteration parameter of a FOR loop, have been elaborated. 

undeclaration : 

< *UNDECLARE*, id+, p, g > 

This descriptor, pushed onto the execution stack when a subprogram is called, enables 
the eventual explicit undeclaration (upon subprogram exit) of the subprogram’s for¬ 
mal parameters and other locally declared objects. The identifier list id+ names the 
objects to be undeclared, and g: Sc —► Sc is a continuation transformer which, after 
carrying out the explicit undeclaration specified in g (thereby popping this *UNDE- 
CLARE* descriptor from the execution stack), continues execution by means of its 
continuation argument. 


113 



8.3 Special Functions 

Certain functions appearing in the semantic specification of Phase 2 translation are not 
defined denotationally, for either of two reasons: (1) their denotational description is too 
cumbersome or not well understood, or (2) they are used to construct SDVS-dependent 
representations of expressions or formulas. 

These functions, implemented directly in Common Lisp, are described below. 


8.3.1 Operational Semantic Functions 

To understand Phase 2 translation, it is important to recognize that in defining the seman¬ 
tics of the VHDL simulation cycle, the VHDL translator involves a significant operational 
component. This is to be distinguished from the semantics of sequential statements within 
processes, which the translator defines in a primarily denotational manner. 

We are referring here to our strategy, explained in Section 2, of designing aspects of a 
simulator kernel into the Stage 3 VHDL translator. After application of the state deltas 
specifying the behavior of one execution cycle for the active processes, the translator is 
responsible for: 


• determining the next VHDL clock time at which a driver becomes active or a process 
resumes; 

• advancing the SDVS state to this new time; and 

• generating the state delta that specifies the next sequential statement in the first 
resuming process for the new execution cycle. 

After a given resuming process suspends, its continuation is the textually next resuming 
process. 

It is the internal translator machinery to perform these tasks that is operationally defined 
— much of it embodied in a portion of the translator that is directly coded in Common Lisp, 
rather than described by semantic equations. The names of the Common Lisp functions 
serving this purpose are listed below. 

make-vhdl-process-elaborate 

make-vhdl-begin-model-execution 

make-vhdl-try-resume- next-process 

make-vhdl-process-suspend 

find-signal-structure 

name-driver 

init-scalar-signal 


114 



init-array-signal-to 

init-array-signal-downto 

mk-element-waves-aux 

get-loop-enum-param-vals 

eval-expr 


8.3.2 Constructing State Deltas 

The construction of state deltas is specified via functions mk-sd(z)(pre, comod, mod, 
post) and mk-sd-decl(z)(pre, comod, mod, post), which take five arguments: the 
design file name z (if p is the current path, this is always hd(p)) and representations of 
the precondition, comodification list, modification list, and postcondition of the state delta 
to be constructed. 

These functions are used to represent the construction of state deltas without specifying 
their exact representation, which is SDVS-dependent and not given here. The pre- and 
postconditions of a state delta are lists of formulas, each of which represents a formula 
that is the logical conjunction of the formulas in this list. If the precondition and comod 
list arguments of mk-sd and mk-sd-decl are c, then the precondition and comod list of 
the constructed state delta are (TRUE) and (ALL), respectively. Otherwise, the given 
arguments are used directly in the state delta. The postcondition may contain a state delta, 
which is usually represented as a statement continuation applied to an execution stack. 

mk-sd and mk-sd-decl are almost the same, the only difference being that a state delta 
created by mk-sd-decl is given a special tag that identifies its association with declaration 
elaboration rather than statement execution. 

For technical reasons, the comod list of every state delta is (ALL) and the mod list of every 
state delta must be nonempty. To ensure that a state delta’s mod list is never empty, mk- 
sd(z)( ... ) will always prefix z\pc to its mod list argument, where z\pc is a unique place 
(represented by a system identifier) in which z is the name of the Stage 3 VHDL hardware 
description being translated. This unique place is the name of a program counter whose 
value implicitly changes when any state delta is applied. This program counter place does 
not make any other kind of appearance in a translated Stage 3 VHDL hardware description. 

The notation of state deltas requires that certain symbols sometimes be prefixed to uniquely 
qualified names: the dot (.) and pound (#) symbols. The functions dot and pound, 
applied to uniquely qualified names, accomplish this. 

dot(placename) = (DOT ,placename) 

pound(placename) = (POUND ,placename) 


Finally, the two functions fixed-characterized-sds and subst-vars are employed by the 
Phase 2 semantics of procedure calls to implement the SDVS ojfline characterization mech¬ 
anism [18, 19], which will be incorporated in Stage 3 VHDL. 


115 



8.3.3 Error Reporting 


The few kinds of errors that can occur in Phase 2 are reported by the functions impl-error 
and execution-error. 

The function impl-error is used, for example, to report invalid arguments passed to the 
low-level utility functions mk-scalar-rel, mk-expl, and mk-exp2, although this should 
never occur. 

The function execution-error is used to report execution errors such as an empty execution 
stack, although again, such errors should never occur if Phase 1 has done its job. 


116 



8.4 Phase 2 Semantic Equations 


This section constitutes the heart of the present report. It documents the semantic equations 
and auxiliary semantic functions in terms of which Phase 2 of the Stage 3 VHDL translator 
— state delta generation -— is specified denotationally. 


8,4.1 Stage 3 VHDL Design Files 

(DF1) DF [ DESIGN-FILE id pkg-decl* pkg-body* use-clause* ent-decl arch-body ] (t) 

= let p 0 = %(e)(id) in 

let idi = hd(tl(ent-decl)) in 
let pi = %(p 0 )(idi) in 
let v = mk-initial-universe(id) 

and stk = (<*STKBOTTOM* ,id f e,e>) in 
(mk-disjoint(id,(dot(id))), 
mk-cover 

(dot(id),(catenate(id, “\pc”),VHDLTIME ^HDLTIME-PREVIOUS )), 

mk-scalar-decl(VHDLTIME ,(TYPE VHDLTIME) ), 
mk-scalar-decl(VHDLTIME_PREVIOUS ,(TYPE VHDLTIME) ), 
mk-rel(vhdltime-type-desc(t))((EQ , dot (VHDLTIME ),mk-vhdltime(0)(0))), 
mk-rel 

(vhdltime-type-desc(t)) 

((EQ ,dot(VHDLTIME-PREVIOUS ),mk-vhdltime(0)(0))), 
mk-decl-sd(id)(e)(e)(e)(ui (v)(stk))) 
where ui = Av,stk.D [pkg-decl* ] (t)(p 0 )(u 2 )(v)(stk) 
where u 2 = Av,stk.D [ pkg-body* J (t)(po)(u 3 )(v)(stk) 
where u 3 = Av,stk.D [[ use-clause* ] (t)(po)(u 4 )(v)(stk) 
where u 4 = Av,stk.EN [[ ent-decl ] (t)(po)(u 5 )(v)(stk) 
where U 5 = Av.stk. AR [ arch-body J (t)(pi)(ue)(v)(stk) 
where U6 = Av,stk.block-exit(v)(stk) 

mk-disjoint(id,lst) = cons(ALLDISJOINT ,cons(id,lst)) 

mk-cover(id,lst) = cons(COVERING ,cons(id,lst)) 

mk-scalar-decl(placename,place-type) = (DECLARE ,piacename,place-type) 

vhdltime-type-desc(t) = t((STANDARD) )(VHDLTIME ) 

mk-rel(d)(op,ei ,e 2 ) 

= let tg = tag(d) in 
(case tg 

(*BOOL* ,*BIT* ,*INT* ,*REAL* ,*TIME* ♦VHDLTIME* *ENUMTYPE* ,*VOID* ,*POLY* ) 

—► mk-scalar-rel(tg)((op,ei ,e 2 )), 

♦SUBTYPE* —► mk-scalar-rel(tag(base-type(d)))((op,ei ,e 2 )), 

♦INT-TYPE* —► mk-scalar-rel(tag(parent-type(d)))((op,ei ,e 2 )), 

♦WAVE* —► (EQ ,ei,e 2 ), 

♦ARRAYTYPE* 

—♦« (is-bitvector-tdesc?(d) 

—► (case op 
EQ 

—► (is-constant-bitvector?(ei)A is-constant-bitvector?(e 2 ) 

-+ (EQ ,cons(USCONC ,ei),cons(USCONC ,e 2 )), 
is-constant-bitvector?(e 2 )—► (EQ ,ei,cons(USCONC ,e 2 )), 
is-constant-bitvector?(ei )—*► (EQ ,cons(USCONC ,ei),e 2 ), 


117 




(EQ ,ei,e 2 )) } 

NE 

—► (is-constant-bitvector?(ei )A is-constant-bitvector?(e2) 

— (NEQ ,cons(USCONC ,ei),cons(USCONC ,e 2 )), 
is-constant-bitvector?(e 2 )—► (NEQ ,ei ,cons(USCONC 
is-constant-bitvector?(ei)—♦ (NEQ ,cons(USCONC ,ei),e 2 ), 
(NEQ , eil e 2 )), 

LT 

—^ (EQ ,(BS ,1,1), 

(is-constant-bitvector?(ei )A is-constant-bitvector?(e 2 ) 

(USLSS ,cons(USCONC ,e 1 ),cons(USCONC ,e 2 )), 
is-constant-bitvector?(e 2 )—+ (USLSS ,ei ,cons(USCONC ,e 2 )), 
is-constant-bitvector?(ei)—► (USLSS ,cons(USCONC ,ei),e 2 ), 
(USLSS ,e lf e 2 ))), 

LE 

- (EQ ,(BS ,1,1), 

(is-constant-bitvector?(ei )a is-constant-bitvector?(e 2 ) 

- (USLEQ ,cons(USCONC ,ei),cons(USCONC ,e 2 )), 
is-constant-bitvector?(e 2 )-+ (USLEQ ,ei ,cons(USCONC ,e 2 )), 
is-constant-bitvector?(ei)—► (USLEQ ,cons(USCONC ,ei),e 2 ), 
(USLEQ ,ei,e 2 ))), 

GT 

- (EQ ,(BS ,1,1), 

(is-constant-bitvector?(ei )A is-constant-bitvector?(e 2 ) 

- (USGTR ,cons(USCONC , ei ),cons(USCONC ,e 2 )), 
is-constant-bitvector?(e 2 )—► (USGTR ,ei,cons(USCONC ,e 2 )), 
is-constant-bitvector?(ei)—+ (USGTR ,cons(USCONC ,ei),e 2 ), 
(USGTR , ei ,e 2 ))), 

GE 

- (EQ ,(BS ,1,1), 

(is-constant-bitvector?(ei )A is-constant-bitvector?(e 2 ) 

— (USGEQ ,cons(USCONC , ei ),cons(USCONC ,e 2 )), 
is-constant-bitvector?(e 2 )^ (USGEQ ,ei ,cons(USCONC ,e 2 )), 
is-constant-bitvector?(ei)—* (USGEQ ,cons(USCONC ,ei),e 2 ), 
(USGEQ ,e l5 e 2 ))), 

OTHERWISE —► impl-error(“Shouldn’t happen!”)), 
is-string-tdesc?(d) 

—► (case op 

EQ 

—► (is-constant-string?(ei )A is-constant-string?(e 2 ) 

— (EQ ,cons(ACONC ,ei),cons(ACONC ,e 2 )), 
is-constant-string?(e 2 )—* (EQ ,ei ,cons(ACONC ,«*)), 
is-constant-string?(ei)—* (EQ ,cons(ACONC ,ei),e 2 ), 
(EQ, eil e 2 )), 

NE 

—► (is-constant-string?(ei )A is-constant-string?(e 2 ) 

— (NEQ ,cons(ACONC ,ei),cons(ACONC ,e 2 )), 
is-constant-string?(e 2 )—► (NEQ ,ei,cons(ACONC ,e 2 )), 
is-constant-string?(ei)—* (NEQ ,cons(ACONC ,ei),e 2 ), 

(NEQ ,ei,e 2 )), 

OTHERWISE —► impl-error(“Shouldn’t happen!”)), 

(case op 
EQ 

—► (dotted-expr-p(e 2 )—► (EQ ,ei,e 2 ), impl-error(“Shouldn’t happen!”)), 
NE 

— ► (dotted-expr-p(e 2 )—► (NEQ ,ei,e 2 ), 
impl-error(“Shouldn ’t happen!”)), 


118 



OTHERWISE —► impl-error(“Shouldn’t happen!”))), 

*RECORDTYPE* 

—♦ (dotted-expr-p(e 2 )—► (EQ ,ei,e 2 ), impl-error (“Shouldn’t happen!”)), 

OTHERWISE —► impl-error(“Shouldn’t happen!”)) 

is-constant-bitvector?(expr*) 

= nuil(expr*) 

V (consp(expr*) 

A let expn = hd(expr*) in 

consp(expri )A hd(expri)= BS ) 

is-constant-string? (expr *) 

= null(expr*) 

V (consp(expr*) 

A let expri = hd(expr*) in 

consp(expri )A hd(expri)= CHAR ) 

dotted-expr-p(expr) = consp(expr)A hd(expr)= DOT 

mk-scalar-rel(type-tag)(relational-op,el,e2) 

= (case type-tag 

*BOOL* 

—► (case relationaJ-op 

EQ —* mk-bool-eq(type-tag,el,e2), 

NE —► mk-bool-neq(type-tag,el,e2), 

LT — (AND ,(EQ ,el,FALSE ),(EQ ,e2,TRUE )), 

LE - (IMPLIES ,el,e2), 

GT — (AND ,(EQ ,el,TRUE ),(EQ ,e2,FALSE )), 

GE — (IMPLIES ,e2,el), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL BOOLEAN relational operator: “a”, 
relational-op)), 

*BIT* 

—► (case relational-op 

EQ — (EQ ,el,e2), 

NE — (NEQ ,el,e2), 

LT — (EQ ,(USLSS ,el,e2),(BS ,1,1)), 

LE — (EQ ,(USLEQ ,el,e2),(BS ,1,1)), 

GT — (EQ ,(USGTR ,el,e2),(BS ,1,1)), 

GE — (EQ ,(USGEQ ,el,e2),(BS ,1,1)), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL BIT relational operator: ~a”, 
relational-op)), 

(*INT* ,*TIME* ) 

(case relational-op 
EQ -> (EQ ,el,e2), 

NE — (NEQ ,el,e2), 

LT —+ (LT ,el,e2), 

LE —+ (LE ,el,e2), 

GT (GT ,el,e2), 

GE — (GE ,el,e2), 

OTHERWISE 
—*■ impl-error 

(“Unrecognized Stage 3 VHDL INTEGER relational operator: “a”, 
relational-op)), 


119 




*VHDLTIME* 

—► (case relational-op 

EQ —► (EQ ,el,e2), 

NE — (NEQ ,el,e2), 

LT —► (TIMELT ,el,e2), 

LE — (TIMELE ,el,e2), 

GT -> (TIMEGT ,el,e2), 

GE — (TIMEGE ,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL VHDLTIME relational operator: ~a”, 
relational-op)), 

*REAL* 

—► (case relational-op 

EQ-> (EQ , e l,e2), 

NE - (NEQ ,el,e2), 

(RLT ,RLE ,RGT ,RGE ) —► (relational-op,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL REAL relational operator: "a”, 
relational-op)), 

*ENUMTYPE* 

—* (case relational-op 

EQ -► (EQ ,el,e2), 

NE - (NEQ ,el,e2), 

LT — (ELT ,el,e2), 

LE (ELE ,el,e2), 

GT — (EGT ,el,e2), 

GE — (EGE ,el,e2), 

PRED -► (EPRED ,el,e2), 

SUCC — (ESUCC ,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL ENUMERATION relational operator: ~a”, 
relational-op)), 

*VOID* 

—► (case relational-op 

EQ — (EQ ,el,e2), 

NE — (NEQ ,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL VOID relational operator: ~a”, 
relational-op)), 

*POLY* 

—► (case relational-op 

EQ (EQ ,el,e2), 

NE — (NEQ ,el,e2), 

OTHERWISE 


—*• impl-error 

(“Unrecognized Stage 3 VHDL POLYMORPHIC relational operator: “a”, 
relational-op)), 

OTHERWISE —► impl-error(“Unsupported Stage 3 VHDL basic type ~a.”,type-tag)) 


mk-bool-eq(type-tag,el,e2) 

~ (type-tag = *BOOL* 

—► (simple-term(el) 

— (simple-term(e2)—♦ (EQ ,el,e2), (EQ ,el,(COND ,e2,TRUE ,FALSE ))), 


120 



simple-term(e2)^ (EQ ,e2,(COND ,el,TRUE ,FALSE )), 

(COND ,el,e2,(NOT f e2))), 

(EQ ,el,e2)) 

mk-bool-neq(type-tag,el ,e2) 

= (type-tag = *BOOL* 

—► (simple-term(el) 

— (simple-term(e2)—► (NEQ ,el,e2), (NEQ ,el,(COND ,e2,TRUE ,FALSE ))), 
simple-term(e2)—» (NEQ ,e2,(COND ,el,TRUE ,FALSE )), 

(COND ,el,e2,(NOT ,e2))), 

(NEQ ,el,e2)) 

simple-term (term) 

= let operators = (DOT POUND) in 
-iconsp(term)V hd(term)£ operators 

mk-vhdltime(global)(delta) = (VHDLTIME ,global,delta) 

block-exit(v)(stk) 

= let <tg,qname,p,g> = hd(stk) in 
(case tg 

*STKBOTTOM* —* model-execution-complete(qname), 

*UNDECLARE* —► g(Avv,s.block-exit(.vv)(s))(v)(stk), 

(*BLOCK-EXIT* ,*SUBPROGRAM-RETURN* ) — g(v)(stk-pop(stk)), 

(*BEGIN* ,*LOOP-EXIT* ,*PACK AGE-BODY-EXIT* ) - block-exit(v)(stk-pop(stk)), 
OTHERWISE 

—► impl-error(“Unknown execution stack descriptor with tag: ~a”,tg)) 


model-execution-complete(id) 

= (mk-sd(id)( £ )(e)(e)(((VHDL_MODEL_EXECUTION-COMPLETE ,id)))) 

A Stage 3 VHDL design file has a name, and consists of some (possibly none) package 
declarations, package bodies, and USE clauses, followed by an entity declaration and an 
architecture body. 

The semantics of the design file has as its sole semantic argument the TSE t constructed by 
Phase 1. The design file name id denotes a special place, whose value .id is itself a place 
that will represent, at any given point during the translation, the current universe of visible 
places. This name is available to most of the Phase 2 semantic functions as the first edge 
label in the current path. 

Translation of a design file commences by generating some top-level assertions and decla¬ 
rations for the SDVS Simplifier: 

• A disjointness assertion , required for technical reasons. 

The function mk-disjoint(place-list) generates an SDVS assertion stating that the 
places in place-list are mutually disjoint. 

• A covering assertion that the initial universe of visible places .id consists of certain 
predefined places: the program counter place id\pc as well as the places vhdltime 
and vhdltime_previous. 


121 



The function mk-cover(place, place-list) 2 generates an SDVS covering assertion 
that place covers all the places in place-list and that all of the places in place-list 
are mutually disjoint. 

• Declarations of the places vhdltime and vhdltime_previous. The function mk- 
scalar-decl(placename,place-type) (make scalar declaration) generates an SDVS 
declaration of a scalar-value place of the indicated type. 

• Assertions that the places vhdltime and vhdltime_previous have as their initial 
value the time object vhdltime(0,0) of the Simplifier VHDL Time domain. 

The function mk-rel(type-desc)(relation,accessed-place,expression) (make re¬ 
lation) constructs an SDVS typed relation that asserts that the value of a place at 
pre- or postcondition time stands in a certain relation to the value of an expression. 


Then a state delta that defines the execution of the hardware description is generated. The 
application of this state delta leads to further usable state deltas, whose generation in the 
absence of errors is accomplished by continuations. With respect to the TSE t, an initial 
path consisting of the design file’s name, an initial universe, and an initial execution stack 
containing a *STKBOTTOM* descriptor to terminate model execution (see Section 8.2), 
these state deltas symbolically elaborate the design file’s package declarations, package 
bodies, USE clauses, entity declaration, and architecture body. 


8.4.2 Entity Declarations 

(ENl) EN | ENTITY id decl* declj opt-id phasel-hook J (t)(p)(u)(v)(stk) 
= let pi = %(p)(id) in 

D [ declj ] (t)(pi)(ui)(v)(stk) 
where ui = Av 2 ,stk 3 .ID [ decl^ ] (t)(pi )(u)(v)(stk) 


Phase 2 translation of an entity declaration effects the elaboration, via semantic function 
D, first of its port declarations, and then of any other declarations local to the entity. The 
interphase abstract syntax tree transformation has arranged for the Phase 2 abstract syntax 
of port declarations to be identical to that for other objects of class SIGNAL. 


8.4.3 Architecture Bodies 

(ARl) AR [[ ARCHITECTURE idi id 2 decl* con-stat* opt-id | (t)(p)(u)(v)(stk) 

= let pi = %(p)(idi) in 

D[decP](t)(p,)(u 1 )(v)(stk) 

where 

m = Avi ,stki. 

CS [ con-stat* ] (t)(pi)(u 2 )(vi)(stki) 
where 

u 2 = Av 2 ,stk 2 . 

2 The function mk-cover has in some instances been superseded by mk-cover-already; it implements 
an experimental new naming scheme for VHDL variables. The scheme is available only when the SDVS 
function new-declarations is defined to return non-NIL. In SDVS Version 12, this new scheme is not 
available, so we will not discuss the actions of this function here. 


122 




cons((VHDL_MODEL_ELABORATION_COMPLETE ,hd(p))> 

(mk-sd 

(hd(p))(e)(e)(e) 

((make-vhdl-begin-model-execution 

(hd(p))(u)(t)(v 2 )(stk 2 ))))) 

Phase 2 translation of an architecture body first effects the elaboration, via semantic func¬ 
tion D, of the architecture’s local declarations, and then initiates the translation, via se¬ 
mantic function CS, of its concurrent statements (which have been uniformly converted to 
PROCESS statements by the interphase abstract syntax tree transformation at the end of 
Phase 1; see Section 7). The continuation of concurrent statement elaboration returns a 
Simplifier assertion to the effect that the VHDL model’s elaboration is complete, as well 
as a state delta, constructed by special function make-vhdl-begin-model-execution, that 
initiates symbolic execution of the model. 


8.4.4 Declarations 

(DO) D [e J (t)(p)(u)(v)(stk) = u(v)(stk) 

(Dl) D [ decl decl* ] (t)(p)(u)(v)(stk) 

= D [ decl 1 (t)(p)(ui)(v)(stk) 

where ui = Avi,stki.D [decl* ] (t)(p)(u)(vi)(stki) 


(D2) D [ pkg-decl pkg-decl* ]] (t)(p)(u)(v)(stk) 

= 21 pkg-decl J (t)(p)(ui )(v)(stk) 

where ui = Avi,stki.D [pkg-decl* ] (t)(p)(u)(vi)(stki) 


(D3) D [ pkg-body pkg-body* J (t)(p)(u)(v)(stk) 

= D [ pkg-body ] (t)(p)(ui )(v)(stk) 

where ui = Avi,stki.D [pkg-body* ] (t)(p)(u)(vi)(stki) 


(D4) D [ use-clause use-clause* ] (t)(p)(u)(v)(stk) 

= D [ use-clause ] (t)(p)(ui )(v)(stk) 

where ui — Avi,stki.D [use-clause* ]] (t)(p)(u)(vi)(stki) 


The Phase 2 processing of declarations proceeds sequentially, from first to last. 

(D5) D [ DEC object-class id + type-mark opt-expr | (t)(p)(u)(v)(stk) 

= let d = lookup-desc(type-mark)(t)(p) in 
(case tag(d) 

(*BOOL* *BIT* *INT* *REAL* ,*TIME* ,*ENUMTYPE* ,*SUBTYPE* *INT_TYPE* ) 

—*■ gen-scalar-decl 

(decl) (object-class) (id + )(d) (opt-expr) (t)(p)(u)(v)(stk), 

*ARRAYTYPE* 

—► gen-array-decl 

(decl) (object-class) (id + )(d)(direction(d))(real-lb(d)) 

(real-ub(d))(elty(d)) (opt-expr) (t)(p)(u)(v)(stk), 

*RECORDTYPE* 

—► gen-record-decl 

(decl) (object-class) (id + )(d)(opt-expr)(t)(p)(u)(v)(stk), 

OTHERWISE - u(v)(stk)) 


123 


(D6) D [ SLCDEC object-class id + slice-name opt-expr ] (t)(p)(u)(v)(stk) 

= let d = lookup(t)(p)(hd(id + )) in 

let anon-array-type-desc = second(type(d)) in 
gen-array-decl 

(decl) (object-class) (id + )(anon-array-type-desc) 
(direction(anon-array-type-desc))(lb(anon-array-type-desc)) 
(ub(anon-array-type-desc))(elty(anon-array-type-desc))(opt-expr)(t)(p) 
( u )(v)(stk) 


lookup-desc(id* )(t)(p) 

= (null(id*)—» void-type-desc(t), 

let q — access(rest(id*))(t)(p) in 
lookup-desc-on-path(t)(q)(last(id*))) 

lookup-desc-on-path(t)(p)(id) 

= let d = t(p)(id) in 

(d = ^UNBOUND* —+ lookup-desc-on-path(t)(rest(p))(id), d) 

accessed* )(t)(p) 

= (null(kT)—► p, 

let d = lookup(t)(p)(hd(id*)) in 
access(tl(id* ))(t)(%(path(d))(idf(d)))) 

gen-scalar-decl(decl) (object-class) (id + )(d)(expr)(t)(p)(u)(v)(stk) 

= (null(expr) 

—♦ gen-scalar-decl-id-f (decl)(object-class)(id + )(d)(expr)(t)(p)(u)(v)(stk), 
gen-scalar-decl-id*(decl)(object-class)(id + )(d)(expr)(t)(p)(u)(v)(stk)) 

gen-scalar-decl-id-f (decl)(object-class)(id + )(d)(expr)(t)(p)(u)(v)(stk) 

= (object-class = SIG 

—*■ gen-scalar-signal-decl-id-f(decl)(id + )(d)(expr)(t)(p)(u)(v)(stk), 
gen-scalar-nonsign al-decl-id-b(decl)(id' f )(d)(expr)(t)(p)(u)(v)(stk)) 

gen-scalar-decl-id*(decl) (object-class) (id* )(d)(expr)(t)(p)(u)(v)(stk) 

= (null(id*) —► u(v,stk), 
let id+ = (hd(id*)) in 

gen-scalar-decl-id-h(decl)(object-class)(id + )(d)(expr)(t)(p)(ui )(v)(stk) 
where 

Ui = Avi ,stki. 

gen-scalar-decl-id * 

(decl)(object-class)(tl(id*))(d)(expr)(t)(p)(u)(vi )(stkj)) 


gen-scalar-nonsignal-decl-id-f(decl)(id + )(d)(expr)(t)(p)(u)(v)(stk) 
= R [ expr ] (t)(p)(k)(v)(stk) 
where 


k = A(e,f),vi ,stki. 
let z = hd(p) 

and suqn + = get-qids(id + )(t)(p) in 
let v 2 = push-universe(vi )(z)(suqn + ) in 
let duqn + = get-qualified-ids(suqn + )(v 2 ) in 
(mk-decl-sd 

(z)(f)(e)((z)) 

(nconc 

(mk-qual-id-coverings(suqn + )(duqn + )(z)(v)(t), 
mk-scalar-nonsignal-dec-post 

(decl)((duqn + ,e,d))(t)(p)(u)(v 2 )(stk)))) 


124 


get-qids(id* )(t)(p) 

= (nnll(id*)—#- c, cons(qid(t(p)(hd(id* ))),get-qids(tl(id* ))(t)(p))) 

get-qualified-ids(suqn* )(v) 

= (null(suqn*)—► e, 

cons(qualified-id(hd(suqn* ))(v),get-quaMed-ids(tl(suqn* ))(v))) 

qualified-id(suqn)(v) 

= let vars = universe-vars(v) in 

let suqn-triple = assoc(suqn,vars) in 
(suqn-triple 

—> let n = hd(third(suqn-triple)) in 
name-qualified-id (suqn) (n), 
name-qualified-id(suqn)(l)) 

name-qualified-id (suqn)(n) 

= (new-declarations()—► (PLACELEMENT ,suqn,n), 

(n = 1 —► suqn, catenate(suqn, w !”,n))) 

already-qualified-id(suqn)(v) = ->null(assoc(suqn,universe-vars(v))) 

qualified-id-decls(suqn*) 

= (null(suqn*)—► e, 

let suqn = hd(suqn*) in 

cons((DECLARE ,suqn,(TYPE ,PLACEARRAY )),qualified-id-decls(tl(suqn*)))) 

mk-qual-id-coverings(suqn + )(duqn + )(z)(v)(t) 

= (new-declarations() 

—► (already-qualified-id(hd(suqn + ))(v) 

—► (mk-rel(univint-type-desc(t))((EQ ,pound(z),dot(z)))), 
nconc 

((mk-disjoint(z,cons(dot(z),suqn -1 ')), 
mk-cover(pound(z),cons(dot(z),suqn + ))),qualified-id-decls(suqn + ))), 
(mk-disjoint(z,cons(dot(z),duqn + )),mk-cover(pound(z),cons(dot(z),duqn + )))) 

mk-scalar-nonsignal-dec-post(decl)(duqn* ,e,d)(t)(p)(u)(v)(stk) 

= let type-spec = mk-type-spec(d)(t)(p) in 
(null(e) 

—♦ nconc 

(mk-scalar-nonsignal-dec-post-declare(duqn*)(type-spec), 
u(v)(stk)), 

nconc 

(mk-scalar-nonsignal-dec-post-declare(duqn*) (type-spec), 
ui(v)(stk)) 
where 

ui = Avi,stki. 

(mk-decl-sd 

(hd(p))(e)(e)(duqn*) 

(nconc 

(mk-scalar-nonsignal-dec-post-init(duqn*)(e)(d), 

u(vi)(stki))))) 

mk-type-spec(d)(t)(p) 

= (case tag(d) 

♦BOOL* - (TYPE BOOLEAN) , 

♦BIT* — (TYPE BIT) , 

(*INT* ,*INT_TYPE* ,*TIME* ) — (TYPE INTEGER) , 


125 



♦REAL* — (TYPE FLOAT) , 

♦VHDLTIME* - (TYPE VHDLTIME) , 

♦ENUMTYPE* 

- (idf(d)= CHARACTER - (TYPE CHARACTER) , 
cons(TYPE ,cons(ENUMERATION ,literals(d)))), 

♦SUBTYPE* —*■ mk-type-spec(base-type(d))(t)(p), 

♦VOID* — (TYPE VOID) , 

♦POLY* — (TYPE POLYMORPHIC) , 

♦RECORDTYPE* —► cons(TYPE ,cons(RECORD ,record-to-type(components(d))(t)(p))), 

*AR RAYTYPE* 

—► let expri = lb(d) in 

R [[expri ] (t)(p)(ki)(e)(e) 
where 

ki = A(ei ,fi ),V] ,stki. 

let expr 2 = ub(d) in 
R I expr 2 1 (t)(p)(k 2 )(vi)(stki) 
where 

k 2 — A(e 2 ,f 2 ),v 2 ,stk 2 . 

cons(TYPE , 

(ARRAY ,ei,e 2 ,mk-type-spec(elty(d))(t)(p))), 

♦WAVE* - (TYPE ,WAVEFORM ,mk-type-spec(hd(type(d)))(t)(p)), 

OTHERWISE —► impl-error(“Unrecognized Stage 3 VHDL type: ~a”,tag(d))) 

record-to-type(record-components)(t)(p) 

= (null(record-components)—» e, 

let (id,d) = hd(record-components) in 
cons((id,mk-type-spec(d)(t)(p)), 
record-to-type(tl(record-components))(t)(p))) 

mk-scalar-nonsignal-dec-post-declare(duqn*) (type-spec) 

= (null(duqn*)—► e, 

let duqn = hd(duqn*) in 
cons(mk-scalar-decl(duqn, type-spec), 

mk-scalar-nonsignal-dec-post-declare(tl(duqn* ))(type-spec))) 

mk-scalar-decl(placename,place-type) = (DECLARE ,placename,place-type) 

mk-scalar-nonsignal-dec-post-init(duqn* )(e)(d) 

= (null(duqn*)— e, 

let duqn = hd(duqn*) in 
nconc 

(assign(d)((duqn,e)),mk-scalar-nonsignal-dec-post-init(tl(duqn*))(e)(d))) 

assign(d)(target, value) 

= (case tag(d) 

(*BOOL* ,*BIT* ,*INT* ,*REAL* *TIME* ,*VHDLTIME* ,*ENUMTYPE* ,*WAVE* , 
♦VOID* *POLY* ) 

—► (mk-rel(d)((EQ ,pound(target),value))), 

♦SUBTYPE* —♦ assign(base-type(d))((target,value)), 

♦INTJTYPE* —► assign(parent-type(d))((target, value)), 

♦ARRAYTYPE* 

—► (is-bitvector-tdesc?(d) 

—► (is-constant-bitvector?(value) 

—► (case direction(d) 

TO 

—* assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 


126 



DOWNTO 

—► assign-array-downto 

(target)(value) (elty(d)) 

(mk-exp2 
(SUB , 

mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)), 1))(0), 
OTHERWISE —► impl-error( “Illegal direction: ~a”,direction 

(«*))), 

(mk-rel(d)((EQ ,pound(target),value)))), 
is-string-tdesc?(d) 

—► (is-constant-string?( value) 

—► (case direction(d) 

TO 

—► assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 
—► assign-array-downto 

(target)(value)(elty(d)) 

(mk-exp2 
(SUB , 

mk-ex P 2(ADD ,(ORIGIN ,target),(RANGE ,target)), 1))(0), 
OTHERWISE —* impl-error(“Illegal direction: ~a” ,direction 

(d))), 

(mk-rel(d)((EQ ,pound(target),value)))), 

(dotted-expr-p(vaiue)—► (mk-rel(d)((EQ ,pound(target),value))), 

(case direction(d) 

TO —► assign-array-to(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 

—► assign-array-downto 

(target) (value) (elty(d)) 

(mk-exp2 

(SUB ,mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)), 
1))(0), 

OTHERWISE — impl-error(“Illegal direction: ~a”,direction(d))))), 
*RECORDTYPE* 

—► (dotted-expr-p( value)— assign-record(d)((target,value)), 
assign-record-fields(components(d))( (target, value))), 

OTHERWISE — impl-error(“Unrecognized Stage 3 VHDL type tag: ~a”,tag(d))) 

is-constant-bitvector?(expr*) 

= null(expr*) 

V (consp(expr*) 

A let expri = hd(expr*) in 

consp(expri )A hd(expri)= BS ) 

is-constant-string?(expr*) 

= null(expr*) 

V (consp(expr*) 

A let expri = hd(expr*) in 

consp(expri )A hd(expri)= CHAR ) 

dotted-expr-p(expr) = consp(expr)A hd(expr)— DOT 

assign-array-to(target)(aggregate)(element-type-desc)(start-index)(m) 

= (nuU(aggregate)— e, 
nconc 
(assign 


127 




(element-type-desc) 

(((ELEMENT ,target,mk-exp2(ADD ,start-index,m)),hd(aggregate))), 
assign-array-to 

(target )(tl(aggregate))(element-type-desc) (start-index) (m-j-l))) 

assign-array-down to(target)( aggregate) (element-type-desc)(st art-index )(m) 

= (null(aggregate)—► e, 
nconc 
(assign 

(element-type-desc) 

(((ELEMENT ,target,mk-exp2(SUB ,start-index,m)),hd(aggregate))), 
assign-array-downto 

(target) (tl(aggregate))(element-type-desc)(start-index)(m-fl))) 

mk-exp2(binary-op,el ,e2) 

= (case binary-op 

AND — (AND ,el,e2), 

NAND - (NAND ,el,e2), 

OR —► (OR ,el,e2), 

NOR - (NOR ,el,e2), 

XOR (XOR ,el,e2), 

BAND (USAND ,el,e2), 

BNAND — (USNAND ,el,e2), 

BOR — (USOR ,el,e2), 

BNOR — (USNOR ,el,e2), 

BXOR -> (USXOR ,el,e2), 

ADD - (PLUS ,el,e2), 

SUB — (MINUS ,el,e2)j 
MUL — (MULT ,el,e2), 

DIV — (DIV ,el,e2), 

MOD — (MOD ,el,e2), 

REM - (REM ,el,e2), 

EXP - (EXPT ,el,e2), 

(RPLUS ,RMINUS ,RTIMES ,RDIV ,REXPT ) — (binary-op,el,e2), 
CONCAT — (ACONC ,el,e2), 

OTHERWISE 

—* impl-error(“Unrecognized Stage 3 VHDL binary operator: ~a”,binary-op)) 

assign-record (d) (target-record,dotted-source-record) 

— cons(mk-rel(d)((EQ ,pound(target-record),dotted-source-record)), 
assign-record-aux 

(components(d))((target-record,second (dotted-source-record)))) 

assign-record-aux(comp*)(target-record, source-record-name) 

= (null(comp*)—► e, 

let (id,d) = hd(comp*) in 
nconc 
(assign 
(d) 

((mk-recelt( target- record, id), dot(mk-recelt(source- record-name, id)))), 
assign-record-aux(tl(comp*))((target-record,source-record-name)))) 

assign-record-fields(comp*)(target-record,source-fields) 

= (null(comp*)—► e, 

let (id,d) = hd(comp*) in 
nconc 

(assign(d)((mk-recelt(target-record,id),second(assoc(id,source-fields)))), 
assign-record-fields(tl(comp* ))((target-record,source-fields)))) 


128 



mk-recelt(e)(id) = (RECORD ,e,id) 


gen-scalar-sign al-decl-id-f(decl) (id + )(d)(expr) (t) (p)(u) (v) (stk) 

= R [[ expr ] (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi,stki. 
let z = hd(p) 

and signal-suqn + — get-qids(id + )(t)(p) in 
let driver-suqn + = name-drivers(signal-suqn + ) in 
let suqn + = append(signal-suqn+ ,driver-suqn + ) in 
let V 2 = push-universe(vi )(z)(suqn + ) in 
let signal-duqn + = get-qualified-ids (signal-suqn + )(v 2 ) 

and driver-duqn + = get-qualified-ids(driver-suqn+ )(v 2 ) in 
let duqn + = append(signal-duqn + ,driver-duqn + ) in 
(mk-decl-sd 

(z)(f)(e)((z)) 

(nconc 

(mk-qual-id-coverings(suqn' 1 ' )(duqn+ )(z)(v)(t), 
mk-scalar-signal-dec-post 

(decl)((duqn + ,signal-duqn + ,driver~duqn + ,e,d))(t)(p)(u) 
(v 2 )(stk)))) 


name-drivers(signal-names) 

= (null(signal-names)—► e, 

cons(name-driver(hd(signal-names)),name-drivers(tl(signal-names)))) 

mk-scalar-signal-dec-post(decl)(duqn* ,signal-duqn* ,driver-duqn*,e,d)(t)(p)(u)(v)(stk) 

= let sigtype-spec = mk-sigtype-spec(d)(t)(p) 

and waveform-type-spec = (TYPE ,WAVEFORM ,mk-type-spec(d)(t)(p)) in 
nconc 

(mk-scaiar-signal-dec-post-declare 

(signal-duqn* )(driver-duqn* )(sigtype-spec)( waveform-type-spec), 
ui(v)(stk)) 
where 

ui = Avi,stki. 

(mk-decl-sd 

(hd(p))(e)(e)(duqn*) 

(nconc 

(mk-scalar-signal-dec-post-init 

(signal-duqn* )(driver-duqn* )(e)(d)(waveform-type-desc(d)), 
u(vi)(stk,)))) 

mk-scalar-signal-dec-post-declare(signa]-duqn* )(driver-duqn*)(sigtype-spec) (waveform-type-spec) 
= (null(signal-duqn*) —♦ e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(mk-scalar-signal-decl 

((signal-duqn,driver-duqn))((sigtype-spec,waveform-type-spec)), 

mk-scalar-signal-dec-post-declare 

(tl(signal-duqn*))(tl(driver-duqn*)) (sigtype-spec) (waveform-type-spec))) 

mk-scalar-signal-decl(signal-name,driver-name) (sigtype-spec, waveform-type-spec) 

= (mk-scalar-decl(signal-name,sigtype-spec), 

mk-scalar-decl(driver-name,waveform-type-spec)) 


129 



mk-scalar-signal-fn-decl (signal-name, driver-name) 

= (DECLARE ,signal-name,(TYPE ,FN ,(VAL ,dot(driver-name),dot(VHDLTIME )))) 
waveform-type-desc(type-desc) = <WAVEFORM ,e,*WAVE* ,(STANDARD) ,tt,type-desc> 


mk-scalar-signal-dec-post-init(signal-duqn*)(driver-duqn*)(e) (type-desc) (waveform-type-desc) 
= (null(signal-duqn*)—+ £, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
let initial-signal-val = (null(e)—> eval-expr(dot(signal-duqn)), e) in 
let initial-waveform = init-scalar-signal 

(signal-duqn) (driver-duqn) (type-desc) 

(initial-signal-val) in 


nconc 

(assign(waveform-type-desc)( (driver-duqn,initial-waveform)), 
mk-scalar-signal-dec-post-init 

(tl(signal-duqn* ))(tl(driver-duqn* ))(e)(type-desc)( waveform-type-desc))) 


gen-array-decl(decl) 

(object-class) (id + )(type-desc)(direction)(lower-bound)(upper-bound)(element-type-desc)(expr) 
(t)(p)(u)(v)(stk) 

= (null(expr) 

—► gen-array-decl-id-f 

(decl) (object-class) (id + ) (type-desc) (direction) (lower-bound) (upper-bound) 

(element-type-desc)(expr)(t)(p)(u)(v)(stk), 
gen-array-decl-id * 

(decl) (object-class) (id + ) (type-desc) (direction) (lower-bound) (upper-bound) 
(element-type-desc)(expr)(t)(p)(u)(v)(stk)) 

real-lb(d) 

— let bound = lb(d) in 

(is-num-lit ?(bound)—► bound, 

(REF ,((SREF ,path(d),mk-tick-low(idf(d)))))) 

real-ub(d) 

= (path(d)= (STANDARD) A idf(d)G (STRING BIT_VECTOR) - £ , 
let bound = ub(d) in 
(is-num-lit?(bound)—► bound, 

(REF ,((SREF ,path(d),mk-tick-high(idf(d))))))) 


mk-tick-low(id) = catenate^d/^LOW”) 
mk-tick-high(id) —- catenate(id,“’HIGH”) 


gen-array-decl-id-f-(decl) 

(object-class)(id + ) (type-desc) (direction) (lower-bound) (upper-bound) (element-type-desc)(expr) 
( t )(p)(u)(v)(stk) 

= (object-class = SIG 

—> gen-array-signal-decl-id-f 

(decl) (id + )(type-desc)(direction)(lower-bound)(upper-bound) 

(element-type-desc)(expr)(t)(p)(u)(v)(stk), 

gen-array-nonsignal-decl-id-J- 

(decl)(id + ) (direction) (lower-bound)(upper-bound)(eiement-type-desc)(expr) 

( t )(p)( u )( v )(stk)) 


130 



gen-array-decl-id*(decl) 

(object-class) (id* )(type-desc)(direction)(lower-bound) (upper-bound) (element-type-desc)(expr) 
(t)(p)(w)(v)(stk) 

= (null(id*)—* u(v,stk), 
let id+ = (hd(id*)) in 
gen-array-decl-id 4- 

(decl) (object-class) (id + )(type-desc)(direction)(lower-bound)(upper-bound) 
(element-type-desc)(expr)(t)(p)(ui )(v)(stk) 
where 


ui = Avi ,stki. 

gen-array-decl-id* 

(decl)(object-class)(tl(kT ))(type-desc)(direction)(lower-bound) 
(upper-bound)(element-type-desc)(expr)(t)(p)(u)(vi )(stki)) 


gen-array-nonsignal-decl-id+(decl) 

(id + ) (direction) (expri )(expr 2 )(element-type-desc)(expr) 
(t)(p)W(v)(stk) 

= R I expr 1 (t)(p)(k)(v)(stk) 
where 

k — A(e,f),vi,stki. 

R[expri | (t)(p)(ki)(vi)(stki) 
where 

ki = A(ei,fi),v 2 ,stk 2 . 

R I expr 2 1 (t)(p)(k 2 )(v 2 )(stk 2 ) 

where 

k 2 = A(e 2T f2),V3,stk 3 . 
let z = hd(p) 

and len = length-expr(expr) 
and suqn + = get-qids(id + )(t)(p) in 
let v 4 = push-universe(v 3 )(z)(suqn + ) in 
let duqn + = get-quaMed-ids(suqn + )(v 4 ) in 
let g! = (ei A e 2 

—*> mk-rel 

(univint-type-desc(t)) 

((LE , ei ,e 2 )), 

TRUE ) 

and g 2 = (ei A e 2 

—► mk-rel 

(univint-type-desc(t)) 

((GE , 
mk-exp2 

(ADD ,mk-exp2(SUB ,e 2 ,ei), 
l),len)), 

TRUE ) in 

(mk-decl-sd 

( z ) 

(nconc 

(fl,f2,(gl), 

(len = 0 — f, nconc((g 2 ),f))))(e)((z)) 

(nconc 

(mk-qual-id-coverings 

(suqn + )(duqn + )(z)(v)(t), 
mk-array-nonsignal-dec-post 
(decl) 

((duqn + ,e,directional ,e 2 ,element-type-desc)) 
(t)(p)(u)(V 4 )(stk 3 )))) 


131 



length-expr(expr) 

= (null(expr)—*• 0, 

hd(expr)£ (BITSTR STR PAGGR) —► length(second(expr)), 

1 ) 


mk-array-nonsignal-dec-post (decl) 

(duqn*,e, direction, lower-bound, upper-bound, element-type-desc) 
(t)(p)(u)( v )(stk) 

= let element-type-spec = mk-type-spec(element-type-desc)(t)(p) in 
(null(e) 

—► nconc 

(mk-array-nonsignal-dec-post-declare 

(duqn*) (direction) (lower-bound) (upper-bound) (element-type-spec), 
u(v)(stk)), 

nconc 

(mk-array-nonsignal-dec-post-declare 

(duqn*)(direction)(lower-bound)(upper-bound)(element-type-spec), 

ui(v)(stk)) 

where 

ui = Avi ,stki. 

(mk-decl-sd 

(hd(p))(c)(e)(duqn*) 

(nconc 

((direction = TO 

—*■ mk-array-nonsignal-dec-post-init-to 

(duqn*)(e)(element-type-desc)(lower-bound), 

mk-array-nonsignal-dec-post-init-downto 

(duqn* )(e) (element-type-desc)(upper-bound)), 
u(vj)(stki))))) 

mk-array-nonsignal-dec-post-declare(duqn* )(direction)(lower-bound)(upper-bound)(element-type-spec) 
= (null(duqn*)—► e, 

let duqn = hd(duqn*) in 
nconc 

(mk-vhdl-array-decl 

(duqn)(direction)(lower-bound) 

((null(upper-bound) 

(lower-bound = 1 —► (RANGE ,duqn), 

mk-exp2(SUB ,mk-exp2(ADD ,(RANGE ,duqn),lower-bound),1)), 
upper-bound))(element-type-spec), 
mk-array-nonsignal-dec-post-declare 

(tl(duqn*)) (direction) (lower-bound) (upper-bound) (element-type-spec))) 

mk-vhdl-array-decl(id) (direction) (lower-bound) (upper-bound) (element-type-spec) 

= (case second(element-type-spec) 

BIT 

(mk-array-decl(id)(lower-bound)(upper-bound)(element-type-spec), 
mk-bitvec-fn-decl(id) (direction) (lower-bound) (upper-bound)), 

CHARACTER 

—* (mk-array-decl(id)(lower-bound)(upper-bound)(element-type-spec), 
mk-string-fn-decl(id) (direction) (lower- bound) (upper-bound)), 

OTHERWISE 

—► (mk-array-decl(id) (lower-bound) (upper-bound) (element-type-spec))) 


mk-array-decl(id) (lower-bound) (upper-bound) (element-type-spec) 

= (DECLARE ,id,(TYPE ,ARRAY ,lower-bound,upper-bound,element-type-spec)) 


132 



mk-bitvec-fn-decl(bitvec-name) (direction) (lower-bound) (upper-bound) 

= let bitvec-elt-names = (direction = TO 

—► mk-sUce-elt-names-to 

(bitvec-name)(lower-bound) (upper-bound), 
mk-slice-elt-names-downto 

(bitvec-name)(lower-bound)(upper-bound)) in 
(DECLARE ,bitvec-name,(TYPE ,FN ,concatenate-bits(bitvec-elt-names))) 

mk-string-fn-decl(string-name)(direction)(lower-bound) (upper-bound) 

= let string-elt-names = (direction = TO 

—► mk-slice-elt-names-to 

(string-name) (lower-bound) (upper-bound), 
mk-slice-elt-names-downto 

(string-name)(lower-bound)(upper-bound)) in 
(DECLARE ,string-name,(TYPE ,FN ,concatenate-characters(string-elt-names))) 

mk-slice-elt-names-to(slice-name) (lower-bound) (upper-bound) 

= (lower-bound > upper-bound —► e, 

cons(mk-array-elt(slice-name)(lower-bound), 

mk-slice-elt-names-to(slice-name)(lower-bound4-l) (upper-bound))) 

mk-slice-elt-names-downto(slice-name)(lower-bound)(upper-bound) 

= (upper-bound < lower-bound —► e, 

cons(mk-array-elt(slice-name)(upper-bound), . 

mk-slice-elt-names-downto(sbce-name) (lower-bound) (upper-bound— 1))) 
mk-array-elt(id)(e) = (ELEMENT ,id,e) 

concatenate-bits(bit-names) — cons(USCONC ,mk-dotted-names(bit-names)) 
concatenate-characters(char-names) = cons(ACONC ,mk-dotted-names(char-names)) 
mk-dotted-names(names) 

= (null(names)—+ e, cons(dot(hd(names)),mk-dotted-names(tl(names)))) 

mk-array-nonsignal-dec-post-init-to(duqn* )(e)(element-type-desc)(lower-bound) 

= (null(duqn*)—► e, 
nconc 

(assign-array-to(hd(duqn*))(e)(element-type-desc)(lower-bound)(0), 

mk-array-nonsignal-dec-post-init-to 

(tl(duqn*)) (e) (element- type-desc) (lower-bound))) 

mk-array-nonsignal-dec-post-init-downto(duqn* )(e)(element-type-desc) (upper-bound) 

= (null(duqn* )—*• e, 
nconc 

(assign-array-do wnto(hd(duqn*))(e)(element-type-desc)( upper-bound )(0), 
mk-array-nonsignal-dec-post-init-downto 

(tl(duqn*))(e)(element-type-desc)(upper-bound))) 


gen-array-signal-decl-id-f(decl) 

(id + )(type-desc)(direction)(expri)(expr 2 )(element-type-desc)(expr) 
(t)( P )(u)(v)(stk) 

= R [[ expr 1 (t)(p)(k)(v)(stk) 

where 

k = A(e,f),vi,stki. 

R I expri 1 (t)(p)(ki)(vi)(stki) 


133 


where 

ki = A(ei,fi),v 2 ,stk 2 . 

R l expr 2 ] (t)(p)(k 2 )(v 2 )(stk 2 ) 
where 

k 2 = A(e 2 ,f 2 ),v 3 ,stk 3 . 
let z = hd(p) 

and len = length-expr(expr) 
and signal-suqn + = get-qids(id + )(t)(p) in 
let driver-suqn + = name-drivers(signal-suqn + ) in 
let suqn+ = append(signal-suqn+ ,driver-suqn + ) in 
let v 4 = push-universe(v 3 )(z)(suqn + ) in 
let signal-duqn + = get-quaiified-ids 

(signal-suqn + )(v 4 ) 
and driver-duqn + = get-qualified-ids 

(driver-suqn + )(v 4 ) in 

let duqn + = append 

(signal-duqn" 1 ' ,driver-duqn + ) in 
let gi = (ei A e 2 

—> mk-rel 

(univint-type-desc(t)) 

((LE ,ei >e2 )), 

TRUE ) 

and g 2 = (ei A e 2 

—► mk-rel 

(univint-type-desc(t)) 

((GE, 

mk-exp2 

(ADD , 

mk-exp2(SUB ,e 2 ,ei ),l),len)), 

TRUE) in 

(mk-decl-sd 

( z ) 

(nconc 

(fiA,(gi), 

(len = 0 — f, nconc(f,(g 2 )))))(e)((z)) 

(nconc 

(mk-qual-id-coverings 

(suqn + )(duqn + )(z)(v)(t), 
mk-array-signal-dec-post 
(decl) 

((duqn + ,signal-duqn + ,driver-duqn + ,e,type-desc,direction, 
ei,e 2 ,element-type-desc))(t)(p)(u) 

(v 4 )(stk 3 )))) 


mk-array-signal-dec-post(decl) 

(duqn*,signal-duqn 4 ,driver-duqn* ,e,type-desc, 
direction,lower-bound,upper-bound,element-type-desc) 
( t )(p)( u )( v )(stk) 

= let element-sigtype-spec = mk-sigtype-spec(element-type-desc)(t)(p) 
and element-waveform-type-spec = mk-waveform-type-spec 

(mk-type-spec(element-type-desc)(t)(p)) in 

nconc 

(mk-array-signal-dec-post-declare 

(signal-duqn 4 )(driver-duqn*) (direction) (lower-bound) (upper-bound) 
(element-sigtype-spec)(element-waveform-type-spec) (tt)(t)(p)(v)(stk), 
ui(v)(stk)) 
where 


134 



Ul — Avi ,stki. 

(mk-decl-sd 

(hd(p))(£)(e)(duqn’) 

(nconc 

(mk-array-signal-dec-post-init 

(signal-duqn* )(driver-duqn*)(e)(type-desc)(direction) 

(lower-bound) (upper-bound )(element-type-desc) 
(waveform-type-desc(element-type-desc))(t)(p)(v)(stk), 
u(V!)(stki)))) 

mk-waveform-type-spec(type-spec) 

= (case second(type-spec) 

ARRAY —► append(rest(type-spec),(mk-waveform-type-spec(last( type-spec)))), 

OTHERWISE — (TYPE ,WAVEFORM ,type-spec)) 
mk-array-signal-dec-post-declare(signal-duqn* ) (driver-duqn*) (direction) (lower-bound) (upper-bound) 

(element-sigtype-spec) (element-waveform-type-spec) (fn-decls?) 

(t)(p)(v)(stk) 

= (null(signal-duqn*)—»► e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(mk- array-sign al-decl 

(signal-duqn) (driver-duqn) (direction )(lower-bound)(upper-bound) 

(element-sigtype-spec) (element-waveform-type-spec) (fn-decls? ) (t) (p) (v) 

(stk), 

mk-array-signal-dec-post-declare 

(tl(signal-duqn* ))(tl(driver-duqn* ))(direction)(lower-bound) 

(upper-bound) (element-sigtype-spec) (element-waveform-type-spec) 
(fn-decls?)(t)(p)(v)(stk))) 

mk-array-signal-decl(signal-name) (driver-name) (direction) (lower-bound) (upper-bound) 
(element-sigtype-spec) (element-waveform-type-spec) (fn-decls?) 

(0(p)(v)(stk) 

= nconc 

(mk-vhdl-sigarray-decl 

(signal-name) (direction) (lower-bound) 

((null(upper-bound) 

—► (lower-bound = 1 —► (RANGE ,signal-name), 

mk-exp2(SUB ,mk-exp2(ADD ,(RANGE ,signal-name),lower-bound),1)), 
upper-bound))(element-sigtype-spec) (fn-decls?), 

(mk-array-decl 

(driver-name) (lower-bound) 

((null(upper-bound) 

—► (lower-bound = 1 —► (RANGE ,driver-name), 

mk-exp2(SUB ,mk-exp2(ADD ,(RANGE ,driver-name),lower-bound), 1)), 
upper-bound))(element-waveform-type-spec))) 

mk-array-signal-elt-fn-decls (signal-duqn) (driver-duqn) (element-type-desc)(lower-bound) (upper-bound) 

(t)(p)(v)(stk) 

= (is-array-tdesc?(element-type-desc) 

—► let signal-elts = mk-slice-elt-names-to 

(signal-duqn) (lower-bound) (upper-bound) 
and driver-elts = mk-slice-elt-names-to 

(driver-duqn)(lower-bound)(upper-bound) in 
let expri = real-lb(element-type-desc) in 
R l expri ] (t)(p)(ki)(v)(stk) 


135 



where 

ki — A(ei ,fi),vi,stki. 

let expr 2 = real-ub(element-type-desc) in 
R fexpr 2 ]] (t)(p)(k 2 )(vi)(stki) 
where 

k 2 = A(e 2 ,f 2 ),v 2 ,stk 2 . 

mk-array-signal-elt-fn-decls-aux 

(signal-elts)(driver-elts)(elty (element-type-desc)) 
(ei)(e 2 )(t)(p)(v 2 )(stk 2 ), 
let scalar-signal-elts = mk-slice-elt-names-to 

(signal-duqn)(lower-bound) (upper-bound) 
and scalar-driver-elts = mk-slice-elt-names-to 

(driver-duqn)(lower-bound)(upper-bound) in 
mk-scalar-signal-fn-decls(scalar-signal-elts,scalar-driver-elts)) 

mk-array-signal-elt-fn-decls-aux(signal-duqn*) (driver-duqn*) 

(element-type-desc) (lower-bound) (upper-bound) 
(t)(p)( v )(st k ) 

= (null(signal-duqn*)^ e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(mk-array-signal-elt-fn-decls 

(signal-duqn)(driver-duqn)(element-type-desc)(lower-bound)(upper-bound) 

(t)(p)( v )(stk), 

mk-array-signal-elt-fn-decls-aux 

(tl(signal-duqn*))(tl(driver-duqn*))(element-type-desc)(lower-bound) 
(upper-bound) (t)(p)(v)(stk))) 

mk-scalar-signal-fn-decls(signal-names, driver-names) 

= (null(signal-names)^ e, 

cons(mk-scalar-signal-fn-decl(hd(signal-names),hd(driver-names)), 

mk-scalar-signal-fn-decls(tl(signal-names),tl(driver-names)))) 

mk-array-signal-dec-post-init(signal-duqn* )(driver-duqn* )(e) 

(type-desc)(direction)(lower-bound)(upper-bound) 
(element-type-desc) (element-waveform-type-desc) 

( t )(p)( v )( stk ) 

= (direction = TO 

—► mk-array-signal-dec-post-init-to 

(signal-duqn* )(driver-duqn*)(e)(type-desc)(lower-bound)(upper-bound) 
(element-type-desc) (element-waveform-type-desc) (t)(p)(v)(stk), 
mk-array-signal-dec-post-init-downto 

(signal-duqn*) (driver-duqn* )(e) (type-desc) (lower-bound)(upper-bound) 
(element-ty pe-desc) (element-waveform- type-desc) (t)(p)(v)(stk)) 

mk-array-signal-dec-post-init-to(signal-duqn*)(driver-duqn* )(e) 

(type-desc) (lower-bound) (upper-bound) 

(element-type-desc)(element-waveform-type-desc) 

(t)(p)( v )(stk) 

= (is-array-tdesc? (element-type-desc) 

—► let expri = real-lb(element-type-desc) in 
R [expri ] (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,fi),vi ,stki. 

let expr 2 = real-ub(element-type-desc) in 
R [expr 2 ] (t)(p)(k 2 )(vi)(stki) 


136 



where 

k 2 = A(e 2 ,f2),V2,stk 2 . 

mk-array-signal-dec-post-init-elt-arrays-to 
(signal-duqn* )(driver-duqn*)(e) (type-desc) 

(lower-bound) (upper-bound)(element-type-desc) 

(direction(element-type-desc))(ei )(e 2 )(t)(p)(v 2 )(stk 2 ), 
mk-array-signal-dec-post-init-elt-scalars-to 

(signal-duqn* )(driver-duqn* )(e)(type~desc)(lower-bound)(upper-bound) 
(element-type-desc)(element-waveform-type-desc)(t)(p)(v)(stk)) 

mk-array-signal~dec-post-init-downto(signal-duqn* )(driver-duqn* )(e) 

(type-desc) (lower-bound)(upper-bound) 
(element-type-desc)(element-waveform-type-desc) 

(t)(p)(v)(stk) 

= (is-array-tdesc?(element-type-desc) 

—► let expri — real-lb(element-type-desc) in 
R [expri 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

let expr 2 = real-ub(element-type-desc) in 
R[expr 2 1 (t)(p)(k 2 )(vi)(stki) 
where 

k 2 = A(e 2 ,f 2 ),v 2 ,stk 2 . 

mk-array-signal-dec-post-init-elt-arrays-downto 
(signal-duqn* )(driver-duqn* )(e)(type-desc) 

(lower-bound) (upper-bound) (element-type-desc) 
(direction(element-type-desc))(ei)(e 2 )(t)(p)(v 2 )(stk 2 ), 
mk-array-signal-dec-post-init-elt-scalars-downto 

(signal-duqn* )(driver-duqn* )(e)(type-desc) (lower-bound) (upper-bound) 

(element-type-desc) (element-waveform-type-desc)(t)(p)(v)(stk)) 

mk-array-signal-dec-post-init-elt-arrays-to(signal-duqn* )(driver-duqn* )(e) 

(type-desc) (lower-bound) (upper-bound) 

(elt-type-desc)(elt-direction)(elt-lower-bound)(elt-upper-bound) 

(*)(p)(v)(stk) 

= (null(signal-duqn*)-+ e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(let signal-elts = mk-slice-elt-names-to 

(signal-duqn)(lower-bound)(upper-bound) 
and driver-elts = mk-slice-elt-names-to 

(driver-duqn)(lower-bound)(upper-bound) in 
mk-array-signal-dec-post-init-aux 

(signal-elts) (driver-elts) (e)(elt-type-desc)(elt-direction) 
(elt-lower-bound)(elt-upper-bound)(elty(elt-type-desc)) 
(waveform-type-desc(elty(elt-type-desc)))(t)(p)(v)(stk), 
ink-array-signal-dec-post-init-elt-arrays-to 

(tl(signal-duqn*))(tl(driver-duqn* ))(tl(e))(type-desc)(lower-bound) 
(upper-bound)(elt-type-desc)(elt-direction)(elt-lower-bound) 

(elt-upper-bound)(t)(p)(v)(stk))) 

mk-array-signal-dec-post-init-elt-arrays-downto(signal-duqn*) (driver-duqn* )(e) 

(type-desc)(lower-bound)(upper-bound) 

(elt-type-desc) (elt-direction) (elt-lower-bound) (elt-upper-bound) 
(t)(p)(v)(stk) 

= (null(signal-duqn')—* e, 


137 



let signal-duqn = hd(signal~duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(let signal-elts = mk-slice-elt-names-downto 

(signal-duqn)(lower-bound)(upper-bound) 
and driver-elts = mk-slice-elt-names-downto 

(driver-duqn)(lower-bound)(upper-bound) in 
mk-array-signal-dec-post-init-aux 

(signal-elts) (driver-elts) (e) (elt-type-desc) (eit-direction) 
(elt-lower-bound)(elt-upper-bound)(elty(elt-type-desc)) 
(waveform-type-desc(elty(elt-type-desc)))(t)(p)(v)(stk), 
mk-array-signal-dec-post-init-elt-arrays-downto 

(tl(signal-duqn* ))(tl(driver-duqn* ))(tl(e))(type-desc)(lower-bound) 

(upper-bound) (elt-type-desc) (el t-direction)(elt-lower-bound) 
(elt-upper-bound)(t)(p)(v)(stk))) 

mk-array-signal-dec-post-init-aux(signal-duqn*)(driver-duqn*)(e) 

(type-desc) (direction) (lower-bound) (upper-bound) 
(element-type-desc) (element-waveform-type-desc) 

( t )(p)( v )(stk) 

= (null(signal-duqn*)—► e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(mk-array-signal-dec-post-init 

((signal-duqn)) ((driver-duqn))(hd(e))(type-desc) (direction) 

(lower-bound) (upper-bound )(element-type-desc) (element-waveform-type-desc) 
( t )(p)( v )( st k), 

mk-array-signal-dec-post-init-aux 

(tl(signal-duqn*))(tl(driver-duqn*))(tl(e))(type-desc)(direction) 

(lower-bound) (upper-bound) (element-type-desc) (element-waveform-type-desc) 
(t)(p)(v)(stk))) 

mk-array-signal-dec-post-init-elt-scalars-to(signal-duqn*) (driver-duqn* )(e) 

(type-desc) (lower-bound) (upper-bound) 
(element-type-desc)(element-waveform-type-desc) 
(*)(p)( v )(stk) 

= (null(signal-duqn*)—► c, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
let initial-waveforms = init-array-signal-to 

(signal-duqn) (driver-duqn) (e)( type-desc) 

(element-type-desc)(lower-bound)(upper-bound) in 

nconc 

(assign-array-to 

(driver-duqn) (initial-waveforms) (element-waveform-type-desc) 

(lower-bound)(0), 

mk-array-signal-dec-post-init-elt-scalars-to 

(tl(signal-duqn* ))(tl(driver-duqn* ))(e)(type-desc)(lower-bound) 
(upper-bound)(element-type-desc)(element-waveform-type-desc)(t)(p)(v) 

(stk))) 

mk-array-signal-dec-post-init-elt-scalars-downto(signal-duqn* )(driver-duqn* )(e) 

(type-desc)(lower-bound)(upper-bound) 
(element-type-desc) (element-waveform-type-desc) 
(t)(p)( v )(stk) 

= (null(signal-duqn*)—► e, 


138 



let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
let initial-waveforms = init-array-signal-downto 

(signal-duqn)(driver-duqn)(e)(type-desc) 
(element-type-desc)(lower-bound)(upper-bound) in 

nconc 

(assign-array-downto 

(driver-duqn)(initial-waveforms)(element-waveform-type-desc) 

(upper-bound)(0), 

mk-array-signal-dec-post-init-elt-scalars-downto 

(tl(signal-duqn* ))(tl(driver-duqn* ))(e)(type-desc)(lower-bound) 

(upper-bound)(element-type-desc)(element-waveform-type-desc)(t)(p)(v) 

(stk))) 


(D7) D [ ETDEC id id+ ] (t)(p)(u)(v)(stk) 

— (mk-decl-sd 

(hd(p))(e)(e)(e) 

(nconc(mk-etdec-post((id))(t)(p),u(v)(stk)))) 

mk-etdec-post(type-mark)(t)(p) 

= let d = lookup-desc(type-mark)(t)(p) in 
mk-enumlit-rels(d)(literals(d)) 

mk-enumlit-rels(d)(id*) 

= (null(tl(id*))—► e, 
let idi = hd(id*) 

and id 2 = hd(tl(id*)) in 

cons(mk-rel(d)((PRED ,idi ,id 2 )),mk-enumlit-rels(d)(tl(id*)))) 


The translation of an enumeration type declaration emits an SDVS declaration of the enu¬ 
meration type. 

(D8) D [ ATDEC id discrete-range type-mark ] (t)(p)(u)(v)(stk) 

= let (direction,expr 1 ,expr 2 ) = discrete-range in 

let lower-bound = (direction = TO —► expn, expr 2 ) 

and upper-bound = (direction = TO —► expr 2 , expri) in 
attributes-low-high 

((id,lower-bound,upper-bound,(UNIVERSAL-INTEGER) ))(t)(p)(u)(v)(stk) 

attributes-low-high(id,lower-bound,upper-bound, attribute-type-mark)(t)(p)(u)(v)(stk) 

= let dech = (DEC ,SYSGEN ,(mk-tick-low(id)),attribute-type-mark,lower-bound) 

and decl 2 = (DEC ,SYSGEN ,(mk-tick-high(id)),attribute-type-mark,upper-bound) in 
let decl + = (dech ,decl 2 ) in 
D [ decl+ 1 (t)(p)(u)(v)(stk) 

mk-tick-low(id) = catenate(id,“ , LOU”) 

mk-tick-high(id) = catenate(id,“’HIGH”) 


An array type declaration declares and initializes the ’low and ’high array type attributes. 

(D9) D [ PACKAGE id decl* opt-id J (t)(p)(u)(v)(stk) 

= D I decl* ] (t)(%(p)(id))(u)(v)(stk) 


139 




The declarations contained within a package are translated as usual, but in the package’s 
context in the TSE, via the extended path %(p)(id). 


(DIO) D [ PACKAGEBODY id decP opt-id ] (t)(p)(u)(v)(stk) 

= let pb-exit-desc = <*PACKAGE-BODY-EXIT* ,id,p,Av,s.u(v)(s)> in 
D J decP ] (t)(%(p)(id))(ui )(v)(stk-push(pb-exit-desc)(stk)) 
where ui = Avi ,stki .pkg-body-exit(vi )(stki) 

pkg-body-exit(v)(stk) 

= let <tg,qname,p,g> = hd(stk) in 
(case tg 

*STKBOTTOM* —► model-execution-complete(qname), 

*UNDECLARE* —► g(Avv,s.pkg-body-exit(vv)(s))(v)(stk), 

(*BEGIN* ) —► pkg-body-exit(v)(stk-pop(stk)), 

(*PACK AGE-BODY-EXIT* ,*LOOP-EXIT* ,*SUBPROGRAM-RETURN* ) g(v)(stk-pop(stk)), 
OTHERWISE 

—► impl-error(“Unknown execution stack descriptor with tag: ~a”,tg)) 


The declarations contained in a package body are translated in the package’s context in 
the TSE, via the extended path %(p)(id). A *PACKAGE-BODY-EXIT* descriptor 
is first pushed onto the execution stack to prevent the package’s declarations from being 
unelaborated when the package body is exited. 

(Dll) D J PROCEDURE id proc-par-spec* ] (t)(p)(u)(v)(stk) = u(v)(stk) 

(D12) D | FUNCTION id func-par-spec* type-mark ] (t)(p)(u)(v)(stk) = u(v)(stk) 

(D13) D [ SUBPROGBODY subprog-spec decP seq-stat* opt-id ] (t)(p)(u)(v)(stk) 

= u(v)(stk) 

Subprogram declarations need no Phase 2 translation, nor do subprogram bodies. 

(D14) D |[ USE dotted-name + J (t)(p)(u)(v)(stk) = u(v)(stk) 


The effect of USE clauses has already been recorded in the TSE during Phase 1; no further 
Phase 2 translation is necessary. 

(D15) D J STDEC id type-mark opt-discrete-range ] (t)(p)(u)(v)(stk) 

— let z = hd(p) 

and subtype-desc = lookup-desc-on-path(t)(p)(id) in 
let basetype-desc = base-type(subtype-desc) in 
let expri = type-tick-low(basetype-desc) 

and expr 2 = type-tick-low(subtype-desc) 
and expr3 = type-tick-high(subtype-desc) 
and expr 4 = type-tick-high(basetype-desc) in 
R [ expr, J (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

R l expr 2 ] (t)(p)(k 2 )(vi )(stki) 
where 

k 2 = A(e 2 ,f 2 ),v 2 ,stk 2 . 

R l expr 3 1 (t)(p)(k 3 )(v 2 )(stk 2 ) 
where 


140 



k 3 = A(e 3 ,f3),V3,stk 3 . 

R [ expr 4 I (t)(p)(k 4 )(v 3 )(stk 3 ) 
where 

k 4 = A(e 4 ,f 4 ),v 4 ,stk 4 . 

(mk-decl-sd 

(z) 

(nconc 

((e. 

—* (mk-rel 

(basetype-desc) 

((LE .d.ea))), 

£ ). 

(e 4 

—► (mk-rel 

(basetype-desc) 

((LE ,e 3 ,e 4 ))), 
e)))(e)(e) 

(ui(v 4 )(stk 4 ))) 

where 

ui = Av 5 ,stk 5 . 

attributes-low-high 

((id,expr 2 ,expr 3 , 

(idf(basetype-desc))))(t)(p)(u) 

(v 5 )(stk 5 ) 


The Phase 2 semantics of subtype declarations generates a state delta with guards in the 
precondition to ensure that the subtype range falls within the range of allowable values 
for the subtype’s base type. Assuming this holds, the continuation in the state delta’s 
postcondition performs the Phase 2 processing of declarations and initializations for the 
’low and ’high attributes representing the subtype bounds. 

(D16) D [ ITDEC id discrete-range ] (t)(p)(u)(v)(stk) 

= let z = hd(p) 

and integer-type-desc = lookup-desc-on-path(t)(p)(id) in 
let expri = type-tick-low(integer-type-desc) 

and expr 2 = type-tick-high(integer-type-desc) in 
attributes-low-high 

((id,ex P n ,expr 2 ,(UNIVERSAL JNTEGER) ))(t)(p)(u)(v)(stk) 

The Phase 2 semantics of integer type declarations simply processes declarations and ini¬ 
tializations for the ’low and ’high attributes representing the integer type bounds. 


8.4,5 Concurrent Statements 

(CSO) CS Je ] (t)(p)(u)(v)(stk) = u(v)(stk) 


(CS1) CS [con-stat con-stat* ] (t)(p)(u)(v)(stk) 

= l con-stat J (t)(p)(ui )(v)(stk) 

where ui = Av.stk.CS [[ con-stat* | (t)(p)(u)(v)(stk) 


A Ust of concurrent statements is translated in order, from first to last. 


141 



(CS2) CS [ PROCESS id decl* seq-stat* opt-id phasel-hook ]] (t)(p)(u)(v)(stk) 
— let pi = %(p)(id) in 
(mk-decl-sd 

(hd(p))(e)(e)(e) 

((make-vhdl-process-elaborate(id)(t)(pi)(seq-stat*)(ui)(v)(stk)))) 
where ui = Av,stk.D [decl* ] (t)(pi)(u)(v)(stk) 


8.4.6 Sequential Statements 

(SSO) SS [ £ ] (t)(p)(c)(v)(stk) = c(v)(stk) 


(SSI) SS [ seq-stat seq-stat* ] (t)(p)(c)(v)(stk) 

= SS[ seq-stat ] (t)(p)(ci)(v)(stk) 

where ci = Av,stk.SS [ seq-stat* ]] (t)(p)(c)(v)(stk) 


A list of sequential statements is translated in order, from first to last. 

(SS2) SS [ NULL atmark ] (t)(p)(c)(v)(stk) 

= ((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
mk-sd(hd(p))(e)(e)(£)(c(v)(stk))) 


NULL statements have no effect. 

(SS3) SS [ VARASSN atmark ref expr ] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let d = T [ ref J (t)(p) in 
E [ ref 1 (t)(p)(k 1 )(v)(stk) 
where 

ki = A(ei ,fi),v,stk. 

R [ expr ] (t)(p)(k 2 )(v)(stk) 
where 

k 2 = A(e 2 ,f 2 ),v,stk. 

let precondition — nconc(fi,f 2 ) in 
(mk-sd 

(hd(p))(precondition)(g:)((ei)) 
(nconc 

(assign(d)((ei ,e 2 )), 
c(v)(stk))))) 


assign(d)( target, value) 

= (case tag(d) 

(*BOOL* ,*BIT* ,*INT* ,*REAL* ,*TIME* ,*VHDLTIME* *ENUMTYPE* ,*WAVE* , 
*VOID* *POLY* ) 

—»■ (mk-rel(d)((EQ ,pound(target),value))), 

*SUBTYPE* — assign(base-type(d))( (target, value)), 

*INT_TYPE* —> assign(parent-type(d))((target,value)), 

*ARRAYTYPE* 

—♦ (is-bitvector-tdesc?(d) 

—► (is-constant-bitvector?(value) 

—► (case direction(d) 

TO 

—► assign-array-to 


142 



(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 
—► assign-array-down to 

(target)(value) (elty(d)) 

(mk-exp2 
(SUB , 

mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)), 1))(0), 
OTHERWISE —► impl-error(“Illegal direction: ""a”direction 

m, 

(mk-rel(d)((EQ ,pound(target),value)))), 
is-string-tdesc?(d) 

—► (is-constant-string?(value) 

—+ (case direction(d) 

TO 

—► assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 

—* assign-array-downto 

(target)(value) (elty(d)) 

(mk-exp2 
(SUB , 

mk-ex P 2(ADD ,(ORIGIN ,target),(RANGE ,target)), 1))(0), 
OTHERWISE impl-error(“Illegal direction: ~a”,direction 

(<*))), 

(mk-rel(d)((EQ ,pound(target), value)))), 

(dotted-expr-p(value)—> (mk-rel(d)((EQ ,pound(target),value))), 

(case direction(d) 

TO —> assign-array-to( target) (value)(elty(d))( (ORIGIN ,target))(0), 

DOWNTO 

—► assign-array-downto 

(target)(value)(elty(d)) 

(mk-exp2 

(SUB ,mk-ex P 2(ADD ,(ORIGIN ,target),(RANGE ,target)), 

1 ))( 0 ), 

OTHERWISE —► impl-error( “Illegal direction: ~a”,direction(d))))), 
*RECORDTYPE* 

—► (dotted-expr-p(value)-^ assign-record(d)((target,value)), 
assign-record-fields(comp onen ts(d)) ((target, value))), 

OTHERWISE —► impl-error(“Unrecognized Stage 3 VHDL type tag: ~a”,tag(d))) 


The translation of a variable assignment statement first translates its left and right parts, 
obtaining translated expressions and guard formulas. Note that the left part is translated 
by E and is therefore not dereferenced (by application of the dot function), as it would be if 
R were used instead. The precondition of the generated state delta consists of the combined 
lists of guard formulas, and its mod list is the translated left part. Its postcondition asserts 
the new value of the left part place, and then asserts succeeding state deltas by appropriately 
using the continuation c. Assignments in Stage 3 VHDL can be scalar or can assign entire 
arrays. Entire array assignments are asserted element by element via auxiliary semantic 
function array-signal-assignment. 

(SS4) SS [ SIGASSN atmark delay-type ref waveform J (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p), w \pc”)),atmark), 
let d = T l ref J (t)(p) in 
(case tag(d) 


143 



(♦BOOL* ,*BIT* ,*INT* ,*REAL* ,*TIME* *ENUMTYPE* ,*SUBTYPE* , 
*INT_TYPE* ) 

—► scalar-signal-assignment 

(seq-stat)(delay-type)(ref)(waveform)(d)(t)(p)(c)(v)(stk), 

♦ARRAYTYPE* 

—► array-signal-assignment 

(atmark) (delay-type) (ref)(waveform)(t)(p)(c)(v)(stk), 

OTHERWISE 

—► impl-error 

(“Signal assignment not implemented for object ”,ref, 

“ of type ”,d))) 

scalar-signal-assignment (seq-stat) (delay-type) (ref)(waveform )(d)(t)(p)(c)(v)(stk) 

= E I ref J (t)(p)(k)(v)(stk) 
where 

k = A(signal-name,guard),v,stk. 

let driver-name = name-driver(signal-name) in 
W [ waveform J (t)(p)(wave-cont)(v)(stk) 
where 

wave-cont = A(trans*,guard*),v,stk. 

let all-guards — nconc(guard,guard*) in 
(delay-type = TRANSPORT 
—► (mk-sd 

(hd(p))(all-guards)(e) ((driver-name)) 

(nconc 

(assign 

(waveform-type-desc(d)) 

((driver-name, 

mk-transport-update 

(dot(driver-name))(trans*))), 
c(v)(stk)))), 

let earliest-new-transaction = hd(trans*) in 
(mk-sd 
(hd( P )) 

(cons(mk-preemption 

(dot (driver-name)) 

(earliest-new-transaction), all-guards) )(e)( (driver-name)) 

(nconc 

(assign 

(waveform-type-desc(d)) 

((driver-name, 

mk-inertial-update 

(dot(driver-name))(trans*))), 

c(v)(stk))), 

mk-sd 

(hd( P » 

(cons(mk-not 

(mk-preemption 

(dot(driver-name)) 

(earliest-new-transaction)), 
all-guards) )(e)( (driver-name)) 

(nconc 

(assign 

(waveform-type-desc(d)) 

((driver-name, 

mk-inertial-update 

(dot(driver-name))(trans*))), 
c(v)(stk))))) 


144 



waveform-type-desc(type-desc) = <WAVEFORM ,e,*WAVE* ,(STANDARD) ,tt,type-desc> 
mk-transport-update(dot-driver)(trans*) 

= cons(TRANSPORT.UPDATE ,cons(dot-driver,trans*)) 

mk-preemption(dot-driver)( transaction) 
s= (PREEMPTION ,dot-driver,transaction) 

mk-inertial-update(dot-driver)(trans*) 

= cons(INERTIAL-UPDATE ,cons(dot-driver,trans*)) 

mk-not(e) — (NOT ,e) 


array-signal-assignment(atmark) (delay-type) (ref) (waveform) (t)(p)(c)(v)(stk) 

= let seq-stat + = cascade-array-signal-assignment 

(atmark)(delay-type)(ref)(waveform)(t)(p)(c)(v)(stk) in 
SS [ seq-stat + J (t)(p)(c)(v)(stk) 

cascade-array-signal-assignment (atmark) (delay-type) (ref )(agg-wave) (t)(p)(c)(v)(stk) 

= let array-refs = mk-array-refs(ref)(t)(p)(c)(v)(stk) 

and element-waves = mk-element-waves(agg-wave)(t)(p)(c)(v)(stk) in 
mk-scalar-signal-assignments(atmark)(delay-type) (array-refs) (element-waves) 

mk-scalar-signal-assignments(atmark)(delay-type)(array-refs)(element-waves) 

= (null(array-refs)—* e, 

cons((SIGASSN ,atmark,delay-type,hd(array-refs),hd(element-waves)), 
mk-scalar-signal-assignments 

(atmark) (delay-type) (tl(array-refs))(tl(element-waves)))) 

mk-array-refs(ref)(t)(p)(c)(v)(stk) 

= let d = T [ ref J (t)(p) in 
let direction = direction(d) 
and expri = lb(d) 
and expr 2 = ub(d) in 
R [ expn 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

R [expr 2 ] (t)(p)(k 2 )(vi)(stki) 

where 

k 2 = A(e 2 ,f2),V2 5 stk 2 . 

let sref = hd(second(ref)) 

and indices = (direction = TO 

—► gen-ascending-indices(ei )(e 2 ), 
gen-descending-indices(ei )(e 2 )) in 
mk-array-refs-aux(sref) (indices) 

gen-ascending-indices(min)(max) 

= (min > max —► e, cons(min,gen-ascending-indices(min4- l)(max))) 
gen-descending-indices(min)(max) 

= (max < min —► e, cons(max,gen-descending-indices(min)(max-l))) 

mk-array-refs-aux(sref) (indices) 

= (null(indices)--+ e, 

cons((REF ,(sref,(INDEX ,(NUM ,hd(indices))))), 
mk-array-refs-aux(sref ) (tl(indices)))) 


145 


mk-element-waves(agg-wave)(t)(p)(c)(v)(stk) 

= let aggregate-transactions = second (agg-wave) in 

let element-transaction-lists = mk-element-transaction-lists 

(aggregate-transactions)(t)(p)(c)(v)(stk) in 
mk-element-waves-aux(element-transaction-lists) 

mk-elemen t-transaction-lists(aggregate-transactions) (t)(p)(c)(v)(stk) 

= (null(aggregate-transactions)—* e, 

cons(mk-transaction-list(hd(aggregate-transactions))(t)(p)(c)(v)(stk), 

mk-element-transaction-lists(tl(aggregate-transactions))(t)(p)(c)(v)(stk))) 

mk-transaction-list(agg-trans)(t)(p)(c)(v)(stk) 

= let agg-value-expr = second(agg-trans) 
and time-expr = third (agg-trans) in 
let element-value-exprs = (case hd(agg-value-expr) 

REF 

mk-array-refs(agg-value-expr)(t)(p)(c)(v)(stk), 
(BITSTR ,STR ,PAGGR ) —* hd(tl(agg-value-expr)), 

OTHERWISE 

—► impl-error 

(“Illegal aggregate in transaction: ”, 
agg-value-expr)) in 

mk-simultaneous-transactions(element-vaIue-exprs)(time-expr) 

mk-simultaneous-transactions(expr*) (time-expr) 

= (null(expr*)—► e, 

cons((TRANS ,hd(expr*),time-expr), 
mk-simultaneous-transactions(tl(expr* ))(time-expr))) 


(SS5) SS [[ IF atmark cond-part+ else-part J (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p), “\pc”)),atmark), 
let seq-stat* = else-part in 
gen-if(cond-part+ )(seq-stat*)(seq-stat)(t)(p)(c)(v)(stk)) 

gen-if(cond-part* )(seq-stat*)(ifclause)(t)(p)(c)(v)(stk) 

= (null(cond-part*)—+ SS [seq-stat* ] (t)(p)(c)(v)(stk), 
let (expr,seq-stat*) = hd(cond-part*) in 
R [expr ] (t)(p)(k)(v)(stk) 
where 

k — A(e,f),vi ,stki. 

(mk-sd 

(hd(p))(cons(e,f))(e)(e) 

(let ci = Av2.stk2. SS [[ seq-stat* J (t)(p)(c)(V2)(stk2) in 
ci(vi)(stki)), 
mk-sd 

(hd(p))(cons(mk-not(e),f))(e)(e) 

(let C2 = Av3,stk3. 

gen-if 

(tl(cond-part*))(seq-stat*)(e)(t)(p)(c)(v 3 )(stk 3 ) in 
c 2 (vi)(stki)))) 


1 he abstract syntax of a Stage 3 VHDL IF statement consists of a finite, nonempty list of 
cond-parts followed by a (possibly empty) else-part. Each cond-part corresponds to an 
IF expr THEN seq-stats or an ELSIF expr THEN seq-stats construct in the concrete 


146 


syntax. Thus each cond-part must be translated into two state deltas: one for the case 
where expr evaluates to true and the other where it evaluates to false. The translation is 
performed by auxiliary semantic function gen-if, which takes as arguments (among others): 
the cond-part list and the seq-stats comprising the else-part. Successive recursive calls 
of gen-if process the first element of their cond-part list, reducing it to empty. When the 
cond-part list is empty, gen-if produces the translation of the else-part. The function 
mk-not constructs the logical negation of its argument. 

(SS6) SS [ CASE atmark expr case-alt + J (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 

R [ expr 1 (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

let d = T I expr J (t)(p) in 
gen-case(e)(d)((e,f))(case-alt' 1 ' )(t)(p)(c)(v)(stk)) 

gen-case(g)(d)(e,f)(case-alt*)(t)(p)(c)(v)(stk) 

= (null(case-alt*)—► e, 

let (h,sd) = gen-alt(g)(d)((e,f))(hd(case-alt*))(t)(p)(c)(v)(stk) in 
cons(sd,gen-case(append(g,h))(d)((e,f))(tl(case~alt* ))(t)(p)(c)(v)(stk))) 

gen-alt (g)(d)(e,f) (case-alt) (t)(p)(c)(v)(stk) 

= let case-alt-tag = hd(case-alt) in 
(case-alt-tag = CASEOTHERS 
—► let seq-stat* = hd(tl(case-alt)) in 

let ci = Avi,stki.SS [[ seq-stat* ] (t)(p)(c)(vi)(stki) in 
(*> 

mk-sd 

(hd(p))(append(f,(mk-not(mk-ors(g)))))(e)(e) 

(ci(v)(stk))), 

let (case-set,seq-stat*) = tl(case-alt) in 
let ci — Avi.stki.SS [f seq-stat* H (t)(p)(c)(vi )(stki) in 
let h — append(f,gen-guard(case-set)(d)(e)(t)(p)) in 
(h,mk-sd(hd(p))(h)(£)(£)(ci(v)(stk)))) 

mk-ors(disjs) 

= (case length(disjs) 

1 —*> hd(disjs), 

2 —* mk-or(hd(disjs))(hd(tl(disjs))), 

OTHERWISE — mk-or(hd(disjs))(mk-ors(tl(disjs)))) 

mk-or(el,e2) 

= (null(el)—*■ e2, 
null(e2)—► el, 
consp(el)A consp(e2) 

— (hd(el)= OR 

—► (hd(e2)= OR —► cons(OR ,append(tl(el),tl(e2))), append(el,(e2))), 
hd(e2)= OR —+ nconc((OR ,el),tl(e2)), 

(OR ,el,e2)), 

(OR ,el,e2)) 

gen-guard(discrete-range* )(d)(e)(t)(p) 

= (null(discrete-range*)—► e, 

let (direction,expri ,expr 2 ) = hd(discrete-range*) in 
R [expri 1 (t)(p)(ki)(e)(e) 


147 



where 

ki — A(ei,fi),vi,stki. 

(expri = expr 2 

—►let h — nconc(fi,(mk-rel(d)((EQ ,e,ei)))) in 
(null(tl(discrete-range*))—► h, 

(cons(OR , 

cons(hd(h),gen-guard(tl(discrete-range*))(d)(e)(t)(p))))), 
R [ expr 2 1 (t)(p)(k 2 )(v!)(stki) 
where 

k 2 = A(e 2 ,f 2 ),v 2 ,stk 2 . 
let h = nconc 

(fl ^2, 

(direction = TO 

- ((AND ,mk-rel(d)((GE ,e,ei)), 
mk-rel(d)((LE ,e,e 2 )))), 

((AND ,mk-rel(d)((LE ,e,ei)), 
mk-rel(d)((GE ,e,e 2 )))))) in 

(cons(OR , 
cons(hd(h), 

gen-guard(tl(discrete-range* ))(d)(e)(t)(p)))))) 


The abstract syntax of a CASE statement consists of a selector expression followed by a 
finite, nonempty list of case alternatives. Each case alternative consists of a fist of sequential 
statements, preceded either by a nonempty list of discrete ranges (indicated by CASECHOICE) 
or (for the last alternative only) by CASEOTHERS. Each of these discrete range lists represents 
a set of values, called a case selection set. If the selector expression evaluates to one of these 
values, then the corresponding sequential statement list is executed, after which control 
passes to the successor of the CASE statement. CASEOTHERS represents a case selection set 
that is the complement of the union of all of the other case selection sets relative to the set 
of values in the selector expression’s type. Phase 1 has ensured that no case selection sets 
intersect. 

The Phase 2 translation of a CASE statement first processes its selector expression, obtaining 
a translated expression and a guard formula. The translation is completed by the function 
gen-case, which takes the following arguments: 


• a formula, initially empty, that is the disjunction of formulas representing the case 
selection sets of case alternatives translated so far in this CASE statement — this for¬ 
mula’s negation represents the case selection set indicated by CASEOTHERS (if present) 
in the CASE statement; 

• the basic type of the selector expression (and the case selection set elements); 

• the selector expression’s translation and guard formula; and 

• a list of case alternatives. 


Each successive recursive call to gen-case processes the first element of its case alternative 
list, reducing the list to empty, at which time processing terminates normally. Each case 
alternative is processed by auxiliary semantic function gen-alt, which returns a formula 


148 



representing the case selection set for that alternative and a state delta representing the 
execution of the corresponding sequential statement list. This formula and state delta are 
collected by gen-case; the final result returned by gen-case is a list of state deltas. The 
function gen-guard converts discrete range lists into formulas representing case selection 
sets. The function mk-or(formula 1 , formula 2 ) constructs the logical disjunction of two 
formulas; if one of the formulas is empty, then mk-or ignores it and returns the nonempty 
one. 

(SS7) SS [ LOOP atmark id seq-stat* opt-id ] (t)(p)(c)(v)(stk) 

= let lp-desc — <*LOOP-EXIT* ,id,p,Av,s.c(v)(s)> in 
let stki = stk-push(lp-desc)(stk) in 
cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
loop-infinite(seq-stat)(id)(seq-stat* )(t)(%(p)(id))(c)(v)(stki)) 

loop-infinite(seq-stat)(id)(seq-stat*)(t)(p)(c)(v)(stk) 

= let ci = Av,stk. 

SS |f seq-stat* ] (t)(p)(c 2 )(v)(stk) 
where 
c 2 = Av,stk. 

loop-infinite(seq-stat)(id)(seq-stat*)(t)(p)(c)(v)(stk) in 
(mk-sd(hd(p))(e)(e)(e)(ci(v)(stk))) 


(SS8) SS |[ WHILE atmark id expr seq-stat* opt-id | (t)(p)(c)(v)(stk) 

= let lp-desc = <*LOOP-EXIT* ,id,p,Av,s.c(v)(s)> in 
let stki = stk-push(lp-desc)(stk) in 
cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
loop-while(seq-stat)(id)(expr)(seq-stat*)(t)(%(p)(id))(c)(v)(stki)) 

loop-while(seq-stat)(id)(expr)(seq-stat*)(t)(p)(c)(v)(stk) 

= R [[ expr ] (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

let ci = Av,stk. 

SS l seq-stat* J (t)(p)(c 2 )(v)(stk) 
where 
c 2 = Av,stk. 

loop-while 

(seq-stat) (id) (expr) (seq-stat* )(t)(p)(c)(v) 
(stk) in 

(mk-sd 

(hd(p))(cons(e,f))(e)(e)( c i( v )(stk)), 

mk-sd 

(hd(p))(cons(mk-not(e),f))(e)(e) 

(c(v)(stk-pop(stk)))) 


(SS9) SS J FOR atmark id ref discrete-range seq-stat* opt-id ] (t)(p)(c)(v)(stk) 
= let d = T [ ref ]] (t)(p) in 

let lp-desc = <*LOOP-EXIT* ,id,p, 

Av,s.c(v)(s)> in 

let stko = stk-push(lp-desc)(stk) in 
let (direction,expri ,expr 2 ) = discrete-range in 
cons((EQ ,pound(catenate(hd(p), K \pc”)),atmark), 

R [ expri ] (t)(p)(ki)(v)(stk) 


149 



where 

ki = A(ei,fi),vi,stki. 

R[expr 2 J (t)(p)(k 2 )(vi)(stki) 
where 

k 2 = A(e 2 ,f 2 ) J v 2 ,stk 2 . 

let bk-desc = <*BLOCK-EXIT* ,id,p,Av,s.c(v)(s)> in 
let decl = (DEC ,CONST , 

(last(hd(hd(tl(ref))))), 

(hd(d)),hd(tl(discrete-range))) in 
D f decl ] (t)(%(p)(id))(u)(v) 

(stk-push(bk-desc)(stk 0 )) 
where 
u = Av 3 ,stk 3 . 

let bg-desc = <*BEGIN* ,id,%(p)(id), 

Av,s.ci(v)(s)> in 

(mk-sd 

(hd(p))(nconc(fi ,fc))(e)(e) 

((case tag(d) 

*INT* 

—► let final-iter-val = eval-expr 
(e 2 ) in 

loop-for-int 

(seq-stat)(ref)(d) 

(direction) 

(final-iter-val) 

(seq-staf )(t)(%(p)(id))(ci) 

( v s) 

(stk-push(bg-desc)(stk 3 )), 

*ENUMTYPE* 

—► let initial-iter-val = eval-expr 

(ei) 

and final-iter-val = eval-expr 
(ea) 

and enum-lits = literals 

(d) in 

let parameter-updates = tl(get-loop-enum-param-vals 

(initial-iter-val) 

(final-iter-val) 

(direction) 

(enum-lits)) in 

loop-for-enum 

(seq-stat)(ref)(d) 

(direction) 

(parameter-updates) 

(final-iter-val) 

(seq-stat* )(t)(%(p)(id)) 

(CI)(V3) 

(stk-push 

(bg-desc)(stk 3 )), 

OTHERWISE 

—► impl-error 

(“Illegal FOR loop parameter type: ~a”, 

d)))) 

where 

ci = Av4,stk4. 

block-exit(v 4 )(stk 4 )) 


150 



loop-for-int(seq-stat)(ref)(d) (direction) (final-iter-val)(seq-stat* )(t)(p)(c)(v)(stk) 

= E [ ref 1 (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

R [ ref ] (t)(p)(ki )(v)(stk) 
where 

ki - A(ei,fi),v 1 ,stki. 

let c 0 = Av 0 ,stko- 

SS I seq-stat* ]] (t)(p)(ci)(v 0 )(stk 0 ) 
where 

ci = Av 2 ,stk 2 . 

(mk-sd 

(hd(p))(e)(e)((e)) 

(cons(mk-rel 

(d) 

((EQ ,pound(e), 

(direction = TO 
—♦ mk-exp2(ADD ,ei ,1), 
mk-exp2(SUB ,ei, 1)))), 
loop-for-int 

(seq-stat)(ref)(d)(direction) 

(fmal-iter-val^seq-stat* )(t) 

(p)(c)(v 2 )(stk 2 )))) in 

(mk-sd 

(hd(p)) 

(cons(mk-rel 

(d) 

(((direction = TO —► LE , GE ),ei,final-iter-val)),fi))(e)(e)(co(v)(stk)), 

mk-sd 

(hd( P )) 

(cons(mk-rel 

(d) 

(((direction = TO —► GT , LT ),ei,final-iter-val)),fi ))(£)( e ) 
(c(v)(stk-pop(stk)))) 

loop-for-enum(seq-stat)(ref)(d)(direction)(parameter-updates)(final-iter-val)(seq-stat’*)(t)(p)(c)(v)(stk) 

= E [ ref 1 (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

R I ref 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

let Co = Av 0 ,stko- 

SS [ seq-stat* ] (t)(p)(ci )(v 0 )(stko) 
where 

Cl = Av 2 ,stk 2 - 

(parameter-updates 
—(mk-sd 

(hd(p))(e)(e)((e)) 

(cons(mk-rel 

(d) 

((EQ ,pound(e), 
hd(parameter-updates))), 
loop-for-enum 

(seq-stat)(ref)(d) 

(direction) 

(tl(parameter-updates)) 


151 




(final-iter-val)(seq-stat*) 

( t )(p)(c)( v 2 )(stk 2 )))), 

(mk-sd 

(hd(p))( e )(e)( e ) 

(c(v)(stk-pop(stk))))) in 

(mk-sd 

(hd(p)) 

(cons(mk-rel 

(d) 

(((direction = TO —* LE , GE ),ei,final-iter-val)),fi))(e)(e)(co(v)(stk)), 

mk-sd 

(hd( P )) 

(cons(mk-rel 

(d) 

(((direction = TO —+ GT , LT ),ei,final-iter-val)),fi ))(e)(e:) 
(c(v)(stk-pop(stk)))) 

A loop — i.e., a LOOP, WHILE, or FOR statement — has a label (used for leaving that loop 
by means of an EXIT statement) and a body consisting of sequential statements. When a 
loop is entered, a new local environment is created (signified by an extended path in the 
TSE), and a *LOOP-EXIT* descriptor is pushed onto the execution stack, to be used by 
EXIT statements to leave the loop properly. The continuation in the descriptor is that of 
the loop statement itself. 

In the case of a simple LOOP statement, the loop is nonterminating, and a recursive state 
delta is generated by auxiliary semantic function loop-infinite. 

In the case of a WHILE statement, auxiliary semantic function loop-while first processes the 
control expression, yielding its translation and a guard formula, and then uses these items 
to generate two state deltas, one of which is recursive. The recursive state delta represents 
the situation where the control expression is true and the loop’s body is executed; recursion 
stems from the appearance of loop-while in the continuation of the loop body’s translation. 
The execution stack remains unchanged in this case. The other state delta represents the 
case where the loop is exited “naturally” by virtue of its control expression having the value 
false. The postcondition of this state delta is the loop statement’s continuation applied to 
the result of popping the loop statement’s descriptor from the execution stack. 

The case of a FOR statement is analogous to that of the WHILE statement, only more complex 
technically. 

(SSlO) SS ([ EXIT atmark opt-dotted-name opt-expr ] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let expr = opt-expr in 
R l expr ] (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi ,stki. 

let loop-name = (null(opt-dotted-name)—> e, 
last(opt-dotted-name)) in 
(null(e)—► exit(loop-name)(vi )(stk), 

(mk-sd 

(hd(p))( c °ns(e,f))(e)(e) 

(ci(vi)(stki) 

where ci — Av 2 ,stk 2 .exit(loop-name)(v 2 )(stk 2 )), 


152 



mk-sd 

(hd(p))(cons(mk-not(e),f))(e)(e) 

(c(vi)(stk,))))) 

exit(loop-name)(v)(stk) 

= let <tg,id,p,g> = hd(stk) in 
(case tg 

*LOOP-EXIT* 

—► (-inull(loop-name)A id ^ loop-name —► exit(loop-name)(v)(stk-pop(stk)), 
g(v)(stk-pop(stk))), 

♦UNDECLARE* —► g(Avv,s.exit(loop-name)(vv)(s))(v)(stk), 

(♦BEGIN* ,*BLOCK-EXIT* ) —► exit(loop-name)(v)(stk-pop(stk)), 
OTHERWISE -> execution-error(“*** EXECUTION ERROR ~ ILLEGAL EXIT ***”)) 


An EXIT statement: 


• transfers control from the interior of a loop to the immediate successor of that loop, 
provided that the EXIT statement’s condition (if any) is satisfied; and 

• adjusts the state of SDVS to reflect that transfer of control. 


The loop being exited can be named in the EXIT statement; Phase 1 has ensured that an 
appropriate label is used. If a loop is named, then that loop is exited. If no name appears, 
then the smallest loop enclosing the EXIT statement is exited. The EXIT statement may be 
enclosed within a system of nested loops. When the loop statement is exited, these other 
loops must first be exited in the order opposite that in which they were entered. When a 
FOR loop is exited, the effect of its implict local declaration of the iteration parameter is 
reversed by encountering an *UNDECLARE* descriptor on the execution stack. 

The translation of an EXIT statement first processes its control expression (which may be 
empty), resulting in a translated expression and a guard formula. If the control expression 
is nonempty, two state deltas are generated. The first represents the case where the control 
expression has the value true; in this case the exit process proceeds by invoking the semantic 
function exit, which appears in the state delta’s postcondition. The other state delta 
represents the case where the control expression has the value false, whereupon the exit 
does not occur and control passes to the immediate successor of the EXIT statement. If the 
control expression is empty, the exit is unconditional; the second state delta is not even 
generated. 

(SSll) SS [ CALL atmark ref ] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc w )),atmark), 
let basic-ref = second(ref) in 
let (tg,q,id) = hd(basic-ref) in 
let d = t(q)(id) in 

let expr* = second(second(basic-ref)) in 
gen-call(ref)(d)(expr* )(tt)(ff)(t)(p)(c)(v)(stk)) 

gen-call(ref )(d) (expr *) (gen-guards?) (no-unbind?)(t)(p)(c)(v)(stk) 

= let z = hd(p) 

and q = %(path(d))(idf(d)) in 
let (decl*,seq-stat*) = body(d) in 


153 



bind-parameters(ref)(d)(expr*)(gen-guards?)(t)(p)(u)(v)(stk) 
where 
u = Avi,stki. 

let sp-desc = <*SUBPROGRAM-RETURN* ,idf(d),p,Av,s.c(v)(s)> 

and par-desc = <*UNDECLARE* ,collect-allpars(extract-pars(d)(t)),p, 
Aci,v 4 ,stk 4 . 

(mk-sd 

(z)(e)(e)(e) 

(cons((EQ ,pound(catenate(z,“\pc”)), 

(EXITED ,$(path(d))(idf(d)))), 
unbind-parameters 

(ref)(d)(expr*)(no-unbind?)(t)(p)(ci) 
(v 4 )(stk„))), 

mk-sd 

(•) 

(((EQ ,dot(catenate(z,“\pc”)), 

(EXITED ,$(path(d))(idf(d))))))(e)(e) 
(unbind-parameters 

(ref)(d)(expr*)(no-unbind?)(t)(p)(ci)(v 4 ) 

(stk 4 )))> in 

let stk 5 = stk-push(par-desc)(stk-push(sp-desc)(stki)) in 
(mk-sd 

(z)(£)(e)(e) 

(cons((EQ ,pound(catenate(z,“\pc”)), 

(AT ,$(path(d))(idf(d)))), 
n 2 (vi)(stk 5 )))) 
where 

u 2 = Av 6 ,stk 6 . 

(null(characterizations(d)) 

D [ decl* ] (t)(q)(ui)(v6)(stk 6 ), 
null(seq-stat*) 

—► gen-characterizations 

(e)(p)(characterizations(d))(c 2 )(v 6 )(stk 6 ) 
where 

C 2 = Av 7 ,stk 7 . 

unbind-parameters 

(ref )(d)(expr*)(no-unbind?)(t)(p)(c 3 ) 

(v 7 )(stk 7 ) 

where c 3 = Avg ,stkg.block-exit(vg )(stkg), 
impl-error 

(“Offline Characterization not yet implemented 
for procedures with nonempty bodies !”)) 

where 

ui = Av 2 ,stk 2 . 

let bg-desc = <*BEGIN* ,idf(d),q,Avv,s.ci (vv)(s)> in 
SS [ seq-stat* J (t)(q)(ci )(v 2 )(stk-push(bg-desc)(stk 2 )) 
where ci = Av 3 ,stk 3 .block-exit(v 3 )(stk 3 ) 

gen-characterizations(sds)(p)(characterizations)(c)(v)(stk) 

= (null(characterizations) —► fix-characterized-sds(sds)(c(v)(stk)), 
let (q,id,parnames,pre,mod) = hd(characterizations) in 
let post = sixth(hd(characterizations)) in 
gen-characterizations 

(cons(gen-characterization(hd(p))($(q)(id))(parnames)(pre)(mod)(post)(v),sds)) 

(p)(tl(characterizations))(c)(v)(stk)) 

gen-characterization(z)(qid)(parnames)(pre)(mod)(post)(v) 


154 





= let sd = mk-sd 

(z)(((EQ ,dot(catenate(z,“\pc”)),(AT ,qid))))(e)(mod) 

(append 

(post,((EQ ,pound(catenate(z,“\pc”)),(EXITED ,qid))))) in 
subst-vars(parnames)(v)(sd) 

bind-parameters(ref)(d) (actuals) (gen-guards?) (t)(p)(u)(v)(stk) 

= let z = hd(p) 

and q = %(path(d))(idf(d)) 
and par-assoc-list = extract-pars(d)(t) in 
(null(par-assoc-list)—► u(v)(stk), 

let all-formals = get-qids(coUect-allpars(par-assoc-list))(t)(q) 

and to-formals = get-qids(collect-topars(par-assoc-list))(t)(q) 
and type-descriptors = collect-topars-types(par-assoc-list) 
and from-actuals = collect-fromargs(actuals)(par-assoc-list) in 
let v 0 = push-universe(v)(z)(all-formals) in 
let qual-all-formals = get-qualified-ids(all-formals)(v 0 ) 

and qual-to-formals = get-qualified-ids(to-formals)(v 0 ) in 
(mk-decl-sd 

M(e)(e)((z)) 

(nconc 

(mk-qual-id-coverings(all-formals) (qual-all-formals) (z)(v)(t), 
mk-par-decls(q)(par-assoc-list)(p)(t)(vo), 

(null (qu al-1 o-form als)—► u(v 0 )(stk), 
let expr* = from-actuals in 
MR[expr*](t)(p)(h)( V o)(stk) 
where 

h = A(e*,f*),vi,stk 1 . 
ui(vi)(stki) 
where 

ui = Av 2 ,stk 2 . 

let precondition = (gen-guards? 

—► nconc 

(mk-constraint-guards 

(e*)(type-descriptors) 

(t)( P )(v 2 )(stk 2 ),r), 

r) in 

(mk-decl-sd 

(z) (precondition) (e) (qucd-to-formals) 

(nconc 

(assign-multiple 

(qual-to-formals) (type-descriptors) (e*), 
u(v 2 )(stk 2 ))))))))) 


extract-pars(d)(t) 

= let signatures = signatures(d) in 
let signature = hd(signatures) in 
(null(tl(signatures))—► pars(signature), 
extract-poly-pars(pars(signature))(t)) 

extract-poly-pars(par-assoc-list)(t) 

= (null(par-assoc-list)—► e, 

let par = hd(par-assoc-list) in 
cons((hd(par),(hd(second(par)),poly-type-desc(t))), 
extract-poly-pars(tl(par-assoc-list))(t))) 


collect-zdlpars(par-aLSSoc-list) 

= (null(par-assoc-list)—► e, 

let (id,w) = hd(par-assoc-list) in 
cons (id,collect-all par s( tl( par- clssoc-Hs t)))) 


155 



collect-topars(par-assoc-list) 

= (nul^par-assoc-list)—* e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))£ (REF VAL) 

—► cons(id,collect-topars(tl(par-assoc-list))), 
collect-topars(tl(par-assoc-list)))) 

collect-fromargs(actuals)(par-assoc-list) 

= (null(par-assoc-list) —► e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))£ (REF VAL) 

—► cons(hd(actuals),cohect-fromargs(tl(actuals))(tl(par-assoc-list))), 
collect-fromargs(tl(actuals))(tl(par-assoc-list)))) 

collect-frompars(par-assoc-iist)(p) 

= (null(par-assoc-list)—► e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))€ (REF OUT) 

- cons((REF ,((SREF ,p,id))), 

collect-frompars(tl(par-assoc-list))(p)), 

collect-frompars(tl(par-assoc-list))(p))) 

collect-toargs(actuals-ids)(par-assoc-list) 

= (null(actuals-ids)—♦ e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))6 (REF OUT) 

“♦ cons(hd(actuals-ids),collect-toargs(tl(actuals-ids))(tl(par-assoc-list))), 
collect-toargs(tl(actuals-ids))(tl(par-assoc-list)))) 

collect-topars-types(par-assoc-list) 

= (null(par-assoc-list)—+ e, 

let (id,w) — hd(par-assoc-list) in 
(ref-mode(tmode(w))E (REF VAL) 

cons(tdesc(w),collect-topars-types(tl(par-assoc-list))), 

collect-topars-types(tl(par-assoc-list)))) 

collect-toargs-types(actuals)(par-assoc-list)(t)(p) 

= (null(actuals)—► c, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))£ (REF OUT) 

—* let expr = hd(actuals) in 
cons(T I expr J (t)(p), 

collect- toargs-types(tl(actuals))(tl(par-assoc-list))(t)(p)), 
collect-toargs-types(tl(actuaIs))(tl(par-assoc-list))(t)(p))) 

collect-guards-for-exprs(expr* )(d*)(t)(p)(v)(stk) 

= MR [ expr* ] (t)(p)(h)(v)(stk) 

where h = A(e*,f*),v,stk.mk-constraint-guards(e*)(d*)(t)(p)(v)(stk) 

mk-constraint-guards(e* )(d*)(t)(p)(v)(stk) 

— (null(e*)—► e, 
let e = hd(e*) 

and d = hd(d*) in 

(-.(tag(d)e (*INT* *SUBTYPE* *INT_TYPE*) ) 

—•* mk-constraint-guards(tl(e* ))(tl(d*))(t)(p)(v)(stk), 

(tag(d)= *INT* —► mk-constraint-guards(tl(e*))(tl(d*))(t)(p)(v)(stk), 
let dd = (tag(d)= *SUBTYPE* —► base-type(d), parent-type(d)) 


156 



and expri = type-tick-low(d) 
and expr 2 = type-tick-high(d) in 
R II expri 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,f 1 ),vi,stki. 

R l expr 2 ] (t)(p)(k 2 )(vi)(stki) 
where 

k 2 = A(e 2 ,f 2 ),v 2 ,stk 2 . 
nconc 

((ei —+ (mk-rel(dd)((LE t ei,e))), e), 

(e 2 —»► (mk-rel(dd)((LE ,e,e 2 ))), e), 
mk-constraint-guards(tl(e*))(tl(d*))(t)(p)(v)(stk))))) 

mk-par-decls(q)(par-assoc-list)(p)(t)(v) 

= (null(par-assoc-list)--* e, 

let (id,w) = hd(par-assoc-list) in 

cons((DECLARE ,qualified-id(qLd(t(q)(id)))(v),mk-type-spec(tdesc(w))(t)(p)), 
mk-par-decls(q)(tl(par-assoc-list))(p)(t)(v))) 

assign-multiple(duqn* )(type-descriptors)(e*) 

= (null(duqn*)—► e, 

let target = hd(duqn*) 

and d = hd(type-descriptors) 
and source = hd(e*) in 
nconc 

(assign(d)((target, source)), 

assign-multiple(tl(duqn* ))(tl(type-descriptors))(tl(e*)))) 

unbind-parameters(ref)(d)(actuals)(no-unbind?)(t)(p)(c)(v)(stk) 

= let z — hd(p) 

and q = %(path(d))(idf(d)) 
and par-assoc-list = extract-pars(d)(t) in 
let all-formals = get-qids(coUect-allpars(par-assoc-list))(t)(q) in 
let qual-all-formals = get-quahfied-ids( all-formals) (v) in 
(null(qual-all-formals) 

—*■ (mk-sd 

(*)(«)(«)(*) 

(c(pop-universe(v) (all-formals) )(stk-pop(stk)))), 

(no-unbind? 

—* (mk-sd 

(z) (e) (e) (cons(z,qual-all-formals)) 

(cons(mk-cover-already( (dot (z),cons(pound(z),qual-all-formals) ))(t), 
cons(mk-undeclare(qual-all-formals), 
c(pop-universe(v)(all-formals))(stk-pop(stk)))))), 
let exprj = actuals in 
MR I exprj 1 (t)(p)(hi )(v)(stk) 
where 

hi = A(ei,fi),v i> stki. 

let to-actuals = collect-toargs(underef(eJ ))(par-assoc-list) in 
let qual-to-actuals = get-qualified-ids(to-actuals)(vi) in 
(null(qual-to-actuals) 

—> (mk-sd 

(z) (e ) (e) (cons( z, qu al- all-form als)) 

(cons(mk-cover-already 

((dot(z),cons(pound(z),qual-all-formals)))(t), 
cons(mk-undeclare(qual-all-formals), 
c(pop-universe(vi )(all-formals))(stk-pop(stki)))))), 


157 



let from-formals = coUect-frompars(par-assoc-list)(q) 
and type-descriptors = collect-toargs-types 

(actuals)(par-assoc-list)(t)(p) in 

let expr 2 = from-formals in 
MR U expr* 1 (t)(q)(h 2 )(vi)(stki) 
where 

h 2 = A(eJ,fJ),v 2 ,stk 2 . 
ui(v 2 )(stk 2 ) 
where 

ui = Av 3 ,stk 3 . 

let guard* = nconc 

(collect-guards-for-exprs 

(from-formals) 

(type-descriptors) (t) 
(q)( v 3 )(stk 3 ),fj, 
f|) in 

(mk-sd 

(z)(guard*)(e)(qual-to-actuals) 

(nconc 

(assign-multiple 
(qual-to-actuals) 
(type-descriptors)(eJ), 
U2(v 3 )(stk 3 )))) 

where 

u 2 = Av 4 ,stk 4 . 

(mk-sd 

(z)(e)(e) 

(cons(z,qual-all-formals)) 
(cons(mk-cover-already 
((dot(z), 
cons(pound(z), 
qual-aU-formals)))(t), 
cons(mk-undeclare 

(qual-all-formals), 
c(pop-universe 
( v 0 

(all-formals)) 

(stk-pop(stk 4 ))))))))) 


underef(actuals) 

= (null(actuals)—► e, 

let actual — hd(actuals) in 

(dotted-expr-p(actual )—+ cons(second(actual),underef(tl(actuals))), 
cons(actual,underef(tl(actuals))))) 


mk-cover-already(id,lst)(t) 

= (new-declarations()—► mk-rel(univint-type-desc(t))((EQ ,hd(lst),id)), 
mk-cover(id,lst)) 


mk-undeclare(lst) = cons(UNDECLARE ,1st) 


Procedure calls in Stage 3 VHDL use call by value-result semantics. The translation of a 
procedure call consists of the following steps: 

• The actual parameters are translated and then gen-call pushes a subprogram return 
descriptor and then a (single) undeclaration descriptor for all of the formal parameters 
onto the execution stack. 


158 



• SDVS declarations of all of the formal parameters are emitted (in bind-parameters). 

• The IN and INOUT formal parameters are bound to their corresponding actual param¬ 
eters by first translating the actual parameters and then in effect assigning them to 
their corresponding formals by emitting appropriate equality relations (as in the trans¬ 
lation of assignment). This is done by auxiliary semantic function bind-parameters. 
In these equality relations, the qualified names of the formal parameters must refer to 
the procedure’s declaration TSE, whereas the qualified names in the actual parame¬ 
ters refer to the procedure’s calling environment. This implements the semantics of 
static binding required by VHDL. 

• The subprogram may have either a specific body or a set of state delta characteriza¬ 
tions, but not both. Different actions are performed in each case. 

1. If the procedure has a body, the procedure’s local declarations and statements 
are translated in the procedure’s declaration environment after first pushing a 
♦SUBPROGRAM-RETURN* descriptor on the execution stack. This de¬ 
scriptor will be used to perform a return from the procedure, whether that return 
is explicit via a RETURN statement or implicit via encountering the end of the pro¬ 
cedure’s body. 

2. If the procedure has one or more characterizations, state deltas representing the 
actions of the procedure are produced by the functions gen-characterizations 
and gen-characterization. These two functions use the SDVS functions fixed- 
characterized-sds and subst-vars, part of the implementation of an offline 
characterization mechanism for SDVS [3], 

• Auxiliary semantic function unbind-parameters is invoked to assign the (final) val¬ 
ues of the INOUT and OUT formal parameters to their corresponding actual parameters 
(which must, of course, have reference types). 


(SS12) SS l RETURN atmark opt-expr ] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p), “\pc”)),atmark), 
let expr = opt-expr in 
R[expr](t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

(nu 11(e)—► (mk-sd(hd(p))(e)(e)(e)(return(v)(stk))), 
let d = context(t)(p) in 
let result-d = tdesc(extract-rtype(d)) in 
let precondition = nconc 

(ink-constraint-guards 
((e))(( re sult- d ))( t )(p) 
(v)(stk),f) in 

(mk-sd 

(hd(p)) (precondition) (e) 
((qualified-id(qid(d))(v))) 

(nconc 

(assign(result-d)((qualified-id(qid(d))(v),e)), 

ci(v)(stk) 

where ci = Av,stk.return(v)(stk)))))) 


159 



return(v)(stk) 

= let <tg,qname,p,g> = hd(stk) in 
(case tg 

*UNDECLARE* —► g(Avv,s.return(vv)(s))(v)(stk), 

(^BLOCK-EXIT* ,*SUBPROGRAM-RETURN* ) - g(v)(stk-pop(stk)), 

(*BEGIN* *LOOP-EXIT* ,*PACK AGE-BODY-EXIT* ) — return(v)(stk-pop(stk)), 
OTHERWISE 

—*■ impl-error(“Bad execution stack descriptor tag in context: ~a”,tg)) 
context(t)(path) 

= let d = t(path)(*UNIT* ) in 

(d = *UNBOUND* —► context(t)(rest(path)), 

(case tag(d) 

(*PROCEDURE* *FUNCTION* *PACKAGE* ) -+ t(rest(path))(last(path)), 
OTHERWISE —+ context(t)(rest(path)))) 

extract-rtype(d) 

= let signature = hd(signatures(d)) in 
rtype(signature) 


RETURN statements come in two varieties: with an expression, to effect a return from a 
function, and without an expression, to effect a return from a procedure. If the RETURN is 
from a function, then the expression must first be translated and an assignment of its value 
to the function’s (statically and dynamically uniquely qualified) name must be asserted via 
an equality relation. Then (no matter whether the RETURN is from a procedure or a function), 
the function return (similar to exit) is invoked to use the topmost ♦SUBPROGRAM- 
RETURN* descriptor on the execution stack to return from the subprogram, after first 
effecting exits from intervening loops and effecting necessary undeclarations. The function 
context determines the qualified name of the subprogram from which the return is being 
made. 

(SS13) SS [ WAIT atmark ref* opt-expri opt-expr 2 J (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p), “\pc”)),atmark), 
let ci = Av,stk. 

(mk-sd 

(hd(p))(e)(e)(e) 

((make-vhd]-try-resume-next-process(hd(p))(v)(stk)))) in 
MMref* ](t)(p)(h)(v)(stk) 
where 

h = A(e*,f*),vi,stkj. 

let expri = opt-expri in 
R I expri 1 (t)(p)(kj)(v)(stk) 
where 

ki = A(ei ,fi),v,stk. 

let expr 2 = opt-expr 2 in 
R [ expr 2 1 (t)(p)(k 2 )(v)(stk) 
where 

k 2 = A(e 2 ,f 2 ),v,stk. 

let process-id = last(find-process-env 
(t)(p)) in 

(mk-sd 

(hd(p))(nconc(fi ))(«)<£) 

((make-vhdl-process-suspend 
(process-id)(get-signals(e’)) 

(ei)(e 2 )(c)(ci(v)(stk)))))) 


160 



find-process-env(t)(p) 

= (null(p)V tag(t(p)(*UNIT* ))= ^PROCESS* - p, find-process-env(t)(rest(p))) 


get-signals(signal-names) 

= (null (signal-names)—► e, 

cons(find-signal-structure(hd(signal-names)),get-signals(tl(signal-names)))) 


8.4.7 Waveforms and Transactions 

(Wl) W [[ WAVE transaction + ] (t)(p)(wave-cont)(v)(stk) 
- TRM l transaction + ] (t)(p)(wave-cont)(v)(stk) 


(TRMO) TRM [ e ] (t)(p)(wave-cont)(v)(stk) = wave-cont((e,e))(v)(stk) 

(TRM1) TRM [ transaction transaction* J (t)(p)(wave-cont)(v)(stk) 

= TR l transaction ] (t)(p)(trans-cont)(v)(stk) 
where 

trans-cont = A(trans,guard),v,stk. 

TRM J transaction* ] (t)(p)(wave-conti)(v)(stk) 
where 

wave-conti = A(trans*, guard* ),v,stk. 
wave-cont 

((cons(trans,trans*), 
nconc(guard,guard* )))(v)(stk) 


The transactions in a waveform are translated in order, from left to right. 

(TR1) TR [ TRANS expr opt-expr ] (t)(p)(trans-cont)(v)(stk) 

= R[expr](t)(p)(k)(v)(stk) 
where 

k = A(ei,fi),v,stk. 

let expr 2 = opt-expr in 
R I expr 2 ] (t)(p)(ki )(v)(stk) 

where 

ki = A(e 2 ,f 2 ),v,stk. 
trans-cont 

((mk-transaction-for-update(ei )(e 2 ),nconc(fi ,f 2 ))) 

(v)(stk) 


mk-transaction-for-update(transaction-value)(delay-time) 

= let transaction-time = (null(delay-time)—► mk-add-delay-time(0)(l), 

mk-add-delay-time(delay-time)(0)) in 
mk-transaction( transaction-time) (transaction-value) 


mk-add-delay-time(global)(delta) 

= (TIMEPLUS ,dot(VHDLTIME ),mk-vhdltime(global)(delta)) 
mk-vhdltime(global) (delta) = (VHDLTIME ,global,delta) 


161 



8.4.8 Expressions 


Two semantic functions, E and R, translate expressions. E obtains the (qualified) place 
name corresponding to a scalar or array. R yields an expression that represents a value 
rather than a reference. 

(MEO) Ml [ £ 1 (t)(p)(h)(v)(stk) = h(( e ,e))(v)(stk) 

(ME!) ME [ ref ref* J (t)(p)(h)(v)(stk) 

= E [ ref ] (t)(p)(k)(v)(stk) 
where 

k — A(e,f),vi,stki. 

MEffrer](t)(p)(h 1 )(vi)(stk 1 ) 
where hi = A(e*,r) 3 v 2 >stk 2 .h((cons(e,e*),nconc(f,f*)))(v 2 )(stk 2 ) 


(MRO) MR l e ] (t)(p)(h)(v)(stk) = h((e,e))(v)(stk) 

(MR1) MR [expr expr* J (t)(p)(h)(v)(stk) 

= 3L l expr J (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi ,stki. 

MR E expr* ] (t)(p)(hi)(v!)(stki) 
where hi = A(e*,f*),v 2 ,stk 2 .h((cons(e,e*),nconc(f,r)))(v 2 )(stk 2 ) 


The translation of a (possibly empty) multiple expression list yields a list of translated 
expressions and a corresponding list of guard formulas. 

(El) E J REF modifier" 1 " J (t)(p)(k)(v)(stk) 

= let basic-ref = modifier -1 " in 

let (basic-name,d) — gen-basic-name(basic-ref)(t)(v) in 
gen-name(ref)(basic-name)(e)(d)(tl(basic-ref))(t)(p)(k)(v)(stk) 


gen-basic-name(basic-ref)(t)(v) 

= let (tg,q,id) = hd(basic-ref) in 
let d = t(q)(id) in 
(case tag(d) 

(^PROCEDURE* ,*FUNCTION* ) - (qualified-id(qid(d))(v),d), 
OTHERWISE —► (qualified-id(qid(d))(v),tdesc(type(d)))) 

gen-name(ref )(e)(f)(d) (ref-tail) (t)(p)(k)(v)(stk) 

= (null(ref-tail) —+ k((e,f))(v)(stk), 
let modifier = hd(ref-tail) in 
let (tg,isp) = modifier in 
(case tg 

INDEX —► gen-array-ref(isp)(e)(f)(d)(t)(p)(c)(v)(stk), 

SELECTOR —► gen-record-ref(isp)(e)(f)(d)(c)(v)(stk), 

PARLIST gen-function-call(ref)(isp)(d)(t)(p)(c)(v)(stk), 

OTHERWISE 

—► impl-error( “Unrecognized Stage 3 VHDL reference modifier tag: ~a”,tg)) 
where 

c = A(ei ,fi,di),v,stk. 

gen-name(ref)(ei)(fi)(di)(tl(ref-tail))(t)(p)(k)(v)(stk)) 


162 



gen-array-ref(expr)(e)(f)(d)(t)(p)(c)(v)(stk) 

= R [ expr 1 (t)(p)(k)(v)(stk) 
where 

k = A(e 0 ,fo),v,stk. 

c(((ELEMENT ,e,e 0 ), 
nconc 
(f,fo, 

(null(ub(d)) 

—► (mk-rel(univint-type-desc(t))((GE ,e 0 ,(ORIGIN ,e)))), 
(mk-rel(univint-type-desc(t))((GE ,e 0 ,(ORIGIN ,e))), 
mk-rel 

(univint-type-desc(t)) 

((LE ,eo, 

mk-exp2(SUB ,mk-exp2(ADD ,(ORIGIN ,e),(RANGE ,e)),l)))))), 
elty(d)))( v )(stk) 

gen-record-ref(id)(e)(f)(d)(c)(v)(stk) 

= c((mk-recelt(e,id),f,lookup-record-desc(components(d))(id)))(v)(stk) 

mk-recelt(e)(id) = (RECORD ,e,id) 

lookup-record-desc(comp* )(id) 

= (nu!l(comp*)—► ^UNBOUND* , 
let (x,d) = hd(comp*) in 
(x = id —► d, lookup-record-desc(tl(comp*))(id))) 

gen-function-call(ref)(expr ,,, )(d)(t)(p)(c)(v)(stk) 

— declare-function~name(d)(t)(p)(u)(v)(stk) 
where 
u = Av,stk. 

gen-call(ref)(d)(expr*)(tt)(tt)(t)(p)(ci)(v)(stk) 
where 
ci = Av,stk. 

c((qualified-id(qid(d))(v),e,tdesc(extract-rtype(d))))(v)(stk) 

declare-function-name(d)(t)(p)(u)(v)(stk) 

= let q = path(d) 

and dd = tdesc(extract-rtype(d)) in 
let z = hd(q) in 

let suqn + = get-qids((idf(d)))(t)(q) in 
let vi = push-universe(v)(z)(suqn' f ) in 
let duqn + = get-qualified-ids(suqn + )(vi) in 
let dc-desc = <*UNDECLARE* ,idf(d),q, 

Aui ,V2,stk2. 

undeciare-function-name 

(suqn + )(duqn + )(z)(t)(ui)(v 2 )(stk 2 )> in 

(mk-decl-sd 

(*)(«)(e)((*)) 

(nconc 

(mk-qual-id-coverings(suqn + )(duqn + )(z)(v)(t), 
mk-scalar-nonsignal-dec-post 

(e)((duqn + ,e,dd))(t)(q)(u)(vi )(stk-push(dc-desc)(stk))))) 

undeclare-function-name(suqn + )(duqn + )(z)(t)(u)(v)(stk) 

= (mk-sd 

(z)(e)(e)(cons(z,duqn + )) 

(cons(mk-cover-already((dot(z),cons(pound(z),duqn -l ')))(t), 
cons(mk-undeclare(duqn + ), 
u(pop-universe(v)(suqn + ))(stk-pop(stk)))))) 


163 



A reference must begin with at least a basic reference , which contains its root identifier 
and access path . Following its basic reference, a reference has zero or more array index, 
record field selection, or actual parameter list modifiers. The reference itself is translated 
by gen-name; the basic reference is translated by gen-basic-name. The array index and 
record field selection modifiers are translated by gen-array-ref and gen-record-ref. The 
translation of a reference is complicated by the appearance of a parameter list modifier, 
which represents a function call; these are translated by gen-function-call. 

Whenever a function is called (as part of an expression), the name of that function is used 
in the expression to name the value returned by that particular invocation. Because the 
same function can be invoked more than once in the same expression, each corresponding 
instance of the function’s name must be uniquely dynamically qualified, and each of those 
DUQNs must be declared (and later undeclared when they should no longer exist) to SDVS. 
The declaration is performed by function declare-function-name and the undeclaration 
by undeclare-function-name; the invocation of the latter function is encapsulated in an 
undeclaration (*UNDECLARE*) descriptor pushed onto the execution stack. After a 
new dynamic instance of the function’s name is declared, gen-function-call evaluates the 
actual parameters and then invokes gen-call to finish the translation of this function call. 

(RO) R [ e ] (t)(p)(k)(v)(stk) = k((e,e))(v)(stk) 


For technical convenience, expressions can be empty; the translation of an empty expression 
yields empty results. 

(Rl) R [ FALSE 1 (t)(p)(k)(v)(stk) = k((FALSE >c ))(v)(stk) 

(R2) R [ TRUE 1 (t)( P )(k)(v)(stk) = k((TRUE ,c))(v)(stk) 

(R3) R [ BIT bitlit ] (t)(p)(k)(v)(stk) = k((B [ bitlit J ,c))(v)(stk) 


(R4) R [ NUM constant ] (t)(p)(k)(v)(stk) = k((N [ constant ] ,e))(v)(stk) 


(R5) R [ TIME constant FS J (t)(p)(k)(v)(stk) = k((N [ constant | ,e))(v)(stk) 


(R6) R [ CHAR constant J (t)(p)(k)(v)(stk) = k((expr,e))(v)(stk) 


(R7) R J ENUMLIT id ] (t)(p)(k)(v)(stk) = k((id,e))(v)(stk) 


(R8) R l BITSTR bit-lit* ] (t)(p)(k)(v)(stk) 
= let expr* = bit-lit* in 

MR [expr* ] (t)(p)(k)(v)(stk) 


164 



(R9) R [ STR char-lit* ] (t)(p)(k)(v)(stk) 

= let expr* = char-lit* in 

MR [ expr* ] (t)(p)(k)(v)(stk) 

(RIO) R [ REF modifier* | (t)(p)(k)(v)(stk) 

= let ref = expr in 

E [ ref ] (t)(p)(ki)(v)(stk) 

where ki = A(e,f),vi,stki.k((dot(e),f))(vi)(stki) 

Scalar and array references are first E-translated, yielding an expression and a guard for¬ 
mula. The corresponding R-translation is obtained by applying the dot operation to the 
translated expression. 

(Rll) R [ PAGGR expr* ] (t)(p)(k)(v)(stk) = MR | expr* ] (t)(p)(k)(v)(stk) 


(R12) R [[TYPECONV expr type-mark J (t)(p)(k)(v)(stk) 

= let d = lookup-desc(type-mark)(t)(p) in 
R [ expr 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(e,f),v,stk. 

let constraint-guard* = mk-constraint-guards 

(( e ))((d))(t)(p)(v)(stk) in 
(null(constraint-guard*)—► k((e,f))(v)(stk), 

(mk-sd(hd(p)) (constrain t-guard*)(e)(e)(k((e,f))(v)(stk)))) 


(R13) R [ unary-op expr ] (t)(p)(k)(v)(stk) 

= R [ expr \ (t)(p)(ki)(v)(stk) 

where ki = A(e,f),vi,stki .k((mk-expl (unary-op,e),f))(vi)(stki) 


mk-expl (unary-op,e) 

= (case unary-op 

NOT — (NOT ,e), 

BNOT — (USNOT ,e), 

PLUS -+ e, 

NEG — (MINUS ,e), 

ABS -> (ABS ,e), 

(RNEG ,RABS ) —* (unary-op,e), 

OTHERWISE 

—► impl-error( “Unrecognized Stage 3 VHDL unary operator: "a”,unary-op)) 


(R14) R [binary-op expri expr 2 ] (t)(p)(k)(v)(stk) 

= R [ expri 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,fi,vj,stki). 

R H expr 2 ] (t)(p)(k 2 )(vi)(stki) 
where 

k 2 = A(e 2 ,f 2 ),V 2 ,stk 2 . 

k((mk-exp2(binary-op,ei ,e 2 ),nconc(fi ,f 2 )))(v 2 )(stk 2 ) 


165 



(R15) R [[relational-op expri expr 2 ] (t)(p)(k)(v)(stk) 

= £ I e *pri ] (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,stki). 

R [expr 2 ] (t)(p)(k 2 )(vi)(stki) 
where 

k 2 — A(e 2 ,f 2 ),v 2 ,stk 2 . 

let d = T [[ expri J (t)(p) in 
k((mk-rel(d)((relational-op,ei ,e 2 )),nconc(fi ,f 2 ))) 
(v 2 )(stk 2 ) 


8.4.9 Expression Types 

The function mk-rel (described earlier) requires a type descriptor as its first argument; 
application of the semantic function T determines the type descriptor of an expression as 
follows: 

• if the expression is a constant, its type descriptor is the basic type of that constant; 

• if the expression is a reference, its type descriptor is the basic type of that reference, 
obtained by the function get-type-desc; and 

• if the expression contains operators, its type descriptor is the basic result type of its 
top-level operator (if there is one); 

(TO) T [ e ] (t)(p) = void-type-desc(t) 

(Tl) T [[ FALSE ] (t)(p) = bool-type-desc(t) 

(T2) T [[ TRUE ] (t)(p) = bool-type-desc(t) 

(T3) T [[ BIT bitlit J (t)(p) = bit-type-desc(t) 

(T4) T J NUM constant ] (t)(p) = univint-type-desc(t) 

(T5) T [[ TIME constant FS J (t)(p) = time-type-desc(t) 

(T6) T J CHAR constant | (t)(p) = char-type-desc(t) 

(T7) T [ ENUMLIT id J (t)(p) 

= let d = lookup-desc-on-path(t)(p)(id) in 
tdesc(type(d)) 

(T8) T [ BITSTR bit-lit* ] (t)(p) = bitvector-type-desc(t) 

(T9) T J STR char-lit* ] (t)(p) = string-type-desc(t) 

(T10) T l REF modifier + ] (t)(p) 

= let basic-ref — modifier + in 
get-type-desc(basic-ref)(t)(p) 


166 



get-type-desc(basic-ref)(t)(p) 

= let (tg,q,id) = hd(basic-ref) in 
let d — t(q)(id) in 
(case tag(d) 

(♦PROCEDURE* ,*FUNCTION* *PROCESS* ) 

—► process-ref-tail(d)(tl(basic-ref))(t)(p), 

OTHERWISE —> process-ref-tail(tdesc(type(d)))(tl(basic-ref))(t)(p)) 

process-ref-tail(d)(ref-tail)(t)(p) 

= (null(ref-tail)—* d, 

let modifier = hd(ref-tail) in 
(case hd(modifier) 

INDEX —► process-ref-tail(elty(d))(tl(ref-tail))(t)(p), 

SELECTOR 
—► process-ref-tail 

(lookup-record-desc(components(d))(second(modifier)))(tl(ref-tail)) 

00(p)> 

PARLIST —► process-ref-tail(tdesc(extract-rtype(d)))(tl(ref-tail))(t)(p), 
OTHERWISE 
—► impl-error 

(“Unrecognized Stage 3 VHDL reference modifier tag: "a”, 
hd(modifier)))) 


(Til) T [[ PAGGR expr* | (t)(p) — void-type-desc(t) 

(T12) T [[ TYPECONV expr type-mark ]] (t)(p) = lookup-desc(type-mark)(t)(p) 


(T13) T [[ unary-op expr ] (t)(p) = tdesc(restypel(unary-op)(t)) 

restypel (unary-op)(t) 

= (case unary-op 

NOT —► (VAL ,bool-type-desc(t)), 

BNOT —► (VAL ,bit-type-desc(t)), 

(PLUS ,NEG ,ABS ) —+ (VAL ,univint-type-desc(t)) 5 
(RNEG ,RABS ) — (VAL ,real-type-desc(t)), 

OTHERWISE 

—► impl-error(“Unrecognized Stage 3 VHDL unary operator: "a”,unary-op)) 


(T14) T [ binary-op expn expr 2 ] (t)(p) 

= tdesc(restype2(binary-op)((expri ,expr 2 ))(t)(p)) 

restype2(binary-op)(exprj ,expr 2 )(t)(p) 

= (case binary-op 

(AND ,NAND ,OR ,NOR ,XOR ) mk-type((DUMMY VAL) )(bool-type-desc(t)), 

(BAND ,BNAND ,BOR ,BNOR ,BXOR ) - mk-type((DUMMY VAL) )(bit-type-desc(t)), 

(ADD ,SUB ,MUL ,DIV ,MOD ,REM ,EXP ) -► mk-type((DUMMY VAL) )(univint-type-desc(t)), 
(RPLUS ,RMINUS ,RTIMES ,RDIV ,REXPT ) — mk-type((DUMMY VAL) )(real-type-desc(t)), 
CONCAT 

-►let di = T [ expn 1 (t)(p) 

and d 2 = T [ expr 2 ] (t)(p) in 
mk-type((DUMMY VAL) )(mk-concat-tdesc(di )(d 2 )(t)), 

OTHERWISE 

—► impl-error(“Unrecognized Stage 3 VHDL binary operator: ~a’\binary-op)) 


167 




mk-concat-tdesc(di )(d 2 )(t) 

= (is-bit-tdesc?(di )V is-bitvector-tdesc?(di) 

—► array-type-desc 

(new-array-type-name(BIT_VECTOR ))(e)(e)(tt)(direction(d 1 ))(lb(di ))(e) 
(bit-type-desc(t)), 
let idfi = idf(dj) in 
array-type-desc 

(new-array-type-name((consp(idf])—+ hd(idfi), idfi )))(e)(c)(tt) 

(direction(di ))(lb(di ))(c)(elty(di))) 

(T15) T [ relational-op expn expr 2 ] (t)(p) = bool-type-desc(t) 


8.4.10 Primitive Semantic Equations 

The following semantic functions are primitive. 
(Nl) N [[ constant ] — constant 


(Bl) II [ bitlit J = mk-bit-simp-symbol(bitlit) 


mk-bit-simp-symbol(bitlit) 

= (case bitlit 

0 — (BS 0 1) , 

1 — (BS 1 1) , 

OTHERWISE—► impl-error(“Can’t construct simp symbol for bit: ~a ”,bitlit)) 


168 



9 Conclusion 


A precise and well-documented formal specification of the Stage 3 VHDL translator has been 
presented in this report. We have completed and exercised a Common Lisp implementation 
of both translation phases described herein. 

Stage 3 VHDL represents a robust behavioral subset of the VHSIC Hardware Description 
Language, encompassing the following VHDL language features: (restricted) design files, en¬ 
tity declarations, architecture bodies, ports, declarative parts in entity declarations, package 
STANDARD (containing predefined types BOOLEAN, BIT, UNIVERSAL-INTEGER, INTEGER, TIME, 
CHARACTER, REAL, STRING, and BIT_VECTOR), user-defined packages, USE clauses, array type 
declarations, certain predefined attributes, enumeration types, subtypes of scalar types, in¬ 
teger type definitions, type conversions, PROCESS statements, concurrent signal assignment 
statements, subprograms (procedures and functions), IF and CASE statements, WHILE and 
FOR loops, octal and hexadecimal representations of bitstrings, and general expressions of 
type TIME in AFTER clauses. 

As the SDVS interface to VHDL continues to expand and mature, our confidence grows in 
our language translator semantic specification and implementation paradigm. In 1994, we 
will be applying this paradigm to implement a translator for the Stage 4 VHDL language 
subset. Stage 4 VHDL is expected to include constructs that are needed to verify a VHDL 
application planned for fiscal year 1994, including structural descriptions (e.g. component 
declarations, component instantiation statements , and configuration declarations ), as well 
as an implementation of a symbolic VHDL hardware clock. 


169 



References 


[1] J. V. Cook, I. V. Filippenko, B. H. Levy, L. G. Marcus, and T. K. Menas, “Formal 
Computer Verification in the State Delta Verification System (SDVS),” in Proceedings 
of the AIAA Computing in Aerospace Conference , (Baltimore, Maryland), pp. 77-87, 
American Institute of Aeronautics and Astronautics, October 1991. 

[2] B. Levy, I. Filippenko, L. Marcus, and T. Menas, “Using the State Delta Verification 
System (SDVS) for Hardware Verification,” in Proceedings of the IFIP TC10/WG 10.2 
International Conference on Theorem Provers in Circuit Design: Theory, Practice and 
Experience: Nijmegen , The Netherlands (ed. V. Stavridou, T. F. Melham, and R. T. 
Boute), pp. 337-360, North-Holland, June 1992. 

[3] L. G. Marcus, “SDVS 12 Users’ Manual,” Technical Report ATR-93(3778)-4, The 
Aerospace Corporation, September 1993. 

[4] T. K. Menas, “SDVS 11 Tutorial,” Technical Report ATR-92(2778)-12, The Aerospace 
Corporation, September 1992. 

[5] B. H. Levy, “Feasibility of Hardware Verification Using SDVS,” Technical Report ATR- 
88(3778)-9, The Aerospace Corporation, September 1988. 

[6] IEEE, Standard VHDL Language Reference Manual, 1988. IEEE Std. 1076-1987. 

[7] D. F. Martin and J. V. Cook, “Adding Ada Program Verification Capability to the 
State Delta Verification System (SDVS),” in Proceedings of the 11th National Com¬ 
puter Security Conference , National Bureau of Standards/National Computer Security 
Center, October 1988. 

[8] T. Aiken, I. Filippenko, B. Levy, and D. Martin, “A Formal Description of the In¬ 
cremental Translation of Core VHDL into State Deltas in the State Delta Verifica¬ 
tion System (SDVS),” Technical Report ATR-89(4778)-9, The Aerospace Corporation, 
September 1989. 

[9] I. V. Filippenko, “Example Proof of a Core VHDL Description in the State Delta 
Verification System (SDVS),” Technical Report ATR-90(5778)-6, The Aerospace Cor¬ 
poration, September 1990. 

[10] I. V. Filippenko, “Some Examples of Verifying Core VHDL Hardware Descriptions 
Using the State Delta Verification System (SDVS),” Technical Report ATR-91(6778)- 
6, The Aerospace Corporation, September 1991. 

[11] I. V. Filippenko, “A Formal Description of the Incremental Translation of Stage 1 
VHDL into State Deltas in the State Delta Verification System (SDVS),” Technical 
Report ATR-91(6778)-7, The Aerospace Corporation, September 1991. 

[12] M. J. C. Gordon, The Denotational Description of Programming Languages: An In¬ 
troduction, (New York: Springer-Verlag, 1979). 


171 



[13] I. V. Filippenko, “A Formal Description of the Incremental Translation of Stage 2 
VHDL into State Deltas in the State Delta Verification System (SDVS),” Technical 
Report ATR-92(2778)-4, The Aerospace Corporation, September 1992. 

[14] J. V. Cook, “The Language for DENOTE (Denotational Semantics Translation 
Environment),” Technical Report TR-0090(5920-07)-2, The Aerospace Corporation, 
September 1990. 

[15] L. Marcus and B. H. Levy, “Specifying and Proving Core VHDL Descriptions in 
the State Delta Verification System (SDVS),” Technical Report ATR-89(4778)-5, The 
Aerospace Corporation, September 1989. 

[16] L. Marcus, T. Redmond, and S. Shelah, “Completeness of State Deltas,” Technical 
Report ATR-86(8454)-2, The Aerospace Corporation, September 1986. 

[17] T. K. Menas, “The Relation of the Temporal Logic of the State Delta Verification 
System (SDVS) to Classical First-Order Temporal Logic,” Technical Report ATR- 
90(5778)-10, The Aerospace Corporation, September 1990. 

[18] J. E. Doner and J. V. Cook, “Offline Characterization of Procedures in the State 
Delta Verification System (SDVS),” Technical Report ATR-90(8590)-5, The Aerospace 
Corporation, September 1990. 

[19] J. V. Cook and J. E. Doner, “Example Proofs Using Offline Characterization of Proce¬ 
dures in the State Delta Verification System (SDVS),” Technical Report TR-0090(5920- 
07)-3, The Aerospace Corporation, September 1990. 


172 




Index 


access 74, 124 
already-qualified-id 125 
arl 123 
argtypesl 88 
argtypesl-error 89 
argtypes2 90 
argtypes2-error 90 
array-signal-assignment 145 
array-size 59 
array-type 87 
array-type-desc 43 
artl 54 
arxl 95 

assign 127, 143 
assign-array-downto 128 
assign-array-to 128 
assign-multiple 157 
assign-record 128 
assign-record-aux 128 
assign-record-fields 128 
atO 83 
atl 83 
at2 83 
at3 83 

attributes 71 

attributes-low-high 63, 139 

axO 99 

axl 99 

ax2 99 

ax3 99 

bl 168 

bl 92 

base-type 45 
bind-parameters 155 
bit-type-desc 41 
bits-op 103 

bitvector-type-desc 42 
block-exit 121 
body 45 

bool-type-desc 41 

cascade-array-signal-assignment 145 
case-coverage 78 
case-overlap 83 


case-type-ok 78 
case-union 84 
char-type-desc 42 
characterizations 45 
check-array-aggregate 62 
check-enum-lits 63 
check-exprs 62 
check-if 77 
check-pkg-names 68 
check-wait-ref 83 
check-wait-refs 82 
chk-array-type 87 
collect-allpars 155 

collect-expressions-from-conditional-waveforms 
74 

collect-expressions-from-selected-waveforms 

73 

collect-fids 66 
collect-formal-pars 66 
collect-fromargs 156 
collect-frompars 156 
collect-guards-for-exprs 156 
collect-signals-from-expr 73 
coUect-signals-from-expr-list 73 
collect-toargs 156 
collect-toargs-types 156 
collect-topars 156 
collect-topars-types 156 
collect-transaction-expressions 73 
compatible-par-types 58 
compatible-signatures 58 
components 46 
concatenate-bits 133 
concatenate-characters 133 
construct-case-alternatives 74 
construct-cond-parts 75 
context 82, 160 
csO 141 
csl 141 
cs2 142 
cstO 72 
cstl 72 
cst2 72 


173 



cst3 73 
cst4 74 
csxO 97 
csxl 97 
csx2 97 
csx3 97 
csx4 98 
dO 123 
dl 123 
dlO 140 
dll 140 
d 12 140 
d 13 140 
d14 140 
d15 141 
d 16 141 
d2 123 
d3 123 
d4 123 
d5 124 
d6 124 
d7 139 
d8 139 
d9 140 

declare-function-name 163 

dfl 117 

dftl 52 

dfxl 95 

direction 45 

dot 115 

dotted-expr-p 119, 127 

drtO 84 

drtl 84 

drt2 84 

drxO 99 

drxl 99 

drx2 99 

dtO 55 

dtl 55 

dtlO 64 

dtl 1 65 

dtl2 65 

dt13 67 

dt14 67 

dt15 71 

dt 16 72 


dt2 55 
dt3 55 
dt4 55 
dt5 55 
dt6 61 
dt7 63 
dt8 63 
dt9 64 
dxO 96 
dxl 96 
dxlO 96 
dxll 96 
dxl2 96 
dxl3 96 
dxl4 97 
dxl5 97 
dxl6 97 
dx2 96 
dx3 96 
dx4 96 
dx5 96 
dx6 96 
dx7 96 
dx8 96 
dx9 96 
el 162 
elty 45 
enl 122 
entl 53 

enter-array-objects 62 

enter-characters 53 

enter-formal-pars 66 

enter-objects 53 

enter-package 52 

enter-predefined 53 

enter-standard 52 

enter-string 53 

enum-le 92 

enum-lt 92 

enxl 95 

etO 86 

etl 86 

etlO 88 

etll 88 

etl2 88 

etl3 88 


174 



et2 86 
et3 86 
et4 86 
et5 87 
et6 87 
et7 87 
et8 87 
et9 87 

eval-expr 115 
exO 100 
exl 100 
exlO 102 
exll 102 
exl2 102 
exl3 102 
ex2 100 
ex3 100 
ex4 100 
ex5 100 
ex6 100 
ex 7 100 
ex8 100 
ex9 100 
exit 153 

export-qualified-names 69 
exported 45 
extract-par-types 58 
extract-pars 155 
extract-poly-pars 155 
extract-rtype 58, 160 
extract-rtypes 82 
fifth 14 

filter-components 59 
find-architecture-env 73 
find-looplabel-env 80 
find-process-env 76, 161 
find-prognnit-env 56 
find-signal-structure 114 
fixed-characterized-sds 115 
fourth 14 
gen-alt 147 
gen-array-decl 130 
gen-array-decl-id* 131 
gen-array-decl-id+ 130 
gen-array-nonsignal-decl-id+ 132 
gen-array-ref 163 


gen-array-signal-decl-id+ 134 
gen-ascending-indices 145 
gen-basic-name 162 
gen-call 154 
gen-case 147 
gen-characterization 155 
gen-characterizations 154 
gen-characters 53 
gen-descending-indices 145 
gen-function-call 163 
gen-guard 148 
gen-if 146 
gen-name 162 
gen-record-ref 163 
gen-scalar-decl 124 
gen-scalar-decl-id* 124 
gen-scalar-decl-id-h 124 
gen-scalar-nonsignal-decl-id-b 124 
gen-scalar-signal-decl-id+ 129 
get-base-type 46, 59 
get-loop-enum-param-vals 115 
get-parent-type 46 
get-qids 125 

get-qualified-ids 111, 125 
get-signals 161 
get-type-desc 167 
idf 45 

import-legal 69 
import-qualified-names 68 
init-array-signal-downto 115 
init-array-signal-to 115 
init-scalar-signal 114 
init-var 111 
int-type-desc 41 
invert-bit 89 
is-array-tdesc? 44 
is-array? 44 
is-binary-op? 46 
is-bit-tdesc? 43 
is-bit? 43 

is-bitvector-tdesc? 44 
is-bitvector? 44 
is-boolean-tdesc? 43 
is-boolean? 43 
is-character-tdesc? 44 
is-character? 44 


175 





is-const? 44, 46 

is-constant-bitvector? 119, 127 

is-constant-string? 119, 127 

is-integer-tdesc? 43 

is-integer? 43 

is-paggr? 46 

is-poly-tdesc? 44 

is-poly? 44 

is-readable? 46 

is-real-tdesc? 43 

is-real? 43 

is-record~tdesc? 44 

is-record? 44 

is-ref? 46 

is-relational-op? 46 

is-sig? 45, 46 

is-string-tdesc? 44 

is-string? 44 

is-time-tdesc? 44 

is-time? 44 

is-unary-op? 46 

is-var? 44, 46 

is-void-tdesc? 44 

is-void? 44 

is-writable? 46 

last 15 

lb 45 

length 15 

length-expr 132 

list-type 58 

literals 45 

lookup-desc 124 

lookup-desc-for-ref 74 

lookup-desc-on-path 74, 124 

lookup-local 58 

lookup-record-desc 163 

lookup-record-field 58 

lookup-type 56 

lookup2 57 

loop-for-enum 152 

loop-for-int 151 

loop-infinite 149 

loop-while 149 

make-universe-data 110 

make-vhdl-begin-model-execution 114 

make-vhdl-process-elaborate 114 


make-vhdl-process-suspend 114 

make-vhdl-try-resume-next-process 114 

match-array-type-names 59 

match-integer-types 59 

match-type-names 59 

match-types 59 

meO 162 

mel 162 

mexO 100 

mexl 100 

mk-add-delay-time 161 
mk-array-decl 133 
mk-array-elt 133 
mk-array-nonsignal-dec-post 132 
mk-array-nonsignal-dec-post-declare 132 
mkarray-nonsignal-dec-post-init-downto 133 
mk-array-nonsignal-dec-post-init-to 133 
mk-array-refs 145 
mk-array-refs-aux 145 
mk-array-signal-dec-post 135 
mk-array-signal-dec-post-declare 135 
mk-array-signal-dec-post-init 136 
mk-array-signal-dec-post-init-aux 138 
mk-array-signal-dec-post-init-downto 137 
mk-array-signal-dec-post-init-elt-arrays-downto 

138 

mk-array-signal-dec-post-init-elt-arrays-to 

137 

mk-array-signal-dec-post-init-elt-scalars-downto 

139 

mk-array-signal-dec-post-init-elt-scalars-to 

138 

mk-array-signal-dec-post-init-to 137 
mk-array-signal-decl 135 
mk-array-signal-elt-fn-decls 136 
mk-array-signal-elt-fn-decls-aux 136 
mk-bit-simp-symbol 89, 168 
mk-bitvec-fn-decl 133 
mk-bool-eq 121 
mk-bool-neq 121 
mk-concat-tdesc 91, 168 
mk-constraint-guards 157 
mk-cover 117 
mk-cover-already 158 
mk-disjoint 117 
mk-dotted-names 133 


176 




mk-element-transaction-lists 146 
mk-element-waves 146 
mk-element-waves-aux 115 
mk-enuni-set 85 
mk-enumlit-rels 139 
mk-etdec-post 139 
mk-expl 165 
mk-exp2 128 
ink-inert ial-up date 145 
ink-initial-universe 110 
mk-not 145 
mk-or 147 
mk-ors 147 
mk-par-decls 157 
mk-preemption 145 
mk-qual-id-coverings 125 
mk-recelt 129, 163 
mk-rel 119 

mk-scalar-decl 117, 126 
mk-scalar-nonsignal-dec-post 125 
mk-scalar-nonsignal-dec-post-declare 126 
mk-scalar-nonsignal-dec-post-init 126 
mk-scalar-rel 120 
mk-scalar-signal-assignments 145 
mk-scalar-signal-dec-post 129 
mk-scalar-signal-dec-post-declare 129 
mk-scalar-signal-dec-post-init 130 
mk-scalar-signal-decl 129 
mk-scalar-signal-fn-decl 130 
mk-scalar-signal-fn-decls 136 
mk-set 85 

mk-simultaneous-transactions 146 
mk-slice-elt-names-downto 133 
mk-slice-elt-names-to 133 
mk-string-fn-decl 133 
mk-tick-high 63, 130, 139 
ink-tick-low 63, 130, 139 
mk-tinode 46 

mk-transaction-for-update 161 
mk-transaction-list 146 
mk-transport-update 145 
mk-type 46 
mk-type-spec 126 
mk-undeclare 158 
mk-vhdl-array-decl 132 
mk-vhdlthne 121, 161 


mk-waveform-type-spec 135 
model-execution-complete 121 
mrO 162 
mrl 162 
nl 168 
nl 92 

name-driver 114 

name-drivers 129 

name-qualified-id 111, 125 

name-type 57 

namef 45 

next-var 111 

nth-tl 85 

object-class 46 

otl.l 88 

ot2.1 89 

ot2.2 89 

parent-type 45 

pars 46 

path 45 

pbody 45 

pdtO 54 

pdtl 54 

pdt2 54 

pdt3 55 

pdxO 95 

pdxl 95 

pdx2 95 

pdx3 95 

pkg-body-exit 140 
poly-type-desc 42 
pop-universe 111 
pop-universe-vars 111 
pop-var 111 
position 85 
position-aux 85 
pound 115 
process 45 
process-dec 59 
process-ref-tail 167 
process-slcdec 61 
process-subprog-body 67 
process-use-clause 68 
push-universe 110 
push-universe-vars 110 
push-var 111 


177 



qid 45 

qualified-id 111, 125 

qualified-id-decls 125 

rO 164 

rl 164 

rlO 165 

rl 1 165 

rl2 165 

rl3 165 

rl4 165 

rl5 166 

r2 164 

r3 164 

r4 164 

r5 164 

r6 164 

r7 164 

r8 164 

r9 165 

real-lb 130 

real-op 103 

real-type-desc 42 

real-ub 130 

record-to-type 126 

ref-mode 46 

remove-enclosing-pkgs 68 
rest 15 

restypel 89, 167 
restype2 91, 167 
resvall 89, 92 
return 160 
reverse 85 
reverse-aux 85 
rtl 88 
rtype 46 
rxl 103 
scalar-op 102 

scalar-signal-assignment 145 
second 14 
set-card 78 
signatures 45 
simple-name-match 69 
simple-term 121 
sixth 15 
sltO 75 


sltl 75 


slt2 75 
slxO 98 
slxl 98 
slx2 98 
ssO 142 
ssl 142 
sslO 153 
ssll 153 
ssl2 159 
ssl3 160 
ss2 142 
ss3 142 
ss4 144 
ss5 146 
ss6 147 
ss7 149 
ss8 149 
ss9 150 
sstO 75 
sstl 75 
sstlO 81 
sstll 81 
sstl2 81 
sstl3 82 
sst2 75 
sst3 76 
sst4 77 
sst5 77 
sst6 77 
sst7 79 
sst8 79 
sst9 80 
ssxl 98 
ssxlO 99 
ssxll 99 
ssxl2 99 
ssxl3 99 
ssx2 98 
ssx3 98 
ssx4 98 
ssx5 98 
ssx6 98 
ssx7 98 
ssx8 99 
ssx9 99 

string-type-desc 42 


178 



subst-vars 115 
tO 166 
tl 166 
tlO 166 
til 167 

112 167 

113 167 

114 167 

115 168 
t‘2 166 
t3 166 
t4 166 
t5 166 
t6 166 
t7 166 
t8 166 
t9 166 
tag 45 
tdesc 46 
third 14 

time-type-desc 42 
tmode 46 
trl 161 

transform-if 98 

transform-list 102 

transform-name 101 

transform-name-aux 102 

trmO 161 

trml 161 

trtl 86 

trt2 86 

trxl 100 

trx2 100 

type 45 

type-tick-high 45 
type-tick-low 45 
ub 45 

unbind-parameters 158 
undeclare-function-name 164 
underef 158 
universe-counter 110 
universe-name 110 
universe-stack 110 
universe-vars 110 
univint-type-desc 41 
validate-access 57 


value 45 

vhdltime-type-desc 117 
void-type-desc 42 
wl 161 


waveform-type-desc 130, 145 
wtl 85 
wxl 100 


179 



