r 


AD 

. mil mil Hill III! nil 1ENTATI0N PAGE 




Form Approved 
OPM No. 0704-OiaS 



wigi I hourparrMponu. fidudlngMInwkxnimDlnglmtructian*. iMnMiguMngduiowcMgahMtngindmakmaajllfidiii 
wdng Mi bufdan MilnuM or iny olhtr aipacl at t»i coltalon at Irtotmuui includng ugQMIIana lor roducing tili Cudofl. to WMlwigen 
1 . 1215 JoNonon Otvs Hlgtaray. SuM 1204. Ailngnn. VA 22202-4X2. ind to Iw Otlka ol Mornwtlon tnt RoguMory AKin. ODIca ol 


mucincy use only (Leave Blank) 


4 TITLE AND SUBTITLE 


2. REPORT DATE 


3. REPORT TYPE AND DATES COVERED 

Final: 04 Jan 1991 to 01 Jun 1993 


Irvine CompilerCorporation, ICC Ada v7.0.0. Vaxstation 3100 Model M38, VMS 5.3-1 
(Host) to Intel i80960MC (bare machine)(Target), 910510W1.11148 


6. AUTHOR(S) 

Wright-Patterson AFB, Dayton, OH 
USA 


7 PERFORMING ORGANIZATION NAME(S) AND ADDRESS<ES) 

Ada Validation Facility, Language Control Facility ASD/SCEL 
BkJg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 


9 SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm3E114 
Washington, D C. 20301-3081 



8. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-468-0891 


10. SPONSORINGA^ONITORING AGENCY 
REPORT NUMBER 



12a. DISTRIBUTION/AVAILABIUTY STATEMENT 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13 ABSJRACT (Maximum 200 words) 

Ir^'ine Compiler Corporation, ICC Ada v7.0.0, Wright-Patterson AFB. OH. Vaxstation 3100 Model M38, VMS 5.3-1 (Host) 
to Intel i80960MC(bare machine){Target), ACVC 1.11. 



SEPl9l99n^ t 


14 SUBJECT TERMS 


91-11062 


15 . NUMBER OF PAGES 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF REPORT 

UN'^L.*SSIFIED 

NSN 7540 01 280-550 


18 SECURITY CLASSIFICATION 


iUNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


9 1 


n 12 


16 PRICE CODE 


I 20. UMPTATION OF ABSTRACT 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Sid 239-128 


















TfflS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FUKNISHED TO DTIC CONTAINED 
A SIGNinCANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 







AVF Control Number; AVF-VSR-468-0891 

1 August 1991 
91-01-04-ICC 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910510W1.11148 
Irvine Compiler Corporation 
ICC Ada V7.0.0 

Vaxstation 3100 Model M38, VMS 5.3-1 => Intel i80960MC (bare machine) 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright Patterson AFB OH 45433-6503 


Accesion Fcr 


NTIS 

CHAil V 1 

DfiC 

■ ! 

U. 


J.istii.cat'Oti i 

_ . ._.< 

f 

By... 

. 1 

D<it. ibutiun / j 

A 

.abuL’.’i’ly j 



Dist 

SP' C-di 

fl-l 

I 

1 

1 

! 

1 







Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 10 May 1991. 

Compiler Name and Version: ICC Ada v7.0.0 

Host Computer System: Vaxstation 3100 Model M38, VMS 5.3-1 

Target Computer System: Intel i80960MC (bare machine) 

Customer Agreement Number: 91-01-04-TCC 


See section 3.1 for any additional information about the testing 
envir'>nment. 

As a result of this validation effort, Validation Certificate 

910510U1.11148 is awarded to Irvine Compiler Corporation. This certificate 

expires on 1 March 1993. 

This report has been reviewed and is approved. 






Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 




DECLARATION OF CONFORMANCE 


Customer; Irvine Compiler Corporation 

Ada Validation Facility; ASD/SCEL, Wright-Patterson AFB OH ^5433-6503 
ACVCVersion; 1.11 

Ada Implementation; 

Compiler Name and Version; ICC Ada v7.0.0 

Host Computer System; VAXstation 3100 Model M38,VMS 5.3-1 
Target Computer System: i80960MC (bare machine) 

Customer's Declaration 

I, the undersigned, representing Irvine Compiler Corporation, declare 
that Irvine Compiler Corporation has no knowledge of deliberate devi¬ 
ations from the Ada Language Standard AN SI/MIL-STD-1815A in the 
implementation listed in this declaration. 


Date 

Scott Ogata, Executive Vice-President 
Irvine Compiler Corporation 
34 Executive Park, Suite 270 
Irvine, CA 92714 






TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM AND LINKER OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 














CHAPTER 1 
INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90I against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG891. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national lavs of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test .esults should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer & Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 





INTRODUCTION 


1.2 REFERENCES 


[Ada83] Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint Program 
Office, August 1990. 

[UG89] A^ Compiler Validation Capability User's Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executab'e tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECIC_FILE are used for this purpose. The package REPORT 
also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the valuer used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 







INTRODUCTION 


For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability 
(ACVC) 

Ada 

Implementation 

Ada Joint 
Program 
Office (AJPO) 

Ada 

Validation 
Facility (AVF) 

Ada 

Validation 

Organization 

(AVO) 

Compliance of 
an Ada 

Implementation 

Computer 

System 


The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

The means for testing corpliance of Ada implementations, 
consisting of the test ruite, the support programs, the ACVC 
user's guide and the teopiate for the validation summary 
report. 

An Ada compiler with its host computer system and its 
target computer system. 

The part of the certification body which provides policy and 
guidance for the Ada certification system. 


The part of the certification body which carries out the 
procedures required to establish the compliance of an Ada 
implementation. 

The part of the certification body that provides technical 
guidance for operations of the Ada certification system. 


The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 



INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdravn 
test 


Fulfillment by a product, process, or service of all 
requirements specified. 

An individual or coroorate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>;<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 




CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 14 March 1991. 


E28005C 

B28006C 

C34006D 

C35702A 

C35702B 

C35508I 

C35508J 

C35508M 

C35508N 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 



IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS; 


C2A113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 teits) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 20 tests check for the predefined type LONG_INTEGER; for 
this implementation, there is no such type: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C'5304C 

C45504C 

C45631C 

B86001V 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B‘^2004D 

CD7101F 


C35713C, B86001U, and C860>'oG check for the predefined type LONG_FLOAT; 
for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-poiat type with a 
name other than FlOAT, LONG FLOAT, or SHORT_FLOAT; for this 
implementation, there is no~such type. 

C45423A..B (2 tests), C45523A, ?>nd C45622A check that the proper 
exception is raised if MACHINh OVERFLOWS i TRUE and the results of 
various floatir.o-point operations lie outside the range of the base 
type; for this implementation, MACHINE_OVERFLOWS is FALSE. 

C45531M..P and C45532M.,P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than <'•7. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain length clauses 
that specify values for 'SMALL that are not powers of two or ten; this 
implementation does not support such values for 'SMALL. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this implementation, there is no such type. 

CD1009C checks whether a length c’ause can specify a non-default size 
for a floating-point type; this implementation does not support such 
sizes. 


CD2A53A checks operations of a fixed-point type for which a length 
clause specifies a power-of-ten TYPE'SMALL; this implementation does not 
support decimal 'SMALLs. (See section 2.3.) 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2 a 840 use length clauses 
to specify non-default sizes for access types; this implementation does 
not support such sizes. 


2-2 







IMPLEMENTATION DEPENDENCIES 


BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this implementation provides no package MACHINE_CODE. 

AE2101C and EE2201D..E (2 tests) use instantiations of package 
SEQUENTIAL_IO with unconstrained array types and record types with 
discriminants without defaults; these instantiations are rejected by 
this compiler. 

AE2101H, i:E240lD, and EE2401G use instantiations of package DIRECT_I0 
with unconstrained array types and record types with discriminants 
without defaults; these instantiations are rejected by this compiler. 

The tests listed in the following table check that USE_ERROR is raised 
it the given file operations are not supported for the given combination 
of mode and access method; this implementation supports these 
operations. 


Test 

File Operation Mode 

File Access 

M<. ‘■hod 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 

10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 

10 

CE2102F 

CREATE 

iNOUT FILE 

DIRECT 10 


CE2102I 

CREATE 

IN FILE 

DIRECT 10 


CE2102J 

CREATE 

OUT FILE 

DIRECT 10 


CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 

10 

CE21020 

RESET 

IN FILE 

SEQUEOTIAL 

10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 

10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 

10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 


CE2102S 

RESET 

INOUT FILE 

DIRECT 10 


CE2102T 

OPEN 

IN FILE 

DIRECT 10 


CE2102U 

RESET 

IN FILE 

DIRECT 10 


CE2102V 

OPEN 

OUT FILE 

DIRECT 10 


CE2102V 

RESET 

OUT FILE 

DIRECT 10 


CE3102E 

CRE\TE 

IN FILE 

TEXT 10 


CE3102F 

RESET 

Any Mode 

TEXT 10 


CE3102G 

DELETE 


TEXT 10 


CE3102I 

CREATE 

OUT FILE 

TEXT IC 


CE3102J 

OPEN 

IN FILE 

TEXT 10 


CE3102K 

OPEN 

OUT FILE 

TEXT 10 



CE2203A checks that URITE raises USE_EPROR if the capacity of an 
external sequent al file is exceeded; this implementation cannot 
restrict file capacity. 

CE2403A checks that VRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot restrict 
file capacity. 

CE33&4A checks that SET_LINE_LENGTK and SET_PAGE_LENGTH raise USE_ERROR 
if they specify an inappropriate value for the external file; there are 
no inappropriate values for this implementation. 


2-3 








IMPLEMENTATION DEPENDENCIES 


CE3A13B checks that PAGE raises LAYOlJT_ERROR when the value of the page 
number exceeds COUNT'LAST; for this implementation, the value of 
COUNT'LAST is greater than 150000, making the checking of this objective 
impractical. 

CE2108B. CE2108D, CE2108F, CE2108H, CE3112B, CE3112D (6 tests) checks 
for support of permanent files, and for this implementation, a file 
system has been implemented on the bare target that cannot support 
permanent files, making these tests inapplicable. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 48 tests and 2 support 
packages. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 

B24009A B59001E B59001F B83033B 

CD2A53A was graded inapplicable by Evaluation Modification as directed by 
the AVO. The test contains a specification of a power-of-10 value as 
'SMALL for a fixed-point type. The AVO ruled that, under ACVC 1.11, 
support of decimal 'SMALLs may be omitted. 

The tests below were graded passed by Test Modification as directed by the 
AVO. These tests all use one of the generic support procedures, 
Length_Check or Enum_Check (in support files LENCHECK.ADA & ENUMCHEK.ADA), 
which use the generic procedure Unchecked_Conversion. This implementation 
rejects instantiations of Unchecked_Conversion with array types that have 
non-static index ranges. The AVO ruled that since this issue was not 
addressed by AI-00590, which addresses required support for 
Unchecked_Conversion, and since AI-00590 is considered not binding under 
ACVC 1.11, the support procedures could be modified to remove the use of 
Unchecked_Conversion. Lines 40..43, 50, and 56..58 in LENCHECK and lines 
42, 43, and 58..63 in ENUMCHEK were commented out. 

CD1009A CD1009I CD1009M CD1009V CD1009V CD1C03A 

CD1C04D CD2A21A..C CD2A22J CD2A23A..B CD2A24A CD2A31A..C 

CD2A81A CD3014C CD3014F CD3015C CD3015E..F CD3015H 

CD3015K CD3022A CD4061A 

LA3004A and LA3004B were graded passed by Processing and Evaluation 
Modification as directed by the AVO. These tests check that when the 
bodies of library units (a procedure, function, and package) are made 
obsolete, that the implementation will detect the missing bodies at link 
time. This implementation will detect the missing bodies at link time. 

This implementation detects the missing bodies, but it also issues error 
messages that indicate that the main procedures must be re-compiled; this 


2-4 






IMPLEMENTATION DEPENDENCIES 


behavior violates LRM 10.3:6 & 8. To confirm that the implementation does 
not in fact require recompilation of the main procedures, the obsolete 
bodies were re-compiled (files LA3004A2..4 and LA3004B2..4 were modified to 
contain only the bodies) and the tests were then linked and executed; 

Report.Result output "NOT APPLICABLE" as expected. 

The AVO ruled that CE2102C, CE2102H, CE2103A..B, CE3102B, CE3107A (6 tests) 
are graded passed by Evaluation Modification. 

The AVO accepts the implementation's behavior, given that there is no way 
to create an illegal filename; these tests may be graded PASSED by the 
Evaluation Modification that allows the result FAILED only if the sole 
Report.Failed output is as follows (as was submitted in the dispute): 


CE2102C: NAME_ERR0R NOT RAISED - CREATE {SEQ (DIR)} 1 [63 (60)] 

(& -H) NAME_ERR0R NOT RAISED - CREATE {SEQ (DIR)} 2 [81 (78)| 

OE2103A: NAME_ERR0R NOT RAISED - UNSUCCESSFUL CREATE [52 (51) <45>j 

(& -B) 

<5. -3107A> 


CE3102B: NO EXCEPTION RAISED FOR <S...NAME1> - CREATE [ 95] 
NO EXCEPTION RAISED FOR <$...NAME2> - CREATE [110] 
OTHER EXCEPTION RAISED FOR <$...NAME1> - OPEN [135] 
OTHER EXCEPTION RAISED FOR <$...NAME2> - OPEN [151] 


These tests are ruled to have been passed, since they all contain applicable 
checks that indeed were passed. This implementation supports a file system, 
and in cases where an I/O operation is attempted with a name parameter that 
does not identify an external file the exception NAME_ERROR must be raised; 
this implementation accepts all strings as valid file names and so the 
conditions that raise NAME_ERROR are reduced, but when they obtain the 
implementation conforms. 

The AVO ruled that CE2108B, CE2108D, CE2108F, CE2108H, CE3112B, CE3112D (6 
tests) are graded inapplicable by Evaluation Modification. 

The AVO accepts the implementation's behavior, given that a file system 
has been implemented on the bare target that cannot support permanent 
files; these tests may be graded inapplicable by Evaluation Modification 
f the tests report FAILED and the sole Report. Failed messages are 

CE2108B/D; UNEXPECTED EXCEPTION RAISED ON OPENING OF TEXT FILE. 

WHICH SHOULD HAVE BEEN CREATED BY TEST CE2108{A/C}.ADA [77] 

& CE3112B: " ... <as above, but with test name:> CE3112A.ADA [61] 


or if a run-time system error report results from an unhandled NAME_ERROR, 
for tests CE2108F/H & CE3112D. 


C34009D and C34009J were graded passed by Evaluation Modification as 
directed by the AVO. These tests check that 'SIZE for a composite type is 
greater than or equal to the sum of its components' 'SIZE values; but this 


2-5 






IMPLEMENTATION DEPENDENCIES 


issue is addressed by AI-00825, which has not been considered; there is not 
an obvious interpretation. This implementation represents array components 
whose length depends on a discriminant with a default value by implicit 
pointers into the heap space; thus, the 'SIZE of such a record type might 
be less than the sum of its components 'SiZEs, since the size of the heap 
space that is used by the varying-length array components is not counted as 
part of the 'SIZE of the record type. These tests were graded passed given 
that the Report.Result output was "FAILED" and the only Report.Failed 
output was "INCORRECT 'BASE'SIZE", from line 195 of C34009D and line 193 in 
C34009J. 


2-6 






CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical•and sales information about this Ada implementation, contact; 

Joe Kohli 

Irvine Compiler Corporation 
34 Executive Park, Suite 270 
Irvine, California 92714 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 


3-1 





PROCESSING INFORMATION 


For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Applicable Tests 3784 

b) Total Number of Withdrawn Tests 93 

c) Processed Inapplicable Tests 92 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 293 


g) Total Number of Tests for ACVC 1.11 4170 

All I/O tests of the test suite were processed because this implementation 
supports a file system. The above number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the implementation. When this compiler was tested, the tests 
listed in section 2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded onto the host computer using NFS from a remote 
host with a directly connected 9-track tape drive. The communication 
network was Ethernet. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementation. 


The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target computer 
system by the communications link described above, and run. The results 
were captured on the host computer system. 


3-2 






PROCESSING INFORMATION 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B foi a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 

Option I Switch Effect 


-stack_check 

-numeric_check 

-elaboration_check 

-noinfo 

-quiet 

-link=<main program> 
-listing 

-maximum error=0 


-nopreprocess 

-nowarnings 


Enable stack overflow checking 
Enable arithmetic overflow checks 
Enable elaboration checking 
Suppress informationals 
Suppress compiler banners 
Link the provided subprogram 
Generate a compilation listing 
Set maximum number of errors before abort 
(A value of zero specifies that there is no 
maximum error limit.) 

Disable compilation of preprocessor directives 
Suppress warnings 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 






APPENDIX A 
MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in {UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN- also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 254 

$BIG_ID1 (1,.V-1 => 'A', V => '1') 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG_ID3 (1..V/2 => 'A') & '3' & 

(1..V-1-V/2 => 'A') 

$BIG_ID4 (1..V/2 => 'A') & '4' & 

(1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & "298" 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 & (1..V/2 => 'A') & 

$BTG_STRING2 & (1..V-1-V/2 => 'A') & '1' & 

SBLANKS (1..V-20 => ' ’) 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 


A-1 






MACRO PARAMETERS 


$MAX_STRING_LITERAL & (1..V-2 => 'A') & 

The following table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 

$ACC_SIZE 96 

SALIGNMENT 4 

$COUNT_LAST 2147483647 

SDEFAULT_MEM_SIZE 2097152 

$DEFAULT_STOR_UNIT 8 

$DEFAULT_SYS_NAME 180960 

$DELTA_D0C 0.000_000_000_465_661_287_307_739_257_812_5 

SENTRY ADDRESS address of_entryl 

$ENTRY_ADDRESS1 address__of_entry2 

$ENTRY ADDRESS2 address of_entry3 

SFIELD_LAST 2147483647 

SFILE_TERMINATOR ' ' 

$FIXED_NAME NO_SUCH_FIXED_TYPE 

$FL0AT_NAME N0_SUCH_FL0AT_NAME 

$F0RM_STRING "" 

$F0RM_STRING2 "CANNOT_RESTRICT_FILE_CAPACITY" 

$GREATER_THAN_DURATION 

524287.5 

$GREATER_THAN_DURATION_BASE_LAST 

10000000.0 

$GREATER_THAN_FLOAT_BASE_LAST 

1.123558209288946943370739E+307 

SGREATER_THAN_FLOAT_SAFE_LARGE 

1.123558209288946943370739E+307 


A-2 






MACRO PARAMETERS 


$GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

1.0E308 

$HIGH_PRIORITY 255 

$ILLEGAL_EXTERNAL_FILE_NAME1 

/NODIRECTORY/FILENAME 

$ILLEGAL_EXTERNAL_FILE_NAME2 

/NODIRECTORY/THIS-FILE-NAME-IS-ILLEGAL 

$INAPPROPRIATE_LINE_LENGTH 

-1 

SINAPPROPRIATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("a28006dl.tst") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("b28006f1.tst") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

SINTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE C 

SLESS_THAN_DURATI0N -524287.5 

$LESS_THAN_DURATION_BASE_FIRST 

- 10000000.0 

$LINE_TERMINATOR ASCII.LF 

$LOV_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_C0DE_TYPE N0_SUCH TYPE 

$MANTISSA_D0C 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS 1 2147483648 


SMIN INT 


-2147483648 


MACRO PARAMETERS 


$NAME 

TINY_INTEGER 

$NAME_LIST 

180960 

SNAME^SPECIFICATIONl 

./X2120A 

$NAME_^SPECIFICATION2 

./X2102B 

$NAME^SPECIFICATION3 

./X3119A 

$NEG_BASED_INT 

16#FFFFFFFE# 

$NEW_MEM_SIZE 

2097152 

$neu_stor_unit 

8 

$NEW__SYS_NAME 

180960 

$PAGE_TERMINATOR 

ASCII.FF 

$RECORD_DEFINITION 

NEW INTEGER; 

$RECORD_NAME 

NO_SUCH__MACHINE CODE TYPE 

$TASK_SIZE 

32 

STASK_STORAGE_SIZE 

16383 

STICK 

(1.0/4096.0) 

$VARIABLE_ADDRESS 

address__of varl 

$VARIABLE_ADDRESS1 

address of var2 

SVARIABLE_ADDRESS2 

address_^of var3 

$YOUR_PRAGMA 

EXPORT_OBJECT 


A-4 


APPENDIX B 

COMPILATION SYSTEM AND LINKER OPTIONS 


The compiler and linker options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler and linker 
documentation and not to this report. 


B-1 





Apr 7 22:32 1991 


caMpile_*nd_linl(_options.aU Page 1 


Passive ICC Qualifiers 
-arguoents -args 
-display 
-help 

-helpall -all 
-hide 

-ignore cfg -iefg 
-ignore~env -ienv 
-normal” 

-quiet 
-save_pas2 
-save_tempe -save 
-succeed 
-symbols -syms 
-temp 
-tnp«<arg> 

-unique 

-verbose 

Active ICC Qualifiers 
-architecture*<arg» 
-asm 

-asm_flag -asfflf><arg> 
-asm~naRW -asan><arg> 
-c 

-cc_flag -ccf»<arg> 
-ce”naa» -ccn“<arg> 
-coptimize 
-exe 

-execute 


Display all arguaents to the ICC coaiaend 

Display all actions as they are performed 

List commonly used qualifiers 

List all available qualifiers 

Sippress naming ICC sibprocesses (VMS only) 

Igmre configuration file qualifiers 

Ignore anvironaent variable qualifiers 

Compile with 'normal' messages 

Compile quietly 

Save all intermediate files 

Save temporary files generated by pae2 

Always return the success status 

Show current value of ICC coamiand's symbols 

Use temporary directory for intermediate files 

Use <arg> as the temporary director 

Use unique file names for intermediate files 

Compile with verbose messages 

Specify i80960 architecture KA.KB,NC,CA,MM,MX 

Stop at the generated assembly file 

Explicitly add flag(s) for the assembler 

Use <arg> as the assembler 

Stop at the generated C source file 

Explicitly add flag(s) for the C compiler 

Use <srg> as the C compiler 

Invoke the C optimizer 

Link a non-Ada program 

Execute and delete executable after linking 


-execute_flag -execfz<arg> Explicitly add flag(s) for the executable 


-8da_ext*<arg> 

-asm” ext><arg> 
-c_ext*<arg» 

-exe ext*<arg» 

-int”ext»<arg> 

-lib”ext=<arg> 
-nir 5 ~ext=<arg> 
-obj”ext=<arg> 
-opt“ext»<arg> 
-pas”ext=<arg» 

- int” 

-keep tempss<arg> 
-libriry -lib«<arg> 


Set Ads file extension 

Set assembly file extension 

Set C file extension 

Set executable file extension 

Set I FORM file extension 

Set object archive/library file extension 

Set list mer^e file extension 

Set object file extension 

Set optimized IFORM file extension 

Set Pascal file extension 

Stop at the generated iform file 

Save file(s) with extension(s) in <arg> 

Set the compilation library directory 


-loader_name -loader«<arg> Use <arg> as the loader 
- loaderjjref lag -loac^rerxargx 

Explicitly add pre-flagls) for loader 
•loader_postflag -loadp6tfs<arg> 

Explicitly add post-flag(s) for loader 
-map><arg> Generate a link map file (ICC linker only) 

-merge Invoke the ICC list merger 

'mr^ Stop at the generated list merge file 

•obj . Stop at the generated object file (default] 

-objIib»<arg> Install the object file in library <arg> 

-objlib_flsg -objlibf«<arg> Explicitly add flag<s) for object librarian 
-objlib_name -objlibn»<arg> Use <arg> as the object librarian 
*ont Stop at the optimizer iform file 

-optimize -opt Invoke the Ada optimizer 

-prelooder»<arg> Execute <arg> before linking 

-preloader_flag -preloadf><srg> 

Explicitly add flsg(s) for preloader 
-po8tloaders<arg> Execute <arg> after linking 

-postloader_flag ■p6tloadf«<arg> 

” Explicitly add flag(s) for postloader 

-ranlib_name -ranlibn«<arg> Use <arg> as the ranlib library processor 
-release*<arg> Set the release directory 

-show_only Display all actions to be performed 

-system«<arg> Set the system library directory 

-tool_version»<arg> Specify the ICC toolset version 


-t 00 I_version»<arg> 

Ada Qualifiers 

- infonaation 
-checks 

-compatible calls 
-cross reference -xref 
-deelare*<arg> 

-debugger 

-elaboration_check -elab. 

-exception_info 

- inforsiation 

- listing 

-maxiisjii errors><arg> 

-preprociss 

-rate 

-st8ck_check 
•syntax only 
-trim 

-warnings -w 
-wrap 


ICC toolset version 


Enable informational warnings (default] 
Enable all runtime checks (default] 

Generate calls compatible with C calls 
Generate cross-reference file (.xrf) 

Declare an identifier 
Compile for the Ada sysbolic debugger 
check 

Generate ELABORATION checking 
Enable extra EXCEPTION information (default] 
Enable informational warnings (default] 
Generate list file (.1st) 

Set aaxiaaja nLinber of errors reported 
Generate coninented preprocess file (.app) 
Rate code efficiency 
Generate stack checking code 
Syntax check only 

Generate triamed preprocess file (.app) 
Enable warnings 

Enable auto-wrapping error messages (default] 





Apr 7 22:32 1991 l80960.c^/coi^U«_«nd_link_optior».iU P»9« 2 


-lero 


Zero atl records Cdefaolt] 


ICC Code Generator Oualifi 
•bra.ch relative 
-const 7n code 
-hostdefaugger -cfcx -cdb - 
-extended listing -exl 
- leaf procedures 
-gprotile 
-loc info 
-fraiSe size 
-naises” 

-ntineric check -nuachk 
-probe sTack 
-profile 
-real 
-static 


ers 

Use relative branches (8S0 only) 

Place constant aggregates in CODE segaent 
xdbCenerate host debugger inforaation 
Generate extended code listing output 
Generate LEAF procs when possible (180960 only) 
Generate runtiae 'gprof' profiling 
Generate extended local infonaation 
Generate fraaw size for each subp (180960 only) 
Generate naaelist file (.n) 

Generate overflow detection code 
Generate stack probes 
Generate rirtiae profiling 
Lise real nasws 

Static aode (C code generator only) 


ICC Prelinker Qualifiers 
-coeplink -cl»<arg» 
-force link 
-heap_size*«arQ> 
-link“-l«<arg> 

-output -o*»arg> 
-stack_size -stack»<arg> 
-trap ~ 


Ada compile and link <arg> into one file 
Force link, even if dependency errors 
Allocate <arg> bytes of heap (i80960 only) 

Ada link compilation uiit <arg> 

Use <arg> as the executable file name 
Allocate <arg> bytes of user stack (180960 only) 
Establish nuaeric fault trap handler 




APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 


package STANDARD is 

type INTEGER is range -2147483648 .. 2147483647; 
type FLOAT is digits 15 

range -1. i2355820928895E+307 .. -1.12355820928895E4.307; 

type DURATION is delta 2.0**(-12) 
range -524287.0 .. 524287.0; 

type SH0RT_INTEGER is range -32768 .. 32767; 

type SH0RT_FL0AT is digits 6 

range -2.12676E437 .. 2.12676E437; 

type TINY_INTEGER is range -128 ..127; 
end STANDARD; 


C-1 










Appendix F 
ICC Ada Version 7.0 
VAX / VMS to Intel i80960MC / Bare 


Irvine Compiler Corporation 
34 Executive Park, Suite 270 
Irvine, CA 92714 
(714) 250-1366 

April 23, 1991 


1 ICC Ada Implementation 

The Ada language definition leaves implementation of certain features to 

the language implementor. This appendix describes the implementation- 

dependent characteristics of ICC Ada. 

2 Pragmas 

The following predefined pragmas are implemented in ICC Ada as described 

by the Ada Reference Manual: 

Elaborate This pragma allows the user to modify the elaboration order of 
compilation k;r.its. 

Inline Subprogram inlining is implemented. Inline substitutions are per¬ 
formed by uie ICC optimizer. This pragma is not supported for generic 
subprograms or subprograms which contain nested subprograms. 

List This pragma enables or disables writing to the output list file. 

Pack Packing on arrays and records is implemented to the bit level. Slices 
of packed arrays are not implemented, except boolean arrays. 


1 







2 


Page This pragma ejects a new page in the output list file (if enabled). 

Priority This pragma sets the priority of a task or main program. The 
range of the subtype priority is 0..255. 

The following predefined pragmas have been extended by ICC; 

Interface This pragma is allowed to designate variables in addition to sub¬ 
programs. It is also allowed to have an optional third parameter which 
is a string designating the name for the linker to use to reference the 
variable or subprogram. The third parameter has the same effect as 
pragma Interface, name. 

Suppress In addition to suppressing the standard checks, ICC also permits 
suppressing the following: 

Exception- info Suppressing Exception, info improves run-time per¬ 
formance by reducing the amount of information maintained for 
messages that appear when exceptions are propagated out of the 
main program or any task. 

All. checks Suppressing AIL checks suppresses all the standard 
checks as well as Exception, info. 

The following predefined pragmas are currently not implemented by ICC; 

Controlled Memory.size Optimize 

Shared Storage, unit System.name 

The following additional pragmas have been defined by ICC: (For further 

details on these pragmas refer to the ICC Ada User’s Reference Guide.) 

Compatible-calls This pragma is used to specify that pass-by-reference 
parameter passing should be used for OUT and IN OUT scalar param¬ 
eters. By default some of the ICC code generators use copy-in/copy- 
back for scalar OUT and IN OUT parameters. This pragma allows pass- 
by-reference calls to be performed (primarily for downward compati¬ 
bility). 

Compress This pragma reduces the storage required for discrete subtypes 
in structures (arrays and records). Its single argument is the name 






3 


of a discrete subtype. It specifies that the subtype should be repre¬ 
sented as compactly as possible (regardless of the representation of the 
subtype’s base type) when the subtype is used in a structured type. 
The storage requirement for variables and parameters is not affected. 
Pragma Compress must appear prior to any reference to the named 
subtype. 

Export This pragma is a complement to the predefined pragma Inter¬ 
face. It enables subprograms written in Ada to be called from other 
languages. It takes 2 or 3 arguments. The first is the language to be 
called from, the second is the subprogram name, and the third is an 
optional string designating the actual subprogram name to be used 
by the linker. Pragma Export must appear prior to the body of the 
designated subprogram. 

External- name This pragma is equivalent to the ICC pragma Export 
with an implicit language type of “Ada” and a required external name. 
This pragma allows the user to specify the exact name of the subpro¬ 
gram that will be used in the generated object file. This pragma is 
provided for compatibility with existing Ada source files. 

Foreign This pragma is used to add an object file or an object library file 
to the link command line used when linking the current compilation 
unit. Pragma Foreign is most frequently used in conjunction with 
pragma Interface so that foreign object files may be automatically 
included when the Ada compilation unit is linked. This pragma ac¬ 
cepts two parameters. The first parameter indicates the location of 
the foreign object name on the link command line. It must be either 
Normal or Post. The second parameter is a string denoting the foreign 
object. This string is passed unmodified to the linker, so it should be 
a complete filename. If the location is Normal, then the foreign object 
is included immediately after the current Ada compilation unit on the 
link command line. If the location is Post, then the foreign object 
name is included at the end of the link command line. When multiple 
Foreign Post pragmas are used in a single program, the order of the 
foreign objects on the link command line is not defined. 

Interface.Name This pragma takes a variable or subprogram name and 
a string to be used by the linker to reference the variable or subpro¬ 
gram. It has the same effect as the optional third parameter to pragma 




4 


Interface. 

Interrupt-handler This pragma is used when writing procedures that will 
be invoked as interrupt handlers (independent of the tasking runtime). 
It does not have any parameters and must appear immediately within 
the declarative part of a procedure. The presence of this pragma causes 
the code generator to produce additional code on procedure entrance 
and exit which preserves the values of all global registers. This pragma 
has no other effect. This pragma is not implemented for all targets. 

No-zero The single parameter to No-zero is the name of a record type. 
If the named ’•ecord type has holes (or gaps) between fields that are 
normally initialized with zeroes, this pragma will suppress the clearing 
of the holes. If the named record type has no holes this pragma has 
no effect. When zeroing is disabled, comparisons (equality and non¬ 
equality) of the named type are disallowed. The use of this pragma 
can significantly reduce initialization time for record objects. The 
ICC Command Interpreter also has the qualifier NO-ZERO which has 
the effect of implicitly applying pragma No- zero to all record types 
declared in the file. 

Put, Put-line These pragmas take any number of arguments and write 
their value to standard output at compile time when encountered 
by the compiler. The arguments may be expressions of any string, 
enumeration, or integer type, whose value is known at compile time. 
Pragma Put-line adds a carriage return after printing all of its argu¬ 
ments. These pragmas are often useful in conjunction with conditional 
compilation. They may appear anywhere a pragma is allowed. 

Static-elaboration This pragma is used immediately within a package 
specification to state that all elaboration for the package is intended 
to be static. A warrdng will be generated for all objects within the 
package specification or corresponding body which require dynamic 
elaboration. 

Unsigned-Literal This pragma, when applied to a 32-bit signed integer 
type, affects the interpretation of literals for the type. Literals be¬ 
tween 2**31 and 2**32 are accepted for the type and are represented 
as if the type were unsigned. Operations on the type are unaffected. 
Note that (with checking suppressed), signed addition, subtraction, 






5 


and multiplication are equivalent to the corresponding unsigned op¬ 
erations. However, division and relational operators are different and 
should be used with caution. This pragma is used for type Address 
in package System. 

Uselib This pragma is used within a context clause to explicitly add a list 
of named searched libraries to the library search list of the current 
compilation. The specified libraries are searched first in all following 
WITH clauses. 


3 Preprocessor Directives 

lCC..4da incorporates an integrated preprocessor whose directives begin 
with the keyword Pragma. They are as follows: 

Abort This pragma causes the current compilation to be immediately 
halted. It is useful when unexpected circumstances arise inside condi¬ 
tionally compiled code. 

If, Elsif, Else, End These preprocessor directives provide a conditional 
compilation mechanism. The directives If and Elsif take a boolean 
static expression as their single argument. If the expression evaluates 
to False then all text up to the next End, Elsif or Else directive is 
ignored. Otherwise, the text is compiled normally. The usage of these 
directives is identical to that of the similar Ada constructs. These di¬ 
rectives may appear anywhere pragmas are allowed and can be nested 
to any depth. 

Include This preprocessor directive provides a compile-time source file in¬ 
clusion mechanism. It is integrated with the library management sys¬ 
tem, and the automatic recompilation facilities. 

The results of the preprocessor pass, with the preprocessor directives 
deleted and the appropriate source code included, may be output to a file at 
compile-time. The preprocessor may be disabled by using the NOPREPROCESS 
command-line qualifier, in which case the above directives are ignored. 

4 Attributes 

ICC Ada implements all of the predefined attributes, including the Repre¬ 
sentation Attributes described in section 13.7 of the Ada RM. 






6 


Limitations of the predefined attributes are: 

Address This attribute cannot be used with a statement label or a task 
entry. 


The implementation defined attributes for ICC Ada are: 

Linear- address This attribute is currently identical to the predefined at¬ 
tribute Address. In the future it will return the 32-bit linear address 
for 80960 targets and Address will return a full 64-bit virtual address. 

Version, System, Target, CG.mode These attributes are used by ICC 
for conditional compilation. The prefix must be a discrete type. The 
values returned vary depending on the target architecture and oper¬ 
ating system. 


5 Input/Output Facilities 


5.1 

Standard Input and Output for embedded targets is implemented through 
the serial communications link between the host and embedded system. The 
normal PUT and GET TEXT-10 calls can be used for console-I/0. 

Since embedded systems typically do uot have access to disk storage, file 
I/O operations are simulated through a RAM-based virtual file system im¬ 
plemented by a low-level runtime support package. This virtual file system 
behaves like a disk-based file system, except that files do not persist between 
program executions. Therefore, it is not possible to write a virtual file with 
one program and it read it using another one. Also, the virtual file system 
never raises the exception NAME-ERROR since all file names are considered 
legal. 

The implementation dependent specifications from TEXT-10 and DI¬ 
RECT-10 are: 

typa COUNT is rangs 0 .. IITEGER'UST; 

subtyps FIELD is INTEGER rangs 0 .. INTEGER'LAST; 







7 


5.2 FORM Parameter 

ICC Ada implements the FORM parameter to the procedures OPEN and 
CREATE in DIRECT.IO, SEQUENTIAL-10, and TEXT-10 to perform 
a variety of ancillary functions. The FORM parameter is a string literal 
containing parameters in the style of named parameter notation. In general 
the FORM parameter has the following format: 

^fieldi => value\ [, fieldn => valuCn ]” 
where fieldi => ra/ue, can be 


OPTION 

=> 

NORMAL 

OPTION 

=> 

APPEND 

PAGE-MARKERS 

=> 

TRUE 

PAGE-MARKERS 

=> 

FALSE 

READ.INCOMPLETE 

=> 

TRUE 

READ.INCOMPLETE 

=> 

FALSE 

MASK 

=> 

<9 character protection mask> 


Each field is separated from its value with a “=>” and each field/value 
pair is separated by a comma. Spaces may be added anywhere between 
tokens and upper-case/lower-case is insignificant. For example: 

craateC 1, out.fila, "list.data", 

"option »> append, PAGE.KARXEIIS => FALSE, Mask => mxnz-"); 

The interpretation of the fields and their values is presented below. 

OPTION Files may be opened for appendage. This causes data to be 
appended directly onto the end of an existing file. The default is 
NORMAL which overwrites existing data. This field applies to OPEN in 
all three standard I/O packages. It has no effect if applied to procedure 
CREATE. 

PAGE-MARKERS If FALSE then all TEXT-IO routines dealing with page 
terminators are disabled. They can be called, however they will not 
have any effect. In addition the page terminator character (“L) is al¬ 
lowed to be read with GET and GET-LINE. The default is TRUE which 
leaves page terminators active. Disabling page terminators is particu¬ 
larly useful when using TEXT-IO with an interactive device. For out¬ 
put files, disabling page terminators will suppress the page terminator 
character that is normally written at the end of the file. 






8 


READ-INCOMPLETE This field applies only to DIRECT-10 and SEQUENTIAL. 10 
and dictates what will be done with reads of incomplete records. Nor¬ 
mally, if a READ is attempted and there is not enough data in the file 
for a complete record, then END-ERROR or DiTA-ERROR will be raised. 

By setting READ-INCOMPLETE to TRUE, an incomplete record will be 
read successfully and the remaining bytes in the record will be ze¬ 
roed. Attempting a read after the last incomplete record will raise 
END-ERROR. The SIZE function will reflect the fact that there is one 
more record when the last record is incomplete and READ-INCOMPLETE 
is TRUE. 

MASK Set a protection mask to control access to a file. The mask is a 
standard nine character string notation used by Unix. The letters 
cannot be rearranged or deleted so that the string is always exactly 
nine characters long. This applies to CREATE in all three standard 
I/O packages. The default is determined at runtime by the user’s 
environment settings. 

The letters in the Mask are used to define the Read, Write and 
execute permissions for the User, Group and World respectively. Wher¬ 
ever the appropriate letter exists, the corresponding privilege is granted. 

If a is used instead, then that privilege is denied. For example if 

Mask were set to "rw-rs-" then read and write privilege is granted 

to the file owner and his/her group, but no world rights are given. 

If a syntax error is encountered within the FORM parameter then the 
exception USE-ERROR is raised at the OPEN or CREATE call. Also, the stan¬ 
dard function TEXT-10.FORM returns the current setting of the form fields, 
including default values, as a single string. 

6 Package SYSTEM 

Package SYSTEM is defined as; 
package SYSTEM is 

type NAME is (180960); 

— Language Defined Constants 


SYSTEN-IAME : constant NAME := 180960; 





9 


STaRAGE.UIIT : constant 8; 

MEMQRY.SIZE : constant := 2*(2**20); 

; constant :® -2**31; 

NAZ.IIT : constant := 2*s31-l; 

MAZ.DIGITS : constant := 16; 

NAZ.NAITISSA : constant := 31; 

FIIE.DELTA ; constant := 2.0**(-31); 

TICK : constant 1.0/4096.0; 

typs ADDRESS is rangs NIl.IIT .. NAZ.IIT; — Signsd 32-bit range, 

subtype PRIORITY is IITEGER range 0 .. 25S; 

— Constants lor the STIHEAP package 

BITS.PER.BNU : constant := 8; — Bits per basic machine unit 

MAZ.ALIGIMEIT : constant := 4; — Maximum alignment required. 

MII.NEM.BLQCX : constant ;= 1024; — Minimum chunk request size. 

— Constants lor the HOST package 

HOST.CLOCK.RESOLUTIOI : constant 128; — 128 microseconds 

BASE.DATE.CORRECTIOI : constant 25.202; -- Unix base date is 1/1/1970. 

pragma UISIGIED.LITERAL (ADDRESS); -- Allow unsigned literals. 

lULL.ADDRESS : constant ADDRESS 0; — Value ol type ADDRESS 

— equal to HULL. 

pragma PUT.LIIE ("Target: ", SYSTEM.IANE); 
end SYSTEM; 


7 Limits 

Most data structures held within the ICC Ada compiler are dynamically 
allocated, and hence have no inherent limit (other than available memory). 
Some limitations are: 

The maximum input line length is 254 characters. 


The maximum number of tasks abortable by a single abort statement is 
64. 




10 


Include files can be nested to a depth of 3. 

The number of packages, subprograms, tasks, variables, aggregates, types 
or labels which can appear in a compilation unit is unlimited. 

The number of compilation units which can appear in one file is unlimited. 

The number of statements per subprogram or block is unlimited. 

Packages, tasks, subprograms and blocks can be nested to any depth. 

There is no maximum number of compilation units per library, nor any 
maximum number of libraries per library system. 


8 Numeric Types 

ICC Ada supports three predefined integer types: 

TINY.INTEGER -128..127 8 bits 

SHORT.INTEGER -32768..32767 16 bits 

INTEGER _ -2147483648..2147483647 32 bits 

In addition, unsigned 8-bit, 16-bit and 32-bit integer types can be defined 
by the user via the SIZE length clause. Storage requirements for types can 
be reduced by using pragma Pack and record representation clauses and for 
subtypes by using the ICC pragma Compress. 

Type float is available. 


Attribute 

FLOAT value 

size 

64 bits 

digits 

15 

first 

-1.12355820928895f; -t- 307 

last 

-I-1.12355820928895F -1- 307 


Type short-float is available. 


Attribute 

SHORT-FLOAT value 

size 

32 bits 

digits 

6 

first 

-2.12676f; -i- 37 

last 

-I-2.12676F-t-37 










11 


Fixed point types automatically assume the smallest storage size necessary 
to represent all of the model numbers with the indicated delta and range. 
The size of a fixed point type may be changed via the SMALL representation 
clause and the SIZE length clause. Unsigned fixed point types may be 
defined using the SIZE length clause. 

ICC Ada rounds real (fixed and floating point) values away from zero at 
the mid-point between integral values (i.e. 1.5 rounds to 2.0 and -3.5 rounds 
to -4.0). 


9 Tasks 

The type DURATION is defined with the following characteristics: 


Attribute 

DURATION value 

delta 

2.44140625i; - 04 sec 

small 

2.44140625£; - 04 sec 

first 

-524287.0 sec 

last 

524287.0 sec 


The subtype SYSTEM.PRIORITY as defined provides the following range: 


Attribute 

PRIORITY value 

first 

0 

last 

255 


Higher numbers correspond to higher priorities. If no priority is specified 
for a task, PRIORITY’FIRST is assigned during task creation. 

10 Representation Clauses 

10.1 Type Representation Clauses 

10.1.1 Length Clauses 

The amount of storage to be associated with an entity is specified by means 
of a length clause. The following is a list of length clauses and their imple¬ 
mentation status: 

• The SIZE length clause is implemented. When applied to integer range 
types this length clause can be used to reduce storage requirements 










12 


including storage as unsigned values. It may be used to declare an 
unsigned 32-bit type. Length clauses are allowed for float and fixed 
point types, however the storage requirements for these types cannot 
be reduced below the smallest applicable predeflned type available. 

• The STORAGE-SIZE length clause for task types is implemented. 
The size specified is used to allocate both the task’s Task Information 
Block (TIB) and its stack. 

• The STORAGE-SIZE length clause for access types is implemented. 
When a length clause is encountered for an access type, a block of 
memory is reserved in the user’s heap space. This block of memory 
cannot be expanded beyond the bounds specified in the length cla e. 
When the memory in this block is exhausted, STORAGE-ERROR is rai' 
Due to heap management overhead, the full amount of memory indi¬ 
cated in the length clause may not be available for allocation. 

• The SMALL length clause for fixed point types is implemented for 
powers of two. ICC Ada does not support SMALL values that are not 
integral powers of two. 

10.1.2 Enumeration Representation Clauses 

Enumeration representation clauses are implemented. The use of e” 'mera- 
tion representation clauses can greatly increase the overhead associated with 
their reference. In particular, FOR loops on such enumerations are very ex¬ 
pensive. Representation clauses which define the default representation (i.e. 
The first element is ordinal 0, the second 1, the third 2, etc.) are detected 
and cause no additional overhead. 

10.1.3 Record Representation Clauses 

Record representation clauses are implemented to the bit-level. Records con¬ 
taining discriminants and dynamic arrays may not be organized as expected 
because of unexpected changes of representation. There are no implemen¬ 
tation generated names that can be used in record representation clauses. 

Record representation clauses allow more precise packing than pragma 
Pack. Record representation clauses allow the user to specify the exact 
location of fields within a record to the bit-level. The ICC Ada compiler 
implements bit-level record representation clauses including nested records 





13 


starting on bit-boundaries. Since the user specifies the exaci bit location, 
overhead for extracts and stores may be very high, so record representation 
clauses should be applied very carefully. Record representation clauses are 
implemented using the following rules: 

• Fields of records may be allocated to the nearest bit for elements wh'ch 
are smaller than 32-bits. This includes small nested records. Elements 
32-bits or larger (and all arrays) must be placed on by;^ L' 'undaries. 

• If the specified storage space for an element is not adequate using its 
default allocation, it will automatically be packed in two stages: (1) 
Normal packing will be attempted using the default alignment rules. If 
this does not adequately reduce storage then (2) bit-level packing will 
be attempted with all fields aligned on 8-bit or smaller boundaries. If 
this bit-level packing still does noi meet the storage requirement, an 
error message will be generated. 

• The optional alignment clause may h- used to specify an alignment 
up to 8 bytes. 

• All fields of a record representation clause which are left unspecified 
will be allocated at the end of the record using the default alignment 
rules for each element. 

• The fields of a record representation clause may be specified in any 
order and the storage order of the fields does not need to be the same 
as the order in which they were declared. 

• If no alignment clause is specified, the alignment requirement for the 
record is equivalent to the largest alignment requirement of its ele¬ 
ments. 

10.2 Address Clauses 

Address clauses are implemented for variables. Address clauses for local 
variables using dynamic values are implemented. The use of a dynamic ad¬ 
dress can facilitate overlaying since the address specified may be the value of 
a variable of type System. Address or may be the result of an expression us¬ 
ing the predefined Address attribute. Address ''lauses are not implemented 
for subprograms, packages, tasks, constant objects, or statement !,ibels. 








14 


11 Interface to Other Languages 

Pragma Interface allows Ada programs to interface with (i.e., call) subpro¬ 
grams written in another language (e.g., assembly, C), and pragma Export 
allows programs written in another language to interface with programs writ¬ 
ten in Ada. The accepted languages are: Intrinsic, Ada, C and Assembly. 
The aliases Assembler and ASM cam also be used instead of Assembly. The 
language Intrinsic should be used with came—it is used by ICC for inter¬ 
nally handled operators. 


12 Unchecked Type Conversion 

The generic function Unchecked-conversion is implemented. In general, 
unchecked-conversion can be used when the underlying representations of 
vadues are similar. 

Acceptable conversions are: 

• Conversion of scalars. Unchecked-conversion can be used to change 
the type of scalar values without restriction. In most circumstances 
the unchecked conversion produces no additional code. 

• Conversion of static constrained structures. Constrained static arrays 
and records are represented ais contiguous areas of memory, and hence 
can be converted using unchecked-conversion. 

• Conversion of scalars to str.ic constrained structures. Scalar objects 
may be converted to static constrained structures vrith no additional 
overhead. If a scalar value is converted to a structure, an aggregate 
is first built to hold the scalar value and its add.ess is used as the 
address of the resulting structure. 

Because the representation of dynamic structures uses implicit pointers and 
dope-vectors, ICC Ada does not allow unchecked conversions to or from 
dynamic or unconstrained structures (arrays or records). A compile-time 
error message will be generated for such instantiations. 

Although the Ada compiler does not produce errors for the following 
unchecked conversions, they should be avoided since their results are not 
obvious: 





15 


• Conversion from constrained discriminant records. Conversion from 
discriminant records can cause unpredictable behavior because of un¬ 
derlying representation changes. The unchecked-conversion will use 
the same rules as described above for performing the copy, however 
the results of this operation may not be what the user desires, since 
ICC Ada does not place arrays constrained by the discriminant in-line 
with the other fields in a discriminant record. In place of the array 
only a pointer is used and the array is allocated dynamically from the 
internally maintained heap. 

• Conversion to or from pointers to unconstrained arrays. Unconstrained 
array pointers are implemented as special dope-vectors in ICC Ada. 
Conversions to or from these dope-vectors are not recommended. 

• Conversion to or from any type or object declared in a generic. Gener¬ 
ics can cause hidden representation changes. Unchecked,conversions 
of any object or type declared in a generic should be avoided. 

ICC Ada does not require that the sizes of the parameters to an 
unchecked-conversion be identical. The size of the target type is used to 
determine the number of bytes to copy. The size of the target type (in 
bytes) is determined by the Ada front end and exactly that many bytes are 
copied from the source address to the target address. This can cause prob¬ 
lems (e.g. memory faults) when the source object is smaller than the target 
object. For example, using unchecked-conversion to convert a character into 
an integer will cause 4 bytes to be copied starting from the address of the 
character. The first byte copied will be the value of the character, but the 
values of the remaining three bytes cannot be predicted since they depend 
on values of variables or fields immediately after the character in memory. 
If the source object is larger than the target object then only the bytes that 
will fit in the target object are copied from the source starting at the address 
of the first byte of the source. 

13 Unchecked Storage Deallocation 

Unchecked-deallocation is implemented. Unchecked-deallocation of 
structures containing dynamic elements (such as discriminant records with 
dynamic arrays) should not be performed since these nested structures are 
not automatically deallocated. 







