REPORT DOCUMENTATION PAGE 


Form Approved 
OPM No. 0704 0188 


AD-A265 015 


1 hour p«f rftSfxytw. tnckxJ.ng ff* bm# fof reviewing tn*injci©n*. m/€*■>»% •*»bng data tovtcm gathering and ma*nu.-n*ng vm <J*u 
ing iMe burden eciimafe or any other aspect of m* coHecion of rtormaibn. including euggesione lor reducing th* bunje*^ to Wa&hr>gion 
1215 Jetlerion Bav* Hqfmay. Suit 1204. Arington. VA 22202-4302, and to tm 0»l»ce of intonnjoon and Regulatory Aftan Oflce o< 


REPORT DATE 


3 REPORT TVPE AND DATES COVERED 

Final: 25 Jan 93 


4 TITLE AND SUBTITLE 

Validation Summary Report: Alsys, A!syCOMP_068 Version 1.83, Control Data 4680 
under EP/IX 1.4.3 (host & target), 93012511.11310 


6 AUTHOR(S) 

IABG-AVF 

Ottobrunn, Federal Republic of Germany 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESSES) 

IABG-AVF, Industrieanlagen-Betriebsgeselschaft 
Dept. SZT/ Einsteinstrasse 20 
D-8012 Ottobrunn 

FEDERAL REPUBLIC OF GERMANY 


9 SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 


11 SUPPLEMENTARY NOTES 


12a DISTRIBUTION/AVAILABILITY STATEMENT 


| 5 FUNDING NUMBERS 


8 PERFORMING ORGANIZATION 
REPORT NUMBER 

IABG-VSR 109 


10 SPONSORING/MONITORING AGENCY 
REPORT NUMBER 


Approved for public release: distribution unlimited. 


13. ABSTRACT (Maximum 200 words) 

Alsys, AlsyCOMP_068 Version 1.83, Control Data 4680 (under EP/IX 1.4.3) (host & target), ACVC 1.11 





93-11634 

9 Mil mu !!■■>..... .— • 



14. SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


18. SECURITY CLASSIFICATION 


UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACi 

UNCLASSIFIED 


15. NUMBER OF PAGES 


16 PRICE CODE 


20. LIMITATION OF ABSTRACT 


NSN 7540 01-280-550 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std 239-128 

















THIS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FURNISHED TO DTIC CONTAINED 
A SIGNIFICANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 







AVF Control Number: IABG-VSR 109 
26 January 1593 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: 93012511.11310 
Alsys 

AlsyCOMP__068 Version 1.83 
Control Data 4680 under EP/IX 1.4.3 
Host and Target 



Prepared By: 
IABG mbH, Abt. ITE 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 






Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on January 25, 1993. 


Compiler Name and Version: 
Host Computer System: 
Target Computer System: 


AlsyCOMP_068 Version 1.83 
Control Data 4680 under EP/IX 1.4.3 
Same as Host 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort, Validation Certificate 
#93012511.11310 is awarded to Alsys. This certificate expires 24 months 
after ANSI approval of ANSI/MIL-STD 1815B. 

This report has been reviewed and is approved. 


, L LfTZJJ - 

IABG, Abt. ITE 
Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 



Ada Validation Organization 

Dir£ctq x) Computer & Software Engineering Division 
Institurs^V:or Defense Analyses 
Alexandria VA 22311 


^-Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 




DECLARATION OF CONFORMANCE 


Customer: Alsys GmbH &c Co. KG, Germany 

Certificate Awardee: Alsys 

Ada Validation Facility: IA3G muH, Germany 

ACVC Version: 1.11 

Ada Implementation: 

Compiler: AlsyCOMP_Q68, Version 1.83 

Host: Control Data 4680 

Operating System: EP/Di 1.4.3 

Target: Same as host 

Declaration: 

I, .the undersigned, declare that I have no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MIL-STD-1815A ISO 8652-1987 in the implementation 
listed above. 



Rainer Kollner 


General Manager 
Alsys GmbH <fe Co. KG 



Date 





TABLE OF CONTENTS 

CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 














CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro92] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro92]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the ’’Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 




INTRODUCTION 


1.2 REFERENCES 

[AdaS3] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1387. 

[Pro92] Ada Compiler Validation Procedures . Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User's Guide . 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The AC/C 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK_FILE are used for this purpose. The package REPORT 
also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FIL£ is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values -- for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 



INTRODUCTION 


For each Ada implementation, a customized test suite is produced by the 
AVF. ' This customization consists of making the modifications described 
in the preceding paragraph, removing withdrawn tests {see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations, 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
■ (AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 






INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services {of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial 
or complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro92]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 




CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is August 02, 1931. 


E2S005C 

B28006C 

C32203A 

C34006D 

css^osi 

C35508J 

C35508M 

C35508N 

C35702A 

C357C2B 

B4I308B 

C43Q04A 

C4S114A 

C45346A 

C45612A 

C45S12B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B830223 

B83022H 

B83025B 

BS3025D 

383C2CD 

/-» O ^ 

SUS* 

r* o -> n a -* ■* 

B8S001L 

C86001F 

C94021A 

C97116A 

C93003B 

BA2C11A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD231SC 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE311SA 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3S07C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 


2.2 

INAPPLICABLE 

TESTS 





A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 





The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L. 

. Y 

(14 

tests) (*) 

C3S705L. 

. Y 

(14 

tests 

C35706L. 

. Y 

\ -L x 

tests) 

C35707L. 

. Y 

(14 

tests 

C3S708L. 

. Y 

v 14 

tests) 

C35802L. 

. Z 

(15 

tests 

C45243L. 

. i 

(14 

tests) 

C45321L. 

.Y 

(14 

tests 

C45421L. 

. Y 

(14 

tests) 

C45521L. 

. Z 

(15 

tests 

("4 5 524L . 

• Z 

(15 

tests) 

C45621L. 

.2 

(IS 

tests 

C45641L. 

. Y 

(14 

tests) 

C46012L . 

. Z 

(15 

tests 


{*) C24113W..Y (3 tests) contain lines of length greater than 255 
characters which are not supported by this implementation. 


The following 20 tests check for the predefined type LONG_INTEGERfor 
this implementation, there is no such type: 


C35404C 

C45502C 

C4S613C 

C55B07A 


C45231C 

C45503C 

C4SS14C 

S55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C860C6C 


C4S412C 

C45S11C 

BS2C04D 

CD7101F 


C35713B, C45423B, B86001T, and C86006H check for the predefined type 

SH0RT_FL0AT; for this implementation there is no such type. 


C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLOAT, or SHCRT_FLGAT; for this 
implementation, there is no such type. 


C414C1A checks that CONSTRAINT_ERP.OR is raised upon the evaluation of 
various attribute prefixes; this implementation derives one attribute 
values from the subtype of the prefix at compilation time, and thus 
does not evaluate the prefix or raise the exception, (See Section 2.3. 


C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLCWS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base 
type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

386001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this implementation, there is no such type. 


C96005B uses values of type DURATION's base type that are outside the 
range of type DURATION; for this implementation, the ranges are the 
same. 


CDI009C checks whether a length clause can specify a non-default size 
for a floating-point type; this implementation does not support such 
sizes. 


2-2 





IMPLEMENTATION DEPENDENCIES 


CD2A34A, CD2AS4E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this implementation 
does not support such sizes. 

CD2B15B checks that ST0RAGE_ERR0R is raised when the storage size 
specified for a collection is too small to hold a single value of the 
designated type; this implementation allocates more space chan was 
specified by the length clause, as allowed by AI-00558. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this implementation provides no package MACHINE_CODE. 

The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given 
combination of mode and access method; this implementation supports 
these operations. 


Test 

File Oper 

ation Mode 

File Access Method 

CE2102D 


CREATE 

IN_FILE 

SEQUENTIAL 10 

CE2102E 


CREATE 

OUT_FILE 

SEQUENTIAL 10 

CE2102F 


CREATE 

INCUT FILE 

DIRECT 10 

C52102I 


CREATE 

IN_FILE 

DIRECT 10 

CE2102J 


CREATE 

OUT FILE 

DIRECT 10 

CE2102N 


OPEN 

IN_FILE 

SEQUENTIAL 10 

CE21020 


RESET 

IN_FILE 

SEQUENTIAL 10 

CE2102F 


OPEN 

OUT_FILE 

SEQUENTIAL 10 

CE2102Q 


RESET 

OUT_FILE 

SEQUENTIAL 10 

CE2102R 


OPEN 

INOUT_FILE 

DIRECT_I0 

CE21 G2S 


1 

IIvOUT FILE 

DIRECT 10 

CE2102T 


OPEN 

IN_FILE 

DIRECT 10 

CE2102U 


RESET 

IN FILE 

DIRECT 10 

CE2102V 


OPEN 

OUT__FILE 

DIRECT 10 

CE2102W 


RESET 

OUT_FIL£ 

DIRECT 10 

CE3102E 


CREATE 

IN FILE 

TEXT 10 

CE3102F 


RESET 

Any Mode 

TEXT 10 

CE3102G 


DELETE 


TEXT 10 

CE3102I 


CREATE 

OUT FILE 

TEXT 10 

CE3102J 


OPEN 

IN_FILE 

TEXT 10 

CE3102K 


OPEN 

OUT__FILE 

TEXT_I0 

:107C. .D 

(2 

tests) , 

CE2107H, and 

CE2107L apply function NAME 


temporary sequential, direct, and text files in an attempt to 
associate multiple internal files with the same external file; 
USE_ERROR is raised because temporary files have no name. 

CE2108B, CE2108D, and CE3112B use the names of temporary sequential, 
direct, and text files that were created in other tests in order to 
check that the temporary files are not accessible after the completion 
of those tests; for this implementation, temporary files have no name. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 


EE2401D uses instantiations of DIRECT_IO with unconstrained array and 
record types; this implementation raises USE_ERROR on the attempt to 
create a file of such types. 


2-3 







IMPLEMENTATION DEPENDENCIES 


CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot restrict 
file capacity. 

CE3111B and CE3115A associate multiple internal text files with the 
same external file and attempt to read from one file what was written 
to the other, which is assumed to be immediately available,- this 
implementation buffers output. (See section 2.3.) 

CE3202A expects that function NAME can be applied to the standard 
input and output files,- in this implementation these files have no 
names, and USE_ERROR is raised. (See section 2.3.) 

CE3304A checks that SET_LINE_LENGTH and S£T_PAGE_LENGTH raise 
USE_ERROR if they specify an inappropriate value for the external 
file,- there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the 
page number exceeds COUNT'LAST; for this implementation, the value of 
COUNT'LAST is greater than 1S00Q0, making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 22 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 

S22003A B24009A B29001A B38003A B380C9A B3S009B 

B91001H BC2001D BC2001E BC3204B BC32053 BC3205D 

C34007P and C34007S were graded passed by Evaluation Modification as directed 
by the AVO. These tests include a check that the evaluation of the selector 
"all" raises CONSTRAINT_ERROR when the value of the object is null. This 
implementation determines the result of the equality tests at lines 207 and 
223, respectively, based on the subtype of the object,- thus, the selector is 
not evaluated and no exception is raised, as allowed by LRM 11.6(7) . The tests 
were graded passed given that their only output from Report.Failed was the 

message "NO EXCEPTION FOR NULL.ALL - 2". 

C41401A was graded inapplicable by Evaluation Modification as directed by the 
AVO. This test checks that the evaluation of attribute prefixes that denote 
variables of an access type raises CONSTRAINT_ERROR when the value of the 
variable is null and the attribute is appropriate for an array or task type. 
This implementation derives the array attribute values from the subtype; thus 
the prefix is not evaluated and no exception is raised, as allowed by LRM 

11.6(7), for the checks at lines 77, 87, 97, 108, 121, 131, 141, 152, 165, & 

175 . 

C64103A was graded passed by Evaluation Modification as directed by the AVO. 
This test checks that exceptions are raised when actual parameter values, which 
result from an explicit type conversion, do not belong to the formal 
parameter's base type. However this implementation recogni es that the formal 
parameter is not used within the procedure and therefore the type conversion 
(and subtype check) need not be made (as allowed by [Ada 83] 11.6.7) and the 
subsequent expected exception need not be raised. The AVO riled that the 


2-4 






IMPLEMENTATION DEPENDENCIES 


implementation's behavior should be graded passed, given that Report. Failed was 
invoked only from procedure calls at lines 91 (invoking line 76) and 119 
(invoking line 115), yielding the following output: 

"EXCEPTION NOT RAISED BEFORE CALL -P2 (A)" 

"EXCEPTION NOT RAISED BEFORE CALL -P3 (A) " 


BC3204C..D and BC3205C..D (4 tests) were graded passed by Evaluation 
Modification as directed by the AVO. These tests are expected to produce 
compilation errors, but this implementation compiles the units without error; 
all errors are detected at link time. This behavior is allowed by AI-00256. 
as the units are illegal only with respect to units that they do not depend on. 

CE3111B and CE3115A were graded inapplicable by Evaluation Modification as 
directed by the AVO. The tests assume that output from one internal file is 
unbuffered and may be immediately read by another file that shares the same 
external file. This implementation raises END_ERROR on the attempts to read 
at lines 87 and 101, respectively. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies function NAME to the standard input file, which in 
this implementation has no name; USE_ERR0R is raised but not handled, so the 
test is aborted. The AVO ruled that this behavior is acceptable pending any 
resolution of the issue by the ARG. 


2-5 



CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described adequately 
by the information given in the initial pages of this report. 

For a point of contact in Germany for technical and sales information about 
this Ada implementation system, see: 

Alsys GmbH & Co. KG 
Am Ruppurrer SchloS 7 
W-7500 Karlsruhe 51 
Germany 

Tel. +49 721 883025 

For a point of contact outside Germany for technical and sales information 
about this Ada implementation system, see: 

Alsys Inc. 

€7 South Bedford Str. 

Burlington MA 

01803-5152 

USA 

Tel. +617 270 0030 

Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customised test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 







The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the implementation's maximum 
precision (item e; see section 2.2), and those that depend on the support 
of a file system --if none is supported (item d). All tests passed, except 
those that are listed in sections 2.1 and 2.2 (counted in items b and f, 
below) . 


a) Total Number of Applicable Tests 3787 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicable Tests 87 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests # 201 


f) Total Number of Inapplicable Tests 288 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

The Ada implementation was installed on a computer at the AVF. The customized 
test suite (see section 1.3) was then loaded onto the host computer by the 
validation team. 

After the test files were loaded, the full set of tests was processed by the 
Ada implementation. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of the 
processing options for this implementation. It also indicates the default 
options. 

Tests were compiled using the command 

ada.c -v 'file name' 

and linked using the command 

ada.link -v -o 'file name' 'main unit'. 

The option -v was used to output additional compiling and linking information. 

The option -o was used to assign a dedicated file name to the generated 
executable image. 

Class B tests, the executable not applicable tests, and the executable tests 
of class E were compiled using the full listing option -1. For several tests, 
completer listings were added and concatenated using the option -L 'file name'. 
The completer is described in Appendix B, compilation system options, chapter 
4.2 of the User Manual on page 40. 

Test output, compiler and linker listings, and job logs were captured on a 
Magnetic Data Cartridge and archived at the AVF. The listings examined on-site 
by the validation team were also archived. 


3-2 






APPENDIX A 


MACRO PARAMETERS 

This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN--also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$MAX_IN_LEN 

2SS 

-- Value of V 

$BIG_ID1 

(1. 

.V-l => 'A’ , 

V 

*> '1') 

$BIG_ID2 

(1. 

. V-l => 'A' , 

V 

= > '2' ) 

$BIG_ID3 

11- 

. V/2 *> 'A') 
(1..V-l-V/2 

Sc 

= > 

'3' & 
'A' ) 

$BIG_ID4 

(1. 

.V/2 => 'A') 
(1..V-l-V/2 

Sc 

* > 

'4' Sc 
■A’ ) 

$BIG__INT_LIT 

(1. 

. V-3 => '0') 

Sc 

"2 98 " 

$ BIG_REAL_LIT 

(1. 

.V-S *> '0') 

Sc 

"690.0" 

$BIG_STRING1 

• II » 

Sc {1. .V/2 = 

> ' 

A' ) Sc ' 


$BIG_STRING2 Sc (1..V-1-V/2 => 'A') & '1' & 

$BLANKS (1..V-20 => ' ') 

$MAX_L£N_INT_BAS ED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAX LEN_REAL_BAS ED_LITERAL 

"IS:" & (1..V-7 '0') Sc " F . E : " 

$MAX STRING LITERAL & (1..V-2 => 'A') & 


A-l 



MACRO PARAMETERS 


The following table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 

$ACC_SIZE 32 

$ALIGNMENT 4 

$COUNT_LAST 2147483647 

$DEFAULT_MEM_SIZE 2147483648 

$DEFAULT_STOR_UNIT 8 

$DEFAULT_SYS_NAME MIPS_EPIX 

$DELTA_DOC 2#1.0#E-31 

$ ENTRY_ADDRE S S SYSTEM.INTERRUPT_VECTOR(SYSTEM.SIGUSR1) 

$ ENTRY_ADDRES S1 SYSTEM.INTERRUPT_VECTOR(SYSTEM.SIGUSR2) 

$ ENTRY_ADDRE S S 2 SYSTEM.INTERRUPT_VECTOR(SYSTEM.SIGALRM) 

$FIELD_LAST 512 

$FILE_TERMINATOR ' ’ 

$FIXED_NAME NO_SUCH_FIXED_TYPE 

$ FLOAT_NAME .NO_SUCH_FLOAT_TYPE 

$FORM_STRING 

$ FORM_STRING2 "CANNOT_RESTRICT_FILE_CAPACITY" 

$ GREATER_THAN_DURATION 

0.0 

$GREATER_THAN_DURATION_BASE_LAST 

200 _ 000.0 

$ GREATER_THAN_FLOAT_BASE_LAST 

16#1.0#E+32 

$GREATER__THAN_FLOAT_SAFE_LARGE 

16#0.8#E+32 

$ GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

0.0 

$HIGH_PRIORITY 15 

$ILLEGAL_EXTERNAL_FILE_NAME1 

/nodir/filel 


A-2 





MACRO PARAMETERS 


$ILLEGAL_EXTERNAL_FILE_NAME2 

/wrongdir/file2 


$INAPPROPRIATE_LINE_LENGTH 

-1 

$INAPPROPRIATE PAGE LENGTH 

-1 

PRAGMA INCLUDE 
PRAGMA INCLUDE 
-2147483648 
2147483647 
2147483648 
C 

- 0.0 

$LESS_THAN_DURATION_BASE_FIRST 

- 200 _ 000.0 

$LINE_TERMINATOR ASCII.LF 

$LOW_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

NULL; 


$INCLUDE_PRAGMA1 
$INCLUDE_PRAGMA2 
$INTEGER_FIRST 
$INTEGER_LAS T 
$INTEGER_LAST_PLUS_1 
$INTERFACE_LANGUAGE 
$LESS_THAN DURATION 


("A28006D1.TST") 
( "B28 006D1.TST") 


$MACHINE_CODE_TYPE 

$MANTISSA_DOC 

$MAX_DIGITS 

$MAX_INT 

$ MAX_INT_PLUS_1 

$MIN_INT 

SNAME 

$NAME_LIST 

$NAME_SPECIFICATIONl 

$NAME_S PECIFICATION2 

$NAME_SPECIFICATION3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW SYS NAME 


NO_SUCH_TYPE 

31 

15 

2147483647 

2147483648 

-2147483648 

SHORT_SHORT_INTEGER 

MIPS_E?IX 

/people/vali/res/chape/X2120A 
/people/vali/res/chape/X212OB 
/people/vali/res/chape/X3119A 
16#FFFFFFFE# 

2147483648 
MIPS EPIX 


A-3 



MACRO PARAMETERS 


$PAGE__TERMINATOR 

/ i 


$RECORD_DEFINITION 

NEW INTEGER 


$RECORD_NAME 

NO_SUCH_MACHINE_CODE_T 

$TASK_SIZE 

32 


$TASK_STORAGE_SIZE 

10240 


$TICK 

1.0/3600.0 


$VARIABLE_ADDRESS 

GET_VARIABLE_ 

_ADDRESS . 

$ VAR IAB LE_ADDRES S1 

GET_VARIABLE_ 

_ADDRESS1 

$VARIABLE_ADDRESS2 

GET_VARIABLE_ 

_ADDRESS2 

$YOUR_PRAGMA 

RESIDENT 



A-4 



appendix b 


COMPILATION AND LINKER SYSTEM OPTIONS 


The compiler and linker options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and not 
to this report. 


B-l 




Compiling 


Chapter 4 


4 Compiling 


After a program library has been created, one or more compilation units can be com¬ 
piled in the context of this library. The compilation units can be placed on different 
source files or they can all be on the same file. One unit, a parameterless procedure, 
acts as the main program. If all units needed by the main program and the main 
program itself have been compiled successfully, they can be linked. The resulting code 
can then be executed. 

§4.1 and Chapter 5 describe in detail how to call the Compiler, the Completer, which 
is called to generate code for instances of generic units, and the Linker. 

Chapter 6 explains the information which is given if the execution of a program is 
abandoned due to an unhandled exception. 

The information the Compiler produces and outputs in the Compiler listing is explained 
in §4.4. 

Finally, the log of a sample session is given in Chapter 7. 

The following conventions are used: 

<ADA_dir> stands for the directory where the Alsys Ada System is located on your 
computer. This directory can be found using the ada.lib command. 
(If you have no library just create one with the ada.create command.) 
The output of the ada.lib command displays the directory in the first 
line. 


4.1 Compiling Ada Units 

The command ada.c invokes the Compiler, and optionally Completer and Linker of 
the Alsys Ada System. 

ada.C Command Description 

NAME 

ada.c - Alsys Ada System compile command 

SYNOPSIS 

ada.c (option ...] (file ...] ( -Id Idopt j 


Alsys Ada System - User Manual 


35 






Chapter 4 


Compiling 


DESCRIPTION 

Compilation, Completion and Linking are performed in that order. The Completer 
is called if the -C or the -a option is specified. The Linker is called if the -a option 
is specified. By default, only the compiler runs and compiles the source(s) in the 
given files. 

The source file may contain a sequence of compilation units (cf. LRM(§10.I)). All 
compilation units in the source file are compiled individually. When a compila¬ 
tion unit is compiled successfully, the program library is updated and the Compiler 
continues with the compilation of the next unit on the source file. If the compi¬ 
lation unit contained errors, they are reported (see §4.4). In this case, no update 
operation is performed on the program library and all subsequent compilation 
units in the compilation are only analyzed without generating code. 

The command delivers a non-zero status code on termination (cf. exit(2)) if one 
of the compilation units contained errors. 

file specifies the file(s) to be compiled. The maximum length of lines in file is 255. 
The maximum number of source lines in file is 65534. 

Note: If you specify a file name pattern, which is replaced by one or more file 
names by the shell, the order of the compilation is alphabetical, which is 
not always successful. Thus file name patterns should be used together with 
the option -a. With this option the sources can be processed in any order. 

The generation of listing output is controlled by options -1 and -L. The default 
listing filename for a compilation is the basename, cf. basename(l ), of the source 
file with suffix . 1; when the source file already has a suffix, it is replaced by the 
suffix .1. When an automatic recompilation is performed through option -R the 
basename is taken from the original source file name stored in the library. 

-A Controls whether automatic inline expansion is performed. A sub¬ 

program S is automatically inlined at a place P where S is called, 
if the following conditions hold: S meets the requirements for ex¬ 
plicit inlining via PRAGMA inline (cf. §15.1.1); subprogram spec¬ 
ification and subprogram body of S are in the same compilation 
unit; and the estimated code size of S when expanded inline is not 
greater (or only slightly greater) than the call it replaces. (The 
estimation of size is based on heuristics and is not exact; however, 
it is designed to give a close approximation.) If you specify -A, 
automatic inline expansion is suppressed. 

By default, automatic inline expansion is performed. 

-a Specifies that the Compiler only performs syntactical analysis and 

the analysis of the dependencies on other units. The units in file 
are entered into the library if .they are syntactically correct. The 
actual compilation is done later. 


36 


Alsys Ada System - User Manual 





Compiling 


Chapter 4 


Note: An already existing unit with the same name as the new 
one is replaced and all dependent units become obsolete, 
unless the source file of both are identical. In this case the 
library is not updated because the dependencies are already 
known. 

By default, the normal, full compilation is done. 

-C unitlist Requests the completion of the units in unitlist, which is a white 
space separated list of unit names, unitlist must be a single shell 
argument and must therefore be quoted when it has more than 
one item. Example with two units: 
ada.c -C "our.unit my_im.it" 

The Completer generates code for all instantiations of generic 
units in the execution closure of the specified unit(s). It also 
generates code for packages without bodies (if necessary). 

If a listing is requested the default filename used is complete. 1. 
The listing file contains the listing information for all units given 
in unitlist. 

-c Controls whether a copy of the source file is kept in the library. 

The copy in the program library is used for later access by the 
Debugger or tools like the Recompiler. The name of the copy 
is generated by the Compiler and need normally not be known 
by the user. The Recompiler and the Debugger know this name. 
You can use the ada. list -1 co mman d to see the file name of the 
copy. If a specified file contains several compilation units a copy 
containing only the source text of one compilation unit is stored 
in the library for each compilation unit. Thus the Recompiler can 
recompile a single unit. 

If -c is specified, the Compiler only stores the name of the source 
file in the program library. In this case the Recompiler and the 
Debugger are able to use the original file if it still exists. 

A copy of the source is only taken if the ada.c command results 
in a successful compilation (and the option -c is not given). In 
particular, no copy is taken if the option -a is given since in this 
case no compilations are carried out. 

-D By default debug information for the Alsys Ada Debugger is gen¬ 

erated and included in the executable file. When the -D option 
is present, debug information is not included in the object file. If 
the program is to run under the control of the Debugger it must 
be linked without the -D option. 


Alsys Ada System - User Manual 


37 







Chapter 4 


Compiling 


-I 

-1 

-L directory 

-L file 
-Id Idopt 

-m unit 

- 0 / 


-o file 


Controls whether inline expansion is performed as requested by 
PRAGMA inline. If you specify -I these pragmas are ignored. 

By default, inline expansion is performed. 

Generates listing files with default filenames (see above) in the 
current directory (use option -L for redirecting to another direc¬ 
tory). 

Generates listing files with default filenames (see above) in direc¬ 
tory directory. 

Concatenates all listings onto file file. 

This option can be used to supply options for the call of /d(l) when 
linking a program by the -a option. -Id followed by the options 
to be passed to ld( 1) must be the last items of the command. 

Specifies the name of a main program, which must be a param¬ 
eterless procedure. This option will cause the completion of any 
generic instantiations in the program; if a listing is requested, the 
listing options have the same meaning as for the complete op¬ 
tion; if the completer has already been called by the -C option, 
the listing output is appended to that completer listing file. If 
all compilations are successful, the linker is invoked to build an 
executable file; if a listing is requested, the default filename for 
the linker listing is link.l. 

Restricts optimizations to level l. Level 0 indicates no optimiza¬ 
tions, level 1 indicates partial optimizations, level 2 indicates full 
optimization. Default is full optimization. 

Partial optimizations allows those optimizations that do not move 
code globally. These are: Constant propagation, copy propaga¬ 
tion, algebraic simplifications, runtime check elimination, dead 
code eli min ation, peephole and pipeline optimizations. This op¬ 
timization level allows easier debugging while maintaining a rea¬ 
sonable code quality. 

Full optimization enforces the following optimizations in addition 
to those done with -01: Global common subexpression elimination 
and keeping local variables in registers. 

When linking is requested by -a this option can be used to specify 
the name of the generated executable file. By default, the unit 
name given with the -a option is used; this value is taken literally, 
i.e. upper and lower case letters are distinguished. 


38 


Alsys Ada System - User Manual 




Compiling 


Chapter 4 


-R Indicates that a recompilation of a previously analyzed source is 

to be performed. This option should only be used in commands 
produced by the ada.nake command. 

-r Suppresses the generation of an executable file when linking is 

requested. See the -r option of the ada.link command (§5) for 
details. 

-S Controls whether all run-time checks are suppressed. If you spec¬ 

ify -S this is equivalent to the use of PRAGMA suppress for ail 
kinds of checks. 

By default, no run-time checks are suppressed, except in cases 
where PRAGMA suppress.all appears in the source. 

-s Controls whether machine code is appended to the listing file. 

-s has no effect if no listing is requested or -a (analyze only) is 
specified. 

By default, no machine code is appended to the listing file. 

-t Suppresses selective linking. Selective linking means that only the 

code of those subprograms which can actually be called is included 
in the executable image. With -t the code of all subprograms of 
all packages in the execution closure of the main procedure is 
linked into the executable image. 

Note: The code of the runtime system and of the predefined units 
is always linked selectively. 

-v Controls whether the ada. c command writes additional informa¬ 

tion onto standard error. 

By default, no additional information is written. 

-y library Specifies the program library the ada.c command works on. It 
needs write access to the library. 

The default library is adalib. 


End of Command Description 


Alays Ada System - User Manual 


39 




Linking 


Chapter 5 


5 Linking 

An Ada program Ls a collection of units used by a main program which controls the 
execution. The main program must be a parameterless library procedure; any param¬ 
eterless library procedure within a program library can be used as a main program. 

The EP/IX system linker is used by the Alsys Ada Linker. 


To link a program, call the ada.link command. The Linker can also be called directly 
from the ada.c command and from the ada.aake command. 


ada.link 


Command Description 


NAME 

ada.link - invoke the Alsys Ada System linker 
SYNOPSIS 

ada.link [option ...] unit [-Id ldopt\ 

DESCRIPTION 

The ada.link command invokes the Alsys Ada Linker. 

The Linker builds an executable file. The default file name of the executable file 
is the unit name of the main program given with the unit parameter. This value 
is taken literally, i.e. upper and lower case letters are distinguished. 

unit specifies the library unit which is the main program. This must be a para¬ 
meterless library procedure. 


-A This option is passed to the implicitly invoked Completer. See the 

same option with the ada.c command. 

-c Suppresses invokation of the Completer of the Alsys Ada System 

before the linking is performed. Only specify -c if you are sure 
that there are no instantiations or implicit package bodies to be 
compiled, e.g. if you repeat the ada.link command with different 
linker options. 


Alsys Ada System - User Manual 


51 









Chapter 5 


Linking 


-D By default debug information for the Alsys Ada Debugger is gen¬ 

erated and included in the executable file. When the -D option 
is present, debug information is not included in the object file. If 
the program is to run under the control of the Debugger it must 
be linked without the -D option. 

-I Controls whether inline expansion is performed as requested by 

PRAGMA inline. If you specify -I these pragmas are ignored. 

By default, inline expansion is performed. 

-1 If -1 is specified the Linker of the Aisys Ada System creates a list¬ 

ing file containing a table of symbols which are used for linking the 
Ada units. This table is helpful when debugging an Ada program 
with the EP/IX debugger. The default name of the listing file is 
link.l. By default, the Linker does not create a listing file. 

This option is also passed to the implicitly invoked Completer, 
which by default generates a listing file complete. 1 if -1 is given. 

-L directory The listing files are created in directory directory instead of in the 
current directory (default). 

-L file The listing files are concatenated onto file file. 

-Id Idopt This option can be used to supply options for the call of ld{ l). 

-Id followed by the options to be passed to ld( 1) must be the last 
items of the co mm and. 

-0/ This option is passed to the implicitly invoked Completer. See the 

same option with the ada. c command. 

-o file Specifies the name of the executable file. 

The default file name of the executable file is the unit name of the 
main program. 

-r Suppresses the generation of an executable file. In this case the 

generated object file contains the code of all compilation units 
written in Ada and of those object modules of the predefined lan¬ 
guage environment and of the Ada run time system which are 
used by the main program; references into the Standard C library 
remain unresolved. The generated object module is suitable for 
further /d(l) processing. The name of its entry point is oain. 

-S This option is passed to the implicitly invoked Completer. See the 

same option with the ada.c command. 


52 


Alsys Ada System - User Manual 




Linking 


Chapter 5 


“3 This option is passed to the implicitly invoked Completer. See the 

same option with the ada.c command. If a listing is requested 
and -s is specified, the Linker of the Alsys Ada System generates 
a listing with the machine code of the program starter in the 
file link.l. The program starter is a routine which contains the 
calls of the necessary elaboration routines and a call for the Ada 
subprogram which is the main program. 

By default, no machine code is generated. 

"t Suppresses selective linking. Selective linking means that only the 

code of those subprograms which can actually be called is included 
in the executable file. With -t the code of ail subprograms of all 
packages in the execution closure of the main procedure is li nk ed 
into the executable file. 

Note: The code of the runtime system and of the predefined units 
is always linked selectively, even if -t is specified. 

-v Controls whether the ada. link command writes additional infor¬ 

mation onto standard error, and is also passed to the implicitly 
invoked Completer. 

By default, no additional information is written. 

-y library Specifies the program library the command works on. The 
ada.link command needs write access to the library unless -c 
is specified. If -c is specified the ada.link command needs only 
read access. The default library is adalib. 


End of Command Description 


The ada.link command implicitly calls the EP/IX System Linker using the command 

/bsd43/bin/ld [-N 3 -o rtsultfUt /bsd43/usr/lib/cmplrs/cc/crtl .o \ 
obj rtslib Id-options -lc /bsd43/usr/lib/caplrs/cc/crtn.o 

unless the -r option is specified. When -r is specified, the Linker is called with the 
command 

/b3d43/bin/ld [-N] -o rcsultfile -r obj rtslib Id-options 

Here, obj denotes the file containing the object module which is produced by the Ada 
Linker and rtslib the archive library containing the Ada runtime system. (This may 
be librtadbg.a reap, librcs.a if the Alsys Ada Linker is called with option -D. In 
this case the -N option is missing. ) 


Alsys Ada System - User Manual 


53 









Chapter 5 


Linking 


If you invoke W( 1) by yourself to link the executable object rather than having the Ada 
Linker doing it automatically, then you must explicitly specify the startup modules 
(see below) and any libraries you want linked into the Ada program. Furthermore, the 
option -N of /d(l) should be specified to allow the resulting object file to be debugged 
by the Alsys Ada Debugger. (Note that debugging is only possible if the option -D 
was not passed to the Ada Linker.) 

The startup module must satisfy the following requirements: 

• A global variable called environ is defined containing a pointer to the current 
environment (cf. environ^).) 

• The Ada main program is called using the entry point main. 

• argc and argv are passed as arguments to main. 

Note that instructions following the call of main will never be executed. 

By default, the Standard C runtime startup routines /bsd43/u3r/lib/cmplrs/cc/crtl ,o 
and /bsd43/usr/lib/cmplrs/cc/crtn.o are used. 


54 


Alsys Ada System - User Manual 









APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation- 
dependent pragmas, to certain machine-dependent conventions as mentioned in 
Chapter 13 of the Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of this 
Ada implementation, as described in this Appendix, are provided by the 
customer. Unless specifically noted otherwise, references in this Appendix are 
to compiler documentation and not to this report. Implementation-specific 
portions of the package STANDARD, which are not a part of Appendix F, are 
contained in the following Predefined Language Environment (chapter 13 page 275 
ff of the compiler user manual). 


C-l 








Predefined Language Environment 


Chapter 13 


13 Predefined Language Environment 

The predefined language environment comprises the package standard, the language- 
defined library units and the implementation-defined library units. 


13.1 The Package STANDARD 

The specification of the package standard is outlined here; it contains all predefined 
identifiers of the implementation. 


PACKAGE standard IS 

TYPE boolean IS (false, true); 

— The predefined relational operators for this type are as follows: 

— FUNCTION "=" (left, right : boolean) RETURN boolean; 

— FUNCTION ■/«» (left, right : boolean) RETURN boolean; 

— FUNCTION "<" (left, right : boolean) RETURN boolean; 

— FUNCTION (left, right : boolean) RETURN boolean; 

— FUNCTION ">" * (left, right : boolean) RETURN boolean; 

— FUNCTION ">=*" (left, right : boolean) RETURN boolean; 

-- The predefined logical operators and the predefined logical 

— negation operator are as follows: 

— FUNCTION "AND" (left, right : boolean) RETURN boolean; 

— FUNCTION "OR" (left, right : boolean) RETURN boolean; 

— FUNCTION "XOR" (left, right : boolean) RETURN boolean; 

— FUNCTION "NOT" (right : boolean) RETURN boolean; 

— The universal type universal-integer is predefined. 

TYPE integer IS RANGE - 2_147_483_648 .. 2_147_483.647; 

—* The predefined operators for this type are as follows: 

— FUNCTION (left, right : integer) RETURN boolean; 

— FUNCTION "/■" (left, right : integer) RETURN boolean; 


AJsys Ada System - User Manual 


275 






Chapter 13 


Predefined Language Environment 


— 

FUNCTION 

n< n 

— 

FUNCTION 

!f< 3 n 

— 

FUNCTION 

ft > « 

— 

FUNCTION 


-- 

FUNCTION 

» + n 

— 

FUNCTION 

*♦- « 


FUNCTION 

"ABS" 

-- 

FUNCTION 

H + rt 

— 

FUNCTION 

M .ft 

— 

FUNCTION 

W * ft 

— 

FUNCTION 

ft J ft 

— 

FUNCTION 

"REM” 

-- 

FUNCTION 

"MOD” 

-- 

FUNCTION 

tt ** n 


(left, right : integer) RETURN boolean; 

(left, right : integer) RETURN boolean; 

(left, right : integer) RETURN boolean; 

(left, right : integer) RETURN boolean; 

(right : integer) RETURN integer; 

(right : integer) RETURN integer; 

(right ; integer) RETURN integer; 

(left, right : integer) RETURN integer; 

(left, right : integer) RETURN integer; 

(left, right : integer) RETURN integer; 

(left, right : integer) RETURN integer; 

(left, right : integer) RETURN integer; 

(left, right : integer) RETURN integer; 

(left : integer; right : integer) RETURN integer; 


— An implementation may provide additional predefined integer types. 

— It is recommended that the names of such additional types end 

— with INTEGER as in SHORT-INTEGER or LONG-INTEGER. The 
specification of each operator for the type universal-integer, or 

— for any additional predefined integer type, i3 obtained by 

-- replacing INTEGER by the name of the type in the specification 

— of the corresponding operator of the type INTEGER, except for the 

— right operand of the exponentiating operator. 


TYPE short-short^integer IS RANGE - 128 .. 127; 
TYPE short-integer IS RANGE - 32-768 .. 32-767; 


— The universal type universal-real is predefined. 

TYPE float IS DIGITS 6 RANGE 

- 16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

FOR float’size USE 32; 


— The predefined operators for this type are as follows: 


FUNCTION 
FUNCTION ■/»■ 
FUNCTION "<" 
FUNCTION "<*" 
FUNCTION ">" 
FUNCTION ">«" 


(left, right 
(left, right 
(left, right 
(left, right 
(left, right 
(left, right 


float) RETURN boolean; 
float) RETURN boolean; 
float) RETURN boolean; 
float) RETURN boolean; 
float) RETURN boolean; 
float) RETURN boolean: 


— FUNCTION ■*» (right : float) RETURN float; 


276 


Alsys Ada System - User Manual 












Predefined Language Environment 


Chapter 13 


~ FUNCTION «-« 

— FUNCTION w ABS n 

— FUNCTION 

— FUNCTION 

— FUNCTION 

— FUNCTION "/" 

— FUNCTION "**" 


(right : float) RETURN float; 

(right : float) RETURN float; 

(left, right : float) RETURN float: 

(left, right : float) RETURN float; 

(left, right : float) RETURN float; 

(left, right ; float) RETURN float; 

(left : float; right : integer) RETURN float; 


— An implementation may provide additional predefined floating 

— point types. It is recommended that the names of such additional 

— types end with FLOAT as in SHORT-FLOAT or LONG-FLOAT. 

— The specification of each operator for the type universal-real, 

— or for any additional predefined floating point type, is obtained 
-- by replacing FLOAT by the name of the type in the specification of 

— the corresponding operator of the type FLOAT. 


TYPE long-float IS DIGITS 15 RANGE 

- 16#O.FFFF_FFFF_FFFF_F8#E256 .. 
16#0. FFFF-FFFF JTFFF-F8#E25<5; 
FOR long-float'size USE 64; 


— In addition, the following operators are predefined for universal 

— types: 

— FUNCTION «*" (left : UNIVERSAL-INTEGER; right : UNIVERSAL-REAL) 

RETURN UNIVERSAL-REAL; 

— FUNCTION (left : UNIVERSAL-REAL; right : UNIVERSAL-INTEGER) 

RETURN UNIVERSAL-REAL; 

— FUNCTION »/" (left : UNIVERSAL-REAL; right : UNIVERSAL-INTEGER) 

RETURN UNIVERSAL-REAL; 

-- The Type universal-fixed is predefined. 

— The only operators declared for this type are 

— FUNCTION (left : ANY-FIXED-POINT-TYPE; 

right : ANY-FIXED-POINT-TYPE) RETURN UNIVERSAL-FIXED; 

— FUNCTION ■/" (left : ANY-FIXED-POINT-TYPE; 

right : ANY-FIXED.POINT-TYPE) RETURN UNIVERSAL-FIXED; 


— The following characters form the standard ASCII character set. 

— Character literals corresponding to control characters are not 

— identifiers. 


TYPE character IS 

(nul. soh, stx. etx. 


eot, enq. ack, bel. 




Chapter 13 


Predefined Language Environment 


bs. 

ht. 

if. 

Tt. 

it. 

cr. 

so. 

si. 

die. 

del, 

dc2. 

dc3, 

dc4. 

nak. 

ayn. 

etb, 

can. 

em. 

sub. 

esc, 

fa. 

ga. 

rs. 

us. 

• ■ 

• 

• i • 

• • 

* ft * 

• 


*$'. 

•7,*. 


ill 

• 

•r. 




* e 

• e 

i _ i 

• 

1 » 

• 1 

V. 

’O'. 

*1*. 

*2*. 

*3*. 

•4*. 

*5*. 

’6*. 

*7'. 

•8*. 

•9’. 

• • * 

• • • 

• • 

*<*. 

* 3 * 

• 

*>* , 

•? * 

•a*. 

•A’. 


*c\ 

*D\ 

*E\ 

*F\ 

■G* , 

•H*. 

•I*. 

•J*. 

*K\ 

*L’, 

*M*. 

’N*. 

*0'. 

’P\ 

•Q\ 

•R*. 


'T*. 

*U*. 

'V*. 

*w*. 

*X*. 

*Y\ 

•Z’. 

•c*. 


*]*. 

• « i 

• 

• t 

Ill 

» 

*a*. 

’b’. 

'c*. 

’d*. 

■e’. 

'f * . 

’g'. 

*h*. 

’i*. 


*k\ 

‘1’. 

*m*. 

•n'. 

•o'. 

‘P‘. 

V. 

*r\ 

‘s'. 

’t*. 

*u'. 

'V, 

*w'. 

*x\ 

•y\ 

'z '. 

•C. 

* r. 


i " » 

t 

del) 


FOR character USE — 128 ascii CHARACTER SET WITHOUT HOLES 

(0. 1. 2. 3. 4, 5. 125. 126. 127); 

— The predefined operators for the type CHARACTER are the saae as 

— for any enumeration, type. 

PACKAGE ascii IS 

— Control characters: 


nul 


CONSTANT 

character 

» 

nul; 

soh 

CONSTANT 

character 

* 3 

soh; 

stx 


CONSTANT 

character 

3 

stx; 

etx 

CONSTANT 

character 

; s 

etx; 

eot 


CONSTANT 

character 

3 

eot; 

enq 

CONSTANT 

character 

• 3 

enq; 

ack 


CONSTANT 

•character 

3 

ack; 

bel 

CONSTANT 

character 

* 3 

bel; 

bs 


CONSTANT 

character 

3 

bs; 

ht 

CONSTANT 

character 

• 3 

ht; 

If 


CONSTANT 

character 

3 

if; 

vt 

CONSTANT 

character 

;3 

vt; 

ff 


CONSTANT 

character 

3 

ff; 

cr 

CONSTANT 

character 

♦ 3 

cr; 

so 


CONSTANT 

character 

3 

so; 

si 

CONSTANT 

character 

: = 

si; 

die 


CONSTANT 

character 

3 

die; 

del 

CONSTANT 

character 

• 3 

del; 

dc2 


CONSTANT 

character 

3 

dc2; 

dc3 

CONSTANT 

character 

; 3 

dc3; 

dc4 


CONSTANT 

character 

3 

dc4; 

nak 

CONSTANT 

character 

I * 

nak; 

syn 


CONSTANT 

character 

a 

syn; 

etb 

CONSTANT 

character 

• 3 

etb; 

can 


CONSTANT 

character 

a 

can; 

em 

CONSTANT 

character 

• 3 

em; 

sub 


CONSTANT 

character 

a 

sub; 

esc 

CONSTANT 

character 

* 3 

esc; 

fs 


CONSTANT 

character 

a 

fs; 

gs 

CONSTANT 

character 

l M 

gs; 

rs 


CONSTANT 

character 

a 

rs; 

us 

CONSTANT 

character 

• 3 

us; 

del 


CONSTANT 

character 

a 

del; 







— Other characters: 

exclam : CONSTANT character :■ *!*; 

quotation : CONSTANT character :- 

sharp : CONSTANT character :- '#*; 


278 


Alsys Ada System - User Manual 





















Predefined Language Environment 


Chapter 13 


dollar 

CONSTANT character :* 

percent 

CONSTANT character :* 

ampersand 

CONSTANT character :* ’It’ 

colon 

CONSTANT character :» 

semicolon 

CONSTANT character :* 

query 

CONSTANT character :■ *?’ 

at.sign 

CONSTANT character :■ *0* 

l.bracket 

CONSTANT character :* 

back-slash 

CONSTANT character :* *\* 

r.bracket 

CONSTANT character :- ’]\ 

circumflex 

CONSTANT character :* 

underline 

CONSTANT character :» 

grave 

CONSTANT character := *” 

l.brace 

CONSTANT character := ’{* 

bar 

CONSTANT character :» ’1* 

r.brace 

CONSTANT character :* ’}’ 

tilde 

CONSTANT character :» 


lc_a : CONSTANT character :* ’a'; 


lc_z : CONSTANT character :* *z’; 

END ascii: 

-- Predefined subtypes: 

SUBTYPE natural IS integer RANGE 0 .. integer’last; 
SUBTYPE positive' IS integer RANGE 1 .. integer’last; 

— Predefined string type: 

TYPE string IS ARRAY(positive RANGE <>) OF character: 


PRAGMA byte.pack(string); 


— The predefined operators for this type are as follows: 


— FUNCTION 

— FUNCTION 

— FUNCTION 

— FUNCTION 

— FUNCTION 

— FUNCTION 


"»" (left, 
"/»" (left. 
"<" (left, 
"<*" (left. 
">" (left, 
">«" (left. 


right 

right 

right 

right 

right 

right 


string) RETURN boolean; 
string) RETURN boolean; 
string) RETURN boolean; 
string) RETURN boolean; 
string) RETURN boolean; 
string) RETURN boolean: 


FUNCTION "it" (left : string; right : string) RETURN string; 
FUNCTION "it" (left : character; right : string) RETURN string; 
FUNCTION "it" (left : string; right : character) RETURN string; 


A A Ail Sv»ti>m - TT<w»r Manual 


279 








Chapter 13 


Predefined Language Environment 


— FUNCTION (left : character; right : character) RETURN string; 


TYPE duration IS DELTA 2#1.0#E-14 RANGE 

- 131_072.0 .. 131_071.999-938.964-843-75; 


— The predefined operators for the type DURATION are the 3ame 

— as for any fixed point type. 

— the predefined exceptions: 


constraint-error 
numeric-error 
program-error 
storage-error 
tasking_error 


EXCEPTION; 
EXCEPTION; 
EXCEPTION; 
EXCEPTION; 
EXCEPTION; 


END standard; 


13.2 Language-Defined Library Units 

The following language-defined library units are included in the master library: 


The PACKAGE system 
The PACKAGE calendar 

The generic PROCEDURE unchecked-deallocation 

The generic FUNCTION unchecked-conversion 

The PACKAGE io.exceptions 

The generic PACKAGE sequential-io 

The generic PACKAGE direct_io 

The PACKAGE text-io 

The PACKAGE lovr_level_io 


280 


Alsys Ada System - User Manual 





Appendix F: Representation Clauses 


Chapter 16 


16 Appendix F: Representation Clauses 


In this chapter we follow the section numbering of Chapter 13 of the LRM and provide 
notes for the use of the features described in each section. 


16.1 Pragmas 

PACK 

As stipulated in the LRM(§13.1), this pragma may be given for a record or array 
type. It causes the Compiler to select a representation for this type such that gaps 
between the storage areas allocated to consecutive components are minimized. For 
components whose type is an array or record type PRAGMA pack has no effect on 
the mapping of the component type. For all other component types the Compiler 
will choose a representation for the component type that needs minimal storage 
space (packing down to the bit level). Thus the components of a packed data 
structure will in.general not start at storage unit boundaries. 


BYTE_?ACK 

This is an implementation-defined pragma which takes the same argument as 
the predefined language PRAGMA pack and is allowed at the same positions. For 
components whose type is an array or record type PRAGMA byte_pack has no 
effect on the mapping of the component type. For all other component types the 
Compiler will try to choose a more compact representation for the component type. 
But in contrast to PRAGMA pack all components of a packed data structure will 
start at storage unit boundaries and the size of the components will be a multiple 
ofsystea.storage-unit. Thus, PRAGMA byte-pack does not effect packing down 
to the bit level (for this see PRAGMA pack). 


Alsvs Ada System - User Manual 


313 




Chapter 16 


Appendix F: Representation Clauses 


16.2 Length Clauses 

SIZE 

For all integer, fixed point and enumeration types the value must be <= 32; 
for float types the value must be = 32 (this is the amount of storage which is 
associated with these types anyway). 

for long_float types the value must be = 64 (this is the amount of storage which 
is associated with these types anyway); 

for access types the value must be — 32 (this is the amount of storage which is 
associated with these types anyway). 

If any of the above restrictions are violated, the Compiler responds with a RE" 
STRICTIQtf error message in the Compiler listing. 

STORAGE-SIZE 

Collection size: If no length clause is given, the storage space needed to contain 
objects designated by values of the access type and by values of other types derived 
from it is extended dynamically at runtime as needed. If, on the other hand, a 
length clause is given, the number of storage units stipulated in the length clause 
is reserved, and no dynamic extension at runtime occurs. 

Storage for tasks: The memory space reserved for a task is 10K (+ 2K) bytes if no 
length clause is given (cf. Chapter 14). If the task is to be allotted either more or 
less space, a length clause must be given for its task type, and then all tasks of this 
type will be allotted the amount of space stipulated in the length clause. Whether 
a length clause is given or not, an additional 2K bytes axe allotted for runtime 
activities and the total space allotted is not extended dynamically at runtime. 


SMALL 

There is no implementation-dependent restriction. Any specification for SMALL 
that is allowed by the LRM can be given. In particular those values for SMALL are 
also supported which are not a power of two. 


16.3 Enumeration Representation Clauses 

The integer codes specified for the enumeration type have to lie inside the range of the 
largest integer type which is supported; this is the type integer defined in package 
standard. 


314 


Alsys Ada System - User Manual 






Appendix F: Representation Clauses 


Chapter 16 


16.4 Record Representation Clauses 


Record representation clauses are supported. The value of the expression given in an 
alignment clause must be 0, 1, 2 or 4. If this restriction is violated, the Compiler 
responds with a RESTRICTION error message in the Compiler listing. If the value is 0 
the objects of the corresponding record type will not be aligned, if it is 1, 2 or 4 the 
starting address of an object will be a multiple of the specified alignment. 

The number of bits specified by the range of a component clause must not be greater 
than the amount of storage occupied by this component. (Gaps between components 
can be forced by leaving some bits unused but not by specifying a bigger range than 
needed.) Violation of this restriction will produce a RESTRICTION error message. 

There are implementation-dependent components of record types generated in the 
following cases : 

• If the record type includes variant parts and the difference between the maximum 
and the minimum sizes of the variant is greater than 32 bytes, and, in addition, 
if it has either more than one discriminant or else the only discriminant may 
hold more than 256 different values, the generated component holds the size of 
the record object. (If the second condition is not fulfilled, the number of bits 
allocated for any object of the record type will be the value delivered by the size 
attribute applied to the record type.) 

• If the record type includes array or record components whose sizes depend on dis¬ 
criminants, the generated components hold the offsets of these record components 
(relative to the corresponding generated component) in the record object. 

But there are no implementation-generated names (cf. LRM(§13.4(8))) denoting these 
components. So the mapping of these components cannot be influenced by a represen¬ 
tation clause. 


16.5 Address Clauses 

Address clauses are supported for objects declared by an object declaration and for 
single task entries. If an address clause is given for a subprogram, package or a task 
unit, the Compiler responds with a RESTRICTION error message in the Compiler listing. 

If an address clause is given for an object, the storage occupied by the object starts at 
the given address. Address clauses for single entries are described in §16.5.1. 


A !«v« A A a - T Tgar Vfarmal 


IUl 





Chapter 16 


Appendix F: Representation Clauses 


16.5.1 Interrupts 

Under EP/DC it is not possible to handle hardware interrupts directly within the Ada 
program; all hardware interrupts are handled by the operating system. In EP/DC, 
asynchronous events are dealt with by signals (cf. siguec(2)). In the remainder of this 
section the terms signal and interrupt should be regarded as synonyms. 

An address clause for an entry associates the entry with a signal. When a signal 
occurs, a signal catching handler, provided by the Ada runtime system, initiates the 
entry call. 

By this mechanism, an interrupt acts as an entry call to that task; such an entry is 
called an interrupt entry. 

The interrupt is mapped to an ordinary entry call. The entry may also be called by an 
Ada entry call statement. However, it is assumed that when an interrupt occurs there 
is no entry call waiting in the entry queue. Otherwise, the program is erroneous and 
behaves in the following way: 

• If an entry call stemming from an interrupt is already queued, this previous entry 
call is lost. 

• The entry call stemming from the interrupt is inserted into the front of the entry 
queue, so that it is handled before any entry call stemming from an Ada entry 
call statement. 


16.5.1.1 Association between Entry and Interrupt 

The association between an entry and an interrupt is achieved via an interrupt number 
(type system interrupt _nunber), the range of interrupt numbers being I .. 31 (this 
means that 31 single entries can act as interrupt entries). The meaning of the interrupt 
(signal) numbers is as defined in sigvec(2). A single parameterless entry of a task can be 
associated with an interrupt by an address clause (the Compiler does not check these 
conventions). Since an address value must be given in the address clause, the interrupt 
number has to be converted into type systen. address. The array system interrupt _ 
vector is provided for this purpose; it is indexed by an interrupt number to get the 
corresponding address. 

The following example associates the entry ir with signal SIGINT. 


316 


Alsys Ada System - User Manual 



Appendix F: Representation Clauses 


Chapter 16 


TASK handler IS 
ENTRY ir; 

FOR ir USE AT systea.interrupt-vector (systaa.sigint)• 
END; * ' 


The task body contains ordinary accept statements for the entries. 


16.5.1.2 Important Implementation Information 


There are some important facts which the user of interrupt entries should know about 
the implementation. First of all, there are some signals which the user should not use 
within address clauses for entries. These signals are SIGFPE, SICSEGV, SIG3US, SIGILL, 
SIGTRAP and SIGALRM; they are used by the Ada Runtime System to imp’ nent excep¬ 
tion handling and delay statements (SIGALRM). Programs containing address clauses 
for entries with these interrupt numbers are erroneous. 

Moreover, the Debug Runtime System establishes a signal catching handler for the 
signals SIGUSRl and SIGQUIT; hence, debugging of any program containing an address 
clause for an entry with either of these interrupt numbers is restricted. 

When the signal SIGUSRl is used for an interrupt entry, the break-in and connect 
commands (described in §3.7.2 and §3.5.1 respectively) must not be used as they send 
the signal SIGUSRl to the program. 

When the signal SIGQUIT is used for an interrupt entry, no program dump can be 
created by sending this signal to the program. This restriction does not affect the 
automatic generation of a program dump when the program is abandoned due to an 
unhandled exception. 

In the absence of address clauses for entries, the Ada Runtime System establishes signal 
catching handlers only for the signals mentioned above, so all other signals will lead 
to program abortion as specified in the EP/IX documentation. 

A signal catching handler for a specific signal is established when a task which has an 
interrupt entry for this signal is activated. The signal catching handler is deactivated 
and the previous handler is restored when the task has been completed. Several tasks 
with interrupt entries for the same signal may exist in parallel; in this case the signal 
catching handler is established when the first of these tasks is activated, and deactivated 
when the last of these tasks has been completed. 


Alsys Ada System - User Manual 


317 



Chapter 16 


Appendix F: Representation Clauses 


16.5.1.2 Example With Interrupt Entries 

A complete example for an interrupt entry follows at the end of this section. This 
example can be found in <ADA_dir>/exaaple/interrupt .ada. In that example, a 
child process is created (by a EP/IX system call fork{ 2)) which executes the s/i(l) with 
the command sleep 10 (cf. sleep( 1)). A task named shell_call_handler defines the 
entry handle_sigchid which is bound to the occurrence of the signal SIGCKLD. Once 
this signal occurs, i.e. the child process dies after about 10 seconds, this interrupt 
entry is called and handled. 

The log of a sample session follows. The lines starting with are EP/IX commands, 
all other lines are output. 


$ ada.c -v interrupt.ada 

ALSYS ADA - COMPILER Control Data 4CC0/EP/IX 1.83 

Library: /tnp/adalib 

Coopiling: /tap/interrupt.ada 

PROCEDURE INTERRUPT-EXAMPLE 

*** jf 0 Errors found *** 

CPU Tiae used : 4.1 Seconds 


$ ada.link -v ~o interrupt interrupt_exaaple 

ALSYS ADA - COMPLETER Control Data 4000/EP/IX 1.83 

Library: /tap/adalib 

Coapleting: INTERRUPT-EXAMPLE.-DUR-I0-3OOCO1 
SEPARATE PACKAGE BODY _DUR_IO_B00001 
*** No Errors found *** 

CPU Tiae used : 1.0 Seconds 

ALSYS ADA - LINKER Control Data 4000/EP/IX 1.83 


$ interrupt 

At 45538.33142. "sleep 10" started. 

At 45549.63086. workload finished 

At 45549.63202. "sleep 10" - status: 0 

$ cat interrupt.ada 


Alsys Ada System - User Manual 


318 






Appendix F: Representation. Clauses 


Chapter 16 


WITH system, text_io. calendar: 

PROCEDURE interrupt_exanple IS 
PRAGMA priority (1)• 

status : integer; 
f : float; 

abort.error : EXCEPTION; 


FUNCTION time_staep RETURN string IS 
t : calendar.tine calendar.clock; 
result : string (1 .. 15); 

PACKAGE dur_io IS NEW text_io.fixed_io (duration); 

BEGIN 

dur_io.put (result, calendar.seconds (t)) ; RETURN result; 
END time-stamp; 

PROCEDURE error (func : string) IS 
BEGIN 

text-io.put_line ( 

func b error" Sc integer’inage (system, ermo)) ; 

RAISE abort-error; 

END error; 


PROCEDURE systea_call (cocnand : IN string) IS 
result : integer; PRAGMA resident (result); 
argO : CONSTANT string :* "/bin/sh" St ascii.nul; 

PRAGMA resident (argO); 
argl : CONSTANT string :■ "sh" b ascii.nul; 

PRAGMA resident (argl); 
arg2 : CONSTANT string :■ "-c" b ascii.nul; 

PRAGMA resident (arg2); 
argS : string (1 .. 80); 

PRAGMA resident (arg3) ; 
arg4 : CONSTANT 3tring * ascii.nul; 

PRAGMA residert (arg4); 


FUNCTION unix_fork RETURN integer; 

PRAGMA interface (c, unix_fork); 

PRAGMA external-name ("fork", unix_fork); 


FUNCTION unix_execl ( 

argO, argl, arg2, 

arg3, arg4 ; system.address) RETURN integer; 
PRAGMA interface (c. unix_execl); 

PRAGMA external-name ("execl", unix_execl) ; 


Aisys Ada System - User Manual 


319 



Chapter 16 


Appendix F: Representation Clauses 


BEGIN — systen_call 

arg3 (1 .. 1 + command'length - 1) :■ command; 
arg3 (command'length ♦ 1) :* ASCII.nul: 
result := unix_fork; 

IF result - 0 THEN 
— child process 
DELAY (1.0): 

result := unix_execl (argO’address, 

argl'address, arg2*address, 
arg3’address, arg4’address); 
error ("ercacl") ; 

ELSIF result * -1 THEN 
error ("fork"); 

ELSE 

NULL; -- the parent 
END IF; 

END system.cali; 

PROCEDURE wait_for-child (status ; OUT integer) IS 
r_status : integer; 

PRAGMA resident (r_status); 
result : integer; 

FUNCTION unix_wait (status : IN systen.address) RETURN integer; 
PRAGMA interface (c, unix_wait); 

PRAGMA external_naae ("wait", unix_wait) ; 

BEGIN — wait_*for_child 

result :* uni:c_wait (r_status’addre33); 

IF result * -1 THEN error ("wait"); END IF; 
status :■ r.status; 

END wait_for.child; 

TASK shell_call_handler IS 
PRAGMA priority (2); 

ENTRY subshell (comnand : IN string): 

ENTRY wait (status : OUT integer); 

ENTRY handle.sigchld; 

FOR handle_sigchld USE AT 

sy3ten.interrupt_vector(systea.sigchld); 

END shell_call_handlar; 

TASK workload IS 

PRAGMA priority (0); 

ENTRY start; 

ENTRY stop; 

ENTRY finished (result ; OUT float); 

END workload; 


320 


Aisya Ada System - User Manual 






Appendix F: Representation Clauses 


Chapter 16 


TASK BODY shell_call_handler IS 
last.status : integer : = 0; 

BEGIN 

LOOP 

SELECT 

ACCEPT subshell (command : IN string) DO 
systea.call (command): 

END subshell; 

ACCEPT handle-sigchld; 
workload.stop; 

wait-for_child (last-status); 

OR 

ACCEPT wait (status : OUT integer) DO 
status :=* last-status; 

END wait; 

OR 

TERMINATE; 

END SELECT; 

END LOOP; 

END shell.call-handler; 

TASK BODY workload IS 
f ; float :*» 0.0; 

BEGIN 

ACCEPT start; 

LOOP 

SELECT - 

ACCEPT ston; EXIT; 

ELSE 

IF f >* 10.0 THEN f :» 0.0; END IF; 
f :* f * 2.0 ♦ 1.0; 

END SELECT; 

END LOOP; 

ACCEPT finished (result : OUT float) DO 
result :» f; 

END finished; 

END workload; 

BEGIN 

shell_call_handler.subshell ("sleep 10"); 

text_io.put-line ("At " ft time-stamp ft ", ""sleep 10"" started."); 
workload.start; 
workload.finished (f); 

text_io.put-line ("At " ft tiae.staap ft ", workload finished"); 
shell_call_handler.wait (status); 

text_io.put-line ("At " ft time-staap ft ", ""sleep 10"" - status:" 

ft integer‘image (status)); 


END interrupt.example; 




Chapter 16 


Appendix F: Representation Clauses 


16.6 Change of Representation 

The implementation places no additional restrictions on changes of representation. 


Alsys Ada System - User Manual 




Appendix F: I/O 


Chapter 17 


17 Appendix F: I/O 

In this chapter we follow the section numbering of Chapter 14 of the LRM and provide 
notes for the use of the features described in each section. 


17.1 External Files and File Objects 


An external file is identified by a string that denotes an EP/IX file name. It may 
consist of up to 1023 characters. 

The form string specified for external files is described in §17.2.1.1. 


17.2 Sequential and Direct Files 


Sequential and direct files are ordinary files which are interpreted to be formatted with 
records of fixed or variable length. Each element of the file is stored in one record. 

In case of a fixed record length each file element has the same size, which may be 
specified by a form parameter (see §17.2.1.1); if none is specified, it is determined to 

be (element-type 1 SIZE -r aystem.etor age .unit — 1) / system.storage^unit. 

In contrast, if a variable record length is chosen, the size of each file element may 
be different. Each file element is written with its actual length. When reading a file 
element its size is determined as follows: 

• If an object of the elenent_type has a size component (see §16.4) the element 
size is determined by first reading the corresponding size component from the file. 

• If eleaent-type is constrained, the size is the minimal number of bytes needed 
to hold a constrained object of that type. 

• In all other cases, the size of the current file element is determined by the size of 
the variable given for reading. 


17.2.1 File Management 

Since there is a lot to say about this section, we shall introduce subsection numbers 
which do not exist in the LRM. 


Alsys Ada System * User Manual 


323 


Chapter 17 


Appendix F: I/O 


17.2.1.1 The NAME and FORM Parameters 

The nase parameter must be an EP/DC file name. The function nase will return a 
path name string which is the complete file name of the file opened or created. Each 
component of the file name (separated by ”/”) is truncated to 255 characters. Upper 
and lower case letters within the file name string are distinguished. 

The syntax of the fora parameter string is defined by: 


fora_parameter :: a C fora_specification { . forn_specification } ] 

fora_specification keyword [ *> value 3 

keyword ::« identifier 

value identifier I nuaeric.literal 

For identifier and nuaeric .literal see LRM(Appendix E). Only an integer literal 
is allowed as mineric.literal (see LRM(§2.4)). In an identifier or numeric, 
literal, upper and lower case letters are not distinguished. 

In the following, the form specifications which are allowed for all files are described. 


MODE *> nuneric.literal 

This value specifies the access pe rmis sion of an external file; it only has an effect in 
a create operation and is ignored in an open. Access rights can be specified for the 
owner of the file, the members of a group, and for all other users. nuoeric_literal 
has to be a three digit octal number. 

The access permission is then interpreted as follows: 

8#400# read access by owner 
8#200# write access by owner 
8#100* execute access by owner 

8#040# read access by group 

write/axecute access by group, analogously 
8#004# read access by all others 

.. write/execute access by others, analogously 


324 


Alsys Ada System - User Manual 


Appendix F: I/O 


Chapter 17 


Each combination of the values specified above is possible. The default value is 

8 # 666 #. 

The definitive access permission is then determined by the EP/DC System. It will be 
the specified value for MODE, except that no access right prohibited by the process’s 
file mode creation mask (which may be set by the EP/IX co mm and timai/c(l)} is 
granted. In other words, the value of each "digit” in the process’s file mode creation 
mask is subtracted from the corresponding "digit” of the specified mode. For example, 
a file mode creation mask of 3#022jf removes group and others write permission (i.e. 
the default mode 8#666# would become mode 8#644#). 

The following form specification is allowed for sequential, direct and text files: 


SYNCHRO => OFF | ON ! ON-WAIT 


It allows reader/writer synchronization of parallel file accesses by different processes, 
such that only one process may write to a file (and no other process may read from 
or write to the same file in parallel) or multipte processes may read a file in parallel. 
This synchronization is achieved through the system call fcntl{ 2). 

By default parallel accesses are not synchronized (SYNCHRO => OFF). 

If the form specification SYNCHRO *> ON is given, USE-ERROR is raised when the 
access is not possible (because other processes are accessing the file when write access is 
requested, or because another process is writing the file when read access is requested). 
If the form specification SYNCHRO => ON.WAIT is given, the process is blocked when the 
access is not possible for one of the above reasons. When the access becomes possible, 
the process is unblocked. USEJERROR is not raised with SYNCHRO *> ON-WAIT. 

The following form specification is allowed for sequential and direct files: 


RECORD_SIZE *> nuneric-literal 


This value specifies the size of one element on the file (record size) in bytes. This form 
specification is only allowed for files with fixed record format. If the value is specified 
for an existing file it must agree with the value of the external file. 

By default, [eUment^typt'SIZE-r jyjiem.jtora^e-uro't — l)/st/atem.itoragc-unit will be chosen 
as record size, if the evaluation of this expression does not raise an exception. In this 
case, the attempt to create or open a file will raise USE-ERROR. 

If a fixed record format is used, ail objects written to a file which are shorter than the 
record size are filled up. The content of this extended record area is undefined. An 
attempt to write an element which is larger than the specified record size will result 
in the exception use-error being raised. This can only happen if the record size is 
specified explicitly. 


Alsya Ada System - User Manual 


325 




Chapter 17 


Appendix F: I/O 


17.2.1.2 Sequential Files 


A sequential file is represented by an ordinary file that is interpreted to be formatted 
with either fixed-length or variable-length records (this may be specified by the form 
parameter). 

If a fixed record format is used, all objects written to a file which are shorter than 
the maximum record size are filled up. The content of this extended record area is 
undefined. 


RECORD-FORMAT => VARIASLE 1 FIXED 


This form specification is used to specify the record format. If the format is specified 
for an existing file it must agree with the format of the external file. 

The default is variable record size. This means that each file element is written with 
its actual length. A read operation transfers exactly one file element with its actual 
length. 

Fixed record size means that every record is written with the size specified as record 
size. 


APPEND *> FALSE I TRUE 


If the form specification APPEND => TRUE is given for an existing file in an open for an 
output file, then the file pointer will be set to the end of the file after opening, i.e. the 
existing file is extended and not rewritten. This form specification is only allowed for 
an output file; it only has an effect in an open operation and is ignored in a create. By 
default the value FALSE is chosen. 


TRUNCATE »> FALSE I TRUE 


If the form specification TRUNCATE *> TRUE is given for an existing file in an open for 
an output file, then the file length is truncated to 0, i.e. the previous contents of the 
file are deleted. Otherwise the file is rewritten, i.e. if the amount of data written is 
less than the file size, data previously written will remain at the end of the file. This 
form specification is only allowed for an output file; it only has an effect in an open 
operation and is ignored in a create. By default the value TRUE is chosen. 


326 


Alsys Ada System - User Manual 







Appendix F: I/O 


Chapter 17 


The default form string for a sequential file is : 

"RECORD.FORMAT => VARIABLE. APPEND *> FALSE. * k 
"TRUNCATE *> TRUE. MODE *> 8*666# " k 

"SYNCHRO *> OFF" 


17.2.1.3 Direct Files 


The implementation dependent type count defined in the package specification of 
direct _io has an upper bound of : 

COUNT‘LAST - 2_147.483.647 (=* INTEGER’LAST) 

A direct file is represented by an ordinary file that is interpreted to be formatted 
with records of fixed length. If not explicitly specified, the record size is equal to 
[element-type? SIZE 4* syetem. 3 tarage~.unit — 1) / sy3tem.3torage~.unit. 


The default form string for a direct file is : 

"RECORD.SIZE *> .... MODE => 8*666*, SYNCHRO *> OFF" 


17.3 Text I/O 

Text files are sequential character files. 

Each line of a text file consists of a sequence of characters terminated by a line termi¬ 
nator, i.e. an ASCULF character. 

A page terminator is represented by an ASCII.FF character and is always preceded by 
a line terminator. 

A file terminator is not represented explicitly in the external file; the end of the file is 
taken as a file terminator. A page terminator is assumed to precede the end of the file 
if there is not explicitly one as the last character of the file. 

Output to a file and to a terminal differ in the following way: If the output refers to 
a terminal it is unbuffered, which means that each write request in an Ada program 


Alsys Ada System - User Manual 


327 





Chapter 17 


Appendix F: I/O 


will appear on the terminal immediately. Output to other files is buffered, l.e several 
characters are saved up and written as a block. 

Terminal input is always processed in units of lines. 


17.3.1 File Management 

Besides the mode specification (cf. §17.2.1.1) the following form specification is allowed: 
APPEND => FALSE | TRUE 


If the form specification APPEND *> TRUE is given for an existing file in an open for an 
output file, then the file pointer will be set to the end of the file after opening, i.e. the 
existing file is extended and not rewritten. This form specification is only allowed for 
an output file; it only has an effect in an open operation and is ignored in a create. By 
default the value FALSE is chosen. 

The default form string for a text file is : 

"APPEND => FALSE, MODE =*> 8*666#, SYNCHRO => OFF" 


17.3.2 Default Input and Output Files 

The standard input (resp. output) file is associated with the standard EP/DC files 
stdin resp. stdout. 

Writing to the EP/EC standard error file stderr may be done by using the package 
text_io_extension (cf. §13.3.4). 


328 


Alsys Ada System - User Manual 





Appendix F: I/O 


Chapter 17 


17.3.3 Implementation-Defined Types 


The implementation-dependent types count and field defined in the package specifi¬ 
cation of text—io have the following upper bounds : 


COUNT*LAST 


2_147_483_647 


INTEGER‘LAST) 


FIELD‘LAST * 512 


IT.4 Exceptions in I/O 


For each of nane_error, use.error, device_error and data_error we list the condi¬ 
tions under which that exception can be raised. The conditions under which the other 
exceotions declared in the package io.exceotions can be raised are as described in 
LRM(§14.4). 

NAME-ERROR 

• in an open operation, if the specified file does not exist; 

• if the aane parameter in a call of the create or open procedure is not a legal 
EP/EX file name'string; i.e, if a component of the path prefix is not a directory. 


USE-ERROR 

• whenever an error occurred during an operation of the underlying EP/DC system. 
This may happen if an internal error was detected, an operation Is not possible for 
reasons depending on the file or device characteristics, a capacity limit is exceeded 
or for similar reasons; 

• if the function nace is applied to a temporary file or to the standard input or 
output file; 

• if an attempt is made to write or read to/from a file with fixed record format a 
record which is larger than the record size determined when the file was opened 
(cf. §17.2.1.1); in general it is only guaranteed that a file which is created by am 
Ada program may be reopened and read successfully by another program if the 
file types and the form strings are the same; 

• in a create or open operation for a file with fixed record format (direct file or 
sequential file with f ora, parameter RECORD-FORMAT -> FIXED) if no record size is 
specified and the evaluation of the size of the element type will raise an exception. 


Aisys Ada System - User Manual 


329 





Chapter 17 


Appendix F: I/O 


(For example, if direct_io or sequential_io is instantiated with an unconstrained 
array type.) 

• if a given fora parameter string does not have the correct syntax or if a condition 
on an individual form specification described in §§17.2-3 is not fulfilled; 

• in a create or open operation with form specification SYNCHRO *> ON when the 
requested access is currently not possible; see §17.2.1.1 for the exact conditions. 


DEVICE-ERROR 

is never raised. Instead of this exception the exception use_error is raised when¬ 
ever an error occurred during an operation of the underlying EP/DC system. 


DATA-ERIIOR 

the conditions under which data_error is raised by text-io are laid down in the 

LRM. 


In general, the exception data_error is not usually raised by the procedure read 
of sequential_io and direet_io if the element read is not a legal value of the 
element type because there is no information about the file type or form strings 
specified when the file was created. 

An illegal value may appear if the package sequential.io or direct-io was 
instantiated with a different eleaent-type or if a different form parameter string 
was specified when creating the file. It may also appear if reading a file element 
is done with a constrained object and the constraint of the file element does not 
agree with the constraint of the object. 

If the element on the file is not a legal value of the element type the effect of 
reading is undefined. An access to the object that holds the element after reading 
may cause a constraint-error, storage-error or non_ada_error. 


17.5 Low Level I/O 

We give here the specification of the package low_level_io: 

PACKAGE lo*«-level_io IS 

TYPE device-type IS (null-device): 

TYPE data-typ« IS 
RECORD 
NULL; 


330 


A lays Ada System - User Manual 




Appendix F: I/O 


Chapter 17 


END RECORD; 

PROCEDURE send.control (device : device_t 7 pe: 

data : IN OUT data.type); 

PROCEDURE receive.control (device : device.typa; 

data : IN OUT data.type); 


END low_level_io; 


Note that the enumeration type device .type has only one enumeration value, null, 
device; thus the procedures send.control and receive.control can be called, but 
send.control will have no effect on any physical device and the value of the actual 
parameter data after a call of receive.control will have no physical significance. 


Alsys Ada System - User Manual 


331 








