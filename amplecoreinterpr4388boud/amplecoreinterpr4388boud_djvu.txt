NISTIR 4388 


AMPLE CORE 
INTERPRETER: 
USER’S GUIDE 


J. C. Boudreaux 


U.8. DEPARTMENT OF COMMERCE 
National Institute of Standards 
and Technology 

Center for Manufacturing Engineering 
Automated Production Technology Division 
Gaithersburg, MD 20899 


U.S. DEPARTMENT OF COMMERCE 
Robert A. Mosbacher, Secretary 

NATIONAL INSTITUTE OF STANDARDS 
AND TECHNOLOGY 
John W. Lyons, Director 


NIST 






NISTIR 4388 


AMPLE CORE 
INTERPRETER: 
USER’S GUIDE 


J. C. Boudreaux 


U.S. DEPARTMENT OF COMMERCE 
National Institute of Standards 
and Technology 

Center for Manufacturing Engineering 
Automated Production Technology 
Gaithersburg, MD 20899 


September 1990 



U.S. DEPARTMENT OF COMMERCE 
Robert A. Mosbacher, Secretary 

NATIONAL INSTITUTE OF STANDARDS 
AND TECHNOLOGY 
John W. Lyons, Director 






Foreword 


Origins. Since its inception in 1984, AMPLE has been conceived as a programming language 
environment which permits the construction of control interfaces to industrial manufacturing 
systems /3/, /5/, /&/. This report describes the AMPLE Core Interpreter, Version 1.0. 

AMPLE has gone through two major editions. The first was Version 0.1 in which AMPLE 
Core was a dialect of LISP called Franzlisp /5/, /17/. This version wais hosted on a Silicon 
Graphics^ IRIS workstation under the Unix^ operating system. This version of AMPLE, in- 
cluding such operational modules as the AMPLE Workstation Animation Package (AWAP) and 
the Real-Time Control Interfeice (ARTCI), which were coded in Fortran, has been discussed in 
/3/. The primary objective of AMPLE Version 0.1 was to provide ofif-line programming services 
within the framework of the Automated Manufacturing Research Facility (AMRF). For exam- 
ple, ARTCI allowed the user to select operations for the AMRF Horizontal Workstation from 
pre-defined menus. After all operations were selected, command data files for all levels of the 
control hierarchy were created and then transfered to the workstation controller by means of the 
AMPLE Communication (AComm) module. 

By mid-1988 the main focus of our effort wzis shifted to the Quality in Automation (QIA) 
project. Even though QIA would make use of the oS’-line programming capabilities of AMPLE 
/16/, two decisions were made which significantly changed the character of the AMPLE Core 
Interpreter (amcore). First, it was decided that the AMPLE platform in the QIA environment 
would be an MS-DOS^ AT-class personal computer. This decision had two immediate conse- 
quences: (i) such modules as the Animation Package would be very difficult or impossible to 
transport to the new platform, and (ii) familiar Unix multiprocessing commands, which had 
been used to good effect in Version 0.1, would no longer be available. Second, it was decided that 
amcore would have to provide hard real-time services. Specifically, amcore had to be able to 
produce values which were not only correct in an abstract mathematical sense, but which were 
also timely enough to be of pr£w:tic€d use to em external system. The second decision forced us 
to abeindon the view that amcore could be defined as a conservative extension of any existing 
Lisp dialect. The difficulty is that all Lisp dialects, and all interpretive systems, need on occzision 
to reclaim memory, a process ceilled garbage collection. Depending upon the algorithm chosen 
for this purpose, garbage collection for MS-DOS AT-class computers can take 500 ms or more, 
which is of little or no importeince to the off-line programmer, but which can have devastating 
effects in real-time processing. Clearly, to develop an AMPLE prototype for the QIA project, we 
would have build a Lisp interpreter with some exotic capabilities, and to do this we would need 
access to the source code in which the interpreter itself weis implemented. 

By late 1988, I was busily reviewing those Lisp interpreters for the AT class MS-DOS ma- 
chines for which public domain source code was available. The short list of candidate system 
included the XLISP 1.7 system of David Betz, of which I had already obtained a copy^. After 

^Commercial equipment, instruments, or materials are identified in tliis report in order to specify adequately 
certain experimental procedures. In no case does such identification imply recommendation or endorsement by 
the National Institute of Standards and Technology, nor does it imply that the material or equipment identified is 
necessarily the best available for the purpose. 

^Unix is a trademark of Bell Laboratories. 

‘MS-DOS is a registered trademark of Microsoft Corporation. 

‘XLISP 1.7 was implemented in the C programming language. Bets distributed XLISP 1.7 and its source code 
very widely. The distributed material has been copyrighted by Betz, and all rights reserved. The copyright notice 
in /2/ also states that Bets grants permission ‘^or unrestricted non-commercial use.* 


iii 


several weeks of discussion with Scott Staley (then of the University of Miami), we both con- 
cluded that this system would be an execellent starting point for our work. One limitation which 
demanded our immediate attention was the need to stay within the MS-DOS 640K upper bound 
on usable memory. Since a substantial run-time stack would be needed for recursion, and since 
several modules would normally be loaded into amcore at the same time, I thought that the 
amcore executable code would have to be no more 250 Kbytes, and preferrably much smaller. 
This meant that we would have to be absolutely ruthless in eliminating from XLISP all functions 
except those which were absolutely essential. We succeeded in doing this by reducing XLISP 
to those functions which are available in almost all Lisp dialects. In fact, the remaining set of 
functions W8is just about the same as that provided in the original dialect of Lisp, called LISP 
1.5 /1 3/. The next phase was to develop those new capabilities which would be needed for the 
system to be a useful prototype of the AMPLE Core Interpreter, Version 1.0. By the Fall of 1988, 
Staley extended the arithmetic of XLISP 1.7 by adding complex numbers, described in Section 
15. By mid-summer of 1989, I added the textport and graphic viewport functions, described in 
Section 18. The primitive amcore functions needed to support real-time processing are being 
developed and will be introduced in subsequent publications. 

Getting Started. Amcore Version 1.0 has been implemented in Microsoft C 5.0 and will run 
on MS-DOS AT-class personal computers. An EGA graphics adaptor is also recommended. The 
distribution disk contains two executable progreims AMCQRE.EXE and AMC0RE1M.EXE. If your com- 
puter has an 80x87 floating point coprocessor, then use AMCQRE.EXE, otherwise, use AMC0REM.EXE. 
To start the interpreter, key in amcore (or amcorem) to the MS-DOS prompt. Once you see the 
amcore prompt (>), the command 

> (load "tutor. Isp”) 

will begin a tutorial session. Follow the navigation rules on the bottom line of the screen. This 
command will not only give you access to the tutorial material, but will also allow you to access 
HELP files. Please remember that this system is a working prototype and that it is subject to 
change and revision without prior notification. 

How to Stop. To exit the Interpreter and to return to the operating system, you may either 
execute the exit command: 

>(exit) 

or enter the CTRLrZ key chord. 

Preparing Programs. The Core Interpreter may be thought of as the boiler room of the 
AMPLE system: it hets been specifically designed to be as compact and efficient as possible. 
Such programming tools as a syntax-directed editor and a workspace manager are now in final 
development and will be released as AMPLE modules. Until these modules are generally available, 
the most direct way to program this system is to use a text editor to prepare an ASCII file, that 
is, a file without embedded control chwacters, and then to load the file into the interpreter. 
Progreun files we hamdled in the same way as was the file TUTOR. LSP which was itself prepared 
by using a text editor. The effect of loading a program file is identical to keying the same 
programs into the interpreter directly. Comments begin with a semicolon character and continue 
to the end of the line. Since the interpreter treats commented characters as whitespace, they 


IV 


may be placed wherever a blank character would be legal 


How to Use This Guide. This document is being released as a companion to the AMPLE 
Core Interpreter. I assume throughout that the reader is simultaneously interacting with the 
Core Interpreter itself. The primary purpose of the User’s Guide is to allow the reader to get 
comfortable with the interpreter and ultimately to develop that confidence which comes from 
being able to correctly predict the behavior of a complicated system. The first five sections 
present a general overview of AMPLE. The remaining sections introduce the reader to all of the 
functions which are available in the Core Interpreter. Each of these sections has the same basic 
plan: a brief explanation of the section’s main topic; a list of the section’s functions, grouped 
according to similarity; and then a discussion session with transcripts of actual interactions with 
the Core Interpreter. Because only a few functions can be discussed in detail, the final section is 
am Appendix which provides a brief description of all of the functions mentioned in this report, 
listed in alphabetic order. 

More Information. For further information or for a copy of the AMPLE Core Interpreter, 
pleeise write to: 

J.C. Boudreaux 

Center for Manufacturing Engineering 

National Institute of Standards and Technology 

Bldg. 233, Room A-107 

Geiithersburg MD 20899 

tel (301)975-3560 

FAX (301)417-0514 


V 



-r% ■ u ^thmm -n This page intentionally blank, il^ “ 

)- im wmI.: * 1: *:, . ^ 

.it , i.i' ^-J 01,; .'mime ii>-* • V* - tcv »;aD^ 

•*?n ^ ' 

■ ijr*- - -/n . ._ 'i’' 


yj^r, ,i(cru> ejtlJ «iri MO tJ?«P, »•«♦.. , 

.lun • iorci krta uv.»I fci,T,^ 4 J 

o **.] ih ; J| . .^aori 3 iM ‘1 J 2 >, 

^ai nf 'Situ. . , _ 



*^i’: 


I.'i I ' enisv^^f^Wi -iT-W " 

WV<''n '.'a. Tl'v vih^feW'' ^;«*'i.i 

-^r-. low) »' .I^..:f'<. 4 w^^ n:* VviJ # 9 ^^ . ,,i®' . ; 

>tq 7 ,v?al »^€k.I anii )c, * «©5 rr, 

•CT ....^i:, V, 4 iv:a.UM»:fei - '. ■■">- JSAftii^WO*. 

'. ■* A''f*«d.iti«' i ^^ia';;»u^»«!lr*.. i^a!. 'I 

• f.’.nv ■:. » •',,'^ ■■■.t?»,:t?'-'-.'"- t'"*' '■■■.'sv-- 3 »-lt^.bi«t V»ro»j*.vajJi* 

"■^' ^ . na5&^!,0«fS^ 

' / ■/■■■.■■'■"'■'■ •>i'aodU'(i 0 ei'. 5 l^' 

., , ■•■• ■ ^ \ 

|>>»|' ,' U ‘ ■ l‘'i' !ti^',Jll^tf .Ult« •> 

!" '■>■ > 3 UVtt yv'''‘',AiC’', ,*y ' r ,:. ■ V'S' 4 a*r’.|«a i^k ai^; . tltow,’ _ ■ _ __ '^"' _ 

'4 ,4laU'' '; »'•••. 1. - -t* y i Ut fc tWOttojCff^ i’',r.f,+r wpc!! '(.yt , « ijl; 




\ j). a'vi, , C-Ji 

• r I * 1 '' 


t4M ** <»4'Mf«i>^ 7 w*<i/* . ► V .-.H 


.«■ . '( f • XI t • *.* 0 , . hi ui, 

>'«/• I 

'. 4 riLt % ii T ; - 1 '» ■■ i fkw- 


■u’’ ?,- 




v ' 

■ ,;^d: ■;- 
'^/v."'x 


Sk 


-‘''■*■7 *:. »,.4».«*.a;i j* Um '' ’«m, a \. * 1 ?- CK'Wfi^mK mn^ iJiioaitlr' i^k 

bij' b vwM*' t‘v k >f 


•>* ^ '' ' .t *^4 V ‘ • /^i -*!■« ‘ if*" 'ldr«j'^' 1:: ls>! 


*<•* ^ < ;<* jfv 

,;■ tiuiiF JjMi' 

./ * f V iV.»» «v«it 


O If 


j»* j ^»Te (■'Vl . • ,' 11: tsi'/i' '■’^f' 

; ■' * rhaf' ■ *i - ♦|<-; 

’ ■ 'Vj»i.'' ■ • * tjl t itt> ■ V 

’ .•WMI' ^r’ 't '^ .. ' --iJMif ^ 

Tt, • » tUc • ■ ^ , tfihf' H# ft %j».h • 

i:i - ftH • HWiU -:>*•> 


ife 


I 


VI 

■A^y • 



83 



. ija '. 

*■'' ", -r-i' (“ 

''\: 



Table of Contents 


1. Introduction 1 

2. Defining FMS Workstations 3 

3. Requirements for a Programming Language 

Environment 5 

4. AMPLE Architecture 7 

6. The AMPLE Core Interpreter 9 

6. The Model of Computation 11 

7. Elxpressions 15 

8. Symbols 19 

9. Lists 25 

10. Cond Expressions 29 

11. Prog Expressions 31 

12. Iteration Expressions 33 

13. Arrays 37 

14. Strings 39 

15. Numbers 41 

16. Objects 45 

17. Streams 49 

18. Textport and Viewport Functions 63 

19. System Functions 67 

20. Debugging Support Functions 69 

I. References 63 

II. Alphabetic List of amcore Functions .... 65 

vii 


ft 




.A. 




This page intentionally blank. 




■» ^ 'f 


• * , ' ' '^y.i • 

' '’v#' 

■V . . .A 




■ ■* 
.' 't « 




t ■ . — V . , , . t'> , V ■ '^11 1 43 




a 

V 

« 

ft 




s - .iiu 

a. V ; : (k ~ 


ifV 


'if 


,'•. . .(i-t . f a*s«3, '.ttTJtA Jtjff '.I 

. -wJ ^ I f ^ 1 ; . * "j *. * i '.^ '4 






I 


'vi:, 

V '-’’ : / ■ ■ ■ 

' ’ ■'' ■■- \i,'l ’■ - ' 


• ,. , . a , . . , ,,u . ^ '"'Oil 




•w • T f k 






Tr' 




. .A . 


I • . ■ ' t r 


a€ 

ti. 


, ' d' 

■t s ' ,1 ,»►»*«< ■' ' H jjA tTjiJ'Si'.- 


>ii'^ 


<* I fi* 


at- 


d/ * .* 




ji .. . -^.■, 




u 

ta 


• f » *, « 

V ■ 

V 


.... ...... 














t 


'•‘•AM ( - ; ‘ roMjKi/ya. 


$ ' lAi 


■♦• • p «•*(»*• 






ly 


I Vlll 





1 Introduction 


• The Automated Manufacturing Programming Language Environment [AMPLE) sys- 
tem is a global programming language which was developed with the Center for 
Manufacturing Engineering of the U.S. National Institute of Standards and Tech- 
nology (formerly the National Bureau of Standards). AMPLE was designed to 
provide 

— a uniform programming language environment for the construction of control 
interfaces to industrial manufacturing processes, and 

— an integrated system of software tools for translating product design and pro- 
cess planning specifications into workstation and equipment-level control pro- 
grams. 

• The initial design of AMPLE was based upon an analysis of the requirements of 
flexible manufacturing systems (FMS). This category of systems includes manufac- 
turing systems whose resident capital equipment is 

— programmable, 

— rapidly reconfigurible to produce a wide spectrum of industrial products, and 

— designed to require infrequent operator intervention under normal conditions. 


1 


This page intentionally blank. ' uohtXJhonitll ^ 

''■■■■ ■ ■ ■■ '■■•" ' ^4. # 

"v* tnamfl'jV*un3 

lol ^ AHw baqoiAV(*b saw iJbM'w i^7<} si „ 

-ii.^'^' Lu\» nbviboAQ ^ pJHJiJwij .2.U mb >0 iClibfnis’ii 

\J ?c*w .(‘jbMbod;? % irjioiwH la*tt)r45Vlj( " ' -- *- > 


.... "i'r 

«'vriivC‘.'> 1c> noii ';ala/)LW3 loV <>|UugMi 

MUt a«ha^-ustaiifl^ i>) 


.. — ^ ’-Wt- w . — »*■•<» trisrv^j|i5'^w^*.k 

-c\q ioi.»Pv>3 f9V9l4ni>A'^£'^ bcwii -o^al sw 






lo «la«>nKd':mps)‘i 
• jj^lnnAra !sbf»! 


‘imp-i)*-! ftifU Vj -iUi -iMiafid' 

■iu ..‘'TaiTi«|ijtrps afli 


tr!.8 .ftJ^^^J‘lr^v -rr ^^iT.tSul-ol Jo /fflrt^aiKy* rrMw ’« 

*Tl 

.eaoii;bn^'r> Lirijon i^Enu QQjbTavT;a.t 


'S 







2 Defining FMS Workstations 


• FMS workstations are configurations of devices, and devices are distributed net- 
works of controllers which can be commanded to perform specific manufacturing 
operations. Devices include such equipment as 

— numerically controlled (NC) machines, 

— programmable fixtures and other specialized workholding devices, 

— machine tools and tool-changing devices, 

— robots, 

— automated vehicles, and 

— material-handling devices. 

• FMS workstations are multi-language environments. There are many controller- 
level languages: APT (ANSI X3. 37-1977), NC machine code (EIA RS-274-D), re- 
cently proposed standard languages for programmable controllers (IEC/SC65A/67), 
and many vendor-specific languages, especially for robotic control. There are also 
many language-like formalisms for encoding inspection plans (DMIS), part design 
and specification data (IGES, PDES, STEP, EDIF), and other data elements needed 
for automated manufacturing. 

• FMS workstations axe equipped to monitor their own operating states and have 
the ability to adapt to changes in their operating environment. The need for self- 
monitoring, especially in the context of adaptive error-recovery, presupposes that 
FMS workstations are configured with sensors. 


3 


?• t . 


t . 1 




■J ' 

This page intentionally blank. V/ 8M"« gflJttasa 

r: 

,Jtu. >ij: •?■ ;/4b l/.*T lo ♦ si; 

^ '* !-’»;« . iMMT.v ■ .7,- h^bft-r.m.TRoa >6 JUR'vilaMw a'l'^lfp^ijKoa 

■■:£ ■;-' ••r^.4.:!j[.‘/ sbi.ibcj 

'■ ' ■ ■ 'i':,’' ,,>■■* ' ■ 

'■ ' ■' '' '*■■.. .'^V' '^v" 

-■■■•■•■ ' . I.'' .V'-' ..V rjQ^,l»ry^'ii- V'' »Jdj8c;:jO?u^pT*^ 

r rs^ijivvb bitiii /- ■' i^'‘> 

■ -(Sjixsdqi >??*:. 

♦ayibl/fov # '“' : 

} ' ’ . j v't ' 

'. •■ ;. v‘):> isd f , ,«:*,(SiZ':,f' 

>■ ' ^'>..^1 Ai-" ' e.^o'': T*IA m^iit’2^41 

■ Cd: ' \ r ' '■>. 1.) t '»'•!..• . , V, 

' OT • « to.' » .'■yilnA'rJi ' ,i x«>^b<ur< ';v,^ 

■/.ii >• .'lus' . ,^*3.il*l ,R30r/ |[ii>Jiii3>i'b5»q9 

. sit» imi ^dEt’ibdijtmqJ h ii.' 


,-5f ' ''-T’j'*. I ■‘r C-'i vJiii , t -fe^.v'- 4:; •-{ J■'^Ath^i. <j4 

f/i’) ' - I. /v^ijrroj ‘.)ili ni 

v: ;-.Of!,dli-i»' Kj i*iMk 


f 



. ■« r' ‘ 


^4 


3 Requirements for a programming language enviromnment 

• Reliability. Every programming language environment (pie) must be a system 
which can be used a reliable assistant. Every pie must be able to carry out 
elementary operations with little or no operator assitance, and must be able to un- 
dertake more complicated operations if given appropriate step-by-step instructions. 

• Portability. Programs must be portable between similarly configured FMS work- 
stations. 

• Service modalities. Every reasonable pie must provide both off-line and real- 
time services. 

• Device abstraction. To insulate the programmer from device-dependent prop- 
erties of the controllers, every pie must be based on an abstract or generic model 
of manufacturing devices and processes. Specific devices should be represented 
as instances of abstract typedefs^ which group devices into classes based on their 
components, the operations or motions that can be performed, and their operating 
states. 

• Code generation. Since FMS workstations are multilingual and each controller 
needs to be addressed in its own native language, every pie must supply a very- 
high-level code generation facility which translates high-level commands into the 
controller’s native language. Code generation has two stages: 

1. build a library of program templates by inserting parameters within fragments 
of control programs, 

2. generate application programs by gluing templates together and then uniformly 
replacing the embedded paxameters with appropriate values. 


5 






‘iX y '^TiUa^liVLlt^ This page intentionally blink. ^ 

i7Tjitcv,t *; "■< .'itkii f'?fq) M AVtiSonlyrri* •• j 

Jt/o ' 1 • ,!)d JiiiKin alq 

-.fl4j c.< ^<<1 .'L*nfl5 b«3 ,a3n;jBlta8j0 ^ io s>lS#lf tfiiw artoi^Jil^qo x;tJ&il/i&ii£aFl®*' 

.AiioiJ q^la-yd ^^8 el^iiqoiqqA Jl&vf^ It 8HO»JJ»5^qd 

-/Iiow bM^. h®•^oJ^^^/lo-1" ^llrtl^lfi^j^;,f^^ :xl 





Mftin hcuj d/cd abiwoiicj suim slstiiiCiOiwd^ .»9WiIshQjj* 


!‘'ii' , 


-qoiq Jcuixwqab-riiY&b rwot) 'OT? 

• l!#J)0,ca tut hO aatltijt-’ 

bdlMuyiqdt s(f JilWc 

iwdJ no b8esd-»sB6!,> <4fti qtm^ xbixi^ 

ui^d} rjw ,bf3im6hii4^nd 

■ '■ /’ 

r*Mi.S)fxo3 dj-sa' i»|.o ■.g-M'Sl 

-(: .V 6 'fldiiue'^imm 9fq[ iSiSjaagnjal 'SVil^ft nwo «^i ni 

rrfj o.: d ai>f-i^£!tnrr?3 |*ry^I-d..gid 

■■:es>%J!‘i ow,r &sii noi^t5lto^'*6o&' 


’' “ . ^ . . . 7' ‘ ’ %'■ 


. ^iwxsQiq, w«Qy^, 


I . . . ■ ■> . ■ ,.’V ; ■'■ ^ ^ 

f '.inolin. t rr.- l.} bun i® ■ i 8s.U!qaiSvf ^iluf^ xd 

?o{dsv s4iaq^i».;qj» dJin »£li 




■SWi 


■...i 




;; ;4.' 






.■jy<ir.->'- ^».- . 


^’la 'S • ■/;;, 








A yitST^k 

^ ■ , ¥'^IS^ 

;.r'V'i^|i 




■ ^'■' 




/'■•f 






- <i 











4 AMPLE Architecture 


• AMPLE consists of a central kernel, or core, around which is a loosely confederated 
bundle of software modules. 

• Each module is a collection of symbols whose meaning is established by a legal 
AMPLE program. This program may reference symbols which are supplied in 
AMPLE core or which have been defined within other modules. The set of modules 
in terms of which the meaning of a symbol is defined is called the environment, or 
symbolic frame, of the symbol. 

• Some modules are very general and supply functions which are very commonly 
used. These modules are called core support modules. Other modules are tailored 
to specific application areas and have a narrower scope. 

• This architecture has two consequences: first, AMPLE must contain explicit mech- 
anisms for the definition of interfaces between each module and the core, and also 
between several modules; and second, AMPLE must be based on a clear and concise 
model of computation. 


7 


:‘.r I 






' . »<f Vr. 








This page intentionally blank. i 

si'’'.' '■; 








yUiwxjl A ai rfrtfilw brtt.'f'itt ,ait 05 to tttsi^a n 


, , . , ' 'V^*«if 1,^ , 

Ugs; A V'S b9rinii4-<<cla»_ fti\ "16 ,<K)iii3ib5':.4' 

;:i £»il<iuu2 .^tff dvirlv/ bWmy.B 

T?!i;bo,<r lo , Rtfhhom ■tsrfio 'rtiiitlW: bmtShb wsd to ^ 




10 :^ni)mooirjj?a arii halljs.' sh bm,M tn Mwxs ^ ^ saijiliscat oxtJ irf 

''' ■ ■ ■' .' ' ■'■' ' - ; 'v,-® ■J?f'''*:'^.. ^ 

XIiicitm:or» tt^v mj Mfiyf 

t»i;>ialj;ii4 et;;' «fiUii>*>iDtt <.afk'hEHT« 4‘»O^qu*,,»1r0(5: ^ 

,^^<•>.0^e 'tiswoTUis 

1 . . , y - 'i^ ~ ' ' ' T* '' ” 

-rbftcu HaHqjca (^ 

•.^^U bf.'v<ato 3 5 ir{l hin> Hohom 
•>3iano3 Litii i4alOJs a^' baj»saf 




.,/■ 






,i ' ■: . 'I ‘ ‘ ’■' J 






■ ..v 

. . : uJr. ' 


j;;;, 


! i ' fm 




' ‘ « ■■ • . S'- ■>, ■' 

■r ^!i 4 'w ..4 


■>. 


c% 




:-^'. -, ft} <,■■■. .:■ 


■ :.'i" . ■' 


•, '■, I'-. '..Xs 






\r 


mm 




WM 







mki 



5 


The AMPLE Core Interpreter 


• AMPLE core (amcore) is a Lisp dialect which is a small subset of Common Lisp, 
adapted to the specific requirements of automated manufacturing. Amcore is a 
set of functions, whose meaning is defined in terms of an explicit model of compu- 
tation. This model is approximated by an interactive program, called the amcore 
interpreter. The Version 1.0 prototype of the amcore interpreter wa.s derived from 
Betz’s XLISP 1.7 /!/, /2/. 

• Though several paradigms could have guided the design of amcore, Lisp Wcls chosen 
for the following reasons: 

— structural simplicity, that is, every Lisp expression consist of an atomic 
value or is the result of a function being applied to its arguments. 

— extensiblity, that is, primitive functions introduced in amcore and functions 
which are constructed have precisely the same standing. 

• In addition to primitive functions which constitute a small subset of Common Lisp, 
amcore includes textport functions for interactive text windows and graphic view- 
port functions as well as object-oriented programming capabilites inherited from 
XLISP. 

• Because of the real-time requirements, amcore also includes a collection of func- 
tions which define a real-time processor. These functions are not documented in 
this report. 


9 






Aj—i jiiii ‘‘V.* . 




0 

.c ^ 




iiv/'V:; 


This page intentionally blank.'^t^Oj A MK 

«. - M:'-» ■ "H « -,-V :: '* 

'■.'al.'' lo ivJilK tifcOUi « I' iJiri'^y l‘/4Jr,{»T£t:>fe«]/A'tOO^^*-tl’A^ ,V,.'#| 

lo lahofjA li,.>'Ki.iu> Kijf to'iitttfii'l >ti l.vi*i(?l®'b 41 3eii^wS':Slipi^^'j«hai;li^)T(i/l 


'■-:>>) ft'.vih MW a«iv;.'^/rf|3 Ifi b-'l V^Pil^K 

;‘,^ '"; AsVa^ 


'M ".i 


•a 




. , '' . ' ..V ^ ffi.’ - 

>!tl 035 US lo i 8 i!|II©a j'A/fl'' 

-«ju > sijrti 4 » 9 *%;e 


~' ^ S ' -t' -fjf ^ .. '• •?•' •^, ' ' 

HflOf.lr.iTul f'-'-’A ni 


. 3 f^ry''.s 


,kC 


■; 


. :3«#t ’., •'» p- umrO lo id^..:fi)8 '^^‘8^wtihr«^J;J> sb;ifw bv'iiiiuh^ m itofJiljfcii 

■•■Il' f; -tfqiJT^ bn^ nw^Mw jy-il a;V!i.t>«v,’irti yOl-.i^'abflbflbl 

•\^r% i I • . r«4!vA/4.tta i ^ » I- -1^ ^ *1. '• ... .<> p. -% k. / '‘'---';44B^ 






/lUM' 


'p.,’' ‘.kti.ij^l/' ,*. 1 - w cvlf. .'TfWiita 


tMi 


A) ^ 




I' *’•#:! 


‘•wia 




' .•r-.‘ : 


iVS'-- ■ 1 '! i/' 






i'.. 


^■. ;■ ■ -il i/rfSl 


'S'^' 







JftS 




' '^T.k 


d 10 


BJsJH' • fV 

**. J ^4 klUrfJdL 

i/' * 


The Model of Computation 

The AMPLE Core Interpreter is a read-eval-print loop. 

The reader returns the next AMPLE expression from the designated input stream. 
This expression is assembled character at a time under the control of a data struc- 
ture called the readtable. 

Once an expression has been read, it is then evaluated: 

1. If the expression is a list, then eval applies the first member of the expression, 
which is the function, to the remaining members of the expression, which are 
the arguments. 

2. In most cases, functions are applied to the values returned by evaling the 
argument expressions. If the function is a special form, then the argument 
expressions are passed without prior evaluation. 

3. If the expression is a non-list, or atom, then it evaluates to itself. 

The returned value is then printed to the designated output stream. 


A: 


eval 


apply quote 


backquote fimction 


Discussion 


6(A): The normal operation of the reader may be modified by inserting read macros in the 
input stream: 


’ <expr> 

is 

(quote <expr>) 

' <expr> 

is 

(backquote <expr>) 

, <expr> 

is 

(comma <expr>) 

,0<expr> 

is 

(comma-at <expr>) 


The quote and backquote functions are used to prevent the evaluation of their arguments, that 
is, the value of a quoted or backquoted expression is the expression itself. Within the context of 
a backquoted expression it is possible to invoke 6Val by using the comma or the comma-at 
construction. 


> (quote (1 2 3)) 

(1 2 3) 

> ’(123) ;using the QUOTE read macro 

(1 2 3) 

> (backquote (1 2 3)) 

(1 2 3) 

> '(123) ; using the BACKQUOTE read macro 

(1 2 3) 


> (setq ace ’(66 78)) ; QUOTE here prevents evaluation of 

(66 78) 


> (backquote (1 2 
(1 2 (66 78)) 
>‘(12 ,ace) 

(1 2 (66 78)) 

> (backquote (1 2 
(1 2 66 78) 
>•(12 .Cace) 

(1 2 66 78) 


(comma ace))) 

'.using the COMMA read macro 
(comma-at ace))) 

: using the COMMA-AT read macro 


(66 78) 


Another family of read macros is signaled by the occurrence of the hash mark in the input stream. 
The hash mark signals the reader that special handling will be required to build the expression 
and that the precise nature of the special handling is specified by the next character. 


# ‘ <expr> 

is 

(function <expr>) 

#(<expr> . . . ) 

is 

an array of the expressions 

#x<hdigit8> 

is 

a hexadecimal number 

#o<odigitB> 

is 

an octal number 

#C (<real><imag>) 

is 

a complex number 

#\<char> 

is 

the ASCII code of <char> 


12 


The macro #’ abbreviates the function function, which is used in place of quote to apply to 
functional expressions. The value returned is a function closure. An error is returned if the 
argument expression is not a function. 

> (function 2) 

error: not a function - 2 

> (function (+ 1 2)) 

error: not a function - (+12) 

> (function +) 

#<Subr: #4e47afl8> ; address of compiled code for + in hex 

> #’ + 

#<Subr: #4e47afl8> 

The eval function which defines the operation of amcore may be used in the same manner as 
all other functions. When presented with a single expression, eval returns its value. 


> (eval 2) 

2 

> (eval ’(+ 2 3)) 

6 

> (eval +) 

#<Subr: #4e47afl8> 

The apply function is quite similar to eval, except that apply requires two expressions: an 
expression which designates a function and then the list of arguments to which the function is to 
be applied. 


> (apply sin *(1.0)) 
0.841471 

> (apply +’(123)) 

6 

> (apply eval *((+ 1 2 3))) 
6 


13 




-a 






«J 't(qq> 04 i^QUp to -miq( o> Isiy This page intentionally blank.'^rfj 
^dJ It hairui^ai R^.TjaVw nA t. ai h9awi)^t,Mtk|, 

■■^Trv " -i» ^ 

yo/i pt » -toi *^o ;|>i^« 0 '?' 

'l i,- r*'-'--"’- ■■• •'■ 

M, 4 t- >-i ■- «■*■ - rMt^>rciHli)t»a? 


w\ 




■ ' ' '''‘■' > , "■ ' -. ,J*“"’'' ' 'a-Ai 


> (<ino*» Ci 'i VI 

[1 i ?j 

^ (- ‘it ; 

i * 1 . . '» j p . 

:v . r • 

.* ■> . 1 1 'j '»} } 

f 1 ' J!. ^ ^ 

‘ <t -^ ’^ ' 

V ^ J) 

u» («Aaj/!<.s^r;t |(9 
CM el tii^mv 

> ^Mr* .tiotyi O 7 vCtniSjJr » ;» V 

t,,l. .. /t-u '’o;> 




:-,S i* i 





‘.pr 




4 u,^*K$: frli-ift filfiJOTK WEni'i 


*« •■': ■ **,»*' 5 ! 


im-’ 






■f'. ®'i 554 M 


> r» A 

.*' aA'J ihiJyt oi )o Jyrt I jiSJ* »9l*^ 


-i^v:' 




‘ 1 


^p...>a 5 


JA 


./V^‘, ■ 

'•') , *Uf OCi^U , reiOil, ' / '^‘~ ' g 

•■' ''•. i) .. ', ' ■' '''’ ' , (to*"!)* stis^ 

V-'A -;,.... ■ ■ . ' i, (cOfci«a-«t «<!'*!r})l, A". ^ # ,: It 

' • ^'- ’A'- 

? vft> , ; ■' •■ ■ (<<«■« i 

_ , v ;v^ 

'■ I ’--ij t nV4^^'|||l^|<!bAU^ V),y %%0r ‘Xirr-»4i^^'l>f 
♦♦♦'■I »h«) #'H‘'tinf oNt-., 

f .<^^> ^ ''«>i «rTli^ ^ 

^ji«pMij •. I lb isn^4- i««-{ ' *a ■\/' ';''‘’-i^^S'^ 

^i«.* •^ ■ •'•■ft o 4 «' ‘ .i«i. 4 t»itr 

-- - ■ • ♦■ r* .. ' ,, 











’.♦i# it 


:' 14 


•r .V ." i Aii 



7 Expressions 


• Everything is an expression. 

• Legal AMPLE expressions include: 


characters 

strings 

symbols 

numbers 

lists 

arrays 

streams 


ASCII character set 
” a string ” 

ace a_long_symbol **a!!? 

1 23.45 7.89e-07 #C(1.2 3.98) 

(1 2 3 4) 

#(0 2 3 89 "this is ok") 
files 


• The following expressions are lists with special significance to the eval function: 


function expressions 
applicative expressions 
prog expressions 
cond expressions 
iteration expressions 
object expressions 


A: 

type-of 

atom symbolp numberp complexp listp consp 

B: 

eq eql 

equal 

C: 

lauabda 


D: 

length 



15 


Discussion 


7(A): The function type-of returns the type to which the value of the argument expression 
belongs. The remaining functions in this group are type predicates, that is, atom returns T 
(true) if applied to an atomic entity and nU (false) if applied to a list, and so on. 


> (type-of " a string ") 
: STRING 


> (type-of 
: SYMBOL 

> (type-of 
:FIXNUM 

> (type-of 
rFLONUM 

> (type-of 
:FL0NUM 

> (type-of 
: COMPLEX 


’ace) 

1 ) 

23.45) 
7.89e-07) 
#C(1.2 3.98)) 


> (type-of ’(123 4)) 

:C0NS 

> (type-of #(0 2 3 89 ”th.is is ok”)) 
: ARRAY 


7(B): Each of the functions in this group introduces a different equality predicate. The function 
equal returns T if and only if its arguments evaluate to equivalent values. The function eq returns 
T if and only if its arguments are identical, that is, if and only if both argument expressions point 
to one and the same stored entity. The function eql returns T if and only if its arguments are 
eq, or they are numbers of the same type, cheiracters, or strings that designate the same value. 


> (equal 4 4) 
T 

> (eq 4 4) 

NIL 

> (eql 4 4) 

T 

> (setq a 4) 

4 

> (setq b a) 

4 

> (eq a b) 

T 


7(C): The lambda function, when applied to a list of expressions called formal parameters, and a 
sequence of expressions called the lambda body, returns a function closure. When presented with 
a list whose head is such a function closure, eval evaluates all of the remaining members of the 


16 


tail of the list, binds these values to the formal parameters, and then evaluates each expression in 
the lambda body vv^ithin this new environment. After the body has been completely evaluated, 
the formal parameters are unbound and removed from the environment. The value of the last 
evaluated expression in the lambda body is returned as the value of the entire expression. 


> (lambda (x) (♦ x x)) 

((LAMBDA (X) (♦ X X))) 

> ((lambda (x) (* x x)) 6) 

26 

> ((lambda (x) (* x x x)) 5) 

125 

> ((lambda (x y) (+ x y)) 6 7) 

13 

The formal parameter list may be resolved into three distinct blocks of parameters, any one of 
which may be empty. The first block consists of the list of all required parameters. When a lambda 
expression is applied to an argument list, there must be at lezist Bls many arguments as there are 
required parameters. The parameters are bound to the arguments in left-to-right order. The 
second block consists of the list of optional parameters, beginning with the keyword (^optional. 
If this block is present, then after all of the required parameters have been processed, the optional 
peirameters are bound to the arguments in left-to-right order. If no arguments remain, then the 
unprocessed optional parameters are bound to nil. The third block begins with the keyword 
Arrest which must be followed by a single parameter. If this block is present, then after all 
required and optional parameters have been processed, the single rest parameter is bound to the 
list of all remeiining arguments. If there are no remaining arguments, the rest parameter is bound 
to nil. 


> ((lambda (x ^optional y) 
2> (cond (y (+ x y)) 

3> (t x))) 

1 > 1 2 ) 

3 


y is not nil, retnm x + y: 
; otherwise, retnm x. 

;the argument list 
;the value returned 


> ((lambda (x ^optional y) 
2> (cond (y (+ x y) 

4> ) 

3> (t x))) 

1 > 1 ) 

1 


> ((lambda (x frrest end) 

2> (cond (end (cons x end)) 
3> (t x))) 

1> 1 2 3 4 5 6 7) 

(1 2 3 4 5 6 7) 


:if end is not nil, return the argument list 
: otherwise . 

Ithe argument list 
;the value returned 


> ((lambda (x JO-est end) 


17 


2> (cond (end (cons x end)) 
3> (t x))) 

1 > 1 ) 

1 


7(D); Some amcore entities have length and others do not. The entities with length are lists, 
arrays, and strings. 

> (length ’(1 2 3 4)) 

4 

> (length '#(0 2 3 89 "this is ok")) 

6 

> (length " a string ") 

12 

> (length 5) 

error: bad argument type - 5 


18 


8 Symbols 


• Symbols are unempty sequences of characters. Symbol names can consist of any 
sequence of non-blank printable characters except: 

Uppercase and lowercase characters are not distinguished within symbol names. 

• Every symbol may have a binding, a property list, or both. 

• An amcore environment is the list of every available symbol together with its 
associated binding and/or property list. 


A: 

set setq setf 


B: 

defxin defmacro 


C: 

getprop putprop remprop 

assoc 

D: 

symbol-name symbol-value 

symbol-plist 

E: 

boundp hash gensym intern make-symbol 


19 


Discussion 


8(A): Three functions are used to assign values to symbols. The function set evaluates its 
arguments, which means that its first argument, a symbol, must be quoted. The functions setq 
and setf are both special forms, which means that their arguments are passed without being 
evaluated. The first argument of setq must be a symbol. The first argument of setf may be any 
legal place, that is, not only a symbol but also other more complicated expressions. All three 
assignment functions obtain the value to be assigned by evaluating the second argument. 


> (set 'ace 45.67) 

45.67 

> ace 
45.67 

> (setq beta ‘ (1 2)) 

(1 2 ) 

> beta 

(1 2 ) 

> (setf (car beta) ’(4 6)) 
(4 5) 

> beta 
((4 5) 2) 

> (setf (cdr beta) ’(6 7)) 
(6 7) 

> beta 

((4 5) 6 7) 


8(B): The construction of user-defined functions is accomplished by the special form defun. 
The formed parameter list of defun has exactly the same structure as that which heis already 
been described for the lambda function. Note that the effect of evaluating defun is to bind 
the function symbol to a function closure. 


> (defun square (x) (* x x)) 
SQUARE 

> square 

((LAMBDA (X) (♦ X X))) 

> (square 4) 

16 


The next session shows one method for interpreting list objects as sets. In order to be a valid 
interpretation of sets, the functions must ignore both the relative order of the elements and the 
presence of any number of duplicate elements. This example introduces the recursive style of 
progrtimming in which the definition of the function contains an explicit or implicit reference to 
the function being defined. 


20 


> (deluji memberset (x y) 

1> (cond 

2> ((null y) nil) 

2> ((equalset x (car y)) t) 

2> (t (memberset x (cdr y))))) 

MEMBERSET 

> 

> (delun equalset (x y) 

1> (cond 

2> ((eind (atom x) (atom y)) (equal x y)) 

2> ((ajid (listp x)(listp y)) 

3> (ajid (subset x y) (subset y x))) 

2> (t nil))) 

EQUALSET 

> 

> (deiun subset (x y) 

1> (cond 

2> ((and (null x) (null y)) t) 

2> ((null x) t) 

2> ((null y) nil) 

2> ((memberset (car x) y) (subset (cdr x) y)) 

2> (t nil))) 

SUBSET 

> 

> (memberset 1 ’(2312)) 

T 

> (memberset B ’(2312)) 

NIL 

> (equalset ’((1 2) (3 4)) ’((433) (1 2 2) (2 1 1 1))) 
T 

> (equalset nil nil) 

T 


Functions in amcore are treated in much the same way as other types of entities: they can 
be stored in data structures, peissed as arguments, 2ind returned as results. Functions whose 
arguments explicitly admit functions as arguments may be called higher-order functions. 


> (defun twice (loo) ; TWICE is higher order 

1> (lambda (x) (loo (loo x))) ; lambda returns a function closure 

1 > ) 

TWICE 

> twice 

((LAMBDA (X) (FOO (FOO I)))) 


21 


> (twice 1+) 

((LAMBDA (X) (FOO (FOO X))) ((FOO . #<Subr: #43fcadb0>) ) ) 

:the function closure in which FDD is 
; bound to the compiled function 1+ 

> 1 + 

#<Subr: #43fcadbO> 

> ((twice 1+) 4) ;the application of (twice 1+) to 4 

6 : 6 = (1+ (1+ 4)) 


Symbols defined by means of the defmacro special form are called macros. When eval is given 
a list whose head is a macro, the interpretation takes place in two stages. Using the defmacro 
body as a template, the macro is expanded to an expression, which is then evaluated to produce 
the value to be returned. For example, the macro while may be defined in terms of the do 
function, discussed in Section 12; 

> (defmacro while (test fcrest body) 

1> ‘(do 0 

2> ((not .test)) 

2> .fibody)) 

WHILE 

That is, the expression 

(while (< i 10) (setq i (1+ i))) 
would be expanded to 
(do () 

((not (< i 10)) 

(setq i (1+ i)) 

) 

which given some assigned value to i would continue looping so long m i is less than 10. Macros 
constitute a useful but limited tool. For example, macros cannot occur as the first argument of the 
apply function, nor can mew:ros be used to express inherently recursive algorithms. But the fact 
that macro expansion occurs before evaluation, and specifically before the argument expressions 
are evaluated, 2 dso suggests that macros cam on occzision be used to accomplish results which 
functions are simply not able to do: 


> (defmacro nil! (x) 
1> ‘ (setq ,x nil)) 
NIL! 

> (nil! a_new_8ymbol) 
NIL 

> a_new_8ymbol 


22 


NIL 

> (defuji nil! (x) 

1> (setq X nil)) 

NIL! 

> (nil! another_new_symbol) 

error: unbound variable - ANOTHER_NEW_SYMBOL 

8(C): The property list, or plist, of a symbol is a list which contains zero or more entries. Each 
entry consists of a symbol, called the property indicator or key, followed by an expression, called 
the property value. 

> (putprop ’pencil_001 ’mechanical ’type) 

MECHANICAL 

> (putprop ’pencil_001 ’pentel ’mainufacturer) 

PENTEL 

> (putprop ’pencil.OOl 8.99 ’cost) 

8.99 

> (symbol-plist ’pencil_001) 

(COST 8.99 MANUFACTURER PENTEL TYPE MECHANICAL) 

> (getprop ’pencil_001 ’type) 

MECHANICAL 

> (getprop ’pencil.OOl ’manufacturer) 

PENTEL 

> (getprop ’pencil_001 ’cost) 

8.99 

> (remprop ’pencil.OOl ’cost) 

NIL 

> (symbol-plist ’pencil_001) 

(MANUFACTURER PENTEL TYPE MECHANICAL) 

> (putprop ’pencil.OOl 18.99 ’cost) 

18.99 

> (getprop ’pencil_001 ’cost) 

18.99 


An association list, or alist, is a list of pairs. The first member of the pair is called the key and 
the second member is C2illed the value. 


> (setq example ’((name john)(age 32) (job programmer))) 
((NAME JOHN) (AGE 32) (JOB PROGRAMMER)) 

> (assoc ’name example) 

(NAME JOHN) 

> (assoc ’age example) 

(AGE 32) 

> (assoc ‘job example) 

(JOB PROGRAMMER) 


23 




■ • ■ *' 4 , ,;.J 

> (cadr (assoc ’name example)) ' ^ ^ ^ 

JOHN (x), illA 

.K\' .V'. •» WMrcKi iilijx yi 

.tN, r lAj y(tJ0..<rU; ; : Ei.WtH ’ ' 

,^&iJa3K4' TO pi# liT:.H;;<* l«nS. . 

^*' ' 'jCMiMt'8wtevi_i3aj3raMA:/':^«x<^*tw 

^-7 fnKv!» iln-.M#.! hy «inw<* t 

4 wfc.-vjm t'3-*4l m a nvtct*-- f.u' 

;.t^y «t *' 

'M v>i„0 i'.y^. r,’.jTt.:t\. ,#^'< 

^.tt.ion, .^lA^ =r.;. ^ '• . .. ^ ’ " , '■ ;■ 

' !.^'iAaB*''i 6’.-"'^l» ;. ' ' ' • '''^vi ' ■ ■’^''ji^ 'ii ■' - '((j'Sl.i-^V 

■'•■'’ (/' ' •y.fi »«*?!’ ^''siC'^'/.c.'i.'sx^); 

■ (ai:)i»iiin53y' rwr'iafmi 

.. '." ■ 


w; 7 


I'V 


!.l. * , f •■ ■ • '1 


,jafr1i»|:i 


K 


A 


U«) t.M, . » i..i A'; 


■/■' ■" "V" ^ 


I io;> 
’ <1*^' 3J> 


il# " :-<V' ■■ J_-* .'■ 

f ^1 


> '(JHOb* 'SilS 


1 




CitfiWA^ iOO^uxl^^* 




^ :, ■ , r ^,^‘1, 

" • • »■ • -i ■ -•■ ■■».' ='■' v.,,fvk*' ’ ■ ^9 ,'. i(<. j^^ao) 

r ,_. - ■ t ♦ .' ■ ' ■/» -.n * I ‘i{tin(;n^,v,t i., Vfc,,r ^t4$iyi^ 
biJciPfiS' H* •^••* ' - 

tj > ^-.%iiji#**'*i. aliH* fnj(jfr-’if ti<,V ’CTMT liy f/T; 

,' . •’■■■■' ^ ' ■ S' , , ' 

{((rn^'ifli'HtJlotq tfo'tUifJS »«:•»>’ ,»JCq'jdUXir,^J;^'^ 

' . 2 !. O' <Ct epaK 

*Ai##irTt XU' ''iPB9S0 ' (tXflllWrt* iiaiPi* s.v'tt 

■MHW*" ’ C(iX«{ci(X# ‘ 

• .K^^} ns» 

mmF , ■: 

"4ji, ' ■ ' ' ■ ■ "'^■5 

'^' V ■■' ■■ ■ , 24 

iM *%-...4 ..J'j 





I 




9 Lists 


• Lists are entities with heads and tails. The function cons constructs a list entity 
whose head is the first argument and whose tail is the second argument. 

• The function car returns the head of the list, cdr returns the tail of the list. 

• There is one headless list, called nil. Every other list hcis one and only one head. 


A: 

car 

cdr cons 





B: 

nth 

nthcdr list 

append 

reverse 

last 

null 


not 

member subst 

sublis 

remove 



C: 

rpli 

aca rplacd nconc delete 




25 


Discussion 


9(A): The functions car, cdr, and cons are the primitive list-processing functions. 

> (setq a (cons 1 ’(23 4))) 

(1234) 

> (car a) 

1 

> (cdr a) 

(2 3 4) 

> (setq b (cons ’(17) ’((-4 (0))))) 

((17) (-4 (0))) 

> (car b) 

(17) 

> (cdr b) 

((-4 (0))) 

Compositions of up to three car and cdr operations are represented by single functions whose 
names begin with c, end with r, and in between have a sequence of a and d letters. 

> (cadr b) 

(-4 (0)) 

> (caadr b) 

-4 

> (cdadr b) 

((0)) 

When cons is applied to two atomic arguments, the returned value is called a dotted pair. 

> (cons 1 2) 

(1.2) 

> (setq dotted-pair (cons 12)) 

(1 . 2) 

> (cax dotted-pair) 

1 

> (cdr dotted-pair) 

2 

A list may be defined as a dotted pair whose tail is either nil or another list. 

> (cons 1 nil) 

(1) 

> '(1 . nil) 

(1) 

> '(1 . (2 . nil)) 

(1 2) 

> ’(1 . (2 . (3 . nil))) 

(1 2 3) 

> '((1 . nil) . (2 . nil)) 

((1) 2) 


26 


9(C): The functions in this group are used to do surgery on list structures. The structure is 
not copied but is destructively altered. 


> (setq c a) 
( 1234 ) 

> (rplaca a 101) 
(101 234) 


;C points to same value that A points to 


> a 


;A is altered 


(101 234 ) 
> c 


; alteration is visible Irom C 


(101 234 ) 

> (rplacd c ’(102 103 104)) 
(101 102 103 104) 

> c 

(101 102 103 104) 

> a 

(101 102 103 104) 

> (rplaca (cdr a) -202) 
(-202 103 104) 

> a 

(101 -202 103 104) 


> c 


(101 -202 103 104) 

> (rplaca (cddr a) -203) 

(-203 104) 

> a 

(101 -202 -203 104) 

> (rplacd (cdr a) nil) 

(- 202 ) 

> a 

(101 - 202 ) 

The functions nconc and delete eire simileu to append and remove, except that the former 
alter their zu-guments and the latter do not. 

> (append a ’(303 304)) 

(101 -202 303 304) 

> a 

(101 - 202 ) 

> (nconc a ’(303 304)) 

(101 -202 303 304) 

> a 

(101 -202 303 304) 

> c 

(101 -202 303 304) 

> (remove 303 a :test equal) 


27 


(101 -202 304) 

> a 

(101 -202 303 304) 

> (delete 303 a :test equal) 

(101 -202 304) 

> a 

(101 -202 304) 

> c 

(101 -202 304) 

The functions in this class have long been considered problematic and troublesome. Though these 
functions should be used carefully, what appears at first glance to be misbehavior is nothing more 
than a clear message that to understand amcore one needs to be alert to the inherent memory 
structure of lists. 


> (setq case-one (cons (cons T T)(cons T T))) 

((T . T) T . T) 

> (setq case-two ((lambda (x) (cons x x))(cons T T))) 
((T . T) T . T) 

> case-one 

((T . T) T . T) 

> case-two 

((T . T) T . T) 

> (rplaca (car case-one) NIL) 

(NIL . T) 

> case-one 
((NIL . T) T . T) 

> (rplaca (car case-two) NIL) 

(NIL . T) 

> case-two 

((NIL . T) NIL . T) 


28 


10 Cond expressions 

• The primary branching construct is the cond expression, which consists of 

• a list of expressions called cond clauses 

• each of which consists of a test expression, followed by a list of zero or more ex- 
pressions. 

• The evaluator processes each clause in sequence, selecting for further evaluation the 
first clause whose test expression evaluates to a non-nil value. 


A: cond amd or 


29 


Discussion 


10(A): The special form cond is almost always used within function definitions. The function 
new-abs is a simple version of the absolute value function abs, which returns the result of 
multiplying its argument by —1, if the argument is less than 0; otherwise, it returns the original 
number. Notice that the otherwise clause is represented by a clause whose head is the conventional 
non-nil value t, and that this clause is the last argument of cond. 


> (delun new-abs (x) 

1> (cond ((< X 0) (* -1 x)) 
2> (t x)) 

1 > ) 

NEW-ABS 

> (new-abs 1) 

1 

> (new-abs -1) 

1 

> (new-abs 0) 

0 


The following examples show that and and or are special forms whose behavior during evaluation 
is derived from cond. The form and processes its arguments until it encounters a nil value, at 
which point it returns nil without any further evaluation; otherwise, it returns the value of its 
leist argument. The form or processes its arguments until it encounters a non-nil value, at which 
point it returns that value; otherwise, it returns nil. 


> (and (setq a 100)(setq b 101)(setq c 102)) 
102 

> (and (setq d 34) (setq e nil) (setq 1 67)) 
NIL 

> d 
34 

> e 
NIL 

> f 

error: unbound variable - F 

> (or (setq h nil) (setq i 230) (setq j 765)) 
230 

> h 
NIL 

> i 
230 

> 3 

error: unbound variable - J 


30 


11 


Prog expressions 


• The prog expression is used to support the procedural, as opposed to strictly func- 
tional, style of programming. 

• This expression creates an environment within which local variables can be declared 
and referenced, and the primitive goto control method can be used. 


A: 

prog 

prog* go 

return 

B: 

catch 

throw 



31 


Discussion 


11(A): The special form prog allows one to program in the procedural style. The prog form 
creates a small environment of limited duration and scope within which three distinct operations 
may be performed: the declaration and binding of local variables, that is, symbols whose binding 
is limited to the prog body; the use of the return function, which terminates evaluation of the 
prog body and returns a value; and the use of the go function, which causes a transfer of control 
to a tag within the prog body. 


> (delun new-length (L) 

1> (prog (sum) 

2> (setq sum 0) 

2> here 

2> (cond ((atom L) (return sum)) 

3> (t (setq sum (1+ sum)) 

4> (setq L (cdr L)) 

4> (go here))) 

2 > )) 

NEW-LENGTH 

> (new-length nil) 

0 

> (new-length ’(1 2 3)) 

3 

> (new-length ’((((!))))) 

1 


SUM is a local variable 
initialize SUM to 0 
the HERE tag 

ii L is atomic , return SUM 
otherwise , increment SUM 

update L to (cdr L) 
go to HERE tag 


32 


12 Iteration expressions 

• Iteration expressions in amcore provide general mechanisms for performing repet- 
itive calculations. 

• The do special form allows an arbitrary number of loop variables, each of which is 
declared by specifying an initial value and a step function. When the declared end 
condition is met, the iteration terminates and a specified value is returned. 

• The dolist and dotimes special forms evaluate a body of code once for each value 
of a single variable. The form dotimes iterates over a sequence of integers, and 
the form dolist iterates over the elements of a list. 

• Mapping is a type of iteration in which a function is successively applied to pieces 
of one or more sequences. 


A: 

B: 


do do* dotimes dolist 
mapcar mapc maplist mapl 


33 


Discussion 


12(A): Though the iteration expressions are technically unnecessary in the sense that their 
behavior can be easily simulated by prog expressions, explicit iteration makes an important 
contribution to good programming style: 

> (delun new-reverse (L) 

1> (do 

2> ((x L (cdr x)) :x starts at L, updates to (cdr x) 

3> (y nil (cons (car x) y))) :y starts at nil, updates to (cons (car x) y) 

2> ((null x) y)) :WHEN x is nil, return y 

1> iloop body is NIL 

1 > ) 

NEW-REVERSE 

> (new-reverse nil) 

NIL 

> (new-reverse ’(1 2 3)) 

(3 2 1) 

> (new-reverse ’(((1)))) 

((( 1 ))) 

The next function will loop indefinitely, that is, infinite-loop will iterate until it is terminated 
by the CTRL-C key chord. 

> (delun infinite-loop 

1> (do 0 
2> 0 

2> 

2 > ) 

1 > ) 

INFINITE-LOOP 

A more useful variant of this function loops until a key b pressed. 

> (defun loop-until-key-pressed () 

1> (do () ; there are no loop variables 

2> ((kbhit)) :when KBHIT, terminate loop and return NIL 

2> ;the loop body is NIL 

2 > ) 

1 > ) 

LOOP-UNTIL-KEY-PRESSED 

12(B): The use of explicit iteration expressions have tended to make the mapping functions 
less useful them they once were. It should be noted that these functions can still be helpful by 
suggesting places at which amcore code can be par 2 dlelbed. 

> (mapcar *1+ '(1 234 5)) 

(2 3 4 6 6) 

> (mapcar 'sin *(.10 .20 .30 .40 .60 .60 .70)) 


; there are no loop variables 
; there is no loop termination test 
;the loop body is NIL 


34 


(0.0998334 0.198669 0.29552 0.389418 0.479426 0.564642 0.644218) 

> (mapcar ’+ *(12345) *(10 20 30 40 50)) 

(11 22 33 44 55) 

> (mapcar * (lambda (x) (* x x)) *(2468)) 

(4 16 36 64) 

> (maplist *cons * (a b) * (x y)) 

(((A B) X Y) ((B) Y)) 


35 


v-.,;Aa')S 

; - ' '■'Vu.S 







■ (Simo O Rfr This page intentionally blank. 

'i III. '.-K f ■* ir~«^tfr.» ,.',r/' TnjrAlij' 

'-.J V' "' ' V.: /a m 

l> ('t ' \(.l' .;-■ ' :.|u,.,, 

■' Cy • ,U t,' ->' 3 # Uvr .• .4 

(f, ..- ^ .. i ^1 . ■ ■' 'V'.v" ''^.1^^ 


■ M^K f 

f ' ^ ' f" 

li> 

3 


•r*M >'* ',< 


2y ^ ('> i.'l i * 1 

1 '. 


■^,. ’'V. •. 


%rl0, tim, v '^ 


,4 


sf : >, 


’. ■"I'#'. ■■‘.■'M.i* n t, ••,' 
t 


■nil* ^i.^^• (-?:#' *4 ^,' t,\;,i / 

I - -- I / 


/ (••► ■■'.f.irii ‘.I* '(. 


-''v'^ " ■■ ■ ' il 


‘ »•''’/ I 


'•■' J .’ I . •. .,i! ■ -Iji U -'f 

'■.f. {'/!*'’. ' :. l^;k 


i- <i i v? 


. . • 'A ,■..■■ 

^ ,-^r/ ’ ‘ ' ' ' ' ''■' '■■ : ' ' " ' ^ 

•- ' ‘ V • *^jpap*i— ^itfLVPt* t«i> A'«w 

• ■•■ U S' ' ,'••■ 

[I, ‘ ^ ' 




(iV 


virt 






'.- I . 


' ' ' s»- ■■ I’t'-w'.'. I 

.A -' A 


(MaI O' 


.. ji' 


f 


( vvvj^i; ) 


r 1 


. ' ... ;.fe’ ■ ■': 

, U , t *1 J-ill 'fn.f h 0 .'?.*M|fP M^L. V. w , 

'. ' . 


V., J' 1 W !■-- ■ • " . i K '>■* ,i^»'M’.-.*j| 

i)' j i L$tu, ■Jui> .I.'.y . .: ' |i'»)iV(iau*d'bfr blH^* ii .V'lHr gftt? 

*4 • -. ■ niiip jtjei4^..vi *1^ fc*t -.iijit^ ' '■■' "■ 


. ■ , ‘y '• ./. ■ 

r ’% 36 ' " .A i^r "" ; i.;rF“' 





Arrays 


• An array is a compound data structure whose component values are accessed by an 
index mechanism. 

• The time it takes to access an array component must not be dependent upon the 
size of its index. 

• The components of amcore arrays may belong to different types. 


A: 


make-array 


aref 


Discussion 


13(A): Note that amcore only allows one-dimensional arrays. But given the covert implementa- 
tion of arrays as arrays of pointers, this restriction can be liberalized in an entirely straightforward 
manner. 


> (delun make-table (m n) 

1> (do ((tmp (make-array m)) 

3> (index 0 (1+ index))) 

2> ((= index m) tmp) 

2> (seti (aref tmp index) (make-array n)) 

2 > )) 

MAKE- TABLE 

> (setq tab (make-table 22)) 

#(#(NIL NIL) #(NIL NIL)) 

> 

> (deiun tabrei (tab m n) 

1> (arei (aref tab m) n)) 

TABREF 

> 

> (tabref tab 1 1) 

NIL 

> (defun tabupdate (tab m n val) 

1> (setf (aref (aref tab m) n) val) 

1 > ) 

TABUPDATE 

> 

> (tabupdate tab 1 1 -56) 

-56 

> (tabupdate tab 0 1 "a test") 

"a test" 

> tab 

#(#(NIL "a test") #(NIL -56)) 

> (tabref tab 1 1) 

-56 

> (tabref tab 0 1) 

"a test" 


38 


14 Strings 


• The concatenation of any finite number of characters is a string. 

• String literals are sequences of characters surrounded by double quotes, 
printable characters may be included by using the following codes: 


w 

is 

the escape character ’\’ 

\n 

is 

newline 

\t 

is 

tab 

\r 

is 

carriage return 

\f 

is 

form feed 


A: char string strcat substr 


Non- 


39 


Discussion 


14(A): There are very few string functions in amcore which is in keeping with the overall 
requirement that the Core Interpreter be kept as small eis possible. 


> (char "abode" 0) 

97 

> (string 97) 

"a" 

> (defun. strchar (str index) 

1> (string (char str index))) 

STRCHAR 

> (strchar "abode" 0) 

"a" 

> (strchar "abode" 1) 

"b" 

> (strchar "abode" 4) 

"e" 

> (strcat " first" " second") 

" first second" 

> (strcat " first" " second" " third") 
" first second third" 

> (substr "abode" 2 4) 

"bcde" 

> (substr "abode" 3 7) 

"cde" 


40 


15 Numbers 


• amcore supports integers (fixnums) and floating-point numbers (flonums), which 
are scalar numeric types. 


12 -456 34567 #o677 #xfde56 

1.456 -8.9083456 -1.89098E-2 

• amcore also supports complex numbers, which are pairs of integers or floats. 
#C(34 -67) #0(1.23 -4.56) #C(-123 4.567ell) 


A; 

fix 

float 

c 

omplex 

realpart 

imagpart 

B: 

+ 

* / 

1 + 

1- 



C: 

min 

meix 

abs 

minusp zerop 

plusp 


< < 

s s 

/= 

>= 

> 


D: 

rem 

random 

logand 

logior 

logxor lognot 

E: 

sin 

cos 

tan 

asin 

acos 

atan sinh cosh tanh 

F: 

expt 

exp 

In 

log 

sqrt 


G: 

cis 

phase 






41 


Discussion 


15(B): These primitive arithmetic operations may be applied to one or more numeric arguments. 
If all of the arguments are integers, then the value returned is an integer. If any of the arguments 
is a floating point number or a complex number, then the result is coerced to that type, just cis if 
the appropriate type coercion function had been called. The default format for printing floating 
point numbers is the g format, which uses the shorter of the f or e floating-point format, and 
which suppresses the printing of nonsignificant zeros. 


> (+ 1 ) 

1 

>(+12) 

3 

>(+123) 

6 

> (- 1 ) 

-1 

> (setq a 9) 

9 

> (type-of a) 

:FIXNUM 

> (setq b 10.0) 

10 

> (type-ol b) 

:FL0NUM 

> (setq c (* a b)) 

90 

> (type-oi c) 

:FL0NUM 

> (setl d #C(1.0 0.0)) 

#C(1 0) 

> (+ a b d) 

#C(20 0) 

> (+ #c(4.0 5.0) #c(7.0 8.0) 

1> ) 

#C(11 13) 

> (♦ #c(4.0 6.0) #c(7.0 8.0)) 

#C(-12 67) 

> (- #c(4.0 B.O) #c(7.0 8.0)) 

#C(-3 -3) 

> (* 2.0 #c(4.0 6.0)) 

#C(8 10) 

> (/ #c(4.0 B.O) #c(7.0 8.0)) 

#0(0.60177 0.0266487) 

> (deltm conj (cmplx) 

1> (complex (realpart cmplx) (- (imagpart cmplx))) 
1> ) 

CONJ 


42 


> (conj #c(4.0 5.0)) 

#C(4 -5) 

> (conj #c(4.0 -5.0)) 

#C(4 5) 

> (delun norm (cmplx) 

1> (sqrt (realpart (* cmplx (conj cmplx)))) 
1 > ) 

NORM 

> (norm #c(1.0 0.0)) 

1 

> (norm #c(4.0 5.0)) 

6.40312 

> (norm #c(7.0 8.0)) 

10.6301 


43 






,;;';’',T^^ ■ 




This page intentionally blank 




if if ' i- 1 'afj^"u*. i*«ji» Rfii ii3W;jS<8t‘4 

»> ► -W-. . r*.iM>- iif » «:0«-5\f«J(.,««iinbetri^o'^H<»-'fiorj3i»«‘j^r4^ay 

t^: *■• p#} vi^t/'-Oh bffr,ti('f' I' -vt 

,.v4»at (ji;na..W' li' >{•': 1V'hlt,'H,vif«ta.sSk«. >av5' 

•i.j- ih>' |»> ' V ^ V 

. i . 0 - 1 ) ^ ' otob) <■ : 

.r,fo':ii O', f ) .-»*vjr£Bi^' ,<;i^ 


j. c* If 
% 

'• » V) 

13 *: 


;;/■ '-, "‘s 






i 5 

^ I. n 

-t ' 


— i 


' ■ ■■ ■ ^ 


\ 

' ( J- 

’■' T' • .-I, 


I -* 


h »iJ , 


... '-fc, i' ■.'.tT" " 

if.(, ■ • '<p' 'r:';v ■ _ • , : ' ”■ ■ " 

'!f::'' ;|;, J'.'% '■' ;: , ' ■ ^ ■.m.': .,: ■ 


i » 

vO;" ; '-■ 




T - 


ii b ' ^ 


*■ ■ * of c f ^ 

'.\ }H 


•j: * •.< -j f!.o> 


- /y <4 w R • .- *^ir .» ar.o^j 
tzi t?e;) / 

• » * 'U * ' ij/ 4 a*o i.w^' 

* ' 0 ty 

» 2 0 f<< 4 .U ^-v^J 


., vfV 


'> -i ‘U 1 

'i. nii)».i 


<r*4> ' 

Ci.*. .J,;» .;, ( • (1 Kx:gj-'. rb' ( » 


i-. ) 
I 



, 51 



16 Objects 

• An object consists of a data structure containing a pointer to the class and an array 
containing the values of the instance variables. 

• The only way to communicate with an object is by sending it a message. When 
eval is presented a list whose first element is an object, it interprets the value of 
the second element, which must be a symbol, 2 ls the message selector, 

• then eval gets the clciss of the receiving object and attempts to find a method 
corresponding to the message selector in the set of messages defined for that class. 

• If the message is not found in the object’s class and the class has a superclass, the 
search continues by looking at the messages defined for the superclass. 


A: object class 


45 


Discussion 


16(A): The following example, taken from Betz’s tutorial on Xlisp /!/, defines a class of objects 
that represent simple dictionaries. Each dictionary instance will be an association list whose first 
member is a symbol and whose second member is a pair. In this example, the class dictionary 
supports two methods add and find. 


> (setq dictionary (class :new ’(entries))) 

#<0bject; #391b7072> 

> (dictionary : show) 

Object is #<0bject: #391b7072>, Class is #<0bject: #391bd900> 
MESSAGES - NIL 
IVARS - (ENTRIES) 

CVARS = NIL 
CVALS - #0 

SUPERCLASS = #<Object: #391bd882> 

IVARCNT - 1 
IVARTOTAL = 1 
#<Object: #391b7072> 

> (dictionary ; answer ’add ’(name value) 

1> ’ ( (setq entries 

3> (cons (cons name value) entries)) 

2> value)) 

#<Object: #391b7072> 


> (dictionary :answer ’find ’(name &aux entry) 
1> ’((cond ((setq entry (assoc name entries)) 
4> (cdr entry)) 

3> (t 

4> nil)))) 

#<Object: #391b7072> 


> (dictionary rshow) 

Object is #<Object: #391b7072>. Class is #<Object: #391bd900> 
MESSAGES - ((FIND (NAME &AUX ENTRY) 

(COND ((SETQ ENTRY (ASSOC NAME ENTRIES)) 

(CDR ENTRY)) (T NIL))) 

(ADD (NAME VALUE) 

(SETQ ENTRIES 

(CONS (CONS NAME VALUE) ENTRIES)) 

VALUE) 

) 

IVARS - (ENTRIES) 

CVARS - NIL 
CVALS - #() 


46 


SUPERCLASS = #<Object: #391bd882> 
IVARCNT = 1 
IVARTOTAL = 1 
#<Object: #391b7072> 


Dictionary instances may now be created and some entries added: 


> (setq d (dictionary :new)) 

#<0bject: #391b549a> 

> (d ’add ’mozart ’composer) 

COMPOSER 

> (d ’add ’ Winston ’computer-scientist) 

COMPUTER- SCIENTIST 

> (d ’iind ’mozart) 

COMPOSER 

> (d ’find ’ Winston) 

COMPUTER- SCIENTIST 

> (d :show) 

Object is #<0bject: #391b549a>. Class is #<0bject: #391b7072> 
ENTRIES = ((WINSTON . COMPUTER-SCIENTIST) (MOZART . COMPOSER)) 
#<0bject: #391b549a> 


> (setq e (dictionary :new)) 

#<0bject: #481c794a> 

> (e ’add ’one 1) 

1 

> (e ’add ’two 2.0) 

2 

> (e ’add ’three 3.0) 

3 

> (e ’find ’one) 

1 

> (e ’find ’two) 

2 

> (e ’lind ’three) 

3 

> (e ’lind ’winston) 

NIL 

> (e :show) 

Object is #<Object: #481c704a>. Class is #<0bject: #391b7072> 
ENTRIES = ((THREE . 3) (TWO . 2) (ONE . 1)) 

#<Object: #481c794a> 


47 




, I > v .' 





This page intentionally blank. tJQ«|40>^ “ 

'■ ^ ' waKvx:?i^;'^ 

•■■ % „.<> , ( f . M . •• 0 . .. i ..'* a ,, 

t '' <i*.-iA' V.a^•h n: ‘ft*;)A*;« (>(‘<11 b* 

' r- (»': '■«. ‘Wtv'tr'-"': tf, d |)4o 

'' -, . .1 ' /-t . .<■ : '' X ' 'U J ' 

►h!' .. fl«h<lrn IV'f-# *d 'if^d Wan-t'oaao '.uni' 


■ UH ■ (,v 

. p dh 




• 0 <1 ■< •. V iKc ) 


, ( j+- ' ■ :i{^jj[!&o |4 



.; 0 » 


:..5y 


' .%t ^-SaiSOWO 

'. ..^ ■ - - ■•s.' rf-. ' .(l^i;,^5^^f;ii^ halti 

/•.'', '\ ,.. ■ 

/ ■ '■•!*.!> rt ■■ ' /' , ; Ufl4r|< 

•VI, r. ' r ' ' ll' , 

■■■ ,'j*'‘ ' . '■ ’' ' 

’^ii\ .< ' ■■ ‘v" 'trr<( * j--i,n l'■40>» Mt aattP 

' . ,,. mm^)y 

•' ' '' ■ s ! . ' t ' tjsi.^I *'-'‘''- 

r , ■■ ’^*4 ■ 


< I 


T J.» r , < 


Mffs 

mm 






I. 

r * • 


j*t - •■ i Otri'.v 

' '.'j ]t \ .!'■ ' If*:r .t ''..1 ( li I 


I 1 


■•)> 


■ (1, drab’' 

(0.;il. ov4*'- %.'!#' 

■ ■ft 


' i . r .; 


■Vf 

J - 

■m 






lit ».5U4WK«»3» ^■' i, >.■..#■ 


(eaxtisf ■ ' mt 


■'■, ;/ m ‘^■S 

n,. ! v >«5 v*^,tJ!|> 

. ‘ : m ttrmif 










- { iM-Ji: 

" * ♦>-. 
v«UI *■♦' 

r 

J 


UL \ my (t it W)': <e, . 

3'Vji 


48 








17 


Streams 


• Streams are expressions that serve as sources or sinks of expressions. 

• Streams are usually connected to files or to external peripheral devices. 

• Streams may be input-only, output-only, or input-output. The streams * standard- 
input* and *standard-output* have been predefined in the amcore interpreter. 


A: 

read 

print princ 

read-char 

peek-char 


read-line cfprintfl 

terpri 


B: 

flatsize flatc 



C; 

openi 

openo openio 

opena 

close 

D: 

f seek 

ftell 



E: 

kbhit 

getkey 




write-char 


49 


Discussion 


17(A): All input and output operations are performed by the functions of this group. If the file 
pointer argument is omitted, then the default stream is understood to be either standard input 
or standard output. 


> (setl test "this is a line") 

"this is a line" 

> (princ test) 

this is a line"this is a line" ;TEST is PRINCed then value is returned 

> (print test) 

"this is a line" ;TEST is PRINTed, including newline... 

"this is a line" ; . . . then value returned 

> (setq sample "\tone\n\t\ttwo\n\t\t\tthree") :more complicated case 
"\tone\n\t\ttwo\n\t\t\tthree" 

> (princ sample) 

one 

two 

three"\tone\n\t\ttwo\n\t\t\tthree" 

> (print sample) 

"\tone\n\t\ttwo\n\t\t\tthree" 

"\tone\n\t\ttwo\n\t\t\tthree" 


> (defun little-reader () 

1> (do 0 

2> 0 

2> (princ "\t::") 

2> (read))) 

LITTLE-READER 

> (little-reader) 

::> 12 
: :> 34 
: :> 66 
: ; > this 

::> ;Ctrl-C entered here 

[ back to the top level ] 

> (defun little-reader-writer () 

1> (do 0 


2> 

() 


2> 

(princ "\t::") 


2> 

(princ (read)) 


2> 

(terpri))) 

: TERPRI causes newline 


LITTLE-READER-WRITER 
> (little-reader-writer) 
: :> 12 

12 


50 


: :> 34 
34 

: : > this 

THIS 

::> (a list (is here)) 

(A LIST (IS HERE)) 

: :> :Ctrl-C entered here 

[ back to the top level ] 

17(C): In order to perform external 10 operations, streams must be associated with files. This 
association is established by applying an open function to a legal path and filename. If no path 
is given, then the pathname of the default directory is assumed. All open functions return a file 
pointer which provides access to the external file. The open functions differ in direction: openi 
is an input stream, openo is an output stream, openio is an in-out stream, and opena is a 
stream opened in append mode. The close function breaks the association of a stream with an 
external file. 


> (set! Ip (openo "test.dat”)) ; TEST.DAT opened lor output 

#<File: #481c2922> 

> (print "this is line 1" Ip) 

"this is line 1" 

> (print "this is line 2" Ip) 

"this is line 2" 

> (print "this is line 3" Ip) 

"this is line 3" 

> (close Ip) ; TEST.DAT closed 

NIL 

> (setq gp (openi "test.dat")) ;TEST.DAT opened lor input 
#<File: #481c2436> 

> (delun dump (Ipnt) 

1> (do ((tmp (read-line Ipnt) (read- line Ipnt)) 

3> ) 

2> ( (null tmp) ) 

2> (princ tmp) 

2> (terpri) 

2 > )) 

DUMP 

> (dump gp) 

"this is line 1" 

"this is line 2" 

"this is line 3" 

NIL 

> (close gp) 

NIL 

17(D): The ftell fimction returns the position in the stre^lm from which the next lO operation 
will be performed. The fseek function changes the current position. 

51 


> (set! Ip (openi "test.dat")) 


#<File: #391b6ec2> 

> (Itell Ip) 

0 

> (read Ip) 

"this is line 1" 

:get current position 

> (ftell ip) 

16 

> (read fp) 

"this is line 2" 

;get position aiter iirst READ 

> (itell ip) 

34 

> (read ip) 

"this is line 3" 

;get position aiter second READ 

> (itell ip) 

52 

:get position aiter third READ 

> (iseek ip 16 0) 

16 

;set position to 16’th byte 

> (read ip) 

"this is line 2" 

;read iile again ... 

> (iseek ip 16 0) 

16 

> (read ip) 

"this is line 2" 

; . . . and repeat 


52 


18 Textport and Viewport Functions 


• A textport is any region of a display space which is a two-dimensional array of 
character positions, indexed by row in the vertical axis and by column in the 
horizontal. 

- Every character position is itself a two-dimensional array of pixels: those that 
make up the character are called foreground pixels, the rest are called back- 
ground pixels. 

— The appearance of each character position is determined by an attribute byte, 
which determines the color and intensity of the foreground pixels, the color of 
the background pixels, and whether the foreground blinks or not. The value 
of the attribute byte is set by settextcolor. 

— The current position is indicated by the cursor. 

• A viewport is any region of display space which is a two-dimensional array of pixels, 
indexed by row and column. 

- Each pixel is a discrete dot of color. 

- The function setbkcolor sets the background color for all of the viewport’s 
pixels. 

— The function setcolor sets the color to be used by setpixel and the other 
drawing functions. 


A: make-window box get-margins savescr restorescr 

settextcolor gettextcolor 

B: clear clearregion cleared cleareos 

scrollup scrolldown 

C: setcursor getcurrow getcurcol curshift 

rowhome colhome 

D: setvideomode setpixel getpixel 

setcolor getcolor setbkcolor getbkcolor 

E: lineto moveto arc pie ellipse rectemgle 

F: setcliprgn setviewport floodfill 


53 


Discussion 


18(A); The argument of settextcolor must be an integer in the range from 0 to 255. There 
are eight basic colors: 


black 

is 

0 

red 

is 

4 

blue 

is 

1 

magenta 

is 

5 

green 

is 

2 

brown 

is 

6 

cyan 

is 

3 

white 

is 

7 


To determine the attribute value, it is first necessary to assign values to two bit-valued variables: 
blink (0 is no-blink, 1 is blink), and intensity (0 is low, 1 is high). The value of the attribute 
byte may be calculated eis follows: 

(128 * blink) + (16 ♦ bkgmd) + (8 * intensity) + Igmd 

where bkgrnd and Igmd are any basic color values. The next session creates a function which 
shows all of the possible values of settextcolor and what they actually look like on the screen. 

> (delun show-sample-text-colors (ch) 

1> (clear) 

1> (color-block 0 ch) 

1> (color-block 64 ch) 

1> (color-block 128 ch) 

1> (color-block 192 ch) 

1> (settextcolor 7) 

1 > ) 

SHOW-SAMPLE-TEXT-COLORS 

> 

> (defun color-block (n ch) 

1> (do ((i 0 (1+ i))) 

2> ((“ i 64)(terpri)) 

2> (settextcolor (+ i n)) 

2> (princ ch) 

2 > )) 

COLOR-BLOCK 

The function basic -screen defines a textport whose upper-left position is in row 1 column 1, 
emd whose lower-right position is in row 25 column 80. The attribute byte is set to 7, which 
means that the foreground color is low-intensity white, the background color is black, and there 
will be no blinking. When this function is executed, the window will be cleared and the cursor 
will be plew:ed in the home position row 1 colunm 1. 

> (defun basic-screen () 

1> (settextcolor 7) 

1> (make-window 1 1 26 80) 

1> (clear) 

1 > ) 

BASIC-SCREEN 


54 


The next function creates a smaller window in the lower part of the screen, beginning in row 
8 column 1. The attribute byte indicates that the foreground color is low-intensity blue, the 
background is white, and there will be no blinking. Using special printing characters whose 
ASCII code is greater than 127, the function box prints a double-lined box around the margins 
of the defined window. Having drawn the box, a new window is created inside of it and that new 
window is cleared. 

> (defun lower-window () 

1> (settextcolor 113) 

1> (make-window 8 1 25 80) 

1> (clear) 

1> (box 8 1 25 80 2) 

1> (make-window 9 2 24 79) 

1> (clear) 

1 > ) 

LOWER-WINDOW 

18(C): The next function is more complicated than those we have been considering so far in this 
write up. After storing the current status information concerning the current textport, such as 
its dimensions, text color, and the position of the cursor, a 10x10 window is created and then the 
charaicter string passed as an argument is princed in the new window. Before each invocation 
of princ, setcursor is used to set the cursor at a randomly selected row and column. The color 
of the princed chaireicter is also randomly selected. The inner do loop may be terminated by 
pressing any key, at which time the previous textport is restored. 


> (defun random-princ (ch) 



1> 

(prog (i j 



3> 

(♦margins (get-margins)) 

; store 

description of current 

3> 

(♦row (getcurrow)) 

: textport in local variables 

3> 

(*col (getcnrcol)) 



3> 

(♦tcolor (gettextcolor))) 



2> 

(make-window 10 50 19 59) 

; make new window and . . . 

2> 

(settextcolor 113) 



2> 

(clear) 

: CLEAR 

it 

2> 

(do 0 



3> 

((kbhit) 


;when KBHIT, 

4> 

(apply make-window ♦meirgins) 


; terminate loop and 

4> 

(apply setcursor (list ♦row 

♦col)) 

; restore previous texport 

4> 

(settextcolor *tcolor)) 



3> 

(setq i (rem (random 255) 8)) 


:get random row 

3> 

(setq j (rem (random 255) 8)) 


;get random column 

3> 

(setq c (rem (random 255) 127)) 

;get random color 

3> 

(setcursor (+ 11 i)(+ 61 j)) 


;move cursor 

3> 

(settextcolor c) 


; change color 

3> 

(princ ch) 


; princ 

3> 

) 



2> 

)) 



RANDOM-PRINC 




18 (D): At any given time, a screen may be in one and only one video mode. The current mode 


55 


may be changed by invoking setvideomode with a proper integer value. Which values are proper 
depend upon the graphics adaptor and upon the specific functional capabilities of the display 
monitor. K an improper value is used, then the execution of setvideomode hcis no effect. The 
following video modes are commonly used: 


mode 

type 

color 

dimensions 

adaptor 

0 

text 

b/w 

40x25 

CGA 

1 

text 

16 

40x25 

CGA 

2 

text 

b/w 

80x25 

CGA 

3 

text 

16 

80x25 

CGA 

4 

graphics 

4 

320x200 

CGA 

6 

graphics 

4 grey 

320x200 

CGA 

6 

graphics 

b/w 

640x200 

CGA 

13 

graphics 

16 

320x200 

EGA 

14 

graphics 

16 

640x200 

EGA 

15 

graphics 

4 

640x350 

EGA 


Every EGA adaptor supports all of the video modes defined for CGA, but not conversely. 


56 


19 System Functions 


• These functions make operating system services available within amcore. 


A: 

dos 

date tstamp load 

transcript 

B: 

gc 

address-of expand 

alloc mem 

C: 

peek 

poke 


D: 

exit 




57 


Discussion 


19(A); The argument of dos is a string which is a legal DOS command string. 

> (dos "dir /p") 

Following the normal conventions for strings, occurrences of the backslash character in command 
strings is represented by a double backslash with no intervening whitespace. 

> (dos "cd c : WmscWlib”) 

When the screen has been patiently put together using the textport functions of the preceeding 
section, sometimes dos can do terrible damage, seeming almost to tear the screen apart. The 
following function, using savescr and restorescr, solve the problem rather elegantly: 

> (delun neat-dos (dos-cmd-str) 

1> (savescr) 

1> (dos dos-cmd-str) 

1> (getkey) 

1> (restorescr) 

1 > ) 

NEAT-DOS 

The function trainscript, when applied to a legal DOS filename, causes the file to be opened in 
output-only mode ^lnd then writes to it every character from *8taiidard-iiiput* and •standard- 
output*. This file is a complete record of an amcore session. If the function transcript is 
called with no Mgument, then the recording process is terminated eind the file closed. 

> (transcript "sample .trs") 

T 

>(* 46 ) 

20 

> (tr 2 aiscript) 

NIL 


58 


20 Debugging Support Functions 

• The functions in this group are used to control the behavior of the evaluator when it 
encounters an error. This behavior is determined by the values assigned to several 
global variables: 

*breakenable* controls entrance to break loop on errors 
*tracenable* enable baktrace on errors 
♦tracelimit* number of levels of baktrace 

• If *breakenable* is T, the error message is printed. If the error is correctable, 
the correction message is printed. 

• If *tracenable* is T, then the evaluation stack is baktraced. The number of entires 
printed depends on the value assigned to *tracelimit’''. If it has been assigned as 
non-numeric value, then the stack is printed. 

• At this point, a special read-eval-print loop, called the break loop, is entered. 
Unlike the normal top-level loop, break loops allow programmers to invoke the 
continue function and then continue processing after a correctable error. While in 
a breaJc loop, a break level number is prefixed to the amcore prompt. K another 
error causes a new break loop to be activated, the break level is incremented. 

• If *breakenale* is nil, then the processor looks for an err set function. If the 
flag of errset is T, then the error message is printed. If there is no surrounding 
errset, then the error message is printed and the system returns to the top-level 


A: 

error cerror 

errset 



B: 

break continue 

clean-up 

top-level 

baktrace 

C: 

evalhook 





59 


D iscussion 


20(A): The error function is used to cause a non-recoverable break in the processing of a 
program. 

> (delun integer-only (n) 

1> (cond ((equal (type-of n) rFIXNUM) n) 

2> (t (error "Not an integer"))) 

1 > ) 

INTEGER-ONLY 

> (integer-only 6) 

6 

> (integer-only 6.0) 
error: Not an integer 

> (integer-only nil) 
error: Not an integer 

The function c error causes an error to be signaled from which it is possible to continue. 
This function requires two strings: the first is the continue message which may be used to suggest 
corrective actions, and the second is the error message. This operational mode requires that the 
global vairiable *breakenable* be set to T. 

> (setq ♦breakenable* T) 

T 

> (delun continuable-integer-only (n) 

1> (cond ((equal (type-ol n) :FIXNUM) n) 

2> (t (cerror "SETQ n TO INTEGER" "Not an integer") 

3> (♦ n n))) 

1 > ) 

CONTINUABLE-INTEGER-ONLY 

> (continuable-integer-only 10) 

10 

> (continuable-integer-only 5.0) 
error: Not an integer 

if continued: SETQ n TO INTEGER 
1 :> (setq n 6) 

5 

1:> (continue) 

[ continue Irom break loop ] 

25 

> (setq this-example (continuable-integer-only 9.0)) 
error: Not an integer 

if continued: SETQ n TO INTEGER 
1 :> (setq n 9) 

9 

1:> (continue) 

[ continue from break loop ] 

81 

> this-example 
81 


60 


20(B): The break and continue functions are used together to create an interpretive environ- 
ment which is especially useful when debugging programs. 


> (delun using-break () 
1> (prog (x) 


2> 

(setq X 10) 



2> 

(break) 

: break 

A 

2> 

(prog (x) 



3> 

(setq X -20) 



3> 

(break) 

; break 

B 

3> 

) 



2> 

(break) 

: break 

C 


2 > )) 

USING-BREAK 


> (using-break) 
brezLk: **BREAK** 

1:> X 
10 

1 : > (setq x 78.9) 
78.9 


;break A processed 
:get current value 

•.chamge value ol x 


(break level 1) 
of X 


1:> (continue) ; continue from break A (break level 0) 

[ continue from break loop ] 

break: **BREAK** ;break B processed (break level 1) 

1:> X ;get current value of x 

-20 


1:> (continue) ;continue from break B (break level 0) 

[ continue from break loop ] 

break: ♦*BREAK** ;break C processed (break level 1) 

1:> X ; check value of x 

78.9 

1:> (continue) ;continue from break C (break level 0) 

[ continue from break loop ] 

NIL ; value returned by USING-BREAK 


The backtrace function shows the current state of the evaluation stack. That is, it returns a 
printed list of all of the expressions which are currently being evaluated, beginning with the most 
recent and working backweirds: 


> (continuable-integer-only 9.5) 
error: Not an integer 
if continued: SETQ n TO INTEGER 
1:> (bedctrace) 

(BAKTRACE) 

(CERROR "SETQ n TO INTEGER" "Not an integer") 

(COND ((EQUAL (TYPE-OF N) :FIXNUM) N) 

(T (CERROR "SETQ n TO INTEGER" "Not an integer") 
(♦ N N))) 

(CONTINUABLE-INTEGER-ONLY 9.5) 


61 


NIL 

1 : > (setq n 9) 

9 

1:> (continue) 

[ continue irom break loop ] 
81 


62 


References 


1 . 

2 . 

3. 

4. 


5. 

6 . 


7. 

8 . 


9. 

10 . 

11 . 

12 . 

13. 

14. 

15. 

16. 

17. 


Betz, D. “An Xlisp Tutorial,” BYTE, March 1985, 221 et sq. 

Betz, D.M. “XLISP; An Object-oriented Lisp, Version 1.7,” unpublished manuscript, June 
2, 1986. 

Bandy, H.T., Carew, V.E. Jr. and Boudreaux, J.C. “An AMPLE Version 0.1 Prototype: 
The HWS Implementation,” National Bureau of Standards, NBSIR 88-S770. 

Boudreaux, J.C. “Problem Solving and the Evolution of Programming Languages,” The 
Role of Language in Porblem Solving - Jf; edited by R. Jernigan, B. Hamil, and D. Wein- 
traub, North-Holland, Amsterdam, 1985; 103-126. 

Boudreaux, J.C. “The AMPLE Project,” National Bureau of Standards, NBSIR 86-S496. 

Boudreaux, J.C. “AMPLE: A Programming Language Environment for Automated Man- 
ufacturing,” The Role of Language in Problem Solving - 2; edited by J.C. Boudreaux, B. 
Hamill, and R. Jernigan, North Holland, Amsterdam, 1987; 359-376. 

Boudreaux, J.C. “Requirements for Global Programming Languages,” Proceedings of the 
Symposium on Manufacturing Application Languages, MAPL 88, 107-114. 

Boudreaux, J.C. and Staley, S.M. “Representing and Querying Objects in AMPLE,” En- 
gineering Database Management: Leadership Key for the 90’s, The American Society of 
Mechanical Engineers, 1989; 73-79. 

Graham, P. “Common Lisp Macros,” A I Expert, March 1988, 42 et sq. 

Hudeik, P. “Conception, Evolution, and Application of Functional Programming Languages,” 
ACM Computing Surveys, vol 21(1989), 359-411. 

Kaisler, S.H. INTERLISP: The Language and its Usage, Wiley-Interscience, 1986. 

Mason, I.A. The Semantics of Destructive Lisp, CSLI Stanford, 1986. 

McCarthy, J., Abrahams, P.W., Edwards, D.J., Hart, T.P., and Levin, M.I. LISP 1.5 
Programmer’s Manual, Second Edition, MIT Press, 1965. 

Staley, S.M. and Boudreaux, J.C. “Programming Language Environments for CIM,” Pro- 
ceedings of PROCIM ’88, 70-72. 

Steele, G.L. Common Lisp: The Language, Digiteil Press, 1984. 

Vorberger, T.V. and Boudreaux, J.C. “An Architecture for Quality Control in the QIA 
Project,” in C. Denver Lovett (ed.). Progress Report of the Quality in Automation Project 
for FY88, NISTIR 89-4045; 5-47. 

Wilensky, R. LISPcraft, Norton, 1984. 


63 




This page intentionally blank. 




V;s,.»,. J t4| 


'^r j 




J, 












U i?!' ,2«&r Ataj«M tt .jtsfisflt 

}»,‘Ji'^/rt^r''..-.i ■• tlvL M^^li}f»V' M 0 ,.JJ ^ 

tJT Vt •''&'<» iUWtl^ ,*‘a>oina4^\Q U^uM»^ 

■ ■ 2^-1 I '• '’■) '■■'■' 

,■ ' ■ ■ ■' ■ sa'Viijt. 

•r.'t * n^iish'T^ 

. '(Ti®W u’b't.ti .fif M %4 -h$i\hn» jl ' ;h43^4'»e!H. t\\ \<» 4«$s!'ia^ 

' * ‘ f- ' ■'•■■ 1 ; ' ^ ' ' ■•: '’’V 

’CilA bei»mu4ii/ ^oliifiqOTtS^^' '4 


.Vif-Vpi ''■*. M4 .» i|LhV>t>JrMs\#»»itt'S^i tti 

* *'1 't'T ■ * ' ‘*^''0^' 

U[% '^’y l'\l/. ^ *.| ft<«0 iut(y"'^0 fetu bm 

!'■• i'_ i''i\jh: i-.«', “'.IT fcAl 1w\ fJrH 


'*^'' 

■■ ■' - V , ■ ^ :'p^v^ 

1^1. i» .■h«'jM‘ .V» •'^»A \*k ■•'wrfcwM iqaiii 

' bo4'iW(n>‘,fflQrvS 

' - , 4 ' • 

. 1 ■olx^,^.^c,•»^^a■^ %)u-. hw;*» »sVl? Jfl.3 

tt%n inloY' ,H^l X^ji, aATK 

-1 -V, iv*-K4 fyr‘ J}-'!: fjTWkU ,-X,^ ^m^tAdkpJ^^' ,X 

?Ml }iioJ>irjtl3[ ’jfe^ V i«ii*5rihJ!»’rs^n’''' 

, ; ; • , 01^" . _ 

,r^\Y »"<•>•>*:, W 'ihh^ ^uiiitWwAijgalV .O.t Ibfej# 

-MOI <«unH '-jtiJfsiCl #lrt 

; ‘ ^ ^ ■ " ^ ■■ ,: PV ^ 

<'.(0 •Ad ni f ooJ ‘f|i#5i^iijiA 1 ^* ,5>.L Paft “P 

, \Tfri _/ ></Vt jiMt&Mf' 

‘■iy^ 


li 


r 



Alphabetic List of amcore Functions 


(• <<nu«ber>>) 

< 2 inMb«r> the noabere 

returns the result ol the Boltlplicatlon 


<Ecalar_2> the right operand ol the comparison 

returns the result ol comparing <scalar_l> with <scalar_2> 


(♦ <<nu«ber>}) 

<nnaber> the numbers 

returns the result ol the addition 


(abs <Bcalar_nuBber>) 

<scalar.number> the number 

returns the absolute value ol the number 


(- <<number>}) 

<number> the numbers 

returns the result ol the subtraction 


(acos <ec alar. number!) 

Cscalar .number! the number 

returns the arccosine ol the number 


(/ {cnumber!}) 

<nnmber! the numbers 

returns the result ol the division 


(addresB-ol cexpression!) 

Cexpression! the node 

returns the address ol the node 


(/- <8calar.l! <Bcalar.2!) 

<8calar_l! the lelt operand ol the comparison 

<6calar.2! the right operand ol the comparison 

returns the result ol comparing Cscalar.l! with <scalnr.2! 


(alloc cinteger!) 


<integer! 

returns 


the number ol nodes to allocate 
the old number ol nodes to allocate 


(!♦ <number!) 

Cnumber! the number 

returns the number plus one , 


(1- <number!) 

<number! the number 

returns the number minus one 


(< <sealar.l! <scalar.2!) 

^scalar. 1! the lelt operand ol the comparison 

^scalar.2! the right operand ol the comparison 

returns the result ol comparing Cscalar.l! with <scalar_2! 

(<• <scalar.l! <8cal%r^2>) 

<scalar_l! the lelt operand ol the comparison 

<scalar.2! the right operand ol the comparison 

returns the result ol comparing Cscalar.l! with <8calar.2> 


(and (Cexpression!}) 

Cexpression! the expressions to be IKDed 

returns nil il any expression evaluates to nil: 

otherwise the value ol the last expression 
(evaluation ol expressions stops alter the lirst 
expression that evaluates to nil) 


(append {<list!}) 

<llst! lists whose elements are to be appended 

returns the new list 


(apply clnnction.expression! <liBt!) 

clunction.expression! a symbol with Innction binding, a lambda 
expression, else an error 

<list! the list ol arguments to which <lnnction.expression! 
is applied 

returns the result ol applying the lunctlon to the arguments 


(■ <scalar.l! <scalar_2>) 

^•calar.l! the lelt operand ol the comparison 

<scalar_2! the right operand ol the comparison 

returns the result ol comparing Cscalar.l! with <scalar_2! 


(> <scalar.l! <scalar.2!) 

^•calar.l! the lelt operand ol the comparison 

^•talar.2! the right operand ol the comparison 

returns the result ol comparing cscalar.l! with <scalar.2! 


(!• <scalar.l! <Bcalar.2!) 

^scalar.l! the lelt operand ol the comparison 


(arc <integer.l! <integer.2! <integer.3! <integer.4! 
<lnteger.6! <integer.6! <lnteger.7! <integer.8! ) 


<integer.l!<integer.2! 

X- and 


comer 

<integer.2!<integer.3! 

X- and 


comer 

<integer.6!<integer.fi! 

X- and 

<integer.7!<lnteger.8! 

X- and 


y-axls coordinates ol upper- lelt 

ol bounding rectangle 

y.-axls coordinates ol lower-right 

ol bounding rectangle 

y-axls coordinates ol start vector 

y-axls coordinates ol end vector 


returns true, il the arc is successlully drawn: 

otherwise, nil 

side ellect draws an elliptical arc, the center ol which is the 
center ol the bounding rectangle, starting Irom the 
intersection point with the start vector and ending 
at the intersection point with the end vector 


65 


(4rel <4iT*y> 
<4rr«y> 
<jjiteger> 
rctTiniA 


<lnteger>) 

the arraj 

the array index 

the ralae oi the array element 


(aein <scalar.niiMber>) 

<acalar_naBber> the nonber 

returns the arcsine of the nuaber 


(assoc <syabol> 
<sy*bol> the 
<list> the 
<key> the 
<teBt> the 
returns the 


<li8t> (<kcy> <teEt>]) 
sysbol to lind 

assoc list of the lorn ([{(<synbol> , <expre6sion>) }] ) 

keyword :test or :te6t*not 

test function (defaults to eql) 

assoc list entry testing true on <6ynbol> 


(break [<string> [<expres8lon>] ] ) 

<etring> the break nessage. defaults to "••BREAK**" 

<expre88lon> (eval <expre88ion>) is printed alter the nessage 
returns nil when continued from the break loop 


(car <llst>) 

<llst> the list node 

returns the head of the list node 


(catch <tag> [{<expre86lon>}] ) 

<tag> the catch tag 

<expre66ion> expressions to evaluate 

returns the value (eval (last <<expre68ion>>) ) or the 

value of a throw expression 


(atan <scalar^unber>) 

<scalar.nunber> the nuaber 

returns the arctangent of the nuaber . , v 

(cdr <list>) 

<ll6t> the list node 

returns the tail of the list node 


(atoB <expre66ion>) 

<expression> the expression to check 

returns t if the value is an atom, nil otherwise 

i I 


(backquote <expre8Sion>) 

<expre6Bion> the teaplate 

returns a copy of the teaplate with coaaa and conaa*’at 

expressions expanded: 

(i) if (coaaa <expreeeion>) in scope of backquote, 
then replace with (eval <expre8slon>) . 

(ii) if (coaaa-at <expree8ion>) in scope of 
backquote. then replace with (eval <expres6ion>) 
spliced in. 


(cerror <6trlng_l> <6tring.2> [<expr«B6lon>] ) 

<strlng_l> the continue sessage 

<6tring_2> the error aesaage 

<expresElon> (eval <expre8Elon>) ia printed alter the aessage 
returns nil when continued Iron the break loop 


(clprintll <Iile_pointer> <Btring> <expres6ion>) 
<lile_pointer> the output sink 

<atring> any loraat convereion strings in C 

<expresslon> the expression to be printed 

retumB true 

slde-ellect the value (eval <expresBlon>) is printed 

in the lomat specllied by <string> 


(baktrace [<lnteger>]) 

<lnteger> the number ol levels (defaults to all levels) 


nil 


(char <string> <index>) 

<strlng> the string 

<lndex> the string Index (zero relative) 

returns the ascii code ol the character 


(boundp <syBbol>) 

<syBbol> the symbol 

returns t 11 a value Is bound to the symbol, nil otherwise 


(box <lnteger_l> <lnteger_2> 

<lnteger_3> <integer_4> 

<integer_6>) 

<lnteger_l> npper-lelt row (top margin) 

<lateger_2> upper-lelt column (lelt margin) 

<integer_3> lower-right row (bottom margin) 

<lnteger_4> lower-right column (right margin) 

<lnteger_6> border lines to draw 

2 • draw double-line 
otherwise draw single-lines 
returns true 

slde-ellects draws a double- or single-line bordered box ol 
the designated size. Usually the interior ol 
this region is marked with the make-window command. 


(cim <scalar_number>) 

<scalar_number> the number 

returns the result ol evaluating els <mcalar_nunber> 


(class <selector> [<expresBion>] ) 

<selector> the method selector 

<expression> the (optional) argument expression 

returns the value obtained by applying the method to 

list ol (eval <expression>) ; 


:nes 

returns the new clans object 

-.isnew <llst_l> (<llnt_2>(<obJect>)) 

<llst_l> the list of Instance variable symbols 


66 


<obJ«ct> 

returns 


the list ol clssB Tsrlable sjrsbols 

the supcrclsss (delsolt is Object) 

the new class object 

:answer <selector> ([{Csynboli))) [{<exprcssloii>}] 
<selector> the nessage symbol 

( [{Csynboli}] ) the list ol iomal argtuients: 

( 

[{<larg>}] 

[hoptional [{<oarg>}]] 

[hrest <rarg>] 


[kaux 

) 

where 

[{<aux>}]] 

<farg> 

1ft a loraal argujoent 

<oarg> 

Is an optional argnaent 

<rarg> 

bound to the rest of the arguaents 

<aux> 

is an auxiliarj Tarlable 


[{<expression>}] the body of the nethod 
retnms the object 


(cosplex <ocalar_nnnber_l> <scalar_nunber_2>) 

^•<^*lsr_nusber_l> realpart of cosplex nnsber 
^•'^**'-*'®nber_2> laagpart of cosplex nosber 

returns tjie cosplex number #C«scalar^usber_l> <ocalar_nusber_2>) 


(cond {<cond_c lauae>)) 

<cond_clause> a list of cond-clauses 

returns (eval (last <rest_expresslon>) ) of the first 

cond-clause such that (eral <teBt_expres6ion> is 
non-nil; otherwise nil 


(cons <expre6sion_l> 
<expreBeion.l> 
<expres8ion_2> 
returns 


<expreB6ion_2>) 
the head of the new list node 
the tail of the new list node 
the new liet node 


(clean-up) 

returns 


never retumB 


(consp <cxpresslon>) 

<expresslon> the expression to check 

retume t if the value is a list node, nil otherwise 


(clear) 

returns true 

side-effect clears screen in active window 


(continue) 

returns never returns 


(cleareol) 

retnms true 

side-effect clears to end of current line 


(cos <scalar_nnBber>) 

<scalar_nusber> the number 

returns the cosine of the nusber 


(cleareos) 

retnms tme 

side-effect clears to end of current window 


(cosh <scalar_nuBber>) 

<scalar_nusber> the number 

retnms the hyperbolic cosine of the number 


(clcarregion <int«ger_l><integer_2><integer_3><integer_4><lnteger_6>) 
<lmteger_l> the row in active window 
<lnt«gsr_2> the. cplnmn in active window 

<lntcger_3> the width of window region to be cleared 
<lntegar_4> the number of lines to be cleared 
<lnteger_6> the color attribute 
retnms tme 

side-ellect starting at (<lnteger_l> <lnteger_2>) , cleam 
<integer_3> positions on each of the next 
<lnteger_4> rows, using the color attribute 
<integer_6> 


(cumhllt <integer_l> <lnteger_2>) 

<lnteger_l> row Increaent 
<lnteger_2> colnan increaent 

retnms row of cursor in active window alter side-ellect 

side-ellect shllts cnmor to position: 

row • (♦ (get-row-pos) <lnteger_l>) 
col ■ (♦ (get-col-pos) <lnteger_2>) 


(date) 

retnms systes tine and date (string) 


(close <lile_pointer>) 

<lile_polnter> the llle pointer 
retnms nil 


(colhose) 

retnms column position ol cursor alter side-ellect 

side-ellect positions cursor at lelt-sargln of active 
window 


(delnn <8ymbol_l> ([{<symbol_2>}]) [{<expreB8ion>}] ) 
(delnacro <syBbol_l> ( ['{<8yBbol_2>}] ) [{<expresslon>} j ) 
<syabol_l> sysbol being defined 

<sjmbol_2> list of Iomal arguaents: 

( 


[{<farg>}] 

[hoptional [{<oarg>}] ] 
[hrest <rarg>] 

[haux [{<anx>}]] 

) 


where 


67 


<larg> 1« a lonal axguacnt 

<oarg> la an optional argnncnt 

^arg> bonnd to the reat of the argnaients 

<aux> ie an anxillary earlable 

<expreBalon> the body ot the Innctlon 

retnma <8yBbol_l> 


the Talne retnrned la the valne of a return 
Innctlon In <loop.body> 


(ellipse <lnteger_l> 

<lnteger_2> <lnteger_3> 
<lnteger_4> <lnteger_6>) 


(delete <erpresslon> <llst> [<key> <te6t>] ) 

<expresalon> the expression to delete 

<llBt> the list 

<key> the keyword ;test or ;test-not 

<test> the test innctlon (delanlts to eql) 

returns the node <llst> with the Batching expressions deleted 


<integer_l> 


<lnteger_2><integer_3> 

<lnteger_4><lnteger_6> 


2 - draw only outline (no 1111) 

3 - 1111 using current color and 

1111 Bask 

X- and y-axis coordinates ol npper-lelt 
comer ol bounding rectangle 
X- and y-axls coordinates ol lower-right 
comer ol bounding rectangle 


(do <loop_blndlng_ll8t> <loop_teBt> [<loop_body>] ) 

(do* <loop_binding_list> <loop_test> [<loop_body>] ) 

<loop_blnding_ll6t> the wariable bindings which are either: 

1) a synbol. Initialized to nil 

2) a <loop_blndlng> ol the lonn: 

(<ByBbol> <initlal> [<next>]) 

where : 

<8yBbol> la the syabol to bind 
<lnltlal> during loop Initialization. <E}rnbol> 
la set to (eval <lnltlal>) 

<next> belore each iteration, <ByBbol> Is 
set to (eval <next>) 

<loop_te8t> the loop temination teat 

11 (eral <test_expreB8ion>) Is non-nil, then 
all ol the expressions In <re8t_expreBBion> are 
ewaluated, and (eval (laBt <rest_expreBBion>)) 1b 
' returned 

<loop_body> the body ol the loop, which Is an Instance ol 
<prog_body> 


returns tme, 11 the ellipse Is successlully drawn: 

otherwise, nil 

aide ellect draws an ellipse whose center Is the center ol the 
bounding rectangle 


(eq <expres6ion_l> <expresEion_2>) 

<expreBBlon_l> the lirst expression 

<expreE6ion_2> the second expression 

returns t 11 they are equal, nil otherwise 


(eql <expression_l> <expres8lon_2>) 

<expreB8lon_l> the lirst expression 

<expreBsion_2> the second expression 

returns t 11 they are equal, nil otherwise 


returns 


11 <loop_test> activated, then the value ol this 
clause is returned; otherwise, the value returned Is 
the value ol a return lunctlon In <loop_body> 


(equal <expresaion_l> <expre88ion_2>) 

<expres8lon_l> the lirst expression 

<expresaion_2> the second expression 

returns t 11 they are equal, nil otherwise 


(dolist (<ByBbol> <llst> [<exprasslon>] } [<loop_body>] ) 

<syBbol> the sysbol to bind to each list elesent 

<llst> the list to iterate through 

<ezprcssion> the result expression (the delault Is nil) 
<loop_body> the body'ol the loop 

returns when all eleaents ol <list> have been processed, 

then (eval <expres8ion>) is returned; otherwise, 
the value retximed Is the value ol a return 
Innctlon In <loop_body> 


(dos <strlng>) 

<strlng> the DOS coBsand to execute 

returns tme or error code 


(error <8trlng> [<exproBSlon>] ) 

<atrlng> the error aessage 

<expresslon> (eval <expresaion>) Is printed alter the aessage 
returns never returns 


(errset <exprea8lon> [<pllag>]) 

<expresslon> the expression to execute 

<pllag> llag to control printing ol the error aessage 

returns the value ol the last expression consed with nil 

or nil on error 


(dotlses (<ayBbol> <expreaaion_l> [<expresslon_2>] ) [<loop_body>] ) 


<8ynbol> 


<expraa8lon. 

Cexprcaaion. 

<loop_body> 

returns 


the loop variable , which Is Initialized to 0 
and which la set to (eval (1* <ByBbcl>}) belore 
each iteration 

1> the nnsber ol tines to loop 

2> when <sysbol> is (1- <expresslon_2>) , then return 
(eval <«xprcsslon_2>) 
the body ol the loop 

when loop count satlslled, then return 
(eval <expreaalon_2>) ; otherwlae. 


(eval <expreBcion>) 

<expreBSlon> the expression to be evaluated 

returns the result ol evaluating the expression 


(evalhook <expression_l> <expreBlon_2> <expression„3> I<env>]) 
<exprasalon_l> the expression to evaluate 
<expresslon_2> wevalhook* Is set to (eval <expre 80 lon_l>) 


68 


<ex|>reftslon_3> •applyhock* Is set to (evsl <expreBsion.3>) 
<enT> the enTlronsent (delsolt Is nil) 

returns the result of eTalustin^ the expression 


(exit) 

returns never returns 


(exp <scslar_nusber>) 

<scalar.nunber> the nusber 

returns e to the <scalsr_nuaber> power 


(Iseek <lp> <integer_l> <integer_2>) 


<lp> 

<integer_l> 

<lnteger_2> 


returns 
si<le*el lect 


the lile pointer 

offset for position In file 

origin froB which offset is calculated: 

0 • origin is beginning of file 

1 • origin is current position in file 

2 - origin is end of file 
offset for position in file 

changes lile position as required for next 10 
operation 


(ftell <fp>) 

<fp> the file pointer 

(expand <integer>) returns current position of pointer in lile 

<lnteger> the nunber of segments to add 

returns the nunber of segments added 


(function <expres£ion>) 

<expreesion> the function to be quoted 

(expt <scalar.nuaber.l> <scalar.nujDber.2>) returns a function closure 

<scalar.number.l> the nunber 
<8calar.nunber.2> the power 

returns <scalar .nunber. 1> to the <scalar_nuBb€r_2> power 

(gc) 

returns nil 


(fix <8calar_nn«ber>) 

<scal&r_niiBber> the nunber 

returns li <8cal.ar_nUBber> is s <llost>. then the truncation 

to <lnteger>; ii <scalar_nuBber> is a <integer>, thei 
<scalar_nnaber> 


(gensyi [<tag>]) 

<tag> string or nunber 

returns the ne» synbol 


(llatc <expreBsion>) 

<expre88ion> the expression 

returns the nunber of characters to print <expression> 

using print 


(get-nargins) 

returns a list containing the nargins ol the current vindo* 

in the following order: npper.left row. upper.left col 
lower_right row. and lower.rlght col 


(llatsize <cxpresslon>) 

<expresslon> the expression 

returns the nunber of characters to print <expresslon> 

usin^' print 


(getbhcolor) 

returns the pixel walue of the current background color 


(float <Bcalar.nunber>) 

<scalar_nnBber> the nunber 

returns if <acalar_nnBber> is an <integer>. then the 

coresponding <float>: <scalar_nnnber> is a <float>. 
then <scalar_nnaber> 


(getcolor) 

returns the pixel walue of the current color 


(getcurcol) 

returns current colunn of cursor in actiwe window 


(floodfill <integer_l> <integer_2> <integer_3>) 

<integor_l><integer_2> x- ami y-axis coordinates of 
start point 

<lnt«ger_3> fill boundry color 

retuxna true, if the fill is successfully drawn; 

otherwise, nil 

side effect fills an area of the display naief current color 

and fill nask. starting at (<lnteger_l>. <integer_2>) . 
If this point lies Inside the figure, the Interior is 
filled. If this point lies outside, the background 
is filled. Filling stops at the fill boundry color. 


(getc arrow) 

returns current row of cursor in actiwe window 


(getkey) 

returns the next key stroke (Integer) 


69 


(getplxcl <ljiteger_l> <liiteg«r_2>) 

<integer_l><iiiteger_2> x- aiul y-*xl* coordinates 

returns If successful, the pixel Tslue st position 

(<lnteger_l>. <lnteger_2>) ; otherwise. -1 

side effect draws a line from the current position to 

coonllnate (<lnteger_l> . <integer_2>) using 
current color and line style. If no error 
occurs, lineto sets current position to 
(<lnteger_l>. <lnteger_2>) . 

(getprop <s 3 nibol_l> <sy«bol_2>) 

<syBbol_l> the sysbol 

<By»bol_2> the property syubol 

returns the property Tslne or nil 

(list <<expre6slon>}) 

<expreBslon> expressions to be combined into a list 

returns the new list 

(gettertcolor) 

returns the color attribute of actire window 

(listp <expresBlon>) 

cexpresslonX the expression to check 

returns t if the walue is a list node or nil. nil otherwii 

(go <tag>) 

<tag> the tag (quoted) 

returns newer returns 

(In <Bcalar_number>) 

<scalar_nuBber> the number 

returns the natural logarithm of <scalar_nnnber> 

(hash <syBbol> <lnteger>) 

<B 3 ™bol> the synbol or string 

<lnteger> the table size 

returns the hash index 

(load efnameX (<wflag> (<pllag>])) 

<fname> the filename string or s 3 rBbol 

<wflag> the werbose flag (default is t) 

<pflag> the print flag (default is nil) 

returns the filename 

(inagpart <co«iplex>) 

<coBplex> complex number' ' 

returns the imaginary part of <coBplex> 

(log <Bcalar_nuBber_l> <Bcalar_nnmber_2>) 

<scalar_number_l> the number 

(intern <Btring>) 

<string> the symbol's print name string 

returns the new symbol 

<scalar_number_2> the power 

returns logarithm of <scalar_noBber_i> to the base 

<Bcalar .number _2> 

(hbhit) 

returns a system-dependent nonzero walue If a key has been 

hit; otherwise, it returns 0. 

(logand <<lnteger>}) 

<lmteger> the numbers 

returns the result of the and operation 

(lambda ( [{<symbol>}] ) [{<expresBlon>}] ) 

<syBbol> the formal parameter symbol 

<azpresslon> expressions of the function body 

returns the function closure 

(logior {<integer>» 

<intcger> the numbers 

returns the result of the inclusiwe or operation 

(last <llst>) 

<Ust> the Ust 

returns the last list node In the list 

(lognot <integer>) 

<integer> the number 

returns the bitwise inwersion of number 

(length <expresslon>) 

<expression> the expression whose length is to be determined 
returns if <expresslon> is a list, string or array, then 

the length of <expresslon> ; otherwise error 

(logxor {<integer>}) 

<integer> the numbers 

returns the result of the cxclusiwe or operation 

(make-array <integer>) 

<integer> the size of the new array, assumlmng zero origin 

(llneto <lnteger_l> <lnteger_2>) 

<lnteger_l><lnteger_2> x- and y-axls coordinates 

returns true, if the line is successfully drawn; 

otherwise, nil 

returns the new array 

(sake-symbol <strlng>) 


70 


<8trlfig> 

retnmB 


the sjabol's print nane string 
the new symbol 


(■ake-«lndo« <lnteger_l> <integer_2> <iiiteger_S> <lnteger_4>) 
<ijiteg«r_l> npper-lelt row (top murgln) 

<ljiteger_2> upper-left column (left margin) 

<lnteger_3> lomer-right row (bottom margin) 

<lnteger_4> lower-right column (right margin) 

retumm true, 11 error retumm nil 

slde-ellects mete margins lor actlwe window 


(moreto <ln'.eger.l> <integer_2>) 

<lnteger_l><lnteger_2> x- and y-axls coordinates 
returns '• true 

side ellect moves current position to the point 
(<lnteger_l>. <lnteger_2>) . 


(nconc {<ll6t>]>) 

<list> lists to concatenate 

returns the result ol destructively concatenating the lists 


(nape <lunctlon_expre66lon> {<llst>]}) 

<lunctlon_expre8Blon> the function expression to be mapped 
<li8t> a list lor each argument ol the function 

returns the first list ol arguments 


(not <expreB6lon>) 
<expres6ion> 
return 


the expression to check 

t if the expression Is nil, nil otherwise 


(mapear <lunctlon_expreB8ion> {<li8t>}) 

<lunction_e:q>re8Bion> the Innction expression to be mapped 
<ll8t> a list lor each argument ol the function 
returns a list ol the values returned 


(mapl <lunction_expression> (<list>)) 

<ltinction_expre88ion> the function expression to be mapped 
<llst> a list lor each argument ol the Innction 
returns the first list .olj apgumentE 


(maplist <lunctlon_expression> {<llst>}) 

<lunction_expression> the function expression to be mapped 
<list> a list lor each argument ol the Innction 
returns a list ol the values returned 


(max <<scalar_nuaber>}) 

<scalar_nnaber> the expressions to be checked 
returns the largest number in the list 

(mem) 

returns nil 


(nth <integer> <list>) 

<lnteger> the position Index ol the element to return. 

assuming zero origin 
<list> the list 

returns 11 (length <list>) >• <integer>. the n’th car; 
otherwise nil 


(nthedr <integer> <li8t>) 

<integer> the position Index ol the sub-list to return. 

assuming zero origin 
<llst> the list 

retxims 11 (length <list>) >• <integer>. the <integer>’th; 

otherwise nil 


(null <expression>) 

<expre8slon> the list to check 

returns t 11 the list Is empty, nil otherwise 


(numberp CexpressionX) 

<expresslon> the expression to check 

returns t 11 the expression is a number, nil otherwise 


(member <eiq)resslon> <list> t<key> <test>]) 

<expreasion> the expression to find 

<Ilst> the list to search 

<key> the keyword rtest or :te8t-not 

<te8t> the test function (defaults to eql) 

returns the remainder of the list from <expresslon> 


(min (<scalar_nuaber>}) 

<scalar_nuBber> the numbers to be compared 
rctuns the smallest number in the list 


(mlnusp <scalar_nnaber>) 

<sealar_Buaber> the number to test 

returns t 11 the number Is negative . nil otherwise 


(object <selector> (cexpression)]) 

<selector> the method selector 

<expres8lon> the (optional) argument expression 

returns the value obtained by applying the method to 

list ol (eval <expression>) : 


:shov 

returns 

the object 


tclass 

returns 

the class ol 

the object 

lisnew 

returns 

the object 


;sendsiq>er CselectorX [<expres8lon>] 

<aelector> the message selector 

<expres8lon> the message arguments 

returns the result ol sending the message 


71 


<iiiteger_2><lnteger_3> 


(open* <lllc.nue>) 

<lll«_nue> the file n&ae ■trlng or sjabol 

retoms the <llle_polnter> 

alde-ellect <llle_<llrectlon> Is set to append and file position 
la set to beginning ol file 11 no existent file, 
othervlse file position Is set jnst before end of 
existent file 


<integer_ CXlnteg' r_6> 

<lnteger_6><lnteger_7> 

<integer_8><lnteger_0> 


fill Bask 

X- and jr-axls coordinates of npper-left 

comer of bounding rectangle 

X- and y-axla coordinates ol lower-right 

comer ol bounding rectangle 

X- and y-axis coordinates ol start vector 

X- and y-axls coordinates of end vector 


side effect 


tme. If the pie Is successfully drawn; 
otherwise, nil 

draws a pie -shaped wedge by drawing an elliptical arc 
whose center and end points are joined by lines. 


(openl <llle_naae>) 

<flle_naBe> the file naae string or syabol 

returns the <llle_polnter> 

side-effect <f ile_directlon> Is set to Input and file position 

is set to beginning of file 


(plusp <scnlar_nujnber>) 

<6calar_nuiiiber> the number to test 

returns t If the number Is positive, nil otherwise 


(openlo efnamei) 

<fname> the file name string or syabol 

returns the <llle_pointer> 

side-effect <f lle_dlreetlon> la set to input-output and file 
position is set to beginning of file 


(poke <integer> <e:q>resslon>) 

<lnteger> the address to poke 

<exDression> (eval <expresalon>) is the value to poke 
returns the value 


(openo cfile.namei) 

<flle_name> the file name string or symbol 

returns the <f ile_pointer> 

side-effect <flle_dlrectloA> Is set to output and file position 
Is set to beginning of file 


(prlnc <exprescion> [<lile_polnter>] ) 

<expresslon> the expressions to be printed 
<llle_polnter> the output sink (default Is standard output) 
returns the expression 

side-effect file position Is set to point to next byte after 
the last <char> In <exprcnslon> 


(or {<expresslon>}) 

<expression> the expressions to be OEed 

returns nil If all expressions evaluate to nil; 

otherwise the value of the first non-nil expression 
(evaluation of expressions stops alter the first 
expression that does not evaluate to nil) 


(print Cexpressioni (<f ile_pointer>] ) 

<expression> the expressions to be printed 
<file_pointer> the output sink (default Is standard output) 
returns the expression 

aide-effect after the last byte of cexpressioni , a CR or LF 

Is printed, and file position is set to next byte 


(peek <lnteger>) 

<lntcger> the address to peek at 

returns the val'ae'-at the specified address (Integer) 


(peek-char C<llag> [<lile_pointer>]]) 

<flag> lot skipping white space (default Is nil) 

<f lle_pointer> the Input source (default la standard input) 
returns the character (Integer) 


(prog <blnding_llst> <prog.body>) 

(prog* <blmdlng_llst> <prog_body>) 

<bindlng_llst> the variable bindings each of which is elthep: 

1) a synbol (Initialized to nil) 

2) a list whose car Is a ayabol and whose cadr 
is an initialization expression 

<prog_body> expressions to evaluate or tags (symbols) 
returns nil or the arguaent passed to the return function 


(phase <coBplex>) 

<coBplex> coaplex nnaber 

returns the phase 


(putprop <syBbol_l> <expresslon> <syabol_2>) 

<syBbol_l> the ayabol , , 

Cexpressioni the attribute pair (<syabol_2 (eval <expreosion>) 

Is addded to property list of <syabol_l> 
<ayBbol_2> the property syabol 

returns (eval <expreoslon>) 


(pie <lnteger_l> <lnteger.2> <lnteger_3> <lnteger_4> 

<lmteger_6> <lnteger_0> <lnteger_7> <integer_8> <lnteger_0> ) 


<integer_l> 


fill control paraaeter: 

2 • draw only outline (no fill) 

3 • fill using current color and 


(quote <expresalon>) 

<expression> the expression to be quoted 

returns <expresslon> nnevaluated 


72 


(ruuloB <lnteger>) 

<liiteger> the upper bonsd (integer) 

returns s rsndos nunber 


(resd I<llle_polJiter> [<expres8ion> [<nisg>]]]) 

<llle_polnter> the input source (delsult Is stsndnrd input) 
<expre8Bion> the rslue to return on end ol lile (delsult is nil) 
<rflsg> recursive resd llsg (delsult is nil) 

returns <stress_heed_expre88lon> , else (evsl <expres8lon>) 

side'cllect lile position is set to next bjrte slter Isst byte 
the expression resd 


(resprop <Byiibol_l> <sy*bol_2>) 

< 83 rBbol_l> the sysbol 

<S3r*bol_2> the property sysbol 

returns nil 

slde-ellect the sttribnte psir (<syBbol.2 (evsl <expresslon>) 

4. 1re\n the iiroDertv list ol <SV»bol_l> 


(restorescr) 

returns true 

side-ellect restores textport screen Issge previously ssved by 
(ssvescreen) 


(resd-chsr [<lile_pointer>] ) 

<llle_pointer> the input source (delsult is stsndsrd input) 
returns the chsrscter (integer) 

side-ellect lile-posltion is set to next byte 


(resd-line (<lile_polnter>] ) 

<lile_pointer> the input source (delsult is stsndsrd input) 
returns sll <chsr> in <stresB> up to LF or LF/CR 

side-ellect lile position is set to next byte slter LF 

or LF/CR 


(return [Cexpressioni] ) 

<expres8lon> in the scope ol prog or prog*, this estsbllshes 
(evsl <expreeslon>) ss the vslue returned; 
otherwise undelined 
returns never returns 


(reverse <ll8t>) 

<liBt> the list to reverse 

returns s new list in the reverse order 


(reslpsrt <coBplex>) j ■ 

<coBplex> coBplex nuaber 

returns the reslpsrt ol <coaplex> 


(rowhoDe) 

returns row position ol cursor slter side-ellect 

side-ellect positions cursor st top-nsrgin ol sctive 
window 


(rectsngle <integer_l> 

<lnteger_2> <lnteger_3> 
■<integer_4> <integer_6>) 


<lnteger_l> 


<integer_2xiuteger_3> 

<lnteger_4><lntegeii„p> 


1111 control psrsaetcr: 

2 • drew only outline (no 1111) 

3 - 1111 using current color and 

1111 BSSk 

X- snd y-sxls coordlnstes ol upper-lelt 
comer ol bounding rectsngle 
X- sad y-sxls coordlnstes ol lower-right 
comer ol bounding rectangle 


(rplaca <list> <expreBslon>) 

<liEt> the list node 

<expression> the new value lor the car ol the list node 

returns the node <llBt> whose car is (evsl <expression>) 


(rplacd <li8t> <expresslon>) 
<llst> the list node 


<eiq>resslon> 

returns 


the new value lor the cdr ol the list node 
the node <list> whose cdr is (evsl <expresslon>) 


returns tme, 11 the rectangle is successlully drawn: 

otherwise, nil 

side ellect dmws a rectsngle using current color and line 
style 


(savescr) 

returns tme 

side-ellect noves textport screen Insge into unused video Benory 


(rsB (<lnteger>}) 

<lnteger> the nnnbers 

returns the result ol the resainder operation 


(scrolldown <lnteger>) , . 

<lnteger> the nuaber ol lines to scroll 

returns systea-dependent integer 

side-ellect scmlls the active window by <lnteger> lines 


(reaove <expresslon> <llst> (<key> <test>]) 


<exprcsslon> 

the expression to delete 

(scrollup <lnteger>) 

<Ust> 

the 

list 

<integer> 

the nuaber ol lines to scroll 

<key> 

the 

keyword :test or :test-not 

returns 

systea-dependent Integer 

<t«st> 

the 

test Innctlon (delaults to eql) 

side-ellect 

scrolls the sctive window by <integer> lines 

returns 

the 

list with the Batching expressions deleted 




73 


<lnteger>) 

the color attrlbate lor actlee window 
true 


(wet <expr««aloa_l> <expreaaion_2>) 

<ejcpreaalon_l> (cwal <expraBalos^l> la a syabol, elae error 
<expraaalon_2> walna ol (awal <expreBalon.l>} la aet to 
(eral <expresalon>) 
retoma (ewal <expreaalon_2>) 


(aettextcolor 

<lnteger> 

retnms 


(aetbkcolor <lnteger_l>) 

<lnteger_l> the dealred backgroond color 
retoma tme 

aide ellcct In graphics node all background pixels are 
luedlatelj changed 


(setcllprgn <lnteger_l> <lnteger_2> <lnteger_3> <lnteger_4>) 

<lnteger_l><lnteger_2> x- and y-axle coordinates ol npper-lelt 
comer ol clip region 

<lnteger_3><lnteger_4> x- and y-axls coordinates ol lower-right 
comer ol clip region 

retnms tme 

side ellcct Units the display ol graphic objects to those 
coaponents within the clip region 


(setcolor <lnteger_l>) 

<lnteger_l> the color nnnber (nasked to be In range) 
retnms tme 


(setcnrsor <lnteger_l> <lnteger_2>b 
<lnteger_l> the row In active window 
<lnteger_2> the colnan In active window 
return tme 

slde-ellect positions the cursor In the active window 
at (<lnteger_l> <lnteger_2>) 


(setvldeonode 

<integer> 

returns 

slde-ellects 


<lnteger>) 

the selected graphics node 
nil 

systea-dependent nodlllcatlons ol screen 


(setvlewport <lnteger_l> <lnteger_2> <lnteger_3> <lnteger_4>) 

<lnteger_l><lnteger_2> x- and y-axls coordinates ol npper-lelt 
comer ol viewport 

<lnteger_3><lnteger_4> x- and y-axls coordinates ol lower-right 
comer ol viewport 

returns tme 

side ellect Units the display ol graphic objects In precisely 
the sane nanner as setcllprgn. and then sets the 
logical origin to point (<lnteger_l>. <lnteger_2>) 


(sin <scalar_nnBber>) 

<scalar_nuBber> the nnnber 
retnms the sine ol the nnnber 


(slnh <scalar_nnBber>) 

Cscalar.nnnberx the nnnber 

retnms the hyperbolic sine ol the nnnber 


(sqrt <scalar_nnnber>) 

<8calar.nnnber> the nnnber 

retnms the square root ol the nnnber 


(setl {<placelom> <expresslon>}) 

<placelom> the Held speclller (quoted): 

<synbol> set valne ol a syabol 

(car <cxpreaBlon>) set car ol a list node 

(cdr <cxpresslon>) set cdr ol a list node 

(nth <lnteger> <expression>) set nth car ol a list 
(arsl <qmay> <lnteger>) net nth slenent ol an array 
(getprop <syabol> <expresslon>} net value ol a property 
(synbol-valne Csynbolx) net valne ol a syabol 
(synbol-pllst <syabol>) set property list ol a synbol 
^*^resslon> the valne ol <placelom> Is (aval <expresslon>) 
returns (eval <expresslon>) 


(strcat {<strlng>}) 

<strlng> the strings to concatenate 

retnms the result ol concatenating the strings 


(string <lnteger>) 

<lnteger> a snail Integer 

retnms the one character string whose ASCII code Is 

<lnteger> 


(setplxel <lnteger_l> <lnteger_2>) 

<lnteger..l><lnteger_2> x- and y-axls coordinates 
retnms tma 

side ellect sets the pixel at (<lnteger_l>, <lnteger_2>) 
to cnrrent color. 


(snblls <allst> 
<slint> 
<expresslon> 
<key> 

<test> 

retnms 


<expreaslon> [<key> <test>l) 
the association list 

the expression In which to do the snbstltntlons 
the keyword :test or :test-not 
the test Innctlon (delanlts to eql) 
the expression with- snbstltntlons 


(setq <<syabol> 
<syabol> 
<exprasslon> 
returns 


<expresslon>>) 

the synbol being set 

valne ol <nynbol> la set to (eval <expresslon>) 
(eval <expreaalon>) 


(snbst <to> <lroB> <expresBlon> [<key> <test>]) 


<to> 

the 

new expression 

<fro»> 

the 

old expression 

<cxpr«sslon> 

the 

expression in which to do the snbstltntlons 

<it€y> 

the 

keyword rteat or :test-not 

<t«at> 

the 

test Innctlon (delanlts to eql) 

r«tqj-iia 

the 

expression with substitutions 


74 


(■abstr <«trliig> <integer_l> (<lJiteger_2>] ) 

'<strliig> Uie string 

<liiteger_l> the starting position 

<lnteger_3> the length (delanlt Is rest ol string) 

retnms substring starting at <lnteger_l> lor 

<lnteger_2> 


(sjnbol-nase 

<s]mbol> 

returns 


<S3mbol>) 

the sjnbol 

the sjnbol's print nane 


(sjabol-pllst <sy*bol>) 

< 87 abol> the syabol 

returns the synbol's property list 


(type-ol <expresslon>) 

<expression> the expression to return the type ol 
retnms nil 11 the value Is nil otherwise one ol the syabols 

‘.SYMBOL lor symbols 
: OBJECT lor objects 
:CONS lor conses 

rStJBR lor bnllt-lns with evaluated arguments 

:FSt>BR lor built-ins with nnevalnated arguments 

: STRING lor strings 

iFIXNUM lor Integers 

'.FLONUM lor lloatlng point numbers 

: COMPLEX lor cosplex numbers 

:FILE lor llle pointers 

: ARRAY lor arrays 


(symbol-value <8ynbol>) 

<symbol> the symbol 

retnms the symbol's value 


(wrlte-char <char> 
<ehar> 

<lile_polnter> 

retnms 

slde-cllect 


[<llle_polnter>] ) 
the character to put (Integer) 
the output sinh (delault Is standard output) 
the character (Integer) 
llle polstlon it set to next byte 


(sysbolp <expresslon>) 

<expression> the expression to check 

retnms t 11 the expression Is a symbol, nil otherwise 


(zerop <8calar_number>) 

<8calar_nnnber> the number to test 

returns t 11 the number is zero, nil otherwise 


(tan <scalar_nnmber>) 

<scalar_number> the nuobel' ■ 

returns the tangent ol the nuober 


(tanh <sc alar .number >) 

<scalar_number> the number 

returns the hyperbolic tangent ol the number 


(terprl (<llle.pointer>]) 

<llle_polntar> the output sink (delault is standard output) 
returns nil 


(throw <tag> [Cs^rsMjLQ]^] ) 

<tag> the catch tag 

<a]qirsssioa> (aval <s]q>resslon>) is the value lor the associated 
catch to return; 
otherwise nil 

returns never retnms 


(top-level) 

returns never returns 


(transcript [<laase>]) 

<lnase> llle name string or symbol 

(11 missing, close current transcript) 
returns t 11 the transcript Is opened, nil 11 It Is closed 


(tstanp) 

returns time stamp (string) 


76 









.'. '• »■<; k« • «f.>-*t, •■■1 

(»r, ■"»■".■,<«»*»<<?»,'» S'K^»#^'i> *>.'»-'"v4'^* 

^ ii*ia '■■«'•*/ .^> .iw^JJt)* «<• <»»»»*• idHip'*''* ‘ 

f*TL«t»*a -wM' t.i ■ • 

vt<v<l„vi 

<t»J TXt’ W 
.«•« tTAuO 

', ^ » iU((t t.iti ‘ /•>* '■‘'' 

., , , 4 *(>-) w.'« . 

•'’J wi'^ST’ ) 
i. . - .' ■ C->?J5*k]V,''^ '/ilr^lka 
I'**' fffrtfsijW* 

♦ ,»»»iktr t!l.,yT|ICv^ ', 

I ‘OH t(tl tUi^' 














V*,’ :, 


■f-’i •r;-- >:•■ 

*“ " '* ,i.:^.» iW . j»iy .: .■' ; ' -■ ■ )■» 


» • • a ’ I* ;> ■ 

• ■ ua ■ » '■“ ' 


,.t.> 


iit,H 

> 


..Ir:. a» ••i.^ :'‘i^ifu 4iti Mi't* 

a:*.-c ’ .t- ■> »J*'5 -i«, t4>vi*''^*^^*^ 








* .1 ‘ i^_4Hi^!<5eI.< • W' pbti^lfrfy 




1 1 • I ir wfts^ I i 








-w,. »«.»*■, ,., - -l.JSS S'SByS^V.^i 


■ : » 1> 


•'" ■■' ' r^/ipjKI« ' 4A' ,' 


i(.VY »^*K»''.w«a^»J' 





«*|. a* ■aatmH#’ a /I.^ •Wa«>\^<, ■ l?W ■ f- iCT' 

' •'"' ' ' • ' ■ ’',.*^ri^®T^' '*^''.... 

U ' ■^t94wa Mt ^a'.iflWV’^* ' ' 


I »C*V» X^'-'*-*'*-'' '^ ' 


;. %i.fl 


•1 , -* ' '■ ■ 

• i 'fci • ■ 

- f.> • • ‘ 

• V* i v\ ^ 


•t 


Ikl .' 


<A a i,-- 
*- ■-''(.*» • *' '■ 




•ft*’ 


"'• ■ •• It a ^af"; ’ • 

«•' n a| ■/*> 

« ;' < . • • *a 4uiJ 

‘:>. 44-. •■:'*■ •■- ■•.•' 


LyC. ^^ 4 ^l• ' ftlV* 

»• tf, 'l#k..,.u^} ,* 

}Jpt#4.5r|;. 






'v> 


'W 


■ ‘-•I ■■ «• 5 


# ^ 

■ ^ »»y.y4jklft»a 


-.i* . ja' .^i al 

•'■ ■ •#. 4 •» 


J*i »f 




..-aWtMi' '»‘4 a I .-jT' ” *%iBi^r. 

nVfif^ vftM.*' W|)^ 

**|, <%ftii.. -'V‘(.ft.jh |4 .♦(W'h 

■ . -'r -<'V Tilt' J'kY 

• *i*4f-»» '•■‘irta ‘4a(ft/ 4'.v -^Jr^ 

rt(l^..ftl^^'^‘^-:4*' ■‘ft ■T'klt*.; ■ 


- i • 



^l■''^ •■ . 

■■■A-’f j; 

. ... 'Hki?**' <• ■ ofl-w.;. - 

.. '.i— .a '.-a a.k. " A.a. .^- . Jlhl': .4. '..A/iit. 1^ 




'v <*i*»*-'**' 


1.^: ■' ""'.'Ob'' ■ , 


s.,.,- 





NIST-1 14A 
(REV. 3-90) 


U.S. DEPARTMENT OF COMMERCE 
NATIONAL INSTITUTE OF STANDARDS AND TECHNOLOGY 

BIBLIOGRAPHIC DATA SHEET 


1. PUBUCATION OR REPORT NUMBER 

NISTIR 4388 


2. PERFORMING ORGANIZATION REPORT NUMBER 


3. PUBUCATION DATE 

SEPTEMBER 1990 


4. TITLE AND SUBTITLE 


AMPLE Core Interpreter: User's Guide 


5. AUTHOR(S) 

J. C. Boudreaux 


6. PERFORMING ORGANIZATION (IF JOINT OR OTHER THAN NIST, SEE INSTRUCTIONS) 

U.S. DEPARTMENT OF COMMERCE 

NATIONAL INSTITUTE OF STANDARDS AND TECHNOLOGY 
GAITHERSBURG, MD 20890 


7. CONTRACT/GRANT NUMBER 


a. TYPE OF REPORT AND PERIOD COVERED 


3. SPONSORING ORGANIZATION NAME AND COMPLETE ADDRESS (STREET, CITY, STATE, ZIP) 


10. SUPPLEMENTARY NOTES 


11. ABSTRACT (A 200-WORO OR LESS FACTUAL SUMMARY OF MOST SIGNIFICANT INFORMATION. IF DOCUMENT INCLUDES A SIGNIFICANT BIBUOGRAPHY OR 
UTERATURE SURVEY, MENTION IT HERE.) 

The Automated Manufacturing Programming Language Environment 
(AMPLE) system was developed in the Center for Manufacturing 
Engineering to provide a uniform environment for the construction 
of control interfaces to industrial processes. The AMPLE Core 
Interpreter, Version 1.0 is a working prototype, implemented in 
Microsoft C 5.0 for PC/AT-class personal computers under MS-DOS. 

The User's Guide is an introduction to the prototype which is 
being circulated at this time to provide the manufacturing 
community and other potential users with an operational specifi- 
cation of AMPLE. For further information or to obtain a copy of 
the prototype on a 5.25" double sided/double density floppy 
diskette, please write to: 

J. C. Boudreaux 

Center for Manufacturing Engineering 
National Institute of Standards and Technology 
Bldg 233, Room A107 
Gaithersburg, MD 20899 


1Z KEY WORDS (6 TO 12 ENTRIES; ALPHABETICAL ORDER; CAPITAUZE ONLY PROPER NAMES; AND SEPARATE KEY WORDS BY SEMICOLONS) 


AMPLE; programming language environment; very-high level language. 


13. AVAILABIUTY 

UNUMITED 

FOR OFFICIAL DISTRIBUTION. DO NOT RELEASE TO NATIONAL TECHNICAL INFORMATION SERVICE (NTIS). 


JL 


ORDER FROM SUPERINTENDENT OF DOCUMENTS, U.S. GOVERNMENT PRINTING OFFICE, 
WASHINGTON, DC 20402. 

ORDER FROM NATIONAL TECHNICAL INFORMATION SERVICE (NTIS), SPRINGFIELD, VA 22161. 


14. NUMBER OF PRINTED PAGES 

84 


15. PRICE 


AOS 


ELECTRONIC FORM 


> 'V «S10fItK5li53i^ 


d»4HWBMPrT 


'•^Vi nt34?t3r*r3e 


nOTJRKJgSrit 


"fei^iaK)0 ^0ll4ari^A^a 343 





yj®0J'0^O3Ti»^ ' '« 

r^m A cm ofH«iAri0Of jats 


WttJKJtwriiiT <«** 

■ ' 


#« 




“^wTJy^t* . ^"^’aS wri!'i ■■|¥vTf>rtir?i^»» (ii w^ioll!^ 

' ,: ■■ v ■' .. V ,'■■■'' ■'; '.^1 




'>*> 




■Vf. ,■„ . '.. |.' ; 





■^o '•T^n^KnB' . "ITt li^ /> -*< 


•'* • . #'--,4L 

: •^,,;vs1:^ ' , ri , .^'i ~ ■ '’M 


•Jr..-ifn^ ‘j I 'tui fe»4Aiwft44^ 

r.-.'/ -fO^' oil:^ ftr 

'.o •'• ir/ Jaf>':):3 <'•■' MiJRioO’xlvn^ ^t'otifU? « t. .ivotq f:7t t^i7ilr«i>aiL 

lu^iKA 3if:‘ . . o.r, s'posiJUfiint ■ Lmpnas^.. 

({ nr»,;A'' ’;''9.-:'.T-' t.^'qiT^'^ojO’xq ^'*l'|'w.oI<f:t»V 


' ''-Z3^ ^-:»br!.ii ^i'xii:*uqmoD XirriOPTwa^' ^0l O.S 

noiS 




doj.ti'» foiti s.dLr noi5 .»:i<X»c^f Jnl' flf.5? 

*;?M, I-. .■>^K:l:i;fr^^/ff irttf --ftivcrici :tis 

70 .j n!c4u»-* o^- ‘lO^floJt^sir.co'i.fti. -"4d:hrfr5 , i'^n44.' 




7ooJ.onii:?oT' fiiaa aZrxcfafCJ^a Ifc, fsotii.iJfiK 

♦ v&iA'ttowrfT '!?b'Car'li 


H.tlU' 


rr>.. ■ ~ 

I 

r»>A I 


r.'i^.^vi3r?rar?5!J4«uPr-' 

d .i"’ , , ' ; ■/ 

•^'•4<4iis*r X. 'wJ i irr^.iw ^XvfHk 

~ - - i n i -■■ — r '■ ••' ■’ '"' — ■ - y.,.iii.J« 


■mu-, oi’/Hif »»*:/•> ^o#o«^.^»^>mlf‘('''i4:»«,. 




L 


vjrrm iwif ■ ■‘-wn <Ji ATiW^^woo 


"I 




.;y^^‘ 






'.'V> 




i 


