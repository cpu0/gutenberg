AD-A240 849 



ENTATION PAGE 


Form Approved 
OPM No. 0704-018$ 


Pub«c 'eooflmg sun»n la ms coHectco ol rtomiooo s Mtinaiad !0 average t hour per response mousing me nme tor reviewing net ructions, sevcting eiMng 0su toucee gt iemg and maramhfaM^iB 
needed, ana reviewing me coSecion a mlormation. Send comments regaromg ms Durden estimate or any oiner aspeol ot ms coteotcn o< Mormshon. ndudmg suggsstiors tor reOucsig ms Durden, to Waeranpon 
Hesoguaners Service Directorate lor mk>rma!»n Cceraoons and Reports, 1 215 Jerterson Dave Hgnway Suae 1 20 a, Arlington. VA 22202 -A302. and to the Otfice ot ntormason and Regulatory Allan. Oltice or 
Management and Budget, Waslimgton. OC 20603. 


1 AGENCY USE ONLY (Leave Blank) 


2. REPORT DATE 


3. REPORT TYPE AND DATES COVERED 

Final: 24 Jul 1991 to 0" Jun 1993 


4 TITLE AND SUBTITLE 

Ada Compiler Validation Summary Report: ddc international a/s, DACS 

Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, Version 

Version 4.6.4. MRI IEEE 685 (SECURE MODE), Sun-3/50 (Host) to 
Mntnrula MVME1-+3 Board ( Ta roof) . — _ _ 


6 AUTHOR(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7 PERFORMING ORGANIZATION NAME(S) AND ADDRESS) ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm A266 
Gaithersburg, MD 20899 USA 


9 SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS) ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, RM 3E114 
Washington, D C. 20301-3081 



8 PERFORMING ORGANIZATION 
REPORT NUMBER 

NIST90DDC500 12 1.11 


10 SPONSORING/MONITORING AGENCY 
REPORT NUMBER 



12a OISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 


12b DISTRIBUTION COOE 


13 ABSTRACT (Maximum 200 words) 

DDC International A/S, DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, Version 4.6.4, MRI IEEE 695 
(SECURE_MODE), Gaithersburg, MD, Sun-3/50 running SunOS Release 4.0_Export (Host )to Motorola MVME143 Board 
(68030/68882)(Target), ACVC 1.11, 9L0502S1.11160 


ryvnr 

LJ :! A -Vu* 

^ cLKCTt: £p 

k SEP 19 19911 1 


91-11070 

II Hill ](■■! ..... .... m 


14 SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability. Val Testing, Ada Val Office. Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


18 SECURITY CLASSIFICATION 


UNCLASSIFED 


19 SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 


16 PRICE COOE 


20 LIMITATION OF ABSTRACT 


NSN 7540-01-280-550 


— Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std 239-128 



























AVF Control Number: NIST90DDC500_12_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 1991-04-22 
AFTER ON-SITE: 1991-05-02 
REVISIONS: 1991-07-24 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910502S1.11160 
DDC International A/S 

DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, 
Version 4,6.4, MRI IEEE 695 (SECURE_MODE) 
Sun-3/50 => Motorola MVME143 Board (68030/68882) 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 




AVF Control Number: NIST90DDC500_12_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on May 2, 1991. 

Compiler Name and Version: DACS Sun-3/SunOS to 68030 Bare Ada 

Cross Compiler System, Version 
4.6.4, MRI IEEE 695 (SECURE_MODE) 

Host Computer System: Sun-3/50 running SunOS Release 

4.0_Export 

Target Computer System: Motorola MVME143 Board (68030/68882) 


A more detailed description of this Ada implementation is found in 
section 3.1 of this report. 

As a result of this validation effort, Validation Certificate 
910502S1.11160 is awarded to DDC International A/S. This 
certificate expires on March 01, 1993. 














DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the 
customer. 


DECLARATION OF CONFORMANCE 


Customer and Certificate Awardee: DDC International A/S 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

ACVC Version: 1.11 

Ada Implementation: 

Compiler Name and Version: DACS Sun-3/SunOS to 68030 Bare Ada 

Cross Compiler System, Version 
4.6.4, MRI IEEE 695 (SECURE_MODE) 

Host Computer System: Sun-3/50 running SunOS Release 

4.0_Export 

Target Computer System: Motorola MVME143 Board (68030/68882) 


Declaration: 

I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
8652-1987 in the implementation listed above. 



Customer Signature 

Company DDC International A/S 

Title Project Manager 


Date 




TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION . 1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-3 

.3.3 TEST EXECUTION.3-3 

APPENDIX A.A-l 

MACRO PARAMETERS.A-l 

APPENDIX B.B-l 

COMPILATION SYSTEM OPTIONS . B-l 

LINKER OPTIONS . B-2 

APPENDIX C.c-1 

APPENDIX F OF THE Ada STANDARD.C-1 

























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro90], A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.2 REFERENCES 

[Ada33] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 


1-1 



FUG39] Ada Compiler Validaticn Capability User's Guide . 21 June 
1989/ 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, 3, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. Class B 
tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify*that 
all violations of the Ada Standard are detected. Some of the class 
B tests contain legal Ada code which must not be flagged illegal by 
the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG39]) . 


1-2 



In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to 
be added to a given host and target computer 
system to allow transformation of Ada programs 
into executable form and execution thereof. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


The means for testing compliance of Ada 
implementations, Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user's guide and the template for 
the validation summary (ACVC) report. 


Ada An Ada compiler with its host computer system and 

Implementation its target computer system. 


Ada The part of the certification body which carries 

Validation out the procedures required to establish the 

Facility (AVF) compliance of an Ada implementation. 


Ada The part of the certification body that provides 

Validation technical guidance for operations of the Ada 

Organization certification system. 

(AVO) 

Compliance of The ability of the implementation to pass an ACVC 
an Ada version. 

Implementation 


Computer 

System 


Conformity 


Customer 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program and 
also for all or part of the data necessary for 
the execution of the program? executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including 
arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process or service of 
all requirements specified. 

An individual or corporate entity who enters into 
an agreement with an AVF which specifies the terms 
and conditions for AVF services (of any kind) to 



be performed. 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 


Validation 


Withdrawn 

test 


A formal statement from a customer assuring that 
conformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
implementation. 

Software that controls the execution of programs 
and that provides services such as resource 
allocation, scheduling, input/output control, 
and data management. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
i>ucce»s£uxiy either oy AVF testing or by 
registration [Pro90], 

The process of checking the conformity of an Ada 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


1-4 





CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 93 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-03-14. 


E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly reterenced in the 
format Al-dddd. For this implementation, the following tests were 
inapplicable for the reasons indicated; references to Ada Issues 
are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L. 

. Y 

(14 

tests) 

C35705L. 

. Y 

(14 

tests) 

C35706L. 

. Y 

(14 

tests) 

C35707L. 

. Y 

(14 

tests) 

C35708L. 

. Y 

(14 

tests) 

C35802L. 

. Z 

(15 

tests) 

C45241L. 

. Y 

(14 

tests) 

C45321L. 

. Y 

(14 

tests) 


2-1 




C45421L..Y (14 tests) C45521L..Z (15 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 

C24113I..K (3 TESTS) USE A LINE LENGTH IN THE INPUT FILE WHICH 

EXCEEDS 126 CHARACTERS. 

THE FOLLOWING 20 TESTS CHECK FOR THE PREDEFINED TYPE 
LONG_INTEGER: 

C35404C C45231C C45304C C45411C C45412C 

C45502C C45503C C45504C C45504F C45611C 

C45613C C45614C C45631C C45632C B52004D 

C55B07A B55B09C B36001W C86006C CD7101F 

C35404D, C45231D, B86001X, C86006E, AND CD7101G CHECK FOR A 

PREDEFINED INTEGER TYPE WITH A NAME OTHER THAN INTEGER, 
LONG_INTEGER, OR SHORT_INTEGER. 

C35713B, C45423B, B86001T, AND C86006H CHECK FOR THE PREDEFINED 
TYPE SHORT_FLCAT. 

C35713D AND B86001Z CHECK FOR A PREDEFINED FLOATING-POINT TYPE 
WITH A NAME OTHER THAN FLOAT, LONG_FLOAT, OR SHORT_FLOAT. 

C45531M, C45531N, C455310, C45531P, C45532M, C45532N, C45532C, 

AND C45532P CHECK FIXED-POINT OPERATIONS FOR TYPES THAT REQUIRE 
A SYSTEM.MAX_MANTISSA OF 4 7 OR GREATER. 

C45624A AND C45624B CHECK THAT THE PROPER EXCEPTION IS RAISED IF 
MACHINE_OVERFLOWS IS FALSE FOR FLOATING-POINT TYPES; FOR THIS 
IMPLEMENTATION, MACHINE_OVERFLOWS IS TRUE. 

C4A013B CONTAINS THE EVALUATION OF AN EXPRESSION INVOLVING 

'MACHINE_RADIX APPLIED TO THE MOST PRECISE FLOATING-POINT TYPE. 
THIS EXPRESSION WOULD RAISE AN EXCEPTION. SINCE THE EXPRESSION 
MUST BE STATIC, IT IS REJECTED AT COMPILE TIME. 

B86001Y CHECKS FOR A PREDEFINED FIXED-POINT TYPE OTHER THAN 
DURATION. 

C96005B CHECKS FOR VALUES OF TYPE DURATION'BASE THAT ARE OUTSIDE 
THE RANGE OF DURATION. THERE ARF. NO SUCH VALUES FOR THIS 

IMPLEMENTATION. 

CA2009C AND CA2009F CHECK WHETHER A GENERIC UNIT CAN BE 

INSTANTIATED BEFORE ITS BODY (AND ANY OF ITS SUBUNITS) IS 
COMPILED; THIS IMPLEMENTATION CREATES A DEPENDENCE ON GENERIC 
UNITS AS ALLOWED BY AI-00408 AND AI-00506 SUCH THAT the 

COMPILATION OF THE GENERIC UNIT BODIES MAKES THE INSTANTIATING 
UNITS OBSOLETE. (SEE SECTION 2.3.) 


2-2 



CD1009C USES A REPRESENTATION CLAUSE SPECIFYING A NON-DEFAULT 
SIZE FOR A FLOATING-POINT TYPE. 

CD2A34A, CD2A84E, CD2A34I..J (2 TESTS), AND CD2A340 USE 
REPRESENTATION CLAUSES SPECIFYING NON-DEFAULT SIZES FOR ACCESS 
TYPES. 

THE FOLLOWING 264 TESTS CHECK FOR SEQUENTIAL, TEXT, AND DIRECT 
ACCESS FILES: 


CE2102A. 

.C 

(3) 

CE2102G. 

. H 

(2) 

CE2102K 



CE2102N. 

. Y 

(12) 

CE2103C. 

. D 

(2) 

CE2104A. 

. D 

(4) 

CE2105A. 

. B 

(2) 

CE2106A. 

. B 

(2) 

CE2107A. 

.H 

(8) 

CE2107L 



CE2108A. 

.H 

(8) 

CE2109A. 

• C 

(3) 

CE2110A. 

• D 

(4) 

CE2111A. 

T 

• -i. 

(3) 

CE2115A. 

. B 

(2) 




CE2120A. 

. B 

(2) 

CE2201A. 

.C 

(3) 

EE2201D. 

.E 

(2) 

CE2201F. 

. N 

(9) 

CE2203A 



CE2204A. 

.D 

(4) 

CE2205A 



CE2206A 



CE2203E 



CE2401A. 

. C 

(3) 

EE2401D 



CE2401E . 

. F 

(2) 

EE2401G 



CE2401H. 

. L 

(5) 

CE2403A 



CE2404A. 

. B 

(2) 

CE2405B 



CE2406A 



CE2407A. 

• B ( 2 ) 

CE2408A. 

. B 

(2) 

CE2409A. 

• B 

(2) 

CE2410A. 

. B 

(2) 

CE2411A 



CE3102A. 

. C 

(3) 

CE3102F. 

.H 

(3) 

CE3102J. 

.K 

(2) 

CE3103A 



CE3104A. 

. C 

(3) 

CE3106A. 

. B 

(2) 

CE3107B 



CE3108A. 

. B 

(2) 

CE3109A 


CE3110A 



CE3111A. 

. B 

(2) 

CE3111D. 

.E 

(2) 

CE3112A. 

. D 

(4) 

CE3114A. 

. B 

(2) 

CE3115A 



CE3119A 





EE3203A 



EE3204A 



CE3207A 



CE3208A 



CE3301A 



EE3301B 



CE3302A 



CE3304A 



CE3305A 



CE3401A 



CE3402A 



EE3402B 



CE3402C. 

.D 

(2) 

CE3403A. 

• C 

(3) 

CE3403E. 

.F 

(2) 

CE3404B. 

.D 

(3) 

CE3405A 



EE3405B 



CE3405C. 

.D 

(2) 

CE3406A. 

.D 

(4) 

CE3407A. 

.C 

(3) 

CE3408A. 

.c 

(3) 

CE3409A 



CE3409C. 

. E 

(3) 

EE3409F 



CE3410A 



CE3410C. 

.E 

(3) 

EE3410F 


CE3411A 



CE3411C 



CE3412A 



EE3412C 



CE3413A. 

.C 

(3) 

CE3414A 



CE3602A. 

.D 

(4) 

CE3603A 



CE3604A. 

. B 

(2) 

CE3605A. 

.E 

(5) 

CE3606A. 

. B 

(2) 




CE3704A. 

• F 

(6) 

CE3704M. 

.0 

(3) 

CE3705A. 

.E 

(5) 

CE3706D 



CE3706F. 

.G 

(2) 

CE3804A. 

. P 

(16) 

CE3805A. 

. B 

(2) 

CE3806A. 

. B 

(2) 

CE3806D. 

.E 

(2) 

CE3806G. 

.H 

(2) 

CE3904A. 

. B 

(2) 

CE3905A. 

.C 

(3) 

CE3905L 



CE3906A. 

.C 

(3) 

CE3906E. 

• F 

(2) 




CE2103A..B AND CE3107A EXPECT THAT NAME_ERROR IS RAISED WHEN AN 
ATTEMPT IS MADE TO CREATE A FILE WITH AN ILLEGAL NAME; THIS 
IMPLEMENTATION DOES NOT SUPPORT THE CREATION OF EXTERNAL FILES 
AND SO RAISES USE_ERROR. (See section 2.3.) 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 70 tests. 


2-3 




The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B26001A 

B26002A 

B26005A 

B28003A 

B29001A 

B33301B 

B35101A 

B37106A 

B37301B 

B37302A 

B38003A 

B38003B 

B38009A 

B33009B 

B55A01A 

B61001C 

B61001F 

B61001H 

B61001I 

B61001M 

B61001R 

B61001W 

B67001H 

B83A07A 

B83A07B 

B83A07C 

B83E01C 

B83E01D 

B83E01E 

B85001D 

B85008D 

B91001A 

B91002A 

B91002B 

B91002C 

B91002D 

B91002E 

B91002F 

B91002G 

B91002H 

B91002I 

B91002J 

B91002K 

B91002L 

B95030A 

B95061A 

B95061F 

B95061G 

B95077A 

B97103E 

B97104G 

BA1001A 

BA1101B 

BC1109A 

BC1109C 

BC1109D 

BC1202A 

BC1202F 

BC1202G 

BE2210A 

BE2413A 



"PRAGMA ELABORATE (REPORT)" has been added at appropriate points in 
order to solve the elaboration problems for: 

C83030C C86007A 


BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 


The value used to specify the collection size has been increased 
from 256 to 324 take alignment into account for: 

CD2A83A 

CE2103A..B and CE3107A abort with an unhandled exception when 
USE_ERROR is raised on the attempt to create an external file (see 
2.2). The AVO ruled that these tests are to be graded as 
inapplicable. 


2-4 









CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The executable files were prepared on the Sun-3/50 host computer. 
The target linker used was developed by Microtech Research Inc. 
and is called "lnk6Sk". The linker produces an S-record format 
module that prior to being loaded is packed by a DDC-I developed 
tool. The executables were transferred via an RS232 serial line 
from the Sun-3/50 (host) to the Motorola MVME143 Board 
(68030/68882) (target); this RS232 line is used by a downloader 
on the host for communication with the monitor on the target. The 
serial RS232 line is also used for communication between the Ada 
program running on the target board for TEXT_IO communication 
with the downloader on the host which captures the output. 

The DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, 
Version 4.6.4, MRI IEEE 69 5 (SECURE_MODE) was executed on the 
target board with the following: 

Motorola MVME143 Board (68030/68882) 

One internal timer 
One serial port 
4MB RAM 

For each category, a command file was generated that loaded and 
executed every program. 

For a point of contact for technical information about this Ada 
implementation system, see: 

In the U.S.A.: 


Mr. Larry Price 
DDC-I, Inc. 

9630 North 25th Avenue 
Suite #118 

Phoenix, Arizona 85021 
Mailing address: 

P.O. BOX 37767 
Phoenix, Arizona 85069-7767 
Telephone: 602-944-1883 

Telefax: 602-944-3253 

In the rest of the world: 


3-1 







Mr. Svend Bodilsen 
DDC International A/S 
Gl. Lundtoftevej IB 
DK-2800 Lyngby 
DENMARK 

Telephone: + 45 45 87 11 44 
Telefax: + 45 45 87 22 17 

For a point of contact for sales information about this Ada 
implementation system, see: 

In the U.S.A.: 


Mr. Mike Turner 
DDC-I, Inc. 

9630 North 25th Avenue 
Suite #118 

Phoenix, Arizona 85021 
Mailing address: 

P.0. BOX 37767 
Phoenix, Arizona 85069-7767 
Telephone: 602-944-1883 

Telefax: 602-944-3253 

In the rest of the world: 

Mr. Palle Andersson 
DDC International A/S 
Gl. Lundtoftevej IB 
DK-2800 LYNGBY 
Denmark 

Telephone: + 45 45 87 11 44 
Telefax: + 45 45 87 22 17 

Testing of this Ada implementation was conducted at the 
customer's site by a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro90]. 


3-2 



For all processed tests (inapplicable and applicable), a result 
was obtained that conforms to the Ada Programming Language 
Standard. 


a) Total Number of Applicable Tests 3554 

b) Total Number of Withdrawn Tests 93 

c) Processed Inapplicable Tests 523 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


f) Total Number of Inapplicable Tests 523 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this 
compiler was tested, the tests listed in section 2.1 had been 
withdrawn because of test errors. The AVF determined that 523 
tests were inapplicable to this implementation. All inapplicable 
tests were processed during validation testing. In addition, the 
modified tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. 
The tests were compiled and linked on the host computer system, 
as appropriate. The executable images were transferred to the 
target computer system by the communications link described 
above, and run. The results were captured on the host computer 
system using the communications link described above. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this 
test were: 

-L -a <library> 

There were NO compiler options invoked by default for validation 
testing during this test. 

The specific linker options invoked for the SECURE_MODE were: 


-M secure 

-F default.els 

-m stack size=200000 


3-3 



-t 30 

-u ../dacs/Ada_UCC.sib 
-a acvc.alb 


Test output, compiler and linkt listings, and job logs were 
captured on magnetic tape and archived at the AVF. Selected 
listings examined on-site by the validation team were also 
archived. 


3-4 








APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in 
terms of the maximum input-line length, which is 126 the value 
for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum 
input-line length. 

Macro Parameter Macro Value 


$MAX IN LEN 126 


$BIG_ID1 

(1..V-l => 

'A', 

V 

=> 'l') 


$BIG_ID2 

(1..V-l => 

'A', 

V 

=> '2') 


$BIG_ID3 

(1..V/2 => 

'A') 

& 

'3' & (1..V-l-V/2 => 

' A') 

$BIG_ID4 

(1..V/2 => 

'A') 

& 

'4 ' & (1..V-l-V/2 => 

'A') 

$BIG_INT_LIT 

(1..V-3 => 

'0') 

& 

"298" 


$BIG_REAL_LIT 

(1..V-5 => 

'0') 

& 

"690.0" 


$BIG_STRING1 

& (1..V/2 = 

> ' 

A') & 


$BIG_STRING2 

& (1..V 

-l-V/2 

=> 'A') & '1 • & 


$BLANKS 

(1..V-2 0 => 

/ / 

) 



$MAX_LEN_INT_BASED_ 

LITERAL 
'"2:" & (1.. 

V-5 

= > 

'0') & "11:" 



$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 => 'A') & 


A-1 




The following table contains the values for the remaining macro 
parameters. 

Macro Parameter Macro Value 


647 


ACC_SIZE 
ALIGNMENT 
COUNT_LAST 
DE FAU LT_MEM_SIZ E 
DEFAULT_STOR_UNIT 
DEFAULT_SYS_NAME 
DELTA_DOC 
ENTRY_ADDRESS 
ENTRY_ADDRESS 1 
ENTRY_ADDRES S 2 
FIELD_LAST 
FILE_TERMINATOR 
FIXED_NAME 
FLOAT_NAME 
FORM_STRING 
F0RM_STRING2 
GREATER_THAN_DURATION 
GREATER_THAN_DURATION_BASE_LAST 
GREATER_THAN_FLOAT_BASE_LAST 
GREATER_THAN_FLOAT_SAFE_LARGE 
GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 
HIGH_PRIORITY 

ILLEGAL_EXTERNAL_FILE_NAME1 
ILLEGAL_EXTERNAL_FILE_NAME2 
INAPPROPRIATE_LINE_LENGTH 
INAPPROPRIATE_PAGE_LENGTH 
INCLUDE_PRAGMA1 
INCLUDE_PRAGMA2 
INTEGER_FIRST 
INTEGER_LAST 
INTEGER_LAST_PLUS_1 
INTERFACE_LANGUAGE 
LESS_THAN_DURATION 
LESS_THAN_DURATION_BASE_FIRST 
LINE_TERMINATOR 
LOW_PRIORITY 
MACHINE_CODE_STATEMENT 

AA_INSTR'(AA_EXIT_SUBPRGRM,0,0,0,AA_INSTR_INTG'FIRST,0 ); 


32 
4 

2_147_483_ 

2#1#E32 
8 

DACS_68 0X0 
2 #1.0#E-31 

FCNDECL.ENTRY_ADDRESS 
FCNDECL.ENTRY_ADDRESS1 
FCNDECL.ENTRY_ADDRESS2 
35 

t / 

N 0_SU CH_TY PE 
NO_SUCH_TYPE 

ti ii 

" CANNOT_RESTRICT_FILE_CAPACITY" 
100000.0 
200000.0 
16#1.0#E+32 
16#5.FFFF_F0#E+31 
16#5.FFFF_F0#E+31 
24 

/NODIRECTORY1/NOFILENAME1 
/NODIRECTORY2/NOFILENAME2 
-1 
-1 

PRAGMA INCLUDE ("A28006D1.TST") 
PRAGMA INCLUDE ("B28006D1.TST") 
-2147483648 
2147483647 
2147483648 
AS 

-75000.0 
-131073.0 


MACHINE_CODE_TYPE 
MANTISSA_DOC 
MAX_DIGITS 
MAX_INT 
MAX_INT_PLUS_1 
MIN INT 


AA_INSTR 

31 

15 

2147483647 

2147483648 

-2147483648 


A-2 










NAME 

NAME_LIST 

NAME_SPECIFICATI0N1 

NAME_SPECIFICATI0N2 

NAME_SPECIFICATI0N3 

NEG_BASED_INT 

NEW_MEM_SIZ E 

NEW_STOR_UNIT 

NEW_SYS_NAME 

PAGE_TERMINATOR 

RECORD DEFINITION 


: NO_SUCH_TYPE_AVAILABLE 
: DACS_68 0X0 

: /home/i=un2/ada/6803 0/test/wrk/X212 0A 
: /home/sun2/ada/68030/test/wrk/X2120B 
: /home/sun2/ada/68030/test/wrk/X3119A 
• 16#F000000E# 

: 2097152 
: 8 

: DACS 680X0 


RECORD INSTR NO:INTEGER;ARGO:INTEGER;ARG1:INTEGER; 


ARG2:INTEGER;ARG3:INTEGER;END RECORD? 


RECORD_NAME 

TASK_SIZE 

TASK_STORAGE_SIZE 

TICK 

VARIABLE_ADDRESS 
VARIABLE_ADDRESS1 
VARIABLE_ADDRESS2 
YOUR PRAGMA 


AA_INSTR 

32 

1024 

0.0208130 

FCNDECL.VARIABLE_ADDRESS 
FCNDECL.VARIABLE_ADDRESS1 
FCNDECL.VAPIART,E_ 7 'DDP.ESS2 
NOFLOAT 


A-3 





APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to compiler 
documentation and not to this report. 

Invoke the Ada compiler with the following command to the SunOS 
shell: 

ada {<option>} <source-spec> {<source-spec>} 

where the options and parameters are: 

QUALIFIER DESCRIPTION 

specifics program library used. 

-c CONFIGURATION_FILE. Specifies the file used by the 

compiler 

-1, -L LIST. Writes a source listing on the list file. 

-M MODE. Protection mode 

-n, -N NOCHECK. Generates run-time constraint checks. 

-o, -O OPTIMIZE. Specifies compiler optimization. 

-p PROGRESS. Displays compiler progress. 

-s, -S NOSAVE. Inserts source text in program library. 

-u UNIT. Assigns a specific unit number to the 

compilation 

(must be free and in a sublibrary). 

-x XREF. Creates a cross reference listing. 

-d DEBUG. Generates debug information 

<source-spec> The name of the source file to be compiled 


B-l 






LINKER OPTIONS 


The linker options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to linker 
documentation and not to this report. 

Enter the following command to the SunOS shell to invoke the 
linker: 

al {<option>} <unitname> 

where the options and parameters are: 

QUALIFIER DESCRIPTION 


-a 

-b 

-B 

-d 

-D 

-e 

-E 

-f 

-F 

-g 

-G 

-H 

-i 

-I 

-j 

-J 

-k 

-1 

-L 

-m 

-M 

-n 


-o 

-O 

-P 

-q 

-r 

-R 

-s 

-S 

-t 

-T 

-u 


LIBRARY. The library used in the link 

RAM_BASE. Base address for RAM sections 

ROM_BASE. Base address for ROM sections 

DEBUG. Generate debug information 

STATISTICS. Print statistics 

ENTRY. Alternative program start label 

NOEXCEPTIONS. Control of exception management 

FLOAT. Control of which float processor is used 

CLASS_FILE. Class file name 

USERCONSTANT. User constant sections 

SUPERVISOR_CONSTANT. Supervisor constant sections 

NOHEAP. Control of memory management 

INTERRUPT_STACK. Interrupt stack description 

INTERRUPTS. Number of Interrupt Task Control Blocks 

allocated 

USER_CODE. User code sections 

SUPERVTSOR_CODE. Supervisor code sections 

KEEP. Do not delete temporary files 

LOGICAL_MEMORY. Logical memory specification 

LOG_FILE. Log file name 

MAIN_TASK. Main task specification 

MODE. Execution mode 

OPTION_FILE. Linker option file name 

EXECUTABLE. Name of executable file 

NOEXECUTABLE. Do not create executable 

PHYSICAL_MEMORY. Physical memory specification 

RTS_STACK_USE. Amount of memory used by RTS 

RAM. Description of RAM memory sections 

ROM. Description of ROM memory sections 

USER_DATA. User data sections 

SUPER_DATA. Supervisor data sections 

TASKS. Number of Task Control Blocks allocated 

TASK_DEFAULTS. Default values for tasks 

UCC_LIBRARY. UCC library name 


B-2 






~U USR_LIBRARY. A user supplied object library 

~v VERIFY. Print information about the link 

“V MMU_DETAILS. Setup values for MMU registers 

-w WARNINGS. Print warnings 

-x TARGET_OPTIONS. Options to the target linker 

-y VECTOR. Interrupt vector description 

-Y NOVECTOR. No interrupt vector 

~z INIT_FILE. Initialization file name 

-Z BOOT. Generate boot module 

All qualifier keywords to the options may be abbreviated to the 
minimal unique substring, and casing is not significant. 


B-3 




APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and 
to certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada 
implementation, as described in this Appendix, are provided by 
the customer. Unless specifically noted otherwise, references in 
this Appendix are to compile, documentation and not to this 
report. Implementation-specific portions of the package 
STANDARD, which are not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 

range -16*0.FFFF_FF#E32 .. 16#0.FFFF_FF*E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 

16#0.FFFF_FFFF_FFFF_F8 #E2 5 6; 

type DURATION is delta 2#1.0#E-14 range -13l_072.0 .. 131_071.0? 
end STANDARD; 


C-l 




APPENDIX I. 


IMPLEMENTATION DEPENDENT CHARACTERISTICS 


This appendix describes the implementation-dependent 
characteristics of DACS-68030 required in Appendix F of the Ada 
Reference Manual (ANSI/MIL-STD-1815A). 


A. Implementation-Dependent Pragmas 

This section describes all implementation defined pragmas. 


1. PRAGMA INTERFACE SPELLING 

Format: pragma INTERFACE_SPELLING(<subprogram-name>, 

<string>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: Pragma INTERFACE_SPELLING must be applied to the 

subprogram denoted by <subprogram-name> . The 
<string> must be a string literal. 

This pragma allows an Ada program to call routines with a name that 
is not a legal Ada name, the <string> provides the exact spelling 
of the name of the procedure. 


2. PRAGMA INITIALIZE 

Format: pragma INITIALIZE(<string_literal>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

When the pragma is applied the linker will, as part of the 
initialization code generate a call to the subprogram with the name 
<string_literal>. The call will be performed before the elaboration 
of the Ada program is initiated, with IPL on 7. If several pragmas 
INITIALIZE are applied to the same program the routines are called 
in the elaboration order, if several pragmas INITIALIZE are applied 
to one compilation unit the routines are called in the order of 
appearance. If several compilations units apply pragma INITIALIZE 
to the same routine the routine is called once only. 


C-2 





3. PRAGMA RUNDOWN 


Format: pragma RUNDOWN(<string_literal>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Similar to pragma initialize, but the subprogram is called after 
the main program have terminated and in the reverse order as for 
the pragma INITIALIZE. 


4. PRAGMA TASKS 

Format: pragma TASKS; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the task attribute. If the code 
that is interfaced by a pragma INTERFACE uses any tasking 
constructs, the compilation unit must be marked such that the 
linker includes the tasking kernel in target programs that 
reference the compilation unit. 


5. PRAGMA FLOAT 

Format: pragma FLOAT; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the float attribute. If the code 
that is interfaced by a pragma INTERFACE uses any floating point 
co-processor instructions, the compilation unit must be marked such 
that the linker includes initialization of the floating point 
co-processor in target programs that reference the compilation 
unit. 


6. PRAGMA INTERRUPTS 

Format: pragma INTERRUPTS; 


C-3 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


Placement: The pragma may be placed as a declarative item. 
Restrictions: None. 

Marks the compilation unit with the interrupt attribute. If the 
code that is interfaced by a pragma INTERFACE uses any interrupts, 
the compilation unit must be marked such that the linker include 
the interrupt handling in target programs that reference the 
compilation unit. 


7. PRAGMA STORAGE MANAGER 

Format: pragma STORAGE_MANAGER; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the heap attribute. If the code 
that is interfaced by a pragma INTERFACE uses the storage manager, 
the compilation unit must be marked such that the linker include 
initialization of the storage manager in target programs that 
reference the compilation unit. 


8. PRAGMA INTERRUPT HANDLER 

The pragma INTERRUPT_HANDLER is defined with two formats. 

a. PRAGMA INTERRUPT HANDLER for Task Entries 
Format: pragma INTERRUPT_HANDLER; 

Placement: The pragma must be placed as the first declarative 

item in the task specification that it applies to. 

Restrictions: The task for which the pragma INTERRUPT HANDLER is 

applied must fulfill the following requirements: 

An address clause must be specified for all entries to 

the task. 

All entries of the task must be single entries with no 


C-4 









DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


parameters. 

The entries must not be called from any tasks. 

No other tasks may be specified in the body of the task. 

The body of the task must consist of a single sequence of 
accept statements for each of the defined interrupts, see 
below: 

task body fih is 

— local simple data declaration, no tasks, 
begin 

accept handlerl do 
<statement1ist>; 
end handlerl; 
accept handler2 do 
<statementlist>; 
end handler2; 
end fih; 

No other tasking construct than unconditional entry calls 
may appear in the statement list for the select 
alternatives. The execution of a statement list must only 
execute one unconditional entry call. 

Any procedures called from the accept body must not use 
any tasking constructs at all. 

No heap storage must allocated. 

No exception must be propagated out of the statement list 
of the accept alternatives. 

If the restrictions described above are not fulfilled, the program 
is erroneous and the result of the execution unpredictable. The 
compiler cannot and is not checking all the restrictions, but 
attempts to perform as many checks of the requirements as possible. 

The pragma INTERRUPT_HANDLER with no parameters allows the user to 
implement immediate response to exceptions. 


b. PRAGMA INTERRUPT HANDLER for Procedures 

Format: pragma 

INTERRUPT_HANDLER(procedure-name,integer-literal); 


05 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


Placement: The pragma must be placed as a declarative item, in 

the declarative part, immediately after the 
procedure specification. 

Restrictions: The procedure for which pragma INTERRUPT HANDLER 

applies must fulfill the following restrictions: 

The integer-literal must be in range 0..255, and must not 
define an interrupt vector entry to which the processor 
may generate a trap. 

The procedure must not be called anywhere in the 
application. 

No tasks may be declared in the body of the procedure. 

The only tasking construct that may be used from the body 
of the procedure is unconditional entry calls. Several 
unconditional entry calls may appear in the body of the 
procedure but the execution of the body must only lead to 
the execution of one. 

Any subprograms called from the procedure must not use 
any tasking constructs at all. 

The procedure must be parameterless. 

No heap storage must allocated from the procedure. 

Exceptions must no be propagated out of the procedure. 

If the restrictions described above is not fulfilled the program is 
erroneous and the result of the execution unpredictable. The 
compiler cannot and is not checking all the restrictions, but 
attempts to perform as many checks of the requirements as possible. 

The pragma INTERRUPT HANDLER for procedures defines the named 
subprogram to be an interrupt handler for the interrupt vector 
entry defined by the integer-literal. 


C-6 



DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


9. PRAGMA NOFLOAT 

Format: pragma NOFLOAT(task-id) 

Placement: The pragma must be placed as a declarative item, in 

the declarative part, defining the task type or 
object denoted by the task-id. 

Restrictions: The task(s) denoted by the task-id must not execute 

floating-point co-processor instructions. 

This pragma informs the compiler and runtime system that the task 
will not execute floating point co-processor instructions. 
Consequently the context switch needs not save and restore the 
state of the floating point co-processor yielding improved 
performance. 


10. PRAGMA SUPERVISOR_TASK 

Format: pragma SUPERVISOR_TASK 

Placement: The pragma must be placed immediately after the 

task declaration of the task declaring as a 
SUPERVISORJTASK. 

Restrictions: The pragma has no meaning if linking with BASIC 

mode. 

This pragma informs the compiler and runtime system that the task 
shall execute at the supervisor privilege level, all other tasks 
will execute at user privilege level when linking with SECURE 
execution mode. In BASIC execcution mode all tasks execute at the 
supervisor privilege level. 


11. PRAGMA ACCESS_TYPE_RETAIN_HEAP 

Format: pragma ACCESS_TYPE_RETAIN_HEAP 

Placement: The pragma must be placed as a declarative item, in 

the declarative part, immediately, after the 
procedure specification. 

Restrictions: The pragma can only be used when linking in BASIC 

mode. 


C-7 



DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


This pragma supress garbage collection of access types, when 
leaving the scope of the access type declaration. 


B. Implementation-Dependent Attributes 
No implementation-dependent attributes are defined. 


C. Package SYSTEM 
package SYSTEM is 


type ADDRESS 
subtype PRIORITY 
type NAME 
SYSTEM_NAME: 
STORAGE_UNIT: 
MEMORY_SIZ E: 
MIN_INT: 

MAX_INT: 

MAX_DIGITS: 

MAX_MANTISSA: 

FINE_DELTA: 

TICK: 


is ( DACS_680X0 

constant NAME 

constant 

constant 

constant 

constant 

constant 

constant 

constant 

constant 


24; 

DACS_680X0; 

8 ; 

2#1#E32 ; 
-2_14 7 _483_648 
2_147_483_647; 
15; 

31; 

2#1.0#E-31; 

0.0208130; 


is new INTEGER; 
is INTEGER range 1 

) 


type interface_language is (AS,C); 


end SYSTEM; 


D. Representation Clauses 

The DACS-68030 fully supports the 'SIZE representation for derived 
types. The representation clauses that are accepted for non-derived 
types are described in the following subsections. 


1. Length Clause 

Some remarks on implementation dependent behavior of length clauses 
are necessary: 


C-8 








DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


When using the SIZE attribute for discrete types, the 
maximum value that can be specified is 32 bits. 

SIZE is only obeyed for discrete types when the type is 
a part of a composite object, e.g. arrays or records. 

Using the STORAGE_SIZE attribute for a collection will 
set an upper limit on the total size of objects allocated 
in this collection. If further allocation is attempted, 
the exception STORAGE_ERROR is raised. 

When STORAGE_SIZE is specified in a length clause for a 
task, the process stack area will be of the specified 
size. 


2. Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in 
the range of INTEGER'FIRST + 1..INTEGER'LAST - 1. 


3. Record Representation Clauses 

When representation clauses are applied to records the following 
restrictions are imposed: 

if the component is a record or an unpacked array, it 
must start at a storage unit boundary (8 bits) 

a record occupies an integral number of storage units 
(words) (even though a record may have fields that only 
define an odd number of bytes) 

a record may take up a maximum of 2 giga bits 

a component must be specified with its proper size (in 
bits), regardless of whether the component is an array or 
not. 

if a non-array component has a size which equals or 
exceeds one storage unit 32-bits the component must start 
on a storage unit boundary. 

the elements in an array component should always be 
wholly contained in 32-bits. 


C-9 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


If the record type contains components which are not covered by a 
component clause, they are allocated consecutively after the 
component with the value. Allocation of a record component without 
a component clause is always aligned on a storage unit boundary. 
Holes created because of component clauses are not otherwise 
utilized by the compiler. 

Pragma PACK on a record type will attempt to pack the components 
not already covered by a representation clause (perhaps none). This 
packing will begin with the small scalar components and larger 
components will follow in the order specified in the record. The 
packing begins at the first storage unit after the components with 
representation clauses. 


a. Alignment Clauses 

Alignment clauses for records are implemented with the following 
characteristics: 

If the declaration of the record type is done at the 
outermost level in a library package, any alignment is 
accepted. 

If the record declaration is done at a given static level 
(higher than the outermost library level, i.e., the 
permanent area), only word alignments are accepted. 

Any record object declared at the outermost level in a 
library package will be aligned according to the 
alignment clause specified for the type. Record objects 
declared elsewhere can only be aligned on a word 
boundary. If the record type is associated with a 
different alignment, an error message will be issued. 

If a record type with an associated alignment clause is 
used in a composite type, the alignment is required to be 
one word; an error message is issued if this is not the 
case. 


E. Implementation-Dependent Names for Implementation-Dependent 
Components 

None defined by the compiler. 


C-10 



DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


F. Address Clauses 

This section describes the implementation of address clauses and 
what types of entities may have their address specified by the 
user. 


1. Objects 

Address clauses are supported for scalar and composite objects 
whose size can be determined at compile time if the address is 
specified. 


2. Task Entries 

Address clauses are supported for task entries. The following 
restrictions applies: 

The affected entries must be defined in a task object 
only, not a task type. 

The entries must be single and parameterless. 

The address specified must not denote an interrupt index 
which the processor may trap. 

If the interrupt entry executes floating point 
co-processor instructions the state of the co-processor 
must be saved prior to execution of any floating point 
instructions, and restore before the return. 

The address specified in the address clause denotes the interrupt 
vector index. 


G. Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O 
system, but in order to support testing and validation, DDC-I has 
developed a small terminal oriented I/O system. This I/O system 
consists essentially of TEXT_I0 adapted with respect to handling 
only a -erminal and not file I/O (file I/O will cause a USE ERROR 
to be raised) and a low level package called TERMINAL_DRIVER. A 


C-ll 






DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


BASIC_IO package has been provided for convenience purposes, 
forming an interface between TEXT_IO and TERMINAL_DRIVER as 
illustrated in the following figure. 




TEXT 10 


1 

! 

BASIC 10 

TERMINAL DRIVER 
(H/W interface) 

! 


Fig. F.l: 

The TERMINAL_DRIVER package is the only package that is target 
dependent, i.e., it is the only package that need be changed when 
changing communications controllers. The actual body of the 
TERMINAL_DRIVER is written in assembly language, but an Ada 
interface to this body is provided. A user can also call the 
terminal driver routines directly, i.e. from an assembly language 
routine. TEXT_IO and BASIC_IG are written completely in Ada and 
need not be changed. 

BASICIO provides a mapping between TEXT_IO control characters and 
ASCII as follows: 


TEXT 10 

ASCII Character 

LINE TERMINATOR 

PAGE TERMINATOR 

FILE TERMINATOR 

NEW LINE 

ASCII.CR 

ASCII.FF 

ASCII.EM (Ctrl Z) 

ASCII.LF 


Table F.l: Mapping between TEXT_I0 and ASCII 


The services provided by the terminal driver are: 


1) Reading a character from the communications port. 

2) Writing a character to the communications port. 


1. Package TEXT 10 


C-12 








DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


The specification of package TEXT_I0: 

pragma page; 
with BASIC_I0; 

with I0_EXCEPTI0NS; 
package TEXT_I0 is 

type FILE_TYPE is limited private; 

type FILE_MODE is (IN_FILE, 0UT_FILE); 

type COUNT is range 0 .. INTEGER'LAST; 

subtype P0SITIVE_C0UNT is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED: constant COUNT:= 0; — line and page length 

— max. size of an integer output field 2#....# 
subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER_BASE is INTEGER range 2 .. 16; 

type TYPE_SET is (LOWER_CASE, UPPER_CASE); 
pragma PAGE; 

— File Management 


procedure CREATE 

(FILE 


in 

out FILE TYPE; 



MODE 


in 

FILE MODE :=OUT FILE; 


NAME 


in 

STRING :=••» 

I 


FORM 
) ? 


in 

STRING :="" 


procedure OPEN 

(FILE 


in 

out FILE TYPE; 



MODE 


in 

FILE MODE; 



NAME 


in 

STRING; 



FORM 
) i 


in 

STRING :=»•" 


procedure CLOSE 

(FILE 


in 

out FILE TYPE); 


procedure DELETE 

(FILE 


in 

out FILE TYPE); 


procedure RESET 

(FILE 


in 

out FILE TYPE; 



MODE 


in 

FILE MODE); 


procedure RESET 

(FILE 


in 

out FILEJTYPE); 


function MODE 

(FILE 


in 

FILE TYPE) return 

FILE MODE 

function NAME 

(FILE 


in 

FILE TYPE) return 

STRING; 

function FORM 

(FILE 


in 

FILE TYPE) return 

STRING; 


function IS_OPEN(FILE : in FILE_TYPE return BOOLEAN; 


C-13 









DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— control of default input and output files 

procedure SET_INPUT (FILE : in FILE_TYPE); 
procedure SET_0UTPUT (FILE : in FILE_TYPE); 

function STANDARD_INPUT return FILE_TYPE; 

function STANDARD_OUTPUT return FILE_TYPE; 

function CURRENT_INPUT return FILE_TYPE; 

function CURRENT_OUTPUT return FILE_TYPE; 

pragma PAGE; 

— specification of line and page lengths 

procedure SET_LINE_LENGTH (FILE : in FILE_TYPE; 

TO : in COUNT); 

procedure SET_LINE_LENGTH (TO ; in COUNT)? 

procedure SET_PAGE_LENGTH (FILE : in FILE_TYPE; 

TO : in COUNT); 

procedure SET_PAGE_LENGTH (TO : in COUNT); 

function LINE_LENGTH (FILE : in FILE_TYPE) 

return COUNT; 
function LINE_LENGTH return COUNT; 

function PAGE_LENGTH (FILE : in FILE_TYPE) 

return COUNT; 
function PAGE LENGTH return COUNT; 


C-14 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Column, Line, and Page Control 


procedure 

NEW_LINE 

(FILE : in FILE_TYPE; 




SPACING 

: in POSITIVE COUNT := 

1) ; 

procedure 

NEW_LINE 

(SPACING 

: in POSITIVE_COUNT := 

1) ; 

procedure 

SKIP_LINE 

(FILE : 

in FILE TYPE; 




SPACING 

; in POSITIVE COUNT := 

= i); 

procedure 

SKIP_LINE 

(SPACING 

: in POSITIVE_COUNT := 

= i) ? 

function 

END OF LINE 

(FILE 

: in FILE_TYPE) return 

BOOLEAN; 

function 

END_OF_LINE 


return 

BOOLEAN; 

procedure 

NEW PAGE 


(FILE 

: in FILE_TYPE); 


procedure 

NEW_PAGE; 





procedure 

SKIP PAGE 


(FILE 

; in FILE_TYPE) ; 


procedure 

SKIP_PAGE 

t 




function 

END OF PAGE 

(FILE 

; in FILE_TYPE) return 

BOOLEAN; 

function 

END_OF_PAGE 


return 

BOOLEAN; 

function 

END OF FILE 

(FILE 

: in FILE_TYPE) return 

BOOLEAN; 

function 

END_OF_FILE 


return 

BOOLEAN; 

procedure 

SET_COL 


(FILE 

: in FILE TYPE; 





TO 

: in POSITIVE COUNT); 


procedure 

SET_COL 


(TO : 

in POSITIVE_COUNT); 


procedure 

SET_LINE 


(FILE 

: in FILE TYPE; 





TO : 

in POSITIVE COUNT); 


procedure 

SET_LINE 


(TO : 

in POSITIVE_COUNT); 


function 

COL 


(FILE 

: in FILE TYPE) 





return 

POSITIVE COUNT; 


function 

COL 


return 

POSITIVE_COUNT; 


function 

LINE 


(FILE 

; in FILE TYPE) 





return 

POSITIVE COUNT; 


function 

LINE 


return 

POSITIVE_COUNT; 


function 

PAGE 


(FILE 

: in FILE TYPE) 





return 

POSITIVE COUNT; 


function 

PAGE 


return 

POSITIVE COUNT; 



C-15 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Character Input-Output 


procedure 

GET 

(FILE 

: in FILE TYPE; ITEM : 

out 

CHARACTER); 

procedure 

GET 

( 


ITEM : 

out 

CHARACTER); 

procedure 

PUT 

(FILE 

: in FILE TYPE; ITEM : 

in 

CHARACTER); 

procedure 

PUT 

( 


ITEM : 

in 

CHARACTER); 

— String 

Input-Output 




procedure 

GET 

(FILE 

: in FILE TYPE; ITEM : 

out 

CHARACTER); 

procedure 

GET 

( 


ITEM : 

out 

CHARACTER); 

procedure 

PUT 

(FILE 

: in FILE_TYPE; ITEM : 

in 

CHARACTER); 

procedure 

PUT 

( 


ITEM : 

in 

CHARACTER); 

procedure 

GET_ 

_LINF 

(FILE : 

in FILE_TYPE; 






ITEM : 

out STRING; 






LAST : 

out NATURAL); 



procedure 

GET_ 

LINE 

(ITEM : 

out STRING; 






LAST : 

out NATURAL); 



procedure 

PUT_ 

LINE 

(FILE : 

in FILE_TYPE; 






ITEM : 

in STRING)? 



procedure 

PUT_ 

LINE 

(ITEM : 

in STRING); 




C-16 




User's Guide 


DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - 
Implementation Dependent Characteristics 


pragma PAGE; 

— Generic Package for Input-Output of Integer Types 


generic 

type NUM is range <>; 
package INTEGER_IO is 


DEFAULT_WIDTH : FIELD := NUM'WIDTH; 

DEFAULT_BASE : NUMBER BASE := 10; 


— 




procedure 

GET 

(FILE 

in FILE_TYPE; 



ITEM 

out NUM; 



WIDTH 

in FIELD := 0) ; 

procedure 

GET 

(ITEM 

out NUM; 



WIDTH 

in FIELD ;= 0); 

procedure 

PUT 

(FILE 

in FILE_TYPE; 



ITEM 

in NUM; 



WIDTH 

in FIELD := DEFAULT WIDTH; 



BASE 

in NUMBER_BASE := DEFAULT_BASE) 

procedure 

PUT 

(ITEM 

in NUM; 



WIDTH 

in FIELD := DEFAULT WIDTH; 



BASE 

in NUMBER_BASE := DEFAULT_BASE) 

procedure 

GET 

(FROM 

in STRING; 



ITEM 

out NUM; 



LAST 

out POSITIVE); 

procedure 

PUT 

(TO 

out STRING; 



ITEM 

in NUM; 



BASE 

in NUMBER_BASE := DEFAULT BASE); 

end INTEGER 10; 




C-17 







DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Generic Packages for Input-Output of Real Types 


generic 

type NUM is digits <>; 
package FL0AT_I0 is 

DEFAULT_FORE : FIELD := 

DEFAULT_AFT : FIELD : = 

DEFAULT_EXP : FIELD := 

procedure GET (FILE : 

ITEM : 
WIDTH : 

procedure GET (ITEM : 

WIDTH : 

procedure PUT (FILE 

ITEM 
FORE 
AFT 
EXP 

procedure PUT (ITEM 

FORE 
AFT 
EXP 

procedure GET (FROM 

ITEM 
LAST 

procedure PUT (TO 

ITEM 
AFT 
EXP 

end FLOAT 10; 


2 ; 

NUM'DIGITS - 1; 

3; 

in FILE_TYPE; 
out NUM; 
in FIELD := 0) ; 
out NUM; 
in FIELD := 0); 

in FILE_TYPE; 
in NUM; 

in FIELD := DEFAULT_FORE; 
in FIELD := DEFAULT_AFT; 
in FIELD := DEFAULT_EXP); 
in NUM; 

in FIELD := DEFAULT_FORE; 
in FIELD := DEFAULT_AFT; 
in FIELD := DEFAULT_EXP); 

in STRING; 
out NUM; 
out POSITIVE); 
out STRING; 
in NUM; 

in FIELD := DEFAULT_AFT; 
in FIELD ;= DEFAULT_EXP); 


C-18 





User's Guide 


DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - 
Implementation Dependent Characteristics 


pragma PAGE; 
generic 

type NUM is delta <>; 
package FIXED_I0 is 

DEFAULT_FORE : FIELD 

DEFAULT_AFT : FIELD 

DEFAULT_EXP : FIELD 

procedure GET (FILE 

ITEM 

WIDTH 

procedure GET (ITEM 

WIDTH 

procedure PUT (FILE 

ITEM 

FORE 

AFT 

EXP 

procedure PUT (ITEM 

FORE 

AFT 

EXP 

procedure GET (FROM 

ITEM 

LAST 

procedure PUT (TO 

ITEM 

AFT 

EXP 


NUM'FORE; 

NUM'AFT; 

0 ; 

in FILE_TYPE; 
out NUM; 
in FIELD := 0); 
out NUM; 
in FIELD := 0) ; 


in 

FILE TYPE 

* t 


in 

NUM.- 



in 

FIELD : = 

DEFAULT 

fore 

in 

FIELD := 

DEFAULT 

’AFT ; 

in 

FIELD := 

default’ 

'EXP) 

in 

NUM.- 



in 

FIELD : = 

DEFAULT 

FORE 

in 

FIELD := 

default" 

’AFT 

in 

FIELD := 

default" 

’EXP) 

in 

STRING; 



out NUM; 



out POSITIVE); 


out STRING; 




in NUM; 

in FIELD := DEFAULT_AFT; 
in FIELD := DEFAULT_EXP) 


end FIXED IO; 


C-19 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Generic Package for Input-Output of Enumeration Types 
generic 

type ENUM is (<>) ; 
package ENUMERATION 10 is 

DEFAULT_WIDTH : FIELD := 0; 

DEFAULT_SETTING : TYPE_SET := UPPER_CASE; 

procedure GET (FILE : in FILE_TYPE; ITEM : out ENUM); 
procedure GET ( ITEM : out ENUM); 

procedure PUT (FILE : FILE_TYPE; 

ITEM : in ENUM; 

WIDTH : in FIELD := DEFAULT_WIDTH; 

SET : in TYPE_SET := DEFAULT_SETTING); 

procedure PUT (ITEM : in ENUM; 

WIDTH : in FIELD := DEFAULT_WIDTH; 

SET : in TYPE_SET := DEFAULT_SETTING) ; 

procedure GET (FROM : in STRING; 

ITEM : out ENUM; 

LAST : out POSITIVE); 

procedure PUT (TO : out STRING; 

ITEM : in ENUM; 

SET : in TYPE_SET DEFAULT_SETTING) ; 

end ENUMERATION_IO; 
pragma PAGE; 

— Exceptions 

STATUS_ERROR : exception renames IO_EXCEPTIONS.STATUS_ERROR; 

MODE_ERROR : exception renames IO_EXCEPTIONS.MODE_ERROR; 

NAME_ERROR ; exception renames I0_EXCEPTI0NS.NAME_ERROR; 

USE_ERR0R : exception renames IO_EXCEPTIONS.USE_ERROR; 

DEVICE_ERR0R : exception renames IO_EXCEPTIONS.DEVICE_ERROR; 

END_ERROR : exception renames IO_EXCEPTIONS.END_ERROR; 

DATA_ERROR : exception renames IO_EXCEPTIONS.DATA_ERROR; 

LAYOUT_ERROR : exception renames IO_EXCEPTIONS.LAYOUT_ERROR; 


C-20 



DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma page; 
private 

type FILE_TYPE is 
record 

FT : INTEGER := -1; 
end record; 

end TEXT 10; 


2. Package 10 EXCEPTIONS 

The specification of the package IO_EXCEPTIONS: 


package IO_EXCEPTIONS is 


STATUS_ERR0R 
M0DE_ERR0R 
NAME_ERROR 
USE_ERROR 
DEVICE_ERROR 
END_ERROR 
DATA_ERROR 
LAYOUT ERROR 


exception; 
exception; 
exception; 
exception; 
exception; 
exception; 
exception; 
exception; 


end 10 EXCEPTIONS; 


3. Package BASIC 10 

The specification of package BASIC_I0: 


with I0_EXCEPTI0NS; 
package BASIC_I0 is 

type count is range 0 .. integer'last; 

subtype positive_count is count range 1 .. count'last; 

function get_integer return string; 

— Skips any leading blanks, line terminators or page 
— terminators. Then reads a plus or a minus sign if 


C-21 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


— present, then reads according to the syntax of an 

— integer literal, which may be based. Stores in item 

— returns a string containing an optional sign and an 

— integer literal. 

— The exception DATA_ERROR is raised if the sequence 

— of characters does not correspond to the syntax 

— described above. 

— The exception END_ERROR is raised if the file terminator 

— is read. This means that the starting sequence of an 

— integer has not been met. 

— Note that the character terminating the operation must 

— be available for the next get operation. 


function get_real return string; 

— Corresponds to get_integer except that it reads according 

— to the syntax of a real literal, which may be based. 

function get_enumeration return string? 

— Corresponds to get_integer except that it reads according 

— to the syntax of an identifier, where upper and lower 

— case letters are equivalent to a character literal 

— including the apostrophes. 

function get_item (length : in integer) return string; 

— Reads a string from the current line and stores it in 

— item. If the remaining number of characters on the 

— current line is less than length then only these 

— characters are returned. The line terminator is not 

— skipped. 

procedure put_item (item ; in string); 

— If the length of the string is greater than the current 

— maximum line (linelength), the exception LAYOUT_ERROR 

— is raised. 

— If the string does not fit on the current line a line 

— terminator is output, then the item is output. 

— Line and page lengths - [DOD-83] 14.3.3. 


C-22 



DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 

procedure set_line_length (to : in count); 

procedure set_page_length (to : in count); 

function line_length return count; 
function page_length return count; 

— Operations on columns, lines and pages - [DOD-83] 14.3.4. 

procedure new_line; 
procedure skip_line; 

function end_of_line return boolean; 

procedure new_page; 

procedure skip_page; 

function end_of_page return boolean; 

function end_of_file return boolean; 

procedure set_col (to : in positive_count); 

procedure set_line (to ; in positive_count); 

function col return positive__count; 

function line return positive_count; 

function page return positive_count; 

— Character and string procedures. 

— Corresponds to the procedures defined in [DOD-83] 14.3.6. 

procedure get_character (item ; out character); 

procedure get_string (item ; out string); 

procedure get_line (item ; out string; 

last ; out natural); 

procedure put_character (item ; in character); 
procedure put_string (item : in string); 


C-23 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


procedure put__line (item : in string); 


exceptions: 

USE_ERR0R : exception renames IO_EXCEPTIONS.USE_ERROR; 
DEVICE_ERROR : exception renames IO_EXCEPTIONS.DEVICE_ERROR; 
END_ERR0R : exception renames IO_EXCEPTIONS.END_ERR0R; 
DATA_ERROR : exception renames I0_EXCEPTI0NS.DATA_ERROR; 
LAYOUT_ERROR : exception renames IO_EXCEPTIONS.LAY0UT_ERR0R; 

end BASIC 10; 


4. Package TERMINAL DRIVER 

The specification of package TERMINAL_DRIVER: 
package terminal_driver is 

procedure put_character(ch : character); 
procedure flush; 

function get_character return character; 
procedure purge; 
private 

pragma interface (AS, put_character); 

pragma interface_spelling(put_character, "Ada_UCC_G$PutByte”); 
pragma interface (AS, get_character); 

pragma interface_spelling(get_character, "Ada_UCC_G$GetByte"); 
pragma interface (AS, flush); 

pragma interface_spelling(flush, "Ada_UCC_G$FlushOutput"); 
pragma interface (AS, purge); 

pragma interface_spelling(purge, "Ada_UCC_G$PurgeInput"); 

pragma initialize("Ada_UCC_G$InitIO"); 
pragma rundown ("Ada_UCC_G$CloseIO"); 

end terminal driver; 


C-24 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 

5. Package SEQUENTIAL 10 

The specification of package SEQUENTIAL_70: 

— Source code for SEQUENTIAL_I0 

pragma PAGE; 

with IO_EXCEPTIONS; 

generic 

type ELEMENT_TYPE is private; 
package SEQUENTIAL_IO is 

type FILE_TYPE is limited private; 
type FILE_MODE is (IN_FILE, 0UT_FILE); 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— File management 


procedure 

/■•nr 

x X~t 

(FILE 

• 

iii 

out 

FILE TYPE; 




MODE 


in 


FILE MODE := 

DUT_FILE; 



NAME 


in 


STRING := 

ii ti • 

9 



FORM 


in 


STRING ;= 

"") ; 

procedure 

OPEN 

(FILE 


in 

out 

FILE TYPE; 




MODE 


in 


FILE MODE; 




NAME 


in 


STRING; 




FORM 


in 


STRING := "") 

* 

procedure 

CLOSE 

(FILE 


in 

out 

FILEJTYPE); 


procedure 

DELETE(FILE 


in 

out 

FILEJTYPE); 


procedure 

RESET 

(FILE 


in 

out 

FILE TYPE; 




MODE 


in 


FILE_MODE); 


procedure 

RESET 

(FILE 

• 

in 

out 

FILE_TYPE); 


function 

MODE 

(FILE 

• 

• 

in 

FILE 

_TYPE) return 

FILE_MODE 

function 

NAME 

(FILE 


in 

FILE 

_TYPE) return 

STRING; 

function 

FORM 

(FILE 


in 

FILE 

_TYPE) return 

STRING; 

function 

IS_OPEN(FILE 

: 

in 

FILEJTYPE) return 

BOOLEAN; 


pragma PAGE; 

— input and output operations 


procedure READ (FILE : in FILE_TYPE; 

ITEM : out ELEMENT_TYPE); 

procedure WRITE (FILE : in FILE_TYPE; 

ITEM : in ELEMENT_TYPE); 

function END_OF_FILE(FILE : in FILE_TYPE) return BOOLEAN; 


C-26 






DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 
— exceptions 


STATUS_ERROR 

MODE_ERROR 

NAME_ERROR 

USE_ERR0R 

DEVICE_ERROR 

END_ERROR 

DATA ERROR 


exception 

exception 

exception 

exception 

exception 

exception 

exception 


renames 

renames 

renames 

renames 

renames 

renames 

renames 


I0_EXCEPTI0NS.STATUS_ERROR; 
IO_EXCEPTIONS.MODE_ERROR; 
IO_EXCEPTIONS.NAME_ERROR; 
I0_EXCEPTI0NS.USE_ERR0R; 
IO_EXCEPTIONS.DEVICE_ERROR; 
IO_EXCEPTIONS.END_ERROR; 
I0_EXCEPTI0Nt>. DATA ERROR; 


pragma PAGE; 
private 


type FII,E_TYPE is new INTEGER; 


end SEQUENTIAL 10; 


H. Machine Code Insertions 

Machine code insertion is allowed using the instruction defined 
in package MACHINE_C0DE. All arguments given in the code 
statement aggregate must be static. 

The machine language defined in package MACHINE_CODE is not 68020 
assemble, but rather Abstract A-code which is an intermediate 
language used by the compiler. 


C-27 





