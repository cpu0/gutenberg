DTIP. FILE COPY 






IENTATION PAGE | 0^^0704018 8 

AD-A223 535 


BFUtONG NUMBERS 


REPORT DATE t REPORT TYPE AM) OWES COVERED 

Final 

7 Dec. 90 to 7 Dec. 91 


4.TfIl£ANDSUBTm£ Ada Compiler Validation Summary Report:Tartan 
Laboratories Incorporated, Tartan Ada ULTR1X, Version INT-3 
VAX Station (Host & Target), 89120711.10261 


•.AUTHORS) 

IABG-AVF 

Ottobrunn, FEDERAL REPUBLIC OF GERMANY 


7. PERPORMMG ORGANIZATION NANE(S) AND AOORE$S<ES) 

IABG-AVF, Industrieanlagen-Betrieb sgeselschaft 

Dept. S2T 
Einsteinstrasse 20 
D-8012 Ottobrunn 
FEDERAL REPUBLIC OF'GERMANY 


8. SPONSORMGflyDNITORNQ AGENCY NAME'S) AND AOORESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-IABG-059 


10. SPONSORMGAAONITORMG AGENCY 
REPORT NUMBER 



12a. OSYREXJTIOWAVALABLfTY STATEMENT 


12 b. DISTRBUnON COOE 


Approved for public release; distribution unlimited. 


IS. ABSTRACT (UulmunSOO mntt) 


Tartan Laboratories Incorporated, Tartan Ada ULTRIX, Version INY-3, Ottobrunn West German 
VAX Station 3100 under ULTRIX V3.0 (Host & Target), ACVC 1.10. 


DTIC 

ELECTE 

JUN 2 G 1990 

to u 



it. NUMBER OP RAGES 


14. SUBJECT TERMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 

Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- I it. PRICE COOE 
_STD-1815A, Ada Joint Program Office _I 








y iiiiivi*-' r d^ 




20. UMfTATION OF ABSTRACT 


trANWM. 















AVF Control Number: AVF-IABG-059 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: #39120711.102*51 
TARTAN LABORATORIES INCORPORATED 
Tartan Ada ULTRIX Version INT-3 
VAX Station host and target 


Completion of On-Site Testing: 
7 December 1989 


Prepared By: 
IA3G mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
Vest Germany 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3031 


90 06 26 071 








Ada Compiler Validation Summary Report: 


Compiler Marne: Tartan Ada ULTRIX Version INT-3 
Certificate Number: #89120711.10261 
Host: VAX Station 3100 under ULTRIX V3.0 

Target: VAX Station 3100 under ULTRIX V3.0 
Testing completed 7 December 1989 using ACVC 1.10. 


This report has been reviewed and is approved. 


iL-j 

Dr. S. Heilbrunner 
IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
West Germany 




Institute f(\£ 
Alexandria VA 


n organization 
rgmer 

efense Analyses 
22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 



Accesior 


ro 


NTIS 

CR 

DTK' 

TA 

U ■ ’ rf:'. 

Jur.tif 

') 

By 


Di;.t 



Dist 

, 

JH 











TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION . 1 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.2 

1.3 REFERENCES.3 

1.4 DEFINITION OF TERMS . 3 

1.5 AC VC TEST CLASSES.4 

CHAPTER 2 CONFIGURATION INFORMATION . 7 

2.1 CONFIGURATION TESTED . 7 

2.2 IMPLEMENTATION CHARACTERISTICS . S 

CHAPTER 3 TEST INFORMATION.14 

3.1 TEST RESULTS.14 

3.2 SUMMARY OF TEST RESULTS BY CLASS.14 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.15 

3.4 WITHDRAWN TESTS.15 

3.5 INAPPLICABLE TESTS . 15 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . 19 

3.7 ADDITIONAL TESTING INFORMATION 

3 . 7.1 Prevalidation.20 

3.7.2 Test Method.20 

3.7.3 Test Site .21 

APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 


APPENDIX E 


COMPILER AND LINKER OPTIONS 
























INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1315A. 
This report explains all technical terms used within it and thoroughly 
reports the results of test ing this compiler using the Ada Compiler 
Validation Capability « (ACVC). '' An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard.N 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies — for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
given in this report, j 


The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results.The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation dependent, but is permitted by the Ada Standard. Six 
classes of tests are used. These tests are designed to perform checks at 
compile time, at link time, and during execution. 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 





INTRODUCTION 


To attempt to identify any language constructs supported bv the 
compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by IABG mbH, Abt SZT according to 
procedures established by the Ada Joint Program Office and administered by 
the Ada Validation Organization (AVO). 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the "Freedom of Information Act" 
(5 U.S.C. #552) . The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 

or from: 

IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 










INTRODUCTION 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 

AMSI/MIL-STD-1815A, February 1933 and ISO 3652-1937. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTeoh, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1936. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

An Ada Commentary contains all information relevant to the 
point addressed by a comment on the Ada Standard. These 
comments are given a unique identification number having the 
form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 3652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVR is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 

AVO The Ada Validation Organization. The A v 0 has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 

demonstrates nonconformity to the Ada Standard. 


Ada 

Commentary 


Host 


The computer on which the compiler resides. 




INTRODUCTION 


Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the test. 


Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler’s conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 


Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be incorrect 

because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce errors because of the way in which a 
program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal Ada 
programs with certain language constructs which cannot be verified at run 
time. There are no explicit program components in a Class A test to check 
semantics. For example, a Class A test checks that reserved words of 
another language (other than those already reserved in the Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed if no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic error in the test is detected. A Class B test is passed if 
every illegal construct that it contains is detected by the compiler. 










INTRODUCTION 


Class C tests check the run time system to ensure that legal Ina programs 
can be correctly compiled and executed. Each Class C test is se1f-checking 
and produces a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. In some cases, an implementation may legitimately 
detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also provides a set of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FILE is used to 
check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
tests. However, some tests contain values that require the test to be 










INTRODUCTION 


customized according to implementation-specific values — for example, an 
illegal file name. A list of the values used for this validation is 
provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
AO’C and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 







COWFTGURATION INFORMATION 


CHAPTER 2 

CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under the 
following configuration: 

Compiler: Tartan Ada ULTRIX Version INT-3 
ACVC Version: 1.10 
Certificate Number: #39120711.10261 
Host Computer: 

Machine: VAX Station 3100 

Operating System: ULTRIX V3.0 

Memory Size: 9 MB 

Target Computer: 

Machine: VAX Station 3100 

Operating System: ULTRIX V3.0 


Memory Size: 


9 MB 







CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. ^See test 
D29002K.) 

2) The compiler correctly processes tests containing loop 

statements nested to 65 levels. (See tests D55A03A..H (3 
tests).) 

3) The compiler correctly processes tests containing block 

statements nested to 65 levels. (See test D56001B.) 

4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

1) This implementation supports the additional predefined types 
SHORT_INTEGER, BYTE_INTEGER, and LONG_FLOAT in the package 
STANDARD. (See tests 336001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at which 
constraints are checked are not defined by the language, -hile 
the ACVC tests do not specifically attempt to determine the order 
of evaluation of expressions, test results indicate the following: 

1' None of the default initialization expressions for record 
components are evaluated before any value is 
checked for membership in a component's subtype. (See test 
C32117A.) 

2) Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 


3) This implementation uses no extra bits for extra precision 








CONFIGURATION INFORMATION 


and uses all extra bits for extra range. (See test ^35903A.} 

4) NUHERIC_ERROR is raised for predefined and largest integer and 
no exception is raised for smallest integer when an integer 
literal operand in a comparison or membership test is outside 
the range of the base type. (See test C45232A.) 

5) No exception is raised when a literal operand in a fixed- 
point comparison or membership test is outside the range of 
the base type. (See test C45252A.) 

6) Underflow is not gradual. (See tests C45524A..Z (26 

tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is not 
defined by the language. While the ACVC tests do not specifically 
attempt to determine the method of rounding, the test results 
indicate the following: 

1) The method used for rounding to integer is round away from 
zero. (See tests C46012A..Z (26 tests).) 

2) The method used for rounding to longest integer is round 
away from zero. (See tests C46012A..Z (26 tests).) 

3) The method used for rounding to integer in static universal 
real expressions is round away from zero. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUHERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For -this 
implementation: 

1) Declaration of an array type or subtype declaration with more 
than SYSTEM.MAX_INT components raises NUMERIC_ERROR for 
one dimensional array types, two dimensional array types and 
two dimensional array subtypes, and no exception for one 
dimensional array subtypes. (See test C36003A.) 


2) 

NUMERIC ERROR 

is 

raised when 

an 

array 

type 

with 


INTEGER’LAST 
C36202A.) 

+ 

2 components 

is 

declared. 

(See 

test 

3) 

NUMERIC_ERROR 

is 

raised when 

an 

array 

type 

with 


SYSTEM.MAX_INT 

+ 

2 components 

is 

declared. 

(See 

test 







CONFIGURATION INFORMATION 


C36202B.) 

4) A packed BOOLEAN array having a 'LENGTH exceeding INTEGER'LAST 
raises NUHERIC_ERROR when the array type is declared. (See 
test C52103X.) 

5) A packed two-dimensional BOOLEAN array with more than 

INTEGER'LAST components raises NUHERIC_ERROR when the array 
type is declared and exceeds INTEGER'LAST. (See test 

C52104Y.) 

6) In assigning one-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERRGR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

7) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52C13A.) 

8) A null array with one dimension of length greater 
than INTEGER'LAST may raise MUHERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an implemen¬ 
tation may accept the declaration. However, lengths must 
match in array slice assignments. This implementation raises 
NUMERIC_ERROR when the array type is declared. (See 
test E52103Y.) 


f. Discriminated types. 

1) In assigning record types with discriminants, the expression 
is evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 


g. Aggregates. 

1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

3) CONSTRAINT_ERROR is raised after all choices are 
evaluated when a bound in a non-null range of a non-null 






CONFIGURATION INFORMATION 


aggregate does not belong to an index subtype. <'3ee test 
E432113.} 


h. Pragmas. 

1) The pragma INLINE is supported for functions and 
procedures. (See tests LA3004A..B (2 tests), EA3004C..D (2 

tests), and CA3004E..F (2 tests).) 


i. Generics. 

This compiler enforces the following two rules concerning 
declarations and proper bodies which are individual compilation 
units: 

o generic bodies must be compiled and completed before their 
instantiation. 

o recompilation of a generic body or any of its transitive 
subunits makes all units obsolete which instantiate that 

generic body. 

These rules are enforced whether the compilation units are in 
separate compilation files or not. AI408 and AI506 allow this 
behaviour. 

1) Generic specifications and bodies can be compiled 

in separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

2) Generic subprogram declarations and bodies can be 

compiled in separate compilations. (See tests CA1012A and 

CA2009F.) 

3) Generic library subprogram specifications and bodies can be 

compiled in separate compilations. (See test CA1012A.) 

4) Generic non-library package bodies as subunits can 

be compiled in separate compilations. (See test CA2009C.) 

5) Generic non-library subprogram bodies can be 
compiled in separate compilations from their stubs. (See test 
CA2009F.) 

6) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 

7) Generic package declarations and bodies can be 
compiled in separate compilations. (See tests CA2009C, 


1 1 







CONFIGURATION INFORMATION 


3C3204C, and 3C3205D.) 

3) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests 

BC3204C and BC3205D.) 

9) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 


Input and output. 

1) The package SEQUENTIAL_IO cannot be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101C, EE2201D. 

and EE2201E.) 

2) The package DIRECT_IO cannot be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101H, EE2401D, 

and EE2401G.) 

3) Modes IN_FILE and OUT_FILE are supported for SEQUENTTAL_IO. 
(See tests CE2102D..E, CE2102N, and CE2102P.) 

4) Modes IN_FILE, OUT_FILE, and INOUT_FILE are supported for 

DIRECT_IO. (See tests CE2102F, CE2102I..J, CE2102R, CE2102T, 

and CE2102V.) 

5) Modes IN_FILE and 0UT_FILE are supported for text files. (See 
tests CE3102E, CE3102I..K.) 

6) RESET and DELETE operations are supported for SEOUENTIAL_IO. 
(See tests CE2102G and CE2102X.) 

7) RESET and DELETE operations are supported for DIRECT_IO. (See 
tests CE2102K and CE2102Y.) 

8) RESET and DELETE operations are supported for text files. (See 
tests CE3102F..G, CE3104C, CE3110A, and CE3114A.) 

9) . Overwriting to a sequential file truncates to the last element 

written. (See test CE2208B.) 

10) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

11) Temporary direct files are given names and deleted when 
closed. (See test CE2108C.) 


12) Temporary text files are given names and deleted when closed. 











CONFIGUPATTOM IMFORMATION 


(See test i ~&_>li2n.) 

13) More than one internal file can be associated with each 

external file for sequential files when writing or reading. 
(See tests CE2107A..E, CE2102L, CE2110B.. and CE2111D.) 

14) More than one internal file can be associated with each 

external file for direct files when writing or reading. (See 
tests CE2107F..K, CE2110D, and CE2111H.) 

15) More than one internal file can be associated with each 

external file for text files when writing only or when reading 
only. (See tests CE3111A..E, CE3114B, and CE3111A.) 







TEST INFORMATION 


CHAPTER 3 
TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 441 tests were inapplicable to this implementation. 
All inapplicable tests were processed during validation testing except for 
285 executable tests that use floating-point precision exceeding 
that supported by the implementation. Modifications to the code, 
processing, or grading for 79 tests were required to successfully 
demonstrate the test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

127 

1132 

1886 

17 

24 

46 

3232 

Inapplicable 

0 

6 

429 

0 

4 

0 

441 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 










TEST INFORMATION 


3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

n 

CHAPTER 
7 8 ■ 

9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

192 

547 

497 

245 

172 

99 

161 

332 

133 

36 

252 

274 

292 

3232 

N/A 

20 

102 

133 

3 

0 

0 

5 

0 

4 

0 

0 

95 

29 

441 

Vdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

630 

243 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 


following 
the time of 

44 tests were withdrawn 
this validation: 

from ACVC 

Version 1.10 


E23005C 

A39005G 

B97102E 

C97H6A 

3C3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CB2A73A 

CD2.4733 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A34N 

CD2A34M 

CD50110 

CD2B15C 

CD7205C 

CD2D11B 

CD5007B 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 

CD7105A 

CD7203B 

CD7204B 

CD7205D 

CE2107I 

CE3111C 


CE3301A CE3411B 

See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 441 tests were inapplicable for the 
reasons indicated: 

a. The following 285 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX DIGITS: 


C24113F..Y (20 tests) 
C35706F..Y (20 tests) 


C35705F..Y (20 tests) 
C35707F..Y (20 tests) 








TEST INFORMATION 


■735703F.. Y <20 trusts) C35S02F..Z ''27 tests) 

C45241F..Y (20 tesr s ! C45321F..Y ^20 tests! 

C45421F..Y (20- tests! C45521F..Z (21 tests) 

C45524F..Z (21 tests) C45621F..Z (21 tests) 

C45641F..Y (20 tests) CA8012F..Z (21 tests) 

b. C35702A and 386001T are not applicable because this implementation 
supports no predefined type SHORT_FLOAT. 

c. The following 16 tests are not applicable because this 
implementation does not support a predefined type L0NG_IN7EGEE: 

C45231C C45304C C45502C C45503C C45504C 

C45504F C45611C C45613C C45614C C45631C 

C45632C 3S2004D C55B07A B55B09C 386001'-’ 

CD7101F 

d. C45531M..P (4 tests) and C45532M..P (4 tests) are not applicable 
because the value of SYSTEM.MAX_HANTISSA is less than 32. 

e. C36001F is not applicable because, for this implementation, the 
package TEXT_IO is dependent upon package SYSTEM. This test re¬ 
compiles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. 

f. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

g. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT, 
L0NG_FL0AT, or SHORT_FLOAT. 

h. CA2009A, CA2009C, CA2009F and CA2009D are not applicable because 

this compiler creates dependencies between generic bodies, and 
units that instantiate them (see section 2.2i for rules and 
restrictions concerning generics) . 

i. CD1009C, CD2A41A..E (5 tests), and CD2A42A..J (10 tests) are not 
applicable because this implementation imposes restrictions on 
’SIZE length clauses for floating point types. 

j. CD2A61I is not applicable because this implementation imposes 
restrictions on ’SIZE length clauses for array types. 

k. CD2A34B..I (8 tests) and CD2A84K..L <2 tests) are not applicable 
because this implementation imposes restrictions on ’SIZE length 
clauses for access types. 

l. CD2A91A..E (5 tests) are not applicable because ’SIZE length 
clauses for task types are not supported. 











TEST TTT^nR'TATT^T-T 


!>. CD2311G is not applicable because ' STORAGE_SIZE representation 
clauses are not supported for access types where the designated 
type is a task type. 

n. CD2B158 is not applicable because a collection size larger than 
the size specified was allocated. 

o. Tests CD5003B..I (8 tests), CD5011A..I (9 tests), CD501XK..M (4 

tests), CD5011Q..S (3 tests), CD5012A..J (10 tests), CD5012L..M (2 
tests), CD5013A..I (9 tests), CD5013K..O (5 tests), CD5013R..S (2 

tests), CD5014S..Z (3 tests) are not applicable because, for this 
implementation, type SYSTEM.ADDRESS is a limited private type. 

p. AE2101C, EE2201D, and EE2201E use instantiations of package 

SEQUENTIAL_IO with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this compiler. 

q. AE2101H, EE2401D, and EE2401G use instantiations of package 

DIRECT_I0 with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this compiler. 

r. CE2102D is inapplicable because this implementation supports 

CREATE with IN_FILE mode for SEQUENTIAL_IO. 

s. CE2102E is inapplicable because this implementation supports 

CREATE with 0UT_FILE mode for SEQUENTIAL_I0. 

t. CE2102F is inapplicable because this implementation supports 

CREATE with INOUTlFILE mode for DIRECT_I0. 

u. CE2102I is inapplicable because this implementation supports 

CREATE with IM_FILE mode for DIRECT_I0. 

v. CE2102J is inapplicable because this implementation supports 

CREATE with 0UT_FILE mode for DIRECT_I0. 

w. CS2102N is inapplicable because this implementation supports OPEN 
with IN_FILE mode for SEQUENTIAL_IO. 

x. CE21020 is inapplicable because this implementation supports RESET 
with INJFILE mode for SEQUENTIAL_I0. 

y. CE2102P is inapplicable because this implementation supports OPEN 
with 0UT_FILE mode for SEQUENTIAL_IO. 

z. CE2102Q is inapplicable because this implementation supports RESET 
with 0UT_FILE mode for SEQUENTIAL_IO. 










TEST INFORMATION 


aa. 0E2102R is inapplicable because this lmple-enta"ion supports OFF” 
with INO ; JT_FIuE mode for DIRECT_IO. 

ab. CE2102S is inapplicable because this implementation supports RESET 
with ITiOITT^FILE mode for DIRECT_IO. 

ac. CE2102T is inapplicable because this implementation supports OPEN 
with IN_FILE mode for DIRECT_IO. 

ad. CE2102U is inapplicable because this implementation supports RESET 
with IN_FILE mode for DIRECT_IO. 

ae. CE2102V is inapplicable because this implementation supports OPEN 
with 0UT_FILE mode for DIRECT_IO. 

af. CE2102W is inapplicable because this implementation supports RESET 
with 0UT_FILE mode for DIRECT_IO. 

ag. CE3102E is inapplicable because text file CREATE with IN_FILE mode 
is supported by this implementation. 

ah. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

ai. CE3102G is inapplicable because text file deletion of an external 
file is supported by this implementation. 

aj. CE3102I is inapplicable because text file CREATE with OUT_FILE 
mode is supported by this implementation. 

ak. CE3102J is inapplicable because text file OPEN with IN_FILE mode 
is supported by this implementation. 

al. CE3102K is inapplicable because text file OPEN with OUT_FILE mode 
is supported by this implementation. 

am. CE31113 and CE3115A open two internal files, both of which 
correspond to the same external file. The tests PUT a string to 
the first internal file, and then try to read this string from the 
second internal file. 

This implementation raises END_ERROR upon executing the GET 
statement because of the use of buffers which, are not flushed 
until the output of a line of page terminator. Due to LRM 14.1 
(13), the AVO ruled these tests not applicable. 












TES" TT-I70S 


3 . • 


TEST, PROCESSING, AND EVALUATION MODIFICATIONS 


will require modifications of code, 
order to compensate fnr legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 


If is expected that some tests 
processing, or evaluation in 


(otherwise) applicable 

test. 

Examples 

of such 

modifications include: 

adding a length clause 

to alter 

the default size of 

a collection; splitting 

a Class B test into 

subtests 

so that 

all errors are d 

etected; and 

confirming that messages produced by 

an executable test 

demonstrate 

conforming behavior that was not 

anticipated by the 

test (such 

as raising 

one exception instead < 

of another 

) . 




Modifications were required for 

79 tests. 




a. The following 

tests ware split because syntax errors 

at one point 

resulted in the compiler not det 

acting other errors i 

n M"! e test: 

B22003A 

B24007A 

B24009A 

B250023 

332201A 

3 34005M 

B34005T 

334007H 

335701A 

B36171A 

3 3 6 2 01A 

B37101A 

337102A 

B37201A 

B37202A 

B37203A 

337302A 

B 3 300 3 A 

3330033 

338003A 

3330033 

B38009A 

3330093 

3 3 310 3 A 

B331033 

B38103C 

B33103D 

338103E 

B43202C 

344002A 

343002A 

B480023 

343002D 

B48002E 

B43002G 

343003E 

B49003A 

349005A 

349006A 

349007A 

349009A 

3 4 A0 IOC 

B54A20A 

B54A25A 

B53002A 

B530023 

359001A 

359001C 

B59001I 

B62006C 

B67001A 

B67001B 

367001C 

367001D 

B74103E 

B74104A 

B35007C 

B91005A 

B95003A 

395007B 

B95031A 

B95074E 

BC1002A 

3C1109A 

BC1109C 

BC1206A 

BC2001E 

BC30053 

3C3009C 

3D5005B 




b. For the two tests BC3204C and BC3205D, the compilation order was 
changed to 

BC3204C0, Cl, C2, C3M, C4, C5, C6, C3M 
and 

BC3205D0, D2, DIM 

respectively. This change was necessary because of the compiler's 
rules for separately compiled generic units (see section 2.2i for 
rules and restrictions concerning generics). When processed in 
this order the expected error messages were produced for BC3204C3M 
and BC3205D1M. 

c. The two tests BC3204D and 3C3205C consist of several compilation 
■■nits each. The compilation units for the mam procedures are 
near the beginning of the files. When processing these files 
unchanged, a link error is reported instead of the expected 
compiled generic units. Therefore, the compilation files were 
modified by appending copies of the main procedures to the end of 






TEST INFORMATION 


these files. When processed, the expected error messages w-?re 
generated by the compiler. 

d. Tests C39005A, CD7004C, CD7005E and CD7006E wrongly presume an 

order of elaboration of the library unit bodies. These tests were 
modified to include a PRAGMA ELABORATE (REPORT); 

e. Test E28002B checks that predefined or unrecognized pragmas may 
have arguments involving overloaded identifiers without enough 
contextual information to resolve the overloading. It also checks 
the correct processing of pragma LIST. For this implementation, 
pragma LIST is only recognised if the compilation file is compiled 
without errors or warnings. Hence, the test was modified to 
demonstrate the correct processing of pragma LIST. 


For this implementation, the required support package specification, 
SPPRT13SP, was rewritten to provide constant values for the function names. 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 


Prior to validation, a sat of test results for ACVC Version 1.10 produced 
by the Tartan Ada ULTRIX Version INT-3 compiler was submitted to the AVF 
by the applicant for review. Analysis of these results demonstrated that 
the compiler successfully passed all applicable tests, and the 
compiler exhibited the expected behavior on all inapplicable tests. 

3.7.2 Test Method 

Testing of the Tartan Ada ULTRIX Version INT-3 compiler using ACVC 
Version 1.10 was conducted by IABG on the premises of TARTAN. The 
configuration in which the testing was performed is described by the 
following designations of hardware and software components: 


Host Computer: 

Machine: 

Operating System: 
Memory Size: 


VAX Station 3100 
ULTRIX V3.0 
9 MB 


Target Computer: 

Machine: 

Operating System: 
Memory Size: 


VAX Station 3100 
ULTRIX V3.0 
9 MB 


Compiler: 


Tartan Ada ULTRIX Version INT-3 








The original ACVC va> 01'!?*. to r Q validation. v 1 5 i t 1 Pi PM-f ro 

r- ■•'■•- ail ••/i i-’-.m> «an r-s<:s and s ■.Tgu-riug »i > « l Mii.ni .:-<•] ,,,-j ^>..int 

orec 15 ions . Tests that make us-? of 1 ’pi i 1 r * r i nn ^tirroific "t'S- 

also customized. Tests requiring nodifixations during the pr-validat i ■ ■<., 
testing were modified accordingly. 


A f'-.pe containing 

the 

customized AC V C 

«as 

read 

by the 

host 

computer . 

After the test 

f il 

es were loaded to 

disk, 

the 

full 

set of 

tests was 

compiled, linked, 
the host. 

and 

executed. Results 

were then 

evaluated and 

archived on 


The compiler 
LABORATORIES 
compiler was 
compiled with, 
the command 


was tested using command scripts provided 
INCORPORATED and reviewed by the validation 
tested using no option settings. All chapter B 
the listing option on (i.e. -La) . The linker was 


by 

f ~ 3 ;n . 
r ~S f S 

railed 




alib link <testnam.e> 

A full list of compiler and linker options is given in Appendix E. 


3.7.3 Test Site 

Testing was conducted at TARTAN LABORATORIES INCORPORATED, Pittsburgh and 
was completed on 7 December 1989. 









DECLARATION OF CONFORMANCE 


APPENDIX A 

DECLARATION OF CONFORMANCE 


TARTAN LABORATORIES INCORPORATED has submitted the fo 
Declaration of Conformance concerning the Tartan Ada 
Version INT-3 compiler. 


liowing 

ULTRIX 










DECLARATION OF CONFORMANCE 


Compiler Implementor: Tartan Laboratories Incorporated 

Ada Validation Facility: IABG mbH, Dept. SZT 

Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Compiler Name: 
Base Compiler Version: 
Host Computer: 

Target Computer: 


Base Configuration 

Tartan Ada ULTRIX 
Version INT-3 

VAX Station 3100 under ULTRIX V3.0 
VAX Station 3100 under ULTRIX V3.0 


Implementor*s Declaration 

I, the undersigned, representing Tartan Laboratories Incorporated, 
have implemented no deliberate extensions to the Ada Language 
Standard ANSI/MIL-STD-1815A in the compiler(s) listed in this 
declaration. I declare that Tartan Laboratories Incorporated is the 
owner of record of the Ada Language compiler(s) listed above and, as 
such, is responsible for maintaining sa.La compiler(s) in conformance 
to ANSI/MIL-STD-1815A. All certificates and registrations for Ada 
Language compiler(s) listed in chis declaration shall be made only in 
the owner's corporate name. 



Date: 


Tartan Laboratories Incorporated 
Ed Lieblein, Sr. VP, Development 


r 7, /fcPf 


Owner's Declaration 

I, the undersigned, representing Tartan Laboratories Incorporated, 
take full responsibility for implementation and maintenance of the 
Ada compiler(s) listed above, and agree to the public disclosure of 
the final Validation Summary Report. I declare that all of the Ada 
Language compilers listed, and their host/target performance, are in 
compliance with the Ada Language Standard ANSI/MIL-STD-1815A. 

- Date: Z 

Tartan Laboratories Incorporated 
Ed Lieblein, Sr. VP, Development 





APPENDIX F OF THE Ada STANDARD 


APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies corres¬ 
pond to implementation-dependent pragmas, to certain machine- 
dependent conventions as mentioned in chapter 13 of the Ada Stan¬ 
dard, and to certain allowed restrictions on representation 
clauses. The implementation-dependent characteristics of the 
Tartan Ada ULTRIX Version INT-3 compiler, as described in this 
Appendix, are provided by TARTAN LABORATORIES INCORPORATED. 
Unless specifically noted otherwise, references in this appendix 
are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, are 
contained in Appendix F. 







Chapter 5 

Appendix F to MIL-STD-1815A 


This chapter contains the required Appendix F to Military Standard. Ada Programming Language, 
ANSI/MEL-STD-1815A (.American Nanonai Standards Institute, Inc., February 17. 1983') . 

5.1. PRAGMAS 

5.1.1. Predefined Pragmas 

This section summarizes the effects of and restrictions on predefined pragmas. 

• Access collections are not subject to automatic storage reciamauon so pragma ICNTRCLLSO has no effect. 
Space deallocated by means of UNCH EC KEE _ISALLCCATICft -mil be reused by the allocation of new 
objects. 

• Pragma ELABORATE is supported. 

• Pragma INLINE is supported. The body tor an mlined subprogram need not appear in the same compila- 
uon unit as the call. Inlining will take place only if the subprogram boay is present in the library and is not 
obsolete. 

« Pragma I NT ERE ACE is not supported. The implementauon-defined pragma rcREI3N_3CDY (see Sec¬ 
tion 5.1.2.2) can be used to interface to subprograms written in other languages. 

• Pragma LIST is supported but has the intended effect only if the command line option -La was supplied 
tor compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma OPTIMIZE is supported except when at the outer level that is. in a package specificauon or 
body;. 

• Pragma PACK is fully supported. 

• Pragma PAGE is supported but has the intended effect only if the command line opuon -La was supplied 
for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma PRIORITY is fully supported. 

• Pragma SUPPRESS is fully supported as required by Ada LRM 11.”. 

• Future releases of the compiler will support the following pragmas: MEMCRY_3IIE. SHARES. 
STCRAGEJJNIT and 5YST£M_NANS. 

A warning message will be issued if an unsupported pragma is supplied. 

5.1.2. Implementation-Defined Pragmas 

.'mplemencauon-defined pragmas provided by Tartan are described in he following sections. 

5.12.1. Pragma LINXAGZ_NAME 

The pragma LINKAGZ_MAME associates an Ada entity with a string that is meaningful externally, e.g.. to a 
linkage editor. It takes the form 

pragma LINKAGE_MAME (Ada-umpie-mme. string-constant) 


5-1 







USER MANUAL FOR TARTAN aOa LXTROC 


The Ada-simple-name must be the name of an Ada enaty declared in a package specification. This endty must be 
one chat has a runtime representation: e.g.. a subprogram, exception or object. It may not be a named number or 
smng constant. The pragma must appear after the declarauon of the entity in the same package specification. 

The effect of the pragma is to cause the string-constant to be used in the generated assembly code as an 
external name for the associated Ada enaty. It is the responsibility of the user to guarantee that this string 
constant is meaningful to the linkage editor and that no illegal linkname ciasnes arise. 

6.122. Pragma rCRSIGN_3GDY 

A subprogram written in another language can be called trom an Ada program. Pragma ~CR£Z3N_3CC'l is 
■used to indicate that the body for a non-genenc top-levei package specification is provided in the form of an 
object module. The bodies for several subprograms may be contained in one object module. 

Use of the pragma FCRS:::GN_3CCY dictates that ail subprograms, excepuons and objects in the package are 
provided by means of a foreign object module. In order to successfully link a program including a foreign body, 
the object module for that body must be provided to the library using the iL-z foreign command described 
in Section AT. 

The pragma is of the form: 

pragma FCR£GGN_3CDY l language _name eiaooranon routine -ame\ ) 

The parameter language jiame ts a scnng intended to allow me compiler to idenafy the calling convenaon used 
by he foreign module (but this functionality is not yet in operation;. Currendy. the programmer must ensure that 
the calling convention and data representation of he foreign body procedures are compatible with those used by 
he Tartan Ada compiler. Subprograms called by tasks should be reentrant. 

The opuonai eiaooranon _rounne_name smng argument provides a means to initialize the package. The 
rouane specified os die elaboration joitune jiame. which will be called for he elaboration of his package body, 
must be a global routine in the object module provided by he user. 

A specificanon that uses this pragma may contain only suborogram declarauons, object decaraaons that use 
an unconstrained type mark, and numoer declarauons. Pragmas may also appear m he package. The type mark 
for an object cannot be a task type, and the object declarauon must not have an iniual value expression. The 
pragma must be given prior to any declarauons within he package specificanon. If he pragma ts not located 
before he first declaraaon. or any restriction on he declarations is violated, he pragma is ignored and a warning 
;s generated. 

The foreign body is entirely responsible for initializing objects declared n a package utilizing pragma 
?CRSIGN_3CDY. In particular, he user should be aware hat he implicit imuanzauons described in LRM 3.2.1 
are not done by he compiler. (These implicit miuaiizauons are associated with objects of access types, certain 
record types and composite types containing components of he preceding kinds of types.) 

Pragma LGNKAG2_NAME should be used for all declarauons in he pacxage. including any declarauons in a 
nested package speaficauon to be sure hat here are no confiicung link names. If pragma l:nkaG2_MAM£ is 
not used, he cross-reference qualifier, -x. (see Section 3.2) should be used wnen invoking he compiler and he 
resulting cross-reference able of linknames inspected to identify he limcnames assigned by he compiler and 
determine mat here are no confiicung iinxnames i,see also Secuon 3.S’). 

In he following example, we want to call a funcuon plan wrucn comoutes polynomials and is wnuen in C. 









\??EN'DK r TO .VflL-STD-;3l5A 


package MATH_rUNC3 is 

pragma rCREIGN_30DY C*C") ; 

function POLYNOMIAL (X: INTEGER) return INTEGER; 

—Ada spec matching the C routine 
pragma LINKAGe"_NAME (POLYNOMIAL, "oimn") ; 

—Force compiler to use name "plmn’' when referring to this 
— function 
end MATH_FUNC3; 

with MATH_FVNCS; use MATH_FUNC3 
procedure MAIN is 

X: INTEGER := POLYNOMIAL ill) ; 

— Will generate a call to "plmn" 
begin . . . 
end MAIN; 

To compile, link and run the above program, you do the following steps: 

1. Compile MATH_FVNC3 

2. Compile MAIN 

3. Obtain an object module (e.g. math, toff) containing the compiled code for p_mr„ 

Issue the command 

alib foreign math_fur.es math, toff 
5. Issue the command 

alif> link main 

Without Step -. an attempt to link will produce an error message informing you of a missing package body for 
MATH_r*JNC3. 

Using an Ada body from another Ada program library. The user may compile a body written in Ada fora 
specification into die library, regardless of the language specified in the pragma contained in the specification. 
This capability is useful for rapid prototyping, where an Ada package may serve to provide a simulated response 
for the functionality that a foreign body may eventually produce. It also allows the user to replace a foreign body 
with an Ada body without recompiling the specification. 

The user can either compile an Ada body into the library, or use the command a_ir foreign (See Section 
■O to use an Ada body from another library. The Ada body from another library must have been compiled 
under an idenucai specification. The pragma LINKAGE_NAME must have been applied to all entities declared in 
the specification. The only way to specify the linkname for the elaboration routine of an Ada body is with the 
pragma FOR£IGN_3CDY. 

Using Calls to the Operating System. In some cases, the foreign code is actually supplied by the operating 
system (in the case of system cails) or by runume libraries for other programming languages such as C. Such 
calls may be made using a dummy procedure to supply a tile specification to the a_-o foreigncommancL 
You need a dummy .oof; file which may be obtained m a number of wavs. Cne way is to compile the 
procedure 

procedure TUMMY is 
begin 
null; 

end; 

Then, use the library command 

alio foreign pkq dummy.coff 

where pkq is the name of the package that contains the pragma linkage_name for the operating system call. 
For example to use the ULTRIX system call _sar .< in the program TEST: 


5-3 










USER MANUAL FCR TART.AN aDA L'LTRIX 


Package memory is 

pragma ?0R£IGN_30DY ("ASM"); 
procedure GET_VIRTUAL_MEMCRY (MEM: INTEGER) ; 
pragma LINKAGE_NAME - GET VIRTUAL MEMORY, " sbrk "); 
end MEMORY; 

with MEMORY; 
procedure TEST is 

begin 

3ET_VIRTUAL_MEMCRY (MEM) ; 
end TEST; 

Obtain the file dummy .caff. Then use 

aiib foreign memory dummy.Toff 
to include the body for die system call in the library. 

5.2. IMPLEMENTATION-DEPENDENT ATTRIBUTES 

No implementation-dependent attributes are currently supported. 

5.3. SPECIFICATION OF THE PACKAGE 3*2 STIM 

The parameter values specified for the VAX in package SYSTEM [LRM 13.7.1 and Appendix C, are: 

package SYSTEM is 

type ADDRESS is new INTEGER; 
type NAME is (VAX) ; 

SYSTEM_NAM£ : constant NAME VAX; 

STORAGE UNIT : constant :» 3; 

MEMORY_SIZE : constant 1_3CC_00C; 

MAX_INT : constant :« Z L 4 V_4 3 3_5 >4 ~ ; 

MIN~INT : constant :» -MAX_INT ~ I; 

MAX^OIGITS : constant : - 9: ~ 

MAX_MANTISSA : constant : - 31; 

EINE_OELTA : constant :» 2*1.0+e-31; 

TICK*" : constant 0.015S7; 

subtype PRIORITY is INTEGER range 10 .. ZOO; 

0EEACJLT_?R2ORITY : constant PRIORITY : - PRIORITY'EIRST; 

RUNTIME - ERROR : exception; 

end SYSTEM; - 

5.4. RESTRICTIONS ON REPRESENTATION CLAUSES 

The following sections explain the basic restrictions for representation speciticauons followed by addiuonal 
restrictions applying to specific kinds of clauses. 

5.4.1. Basic Restriction 

The basic restriction on representation speciticauons LRM 13.1) that they may be given only tor types 
declared in terms of a type definition, excluding a ger.era.c_cype_defcnucuon (LRM 12.11 and a 
prTrac3_cyoe_dafi.nj.ci.on (LRM 7.4). .Any representauon clause in violation of these rules is not obeyed 
by the compiler a diagnostic message is issued. 

Further restncuons are explained m (he following sections. Any representauon clauses violaung those restric¬ 
tions are not obeyed but cause a diagnosuc message to be issued. 











APPENDIX ? TO MIL STD-1 31!A 


5.4.2. Length Clauses 

Length clauses [LRM 13.2] are. in general, supported. For details, refer to the following sections. 

5.42.1. Size Specifications for Types 

The rules and restrictions for size specifications applied to types of various classes are described below. 

The following principle rules apply: 

1. The size is specified in bits and must be given by a stauc expression. 

2. The specified size is taken as a mandate to store objects of the type in the given size wherever feasible. 
No attempt is made to store values of the Lype in a smaller size, even if possible. The following rules 
apply 'with regard to feasibility: 

• An object tnat is not a component of a composite object is allocated with a size and alignment that 
is referable on the target machine; that is. no attempt is made to create objects of non-referable size 
on the stack. If such stack compression is desired, it can be achieved by die user by combining 
multiple stack variables in a composite object; for example 

v/pe My 2nun as (A,31; 
for My_anum'siofi use 1; 

7, W: My_anum; — well occupy owe storage 

— ur.oos or. one soac.c 

— (of allocacad at all! 
type rec '.3 record 

7,W: Mv_enum.- 
end record; 
pragma ?aci<!rec); 

1: rec; — will occupy one storage ur.it 

• A formal parameter of the type is sized according to calling conventions rather than size 
specificauons of the type. Appropriate size conversions upon parameter passing take place 
automatically and are transparent to (he user. 

• Adjacent bus to an object that is a component of a composite ooject. but whose size is 
non-referable, may be affected by assignments to tne object, uniess these bus are occupied by other 
components of the composite object; that is. wnenever possible, a component of non-referable size 
is made referable. 

In ail cases, the compiler generates correct code for all operations on objects of the type, even if they are 
stored with differing representational size in different contexts. 

Note: A size specification cannot be used to force a certain size in vaiue operations of the type: for 
example 

V/pe mv_inc ia r3nce 2. .53523; 
for my_i r.z'3zze use IS; — c . i. 

A,3: ny_inc; 

...A - 3... -- c.-.is operacror. wi__ general!./ re 
-- executed on 32-ort values 

3. A size specification for a type specifies the size for objects of this type and of all its subeypes. For 
components of composite types, whose subtype would ailow a shorter reoresentauon of the component, 
no attempt :s made to take advantage of such shorter represeniauons. In contrast, for types without a 
length clause, such components may be represented m a lesser number of bits than die number of bus 
required to represent all values of the type. Thus, in the example 


5-5 













USER MANUAL FOR TARTAN ADA U'LTRK 


cype MY_INT rs range 7. . 2”15-.; 
for MY_:NT'3IZE use 15; -- (1) 
subtype SMALL_MY_:N’: ls MY_ZNT range 3. .255; 
type R is record. 

X: 3MALL_FIY_:NT; 

end record; 

the component R„X will occupy 16 bits. In the absence of the length clause at i.l), R.X may be represented 
in 3 bits. 

For the following cype classes, the sice specification must coincide with the default sue chosen by the compiler 
for the type: 

• access types 

• floating-point types 

• task types 

No useful effect can be achieved by using sue specifications for these types. 

5.42 2. Size Specification for Scalar Types 

The specified size must accommodate ail possible values of the type including the value 0 (even if 0 is not in 
the range of the values of the type). For numeric types with negauve values the number of bits must account for 
the sign biL No skewing of the representation is attempted. Thus 
cype my_rnc is range 100..101; 
requires at least 7 bus. although it has only two values, while 
cype my_inc is range -101..-100; 
requires 3 bits to account for die sign bit 

A size specification for a real type does not affect the accuracy of operauons on the type. Such influence 
should be exerted via the accuracy_defcnLCi.cn of die type tLRM 3.5.", 3.5.9). 

A sue specification for a scalar type may not specify a sue larger than the largest operauon size supported by 
the target architecture tor the respecuve class of values of the type. 

5.42.3. Size Specification for Array Types 

A sue specification for an array cype must be large enough to accommodate ail components of the array under 
the densest packing strategy explained below in adherence to any alignment constraints on the component type 
(see Section 5.4.7). 

The size of the component type cannot be influenced by a length clause for an array. Within the limns of 
representing all possible values of the component subtype i but not necessarily of its type), the representation of 
components may. however, be reduced to the minimum number of bits, unless the component type carries a size 
specification. 

If there is a size speaficauon for the component type, but not for the array type, the component sue is 
rounded up to a referable sue. unless pragma PACK is given. This applies even to coo lean types or other types 
that require only a single bu for the representauon of ail values. 

5.42.4. Size Specification for Record Types 

A stze specification for a record type does not influence the default type mapping of a record type. The sue 
must be at least as large as the number of bits determined by type mapping. Influence over packing of com¬ 
ponents can be exerted by means of (partial) record representauon clauses or by Pragma PACK. 

Neither the size of component types, nor the representation of component subtypes can be influenced by a 
length clause for a record. 


5-6 










\??ENDIX r TO VOL-STO-iSliA 


The only implementaaon-dependent components allocated by Tartan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record or contain relative offsets of components within a 
record layout for record components of dynamic size. These implementation-dependent components cannot be 
named or sized by the user. 

A size specification cannot be applied to a record type wtih components of dynamicaily determined size. 

Note: Size specifications for records can be used only to widen the representation accomplished by padding at 
the beginning or end of the record. Any narrowing of the representation over default type mapping must be 
xcomotished by representation clauses or pragma pack. 

5.4 2.5. Specification of Collection Sizes 

The specification of a collection size causes the collection to be allocated with the specified size. It is 
expressed in storage units and need not be static; refer to package SYSTEM for the meaning of storage units. 

.Any attempt to allocate more objects than the coilecaon can hold causes a 3TCPA.GE_SRP.CR exception to be 
raised. Dynamicaily sized records or arrays may carry hidden administrauve storage requirements that must be 
accounted tor as pan of the collecdon size. Moreover, alignment constraints on the type of the allocated objects 
may make it impossible to use all memory locations of the allocated coilecaon. Funnei-more. some administra¬ 
tive overnead for the allocator must be taken into account by the user ("currently 1 word per allocated object). 

In the absence of a specificauon of a coilecaon size, the coilecaon is extended automaucaily if more objects 
are allocated than possible :n the coilecaon ortgmaily allocated with the compiler-estabiisned default size. In this 
case. 3TCRAGE_ERRCR is raised only when the available target memory is exhausted. If a collecuon size of 
zero is specified, no access coilecaon is allocated. 

5.42.6. Specification of Task Activation Size 

The specification of a task acavauon size causes the task acava uon to be allocated with die specified size. It 
is expressed in storage units: refer to package SYSTEM, for die meaning of storage units. 

Any attempt to exceed the acuvauon size during execution causes a 3TCRAGE_£RRCR exception to be 
raised. Unlike coilecaons. there is generally no extension of task acuvauons. 

5.42.7. Specification of' SMALL 

Gniv powers of Z are allowed for ' SMALL. 

The length of the representation may be affected by this specificauon. If a size specificauon is also given tor 
the tvpe. the size specification takes precedence; the specificauon of ' SMALL must hen be accommodatabie 
wumn the specified size. 

5.4.3. Enumeration Representation Clauses 

"or enumeration representauon clauses "LRM 13.31, the following restrtcuons apply: 

♦ The internal codes specified for the literals of the enumeration type mav be any integer value between 
INTEGER' ETRST and INTEGER' LAST. It is strongly advised to not provide a representauon clause that 
merely duplicates 'he default mapping of enumeration types, wnicn assigns aonsecuuve numbers ;n as¬ 
cending order starting with 0, since unnecessary runtime cost is incurred by sucn duplicauon. It should be 
noted that the use of attributes on enumerauon types wuh user-spec:fed encoamgs is costly at run ume. 

• Array types, whose mdex type is an enumerauon tvpe with non-conuguous vaiue encodings, consist of a 
contiguous sequence of components. Indexing ;mo cne array involves a mnume transiauon of the index 
value mio the corresponding posiuon vaiue of the enumerauon type. 


5-7 








USER .MANUAL 'OR TARTAN ADA JLTRdX 


5.4.4. Record Representation Clauses 

The alignment clause of record representation clauses [LRM 13.-1] is observed. The specified expression 
must yield a target-dependent value. 

Static objects may be aligned ax powers of 2 up to a page boundary. The specuied alignment becomes the 
minimum alignment of the record type, unless the minimum alignment of the record forced by the component 
alloc anon and the minimum alignment requirements of the components is already more stringent than the 
specified align menL 

The component clauses of record representation clauses are allowed only for components and discriminants 
of stancaily determinable sue. Not all components need to be presenL Component clauses for components of 
variant parts are allowed only if the size of the record type is statically determinable for every variant. 

The sue specified for each component must be sufficient to allocate all possible values of the component 
subtype (but not necessarily the component type). The locauon specuied must be compatible with any alignment 
constraints of the component type: an alignment constraint on a component type may cause an implicit alignment 
constraint on the record type itself. 

If some, but not ail. discriminants and components of a record type are described by a component clause, then 
the discriminants and components without component clauses are allocated alter those with component clauses; 
no attempt is made to utilize gaps left by the user-provided allocation. 

5.4.5. Address clauses 

Address clauses (LRM 13.5] are sup pored with the following restrictions: 

• When applied to an object an address clause becomes a linker directive to allocate the object at the given 
address. For ary object not declared immediately within a top-level library package, the address clause is 
meaningless. Address clauses applied to local packages are not suppored by Tartan Ada. Address clauses 
applied to library packages are prohibited by the syntax; therefore, an address clause can be applied only to 
a package if it is a body stub. 

• Address clauses applied to subprograms and tasks are implemented according to the LRM rules. When 
applied to an encry, the specified value identifies an interrupt in a manner customary for the targeL 
Immediately after a task is created, a runtime call is made for eacn of its encr.es having an address clause, 
establishing the proper binding between the entry and the interrupt. 

• Specified addresses must be constants. 

5.4.6. Pragma PACK 

Pragma PACK (LRM 13.1] is supported. For details, refer to the following sections. 

5.4.6.I. Pragma PACK for Arrays 

If pragma PACK is applied to an array, the densest possible representauon is chosen. For details of packing, 
refer to me explanation of size spectficauons for arrays i Section 5A2.3L 
If. ;n addition, a length clause is applied to 

1. me array type, the pragma has no effect, since such a length clause already uniquely determines the array 
packing method. 

2. me component type, me array is packed densely, observing the component s length clause. Note that die 
comoonenc length clause may have the erfect of preve.oung the comDiier rrom packing as densely us 
would be the detauit if pragma PACK is applied -vnere there vas no length clause given for 'die com¬ 
ponent cy{5e. 


5-* 







APPENDIX = 70 MEL-STD-tSliA 


5.4.62. The Predefined Type String 

Package STANDARD applies Pragma PACK to the type scrang. However, when applied to character arrays, 
this pragma cannot be used to achieve denser packing than is the default for the target: 1 character per 8-bit 
word. 

5.4.63. Pragma PACK for Records 

If pragma PACK is applied to a record, the densest possible representation is chosen that is compatible with 
the sizes and alignment constraints of the individual component types. Pragma PACK has an effect only if the 
sizes of some component types are specified explicitly by size specifications and are of non-referable nature. In 
the absence of pragma PACK, such components generally consume a referable amount of space. 

It should be noted that default type mapping for records maps components of boolean or other types that 
require only a single bit to a single bit in the record layout, if there are multiple such components in a record. 
Otherwise, it allocates a referable amount of storage to the component. 

If pragma PACK is applied to a record for which a record representation clause has been given detailing the 
allocation of some but not all components, the pragma PACK affects only the components whose allocadon has 
not been detailed. Moreover, the strategy of not utilizing gaps between explicitly allocated components sail 
applies. 

5.4.7. Minimal Alignment for Types 

Certain alignment properties of values of certain types are enforced by the type mapping rules. Any represen¬ 
tation specification h : nnot be sausfied within these constraints is not obeyed by the compiler and is ap¬ 
propriately diagnosed 

.Alignment .or ..amts are caused by properties of the target architecture, most notably by the capability to 
extract non-Migned component values from composite values in a reasonably efficient manner. Typically, restric¬ 
tions exist that make extracaon of values that cross certain uddr”s boundaries very expensive, especially in 
contexts involving array indexing. Permuung data layouts that require such complicated extracuons may impact 
coda quality on a broader scale than mereiv m the local context of such extractions. 

Instead of describing the precise algorithm of establishing the minimal alignment of types, we provide he 
general rule that is being enforced by he alignment rules: 

• No object of scalar type including components or subcomponents of a composite type, may span a target- 
dependent address boundary hat would mandate an extracaon of he object's value to be performed by two 
or more extracuons. 

5.5. IMPLEMENT A TION-GENERA TED COMPONENTS IN RECORDS 

The only implementauon-dependent components allocated by Tartan Ada m records contain dope informauon 
for arrays 'whose bounds depend on discriminants of he record. These components cannot be named by he user. 

5.6, INTERPRETATION OF EXPRESSIONS APPEARING IN ADDRESS CLAUSES 

Secaon 13.5.1 of he Ada Language Reference Manual describes a syntax for associaung interrupts wuh task 
entries. Tartan Ada implements he address clause 
for 7CENTS- use at ar.cED; 

by associaung the interrupt specified by ar.cED with he caer.cry entry of he risk containing this address 
clause. The mterpretauon of ante ED ts boh machine and compiler dependent. 


5-9 









cser manual .-or tartan aoa jltrix 


5.7. RESTRICTIONS ON UNCHECKED CONVERSIONS 

Tartan supports ’JNCHEC:<S3_CQNV2RSION with a restncuon that requires the sizes of both source and 
target types to be known at compile time. The sizes need not be the same. If the value in the source is wider than 
that in the target, the source value will be truncated. If narrower, it will be zero-extended Calls on instantiations 
of 'JNCHECXS3_CCNVSRSI0N are made inline automatically. 

5.8. IMPLEMENTATION-DEPENDENT ASPECTS OF INPUT-OUTPUT PACKAGES 

Tartan Ada supports all predefined input/output packages [LRM Chapter Ul with the exception of 
LCW_L2VZL_:0. 

5SCUENTrAi_:o and PIR£CT_:o may not be instantiated on types whose representation size is greater 
chan 32255 bytes. .Any attempt to read or wnte values of sucn types raises 'JS2_£RRCR. 

S2CUSNTIAL_£0 and DIR£CT_-0 may not be instanuated on unconstrained array types, nor on record 
record types with discriminants without default values. 

An attempt to delete an external file while more than one internal file refers to this external file raises 
■JSS_2RRCR. 

When an external tile is referenced by more than one internal file, an attemot to reset one of those internal 
files to CUT_r£12 raises L'S2_2RRCR. 

An attempt to create a file with r;L2_MCD£ VA_?ZZZ raises 'JS2_£RRCR. 

Since the implementation of the input-output packages uses buffers, output to one tile cannot necessarily be 
read immediately mom another file associated with the same external tile. 

The FORM parameter of file management subprograms is ignored. 

.An attempt to read a non-existent data record through the operations of 3 £Q'J£NT:al_:o or 3IR£CT_:o 
raises 3ATA_£RRCR. except that 2ND_£RRGR is raised when reading beyond the end of tile. 

If an ULTRIX system call returns an error number that cannot be mapped onto a predefined Ada exception, 
the exception 3£7rC2_£RR0R is raised. 

5.9. OTHER IMPLEMENTATION CHARACTERISTICS 

The following information is supplied in addiuon to that required by Appendix F to MIL-STD-1815A. 

5.9.1. Definition of a Main Program 

.Any Ada library subprogram unit may be designated me main program tor purposes of linking > using the 
ales command! provided that the subprogram has no panmeters. 

Tasks initiated in imported library units follow the same rules for termination us other tasks [described in 
LRM 9.4 (6-10)]. Specifically, these tasks are not terminated simply because the main program has terminated. 
Terminate alternatives in selecuve wait statements in library tasks are therefore strongly recommended. 

5.9.2. Implementation of Generic Units 

All instantiations of generic units, except the predetined generic 'JNC:-:£CX22_CCNV2RS 3 CM and 
■JbiCH2C:<23 32A1LCCAT2CN subprograms, are implemented by code duplications. No attempt at sharing 
code by muiopie mstanuauons is made in this release of Tartan Ada. 'Code sharing will be implemented m a 
later release, i 

Tartan Ada enforces the restncuon that the body of a generic unit must be complied before the unit can be 
insinuated. It Joes not impose the restncuon that the specificauon and body or a generic unit must be provided 
as pan of the same ccmpilauon. A recompilauon of the body of a generic unit will obsolete any units that 
insinuated this generic unit. 


5-10 







APPENDIX FTO .VflL-STD-UtJA 


53 J. Implementation-Defined Characteristics in Package STANDARD 

The implementation-dependent characteristics for SUN in package STANDARD [Annex C] are: 
package STANDARD is 

type BYTE INTEGER is range -128 .. 127; 

type SHORT_INTEGER is range -327S8 .. 32767; 

type INTEGER is range -2_147_483_648 .. 2_147_483 647; 

type FLOAT is digits 6 range -16#o77FFF_FF8#E+32 .. - 16#Q.7FFF_FF8#E+32; 

type LONG FLOAT is digits 9 range -16#0.7FFF FFFF_FFFF_FE*E+256 .. 

16#0.7FFF_FFFF_FFFF_FE0#E+256 ;“ 
type DURATION is delta 0.0001 range -86400.0 .. 36400.0; 

— DURATION'SHALL - 2#1.0#E-14 (that is, 6.103516E" 5 sec) 

end* STANDARD; 

53.4. Attributes of Type Duration 

The type DURATION is defined with the following characteristics: 

DURATION' DELTA is 0.02 sec 
DURATION' SMALL is 0.015625 sec 
DURATION' FIRST is -86400.0 sec 
DURATION'LAST is 86400.0 sec 

533. Values of Integer Attributes 

Tartan Ada supports the predefined integer types INTEGER, SHORT_INTSGER and BYTE_INTEGER. The 
range bounds of the predefined type INTEGER are: 

INTEGER'FIRST a 
INTEGER' LAST a 2**31-l 

SHORT_INTSG£R' FIRST a -2**15 
SHORT_INTEGER' LAST a 2**15-1 • 

BYTS_INTEGER'FIRST a -128 
BTTE“lNTEGER'LAST a 127 

The range bounds for subtypes declared in package text_io are: 

COUNT'FIRST a 0 

COUNT'LAST * INTEGER'LAST - 1 

POSITIVE_COUNT'FIRST a 1 
?OSITIVE~COUNT' LAST a INTEGER' LAST - 1 

FIELD'FIRST a0 
FIELD'LAST a 20 

The range bounds for subtypes declared in packages DIRECT_I0 are: 

COUNT'FIRST a0 

COUNT'LAST a INTEGER'LAST 

?OSITIVE_COUNT'FIRST a 1 
POSITIVE - COUNT' LAST a COUNT' LAST 


5-11 









USER MANUAL "OR TARTAN ADA ULTRDC 


5.9.6. Values of Floating-Point Attributes 

Tartan Ada supports tile predefined floating-point 
VAX F- form at floating-point representation; LGNG_F: 

Attribute 


types FLOAT and LONG_FLGA 
-GAT, onto the D-format. 

Value for FLOAT 


T. FLOAT maps onto the 


DIGITS 


MANTISSA 


2?SILON 
approximately 


1640.1000 0CC#E-i 
9.5367AE-07 


SMALL 

approximately 


1640.3000 000#E-2l 
2.33A94E-:6 


LARGE 

approximately 


1640.FFFF F304E-t-21 
1.93-2SE-25 


SAFE EMAX 


SAFE_SMALL 

approximately 


1640.1000 T004E-31 
2.9387AE-39 


3AFE_LARGE 

approximately 

FIRST 

approximately 


approximately 


1640.7FFF FC0#£-32 
1.701-WE-38 

-I6*0.~FF? FF8#Ei-32 
-1.701-UE-38 

!640.7'rrr_?F34E-^32 

1.70U1E-33 


MACHINE RADIX 


MACHINE MANTISSA 


MACHINE EMAX 


MACHINE EMIN 


MACHINE ROUNDS 


MACHINE OVERFLOWS 


5-1 









APPENDIX FTO .VDL-STD-1315A 


Attribute 

Value for LONG FLOAT 

DIGITS 

9 

MANTISSA 

31 

EMAX 

12-1 

EPSILON 

approximately 

16*0.4CC9 QO00j3OO0_QOO#E-7 

9.3132257A6154.8E-10 

SMALL 

approximately 

16^*0.3000 OOCO 0000_000#E-31 
2.3509887016U6E-38 

LARGE 

approximately 

16#0.FFFF FFFE_0000_000#E-f31 

2.12676*7922655E *-37 

safe_emax 

127 

3AFE_3MALL 

approximately 

16*0.1000 CCOO_OOOO_0CO#E-31 
2.9387353770557E-39 

3AFE_LARGE 

approximately 

16<0.7FFF FrFF_0000_000#E-*-32 
1.70141 l83*38l24E-t-38 

FIRST 

approximately 

. 16*0. .H'rr FFFF_FFFF_FF3#E-t-32 
-1.701411S346047E+38 

LAST 

approximately 

16*0.7F??_FFFF_FFFF _FF3#E*-32 
1.7014118346047E *-38 

MACHINE_RADIX 

* 

MAC HINE_MANT13 3A 

56 

MACHINE_EMAX 

127 

MACHINE_SMIN 

-127 

MACHINE_RCGND S 

TRUE 

MACHINE OVERFLOWS 

TRUE 


5*13 







TEST PARAMETERS 


APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension .TST in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character, and the use of the character signifies 

concatenation of the preceeding and following strings. The values within 
single or double quotation marks are to highlight character or string 
values: 

Name and Meaning Value 

$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

SBIG_ID1 239 * 'A' & '1' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID2 except 
for the last character. 

$BIG_ID2 239 * 'A' & ’2' 

An identifier the size of the 
maximum input line length which 
is identical to $3IG_ID1 except 
for the last character. 

SBIG_ID3 120 * 'A' & '3' & 119 * 'A' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID4 except 
for a character near the middle. 








TEST PARAMETERS 


Marne and Meaning Value 

$BIG_ID4 120 * 'A' & ’4' & 119 * 'A' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID3 except 
for a character near the middle. 

$BIG_INT_LIT 237 * 'O’ & ”298” 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$8IG_REAL_LIT 235 * ’O’ * "690.0" 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 

$3IG_STRING1 & 120 * 'A' & "" 

A string literal which when 
catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 & 119 * 'A' & '1' & "" 

A string literal which when 
catenated to the end of 
BIG STRING1 yields the image of 
BIG_ID1. 

SBLANKS 220 * ’ ’ 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

$COUNT_LAST 2147483646 

A universal integer literal 
Whose value is TEXT_IO.COUNT'LAST. 

$DEFAULT_MEM_SIZE 1_000_000 

An integer literal whose value 
is SYSTEM.MEMORY_SIZE. 

$DEFAULT_STOR_UNIT 8 

An integer literal whose value 
is SYSTEM.STORAGE UNIT. 








TEST PARAMETERS 


Marne and Meaning Value 

$ D EF AULT _S Y S _N AME VAX 


The value of the constant 
SYSTEM.SYSTEM JIAME. 

$DELTA_DOC 

A real literal whose value is 
SYSTEM.FINE_DELTA. 

SFIELD_LAST 

A universal integer 

literal whose value is 
TEXT_IO.FIELD*LAST. 

SFIXEDJJAME 

The name of a predefined 
fixed-point type other than 
DURATION. 

$FLOAT_NAME 

The name of a predefined 
floating-point type other than 
FLOAT, SHORT_FLOAT, or 

LONG_FLOAT. 

$GREATER_THAN_DURATION 

A universal real literal that 
lies between DURATION*BASE'LAST 
and DURATION*LAST or any value 
in the range of DURATION. 

$GREATER_THAN_DURATION_BASE_LAST 

A universal real literal that is 
greater than DURATION*BASE'LAST. 

$HIGH_?RIORITY 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAME1 

An external file name which 
contains invalid characters. 

$ILLEGAL_EXTERNAL_FILE_NAME2 

An external file name which 
is too long. 


2#1.0#E-31 

20 

NO _S UC H _F IXED _U AME 

NO_SUCH_FLOAT_TYPE 

100 _ 000.0 

131_0 7 3.0 

200 

/NON_EXISTENT_DIRECTORYl/FILE1 

/NON EXISTENT_DIRECTORY2/FILE2 






TEST PARAMETERS 


Marne and Meaning 
$INTEGER_FIRST 

A universal integer literal 

whose value is INTEGER'FIRST. 

$INTEGER_LAST 

A universal integer literal 

whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 

A universal integer literal 

whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$LOV_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAX.MANTISSA. 

$HAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.MAX INT+1. 


Value 

-2147433643 

2147483647 

2147483643 

- 100 _ 000.0 

— 131_0 7 3.0 

10 

31 

9 

240 

2147433647 


2147483648 









TEST PARAMETERS 


Name and Meaning Value 

$MAX_LEN_Im_BASED_LITERAL ”2:" & 235 * 'O’ & "11:" 

A universal integer based 
literal whose value is 2 #11# 
with enough leading zeroes in 
the mantissa to be MAX_IN__LEN 
long. 

$MAX_LEN_REAL_8ASED_LITERAL "16:" « 233 * 'O' & "F.E:" 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL "" & 233 * 'A' & 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIM_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

SHAME BYTE_INTEGER 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT_INTEGER, 

LONGBOAT, or LONG_INTEGER. 

$NAME_LIST VAX 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

$NEG_BASED_INT 8#777777777776# 

A based integer literal whose 
highest order nonzero bit 
falls in the sign bit 
position of the representation 
for SYSTEM.MAX INT. 








TEST PARAMETERS 


Marne and Meaning 
$NEV_MEM_SIZE 

An integer literal whose value 
is a permitted argument for 
pragma MEMORY_SIZE, other than 
^DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEV_STOR_UNIT 

An integer literal whose value 
is a permitted argument for 
pragma STORAGEJJNIT, other than 
$DEFAUliT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGEJJNIT. 

$NEV_SYS_NAME 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT' 
parameter. 

STICK 

A real literal whose value is 
SYSTEM.TICK. 


Value 
1 000 000 


8 


VAX 

96 


0.01667 






WITHDRAWN TESTS 


APPENDIX D 
WITHDRAWN TESTS 

Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 44 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 

a. E28005C This test expects that the string "— TCP OF PAGE. 

63" of line 204 will appear at the top of the listing page due 
to a pragma PAGE in line 203; but line 203 contains text that 

follows the pragma, and it is this that must appear at the top 
of the page. 

b. A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30). 

c. B97102E This test contains an unitended illegality: a select 

statement contains a null statement at the place of a selective 
wait alternative (line 31) . 

d. C97116A This test contains race conditions, and it assumes that 
guards are evaluated indivisibly. A conforming implementation 
may use interleaved execution in such a way that the evaluation 
of the guards at lines 50 & 54 and the execution of task CHANGING- 
_OF_THE_GUARD results in a call to REPORT.FAILED at one of 
lines 52 or 56. 

e. BC3009B This test wrongly expects that circular instantiations 
will be detected in several compilation units even though none ot 
the units is illegal with respect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95) . 

f. CD2A62D This test wrongly requires that an array object’s size 
be no greater than 10 although its subtype's size was specified 
to be 40 (line 137) . 

g. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them 
to a derived subprogram (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
’SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 







WITHDRAWN TESTS 


h. CD2A81G, CD2A33G, CD2A34N & M, 5 CD50110 [5 tests] These tests 

assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 
is not the case, and the main program may loop indefinitely 
(lines 74, 85, 36 & 96, 36 & 96, and 58, resp.). 

i. CD2B15C & CD7205C These tests expect that a ’STORAGE_SIZE 
length clause provides precise control over the number of 
designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

j. CD2D11B This test gives a SMALL representation clause for a 

derived fixed-point type (at line 30) that defines a set of 
model numbers that are not necessarily represented in the 
parent type; by Commentary AI-00099, all model numbers of a 
derived fixed-point type must be representable values of the 
parent type. 

k. CD5007B This test wrongly expects an implicitly declared sub¬ 

program to be at the the address that is specified for an un¬ 
related subprogram (line 303! . 

l. ED7004B, ED7005C & D, ED7006C & D [5 tests] These tests check 

various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

m. CD7105A This test requires that successive calls to CALENDAR.- 

CLOCK change by at least SYSTEM.TICK; however, by Commentary 

AI-00201, it is only the expected frequency of change that must 
be at least SYSTEM.TICK—particular instances of change may be 
less (line 29). 

n. CD7203B, & CD7204B These tests use the 'SIZE length clause and 
attribute, whose interpretation is considered problematic by 
the WG9 ARG. 

o. CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task's 

activation as though it were like the specification of storage 
for a collection. 

p. CE2107I This test requires that objects of two similar scalar 
types be distinguished when read from a file—DATA_ERR0R is 
expected to be raised by an attempt to read one object as of 
the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective 
is not considered valid. (line 90) 

q. CE3111C This test requires certain behavior, when two files are 

associated with the same external file, that is not required by 







WITHDRAWN TESTS 


the Ada standard. 

CE330IA This test contains several calls to END_OF_LINE £ 
END_OF_PAGE that have no parameter: these calls were intended 
to specify a file, not to refer to STANDARD_INPUT (lines 103, 
107, 113, 132, & 136). 

CE3411B This test requires that a text file's column number be 
set to COUNT'LAST in order to check that LAYOUT_ERROR is raised 
by a subsequent PUT operation. But the former operation will 
generally raise an exception due to a lack of available disk 
space, and the test would thus encumber validation testing. 








COMPILE? AND LINKS? OPTIONS 


APPENDIX E 

COMPILER AND LINKER OPTIONS 








Chapter 3 

Compiling Ada Programs 


The cada command is used to compile and assemble Ada compiladon units. 


3.1. THE “ ada COMMAND FORMAT 

The cada command has this format: 

aada [option... I file... [option... i 

Arguments that start with a hyphen are interpreted as options: otherwise, they represent filenames. There 
must be at least one filename, but there need not be any opuons. Options and filenames may appear in any order, 
and all options apply to all filenames. For an explanation of the available opuons. see Section 3_2. 

If a source file does not reside in the directory in which the compiiauon takes place, file must include a path 
sufficient to locate the file. It is recommended that only one compiiauon unit be placed in a file. 

Files are processed in the order in which they appear on the command line. The compiler sequentially 
processes all compilation units in each file. Upon successful compilation of a unit: 

• the Ada program library ada. db is updated to reflect the new compilation time and any new dependencies 

• one or more separate compiiauon files and/or object files are generated 

If no errors are detected in a compiiauon unit, cada produces an object module and updates the library. If any 
error is detected, no object code file is produced, a source listing is produced, and no library entry is made for 
that compiiauon unit. If warnings are generated, both an object code tile and a source listing axe produced. For 
further details about the process of updating the library, files generated, replacement of existing files, and 
possible error condiuons. see Sections 3.3 through 3.6. 

The output from cada is a file of type . scoff or . coff, for a specification or a body unit respectively, 
containing object code. Some other files are left in the directory as well. See Section 3.4 for a list of extensions 
of files that may be left in the directory. 

32. OPTIONS 

Command line opuons indicate special acuons to be performed by the compiler or special output file 
properties. 

The following command line options may be used: 

-a Generate an assembly code tile. The assemoly code file nas an extension . s or . ss 

(see Section 3.4). 

-g Output debugging informauon. 

-i Cause compiler to omit data segments with the text of enumeration literals. This text 

is normally produced for exported enumerauon types in order to support the 
' IMAGE attribute. You should use -i only when you can guarantee that no unit 
that will import the enumerauon type will use ' IMAGE. However, if you are 
compiling a unit with an enumerauon type that is not visible to other compilation 
units, this opoon is not needed. The compiler can recognize when ' IMAGE is not 
used and will not generate the supporting strings. 


3-1 




USER MANUAL FOR TARTAN ADA ULTRIX 


'La Generate a listing, even if no errors were found. The default is to generate a listing 

only if an error is found. 

Never generate a listing. The default is to generate a listing only if an error is found. 
Stop compilation after n errors have been detected. 

Control the levei of optimization performed by the compiler, requested by n. The 
optimization levels available are: 

n = 0 Minimum - Performs context determination, constant folding, al¬ 
gebraic manipulation, and short circuit analysis. 

n = 1 Low - Performs levei 0 optimizations plus common subexpression 
eiiminanon and equivalence propagation within basic blocks. It 
also optimizes evaluation order. 

n = 2 Space - This is the default if none is supplied. Performs level 1 
optimizations plus flow analysis which is used for common sub¬ 
expression eiiminanon and equivalence propagadon across basic 
blocks. It also performs invariant expression hoisung, dead code 
eiiminanon. and assignment killing. Level 2 also performs lifedme 
analysis which is used to improve register allocation. It also per¬ 
forms inline expansion of subprogram calls indicated by Pragma 
INLINE which appears in the same compilation unit. 

n = 3 Time - Performs level 2 optimizauons plus inline expansion of 
subprogram calls which the optimizer decides are profitable to ex¬ 
pand (from an execution time perspective). Other optimizations 
which improve execuuon time at a cost to image size are per¬ 
formed only at this level. 

—/ Print out compiler phase names. The compiler prims out a short description of each 

compilation phase in progress. 

-q Do not prim out compiler phase names. 

-w Suppress warning messages. 

-5 [ACDEILORSZ] Suppress the given set of checks: 


A ACCESS CHECK 

C CONSTRAINT CHECK 

0 DISCRIMINANT CHECK 

E ELABORATION CHECK 

I INDEX CHECK" 

L LENGTH CHECK 

0 OVERFLOW CHECK 

A RANGE CHECK 

3 STORAGE CHECK 

Z ■•ZERO"DIVISION CHECK 


The -5 option has the same effect as a global pragma SUPPRESS applied to the 
source file. If the source program aiso contains a pragma SUPPRESS, then a given 
check is suppressed if either the pragma or the switch specifies iu that is. the effect 
of a pragma SUPPRESS cannot be negated with the command line option. See 
LRM 11.7 for further details. Examples are: 

-502 Suppress 0VSRF1CW_CHECK and " 2 ERO"DIVISICNjOHEC!C. 

-S Suppress all checks. 

-SC Suppress CONSTRAINT_ERRCR. equivalent to - SAD I LA. 


-Ln 

-n-n 

-Ope 


3-2 










COMPILING ADA PROGRAMS 


-x Cause the compiler to generate a cross reference file containing entries of the form 

Ada-name m >linkname at line 

This option will allow users to find the linkname generated for „,e given Ada-name, 
and use linkname to set breakpoints in debuggers. Tne tile will have the extension 
. sere (See Section 3.5). 

In addition, the output from the compiler may be redirected using 'he ULTRIX redirection facility including ‘s’ 
for ettderrt for example 

% tada cax_soec.ada >i tax_3pec.cxc 

3 J. WHAT UPDATES ARE MADE TO THE PROGRAM LIBRARY 

Simply stated, upon successful compilation of a unit, 

• the Ada program library ada. db is updated to reflect the new compilation dme and any new dependencies 

• one or more separate compilation files and/or object files are generated. 

However, more complicated situations can anse. The following items list the types of compilauon unit and 
address the range of suuauons that can arise. 

• In ail cases the transitive closure of the dependencies of a compilauon unit in he library must be consis¬ 
tent: that is. the unit must be compiled consistently as defined in section 10.3 of he LRM. A secondary 
unit can have its specification in its context clause, although it is redundant. For a more complete 
discussion of closure, see Section 4.5. 

• A package specification replaces any library unit in he library with he same name, or is simply added if 
no such library unit exists. 

• A package body replaces any existing body of a package specification with the same name. If no such 
specificauon exists, an error message is issued. If such a specificadon exists, but he body does not match 
the speculation in he sense of Section 7.1 of he LRM, error messages are issued. 

• A subprogram specification replaces any library unit in he library --with he same name, or is simply 
added if no such library unit exists. 

• A subprogram body replaces any existing body of a i generic or non-genenc) subprogram specificauon 
with he same name. If no such specificauon exists, an implicit specificauon is denved from he body and 
entered into he library as noted above for subprogram specificauon. If a specificauon exists, but he body 
does not match he specificauon in he sense of Secuon 6.3 of he LRM. error messages are issued. If any 
library unit other than a subprogram specificauon exists with he same name, he new implicit specification 
replaces thac library unit. 

• Generic package specifications and subprogram specifications xt as explicit specifications, i.e.. cor¬ 
responding bodies must match heir specuicauons. If a generic unit is mstanuated. a dependency is created 
on he generic body. 

• Generic instances compiled as library units are treated in he same wav as heir non-generic counterparts. 

• When an instanuation replaces he body of a library unit, ail secondary units of hat library unit are now 
obsolete and are deleted. 

• A subunit with a parent unit containing an appropriate body stub exisung in he library replaces any 
subunit with he same subunit name, comprised of he stub's name and he name of he ancestor unit, or is 
simply added, if no such subunit exists. A unit containing stubs will only be entered into the library if he 
simple names of ail its stubs are unique for ail stubs denved from its common ancestor. .An error message 
is issued if no parent unit exists in he library, he parent unit exists but does not have a releveni stub, or he 
parent unit and body stub exist but he subunit does not match the stub or its specificauon. 


3-3 



USER MANUAL ?0R TARTAN ADA CLTRIX 


• When the parent unit of a subunit is recompiled and the parent no longer contains a stub for the subunit, 
the subunit which is now obsolete, is deleted. 

3.4. FILES PRODUCED OR USED BY THE COMPILATION SYSTEM 

Files 'vith the following extensions are contained in the standard packages directories or can be created by 
compiling or linking an Ada program; the .lie name is the name of a compilation unit, but may be compressed to 
conform to length limitations. 

ARP A file containing information to be used by AdaScope. the Tartan Ada Debugger. 

created when an Ada unit is compiled in a library created for the Tartan Tool Set. 

ood Representation of the body of a generic, and/or the visibility information available to 

any subunits, body-name. Pod is read when compiling a program that instantiates 
body-name , or is a subunit of body-name , or makes a call to a subprogram in body-name 
to which pragma INLINE has been applied. 

da. Representation of a library unit specification, unit-name. da is read during the compila- 

aon of a program that does a "with unit-name". 

-3 c A listing produced by the Ada compiler. 

3 The assembly language file produced by compiling an Ada unit body when the -a 

option is specified. 

33 The assembly language file produced by compiling an Ada unit specification when the 

-a option is specified. 

scoff The object file created by compiling an Ada unit specificauon in a library created for the 

Tartan Tool Set. 

caff The object file created by compiling an Ada unit body in a library created for the Tartan 

Tool Set. 

xrf Cross reference files that relate Ada names with compressed and disambiguated names 

used in the assembly language file. 

The following are the extensions used for files that are created temporarily during the linking process: 

ccl File created by the librarian listing the files that are needed to link the program 

■scoff The object file containing calls for elaboration of the program 

Addiuonaily, temporary files are created during compilation that have the same file extensions listed above, but 
also have a unique 8-digit hexadecimal number concatenated to the extension. .Any of the above files will appear 
in the directory only if a link or compilation is abnormally terminated. These files should then be deleted by the 
user. 

Files having the foilowtng extensions are controlled by the librarian and compiler ±i. red. 3. and ss. The 
user should not use these extensions for any other purpose. The a^ro ieieca command will automatically 
delete these files, when the respective unit is deleted from the library, [f the user deletes these files in any other 
way, subsequent invocations of the compiler or librarian will have unpredictable results, including fatal crashes. 
We therefore advise that the user never delete these files by ITLTRIX commands. 

3-5. THE CROSS REFERENCE MAP OF UNKNAMES 

A cross reference of symbolic names to linknames is generated with the option -x to the cada command. 
The cross-reference file has the extension .xrf; the file name is that of the compiled unit, but possibly 
compressed to match ITLTRIX restrictions, as shown in the example below. 

For longer unit-names, the cross reference file generaied may not have an immediately obvious name, in 
order to find it. it may be necessary to search the current working directory for a recently produced file with 
extenuon xrf. 


3-4 





COMPILING ADA PROGRAMS 


Example: 

File crexample_3pec. ada 

package THIS IS_A LONG ?ACKAGE_NAM£ is 
package ANOTH£R_LONG_PACXAGE NAME is 

procedure LONG_?ROCEDURE NAME_THAT WILL HAVE SHORT LINKNAME; 
end ANOTHER LONG ?ACXAG2_NAME; - - - - 

end THI S_I S_A_LCNG_?ACXAGE_NAME ; 

File crsxample_body. ada 

package body THIS_IS_A_LCNG_?ACXAGE_NAME is 

package body ANOTHER_LGNG_?ACXAGE_NAME is seoaraca; 
end rHI5_*3 - A_LONG_?AC:<AGS_MAM£; 

File crexampie. seo 

separate (THIS 13 A LONG PACKAGE NAME! 
package body ANOTHER_LONG ?AC:<AGE_NAME is 

procedure L0NG_?RCCS3URE_NAME_THAT_WILL_HAVE_SH0RT_LINKNAM£ is 
begin ' 

null; 

end L0NG_?RCC2DUR£_NAMS THAT_WILL HAVE 3HORT_LCNKNAM£; 
end ANOTHER_LONG_?AC:<AGE_NAME; 

The commands: 

cada crexampla_3pec.ada 
"ada crexample__body.ada 
cada -x crexampie.3ep 

produce the file chsalr.gpcjignm.ncdrlngpckgnmeOOl .xrf which appears below: 

- liakname Cross Reference Map zhs3ingpcxgnm.nchrlngpckgnmeOOl - 

chis__is_a__long_package_name»>xxbhs3)cgiun001 at 0 

zr.rs~i3_a~long^oackage_name. chi3_is_a_long_oac!cage_name“>zbi3_r3_a_long 
_?acxage_name. 00 at 1 

t.'iA 3 _r 3 _a_Lang_oackage_name. another_Long__pacicage_nanie. anacher_long_?ackage 
name»>anochar_long_package_name.00 at 2 

7:ii3^i.3_a_Lang^?ackage_name.another_long_package_name.long_procedure_name 
_chat_w7lT_have_3hort — Iinkname*>xxtns3kgnm001. Ingprcdtlr.knm. 30 at 3 

In the above cross reference file: 

• The first line represents the name for the elaboration code for the package 

CHI3_:3_A_LCNG_?AC:<AGE_NAME. The symbols representing the specification and body have 
respectively .OECLARS and . 30DT postpended. 

• The second line is the name of the data segment for the package this_:3_a_lcng_?acxage_name. 

• The third line is the name of the daia segment for the package ANOTHER_LCNG_?ACXAGE_NAME. 

• The name for the lcng_?ROCSOURE_name_THAT_will_have_3HCRt_iinkname procedure is on 
the fourth line. 

• The fifth line is the name for the elaboration variable for the procedure 

LCNG__?RCCECURE_NAME_THAT_wiLL_HAVE_3HCRT__LlNKNAME. Ada rules require that the body 
of a subprogram is already elaborated before it can be called. If it is not already elaborated the exception 
? RCGRAM_ERRCR must be raised. For each subprogram that may require an elaboration check the 
compiler generates a variable that is used to record that the body of the subprogram .has been elaborated. 
The name of the elaboration variable is generated by postpending . GOTO to the name of the subprogram. 
The elaboration variable name is then subject to the same compression algorithms as the rest of the 
symbols in the p ro gra m. 


3-5 




VScR MANX'AL .-OR TARTAN aDa 'JTTRtX 


The ULTRIX command 
Is -Ic *.xrf 

will help you locate the cross reference listing. In order to view the contents of the cross reference file, make 
sure that your terminal is set to wrap around mode. The identifier appearing at the left is the identifier that 
appears in the Ada source code. The name to the right of the '=•>' is the linkname that is supplied for that 
identifier to id. The “at <number>" gives the line number in the source code where the identifier is found. 
A Cross Reference Map can be used to verify that there are no conflicting linknames in a program library that 
uses subprograms written in another language (see Secaon 5.1.2.2 that discusses the pragma FCR£rSN_3CDir). 
It is also useful for assembly-level debugging. 

3.6. COMPILER DIAGNOSTIC MESSAGES 

The compiler and library issue diagnostic messages that appear at your terminal and in the optional compiler¬ 
generated listing. Most messages issued by Tartan Ada ULTRIX contain a reference to the Ada LRM section 
and paragraph relevant to the error. This section explains the kinds of diagnostic messages that are generated, 
how the compiler attempts to deal with problems that caused the messages and how you shouid go about 
correcting a program. 

A comprehensive listing of all the messages the compiler can issue is contained in Appendix Section A.l. A 
similar listing of ail the messages the library can issue is contained in Appendix Secaon A.2. 

3.6.1. Message Severity Levels 

Every message issued by the compiler is assigned a seventy level that indicates how serious the problem is. 
There are four message categories. 

1. A fatal error is serious enough to suspend compilation immediately after the error is discovered. This is 
the only class of error that inhibits further analysis of the source program. An example of a fatal error 
message (in this case from the library) is: 

ratal 5301: < library administration file name> is incompatible 
wish inis version of the Library. 

2. An error is senous enough to prevent the generation of object code, but the compiler attempts to recover 
from the error and continues checking the source for addiuonai errors. An example of an error is: 

Error 2360: Thi3 record field has already been assigned 
in "he aggregace (4.2 (5)) 

3. A Morning does not stop the compiler from generating object code, but may sail be an indication of a 
programming error. When a warning occurs, the code generated may not be what you intended. An 
example of a warning is: 

Warn 4001: Elaboration of this subtype will raise const rai.it_errt r 
at runtime (3.3.2) . 

i. .An informational message provides you with addiuonai mformauon when you use some library com¬ 
mands (see. for example. Secuon a,6), Informauonai messages are issued only by the library, not by the 
compiler. An example of an informauonai message is: 

Info 5011: the files required for linking oy <umtjbnd> 

<'untt_name> are consistent (10.2). 

3.6.2. Message Formats 

The format of messages appearing on the standard error output and in the lisung file is similar. Here is an 
example: 


3-6 









COMPILING AO A PROGRAMS 


SI si : string(1 .. discrim); 

5| 3 2 : stringd .. 2 * discrim) ; 

*** 1 Error 2204: A discriminant may not be used in 

*** expression (3.7.1 (5)) 

7| end record; 


this 


The numbered lines in the example are lines from the source program. The source line in quesdon is followed by 
the messages and pointers to the exact location of the problem. 

On the terminal, horizontal lines are used to separate messages coming from different parts of the source 
program, for example: 


5| si : stringd .. discrin) ; 

61 s2 : stringd . . 2 ' discrin) ; 

* 1 

*” l Error 2204: A discriminant may not be used 
*** in this expression (3.7.1 (6)) 

7| end record; 


141 null; 

151 when numeric_error I constraint_error ■> 

* 1 

*** 1 Error 3112: A given exception nay only appear once 

*’* in a handler (11.2 (5)) 

161 null; 

In a listing file, a message chain accompanies each diagnostic message. The message chain indicates where 
in the program the next and previous messages occur, for example: 


3-7 






'JScR MANUAL FOR. TARTAN aQa L'LTRJX 


Ada tTLTRIX INT-3 Copyright: 198 9, Taman Laboratories Incorporated 
"* n First diagnostic is on line 5 

II procedure sample_program is 

21 3ubtype smaii_t.nt is integer range 1 .. 10; 

31 

41 type rec(discrim : small_int) is record 

31 si : strmgd .. dis’cnm) ; 

Si s2 : 3tring(l .. 2 * discrim); 

* 1 

*** 1 Srror 2204: A discriminant may not be used m this 

*** expression (3.7.1 (S)) 

*** Next diagnostic is on line 15 

7| end record; 

8 I 

9 I x : rec (5) ; 

10|begin 

111 x :- (S, "12345", "abode"); 

12!exception 

13 l wnen constramt_error «> 

141 null; 

151 when numenc_error f constraint_error *> 

*** Previous diagnostic was on line S 

*** 1 error 3112: A given exception may only appear once 

m a handler (11.2 (5)) 

161 null; 

17iend samole_program; 

13! 

La3t diagnostic was on line 15 

*** errors: 2, Warnings: 0 
The message chain is especially helpful when working with large listings. 

Whether on the standard error output or in a listing file, the list of messages is followed by a summary line 
containing a count of the number of errors in each seventy class, for example: 

? errors: 2, warnings: 1 

3.6.3. Message Generation 

Tartan Ada ULTRDC has many internal phases, any one of which can issue diagnostic messages. Messages 
are collected in memory until the time comes to generate the message listing. At that time, all the messages are 
sorted by their position in the source program and are pnnted. 

When you examine a program listing containing many messages, remember that the order in which the 
messages appear in the listing ts not necessarily the order in which the messages were generated. This fact may 
be important when one error causes another. It is advisable to start correcting your program according to the 
messages having the lowest numbers and work towards the higher numbers, making an intermediate compilation 
if necessary. 

3.6.4. About Syntax Errors and Recovery 

Tartan Ada ULTRIX incorporates a parser which is capable of analyzing and correcting all syntactic errors in 
the source program. This section describes the various error messages that may be issued by the parser. When a 
syntax error is detected, no object code is generated. 

The parser divides the source program text into lexical elements, or tokens, such as identifiers, reserved 
words, constants, etc. When the parser encounters a token that it does not expect, it issues an error message that 


3-a 






COMPtUN'G ADA PROGRAMS 


indicates the position at which the error was detected and the action that was taken to correct the error. Here are 
some examples of the recovery actions: 

In the example below, the trailing “3” does not match any of the valid tokens of Ada and so the parser 
deletes it. 

II procedure bad_3yncax is 

21 subcype byte is integer range 0 .. 255; 3 

a n 

*** 1 Error 104: Ill-formed token deleted. 

31 x : integer; 

The compiler also deletes a token occupying an inappropriate place. In the following example, it deletes the 
superfluous token “while”. 

5 1 begin 

51 for while i in 1 .. 10 loop 
"1 

*** 1 Error 121: Parse error; token deleted. 

7| x :- x + 1; 

In the following example, the missing symbol is inserted, and parsing continues undisturbed. 

41 i : integer 

51 b : boolean; 

A * 

**■* i Error 120: Parse error; token inserted. 

6 1 begin 

In the following example, the syntactically incorrect symbol is replaced by the proper symbol 

17 | end loop; 

131 x :- 15*: 

- 1 

»»> 1 Error 122: Parse error; this token deleted. inserted. 

19! 

J. 6.4.1. Multi-Token Insertion 

The parser may also insert several tokens in an attempt to repair the constructs whose closing tokens (e.g., 
“end if ;") are missing. An example of this recovery is: 

10 I end if; 

III end looo; 

*1,2,3 

»»* 1 Error 120: Parse error: token "if" inserted. 

**» 2 Error 120: Parse error; token ";" inserted. 

*** 3 Error 120: Parse error; toiten "end” inserted. 

12 1 end bad_proc; 

In this example an additional “end if;” was missing. Note, however, that the maximum number of 
tokens that can be inserted m succession is limited. 

3.6.42. Complex Recovery Strategy 

If all the simple fix-up and multi-token insertion techniques above are unsuccessful, the parser attempts a 
more massive correcaon by deleting many successive or preceding phrases of the program. Foe example. 

5 i •/ : - 5; case oad_case is 

r>* „ where :t«y »> x :» 3; 

-A * 

»»* 1 Error 123: Parse error; ill-formed "<3caeament>". 

7* wnen 2 :* :c * 3; 

The caret ( A > locates the place where the parser detects an error. The compiler indicares the elided portion of 
the source program by underlining with asterisks. In the first (and possibly the last line), only the tokens deleted 


3-9 









•JSER MANUAL FOR TARTAN aDA ULTRK 


are underlined. The lines following die first line are not underlined, but when the entire line is deleted the 
symbol after the line number (e.g., lines 6 and 7) changes from a vertical bar (I) to an asterisk. (The above case 
statement contained three errors. The closing “end case; ” was also deleted.) 

In cases like the above example, when the parser has deleted more than one token, the error message is 
Error 123: Parse error; ill-formed "<name>". 

The name contained within the angle bracket pair is that of the grammatical element that the parser expected to 
find in this position. Occasionally, the deletion of tokens starts at a point cexmaily preceding the reported error 
because no legal interpretation of an enclosing construct can be found due to the error within the construct. 

Under rare circumstances, you may see an error message 
Error 127: Parse error; unexpecoad end-of-frle. 
pointing to a token within the program, with the rest of the program marked as deleted. This message points to 
the position in the program where the parser detected a syntax error. It indicates that, despite all anempts, the 
error recovery was unsucessfiil undl the end-of-file was reached. In this case, correct ail the errors reported and 
examine the program for missing keywords that end complicated syntactic constructs: also, especially examine 
the few lines that precede and follow this message for syntacac errors. 


3-10 








LSER MANUAL FOR TARTAN ADA L'LTRIX 


4.8. THE L ink SUBCOMMAND 

The link command checks that the unit within the library specified by the user has the legal form for a main 
unit, checks that ail its dependencies are consistent, finds ail required object files, and links the main program 
with its full closure (See Section 4.5) producing an executable image. The format of the link command is 

alib link [option...] Ada-name [option...] 

where the Ada-name specifies the unit in the library to be made the main program. 

The following options may be used; 

-a Provide a trace of the load command indicanng what files are being loaded 

-K Create a shell script file that may be redirected to sh to cause the Ada program to be linked. The 

user assumes full responsibility for the consistency of the program when this scnpt is run instead 
of using the alib link command. 

-M Provide a load map 

-o filename 

Name the final output file from the loader filename 


4-10 







