AD-A 216 482 





_ UNCLASSIFIED V ^ rmr niF m* /- 

SCCURT* CLASSIFICATION QF THIS PAGE _I Qf 

REPORT DOCUMENTATION P*GE 

X. RE PORI NUMBER | 2 . SOVT ACCESSION NO. 3 . RECIPIENTS CATALOG NUMfc 

«. TITLE iindiubMit) S. ▼TPE Of REPORT & PERIOD COVERED 

Ada Compiler Validation Summary Report: Aisvs, 19 Jan 89 - l Dec 90 

AlsyCOMP_ 019 , Version 4 . 1 , Zenith Z -248 Model 50 (host) to 7 ”" 7 erFor 5 in&T)r& report number 
I ntel isBC 286/12 single boaru computer (tar^^^^j^^. ±0032 

7 . AUTHORu; 8 . contract op brant number^; 

AFNOR, Paris, France. 


«. PERFORMING ORGANIZATION AND ADDRESS 

AFNOR, Paris, France. 


10 . PROGRAM ELEMENT. PROJECT. TASR 
AREA t MORA UNIT NUMBERS 


11 . CONTROLLING OFFICE NAME AND ADDRESS 

Ada Joint Program Office 

United States Department of Defense 

Washington, DC 2u301-3081 


14 . MONITORING AGENCY NAME l ADDRESSED differ* nr from Controlling Other) 

AFNOR, Paris, France. 


12. REPORT DATE 


is. security class (of thu rtponj 
UNCLASSIFIED 


IS. g[^AS^F, C AT10N/00-NGRADING 

J N/A 


IE. DISTRIBUTION STATEMENT (of thu Report' 

Approved for public release; distribution unlimited. 


17. DISTRIBUTION STATEMENT (of the .Pjt/.ct tmtr rtj in Block 2 0 tf chtirrrni froa? Htpon) 

UNCLASSIFIED DTIC 

^ ^CTE 


18 . SUPPLEMENTARY NOTES 


V 

!% 


D* 



1473 EDITION OF 1 NOV es IS obsolete 

m s/n oioZ'LF * 014*6601 _ UN CLASSIFIED _ 

V SECURPY CLASSIFICATION Of THIS PAGE <**Ne"D«t« Enter**) 






















Zenith 


&VT Control Number: 


AVY-VSR-AFNOR-88-20 


Ada COMPILED 
VM-IBWIOH 

Certificate Number: 89011 

ilS, e°in«risW r w”l2’ lsiMle ‘■card center 
Model 50 and Intel isb 



-f nn-Site Testing. 
Completion oi On sire 

19 January I 983 


prepared By: 

AFNOR 

Tour Europe 
Cedex 7 

p-92080 Paris la Defense 


prepared For: 

Ada Joint Program Office 
a states Department of De 
DC 20301-3081 


Accesion For 

- 1 - 1 

NTIS 

CRAAI 


DTIC 

T M-i 

• , 


L i 

JfiStltl 

u 


By 



Dint' ibutlOi : 1 

Availjljtiiiy Codes 

Disl 

Avdii unci / or 

Special 

Ia-i 





Ada Compiler Validation Summary Report: 


Compiler Name: AlsyC0MP_019, Version 4.1 
Certificate Number: 890119A1.10032 

Host: Zenith Z-248 Model 50 under MS/DOS, Version 3.2 

Target: Intel isBC 286/12 single board computer 

Testing Completed 19 January 1989 Using ACVC 1.10 

This report has been reviewed and is approved. 


AFNOR 

Fabrice Gamier de Labareyre 
Tour Europe 
Cedex 7 

F-92080 Paris la Defense 



Ada Validation Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 
Alexandria VA 22311 




Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 


2 


ABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT.5 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.5 

1.3 REFERENCES.6 

1.4 DEFINITION OF TERMS.6 

1.5 ACVC TEST CLASSES.7 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED.10 

2.2 IMPLEMENTATION CHARACTERISTICS. 11 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.16 

3.2 SUMMARY OF TEST RESULTS BY CLASS.16 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.17 

3.4 WITHDRAWN TESTS.17 

3.5 INAPPLICABLE TESTS.17 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS.19 

3.7 ADDITIONAL'TESTING INFORMATION.20 

3.7.1 Prevalidation.20 

3.7.2 Test Method. 21 

3.7.3 Test Site.22 


APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B TEST PARAMETERS 

APPENDIX C WITHDRAWN TESTS 


APPENDIX D APPENDIX F OF THE Ada STANDARD 

























INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


, /' 

This -Validation /Summary Report (VSR)' v describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL- 
STD-1815A. This report explains all technical terms used within it 
and thoroughly reports the results of testing this compiler using the 
Ada Compiler Validation Capability (ACVC). An Ada compiler must be 
implemented according to the Ada Standard, and any implementation- 
dependent features must conform to the requirements of the Ada 
Standard. The Ada Standard must be implemented in its entirety, and 
nothing can be implemented that is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, 
it must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies—for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results 
produced during validation testing. The validation process includes 
submitting a suite of standardized tests, the ACVC, as inputs to an 
Ada compiler and evaluating the results. The purpose of validating is 
to ensure conformity of the compiler to the Ada Standard by testing 
that the compiler properly implements legal language constructs and 
that it identifies and rejects illegal language constructs. The 
testing also identifies behavior that is implementation-dependent but 
permitted by the Ada Standard. Six classes of tests are used. These 
tests are designed to perform checks at compile time, at link time, 
and during execution. 


4 









INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR documents the results of the validation testing performed on 
an Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by 
the compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported 
by the compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is 
allowed by the Ada Standard 

Testing of this compiler was conducted by under the direction of the 
AVF according to procedures established by the Ada Joint Program 
Office and administered by the Ada Validation Organization (AVO). 
On-site testing was completed 19 January 1989 at Alsys inc. in 
Waltham, USA 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national- laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the 
United States, this is provided in accordance with the "Freedom of 
Information Act"(5 U.S.C.#552). The results of this validation apply 
only to the computers, operating systems, and compiler versions 
identified in this report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. 
Copies of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rra 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


AFNOR 

Tour Europe 
cedex 7 

F-92080 Paris la Defense 


5 







INTRODUCTION 


Questions regarding this report or the validation test results should 
be directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 

ANSI/MIL- 

STD-1815A, February 1983. and ISO 8652-1987. 


2. Ada Compiler Validation Procedures and Guidelines, 

Ada Joint 

Program Office, 1 January 1987. 


3. Ada Compiler Validation Capability Implementers 

' Guide, 

SofTech, Inc., December 1986. 


1.4 DEFINITION OF TERMS 

ACVC The Ada Compiler Validation Capability. The set of 

Ada programs that tests the conformity of an Ada 
compiler to the Ada programming language. 

Ada Commentary An Ada Commentary contains all information relevant 
to the point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

The agency requesting validation. 

The Ada Validation Facility. The AVF is responsible 
for conducting compiler validations according to 
procedures contained in the Ada Compiler Validation 
Procedures and Guidelines. 

The Ada Validation Organization. The AVO has 
oversight authority over all AVF practices for the 
purpose of maintaining . a uniform process for 
validation of Ada compilers. The AVO provides 
administrative and technical support for Ada 
validations to ensure consistent practices. 

A processor for the Ada language. In the context of 
this report, a compiler is any language processor, 


Ada Standard 

Applicant 

AVF 

AVO 


Compiler 


6 










INTRODUCTION 


including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a 

result that demonstrates nonconformity to the Ada 

Standard. 

Host The computer on which the compiler resides. 

Inapplicable test An ACVC test that uses features of the language 
that a compiler is not required to support or may 
legitimately support in a way other than the one 
expected by the test. 

Passed test An ACVC test for which a compiler generates the 

expected result. 

Target The computer for which a compiler generates code. 

Test A program that checks a compiler's conformity 

regarding a particular feature or a combination of 
features to the Ada Standard. In the context of this 
report, the term is used to designate a single test, 
which may comprise one or more files. 

Withdrawn test An ACVC test found to be incorrect and not used to 
check conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal 
or erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce compilation 
or link errors. 

Class A tests check that legal Ada programs can be successfully 
compiled and executed. There are no explicit program components in a 
Class A test to check semantics. For example, a Class A test checks 
that reserved words of another language (other than those already 
reserved in the Ada language) are not treated as reserved words by an 
Ada compiler. A Class A test is passed if no errors are detected at 
compile time and the program executes to produce a PASSED message. 


7 












INTRODUCTION 


\ 




Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that 
every syntax or semantic error in the test is detected. A Class B 
test is passed if every illegal construct that it contains is 
detected by the compiler. 

Class C tests check that legal Ada programs can be correctly compiled 
and executed. Each Class C test is self-checking and produces a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when 
it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a 
compiler by the Ada Standard for some parameters—for example, the 
number of identifiers permitted in a compilation or the number of 
units in a library—a compiler may refuse to compile a Class D test 
and still be a conforming compiler. Therefore, if a Class D test 
fails to compile because the capacity of the compiler is exceeded, 
the test is classified as inapplicable. If a Class D test compiles 
successfully, it is self-checking and produces a PASSED or FAILED 
message during execution. 

Each Class E test is self-checking and produces a NOT APPLICABLE, 
PASSED, or FAILED message when it is compiled and executed. However, 
the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during 
compilation. Therefore, a Class E test is passed by a compiler if it 
is compiled successfully and executes to produce a PASSED message, or 
if it is rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time—that 
is, an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The 
package REPORT provides the mechanism by which executable tests 
report PASSED, FAILED, or NOT APPLICABLE results. It also provides a 
set of identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The procedure CHECK_FILE is used to check the contents of text files 
written by some of the Class C tests for chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set 
of executable tests. These tests produce messages that are examined 


8 










INTRODUCTION 


to verify that the units are operating correctly. If these units are 
not operating correctly, then the validation is not attempted. 

The text of the tests in the ACVC follow conventions that are 
intended to ensure that the tests are reasonably portable without 
modification. For example, the tests make use of only the basic set 
of 55 characters, contain lines with a maximum length of 72 
characters, use small numeric values, and place features that may not 
be supported by all implementations in separate tests. However, some 
tests contain values that require the test to be customized according 
to implementation-specific values—for example, an illegal file name. 
A list of the values used for this validation is provided in Appendix 
C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is 
inapplicable to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is 
validated. A test that is inapplicable for one validation is not 
necessarily inapplicable for a subsequent validation. Any test that 
was determined to contain an illegal language construct or an 
erroneous language construct is withdrawn from the ACVC and, 
therefore, is not used in testing a compiler. The tests withdrawn at 
the time of this validation are given in Appendix D. 


* 


9 









CONFIGURATION INFORMATION 


CHAPTER 2 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 

Compiler: AlsyCOMP_019, Version 4.1 

ACVC Version: 1.10 

Certificate Number: 890119A1.10032 

Host Computer: 

Machine: Zenith Z-248 Model 50 

Operating System: MS/DOS 

Version 3.2 

Memory Size: 640 K of main memory 

plus 5 Mb of extend memory 

Configuration information: 

80287 floating point co-processor 

40 Mb of hard disk 

EGA color display and adapter 

Target Computer: 

Machine: Intel isBC 286/12 single board 

computer 

Memory Size: 1 Mb 

Communications Network: Serial Port, V24 


10 








CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the 
behavior of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 

Capacities. 

The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

The compiler correctly processe a test containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests) .) 

The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


Predefined types. 

This implementation supports the additional predefined 
types SHORT_INTEGER, LONG_INTEGER, LONG_FLOAT in the 
package STANDARD. (See tests B86001T..Z (7 tests).) 


Based literals. 

An implementation is allowed raise NUMERIC_ERROR or 
CONSTRAINT_ERROR when a value exceeds SYSTEM.MAX.INT . This 
implementation raises CONSTRAINT_ERROR during execution. 
(See test E24201A.) 


Expression evaluation. 

Apparently no default initialization expressions for record 
components are evaluated before any value is checked to 
belong to a component's subtype. (See test C32117A.) 

Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 


11 









CONFIGURATION INFORMATION 


This implementation uses no extra bits for extra precision. 
This implementation uses all extra bits for extra range. 
(See test C35903A.) 

Apparently NUMERIC_ERROR is raised when an integer literal 
operand in a comparison or membership test is outside the 
range of the base type. (See test C45232A.) 

Apparently NUMERIC_ERROR is raised when a literal operand 
in a fixed-point comparison or membership test is outside 
the range of the base type. (See test C45252A.) 

Apparently underflow is gradual. (See tests C45524A..Z.) 


Rounding. 

The method used for rounding to integer is apparently round 
to even. (See tests C46012A..Z.) 

The method used for rounding to longest integer is 
apparently round to even. (See tests C46012A..Z.) 

The method used for rounding to integer in static universal 
real expressions is apparently round to even. (See test 
C4A014A.) 


Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For this 
implementation: 

Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises NUMERIC_ERROR 
sometimes, CONSTRAINT_ERROR sometimes. (See test C36003A.) 

CONSTRAINT_£RROR is raised when 'LENGTH is applied to an 
array type with INTEGER'LAST + 2 components. (See test 
C36202A.) 

CONSTRAINT_ERROR is raised when an array type with 
SYSTEM.MAX INT + 2 components is declared. (See test 
C36202B.) 

A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises no exception. (See test C52103X.) 


12 










CONFIGURATION INFORMATION 


A packed two-dimensional BOOLEAN array with more than 
INTEGER'LAST components raises CONSTRAINT_ERROR when the 
length of a dimension is calculated and exceeds 
INTEGER’LAST, array objects are sliced. (See test C52104Y.) 

A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, lengths 
must match in array slice assignments. This implementation 
raises no exception. (See test E52103Y.) 

In assigning one-dimensional array types, the expression 
appears to be evaluated in its entirety before 
CONSTRAINT_ERROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 

In assigning two-dimensional array types, the expression 
does not appear to be evaluated in its entirety before 
CONSTRAINT_ERROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 


Discriminated types. 

In assigning record types with discriminants, the 
expression appears to be evaluated in its entirety before 
CONS TRAINTJER ROR is raised when checking whether the 
expression's subtype is compatible with the target’s 
subtype. (See test C52013A.) 


Aggregates. 

In the evaluation of a multi-dimensional aggregate, all 
choices appear to be evaluated before checking against the 
index type. (See tests C43207A and C43207B.) 

In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

All choices are evaluated before CONSTRAINT_ERROR is raised 
if a bound in a non-null range of a non-null aggregate does 
not belong to an index subtype. (See test E43211B.) 


13 












CONFIGURATION INFORMATION 


Pragmas. 

The pragma INLINE is supported for functions or procedures, 
but not functions called inside a package specification. 
(See tests LA3004A..B, EA3004C..D, and CA3004E..F.) 


Generics. 

Generic specifications and bodies can be compiled in 
separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 

Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

Generic non-library subprogram bodies can be compiled in 
separate compilations from their stubs. (See test CA2009F.) 

Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, BC3204C, and 

BC3205D.) 

Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

Generic non-library package bodies as subunits can be 
compiled in separate compilations. (See test CA2009C.) 

Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


Input and output. 

The package SEQUENTIAL_IO can be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.} 







CONFIGURATION INFORMATION 


Pragmas. 

The pragma INLINE is supported for functions or procedures, but not 
functions called inside a package specification.(See tests LA3004A..B, 
EA3004C..D, and CA3004E..F.) 


Generics. 

Generic specifications and bodies can be compiled in separate compilations. 
(See tests CA1012A, CA2009C,CA2009F, BC3204C, and BC3205D.) 

Generic unit bodies and their subunits can be compiled in separate 
compilations. (See test CA3011A.) 

Generic subprogram declarations and bodies can be compiled in separate 
compilations. (See tests CA1012A and CA2009F.) 

Generic library subprogram specifications and bodies can be compiled in 
separate compilations. (See test CA1012A.) 

Generic non-library subprogram bodies can be compiled in separate 
compilations from their stubs. (See test CA2009F.) 

Generic package declarations and bodies can be compiled in separate 
compilations. (See tests CA2009C, BC3204C, andBC3205D.) 

Generic library package specifications and bodies can be compiled in 
separate compilations. (See tests BC3204C andBC3205D.) 

Generic non-library package bodies as subunits can be compiled in separate 
compilations. (See test CA2009C.) 

Generic unit bodies and their subunits can be compiled in separate 
compilations. (See test CA3011A.) 


Input and output. 

The director, AJPO, has determined (AI-00332) that every call to OPEN and 
CREATE must raise USE_ERROR or NANE_ERROR if file input/output is not 
supported. This implementation exhibits this behavior for SEQUENTIAL_IO, 
DIRECT_IO, and TEXT.IO. 








CONFIGURATION INFORMATION 


This page is blank 


15 








TEST INFORMATION 


CHAPTER 3 

TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was tested, 

36 tests had been withdrawn because of test errors. The AVF determined that 577 
tests were inapplicable to this implementation. All irapplicable tests were 
processed during validation testing except for 201 executable tests tnat use 
floating-point precision exceeding that supported by the implementation and 242 
executable tests that use file operations not supported by this implementation. 
Modifications to the code, processing, or grading for 52 tests were required . 
(See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable conformity to 
the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT TEST CLASS TOTAL 



A 

B 

C 

D 

E 

L 


Passed 

129 

1132 

1758 

17 

22 

46 

3104 

Inapplicable 

0 

6 

559 

0 

12 

0 

577 

Withdrawn 

1 

2 

33 

0 

0 

0 

36 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


16 







\ 


TEST INFORMATION 


3.3 


SUMMARY OF 


• 2*0 * 


RESULTS BY CHAPTER 


RESULT CHAPTER TOTAL 



0 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 


Passed 

199 

577 

555 

248 

172 

99 

161 

332 

137 

36 

252 

257 

79 

3104 

Inappl 

14 

72 

125 

0 

0 

0 

5 

X 

0 

0 

0 

118 

242 

577 

Wdrn 

0 

X 

0 

0 

0 

0 

0 

1 

0 

0 

1 

29 

4 

36 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 


The following 36 tests were withdrawn from ACVC Version 1.10 at thetime of this 
validation: 


A39005G 

B97102E 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84N 

CD2A84K 

CD50110 

CD2B15C 

CD7205C 

CD5007B 

CD7105A 

CD7203B 

CD7204B 

CD7205D 

CE2107I 

CE3111C 

CE3301A 


CE3411B 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features that 
a compiler is not required by the Ada Standard to support. Others may depend on 
the result of another test that is either inapplicable or withdrawn. The 
applicability of a test to an implementation is considered each time a 
validation is attempted. A test that is inapplicable for one validation attempt 
is not necessarily inapplicable for a subsequent attempt. For this validation 
attempt, 577 tests were inapplicable for the reasons indicated: 

The following 201 tests are not applicable because they have floating-point 

type declarations requiring more digits than System.Max_Digits: 


C24113L..Y 

C35705L..Y 

C35706L.. Y 

C35707L..Y 

C35708L..Y 

C35802L..Z 

C45241L..Y 

C45321L..Y 

C45421L..Y 

C45521L..Z 

C45524L..Z 

C45621L..Z 

C45641L..Y 

C46012L..Z 



17 









TEST INFORMATION 


C35702A and B86001T are not applicable because this 
implementation supports no predefined type Short_Float. 

C45531M..P (4 tests) and C45532M..P (4 tests) are not applicable 
because the value of System.Max_Mantissa is less than 32. 

C86001F, is not applicable because recompilation of Package 
SYSTEM is not allowed. 

B86001X, C45231D, and CD7101G are not applicable because this 
implementation does not support any predefined integer type with 
a name other than Integer, Long_Integer, or Short_Integer. 

B86001Y is not applicable because this implementation supports 
no predefined fixed-point type other than Duration. 

B86001Z is not applicable because this implementation supports 
no predefined floating-point type with a name other than Float, 
Long_Float, or Short_Float. 

B91001H is not applicable because address clause for entries is 
not supported by this implementation. 

CD1009C, CD2A41A..B, CD2A41E, CD2A42A..B, CD2A42E..F, CD2A42I..J 
are not applicable because size clause on float is not supported 
by this implementation. 

CD1C04B, CD1C04E, CD4051A..D are not applicable because 
representation clause on derived records or derived tasks is not 
supported by this implementation. 

CD1C03C, CD2A83A..C, CD2A83E, CD2A84B..I, CD2A84K..L, CD2B11B 
are not applicable because storage size clause on collection of 
unconstrained object is not supported. 

CD1C04A, CD2A21C..D, CD2A22C..D, CD2A22G..H, CD2A31C..D, 
CD2A32C..D, CD2A32G..H, CD2A41C..D, CD2A42C..D, CD2A42G..H, 
CD2A51C..D, CD2A52C..D, CD2A52G..H, CD2A53D, CD2A54D, 

CD2A54H are not applicable because size clause for derived 
private type is not supported by this implementation. 

CD2A61A..D,F,H,I,J,K,L, CD2A62A..C, CD2A71A..D, CD2A72A..D, 
CS2A74A..D, CD2A75A..D are not applicable because of the way 
this implementation allocates storage space for one component, 
size specification clause for an array type or for a record type 
requires compression of the storage space needed for all the 
components (without gaps). 

CD4041A is not applicable because alignment "at mod 8” is not 
supported by this implementation. 


18 









TEST INFORMATION 


CD5003E is not applicable because address clause for integer variable 
is not supported by this implementation. 

BD5006D is not applicable because address c.aust for packages is not 
supported by this implementation. 


CD5011B.D.F,H,L,N,R, CD50I2C,D,G,H,L, CD5013B,D,F,H,L,N,R, CD5014U,V 


are nor app 

licabie because address clause 

for a constant 

is not supported 

by this imp 

iementation. 




CD5013K is 

not applicable 

because address 

clause for van 

ables of a record 

type is not 

supported by 

this implementation. 


CD5012J, CD5013S, CD5014S 

are not applicable because addr 

ess clause for a 

task is not 

supported by 

this impiementati 

.on. 


The following 242 tests 

are inapplicable 

because sequential, text, and 

direct access files are 

not supported: 



CE2102A..C 

CE2102G..H 

CE2102K 

CE2102N..Y 

CE2103C..D 

CE2104A..D 

CE2105A.-B 

CE2106A..B 

CE2107A..H 

CE2107L 

CE2108A..B 

CE2108C..H 

CE2109A..C 

CE2110A..D 

CE2111A..1 

CE2115A..B 

CE2201A..C 

CE2201F..N 

CE2204A..D 

CE2205A 

CE2208B 

CE2401A..C 

CE2401E..F 

CE2401H..L 

CE2404A..B 

CE2405B 

CE2406A 

CE2407A..B 

CE2408A..B 

CE2409A..B 

CE2410A..B 

CE2411A 

CE3102A..B 

EE3102C 

CE3102F..H 

CE3102J..K 

CE3103A 

CE3104A..C 

CE3107B 

CE3108A..B 

CE3109A 

CE3110A 

CE3111A..B 

CE3111D..E 


CE3112A..D 

CE31I4A..B 




CE3115A 

EE3203A 

CE3208A 

EE3301B 


CE3302A 

CE3305A 

CE3402A 

EE3402B 

CE3402C. .D 

CE3403A..C 

CE3403E..F 

CE3404B..D 

CE3405A 

EE3405B 

CE3405C..D 

CE3406A..D 

CE3407A..C 

CE3408A..C 

CE3409A 

CE3409C..E 

EE3409F 

CE3410A 

CE3410C..E 

EE3410F 

CE3411A 

CE3411C 




CE3412A 

EE3412C 

CE3413A 

CE3413C 


CE3602A..D 

CE3603A 

CE3604A..B 

CE3605A..£ 

CE3606A. .B 

CE3704A..F 

CE3704K..0 

CE3706D 

CE3706F..G 

CE3804A..P 

CE3805A..B 

CE3806A..B 

CE3806D..E 

CE3806G..H 

CE3905A..C 

CE3905L 

CE3906A..C 

CE3906E..F 

EE2201D..E 

EE2401D 


EE2401G 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, processing, or 
evaluation in order to compensate for legitimate implementation behavior. 
Modifications are made by the AVF in cases where legitimate implementation 
behavior prevents the successful completion of an (otherwise) applicable test. 
Examples of such modifications include: adding a length clause to alter the 
default size of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 


19 



TEST INFORMATION 


executable test demonstrate conforming behavior that wasn't 
anticipated by the test {such as raising one exception instead of 
another). 


Modifications were required for 52 tests. 

The test EA3004D when run as it is, the implementation fails to 
detect an error on line 27 of test file EA3004D6M (line 115 of "cat 
-n ea3004d*"). This is because the pragma INLINE has no effect when 
its object is within a package specification. However, the results of 
running the test as it is does not confirm that the pragma had no 
effect, only that the package was not made obsolete. By re jrdering 
the compilations so that the two subprograms are compiled after file 
D5 (the re-compilation of the "with"ed package that makes the various 
earlier units obsolete), we create a test that shows that indeed 
pragma INLINE has no effect when applied to a subprogram that is 
called within a package specification: the test then executes and 
produces the expected NOT_APPLICABLE result (as though INLINE were 
not supported at all). The re-ordering of EA3004D test files is 
0-1-4-5-2-3-6. 


The following 30 tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B23004A 

B32202A 

B49005A 

B91004A 

BC3009A 


B24007A 

B32202B 

B61012A 

B95032A 

BC3009C 


B24009A 

B32202C 

B62001B 

B95069A 

BD5005B 


B25002A 

B33001A 

B74304B 

B95069B 


B26005A 

B36307A 

B74304C 

BA1101B2 


B27005A 

B37004A 

B74401F 

BA1101B4 


B28003A 

B49003A 

B74401R 

BC2001D 


The following 21 tests were split in order to show that the compiler 
was able to find the representation clause indicated by the comment 
—N/A =>ERROR : 


CD2A61A 

CD2A71A 

CD2A84C 


CD2A61B 

CD2A71B 

CD2A84D 


CD2A61F 

CD2A72A 

CD2A84E 


CD2A61I 

CD2A72B 

CD2A84F 


CD2A61J 

CD2A75A 

CD2A84G 


CD2A62A 

CD2A75B 

CD2A84H 


CD2A62B 

CD2A84B 

CD2A84I 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the AlsyCOMP_019 was submitted to the AVF by the 
applicant for review. Analysis of these results demonstrated that the 
compiler successfully passed all applicable tests, and the compiler 
exhibited the expected behavior on all inapplicable tests. 


20 









TEST INFORMATION 


3.7.2 Test Method 

Testing of the AlsyCOMP_019 using ACVC Version 1.10 was conducted 
on-site by a validation team from the AVF. The configuration 
consisted of a Zenith Z-248 Model 50 host operating under MS/DOS, 
Version 3.2 and a Intel isBC 286/12 single board computer target. The 
host and target computers were linked via Serial Port, V24. 

A tape containing all tests was taken on-site by the validation team 
for processing. Tests that make use of implementation-specific values 
were customized by Alsys after loading of the tape. 

The contents of the tape were not loaded directly onto the host 
computer. They were loaded on a VAX/VMS machine and transferred via a 
network to the Zenith Z-248 Model 50. This is the reason why 
prevalidation tests were used for the the validation. Those tests 
were loaded by Alsys from a magnetic tape containing all tests . 
provided by the AVF. Customization was done by Alsys. All the tests 
were checked at prevalidation time. 

Integrity of the validation tests was made by checking that no 
modification of the test occured after the time the prevalidation 
results were transferred on disquettes for submission to the AVF. 
This check was performed by verifying that the date of creation (or 
last modification) of the test files was earlier than the 
prevalidation date. After validation was performed, 80 source tests 
were selected by the AVF and checked for integrity. 

The full set of tests was compiled and linked on the Zenith Z-248 
Model 50, then all executable images were transferred to the Intel 
isBC 286/12 single board computer via Serial Port, V24 and run. 
Results were printed from the host computer. 

The compiler was tested using command scripts provided by Alsys and 
reviewed by the validation team. The compiler was tested using all 
default option settings except for the following: 

OPTION / SWITCH EFFECT 

GENERIC=STUBS Code of generic instantiation is placed in separate 
units 

CALLS=INLINE The pragma INLINE are taken into account 

Tests were compiled, linked, and executed (as appropriate) using 2 
computers and a single target computer. Test output, compilation 
listings, and job logs were captured on floppy disk and archived at 
the AVF. The listings examined on-site by the validation team were 
also archived. 


21 








TEST INFORMATION 


3.7.3 Test Site 

Testing was conducted at Alsys, Inc. in Waltham, USA and was completed 
on 19 January 1989. 


P 


22 


DECLARATION OF CONFORMANCE 


APPENDIX A 

DECLARATION OF CONFORMANCE 

Alsys has submitted the following Declaration of 
Conformance concerning the AlsyCOMP_019. 


23 



DECLARATION OF CONFORMANCE 


DECLARATION OF CONFORMANCE 
Compiler Implementor: Alsys 

Ada Validation Facility: AFNOR, Tour Europe Cedex 7, 

F-92080 Paris la Defense 

Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Compiler Name: 

Host Architecture ISA: 
OS&VER #: 

Target Architecture ISA: 


Base Configuration 


AlsyCOMP_019 Version 4.1 

Zenith Z-248 Model 50 
MS/DOS, Version 3.2 

Intel isBC 286/12 single board computer 


Implementor's Declaration 

I, the undersigned, representing Alsys, have implemented no deliberate 
extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the 
compiler(s) listed in this declaration. I declare that Alsys is the 
owner of record of the Ada language compiler(s) listed above and, as 
such, is responsible for maintaining said compiler(s) in conformance 
to ANSI/MIL-STD-1815A. All certificates and registrations for Ada 
language compiler(s) listed in this declaration shall be made only in 
the owner’s corporate name. 


V.Vt Date 

Alsys 

Mike Blanchette 

Vice President and Director of Engineering 


24 






DECLARATION OF CONFORMANCE 


Owner's Declaration 

I, the undersigned, representing Alsys, take full responsibility for 
implementation and maintenance of the Ada compiler(s) listed above, 
and agree to the public disclosure of the final Validation Summary 
Report. I further agree to continue to comply with the Ada trademark 
policy, as defined by the Ada Joint Program Office. I declare that all 
of the Ada language compilers listed, and their host/target 
performance, are in compliance with the Ada Language Standard 
ANSI/MIL-STD-1815A. 


^ Date ■ ■> • ^ / 

Alsys 

Mike Blanchette 

Vice President and Director of Engineering 


25 



TEST PARAMETERS 


APPENDIX B 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


Name and Meaning Value 


$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

$BIG_ID1 (254 * 'A') & '1' 

Identifier the size of the 
maximum input line length 
with varying last character. 

$BIG_ID2 (254 * * A) & , 2’ 

Identifier the size of the 
maximum input line length 
with varying last character. 

$BIG_ID3 (126 * 'A') & '3' & (128 * 'A') 

Identifier the size of the 
maximum input line length 
with varying middle character. 

$BIG_ID4 (126 * 'A') & ’4* & (128 * ’A*) 

Identifier the size of the 
maximum input line length 
with varying middle character. 


26 











TEST PARAMETERS 


Name and Meaning 


Value 


$BIG_INT_LIT (252 * ’O') 

An integer literal of value 
298 with enough leading zeroes 
so that it is the size of the 
maximum line length. 

$BIG_REAL_LIT (250 * '0') 

A universal real literal of 
value 690.0 with enough 
leading zeroes to be the size 
of the maximum line length. 


$BIG_STRING1 "" & (127 * 

A string literal which when 
catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 ' & (127 * 

A string literal which when 
catenated to the end of 
BIG_STRING1 yields the image 
of BIG ID1. 


SBLANKS 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

$COUNT_LAST 
A universal integer literal whose 
value is TEXT_IO.COUNT’LAST. 

$DEFAULT_MEM_SIZE 655360 

An integer literal whose value 
is SYSTEM.MEMORY SIZE. 


(235 * * ’) 


214783647 


$DEFAULT_STOR_UNIT 8 

An integer literal whose value 
is SYSTEM.STORAGEJJNIT. 

$DEFAULT_SYS_NAME I_80X86 

The value of the constant 
SYSTEM.SYSTEM NAME. 


$DELTA_D0C 2#1.0|E-31 

A real literal whose value is 
SYSTEM.FINE DELTA. 


& ’298' 


& '690.0' 


'A') & "" 


'A') & "1"' 


27 







TEST PARAMETERS 


Name and Meaning Value 


$FIELD_LAST 255 

A universal integer literal whose 
value is TEXT_IO.FIELD'LAST. 

$FIXED_NAME NO_SUCH_FIXED_TYPE 

The name of a predefined 
fixed-point type other than 
DURATION. 

$FLOAT_NAME NO_SUCH_TYPE 

The name of a predefined 
floating-point type other than 
FLOAT, SHORT_FLOAT, or 
LONG_FLOAT. 

$GREATER_THAN_DURATION 2_097_151.999_023_437_51 

A universal real literal that 
lies between DURATION'BASE'LAST 
and DURATION'LAST or any value 
in the range of DURATION. 

$G'REATER_THAN_DURATION_BASE_LAST 3 _000_000.0 
A universal real literal that is 
greater than DURATION'BASE'LAST. 

$HIGH_PRIORITY 10 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGALJEXTERNAL_FILE_NAME1 
An external file name which 
contains invalid characters. 

$ILLEGAL_EXTERNAL_FILE_NAME2 
An external file name which 
is too long. 

$INTEGER_FIRST 
A universal integer literal 
whose value is INTEGER'FIRST. 

$INTEGER_LAST 

A universal integer literal 
whose value is INTEGER'LAST. 


ILLEGAL\!$%*&*()/ + 


!$%*&*()?/)(*&\!$%‘ 


-32768 


32767 


28 









TEST PARAMETERS 


Name and Meaning Value 


$INTEGER_LAST_PLUS_1 32768 

A universal integer literal 
whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATION -2_097_152.5 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST -3000_000.0 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$LOW_PRIORITY 1 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTISSA_DOC 31 

An integer literal whose value 
is SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 15 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 255 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 2147483647 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 2147483648 

A universal integer literal 
whose value is SYSTEM.MAX_INT+1. 

$MAX_LEN_INT_BASED_LITERAL '42:' & (250 * '0') & 'll:’ 

A universal integer based 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 


29 












TEST PARAMETERS 


Name and Meaning Value 


$MAX_LEN_REAL_BASED_LITERAL '16:* & (248 * ’O’) & 'F.E:' 

A universal real based literal 
whose value is 16: F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL & (253 * ’A’) & "" 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
NULL;*’ as the only statement in 
its body. 

$NAME NO_SUCH_TYPE 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT.INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST I_80X86 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

$NEG_BASED_INT 16IFFFFFFFE# 

A based integer literal whose 
highest order nonzero bit falls 
in the sign bit position of the 
representation for SYSTEM.MAX_INT. 

$NEV_MEM_SIZE 655360 

An integer literal whose value 
is a permitted argument for 
pragma memory_size, other than 
DEFAULT_MEM_SIZE. If there is 
no other value, then use 
DEFAULT MEM SIZE. 


30 










TEST PARAMETERS 


Name and Meaning 


$NEV_STOR_UNIT 

An integer literal whose value 
is a permitted argument for 
pragma storage_unit, other than 
DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGEJJNIT 

$NEW_SYS_NAME 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

STASK^SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one inout 
parameter. 

STICK 

A real literal whose value is 
SYSTEM.TICK. 


Value 


8 


I 80X86 


32 


1.0/18.2 


31 











WITHDRAWN TESTS 


APPENDIX C 
WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 

the Ada Standard. The following 36 tests had been withdrawn at the 

time of validation testing for the reasons indicated. A reference of 

the form Al-ddddd is to an Ada Commentary. 

A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30). 

B97102E This test contains an unitended illegality: a select 

statement contains a null statement at the place of a 
selective wait alternative (line 31). 

BC3009B This test wrongly expects that circular instantiations 

will be detected in several compilation units even 
though none of the units is illegal with respect to the 
units it depends on; by AI-00256, the illegality need 
not be detected until execution is attempted (line 95). 

CD2A62D This test wrongly requires that an array object's size 

be no greater than 10 although its subtype’s size was 
specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These tests 
wrongly attempt to check the size of objects of a 
derived type (for which a 'SIZE length clause is given) 

by passing them to a derived subprogram (which 

implicitly converts them to the parent type (Ada 
standard 3.4:14)). Additionally, they use the 'SIZE 
length clause and attribute, whose interpretation is 
considered problematic by the VG9 ARG. 

CD2A81G, CD2A83G, CD2A84N & M, & CD50110 These tests assume that 
dependent tasks will terminate while the main program 
executes a loop that simply tests for task termination; 
this is not the case, and the main program may loop 

indefinitely (lines 74, 85, 86 & 96, 86 & 96, and 58, 
resp.). 

CD2B15C i CD7205C These tests expect that a ’STORAGE_SIZE length 

clause provides precise control over the number of 
designated objects in a collection; the Ada standard 
13.2:15 allows that such control must not be expected. 


32 











WITHDRAWN TESTS 


CD5007B This test wrongly expects an implicitly declared 

subprogram to be at the address that is specified for an 
unrelated subprogram (line 303). 

» 

CD7105A This test requires that successive calls to 

CALENDAR.CLOCK change by at least SYSTEM.TICK; however, 
by Commentary AI-00201, it is only the expected 
frequency of change that must be at least SYSTEM.TICK— 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B These tests use the ’SIZE length clause and 

attribute, whose interpretation is considered 

problematic by the WG9 ARG. 

CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task’s 
activation as though it were like the specification of 
storage for a collection. 

CE2107I This test requires that objects of two similar scalar 

types be distinguished when read from a file—DATA_ERROR 
is expected to be raised by an attempt to read one 

object as of the other type. However, it is not clear 
exactly how the Ada standard 14.2.4:4 is to be 

interpreted; thus, this test objective is not considered 
valid, (line 90). 

CE3111C This test requires certain behavior, when two files are 

associated with the same external file, that is not 

. required by the Ada standard. 

CE3301A This test contains several calls to END_OF_LINE & 

END_OF_PAGE that have no parameter: these calls were 
intended to specify a file, not to refer to 

STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 

CE3411B This test requires that a text file's column number be 

set to COUNT'LAST in order to check that LAYOUT_ERROR is 
raised by a subsequent PUT operation. But the former 
operation will generally raise an exception due to a 
lack of available disk space, and the test would thus 
encumber validation testing. 


33 












APPENDIX F OF THE Ada STANDARD 


APPENDIX D 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the AlsyCOMP_019, Version 
4.1, are described in the following sections, which discuss topics in 
Appendix F of the Ada Standard. Implementation-specific portions of 
the package STANDARD are also included in this appendix. 


package STANDARD is 


type INTEGER is range -32_768 .. 32_767; 
type SHORT_INTEGER is range -128 .. 127; 

type LONG_INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 range 
-2#1.111_1111_1111_1111_1111_1111#E+127 
• • 

2#l.lll_llll_llll_llll_llll_llllfE+127; 
type LONG FLOAT is digits 15 range 

-2#1.1'111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111#E1023 
« • 

2#1.1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111#E1023; 
type DURATION is delta 0.001 range -2097152.0 .. +2097152.0; 


end STANDARD; 


34 






Copyright 1988 by Alsys 


I 


All rights reserved. No part of this document may be reproduced in 
any form or by any means without permission in writing from Alsys. 


Printed: December 1988 

Alsys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice. Consult Alsys to determine whether 
such changes have been made. 


Alsys, AdsWorld AdsProbs, AdeXrtf, AdsRsformst, and AdsMsks art registered tradsmarks of Alsys. 
Microsoft, MS-DOS and MS art rsgistsrsd tradsmarks of Microsoft Corporation. 

IBM, PC AT, PS/2 and PC-DOS art rsgistsrsd tradsmarks of International Business Machines Corporation. 
INTEL is a rsgistsrsd trademark of Intel Corporation. 






TABLE OF CONTENTS 


APPENDIX F 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

1.3 INTERFACE_NAME 

1.4 INDENT 

1.5 Other Pragmas 


2 Implementation-Dependent Attributes 

2.1 P’IS_ARRAY 

2.2 P’RECORD_DESCRIPTOR, PARRA Y_DESCRIPTOR 

2.3 E’EXCEPTION CODE 


3 Specification of the package SYSTEM 


4 Support for Representation Clauses 

4.1 Enumeration Types 

4.1.1 Enumeration Literal Encoding 

4.1.2 Enumeration Types and Object Sizes 

4.2 Integer Types 

4.2.1 Integer Type Representation 

4.2.2 Integer Type and Object Size 
Minimum size of an integer subtype 

4.3 Floating Point Types 

4.3.1 Floating Point Type Representation 

4.3.2 Floating Point Type and Object Size 

4.4 Fixed Point Types 

4.4.1 Fixed Point Type Representation 

4.4.2 Fixed Point Type and Object Size 

4.5 Access Types and Collections 

4.6 Task Types 

4.7 Array Types 

4.7.1 Array Layout and Structure and Pragma PACK 

4.7.2 Array Subtype and Object Size 

4.8 Record Types 

4.8.1 Basic Record Structure 


Table of Contents 





4.8.2 Indirect components 

21 


4.8.3 Implicit components 

24 


4.8.3.1 RECORD SIZE 

25 


4.8.3.2 VARIANT INDEX 

25 


4.8.3.3 ARRAY DESCRIPTOR 

26 


4.8.3.4 RECORD_DESCRIPTOR 



4.8.3.5 Suppression of Implicit Components 



4.8.4 Size of Record Types and Objects 

28 

5 

Conventions for Implementation-Generated Names 

28 

6 

Address Clauses 

29 

6.1 

Address Clauses for Objects 

29 

6.2 

Address Clauses for Program Units 

29 

6.3 

Address Clauses for Interrupt Entries 

29 

7 

Unchecked Conversions 

30 

8 

Input-Output Packages 

30 

8.1 

Accessing Devices 

30 

8.2 

File Names and the FORM Parameter. 

30 

8.3 

Sequential Files 

31 

8.4 

Direct Files 

31 

8.5 

Text Files 

31 

8.6 

The Need to Close a File Explicitly 

32 

8.7 

Limitation on the procedure RESET 

32 

8.10 

Sharing of External Files and Tasking Issues 

32 

9 

Characteristics of Numeric Types 

33 

9.1 

Integer Types 

33 

9.2 

Floating Point Type Attributes 

33 

9.3 

Attributes of Type DURATION 

34 

10 

Other Implementation-Dependent Characteristics 

34 

10.1 

Use of the Floating-Point Coprocessor (80287) 

34 

10.2 

Characteristics of the Heap 

35 

10.3 

Characteristics of Tasks 

35 

10.4 

Definition of a Main Subprogram 

36 

10.5 

Ordering of Compilation Units 

36 

11 

Limitations 

36 

11.1 

Compiler Limitations 

36 

11.2 

Hardware Related Limitations 

36 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 






INDEX 


38 


iii 


Table of Conients 






APPENDIX F 


Implementation - Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys 
i80x86 Ada Cross Compilation System. This appendix is a required part of the 
Reference Manual for the Ada Programming Language (called the RM in this appendix). 

The sections of this appendix are as follows: 

1. The form, allowed places, and effect of every implementation-dependent 
pragma. , 

2. The name and the type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The description of the representation clauses. 

5. The conventions used for any implementation-generated name denoting im¬ 
plementation-dependent components. 

6. The interpretation of expressions that appear in address clauses, including 
those for interrupts. 

7. Any restrictions on unchecked conversions. 

8. Any implementation-dependent characteristics of the input-output packages. 

9. Characteristics of numeric types. 

10. Other implementation-dependent characteristics. 

11. Compiler limitations. 

-The name Alsys Runtime Executive Programs or simply Runtime Executive refers to the 
runtime library routines provided for all Ada programs. These routines implement the 
Ada heap, exceptions, tasking control, and other utility functions. 

General systems programming notes are given in another document, the Application De¬ 
veloper's Guide (for example, parameter passing conventions needed for interface with 
assembly routines). 


Appendix F, Implementation-Dependent Characteristics 


I 










1 . Implementation-Dependent Pragmas 

1.1 INLINE 

Pragma INLINE is fully supported; however, it is not possible to inline a subprogram in 
a declarative part. 


1.2 INTERFACE 

Ada programs can interface with subprograms written in Assembler and other languages 
through the use of the predefined pragma INTERFACE and the implementation-defined 
pragma INTERFACE_NAME. 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of 
the programming language for which parameter passing conventions will be generated. 
Pragma INTERFACE takes the form specified in the RM: 

pragma INTERFACE (language_name, subprogram_name)\ 

where, 

■ language_name is ASSEMBLER, ADA, or C. 

• subprogram_name is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language names accepted by pragma INTERFACE are ASSEMBLER, ADA and 
C. The full implementation requirements for writing pragma INTERFACE subprograms 
are described in the Application Developer's Guide. 

The language name used in the pragma INTERFACE does not have to have any re¬ 
lationship to the language actually used to write the interfaced subprogram. It is used 
only to tell the Compiler how to generate subprogram calls; that is, what kind of 
parameter passing techniques to use. The programmer can interface Ada programs with 
subroutines written in any other (compiled) language by understanding the mechanisms 
used for parameter passing by the Alsys i80x86 Ada Cross Compilation System and the 
corresponding mechanisms of the chosen external language. 


1.3 INTERFACE_NAME 

Pragma INTERFACE_NAME associates the name of the interfaced subprogram with 
the external name of the interfaced subprogram. If pragma INTERFACE_NAME is not 
used, then the two names are assumed to be identical. This pragma takes the form: 

pragma INTERFACE_NAME (subprogram_name, string _literal)\ 


2 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 











where, 

■ subprogram_name is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ string_literal is the name by which the interfaced subprogram is referred to 
at link time. 

The pragma INTERFACE_NAME is used to identify routines in other languages that 
are not named with legal Ada identifiers. Ada identifiers can only contain letters, dig¬ 
its, or underscores, whereas many linkers allow external names to contain other 
characters, for example, the dollar sign {$) or commercial at sign ((§>). These characters 
can be specified in the string_literal argument of the pragma INTERFACE_NAME. 

The pragma INTERFACE_NAME is allowed at the same places of an Ada program as 
the pragma INTERFACE. (Location restrictions can be found in section 13.9 of the 
RM.) However, the pragma 1NTERFACE_NAME must always occur after the pragma 
INTERFACE declaration for the interfaced subprogram. 

The string _literal of the pragma INTERFACE_NAME is passed through unchanged 
into the Intel OMF86 object file. The maximum length of the string_literal is 40 
characters. This limit is not checked by the Compiler, but the string is truncated by the 
Binder to meet the Intel object module format standard. 

The user must be aware however, that some tools from other vendors do not fully sup¬ 
port the standard object file format and may restrict the length of symbols. For exam¬ 
ple, the IBM and Microsoft assemblers silently truncate symbols at 31 characters. 

The Runtime Executive contains several external identifiers. All such identifiers begin 
with either the string "ADA<S>" or the string "ADAS<®\ Accordingly, names prefixed by 
"ADA(S>" or "ADAS@" should be avoided by the user. 

Example 

package SAMPLE_DATA is 

function SAHPLE_DEVICE (X: INTEGER) return INTEGER; 
function PR0CESSJ5AMPLE (X: INTEGER) return INTEGER; 
private 

pragma INTERFACE (ASSEMBLER, SAMPlE_0EVICE); 
pragma INTERFACE (ADA, PROCESS_SAMPLE); 
pragma INTERFACE_NAME (SAMPLE_DEVICE, "DEVJOSGET_SAMPLE"); 
end SAMPLE JJATA; 


Appendix F, Implementation-Dependent Characteristics 


3 









1.4 INDENT 


Pragma INDENT is only used with AdaReformat. AdaReformat is the Alsys reformatter 
which offers the functionalities of a pretty-printer in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. The line 

pragma INDENT(OFF); 

causes AdaReformat not to modify the source lines after this pragma, while 
pragma INDENT(ON); 

causes AdaReformat to resume its action after this pragma. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses and records (Chapter 4). 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Section 3). Undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress all checks in a given compi¬ 
lation by the use of the Compiler option CHECKS. (See Chapter 4 of the User's Guide.) 


2 Implementation-Dependent Attributes 

2.1 P’IS_ARRAY 

For a prefix P that denotes any type or subtype, this attribute yields the value TRUE if 
P is an array type or an array subtype; otherwise, it yields the value FALSE. 


2.2 P’RECORD_DESCRIPTOR, P’ARRAY_DESCRIPTOR 

These attributes are used to control the representation of implicit components of a 
record. (See Section 4.8 for more details.) 


2.3 E’EXCEPTION_CODE 

For a prefix E that denotes an exception name, this attribute yields a value that repre¬ 
sents the internal code of the exception. The value of this attribute is of the type 
INTEGER. 


4 


Alsys i80x86 Ada Cross Compilation System, Appendix F, Version 4.2 









3 Specification of the package SYSTEM 

The implementation does not allow the recompilation of package SYSTEM. 


package SYSTEM is 


* (1) Required Definitions. * 


type NAME is <I_80x86); 

SYSTEM_NAME : constant NAME := I_80x86; 

STORAGE_UNIT : constant := 8; 

MEM0RY_S1ZE : constant := 640 • 1024; 

-- System-Dependent Named Nunbers: 

MINJNT : constant :* -(2 ••31); 

MAX_INT : constant :* 2«*31 - 1; 

MAX_OIGITS : constant :* 15; 

MAX_MANTISSA : constant :* 31; 

FINE_DELTA : constant :* 2#1.0#E-31; 

-- For the high-resolution timer, the clock resolution is 
-- 1.0 / 1024.0. 

TICK S constant :* 1.0 / 18.2; 

-- Other System-Dependent Declarations: 

subtype PRIORITY is INTEGER range 1 .. 10; 

** The type ADDRESS is, in fact, implemented as a 
-- segment:offset pair. 

type A00RESS is private; 

NULl_AD0RES$: constant ADDRESS; 


*****•***»***»*»•••****•**•***** 
* (2) MACHINE TYPE CONVERSIONS • 




-- If the word / double-word operations below are used on 
-- ADDRESS, then MSW yields the segment and ISV yields the 
-- offset. 


Appendix F, Implementation-Dependent Characteristics 


5 









-- In the operations below, a BYTE_TYPE is any simple type 
-- implemented on 8-bits (for example, SHORTJNTEGER), a WORD_TYPE is 
-- any simple type implemented on 16-bits (for example, INTEGER), and 
-- a D0U8LE_W0RD_TYP6 is any simple type implemented on 
-- 32-bits (for example, LONG_INTEG£R, FLOAT, AODRESS). 

-- Byte «*»> Word conversions: 

-- Get the most significant byte: 
generic 

type BYTE_TYPE is private; 
type WORO_TYPE is private; 
function MSB (U: W0RD_TYPE) return BYTEJYPE; 

-- Get the least significant byte: 
generic 

type BYTE_TYPE is private; 
type WORO_TYPE is private; 
function LS8 (U: WORD.TYPE) return 8YTE_TYPE; 

•- Compose a word from two bytes: 
generic 

type BYTE_TYPE is private; 
type UORO_TYPE is private; 

function WORD (MSB, LS8: BYTE_TYPE) return WORD_TYPE; 


-- «ord <■«» Double-Word conversions: 

•• Get the most significant word: 
generic 

type W0R0_TTPE is private; 
type DOUBLE_WOM>_TYPE is private; 
function MSW (U: 00UBIE_W0RDJYPE) return WORP_ T YPE; 

-- Get the least significant word: 
generic 

type WORD_TYPE is private; 
type DOUBLE_WORD_TYPE is private; 
function ISW(W: DOUBLE_WO«D_TYPE) return WORD_TYPE; 

— Compose a OATA double word from two words, 
generic 

type W0RD_TYPE is private; 

-- The following type must be a data type 
-- (for example, LONGJNTEGER): 
type OATA_OOUBLE_WORO is private; 
function DOUBLE.WORD (MSW, LSW: W0R0_TYPE) 
return DATA_OOUBLE_WORD; 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 






-• Compose a REFERENCE double word from two words, 
generic 

type WORD_TYPE is private; 

-- The following type must be a reference type 
-- (for exaeple, access or ADDRESS): 
type R£F_DOU8lE_WORD is private; 
function REFERENCE (SEGMENT, OFFSET: WORD_TYPE) 
return R£F_DOU8LE_WORD; 


• (3) OPERATIONS ON ADDRESS * 


-- Tou can get an address via 'ADDRESS attribute or by 
-- instantiating the function REFERENCE, above, with 
•• appropriate types. 

-- Some addresses are used by the Compiler. For example, 

-- the display is located at the low end of the DS segment, 
-- and addresses SS:0 through SS:128 hold the task control 
-• block and other information. Writing into these areas 
*• will have unpredictable results. 

*• Note that no operations are defined to get the values of 
•• the segment registers, but if it is necessary an 
-- interfaced function can be written. 

generic 

type OBJECT is private; 

function FETCH_FROM_AOORESS (FROM; ADDRESS) return OBJECT; 
generic 

type OBJECT is private; 

procedure ASS1GN_T0_ADDRESS (OBJ: OBJECT; TO: AOORESS); 
private 


end SYSTEM; 



Appendix F, Implementation-Dependent Characteristics 











4 Support for Representation Clauses 


This section explains how objects are represented and allocated by the Alsys i80x86 Ada 
Cross Compilation System and how it is possible to control this using representation 
clauses. Applicable restrictions on representation clauses are also described. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representa¬ 
tion of the corresponding objects is described. 

Except in the case of array and record types, the description for each class of type is 
independent of the others. To understand the representation of array and record types it 
is necessary to understand first the representation of their components. 

Apart from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, applicable to array types 

■ a record representation clause 

■ a size specification 

For each class of types the effect of a size specification is described. Interactions among 
size specifications, packing and record representation clauses is described under the 
discussion of array and record types. 

Representation clauses on derived record types or derived tasks types are not supported. 

Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


4.1 Enumeration Types 

4.1.1 Enumeration Literal Encoding 

When no enumeration representation clause applies to an enumeration type, the internal 
code associated with an enumeration literal is the position number of the enumeration 
literal. Then, for an enumeration type with n elements, the internal codes are the inte¬ 
gers 0, 1, 2, .. , n-1. 

* An enumeration representation clause can be provided to specify the value of each 
internal code as described in RM 13.3. The Alsys compiler fully implements enumeration 
representation clauses. 


8 


Alsys 180x86 Ada Cross Compilation System. Appendix F. Version 4.2 







As internal codes must be machine integers the internal codes provided by an enumera¬ 
tion representation clause must be in the range -2 31 .. 2 31 -1. 

An enumeration value is always represented by its internal code in the program gener¬ 
ated by the compiler. 


4.1.2 Enumeration Types and Object Sizes 

Minimum size of an enumeration subtype 

The minimum possible size of an enumeration subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form. 

A static subtype, with a null range has a minimum si 2 e of 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m >= C, L is the 
smallest positive integer such that M <« 2 L -1. For m < 0, L is the smallest positive inte¬ 
ger such that -2 l ' 1 <* m and M <* 2 L_1 -1. For example: 

type COLOR is (GREEN, BLACK, WHITE, RED, BLUE. YELLOW); 

-- The minimum size of COLOR is 3 bits. 

subtype BLACK_AND_WHITE is COLOR range BLACK .. WHITE; 

— The minimum size of BLACK_AND_WHITE is 2 bits. 

subtype BLACK_OR_WHITE is BLACK_AND_WHITE range X .. X; 

— Assuming that X is not static, the minimum size of BLACK_OR_WHITE is 
-- 2 bits (the same as the minimum size of its type mark 
BLACK_AND_WHITE). 


Size of an enumeration subtype 

When no size specification is applied to an enumeration type or first named subtype, the 
objects of that type or first named subtype are represented as signed machine integers. 
The machine provides 8, 16 and 32 bit integers, and the compiler selects automatically 
the smallest signed machine integer which can hold each of the internal codes of the 
enumeration type (or subtype). The size of the enumeration type and of any of its sub- 
types is thus 8, 16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to 
a first named subtype. The size specification must of course specify a value greater than 
or equal to the minimum size of the type or subtype to which it applies: 


Appendix F, Implementation-Dependent Characteristics 


9 




type EXTENDED is 

(-- The usual ASCII character set. 

NUL, SOH, STX, ETX, EOT, ENQ, ACK.. BEL, 

’x\ ’y\ ’z\ ’{’, T. T, DEL, 

— Extended characters 

C_CEDILLA_CAP, U_UMLAUT, E_ACUTE, ...); 
for EXTENDED’SIZE use 8; 

— The size of type EXTENDED will be one byte. Its objects will be represented 
-- as unsigned 8 bit integers. 

The Alsys compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 


Size of the objects of an enumeration subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an enumeration subtype has the same size as its subtype. 


4.2 Integer Types 


There are three predefined integer 
machines: 

types in the Alsys 

implementation for 180x86 

type SHORT INTEGER 

is range -2**07 

.. 2**07-1; 

type INTEGER 

is range -2**15 

.. 2**15-1; 

type LONG INTEGER 

is range -2**31 

.. 2**31-1; 


4.2.1 Integer Type Representation 
An integer type declared by a declaration of the form: 
type T is range L .. R; 

is implicitly derived from a predefined integer type. The compiler automatically selects 
the predefined integer type whose range is the smallest that contains the values L to R 
.inclusive. 

* Binary code is used to represent integer values. Negative numbers are represented using 
two’s complement. 


10 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 













4.2.2 Integer Type and Object Size 

Minimum size of an integer subtype 

The minimum possible size of an integer subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binary 
form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M 
are the lower and upper bounds of the subtype, then its minimum size L is determined 
as follows. For m >= 0, L is the smallest positive integer such that M <* 2 l «j. For 
m < 0, L is the smallest positive integer that -2 L_1 <= m and M <= 2 t_I -l. For example: 

subtype S is INTEGER range 0 .. 7; 

-- The minimum size of S is 3 bits. 

/ 

subtype D is S range X .. Y; 

-- Assuming that X and Y are not static, the minimum size of 
-- D is 3 bits (the same as the minimum size of its type mark S). 


Size of an integer subtype 

The sizes of the predefined integer types SHORT_!NTEGER, INTEGER and 
LONG_INTEGER are respectively 8, 16 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, directly or indirectly. For example: 

type S is range 80 .. 100; 

— S is derived from SHORT_INTEGER, its size is 8 bits, 
type J is range 0 .. 255; 

— J is derived from INTEGER, its size is 16 bits, 
type N is new J range 80 .. 100; 

-- N is indirectly derived from INTEGER, its size is 16 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is range 80 .. 100; 
for S'SIZE use 32; 

— S is derived from SHORT_INTEGER, but its size is 32 bits 
— because of the size specification. 


Appendix F, Implementation-Dependent Characteristics 


11 









type J is range 0 .. 255; 
for J’SIZE use 8; 

-- J is derived from INTEGER, but its size is 8 bits because 
— of the size specification. 

type N is new J range 80 .. 100; 

-- N is indirectly derived from INTEGER, but its size is 8 bits 
-- because N inherits the size specification of J. 


Size of the objects of an integer subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an integer subtype has the same size as its subtype. 


4.3 Floating Point Types 

There are two predefined floating point types in the Alsys implementation for 180x86 
machines: 

type FLOAT is 

digits 6 range -(2.0 - 2.0**(-23))*2.0**127 .. (2.0 - 2.0**(-23))*2.0**127; 
type LONG_FLOAT is 

digits 15 range -(2.0 - 2.0**(-51))*2.0**1023 .. (2.0 - 2.0**(-51))*2.0**1023; 


4.3.1 Floating Point Type Representation 
A floating point type declared by a declaration of the form: 
type T is digits O [range L .. R]; 

is implicitly derived from a predefined floating point type. The compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L to R inclusive. 

In the program generated by the compiler, floating point values are represented using 
the IEEE standard formats for single and double floats. 

The values of the predefined type FLOAT are represented using the single float format. 
The values of the predefined type LONG__FLOAT are represented using the double 
* float format. The values of any other floating point type are represented in the same 
way as the values of the predefined type from which it derives, directly or indirectly. 


12 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 











4.3.2 Floating Point Type and Object Size 


The minimum possible size of a floating point subtype is 32 bits if its base type is 
FLOAT or a type derived from FLOAT; it is 64 bits if its base type is LONG_FLOAT 
or a type derived from LONG_FLOAT. 

The sizes of the predefined floating point types FLOAT and LONG_FLOAT are 
respectively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype us¬ 
ing a size specification is its usual size (32 or 64 bits). 

An object of a floating point subtype has the same size as its subtype. 


4.4 Fixed Point Types 

4.4.1 Fixed Point Type Representation 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by RM 3.5.9. 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

To implement fixed point types, the Alsys compiler for 180x86 machines uses a set of 
anonymous predefined types of the form; 

type SHORT_FIXED is delta D range (-2.0**07-1 )*S .. 2.0**07*S; 
for SHORT_FIXED' SMALL use S; 

type FIXED is delta D range (-2.0**15-1)*S .. 2.0**15*S; 

for FIXED'SMALL use S; 

type LONC_F/XED is delta D range (-2.0**31-1)*S .. 2.0**31*S; 
for LONC_FIXED'SM ALL use S; 

where D is any real value and S any power of two less than or equal to D. 

•A fixed point type declared by a declaration of the form: 
type T is delta D range L .. R; 

9 

possibly with a small specification: 
for TSMALL use S; 


Appendix F, Implementation-Dependent Characteristics 


13 




is implicitly derived from a predefined fixed point type. The compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L to R inclusive. 

In the program generated by the compiler, a safe value V of a fixed point subtype F is 
represented as the integer: 

V / FBASE'SMALL 


4.4.2 Fixed Point Type and Object Size 

Minimum size of a fixed point subtype 

The minimum possible size of a fixed point subtype is the minimum number of binary 
digits that is necessary for representing the values of the range of the subtype using the 
small of the base type. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S 
being the bounds of the subtype, if i and 1 are the integer representations of m and M, 
the smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i >■> 0, L is the smallest positive 
integer such that I <» 2 L -1. For i < 0, L is the smallest positive integer such that 
-2 l_1 <* i and 1 <* 2 L ' 1 -1. 


type F is delta 2.0 range 0.0 .. 500.0; 

-- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0 .. 250.0; 

— The minimum size of S is 7 bits. 

subtype D is S range X .. Y; 

— Assuming that X and Y are not static, the minimum size of D is 7 bits 

— (the same as the minimum size of its type mark S). 


Size of a fixed point subtype 

The sizes of the predefined fixed point types SHORTJFIXED , FIXED and 
LONC_FIXED are respectively 8, 16 and 32 bits. 

When no size specification is applied to a fixed point type or to its first named subtype, 
* its size and the size of any of its subtypes is the size of the predefined type from which 
it derives directly or indirectly. For example: 

type S is delta 0.01 range 0.8 .. 1.0; 

— S is derived from an 8 bit predefined fixed type, its size is 8 bits, 
type F is delta 0.01 range 0.0 .. 2.0; 

— F is derived from a 16 bit predefined fixed type, its size is 16 bits. 


14 


Alsys i80x86 Ada Cross Compilation System, Appendix F. Version 4.2 








type N is new F range 0.8 .. 1.0; 

-- N is indirectly derived from a 16 bit predefined fixed type, its size is 16 bits. 


When a size specification is applied to a fixed point type, this fixed point type and each 
of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than 
or equal to the minimum size of the type or subtype to which it applies: 

type S is delta 0.01 range 0.8 .. 1.0; 
for S’SIZE use 32; 

-- S is derived from an 8 bit predefined fixed type, but its size is 32 bits 

— because of the size specification. 

type F is delta 0.01 range 0.0 .. 2.0; 
for F’SIZE use 8; 

-- F is derived from a 16 bit predefined fixed type, but its size is 8 bits 

— because of the size specification. 

type N is new F range 0.8 .. 1.0; 

-- N is indirectly derived from a 16 bit predefined fixed type, but its size is 
-- 8 bits because N inherits the size specification of F. 

The Alsys compiler fully implements size specifications. Nevertheless, as fixed point 
objects are represented using machine integers , the specified length cannot be greater 
than 32 bits. 


Size of the objects of a fixed point subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of a fixed point type has the same size as its subtype. 


4.5 Access Types and Collections 

Access Types and Objects of Access Types 

The only size that can be specified for an access type using a size specification is its 
usual size (32 bits). 

An object of an access subtype has the same size as its subtype, thus an object of an 
access subtype is always 32 bits long. 

Collection Size 

As described in RM 13.2, a specification of collection size can be provided in order to 
reserve storage space for the collection of an access type. 


Appendix F. Implementation-Dependent Characteristics 


15 




When no STORAGE_SIZE specification applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORAGE_SIZE is then 0. 

The maximum size allowed for a collection is 64k bytes. 


4.6 Task Types 

Storage for a task activation 

As described in RM 13.2, a length clause can be used to specify the storage space (that 
is, the stack size) for the activation of each of the tasks of a given type. Alsys also al¬ 
lows the task stack size, for all tasks, to be established using a Binder option. If a 
length clause is given for a task type, the value indicated at bind time is ignored for this 
task type, and the length clause is obeyed. When no length clause is used to specify the 
storage space to be reserved for a task activation, the storage space indicated at bind 
time is used for this activation. 

A length clause may not be applied to a derived task type. The same storage space is 
reserved for the activation of a task of a derived type as for the activation of a task of 
the parent type. 

The minimum size of a task subtype is 32 bits. 

A size specification has no effect on a task type. The only size that can be specified 
using such a length clause is its usual size (32 bits). 

An object of a task subtype has the same size as its subtype. Thus an object of a task 
subtype is always 32 bits long. 


4.7 Array Types 

Each array is allocated in a contiguous area of storage units. All the components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 


4.7.1 Array Layout and Structure and Pragma PACK 



Component Gap Compone n t Gap Component Gap 


16 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 








If pragma PACK is not specified for an array, the size of the components is the size of 
the subtype of the components: 


type A is array (1 ..8) of BOOLEAN; 

— The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIGIT is range 0 .. 9; 
for DECIMAL_DIGITSIZE use 4; 
type BINARY_C0DED_DEC1MAL is 

array (INTEGER range <>) of DECIMAL_DIGIT; 

— The size of the type DECIMAL_DIGIT is 4 bits. Thus in an array of 
-- type BINARY_CODED_DECIMAL each component will be represented on 
— 4 bits as in the usual BCD representation. 

If pragma PACK is specified for an array and its components are neither records nor 
arrays, the size of the components is the minimum size of the subtype of the compo¬ 
nents: 


type A is array (1 ..8) of BOOLEAN; 
pragma PACK(A); 

— The size of the components of A is the minimum size of the type BOOLEAN: 

— I bit. 

type DECIMAL_DIGIT is range 0 .. 9; 
for DECIMAL_DIGITSIZE use 32; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range <>) of DEC1MAL_D1GIT; 
pragma PACK(BINARY_CODED_DECIMAL); 

— The size of the type DECIMAL_DIGIT is 32 bits, but, as 
— BINaRY_CODED_DECIMAL is packed, each component of an array of this 
-- type will be represented on 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays, since records and arrays may be assigned addresses consistent with the 
alignment of their subtypes. 


Gaps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the compiler may choose a representa¬ 
tion with a gap after each component; the aim of the insertion of such gaps is to opti¬ 
mize access to the array components and to their subcomponents. The size of the gap is 
'chosen so that the relative displacement of consecutive components is a multiple of the 
alignment of the subtype of the components. This strategy allows each component and 
subcomponent to have an address consistent with the alignment of its subtype: 


Appendix F, Implementation-Dependent Characteristics 


17 






type R is 
record 

K : INTEGER; 

B : BOOLEAN; 
end record; 
for R use 
record 

K it 0 range 0 .. 15; 

B at 2 range 0 .. 0; 
end record; 

-- Record type R is byte aligned. Its size is 17 bits, 
type A is array (1 .. 10) of R; 

-- A gap of 7 bits is inserted after each component in order to respect the 
-- alignment of type R. The size of an array of type A will be 240 bits. 



****** 


***** 


***** 


K 

B 

K 

B 



K 

B 





Component Gap Component Gap Component Gap 


Array of type A: each subcomponent K has an even offset. 

If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are inserted: 

type R is 
record 

K : INTEGER; 

B : BOOLEAN; 
end record; 

type A is array (1 .. 10) of R; 
pragma PACK(A); 

— There is no gap in an array of type A because 
-- A is packed. 

-- The size of an object of type A will be 270 bits. 

type NR is new R; 
for NR’SIZE use 24; 

type B is array (1 .. 10) of NR; 

— There is no gap in an array of type B because 
— NR has a size specification. 

— The size of an object of type B will be 240 bits. 


18 


Alsvs i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 












\ 



Component 


Component 


Array of type A or B 


4.7.2 Array Subtype and Object Size 

Size of an array subtype 

The size of an array subtype is obtained by multiplying tne number of its components 
by the sum of the size of the components and the size of the gaps (if any). If the sub- 
type is unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

• if it has non-static constraints or is an unconstrained array type with non¬ 
static index subtypes (because the number of components can then only be 
determined at run time). 

■ if the components are records or arrays and their constraints or the con¬ 
straints of their subcomponents (if any) are not static (because the size of the 
components and the size of the gaps can then only be determined at run 
time). 

As has been indicated above, the effect of a pragma PACK on an array type is to sup¬ 
press the gaps. The consequence of packing an array type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the con¬ 
straints of their subcomponents (if any) are not static, the compiler ignores any pragma 
PACK applied to the array type but issues a warning message. Apart from this limita¬ 
tion, array packing is fully implemented by the Alsys compiler. 

A size specification applied to an array type or first named subtype has no effect. The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of an array is as expected by 
the application. 


Size of the objects of an array subtype 

The size of an object of an array subtype is always equal to the size of the subtype of 
the object. 


Appendix F, Implementation-Dependent Characteristics 


19 










4.8 Record Types 

4.8.1 Basic Record Structure 

Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record com¬ 
ponent depends on its type. 

The positions and the sizes of the components of a record type object can be controlled 
using a record representation clause as described in RM 13.4. In the Alsys implementa¬ 
tion for 180x86 machines there is no restriction on the position that can be specified for 
a component of a record. If a component is not a record or an array, its size can be any 
size from the minimum size to the size of its subtype. If a component is a record or an 
array, its size must be the size of its subtype: 

type DEVICEJNFOJtECORO is 
record 

B1T15 : BOOLEAN; -• Bit 15 (reserved) 

CTRL : BOOLEAN; -- Bit 14 (true if control strings processed) 

NETWORK : BOOLEAN; -* Bit 13 (true if device is on network) 

• BIT12 : BOOLEAN; -- Bit 12 (reserved) 

BIT11 : BOOLEAN; -- Bit 11 (reserved) 

BIT10 : BOOLEAN; -- Bit 10 (reserved) 

BIT9 : boolean; -* Bit 9 (reserved) 

BIT8 : boolean; -• Bit 8 (reserved) 

ISDEV : BOOLEAN; -- Bit 7 (true if device, felse if disk file) 

EOF : BOOLEAN; -- Bit 6 (true if at end of file) 

BINARY : BOOLEAN; -- Bit 5 (true if binary (raw) mode) 

BIT4 : BOOLEAN; -• Bit 4 (reserved) 

ISCLK : BOOLEAN; -• Bit 3 (true if clock device) 

ISNUL : BOOLEAN; •• Bit 2 (true if NUL device) 

ISCOT : BOOLEAN; -- Bit 1 (true if console output device) 

ISC1N : BOOLEAN; -- Bit 0 (true if console input device) 

end record; 


for DEVtCE_INFO_RECORD use 
record 


BIT15 

at 

1 

range 7 


7; 

-- Bit 15 

CTRL 

at 

1 

range 6 


6; 

- Bit 14 

NETWORK 

at 

1 

range 5 


5; 

- Bit 13 

B1T12 

at 

1 

range 4 


4; 

-- Bit 12 

BIT11 

at 

1 

range 3 


3; 

- Bit 11 

BIT10 

at 

1 

range 2 


2; 

-- Bit 10 

BIT9 

at 

1 

range 1 


1; 

-- Bit 9 

BITS 

at 

1 

range 0 


0; 

-- Bit 8 

ISOEV 

at 

0 

range 7 


7; 

-- Bit 7 

EOF 

at 

0 

range 6 


6; 

- Bit 6 

BINARY 

at 

0 

range 5 


5; 

- Bit 5 

BIT4 

at 

0 

range 4 


4; 

- Bit 4 


20 


Alsvs i80x86 Ada Cross Compilation System, Appendix F, Version 4.2 









ISCIK «t 0 range 3 .. 3; *• Bit 3 

ISNUL at 0 range 2 .. 2; -* Bit 2 

I SCOT at 0 range 1 .. 1; -- lit 1 

I SCIH at 0 range 0 .. 0; -- Bit 0 

end record; 

Pragma PACK has no effect on records. It is unnecessary because record representation 
clauses provide full control over record layout. 

A record representation clause need not specify the position and the size for every com¬ 
ponent. If no component clause applies to a component of a record, its size is the size 
of its subtype. 


4.8.2 Indirect components 

If the offset of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direct: 



Beginning of the record 
Coepile time offset 


Compile time offset 


Run time offset 


A direct and an indirect component 


If a record component is a record or an array, the size of its subtype may be evaluated 
at run time and may even depend on the discriminants of the record. We will call these 
'components dynamic components: 

type DEVICE is (SCREEN, PRINTER); 

type COLOR is (GREEN, RED, BLUE); 

type SERIES is array (POSITIVE range <>) of INTEGER; 


Appendix F, Implementation-Dependent Characteristics 


21 




type GRAPH (L : NATURAL) is 
record 

X : SERIES<1 .. L); — The size of X depends on L 
Y : SERIES(1 .. L); — The size of Y depends on L 
end record; 

Q : POSITIVE; 

t 

I type PICTURE (N : NATURAL; D : DEVICE) is 

: record 

F : GRAPH(N); — The size of F depends on N 
S : GRAPH(Q); -- The size of S depends on Q 
case D is 

when SCREEN ■> 

C : COLOR; 
when PRINTER «> 
null; 

end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be eval¬ 
uated at compile time and is thus indirect. In order to minimize the number of indirect 
components, the compiler groups the dynamic components together and places them at 
the end of the record: 


22 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 












D * SCREEN 
N * 2 


D * PRINTER 
N * 1 


S OFFSET 


F OFFSET 


Beriming of the record 
- Compile time offsets — 


Run time offsets 


S OFFSET 


F OFFSET 


The record type PICTURE: F and S are placed at the end of the record 

Note that Ada does not allow representation clauses for record components with non¬ 
static bounds [RM 13.4.7], so the compiler’s grouping of dynamic components does not 
conflict with the use of representation clauses. 

Because of this approach, the only indirect components are dynamic components. But 
not all dynamic components are necessarily indirect: if there are dynamic components in 
a component list which is not followed by a variant part, then exactly one dynamic 
component of this list is a direct component because its offset can be computed at com¬ 
pilation time (the only dynamic components that are direct components are in this situa¬ 
tion): 


Appendix F, Implementation-Dependent Characteristics 


23 


















Y OFFSET 


Beginning of the record 
Conpile time offset 


. Compile time offset 

Size dependent on discriminant L 
— Run time offset 

Size dependent on discriminant L 


The record type GRAPH: the dynamic component X is a direct component. 


The offset of an indirect component is always expressed in storage units. 

The space reserved for the offset of an indirect component must be large enough to 
store the size of any value of the record type (the maximum potential offset). The com¬ 
piler evaluates an upper bound MS of this size and treats an offset as a component hav¬ 
ing an anonymous integer type whose range is 0 .. MS. 

If C is the name of an indirect component, then the offset of this component can be 
denoted in a component clause by the implementation generated name C’OFFSET. 


4.8.3 Implicit components 

In some circumstances, access to an object of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid recom¬ 
putation (which would degrade performance) the compiler stores this information in the 
record objects, updates it when the values of the discriminants are modified and uses it 
when the objects or its components are accessed. This information is stored in special 
components called implicit components. 

An implicit component may contain information which is used when the record object 
or several of its components are accessed. In this case the component will be included in 
any record object (the implicit component is considered to be declared before any 
variant part in the record type declaration). There can be two components of this kind; 
one is called RECORD_SlZE and the other VaRIANT_INDEX. 

On the other hand an implicit component may be used to access a given record compo¬ 
nent. In that case the implicit component exists whenever the record component exists 
(the implicit component is considered to be declared at the same place as the record 
component). Components of this kind are called ARRAY_DESCRIPTORs or 
RECORD DESCRIPTORS. 


24 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 





4.8.3.1 RECORD SIZE 


This implicit component is created by the compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space neces¬ 
sary to store the current value of the record object (note that the storage effectively 
allocated for the record object may be more than this). 

The value of a RECORD_SIZE component may denote a number of bits or a number of 
storage units In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maximum 
size of any value of the record type. The compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer type 
whose range is 0 .. MS. 

If R is the name of the record type, this implicit component can be denoted in a com¬ 
ponent clause by the implementation generated name R’RECORD_SIZE. This allows 
user control over the position of the implicit component in the record. 


4.8.3.2 VARIANTINDEX 

This implicit component is created by the compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used 
when a discriminant check is to be done. 

Component lists in variant parts that themselves do not contain a variant part are num¬ 
bered. These numbers are the possible values of the implicit component 
VARIANTJNDEX. 

type VEHICLE is (AIRCRAFT, ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND : VEHICLE CAR) is 
record 

SPEED : INTEGER; 
case KIND is 

when AIRCRAFT | CAR *> 

WHEELS : INTEGER; 
case KIND is 

when AIRCRAFT ■> -- 1 

WINGSPAN : INTEGER; 
when others ■> -- 2 

null; 

end case; 


Appendix F. Implementation-Dependent Characteristics 


25 









when BOAT »> — 3 

STEAM : BOOLEAN; 
when ROCKET -> — 4 

STAGES : INTEGER; 

end case; 
end record; 

The value of the variant index indicates the set of components that are present in a 
record value: 


Variant Index 

Set 

1 

{KIND, SPEED, WHEELS, WINGSPAN) 

2 

{KIND, SPEED, WHEELS) 

3 

{KIND, SPEED, STEAM) 

4 

{KIND, SPEED, STAGES) 


A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Component 

Interval 

KIND 

.. 

SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAM 

3 .. 3 

STAGES 

4 .. 4 


The implicit component VaRIANT_INDEX must be large enough to store the number 
V of component lists that don’t contain variant parts. The compiler treats this implicit 
component as having an anonymous integer type whose range is 1 .. V. 

If R is the name of the record type, this implicit component can be denoted in a com¬ 
ponent clause by the implementation generated name R'VARIANT_INDEX. This 
allows user control over the position of the implicit component in the record. 


4.8.3.3 ARRAY_DESCRIPTOR 

An implicit component of this kind is associated by the compiler with each record com¬ 
ponent whose subtype is an anonymous array subtype that depends on a discriminant of 
* the record. It contains information about the component subtype. 

The structure of an implicit component of kind ARRAY_DESCRIPTOR is not 
described in this documentation. Nevertheless, if a programmer is interested in specify¬ 
ing the location of a component of this kind using a component clause, size of the com¬ 
ponent may be obtained using the ASSEMBLY parameter in the COMPILE command. 


26 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 










The compiler treats an implicit component of the Kind ARRAY_DESCR1PT0R as hav¬ 
ing an anonymous array type. If C is the name of the record component whose subtype 
is described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name C'ARRAY_DESCRIPTOR. 
This allows user control over the position of the implicit component in the record. 


4.8.3.4 RECORDDESCRIPTOR 

An implicit component of this kind is associated by the compiler with each record com¬ 
ponent whose subtype is an anonymous record subtype that depends on a discriminant of 
the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD_DESCRIPTOR is not 
described in this documentation. Nevertheless, if a programmer is interested in specify¬ 
ing the location of a component of this kind using a component clause, the size of the 
component may be obtained using the ASSEMBLY parameter in the COMPILE com¬ 
mand. 

The compiler treats an implicit component of the kind RECORD_DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 
C’RECORD_DESCRIPTOR. This allows user control over the position of the implicit 
component in the record. 


4.8.J.5 Suppression of Implicit Components 

The Alsys implementation provides the capability of suppressing the implicit components 
RECORD_SIZE and/or VaRIaNT_INDEX from a record type. This can be done using 
an implementation defined pragma called IMPROVE. The syntax of this pragma is as 
follows: 

pragma IMPROVE ( TIME | SPACE , [ON «>] simple_name ); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the representation of the record type that is denoted by the second argument. 

If TIME is specified, the compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the compiler only inserts a VARIANT_INDEX or a 
RECORD^SIZE component if this component appears in a record representation clause 
that applies to the record type. A record representation clause can thus be used to keep 
*one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Appendix F, Implementation-Dependent Characteristics 


27 










4.8.4 Size of Record Types and Objects 

Size of a record subtype 

Unless a component clause specifies that a component of a record type has an offset or a 
size which cannot be expressed using storage units, the size of a record subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its compo¬ 
nents and the sizes of its gaps (if any). This size is not computed at compile time 

■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at 
compile time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the com¬ 
ponents and the sizes of the gaps (if any) of its largest variant. If the size of a compo¬ 
nent or of a gap cannot be evaluated exactly at compile time an upper bound of this size 
is used by the compiler to compute the subtype size. 

A size specification applied to a record type or first named subtype has no effect. The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of a record is as expected by 
the application. 


Size of an object of a record subtype 

An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this 
size is less than or equal to 8 kb. If the size of the subtype is greater than this, the 
object has the size necessary to store its current value; storage space is allocated and 
released as the discriminants of the record change. 


5 Conventions for Implementation-Generated Names 

The Alsys i80x86 Ada Cross Compilation System may add fields to record objects and 
have descriptors in memory for record or array objects. These fields are accessible to 
the user through implementation-generated attributes (See Section 2.3). 

•The following predefined packages are reserved to Alsys and cannot be recompiled in 
Version 4.2: 

AlSYSjkOAJtUNTIME 
AlSYS_8AStCJ0 
AlSYS_#ASlC_Otl»ECTJO 
AL$Y$_BASt C.SEQUENT1AlJ 0 


28 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 







6 Address Clauses 


6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an object as described in RM 
13.5. When such a clause applies to an object the compiler does not cause storage to be 
allocated for the object. The program accesses the object using the address specified in 
the clause. It is the responsibility of the user therefore to make sure that a valid alloca¬ 
tion of storage has been done at the specified address. 

An address clause is not allowed for task objects, for unconstrained records whose size is 
greater than 8k bytes or for a constant. 

There are a number of ways to compose a legal address expression for use in an address 
clause. The most direct ways are: 

• For the case where the memory is defined in Ada as another object, use the 
’ADDRESS attribute to obtain the argument for the address clause for the 
second object. 

■ For the case where an absolute address is known to the programmer, instan¬ 
tiate the generic function SYSTEM.REFERENCE on a 16 bit unsigned inte¬ 
ger type (either from package UNSIGNED, or by use of a length clause on a 
derived integer type or subtype) and on type SYSTEM.ADDRESS. Then the 
values of the desired segment and offset can be passed as the actual param¬ 
eters to the instantiated function in the simple expression part of the address 
clause. See Section 3 for the specification of package SYSTEM. 

■ For the case where the desired location is memory defined in assembly or 
another non-Ada language (is relocatable), an interfaced routine may be used 
to obtain the appropriate address from referencing information known to the 
other language. 

In ail cases other than the use of an address attribute, the programmer must ensure that 
the segment part of the argument is a selector if the program is to run in protected 
mode. Refer to the Application Developers' Guide, Section 5.5 for more information on 
protected mode machine oriented programming. 


6.2 Address Clauses for Prof am Units 

Address clauses for program units are not implemented in the current version of the 
compiler. 


6.3 Address Clauses for Interrupt Entries 

Address clauses for interrupt entries are supported. (See Chapter 7 of the Application 
Developer's Guide for details.) 


Appendix F, Implementation-Dependent Characteristics 


29 









7 Unchecked Conversions 


Unchecked conversions are allowed between any types. It is the programmer’s re¬ 
sponsibility to determine if the desired effect is achieved. 


8 Input-Output Packages 

The RM defines the predefined input-output packages SEQUENTIAL_IO, 
DIRECT_IO, and TEXT__IO, and describes how to use the facilities available within 
these packages. The RM also defines the package 10_EXCEPTI0NS, which specifies 
the exceptions that can be raised by the predefined input-output packages. 


In addition the RM outlines the package LOW_LEVEL_IO, which is concerned with low- 
level machine-dependent input-output, such as would possibly be used to write device drivers 
or access device registers. LOW_LEVEL_IO has not been implemented. In general, 
functionality equivalent to this package is provided by the application developer when 
building the board support package for the Ada runtime executive. 


For details regarding 10 facilities of the native DOS compiler included in the system, refer to 
the Alsys 286 DOS Ada Compiler Appendix F. 8.1 Accessing Devices 


The application developermust provide a description of input-output devices and 
provide drivers for them. These drivers permit the various devices to be accessed 
directly through the Ada standard 10 packages TEXT_IO, DIRECT_IO and 
SEQUENTIAL_IO. 

All information necessary to describe devices and build drivers is provided in the Cross 
Development Guide contained in this documentation set. 


8.2 File Names and the FORM Parameter. 

Only built-in files and devices are recognized as files by the 10 packages. All devices 
and built-in files must be specified in the DEVICES.ASM file, as described in the 
accompanying Cross Development Guide. Any number of files may be created. Several 
logical files may be associated with a single device, provided that they are all defined in 
DEVICES.ASM. 

This implies that ail CREATE procedures will raise USE_ERR0R, and that all OPEN 
procedures will also raise USE_ERR0R if the NAME parameter does not designate a 
built-in file or device. 

The function FORM always returns a null string. 

The FORM parameter of the OPEN procedures must be a null string. 


30 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 








8.3 Sequential Files 


For sequential access the file is viewed as a sequence of values that are transferred in 
the order of their appearance (as produced by the program or run-time environment). 
This is sometimes called a stream file in certain operating systems. Each object in a se¬ 
quential file has the same binary representation as the Ada object in the executable pro¬ 
gram. 


8.4 Direct Files 

For direct access the file is viewed as a set of elements occupying consecutive positions 
in a linear order. The position of an element in a direct file is specified by its index, 
which is an integer of subtype POSITIVE_COUNT. 

DIRECT_IO only allows input-output for constrained types. If DIRECT_IO is in¬ 
stantiated for an unconstrained type, all calls to CREATE or OPEN will raise 
USE_ERROR. Each object in a direct file will have the same binary representation as 
the Ada object in the executable program. All elements within the file will have the 
same length. 


8.5 Text Files 

Text files are used for the input and output of information in ASCII character form. 
Each text file is a sequence of characters grouped into lines, and lines are grouped into 
a sequence of pages. 

All text file .i.Coiumn number$;co!umn numbers, .i.Line numbers;line numbers, and 
.i.Page numbers;page numbers are values of the subtype 
.i.POSmVE_COUNT;POSITIVE_COUNT. 

Note that due to the definitions of line terminator, page terminator, and file terminator 
in the RM , and the method used to mark the end of file under 286 DOS, some ASCII 
files do not represent well-formed TEXT_IO files. 

A text file is buffered by the .i.Runtime Executive;Runtime Executive unless 

■ it names a device, as indicated by the table ADA@DEV_IOCTL. Refer to 
the accompanying Cross Development Guide for details. 

■ it is STANDARD_INPUT or STANDARD_OUTPUT and is the console 
input or output device, as designated in the table ADA@DEV_IOCTL. 

If the standard 10 files are mapped to the console, prompts written to 
STANDARD__OUTPUT with the procedure PUT will appear before (or when) a GET 
(or GET_LINE) occurs. 


Appendix F, Implementation-Dependent Characteristics 


31 









The functions END_OF_PAGE and END_OF_FILE always return FALSE when the 
file is a device, which includes the use of STANDARD_INPUT when it corresponds to 
the console input device. Programs which would like to check for end of file when the 
file may be a device should handle the exception END_ERROR instead, as in the fol¬ 
lowing example: 


Example 

begin 

loop 

-- Display the prompt: 

TEXT_IO.PUT (•--> "); 

-- Read the next line: 

TEXT_IO.GET_LINE (COMMAND, LAST); 

-- Now do something with COMMAND (1 .. LAST) 
end loop; 
exception 

when TEXT_IO.END_ERROR «> 
null; 


END_ERROR is raised for STANDARD_INPUT when A Z (ASCII.SUB) is entered 
through the console input device. 


8.6 The Need to Close a File Explicitly 

The Runtime Executive will flush all buffers and close all open files when the program is 
terminated, either normally or through some exception. 

However, the RM does not define what happens when a program terminates without 
closing all the opened files. Thus a program which depends on this feature of the 
Runtime Executive might have problems when ported to another system. 


8.7 Limitation on the procedure RESET 

An internal file opened for input cannot be RESET for output. However, an internal 
file opened for output can be RESET for input, and can subsequently be RESET back 
to output. 


* 8.10 Sharing of External Files and Tasking Issues 

Several internal files can be associated with the same external file only if all the internal 
files are opened with mode IN_MODE. However, if a file is opened with mode 
OUT_MODE and then changed to IN_MODE with the RESET procedure, it cannot be 
shared. 


32 


Alsys i80x86 Ada Cross Compilation System, Appendix F, Version 4.2 






Care should be taken when performing multiple input-output operations on an external 
file during tasking because the order of calls to the I/O primitives is unpredictable. For 
example, two strings output by TEXT_IO.PUT_LINE in two different tasks may ap¬ 
pear in the output file with interleaved characters. Synchronization of I/O in cases such 
as this is the user’s responsibility. 

The TEXT_IO files STANDARD_INPUT and STANDARD_OUTPUT are shared by 
all tasks of an Ada program. 

If TEXT_IO.STANDARD_INPUT corresponds to the console input device, it will not 
block a program on input. All tasks not waiting for input will continue running. 

9 Characteristics of Numeric Types 

9.1 Integer Types 

The ranges of values for integer types declared in package STANDARD are as follows: 
SHORTJNTEGER -128 .. 127 -- 2**7 - 1 

INTEGER -32768 .. 32767 - 2**15 - 1 

IONGJNTEGER -2147483648 .. 2147483647 — 2**31 - 1 

For the packages DIRECT_IO and TEXT_IO, the range of values for types COUNT 
and POSITIVE_COUNT are as follows: 

COUNT 0 .. 2147483647 - 2**31 - 1 

POSITIVE_COUNT 1 .. 2147483647 -- 2**31 - 1 

For the package TEXT_lO, the range of values for the type FIELD is as follows: 

FIELD 0 .. 255 -- 2**8 - 1 

9.2 Floating Point Type Attributes 

FLOAT LONG FLOAT 


OtGITS 

6 * 

15 

MANTISSA 

21 

51 

EMAX 

84 

204 

EPSILON 

9.53674E-07 

8.88178E-16 

LARGE 

1.934286*25 

2.57110E*61 


Appendix F. Implementation-Dependent Characteristics 


33 








SAFE_EMAX 

125 

1021 

SAFE_SNALL 

1.17549E-38 

2.22507E-308 

SAFE_LfRG£ 

4.25353E*37 

2.24712E+307 

FIRST 

-3.40282E+38 

-1.79769E*308 

LAST 

3.40282E+38 

1.79769E-308 

MACH IME_RAD1X 

2 

2 

MACHINE_EHAX 

128 

10?4 

MACHINE_EMIN 

-125 

-1021 

MACH INE_R0UNDS 

true 

true 

MACH INE_0VERFLOWS 

false 

false 

SIZE 

32 

64 

Attributes of Type DURATION 


DURATION'DELTA 

2.0 *• (-14) 


DURATION•SMALL 

2.0 •* (-14) 


DURATION'FIRST 

-131J372.0 


DURATION'LAST 

131JJ72.0 


DURATION'LARGE 

same as DURATI ON•LAST 



10 Other Implementation-Dependent Characteristics 

10.1 Use of the Floating-Point Coprocessor (80287) 

Floating point coprocessor (8087 or 80287 chip) instructions are used in programs that 
perform arithmetic on floating point values in some fixed point operations and when the 
*FLOAT_IO or FIXED_IO packages of TEXT_IO are used. The mantissa of a fixed 
point value may be obtained through a conversion to an appropriate integer type. This 
conversion does not use floating point operations. Programs using floating point 
instructions require either an 8087 coprocessor or an 80287 coprocessor, alternatively, for 
code running on an 80/86, 80286 or 80386 processor, the 8028*’ software emulation 
library provided with the Compiler can be used. Note that object code running on an 
8086 or 8088 does require an 8087 coprocessor, since 8087 software emulation is not 
supported. See Appendix D of the Application Developer's Guide for more details. 


34 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 





The Runtime Executive will detect the absence of the floating point coprocessor if it is 
required by a program and will raise CONSTRAlNT_ERROR. 


10.2 Characteristics of the Heap 

All objects created by allocators go into the heap. Also, portions of the Runtime Execu¬ 
tive representation of task objects, including the task stacks, are allocated in the heap. 

UNCHECKED_DEALLOCATION is implemented for ail Ada access objects except 
access objects to tasks. Use of UNCHECK ED_DEALL0CAT10N on a task object will 
lead to unpredictable results. 

All objects whose visibility is linked to a subprogram, task body, or block have their 
storage reclaimed at exit, whether the exit is normal or due to an exception. Effectively 
pragma CONTROLLED is automatically applied to all access types. Moreover, all com¬ 
piler temporaries on the heap (generated by such operations as function calls returning 
unconstrained arrays, or many concatenations) allocated in a scope are deallocated upon 
leaving the scope. 

Note that the programmer may force heap reclamation of temporaries associated with 
any statements by enclosing the statement in a begin .. end block. This is especially 
useful when complex concatenations or other heap-intensive operations are performed in 
loops, and can reduce or eliminate STORAGE_ERRORs that might otherwise occur. 

The maximum size of the heap is limited only by available memory. This includes the 
amount of physical memory (RAM) and the amount of virtual memory (hard disk swap 
space). 


10.3 Characteristics of Tasks 


Normal priority rules are followed for preemption, where PRIORITY values are in the 
range 1 .. 10. A task with undefined priority (no pragma PRIORITY) is considered to 
be lower than priority 1. 

The maximum number of active tasks is restricted only by memory usage. 

The accepter of a rendezvous executes the accept body code in its own stack. Ren¬ 
dezvous with an empty accept body (for synchronization) does not cause a context 
switch. 

'The main program waits for completion of ail tasks dependent upon library packages 
before terminating. 

Abnormal completion of an aborted task takes place immediately, except when the ab¬ 
normal task is the caller of an entry that is engaged in a rendezvous, or if it is in the 
process of activating some tasks. Any such task becomes abnormally completed as soon 
as the state in question is exited. 


Appendix F, Implementation-Dependent Characteristics 


35 






The message 

GLOBAL BLOCKING SITUATION OETECTEO 

is printed to STANDARD_OUTPUT when theRuntime Executive detects that no 
further progress is possible for any task in the program. The execution of the program 
is then abandoned. 

10.4 Definition of a Main Subprogram 

A library unit can be used as a main subprogram if and only if it is a procedure that is 
not generic and that has no formal parameters. 

10.5 Ordering of Compilation Units 

The Alsys i80x86 Ada Cross Compilation System imposes no additional ordering 
constraints on compilations beyond those required by the language. 

11 Limitations 

11.1 Compiler Limitations 

■ The maximum identifier length is 255 characters. 

■ The maximum line length is 255 characters. 

■ The maximum number of unique identifiers per compilation unit is 2500. 

■ The maximum number of compilation units in a library is 1000. 
a The maximum number of Ada libraries in a family is 15. 

11.2 Hardware Related Limitations 

a The maximum size of the generated code for a single compilation unit is 
65535 bytes. 

a The maximum size of a single array or record object is 65522 bytes. An 
object bigger than 4096 bytes will be indirectly allocated. Refer to 
ALLOCATION parameter in the COMPILE command. (Section 4.2 of the 
User's Guide.) 

a The maximum size of a single stack frame is 32766 bytes, including the data 
for inner package subunits unnested to the parent frame. 


36 Alsys i80x86 Ada Cross Compilation System. Appendix F, Version 4.2 





■ The maximum amount of data in the global data area is 65535 bytes, in¬ 
cluding compiler generated data that goes into the GDA (about 8 bytes per 
compilation unit plus 4 bytes per externally visible subprogram). 

■ The maximum amount of data in the heap is limited only by available mem¬ 
ory, real and virtual. 

■ If an unconstrained record type can have objects exceeding 4096 bytes, the 
type is not permitted (unless constrained) as the element type in the 
definition of an array or record type. 


Appendix F, Implementation-Dependent Characteristics 


37 







INDEX 


80287 34 
8087 34 

Abnormal completion 35 
Aborted task 35 
Access types 15 
Allocators 35 

Application Developer’s Guide 2 
Array gaps 17 
Array objects 28 
Array subtype 4 

Array subtype and object size 19 
Array type 4 

ARRAY_DESCRIPTOR 26 
Attribute 4 
ASSEMBLER 2 
ASS1GN_T0_ADDRESS 7 
Attributes of type DURATION 34 

Basic record structure 20 
Binder 35 
Buffered files 31 
Buffers 

flushing 32 

C 2 

Characteristics of tasks 35 
Collection size 15 
Collections 15 
Compiler limitations 36 

maximum identifier length 36 
maximum line length 36 
maximum number of Ada libraries 
36 

maximum number of compilation 
units 36 

maximum number of unique 
identifiers 36 
Constrained types 
I/O on 31 

CONSTRAlNT_ERROR 35 
Control Z 32 
COUNT 33 
CREATE 31 

DIGITS 33 


Direct files 31 
DIRECT_IO 30, 31, 33 
DURATION’DELTA 34 
DURATIONTIRST 34 
DURATION’LARGE 34 
DURATION’LAST 34 
DURATION’SMALL 34 

E’EXCEPTION_CODE 4 
EMAX 33 

Empty accept body 35 
END_ERROR 32 
END_OF_FILE 32 
END_OF_PAGE 32 
Enumeration literal encoding 8 
Enumeration subtype size 9 
Enumeration types 8 
EPSILON 33 
EXCEPTION_CODE 
Attribute 4 

FETCH_FROM_ADDRESS 7 
FIELD 33 
File closing 
explicit 32 
File terminator 31 
FIRST 34 

Fixed point type representation 13 
Fixed point.type size 14 
Floating point coprocessor 34 
Floating point type attributes 33 
Floating point type representation 12 
Floating point type size 13 

GET 31 
GET_LINE 31 

GLOBAL BLOCKING SITUATION 
DETECTED 36 

Hardware limitations 

maximum amount of data in the 
global data area 37 
maximum data in the heap 37 
maximum size of a single array or 
record object 36 


38 


Alsys i80x86 Ada Cross Compilation System. Appendix F, Version 4.2 









* 


maximum size of a single stack frame 
36 

maximum size of the generated code 
36 

Hardware related limitations 36 
Heap 35 

I/O synchronization 33 
Implementation generated names 28 
Implicit component 26, 27 
Implicit components 24 
IN_MODE 32 
INDENT 4 

Indirect record components 21 
INTEGER 33 

Integer type and object size 11 
Integer type representation 10 
Integer types 33 
Intel object module format 3 
INTERFACE 2, 3 
INTERFACE_NAME 2, 3 
Interleaved characters 33 
IO_EXCEPTIONS 30 

IS_ARRAY 

Attribute 4 

LARGE 33 
LAST 34 

Layout of a record 20 
Library unit 36 
Limitations 36 
Line terminator 31 
LONG_INTEGER 33 
LOW_LEVEL_IO 30 

MACHINE_EMAX 34 
MACHINE_EMIN 34 
MACHINE_MANTISSA 34 
MACHINE_OVERFLOWS 34 
MACHINE_RADIX 34 
MACHINE_ROUNDS 34 
Main program 35 
Main subprogram 36 
• MANTISSA 33 

Maximum amount of data in the global 
data area 37 

Maximum data in the heap 37 
Maximum identifier length 36 
Maximum line length 36 
Maximum number of Ada libraries 36 


Maximum number of compilation units 
36 

Maximum number of unique identifiers 
36 

Maximum size of a single array or 
record object 36 

Maximum size of a single stack frame 
36 

Maximum size of the generated code 36 

Non-blocking I/O 33 
Number of active tasks 35 

OPEN 31 

Ordering of compilation units 36 
OUT_MODE 32 

P*ARRAY_DESCRIPTOR 4 
P’IS_ARRAY 4 
P’RECORD_DESCRIPTOR 4 
PACK 4 

Page terminator 31 
Parameter passing 1 
POSITIVE_COUNT 31, 33 
Pragma IMPROVE 4, 27 
Pragma INDENT 4 
Pragma INTERFACE 2, 3 
Pragma INTERFACE_NAME 2, 3 
Pragma PACK 4, 17, 21 
Pragma PRIORITY 4, 35 
Pragma SUPPRESS 4 
Predefined packages 28 
PRIORITY 4, 35 
PUT 31 
PUT_LINE 33 

Record objects 28 
RECORD_DESCRIPTOR 
Attribute 4 

RECORD_DESCRlTPOR 27 
RECORD_SIZE 25, 27 
Rendezvous 35 
Representation clauses 8 
RESET 32 

Runtime Executive 1, 3, 32, 35, 36 

SAFE_EMAX 34 
SAFE_LARGE 34 
SAFE__SMALL 34 
Sequential files 31 
SEQUENTIAL_I0 30 


Index 


39 











Sharing of external files 32 
SHORT_INTEGER 33 
SIZE 34 

Size of record types 28 
SPACE 27 

STANDARD_1NPUT 31. 32, 33 
STANDARD_OUTPUT 31, 33, 36 
Storage reclamation at exit 35 
STORAGE_SIZE 16 
Stream file 31 
SUPPRESS 4 
Synchronization of I/O 33 
SYSTEM 4 

Task activation 16 
Task stack size 16, 35 
Task stacks 35 
Task types 16 
Tasking issues 32 
Tasks 

characteristics of 35 
Text file 

buffered 31 
Text files 31 
TEXT__IO 30, 33 
TIME 27 

Unchecked conversions 30 
UNCHECKED_DEALLOCATION 35 
USE_ERROR 31 

Variant part 25 

VARIANT INDEX 25, 26, 27 


40 


Alsys i80x86 Ada Cross Compilation System. Appendix F. Version 4.2 





