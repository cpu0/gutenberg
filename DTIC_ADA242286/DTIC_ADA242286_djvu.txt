

REPOI AD-A242 286 GE 


PuMe rapofttiQ tor Mi cQlKria 

ntiM fVfiMinQ fho cQlMiM of 
Hiod 9 MriM Strvteo^ Dkocioniolor In 

1. AifeNiY us^'is^v riMM a«5r 


ii 


FomAppmwd 
OPM No. 0704-0180 



lor iwMig Inanctton^ «mrM« «Mno dM aeuioH gMhMng aid nMMig »M dw 
iadiacolicdOBO<ltdiinnalDt»tidui*igiHBiidiirilotioduclngtilobi»diii.ttWiih>ndon 
Mn^ VA 22!atM02L and to «M Odico el MHinMIan ond ItagMoiy Miit, Ollco a 


rfiiRSjpfBA^r"' 


'^iniXii455bSTiTll " " ' 

Alsys, Inc., AlsyCOMP_003 Version 5.1, Zenith Z-248-50 (Host & Target), 
901102W1.11059 


i. RS^JfiT WAS A^6 bA+fis covEfteb 
Final; 02 Nov 1990 to 01 Jun 1993 

S. FUNDING NUMBERS 


o s Tas R ;^ )- 

Wright-Patterson AFB, Dayton, OH 
USA 


tme 


7 . p^hFbhMiNb organization i^d(S) and aodAess(^) 

Ada Validation Facility, Language Control Facility ASO/SCELv 
BkJg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 


Ik- ' 


‘r.f 


1 V O V 


<'T r 

iS'Ji 


"i: 


9. SPOMSOniNGAllONITORING AGENCY NAME(S) AND A00RESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 

11. Suf»PLfeMfef4TAftY 



ING ORGANIZATION 
NUMBER 

AVF-VSR-413-0891 


10. Sr>ONs6RINGAilONltoRING AGENCY 
REPORT NUMBER 


I'V.i c ‘^o 


6^ ^ 


< V • 


II 


Lj-i... '■i-u'v <i i.-:)I lo (.'■ \ p <~-r Z-c, 

/ ^ /H{ 


IZa. Ol^fll6uTION/AVAILABILrTY STAT^M^ 

App.'oved for public release; distribution unlimited. 


12b. OISTRIBUtlON CODE 


13. ABSri^ct (Maximum 200 words) 

Alsys, Inc., AlsyCOMP_003 Version 5.1, Wright-Patterson AFB, OH, Zenith Z-248-50 (Host & Target), ACVC 1.11. 


91-15051 


U.SUBJECf TEMliiS 

Ada programming language, Ada Compiler Vai. Summary Report, Ada Ckrmpiler Val. 
Capability, Val. Testing, Ada Vai. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 

rif.5KuftW&>5S'lfl4ATid)N lii.SKbfiiT7<l:DiSiF*icAyt6N i io. s^ftifv dUiiSIPidAffIt' 

OF REPORT 

UNCLASSIFIED 


ii! SKbfiiT7cLASsiF*icAyt6N 
UNCLASSIFED 


19. SECURITY ClAS 
OF ABSTRACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 


1 S. PRICE CODE 

io. uMrf atIon of aiH^MST 


NSN 7540.01-280-550 


9l 1104 122 


standard Fom 298, (Rav. 2-89) 
Praacribad by ANSI Sid. 239-128 







AVF Control Number: AVF-VSR-413-0891 

23-August-1991 

90-06-01-ALS 


Ada CCMPILER 
VALIDATKXt SUMMARY REPORT: 
Certificate Number: 901102W1,11059 
Alsys, Inc. 

AlsyCOMP 003 Version 5.1 
Zenith 2-248-50 -> Zenith Z-248-50 


Prepared By: 

Ada Validation Facility 
ASO/SCEL 

Wright-Patterson AFB OH 45433-6503 




Certificate Information 


The following Ada implementation was tested cmd determined to pass ACVC 
1.11. Testing was conpleted on 2 November 1990. 

Compiler Name and Version: AlsyCCMP_003, Version 5.1 

Host Computer System: Zenith Z-248-50 (under MS/DOS 3.30) 

Target Cooputer System: Zenith Z-248-50 (under HS/DOS 3.30) 

Custcsner Agreement Number: 90-06-01-AI.S 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this v 2 didation effort. Validation Certificate 
901102W1.11059 is awarded to Alsys, Inc. This certificate expires on 1 
June 1993. 

This report has been reviewed and is approved. 



Steven P. Wilson 
Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


Ada Valid^iOT Organization 

Director, Computer & Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 







DECLARATION OF CONFORMANCE 


CUSTOMER: 

ADA VAUDAIION FAClli i V: 

ACVC VERSION! 

ADA IMPLEMENTA'llON: 

COMPILER NAME AND V ERSiON: 
HOST COMPUTER SYSTEM: 

TARGET COMPim-R SYS'rEM: 


Alsys,Inc. 


Ada Validation Facility (ASD/SCEL) 
Computer Opetations Division 
Infonnation Sysmms and Teciutology Center 
Wright-Pattenon AFB OH 45433-6503 


1.11 


ALSYS_COMP_C03-ADA 

Zenith Zr24S Model 50 
under MS/DOS 3.30 

Zenith Z-24S Model 50 
under MS/DOS 330 


CUSTOMER’S DECLARATION: 

L Qie uideisigned, leprcsentisg .Msys, Inc., dcdaie diat A]sys» Inc, has n o knowledge o£ 
lietr iatirtiiic finoo ttie Adi Language Standard ANSI/MUrSl'D-lSlSA in tbe 
iS|deaientation listed in this dcclututiou. 

Nfike Blanchette, Date 

Vice President, Enginecr'Jig 

Alsya,Inc. 

67 &uth Bedford Stiect 
Burlington, MA 0i80j-.'S i 52 




TABLE OF CONTENTS 


CHAPTER 1 INTRCXXJCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WIIHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MC»IFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 














CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national lavs of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions Identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 




INTRODUCTION 


1.2 REFERENCES 


[Ada83] Reference Manual for the Ada Programming Language, 

ANSI/NIL-STD-1815A, FeEruary 1985 and ISO 8652-1^87. 

[Pro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint Program 
Office, August 19^0. 

[UG89] Ada Compiler Validation Capability User's Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing^ is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 


INTRODUCTION 


For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 






INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host ConfJuter 
System 

Inapplicable 

test 

ISO 

Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Inplementation 

Validation 


Withdravm 

test 


Fulfillment by a product, process or service of adl 
requirements specified. 

An individued or corporate entity who enters into am 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 


A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevzmt for the given Ada inplementation. 

International Organization for Standardization. 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
ccxnplete hardware implementations are possible. 

A computer system where the executzdsle form of Ada programs 
are executed. 


Ihe compiler of a validated Ada implementation. 


An Ada inplementatlon that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

Ihe process of. checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this ii^lementation. 

A test found to be incorrect aivi not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 



CHAPTER 2 


IMPLEMENTATICX4 DEPENDENCIES 


2.1 WITHDRANN TESTS 

The following tests have been withdrawn by the AVO, The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of witMrawn tests is 12 October 1990. 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C7430aA 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C83041A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BO8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CESllSA 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 




addition to 

the tests 

indicated above 

, C35702A was withdrawn 

as a result 


of a challenge by this customer; it was included in the subsequent list of 
withdrawn tests, dated 21 November 1990. 


2.2 INAPPLICABLE TESTS 

A tisst is inapplicable if it contains test objectives which are irrelevant 
for a given isqplementation. Reasons for a test's inapplicability may 
be supported by documents issued by ISO and the AJPO known as Ada 
Coinaentaries and ccnmonly referenced, in the format Al-dckidd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
a{^ropriate. 


2-1 



IMPLEHENIATION DEPEMiENCIES 


Hie following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_piGlTS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L.,Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 

C45241L..Y (14 tests) C45321L..Y"(14 tests) 

C45421L..Y (14 tests) C45521L..Z (15 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 

C35404D, C45231D, B86001X, C86006E, and CD7101G check for a predefined 
integer type with a name other than INTEGER, U»K3_INTEGER, or 
SHORT_INTEGER. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LGNS_FLC1A.T, or SHORT_FLQAT. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX__MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain 'SMALL 
representation clauses vdiich are not powers of two. 

G)2A53A checks operations of a fixed-point type for which a length 
clause specifies a power-of-ten TYPE'SMALL; this inplementation does not 
support decimal 'SMALLs. (See section 2.3.) 

C45624A checks that the proper exception is raised if MACHINEJTVERFLCWS 
is FALSE for floating point types with digits 5. For this 
implonentation, HACHINEjTVEEtFLaHS is TRUE. 

C45624B checks that the proper exception is raised if HACHINEjOVERFLaws 
is FALSE for floating point types with digits 6. For this 
inpleroentation, MACMINEjOVERFLCWS is TRUE. 

C86001F recon?)iles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. 

C96005B checks for values of type DURATIW'BASE that are outside the 
range of DURATION. There are no such values for this implementation. 

CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2a 84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 

B86001Y checks for a predefined fixed-point type other than DURATION. 


2-2 






IMPLEMENTATION DEPENDENCIES 


BD8001A, BD8003A, BD8004A. .B (2 tests) . and AD8011A use machine ccxie 
insertions. 

The tests listed in the following table are not applicadale becaxase the 
given file operations are supported for the given combination of mode 
and file access method. 


Test 

File Operation Itode 

File Access Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INCUT FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OOT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT_FILE 

DIRECT_I0 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT_IO 


The tests listed in the following table are not appliceJale because the 
given file operations are not supported for the given combination of 
mode and file access method. 

Test File Operation Mode File Access Method 


CE2105A CREATE IN_FILE SEQUENTIAL_IO 

CE2105B CREATE IN_FILE DIRECT_IO 

CE3109A CREATE IN_FILE TEXT_IO 

The following 16 tests check operations on sequential, direct, and text 
files when multiple internal files are associated with the same external 
file and one or more are open for writing; USE_ERROR is raised when this 
association is attempted. 


CE2107B..E CE2107G..H CE2107L CD2110B CE2110D 

CE2111D CE2111H CE3111B CE3111D..E CE3114B 

CE3115A 

CE2111C raises a USE_ERROR vrtien file is RESET from IN^FILE to CX3T_FILE. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for SEQUS4TIAL_I0. This implementation does 
not restrict file capacity. 


2-3 


IMPLEMENTATION DEPENDENCIES 


EE2401D and EE2401G use instantiations of package DIRECT_IO with 
unconstrained array types and record types with discriminants without 
defaults. These instantiations are rejected by this conpiler. 

CE2401H raises USE_ERROR when CREATE with mode INOtrr_FILE is used for 
unconstrained records with default discriminants. 

CE2403A checks that WRITE raises USE_ERR0R if the capacity of the 
external file is exceeded for DIRECT_IO. This implementation does not 
restrict file capacity. 

CE3304A checks that USE_ERROR is raised if a call to SET LINE LENGTH or 
SET_PAGE LENGTH specifies a value that is inappropriate lot tEe external 
file. THis inplementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAyOUT_ERROR when the value of the page 
number exceeds COUNT'LAST. For this inplementation, the value of 
COUNT'LAST is greater than 150000 making the checking of this objective 
impractical. 


2.3 TEST MODIFICATICWS 


Modifications (see section 1.3) were required for 24 tests. 


The following tests were split into two or more tests because this 
inplementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 


B23004A 

B28003A 

B61012A 

BC2001D 


B24007A 

B32202A 

B91004A 

BC3009A 


B24009A 

B32202B 

B95069A 

BC3009C 


B25002A 

B32202C 

B95069B 


B26005A 

B37004A 

B97103E 


B2700SA 

B45102A 

BAllOlB 


BA2001E was graded passed by Evaluation Modification as directed by the 
AVO. The test expects that duplicate names of subunits with a common 
ancestor will be detected as compilation errors; this inplementation 
detects the errors at link time, and the AVO ruled that this behavior is 
acceptable. 


CD2A53A was graded inapplicable by Evaluation Modification as directed by 
the AVO. The test contains a specification of a power-of-10 value as small 
for a fixed-point type. The AVO ruled that, under ACVC 1.11, support of 
decimal smalls may be omitted. 


EA3004D was graded passed by Evaluation and Processing Modification as 
directed by the AVO. The test requires that either pragma INLINE is obeyed 
for a fionction call in each of three contexts and that thus three library 
units are made obsolete by the re-compilation of the inlined function's 
body, or else the pragma is ignored completely. This implementation obeys 


2-4 . 




IMPLEMENTATION DEFE3CEMCIES 


the pragma except v4ien the call is within the package specification. When 
the test's files are processed in the given order, only two \anits are made 
obsolete; thus, the expected error at line 27 of file EA3004D6M is not 
valid and is not flagged. To confirm that indeed the pragma is not obeyed 
in this one case, the test was also processed with the files re-ordered so 
that the re-conpilation follows only the package declaration (and thus the 
other library \mits will not be made obsolete, as they are conpiled later); 
a "NOT APPLICABLE" result was produced, as expected. The revised order of 
files was 0-1-4-5-2-3-6. 


2-5 



r 


CHAPTE21 3 

PRCXrESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada in?)leiBentation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information eibout this Ada 
implementation system, see: 

Mike Blanchette 
67 South Bedford Street 
Burlington MA 01803-5152 

For a point of contact for sales information about this Ada implementation 
system, see: 


Mike Blanchette 
67 South Bedford Street 
Burlington HA 01803-5152 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
L 2 uiguage Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 




PROCESSING INFORMATIOI 


a) Total Number of i^licable Tests 3805 

b) Total Number of Withdrawn Tests 82 

c) Processed Inapplicable Tests 82 

d) Non-Processed I/O Tests 0 

e) Non-Prbcessed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 283 


g) Total Number of Tests for ACVC 1.11 4170 


All I/O tests of the test suite were processed because this implementation 
supports a file system. The above number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the inplementation. When this compiler was test^, the tests 
listed in section 2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the vali^tion team for processing. The contents of the 
magnetic tape were loaded onto a VAX/VMS system and then transferred to the 
host computer via a FTP LAN network. 

After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada inplementation. 

Testing was performed using command scripts provided by the customer and 
reviewi^ by the v 2 didation team. See ippendix B for a complete listing of 
the processing options for this implementation. The options invoked 
explicitly for validation testing during this test were: 


OPTION/SWITCH 

EFFECT 

SHOW -> NO 

Do not show header nor error 
summary in listing. 

WARNING -> NO 

Do not include warning messages. 

GENERIC -> STUB 

Place code of generic instantiation 
in separate subunits. 

ERROR -> 999 

Neucimum number of compilation errors 
permitted before terminating the 
compilation. 

CALLS -> INLINED 

This option allows insertion of code for 
sxibprograms inline eind must be set for 
the pragma INLINE to be operative. 


3-2 




PROCESSING INfORMATION 


NODULE -> \alsys\duinnyes.obj 

Required by run-time library. 


Test output, conpiler and linker listings, and job logs vfere captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG891. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$BIG_ID1 (1..V-1 => 'A', V => '1') 

$BIG_ID2 (1..V-1 «> 'A', V *> '2') 

$BIG ID3 <l..V/2 .> 'A') & '3' & 

(1..V-1-V/2 .> 'A') 

$BIG_ID4 <1..V/Z -> 'A') & ’t*' & 

(1..V-1-V/2 => 'A') 

SBIG_INT_LIT (1..V-3 -> '0') & "298" 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 & (1..V/2 => 'A') & 

$BIG_STRING2 h (1..V-1-V/2 => 'A') & '1' S. 

$BLANKS (1..V-20 »> ' ') 

SMAX_LEN_INT BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAX LEN REAL_BASED_LITERAL 

"16:" & (1..V-7 «> '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 


A-1 





I 


MACRO PARAMETERS 


The following table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 


SMAX_IN_LEN 

255 

Sacc_size 

32 

Salignment 

2 

$COUNT_LAST 

2147483647 

SDEFAULT_MEM_SIZE 

2**24 

SDEFAULT_STOR_UNIT 

8 

SDEFAULT_SYS_NAME 

180X86 

SDELTA_DOC 

2#1.0#E-31 

SENTRY_ADDRESS 

SYSTEM.VALUE("00010:0040") 

SENTRY_ADDRESS1 

SYSTEM.VALUE("00010:0080") 

SENTRY_ADDRESS2 

SYSTEM.VALUE("00010:0100") 

SFIELD_LAST 

255 

SFILE_TERMINATOR 

t 9 

SFIXED_^NAME 

NO_SUCH_FIXED_TTPE 

SFLOAT_NAME 

NO_SUCH_FLOAT_TYPE 

SFORM_STRING 

tf If 

SF0RM_STRING2 

"CANNOT_RESTRICT_FILE_CAPACITY 

SGREATER THAN DURATION 

75000.0 


SGREATER THANDURATION BASE LAST 

T31073.0 

SGREATER THAN FLOATBASE LAST 

1.50141E+38 

SGREATER THAN FLOATSAFE LARGE 

1.0E3O8 





MACRO PARAMETERS 


$GREATER THAN_SHORT_FLOAT_SAFE_LARGE 

1.0E308 

$HIGH_PR10RITY 10 

SILLEGAL EXTERNAL_PILE NAMEl 

\NODIRECTORY\FILENAME 

SILLEGAL EXTERNAL_FILE_NAME2 

THIS_FILE_NAME_IS_TOO_LONG_FOR_MY_SYSTEM 

$INAPPROPRIATE_LINE_LENGTH 

-1 

$INAPPROPRIATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ('’A28006D1 .TST" ) 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ('•B28006D1.TST") 

SINTEGER^FIRST -32768 

SINTEGER^LAST 32767 

$INTEGER__LAST_PLUS_1 32768 

$INTERFACE_LANGUAGE C 

$LESS_THAN_DURATION -75000.0 

SLESS THAN DURATION BASE FIRST 

-131073.0 

$LINE_TERMINATOR ASCII.CR & ASCII.LF 

SLOWPRIORITY 1 

$MACHINE_CODE_STATEMENT 



NULL; 

$MACHINE_CODE_TYPE 

NOSUCHTYPE 

SMANTISSADOC 

31 

$MAX_DIGITS 

15 

$MAX_INT 

2147483647 

$MAX_INT_PLUS_1 

2147483648 

$MIN INT 

-2147483648 


A-3 









12 05 91 11:11 ©703 oh3 "1.119_ 

AJFi- 

. I U _ > 


MACRO PARAMETERS 




$NAME 

NO_SUCH_TyPE_AVAlLABLE 



$NAME_LIST 

180X86 



$NAME_SPEC1FICAT1'JN1 

D:\VORK\X2120A 



$NAME_SPECIF1CATI0N2 

D:\W0RK'vX2120B 



$NAME_SPECIFICAT10N3 

D:\W0RK\X3119A 



$NEG_^BASED_1NT 

16«F000000E# 



$NEW_MEM_S1ZE 

2**24 



$NEV_STOR_UNIT 

16 



$NEW_SYS_NAME 

180X86 



$PAGE_T£RMINATOR 

ASCII.CR 6 ASCII.LF & ASCII.FF 



$REC0RD_DEF1NITI0N 

NEW INTEGER; 



SRECORD_NAME 

NO_SUCH_MAClilNE_CODE_TYPE 



$TASK_S1ZE 

32 



$TASK_ST0RAGE_S1ZE 

1024 



STICK 

1.0/18.2 



SVARIABLE.AODRESS 

SYSTEM. VALIJE( "0010 r 0020" ) 



$VARIABL£_A0DRESS1 

SYSTEM.VALUEC"0010;OOZA*) 



SVARIABLE_ADDRESS2 

SYSTEM.VALUE("0010:0028") 



5YOUR_PRAGMA 

INTERFACE 




A-4 



14' 7. 'Hi 

'll; t n 1 ' ' 

f - 11'4 . 11 : 






APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


Compile Options 


COMPILE (SOURCE => source_name ( INSTANTIATION, 

LIBRARY => library_name, 

OPTIONS => 

(ANNOTATE => character_string, 

ERRORS »> positive_integer, 

LEVEL => PARSE 1 SEMANTIC | CODE | UPDATE, 

CHECKS »> ALL | STACK | NONE, 

GENERICS «> STUBS | INLINE, 

TASKING -> YES 1 NO, 

MEMORY «> nufflber_of kbytes), 

DISPLAY «> 

(OUTPUT -> SCREEN | NONE | AUTOMATIC | file name, 
WARNING => YES I NO, 

TEXT => YES 1 NO, 

SHOW => BANNER | RECAP | ALL | NONE, 

DETAIL => YES 1 NO, 

ASSEMBLY => CODE | MAP | ALL | NONE), 

ALLOCATION => 

(STACK »> positive_integer), 

IMPROVE -> 

(CALLS => NORMAL | INLINED, 

REDUCTION -> NONE ] PARTIAL | EXTENSIVE, 

EXPRESSIONS -> NONE j PARTIAL j EXTENSIVE); 

KEEP => 

(COPY «> YES i NO, 

DEBUG »> YES | NO, 

TREE => YES 1 NO)); 


B-1 





COMPILATION SYSTEM OPTIONS 


LINKER OPTIONS 

The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 

bind Options 


BIND (PROGRAM => 
LIBRARY => 
OPTIONS => 
(LEVEL 
EXECUTION 
FLOAT 
MATHLIB 
OBJECT 
UNCALLED 
TIMER 
SLICE 

STACK »> 

(MAIN 
TASK 
HISTORY 
HEAP => 

(SIZE 
INCREMENT 
INTERFACE => 
(DIRECTIVES 
MODULES 
SEARCH 

DISPLAY => 
(OUTPUT 
DATA 
WARNING 
KEEP -> 
(DEBUG 
TUNE 


main_program name, 

library_name7 

=> CHECK I BIND | LINK, 

«> EXTENDED 1 PROTECTED, 

-> AUTOMATIC 1 HARDWARE I 
=> 1287 I 1387, 

-> AUTOMATIC I file name, 
«> REMOVE I KEEP, ~ 

-> NORMAL I FAST, 

-> NO I positive_integer), 

=> positive_integer, 

=> positive_integer, 

=> YES I NO), 

=> positive_integer, 

=> positive_integer), 

=> options_for_linker, 

=> file_names, 

=> library names). 


.> SCREEN I NONE | AUTOMATIC 
•> BIND I LINK I ALL | NONE, 
-> YES I NO), 

.> YES I NO, 

=> YES 1 NO)); 


SOFTWARE, 


file name. 


B-2 



APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -32768 .. 32767; 
type SHORT INTEGER is range -128 .. 127; 
type LONG_lNTEGER is range -2147483648 .. 2147483647; 
type FLOAT is digits 6 range 

-2#l.lllllllllllllllllllllll#E+127 .. 

2#1.11111111111111111111111#E+127; 
type SHORT_FLOAT is digits 6 range 

-2#1.11111111111111111111111#E+127 .. 

2#1.11111111111111111111111#E+127; 
type LONG FLOAT is digits 15 range 

2#1.T111111111111111111111111111111111111111111111111111#E1023 .. 
2#l.llllllllllllllllllllllllllllllllllllllllllllllllllll#E1023; 
type NATURAL is Integer range 0..INTEGER'last; 
type DURATION is delta 2#0.00000000000001# range 
-131072.0000 .. 131071.99994; 
type POSITIVE is INTEGER range 1..INTEGER'last; 


end STANDARD; 


C-1 







PRE-RELEASE DOCUMENTATION - OCTOBER 1990 


Alsys FirstAda Development Environment 


APPENDIX F 


Versioa 5 



Copyright 1990 by Alsys 


All rights reserved. No part of this document may be reproduced in any form or by any 
means without permission in writing from Alsys. 


Printed: October 1990 

Alsys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice. Consult Alsys to determine 
whether such changes have been made. 


Al<y(, AdmWorld, AdaProba, AdaXraf, AdsRaformat, AdaMskt, AdaVcrify, AdaCount, and 
AdaSplit art rtfutarad tradamarks of Alsyt. 

Microaolt, MS-DOS, and MS ara ragiatarad tradamarka of Mieroaoft Corporation. 

IBM, PC AT, PS/S, and PC-OOS ara ragiatarad tradamarka of Intamational Buainaaa Machinat 
Corporation. 

INTEL ia a ragiatarad tradamark of Intal Corporation. 




TABLE OF CONTENTS 


APPENDIX F 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

1.3 INTERFACE_NAME 

1.4 INDENT 

1.5 Other Pragmas 


2 Implementation-Dependent Attributes 

Z1 P’lS^ARRAY 

2.2 E’EXCEPTION_CODE 

23 Attributes Used in Record Representation Clause 


3 Specification of the packa je SYSTEM 


4 Support for Representation Clauses 

4.1 Enumeration Types 

4.1.1 Enumeration Literal Encoding 

4.1.2 Enumeration Types and Object Sizes 

4.2 Integer Types 

4.2.1 Integer Type Representation 
4.Z2 Integer Type and Objea Size 

4.3 Floating Point Types 

4.3.1 Floating Point Type Representation 

4.3.2 Floating Point T^ and Object Size 

4.4 Fixed Point Types 

4.4.1 Fixed Point Type Represenution 

4.4.2 Fi xcd Point 1^ and Object Size 


Table of Contents 



43 Access IVp^ Collections 24 

4.6 Task Types 24 

4.7 Array Types 25 

4.7.1 Array Layout and Structure and Pragma PACK 25 

4.7.2 Array Subtype and Object Size 28 

4.8 Record Types 29 

4.8.1 Basic Record Structure 29 

4.8.2 Indirect Components 31 

4.8.3 Implicit Components 34 

4.8.4 Size of Record Types and Objects 38 

5 Conventions for Implementation*Generated Names 39 

6 Address Clauses 41 

6.1 Address Clauses for Objects 41 

6.2 Address Clauses for Program Units 42 

63 Address Clauses for Interrupt Entries 42 

7 Unchecked Conversions 43 

8 Input'Output Packages 45 

8.1 Correspondence between External Files and DOS Files 45 

8.2' Error Handling 46 

8.3 The FORM Parameter 46 

8.4 Sequential Files 47 

8.5 Direa Files 48 

8.6 Text Files 48 

8.7 Access Protection of External Files 49 

8.8 The Need to Qose a File Explicitly 49 

8.9 limitation on the Procedure RESET 49 

8.10 Sharing of External Files and Tasking issues 50 


ii 


Appendix F, Version 5 





9 Characteristics of Numeric l^pes 


51 


9.1 Integer Types 51 

9.2 Floating Point Type Attributes 51 

9.3 Attributes of Ty^ DURATION 52 

10 Other Implementation-Dependent Characteristics 53 

10.1 Use of the Floating-Point Coprocessor 53 

10.2 Characteristics of the Heap 53 

10.3 Characteristics of Tasks 54 

10.4 Definition of a Main Subprogram 55 

10.5 Ordering of Compilation Units 55 

11 Limitations 57 

11.1 Compiler Limitations 57 

11.2 Hardware Related Limitations 57 

INDEX 59 


Table of Contents 




Appendix F, Version 5 







APPENDIX F 


Implementation - Dependent Characteristics 


Hiis appendix summarizes tbe implementation-dependent characteristics of the Alsys 
HistAda Development Environment, i^pendix F is a required part of the Reference 
Manual for the Ada Proffamnung Language (called the RM in this appendix). 

The sections of this appendix are as follows: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and the type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The description of the represenution clauses. 

5. The conventions used for any implementation-generated name denoting im¬ 
plementation-dependent oomponents. 

6. The interpretation of expressions that appear in address clauses, including those 
for interrupts. 

7. Any restrictions on unchecked conversions. 

8. Any implementation-dependent characteristics of the input-output packages. 

9. Charaaeristics of numeric types. 

10. Other implementation-dependent charaaeristics. 

11. Compiler limiutions. 


Implementation-Dependent Characteristics 


I 





The wmcAl^ Runtime Executive Programs or simply Runtime Executive refers to the 
runtime libraiy routines provided for all Ada programs. These routines implement the 
Ada heap, exceptions, tasking conuol, and other utility functions. 

General systems programming notes are given in another document, Vxe Application 
Developer’s Guide (for example, parameter passing conventions needed for interface with 
assembly routines). 


2 


Appendix F, Version 5 


Section 1 


Implementation-Dependent Pragmas 


1.1 INLINE 

Pragma INLINE is fully supported; however, it is not possible to inline a subprogram in a 
declarative part 


1.2 INTERFACE 

Ada programs can interface with subprograms written in Assembler and other languages 
through the use of the predefined pragma INTERFACE and the implemenution-defined 
pragma INTERFACE.NAME. 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of 
the programiniag language for which parameter passing conventions will be generated. 
Pragma INTERFACE takes the form specified in the RM; 

pragma INTERFACE (languagejuane,subpm^tmjuone); 

where, 

■ language juune is ASSEMBLER, ADA, or C 

■ subprogram juime is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language names accepted by pragma INTERFACE are ASSEMBLER, ADA and 
C The full implemenution requiremenu for writing pragma INTERFACE subprograms 
are described in tixAf^Ucation Developer’s Guide. 

The language name used in the pragma INTERFACE does not have to have any 
relationship to the language actually used to write the interfaced subprogram. It is used 
only to tell the Compiler how to generate subprogram calls; that is, what land of 
parameter passing techniques to use. The programmer can interface Ada programs with 
subroutines written in any other (compiled) language by understanding the mechanisms 


Implementation-Dependent Pragmas 


3 








used for parameter passing by the compiler and the corresponding mechatusms of the 
chosen external language. 


13 INTERFACE_NAME 

Pragma INTERFACE_NAME associates the name of the interfaced subprogram with the 
external name of the interfaced subprogram. If pragma INT£RFACE_NAM£ is not used, 
then the two names are assumed to be identical. This pragma takes the form: 

pragma INTERFACE_NAME (subprogram jiame, stringjiteral); 

where, 

■ subprogramjume is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ stringjiteral is the name by which the interfaced subprogram is referred to at link 
time. 

The pragma INTERFACE.NAME is used to identify routines in other languages that are 
not named with legal Ada identifiers. Ada identifiers can only contain letters, digits, or 
underscores, whereas the DOS Linker allows external names to contain other characters, 
for example, the dollar sign (S) or commercial at sign (@). These characten can be 
specified iai^mngjaeral aignment of Uie pragma INTERFACE.NAME. 

The pragma INTERFACE.NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE. (Location resuiaions can be found in seaion 13.9 of the RM.) 
However, the pragma INTERFACE_NAME must always occur after the pragma 
INTERFACE declaration for the interfaced subprogram. 

The stringjiteral of the pragma INTERFACE_NAME is passed through unchanged to the 
DOS object file. The maximum length of the stringJUeral is 40 characters. This limit is 
not checked by the Compiler, but the string is truncated by the Binder to meet the Intel 
objea module format sundard. 

The user must be aware however, that some toob from other vendors do not fully 
support the sundard objea file format and may restria the length of symbob. For 
example, the IBM and Microsoft assemblen silentiy truncate symbob at 31 charaaets. 

The Runtime Executive conuins several external identifiers. All such identifiers begin 
with either the string 'ADA®' or the string ’ADAS®*. Accordingly, names prefixed by 
*ADA®” or *ADAS®* should be avoided by the user. 


¥ 


Appendix F, Version 5 



Example 


package SAMPLE_OATA is 

hinction SAkff LE_DEVICE pC INTEGER) return INTEGER; 
hinction PROCESS^SAMPLEpC; INTEGER) return INTEGER; 
private 

pragma INTERFACE (ASSEMBLER, SAMPLE.DEVICE); 
pragma INTERFACE (ADA, PROCESS.SAMPLE); 

pragma INTERFACE_NAME (SAMPLE_DEVICE, TDEVIOSGET.SAMPLE"); 
end SAMPLE.DATA; 


1.4 INDENT 

Pragma INDENT is only used 'mthAdoReformat. AdaReformat is the Alsys reformatter 
which offers the funaionalities of a pretty-printer in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. The line 

pragma INDENT(OFF); 

axtsesAdoR^armat not to modify the source lines after this pragma, while 
pragma INDENT(ON); 

causes ./4d!aRfybrTnar to resume its actioa after this pragma. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses and records (Chapter 4). 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Section 3). Undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress all checks in a given compi¬ 
lation by the use of the Compiler option CHECKS. (See Chapter 4 of the User's Guide.) 


Implementation-Dependent Pragmas 


5 


Appendix F, Version 5 





Section 2 


Implementation-Dependent Attributes 


2.1 FIS^ARRAY 

For a prefix P that denotes any type or subtype, this attribute yields the value TRUE if P 
is an array type or an array subtype; otherwise, it yields the value FALSE. 


2.2 E'EXCEPnON^rODE 

For a prefix E that ucr. jies an exception name, this attribute yields a value that 
represents the' .w* nul code of the exception. The value of this attribute is of the type 
INTEGER. 


2J Attributes Used in Record Representation Clauses 

In addition to the Representation Attributes of [13.7.2] and [13.73], the following 
attributes are used to form names of indirect and implicii co m p on ents for use in record 
representation clauses, as described in Section 4.8. 

'OFFSET 

'RECORD.SIZE 

’VARIANT_INDEX 

'ARRAY.DESCRIPTOR 

’RECORD_DESCR1PTION 


Implementation-Dependent Attributes 


7 




Appendix F, Version 5 




Section 3 


Specification of the package SYSTEM 


The implementation does not allow the recompilation of package SYSTEM. 


package SYSTEM is 


*««*«*««♦«**«******««**««•*«• 

* (1) Required Definitions, • 


type NAME is (180X86); 

SYSTEM_HAME : constant NAME 180X86; 

STORACEJIMIT : constant :« 8; 
MEMOnr^StZE : conatwit :« 2^4; 

*■ Systcnt'Oepandent Named Numbers: 
MAX_INT : constant :* 2**31 - 1; 

MINJNT ; constant :» - (2**31); 

MAX_NANT{SSA : constant :x 31; 

FINE.DELTA ; constant :» 2«1.0«E-31; 

NAX_DIGITS : constant IS; 


-- For the high-resolution timer, the clock resolution is 
-- 1.0 / 1024.0. 

TICK : constant :« 1.0 / 18.2; 


Specification of the package SYSTEM 


9 



other Systear Dependent Delceretions: 
subtype PRlORirr is INTEGER range 1 .. 10; 

-- The type ADDRESS is, in fact, implemented as a 
-- segment:offset pair, 
type ADDRESS is private; 

NULL_ADDRESS : constant ADDRESS; 


(2) Operations on Address * 


-- VALUE converts a string to an address. The syntax of the string and its 
-• meaning are target dependent. 

*■ Tor the 8086, 80186 and 80286 the syntax is: 

•• "SSSS.'OOOO" uhere SSSS and 0000 are a A digit or less hexadecimal 
nuaber representing a segment value and an offset. 

The physical address corresponding to SSSS:OQOO dependents 
on the execution mode. In real mode it is 16*SSSS'KXXX>. 

In protected mode the value SSSS represents a sepaent 
descriptor. 

-- Example: 

"0014:00F0" 


-- The exception CONSTRAINT_ERROR is raised if the string does not have 
-- the proper syntax. 

function VALUE (LEFT : in STRING) return ADDRESS; 


10 


Appendix F, Kenion 5 




-* IHAGE converts an address to a string. The syntax of the returned string 
-• is described in the VALUE function. 

subtype A0DRESS_STR1NG is STR1NG(1..9); 

fixation IHAGE (LEFT : in ADDRESS) return ADDRESS_STRIMG; 


-- SAHE_SEGMENT returns true if the two addresses have 
'■ the saaie segment value. 

function SAME_SEGHENT (LEFT, RIGHT ; in ADDRESS) return BOOLEAM; 


The following routines provide support to perform address 
-• computation. For the “+“ and operators the OFFSET parameter 
-- is added to, or subtracted from the offset part of the address, 
-- the segment resaining untouched. 

type OFFSET is rwige 0 .. 2**16 -1; 


-- The exeoeption AODRESS_ERROR is raised by “<", 

-- if the two addresses do not have rhe same segment value. 

-- The exception CONSTRAINT_ERROR con be raised by and 

AOORES$_ERROR : exception; 

function ••+" (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

function (LEFT : in OFFSET; RIGHT : in ADDRESS) return ADDRESS; 

function (LEFT ; in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 


Specification of the package SYSTEM 


11 


-- The exception AOORESS_ERROR is raised if the tuo addresses do 
— not have the seew sapaent vetue. 

function <*-" (LEfT : in ADDRESS; RIGHT : in ADDRESS) return OFfSET; 

*■ Perform an unsigned cosparison on offset part of addresses. 

function "**" (LEFT. RIGHT : in ADDRESS) return BOOLEAN; 

function ■*<» (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function ">«" (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function "mod* (LEFT : in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


-- Returns the given address rounded to a specific value. 


type RaUNO_DlRECTION is (DOUH. UP); 

function ROUND (VALUE : in ADDRESS; 

DlREaiOH ; in RCUNO.OIRECTION; 

NODUUUS : in POSITIVE) return ADDRESS; 


-- These routines are provided to perform READ/URITE operation 
•* in memory. 

-- Uarning: These routines will give unexpected results if used with 
-- unconstrained types. 

generic 

type TARGET is private; 

function FETCH_FRaM_ADDRES$ (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASS(GN_TO_AOORESS (A : in ADDRESS; T : in TARGET); 


12 


Appendix F, Version 5 





-- Procedure to copy LENGTH storage unit starting at the address 
— FROH to the address TO. The source and destination may overlap. 
-• OBJECT_LENGTH designates the size of an object in storage units. 

type 08JECT_LENGTH is range 0 .. 2*»16 -1; 
for aBJECT_LENGTH<SIZE use 16; 

procedure HOVE (TO : in AOORESS; 

FRQN : in ADDRESS; 

LENGTH : in OBJECT.LENGTH); 

private 


end SYSTEM; 


Specification of the package SYSTEM 


13 







k 

, .. 


14 


Appendix F, Version 5 





Section 4 


Support for Representation Clauses 


This section explains bow objects are represented and allocated and how it is possible to 
control this using representation clauses. Applicable restrictions on representation 
clauses are also described. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is describe. 

Except in the case of array and record types, the description for each class of type is 
independent of the others. To undeistand the representation of array and record types it 
is necessary to undenund first the representation of their components. 

Apart from implementation defined pragmas, Ada provides three means to conuol the 
size of objects: 

• a (predefined) pragma PACK, applicable to an^ types 
■ a record representation clause 

• a size specification 

For each class of types the efiea of a size specification is described. Interactions among 
size specifications, packing and record representation clauses is described under the 
discussion of array and record types. 

Representation clauses on derived record types or derived tasks types are not supported. 

Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


Support far Representation Clauses 


15 






4.1 Enumeration I^pes 

4.1.1 Enumeration Literal Encoding 

When no enumeration representation clause applies to an enumeration type, the 
internal code associated with an enumeration literal is the position number of the 
enumeration literal Then, for an enumeration type with n elements, the internal codes 
are the integers 0,1,2,, n-1. 

An enumeration representation clause can be provided to specify the value of each 
internal code as described in RM13 J. The Alsjs compiler fiilly implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -2^^.. 2^^-l. 

An enumeration value is always represented by its internal code in the program 
generated by the compiler. 


4.1.2 Enumeration l^pes and Object Sizes 

Mimmumsiattfmtmmimtimsabtjpe 

The minimum passible size of an emaneration subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form. 

A sutic subtype, with a null range has a minimum size of 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m > = 0, L is the 
smallest positive integer such that M < » 2^-1. For m < 0, L is the smallest positive 
integer such that -2^'^ < * m and M < = 2^'*-l. For example: 

type COLOR is (GREEN, BUVCK, WHITE, RED, BLUE, YELLOW); 

- The minimum size of COLOR is 3 bits. 

subfype BLACK_AND_WHITE U COLOR range BLAOC.. WHITE; 

- The minimum size of BLACK.aND.WHTTE is 2 bits. 


16 


Appendix F, Version 5 


subtype BLACK.OR^WHTTE U BLACK_AND_WHITE nose X.. X; 

- Assuming that X is not sutic, the minimum size of BLACX_OR_WHITE is 

- 2 bits (the same as the minimum size of its type mark BLACK_AND_WHITE). 


Size ef an enumeration subtype 

When no size specification is applied to an enumeration type or first named subtype, the 
objects of that type or first named subtype are represented as signed machine integers. 
The machine provides 8,16 and 32 bit integers, and the compiler selects automatically 
the smallest signed machine integer which can hold each of the internal codes of the 
enumeration type (or subtype). The size of the enumeration type and of any of its 
subtypes is thus 8,16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified the length clause. The same rule applies to a 
first named subtype. The size specification must of course spediy a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

^EXTENDED is 

(- The usual ASCII character set 

NUL, SOH, STX, ETX, KJT. ENQ, ACK. BEL, 

V, y. Y, •{’, r, DEL. 

- Extended characters 

C_CEDILLA_CAP, U_UMLAUT, E_ACUTE, ...); 
f' i EXTENDED-SIZE use 8; 

-- The size of type EXTENDED will be one byte. Its objects will be represented 
- as unsigned 8 bit integers. 

The Alsys compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 


Size the objects tf an enumeration aibtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
objea of an enumeration subtype has the same size as its subtype. 


Support foe Representation Clauses 


17 





4.2 Integer Types 

There are three predefined integer types in the Alsys HistAda implementation: 

type SHORT^INTEGER b range -2**07.. 2**07-l; 

type INTEGER b range-2**15..2**15-1; 

type LONG_INTEGER b range -2**31.. 2**31-1; 

A2.\ Integer lype Representation 
An integer type decbred by a declaration of the form: 
type T b range L.. R; 

is implicitly derived from a predefined integer type. The compiler automatically selects 
the predefined integer type whose range is the smallest that contaiits the values L to R 
inclusive. 

Binary code is used to represent integer values. Negative numbers are represented using 
two’s complement 


4.2.2 Integer Type and Object Size 

Mudmum m tftm irnttg^ nhtypa 

The minimum possible size of an integer subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binary 
form. 

For a static subtype, if it has a null range ib minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > s 0, L is the smallest positive integer such that M < = 2^'^ For m < 
0, L b the smallest positive integer that -2^'^ < » m and M < s 2^'^-l. For example: 

subtype S b INTEGER range 0 „ 7; 

- The minimum size of S is 3 bits. 


18 


Appendix F, Version 5 



subtype D is S range X.. Y; 

- Assuming that X and Y are not static, the minimum size of 

- D is 3 bits (the same as the minimum size of its type mark S). 


Sag of an integer subtype 

The sizes of the predefined integer types SHORT_lNTEGER, INTEGER and 
LONG_INTEGER are respectively 8,16 and 32 bits. 

When no size spedfication is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type 
which it derives, directty or indirectly. For example: 

type S is range 80.. 100; 

- S is derived from SHORTJNTEGER, its size is 8 bits, 
type J is range 0.. 255; 

- J is derived from INTEGER, its size is 16 bits, 
type N te new J range 80 _ 100; 

- N is indirectly derived from INTEGER, its size is 16 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of oouise specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is range 80.. 100; 
rorS'SIZEuse32; 

- S is derived from SHORT_INTEGER, but its size is 32 bits 

- because of the size specification. 

type J is range 0.. 255; 
for J’SIZE use8; 

- J is derived from INTEGER, but its size is 8 bits because 

- of the size specification. 

type N is new J range 80.. 100; 

~ N is indirectly derived from INTEGER, but its size is 

- 8 bits because N inherits the size specification of J. 


Support for Representation Clauses 


19 



Site t^Ute objects an integer sub^fpe 

Provided its sue is not constrained by a record component clause or a pragma PACK, an 
objea of an integer subtype has the same size as its subtype. 


4^ Floating Point Types 

There are three predefined floating point types in the Al^ implementation for 180x86 
machines: 

type SHORT FLOAT is 

digits 6 range -(2.0 - 2.0**(-23))*2.0**127.. (iO - 2.0**(-23))*i0**127; 
type FLOAT is 

digits 6 range -(2.0 - ^0•*(-23))•2.0••l27.. (2.0 - 2.0**(-23))*2.0*»127; 
type LONG_FLOAT is 

digits 15 range -(2.0 - 2.0**(-51))*2.0**1023.. (10 -10**(-51))*10**1023; 
Note that SHORT_FLOAT has the same range as FLOAT. 


43.1 Floating Point type Representation 
A floating point type dedared by a dedaration of the form: 
type T is digits D (range L.. R]; 

is implicitly derived from a predefined floating point type. The compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L to R inclusive. 

In the program generated by the compiler, floating point values are represented using 
the IEEE standard formats for single and double floats. 

The values of the predefined types SHORT_FLOAT and FLOAT are represented using the 
single float format. The values of the predefined type LONG.FLOAT are represented 
using the double float formaL The values of any other floating point type are represented 
in the same way as the values of the predefined type from which it derives, directly or 
indirectly. 


20 


Appendix F, Version 5 





43^ Floating Point Type and Object Size 

The minimum possible size of a floating point subtype is 32 bits if its base type is 
SHORT_FLOAT or FLOAT or a type derived from SHORT_FLOAT or FLOAT, it is 64 bits 
if its base type is LONG_FLOAT or a type derived from LONG_FLOAT. 

The sizes of the predefined floating point types SHORT_FLOAT and FLOAT is 32 bits 
and LONG_FLOAT is 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32 or 64 bits). 

An objea of a floating point subtype has the same size as its subtype. 


4.4 Fixed Point Types 


4.4.1 Fixed Point Type Representation 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by RM 3.5.9. 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

To implement fixed point types, the Alsys First Ada compiler uses a set of anonymous 
predefined types of the form: 

type SHORT_FrXED is delta D range (-2.0**7-l)*S.. 2.0**7*S; 
for SHORT.nXED’SMALL use S; 

type FIXED is delta D range (-2.0**15-1)*S.. 2.0**15*S; 
for FDCED’SMALL use S; 

type LONG.FIXED is delta D range (-2.0”31-1)»S.. 2.0**31*S; 
for LONG.FDCED’SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 


Supponfor Representation Clauses 


21 



A fixed point type declared by a declaration of the form: 

type T is delta D range L _ R; 
possibly with a small specification: 
for TSMALL use S; 

is impUcitlv derived from a predefined fixed point type. The compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shonest that includes the values L to R inclusive. 

In the program generated by the compiler, a safe value V of a fixed point subtype F is 
represented as the integer: 

V/FBASE’SMALL 


4.4.2 Fixed Point l^pe and Object Size 
Minimum size of a fixed poiia subtype 

The minimum possible size of a fixed point subtype is the minimum number of binary 
digits that is necessary for representing the values of the range of the subtype using the 
small of the base type. 

Fbr a static subtype, if it has a noil range its ntinimam size is 1. Otherwise, s and S being 
the bounds of the subtype, if i and I are the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i >=: 0, L is the smallest positive 
integer such that I < a 2^'^ For i < 0, L is the smallest positive integer such that - 
2^'”<«iandl<»2^*^-l. 

type F is delta 2.0 range 0.0.. 500.0; 

- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0.. 250.0; 

- The minimum size of S is 7 bits. 

subtype D is S range X - Y; 

~ Assuming that X and Y are not static, the minimum size of D is 7 bits 
~ (the same as the minimum size of its type mark S). 


22 


Appendix F, Version 5 






Size of a fixed point subtype 

The sizes of the predefined fixed point types SHORT_FIXED, FIXED and LONG FIXED 
are respeaively 8,16 and 32 bits. 

When no size spedScation is applied to a fixed point type or to its first named s btype, 
its size and the size of any of its sub^pes is the size of the predefined type from hich it 
derives direaly or indirectly. For example: 

type S is delta 0.01 ran^ 0.8.. 1.0; 

- S is derived from an 8 bit predefined fixed type, its size is 8 bits, 
type F is delta O.Ol range 0.0.. 2.0; 

" F is derived from a 16 bit predefined fixed type, its size is 16 bits, 
type N is new F range 0.8.. l.O, 

~ N is indirealy derived from a 16 bit predefined fixed type, its size is 16 bi >. 

When a size specification is applied to a fixed point type, this fixed point type at 1 each of 
its subtypes has the size specified by the length clause. The same rule applies to first 
named subtype. The size specification must of course specify a value greater iha or 
equal to the minimum size of the type or sulMype to wl^ it applies: 

type S is delta 0.01 range 0.8.. 1.0; 
forS-SIZEuseSZ; 

" S is derived from an 8 bit predefined fixed type, but its size is 32 bits 
" because of the size specification. 

type F is delta 0.01 range 0.0.. 2.0; 
for FSI2E use 8; 

- F is derived from a 16 bit predefined fixed type, but its size is 8 bits 

- because of the size specification. 

type N is new F range 0.8.. 1.0; 

~ N is indirectly derived from a 16 bit predefined fixed type, but its size is 
~ 8 bits because N inherits the size specification of F. 


Support for Representation Clauses 


23 



The Alsys compiler fully implements size specifications. Nevertheless, as flxul point 
objects are represented using machine integers, the specified length cannot be greater 
than 32 bits. 


Size of the objects of a fixed point subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of a fixed point type has the same size as its subtype. 


4.5 Access I^pes and Collections 

Access Types and Objects of Access Types 

The only size that can be specified for an access type using a size specification is its usual 
size (32 bits). 

An object of an access subtype has the same size as its subtype, thus an object of an 
access subtype is always 32 bits long. 


CaUectioH Size 

As described in RM 13.2, a specification of collection size can be provided in order to 
reserve storage space for the coOection of an access ^pe. 

When no STORAGE_SIZE specification applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORAGE_SIZE is then 0. 

fhe maximum size allowed for a colleaion is 64k bytes. 


4.6 Task Types 

Storage for a task activation 

As described in RM 13.2, a length clause can be used to specify the storage space (that is, 
the stack size) for the activation of each of the tasks of a given type. Alsys also allows the 
task stack size, for all tasks, to be established using a Binder option. If a length clause is 
given for a task type, the value indicated at bind time is ignored for this task type, and the 
length clause is obeyed. When no length clause is used to specify the storage space to be 


24 


Appendix F, Version 5 



reserved for a task activation, the storage space indicated at bind time is used for this 
activation. 

A length clause may not be applied to a derived task type. The same storage space is 
reserved for the aaivation of a task of a derived type as for the activation of a task of the 
parent type. 

The minimum size of a task subtype is 32 bits. 

A size specification has no effect on a task type. The only size that can be specified using 
such a length clause is its usual size (32 bits). 

An objea of a task subtype has the same size as its subtype. Thus an object of a task 
subtype is always 32 bits long. 


4.7 Array T^pes 

Each array is allocated in a contiguous area of storage units. All the components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 


4.7.1 Array Layout and Structure and Pragma PACK 



Component Gap Component Cap Coeponent Gap 


If pragma PACK is not specified for an array, the size of the componenu is the size of the 
subtype of the components: 


Support for Representation Clauses 


25 








type A is array (1.. 8) of BOOLEAN; 

- The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIGIT is range 0 ^ 
for DECIMAL_DIGrrsIZE use 4; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range <>) of DEOMAL^DIGIT; 

- The size of the type OECIMAL.DIGIT is 4 bits. Thus in an array of 

- type BINARY_CODED_DECIMAL each component will be represented on 

- 4 bits as in the usual BCD represenution. 

If pragma PACK is specified for an array and its components are neither records nor 
arrays, the size of the components is the minimum size of the subtype of the components: 

type A is array (1.. 8) of BOOLEAN; 
pragma PACK(A); 

- The size of the components of A is the minimum size of the type BOOLEAN: 

-1 bit. 

type DECIMAL_OIGIT is range 0^9; 
for DEaMAL^IOrrSIZE use 32; 
type BINARY.CODEDJJEOMAL is 

array (INTEGER range < >) of DECIMAL_DlGrri 
pragma FAlCK(BINARY.OODED_DECIMAL); ~ 

~ The size of the type DEaMAL.DIGIT is 32 bits, but, as 

- BINARY_CODED_DECIMAL is packed, each component of an array of this 

- type will be represented on 4 bits as in the usual BCD representation. 

Packing the array has no efiect on the size of the components when the components are 
records or arrays, since records and arrays may be assigned addresses consistent with the 
alignment of their subtypes. 


Gaps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the compiler may choose a 
representation with a gap after each component; the aim of the insertion of such gaps is 
to optimize access to the array components and to their subcomponents. The size of the 
gap is chosen so that the relative displacement of consecutive components is a multiple 


26 


Appendix F, Version 5 



of the alignment of the subtype of the components. This strategy allows each component 
and subcomponent to have an address consistent with the alignment of its subtype: 

type R is 
record 

K; INTEGER; 

B: BOOLEAN; 
end record; 
for Ruse 
record 

K at 0 range 0.. IS; 

B at 2 range 0.. 0; 
end record; 

~ Record type R is byte aligned. Its size is 17 bits, 
type A is array (1.. 10) of R; 

- A gap of 7 bits is inserted after each component in order to respect the 
~ alignment of type R. The size of an array of type A will be 240 bits. 



Cflwpone n t 6m Comonent Gap Conporant Gap 


Atto^ of type A: each subcomponent K has an even offset 


If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are insened: 

type R is 
record 

K: INTEGER; 

B: BOOLEAN; 
end record; 

type A is array (1.. 10) of R; 
pragma PACK(A); 

~ There is no gap in an array of type A because A is packed. 

- The size of an objea of type A will be 270 bits. 


Supptm for Representation Clauses 


27 






type NR is new R; 
for NR'SIZE use 24; 

type B is array (1.. 10) of NR; 

- There is no gap in an anay of type B because 
-- NR has a size specification. 

~ The size of an objea of type B will be 240 bits. 







D 



D 


IHI 

D 

II 






Conponent Component 


Array of type A or B 


4.7^ Array Subtype and Object Si 2 e 
Sia ef an array subtype 

The size of an array subtype is obtained by multiplying the number of its components by 
the sum of the size of the components and the size of the gaps (if any). If the subtype is 
unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

■ if it has non-static constraints or is an unconstrained array type with non-static 
index subtypes (because the number of components can then only be determined at 
run time). 

■ if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not static (because the size of the components and 
the size of the gaps can then only be determined at run time). 

As has been indicated above, the effea of a pragma PACK on an array type is to suppress 
the gaps. The consequence of packing an array type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not sutic, the compiler ignores any 
pragma PACK applied to the array type but issues a warning message. Apart from this 
limiution, array packing is fully implemented by the Alsys compiler. 


28 


Appendix F, Version 5 







A size spedfication applied to an anay type or first named subtype has no effect The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verily that the layout of an array is as expeaed by 
the application. 


Size of the objects if an arraj subtype 

The size of an object of an array subQrpe is always equal to the size of the subtype of the 
object 


4.8 Record Types 


4.8.1 Basic Record Structure 
Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. 

The positions and the sizes of the components of a record type objea can be controlled 
using a record representation clause as described in RM 13.4. In the Alsys FirstAda 
tmplemeiuarkMi there b no restriction on the position that can be specified fora 
component of a record. If a component b not a record or an array, its size can be any size 
from the minimum size to the size of its subtype. If a component b a record or an array, 
its size must be the size of its subtype. 


type OEVICE_INFO_aECaRO is 
record 


Bins 


B(X)LEAN; 

-- Bit 

CTRL 


BOOLEAN; 

-- Bit 

NETWORK 


BOOLEAN; 

" Bit 

BIT12 


BOOLEAN; 

-- Bit 

■IT11 


BOOLEAN; 

" Bit 

BIT10 


BOOLEAN; 

-- Bit 

BIT9 


BOOLEAN; 

- Bit 

BITS 


BOOLEAN; 

-- Bit 

ISOEV 


BOOLEAN; 

” Bit 


IS (reserved) 

H (true if control strings processed) 
13 (true if device is on network) 

12 (reserved) 

11 (reserved) 

10 (reserved) 

9 (reserved) 

8 (reserved) 

7 (true if device, false if disk file) 


Support for Representation Clauses 


29 


EOF 


BOOLEAN; 

-- Bit 6 

BtNiUir 


BOOLEAN; 

" Bit 5 

B1T4 


BOOLEAN; 

— Bit 4 

ISCLK 


BOOLEAN; 

-- Bit 3 

ISHUL 


BOOLEAN; 

— Bit 2 

I SCOT 


BOOLEAN; 

-- Bit 1 

ISCIN 


BOOLEAN; 

" Bit 0 


and record; 


<true if at and of file) 

(true if binary (raw) Mode) 
(reaarvad) 

(true if clock device) 

(true if NUL device) 

(true if conaote output device) 
(true if console input device) 


for OEVKX.INFO.RECOKO uee 
record 


Bins 

at 

1 

range 7 


7; 

•• 

Bit 15 

CTRL 

at 

1 

range 6 


6; 


Bit 14 

NETWORK 

at 

1 

range 5 


5; 


Bit 13 

BIT12 

at 

1 

range 4 


*; 


Bit 12 

BIT11 

at 

1 

range 3 


3; 


Bit 11 

BtTIO 

at 

1 

range 2 


2; 


Bit 10 

BIT9 

at 

1 

range t 


1; 


Bit 9 

BITS 

at 

1 

range 0 


0; 


Bit 8 

rSOEV 

at 

0 

ranea 7 


7; 


Bit 7 

EOF 

at 

0 

range 6 



— 

Bit 6 

BINARY 

at 

0 

range S 


5; 

" 

Bit 5 

BIT4 

at 

0 

range 4 


4; 

” 

Bit 4 

ISCLK 

at 

0 

range 3 


3; 

-- 

Bit 3 

ISNUL 

at 

0 

range 2 


2; 

•• 

Bit 2 

ISCOT 

at 

0 

range 1 


1; 

- 

Bit 1 

ISCIN 

at 

0 

range 0 

• e 

0; 

-- 

Bit 0 


end record; 


Pragma PACK has no effea on records, h is unnecessary because record representation 
clauses provide full control over record layout 

A record represenution clause need not specify the position and the size for every 
component. If no component clause applies to a component of a record, its size is the 
size of its subtype. 


30 


Aj^tendix F, Version 5 



1 


4.8^ Indirect Components 

"OFFSET 


If the offiet of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direct; 



B« 9 inn<ng of the record 
Coapile tiM offset 


CoMpile ttae offset 


Run tiae offset 


A direerai^i an Mina component 

If a record component is a reoinl or an array, the soe of its subtype may be evaiiated at 
run time and may even depend on the discriminants of the record. We will call these 
components dynamic components; 

^ DEVICE is (SCREEN, PRINTER); 

type COLOR is (GREEN, RED, BLUE); 

type SERIES is array (POSITIVE nmgt < >) of INTEGER; 

type GRAPH (L: NATURAL) is 
record 

X: SERIES( 1 ~ L); - The size of X depends on L 
Y: SERIES( 1 ~ L); - The size of Y depends on L 
end record; 

Q: POSITIVE; 

Support for Representation Clauses 31 




type PICTURE (N : NATURAL; D; DEVICE) fa 
record 

F: GRAPH(N); - The size of F depends on N 
S : GRAPH(Q); - The size of S depends on Q 
caseDfa 

when SCREEN »> 

C: COLOR; 
when PRINTER >> 
null; 
end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be 
evaluated at compile time and is thus indirect In order to minimize the number of 
indirect components, the compiler groups the dynamic components together and places 
them at the end of the record: 

0 > SCREEN D > PRINTER 

N > 2 N B 1 



The record type PICTURE: F and S are placed at the end of the record 


32 


Appendix F, Version 5 




Note that Ada does not allow representation clauses for record components with non¬ 
static bounds [RM 13.4.7], so the compiler’s grouping of dynamic components does not 
conflia with the use of representation clauses. 

Because of this approach, the only indirect components are dynamic components. But 
not all dynamic components are necessarily indirect: if there are dynamic components in 
a component list which is not followed by a variant part, then exactly one dynamic 
component of this list is a direct component because its o^t can be computed at 
compilation time (the only dynamic components that are direct components are in this 
situation): 



Beginning of the record 
Coepile tine offset 


' I " Coepile tin* offset 

Size dependent on discrininent L 
' J-" ' .- '...Hvn.tfne offset 

Size depe n d en t on discrieiinant L 


The record type GRAPH: the dyttamk corrtponent Xis a direa component 


The o^t of an indirect component is almys expressed in storage units. 

The space reserved for the offiet of an indirea component must be large enough to store 
the size of any value of the record type (the maximum potential of&et). The compiler 
evaluates an upper bound MS of this size and treats an offset as a component having an 
anonymous integer type whose range is 0 ~ MS. 

If C is the name of an indirect component, then the ofBet of this component can be 
denoted in a component clause by the implementation generated name COFFSET. 


Support for Representation Clauses 


33 



4.8 J Implicit Components 

In some circumstances, access to an objea of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid 
recomputation (which would degrade performance) the compiler stores this information 
in the record objects, updates it when the values of the discriminants are modified and 
uses it when the objects or its components are accessed. This information is stored in 
special components called implicit components. 

An implidt component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record object (the implidt component is considered to be declared before any variant 
part in the record type declaration). There can be two components of this kind; one is 
called RECORD_SlZE and the other VARIANT_INDEX. 

On the other hand an implidt component may be used to access a given record 
component In that case the implidt component exists whenever the record component 
exists (the implidt component is considered to be declared at the same place as the 
record component). Components of this kind are called ARRAY DESCRIPTORS or 
RECORD.DESCRIPTORS. 


KECOttDJIZE 

This implicit oomponetu is created by the compiler when the record ^pe has a variant 
part and its discriminants are de&nited. U contains the size of the storage space 
necessary to store the current value of the record object (note that the storage effectively 
allocated for the record objea may be more than this). 

The value of a RECORD.SIZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause spedfies that a component of the record type has an of&et or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implidt component RECORD.SIZE must be large enough to store the maximum 
size of any value of the record type. The compiler evaluates an upper bound MS of this 
size and then considers the implidt component as having an anonymous integer type 
whose range is 0.. MS. 

If R is the name of the record type, this implidt component can be denoted in a 
component clause by the implementation generated name R‘RECORD_SIZE This 
allows user control over the position of the implidt component in the record. 


34 


Appendix F, Version 5 


VARIASTJNDEX 

This implicit component is created by the compiler when the record type has a variant 
part It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists in variant parts that themselves do not contain a variant part are 
numbered. These numbers are the possible values of the implicit component 
VARIANT.INDEX. 

type VEHICLE is (AIRCRAFT. ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND: VEHICLE := CAR) is 
record 

SPEED: INTEGER; 
case KIND is 

when AIRCRAFT | CAR = > 

WHEELS: INTEGER; 
case KIND is 

when AIRCRAFT «> -1 

WINGSPAN: INTEGER; 
when others «> -2 


when BOAT *>-3 

STEAM : BOOLEAN; 
when ROCKET = > - 4 

STAGES: INTEGER; 

end case; 
end record; 

The value of the variant index indicates the set of components that are present in a 
record value: 



Support for Representation Clauses 


35 




A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Conponent 

Interval 

KINO 

• • 

SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAM 

3 .. 3 

STAGES 

4 .. 4 


The implicit component VARIANT_INDEX must be large enough to store the number v 
of component lists that don’t contain variant parts. The compiler treats this implicit 
component as having an anonymous integer type whose range is 1.. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name RVARIANT.INDEX. This 
allows user control over the position of the implicit component in the record. 


•ARMAYJ}ESCRIFTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subqrpe is an anonymous 9staf subtype that depends on a discriminant 
of the record. It contains information abom the component subtype. 

The structure of an implicit component of kind ARRaY_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, size of the component 
may be obtained using the ASSEMBLY parameter in the COMPILE command. 

The compiler treats an implicit component of the kind ARRAY_DESCRIFTOR as having 
an anonymous array type. If C is the name of the record component whose subtype is 
describe by the array descriptor, then this implicit component can be denoted in a 
component clause by the implemenution generated name CarRAY.DESCRIPTOR. 

This allows user control over the position of the implicit component in the record. 


36 


AppendixF, Version 5 




7tECORD_DESCRIPTOR 


An implicit component of this kind is associated toy the compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
discriminant of the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD^DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, the size of the 
component may be obtained using the ASSEMBLY parameter in the COMPILE 
command. 

The compiler treats an implicit component of the land RECORO^DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implemenution generated name 
CRECORD_^DESCRIPTOR. This allows user control over the position of the implicit 
component in the record. 


Suppression ttflnqrUdtCompoHails 

The Alsys implemenution provides the capability of suppressing the implicit 
oompooents RECORD.SIZE and/orVARIANTJNDEX Etom a record type. This can be 
done using an impiementaiion defined pragma called IMPROVE. The syntax of this 
pragma is as follows; 

pragma IMPROVE (TIME | SPACE, [ON « >) simple_name); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the represenution of the record type that is denoted by the second argument. 

If TIME is specified, the compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the compiler only inserts a VARIANT.INDEX or a 
RECORD_SIZE component if this component appears in a record represenution clause 
that applies to the record type. A record represenution clause can thus be used to keep 
one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
represenution clause is allowed for this type. 


Support for Representation Clauses 


37 



4.8.4 Size of Record Types and Objects 

Site >4'a ncord subtype 

Unless a component clause specifies that a component of a record type has an offset or a 
size which cannot be expressed using storage units, the size of a record subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its 
components and the sizes of its gaps (if any). This size is not computed at compile time 

■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at compile 
time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant If the size of a 
component or of a gap cannot be evaluated exactly at compile time an upper bound of 
this size is used by the compiler to compute the subtype size. 

A size specification applied to a record type or first named subtype has no effect The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
sudt a length clause can be useful to verify that the layout of a record is as expeaed by 
the application. 


Size ef an object vf a record subtype 

An objea of a constrained record subtype has the same size as its subtype. 

An objea of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 8k bytes. If the size of the subtype is greater than this, the objea 
has the size necessary to store its current value; storage space is allocated and released as 
the discriminants of the record change. 


38 


Append F, Versurn 5 



Section 5 


Conventions for Implementation>Generated Names 


The following fonm of implementation-generated names [13.4(8)] are used to denote 
implementation-dependent record components, as described in si^tion 4.8 in the 
seaions on indirea and implicit components; 


COFFSET 

R’RECORD_SIZE 

R’VARIANf_INDEX 

R’ARRAY_D~ESCRIPTORs 

R*RECORD_DESCRIPTORs 


where C is the name of a record component and R the name of a record type. 

The following predefined packages are reserved to Alsys and cannot be recompfied: 

alsys_basicjo 

ALSYS_ADA_RUNTIME 

ALSYS_BASIC_DIRECT_IO 

ALSYS_BASICJSEQUEPmAL_IO 


Conventions for Implementation-Generated Names 


39 





Appendix F, Version 5 



Section 6 


Address Clauses 


6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an objea as described in RM 13.5. 
When such a clause applies to an objea the compiler does not cause storage to be 
allocated for the object The program accesses the objea using the address specified in 
the. clause. It is the responsibility of the user therefore to make sure that a valid 
allocation of storage has been done at the specified address. 

An address clause is not allowed for task objects, for unconstrained records whose size is 
greater than 8k bytes or for a constant 

There are a number of ways to compose a legal address expression for use in an address 
clause. The most direct ways are: 

■ For the case where the memory is defined in Ada as another object use the 
’ADDRESS auribute to obtain the argument for the address clause for the second 
object 

■ For the case where the desired location is memory defined in assembly or another 
non-Ada language (is relocatable), an interfaced routine may be used to obtain the 
appropriate address from referencing information known to the other language. 

■ For the case where an absolute address is known to the programmer, use the 
funaion SYSTEM.VALUE This funaion has one (1) parameter of type string. The 
string is of the form 'sss.-OOOO”. The length is 9, and the is required to separate the 
segment and of&et ponion of the address. SYSTEM.VALUE returns a value of type 
SYSTEMADDRESS. The string representing the desired address can be passed as 
the aaual parameter to SYSTEM.VALUE in the simple expression part of the 
address clause. See Seaion 3 for the specification of package SYSTEM. 

In all cases other than the use of mi address attribute, the programmer must ensure 
that the segment part of the argument is a seleaor if the program is to run in 
protected mode. Refer to ihc Af^lkation Devehpen’ GiMe, Seaion 5.1.5 for more 
information on proteaed mode machine oriented programming. 


Address Clauses 


41 






6,2 Address Clauses for Program Units 

Address clauses for program units are not implemented in the current version of the 
compiler. 

63 Address Clauses for Interrupt Entries 

Address clauses for interrupt entries are supported. (See Chapter 7 of the Application 
Developer’s Guide for details.) 


42 


Appendix F, Version 5 




Section 7 


Unchecked Conversions 


Unchecked type convereions are described in [13.10.2]. The foUowing restrictions apply 
to their use: 

■ Unconstrained arrays are not allowed as target types. Unconstrained record types 
without defaulted discriminants are not allowed as target types. Access types to 
unconstrained arrays are not allowed as target or source types. Notes also that 
UNChLCKED_CONVERSION cannot be used for an access to an unconstrained 

string. 

■ If the target type has a smaller size than the source type then the target is made of 
the least signiHcant bits of the source. 

If the source and the target types are each of scalar or access type or if they are both of 
composite type, the effea of the function is to return the operand. 

In other ihe effect of unchecked conversion can be considered as a copy: 

■ If an unchecked oomrersion of a scalar or access source qpc to a composite target 

type is performed, the tesoU is a cort of the source operand. The result has the size 
of the source. 

• If an unchecked conversion of a composite source wpe to a scalar or access target 
type is performed, the result is a copy of the source operand. The result has the size 
of the target. 


Unchecked Conversions 


43 


Appendix F, Version 5 



Section 8 


Input-Output Packages 


The RM dcGnes the predefiiied input-output packages SEQUENTIAL_IO, DIRECT_IO, 
and TEXT_IO, and describes how to use the £acilities available within these packages. 
The RM ate defines the package lO^EXCEFTlONS, which specifies the exceptions that 
can be raised by the predefined input-output packages. 

In addition the RM outlines the package LOW_LEVEL_IO, which is concerned with low- 
level machine-dependent input-output, such as would possibly be used to write device 
drivers or access device registers. L0W_LEVEL_10 has not been implemented. The use 
of interfaced subprograms is recommended as an alternative. 


8.1 Correspondence between External Files and DOS Files 

Ada L'.put-output is defined in terms of external files. Data is read Ctom and written to 
extemalfiles. Each extenial file is implemented as a standard DOS fiJie, including the use 
of ST ANDARD.INPUT and STANDARDjOUTTUT. 

The name of an external file can be either 

■ ttie null string 

■ a DOS filename 

• a DOS special file or device name (for example, CON and PRN) 

If the name is a null string, the associated external file is a temporary file and will cease 
to exist when the program is terminated. The file will be placed in the current directory 
and its name will be chosen by DOS. 

If the name is a DOS filename, the filename will be interpreted according to standard 
DOS conventions (that is, relative to the current directory). The exception 
NAME.ERROR is raised if the name part of the filename has more than 8 characters or if 
the extension part has more than 3 charaaers. 


Input-Output Packages 


45 






If an existing DOS file is specified to the .LCREATE;CREATE procedure, the contents 
of the file will be deleted before writing to the file. 

If a non-existing directoiy is specified in a file path name to CREATE, the directory will 
not be created, and the exception NAME_ERROR is raised. 


8.2 Error Handling 

DOS errors are translated into Ada exceptions, as defined in the RM by package 
lO.EXCEPnONS. In particular, DEVICE.ERROR is raised in cases of drive not ready, 
uniLiown media, disk ^11 or 8.3 Tho FORM Parameter 

The form parameter is a string, formed from a list of attributes, with attributes separated 
by commas. The string is not case sensitive. The attributes specify: 

■ Buffering 

BUFFER_SIZE = > sizejnjytes 

■ Appending 

APPEND *> YES 1 

■ Truncation of the name by DOS 

TRUNCATE -> YES | fiSl 
m DIRECTJO on UNCONSTRAINED objects 
RECORD_SIZE = > sizejnjjytes 


where: 

BUFFER.SIZE: Controls the size of the internal buffer. This option is not sup¬ 
ported for DIRECTJO. The default value is 1024. This option has no effea when 
used by TEXT JO with an external file that is a charaaer device, in which case the 
size of the buffer will be 0. 

APPEND; If YES output is appended to the end of the existing file. If NO output 
overwrites the existing file, lliis option is not supported for DIRECTJO. llie 
default is NO. 


46 


Appendix F, Version 5 



TRUNCATE: If YES the file name will be automatically truncated if it is bigger than 
8 charaaers. The default value is NO, meaning that the exception NAME.ERROR 
will be raised if the name is too tong. 

RECORO.SIZE: This option is supported only for DIRECTJO. This attribute 
controls the logical record length of the external file. 

- When DIRECTJO is instantiated with an unconstrained type the user is 
required to specify the RECORD_SIZE attribute (otherwise USE_ERROR will 
be raised). Tlie value given must be larger or equal to the largest record which 
is going to written. If a larger record is processed the exception USE_ERROR 
will be raised. 

- When DIRECT JO is instantiated with a constrained type the user is not 
required to specify the RECORD_SIZE bui if the RECORD_SIZE is specified 
the only possible value would be the element size in bytes. Any other values 
will raise USE_ERROR. 

The exception USE_ERROR is raised if the form STRING in not correa or if a non 
supported attribute for a given package is used. 


Example: 

FORM »> TRUNCATE »> YES, APPEND »> YES, BUFFERJSIZE »> 20480r 

8.4 Sequential Files 

For sequential access the file is viewed as a sequence of values that are transferred in the 
order of their appearance (as produced by the program or run-time environment). This 
is sometimes called a stream file in other operating systems. Each object in a sequential 
file has the same binary representation as the Ada objea in the executable program. 


Input-Output Packages 


47 



8.5 Direct Files 


For (Urea access the file is viewed as a set of elements (xxupying consecutive positions in 
a linear order. The position of an element in a direa file is specified by its index, which is 
an integer of subtype POSrr[VE_COUNT. 

DIRECTJO only aUows input-output for constrained types. If DIRECTJO is instantiated 
for an unconstrained type, aU calls to CREATE or OPEN will raise USE_ERROR. Each 
objea in a direa file wiU have the same binary representation as the Ada objea in the 
executable program. All elements within the file will have the same length. 


8.6 Text Files 

Text files are used for the input and output of information in ASCII character form. 

Each text file is a sequence of charaaers grouped into lines, and lines are grouped into a 
sequence of pages. 

All text file column numbers, line numbers, and page numbers are values of the subtype 
POSmVE.COUNT. 

Note that due to the definitions of line teimiiuitor, page terminator, and file terminator 
in the RM, and the metlKxi used to mark the end of file umkx DOS. some ASCn files do 
not represent well-formed TEXTJO files. 

A text file is bnfTered by the Runtime Executive unless 

■ it names a device (for example, CON or PRN). 

■ it is STANDARDJNPUT or STANDARD_OUTPUT band has not been redirected. 

If not redireaed, prompts written to STANDARD_OUTPUT with the procedure PUT will 
appear before (or when) a GET (or GET_LINE) (xxurs. 

The funaions END_OF_PAGE and END_OF_FILE always return FALSE when the file is a 
device, which includes the use of the file CON, and STANDARD.INPUT when it is not 
redireaed. Programs which would like to check for end of file when the file may be a 
device should handle the exception END.ERROR instead, as in the following example: 


48 


Appendix F, Version 5 





Example 

besin 

loop 

-- Display the proo^t: 

TEXTJO.PUT (“"> •); 

•• Read the next line: 

TEXTJ0.GET_LIMG (COMMAND. LAST); 

-- Nou do soMthing with CCfMANO (1 .. UST) 
end loop; 
exception 

when TEXT_IO.END_ERROR «> 
null; 

end; 

END^ERROR is raised for STANDARD_INPUT when '' Z (ASCI1.SUB) is entered at the 
keyboard. 


8.7 Access Protection of External Files 

All DOS access protections exist Tidien using files under DOS. If a file is open for read 
only access by one process it can not be opened by another process for read/write access. 


8.8 The Need to Close a File Explicitly 

The Runtime Executive will flush all buffers and close all open files when the program is 
terminated, either normally or through some enxption. 

However, the RM does not define what happens when a program terminates without 
closing all the opened files. Thus a program which depends on this feature of the 
Runtime Executive might have problems when ported to another system. 


8.9 Limitation on the Procedure RESET 

An internal file opened for input cannot be RESET for output However, an internal file 
opened for output can be RESET for input, and can subsequently be RESET back to 
output. 


Input-Output Packages 


49 



8.10 Sharing of External Files and Tasking Issues 

Several internal files can be associated with the same external file only if all the internal 
files are opened with mode IN_MODE. However, if a file is opened with mode 
OUT_MODE and then changed to IN_MODE with the RESET procedure, it cannot be 
shared. 

Care should be taken when performing multiple input-output operations on an external 
file during tasking because the order of calk to the I/O primitives is unpredictable. For 
example, two strinp output by TEXT_IO.PUT_LINE in two different tasks may appear in 
the output file with interleaved characters. Synchronization of VO in cases such as this is 
the user’s responsibility. 

The TEXTJO files STANDARD_INPUTand STANDARD_OUTPUT are shared by all 
tasks of an Ada program. 

If TEXTJO.STANDARD_INPlJT is not redirected, it will not block a program on input. 
All tasks not waiting for input will continue running. 


50 


A^tendix F, Version 5 





Section 9 


Characteristics of Numeric Types 


9.1 Integer Types 

The ranges of values for integer types declared in package STANDARD are as follows: 


SHORT INTEGER 


INTEGER 


LONG INTEGER 


-128 .. 127 


-32768 .. 32767 


-2H7483648 .. 2H7483647 


2*«7 - 1 


2*«15 - 1 


2**31 - 1 


For the packages DIRECTJO and TEXTJO, the range of values for types COUNT and 
POsmvE.COUNT are as follows: 


POSITIVE COUKT 


0 .. 2147485647 
T .. 2147485647 


zvm - 1 


- 2^31 - 1 


For the package TEXTJO, the range of values for the type FIELD is as follows: 


0 .. 255 


2*«B - 1 


9.2 Floating Point Type Attributes 



SHORT_FLOAT 

L0NG_FL0AT 


and FLOAT 


DIGITS 

6 

15 

MANTISSA 

21 

51 

EHAX 

84 

204 


Characteristics of Numeric Types 


51 


r 


EPSILON 

9.53&74E'0r 

8.88178E-16 

LARGE 

1.934Z8E«^25 

2.57110E+61 

SAFE.EMAX 

125 

1021 

SAfE_SHALL 

1.17549E'3« 

2.22S07E-308 

SAFE_LARGE 

4.25353E^37 

2.24712E*307 

FIRST 

•3.4Q2a2E«^38 

-1.79769E+308 

UST 

3.40282E-''38 

1.79769E+308 

HACHINE^RAOIX 

2 

2 

MACHINE^EHAX 

128 

1024 

MACHINE.EMIN 

-125 

-1021 

HACHmjROUHOS 

true 

true 

NACHINE^OVERFLOUS 

false 

false 

SIZE 

’2 

64 

Attributes of Type DURATION 


PURAriOM'DELTA 

2.0 •* (-14) 


DURATION'SMALL 

2.0 •• (-14) 


DURATION'FIRST 

-131_D72.0 


OURATION'LAST 

131_072.0 


DURATION'LARGE 

sme at OURATION'LAST 





52 


Appendix 





Section 10 


Other Implementation-Dependent Characteristics 


10.1 Use of the Floating-Point Coprocessor 

Floating point coprocessor instructions are used in programs that perform arithmetic on 
floating point values in some fixed point operations and when the FLOAT JO or 
FIXED JO packages of TEXT JO are used. The mantissa of a fixed point value may be 
obtained through a conversion to an appropriate integer type. This conversion does not 
use floating point operations. Object code running on an 80286 or 80386 using floating 
point instructions does not require the coprocessor, since software floating point 
emulation is provided (see Binder option FLOAT in User’s Guide, Section 5.2). Object 
code running on an 8086,8088 or 80186 does require an 8087 coprocessor, since 8087 
software emulation is not supported. See Appendix D of ihe Application Developer’s 
Guide for more details. 

The Runtime Executive will detea the absence of the floating point coprocessor if it is 
required by a program and will raise CX)NSTRAINT_ERROR. 

10.2 Characteristics of the Heap 

All objects created by allocators go into the heap. Also, portions of the Runtime Execu¬ 
tive representation of task objects, including the task stacks, are allocated in the heap. 

UNCHECKED_DEALLOCATION is implemented for all Ada access objects except access 
objects to tasks. Use of UNCHECKED_DEALL0CATI0N on a task object will lead to 
unprediaable results. 

All objects whose visibility is linked to a subprogram, task body, or block have their 
storage reclaimed at exit, whether the exit is normal or due to an exception. Effeaively 
pragma CONTROLLED is automatically applied to all access types. Moreover, all 
compiler temporaries on the heap (generated by such operations as funaion calls 
returning unconstrained arrays, or many concatenations) allocated in a scope are 
deallocated upon leaving the scope. 


Other Implementation-Dependent Characteristics 


53 



Note that the programmer may force heap reclamation of temporaries associated with 
any statements by enclosing the statement in a begin.. end block. This is especially 
useful when complex concatenations or other heap-intensive operations are performed 
in loops, and can reduce or eliminate STORAGE_ERRORs that might otherwise occur. 

The maximum size of the heap is limited only by available memory. This includes the 
amount of physical memory (RAM) and the amount of virtual memory (hard disk swap 
space). 

10 J Characteristics of Tasks 

The default task stack size is IK bytes (32K bytes for the environment task), but by usino 
the Binder option STACKTASK the size for all task stacks in a program may be set to a 
size from IK bytes to 64K bytes. 

Normal priority rules are followed for preemption, where PRIORITY values are in the 
range 1.. 10. A task with undefined priority (no pragma PRIORITY) is considered to be 
lower than priority 1. 

The maximum number of active tasks is restricted only by memory usage. 

The accepter of a rendezvous executes the accept body code in its own suck. 

Rendezvous with an empty accept body (for ^chronization) does not cause a context 
switch. 

The main program waits for completion of all tasks dependent upon libraiy packages 
before terminating. 

Abnormal completion of an aborted task ukes place immediately, except when the ab¬ 
normal task is the caller of an entry that is engaged in a rendezvous, or if it is in the 
process of aaivating some tasks. Any such task becomes abnormally completed as soon 
as the sute in question is exited. 

The message 

GLOBAL BLOCKING SITUATION DETECTED 

is printed to STANDARD_OUTPUT when the Runtime Executive detects that no further 
progress is possible for any task in the program. The execution of the program is then 
abandoned. 




Appendix F, Version 5 




10.4 Definition of a Main Subprogram 

A Ubrary unit can be used as a main subprogram if and only if it is a procedure that is not 
generic and that has no formal parameters- 

FirstAda imposes no additional ordering constraints on compilations beyond those 
required by the language. 


Other Implemeruation-Dependmt Characierisria 


55 


56 


Appendix F, Version 5 








Section 11 


Limitations 


11.1 Compiler Limitations 

■ The maximum identifier length is 255 charaaeis. 

■ The maximum line length is 255 characters. 

■ The maximum number of unique identifiers per compilation unit is 2500. 

■ The maximum number of compilation units in a library is 1000. 

■ The maximum number of Ada libraries in a family is IS. 


11.2 Hardware Related Limitations 

■ The maximum amount of data in the heap is limited only by available memory. 

a If an unconstrained record type can exceed 4096 bytes, the Qrpe is not permitted 
(unless constrained) as the element type in the definition of an array or record type. 

a The maximum size of the generated code for a single compilation unit is 65535 
bytes. 

a The maximum size of a single array or record object is 65522 bytes. An object 
bigger than 4096 bytes will be indirectly allocated. Refer to ALLOCATION 
parameter in the COMPILE command. (Seaion 4.2 of the User’s Guid-.) 

a The maximum size of a single stack frame is 32766 bytes, including the dau for 
inner package subunits unnested to the parent frame. 

a The maximum amount of data in the global dau area is 65535 bytes, including 
compiler generated dau that goes into the GDA (about 8 bytes per compilation unit 
plus 4 bytes per externally visible subprogram). 


Limitations 


57 


58 


Appendix F, Version 5 





INDEX 


Abnormal completion 54 
Aborted task 54 
Access protection 49 
Access types 24 
Allocators 53 
append 46 

Application Developer’s Guide 3 
Array gaps 26 
Array subtype 7 

Array subtype and object size 28 
Array type 7 

ARRAY_DESCRIPT0R 36 
ASSEMBLER 3 

Attributes of type DURATION 52 

Basic record structure 29 
Binder 54 
BUFFER_SIZE 46 
Boffered ffles 48 
BuCTers 

flashing 49 

C 3 

Charaaeristics of tasks 54 
Colleaion size 24 
Collections 24 
Column numbers 48 
Compiler limitations 57 

maximum identifler length 57 
maximum line length 57 
maximum number of Ada libraries 
57 

maximum number of compilation 
units 57 

maximum number of unique 
identifiers 57 
Constrained types 


lADon 48 
Control Z 49 
COUNT 51 
CREATE 46,48 

Device name 45 
DEVICE.ERROR 46 
DIGITS 51 
Direct files 48 
DIRECTJO 45,48,51 
Disk full 46 
DOS conventions 45 
DOS files 45 
DOS Linker 4 
DOS special Gle 45 
Drive not ready 46 
DURATIONDELTA 52 
DURATIONTIRST 52 
DURATIONTARGE 52 
DURATTONTAST 52 
DURATION’SMALL 52 

E’EXCEPTION_CODE 7 
EMAX 51 

Empty accept body 54 
END_ERROR 48,49 
END”oF_nLE 48 
ENd”oF_PAGE 48 
Enumeration literal encoding 16 
Enumeration subtype size 17 
Enumeration types 16 
EPSILON 52 
Errors 

disk full 46 
drive not ready 46 
hardware 46 
unknown media 46 


Index 


59 




EXCEPTION_CODE 
Attribute 7 

FIELD 51 
File closing 
explicit 49 
Filenames 45 
File terminator 48 
FIRST 52 

Fixed point type representation 21 
Fixed point type size 22 
Floating point coprocessor 53 
Floating point type attributes 51 
Floating point type representation 20 
Floating point type size 21 
FORM parameter 46 

GET 48 
GET_UNE 48 

GLOBAL BLOCKING SITUATION 
DETECTED 54 

Hardware errors 46 
Hardware limitations 

maximum amount of data in the 
global data area 57 
maximum data in the heap 57 
maximum size of a single array or 
record objea 57 

maximum size of the generated code 
57 

Hardware related limitations 57 
Heap 53 

I/O synchronization 50 
Implicit component 36,37 
Implicit components 34 


m.MODE 50 
INDENT 5 

Indirect record components 31 
INTEGER 51 

Integer type and object size 18 
Integer type representation 18 
Integer types 51 
Intel object module format 4 
INTERFACE 3,4 
INTERFACE_NAME 3,4 
Interfaced subprograms 45 
Interleaved characters 50 
lO.EXCEPnONS 45,46 
isJarray 
A ttribute 7 

LARGE 52 
LAST 52 

Layout of a record 29 
L^al file names 45 
Ubiaiyunit 55 
Linitatioiis 57 
Line numbers 48 
Line terminator 48 
LONG_INTEGER 51 
LOW_LEVEL_IO 45 

MACHINE.EMAX 52 
MACHINE_EMIN 52 
MACHINE_MANTISSA 52 
MACHINeIoVERFLOWS 52 
MACHINE^RADIX 52 
MACHINeIrOUNDS 52 
Main program 54 
Main subprogram 55 
MANTISSA 51 


60 


Appendix F, Version 5 






Maximum amount of data in the global 
data area 57 

Maximum data in the heap 57 
Maximum identifier length 57 
Maximum line length 57 
Maximum number of Ada libraries 57 
Maximum number of compilation units 
57 

Maximum number of unique identifiers 
57 

Maximum size of a single array or 
record objea 57 

Maximum size of the generated code 57 

NAME^ERROR 45.46 
Non-bloddng I/O 50 
Number of active tasks 54 

OPEN 48 

Ordering of compilation units 55 
OUT.MODE 50 

PTS_ARRAY 7 
PACK 5 

Page numbers 48 
Page terminator 48 
Parameter passing 2 
POSmVE.COUNT 48,51 
Pragma IMPROVE 5,37 
Pragma INDENT 5 
Pragma INTERFACE 3,4 
Pragma inTERFACE_NAME 4 
Pragma PACK 5.25. % 30 
Pragma PRIORITY 5,54 
Pragma SUPPRESS 5 
Predefined packages 39 
PRIORITY 5,54 


PUT 48 
PUT_LINE 50 

RECORD_DESCRIPTOR 37 
RECORD^SIZE 34,37,47 
Rendezvous 54 
Representation clauses 15 
RESET 49,50 

Runtime Executive 2,4,48,49,53,54 

SAFE.EMAX 52 
SAFE^LARGE 52 
SAFeIsMALL 52 
Sequential files 47 
SEQUENTIALJO 45 
Sharing of external files 50 
SHORT.INTEGER 51 
SIZE 52 

Size of record types 38 
SPACE 37 

STANDARDJNPUT 45,48,49,50 
STANDARDJOUTPUT 45,48,50,54 
Storage reclamation at exit 53 
STORAGE.SIZE 24 
Stream file 47 
SUPPRESS 5 

Synchronization of I/O 50 
SYSTEM 5 

Task activation 24 
Task stack size 24,54 
Task stacks 53 
Task types 24 
Tasking issues 50 
Tasks 

charaaeristics of 54 
Text file 


Index 


61 





buffered 48 
TextGles 48 
TEXTJO 45,51 
TIME "37 
TRUNCATE 47 

UNCHECKED_DEALLOCATION 53 
Unknown media 46 
USE_ERROR 47,48 

Variant part 35 
VARIANT_INDEX 35,36,37 


62 


Appendix F, Version 5 





