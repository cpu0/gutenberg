Technical Report 



CMU/SEl-91 -TR-19 
ESD-91-TR-19 



Carnegie-Mellon University 

Software Engineering Institute 


AD-A248 118 




A Description of Cluster Code 
Generated by the Durra Compiler 





Dennis L. Doubleday 
Michael J. Gardner 
Charles B. Weinstock 




♦ 


♦ 


( , A 

~App:ov‘>d ralea*; 

DUtribn'inn Unlimited 


^2 4^1 


005 


siliiiif 43 






Technical Report 

CMU/S El-91 -TR-19 
ESD-91-TR-19 
December 1991 


A Description of Cluster Code 
Generated by the Durra Compiler 


Dennis L. Doubleday 
Michael J. Gardner 
Charles B. Weinstock 

Distributed Systems Project 


Approved for public release. 
Distribution unlimited. 


Software Engineering Institute 

Carnegie Mellon University 
Pittsburgh, Pennsylvania 15213 





This technical report was prepared for the 


SEI Joint Program Office 
ESD/AVS 

Hanscom AFB, MA 01731 

The ideas and findings in this report should not be construed as an official 
DoD position. It is published in the interest of scientific and technical 
information exchange. 

Review and Approval 

This report has been reviewed and is approved for publication. 


I 


FOR T' E COMMANDER 



John S. Herman, Capt, USAF 
SEI Joint Program Office 


The Software Engineering Institute is sponsored by the U.S. Department of Defense. 
This report was funded by the U.S. Department of Defense. 

Copyright © 1992 by Carnegie Mellon University. 


This document is available through the Defense Technical Information Center. DTIC provides access to and fransfer of 
scientific and technical information for DoD personnel. DoD contractors and potential contractors, and other U.S. Government 
agency personnel and their contractors. To obtain a copy, please contact DTIC directly: Defense Technical Information 
Center, Attn: FDRA, Cameron Station, Alexandria, VA 22304-6145. 

Copies of this document are also available through the National Technical Information Service. For information on ordering, 
please contact NTIS drectfy: National Technical Information Service, U.S. Department of Commerce, Springfield, VA 22161. 

Copies of this document are also available from Research Access, Inc., 3400 Forbes Avenue, Suite 302, Pittsburgh. PA 15213. 

Use of any trademarks in this report is not intended in any way to infringe on the rights of the trademark holder. 








Table of Contents 


1 Introduction 


2 Standard Template 


3 Cluster-Specific Code Fragments 

3.1 With Clauses for User Procedures 

3.2 With Clauses for Channel Packages 

3.3 Enumeration of Channels Used 

3.4 LinkJTaskJnfo Case Alternatives 

3.5 Instantiations of Process_Shell 

3.6 Task Object Declarations for Each Imported Procedure 

3.7 Start_Link_Process Case Alternatives 

3.8 Reconfiguration Trigger Functions 

3.9 Level Configuration Procedures 

3.10 Get_Port Case Alternatives 

3.11 Get_Port_Return Case Alternatives 

3.12 Send_Port Case Alternatives 

3.13 Send_Port_Return Case Alternatives 

3.14 Test_lnput_Port Case Alternatives 

3.15 Test_Output_Port Case Alternatives 

3.16 Case Alternative for Each Configuration Level 

3.17 Type_Table Entries 

3.18 Process_Table Entries 

3.19 Process Attribute Value Assignments 

3.20 LinkJTable Entries 

3.21 Link Attribute Value Assignments 

3.22 Level_Table Entries 

3.23 Cluster_Table Entries 


9 

9 

9 

9 

10 

10 

10 

11 

11 

12 

12 

13 

13 

13 

13 

14 
14 
16 

17 

18 
18 
19 
19 
21 


References 


23 



A i-ia ?*r _^ 

V' • BE 

V* i .' □ 

171 

J isc it ioatloc.- 


I. 1 d'J v 4 ; 


CMU/SEI-91-TR-19 







A Description of Cluster Code Generated by the Durra 

Compiler 


Abstract: Durra is a language and support environment for the specification 
and execution of distributed Ada applications. The Durra programmer specifies 
the distribution of application components by assigning them to virtual nodes 
called clusters. For each cluster named in an application description, the Durra 
compiler generates an Ada package body with a standardized format. Within 
the confines of the format, the content of the package body varies according to 
the requirements placed upon the cluster by the Durra application description. 
The cluster-specific package body is compiled and linked with a fixed set of Ada 
compilation units, common to all clusters, to form a multitasking Ada program. 
The intended audience for this document is Durra application developers, who 
will need an understanding of the concepts presented here in order to be 
effective Durra application debuggers. 


1 Introduction 

The Durra language [1] is a task-level application description language. 1 The basic building 
blocks of the language are the task description, which specifies the properties of an associated 
Ada subprogram or subsystem, and the channel description, which specifies the properties of 
an Ada package implementing a communication facility. Task descriptions may be either prim¬ 
itive or compound. A primitive task description represents a single thread of control. 2 A com¬ 
pound task description is a composition of other task and channel descriptions. Channel de¬ 
scriptions are syntactically similar to primitive task descriptions although the implementations 
exhibit different behaviors. Task implementations are active components; they initiate re¬ 
quests to send or receive messages by calling procedures provided by the runtime environ¬ 
ment. Channel implementations are passive components; they wait for and respond to re¬ 
quests from the runtime environment. 

A Durra programmer describes an application as a collection of processes (instances of Durra 
task descriptions) connected to each other in a graph structure by links (instances of channel 
descriptions). Lower level components are used as building blocks for higher-level task de¬ 
scriptions. Application descriptions are simply compound task descriptions that describe a 
complete application. 

A component’s input/output interface is specified by the ports section of its description. Ports 
are named, unidirectional, locally-defined conduits through which processes may transmit/re¬ 
ceive data. Ports have a Durra data type associated with them to allow semantic checking of 
intercomponent port connections. 

1. Throughout this document, the term task refers to a generalized "thread of control* concept rather than to the 
analogous Ada construct, except where noted. 

2. The actual Ada code that implements a Durra task may, in fact, be a multitasking program. However, from the 
Duma perspective the program is a single thread of control. 


CMU/SEI-91-TR-19 


1 







A compound task description must include additional information about its structure. Its com¬ 
ponent processes and links are defined in its components section and the manner in which 
they are logically connected (which may vary dynamically) is specified in its structures section. 
If the structure of the compound task is allowed to vary, then there must be a reconfigurations 
section that describes a set of structural changes and the conditions under which the changes 
will occur. The clusters section specifies the physical grouping of components into executable 
images, which may well be orthogonal to the logical connections described in the structures 
section. 

If the compound description is a complete application description, then the Durra compiler 
generates an Ada package body with a standardized format for each cluster defined in the ap¬ 
plication. Within the confines of the format, the content of the package body (called Tables) 
varies according to the requirements placed upon the cluster by the Durra application descrip¬ 
tion. The cluster-specific Tables package body imports the implementations of the compo¬ 
nents assigned to the cluster, creates Ada tasks to serve as threads for the Durra process 
implementations, and creates instances of the Ada task types that implement the Durra links 
assigned to the cluster. The package body contains a set of subprograms that route inter-task 
communications; a set of subprograms that evaluate reconfiguration conditions, if any; and a 
set of Ada tasks that together control the runtime configuration of Durra processes assigned 
to the cluster. The package body also defines a set of tables, common to all clusters in the 
application, that describe the complete application structure. The Tables package body is 
compiled and linked with a fixed set of Ada compilation units, common to all clusters, to form 
a multitasking Ada program. If only one cluster is specified in the application description, then 
this program is the complete application implementation. Otherwise, the application is distrib¬ 
uted and the cluster program will communicate at runtime with other cluster programs. 

Each generated Tables package body will consist of twc parts: 

1. A standard template that is constant across all applications. 

2. A cluster-specific part that is distributed throughout the standard template. 

In the specifications in the following sections, program text comprising the standard template 
appears in boldface Italic, while program text that is included for sample purposes but will vary 
with the application appears in italic. Text surrounded by the "<>" character pair is a placehold¬ 
er for actual program text. If expansion and explanation of a placeholder is required, the place¬ 
holder refers to a subsequent section of this document. Program text lines beginning with the 
string "- -" are simply commentary. 


2 


CMU/SEI-91-TR-19 








2 Standard Template 


The following code comprises the standard template for the Tables package body. Placehold¬ 
ers in the template substitute for cluster-specific code fragments which will be described in lat¬ 
er sections. 

with Conflguratlon_Manager; 
with Durrajnterlace; 
with Process_Shell; 
with StorageJManager; 
with Strlng_Pkg; 
with Text JO; 

- packages Calendar, System, DurraJnterface_Types, and Table_Types 

- are "withed" by the package specification 

additional "with" clauses for user procedures (see section 3.1 on page 9)> 

<additional "with" clauses for channel packages (see section 3.2 on page 9)> 

package body Tables Is 

- <comment indicating version of code generator used to create this package body> 

package CM renames ConflguratlonJManager; 
package SM renames StorageJManager; 
package SP renames String_Pkg; 
package Dl renames Durrajnterface; 

- package TTrenames Table_Types in package specification 

- package DT renames Durra lnterface_ Types in package specification 


TYPES 


type Channel_Types Is (<enumeration of Channels used (see section 3.3 on page 9)>); 

type UnkJTaskJnfo (Channel_Type: ChannelJTypes) Is 
record 

case Channel_Type Is 

<case alternative for each value of Channel_Type (see section 3.4 on page 10)> 

end case; 
end record; 

type Llnk_Task_Ptr Is access UnkJTaskJnfo; 

type LlnkJTaskJndex Is array (TT.UnkJDJRange range <>) of LlnkJTaskJPtr; 


OBJECTS 

— ft#*#****#**#***#******#**#***#*#**# 


CMU/SEI-91-TR-19 


3 










Llnk_Task_Table: Llnk_Task_lndex(l..<n>); 

- where n = number of links defined in the application 
<Instantiation of Process_Shell for each user procedure in the cluster 
(see sect bn 3.5 on page 10)> 

<Task object declaration for each Durra process assigned to the duster 
(see section 3.6 on page 10)> 


LOCAL SUBPROGRAMS 


procedure Start_Llnk_Process (Channel_ Type : In Channel_ Types; 

The_Llnk : In TT.LInk_Table_Ptr) Is 

begin 

case Channel_Type Is 

<case alternative for each value of Channel_Type (see section 3.7 on page 11)> 

end case; 

The_Llnk.lnltlallzed := TRUE; 
end Start_L lnk_ Process; 

-- Assume level numbers run from 1..n 

<A set of functions with names of the form Lx, where x is in the range 0..n. 

These functions are used to determine whbh level to go to next, and when to do it. 

The Oth level is equivalent to ENTER. 

(see section 3.8 on page 11)> 

<A set of procedures with names of the form Configure_Level_x where x is in the range 1..n+1. 
These functions are used to configure to a particular level and to start and stop 
relevant processes and links. The n+1 level is EXIT. 

(see section 3.9 on page 12)> 


VISIBLE SUBPROGRAMS 


procedure Get_Port( 

The_Port 
Data_Locatlon 
Data_Slze 
Data_ TypeJD 
Completed 

begin 

case Llnk_ Task_ Table(The_Port.Associated_Llnk.lD). Channel_ Type Is 

CMU/SEI-91-TR-19 


: In TT.Port_Table_Ptr; 

: In System.Address; 

: out NATURAL; 

: out DT.Type_ID_Range_Plus_Null; 
: out BOOLEAN) Is 













<case alternative for each value of Channel__Type (see section 3.10 on page 12)> 

end case; 
end Get_Port; 


procedure Get_Port_Return( 

The_Port : In TT.Port_Table_Ptr; 

Size_of_Data : out NATURAL; 

TypejD : out DT.Type_ID_Range_Plus_Null) Is 


begin 

case Llnk_Task_Table(The_Port.Assoclated_Llnk.lD).Channel_Type Is 

<case alternative for each value of Channel_Type (see section 3.11 on page 13)> 

end case; 

end Get_Port_Return; 


procedure Send_Port( 


The_Port 

: In 

Data_Locatlon 

: In 

Data_Slze 

: In 

Data_TypeJD 

: In 

Completed 

: < 

Priority 

: In 


TT.Port_Table_Ptr; 

System. Address; 

POSITIVE; 

DT. TypeJDJRangeJPlusjNull; 
BOOLEAN; 

DT.MessageJPrtorltyJRange := 


DT.NULL_MESSAGE_PRIORITY) Is 


begin 

case Llnk_Task_Table(The_Port.Assoclated_Llnk.lD).Channel_Type Is 
<case alternative for each value of Channel_Type (see section 3.12 on page 13)> 

end case; 
end Send_Port; 


procedure Send_PortjRetum(TheJPort: In TT.Port_Table_Ptr) Is 
Llnk Task: Llnk_Task_Ptr; 
begin 

case Llnk_Task_Table(The_Port.Assoclated_Llnk.lD).Channel_Type Is 

cease alternative for each value of Channel_Type (see section 3.13 on page 13)> 

end case; 

end SendJPortJRetum; 


CMU/SEI-91-TR-19 


I 







i^**************************************#****^^^****** 


procedure Test_lnput_Port( 

The_Port : in TT.Port_Table_Ptr; 

Type_of_Next_lnput : out DT.Type_ID_Range_Plus_Null; 
Slze_of_Next_lnput : out NATURAL; 
lnputs_A vallable : out NA TURAL) Is 


begin 

Link_ Task_ Table(The_Port.Assoclated_Llnk. ID). Channel_ Type Is 

<case alternative for each value of Channel_Type (see section 3.14 on page 13)> 

end case; 

end Test_lnput_Port; 


procedure Test_Output_Port( 

The_Port : in TT.Port_Table_Ptr; 

Slots_Avaliable : out NATURAL) Is 


begin 

case Llnk_ Task_Table(The_Port.Assoclated_Llnk.lD).Channel_Type Is 

<case alternative for each value of Channel_Type (see section 3.15 on page 14)> 
end case; 

end Test_Output_Port; 


VISIBLE TASKS 


task body StatejChanger Is 
Done : BOOLEAN ;= FALSE; 

Next_LevelJD : INTEGER := 0; 

Prev_Level_ID: INTEGER := 0; 
begin 

accept start; 
while not Done loop 

If Cluster_Table{Thls_ClusterjD).Master then 

- The master is in charge of reconfiguration decisions 


case Next_Level_ID Is 

when 0 =» Next_Level_ID ;« L0(0); - This is the entry condition 
when <l..n+l> => 


<One case alternative for each configuration level in the application and one addtional 
alternative for termination (see section 3.16 on page 14)> 

when others => 


Text_IO.PutJ.lne (’’Illegal reconfiguration to Level’’ & 


6 


CMU/SEI-91-TR-19 






Level_ID_Range’IMAGE(Next_Level_ID) & " requested."); 

end case; 
else 

- Non-masters respond to requests from the master 

accept Reconflgure(To_Level: In NATURAL) do 
Prev_Level_ID := Next_Level_ID; 

Next_Level_ID := To_Level; 
end Reconfigure; 
case Next_Level_lD Is 
when 0 => null; 
when <l..n+l> => 

<One case alternative for each configuration level in the applications and one 
additional alternative for termination (see section 3.16 on page 14)> 

when others => 

Text_IO.Put_Llne(“lllegal reconfiguration to Lever & 
TT.Level_ID_Range’IMAGE(Next_LevelJD) & "requested."); 

end case; 
end If; 
end loop; 
accept Flnlsh_Up; 
end State_Changer; 


TABLE DEFINITIONS 


begin 

Thls_Cluster_ID := <index of this cluster in the Cluster_Table>; 

The_Master := <index of the master in the Cluster_Table>; 

TypeJTable := 
new TT.TypeJndex’f 

<one Type_Table_Entry for each data type defined in the application 
(see section 3.17 on page 16)> 

); 


Process_Table := 

new TT.ProcessJndex ’( 

cone Process_Table_Entry for each process in the application 
(see section 3.18 on page 17)> 

); 


cseries of assignments to the Attributes field of any Process containing attribute values 
(see section 3.19 on page 18)> 


CMU/SEI-91 -TR-19 









_ ************************************************************ 


Llnk_Table := 

new TT.LInk_lndex’( 

<one Link_Table_Entry for each link in the application 
(see section 3.20 on page 18)> 

); 

<series of assignments to the Attributes field of any Link containing attribute values 
(see section 3.21 on page 19)> 

__ ************************************************************ 

Level_Table := 

new TT.Level_lndex’( 

<one Level_Table_Entry for each configuration level in the application 
(see section 3.22 on page 19)> 

); 

__ ************************************************************ 

Cluster _T able := 

new TT.CIuster_lndex'( 

<one Cluster_ Table_Entry for each cluster in the application 
(see section 3.23 on page 21 )> 

); 

end Tables; 


8 


CMU/SEI-91 -TR-19 



3 Cluster-Specific Code Fragments 


This section describes the cluster-specific code fragments referred to by the placeholders in 
the standard template description above. 

3.1 With Clauses for User Procedures 

There must be a "with" clause for every Ada procedure named in the Durra application descrip¬ 
tion as the implementation of a Durra process assigned to the cluster. An Ada procedure is the 
implementation of a Durra process if it is named in the procedure_name attribute for that pro¬ 
cess. 

Example: 

with Producer; 
with Consumer; 
with Console; 
etc. 


3.2 With Clauses for Channel Packages 

There must be a "with" clause for every Ada package named in the Durra application descrip¬ 
tion as the implementation of a Durra link assigned to the cluster. An Ada package is the im¬ 
plementation of a Durra link if it is named in the package_name attribute for that link. 


Example: 

with FIFO_Channel; 
with Broadcast_Channel; 
etc. 

3.3 Enumeration of Channels Used 

Each channel package named in a "with" clause must have a corresponding enumeration lit¬ 
eral in type Channel_Types. The enumeration literal name is the name of the package with the 
suffix "_Type" appended. 

Example: 

type Channel_Types is (FIFO_Channel_Type, Broadcast_Channel_Type); 


CMU/SEI-91-TR-19 


9 






3.4 Link_Task_lnfo Case Alternatives 

In the definition of the Link_Task_lnfc record, there must be a case alternative for each literal 
in the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Type value>=> 

<channel package name>_Llnk: <channel package name>.Channel_Task; 

Example: 

when FIFO_Channel_Type => 

FIFO_Channel_Link: FIFO_Channel.Channel_Task; 

3.5 Instantiations of Process_Shell 

Process_Shell is the name of a generic package supplied with the Durra runtime library. This 
package exports an Ada task type that serves as a "wrapper" around the Ada subprogram 
named as its actual parameter. There must be an instantiation of Process_Shell for each user 
procedure named in a "with" clause. The form of the instantiation must be: 

package <Ada procedure name>_Shell Is new Process_Shell(<Ada procedure name>); 

Example: 

package Producer_Shell is new Process_Shell(Producer); 
package Consumer_Shell is new Process_Shell(Consumer); 
package Console_Shell is new Process_Shell(Console); 
etc. 

3.6 Task Object Declarations for Each Imported Procedure 

There must be an Ada task object declaration for each Durra process assigned to the cluster. 
The object declaration for each process must refer to the instantiation of Process_Shell asso¬ 
ciated with the Ada procedure that implements the Durra process. The process ID of a process 
is its index in the Process_Table (see section 3.18 on page 17). 

Process_<process ID> : <Ada procedure name>_Shell.Caller; 

Example: 

Process_l: Producer_Shell.Caller; 

Process_2: Consumer_Shell.Caller; 

Process_3: Console_Shell.Caller; 

Process_4: Producer_Shell. Caller; 
etc. 


10 


CMU/SEI-91 -TR-19 







3.7 StartJLinkJProcess Case Alternatives 

In the body of the Start_Link_Process subprogram, there must be a case alternative for each 
literal in the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Type value>=> 

Llnk_Task_Table(The_Llnk.lD) := newUnk_Task_lnfo(<Channel_Type vatue>); 
Llnk_Task_Table(The_Llnk.lD).<channel package name>_Llnk.lnitialize(The_Link); 

Example: 

when FIFO_Channel_Type => 

Link_ Task_Table (TheJL ink. ID) := new Link_Task_lnfo(FIFO_Channel_Type); 
Link_Task__Table(The_Link.lD).FIFO_Channel_Llnk.lnitialize(The_Link); 

3.8 Reconfiguration Trigger Functions 

For each configuration level specified in the application description there is a function which 
determines which level to go to next, and when to go to it. An additional function for the initial 
level (level 0), a hidden level not specified in the application description, determines when and 
at what level to start the application. 

function L<Level iD>(Prev: In NATURAL) return NATURAL Is 
theDelta : DURATION := DURATION'LAST; 
aDetta ; DURATION; 
begin 
loop 

-- A series of statements that evaluate reconfiguration expressions at this level. 

- When an expression evaluates true the function returns the new level to go to. 

- The expressions take the following form: 

If reconfiguration condition> then 

return <new Level ID>; 
end If; 

- A series of statements that determine the next time the expressions should be 

- evaluated in the absence of a signal. The expressions take the form:> 
aDetta := <duration evaluation>; 

If aDetta < theDelta then 
theDelta := aDetta; 
end If; 

CM.Reconflguratlon_Condftion_Task.Start(theDelta); 
CM.Reconflguratlon_Condltlon_Task.Check; 
end loop; 
end L<Level ID>; 


CMU/SEI-91 -TR-19 


11 



3.9 Level Configuration Procedures 

For each configuration level there is a procedure that actually carries out the steps necessary 
to configure for that level. For all but the termination level (the level entered when an applica¬ 
tion is about terminate) the procedure is of the form: 

procedure Conflgure_Level_<Level ID> Is 
begin 

CM.Do_Level_Conflguratlon(<Level ID>); 

<A series of statements that start processes and links in the configuration. 

They take on the form:> 

If Thls_Cluster_ID = Llnk_Table(<x>).CIuster_ID and then 
not Llnk_Table(<x>).lnltlallzed then 
Start_Llnk_Process( 

<llnk_type>, 

Llnk_Table(<x>)); 
end If; 

If ThlsjClusterJD = Process_Table(<y>).CIuster_ID and then 
not Process_Table(<y>).lnltlatlzed then 
Process_<z>.Start(<y>); 
end If; 

end Conflgure_Level_<Level ID>; 

For the termination level (level n+1), the procedure has the form: 

procedure Conflgure_Level_<Level ID> Is 
begin 

CM.Do_Level_Conflguratlon(<Level ID>); 

- A series of statements that stop processes in the configuration. 

- They take the form:> 

If Thls_Cluster_ID = Process_Table(<y>).CIuster_ID and then 
Process_Table(<y>).lnltlallzed then 
Process_<z>.Stop; 
end If; 

end Conflgure_Level_<Level ID>; 


3.10 Get_Port Case Alternatives 

In the body of the Get_Port subprogram, there must be a case alternative for each literal in the 
enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Types value> => 

Unk_Task_Table(The_Port.Assoclated_Llnk.lD). 

<channel package name>_Llnk.Get_Port( 

TheJPort, 

Data_Locatfon, 

Data_Slze, 


12 


CMU/SEI-91-TR-19 









Data_TypeJD, 

Completed); 


3.11 Get_Port_Return Case Alternatives 

In the body of the Get_Port_Return subprogram, there must be a case alternative for each lit¬ 
eral in the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Types value> => 

Llnk_Task_Table(The_Port.Assoclated_Llnk.lD).<channel package name>_Llnk. 
Get_Port_Retum(The_Port.Connectlon_Polnt)(Size_of_Data, Type_ID); 

3.12 Send_Port Case Alternatives 

In the body of the Send_Port subprogram, there must be a case alternative for each literal in 
the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_ Types value> =» 

Llnk_Task_Table(The_Port.Assoclated_Unk.lD). 

<channel package name>_Llnk.Send_Port( 

TheJPort, 

Data_Locatlon, 

Data_Slze, 

Data_TypeJD, 

Completed, 

Priority); 

3.13 SendPortReturn Case Alternatives 

In the body of the Send_Port_Return subprogram, there must be a case alternative for each 
literal in the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Types value> => 

- compiler bug requires this workaround 

Llnk_Task := Llnk_Task_Table(The_Port.Associated_Llnk.lD); 

Llnk_Task.<channelpackage name>_Llnk. 

Send_Port_Retum(The_Port.Connectlon_Polnt); 

3.14 TestJnputJPort Case Alternatives 

In the body of the Test_lnput_Port subprogram, there must be a case alternative for each lit¬ 
eral in the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Types value> => 

Unk_ Task_ Table(The_Port.Assoclated_Unk.lD). 


CMU/SEI-91 -TR-19 


13 






<channel package name>_Unk. Test_lnput_Port( 

The_Port, 

Type_ of_Next_ Input, 

SIzejofJNextJnput, 
lnputs_A va liable); 

3.15 Test_Output_Port Case Alternatives 

In the body of the Test_Output_Port subprogram, there must be a case alternative for each 
literal in the enumerated type Channel_Types. The form of the case alternative must be: 

when <Channel_Types value> => 

Llnk_Task_Table(The_Port.Assoclated_Llnk.lD).<channel_package_name>_Link. 
Test_Output_Port(The_Port, Slots_A vallable); 

3.16 Case Alternative for Each Configuration Level 

There are two case statements in the body of the State_Changer task. The first is executed by 
the master cluster and the second is executed by all other clusters. For each configuration lev¬ 
el in the application there must be a case alternative in both case statements. The case alter¬ 
native choice is the ID of the configuration level, which is its index in the Level_Table. There 
are also alternatives for ENTER (alternative 0) and EXIT (alternative n+1). For the master, the 
form of the alternative is as follows: 

when <level ID> =» 

CM.Reconflguratlon_Task.Conflgure_to_Level(<level ID>); 
accept Reconflgure(To_Level: In NATURAL); 

Conflgure_Level_<level ID>; 

Next_Level_ID := L<Level ID>(Prev_Level_ID); 

Prev_Level_ID := <level ID>; 

The ENTER alternative is: 

when 0 => Next_Level_ID := L0(0); 

The EXIT alternative is: 
when <n+1> => 

CM. Recon flgura tion_ Task. Con flgure_ to_ Level(<n+1>); 
accept ReconflgurefTo_Level: In NATURAL); 

ConflgureJLevel_<n+1>; 

Done := TRUE; 


For the non-master clusters, the form of all alternatives except the ENTER alternative is as fol¬ 
lows: 

when clevel ID> => Conflgure_Level_<Levei ID>; 


14 


CMU/SEI-91-TR-19 











The ENTER alternative for non-master clusters is: 


when 0 => null; 


Example: 

In the following example, there are two application levels, Level 1 and Level 2. Level 0 is the 
ENTER level and Level 3 is the EXIT level. 

if Cluster_Table(This_Cluster_ID).Master then 
case Next_Level_ID is 
when 0 -> Next_Level_ID ;= L0(0); 

when 1 => 

CM. Reconfiguration_ Task. Configure_to_L e vel( 1); 
accept Reconfigure(To_Level: in NATURAL); 

Configure_Level_1; 

Next_Level_ID := LI (Prev_Level_ID); 

Prev_Level_ID := 1; 

when 2=> 

CM.Reconfiguration_Task.Configure_to_Level(2); 
accept Reconfigure(To_Level: in NATURAL); 

Configure_Level_2; 

Next_Level_ID := L2(Prev_Level_ID); 

Prev_Level_ID ;* 2; 


when 3 => 

CM. Reconfiguration_ Task. Configure_to_Level(3); 
accept Reconfigure(To_Level: in NATURAL); 

Configure_Level_3; 

Done > TRUE; 

when others -> 

TextJO.Put_LineClllegal reconfiguration to Level" & 

TT.LevelJD_Range’IMAGE(Next_Level_ID) & "requested."); 


end case; 
else 

accept Reconfigure(To_Level: in NATURAL) do 
Prev_Level_ID := NextJLevelJD; 
Next_LevelJD := To_Level; 
end Reconfigure; 

case Next_Level_ID is 
when 0 => null; 


CMU/SEI-91 -TR-19 


15 





when 1 => Configure_Level_1; 


when 2 => Configure_Level_2; 
when 3 => Configure_Level_3; 
when others => 

TextJO.Put_Line("!llegal reconfiguration to Level" & 

TT.Level_ID_Range IMAGE(Next_LevelJD) & "requested."); 

end case; 
end if; 

3.17 Type Table Entries 

There must be an entry in the Type_Table for each Durra type defined in the application de¬ 
scription. The Type_Table_Entry assignment shall have the form: 

sequential index n, starting at 1> => new TT.TypejTable_Entry’( 

Kind => <TT.Size_Type or TT.Union_Type>, 

Name => SP.Make__Perslstent("<Durra type name>”), 

ID => <n>, 

Free_Ust => <if the type has a fixed upper bound, then 

SM.CreatejFreeJUst(<upper_bound/8>), 
else null,> 

Bytes_Requlred => <maximum size of data, or 0 if unbounded>, 

- if Kind is SizeJType then 

Upper Bound => <upper bound from type definitions 
Lower_Bound => <tower bound from type definition> 

- elsif Kind = UnionJType then 

Component Types => null 

) 


Example: 

1 => new TT.Type_Table_Entry'( 

Kind «> TT.SizeJType, 

Name => SP.Make_Persistent(’GENERAL"), 
ID => 1, 

Free_List => SM.Create_Free_List(4), 
Bytes_Required «> 4, 

Upper_Bound => 32, 

Lower_Bound => 32 

) 


16 


CMU/SEI-91-TR-19 







3.18 Process Table Entries 


There must be an entry in the Process_Table for each process defined in the application de¬ 
scription. The Process_Table_Entry assignment shall have the form: 

sequential index n, starting at 1> => new TT.Process_Table_Entry’( 

Name => SP.Make_Persistent(”<expanded Durra process name>"), 

ID => <n>, 

Start_Tlme => DT.NULL_TIME, 

Initialized => FALSE, 

Ports => new TT.Port_lndex’( 

- for each port defined for this process, one Port_Table_Entry 
sequential index m, starting at 1> => TT.new Port_Table_Entry’( 

Name => SP.Make_Perslstent("simple/expanded Durra port name>"), 

ID => <m>, 

Owner_Process => null, 

DataJType => Type_Table(<ID of data type for this port>), 
Assoclated_Llnk => null, 

Connectlon_Polnt => DT.Port_ID_Range’LAST, 
ls_lnput => < FALSE or TRUE, depending on port direction> 

) 

), 

Attributes => TT.Attrlbute_Palrs.Create, 

Blocked => FALSE, 

Blocked_Data_Buffer => System.NO_ADDR, 

BlockedJDatajSIze => 0, 

Blocked_Data_TypeJD => NULL_TYPE_ID, 

RemoteJData => null, 

ClusterJD => 0 


Example: 

1 => new Process_Table_Entry'( 

Name => SP.Make_Persistent(’MAIN.P1"), 

ID => 1, 

Start_Time *> DT.Null_Time, 

Initialized => FALSE, 

Ports => new TT.Port_lndex'( 

1 => new TT.Port_Table_Entry’( 

- Port MAIN.P1.OUT1 
Name -> SP.Make_Persistent("OUTr), 

ID => 1. 

Owner_Proce$s => NULL, 

DataJType => Type_Table(1), 

AssociatedJLink *> NULL, 

Connection_Point -> DT.Port_ID_Range’LAST, 


CMU/SEI-91 -TR-19 


17 






Isjnput => FALSE 

) 

). 

Attributes => TT.Attribute_Pairs.Create, 

Blocked => FALSE, 

Blocked_Data_Buffer => System.NO_ADDR, 

Blocked_Data_Size => 0, 

Blocked_Data_ TypeJD => DT.NULL_TYPEJD, 

Remote_Data => null, 

Cluster_ID => TT.CIuster_ID_Range'LAST 

) 

3.19 Process Attribute Value Assignments 

For each attribute of each process defined in the application description, there must be an as¬ 
signment of the form: 

TT.A ttrlbute_Palrs.Append 

(Element => (SP.Make_Perslstent("simple attribute name>"), 

SP. Make_Pers!stent("<attribute value> ”)), 

L => Process_Table(<processjable_index>).Attrlbutes); 

Example: 

TT.AttributeJPairs. Append 
(Element => (SP.Make_Persistent("clusteF), 

SP.Make_Persistent("cl1 ”)), 

L => Process_Table(1).Attributes); 

3.20 Link_Table Entries 

There must be an entry in the Link_Table for each link defined in the application description. 
The Link Table^Entry assignment shall have the form: 

sequential index n, starting at 1> => new TT.LInk_Table_Entry’( 

Name => SP.Make_Perslstent(<expanded Durra link name>), 

ID => <n>, 

In Ports => new TT.Port_lndex’( 

- one entry for each input port defined for this link 
sequential index m, starting at 1> => null 

h 

Out_Ports => new TT.Port_lndex’( 

- one entry for each output port defined for this link 
sequential index j, starting at 1> => null 

Attributes => TT.AttrlbuteJPalrs.Create, 


18 


CMU/SEI-91 -TR-19 







Buffer_Slze => <mes$age buffer bound specified for link>, 

Cluster_ID => TT.CIuster_ID_Range’LAST 

) 

Example: 

1 => new TT.Link_Table_Eutry’( 

Name => SP.Make_Persistent("MAIN.Q1"), 

ID => 1, 

ln_Ports => new TT.PortJndex’f 1 => null), 

Out_Ports => new TT.Port_lndex’( 1 -> null), 

Buffer_Size -> 10, 

ClusterJD => 7T. ClusterJD_Range’LAST 

) 

3.21 Link Attribute Value Assignments 

For each attribute of each link defined in the application description, there must be an assign¬ 
ment of the form: 

TT.Attribute_Palrs.Append 

(Element => (SP.Make_Perslstent(”simple attribute name>"), 

SP. Make_Persistent("<attribute value> “)), 

L => Llnk_Table(<link_table_index>).Atlrlbutes); 

Example: 

TT.Attribute_Pairs. Append 
(Element => (SP. Make_ Persistent ("cluster''), 

SP.Make_Persistent("cl1")), 

L => Link_Table(1).Attributes); 

3.22 Level_Table Entries 

There must be an entry in the Level_Table for each configuration level defined in the applica¬ 
tion description. The Level_Table_Entry assignment shall have the form: 

sequential index n, starting at 1> => new TT.Level_Table_Entry’( 

Number_ot_Processes => <number of processes in Process_Table>, 
Number_of_Llnks => <number of links in Link_Tab!e>, 

Number_of_Connectlons => <number of connection records for this level>, 

Name => SP.Make_Perslstent(<expanded name of configuration level>), 

ID => <n>, 

Processes => ( 

- for each process in the Process_Table 
sequential index m, starting at 1>s> 


CMU/SEI-91 -TR-19 


19 






(The_Process => Process_Tab!e(<m>), 

Cluster ID => <cluster ID or 0 if not active at this level> 

) 

), 

Links => ( 

- for each link in the Link_Table 
sequential index j, starting at 1> => 

(The_Llnk => Unk_Table(<j>), 

Cluster_ID => <cluster ID or 0 if not active at this level>) 

), 

Connections => ( 

- for each port requiring connection at this level 
sequential index k, starting at 1> => 

(The_Port => Process_Table(s>).Ports(<t>), 

The_Llnk => Llnk_Table(<r>), 

Connectlon_Polnt => <v> 

) 

) 

) 

In the Connections assignment, the values s, t, r, and v vary according to the process ports to 
be connected, the links to which they are to be connected, and the link port index where the 
process port is attached to the link. All the variables are positive integer values. The meaning 
of the field ConnectionPoint varies with the type of process port being connected. If the port 
is of type InJPort , then ConnectionPoint is an index into the Out_Poris index of the Link_Ta- 
ble_Entry if the port is of type Out_Port, then Connection_Point is an index into the ln_Ports 
index of the Link_Table_Entry. 

Example: 

1 => new TT.Level_Table_Entry'( 

Number_of_Processes => 3, 

Number_of_Links => 1, 

Number_of_Connections => 3, 

Name -> SP. Make_ Persistent("MA IN"), 

ID => 1, 

Processes => ( 

1 => (The_Process => Process_Table(1), Cluster_ID => 1), 

2 => (The_Process => Process_Table(2), Cluster_ID=> 1), 

3 => (The_Process => Process_Table(3), Cluster JD => 0) 

). 

Links => ( 

1 => (The_Link => Link_Table(1), ClusterJD => 1) 

). 

Connections => ( 

1 => (The_Port => Process_Table(l).Ports(1), 

The_Link => Link_Table(1), 


20 


CMU/SEI-91-TR-19 






Connection_Point => 1 

). 

2 => (The_Port => ProcessJTab!e(2).Ports(1), 

The_Link => Link_Table(1), 

Connection_Point => 1 

). 

3 => (The_Port => Process_Table(3).Ports(1), 

The_Link => NULL, 

Connection_Point => 1 

) 

) 

) 

3.23 Cluster_Table Entries 

There must be an entry in the ClusterJTable for each cluster defined in the application descrip¬ 
tion. The Cluster_Table_Entry record shall have the form: 

<sequential index n, starling at 1> => new TT.CIuster_Table_Entry’( 

ID s> <n>, 

Host_Name => SP.Make_Perslstent( 

"<host processor >", or "localhost" if no compile-time configuration file), 

Connected => FALSE, 

Launched => FALSE, 

Command ~> SP.Make_Perslstent('’"), 

) 

Example: 

1 => new TT.CIuster_ Tab!e_Entry'( 

ID => 1, 

Host_Name => SP.Make_Persistent(”hx.sei.cmu.edu"), 

Connected => FALSE, 

Launched => FALSE, 

Command => SP.Make_Persistent( m '), 


CMU/SEI-91 -TR-19 


21 














References 


[1] Barbacci, M.R., D.L. Doubleday, C.B. Weinstock, M.J. Gardner, J.M. Wing. Durra: A Task- 
Level Description Language Reference Manual (Version 3), SEI Technical Report 
CMU/SEI-91 -TR-18, December, 1991, Software Engineering Institute, Carnegie Mellon 
University, Pittsburgh, Pa. 


CMU/SEI-91-TR-19 


23 





UNLIMITED, UNCLASSIFIED 

SECURITY CLASSIFICATION OP THIS PAOB 


la REPORT SECURITY CLASSIFICAXION 

Unclassified 


REPORT DOCUMENTATION PAGE 


lb. RESTRICTIVE MARKINGS 

None 


2a. SECURITY CLASSIFICATION AUTHORITY 

N/A 


2b. DECLASSIFICATION/DOWNGRADING SCHEDULE 

N/A 


4. PERFORMING ORGANIZATION REPORT NUMBER(S 

CMU/SEI-91 -TR-19 


3. DISTRIBUTION/AVAILABIUTY OF REPORT 

Approved for Public Release 
Distribution Unlimited 


J. MONITORING ORGANIZATION REPORT NUMBER(S) 

ESD-91-TR-19 


6a NAME OF PERFORMING ORGANIZATION 

Software Engineering Institute 


6b. OFFICE SYMBOL 
(if applicable) 

SEI 


7a. NAME OF MONITORING ORGANIZATION 

SEI Joint Program Office 


6c. ADDRESS (City, State and ZIP Code) 

Carnegie Mellon University 
Pittsburgh PA 15213 


7b. ADDRESS (City, State and ZIP Code) 

ESD/AVS 

Hanscom Air Force Base, MA 01731 


8a NAME OFFUNDING/SPONSORING 
ORGANIZATION 

SEI Joint Program Office 


8c. ADDRESS (City, State and ZIP Code) 

Carnegie Mellon University 
Pittsburgh PA 15213 


8b. OFFICE SYMBOL 
(if applicable) 

ESD/AVS 


9. PROCUREMENT INSTRUMENT IDENTIFICATION NUMBER 

FI 962890C0003 


10. SOURCE OF FUNDING NOS. 


PROGRAM 
ELEMENT NO 


• 63756E 


11 TITLE (Include Security Claaalocation) 

A Description of Cluster Code Generated by the Durra Compiler 


12 PERSONAL AUTHOR(S) 

Dennis L. Doubleday, Michael J. Gardner, and Charles B. Weinstock 


PROJECT 

NO. 

N/A 



WORK UNIT 
NO. 

N/A 


13. TYPE OF REPORT 

13b. TIME COVERED 

14. DATE OF REPORT (Yt, Mo. D«y) 

15. RAGE COUNT 

Final 

FROM TO 

December 1991 

23 pp. 



17 COSATI CODES 


FIELD GROUP 



18. SUBJECT TERMS (Continue on revene of necessary and identify by block number) 

code generation 

distributed processing 

configuration management 
distributed processing 

task-description languages 


19. ABSTRACT (Continue an reveoe if neccMary and identify by block number) 

Durra is a language and support environment for the specification and execution of distributed Ada applica¬ 
tions. The Durra programmer specifies the distribution of application components by assigning them to virtual 
nodes called clusters. For each cluster named in an application description, the Durra compiler generates an 
Ada package body with a standardized format. Within the confines of the format, the content of the package 
body varies according to the requirements placed upon the cluster by the Durra application description. The 
cluster-specific package body is compiled and linked with a fixed set of Ada compilation units, common to all 
clusters, to form a multitasking Ada program. The intended audience for this document is Durra application 
developers, who will need an understanding ol the concepts presented here in order to be effective Durra appli¬ 
cation debuggers. 


». DISTRIBUTION/AVAILABIUTY OF ABSTRACT 
UNCLASSIFIED/UNLIMITED SAME AS RPTDT1C USERS | 


(please turn over) 


21. ABSTRACT SECURITY CLASSIFICATION 

Unclassified, Unlimited Distribution 


22*. NAME OF RESPONSIBLE INDIVIDUAL 

John S. Herman, Capt, USAF 


DO FORM 1473, *3 APR 


22b. TELEffiONE NUMBER (Include Am Code) 22c. OFFICE SYMBOL 

(412)268-7631 ESD/AVS (SEI) 


EDITION of 1 JAN 73 IS OBSOLETE 


UNLIMITED, UNCLASSIFIED 
SBCUWTY CLAUncXTION OF THIS 




























































