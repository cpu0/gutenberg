AD-A223 366 


DTIC FILE cop:/ 


REPORT DOCUMENTATION PAGE 







1. AGENCY USE ONLY (Lmm aiMk; 


IWPORTOATE S. report TYPE A« DATES COVERED 

1 Dec 89 to 1 Dec 90 Final 


A-TnvEAWMTrtlE Compiler Validation Summary Report: wavy, 
Ada/L, Version 2.0 (/OPTIMIZE Option), Vax 8550 and VAX 11/785 
(Hosts) to AN/UYK-43 (Target),891201.10212 


•.AUTH0R(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7. PERF0RMM6 ORGAMZATUN NAIiC(S) AND AOORESS(ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm. A266 

Gaithersburg, MD 20899 
USA 


S. SPONSORMGMON(TDRMQ AGENCY NAhC(S) AfO AOORESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 



S. PERFORMMG ORGANIZATION 
REPORT NUMBER 


10. SPONSORMCAyONTTORMC AGENCY 
REPORT NUMBER 



12a. OtSTRSUTONrAVALABUTY STATEICNT 

Approved for public release; distribution unlimited. 


12». nSTRBUnON CODE 


IS. ABSTRACT (UuimmiOO mard$) 

LS Navy, Ada/L, Version 2.0, (/OPTIMIZE Option), Vax 8550 and VAX 11/785 (Hosts) to 
AN/UYK-43 (Target), ACVC 1.10 


S DTIC 

ELECTE|fc 

JUN27.]9gt| I 


m.KAJECTTERMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSl/MIL- 
STD-1815A. Ada Joint Program Office 







1*. SIwiSyj ««s»ication 
OF ABSTRACT 

UNCLASSIFIED 


irNUtyBEROFRAGES 


IS. PRICE CODE 


20. UMITATION OF ABSTRACT 





























AVF control Number: NIST89USN555_4_1.10 
DATE VSR OCMPIEIED BEFORE CN-SITE: 08-11-89 
DATE VSR OCMPLETED AFTER ON-STTE: 12-04-89 
DATE VSR MODIFIED PER AVO OCWMENTS: 12-29-89 
DATE VSR MODIFIED PER AVO OCWMENTS: 04-27-90 


Ada OCMPITER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 891201S1.10212 
U.S. NAVY 

Ada/L, Version 2.0 {/OPTIMIZE Option) 

VAX 8550 and VAX 11/785 Hosts and AN/UYK-43 Target 


Ocnpletion of Qn-Site Testing: 
12-01-89 


Prepared B/: 

Software Standards Validation Group 
National Conputer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Roan A266 
Gciithersburg, Meuryland 20899 


Prepared For: 

Ada Joint Progremi Office 
United States D^artment of Defense 
Washington DC 20301-3081 








¥ 


AVF Control Ntunber: NIST89USN555_A_1.10 
DATE COMPLETED BEFORE ON-SITE: 08-11-89 
DATE COMPLETED AFTER ON-SITE: 12-04-89 

Ada Compiler Validation Stunmary Report: 


Compiler Name: Ada/L, Version 2.0 (/OPTIMIZE Option) 
Certificate Number: 891201S1.10212 


Hosts: VAX 8550 and VAX 11/785 under VMS, Version 5.1 

Target: AN/UYK-43 Bare machine 

Testing Completed 12-01-89 Using ACVC 1.10 


This report has been reviewed and i.s approved. 




Cnief, Information Systems 
Engineering Division (ISED) 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Ada Validation Fac^ity 
Mr. L. Arnold Johi^pt^ 
Manager, Soff-zare Standards 
Validation Group 
National Computer Systems 
LaboratoiTr (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


-'-y' r .>■ — 

Ada Vali'dation'^Drganization 
/ '- Dr. John F. Kr^er 

Institute for Defense Analyses 
Alexandria VA 22311 





/ 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 



Accession For 

gra&i 

DTIC TAB 




Uiiarmo'incod 
Just ir 1 cn t I'Mi 


By. 


I_rlliUt ion/ 

AvaU«hUity'c7dos 

.'Avnli :ir.d/or~ 
! Spoolol 




A 


□ □ 




TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST GLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED.2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST. PROCESSING, AND EVALUATION MODIFICATIONS . .3-6 

3.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Prevalidation.3-7 

3.7.2 Test Method.3-7 

3.7.3 Test Site.3-8 

APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

APPENDIX E COMPILER OPTIONS AS SUPPLIED BY 

U.S. NAVY 






















CHAPTER 1 


INTRODUCTION 


This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of„testing this compiler using the Ada Compiler 
Validation Capability» (ACVC). An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be Implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results The purpose of validating is to ensure 
conformity of the compiled to the Ada Standard by testing that the 
compiler properly implements l»gal language constructs and that it 
identifies and rejects lllejgal language constructs. The testing also 
identifies behavior that isl implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks/ at compile time, at link time, and during 
execution. / 


1-1 







1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to Identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


On-site testing was completed 12-01-89 at Syscon Corporation, 
Washington, D.C. 

1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 






Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada Commentary An Ada Commentary contains all information relevant to 
the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

The agency requesting validation. 

The Ada Validation Facility. The AVF is responsible for 
conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 


The Ada Validation Organization. The AVO has oversight 
authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 
technical support for Ada validations to ensure 
consistent practices. 

A processor for the Ada language. In the context of 
this report, a compiler is any language processor. 


Ada Standard 

Applicant 

AVF 

AVO 


Compiler 


1-3 







including cross-compi1ers , translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 


Passed test 


Target 


Test 


Withdrawn 


An ACVC test for which a compiler generates the expected 
result. 

The computer which executes the code generated by the 
compiler. 

A program that checks a compiler's confomity regarding 
a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

An ACVC test found to be incorrect and not used to check 
test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 


1-4 







Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if It is rejected at link tlme--that 
is, an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support Che self-checking features of Che executable tests. The package 
REPORT provides Che mechanism by which executable tests report PASSED, 
FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check Che contents of text files written by some 
of Che Class C tests for Chapter 14 of the Ada Standard. The operation 


1-5 










of REPORT and CHECK_FIL£ Is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is Inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


1-6 











CHAPTER 2 


CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 

Compiler: Ada/L, Version 2.0 (/OPTIMIZE Option) 

ACVC Version: 1.10 

Certificate Number: 891201S1.10212 

Host Computers: 

Machine: VAX 8550 and VAX 11/785 

Operating System: VMS, Version 5.1 
Memory Size: 48MBytes / ISMBytes 

Target Computer: 

Machine: AN/UYK-43 

Operating System: Bare machine 
Memory Size: 16MBytes 

Communications network: PORTAL/43 


2-1 




2.2 IMPIIMENIAnC3N OffiRACTEKISTICS 


One of the purposes of vcilidating conpilers is to determine the behavior 
of a cxarpiler in those areas of the Ada Standard that permit 
irplementations to differ. Class D and E tests specifically check for 
such inplementation differences. Ifcwever, tests in other classes also 
characterize an inplementation. the tests demonstrate the following 
characteristics; 


a. Capacities. 

(1) Hie cdupiler correctly processes a ccnpilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) Hie ccnpiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A. .H (8 
tests).) 

(3) Hie ccmpiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) Hie ccnpiler correctly processes tests containing recursive 
procedures s^iarately coipiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

(1) Hiis inplementation supports the additional predefined 
types KH3_INTiXitK and IDNG_FICIAT in the package STANDARD. 
(See tests B86001T..Z (7 tests).) 


c. Ejpression evaluation. 

Hie order in vrtiich eopressions are evaluated and the time at 
which constraints are checked are not defined by the language. 
VBiile the ACVC tests do not specifically attenpt to determine 
the order of evaluation of expressions, test results indicate 
the following; 

(1) All of the default initialization expressions for record 
ccmponents are evaluated before any value is checked for 
membership in a conponent’s subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 


2-2 










(3) This inplementation xises no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) Nl)MERIC_EE?PDR is raised for pre-defined integer ccaotparison 
and for pre-defined integer membership. NO EXCEPTION is 
raised for large_int conparison or for large_int 
membership. NUMERrc_ERRQR is raised for small_int 
conparison and for small_int membership vhen an integer 
literal operand in a conparison or membership test is 
outside the range of the base type. (See test C45232A.) 

(5) NUMEKEC_ERROR is raised when a literal operand in a 
fixed-point conparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A. .K (11 
tests).) 


d. Pounding. 

The method by vhich values are rounded in type conversions is 
not defined by the language. While the ACVC tests do not 
specificaLLly att enp t to determine the method of rounding, the 
test results indicate the following: 

(1) The method xised for rxjunding to integer is round away from 
zero. (See tests C46012A..K (11 tests).) 

(2) The method used for rounding to longest integer is round 
away from zero. (See tests C46012A..K (11 tests).) 

(3) The method used for rounding to integer in static \miversal 
reed ejpressions is round toward zero. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERPOR or 
OUNST!PAINr_EBRiDR for an array having a 'IfUSM that exceeds 
STANDARD. INTEGER' LAST ar^or SYSTEM.MAX_INr. For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INr ocaip on ents raises NUMERICJERRDR. 
(See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'I£NG?IH is applied to an array 
1^pe with TNIBGER'IAST + 2 corrponents. (See test C36202A.) 


2-3 











(3) NUMEKEC_ERROR is raised when 'lENGIH is applied to an array 
type with SYSTEM.MAX_INr + 2 cxaiponents. (See test 
C36202B.) 

(4) A packed BOOIEVN array having a 'IINGIH exceeding 
INTEXSER'IAST raises NUMERIC EEWQR. (See test C52103X.) 

-M. ' 

(5) A packed two-dimensional BOOLEAN array with more than 
INTEGER'lAST conponents raises NUMERIC_ERKDR when the array 
t^pe is declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER'lAST may raise NUMERIC_ERRDR or OONSTRAENT_ERRQR 
either when decleured or assigned. Alternatively, an 
implementation may acc^jt the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises no exception. (See test E52103Y.) 

(7) In assigning cne-dimensional array types, the eapression is 
evaluated in its entirety before 0CNSTE?AINr_EFK3R is raised 
when checking vhether the expression's subtype is 
conpatible with the target's subtype. (See test C52013A.) 

(8) In assigning two-dimensional array types, the expression is 
not evalxiated in its entirety before OCNSTRAINr_ERROR is 
raised vhen checking vhether the expression's subtype is 
cdnpatible with the target's subtype. (See test C52013A.) 

f. Discriminated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
aajSTRAINr_EI5RCR is raised vhen checking vhether the 
expression's subtype is ccnpatible with the target's 
subtype. (See test C52013A.) 


g. A g gregates. 

(1) In the evaluation of a multi-diroensicnal ag g regate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
all choices are evciluated before being checked for 
identiccil bounds. (See test E43212B.) 

(3) All choices were not evaluated before aONSTRAINr_ERROR is 
raised when a bound in a non-null range of a non-null 
aggregate does not belcng to an index subtype. (See test 
E43211B.) 


2-4 











h. Pragmas. 


(1) Ihe pragma INLINE is si:;ported for functions or procedures. 
(See tests IA3004A. .B (2 tests), EA3004C. .D (2 tests), and 
Ca3004E..F (2 tests).) 

i. Generics. 

(1) Generic specifications and bodies can be conpiled in 
separate oonpilations. (See tests cai012A, C3^009C, 
CA2009F, BC3204C, and BC3205D.) 

(2) Generic ijnit bodies and their subunits can be catpiled in 
separate ccnpilations. (See test CA301IA.) 

(3) Generic subprogram declarations and bodies can be conpiled 
in separate ccnpilations. (See tests CA1012A and CA2009F.) 

(4) Generic library subprogram specifications and bodies can be 
conpiled in separate conpilations. (See test CM012A.) 

(5) Generic non-library subprogram bodies can be conpiled in 
s^mate conpilations f rcni their stubs. (See test 
CA2009F.) 

(6) Generic paoJcage declarations and bodies can be conpiled in 
s^jarate conpilations. (See tests CM009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies can be 
conpiled in s^^arate conpilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits can be 
conpiled in s^>arate conpilations. (See test CA2009C.) 

(9) Generic unit bodies and their sUbunits can be conpiled in 
separate conpilations. (See test 0^011^.) 


j. Irput and output. 

(1) The package SEiyJE2frnAL_I0 cannot be instantiated with 

unconstrained array types eund record types with 

discriminants without defaults. (See tests AE2101C, 

EE2201D, and EE220IE.) 

(2) The package DIRECT_IO cannot be instantiated with 

unconstrained array types or record types with 

discriminants without defaults. (See tests AE2101H, 






EE2401D, and EE2401G.) 

(3) USE_EE®CR is raised v4ien £iode IN_FIIE is not si;^^rted for 
the operation of C3?EATE for SBQUE2W?IAL_I0. (See test 
CE2102D.) 

(4) USE_ERROR is raised vSien Mode is not si^^rted for 

the operation of CREATE for DIRECr_IO. (See test CE2102I.) 

(5) Modes IN_FHZ, 0[JT_FIIE/ and INCtJr_FnjE are st^ported for 
DIRECr_IO. (See tests CE2102F, CE2102J, CE2102R, CE2102T, 
and CE2102V.) 

(6) Modes IN_FILE and OOT_FII£ are supported for text files. 
(See tests CE3102I..K (3 tests).) 

(7) RESET and DELETE operations are supported for 
SEQUEMrrAL_IO. (See tests CE2102G and CE2102X.) 

(8) RESET and DELETE operations are svj^^ported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(9) RESET and operations are supported for text files. 

(See tests CE3102F. .G (2 tests), CE3104C, CE3110A, and 
CE3114A.) 

(10) Overwriting to a sequential file does not truncate the 
file. (See test CE2208B.) 

(11) Tenporary sequential files are given names and deleted vdien 
closed. (See test CE2108A.) 

(12) Tenporary direct files are given names and deleted when 
closed. (See test CE2108C.) 

(13) Tenporary text files are given names and deleted v^en 
closed. (See test CE3112A.) 

(14) Only one internal file can be associated with each external 
file for sequential files vhen reading only. (See test 
CE2107A.) 

(15) Only one intemad file can be associated with each external 
file for sequential files vhen writing. (See tests 
CE2107B..E (4 tests), CE2110B, and CE2111D.) 

(16) Only one internal file can be associated with each external 
file for direct files when reading. (See test CE2107F.) 

(17) Only one internal file can be associated with each external 
file for direct files \dien writing. (See tests CE2107G. .H 
(2 tests), CE2110D and CE2111H.) 


2-6 











(18) Only one internal file can be associated with each external 
file for text files vhen reading only. (See CE3111A.) 


(19) Only one internal file can be associated with each external 
file for text files vhen reading or writing. (See tests 
CE3111B, CE3111D..E (2 tests), CE3114B, aid CE3115A.) 


2-7 










CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 471 tests were Inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. Modifications to the code, processing, 
or grading for 41 tests were required to successfully demonstrate the 
test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

127 

1132 

1858 

17 

22 

46 

3202 

Inapplicable 

2 

6 

457 

0 

6 

0 

471 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 







3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

_^ 

_2 

4 


6 _7 

CHAPTER 

8 9 10 

_Ii 

12 11 

14 

TOTAL 

Passed 

194 

573 

544 

245 

172 

99 

161 

332 137 

36 

252 

182 

275 

3202 

Inapplicable 

18 

76 

136 

3 

0 

0 

5 

0 0 

0 

0 

187 

46 

471 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD50110 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 

E28005C 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 






See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 471 
tests were inapplicable for the reasons indicated: 

a. The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 


3-2 









C45241L..Y 

(14 

tests) 

C45321L..Y 

(14 

tests) 

C45421L. .Y 

(14 

tests) 

C45521L..Z 

(15 

tests) 

C45524L. .Z 

(15 

tests) 

C45621L. .Z 

(15 

tests) 

C45641L..Y 

(14 

tests) 

C46012L,.Z 

(15 

tests) 


b. C24113H, C24113I, C24113J. C24113K (4 tests) are not applicable 
because this implementation supports a line length of 120 
characters. 

c. C35508I, C35508J, C35508M, and C35508N are not applicable because 
they include enumeration representation clauses for BOOLEAN types 
in which the representation values are other than (FALSE -> 0, TRUE 
—> 1). Under the terms of AI-00325, this implementation is not 
required to support such representation clauses. 

d. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SH0RT_FL0AT. 

e. The following 16 tests are not applicable because this 
implementation does not support a predefined type SHORT_INTEGER; 

C45231B C45304B C45502B C45503B C4550iR 

C45504E C45611B C45613B C45614B C45631B 

C45632B B52004E C55B07B B55B09D B86001V 

CD7101E 

f. C45531M. .P (4 tests), C45532M..P (4 tests) are not applicable 
because this implementation does not support a 48 bit integer 
machine size. 

g. B86001X, C45231D, and CD7101G (3 tests) are not applicable because 
this implementation does not support any predefined integer type 
with a name other than INTEGER or LONG_INTEGER. 

h. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT, or 
L0NG_FL0AT. 

i. C86001F is not applicable because, for this implementation, the 
package TEXT_I0 is dependent upon package SYSTEM. This test 
recompiles package SYSTEM, making package TEXT_I0, and hence 
package REPORT, obsolete. Because of the recompilation, the test 
compiles but fails to link. 

j. GD1009C, CD2A41A, CD2A41B, CD2A41E, CD2A42A, GD2A42B, CD2A42C, 
CD2A42D, CD2A42E, CD2A42F, CD2A42G, CD2A42H, CD2A42I, CD2A42J (14 
tests) are not applicable becavise this implementation does not 
support 'SIZE representations for floating-point types. 

k. CD1009N, CD1009X, GD1009Y, CD1009Z, CD1C03H, CD1C04E, CD4031A, 

CD4041A, CD4051A, CD4051B. CD4051C, CD4051D, CD7204C, ED1D04A (14 
tests)are not applicable because record representation clauses are 


3-3 







not supported. 


l. CD1C04C is not applicable because this implementation does net 
support 'SMALL specification clause for a derived fixed point type 
when it is inherited from the parent. 

m. CD2A51A, CD2A51B, CD2A51D, CD2A51E, CD2A52A, CD2A52B, CD2A52C, 

CD2A52D, CD2A52G, CD2A52H. CD2A52I, CD2A52J, CD2A53A, CD2A53B, 

CD2A53C. CD2A53D. CD2A53E, CD2A54A, CD2A54B, CD2A54C, CD2A54D, 

CD2A54G, CD2A54H, CD2A54I, CD2A54J. ED2A56A (26 tests) are not 
applicable because this implementation does not support 'SIZE 
representations for fixed-point types. 

n. CD2A61A, CD2A61B, CD2A61C, CD2A61D, CD2A61E. CD2A61F, CD2A61G, 

CD2A61H. CD2A61I. CD2A61J, CD2A61K, CD2A61L, CD2A62A, CD2A62B, 

CD2A62C, CD2A64A. CD2A64B. CD2A64C, CD2A64D, CD2A65A, CD2A65B. 

CD2A6SC, CD2A65D (23 tests) are not applicable because this 

implementation does not support size specifications for array types 
that imply compression of component storage. 

o. CD2A71A, CD2A71B. CD2A71C, CD2A71D, CD2A72A, CD2A72B, CD2A72C, 

CD2A72D, CD2A74A. CD2A74B. CD2A74C, CD2A74D, CD2A75A, CD2A75B, 

CD2A7SC, CD2A7SD (16 tests) are not applicable because this 

implementation does not support the 'SIZE specification for record 
types implying compression of component storage. 

p. CD2A84B, CD2A84C. CD2A84D, CD2A84E, CD2A84F, CD2A84G, CD2A84H, 

C02A84I, C02A84K, CD2A84L (10 tests) are not applicable because 
'SIZE representation clauses for access types are not supported. 

q. CD2A91A, CD2A91B, CD2A91C, CD2A91D, CD2A91E (5 tests) are not 

applicable because this implementation does not support the 'SIZE 
representation clauses for task types. 

r. CD5003B, CD5003C. CD5003D, CD5003E, CD5003F, CD5003G, CD5003H, 

CD5003I, CD5011A, CD5011C, CD5011E, CD5011G, CD5011I, CD5011K, 

CD5011M. CD5011Q, CD5012A, CD5012B, CD5012E, CD5012F, CD5012I, 

CD5012J. CD5012M, CD5013A, CD5013C. CD5013E, CD5013G, CD5013I. 

CD5013K, CD5013M, CD50130, CD5013S, CD5014A, CD5014C, CD5014E, 

CD5014G, CD5014I, CD5014K, CD5014M, CD50140, CD5014S, CD5014T, 

CDS014V, C05014X, CD5014Y, CD5014Z (46 tests) are not applicable 
because this implementation does not support 'ADDRESS clauses for 
variables. 

s. CD5011B, CD5011D, CD5011F, CD5011H, CD5011L, CD5011N, CD5011R, 

CD5011S, CD5012C, CD5012D, CD5012G, CD5012H. CD5012L, CD5013B, 

CD5013D, CD5013F, CD5013H, CD5013L, CD5013N, CD5013R, CD5014B, 

CD5014D, CD5014F, CD5014H, CD5014J, CD5014L, CD5014N, CD5014R, 

CDS014U, CD5014W (30 tests) are not applicable because this 

implementation does not support 'ADDRESS clauses for constants. 

t. AE2101C, EE2201D, and EE2201E use instantiations of package 


3-4 





SEQUENTIAL_IO with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this compiler. 

u. AE2101H, EE2401D, and EE2401G use instantiations of package 

DIRECT_IO with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this compiler. 

V. CE2102E is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for SEQUENTIAL_IO. 

w. CE2102F is inapplicable because this implementation supports CREATE 
with IN0UT_F1LE mode for DIRECT_IO. 

X. CE2102J is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for D1RECT_I0. 

y. CE2102N is Inapplicable because this implementation supports OPEN 
with IN_FILE mode for SEQUENTIAL_IO. 

z. CE21020 is Inapplicable because this implementation supports RESET 
with IN_FILE mode for SEQUENTIAL_IO. 

aa. CE2102P is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for SEQUENTIAL_I0. 

ab. CE2102Q is inapplicable because this implementation supports RESET 
with OUT_FILE mode for SEQUENT1AL_I0. 

ac. CE2102R is Inapplicable because this implementation supports OPEN 
with INOUT_FILE mode for DIRECT_IO. 

ad. CE2102S is inapplicable because this implementation supports RESET 
with INOUT_FILE mode for DIRECT_IO. 

ae. CE2102T is inapplicable because this implementation supports OPEN 
with IN_FILE mode for DIRECT_IO. 

af. CE2102U is inapplicable because this implementation supports RESET 
with IN_FILE mode for DIRECT_IO. 

ag. CE2102V is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for DIRECT_IO. 

ah. CE2102W is inapplicable because this implementation supports RESET 
with OUT_FILE mode for DIRECT_IO. 

ai. CE2105A is inapplicable because CREATE with IN_FILE mode is not 
supported by this implementation for SEQUENTIAL_IO. 

aj. CE2105B is inapplicable because CREATE with IN_FILE mode is not 


3-5 








supported by this implementation for DIRECT_IO. 

ak. CE2107A..E (5 tests), CE2107L, CE2110B CE2111D are not applicable 
because multiple internal files cannot be associated with the same 
external file when one or more files is reading or writing for 
sequential files. The proper exception is raised when multiple 
access is attempted. 

al. CE2107F is not applicable because multiple internal files cannot be 
associated with the same external file when one or more files is 
reading for direct files. 

am. CE2107G..H (2 tests), CE21100, and CE2111H are not applicable 

because multiple internal files cannot be associated with the same 
external file when one or more files is writing for direct files. 
The proper exception is raised when multiple access is attempted. 

an. CE3102F is Inapplicable because text file RESET is supported by 
this implementation. 

ao. CE3102G is Inapplicable because text file deletion of an external 
file is supported by this implementation. 

ap. CE3102I is inapplicable because text file CREATE with OUT_FILE mode 
is supported by this implementation. 

aq. CE3102J is inapplicable because text file OPEN with IN_FILE mode is 
supported by this implementation. 

ar. CE3102K is inapplicable because text file OPEN with 0UT_F1LE mode 
is not supported by this implementation. 

as. CE3109A is inapplicable because text file CREATE with IN_FILE mode 
is not supported by this implementation. 

at. CE3111A..B (two tests), CE3111D..E (2 tests), CE3114B, and CE3115A 
are not applicable because multiple internal files cannot be 
associated with the same external file when one or more files is 
reading or writing for text files. The proper exception is raised 
when multiple access is attempted. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some ^ests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
Implementation behavior. Modifications are made by the AVF in cases 
where legitimate Implementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 


3-6 





executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception Instead of another). 

Modifications were required for 41 tests. 

The following tests contain no pragma elaboarate. Therefore, It Is 
possible that the package body may be elaborated before the package body 
of REPORT. Each of the following tests were modified with the addition 
of a pragma elaborate statement and with the modification report PASS: 

C39005A CD7004C CD7005E CD7006E 

CC3126A was modified by inserting the initializing expression 
(others -> 'H')" into line numbered 117. With this modification, this 
test reports PASS. 

For this implementation CD2C11A and CD2C11B were modified by inserting 
the initialization 5.0" into variable W's declaration (note that W 

is declared along with one or two other variables in a single object 
declaration; the initialization is not needed for them, but does not 
affect their use). With this modification, these tests report PASS. 

The following 34 tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 

B28003A B28003C B2A003A B33201C B33202C B33203C B33301B 

B37106A B3720U B37301I B38003A B38003B B38009A B38009B 

B4400U B44004A B5100U B54A01L B91001H B95063A BB1006B 

BC1002A BC1102A BC1109A BC1109B BC1109C BC1109D BC1201F 

BC1201G BC1201H BC1201I BC1201J BC1201L BC3013A 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the Ada/L, Version 2.0 (/OPTIMIZE Option) compiler was 
submitted to the AVF by the applicant for review. Analysis of these 
results demonstrated that the compiler successfully passed all 
applicable tests, and the compiler exhibited the expected behavior on 
all inapplicable tests. 


3.7.2 Test Method 

Testing of the Ada/L, Version 2.0 (/OPTIMIZE Option) compiler using ACVC 
Version 1.10 was conducted on-site by a validation team from the AVF. 
The configuration in which the testing was performed is described by the 
following designations of hardware and software components: 

Host computers: VAX 8550 and VAX 11/785 


3-7 









VMS, Version 5.1 
AN/UYK-43 
Bare machine 

Ada/L, Version 2.0 (/OPTIMIZE Option;■ 
LNK L 

imp'l 

EXP_L 
PORTAL/43 

RTEXEC Version 2.0/RTLIB Version 2.0 

The host and target computers were linked via PORTAL/43 

A magnetic tape containing all tests except for withdrawn tests was 
taken on-site by the validation team for processing. Tests that make 
use of implementation-specific values were customized before being 
written to the magnetic tape. Tests requiring modifications during the 
prevalidation testing were modified on-site. 


Host operating system: 
Target computer: 

Target operating system: 
Compiler: 

Linker: 

Importer: 

Exporter: 

Loader/Downloader: 
Runtime System: 


TEST INFORMATION 

The contents of the magnetic tape were loaded directly onto the host 
computers. 

The ACVC Version 1.10 was compiled and linked on the host VAX 8550. All 
executable tests were transferred to the AN/UYK-43 using PORTAL/43 and 
were run on the AN/UYK-43. Results were uploaded from the target system 
to the VAX 8550 stored on disk and printed. 

The ACVC Version 1.10 was compiled and linked on the host VAX 11/785. 
All executable tests were transferred to the AN/UYK-43 using PORTAL/43 
and were run on the AN/UYK-43. Results were uploaded from the target 
system to the VAX 11/785 stored on disk and printed. 

The compiler was tested using command scripts provided by U.S. NAVY and 
reviewed by the validation team. See Appendix E for a complete listing 
of the compiler options for this implementation. The compiler options 
invoked during this test were: 

For A, C, D, L Tests: 

/SUMMARY /OPTIMIZE /SOURCE 

For B, E Tests: 

/SUMMARY /OPTIMIZE /SOURCE 

Unless explicitly stated the following are the default options: 

N0_S0URCE, NO_MACHINE, NO_ATTRIBUTE. NO_CROSS_REFEPENCE, 
N0_DIAGN0STICS, NO_SUMMARY, NO_NOTES, PRIVATE, CONTAINER_GENERATION, 
C0DE_0N_WARNING, LIST, NO MEASURE, DEBUG, NO_OPTIMIZE, CHECKS. 


3-8 









No_EXEan:ivE , no_rte_only 

Tests were compiled, linked, and executed as appropriate using a single 
computer. Test output, compilation listings, and Job logs were captured 
on magnetic tape and archived at the AVF. The listings were examined 
on-slte by the validation team. 


3.7.3 Test Site 

Testing was conducted at Syscon Corporation, Washington, D.C. and was 
completed on 12-01-89. 


3-9 








APPENDIX A 


DECLARATION OF CONFORMANCE 


U.S. NAVY has submitted the following Declaration of Conformance 
concerning the Ada/L, Version 2.0 (/OPTIMIZE Option). 


A-1 








DECLARATION OF CONFORMANCE 


Customer: U.S. NAVY 

Ada Validation Facility: 


Ada Validation Facility 
National Computer Systems Laboratory (NCSL) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


Ada Compiler Validation Capability {ACVC) Version: 1.10 


Ada Implementation: 
Host Computer Systems: 
Host OS and Version: 
Target Computer System 
Target OS and Version: 


Ada/L, Version 2.0 (/OPTIMIZE Option) 

VAX 8550 and VAX 11/785 

VMS, Version 5.1 

AN/UYK-43 

Bare machine 


Customer’s Declaration 

I, the undersigned, representing U.S. NAVY, declare that the U.S. NAVY 
has no knowledge of deliberate deviations from the Ada Language Standard 
A.NSI/MIL-STD-1^5A in the implementation(s) listed, in this declarations. 

I ^ Date, 

^gnature of : 


Mgnature 
William L. Wilder, 
U.S. NAVY 








APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed Implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. Th 
implementation-dependent characteristics of the Ada/L, Version 2. 
(/OPTIMIZE Option) compiler, as described in this Appendix, are provided 
by U.S. NAVY. Unless specifically noted otherwise, references in this 
appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are not 
a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -2_147_A83_647 .. 2_147_483_647; 
type LONG_INTEGER is range 

- 9_223_372_036_854_775_807 .. 9_223_372_036_854_775_807; 

type FLOAT is digits 6 range 

- (16#0.FF_FFF8#E63) .. (16#0.FF_FFF8#E63); 
type LONG_FLOAT is digits 15 range 

- (16#0.FF_FFFF_FFFF_FFE0#E63) .. (16#0.FF_FFFF_FFFF_FFE0#E63); 

type DURATION is delta 2.0 ** (-14) range 
-131_071.0 .. 131 071.0; 


end STANDARD; 


B-1 


O (D 










Ada/L PSS Handbook 


Version 2.0C 
30 September 1989 


Section 6 

The Ada Language for the AN/UYK-43 


The source language accepted by the compiler is Ada, as 
described in the Military Standard, Ada Programming Language, 
ANSI/MIL-STD-iai5A-19a3, 17 February 1983 ("Ada Language 
Reference Manual"). 

The Ada definition permits certain implementation 
dependencies. Each Ada implementation is required to supply a 
complete description of its dependencies, to be thought o£ as 
Appendix F to the Ada Language Reference Manual. This section is 
that description for the AN/UYK-43 target. 


6.1 Options I 

There are several compiler options provided by all ALS/N 
Compilers that directly affect the pragmas defined in the Ada 
Language Reference Manual. These compiler options currently 
include the CHECKS and OPTIMIZE options which affect the SUPPRESS 
and OPTIMIZE pragmas, respectively. A complete list of ALS/N 
Compiler options can be found in Section 10.2. 

The CHECKS option enables all run-time error checking for 
the source file being compiled, which can contain one or more 
compilation units. This allows the SUPPRESS pragma to be used in 
suppressing the run-time checks discussed in the Ada Language 
Reference Manual, but note that the SUPPRESS pragma(s) must be 
applied to each compilation unit. The NO CHECKS option disables 
all run-time error checking for all compilation units within the 
source file and is equivalent to SUPPRESSing all run-time checks 
within every compilation unit. 

The OPTIMIZE option enables all compile-time optimizations 
for the source file being compiled, which can contain one or more 
compilation units. This allows the OPTIMIZE pragma to request 
either TIME-oriented or SPACE-oriented optimizations be 
performed, but note that the OPTIMIZE pragma must be applied to 
each compilation unit. If the OPTIMIZE pragma is not present, 
the ALS/N Compiler's Global Optimizer tends to optimize for TIME 
over SPACE. The NO OPTIMIZE option disables all compile-time 
optimizations for aXl compilation units within the source file 
regardless of whether or not the OPTIMIZE pragma is present. 

In addition to those compiler options normally provided by 
the ALS/N Common Ada Baseline compilers, the Ada/L compiler also 
implements the EXECUTIVE, DEBUG, and MEASURE options. 

The EXECUTIVE compiler option shall enable processing of the 


6.1 Options 


6-01 










Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


I EXECUTIVE pragma. The EXECUTIVE compiler option also allows WITH 
I of units compiled with the RTEjONLY option. If NONEXECUTIVE is 
specified on the command line, the pragma will be Ignored and 
will have no effect on the generated code. 

The DEBUG compiler option shall enable processing of the 
pragma DEBUG to provide debugging support. If NO_DEBUG is 
specified, the DEBUG pragmas shall have no effect. Program units 
containing DEBUG pragmas and compiled with the DEBUG compiler 
option may be linked with program units containing DEBUG pragmas 
and compiled with the NO_DEBUG option; only those program units 
compiled with the DEBUG option shall have additional DEBUG 
support. 

The MEASURE compiler option shall enable processing of the 
pragma MEASURE to provide debugging support. If NO_M£ASURE is 
specified, the MEASURE pragmas shall have no effect. Program 
units containing MEASURE pragmas and compiled with the MEASURE 
compiler option may be linked with program units containing 
MEASURE pragmas and compiled with the NO_MEASURE option; only 
those program units compiled with the MEASURE option shall have 
additional MEASURE support. 


6-02 


6.1 


Options 





Ada/L PSE Handbook 


Version 2.OC 
30 September 1989 


6.2 Pragmas 

These paragraphs describe the pragmas recognized and 
processed by the Ada/L compiler. The syntax defined in Section 
2.8 of the Ada Language Reference Manual allows a pragma as the 
only element in a compilation unit, before a compilation unit, at 
defined places within a compilation unit, or following a 
compilation unit. Ada/L associates pragmas with compilation 
units as follows: 

a. If a pragma appears before any compilation unit in a 
compilation, it will affect all following compilation 
units, as specified below and in section 2.8 of the 
Ada Language Reference Manual. 

b. If a pragma appears inside a compilation unit, it 
will be associated with that compilation unit, and 
with the listings associated with that compilation 
unit, as described in the Ada Language Reference 
Manual, or below. 

c. If a pragma follows a compilation unit, it will be 
associated with the preceding compilation unit, and 
effects of the pragma will be found in the container 
of that compilation unit and in the listings 
associated with that container. 


6.2.1 Language-Defined Pragmas 

This paragraph specifies implementation-specific changes to 
those pragmas described in Appendix B of the Ada Language 
Reference Manual. Unmentioned pragmas are implemented as defined 
in the Ada Language Reference Manual. 

The pragmas MEMORY_SIZE (arg), STORAGE_UNIT (arg), and 
SYSTEM_NAME (arg) must appear at the start of the first 
compilation when creating a program library, as opposed to the 
start of any compilation unit. If they appear elsewhere, a 
diagnostic of severity WARMING is generated and the pragma has no 
effect. 

pragma INLINE (arg {,arg,...}); 

The arguments designate subprograms. There are three I 
instances in which the INLINE pragma is ignored. Each 
of these cases produces a warning message which states 
that the INLINE did not occur. 

a. If a call to an INLINEd subprogram is 
compiled before the actual body of the 
subprogram has been compiled (a routine 
call is made instead). 


6.2.1 Language-Defined Pragmas 


6-03 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


b. If the INLINEd subprograms compilation unit 
depends on the compilation unit of its 
caller (a routine call is made instead). 

c. If an immediately recursive subprogram call 
is made within the body of the INLINEd 
subprogram (the pragma INLINE is ignored 
entirely). 

pragma INTERFACE (arg, arg); 

The first argument specifies the language and type of 
interface to be used in calls used to the externally 
supplied subprogram, specified by the second argument. 
The allowed values for the first argument (language 
name) are MACRO_NORMAL and MACRO_QUICK. MACRO_NORMAL 
indicates that parcuneters will be passed on the stack 
and the calling conventions used for normal Ada 
subprogram calls (see Section 3.4.14.2 of 
Ada/L_Intf Spec]) will apply. MACRO_QCJICK is used in 
RTLIB routines to indicate that parameters are passed 
in registers. See Section 7.7 for details on the space 
required to pass various types of parameters. 

The user must ensure that an assembly-language body 
container will exist in the library before linking. 

pragma OPTIM12E (arg); 

The argument is either TIME or SPACE. The default is 
SPACE. This pragma will be effective only when the 
OPTIMIZE option has been given to the compiler, as 
described in Appendix 20 of [ALS/N_Spec]. 

pragma PRIORITY (arg); 

The argument is an integer static expression in the 
range 0..15, where 0 is the lowest use-specifiable task 
priority and 15 is the highest. If the value of the 
argument is out of range, the pragma will have no 
effect other than to generate a WARNING diagnostic. A 
value of zero will be used if priority is not defined. 
The pragma will have no effect when not specified in a 
task (type) specification or the outermost declarative 
I part of a subprogram. If the pragma appears in the 
I declarative part of a subprogram, it will have no 

effect unless that subprogram is designated as the main 
subprogr^ull at link time. 

pragma SUPPRESS (arg {,arg}); 

This pragma is unchanged with the following exceptions: 


6-04 


6.2.1 Language-Defined Pragmas 




Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Suppression of OVERFLOW_CHECK applies only to integer 
operations; and a SUPPRESS pragma has effect only 
within the compilation unit in which it appears, except 
that suppression of ELABORATION_CHECK applied at the 
declaration of a subprogram or task unit applies to all 
calls or activations. 


6.2.2 Implementation-Defined Pragmas 

This paragraph describes the use and meaning of those 
pragmas recognized by Ada/L which are not specified in Appendix B 
of the Ada Language Reference Manual. 

pragma DEBUG; 

To be supplied. 

pragma EXECUTIVE [(arg)]; 

This pragma allows the user to specify that a I 

compilation unit is to run in the executive state of I 
the machine and/or utilize privileged instructions. I 

The pragma has no effect if the Compiler option I 

NO EXECUTIVE is enabled, either explicitly or by j 

deFault. I 

If PRAGMA EXECUTIVE is specified without an argument, I 

executive state is in effect for the compilation unit I 

and the code generator does not generate privileged I 
instructions for the compilation unit. If PRAGMA I 

EXECUTIVE (INHERIT) is specified, a subprogram in the I 

compilation unit inherits the state of its caller and I 

the code generator does not generate privileged I 

instructions for the compilation unit. If PRAGMA I 

EXECUTIVE (PRIVILEGED) is specified, the executive I 

state is in effect and the code generator may generate I 
privileged instructions for the compilation unit. I 

Currently, the Ada/L compiler does not generate such I 
instructions. In the absence of PRAGMA EXECUTIVE, the I 
compilation unit executes in task state and the code I 
generator does not generate privileged instructions. I 

If PRAGMA EXECUTIVE (INTERRUPT_CMR) is specified, the I 
Ada/L compiler generates code which uses executive I 

state registers instead of task state registers (i.e. I 
SCI instead of SCT). 1 

PRAGMA EXECUTIVE is applied once per compilation unit, I 
so its scope is the entire compilation unit. PRAGMA I 
EXECUTIVE may appear between the context clause and the I 
outermost unit. If there is no context clause, the I 
pragma EXECUTIVE must appear within that unit before I 
the first declaration or statement. The placement of I 


6.2.2 Implementation-Defined Pragmas 


6-05 




Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


I the pragma before the context clause has no effect on 
I any or all following compilation units. If PRAGMA 
I EXECUTIVE appears in the specification of a compilation 
I unit/ it must also appear in the body of that unit, and 
I vice versa. If the pragma appears in a specification 
I but is absent from the body, the user is warned and the 
I pragma is effective. If the pragma appears in the body 
I of a compilation unit, but is absent from the 
I corresponding specification, the user is warned and the 
I pragma has no effect. PRAGMA EXECUTIVE does not 
I propagate to subunits. If a subunit is compiled 
I without PRAGMA EXECUTIVE and the parent of the subunit 
I is compiled with PRAGMA EXECUTIVE, the user is warned 
I and PRAGMA EXECUTIVE has no effect on the subunit. 

pragma FAST_INTERRUPT_ENTRy (argl, arg2); 

I To be supplied. 

pragma MEASURE (extraction_set, [arg,...]); 

To be supplied. 

pragma STATIC; 

To be supplied. 

pragma TITLE (arg); 

This is a listing control pragma. It takes a single 
argument of type string. The string specified will 
appear on the second line of each page of every listing 
produced for the compilation unit. At most one such 
pragma may appear for any compilation unit, and it must 
be the first lexical unit in the compilation unit 
(excluding comments). 

pragma TRIVIAL_ENTRY (NAME; entry_3imple_name); 

To be supplied 

pragma UNMAPPED (arg [arg,,...]); 

The effect of this pragma is for unmapped (i.e., not 
consistently mapped within the virtual space) 
allocation of data in a compilation unit. The 
arguments of this pragma are access types to be 
unmapped. If a program tries to allocate more UNMAPPED 
space than is available in the physical configuration, 
then STORAGE_ERROR will be raised at run-time. Pragma 
UNMAPPED must appear in the same declarative region as 
the type and after the type declaration. 


6-06 


6.2.2 Implementation-Defined Pragmas 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.2.3 Scope of Pragmas 

The scope for each pragma previously described as differing 

from the Ada Language Reference Manual is given below: 

DEBUG To be supplied. 

EXECUTIVE Applies to the compilation unit in which the pragma 
appearSf i.e., to all subprograms and tasks within 
the unit. Elaboration code is not affected. 

The pragma is not propagated from specifications 
to bodies/ or from bodies to subunits. The pragma 
must appear consistently in the specification, 

body, 

and subunits associated with a library unit. 

FAST_INTERRUPT_ENTRY 

To be supplied. 

INLINE Applies only to subprogram names in its 

arguments. If the argument is an overloaded 
subprogram name, the INLINE pragma applies to 
all definitions of that subprogram name which 
appear in the same declarative part as the 
INLINE pragma. 

INTERFACE Applies to all invocations of the named 
imported subprogram. 

MEASURE To be supplied. 

MEMORY_SIZE Applies to the entire Program Library in 
which the pragma appears. 

OPTIMIZE Applies to the entire compilation unit in 

which the pragma appears. 

PRIORITY Applies to the task specification in which it 

appears, or to the environment task if it 
appears in the main subprogram. 

STATIC To be supplied. 

STORAGE_UNIT Applies to the entire Program Library in 
~ which the pragma appears. 

SYSTEM_NAM£ Applies to the entire Program Library in 
which the pragma appears. 

SUPPRESS Applies to the block or body that contains 

the declarative part in which the pragma 

appears. 


6.2.3 Scope of Pragmas 


6-07 






Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


TITLE 

TRIVIAL_ENTRy 

UNMAPPED 


Applies to the compilation unit in 
which the pragma appears. 

To be supplied. 

Applies to all objects of the access type 
named as arguments. 


6-08 


6.2.3 Scope of Pragmas 






Ada/L PSE Handbook 


Version 2.OC 
30 September 1989 


6.3 Attributes 

There is an implementation-defined attribute in addition to I 
the predefined attributes found in Appendix A of the Ada Language 
Reference Manual. 

p'PHYSICAL_ADDRESS for a prefix p that denotes a data 
object; 

Yields a value of type system.physical_address, which corresponds 
to the absolute address in physical memory of the object named by 
p. This attribute is used to support operations associated with 
the pragma UNMAPPED. 

The following notes augment the language-required I 

definitions of the predefined attributes found in Appendix A of 
the Ada Language Reference Manual. 

T'MACHINE_EMAX 

T'MACHINE_EMIN 

T'MACHINE_MANTISSA 

T'MACHINE_OVERFLOWS 

T’MACHINE_RADIX 

T’MACHINE ROUNDS 


is 

63. 

is 

-64. 

is 

6. 

is 

TRUE. 

is 

16. 

is 

FALSE 


6.3 Attributes 


6-09 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.4 Predefined Language Environment 

! The predefined Ada language environment consists of the 

I packages STANDARD and SYSTEM, which are described below. 


6.4.1 Package STANDARD 

The package STANDARD contains the following definitions in 
addition to those specified in Appendix C of the Ada Language 
Reference Manual. 

PACKAGE STANDARD IS 

TYPE boolean IS (false, true); 

— The type universal_integer is predefined. 

TYPE integer IS RANGE -2_147_483_647 .. 2_147_483_647; 

-(2**31 - 1) .. (2**31 - 1) 

TYPE long_integer IS RANGE 

-9_223_372_036_854_775_807 .. 9_223_372_036_854_775_807; 

TYPE float IS DIGITS 6 RANGE 

-(16#0.FP_PFF8#E63) .. (16#0.FF_FFF8#E63); 

TYPE long float IS DIGITS 15 RANGE 

-(16#0.FP FFFF FFFF PFE0#E63) .. 

(16#0.PP”PPPF“PPPP“PFE0#E63); 

— Predefined subtypes; 

SUBTYPE natural IS integer RANGE 0 .. integer'LAST; 

SUBTYPE positive IS integer RANGE 1 .. integer'LAST; 

— Predefined string type: 

TYPE string IS ARRAY (positive RANGE <>) OP character; 

PRAGMA PACK(string); 

TYPE duration IS DELTA 2.0 ** (-14) 

RANGE -131 071.0 .. 131 071.0; 

— (2*^17 - 1) 


— The predefined exceptions: 


constraint_^error 

numeric_erFor 

program_error 

storage~error 

tasking_^error 


exception; 

exception; 

exception; 

exception; 

exception; 


6-10 


6.4.1 Package STANDARD 






Ada/L PSE Handbook 


Version 2.OC 
30 September 1989 


END STANDARD; 


6.4.2 Package SYSTEM 

The package SYSTEM for Ada/L is as follows: 

PACKAGE SYSTEM IS 

memory_size : CONSTANT := 1_048_576; 

— 2**20 

— virtual memory size (not configurable). 

TYPE address IS RANGE 0..system.memory_size - 1; 

— virtual address. 

TYPE name IS (anuyk43); 

— only one compatible system name. 

syatem_name : CONSTANT system.name := system.anuyk43; 

— name of current system. 

storage__unit ; CONSTANT ;= 32; 

— word-oriented system (not configurable) 

— System Dependent Named Numbers 

min_int : CONSTANT := -((2**63)-1); 

-- most negative integer. 

max_int ; CONSTANT := (2**63)-l; 

— most positive integer. 

max_digits ; CONSTANT ;» 15; — 15 with long_float 

— most decimal digits in floating point constraint. 

raax_mantiasa ; CONSTANT := 31; 

— moat binary digits for fixed point subtype. 

fine_delta ; CONSTANT 

;= 2 # 0 . 0000_0000 0000 _ 0000 _ 0000 ^ 0000 _ 0000 _ 001 #; 

— 2**(-31) is minimum fixed point constraint. 

tick : CONSTANT := 4.8828125e-05; 

— 1/20480 seconds is the basic clock period. 

— FOR address'SIZE USE 32; 

— virtual address is a 32-bit quantity. 

null_addr : CONSTANT address 0; 

— Indicates a NULL address. 


6.4.2 Package SYSTEM 


6-11 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


— Address clause (interrupt) addresses 
Class_I_Unhandled_address 

Class_II_tJnhandled_address 

CP_Ope rand_Memory_Resume_address 

CP_IOC_Command_Resume_address 

CP_Instruction__Memory_Resume_address 

CP_IOC_Interrupt_Code_Resume_address 

CP_Operand_Memory_Error_address 

CP_Instruction__Memory_Error_addreas 

CP_I0C_Command_0perand_Erroc_addres3 

10C_Memory_Error_address 

IPI_Pault_address 

IOC_Memory_Resume_address 

Intercomputer_Timeout_address 

Confidence_Test_Pault_address 

CPD_IOC_Microprocessor_Stop_address 

Module_Interrupt_address 

Power_Tolerance_Interrupt_address 


: CONSTANT 
address 

: CONSTANT 
address := 

: CONSTANT 
address := 

: CONSTANT 
address := 

: CONSTANT 
address 

: CONSTANT 
address := 

: CONSTANT 
address 

: CONSTANT 
address :~ 

! CONSTANT 
address 

; CONSTANT 
address := 

; CONSTANT 
address 

: CONSTANT 
address 

: CONSTANT 
address 

: CONSTANT 
address 

: CONSTANT 
address 

: CONSTANT 
address 

: CONSTANT 
address :~ 


16»0800»; 

16#1800#; 

16#1000#; 

16#1100#; 

16#1200#; 

16#1300#; 

16#1400#; 

16#1500#; 

16#1600#; 

16#1700#; 

16#1900#; 

16#1A00#; 

16»1B00«; 

16#1C00#; 

16»1D00*; 

16#1E00#; 

16#1P00#; 


6-12 


6.4.2 Package SYSTEM 





Ada/L PSE Handbook Version 2.0C 

30 September 1989 


Class_III_Unhandled_address : CONSTANT 

address := 16#2800#; 

CP_Illegal_Instruction_Error_address ; CONSTANT 

~ address := 16#2200#; 

Privileged_Instruction Error_address : CONSTANT 

address := 16#2300#; 

Data_Pattern_Breakpoint_address : CONSTANT 

address := 1612400#; 

Operand_Breakpoint_Match_address : CONSTANT 

~ address := 16#2500#; 

0perand_Read_addre3S : CONSTANT 

' address := 16#2600#; 

DCU__Status_Interrupt_address : CONSTANT 

^ address :* 16#2700#; 

Operand_Write_Protection_address : CONSTANT 

~ address := 16#2900#; 

Operand__Limit_Protection_address : CONSTANT 

“ “ address ;= 16#2A00#; 

Instruction_Breakpoint_Match_address ; CONSTANT 

” ““ “ address := 16#2B00#; 

RPD_Underflow_address : CONSTANT 

” address := 16#2C00#; 

Instruction_Execute_Protection_address ; CONSTANT 

~ address 16#2D00#; 

Instruction_Limit_Protection_address : CONSTANT 

address 16#2E00#; 

Precisly_Timed_Interrupts_address : CONSTANT 

address 16#2F00#; 


I/O Interrupts 

User should program 

— FOR entry-name USE AT system.address_of( 

interrupt*>interrupt_name, 
for_channel»>channel_number); 
e.g. ” 

OSE system; 

** • • 

FOR el USE AT address^of(ioc_cp_interrupt, 

^ for_channel»>5); 


6.4.2 Package SYSTEM 


6-13 






Version 2.0C 
30 September 1989 


Ada/u PSE Handbook 


Note that if the user wants to register for the 
IOC_Illegal_CAR_Instruction interrupt, where only the 
IOC is to be specified, for_channel should be either 0 
or 32. 


(Declaration of FUNCTION address_of is found below) 


IOC_Illegal_CAR_Instruction 

IOC”Meraory_Protection 

IOC_Channel_Function_Error 

IOC_Illegal_Chain_Instruction 

I0C_Confidence_Test_Fault 

IOC_Breakpoint__Match 

IOC_CP_Interrupt 

IOC_External_Interrupt_Monitor 

IOC__External_Function_Monitor 

IOC”Output_Data_Monitor 

IOC_Input_Data_Monitor 


CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 


16#3000# 

16#3100# 

16#3300# 

16#3400# 

16#3800# 

16#3900# 

16#3B00# 

16«3C00# 

16#3D00# 

16#3E00# 

16#3F00# 


SUBTYPE IO_interrupts IS address RANGE 

IOC Illegal CAR_Instruction..IOC_Input_Data_Monitor; 
SUBTYPE channel numbers IS INTEGER RANGE 0..63; 


physical__memory__si 2 e ; CONSTANT :* 2**31; 

— maximum physical memory size (not configurable) 

TYPE physical_address IS 

RANGE 0..system.physical_memory_si 2 e - 1 ; 

— absolute address. ” ^ 

null_phys addr : CONSTANT physical address := 0; 

— Indicates a NULL physical address. 

TYPE word IS NEW INTEGER; 

— objects of this type occupy one target_computer 

— word *32 bits on the AN/UYK-43). ” 

— UNCHECKEO_CONVERSION must be used to interpret 
—• the value”for an object of this type from Ada. 

SUBTYPE priority IS integer RANGE 0..15; 

— task priority, lowest > default - 0. 

TYPE entry_kind is (normal, immediate); 

— enumeration type for use with 
— PRAGMA INTERRUPT HANDLER TASK. 


— The following exceptions are provided as a "convention" 

— whereby the Ada program can be compiled with all implicit 
checks suppressed (i.e. pragma SUPPRESS or equivalent), 

— explicit checks included as necessary, the appropriate 

— exception raised when required, and then the exception is 


6-14 


6.4.2 Package SYSTEM 










Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


either handled or the Ada program terminates. 


ACCESS_CHECK 
DISCRIMINANT CHECK 
INDEX CHECK ~ 
LENGTH_CHECK 
RANGE CHECK 
DIVIsrON_CHECK 
OVERFLOW_CHECK 
ELABORATION CHECK 
STORAGE CHECK 


EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION: 

EXCEPTION; 


— implementation-defined exceptions. 

UNRES0L7ED_REFERENCE : EXCEPTION; 

SYSTEM_ERROR : EXCEPTION; 

CAPACITY^ERROR : EXCEPTION; 

~ The exception CAPACITY_ERROR is raised by the RTExec when 

— Pre-RunTime specified resource limits are exceeded. 


FUNCTION ADDR£SS_OF 

— returns the system.address of the given Class III 

— interrupt for the specified channel 
(interrupt ; IN IO_interrupts; 

— The name of the interrupt 
fot_channel : IN channel_numbers 
— The channel number. 

) RETURN address; 

— The address to be used in the 
— representation (address) clause. 

PRAGMA INTERFACE (MACRO_NORMAL,ADDRESS OF); 


FUNCTION "AND" 

— returns the logical 32 bit 'AND' between two integers. 

(operand_a : IN integer; — The first operand. 

operand_b ; IN integer ~ The second operand 

) RETURN~integer; — The results. 

PRAGMA INTERFACE (MACRO__NORMAL, "AND"); 

FUNCTION "NOT" 

— returns the- logical 32 bit 'NOT' of an integer, 
(operand^a : IN integer — The first operand. 

) RETURN integer; — The results. 

PRAGMA INTERFACE (MACRO^NORMAL, "NOT"); 

FUNCTION "OR" 

returns the logical 32 bit 'OR* between two integers. 
(operand__a : IN integer; -- The first operand. 

operand_b : IN integer ~ The second operand 


6.4.2 Package SYSTEM 


6-15 










Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


1 ) RETURN integer; — The results. 

I PRAGMA INTERFACE (MACRO_NORMAL, "OR"); 

I END SYSTEM; 


6-16 


6.4.2 Package SYSTEM 








Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.5 Character Set 

Ada compilations may be expressed using the following 
characters'in addition to the basic character set: 

lower case letters: 

abcdefghijklmnopqrstuvwxyz 
special characters: 

!$?@[/]"{}" (accent grave) % 


6.5 Character Set 


6-17 


Version 2,0C 
30 September 1989 


A.da/L PSE Handbook 


6.6 Representation and Declaration Restrictions 

Representation specifications are described in Section 13 of 
the Ada Language Reference Manual. Declarations are described in 
Section 3 of the Ada Language Reference Manual. 

In the following specifications, the capitalized word SIZE 
indicates the number of bits used to represent an object of the 
type under discussion. The upper case symbols D, L, R, 
correspond to those discussed in Section 3.5.9 of the Ada 
Language Reference Manual. 


6.6.1 Integer Types 

Integer types are specified with constraints of the form 
RANGE L..R 

where 

R <= system.max_int & L >= system.min_int 

For a prefix "t" denoting an integer type, length specifications 
of the form 

FOR t'SIZE tJSE n ; 

may specify integer values n such that 
n in 2..64, 
and such that 

R <= 2**(n-l)-l 4 L >= -(2**(n-l)-l) 
or else such that 

R <* (2**n)-l & L >* 0 

and 

1 < n <» 15 

For a stand-alone object of integer type, a default SIZE of 32 is 
I used when: 

I R <» 2**31 - 1 & L >» -(2**31 - 1) 

I Otherwise, a SIZE of 64 is used. 

For components of integer types within packed composite 


6-18 


6.6.1 Integer Types 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


objects, the smaller of the default stand-alone SIZE and the SIZE 
from a length specification is used. 


6.6.2 Floating Types 

Floating types are specified with constraints of the form: 
DIGITS D 

where D is an integer in the range 1 through 15. 

For a prefix "t" denoting a floating point type, length 

specifications 

of the form: 

FOR t'SIZE OSE n; 

are permitted only when the integer value n = 32 for D <* 6 or 
N * 64 for 7 <= D <= 15. 


6.6.3 Fixed Types 

Fixed types are specified with constraints of the form 
DELTA 0 RANGE L..R 


where 


MAX (ABS(R), ABS(L)) 

---<- 2**31 - 1. 

actual delta 

The actual delta defaults to the largest integral power of 2 less 
than or equal to the specified delta D. (This implies that fixed 
values are stored right-aligned.) For specifications of the form 

FOR t'SMALL USE n; 

n must be specified as an integral power of 2 such that n <= D. 

For a prefix "t" denoting a fixed point type, length 
specifications of the form 

FOR t'SIZE USE n; 

are permitted only when n » 32. All fixed values have SIZE ^ 32 . 


6.6.4 Enumeration Types 

In the absence of a representation specification for an 


6.6.4 Enumeration Types 


6-19 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


enumeration type "t”, the internal representation of t*FIRST is 
0. The default size for a stand-alone object of enumeration type 
"t" is 32, so the internal representations of t'PIRST and t'LAST 
I both fall within the range: 

I -(2**31 - 1) .. 2**31 - 1. 

I For enumeration types, length specifications of the form 
I FOR t'SIZE USE n; 

I and/or enumeration representations of the form 
1 FOR t USE <aggregate>; 

I are permitted for n in 2..32, provided the representations and 
I the SIZE 

I conform to the relationship specified above, or else for n in 
I 1..32, 

I is supported for enumeration types and provides an internal 
I representation of: 

I t'PIRST >= 0 .. t'LAST <* 2**{t'SIZE) - 1. 


For components of enumeration types within packed composite 
objects, the smaller of the default stand-alone SIZE or the SIZE 
from a length specification is used. 

Enumeration representations for types derived from the 
predefined type standard.boolean will not be accepted, but length 
specifications will be accepted. 


6.6.5 Access Types 

For access type, "t", length specifications of the form: 

FOR t'SIZE USE n; 

will not affect the runtime implementation of "t", therefore n = 
32 is the only value permitted for SIZE, which is the value 
returned by the attribute. 

For collection size specifications of the form: 

FOR t'STORAGE_SIZE USE n; 

for any value of "n” is permitted for STORAGE_SIZE (and that 
value will be returned by the attribute call). The collection 
size specification will affect the implementation of "t" and its 
collection at runtime by limiting the number of objects for type 
"t” that can be allocated. 


6-20 


6.6.5 Access Types 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


The value of t'STORAGE_SIZE for an access type "t" specifies 
the maximum number of storage_units used for all objects in the 
collection for type "t". This includes all space used by the 
allocated objects, plus any additional storage required to 
maintain the collection. 


6.6.6 Arrays and Records 

For arrays and records, a length specification of the form 
FOR t'size USE n; 

is not allowed unless it is the default size. 

The PACK pragma may be used to minimize wasted space between 
components of arrays and records. The pragma causes the type 
representation to be chosen such that the storage space 
requirements are minimized at the possible expense of data access 
time and code space. 

A record type representation specification is not allowed. 
For records, an alignment clause of the form: 

AT MOD n 

specify alignments of 1 word (word alignment) or 2 words 
(doubleword alignment). 

If it is determinable at compile time that the SIZE of a 
record or array type or subtype is outside the range of 
standard.integer, a diagnostic of severity WARNING is generated. 
Declaration of such a type or subtype would raise NUM£RIC_ERROR 
when elaborated. 


6.6.7 Other Length Specifications 

Length Specifications are discribed in Section 13.2 of the I 
Ada Language Reference Manual. I 

A length specification for a task type "t", of the form: I 

FOR f STORAGE _SIZE use N; I 

specifies the number of system.storage_units that are allocated 
for the execution of each task object of type "t". This includes 
the runtime stack for the task object but does not include 
objects allocated at runtime by the task object. 


6.6.7 Other Length Specifications 


6-21 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.7 System Generated Names 

I Refer to Section 13.7 of the Ada Language Reference Manual 

I and the section above on the Predefined Language Environment for 
I a discussion of package SYSTEM. 

I The system name is chosen based on the target(s) supported, 

I but it cannot be changed. In the case of Ada/L, the system name 
I is ANUYK43. 


6-22 


6.7 System Generated Names 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.8 Address Clauses 

Refer to Section 13.5 of the Ada Language Reference Manual 
for a description of address clauses. All rules and restrictions 
described there apply. In addition, the following restrictions 
apply. 

An address clause designates a single task entry only. The 
appearance of a data object, subprogram, package, or task unit 
name in an address clause is not allowed, and will result in the 
generation of a diagnostic of severity ERROR. 

An address clause may designate a single task entry. Such 
an address clause is allowed only within a task specification 
compiled with the EXECUTIVE compiler option. The meaningful 
values of the simple_expression are the allowable interrupt entry 
addresses as defined in Table 6-1. The use of other values will | 
result in the raising of a PROGRAM ERROR exception upon creation 
of the task. “ 

If more than one task entry is equated to the same interrupt 
entry address, the most recently executed interrupt entry 
registration permanently overrides any previous registrations. 

At most one address clause is allowed for a single task 
entry. Specification of more than one interrupt address for a 
task entry is erroneous. 


6.8 Address Clauses 


6-23 




Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


AN/UYK-43(V) Interrupt Summary 


Class 0 



ISC 

Interrupt 


Target-Computer Interrupt 

CODE 

Entry Address 

Registration 

Class I Unhandled Interrupt 

None 

16*0800# 


Class 

I 




ISC 

Interrupt 


Target-Computer Interrupt 

CODE 

Entry Address 

Registration 

Class II Onhandled Interrupt 

None 

16*1800* 


CP-Operand Memory Resume 

16«0» 

16*1000* 


CP-IOC Command Resume 

16*1» 

16*1100* 


CP-Instruction Memory Resume 

16*2» 

16*1200* 


CP-IOC Interrupt Code Resume 

16#3* 

16*1300* 


CP-Operand Memory Error 

16*4* 

16*1400* 


CP-Instruction Memory Error 

16*5* 

16*1500* 


CP-IOC Command/Operand Error 

16*6* 

16*1600* 


IOC Memory Error 

16*7* 

16*1700* 


IPI Fault 

16*9* 

16*1900* 


IOC Memory Resume 

16*A* 

16#1A00* 


Intercomputer Timeout 

16*B* 

16*1B00* 


CP Confidence Test Fault 

16*C* 

16*1C00* 


CPU/IOC Microprocessor Stop 

16*D* 

16*1D00* 


Module Interrupt 

16*E* 

16*1E00* 


Power Tolerance 

16*F* 

16*1F00# 



Table 6-la - Interrupt Entry Addresses 


6-24 


6.8 Address Clauses 














Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


AN/aYK-43(V) Interrupt Summary 


Class 

II 



Target-Computer Interrupt 

ISC 

CODE 

Interrupt 

Entry Address 

Registration 

Class III Unhandled Interrupt 

None 

16#2800« 


Interprocessor Interrupt 

16#0# 

16#2000# 

UNDEFINABLE 

Floating Point Error 

16#1# 

16#2100# 

UNDEFINABLE 

Illegal Instruction 

16#2# 

16#2200# 


Privileged Instruction Error 

16#3# 

1612300# 


Data Pattern Breakpoint 

16«4« 

1612400# 


Operand Address Breakpoint 

16#5# 

16#2500# 


Operand Read or 




Indirect Addressing 

16#6# 

16#2600# 


OCU Status Interrupt 

16#7# 

16#2700# 


Operand Write 

16«9* 

16#2900# 


Operand Limit 

16#A# 

16#2A00# 


Instruction Address Breakpoint 16#B# 

16#2B00# 


RPD Underflow 

16#C# 

16#2C00# 


Instruction Execute 

16«D« 

16#2D00# 


Instruction Limit 

16«Ei 

16#2EQ0# 


Monitor Clock 

16#F# 

16#2F00# 

UNDEFINABLE 


Table 6-lb - Interrupt Entry Addresses (Continued) 


6.8 Address Clauses 


6-25 










Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


AN/UYK-43(V) Interrupt Summary 


Class III 


Target-Computer 

Interrupt 

ISC 

CODE 

Interrupt 

Entry Address 

1 

Registration I 

IOC 

IOC 

Illegal CAR Instruction 
Memory Protection 

16*0* 

16*1# 

16*3010# 

16#31IC# 

1 

1 

1 


If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be 
translated to Class II CJnhandled. 


ONDEFINEO 16#2# 16«3200# UNDEFINABLE 

Channel Function Error 16#3# 16#33IC# 

IOC Illegal Chain Instruction 16#4#.. 16#34IC# 

16#7# 

IOC Confidence Test Fault 16#8# 16#38IC# 

If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be 
translated to Class II Unhandled. 

IOC Breakpoint Match 16#9# 16#39IC# 

If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be 
translated to Class II Unhandled. 

IOC Monitor Clock 16#A# 16#3AI0# UNDEFINABLE 

IOC Processor Interrupt 16IB# 16#3BICI 

External Interrupt Monitor 16#C# 16#3CIC# 

External Function Monitor 16#D# 16t3DICt 

Output Data Monitor 16#E# 16#3EICt 

Input Data Monitor 16#F# 16#3FICt 

For class III interrupts, the following interpretations apply: 

IC »> IOC, channel number where 

16«00*..16«lFi indicates IOC 0, channel 16*00..16«1F», 
16*20*..16«3F* indicates IOC 1, channel 16*00..16*1F* 


Table 6-lc - Interrupt Entry Addresses (Continued) 


6-26 


6.8 Address Clauses 










Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.9 Unchecked Conversions 

Refer to Section 13.10.2 of the Ada Language Reference 
Manual for a description of UNCHECKED_CONVERSION. It is 
erroneous if the user written ada program performs 
□NCHECKED_CONVERSION when the source and target objects have 
different sizes. 


6.9 


Unchecked Conversions 


6-27 



Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.10 Restrictions on the Main Subprogram 

Refer to Section 10.1 (8) of the Ada Language Reference 
Manual for a description of the main subprogram. The subprogram 
designated as the main subprogram cannot have parameters. The 
designation as the main subprogram of a subprogram whose 
specification contains a formal_part results in a diagnostic of 
severity ERROR at link time. 

The main subprogram can be a function, but the return value 
will not be available upon completion of the main subprogram's 
I execution. The main subprogram may not be an import unit. 


6-28 


6.10 


Restrictions on the Main Subprogram 







Ada/L PSE Handbook 


Version 2.OC 
30 September 1989 


6.11 Input/Output 

Refer to Section 14 of the Ada Language Reference Manual for 
a discussion of Ada Input/Output and to Section 12 of the Ada/L 
Run Time Environment Handbook for more specifics on the Ada/L 
Input/Output subsystem. 

The Ada/L Input/Output subsystem provides the following 
packages to the user: TEXT_IO, SEQUENTIAL_IO, DIRECT_IO, and 
LOW_LEVEL_IO. These packages execute in the context of the 
useF-written Ada program task making the I/O request. 
Consequently, all of the code that processes an I/O request on 
behalf of the user-written Ada program executes sequentially. 

The package IO_EXCEPTIONS defines all of the exceptions needed by 
the packages SEQOENTIAL_IO, DIRECT^IO, and TEXT_IO. The 
specification of this package is given in Section 14.5 of the Ada 
Language Reference Manual. This package is visible to all of the 
constituent packages of the Ada/L I/O subsystem so that 
appropriate exception handlers can be inserted. 

I/O in Ada/L is performed solely on external files. No 
allowance is provided in the I/O subsystem for memory resident 
files (i.e., files which do not reside on a peripheral device). 
This is true even in the case of temporary files. With the 
external files residing on the peripheral devices, Ada/L makes 
the further restriction on the number of files that may be open 
on an individual peripheral device. 

Section 14.1 of the Ada Language Reference Manual states 
that all I/O operations are expressed as operations on objects of 
some file type, rather than in terms of an external file. File 
objects are implemented in Ada/L as access objects which point to 
a data structure called the File Control Block (see Section 

3.1.2.11 of the (Ada/L_RTLIB PDS]). This File Control Block is 
defined internally to each ol the high-level I/O packages; its 
purpose is to represent an external Hie. The File Control Block 
contains all of the I/O-specific information about an external 
file that is needed by the high-level I/O packages to accomplish 
requested I/O operations. 


6.11.1 Naning External Files 

The naming conventions for external files in Ada/L are of 
particular importance to the user. All of the system-dependent 
information needed by the I/O subsystem about an external file is 
contained in the file name. External files may be named using 
one of three file naming conventions: standard, temporary, and 
user-derived. 

a. Standard File Names: 

The standard external file naming convention used in 


6 . 11.1 


Naming External Files 


6-29 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Ada/L identifies the specific location of the external 
file in terms of the physical device on which it is 
stored. For this reason, the user should be aware of the 
configuration of the peripheral devices on the AN/UYK-43 
at a particular user site. 

Standard file names consist of a six character 
prefix and a file name of up to twenty characters. The 
six character prefix has a predefined format. The first 
and second characters must be either "DK," "MT," or "tt," 
designating an AN/UYH-3(V) Recorder/Reproducer Set 
Magnetic Disk, the RD-358 Magnetic Tape Subsystem, or the 
AN/USQ-69 Data Terminal Set, respectively. 

The third and fourth characters specify the channel 
on which the peripheral device is connected. Since there 
are sixty-four channels on the AN/UYK-43, the values for 
the third and fourth positions must lie in the range ”00" 
to "63." 

The range of values for the fifth position in the 
prefix (the unit number) depends upon the device 
specified by the characters in the first and second 
positions of the external file name. If the specified 
peripheral device is the AN/UYH-3 magnetic disk drive, 
then the character in the fifth position must be one of 
the characters "0," "1," "2," or "3." This value 
determines which of the four disk units available on the 
AN/UYH-3 is to be accessed. If the specified peripheral 
device is the RO-358 magnetic tape drive, the character 
in the fifth position must be one of the characters "0," 
"1," "2," or "3." This value determines which of the four 
tape units available on the RO-358 is to be accessed. If 
the specified peripheral device is the AN/USQ-69 
militarized display terminal, the character in the fifth 
position depends on the channel type. If the channel 
type is parallel then this character must be a "0". This 
is the only allowable value for the unit number when the 
AN/USQ-69 is connected to a parallel I/O channel. This 
is because the AN/USQ-69 may have only one unit on a 
parallel channel. If the channel type is serial then the 
character in the fifth position must be one of the 
characters "0", "1", "2", "3", "4", "5", "6", "7", or "8" 
(the character "8" will be used to specify a broadcast 
mode transmission). The AN/USQ-69 allows up to eight 
terminals to be daisy chained together when running on a 
serial channel. 

The colon, is the only character allowed in the 

sixth position. If any character other than the colon is 
in this position, the file name will be considered 
non-standard and the file will reside on the default 
device defined during the elaboration of CONFIGURE 10. 


6-30 


6.11.1 Naming External Files 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Positions seven through twenty-six are optional to 
the user written Ada program and may be used as desired. 
These positions may contain any printable character the 
user chooses in order to make the file name more 
intelligible. Embedded blanks, however, are not allowed. 

The location of an external file on a peripheral 
device is thus a function of the first six characters of 
the file name regardless of the characters that might 
follow. For example, if the external file 
"MTOOO:01d_0ata'' has been created and not subsequently 
closed, an attempt to create the external file 
"MTOOO;New_Data" will cause the exception DEVICE_ERROR 
(rather than NAME_ERROR or CJSE_ERROR) to be raised 
because the peripheral device on channel "00" and 
cartridge "0" is already in use. 

The user is advised that any file name beginning 
with "xxxxx:" (where x denotes any printable character) 
is assumed to be a standard external file name. If this 
external file name does not conform to the Ada/L standard 
file naming conventions, the exception NAM£_ERROR will be 
raised. 

b. Temporary File Names: 

Section 14.2.1 of the Ada Language Reference Manual 
defines a temporary file to be an external file that is 
not accessible after completion of the main subprogram. 

If the null string is supplied for the external file 
name, the external file is considered temporary. In this 
case, the high level I/O packages internally create an 
external file name to be used by the lower level I/O 
packages. The internal naming scheme used by the I/O 
subsystem is a function of the type of file to be created 
(text, direct or sequential) and the current date and 
time. This scheme is consistent with the requirement 
specified in the Ada Language Reference Manual that all 
external file names be unique. 

The first two characters of the file name are ”TX," 
"D_," or "S_." The next eight characters are the date 
(four characters for the year, two characters for the 
month, and two characters for the day). The remaining 
ten characters are the time (five for seconds and five 
for the fraction part of a second). For instance, the 
temporary external file name ”D_198803311234598765" would 
be a DIRECT 10 file created March 31, 1988 at 
12,345.9876? seconds. 

c. User-Derived File Names: 

A random string containing a sequence of characters 


6 . 11.1 


Naming External Files 


6-31 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


of length one to twenty may also be used to name an 
external file. External files with names of this nature 
are considered to be permanent external files. The user 
is cautioned to refrain from using names which conform to 
the scheme used by the I/O subsystem to name temporary 
external files (see list item "b."). 

It is not possible to associate two or more internal 
files with the same external file. The exception 
USE ERROR will be raised if this restriction is violated. 


6.11.2 The FORM Specification for External Files 

Section 14.2.1 of the Ada Language Reference Manual defines 
a string argument called the FORMf which supplies 
system-dependent information that is sometimes required to 
correctly process a request to create or open a file. In Ada/L, 
the string argument supplied to the FORM parameter on calls to 
CREATE and OPEN is retained while the file is open, so that calls 
to the function FORM can return the string to the user written 
Ada program. FORM options specified on calls to CREATE have the 
effects stated below. FORM options specified on calls to OPEN 
have no effect. 

Ada/L only allows a FORM parameter when a file is open or 
created on the RD-358 tape drive. A USE^ERROR will be raised 
when a FORM parameter is associated with^any other Ada/L system 
device. The FORM parameter specifically controls the positioning 
and formatting of the tape prior to tape I/O operations. This 
section identifies the arguments of the FORM parameter. Refer to 
Section 14.2.1 of the Ada Language Reference Manual and to 
Section 12.2.2 of the Ada/L Run Time Environment Handbook for 
more detail on the use of the FORM parauneter. 

The FORM parameter is a string literal of which a maximum of 
twenty characters is processed. If the supplied FORM string is 
longer than the maximum allowed (20 characters), the exception 
USE_ERROR will be raised. The string literal is interpreted as a 
sequence of arguments. If the user wishes to utilize the default- 
arguments, a FORM parameter need not be supplied. 

Only the first two arguments within the string are 
processed. All following characters or arguments will cause the 
USE_ERROR to be raised. The arguments are not case sensitive. 
The~arguments must be separated by at least one delimiter. A 
legal delimiter consists of a comma or blank. Extra delimiters 
are ignored. Of the recognized arguments, at most one formatting 
and one positioning argument are allowed. If conflicting 
arguments are used, the exception USE_ERROR will be raised. 

Positioning arguments allow control of tape before its use. 
The following positioning arguments are available to the user: 


6-32 


6.11.2 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


a. REWIND - specifies that a rewind will be performed 
prior to the requested operation. 

b. NOREWIND - specifies that the tape remains positioned 
as is. 

c. APPEND - specifies that the tape be positioned at the 
logical end of tape (LEOT) prior to the requested 
operation. The LEOT is denoted by two consecutive 
tape_marks. 

The formatting argument specifies information about tape 
format. If a formatting argument is not supplied, the file is 
assumed to contain a format header record determined by the ALS/N 
I/O system. The following formatting argument is available to 
the user: 

a. NOHEAD - specifies that the designated file has no 
header record. This argument allows the reading and 
writing of tapes used on computer systems using 
different header formats. 


6.11.3 File Processing 

Processing allowed on Ada/L files is influenced by the 
characteristics of the underlying device. The following 
restrictions apply: 

a. . Only one file may be open on an individual RO-358 

tape drive at a time. 

b. The attempt to CREATE a file with the mode IN_FILE is 
not supported since there will be no data in the file 
to read. 


6.11.4 Text Input/Output 

TEXT_IO is invoked by the user-written Ada program to 
perform sequential access I/O operations on text files (i.e., 
files whose content is in human-readable form). TEXT^IO is not a 
generic package and, thus, its subprograms may be invoked 
directly from the user-written Ada program, using objects with 
base type or parent type in the language-defined type character. 
TEXT_IO also provides the generic packages INTEGER^IO, FLOAT_IO, 
FIXED 10, and ENUMERATION^IO for the reading and writing of 
numerTc values and enumeration values. The generic packages 
within TEXT_^IO require an instantiation for a given element type 
before any of their subprograms are invoked. The specification 
of this package is given in Section 14.3.10 of the Ada Language 
Reference Manual. 


6.11.4 Text Input/Output 


6-33 






Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


The implementation-defined type COUNT that appears in 
Section 14.3.10 of the Ada Language Reference Manual is defined 
as follows: 

type COUNT is range 0...INTEGER'LAST; 

The implementation-defined subtype FIELD that appears in Section 
14.3.10 of the Ada Language Reference Manual is defined as 
follows; 


subtype FIELD is INTEGER range 0 ... INTEGER'LAST; 

At the beginning of program execution, the STANDARD_INPUT 
file and the STANDARD^OUTPUT file are open, and associated with 
the files specified by the user at export time. Additionally, if 
a program terminates before an open file is closed (except for 
STANDARO_INPUT and STANDARD OUTPUT), then the last line which the 
user added to the file may Ee lost; if the file is on magnetic 
tape, the file structure on the tape may be inconsistent. 

A program is erroneous if concurrently executing tasks 
attempt to perform overlapping GET and/or PUT operations on the 
same terminal. The semantics of text layout as specified in the 
Ada Language Reference Manual, Section 14.3.2, (especially the 
concepts of current column number and current line) cannot be 
guaranteed when GET operations are interweaved with PUT 
operations. A program which relies on the semantics of text 
layout under those circumstances is erroneous. 

For TEXT__IO processing, the line length can be no longer 
than 1022 characters. An attempt to set the line length through 
SET_LINE_LENGTH to a length greater than 1022 will result in 
USE ERROR. 


6.11.5 Sequential Input/Output 

SEQUENTIAL^IO is invoked by the user-written Ada program to 
perform I/O on the records of a file in sequential order. The 
SEQUENTIAL_IO package also requires a generic instantiation for a 
given element type before any of its subprograms may be invoked. 
Once the package SEQUENTIAL_IO is made visible, it will perform 
any service defined by the subprograms declared in its 
specification. The specification of this package is given in 
Section 14.2.3 of the Ada Language Reference Manual. 

The following restrictions are imposed on the use of the 
package SEQUENTIAL_IO: 

a. SEQUENTIAL 10 must be instantiated for a constrained 
type. 

b. Ada/L does not raise OATA_ERROR on a read operation 


6-34 


6.11.5 Sequential Input/Output 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


if the data input 
the instantiating 
Reference Manual, 


from the external file is not of 
type (see the Ada Language 
Section 14.2.2). 


6.11.6 Direct Input/Output 

DIRECT_IO is invoked by the user-written Ada program to 
perform I/O of the records of a file in an arbitrary order. The 
package DIRECT_IO requires a generic instantiation for a given 
element type before any of its subprograms may be invoked. Once 
the package DIRECT_IO is made visible, it will perform any 
service defined by the subprograms declared in its specification. 
The specification of this package is given in Section 14.2.5 of 
the Ada Language Reference Manual. 

The following restrictions are imposed on the use of the 
package OIRECT_IO: 

a. OIR£CT_IO must be instantiated for a constrained 
type. 

b. Ada/L does not raise DATA^ERROR on a read operation 
if the data input from the external file is not of 
the instantiating type (see the Ada Language 
Reference Manual, Section 14.2.4). 


6.11.7 Low Level Input/Output 

LOW_LEVEL_IO is invoked by the user-written Ada program to 
initiate physical operations on peripheral devices, and thus 
executes as part of the user-written Ada program task. Requests 
made to LOW_LEVEL_IO from the user-written Ada program are passed 
through the RTEXEC_GATEWAY to the channel programs in CHANNEL_IO. 
Any status check or result information is the responsibility of 
the invoking subprogram and can be obtained from the subprogram 
RECEIVE^CONTROL within LOW_LEVEL_IO. 

The package LOW__LEVEL_IO allows the user written Ada program 
to send I/O commands^to the I/O devices (using SEND_CONTROL) and 
to receive status information from the I/O devices (using 
R£CEIVE_CONTROL). A program is erroneous if it uses LOW LEVEL_IO 
to access a device that is also accessed by high-level l/O 
packages such as SEQUEMTIAL_IO and TEXT_IO. The following is 
excerpted from the package L0W_L£VEL_I07 

PACKAGE LOW_LEVEL_IO IS 

SUBTYPE channel_range IS INTEGER RANGE 0..63; 

— Range of values allowed for channel number. 

SUBTYPE device str IS STRING; 


6.11.7 Low Level Input/Output 


6-35 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


— To be passed to CHANNEL_IO for future implementations 

— of logical path name. The string will be ignored until 

— logical path name support is added. 

SUBTYPE btc_int IS INTEGER RANGE 0..16383; 

— Passes transfer counts to/frora IO_MANAGEMENT/RTEXEC. 

SUBTYPE io_^functions IS INTEGER RANGE 0..20; 

— Specifies the I/O function to be performed by LOW___LEVEL_IO. 

— The following table shows the values associated with device 

and 

— device functions available. 


~ VALUE ~ DEVICE ~ FUNCTION 


RD-358 

RD-3S8 

RD-358 

RD-358 

RD-358 

OYH-3 

UYH-3 

OYH-3 

UYH-3 

OYH-3 

OYH-3 

OYH-3 


Normal Read 
Read with Search data 
Normal Write 
Send EF Command 
Initialise Channel 

Read with 2 word EF 
Read with 1 word EF 
Write 

Send 1 word EF Command 
Send 2 word EF Command 

Send 1 word EF Command (Same as function 
Initialize Channel 


USQ-69 Read 

OSQ-69 Write 

USQ-69 Write (Same as function 1) 

USQ-69 Send Command 

OSQ-69 Initialize Channel 


TYPE cap block IS 

— Information that can be found in 
— a per channel/ per function basis 
RECORD 


IOC control memory on 


cap 

instruct_base 

index 

accumulator 
status 
buffer_base 
bcw 

operand base 
END RECORD? 


INTEGER; — CAP register. 

INTEGER; — CAP instruction base. 

INTEGER; — CAP index register. 

INTEGER; — CAP accumulator register. 

INTEGER; — CAP status register. 

INTEGER; — CAP buffer base. 

INTEGER; — CAP buffer control word. 

INTEGER; — CAP operand base. 


TYPE short rec control block IS 


6-36 


6.11.7 Low Level Input/Output 










Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


— I/O control block sent to LOW_LEVEL_IO as a parameter 

— when calling subprogram RECEIVE_REQUEST. 

RECORD 

channel : low_level_io.channel_range; 

— Specifies channel of interest. 
ei_word : INTEGER; 

— External interrupt returned by the peripheral device. 
END RECORD; 

TYPE receive_control_block IS 

— I/O control block sent to LOW_LEVEL_IO as a parameter 

— when calling subprogram RECEIVE_REQUEST. 

RECORD 

data : low_level_io.short_rec_control_block; 

— Channel and ei_word. 
ef ; low_level_io.cap_block; 

— External Function CAP information, 
output : low_level_io.cap block; 

— Output”CAP informatTon. 
ei ; low_level_io.cap_block; 

— External Interrupt CAP information, 
input : low_level io.cap_block; 

— Input CAP in?ormation. 

END RECORD; 

TYPE send_control_block IS 

— I/O”control”block sent to LOW_LEVEL_IO as a parameter 
—* when calling subprogram SEND REQUEST. 

RECORD 

functionals ; low_level io.io_functions; 

— Indicates which I/O Function is to be requested 

— of LOW_LEVEL_IO. 

channel ; low_level_io.channel_range; 

— Specifies channel number. "* 

transfer count ; low__level_io.btc int; 

— BuFfer transfer count for l7o operation. 
buffer_addr : system.address; 

— Address of data buffer. 

comffland_l : INTEGER; 

— Holds the first word of the external 

— function for the device. 

coniinand_2 : INTEGER; 

—' Holds the second word of the external 

— function for the device. 

filler_l ; INTEGER; 

— Passes additional information to 
— CHANNEL_IO (such as the terminal_address 

— for the”OSQ-69 device). 

END RECORD; 


PROCEDURE SEND_CONTROL 

— Passes I/O control information to a procedure in 


6.11.7 Low Level Input/Output 


6-37 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


— IO_MANAGEMENT/RTEXEC in order to send data to the 

— specified device. 

(device : IN low_level_io.device_str := ; 

— This string will be^ignored until 
— logical path names are implemented, 
data : IN low_level_io.send_control block 

-- I/O control block for sen3 request. 

); 


PROCEDURE RECEIVE_CONTROL 

— Passes I/O control information to a procedure in 

— IO_MANAGEMENT/RTEXEC in order to obtain the status of 

— the I/O operation. 

(device r IN low_lcvel io.device_str := 

— This string wTll be ignored until 
— logical path names are implemented, 
data : IN OUT low_level_io.receive_control_block 
— I/O control block for receive request. 

); 


PROCEDURE RECEIVE_CONTROL 

— Passes I/O control information to a procedure in 
~ IO_MANAGEMENT/RTEXEC in order to Obtain the status of 
— the I/O operation. 

(device : IN low_level io.device^str := 

— This stFing will be ignored until 
— logical path names are implemented, 
data : IN OUT low_level_io.short_rec control_block 
— I/O control block for receive request. 

); 

END LOW LEVEL 10; 


6-38 


6.11.7 Low Level Input/Output 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.12 System Defined Exceptions 

In addition to the exceptions defined in the Ada Language 
Reference Manual, this implementation pre-defines the exceptions 
shown in Table 6-2. 


Name 

Significance 

UNRESOLVED_REFERENCE 

Attempted call to a routine not 
linked into the executable image. 

SYSTEM_ERROR 

Serious error detected in underlying 
AN/UYK-43 operating system. 

CAPACITY_ERROR 

Raised by the RTEXEC when Pre-Runtime 
specified resource limits are 
exceeded. 

ONREGISTERED_PTI 

Raised by the PTI support package if 
the PTI's state is returned as 
"unregistered". 

PAST_PTI_TIME 

Raised by the PTI support package if 
the PTI start time is greater than the 
current CALENDAR.CLOCK. 


Table 6-2a - System Defined Exceptions 


6.12 System Defined Exceptions 


6-39 








Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


1 Name 

Significance 

— + 

1 

1 

1 ACCESS_CHECK 

1 

The ACCESS_CHECK exception nas been 
raised explicitly within the program. 

1 

1 

1 

1 

i DISCRIMINANT_CHECK 

1 

DISCRIMINANT_CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

1 INDEX_CHECK 

1 

The INDEX_CH£CK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

1 LENGTH_CHECK 

( 

The LENGTH CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

I RANGE_CHECK 

The RANGE_CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

1 DIVISION_CHECK 

1 

The DIVISION_CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

1 OVERFLOW^CHECK 

1 

The OVERFLOW_CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

1 ELABORATION__CHECK 

1 

ELABORATION^CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

1 STORAGE_CHECK 

1 

The STORAGE^CHECK exception has been 
raised explicitly within the program. 

1 

1 

1 

1 

Table 6-2b - 

System Defined Exceptions (Continued) 



6-40 


6.12 System Defined Exceptions 










Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.13 Machine Code Insertions 


The Ada language permits machine code insertions as defined 
in Section 13.8 of the Ada Language Reference Manual. This 
section describes the specific details for writing machine code 
insertions as provided by the predefined package MACHINE_COOE. 

The Ada/L user may, if desired, include AN/UYK-43 
instructions within an Ada program. This is done by including a 
procedure in the program which contains only record aggregates 
defining machine instructions. The package MACHINE_CODE, 
included in the system program library, contains type, record, 
and constant declarations which are used to form the 
instructions. Each field of the aggregate contains a field of 
the resulting machine instruction. These fields are specified in 
the order in which they appear in the actual instruction. Since 
the AN/UYK-43 has several different formats for instructions, 
package MACRINE_CODE defines different types for each of these 
formats. For each of the fields which must have a certain value 
for a given instruction (i.e., part of the opcode), package 
MACHINE_COOE defines a constant to use for that field. 

The following procedure implements a floating point 
exponential. Note that this actual procedure would not be used, 
because package MATH_PACK implements the same operation in a more 
efficient manner. 

with machine__code; use machine_code; 

procedure floating_point_exponential 
(X : FLOAT j 
ex ; OUT FLOAT) is 


BEGIN 

formatI'(f_LA,l,3,6,0,0,0); 

— LA Al,B6+0 

formatv(f_FEX,l,f2_PEX,2,0,0,0,f6_FEX); 

— FEX A1,A2 

formatI'(f=>f_SA,aa>2,k=>3,b*>6,i*>0,s=>0,y=>l); 

— SA A2,B6+1 

END; 

Note that either positional or names aggregates may be used. 
Whenever a field does not appear in the MACRO/L instruction, it 
must be filled in with 0, since no missing fields are allowed. 

For formatl instructions, when k*0, the s and y field are 
collapsed and used together. For user convenience, an additional 
record type, fprmatli, for immediate, can be used to define the s 
and y fields as a single 16-bit quantity. This quantity is 
defined as an unsigned integer, so if a negative number x is 
desired, one should instead put the number x + 65535; 


6.13 Machine Code Insertions 


6-41 






Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Table 6-3 contains a list of MACRO/L instructions and their 
Ada/L machine code equivalents, sorted by MACRO/L mnemonic. 


6-42 


6.13 Machine Code Insertions 




Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


MACRO/L 

Ada/L 


-+ 

1 

AA 

a,y,k>b,s 

formatI*(f AA,a,k,b,i,Sry); 


1 

AB 

a,y,k,b,s 

formatI'(£ ABra,k/b,i/S,y); 


1 

A£I 

a,sy,b 

£ormatIi'(? A£I,a,k A£I,b,i,sy); 


1 

ALP 

a,y,b,s 

£ormatI'(f ALP,a,k ALP,b,i,s,y); 


1 

ANA 

a,y,k»b,3 

£ormatI'(£ ANA,a,k,b,i,s,y); 


1 

ANB 

a,y,k,b,s 

£ormatI*(f ANB,a,k,b,i,s,y); 


1 

ATSF 

a,b 

formatVMf ATSF,a,f2 ATSF,b,0,0,0,f6 ATSF); 

1 

BC 

ak,y,b,s 

£ormatIa'(£ BC,a,k,b,i,s,y); 


1 

BS 

ak,y,b,s 

£ormatIa'(£ BS,a,k,b,i,s,y); 


1 

BZ 

ak,y,b,s 

£ormatIa'(£ BZ,a,k,b,i,s,y); 


1 

C 

a,y,krb,s 

£ormatI'(£ C,a,k,b,i,s,y); 


1 

CB 


£ormatIVA'(f CB,a CB,0,i CB ); 


1 

CBN 

a,n 

formative(f CBN,a,£4 CBN,n); 


1 

CBR 

a,b 

£ormatV'(f CBR,a,£2 CBR,b,0,0,0,£6 CBR 

); 

1 

CCT 

a,b 

formatIVA*(f CCT,a,E,i CCT); 


1 

CE 


£ormatIVA'(f CE,a CE,0,i CE ); 


1 

CG 

a,y,k,b,3 

£ormatI*(f CG,a,k,b,i,s,y); 


1 

CHCL 

a,y,b,s 

£ormatI‘(£ CHCL,a,k CHCL,b,i CHCL,s,y); 


1 

CL 

a,y,k,b,s 

£ormatI‘(£ CL,a,k,b,i,s,y); 


1 

CM 

a,y,k»b,s 

formatI*(£“CM,a,k,b,i,s,y); 


1 

CMPS 

a,b 

£ormatV(f CMPS,a,£2 CMPS,b,0,0,0,£6 CMPS ); 

1 

CNT 

a,y,b,s 

£ormatI'(£ CNT,a,k CNT,b,i,s,y); 


1 

CRB 

a,b 

formatV(f”CRB,a,£l CRB,b,0,0,0,£6 CRB 

); 

1 

CXI 

a,y,k,b,s 

formatl* (f“‘CXI,a,k,E,i,3,y); ” 


1 

D 

a,y,k,b,s 

£ormatI'(£ D,a,k,b,i,s,y); 


1 

DA 

a,y,b,s 

£ormatI'(f DA,a,k OA,b,i,s,y); 


1 

DAN 

a,y,b,s 

£ormatI'(£ DAN,a,k DAN,b,i,s,y); 


1 

DC 

a,y,b,s 

£ormatI'(£ DC,a,k DC,b,i,s,y); 


1 

DJNZ 

a,y,k,b,3 

formatlll'Tf DJNZ,a,£3 DJNZ,k,b,i,s,y); 


1 

DJZ 

a,y,k,b,s 

£ormatIII'(£ DJZ,a,£3 DJZ,k,b,i,s,y); 


1 

DL 

a,y,b,s 

£ormatI'(f OL,a,k DL,b,i,s,y); 


1 

DS 

a,y,b,s 

£ormatI'(£ DS,a,k DS,b,i,s,y); 


1 

DSP 

3 ^ b / tti 

formatV(£~DSP,a,72 DSP,b,0,0,m,£6 DSP 

); 

1 

EECM 


formatIVA'Tf EECM,a EECM,0,i EECM ); 


1 

ESCM 


formatIVA'(£ ESCM,a ESCM,0,i~ESCM ); 


1 

ETCM 


formatIVA'(£ ETCM,a ETCM,0,i ETCM ); 


1 

FA 

a,y,b,s 

£ormatI'(f FA,a,k FA,b,i,s,y); 


1 

FAC 

a,b 

formatV(£ FAC,a,72 FAC,b,0,0,0,£6 FAC 

); 

1 

FAN 

a,y,b,s 

£ormatI'(£ FAN,a,k FAN,b,i,s,y); 


1 

FANR 

a,y,b,s 

formatl'if FANR,a,k FANR,b,i,s,y); 


1 

FAR 

a,y,b,s 

£ormatI'(£ FAR,a,k FAR,b,i,s,y); 


1 

FAS 

a,b 

formatV(£ PAS,a,f7 FAS,b,0,0,0,£6 FAS 

); 

1 

FAT 

arb 

formatV(£ FAT,a,£2 FAT,b,0,0,0,£6 FAT 

); 

1 

FD 

a,y,b,s 

formatl'(£”FD,a,k FD,b,i,s,y); 


1 

FDR 

a,y,brS 

formatl'(£_FDR,a,k_FDR,b,i,s,y); 


1 


Table 

6-3a - Machine Code Instructions 



6.13 

Machine Code 

Insertions 

6-43 









Version 2.0C Ada/L PSE Handbook 

30 September 1989 


1 

MACRO/L 


Ada/L 

1 

FEX 

a,b 


formatV'(f FEX/a/f2 FEX/b/0/0/0,f6 FEX ); 

1 

FLN 

a/b 


forautV'if FLN/a/f2 FLN,b,0,0,0,£6 FLN ); 

1 

FLTF 

a,n 


£ormatV'(fFLTP,a,£2 FLTF,n,0,0,0,16 FLTF); 

1 

FM 

a,y. 

b/S 

£ormatI' {£““PM,a,k FM,b,i,s,y); 

1 

FMR 

a,y, 

b/S 

£ormatI'(£ FMR/a/k FMR,b,i,s,y); 

1 

FPA 

a,b 


formatV'(f FPA/a,£2 FPA,b,0,0,0,£6 FPA); 

1 

FPD 

a,b 


£ormatV{£“FPD,a,f2 FPD,b,0,0,0,f6 FPD); 

1 

FPM 

a,b 


£ormatV'(f*“PPM,a,f2 FPM,b,0,0,0,f6 FPM ); 

1 

FPS 

a,b 


formatV(f“FPS,a,f2 FPS,b,0,0,0,f6 FPS ); 

1 

FSA 

a,b 


£ormatV'(£'FSA,a,f2 FSA,b,0,0,0,£6 FSA); 

1 

FSC 

a,b 


£ormatV'(f‘“PSC,a,f2 PSC,b, 0,0,0, f 6 FSC ); 

1 

PSD 

a,b 


£ormatV'(f"'PSD,a,f2 FSD,b,0,0,0,f6 FSD); 

1 

FSM 

a, b 


£ormatV(f~PSM,a,f2 FSM,b,0,0,0,£6 FSM); 

1 

FSS 

a,b 


£ormatV’{£'PSS,a,£2 FSS,b,0,0,0,£6 FSS); 

1 

FTSL 

a,b 


£ormatV'(£“FTSL,a,£2 PTSL,b,0,0,0,?6 FTSL); 

1 

HA 

a,b 


£ormatIVA‘7£ HA,a,b,0); 

1 

1 

HAEI 

HAI 

a,b 


£ormatIVA’(f”HAEI,a,b,i HAEI ); 

£ormatIVA'(£ HAI/0/0,0); 

1 

HALT 



£ormatIVA'(£ HALT/0,0/i HALT ); 

1 

HAN 

a,b 


£ormatIVA•(f“HAN,a,b,0); 

1 

HAND 

a^ b 


£ormatlVA*(f“HAND,a/b/i HAND ); 

£ormatIVA•(f~HC/a,b,0);" 

£ormatIVA'(f”HCB/a,b,0); 

1 

HC 

a,b 


1 

HCB 

arb 


1 

HCL 

a/b 


£ormatIVA' (£“’HCL,a, b, 0); 
£ormatIVA'(f”HCM/a,b,0); 
£ormatIVA’(f”HCP/a,0,0); 

£ormatIVA'(£”HCRC,a,b,i HCRC ); 

1 

HCM 

a,b 


1 

HCP 

a 


1 

HCRC 

a,b 


1 

HD 

a,b 


£ormatIVA'(£“HD,a/b,0); 

£ormatIVA' (£“'HDCP,a/0,0); 

£ormatIVB'(£_HDLC,a,m); 

£orfflatIVB'(£_HDRS/a/m); 

£ormatIVB'(£”HDRZ,a,m); 

1 

HDCP 

a 


1 

HDLC 

a,m 


1 

HDRS 

a,ffl 


1 

HDRZ 

a^m 


1 

HDSF 

a,b 


£ormatIVA'(£~HDSF/a,b,0); 

£ormatIVA'(£_HLB/a/b,0); 

£ormatIVB'(£'HLC/a/m); 

1 

HLB 

a/b 


1 

HLC 

a,m 


1 

HLCA 

a/b 


£ormatIVA'(f”HLCA,a,b,i HLCA ); 

1 

HLC I 

af4/ 

b 

£ormatIVA l'(£ HLCI,a£4,b/i HLCI); 

1 

HLCT 

a£4/ 

b 

£ormatIVA l'(£ HLCT,a£4,b,i HLCT); 

1 

HLTC 

a/b 


£ormatIVA‘^( £_HLTC, a, b, i_HLTC ) ; 

£ormatIVA'(£~HM/a/b/0); 

£ormatIVA'(£"H0R/a,b,0); 

1 

HM 

a/b 


1 

HOR 

a/b 


1 

HPEI 

a/b 


£ormatIVA'(£ HPEI/a/b/i HPEI ); 

1 

HPI 



£ormatIVA•(£"HPI/0,0,0); 

1 

HR 

a/b 


£ormatV'{£ HR/a/£2 HR/b,0/0,0/£6 HR); 

1 

HRS 

a/m 


£ormatIVB'T£_HRS,a,m); 


Table 6-3b - Machine Code Instructions (Continued) 


6-44 


6.13 Machine Code Insertions 










Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


MACRO/L 

HRT 

a,b 

HRZ 

a,m 

HSCA 

a#b 

HSCI 

af4,b 

HSCT 

af 4,b 

HSF 

a, b 

HSIM 

a,b 

HSTC 

a,b 

HSTl 

HST2 

HST3 

HST4 

HSTD 

a,b 

HSTV 

a,b 

HV 

a,b 

HWPI 

HXOR 

a,b 

IBSC 

a 

IILM 

a 

10 

a,y,b,s 

lOCL 

a 

lOCR 

a 

IOCS 

a 

lOT 

a,b,m 

IPI 

y»b,s 

IR. 

IRMMS 

a/b 

IRMSR 

arb 

ISMSR 

arb 

ISP 

3 f b / ni 

J 

y,k,b,s 

JBNZ 

a,y,k,b,3 

JC 

a^y/k/b/S 

JE 

y,k,b,s 

JEP 

a,y,k,b,a 

JG 

y»k,b,s 

JGE 

y»k,b,a 

JL 

y»k,b,s 

JLE 

y,k,b,s 

JLT 

yfk,b,s 

JN 

a,y,k,b,a 

JNE 

yfk,b,s 

JNP 

yA/b,s 

JNW 

yrk,b,s 

JNZ 

a,y,k,b,s 



formatIVA'{f_HRT,a,b,0); 
formatIVB'(f“HRZ,a,m); 
fo rma tIVA'(f“HSCA,a,b,i_HSCA ); 
formatIVA_1'Tf_HSCI,af 4,b,i_HSCI); 
formatIVA_l'(f_HSCT,af4,b,i HSCT); 
formatIVA'(fHSF,a,b,0); 
formatIVA'(flHSIM,a,b,i_HSIM ); 
formatlVA*(f_HSTC,a,b,i HSTC ); 
formatIVA’(f HSTl,a HSTr,b_HSTl,i_HSTl); 
formatIVA'(f~HST2,a~HST2,b HST2,i_HST2); 
formatIVA'(f_HST3,a~HST3,b“HST3,i_HST3); 
formatIVA’(f_HST4,a HST4,b”HST4,i_HST4); 
formatIVA*(f HSTD,a7b,i_HSTD ); 
formatIVA'(f'HSTV,a,b,i_HSTV ); 
formatV(f HV,a,f2_HV,b,0,0,0,f6_HV); 
formatIVA’Tf HWPI,0,0,i_HWPI ); 
formatIVA'(f“HXOR,a,b,0); 
formatIVA'(f IBSC,a,0,i_IBSC ); 
formatIVA'(f”lILM,a,0,i_^IILM ); 
formatI'(f IO»a,k lOrbrlrS^y); 
formatlVA'If IOCL7a,0,i lOCL ); 
formatIVA’(f'lOCR,a,0,i“lOCR ); 
formatIVA'(f-IOCS,a,0,i“lOCS ); 
formatV(f l5T,a,f2 IOT7b,0,0,m,f6_IOT ); 
formatI‘(f"lPI,a Ipr,k_IPI,b,i,s,y); 
formatl'(f"lR,0,lc IR,0,0,0,0); 
formatIVA’Tf IRMMS,a,b,i IRMMS); 
formatIVA'(f"'lRMSR,a,b,i'"lRMSR ); 
formatIVA’(fTlSMSR,a,b,iTlSMSR ); 
formatV{f_ISP,a,f2 ISP,b,0,0,m,f6_ISP ); 
formatin' (f_Jra_J,F3_J,k,b,i,s,y); 
formatin' (f_JBNZ,a,f3_JBNZ,k,b,i,s,y); 
formatin’ (fTJCfa,f3_JC,k,b,i,s,y); 

format 111 ' ( f JE r a JE r f 3_^JE rkrbrirSry) # 
formatnI'(f JEPfarf3 JEPrk^brirary)# 
formatin' (f JGya^JGyT3 JG^k^bf ifSry) r 
format 111' (f _^JGE f a JGE»?3^iJGE fkfbrira^y); 
formatin' (f33'I*ra,?3_JL,k7b,i,s,y); 
format in' (f __«JLE r a_iJI»E r f 3_iJriE fk/b/i/S/y) j 
formatlll* (f__JLTra JLTff3_JLiTfk^bri/Sfy) j 
formatlll'(f_JN r a r f3_JN rkrbfirSry); 
formatin’ (f_JNE,a_JNE,f3 JNE,k,b,i,s,y) ; 
formatin’ (f JNF,a_JNP,f3'JNP,kfb, i,s,y) ; 
formatin' (f”JNW,a JNW,f3“jNW,k,b,i,s,y); 
formatin’ (f”JNZ,a7f3 JNz7k,b,i,s,y) ; 


Table 6'’3c - Machine Code Instructions (Continued) 


6.13 Machine Code Insertions 


6-45 








Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


MACRO/L 


Ada/L 

JOF 


k,b,s 

formatin’(f JOFfa JOF,f3 JOF,k,b, i ,s,y); 

JOP 

a. 

y,k,b,s 

formatlll'jf JOPfaff3 JOP,k,b,i,sfy); 

JP 

a. 

y/k,b,s 

formatlll'if JPfaff3 JP,k,b,i,s,y); 

JS 

sy 

,k,b 

formatIII'(f JSfO,£3 JSfk,b,i,Sfy); 

JSC 

a/ 

y/k,b,s 

formatlll'if JSCfa,f3 JSCfk,b,i,sfy); 

JW 

y» 

k ,b,s 

formatIII’(f JW,a JW,l3 JW,k,b,i,s,y); 

J2 

a. 

y»k,b,s 

formatlll'if JZfaff3 JZ,k,b,i,s,y); 

LA 

a. 

y,k,b,s 

formatI'(f LA,afk,bfi,Sfy); 

LB 

a. 

y,k,b,a 

formatl'if LB,a,k,bfi,Sfy); 

LBJ 

a, 

y»k,b,s 

formatIII'(f LBJ,aff3 LBJ,k,b,i,s,y); 

LBMP 

a, 

y/b,s 

formatIMf LBMP,afk LBMP,b,i,s,y); 

LCI 

ak 

»y»b,s 

formatla'(? LCIfakfb,i,Sfy); 

LCMl 

y» 

b,s 

formatI'(f LCMl,a LCMlfk LCMlfbfi LCMl,s,y); 

LCM2 

y» 

b,s 

formatI'(f LCM2fa LCM2fk LCM2fbfi LCM2,Sfy); 

LCM3 

y/ 

b»s 

formatI’(f LCM3fa LCM3,k LCM3fb,i LCM3fSfy); 

LCM4 

y» 

b,s 

formatl’(f“LCM4fa LCM4fk LCM4fb,i LCM4,Sfy); 

LCMA 

y^ 

b,s 

formatI'(f LCMAfa LCMA,k LCMAfb,i LCMA,Sfy); 

LCMP 

y» 

b,s 

formatl’if LCMPfa LCMPfk LCMPfb,ifS,y); 

LCMT 

y/ 

bfS 

formatl'(f_LCMT,a_LCMT f k_LCMT f b,i_LCMT,s f y); 
formatl’ (£‘~LCPA,a,k LCPATbf ifS,y)T 

LCPA 

a. 

y»b,s 

LCRA 

ar 

y,b,3 

formatl’if LCRAfafk'^LCRAfbf i,s,y); 

LCT 

ak 

,yfb,3 

formatIa’(? LCTfakfSfifSfy); 

LDIP 

LECM 

a. 

y»k,b,a 

formatl’(f LDIFfSfkfbfifSfy); 
formatIVA’(f LECMfa LECMfOfi LECM ); 

LIBP 

a, 

yfb,s 

formatl’(f LlBPfafk LIBP,bfifS,y); 

LIM 

a, 

sy/b 

formatIi’(? LIMfSfk LIM,bfifSy); 

LIMP 

a, 

y»b,s 

formatI’(f LIMPfafk LIMPfbfi,s,y); 
formatIVA’Tf LISRfaTbfi LISR ); 

LISR 

a, 

b 

LLP 

a, 

yf b,s 

formatl’{f_LLPfafk_LLPfb,if3fy) ; 
formatl’if LLPNfSfk LLPN,bfi,s,y); 

LLPN 

a, 

y/b,s 

LM 

a, 

yf k,b,s 

formatl’if LM,afkfbfifSry); 

LMA 

d r 

yf kfbfS 

formatl’if LNAfafk,b,ifSfy); 

LRR 

a. 

m 

formatV’if~LRRfaff2 LRR,Of0,0fm,f6 LRR); 

LRRA 

LSCM 

a, 

bf i 

formatIVA’(f LRRAfafbfi); 
formatIVA’(f”LSCMfa LSCMfO,i LSCM); 

LSUM 

LTCM 

a, 

yf k,bf s 

formatI’(f LSUMfSfkfbfifSfy); 
formatIVA’(f LTCMfa LTCM,0fi LTCM ); 

LXB 

a, 

yfkfbfs 

formatl’(f LXBfafkfH,ifSfy); 

M 

a, 

yfkfbfs 

formatl’if MfafkfbfifSfy); 

MS 

a. 

yfbfS 

formatl’if MSfafk MSfbfifSfy); 

NLP 

a, 

yf bf s 

formatl’if~NLP,afk SLP,b,i,3,y); 

OR 

a, 

yfbfS 

formatl’if OR,afk ORfbfifSfy); 

PEI 

PFCD 

PFCE 

a. 

ay,b 

formatIi’(? PEIrafk PElfb,i,sy); 
formatIVA’(I PFCDfOTOfi PFCD ); 
formatIVA’(f_PFCEf0f0fi“PFCE ); 


Table 6-3d - Machine Code Instructions (Continued) 


6-46 


6.13 Machine Code Insertions 












Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


--- 

I MACRO/L Ada/L 


+- 

1 

PFR 

a. 

yrbrS 

formatI'(f PPR/a,k PPR,b,i PFR,s,y); 


1 

PIE 



formatIVA’Tf PIE, 0 , 0 ,i PIE); 


1 

PMM 

y/ 

b,s 

formatIMf PMM,a PMM,k PMM,b,i,s,y); 


1 

PMR 

y» 

bf s 

formatlMf PMR,a PMR,k PMR,b,i,s,y); 


I 

POP 

a, 

b 

forniatV(f POP,a,f2 POP,b,0,0,0,f6 POP); 


1 

PUSH 

a. 

b 

formatV'(f PUSH,a,f2 PUSH,b,0,0,0,f6 PUSH ); 


1 

RA 

a. 

y»k,b,s 

formatI'(f RA,a,k,b,r,s,y); “ 


1 

RALP 

a. 

y»b,s 

formatI'(f RALP,a,k HALP,b,i,s,y); 


1 

RAN 

a. 

yfk,b,3 

£ormatI'(f RAN,a,k,b,i,s,y); 


1 

RCCR 

y/ 

b,s 

formatIMf RCCR,a RCCR,k RCCR,b, i ,s,y); 


1 

RD 

a. 

y»k,b,s 

£ormatI'(£ RD,a,k,b,i,s,y); 


1 

RI 

a. 

y»k,b,s 

£ormatI*(£ RI,a,k,b,i,s,y); 


1 

RIOAS 

a. 

b 

formatIVA'(f RIOAS,a,b,i RIOAS); 


1 

RISR 

a. 

b 

formatIVA'(f RISR,a,b,i RISR ); 


1 

RJ 

y» 

k,b,s 

formatin'(f RJ,a RJ,f3 RJ,k,b,i,s,y); 


1 

RJC 

a. 

y»l«»b,s 

formatlll'if RJC,a,£3 RJC,k,b,i,s,y); 


1 

RJSC 

a. 

y/k,b,s 

£ormatIII'(£ RJSC,a,£3 RJSC,k,b,i,s,y); 


1 

RLP 

a, 

y»b,s 

£ormatI'(£ RLP,a,k RLP,b,i,s,y); 


1 

RMMS 

a. 

bi 

£ormatIVA'(£ RMMS,a,b,i); 


1 

RMS 

a. 

y»b,s 

£ormatI'(£ RMS,a,k RMS,b,i,s,y); 


1 

RMSR 

y» 

b,s 

£ormatI‘(£ RMSR,a RMSR,k RMSR,b,i,s,y); 


1 

RNLP 

a, 

yrbrS 

£orniatI’(f RNLP,a,k RNLP7b,i,s,y); 


1 

ROR 

a. 

y»b,s 

£ormatI'(£ ROR,a,k ROR,b,i,s,y); 


1 

RP 

a. 

sy,b 

formatIi'(r RP,a,k”RP,b,i,sy); 


1 

RPD 

Yf 

k,b,s 

£ormatI'(£ RPD,a RPO,k,b,i,s,y); 


1 

RRR 

a, 

m 

£ormatV'(£ RRR,'a7£2 RRR,0,0,0,m,£6 RRR ); 


1 

RSC 

a, 

y»b,s 

£ormatI'(£ RSC,a,k RSC,b,i,s,y); 


1 

RSD 

a 


£ormatIVA'(£ RSD,a,0,i RSD); 


1 

RXOR 

a, 

y»b,s 

formatI'(f RXOR,a,k RXOR,b,i,s,y); 


1 

SA 

a. 

yfk,b,3 

£ormatI'(£ SA,a,k,b,i,s,y); 


1 

SB 

a. 

y/k,b,s 

£ormatI'(£ SB,a,k,b,i,s,y); 


1 

SBN 

a. 

n 

formatIVC'Tf SBN,a,£4 SBN,n); 


1 

SBPC 

a. 

y»k,b,s 

formatI'(£ SBPC,a,k,b,i,s,y); 


1 

SC 

a, 

y»b,s 

£ormatI'(£ SC,a,k SC,b,i,s,y); 


1 

SCI 

ak 

»yfb,s 

£ormatIa'(? SCI,ak,b,i,s,y); 


1 

SCMA 

Yf 

b,s 

formatl’Cf SCMA,a SCMA,k SCMA,b,i SCMA,s,y); 


1 

SCMP 

Y> 

b,s 

£ormatI'(£ SCMP,a SCMP,k'~SCMP,b,i,s,y); 


1 

SCMT 

Y> 

b,s 

forraatI'(f SCMT,a“SCMT,k'"SCMT,b, i SCMT,s,y); 


1 

SCMl 

Yt 

b,s 

£ormatI'(£ SCMl,a SCMl,k SCMl,b,i SCMl,s,y); 


1 

SCM2 

Y> 

b,s 

£ormatI'(£ SCM2,a SCM2,k''SCN2,b,i SCM2,s,y); 


1 

SCM3 

Y> 

b,s 

£ormatI'(£ SCM3,a SCM3,k^SCMS,b,i SCM3,s,y); 


1 

SCM4 

Y> 

b,s 

£ormatI'(£ SCM4,a SCM4,k'SCM4,b,i SCM4,s,y); 


1 

SCPA 

a. 

y»b,s 

£ormatI’(f SCPA,a,k SCPA,b,i,s,y); 


1 

SCRA 

a, 

y/b,s 

formatI'(£ SCRA,a,k SCRA,b,i,s,y); 


1 

+- 

SCSR 

Y> 

h,3 

formatl*(f_SCSR,a_SCSR,k_SCSR,b,i,s,y); 



Table 6-3e ~ Machine Code Instructions (Continued) 


6.13 Machine Code Insertions 


6-47 











Version 2.0C Ada/L PSE Handbook 

30 September 1989 


MACRO/L 

Ada/L 

SCT 

ak,y,b,s 

formatIa'(£ SCT,ak,b,irS^y); 

SDIF 

a,y,b,s 

£ormatI'(£ SDIP/ark SDIP,b,i,s,y); 

SDMC 

a 

£ocmatIVA‘(f SDMC,a,0,i SDMC ); 

SIBP 

a,y,b,s 

£ormatI'(£ SIBPrark SIBP,b,i,s,y); 

SIMC 

a,b 

formatlVA'(f SIMC,a,b,i SIMC ); 

SIMP 

a,y,b,s 

formatI'(£ SIMP,a,k SIMP,b,i,s,y); 

SIRC 

arb 

formatIVA'(f SIRC,a,b,i SIRC ); 

SITC 

a,b 

formatlVA*(f SITC,a,b,i SITC ); 

SLP 

a,y,b,s 

£ormatI*(£ SLP,a,k SLP,b,i,s,y); 

SM 

a,y,k,b,a 

£ormatI'(f SM,a,k,b,i,s,y); 

SMCC 

a 

formatIVA'(f SMCC,a,0,i SMCC ); 

SMSR 

y,b,s 

£ormatI'(£ SMSR,a SMSR,k SMSR,b,i,s,y); 

SNA 

a,y,k,b,s 

£ormatI'(£ SNA,a,k,b,i,s,y); 

SRRA 

a,b,i 

£ormatIVA'(£ SRRA,a,b,i); 

SSUM 

a,y,b,s 

£ormatI'(f SSUM,a,k SSUM,b,i,s,y); 

STAP 

a,b 

£ormatV{f“STAP,a,£2 STAP,b,0,0,0,£6 STAP); 

STSB 

ak,y,bfs 

£ormatIa'(? STSB,ak,E,i,s,y); 

SXB 

a,y,k,b,a 

£ormatI'(C SXB,a,k,b,i,s,y); 

TBN 

a,n 

£ormatIVC‘(f TBN,a,£4 TBN,n); 

TR 

a,b 

£orniatV'(f TR,a,£2 TR,b,0,0,0,£6 TR); 

TSBN 

a,n 

£ormatIVC‘T£ TSBN,a,£4 TSBN,n); 

TSP 

y,b,a 

£ortiiatI'(£ TSP,0,k TSP,b,i,s,y); 

TSM 

bi 

£ormatIVA'Tf TSM ,a TSM,b,i); 

TV 

a,b 

£ormatV(f TV,a,£2 n,b, 0 , 0 , 0,£6 TV); 

WPBP 

a,y,b,s 

forniatI’(f"WPBP,a,lc WFBP,b,i WPBP,s,y); 

WPM 

a,y,b,s 

£ormatI‘(f”WFM,a,k WPM,b,i WFM,s,y); 

XOR 

a»y/b,s 

£ormatI'(£~XOR,a,k XOR,b,i,s,y); 

XR 

yrbrs 

£ormatI'(£‘“XR,0,k XR,b,i,s,y); 

XRL 

y,b,s 

£orinatI' (f~XRL,0,k XRL,b,i,s,y); 

xs 

3y»b 

£orniatI' (f_XS,a_XS,k_XS,b,i,sy); 


Table 6-3f - Machine Code Instructions (Continued) 


6-48 


6.13 Machine Code Insertions 









APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 







H 

• Si 

93 BP 
M K 

■"B 

BS 

3i^ 


SS 

O H 

a 

a 

OP M 
O H 


O 93 
B 
>• M 

®a 

s« 

H 93 

93 B 
M 

3i 

93 

B O 

e 

M H 
H 93 

HM -H 
B .J 






u 

Bb 

















LIHITS or SAKPLS shown by ANCLB BKACms 







- AH IHTBGBI LITKIUL HHOSli VALUB IS TUB NUBBBB Of BITS BBIIUIKBO Til 

- BOLD A TASI OBJBCT «HICH BAS A SINCLB BNTBY WITH ONE INOUT PARAHBTEB. 

- USED IN: CDBAOl. CDBABIB CDBADlC CDBAOID CD2AB1B 

FASI SIZB 82 


a 

H 


0 a 

I 33 

B 

B 

^ H 

< H H 

X H 

0.3 


cn M i 

a cn ■ 
< : 

sa-* 

H H ^ { 


<nk.cn 
. ^ M o < 

: cn -J mi 


H S M H 

M <n o <n 

m<mS» 



OH H cd 

at < 
ea 

H ■ 


k. 

H ft 


D H b 
OHO GB 

o at H Bh 

00 o ^ ae 
H H > ^ 00 
H cn BO 
M 00 H K 
a H B ^ o 

3 ^ at K 
0. < eo o 5 00 

S en B at lo 

="000* 

cn B B M CB H 

^ ^ S 00 o S 

^ H -B O 
< 00 H B A 

> at 5 mm 

DO S 3 ft cn S 
cn H > H H 

jStiH- 

ais^ia 

00 at 00 S 9 
HHflOSOMBca 
MMO^^HHfa 

i-^a.iaa 

at o S H a. H 
at 00 H B cn ^ 

s««-s2sae 

XKaicntfiScnGn 
ta ^ k Ht A H 3 


00 


cn 

H 


E at H 
E O 
V3 < k. 

^ B 00 
H CO O 
00 OB 
at at SO 2 < 
o B B o J 
k. B O 

H B 2 cn k 
H OHO 
2 Bb cn B 

§ M M cn 00 

flO QO O 

00 B 5 2 

O • B m3 < 

3 00 B a •< B 
^4 B ^ > 

hh 5 00 
I cn o a A 


a 00 k. a 00 H 

a 1=1""}:® 


S 


SjjmS 

o"as 

sosi 

. . .0 


at H 00 cn B o 
DO pj M 00 00 2 

a. 5 M H a. M 

•< cn B 

•< k. H Ob B 
OO B 2 O > 
cn A B 00 o 

NH«a B S B o 

H B 

liiois 

< H < a. 2 cn 
> k. 3 

B 3 A S S B 
cn a A H H B 
O H 

a O B 2 pb A 

j a H e 

^ M X • a 

oa M H H H 
t4 .4 at -H < 

M Q B •< X . 

"3ilS3$ 

ii! 

» C 4 B _ B 

axSpa^B 

A ? Ob O O B cn 


H 

3S 

A 




< 

B 


X 

O 


3 

O 

a 


o 

3 


sc h 

3 - 

< z 
> - 

B E 

V3 

c : 

S; 











APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated Indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the gtiards at lines 50 & 
54 and the execution of task CHANGING OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56“ 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84M & N, & CD50110 

These tests assvime that dependent tasks will terminate while the main 
program executes a loop chat simply tests for task termination; this is 
not Che case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 


D- 









CD2B15C & CD7205C 

These tescs expect that a 'STORAGE_SIZE length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SHALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent t)rpe; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent tjrpe. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B. & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARC. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file-'DATA_ERROR is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid, (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter; these calls were intended to specify a file, not to refer 
to STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 


D-2 








CE3411B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 
will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D-3 








APPENDIX E 


Compiler; 

ACVC Version: 


COMPILER OPTIONS AS SUPPLIED BY 

u.s. Navy 

Ada/L, Version 2.0 (/OPTIMIZE Option) 

1.10 


E-1 








Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


10.2 Options 

Options control the type of processing the compiler 
performs. They enable the selection of listings produced as part 
of the compilation process, make special processing requests, and 
indicate when special compilation units are being compiled. The 
compiler options, their functions and defaults are summarized in 
Table 10-1. Each option may be specified as shown or preceded by 
the three characters '•NO_" to specify the opposite option. For 
example, SOURCE turns the source listing on; NO_SOURCE turns the 
source listing off. 

The following error conditions are detected by the compiler 
during option processing. In each case, the compiler issues a 
WARNING diagnostic and takes the action indicated. 

a. The complement of an already-specified option is 
specified; the last option is honored. For example, 
if NO_SOCIRCE is specified, followed by SOURCE later 
in the option list, SOURCE is the option that will be 
in effect. 

b. An option is specified more than once. The last 
occurrence of the option is honored; all others are 
ignored. 

c. An undefined option is specified. The option is 
ignored. 

The compiler does not check options for redundant 
directions. For example, no error is reported when both 
NO_SOURCE and NO_PRIVATE are specified in the same compiler 
invocation. ” 

Some options impact the speed with which the compilation 
process is completed and the efficiency of the object code 
produced by the compiler. The remainder of this section 
discusses the implications of options for the compilation 
process, how options affect the quality of object code generated 
by the compiler, and guidelines for using them. 


10.2 Options 


10-03 





Version 2.0C Ada/L PSE Handbook 

30 September 1989 


Option 

Function 

Listing Control 

Options: 

ATTRIBUTE 

Produce a Symbol Attribute Listing. (Produces an 
attribute cross-reference listing when both 
ATTRIBUTE and CROSS REFERENCE are specified.) 
Default: NO ATTRIBUTE 

I 

CROSS_REFERENCE Produce a Cross-Reference Listing. (Produces an 
~ attribute cross-reference listing when both 

ATTRIBUTE and CROSS REFERENCE are specified.) I 

Default: NO CROSS REFERNCE j 

DIAGNOSTICS 

1 

Produce a Diagnostic Summary Listing. I 

Default: NO_DIAGNOSTICS 1 

MACHINE 

Produce a Machine Code Listing if code is j 
generated. Code is generated when 1 
CONTAINER_GENERATION option is in effect and (1) | 
there are'no diagnostics of severity ERROR, SYSTEM I 
or FATAL (2) NO_CODE_ON_MARNING option is in effect| 
and there are no diagnostics of severity higher I 
than NOTE. A diagnostic of severity NOTE is I 
reported when a Machine Code Listing is requested j 
and no code is generated. OCTAL is an additional I 
option that may be used with MACHINE to output I 
octal values on the listing instead of hex values. I 
Default: NO_MACHINE 1 

NOTES 

Include diagnostics of NOTE severity level in the 1 
Source Listing and Diagnostic Summary Listing. j 
Default: NO_NOTES 1 

PRIVATE 

If there is a Source Listing, text in the private I 
part of a package specification is listed in I 
accordance with the selected SOURCE option, subject! 
to requirements of LIST pragmas. Default: PRIVATE, j 

SOURCE 

Produce listing of Ada source statements. 1 

Default: NO_SOORCE I 

SUMMARY 

Produce a Summary Listing; always produced when j 
there are errors in the compilation. I 
Default: NO SUMMARY j 


Table 10-la - Ada Compiler Options 


10-04 


10.2 Options 









Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Option Function 


Special Processing Options: 

CHECKS Provide run-time error checking. 

NO_CHECKS suppresses all run-time error 
checking. Please refer to the Pragma 
SUPPRESS description for further information 
on run-cime error checking. 

Default: CHECKS 

CODE_ON_WARNING Generate code (and Machine Code Listing, if 

requested) only when there are no diagnostics 
of a severity higher than WARMING. 

NO__CODE_ON_WARNING means no code is generated 
when there“i3 a diagnostic of severity WARNING 
or higher (i.e.> ERROR, SYSTEM, or FATAL). 
Default: CODE_ON_WARNING 

CONTAINER_GENERATION 

~ Produce a container if diagnostic severity 

permits. NO^CONTAINER_GENERATION means that no 
container is~produced even if there are no 
diagnostics. No code (or Machine Code Listing, 
if requested) is generated if a container is not 
produced because the NO_CONTAlNER_GENERATION 
option is in effect. ” “ 

Default: CONTAINER_GENERATION 

DEBUG Include in compiler output only that information 

needed to link, export, and execute the current 
unit. This option is ignored for a unit that: 

o is a package or subprogram specification, 
o is a subprogram body for which there is 
no previous declaration, or 
o contains a body stub, pragma INLINE, 
generic declaration, or a generic body. 

If DEBUG is used, internal representations are 
stored in the container as well as additional 
symbolic information. 

A diagnostic of severity NOTE is issued when 
the option is ignored. 

Default: NO DEBUG 


Table 10-lb - Ada Compiler Options (Continued) 


10.2 Options 


10-05 












Version 2.0C 
30 September L989 


Ada/L PSE Handbook 


Option 

I 

1 

I Special Process 

I 

I EXECUTIVE 


MEASURE 
OPTIMIZE 

I 


RTE ONLY 


Table 


Function 


ing Options (continued): 

Enable pragma EXECUTIVE and allow visibility 
to units which have been compiled with the 
/RTE_ONLY option. 

Default: NO_EXECUTIVE. 

Deferred. 

Enable global optimizations in accordance with 
the optimization pragmas specified in the source 
program. When NO_OPTIMIZE is in effect, no 
global optimizations are performed, regardless 
of the pragmas specified. The optimize option 
enables global optimization. The goals of global 
optimization may be influenced by the user 
through the Ada defined optimize pragma. 

If time is specified, the optimizer concentrates 
on optimizing code execution time. If space is 
specified, the optimizer concentrates on 
optimizing code size. If the user does not 
include pragma optimize, the global optimizer 
tends to optimize time over space. 

Default: NO_OPTIMIZE 

Restrict visibility of this unit only to those 
units compiled with the /EXECUTIVE option. 
Default: NOT RTE ONLY. 


10-lc - Ada Compiler Options (Continued) 


10-06 


10.2 Options 











