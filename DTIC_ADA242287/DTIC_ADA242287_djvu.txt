REPORT AD-A242 287 


Pubic raputlng buRlin tor M coiMtIan at Mor 
notdod. ind fontouHng tho colKtion of Monnitt 
HoadquMon Sotvico. Otroctonm lor kiloniiatta 
Monogwnom and Budgal. Waahtngnn. OC 206— 


1. AGENCY USE ONLY (Leave Blank) 


2. REPORT DATE 


Form Approved 
OPM No. 0704-0188 


inatiucllon^ saarcbaig axioting data aourcaa gathaiing and mainlining lha data 
slactlon ol Mormatlon. kieluding auggaationa tor raducing dila burdan. to WaalangMn 
I. VA 22202-4302. and to lha Ollica at iitoimaiion and RagUalory Allaira. Ofllca ol 


3. REPORT TYPE AND DATES COVERED 


I Rnal: 11 Apr1991 


4 . TITLE AND SUBTITLE 

Hewlett-Packard Co./Apollo systems Division, Domain Ada V6.0p, DN10000, 
Domain/OS SR10.3.P (Host & Target), 910411W1.11138 a , - 

s J I U 


6. AUTHOR(S) * rv • r- , T , - 

Wright-Patterson AFB, Dayton, OH 
USA 


7. PERFORMING ORGANIZATION NAME(S) AND A00RESS(ES) 

Ada Validation Facility, Language Control Facility ASD/SCEL 
BkJg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 



irUcia: 


FORMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-452-0491 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADORESS<ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
W'ashington, D.C. 20301-3081 


10. SPONSORINGAiONITORING AGENCY 
REPORT NUMBER 


1. SUPPLEMENTARY NOTES / 1 , 1 . , i I / /• - /. 

J\J., / fc V' i^ U. rfr-../'>/ A- Vt , 

. ^ ^ ^ ^ ^ ' ' i S i‘ M }-\- - 


12a. DISTRIBUTION/AVAILABIUTY STATEMENT 

Approved for public release; distribution unlimited. 


12b, DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

Hewlett-Packard Co./Apollo systems Division, Domain Ada V6.0p, Wright-Patterson AFB, OH,DN10000, Domain/OS 
SR10.3.P (Host & Target), ACVC 1.11. 


I|91-15()49 


14, SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability. Val. Testing, Ada Val. Office. Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECURITY CLASSIFICATION 118 SECURITY CLASSIFICATION 119 SECURITY CLASSIFICATION 


OF REPORT 

UNCLASSIFIED 


NSN 7540-01 280-550 


UNCLASSIFED 


OF ABSTRACT 

UNCLASSIFIED 


15 NUMBER OF PAGES 


16 PRICE CODE 


20 LIMITATION OF ABSTRACT 


Ol HOT 1 ?! 


standard Form 298. (Rev 2-8') 
Prescribed by ANSI Std 239- 1 28 






















AVF Control Number: AVF-VSR-452-0491 

20-AUG-1991 

90-07-05-AP0 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910411W1.11138 
Hewlett-Packard Co./Apollo Systems Division 
Domain Ada V6.0p 

DNIOOOO, Domain/OS SR10.3.p => DNIOOOO, Domain/OS SR10.3.p 


Prepared By; 
Ada_Validation_Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 






Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 11 April, 1991. 

Compiler Name and Version: Domain Ada V6.0p 

Host Computer System: ONIOOOO running Domain/OS SR10.3.p 

Target Computer System: DNIOOOO running Domain/OS SR10.3.p 

Customer Agreement Number: 90-07-05-APO 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort, Validation Certificate 
910411W1.11138 is awarded to Hewlett-Packard Co./Apollo Systems Division. 
This certificate expires on 1 June 1993. 


This report has been reviewed and is approved. 



Ada Validation Facility 
Steven P. Wilson 
Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


Ada Validation Organization 


Director, Computer & Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 






Apollo Syatenw Division 

300 Apollo Drive 

Qieljnsford, Massachusetts 01824 

5082566600 

Fax 508 Z561509 


apollo 

A subsidiary of 

ra >^€W^■g^f 
«W^CICAflO 


Declaration of Conformance 

Customer: Hewlett-Packard Co./Apollo Systems Division 

Ada VUidadon Padlity: Wrigbt-Patterson AFB. Ohio 45433-6503 

ACVC Version: 1.11 

Ada Implementadon: 

Compiler Name and Version: Domain Ada V6.0p 

Host Computer System: DN10000. Domain/OS SR10J.p 


Target Computer System: Same 

Custmncr’s Declaration 

I. the undersigned, represendng Hewlett-Packard Company, declare that Hewlett-Packard 
Company has no knowledge of deliberate deviations from the Ada Language Standard 
ANSI/MJL-STD-1815A in the implementation listed in this declaration. 



Hewlett-Packard Co. 
300 Apollo Drive 
Chelmsford. MA 01824 






TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

l.A DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 


















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account o£ the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national lavs of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The orgeuiizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 





INTRODUCTION 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, FiBruary 1963 and ISO 8^52-1987. 

[Pro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint Program 
Office, August 1990. 

[UG89] Ada Compiler Validation Capability User's Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 




INTRODUCTION 


For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability 
(ACVC) 

Ada 

Implementation 

Ada Joint 
Program 
Office (AJPO) 

Ada 

Validation 
Facility (AVF) 

Ada 

Validation 

Organization 

(AVO) 

Compliance of 
an Ada 

Implementation 

Computer 

System 


The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

The means for testing compliance of Ada implementations, 
consisting of the test suite, the support programs, the ACVC 
user's guide and the template for the validation summary 
report. 

An Ada compiler with its host computer system and its 
target computer system. 

The part of the certification body which provides policy and 
guidance for the Ada certification system. 


The part of the certification body which carries out the 
procedures required to establish the compliance of an Ada 
implementation. 

The part of the certification body that provides technical 
guidance for operations of the Ada certification system. 


The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 






INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 




CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 14 March 1991. 


E28005C 

B28006C 

C34006D 

C35508N 

C35702A 

C35702B 

C45346A 

C45612A 

C45612B 

B49008A 

A74006A 

C74308A 

B83025D 

C83026A 

B83026B 

C94021A 

C97116A 

C98003B 

CB7004A 

CC1223A 

BC1226A 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A41A 

CD2A41E 

CD2A87A 

CD4022A 

CD4022D 

CD4024B 

CD4051D 

CD5111A 

CD7004C 

CD7006E 

AD7201A 

AD7201E 

BD8004C 

CD9005A 

CD9005B 

CE2117B 

CE2119B 

CE2205B 

CE3118A 

CE3411B 

CE3412B 

CE3812A 

CE3814A 

CE3902B 


C35508I 

C35508J 

C35508M 

B41308B 

C43004A 

C45114A 

C45612C 

C45651A 

C46022A 

B83022B 

B83022H 

B83025B 

C83041A 

B85001L 

C86001F 

BA2011A 

CB7001A 

CB7001B 

CC1226B 

BC3009B 

BD1B02B 

CD2A21E 

CD2A23E 

CD2A32A 

CD2B15C 

BD3006A 

BD4008A 

CD4024C 

CD4024D 

CD4031A 

ED7005D 

CD7005E 

AD7006A 

CD7204B 

AD7206A 

BD8002A 

CDA201E 

CE2107I 

CE2117A 

CE2405A 

CE3111C 

CE3116A 

CE3607B 

CE3607C 

CE3607D 


2.2 INAPPLICABLE TESTS 


A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 




IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 

C45241L..Y (14 tests) C45321L..Y (14 tests) 

C45421L..Y (14 tests) C45521L..Z (15 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 


following 20 

tests check 

for the 

predefined type 

L0NG_INTEGER 

C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 

CD7101F 


C35713C, B86001U, and C86006G check for the predefined type L0NG_FL0AT. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, L0NG_FL0AT, or SH0RT_FL0AT. 

A35801E checks that FLOAT'FIRST..FLOAT'LAST may be used as a range 
constraint in a floating-point type declaration; for this 
implementation, that range exceeds the safe numbers and must be 
rejected. (See section 2.3) 

C45531M..P (4 tests) and C45532M..P (4 tests) check fixed-point 
operations for types that require a SYSTEM.MAX_MANTISSA of 47 or 
greater. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_0VERFL0WS is FALSE for floating point types; for this 
implementation, MACHINE_0VERFL0WS is TRUE. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATION'BASE that are outside the 
range of DURATION. There are no such values for this implementation. 

CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions. 


2-2 




IMPLEMENTATION DEPENDENCIES 


The tests listed in the following table are not applicable because the 
given file operations are supported for the given combination of mode 
and file access method. 


Test 

File Operation Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL TO 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE21020 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT 10 

CE3102E 

CREATE 

IN FILE 

TEXT 10 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT 10 


CE2203A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for SEQUENTIAL_I0. This implementation does 
not restrict file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_I0. This implementation does not 
restrict file capacity. 

CE3304A checks that USE_ERROR is raised if a call to SET_LINE_LENGTH or 
SET_PAGE_LENGTH specifies a value that is inappropriate for the external 
file. This implementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page 
number exceeds COUNT'LAST. For this implementation, the value of 
COUNT'LAST is greater than 150000, thus making the checks'ng of this 
objective impractical. 


2-3 






IMPLEMENTATION DEPENDENCIES 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 22 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 

B20049A B33301B B38003A B38003B B38009A B38009B 

B85008G B85008H BC1303F BC3005B BD2B03A BD2D03A 

BD4003A 


A35801E was graded inapplicable by Evaluation Modification as directed by 
the AVO; the compiler rejects the use of the range FLOAT'FIRST..FLOAT'LAST 
as the range constraint of a floating-point type declaration because the 
bounds lie outside of the range of safe numbers (cf. ARM 3.5.7(12)). 

CD1009A, CD1009I, CD1C03A, CD2A22J, CD2A24A, and CD2A31A..C (3 tests) were 
graded passed by Evaluation Modification as directed by the AVO. These 
tests use instantiations of the support procedure LENGTH_CHECK, which uses 
Unchecked_Conversion according to the interpretation given in AI-00590. 

The AVO ruled that this interpretation is not binding under ACVC 1.11; the 
tests are ruled to be passed if they produce Failed messages only from the 
instances of LENGTH CHECK—i.e, the allowed Report.Failed messages have the 
general form: ~ 

" * CHECK ON REPRESENTATION FOR <TYPE ID> FAILED.” 


2-4 







CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
implementation system, see: 

Peter J. Morris 
Hewlett-Packard Co 
300 Apollo Drive 
Chelmsford MA 01824 

For a point of contact for sales information about this Ada implementation 
system, see: 


Peter J. Morris 
Hewlett-Packard Co 
300 Apollo Drive 
Chelmsford MA 01824 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 








PROCESSING INFORMATION 


a) Total Number of Applicable Tests 3802 

b) Total Number of Withdrawn Tests 93 

c) Processed Inapplicable Tests 74 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 275 


g) Total Number of Tests for ACVC 1.11 4170 


All I/O tests of the test suite were processed because this implementation 
supports a file system. The above number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the implementation. When this compiler was tested, the tests 
listed in section 2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this compiler was 
tested, the tests listed in section 2.1 had been withdrawn because of test 
errors. The AVF determined that 275 tests were inapplicable to this 
implementation. All inapplicable tests were processed during validation 
testing except for 201 executable tests that use floating-point precision 
exceeding that supported by the implementation. In addition, the modified 
tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were read by two workstations, in an adjacent building. The 
contents were then copied over the network to the host computers. 


Testing was done on two host computers connected together on a network. 
After the test files were loaded onto the host computers, the full set of 
tests was processed by the Ada implementation. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 

Option ( Switch Effect 


-el 


Produce Error Listing 


3-2 







PROCESSING INFORMATION 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$BIG_ID1 (1..V-1 => 'A', V => '1') 

$BIG_ID2 (1..V-1 => 'A', V *> '2') 

$BIG_ID3 (1..V/2 => 'A') & '3' & 

(1..V-1-V/2 => 'A') 

$BIG_ID4 (1..V/2 => 'A') & '4' & 

(1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & "298" 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 & (1..V/2 => 'A') 6. 

$BIG_STRING2 & (1..V-1-V/2 => 'A') & '1' & 

SBLANKS (1..V-20 => ' ') 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11;" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 => 'A') & 


A-1 




MACRO PARAMETERS 


The following table lists all of the other macro parameters and their 
respective values: 

Macro Parameter Macro Value 


$MAX_IN_LEN 

$ACC_SIZE 

SALIGNMENT 

$COUNT_LAST 

$DEFAULT_MEM_SIZE 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRy_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

SGREATER THAN DURATION 


499 

32 

4 

2147483647 

16777216 

8 

AP0LL0_UNIX_A88K 

0.0000000004656612873077392578125 
SYSTEM. "+"(16#40#) 

SYSTEM. "+"(16#80#) 

SYSTEM. "+"(16#100#) 

2147483647 

/ 9 

NO_SUCH_FIXED_TYPE 

NO_SUCH_FLOAT_NAME 

nn 

"CANNOT RESTRICT FILE CAPACITY" 


100 _ 000.0 

$GREATER_THAN_DURATION_BASE_LAST 

10_000_000.0 

$GREATER_THAN_FLOAT_BASE_LAST 

1.8E+308 

$GREATER_THAN_FLOAT_SAFE_LARGE 

1.0E308 


A-2 






MACRO PARAMETERS 


$GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

1.0E308 

$HIGH_PRIORITY 99 

$ILLEGAL_EXTERNAL_FILE_NAME1 

/illegal/file_name/2{]$X2102C.DAT 

$ILLEGAL_EXTERNAL_FILE_NAME2 

/illegal/file_name/CE2102C*.DAT 

$INAPPROPRIATE_LINE_LENGTH 

-1 


$INAPPROPRIATE_PAGE_ 

LENGTH 

-1 


$INCLUDE_PRAGMA1 

PRAGMA INCLUDE 

('’A28006D1.A") 

$INCLUDE_PRAGMA2 

PRAGMA INCLUDE 

("B28006F1.A") 

$INTEGER_FIRST 

-2147483648 


$INTEGER_LAST 

2147483647 


$INTEGER_LAST_PLUS_1 

2147483648 


$INTERFACE_LANGUAGE 

C 


$LESS_THAN_DURATION 

-100_000.0 


$LESS_THAN_DURATION_^ 

BASE FIRST 

-1U_000_000.0 


$LINE_TERMINATOR 

ASCII.LF 


$LOW_PRIORITY 

0 


SMACHINE CODE STATEMENT 

NULL; 


$MACHINE_CODE_TYPE 

NO_SUCH_TYPE 


$MANTISSA_DOC 

31 


$MAX_DIGITS 

15 


$MAX_INT 

2147483647 


$MAX_INT_PLUS_1 

2147483648 


$MIN INT 

-2147483648 



A-3 




MACRO PARAMETERS 


$NAME 

TINY_INTEGER 

$NAME_LIST 

APOLLO_UNIX_A88K,APOLLO_UNIX_l 

$NAME_SPECIFICATIONl 

//obsolete/ada tests.store 
/acvc l.ll_valTdation/v6.0.p 
/resuTts/ctests/ce/ 
ce2120a.lib/X2120A 

$NAME_SPECIFICATION2 

//obsolete/ada tests.store 
/acvc 1.11 validation/v6.0.p 
/results/ctests/ce/ 
ce2120b.lib/X2120B 

$NAME_SPECIFICATION3 

//obsolete/ada tests.store 
/acvc 1.11 validation/v6.0.p 
/resuTts/ctests/ce/ 
ce3119a.lib/X3119A 

$NEG_BASED_INT 

16#F0000000E# 

$NEW_MEM_SIZE 

16_777_216 

$NEU_STOR_UNIT 

8 

$NEW_SYS_NAME 

AP0LL0_UNIX_A88K 

$PAGE_TERMINATOR 

ASCII.LF&ASCII.FF 

$RECORD_DEFINITION 

NEW INTEGER; 

$RECORD_NAME 

NO_SUCH_MACHINE_CODE_TYPE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

2000 

STICK 

0.01 

$VARIABLE_ADDRESS 

VAR_1'ADDRESS 

$VARIABLE_ADDRESS1 

VAR_2'ADDRESS 

$VARIABLE_ADDRESS2 

VAR_3'ADDRESS 

SYOUR PRAGMA 

EXTERNAL NAME 


A-4 





APPENDIX B 


COMPILATION SYSTEM OPTIONS 


COMPILER OPTIONS 

The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 

-# id type value (define) Define an identifier of a specified type 
and value. 

-a file_name (archive) Treat file_name as an ar file. Since some 

"archive files end with .a, use -a to distinguish archive files 
from Ada source files. 

-d (dependencies) Analyze for dependencies only. Do not do 

semantic analysis or code generation. Update the library, 
marking any defined units as uncompiled, a.make uses the 
-d option to establish dependencies among new files. 

-e (error) Process compilation error messages using a.error and 

send it to stdout (standard output). Only the source lines 
containing errors are listed. Use only one -e or -E option. 

-E 

-E file 

-E directory (error output) Without a file or directory argument, ada 
processes error messages using a.error and directs a brief 
output to stdout; the raw error messages are left in 
ada_source.err. If a file pathname is specified, the raw 
error messages are placed in that file. If a directory 
argument is supplied, the raw error output is placed in 
dir/source.err. Then, the file of raw error messages can be 
used as input to a.error. Use only one -e or -E option. 

-el (error listing) Intersperse error messages among source lines 
and direct to stdout. 


B-1 





COMPILATION SYSTEM OPTIONS 


-El 


-El file 

-El directory (error listing) Same as the -E option, except that a 
source listing with errors is produced. 

-ev (error vi) Process syntax error messages using a.error, embed 
them in the source file, and call the environment editor, 

EDITOR. 

-K (keep) Keep the Intermediate Language (IL) file produced by the 

compiler front end. The IL file will be placed in the .objects 
directory, with the filename ada_source.i If the -0 option is 
used, the compiler places an ada_source.O file in the same 
directory. 

- L ada_library (library) Operate in Domain/Ada library library_name 
(the current working directory is the default). 

-Ifile_abbreviation (library) This is an option passed to the Domain/OS 
linker telling it to search the specified library file. (Do not 
put a space between the -1 and the file abbreviation.) 

-M unit_name (main) Produce an executable program using the named unit 
as the main program. The unit must be either a parameterless 
procedure or a parameterless function returning an integer. 

The executable program will be left in the file a.out unless 
overridden with the -o option. 

-M ada_source.a (main) Similar to -M unit_name, except that the unit name 
is assumed to be the root name of the .a file. (In the example, 
”-M example.a", the unit name is assumed to be "example".) Only 
one .a file can be preceded by -M. 

-n Suppress the generation of symbol table information (for use by 

Apollo's performance analysis tools, tb and dpat) in the object 
module. 

-o executable_file (output) Use this option in conjunction with the -M 
option. Executable_file is the name of the executable rather 
than the default, a.out. 

-P (preprocessor) Invoke the Domain/Ada preprocessor. See Chapter 6 
for a detailed discussion. 

-R Domain/Ada_library (recompile instantiation) Force analysis of all 

generic instantiations, causing reinstantiation of any that are 
out of date. 

-S (suppress) Apply pragma SUPPRESS to the entire compilation for 

all suppressible checks. 


B-2 






COMPILATION SYSTEM OPTIONS 


-sh (show) Display the pathnames of the compiler components. 

-T (timing) Print timing information for the compilation. 

-V (verbose) Print compiler version number, date and time of 

compilation, name of file compiled, command input line, total 
compilation time, and error sununary line. 

-w (warnings) Suppress warning diagnostics. 

-'c <options>' where <options> can be any of the options listed in the 
following table. Use this option to pass options to the 
DNIOOOO code generator. 

Domain/Ada Series 10000 Compiler Options 


Option 


What It Causes the Compiler to Do 


* -compress 
-ncompress 
-ndb 


-db 


Store all non-bss data in compressed form. 

Store data in uncompressed form. 

Suppress creation of debugging information. Both a.db 
and Domain/DDE cannot debug such a program. 

Generate minimal debugging information. When debugging 
this program, breakpoints can be set, but variables 
cannot be examined. 


* -dbs 


-dba 


-exp 


Generate full run-time debug information and optimize 
the source code in the executable object file. (Implies 
-opt 3.) 

Generate full run-time debug information but don't 
optimize the source code in the executable object file. 
(Implies -opt 0.) Use -dba along with -00 to avoid 
all optimization effects when planning to use the 
debugger. 

Generate assembly language listing. 


* -nexp 


Suppress creating assembly language listing. 


-inlib pathname Load pathname (a PIC binary file) at run time and 

resolve global variable references. Thus pathname can 
be used as a library file for many different programs. 


-nclines Suppress generation of COFF line number tables. 


-opt n Optimize the code in the executable object to the nth 

level, n is an optional specifier that must be between 


B-3 





COMPILATION SYSTEM 

* -prasm 

-nprasm 

-zero 

* -nzero 


OPTIONS 


0 and 3. If n is omitted, or the entire switch is 
omitted, optimize to level 3. 

Format assembler listing in Series 10000 assembler 
format. 

Format assembler listing in a format similar to the 
680x0-based assembler. 

Initialize to zero all statically allocated variables. 
Do not initialize all statically allocated variables. 


* denotes a default option 



COMPILATION SYSTEM OPTIONS 


LINKER OPTIONS 

The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and not 
to this report. 

-E unit_name (elaborate) Elaborate unit_name as early in the elaboration 
order as possible. 

-F (files) Print a list of dependent files in order and suppress 

linking. 

-o executable_file (output) Use the specified filename as the name of the 
output rather than the default, a.out. 

-sh (show) Display the pathname of the tool executable, but do not 
execute it. 

-U (units) Print a list of dependent units in order and suppress 

linking. 

-V (verbose) Print the linker command before executing it. 

-V (verify) Print the linker command, but suppress execution. 





APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -2147483648 .. 2147483647; 
type SHORT_INTEGER is range -32768 .. 32767; 
type TINY_INTEGER is range -128 .. 127; 

type FLOAT is digits 15 range -1.79769313486231E+308 .. 

1.79769313486231E+308; 

type SHORT_FLOAT is digits 6 range -3.40282E+38 .. 3.40282E+38; 

type DURATION is delta 1.OOOOOOOOOOOOOOE-3 range -2147483.648 .. 

2147483.647; 


end STANDARD; 


C-1 






APPENDIX F OF THE Ada STANDARD 


Implementation-Dependent Characteristics 
This section summarizes the Domain/Ada f ies 10000 

implementation-dependent characteristics ^‘5 required by Appendix F of the 
Ada Language Reference Manual (RM). 


Implementation-Dependent Pragmas and Attributes 

This section details the Domain/Ada Series 10000 implementation-dependent 
pragmas and attributes. 


Implementation-Dependent Pragmas 

Domain/Ada provides the following pragmas in its Series 10000 
implementation: 

BUILT_IN 

pragma BUILT_IN is used in the implementation of some predefined Ada 
packages, but provides no user access. It is used only to implement 
code bodies for which no actual Ada body can be provided. 

EXTERNAL_NAME 

pragma EXTERNAL_NAME allows a link_name for an Ada variable or 
subprogram to be specified so that the object from programs written in 
other languages can be referenced. 

INLINE_0NLY 

pragma INLINE_0NLY, when used in the same way as pragma INLINE, 
indicates to the compiler that the subprogram must always be inlined. 
(This is very important for some code procedures.) This pragma also 
suppresses the generation of a callable version of the routine, which 
saves code space. 

INTERFACE_NAME 

pragma INTERFACE_NAME allows variables and subprograms defined in 
another language to be referenced from Ada programs, replacing all 
occurrences of a ada_subprogram_or_object name with an external 
reference to a link_name in the object file. The pragma 
INTERFACE_NAME, used in conjunction with pragma INTERFACE, allows the 
exact name of the subprogram being called to be specified by providing 
an optional linker name for the subprogram. This optional linker name 
enables the calling of a subprogram defined in another language whose 
name contains characters that are not allowed in an Ada identifier. 


C-2 





APPENDIX F OF THE Ada STANDARD 


NO_IMAGE 

pragma N0_IMAGE suppresses the generation of the image array used 
for the IMAGE attribute of enumeration types. This eliminates the 
overhead required to store the array in the executable image. 

NON_REENTRANT 

pragma NON_REENTRANT takes one argument which can be the name of 
either a library subprogram or a subprogram declared immediately 
within a library package spec or body. It indicates to the compiler 
that the subprogram will not be called recursively, thus allowing the 
compiler to perform specific optimizations. The pragma can be applied 
to a subprogram or a set of overloaded subprograms within a package 
spec or package body. 

NOT_ELABORATED 

pragma NOT_ELABORATED, which is allowed only within a package 
specification, suppresses elaboration checks for all entities defined 
within a package, including the package specification itself. In 
addition, this pragma suppresses the generation of elaboration code. 
When using pragma NOT_ELABORATED, there must be no entities defined in 
the program that require elaboration. 

PASSIVE 

pragma PASSIVE has three forms: 

PRAGMA PASSIVE; 

PRAGMA PASSIVE(SEMAPHORE); 

PRAGMA PASSIVE(INTERRUPT, <number>); 


This pragma can be applied to a task or task type declared immediately 
within a library package spec or body. The pragma directs the 
compiler to optimize certain tasking operations. It is possible that 
the statements in a task body will prevent the intended optimization; 
in these cases, a warning will be generated at compile time and will 
raise TASKING_ERROR at runtime. 

SHARE_CODE 

pragma SHARE_CODE provides for the sharing of object code between 
multiple instantiations of the same generic procedure or package body. 
A "parent" instantiation is created, and subsequent instantiations of 
the same types can share the parent's object code, reducing program 
size and compilation times. The name pragma SHARE_BODY instead of 
SHARE CODE can be used with the same effect. 


C-3 




APPENDIX F OF THE Ada STANDARD 


In addition to the pragmas mentioned in the previous list, the Domain/Ada 
Series 10000 implementation expands upon the functionality of the following 
predefined language pragmas: 

INLINE 

pragma INLINE is implemented as described in Appendix B of the RM 
with the addition that recursive calls can be expanded up to the 
maximum depth of 8. The compiler produces warnings for nestings that 
are too deep or for bodies that are not available for inline 
expansion. 

PACK 

pragma PACK causes the compiler to minimize gaps between components 
in the representation of composite types. For arrays, the compiler 
packs components to bit sizes corresponding to powers of 2 (if the 
field is smaller than ST0RAGE_UNIT bits). The compiler packs objects 
larger than a single ST0RAGE_lINIT to the nearest ST0RAGE_UNIT. 

SUPPRESS 

pragma SUPPRESS is supported in the single parameter form. The 
pragma applies from the point of occurrence to the end of the 
innermost enclosing block. DIVISION_CHECK, RANGE_CHECK, 

DISCRIMINANT CHECK, INDEX_CHECK, LENGTH_CHECK, or ACCESS_CHECK cannot 
be suppressed. The double parameter form of the pragma with a name of 
an object, type, or subtype is recognized, but has no effect in the 
current release. This pragma can be used to suppress elaboration 
checks on any compilation unit except a package specification. 


The Domain/Ada Series 10000 implementation recognizes the following 
pragmas, but they have no effect in the current release: 

pragma CONTROLLED 

pragma MEM0RY_SIZE 

pragma OPTIMIZE 

pragma SHARED 

pragma ST0RAGE_UNIT (This implementation does not allow 
modification of package SYSTEM by means of pragmas. However, the same 
effect can be achieved by recompiling package SYSTEM with altered 
values.) 

pragma SYSTEM_NAME (This implementation does not allow modification 
of package SYSTEM by means of pragmas. However, the file system.a can 
be copied from the STANDARD library to a local Domain/Ada library and 
recompiled there with the new values.) 


C-4 



APPENDIX F OF THE Ada STANDARD 


The following pragmas are implemented as described in Appendix B of the RM: 
pragma ELABORATE 

pragma INTERFACE (supports C and FORTRAN only) 
pragma LIST 
pragma PAGE 
pragma PRIORITY 


Implementation-Defined Attribute: 'REF 
The Domain/Ada Series 10000 implementation provides one 

implementation-defined attribute, 'REF. Attribute 'REF can be used in the 
form SYSTEM.ADDRESS'REF(N) anywhere that an integer expression is to be 
converted to an address. 

The effect of SYSTEM.ADDRESS'REF<N) is similar to the effect of an 
unchecked conversion from integer to address. However, this attribute 
should be used instead of an unchecked conversion in the following 
circumstances (in these circumstances, N must be static): 

Within any of the run-time configuration packages: Use of 
unchecked conversion within an address clause would require the 
generation of elaboration code, but the configuration packages are not 
elaborated. 

In any instance where N is greater than INTEGER'LAST: Such values 
are required in address clauses that reference the upper portion of 
memory. To use unchecked conversion in these instances would require 
that the expression be given as a negative integer. 

To place an object at an address, use the 'REF attribute: The 
integer_value, in the following example, is converted to an address for use 
in the address clause representation specification. The form avoids 
UNCHECKED_C0NVERSI0N and is also useful for 32-bit unsigned addresses. 

—place an object at an address 

for object use at ADDRESS'REF (integer_value) 

—to use unsigned addresses 

for VECTOR use at SYSTEM.ADDRESS'REF(16#808000d0#); 

T0P_0F MEMORY: SYSTEM.ADDRESS:= SYSTEM.ADDRESS'REF(16#FFFFFFFF#); 


In SYSTEM.ADDRESS'REF(N), SYSTEM.ADDRESS must be the type SYSTEM.ADDRESS. 

N must be an expression of type UNIVERSAL_INTEGER. The attribute returns a 
value of type SYSTEM.ADDRESS, which represents the address designated by N. 


C-5 




APPENDIX F OF THE Ada STANDARD 


Specification of the Package SYSTEM 


with IINSIGNED_TYPES; 
package SYSTEM is 

pragma SUPPRESS(ALL_CHECKS); 
pragma SUPPRESS(EXCEPTION_TABLES); 
pragma NOT_ELABORATED; 

type NAME is ( apollo_unix_a88k, apollo_unix_m68k ); 

SYSTEM_NAME : constant NAME := apollo_unix_a88k; 

STORAGE_UNIT : constant := 8; 

MEMORY_SIZE : constant := 16_777_216; 

— System-Dependent Named Numbers 

MIN_INT : constant := -2_147_483_648; 

MAX_INT : constant := 2_147_483_647; 

MAX_DIGITS : constant := 15; 

MAX_MANTISSA : constant := 31; 

FINE_DELTA : constant := 2.0**(-31); 

TICK : constant := 0.01; 

— Other System-dependent Declarations 

subtype PRIORITY is INTEGER range 0 .. 99; 

MAX_REC_SIZE : integer := 64*1024; 

type ADDRESS is private; 

function ">" (A: ADDRESS; B: ADDRESS) return BOOLEAN; 

function "<" (A: ADDRESS; B: ADDRESS) return BOOLEAN; 

function ">="(A; ADDRESS; B; ADDRESS) return BOOLEAN; 

function "<="(A; ADDRESS; B: ADDRESS) return BOOLEAN; 

function (A: ADDRESS; B: ADDRESS) return INTEGER; 

function "+" (A; ADDRESS; I; INTEGER) return ADDRESS; 

function (A; ADDRESS; I: INTEGER) return ADDRESS; 

function "+" (I: UNSIGNED_TYPES.UNSIGNED_INTEGER) return ADDRESS; 

function MEMORY_ADDRESS 

(I: UNSIGNED_TYPES.UNSIGNED_INTEGER) return ADDRESS renames "+" 

N0_ADDR : constant ADDRESS; 

type TASK_ID is private; 

NO TASK ID : constant TASK ID; 


C-6 



APPENDIX F OF THE Ada STANDARD 


type PROGRAM_ID is private; 

NO PROGRAM ID : constant PROGRAM ID; 


private 


type ADDRESS is new UNSIGNED_TYPES.UNSIGNED_INTEGER; 

NO_ADDR : constant ADDRESS 0; 

pragma BUI LT_IN (•’>'•); 
pragma BUILT_IN(”<"); 
pragma BUILT_IN( '•>="); 
pragma BUILT_IN("<="); 
pragma BUILT_IN("-"); 
pragma BUILT_IN(); 

type TASK_ID is new UNSIGNED_TYPES.UNSIGNED_INTEGER; 
NO_TASK_ID ; constant TASK_ID :* 0; 

type PROGRAM_ID is new UNSIGNED_TYPES.UNSIGNED_INTEGER; 
N0_PR0GRAM_ID : constant PROGRAMID := 0; 

end SYSTEM; 


Restrictions on Representation Clauses and Unchecked Type Conversions 

This section summarizes the restrictions on representation clauses and 
unchecked type conversions for the Series 10000 implementation of 
Domain/Ada. 

The representation clauses that Domain/Ada supports are described in 
Chapter 14. 


Representation Clauses 

The Domain/Ada Series 10000 implementation supports bit level, length, 
enumeration, size, and record representation clauses. Size clauses are not 
supported for tasks, floating-point types, or access types. This 
implementation supports address clauses for objects except for task objects 
and for initialized objects given dynamic addresses. Address clauses for 
task entries are supported; the specified value is a UNIX signal value. 

The only restrictions on record representation clauses are the following: 

If a component does not start and end on a storage unit boundary, 
it must be possible to get the component into a register with one move 
instruction. Because longwords start on even bytes, the component 
must fit into four bytes starting on a word boundary. 


C-7 



iiJ^PENDIX F OF TaE Ada STANDAilD 


A component that is itseli a record must occupy a number ot bits 
equal to a power o£ two. CunipuneniJi that are ot s, discrete type or 
packed array can occupy an arbitrary number of bits subject to the 
previously mentioned restrictions. 


Unchecked Type Conversions 

This implementation of Domain/Ada supports the generic function 
UNCKECKEUCONVERSION with the iolioving restriction: 

The predefined generic tunction UNCHECWiD_CONVERSION cannot be 
instantiated with a target type that is an unconstrained array type or 
an unconstrained record type with discriminants. 


Denoting Implementation-Dependent Components 
in Record Representation Clauses 

.Record representation clauses are based on the target machine's word, byte* 
and bit order numbering so that Donain/Ada is consistent with various 
machine architecture manuals, flits within a ST0RAGE_UNIT are also numbered 
according to the target machine manuals- This implementation of Domain/Ada 
does not support the allocation of implementation-dependent components in 
records. 


Implementation-Dependent Chacacteristics of I/O Packages 

The Ada I/O system is implemented usi.ng Domain/OS I/O. Both formatted I/O 
and binary I/O are available. There are no restrictions on the types with 
which DIRECT_I0 and SEQUENTIAL_IO can be instantiated except that the 
element .size must be less than a maximum given by the variable 
SYSTEM.MAX_^REC_SIZE. This variable can be set to any value prior to the 
generic instantiation; thus, any element size can be used. DIRZCT_I0 can 
be instantiated with unconstrained types, but each element will be padded 
out to the maximum possible for that type or to SYSTEM.MAX REC SIZE, 
whichever is smaller. No checking—other than normal static Ada type 
checking--is done to ensure that values from files are read into correctly 
sized and typed objects. 

Domain/Ada file and terminal input/output are identical in most respects 
and differ only in the frequency of buffer flushing. Output is buffered 
(buffer size is 102A bytes), and the buffer is flusheo after each write 
request if the destination is a terminal- 

The procedure FTLE_SUPPORT.ALUAyS_FI.USH (fiie_ptr) will cause flushing of 
the buffer associated with file ptr after all subsequent output requests. 
Refer to the source code for file_spprt_b.a in the standard library for 
more information. 


C-8 




APPENDIX F OF THE Ada STANDARD 


Instantiations of DIRECT_IO 

Instantiations of DIRECT_IO use the value MAX_REC_SIZE as the record size 
(expressed in STORAGE UNITs) when the size of ELEMENT_TYPE exceeds that 
value. For example, ?or unconstrained arrays such as a string where 
ELEMENT_TYPE'SIZE is very large, HAX_REC_SIZE is used instead. 

MAX_REC_SIZE (defined in package SYSTEM)”can be changed before 
instantiating DIRECT_IO to provide an upper limit on the record size. The 
maximum size supported is 1024 * 1024 * ST0RAGE_UNIT bits. DIRECT_I0 will 
raise USE ERROR if MAX REG SIZE exceeds this absolute limit. 


Instantiations of SEQUENTIAL_I0 

Instantiations of SEQUENTIAL_I0 use the value MAX REC_SIZE as the record 
size (expressed in STORAGE UNITs) when the size ol ELEMENT_TYPE exceeds 
that value. For example. Tor unconstrained arrays such as STRING where 
ELEMENT_TYPE'SIZE is very large, MAX_REC_SIZE is used instead. 

MAX_REC SIZE (defined in package SYSTEM) can be changed before 
instantiating INTEGER_I0 to provide an upper limit on the record size. 
SEQUENTIAL_I0 imposes no limit on MAX_REC_SIZE. 


Additional Implementation-Dependent Features 

This section details any other features that are specific to the Domain/Ada 
Series 10000 implementation. 


Restrictions on "Main" Programs 

Domain/Ada requires that a "main" program must be a non-generic subprogram 
that is either a procedure or a function returning an Ada STANDARD.INTEGER 
(the predefined type). In addition, a "main" program cannot be an 
instantiation of a generic subprogram. 


Generic Declarations 

Domain/Ada does not require that a generic declaration and the 
corresponding body be part of the same compilation, and they are not 
required to exist in the same Domain/Ada library. The compiler generates 
an error if a single compilation contains two versions of the same unit. 


C-9 




APPENDIX F OF THE Ada STANDARD 


Implementation-Dependent Portions of Predefined Ada Packages 

Domain/Ada supplies the following predefined Ada packages given by the Ada 
RM C(22) in the standard library: 

package STANDARD 

package CALENDAR 

package SYSTEM 

generic procedure UNCHECKED_DEALLOCATION 

generic function UNCHECKED_CONVERSION 

generic package SEQUENTIAL_IO 

generic package DIRECT_IO 

package TEXT_IO 

package IO_EXCEPTIONS 

package LOW_LEVEL 10 


The implementation-dependent portions of the predefined Ada packages define 
the following types and objects: 


<in package STANDARD> 


type BOOLEAN is 

type TINY_INTEGER is 

type SHORT_INTEGER is 

type INTEGER is 

type SH0RT_FL0AT is 

type FLOAT is 

type DURATION is <delta 


<8-bit, byte>; 

<8-bit, byte integer>; 

<16-bit, word integer>; 

<32-bit, longword integer>; 
<6-digit, 32-bit, float>; 
<15-digit, 64-bit, float>; 

1.OOOOOOOOOOOOOOE-03 range 

-2147483.648 .. 2147483.647>; 


<in package DIRECT_I0> 

type COUNT is 

<in package TEXT_I0> 

type COUNT is 
subtype FIELD is 


range 0 2 147 483 647; 


range 0 •. 2_147_483_647; 

INTEGER range 0 .. INTEGER'last; 


C-10 






APPENDIX F OF THE Ada STANDARD 


Values of Integer Attributes 

The Series 10000 implementation of Domain/Ada provides three integer types 
in addition to universal_integer: INTEGER, SHORT INTEGER, and 
TINY_INTEGER. Table F-1 lists the ranges for these integer types. 

Table F-1. Domain/Ada Integer Types 


Name of 

Attribute Value 

Attribute Value 

Attribute Value 

Attribute 

of INTEGER 

of SHORT INTEGER 

of TINY_INTEGER 

FIRST 

-2 147 483 648 

-32 768 

-128 

LAST 

2_147_483_647 

32_767 

127 


% 


C-ll 




APPENDIX F OF THE Ada STANDARD 


Values of Floating-Point Attributes 
Table F-2 lists the attributes of floating-point types. 


Table F-2. Domain/Ada Floating-Point Types 


Name of 

Attribute 

Attribute Value 
of FLOAT 

Attribute Value 
of SH0RT_FL0AT 

SIZE 

64 

32 

FIRST 

-1.79769313486231E+308 

-3.40282E+38 

LAST 

1.79769313486231E+308 

3.40282E+38 

DIGITS 

15 

6 

MANTISSA 

51 

21 

EPSILON 

8.88178419700125E-16 

9.53674316406250E-07 

EMAX 

204 

84 

SMALL 

1.94469227433160E-62 

2.58493941422821E-26 

LARGE 

2.57110087081438E+61 

1.93428038904620E+25 

SAFE EMAX 

1022 

126 

SAFE SMALL 

1.11253692925360E-308 

5.87747175411143E-39 

SAFE_LARGE 

4.49423283715578E+307 

8.5075511654154E+37 

MACHINE RADIX 

2 

2 

machine“mantissa 

53 

24 

MACHINE EMAX 

1024 

128 

machine“emin 

-1022 

-126 

MACHINE ROUNDS 

TRUE 

TRUE 

MACHINE OVERFLOWS 

TRUE 

TRUE 


C-12 





APPENDIX F OF THE Ada STANDARD 


Attributes of Type DURATION 


Table F-3 lists the attributes for the fixed-point type DURATION, 
Table F-3. Attributes for the Fixed-Point Type DURATION 


Name of 

Attribute 

Attribute Value 
for DURATION 

SIZE 

32 

FIRST 

-2147483.648 

LAST 

2147483.647 

DELTA 

l.OOOOOOOOOOOOOOE-03 

MANTISSA 

31 

SMALL 

9.76562500000000E-04 

LARGE 

4.19430399902343E_06 

FORE 

8 

AFT 

3 

SAFE SMALL 

9.76562500000000E-04 

SAFE_LARGE 

4.19430399902343E+06 

MACHINE ROUNDS 

TRUE 

MACHINE'OVERFLOWS 

TRUE 


Implementation Limits 

Character Set: Domain/Ada provides the full graphic_character textual 
representation for programs. The character set for source files and 
internal character representations is ASCII. 

Lexical Elements, Separators, and Delimiters: Domain/Ada uses normal 
Domain/OS I/O text files as input. Each line is terminated by a newline 
character (ASCII.LF). 

Source File Limits: Domain/Ada imposes the following limitations on source 
files: 


499 characters per source line 
1296 Ada units per source file 
32767 lines per source file 


C-13 






