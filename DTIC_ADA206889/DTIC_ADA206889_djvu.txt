UNCLASSIFIED _ 

SECURITY CLASSIFICATION Of THIS PAGE (When Pete Entered) 

REPORT DOCUMENTATION PAC 


1. REPORT NUMBER 


4. TITLE (end Subtitle) 


THIS RAGE (When Pete Entered) , rT\f\C QQQ 

DOCUMENTATION P AGE_ AD”A2uo 

copj ' 


m 


Ada Compiler Validation Summary Report: Harris 
Corporation, Harris Ada Compiler, Version 4.0, Harris 
HCX-9 (Host) and (Target), 880603W1.09059 


7. authors; 

Wright-Patterson AFB 
Dayton OH 


9. PERFORMING ORGANIZATION AND AODRESS 

Wright-Patterson AFB 
Dayton OH 


11. CONTROLLING OFFICE NAME AND ApDRESS 

Ada Joint Program Office 

United States Department of Defense 

Washington, DC 2U301-3081 


14. MONITORING AGENCY NAME & ADDRESSEE different from Controlling Office) 

Wright-Patterson AFB 
Dayton OH 


16. DISTRIBUTION STATEMENT (of this Report) 


S. TYRE OF REPORT l PERIOD COVERED 

6 June 1988 to 6 June 1988 


6. PERFORMINGT>R6. REPORT NUMBER 


B. CONTRACT OR GRANT NUMBERS 


10. PROGRAM ELEMENT. PROJECT. TASK 
AREA 6 WORK UNIT NUMBERS 


12. REPORT DATE 


IS. SECURITY CLASS (ot this report) 

UNCLASSIFIF 


ISa. gJE^S^FlCAUGN/DOWNGRADlNG 
U N/A 


Approved for public release; distribution unlimited. 


17. DISTRIBUTION STATEMENT (of the ebstrect entered in Block 20 If different from Report) 

UNCLASSIFIED 


18. SUPPLEMENTARY NOTES 


ELECTE 

1 3 APR 1909 



^7 


19. KEYWORDS (Continue on reverse side if netessery end identify by block number) 

Ada Programming language, Ada Compiler Validation Summary Report, Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/KIL-STD- 
1815A, Ada Joint Program Office, AJPO 


20. ABSTRACT (Continue on reverse tide if necessery end identify by block number! 

Harris Corporation, Harris Ada Compiler, Version 4.0, Wright-Patterson AFB, Harris 
HCX-9 under HCX/UX, Version 3.0 (Host) to Harris HCX-9 under HCX/UX, Version 3.0 
(Target), ACVC 1.9. 


1473 EDITION OF 1 NOV 6S IS OBSOLETE 
7J S/N 0102-LF-014-6601 




UNCLASSIFIED 

CLASS^ICATION^OF -*<IS PAG 


hmDe n te r e d) 


,<m0 












AVF Control Number: AVF-VSR-AVF-VSR-156.0289 

88-03-02-HAR 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 880603W1 .09059 
Harris Corporation 
Harris Ada Compiler, Version 4.0 
Harris HCX-9 


Completion of On-Site Testing: 
06 June 1988 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


Accession For 


NTIS GRAAI 
DTIC TAB 
Unannounced 
Justificatlc 

"T~ 

□ 

m 


Bv 

Distribution/ 

Availability Codes 

Dist 

i/ 

Avail 

Spec 

and/or 

ial 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 









Ada Compiler Validation Summary Report: 

Compiler Name.: Harris Ada Compiler, Version 4.0 

Certificate Number: 880603W1.09059 

Host: Target: 

Harris HCX-9 under Harris HCX-9 under 

HCX/UX, Version 3-0 HCX/UX, Version 3.0 

Testing Completed 06 June 1988 Using ACVC 1.9 

This report has been reviewed and is approved. 



Ada Validation Facility 


Steven P. Wilson 


Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



Dr. John F. Kramer 


Institute for Defense Analyses 


Alexandria VA 22311 



Ada Joint Program Office 
William S. Ritchie 
Acting Director 
Department of Defense 
Washington, DC 20301 


2 





Ada Compiler Validation Summary Report: 

Compiler Name: Harris Ada Compiler, Version 4.0 

Certificate Number: 880603W1.09059 

Host: Target: 

Harris HCX-9 under Harris HCX-9 under 

HCX/UX, Version 3.0 HCX/UX, Version 3.0 

Testing Completed 06 June 1988 Using ACVC 1.9 

This report has been reviewed and is approved. 




Ada Validation Facility 
Steven P. Wilson 
Technical Director 
ASD/SCEL 


Wright-Patterson AFB OH 45433-6503 


Ada Validation Organization 
Dr. John F. Kramer 
Institute for Defense Analy: 
Alexandria VA 22311 



Ada Joint Program Office 
Virginia L. Castor 
Director 

Department of Defense 
Washington DC 20301 


2 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 ' USE OF THIS VALIDATION SUMMARY REPORT.1-2 

• 1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-4 

1.5 ACVC TEST CLASSES.1-5 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3-2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 ■ INAPPLICABLE TESTS.3-2 

3.6 -TEST, PROCESSING, AND EVALUATION MODIFICATIONS . . 3-4 

~3.7 ADDITIONAL TESTING INFORMATION . 3-4 

3.7.1 Pre validation.3-4 

3.7.2 Test Method.3-4 

3.7.3 Test Site.3-5 


APPENDIX A DECLARATION OF CONFORMANCE 


APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 



















CHAPTER 1 
INTRODUCTION 


/""■-Ai 

This Validation Summary Report describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of testin g this compiler using the Ada Compiler 
Validation Capability « r <ACVC)ix^ An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. ', 


£ Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations.. 
The Ada Standard permits some implementation dependencies—for example, the/ 
maximum length of identifiers or the maximum values of integer typep. 
Other differences between compilers result from the characteristics/of 
particular operating systems, hardware, or implementation strategies. C-All 
the dependencies observed during the process of testing this compiler are 
given in this report^ 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. ~\The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation dependent but permitted by the Ada Standard. Six classes of 
test3 are used. These tests are designed to perform checks at compile 
time, at link time, and during execution. 



v. 


1-1 



INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR docisnents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by SofTeeh, Inc. under the 
direction of the AVF according to procedures established by the Ada Joint 
Program Office and administered by the Ada Validation Organization (AVO). 
On-site testing was completed 06 June 1988 at Ft. Lauderdale, FL. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of'this report. In the United States, 
this is provided in accordance with the "Freedom of Information Act" (5 
U.S.C. #552). The results of this validation apply only to the computers, 
operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


1-2 




INTRODUCTION 


Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines , Ada Joint 
Program Office, 1 January 198?. 

3. Ada Compiler Validation Capability Implementers 1 Guide , SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 




INTRODUCTION 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

Ada An Ada Commentary contains all information relevant to the 

Commentary point addressed by a comment on the Ada Standard. These 

comments are given a unique identification number having the 
form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines . 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 
demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 

Target The computer for which a compiler generates code. 

Test A program that checks a compiler’s conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be incorrect 


1-4 







INTRODUCTION 


because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce compilation or link errors. 

Class A tests check that legal Ada programs can be successfully compiled 
and executed. There are no explicit program components In a Class A test 
to check semantics. For example, a Class A test checks that reserved words 
of another language (other than those already reserved in the Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed If no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B testa check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that every syntax or 
semantic error in the test is detected. A Class B test is passed if every 
illegal construct that it contains is detected by the compiler. 

Class C tests check that legal Ada programs cam be correctly compiled and 
executed. Each Class C test is self-checking and produces a PASSED, 
FAILED, or NOT APPLICABLE message indicating the result when it is 
executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Each Class E test is self-checking and produces a NOT APPLICABLE, PASSED, 
or FAILED message when it is compiled and executed. However, the Ada 
Standard permits an implementation to reject programs containing some 
features addressed by Class E tests during compilation. Therefore, a Class 
E test is passed by a compiler if it is compiled successfully and executes 
to produce a PASSED message, or if it is rejected by the compiler for an 
allowable reason. 




1-5 




INTRODUCTION 


Class L tests check that Incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Ca<*ss L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. 

Two library units, the package REPORT and the procedure CHECK__FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also provides a set of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FILE is used to 
check the contents of text files written by some of the Class C tests for 
chapter 14 of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of the tests in the ACVC follow conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
place features that may not be supported by all implementations in separate 
tests. However, some tests contain values that require the test to be 
customized according to implementation-specific values—for example, an 
illegal file name. A list of the values used for this validation is 
provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain am illegal 
language construct or an erroneous lamguage construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation au?e given in Appendix D. 


1-6 






CHAPTER 2 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under the 
following configuration: 


Compiler: Harris Ada Compiler, Version ^.0 
ACVC Version: 1.9 

Certificate Number: 880603W1.09059 

Host Computer: 

Machine: Harris HCX-9 

Operating System: HCX/UX, Version 3-0 

Memory Size: 32 megabytes 


Target Computer: 

Machine: 

Operating System: 
Memory Size: 


Harris HCX-9 
HCX/UX, Version 3-0 
32 megabytes 


2-1 




CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the 
behavior of a compiler in those areas of the Ada Standard that 
permit implementations to differ. Class D and E tests specifically 
check for such implementation differences. However, tests in other 
classes also characterize an implementation. The tests demonstrate 
the following characteristics: 


. Capacities. 

The compiler correctly processes tests containing loop 
statements nested to 65 levels, block statements nested to 65 
levels, and recursive procedures separately compiled as 
subunits nested to 17 levels. It correctly processes a 
compilation containing 723 variables in the same declarative 
part. (See tests D55A03A..H (8 tests), D56001B, D64005E..G (3 
tests), and D29002K.) 


. Universal integer calculations. 

An implementation is allowed to reject universal integer 
calculations having values that exceed SYSTEM.MAX_INT. This 
implementation processes 64-bit integer calculations. (See 
test3 D4A002A, D4A002B, D4A004A, and D4A004B.) 


. Predefined typ .. 

This implementation supports the additional predefined types 
SHORT_INTEGER, LONG_FLOAT, and TINYJCNTEGER in the package 
STANDARD. (See tests B86001C and B86001D.) 


. Based literals. 

An implementation is allowed to reject a based literal with a 
value exceeding SYSTEM.MAX_INT during compilation, or it may 
raise NUMERIC_ERROR or CONSTRAINT_ERROR during execution. This 
implementation raises NUMERIC_ERROR during execution. (See 
test E24101A.) 


. Expression evaluation. 

Apparently no default initialization expressions for record 
components are evaluated before any value is checked to belong 
to a component’s subtype. (See test C32117A.) 


2-2 








CONFIGURATION INFORMATION 


Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 

This implementation uses no extra bits for extra precision and 
all extra bits for extra range. (See test C35903A.) 

Sometimes NUMERIC_ERROR is raised when an integer literal 
operand in a comparison or membership test is outside the range 
of the base type. (See test C45232A.) 

Apparently NUMERIC_ERROR is raised when a literal operand in a 
fixed-point comparison or membership test is outside the range 
of the base type. (See test C45252A.) 

Apparently underflow is not gradual. (See tests C45524A..Z.) 


. Rounding. 

The method used for rounding to integer is apparently round 
away from zero. (See tests C46012A..Z.) 

The method used for rounding to longest integer is apparently 
round away from zero. (See tests C46012A..Z.) 

The method used for rounding to integer in static universal 
real expressions is apparently round away from zero. (See test 
C4A014A.) 


. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINTJSRROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For this 
implementation: 

Declaration of an array type or subtype declaration with more 
than SYSTEM.MAX_INT components raises no exception. (See test 
C36003A.) 

NUMERIC_ERROR is raised when ’LENGTH is applied to an array 
type with INTEGER’LAST + 2 components. (See test C36202A) 

NUMERIC_ERROR is raised when ’LENGTH is applied to an array 
type with SYSTEM.MAX_INT + 2 components. (See test C36202B.) 

A packed BOOLEAN array having a ’LENGTH exceeding INTEGER'LAST 
raises NUMERIC_ERROR when the array type is declared. (See 
test C52103X.) 


2-3 




CONFIGURATION INFORMATION 


A packed two-dimensional BOOLEAN array with more than 
INTEGER’LAST components raises NUMERIC_ERROR when the array 
subtype is declared. (See test C52104Y.) 

A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR either 
when declared or assigned. Alternatively, an implementation 
may accept the declaration. However, lengths must match in 
array slice assignments. This implementation raises 
NUMERIC_ERROR when the array type is declared. (See test 
E52103Y.) 

In assigning one-dimensional array types, the expression 
appears to be evaluated in its entirety before CONSTRAINT_ERROR 
is raised when checking whether the expression’s subtype is 
compatible with the target's subtype. In assigning 
two-dimensional array types, the expression does not appear to 
be evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is compatible 
with the target’s subtype. (See test C52013A.) 


. Discriminated types. 

During compilation, an implementation is allowed to either 
accept or reject an incomplete type with discriminants that is 
used in an access type definition with a compatible 
discriminant constraint. This implementation accepts such 
subtype indications during compilation. (See test E38104A.) 

In assigning record types with discriminants, the expression 
appears to be evaluated in its entirety before CONSTRAINT__ERROR 
is raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 


. Aggregates. 

In the evaluation of a multi-dimensional aggregate, all choices 
appear to be evaluated before checking against the index type. 
(See tests C43207A and C43207B.) 

In the evaluation of an aggregate containing subaggregates, all 
choices are evaluated before being checked for identical 
bounds. (See test E43212B.) 

All choices are evaluated before CONSTRAINT_ERROR is raised if 
a bound in a nonnull range of a nonnull aggregate does not 
belong to an index subtype. (See test E43211B.) 


2-4 









CONFIGURATION INFORMATION 


Representation clauses. 

An implementation might legitimately place restrictions on 
representation clauses used by some of the tests. If a 
representation clause is used by a test in a way that violates 
a restriction, then the implementation must reject it. 

Enumeration representation clauses containing noncontiguous 
values for enumeration types other than character and boolean 
types are supported. (See tests C35502I..J, C35502M..N, and 

A39005F.) 

Enumeration representation clauses containing noncontiguous 
values for character types are supported. (See tests 
C35507I..J, C35507M..N, and C55B16A.) 

Enumeration representation clauses for boolean types containing 
representational values other than (FALSE => 0, TRUE => 1) are 
supported. (See tests C35508I..J and C35508M..N.) 

Length clauses with SIZE specifications for enumeration types 
are supported. (See test A39005B.) 

Length clauses with STORAGEjSIZE specifications for access 
types are supported. (See tests A39005C and C87B62B.) 

Length clauses with ST0RAGE_SlZE specifications for task types 
are supported. (See tests A39005D and C87B62D.) 

Length clauses with SMALL specifications are not supported. 
(See tests A39005E and C87B62C.) 

Length clauses with SIZE specifications for derived integer 
types are supported. (See test C87B62A.) 


Pragmas. 

The pragma INLINE is supported for procedures and functions. 
(See tests LA3004A, LA3004B, EA3004C, EA3004D, CA3004E, and 
CA3004F.) 


Input/output. 

The package SEQUENTIAL_I0 can be instantiated with 
unconstrained array types and record types with discriminants 
without defaults. (See tests AE2101C, EE2201D, and EE2201E.) 

The package DIRECT__I0 can be instantiated with unconstrained 
array types and record types with discriminants without 
defaults. (See tests AE2101H, EE2401D, and EE2401G.) 


2-5 






CONFIGURATION INFORMATION 


Modes IN_FILE and OUT_FILE are supported for SEQUENTIAL_IO. 
(See tests CE2102D and CE2102E.) 

Modes IN FILE, OUT_FILE, and INOUT_FILE are supported for 
DIRECT_IO. (See tests CE2102F, CE2102I, and CE2102J.) 

RESET and DELETE are supported for SEQUENTIAL_IO and DIRECT_IO. 
(See tests CE2102G and CE2102K.) 

Dynamic creation and deletion of files are supported for 
SEQUENTIAL_IO and DIRECTJEO. (See tests CE2106A and CE2106B.) 

Overwriting to a sequential file truncates the file to last 
element written. (See test CE2208B.) 

An existing text file can be opened and created in OUT_FILE 
mode, and can be created in IN_FILE mode. (See test EE31C2C.) 

More than one internal file can be associated with each 
external file for text I/O for both reading and writing. (See 
tests CE3111A..E (5 tests), CE3114B, and CE3115A.) 

More than one internal file can be associated with each 
external file for sequential I/O for both reading and writing. 
(See tests CE2107A..D (4 tests), CE2110B, and CE2111D.) 

More than one internal file can be associated with each 
external file for direct I/O for both reading and writing. 
(See tests CE2107F..I (5 tests), CE2110B, and CE2111H.) 

An internal sequential access file and an internal direct 
access file can be associated with a single external file for 
writing. (See test CE2107E.) 

An external file associated with more than one internal file 
can be deleted for SEQUENTIAL_IO, DIRECT_IO, and TEXT_IO. (See 
test CE2110B.) 

Temporary sequential files are given names. Temporary direct 
files are given names. Temporary files given names are deleted 
when they are closed. (See tests CE2108A and CE2108C.) 









CONFIGURATION INFORMATION 


. Generics. 

Generic subprogram declarations and bodies can be compiled in 
separate compilations. (See tests CA1012A and CA2009F.) 

Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, BC3204C, and 

BC3205D.) 

Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


2-7 








CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.9 of the ACVC comprises 3122 tests. When this compiler was 
tested, 27 tests had been withdrawn because of test errors. The AVF 
determined that 322 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 285 
executable tests that use floating-point precision exceeding that supported 
by the implementation. Modifications to the code, processing, or grading 
for 26 tests were required to successfully demonstrate the test objective. 
(See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

108 

1048 

1536 

17 

18 

46 

2773 

Inapplicable 

2 

3 

317 

0 

0 

0 

322 

Withdrawn 

3 

2 

21 

0 

1 

0 

27 

TOTAL 

113 

1053 

1874 

17 

19 

46 

3122 


3-1 






TEST INFORMATION 


3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT CHAPTER TOTAL 

_ 2 3 4 5 6 7 8 9 _1_0 _11_ __1£ _lii_ 

Passed 184 468 483 245 166 98 140 326 137 36 234 3 253 2773 

Inapplicable 20 104 191 3 0 0 3 1 0 0 0 0 0 322 

Withdrawn 2 14 30012000212 27 

TOTAL 206 586 677 248 166 99 145 327 137 36 236 4 255 3122 


3.4 WITHDRAWN TESTS 

The following 27 tests were withdrawn from ACVC Version 1.9 at the time of 
this validation: 


B28003A 

E28005C 

C34004A 

C35502P 

A35902C 

C35904A 

C35904B 

C35A03E 

C35A03R 

C37213H 

C37213J 

C37215C 

C37215E 

C37215G 

C37215H 

C38102C 

C41402A 

C45332A 

G45614C 

A74106C 

C85018B 

CE2401H 

C87B04B 

CE3208A 

CC1311B 

BC3105A 

AD1A01A 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some test 3 do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation Is considered 
each time a validation is attempted. . A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 322 tests were inapplicable for the 
reasons indicated: 


. C35702A uses SH0RT_FL0AT which is not supported by this 

implementation. 

. A39005E and C87B62C use length clauses with SMALL specifications 

which au*e not supported by this implementation. 


3-2 





TEST INFORMATION 


. A39005G uses a record representation clause which is not supported 

by this compiler. 

. The following 13 tests use LONG__INTEGER, which is not supported by 
this compiler: 

C45231C C45304C C45502C C45503C C45504C 

C45504F 045611C 0456130 0456310 0456320 

B52004D B55B09C C55B07A 

. C45231D requires a macro substitution for any predefined numeric 

types other than INTEGER, SH0RT_INTEGER, L0NG_INTEGER, FLOAT, 
SH0RT_FL0AT, and LONG_FL0AT. This compiler does not support any 
such types. 

. C45531I, C45531J, C45532I, and 045532J use fine 32-bit fixed-point 
base types which are not supported by this compiler. 

. C45531K, C45531L, C45532K, and C45532L use coarse 32-bit fixed- 

point base types which are not supported by this compiler. 

. C45531M, C45531N, C45532M, and C45532N use fine 48-bit fixed-point 
base types which are not supported by this compiler. 

. C455310, C45531P, C455320, and C45532P use coarse 48-bit 
fixed-point base types which are not supported by this compiler. 

. B86001D requires a predefined numeric type other than those 

defined by the Ada language in package STANDARD. There is no such 
type for this implementation. 

. C86001F redefines package SYSTEM, but TEXT_I0 is made obsolete by 

this new definition in this implementation and the test cannot be 
executed since the package REPORT is dependent on the package 
TEXT_I0. 

. C96005B requires the range of type DURATION to be different from 

those of its base type; in this implementation they are the same. 

. The following 285 tests require a floating-point accuracy that 
exceeds the maximum of 9 digits supported by this implementation: 

C24113F..Y (20 tests) C35705F..Y (20 tests) 

C35706F..Y (20 tests) C35707F..Y (20 tests) 

C35708F..Y (20 tests) C35802F..Z (21 tests) 

C45241F..Y (20 tests) C45321F..Y (20 tests) 

C45421F..Y (20 tests) C45521F..Z (21 tests) 

C45524F..Z (21 tests) C45621F..Z (21 tests) 

C45641F..Y (20 tests) C46012F..Z (21 tests) 


3-3 




TEST INFORMATION 


3.6 TEST, PnOCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection; splitting 
a Class B test into subtests so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming behavior that wasn’t anticipated by the test (such as raising 
one exception instead of another). 

Modifications were required for 26 Class B tests. 

The following Class B tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B24009A 

B24204A 

B24204B 

B24204C 

B25002A 

B2A003A 

B2A003B 

B2A003C 

B33301A 

B36002A 

B37201A 

B38003A 

B38003B 

B38009A 

B38009B 

B44001A 

B64001A 

B67001A 

B67001B 

B67001C 

B67001D 

B91003B 

B95001A 

B97102A 

BC1303F 


BC3005B 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.9 produced by 
the Harris Ada Compiler was submitted to the AVF by the applicant for 
review. Analysis of these results demonstrated that the compiler 
successfully passed all applicable tests, and the compiler exhibited the 
expected behavior on all inapplicable tests. 


3.7.2 Test Method 

Testing of the Harris Ada Compiler using ACVC Version 1.9 was conducted 
on-site by a validation team from the AVF. The configuration consisted of 
a Harris HCX-9 host and target operating under HCX/UX, Version 3*0. 

A magnetic tape containing all tests except for withdrawn tests and tests 
requiring unsupported floating-point precisions was taken on-site by the 
validation team for processing. Tests that make use of 
implementation-specific values were customized before being written to the 
magnetic tape. Tests requiring modifications during the prevalidation 
testing were included in their modified form on the magnetic tape. 


3-4 







TEST INFORMATION 


The contents of the magnetic tape were loaded directly onto the host 
computer. After the test files were loaded to disk, the full set of tests 
was compiled on the Harris HCX-9» and all executable tests were linked and 
run on the Harris HCX-9. Results were printed from the host computer. 

The compiler was tested using command scripts provided by Harris 
Corporation and reviewed by the validation team. The compiler was tested 
using the following options: 

Option Effect 

-el Produce error listing. Used on all tests. 

-w Suppress warning messages. Used on Class A, C, D, 

L and support tests. 


Tests were compiled, linked, and executed (as appropriate) using a single 
host computer and a single target computer. Test output, compilation 
listings, and job logs were captured on magnetic tape and archived at the 
AVF. The listings examined on-site by the validation team were also 
archived. 


3.7.3 Test Site 

Testing was conducted at Ft. .Lauderdale, FL and was completed on 06 June 

1988. 


3-5 




APPENDIX A 


DECLARATION OF CONFORMANCE 


Harris Corporation has submitted the following 
Declaration of Conformance concerning the Harris Ada 
Compiler. 


A-1 







DECLARATION OF CONFORMANCE 


DECLARATION OF CONFORMANCE 


Compiler Implementor: Harris Corporation 

Ada Validation Facility: Ada Validation Facility, ASD/SCEL, 

Wright-Patterson AFB OH 45433-6503 

Ada Compiler Validation Capability (ACVC) Version: 1.9 


Base Configuration 


Base Compiler Name: Harris Ada Compiler Version: Version 4.0 

Host Architecture ISA: Harris HCX-9 OS&VER #: HCX/UX, Version 3-0 

Target Architecture ISA: Harris HCX-9 OS&VER #: HCX/UX, Version 3-0 


Implementor's Declaration 

I, the undersigned, representing Harris Corporation, have implemented no 
deliberate extensions to the Ada Language Standard ANSI/MIL-STD-1815A in 
the compiler(s) listed in this declaration. I declare that Harris 
Corporation is the owner of record of the Ada language compiler(s) listed 
above and, as such, is responsible for maintaining said compiler(s) in 
conformance to ANSI/M3L-STD-1815A. All certificates and registrations for 
Ada language compiler(s) listed in this declaration shall be made only in 
the owner's corporate name. 


' ■ . r - Date: 

Harris Corporation 

Wendell E. Norton, Director of Contracts 


Owner's Declaration 

I, the undersigned, representing Harris Corporation, take full 
responsibility for implementation and maintenance of the Ada compiler(s) 
listed above, and agree to the public disclosure of the final Validation 
Summary Report. I further agree to continue to comply with the Ada 
trademark policy, as defined by the Ada Joint Program Office. I declare 
that all of the Ada language compilers listed, and their host/target 
performance, are in compliance with the Ada Language Standard 
ANSI/MIL-STD-1815A. 


Date: 

Harris Corporation 

Wendell E. Norton, Director of Contracts 


A-2 








APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation- 
dependent pragmas, to certain machine-dependent conventions as mentioned in 
chapter 13 of the Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of 
the Harris Ada Compiler, Version 4.0, are described in the following 
sections, which discuss topics in Appendix F of the Ada Standard. 
Implementation-specific portions of the package STANDARD are also included 
in this appendix. 


package STANDARD is 


type INTEGER is range -2_147_483_648 .. 2_147_483_647; 
type SHORT_INTEGER is range -32768 .. 32767; 
type TINY_INTEGER is range -128 .. 127; 

type FLOAT is digits 6 range -2#0.1111111111 _1111111111_111UE127 •• 

2#0.1111111111_1111111111_11110E127; 

type LQNG_FL0AT is digits 9 range 

-200.1111111111_1111111111_1111111111_1111111111_1111111111_111111#E127 
2#0.1111111111_1111111111_1111111111_1111111111_1111111111_111111#E127 

type DURATION is delta 2#1.0#E-13 range ~2#1000000000_00000000.0# .. 

2#111imi11_1111111.1111111111J 11#; 


end STANDARD; 


B-1 






CHAPTER 5 


IMPLEMENTATION-DEPENDENT CHARACTERISTICS 

(Note: This chapter operates as Appendix F of the Ada RM.) 


5.1 IMPLEMENTATION-DEPENDENT PRAGMAS 

HAPSE provides for sharing of generic bodies (procedures and packages), when 
the generic parameters are restricted to enumeration types, integer types, and 
floating types. 

PRAGMA SHARE_BODY is used to indicate desire to share or not share an 
instantiation. The pragma may reference the generic unit or the instantiated 
unit. When it references a generic unit, it gets sharing on/off for all 
instantiations of the generic, unless overridden by specific SHARE_BODY 
pragmas for individual instantiations. When it references an instantiated 
unit, sharing is on/off only for that unit. The default is to share all 
generics that can be shared, unless the unit uses PRAGMA IN_LINE. 

PRAGMA SHARE_BODY is only allowed in the following places: immediately within 
a declarative part, immediately within a package specification, or after a 
library unit in a compilation, but before any subsequent compilation unit. 
The form of this pragma is 

pragma SHARE_BODY (generie_name, boolean_literal) 

Note that a parent instantiation is independent of any individual 
instantiation, therefore recompilation of a generic with different parameters 
has no effect on other compilations that reference it. The unit that caused 
compilation of a parent instantiation need not be referenced in any way by 
subsequent units that share the parent instantiation. 

Sharing generics causes a slight execution time penalty because all type 
attributes must be indirectly referenced (as if an extra calling argument were 
added). However, it substantially reduces compilation time in most 
circumstances and reduces program size. 

Harris has compiled a unit, SHARED_IO, in the standard library that 
instantiates all Ada generic I/O packages. Thus, any instantiation of an Ada 
I/O generic package will share one of the parent instantiation generic bodies. 
The PRAGMA SHARE_BODY takes the name of a generic instantiation or a generic 
unit as the first argument and one of the identifiers TRUE or FALSE as the 
second argument. This pragma is only allowed immediately at the place of a 
declarative item in a declarative part or package specification, or after a 
library unit in a compilation, but before any subsequent compilation unit. 

When the first argument is a generic unit, the pragma applies to all 
instantiations of that generic. When the first argument is the name of a 
generic instantiation the pragma applies only to the specified instantiation, 
or overloaded instantiation. 





If the second argument is TRUE, the compiler will try to share code 
generated for a generic instantiation with code generated for other 
instantiations of the same generic. When the second argument is FALSE, each 
instantiation will get a unique copy of the generated code. The extent to 
which code is shared between instantiations depends on this pragma and the 
kind of generic formal parameters declared for the generic unit. 

Pragma EXT£RNAL_NAME provides a method for specifying an alternative link 
name for variables, functions and procedures. The required parameters are 
the simple name of the object and a string constant representing the link 
name. Note that this pragma is useful for referencing functions and 
procedures that have had pragma interface applied to them, in such cases 
where the functions or procedures have link names that do no conform to Ada 
identifiers. The pragma must occur after any such applications of pragma 
interface and within the same declarative part or package specification that 
contains the object. 

Pragma INTEREACE_OBJECT provides an interface to objects defined in foreign 
languages. This pragma has a required first parameter that is the simple 
name of an Ada variable to be associated with the foreign object. The 
optional second parameter is a string constant that defines the link name of 
the object. By default, the link name of the object is the symbolic 
representation of the simple name converted to lowercase. The variable 
declaration must occur before the pragma and both must occur within the same 
declarative part or package specification. 


5.2 IMPLEMENTATION-DEPENDENT ATTRIBUTES 

There are no implementation-dependent attributes in HAPSE. 


B-3 







5.3 SPECIFICATION OE PACKACE SYSTEM 


package SYSTEM is 

type ADDRESS is private; 
type NAME is (hcx_ux) ; 

SYSTEM_NAME sconstant NAME :=hcx_ux 

--System-Dependent Constraints 

STORAGE_UNIT :constant :=8; 

MEM0RY_SI2E sconstant :=3_221_22S_469; 

--System-Dependent Named Numbers 

MIN-INT sconstant :*-2_147_483_647-l; 

MAX_INT sconstant :=2_147_483_647; 

MAXJDIGITS sconstant :=9; 

MAX_MANTISSA sconstant :=30; 

EINE_DELTA sconstant :=2.0**(-30); 

TICK sconstant s=0.01; 

--Other System-dependent Declarations 

subtype PRIORITY is INTEGER range 0.. 99; 

MAX_REC_SIZE s INTEGER :=64*1024 

private 

type ADDRESS is new INTEGER; 
end SYSTEM; 

5.4 RESTRICTIONS ON REPRESENTATION CLAUSES 

5.4.1 Pragma PACK 

Bit packing is not supported. Certain objects and components can be packed 
to the nearest whole STORAGE_UNIT. 

5.4.2 Length Clauses 

The specification T'SIZE is supported, but the size required for a type is a 
multiple of STORAGE_UNIT. The specification T'SMALL is not supported. 






5.4.3 Record Representation Clauses 

Component clauses must be aligned on STORAGE_UNIT boundaries. 

5.4.4 Address Clauses 

Address clauses are supported for the following entities. 

objects 

entries 

The function PHYSICAL_ADDRESS is defined in the package SYSTEM to provide 
conversion from INTEGER values to ADDRESS values. 


5.4.5 Interrupts 

Interrupt entries (UNIX signals) are supported. This feature allows Ada 
programs to bind a UNIX signal to an interrupt entry by using a for clause 
with a signal number. There is no protection against two tasks binding the 
same signal. The result is undefined. Interrupt entries should have no 
parameters and can be called explicitly by the program. See SIGVEC(2). 

The HAPSE runtime uses SIGALRM (14) to perform time slicing and delays. The 
result of establishing a signal handler for SIGALRM is undefined. 

The following example program uses an interrupt entry that prints a message 
when the process receives SIGINT. 

with TEXT_IO, SYSTEM; 
use TEXT_IO; 
procedure INTR is 

— This program waits for the user to generate SIGINT (<CONTROL>C) 

SIGINT_NUMBER : constant 2; 

task SIGINT_HANDLER is 
entry SIGINT; 

for SIGINT use at SYSTEM.PHYSICAL_ADDRESS(SIGINT_NUMBER); 
end SIGINT_HANDLER; 

task body SIGINT_HANDLER is 
begin 

accept SIGINT; 

PUT_LINE("Control~C received"); 
end SIGINT_HANDLER; 

begin 
nul 1; 
end INTR; 


B-5 












5.5 OTHER REPRESENTATION IMPLEMENTATION-DEPENDENCIES 


Change of representation is not supported for record types. 

The ADDRESS attribute is not supported for the following entities: static 
constants, packages, tasks, labels, and entries. 


5.6 CONVENTIONS FOR IMPLEMENTATION-GENERATED NAMES 

There are no implementation generated names. 


5.7 RESTRICTIONS ON UNCHECKED CONVERSIONS 

The predefined generic function UNCHECKED_CONVERSION cannot be instantiated 
with a target type that is an unconstrained array type or an unconstrained 
record type with discriminants. 


5.8 IMPLEMENTATION CHARACTERISTICS OF I/O PACKAGES 


5.8.1 Interpretation of Strings as Applied to External Files 

Strings that contain names of external files are interpreted in the following 
manner: File names may be composed of up to 256 characters of the ASCII 
character set except for "/", with a total path name of up to 1024 characters. 
Further, the first character of a file must be alpha-numeric, or If 
the "/” character is encountered in a string, it is interpreted as a separator 
between file names that specify directories. 

5.8.2 Implementation-Dependent Characteristics of DIRECT I/O 

Instantiations of DIRECT_I0 use the value MAX_REC_SIZE as the record size 
(expressed in STORAGE_UNITs) when the size of ELEMENT_TYPE exceeds that value. 
For example, for unconstrained arrays such as a string where ELEMENT_TYPE'SIZE 
is very large, MAX_REC_SIZE is used instead. MAX_RECORD_SIZE is defined in 
SYSTEM and can be changed by a program before instantiating DIRECT_I0 to 
provide an upper limit on the record size. In any case, the maximum size 
supported is 64*1024 STORAGEJJNIT bits. DIRECT_I0 raises USE_ERR0R if 
MAX REC SIZE exceeds this absolute limit. 


B-6 










5.8.3 Implementation-Dependent Characteristics of SEQUENTIAL I/O 


Instantiations of SEQUENTIAL_IO use the value MAX_REC_SIZE as the record size 
(expressed in STORAGE_UNITs) when the size of ELEMENT_TYPE exceeds that value. 
For example, for unconstrained arrays such as a string where ELEMENT_TYPE'SIZE 
is very large, MAX_REC_SIZE is used instead. MAX_RECORD_SIZE is defined in 
SYSTEM and can be changed by a program before instantiating SEQUENTIAL_IO to 
provide an upper limit on the record size. In any case, the maximum size 
supported is 64*1024 STORAGEJJNIT bits. SEQUENTIAL_I0 raises USE_ERROR if 
MAX REC SIZE exceeds this absolute limit. 


5.9 MACHINE CODE INSERTIONS 

The general definition of package MACHINE_C0DE provides an assembly language 
interface for the target machine including the necessary record types needed 
in the code statement, an enumeration type containing all the opcode 
mnemonics, a set of register definitions, and a set of addressing mode 
functions. Also supplied (for use only in units that WITH MACHINE_CODE) are 
pragma IMPLICIT_CODE and the attribute 'REF. 

Machine code statements take operands of type OPERAND, a private type that 
forms the basis of all machine code address formats for the target. 

The general syntax for a machine code statement is 


code__ a'(opcode, operand {, operand))); 


In the example shown below, code_2 is a record 
is an enumeration value of type OPCODE followed 
OPERAND. 


format' whose first 
by two operands 


argument 
of type 


C0DE_2'(ADDA, a'ref, b'ref); 


The opcode must be an enumeration literal (i.e., it can not be an object, 
attribute, or a rename). An operand can only be an entity defined in 
MACHINE_C0DE or the 'REF attribute. 

For an object, arguments to any of the functions defined in HACHINE_CODE must 
be static expressions, string literals, or the functions defined in 
MACHINE_C0DE. The 'REF attribute may not be used as an argument in any of 
these functions. 


B-7 







'REF - The 'REF attribute denotes the effective address of the first of the 
storage units allocated to the object. For a subprogram, package, task unit, 
or label, it refers to the address of the machine code associated with the 
corresponding body or statement. The attribute is of type OPERAND defined in 
package MACHIN£_CODE and is allowed only within a machine code procedure. 
'REF is not supported for a pack; 2 , task unit, or entry. 

Registers - The supported register operands are RO, Rl, ..., R15, SP, FP, PC. 

Addressing Nodes - All of the HCX's addressing modes are supported by the 
compiler. They are accessed through the following functions provided in 
MACHINE CODE. 


Address Mode 

Assembler Notation 

Ada Function Call 

Register 

Rn (n“0..13) 

Rn 

Register Deferred 

(Rn) (n*0..14) 

def(Rn) 

Register + Displacement 
Register + Displacement 

<disp>(Rn) (n*0..15) 

disp(Rn, <disp>) 

Deferred 

*<disp>(Rn) (n*0..15) 

disp_def(Rn, <disp>) 

Autodecrement SP 

-(SP), - (R14) 

deer (SP) 

Autoincrement SP 
Autoincrement Deferred 

(SP) + , (R14) + 

incr(SP) 

SP . 

*(SP)+, *<R14)+ 

incr_def(SP) 

Absolute Address 

*$<addr> 

absol(<addr>) 

Index Register 

[Rx] i 

index (i, Rx) 

Displacement Relative 
Displacement Relative 

<disp> 

rel(<disp>) 

Deferred 

*<disp> 

rel_def(<disp>) 

Immediate 

$<disp> 

immed(<disp>) (<disp> is int) 

Immediate 

$<disp> 

immed(<disp>) (<disp> is float) 

Immediate 

$<disp> 

immed(<disp>) 

(<disp> is a character) 

External Name 

$<name> 

ext (<name>) 


<disp> 

+<disp>, -<disp> 


pragma IMPLICIT_CODE - The IMPLICIT_CODE pragma specifies that implicit code 
generated by the compiler is allowed (ON) or disallowed (OFF) and is used only 
within the declarative part of a machine code procedure. Implicit code 
includes preamble and postamble code (e.g., code used to move parameters from 
and to the stack). Implicit code does not eliminate code generated for 
runtime checks, nor does it eliminate call/return instructions (these can be 
eliminated by pragma SUPPRESS and pragma INLINE, respectively). A warning is 
issued if OFF is used and any implicit code needs to be generated. This 
pragma should be used with caution. 


B-8 





L/ ' 


APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension .TST in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. 


Name and Meaning _ 

$BIG_ID1 

Identifier the size of the 

maximum input line length with 

varying last character. 

$BIG_ID2 

Identifier the size of the 

maximum input line length with 

varying last character. 

$BIG_ID3 

Identifier the size of the 

maximum input line length with 

varying middle character. 

$BIG_ID4 

Identifier the size of the 

maximum input line length with 

varying middle character. 

$BIG_INT_LIT 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 


Value _ 

(1..498 s>'A', '499 *>'1') 


(1..498 =>’A', 499 =>’2’) 


(1..249 I 251..499 => , A’, 250 =>’3’) 


(1..249 I 251..499 =>'A», 250 =>'4*) 


(1..496 =>'0», 497..499 =>"298") 


C-1 



TEST PARAMETERS 


Name and Meaning 


Value 


$BIG_REAL_LIT 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 

$BIG_STRING1 

A string literal which when 
catenated with BIG__STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 

A string literal which when 
catenated to the end of 
BIG STRING1 yields the image of 
BIG ID1. 


(1..493 =>*0*, 494..499 =>"69.0E1") 


(1..249 =>'A*) 


(1..249 =>’A*, 250 =>*1») 


$BLANKS 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 


(1..479 =>* ’) 


$C0UNT_LAST 

A universal 

literal whose 
TEXT 10.COUNT'LAST. 


integer 
value is 


2_147_483_647 


$FIELD_LAST 

A universal 

literal whose 
TEXT 10.FIELD'LAST. 


integer 
value is 


2 147 483 647 


$FILE_NAME_WITH_BAD_CHARS "/illegal/filename/2{]$%bad" 

An external file name that 
either contains invalid 

characters or is too long. 

$FILE_NAME_WITH_WILD_CARD_CHAR "/illegal/filename/wild*char" 

An external file name that 
either contains a wild card 
character or is too long. 

$GREATER_THAN_DURATION 100_000.0 

A universal real literal that 
lies between DURATION'BASE'LAST 
and DURATION*LAST or any value 
in the range of DURATION. 


C-2 




TEST PARAMETERS 


Maine and Meaning _ 

$GREATER_THAN_DURATION_BASE_LAST 

A universal real literal that is 
greater than DURATION’BASE'LAST. 

$ILLEGAL_EXTERNAL_FILE_NAME1 

An external file name which 
contains invalid characters. 

$ILLEGAL_EXTERNAL_FILE_NAME2 

An external file name which 
is too long. 

$INTEGER_FIRST 

A universal integer literal 
whose value is INTEGER’FIRST. 

$INTEGER_LAST 

A universal integer literal 
whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 

A universal integer literal 
whose value is INTEGER'LAST + 1. 

$ LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION’BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUSJ 

A universal integer literal 
whose value is SYSTEM.MAX INT+1. 


Value ___ 

10_000_000.0 

"/no/such/directory/illegal_name1 n 

"/no/such/directory/ilegal_name2 M 

-2_147_483_648 

2J47_483_647 

2J47_483_648 

- 100 _ 000.0 

-10J>00_000.0 

9 

499 

2_147_483_647 

2 147*483 648 


C-3 








TEST PARAMETERS 


Name and Meaning _ 

$MAX_LEN_INT_BASED_LITERAL 

A universal integer based 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$namE 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 
SHORT_FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NEG_BASED_INT 

A based integer literal whose 
highest order nonzero bit 
falls in the sign bit 
position of the representation 
for SYSTEM.MAX INT. 


Value _ 

(1..2 3.-496 =>'0', 

497..499=>"11:") 


(1..3 =>"16:", 4..495 =>*0*, 
496..499=>"F.E: W ) 


(1 =>*"', 2..498 => , A', 499 =>"") 


-2 147 483 648 


SHORT SHORT INTEGER 


16#FFFFFFFD# 


C-4 







APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 27 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
"Al-ddddd" is to an Ada Commentary. 


. B28003A: A basic declaration (line 36) incorrectly follows a 

later declaration. 

. E28005C: This test requires that "PRAGMA LIST (ON);" not 

appear In a listing that has been suspended by a previous 
"PRAGMA LIST (OFF);"; The Ada Standard is not clear on this 
point, and the matter will be reviewed by the AJPO. 

. C34004A: The expression in line 168 yields a value outside 

the range of the target type T, but there is no handler for 
CONSTRAINT_ERROR. 

• C35502P: The equality operators in lines 62 and 69 should be 
inequality operators. 

• A35902C: The assignment in line 17 of the nominal upper 
bound of a fixed-point type to an object raises 
CONSTRAINT__ERROR, for that value lies outside of the actual 
range of the type. 

• C35904A: The elaboration of the fixed-point subtype on line 
28 wrongly raises CONSTRAINT_ERROR, because its upper bound 
exceeds that of the type. 

• C35904B: The subtype declaration that is expected to raise 
CONSTRAINT_ERROR when its compatibility is checked against 
that of various types passed as actual generic parameters, 
may, in fact, raise NUMERIC_ERROR or CONSTRAINT_ERROR for 
reasons not anticipated by the test. 


D-1 









WITHDRAWN TESTS 


. C35A03E and C35A03R: These tests assume that attribute 

•MANTISSA returns 0 when applied to a fixed-point type with a 
null range, but the Ada Standard does not support this 
> assumption. 

. C37213H: The subtype declaration of SCONS in line 100 is 

incorrectly expected to raise an exception when elaborated. 

. C37213J: The aggregate in line 451 incorrectly raises 

C0NSTRAINT_ERR0R. 

. C37215C, C37215E, C37215G, and C37215H: Various discriminant 

constraints are incorrectly expected to be incompatible with 
type CONS. 

. C38102C: The fixed-point conversion on line 23 wrongly 

raises C0NSTRAINT_ERR0R. 

. C41402A: The attribute •ST0RAGE_SIZE is incorrectly applied 

to an object of an access type. 

. C45332A: The test expects that either an expression in line 

52 will raise an exception or else MACHINE_0VERFL0WS is 
FALSE. However, an implementation may evaluate the 
expression correctly .using a type with a wider range than the 
base type of the operands, and MACHINE_0VERFL0WS may still be 
TRUE. - 

. C45614C: The function call of IDENT_INT in line 15 uses an 

argument of the wrong type. 

. A74106C, C85018B, C87B04B, and CC1311B: A bound specified in 

a fixed-point subtype declaration lies outside of that 
calculated for the base type, raising C0NSTRAINT_ERR0R. 
Errors of this sort occur at lines 37 A 59, 142 & 143, 16 A 
48, and 252 A 253 of the four tests, respectively. 

. BC3105A: Lines 159 through 168 expect error messages, but 

these lines are correct Ada. 

. AD1A01A: The declaration of subtype SINT3 raises 

C0NSTRAINT_ERR0R for implementations which select INT'SIZE to 
be 16 or greater. 

. CE2401H: The record aggregates in lines 105 and 117 contain 

the wrong values. 

. CE3208A: This test expects that an attempt to open the 

default output file (after it was closed) with mode IN_FILE 
raises NAME_ERR0R or USE_ERR0R; by Commentary AI-00048, 
MODE ERROR should be raised. 


D-2 








