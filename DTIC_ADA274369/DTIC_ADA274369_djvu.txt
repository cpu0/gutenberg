
g| CMSC 130 

g" INTRODUCTORY 
COMPUTER SCIENCE 


LECTURE NOTES 

r*| c A pen 

rOHOPENPUBUCATION ROTEW OF THIS 

duartment or cnrcfSE C* 

'17 ICO! A r, factual ACCJRAC* QB OPBBOH ^ 

' ' M3 12 ^ 


OinECTORATF FOR FREEX’M OF ffifORMAIR’V^ 

AND SECllRi'iY REVIEW '0A3C-PA) 

EDITION 


s 


DTIC 

ELECTE 
DEC2 81993 


July 1993 


Duane J. Jarc and Eric Fendler 
in cooperation with 


Undergraduate Programs 
University of Maryland University College 

Sponsored by Advanced Research Projects Agency (ARPA) 







REPORT DOCUMENTATION PAGE 


form Approwtf 
OMI Mo. OAM-OfM 


»uW<c tt»o>tiA« bw>4t<t 'er Ihn tt n M I k«w t«ipenM. mcMtof Ik* ton* lar rvvKiNiAf tiuda^ tMlHW 4*1* towtcM. 

a«lh««M Uw 4«U XHH. »«4 *04 >t«i**>of !*• cotMMO •• wlotmtiioo Wo4 (atnoKOA >M«r4iOf iMt kw>4*o ntmtcM *f (Oy ttkt* (MM •< tKit 

coMkIioo o> iof 4 «<<«li«o. 10*1*4*4 iMtyi l iOo* to* n 4»tio4 lOn •ll•4*o. lo WtiN 0|<«0 MN44v*n*a torvKn. D«*<lor*l* o»r iof*>«\*iioo 0»*<*Mot *04 Mfwn. II tt MNtfwo 
0*»nMI|ii«»».*wW IIHi-«WI.*o<IOII««0««»<*4«M«» m > H «Ho4lu44**.*«p»oi»0rtM4wtt*o4»0(*<tW>04<li4).4(«»KiO4WO. OC KM! ' - 


1. AGCNCV USf ONLY (t«4vc blinki 2. REfONT OATI 

July 1993 


4. mu AND suimu 

CMSC 130 INTRODUCTORY'COMPUTER SCIENCE 
LECTURE NOTES 


11 


REPORT TYPE ANO OATES COVERE 

LECTURE NOTES 


S. FUNOWC NUMRI 


nrmnEzni 


MDA972-92-J-1021 


Duane J. Jarc & Eric Fendler 


7. PfRPORMING ORGANUATKM NAME(S) ANO AOORESS(ES) 

UNIVERSITY OF MARYLAND UNIVERSITY COLLEGE 


t. PERPORMING ORGANIZATION 
REPORT NUMISR 


CMSC 130 


•. SPONSORING/MONITORING AGENCY NAME(S) ANO ADORISS(ES) 


ARPA 

3701 N. Fairfax Dr. 
Arlington, VA 22203-1714 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMRER 



12a. OtSTRIIUTION/AVAKARRiTV STATEMENT 


12b. OISTRIRUTION CODE 


APPF<0VEX FOi' r;;-lEASt 
DISTRI-- TiO ' U LiMiTED 


13. AISTRACT (M4Kim*m200¥ifonh) 


The CMSC 130 Introductory Computer Science lecture notes are 
used in the classroom for teaching CMSC 130, an introductory 
computer science course, using the Ada programming language. 


14. SURJSa TERMS 



COMPUTER SCIENCE 

LANGUAGE CONCEPTS 

s 

ADA LANGUAGE 

SOFTWARE CONCEPTS 





17. SECURITY CUSSIPICATION 
OF REPORT 

(J 

IS. SECURITY CLASSIFICATION 
OF THIS PAGE 

ey 

19. SECURITY CLASSIFICATION 

OF ARSTRACT 


11 NUMRER OP PAGES 




IS. PRICE COOS 


0 / u 


NSN 7S4O4)1-280-SS00 


Standard Form 298 (Rev 2-R9) 

4in(r«(4 bf *N« SI4 IN-II 











First Edition—^July 1993 


Copyright 1993 by University of Maryland University College (UMUC). Advanced 
Research Projects Agency (ARPA), in conjunction with the Ada Joint Program Office 
(AJPO), will have the right to make unlimited copies and use the finished materials 
in its programs and all other U.S. Government training programs. The Air Force 
Institute of Technology (AFTT) may adapt the materials for its training programs. 

The Software Engineering Institute (SEI) may distribute the materials to its 
educational affiliates. U^^C will retain the right to use the materials within the 
University of Maryland System and to make it available to other colleges and 
universities. All other rights reserved. No part of this publication may be 
reproduced, stored in a retrieval system, or transmitted in any form or by any 
means, electronic, mechanical, photocopying, recording, or otherwise, without the 
prior written permission of the copyright holder. 

This project is sponsored by ARPA. The content of the information does not 
necessarily reflect the position or the policy of the Government, and no official 
endorsement should be inferred. 

Printed in the United States of America. 



CMSCISO 


INTRODUCTORY 
COMPUTER SCIENCE 


LECTURE 1 

INTRODUCTION AND 
OVERVIEW 




il.... LiCTi'D 8 


Accesion i-O' 

NTIS CI'V,i.i 
DT!!J TAP 

JtiitiT;', )>,./• _ 






OVERVIEW OF INTRODUCTORY COURSES 


CMSC 130 Introductory Computer Science 

Basic Syntax And Semantics Of Ada Language 
Conditional And Iterative Control Structures 
Scalar Data Types, Arrays And Records 
Structured Programming Concepts 
CMSC 135 Intermediate Computer Science 
Additional Ada Language Concepts 
Generic Packages 
Access Data Types 

pata Structures And Algorithm Efficiency 
Stacks, Queues, Lists, Trees And Graphs 
Objected-Oriented Programming Concepts 
Recursive Programming Concepts 
CMSC 230 Advanced Computer Science 
Advanced Ada Language Concepts 

Task Declarations And Control Statements 
Concurrent Programming Concepts 


CMSC 130 


-2- 


Lecture 1 



CMSC130 OVERVIEW 


Introductory Concepts 

Hardware/Software Concepts 
Language Concepts 
Software Engineering Concepts 
Control Structures 

Conditional Control (If And Case Statements) 
Iterative Control (For, While And Loop Statements) 
Subprograms (Procedures And Functions) 

Data Structures 

Scalar Data Types 
Array Types 
Record Types 
Abstraction Concept 

Procedural Abstraction 
Data Abstraction 


CMSC 130 


-3- 


Lecture 1 



COMPUTER HARDWARE 



Central Processing Unit (CPU) 
Arithmetic Logic Unit (ALU) 
Storage 

Registers 
Main Memory 
Disk 

Input/Output Devices 


CMSC 130 


-4- 


Lecture 1 




COMPUTER SOFTWARE 


System Software 
Operating System 

Interface Between Computer Hardware And User 

Manages System Resources 
System Software (Program Development) 

Editor 

Allows Text File Creation And Modification 
Compiler 

Translates High Level Language Into Machine Language 
Linker 

Links Separately Compiled Files Together 
Symbolic Debugger 

Allows Program Tracing And Memory Examination 
Integrated Development Environment 

Integrated Editor, Compiler, Linker And Debugger 
Application Software 

User Written Programs 


CMSC 130 


-5- 


Lecture 1 



PROGRAM DEVELOPMENT PROCESS 



CMSC130 


-6- 


Lecture 1 




COMPUTER SCIENCE AS AN 
INTERDISCIPLINARY FIELD 



Mathematical Component 

Algorithms, Efficiency And Computability 
Linguistic Component 

Programming Languages 
Engineering Component 

Design Principles (Software Engineering) 


CMSC 130 


-7- 


Lecture 1 



ALGORITHMS AND PROBLEM SOLVING . 

Terminology: 

Algorithm : A Step By Step Procedure That Is Used To Solve A 
Problem 

Sandwich Making Algorithm 

1. Go To The Store And Buy Some Bread 

2. Go Home And Put The Bread On A Plate 

3. Go To The Store And Buy Some Mustard 

4. Go Home And Put The Mustard On The Bread 

5. Go To The Store And Buy Some Baloney 

6. Go Home And Put The Baloney On The Bread 

7. Eat The Sandwich 
Important Points: 

1. A Clear Problem Definition Must Precede Algorithm 
Development 

2. Algorithm Development Determines The Details Of How 
To Solve The Problem 

3. There Are Many Algorithms That Solve The Same 
Problem 


CMSC130 


-8- 


Lecture 1 



EFFICIENT ALGORITHMS 


Terminology: 

Algorithm Efficiency : A Measure Jf The Number Of Steps 
Required To Complete An Algorithm 

Efficient Sandwich Making Algorithm 

1. Go To The Store And Buy Bread, Mustard And Baloney 

2. Go Home And Put The Bread On The Plate 

3. Put Mustard On The Bread 

4. Put Baloney On The Bread 

5. Eat The Sandv.ich 
Important Points: 

1. This Algorithm Is More Efficient Than The Previous 
Algorithm, It Save Two Steps, Two Trips To The Store 

2. For More Complex Algorithms, The Number Of Steps 
Required May Not Be Constant, It May Depend On Some 
Input, The Type Of Sandwich, For Example 

3. When The Number Of Steps Varies, Plotting A Graph Of 
The Steps Versus The Input Data Can Be Useful 


CMSC 130 


-9- 


Lecture 1 



SOFTWARE ENGINEERING PRINCIPLES 

Computer Science As An Engineering Discipline 

1. Software Systems Require Design, An Essential 
Characteristic Of Engineering Fields 

2. Computer Systems Are Constructed, The Building 
Material Is The Programming Language 

3. Simplicity Is An Important Design Criterion, Simple 
Programs Are More Reliable And Easier To Maintain 

Programming Languages And Software Engineering 

1. Ada Is A Language Designed With Software Engineering 
Principles In Mind 

2. Ada's Design Emphasizes Reliability Before Efficiency 

3. Using A Well Designed Language Can Reduce The Cost 
Of Software Development 

Ada Software Engineering Features 

1. Structured Language With Fully Nested Syntax 

2. Procedural Abstraction Supported By Subprograms 

3. Data Abstraction Supported By Packages 


CMSC 130 


-10- 


Lecture 1 



PROGRAMMING LANGUAGES 

Characteristics Of Programming Languages 

1. Programming Languages Are Formal Languages That 
Avoid The Potential Ambiguity Of Natural Language 

2. Programming Languages Have A Precise Syntax, 
Programs With Syntax Errors Are Not Understood 

Languages And Compilers 

1. Compilers Are Language Translators That Translate 
From A High-Level Language To Machine Language 

2. Compilers Translate Complete Programs, Interpreters 
Translate One Line At A Time 



Abstraction Level Of Languages 

1. Programming With Low-Level Languages Is Like Building 
With Small Bricks, More Work Is Involved 

2. Programming With High-Level Languages Is Like 
Building With Prefabricated Panels, Less Work Is 
Involved 


CMSC 130 


-11 - 


Lecture 1 




EVOLUTION OF PROGRAMMING 

LANGUAGES 


Unstructured Imperative Languages 
Machine Language 

Physical (Numeric) Addresses, Numeric Operation 
Codes 

Assembly Language 

Symbolic Addresses And Operation Codes 
Structured Imperative Languages 

Languages With Arithmetic Formulas (Fortran) 

Nested Expressions 

Fully Structured Languages (Pascal, C, Ada) 

Nested Statements, No Gotos Required 
Nonimperative Languages 

Functional Programming Languages (ML) 

No States, No Variables, No Assignments 
Logic Programming Languages (Prolog) 

No Explicit Control Flow, Nonprocedural 


CMSC 130 


-12- 


Lecture 1 



• 4 




* ' . V 


* r . 


’ s ♦ < • 



ADA HISTORY 


Developed By DoD In Response To High Cost Of Software 
Ada Development Was A Ten Year Effort 
1973-1974 Cost Study To Find Ways To Reduce Software Costs 
1975 High Order Language Working Group (HOLWG) 

Goal To Adopt Standard DoD Language 
Developed Requirement Specifications 
(Strawman, Woodenman, Tinman) 

1977 Concluded No Existing Language Met Specifications 
Solicited Proposals For New Language 

17 Proposals Received, All Based On Pascal Excepts IBM's 
4 Selected, Designated Red, Blue, Green and Yellow 

1978 Two Finalists selected 

Red (Intermetrics), Green (CM Honeywell Bull) 

1979 Green Language Chosen 
1981-1982 Extensive Public Reviews 

1983 Military Standard & ANSI Standard Adopted 
First Compilers Available In Mid 1980's 


CMSC 130 


-2- 


Lecture 2 



LEVELS OF LANGUAGE 


Natural Language 

Programming Language 

Letters 

Characters | 

Words 

Tokens 

Phrases 

Expressions 

Sentences 

Statements 

Paragraphs 

Subprograms 

Sections 

Programs 


LEXICAL COMPONENTS 

Natural Language 
Parts Of Speech 

Noun, Verb, Adjective, Adverb, Preposition 
Programming Language 
Token Categories 

Reserved Words, Identifiers, Constants, Operators 


CMSC 130 


-3- 


Lecture 2 




IDENTIFIERS AND RESERVED WORDS 


Identifier Syntax 

Identifiers Must Begin With A Letter, Followed By Zero Or 
More Letters, Digits Or Underscores, Consecutive 
Underscores And Terminating Underscores Are Prohibited 

Valid Identifiers 

Name This_Value Value_2 

Invalid Identifiers 

5_Value Begins With Digit 

Some_Number Consecutive Underscores 

statement# Contains Special Character 

identifier_ Terminating Underscore 

Role Of Identifiers 

Identifiers Are Used To Name Variables, Constants Etc. 

Unlike English Words Which Are Fixed, Programmers Can 
Create Any Identifier That Follows The Syntax Rules And 
Give It A Meaning 

Reserved Words 

Certain Ada Identifiers, If Case While And Others, Are 
Reserved, Have A Predefined Meaning, They Can Not Be 
User-Defined Identifiers 


CMSC 130 


-4- 


Lecture 2 



LEXICAL STYLE 


Comments 

Comments Add Clarification To Programs, They Begin With 
Two Dashes And End With End Of Line 

-- This Is An Ada Comment 

Upper And Lower Case Issues 

Ada Is Case Insensitive, Upper And Lower Case Characters 
Are Not Distinct 

There Is No Widely Observed Convention For The Use Of 
Upper And Lower Case 

Upper And Lower Case Convention Adopted 

Upper Case For Reserved Words 

Mixed Case For User Defined Identifiers 

Blank Space 

Any Number Of Spaces Can Separate Tokens 

Blank Space Should Be Used Liberally To Enhance The 
Readability Of Programs 

Indentation 

Indentation With Blank Space Should Be Used To Reflect The 
Control Structure Of The Program 


CMSC 130 


-5- 


Lecture 2 



DATA TYPES 


Data Type Concept 

Data Types In A Programming Language Categorize Data In 
A Similar Way That Categories Such As Animate, Inanimate 
Categorize Objects In Natural Language 

Character Data Type 

Literal Representation: A Single Character Enclosed In A Pair 
Of Single Quotes 

Literal Examples: ' A ' ' b ’ 

Integer Data Type 

Literal Representation: An Optionally Signed Sequence Of 
Digits With An Optional Exponent 

Literal Examples: 156 -320 12E2 

Float Data Type 

Literal Representation: An Optionally Signed Sequence Of 
Digits Followed By A Decimal Point, Another Sequence 
Of Digits And An Optional Exponent 

Literal Examples: 98.6 2.45E-2 -0.4 

Invalid Examples 

2 . E2 Must Be A Digit After The Decimal 

. 21 Must Be A Digit Before The Decimal 


CMSC 130 


-6- 


Lecture 2 



ARITHMETIC EXPRESSIONS 


Role Of Arithmetic Expressions 

Arithmetic Expressions Define Mathematical Formulas 

Arithmetic Expressions Contain Operators And Operands 
(Literals Or Identifiers Naming Variables Or Constants) 

Arithmetic Operators 

+ Addition 

Subtraction 

* Multiplication 

/ Division 

REM Remainder 

* * Exponentiation 

Arithmetic Expression Examples 
Integer_Variable + 5 
Number * (Value + 2) 

Expression Evaluation 

Parentheses Can Be Used To Group Subexpressions 

In The Absence Of Parentheses Precedence Applies 

Highest Precedence ** 

Middle Precedence / rem 
Lowest Precedence + - 

Left To Right Associativity Applies Otherwise 


CMSC 130 


-7- 


Lecture 2 



DECLARATIVE STATEMENTS 


Variable Declarations 

A Variable Declaration Instructs The Compiler To Reserve A 
Memory Location For A Variable Of The Specified Type 

Identifiers Are Used To Name Variables 

Variable Declaration Examples 

Letter: Character; 

Whole_Number: Integer; 

Real_Numberl,Another_Real: Float; 

Variable Declaration Syntax 

varlable_declaration ::= 
identifierjist : type; 

Constant Declarations 

A Constant Declaration Instructs The Compiler To Reserve 
Memory For A Value That Can Not Change 

Constant Declaration Examples 

Excellent_Grade: CONSTANT Character := 'A'; 
Course_Number: CONSTANT Integer := 130; 

Constant Declaration Syntax 

constant_declaration ::= 

Identifier : constant type : = value; 


CMSC 130 


-8- 


Lecture 2 



EXECUTABLE STATEMENTS 

Assignment Statements 

An Assignment Statement Stores The Value Of The 
Expression On The Right Side Of The Assignment Into The 
Variable On The Left Hand Side 

Assignment Statement Examples 

Letter := 'B'; 

Real_Number := Another_Real + 5.0/ 

Assignment Statement Syntax 

asslgnment_statement ::= 
variable : = expression; 

Input/Output Statements 

An Input Statement Reads Data In From The Keyboard, An 
Output Statement Writes Data Out To The Screen 

Input/Output Statement Examples 

Get (Whole_Number) ; 

Put (Real_Number) ; 

Input/Output Statement Syntax 

lnput_statement ::= 

Get (variable) ; 


output_statement ::= 
Put (variable) ; 


CMSC130 


-9- 


Lecture 2 



COMPLETE PROGRAM SYNTAX 

Simple Procedure Syntax 

adajDrogram ::= 

WITH Text_IO/ 

PROCEDURE identifier is 
declarations 

i/o_packageJnstantiations 

BEGIN 

statements 
END identifier; 

Important Points: 

1. The Simplest Ada Program Consists Of One Procedure 

2. Both Of The Identifiers, Which Name The Procedure, 
Must Match 

3. Input/Output Package Instantiation Is Required When 
Integer And Floating Point I/O Is Required 

Input/Output Package Instantiation 

integerJojDackageJnstantiation ::= 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

floating_pointJojDackageJnstantiatlon ::= 

PACKAGE Flt_IO IS NEW Text_IO.Float_IO 
(Float); 


CMSC130 


-10- 


Lecture 2 



ADA PROGRAM EXAMPLES 

Hello World Program 

WITH Text_IO; 

PROCEDURE Hello_World IS 
-- Declarative Section 
BEGIN 

--Sequence of Statements 

Text_IO.Put_Line("Hello, World! ! !" ) ; 

END Hello_World; 

Adding Machine Program 

UITH Text_IO; 

PROCEDURE Adding_Machine IS 
Total: Integer; 

Users_Entry: Integer; 

One: CONSTANT Integer := 1; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Text_IO.Put_Line("Enter an integer"); 
Int_IC.Get (Users_Entry); 

Total := Users_Entry + One; 

Text_IO.Put ("The answer is: "); 
Int_IO.Put(Total) ; 

Text_IO.New_Line; 

END Adding Machine; 


CMSC130 


-11 - 


Lecture 2 



ERROR MESSAGES 


Compilation Errors 

These Are Errors Detected By The Compiler When The 
Program Is Compiled 

Syntax Errors: 

Misspelling Reserved Words Or Omitting 
Punctuation Are Examples 

Semantic Errors: 

Mismatched Types Are Examples 

Run-Time Errors 

These Are Errors Detected When The Program Is Run 
Logic Errors 

These Are Errors That Do Not Generate Error Messages, 
They Can Only Be Detected By Observing That Programs 
Generate Incorrect Output 

Important Points: 

1. Ada Is Designed To Encourage Early Error Detection 

2. It Is Easier To Find And Correct Compilation Errors Than 
It Is To Detect Logic Errors 

3. Symbolic Debuggers Can Be A Useful Tool To Uncover 
Logic Errors 


CMSC 130 


-12- 


Lecture 2 





I 



♦ > 
*^4 





SOFTWARE ENGINEERING 


Major Issue; 

Software Engineering Principles Promote Simple Program 
Design 

Structured Programming 

Structured Programming Simplifies The Statement Level 
Control Structure Of Programs By Prohibiting Explicit Gotos 

Procedural Abstraction 

Procedural Abstraction Simplifies Programs By Limiting The 
Size Of Subprograms 

Data Abstraction 

Data Abstraction Simplifies Programs By Encapsulating Data 
Type Definitions Into Packages 

Ada And Software Engineering 

Ada Supports Structured Programming Because It Contains 
High Level Statements That Can Be Nested 

Ada Supports Procedural Abstraction Because Ada Permits 
The Definition And Invocation Of Subprograms 

Ada Supports Data Encapsulation Because Ada Permits Data 
Types And Objects To Be Defined Within Packages 


CMSC130 


-2- 


Lecture 3 



STRUCTURED PROGRAMMING 


Terminology: 

Flow Chart : A Diagram That Illustrates The Flow Of Control Of 
A Computer Program 

Unstructured Programs 

Goto Statements Implement Control Flow 

Flow Charts Can Contain Crossing Lines 

Structured Programs 

High-Level Statements Implement Control Flow 

Flow Charts Never Contain Crossing Lines 

Structured Program Control 

Fundamental Statements 

Simple Statements, Assignment I/O 
Conditional Statements If, Case 
Iterative Statements For, While And Loop 

Methods Of Combining Statements 

Sequential 

Nested 

Important Point: 

1. Nesting Is Essential To Structured Programming 


CMSC 130 


-3- 


Lecture 3 



BUILDING STRUCTURED PROGRAMS 



ITERATIVE CONTROL CONDITIONAL CONTROL 



NESTED COMBINATION 


CMSC 130 


-4- 


Lecture 3 






UNSTRUCTURED CODE EXAMPLE 

Unstructured Name Repetition Algorithm 

1. Output "What's your name" 

2. Input Name 

3. Output "How many times should I print your name" 

4. Input Repetitions 

5. IF Repetitions > 100 GOTO Step 10 

6. Output "Your name is", Name 

7. Decrement Repetitions 

8. IF Repetitions Is Zero GOTO Step 12 

9. GOTO Step 6 

10. Output "That's too many times, tell me again" 

11. GOTO Step 4 

12. Output "Done" 

Important Points: 

1. The Code Is Hard To Read 

2. The Steps In The Algorithm Are Tangled Up With One 
Another 

3. The Code Is Really Delicate, It Is Difficult To Add New 
Functions Without Creating Problems 

4. Flowcharts Were Traditionally Used For The Design Of 
Unstructured Code 


CMSC 130 


-5- 


Lecture 3 



STRUCTURED CODE EXAMPLE 

Structured Name Repetition Algorithm 

Output "What's your name" 

Input Name 

Set Undetermined To True 

WHILE Undetermined LOOP 

Output "How many times should I print your name" 

Input Repetitions 
IF Repetitions > 100 THEN 

Output "That's too many times, tell me again" 

ELSE 

Set Undetermined To False 
END IF 

END LOOP 

FOR Index IN 1..Repetitions LOOP 
Output "Your name is", Name 

END LOOP 

Output "Done" 

Important Points: 

1. Structured Code Is Naturally Indented 

2. The Indentation Of Structured Code Reflects The Control 
Structure 

3. Structured Code Is Easier To Read And Easier To Modify 


CMSC 130 


-6- 


Lecture 3 



PROCEDURAL ABSTRACTION 


Terminology: 

Top-down Design : A Method Of Program Design That Begins 
At The Top, By Subdividing The Whole Problem 

Step-wise Refinement: The Process Of Further Subdividing, 
Refinement, The Problem Design At Each Step 

Structure Chart : A Chart Representing The Functional 
Decomposition Of A Problem 

Structure Chart Example: 


Important Points: 

1. The Boxes Of A Functional Decomposition Most Often 
Become Subprograms 

2. Get And Put Are Examples Of System Defined 
Procedural Abstraction 


CMSC 130 


-7- 


Lecture 3 




TOP-DOWN DESIGN EXAMPLE 



Important Point: 

1. Computers Only Do What They Are Told, Nothing Is 
Obvious, Every Step That Must Be Performed Must Be 
Specified 


CMSC130 


-8- 


Lect'jre 3 









STEP-WISE REFINEMENT EXAMPLE 



CMSC130 


-9- 


Lecture 3 












DATA ABSTRACTION 


Terminology: 

Encapsulation : Enclosing A Data Type Definition With The 
Functions That Define Its Operations 

Information Hiding : Concealing The Representation Of A Data 
Type And The Implement Of Its Operations 

Loose Coupling : Building A System Of Software Components 
With Minimal Interdependencies 

Software Reusability : Building General Software Components 
That Can Be Used In Other Systems 

Ada Package Features 

An Ada Package Encapsulations A Data Type Definition 
Together With The Functions That Define Its Operations 

Ada Packages Consist Of Specifications And Bodies, The 
Package Body Conceals The Implementation Of The 
Operations 

Package Specifications Consist Of Public And Private Parts, 
The Private Part Conceals The Representation Of Data Types 

The Package Specification Defines The Interface Of A 
Package And Defines It Coupling With Other Units 

Ada Packages Are Reusable Software Components That Can 
Be Separately Compiled 


CMSC 130 


-10- 


Lecture 3 



ENUMERATION TYPES 

Enumeration Type Declarations 

Enumeration Type Declarations Create New Data Types 
Whose Literal Values Are Names, Identifiers 

Enumeration Type Declaration Examples 

TYPE Days IS (Monday, Tuesday, Wednesday, 
Thursday, Friday, Saturday, Sunday); 

TYPE Rainbow_Colors IS (Red, Orange, Yellow, 
Green, Blue, Indigo, Violet); 

Enumeration Type Declaration Syntax 

enumeration_type_declaration ::= 

TYPE identifier (identifierjist) / 

Terminology: 

Overloading : The Use Of A Name Or An Operator For More 
Than One Purpose 

Overloaded Enumeration Literals 

Ada Permits Enumeration Literals To Be Overloaded, In 
Addition To Rainbow_Colors, The Following Type Could 
Be Defined 

TYPE Primary_Colors IS (Red, Blue, Yellow)/ 

The Names Red, Blue And Yellow Belong To Two Types 


CMSC130 


-11 - 


Lecture 3 



ENUMERATION TYPE ATTRIBUTES & I/O 

Terminology: 

Attribute : A Constant Value Or A Function Associated With A 
Data Type 

Attributes 

First First Value Of The Type 
Last Last Value Of The Type 

Pos A Function That Maps Enumeration Literals To Their 
Position In The Type Definition 

val A Function That Maps Positions To Enumeration 
Literals 

Succ Successor Function 
Pred Predecessor Function 
Attribute Examples 

Days'First = Monday 
Rainbow_Colors'Pos(Orange) = 1 
Primary_Colors'Succ(Red) = Blue 

Enumeration I/O Syntax: 

enumerationjo ::= 

PACKAGE Identifier IS new Text_io. 

Enumeration lO(type); 


CMSC130 


-12- 


Lecture 3 



ENUMERATION TYPE EXAMPLE 

Yesterday And Tomorrow Program 

WITH Text_IO; 

PROCEDURE Yesterday_And_Tomorrow IS 

TYPE Days IS (Monday, Tuesday, Wednesday, 
Thursaay, Friday, Saturday, Sunday); 
PACKAGE Days_IO IS NEW Text_IO. 

Enumeration_IO(Days); 

Today, Yesterday, Tomorrov;: Days; 

BEGIN 

Text_IO. Put_Line ("What Day Is Today?"); 
Days_IO.Get (Today) ; 

Yesterday := Days'Pred(Today); 

Tomorrow := Days’Succ(Today); 

Text_IO.Put ( "Yesterday was "); 

Days_IO.Put(Yesterday); 

Text_IO.New_Line; 

Text_IO.Put ("Tomorrow will be "); 
Days_IO.Put(Tomorrow); 

Text_IO.New_Line; 

END Yesterday_And_Tomorrow; 

Important Point: 

1. A Run-Time Error Will Occur If Monday Or Sunday Is 
Entered, Monday Has No Predecessor, Sunday Has No 
Successor 


CMSC130 


-13- 


Leciure 3 



f 


1 



1 


• i > ‘ ' 



V > 

* % • • 










SIMPLE CONDITIONS 

Boolean Data Type 

The Boolean Data Type Is A Predefined Enumeration Type 

TYPE Boolean IS (False,True); 

Relational Operators 


Symbol 

Meaning 

< 

Less Than 

<= 

Less Than Or Equal 

= 

Equal 

/= 

Not Equal 

> 

Greater Than 

>= 

Greater Than Or Equal 


Condition Syntax 
condition ::= 

operand relational_operator operand 
Important Point: 

1. The Operands Of Simple Conditions Are Either Variables, 
Named Constants Or Literal Constants 


CMSC 130 


-2- 


Lecture 4 




SIMPLE CONDITION EXAMPLES 


Type Checking Rule 

The Type Of The Two Operands Of A Condition Must Match, 
They Must Be The Same Type 

Variable Declarations 

Whole_Number: Integer := 1; 

Decimal_Number: CONSTANT Float := 1.0; 
Truth_Value: Boolean; 

Letter: Character; 

Examples Of Valid Conditions 
Whole_Number < 5 
Truth_Value = True 
Letter > 'A' 

Examples Of Invalid Conditions 

Whole_Number < Decimal_Number 
Truth_Value = 5 
Decimal_Number > 2 
Letter = Whole Number 


CMSC 130 


-3- 


Lecture 4 



SIMPLE IF STATEMENT 

Simple If Statement Syntax 

simplejf_statement ::= 

IF condition then 

sequence_of_statements 

END IF; 

Absolute Values Procedure 

WITH Text_IO; 

PROCEDURE Absolute_Values IS 
Absolute, Number: Integer; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Text_IO.Put("Enter An Integer: "); 
Int_IO.Get(Number); 

Absolute := ABS Number; 

Text_IO.Put("Absolute Value With ABS "); 
Int_IO.Put(Absolute); 

Text_IO.New_Line; 

IF Number < 0 THEN 
Number := -Number; 

END IF; 

Text_IO.Put("Absolute Value With IF "); 
Int_IO.Put(Number); 

Text_IO.New_Line; 

END Absolute Values; 


CMSC130 


-4- 


Lecture 4 



IF STATEMENT WITH ELSE CLAUSE 

If Else Statement Syntax 

jf_else_statement ::= 

IF condition then 

sequence_of_statemen!s 

ELSE 

sequence_of_statements 

END IF; 

Circular Tomorrow Procedure 

WITH Text_IO; 

PROCEDURE Circular_Tomorrow IS 

TYPE Days IS (Monday, Tuesday, Wednesday, 
Thursday, Friday, Saturday, Sunday)/ 
PACKAGE Days_IO IS NEW Text_IO. 

Enumeration_IO(Days); 

Today, Tomorrow: Days; 

BEGIN 

Text_IO.Put_Line("What Day Is Today?")/ 
Days_IO.Get(Today); 

IF Today /= Sunday THEN 

Tomorrow := Days'Succ(Today)/ 

ELSE 

Tomorrow := Monday; 

END IF; 

Text_IO.Put("Tomorrow will be "); 
Days_IO.Put(Tomorrow); Text_IO.New_Line; 
END Circular Tomorrow; 


CMSC130 


-5- 


Lecture 4 



DESCENDING LOOP EXAMPLE 


Rocket Launch Program 

WITH Text_IO; 

PROCEDURE Rocket_Launch IS 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

FOR Launch_Count IN REVERSE 1..3 LOOP 
Int_IO.Put(Launch_Count) ; 

IF Launch_Count = 3 THEN 
Text_IO.Put_Line 

("Start launch computers"); 

ELSIF Launch_Count = 2 THEN 
Text_IO.Put_Line 

("Release rocket stabilizers"); 
ELSIF Launch_Count = 1 THEN 
Text_IO.Put_Line 

("Start engine ignition"); 

END IF; 

END LOOP; 

Text_IO.Put_Line("Blast-Off"); 

END Rocket_Launch; 

Important Point: 

1. In A Descending For Statement The Range Of Values Is 
Specified In Ascending Order 


CMSC 130 


-6- 


Lecture 6 



ENUMERATION RANGE EXAMPLE 


Total Weeks Earnings Program 

WITH Text_IO; 

PROCEDURE Total_Weeks_Earnings IS 

TYPE Days_Of_Week IS (Sun, Mon, Tue, Wed, 
Thu, Fri, Sat); 

Weeks_Income, Todays_Income: Float := 0.0; 
PACKAGE Day_IO IS NEW 

Text_IO.Enumeration_IO(Days_Of_Week)/ 
PACKAGE Incoine_IO IS NEW Text_IO. Float_IO 
(Float); 

BEGIN 

FOR Day IN Mon..Fri LOOP 
Text_IO.New_Line; 

Text_IO.Put("Enter salary & tips for "); 
Day_IO.Put(Day); 

Income_IO.Get(Todays_Income)/ 
Weeks_Income := Weeks_Income + 

Todays_Income; 

END LOOP; 

Text_IO.New_Line(3); 

Text_IO.Put("Total for the week is " ); 
Income_IO.Put(Weeks_Income); 

Text_IO.New_Line; 

END Total Weeks Earnings; 


CMSC130 


-7- 


Lecture 6 



NESTED LOOP EXAMPLE 


Oldest Go First Program 

WITH Text_IO; 

PROCEDURE 01ciest_Go__First IS 

TYPE Months IS (Jan, Feb, Mar, Apr, May, 
Jun, Jul, Aug, Sep, Oct, Nov, Dec); 
PACKAGE Age_IO IS NEW Text_IO.Integer_IO 
(Integer)/ 

PACKAGE Months_IO IS NEW 

Text_IO.Enumeration_IO(Months); 

BEGIN 

FOR Age IN REVERSE 0..100 LOOP 
FOR Month_Born IN Jan..Dec LOOP 
Text_IO.Put("Now Serving: ")/ 
Age_IO.Put(Age); 

Text_IO.Put(" year olds born in ")/ 
Months_IO.Put(Month_Born) ; 

Text_IO.New_Line; 

END LOOP; 

END LOOP; 

END 01dest_Go_First; 

Important Point: 

1. The Statements In The Body Of The Innermost Loop Are 
Executed 1212 Times 

12 (Months) X 101 (Ages) = 1212 (Iterations) 


CMSC 130 


-8- 


Lecture 6 



COUNTING EXECUTED STATEMENTS 


Major Issues: 

1. There Is Always An Upper Bound To The Number Of 
Statements Executed By Programs Containing Only 
Conditional Control Statements 

2. The Number Of Statements Executed By Programs 
Contains Definite Iteration May Be Unbounded 


Triangular Numbers Program 

BEGIN 1 

Text_IO.Put("Enter Number: ") ; 1 

Int_IO.Get(Number ); 1 

Triangle := 0; 1 

FOR Index IN 1..Number LOOP n 

Triangle := Triangle + Index; n 

END LOOP; n 

Text_IO.Put("Triangular Number = "); 1 
Int_IO.Put(Triangle) ; 1 

END Triangular Numbers; 1 


Function Determining Executed Statements: 

f(n) = 3n + 7 
Important Point: 

1. The Number Of Statements Executed Is Unbounded 
Because It Depends On The Input Value For Number 


CMSC130 


-9- 


Lecture 6 


ALGORITHM EFFICIENCY 


Linear Efficiency: 

Programs Containing Single Loops Have Linear Efficiency, 
The Function That Measures The Executed Statements Is Of 
The Form: 


f{n) = an + b 


Quadratic Efficiency 

Programs Containing Nested Loops As Follows: 

FOR I IN 1..n LOOP 
FOR J IN 1..n LOOP 

Have Quadratic Efficiency, The Function That Measures The 
Executed Statements Is Of The Form: 

f(n) = an2 + bn + c 

Comparing Algorithms: 

Algorithms With Quadratic Execution Functions Are Less 
Efficient Than Algorithms With Linear Execution Functions 

Important Points: 

1. All Problems Can Be Solved With More Than One 
Algorithm 

2. When The Efficiency Of The Algorithms For A Given 
Problem Vary, The Most Efficient Is Preferred 


CMSC 130 


-10- 


Lecture 6 



SUBTYPE DECLARATIONS 


Subtype Concept 

The Rationale For Using Subtype Declarations Is To Limit The 
Range Of Values And Detect Out Of Range Conditions If 
They Should Occur 

Subtype Declaration Syntax 

subtype_declaration ::= 

SUBTYPE identifier is type range 
simple_expression . .simple_expression / 

Subtype Declaration Examples 

SUBTYPE Days_In_Month IS Integer RANGE 
1..31; 

SUBTYPE Weekdays IS Days_Of_Week RANGE 
Monday..Friday; 

Range Checking Relational Operators 

IN Determines Whether A Value Is In A Range 

NOT IN Determines Whether A Value Is Not In A Range 

Range Checking Expression Examples 

3 IN 5. .10 False 

Wednesday IN Monday..Friday True 

40 NOT IN 1. . 10 True 


CMSC130 


-11 - 


Lecture 6 



SUBTYPE PROGRAM EXAMPLE 


Summer Only Program 

WITH Text_IO; 

PROCEDURE Suminer_Only IS 

TYPE Months IS (Jan, Feb, Mar, Apr, May, 
Jun, Jul, Aug, Sep, Oct, Nov, Dec;; 
SUBTYPE Suminer_Months IS Months RANGE 
Jun..Aug ; 

PACKAGE Age_IO IS NEW Text_IO.Integer_IO 
(Integer); 

PACKAGE Months_IO IS NEW 

Text_IO.Enumeration_IO(Months) / 

BEGIN 

FOR Age IN REVERSE 0..100 LOOP 
FOR Month_Born IN Jan..Dec LOOP 

IF Month_Born IN Suminer_Months THEN 
Text_IO.Put("Now Serving: "); 
Age_IO.Put(Age)/ 

Text_IO.Put( " year olds born in " & 
"the summer month of " ) ; 
Months_IO.Put(Month_Born)/ 

Text_IO.New_Line ; 

END IF; 

END LOOP; 

END LOOP; 

END Summer Only; 


CMSC130 


-12- 


Lecture 6 



I 


/ 



f 

( 










f 


♦ 







r ^ 




/ * 


f 

,> 



INDEFINITE ITERATION CONCEPT 


Major Issues: 

1. Programs Containing Only Conditional Control And 
Definite Iteration Always Terminate 

2. Certain Problems Require Indefinite Iterative Control To 
Be Solved 

Terminology: 

Indefinite Iteration : Control Mechanism That Permits The 
Repetition Of A Group Of Statements While A Specified 
Condition Remains True 

Important Points: 

1. Programs Containing Indefinite Iteration Can Get Into 
"Infinite Loops" And Never Terminate 

2. Indefinite Iteration Can Be Used To Solve Any Problem 
Solved With Definite Iteration 

A Simple Problem Requiring Indefinite Iteration 
Summing Positive Integers 

1. Read In Integers From The Keyboard And Sum The 
Numbers 

2. Stop When A Number That Is Not Positive Is Read In 

3. Print Out The Sum 


CMSC130 


-2- 


Lecture 7 



WHILE STATEMENT 


While Statement Syntax 

while_statement ::= 

WHILE condition loop 
sequence_of_statements 

END LOOP; 

Static Semantic Rule: 

1. The Condition Must Be A Boolean Expression 
While Statement Flowchart 



CMSC 130 


-3- 


Lecture 7 




FLAG CONTROLLED LOOP EXAMPLE 

Sum_Positive_With_Flag Procedure 

WITH Text_IO; 

PROCEDURE Sum_Positive_With_Flag IS 
Number: Integer; 

Sum:Integer := 0; 

Positive: Boolean := True; 

PACKAGE Int_IO IS NEW 

Text_IO.Integer_IO(Integer); 

BEGIN 

WHILE Positive LOOP 
Int_IO.Get(Number) ; 

IF Number > 0 THEN 
Sum := Sum + Number; 

Positive := True; 

ELSE 

Positive := False; 

END IF; 

END LOOP; 

Text_IO.Put("The Sum Is ”) ; 

Int_IO.Put(Sum); 

Text_IO.New_Line; 

END Sum_Positive_With_Flag; 

Important Point: 

1. The Flag Controlling The Loop Must Be Initialized Prior 
To The Loop And Must Be Set Within The Loop 


CMSC 130 


-4- 


Lecture 7 



SENTINEL CONTROLLED LOOP EXAMPLE 

Sum_Positive_With_Sentinel Procedure 

WITH Text_IO; 

PROCEDUPE Sum_Positive_With_Sentinel IS 
Number: Integer; 

Sum:Integer := 0/ 

PACKAGE Int_IO IS NEW 

Text_IO.Integer_IO(Integer); 

BEGIN 

Int_IO.Get (Number) ; 

WHILE Number > 0 LOOP 
Sum := Sum + Number; 

Int_IO.Get(Number) ; 

END LOOP; 

Text_I0.Put("The Sum Is "); 

Int_IO.Put(Sum); 

Text_IO.New_Line; 

END Sum_Positive_With_Sentinel; 

Important Points: 

1. Controlling A Loop With A Sentinel Requires Reading 
The Input Twice 

a) A "Priming Read" Is Required Prior To The Loop 

b) Another Get Is Required At The End Of The Loop 

2. The Sentinel Must Be Compared In The While Condition 
To Determine Loop Termination 


CMSC 130 


-5- 


Lecture 7 



DEFINITE VS INDEFINITE ITERATION 


Major Issue; 

1. Every For Loop Can Be Replaced By A While Loop, The 
Reverse Is Not True 

FOR Index IN Lower..Upper LOOP 

sequence_of_statements 

END LOOP; 

Index := Lower; 

WHILE Index <= Upper LOOP 
sequence_of_statements 
Index := Index + 1; 

END LOOP; 


INFINITE LOOPS 

Nonterminating While Loop 

Index := 1; 

WHILE Index /= 0 LOOP 
Index := Index + 1; 

END LOOP; 

Important Point: 

1. While Loops That Do Not Converge To The Termination 
Condition Are Infinite Loops 


CMSC 130 


-6- 


Lecture 7 



LOOP AND EXIT STATEMENTS 

Loop Statement Syntax 

loop_statement ::= 

LOOP 

sequence_of_statements 

END LOOP; 

Exit Statement Syntax 

exit_statement ::= 

EXIT [ WHEN condition ] ; 

Static Semantic Rule: 

1. An Exit Statement Can Only Appear Within The Body Of 
A For, While Or Loop Statement 

Loop Exit Combined Syntax 

LOOP 

sequence_of_statements 
EXIT [WHEN condition] / 
sequence_of_statements 

END LOOP; 

Important Points: 

1. A Loop Statement Is Most Useful When The Loop 
Terminating Condition Can Not Be Determined At The 
Top Of The Loop 


CMSC 130 


-7- 


Lecture 7 



LOOP STATEMENT EXAMPLE 

Count Letters Program 

WITH Text_IO/ 

PROCEDURE Count_Letters IS 

Lower_Case, Upper_Case: Natural := 0; 

Char: Character; 

PACKAGE Count_IO IS NEW Text_IO.Integer_IO 
(Natural) ; 

BEGIN 

Text_IO.Put_Line("Enter a sentence")/ 

WHILE NOT Text_IO.End_Of_Line LOOP 
Text_IO.Get(Char); 

EXIT WHEN Char = * '; 

IF Char IN *a'..’z' THEN 

Lower_Case := Lower__Case + 1/ 

ELSIF Char IN *A’..'Z' THEN 
Upper_Case := Upper_Case + 1/ 

END IF; 

END LOOP; 

Text_IO.Put("Number of lower case = ")/ 
Count_IO.Put(Lower_Case) ; 

Text_IO.New_Line; 

Text_IO.Put("Number of upper case = "); 
Count_IO.Put(Upper_Case) ; 

Text_IO.New_Line; 

END Count Letters; 


CMSC 130 


-8- 


Lecture 7 



PROCEDURES 


Procedure Concept 

Procedures Differ From Functions In That They Do Not 
Return Values, But Their Parameters Can Return Values 

Procedure Declaration Syntax 

procedure_declaration ::= 

PROCEDURE identifier [ formaljDarameters ] is 
{declarations} 

BEGIN 

sequence_of_statements 
END identifier; 

formal JDarameters ::= 

(formaljDarameter {, formaljDarameter) 

formaljDarameter ::= 

identifier {, identifier}: [ mode ] type 

mode ::= 

IN I OUT I IN OUT 

Static Semantic Rules: 

1. The Type Of The Actual And Formal Parameters Must 
Match 

2. Parameters Of In Mode Are Read Only And Parameters 
Of Out Mode Are Write Only 


CMSC 130 


-9- 


Lecture 7 



PROCEDURE EXAMPLE 


Above And Below Procedure 

WITH Text_IO/ 

PROCEDURE Above_And_Below( 

Number: IN Integer; 

Above_Count: OUT Natural; 

Below_Count: OUT Natural) 

IS 

Value: Integer; 

Above, Below: Natural := 0; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Int_IO.Get(Value); 

WHILE Value /= Number LOOP 
IF Value > Number THEN 
Above := Above + 1; 

ELSE 

Below := Below -i- 1; 

END IF; 

Int_IO.Get(Value); 

END LOOP; 

Above_Count := Above; 

Below_Count := Below; 

END Above_And_Below; 

Important Point: 

1. Out Parameters Are Write Only 


CMSC130 


-10- 


Lecture 7 



PROGRAM CORRECTNESS 

Axiomatic Semantics 

A Method For Defining The Meaning Of Procedures That 
Uses Assertions, Statements Of Formal Logic Or English, 

Assertions 

Precondition 

An Assertion That Is True Prior To The Execution Of A 
Procedure 

Postcondition 

An Assertion That Is True After The Execution Of A 
Procedure 

Loop Invariant 

An Assertion That Is True Prior To The Execution Of A 
Loop, After Each Iteration And After The Execution Of 
The Loop Is Completed 

Proof Of Correctness 

The Precondition And Postcondition Define The Meaning Of A 
Procedure 

A Proof Can Establish Correctness, That The Algorithm 
Accomplishes The Goal The Meaning Defines 

Establishing That The Loop Terminates Is Necessary To 
Prove Total Correctness 


CMSC130 


-11 - 


Lecture 7 



LOOP INVARIANT EXAMPLE 


Quotient Remainder Procedure 

PROCEDURE Quotient_Remainder ( 
Dividend: IN Integer; -- di 
Divisor: IN Integer; -- d 2 
Final_Quotient: OUT Integer; 
Final_Remainder: OUT Integer) 

IS 

Quotient: Integer; —q 
Remainder: Integer; —r 
BEGIN 

—Precondition 
— (di > 0) A (d2 > 0) 

Quotient := 0; 

Remainder := Dividend; 

WHILE Remainder >= Divisor LOOP 
--Loop Invariant 

--(di = q * d 2 + r) a (r > d 2 > 0) 
Remainder := Remainder - Divisor; 
Quotient := Quotient + 1; 

END LOOP; 

—Postcondition 

--(di = q * d 2 + r) a (d 2 > r > 0) 
Final_Quotient := Quotient; 
Final_Remainder := Remainder; 

END Quotient Remainder; 


CMSC130 


-12- 


Lecture 7 



I* ■ 






* a 

z * 

f 


f ^ 


♦ ^ 


t 



t 


* 1 . * 


« 


« • # 


,* 




> 

^ - T 

• • 



P * % 

•4 


t 



I 

» 


J 



SCALAR DATA TYPES 


Ada Data Type Hierarchy 

Scalar Data Types 
Discrete Types 
Integer Types 
Enumeration Types 
Boolean Type 
Character Type 
Real Types 

Floating Point 
Fixed Point 

Composite Data Types 
Array Types 
Record Types 

Access Types 

Terminology: 

Scalar Data Type : A Data Type Whose Elements Consist Of A 
Single Value 

Discrete Type : A Data Type Whose Elements Have 
Successors And Predecessors 

Important Point: 

1. Access Types Will Not Be Discussed In This Course 


CMSC130 


-2- 


Lecture 8 



NUMERIC OPERATORS 


Operation 

Operator 

Left 

Right 

Result 

Addition 

+ 

Numeric 

Numeric 

Numeric 

Subtraction 

— 

Numeric 

Numeric 

Numeric 

Multiplication 

★ 

Numeric 

Numeric 

Numeric 

Division 

/ 

Numeric 

Numeric 

Numeric 

Remainder 

REM 

Integer 

Integer 

Integer 

Modulo 

MOD 

Integer 

Integer 

Integer 

Exponentiation 

★ ★ 

Integer 

Integer 

Integer 

Exponentiation 

★ ★ 

Float 

Integer 

Float 


Important Points: 

1. The Remainder And Modulo Operators Are Only Defined 
On Integer Operands 

2. The Remainder And Modulo Operators Produce The 
Same Results On Positive Integers 

3. The Type Of The Left And Right Operands Must Be The 
Same Except In The Case Of Exponentiation 


CMSC 130 


-3- 


Lecture 8 













































EXPRESSION EVALUATION 


Expression Evaluation Rules 

1. Parentheses 

2. Precedence 

Highest abs ** 

Second Highest mod rem * / 

Third Highest + - (Unary) 

Lowest + - (Binary) 

3. Left To Right Associative 
Expression Evaluation Examples 

(2 + 3) * 5 25 

Parentheses Force Addition Before Multiplication 

8- 6/2 5 

Precedence Causes Division Before Subtraction 

9- 2-1 6 

Associativity Ensures Left Subtraction Before Right 
Expressions Requiring Parentheses 
2 ★★ 2 ** 3 

The Above Expression Is Syntactically Incorrect, Ada 
Requires That It Be Parenthesized 


CMSC 130 


-4- 


Lecture 8 



TYPE CONVERSION 


Major Issue: 

Integer And Floating Point Number Can Be Mixed If Explicit 
Type Conversion Is Used 

Type Conversion Example 

I: Integer; 

F: Float; 

I := Integer(F); --Rounded 
F : = Float (I) ; 


FLOATING POINT NUMBERS 

Floating Point Representation 

Mantissa Controls Precision 
Exponent Controls Range 

Terminology: 

Underflow : A Number Which Can Not Be Represented 
Because It Is Too Close To Zero 

Overflow : A Number Which Can Not Be Represented 
Because It Is Too Far From Zero 

Representation Error : Error Which Occurs Converting 
Decimal Numbers Such As 0.1 To Binary 


CMSC (30 


-5- 


Lecture 8 



NUMERIC EXAMPLE 


Sphere Formulas 

4 

Volume = gTirS Surface Area = 47ir2 

Sphere Calculations Program 

WITH Text_IO; 

PROCEDURE Sphere_Calculations IS 
Pi: CONSTANT Float := 3.14159; 

Radius,Volume,Surface_Area: Float; 

PACKAGE Flt_IO IS NEW Text_IO.Float_IO 
(Float); 

BEGIN 

Text_IO.Put("Enter Sphere Radius: "); 
Flt_IO.Get(Radius) ; 

Volume := (4.0/3.0) * Pi * Radius ** 3; 
Surface_Area := 4.0 * Pi * Radius ** 2; 
Text_IO.Put("Volume = "); 

Flt_IO.Put(Volume); 

Text_IO.New_Line; 

Text_IO.Put("Surface Area = "); 

Flt_IO.Put(Surface_Area); 

Text_IO.New_Line; 

END Sphere_Calculations; 

Important Point: 

1. The Types Around ** Do Not Match 3ut Are Compatible 
With Function Specification 


CMSC 130 


-6- 


Lecture 8 



LOGICAL OPERATORS 


X 

Y 

NOT X 

X AND Y 

X OR Y 

X XOR Y 

True 

True 

False 

True 

True 

False 

True 

False 

False 

False 

True 

True 

False 

True 

True 

False 

True 

True 

False 

False 

True 

False 

False 

False I 


Precedence Of All Operators 


Highest 

Second iighest 
Third Highest 
Fourth Highest 
Fifth Highest 
Lowest 


NOT ABS ** 

MOD REM * / 

+ - (Unary) 

+ - & (Binary) 

<<=>>==/= 
AND OR XOR 


Compound Boolean Expressions 

3 > 2 AND 8=4 False 


2 <= 2 OR 6 = 5 True 

Important Point: 

1. Compound Expressions With Mixed Logical Operators 
Require Parentheses 

X AND Y OR Z Syntax Error 


CMSC 130 


-7- 


Lecture 8 



































SHORT CIRCUIT OPERATORS 


Short Circuit Principle 

False AND Anything = False 
True OR Anything = True 
Short Circuit Operators 

Short Circuit Conjunction and then 
Short Circuit Disjunction or else 
Short Circuit Evaluation 

1. Left Operand Is Always Evaluated First 

2. Right Operand Is Not Evaluated When 

a) Left Operand Is False And Operator Is And Then 

b) Right Operand Is True And Operator Is Or Else 

Short Circuit Example 

Y /= 0 AND THEN X / Y > 0 

Use Of The Short Circuit Operator Prevents Evaluation Of 
The Right Operand When The Left Operator Is False, Which 
Prevents Division By Zero 

Important Point: 

1. With Ordinary Logical Operators, Either Operand May Be 
Evaluated First And Both Are Always Evaluated 


CMSC 130 


-8- 


Lecture 8 



BOOLEAN EXPRESSION EXAMPLE 

Diagnose Program 

WITH Text_IO; 

PROCEDURE Diagnose IS 

Smiling, Laughing, Singing, Frowning, 
Weeping, Wailing: Boolean; 

BEGIN 

Smiling:= False; 

Laughing := False; 

Singing := True; 

Frowning := False; 

Weeping := True; 

Wailing := True; 

IF Smiling AND THEN 

(Laughing OR Singing) THEN 
Text_IO.Put_Line("Must be happy"); 

ELSIF Frowning OR ELSE 

(Weeping AND Wailing) THEN 

Text_IO.Put_Line 

("Must be angry or depressed"); 

END IF; 

END Diagnose; 

Important Points: 

1. The Parentheses In These Boolean Expressions Are 
Required 

2. Non Short Circuit Operators Could Have Been Used 


CMSC130 


-9- 


Lecture 8 



CHARACTER DATA TYPE 


Nonprintable Characters 

Nonprintable Characters Can Be Represented By Name 

ASCII. BEL Bell Character 

ASCII. CR Carriage Return 

ASCii.LF Line Feed 

Control Characters Program 

WITH Text_IO; 

PROCEDURE Control_Characters IS 

BEGIN 

Text_IO.Put_Line 

("This one put_line statement" & 

ASCII.CR & ASCII.LF & 

"generates several lines of " & 

ASCII.CR & ASCII.LF & 

"text on the screen " & ASCII.CR & 
"and overstrikes the third line " & 
"because no linefeed was issued"); 

Text_IO.New_Line(3)/ 

Text_IO.Put_Line 

("Non-printing characters can ring " & 
"the terminals bell" & ASCII.BEL); 

Text_IO.New_Line(3); 

Text_IO.Put_Line("ASCII.ESC is also " & 
"used for cursor-positioning"); 

END Control Characters; 


CMSC 130 


-10- 


Lecture 8 



CASE STATEMENT 

Case Statement Syntax 

case_statement ::= 

CASE expression is 

case_statement_alternative 

{case_statement_alternative} 

END CASE; 

case_statement_alternative ::= 

WHEN choice {| choice} => 
sequence_of_statements 

choice ::=simple_expression | discrete_range | others | 
componenf_simple_name 

Semantic Rules: 

1. The Expression Must Be Of A Discrete Type, Integer Or 
Enumerated 

2. The Type Of The Choices Must Match The Type Of The 
Expression 

3. Every Possible Value Of The Expression Must Be 
Specified By Exactly One Of The Choices Or By Others 

4. Every Choice Must Be Static (Able To Be Evaluated At 
Compile Time) 

5. If Used, The When Others Clause Must Be Last 


CMSC 130 


-11 - 


Lecture 8 



CASE STATEMENT EXAMPLE 


Favorite Colors And Numbers Program 

WITH Text_IO/ 

PROCEDURE Favorite_Colors_And_Numbers IS 
TYPE Color_Type IS (Red, Puce, Blue, 
Purple, White, Magenta, Beige); 

Favorite_Number: Integer := 13/ 
Favorite_Color: Color_Type := Beige/ 

BEGIN 

CASE Favorite_Number IS 
WHEN Integer'First..-1 => 

Text_IO.Put_Line("How avant-garde!")/ 
WHEN 13 => 

Text_IO.Put_Line("How bold")/ 

WHEN 0..12 I 14..99 => 

Text_IO.Put_Line("How ordinary")/ 
WHEN OTHERS => 

Text_IO.Put_Line("You think big")/ 

END CASE/ 

CASE Favorite_Color IS 

WHEN Red | White | Blue => 

Text_IO.Put_Line("How patriotic I")/ 
WHEN Puce I Purple 1 Magenta | Beige => 
Text_IO.Put_Line("How unusual!")/ 

END CASE/ 

END Favorite Colors And Numbers/ 


CMSC 130 


- 12 - 


Lecture 8 



* 


I 

i .. 


■( 

« 




V . 




m 

t 


/ 



4 


I 




9 

;-i • 

% * 




* 9^ 


4*. 


• « 






* 1 # 




f • 

V 



ARRAY DECLARATIONS 


Array Definition Syntax 

array_definition ::= array (discrete_range) of type 
Constrained Array Type Declarations: 

-- An Array For Hours Worked For A Week 

TYPE Days_Of_Week IS (Mon^ Tue, Wed, Thu, 
Fri, Sat, Sun); 

TYPE Hours IS ARRAY(Days_Of_Week) OF Float; 

-- An Array To Contain 10 Logical Values 

TYPE Boolean_Array IS ARRAY(1..10) OF 
Boolean; 

-- An Array Of Grade Frequencies 

SUBTYPE Grades IS INTEGER RANGE 0..100; 

TYPE Frequencies IS ARRAY(Grades) OF 
Natural; 

Important Points: 

1. Arrays Collect Together Data Elements Of The Same 
Type 

2. The Type Of The Subscripts Must Be A Discrete Type, 
But The Components May Be Any Type 


CMSC 130 


-2- 


Lecture 9 



ARRAY SUBSCRIPTS 


Role Of Array Subscripts 

Array Subscripts Select One Element From The Array 

Schedule: Hours; 

Schedule(Mon) 

Schedule(Tue) 

Schedule(Wed) 

Schedule(Thu) 

Schedule(Fri) 

Schedule(Sat) 

Schedule(Sun) 

Important Point: 

1. A Subscript Can Be A Constant Or A Variable 

Types Of Array Subscripts 

Semantically Significant Subscripts 

Subscripts Of Arrays That A Collection Of Values 
(Subscripts Have No Particular Meaning) 


8.0 


8.0 


8.0 


8.0 


8.0 


0.0 


0.0 


CMSC130 


-3- 


Lecture 9 




ARRAY AGGREGATES 


Terminology: 

Array Aggregate : A Literal Constant Which Represents The 
Value Of A Complete Array 

Array Aggregate Syntax 

aggregate ::= 

(component_assoclation {, component_association}) 

component_association ::= 

[choice {I choice} =>] expression 

choice ::= simple_expression | discrete_range | others 

Array Object Declaration: 

Worked: Hours; 

Array Aggregates Assignments: 

Worked := (^.0,4.0,8.0,8.0,8.0,0.0^0.0); 

Worked := (4.0,4.0,8.0,8.0,8.0,OTHERS => 
0 . 0 ) / 

Worked := (Sat|Sun => 0.0, Wed..Fri => 8.0, 
Mon..Tue => 4.0); 

Important Point: 

1. Named Aggregates Values Can Appear In Any Order 


CMSC 130 


-4- 


Lecture 9 



ARRAY WITH SEMANTICALLY 
SIGNIFICANT SUBSCRIPTS 

Grade Frequency Program 

WITH Text_IO; 

PROCEDURE Grade_Frequency IS 

SUBTYPE Grades IS Integer RANGE 0..100; 
SUBTYPE Students IS Integer RANGE 1..30; 
TYPE Frequencies IS ARRAY(Grades) OF 
Natural; 

Grade: Grades; 

Frequency: Frequencies := (OTHERS => 0); 
PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer)/ 

BEGIN 

FOR Student_Index IN Students LOOP 
Text_IO.Put("Enter Grade: "); 
Int_IO.Get(Grade) ; 

Frequency(Grade) := Frequency(Grade) 

+ 1 ; 

END LOOP; 

FOR Grade_Index IN Grades LOOP 
Int_IO.Put (Grade_Index) ; 

Int_IO.Put (Frequency(Grade_Index) ); 
Text_IO.New_Line; 

END LOOP; 

END Grade Frequency; 


CMSC130 


-5- 


Lecture 9 



ARRAY AS COLLECTION 


Average Measurements Program 

WITH Text_IO; 

PROCEDURE Average_Measurements IS 

SUBTYPE Num_Measurements_Type IS Integer 
RANGE 1..10; 

TYPE Measurement_Array_Type IS 

ARRAY(Num_Measurernents_Type) OF Float; 
Measurement_Array: Measurement_Array_Type; 
Total, Average: Float; 

PACKAGE Measurement_IO IS NEW Text_IO. 
Float_IO(Float) ; 

BEGIN 

FOR I IN 1..10 LOOP 

Text_IO. Put_Line (’’Enter a measurement”); 
Measurement_IO.Get 

(Measurement_Array(I)); 

END LOOP; 

Total := 0.0; 

FOR I IN 1..10 LOOP 

Total := Total + Measurement_Array(I); 
END LOOP; 

Average := Total / 10.0 ; 

Text_IO.Put_Line (’’The average is ”); 
Measurement_IO.Put (Average) ; 

Text_IO. New_Line; 

END Average Measurements; 


CMSC130 


-6- 


Lecture 9 



ARRAYS OF AN ANONYMOUS TYPE 


Anonymous Array Declaration Syntax 

anonymous_array_declaration ::= 

identifierjist: ARRAY (discrete_range) of type; 

Anonymous Array Object Declarations: 

Array_l,Array_2: ARRAY (1..10) OF Integer; 
Array_3: ARRAY (1..10) OF Integer; 

Important Points: 

1. Anonymous Array Object Declarations Should Only Be 
Used For 'One Of A Kind" Arrays 

2. All Three Arrays Are All Of Different Types 

ARRAY PARAMETERS 


Terminology: 

Call Bv Reference : The Address Of A Parameter Is Passed 
Instead Of The Parameter Itself 

Important Point: 

1. Array Parameters Can Be Passed By Reference Or By 
Value-Result, The Compiler Chooses The Method 


CMSC 130 


-7- 


Lecture 9 



ARRAY PARAMETER EXAMPLE 


Sum Array Program 

WITH Text_IO; 

PROCEDURE Sum_Array IS 

TYPE Integer_Array_Type IS 
ARRAY(1..5) OF Integer; 

Actual_Array: Integer_Array_Type := 

(21, 4, 5, 11, 26); 

Sum: Integer; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

PROCEDURE Calculate_Sum(Formal_Array: IN 
Integer_ArraY_Type; 

Sum: OUT Integer) IS 
Total: Integer; 

BEGIN 

Total := 0; 

FOR I IN 1..5 LOOP 

Total := Total + Formal_Array(I) ; 

END LOOP; 

Sum := Total; 

END Calculate_Sum; 

BEGIN 

Calculate_Sum(Actual_Array, Sum); 

Text_IO.Put_Line("The sum is "); 
Int_IO.Put(Sum); 

Text_IO.New_Line; 

END Sum Array; 


CMSC130 


-8- 


Lecture 9 



STRING TYPES 


String Literals 

A Sequence Of Characters Enclosed In Double Quotes 
String Literals Must Not Cross Line Boundaries 

String Assignment 

String Lengths Must Match 

Some_String: String (1..5); 

Some_String "This String"; --Error 

String Concatenation 

Creates A Single String From Two Strings 

Text_IO.Put("This Output Is Too Long" & 
"To Fit One A Single Line"); 

String Slices 

Extracts Substrings From Strings 

Any_String := "A Several Word String"; 
Text_IO.Put(Any_String(3..9)); 

-- Outputs The Word "Several" 

String Comparisons 

Left-Most Characters Are Compared First 

"Cat" > "Dog" False 

"Car" < "Cart" True 


CMSC 130 


-9- 


Lecture 9 



STRING SLICE EXAMPLE 


Slice Program 

WITH Text_IO; 

PROCEDURE Slice IS 

SUBTYPE Bounds_l IS Integer RANGE 1..5; 
SUBTYPE Bounds_2 IS Integer RANGE 
Pattern: String(Bounds_l); 

Text: String(Bounds_2) := "Sample Text"; 

Match: Boolean := Falser- 
Upper, Finish : Natural; 

PACKAGE Bool_IO IS NEW 

Text_IO.Enumeration_IO(Boolean); 

BEGIN 

Text_IO.Put("Enter Pattern: "); 
Text_IO.Get(Pattern) ; 

Unper := Bounds_2'Last - 
Bounds_l'Last + 1; 

FOR Start IN Bounds_2'First..Upper LOOP 
Finish := Start + Bounds_l'Last - 1; 

IF Pattern = Text(Start..Finish) THEN 
Match := True; 

EXIT; 

END IF; 

END LOOP; 

Bool_IO.Put(Match); 

END Slice; 


CMSC 130 


- 10- 


Lecture 9 



ARRAY SEARCHING 


Linear Search Procedure 

WITH Text_IO; 

PROCEDURE Linear_Search IS 

SUBTYPE Bounds IS Integer RANGE 1..10; 
Table: ARRAY(Bounds) OF Integer := 

(31,15, 8,34,5,81,2,97,30, 95) / 

Value: Integer; 

Found: Boolean; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Text_IO.Put("Enter Value: "); 

Int^IO.Get(Value); 

FOR Index IN Bounds LOOP 

Found := Table(Index) = Value; 

EXIT WHEN Found; 

END LOOP; 

IF Found THEN 

Text_IO.Put("Value In Table"); 

ELSE 

Text_IO.Put("Value Not In Table"); 

END IF; 

Text_IO.New_Line; 

END Linear_Search; 

Innportant Point: 

1. The Execution Time Increases Linearly 


CMSC 130 


-11 - 


Lecture 9 



BIG O CONCEPT 

Execution Time Function For Linear Search 
f(n) = 3n + 6, Where n Is The Table Size 
Formal Definition Of Big-0: 

f{n) e 0(p(n)) If And Only If There Exist Two Constants m and 
no such that \f(n)\ < m|g(n)| for n > no 

Big-0 Proof 

3n + 6 G 0(n) Because |3n + 6| < 9|n| for n > 1 



Big-0 Relationships 

0(log X) c 0(x) c 0(x2) c 0(x3) c 0(ex) 

0(log x) Is Most Efficient, 0(ex) Is Least Efficient 


CMSC 130 


-12- 


Lecture 9 



FUNCTION EXAMPLE 


Estimate Tax Procedure 

WITH Text_IO/ 

PROCEDURE Estimate_Tax IS 
Income, Tax_BiIl: Float; 

FUNCTION Federal_Taxes(Income, 

Tax_Rate: Float) RETURN Float IS 
BEGIN 

RETURN Income * Tax_Rate; 

END Federal_Taxes; 

PACKAGE Income_IO IS NEW Text_IO.Float_IO 
(Float); 

BEGIN 

Text_IO.Put_Line("What is your income"); 
Income_IO.Get(Income); 

IF Income <= 18000.00 THEN 

Tax_Bill := Federal_Taxes(Income, 0.15); 
ELSE 

Tax_Bill := Federal_Taxes 
(18000.00, 0.15); 

Tax_Bill := Tax_Bill + Federal_Taxes 
(Income - 18000.00, 0.31); 

END IF; 

Text_IO.Put("Your approximate taxes "); 
Income_IO.Put(Tax_Bill, 10, 2, 0 ) ; 

Text_IO.New_Line ; 

END Estimate Tax; 


CMSC130 


-3- 


Lecture 5 



FORMAL PARAMETERS, ACTUAL 
PARAMETERS AND LOCAL VARIABLES 

Terminology 

Formal Parameters : The Names Declared After The Function 
Name And Before The "Return" In A Function Declaration 

Actual Parameters : The Expressions That Are Supplied In A 
Function Call 

Local Variables : The Names Declared After The "Is" And 
Before The "Begin" 

Static Semantic Rules: 

1. The Type Of Corresponding Actual Parameters And 
Formal Parameters Must Match 

2. Formal Parameters And Local Variables Can Only Be 
Accessed In The Function In Which They Are Defined 

3. In Functions, Formal Parameters Act As Constants, They 
Are Read Only, They Cannot Be Assigned To 

Parameter Association In Function Calls 

Positional Association: Only The Actual Parameter Is 
Supplied 

Named Association: Both The Actual And The Formal 
Parameters Are Supplied 


CMSC 130 


-4- 


Lecture 5 



PACKAGES CONTAINING FUNCTIONS 


Package Concept 

A Package Collects Together Functions Into A Library That 

Can Be Used By Many Programs 

A Package Consists Of A Specification, Which Defines The 

Interface, And A Package Body, Which Contains The 

Implementation Details 

Package Specification Syntax 

package_specification ::= 

PACKAGE identifier is 
{function_specification} 

END identifier ; 

Function Specification Syntax 

function_specification 

FUNCTION identifier [ formaljDarameters ] 

RETURN type ; 

Package Body Syntax 

package_body ::= 

PACKAGE BODY identifier IS 
{function_declaration} 

END identifier ; 

Important Point: 

1. This Is A Very Simplified Package Syntax 


CMSC130 


-5- 


Lecture 5 



PACKAGE SPECIFICATION EXAMPLE 

Tax Package Specification 

PACKAGE Tax_Package IS 
FUNCTION Federal_Taxes 

(Income^ Tax_Rate: Float) RETURN Float; 
FUNCTION FICA_Taxes 

(Income: Float; Self_Employed: Boolean) 
RETURN Float; 

-- FUNCTION State_Taxes 

(Income: Float; State: String) 

-- RETURN Float; 

END Tax_Package; 

-- Social security taxes only applied to the 
-- first 54,000 of income 

-- Medicare taxes not subject to an income 
-- limit 

-- Self_employed individuals pay both the 
-- employee and employer share 

-- A function specification is included as 
-- a comment for state tax function 


CMSC 130 


-6- 


Lecture 5 



PACKAGE BODY EXAMPLE 


Tax Package Body 

PACKAGE BODY Tax_Package IS 
FUNCTION Federal_Taxes 

(Income, Tax_Rate: Float) 

RETURN Float IS 
BEGIN 

RETURN Income * Tax_Rate/ 

END Federal_Taxes/ 

FUNCTION FICA_Taxes 

(Income: Float; Self_Employed: Boolean) 
RETURN Float IS 

Rate, Tax_Bill: Float; 

BEGIN 

IF Self_Employed THEN 
Rate := 0.145; 

ELSE 

Rate := 0.0725; 

END IF; 

IF Income <= 54000.00 THEN 
Tax_Bill := Income * Rate; 

ELSE 

Tax_Bill := Income * Rate; 

Tax_Bill := Tax_Bill + 

(Income - 54000.00) * 0.0125; 

END IF ; 

RETURN Tax_Bill; 

END FICA_Taxes; 

END Tax Package; 


CMSC 130 


-7- 


Lecture 5 



FUNCTION SEMANTICS 


Denotational Semantics 

A Method For Defining The Meaning Of Functions That Uses 
Mathematical Functions 

Ada Functions As Mathematical Functions 

The Domain Of The Mathematical Function Is The Cartesian 
Product Of The Types Of The Formal Parameters 

The Co-domain Is The Type Returned By The Function 

Function Example 

FUNCTION Hypotenuse 
Sicie_l : Float; 

Side_2 : Float) 

RETURN Float; 

h: R X R R 

Mathematical Function Definition 

The Mathematical Definition Of An Ada Function Should 
Depend Only On The Formal Parameters, The Local 
Variables Should Not Be A Part Of The Definition 

Important Point: 

1. A Function Specification Should Include The Ada 
Function Specification And A Comment Defining Its 
Meaning, Mathematics Or English Can Be Used 


CMSC 130 


-8- 


Lecture 5 



EQUIVALENT FUNCTIONS 


Two Equivalent Functions 

WITH Math_Lib; 

FUNCTION Hypotenuse (Side_l,Side_2: Float) 
RETURN Float IS 

Side_l_Squared,Side_2_Squared: Float; 
PACKAGE Math IS NEW Math_Lib(Float) ; 
BEGIN 

Side_l_Squared := Side_l ** 2; 
Side_2_Squared := Side_2 ** 2/ 

RETURN Math.Sqrt(Side_l_Squared + 
Side_2_Squared) ; 

END Hypotenuse; 

WITH Math_Lib/ 

FUNCTION Hypotenuse (Side_l^Side_2: Float) 
RETURN Float IS 

Sum_Of_Squares,Side_3: Float; 

PACKAGE Math IS NEW Math_Lib(Float) ; 
BEGIN 

Sum_Of_Squares := Side_l ** 2 + 

Side_2 **2; 

Side_3 := Math.Sqrt(Sum_Of_Squares) ; 
RETURN Side_3; 

END Hypotenuse; 

Mathematical Definition 

/?: R X R R h(s^,S2) = Vsi2'T^^ 


CMSC130 


-9- 


Lecture 5 



< 


* 


. j 


. • 


' % 






^ ' 'ih m. 


« • 
s 




» « 




t #» • - 


r • 

• » t •• 


V 

■\ 


k. 


t 




I -• 


n 

•t 



DEFINITE ITERATION CONCEPT 


Major Issues: 

1. Programs Containing Only Conditional Control Have 
Forward Control Flow 

2. Certain Problems Require Iterative Control To Be Solved 
Terminology: 

Definite Iteration : Control Mechanism That Permits The 
Repetition Of A Group Of Statements A Fixed (At Run-Time) 
Number Of Times 

Important Points: 

1. If The Number Of Repetitions Is Known At Compile-Time, 
Iteration Can Be Avoided By Repeating The Code At 
Fixed Number Of Times 

2. If The Number Of Repetitions Is Not Known Until Run¬ 
Time, Definite Iteration Is Required 

A Simple Problem Requiring Definite Iteration 
Computing Triangular Numbers 

1. Read In An Integer n. From The Keyboard 

2. Compute The Sum Of The First n Integers 

n 

li 

1=1 

3. Print The nth Triangular Number, The Sum 


CMSC 130 


-2- 


Lecture 6 



DEFINITE ITERATION EXAMPLE 


Triangular Numbers Program 

WITH Text_IO; 

PROCEDURE Triangular_Numbers IS 
Number, Triangle: Integer; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Text_IO.Put("Enter Number: "); 

Int_IO.Get(Number); 

Triangle := 0; 

FOR Index IN 1..Number LOOP 
Triangle := Triangle + Index; 

END LOOP; 

Text_IO.Put("Triangular Number = "); 
Int_IO.Put(Triangle); 

END Triangular_Numbers; 

Triangular Numbers 



CMSC130 


-3- 


Lecture 6 



FOR STATEMENT 


For Statement Syntax 
for_statement ::= 

FOR identifier in [ reverse ] discrete_range loop 
sequence_of_statements 

END LOOP; 

Static Semantic Rules: 

1. The Loop Control Variable Is Implicitly Declared 

a) The Loop Control Variable Should Not Be Explicitly 
Declared, Doing So Creates Two Variables 

b) It Can Only Be Referenced From The Sequence Of 
Statements That Comprise The Body Of The Loop 

c) It Only Exists During The Execution Of The Loop, It 
Is Deallocated Afterward 

2. The Type Of The Loop Control Variable, Defined By Its 
Range Of Values Must Be Discrete, Integer Or 
Enumerated 

3. Within The Body Of The Loop, The Loop Control Variable 
Can Not Be Modified By Assignments 

4. The Bounds Of The Loop Are Evaluated Once And 
Cannot Be Altered In The Body Of The Loop 


CMSC 130 


-4- 


Lecture 6 



FOR STATEMENT FLOWCHART 


Ascending For Statement 

FOR I IN 1..N LOOP 

sequence_of_statements 

END LOOP; 



CMSC 130 


-5- 


Lecture 6 






IF STATEMENT WITH ELSIF CLAUSES 

Categorize Courses Program 

WITH Text_IO; 

PROCEDURE Categorize_Courses IS 
TYPE Categories IS (Lower_Level/ 
Upper_Level, Graduate, Invalid); 
Category: Categories; 

Course_NurrJDer: Integer; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

PACKAGE Categories_IO IS NEW Text_IO. 
Enumeration_IO(Categories); 

BEGIN 

Text_IO.Put("Enter Course: ") ; 

Int_IO.Get(Course_Number); 

IF Course_Number < 100 THEN 
Category := Invalid; 

ELSIF Course_NuiTiber < 300 THEN 
Category := Lower_Level; 

ELSIF Course_Nuinber < 500 THEN 
Category := Upper_Level; 

ELSE 

Category := Graduate; 

END IF; 

Text_IO.Put("Category Is "); 
Categories_IO.Put(Category) ; 

Text_IO.New_Line; 

END Categorize Courses; 


CMSC130 


- 6 - 


Lecture 4 



FORMAL SYNTAX 


Backus-Naur Form (BNF) 

BNF Is A Meta-Language For Describing The Syntax Of 
Programming Languages, It Is Both Precise And Concise 

BNF Meta-Symbols 

::= Is Defined By 

[] Optional (Zero Or One) 

{} Repetition (Zero Or More) 

I Choice (One Or The Other) 

If Statement Syntax 

if_statement ::= 

IF condition then 

sequence_of_statements 
{ELSIF condition then 
sequence_of_statements} 

[ ELSE 

sequence_of_statements ] 

END IF; 

Historical Note: 

BNF Was First Used To Describe The Syntax Of The 
Programming Language Algol-60 


CMSC130 


-7- 


Lecture 4 



STATIC SEMANTICS 


Static Semantics In English 



Syntax 

Static 

Semantics 

Jump the in house of. 

X 

X 

The car eats the apple. 

V 

X 

The boy hits the ball. 

V 

V 


Static Semantic Rules 

Static Semantic Rules Are Rules That Determine Whether A 
Statement Is Meaningful 

Syntax Rules With Semantic Information 

condition ::= 

boo/ean_expression 

The Ada Language Reference Manual Italicizes Static 
Semantic Information In Its Syntax Rules 

Another Static Semantic Rule 

Requiring That The Types Of The Two Operands Within A 
Condition Be The Same Is A Static Semantic Rule, These 
Rules Often Involve Type Information Or Type Checking 


CMSC130 


-8- 


Lecture 4 



DYNAMIC SEMANTICS 


Dynamic Semantic Models 

Dynamic Semantics Models Are Methods For Defining The 
Meaning Of Statements In Programming Languages 

Operational Semantics 

Operational Semantics Is One Model For Defining The 
Meaning Of Statements That Translates The Statement Into 
An Less Abstract Language, Unstructured Language 

A Flowchart Is The Simplest Means Of Conveying The 
Operational Semantic Meaning Of A Statement 

Simple If Statement Flowchart 



CMSC130 


-9- 


Lecture 4 




NESTED IF STATEMENTS 


Summer Day Program 

WITH Text_IO/ 

PROCEDURE Summer_Day IS 

TYPE Months IS (Jan, Feb, Mar, Apr, May, 
Jun, Jul, Aug, Sep, Oct, Nov, Dec); 
Month: Months; 

Day: Integer; 

PACKAGE Months_IO IS NEW Text_IO. 

Enumeration_IO(Months); 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Text_IO.Put("Enter Month and Day: "); 
Months_IO.Get(Month); 

Int_IO.Get(Day); 

IF Month = Jun THEN 
IF Day >= 21 THEN 

Text_IO.Put_Line("Summer") ; 

END IF; 

ELSIF Month IN Jul..Aug THEN 
Text_IO.Put_Line("Summer"); 

ELSIF Month = Sep THEN 
IF Day < 21 THEN 

Text_IO.Put_Line("Summer"); 

END IF; 

END IF; 

END Summer Day; 


CMSC130 


-10- 


Lecture 4 



TRACING RKUUHAMb Wl I M ll- IMI tiviciN i o 


Tracing Program Execution 

Tracing The Execution Of A Program Can Be A Useful 
Technique For Understanding The Action Of A Program 


Trace Of Absolute Values Program 



Number 

Number < 0 

Int 10.Get(Number)/ 

-5 


IF Number < 0 THEN 


True 

Number = -Number 

5 


END IF/ 




Counting Paths 

Two If Else Statements In Sequence Creates A Program With 
Four Possible Paths 

An If Else Statement With One If Else Statement Nested In 
The If Part And One If Else Statement Nested In The Else Part 
Creates A Program With Four Paths 

Summer Day Program Has 6 Paths 
Two Paths For June 
One Path For July And August 
Two Paths For September 
One Path For Other Months 


CMSC130 


-11 - 


Lecture 4 














I bt> IINU bhlUbaMMIVlD vvi i n ir o i m i c^ivic^in i o 


Developing Testing Strategies 
All Statements Strategy 

Choose Test Data That Will Ensure That Each Statement 
In The Program Is Executod 

All Paths Strategy 

Choose Test Data That Will Ensure That Every Path Of 
The Program Is Executed 

Test Data To Test Each Path Of Summer Day Program 


Condition 

Test Data 

Output 

Month = Jun 

Day < 21 

Jun 5 

None 

Month = Jun 

Day < 21 

Jun 30 

Summer 

Month IN JuL.Aug 

Jul 10 

Summer 

Month = Sep 

Day < 21 

Sep 8 

Summer 

Month = Sep 

Day >= 21 

Sep 25 

None 

Month NOT IN 
Jun..Sep 

Feb 5 

None 


CMSC 130 


-12- 


Lecture 4 


























' % 


' i f * % 

' # 0 I 






V« k 





DECLARING AND CALLING FUNCTIONS 


Function Concept 

User Defined Functions Provide A First Capability For 
Procedural Abstraction, Defining A Common Function Once 
With The Ability To Call It Any Number Of Times 

Function Declaration Syntax 

functlon_declaration ::= 

FUNCTION identifier [ formaljDarameters ] 

RETURN type IS 
{declarations} 

BEGIN 

sequence_of_statements 
END identifier; 

formal_parameters ::= 

(formaljDarameter {, formaljDarameter}) 

formaljDarameter ::= 

identifier {, identifier}: type 

Function Call Syntax 

function_call ::= 

Identifier ( actual JDarameter {, actual jDarameter}) 

actuaLparameter ::= 

[ identifier => ] expression 


CMSC130 


-2- 


Lecture 5 



• ■ >• V» •w’ 

« • • • I 

♦ V ' ' / • . 4 ' ^ * 

• • ’ -4 

.. , .1 r-.. . .Vw' 




RECORD DECLARATIONS 


Syntax Rules: 

record_type_definition ::= 

RECORD 

componentjist 

END RECORD 

componentjist ::= component_declaration 
{component_declaration} | null 

component_declaration ::= identifierjist: type_mark 
[constraint] [: = expression]; 

Record Type Declaration: 

SUBTYPE Hours IS INTEGER RANGE 0..23; 

SUBTYPE Minutes IS INTEGER RANGE 0..59; 

TYPE Times IS 
RECORD 

Hour: Hours; 

Minute: Minutes; 

END RECORD; 

Important Points: 

1. Records Can Collect Together Data Elements Of 
Different Types 

2. Variables Of Record Types With Initialized Components 
Are Initialized To Those Values 


CMSC 130 


-2- 


Lecture 10 



RECORD AGGREGATES 


Terminology: 

Record Aggregate : A Literal Constant Which Represents The 
Value Of A Complete Record 

Record Object Declaration: 

Time: Times; 

Positional Aggregate: 

Time := (6,45); -- Is Equivalent To 
Time.Hour := 6; 

Time.Minute := 45; 

Named Aggregate: 

Time := (Minute => 45, Hour => 6); 


RECORD OPERATIONS 

Component Selection 
Assignment: Types Must Match 
Relational Operators: = /= Predefined 
Arithmetic And Logical Operators: None Predefined 


CMSC 130 


-3- 


Lecture 10 



RECORD EXAMPLE 


Students Type Definition 

SUBTYPE Ages IS Integer RANGE 0..120; 
SUBTYPE SSNs IS Integer RANGE 
100_000_000. . 999_999_999 ; 

TYPE Students IS 
RECORD 

Name: String(1..30); 

Age: Ages; 

SSN: SSNs; 

END RECORD; 

Get Procedure 

WITH Text_IO; 

PROCEDURE Get(Student: OUT Students) IS 
Last: Natural; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

BEGIN 

Text_IO.Put_Line("Enter name"); 

Student.Name := (OTHERS => ' '); 

Text_IO.Get_Line(Student.Name, Last); 
Text_IO.Put_Line("Enter student's age"); 
Int_IO.Get(Student.Age) ; 

Text_IO.Put_Line("Enter student's SSN"); 
Int_IO.Get(Student.SSN); 

END Get; 


CMSC 130 


-4- 


Lecture 10 



ARRAYS OF RECORD EXAMPLE 

Array Of Record Type Definition: 

TYPE Departments IS (CMSC,CMIS,IFSM); 
SUBTYPE Course_Numbers IS INTEGER RANGE 
100..499; 

SUBTYPE Enrollments IS INTEGER RANGE 0..45/ 
TYPE Courses IS 
RECORD 

Department: Departments; 

Course_Number: Course_Numbers; 
Enrollment: Enrollments; 

END RECORD; 

TYPE Course_Lists IS ARRAY(1..25) OF 
Courses; 

List: Course_Lists; 

List(1).Course Number := 130; 



Department 

Course_ 

Number 

Enrollment 

List (1) 

CMSC 

130 

42 

List (2) 

CMSC 

135 

35 

• 

• 

• 




List(25) 

CMSC 

430 

21 


CMSC130 


-5- 


Lecture 10 




NESTED RECORDS 

Preliminary Type Definitions: 

Hours_Per_Day: CONSTANT := 24; 
Minutes_Per_Hour: CONSTANT := 60; 

SUBTYPE Hours IS INTEGER RANGE 
0..Hours_Per_Day - 1; 

SUBTYPE Minutes IS INTEGER RANGE 
0..Minutes_Per_Hour - 1; 

TYPE Departments IS (CMSC,CMIS,IFSM); 
SUBTYPE Course_Numbers IS INTEGER RANGE 

100.. 499; 

SUBTYPE Sections IS INTEGER RANGE 

1000.. 9999; 

TYPE Days IS (Monday, Tuesday, Wednesday, 
Thursday, Friday, Saturday, Sunday); 

Nested Record Type Definition 

TYPE Times IS 
RECORD 

Hour: Hours; 

Minute: Minutes; 

END RECORD; 

TYPE Intervals IS 
RECORD 

Start_Time: Times; 

Stop_Time: Times; 

END RECORD; 


CMSC130 


-6- 


Lecture 10 



DOUBLY NESTED RECORDS 


Doubly Nested Record Type Definition: 

TYPE Classes IS 
RECORD 

Department- : Departments; 
Course_Number: Course_Numbers; 
Section: Sections; 

Day: Days; 

Interval: Intervals; 

END RECORD; 

Class: Classes; 

Class.Interval.Start Time.Hour := 7; 


Class 


Department 


Section 


Interval 


Course Number 


Day 


Start Time 


Stop Time 


Hour Minute Hour Minute 


CMSC130 


-7- 


Lecture 10 







RECORDS CONTAINING ARRAYS 


Record Containing Array Type Definition: 

SUBTYPE Percents IS INTEGER RANGE 0..100/ 
TYPE Homeworks IS ARRAY (1..10) OF Percents; 
TYPE Projects IS ARRAY (1..4) OF Percents; 
TYPE Grades IS 
RECORD 

Homework: Homeworks; 

Project: Projects; 

First_Exam, Second_Exam, Final: 

Percents; 

END RECORD; 

Grade: Grades; 

Grade.Homework(2) := 100; 

Homework 
Projects 
First_Exam 

Second_Exam 
Final Exam 



CMSC130 


-8- 


Lecture 10 




PHASES OF SOFTWARE DEVELOPMENT 


Requirements 

Written Document Specifying Systems Requirements 
Analysis And Design 

Analysis Of Requirements To Determine Hardware And 
Software Design 

System Design By Decomposition Into Subsystems Including 
Interface Specifications 

Coding And Unit Testing 

Translation Of Design Of Individual Units Into A Specific 
Programming Language 

Testing Of Individual Units Using Drivers Or Stubs 
Integration And Testing 

Integration Of Individual Units To Uncover Interface Problems 
Testing System Against Original Requirements Specification 
Operation And Maintenance 
Operation Of System 

Maintenance Includes Fixing Problems As Discovered And 
Adding Necessary Enhancements 


CMSC130 


-2- 


Lecture 11 



TOP-DOWN DESIGN EXAMPLE 


Problem: Design A Spreadsheet Program 
Major Steps 

1. Perform Initial Program Setup 

2. Get A Command From The User 

3. While The Command Is Not QUIT 
LOOP 

4. Execute The Command 

5. Display The Results Of The Command 

6. Get A Command From The User 
END LOOP 

7. Quit 
Important Points: 

1. The Design Should Include High-Level Algorithms And 
Initial Ideas For Data Structures 

2. The Outlines Of A Main Procedure And The Required 
Subprograms Should Begin To Emerge 

3. One Approach Is To Create Compilable Ada Modules 
With All Of The High-Level Concepts Written As 
Comments 


CMSC 130 


-3- 


Lecture 11 



TOP-DOWN DESIGN REFINEMENTS 


1. Initial Program Setup 

Allocate The Minimum Amount Of Memory Needed 

Clear The Screen, Print The Logo And Display The Main 
Menu 

2. Get A Command 

IF Valid Menu Choice Selected THEN 

IF The Menu Choice Has Sub-Choices THEN 
Display The Sub-Choices 
ELSE 

Get Required Data 
Add Data To Command Record 
END IF 

ELSIF The Right Arrow THEN 

IF Cursor Is On Rightmost Menu Item THEN 
Place Cursor On The Leftmost Menu Item 
ELSE 

Move Cursor One Menu Item To The Right 
END IF 

ELSIF The Left Arrow THEN 

IF Cursor Is On Leftmost Menu Item THEN 
Place Cursor On The Rightmost Menu Item 
ELSE 

Move Cursor One Menu Item To The Left 
END IF 

END IF 


CMSC 130 


-4- 


Lecture 11 



UNIT TESTING STRATEGIES 

Top-Down Testing 
Testing Strategy 

A Method Of Unit Testing For High-Level Subprograms 
Using Incomplete Lower Level Subprograms Called 
Stubs 

Stubs 

Stubs Typically Output A Message Indicating That They 
Have Been Called 

Bottom-Up Testing 

Testing Strategy 

A Method Of Unit Testing For Low-Level Subprograms 
Using Skeletal Higher Level Subprograms Called Drivers 

Drivers 

Drivers Typically Call The Subprogram To Be Tested And 
Output The Result 

Important Points: 

1. Ada Subunits Are A Language Feature That Can 
Facilitate Unit Testing 

2. The Syntax Of Subunits Will Be Studied In The 
Subsequent Course 


CMSC 130 


-5- 


Lecture 11 



TOP-DOWN TESTING 

Data Processor Procedure With Stubs 

WITH Text_IO; 

PROCEDURE Data_Processor IS 

PROCEDURE Read_Input IS 
BEGIN 

Text_IO. Put ("Input Read"); 

Text_IO. New_Line; 

END Read_Input; 

PROCEDURE Perform_Processing IS 
BEGIN 

Text_IO.Put("Processing Performed") ; 
Text_IO.New_Line; 

END Perform_Processing; 

PROCEDURE Write_Output IS 
BEGIN 

Text_IO.Put ("Output Written") ; 
Text_IO. New_Line; 

END Write_Output; 

BEGIN 

Read_Input; 

Perform_Precessing; 

Write_Output; 

END Data Processor; 


CMSC 130 


-6- 


Lecture 11 



BOTTOM-UP TESTING 

Driver Procedure To Test Min Function 

WITH Text_IO; 

PROCEDURE Driver IS 

Valuel, Value2, Minimum: Integer; 

PACKAGE Int_IO IS NEW Text_IO.Integer_IO 
(Integer); 

FUNCTION Min(Left,Right: Integer) 

RETURN Integer IS 
BEGIN 

IF Left < Right THEN 
RETURN Left; 

ELSE 

RETURN Right; 

END IF; 

END Min; 

BEGIN 

Text_IO.Put("Enter Two Integers: "); 
Int_IO.Get(Valuel); 

Int_IO.Get(Value2); 

Minimum := Min(Valuel,Value2); 

Text_IO.Put("Minimum Is "); 

Int_IO.Put(Minimum); 

Text_IO.New_Line; 

END Driver; 


CMSC 130 


-7- 


Lecture 11 



BLOCK STATEMENT 


Block Statement Syntax 

block_statement ::= 

[b/oc/c_simple_name:] 

[DECLARE 

declarativejDart] 

BEGIN 

sequence__of__statements 
END [b/oc/c_simple_name]; 

Semantic Rule: 

1. Block Names Must Match If They Are Present 
Important Points: 

1. Blocks Localize Variables And Can Save Memory, But 
Small Subprograms Can Do The Same 

2. Blocks Are Most Useful For Exceptions 
Terminology: 


Frame : A Block, A Procedure Or A Function 


DECLARE 

PROCEDURE 

FUNCTION 

declarations 

declarations 

declarations 

BEGIN 

BEGIN 

BEGIN 

statements 

statements 

statements 

END 

END 

END 


CMSC 130 


-8- 


Lecture 11 








SCOPE AND VISIBILITY 


Terminology: 

Scope : Portion Of A Program For Which A Specific Identifier 

Is Defined 

Visibility : Identifiers That Can Be Accessed From A Specific 

Point In A Program 

Scope And Visibility Rules 

1. The Scope Of Identifiers Is From Their Declaration Until 
The End Of The Frame In Which They Are Declared 

2. When The Same Identifier Is Redeclared In An Inner 
Frame, Only The Inner Occurrence Is Directly Visible 
(Most Closely Nested Rule) 

3. When The Same Identifier Is Redeclared In An Inner 
Frame, The Outer Occurrence Is Visible By Selection 
Using The Expanded Name 

4. The Scope Of Formal Parameters Is The Same As The 
Scope Of Their Subprogram Name, Outside The 
Subprogram They Are Visible Only Within Named 
Parameter Associations 

Accessing Hidden Identifiers 

Hidden Identifiers Are Visible By Selection And Can Be 

Accessed Using An Expanded Name 


CMSC130 


-9- 


Lecture 11 



VISIBILITY BY SELECTION 


Expanded Name Example 

PROCEDURE Outer_Frame IS 
Variable: Integer; 

BEGIN 

Inner_Frame: 

DECLARE 

Variable: Character; 

BEGIN 

Inner_Frame.Variable := 'A*; 
Outer_Frame.Variable := 1; 
Variable := 'B *; 

END Inner_Frame; 

END Outer_Frame; 

Outer_Frame 
I-Variable 


Inner Frame 



CMSC130 


-10- 


Lecture 11 



FILE INPUT/OUTPUT 


Major Issue: 

1. To Write Programs With More Than One Input File Or 
More Than One Output File, Explicit File Input/Output Is 
Required 

Explicit File Processing 

All Explicit Files Must Be Declared, Explicitly Opened And 
Explicitly Closed, All Input/Output Must Explicitly Name Which 
File Is Being Referenced 

Text_IO Package 

PACKAGE Text_IO IS 

TYPE File_Type IS LIMITED PRIVATE; 

TYPE File_Mode IS (In_File,Out_File); 
PROCEDURE Open(File: IN OUT File_Type; 
Mode: IN File_Mode; Name IN String; 

Form: IN String := 

PROCEDURE Close(File: IN OUT File_Type); 
FUNCTION End_Of_Line(File: IN File_Type) 
RETURN Boolean; 

FUNCTION End_Of_File(File: IN File_Type) 
RETURN Boolean; 

• • • 

-- Many Other Subprograms 

• • • 

END Text 10; 


CMSC 130 


-11 - 


Lecture 11 



EXPLICIT FILE EXAMPLE 


Copy File Procedure 

WITH Text_IO; USE Text_IO; 

PROCEDURE Copy_File IS 

Input_File, Output_File: File_Type; 

Char: Character; 

BEGIN 

Open(Input_File,In_File,"IN.TXT"); 

Create(Output_File,Out_File,"OUT.TXT"); 
WHILE NOT End_Of_File (Input_File) LOOP 
WHILE NOT End_Of_Line (Input_File) LOOP 
Get (Input_File,Char); 

Put (Output_File, Char) ; 

END LOOP; 

Skip_Line(Input_File)/ 

New_Line(Output_File); 

END LOOP; 

Close(Input_File); 

Close(Output_File); 

END Copy_File; 

Important Points: 

1. This Program Copies The Line And File Structure Of The 
Input File To The Output File 

2. The Output File Is Created Rather Than Opened 
Because It Does Not Already Exist 


CMSC 130 


-12- 


Lecture 11 





y 




•X 



• I ^ 

« i 

% ^ . K k I 


r 



ABSTRACT DATA TYPES 


Terminology: 

Abstract Data Type : An Axiomatic Definition Of A Data Type 
Which Defines The Behavior Of The Data Type And Its 
Associated Operations 

The Natural Numbers - N 

Operations 

Zero 0 : 0 ^ N 

Successor a : N ^ N 

Peano Axioms 

1. V n,m e N: a(n) = a(m) => n = m 

2. V n € N: a(n) ^ 0 

3. V M 9 M c N: (0 e M, n G M => a(n) g M) => M = N 
Mathematical Induction Axiom 

Supplemental Operation 
Addition + : N x N -9 N 
Addition Axioms 

1. VnGN:n + 0 = n 

2. V n,m G N: n + a(m) = a(n + m) 


CMSC 130 


-2- 


Lecture 12 



DATA TYPE REPRESENTATIONS AND 
IMPLEMENTATIONS 


Terminology: 

Data Type Representation : A Way To Represent The 
Elements Of A Data Type 

Data Type Implementation : A Way To Implement The 
Operations Of A Data Type Which Is Consistent With Its 
Abstract Definition 

Natural Numbers Representations 

Literal Representations 

1. Roman Numerals 

2. Arabic Numerals In Base 10 

3. Arabic Numerals In Base 5 

Internal Machine Representations 
1. Natural 

2 Binary Coded Decimal 

3 ASCII 

Natural Numbers Implementation 

To Uncover The Details Of The Implementation Of The 
Arithmetic Operations For Natural Numbers, One Must Look 
Into The Arithmetic Logic Unit Of The CPU 


CMSC130 


-3- 


Lecture 12 



EXTERNAL VIEW AND INTERNAL DETAILS 


External View 

The Abstract Data Type Is The External View, It Describes 

The Operations Of The Data Type And Their Behavior 

In Practice The Behavior Of A Data Type Might Best Be 

Described With English, Not Formal Mathematics 

Major Issues; 

1. The Exact Details Of How The Daia Is Represented And 
The Operat'oriS Are Implemented Is Unimportant To The 
User, The:;e Details Should Be Hidden 

2. It Is Important That The Implementation Be Consistent 
With The Axioms, 2 + 2 Must Equal 4 

Internal Details 

Internal Details Can Be Determined By The Hardware, 

System Software Or Application Software 

Important Points: 

1. The Internal Machine Representation And 
Implementation For Fundamental Data Types Is Made By 
The Hardware Designers 

2. The Representation And Implementation For User- 
Defined Data Types Must Be Made By The Software 
Designer 


CMSC 130 


-4- 


Lecture 12 



ADA AND ABSTRACT DATA TYPES 


Major Issue: 

Ada Packages Provide The Necessary Facility For 
Implementing Abstract Data Types 

Visible Part Of Package Specification 

The Abstract Data Type Is Defined Here 

1. A Private Type Definition Names The Type 

2. Subprogram Definitions Define The Operations, Ada 
Allows Functions Names To Be Operator Symbols 

3. Comments Can Define The Axioms, The Behavior 
Of The Data Type 

Private Part Of Package Specification 

The Representation Of The Data Type Is Defined Here As A 
Type Definition 

Package Body 

The Implementation Of The Data Type Is Defined Here As 
The Bodies Of The Subprograms Declared In The 
Specification 

Important Point: 

1. Only The Visible Part Of The Package Can Be Seen By 
Users Of The Package 


CMSC 130 


-5- 


Lecture 12 



PACKAGES 


Package Syntax 

package_specification ::= 

PACKAGE identifier is 
{basic_declarativejtem} 

[PRIVATE 

{basic_declarativejtem}] 

END [pac/cagfe_simple_name]; 

package_body ::= 

PACKAGE BODY pac/cagfe_simple_name is 
[declarativejDart] 

END [pac/cagfe_simple_name]; 

General Package Structure 

PACKAGE Data_Type_Package IS 
TYPE Data_Type IS PRIVATE; 

-- Subprogram Specifications 
PRIVATE 

TYPE Data_Type IS 

--Actual Type Definition 
END Data_Type_Package/ 

PACKAGE Data_Type_Package IS 
—Subprogram Bodies 
END Data Type Package; 


CMSC 130 


-6- 


Lecture 12 



COMPLEX PACKAGE SPECIFICATION 


Package Specification 

PACKAGE Complex_Pack:age IS 
TYPE Complex IS PRIVATE; 

FUNCTION ”+"(X,Y: COMPLEX) RETURN Complex; 

FUNCTION "-"(X,Y: COMPLEX) RETURN Complex; 

FUNCTION ''*"(X,Y: COMPLEX) RETURN Complex; 

FUNCTION "/"(X^Y: COMPLEX) RETURN Complex; 

FUNCTION "+"(X: Float; Y: Complex) RETURN 
Complex; 

FUNCTION "*"(X: Float; Y: Complex) RETURN 
Complex; 

FUNCTION Re(X:Complex) RETURN Float; 
FUNCTION Im(X:Complex) RETURN Float; 
i: CONSTANT Complex; 

PRIVATE 

TYPE Complex IS 
RECORD 

Real: Floaty- 
Imaginary: Float; 

END RECORD; 

i: CONSTANT Complex := (0.0,1.0); 

END Complex_Package; 

Important Points: 

1. The Second + And * Functions Are Constructors 

2. The Functions Re And Im Are Selectors 


CMSC 130 


-7- 


Lecture 12 




COMPLEX PACKAGE BODY 


Package Body 

PACKAGE BODY Complex_Package IS 
FUNCTION "+"(X,Y: COMFLEX) 

RETURN Complex IS 
BEGIN 

RETURN (X.Real + Y.Real, 

X. Imaginary + Y.Imaginary); 

END 

FUNCTION "*''(X,Y: COMPLEX) 

RETURN Complex IS 
BEGIN 

RETURN (X.Real * Y.Real - X.Imaginary * 

Y. Imaginary, X.Real * Y.Imaginary + 

X.Imaginary * Y.Real); 

END 

FUNCTION " + '’(X: Float; Y: Complex) 

RETURN Complex IS 
BEGIN 

RETURN (X + Y.Real, Y.Imaginary); 

END 

FUNCTION "*"(X: Float; Y: Complex) 

RETURN Complex IS 
BEGIN 

RETURN (X * Y.Real, X * Y.Imaginary); 
END 

END Complex Package; 


CMSC 130 


-8- 


Lecture 12 



USE OF COMPLEX NUMBER PACKAGE 

Complex Numbers Procedure: 

WITH Complex_Package; USE Complex_Package; 
PROCEDURE Complex_Numbers IS 

Complexl,Complex2,ComplexS: Complex; 

BEGIN 

Complexl := 3.0 + 2.0 * i; 

Complex2 := 

(Real => 1.0, Imaginary => 2.0); 
Complex3 := Complexl + Complex2; 

END Complex_Numbers; 

Important Points: 

1. In Order To Use The Complex Operators In Their Infix 
Form, It Is Necessary To "Use" The Package 

2. Complex Numbers Are Created With The Selectors 
Using +.* (FLOAT, COMPLEXES COMPLEXES) 

For Example, 3.0 + 2.0 * i 

3. The Second Assignment Is A Syntax Error Because The 
The Type Is Private 

4. The Third Assignment Performs Complex Number 
Addition 


CMSC 130 


-9- 


Lecture 12 



SOFTWARE ENGINEERING CONCEPTS 


Terminology: 

Encapsulation : Physically Enclosing The Type Definition And 
Operations For An Abstract Data Type 

Information Hiding : Limiting Visibility Of Type And Variable 
Declarations 

Loosely Coupled Systems : Systems Subdiyided Into 
Components With Minimal Interdependence 

Software Reusability : General Software That Can Be Used By 
Many Programs 

Important Points: 

1. If The Complex Number Package Were Changed From 
Rectangular Coordinates To Polar Coordinates 
Programs That Use The Package 

a) Would Require Recompilation 

b) Would Not Require Any Changes 

2. Loose Coupling Minimizes The Possibility That Software 
Changes Will Create Problems In Other Parts Of The 
System 

3. Ada Packages Enable Encapsulation, Information Hiding 
And Make It Possible To Create Loosely Coupled 
Systems 


CMSC 130 


-10- 


Lecture 12 



CHARACTER PACKAGE SPECIFICATION 

Package Specification 

PACKAGE Character_Function_Package IS 

FUNCTION Is_Upper(Ch: Character) 

RETURN Boolean; 

FUNCTION Is_Lower(Ch: Character) 

RETURN Boolean; 

FUNCTION Is_Alpha(Ch: Character) 

RETURN Boolean; 

FUNCTION Is_Digit(Ch: Character) 

RETURN Boolean; 

FUNCTION To_Upper(Ch: Character) 

RETURN Character; 

FUNCTION To_Lower(Ch: Character) 

RETURN Character; 

END Character_Function_Package; 

Important Points: 

1. This Package Does Not Define A New Type, It Collects 

Together A Library Of Similar Utility Functions 

2. Packages Can Also Be Used To: 

a. Define A Collection Of Constants, Such Packages 
May Have No Bodies 

b. Define A Collection Of Variables, Although Ada 
Permits This, It Is A Very Poor Practice 


CMSC 130 


-11 - 


Lecture 12 



CHARACTER PACKAGE BODY 


Package Body 

PACKAGE BODY Character_Function_Package IS 
FUNCTION Is_Upper(Ch: Character) 

RETURN Boolean IS 
BEGIN 

RETURN Ch IN *A*..*Z'; 

END Is_Upper; 

FUNCTION Is_Alpha(Ch: Character) 

RETURN Boolean IS 
BEGIN 

RETURN Is_Lower(Ch) OR Is_Upper (Ch); 

END Is_Alpha/ 

FUNCTION To_Upper(Ch: Character) 

RETURN Character IS 

Offset: Integer := Character *Pos('A') - 
Character'Pos('a *); 

Place: Integer; 

BEGIN 

IF Is_Lower(Ch) THEN 

Place := Character'Pos(Ch) + Offset; 
RETURN Character'Val(Place); 

ELSE 

RETURN Ch; 

END IF; 

END To_Upper; 

-- Several Function Bodies Are Omitted 
END Character Function Package; 


CMSC 130 


-12- 


Lecture 12 



CMSC 130 


INTRODUCTORY 
COMPUTER SCIENCE 

LECTURE 13 


ADVANCED ARRAY TYPES 



MULTIDIMENSIONAL ARRAYS 


Multi-Dimensional Array Definition Syntax 

multl-dlmensional_array_deflnition ::= 

ARRAY (discrete_range {,discrete_range}) of type 

Multi-Dimensional Array Type Declarations 

TYPE Square_Matrix IS ARRAY(1..10, 1..10) OF 
Integer; 

TYPE Rectangular_Matrix IS ARRAY(1..2,1..4) 
OF Integer; 

TYPE Three_Dimensional_Array IS ARRAY 
(1. .5,1..5,1. .5) OF Floaty- 

Array Object Declarations 

Square: Square_Matrix; 

Rectangle: Rectangular_Matrix; 

Three: Three_Dimensional_Array; 

Array Component Assignments 

Matrix(1,1) := 1; 

Rectangle (2,4) := 5; 

Three (1,2,5) := 3.8; 


CMSC130 


-2- 


Lecture 13 



MULTI-DIMENSIONAL AGGREGATES 


Positional Aggregate 

Rectangle := ((1,2,3,4), (2,4,6,8))/ 

Named Aggregate 

Rectangle := ( 

1 => (1 => 1, 2 => 2, 3 => 3, 4 => 4), 

2 => (1 => 2, 2 => 4, 3 => 6, 4 => 8)); 

MULTI-DIMENSIONAL ARRAY OPERATIONS 

Assignment 

Types Must Match 
Subscripting 

A Subscript Must Be Provided For Each Dimension 
Slicing 

Slices Are Not Permitted On Multi-Dimensional Arrays 

Relational Operators 

Pre-defined = /= 

Not Pre-defined >>=<<= 

May Be User Defined 


CMSC130 


-3- 


Lecture 13 



STORAGE ALLOCATION FOR ARRAYS 


Row Major 



1 , 1 1,2 1,3 1,4 2 , 1 2,2 2,3 2,4 


Column Major 



CMSC130 


-4- 


Lecture 13 



TWO-DIMENSIONAL ARRAY EXAMPLE 

Type Declaration 

SUBTYPE Row_Range IS Integer RANGE 1..2; 
SUBTYPE Column_Range IS Integer RANGE 1..3; 
TYPE Original_Type IS ARRAY(Row_Range, 
Column_Range) OF Integer; 

TYPE Flipped_Type IS ARRAY(Column_Range, 
Row_Range) OF Integer; 

Matrix Transposition Function 

FUNCTION Transpose(Original: Original_Type) 
RETURN Flipped_Type IS 
Flipped: Flipped_Type; 

BEGIN 

FOR Row IN Row_Range LOOP 

FOR Column IN Column_Range LOOP 
Flipped(Column^Row) := 

Original(Row, Column); 

END LOOP; 

END LOOP; 

RETURN Flipped; 

END Transpose; 

Important Point: 

1. A Generalized Function For Matrices Of Any Size Can Be 
Written Using Unconstrained Array Types 


CMSC130 


-5- 


Lecture 13 



THREE DIMENSIONAL ARRAY EXAMPLE 


Type Declarations 

TYPE Day_Type IS (Monday, Tuesday, 
Wednesday, Thursday, Friday); 

SUBTYPE Room_Type IS Integer RANGE 1..10; 

TYPE Bldg_Type IS (Computer_Science, 
Engineering); 

TYPE Room_Status_Type IS (Available, 
Reserved); 

TYPE Room_Availability_MatriX IS 

ARRAY(Day_Type, Bldg_Type, Room_Type) OF 
Room_Status_Type/ 

Initialized Variable Declarations 

Room_Matrix: Room_Availability_Matrix := 
(Monday..Friday => 

(Computer_Science..Engineering => 
(Room_Type'First..Room_Type'Last => 
Available)))/ 

Constant Declaration 

Full: CONSTANT Room_Availability_Matrix := 
(Monday..Friday => 

(Computer_Science..Engineering => 
(Room_Type'First..Room_Type'Last => 
Reserved))); 


CMSC130 


-6- 


Lecture 13 



UNCONSTRAINED ARRAY TYPES 

Unconstrained Array Definition Syntax 

unconstrained_array_definition ::= 

ARRAY (type RANGE <>{, type RANGE <>}) OF type 

Unconstrained Array Type Declarations 

TYPE Integer_Vector IS ARRAY 
(Integer RANGE <>) OF Integer; 

TYPE Character_Frequency IS ARRAY 
(Character RANGE <>) OF Integer; 

Array Object Declarations 

Vector: Integer_Vector(1..10); 

Frequency: Character_Frequency('a' . . ' z ' ) ; 

Important Points: 

1. The Box Symbol <> Means "To Be Specified" 

2. Constrained Indexes And Unconstrained Indexes Can 
Not Be Mixed In The Same Array Type Declaration 

3. An Object Of An Unconstrained Type Must Be 
Constrained In The Object Declaration 

4. A Formal Parameter Of An Unconstrained Array Type 
May Be Left Unconstrained 


CMSC 130 


-7- 


Lecture 13 



ARRAY ATTRIBUTES 


Array Attributes 

Type'First (I) 

First Subscript Of Ith Dimension 

Type'Last (I) 

Last Subscript Of Ith Dimension 

Type'Length (I) 

Number Of Elements In Ith Dimension 

Type ' Range (I) <=? Type * First (I) .. Type ' Last (I) 

Important Points: 

1. Array Attributes May Be Applied To Either Array Types 
Or Array Objects 

2. Subscript Can Be Omitted For First Dimension 
Examples 

Vector'First -- 1 
Vector'Range -- 1..10 

Frequency'Last — 'z' 

Frequency'Length -- 26 

Rectangle'Last (1) -- 2 
Rectangle'Last (2) -- 4 


CMSC 130 


-8- 


Lecture 13 



ASSIGNMENT AND COMPARISON 


Assignment Rule 

To Assign Arrays They Must Be Of Same Type And Sdme 
Length, But The Bounds May Be Different 

Assigning Arrays Of Different Lengths Produces A Constraint 
Error At Run Time 

Array Assignment Example 

TYPE Array_Type IS ARRAY (Integer RANGE <>) 
OF Integer; 

Array_l: Array_Type(0 . . 9)/ 

Array_2: Array_Type(1..10); 

Array_l := Array_2; -- Valid Assignment 

Comparison Rule 

To Compare Arrays They Must Be Of Same Type And Same 
Length, But The Bounds May Be Different 

Comparing Arrays Of Different Lengths Produces A Value Of 
False 

Array Comparison Example 

"String" = "String '' 

-- False Because Lengths Are Differenc 


CMSC130 


-9- 


Lecture 13 



UNCONSTRAINED ARRAYS AND 
SUBPROGRAMS 


Major Issues: 

1. Unconstrained Array Types Decouple The Length From 
The Type 

2. Unconstrained Array Types Make It Possible To Write 
Generalized Subprograms 

Specific Issues: 

1. Subprograms Can Have Array Parameters Of An 
Unconstrained Array Type, Left Unconstrained 

2. Functions Can Return Arrays Of An Unconstrained Type 

Storage Allocation Issues: 

1. Because The Compiler Must Allocation Space For Array 
Variables, They Must Be Constrained In Their 
Declaration If Their Type Is Unconstrained 

2. The Size Of An Unconstrained Formal Parameter Is 
Determined At Run-Time, It Depends On The Size Of 
The Actual Parameter 

Important Point: 

1. The Attributes Of An Array Parameter Are Passed With 
The Array Automatically, So It Is Not Necessary To Pass 
Them As Parameters 


CMSC 130 


-10- 


Lecture 13 



UNCONSTRAINED PARAMETER EXAMPLE 

Compute Maximum Program 

WITH Text_IO; 

PROCEDURE Compute_Maximum IS 

TYPE Vectors IS ARRAY (Integer RANGE <>) 

OF Integer; 

Five_Values: Vectors(1..5)/ 

Maximum: Integer; 

PACKAGE Int_IO IS NEW 

Text_IO.Integer_IO(Integer); 

FUNCTION Find_Maximum(Vector: 

Vectors) RETURN Integer IS 
Local_Maximum: Integer := Integer'First; 
BEGIN 

FOR Index IN Vector'Range LOOP 

IF Vector(Index) > Local_Maximum THEN 
Local_Maximum := Vector(Index); 

END IF; 

END LOOP; 

RETURN Local_Maximum; 

END Find_Maximum; 

BEGIN 

Five_Values := (20,0,89,18^43); 

Maximum := Find_Maximum(Five_Values); 
Text_IO.Put("Maximum Is "); 

Int_IO.Put(Maximum); 

Text_IO.New_Line; 

END Compute Maximum; 


CMSC 130 


-11 - 


Lecture 13 



UNCONSTRAINED FUNCTION EXAMPLE 

Reverse String Function 

FUNCTION Reverse_String(Original: String) 
RETURN String IS 

Reversed: String(Original'Range); 
Reverse_Index: Positive; 

BEGIN 

FOR Original_Index IN Original * Range LOOP 
Reverse_Index := Original' Last -- 
Original_Index + Original'First; 
Reversed(Reverse_Index) := 

Original(Original_Index); 

END LOOP; 

RETURN Reversed; 

END Reverse_String; 

Important Points: 

1. String Is A Predefined Unconstrained Array Type 

TYPE String IS ARRAY(Positive RANGE <>) 

OF Character; 

2. The Range Attribute Is Used To Declare A Local Variable 
Of The Same Size As The Formal Parameter 

3. The Length Of The Returned String Is Determined By Of 
The Variable In The Return Statement 


CMSC 130 


-12- 


Lecture 13 



•- • 




I • 

\ 0 V * « 

i 








^ >v • 



. * t • 

• f 


s 4 


■\ 


^-. ♦ • 

1 •“a 

* • 


r 

i* 

\ .* 


* s * 


4 


t 



TRIANGULAR NUMBERS WITH ITERATION 


Iterative Definition Of Triangular Numbers 

n 

An = I i 
i=1 

Iterative Evaluation Of Triangular Numbers 

4 

A4 = 11 = 1+ 2 + 3 + 4 = 10 

Iterative Triangular Function 

FUNCTION Triangular(Number: Positive) 
RETURN Positive IS 
Sum: Integer := 0; 

BEGIN 

FOR Index IN 1..Number LOOP 
Sum := Sum + Index; 

END LOOP; 

RETURN Sum; 

END Triangular; 

Important Points: 

1. The Triangular Number Sequence Is The Following: 

1,3,6,10,15,21,28, 36... 

2. The Summation Symbol Of Mathematics Corresponds 
To The For Loop Of Ada 


CMSC 130 


-2- 


Lecture 14 



TRIANGULAR NUMBERS WITH RECURSION 


Recursive Definition Of Triangular Numbers 

{ 1 if n = 1 

n + An-1 if n > 1 

Recursive Evaluation Of Triangular Numbers 

Aa = 4 + A 3 
= 4 + 3 + A 2 
= 4 + 3 + 2 +Ai 
= 4 + 3 + 2 + 1 = 10 

Recursive Triangular Function 

FUNCTION Triangular(Number: Positive) 

RETURN Positive IS 

BEGIN 

IF Number = 1 THEN 
RETURN 1/ 

ELSE 

RETURN Number + Triangular(Number-1); 
END IF; 

END Triangular; 

Important Point: 

1. The Recursive Ada Function Is Simply A Translation Of 
The Recursive Definition 


CMSC 130 


- 3 - 


Lecture 14 



FACTORIAL WITH ITERATION 

Iterative Definition Of Factorial 

n! = n i 

1=1 

Iterative Evaluation Of Factorial 

4 

4!=ni = 1x2x3x4 = 24 

1=1 

Iterative Triangular Function 

FUNCTION Factorial(Number: Natural) 

RETURN Positive IS 

Product: Integer := 1; 

BEGIN 

FOR Index IN 1..Number LOOP 
Product := Product * Index/ 

END LOOP; 

RETURN Product; 

END Factorial; 

Important Points: 

1. Factorial Is The Multiplicative Analog Of The Triangular 
Numbers 

2. The Product Symbol Of Mathematics Corresponds To 
The For Loop Of Ada 


CMSC 130 


-4- 


Lecture 14 



FACTORIAL WITH RECURSION 


Recursive Definition Of Factorial 

{ 1 if n = 0 

n X (n-1)! if n > 1 

Recursive Evaluation Of Triangular Numbers 

4! =4x3! 

= 4x3x2! 

= 4x3x2x1! 

= 4x3x2x1 =24 

Recursive Factorial Function 

FUNCTION Factorial(Number: Natural) 

RETURN Positive 13 
BEGIN 

IF Number = 0 THEN 
RETURN 1; 

ELSE 

RETURN Number * Factorial(Number-1); 

END IF; 

END Factorial; 

Important Point: 

1 . Recursive Subprograms Must Contain A Base Case Path 
And A Recursive Case Path, The Recursive Case Must 
Converge Toward The Base Case 


CMSC130 


-5- 


Lecture 14 



PALINDROMES WITH ITERATION 

Iterative Definitions Of Palindrome 

n 

2 

Palindrome(s) = a Si = Sn-i+i, where n = Length(s) 

i = 1 

Palindrome(s) = i, 1 < i < ^ si = Sn-i+i 

( V Is Equivalent To An Iterative a ) 

Iterative Evaluation Of Palindrome 

Palindrome(addcda) = (a = a) a (b= b) a (b= c) = 

True A True A False = False 

Iterative Palindrome Function 

FUNCTION Palindrome(Word: String) 

RETURN Boolean IS 
Right: Integer; 

BEGIN 

FOR Index IN Word * First..Word'Last/2 LOOP 
Right := Word’Last - Index + 1; 

IF Word(Index) /= Word(Right) THEN 
RETURN False; 

END IF; 

END LOOP; 

RETURN True; 

END Palindrome; 


CMSC 130 


-6- 


Lecture 14 



PALINDROMES WITH RECURSION 


Recursive Definition Of Palindrome 


Palindrome(s) = 



True if Length(s) < 1 

First(s) = Last(s) a Palindrome(Middle(s)) 


Recursive Evaluation Of Palindrome 


Palindrome(atocda) = (a = a) a Palindrome(5dcd) 
= True A Palindrome(bbcd) 

= True A(b = b) A Palindrome(6c) 

= True A True a Palindrome(6c) 

= True ATrue A(d=c) 

= True A True a False = False 


Recursive Palindrome Function 

FUNCTION Palindrome(Word: String) 

RETURN Boolean IS 
BEGIN 

IF Word'Length <= 1 THEN 
RETURN True; 

ELSE 

RETURN 

Word(Word'First) = Word(Word'Last) 
AND THEN 

Palindrome(Word(Word'First+1 .. 
Word'Last-1) ); 

END IF; 

END Palindrome; 


CMSC130 


-7- 


Lecture 14 



COMPARING ITERATION AND RECURSION 



Iteration 

Recursion 

Control 

Loop Statement 

Recursive Call 

Local Variables 

Required 

Not Required I 

Assignments 

Required 

Not Required 

Style 

Imperative 

Declarative 

Size 

Larger 

Smaller 

Nontermination 

Infinite Loop 

Infinite Recursion j 


Important Points: 

1 . Recursion Provides The Beginning Of A Functional Style 
Of Programming That Is Characterized By: 

a) No Local Variables 

b) No Intermediate States 

c) No Assignment Statements 

2 . Functional Programming Is At A Higher Level Of 
Abstraction Than Imperative Programming 

3. Thinking Recursively Means Searching For A Definition, 
Not For An Algorithm 

4. Recursion Can Often Provide Shorter Simpler Solutions 


CMSC130 


-8- 


Lecture 14 


























TAIL RECURSION 


Terminology: 

Tail Recursive : A Subprogram In Which The Recursive Call Is 
The Last Step 

Tail Recursive Triangular Function 

FUNCTION Triangular(Number: Positive) 

RETURN Positive IS 

FUNCTION Triangle(Number,Sum: Integer) 

RETURN Positive IS 

BEGIN 

IF Number = 0 THEN 
RETURN Sum; 

ELSE 

RETURN Triangle(Number-1,Sum+Number); 
END IF; 

END Triangle; 

BEGIN 

RETURN Triangle(Number,0)/ 

END Triangular; 

Important Points: 

1. Tail Recursive Solutions Mimic Iteration, They Are Not 
The Result Of Thinking Recursively 

2. The Tail Recursive Solution For This Problem Requires A 
Nested Function 


CMSC 130 


-9- 


Lecture 14 



DOUBLE RECURSION 


Fibonacci Function 

FUNCTION Fibonacci(Number: Natural) 

RETURN Natural IS 

BEGIN 

IF Number = 0 OR Number = 1 THEN 
RETURN Number; 

ELSE 

RETURN Fibonacci(Number-1) + 

Fibonacci (Number-2)/ 

END IF; 

END Fibonacci; 



CMSC 130 


-10- 


Lecture 14 



CHARACTER REVERSAL 


Reversal Procedure 

WITH Text_IO; 

PROCEDURE Reversal IS 
Char: Character; 

BEGIN 

IF NOT Text_IO.End_Of_Line THEN 
Text_IO.Get(Char) ; 

Reversal; 

Text_IO.Put(Char) ; 

END IF; 

END Reversal; 

Important Points: 

1 . This Procedure Uses The Compiler's Stack Of Activation 
Records To Perform The Reversal 

2 . The Order Of Execution Is That All The Gets Are 
Executed Before All The Puts 



Local Variable Stack 


CMSC 130 


-11 - 


Lecture 14 




RECURSION AND EFFICIENCY 


* 

Fibonacci Numbers 



Execution Speed 

Memory Utilization 

Recursive 

Exponential 

Linear 

Iterative 

Linear 

Constant 


Character Reversal 


1 

Execution Speed 

Memory Utilization 

Recursive 

Linear 

Linear 

Iterative 

Linear 

Linear 


Important Points: 

1 . The Use Of Recursion Can Dramatically Reduce The 
Efficiency Of Certain Problems 

2 . Other Problems Such As Character Reversal, Can Not 
Be Solved In A Bounded Memory Space, For Such 
Problems Recursion Does Not Introduce An Efficiency 
Penalty 


CMSC 130 


-12- 


Lecture 14 































REFERENCES AND NOTES 


REFERENCES: H 

The following references were used in the preparation of these lecture notes: 

Reference Manual For The Ada Programming Language, ANSI/MIL-STD 
1815A-1983. Washington, D.C.: U.S. Government, 1983. 

Barnes, J. G. P. Programming In Ada, Tnird Edition. Reading, Mass.: 
Addison-Wesley, 1989. 

Cohen, Norman H. Ada As A Second Language. New York: McGraw Hill, 
1986. 

Feldman, Michael B. and Elliot B. Koffman, Ada Problem Solving and 
Program Design. Reading, Mass.: Addison-Wesley, 1992. 

Savitch, Walter J. and Charles G. Petersen. Ada, An Introduction to the Art 
and Science of Programming. Redwood City, Calif.: Benjamin/Cummings 
Publishing Company, 1992. 

Sebesta, Robert W. Concepts of Programming Languages. Redwood City, 
Calif.: Benjamin/Cummings, 1989. 

Shumate, Ken. Understanding Ada (2nd Edition). New York: John Wiley, 
1989. 

Skansholm, Jan. Ada from the Beginning. Reading, Mass.: Addison-Wesley, 
1988. 

Volper, Dennis and Martin D. Katz. Introduction to Programming Using 
Ada. Englewood Cliffs, N.J.: Prentice-Hall, 1990. 

NOTES: 

1. The Ada language reference manual and references by Cohen and Barnes 
provide a comprehensive view of the Ada language. 

2. The reference by Sebesta provides a good discussion of programming 
language semantics. 

3. The remaining references are all texts for introductoiv programming 
courses using Ada. 


- 1 - 


CMSC 130 


References 



