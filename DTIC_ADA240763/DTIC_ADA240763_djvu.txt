AD-A240 763 


NTATION PAGE 


Form Approve 
OPMNo. 0704-0183 


11 houf p«r resoonsa inciu(K<Q the !im« tof r«vt«wing rsiructont. sMn^rg axung dau swurcM galhanng and manainng di# data 
I me C'jrdan ssiimais or any other aapeo ol the coilsciion of irtormaiion. including auggaationa tor raduo^ me Durden, to Wurwrgor 
Maadquanere Sarvea. Zlvactoraia tor mtormaoon Gcarationa and Racerts. 1216 Jattersen Date mgrhaay. Suaa 120 a Anmgion VA 22202-4302. and to the Ottice o< Intormation and Raguiaiory Adain Otiica ot 
Managemant and Budget. Washm^on. OC 20S03 


1 AGENCY USE ONLY (Leave Blank) 


4 TITLE AND SUBTITLE 


2. REPORT DATE 


J REPORT TYPE AND OATES COVERED 

Final: 30 Jul 1991 to 01 Jun 1991 


Ada Compiler Validation Summary Report;U.S. NAVY, Ada/M, Version 4.0 
(OPTIMIZE), VAX 11/785 (Host) to ANY/UYK-44 (EMR)(Bare 8oard)(Target), 
91062651,11178 


6. AUTHOR(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7 PERFORMING ORGANIZATION NAME(S) AND ADDRESS!ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm A266 
Gaithersburg, MD 20899 USA 


9 SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, RM 3E114 
Washington, D C. 20301-3081 



8 PERFORMING ORGANIZATION 
REPORT NUMBER 

NIST90USN510 11 1.11 


10 SPONSORING/MONITORING AGENCY 
REPORT NUMBER 



12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 


12b DISTRIBUTION CODE 


13 ABSTRACT (Maximum 200 words) 

U S. NAVY, Ada/M, Version 4.0 (OPTIMIZE), Gaithersburg, MD. VAX 11/785, running VAX/VMS Version 5.3 (Host) to 
ANY/UYK-44 (EMR)(Bare Board)(Target), ACVC 1,\.11 




14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
Ot" HtKOn I 
UNCLASSIFIED 


NSN 7540-01 280-550 


18 SECURITY CLASSIFICATION 


UNCLASSIFED 


19 SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


9 1 


15. NUMBER OF PAGES 


16, PRICE CODE 


20. LIMITATION OF ABSTRACT 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std 239-128 
































AVF Control Number: NIST90USN510_11_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 1991-04-05 
AFTER ON-SITE: 1991-06-26 
REVISIONS: 1991-07-30 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 910626S1.11178 
U.S. NAVY 

Ada/M, Version 4.0 (/OPTIMIZE) 

VAX 11/785 => AN/UYK-44 (EMR) (Bare Board) 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


’~A':cesio:'. Kor 

vns AAi 

; u I I / • t_> 

11 y .'.O 

J I 








AVF Control Number: NIST90USN510_ll_l.ll 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on 1991-06-26. 


Compiler Neune and Version: Ada/M, Version 4.0 (/OPTIMIZE) 

Host Computer System: VAX 11/785, running VAX/VMS Version 

5.3 


Target Computer System: AN/UYK-44 (EMR) (Bare Board) 

A more detailed description of this Ada implementation is found in 
section 3.1 of this report. 


As a result of this validation effort. Validation Certificate 
910626S1.11178 is awarded to U.S. NAVY. This certificate expires 
on 01 March 1993. 


This report has been reviewed and is approved. 




Manager, Software Standards 
Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CLS) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



_ 

Ada J^Lid^ion Organization 

Dir^ctQZwComputer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 






Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 






DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the 
customer. 


DECLARATION OF CONFORMANCE 


Customer: U.S. NAVY 

Certificate Awardee: U.S. NAVY 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: Ada/M, Version 4.0 (/OPTIMIZE) 

Host Computer System: VAX 11/785, running VAX/VMS Version 

5.3 

Target Computer System: AN/UYK-44 (EMR) (Bare Board) 

Declaration: 

I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
8652-1987 in the implementation listed above. 



Customer Signature 


Date 


Company U.S. Navy 




Title 

\ ■ 




✓ 


i 

• ‘ 

Certificate Awardee 

Signature 

Date 



Company U.S. Navy 
Title 





TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION . 1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-5 


CHAPTER 3.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION. 3-2 


APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 



























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552) . The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 
Computer and Software Engineering Division 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311-1772 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 3983 and ISO 8652-1987. 


1-1 






[r'ro90] Ada Compiler Validation Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 


[UG89] Ada Compiler Validation Capability User's Guide . 21 June 
1989 . 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. Class B 
tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that 
all violations of the Ada Standard are detected. Some of the class 
B tests contain legal Ada code which must not be flagged illegal by 
the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 


1-2 




the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]) . 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to 
be added to a given host and target computer 
system to allow transformation of Ada programs 
into executable form and execution thereof. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


The means for testing compliance of Ada 
implementations. Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user's guide and the template for 
the validation summary (ACVC) report. 


Ada An Ad?, compiler with its host computer system and 

Implementation its target computer system. 


Ada The part of the certification body which carries 

Validation out the procedures required to establish the 

Facility (AVF) compliance of an Ada implementation. 


Ada The part of the certification body that provides 

Validation technical guidance for operations of the Ada 

Organization certification system. 

(AVO) 

Compliance of The ability of the implementation to pass an ACVC 
an Ada version. 

Implementation 

Computer A functional unit, consisting of one or more 

System computers and associated software, that uses 

common storage for all or part of a program and 
also for all or part of the data necessary for 
the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including 
arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 


1-3 





Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of 
all requirements specified. 

An individual or corporate entity who enters into 
an agreement with an AVF which specifies the terms 
and conditions for AVF services (of any kind) to 
be performed. 

A formal statement from a customer assuring that 
conformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
implementation. 

Software that controls the execution of programs 
and that provides services such as resource 
alxoca^-Ton, scheduling, input/output control, 
and data management. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
successfully either by AVF testing or by 
registration [Pro90]. 

The process of checking the conformity of an ?la 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


1-4 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 94 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-05-03. 


E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C45022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD.’A2 3E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD72C6A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 




2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the 
format Al-dddd. For this implementation, the following tests were 
inapplicable for the reasons indicated; references to Ada Issues 
are included as appropriate. 

The following 327 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 

C24113C..Y (23 tests) C35705C..Y (23 tests) 

C35706C..Y (23 tests) C35707C..Y (23 tests) 

C35708C..Y (23 tests) C35802C..Z (24 tests) 

2-1 




C45241C..Y (2J tests) C45321C..Y (23 tests) 

C45421C..Y (23 tests) C45521C..Z (24 tescs) 

C45524C..Z (24 tests) C45621C..Z (24 tests) 

C45641C..Y (23 tests) C46012C..Z (24 tests) 

C35713B, C45423B, B86001T, and C86006H check for the predefined 

type SHORT_FLOAT; for this implementation, there is no such type. 

The following 21 tests check for the predefined type SHORT_INTEGER; 
for this implementation, there is no such type: 

C35404B B36105C C45231B C45304B C45411B 

C45412B C45502B C45503B C45504B C45504E 

C45611B C45613B C45614B C45631B C45632B 

B52004E C55B0;B B55B09D B86001V C86006D 

CD7101E 

C35404D, C45231D, B36001X, C8' 006E, and CD7101G check for a 
predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INT£GER; for this implementation, there is 
no such type. 

C35713C, B86001U, and C86006G check for the predefined type 
LONG_FLOAT; for this implementation, there is no such type. 

C35713D and BS6001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
im.plementation, there is no such type. 

C45531M..P and C45532M..P I”8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, there is no such type. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types; for this 
implementation, MACHINE_OVERFLOWS is TRUE. 

D64005G uses 17 levels of recursive procedure ca■Is nesting; this 
test exceeds the linkable size of 128KBytes. 

B86001Y uses the name of a predefined fixed-point type other than 
DURATION; for this implementation, there is no such type. 

CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 


2-2 





AE2101C and EE2201D..E (2 tests) use instantiations of package 

SEQUENTIAL_IO with unconstrained array types and record types with 
discriminants without defaults; these instantiations are rejected 
by this compiler. 

AE2101H, EE2401D, and EE2401G use instantiations of package 

DIRECT_IO with unconstrained array types and record types with 
discriminants without defaults; these instantiations are rejected 
by this compiler. 

The tests listed in the following table are not applicable because 
the given file operations are supported for the given combination 
of mode and file access method. 

Test File Operation Mode File Access Method 

CE2102E CREATE OUT_FILE SEOUENTIAL_IO 

CE2102N OPEN IN_FILE SEQUENTIAL_IO 

CE21020 RESET IN_FILE SEQUENTIAL_IO 

CE2102P OPEN OUT_FILE SEQUENTIAL_IO 

CE2102Q RESET OUT_FILE SEQUENTIAL_IO 

CE21C5A CREATE IN_FILE SEQUENTIAL_IO 

CE3102F RESET Any Mode TEXT_IO 

CE3102G DELETE - TEXT_IO 

CE3102I CREATE OUT_FILE TEXT_IO 

CE3102J OPEN IN_FILE TEXT_IO 

CE3102K OPEN OUT_FILE TEXT_IO 

CE3109A CREATE INOUT_FILE TEXT_IO 

The following 56 tests check operations on direct files; this 
implementation does not support direct files. 

CE2102B CE2102H CE2102K CE2102R..W 

CE2102Y CE2103D CE2104C..D CE2105B 

CE2106B CE2107E..H CE2107L CE2108C..D 

CE2108G..H CE2109B CE2110C..D CE2111B 

CE2111E CE2111G..H CE2115A CE2120A 

CE2401A..B CE2401C CE2401E..F CE2401H..L 

CE2404A..B CE2405B CE2406A CE2407A..B 

CE2408A..B CE2409A..B CE2410A.,B CE2411A 

The following 12 tests check operations on sequential and text 
files when multiple internal files are associated with the same 
external file; USE_ERROR is raised when this association is 
attempted. 

CE2107A..D CE2110B CE2111D 

CE3111A..B CE3111D..E CE3114B CEl^llSA 


2-3 









CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot 
restrict file capacity. 

CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise 
USE_ERROR if they specify an inappropriate value for the external 
file; there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the 
page number exceeds COUNT'LAST. For this implementation, the value 
of COUNT'LAST is greater than 150000 making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 


Modifications (see section 1.3) were required for 45 tests. 


The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B33201C 

B38003A 

B54A01L 

BS7103E 

BC1109D 

BC1201L 


B22004A 

B33202C 

B38003B 

B55A01A 

BB1006B 

BC1201F 

BC3013A 


B23004A 

B33203C 

B38009A 

B61005A 

BC1102A 

BC1201G 

BE2210A 


B24005A 

B33301B 

B38009B 

B85008G 

BC1109A 

BC1201H 

BE2413A 


B24005B 

B37106A 

B44001A 

B85008H 

BC1109B 

BC1201I 


B28003A 

B37301I 

B44004A 

B95063A 

BC1109C 

BC1201J 


CS3030C and CS6007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAM_ERROR. 


C34005P and C34005S were graded passed by Test Modification as 
directed by the AVO. These tests contain expressions of the form 
"I - X'FIRST + Y'FIRST", where X and Y are of an array type with a 
lower bound of INTEGER'FIRST; this implementation recognizes that 
"X'FIRST + Y'FIRST" is a loop invariant and so evaluates this part 
of the expression separately, which raises NUMERIC_ERROR. These 
tests were m.odified by inserting parens to force a different order 
of evaluation (i.p., to force the subtraction to be evaluated 
first) at lines 137 and 262/263, respectively; those modified lines 


2-4 




are: 


[C34005P, line ]S7] 

IF NOT EQUAL (X (I), Y ((I - X’FIRST) + Y'FIRST)) THEN 

[C34005S, lines 261..4 (only 262 & 263 were modified)] 

IF NOT EQUAL (X (I, J), 

Y ((I - X'FIRST) + Y'FIRST, 

(J - X'FIRST(2)) + 

Y'FIRST(2))) THEN 

CE3413B was graded inapplicable by Evaluation Modification as 
directed by the AVO. This test attempts to output COUNT'LAST*1 
pages and then check that invoking PAGE raises LAYOUT_ERROR. This 
implementation's output device is a USH-26 tape device, and a 
standard tape will hold only approximately 1860 page delimiters; 
thus, DEVICE_ERROR is raised when that limit is exceeded —well 
before COUNT'LAST pages have been output. During validation 
testing, a modified version of the test was processed that placed 
the call to NEW_PAGE at line 54 within a block with a handler for 
DEVICE_ERROR, to confinri which exception was raised. 

For this test, the particular TModifications are: 

Line 21 

replace: INCOMPLETE, INAPPLICABLE : EXCEPTION; 

with : INCOMPLETE, INAPPLICABLE, DEVICE_ERROR_NA : EXCEPTION; 
Line 54 

replace: NEW_PAGE (FILE); 
with; 

BEGIN 

NEW_PAGE (FILE); 

EXCEPTION 

when TEXT_IO.DEVICE_ERROR => 

REPORT.COMMENT("TEXT_IO.DEVICE_ERROR RAISED ON NEW_PAGE 
ATTEMPT NUMBER " & integer'image(integer(I))) ; 

RAISE DEVICE_ERROR_NA; 
end; 

Add at line 131 in the main program exception handler after the 
handler for INAPPLICABLE : 

when DEVICE_ERROR_NA => 

NOT_APPLICABLE ("THE VALUE OF COUNT'LAST IS GREATER " & 

"THAN THIS STORAGE DEVICE CAN HANDLE. " & 

"THE CHECKING OF THIS " & 

"OBJECTIVE IS IMPRACTICAL FOR THIS I/O DEVICE"); 


2-5 







CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial 
pages of this report. 

For a point of contact for technical information about this 
Ada implementation system, see: 

Mr. Christopher T. Geyer 

Fleet Combat Directions Systems Support Activity 
Code 81, Room 30ID 
200 Catalina Blvd. 

San Diego, California 92147 
619-553-9447 


For a point of contact for sales information about this Ada 
implementation system, see: 

NOT APPLICABLE FOR THIS IMPLEMENTATION 

Testing of this Ada implementation was conducted at the 
customer's site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Applicable Tests 3606 

b) Total Number of Withdrawn Tests 94 

c) Processed Inapplicable Tests 470 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


3-1 






f) Total Number of Inapplicable Tests 470 

g) Total Number of Tests for ACVC l.ii 4170 


(c+d^e) 
(a+b»f) 


When this implementation was tested, the tests listed in section 
2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this 
compiler was tested, the tests listed in section 2.1 had been 
withdrawn because of test errors. The AVF determined that 470 
tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing. 
In addition, the modified tests mentioned in section 2.3 were 
also processed. 

A magnetic tape containing the customized test suite (see 
section 1.3) was taken on-site by the validation team for 
processing. The contents of the magnetic tape were loaded 
directly onto the host computer. 

After the test files were loaded onto the host computer, the 
full set of tests was processed by the Ada implementation. 

The tests were compiled and linked on the host computer system 
and executed on the target computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B 
for a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this 
test were: 


FOR /OPTIMIZE the options were: 

/SUMMARY /OPTIMIZE /SOURCE /EMR /OUT=<filename> 

The options invoked by default for validation testing during 
this test were: 


FOR /OPTIMIZE the options were: 

N0_MACHINE_C0DE NO_ATTRIBUTE NO_CROSS_REFERENCE 

NO DIAGNOSTICS NO NOTES PRIVATE LIST CONTAINER_GENERATION 


3-2 





CODE_ON_WARNING NO_MEASURE DEBUG CHECKS NO_EXECUTIVE 
NO_RTE_ONLY TRACE_BACK 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. Selected 
listings examined on-site by the validation team wr -e also 
archived. 


3-3 




APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for 
customizing the ACVC. The meaning and purpose of these 
parameters are explained in [UG89]. The parameter values are 
presented in two tables. The first table lists the values 
that are defined in terms of the maximum input-line length, 
which is I the value for $MAX_IN_LEN—also listed here. 
These values are expressed here as Ada string aggregates, 
where "V" represents the maximum input-line length. 

Macro Parameter Macro Value 


$MAX IN LEN 120 


$BIG_ID1 

(1..V-1 => 'A', V => 

•1') 


$BIG_ID2 

< 

1 

(-> 

II 

V 

> 

< 

II 

V 

'2 ' ) 


$DIG_ID3 

(1..V/2 => 'A') & ' 3 ' 

& (1..V-l-V/2 => 

'A' ) 

$BIG_ID4 

(1..V/2 => 'A* ) & '4 ' 

& (1..V-l-V/2 => 

'A' ) 


$BIG_INT_LIT (1..V-3 => *0') & "298" 


$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 "" & (1..V/2 => 'A') & "" 

$BIG_STRING2 "" & (1..V-1-V/2 => 'A') & & "" 

$BLANKS (l,.V-20 => ' ' ) 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MAX_STRING_LITERAL "" & (1..V-2 => 'A') & "" 


A-1 







The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 



A-2 





SILLEGAL EXTERNAL FILE NAMEl BAD-CHARS"«.%!X@*()*&'%$=@!@ 


$ILLEGAL_EXTERNAL_FILE_NAME2 

$INAPPROPRIATE_LINE_LENGTH -1 

$INAPPROPRIATE_PAGE_LENGTH -1 

$INCLUDE_PRAGMA1 
$INCLUDE_PRAGMA2 
$INTEGER_FIRST 
$INTEGER_LAST 
$INTEGER_LAST_PLUS_1 
$INTERFACE_LANGUAGE 
$ LES S_THAN_DURATION 
$LESS_THAN_DURATION_BASE_FIRST 
$LINE_TERMINATOR 
$LOW_PRIORITY 
$MACHINE_CODE_STATEMENT 
$MACHINE_CODE_TYPE 
$MANTISSA_DOC 
$MAX_DIGITS 
$MAX_INT 
$MAX_INT_PLUS_1 
$MIN_INT 
$NAME 

$NAME_LIST 

$NAME_SPECIFICATIONl 
$NAME SPECIFICATION2 


ANOTHER_BAD- 

CHARS'#.%!X@*() 


PRAGMA INCLUDE ("A28006D1.TST") 
PRAGMA INCLUDE ( "B28006F1. TST" ) 
-32768 
32767 
32_76S 

MACRO_NORMAL 

-131071.5 

-131073.0 
ASCII.LF 
0 

instr'(Ir, rO,rO) 
instr 
31 
6 

2147483647 

2147483648 

-2147483648 

NO_SUCH_INTEGER_TYPE 

ANUYK44,ANAYK14 

X2120A 

X2120B 


A-3 





$NAME_SPECIFICATI0N3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

$TICK 

$VARIABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLE_ADDRESS2 
$YOUR PRAGMA 


X3119A 

16#FFFFFFFE? 

65_536 

16 

ANAYK14 
ASCII.FF 

RECORD value : signed_byte; END 
RECORD; 

signed_byte_value 

32 

2048 

0.00003125 

16#0020# 

16#0021# 

16#0023# 

EXECUTIVE 


A-4 




APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to compiler 
documentation and not to this report. 


B-1 





Version 3.5 
29 March 1991 


Ada/M PSE HandbooK 


Option 

Function 

EXECUTIVE 

Enables pragma EXECUTIVE and allows 
visibility to units which have been 
compiled with the RTE ONLY ootion. 
Default: NO_EXECUTIVE 

MEASURE 

Generates code to monitor execution 
frequency at the subprogram level for 
the current unit. Default: NO MEASURE 

NO_CHECKS 

NO_CHECKS suppresses all run-time 
error checking. CHECKS provides 
run-time error checking. 

Default: CHECKS 

NO_CODE_ON 

_WARNING 

NO_CODE_ON_WARNING means no code is 
generated when there is a diagnostic 
of severity WARNING or higher. 
CODE_ON_WARNING generates code 
only if there are no diagnostics 
of a severity higher than WARNING. 
Default: CODE_ON_WARNING 

NO CONTAINER GENERATION 

NO_CONTAINER_GENERATION means that no 
container is~produced even if there 
are no diagnostics. 

CONTAINER_GENERATION produces a 
container if diagnostic serverity 
permits. 

Default: C0NTAINER_GENERATI0N 


Table F-4a - Special Processing Options 


F-56 


F.14 


Compiler Options 











Ada/M PSE Handbook 


Version 3.5 
29 Marcn 1991 


Option 

Function 

i 

1 

1 NO_DEBUG 

If NO DEBUG is specified, only that 
information needed to link, export 
and execute the current unit is 
included in the compiler output. 


With the DEBUG option in effect, 
internal representations and 
additional symbolic information are 
stored in the container. 

Default: DEBUG 

1 NO_TRACE_BACK 

Disables the location of source 
exceptions that are not handled by 
built-in exception handlers. 
Default: TRACE_BACK 

1 OPTIMIZE 

Enables global optimizations in 
accordance with the optimization 
pragmas specified in the source 
program. If the pragma OPTIMIZE is 
not included, the optimizations 
emphasize TIME over SPACE. 

When NO_OPTIMIZE is in effect, no 
global optimizations are performed, 
regardless of the pragmas specified 
Default: NO_OPTIMIZE 

1 RTE_ONLY 

Restricts visibility of this unit 
only to those units compiled with 
the EXECUTIVE option. 

Default: NO_RTE_ONLY 


Table F-5b 


Special 


Processing Options 


(Continued) 


F.14 Compiler Options 


F-57 









Version 3.5 
29 March 1991 


Ada/M ?SE Kandoccx 


1 Option Function 


I ATTRIBUTE Produces a Symbol Attribute Listing. 

! (Produces an attribute cross-reference 

! listing when both ATTRIBUTE and 

i CROSS_REFERENCE are specified.) 

I Default: NO ATTRIBUTE. 

I 

i CROSS_REFERENCE Produces a Cross-Reference Listing. 

! (Produces an attributj cross-reference 

i listing when botn ATTRIBUTE and 

i CROSS_REFERENCE are specified.) 

I Default: NO CROSS REFERENCE. 

I 

! DIAGNOSTICS Produces a Diagnostic Summary Listing. j 

I Default: NO_DIAGNOSTICS. i 

I i 

1 MACHINE_CODE Produces a Machine Code Listing if i 

code is generated. Code is generated i 

i when CONTAINER_GENERATION option is 1 

! in effect and (1) there are no i 

1 diagnostics of severity ERROR, SYSTEM, | 

or FATAL, and/or (2) NO_CODE_ON_WARNING i 
i option is in effect and there are no ! 

I diagnostics of severity higher than 

1 NOTE. A diagnostic of severity NOTE I 

I is reported when a Machine Code i 

I Listing is requested and no code is I 

! generated. OCTAL is an additional ! 

option that may be used with I 

MACHINE_CODE to output ocatal values I 

i on the listing instead of hex values. i 

Default: NO_MACHINE_CODE. ! 

1 i 

I NOTES Includes diagnostics of NOTE severity I 

I level in the Source Listing. I 

i Default: NO NOTES. i 

I ■ I 

i SOURCE Produces listing of Ada source ! 

I statements. Default: NO SOURCE. 1 

1 " I 

i SUMMARY Produces a Summary Listing; always I 

I produced when there are errors in the I 

I compilation. Default: NO_SUMMARY. I 


Table F-6 - Ada/M Listing Control Options 


F-58 


F.14 Compiler Options 








Ada/M PSE Handbook 


Version 3.5 
29 March 1991 


Option 

Function 

MSG 

Sends error messages and tne 

Diagnostic Summary listing to t.he 
file specified. The default is to 
send error messages and the Diagnostic 
Summary Listing to .Message Output 
(usually the terminal). 

OUT 

Sends all selected listings to a 
single file specified. The default 
is to send listings to Standard 

Output (ususally the terminal). 


Table F-7 - Con..rol_?art: (Redirection) Options 


F,14 Compiler Options 







LINKER OPTIONS 


The linker options of this Ada implementation, as described in thi 
Appendix, are provided by the customer. Unless specifically note 
otherwise, references in this appendix are to linker documentaticr. 
and not to this report. 


B-2 


il. If) 


Version 3.5 
29 March 1991 


Ada/M PSE HandbcoK 


F.16 Linker Options 


1 option 

Function 

DEBUG 

1 

Produces a linked container to be 
debugged. Default: NO DEBUG. 

! LOAD 

Deferred. 

i MEASURE 

1 

Produces a linked container to be 
analyzed. Default: NO_MEASURE. 1 

NO 10 SUBSYSTEM 

1 ~ ~ 

1 

Does not automatically pull in Ada/M ! 
predefined 10 subsystem phases i 
SYSTEM 10 1 and SYSTEM 10 2 . | 
Default: IO_SUBSYSTEM. | 

1 

i 

! PARTIAL 

j 

1 

I 

Produces an incomplete linked I 
container with unresolved | 
references. Default: NO_PARTIAL. 1 

1 

1 RTL SELECTIVE 

1 

1 

1 

1 

1 

1 

Similar to the SELECTIVE option 1 

except that it only refers to RTLIB ! 

units. This option is not supported 1 

during phase links. ! 

Default: NO RTL SELECTIVE. 1 

~ ~ 1 

SEARCH 

! 

t 

1 

i 

1 

1 

Explicitly searches for the units to 1 
be included in the linked container. 1 

Default: SEARCH for final links; 1 

NO SEARCH for phase links. i 

~ 1 

1 

i SELECTIVE 

I 

1 

1 

! 

Maps into the program only the 1 
subprograms called by the main 1 
subprogram. Default: SELECTIVE for I 
final links; NO_SELECTIVE for phase 1 
links. 1 

! 


Table F-10 - Ada/M Linker Special Processing Options 


F-62 


F.16 Linker Options 









Ada/M PSE Handbook 


Version 3.5 
29 March 1991 


Option 

Function 

No option 

Linker summary listing always 
produced. 

DE3UGMAP 

Deferred. 

ELA3_LIST 

Generates an elaboration order 
listing. Default: NO ELAB LIST. 

LOADMAP 

Generates a loadmap listing. 

Default: NO_LOADMAP. 

LOCAL_SYMBOLS 

Generates a symbols listing with , 

all internal as well as external I 

definitions in the program. 
LOCAL_SYMBOLS is to be used in ! 

conjunction with the SYMBOLS 
option. If LOCAL SYMBOLS is 1 

specified with NO_SYMBOLS, a 

WARNING is produced and the SYMBOLS 1 
option is activated. | 

Default: NO_LOCAL_SYMBOLS 

SYMBOLS 

i 

Produces a Linker symbols listing. 
Default: NO_SYMBOLS. 

UNITS 

Produces a Linker units listing. 1 

Default: NO_UNITS. 


Table F-11 - Linker Listings Options 


F.16 Linker Options 


F-63 








Version 3.5 

29 March 1991 

Ada/M PSE 

HandbooK 

1 Option 

Function 


1 

1 

1 

1 MSG 

1 

1 

i 

1 

Sends error messages to the file 
specified. The default is to send 
error messages to Message Output 
(usually the terminal). 

1 

1 

! 

1 

1 OUT 

1 

1 

1 

1 

+ - 

Sends all selected listings to the 
single file specified. The defaul 
is to send listings to Standard 
Output (usually the terminal). 

1 

! 


Table F-12 - Control Part (Redirection) Options 


F-64 


F.16 Linker Options 







Ada/M 

PSE Handbook 

Version 3. 
29 March 199 

F.17 

Exporter Options 

1 

Option 

Function 

( 

1 

1 

Ai fvx 4 

Generate image for the AN/AiK-14. 

Default: UYK44. 

1 

i 

1 

I 

1 

1 

DEBUG 

Permits the generation of a load module 
with ail debugging facilities available. 

When NO DEBUG is in effect, no debugging 
facilities are made available. i 

Default: NO_DEBUG. 

1 

1 

I 

DYNAMIC 

Deferred. i 

1 

1 

i 

1 

LOAD 

Deferred. 1 

i 

1 

1 

1 

1 

1 

1 

1 

1 

MEASURE 

Permits the generation of a load module ' 
with all performance measurement ! 
facilities available. When NO_MEASURE 1 
is in effect, no performance measurement 1 
facilities are made available. ! 
Default: NO MEASURE. ! 

” i 

1 

1 

1 

1 

NO_UYK44 

Generate image for the AN/AYK-14. i 

Default: UYK44. 1 

1 


Table F- 

13 - Ada/M Special Processing Options 


F.17 Exporter Options 


F-65 











Version 3.5 

29 March 1991 

Ada/M PSE HandbocK 

1 Option 

Function 

1 

1 MSG 

1 

! 

1 

! 

Sends error messages to the file 
specified. The default is to send 
error messages to Message Output 
(usually the terminal). 

1 

1 OUT 

1 

I 

1 

+ - 

Sends all selected listings to the 
single file specified. The default 
is to send listings to Standard 

Output (usually the terminal). 


Table F-14 - Control_Part (Redirection) Options 


F-66 


F.17 Exporter Options 









Ada/M PSE Handbook 


Vers:.on 3. 
29 March 199 


Option 

Function j 

DEBUGMAP 

Deferred 

LOADMAP 

Produces an Exporter Loadmap 

Listing. This listing shows the 
location of each program section for 
each phase. Default: NO_LOADMAP. 

LOCAL_SYMBOLS 

Includes names local to library 
package bodies in the Exporter 

Symbol Definition Listing, if 
produced. This option has no effect ! 

if NO SYMBOLS is in effect. i 

Default: NO_LOCAL_SYMBOLS 
(include only names | 

which are externally visible). i 

1 

RTEXEC 

Produces executive listings instead ! 

of user application listings. It can 1 
only be used with the /LOADMAP I 

option, i.e., /LOADMAP/RTEXEC. 1 

Default: NO RTEXEC. j 

~ 1 

SYMBOLS 

Produces an Exporter Symbol i 

Definition Listing. This listing 
shows the virtual and physical 
locations of the symbols in memory 1 

for each virtual memory phase. 1 

Default: NO_SYMBOLS. ! 

UNITS 

i 

Produces an Exporter Units Listing. I 

Default: NO UNITS. 1 

1 


Table F-15 - Ada/M Exporter Listing Options 


F.17 Exporter Options 


F-6 









APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type INTEGER is range -32_768 .. 32_767; 

type FLOAT is digits 6 range 

-(16sO.FF_FFF8#E63) .. (16#0.FF_FFF8#E63); 

type LONG_FLOAT is digits 15 range 

-(16«0.FF_FFFF_FFFF_FFE0#E63) .. (16#0.FF_FFFF_FFFF_FFE0#E63); 

type DURATION is delta 2.0 ** (-14) range 
-131_071.0 .. 13]_071.0; 

end STANDARD; 


C-1 



Ada/M PSE HandbooK 


V e r s . c r. 2.3 
29 Marcn 1951 


Appendix F 

The Ada Language for the AN/UYK-44 and AN/AyK-14 Targets 


The source language accepted by the compiler is Ada, as 
described in the Military Standard, Ada Programming Language, 
ANSI/MIL-STD-1815A-1983, 17 February 1983 ("Ada Language 
Reference Manual"). 

The Ada definition permits certain implementation 
dependencies. Each Ada implementation is required to supply a 
complete description of its dependencies, to be thought of as 
Appendix F to the Ada Language Reference Manual. This section is 
that description for the AN/uyK-44 and AN/AyK-14 targets. 


F.l Options 

There are several compiler options provided by all ALS/N 
compilers that directly affect the pragmas defined in the Ada 
Language Reference Manual. These compiler options currently 
include the CHECKS and OPTIMIZE options which affect the SCPPRESS 
and OPTIMIZE pragmas, respectively. A complete list of ALS/N 
compiler options can be found in Section 9. 

The CHECKS option enables all run-time error checking for tne 
source file being compiled, which can contain one or more 
compilation units. This allows the SUPPRESS pragma to be used in 
suppressing the run-time checks discussed in the Ada Language 
Reference Manual, but note that the SUPPRESS pragma(s) must be 
applied to each compilation unit. The NO_CHECKS option disables 
all run-time error checking for all compilation units within the 
source file and is equivalent to SUPPRESSing all run-time checks 
within every compilation unit. 

The OPTIMIZE option enables all compile-time optimizations 
for the source file being compiled, which can contain one or more 
compilation units. This allows the OPTIMIZE pragma to request 
either TIME-oriented or SPACE-oriented optimizations be 
performed, but note that the OPTIMIZE pragma must be applied to 
each compilation unit. If the OPTIMIZE pragma is not present, 
the ALS/N compiler's Global Optimizer tends to optimize for TIME 
over SPACE. The NO_OPTIMIZE option disables all compile-time 
optimizations for all compilation units within the source file 
regardless of whether or not the OPTIMIZE pragma is present. 

In addition to those compiler options normally provided by 
the ALS/N Common Ada Baseline compilers, the Ada/M compiler also 
implements the EXECUTIVE, DEBUG, and MEASURE options. 


F.l Options 


F-01 






r 


r*ar.cocc< 


29 March 1991 


The EXECUTIVE compiler option enables processing of PRAGMA 
EXECUTIVE and allows WITH of units compiled with the RTE_ONLY 
option. IF NONEXECUTIVE is specified on the command line, the 
pragma will be ignored and will have no effect on the generated 
code. 

The DE3UG compiler option enables processing of PRAGMA DE3UG 
to provide debugging support. If NO_D£3UG is specified, the 
DE3UG pragmas shall have no effect. Program units containing 
DE3UG pragmas and compiled with the DE3UG compiler option may be 
linKed with program units containing DEBUG pragmas and compiled 
with the NO_DE3UG option; only those program units compiled with 
the DEBUG option shall have additional DEBUG support. 

The MEASURE compiler option enables run-time calls to 
Run-Time Performance Measurement Aids (RTAids) to record the 
entrance into all subprograms whose bodies are in the 
compilation. Program units compiled with the MEASURE option may 
be linked with program units not compiled with the MEASURE 
option; at run-time, only those subprograms in program units 
compiled with the MEASURE option shall have this additional 
MEASURE support. 


F-02 


F.l 


Options 





F.2 Pragmas 

Both implementation-defined and Ada language-defined pragr^as 
are provided by all ALS/N compilers. These paragraphs descrice 
the pragmas recognized and processed by the Ada/M compiler. Tr.e 
syntax defined in Section 2.8 of the Ada Language Reference 
Manual allows pragmas as the only element in a compilation, 
before a compilation unit, at defined places within a compilation 
unit, or following a compilation unit. Ada/M associates pragmas 
with compilation units as follows: 

a. If a pragma appears before any compilation unit in a 
compilation, it will affect all following compilation units, 
as specified below and in Section 10.1 of the Ada Language 
Reference Manual. 

b. If a pragma appears inside a compilation unit, it will be 
associated with that compilation unit, and with the listings 
associated with that compilation unit, as described in the" 
Ada Language Reference Manual, or below. 

c. If a pragma follows a compilation unit, it will be associatec 
with the preceding compilation unit, and effects of the 
pragma will be found in the container of that compilation 
unit and in the listings associated with that container. 

The pragmas MEMORy_SIZE, STORAGE_UNIT , and sySTEM_NAME are 
described in Section 13.7 of the Ada”Language Reference Manual. 
They may appear only at the start of the first compilation when 
creating a program library. In the ALS/N, however, since progra.m 
libraries are created by the Program Library Manager and not by 
the compiler, the use of these pragmas is obviated. If they 
appear anywhere, a diagnostic of severity level WARNING is 
generated. 


F.2 Pragmas 


."-0 3 






"•a 




29 March 1991 


F.2.1 Language-Defined Pragmas 

The following notes specify implementation-specific changes 
to those pragmas described in Appendix B of the Ada Language 
Reference Manual. Unmentioned pragmas are implemented as defined 
in the Ada Language Reference Manual. 

pragma INLINE (arg {,arg}); 

The arguments designate subprograms. There are three 
instances in which the INLINE pragma is ignored. Eacn 
of these cases produces a warning message which states 
that the INLINE did not occur. 

a. If the compilation unit containing the INLINEd 
subprogram depends on the compilation unit of its 
caller, a routine call is made instead. 

b. If the INLINEd subprogram's compilation unit 
depends on the compilation unit of its caller (a 
routine call is made instead). 

c. If an immediately recursive subprogram call is made 
within the body of the INLINEd subprogram (the 
pragma INLINE is ignored entirely). 

pragma INTERFACE (language_name, subprogram_name); 

The language_name specifies the language and type of 
interface to be used in calls used to the externally 
supplied subprogram specified by subprogram_name. The 
only value allowed for the first argument (language 
name) is MACRO_NORMAL. MACRO_NORMAL indicates that 
parameters will be passed on the stack and the calling 
conventions used for normal Ada subprogram calls will 
apply. 

You must ensure that an assembly-language body 
container will exist in the program library before 
linking. 


F-04 


F.2.1 


Language-Defined Pragmas 





Aaa, M ?S£ nar.GoccfC 


V e r 5 1 G 
2 9 Marcr. 


pragma OPTIMIZE (arg); 

The argument is either TIME or SPACE. If TIME is 
specified, the optimizer cohcentrates on optimizing 
code execution time. If SPACE is specified, tne 
optimizer concentrates on optimizing code size. The 
default is If tne OPTIMIZE option is enaoled and pragma 
OPTI.MIZE is not present, global optimization is still 
performed with the default argument, SPACE. Progra.m 
units containing OPTIMIZE pragmas and compiled wirh tne 
OPTIMIZE option may be linked with program units 
containing OPTIMIZE pragmas and compiled with the 
NO_OPTIMIZE option; but only chose program units 
compiled with the OPTIMIZE option will have glooal 
optimization support. SPACE. 

pragma PRIORITY (arg); 

The argument is an integer static expression in the 
range 0..15, where 0 is the lowest user-specifiable 
task priority and 15 ^s the highest. If the value of 
the argument is out of range, the pragma will have no 
effect other than to generate a WARNING diagnostic. A 
value of zero will be used if priority is not defined. 
The pragma will have no effect when not specified in a 
task (type) specification or the outermost declarative 
part of a subprogram. If the pragma appears in the 
declarative part of a subprogram, it will have no 
effect unless that subprogram is designated as the main 
subprogram at link time. 

pragma SUPPRESS (arg {,arg}); 

This pragma is unchanged with the follc.wing exceptions: 

Suppression of OVERFLOW_CHECK applies only to integer 
operations; and PRAGMA SUPPRESS has effect only within 
the compilation unit in which it appears, except that 
suppression of ELABORATION^CHECK applied at the 
declaration of a subprogram or task unit applies to all 
calls or activations. 


F.2.i Language-Defined Pragmas 







co< 


Vers ion 3 . 5 
29 Marcn 1991 



P.2.2 Implcaientation-Defined Pragmas 

This paragraph describes the use and meaning of those pragmas: 

recognized by Ada/M which are not specified in Appendix 3 of me 

Ada Language* Reference Manual. 

pragma DEBUG; 

This pragma enables rhe inclusion of full symbolic 
information and support for the Embedded Target 
Deougger. The DEBUG PRAGMA is enabled by the DEBUG 
command line option and has no effect if this option is 
not provided. This pragma muse appear within a' 
compilation unit, before the first declaration or 
statement. 

pragma EXECUTIVE > (arg)]; 

This pragma allows you to specify that a compilation 
unit IS to run in the executive state of the machine 
and/or u'-ilize privileged instructions. The pragma has 
no effect if the compiler option NO_EXECUTIVE is 
enaoled, either explicitly or by default. 

If PRAGMA EXECUTIVE is specified without an argument, 
executive state is in effect for the compilation unit 
and the code generator does not generate privileged 
instructions for the compilation unit. If PRAGMA 
EXECUTIVE (INHERIT) is specified, a subprogram in the 
compilation unit inherits tne state of its caller and 
the code generator does not generate privileged 
instructions for the compilation unit. If PRAGMA 
EXECUTIVE (PRIVILEGED) is specified, the executive 
state is in effect and the code generator may generate 
privileged instructions for the compilation unit. In 
the absence of PRAGM.' EXECUTIVE, the compilation unit 
executes in task state and the code generator does not 
generate privileged instructions. 

PRAGMA EXECUTIVE is applied once per compilation unit, 
so its scope is the entire compilation unit. PRAGMA 
EXECUTIVE may appear between the context clause and the 
outermost unit. If there s no context clause, PRAGMA 
EXECUTIVE must appear within t.hat unit before the first 
declaration or statement. The placement of the pragma 
before the context clause has no effect on any or all 
following compilation units. If PRAGMA EXECUTIVE 
appears in the specification of a compilation unit, it 
must also appear in the body of that unit, and vice 
versa. If the pragma appears in a specification but is 
absent from the body, you are warned and the pragma is 
effective. If the pragma appetrs in the body of a 
compilation unit, but is absent from the corresponding 


F-06 


F.2.2 Implementation-Defined Pragmas 





Aaa/ M r'5- ."a.-.CuGCK 

<ers-cr. ,.3 
29 Marcr. .591 


specification, you are warned and the pragma has no 
effect. PRAGMA EXECUTIVE does not propagate to 
subunits. If a subunic is compiled without PRAGMA 
EXECUTIVE and the parent of the subunic is compiled 
with PRAGMA EXECUTIVE, you are warned and PRAGMA 
EXECUTIVE has no effect on the subunit. 

pragma EAST_IN’TERRUPT_ENTRY (entry_name, IMMEDIATE); 

This pragma provides for situations of high interrupt 
rates with simple processing per interrupt, (such as 
adding data to a buffer), and where complex processing 
occurs only after large numbers of these interrupts, 
(such as when the buffer is full). This allows for 
lower overhead and faster response capability by 
restricting you to disciplines that are commensurate 
with limitations normally found in machine level 
interrupt service routine processing. 

pragma MEASURE (extraction_set, [arg {,arg}]); 

This pragma enables one or more performance measurement 
features. Pragma MEASURE specifies a user-defined 
extraction set for the Run-Time Performance Measurement 
Aids and Embedded Target Profiler. The user-defined 
extraction set consists of all occurences pragma 
MEASURE throughout the program. Extraction_set is a 
numeric literal, which is an index into a user-supplied 
table. Arg is a variable or a list of variables whose 
values are reported at this point in the execution. 
These values describe the nature (TYPE) of the values 
collected to an independent data reduction program. 
Pragma MEASURE is enabled by the MEASURE command line 
option and has no effect if this option is not 
provided. This pragm.' should be applied to a package 
body rather than a package specification. 

pragma STATIC (INTERRUPT_HANDLER_TASK); 

The pragma STATIC is only allowed immediately after the 
declaration of a task body containing an immediate 
interrupt entry. The argument is 

INTERRUPT_HANDLER__TASK. The effect of this pragma will 
be to allow generation of nonreentrant and nonrecursive 
code in a compilation unit, and to allow static 
allocation of all data in a compilation unit. This 
pragma shall be used to allow for procedures within 
immediate (fast) interrupt entries. The effect will be 
for the compiler to generate nonreentrant code for the 
affected procedure bodies. If a STATIC procedure is 
called recursively, the program is erroneous. 


F.2.2 Implementation-Defined Pragmas 








w a / r 


no 


29 March 1991 


r." c i _ ■<. 


pragma TICK (arg); 

This is a system configuration pragma. It tatces a 
single argument of type universal_real, which specifies 
cne value of the named number SYSTEM.TIi'K. This pragma 
may appear only at the start of the first compilation 
when creating a program library. If this pragma 
appears elsewhere, a diagnostic of severity WARNING is 
generated. 

pragma TITLE (arg); 

This is a listing control pragma. It takes a single 
argument of type string. The string specified will 
appear on the second line of each page of the source 
listing produced for the compilation unit within which 
It appears. The pragma should be the first lexical 
unit to appear within a compilation unit (excluding 
comments). If it is not, a warning message is issued. 

pragma TRIVIAL_ENTRY (NAME: entry_simple_name); 

This pragma is only allowed within a task specification 
after an entry declaration and identifies a 
Trivial_Entry to the system. A trivial entry 
represents a synchronization point, contained in a 
normal Ada task, for rendezvous with a fast interrupt 
entry body. The body of a trivial entry must be null. 

pragma UNMAPPED (arg {,arg}); 

The effect of this pragma is for unmapped (i.e., not 
consistently mapped within the virtual space) 
allocation of data in a compilation unit. The 
arguments of this pragma are access types to be 
unmapped. If a program tries to allocate more UNMAPPED 
soace than is available in the physical configuration, 
STORAGE ERROR will be raised at run-time. PRAGMA 
UNMAPPED must appear in the same declarative region as 
the type and after the type declaration. 


F-08 


F.2.2 


mplementation-Defined Pragmas 



Aca/M rai 


-OCOK 


'cia.wT. J..3 

29 Marcr. 199 1 

F.2.3 Scope of Pragmas 

The scope for each pragma previously described as differir.a 

from the Ada Language Reference Manual is given below. 

0E5UG Applies to tne compilation unit in wnich the ora'^ma 

appears. ‘ ’ 

EXECUTIVE Applies to the compilation unit in whicn the oraoma 
appears, i.e., to all subprograms and tas<s wltr.ir. 
the unit. Elaboration code is not affected. The 
pragma is not propagated from specifications to 
bodies, or from bodies to subunits. The oracma 
must appear consistently in the specification, 
body, and subunits associated with a library unit. 

FAST_INTERRUPT_ENTRY 

Applies to the compilation unit in which the pragma 
appears. 

INLINE Applies only to subprograms named in its 

arguments. If the argument is an overloaded 
subprogram name, the INLINE pragma applies to 
all definitions of that subprogram name which 
appear in the same declarative part as the 
INLINE pragma. 

INTERFACE Applies to all invocations of the named 
imported subprogram. 

MEASURE No scope, but a WARNING diagnostic is 

generated. 

MEMORY_SIZE No scope, but a WARNING diagnostic is 
generated. 

OPTIMIZE Applies to the entire compilation unit in 

which the pragma appears. 

PRIORITY -Applies to the task specification in which it 

appears, or to the environment task if it 
appears in the main subprogram. 

STATIC Applies to the compilation unit in which the pragma 

appears. 

STORAGE_UNIT No scope, but a WARNING diagnostic is 
generated. 

SUPPRESS Applies to the block or body that contains 

the declarative part in which the pragma 
appears. 


F.2.3 Scope of Pragmas 


F-09 







vers.on j.d 
29 March 1991 


Aca/M ?SE Har.cDCc< 


SYSTEM_NAM£ No scope, but a WARNING diagnostic is 
generated. 

TICK Applies to the entire program library in 

which the pragma appears. 

TITLE The compilation unit within which the pragma 

occurs. 

TRIVIAL_ENTRY Applies to the compilation unit in which the pragma 
appears. 

UNMAPPED Applies to all objects of the access type 

named as arguments. 


F-10 


F.2.3 Scope of Pragmas 






Aca/ M PSi riancDOOK 


Ve : 3. 
29 Marc 


P.3 Attributes 

The following notes augment the language-required defir. 
of the predefined attributes found in Appendix A of tne Ada 


anguage Reference Manual. 



T'MACHINE_EMAX 

is 

63. 

t'.mach:ne_emin 

is 

-64. 

T'MACHINE_MANTIS SA 

is 

6. 

T'MACHINE_OVERFLOWS 

is 

TRUE. 

T'MACHINE_RADIX 

is 

16. 

T'MACHINE ROUNDS 

is 

FALSE 


F.3 Attributes 






29 March 1991 


F.4 Predefined Language Environment 

The predefined Ada language environment consists of the 
.packages STANDARD and SYSTEM, which are described below. 


F.4.1 Package STANDARD 

The package STANDARD contains the following definitions in 
addition to these specified in Appendix C of the Ada Language 
Reference Manual. 

TYPE boolean IS (false, true); 
rC'R boolean’SIZE USE 1; 


TYPE integer IS RANGE -32 768 .. 32 767; 

TYPE long^integer IS RANGE -2_147_483__648 .. 2_147_483_647 ; 

TYPE float IS DIGITS 6 RANGE 

-(16#0.FFrFF8#E63) .. (16#0.FFFFF8#E63); 


— Additions to predefined subtypes: 

SUBTYPE long_natural IS long_integer RANGE 0..integer'LAST; 
SUBTYPE long^positive IS long^integer RANGE 1..integer’LAST; 

FOR character'SIZE USE 8; 

TYPE string IS ARRAY (positive RANGE <>) OF character; 

PRAGMA PACK(string); 

TYPE duration IS DELTA 2.0 ** (-14) 

RANGE -131 071.0 .. 131 071.0; 


— The predefined exceptions: 


cor.straint_error 
numeric_er7or 
programmerror 
storage”error 
tas<ing~error 


exception; 

exception; 

exception; 

exception; 

exception; 


r-12 


F.4.1 Package STANDARD 










Ada/M ?SE Har.GDoo< 


^.5 

29 Ma r c n 19 91 


F. 4.2 Package SYSTEM 

The SYSTEM packages for Ada/M are as follows: 


F.4.2.1 AN/UYK-44 SYSTEM 

The package SYSTEM for the AN/UYK_44 is: 

TYPE name IS (anuyk44, anaykl4); 

system_name : CONSTANT system.name := system.anuyk44; 

storage_unit : CONSTANT := 16; 

memory size : CONSTANT := 65_536; 

TYPE address IS RANGE 0..system.memory_size - 1; 

FOR address'SIZE USE 16; 

— System Dependent Named Numbers 

min_int : CONSTANT := -(2**31); 

max_int ; CONSTANT := (2**31)-1; 

max_digits : CONSTANT := 6; 

max_mantissa : CONSTANT := II; 

fine_delta : CONSTANT := 

2 # 0 . 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 001 #; 
tick : CONSTANT := 3.125e-05; 

— 1/32000 seconds is the basic clock period. 

— Other System Dependent Declarations 

SUBTYPE priority IS integer RANGE 0..15; 

TYPE entry__kind IS (normal, immediate); 

physical_memory size ; CONSTANT ;= 2*^22; 

TYPE physical_a3dress IS 

RANGE 0..system.physical_memory_size - 1; 

TYPE external^interrupt__word IS RANGE 0 .. 65_536; 

Address clause (interrupt) address codes for the 

ANUYK-44 

Class I Unhandled address : CONSTANT 

” address := 16#0800#; 

Class II Unhandled address : CONSTANT 

” address ;= 16#1800#; 

Class III Unhandled address : CONSTANT 

~ address 1612800#; 


F.4.2.1 AN/UYK-44 SYSTEM 







Version 3.5 
29 March 1991 


Ada/M PSE HandDooK 


- Class I interrupts - 

CP_Meraory_Resume_address : CONSTANT 

address := 1611000#; 

C?_Memory_Parity_address : CONSTANT 

address := 16#1400#; 

IOC_Memory_Parity_address : CONSTANT 

~ address := 16#1700#; 

IOC_Memory_Resume_address : CONSTANT 

~ address := 16#1A00#; 

Power_Fault_address ; CONSTANT 

address := 16#1F00#; 

- Class II interrupts - 

C?_Instruction_Fault_address : CONSTANT 

address := 1612200#; 

Executive_Mode_Fault_address : CONSTANT 

address := 1612300#; 

IOC_Instruction_Fault_addcess : CONSTANT 

address := 16#2400#; 

IOC_Protect_Fault_address : CONSTANT 

address := 16#2500#; 

CP_Procect_Fault_address : CONSTANT 

address := 16#2900#; 

once_only_pti : CONSTANT duration ;= 0.0; 

Used to indicate that a PTI is not to be periodic. 
SUBTYPE pti_address IS address RANGE 16#2F01#..16#2F1F# ; 
TYPE pti_state IS (active,inactive,unregistered); 

- Class III (I/O) interrupts - 

MMIO_Discrete_Interrupt_address : CONSTANT 

” “ address := 16#3C00#; 

MMIO_External_Interrupt_address ; CONSTANT 

address := 16*3D00t; 

MMIO_Output_Data_Ready_address : CONSTANT 

address := 16#3E00#; 

MMIO Input Data Ready address : CONSTANT 

address := 16#3F00#; 

IOC Intercomputer Timeout address : CONSTANT 

" “ address := 16#3C00#; 

IOC External Int Discrete address : CONSTANT 

” ” address :» 16#3D00#; 

IOC Output Chain Interrupt address : CONSTANT 

“ “ “ “ address := 16#3E00#; 

IOC Input Chain Interrupt address ; CONSTANT 

“ address := 16#3F00#; 


F-14 


F.4.2.1 AN/UYK-44 SYSTEM 





















Aaa/M ?S£ riandDooic 


Vers -cr. 
2 3 Marcr. 



— The following exceptions are provided as a "convention" 

— whereby the Ada program can be compiled with all implicit 

— checks suppressed (i.e., pragma SUPPRESS or equivalent), 

— explicit checks included as necessary, the appropriate 

— exception raised when required, and then the exception 13 

— either handled or the Ada program terminates. 


access_check 
discriminant_check 
index_check 
iength_check 
range check 
divisron_check 
overflow check 
elaboracron_check 
storage_check 


EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 


— implementation-defined exceptions, 


unresolved_reference 
system_error 
capacity error 


EXCEPTION; 

EXCEPTION; 

EXCEPTION; 




F.4.2.1 AN/UyK-44 SYSTEM 







Version 3.5 
29 March 1991 


Ada/M PSE Handbook 


P.4.2.2 AN/AYK-14 SYSTEM 

The package SYSTEM for the AN/AYK-14 is: 

TYPE name IS (anuyk44, anaykl4); 

system_name : CONSTANT system.name := system.anaykl4; 

storage_unit : CONSTANT := 16; 

memory_si 2 e : CONSTANT := 65_536; 

TYPE address IS RANGE 0..system.memory_si 2 e - 1; 

FOR address'SIZE USE 16; 

— System Dependent Named Numbers 

min_int : CONSTANT ;= -(2**31); 

max_int : CONSTANT := (2**31)-l; 

max_digits : CONSTANT := 6; 

max_mantissa : CONSTANT := 31; 

fine_delta : CONSTANT := 

2 # 0 . 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 001 #; 
tick : CONSTANT ;= 3.125e-05; 

— 1/32000 seconds is the basic clock period. 

— Other System Dependent Declarations 

SUBTYPE priority IS integer RANGE 0..i5; 

TYPE entry_kind IS (normal, immediate);’ 

physical_memory size ; CONSTANT := 2**22; 

TYPE physical_a3'dress IS 

RANGE 0. .system.physical_memory_size - 1; 

TYPE external_interrupt_word IS ElANGE 0 .. 65_536; 

Address clause (interrupt) address codes for the 

ANAYK-14 

Class_I_Unhandled_address : CONSTANT 

address 1610800#; 

Class II Unhandled address : CONSTANT 

” “ “ address ;= 16#1800#; 

Class III Unhandled address : CONSTANT 

” “ “ address := 16#2800#; 


F-16 


F.4.2.2 AN/AYK-14 SYSTEM 









Ada/M PSE ciandDOOK 


versior. 2.5 
29 Ma r c r. 1991 


- Class I interrupts - 

Memory_Resume address ; CONSTANT 

address := 16#1000#; 

Memory_Parity_address : CONSTANT 

address := 16#1400#; 

Thermai_Overload_address : CONSTANT 

address := 16#1900#; 

IO_Failure_address : CONSTANT 

address := 16#1300#; 

Hardware_aiT__Fault_address : CONSTANT 

" address := 16#1C00#; 

Hardware_Fault_Warning_address : CONSTANT 

address := i6#iD00#; 

Power_Fault_address : CONSTANT 

address := iSIlFOO#; 

-- Class II interrupts - 

CP_Instruction_Fault_address : CONSTANT 

address := 16#2200#; 

Execucive_Mode_Instruction Pault_address : 

CONSTANT 

address := 16#2300#; 

IO_Instruction_Fault_address : CONSTANT 

address ;= 16#2400#; 

System_Reset_address : CONSTANT 

address :» 16#2500#; 

Overtemp__address : CONSTANT 

"" address := 16#2700#; 

Memory__Protect_Fault_address : CONSTANT 

” “ “ address :* 1612900#; 

External_Interrupt_2_address : CONSTANT 

^ ~ address := 16#2C00#; 

External Interrupt 3_address : CONSTANT 

address := 16#2D00#; 

External_Interrupt_4_addres3 : CONSTANT 

“ address := 16#2E00#; 

once^only pti ; CONSTANT duration ;= 0.0; 

-- Usea to indicate that a PTI is not to be periodic. 

SUBTYPE pti^address IS address RANGE 16*2F01«..16»2F1FI; 

TYPE pti^state IS (active,inactive,unregistered); 

——— - Class III (I/O) interrupts - 

IO_Channel_Abnormal_address : CONSTANT 

“ ” address := 16#3C00#; 

External Interrupt address ; CONSTANT 

“ address :* 16I3D00#; 

Output Chain Interrupt address ; CONSTANT 

address := 16#3E00#; 

Input Chain Interrupt address : CONSTANT 

” address :* 16#3FOO#; 


F.4.2.2 AN/AYK-14 SYSTEM 


F 















29 March 1991 


- - ..a-^ < 


— The following exceptions are provided as a "convention” 

— whereby the Ada program can be compiled with all implic: 

— checics suppressed (i.e., pragma SUPPRESS or equivalent), 

— explicit checxs included as necessary, the appropriate 

— exception raised when required, and then the exception ; 

— either handled or the Ada program terminates. 


access_check 

Qiscriminant_check 

index_check 

length_check 

range check 

divisron_check 

overflow check 

elaboratron_check 

storage_check 


EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 


— implementation-defined exceptions. 


unresolved_reference 
system_error 
capacity_error 


EXCEPTION 

EXCEPTION 

EXCEPTION 


F-18 


F.4.2.2 AN/AyK-14 SYSTEM 







AGd/ M rat aar.aocc^ 


Ve r 3 - cr. : . 5 
29 Harcr. .9 3. 

F.5 Character Jet 

Ada compilations may be expressed using the following 
Characters in addition to the basic character set: 

lower case letters: 

abcdefghi jKlmnopqrsruvwxyz 
special characters: 

!$%?§[ ]“'{}" 

The following transliterations are permitted: 

a. Exclamation point for vertical bar, 

b. Colon for sharp, and 

c. Percent for double-quote. 


F.5 Character Set 


19 






Version 3.5 Ada/M ?SZ “ar.dccc< 

29 March 1991 


F.6 Declaration and Recresentation Restrictions 

Declarations are described in Section 3 of rhe Ada Language 
Reference Manual, and represencacion specifications are descrioed 
in Section 13 of the Ada Language Reference Manua. and discussed 
here. 

In the following specifications, the capitalized word SIZE 
indicates the number of bits used to represent an object of tne 
type under discussion. The upper case symbols D, L, R, 
correspond to those discussed in Section 3.5.9 of tne Ada 
Language Reference Manual. 


F.o.l Integer Types 

Integer types are specified with constraints of the form: 
RANGE L..R 

where: 


R <= SYSTEM..MAX_INT 4 L >= SYSTEM.MIN_INT 

For a prefix "t" denoting an integer type, length specifications 
of the for. : 

FOR t'SIZE USE n ; 

may specify integer values n such that n in 2..16, 

R <= 2**(n-l)-l & L >= -(2**(n-l)) 
or else such that 

R <= (2**h)-l & L >= 0 
and 1 < n <= If. 

For a stand-alone object of integer type, a default SIZE of 16 is 
used when: 

R <= 2**15-1 & L >= -2**15 

Otherwise, a SIZE of 32 is used. 

For components of integer types within packed composite 
objects, the smaller of the default stahd-alohe SIZE or the SIZE 
from a length specification is used. 


F-20 


F.6.1 


Integer Types 




Ada/M PS£ ^.andbooK 


Ve r s . 2 - 
2 9 Marcr. 


991 


P.6.2 Floating Types 

Floating types are specified wirh constraints of tne fcrr.: 
DIGITS D 

where D is an integer in the range i through 6. 

For a prefix "t" denoting a floating point type, lengtn 
specifications of the form: 

FOR t'SIZE USE n; 

may specify integer values n = 32 when D <= 6. All floatino 
point values have SIZE = 32. 

F.6.3 Fixed Types 

Fixed types are specified with constraints of the form: 
DELTA D RANGE L..R 

where: 


MAX (ABS(R), ABS(L)) 

- <= 2**31-1. 

actual_delta 

The actual delta defaults to the largest integral power of 2 less 
than or equal to the specified delta D. (This implies that fixed 
values are stored right-aligned.) 

For fixed point types, length specifications of the form: 
for T'SIZE use N; 

are permitted only when N in 1 .. 32, if; 

R - actual_delta <= 2**(N-1)-1 * actual delta, and 
L + actual_delta >= -2**(n-l) * actual)3elta 

or 

R - actual_delta <= 2**(N)-1 * actual_delta, and 
L >= 0 


F.6.3 Fixed Types 







Version 3.5 
29 March 1991 


Ada/M ?SE Hap.dbcc< 


For stand-alone objects of fixed point type, a default size of 22 
is used. For components of fixed point types within packed 
composite objects, the size from the length specification will be 
used. 

For specifications of the form: 

FOR r'SMALL L’SE n; 

are permitted for any value of X, such that X <= D. X must oe 
specified either as a base 2 value or as a base 10 value. Note 
that when X is specified as other than a power of 2, actual_delta 
will still be the largest integreal power of two less than X. 


F.6.4 Enumeration Types 

In the absence of a representation specification for an 
enumeration type "t," the internal representation of t'FIRST is 
0. The default size for a stand-alone object of enumeration type 
"t" is 16, so the internal representations of t'FIRST and t’LAST 
both fall within the range 

-2**15 .. 2**15 - 1. 

For enumeration types, length specifications of the form: 

FOR t'SIZE USE n; 

and/or enumeration -representations of the form: 

FOR t USE <aggregate>; 

are permitted for n in 2..16, provided the representations and 
the SIZE conform to the relationship specified above. 

Or else for n in 1..16, is supported for enumeration types 
and provides an internal representation of: 

t'FIRST >« 0 .. t'LAST <= 2**(t'SIZE) - 1. 

For components of enumeration types within packed composite 
objects, the smaller of the default stand-alone SIZE and the SIZE 
from a length specification is used. 

Enumeration representations for types derived from the 
predefined type STANDARD.BOOLEAN will not be accepted, but length 
specifications will be accepted. 


F-22 


F.6.4 Enumeration Types 







rtaa/M rsi .idncoocK 


Vers 
2 9 Mar 


r . 5 


991 


F.6.5 Access Types 

For access type, "t," length specifications of the forT.: 

FOR t'SIZE USE n; 

will not affect the runtime implementation of "t," therefore n = 
16 is the only value permitted for SIZE, which is the va.ie 
returned by the attribute. 

For collection size specification of the form: 

FOR t'STORAGE_SIZE USE n; 

for any value of "n" is permitted for STORAGE_SIZE {and tnat 
value will be returned by the attribute call). The collection 
size specification will affect the implementation of "t" and its 
collection at runtime by limiting the number of objects for tyoe 
"t" that can be allocated. 

The value of t'STORAGE_SIZE for an access type "t" specifies 
the maximum number of storage_units used for all objects in the 
collection for type "t." This includes all space used by the 
allocated objects, plus any additional storage required to 
maintain the collection. 


F.6.6 Arrays and Records 

For arrays and records, a length specification of the form: 

FOR t'size USE n; 

may cause arrays and records to be packed, if required, to 
accommodate the length specification. If the size specified is 
not large enough to contain any value of the type, a diagnostic 
message of severity ERROR is generated. 

The PACK pragma may be used to minimize wasted space between 
components of arrays and records. The pragma causes the type 
representation to be chosen such that the storage space 
requirements are minimized at the possible expense of data access 
time and code space. 

A record type representation specification may be used to 
describe the allocation of components in a record. Bits are 
numbered 0..15 from the right. 16 starts at the right of the 
next higher numbered word. Each location specifica.ion must 
allow at least n bits of range, where n is large enough to hold 
any value of the subtype of the component being allocated. 
Otherwise, a diagnostic message of severity ERROR is generated. 
Components that are arrays, records, tasks, or access variables 
may not be allocated to specified locations. If a specification 


r- *3 


F.6.6 Arrays and Records 










r\<ZcL, 


r- i C. 


-ar.dsccK 


29 March 1991 


of this form is entered, a diagnostic message of severity ERROR 
is generated. 

For records, an alignment clause of the form: 

AT MOD n 

specify alignments of 1 word (word alignment) or 2 words 
(doubleword alignment). 

If it is determinable at compile time that the SIZE of a 
record or array type or subtype is outside the range of 
STANDARD.LONG_INTEGER, a diagnostic of severity WARNING is 
generated. Declaration of such a type or subtype would raise 
NUMERIC ERROR when elaborated. 


F.6.7 Other Length Specifications 

Length Specifications are described in Section 13.2 of the 
Ada Language Reference Manual. 

A length specification for a task type "t" of the form: 

FOR t'STORAGE_SIZE use n; 

specifies the number of SYSTEM.STORAGE_UNITS that are allocated 
for the execution of each task object of type "t." This includes 
the runtime stack for the task object but does not include 
objects allocated at runtime by the task object. If a 
t'STORAGE_SIZE is not specified for a task type "t," the default 
value is 8K (words). 

A length specification for a task type "t" of the form: 

FOR t'SIZE USE n; 
is allowable only for n » 32. 


F-24 


F.6.7 Other Length Specifications 







Aaa/M ?S£ Har.GDooK 


Version 3.5 
29 Marc.n 1991 


F.7 System Generated Names 

Refer to Section 13.7 of the Ada Language Reference .Manual 
and the section above on the Predefined Language Environment for 
a discussion of package SiSTEM. 

The system name is chosen based on the target(s) supported, 
but it cannot be changed. In the case of Ada/M, the syste.T. name 
is ANUYK44 or ANAYK14. 


F.8 Address Clauses 

Refer to Section 13.5 of the Ada Language Reference Manual 
for a description of address clauses. All rules and restrictions 
described there apply. In addition, the following restrictions 
apply. 

An address clause may designate a single task entry. Such 
address clause is allowed only within a task specification. 
meaningful values of the simple expression are the allowable 
interrupt entry addresses as deJinfd in Table F-1. The use of 
other values will result in the raising of a PROGRAM_ERROR 
exception upon creation of the task. 

If more than one task entry is equated to the same interrupt 
entry address, the most recently executed interrupt entry 
registration permanently overrides any previous registrations. 

At most one address clause is allowed for a single task 
entry. Specification of more than one interrupt address for a 
task entry is erroneous. 

Address clauses for objects and code otner tha task entries 
are allowed by the Ada/M target, but they have no effect beyond 
changing the value returned by the 'ADDRESS attribute call. 


F.8 Address Clauses 


0 


n) a> 







Version 3.5 
29 March 1991 


Ada/M ?SE Har.CDOOK 


AN/UYK-44 Interrupt Summary 

H —- - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --- --- 

I Class 0 interrupts (with interrupt entry address) include: 


o Class I Unhandled Interrupt 16#0800# 


I Class I interrupts (with interrupt entry address) include: 


o 

Class II Unhandled 

16#1800# 

o 

CP Memory Resume 

16#1000# 

o 

CP Memory Parity 

16#1400# 

o 

IOC Memory Parity 

16#1700# 

o 

IOC Memory Resume 

16#1A00# 

o 

Power Fault 

16#1F00# 


Class II interrupts (with interrupt 

entry address) include: 

0 

Class III Unhandled 

16«2800« 


o 

Floating Point Over/Underflow 

16#2100# 

UNDEFINABLE 

0 

CP Instruction Fault 

16#2200# 


o 

Executive Mode Fault 

16#2300# 


0 

IOC Instruction Fault 

16«2400* 


o 

IOC Protect Fault 

16#2500# 


o 

Executive Return 

16*2600* 

UNDEFINABLE 

0 

Overtemo address 

16*2700* 


o 

CP Protect Fault 

16*2900* 


o 

Real-Time Clock 

16*2E00* 

UNDEFINABLE 

o 

Monitor Clock 

16*2F00* 

UNDEFINABLE 


Table F-la - Interrupt Entry Addresses 


F-26 


F.8 Address Clauses 










Aaa/M nar.aDooic 


Ve rs-cn 2.5 
29 Marcr. 1991 


AN/UYK-44 Interrupt Summary 


Class III interrupts (with interrupt entry address) include: 


o MMIO Discrete Interrupt 16#3C00# 

o MMIO External Interrupt 16#3D00# 

o MMIO Output Data Ready 16#3E00# 

o MMIO Input Data Ready 16t3F00# 

o IOC Intercomputer Timeout 16#3C00# 

o IOC External Interrupt/Discrete 16#3D00# 

o IOC Output Chain Interrupt 16#3E00# 

o IOC Input Chain Interrupt 16#3F00# 

For all class III interrupts, the following interpretations 

apply: 

IC => IOC, CHANNEL pair, 16#00#..16#0F# indicates IOC 0 
16#10#..16#1F# indicates IOC 1 
16#20#..16#2F# indicates IOC 2 
16#30#..i6#3F# indicates IOC 3 

CC => CHANNEL number, 16#00#..16#3F# indicates channel 0..63 


Table F-lb - Interrupt Entry Addresses (Continued) 


F.8 Address Clauses 


F-27 











Version 3.5 
29 March 1991 


Ada/M PSE nar.docoK 


1 

AN/AYK-14 Interrupt Sununary ! 

i 

Class 0 interrupts (with interrupt 

entry address) include: 


o Class I Unhandled Interrupt 

16#0800# 


Class I interrupts (with interrupt 

entry address) include: 


o Class II Unhandled 

16#1800# 


o CP Memory Resume 

16#1000# 


o CP Memory Parity 

16#1400# 


o Thermal Overload 

16#1900# 


o 10 Failure 

16#1B00# 


o Hardware BIT Fault 

16#1C00# 

i 

0 Hardware Fault Warning 

16#1D00# 

1 

o Power Fault 

16#1F00# 

1 

1 


Class II interrupts (with interrupt 

entry address) include: | 

0 

Class III Unhandled 

16#2800# 

i 

0 

Floating Point Over/Underflow 

16#2100# 

UNDEFINABLE 

o 

CP Instruction Fault 

16*2200* 


0 

Executive Mode Fault 

16*2300* 


o 

IOC Instruction Fault 

16*2400* 


o 

System Reset 

16*2500* 


0 

Executive Return 

16*2600* 

UNDEFINABLE 

o 

Overtemp address 

16*2700* 


o 

CP Protect Fault 

16*2900* 


r> 

w 

Real-Time 1■owk 

15*2E00* 

UKDEFINABLE 

o 

Monitor Clock 

16*2F00* 

UNDEFINABLE 


Table F'lc - Interrupt Entry Addresses (Continued) 


F-28 


F.8 


Address Clauses 












AGd/M PSt a<aaGDOC< 


Version 2.5 
29 Marcr. 1991 


+ 


AN/AYK-14 Interrupt Summary 


I Class III interrupts (with interrupt entry address) include: 


o 10 Channel Abnormal 
o External Interrupt 
o Output Chain Interrupt 
o Input Chain Interrupt 


16#3COO# 

16#3D00# 

i6#3E00# 

16#3F00# 


For ail class III interrupts, the following interpretations 
apply; 


IC => IOC, CHANNEL pair, 16#00#..16#0F# indicates IOC 0 
16#10#..16#1F# indicates IOC 1 
16#20i..16#2F# indicates IOC 2 
16#30#..16#3F# indicates IOC 3 


I CC => CHANNEL number, 16100#..16#3FI indicates channel 0..63 


Table F“ld - Interrupt Entry Addresses (Continued) 


F .8 Address Clauses 


F-29 













29 March 1991 


F.9 Oncheciced Conversions 

Refer to Section 13.10.2 of the Ada Language Reference Manual 
for a description of UNCHECKED_CONVERSION. It is erroneous :.f 
your Ada program performs UNCHECKED_CONVERSION when the source 
and target objects have different sizes. 


F.IO Restrictions on the Main Subprogram 

Refer to Section 10.1 (8) of the Ada Language Reference 
Manual for a description of the main subprogram. The subprogram 
designated as the main subprogram cannot have parameters. The 
designation as the main subprogram of a subprogram whose 
specification contain a formai_part results in a diagnostic of 
severity ERROR at link time. 

The main subprogram can be a function, but the return value 
will not be availaole upon completion of the main subprogram's 
execution. The main subprogram may not be an import unit. 


F-30 


F.IO 


Restrictions on the Main Subprogram 




Ada/M ?SE .-iandDOOK 


V s r 3 
29 Mar 


- . 3 


991 


P.ll Input/Output 

Refer to Section 14 of the Ada Language Reference Manual fcr 
a discussion of Ada Input/Output and to Section 12 of the Ada.-^M 
Run Time Environment Handbook for more specifics on the Ada/M 
input/output subsystem. 

The Ada/M IntJut/Outout subsystem provides the following 
packages: TEXT_l6, SEQU£NTIAL_rO, DrRECT_rO, and L0W_LEVEL_:G. 
These packages execute in the context of the user-written Ada 
program tasx making the I/O request. Consequently, all of tne 
code that processes an I/O request on behalf of the user-written 
Ada program executes sequentially. The package IO_EXCEPTIONS 
defines all of the exceptions needed by the packages 
SEQUENTIAL_IO, DIRECT_IO, and TEXT 10. The specification of tnis 
package is given in Section 14.5 o'E the Ada Language Reference 
Manual. This package is visible to all of the constituent 
packages of the Ada/M I/O subsystem so that appropriate exception 
handlers can be inserted. 

I/O in Ada/M is performed solely on external files. No 
allowance is provided in the I/O subsystem for memory resident 
files (i.e., files which do not reside on a peripheral device). 
This is true even in the case of temporary files. With the 
external files residing on the peripheral devices, Ada/M makes 
the further restriction on the number of files that may be open 
on an individual peripheral device. 

Section 14.1 of the Ada Language Reference Manual states tnat 
all I/O operations are expressed as operations on objects of seme 
file type, rather than in terms of an external file. File 
objects are implemented in Ada/M as access objects which point to 
a data structure called the File Control Block. This File 
Control Block is defined internally to each of the high-level I/O 
packages; its purpose is to represent an external file. The File 
Control Block contains all of the I/O-specific information about 
an external file needed by the high-level I/O packages to 
accomplish requested I/O operations. 


F.11.1 Naaing External Piles 

The naming conventions for external files in Ada/M are of 
particular importance. All of the system-dependent information 
needed by the I/O subsystem about an external file is contained 
in the file name. External files may be named using one of three 
file naming conventions: standard, temporary, and user-derived. 


F.11.1 Naming External Files 





version j.5 
29 March 1991 


Ada/M ?SE riandoccK 


P.11.1.1 Standard File Names 

The standard external file naming convention used in Ada/M 
identifies the specific location of the external file in terms of 
the physical device on which it is stored. For this reason, you 
should be aware of the configuration of the peripheral devices on 
the AN/UYK-44 or AN/AYK-14 at your particular site. 

Standard file names consist of a six character prefix and a 
file name of up to fourteen characters. The six character prefix 
has a predefined format. The first and second characters must oe 
either "CT," "MT," or "tt," designating an AN/USH-26 Signal Data 
Recorder/Reproducer Set, the RD-35a Magnetic Tape Subsystem, or 
the AN/USQ-69 Data Terminal Set, respectively. These characters 
must be in upper case. 

The third and fourth characters specify the channel on which 
the peripheral device is connected. Since there are sixty-four 
channels on the Ada/M system, the values for the third and fourth 
positions must lie in the range ’’00” to ''63.” 

The range of values for the fifth position in the external 
file name's prefix (the unit number) depends upon the device 
specified by the characters in the first and second positions of 
the external file name. If the specified peripheral device is 
the AN/c;SH-26 magnetic tape drive, the character in the fifth 
position must be one of the characters "O," ”1,'' ''2," or 
”3." This value determines which of the four tape cartridge 
units available on the AN/USH-26 is to be accessed. If the 
specified peripheral device is the RD-358 magnetic tape drive, 
the character in the fifth position must be one of the characters 
"O," "1,” "2,” or ”3.'' This value determines which of the four 
tape units available on the RO-358 is to be accessed. If the 
specified peripheral device is the AN/USQ-69 militarized display 
terminal, the character in the fifth position must be a "0." The 
AN/USQ-69 has only one unit on a channel. 

The colon (:) is the only character allowed in the sixth 
position. If any character other than the colon is in this 
position, the file name will be considered non-standard and the 
file will reside on the default device defined during the 
elaboration of CONFIGURE_IO. 

Positions seven through twenty are optional to your Ada 
program and may be used as desired. These positions may contain 
any printable character you choose in order to make the file name 
more intelligible. Embedded blanks, however, are not allowed. 


F-32 


F.11.1.1 Standard File Names 






rtwa/ 


r O- 




w w N 


/e.3.z" 
29 Marcn 


- . 3 


991 


The location of an external file cn a peripheral device :s 
thus a function of the first six characters of the file name 
regardless of the characters that might follow. For exompie, if 
the external file "CTOOOr01d_Data" has been created and not 
subsequently closed, an attempt to create the external file 
"CTOOO:New_Data" will cause the exception DEVICE_ERROR (ratner 
tnan NAME_ERROR or USE_ERROR) to be raised because the oeripnera. 
device on channel "00" and cartridge "0" is already in use.' 

You are advised that any file name beginning with "xxxxx:" 
(where x denotes any printable character) is assumed to be a 
standard external file name. If this external file name does not 
conform to the Ada/M standard file naming conventions, the 
exception MAME_ERROR will be raised. 


F.11.1.2 Temporary File Names 

Section 14.2.1 of the Ada Language Reference Manual defines a 
temporary file to be an external file that is not accessible 
after completion of the main subprogram. If the null string is 
supplied for the external file name, the external file is 
considered temporary. In this case, the high level I/O pacicages 
internally create an external file name to be used by the lower 
level ’■^0 packages. The internal naming scheme used by the I/O 
subsystem is a function of the type of file to be created (text, 
direct or sequential), the temporary nature of the external file, 
and the number of requests made thus far for creating te.mprrary 
external files of the given type. This scheme is consistent with 
the requirement specified in the Ada Language Reference Manual 
that all external file names be unique. 

The first three characters jf the file name are "rEX," "OIR," 
or "SEQ." The next six characters are "_TEMP The remaining 
characters are the image of an integer which denotes the number 
of temporary files of the given type successfully created. There 
are two types of temporary files; one is used by SEQUENTIAL_IO 
and DIRECT_IO, and the other is used by TEXT_I0. For instance, 
the temporary external file name "TEX_TSMP_10" would be the namie 
of the tenth temporary external file successfully created by your 
Ada program through calls to TEXT_IO. 




F.11.1.2 


Temporary File Names 







Version 3.5 
29 March 1991 


Ada/M ?S£ HandoocK 


P.11.1.3 User-Derived File Manes 

A random string containing a sequence of characters of length 
one to twenty may also be used to name an external file. 

External files with names of this nature are considered to be 
permanent external files. You are cautioned from using names 
wnicn conform to the scheme used by the I/O subsystem to name 
temporary external files (see list item "b"). 

It is not possible to associate two or more internal files 
witn the same external file. The exception USE_ERROR will be 
raised if this restriction is violated. 


F.11.2 The FORM Specification for External Files 

Section 14.2.1 of the Ada Language Refereiice Manual defines a 
string argument called the FORM, which supplies system-dependent 
information that is sometimes required to correctly process a 
request to create or open a file. In Ada/M, the string argument 
supplied to the FORM parameter on calls to CREATE and OPEN is 
retained while the file is t^pen, so tnat calls to the function 
FORM can return the string to ycur Ada program. Form options 
specified on calls to CREATE have the effects stated below. Form 
options spe-^-fied on calls to OPEN have no effect. 

The REWIND and APPEND options are mutually exclusive; an 
attempt to specify both options on a call to CREATE will raise 
the exception USE_ERROR. 

The NOHEAD option may be specified in combination with either 
t.ne REWIND or the APPEND option. 

If one form option is specified, the FORM string should 
contain only the option, without any extraneous characters. If 
two form options are specified, the FORM string should contain 
the first form option followed by a comma followed by the second 
form option. The form options may be specified in any 
combination of upper and lower case. 

If the supplied FORM string is longer than the maximum 
allowed FORM string (13 characters), CREATE and OPEN will raise 
the exception USE_FRROR. 

If the procedure CREATE does not recogni-c the options 
specified in the FORM string, it raises the exception USE_ERROR. 
The procedure OPEN does not validate the contents of the supplied 
FORM string. 


F-34 


F.11.2 


The FORM Sp^cification for External Files 





rtCa/« r'Si nancJOCOK 


Ve r 
2 9 Ma 


Positioning arguments allow control of tape before its use. 
The following positioning arguments are available: 

a. REWIND - specifies that a rewind will be performed pricr to 
the requested operation. 

b. NOREWIND - specifies that the tape remains positioned as .s 

c. APPEND - specifies that the tape be positioned at the looio 
end of tape (LEOT) prior to the requested operation. Tne 
LEOT IS denoted by two consecutive tape_marKS. 

Note that, to ensure a tape file created by a previous 
program is available for use by a new program, you must have 
knowledge of the tape being used and must use the APPEND form 
option when creating new files. 

The formatting argument specifies information about tape 
format. If a formatting argument is not supplied, the file is 
assumed to contain a format header record determined by the AL3 
I/O system. The following formatting argument is available: 

a. NOHEAD - specifies that the designated file has no header 
record. This argument allows the reading and writing of 
tapes used on computer systems using different header 
formats. Note that files created with the NOHEAD option 
cannot be opened by the Ada/M I/O subsystem. 


F.11.2 The FORW Specification for External Files 




Version 3.5 
29 March 1991 


Ada/M ?S£ HanaoccK 


F.11.3 File Processing 

Processing allowed on Ada/M files is influenced by the 
characteristics of the underlying device. The following 
restrictions apply; 

a. Only one file may be open on an individual AN/USH-26 tape 
cartridge at a ri.me. 


b. Only one input and one output file may simultaneously be open 
on an AN/USQ-69 terminal at one time. 


c. An Ada program is erroneous if it does not close or delete 
all files it creates or opens. 

d. The attempt to CREATE a file with the mode IN FILE is not 
supported since there will be no data in the File to read. 


F-36 


F.11.3 File Processing 







Ada/M ?SE HandbocK 


Versicr. 

2 9 Ma r c n 13 9 1 


P.11.4 Text Input/Output 

TEXT 10 is invoked by your Ada program to perform sequential 
access l70 operations on text files (i.e, files whose content .s 
in human-readable form). TEXT_I0 is not a generic pacKage and, 
thus, its subprograms may be invoked directly from your procram, 
using objects with base type or parent type in tne 
language-defined type character. TEXT_I0 also provides the 
generic packages INTEGER_IO, riOAT_IO, FIXED 10, and 
ENUMERATION_ro for the reading and writing oF numeric values and 
enumeration values. The generic pacxages within TEXT_I0 require 
an instantiation for a given ele.ment type before any of their 
subprograms are invoked. The specification of this pacKage is 
given in Section 14.3.10 of the Ada Language Reference Manual. 

The implementation-defined type COUNT that appears in Section. 
14.3.10 of the Ada Language Reference Manual is defined as 
follows: 

type COUNT is range 0..INTEGER’LAST; 

The implementation-defined subtype FIELD that appears in Section. 
14.3.10 of tne Ada Language Reference Manual is defined as 
follows: 


subtype FIELD is INTEGER range 0..INTEGER’LAST; 

At the beginnihg of program execution, the STANDARD_INPUT 
file and the STANDARD^OUTPUT file are open, and associated witn 
the files specified by you at export time. Additionally, if a 
program terminates before an open file is closed (except for 
STANDARD_INPUT and STANDARD_OUTPUT), the last line added to the 
file may be lost; if the file is on magnetic tape, the file 
structure on the tape may be inconsistent. 

A program is erroneous if concurrently executing tasks 
attempt to perform overlapping GET and/or PUT operations on the 
same terminal. The semantics of text layout as specified in tne 
Ada Language Reference Manual, Section 14.3.2, (especially the 
concepts of current column number and current line) cannot be 
guaranteed when GET operations are interweaved with PUT 
operations. A program which relies on the semantics of text 
layout under those circumstances is erroneous. 

For TEXT_IO processing, the line length can be no longer than 
532 characters. An attempt to set the line length through 
SET_LINE_LENGTH to a length greater than 532 will result in 
USE ERROR. 


F.il.4 


ext Input/Output 





Aaa/M r-SZ 


J.J 

29 March L99i 


ria r.c 


< 


P.11.5 Sequential Input/Output 

SEQUENTIAL_IO is invoked by your Ada program to perform i/o 
on the records cf a file in sequential order. The SEQUENTIAL :o 
package also requires a generic instantiation for a given ele.mer.t 
type before any of its subprograms may be invoked. Once the 
package SEQUENTIAL_IO is made visible, it will perform any 
service defined by the subprograms declared in its specification. 
The specification of this pacKage is given in Section 14.2.3 cf 
the Ada Language Reference Manual. 

The following restrictions are i.mposed on the use of the 
package SEQUENTIAL_IO: 

a. SEQUENTIAL_IO cannot be instantiated with an unconstrained 
array type. 

b. SEQUENTIAL_IO cannot be instantiated with a record type with 
discriminants with no default values. 

c. Ada/.M does not raise DATA_ERROR on a read operation if the 
data input from the external file is not of the instantiating 
type (see the Ada Language Reference Manual, Section 14.2.2). 


F.11.6 Direct Input/Output 

Calls to the subprograms of an instantiation of DIRECT_IO 
have one of three possible outcomes. The exception USE_ERROR is 
raised if an attempt is made to CREATE and/or OPEN a file since 
direct access I/O operations are not supported in Ada/M. The 
exception STATUS_ERROR is raised on calls to subprograms other 
than CREATE, OPEN, and IS_OPEN. The function IS_OPEN always 
returns the value FALSE. 

The implementation-defined type COUNT that appears in Section 
14.2.5 of the Ada Language Reference Manual is defined as 
follows: 


type COUNT is range 0..LONG_INTEGER'LAST. 

The following restrictions are imposed on the use of the 
package DIRECT_IO; 

a. DIR£CT_IO cannot be instantiated with an unconstrained array 
type. 

b. DIRECT_IO cannot be instantiated with a record type with 
discriminants with no default values. 


F-38 


F.11.6 Direct Input/Output 







Ada/M ?S£ Kar.docoK 


•'---'sicr. 2.5 
29 Marc.T 19 91 


P.11.7 Low Level Input/Output 

LOW_LEVEL_IO is invoked by your Ada program to initiate 
physical operations on peripheral devices, and thus executes as 
part of a program task. Requests made to LOW_LEVZL_IO from your 
program are passed through the RTEXEC_GATEWAy to t.ne cha.nnel 
programs in CHANNEL_IO. Any status check or result information 
IS the responsibility of the invoking subprogram and can oe 
obtained from the suoprogram RECEIVE_CONTROL within L0W_LEVEL_:0. 

The package LOW_LEVEL_IO allows your program to send I/O 
commands to the l/0~devices (using SEND_CONTROL) and to receive 
status information from the I/O devices (using RECEIVE_C0NTR01;. 

A program is erroneous if it uses LOW LEVEL_IO to access a device 
that is also accessed by high-level l7o packages such as 
SEQUENT:aL_IO and TEXT_:0. The following is excerpted from me 
package LOW_LEVEL_IO. 

— IO_CHANNEL_RANGE is the type for the parameter DEVICE for 

— both SEND_CONTROL and RECEIVE_CONTROL. DEVICE identifies 

— which device to perform the operation for, and the channel 

— number is a convenient m*»ans for identifying a device. 

SUBTYPE io_channel_range j integer RANGE 0..63; 

— Range of values allowed for channel number. 

SUBTYPE buffer_address IS system.physical_address; 

— Type of variables used to specify 
— address of buffer for the I/O operation. 

SUBTYPE command_word IS long_integer RANGE 0..65535; 

-- Data structures used in communication with the AN/USH-26. 

ush26_programs : CONSTANT := 3; 

— Number of channel programs in CHANNEL_IO for 
— AN/USH-26 devices. 

SUBTYI” ush26_operation IS integer 

RANGE 0..low_ievel_io.ush26_programs; 

— Indicates to CHANNEL__IO which channel program to use. 

ush26_reaet channel ; CONSTANT ush26_operation := 0; 

ush26_read_3ata ; CONSTANT ush26_operation := 1; 

ush26_write_data : CONSTANT ush26_operation := 2; 

ush26 control : CONSTANT ush26_operation ;= 3; 


F.11.7 


Low Level Input/Output 


39 








Version j.5 
29 March 1991 


Ada/M .-iandooc< 


TYPE ush26_data IS RECORD 

— Data passed to SEND_CONTROL for operations on 
— AN/USH-26 devices. 

operation : low_ievel_io.ush26_operation; 

-- Kind of operation requested of LOW_LEVEL_IO: 

— read data, write data, control, or initialize, 
command : low_level_io.command_word; 

— Command to send to the device. 
data_length : integer range 0..integer‘last; 

— Number of words of data in the buffer. 
buffer_addr : low_level_io.buffer address; 

— Physical address of data buffer. 

END RECORD; 

— Data structures used in communication with the AN/USQ-69. 

usq69_programs : CONSTANT := 4; 

— Number of channel programs in CHANNEL_IO for 
— AN/USQ-69 devices. 

SUBTYPE usq69_operation IS integer 

RANGE 0..low_level_io.usq69_programs; 

— Indicates to CKANNEL_IO which channel program to use. 

usq69_reset_channel ; CONSTANT usq69_operation := 0; 

usq69~header : CONSTANT usq69_operation := 1; 

usq69_read_data ; CONSTANT usq69~operation :* 2; 

usq69~write_data : CONSTANT usq69_operation := 3; 

usq69“eot : CONSTANT usq69~operation := 4; 

TYPE usq69_data IS RECORD 

— Information needed to do I/O to a AN/USQ-69 device, 
operation ; low_level_io.usq69 operation; 

— Kind of operation requested of LOW_LEVEL_IO: 

— read data, write data, control, or initialize, 
command ; low_level_io.comniand_word; 

— Command to send to the device. 
data_length ; integer range 0..integer'last; 

— Number of words of data in the buffer, 
buffer^addr : low level_io.buffer address; 

— Physical ad3ress of data buffer. 

END RECORD; 

rd358_programa : CONSTANT ;= 3; 

— Number of channel programs in CHANNEL_IO for 
— RD-358 devices. 

SUBTYPE rd358_operation IS integer 

RANGE 0..low_level_io.rd358_programs; 

— Indicates to CHANNEL 10 which channel program to use. 


F-40 


F.11.7 Low Level Input/Outpu 








Ada/M PSE HandbooK 


Versicn 3. 
29 Ma r c n 19 9 


rd358_reset channel : CONSTANT rd358_operation := 0; 

rd358”read_3ata : CONSTANT rd358_operation := l; 

rd358”write_data : CONSTANT rd358~operacion := 2; 

rd358_control : CONSTANT rd358_operacion := 3; 

TYPE rd358_data IS RECORD 

— Information needed to do I/O to an RD-358 device, 
operation ; low_levei_io.rd358_operat ion; 

— Kind of operation requested of LOW_LEVEL_IO: 

— read data, write data, control, or initialization 
command : low_level_io.command_word; 

— Command to send to the device. 
data_length : integer range 0..integer‘last; 

— Number of words of data in the buffer. 
buffer_addr : low level_io.buffer address; 

— Physical adjress of data buffer. 

END RECORD; 

— Types used for intercomputer I/O operations. 

ic_programs : CONSTANT := 10; 

— Numoer of channel programs in CHANNEL_IO for 
— AN/USH-26 devices. 

SUBTYPE intercomputer_operation IS integer 
RANGE 0..low_level_io.ic_program3; 

— Indicates”to CHANNEL_IO which channel program to use. 

ic_reset channel : CONSTANT intercomputer_operation :* 0; 

ic_read_3ata : CONSTANT intercomputer_operation :* 1; 

ic_write^data : CONSTANT intercomputer_operation := 2; 

ic_control : CONSTANT intercomputer~operation := 3; 

TYPE intercomputer_data IS RECORD 

— Information needed to do I/O to an intercomputer 
— channel. 

operation ; low_level_io.intercomputer_operation; 

— Kind of operation”requested of LOW_LEVEL_IO; 

— read data, write data, contxol, or'initialization 
command ; low_level_io.conunand_word; 

— Command to send to the other computer. 
data_length ; integer range 0..integer’last; 

— Number of words of data in the buffer. 
buffer_addr : low level_io.buffer address; 

— Physical adSress of data buffer. 

END RECORD; 


F.11.7 Low Level Input/Output 


t-4 










Version 3.5 
29 March 1991 


Ada/M PSE HandoccK 


— Data type identifiers for RECEIVE_CONTROL. 

TYPE io_3tatus_word IS NEW long_integer RANGE 0..65535; 

— Used to pass I/O status word to RECEIVE_CONTROL. 

SUBTYPE external_interrupt_word IS 

system.external_inter rupt_word; 

— SEND_CONTROL is an overloaded Ada procedure which passes I/O 

— control information to a procedure in CHANNEL_IO in order to 

— carry out a read, write, or control operation. In Ada/M, 

— t.nere are four overloaded subprograms for SEND_CONTROL, one 

— for each of the following purposes : 

send data/command to an AN/USH-26 device, 
send data/command to an AN/USQ-69 device, 
send data/command to an RD-358 device, 
send data/command to another computer. 

— The following versions of the overloaded procedure 

— SEND_CONTROL are used for sending data to specific types of 

— devices. The difference between the various forms of this 

— procedure lies in the DATA parameter, whicn is a record with 

— a field that specifies the control command to send to the 

— device. The data type of this field is different for each 

— type of device. 

— SEND_CCNTROL for AN/USH-26 devices. 

PROCEDURE SEND_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheral device, 
data : IN OUT low_level_io.ush26_data 

— I/O control information for AN/USH-26 devices. 

) ; 


-- SEND_CONTROL for AN/USQ-69 devices. 

PROCEDURE SEND_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheral device, 
data : IN OUT low_level_io.usq69_data 

— I/O control information for AN/USQ-69 devices. 

) ; 


-- SEND_CONTROL for RD-358 devices. 

PROCEDURE SEND_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheral device, 
data : IN OUT low_level_io.rd358_data 

— I/O control information for AN/USQ-69 devices. 

) ; 


F-42 


F.il.7 Low Level Input/Output 





Ada/M ?_ dandbooK 


3 



— SEND CONTROL for Intercomputer channel. 

PROCEDURE SEND_CONTROL ( 

device : IN low_level_io. io_channel_range 

— Channel number of the peripheral device, 
data ; IN OUT Iow_ievei_io.intercomputer_daca 

— I/O control information for AN/USQ-69 devices. 

); 

— RECEIVE_CONTROL is a procedure which passes I/O control 

— information to a procedure in CHANNEL^IO in order to ootain 

— the value for the input transfer count for the specified 

— channel. 

PROCEDURE RECEIVE_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Device type for which status is requested, 
data : IN OUT low_ievel_io.io_status_word 

— External interrupt word for channel specified. 

); 


— RECEIVE_CONTROL for getting the external interrupt data 
-- for the specified channel. 

PROCEDURE RECEIVE_CONTROL ( 

device : IN iow_ievel_io.io_channel_range; 

— Channel numbe? of the peripheral device, 
data : IN OUT low_level_io.external_interrupt_word 
— Input count for channel specified. 

); 

— RECEIVE_CONTROL for getting input transfer count. 
PROCEDURE RECEIVE_CONTROL { 

device : IN low_level__io. io_channel_range; 

— Channel”nurabeF of the peripheral device, 
data ; IN OUT integer 

— Input count for channel specified. 

) ; 


P.12 Systea-Oefined Exceptions 

In addition to the exceptions defined in the Ada Language 
Reference Manual, this implementation pre-defines the exceptions 
shown in Table F-2 below. 



F.12 System-Defined Exceptions 



Version 3.5 
29 March 1991 


Ada/M ?SE tiandoocK 


Name 


Significance 


CAPACITY_ERROR 

SYSTEM_ERROR 

'JNRESOLVED_REFERENCE 

ACCESS_CHECK 

DISCRIMINANT_CHECK 

OIVISION_CHECK 

ELABORATION_CHECK 

INDEX_CHECK 
LENGTH_CHECK 
OVERFLOW_CHECK 
RANGE CHECK 


Raised by the Run-Time Executive when 
Pre-Runtime specified resource limits 
are exceeded. 

Serious error detected in underlying 
AN/UYK-44 or AN/AYK-14 operating* 
system. 

Attempted call to a subprogram whose 
body is not linked into the executaole 
program image. 

The ACCESS_CHECK exception has been 
raised explicitly within the program. 

DISCRIMINANT_CHECK exception has been 
raised explicitly within the program. 

The DIVISION_CHECK exception has been 
raised explicitly within the program. 

The ELABORATION_CHECK exception has 
been raised explicitly within the 
program. 

The INDEX_CHECK exception has been 
raised explicitly within the program. 

The LENGTH^CHECK exception has been 
raised explicitly within the program. 

The OVERFLOW__CHECK exception has been 
raised explicitly within the program. 

The RANGE^CHECK exception has been 
raised explicitly within the program. 


Table F-2 - System Defined Exceptions 


F-44 


F.12 System-Defined Exceptions 










Ada/M PSE HandbooK 


Version 
29 Marcn 1 



F.13 Machine Code Insertions 

The Ada language permits machine code insertions as defined 
in Section 13.8 of the Ada Language Reference Manual. T.tis 
section describes the specific details for writing machine code 
insertions as provided by the predefined package MACHINE CODE. 

Eou may, if desired, include AN/UYK-44 or AN/AiK-14 
instructions within an Ada program. This is done by including a 
procedure in the program which contains only record aggregaoes 
defining machine instructions. The package MACHINE_c6de, 
included in the system program library, contains type, record, 
and constant declarations which are used to form the 
instructions. Each field of the aggregate contains a field of 
the resulting machine instruction. These fields are specified in 
the order in which they appear in the actual instruction. 

A procedure containing machine-code insertions looks similar 
to this: 

with machine_code; use machine_code; 
procedure machine_samples is 
begin 

instr'( OPCODE ,A, M, Y); — first instruction 
instr' (OPCODE, A,M,Y); — second instruction 

instr' (OPCODE,A,M,Y); — last instruction 
end; 

OPCODE, A, M, and Y in all these examples are replaced by the 
actual opcode, A register, M register, and Y field desired for 
each AN/UYK-44 or AN/AYK-14 instruction. Whenever possible, 
MACRO/M mnemonics are used to specify the opcode field. The A 
and M register fields are specified as RO, Rl, ... R15. The Y 

field may be specified by any static expression which will fit in 
a 16-bit integer. For certain instructions such as unary 
arithmetic operations, the opcode and either the A or M register 
determine which instruction is executed. The specification of 
these instructions and certain others is somewhat more 
complicated and is explained in detail below. Here are some 
examples of possible NACRO/N instructions and the Ada/M record 
aggregates that correspond to them: 


NACRO/M 

Ada/M 

spt 

A,Y,M 

instr'(spt,A,M,Y); 

Ir 

A,M 

instr'(Ir,A,M); 

1 

A,Y,M 

instr'(1,A,M,Y); 

mi 

A,M 

instr'(mifA,M); 

ork 

A,Y,M 

instr’(ork,A,M,Y); 


• D 


F,13 Machine Code Insertions 








Version 3.5 
29 March 1991 


Ada/M ?SE ciar.docoK 


In some caseSf A or M register fields do not appear in tne 
MACRO/M instruction because the field is always zero in the 
machine instruction. RO must be used in that field of the record 
aggregate in Ada/M, however, since no missing fields are allowed. 
Here are some examples where that occurs: 

MACRO/M Ada/M 


Ipi M 
Ip Y,M 
sfsc M 


instr'(Ipi,rO,M) ; 
instr'(Ip,rO,M,Y) ; 
instr’(sfsc,rO,M); 


Some MACRO/M mnemonics are ambiguous and are assembled into 
one of two or more opcodes based on the operands specified in the 
instruction. Ada/M opcode mnemonics must be unambiguous, so 
either the letter K (indicating an RK format instruction) or the 
letter X (indicating an RX format instruction) has been added to 
the end of otherwise ambiguous mnemonics. Some examples of this 
are as follows: 

MACRO/M Ada/M 


jz A,Y,M instr ■( j 2 lt»A,M,y); 

jpA,*Y,M instr'(jpx»A,M,Y); 


"or those MACRO/M mnemonics which determine both the opcode 
and either the A or M register, the MACRO/M mnemonic 
(disambiguated as above if necessary) is used for the A or M 
field and an opcode mnemonic is invented. Some examples of this 
are as follows: 

MACRO/M Ada/M 


pr A 
drtr A 
sqr A 
jne Y,M 
her 


instr'(ua_opcode,A,pr); 
instr'(ua”opcode,A,drtr); 
instr’(us_opcode,A,sqr); 
instr ' (cjk_opcode, jnelc,M,Y); 
instr’(ec_opcode,hcr,rO)? 


F-46 


F,13 Machine Code Insertions 













AQd/ n rac. -leir.aDCCK 


Ve r 3 .C- 
29 Marcr. 


You must be able to include data as well as instructions 
machine code. The MACHINE CODE pactcage defines record types 
which allow you to create Indirect words, signed bytes, unsig 
bytes, words, double words, and floating point numoers. The 
format for including data is as follows: 

Data Ada/M 


indirect word (iw J,Y,X) ind.rect_word’(J,X,Y); 

unsigned byte (0 .. 255) unsigned_byte value'(VALUE); 

word (16-bit value) word_value’(VALUE): 

double word {32-bit value) do-ubxe_word_value’(VALUE) ; 
float value (32-bit value) float_vaiue'(VALUE); 


Table F-"* uontains a list of MACRO/M instructions and the 
Ada/M machine code equivalents, sorted by MACRO/M mnemonic. 


F.13 Machine Code Insertions 






Version i.5 
29 March 1991 


AOd, ?SE Hdr.aocc< 


MACRO/M 

Ada/M 


a A,Y,M 

instr'(a.A.M,Y) ; 


acos A 

instr'(mf opcode,A,acos); 


acr M 

instr■(Ipar.rO,M); 


ad A,Y,M 

instr'(ad.A.M,Y) ; 


aci A,M 

instr'(adi,A.M); 


adr A,M 

instr'(adr,A.M); 


ai A,M 

instr’(ai.A.M); 


an A , Y,M 

instr’(ak.A.M,Y ); 


aid A,Y,M 

instr'(aid,A.M,Y) ; 


aldr A,M 

instr■(aldr,A.M); 


alog A 

instr'(mf opcode,A,alog); 


als A,Y,M 

instr'(als.A.M.Y); 


alsr A.M 

instr‘(alsr,A.M); 


and A,Y,M 

instr■(and.A.M.Y) ; 

1 

andi A,M 

instr'(andi,A.M) ; 

1 

1 

andk A,Y,M 

instr'(andk.A.M.Y) ; 


andr A.M 

instr'(andr.A.M); 


ar A.M 

instr■(ar.A.M); 

1 

ard A.Y.M 

instr' ( ard,A.M,Y) ; 


ardr A.M 

instr ' (arar.A.M) ; 


a r s A.Y.M 

instr * (ars.A.M.Y) ; 

1 

arsr A.M 

instr'(arsr,A.M); 


asin A 

instr'(mf opcode,A,asin) ; 

1 

acan A 

instr'(mf opcode-A,atan); 


ba A,£,M 

instr'(ba.A.M.Y); 


be A.Y.M 

instr’(bc.A.M.Y); 

i 

1 

bcl A.M 

instr'(bci.A.M); 

i 

bex A.Y.M 

instr'(bcx.A.M.Y); 

1 

bexi A/M 

instr’(bcxi.A.M); 

1 

bf Y.M 

instr'(bf . rO.M.Y); 


bfi M 

instr ’ (bfi.rO.M) ; 

i 

bl A,Y,M 

instr ’ (bl.A.M.Y) ; 


bl:. A.M 

instr'(bli.A.M) ; 


blx A.Y.M 

instr ' (blx.A.K,Y) ; 


blxi A.M 

insti '( blxi.A.M) ; 


bs A.Y.M 

instr ' (bs.A.M.Y) ; 


bsi A.M 

instr'(bsi.A.M) ; 

! 

bsu A.Y.M 

instr ' (bsu.A.M.Y) ; 

1 

bsx A.Y.M 

instr ' (bsx.A.M,Y) ; 


bsxi A.M 

instr ' bsxi.A.M) ; 


built-in test - dec 

instr'(bit opcode.dec); 


built-in test - eec 

inntr’ 1 bit_opcode.eec); 

•4 


Table F-3a - Machine Code Instructions 


F-48 


F.13 Machine Code Insertions 










Aaa/M Fiji aar.aocoK 


Vers^or. j, . 
29 Marcr. 199 


+— 

1 

MACRO/M 



Ada/M 


built-in test 

- 

icp 

instr'{bit opcode,ico); 


built-in test 

- 

ids 

instr'(bit opcode,ids); 


built-in test 

- 

imp 

instr'(bit opcode,imp); 


built-in test 

- 

Irm 

instr'(bit opcode,Irm); 


built-in test 

- 

rscs 

instr'(bit opcode,rscsj; 

1 

Duilt-in test 

- 

sei 

instr'(bit opcode,sel); 


built-in test 

- 

srm 

instr'lbit opcode,srm); 


C A,Y,M 



instr'(c,A,M,Y); 


cbr A,M 



instr'(cbr,A,M); 


ccr A,M 



instr'(Ipar,A,M); 


cd A,Y,M 



instr'(cd,A,M,Y); 


cdi A,M 



instr’(cdi,A,M); 


cdr A,M 



instr’(cdr,A,M); 


ci A,M 



instr’(ci,A,M); 


ck A,Y,M 



instr'(ck,A,M,Y); 


cl A,Y,M 



instr'(cl,A,M,Y); 


cld A,Y,M 



instr ’ (cld,A,M,Y) ; 


cldr A,M 



instr '( cldr,A,M) ; 


cli A,M 



instr ’( cli, a,M) ; 


elk A,Y,M 



instr ’ (elk,A,M,Y); 

1 

clr A,M 



instr'{clr,A,M); 


els A/Y,M 



instr’(els,A,M,Y); 


clsr A,M 



instr '( clsr,A,M) ; 


cm A,Y,M 



instr '( cm,A,M,Y ); 


cmi A,M 



instr ’{ cmi , A,M) ; 


cmk A,Y,M 



instr ’ (cmk,A,M,Y) ; 


cmr A,M 



instr '( cmr , A,M) ; 


ent A 



instr'(us opcode , A,ent ); 


cos A 



instr'(mf opcode,A,cos) ; 


cr A,M 



instr '( cr , A,M) ; 


d A,Y,M 



instr ' (d,A,M,Y) ; 


data - double 

word 

double word value ' (VALUL) ; 


data - float 



float value ' (VALUE) ; 


data - signed 

byte 

signed byte value ' (VALUE) ; 


data - unsigned 

byte 

unsigned byte value'(VALUE); 


data - word 



word value'(VALUE); 


dcir 



instr' (uc opcode,rO,dcir); 


dcr 



instr' (uc opcode,rO,dcr); 


dd A,Y,M 



instr'(dd,A,M,Y); 


ddi A,M 



instr'(ddi,A,M) ; 


ddr A,M 



instr'(ddr,A,M); 


di A,M 



instr'(di,A,M); 


dk A,Y,M 



instr'(dk,A,M,Y); 


+• 


Table F-3b - Machine Code Instructions (Continued) 


F.13 Machine Code Insertions 











Version 3.5 
29 March 1991 


Ada/M ?S£ Hancbcc^ 


1 MACRO/M 

Ada/M 

dm 

instr’ 

(uc opcode,rO,dm); 

dr A,M 

instr' 

(dr,A,M); 

dror A 

instr' 

(ua opcode,A,dror ); 

drtr A 

instr' 

{ua_opcode,A,drtr); 

ecir 

instr' 

(uc opcode,rO,ecir ) ; 

ecr 

instr ’ 

(uc_opcode,rO,ecr ) ; 

er A 

instr‘ 

(uc opcode,A,er ); 

exp A 

instr ' 

(mf opcode,A,exp); 

fa A,Y,M 

instr ' 

(fa,A,M,Y); 

fai A,M 

instr‘ 

(fai,A,M); 

far A,M 

instr ‘ 

(far,A,M); 

fc A,Y 

instr’ 

(mp opcode,A,fc); 
wor3 value'(Y) ; 

fd A,Y,M 

instr' 

(fd,A,M,Y); 

fdi A,M 

instr ' 

(fdi,A,M); 

fdr A,M 

instr' 

(fdr,A,M); 

flc A 

instr' 

(mp opcode,A,flc) ; 

fled A 

instr ' 

(mp opcode,A,fled); | 

fm A,Y,M 

instr ' 

(fm,A,M,Y); 

fmi A,M 

instr ' 

(fmi,A,M); 

fmr A,M 

instr ’ 

(fmr,A,M); 

fsu A,Y,M 

instr’ 

(fsu,A,M,Y); 

fsui A,M 

instr' 

(fsui,A,M); 

fsur A,M 

instr' 

( fsur,A,M); 

fxc A 

instr' 

(mp opcode,A,fxc) ; \ 

fxed A 

instr’ 

(mp_opcode,A,fxed) ; 

ib A 

instr' 

(us opcode,A,ib); 

ick A,Y 

instr' 

(e6_opcode,A,ick,Y); 

ioc A,Y,M 

instr' 

(iocr,A,M); 
word value'(Y); 

iocr 

instr’ 

(iocr,rO, rO ); 

iror A 

instr' 

(ua opcode,A,iror); 

irtr A 

instr’ 

(ua opcode,A,irtr ) ; 

is A 

instr' 

(us opcode,A,is); 

iw Y,Y,X 

indirect word'(J,X,Y); 

j *Y,M 

instr' 

(C]x__opcode, jx,M); 

j Y,M 

instr’ 

(cjit opcode, jk,M); 

jb *Y,M 

instr' 

(cjx opcode,jbx,M); 

jb y,M 

instr' 

(cjk opcode,jbk,M); 

jbr M 

instr' 

(cjr^opcode,jbr,M); 

jc *Y,M 

instr’ 

(cjx opcode,jcx,M); 

jc Y,M 

instr' 

( c j k^opcode,j ck,M); 

jer M 

instr' 

(cjr__opcode, jer ,M) ; 

je *Y,M 

instr’ 

(cjx_opcode,jex,M); 

je Y,M 

instr ' 

(c jk__opcode, jek ,M); 


Table F-3c - Machine Code Instructions (Continued) 


F~50 


F.13 Machine Code Insertions 















Ada/M PSE Handbook 


Version 3. 
29 Marcn 199 


1 MACRO/M 

Ada/M 

jer M 

instrMcjr opcode, :er ,M ); 

jge *Y,M 

instr'(cjx opcode,jgex,M) ; 

jge Y,M 

instr'(cjk opcode , :ge.< , M) ; 

]ger M 

instr'(C]r opcode,:ger,M ) ; 

iks 

instr'(cjx opcode,jksxi, M ); 

iks i,Y,M 

instr'(cjk opcode, j kskl,M j; 

jks 2,*Y,M 

instr'(cjx opcode,:ksx2,M); 

]ks 2,Y,M 

instr'(cjk opcode,jksx2,M); 

3 ksr 1,M 

instr'(cjr opcode,3Ksri,M) ; 

jksr 2,M 

instr‘(cjr opcode,jKsr2,M) ; 

jlm *Y,M 

instr '( jlrax,rO,M,Y) ; 

jlm Y,M 

instr '( jlmk,rO,M,Y) ; 

jlr A,*Y,M 

instr '( jlrx,A,M,Y) ; 

jir A,Y,M 

instr ’( jlrk,A,M,Y) ; 

jlrr A,M 

instr ’( jlrr,A,M) ; 

jls *Y,M 

instr'(cjx opcode,jlsx,M) ; 

jls Y,M 

instr'(cjk opcode,jlsk,M) ; 

jlsr M 

instr'(cjr opcode,jlsr,M) ; 

jn A,*Y,M 

instr '( jnx,A,M,Y) ; 

jn A,Y,M 

instr '( jnk,A,M,Y ); 

]ne *Y,M 

instr'(cjx opcode,jnex,M); 

]ne Y,M 

instr'(c^k opcode,]nek,M); 

jner M 

instr'(cjr_opcode,jner,M); 

jnr A,M 

instr'(jnr,A,M); 

jnz A,*Y,M 

instr'(jnzx,A,M,Y); 

jnz A,Y,M 

instr’(jnzk,A,M,Y); 

jnzr A,M 

instr'(jnzr,A,M); 

jo *Y,M 

instr'(cjx_opcode,jox,M); 

jo Y,M 

instr'(cjk_opcode,jok,M); 

jor M 

instr'(cjr opcode,jor,M); 

jp A,*Y,M 

instr'(jpx,A,M,Y); 

jp A,y,M 

instr’(jpk,A,M,Y); 

jpr A,M 

instr'(jpr,A,M); 

jpt *Y,M 

instr'(cjx opcode,jptx,M); 

jpt Y,M 

instr'(cjk opcode,jptk,M); , 

jptr M 

instr’(cjr_opcode,jptr,M); 

jr M 

instr'(cjr opcode,jr,M); I 

js *Y,M 

instr'(cjx opcode,jsx,M); , 

js Y,M 

instr'(cjk opcode,jsk,M); 

jsr M 

instr'(cjr opcode,jsr,M); 

jz A,*Y,M 

instr'(jzx,A,M,Y); 

jz A,Y,M 

instr'(jzk,A,M,Y ): 

jzr A,M 

instr'(jzr,A,M ); 


Table F*-3d - Machine Code Instructions (Continued) 


F.13 Machine Code Insertions 

















Version 3.5 
29 March 1991 


Ada/M ?SE riar.dDcc< 


1 MACRO/M 

Ada/M ; 

1 A,Y,M 

instr'(1,A,M,Y); 

la A,M 

instr'(la,A,M); 

lad A,M 

instr‘(lad,A,M); 

laid A,M 

instr'(laid,A,M); 

lals A,M 

laser'(lals,A,M); 

lard A,M 

instr'(lard,A,M); 

lari A,M 

instr'(lari,A,M); 

larm A,Y,M 

instr'(larm,A,M,Y); 

larr A,M 

instr'(larr,A,M); 

lars A,M 

instr’(lars,A,M); 

Ibxi A,Y,M 

instr'(Ibxi,A,M,Y); 

Ic A,M 

instr'(Ic,A,M); I 

Icep A 

instr'(us opcode,A,Icep): 

Iclc A,M 

instr’(Iclc,A,M); 

Icld A,M 

instr'(Iclc,A,M); 

Icr A 

instr'(uc opcode,A,Icr); 

Icrd A 

instr'(uc opcode,A,Icrd); 

Id A,Y,M 

instr'(Id,A,Y,M); ' 

Idi A,M 

instr'(Idi,A,M); i 

Idiv A,M 

instr'(Idiv,A,M); 

Idx A,Y,M 

instr'(ldx,A,M,Y); 

Idxi A,M 

instr'(Idxi,A,M); 

lem A 

instr'(uc opcode,A,lem); 

li A,M 

instr'(li,A,M); 

lir A,M 

instr'(lir,A,M); i 

Ij D 

instr'(1j »D); 
instr'(1je,D); 
instr'(1jge,D); 
instr’(1ji,D); 

Ije D 

Ijge D 

Iji D 

Ijlm D 

instr'(1jlm,D); 
instr'(1jls,D); 

Ijls D 

Ijne D 

instr'(1jne,D); 

Ik A,Y,M 

instr'(Ik,A,M,Y); 

11 A,M 

instr'(11,A,M); 

llrd A,M 

instr'(llrd,A,M); 

llrs A,M 

instr'(llrs,A,M); 

Iffl A,Y,M 

instr'(Im,A,M,Y); 

Intap A,Y,M 

instr'(lmap,A,M,Y); 

lor A,Y,M 

instr'(Imr,A,M,Y); 

IJBUl A,M 

instr'(Imul,A,M); 

Ip Y,M 

instr ' (Ip, rO,M,-Y); 

Ipa A,Y,M 

instr'(lpa,A,M,Y ); 

lr>ai A,M 

instr'(Ipai,A,M); 


Table F-3e - Machine Code Instructions (Continued) 


F-52 


F.13 Machine Code Insertions 













Aaa/M c'ac aanaoooK 


Version 3. 
29 March 199 


1 MACRO/M 

Ada/M 

Ipak A,Y,M 

instr'(lpak,A,M,Y); 

Ipar A,M 

instr '{ Ipar,A,M) ; 

Ipi M 

instr’ ( Ipi,rO,M) ; 

Ipl A,Y,M 

instr '( Ipl,A,M,Y ) ; 

Ipli A,M 

instr '( lpii,A,M) ; 

Ipr A 

instr'(uc opcode,A, Ipr); 

Ir A,M 

instr'(Ir,A,M); 

Ird A,Y,M 

instr'(lrd,A,M,Y); 

Irdr A,M 

instr' ( Irdr,A,M) ; 

irs A,Y,M 

instr ’( lrs,A,M,Y) ; 

Irar A,M 

instr '( Irsr,A,M) ; 

Isor A 

instr'(uc opcode,A,Isor ); 

Istr A 

instr'(uc opcode,A,Istr ); 

Isu A,M 

instr '( lsu,A,M) ; 

Isud A,M 

instr '( Isud,A, M); 

lx A,Y,M 

instr ■( lx,A,M,Y) ; j 

Ixi A,M 

instr '( Ixi,A,M) ; 

m A,Y,M 

instr ' (m,A,M,Y) ; ; 

mb A,M 

instr ‘ (mb,A,M) ; i 

mdi A,M 

instr'(mdi,A,M); 

mdm A,Y,M 

instr'(mdm,A,M,Y); 

mdr A,M 

instr'(mdr,A,M); 

mi A,M 

instr'(mi,A,M); i 

mk A,Y,M 

instr'(rak,A,M,Y); 1 

mr A,M 

instr'(mr,A,M); ' 

ms A,Y,M 

instr'(ms,A,M,Y); 

msi AfM 

instr'(msi,A,M); 

msk A,Y,M 

instr’(msk,A,M,Y)? 

msr A>M 

instr'(msr,A,M); 

nf A 

instr'(mp_opcode,A,nf); j 

instr'(ua opcode,A,nr); I 

nr A 

ock A,Y 

instr'{e6 opcode,A,ock,Y); 

ocr A 

instr'(ua opcode.-A,ocr); 

or A,Y,N 

instr'(or,A,M,Y); 

ori A,N 

instr'(ori,A,M ); 

ork A,YrN 

instr'(ork,A,M,Y); 

orr A,M 

instr'(orr,A,M); 

pr A 

instr'(ua opcode,A,pr); 

qal A,Y 

instr'(mp_opcode,A,qal); 

word value'(Y); ! 

qar A,Y 

instr'(mp_opcode,A,qar); > 

word value' (Y); ' 

qqt A,Y,M 

instr'(qqt,A,M,Y]; 1 

instr'(qpb,A,M,Y] ; j 

qpb A,Y,M 


Table F-3f - Machine Code Instructions (Continued) 


F.13 Machine Code Insertions 











Version 3.5 
29 March 1991 


Ada/M PSE HandoooK 


MACRO/N 

Ada/M 

qpt A,Y,M 

instr'(qpt,A,M,Y); 

rex Y,M 

instr'(rex,rO,M,Y); 

rf A 

instr'(mp opcode,A,rf); 

rfp A 

instr'(mp_opcode,A,rfp); 

rh A 

instr’(mp opcode,A,rh); 

rhp A 

instr'(mp_opcode,A,rhp); 

rim A,Y,M 

instr'(smap,A,M,Y); 

rr A 

instr'{ua opcode,A,rr); 

rvr A 

instr'(us opcode,A,rvr); 

S A,Y,M 

instr’(s,A,M,Y); j 

sari A,M 

instr'(sari,A,M); 

sarm A,Y,M 

instr'(sarm,A,M,Y); 

sarr A,M 

instr'(sarr,A,M); 

sbr A,M 

instr'(sbr,A,M); 

sbxi A,Y,M 

instr'(sbxi,A,M,Y); 

scr A 

instr'(uc opcode,A,scr); 

scrd A 

instr'(uc opcode,A,scrd); 

sd A,Y,M 

instr'(sd,A,M,Y); 

sdi A,M 

instr'(sdi,A,M); 

sdx A,Y,M 

instr'(sdx,A,M,Y); 

sdxi A,M 

instr‘(sdxi,A,M); 

sedr A,M 

instr’(sedr,A,M); 

ser A,M 

instr'(ser,A,M); 

sfr A 

instr'(us_opcode,A,sfr); 

sgt A,Y,M 

instr’(sgt,A,M,Y); 

si A,M 

instr'(si,A,M); 

sin A 

instr'(mf_opcode,A,sin); 

sir A,M 

instr'(sir,A,M); 

sm A,Y,M 

instr'(sm,A,M,Y); 

smap A,Y,M 

instr'(smap,A,M,Y); 

smc A 

instr*(us opcode,A,smc); 

smr A,Y,M 

instr*(smr,A,M,Y); 

spl A,Y,M 

instr *(spl,A,M,Y); 

spli A,M 

instr'(spli,A,M); 

spt A,Y,M 

instr'(spt,A,M,Y)r 

sqr A 

instr* (us__opcode,A,sqr); 

sqrt A 

instr*(us_opcode,A,sqrt) ; 

saor A 

instr*(uc opcode,A,ssor); 

sstr A 

instr*{uc_opcode,A,sstr); 

SU A,Y,M 

instr *(su,A,M,Y); 

sud A,Y,M 

instr *(sud,A,M,Y); 

sudi AfM 

instr'(sudi,A,M); 

sudr A,M 

instr *(sudr,A,M); 


Table F-3g - Machine Code Instructions (Continued) 


F-54 


F.13 Machine Code Insertions 








Had/n rS£. adiluooOK 


'version 3.5 
29 March 1991 


F.13 


1 MACRO/M 

Ada/M 

sui A,M 

instr'(sui,A,M); 

suk A,y,M 

instr'(suk,A,M,Y); 

sur A,M 

instr'(sur,A,M); 

SX A,Y,M 

instr'{sx,A,M,Y); 

sxi A,M 

instr'{sxi,A,M); 

S2 Y,M 

instr'{sz,rO,M,Y); 

szi M 

instr'(szi,rO,M); 

tan A 

instr'(mf opcode,A,tan) 

tcdr A 

instr'(ua opcode,A,tcdr 

ter A 

instr'(ua opcode,A,ter) 

vf A 

instr'(mp opcode,A,vf); 

vfp A 

instr'(mp opcode,A,vfp) 

vh A 

instr'(mp opcode,A,vh); 

vhp A 

instr'(mp opcode,A,vhp) 

wem A,Y,M 

instr'(Imap,A,M,Y); 

wemk AM,Y 

instr'(e6 opcode,A,M,Y) 

wim A,Y,M 

instr'(Imap,A,M,Y); 

wirak A,Y,M 

instr'(e6 opcode,A,M,Y) 

xj A,*Y,M 

instr'(xjx,A,M,Y); 

xj A,Y,M 

instr'(xjk,A,M,Y); 

xjr A,M 

instr'{xjr,A,M); 

xor A,Y,M 

instr'(xor,A,M,Y); 

xori A,M 

instr'(xori,A,M); 

xork A,Y,M 

instr'(xork,A,M,Y) ; 

xorr A,M 

instr'(xorr,A,M)? 

xsdi A,M 

instr' ( xsdi,A,M) ; 

xsi A,M 

instr '( xsi,A,M); 

zbr A,M 

instr'(zbr,A,M); 


Table F-3h - Machine Code Instructions (Continued) 


Machine Code Insertions 







