NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



THESIS 


A TYPE INFERENCE ALGORITHM 
AND TRANSITION SEMANTICS 
FOR POLYMORPHIC C 

by 

Mustafa Ozgen 
September 1996 

Thesis Advisor: Dennis Volpano 


Approved for public release; distribution is unlimited. 


DTIC QTJALITy mSEBCTBD 4 

19961202 034 I 







REPORT DOCUMENTATION PAGE 

Form Approved 

OMB No, 0704^188 

Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time reviewing instructbns, searching existing data sources 
gathering and maintaining the data needed, and completing and reviewing the collection of information. Send comments regarding thfe burden estimate or any other aspect of thfe 
collection of information, including suggestions for reducing this burden to Washington Headquarters Services, Directorate for Information Operations and Reports, 1215 Jefferson 

Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project (0704-0188), Washington, DC 20503. 

11. AGENCY USE ONLY (Leave Blank) 12. REPORT DATE 

1 1 September 1996 

13. REPORT TYPE AND DATES COVERED 1 

1 Master’s Thesis | 

4. TITLE AND SUBTITLE 

A Type Inference Algorithm And Transition Semantics For Polymorphic C 

5. FUNDING NUMBERS 

6. AUTHOR(S) 

Ozgen, Mustafa 

7. PERFORMING ORGANIZATION NAME(S) AND ADORESS(ES) 

Naval Postgraduate School 

Monterey, CA 93943-5000 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

9. SPONSORING/ MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

10. SPONSORING/ MONITORING 

AGENCY REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

The views expressed in this thesis are those of the author and do not reflect the ofl&cial policy or position of the Department of 
Defense or the United States Government 

12a. DISTRIBUTION / AVAILABILITY STATEMENT 

Approved for public release; distribution is unlimited. 

12b. DISTRIBUTION CODE 

13. ABSTRACT (Maximum 200 words) 

In an attempt to bring the ML-style type inference to the C programming language, Smith and Volpano developed a type 
system for a dialect of C, called PolyC [SmV96a] [SmV95b]. PolyC extends C with ML-style polymorphism and a limited 
form of higher-order function. 

Smith and Volpano proved a type soundness theorem that basically says that evaluation of a well-typed PolyC program 
cannot fail due to a type mismatch. The type soundness proof is based on an operational characterization of a special kind of 
semantic formulation called a natural semantics. This thesis presents an alternative semantic formulation, (^ed a transition 
semantics, that could be used in place of the natural semantics to prove type soundness. The primary advantage of the transition 
semantics is that it eliminates the extra operational level, but the disadvantage is that it consists of many mote evaluation rules 
than the natural semantics. Thus it is unclear wheter it is a suitable alternative to the two-level tpproach of Smith and Volpano. 

Further, the thesis gives the first full type inference algorithm for the type system of PolyC. Despite implicit vari^le 
dereferencing found in PolyC, the algorithm turns out to be a rather straightforward extension of Damas and Milner’s algorithm 

W |DaM82]. The algorithm has been implemented as an attribute grammar in Granunatech’s SSL and a complete source code 
listing is given in the Appendix. 

14. SUBJECT TERMS 

programming language, polymorphism, type inference, semantics, transition semantics. 

|15. NUMBER OF PAGES 

126 

1&. t^i^icE d&5E 

17. SECURITY CLASSIFICATION 18. SECURITY CLASSIFICATION 

OF REPORT OF THIS PAGE 

Unclassified Unclassified 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

Unclassified 

20. LIMITATION OF ABSTRACT 

UL 


NSN 7540-01-280-5500 Standard Form 298 (Rev. 2-89) 


Prescribed by ANSI Std. 239-18 
















11 




Approved for public release; distribution is unlimited 


A TYPE INFERENCE ALGORITHM AND 

TRANSITION SEMANTICS 
FOR POLYMORPHIC C 

Mustafa Ozgen 

Lieutenant Junior Grade, Turkish Navy 
B.S., Turkish Naval Academy, 1990 


Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF SCIENCE IN COMPUTER SCIENCE 

from the 

NAVAL POSTGRADUATE SCHOOL 
September 1996 


Author: 


Approved by: 



Department of Computer Science 


111 



i 


IV 



ABSTRACT 


In an attempt to bring the ML-style type inference to the C programming 
language, Smith and Volpano developed a type system for a dialect of C, called 
PolyC [SmV96a] [SmV96b]. PolyC extends C with ML-style polymorphism and a 
limited form of higher-order function. 

Smith and Volpano proved a type soundness theorem that basically says that 
evaluation of a well-typed PolyC program cannot fail due to a type mismatch. The 
type soundness proof is based on an operational characterization of a special kind of 
semantic formulation called a natural semantics. This thesis presents an alternative 
semantic formulation, called a transition semantics, that could be used in place of the 
natural semantics to prove type soundness. The primary advantage of the transition 
semantics is that it eliminates the extra operational level, but the disadvantage is 
that it consists of many more evaluation rules than the natural semantics. Thus, it 
is unclear whether it is a suitable alternative to the two-level approach of Smith and 
Volpano. 

Further, the thesis gives the first full type inference algorithm for the type 
system of PolyC. Despite implicit variable dereferencing found in PolyC, the algorithm 
turns out to be a rather straightforward extension of Damas and Milner’s algorithm 
W for functional languages [DaM82]. The algorithm has been implemented as an 
attribute grammar in Grammatech’s SSL and a complete source code listing is given 
in the Appendix. 



vi 



DISCLAIMER 


The computer program in the Appendix is supplied on an “as is” basis, with 
no warrantees of any kind. The author bears no responsibility for any consequences 
of using this program. 


Vlll 



TABLE OF CONTENTS 


I. INTRODUCTION. 1 

A. MACRO-BASED POLYMORPHISM. 2 

B. ML-STYLE POLYMORPHISM. 2 

C. TYPE SYSTEMS AND TYPE SECURITY. 3 

1. Hindley/Milner Type System. 4 

a. Parametric Polymorphism. 5 

b. Type Inference. 5 

c. Soundness and Completeness. 6 

II. THE POLYMORPHIC C LANGUAGE. 7 

A. THE TYPE SYSTEM. 9 

1. Examples of Type Inference. 12 

III. THE TYPE-INFERENCE ALGORITHM . 15 

A. SUBSTITUTION AND UNIFICATION . 15 

B. ALGORITHM Wc. 16 

1. Sample Type Inference with ITc. 20 

2. Correctness Criteria for Wc . 23 

IV. TRANSITION SEMANTICS FOR POLYC. 25 

A. STRUCTURAL OPERATIONAL SEMANTICS OF POLYC . . 25 

B. TRANSITION SEMANTICS FOR POLYC . 27 

1. Definitions. 27 

2. The Transition Rules. 27 

3. Two Examples of Program Evaluation. 32 

4. The LOOP Rule. 36 

C. CONCLUSION. 38 

V. CONCLUSIONS AND FUTURE WORK. 39 

A. CONCLUSIONS . 39 


IX 




























1. Type Inference Algorithm . 39 

2. The Transition Semantics. 39 

B. FUTURE WORK. 39 

1. Formal Soundness Proof. 39 

2. Extending PolyC. 40 

APPENDIX. SOURCE PROGRAM FOR THE INTERPRETER . . 41 

1. REMARKS. 41 

2. SSL CODE FOR THE INTERPRETER. 41 

LIST OF REFERENCES .Ill 

INITIAL DISTRIBUTION LIST .113 


X 













ACKNOWLEDGMENTS 


I would like to thank Dr. Dennis Volpano for his help, advice and time during 
this research work. His examples of professional competency and attention to detail 
will help guide me in my future work. 

I would also like to thank Dr. Craig Rasmussen for his assistance in editing 
and correcting my work. 


XI 



i 


xii 



I. 


INTRODUCTION 


If one studies some of the well-known algorithms in Computer Science carefully, 
it becomes clear that some do not make any assumptions about the structure of the 
objects they manipulate. In other words, the algorithm can be generalized to objects 
of infinitely many different types. For instance, a sorting algorithm works for any type 
of value provided that an ordering relation can be defined for the values of the type. 
Also, a function, say length, that finds the length of a list object, is not concerned with 
the structure of the list elements. The result is always a natural number regardless 
of the type of the elements in the list. So the length function is polymorphic in the 
sense that it can work on infinitely many different types. What we gain from this 
generalizability property is that the function can have the same source code, or for 
that matter, the same executable(binary) for each different type of list. 

An implementation of length in ML is given by the program below: 

fun length [] = 0 

I length (x ::xs) = 1 + length xs ; 

How can we express this polymorphic behaviour in the type of length"! Since the type 
of the list elements is not relevant to the computation, we introduce a type variable 
to denote the type of list elements and bind it with a universal quantifier. The type 
of length is then written as 

V 7.7 list —» int . 

By instantiating the type variable 7 in this type formula with different types, we 
can specialize the type of the function for different lists. For instance, following type 
formulae show two different specializations, one for integer list, and one for real list: 

int list —> int 
real list real 


1 



We contrast different forms of polymorphism in modern programming lan¬ 
guages below. 

A. MACRO-BASED POLYMORPHISM 

Ada and C-j—t- implement the idea of polymorphism in the form of Ada generics 
and C-b-f templates. In these languages, a type parameter for each of the polymorphic 
type variables has to be specified explicitly. Before applying an Ada generic function 
to a value of type r, one has to create a specialized instance of the function for type 
r explicitly in the source program. In C-|—f, instantiation is done by the compiler 
vice the user; but the programmer has to provide the actual type with which the 
parameterized type variable will be instantiated. 

The reason for the earlier specialization requirement is that, in these languages, 
only the same source code is used for a polymorphic function. But for each different 
type of argument, different executable code is generated. This kind of polymorphism 
is syntactic, since the generic instantiation is done at compile time with actual-type 
values that must be available at compile time. Thus, a generic procedure can be 
considered as an abbreviation for a set of monomorphic procedures with the same 
behaviour. This is called macro-based polymorphism. An alternative to macro- 
based polymorphism is parametric polymorphism, as used in Standard ML. The key 
difference is that polymorphic functions have an evaluation semantics. Moreover, 
the same executable code in addition to the same source code can be used for a 
polyniorphic function. 

B. ML-STYLE POLYMORPHISM 

ML does not require programs to be annotated with types by the program¬ 
mer; instead, the type of a program is inferred by the compiler without sacrificing 
the polymorphism. ML-style polymorphism will be discussed in the context of the 
Bindley/Milner system since the ML type system is based on it. 


2 



C. TYPE SYSTEMS AND TYPE SECURITY 

Although we earlier assigned types to the function length, we did not explain 
how these types can be found in a systematic way since it is not always the case that 
programmers construct type-correct programs. In general, we prefer languages that 
verify the type correctness of programs statically, by checking the type correctness of 
every term of a program rigorously (strong typing). The main aim of strong typing 
is to ensure that the values are treated appropriately according to their structures, 
so that the evaluation of a program does not abort because of type errors. If 1 -t- true 
does not make sense with respect to the semantics of a language then one expects 
the compiler find this error before the evaluation of the program. For instance, if + 
denotes the addition of two integer values, then at compile time it should be ensured 
that in an application of +, the parameters are terms of integer type. So we need 
some system of rules which tells us how to give a type to each kind of term in the 
language. 

Such a rule system is known as a type system for the language. Most of the 
type systems are written as natural deduction systems. Below is a typical typing rule 
for function application: 


A h Cl : Ti T2, a h 62 : ti 

A h Cl 62 : T2 


In this rule. 


A h 61 : Ti —> T2 


is called a type judgement and we say that ei has the type ti —> r 2 with respect to 
the assumption set A. Type information for the free identifiers of ei is taken from 
the assumption set A}. If there is no type assumption for a free identifier in the 
assumption set then we say ei is not well-typed or is ill-typed. We say that a term e 


^When the language is extended with imperative features, A has to be extended with the as¬ 
sumptions about the type of memory addresses. This issue will come up in Chapter II. 


3 



is well-typed with respect to A if there is a type r such that A h e : r. An assumption 
set is also called a type environment. 

In an explicitly-typed programming language, where the programs are anno¬ 
tated with type information, type checking ensures that type annotations are consis¬ 
tent with the type system. On the other hand, the types of programs including the 
parameterization of types can be inferred statically by the compiler without requiring 
any type annotations in the source code. This idea is one of the reasons for the huge 
success of ML, which does type inference instead. 

We want programs to run without run-time type errors. For this reason we 
develop two orthogonal systems of rules, namely a type system and a semantics. If the 
type system types a program correctly then the evaluation of this well-typed program 
does not get stuck due a type error. The security from run-time type errors is known as 
the soundness of a type system. The type-soundness proof of a purely functional type 
system is typically more straightforward than that of an imperative type system with 
first-class references(pointers), first-class functions, and polymorphism. Coexistence 
of first-class references and polymorphism is the main source of difficulty, and it 
requires a precise formulation of the polymorphic treatment of references as well as 
a careful formulation of the semantics of a language. Damas’s faulty proof of a type¬ 
soundness theorem [Dam85] is an illustration of this difficulty [Tof90]. 

1. Hindley/Milner Type System 

Hindley’s type discipline [Hin69] introduces type variables in type expressions 
without any quantification. Later, Milner introduced quantification of type variables 
[Mil78]. Damas and Milner gave an application of these ideas in a purely functional 
setting [DaM82]. The Hindley/Milner type system has three important properties: 
parametric polymorphism, type inference and soundness and completeness of type in¬ 
ference. 


4 



a. Parametric Polymorphism 

The polymorphism used in Hindley/Milner system is also called let 
polymorphism, because polymorphic functions are allowed only in the local scope of 
a let construct together with a notion of instantiation. In 

let X = Cl in 62 , 

if 61 has the type r with respect to A then x is assumed to have type <t, which is 
found by quantifying the type variables that occur in r but do not occur free in the 
assumption set A. Then x binds all free occurrences of x in 62 , each of which has as 
its type an instance of cr. 

The Hindley/Milner system imposes a restriction on the quantification: 
all type formulae have to be in prenex normal form] in other words, quantification 
must be done at the outermost level. A type formula in prenex normal form is also 
called a shallow type. 

It should be noted that let x = ei in 62 can be thought of as an abbre¬ 
viation for (Ax. 62)61 as far as the evaluation of these two constructs are concerned. 
But there is a difference between them when it comes to how they are treated by the 
type system. In let x = ei in 62 , ei can be typed polymorphically, but in (Ax. 62 ) 61 , 
61 has to be monomorphic, since otherwise the type formula computed for it would 
not be in prenex normal form! Assume we give ei the type cr, which is universally 
quantified over some type variables, and 62 the type r. Then Ax .62 has to be given 
the type cr ^ r, which is clearly not in prenex normal form. 

b. Type Inference 

There is an efficient algorithm, called W [DaM82], for the type sys¬ 
tem. W determines whether a given program is well-typed and infers the most gen¬ 
eral (principal) type for it. 

Starting from the leaves of the parse tree of a program with an empty 


5 


assumption set^ , W implicitly annotates tlie program with type information and, 
at the end, either finds the principal type of the program, if the program is well- 
typed, or fails. Roughly speaking, a principal type is one from which all other types 
of the program can be derived. In the next chapter we will show, in detail, how an 
extension of W infers types for well-typed programs in Polymorphic C. Restricting 
the type formulae to prenex normal form allows the use of Robinson’s first order 
unification algorithm [Rob65]. 

c. Soundness and Completeness 

In [DaM82] it is shown that W is sound, in the sense that it finds types 
only for well-typed expressions, and complete, in the sense that if a program is a 
well-typed then W finds the most general type for it. 


^Actually, a type assignment process never starts with an empty assumption set if there are 
built-in operations in the language but we would like to consider the emptiness of the assumption 
set in terms of adding a new assumption to the set during the process of type assignment. 


6 



II. THE POLYMORPHIC C LANGUAGE 


This section gives an overview of Polymorphic C. Hereafter we use PolyC 
instead of Polymorphic C as a shorthand. The reader should see [SmV96a] for a 
detailed account of PolyC. 

PolyC is designed to incorporate an advanced polymorphic type system, si- 
miliar to those designed a.s extensions to the core-ML type system, into the widely 
used imperative programming language, C. Unlike other extensions, the PolyC type 
system also captures polymorphic typing of first class pointers. 

PolyC is semantically very close to K&R C [KR78], with the same pointer 
operations, including the address of &, the dereferencing *, and pointer arithmetic. 
The main design rationale was to bring ML-style polymorphism and type security to 
C while keeping the flexibility and simplicity of C. Variables in PolyC are second class 
and implicitly derefenced, while pointers are first class and explicitly dereferenced by 
the * operator. 

As a new feature, functions are first class citizens in PolyC, and, as in C, 
function applications are implemented on a stack without use of static links or displays 
by imposing a restriction on fimctions: The free identifiers of a function must be 
declared at top level; that is, the scope of the declaration must extend all the way to 
the end of the pro^rram[SmVo95]. In C, no automatic variable^ can occur free in a 
function declaration so that a function declaration is closed with respect to the top- 
level (global) identifier set. PolyC establishes the same property via this restriction 
by ensuring that a lambda-bound identifier, or an identifer bound by a let, letvar or 
letarr declaration whose scope does not extend to the end of the program, does not 
occur free in a function. In the program below, the scope of y does not extend to the 


of 


variable that is created as a result of a function application. In other words, the local variables 
a function including its formal parameters. 


7 


end of the program, so Xz.z+y is not closed with respect to top-level identifiers. 

letvar x := letvar j/ := 5 in Xz.z -f y 
in ... 

But this restriction has another consequence: Currying of functions is not al¬ 
lowed anymore. An attribute grammar enforcing the restriction is given in Appendix. 

PolyC does not distinguish between commands and expressions. Every term 
of the language is an expression. A subset of expressions, however, are distinguished 
as Values, which are the syntactic values^ of the language. The core syntax is given 
below. 

{Expr) e ::= u | e(ei,...,e„) | ei := 63 | 

ke I *e I 61 - 1-62 I 61 ( 62 ] I 61 ; 62 I 

while 61 do 62 | 

if 61 then 62 else 63 | 

let a; = 61 in 62 | 

letvar x := 61 in 62 | 

letarr x[ 6 i] in 62 i 

(a, 1) 

(Values) V ::= x | c | Axi,...,x „.6 | (o,0) 

Meta-variable x ranges over identifiers, c over literals (such as integer literals and 
unit), and a over addresses. To be able to catch pointer errors in the semantics, an 
address is designed as a pair (i,j), where i is a segment and j is an offset in that 
segment. The lifetime of a cell ends when the scope of the identifier to which it is 
bound ends. 

Since core PolyC does not support overloading, -|- denotes only pointer arith- 
methic and * denotes dereferencing. The construct letvar binds x to a new cell 

^Syntactic values correspond to non-expansive expressions of [Tofte90], where evaluation of a 
non~expansive expression does not extend the domain of the store function. 



initialized to value of ei; the scope of binding is e-i and the lifetime of the cell ends 
after the evalution of If ej has type r then x has type r vat. Analogously, the 
construct letarr binds a: to a pointer to the first cell of n consecutive uninitialized 
cells where n is a positive integer found by the evaluation of ei; the scope of x is 62 , 
and the lifetime of the array ends after 62 is evaluated. 

Having functions as first class citizens leads to a more flexible syntax than that 
of C. In addition to named functions, users can define anonymous functions easily 
anywhere in the program such as 

let id = \x.x in id {Xy.y + 1 ). 

PolyC does not have an explicit syntax to create uninitialized identifiers of 
pointer type. But it unifies array types and pointers, as in C. Then declaring an 
array of size 1 is the declaration of an uninitialized pointer type identifier. 

Another subtle syntactic difference is in the treatment of the formal parameters 
of a function. In C, formal parameters are considered as local variables of a function, 
whereas they are treated as constants in PolyC. But it is not hard to achieve a C-like 
treatment by declaring new local variables in the body of the function and initializing 
them to the values of the formal parameters. Below, a C function and its PolyC 
version are given in order. 

int f{int x){.. .return x; } 
let / = Ax.letvar x := x in x in ... 

A. THE TYPE SYSTEM 

ML stratifies the types into two levels: the ordinary r — types [data types) 
and a — types {type schemes). PolyC adds another level to this stratification, namely 
P ~ types {phrase types) to establish the second-class status of variables. Types of 
PolyC are given below [SmV96a] : 


9 


T ;:= a I int | unit \ t ptr \ ti x • • • x r„ -> r {data types) 
a ::= Var.cr | r {type schemes) 

p a \ T var {phrase types) 

Meta variable a ranges over type variables. 

Tbe type system is designed as a natural deduction system to assign types to 
expressions. It is given in Figure 1 [SmV96a]. 

In Section B, we saw that the type of a term is found with respect to an 
assumption set A, where A ranges over identifiers and assigns types to free identifiers 
of a term. Having A range over identifiers only is adequate for sound typing in a 
functional setting, but if the language includes assignable locations, then we have to 
be able to implicitly type a location, regarding the value stored in it, to get a handle 
on the soundness of the type system. Intuitively, a location must be given a monotype 
since we can not store different types of values in a location. A thorough discussion 
of the difficulties with references in a polymorphic type system is given in [Tof90]. As 
given in Figure 1, typing judgements have the form 

A ;7 h e : p, 

meaning that expression e has type p, assuming that 7 prescribes phrase types for 
the free identifiers of e and A prescribes data types for the variables and pointers 
in e. More precisely, meta-variable 7 ranges over identifier typings, which are finite 
functions mapping identifiers to phrase types; 7(x) is the phrase type assigned to x 
by 7 and ')[x : p] is a modified identifier typing that assigns phrase type p to x and 
assigns phrase type 7(0:') to any identifier x' other than x. Similiar conventions apply 
to A(x) and A[x ; p] [SmV96a]. 

Generalization of data type r with respect to A and 7 is denoted by Close\-~f{T ) 
and is equivalent to the type scheme Va. r, where a is the set of all type variables 
occurring free in r but not in A or in 7 . We write A h e : r and Close\{T ) when 7 = 0. 


10 



(var-id) 

A; 7 h a; : r var j{x) = t var 

(ident) 

A; 7 h a: ; T 7(2:) > t 

(ptr) 

^‘,7^ {{hj),0):T ptr X{i) = T 

(var) 

X]j\-({iJ),l):Tvar X(i) = t 

(LIT) 

A; 7 h c : int c is an integer literal 


A;7 h unit : unit 

(-h-INTRO) 

A;7[^i : Ti,. .. : t„] h e : r 

A;7 h Aa:i,...,a:„.e : Ti x • • • x r„ r 


A; 7 h 6 : Ti X • • • X T, 

A;7 h e,- : Tj-, 1 <i <n 

A;7 h e(ei,...,e„) : r 

(let-val) 

A;7 h u : Ti, A;7[a: : Close h e : T2 

A; 7 h let X = u in 6 : T2 

(let-ord) 

A; 7 t- 61 : Ti, A;7[x : ri] h 62 : r2 

A; 7 h let X = 61 in 62 : T2 

(letvar) 

A;7 h 61 : Ti, A;7[x : ti var] H 62 : r2 

A; 7 h letvar x := ei in 62 ; T2 

(letarr) 

A;7 h 61 : int, A;7[x : Ti ptr] F 62 : r2 

A;7 h letarr x[6i] in 62 : T2 

(r-val) 

A; 7 h 6 : r var 

A;7 h 6 : r 

(l-val) 

A; 7 h 6 : r ptr 

A;7 h *e : r var 

(address) 

A; 7 h e : r var 

A; 7 h &:6 : r ptr 

(assign) 

A; 7 h 61 : T var, A; 7 F 62 : r 


A; 7 H d := 62 : r 


Figure 1. Rules of the Type System, continued next page 


11 


(arith) 

A; 7 h ei ; r ptr, A; 7 h 63 : int 

(subscript) 

A; 7 h Cl -h 62 : T ptr 

A; 7 h Cl : r ptr, A; 7 h 63 : int 

(while) 

A; 7 h ei[e2] : r var 

A; 7 h ei : int, A; 7 h 63 : r 

(compose) 

A; 7 h while ei do 63 : unit 

A; 7 h ei : Ti A; 7 h 63 : rs 


A;7 h ei;e2 : T 2 


Figure 2. Rules of the Type System, cont. 

Typing a let construct is done via two rules, namely LET-VAL and LET-ORD. 
If ei is a syntactic value then LET-VAL is used and x is given a phrase type by 
genaralizing the type of e\. On the other hand, LET-ORD is defined for the cases 
where ei is not a syntactic value and no type generalization is allowed. Regarding 
these two rules, all of the type variables in PolyC can be seen as imperative(weak) 
when compared to Standard ML type system [Tof90]. 

1. Examples of Type Inference 

Consider the program 

let id = Xx.x in id{Xy.y + 1 ) ;id(3) . 

We start with empty domains for A and 7 . The LET-VAL typing rule is the first one 
to start with since Xx.x is a value. By the first premise of LET-VAL, Xx.x is given 
the type a a. We extend 7 with x : Vo;, a —^ o; by closing a a with respect 
to A and 7 , and try to type the sequence id(Xy.y -t-1); id{3). The first expression of 
the sequence is typed using — ^-ELIM. We instantiate id cis /3 /3 and Xy.y -f 1 is 

given the type ( ptr —> ( ptr. Rule — >-ELlM requires /? and ( ptr be the same, so we 
unify them with representative type ( ptr. The second expression is also typed by 
^-ELIM. We instantiate id to ^ ^ this time, and 3 has type int. By —>-ELIM, ^ 


12 



and int are unified to int. So the result of the application has type int. Then by 
COMPOSE, id{\y.y + 1); id[Z) is given the type int. Since, the hypotheses of LET-VAL 
are satisfied, it is deduced that the program has the type int. 

The program below shows how the type system prevents memory locations 
from being treated polymorphically. 

letvar id := Xx.x in id Xy.y + 1 ; let id' = id in id'{3) 

We start with the LETVAR typing rule and give the type a —Of to Aa:.a:. Then we 
extend 7 with id : (a —> a) var and try to type the body of letvar, which is a sequence. 
The first expression of the sequence is typed using ASSIGN. The type {a a) var is 
given to id by 7 , and Xy.y + 1 is given the type ^ ptr I3 ptr . By ASSIGN, a a 
and ^ ptr /3 ptr must be the same. So we unify a and ^ ptr with representative 
type /? ptr. Finally, the assignment is given the type /0 ptr ^ ptr and 7 gives the 
type (/? ptr jd ptr) var to id from now on. 

The second expression of the sequence is a let expression. Since id is an 
identifier we use the LET-VAL typing rule. The type (/? ptr ^ ptr) var is given 
to id by 7 . Since id is in an r-value context, we use rule R-VAL and find the type 
/? ptr -4 0 ptr for id. Then we extend 7 with id': Closex-,~f{0 ptr 0 ptr). 0 occurs 
free in 7 by the fact that it occurs free in the type judgement id : [0 ptr 0 ptr) var 
, so Clo$e\.^{0 ptr —> 0 ptr) = 0 ptr -4 0 ptr. Now, we try to type the body of the 
let expression which is the application id'{Z). The type 0 ptr ^ 0 ptr is given to 
id' by 7 and 3 has the type int. But then — >-ELIM requires 0 ptr and int be the 
same which is not possible. So we conclude that this application is not typable and 
therefore the program is untypable. 

Having first class pointers in the language can lead to the occurrence of dan¬ 
gling pointers. To preserve the flexibility and expressiveness of C, PolyC does not 
prevent the dangling pointers but the semantics catches the dereferencing of a dan¬ 
gling pointer. The program below shows how a reference location escapes from its 
scope by returning the address of the variable y in the body of the inner letvar 


13 



expression, and how the type system assigns a type to this program. 

letvarx := letvar y := \z.z in in (*x)(3) 

We start with the LETVAR typing rule to type the program. The first premise of 
LETVAR requires us to type the inner letvar expression, letvar y := Xz.z in ky . By 
a second use of LETVAR, we give the type a o; to Xz.z, and then by extending 7 
with y : {a a) var, the body of inner letvar, hy, is given the type (or ^ o;) ptr. 
So it is deduced that the inner letvar has the type (a —> a) ptr . Now 7 is extended 
with X : ((a —>■ a) ptr) var, and we try to type the body of the outer letvar. Since 
it is an application, we use — *-ELIM. We type *x by first using R-VAL, then L-VAL 
followed by R-VAL again giving type a a. Since 3 has the type int, we deduce the 
type int for the application and also for the program itself. 

In Chapter III we will show how the semantics prevents the evaluation of this 
program by catching the dereferencing of the dangling pointer stored in x. 


14 



III. 


THE TYPE-INFERENCE ALGORITHM 


In this chapter we present the type-inference algorithm Wc- It is similiar to 
Milner’s algorithm W [DaM82], which is based on unification of type expressions. We 
also present an example type inference produced by the computer implementation of 
Wc- We first give some definitions about substitution and unification. 

A. SUBSTITUTION AND UNIFICATION 

A substitution 5 is a finite set of the form 

[ri/Q:i,r2/Q;2,...,r„/Q;„] 

where the variables o:, (1 < z < n) are distinct. Sp is called the application of 
substitution S to type expression p. The result of Sp is another type expression 
obtained from p by replacing simultaneously each free occurrence of the variable aj, 
1 < z < n in p by T,- , renaming the bound variables of p if necessary, p' is called an 
instance of p. Note that p and p' can be the same if no a,- occurs in r. 

We often write S 2 {S\p) or simply S 2 S\p for the application of the composition 
Si 0 S 2 to p. An empty substitution is written as []. 

A substitution S is called a unifier ioi type expressions pi and p 2 if Spi = Sp 2 - 
We say pi and p 2 are unifiable if there is a unifier for them. 

A unifier S is called the most general unifier of pi and p 2 if for every other 
unifier S' of pi and p 2 there is a substitution S" such that 

S' = So S". 

Unification of type expressions is implemented using Robinson’s first order 
unification algorithm, which returns a substitution U, where U is the most general 
unifier of a pair of type expressions pi and p 2 given as the arguments to the algorithm 
[Rob65]; if pi and p 2 are not unifiable then the algorithm fails to return such a 
substitution. 


15 



B. ALGORITHM Wc 

Wc takes two input arguments, 7 and e, and returns a pair (5, r). As defined for 
the type system, 7 is a finite function mapping identifiers to phrase types. The second 
input argument e is the expression whose type is to be inferred, 5 is a substitution 
and r is the type inferred for e by Wc. The type returned by Wc is a r — type in that 
it is called only in r-value contexts. Since locations do not occur in user programs, 
we do not use a location typing A in Wc- Only 7 is needed to do type inference. 

W ( 7 , e) is defined by cases: 

1 . e is a: 

case 7 (x) = Vai,..., ccn.T 

return ([ ], [A/ofjjT) where /?, is new for each 1 < i < n 
case 7 (x) = r 
return ([ ],t) 
case 7 (x) = r var 
return ([ ], r). 

2 . e is Aa:i,..., Xn.ei 

let {Si,Ti) = PF( 7 [a:i : : /?n],ei) where ^j’s are new 

return x • • • x ^n) ti)- 

3. e is e'(ei,..., e„) then 

let = W(ci,e') 

let(5i,Tx) = TT(5'7,ex) 

let {Sn, Tn) = TT(5n-l5'n-2 ' ' ' 5'l5'7, tn) 

let S" = UnifyiCoT', {Cin x C' 2 T 2 x • • • x Cn-iTn -2 x SnTn-i x r^) 
where (3 is new. 


16 



— ^ 71 ^ 71 —1 * * ' 1 ^ ^ ^ 

return {8773^-1 ■■■ S^S', S"/ 3 ). 

4 . e is let x = ei in 62 

let ( 5 i,Ti) = W(7,e:) 
if ej is a syntactic value then 
let (52, T2) = W{Si'y[x : C7ose5i^(ri)], 62) 
else 

let (52,r2) = l^(5i7[x:ri],e2) 
return (525 i,T2). 

5 . e is letvar x := ei in 62 

let ( 5 i,ri) = W^(7,ei) 

let (52, r2) = W^(5 i7[x : tj vcr],e2) 

return (525 i,T2). 

6. e is letarr x[ei] in 62 then 

let( 5 x,Ti) = W^( 7 ,ei) 
let S' = Unify( ti, int) 

let ( 52 , T2) = W( 5 ' 5 i 7 [x : ^ptr\,e2) where /9 is new 
return ( 525 ' 5 i,r 2 ). 

7 . e is *ei then 

let ( 5 i,ri) = l^(7,ei) 
let S' = Unify{jx, ptr) 
where /? is new 
return ( 5 ' 5 i, 5 '/?). 


17 




8. e is hti then 

case Cl is x 
if 7(x) = T\var then 
return ([],Tiptr) 
else fail 
case Cl is *62 
let ( 5 i,rO = W(7,e2) 
let S' = Unify{Ti, / 3 ptr) where 0 is new 
return [S'Si, S' 0 ptr). 

9 . e is ei := 62 then 

Ccise Cl is X 

if 7(x) = r var then 
let ( 5 i,ri) = f^(7,e2) 
let S' = Unify{ ti^S\t) 
return {S'SxiS'ti). 
else fail 
case Cl is *e' 
let( 5 x,ri) = W(7,e') 
let S' = Unify(Ti, 0 ptr) where 0 is new 
let( 52 ,r 2 ) = W( 5 ' 5 i 7 ,e 2 ) 
let S" = Unify{T2, S2S' 0 ) 
return {S"S2S'Sx, S"t2) 

10. e is Cl + 62 then 

let ( 5 i,Ti) = T^(7,ei) 

let S' = Unify{Ti, 0 ptr) where 0 is new 


18 



let (52,r2) = l^(^'5i7,e2) 
let S" = Unify{T 2 , int) 
return {S"S 2 S'Si, S"S 2 S'^ptr) 

11 . e is ei; 62 then 

let (6'i,Ta) = T^( 7 ,ei) 
let (5'2,T2) = W^(^i 7 ,e 2 ) 
return (5'25'i,r2) 

12 . e is while ei do 62 then 
let(5'i,ri) = W^(7,ei) 
let S' = Unify[ ti, int) 

let ( 52 ,T 2 ) = W"( 5 % 7 , 62 ) 
return {S 2 S'Si,unit) 

Function Unify is the implementation of Robinson’s unification algorithm and 
C'Zo5e5i^(Ti) in case 4 is the generalization of ti with respect to the environment 
found after the application of the substitution to 7. 

Ci in case 3 denotes the composition of substitutions that is applied to the 
type of the ith actual parameter of a function application, where 1 < i < n and n is 
the number of formal parameters. Co is the substitution composition applied to the 
called function. 

We omit the default arm of case statements for simplicity and it corresponds 
to a fail case of Wc. In addition to the explicitly stated fail cases, Wc also fails if 
Unify fails to return a substitution or any subinvocation of Wc fails. 

Array subscripting ei[e 2 ] is a syntactic sugar for *{ei + 62 ) so that we do not 
consider array subscripting as a separate case in Wc- 


19 



The algorithm does not explicitly specify how a “new” type variable is obtained. 
We aissume that there is a global list of used variables, and that new ones are selected 
from those not in that list. 

1. Sample Type Inference with Wc 

An interpreter for PolyC has been written using The Synthesizer Generator 
environment [Gram]. It includes an implementation of Wc and the syntax and the 
natural semantics of PolyC given in [SmV96a] with some modifications. Source code 
for the interpreter is given in Appendix. 

Below is an implementation of a HeapSort algorithm in PolyC [Cor90]. The 
type annotations shown as 

id : cr 

for selected identifiers only are done automatically by the interpreter. 

let Swap : V* 9.(=t=9ptr x +9ptr —> +9) := A(a, b) {let temp = !a in 

la :=!6; 
lb :=lb; 
end } in 

letvar heapSize : int var := 0 

let Heapify : V * 21.(=(=21ptr x int x (*21 x *21 int) unit) 

= A(a, i, comp){letvar left : int var ;= 2 * i + 1 in 

letvar current : int var := i in 
while left < heapSize — 1 do 
if left < heapSize — 1 

then if comp{a[left],a[left+ Ij) 
then largest := left 
else largest := left + 1 


20 



fi 


else largest := left 

fi; 

if comp{a[largest]^ a[current]) then 
Swa'p{k,a[largest], f!za{current\)\ 
current := largest] 
left := 2* current + 1 
else left := heapSize + 1 
fi 
od 

end 

end 
end } in 

let BuildHeap : V * 29.(=(=29ptr x int x (*29 x *29 — ^ int) — ^ unit) 

= A(a, size, comp){heapSize := size] 
letvar i := sizel2 — 1 in 
while i > 0 do 

Heapifyia, i, comp ); 
i := i — \ 
od 

end } in 

let HeapSort : V * 35.(*35ptr x int x (*35 x *35 int) —> unit) 
= A(a, size, comp){BuildHeap{a, size, comp)] 
letvar i := size — 1 in 
while i > 1 do 


21 



5'wap(&a[i], &:a[0]); 
heapSize ;= heapSize — 1; 

Heapify{a, 0, comp)] 
i := i — 1 

od 

end } in 
letarr a[8] in 
a[0] := 12; 
a[0] := 5; 
a[0] := 23; 
a[0] := 8; 
a[0] := 1; 
a[0] := 45; 
a[0] := 17; 
a[0] := 51; 

HeapSort(a, 8, A(a, b) {a > 6}); 

(a[01, (o|ll, (a[2|, («[3J, (a[4), (a[5l, (ale). a[7]))))))) 

end 

end 

end 

end 

end 

end 

val (1, (5, (8, (12, (17, (23, (45, 51))))))) 

: (int X (int x (int X (int X (int X (int X (int X int))))))) 


22 



In type expressions, Cartesian product x binds tighter than arrow —s-; where i 6 
Natural, is a type variable generated by a global new type variable generator function. 
The second line from the last shows the result of the evaluation of the program and the 
last line shows the type of the program. Here we use * to denote integer multiplication 
vice dereferencing, which is denoted by !, and + denotes integer addition vice pointer 
arithmetic, which is denoted by 0. Type quantification is denoted by V as in the type 
of Swap. 

2. Correctness Criteria for Wc 

Due to time constraints on preparation of this thesis, we are not able to pose 
theorems related to correctness of Wc and prove them. Roughly speaking, correctness 
of Wc should be established by showing that Wc is sound (syntactically) and complete. 
By soundness, we mean that if Wc succeeds in finding a type for a PolyC expression 
then that type can be derived for the expression in the type system. By completeness, 
we mean that if an expression of PolyC has a type at all then Wc will succeed in finding 
a type for this expression which is at least as general. 


23 



24 



IV. TRANSITION SEMANTICS FOR 

POLYC 

In this chapter we develop a transition semantics (TS) for PolyC that cap¬ 
tures each single step of the evaluation of an expression. First we will look at the 
motivations behind this type of semantics. 

A. STRUCTURAL OPERATIONAL SEMANTICS OF 
POLYC 

To show the semantic soundness of the type system of PolyC, Smith and Vol- 
pano use the framework of Harper [Har94] and develop the subject reduction property 
using the Structural Operational Semantics(SOS) given in the same paper [SmV96a]. 
But the subject reduction property based on SOS does not expose enough informa¬ 
tion about the course of evaluation of a program, making it difficult to establish a 
semantic soundess result for the type system. SOS defines a relation between the 
expressions and their normal forms but does not explicitly keep track of step-by-step 
construction of the evaluation tree of an expression. Instead, by using the composi- 
tionality property in a coarse-grained sense, it assumes that in one or more steps the 
evaluation trees created by the subexpressions will constitute the final evaluation tree 
of an expression. If a subexpression fails to evaluate to a value, so does the whole 
expression. But we cannot know exactly how the subexpression got stuck, which is 
a key issue in being able to reason about the semantics and its interaction with the 
type system. SOS admits structural induction on evaluation derivations. 

Gunter [Gun92] strengthens subject reduction for the pure functional pro¬ 
gramming language PCF by augmenting the evaluation rules with new rules that 
evaluate to a special value, namely tyerr which does not have a type. These rules 
cover the evaluation of possible ill-typed expressions. Since a well-typed expression 
never contains an ill-typed subexpression, then any of the rule instances that occur 


25 



in the evaluation of a well-typed expression cannot be an instance of one of these new 
rules. Hence, it is not the case that a well-typed expression evaluates to tyerr. So by 
showing that subject reduction holds for the augmented evaluation rules, absence of 
run-time type errors is guaranteed. In addition to the drawback of augmenting the 
evaluation rules, this approach does not give us any information about the nature 
of the other errors that can occur during evaluation of well-typed programs, which 
will be an important issue in an imperative setting with assignable locations and first 
class pointers. 

On the other hand, Smith and Volpano use the combination of subject reduc¬ 
tion and a lemma, namely the Correct Form Lemma to prove a soundness theorem 
[SmV96a]. The Correct Form Lemma shows the correct syntactic form of a value 
when its type is given. It basically shows the type system is not being silly by giving 
some unexpected type to a term. For example, if a value has type ti —> T 2 then the 
value is a A — abstraction and not, say, an integer. Also, to get a handle on the 
“progress”of an attempted evaluation, the evaluation rules are re-cast as an instance 
of a recursive function, eval. The Soundness Theorem then shows that if an activation 
of eval aborts, it is due to one of the following four errors [SmV96a]: 

El. An attempt to read or write to a dead address {i,j). 

E2. An attempt to read or write to a nonexistent address (i,i). Address (i, 0) 
always will exist, so the problem is that the offset j is invalid. 

E3. An attempt to read an uninitialized address {i,j). 

E4. An attempt to declare an array of size less than or equal to 0. 

But re-casting the evaluation rules as an instance of eval and proving a sound¬ 
ness result based on the abort conditions of eval seems a little bit informal. What we 
would like to do is to collect more information about the “course” of the evaluation of 
the programs so that we can use more formal techniques to prove a soundness result 
for PolyC. It is for this reason that we explore a transition semantics for PolyC. 


26 



B. TRANSITION SEMANTICS FOR POLYC 


1. Definitions 

First, we give some definitions used in the transition (evaluation) rules. 

A configuration is a triple (e, fj,, 6) where e is an expression, 6 is an active cell 
indicator, and /i is a memory which is a finite function from addresses to values; jj, 
may also map addresses to dead or uninit, indicating that the cell with that address 
has been deallocated or is uninitialized. The contents of an address a G dom{ij,) is 
the value //(a), and we write fi[a := u] for the memory that assigns value v to address 
a, and value /x(c') to an address a' ^ a; /^[o := v] is an update of if a 6 dom^n) and 
an extension of if c ^ dom{fi). 

An active cell is an address whose value is not dead. The natural number 8 
denotes the number of active cells created so far by an expression or by its subex¬ 
pressions. We use 8 for the purpose of keeping track of the lifetime of memory cells 
that are allocated via letvar and letarr declarations. 

We define a binary relation —> from configurations to configurations to capture 
the single step transitions. If evaluating the closed expression e in memory pi with 
respect to 8 results in a new expression e', a new memory pi' and a new active cell 
indicator 8', then 

(e, n, 8) (e', n', 8'). 

We write [e'/xje to denote the capture-avoiding substitution of e' for all free 
occurrences of a: in e and the result of the substitution is another expression of PolyC. 

2. The Transition Rules 

The transition rules are given below: 

(contents) 

(l) a G dom{pi) and pi{a) = v 
((a,l),/i,d) -> {v,n,8) 


27 


(deref) 

(I) 

a 6 dom(ijL) and //(a) = v 

(n) 

(*{a,0),n,6) {v,n,6) 

{e,n,6) {e',ix',6') 


(*e, fi, 6) {*e', /, S'j 

(ref) 

(I) 

(n) 

(III) 

(^(a,l),/i,S) ((a,0),fi,S) 

(^*(a,0),M,S) ^ ((a,0),M,S) 

(e,/ii,S) (e',/:i',S') 


(& * e, fj,, 6) e', pt!, 8') 

(offset) 

(I) 

n an integer 

(n) 

(((*>j).0) + n,li,S) -> + n),0), fi,S) 

(e,M,<) 

(III) 

(((*,i),0) + ^ (((hj),0) + e',n’J') 

{ei,fi,8) 


(ei + 62 , fJ,, 8) —> (e' + 62 , fi', 8') 

(apply) 

(I) 

(n) 

((Axi, . . . , Xn. e)(ui,. . . , Vn), {X, 8) ([vi,. . ., 

{e,fx,8) ie',/j,',8') 


• • • j ^Ti)t ^ (®1? • • • ) ^n)? ) 

(ill) (e,-, /X, -> (e<, 1 < e < ra_ 


((Axi,...,Xn- e)(ui,..., Ui_i, Ci,..., e„),yti, 

((AXi, . . . , Xn- 6)(^l5 • • • ; Ij • • • ■> 6n)) j ^ ) 

(update) 

(l) a 6 dom{fj,) and /z(a) ^ dead 

((a, 1) := t;,/i,^) (u,/^[a := u],d) 


,Xn]e,^,<5) 


28 


(ll) (e, //, 6 ) je', fx,', 6 ') _ 

((a, 1 ) := e, /x, 6 ) ((o, 1 ) := e', 8 ') 

(ill) a € dom{jj) and jj,{a) ^ dead _ 

(*(a, 0 ) := u,/i,5) {v,ij\a := ■y],<!)) 

(IV) {e,ii, 8 )^{e',pi,\ 8 ') _ 

(*(a, 0 ) := e,/i, 5 ) -> (*(a, 0 ) := e\fx',S') 

(v) (eufx.S) ie[,n',S') _ 

(*ei := 62 , n, 8 ) (*ei := e 2 ,fx', 8 ') 

(bind) 

(I) (let a: = u in e,/i, ^) —> ([u/a:]e,/X, (5) 

(II) (ei,/x,(?) -> {e[,^', 8 ') _ 

(let a: = ei in 62 , /x, 8 ) (let x = in 62 , /x', 8 ') 

(bindvar) 

(I) {i, 0 ) ^ dom{fj,) 

(letvar x ;= t; in e, H, 0 ) 

(letvar x := u in [((x, 0 ),l)/x]e,/x[(x, 0 ) := t;],l) 

(II) (x, 0 ) G dom{fj.) and (x, 0 ) the last non-dead cell _ 

(letvar x := vi in V 2 ,/x, 1 ) —(v 2 ,/“[(*, 0 ) := dead], 0 ) 

(ill) (ei,Ax,^) {e[,n', 8 ') _ 

(letvar x ;= e-y in 62 , {j,, 8 ) —> (letvar x := in e 2 ,fJ.', 8 ') 

(IV) (e,/x,5-l)^(e^/x^^0 (<^>0) _ 

(letvar x := u in e,fi, 8 ) (letvar x := v in e',ii', 8 ' + 1 ) 

(bindarr) 

(I) n a positive integer and (x, 0 ) ^ dom{n) 

(letarr x[n] in e,jLi, 0 ) (letarr x[n] in [((x, 0 ), 0 )/x]e, 

/i[(x, 0 ),..., (x, n — 1 ) ;= uninit,..., uninit], 1 ) 

(II) (x,n — 1 ) € dom{fi) and (x,n — 1 ) the last non-dead cell 
(letarr x[n] in n,yt 4 , 1 ) —> 

(u, /x[(x, 0 ),..., (x, n — 1 ) := dead,..., dead], 0 ) 


29 


(III) 

{ei,ix,S) — > {e'^, n', S') 



(letarr x[e\] in e2,ti,S) —> (letarr x[< 

e'l] in e2,fi', ~S') 

(IV) 

(e, //, - 1) -4 (e', fi'. S') {8 > 0) 



(letarr x[n] in e,fJ',S) (letarr x[n] 

in e', n', S' + 1) 

(loop) 

(I) 

(ei,^, ^) {e'-y, jx', S') 



(while Cl do 62 ,/^,^) —> 


(if Cj then 62 ; while ei do 62 else unit, fi', 6') 


(branch) 


(I) 

n a nonzero integer 


(if n then ei else 62 ,/x,^) —>■ {ei,fx,6) 

(n) 

(if 0 then ei else 62 , M,^) — » {e2,fi,5) 

(III) 

iei,n,S) {e'i,fi',S') 


(if ei then 62 else e3,fx,6) (if then 62 else 63,^1', S') 

(compose) 

(I) {v,e,n,S)-^ {e,n,S) 

(II) {ei,fi,6)^ 

(ei; e2, /^, S) —> (e^; 62, //', S') 

Meta variable v and x range over values and identifiers, respectively. The 
understanding in rules like DEREF, REF, etc. is that if there are transitions on e and 
V or at least one specific syntactic value then e is understood to be all expressions 
except all values. For instance, DEREF has two rules; (l) defines a transition for pointer 
type values and (ll) defines a transition for all other expressions except values. 

Since the lifetime of a memory cell is bounded by the scope in which it is 
activated, the rules have to keep track of the lifespan of each memory cell. In SOS, 
this is easy to do, whereas the solution in TS may seem unintuitive. We introduce 
S to keep track of the scope information. Notice that in BINDVAR (l), after a cell is 


30 



allocated for a variable we still keep the letvar^ construct until the body evaluates to 
a value. When the cell is allocated 6 is incremented so that we can understand that 
this letvar instance has actually allocated a cell and now it is evaluating its body. 
Rules BINDVAR (l) and BIND VAR (iv) show this difference. In BINDVAR (l), the letvar 
expression of the initial configuration has a value v as its ei and ^ is 0 which means a 
cell has not been allocated yet. Then a new cell for x is allocated and initialized to v, 
and S is incremented by one. In BINDVAR (iv), the initial configuration is the same 
as the initial configuration of BINDVAR (l) except that the second premise forces S be 
greater than 0 which means that this rule is used only to evaluate the body of letvar. 
Keeping the letvar construct around after we allocate a cell makes the proof search 
part of a letvar transition unnecessarily long, but introducing a new construct would 
force us to augment the type system superficially with a new typing rule for this new 
construct. The evaluation of a program starts with ^ = 0 and ends again with ^ = 0. 

At first glance, one might be tempted to use a variation of p-expressions 
to keep track of the cells being activated [WrF91]. This would not be enough by 
itself, since in PolyC the lifetime of a cell is bounded whereas in [WrF91] a cell has 
unbounded lifetime. 

We assume that memory cells are allocated sequentially from a sufficiently big 
sequence of cells, where the cells are associated with index numbers in an increasing 
order. As defined earlier, an address is a pair of segment and offset numbers and it 
indicates a cell in the memory. When a variable v is created, the cell with the least 
index number from the non-used part of the sequence is initialized to the value of 
this variable, and an address {i, 0) corresponding to this cell is added to the domain 
of fi. Similiarly, when an array x of size n is created then the first n cells from 
the non-used part of the sequence are initialized to uninit and the corresponding 
addresses (i, 0), (i, 1),..., (z, n — 1) are added to the domain of p,. When the scope of 

^We will focus on letvar without mentioning leiarr separetely; in most cases the same discussion 
is also valid for leiarr. 


31 


the variable v or the scope of the array x ends then these cells are marked as dead, 
but they are still kept in the domain of /i. 

In SOS, a variable declaration and termination are done within a single eval¬ 
uation rule so that it is easy to know which address is to be marked as dead. But in 
TS, declaration of a variable and termination of it are done via different rules, and the 
address information is not carried to the next transition. Given the memory model, 
it is easy to find out the memory cell to be marked when necessary. Simply search 
through the sequence of cells starting from the high-index numbered end of the used 
part of the sequence, and the first cell that is not marked as dead will correspond 
to the address of the variable whose scope is ending. We call this cell the last non¬ 
dead cell. In case of an array of size n, the consecutive n cells starting from the last 
non-dead cell are the ones that will be marked as dead. The reason that we have to 
search for the last non-dead cell is because dead locations are not taken away from 
the domain of fi. If an expression e creates a variable x for which the cell indexed i 
is allocated, and if a subexpression of e then creates another variable y, then the cell 
allocated for y has a higher index j and so j will be marked as dead before i since 
the scope of y ends before the scope of x. 

3. Two Examples of Program Evaluation 

Figure 3 shows the evaluation derivation of the program 

letvar x := 1 in letvar y := x in y . 

The evaluation in Figure 3 is completed in six transitions. A transition rule 
name is given inside brackets to indicate the rule used in making the single transi¬ 
tion that follows it. For example, the first transition is done using the BINDVAR (l) 
rule. The second, third, fourth and fifth transitions are done using an instance 
of BINDVAR (iv). In the proof search, the second transition uses an instance of 
BINDVAR (ill) and CONTENTS, the third transition uses an instance of BINDVAR (l), 
the fourth transition uses an instance of BINDVAR (iv), and the fifth transition uses 


32 


[bindvar (i)] 

(letvar x := 1 in letvar j/ := x in y, Q, 0) —> 

(letvar x := 1 in [((4,0), l)/x] letvar y := x in y, [(4,0) := 1], 1) 


[contents] 

((( 4 , 0 ), 1 ), [( 4 , 0 ) := 1 ], 0 ) ( 1 , [( 4 , 0 ) := 1 ], 0 ) 

[bindvar (hi)] 

(letvar y := ((4,0),1) in y,[(4,0) := 1],0) 

(letvar y := 1 in y,[(4,0) := 1],0) 


[bindvar (iv)] 

(letvar x := 1 in letvar y := ((4,0), 1) in y, [(4,0) := 1], 1) ^ 

(letvar x := 1 in letvar y := 1 in y, [(4,0 ) := 1], 1) 


[bindvar (i)] 

(letvar y := 1 in y,[(4,0) := 1],0) 

(letvar y := 1 in [(4,0), l)/y]y, [(4,0) := 1,(4,0) := 1],1) 

[bindvar (iv)] 

(letvar x := 1 in letvar y ;= 1 in y, [(4,0) := 1], 1) 

(letvar X := 1 in letvar y := 1 in ((4,0), 1), [(4,0) := 1,(4,0) := 1],2) 


[contents] 

(((45 0), 1), [(4,0) := 1, (4,0) := 1], 0) —^ (1, [(4,0) := 1, 0) := 1], 0) 


[bindvar (iv)] 

(letvar y ;= 1 in ((4,0), 1), [(4,0) := 1, (4,0) := 1], 1) 

(letvar y := 1 in 1,[(4,0) := 1,(4,0) := 1],1) 


[bindvar (iv)] 

(letvar X := 1 in letvar y := 1 in ((4,0),1),[(4,0) := 1,(4,0) := 1],2) 

(letvar X := 1 in letvar y := 1 in 1,[(4,0) := 1,(45 0) := 1],2) 


Figure 3. Sample Program Derivation, continued next page 


33 


[bindvar (ii)] 

(letvar j/ := 1 in 1, [(4,0) := 1, (ij,, 0) := 1], 1) 

(1,[(4,0) :=l,(ij„0) := dead],0) 


[bindvar (iv)] 

(letvar a; := 1 in letvar y := 1 in 1,[(4,0) := 1 ,(^ 3 ,, 0) := 1],2) 

(letvar x := 1 in 1, [(4,0) := 1, (iy, 0) := dead], 1], 1) 


[bindvar (ii)] 

(letvar x := 1 in 1, [(4)0) •= 4 (4^0) := dead], 1) —> 

(1, [(4,0) := dead, (4,0) := dead], 0) 

Figure 4. Sample Program Derivation, cont. 

an instance of BINDVAR (ll). The final transition is done with BINDVAR (ll). So the 
letvar expression evaluates to 1. 

Now let’s turn back to the well-typed program 

letvar x := letvar y := Xz.z in hy in(*x)(3) 

of Chapter I Section 2, in which the location of y escaped from its scope via the & 
operator and we inferred the type int for this program. Figure 5 shows how this 
program gets stuck due to dereferencing a dead cell. 

The notation denotes the stuck condition of a rule instance. In the sixth 
transition, *((4)0)) 0) attempts to derefence a dead location, which causes the eva- 
lution to get stuck because there is no possible transition that can be made. The 
first three transitions are done with BINDVAR (ill), where in the proof search the first 
transition uses an instance of BINDVAR (l), the second transition uses the instances 
of BINDVAR (iv) and REF, and the third transition uses an instance of BINDVAR (ll). 
The fourth transition is done with BINDVAR (l), because ((4) 0), 0) is a pointer, which 
is a syntactic value and S is 0. The fifth transition is done with BINDVAR (ill), where 
the instances of APPLY and CONTENTS are used in the proof search. 


34 



[bindVAR (l)] 

(letvar y := Xz.z in &j/, [],0) 

(letvar y := Az.z in [((ij„0), l)/t/] &?/, [(^,0) := Az.^],!) 


[bindvar (hi)] 

(letvar x := letvar y := Az.z in ky in {*x){3), [],0) —> 

(letvar a: := letvar y := Xz.z in &((z3^,0),l) in(* x)(3), [(?j^, 0) := Az.z],l) 

[ref] 

(&((*V5 0 ) 51)5 [(*y 5 0) := Az.z], 0) {{{iy, 0), 0), [(i^, 0) := Az.z], 0) 

[bindvar (iv)] 

(letvar y := Xz.z in &;((zj,, 0), 1), [(zy, 0) := Az.z],l) 

(letvar y := Xz.z in ((iy,0),0), [(ij„0) := Az.z],l) 


[bindvar (hi)] 

(letvar x := letvar y := Az.z in &((iy, 0), 1 ) in(* a:)(3), [(zy, 0) := Xz.z], 1 ) -4 
(letvar X := letvar y := Xz.z in ((4,0),0) in(* x)(3), [(ij^, 0) := Az.z],l) 


[bindvar (ii)] 

(letvar y := Az.z in ((4^0), 0), [( 4 ,0) := Az.z],l) 

{{{iy, 0), 0), [(zj/, 0) := dead], 0) 


[bindvar (hi)] 

(letvar X := letvar y Xz.z in ((zj/,0),0) in(* x)(3), [(i^,, 0) := Az.z],l) 

letvar x := ((iy,0),0) in (*a;)(3), [(zy,0) := dead],0) 


[bindvar (i)] 

letvar x := ({iy, 0),0) in (:♦= a;)(3), [(zj^,0) := dead],0) -> 

letvar x := ((ij,, 0), 0) in [((4,0), l)/x] {* x)(3), [(ij,, 0) := dead, (4,0) := ((ij,, 0), 0)], 1) 


Figure 5. Sample Stuck Program, continued next page 


35 


[contents] 

((( 4 , 0 ), 1 ), [(iy, 0 ) := dead, ( 4 , 0 ) := {{iy, 0 ), 0 )], 0 ) ^ 

(((ij,, 0 ), 0 ), [(ij,, 0 ) := dead, ( 4 , 0 ) := {{iy, 0 ), 0 )], 0 ) 


[apply] 

((* 2/)(3), [(v 0 ) := dead, ( 4 , 0 ) := {{iy, 0 ), 0 )], 0 ) ^ 

((*((^v,0),0))(3),[(ij„0) := dead, (4,0) := ((4,0), 0)], 0) 


[bindvar (hi)] 

letvar x := ((4,0), 0) in (* ((4,0), 1))(3), [(4,0) := dead, 

( 4 , 0 ) := (( 4 , 0 ), 0 )], 1 ) letvar x := (( 4 , 0 ), 0 ) in (* (( 4 . 0 )> 0))(3), 
[( 4 , 0 ) := dead, (4, 0 ) := (( 4 , 0 ), 0 )], 1 ) 


(* ((4r 0)^ 0)), [(4> 0 ) := dead, (4, 0 ) := (( 4 , 0 ), 0 )], 0 ) 7 ^ 


((* ((4> 0): 0))(3), [(4^ 0) — <iead, (4, 0 ) := (( 4 , 0 ), 0 )], 0 ) 7 ^ 


letvar x := ((4,0),0) in [((4,0),l)/a;] (*((4,0),0))(3), [(4,0) := dead, 
(4,0) := ((4,0),0)],1)7^ 


Figure 6 . Sample Stuck Program, cont. 

4. The LOOP Rule 

In the preliminary design of the transition semantics of PolyC, we developed 
three rules, given below, to specify the transitions for the while-do construct. 


(loop) 

(l) (ei,/x, ^) (n a nonzero integer) _ 

(while Cl do 62 ,/^,^) —> ( 62 ; while ei do 62 ,//',^') 

(n) (ei,/^,<?)(0,//^«?0 _ 

(while ei do 62 ,/i, 5) ^ (unit, jx', 6') 


36 


(ni) _ 

(while ei do 62, 8) —> (while e{ do e2,ii',8') 


Gunter develops a transition semantics for an imperative programming lan¬ 
guage called Simple Imperative Programming Language (SIPL), and rules (ill) and 
(ll) above are closely similiar to Gunter’s [Gun92] . There is a subtle difference 
though: ei of while ei do 62 is not evaluated explicitly in Gunter’s system but its 
value is found by a meaning function in one step. In our system we explicitly evaluate 
Cl and for this reason a third rule had to be added to the system as shown above. But 
in a short time we realized that this third rule was faulty. Assume in an evaluation 
of a program we reach the point of evaluating the expression, 

while (a, 1 ) := ((a, 1 ) d-l); 1 do e, 

which increments the value stored in address a and then evaluates the body e. This 
is an infinite loop, since the value of a sequential composition ei;e 2 is the value of 
62 and, in this program, 62 is 1 so the condition is always true. In each iteration, 
(a, 1 ) := ((a, 1) + 1);1 and e must be evaluated. But this is not achievable with 
the above rules. The evaluation starts with repeated applications of rule (ill) until 
(a, 1 ) := ((a, 1) + 1); 1 evaluates to the value 1 . At this point, the configuration 
is (while 1 do e, /i, 8) and rule (l) is applied by resulting in the new configuration 
(e; while 1 do e, ^', ^'). After some applications of COMPOSE, e evaluates to a value 
and then the configuration (while 1 do e, /i", 8") is found. This completes the first 
iteration of the loop; but notice that we have lost the original program: while 1 do e 
is different than while (a, 1 ) := ((a, 1 ) + 1 ); 1 do e. 

To fix this error, we developed the rule below by using a continuation instead 
of the three rules: 


37 



(ei,/x» -> _ 

(while ei do 62,11,8) —> 

((Ax.if X then 

62; while Cl do 62 
else 
unit 


In this rule, the A abstraction is a continuation. We simplify the rule by 
/? — reducing the application of the continuation to and arrive at the rule below. 

[ei,ii,8) -» _ 

(while Cl do 62,/J,, 8) (if then 62; while ei do 62 else unit,/x',d') 


This is the rule for loop construct in the present system. 

C. CONCLUSION 

Although we have a better handle on the progress of the evaluations of pro¬ 
grams, we face an increase in the number of transition rules in the system. When 
we want to add the binary operations to the language, the number of rules increases 
greatly. One possible effect of this is that proofs might be complicated and unneces¬ 
sarily long. 


38 



V. CONCLUSIONS AND FUTURE WORK 

A. CONCLUSIONS 

1. Type Inference Algorithm 

We have presented an ML-style type inference algorithm called Wc based on 
Milner’s algorithm W [Mil78] [DaM82]. An implementation of Wc has been given in 
Appendix as part of an interpreter of PolyC. We expect a correctness proof of Wc be 
straightforward but it is beyond the scope of this thesis. 

2. The Transition Semantics 

An imperative programming language with first class pointers should have 
a stronger property of type soundness than the subject reduction property; i.e., if 
a closed term has type r, then the evaluation of that term yields a value of type 
T if evaluation terminates successfully. For this reason, Smith and Volpano prove 
soundness of the PolyC type system by formulating the evaluation rules of PolyC’s 
natural semantics as an instance of a recursive function called eval [SmV96a]. But 
this proof seems to be slightly informal. To establish a basis for a more formal proof, 
we developed a transition semantics for PolyC and have presented it in this thesis. 
We believe that a transition semantics exposes more information about the course of 
an evaluation, thus making it possible to give more rigorous soundness arguments. 
But a transition semantics tends to introduce a large number of rules in the system, 
which makes proofs more cumbersome. 

B. FUTURE WORK 

1. Formal Soundness Proof 

Volpano and Smith are currently working on a new soundness proof with 
respect to natural semantics using partial evaluation trees. Pfenning is also expected 


39 


to give a soundness proofs using the £■//programming language, which is based on the 
linear logical framework concept [Pfe96]. We believe a soundness proof of the PolyC 
type system is possible using the transition semantics given in this thesis cis well. 

2. Extending PolyC 

Extending PolyC with integer and boolean operations is a trivial task, and 
they have already been included in the interpreter implementation given in Appendix. 
Polymorphic records and variants, on the other hand, require modifications to the 
type system and to the type inference algorithm. Ohori [Ohor95] investigates an 
ML-style polymorphic record calculus in a functional setting by introducing kinded 
quantification, which places restrictions on possible instantiations of type variables. 
His work is an appealing foundation for labeled records and variants in the PolyC 
language. 


^Based on the personal communication during ESOP’96, Linkoping Sweden 


40 



APPENDIX. SOURCE PROGRAM FOR THE 

INTERPRETER 


1. REMARKS 

Developing a type inference algorithm has led to an implementation of Wc to 
see how it works in practice. Besides type inference we also implemented the natural 
semantics of Poly C given in [SmV96a] and, as a result, we have created an interpreter 
for PolyC. During implementation we tried not to go beyond the PolyC calculus and 
we accomplished this except for SSL lists used in the representation of formal and 
actual parameters. 

Annotations throughout the source code are kept concise by assuming that 
the reader will have some knowledge about programming language theory and some 
experience with functional programming. 


2. SSL CODE FOR THE INTERPRETER 


/ *************************:fc:f:sts5j<*5f;5jt:»c*s|<:****5|c**************************** 

* This interpreter is written using Synthesizer Generator 
Release 4.2. The code given below is the complete code that 
we have used to generate the interpreter by using the Makefile 
given also below. For space efficiency, we put all the files 
together in this appendix, but each file is clearly 
identifiable by the header provided before the beginning of a . 
file. The textual appearance order of files in this appendix is 

* alphabetical except Makefile which is given last. Following are 
the files: 


* 

* 

* 

* 

* 

* 


* 

* 

* 

* 

* 

* 

* 

* 

* 

* 


assign.ssl 
assign.infer.ssl 
bool.ssl 
bool^infer.ssl 
eval.ssl 
explist.ssl 
id.ssl 
if.ssl 


infer,ssl 
int.ssl 
int^infer,ssl 
lambda.ssl 
lambda.infer.ssl 
let.ssl 
let.infer.ssl 
letarr.ssl 


lex.ssl 
pair.ssl 
pair.infer.ssl 
real.ssl 
real.infer.ssl 
while.ssl 
while.infer,ssl 
Makefile 


* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 

* 


41 


* if_infer.ssl letarr.infer.ssl * 

* * 

* Naming of files are intended to be informative what is in there; * 

* for instcince bool.ssl gives the required definitions like * 

* abstract syntax, minimal paranthesization, unparsing rules, * 

* template commainds and concrete input syntax of boolean * 

* operations. Type inference for these operations (constructs) is * 


* in bool_infer.ssl. * 

* * 

* It should be noted one more time that this interpeter extends * 

* Poly C CSmV96] with real type and integer and bool operations. * 

* * 




/:(cs(c5|e**s|ci>|£*****st::)c**J(:*****s|e******=|c********=l'**=l'*****=t'=)'* + *************** 

* File Name : assign.ssl * 

* Purpose : Definitions for Compose, Assign, AddrOf, Deref, * 

* Unit, Dead, Uninit, InvalidAddr constructors of ♦ 

* exp phylum. * 

/* InvalidAddr is returned as a result of a memory lookup */ 

/* Abstract syntax- */ 

exp : Compose (exp exp) 

I Assign (exp exp) 

I AddrOf (exp) 

I Deref (exp) 

I UnitO 

I Dead, Uninit, InvalidAddr () 

J 

/* Minimal paxenthesization - */ 

exp : Compose PP2(0) 

I Assign PP2(0) 

I AddrOf PPl(O) 

I Deref PPl(O) 

3 


42 





/* Unparsing 


*/ 


/* 


* In 

[SmV96], * is used : 

* implementation we 

* multiplication. 

*/ 

use 

exp : 

Compose 

[ - 

1 

Assign 

[ ^ 

1 

AddrOf 

[' 

1 

Deref 

C “ 

1 

Unit 

[ - 

1 

Dead 

C - 

1 

Uninit 

[' 

1 

InvalidAddr 

C ' 

) 

/* Template commajids 
transform exp 

— 


= 0 ’/.n" ® ] 

= @ " •/,S( PUNCTUATION ::=y.S) " 
= "‘/.S (OPERATOR :&y.S)" 0 ] 

= "%S (OPERATOR:! 7,S)" 0 ] 

= "'/.S(KEYWORD:unif/,S)" ] 

= "‘/.S (KEYWORD :deady.S)" ] 

= "‘/.S (KEYWORD runinit'/S)" ] 

= "‘/.S (KEYWORD :invalidy.S) 7.3 
(KEYWORD:addresses)" ] 


on <exp>: Compose(<exp>, <exp>), 

on "e;<exp>" e when (e != <exp>) : Compose(e, <exp>), 

on "<exp>;e" e when (e != <exp>): Compose(<exp>, e), 

on <exp> : Assign(<exp>, <exp>), 

on <exp> : AddrOf(<exp>), 

on "!" <exp>: Deref(<exp>), 

on "!" e when (e != <exp>): Deref(e) 


*/ 


/* Concrete input syntax - */ 

Exp ::= (Exp ASSIGN Exp) ■C$$.abs = Assign(Exp$2.abs, Exp$3.abs);} 

I (Exp Exp) {$$.abs = Compose (Exp$2.abs, Exp$3. abs) ;}• 

I (M' Exp) {Exp$l.abs = Deref (Exp$2.abs) 

I (’&’ Exp) {$$.abs = AddrOf(Exp$2.abs) ;} 

I (UNIT) {Exp.abs = Unit;} 


/ ****=|c********+********=|e********:it:***********5t:********+*:)c*Hc***=(:****J|c*=t:* 

* File Name : assign.infer.ssl * 


43 









* Purpose : Type inference for the cons'tors given in assign.ssl * 

exp : Unit { 

exp.typeAssignment = UnitType; 

exp.S = exp.s; 

exp.partial = false; 

} 

I Dead { 

exp.typeAssignment = NullType; 
exp.s = FailSubst; 
exp.partial = false; 

> 

I Uninit { 

exp.typeAssignment = UniversalType; 

exp.s = exp.s; 

exp.partial = false; 

} 

I InvalidAddr { 

exp.typeAssignment = UniversalType; 

exp.s = exp.s; 

exp.partial = false; 

} 

I Deref { 

local TYPEVAR beta; 
beta = WeakVar(newsymi()); 
exp$2.typeEnv = exp$l.typeEnv; 
exp$2 .letvars = exp$l. letveors; 
exp$2.s = exp$l.s; 

exp$l.S = Unify (RefTypeCTypeVcir (beta) ) , 

exp$2.typeAssignment, exp$2.S); 
exp$l.typeAssigimient= ApplySubstToTypeExp(exp$l.S, TypeVar( 

beta) ) ; 

exp$l.partial = exp$2.partial; 
exp$2.sv = exp$l.sv; 
exp$2.encl = exp$l.encl; 
exp$2.top = exp$l.top; 

} 

I Assign { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 

exp$3.typeEnv = ApplySubstToTypeEnv(exp$2.S, exp$l.typeEnv); 


44 



exp$3.1etvaxs = exp$l.letvaxs; 
exp$3.s = 

witli(exp$2) ( 

Ident(Identifier(i)) : exp$2.S, 
Deref(e) : exp$2.S, 

Subscript(*,*) : exp$2.S, 

VoidExpO : exp$2.S, 

default : FailSubst 


); 


exp$l.typeAssignment = 

ApplySubstToTypeExp(exp$l.S, exp$2.typeAssignment); 
exp$l.S = 

with(exp$2) ( 

Ident(Identifier(i)) : 

InLVList(Identifier(i), exp$l.letvars) ? 

Unify(InstScheme(LookupInTypeEnv(i, 

exp$l.typeEnv)),exp$3.typeAssignment,exp$3.S) 

: FailSubst, /* not a letvar id */ 

VoidExpO : 

Unify(exp$2.typeAssignment,exp$3.typeAssignment, 
exp$3.S), 

Deref(e) : 

Unify(exp$2.typeAssignment,exp$3.typeAssignment, 
exp$3.S), 

Subscript(*,*) : 

Unify (exp$2 .t 3 rpeAssigiunent ,exp$3 .typeAssignment, 
exp$3.S), 

default : FailSubst 

); 

exp$l.partial = exp$2.partial I I exp$3.partial; 

exp$3.sv = exp$l.sv; 

exp$2.sv = exp$l.sv; 

exp$3.encl = exp$l.encl; 

exp$2.encl = exp$l.encl; 

exp$2.top = false; 

exp$3.top = exp$l.top; 

} 

I AddrOf { 

local TYPEEXP tau; 

exp$2.typeEnv = exp$l.typeEnv; 

exp$2.letvars = exp$l.letvars; 


45 





exp$2.s = exp$l.s; 
exp$l.S = 

with(exp$2) ( 

Ident(Identifier(i)) : 

InLVList (Identifier(i),exp$l.letvars)? 

Unify (TypeVar (WeakVar (newsymi ( ) ) ) , tan, exp$ 1. s) 
: FailSubst, /* not a letvar id */ 

VoidExpO : exp$2.S, 

Deref(*) : exp$2.S, 

Subscript(*, *) ; exp$2.S, 

default : FailSubst 

); 


exp$l.typeAssignment = RefType(tau); 
exp$l.partial = exp$2.partial; 

tau = 

with(exp$2)( 

Ident(Identifier(i)) : 

InstScheme(LookupInTypeEnv(i,exp$l.typeEnv)), 
VoidExpO : TypeVar(WeakVar(newsymi())) , 
Deref(*) : exp$2.typeAssignment, 

Subscript(*, *) : exp$2.typeAssignment, 
default : NullType 

); 


exp$2.sv = exp$l.sv; 
exp$2. end = exp$ 1. end; 
exp$2.top = exp$l.top; 

} 

I Compose { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 
exp$3.s = exp$2.S; 
exp$3.letvars = exp$l.letvars; 
exp$3.typeEnv = ApplySubstToTypeEnv(exp$2.S, 
exp$l.typeEnv); 
exp$l.S = exp$3.S; 

exp$l.typeAssignment = exp$3.typeAssignment; 
exp$l.partial = exp$2.partial II exp$3.partial; 


46 



exp$3.sv = exp$l.sv; 
exp$2.sv = exp$l.sv; 
exp$3. end = exp$l. end; 
exp$2.end = exp$l.end; 
exp$2.top = false; 
exp$3.top = exp$l.top; 


exp : Deref {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst);} [ TypeErrors @ : "Deref%n"“ ] 

I Assign {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst && exp$3.S != FailSubst);} 

[ TypeErrors @ : "Assignin''~~ ] 

I AddrOf {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst);} [ TypeErrors ® : "AddrOfy.n"'' ] 

9 


/ *************************ilf:*******:lt:^it:it:****************^****!i:********* 

* File Name : bool.ssl ♦ 

* Purpose : Boolean operations. ♦ 

>|t>|t***********=t:*****s|e**********=|t***************+J)c*:)c***3|c;)c***3|e*:(c******* j 

!* Abstract syntax- */ 

exp : Not(exp) 

I And, Or, Equal, NotEqual(exp exp) 


/* Minimal parenthesization - */ 

exp : Not PP1(9) 

I And PP2(3) 

I Or PP2(2) 

I Equal PP2(4) 

I NotEqual PP2(4) 


/* Unparsing-♦/ 

exp : Not [“ : := '-/.S(PUNCTUATION:" Ip "‘/.S(OPERATOR:•/.<not>y.S)" @ 

"•/.S(PUNCTUATION:" rp "‘/.S)"] 


47 






I And [" ::= "‘/.S(PUNCTUATION:" Ip "y.S)" 0 " '/S(OPERATOR:&&'/.S) " 
0 "’/.S(PUNCTUATION:" rp "‘/.S)"] 

I Or ::= "‘/.S(PUNCTUATION:" Ip "7.3)" © " 7.3(OPERATOR: I T/.S) " 

@ "7.3(PUNCTUATION:" rp "7.3)"] 

I Equal [•' ::= "7.3(PUNCTUATION:" Ip "7.3)" © " 7.3(OPERATOR: =7.3) " 
© "7.3(PUNCTUATION:" rp "7.3)"] 

I NotEqual [“ : := "7.3(PUNCTUATION:" Ip "7.3)" © " 7.3(OPERATOR: 
7.<ne>7.3) " © "7.3(PUNCTUATION:" rp "7.S)"] 


/* Template commands- */ 

transform exp 

on """ <exp> : Not(<exp>), 
on "&&" <exp> : And(<exp>, <exp>), 
on "M" <exp> : Or(<exp>, <exp>), 
on "=" <exp> : Equal(<exp>, <exp>), 
on "<>" <exp> : NotEqual(<exp>, <exp>) 


/* Concrete input syntax- */ 

Exp ::= ('"' Exp) { Exp$l.abs = Not(Exp$2.abs); } 

I (Exp LOGICALAND Exp) 

{ Exp$l.abs = And(Exp$2.abs, Exp$3.abs); } 

I (Exp LOGICALOR Exp) 

{ Exp$l.abs = 0r(Exp$2.abs, Exp$3.abs); } 

I (Exp ' = ' Exp prec ’ = 0 

{ Exp$l.abs = Equal(Exp$2.abs, Exp$3.abs); } 

I (Exp NOTEQUAL Exp prec NOTEQUAL) 

{ Exp$l.abs = NotEqual(Exp$2.abs, Exp$3.abs); } 


/:t:**:Jc*******************+*!t'***=l'**********!)t*************************** 

* File Name : bool_infer.ssl * 

* Purpose : Type inference for the cons Hors given in bool.ssl * 
**:(£*♦♦+; + **♦:(:♦♦**♦♦♦***♦******♦*****♦*♦***♦♦****♦********************/ 

exp : Not { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 


48 







exp$l.S = Unify(exp$2.typeAssignment, 

IntType, exp$2.S); 
exp$l.typeAssignment = IntType; 
exp$l.partial = exp$2.partial; 
exp$2.sv = exp$l.sv; 
exp$2.encl = exp$l.encl; 
exp$2.top = exp$l.top; 

} 

I And, Or { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.1etvars = exp$l.letvars; 
exp$3.1etvars = exp$l.letvars; 
exp$2.s = exp$l.s; 

exp$3.s = Unify(exp$2.typeAssignment, 

IntType, exp$2.S); 

exp$3.typeEnv = ApplySubstToTypeEnv(exp$3.s, 
exp$l.typeEnv); 

exp$l.S = Unify(exp$3.typeAssignment, 

IntType, exp$3.S); 
exp$l.typeAssignment = IntType; 
exp$l.partial = exp$2.partial || exp$3.partial; 
exp$3.sv = exp$l.sv; 
exp$2.sv = exp$l.sv; 
exp$3.encl = exp$l.encl; 
exp$2.encl = exp$l.encl; 
exp$2.top = false; 
exp$3.top = exp$l.top; 

} 

I Equal, NotEqual { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$3.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 
exp$3.s = exp$2.S; 

exp$3.typeEnv = ApplySubstToTypeEnv(exp$2.S, exp$l.typeEnv); 
exp$l.S = Unify(exp$2.typeAssigmaent, exp$3.typeAssignment, 
exp$3.S); 

exp$l.typeAssignment = IntType; 

exp$l.partial = exp$2.partial || exp$3.partial; 

exp$3.sv = exp$l.sv; 

exp$2.sv = exp$l.sv; 

exp$3.encl = exp$l.encl; 


49 


exp $2. end = exp $1. end; 
exp$2.top = false; 
exp$3.top = exp$l.top; 

} 


exp : Not {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst); } [ TypeErrors 0 : "Not*/.n" “ ] 

I And, Or {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst &k exp$3.S != FailSubst);} 

I And [ TypeErrors @ : "And%n" ] 

I Or [ TypeErrors @ : "Or*/,n" “ “ ] 

I Equal, NotEqual {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst && exp$3.S != FailSubst);} 
1 Equal [ TypeErrors @ : "Equal7,n" ~ ^ ] 

I NotEqual [ TypeErrors @ : "NotEquaiy.n" ~ ^ ] 


* File Name ; eval.ssl 

* Purpose : Implements the natural semantics (structured 

* operational semantics) of Poly C wrt the rules 

* given in CSmV96]. User has the option to evaluate 

* a progreim or not by clicking on the button labeled 

* eval-on. 

* When the evaluation of a program gets stuck due 

* to one of four error cases described in [SmV96] 

* the interpreter returns the partially evaluated 

* program as a result for debugging purposes. 


♦ 

* 

♦ 

♦ 

♦ 

* 

♦ 

* 

♦ 

* 


MEMORY : NullMemO [@ : ] 

I MemConcat(LOCATION exp MEMORY) { 

INHSILENCE(exp) 

} [0 : "%{[" @ " \<rightarrow>" @ "I'/.o" @ "7}"] 


/* Result of an evaluation 


*/ 


50 



EVAL : EvalPairCexp MEMORY){ 

INHSILENCE(exp) 

} [“ : "'/.S(PUNCTUATION: (y.S)" ® "'/S(PUNCTUATION://.S) '/.o" @ 

"%S (PUNCTUATION :)y.S)" ] 


/* 

* We have two different array subscript constructors : one returns 

* a value as a result of the evaluation (r-value) and the other 

* returns a Varloc (1-value). Having these two constructors is 

* an efficient way of implementing these two different occurrences. 

* Otherwise, if we had only one constructor that returns Varloc 

* then the result of the evaluation of an expression occuring 

* in r-value context must be checked if the result is a Varloc which 

* must be dereferenced with an extra step. 

*/ 

/* We add basic logical operations to the language. They 

* implement the same C semantics as one would expect. 

* False is denoted by 0 and True is denoted by a non-zero 

* value; a logical operation constructors returns 1 if the 

* result of the operation is True. 

*/ 

EVAL eval (exp e, MEMORY mu) { 
with (e) ( 

Varloc(l) : 

EvalPair(MemoryLookUp(l, mu), mu), 

Sum(el, e2): 

let EvalPair(vl, mul) ® eval (el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): EvalPair(IntOp(il + i2), mu2), 
default : EvalPair(Sum(vl, v2), mu) 

), 

default: EvalPair(Sum(vl,e2), mu) 

))), 

PtrAdd(el,e2) : 

let EvalPair(vl, mul) = eval (el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 


51 


with (vl) ( 

Refloc(Loc(s,o)): with (v2) ( 

IntOp(i): EvalPair(Refloc(Loc(s,INTtoSTR( 
STRtoINT(o) + i))), mu2), 
default : EvalPair(PtrAdd(vl,v2),mu) 

), 

default: EvalPair(PtrAdd(vl, e2), mu) 

))), 

Subscript(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

Refloc(Loc(s,o)): 

with (v2) ( 

IntOp(i): 

EvalPair(MemoryLookUp(Loc(s,INTtoSTR( 
STRtoINT(o)+i)), mu2), mu2), 
default : EvalPair(Subscript(vl,v2),mu) 

), 

default : EvalPair(Subscript(vl,e2), mu) 

))), 

SubscriptL(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 

let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

Refloc(Loc(s,o)): with (v2) ( 

IntQp(i) : EvalPair(Varloc(Loc(s,INTtoSTR( 
STRtoINT(o)+i))), mu2), 
default : EvalPair(SubscriptL(vl, v2), mu) 

), 

default : EvalPair(SubscriptL(vl, e2), mu) 

))), 

Diff(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 

let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): EvalPair(IntOp(il - i2), mu2), 
default: EvalPair(Diff(vl, v2), mu) 

), 

default: EvalPair(Diff(vl, e2), mu) 


52 



))), 

Prod(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): EvalPair(IntOp(il * i2), mu2), 
default: EvalPair(Prod(vl, v2), mu) 

), 

default: EvalPair(Prod(vl, e2), mu) 

))). 

LessThanCel, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): EvalPair(IntOp((il < i2) ? 1 
: 0), mu2), 

default: EvalPair(LessThan(vl, v2), mu) 

), 

default: EvalPair(LessThaui(vl, e2), mu) 

))), 

LessThanOrEqualCel, e2): 

let EvalPairCvl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): EvalPair(IntOp((il <= i2) ? 1: 0), 
mu2) , 

default: EvalPair(LessThanOrEqual(vl, v2), mu 

), 

default: EvalPair(LessThanOrEqual(vl, e2) , mu) 

))), 

GreaterThan(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): EvalPair(IntOp((il > i2)? 1:0), 
mu2) , 

default: EvalPair(GreaterThan(vl, v2), mu) 

), 


53 


default: EvalPair(GreaterThanCvl, e2), mu) 

))), 

GreaterThanOrEqualCel, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il) : with (v2) ( 

IntDp(i2): EvalPair(IntOp((il >= i2) ? 1: 0), 
mu2), 

default: EvalPair(GreaterThanOrEqual(vl, v2), 
mu) 

), 

default: EvalPair(GreaterThcinOrEqual(vl, e2) , mu) 

))), 

Quot(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 

let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(il): with (v2) ( 

Int0p(i2): (i2 == 0) ? EvalPair(Quot(vl, v2),mu) 
: EvalPair(IntOp(il / i2), mu2), 
default: EvalPair(Quot(vl, v2), mu) 

), 

default: EvalPair(Quot(vl, e2), mu) 

))), 

Not(e): let EvalPair(v, mul) = eval(e, mu) in ( 
with (v) ( 

IntOp(b): EvalPair(Int0p((b == 0) ? 1: 0), mul), 
default: EvalPair(Not(v), mu) 

)), 

And(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 

let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(bl) : with (v2) ( 

Int0p(b2) : EvalPair(IntOp(((bl != 0) && 

(b2 != 0)) ? 1: 0), mu2), 
default: EvalPair(And(vl, v2), mu) 

), 

default: EvalPair(And(vl, e2), mu) 

))), 

0r(el, e2) : 


54 



let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

IntOp(bl): with (v2) ( 

Int0p(b2): EvalPair(IntOp(((bl != 0) || 

(b2 != 0)) ? 1: 0), mu2), 
default: EvalPair(Or(vl, v2), mu) 

), 

default: EvalPair(Or(vl, e2), mu) 

))), 

Equal(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 

Value(vl) ? Value(v2) ? EvalPair(lntOp((vl == v2) ? 1 

: 0), mu2) 

: EvalPair(Equal(vl, v2), mu) 

: EvalPair(Equal(vl, e2), mu) 

)), 

NotEqual(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 

Value(vl) ? Value(v2) ? EvalPair(IntOp((vl != v2) ? 1 

: 0), mu2) 

: EvalPair(NotEqual(vl, v2), mu) 

: EvalPair(NotEqual(vl, e2), mu) 

)), 

Deref(el): 

let EvalPair (vl, mul) = eval(el, mu) in ( 
with (vl) ( 

Refloc(l) : EvalPair(MemoryLookUp(l, mul), mul), 
default: EvalPair(Deref(vl), mu) 

)), 

Call(el,al): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
let EvalPair(v2, mu2) = EvalList(al, mul, 

ActualParamListNilO) in ( 

with(vl)( 

Lambda(x,e2); with(v2)( 

Call(Unit, a2): eval(ReplaceWithActuals( 
a2, X, e2), mu2), 

Call(Dead, a2): EvalPair(Call(vl, a2), mu2), 
default: EvalPair(Call(vl, 


55 



v2: :ActualParamListNil) ,mTi) 

/* never happens */ 

), 

default: EvalPair(Call(vl, al), mu) 

))), 

Assign(el, e2): 
with(el) ( 

Deref(el): 

let EvalPair(vl, mul) = eval(el, mu) in ( 

let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

Refloc(l): with (MemoryLookUp(l, mu2)) ( 

Dead: EvalPair(Assign(Deref(Dead), e2), 
mu), 

default: Value(v2) ? 

EvalPair(v2, UpdateMemoryd, v2, mu2)) 

: EvalPair(Assign(Varloc(1), v2), mu) 

), 

default:EvalPair(Assign(Deref(vl), e2), mu) 

))), 

Subscript(e3, e4): 

let EvalPair(vl, mul) = 

eval(SubscriptL(e3,e4) , mu) in ( 
let EvalPair(v2, mu2) = eval(e2, mul) in ( 
with (vl) ( 

Varloc(l): Value(v2) ? EvalPair(v2, 

UpdateMemory(l, v2, mu2)) 

: EvalPair(Assign(vl,v2), mu), 
default : EvalPair(Assign(vl, e2), mu) 

))), 

Varloc(1): 

let EvalPair(v, mul) = eval(e2, mu) in ( 

Value(v) ? EvalPair(v, UpdateMemory(l, v, mul)) 

: EvalPair(Assign(el,v), mu)), 
default: EvalPair(e, mu) 


), 

AddrOf(el): 
with(el) ( 

Deref(e2): 

let EvalPair(vl, mul) = eval(e2, mu) in ( 
with (vl) ( 

Refloc(l): EvalPair(vl, mul). 


56 



default : EvalPair(AddrOf(Deref(vl)), mu) 

) 

), 

Subscript(e2, e3): 

let EvalPair(vl, mul) = eval(SubscriptL(e2, e3),mu) in ( 
with, (vl) ( 

Varloc(l): EvalPair(Refloc(l), mul), 
default : EvalPair(AddrOf(vl), mu) 

) 

), 

Varloc(l): EvalPair(Refloc(l), mu), 
default : EvalPair(e, mu) 

), 

Compose(el, e2); 

let EvalPair(v, mul) = eval(el, mu) in ( 

Value(v) ? eval(e2, mul): EvalPair(Compose(v, e2), mu) 

), 

While(el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 
with (vl) ( 

IntOp(n): (n != 0) ? 

let EvalPair(v2, mu2) = eval(e2, mul) in ( 
Value(v2) ? eval(e, mu2) 

: EvalPair(While(vl, v2), mu)) 

: EvalPair(Unit, mul), 
default: EvalPair(While(vl, e2), mu) 

)), 

Cond(el, e2, e3) : 

let EvalPair(vl, mul) = eval(el, mu) in ( 
with (vl) ( 

IntOp(n): eval((n != 0) ? e2: e3, mul), 
default: eval(Cond(vl, e2, e3), mu) 

)), 

LetVar(x, el, e2): 

let EvalPair(vl, mul) = eval(el, mu) in ( 

Value(vl) ? 

let 1 = (newsymiO) [2:] in ( 
let EvalPair(v2, mu2) = 

eval(ReplaceIn(Varloc(Loc(l,INTtoSTR(0))), x, e2), 
UpdateMemory(Loc(l, INTtoSTR(O)), vl, mul)) in ( 
Value(v2) ? EvalPair(v2, UpdateMemory(Loc(l, 
INTtoSTR(O)), Dead, mu2)): EvalPair(v2, mu))) 


57 





}; 


: EvalPair(LetVcir (x, vl, e2), mu)), 

Let(x, el, e2): 

let EvalPairCvl, mul) = eval(el, mu) in ( 

Value(vl) ? eval(ReplaceIn(vl, x, e2), mul) 

: EvalPair(Let(x, vl, e2), mu) 

. ), 

LetArr(x, el, 62): 

let EvalPairCvl, mul) = eval(el, mu) in ( 
with(vl) ( 

IntOp(n): (n > 0) ? 

let EvalPair(v2, mu2) = InitializeArrayCn, mul) in ( 
let EvalPair(v3, mu3) = eval(ReplaceIn(v2, x, e2), 

mu2) in ( 

Value(v3) ? EvalPair(v3,MarkDead(n, v2, mu3)) 

: EvalPair(v3, mu2) 


)) 

: EvalPair(LetArr(x, vl, e2), mu), /* n <= 0*/ 
default: EvalPair(LetArr(x, vl, e2), mu) 

)), 

Pair(el, e2): 

let EvalPairCvl, mul) = eval(el, mu) in ( 

Value(vl) ? let EvalPair(v2, mu2) = eval(e2, mul) in C 
Value(v2) ? EvalPair(Pair(vl, v2), mu2) 

: EvalPair(Pair(vl, v2), mu) 

) 

: EvalPairCe, mu) 

). 

default: EvalPair(e, mu) 

) 


/* Is the expression 
BOOL Value(exp e) { 
with(e) ( 

Lambda(*,*): 
IntOpC*) : 
RealOpC*) : 
ReflocC*) : 
IdentC*) : 
Unit : 

default : 


e a syntactic value? */ 


true, 

true, 

true, 

true, 

true, 

true, 

false 


) 


58 



>; 


/* Replace all free occurrences of formal pareimeters given by 
* f in e with the actual parameters given by a. 

*/ 

exp ReplaceWithActuals(actualParamList a, formalParamList f, exp e) { 
with(a) ( 

ActualParamListPair(vl, rest1): 
with(f) ( 

FormalParamListPair(x, rest2): 

Replaceln(vl, x, ReplaceWithActuals(restl, rest2, e)), 
default: e 

), 

default: e 

) 

}; 

/* [v/x]e — replace all free occurrences of x in e by v */ 
exp Replacein (exp v. Id x, exp e) { 
with (x) ( 

IdNulK): e, 

Identifier(y): ReplaceAux(v, y, e) 

) 

}; 

exp ReplaceAux (exp v, ID id, exp e) { 
with (e) ( 

Ident(Identifier(x)): (id == x) ? v: e, 

AddrOf(el): AddrOf(ReplaceAux(v, id, el)), 

Assign(el,e2): Assign(ReplaceAux (v, id, el),ReplaceAux (v, id 
,e2)), 

Deref(el): Deref(ReplaceAux(v, id, el)), 

Compose(el, e2): Compose(ReplaceAux(v, id, el), ReplaceAux(v, 
id,e2)), 

Lambda(f, el): IsFormalParameter(id, f) ? e 

: Lambda(f, ReplaceAux(v, id, el)), 

While(el, e2): While(ReplaceAux(v, id, el),ReplaceAux(v, id, e2) 

), 

Letddentifier(x) , el, e2) : 

(id == x) ? Let(Identifier(x), ReplaceAux(v, id, el), e2) 

: Let(Identifier(x), ReplaceAux(v, id, el), 
ReplaceAux(v, id, e2)). 


59 


LetVar(Identifier(x), el, e2): 

(id == x) ? LetVar(Identifier(x), ReplaceAux(v, id, el), e2) 

; LetVar(Identifier(x) , ReplaceAux(v, id, el), 
ReplaceAux(v, id, e2)), 

LetArr(Identifier(x), el, e2): 

(id == x) ? LetVar(Identifier(x), ReplaceAux(v, id, el), 

e2) 

: LetArr(Identifier(x), ReplaceAux(v, id, el), 

ReplaceAux(v, id, e2)), 
PtrAdd(el, e2): PtrAdd(ReplaceAux(v, id, el), ReplaceAux(v, id, 
e2)), 

Subscript(el, e2) : Subscript(ReplaceAux(v, id, el), ReplaceAux( 

V, id, e2)). 

Subscript!(el, e2): Subscript!(ReplaceAux(v, id, el),ReplaceAux( 

V, id, e2)), 

Pair(el, e2): Pair(ReplaceAux(v, id, el), ReplaceAux(v, id, e2) 

), 

Sum(el, e2): Sum(ReplaceAux(v, id, el), ReplaceAux(v, id, e2)), 
Diff(el, e2) : Diff (ReplaceAux(v, id, el), ReplaceAux(v, id, e2 
)), 

Prod(el, e2): Prod(ReplaceAux(v, id, el), ReplaceAux(v, id, e2) 

), 

Quot(el, e2): Quot(ReplaceAux(v, id, el), ReplaceAux(v, id, e2) 

), 

!essThcin(el, e2) ; 

!essThan(ReplaceAux(v, id, el), ReplaceAux(v, id, e2)), 
!essTh.anOrEqual(el, e2) : 

!essThcLnOrEqual(ReplaceAux(v, id, el), ReplaceAux(v, id, e2)), 
GreaterThan(el, e2): 

GreaterThan(ReplaceAux(v, id, el), ReplaceAux(v, id, e2)), 
GreaterTlianOrEqual(el, e2) : 

GreaterThanOrEqual(ReplaceAux(v, id, el), ReplaceAux(v,id,e2) 

), 

Not(e): Not(ReplaceAux(v, id, e)), 

And(el, e2): And(ReplaceAux(v, id, el), ReplaceAux(v, id, e2)), 
Or(el, e2): Or(ReplaceAux(v, id, el), ReplaceAux(v, id, e2)), 
Equal(el, e2): Equal(ReplaceAux(v, id, el), ReplaceAux(v,id,e2) 
), 

NotEqual(el, e2): NotEqual(ReplaceAux(v, id, el), 

ReplaceAux(v, id, e2)), 

Cond(el, e2, e3): Cond( ReplaceAux(v, id, el), ReplaceAux(v, id, 

e2), ReplaceAux(v, id, e3)), 


60 


>; 


) 


Call(el, 1): Call(ReplaceAux(v, id, el), ReplaceInList(v, id,l) 

), 

default: e 


/* Does id occur in formal parameter list x ? */ 

BOOL IsFormalPairameter(ID id, formalParamList x) { 
with (x) ( 

FormalParamListPairddentifier(v) , rest) : 

(id == v) ? true: IsFormalParajneter(id, rest), 
default: false 

) 

>; 


/* Replace all free occurrences of id in each element e of 1 */ 
actualParamList ReplaceInList(exp v, ID id, actualParamList 1) { 
with (1) ( 

ActualParamListNil: 1, 

ActualParamListPair(e, rest): 

ReplaceAux(v, id, e) : : ReplaceInList(v, id, rest), 

) 


/* We evaluate the actual paramaters 11 in order and put the 

* results into another list 12. We use the constructor Call 

* as a placeholder to return the result since it is the only 

* expression constructor with a actualParamList type of argument. 

* The first argument of Call is used to indicate if the 

* evaluation of 11 is completed successfully. If so, we return 

* Unit as the first argument and 12 as the second argument, 

* otherwise we return Dead as the first argument and a partially 

* evaluated list as the second argument. 

*/ 

EVAL EvalList( actualParamList 11, MEMORY mu, actualParamList 12) { 
with(ll) ( 

ActualParamListPair(e, rest): 

let EvalPair(v, mul) = eval(e, mu) in ( 

Value(v) ? EvalList(rest, mul, v::12) 


61 



) 


: EvalPair(Call(Dead, ReverseList(ReverseList( 
rest) @ v::12)), mul)), 

default: EvalPair(Call(Uiiit,ReverseList(12)), mu) 

}; 

actualParamList ReverseList(actualParainList 1) { 
with(l) ( 

ActualParamListPair(v, rest): ReverseList(rest) @ 

ActualParamListPair(v, ActualParamListNilO), 

default: 1 

) 

>; 


/* mu[l:=v] — update(extend) memory mu with binding l:=v */ 

MEMORY UpdateMemory (LOCATION 1, exp v, MEMORY mu) { 
with (mu) ( 

NullMemO: MemConcat(l, v, mu), 

MemConcat(12, v2, mu2): (1 == 12) ? MemConcat(l, v, mu2) 

: MemConcat(12, v2, UpdateMemory(l, v, mu2)), 

) 

}; 


exp MemoryLookUp (LOCATION 1, MEMORY mu) { 
with (mu) ( 

MemConcat(12, v2, mu2): (1 == 12) ? v2: MemoryLookUp(1, mu2), 
default: InvalidAddr /^Dereference of a non-existence address */ 

) 

}; 

/* Allocate memory cells for the elements of an array of size n and */ 
/* initialize them to Uninit.*/ 

EVAL InitializeArray(INT n, MEMORY mu) ■{ 
let 1 = (newsymiO) [2:] in ( 

let mul = InitializeArrayAux(n - 1, 1, UpdateMemory(Loc(l, 
INTtoSTR(n-l)), Uninit, mu)) in ( 

EvalPair(Refloc(Loc(l,INTtoSTR(0))), mul) 

)) 


62 



}; 


MEMORY InitializeArrayAuxClNT n, SEGMENT s, MEMORY mu) { 

(n == 0) ? mu: InitializeArrayAux(n - 1, s, 

UpdateMemory(Loc(s,INTtoSTR(ii-l)), Uninit, mu)) 


}; 


/* Mark the cells allocated for the elements of the array as Dead */ 
MEMORY MarkDeadClNT n, exp e, MEMORY mu) { 
with(e) ( 

Refloc(Loc(s,*)): MarkDeadAux(n, s, mu), 
default : mu /* should never be reached */ 

) 

}; 

MEMORY MarkDeadAuxClNT n, SEGMENT s, MEMORY mu) { 

(n == 0) ? mu: MarkDeadAux(n-l, s, 

UpdateMemory(Loc(s,INTtoSTR(n-l)), Dead, mu)) 

}; 


/*3f;3|c3):3|c:t:*******4c***4:************3|c******:|::|c********Nc*********3ic’ic*****:if;4::tc* 

* File Name : explist.ssl * 

* Purpose : A program is an explist composed of terms. * 

*:tc********!(c:(t*!)c*****:H**:)e**j|c**********s(:*******************************/ 

root expList; 

/* Abstract syntax-*/ 

term : Static(exp) 

I Dynamic(exp) 

9 

list expList; 

expList : ExpListPair(term expList) 

I ExpListNilO 


/* Minimal parenthesization-♦/ 

term : Static, Dynamic { exp.precedence = 0; } 


63 




/* Unparsing - 

expList : ExpListPair [ ® ' ["‘/.S(PUNCTUATION: ;'/.S)y.n%n"] ® ] 




/* Concrete input syntax - */ 

ExpList { synthesized expList abs; }; 
expList ~ ExpList.abs; 

ExpList ::= (Exp) { ExpList.abs = Static(Exp.abs) ExpListNilO; } 

I (Exp ’ ExpList) -CExpList$l.abs = 

Static(Exp.abs) :: ExpList$2.abs; } 


* File Name : id.ssl * 

* Purpose : Defines identifiers of the language * 

**)(c*^5|t*******3|c3(c:4:****Jt:**********=|c**>l=******=t:******************=(:*******/ 

/* Abstract syntax coid unparsing-*/ 

Id : IdNullO [ ^ ::= "y.S(PLACEHOLDER:<identifier>'/.S)" ] 

I Identifier(ID) [ ~ :] 


/* Concrete input syntax- */ 

id ■{ synthesized Id abs; }; 

Id ~ id.abs; 

id ::= (ID) { id.abs = Identifier(ID); } 

I (IDENTIFIER.PLACEHOLDER) 

{ id.abs = IdNull; } 


/* Attribution-*/ 

Id {synthesized ID name; 

synthesized BOOL partial; 

>; 

Id : IdNull { 


64 








Id.name = ".undeclared"; 
Id.partial = true; 

} 

I Identifier { 

Id.neime = ID; 

Id.partial = false; 

} 


/ J|t****=(:*********!|t**s|cs|c**s|t:(t*3t:3t:*jl!****:(::t:**)|e**=l=*!t!**!f:!t:=|t*******!f:***!(!*!(t****!t:=|t 

* File Name : if.ssl * 

* Purpose : Defines the if-then-else construct * 

:t:****:(c:(c*)|c**:t:***5lc******!|c:i(cj|c:(c**s|e****!(c=|t + =(:****************=|c*******:|c***:(c:(c:(c / 

/* Abstract syntax- */ 

exp : Cond(exp exp exp); 

/* Minimal parenthesization - */ 

exp : Cond { 

exp$2.precedence = 0; 
exp$3.precedence = 0; 
exp$4.precedence =0; 

} 

9 

I* Unparsing-*/ 

exp : Cond 

[‘ ::= "y.t%{y.S(KEYWORD:ify.S) " @ " yc’/S(KEYWORD:theny.S) " ® 

" y.cy.S (KEYWORD:elsey.S) " @ " y.by.cy.S(KEYWORD:fi'/.S)'/,}"] 

9 

/* Template commands - */ 

transform exp 

on "if" <exp>: Cond(<exp>, <exp>, <exp>), 

on "if" e when (e != <exp>): Cond(<exp>, e, <exp>) 

9 

/* Concrete input syntax - */ 

Exp (IF Exp THEN Exp ELSE Exp FI) 

{ Exp$l.abs = Cond(Exp$2.abs, Exp$3.abs, Exp$4.abs); } 


65 







/sItJteXc************************************************!)'**** *♦♦***♦♦*♦** 

* File Name : if_infer.ssl * 

* Purpose : Type inference for if-then-else construct * 

*****♦♦****♦♦+******♦**************♦******♦*************************/ 

exp : Cond { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.1etvars = exp$l.letvars; 
exp$3.letvaxs = exp$l.letvars; 
exp$4.letvaxs = exp$l.letvars; 
exp$2.s - exp$l.s; 

exp$3.s = Unify(exp$2.typeAssignment, IntType, exp$2.S); 
exp$3.typeEnv = ApplySubstToTypeEnv(exp$3.s, exp$l.typeEnv); 
exp$4.s = exp$3.S; 

exp$4.typeEnv = ApplySubstToTypeEnv(exp$3.S, exp$l.typeEnv); 
exp$l.S = Unify(exp$3.typeAssignment, exp$4.typeAssignment, 
exp$4.S); 

exp$l.typeAssignment = exp$3.typeAssignment; 
exp$l.partial = exp$2.partial II exp$3.partial II 
exp$4.partial; 
exp$4.sv = exp$l.sv; 
exp$3.sv = exp$l.sv; 
exp$2.sv = exp$l.sv; 
exp$4.encl = exp$l.encl; 
exp$3. end = exp$ 1. end; 
exp$2.encl = exp$l.encl; 
exp$2.top = false; 
exp$3.top = false; 
exp$4.top = false; 

} 

3 

exp : Cond {in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst && exp$3.S != FailSubst && 
exp$4.S != FailSubst); } [ TypeErrors @ : "If'/.n" - - - ] 


/♦♦He********************************************♦****♦****♦♦♦******** 


* File Name : infer.ssl ♦ 

* Purpose : Implementation of the type inference for * 

* Poly C. This implementation is based on * 

* Dennis Volpano's implementation for core ML with * 

* letvax and first-class refs. ♦ 


STR foreign newsymiO; /* generate symbols *1, *2, *3 .... */ 

/* Poly C has only weaJc type variables.*/ 

TYPEVAR : WeakVar (STR) [@ : 0 ] 


/* We need this phylum to type the functions of Poly C */ 
list TYPEEXPLIST; 

TYPEEXPLIST : TypeExpListNilO [@;] 

I TypeExpListPairCTYPEEXP TYPEEXPLIST) 

C @ ^ ["*/.S(OPERATOR: \<times> y.S)y.o"] @ ] 


TYPEEXP : NullTypeO 

I UniversalTypeO 
I IntType () 

I RealType () 

I UnitType () 

I TypeVar (TYPEVAR) 


[@ : "?" ] 

[@ : "\<bottom>" ] 
[@ : "int" ] 

[(§ : "real" ] 

[0 : "unit" ] 


C@ : 0 ] 

MapType (TYPEEXPLIST TYPEEXP) [@ : "(" (S "‘/S(OPERATOR: 
\<rightarrow> y,S)yo" @ ")" ] 

I PairType (TYPEEXP TYPEEXP) [@ : "(" @ " \<times> " @ 
I RefType (TYPEEXP) [@ : @ " ptr" ] 


,)„ ] 


TYPESCHEME 

: TypeExp (TYPEEXP) [@ : <S] 

I TypeVarBinding (TYPEVAR TYPESCHEME) [@ : "\<forall>" 0 "." ®] 


TYPEEXP TypeExpOfTypeScheme(TYPESCHEME t) { 
with(t) ( 

TypeExp(e): e, 

TypeVarBinding(i, s): TypeExpOfTypeScheme(s), 

) 


67 


}; 


/* Substitutions : Finite functions mapping type variables to types 
* Empty substitution is denoted by IdSubst 
*! 

SUBST : FailSubstO [0 : "FailSubst"] 

I IdSubst0 [@ : ] 

I SubstConcatCTYPEVAR TYPEEXP SUBST) 

[@ : "•/,{<" 0 @ ">y.o" @ ] 


BOOL InSubst(TYPEVAR tyvar, SUBST s) { 
with.(s) ( 

FailSubst: false, 

IdSubst: false, 

SubstConcat(j, *, sub): j == tyvar ? true ; InSubst(tyvar, sub), 

) 

>; 

TYPEEXP LookupInSubst(TYPEVAR tyvar, SUBST s) { 
witlL(s) ( 

FailSubst: NullType, 

IdSubst: UniversalT 3 rpe, 

SubstConcat(j, t, sub): j == tyvar ? t : 

LookupInSubst(tyvar, sub), 
default : tyvar 

) 


TYPEEXP Ult(TYPEEXP t, SUBST s) { /* close substitution s for t */ 

with (t) ( 

TypeVar(v) : InSubst(v, s) ? 

Ult(LookupInSubst(v, s), s) : t, 
default : t 

) 


TYPEEXP RecRealAux(TYPEEXP t, SUBST s) { 
with (t) ( 

TypeVar(v) : let e = LookupInSubst(v, s) in ( 
with(e) ( 


68 



NullType: t, 

UniversalType: t, 
default: RecRealAux(e, s) 

) 

), 

MapType(u, w): MapType(RecRealListAux(u, s), RecRealAux(w, s)), 
P3-irType(u, w): PairType(RecRealAux(u, s) , RecRealAux(w, s)), 
RefType(u): RefType(RecRealAux(u, s)), 
default: t 

) 

}; 


TYPEEXPLIST RecRealListAux(TYPEEXPLIST 1, SUBST s) { 
with(l) ( 

TypeExpListPair(v, 1) : RecRealAux(v, s) :: RecRealListAux(l, s), 
default : 1 

) 

}; 

TYPEEXP RecReaKTYPEEXP t, SUBST s) { 
with(s) ( 

FailSubst: NullType, 

IdSubst; t, 

default: RecRealAux(t, s), 

) 

}; 

SUBST RemoveFromSubst(SUBST s, TYPEVAR id) { 
with (s) ( 

FailSubst: FailSubst, 

IdSubst: IdSubst, 

SubstConcat(i, t, sub): 

i == id ? sub : SubstConcat(i, t, RemoveFromSubst(sub, id)), 

) 

>; 

TYPEEXP ApplySubstToTypeVar(SUBST s, TYPEVAR v) { 
with (s) ( 

FailSubst: NullType, 

default: let t = LookupInSubst(v, s) in ( 
with (t) ( 

UniversalType: TypeVar(v), 


69 


default: ApplySubstToTypeExp(s, t) 

) 

)) 

}; 

TYPEEXP ApplySubstToTypeExpCSUBST s, TYPEEXP t) { 
witli(s) ( 

FailSubst: NullType, 

IdSubst: t, 
default: 
witb(t) ( 

TypeVar(u): ApplySubstToT 3 rpeVar(s, u) , 

MapType(tl, t2): MapType(ApplySubstToTypeExpList(s, tl), 

ApplySubstToTypeExp(s, t2)), 
PairType(tl, t2): PairType(ApplySubstToTypeExp(s, tl), 

ApplySubstToTypeExp(s, t2)), 
RefType(t): RefType(ApplySubstToTypeExp(s, t)), 
default: t 
) 

) 

}; 


TYPEEXPLIST ApplySubstToTypeExpList(SUBST s, TYPEEXPLIST t) { 
with(t) ( 

TypeExpListPair(v, 1): ApplySubstToT 3 rpeExp(s, v) :: 

ApplySubstToTypeExpList(s, 1), 

default : t 

) 


TYPESCHEME ApplySubstToTypeScheme(SUBST s, TYPESCHEME t) { 
witb(t) ( 

TypeExp(e): TypeExp(ApplySubstToTypeExp(s, e)), 
TypeVarBinding(i, u): 

TypeVarBinding(i, ApplySubstToTypeSchenie(RemoveFromSubst( 
s, i), u)), 

) 

}; 


70 



/♦♦♦♦**j|t:((j|c***j|=!t!=(=*********!t:st:*******=t:***+*!|e******** 

* let/letarr/letvar-boTind identifier list * 

********!(:!(:********♦****♦****♦**♦************ + **♦* / 


list LVLIST; 

LVLIST : LVNilO [0 : ] 

I LVCons(Id LVLIST) [@ : @ [", "] @ ] 


LVLIST RemoveFromLVList (Id id, LVLIST 1) { 
with (1) ( 

LVNil : 1, 

LVCons(v as IdNullO, rest) : 

V :: RemoveFromLVList(id, rest), 
LVCons(v, rest) : (v == id) ? rest : 

V :: RemoveFromLVList(id, rest) 

) 

}; 


BOOL InLVList (Id id, LVLIST 1) { 
with(l) ( 

LVNil : false, 

LVCons(v, rest) : (v == id) ? true : InLVList(id, rest), 

) 


f *5iC**5jC3|C********************5iC**5}C*****3|e****5!C5|C3f:*5(C5|C5|C5ic:iC5jC*3|C 

* variable/identifier list * 

list VLIST; 

VLIST : BVNilO [@ : ] 

I BVCons(Id VLIST) [@ : 0 [", "] @ ] 


BOOL InVList (Id id, VLIST 1) { 
with(l) ( 

BVNil : false, 

BVCons(v, rest) ; (v == id) ? true ; InVList(id, rest), 

) 


71 


I :i<:i::(c5fcH«******************************************** 

* static (top level) variable/identifier list * 

* These identifiers are the ones whose * 

* declaration satisfies the conditions to become* 

* top level as explained in Chapter I. * 

****:t:********************************************/ 

list SVLIST; 

SVLIST : SVNilO [0 : ] 

I SVConsCld SVLIST) [@ : @ [", "] <9 ] 


* Type environments * 

TYPEENV : NullTypeEnvO [@ : ] 

I TypeEnvConcat(ID TYPESCHEME TYPEENV) 

[@ : "•/.{[" @ @ "]y.o" ® "•/.}" ] 


/* 

* RemoveFromTypeEnv 

* 

* Remove entry for id from s. 

* Note: we assume s contains only one entry for id. 

*/ 

TYPEENV RemoveFromTypeEnv(ID id, TYPEENV s) { 
with(s) ( 

NullTypeEnv: s, 

TypeEnvConcat(i, t, tail): 
id == i ? tail 

: TypeEnvConcat(i, t, RemoveFromTypeEnv(id, tail)) 

) 

}; 

TYPESCHEME LookupInTypeEnv(ID id, TYPEENV s) { 
with(s) ( 

NullTypeEnv: TypeExp(UniversalType), 

TypeEnvConcat(i, t, tail): id == i ? t : LookupInTypeEnv(id, 


72 



) 


tail), 


}; 

TYPEENV ApplySubstToTypeEnvCSUBST s, TYPEENV e) { 
with(s) ( 

IdSubst: e, 

FailSubst; e, 
default: 

with(e) ( 

NullTypeEnv: NullTypeEnv, 

TypeEnvConcat(i, t, tail): 

TypeEnvConcat(i, ApplySubstToTypeScheme(s, t), 
ApplySubstToTypeEnvCs, tail)), 

) 

) 

>; 


/ ♦♦♦♦♦***♦♦*♦♦♦♦:(£**++♦♦**♦**♦♦** 

* Generate a generic instance * 

He ******** ************** ********* ! 

/* list of type variables */ 
list TVLIST; 

miST : TVNilO [© : ] 

I TVConsCTYPEVAR TVLIST) [© : © [", "] © ] 


/* return all type vars in type exp t */ 

TVLIST Tvarsin (TYPEEXP t, TVLIST 1) { 
with (t) ( 

TypeVar(v) : v 1, 

MapType(tl,t2) : Tvarsin(t2,TvarsInList(t1,1)), 

PairType(tl,t2) : TvarsIn(t2,TvarsIn(tl,l)), 
RefType(t) : Tvarsln(t, 1), 

default : 1 

) 

}; 


TVLIST TvarsInList (TYPEEXPLIST t, TVLIST 1) { 


73 



with(t) ( 

TypeExpListPair(v, rest) : TvarsIiiList(rest, Tvarsln(v, 1)), 
default : 1 

) 

>; 


/* is type var x in type var list? */ 

BOOL InTVList (TYPEVAR x, TVLIST 1) { 
with(l) ( 

TVNil : false, 

TVCons(v, rest) : (v == x) ? true : InTVList(x, rest) 

) 

}; 


/* all X members not in y */ 

TVLIST Bar (TVLIST x, TVLIST y) { 
with (x) ( 

TVNil : TVNil, 

TVCons(v,rest) : InTVList(v, y) ? Bar(rest,y) 
: TVCons(v, Bax(rest, y)) 

) 

}; 


/* free type vars in scheme */ 

TVLIST FreeScheme (TYPESCHEME s, TVLIST scvs) { 
with (s) ( 

TypeExp(t) : Bar( Tvarsln(t,TVNil), scvs), 

TypeVarBinding(v, rest) : FreeScheme(rest, TVCons(v,scvs)) , 

) 

>; 


/* free type vars in type environment */ 

TVLIST FreeTe (TYPEENV te) •{ 
with(te) ( 

NullTypeEnv: TVNil, 

TypeEnvConcat(i,t,tail): FreeScheme(t,TVNil) @ FreeTe(tail), 

) 

}; 


74 



/* return a list of noduplicates ♦/ 

TVLIST Nodups (TVLIST 1, TVLIST acc) { 
with(l) ( 

TVNil: acc, 

TVCons(v, tail) : 

InTVList(v,acc) ? Nodups(tail, acc) 

: Nodups(tail, TVCons(v,acc)), 

) 

}; 


TYPESCHEME MkScheme(TVLIST vs, TYPEEXP t) { 
with(vs) ( 

TVNil: TypeExp(t), 

TVCons(v, tail): 

TypeVarBinding(v, MkScheme(tail,t)), 

) 

}; 


/* normal closure */ 

TYPESCHEME Close(TYPEENV a, TYPEEXP t) { 

MkScheme(Bar(Nodups(Tvarsln(t,TVNil),TVNil), FreeTe(a)), t) 

}; 


/* instantiate a scheme */ 

TYPEEXP InstSchemeAux (TYPESCHEME ts, SUBST s) { 
with(ts) ( 

TypeExp(t) : ApplySubstToT 3 rpeExp(s, t), 
TypeVarBinding(v, rest) : 

InstSchemeAux(rest, SubstConcat(v, 
TypeVar(WecikVar(news 3 nai())), s)) 

) 

}; 


TYPEEXP InstScheme(TYPESCHEME s) { 
InstSchemeAux(s, IdSubst) 


75 




}; 


/ 3|c 5|c 5f: :|c 5ic * 5}C :i*c 3f: 5f: sf: 3jc* Sjcsjc 5js **************** ** 

* Unification of type expressions * 
*************************************/ 

SUBST Unify(TYPEEXP t, TYPEEXP u, SUBST s) { 

s == FailSnbst ? FailSubst : Equate(Ult(t, s), Ult(Uj s), s) 

}; 


/* unifies lefthand side of a function space operator */ 

SUBST UnifyList(TYPEEXPLIST t, TYPEEXPLIST u, SUBST s) { 

(s == FailSubst) ? FailSubst : 
with (t) ( 

TypeExpListPair(vl, restl) : 
with(u) ( 

TypeExpListPair(v2, TypeExpListNilO) : 

Equate(Ult(vl, s), Ult(v2, s), s), 

TypeExpListPair(v2, rest2) : 

UnifyList(restl, rest2. Equate(Ult(vl, s), Ult(v2, s), s)), 
default : s 

). 

default : s 

) 


/* returns length of a list */ 

INT Length(TYPEEXPLIST 1) { 
with(l) ( 

TypeExpListPair(v, rest) : 1 + Length(rest), 
default : 0 

) 

}; 


SUBST Equate (TYPEEXP t, TYPEEXP u, SUBST s) { 
t == u ? s : 
with (t) ( 


76 



UniversalTypeO : s, 

TypeVar(v) : 
with(ii) ( 

UniversalTypeO: s, 

default: TypeVarOccurCheck(v, u, s) ? FailSubst : 
SubstConcat(v, u, s), 

), 

RefType(tl): 
with(u) ( 

UniversalTypeO: s, 

TypeVar(ul): Equate(u, t, s), 

RefType(ul): Unify(tl, ul, s), 
default: FailSubst, 

), 

MapType(tl, t2): 
with(u) ( 

UniversalTjrpeO: s, 

TypeVar(ul): Equate(u, t, s), 

MapType(ul, u2): (Length(tl) == Length(ul)) ? 

Unify(t2, u2, UnifyList(tl, ul, s)) : FailSubst, 
default: FailSubst, 

), 

PairType(tl, t2): 
with(u) ( 

UniversalTypeO: s, 

TypeVar(ul): Equate(u, t, s), 

PairTypeCul, u2): Unify(t2, u2, Unify(tl, ul, s)), 
default: FailSubst, 

), 

default: 

with(u) ( 

UniversalTypeO: s, 

TypeVar(ul): SubstConcat(ul, t, s), 
default: FailSubst, 

), 

) 

}; 


BOOL TypeVarOccurCheck(TYPEVAR v, TYPEEXP t, SUBST sub) { 
with(t) ( 

UniversalTypeO: false. 


77 


TypeVar(u): (u == v) || (InSubst(u, sub) && 

TypeVarOccurCheck(v, LookupInSubst(u, sub), sub)), 
MapType(tl, t2) : TypeVarOccurCheckList(v, tl, sub) II 
TypeVarOccurCheck(v, t2, sub), 

PairType(tl, t2): TypeVarOccurCheck(v, tl, sub) II 

TypeVarOccurClieck(v, t2, sub), 

RefType(tl): TypeVarOccurCheck(v, tl, sub), 
default: false 
) 


/* implement TypeVarOccurCheck for a list of type expressions */ 
BOOL TypeVarOccurCheckList(TYPEVAR v, TYPEEXPLIST t, SUBST sub) { 
with(t) ( 

TypeExpListPair(u, rest) : 

TypeVarOccurCheck(v, u, sub) ? true 

:TypeVarOccurCheckList(v, rest, sub). 


default : false 

) 

}; 


/* Is e a value of Poly C ? */ 

BOOL NonExpeinsive (exp e) { 
with(e) ( 

Pair(s, t) : NonExpcinsive(s) 

Ident(*) : true. 

Lambda(*, *) : true, 

default : false 


NonExpansive(t), 


) 

>; 

/* Initial type environment is empty */ 
TYPEENV InitialEnvironmentO { NullTypeEnv 


/ :|c 5|c 5|c 5|c :jc 5f: 3(c ^ :f: 5fc ^ 3jc 3^: :^c :f: 4:5|c 4c 5|c :<c 5jc 5^ :f: af: :1c He * **** ************* * 

* File Name : int.ssl * 

* Purpose : Integer operators * 


78 




+ He************* ******* / 


/* Abstract syntax-*/ 

exp : IntOp(INT) 

I Sum, Diff, Prod, Quot(exp exp) 

I LessThan, LessThanOrEqual, GreaterThan, 

GreaterThanOrEqual(exp exp) 

J 


/* Minimal parenthesization - */ 

exp : Sum, Diff PP2(6) 

I Prod, Quot PP2(7) 

I LessThan, LessThanOrEqual, GreaterThan, GreaterThainOrEqual 
PP2(5) 


/* Unparsing-♦/ 

exp : IntOp [ ~ :] 

I Sum [ ^ ::= "’/.{•/.S(PUNCTUATION:" Ip ''‘/.S)" 0 " ‘/.S(OPERATOR:+%S) 

%o " 0 "‘/.S(PUNCTUATION:" rp "'/.S)’/.}" ] 

I Diff [ ~ "•/.{‘/.S(PUNCTUATION:" Ip -/.S)" 0 " '/.S(OPERATOR:-7,S) 

7.0 " (§ "7.S(PUNCTUATION:" rp "7.S)7.}" ] 

I Prod [ ~ ::= "7.-C7.S (PUNCTUATION: " Ip "7.S)" @ " 7.S (OPERATOR: *7.S) 
7.0 " @ "7.S(PUNCTUATION:" rp "7.S)7.}" ] 

I Quot [ - ::= "7.{7.S (PUNCTUATION: " Ip "7.S)" @ " 7.S (OPERATOR:/7.S) 
7.0 " @ "7.S(PUNCTUATION:" rp "7.S)7.}" ] 

I LessThan [ ~ : := "7.-C7.S(PUNCTUATION:" Ip "7.S)" @ " 

7.S(OPERATOR:<7.S)7.0 " 0 "7.S(PUNCTUATION:" rp "7.S)7.}"] 
I LessThanOrEqual [ ~ : := "7.-C7.S(PUNCTUATION: " Ip "7.S)" @ " 7.S( 
OPERATOR:7.<le>7.S)7.0 " @ "7.S (PUNCTUATION: " rp "7.S)7.}"] 
I GreaterThan [ ~ : := "7.-C7.S(PUNCTUATION:" Ip "7.S)" 0 " 7.S( 

OPERATOR:>7.S)7.0 " ® "7.S(PUNCTUATION: " rp "7.0)7.}"] 

I Great erThanOrEqual [ " : := "7.-C7.S (PUNCTUATION:" Ip "7.S)" @ " 

7.S(OPERATOR:7.<ge>7.S)7.0 " @ "7.S(PUNCTUATION:" rp "7.S)7.}"] 


/* Template commeinds-*/ 

tremsform exp 

on "+" <exp> : Sum(<exp>, <exp>), 
on "-" <exp> : Diff(<exp>, <exp>), 
on "*" <exp> : Prod(<exp>, <exp>), 
on "/" <exp> : Quot(<exp>, <exp>), 


79 








on "<" <exp> : LessThan(<exp>, <exp>), 
on "<=" <exp> : LessThcLnOrEqual(<exp>, <exp>), 
on ">" <Gxp> ; GrGaterThan(<exp>, <exp>), 
on ">=" <exp> : GreaterThanOrEqual(<exp>, <exp>) 

/* Concrete input syntax- */ 

Exp ::= (INTEGER) { Exp$l.abs= IntOp(STRtoIMT(INTEGER)); } 

I (Exp ’+’ Exp) { Exp$l.abs = Sum( Exp$2.abs, Exp$3.abs); } 

I (Exp Exp) { Exp$l.abs = Diff(Exp$2.abs, Exp$3.abs); } 

I (Exp Exp) { Exp$l.abs = Prod(Exp$2.abs, Exp$3.abs); } 

I (Exp ’/’ Exp) { Exp$l.abs = Quot(Exp$2.abs, Exp$3.abs); } 

I (Exp ’<’ Exp) { Exp$l.abs = LessThan(Exp$2.abs, Exp$3.abs); } 
I (Exp LESSEQUAL Exp prec LESSEQUAL) 

{ Exp$l.abs = LessThaai0rEqual(Exp$2.abs, Exp$3.abs); } 

I (Exp Exp) {Exp$l.abs = GreaterThan(Exp$2.abs, Exp$3.abs); } 
I (Exp GREATEREQUAL Exp prec GREATEREQUAL) 

{ Exp$l.abs = GreaterThanOrEqual(Exp$2.abs, Exp$3.abs); } 


* File Name : int_infer.ssl * 

♦ Purpose : Type inference for integer operators * 

exp : IntOp { 

exp.typeAssignment = IntType; 

exp.S = exp.s; 

exp.partial = false; 

} 

I Sum, Diff, Prod, Quot { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.1etvars = exp$l.letvars; 
exp$3.letvars = exp$1.letvars; 
exp$2.s = exp$l.s; 

exp$3.s = Unify(exp$2.typeAssignment, IntType, exp$2.S); 
exp$3.typeEnv = ApplySubstToTypeEnv(exp$3.s, 
exp$l.typeEnv); 

exp$l.S = Unify(exp$3.t3rpeAssignment, IntType, exp$3.S); 
exp$l.typeAssignment = IntType; 


80 





exp$l.partial = exp$2.partial || exp$3.partial; 

exp$3.sv = exp$l.sv; 

exp$2.sv = exp$l.sv; 

exp$3.encl = exp$l.Gncl; 

exp$2.encl = exp$l.encl; 

exp$2.top = false; 

exp$3.top = exp$l.top; 

} 

LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual { 
exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$3.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 

exp$3.s = Unify(exp$2.typeAssignment, IntType, exp$2.S); 

exp$3.typeEnv = ApplySubstToTypeEnv(exp$3.s,exp$l.typeEnv); 

exp$l.S = Unify(exp$3.t3rpeAssignment, IntType, exp$3.S); 

exp$l.typeAssignment = IntType; 

exp$l.partial = exp$2.partial || exp$3.partial; 

exp$3.sv = exp$l.sv; 

exp$2.sv = exp$l.sv; 

exp$3.encl = exp$l.encl; 

exp$2.encl = exp$l.encl; 

exp$2.top = false; 

exp$3.top = exp$l.top; 


Sum, Diff, Prod, Quot { in TypeErrors on (exp$l.S == FailSubst 
&& exp$2.S != FailSubst && exp$3.S != FailSubst); 

} 


Sum 

[ TypeErrors @ : 

"Sum'/n" “ ~ 

] 

Diff 

[ TypeErrors @ 

: "Diffy.n" ~ 

“ ] 

Prod 

[ TypeErrors 0 

: "Prody.n" ^ 

' ] 

Quot 

[ TypeErrors <3 

: "Quoty.n" 

- ] 


LessThan, LessThanOrEqual, GreaterThan, Great erThanOrEqual -( 
in TypeErrors on (exp$l.S == FailSubst && exp$2.S != 

FailSubst && exp$3.S != FailSubst); 

> 

LessThan [ TypeErrors @ : "LessThan5{n" ~ ~ ] 

LessThanOrEqual [ TypeErrors ® : "LessThanOrEqual’/n" “ ~ ] 

GreaterThan [ TypeErrors @ : "GreaterThan‘/on" “ ~ ] 

Great erThanOrEqual 





[ TypeErrors @ : "GreaterThanOrEquaiyoii" “ ~ ] 


* File Name : lambda.ssl * 

* Purpose : * 

♦ ♦♦♦♦it:*:)!*********************************************!*:**************/ 

/* An address is a pair of a segment and an offset. */ 

# define SEGMENT STR 

# define OFFSET STR 

/* Formal parameters of a function is a list of identifiers. */ 

/* Abstract syntax-*/ 

list formalParamList; 

formalParamList : FormalParamListNilO 

I FormalParamListPairdd formalParamList) 


FormalParamList { synthesized formalParamList abs; }; 


/* Actual parameters of an application is a list of expressions. */ 

/* Abstract syntax-*/ 

list actualParamList; 

actualParamList : ActualParamListNilO 

I ActualParamListPair(exp actualParamList) 

ActualParamList { synthesized actualParamList abs; 

jif. -♦/ 


/* Abstract syntax-*/ 

exp : VoidExpO 

I Refloc, Varloc(LOCATION) 

I Ident(Id) 

I Lambda(formalParamList exp) 

I Call(exp actualParamList) 


82 







LOCATION : NullLocO [@ : ] 

I Loc(SEGMENT OFFSET) [ ~ ---••)<• ] 

> 

/* Minimal parenthesization - */ 

exp ■[ inherited INT precedence; }; 

# define PPl(n) {\ 

local STR lp;\ 
local STR rp;\ 
exp$2.precedence = (n);\ 

Ip = ($$.precedence > (n)) ? "(" : 

rp = ($$.precedence > (n)) ? ")" : 

} 

# define PP2(n) {\ 

local STR lp;\ 
local STR rp;\ 
exp$2.precedence = (n);\ 
exp$3.precedence = (n)+l;\ 

Ip = ($$.precedence > (n)) ? "(" : 

rp = ($$.precedence > (n)) ? ")" : 

} 

/* 

* Values are a subset of the expressions, so SSL expects values to 

* to be attributed as well since expressions are attributed. But the 

* attribution is not important so we define two macros to silence SSL 
*/ 

# define SYNSILENCE(P) P.typeAssignment = NullType;\ 

P.S = IdSubst();\ 

P.partial = false; 

# define INHSILEMCE(P) P.typeEnv = NullTypeEnv;\ 

P.letvars = LVNil();\ 

P.S = IdSubst();\ 

P.precedence = 0;\ 

P.sv = SVNil();\ 

P.encl = true;\ 


83 



P.top = false; 


exp 

TT . 

: Call 

1 Lambda 

9 

PPl(O) 

PPl(O) 

unparsing - 

exp : VoidExp 

c 

::= "y.S(PLACEHOLDER:<exp>y.S)" ] 

1 

I dent 

[ ~ 

1 — 1 

< 

II 

1 

Refloc 

[ ~ 


1 

Varloc 

C * 

~ ] 

1 

Call 

C " 

:= @ "y.{y.S(PUNCTUATION:(y,S)y.o" 0 

1 

Lambda 

"y,S (PUNCTUATION:) ’/.S)'/,}"] 

"y.{y.S(PUNCTUATION:" Ip "y.S)y.S(PUNCTUATION 


•/.<lambda>C/.S)" @ "‘/.S(PUNCTUATION:)y.S)y.S(PUNCTUATION: 
{y.S)y.L" @ "y.S (PUNCTUATION: } y,S)y.S (PUNCTUATION: 

" rp "y.s)" "y.by,}"] 


/* Template rules-*/ 

transform exp 

on "fun" e: Lambda(<formalParamList>, e), 

on "call" <exp> : Call(<exp>, <actualParamList>), 
on "call" e : Call(e, <actualParamList>) 


/* Concrete input syntcix-*/ 

Exp { synthesized exp abs; }; 
exp " Exp.abs; 

Exp ::= (EXP.PLACEHOLDER) { Exp.abs = VoidExp; } 

I (id) { Exp.abs = Ident(id.abs); y 

I (LAMBDA '(’ FormalParamList >')’ ’i’ Exp '}') 

{ Exp$l.abs = Lambda(FormalParamList.abs, Exp$2.abs); } 

I Exp 00 

{ Exp$l.abs = Exp$2.abs ; } 

I (Exp O' ActualParamList ')' ) 


84 






{ Exp$l.abs = Call(Exp$2.abs, ActualParamList.abs); } 


/* Unparsing-♦/ 

formalParamList : FormalParamListNil [@:] 

I FormalParamListPair [ 0 : '• ["/.S(PUNCTUATION: 

,y.S) to" ] @ "%}•'] 


/* Concrete input syntax - 

formalParamList ~ FormalParamList.abs; 

FormalParamList ::= (id) •{ FormalParamList.abs = 

(id.abs :: FormalParamListNil); } 
I (id FormalParamList) ■{ FormalParamList$l .abs = 

(id. abs :: FormalParamList$2.abs) ; }■ 


/* Unparsing-♦/ 

actualParamList : ActualParamListNil [@:] 

I ActualParamListPair [ @ ; “ ["'/.S(PUNCTUATION://.S) 

lo" ] @] 


/* Concrete input synteix-*/ 

actualParamList ~ ActualParamList.abs; 

ActualParamList ::= (Exp) { ActualParamList.abs = Exp.abs :: 

ActualParamListNil0; } 
I (Exp ActualParamList) { ActualParamList$l.abs = 

Exp.abs :: ActualParamList$2.abs; } 


/ ************************+5)t**********st:=t:*********=t!*******=|t*=(:*******+** 

* File Name : laimbda_infer.ssl ♦ 

* Purpose : * 

**5^c:^c5^c5f::^c**5^c*^5^:J^c*:f:5t:**♦*****♦***♦************5^<***********5^c*5^c**5^«******5^c* / 

/* Common attributes of exp and actualParamList. 

* Attibutes end, top and sv are used in checking if 

* the free identifiers of a lambda abstraction are top level, 
end shows if an expression is enclosed by a lambda abstraction; 


85 






top shows if an expression occurs in a top level scope. For 
instance in letvar x = e_l in e_2, e_l.top is always false. 

If this letvar expression is enclosed by coi expression e then 
e_2.top gets the same value as the value of e.top. Otherwise, 
e_2.top is true; sv is a list of top level identifiers. 

*/ 

exp, actualParamList { 

inherited TYPEENV typeEnv; 
inherited LVLIST letvaxs; 
synthesized BOOL partial; 
synthesized SUBST S; 
inherited SUBST s; 
inherited BOOL end; 
inherited BOOL top; 
inherited SVLIST sv; 

}; 


/* Types of expressions of an actualParamList are hold in 

* texlist. texlist is a TYPEEXPLIST which is implemented 

* using SSL list. 

*/ 

actualParamList { synthesized TYPEEXPLIST texlist; }; 

exp { synthesized TYPEEXP typeAssignment; }; 

actualParamList : ActualParamListPair •{ 

actualParamList$l.texlist = exp.typeAssignment:: 

actualParamList$2.texlist; 
exp. typeEnv = actualParamList$l .t 3 rpeEnv; 
actualParamList$2.typeEnv = ApplySubstToT 3 p)eEnv(exp.S, 

actualParamList$l.typeEnv); 
exp.letvaxs = actualParamList$l.letvars; 
actualParamList$2.letvaxs = actualParamList$1.letvars; 
exp.s = actualParamList$l.s; 
actualParamList$2.s = exp.S; 
exp. end = actualParamList$l.encl; 
actualParamList$2.encl = actualParcimList$l. end; 
exp.top = false; 
actualParamList$2.top = false; 
exp.sv = actualParamList$l.sv; 
actualParamList$2.sv = actualParamList$l.sv; 
actualParamList$l.S = actualParamList$2.S; 


86 



actualParcLmList$l.partial = exp.partial | I 

actualParamList$2.partial; 

exp.precedence = 0; 

} 

I ActualParamListNil { 
actualParamList.texlist = TypeExpListMil; 
actualParamList. S = actualParajnList .s; 
actualParamList.partial = false; 


term : Static, Dynamic { 

local SUBST finalSubst; 
finalSubst = exp.S; 
exp.typeEnv = InitialEnvironment(); 
exp.S = IdSubst; 

exp.letvars = IdNullO :: LVNil; 
local TYPESCHEME finalTypeScheme; 
finalTypeScheme = 

NonExpansive(exp) ? Close(NullTypeEnv, 

RecReal (exp.t 3 rpeAssignment, exp. S)) 

: TypeExp(RecReal(exp.t 3 rpeAssignment, exp.S)); 
exp.top = true; 
exp. end = false; 
exp.sv = SVNilO ; 

> 


term ; Static [ ~ : 0 "y.ny.S(PUNCTUATION: ;y,S) " finalTypeScheme ] 

I Dynamic { 

local exp val; 

val = (exp.S == FailSubst) || (exp.partial) ? 

Ident(Identifier("?")) 

: let EvalPair(v, *) = eval(exp, NullMem) in (v); 

} 

[ ^ : ® "’/.nval " val " '/S (PUNCTUATION: :y.S) " f inalTypeScheme ] 


exp : VoidExp { 

exp.typeAssignment = TypeVar(WeakVar(newsymi())); 
exp.S = exp.s; 


87 



exp. partial = true; 

} 

I Refloc, Varloc {SYNSILENCECexp)} 

I Ident { 

local TYPESCHEME binding; 

binding = LookupInTypeEnv(Id.name, exp.typeEnv); 
exp.typeAssignment = InstScheme(binding); 
exp.S = binding == TypeExp(UniversalType) ? 

FailSubst /* Free variables cause inconsistency */ 
: exp.s; 

exp.partial = Id.partial; 

} 

I Call { 

local TYPEVAR beta; 

exp$2.typeEnv = exp$l.typeEnv; 

exp$2.s = exp$l.s; 

exp$2.letvars = exp$l.letvars; 

actualParamList.letvars = exp$l.letvars; 

actualParamList.s = exp$2.S; 

actualParamList.typeEnv = ApplySubstToTypeEnv(exp$2.S, 

exp$l.typeEnv); 

exp$l.S = Unify(exp$2.typeAssignment, 

MapType(actualParamList.texlist, TypeVar(beta)) , 
actualParamList.S); 
beta = WeakVar(newsymi()); 
exp$l.typeAssignment = TypeVar(beta); 

exp$l.partial = exp$2.partial II actualParamList.partial; 

actualParamList.sv = exp$l.sv; 

exp$2.sv = exp$l.sv; 

actualParamList. end = exp$l. end; 

exp$2. end = exp$l. end; 

actualParamList.top = exp$l.top; 

exp$2.top = false; 

} 

I Lambda { 

local TYPEEXPLIST formalParamType; 
local TYPEEXP tau; 

formalParamType = GenerateTypeVars(formalParamList); 
exp$l.typeAssignment = tau; 

tau = Closed(FreeVarsIn(exp$l, BVNil), exp$l.sv) ? 


88 



MapTypeCformalParamType, exp$2.typeAssignment) 
: NullTypeO; 

exp$l.S = ((tau == NullTypeO) II 

MultipleOccurrencelii(formalParamList)) ? FailSubstO 

: exp$2.S ; 

exp$2.s = exp$l.s; 

exp$2. letvars = RemoveFPFroitiLVList(formalParamList, 

exp$l.letvars ); 

exp$2.typeEnv = TypeEnvConcatList(formalPaxamList, 

formalParamType, RemoveFPFromTypeEnv( 
formalParamList, exp$l.typeEnv)); 
exp$l.partial = exp$2.partial; 

exp$2.sv= RemoveFPFromSVList(formalParamList, exp$l.sv); 
exp$2.top = false; 
exp$2.Gncl = true; 


sparse view TypeErrors; 

exp : Ident { in TypeErrors on (exp.S == FailSubst); } 

[ TypeErrors @ : "Id: " “ "'/on" ] 

I Lambda { in TypeErrors on (exp$l.S == FailSubst && 
exp$2.S != FailSubst); } 

[ TypeErrors @ : "Lambday,n" “ “ ] 


transform term 

on "eval-on" 

Static(e) 

when ((!e.partial) && (e.S != FailSubst)) : Dynamic(e), 
on "eval-off" 

Dynamic(e) : Static(e) 

} 


/* Return the free variables of e wrt bound variables list 1 */ 
VLIST FreeVarsIn (exp e, VLIST 1) { 
with (e) ( 

Ident(Identifier(x)) : InVList(Identifier(x), 1)? BVNil 


89 


: BVCons(Identifier(x), BVNil), 
AcldrOf(e) : FreeVarsIn (e,l). 

Subscript(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l) , 

Assign(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l) , 

PtrAdd(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l) , 

Deref(e) : FreeVarsIn (e,l), 

LambdaCf, el) : FreeVarsIn (el, ConcatFormalParajtis(f, 1)), 

Let(Identifier(x), el, e2) : FreeVarsIn (el,l) 0 

FreeVarsIn (e2,Identifier(x)::1) , 
LetVar(Identifier(x), el, e2) : FreeVarsIn (el,l) @ 

FreeVarsIn (e2,Identifier(x)::1) , 
LetArr(Identifier(x),el,e2) : FreeVarsIn (el,l) @ 

FreeVarsIn (e2,Identifier(x)::1) , 
Compose(el, e2) ; FreeVarsIn (el,l) @ FreeVarsIn (e2,l), 

Not(el) : FreeVarsIn (e,l), 

And(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l). 

Or(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l). 

Equal(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l), 

NotEqual(el, e2) : FreeVarsIn (el,l) <9 FreeVarsIn (e2,l), 

Cond(el, e2, e3) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l) <9 

FreeVarsIn (e3,l), 

While(el, e2) : FreeVarsIn (el,l) 0 FreeVarsIn (e2,l), 

Sum(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l), 

Diff(el, e2) : FreeVarsIn (el,l) <9 FreeVarsIn (e2,l), 

Prod(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l), 

Quot(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn (e2,l), 

LessThan(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn(e2,l), 
LessTheinOrEqual(el, e2) : FreeVarsIn (el,l) @ FreeVarsIn(e2,l) , 
GreaterThan(el, e2) : FreeVarsIn (el,l) (9 FreeVarsIn(e2,l), 

GreaterThanOrEqual(el, e2) : FreeVarsIn (el,l) (9 FreeVarsIn(e2,l), 
Pair(el, e2) : FreeVarsIn (el,l) (9 FreeVarsIn(e2,l), 

Call(e,a) : FreeVarsIn (e,l) @ FreeVarsInList(a,l), 
default: BVNil() /* constants and placeholders */ 

) 

}; 


VLIST ConcatFormalParams(formalParamList 1, VLIST bv) { 
with(l) ( 

FormalParamListPair(v, rest) : ConcatFormalParams(rest,v bv), 
FormalParamListNil : bv 

) 

}; 


90 







/* A more general form of FreeVarsIn for finding the 
* free variables in a list of expressions. 

*/ 

VLIST FreeVarsInList(actnalParajnList 1, VLIST bv) { 
with(l) ( 

ActualParamListPair(e,rest) : 

FreeVarsIn(e, bv) @ FreeVarsInList(rest, bv), 
default : BVNilO 

) 

>; 


/* Is fv a subset of 1. In other words, we check 
* if all the free varibles given by fv occur in 1 
*/ 


BOOL Closed(VLIST fv, SVLIST 1) { 
with(fv) ( 

BVNil : true, 

BVCons(v, rest) : 

InSVList(v, 1) ? Closed(rest, 1) 
: false 

) 

}; 


BOOL InSVList (Id id, SVLIST 1) { 
with (1) ( 


>; 


) 


SVNil : false, 

SVCons (v, rest) : (v == id) ? true 
; InSVList(id, rest) 


SVLIST RemoveFromSVList (Id id, SVLIST 1) { 
with (1) ( 

SVNil : 1, 

SVCons(v, rest) : (v == id) ? rest : 

V :: RemoveFromSVList(id, rest) 

) 

}; 


91 


7 * Remove let/letvar/letarr bound variables given 
* 1 from b. 

*/ 

VLIST RemoveLetbounds (VLIST b, LVLIST 1) { 
with (b) ( 

BVNilO : BVNilO, 

BVCons(v, rest) : 

InLVListCv, 1) ? v::RemoveLetbounds (rest,l) 
: RemoveLetbounds (rest,l) 

) 

}; 


/* Generate new type variables for the formal parameters 
* of a function. 

*f 

TYPEEXPLIST GenerateTypeVaxs(formalParamList 1) { 
with (1) ( 

FormalParamListPair(f, rest) : 

TypeExpListPair(TypeVar(WeeLkVar(newsymi())), 
GenerateTypeVars(rest)), 
default : TypeExpListNilO 

) 

}; 


/* Remove the formal paraoneters from type environment */ 
TYPEENV RemoveFPFromTypeEnvCformalParamList 1, TYPEENV t ) { 
with(l) ( 

FormalParamListPair(Identifier(id), rest) : 

RemoveFromTypeEnv(id,RemoveFPFromTypeEnv(rest, t)), 
default : t 

) 

>; 


/* Add type assumptions for the formal parameters given by 1 

* to the type environment. Each formal parameter f in 

* position X of 1, is associated with the type expression given in 

* position X of type expression list e. 

*/ 

TYPEENV TypeEnvConcatList(formalParamList 1, TYPEEXPLIST e,TYPEENV t){ 


92 



with(l) C 

FormalParamListPairddentifier(id) , restl) : 
with (e) ( 

TypeExpListPair(v, rest2) : TypeEnvConcat(id, TypeExp(v), 
TypeEnvConcatList(restl, rest2, t)), 
default : t 
), 

default : t 

) 


LVLIST RemoveFPFromLVList(formalParamList 1, LVLIST Iv) { 
with(l) ( 

FormalParamListPair(v,rest) : 

RemoveFromLVList(v,RemoveFPFromLVList(rest, Iv)), 
default : Iv 

) 

}; 


SVLIST RemoveFPFromSVList(formalParamList 1, SVLIST sv) i 
with(l) ( 

FormalParamListPair(v,rest) : 

RemoveFromSVList(v,RemoveFPFromSVList(rest, sv)), 
default : sv 

) 

}; 


/* Functions can only have distinct formal parameters. */ 
BOOL MultipleOccurrenceIn(formalParamList 1) { 
with(l) ( 

FormalParamListNil : false, 

FormalParamListPair(x, rest) : 

Occur(x, rest) ? true :MultipleOccurrenceIn(rest) 

) 

}; 


BOOL Occur(Id x, formalParamList 1) { 
with(l) ( 

FormalParamListNil : false, 
FormalParamListPair(y, rest) : 


93 


(x == y) ? true : Occur(x, rest) 


}; 


) 


/stc^^slcstc*************************************************************** 

* File Name : let.ssl * 

* Purpose : let and letvar declarations * 

* *****:(e****=t:=l'***************!(=!t:*st!****!)'**************=t:******!t:***=K *♦♦*♦/ 

/* Abstract syntax-*/ 

exp : Let(Id exp exp) 

I LetVarCid exp exp) 

3 


I* Minimal parenthesization - */ 

exp : Let, LetVar { 

exp$2.precedence = 0; 
exp$3.precedence = 0; 

} 


/* Unparsing-*/ 

exp : Let C “ ;:= "'/.{‘/.L'/.S(KEYWORD:lety.S) @ @ 

" y.S (KEYWORD :in'/.S)y.ty,ty.n" @ "y,by.by.ny,S (KEYWORD :endy.S)‘/.by.}" ] 
I LetVar [•'::= "y.{y.Ly,S (KEYWORD rletvar'/.S) " @ @ 

" y.S (KEYWORD :iny.S)y.ty.ty.n" <§ "y.by,by.ny.S(KEYWORD:endy.S)y.by.>" ] 


/* Template commeinds-*/ 

transform exp 

on "let" <exp>: Let(<Id>, <exp>, <exp>), 

on "let<Id><exp>e" e when (e != <exp>): Let(<Id>, <exp>, e), 
on "let<Id>e<exp>" e when (e != <exp>) : Let(<Id>, e, <exp>), 
on "letvar" <exp>: LetVar(<Id>, <exp>, <exp>), 

on "letvar<Id><exp>e" e when (e != <exp>) : LetVar(<Id>, <exp>, e), 
on "letvar<Id>e<exp>" e when (e != <exp>): LetVar(<Id>, e, <exp>) 


/* Concrete input syntax - */ 

Exp ::= (LET id ' = ■’ Exp IN Exp END) { 

Exp$l.abs = Let(id.abs, Exp$2.abs, Exp$3.abs); 

} 


94 








(LETVAR id ASSIGN Exp IN Exp END) { 

Exp$l.abs = LetVar(id.abs, Exp$2.abs, Exp$3.abs); 

} 


/ ♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦st:******************************************* 

♦ File Name : let.infer.ssl * 

* Purpose : Type inference for let and letvar * 

****!|t*******=t:****=|e*****>l=**J|t****!t:****5|e***5|e*3|c*=|c**********=|t***!|c******** / 

/* 

* Two local attributes, sigma and finalTypeScheme, are needed in the 

* attribution of Let; sigma is used to extend the type environment, 

* while finalTypeScheme gives the typing used in the alternative 

* unparsing rule. Type sigma may not be a final type scheme for 

* Id.name because it may contain type variables that get specialized 

* by an enclosing expression, e.g, letvar x=[] in 

* let y = (let z=x in 17) in l::x. The type of z is determined by 

* "l::x" of the enclosing expression "let y = ...". 

* Thus the final type scheme must be formed from the final 

* substitution finalSubst inherited from the root. This is done 

* using the upward remote attribute set {Static.finalSubst, 

* Dynamic.finalSubst}. 

* 

* If attribute finalTypeScheme is used for both purposes, then a 

* type 2 circularity results—there is a mutual dependence between 

* finalTypeScheme and finalSubst. 

* 

* Likewise local attribute tau of LetVar, used in the alternative 

* unparsing rule, must also be formed from finalSubst. 

*/ 

exp : Let { 

local TYPESCHEME sigma; 

local TYPESCHEME finalTypeScheme; 

exp$l.S = exp$3.S; 

exp$l.typeAssignment = exp$3.typeAssignment; 

exp$l.partial = Id.partial || exp$2.partial I I exp$3.partial; 

exp$2.s = exp$l.s; 

exp$2.letvars = exp$1.letvars; 


95 


exp$3.letvars = RemoveFromLVList(Id, exp$l.letvars); 
exp$2.typeEnv = exp$l.typeEnv; 
exp$3.s = exp$2.S; 

exp$3.typeEnv = TypeEnvConcat(Id.name, sigma, 
ApplySubstToTypeEnv(exp$2.S, 

RemoveFromTypeEnv(Id.name, exp$l.typeEnv))); 

sigma = 

NonExpansive(exp$2) ? 

CIose(ApplySubstToTypeEnv(exp$2.S, exp$l.typeEnv), 

RecReal(exp$2.typeAssignment, exp$2.S)) 

: TypeExp(RecReal(exp$2.typeAssignment, exp$2.S)); 
finalTypeScheme = 

NonExpcmsive(exp$2) ? 

Close(ApplySubstToTypeEnv({Static.finalSubst, 

Dynamic.finalSubst}, exp$l.typeEnv), 

RecReal(exp$2.typeAssignment, {Static.finalSubst, 
Dynamic.finalSubst})) 

: TypeExp(RecReal(exp$2.typeAssignment, 

{Static.finalSubst,Dynamic.finalSubst})); 
exp$2.sv = exp$l.sv; 

exp$3.sv = exp$l.top ? exp$l.encl ? RemoveFromSVList(Id, 

exp$l.sv) 

: SVCons(Id,exp$l.sv) 

: exp$l.sv; 

exp$3. end = exp$ 1. end; 
exp$2.encl = exp$l.encl; 
exp$2.top = false; 
exp$3.top = exp$l.top; 

} 

I LetVar { 

local TYPEEXP tau; 

exp$l.S = exp$3.S; 

exp$l.typeAssignment = exp$3.typeAssignment; 

exp$l.partial = Id.partial || exp$2.partial || exp$3.partial; 

exp$2.s = exp$1.s; 

exp$2.letvars = exp$l.letvars; 

exp$3. letvars = (Id == IdMullO) ? exp$l. letvars 

: Id :: RemoveFromLVList(Id, exp$l.letvars); 
exp$2.typeEnv = exp$l.typeEnv; 
exp$3.s = FreeInLambda(Id.name, exp$3) ? 

Unify(TypeVar(WeakVar(newsymi())), 


96 



exp$2.typeAssigiimeiit, exp$2.S) 

: exp$2.S; 
exp$3.typeEnv = 

TypeEnvConcat (Id.name, TypeExp(exp$2.t3rpeAssignment), 
ApplySubstToTypeEnv(exp$3.s, RemoveFromTypeEnv( 
Id.name, exp$l.typeEnv))); 

/♦ use RecReal here only because alternative unparsing rule 
displays type tau so type must be closed */ 
tau = RecReal(exp$2.typeAssignment, {Static.finalSubst, 
Dynamic.finalSubst }); 
exp$2.sv = exp$l.sv; 

exp$3.sv = exp$l.top ? exp$l.encl ? RemoveFromSVList (Id, 

exp$l.sv) 

: SVCons(Id,exp$l.sv) 

: exp$l.sv; 

exp$3.encl = exp$l.encl; 
exp$2.encl = exp$l.encl; 
exp$2.top = false; 
exp$3.top = exp$l.top; 


/* Alternative unparsing- */ 

exp : Let C ~ '"/.{y.Ly.S(KEYWORD:let’/.S) " @ finalTypeScheme 

" = y,o" @ " y.S (KEYWORD :iny.S)y,ty.ty.n" ® "y.by.by.n 
y.S (KEYWORD: end'/S) Xb*/.}" ] 

I LetVar [ ~ "y.{y.Ly.S(KEYWORDtletvarXS) " @ 

tau " var := Xo" @ " ‘/.S(KEYWORD;iny.S)y,ty.ty.n" (§ 
"y.by,by.ny.S (keyword :end'/bXS)yj" ] 


/* Does id occur free in a \-abstraction in e? */ 

BOOL FreeInLambda (ID id, exp e) { 
with (e) ( 

AddrOf(e) : FreeInLambda(id, e), 

Subscript(el, e2) :FreeInLambda(id, el) || FreeInLambda(id, e2), 
Assign(el, e2) : FreeInLambda(id, el) || FreeInLambda(id, e2), 

PtrAdd(el, e2) : FreeInLambda(id, el) || FreeInLambda(id, e2), 

Deref(e) ; FreeInLambda(id, e), 

Lambda(*,*) : Freeln(id, e), 


97 




Let(*,el,e2) : FreeInLambda(id, el) || FreeInLambda(id, e2), 

LetVar(*,el,e2) : FreelnLambdaCid, el) II FreeInLambda(id, e2), 

LetArr(*,el,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 

ComposeCel,e2) : FreelnLajiibdaCid, el) II FreelnLambdaCid, e2) , 

NotCe) : FreelnLambdaCid, e), 

AndCel,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 
DrCel,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 
EqualCel,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 

NotEqualCel ,e2) : FreelnLambdaCid, el) I I FreelnLambdaCid, e2), 
CondCel,e2,e3) : FreelnLambdaCid, el) II FreelnLambdaCid, e2) 

II FreelnLambdaCid, e3), 

WhileCel,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 
SumCel,e2) : FreelnLambdaCid, el) I I FreelnLambdaCid, e2), 
DiffCel,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 

ProdCel,e2) ; FreelnLambdaCid, el) II FreelnLambdaCid, e2), 

QuotCel,e2) : FreelnLambdaCid, el) || FreelnLambdaCid, e2), 

LessThanCel,e2) : FreelnLambdaCid, el) || FreelnLambdaCid, e2), 
LessTheai0rEqualCel,e2) : 

FreelnLambdaCid, el) || FreelnLambdaCid, e2), 
GreaterThanCel,e2) : FreelnLambdaCid, el) || FreelnLambdaCid, e2) , 
GreaterThan0rEqualCel,e2) : FreelnLambdaCid, el) I I 
FreelnLambdaCid, e2), 

PairCel,e2) : FreelnLambdaCid, el) II FreelnLambdaCid, e2), 

CallCe,!) : FreelnLambdaCid, e) || FreeInLambdaListCid, 1), 
default : false /* constants and placeholders ♦/ 

) 


BOOL FreeInLambd 2 A.istClD id, actualParaimList 1) { 

withCD C 

ActualParamListPairCe, rest) : 

CFreeInLambdaCid, e) I I FreeInLambdaListCid, rest)), 
default : false 

) 

}; 

BOOL Freein ClD id, exp e) { /* Does id occur free in e? */ 

with Ce) C 

IdentCldentifierCx)) : id == x, 

AddrOfCe) : FreeInCid, e) , 

Subscript Cel, e2) :FreeInCid, el) || FreeInCid, e2), 
AssignCel, e2) : FreeInCid, el) II FreeInCid, e2), 


98 




PtrAdd(el, e2) : Freeln(id, el) || Freeln(id, e2), 

Deref(e) : Freeln(id, e), 

Lambda(f, el) : !OccursIn(id, f) && Freeln(id, el). 

Let(Identifier(x), el, e2) : FreelnCid, el) || 

(FreelnCid, e2) && id != x), 
LetVar(ldentifier(x), el, e2) : Freeln(id, el) || 

(FreelnCid, e2) && id != x), 
LetArr(*,el,e2) : FreelnCid, el) I I FreelnCid, e2), 
ComposeCel, e2) : FreelnCid, el) |i FreelnCid, e2), 

Not(el) : FreelnCid, el), 

AndCel, e2) : FreelnCid, el) M FreelnCid, e2), 

Or(el, e2) ; FreelnCid, el) || FreelnCid, e2), 

EqualCel, e2) : FreelnCid, el) j| FreelnCid, e2), 

NotEqualCel, e2) : FreelnCid, el) || FreelnCid, e2), 

CondCel, e2, e3) : FreelnCid, el) |j FreelnCid, e2) II 

FreelnCid, e3), 

WhileCel, e2) : FreelnCid, el) || FreelnCid, e2), 

Sum(el, e2) : FreelnCid, el) || FreelnCid, e2), 

DiffCel, e2) : FreelnCid, el) || FreelnCid, e2), 

ProdCel, e2) : FreelnCid, el) || FreelnCid, e2), 

QuotCel, e2) : FreelnCid, el) || FreelnCid, e2), 

LessThanCel, e2) : FreelnCid, el) || FreelnCid, e2), 
LessThanOrEqualCel, e2) : FreelnCid, el) I I FreelnCid, e2), 
GreaterThanCel, e2) : FreelnCid, el) || FreelnCid, e2), 

GreaterThanOrEqnal(el, e2) : FreelnCid, el) || FreelnCid, e2), 
PairCel, e2) : FreelnCid, el) I I FreelnCid, e2), 

Call(e,l) : FreelnCid,e) || FreeInList(id, 1), 
default: false /* constants and placeholders */ 

) 


BOOL OccursInCiD id, formalParamList 1) { 
with (1) ( 

FormalParamListPairCldentifier(x), rest) : 

((x == id) II OccursInCid, rest)), 
default : false 

) 

}; 

BOOL FreeInList (ID id, actualParamList 1) •{ 
with(l) ( 

ActualParamListPairCe, rest) : 


99 



(Freeln(id, e) II FreeInList(id, rest)), 
default ; false 

) 

>; 


/sic 4c 3f:*3(c*:f:*5|c***********sic***** ***************** ************************* 


File Name : letarr.ssl 

Purpose : Definitions for letarr, pointer arithmetic eind 
array indexing. We make a minor change to Poly C 
syntax and denote pointer arithmetic with special 
character \oplus which is a plus sign + and a circle 
around it. But in template panel of the editor this 
sign will be seen as o+ because the current SynGen 
environment can not display this special character 
appropriately. 


* 

* 

* 

* 

* 

* 

* 

* 

* 




/* Abstract syntax:--- */ 

exp : LetArrCid exp exp) 

I PtrAddCexp exp) 

I Subscript(exp exp) 

I Subscript!(exp exp) /* For internal use only. */ 


/* Minimal parenthesization — 
exp : LetArr -[ 

exp$2.precedence = 0; 
exp$3.precedence = 0; 

} 

I PtrAdd PP2(6) 

I Subscript PP2(0) 


*/ 


!* Unparsing- */ 

exp : LetArr [ ‘ "’/.S(KEYWORDrletarr'/S) " @ 

" ‘/.S(KEYWORD :in*/S) 7.t7.t‘/.n" @ "7.b7.b7.n7.S (KEYWORD :end7.S)" ] 
I PtrAdd [■'::= "7.-C" "7.S (PUNCTUATION:" Ip "7.S)" @ "7.S (OPERATOR: 

\<oplus>7.S)7.o " (§ "7,S (PUNCTUATION:" rp "7,S)7.>" ] 

I Subscript [ ~ ::= "7.{" @ "C" @ "]7.}" ] 

I Subscript! "7.{" @ " C" ® "]7.}" ] 


100 






/* Template commcuids-*/ 

transform exp 

on "letarr" <exp>: LetArr(<Id>, <exp>, <exp>), 

on "letarr<Id><exp>e" e when (e != <exp>): LetArr(<Id>, <exp>, e), 
on "letarr<Id>e<6xp>" e when (e != <exp>): LetArr(<Id>, e, <exp>), 
on "\<oplus>" <exp> : PtrAdd(<exp> , <exp>), 
on "[ ]" <exp> : Subscript(<exp>, <exp>) 


/* Concrete input syntax - ♦/ 

Exp ::= (LETARR id '['Exp’]' IN Exp END) { 

Exp$l.abs = LetArr(id.abs, Exp$2.abs, Exp$3.abs); 

} 

I (Exp PTRADD Exp) {Exp$l.abs = PtrAdd( Exp$2.abs, Exp$3.abs); } 
I (Exp '['Exp']') ■[Exp$l.abs = Subscript (Exp$2 .abs, Exp$3. abs) ; ]• 


* File Name : letarr.ssl ♦ 

* Purpose : Type inference for letarr, pointer arithmetic and * 

* array indexing. * 

exp : LetArr { 

exp$l.S = exp$3.S; 

exp$l.typeAssignment = exp$3.typeAssignment; 

exp$l.partial = Id.partial M exp$2.partial || exp$3.partial; 

exp$2.s = exp$l.s; 

exp$2.1etvars = exp$l.letvars; 

exp$3.letvars = RemoveFromLVList(Id, exp$l.letvars); 
exp$2.typeEnv = exp$l.typeEnv; 

exp$3.s = Unify(exp$2.typeAssignment,IntType,exp$2.S); 
exp$3.typeEnv = 

TypeEnvConcat(Id.name, TypeExp(RefType(TypeVar( 
WeakVar(newsymi())))), ApplySubstToTypeEnv(exp$2.S, 
RemoveFromTypeEnv(Id.name, exp$l.typeEnv))); 
exp$2.sv = exp$l.sv; 
exp$3.sv = exp$l.top ? exp$l.encl ? 

RemoveFromSVList(Id, exp$l.sv) 

: SVCons(Id,exp$l.sv) 

: exp$l.sv; 


101 




exp$3. end = exp$ 1. end; 
exp$2.end = exp$l.end; 
exp$2.top = false; 
exp$3.top = exp$l.top; 

} 

I PtrAdd { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$3.letvars = exp$l.letvars; 
exp$2.s = exp$1.s; 

exp$3.s = Unify(RefType(TypeVar(WeakVar(news 3 nai()))), 
exp$2.typeAssignment, exp$2.S); 
exp$3.typeEnv = ApplySubstToTypeEnv(exp$3.s, exp$l.typeEnv); 
exp$l.S = Unify(exp$3.typeAssignment, IntType, exp$3.S); 
exp$l.typeAssignment = 

ApplySubstToTypeExp(exp$l.S, exp$2.typeAssignment); 
exp$l.partial = exp$2.partial || exp$3.partial; 
exp$3. end = exp$ 1. end; 
exp$2. end = exp$ 1. end; 
exp$2.top = false; 
exp$3.top = exp$l.top; 
exp$2.sv = exp$l.sv; 
exp$3.sv = exp$l.sv; 

> 

I Subscript { 

local TYPEEXP tau; 
exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$3.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 

exp$3.s = Unify(RefType(TypeVar(WeakVar(newsymi()))), 
exp$2.typeAssignment, exp$2.S); 
exp$3.typeEnv = ApplySubstToTypeEnv(exp$3.s, exp$l.typeEnv); 
exp$l.S = Unify(exp$3.typeAssignment, IntType, exp$3.S); 
exp$l.typeAssignment = 
with(tau) ( 

RefType(t) : t, 
default ; NullType 

); 

exp$l.partial = exp$2.partial || exp$3.partial; 

tau = ApplySubstToTypeExp(exp$l.S, exp$2.typeAssignment); 

exp$3. end = exp$ 1. end ; 


102 


exp$2.eiicl = exp$l.encl; 
exp$2.top = false; 
exp$3.top = exp$l.top; 
exp$2.sv = exp$l.sv; 
exp$3.sv = exp$l.sv; 

} 

I SubscriptL { 

INHSILENCE(exp$2) /* this attribution is a result */ 
INHSILENCE(exp$3) /* of values being expressions */ 
SYNSILENCE.(exp$l) 


/* Alternative unparsing - */ 

exp : PtrAdd { 

in TypeErrors on (exp$l.S == FailSubst && 

exp$2.S != FailSubst && exp$3.S != FailSubst); 

} [ T 3 rpeErrors @ : "PtrAdd*/,n" ~ ] 

I Subscript { 

in TypeErrors on (exp$l.S == FailSubst && 
exp$2.S != FailSubst); 

} [ TypeErrors @ : "Subscript%n" " “ ] 


/ %=)c***********>(c**************,f:******,(c***+:(:,(c**4:,(-*:(::4:,|,**:)„(::)£,)t,(;**:jt^:4::j,^,|,;j,3),,f: 

* File Name : lex.ssl * 

* Purpose : Lexical syntax, token precedences for concrete input * 

* syntax and style declarations. * 

* ♦♦♦♦♦♦♦^^♦♦♦♦♦♦♦♦♦*s(cs(:****!(e******st!****s|!*>|t****!ft!t!!(cX=********>|c>|t*********=|t / 

/* Lexical syntcix- */ 

WHITESPACE : WhiteSpaceLex < [\ \t\n] >; 

EXP_PLACEHOLDER: ExpPlaceholderLex < "<exp>" >; 

IDEMTIFIER_PLACEHOLDER: IdentifierPlaceholderLex < "<identifier>" >; 

LAMBDA : LambdaLex < "lambda"|"LAMBDA"|{lambda} >; 

VAL : ValLex < "val"|"VAL" >; 

FIX : FixLex < "fix" >; 


103 





LET 

LETVAR 

LETARR 

IN 

NIL 

IF 

WHILE 

UNIT 

THEN 

ELSE 

DO 

OD 

FI 

BEGIN 

END 

TRUE 

FALSE 

ASSIGN 

LOGICALAND 

LOGICALOR 

NOTEQUAL 

LESSEQUAL 

GREATEREQUAL 

INTEGER 

FLOAT 

ID 

PTRADD 


LetLex < "let" >; 

LetVarLex < "letvar" >; 

LetArrLex < "letarr" >; 

InLex < "in"I"IN" >; 

NilLex < "nil"r'[]" >; 

IfLex < "if"|"IF" >; 

WhileLex < "while"|"WHILE" >; 

UnitLex < "unit" >; 

ThenLex < "then"I"THEN" >; 

ElseLex < "else"|"ELSE" >; 

DoLex < "do"I"DO" >; 

OdLex < "od"|"0D" >; 

FiLex < "fi"|"FI" >; 

BeginLex < "begin"I"BEGIN" >; 

EndLex < "end"I"END" >; 

TrueLex < "true"I"TRUE" >; 

FalseLex < "false"I"FALSE" >; 

AssignLex < ";=" >; 

LogicalAnd < "&&" >; 

LogicalOr < "II" >; 

NotEqualLex < "<>"Kne} >; 

LessEqualLex < "<="Kle3- >; 

GreaterEqualLex < ">="Kge} >; 

IntegerLex < \-?[0-9]+ >; 

FloatLex <[0-9]*(\.[0-9]*)([dDeE][-+]?[0-9]+)?> 

IdLex < [A-Za-z][0-9A-Za-z_$]*[']*![?] >; 

PtrAddLex < {oplus} >; 


/* Token precedences for concrete input syntax - */ 

left LOGICALOR; 
left LOGICALAND; 
nonassoc NOTEQUAL; 

nonassoc LESSEQUAL, GREATEREQUAL; 

left PTRADD, ’+’, ; 

left V'; 

right 

nonassoc ID, VAL, FIX, IN, NIL, TRUE, FALSE, FLOAT, INTEGER, LET, 
LETVAR,LETARR, IF, WHILE, UNIT, THEN, ELSE, DO, OD, FI, 
BEGIN, END, ASSIGN, LAMBDA, EXP_PLACEHOLDER ; 


104 





/* style declarations - 

style NORMAL, KEYWORD, PLACEHOLDER, PUNCTUATION, OPERATOR; 


*/ 


/♦***>|c******=)t*****************,(c****,|t:(c*****:(c:(c ,)(****:); ,(c:4c***=|t=f:************ 

* File Name : newsymi.c ♦ 

* Purpose : New type variable generator. * 

/* $Revision: 1.2 $ 

* $Date: 1993/09/02 21:21:12 $ 

* $Author: volpano $ 

* $Log: newsymi.c,V $ 

* Revision 1.2 1993/09/02 21:21:12 volpano 

* Removed T in sprintf. 

* 

*f 

I* 

* Copyright (c) 1989, an unpublished work by GrammaTech, Inc. 

* ALL RIGHTS RESERVED 

* 

* This software is furnished under a license and may be used and 

* copied only in accordance with the terms of such license and the 

* inclusion of the above copyright notice. This software or any 

* other copies thereof may not be provided or otherwise made 

* available to any other person. Title to and ownership of the 

* software is retained by GrammaTech, Inc. 

*/ 

#include "strO.exp.h" 

#include "structures_exp.h" 

#include "types_exp.h" 

/* 

* newsymi 

* 

* Generate new unique symbol. . 

♦ 

* WARNING: In general, this is not a good technique, because 

* gratuitous new symbols will cause AFFECTED to be too large. 

*/ 


105 



FOREIGN newsymiO 

{ 

static int i; 
static char buff[10]; 

sprintf (buff, "*y,d", i++) ; 
return(Str(str_to_strO(buff))); 

} 


/***5|C************j(C**!|C*****!)t***********S|t ******♦**♦*♦♦♦♦♦*♦*♦♦*****♦*** 

* File Name : pair.ssl * 

* Purpose : Defitions for pair. Pair is the stdout of the * 

* interpreter. We output the result produced by a * 

* program through pair construct. One might consider * 

* using list construct for this purpose. But a list * 

* requires the elements have the same which is a severe * 

* restriction. Notice that we define only the required * 

* constructor and do not define first and second * 

* operations since pair is not in Poly C calculus they * 

* are not needed. * 

*******=i<********************:)=****************************>i'**********/ 

/* Abstract syntcix- */ 

exp : Pair(exp exp) 

!* Minimal parenthesization - */ 

exp : Pair { 

exp$2.precedence = 0; 
exp$3.precedence =0; 

} 

/* Unparsing-*/ 

exp : Pair [ “ : := "‘/.S(PUNCTUATION: C/S)" 0 

"‘/.S (PUNCTUATION://.S) '/.o" @ "’/.S (PUNCTUATION: )%S) " ] 

J 

/* Template commands-*/ 

transform exp 


106 







on "( , )" <exp> : Pair(<exp>,<exp>) 


/* Concrete input syntax - */ 

Exp ::= ('(' Exp Exp ’)’) {$$.abs = Pair(Exp$2.abs, Exp$3.abs);} 


/!(e* + s|t*:(:!(!*****=)c**5(c***********=l=it=s(t>t:*=|t=(t=|c=t!*s(:***5|t*5)e*****>|t**5(:*:(c****!f;j(=******s|t 

* File Najne : pair_infer. ssl * 

* Purpose : Type inference for pair. * 

***!)c******* + *s|£****s|<s|t*+*********!|t******!f:*********=|t:(!*!(: ********* ******* / 

exp : Pair { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$3.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 

exp$3.typeEnv = ApplySubstToTypeEnv(exp$2.S, exp$l.typeEnv); 
exp$3.s = exp$2.S; 

exp$l.partial = exp$2.partial || exp$3.partial; 
exp$l.S = exp$3.S; 

exp$l.typeAssignment = PairType(exp$2.typeAssignment, 

exp$3.typeAssignment); 

exp$3.top = false; 
exp$2.top = false; 
exp$3.encl = exp$l.encl; 
exp$2.encl = exp$l.encl; 
exp$3.sv = exp$l.sv; 
exp$2.sv = exp$l.sv; 

} 


/******************************************************************** 

* File Name : real.ssl * 

* Purpose : Definitions for real numbers. * 

****************************************jH**5(t*s|c:j;:(c*:(:***j|c:)c:(:;4.sC*3).*5(:^^^^^^/ 

/* Abstract syntax-*/ 


107 




exp : RealOp(REAL) [ ^ ::= ^ ] 


/* Concrete input syntax - */ 

Exp ::= (FLOAT) { Exp$l.abs = RealOp(STRtoREAL(FLOAT)); } 

3 


/****s|c*:(!*:(t****!|!**********************=t<*****************=(!************=t: 

♦ File Name : real_infer.ssl * 

* Purpose : Type inference for real numbers. * 

********!tc:(:*******5|c********************st:*****=('***********************/ 

exp : RealOp { 

exp.typeAssignment = RealType; 

exp.S = exp.s; 

exp.partial = false; 

} 


Z******!)!*****:)!******************************************************* 

* File Name : while.ssl * 

* Purpose : Definitions for while loop. * 

♦**♦**♦*♦*♦♦♦♦*♦♦♦**********♦♦***********************♦**************/ 

/* Abstract syntaix-*/ 

exp : While(exp exp) ; 

/* Minimal parenthesization - */ 

exp : While { 

exp$2.precedence = 0; 
exp$3.precedence = 0; 

} 


/* Unparsing-*/ 

exp : While [“ ; := "'/f/.S(KEYWORD:while%S) " ® " ‘/.S(KEYWORD:do%S)\n" 

@ "‘/.b‘/.ny,S(KEYWORD: od'/.S) "] 


/♦ Template commands - */ 

transform exp 


108 







on "while" e : While(<exp>, e) 


/* Concrete input synteix-*/ 

Exp ::= (WHILE Exp DO Exp OD) 

{ Exp$l.abs = While(Exp$2.abs, Exp$3.abs); } 


/ !|t***=(=******************:(cj|t**=l=************s|e**!(:***!t:*5(c****3)c:t::(c***%s|e*3(c*:)c*^ 

* File Name : while_infer.ssl * 

* Purpose : Type inference for while loop. * 

***5f:*:4£5|c5*c:>lc:>Jc3|«:f:5f::tJ**************************** + *******:4:**** ****** *******/ 

/* type inference */ 
exp : While { 

exp$2.typeEnv = exp$l.typeEnv; 
exp$2.letvars = exp$l.letvars; 
exp$3.letvars = exp$l.letvars; 
exp$2.s = exp$l.s; 

exp$3.s = Unify(exp$2.typeAssignment, IntType, exp$2.S); 

exp$3.typeEnv = ApplySubstToT]rpeEnv(exp$3.s, exp$l.typeEnv) ; 

exp$l.S = exp$3.S; 

exp$l.typeAssignment = UnitType; 

exp$l.partial = exp$2.partial || exp$3.partial; 

exp$3.encl = exp$l.encl; 

exp$2.encl = exp$l.encl; 

exp$3.sv = exp$l.sv; 

exp$2.sv = exp$l.sv; 

exp$2.top = false; 

exp$3.top = false; 

} 


exp : While 

{ in TypeErrors on (exp$3.s == FailSubst && 

exp$2.S != FailSubst); } 
C TypeErrors ® : "While’/n" ~ •* ] 


109 




no 



LIST OF REFERENCES 


[SmV96a] 

[SmV96b] 

[DaM82] 

[Dam85] 

[Tof90] 

[Hin69] 

[Mil78] 

[Rob65] 

[KR78] 

[Gram] 

[Cor90] 

[Guii92] 

[WrF91] 

[Pfe96] 


GeoiFrey Smith and Dennis Volpano. Towards an ML-style type system 
for C. European Symposium on Programming Systems, Linkoping Sweden, 
LNCS 1058:341-355, 1996. 

Geoffrey Smith and Dennis Volpano. Polymorphic typing of variables and 
references. ACM Trans on Programming Languages and Systems, 18:3, 
May 1996. 

Luis Damas and Robin Milner. Principal type schemes for functional pro¬ 
grams. ACM Symposium on Principles of Programming Languages, pages 
207-212, 1982. 

Luis M. M. Damas. Type Assignment in Programming Languages. Ph.D. 
Thesis, University of Edinburgh, 1985. 

Mads Tofte. Type inference for polymorphic references. Information and 
Computation, 89, 12:1-34, 1990. 

J. Roger Bindley. The principal type-scheme of an object in combinatory 
logic. Transaction of the American Mathematical Society, 146:29-60, 1969. 

Robin Milner. A theory of type polymorphism in programming. Journal 
of Computer Systems and Sciences, 17:348-375, 1978. 

Julia A. Robinson. A machine-oriented logic based on the resolution prici- 
ple. Journal of ACM, 12:23-41, 1965. 

Brian Kernighan and Dennis Ritchie. The C Programming Language. 
Prentice-Hall, 1978. 

GrammaTech Inc. The Synthesizer Generator Reference Manual. Gram- 
maTech, Inc., One Hopkins Place, Ithaca, NY. (Fourth Edition), 1993. 

Cormen et.al. The Algorithms. Prentice-Hall, 1990. 

Carl A. Gunter. Semantics of Programming Languages: Structures and 
Techniques. MIT Press, 1992. 

Andrew Wright and Matthias Felleisen. A syntactic approach to type 
soundness. Information and Computation, 115:38-94, 1994. 

Frank Pfenning. The practice of logical frameworks. Trees in Algebra and 
Programming, Linkoping Sweden, LNCS 1059:119-134, 1996. 


Ill 



[Ohor95] 


Atsushi Ohori. A polymorphic record calculus and its compilation. ACM 
Transaction on Programming Languages and Systems, 17:844~^^^i 1995. 


112 



INITIAL DISTRIBUTION LIST 


1. Defense Technical Infornaation Center 
8725 John J. Kingman Rd., STE 0944 
Ft. Belvoir, VA 22060-6218 

2. Dudley Knox Library 
Naval Postgraduate School 
411 Dyer Rd. 

Monterey, CA 93943-5101 

3. Chairman, Code CS/LT 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5118 

4. Dennis Volpano, Code CS/VO 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5118 

5. Geoffrey Smith, 

School of Computer Science 
Florida Int’l University 
University Park 
Miami, Florida 33199 

6. Craig Rasmussen, Code MA/RA 
Mathematics Department 
Naval Postgraduate School 
Monterey, CA 93943-5101 

7. Mustafa Ozgen 

Gazi Mahallesi Celal Bayar Cad. Ogretmenler Apt. 
No: 14 33960-Silifke ICEL/TURKEY 

8. Valdis Berzins, Code CS/BE 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5118 




