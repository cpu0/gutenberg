NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



THESIS 


A SIMPLE SOFTWARE AGENTS FRAMEWORK FOR 

BUILDING DISTRIBUTED APPLICATIONS 

by 


Boon Kwang, Kin 


March 2001 


Thesis Advisor: 

Valdis Berzins 

Co-Advisor: 

Jun Ge 


Approved for public release; distribution is unlimited. 


20010612 099 




REPORT DOCUMENTATION PAGE 


Form Approved OMB No. 0704-0188 


Public reporting burden for this collection of information is estimated to average 1 hour per response, including 
the time for reviewing instruction, searching existing data sources, gathering and maintaining the data needed, and 
completing and reviewing the collection of information. Send comments regarding this burden estimate or any 
other aspect of this collection of information, including suggestions for reducing this burden, to Washington 
headquarters Services, Directorate for Information Operations and Reports, 1215 Jefferson Davis Highway, Suite 
1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project 
(0704-0188) Washington DC 20503._ _ 


1. AGENCY USE ONLY (Leave blank) I 2. REPORT DATE I 3 . REPORT TYPE AND DATES COVERED 


March 2001 


Master’s Thesis 


5. FUNDING NUMBERS 


4. TITLE AND SUBTITLE: Title (Mix case letters) 

A Simple Software Agents Framework for Building Distributed Applications_. 


6. AUTHOR(S) Kin Boon Kwan 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESSES) 

Naval Postgraduate School 

Monterey, CA 93943-5000__ 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 10. SPONSORING / MONITORING 

N/A AGENCY REPORT NUMBER 


. PERFORMING ORGANIZATION 
REPORT NUMBER 


11. SUPPLEMENTARY NOTES The views expressed in this thesis are those of the author and do not reflect the official 
policy or position of the Department of Defense or the U.S. Government. _ 


12a. DISTRIBUTION / AVAILABILITY STATEMENT 12b. DISTRIBUTION CODE 

Approved for public release; distribution is unlimited.__ 


13. ABSTRACT (maximum 200 words) 

The development of distributed systems needs to consider multiple factors such as performance, 
scalability, resource sharing, and fault tolerance. This thesis proposes a simple agent-based framework to address 
these concerns when building distributed applications. Agents act as interfaces among processes to interact and to 
cooperate in a distributed environment. These agents encapsulate the implementation details and make the network 
transparent to running processes. The proposed framework is built on JINI infrastructure. It uses Linda 
TupleSpace model, a shared network-accessible repository, for different processes to exchange information. 
Processes are loosely coupled. Under the proposed model, the correspondent language wrappers such as Java, 
Ada, C++, C and Visual Basic support multiple programming languages. Information exchange among processes 
is not restricted to data only. Executable components, leveraging on Java code’s portability features, can be sent 
over a heterogeneous environment and executed remotely. 

This framework can further address several important issues on formal specifications of the 
communication layer, such as partial failure, synchronization, coordination and heterogeneity, by offering 
properties in our design for operation timeout, and information and service leasing. 

This framework is to be used in the Distributed Computer Aided Prototyping System (DCAPS) to 
provide the inter-process communication layer. It simplifies the tasks of designing, binding and analyzing multiple 
processes of real-time, distributed prototype systems. 

The provided interface library shields the developer from working on the underlying dynamic and 
complex network environment. It supports a wide variety of programming languages and operating platforms. 
Important issues under distributed environment, such as partial failure, synchronization and coordination, have 
been taken into consideration. __ — 


14. SUBJECT TERMS 

ActiveX, Agent, Distributed Systems, Framework, Interoperability, JavaSpace, JINI, 
Software, TupleSpace, Wrapper. 


15. NUMBER OF 
PAGES 


17. SECURITY 
CLASSIFICATION OF 
REPORT 

Unclassified 


NSN 7540-01-280-5500 


18. SECURITY 
CLASSIFICATION OF THIS 
PAGE 

Unclassified _ 


19. SECURITY 
CLASSIFICATION OF 
ABSTRACT 

Unclassified 


16. PRICE CODE 


20. LIMITATION 
OF ABSTRACT 


Standard Form 298 (Rev. 2-89) 
Prescribed by ANSI Std. 239-18 


1 


















THIS PAGE INTENTIONALLY LEFT BLANK l 

i 


11 



Approved for public release; distribution is unlimited. 


A SIMPLE SOFTWARE AGENTS FRAMEWORK FOR BUILDING 
DISTRIBUTED APPLICATIONS 


Boon Kwang, Kin 
Ministry of Defence, Singapore 
B.Eng.(Hons), 

Nanyang Technological University, 1996 

Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF SCIENCE IN COMPUER SCIENCE 


from the 


NAVAL POSTGRADUATE SCHOOL 
March 2001 


Author: 


Approved by: 



Dr. Jun Ge, Co-Advisor 



Department of Computer Science 




THIS PAGE INTENTIONALLY LEF T BLANK 



ABSTRACT 


The development of distributed systems needs to consider multiple factors such as 
performance, scalability, resource sharing, and fault tolerance. This thesis proposes a 
simple agent-based framework to address these concerns when building distributed 
applications. Agents act as interfaces among processes that interact and cooperate in a 
distributed environment. These agents encapsulate the implementation details and make 
the network transparent to running processes. The proposed framework is built on JINI 
infrastructure. It uses Linda TupleSpace model, a shared network-accessible repository, 
for different processes to exchange information. Processes are loosely coupled. They 
discover and linkup with one another by using services residing on JINI infrastructure. 
Under the proposed model, the correspondent language wrappers such as Java, Ada, C++, 
C and Visual Basic support multiple programming languages. Information exchange 
among processes is not restricted to data only. Executable components, leveraging on 
Java code’s portability features, can be sent over a heterogeneous environment and 
executed remotely. 

This framework can further address several important issues on formal 
specifications of the communication layer, such as partial failure, synchronization, 
coordination and heterogeneity, by offering properties in our design for operation 
timeout, and information and service leasing. 

This framework is to be used in the Distributed Computer Aided Prototyping 
System (DCAPS) to provide the inter-process communication layer. It simplifies the 


v 



tasks of designing, binding and analyzing multiple processes of real-time, distributed 
prototype systems. 

The provided interface library shields the developer from working on the 
underlying dynamic and complex network environment. It supports a wide variety of 
programming languages and operating platforms. Important issues under distributed 
environment, such as partial failure, synchronization and coordination, have been taken 


into consideration. 



TABLE OF CONTENTS 


I. INTRODUCTION.1 

II. BACKGROUND.5 

A. BENEFITS OF BUILDING DISTRIBUTED APPLICATIONS.5 

1. Performance.5 

2. Scalability.5 

3. Resource sharing.6 

4. F ault tolerance.6 

B. CHALLENGES OF BUILDING DISTRIBUTED APPLICATIONS.6 

1. Heterogeneity.7 

2. Latency.7 

3. Partial failure.7 

4. Synchronization.8 

5. Coordination.8 

C. MODELS FOR BUILDING DISTRIBUTED SYSTEMS.9 

1. Client/server model.9 

a. Sockets.10 

b. Remote Procedure Call.10 

c. Message Oriented Middleware (MOM).10 

2. Distributed Object Model.11 

a. Distributed Object standards.11 

D. JAVA LANGUAGE FOR DISTRIBUTED PROGRAMMING.12 

E. THE JINI TECHNOLOGIES.13 

F. TUPLE SPACE MODEL. 14 

III. DESIGN..15 

A. OVERVIEW.15 

B. ENTRIES.19 

1. Shared variables..................................................—........................ 19 

2. Ordered structures.20 

3. Unordered structures........................................................................ 21 

C. AGENT SERVICE.22 

D. AGENT OPERATIONS.22 

1. Service registration operations- 23 

2. Entry operations.24 

3. Transaction operations.25 

4. Event Handling..—--26 

5. Code Serialization.....................................................—.................... 28 

E. AGENT ATTRIBUTES.28 

1. Leasing.28 

2. Timeout.30 

F. AGENT WRAPPERS.31 

IV. IMPLEMENTATION.33 

A. ARCHITECTURE.33 

vii 













































B. AGENT SERVICE MODULE.34 

C. SERVICE REGISTRATION MODULE.34 

1. Service Accessor.35 

2. Service Finder.36 

D. EVENT MODULE.36 

1. Space Event Registration.36 

2. Space Event Listener.37 

3. Space Action handier.38 

E. INTERFACE MODULE. 38 

1. Application Interface.39 

a. Agent configuration.39 

b. Entry declaration.40 

c. Transaction handling.41 

2. Entry Handlers.................................................................................. 42 

3. Entries..45 

F. AGENT WRAPPER MODULES_46 

V. RESULTS_49 

A. SERVICE RESPONSE TIME_49 

B. DEVELOPMENT GUIDELINES_51 

C. TESTING JINI/SER VICES_52 

D. AN EXAMPLE: AN ELEVATOR CONTROL SYSTEM_55 

1. Declare and initialize entry.„.60 

2. Read and Write Entry ....._.....___61 

VI. DISCUSSION_63 

A. JAVA PROGRAMMING LANGUAGE_63 

B. JINI TECHNOLOGY_64 

C. FUTURE WORKS_64 

VII. CONCLUSION_67 

LIST OF REFERENCES_69 

APPENDIX A. AGENT API_71 

TUPLESPACE.CORE CLASS AGENT_71 

TUPLESPACE.CORE CLASS SERVICEFINDER_74 

TUPLESPACE.CORE CLASS SERVICEACCESSOR._75 

TUPLESPACE.CORE INTERFACE SPACEEVENTREGISTRATION.... 76 

TUPLESPACE.CORE INTERFACE SPACELISTENER __77 

TUPLESPACE.CORE INTERFACE TSCONSTANTS. 78 

TUPLESPACE.CORE CLASS TSBASE.79 

TUPLESPACE.CORE CLASS TSBOOLEAN. 81 

TUPLESPACE.CORE CLASS TSDOUBLE_ 84 

TUPLESPACE.CORE CLASS TSHASH. 87 

APPENDIX B. JINI/SERVICES SETUP SCRIPT_ 91 

viii 










































APPENDIX C. AGENT TEST BENCH LISTING.95 

A. JAVA VERSION.95 

1. JavaTestBench.java.95 

2. PerformActions.java.109 

B. VISUAL BASIC VERSION.121 

1. VBT estBench.vb.121 

C. C VERSION.127 

1. CtestBench.C.127 

APPENDIX D. AGENT WRAPPER LISTING.137 

1. AGENT.H.137 

2. AGENT.C.141 

APPENDIX E. AGENT API LISTING.169 

A. SERVICE PACKAGE.169 

1. AgentServiceInterface.java.169 

2. AgentService.java.169 

B. CORE PACKAGE.173 

1. Agent.java....................—...........—...................—.......................... 173 

2. ServiceFinder.java.185 

3. ServiceAccessor.java....................................................................... 187 

4. SpaceEventRegistration.java- 189 

5. TSBase.java—...------ ——190 

6. TSConstants.........................................—................................-192 

7. TSDouble.java-199 

8. TSLong.java...............................................................——.*————205 

9. TSHash.java.211 

10. TSQueue.java.220 

11. TSString.java- 226 

C. ENTRIES PACKAGE-232 

1. EntryBoolean.java- 232 

2. EntryBytes.java...-...---...— -- 232 

3. EntryClass.java....................-....-233 

4. EntryDouble.java- 233 

5. EntryFIoatjava.................................—.....................—............... 233 

6. EntryHash.java- 234 

7. Entrylnteger.java.....................—...................................................234 

8. EntryLong.java.235 

9. EntryListItem.java..........................................................................235 

10 EntryListStatus.java- 236 

11 EntryQueueItem.java..........-........-...................... 237 

12 EntryQueueStatus.java...................................................................237 

12 EntryStackItem.java.—-- 239 

14 EntryStackStatus.java.....................................................—........... 239 

15 EntryString.java- 240 

16 SpaceActionHandle.java....................................—........................ 241 

17 SpaceEventListener.java--—..241 

ix 
















































INITIAL DISTRIBUTION LIST 


243 


I 


X 




LIST OF FIGURES 


Figure 1 A distributed application using our agent framework.15 

Figure 2 Share Variables Entries.20 

Figure 3 Ordered Structure Entries.21 

Figure 4 Unordered Structure Entries.22 

Figure 5 Agent Service Registration Process.23 

Figure 6a Entry Read Operation.24 

Figure 6b Entry Take Operation.24 

Figure 6c Entry Write Operation.25 

Figure 6d Entry Update Operation.25 

Figure 6e Entry Notify Operation.25 

Figure 7 Entry Operations with Transaction.26 

Figure 8 Event Handling.27 

Figure 9 Code Serialization.28 

Figure 10 Renewing Service Lease.29 

Figure 11 Entry Lease Expired.29 

Figure 12 Transaction Lease Expired.30 

Figure 13 Service Timeout.31 

Figure 14 Entry Read/Take timeout.31 

Figure 15 Agent Wrappers.32 

Figure 16 Agent Architecture.33 

Figure 17 Service Registration Module.35 

Figure 18 Event Module.36 

Figure 19 Agent Interface Module.39 

Figure 20 Entry Handlers.43 

Figure 21 Entries.46 

Figure 22 Agent Wrapper Module.46 

Figure 23 Chart 1 JINI/JavaSpace Response Time.50 

Figure 24 Chart 2 JINI/JavaSpace Response Time.50 

Figure 25a Agent Test Bench (Java Language version).53 

Figure 25b Agent Test Bench (Visual Basic Language version).54 

Figure 25c Agent Test Bench (C Language version).54 

Figure 26 ECS State Chart.57 

Figure 27 ECS processes.58 

Figure 28A Elevator A & B Control Panel.59 

Figure 28B Floor Control Panel.59 


LIST OF TABLES 

Table 1 ECS Requirements.56 

Table 2 ECS Shared Entries.59 


xi 








































THIS PAGE INTENTIONALLY LEFT BLANK 



ACKNOWLEDGMENTS 


My sincerest appreciation and thanks to my thesis advisor. Professor Valdis 
Berzins. His knowledge of this field is extraordinary and he provided me with many 
insight ideas, assistance, and support. 

I would also like to give special thanks to Doctor Jun Ge for enlightening me and 
working diligent hours to help me in the thesis. 


- Boon Kwang Kin 


xiii 



THIS PAGE INTENTIONALLY LEFT BLANK 



I. INTRODUCTION 

In the past few years, the computing landscape has changed dramatically. More 
and more devices, such as hand-phones, Personal Device Assistances (PDAs) and 
Internet terminals, etc., have been enhanced with network capabilities to leverage on the 
benefits that new communication technologies have brought to us. Industrial companies 
and military services often operate and communicate via the Internet in a broad area to 
streamline operations and cut down on expenditure. Devices and software components 
have become more tightly coupled, cooperating together in a distributed system to 
accomplish a common goal. A distributed computer system is, therefore, defined to be a 
system of multiple autonomous processing elements, cooperating for a common purpose 
or to achieve a common goal ([Robert98]). Hence, challenges and concerns for 
constructing a distributed computer system have become a growing field that is being 
intensively studied worldwide in recent years. 

Distributed systems offer more benefits than standalone systems do. The 
computational ability of a standalone system is usually limited by the available power 
and resources in a single computer. Distributed applications can grow more easily to 
meet new demands by introducing more CPUs and memory. Expensive resources such 
as supercomputers and color printers can be shared and utilized by many different users. 
Distributed systems could reach a better fault tolerance and availability because both 
problems have to be carefully taken care of from the beginning of system design. Hence, 
unlike a standalone program, which could be totally terminated if any component in its 
system fails, a distributed application can still continue to operate even if some processes 


1 


get disrupted because of system failure. Distributed systems can also reuse a lot of 
legacy software components through re-engineering. 

Rewriting legacy software to run in a distributed environment tends to be 
prohibitively expensive and complexed. Many legacy software systems are expensive 
investments that have been developed over many years. Replacing them with new 
designs or implementations is usually not easy to justify in terms of costs and resource 
allocation. Although the only way to keep such legacy software useful is to incorporate 
them into a wider cooperating community in which they can be exploited by other pieces 
of software, in practice, this could be very complex in terms of design. 

Despite the benefits, building distributed applications is difficult. There are many 
different requirements and specifications for distributed systems. Developers have to 
face many problems that do not arise when building standalone applications. Besides 
some common problems like heterogeneity, latency, partial failure and synchronization, 
developers have to consider issues about how to make legacy software components “co¬ 
exist” with each other and how to “glue” multiple processes together running 
independently on different machines. 

Today, the technique to “glue” multiple processes running in a heterogeneous 
environment ranges from low-level sockets and messaging techniques to more 
sophisticated technology Object Resource Broker (ORB) [ORB91], such as CORBA and 
DCOM [DCOM96]. Many of these techniques require developers either to perform 
significant low-level coding work in constructing the communication mechanism or to 


2 


have a good knowledge of the interface details before designing. Hence, “gluing” pieces 
of processes is still a difficult task and requires skilful designers with expertise. 

Wrapper and Glue technology was proposed for constructing distributed systems. 
Wrapping is an approach to protect legacy software systems and commercial off-the-shelf 
(COTS) software products that requires no modification of those products. A wrapper 
consists of two parts, an adapter that provides some additional functionalities for an 
application program at key external interfaces, and an encapsulation mechanism that 
binds the adapter to the application and protects the combined components. Wrapping 
should require no changes to the existing application program. [MEESON97] Candidate 
mechanisms for implementation via wrappers: authentication, logging and auditing, 
constraint checking, encryption, access control, fault detection and recovery, redundancy. 
The glue plays another role by providing a uniformed, supporting layer for individual 
wrapped components based on their specific hardware and software configurations so 
that distributed systems are built upon the glue structure through which components 
communicate to each other. The developer does not have to go down to low-level 
communication details when developing the overall paradigm. 

This thesis proposes a simple framework using agents to act as interfaces among 

various processes that interact and cooperate in a distributed heterogeneous environment. 

It shields developers from the underlying dynamic and complex network environment, 

and offers developers a simple set of Application Program Interfaces (API) to build 

distributed applications. Developers, therefore, do not need to worry about their 

operating platforms and programming languages. It also provides an easier way for 

legacy software to share information with other applications in a heterogeneous 

3 




environment. The glue structure provided in this thesis not only gives APIs to realize the 
communication function across the platform, but also explores the real-time constraints 
and monitors for distributed system communications. 

This thesis is structured as follows. Chapter II introduces the benefits and 
challenges of distributed computing in detail and presents our survey of current 
technologies that are being used for constructing distributed applications. Chapter HI 
gives an overview of the proposed agent framework. The features and underlying design 
details of the agent framework are presented with respect to the requirements of real-time 
distributed systems. Chapter IV discusses the agent architecture and its implementation. 
In Chapter V, a test-bed application implemented using various language wrappers is 
presented to demonstrate the agent’s features. A more complicated application of an 
elevator control system has been constructed on the proposed agent structure. Future 
research directions are discussed in Chapter VI. 


4 




II. BACKGROUND 

This session discusses the benefits and challenges of building distributed 
applications. It also presents a list of technologies that are useful for designing and 
creating distributed systems. 

A. BENEFITS OF BUILDING DISTRIBUTED APPLICATIONS 

Distributed applications offer more benefits than standalone applications do in 
terms of performance, scalability, resource sharing, fault tolerance and availability. 

1. Performance 

Distributed applications can achieve better performance than standalone 
applications. Unlike standalone applications, which rely heavily on newer hardware to 
improve performance, distributed applications utilize the combination of systems 
connected together by a network to boost performance. This performance gain is often 
achieved through splitting problems into smaller pieces and then delivering them across 
the network, where they can be executed in parallel. Nevertheless, this category of 
problems is restricted to tasks that have a low communication-to-computation ratio, i.e. 
processes that spend much less time in communicating than in computing. Otherwise, 
any performance gain would be overwhelmed by the network latency. 

2. Scalability 

Distributed applications can scale more easily. Unlike standalone applications, 
where their scalabilities are limited by how much resource each system has, distributed 


5 



applications can grow without such constraint and new resources can be added to match 
the problem’s difficulties. 

3. Resource sharing 

Distributed applications allow organizations to fully utilize their available 
physical resources. For instance, expensive resources like supercomputers and color 
printers are difficult to redistribute, allowing each end user a local access might not be 
feasible. However, by making them as services more users can remotely access them and 
resource can be better utilized. 

4. Fault tolerance 

Non-distributed systems typically have little tolerance for failure. If a system that 
hosts standalone applications fails, these applications will terminate and remain 
unavailable until they are restarted. On the contrary, distributed applications can tolerate 
a limited amount of failure since they are built on multiple, independent processes that 
reside on many systems — if some processes fail, others can continue. 

B. CHALLENGES OF BUILDING DISTRIBUTED APPLICATIONS 

Despite their benefits, it is difficult to build distributed applications. The 
distributed environment introduces many problems that have not been taken care of in a 
standalone application’s development. These problems include heterogeneity, latency, 
partial failure, synchronization and coordination. 


6 



1. Heterogeneity 

Typically, a distributed application may have to reside on different platforms and 
use multiple technologies from various vendors to meet all requirements. Mixing them 
together usually creates new dimensions of difficulties in terms of integration and system 
management. Integrating multiple technologies can often result in incompatibilities that 
are beyond the control of designers. 

2. Latency 

Communication latency among processes over network is longer and less 
predictable than in a local system. The time lag is typically in several orders of magnitude 
compared to the communication among processes in the same system or to the speed of 
processors. Unlike a local system where user has better control over how resources are 
utilized, the user in a distributed system usually has no control on some resources, such 
as network usages. Hence, predicting the communication latency among processes that 
belong to a distributed application is much more complex and difficult. 

3. Partial failure 

Partial failure is the greatest challenge for designers building distributed systems. 
Unlike a standalone system, which is subjected to total failure, a distributed system is 
subjected to partial failure. If any of the components in the standalone system fails, the 
entire computation terminates. This type of failure is easy to detect and correct. 
Correction can be done simply by rebooting the system and follow by restarting the 
application. On the other hand, partial failure, if a component in the distributed system 
fails, some other processes of a distributed application can continues to run; very often 


7 



this is difficult to detect and control because resources like network are also being shared 
by many other applications. 

4. Synchronization 

In a distributed application, processes need to synchronize with one another to 
succeed a common task. For example, a distributed application often needs to mediate 
access to a limited set of shared resources, guarantee fair access to those resources, or 
prevent processes from terminating as they wait for resources that may never become 
available. Synchronization is not a problem for standalone applications because most of 
them are executed in sequence, and has a central resource manager, the operating system, 
which mediates access to critical resources. Designers building distributed applications 
have to build their own synchronization mechanism, which is difficult because processes 
are run independently on many machines that might have different architectures — if not 
done properly, it can easily result in a deadlock situation. 

5. Coordination 

Coordinating distributed processes can be difficult. An application that runs on a 
single machine has an operating system to act as a centralized manager to synchronize 
multiple threads. But in a network environment, a single point of control does not 
necessarily exist. Processes are executed on different machines and at their own pace. 
Unless we build a centralized controller to manage those processes, which might 
introduce an unwelcome bottleneck to the environment, we must build a distributed 
means of managing their interactions. 


8 



c. 


MODELS FOR BUILDING DISTRIBUTED SYSTEMS 


Distributed systems can be implemented using these models; namely, client/server 
model and distributed object model. 

1. Client/server model 

The Client/server model contains a set of server processes and client processes. A 
server process act as a resource manger for a collection of resources of a particular type 
such as database server, file server, print server and etc. A client process communicates 
with the server for the purpose of exchanging or retrieving information. Communication 
between the client and server can be achieved through sets of protocols agreed by both 
parties. 

The major drawback of the client/server model is that the control of individual 
resource is centralized at the server and this could create a potential bottleneck and a 
single point of failure. Although many implementations have tried to overcome this 
drawback by replicating storage data and functions across multiple servers, thus making 
duplicate server to either act as backup or serve different cluster of clients, this has 
introduced new problems in terms of maintaining data consistency in the servers. 

Despite the drawback, centralizing of resources at a few locations greatly 
simplifies the management of resources. Software update and maintenance are is much 
simple; administrators just need to concentrate on a few locations. 

The client/server model can be implemented in various ways. Typically, it is done 
using low-level sockets, remote procedure calls or high-level message oriented 
middleware such as message queues. 


9 



a. 


Sockets 


Sockets are low-level inter-process communication similar to file 
input/output. It requires developers to implement their own protocol through which the 
client and server will use to communicate with each other. 

b. Remote Procedure Call 

A Remote Procedure Call (RPC) is a high-level communication paradigm 
that allows network applications to be developed by way of specialized procedure calls. 
Client invokes a procedure call that sends requests to a remote server. When these 
requests arrive, the server calls a dispatch routine, executes the requested procedures, and 
returns the results to the client. Program control is returned to the client immediately after 
the RPC is completed. 

The major limitation of RPC is that it only offers synchronous data 
exchange between the calling program and called procedure. Developers must employ 
operating system features such as threads or subtasks to force the RPC to process in an 
asynchronous manner. Using RPCs to integrate applications also limits portability 
because the application code will become very dependent on the operating system. 

c. Message Oriented Middleware (MOM) 

MOM is primarily middleware that facilitates communication between 
distributed applications. While MOM supports both synchronous and asynchronous 
messaging, it is most closely identified with asynchronous messaging using queuing. 
MOM sends messages from one application to another using a queue as an interim step. 
Client messages are sent to a queue and remain there until they are retrieved by the server 
application. 


10 



The advantage of this system is that the server application does not need to 
be available when the message is sent. Instead, the server can retrieve the message at any 
time. In addition, since messages can be retrieved off the queue in any order, MOM can 
also facilitate retrieval of messages using priority or load-balancing schemes. MOM can 
also provide a level of fault-tolerance using persistent queues that allow messages to be 
recovered when the system fails. 

2. Distributed Object Model 

A distributed object-based system is a collection of objects that isolates requestors 
of services from providers of services (servers) by a well-defined encapsulating interface. 
Clients are isolated from the implementation of services as data representations and 
executable code. 

In a distributed object model, a client sends a message to an object that in tum 
interprets the message to decide what service to perform. This service could be performed 
either through the object or a broker. 

a. Distributed Object standards 

Distributed object systems such as CORBA, DCOM, and Java RMI 
provide the infrastructure for supporting remote object activation and remote method 
invocation in a client-transparent way. A client program obtains a pointer (or a reference) 
from a remote object, and invokes methods through that pointer as if the object resides in 
the client's own address space. The infrastructure takes care of all low-level issues such 
as packing the data in a standard format for heterogeneous environments (i.e., marshaling 


11 





and unmarshaling), maintaining the communication endpoints for message sending and 
receiving, and dispatching each method invocation to the target object. 

Among all different vendors for distributed object systems, CORBA is the 
most widely supported standard. Its main advantages are platform independence and open 
industry standard that contains over 750 industry members. 


D. JAVA LANGUAGE FOR DISTRIBUTED PROGRAMMING 

The major advantages of using Java programming language to write distributed 
applications are their platform independent and networking support. Unlike applications 
written in platform dependent programming languages such as C++ and Ada languages, 
which must be compiled to their native platforms in order to run; Java applications need 
not be compiled and they can run on varieties of system architectures and software 
platforms as long as they have JVMs (Java virtual machines) [JVM96] installed to 
interpret the byte code during runtime. Java language is also the first general 
programming language that is designed specifically to work over the network, in 
particular the Internet. Java extensive library of routines for coping with TCP/IP 
protocols like HTTP and FTP make creating network connections much easier than in C 
or C++. Java applications can open and access objects across the net via URLs with the 
same ease that programmers are used to when accessing a local file system. 


12 



E. THE JINI TECHNOLOGIES 

JINI [KEI99] [JOY99] is one of a large number of distributed systems 
architectures including industry-pervasive system such as CORBA and DCOM. It is 
distinguished by being based on Java programming language and deriving many features 
that leverage on capabilities that this language provides, like object-oriented 
programming, code portability, RMI (Remote Method Invocation) [RMI00], network 
support and security. 

Some of the features Jini Technologies offers are 

■/ Enable users to share services and resources over a network 

■/ Provide users easy access to resources anywhere on the network while 
allowing the network location of the user to change 

■S Simplify the task of building, maintaining, and altering a network of devices, 
software, and users 

Jini technology consists of a programming model and a runtime infrastructure. 
The programming model helps designers build reliable distributed systems as a federation 
of services and client programs. The runtime infrastructure resides on the network and 
provides mechanisms for adding, subtracting, locating, and accessing services as the 
system is used. Services use the runtime infrastructure to make themselves available 
when they join the network. A client uses the runtime infrastructure to locate and contact 
desired services. Once the services have been contacted, the client can use the 
programming model to enlist the help of the services in achieving the client's goals. 


13 


F. TUPLE SPACE MODEL 

Tuple Space model was first conceived in the mid-1980 at Yale University by 
professor David Gelemter under a project called Linda. Tuples are typed data structures. 
Collections of tuple exist in a shared repository called a tuple space. Coordination is 
achieved through communication taking place in a tuple space globally shared among 
several processes. Each process can access the tuple space by inserting, reading or 
withdrawing tuples. 

In this model, the programmer never has to be concerned with or program explicit 
message passing constructs and never has to manage the relatively rigid, point-to-point 
process topology induced by message passing. In contrast, coordination in Linda is 
uncoupled and anonymous. The first means that the acts of sending (producing) and 
receiving (consuming) data are independent (akin to buffered message passing). The 
second means that process identities are unimportant and, in particular, there is no need to 
"hard wire" them into the code. 

There are a few similar implementations like JINI/JavaSpaces, IBM’s Tspaces 
[TSPACES00] and Cloudscape’s Java database [CLOUDOO], which are built based on 
TupleSpace model. All of them offer a simple mechanism for dynamic communication, 
coordination, and sharing of objects between clients and servers. 


14 


III. DESIGN 

This session gives an overview of the agent framework and describes its features 


and underlying design. 


A. OVERVIEW 



Figure 1 A distributed application using our agent framework 


This thesis proposes a simple framework using agents to act as interfaces among 
processes interacting and cooperating in a distributed environment. These agents 
encapsulate the implementation details and make the network transparent to processes. 
Hence, by using these agents, developers can reduce significantly their efforts in 
implementing the process interfaces and concentrate on building the logic portions of a 
distributed application. 


15 









Our framework is built on JINI infrastructure and uses JINI network technology 
to simplify the task of building and maintaining reliable distributed systems. This 
technology consists of a well-defined programming model, which allows us to create our 
own services and leverage on services that have already been built to support JINI 
infrastructure. Using this programming model, we do not have to worry about the low- 
level communication protocol. Client processes can dynamically locate and access 
services held in the JINI community using its runtime infrastructure, even if they do not 
know their host URL addresses. 

Our framework uses Linda [GEL85] TupleSpace model type of communication 
mechanism for inter-process communications. Processes are loosely coupled, rather than 
through direct communication, they interact in a globally shared space - repository 
service provided by JavaSpace Service [JS99], through share variables - entries. Being 
loosely coupled, processes need not be physically connected all the time and do not have 
to worry about the point-to-point topology induced by message passing. Several 
processes residing on same machine or on different machines can access the repository 
simultaneously. They interact among themselves by means of reading, writing or 
consuming entries stored in the repository service. 

Repository service is a shared, network-accessible depot for entries storage. It 
behaves like a lightweight relational database, where agents acting on behalf of their 
processes can store, retrieve and query entries stored in it. Unlike database where users 
construct Structured Query Language (SQL) statements to query records, agents use pre- 


16 



constructed templates defined in our framework to match entries stored in the repository 
and only entries that match exactly the data types and fields defined in the template are 
returned by the repository' service. 

Entries are a collection of values or objects placed in repository service by 
coordinating processes for information sharing. Before a process can start operating on an 
entry, it first has to declare the entry, which is identified by a unique name and an entry 
type, with its agent; just like variables declaration in programming techniques. Entry type 
varies from simple primitive type like integer, float, double, etc to more complex type 
like queue, stack, list, etc where entries are managed as group. Each entry, upon 
declaration, is assigned an entry handler to serve operations for accessing the repository 
service. 

Entry handler is responsible for carrying out operations pertaining to a declared 
entry. There are many kinds of entry handlers. Each one is associated to an entry type and 
has methods designed specifically to handle a particular entry type. Methods that are 
common in all handlers are: read, write, take, update and notify. Processes mainly use 
them for manipulating entries stored in the repository service. Every entry handler 
consists of a set of attributes that determine how it carries out its operations. Many of 
them can be overwritten after entry declaration by processes to meet different application 
needs. For instance, an entry-leasing attribute, which determines the validity of the entry 
process stored in the repository, can be used in a real-time application to specify the 
deadline of information to prevent recipients from accessing obsolete information, which 
sometimes can be more damaging than not have any of them. 


17 



Establishing a session with agent service is done in two simple steps: firstly, 
locate the service and then perform a login registration. If the process knows the network 
location where agent service is held, the process can bypass the search procedures. 
Searching for services in JINI network is achieved using JDNTs discovery protocol - 
agent inserts a package into the network and wait for lookup services to respond. A 
lookup service provides the facility for services to publish their services. Upon receiving 
the request package, lookup services respond by returning a list of service items. Each 
item describes its service properties and functions. The agent then searches through the 
list, comparing their service attributes with those of the agent service. After it has found a 
matching service, it will proceed to establish a connection follow by a service registration 
providing a valid login ID and a password to the agent service. 

Below' is a summary of features the framework provides, 

^ A simple and yet comprehensive interface that allow multiple processes to get 
connected and interact with one another in a distributed environment. 

^ Processes can be implemented in Java, Visual Basic, C/C++, or Ada; two agent 
wrappers are included, ActiveX wrapper and a C library wrapper. 

^ Processes are loosely coupled; they need not be physically connected all the time 
and do not have to worry about the point-to-point topology induced by message 
passing. 


18 



•/ Several processes residing on the same machine or the different machines can 
access the repository service and retrieve data simultaneously in a reliable 
manner. 

S Agent Service provides authentication and controls mechanism to manage 
processes using its services. 

•/ Avoid the needs to create and manage remote/virtual classes (e.g. stubs and 
skeletons in RMI and CORBA implementations) 

•/ Provide callback mechanisms that invoke user-defined methods when conditions 
are met. 

■S Support transaction, which enforce consistency over a set of entry operations 
■/ Support leasing, which prevent resources from growing out of bound. 

B. ENTRIES 

Entries are a collection of values or objects placed in the repository service by 
coordinating agents for information sharing. Every entry has a unique entry name and an 
entry type. Unique name differentiates an entry from those stored in the repository and 
entry type determines the contents placed inside the entry. We have grouped entries into 
three categories: shared variables, ordered structures and unordered structures. 

1. Shared variables 

Like variables in programming techniques, they provide storage for some values 
or objects; however, shared variables allow multiple processes operating in the virtual 


19 



space to access and modify them simultaneously in an atomic manner. Atomic operation 
prevents these entries from corruption caused by race conditions. Shared variable type 
can either be defined as Integer, Boolean, Float, Long, Double, String or User-defined. 
User-defined as the name implies allow developers to define their own data structure. 



Figure 2 Share Variables Entries 

2. Ordered structures 

Ordered structure entries are like containers, collecting of similar values or 
objects, in object-oriented languages, where process can iterate through them. There are 
three types of ordered structures defined, i.e., queue, stack, and list; Queue type operates 
in First In First Out (FIFO); a take operation consumes the first entry' in its group and a 
put operation deposits an entry to the last entry in its group. Stack type is similar to queue 


20 

















type, except that the take operation consumes the most recent entry deposited. List type 
allows processes to search and iterate through the list of entries by using indexes. 



; <•«* 


\ 

. Sm 

m 

Process 


< 



\_ 


k 


Figure 3 Ordered Structure Entries 


3. Unordered structures 

An unordered structure behaves like a pack of entries with the same entry ID but 
without any internal order. Unlike ordered structures where they are read or written in a 
predetermined order, unordered structures are arbitrary read or written into the repository. 
A typical example is task-result bags; a process places many small pieces of 
computational tasks in the task bag, waits for other processes to pick them up for 
computation and retrieves the results from the result bag placed after they have been 
computed. 


21 













Figure 4 Unordered Structure Entries 


C. AGENT SERVICE 

Agent service provides authentication and controls mechanism for processes 
running in the network environment. It forces every process using its service to go 
through an authentication process, verifying their identifications against those held inside 
its service database. Identifications can be added or removed from its database to control 
process accesses to restricted resources. It includes a control mechanism that helps itself 
recover resources held by non-existing processes. This mechanism will periodically 
check the status of all processes using the agent service. When it discovers a process that 
is no longer existing (leasing expired), it frees up the resources and assigns them to other 
processes. 

D. AGENT OPERATIONS 

Agent interfaces offer processes a simple and yet comprehensive set of operations 
to interact with one another in a distributed environment, from establishing of 
connections to handling of entries. Generally, we have grouped them into 5 types of 







operations: service registration operations, entry operations, transaction operations, 
event-handling operations and advance operations. 

1. Service registration operations 

Service registration operations provide processes the means to discover and 
register with agent service as well as to retrieve the handles of common services. Figure 5 
shows a service registration process. To begin, a process first has to locate a lookup 
service that agent service publishes itself. Lookup service is like a name directory, 
providing facility for services to publish themselves whereby clients can easily locate 
them. If the process knows exactly where the agent service is located, it can proceed 
directly to service registration, otherwise, it has to perform a network search using JINI 
discovery protocol - place a request package onto the network and wait for lookup 
services to response. After registration the process can retrieve the handles of sendees 
needed for inter-process communication such as transaction service, JavaSpace service 
and etc. 



23 








2 . Entry operations 

Entry operations allow processes to manipulate entries store in the repository 
service. There are five kinds of entry operations that the agent interface provides, namely: 
read, write, update, take and notify. A read operation and a take operation, as depicted in 
figure 6a & 6b, allow processes to retrieve a copy of an entry that matches a given 
template stored in the repository. Unlike a read operation, a take operation will remove 
the entry from the repository after retrieving. On the other hand, a write operation places 
a new entry in the repository while an update operation overwrites any existing entries 
having the same entry ID. The Notify operation, shown in figure 6e, allows process to 
monitor for incoming entries to the repository - when a new entry is added and matches 
the entry ID being monitored, process would be notified by an event. 




> 

\ 

Process 

(Q 

a 

,3 


w. 

s 

k 



\ 


\ JavaSpace / 
'X^Service 

Figure 6b Entry Take Operation 


24 












Figure 6c Entry Write Operation 



> 

X 

Process 

to 

© 

5 






Success/Fall f 
Update i 



V 


X 


JavaSpace / 
Service S 


Figure 6d Entry Update Operation 



Every entry operation that process performs is constrained by a set of entry 
attributes that is described in details in session BI-E. For instance, these attributes limit 
how long a read operation should wait for an entry if it is not available in the repository, 
how long an entry should remain valid before being removed away from the repository 
and etc. Although these attributes are preloaded during declaration, designers can change 
them to meet individual application needs. 

3. Transaction operations 

Transaction operations allow processes to enforce consistency over a set of entry 
operations. When a process starts a transaction, entry operations carry out under this 


25 









transaction will be considered as a group operation. If the transaction completes 
successfully, then all entry operations associated to it are considered completed. 
However, if any problem arises in one of the operations, then the transaction would be 
aborted and all other operations are cancelled. Though using transaction would decrease 
the response time of entry operations, it helps to address one of the most difficult issues 
in distributed environment - partial failure. 




Figure 7 Entry Operations with Transaction 


As depicted in Figure 7, in order to bind entry operations with a transaction, the 
agent first has to request for a handle from the transaction service. Subsequently, it passes 
this handle along with other required parameters to carry out the entry operations. Every 
handle comes with an expiring time - it automatically terminates the transaction if 
operations issued are not completed within a given time. When the agent completes its 
entry operations, it has to inform the transaction service to close the transaction. 


4. Event Handling 

When a new entry arrives, the repository service creates a notification event. The 
event Handling allows processes to be triggered by notification event. For a process to be 


26 







triggered, it first has to invoke a notify operation, specifying the entry it wishes to 
monitor and the callback routine it defines to handle the trigger. The agent, upon 
receiving a notification event, performs some internal filtering and sorting to determine 
the owner and then triggers the callback routine. 



Figure 8 Event Handling 


Event notification is especially important in a distributed system. Rather than 
“busy waiting” for an entry to arrive in the repository service through polling, which is a 
burden to the entire network load, processes can make use of notification operation 
whereby a user-defined routine would be called when conditions are satisfied. 

However, in our current design we do not guarantee the delivery of all notification 

events raise by the service. In the worst case, where system fails or network congestion 

occurs, a notification event package might not reach its destination. Since no 

acknowledgment is returned to the sender, the notification event is considered lost. One 

* 

way to overcome this problem is to use an event mailbox service, which keeps a copy of 
all outgoing events and keep delivering the event until the recipient acknowledges. 




5. 


Code Serialization 


Leveraging on the Java code portability, our agent contains some operations that 
allow processes to embed codes into entries for executing in other processes. It performs 
the function of packing codes into entries and resembles the code in the agent for 
execution, as shown Figure 9. 



E. AGENT ATTRIBUTES 

Agent Attributes affect how the agent carries out its operations. Two of the 
attributes are lease time and time out, and they are applied in many areas. The designer 
can change the default attribute setting after initializing the agent to meet individual 
application needs. 

1. Leasing 

Leasing ensures that the resources used will not grow out of bound. Especially, in 
an environment where partial failure is frequent and processes are disconnected from the 
resources and cannot explicitly free them. A lease must be renewed before it expires, 
otherwise, the resources that have been requested under this lease will be released. 
Transparent to developers, the agent service has to periodically renew its iease with 


28 







JINI/lookup service to maintain the interest in using its facilities to publish its service. It 
is similar for agents to renew its lease in the agent service. 



Figure 10 Renewing Service Lease 


Every entry posted to space must be leased. By default it is given a lease of one 
minute. After the lease time expired, the service will free the resource occupied by the 
entry. Similarly, the transaction service will abort all transaction requests right after the 
lease expires. 



Figure 11 Entry Lease Expired 


29 







Developers must provide due consideration towards leasing while developing the 
application. Although the developer can set a longer lease time that would not expire, this 
could put some constraints on services that still have to maintain the resource used when 
the owner has been disconnected from the network and cannot explicitly free them. 

2. Timeout 

In a distributed environment, it is difficult to determine whether a process 
becomes unavailable due to a system failure or because the CPU is busy with some other 
jobs. Timeout offers the means for the process to give up its operations and turn to other 
jobs. Without timeout, process could be deadlocked to an operation when a certain 
system failure occurs, i.e., waiting endlessly until someone intervenes. Figure 13 and 
Figure 14 show diagrams of service timeout and Entry Read/Write operation timeout 
respectively. 


30 









> 

\ 

Process 

CQ 

©.. 

s 






J3)Tmeoui 

(1}Read 



\ 


JavaSpace 1 
• Service 


' Wait 

Figure 14 Entry Read/Take timeout 


: 


\ 

HZ 

© 

/CD' 

< 

Process 




1 


F. AGENT WRAPPERS 

There are many compelling reasons for the agent to support a wider variety of 
programming languages. Some of these reasons are software re-use, integration with 
legacy code, leveraging on tools that are not available for a particular programming 
language, and performing low-level activities such as hardware interface. 

In the thesis, we provide two types of agent wrappers, ActiveX Component 
Wrapper and Native C Library wrapper. ActiveX Component Wrapper allows our agents 
to be encapsulated as objects in Visual Basic, Visual C++ or Microsoft Office 
applications running in Microsoft Window platform, whereas Native C Library Wrapper 
allows our agent to be bound together with native languages such as Ada, C and C++. 


31 









Figure 15 Agent Wrappers 













IV. IMPLEMENTATION 

This session describes our framework architecture and its implementation details. 

A. ARCHITECTURE 



Figure 16 Agent Architecture 


Our agent architecture, as depicted in Figure 17, consists of six main modules. 


They are Agent Service module. Service Registration module, Agent Interface module. 
Event Module, Transaction Module and Agent Wrapper module. Agent Service module 
implements a service to manage and control the access of agents into the network 
environment. Service Registration module offers the means for processes to locate and 
register with the agent service. Agent Interface module provides processes a simple 
interface to access the agent operations. The Event module handles notification event 
issued by the repository service when new entry arrives at the repository. Transaction 


Module supports the entry operations with transaction services. Lastly, Agent Wrappers 


33 



























expose the interfaces of the agent to processes written in other languages such as Ada, C, 
C++ and Visual Basic/C++ 

B. AGENT SERVICE MODULE 

Agent service module implements authentication and control mechanism for 

processes running in the network environment. It also publishes an agentService interface 

to inform clients what methods are available in the service where they invoke. The 

agentService interface class consists of two methods, joinService and endService. 

JoinService method allows client to linkup with agent service and endService terminates 

connection with service. The JoinService method takes 2 parameters, a name and a 

password. Both parameters are used to verify the client identification and must match one 

of the records held inside its service database. 

public interface agentService { 

public boolean joinService(String name, String Password); 
public boolean endService(); 

} 

C. SERVICE REGISTRATION MODULE 

Service Registration Module offers the means for the process to locate and 
register with the service. It composes of two classes: ServiceAccessor and ServiceFinder. 
ServiceAccessor class provides the method for processes to discover and register with 
services in the JINI community. ServiceFinder class, on the other hand, helps the 
ServiceAccessor to determine whether a request exists in a list of services that it has 
discovered. 


34 



Figure 17 Service Registration Module 

1. Service Accessor 

ServiceAccessor class provides the method for processes to discover and register 
with services in the JINI community. Service discovery is done using the GetLocator 
method and service registration is performed using the getService method. 

public ciass ServiceAccessor implements java.io.Seria!izabie{ 
public static Locator getLocator( long lookupTimeout) 
public static AgentService getAgent{) 
public static AgentService getAgent(String name) 
public static JavaSpace getSpace() 
public static JavaSpace getSpace(String name) 
public static TransactionManager getTransaction () 
public static TransactionManager getTransaction (String name) 

} 


GetLocator method takes one parameter - timeout, which defines a maximum 
time (in millisecond) that it can spend searching for a lookup service (a facility where 
services in the JINI community publish their services). If it fails to locate one within a 


given time, an exception is returned to the calling process. 


GetService methods (e.g. getAgent, getSpace and getTransaction) return the 
handle of services that a process has registered with, otherwise they return a null value. 
These methods require processes to provide names that can identify the services if they 
are being setup using different names. 




2 . 


Service Finder 


ServiceFinder class provides a method, find, for ServiceAccessor to determine 
whether a requested service exists in the list of sendees that it has discovered. The find 
method takes three parameters —locator, name and timeout. Locator is a valid lookup 
service handle where the request service is likely to have registered. Name is a string that 
identifies the requested service. Timeout is the time in millisecond that limits the search 
duration. 

public class ServiceFinder extends Finder { 
public ServiceFinderQ {} 

public Object find (Locator locator, String name, long timeout) { 

D. EVENT MODULE 

The event module composes of three classes: SpaceEventRegistration, 
SpaceEventListener and SpaceActionHandler. SpaceEventRegistration class registers a 
notification event with the repository service. SpaceEventListener class monitors 
notification events generated from the repository service. SpaceActionHandler class 
analyzes the notification events and takes appropriate actions 



Figure 18 Event Module 


1. Space Event Registration 

The SpaceEventRegistration class is an interface responsible for registering 
notification event with the repository service to monitor new entries written into the 


36 













space by other cooperating agents. Every entry handler implements this interface to 
provide a consistent way of starting and stopping notification events. This class consists 
of two types of abstract methods: startEvent and stopEvent. 

public interface SpaceEventRegistration 

{ 

public abstract boolean startEvent(); 

public abstract boolean startEventl (SpaceActionHandler spaceAction); 

public abstract boolean startEvent2(SpaceActionHandler spaceAction, long lease); 

public abstract boolean startEvent3(SpaceActionHandier spaceAction, long lease , 
Transaction txn); 

public abstract boolean stopEventQ; 

} 

StartEvent method takes three parameters (if not specified, the default values will 
be used): SpaceActionHandler , Lease and Transaction. SpaceActionHandler is a valid 
object that is assigned to handle the notification event. Lease determines the expiring 
time in millisecond for a notification. Transaction is a valid handle, requested from 
Jini/Transaction service if a transaction is invoked. StopEvent method removes the event 
registration from the Repository service. It returns an exception if it fails to remove the 
registration or if the registration is already expired. 

2. Space Event Listener 

The Space Event Listener class listens to events issued by the repository service. 
It implements a RemoteEventListener interface, which includes a notify method that the 
repository service used for raising remote events when new entries arrive at its repository. 
The constructor has three parameters: entryType, entrylD, and SpaceActionHandler 
object. Both entryType and entrylD are required to identify the entry being monitored. 
SpaceActionHandle is a valid object that implements the SpaceActionHandler interface 
for handling of notification events. 


37 



public class SpaceEventlistener implements RemoteEventListener { 
private int eventType; 
private String eventID; 
private SpaceActionHandler action; 

public SpaceEventListener(int entryType, String entrylD, SpaceActionHandler action) 
throws RemoteException 
public void notify(RemoteEvent ev) 

1 


3. Space Action handler 

SpaceActionHandler is a simple interface class with an abstract ActionPerformed 
method and fire method. The agent implements this interface to handle notification event. 
ActionPerformed is a callback method that encapsulates actions for handling of the 
notification events; any class implementing this interface must overwrite the 
actionPerformed method. The ActionPerformed method is triggered every time 
SpaceEventListener invokes the fire method, together with an entryType and entrylD to 
identify the entry that cause the notification. 

public interface SpaceActionHandler extends ActionListener { 
public void actionPerformed(ActionEvent e); 
public void fire(int entryType, String entrylD); 

} 


E. INTERFACE MODULE 

The interface module composes of three sub-modules: Application Interface, 
Entry Handlers and Entry templates. Application Interface provides a simple interface for 
the process to access the agent’s functions. Entry Handlers allow the process to carry out 
operations pertaining to the declared entries. Entry templates are used for retrieving 
entries from the repository service. 


38 


Agent Interface 

;j.v : 






Pi 







Figure 19 Agent Interface Module 


1. Application Interface 

The application Interface provides a simple way for processes to access the 
agent’s operations. This interface can be sub-divided into 3 groups of methods: agent 
configuration, entry declaration, transaction handling. 

a. Agent configuration 

Agent configuration methods allow processes to change the setup 
properties as well as to initialize and to terminate connections with the services. Many of 
these properties determine how connections with the services are setup, thus changing 
these properties has to be done before invoking the initAgent method. In total, there are 6 
properties that are modifiable: AgentSecurityPolicy, AgentServerCodebase, 
AgentSpaceName, AgentLookupGroup, AgentSecurityPolicy and AgentLookupURL. 
Modifying and reading these properties can be done using their respective 
serAgentProperty and ge?AgentProperty methods. AgentSecurityPolicy property defines a 
policy file that controls all security permissions granted to the JVM. 
AgentServerCodebase property specifies the location of the code server where agents can 
download the required codes. AgentSpaceName property denotes the name of the 
repository service. AgentLookupGroup property indicates the group type to join in, either 


39 










public or private. And AgentLookupURL property defines the location of the repository 
service that the agent should start looking for this service. 

hiitAgent method allows a process to establish connections with services; 
this has to be done explicitly after the process has started. Terminate Agent method gives 
the system a chance to release allocated resources and relinquish service connections 
before a process ends. Processes written in other languages besides Java Programming 
languages have to explicitly call this method before termination to prevent any possible 
memory leaks. 

public class Agent implements java.io.Seriaiizable, SpaceActionHandler, TSConstants 

{ 


II System setting 

public void setAgentSecurityPolicy(String str) 
public void setAgentSpaceName(String str) 
public void setAgentServerCodebase(String str) 
public void setAgentLookupGroup(String str 
public void setAgentLookupURL(String str) 

public String getAgentSecurityPolicy() 
public String getAgentSpaceName) 
public String getAgentServerCodebase) 
public String getAgentLookupGroup 
public String getAgentLookupURLQ 

public boolean lnitAgent(long timeout) 
public void TerminateAgent() 


} 


b. Entry declaration 

Entry declaration methods allow a process to declare entries it wants to 

share with other processes running in the network. There are three methods provided, 

namely createlD, removelD and getTSObjec. CreatelD method creates a new entry 

handler to manage the declared entry. It takes 2 input parameters, entrylD and entryType. 

40 



Entry ID must be a unique string and entryType must be one of the following enumerate 
types: TSJBOOLEAN, TSJNTEGER, TS_FLOAT, TSJDOUBLE, TS_LONG, 

TS_STRIKG, TS_HASH, TS_QUEUE, TSJLIST or TS.STACK. Each enumerate type 
symbolize the kind of entry the process wants to create. RemovelD method purges the 
entry handler that had been created. Both CreatelD and RemovelD methods return a true 
value if they succeeded in completing the actions, otherwise they return a false value. 
G etTSObject method returns the handle of an entry handler only if the handler exists. 


Otherwise, it returns a null value indicating an error has occurred. 

public class Agent implements java.io.Serializable, SpaceActionHandier, TSConstants 

{ 

private Map tsStringMap; 
private Map tsBooleanMap; 
private Map tsIntegerMap; 
private Map tsFloatMap; 
private Map tsLongMap; 
private Map tsDoubleMap; 
private Map tsQueueMap; 
private Map tsStackMap; 
private Map tsLinkListMap; 
private Map tsHashMap; 


public boolean create!D(int entryType, String entrylD) 
public boolean remove!D(int entryType, String entrylD) 
public Object getTSObject(int entryType, String entrylD) . 


c. Transaction handling 

Transaction handling methods allow a process to start, stop, abort and 
query transaction. StartTransaction method starts a new transaction, registers a 
transaction request with the running transaction service. CloseTransaction completes the 
transaction, commits all entry operations that have been carried after the start transaction 
and relinquishes the transaction handle. GetTransaction method returns the current 


41 


transaction handle. AbortTransaction terminates the transaction; all the entry operations 
that have been invoked are cancelled. 

To perform a transaction, the process first has to invoke the 
stanTransaction method, where the agent would then get the transaction handle using 
getTransaction methods, and then to pass it together with every entry operation that is 
executed under this transaction. Finally, the process should invoke a closeTransaction 
method to commit the transaction. If any operation fails to complete or the transaction’s 
duration fall beyond the given lease time, all issues that the operations have defined will 
be recalled. 

public class Agent implements java.io.Serializable. SpaceActionHandler. TSConstants 

{ 

public boolean abortTransactionQ 
public boolean closeTransaction 
public boolean startTransaction() 
public Transaction getTransaction() 
public boolean isTransactionStarted() 

1 

2. Entry Handlers 

Entry Handlers allow processes to carry out operations pertaining to their entries. 
In total, there are 10 types of entry handlers; each corresponds to an entry type. For 
instance, an integer handler ( TSInteger) corresponds to an integer entry ( Entrylnteger ), 
offering methods needed to operate an integer entry in the repository service. 


42 



Figure 20 Entry Handlers 


Every Entry Handler inherits from a base class, TSBase. This class contains a list 
of entry attributes that determine how its entry behaves or how it should handle entry 
within the repository service. Upon initializing, these attributes are preloaded with default 


values. Processes can easily modify and query them by invoking their respective 

set Attribute and get Attribute methods. For example, to change or to check read-timeout 

attribute, a process can invoke setReadTimeout and getReadTimeOut respectively. 

public class TSBase implements java.io.Serializab!e{ 
public TSBase() { 

writeLeaseTime = Lease.FOREVER; 
updateLeaseTime = Lease.FOREVER; 
notifyLeaseTime = 10000; 
readTimeOut = Long.MAX_VALUE; 
takeTimeOut = Long.MAX_VALUE; 

} 

public void setJavaSpace(JavaSpace space) 

public void setSpaceActionHandler( SpaceActionHandler spaceAction) 

public void setTransactionHandler( Transaction trans) 

public void setWriteLeaseTime(!ong leaseTime) 

public void setUpdateLeaseTimefiong leaseTime) 

public void setReadTimeOut(!ong timeOut) 

public void setTakeTimeOut(long timeOut) 

public Transaction getTransactionHandlerQ 
public long getWriteLeaseTime(){ 
public long getUpdateLeaseTime(){ 
public long getReadTimeOut() 
public long getTakeTimeOutf) 

} 





























Every Entry Handler contains a common set of methods, but with some variation 
in input parameters depending on its entry type. These methods are readlfExists, 
takelfExists, write, update , startEvent and stopEvent. ReadlfExists method returns the 
entry value if it manages to find the request entry from the repository sendee. Similarly, 
takelfExists also returns the entry value but would remove the request entry from the 
repository service. Both methods take up to two input parameters: timeOut and 
transaction. The value of Timeout determines how long the handler should wait for an 
entry if it is available but still being held back by the repository service because of a 
transaction operation in progress. Transaction is a handle provided by transaction service 
to carry out a transaction. Both write and update methods create a new entry that contains 
an entry' value and put it into the repository service. Unlike write method, which just adds 
a new entry to the repository service; update method removes any existing entries, having 
the same entry name before placing a new one. Lease and transaction inputs are optional. 
Lease determines how long an entry remains valid in the repository service, after this 
time it would be automatically remove from repository. StartEvent and stopEvent 
methods allow a process to register and terminate entry notification with the repository 
service respectively. 

public class TS EntryType extends TSBase Implements java.io.Serializable, 
SpaceEventRegistration, TSConstants{ 

{ 

public boolean writet (dataType value) 

public boolean writ e2(data Type value, long lease) 

public boolean write3(dafa7ype value, long lease, Transaction txn) 

public boolean updatel (dataType value) 

public boolean update2(cfafa7ype value, long lease) 

public boolean update3 (dataType value, long lease, Transaction txn) 

public dataType readlfExists!) 

public dataType readlfExistsI (long timeOut) 

public dataType readlfExists2(long timeOut, Transaction txn) 

44 



public dataType take!fExists() 

public dataType takelfExistsI (long timeOut) 

public dataType takelfExists2( long timeOut, Transaction txn) 

public boolean startEvent() 

public boolean startEventl (SpaceActionHandler spaceAction) 

public boolean startEvent2(SpaceActionHandier spaceAction, long lease} 

public boolean startEvent3(Space Action Handler spaceAction, long lease , 

Transaction txn) 
public boolean stopEvent() 


} 

3. Entries 

Entries are serialized Java object instances that are stored within the repository 
service, where processes used them as a means to share information. In total, there are 10 
types of common entries created ranging from primitive type entry' like integer entry to 
more complex type entry like list and queue entry. Each entry class implements the Entry 
interface found in the net.jinni.core.entry.Entry package. 


Below is an example of an entry class - Entry Hash. Entry Hash allows a process to 
define its own data structure. Its constructor takes one parameter or two parameters: 
entrylD and map Object (Optional). The EntrylD identifies the entry placed in the 
repository service and the map object is a container that holds the data fields defined by 
the process. 


public class EntryHash implements Entry { 
public EntryHash (String entrylD) 
public EntryHash (String entrylD, HashMap map) 
public HashMap getHashMapQ 
public void setHashMap(HashMap map) 

} 


45 



Figure 21 Entries 


F. AGENT WRAPPER MODULES 

The Agent wrapper module consists of two separate components: ActiveX 
wrapper and C Library wrapper. ActiveX wrapper embeds the agent as an object such 
that processes written in Visual Basic, Visual C++ or Microsoft Office applications 
running in the Window environment can call it. C Library wrapper allows the agent to be 
bound together with processes written using machine dependents languages like C, C++ 
or Ada. 



Figure 22 Agent Wrapper Module 

The ActiveX Wrapper is implemented by using a packager, ActiveX Packager for 

Java Bean, that comes along with JVM plug-in provided by the Sun MicroSystem. This 

packager automatically generates the wrapper for any Java bean by going through the 

procedure of pre-compiling. Two files are eventually generated after the process, an OCX 

(OLE Control Extension) and a TLB (Type LiBrary). To make the OCX available to the 

Window environment, developers should explicitly register them in the window registry. 

46 




































Together with the Java Bean Bridge and JVM (Java Runtime Environment), any 
method calls on this OCX component will marshal over the bridge and gets executed in 
the JRE memory space; the return for the function is unmarshaled by the bridge and 


given back to the OCX component. 

The C Library Wrapper is built by using JNI (Java Native Interface) APIs. The 
procedure is more complicated and tedious than that of ActiveX Wrapper. We have to 
map every Java types to C, create corresponding interfaces in C language for every 
method defined, and manage the memory resources to prevent any memory leak. 


47 


THIS PAGE INTENTIONALLY LEFT BLANK 


48 


Y. RESULTS 

This session presents the results of an experiment conducted to measure the 
response time of JINI/JavaSpace service for inter-process communications. It also 
provides some guidelines on constructing a distributed system by using the proposed 
agent framework. An Elevator Control System (ECS) is developed as an example. 

A. SERVICE RESPONSE TIME 

Chart 1 and Chart 2, as depicted in Figure 23 and Figure 24 respectively, show the 
response times of the JINI/JavaSpace Service that we have tested over a local area 
network on two Pentium III/SOOMHz machines. One machine is loaded with Jini 
Services (including Agent Service, Lookup Service, Transaction Service and JavaSpace 
Service) and the other is loaded with a client program making requests with Jini Services. 
The local area network traffic is pretty light - it takes an average latency time of 0.6 
milisecond for a 512 bytes data package to travel across the network from one machine to 
the other machine when using sockets. 

Both experiment are performed over the duration of 2 minutes with a total of 
1,000 test cases. Each case consists of 5 roundtrip requests, 5 read and 5 write operations. 
Roundtrip response time, time between the issue of a complete write operation follow by 
a successful read operation, was measured by taking the average of 5 roundtrip requests. 
The result of each case was taken and plotted on the charts below. 

The average roundtrip respond times in Chart 1 (1,000 tuples in the repository) 
and Chart 2 (10,000 tuples in repository) are 12.4 milisecond and 12.03 milisecond 
respectively. Chart 2, despite having more tuples, has a lower average roundtrip respond 


49 



time. We believe that it is due to fluctuation in the network traffic rather than changes in 
system performance. 


JavaSpace Service Response Time 
(1,000 tuples in repository) 



Server 

1 Pentium !ir500MHz 
128MBytes Memory 

Test Cases 

Total No. : 1000 
Duration : 120 Sec 

Response Time(msec> 
Best : 10 
Worst : 37 
Average : 12.4 
StdDev. : 2.28 


Figure 23 Chart 1 JINI/JavaSpace Response Time 


Service Response Time 
(10,000 tuples in repository) 

Server 

i cnn - ~ ___ 

<f> 

2 400 - 


■ : —~~—...t“ .""""t i nenxium Hi/ouuMrtz 

j 123IVBytes Merrory 

w < tUU 

<s 

° 300 - 


1 • j Test Cases 

CO 

f # © 

i I— onn - 


T ; No- .1000 

1 ; Duration : 120 Sec 

o 

— inn - 

■ 

I 1 Response Time (msec) 

O i uu 

z 

r\ 

■ 

1 i 

0 20 40 60 80 Std ° eV ’ :3 ' 32 

Response Time (msec) 


Figure 24 Chart 2 JINI/JavaSpace Response Time 














B. DEVELOPMENT GUIDELINES 

The following presents some guidelines on how to develop distributed 

applications using our agent framework; developers are advised to try out the test 
programs to get familiarized with the features that our framework provides. 

1. Identify the number of independent processes required for an application. 
They can either reside on the same machine or on different machines but must 
share a common network. 

2. Determine the number of entries and their types need to be defined in the 
repository service whereby different processes can use them for exchanging 
information. 

3. Use the appropriate wrapper if processes are written in other languages 
besides Java Language. ActiveX wrapper for Delphi, Visual Basic and Visual 
V-h- processes, and C Library wrapper for C, C++ and Ada processes. 

4. Within every process, 

a. Instantiate an agent 

b. Update the system setting; Agent Service, Security Policy file. Server 
Codebase, Lookup Group and Lookup URL before establishing 
connections with the services. 

c. Invoke initAgent method to establish connections with the services. It 
takes up to a maximum of 20 seconds to establish a connection. 


51 





d. Declare all entries, defined earlier, with the instantiated agent. Every 
entry declared has to be identified by a unique name otherwise it will 
overwrite any earlier declaration. 

5. Use the appropriate entry operation to access entries stored in the repository 
service. It is important to minimize the number of operations as far as possible 
since the network latency is about 10 miliseconds as compared to a few 
nanoseconds for accessing a local shared variable within a process. 

C. TESTING JINI/SERVICES 

We have created 3 test programs, which are written in different languages, to test 
the configurations of services and client processes. Figure 25a, 25b and 25c showed the 
screen captures of these test programs that are implemented in Java language. Visual 
Basic language and C language respectively. Each test program is a GUI component 
enhanced by an agent. These test programs consist of many useful functions described in 
the framework. Besides using them for testing the configurations, they can also be used to 
demonstrate how our framework works. 

We also included a simple script in Appendix B to simplify the complicated 
process of setting up the JINI/Services. Designers can load this script with JINI service 
starter toolkits provided by the Sun Microsystems to start the services. A detailed 
description on how to setup JINI Services can also be found in [ KEI 99] 

After all the JINI services have been started, run any of the test programs on a 
separate machine anywhere in the network. Updates the agent setting, if the setup 
parameters are different from the default values, and then press the “initAgents” button to 


52 



establish connection with the agent service. If successful it will return a “service 
connected” message. Otherwise, it returns an error message indicating the problem 
encountered during initialization. 



Figure 25a Agent Test Bench (Java Language version) 


53 































Figure 25b Agent Test Bench (Visual Basic Language version) 


Enter connandt ttjpe :SIHING IB:T$$tring 3 ->i 
Enter Object ID ->TS$tring 

*** Level 1 Help *-* 



ISQl 



set object tj;pe 
set object IB 
renoue object 
create object 
list all objects 
start transaction 
abort transaction 
close transaction 
quit 

[space 3 : NEXT level 

Enter connandt type:$IKING IBiTSString 3 ->fc 
182:1NTEGE8 ri3:FL0fiX C22:LONG m:BOUBLE t43:STBING 

[53:GUEUE C63 = STftCK C?3 = UNKLIST £83:HHSH m:BOOLESN 

Enter Object Xs^Il^ 


Figure 25c Agent Test Bench (C Language version) 


54 




































D. AN EXAMPLE: AN ELEVATOR CONTROL SYSTEM 

We have designed a simple elevator control system (ECS) to demonstrate how 
distributed applications containing processes written in different programming languages, 
use our agent framework. Table 1 gives a brief description of the ECS requirements. 
Figure 26 is a state chart of the ECS, explaining the various operating states inside the 
system. It also shows the required commands to transit between states, the input guards 
for each command, if any, and the time duration to operate each state. 

We have divided the ECS into six independent processes: one scheduler, two 
hardware emulators, two control panels, one floor panel. The Scheduler determines an 
optimal solution to schedule the two elevators as well as monitors, and dispatches the 
commands to the hardware emulators. The Hardware emulator simulates the timing and 
sequences that an actual controller would need to control its hardware. The Control panel 
provides the interface for passengers to select their destinations, controls the closing and 
opening of the elevator door, and views the status of the elevator. Floor panel allows 
passenger to request for the elevator at each floor. 

Each of the six processes is designed to run on a different machine and to use the 
agents to interact with one another. Four processes (two hardware emulators and two 
control panels) are written in Java programming language. One process (floor control) is 
written in Visual Basic language with ActiveX agent wrapper. The last process 
(scheduler) is written in ANSI C language with C agent wrapper. We will only illustrate 
in this thesis how we design the process interface and the shared data, the details on how 
to build the logical portions of each process in relation to the ECS functionality will not 

be discussed. Screen captures of the final product is shown in Figures 28A-28D. 

55 





ECS Requirements 

The elevator control system controls 2 elevators in a building consisting of 10 floors: It 
schedules elevators to respond to requests from passengers at various floors and controls the motion 
of the elevators between floors. 

Inside each elevator ; there is a set of elevator buttons and lamps: 10 floor buttons for the 
passengers to select their destination , an “open” button to keep the door open, a “close” button to 
close the elevator door , and 10 floor lamps to indicate either the current floor if the elevator is 
stationary or the arriving floor if the elevator is in motion . Each elevator also has a motor that is 
controlled by commands to open and close the door . 

At the second to the ninth floor\ there is a pair of “up” and “down” call buttons for 
passengers to request for an elevator. A corresponding pair of lamps will indicate the directions that 
have been requested. There are only an “up” button and an “up” lamp in the first floor and only a 
“down” button and a “down” lamp in the tenth floor. 

At each floor for each elevator ; there is a pair of direction lamps to indicate whether an 
arriving elevator is heading in the up or down direction. For the top and the bottom floors , there is 
only one direction lamp per elevator. There is also a floor arrival sensor at each floor in each elevator 
shaft to detect the arrival of an elevator . 

The elevator buttons , floor buttons „ and floor arrival sensors are active asynchronous 
devices; that is, input from these devices will automatically turn on their corresponding registers. The 
control software is responsible to poll these registers. The registers will automatically return to the off 
state once polled by the control software. The other I/O devices are all passive. The elevator and floor 
lamps ; as well as the direction lamps are switched on and off by the software . 

Timing requirements: 

• Elevator buttons are pressed with a maximum frequency of 5 times per second, which represents a 
minimum inter-arrival time of200 msec. 

• Floor buttons are pressed with a maximum frequency of 2.5 times per second ’ which represents a 
minimum inter-arrival time of400 msec. 

Each elevator takes at least 2 seconds to open or close its door ; 9 seconds to accelerate , 
travel and then decelerate to the next floor ; and about I second to travel one floor once the elevator 
attains its constant speed. The corresponding floor arrival sensor will be turned on when the elevator 
is halfway between the two floors. 

Table 1 ECS Requirements 


56 






/ current„floor := I 


tm(5dIe_Tjmer) 



Figure 26 ECS State Chart 

We have created 5 globally shared entries, as depicted in table 2, for processes to 


share information. These shared entries are: AStatusEntry, BStatusEntry, AscheduleEntry, 

BscheduleEntry and requestEntry. AstatusEntry entry and BstatusEntry entry stored the 

status of Elevator A and Elevator B respectively. For examples, push button states, 

elevator heading direction, door states and etc. XstatusEntry entry allows hardware 

emulator to update the control panel the status of the elevator when it transits from one 

state to another. Similarly, for AscheduleEntry entry and BscheduleEntry entry, they store 

the data (e.g. request floor) for the next schedule planned by the scheduler for Elevator A 

and Elevator B respectively. Hardware emulator read this entry to determine the next 

57 

















floor to service. RequestEntry entries contain the floor requests submitted to the 
scheduler either from the Control Panel or the Floor Panel. Once the scheduler reads 


them, it will remove them from the repository. 



Figure 27 ECS processes 


58 














No I EntrvID 


1 AstatusEntrv 

2 BStatusEntrv 


EntrvType 


HashEntry 



RequestEntrv 


AScheduleEntry 

BScheduIeEntrv 


Content 


String: eievatorlD 
Boolean: button 1 
Boolean: button2 
Boolean: button3 
Boolean: button4 
Boolean: buttons 
Boolean: button6 
Boolean: button7 
Boolean: button8 
Boolean: button9 
Boolean: button 10 
Integer: direction 
Integer: Level 


String: eievatorlD 
Integer: requestLeve! 
Integer: direction 


String: eievatorlD 
Integer: destination 
Integer: direction 
Integer: current 
Boolean: status 


Table 2 ECS Shared Entries 


HashEntry 


HashEntrv 


Remark 


A3 

T: Active FiNone 
T: Active FrNone 
T: Active FiNone 
T: Active FiNone 
T: Active FiNone 
T: Active FiNone 
T: Active FrNone 
T: Active FiNone 
T: Active FrNone 
T: Active FrNone 
OrNone IrUp 2:Down 
l Ls; -10* floor 


None, A.B 
l is! - 10* floor 
OrNone l:Up2:Down 


A3 

l 15 * -10* floor 
OrNone lrUp2:Down 
l hx -10* floor 
OrDone 1 rln-prosress 



I^Etevatoi 1§0 

jf^ :: ~f Elevator B | 

Ml 

Kit 

mm, 

f : g} 

||w; 


; j 

wm 




Figure 28A Elevator A & B Control Panel 



Figure 28B Floor Control Panel 


59 












































1. Declare and initialize entry 

The following code snippets show how we declare the entries and initialize their 
values in different programming languages 


XstatusEntry (In Java language) 

//Declare an status Entry 

agent.createID(agent.TS_HASH, statusEntrylD); 

//Initialize value 

TSHash ts = (TSHash) agent.getTSObject( agent.TS_HASH, statusEntrylD); 
if(ts != null){ 

ts.setBoolean("buttonl",false); 
ts. setB oolean( "button2 " ,false); 
ts. setB oolean( "button3 M ,false); 
ts. setBoolean( "button4" ,false); 
ts. setB oolean( "button5" ,false); 
ts.setBoolean("button6",false); 
ts.setBoolean("button7",false); 
ts.setBoolean("button8",false); 
ts.setBoolean( "button9" ,false); 
ts.setB oolean( "button 10" ,false); 
ts.setBoolean("up" ,true); 
ts. setB oolean(" down" ,fal se); 

ts.setlntegerC’level’M); // level: 1 to 10 floor 

ts.setFloat("door ,, ,(float)1.0); // Door open percentage : 0 to 100% 

} 

requestEntry (In visual basic language) 

‘Declare an status Entry 
agent.createID(TS„HASH, requestEntrylD) 

‘Initialize value 

agent.getTSObject(TS_HASH, requestEntry ID).setStrmg("elevatorID", > ’A”) 
agent.getTSObject(TS_HASH, requestEntrylD) .setlnteger( "requestLevel", 1) 
agent.getTSObject(TS_HASH, requestEntrylD). setlnteger( "direction",0) 


Xschedule (In C languague) 

//Declare an status Entry 
createID(TS_HASH, “scheduleEntrylD”); 

//Initialize value 

TSHASHSetString(“scheduleEntryID”, “elevatorID , \’ , A”); 
TSHASHSetInteger(“scheduleEntryID”, “destination”, 1); 
TSHASHSetInteger(“scheduleEntryID”, “direction” ,0); 

60 




TSHASHSetInteger(“scheduleEntryID”, “current”,!); 


2. Read and Write Entry 

The following code snippets show how we read entries and write entries to and 
from the repository respectively. 

XstatusEntry (In Java language) 

// Read status entry contents 

TSHash ts = (TSHash) agent.getTSObject(TS_HASH, statusEntrylD); 
if(ts .readlfExistsO) { 

frame.butl.setState(ts.getBoolean( H buttonl")); 

frame.but2. setS tate(ts. getB oolean(" button2")); 

frame.but3.setState(ts.getBoolean("button3")); 

ffame.but4.setState(ts.getBoolean("button4")); 

ffame.but5.setState(ts.getBoolean("button5")); 

frame.but6.setState(ts.getBoolean("button6 M )); 

frame.but7. setS tate(ts. getB oolean( M button7 ")); 

frame.but8.setS tate(ts.getB oolean("button8")); 

frame .but9. setS tate(ts .getB oolean( "button9")); 

frame.butl0.setState(ts.getBoolean("buttonlO M )); 

frame.up.setState(ts.getBoolean("up")); 

frame .down. setState(ts. getB oolean(" do wn")); 

ffame.level.setValue(ts.getInteger( ,, level n )); 

ffame.door.setValue(ts.getFloat( M door M )); 

} 

// Update status entry contents 

TSHash ts = (TSHash) agent.getTSObject(TS„HASH, statusEntrylD); 

ts.setBoolean("button 1”,false); 

ts. setB oolean ( M button2", false); 

ts.setBoolean("button3”,false); 

ts.setBoolean( ,, button4 ,, ,false); 

ts. setBoolean(”button5" ,false); 

ts.setBoolean( f, button6",false); 

ts. setBoolean(”button7 n ,false); 

ts.setBoolean("button8 M ,false); 

ts.setBoolean( H button9",false); 

ts.setBoolean("button 10”,false); 

ts.setBoolean(”up ,, ,true); 

ts.setBoolean( M down ,, ,false); 

ts.setInteger( M level",l); //level: 1 to 10floor 

ts.setFloat("door",(float) 1.0); // Door open percentage : 0 to 100% 

ts.updateO; 


61 



requestEntry (In visual basic language) 

6 Read schedule entry contents 

if agent.getTSObject(TS_HASH, requestEntry ID) .readIfExists() then 

elevatorlD = agent.getTSObject(TS_HASH, requestEntryID).getString(”elevatorID M ) 
level = agent. getTSObject(TSJHLASH, requestEntry ID). getlntegerCrequestLevel”) 
dir = agent.getTSObject(TS_HASH, requestEntryID).getInteger("direction") 


endif 

‘Write a new request entry 

agent.getTSObject(TS_HASH, requestEntry ID). setString( "elevatorlD",” A”) 
agent.getTSObject(TS_HASH, requestEntryrD).setInteger( n requestLever,l) 
agent.getTSObject(TS_HASH, requestEntryID).setInteger("direction",0) 
agent. getT S Obj ect(TS_HASH, requestEntry ID). writeQ 


X schedule (In C languague) 

// Read schedule entry contents 

if(TSHASHReadIfExist(“scheduleEntryID”)) 

{ 

TSHASHGetString(“scheduleEntryID”, “elevatorlD”, elevatorlD); 
destination = TSHASHSetInteger(“scheduleEntryID”, “destination”); 
direction = TSHASHSetInteger(“scheduleEntryID”, “direction”); 
current = TSHASHSetInteger(“scheduleEntryID”, “current”); 

} 

// Update schedule entry contents 
TSHASHSetString(“scheduleEntryID”, “elevatorlD”,”A”); 
TSHASHSetInteger(“scheduleEntryID”, “destination”,!); 
TSHASHSetInteger(“scheduleEntryID”, “direction”,0); 
TSELASHSetInteger(“scheduleEntryID”, “current”, 1); 

T SH ASHW rite(‘ 'scheduleEntry ID’ ’); 


62 


VI. DISCUSSION 


A. JAVA PROGRAMMING LANGUAGE 

We have chosen Java programming language instead of other languages to 
implement the framework. Using Java programming language, it allows our codes to 
remain portable between various computing platforms without worrying about the 
underlying architecture, data representation and operating system of the actual machine 
that they are running. Java’s rich sets of APIs and object-oriented nature simplify our 
design. We have reused many packages that come along with JDK (Java Development 
Toolkit) in our implementation and our designs are simple and easy to understand. 

Java programming language also offers another distinct advantage. It allows code 
besides data to travel across the network and run on a client machine avoiding the tedious 
process of system configuration. This is important especially for distributed applications 
because processes tend to execute on different computing platforms; maintaining and 
managing a uniform operating environment can be very difficult. 

We foresee Java programming language to replace many of the existing native 
programming languages in the future. The evolution of the Internet has changed how 
people view software. With more devices like hand phone, PDA (personal device 
assistance), game console, connecting to the network in each day, writing software using 
machine dependent languages to meet new requirements and expect it to run and support 
a wide variety of platform and hardware might no longer be possible in the future. 
Nevertheless, we still have to co-exist with the existing languages in the mean time. Thus 


63 




we have built wrappers, ActiveX wrapper and native C library wrapper, to allow other 
languages to access our agent as well. 

B. JINI TECHNOLOGY 

Jini Connection technology provides a simple mechanism for objects (clients or 
services) to discover, join and detach with one another. This makes it very attractive to us 
in terms of designing and managing processes running in a distributed environment. Our 
agent service can easily locate and replace services (such as JINI/transaction service) that 
its processes are using but have become unavailable because of system failure or network 
congestion, and processes can still find the agent service even if we change its network 
location. 

Another reason that has affected our decision is that many services such as 
JavaSpace service, transaction service, leasing service and etc are already available. It 
would have taken us a lot of efforts if we were to build similar functions from scratch. 
JavaSpace service has given us a Linda TupleSpace Model type of communication 
mechanism that we are looking for our loosely coupled processes. Although there are 
similar implementations like IBM Tspace Cloudscape’s Java database, which are also 
written in Java programming language, we preferred JavaSpace because of its scalability. 
We could create new services to supplement any features that it does not have. 

C. FUTURE WORKS 

Our current implementation is only the first step towards fulfilling our agent 
framework. We have focused more on designing and building an architecture that is 


64 




scalable and robust. Although we have addressed many of the difficult issues caused by 
the distributed environment, solved the problems of inter-processes communications and 
managed a dynamic network, there are still many other areas in our framework where 
improvements can be made on. Some of them are listed as below. 

Enhance Agent Service - The features provided by our agent service are cunrently 
quite limited. It only provides simple authentication and coordination mechanism for 
controlling process using its service. Other features that can be added are 

□ Provide an GUI to manage and monitor processes running in the network 

□ Provide connection to backend server like email, database, rule-base 
engine and etc 

Point-to-Point Communication Service — The Linda TupleSpace type of 
communication is a great way of sharing information in a distributed environment if there 
is no strict constraint on response latency. From the experiments that we have carried out 
every entry operation, e.g. read an entry from repository, carried a latency penalty of 
eight milliseconds compare to less than a millisecond for point-to-point communication 
using sockets. Point-to-Point communication is also more suitable for sending large 
amounts of data between two processes. 

Security Issues - Security is one of the areas we did not spend much time on. One 
of the reasons is that we are waiting for the JINI Community to finish their design on 
how they are going to incorporate the security mechanism into their infrastructure. 
Security will be a very important issue if processes are connected to the Internet. 


65 




THIS PAGE INTENTIONALLY LEFT BLANK 


66 



VII. CONCLUSION 

This thesis presented a simple agent-based framework to address the concerns for 
building distributed applications. Agents act as the interfaces for processes to interact 
and to cooperate in a distributed heterogeneous environment. It shields developers from 
the underlying dynamic and complex network environment by encapsulating the 
implementation details in the agents and providing a simple set of Application Program 
Interfaces (API), where processes writing in variety of programming languages that can 
be easily invoked. The thesis discussed in detail the characteristics of the software agents 
including agent service, agent operations, agent attributes, and agent language wrappers. 
Software agents provide a wide range of primitive data types, as well as the feasibility of 
user-defined formats. Concerns in a distributed environment, such as partial failure, 
synchronization and coordination, have been taken into consideration in the proposed 
agent framework through various agent operations. The agent attributes, by 
communication leasing time, time-out and transaction, explore the possibility of 
providing time constraints for distributed system communications over the network. It 
enriches the research of distributed system prototyping. The language wrapper concept 
makes the proposed framework feasible in most of language platforms, which achieves 
the interoperability among heterogeneous software components. Test-bed applications 
and the example demonstrate the important features and show the feasibility of the 
proposed technology and methodology. 

The framework is built on JINI infrastructure to simplify the tasks of building and 
maintaining reliable distributed systems. It uses a Linda TupleSpace model, a shared 
network-accessible repository, for different processes to exchange information. 


67 





Processes are loosely coupled. They discover and linkup with one another by using 
services residing on JINI infrastructure. Based on the JINI structure, the agent service 
provides an interface of developing other features in building a distributed system such as 
security management. 

This framework is to be used in the Distributed Computer Aided Prototyping 
System (DCAPS) [LUQI92] to provide the inter-process communication layer. The agent 
framework provides the glue library in the wrapper/glue architecture for distributed 
system prototyping. It simplifies the tasks of designing, binding and analyzing multiple 
processes of real-time, distributed systems. Introducing time constraints for network 
communications into the distributed system design is an initial effort in the research of 
distributed system prototyping. 




[CLOUDOO] 

LIST OF REFERENCES 

Cloudscape. Cloudscape Java database . httD://www.cloudscaoe.com 

[DCOM96] 

Microsoft Corporation, DCOM Technical Overview, Nov. 1996. 
http://msdn.microsoft.com/librarv/back 2 md/html/msdn dcomtec.htm 

[GEL85] 

D.Gelemter, Generative Communication in Linda, ACM Trans. 
Programming Languages and Systems, 7(1), Jan. 1985, pp. 80-112 

[JOY99] 

Bill Joy, The Jini Specifications, Addison Wesley, Inc., 1999 

[JVM96] 

Lindhom, T. and Yellin, F., The Java Virtual Machine Specification, 
Addison-Wesley, ISBN 0-201-63451-1 

[JS99] 

E. Freeman, S. Hupfer and K. Arnold, JavaSpaces: Principles, Patterns, 
and Practice, Addison-Wesley, 1999 

[LUQI92] 

Luqi, “ Computer-aided prototyping for comand and control system using 
CAPS ”, IEEE Software, 9(1), Jan. 1992, pp 56-67 

[KEI99] 

Edward Keith, Core Jini, Prentice, Gall PTR, 1999 

[MEESON97] 

Reginald N. Meeson, Analysis of Secure Wrapping Technologies 
(Alexandria, VA: Institute for Defense Analysis). 

[ORB91] 

The Object Management Group, Common Object Request Broker: 
Architecture and Specification, OMG Document Number 91.12.1(1991) 

[ROBERT98] 

Robert Holton , Real Time Systems, 

http://www.comp.brad.ac.uk/home/comDutin2/Modules/CM0506D/Cour 


seware/weekl 1/node 1 .html 

[RMI00] 

Sun Microsystems, Remote Method Invocation. Java 2 SDK 
Documentation. Dec 2000. http://iava.sun.com/Droducts/idk/L2/docs 

[TSPACESOO] 

IBM. Tspaces. http://www.almaden.ibm.com/cs/TSDaces 


69 



THIS PAGE INTENTIONALLY LEFT BLANK 


70 



APPENDIX A. AGENT API 


Package 


Class 


Tree Index Help 


PREV CLASS NEXT CLASS 

SUMMARY: INNER [ FIELD J CONSTR j METHOD 


FRAMES NO FRAMES 

DETAiL: FiELD I CONSTR 1 METHOD 


TUPLESPACE.CORE 

CLASS AGENT 


java.iang.Object 


+-lupiespace.core.Agent 


public class Agent 
extends java.lang.Object 

implements java.io.Serializable, tuplespace.entries.SpaceActionHandler, TSConstants 
The Agent class implements the methods to configure agent properties, establish 
connection with Jini Services, request for transaction and create new entry handlers 


See Also: 

Serialized Form 

Constructor Summary 



'?/' i 

AgentO 




Aeentfiava.Ianq. String propertiesFiiename) ! 





jMethod Summary 

boolean 

abortTransactionO 

Abort the current transaction; all the commands issued with this 
transaction after the start transaction will be rolled back. 

void 

actionPerformed(iava.awt.event.ActionEvent e) 

void 

i 

addActionListener(iava.awt.event.ActionListenerl) 

boolean 

cleanTSClassfint type, java.lanq.String id) 

Creates a new TSString ID 


71 
















boolean 

closeTransactionO 

closes the current transaction; all the commands issued with 
transaction after the start transaction will become active. 

boolean 

createlDfint tvDe. iava.iana.Strina id) 

[Create a new entry in agent 

void 

fireActlonfint entrvTvDe. iava.iana.Strina entrvID) 

i tuplespace.entries.Spac 

eActionHandler 

i 

setActionHandlerO 

Return the space Action handle 

java.Iang.String 

■ i 

aetAsentLookupGroupf) 

Return Agent Lookup Group 

java.Iang.String 

1 

set4eentLookupURL0 

Return Agent Lookup URL 

java.Iang.String 

getAsentSecuritvPoIicvO 

Return Agent Security Policy path and filename 

java.Iang.String 

setAaentServerCodebase () 

Return Agent Server Codebase 

1 java.Iang.String 

i 

setAsentSpaceNameO 

Return Agent Space Name 

j tuplespace.core.Transac : 

1 i 

} tion 

| j 

setTransactionO 1 

Return the transaction handle; transaction manager must be 
initialized and started 

java.Iang.String 1 

| 

1 

l 

getTSClassIDsfint tvDe) 

Return all TSString IDs created 

java.Iang.Object 

getTSObiectfint tvoe. iava.iana.Strina id) 

Remove an existing TSString ID 

j int 

getTSTvDefiava.iana.Strina tvDe) 

boolean 

1 

InitAeentflona timeout) 

Look for the Jini Services and test whether the interface is 
functioning 

boolean 

} 

isT ransactionStartedO 

Return the current state of transaction handle 

void 

prmtfiava.Iana.Strina str) 


72 














i 

i 

void 

readAsentProperties(iavaJanq.Strin^ filename) 

void 

5 

removeActionListener(iava.awt.event.ActionListener!) 

! 

boolean 

i 

removelDfint type, iava.lanq.String id) 

Remove an existing TSString ED j 

void 

SearchTSClassIDsf) 

void 

setAsentLookupGroupfiava. lanq. Stri ng str) 

Set Agent Lookup Group 

s 

void 

setAgentLookupURLfiava.Ianq.Strinq str) 

Set Agent Lookup URL 

void 

< j 

i 

1 

set4gentSecuritvPoIicv{iavaJanq.Strinp str) 

Set Agent Security Policy path and filename 

1 void 

1 1 

| j 

setA 2 entServerCodebase(iava.lanq.String str) 

Set Agent Server Codebase 

| void | 

1 i 

set4gentSoaceName(iavaJanq.Strinq str) 

Set Agent Space Name 

boolean 

startTransactionO 

Start transaction manager; transaction handle will remain valid 
for a maximum of 5 minutes (Default setting) 

void 

| 

s 

TerminateAsent() 

boolean 

I 

1 uodateTransactionHandleOnt type, iava.Ianq.Strinq id) 
j Update the transaction handle in TSObject 


73 



















Package 


Class 


Tree 


PREV CLASS NEXT CLASS 

SUMMARY: INNER [ FIELD | CONSTR 1 METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD I CONSTR I METHOD 


TUPLESPACE.CORE 

CLASS SERVICEFINDER 

tuplespace.core.ServiceFinder 
public class ServiceFinder 

A LookupFinder implements the methods needed locate a service in a Jini(tm) Lookup 
service. 


Constructor Summary 

ServiceFinder O 

Create a new LookupFinder object 


Method Summary 

i _____ — — - 

java.iang.Obiect Iind(com.sun.iini.mahout.Locator locator, java.Iang.String name) 

j Using the Jini lookup service returned by locator find the 
| service registered with a net.jini.lookup.entry.Name attribute who’s 
| value is name. 


! 


74 












Package 


Class 


PREY CLASS NEXT CLASS 

SUMMARY: INNER t FIELD 1 CONSTR 1 METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD | CONSTR | METHOD 


TUPLESPACE.CORE 

CLASS SERVICEACCESSOR 

java.Iang.Object 


+—tuplespace.core.ServiceAccessor 


public class ServiceAccessor 
extends java.!ang.Object 
implements java.io.Serializable 

The ServiceAccessor class implements the methods for registering the Services 

See Also: 

Serialized Form 


Constructor Summary 

- - • .. ; ’ » 

ServiceAccessorO 



Method Summary 

llfff %.%. ?’■ 'f 'V* ' '/H&1 

static com.sun.jini.mahout.Locator 

» 

aetLocatorflong iookupTimeout) 

static netjini.core.transaction.server. 

TransactionManager 

setManaaerO 

static net.jini.core.tran$action.server, 

i i 

} T ransactionManager 

setManaser(iava.ianQ.StrinQ name) 

r . 

static net.jini.space. JavaSpace! 

j ! 

setSpaceO 

static netjini.space.JavaSpace 

! setSDacefiava.iang.String name) 

1 


75 
















Package 


Class 


Tree 


PREV CLASS NEXT CLASS 

SUMMARY: INNER j FIELD | CONSTR j METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD 1 CONSTR ] METHOD 


TUPLESPACE.CORE 

INTERFACE SPACEEVENTREGISTRATION 

AH Known Implementing Classes: 

TSBooiean . TSCiass, TSDouble. TSFIoat . TSHash . TSInteeer . TSLong . TSOueue . 
TSString 


public abstract interface SpaceEventRegistration 

The SpaceEventRegistration class implements the methods for for registering with Space 
Service to monitor new entries written into the space. 


Meth 

od Summary 

boolean 

startEventO 

boolean 

startEventlftuDlesDace.entries.SoaceActionHandler spaceActiont 

boolean 

i 

startEvent2(tUDleSDace.entries.SDaceActionHandler soace Action. Iona leaset 

boolean 

startEvent3(tuDlesDace.entries.SDaceActionHandler spaceAction. Iona lease. • 
tuplespace.core.Transaction txn) 

1 

boolean 

; 1 

stopEventO 

] 










Package 


Class 


Tree Index 


Help 


PREV CLASS NEXT CLASS FRAMES NO FRAMES 

SUMMARY: INNER | FIELD | CONSTR1 METHOD DETAIL: FIELD 1 CONSTR1 METHOD 


TUPLESPACE.CORE 

INTERFACE SPACELISTENER 


public abstract interface SpaceListener 
extends java.awt.event.ActionListener 


Method Summary 

void 

actionPerformed(iava.awt.event.ActionEvent e) 

void 

i 1 

flreActionO 


77 








Package 


Class 


PREV CLASS NEXT CLASS 

SUMMARY: iNNER | FIELD | CONSTR | METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FiELD [ CONSTR | METHOD 


TUPLESPACE.CORE 
INTERFACE TSCONSTANTS 

All Known Implementing Classes: 

Agent , TSClass . TSDouble . TSFloat. TSHash. TSInteger . TSLong. TSOueue . 
TSBoolean . TSString 


public abstract interface TSConstants 


Field Summary 

static int 

’TS BOOLEAN 

static int 

TS DOUBLE 

static int 

TS FLOAT 

static int 

TS HASH 

static int 

j 

TS INTEGER 

.- -...-.-.... • . .. .... 

static int 

TS LINKLIST { 

i 

static int 

TS LONG | 

static int 

TS OUEUE ! 

-... . I 

static int; 

TS STACK 

} 

i 1 

l static int i 

i i 

TS STRING 

j 


78 













Package 


Class 


PREV CLASS NEXT CLASS 

SUMMARY: INNER! FIELD I CONSTR I METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD | CONSTR | METHOD 


TUPLESPACE.CORE 

CLASS TSBASE 


java.iang.Object 


+-tuplespace.core.TSBase 
Direct Known Subclasses: 

TSBoolean , TSClass . TSDouble , TSFIoat TSHash, TSInteger . TSLong , 
TSOueue, TS String 


public class TSRase 
extends java.lang.Object 
implements java.io.Serializable 

The TSBase class implements the methods for setting the attribute of entry. Every entry 
handler will inherit this class 
See Also: 

Serialized Form 


Constructor Summary 

^.iiN.iiininnl.I.. .mV nlT ‘ " '-li,r" ,r . I "II"".. 

TSBaseO 


Method Summary 


long 

eetReadTimeOutO 

get read time out 

r.— 

boolean 

! 

setResultO 

long 

setTakeTimeOutO 


get take time out 

! tuplespace.core. 

setTransactionHandlerO 

Transaction 



79 




















O) 

c 

o 

getUpdateLeaseTirneO 

get update lease time 

long 

getWriteLeaseTimeO 

get write lease time 

void 

i 

InitTSBase(net.iini.SDace.JavaSDace soace. 

tuptespace.entries.SpaceActionHandler spaceAction, java.iang.String entrylD) | 

_ ___ _... 

protected void 

printfiava.Iana.Strina str) ! 

For debugging purposes 

void 

setlavaSoaceCnetiini.sDace.JavaSDace soace) 

set space 

void 

setReadTimeOutdona timeOut) 

set read time out 

void 

i 

{ 

setResultfboolean value) 

void 

setSpaceActionHandlerftuDlesDace.entries.SDaceActionHandler soaceAction) 

! 

set action listener 

< 

o 

a 

\ setTakeTimeOutflona timeOut) 

set take time out 

void 

f 

setT ransactionHandlerftuoiesDace.core.T ransaction trans) 

set action listener 

void 

| 

setUpdateLeascTimeflona leaseTime) 
set update lease time 

void 

I 

setWriteLcaseTimedona leaseTime) 1 

set write lease time i 


80 



















Package 


Class 


PREV CLASS NEXT CLASS 

SUMMARY: INNER 1 FIELD 1 CONSTR i METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD 1 CONSTR I METHOD 


TUPLESPACE.CORE 

CLASS TSBOOLEAN 

java.Iang.Object 


+~tuplespace.core.TSBase 


+—tuplespace.core.TSBoolean 


public class TSBoolean 
extends TSBase 

implements java.io.Serializable, SpaceEventResistration , TSConstants 
The TSBoolean class implements the methods for reading, writing, updating, notifying 
and retrieving EntryBoolean entry from space. Every EntryBoolean entry in the space is 
identified by an unique ED (entryED). A subclass that implements the 
SpaceActionHandler interface has to load during initialization if remote event notification 
is used. 

See Also: 

EntryBoolean, Serialized Form 

{Fields inherited from cl ass tuplespace.core.TSBase 

| entrvID . eventRegistration. notifVLeaseTime. readTitneOut . result , space . spaceAction . takeTimeOut . 
j transaction . updateLeaseTime , writeLeaseTime 

Constructor Summary 

?- - - ——— . 

{TSBoo|ean (net jini.space.JavaSpace space, 

Ituplespace.entries.SpaceActionHandler spaceAction, java.Iang.String entrylD) 
i Constructor for TSBoolean 


Method Summary 

1 

r-r 

- void! cleanSpacef) 

j j Remove all existing entries from space 




81 
















void 

cleanSDacelftuDlesDace.core. Transaction txnl 

Remove all existing entries from space 

boolean 

initTSBooieanfnet.iini.soace.JavaSDace space. 

tup!espace.entries.SpaceActionHandler spaceAction, java.Iang.String entrylD) 
initialize TSBoolean 

.. 1 

boolean 

readlfExistsO ) 

Reads an entry value j 

boolean 

readlfExistslflona timeOut) ! 

Reads an entry value 1 

boolean 

l 

readIfExists2(lona timeOut. tuDlesoace.core.Transaction txnl 

Reads an entry value j 

boolean 

i 

startEventO 

Start notificiation; remote event will be raised if any entry that 
matches the entry ED is added into the space. 

boolean 

startEventl (tuolesDace.entries.SDaceActionHandler spaceActionl 

Start notificiation; remote event will be raised if any entry that 
matches the entry ED is added into the space. 

boolean 

j 

startEvent2(tuDleSDace.entries.SoaceActionHandler spaceAction. long teasel 
Start notificiation; remote event will be raised if any entry that 
matches the entry ED is added into the space. 

1 boolean j 

\ 

startEvent3(tuDlesDace.entries.SoaceActionHandler spaceAction. long lease 
tupIespace.core.Transaction txn) 

Start notificiation; remote event will be raised if any entry that 
matches the entry ED is added into the space. 

boolean 

i 

! stopEventO 

Stop notification 

boolean 

i 

takelfExistsO 

Takes an entry value; entry will be removed from space 

boolean 

takel fExistsl (lo nq timeOutl 

Takes an entry value; entry will be removed from space 

boolean 

itakeIfExists2nonq timeOut. tuDlesoace.core.Transaction txnl 

Takes an entry value; entry will be removed from space 

i 

boolean 

i 

i 

transReadfionc timeOutl 

Reads an entry value with transaction 


82 













boolean 

■ 

i 

transTakedong timeOut) 

Takes an entry value with transaction; entry will be removed from 

space 

i 

boolean 

i 

. ' . | 

transUpdatefbooiean value, long lease) j 

Updates an existing entry value with transaction 

boolean 

$ 

j 

[ 

transWritefboolean value, long lease) j 

Writes entry value with transaction [ 

boolean 

updatel (boolean value) ! 

Updates an existing entry value j 

boolean | 

1 1 

update2{boolean value, long lease)j 

Updates an existing entry' value j 

f.......".. 

boolean 

uodate3(boolean value, long lease, tupiespace.core.Transaction txn) j 
Updates an existing entry value j 

j.—' | 

boolean 

writel (boolean value) 

Writes value to space 

boolean 

write2(boolean value, long lease) 

Writes value to space 

boolean 

write3fboolean value, long lease, tupiespace.core.Transaction txn) 

Writes value to space 


83 















Package 


Class 


Tree 


PREV CLASS NEXT CLASS 

SUMMARY: INNER ! FIELD I CONSTR 1 METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD I CONSTR I METHOD 


TUPLESPACE.CORE 

CLASS TSDOUBLE 

java.lang.Object 
*-tuplespace.core.TSBase 


+~tuplespace.core.TSDouble 


public class TSDouble 
extends TSBase 

implements java.io.Serializable, SpaceEventResistration . TSConstants 
The TSDouble class implements the methods for reading, writing, updating, notifying and 
retrieving EntryDouble entry from space. Every EntryDouble entry in the space is 
identified by a unique ED (entrylD). A subclass that implements the SpaceActionHandler 
interface has to load during initialization if remote event notification is used. 

See Also: 

EntryDouble, Serialized Form 


Fields inherited from class tuplespace.core.TSBase 

t -------*-—..'.—.. .. . . . . ....-........ .... 

l entrvID . eventRegistration. notifvLeaseTime. readTimeOut. result, space. spaceAction. takeTimeOut . 

{ transaction . updateLeaseTime . writeLeaseTime 

' " " "' . 


Constructor Summary 

TSDouble fnet.iini.space. JavaSpace space, 

i 

jtuplespace.entries.SpaceActionHandler spaceAction, javaJang.String entrylD) 
Constructor for TSDouble 


Method Summary i . ;' ;: ; 

void 

deanSpaceO I 


Remove all existing entries from space j 

void 

cleanSpaceKtuDlesDace.core.Transaction brrt'i i 


84 












r—-— 

j 

| 

Remove all existing entries from space 

boolean 

j 

■ 

I 

initTSDoublefnetiini. space. JavaSpace space, i 

tupiespace.entries.SpaceActionHandler spaceAction, java.lang.String entrylD) j 

initialize TSDouble 

double ; 

1 

readlfExistsO ! 

Reads an entry value 

double 

readlfExistsl (Iona timeOut) 

Reads an entry value j 

! 

double 

readIfExists2(lonq timeOut, tuplespace.core.Transaction txn) 

Reads an entry value 

boolean 

startEventO 

Start notificiation; remote event will be raised if any entry that 
matches the entry ID is added into the space. 

— 1 — ,,j •- - 

boolean 

startEventKtuplespace.entries.SpaceActionHandier spaceAction) 

Start notificiation; remote event will be raised if any entry that 
matches the entry ID is added into the space. 

—■■■ -- -“ ■ 

boolean 

startEvent2ftup!espace.entries.SpaceActionHandler spaceAction, long lease) 

Start notificiation; remote event will be raised if any entry that 
matches the entry ID is added into the space. 

boolean 

i 

1 

i 

1 : 

! startEvent3(tuplespace.entries.SpaceActionHandler spaceAction, long lease, 

i tuplespace.core.Transaction txn) ) 

Start notificiation; remote event will be raised if any entry that 
j matches the entry ID is added into the space. 

boolean 

i 3 

stopEventO 

Stop notification 

double 1 

! 1 

takelfExistsO 

Takes an entry value; entry will be removed from space 

■ double ! 

S ! 

takelfExistslflonq timeOut) 

Takes an entry value; entry will be removed from space 

?-- 

double : 

1 

takeIfExtsts2(lonq timeOut, tuplespace.core.Transaction txn) 1 

Takes an entry value; entry will be removed from space j 

?. 11,1 11 

j double ; 

transReadflona timeOut) 

Reads an entry value with transaction 

double 

transTakedong timeOut) 

Takes an entrv value with transaction: entrv will be removed from 


85 






















space 

boolean 

transUpdate(double value. Iona lease's 

Updates an existing entry value with transaction 

boolean 

transWritefdouble value. Iona lease’s 

Writes entry' value with transaction 

boolean 

updateHdouble value's 

Updates an existing entry value 

boolean 

s 

update2(double value. Iona lease’s 

Updates an existing entry value 

boolean 

update3(doub!e value, Iona lease, tuplespace.coreTransaction ton's 

Updates an existing entry value 

boolean 

writel (double value! 

Writes value to space 

boolean 

j 

wr!te2(double value. Iona lease! 

Writes value to space 

boolean 

i 

write3(doub!e value. Iona lease. tupIespace.core.Transaction txn! 

Writes value to space 


i 


86 







Package 


Class 


Tree 


PREV CLASS NEXT CLASS 

SUMMARY: INNER I FIELD I CONSTR I METHOD 


Index Help 

FRAMES NO FRAMES 

DETAIL: FIELD i CONSTR I METHOD 


TUPLESPACE.CORE 

CLASS TSHASH 


java.Iang.Object 


■i— tupiespace.core.TSBase 


+--tuplespace.core.TSHash 


public class TSHash 
extends TSBase 

implements java.io.Serializable, SpaceEventRegistration, TSConstants 
The TSHash class implements the methods for reading, writing, updating, notifying and 
retrieving EntryHash entry from space. Every EntryHash entry in the space is identified 
by an unique ED (entryED). A subclass that implements the SpaceActionHandler interface 
has to load during initialization if remote event notification is used. 

See Also: 

EntryHash, Serialized Form 

1 Fields inherited from class t upiespace.core.TSBase _ 

! entrvID . eventRegistration . notifvLeaseTinae . readTimeOut . result , space , space Action, takeTimeOut, 

I 

1 transaction , uodateLeaseTime . writeLeaseTime 

Constructor Summary 1 

1 TSHash(net.jini.space.JavaSpace space, tuplespace.entries.SpaceActionHandler spaceAction, 

java.iang.String entrylD) 
j Constructor for TSHash 


Method Summary 

void 

cleanSpaceO 

Remove all existing entries from space 

void 

! cleanSpacel(tuplespace.core.Transaction txn) 


87 












Remove all existing entries from space ) 

boolean 

j ciearContainerO 

I i 

boolean 

setBooleaniiava.lana.Strina id) 

java.util.HashMap 

getContainerf) 

i j 

i 

void 

setContainerfiava.util.HashMap map) 

j 

j double 

| 

: getDouble(iava.lana.Strina id) 1 

! 

i 

float 

getFloatnava.Iana.Strina id) 1 

.. i 

int 

setlnteseriiava.lana.Strina id) 

long 

* 

aetLongfiava.lana.Strina id) 

1 

java.lang.String j 

i i 

t s 

setStrineliava.iana.Strina id) 

j boolean j 

! I 

initTSHash(net.iini.SDace.JavaSpace space. 
tuplespace.entries.SpaceActionHandler spaceAction, 

| java.lang.String entrylD) 
initialize TSHash 

boolean j 

■ 1 

; 1 

readlfExIstsf) 

Read entry value 

boolean j 

i j 

readlfExistsldona timeOut) 

Read entry value 

boolean j 

readIfExists2(lonq timeOut. tupiespace.core.Transaction txn) 

Read entry value 

boolean 

removefiava.iana.Strina id) 

boolean { 

! 

1 

1 

1 

setBoolean(iava.lana.Strina id. boolean value) 1 


88 















boolean 

setDouble(iava.lanq.Strinq id, double value) 

| 

boolean 

setFloatCiava.Iang.Strinq id, float value) ! 

1 

boolean 

j 

setlnteeer(iava.lanq.String id, int value) 1 

| 

f 

boolean 

i 

setLonsdava.Ianq.String id, long value) i 

boolean 

setStrinafiava.lang.String id, iava.Iang.String content) 

boolean 

startEventO 

Start notificiation; remote event will be raised if any 
entry that matches the entry ED is added into the space. 

boolean 

! 

i 

1 

j 

startEventl (tuoiespace.entries.SpaceActionHandler spaceAction) 

Start notificiation; remote event will be raised if any 
entry that matches the entry ED is added into the space. 

boolean 

\ 

) 

j 

\ 

startEvent2(tuplesDace.entries.SpaceActionHandler spaceAction, 

long lease) 

Start notificiation; remote event will be raised if any 
entry that matches the entry ID is added into the space. 

boolean j 

! ^ 

j j 

j j 

startEvent3(tuplespace.entries.SpaceActionHandler spaceAction, 

long lease, tuplespace.core.Transaction txn) 

Start notificiation; remote event will be raised if any 
entry that matches the entry ED is added into the space. 

boolean j 

1 

stopEventO 

Stop notification 

1 -— 

boolean 

takelfExistsO 

Take entry value; entry will be removed from space 

boolean I 

! 1 

* j 

takelfExistslfionq timeOut) 

Take entry value; entry will be removed from space 

r ■■ - —"" - .j 

boolean 

i 

\ 1 

1 j 

takeIfExists2(ionq timeOut, tuplespace.core.Transaction txn) 

Take entry value; entry will be removed from space 

f j 

boolean 

transReadOonq timeOut) 

Reads an entry value with transaction 


89 


















boolean 

transTakedona timeOut) 

Takes an entry value with transaction; entry will be 
removed from space 

boolean 

j 

i 

transUpdatedona lease) 

Updates an existing entry value with transaction 

boolean 

] 

transWritedona lease) 

Writes entry value with transaction 

boolean 

updatert 

Updates an existing entry value j 

. boolean 

updateldona lease) 

Updates an existing entry value j 

■ boolean 

update2dona lease. tUDlesDace.core.Transaction txn) 

Updates an existing entry value 

i boolean 

i ; 

i 

write{) 

Writes value to space 

boolean 

\ 

writeldona lease) 

Writes value to space 

i boolean 

write2dona tease. tUDlesDace.core.Transaction txn) 

Writes value to space 


90 












APPENDIX B. JINI/SERVICES SETUP SCRIPT 


1 ^Starlfervicei i* 

. ,?njxi 

File 

' 

yVy* -*w *.-.v -.%%■ * wXy '-N'-W 

j LookupBrowser T 

ilaanager JavaSpace ftgerrtServfce \ t 

T Template ; ||t : 

Run m\D Webserver LookupService 

Java Command: 

•1 

Java Options: 

Hi 

If 

java 

.It 

— .. ; 

-cp 1 

• I 

• Sefe#J\M Options'* 

:_1\lib\iini-cor8.jar;h:yini1_1\lib\jini-ext.jar;h:'Uinil_1\libtsun-ut'ljar;h:\ 

Seciif ify Policy HJ$;! 

;-Djava.security.po[icv=bi:\jrnt1 _1 

Codebass : 

-Djava.rmi.server.codebase=http:tfMELPOMENE:8081/ 

•!;': Executable : : 

tuplespace.servicesAgentService 

L---—.... .—= 1 


tStartService 

*Kon Sep IS 17:00:03 EDT 2000 


service.list-RMID 

Webserver 


LookupService 
Lookup3rowser 
TxnManager \ 
JavaSpace \ 

AgentService 


\ 

\ 


\ 


\ 


# RKID 

# 

RKID.Xabell=RKID Command : 

RKID.label2-Options : 

RKID.optionl=rmid 

RKID. option2=- J~Dsun. nri. activation. exec?olicy\-none 


# Webserver 

t? 

Webserver.labe11=Java Command : 

Webserver.label2-Java Options : 

Webserver.label3-Executable Jar File : 
Webserver.1abel4-Fort : 

Webserver.1abe15=Document Area : 

Webserver.1abel6-Log Down1oacs : 

Webserver.optionl-j ava 
Webserver-option2= -jar 

Webserver.option3 =d:\\jini1JL \\1ib\\tools.j ar 
Webserver-option4 = -port S0S1 
Webserver.options^-dir d:\\jinil_l\\iib 
Webserver.option6= 


91 
























# 

# Reggie - Lookup Service 

# 

LookupService.label1=Java Command : 

LookupService.label2=Java Options : 

LookupService.label3 ~Se tup JVM Options : 

LookupService.label4=Executable Jar File : 

LookupService.label5=Codebase : 

LookupService.label6=Security Policy File : 

LookupService.label7=Log Directory : 

LookupService.label8=Groups : 

LookupService.label9=Server JVM : 

LookupService.labellO=Server JVM Arguments : 

LookupService.optionl=java 
LookupService.option2 = -j ar 

LookupService.option3=-Djava.security.policy=d:\\jinil_l\\policy\\policy.all 

LookupService.option4=d:\\jinil_l\\lib\\reggie.jar 

LookupService.option5=http://tiptop:8081/reggie-dl.jar 

LookupService.option6=d:\\jinil_l\\policy\\policy.all 

LookupService.option7=\\tmp\\reggie_log 

LookupService.option8=public 

LookupService.option9= 

LookupService.optionl0= 

# 

# Lookup Browser 

# 

LookupBrowser.label1=Java Command : 

LookupBrowser.label2=Java Options : 

LookupBrowser.label3=Jar File : 

LookupBrowser.label4=Security Policy File : 

LookupBrowser.label5=Codebase : 

LookupBrowser.label6=Lookup Browser : 

LookupBrowser.label7=Admin Mode : 

LookupBrowser.label8=Groups : 

LookupBrowser.optionl=j ava 
LookupBrowser.option2=-cp 

LookupBrowser .opt ion3=d: \\jinil_l WlibWj ini-examples .jar 

LookupBrowser. option4=-Dj ava. security .policy\=d: \\jinil_l\\example\\browser\\policy 
LookupBrowser.option5=-Dj ava.rmi .server.codebase\=http://tiptop:8081/jini-examples-dl.j ar 
LookupBrowser. option6=com. sun. j ini . example. browser. Browser 
LookupBrowser.option7= 

LookupBrowser.option8= 

# 

# Mahalo - TxnManager 

# 

TxnManager.labell=Java Command : 

TxnManager.label2=Java Options : 

TxnManager.label3=Setup JVM Options : 

TxnManager.label4=Executable Jar File : 

TxnManager.label5=Codebase : 

TxnManager.label6=Security Policy File : 

TxnManager.label7=Log Directory : 

TxnManager.label8=Groups and Locators : 

TxnManager.label9=Server JVM : 

TxnManager.label10=Server JVM Arguments : 

TxnManager.optionl=j ava 
TxnManager.option2=-j ar 
TxnManager.option3= 

TxnManager.option4 =d:\\jini1_1\\1ib\\mahalo.j ar 
TxnManager.option5=http://tiptop:8081/mahalo-dl.j ar 
TxnManager.option6=d:\\jinil_l\\policy\\policy.all 
TxnManager.option7=d:\\tmp\\mahalo_log 
TxnManager.option8=public 
TxnManager.option9= 


92 



TxnManager.optionlO= 

# 

# JavaSpace 

# 

JavaSpace.optionl=java 
J avaSpace.option2 = -j ar 

JavaSpace.option3 = -Dj ava.security.policy\=d:\\jinil_l\\policy\\policy- all 

JavaSpace.option4=-Dj ava.rmi.server.codebase\=http://tiptop:8081/outrigger-dl.jar 

JavaSpace. option5=-Dcom. sun. j ini . outrigger. spaceName=JavaSpaces 

JavaSpace.option6=d:\\jinil_l\\lib\\transient-outrigger-jar 

JavaSpace.option7=public 

JavaSpace.option8= 

JavaSpace.label1=Java Command : 

JavaSpace.Iabel2=Java Options : 

JavaSpace.label3=Java Security File : 

JavaSpace.label4=Codebase : 

JavaSpace.label5=JavaSpace Name : 

JavaSpace.label6=Executable Jar File : 

JavaSpace.label7^Groups : 

JavaSpace.label8=Locators : 


# 

# AgentService 

# 

AgentService.labell=Java Command : 

AgentService.label2=Java Options : 

AgentService.label3=Setup JVM Options : 

AgentService.labe!4=Security Policy File : 

AgentService.label5=Codebase : 

AgentService.label6=Executable : 

AgentService.optionl=j ava 
AgentService.option2=-cp 

AgentService.option3=D:\\Jinil_l\\lib\\jini-core.jar;D:\\Jinil_l\\lib\\jini~ 
ext.jar;D:\\Jinil_l\\lib\\sun-util.jar;d:\\ 

AgentService.option4=-Djava.security.policy=d:\\jinil_l\\policy\\policy.all 
#AgentService.option4=-Djava.rmi.server.codebase=http://tiptop:8081/ 

AgentService.option5=-Djava.rmi.server.codebase=http://tiptop:8081/ 
AgentService.option6=tuplespace.services.AgentService 

# 

# END 

# 


93 


THIS PAGE INTENTIONALLY LEF T BLANK 


94 



APPENDIX C. AGENT TEST BENCH LISTING 

A. JAVA VERSION 



1. JavaTestBench.java 

package tuplespace.core; 
import j&va.awt.*; 
impor t j ava. awt. event. *; 
import java.applet.*; 
import j avax.swing- *; 
import java.util.Vector; 
import com. thwt. layout. *; 

/** 

* The <code> J av&T esc Ben ch</code> class implements the GUT for testing 

* the agent interface. 

* 

* ©author Kin Boon Xwang 

* ©version 1.0, 01 October 2000 

*/ 

public class JavaTestBench extends JApplet { 
boolean isStancalone = false? 

String [ ] tupleTypes = { “STRINGS-BOOLEAN", "INTEGER", "FLOAT*', "LONG", "DOUB 
•QUEUE"/ "STACK* >; 

PerformActions perform; 

Vector vectorID « new Vector O; 

Vector vector Output ~ new Vector {); 

JPanel jPanel1 ~ new JPanel(); 

Smart Layout smart Layoutl = new SmartLayout O ; 

JButton cmdClose - new JButton{)? 

SmartLayout smart Layout 2 - new SmartLayout (); 

JLabel txtStatus - new JLabel(}; 


95 






















JPanel jPanel2 = new JPanel{); 

JLabel jLabelCl = new JLabel(); 

JLabel jLabelC2 = new JLabel(); 

JScrollPane listOutputScroll = new JScrollPane0; 
JButton cmdlnitSpace = new JButtonO; 

JButton cmdStopEvent = new JButtonO; 

JTextField txtID = new JTextField0; 

JList listID = new JListO; 

SmartLayout smartLayoutLeft = new SmartLayout O ; 
JTextField txtLookupURL = new JTextField(); 
JTextField txtTimeout » new JTextField0; 
JTextField txtLease - new JTextField O; 

JButton cmdRead = new JButton 0; 

JPanel jPanelTop = new JPanel O; 

JCheckBox checkTimeout = new JCheckBox{); 
JTextField txtLookupGroup = new JTextField {) 
JButton cmdTake = new JButtonO; 

JButton cmdTxnAbort = new JButtonO; 

JTextField txtSpaceNaine = new JTextField 0; 

JButton cmdClean - new JButtonO? 

JButton cmdClear = new JButtonO? 

JCheckBox checkLease = new JCheckBox(); 

JTextField txtlnput = new JTextField 0? 

SmartLayout smartLayoutMain = new SmartLayout(); 
SmartLayout smartLayoutRightl = new SmartLayout O ; 
JButton cmdTxnClose = new JButtonO; 

JPanel jPanelLeft = new JPanel(); 

SmartLayout smartLayoutLeftl = new SmartLayoutO; 
JButton cmdRefresh = new JButtonO ; 

SmartLayout smartLayoutRight = new SmartLayout(); 
JPanel jPanelRightl = new JPanel{); 

JButton cmdS tart Event = new JButtonO; 

JComboBox cbType = new JComboBox(tupleTypes); 
JLabel jLabelAO = new JLabel(); 

JLabel jLabelAl = new JLabel0; 

JScrollPane listIDScroll = new JScrollPane(); 
JLabel jLabelA2 = new JLabel(); 

JLabel jLabelA3 = new JLabelO; 

JLabel jLabelA4 = new JLabel(); 

JLabel jLabelA5 = new JLabelO; 

SmartLayout smartLayoutTop = new SmartLayout(); 
JTextField txtCodebase = new JTextField(); 

JLabel jLabelBO = new JLabel(); 

JLabel jLabelBl = new JLabel(); 

JLabel jLabelB3 = new JLabel(); 

JList listOutput = new JListO; 

JTextField txtTransaction = new JTextField(); 
JButton cmdPut = new JButtonO; 

JPanel jPanelMain = new JPanel(); 

JPanel jPanelLeftl = new JPanel(); 

JTextField txtSecurityPolicy - new JTextField(); 
JButton cmdRemove « new JButtonO; 

JPanel j PanelRight = new JPanel(); 

JButton cmdCreate = new JButtonO; 

JButton cmdTxnStart = new JButton(); 

JLabel jLabelCO = new JLabel(); 

JButton cmdSearch = new JButtonO; 

JButton cmdUpdate = new JButtonO; 

//Construct the applet 
public JavaTestBench () { 

} 

//Initialize the JavaTestBench 
public void initO { 
try { 

jblnit(); 

listID.setListData(vectorlD); 
listOutput.setListData{vectorOutput); 


96 






perform = new PerformActions {this) ; 

} 

catch(Exception e) { 
e.printStackTrace() ; 

} 


//Component initialization 
private void jblnit() throws Exception { 
this.setSize(new Dimension(518, 488)); 
jPanel1.setLayout{smartLayout1); 

cmdClose.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdClose_actionPerformed(e); 

} 

}) ? 

cmdClose.setText("Close"); 

cmdClose.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtStatus.setFont(new java.awt.Font("Dialog", 0, 11)); 
txtStatus.setBorder(BorderFactory.createLoweredBevelBorder()); 
j Panel2.setBorder(BorderFactory.createEtchedBorder()); 
jPanel2.setLayout(smartLayout2); 

jLabelCl.setFont(new java.awt.Font("SansSerif", 0, 10)); 
jLabelCl.setText("Transaction :*); 
j LabelC2.setText(* Input"); 

jLabelC2.setHorizontalTextPosition(SwingConstants.CENTER); 

jLabelC2.setFont(new java.awt.Font("SansSerif", 0, 10)); 

cmdlnitSpace.addActionListener(new j ava.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdInitSpace_actionPerformed(e); 

} 

})? 

cmdlnitSpace.setText{"Init Space"); 

cmdlnitSpace.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdlnitSpace.setMargin(new Insets(2, 2, 2, 2)); 
cmdStopEvent.setMargin(new Insets(2, 2, 2, 2)); 
cmdStopEvent.setEnabled(false); 

cmdStopEvent.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdStopEvent.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdStopEvent_actionPerformed(e); 

} 

>> ; 

cmdStopEvent.setText{"StopEvent"); 

txtID.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtID.setText("EntrylD"); 

listID.addMouseListener(new java.awt.event.MouseAdapter() { 

public void mouseClicked(MouseEvent e) { 
listID_mouseClicked(e); 

} 

}>? 

listID.setBorder(BorderFactory.createEtchedBorder()); 
listID.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtLookupURL.setText(""); 

txtLookupURL.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtTimeout.setText("3000"); 

txtTimeout.setHorizontalAlignment(SwingConstants.RIGHT); 
txtTimeout.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtLease. setFont (new java, awt .Font ("Dialog", 0, 10)),- 

txtLease.setText("60000") ; 

txtLease.setHorizontalAlignment(SwingConstants.RIGHT); 
cmdRead.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdRead_actionPerformed(e); 


97 



} 

}); 

cmdRead. setText ('’Read") ; 
cmdRead.setEnabled(false); 

cmdRead.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdRead.setMargin(new Insets(2, 2, 2, 2)); 
jPanelTop. setBorder (BorderFactory. createEtchedBorder ()) ? 
j PanelTop.setLayout(smartLayoutTop) 

checkTimeout.setFont(new java.awt.Font("SansSerif", 0, 10)); 
checkTimeout.setSelected(true); 
checkTimeout.setText("TimeOut"); 

txtLookupGroup.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtLookupGroup.setText(""); 
cmdTake.setText{"Take"); 

cmdTake.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed<ActionEvent e) { 
cmdTake_actionPerformed{e); 

} 

}); 

cmdTake.setEnabled{false); 

cmdTake.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdTake.setMargin(new Insets (2, 2, 2, 2)); 
cmdTxnAbort.setText("Abort"); 

cmdTxnAbort.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdTxnAbort_actionPerformed(e); 

} 

>); 

cmdTxnAbort.setEnabled(false) 

cmdTxnAbort.setFont(new j ava.awt.Font("SansSerif", 0, 10)); 
cmdTxnAbort.setMargin(new Insets(2, 2, 2, 2)); 
txtSpaceName.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtSpaceName.setText(""); 
cmdClean.setText("Clean Up"); 

cmdClean.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdClean_actionPerformed(e); 

} 

)); 

cmdClean.setEnabled(false); 

cmdClean.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdClean.setMargin(new Insets(2, 2, 2, 2)); 
cmdClear.setMargin(new Insets(2, 2, 2, 2)); 
cmdClear.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdClear.setText("Clear"); 

cmdClear.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdClear_actionPerformed(e); 

} 

}>; 

checkLease.setSelected(true); 
checkLease.setText{■Lease"); 

checkLease.setFont(new j ava.awt.Font("SansSerif", 0, 10)); 
txtlnput.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtlnput.setText("A simple message")? 
cmdTxnClose.setText("End"); 

cmdTxnClose.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdTxnClose_actionPerformed(e); 

} 

}); 

cmdTxnClose.setEnabled(false)? 

cmdTxnClose.setFont(new java.awt.Font{"SansSerif", 0, 10)); 
cmdTxnClose.setActionCommand{"Close"); 


98 



cmdTxnClose.setMargin(new Insets(2, 2, 2, 2)); 
jPanelLeft.setBorder(BorderFactory.createEtchedBorder()); 
jPanelLeft.setLayout(smartLayoutLeft); 
cmdRefresh.setText("Refresh"); 

cmdRefresh.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e} { 
cmdRefresh_actionPerformed(e); 

} 

}); 

cmdRefresh.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdRefresh.setMargin(new Insets(2, 2, 2, 2))? 

jPanelRightl.setBorder(BorderFactory.createLoweredBevelBorder()); 
j PanelRightl.setLayout(smartLayoutRightl); 
cmdStartEvent.setText("StartEvent"); 

cmdStartEvent.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdStartEvent_actionPerformed(e); 

} 

}); 

cmdStartEvent.setEnabled(false); 

cmdStartEvent.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdStartEvent.setMargin(new Insets(2, 2, 2, 2)); 
cbType.setFont(new java.awt.Font("Dialog", 1, 10)); 
cbType.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cbType_actionPerformed(e); 

> 

}>; 

jLabelA0.setText("Agent Setting"); 

jLabelA0.setFont(new java.awt.Font("Dialog", 1, 12)); 
jLabelAl.setFont(new java.awt.Font("SansSerif", 0, 10)); 
jLabelA1.setText("Security Policy")? 

jLabelA2.setFont(new java.awt.Font("SansSerif", 0, 10)); 
j LabelA2.setText("Space Name"); 

jLabelA3.setFont(new java.awt.Font("SansSerif", 0, 10)); 
jLabelA3.setText("Server Codebase"); 

jLabelA4.setFont(new java.awt.Font("SansSerif", 0, 10)); 
jLabelA4.setText("Lookup Group"); 

jLabelA5.setFont(new java.awt.Font("SansSerif", 0, 10)); 
jLabelA5.setText("Lookup URL"); 

txtCodebase.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtCodebase.setText(""); 

jLabelBO.setFont(new java.awt.Font("Dialog", 1, 12)); 
jLabelBO.setHorizontalAlignment(SwingConstants.CENTER); 
j LabelBO.setText("Parameters "); 
j LabelBl.setText("Type"); 

jLabelBl.setFont(new java.awt.Font("SansSerif", 0, 10)); 
jLabelB3.setText("ID"); 

jLabelB3.setFont(new java.awt.Font("SansSerif ", 0, 10)); 
jLabelB3.setHorizontalAlignment(SwingConstants.CENTER); 
listOutput.setBackground(Color.black); 

listOutput.setFont(new java.awt.Font{"Dialog", 0, 10)); 
listOutput.setForeground(Color.green); 

listOutput.setBorder(BorderFactory.createEtchedBorder()); 
txtTransaction.setText(""); 

txtTransaction.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdPut.setText(■Put"); 

cmdPut.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdPut_actionPerformed(e); 

) 

}); 

cmdPut.setEnabled(false)? 

cmdPut.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdPut.setMargin(new Insets(2, 2, 2, 2)); 


99 




jPanelMain.setLayout (smartLayoutMain) ; 

jPanelLeftl.setBorder(BorderFactory.createLoweredBevelBorder{)); 
jPanelLeftl.setLayout(smartLayoutLeftl); 

txtSecurityPolicy.setFont(new java.awt.Font("Dialog", 0, 10)); 
txtSecurityPolicy.setText(""); 
cmdRemove. setText (" Remove") ; 

cmdRemove.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdRemove_actionPerformed(e) ; 

} 

}); 

cmdRemove.setEnabled(false); 

cmdRemove.setFont(new java.awt.Font("SansSerif", 0, 10)),- 
cmdRemove.setMargin(new Insets(2, 2, 2, 2)); 
j PanelRight.setBorder(BorderFactory.createEtchedBorder()); 
j PanelRight.setLayout(smartLayoutRight); 
cmdCreate.setText("Create"); 

cmdCreate.addActionListener(new java.awt.event-ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdCreate_actionPerformed(e),- 

} 

}>; 

cmdCreate.setEnabled{false); 

cmdCreate.setFont(new j ava.awt.Font(*SansSerif", 0, 10)); 
cmdCreate.setMargin(new Insets (2, 2, 2, 2)); 
cmdTxnStart.setMargin(new Insets(2, 2, 2, 2))? 
cmdTxnStart.setBackground(new java.awt.Color(204, 204, 204)); 

cmdTxnStart.setEnabled(false); 
cmdTxnStart.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdTxnStart.setText("Start"); 

cmdTxnStart.addActionListener(new j ava.awt.event.ActionListener() { 
public void actionPerformed(ActionEvent e) { 
cmdTxnStart_actionPerformed(e); 

} 

>); 

jLabeICO.setText{"Space Window"); 

jLabelCO.setHorizontalAlignment(SwingConstants.CENTER); 
jLabe ICO.setFont(new java.awt.Font("Dialog", 1, 12)); 
cmdSearch.setMargin(new Insets(2, 2, 2, 2)); 

cmdSearch.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdSearch.addActionListener(new java.awt .event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdSearch_actionPerformed(e); 

> 

}) ; 

cmdSearch.setText("Search"); 

cmdUpdate.setMargin(new Insets(2, 2, 2, 2)); 

cmdUpdate.setEnabled(false); 

cmdUpdate.setFont(new java.awt.Font("SansSerif", 0, 10)); 
cmdUpdate.addActionListener(new java.awt.event.ActionListener() { 

public void actionPerformed(ActionEvent e) { 
cmdUpdate_actionPerformed(e); 

} 

}); 

cmdUpdate.setText("Update"); 

this.getContentPane().add(j Panel1, BorderLayout.CENTER); 
jPanell.add(jPanelMain, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 505), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 453), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 0), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 0))); 
jPanelMain.add(jPaneITop, new com. thwt.layout-LayoutConstraint{ 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 120), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 0), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 0), 


100 



new com. thwt. layout .EdgeAnchor (jPanelRight, Anchor.Right, Anchor. Same, 

Anchor.Right, 0))); 

jPaneITop.add(jLabelA2, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(jLabelA1, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0) , 

new com.thwt.layout.EdgeAnchor{jLabelAl, Anchor.Left, Anchor.Same, Anchor.Left, 

0) , 

new com. thwt .layout .EdgeAnchor {jLabelAl, Anchor .Width, Anchor. Same, Anchor .Width, 

0) , 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Height, Anchor.Same, 

Anchor.Height, 0)))? 

jPaneITop.add{jLabelA3, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(jLabelA2, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0), 

new com.thwt.layout.EdgeAnchor(jLabelA1, Anchor.Left, Anchor.Same, Anchor.Left, 

°) r 

new com.thwt.layout.EdgeAnchor(jLabelA1, Anchor.Width, Anchor.Same, Anchor.Width, 

0) , 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))) ; 

j PanelTop.add(j LabelA4, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(jLabelA3, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0), 

new com. thwt. layout. EdgeAnchor (jLabelAl, Anchor. Left, Anchor. Same, Anchor. Left, 


0 ) , 

new com. thwt. layout .EdgeAnchor (jLabelAl, Anchor .Width, Anchor. Same, Anchor .Width, 

0} , 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelTop-add(jLabelAS, new com. thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(jLabelA4, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0) ' 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Left, Anchor.Same, Anchor.Left, 

0) , 

new com. thwt .layout .EdgeAnchor (jLabelAl, Anchor .Width, Anchor. Same, Anchor .Width, 

0) , 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))>; 

j PanelTop.add(txtSecurityPolicy, new com.thwt.layout.LayoutConstraint( 
new com. thwt .layout .FixedDimensionAnchor (Anchor.Width, 280), 
new com. thwt .layout .FixedDimensionAnchor (Anchor. Height, 18), 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Right, Anchor.Right, Anchor.Left, 

0), 

new com.thwt.layout.EdgeAnchor(jLabelAl, Anchor.Top, Anchor.Same, Anchor.Top, 


0 ) ) ); 

j PanelTop. add {txtSpaceName, new com. thwt. layout. LayoutConstraint ( 

new com. thwt.layout.EdgeAnchor(jLabelA2, Anchor.Right, Anchor.Right, Anchor.Left, 


0) , 

new com. thwt. layout .EdgeAnchor (j Label A2, Anchor.Top, Anchor.Same, Anchor.Top, 0), 
new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Width, Anchor.Same, 

Anchor.Width, 0), 

new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

j PanelTop.add(txtCodebase, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(jLabelA3, Anchor.Right, Anchor.Right, Anchor.Left, 

0) , 

new com. thwt .layout. EdgeAnchor (j Label A3, Anchor. Top, Anchor. Same, Anchor. Top, 0), 
new com. thwt. layout. EdgeAnchor (txtSecurityPolicy, Anchor .Width, Anchor. Same, 

Anchor.Width, 0) , 

new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Height, Anchor.Same, 

Anchor.Height, 0) )) ; 

j PanelTop.add(txtLookupGroup, new com. thwt.layout.LayoutConstraint{ 

new com.thwt.layout.EdgeAnchor(jLabelA4, Anchor.Right, Anchor.Right, Anchor.Left, 

0) , 

new com. thwt .layout. EdgeAnchor (j Label A4, Anchor.Top, Anchor.Same, Anchor.Top, 0), 
new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Width, Anchor.Same, 

Anchor.Width, 0), 

new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 


101 



0 ) 


jPanelTop.add(txtLookupURL, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor{jLabelA5, Anchor.Right, Anchor.Right, Anchor.Left, 

new com.thwt.layout.EdgeAnchor(jLabelA5, Anchor.Top, Anchor.Same, Anchor.Top, 0), 
new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Width, Anchor.Same, 

Anchor.Width, 0), 

new com.thwt.layout.EdgeAnchor(txtSecurityPolicy, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelTop.add(cmdlnitSpace, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor.Width, 70), 
new com. thwt. layout .FixedDimensionAnchor (Anchor.Height, 24), 
new com. thwt. layout .ContainerAnchor (Anchor. Left, 426), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 85))); 
jPanelTop.add(jLabelA1, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor.Width, 110), 
new com. thwt. layout .FixedDimensionAnchor (Anchor. Height, 18), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 14), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 26))); 
jPanelTop. add (j Label A0, new com. thwt. layout. LayoutConstraint ( 
new com. thwt. layout .FixedDimensionAnchor (Anchor. Width, 110), 
new com. thwt. lay out .FixedDimensionAnchor (Anchor. Height, 16), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 217), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 1))); 
jPanelMain.add(jPanelLeft, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 175), 
new com. thwt. layout .ContainerAnchor (Anchor .Bottom, 0), 

new com. thwt.layout.EdgeAnchor(jPanelTop, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0), 

new com.thwt.layout.EdgeAnchor(jPanelTop, Anchor.Left, Anchor.Same, Anchor.Left, 

0))); 

jPanelLeft.add(checkTimeout, new com. thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(checkLease, Anchor.Bottom, Anchor.Below, 

Anchor.Top, 0), 

new com.thwt.layout.EdgeAnchor(checkLease, Anchor.Left, Anchor.Same, Anchor.Left, 

0) , 

new com.thwt.layout.EdgeAnchor(checkLease, Anchor.Width, Anchor.Same, 

Anchor.Width, 0), 

new com. thwt.layout.EdgeAnchor(checkLease, Anchor.Height, Anchor.Same, 

Anchor.Height, 0) ) ) ; 

jPanelLeft.add(txtLease, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 80), 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Height, 18), 

new com.thwt.layout.EdgeAnchor(checkLease, Anchor.Right, Anchor.Right, 

Anchor.Left, 0), 

new com.thwt.layout.EdgeAnchor(checkLease, Anchor.Top, Anchor.Same, Anchor.Top, 

0))); 

jPanelLeft.add{txtTimeout, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 80), 
new com.thwt .layout .FixedDimensionAnchor (Anchor. Height, 18), 

new com. thwt .layout .EdgeAnchor (checkTimeout, Anchor .Right, Anchor .Right, 
Anchor.Left, 0), 

new com. thwt. layout. EdgeAnchor (checkTimeout, Anchor.Top, Anchor. Same, Anchor.Top, 

0))); 

jPanelLeft.add(checkLease, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 70), 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Height, 18), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 13), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 28))); 
jPanelLeft.add(jLabelBO, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 110), 
new com. thwt. layout. FixedDimensionAnchor (Anchor. Height, 16), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 41), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 3))); 
jPanelLef t. add(cbType, new com. thwt. layout .LayoutConstraint ( 
new com. thwt .layout .FixedDimensionAnchor (Anchor. Width, 112), 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Height, 18), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 52), 
new com. thwt. layout. ContainerAnchor (Anchor. Top, 76))); 
jPanelLeft.add(jPanelLeftl, new com.thwt.layout.LayoutConstraint( 


102 


new com.thwt.layout.ContainerAnchor(Anchor.Left ; 5), 
new com. thwt.layout.ContainerAnchor(Anchor.Right/ 5), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 100), 
new com.thwt.layout.ContainerAnchor(Anchor.Bottom, 5)) ) ; 
jPanelLeftl.add(cmdRemove, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0 ) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Left, Anchor.Same, Anchor.Left, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Width, Anchor.Same, Anchor.Width, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelLeftl.add(cmdClean, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout.EdgeAnchor (cmdRemove, Anchor.Bottom, Anchor.Below, Anchor.Top, 10), 
new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Left, Anchor.Same, Anchor.Left, 0), 
new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Width, Anchor.Same, Anchor.Width, 0), 
new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Height, Anchor.Same, Anchor.Height, 
0)>); 

jPanelLeftl.add(cmdStartEvent, new com.thwt.layout.LayoutConstraint{ 

new com.thwt.layout.EdgeAnchor(cmdClean. Anchor.Bottom, Anchor.Below, Anchor.Top, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Left, Anchor.Same, Anchor.Left, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Width, Anchor.Same, Anchor.Width, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelLeftl.add(cmdRefresh, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.ContainerAnchor(Anchor.Bottom, 10), 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Left, Anchor.Same, Anchor.Left, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Width, Anchor.Same, Anchor.Width, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdCreate, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelLeftl.add(cmdCreate, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 60), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 5), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 41))); 
jPanelLeftl.add(jLabelB3, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 60), 
new com.thwt.layout.FixedDimensionAnchor(Anchor-Height, 16), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 13), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 11))); 
jPanelLeftl.add(txtID, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 80), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 18), 

new com. thwt.layout.EdgeAnchor(jLabelB3, Anchor.Right, Anchor.Right, Anchor.Left, 

0) , 

new com. thwt.layout.EdgeAnchor(jLabelB3, Anchor.Top, Anchor.Same, Anchor.Top, 

0))); 

jPanelLeftl.add(listIDScroll, new com.thwt.layout.LayoutConstraint{ 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 90), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 66), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 41), 
new com.thwt.layout.ContainerAnchor(Anchor.Bottom, 10))); 
jPanelLeftl.add(cmdStopEvent, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.EdgeAnchor(cmdStartEvent, Anchor.Bottom, Anchor.Below, Anchor.Top, 
0) , 

new com.thwt.layout.EdgeAnchor(cmdClean, Anchor.Left, Anchor.Same, Anchor.Left, 0), 
new com. thwt. layout. EdgeAnchor (cmdC lean, Anchor .Width, Anchor.Same, Anchor .Width, 0), 
new com.thwt.layout.EdgeAnchor(cmdClean, Anchor.Height, Anchor.Same, Anchor.Height, 0>)); 

jPanelLeftl.add(cmdSearch, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout. EdgeAnchor (cmdRefresh, Anchor.Top, Anchor. Above, Anchor .Bottom, 0), 
new com. thwt. layout. EdgeAnchor (cmdClean, Anchor.Left, Anchor.Same, Anchor.Left, 0), 
new com. thwt. layout .EdgeAnchor (cmdClean, Anchor .Width, Anchor.Same, Anchor .Width, 0), 
new com. thwt. layout. EdgeAnchor (cmdClean, Anchor.Height, Anchor. Same, Anchor.Height, 0)) ) ; 


103 



jPanelLeft.add(jLabelBl, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 70), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 16), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 19), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 77))); 
jPanelMain.add(jPanelRight, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 330), 

new com.thwt.layout.EdgeAnchor(j PanelLeft, Anchor.Right, Anchor.Right, 

Anchor.Left, 0), 

new com.thwt.layout.EdgeAnchor(jPanelTop, Anchor.Bottom, Anchor.Below, Anchor.Top, 

0), 

new com.thwt.layout.EdgeAnchor(jPanelLeft. Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelRight.add(cmdTxnAbort, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(cmdTxnStart. Anchor.Right, Anchor.Right, 

Anchor.Left, 0), 

new com.thwt.layout.EdgeAnchor(cmdTxnStart. Anchor.Top, Anchor.Same, Anchor.Top, 

0), 

new com.thwt.layout.EdgeAnchor(cmdTxnStart, Anchor.Width, Anchor.Same, 

Anchor.Width, 0), 

new com.thwt.layout.EdgeAnchor(cmdTxnStart, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanelRight.add(cmdTxnClose, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.EdgeAnchor(cmdTxnAbort, Anchor.Right, Anchor.Right, Anchor.Left, 0), 

new com.thwt.layout.EdgeAnchor(cmdTxnAbort, Anchor.Top, Anchor.Same, Anchor.Top, 

0), 

new com. thwt. layout. EdgeAnchor (cmdTxnAbort, Anchor .Width, Anchor. Same, 

Anchor .Width, 0) , 

new com. thwt. layout. Edge Anchor (cmdTxnAbort, Anchor .Height, Anchor. Same, 

Anchor.Height, 0) ) ) ; 

jPanelRight.add(jLabelCO, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor. Width, 85), 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Height, 17), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 108), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 2))) ; 
jPanelRight.add(txtTransaction, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout. FixedDimensionAnchor (Anchor. Width, 100), 
new com. thwt .layout .FixedDimensionAnchor (Anchor .Height, 18), 
new com. thwt. layout .ContainerAnchor (Anchor. Left, 68), 
new com. thwt. layout. ContainerAnchor (Anchor. Top, 26))); 
jPanelRight.add(jLabelCl, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout. FixedDimensionAnchor (Anchor .Width, 110), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 16), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 4), 
new com. thwt. layout. ContainerAnchor (Anchor.Top, 25))) ; 
j PanelRight.add(cmdTxnStart, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 50), 
new com. thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 169), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 24))) ; 
j PanelRight.add(j PanelRight1, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout .ContainerAnchor (Anchor. Left, 5), 
new com. thwt. layout. ContainerAnchor (Anchor .Right, 5) , 
new com. thwt. layout .ContainerAnchor (Anchor .Top, 51), 
new com. thwt. layout. ContainerAnchor (Anchor. Bottom, 5) ) ) ; 
jPanelRightl .add (cmdPut, new com. thwt. layout .LayoutConstraint ( 
new com. thwt. layout .FixedDimensionAnchor (Anchor. Width, 50), 
new com.thwt. layout. FixedDimensionAnchor (Anchor. Height, 20), 

new com.thwt.layout.EdgeAnchor(txtInput, Anchor.Right, Anchor.Right, Anchor.Left, 

0), 

new com.thwt.layout.EdgeAnchor(txtlnput. Anchor.Top, Anchor.Same, Anchor.Top, 

0))); 

jPanelRightl.add(jLabelC2, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout. FixedDimensionAnchor (Anchor .Width, 110), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 18), 
new com. thwt. layout. ContainerAnchor (Anchor .Top, 11))); 
jPanelRightl.add(txtlnput, new com.thwt.layout.LayoutConstraint( 
new com. thwt. layout. FixedDimensionAnchor (Anchor. Width, 130), 


104 




new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 55), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 13))); 
jPanelRightl.add(cmdRead, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 50), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 

new com.thwt.layout.EdgeAnchor(cmdTake, Anchor.Right, Anchor.Right, Anchor.Left, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdTake, Anchor.Top, Anchor.Same, Anchor.Top, 0)))? 
jPanelRightl.add(listOutputScroll, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 303), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 198), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 5), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 40))); 
jPanelRightl.add(cmdTake, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 50), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 240), 

new com.thwt.layout.EdgeAnchor(listOutputScroll, Anchor.Left, Anchor.Same, 

Anchor.Left, 0> ) ) ; 

jPanelRightl.add(cmdClear, new com.thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 50), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 20), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 258), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 239))); 
j PanelRightl.add(cmdUpdate, new com.thwt.layout.LayoutConstraint( 

new com.thwt.layout.EdgeAnchor(cmdPut, Anchor.Right, Anchor.Right, Anchor.Left, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdPut, Anchor.Top, Anchor.Same, Anchor.Top, 0), 
new com. thwt.layout.EdgeAnchor(cmdClear, Anchor.Width, Anchor.Same, Anchor.Width, 

0) , 

new com.thwt.layout.EdgeAnchor(cmdClear, Anchor.Height, Anchor.Same, 

Anchor.Height, 0))); 

jPanel1.add(jPanel2, new com.thwt.layout.LayoutConstraint( 

new com. thwt. layout. FixedDimensionAnchor (Anchor-Width, 505), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 31), 

new com.thwt.layout.ContainerAnchor(Anchor.Left, 0), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 453))); 
jPanel2.add(cmdClose, new com. thwt.layout.LayoutConstraint( 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Width, 79), 

new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 22), 
new com.thwt.layout.ContainerAnchor(Anchor.Right, 5), 

new com.thwt.layout.ContainerAnchor(Anchor.Top, 2))); 
jPanel2.add(txtStatus, new com.thwt.layout.LayoutConstraint( 

new com. thwt. layout .FixedDimensionAnchor (Anchor .Width, 413), 
new com.thwt.layout.FixedDimensionAnchor(Anchor.Height, 21), 
new com.thwt.layout.ContainerAnchor(Anchor.Left, 3), 
new com.thwt.layout.ContainerAnchor(Anchor.Top, 2) ) ) ; 
listOutputScroll.getviewport().add(listOutput, null); 
listIDScroll.getViewport().add(listID, null); 

} 

//Start the applet 
public void start() { 

} 

//Stop the applet 
public void stopO { 

} 

//Destroy the applet 
public void destroy() { 

} 

//Get Applet information 
public String getAppletlnfo() { 

return 11 Applet Information"; 


} 




//Get parameter info 

public String[] [j getParameterlnfo() { 
return null; 

} 

//Main method 

public static void main{String[] args) { 

Appletl applet = new JavaTestBenchO; 
applet.isStandalone = true; 

JFrame frame = new JFrame (); 

frame.setTitie{"Space Agent Test Bench"); 

frame.getContentPane().add{applet, BorderLayout.CENTER); 

applet.init(); 

applet.start{) ; 

frame.setSize(515,510) ; 

Dimension d = Toolkit.getDefaultToolkit().getScreenSize(); 

frame.setLocation((d.width - frame.getSize{).width) / 2, (d.height 

frame.getSize().height) / 2); 
frame.setVisible(true); 

} 

// static initializer for setting look & feel 
static { 
try { 

UIManager.setLookAndFeel( "com. sun.java.swing.plaf.windows.MetalLookAndFeel"); 
//UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); 
//UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName()); 

> 

catch (Exception e) {} 


void cmdTxnStart_actionPerformed(ActionEvent e) { 
cmdPut.setBackground(Color.red); 
cmdUpdate.setBackground(Color.red); 
cmdRead. setBackground (Color .red) ; 
cmdTake.setBackground(Color.red); 
cmdStartEvent.setBackground(Color.red); 
txtTransaction.setText("Running...”); 

txtStatus.setText(" Start Transaction Manager ->" + perform.startTransaction()); 

> 

void cmdTxnAbort_actionPerformed(ActionEvent e) { 
cmdPut.setBackground(new Color(204,204,204)); 
cmdUpdate.setBackground{new Color(204,204,204)); 
cmdRead.setBackground(new Color(204,204,204)) ; 
cmdTake.setBackground(new Color(204,204,204)); 
cmdStartEvent.setBackground(new Color(204,204/204)) ; 
txtTransaction.setText(""); 

txtStatus.setText(* Abort Transaction Manager ->" + perform.abortTransaetion()); 

} 

void cmdTxnClose_actionPerformed (ActionEvent e) { 
cmdPut.setBackground(new Color(204,204,204)); 
cmdUpdate.setBackground(new Color(204,204,204)); 
cmdRead.setBackground(new Color(204,204,204)); 
cmdTake.setBackground(new Color(204,204,204)); 
cmdStartEvent.setBackground(new Color(204,204,204)); 

txtTransaction. setText ('"') ; , 

txtStatus.setText(" Close Transaction Manager ->" + perform.closeTransaction()); 

} 

void cmdlnitSpace^actionPerformed(ActionEvent e) { 
perform.initSpace()? 

} 

void cmdCreate_actionPerformed( Act ionEvent e) { 

perform.createID((String) cbType.getSelectedItem()); 

} 

void cmdRemove_actionPer formed (Act ionEvent e) { 


106 




perform. reinovelD ( (String) cbType .getSelectedItern() ) ; 

} 

void cmdClean_actionPerformed(ActionEvent e) { 

perform.cleanSpace((String) cbType.getSelectedItem()); 

} 

void cmdStartEvent_actionPerformed(ActionEvent e) { 

perform.startEvent((String) cbType.getSelectedItern()); 

} 

void cmdStopEvent_actionPerformed(ActionEvent e) { 

perform.stopEvent((String) cbType.getSelectedltern()) ; 

} 

void cmdRefresh_actionPerformed(ActionEvent e) { 

perform.refreshListIDs((String) cbType.getSelectedltern()) 

} 


void cmdTake_actionPerformed(ActionEvent e) { 

perform.takeEntry((String) cbType.getSelectedltern()); 

} 

void cmdRead„actionPerformed(ActionEvent e) { 

perform.readEntry((String) cbType.getSelectedltern{)); 

> 

void cmdClear_actionPerformed(ActionEvent e) { 
perform.clearOutput()? 

} 

void cmdClose_actionPerformed(ActionEvent e) { 
perform.close(); 

System.exit(0); 

} 

void cmdPut_actionPerformed(ActionEvent e) { 

perform.putEntry((String) cbType.getSelectedltern()); 

} 


void listID_mouseClicked(MouseEvent e) { 
if (e.getClickCount() == 1) { 

int index = listID.locationToIndex(e.getPoint()); 
if(index != -1) 

perform.IDSelected(index); 


> 


void listID_mousePressed(MouseEvent e) { > 

void 1is11D_mouseRe1eased(MouseEvent e) { } 

void listID_mouseEntered(MouseEvent e) { } 

void listID_mouseExited(MouseEvent e) { } 


void cbType_actionPerformed(ActionEvent e) { 

JComboBox cb = (JComboBox) e. get Source () ,* 

perform.changeType( (String) cbType.getSelectedItem()); 

} 


void printClassName(Object obj) { 

System.out-printIn("The class of " + obj + 

* is " + obj.getClass().getName()); 


> 


void cmdSearch_actionPerformed(ActionEvent e) { 
perform.SearchTSClassIDs(); 

} 


void cmdUpdate_actionPerformed(ActionEvent e) { 

perform.updateEntry((String) cbType.getSelectedltern()); 

} 


107 




108 



2. PerformActions.java 

package tuplespace.core; 


import java.util.Date; 
import java.util.Vector; 
import java.lang.StringBuffer; 
import javax.swing.JOptionPane; 
import javax.swing.JScrollBar; 
import java.util.EventListener; 
import j ava.awt.event.*; 
import java.awt.Cursor; 


/** 

* The <code>PerformActions</code> class handle the events for 

* the GUI. 

* 

* @author Kin Boon Kwang 

* Aversion 1.0, 01 October 2000 
*/ 

public class PerformActions implements ActionListener{ 
private Appletl frame; 
private Agent agent; 

public PerformActions(Applet1 frame) { 
this.frame = frame; 
this.agent = new Agent(); 
this.agent.addActionListener(this); 
refreshAll(); 

} 

public void initSpace(){ 

frame.getGlassPane<).addMouseListener( new MouseAdapter() {}); 

frame .getGlassPane().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR)); 
frame.getGlassPane().setVisible(true); 

agent.setAgentSecurityPolicy(frame.txtSecurityPolicy.getText()); 
agent.setAgentSpaceName(frame.txtSpaceName.getText()); 
agent.setAgentServerCodebase(frame.txtCodebase.getText()); 
agent.setAgentLookupGroup(frame.txtLookupGroup.getText()); 
if(frame.txtLookupURL.getText().length() > 7) 

agent.setAgentLookupURL(frame.txtLookupURL.getText()); 

//agent.setAgentLookupURL(frame.txtLookupURL.getText()); 
if( agent.InitAgent(10000) ){ 

print (" Space Services Initialised.' 1 ); 
frame.cmdCreate.setEnabled(true) ; 
frame.cmdRefresh.setEnabled(true); 
frame. cmdRemove. setEnabled (true) ; 

}else{ 

print("Fail! to initialise services, timeout 20 secs"); 

} 

frame .getGlassPane().setVisible(false); 

} 

public void createlD(String type){ 

String tmpStr = frame.txtID.getText(); 

print ("Create * + type + " [ M + tmpStr+ *] 

agent.createlD(TSType2Int(type),tmpStr)); 
refreshListIDs(type); 
frame.cmdPut.setEnabled(true); 
frame.cmdUpdate.setEnabled{true); 
frame.cmdRead.setEnabled(true); 
frame.cmdTake.setEnabled(true); 
frame.cmdStartEvent.setEnabled(true); 
frame.cmdStopEvent.setEnabled(true); 
frame.cmdTxnAbort.setEnabled(true); 
frame.cmdTxnClose.setEnabled(true); 
frame.cmdTxnStart.setEnabled(true); 


109 




> 


public boolean startTransaction(){ 
return agent.startTransaction()? 

} 

public boolean closeTransaction(){ 
return agent.closeTransaction(); 

} 

public boolean abortTransaction{){ 
return agent.abortTransaction()? 

> 

public void close(){ 

agent.TerminateAgent()? 

} 

public void rexnovelD(String type) { 

String tmpStr = frame.txtID.getText(); 

print ("Remove "+ type + "[" + tmpStr+ *] » + 

agent. removelD (agent. getTSType (type) , tmpStr)); 
refreshListIDs(type); 

} 

public void refreshIDs(){ 

//print(" String Map Keys -> " + agent.getTSStringMapKeys()) ; 

//refreshListIDs(); 

} 

public void cleanSpace(String type){ 

String tmpStr = frame.txtID.getTextO; 

print ("Clean "+ type + "[" + tmpStr+ "] n + 

agent.cleanTSClass(TSType2lnt(type),tmpStr)); 

} 

boolean putEntry(String type) { 

if( type.conpareTo("BOOLEAN") == 0){ 

TSBoolean ts = (TSBoolean) agent.getTSObject( 

agent.TS_BOOLEAN,frame.txtID.getText() ) ; 
if(ts != null){ 
try{ 

boolean tmp = Boolean. valueOf (frame. txtlnput .getText ())-booleanValue () ; 
print("Write[* + frame.txtID.getText()+"] -> " + tmp + 

B + ts.write3(tmp, getLeaseTime(),agent.getTransaction())); 

}catch(Exception e){} 

} 

}else if( type.compareTo("INTEGER") == 0){ 

TSInteger ts = (TSInteger) agent.getTSObject( 

agent .TS_INTEGER, frame.txtID.getTextO ) ; 
if(ts != null){ 
try{ 

int tmp = Integer.valueOf(frame.txtInput.getText()).intValue(); 
print("Write["+ frame.txtID.getText()+"] -> M + tmp + 

" :* + ts.write3(tmp, getLeaseTime(),agent.getTransaction())); 

}catch(Exception e){} 

} 

> 

else if( type.compareTo{"FLOAT") == 0){ 

TSFloat ts = (TSFloat) agent .getTSObject ( agent .TS__FLOAT, frame. txtID. getText ()) ; 
if(ts != null){ 
try{ 

float tmp = Float.valueOf(frame.txtInput.getText()).floatValue(); 
print("Write["+ frame.txtID.getText()+"] -> " + tmp + 

" :" + ts.write3(tmp, getLeaseTime(),agent.getTransaction())); 

}catch(Exception e){} 

} 

} 


no 



else if( type.compareTo("LONG") == 0){ 

TSLong ts = (TSLong) agent.getTSObject{ agent.TS_LONG,frame.txtID.getText()); 
if(ts l = null){ 
try{ 

long tmp = Long. valueOf (frame, txt Input .getText {)). longValue (im¬ 
print ("Write["+ frame.txtID.getText()+"] -> * + tmp + 

" :" + ts.write3(tmp, getLeaseTime {),agent.getTransaction())); 

}catch(Exception e){} 

} 

} 

else if( type.compareTo("DOUBLE") == 0) £ 

TSDouble ts = (TSDouble) agent.getTSObject( agent.TS_DOUBLE,frame.txtID.getText(}); 
if(ts != null){ 
try { 

double tmp = Double.valueOf(frame.txtlnput.getText()).doubleValue{); 
print("Write["+ frame.txtID.getText()+") -> " + tmp + 

" + ts.write3(tmp, getLeaseTime(),agent.getTransaetion())); 

}catch(Exception e){} 

} 

} 

else if( type.compareTo("STRING") == 0){ 

Date time = new Date(); 

String tmpStr = frame.txtlnput.getText(); //+ " " + time.toGMTString(); 

TSString ts = (TSString) agent.getTSObject(agent.TS_STRING, 

frame.txtID.getText())? 

if(ts != null){ 

print("Write["+ frame.txtID.getText() + "] -> " + tmpStr + 

" : w + ts.write3(tmpStr, getLeaseTime(),agent.getTransaction())); 

} 

} 

else if( type.compareTo("QUEUE") == 0){ 

Date time = new Date(); 

String tmpStr = frame.txtlnput.getText{)+ " " + time.toGMTString(); 

TSQueue ts = (TSQueue) agent.getTSObject(agent.TS_QUEUE, frame.txtID.getText()); 
if(ts != null){ 

print ("Write [" + frame, txt ID. getText () + *'] -> " + tmpStr + " " + 

ts.writel(tmpStr))? 

} 

} 

else if( type.compareTo("STACK") == 0){ 

> 

else if( type.compareTo("LINKLIST") == 0){ 

> 

else if( type.compareTo("HASH") ==-0){ 

Date time = new Date(); 

TSHash tsHash = (TSHash) agent.getTSObject(agent.TS_HASH, 

frame.txtID.getText()); 

if(tsHash != null){ 

tsHash. setstring ("a", "String a " + time. toGMTString {)) 

tsHash.setlnteger{"b",1234); 

tsHash.setFloat("c",(float) 1234.1234); 

tsHash.setLong("d",123456789); 

tsHash.setDouble("e",123456789.123456789); 

tsHash.setBoolean("f",true); 

print("Write[frame.txtID.getText()+"3 ~> " + 

tsHash.writel(getLeaseTime())); 

> 


} 

return true; 


void updateEntry(String type) { 
if{ type.compareTo{"BOOLEAN") == 0){ 

TSBoolean ts = (TSBoolean) agent.getTSObject( 

agent -TS__BOOLEAN, frame. txtID. getText ()) ; 
if(ts != null){ 


in 



try{ 

boolean tmp = Boolean. valueOf (frame, txtlnput. getText ()) .boolean Value Im¬ 
print! "Update [" + frame.txtID.getText{)+"] -> " + tmp + 

n :" + ts.update3(tmp, getLeaseTime(),agent.getTransaction())); 

}catch(Exception e){} 

} 

}else if( type.compareTo("INTEGER") == 0){ 

TSInteger ts = (TSInteger) agent.getTSObject( 

agent.TS_INTEGER,frame.txtID.getText()),- 
if(ts != null){ 
try{ 

int tmp = Integer.valueOf{frame.txtInput.getText()).intValueO; 
print ("Update ["+ frame. txtID.getText ()+" ] -> " + trnp + 

" :" + ts .update3 {tmp, getLeaseTime () , agent. getransaction ())); 

}catch(Exception e){} 

} 

} 

else if( type.compareTo("FLOAT") == 0){ 

TSFloat ts = (TSFloat) agent.getTSObject( agent.TSJFLOAT,frame.txtID.getText())? 
if(ts != null){ 
try{ 

float tmp = Float.valueOf(frame.txtlnput.getText()).floatValue(); 
print("Update["+ frame.txtID.getText()+"] -> M + tmp + 

" : w + ts .update3 (tmp, getLeaseTime(),agent.getTransaction{))); 

}catch(Exception e){} 

> 

} 

else if( type.compareTo("LONG") == 0){ 

TSLong ts = (TSLong) agent.getTSObject( agent.TSJLONG,frame.txtID.getText{)); 
if{ts != null){ 
try{ 

long trrp = Long. valueOf ( frame. txt Input. getText () ) . longValue () ; 
print{"Update["+ frame.txtID.getText()+"] -> " + tmp + 

" + ts.update3(tmp, getLeaseTime(),agent.getTransaction())); 

}catch(Exception e){> 

} 

} 

else if( type.compareTo("DOUBLE") == 0){ 

TSDouble ts = (TSDouble) agent.getTSObject( agent.TS_DOUBLE,frame.txtID.getText()); 
if(ts !- null){ 
try { 

double tmp = Double.valueOf(frame.txtlnput.getText()).doubleValue(); 
print ("Update [" + frame. txtID.getText () + " 3 -> " + trrp + 

" + ts.update3(tmp, getLeaseTime(),agent.getTransaction()))7 

}catch(Exception e){> 

} 

} 

else if( type.compareTo("STRING") == 0){ 

Date time = new Date(); 

String tmpStr = frame. txtlnput. getText () ; //+ ,l M + time. toGMTString () ; 

TSString ts = (TSString) agent.getTSObject(agent.TS_J5TRING, 

frame.txtID.getText()); 

if (ts != null){ 

print("Update["+ frame.txtID.getText()+"] -> " + tmpStr + 

" =" + ts.update3(tmpStr, getLeaseTime(),agent.getTransaction())); 

} 

} 

else if{ type.compareTo{"QUEUE") == 0){ 

/*Date time = new Date(); 

String tmpStr = frame.txtlnput.getText{)+ * " + time.toGMTString()? 

TSQueue ts = (TSQueue) agent.getTSObject(agent.TS_QUEUE # frame.txtID.getText()); 
if(ts != null){ 

print ("Update["+ frame. txtID.getText ()+" ] -> " + tmpStr + " * + 

ts.updatel(tmpStr)); 

} */ 

} 

else if( type.compareTo("STACK") == 0){ 


112 



else if < type.compareTo("LINKLI ST") == 0){ 


} 

else if( type.compareTo("HASH") == 0){ 

Date time = new Date(); 

TSHash tsHash = (TSHash) agent .getTSObject (agent .TS__HASH, 

frame.txtID.getText()); 

if(tsHash != null){ 

tsHash.setStringCa","String a "+time.toGMTString()); 

tsHash.setlnteger("b",1234) ; 

tsHash.setFloat("c",(float) 1234.1234); 

tsHash.setLong("d",123456789) ; 

tsHash.setDouble("e",123456789.123456789) ; 

tsHash.setBoolean("f",true); 

print("Update["+ frame.txtID.getText()+"] -> " + 

tsHash.update2(getLeaseTime (),agent.getTransaction())); 

} 

} 

} 


boolean takeEntry(String type) { 
if( type.compareTo("BOOLEAN") == 0){ 

TSBoolean ts = (TSBoolean) agent.getTSObject( 

agent.TS_BOOLEAN,frame.txtID.getText()); 
if(ts != null){ 

print(•Take[■+ frame.txtID.getText()+"] -> " + 

ts.takeIfExists2(getTimeout(),agent.getTransaction()))? 

} 

> 

else if( type.compareTo("INTEGER") == 0){ 

TSInteger ts = (TSInteger) agent.getTSObject( 

agent.TS_INTEGER,frame.txtID.getText()); 
if(ts != null){ 

print("Take["+ frame.txtID.getText<)+"] ->"+ 

ts.takeIfExists2(getTimeout(),agent.getTransaction{))); 

} 

} 

else if( type.compareTo("FLOAT") == 0) { 

TSFloat ts = (TSFloat) agent.getTSObject( agent.TS_FLOAT,frame.txtID.getText()); 
if(ts != null){ 

print {"Take [ * + frame. txtID.getText ()+*'3 -> " + 

ts.takelfExists2(getTimeout(),agent.getTransaction())); 

} 

> 

else if( type.compareTo{"LONG") == 0){ 

TSLong ts = (TSLong) agent.getTSObject( agent.TS_LONG,frame.txtID.getText()); 
if{ts != null){ 

print("Take["+ frame.txtID.getText()+"3 -> " + 

ts.takeIfExists2(getTimeout(),agent.getTransaction()))? 

} 

} 

else if( type.compareTo("DOUBLE") « 0){ 

TSDouble ts = (TSDouble) agent.getTSObject( agent.TS_DOUBLE,frame.txtID.getText()); 
if(ts != null){ 

print("Take[*+ frame.txtID.getText()+"] -> " + 

ts.takelfExists2(getTimeout(),agent.getTransaction()))? 

} 

} 

else if( type.compareTo("STRING") == 0){ 

TSString ts = (TSString) agent.getTSObject{ agent.TS„STRING,frame.txtID.getText()); 
if(ts != null){ 

print("Take["+ frame.txtID.getText() + "] -> " 4 

ts.takeIfExists2(getTimeout(),agent.getTransaction())); 

} 

} 

else if( type.compareTo("QUEUE") == 0){ 


113 



TSQueue ts = (TSQueue) agent.getTSObject( agent.TS_QUEUE,frame.txtID.getText{)) ; 
if(ts != null){ 

print ("Take[ n + frame. txtID.getText ()+" ] -> * + ts.takeO); 

} 

} 

else if( type.compareTo("STACK") == 0){ 

} 

else if( type.compareTo("LINKLIST") == 0){ 


> 

else if( type.compareTo("HASH") == 0){ 

TSHash tsHash = (TSHash) agent.getTSObject(agent.TS^HASH, frame.txtID.getText()) 
if{tsHash != null){ 

print("Take["+ frame.txtID.getText()+ "3 -> " + tsHash.takelfExists() ) ; 


print("tsHash(a] 
print{"tsHash[b] 
print("tsHash[c] 
print("tsHash[d] 
print("tsHash[e] 
print("tsHash[f] 


String -> " + tsHash.getString("a")); 

Integer -> " + tsHash.getlnteger(*b")); 

Float ~> " + tsHash.getFloat("c")); 

Long -> " + tsHash.getLong("d")); 

Double -> " + tsHash.getDouble{"e“)); 

Boolean ~> * + tsHash.getBoolean("f")); 


} 

return true; 


boolean readEntry(String type) { 

if( type.compareTo("BOOLEAN") == 0){ 

TSBoolean ts = (TSBoolean) 

agent.TS_BOOLEAN,frame.txtID.getText()); 
if(ts != null){ 

print("Read["+ frame.txtID.getText() +" J 

ts.readIfExists2(getTimeout(),agent.getTransaction())); 

} 

} 

else if( type.compareTo("INTEGER") == 0){ 

TSInteger ts = (TSInteger) 

agent-TS_INTEGER, frame.txtID.getText()); 
if(ts != null){ 

print("Read("+ frame.txtID.getText()+"] 

ts.readIfExists2(getTimeout(),agent.getTransaction())); 

} 


agent.getTSObj ect( 


agent.getTSObj ec t( 


> 

else if{ type.compareTo("FLOAT") == 0){ 

TSFloat ts = (TSFloat) agent.getTSObject( agent.TS_FLOAT,frame.txtID.getText{)); 
if(ts != null){ 

print("Read[■+ frame.txtID.getText()+«] -> 

ts.readIfExists2(getTimeout(),agent.getTransaction()))? 

} 


else if( type.compareTo("LONG") == 0){ 

TSLong ts = (TSLong) agent.getTSObject( agent.TS_LONG,frame.txtID.getText()) ; 
if(ts != null)C 

print("Read["+ ‘ frame.txtID.getText()+"3 -> 

ts.readIfExists2(getTimeout(),agent.getTransaction())); 

> 

} 

else if( type.compareTo("DOUBLE") == 0){ 

TSDouble ts = (TSDouble) agent.getTSObject( agent.TS_DOUBLE,frame.txtID.getText()) ; 
if(ts != null){ 

print("Read["+ frame.txtID.getText()+"] -> 

ts.readIfExists2 (getTimeout (), agent .getTransaction ())) 

} 


} 

else if( type.compareTo{"STRING") == 0){ 

TSString ts = (TSString) agent.getTSObject( agent.TS_STRING,frame.txtID.getText()) ; 
if(ts != null){ 

print("Read["+ frame.txtID.getText()+"] -> 

ts. readlfExists2 (getTimeout (),agent.getTransaction ())) 


114 



} 

} 

else if( type.compareTo("QUEUE") == 0){ 

TSQueue ts = (TSQueue) agent.getTSObject( agent.TS_QUEUE,frame.txt ID. getText(})? 
if(ts != null){ 
ts.printQueue() ; 
long startlndex,endlndex; 
startlndex = ts.getStartlndex(); 
endlndex = ts.getEndlndex(); 
clearOutput{); 

print("\n *** Stack Contents *** \n"); 
for(long i = startlndex; i <= endlndex ; i++){ 
print{"["+i+"] "+ ts.readl(i) ); 

} 

> 

} 

else if( type.compareTo("STACK") == 0){ 

} 

else if( type.compareTo("LINKLIST■) == 0){ 


} 

else if( type.compareTo("HASH") == 0){ 

TSHash tsHash = (TSHash) agent.getTSObject(agent.TS_HASH, 
if(tsHash != null){ 

"Read["+ frame.txtID.getText()+"] -> " + tsHash.readlfExists()); 


frame.txtID.getText()) , 


print( 
print(' 
print(' 
print( 1 
print(' 
print(' 
print(' 


tsHash[a] String -> * + tsHash.getString("a")); 

tsHash[b] Integer -> * + tsHash.getlnteger{"b")}; 

tsHash[c] Float -> " + tsHash.getFloat("c")); 

tsHash[d] Long -> " + tsHash.getLong<"d")); 

tsHashte] Double -> " + tsHash.getDouble("e")); 

tsHash[f] Boolean -> • + tsHash.getBoolean{"f")); 


> 

return true; 


void startEvent(String type) { 

if( type.compareTo("BOOLEAN") == 0) { 

TSBoolean ts = (TSBoolean) 

agent.TS_BOOLEAN,frame.txtID.getText()); 
if(ts != null){ 

print("Notify["+ frame.txtID.getText()+"] 

ts.startEvent3(agent,getLeaseTime{),agent.getTransaction{)))? 
} 

} 

else if( type.compareTo{"INTEGER") == 0){ 

TSInteger ts = (TSInteger) 

agent.TS_INTEGER,frame.txtID.getText()); 
if(ts != null){ 

print{"Notify ["+ frame.txtID.getText() + "] 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction())); 

} 


agent.getTSObj ect{ 


+ 


agent.getTSObj ect( 


} 

else if{ type.compareTo("FLOAT") == 0){ 

TSFloat ts = (TSFloat) agent - getTSObject ( agent. TS__FLOAT, frame. txtID. getText () ) ; 
if(ts != null){ 

print("Notify["+ frame.txtID.getText()+"] -> " + 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction())); 

} 

} 

else if( type.compareTo("LONG”) == 0){ 

TSLong ts = (TSLong) agent.getTSObject( agent-TS_LONG,frame.txtID.getText()); 
if(ts != null){ 

print("Notify["+ frame.txtID.getText()+"] -> " + 

ts.startEvent3(agent,getLeaseTime() , agent.getTransaction())); 

} 

} 

else if( type.compareTo("DOUBLE") == 0){ 


115 




TSDouble ts = (TSDouble) agent.getTSObject( agent.TS_DOUBLE,frame.txtID.getText()); 
if(ts != null){ 

print("Notify["+ frame.txtID.getText()+"] -> 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction()) ) ? 

} 

} 

else if( type.compareTo("STRING") == 0){ 

TSString ts = (TSString) agent.getTSObject( agent.TS_STRING,frame.txtID.getText()); 
if(ts != null) 

print ("Notify ["+ frame.txtID.getText()+"] -> 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction())); 
else 

print("Notify!’’ + frame.txtID.getText()+"] -> Fail")? 


> 

else if( type.compareTo("QUEUE") == 0){ 

TSQueue ts = (TSQueue) agent.getTSObject( agent .TS..QUEUE, frame. txtID.getText ()) ; 
if(ts != null){ 

print("Notify["+ frame.txtID.getText()+") -> « 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction())); 

} 

} 

else if( type.compareTo("STACK") == 0){ 

TSStack ts = (TSStack) agent.getTSObject( agent.TS^STACK,frame.txtID.getText()); 
//if(ts != null){ 

// print("Notify["+ frame.txtID.getText()+■] -> 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction{))); 

//} 

} 

else if( type.compareTo("LINKLIST") == 0){ 

} 

else if( type.compareTo("HASH") == 0){ 

TSHash ts = (TSHash) agent.getTSObject( agent.TS_HASH,frame.txtID.getText()); 
if(ts != null){ 

print ("Notify ["+ frame.txtID.getText()+"] -> 

ts.startEvent3(agent,getLeaseTime(),agent.getTransaction())); 

} 

} 


void stopEvent(String type) { 

if( type.compareTo("BOOLEAN") == 0){ 

TSBoolean ts = (TSBoolean) agent.getTSObject( 

agent.TS_BOOLEAN,frame.txtID.getText()); 
if(ts != null){ 

print("Stop Notification["+ frame.txtID.getText()+"] -> • + ts.StopEvent{)); 

} if( type.compareTo("INTEGER") == 0){ 

TSInteger ts = (TSInteger) agent.getTSObject( 

agent.TS_INTEGER,frame.txtID.getText()); 
if(ts != null){ 

print("Stop Notification[■+ frame.txtID.getText()+■] -> « + ts.stopEvent()); 

} 

else if( type.compareTo("FLOAT") == 0){ 

TSFloat ts = (TSFloat) agent.getTSObject{ agent.TS_FLOAT,frame.txtID.getText()); 
if(ts != null){ 

print("Stop Notification["+ frame.txtID.getText()+"] -> " + ts.stopEvent()); 

> 

else if( type.compareTo("LONG") == 0){ 

TSLong ts = (TSLong) agent.getTSObject( agent.TS_LONG,frame.txtID.getText()); 
if(ts != null){ 

print("Stop Notification["+ frame.txtID.getText()+■] -> " + ts.stopEvent())? 

} 

else if( type.compareTo("DOUBLE") == 0){ 


116 



TSDouble ts = (TSDouble) agent.getTSObject( agent.TS_DOUBLE, frame.txtID.getText{)) 
if(ts != null){ 

print ("Stop Notification ["+ frame. txtID. getText 0 + ■ ] -> " + ts. stopEvent () ) ,* 

} 

} 

else if{ type.compareTo("STRING") == 0){ 

TSString ts = {TSString) agent.getTSObject( agent.TS_STRING,frame.txtID.getText()) 
if(ts != null){ 

print ("Stop Notification["+ frame. txtID. getText {)+" ] -> 11 + ts.stopEvent()); 

} 

} 

else if{ type.compareTo("QUEUE") == 0){ 

TSQueue ts = (TSQueue) agent.getTSObject( agent.TS_QUEUE,frame.txtID.getText()); 
if(ts != null){ 

print("Stop Notification["+ frame. txtID. getText ()+ M ] -> " + ts. stopEvent ()) 

} 

} 

else if( type.compareTo("STACK") == 0){ 

} 

else if( type.compareTo{"LINKLIST") == 0){ 


else if( type.compareTo("HASH") == 0){ 

TSHash ts = (TSHash) agent.getTSObject{ agent.TS_HASH,frame.txtID.getText()); 
if(ts != null){ 

print("Stop Notification["+ frame.txtID.getText<)+"3 -> " + ts.stopEvent{)); 

} 


} 

} 

public void changeType(String type){ 
refreshListIDs(type); 

if( type.compareTo("BOOLEAN") == 0){ 
frame.txtlnput.setText("TRUE"); 

} 

if( type.compareTo{"INTEGER") == 0){ 
frame.txtlnput.setText("12345")? 

> 

else if( type.compareTo("FLOAT") == 0){ 
frame.txtlnput.setText("12345.123456"); 

> 

else if{ type.compareTo("LONG") == 0){ 
frame.txtlnput.setText("1234567890")? 

} 

else if( type.compareTo("DOUBLE") == 0){ 

frame.txtlnput.setText("1234567890.123456789"); 

> 

else if( type.compareTo("STRING") == 0){ 
frame.txtlnput.setText("Hello agent!*); 

} 

else if( type.compareTo("QUEUE") == 0){ 

> 

else if( type.compareTo{"STACK") == 0){ 

} 

else if < type.compareTo("LINKLIST") == 0){ 

> 

else if( type.compareTo("HASH") == 0){ 

} 


frame.cmdPut.setEnabled(false); 
frame .cmdUpdate. setEnabled (false) 
frame.cmdRead. set Enabled (false) 


117 



frame.cmdTake.setEnabled(false); 
frame.cmdStartEvent.setEnabled{false); 
frame.cmdStopEvent.setEnabled(false); 
f rame. cmdTxn Abort. set Enabled! false) ; 
frame.cmdTxnClose.setEnabled(false); 
frame.cmdTxnStart.setEnabled(false); 


void IDSelected(int index){ 

frame.txtID.setText((String) frame.vectorlD.get(index)); 

frame.cmdPut.setEnabled(true); 

frame.cmdupdate.setEnabled(true); 

frame.cmdRead.setEnabled(true); 

frame.cmdTake.setEnabled(true); 

frame.cmdStartEvent.setEnabled(true)? 

frame.cmdStopEvent.setEnabled(true); 

frame.cmdTxnAbort.setEnabled(true); 

frame.cmdTxnClose.setEnabled(true); 

frame.cmdTxnStart.setEnabled(true); 


void refreshAll(){ 

frame.txtSecurityPolicy.setText(agent.getAgentSecurityPolicy()); 
frame.txtSpaceName.setText(agent.getAgentSpaceName()); 
frame.txtCodebase.setText(agent.getAgentServerCodebase()); 
frame.txtLookupGroup.setText(agent.getAgentLookupGroup())? 
frame.txtLookupURL.setText(agent.getAgentLookupURL()); 


void refreshListIDs(String type){ 
int startIndex, endlndex; 
frame.vectorlD.clear(); 

String tmpStr = agent.getTSClassIDs(TSType2Int(type))? 
if( tmpStr != null ){ 

tmpStr = tmpStr.concat(","); 
startIndex = 0; 

endlndex = tmpStr.indexOf(' # 1 ); 
while(endlndex > 0 ){ 

frame.vectorID.add(tmpStr.substring(startlndex,endlndex))? 

startlndex = endlndex + 1; 

endlndex = tmpStr.indexOf( 1 ,',startlndex); 

} 

> 

frame.listID.setListData(frame.vectorlD); 

} 

void clearOutput(){ 

frame.vectorOutput.clear(); 

frame.listOutput.setListData(frame.vectorOutput)? 

} 

void printStatus(String str){ 
frame.txtStatus.setText(str); 

//print(str); 

) 

void print(String str){ 

frame.vectorOutput.add(str); 

frame.listOutput.setListData{frame.vectorOutput); 

JScrollBar vbar = frame.listOutputScroll.getVerticalScrollBar {); 
vbar. setValue (vbar.getMaximum ()); 

//System.out.println(str); 


long getLeaseTime(){ 

Long tmpLong; 

if(frame.checkLease.isSelected() == true){ 


118 






time: 


try{ 

//System, out.printIn{" Lease 

Long.decode(frame.txtLease.getText() ) .longValue()); 

return Long.decode(frame.txtLease.getText()).longValue() ; 

}catch(Exception e){ 
e.printstackTrace(); 

> 

} 

//System, out .println (" Lease time:'' + Long. MAX_VALUE) ; 

return Long.MAX_VALUE; 

} 

long getTimeout(){ 

Long tmpLong; 

if{frame.checkLease.isSelected(} == true){ 
try{ 

//System, out .println (" Time Out:" 

Long.decode(frame.txtTimeout.getText()).longValue()) ; 

return Long.decode(frame.txtTimeout.getText()).longValue() ; 

}catch(Exception e){ 

} 

} 

return Long.MAX_VALUE; 


public void actionPerformed(ActionEvent e){ 

print("... Remote Event Type : [" + TSType2String(e.getID()) + 

e.getActionCommand() + "3 "); 

} 

private String TSType2String(int type){ 
switch (type) { 
case 5000: 

return "INTEGER"; 
case 5001: 

return "FLOAT"; 
case 5002: 

return "LONG"; 
case 5003: 

return "DOUBLE"; 
case 5004: 

return "STRING"; 
case 5005: 

return "QUEUE"; 
case 5006: 

return "STACK"; 
case 5007: 

return "LINKLIST"; 
case 5008: 

return "HASH"; 
case 5009: 

return "BOOLEAN" ; 
default: 

return "UNKNOWN"; 


} 

} 

private int TSType2Int(String type){ 
if{ type.compareTo("INTEGER") == 0) 
return agent.TS_INTEGER; 
else if( type.compareTo("FLOAT") == 0) 
return agent.TS_FLOAT; 
else if( type.compareTo("LONG") == 0) 
return agent.TS_LONG; 
else if( type.compareTo("DOUBLE") == 0) 
return agent.TS_DOUBLE; 
else if( type.compareTo("STRING") == 0) 
return agent.TS_STRING; 
else if( type.compareTo("QUEUE") == 0) 


"] ID:[" + 


119 



return agent.TS_QUEUE; 
else if( type.compareTo{"STACK") == 0) 
return agent.TS_STACK; 
else if( type.compareTo("LINKLIST") == 0) 
return agent.TS_LINKLIST; 
else if( type.compareTo("HASH”) == 0) 
return agent.TS_HASH; 
else if( type.compareTo("BOOLEAN") == 0) 
return agent.TS_BOOLEAN; 
else 

return 0; 


public void SearchTSClassIDs(){ 
long time; 
int i,j; 
int cc[]; 

cc = new int[500]; 

agent.createlD (agent.TS__STRING,"entrylD"); 

for{ j = 0; j < 500 ; j++){ 
cc[j] = 0; 

} 

for{ j = 0; j < 100 ; j++){ 

time = System, currentTimeMi 11 is () ; 
for( i = 0; i < 10 ; i++) 

{ 

TSString ts = (TSString) agent.getTSObject(agent.TS_STRING, "entrylD”); 

if(ts.writel("hello”)) 

{ 

if{ ts.takelfExists().length () > 0) 

{ 

//System, out. print In ( "Latency time -> 

System. currentTimeMillis{)); 

} 

} 

> 

int t = (int)((double)(System.currentTimeMillis() - time)/10.0); 

System.out.printIn( "Latency time -> " + t); 

cc[t]++; 

} 

for( j = 0; j < 500 ; j++){ 
if( cc[j] != 0 ){ 

System, out.println( j + " " + cc[j]); 

} 

} 

agent.removelD (agent.TS_STRING,"entrylD") ; 

} 

> 


120 



B. VISUAL BASIC VERSION 


ift. Space Agent Test Bench 


m 


Agent Setting 


f SecuntyPbfcju : 

| Space Name: 

] ServerCodebase: 
I Lookup Group : ; 
f LbokupURL -A'" 


[JavaSpaces 


d:\jni1 _1 \example\hook$\pQllcy. all 


http://tiptop:8Q8t /entries .jar 


public 


Rers&alsze 


Parameters Setting 


Space Memory 


-- - --.. ■ «-n - <■ ». ...■ ', , " ii "" M " .. '.:: '. 

!‘ Lease: ' rjlGGGG fnsec Transaction : {Not started yet Start [ Abort end ] 

I Timeout: I -[iCOOO mstsc 


Input : | A Simple Message 


Put Update | 


j Entry Type: [STRING J§ 


1 Br^O: 

Qeate 

|TSQueue 


Remove 

■l 

l l .j; 

Clean 

No% 

j StopNott 

i Refresh [ 


..tt 


ill 


fit 


Create I D[ T S Queue] -> I rue 
WfitefTSOueue] *>A Simple Message: False 
Create ID[ TSQueue] *> True 
WritefTSQueue] *>A Simple Message: True 
ReadfTSOueue] *>A Simple Message 
UpdatefTSQueue] *>A Simple Message: True 
Update[TSQueue] ->A Simple Message; Irus 
Update?! SQueue] ->A Simple Message; T'u£ 
UpdateffSQueue] *>A Simple Message: True 
Read[TSQueue] ->A Simple Message 
ReadITSQueue] ->A Simple Message 


Take 


Dear 


Dose*; 


1. VBTestBench-vb 

Option Explicit 
Private tra> As String 

Private Sub cbType_Click() 
Select Case cbType.Text 


Case "STRING* 



txtMsg.Text 

- 

* A Siirple Message* 

Case "INTEGER* 



txtMsg.Text 
Case "FLOAT* 


*1234* 

txtMsg-Text 
Case "LONG* 

= 

*1234.1234* 

txtMsg.Text 
Case "DOUBLE* 

= 

*123456789" 

txtMsg.Text 
Case * BOOLEAN* 

zz 

*123456789.12345678 

txtMsg.Text 

Select 

- 

"true* 


cxafiPut.Enabled - False 
cmdUpdate.Enabled - False 
cmdKeac.Enabled = False 
cnsdTake. Enabled = False 
cmcStartNotify.Enabled = False 
crdStopNocify. Enabled ~ False 
txnStart.Enabled = False 
txnAbort.Enabled « False 
txnClose.Enabled = False 

Call cradShoWID„Click 


121 






End Sub 


Private Sub cmdClear_Click{) 
ListOutput.Clear 
End Sub 

Private Sub cmdClose_Click() 
'Agentl.TerminateAgent 
Unload Me 
End Sub 


Private Sub cmdCreateID_Click() 

dump "Create ID[ " & txtID & "] -> " & Agentl.createID{Agentl.getTSType(cbType.Text), 
txtID) 

Call cmdShowID_Click 

ListID.ListIndex = ListID.ListCount - 1 
cmdPut.Enabled = True 
cmdUpdate.Enabled = True 
cmdRead.Enabled = True 
cmdTake.Enabled = True 
cmdStartNotify.Enabled = True 
cmdStopNotify.Enabled = True 
txnStart.Enabled = True 
txnAbort.Enabled = True 
txnClose.Enabled = True 
End Sub 

Private Sub cmdReinitialize_Click() 

Screen.MousePointer = vbHourglass 
If Agentl.InitAgent(5000) Then 
dump "Services Initialized!" 
cmdCreatelD.Enabled = True 
cmdShowID.Enabled = True 
cmdRemove ID. Enabled = True 

Else 

dump "Fail! to initialize services" 
cmdCreatelD.Enabled = False 
cmdShowID.Enabled = False 
cmdRemovelD.Enabled = False 
End If 

Screen.MousePointer = vbDefault 
End Sub 

Private Sub cmdRemoveID_Click() 

dump "Remove ID[" & txtID & "] -> " & Agentl.removelD(Agentl.getTSType(cbType.Text), 
txtID) 

Call cmdShowID_Click 

ListID.ListIndex = ListID.ListCount - 1 
End Sub 

Private Sub cmdShowID_Click() 

Dim tmp As String, tmpl As String 

trap a Agentl.getTSClassIDs(Agentl.getTSType(cbType.Text)) 

Dim startPos As Long 
Dim endPos As Long 
trip = Trim (tmp) & ", " 
startPos = 1 
ListID.Clear 

While startPos < Len(tmp) 

endPos = InStr(startPos, tmp, vbTextCompare) 

If endPos > 0 Then 

tmpl = LTrim(RTrim(Mid(tmp, startPos, endPos - startPos))) 

ListID.Addltem (tmpl) 

End If 

startPos = endPos + 1 


Wend 
End Sub 


122 



Private Sub cmdPut_Click{) 
Dim writeStr As String 
Dim ret As Boolean 


On Error Resume Next 
writeStr = txtMsg.Text{) 
ret = False 


Select Case cbType.Text 
Case "STRING" 

ret = Agentl.getTSObject(Agent1.getTSType(cbType.Text), 

txtID).write3(writeStr, getLeaseTime{), Agentl.getTransaction()) 

Case "INTEGER" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).write3(CInt(writeStr), getLeaseTime(), Agentl.getTransaction()) 

Case "FLOAT" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).write3(CDbl(writeStr), getLeaseTime(), Agentl.getTransaction()) 

Case "LONG" 

ret = Agentl.getTSObjecttAgentl.getTSType(cbType.Text), 

txtID).write3(CLng(writeStr), getLeaseTime 0, Agentl.getTransaction()) 

Case "DOUBLE" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).write3(CDbl(writeStr), getLeaseTime (), Agentl.getTransaction()) 

Case "BOOLEAN" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).write3(CBool(writeStr), getLeaseTime(), Agentl.getTransaction{)) 

End Select 


dump "Write[" & txtID & "] 
End Sub 


->" & writeStr & " : " & ret 


Private Sub cmdUpdate_Click() 

Dim writeStr As String 
Dim ret As Boolean 

On Error Resume Next 
writeStr = txtMsg.Text() 
ret = False 

Select Case cbType.Text 
Case "STRING" 

ret = Agentl.getTSObj ec t(Agentl.getTSType(cbType.Text), 

txtID).update3(writeStr, getLeaseTime(), Agentl.getTransaction()) 

Case "INTEGER" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).update3(CInt(writeStr), getLeaseTime(), Agentl.getTransaction{)) 

Case "FLOAT" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).update3(CDbl(writeStr), getLeaseTime (), Agentl.getTransaction()) 

Case "LONG" 

re t = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).update3(CLng(writeStr), getLeaseTime(), Agentl.getTransaction()) 

Case "DOUBLE" 

ret = Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).update3(CDbl(writeStr), getLeaseTime (), Agentl.getTransaction ()) 

Case "BOOLEAN” 

ret = Agentl. getTSObject (Agentl .getTSType (cbType. Text), 

txtID).update3(CBool(writeStr), getLeaseTime(), Agentl.getTransaction()) 

End Select 

dump "Update[" & txtID & ■] ->" & writeStr & " : " & ret 
End Sub 

Private Sub cmdTake_Click() 


123 



dump "Take[" & txtID & "] ->" & Agent 1. getTSObj ect {Agent 1. getTSType (cbType .Text) , 

txtID).takeIfExists2(getTimeOut{), Agentl.getTransaction()) 

End Sub 

Private Sub cmdRead_Click() 

dump "Read[" & txtID & "] ->" & Agentl.getTSObject(Agentl.getTSType(cbType.Text), 

txtID).readIfExists2(getTimeOut{), Agentl.getTransaction{)) 

End Sub 

Private Sub cmdStartNotify_Click() 

' On Error Resume Next 

dump "Notify ID[ M & txtID & "] -> " & 

Agentl.getTSObj ect(Agentl.getTSType(cbType.Text), 

txtID).startEvent3(Agentl.getActionHandler, getLeaseTime(), Agentl.getTransaction()) 

End Sub 

Private Sub cmdStopNotify_Click() 

On Error Resume Next 

dump "Notify ID[ “ & txtID & -] -> - & 

Agentl.getTSObject(Agentl.getTSType(cbType.Text), txtID).stopEventO 
End Sub 


' actionPerformed 


Private Sub Agentl_actionPerformed(ByVal ActionEventl As Object) 

dump ("... Remote Event[" & ActionEventl.getActionCommand{) & "] Type[" & 

ActionEventl.getID() & "]") 

End Sub 


Private Sub dump(str As String) 

ListOutput.Addltem (str) 

ListOutput.ListIndex = ListOutput.ListCount - 1 
End Sub 


• ★★★★★★★it**-*******************************-****************** 

1 Form Methods 

i*********************************************.*********.***** 

Private Sub Form_Load() 

’ txtSecurityPolicy = Agentl.getAgentSecurityPolicy 

txtSpaceName = Agentl.getAgentSpaceName 
txtLookupGroup = Agentl.getAgentLookupGroup 
’ txtServerCodebase = Agentl.getAgentServerCodebase 
' txtLookupURL = Agentl.getAgentLookupURL 

ListID.Clear 
End Sub 


Private Sub Form_Unload(Cancel As Integer) 
'Agentl.TerminateAgent 
End Sub 

Private Sub ListID_Click() 
txtID = ListID.Text 
cmdPut.Enabled = True 
cmdupdate.Enabled = True 
cmdRead.Enabled = True 
cmdTake.Enabled = True 
cmdStartNotify.Enabled = True 
cmdStopNotify.Enabled = True 
txnStart.Enabled = True 
txnAbort.Enabled = True 
txnClose.Enabled = True 
End Sub 


124 


1 User defined functions 


Private Function getLeaseTime() As Long 
If CheckLease.Value = 1 Then 

getLeaseTime = CLng(TxtLease.Text) 

Else 

getLeaseTime = &HFFFFFFFF 
End If 

End Function 

Private Function getTimeOut{) As Long 
If CheckTimeOut-Value = 1 Then 

getTimeOut = CLng(txtTimeOut.Text) 

Else 

getTimeOut = &HFFFFFFFF 
End If 

End Function 


' Transaction 


Private Sub txnAbort_Click() 

If Agentl.abortTransaction() = False Then 
txntext.Caption = "Error !" 

Else 

txntext-Caption = "Stopped" 

End If 

cmdPut.BackColor = &HCGE0FF 
cmdUpdate.BackColor = &HC0E0FF 
cmdTake.BackColor = &HC0E0FF 
cmdRead.BackColor = &HC0E0FF 
cmdStartNotify.BackColor = &H8000000F 
cmdStopNotify.BackColor = &H8000000F 
End Sub 

Private Sub txnClose_Click() 

If Agentl.closeTransaction() = False Then 
txntext.Caption = "Error !" 

Else 

txntext.Caption = "Stopped" 

End If 

cmdPut.BackColor = &HC0E0FF 
cmdUpdate.BackColor = &HC0E0FF 
cmdTake.BackColor = &HC0E0FF 
cmdRead.BackColor = &HC0E0FF 
cmdStartNotify.BackColor = &H8000000F 
cmdStopNotify.BackColor = &H8000000F 
End Sub 

Private Sub txnStart_Click() 

If Agentl.startTransaction() = False Then 
cmdPut-BackColor = &HC0E0FF 
cmdUpdate.BackColor = &HC0E0FF 
cmdTake.BackColor = &HC0E0FF 
cmdRead.BackColor = &HC0E0FF 
cmdStartNotify.BackColor = &H8000000F 
cmdStopNotify.BackColor = &H8000000F 
txntext.Caption = "Stopped" 

Else 

cmdPut.BackColor = vbRed 
cmdUpdate.BackColor = vbRed 
cmdTake.BackColor = vbRed 
cmdRead.BackColor = vbRed 
cmdStartNotify.BackColor = vbRed 









cmdStopNotify.BackColor = vbRed 
txntext.Caption = "Running ..." 
End If 
End Sub 


126 



C. C VERSION 



Auto _ ~Z1 □ I nfill 


[o] - close transaction 
Eq3 : quit 

[space3 : NEKT level 

Enter commandE type=STBXNG IB-ISString 3 —>i 
Enter Object IB ->TSString 

Level 1 Help ** 

K M X ' X"X' X KX-X- M-X KX KXX X X X X X - X - M X-X-K-X^ XXK»XK X KX KKKKX'^ ’ ^ 

Et3 : set object type 
Ill : set object ID 
Er] : remove object 
Ec3 z create object 
£13 - list all objects 
Es3 : start transaction 
£a3 : abort transaction 
[q 3 : close transaction 
Iq 3 : quit 

Ispace3 : NEXT level 

Enter commandE type:$XBING IB:T3$tring 3 ~>t 
103:INTEGER E13:FL0BT 123:LONG E33:DOUBLE £43:STRING 

C53:QUEUE E63:STftCK E?3:LINKLISI E83:HBSH C93:BOOLEAN 

Enter Object Type -> 


1. CtestBench.C 

#include <jni.h> 
tincluce <stddef-h> 
iinclude *agent.h* 

char level lHelp{ void); 
char level2Kelp{void}; 

void objType2Str(int oType, char* oTypeStr); 

int obj Type; 

char objTypeStr [20]; 

char objXD[20J; 

int tranStartedFlag; 
char processTSStiring {} ? 
char prccessTSInteger(}; 
char processTSFloat()? 
char processTSLong{}? 
char processTSDouble()? 
char processTSBoolean C}; 

int main{} 

C 

char ret; 
char buf[255]; 

trar.StartedFlag = FALSE; 
initJVKO ; 

if (l initAgent(}} goto destroy; 


ge tAgen t Se cu rit y?o1icv{buf); 

printfC" AgentSecurity?o1 icy ~> %s\n w ,buf); 

ge tAgen tSpaceNaite (btf}; 

printf (* AgentSpaceName ~> %s\n" ,buf); 

getAgentServerCodehaseCouf); 


127 













printf(" AgentServerCodebase -> %s\n",buf); 

getAgentLookupGroup(buf)? 

printf(" AgentLookupGroup -> %s\n",buf); 

getAgentLookupURL(buf); 

printf(" AgentLookupURL -> %s\n",buf); 

if(InitializeAgent(10000) == 1}{ 

createlD{TS_STRING/"EntrylD"); 
objType = 5004; 

objType2Str(objType,objTypestr); 
sprintf(objID,"EntrylD"); 

while(ret !- 'q') 

{ 


ret = levellHelp(); 
if( ret == 1 ') 

{ 

ret = level2Help(); 

} 


> 


} 


destroy: 

if {(*env)->ExceptionOccurred(env)) 
(*env)->ExceptionDescribe(env); 


(*jvm) ->DestroyJavaVM( jvm) ; 
return 0; 


char levellHelp(void) 

{ 

while(1) 

{ 

char inputChar[20]; 
char inputStr[20]; 

printf(" \n\t******************************************** ); 

printf(" \t** Level 1 Help **\n M ); 

printf( "\t***********************************************\n* ) ; 

printf (" \t [t] : set object type \n**) ; 

printf("\t[i] : set object ID\n"); 

printf("\t[r] : remove object\n"); 

printf("\t[c] : create object\n H ); 

printf("\t[1] : list all objects\n w ); 

//printf("\t[e] : clean object entriesXn"); 
printf ("\t [s] : start transaction^"); 
printf("\t[a] : abort transaction\n"); 
printf("\t[o] : close transaction\n"); 
printf("\tEq] : quit\n M ); 
printf{"\t[space] : NEXT level \n\n M ); 
if(tranStartedFlag) 

printf("\tTRANSACTION : Enter command[ type:%s ID:%s ] 

>",objTypeStr, objID); 

else 

printf("\tEnter command[ type:%s ID:%s ] ~>",objTypeStr, objID); 

gets(inputChar); 
switch(inputChar[0]) 

{ 

case 'Q': 
case 'q': 

return 'q 1 ? 
case ' ': 

return ' '? 


128 




case 't' : 


printf{”\t[0] :INTEGER [1] :FLOAT [2]:LONG E3]:DOUBLE 

[4]:STRING\n"); 

printf("\t[53:QUEUE [6]:STACK [7]:LINKLIST [8] :HASH 

[9] :BOOLEANVn"); 

printf("\tEnter Object Type ->"); 
gets(inputStr); 

objType = 5000+atoi(inputStr); 
objType2Str(objType,objTypeStr); 
break; 
case 'i 1 : 

printf("\tEnter Object ID 
gets(objID); 
break; 
case 'r 1 : 

printf{"\n##Result## -> Remove %s[%s] %s\n",objID, 

objTypeStr, (removeID(objType,objID) == 0 ? "Fail!" : "Ok!")); 

break; 
case *c': 

printf("\n##Result## -> Create %s[%s] %s\n M ,objID, 

objTypeStr, (createlD(objType,objID) == 0 ? "Fail!" : "Ok!")); 

break; 
case '1': 

break; 
case 'e': 

cleanTSClass(objType,objID); 
break; 
case 's': 

tranStartedFlag = startTransaetion(); 

printf("\n##Result## -> Start Transaction -> %s“, 

tranStartedFlag == TRUE ? "Ok!" : "Fail!”); 

break; 
case 'a': 

tranStartedFlag = FALSE; 

printf("\n##Result## -> Abort Transaction -> %s", 

abortTransactionO == TRUE ? "Ok!" : "Fail!"); 

break; 
case 'o': 

tranStartedFlag = FALSE; 

printf("\n##Result## -> Close Transaction -> %s", 

closeTransaetion() == TRUE ? "Ok!" : "Fail!"); 

break; 


char level2Help(void) 

{ 

char ret = '!'; 
while(ret != ' ') 

{ 


%s 3 


objID); 

switch (objType) 

{ 

129 


printf \n\t********************************************\n ); 

printf("\t** Level 2 Help **\n"); 

printf (*\t***********************************************\n") ? 

printf("\t[w] : write entry\n"); 

printf("\t[u] : update entry\n"); 

printfC\t[r] : read entry\n"); 

printf("\t[t] : take entry\n M ); 

printf("\t[space] : PREVIOUS level \n"); 

if(tranStartedFlag) 

printf("XtTRANSACTION : Enter command[ type:%s ID: 

>",objTypeStr, objID); 

else 

printf("\tEnter command[ type:%s ID:%s ] ->",objTypeStr, 



} 


case TS^INTEGER : 

ret = processTSInteger{) ; 
break; 

case TS_FLOAT : 

ret = processTSFloat{); 
break; 

case TS__LONG : 

ret = processTSLong(); 
break; 

case TS_DOUBLE : 

ret = processTSDouble(); 
break; 

case TS_STRING : 

ret = processTSString(); 
break; 

case TS_QUEUE : 
break; 

case TS_STACK : 
break; 

case TS_LINKLIST : 
break; 

case TS_HASH : 

break; 

case TS_BOOLEAN : 

ret = processTSBoolean(); 
break; 

default: 

break; 


} 

return ret; 


char processTSString() 

{ 

char inputChar[20]; 
char inputStr[20]; 
char outputStr[255]? 
int ret; 

gets(inputChar); 
switch(inputChar[0]) 
{ 


case 'w 1 : 

printf("\tEnter String 
gets(inputStr); 
if(tranStartedFlag) 

ret = TSStringTransWrite(objID,inputStr,100000); 

else 

ret = TSStringWritel(objID,inputStr); 
printf("\n##Result## -> Write %s[%s] %s : %s\n",objID / 

objTypeStr,inputStr, ret == TRUE ? "Ok!" : "Fail!*); 
break; 
case 'u': 

printf (" \tEnter String ->•') ; 
gets(inputStr); 
if(tranStartedFlag) 

ret = TSStringTransUpdate(objID,inputStr,100000); 

else 

ret = TSStringUpdatel(objID,inputStr); 
printf ( ,r \n##Result## -> Update %s[%s] %s : %s\n",objID, 

objTypestr,inputStr, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case 1 r 1 : 

if(tranStartedFlag) 

TSStringTransRead(objID,output Str,100000); 

else 


130 



TSStringReadl(objID,outputStr)? 
printf("\n##Result## -> Read %s[%s] 

objTypeStr,outputStr); 

break; 
case 't': 

if(tranStartedFlag) 

TSStringTransTake{objID,outputStr,100000); 

else 

TSStringTakel(objID,outputStr); 
printf{"\n##Result## -> Take %s[%s] 

objTypeStr,outputStr); 

break; 
case * ': 

return ' '; 


%s\n",objID, 


%s\n",objID, 


} 

return 1 !'; 


} 


char processTSInteger() 

{ 

char inputChar[20]; 
char inputStr[20]; 
int ret, value; 
gets(inputChar); 
switch(inputChar[0]) 

{ 

case 'w': 

printf("\tEnter Integer value ->"); 
value = atoi(gets(inputStr)); 
if(tranStartedFlag) 

ret = TSIntegerTransWrite(objID,value,100000); 

else 

ret = TSIntegerWritel(objID,value); 
printf("\n##Result## -> Write %s[%s] %d : %s\n M ,objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case 'u': 

printf("\tEnter Integer ->•); 
value = atoi(gets(inputStr)); 
if(tranStartedFlag) 

ret = TSIntegerTransUpdate(objID,value,100000)? 

else 

ret = TSIntegerUpdatel(objID,value); 
printf("\n##Result## -> Update %s[%s] %d : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case 'r': 

if(tranStartedFlag) 

value = TSIntegerTransRead(objID,100000); 

else 

value » TSIntegerReadl(objID); 

printf("\n##Result## -> Read %s[%s] %d\n",objID, 

obj Type Str, value) ; 

break; 
case 't 1 : 

if(tranStartedFlag) 

value = TSIntegerTransTake(objID,100000); 

else 

value = TSIntegerTakel(objID); 

printf("\n##Result## -> Take %s[%s] %d\n",objID, 

objTypeStr,value) ; 

break ,- 
case ' ': 

return ' '; 


131 



} 

return '!'; 


char processTSFloat () 

{ 

char inputChar[20]? 
char inputStr[20]; 
int ret; 
float value; 
gets(inputChar); 
switch(inputChar[0]) 
{ 


case ' w* : 

printf(*\tEnter Float value ->"}; 

//value = (float) atof(gets(inputStr)}; 
scanf("%f",value); 
if(tranStartedFlag) 

ret = TSFloatTransWrite(objID,value,100000); 

else 

ret = TSFloatWritel(objID,value) ; 

printf("\n##Result## -> Write %s[%s] %f : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case 'u*: 

printf("\tEnter Float -> M ); 

value = (float) atof(gets(inputStr)); 

if(tranStartedFlag) 

ret = TSFloatTransUpdate(objID,value,100000); 

else 

ret = TSFloatUpdatel(objID,value) ; 
printf("\n##Result## -> Update %s[%s] %f : %s\n",objID, 

objTypeStr,value, ret == TRUE ? H 0k!" : "Fail!"); 
break; 
case 'r': 

if(tranStartedFlag) 

value = TSFloatTransRead(objID,100000); 

else 

value = TSFloatReadl(objID); 

printf("\n##Result## -> Read %s[%s] %f\n M ,objID, 

obj TypeStr, value) ; 

break; 
case 't': 

if(tranStartedFlag) 

value = TSFloatTransTake(objID,100000) ; 

else 

value = TSFloatTakel(objID); 

printf{"\n##Result## -> Take %s(%s] %f\n M ,objID, 

obj TypeStr, value) ; 

break; 
case ' ': 

return ' '; 

} 

return '!*; 


} 


char processTSLong() 

{ 

char inputChar[20]; 
char inputStr[20]; 
int ret; 
long value; 
gets(inputChar); 
switch(inputChar[0]) 
{ 


132 



case 'w': 

printf("\tEnter Long value ->"); 
value = atol(gets(inputStr)}; 
if<tranStartedFlag) 

ret = TSLongTransWrite(objID,value,100000); 

else 

ret = TSLongWritel(objID,value); 

printf("\n##Result## -> Write %s[%s] %d : %s\n",objID, 

objTypeStr, value, ret == TRUE ? "Ok!” : "Fail!"); 
break; 
case 'u': 

printf("\tEnter Long ->"); 
value = atol(gets(inputStr)); 
if(tranStartedFlag) 

ret = TSLongTransUpdate(objID,value,100000); 

else 

ret = TSLongUpdatel(objID,value); 

printf("\n##Result## -> Update %s[%s] %d : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case * r': 

if{tranStartedFlag) 

value = TSLongTransRead(obj ID,100000); 

else 

value = TSLongReadl(objID); 

printf("\n##Result## -> Read %s[%s] %d\n",objID, 

objTypeStr,value) ; 

break; 
case 1 t'; 

if(tranStartedFlag) 

value = TSLongTransTake(objID,100000); 

else 

value = TSLongTakel(objID); 

printf(”\n##Result## -> Take %s[%s) %d\n",objID, 

objTypeStr,value) ; 

break; 
case ' ': 

return 1 1 ; 

} 

return '! 1 ; 


char processTSDouble() 

{ 

char inputChar[20]; 
char inputStr(20]; 
int ret; 
double value; 
gets(inputChar); 
switch(inputChar[0]) 
{ 


case 'w': 

printf("\tEnter Double value ->"); 
value = atof(gets(inputStr)); 
if(tranStartedFlag) 

ret = TSDoubleTransWrite(objID,value,100000); 

else 

ret = TSDoubleWritel(objID,value); 

printf("\n##Result## -> Write %s[%s] %f : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case 'u*: 

printf{"\tEnter Double ->■); 
value = atof(gets(inputStr)}; 
if(tranStartedFlag) 


133 



ret = TSDoubleTransUpdate(objID,value,100000); 

else 

ret = TSDoubleUpdatel (objID, value) ,- 
printf("\n##Result## -> Update %s[%s] %f : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break? 
case 'r': 

if(tranStartedFlag) 

value = TSDoubleTransRead(objID, 100000) ,- 

else 

value = TSDoubleReadl(objID); 

printf("\n##Result## -> Read %s[%s] %f\n",objID, 

objTypeStr,value); 

break; 
case 't’: 

if(tranStartedFlag) 

value = TSDoubleTransTake(objID,100000); 

else 

value = TSDoubleTakel(objID); 

printf(”\n##Result## -> Take %s[%s] %f\n",objID, 

objTypeStr,value) ; 

break; 
case ' '; 

return ’ '; 

} 

return '!*; 


char processTSBoolean() 

{ 

char inputChar[203; 
char inputStr[20]? 
int ret, value; 
gets(inputChar); 
switch(inputChar[0]) 
{ 


case 'w*: 

printf("\tEnter Boolean value ->*); 
value = atoi(gets(inputStr)); 
if(tranStartedFlag) 

ret = TSBooleanTransWrite(objID,value,100000); 

else 

ret = TSBooleanWritel(objID,value); 
printf("\n##Result## -> Write %s[%s] %d : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!")? 
break; 
case 1 u': 

printf("\tEnter Boolean ->"); 
value = atoi(gets(inputStr)); 
if(tranStartedFlag) 

ret = TSBooleanTransUpdate(objID,value,100000)? 

else 

ret = TSBooleanUpdatel(objID,value); 
printf("\n##Result## -> Update %s(%s] %d : %s\n",objID, 

objTypeStr,value, ret == TRUE ? "Ok!" : "Fail!"); 
break; 
case ’r': 

if(tranStartedFlag) 

value = TSBooleanTransRead(objID,100000); 

else 

value = TSBooleanReadl(objID)? 

printf("\n##Result## -> Read %s[%s] %d\n",objID, 

obj Type Str, value) ; 

break; 
case 1 1 *: 

if(tranStartedFlag) 


134 



value = TSBooleanTransTake(objID,100000)? 

else 

value = TSBooleanTakel{objID)? 

printf("\n##Result## -> Take %s[%s] %d\n M ,objID, 

objTypeStr,value); 

break; 
case ' ': 

return ’ '? 

} 

return '!'; 


void objType2Str(int oType, char* oTypeStr) 

{ 

switch (oType) 

{ 

case TS_INTEGER : 

sprintf(OTypeStr, "INTEGER"); 
break; 

case TS_FLOAT : 

sprint f{oTypeStr, "FLOAT"); 
break; 

case TS_LONG : 

sprintf(oTypeStr, "LONG"); 
break; 

case TS_D0UBLE : 

sprintf(oTypeStr, "DOUBLE"); 
break; 

case TS_STRING : 

sprintf(oTypeStr, "STRING"); 
break; 

case TS_QUEUE : 

sprint f (oTypeStr, " QUEUE") ,- 
break; 

case TS_STACK : 

sprintf(oTypeStr, "STACK"); 
break; 

case TS_LINKLIST : 

sprintf(oTypeStr, "LINKLIST")? 
break; 

case TS__HASH : 

sprintf(oTypeStr, "HASH"); 
break; 

case TS^BOOLEAN : 

sprintf(oTypeStr, "BOOLEAN"); 
break; 

default: 

sprintf(OTypeStr, "STRING"); 
break ,- 

} 

} 


135 




THIS PAGE INTENTIONALLY LEFT BLANK 



APPENDIX D. AGENT WRAPPER LISTING 


1. AGENT.H 

#ifndef _AGENT_H_ 

#define _AGENT_H_ 

tdefine PATH_SEPARATOR /* define it to be 1 on Solaris */ 

//#define USER_CLASSPATH M d:/Tuplespace/Jni/Invoke/Debug/" /* where Prog.class is */ 
#define USER_CLASSPATH "d:\V' /* where Prog.class is */ 

#define TRUE 1 
#define FALSE 0 

#define TS_INTEGER 5000 
#define TS_FL0AT 5001 
#define TS_LONG 5002 
#define TS_DOUBLE 5003 
#define TS_STRING 5004 
#define TS_QUEUE 5005 
#define TS_STACK 5006 
#define TS_LINKLIST 5007 
#define TS_HASH 5008 
#define TS_BOOLEAN 5009 


//****************************************************** 

//********★*****★*************************************** 

// Global Variables 

//****************★************************************* 

JavaVM * jvm; 

JNIEnv *env; 

jclass agentClass; // Agent class; 

jobject agentObject; // Agent object; 

jmethodlD jlnitializeAgent, jTerminateAgent; 

// Java space parameters methods 

jmethodlD jSetAgentSecurityPolicy,jGetAgentSecurityPolicy; 
jmethodlD jSetAgentSpaceName,jGetAgentSpaceName; 
jmethodlD jSetAgentServerCodebase,jGetAgentServerCodebase; 
jmethodlD j SetAgentLookupGroup,j GetAgentLookupGroup; 
jmethodlD j SetAgentLookupURL,j GetAgentLookupURL; 

// Tuple methods 

jmethodlD jCreateID,jRemovelD,jCleanTSClass,jGetTSObject; 

jmethodlD jStartTransaction, jGetransaction, jlsTransactionStarted; 

jmethodlD jAbortTransaction, jCloseTransaction, jUpdateTransaetionHandle; 

// TSInteger 

jmethodlD jTSIntegerWritel,jTSIntegerWrite2,jTSIntegerUpdatel,jTSIntegerUpdate2; 
jmethodlD jTSIntegerReadl,jTSIntegerRead2,jTSlntegerTakel,jTSIntegerTake2; 
jmethodlD 

jTSIntegerTransWrite,jTSIntegerTransUpdate,jTSIntegerTransRead,jTSIntegerTransTake; 

// TSFloat 

jmethodlD jTSFloatWritel,jTSFloatWrite2,jTSFloatUpdatel,jTSFloatUpdate2; 
jmethodlD jTSFloatReadl,jTSFloatRead2,jTSFloatTakel,jTSFloatTake2; 

jmethodlD jTSFloatTransWrite,jTSFloatTransUpdate,jTSFloatTransRead,jTSFloatTransTake; 

// TSLong 

jmethodlD jTSLongWritel,jTSLongWrite2,jTSLongUpdatel,jTSLongUpdate2; 
jmethodlD jTSLongReadl,jTSLongRead2,jTSLongTakel,jTSLongTake2; 

jmethodlD jTSLongTransWrite, jTSLongTransUpdate, jTSLongTransRead, jTSLongTransTake; 

// TSDouble 

jmethodlD jTSDoubleWritel, jTSDoubleWrite2, jTSDoubleUpdatel, jTSDoubleUpdate2 ; 
jmethodlD jTSDoubleReadl,jTSDoubleRead2,jTSDoubleTakel,jTSDoubleTake2; 

jmethodlD jTSDoubleTransWrite, jTSDoubleTransUpdate, jTSDoubleTransRead, jTSDoubleTransTake 

137 



// TSString 

jmethodID jTSStringWritel,jTSStringWrite2,jTSStringUpdatel,jTSStringUpdate2; 
jmethodID jTSStringReadl # jTSStringRead2, jTSStringTakel,jTSStringTake2; 

jmethodID jTSStringTransWrite, jTSStringTransUpdate, jTSStringTransRead, jTSStringTransTake; 
// TSHash 

jmethodID jTSHashWritel,jTSHashWrite2,jTSHashUpdatel,jTSHashUpdate2; 
jmethodID jTSHashReadl,jTSHashRead2, jTSHashTakel,jTSHashTake2; 

jmethodID jTSHashTransWrite,jTSHashTransUpdate,jTSHashTransRead,jTSHashTransTake; 

// TSBoolean 

jmethodID jTSBooleanWritel,jTSBooleanWrite2,jTSBooleanUpdatel,jTSBooleanUpdate2; 
jmethodID jTSBooleanReadl,jTSBooleanRead2,jTSBooleanTakel,jTSBooleanTake2; 
jmethodID 

jTSBooleanTransWrite,jTSBooleanTransUpdate,jTSBooleanTransRead,jTSBooleanTransTake; 


//★*********************************************^****** 

// Agent setting 

//*************************************************★**** 

void init JVM (void) ? 

int initAgent (void) ; 

int initMethods (void) ; 

void logError(char* str); 

// Java space parameters methods 
void setAgentSecurityPolicy(char* buf); 
void getAgentSecurityPolicy(char* buf); 
void setAgentSpaceName (char* buf)? 
void getAgentSpaceName(char* buf); 
void setAgentServerCodebase(char* buf); 
void getAgentServerCodebase(char* buf); 
void setAgentLookupGroup(char* buf); 
void getAgentLookupGroup(char* buf); 
void setAgentLookupURL(char* buf); 
void getAgentLookupURL(char* buf); 

int createlD(int classType, char* objectID)? 

int removelD(int classType, char* objectID); 

int cleanTSClass(int classType, char* objectID); 

jobject getTSObject(int classType, char* objectID); 

int startTransactionO ; 

jobject getTransaction(); 

int isTransactionStarted(); 

int abortTransaction(); 

int closeTransaction(); 

int updateTransactionHandle(int classType, char* objectID); 


// TSInteger 

int TSIntegerWritel( char* objectID,int value); 

int TSIntegerWrite2( char* objectID,int value, long lease); 

int TSIntegerUpdatel( char* objectID,int value); 

int TSIntegerUpdate2( char* objectID,int value, long lease); 

int TSIntegerReadl( char* objectID); 

int TSIntegerRead2 ( char* objectID, long timeout); 

int TSIntegerTakel( char* objectID); 

int TSIntegerTake2( char* objectID, long timeout); 

int TSIntegerTransWrite( char* objectID,int value, long lease); 

int TSIntegerTransUpdate( char* objectID,int value, long lease); 

int TSIntegerTransRead( char* objectID, long timeout); 

int TSIntegerTransTake{ char* objectID, long timeout); 

// TSFloat 

int TSFloatWritel( char* objectID,float value); 

int TSFloatWrite2( char* objectID,float value, long lease); 

int TSFloatUpdatel( char* objectID,float value); 

int TSFloatXJpdate2 ( char* objectID, float value, long lease); 


138 



float TSFloatReadl( char* objectID); 

float TSFloatRead2( char* objectID, long timeout); 

float TSFloatTakel( char* objectID); 

float TSFloatTake2( char* objectID, long timeout); 

int TSFloatTransWrite( char* objectID,float value, long lease); 

int TSFloatTransUpdate( char* objectID,float value, long lease); 

float TSFloatTransRead{ char* objectID, long timeout); 

float TSFloatTransTake( char* objectID, long timeout); 

// TSLong 

int TSLongWritel( char* objectID,long value); 

int TSLongWrite2( char* objectID,long value, long lease); 

int TSLongUpdatel{ char* objectID,long value); 

int TSLongUpdate2{ char* objectID,long value, long lease); 

long TSLongReadl( char* objectID); 

long TSLongRead2( char* objectID, long timeout); 

long TSLongTakel( char* objectID); 

long TSLongTake2( char* objectID, long timeout); 

int TSLongTransWrite( char* objectID,long value, long lease); 

int TSLongTransUpdate { char* objectID, long value, long lease) ,- 

long TSLongTransRead( char* objectID, long timeout); 

long TSLongTransTake( char* objectID, long timeout); 

II TSDouble 

int TSDoubleWritel( char* objectID,double value); 

int TSDoubleWrite2( char* objectID,double value, long lease); 

int TSDoubleUpdatel( char* objectID,double value); 

int TSDoubleUpdate2( char* objectID,double value, long lease); 

double TSDoubleReadl( char* objectID); 

double TSDoubleRead2{ char* objectID, long timeout); 

double TSDoubleTakel( char* objectID); 

double TSDoubleTake2( char* objectID, long timeout); 

int TSDoubleTransWrite( char* objectID,double value, long lease); 

int TSDoubleTransUpdate( char* objectID,double value, long lease) 

double TSDoubleTransRead( char* objectID, long timeout); 

double TSDoubleTransTake( char* objectID, long timeout); 

II TSBoolean 

int TSBooleanWritel( char* objectID,int value); 

int TSBooleanWrite2( char* objectID,int value, long lease); 

int TSBooleanUpdatel( char* objectID,int value); 

int TSBooleanUpdate2( char* objectID,int value, long lease); 

int TSBooleanReadl( char* objectID); 

int TSBooleanRead2( char* objectID, long timeout); 

int TSBooleanTakel ( char* objectID) ,- 

int TSBooleanTake2( char* objectID, long timeout); 

int TSBooleanTransWrite( char* objectID,int value, long lease); 

int TSBooleanTransUpdate( char* objectID,int value, long lease); 

int TSBooleanTransRead( char* objectID, long timeout); 

int TSBooleanTransTake( char* objectID, long timeout); 

// TSHash 

int TSHashWritel( char* objectID); 

int TSHashWrite2( char* objectID, long lease); 

int TSHashUpdatel{ char* objectID); 

int TSHashUpdate2{ char* objectID, long lease); 

int TSHashReadl( char* objectID); 

int TSHashRead2( char* objectID, long timeout); 

int TSHashTakel( char* objectID); 

int TSHashTake2( char* objectID, long timeout); 

int TSHashTransWrite( char* objectID, long lease); 

int TSHashTransUpdate{ char* objectID, long lease); 

int TSHashTransRead( char* objectID, long timeout); 

int TSHashTransTake( char* objectID, long timeout); 


//TSString 

int TSStringWritel( char* objectID,char* inputstr); 

int TSStringWrite2( char* objectID,char* inputstr, long lease); 


139 



int TSStringUpdatel( char* objectID,char* inputStr); 

int TSStringUpdate2( char* objectID,char* inputStr, long lease); 

void TSStringReadl( char* objectID,char* outputBuf); 

void TSStringRead2( char* objectID,char* outputBuf, long timeout); 

void TSStringTakel( char* objectID,char* outputBuf); 

void TSStringTake2( char* objectID,char* outputBuf, long timeout); 

int TSStringTransWrite( char* objectID,char* inputStr, long lease) ,- 

int TSStringTransUpdate( char* objectID,char* inputStr, long lease); 

void TSStringTransRead( char* objectID,char* outputBuf, long timeout); 

void TSStringTransTake( char* objectID,char* outputBuf, long timeout); 

#endif /* _AGENT_H_ */ 


140 



2 . 


AGENT.C 

#include <jni.h> 
tinclude <stddef.h> 
#include "agent.h" 


y/***************************************************************** 

// Initialize Java Virtual Machine 
//***************************************************************** 
void initJVM(void) 

{ 

JavaVMInitArgs vm_args; 

JavaVMOption options[1]; 
jint jvmStatus; 

// - 

// Initialize JVM 

options[0].optionstring = "-Djava.class.path=" USER_CLASSPATH; 
vm_args.version = 0x00010002; 
vm_args.options = options; 
vm_args.nOptions = 1; 

vm_args.ignoreUnrecognized = JNI_TRUE; 

jvmStatus = JNI_CreateJavaVM (&jvm, (void**) &env, &vm_args); 
if (jvmStatus < 0) 

{ 

fprintf(stderr, "Can't create Java VM\n"); 
exit(0)? 

> 

If - 

} 

//*****************★*********************************************** 
// Initialize Agent 

//**********************************★****************************** 
int initAgent(void) 

{ 


//- 

Il Initialize Java Class 
jmethodID constructor; 

agentClass = (*env)->FindClass(env, "tuplespace.core.Agent"); 
if (agentClass == 0) 

return FALSE; 

constructor = (*env)->GetMethodID(env, agentClass, "<init>","()V"); 
agentObject = (*env) ->NewObject (env, agentClass, constructor) ; 
if (agentObject == 0) 
return FALSE; 

logError("init Agent OkJ\n"); 

if(I initMethods()) 
return FALSE; 

return TRUE; 

//- 


int initMethods (void) 

{ 

jclass tsClass; 

//- 

// Get method handles of Java Program 

jlnitializeAgent = (*env)->GetMethodID(env, agentClass, "InitAgent", H (J)Z rt ); 
jTerminateAgent = (*env)->GetMethodID(env, agentClass, "TerminateAgent", "OV" 
if (’jlnitializeAgent || !jTerminateAgent) return FALSE; 


141 








agentClass, 


j SetAgentSecurityPolicy = (*env)->GetMethodID(env, 

" setAgentSecurityPolicy", " (L java/I ang/String;) V"} ? 

jGetAgentSecurityPolicy = (*env) ->GetMethodID(env, agentClass, 

"getAgentSecurityPolicy", "()Ljava/lang/String;"); 

if (!jGetAgentSecurityPolicy || !jSetAgentSecurityPolicy) return FALSE; 

j SetAgentSpaceName = {*env)->GetMethodID(env, agentClass, "setAgentSpaceName", 
"(Ljava/lang/String;)V"); 

jGetAgentSpaceName = (*env)->GetMethodID (env, agentClass, "getAgentSpaceName", 
"()Ljava/lang/String;"); 

if {!jGetAgentSpaceMame || ‘ j SetAgentSpaceName) return FALSE; 

j SetAgentServerCodebase = {*env)->GetMethodID(env, agentClass, 

"setAgentServerCodebase", "(Ljava/lang/String;)V M ); 

j GetAgentServerCodebase = (*env)->GetMethodID(env, agentClass, 

"getAgentServerCodebase", "{)Ljava/lang/String;"); 

if (! j GetAgentServerCodebase || ! j SetAgentServerCodebase) return FALSE,- 

jSetAgentLookupGroup = (*env)->GetMethodID(env, agentClass, "setAgentLookupGroup", 
"(Ljava/lang/String;)V"); 

jGetAgentLookupGroup = (*env)->GetMethodID(env, agentClass, "getAgentLookupGroup", 
" 0 Ljava/lang/String;") ,* 

if (!jGetAgentLookupGroup || !jSetAgentLookupGroup) return FALSE; 

j SetAgentLookupURL = (*env)->GetMethodID(env, agentClass, M setAgentLookupURL", 
"(Ljava/lang/String;)V"); 

j GetAgentLookupURL = (*env)->GetMethodID(env, agentClass, "getAgentLookupURL", 
"()Ljava/lang/String;■); 

if (!jGetAgentLookupURL || !jSetAgentLookupURL) return FALSE; 

j StartTransaction = (*env)->GetMethodID(env, agentClass, "startTransaction", 

"<)Z”) ; 

j GetTransaction = (*env)->GetMethodID(env, agentClass, "getTransaetion", 

"()Lnet/jini/core/transaction/Transaction;"); 

jlsTransactionStarted = (*env)->GetMethodID(env, agentClass, 

"isTransactionStarted", "()Z"); 

jAbortTransaction = {*env)->GetMethodID(env, agentClass, "abortTransaetion M , 

"02"); 

jCloseTransaction = (*env)->GetMethodID(env, agentClass, "closeTransaction", 

•0Z-); 

jUpdateTransaetionHandle = (*env)~>GetMethodID(env, agentClass, 

"updateTransactionHandle”, "(ILjava/lang/String;)Z")? 

if (!jStartTransaction || !jGetAgentLookupURL || ‘jlsTransactionStarted || 

!updateTransactionHandle 

|| {jAbortTransaction || !jCloseTransaction) return FALSE; 


jCreatelD = 

*(ILjava/lang/String;)Z n ); 

jRemoveID = 

"(ILjava/lang/String;)Z"); 

jCleanTSClass = 

"(ILjava/lang/String;)Z"); 

jGetTSObject = (*env)->GetMethodID(env, 

"(ILjava/lang/String;)Ljava/lang/Object;"); 

if (IjCreatelD || IjRemovelD || ‘jCleanTSClass | 


(*env) ->GetMethodID(env, 
(*env)->GetMethodID(env, 
(*env)->GetMethodID(env, 


agentClass, 

agentClass, 

agentClass, 

agentClass, 

! jGetTSObject) 


"createlD", 
"removelD", 
"cleanTSClass", 
"getTSObject", 
return FALSE; 


// TSInteger 

tsClass = (*env)->FindClass(env, "tuplespace.core.TSInteger"); 
jTSIntegerWritel = (*env)->GetMethodID(env, tsClass, "writel", "(I)Z M ); 
jTSIntegerWrite2 = (*env)->GetMethodID(env, tsClass, "write2", "(lJ)Z n ); 
jTSIntegerUpdatel = (*env)->GetMethodID(env, tsClass, "updatel", "(I)Z B ); 
jTSIntegerUpdate2 = (*env)“>GetMethodID(env, tsClass, "update2", H (IJ)Z M ); 
jTSIntegerReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", # ()I"); 
jTSIntegerRead2 = (*env)->GetMethodID(env, tsClass, "readlfExistsi", "(J)l*)y 
jTSIntegerTakel = (*env)->GetMethodID(env, tsClass, "takelfExists", "()I n ); 


142 



jTSIntegerTake2 = (*env)->GetMethodID(env, tsClass, "takelfExistsl", "(J)I W ); 
jTSIntegerTransWrite = {*env)->GetMethodID(env, tsClass, "transWrite", "(IJ)Z"); 
jTSIntegerTransUpdate = (*env)->GetMethodID(env, tsClass, "transUpdate M , "(IJ)Z tt ); 
jTSIntegerTransRead = {*env)->GetMethodID(env, tsClass, "transRead", "(J)I"); 
jTSIntegerTransTake = (*env)->GetMethodID(env, tsClass, "transTake", "(J)I")? 

if (!jTSIntegerWritel || !jTSIntegerWrite2 || !jTSIntegerUpdatel || 

jTSIntegerUpdate2 || 

!jTSIntegerReadl || !jTSIntegerRead2 ||!jTSIntegerTakel || 

jTSIntegerTake2 || 

!jTSIntegerTransWrite || !jTSIntegerTransUpdate || ‘jTSIntegerTransRead || 

j TSIntegerTransTake) 

return FALSE; 

// TSFloat 

tsClass = (*env)->FindClass(env, "tuplespace.core.TSFloat"); 
jTSFloatWritel = (*env)->GetMethodID(env, tsClass, "writel", H (F)Z"); 
jTSFloatWrite2 = (*env)~>GetMethodID (env, tsClass, "write2", "(FJ)Z"); 
jTSFloatUpdatel = {*env)->GetMethodID(env, tsClass, "updatel", M (F)Z"); 
jTSFloatUpdate2 = {*env)->GetMethodID(env, tsClass, "update2", "(FJ)Z")? 
jTSFloatReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", "OF"); 
jTSFloatRead2 = (*env)~>GetMethodID(env, tsClass, "readlfExistsl", *(J)F"); 
jTSFloatTakel = (*env)->GetMethodID(env, tsClass, "takelfExists", "()F M ); 
jTSFloatTake2 = {*env)->GetMethodID(env, tsClass, "takelfExistsl", "(J)F B ); 
jTSFloatTransWrite = (*env)->GetMethodID (env, tsClass, "transWrite", "(FJ)Z W ); 
jTSFloatTransUpdate = (*env)->GetMethodID(env, tsClass, "transUpdate", "(FJ)Z B ); 
jTSFloatTransRead = (*env)->GetMethodID(env, tsClass, "transRead", n (J)F"); 
jTSFloatTransTake = (*env)->GetMethodID(env, tsClass, "transTake", "(J)F B ); 

if (‘jTSFloatWritel || ‘jTSFloatWrite2 || !jTSFloatUpdatel || !jTSFloatUpdate2 || 

!jTSFloatReadl || !jTSFloatRead2 ||!jTSFloatTakel || !jTSFloatTake2 || 

!jTSFloatTransWrite || !jTSFloatTransUpdate || !jTSFloatTransRead || 

jTSFloatTransTake) 

return FALSE; 

// TSLong 

tsClass = (*env)->FindClass(env, "tuplespace.core.TSLong"); 
jTSLongWritel = (*env)->GetMethodID(env, tsClass, "writel", "(J)Z"); 
jTSLongWrite2 = (*env)->GetMethodID(env, tsClass, "write2", "(JJ)Z"J; 
jTSLongUpdatel = (*env)->GetMethodID(env, tsClass, "updatel", "(J)Z"); 
jTSLongUpdate2 = (*env)~>GetMethodID(env, tsClass, "update2 M , "(JJ)Z"); 
jTSLongReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", "()J M ); 
jTSLongRead2 = (*env)->GetMethodID(env, tsClass, "readlfExistsl", "(J)J"); 
jTSLongTakel = (*env)->GetHethodID(env, tsClass, "takelfExists", "OJ")? 
jTSLongTake2 = (*env) ~>GetMethodID (env, tsClass, "takelfExistsl", *MJ)J"); 
jTSLongTransWrite = (*env)->GetMethodID (env, tsClass, "transWrite", "(JJ)Z"); 
jTSLongTransUpdate = (*env)->GetMethodID(env, tsClass, "transUpdate", "(JJ)Z"); 
jTSLongTransRead = {*env)->GetMethodID(env, tsClass, "transRead", "(J)J">? 
jTSLongTransTake = (*env)->GetMethodID(env, tsClass, "transTake", "(J)J n ); 

if (!jTSLongWritel || !jTSLongWrite2 || !jTSLongUpdatel || ‘jTSLongUpdate2 || 

•jTSLongReadl || !jTSLongRead2 ||‘jTSLongTakel || !jTSLongTake2 || 

! jTSLongTransWrite || ! jTSLongTransUpdate || ! j TSLongTransRead || 

jTSLongTransTake) 

return FALSE; 

// TSDouble 

tsClass - (*env)->FindClass(env, " tuplespace . core. TSDouble" ) ,- 
jTSDoubleWritel = (*env)->GetMethodID(env, tsClass, "writel", ”(D)Z"); 
jTSDoubleWrite2 = (*env)->GetMethodID(env, tsClass, "write2", "(DJ)Z"); 
jTSDoubleUpdatel = (*env)->GetMethodID(env, tsClass, "updatel", *(D)Z")? 
jTSDoubleUpdate2 = (*env)->GetMethodID(env, tsClass, "update2", "(DJ)Z"); 
jTSDoubleReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", W ()D"); 
jTSDoubleRead2 = (*env)->GetMethodID(env, tsClass, "readlfExistsl", "(J)D n ); 
jTSDoubleTakel = (*env)->GetMethodID(env, tsClass, "takelfExists", "()D"); 
jTSDoubleTake2 = {*env)->GetMethodID(env, tsClass, "takelfExistsl", "(J)D M ); 
jTSDoubleTransWrite = (*env)->GetMethodID (env, tsClass, "transWrite", "(DJ)Z"); 
jTSDoubleTransUpdate - (*env)->GetMethodID(env, tsClass, "transUpdate", "(DJ)Z"); 
jTSDoubleTransRead = (*env)->GetMethodID(env, tsClass, "transRead", "(J)D n ); 


143 




jTSDoubleTransTake = (*env) ->GetMethodID (env, tsClass, • transTake", "(j)D")? 

^ if (!jTSDoubleWritel || »jTSDoubleWrite2 || IjTSDoubleUpdatel || !jTSDoubleUpdate2 

!jTSDoubleReadl || !jTSDoubleRead2 ||!jTSDoubleTakel || !jTSDoubleTake2 || 

!jTSDoubleTransWrite || !jTSDoubleTransUpdate || !jTSDoubleTransRead || 

jTSDoubleTransTake) 

return FALSE? 

// TSBoolean 

tsClass = (*env)->FindClass(env / "tuplespace.core.TSBoolean")? 
jTSBooleanWritel = (*env)->GetMethodID(env, tsClass, "writel", "<Z)Z")? 
jTSBooleanWrite2 = (*env)->GetMethodID(env, tsClass, "write2", "(ZJ)Z")? 
jTSBooleanUpdatel = (*env)->GetMethodID(env, tsClass, "updatel", "(Z)Z")? 
jTSBooleanUpdate2 = {*env)->GetMethodID(env, tsClass, "update2”, "(ZJ)Z n ); 
jTSBooleanReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", "()Z M ); 
jTSBooleanRead2 = (*env)->GetMethodID(env, tsClass, "readlfExistsl", M (J)Z"); 
jTSBooleanTakel = (*env)->GetMethodID(env, tsClass, "takelfExists", "()Z M ); 
jTSBooleanTake2 = (*env)->GetMethodID(env, tsClass, "takelfExistsl", "(J)Z n ); 
jTSBooleanTransWrite = (*env)->GetMethodID(env, tsClass, "transWrite", "(ZJ)Z")? 
jTSBooleanTransUpdate = (*env)->GetMethodID(env, tsClass, "transUpdate", "(ZJ)Z"); 
jTSBooleanTransRead = (*env)->GetMethodID(env, tsClass, "transRead", ”(J)Z")? 
jTSBooleanTransTake = (*env)->GetMethodID(env, tsClass, "transTake", "(J)Z")? 

if {!jTSBooleanWritel || !jTSBooleanWrite2 II ! jTSBooleanUpdatel II 

jTSBooleanUpdate2 || 

!jTSBooleanReadl || !jTSBooleanRead2 | | !jTSBooleanTakel || 

jTSBooleanTake2 || 

!jTSBooleanTransWrite || !jTSBooleanTransUpdate || !jTSBooleanTransRead || 

jTSBooleanTransTake) 

return FALSE? 

// TSHash 

tsClass = (*env)->FindClass(env, "tuplespace.core.TSHash">? 
jTSHashWritel = (*env)->GetMethodID(env, tsClass, "write", "()Z H )? 
jTSHashWrite2 - (*env)->GetMethodID(env, tsClass, "writel", ”{J)Z")? 
jTSHashUpdatel = (*env)->GetMethodID(env, tsClass, "update", "OZ")? 
jTSHashUpdate2 = (*env)->GetMethodID(env, tsClass, "updatel", "(J)Z”)? 
jTSHashReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", "()Z n ); 
jTSHashRead2 = (*env)->GetMethodID(env, tsClass, "readlfExistsl”, "(J)2")? 
jTSHashTakel = (*env)->GetMethodID(env, tsClass, "takelfExists M , "OZ")? 
jTSHashTake2 = {*env)->GetMethodID(env, tsClass, "takelfExistsl", "(J)Z") ; 
jTSHashTransWrite = (*env)->GetMethodID(env, tsClass, "transWrite”, M (J)Z"); 
jTSHashTransUpdate = (*env)->GetMethodID(env, tsClass, "transUpdate", "(J)z«)? 
jTSHashTransRead = (*env)->GetMethodID(env, tsClass, "transRead", "(J)2 n ); 
jTSHashTransTake = <*env)->GetMethodID(env, tsClass, "transTake", "(J)Z tt ); 

if (!jTSHashWritel || !jTSHashWrite2 || 'jTSHashUpdatel || !jTSHashUpdate2 || 

!jTSHashReadl || !jTSHashRead2 ||!jTSHashTakel || !jTSHashTake2 || 

!jTSHashTransWrite || !jTSHashTransUpdate | 'jTSHashTransRead || 

jTSHashTransTake) 

return FALSE? 


// TSString 

tsClass = {*env) ->FindClass (env, "tuplespace.core.TSString") ,- 
• jTSStringWritel = (*env)->GetMethodID(env, tsClass, "writel", 

(Ljava/lang/String?)Z")? 

jTSStringWrite2 = (*env)->GetMethodID(env, tsClass, "write2", 

(Ljava/lang/String?J)Z")? 

jTSStringUpdatel = (*env)->GetMethodID(env, tsClass, "updatel", 

(Ljava/lang/String?)Z")? 

j T S S t ringUpda t e2 = (*env)->GetMethodID(env, tsClass, "update2", 

(Ljava/lang/String?J)Z"); 

jTSStringReadl = (*env)->GetMethodID(env, tsClass, "readlfExists", 

()Ljava/lang/String?")? 

j TSStringRead2 = (*env)->GetMethodID(env, tsClass, "readlfExistsl", 

(J)Ljava/lang/String?")? 


144 




(*env)->GetMethodID(env, 


tsClass, 


takelfExists", 


jTSStringTakel = 

" ()Ljava/lang/String;"); 

jTSStringTake2 = 

"(J)Ljava/lang/String;")? 

j TSStringTransWrite 
"(Ljava/lang/String;J)Z"); 

jTSStringTransUpdate 
"(Ljava/lang/String;J)Z")? 

jTSStringTransRead 
"(J)Ljava/lang/String;"); 

jTSStringTransTake 
"(J)Ljava/lang/String;"); 


(*env)->GetMethodID(env, 

(*env) ->GetMethodID(env, 
(*env)->GetMethodID(env, 
(*env)->GetMethodID(env, 
(*env)~>GetMethodlD(env, 


tsClass, 

tsClass, 

tsClass, 

tsClass, 

tsClass, 


"takelfExistsl", 
"transWrite", 
"transUpdate", 
M transRead", 
"transTake", 


if (!jTSStringWritel || !jTSStringWrite2 || !jTSStringUpdatel || !jTSStringUpdate2 

!jTSStringReadl || !jTSStringRead2 ||!jTSStringTakel || !jTSStringTake2 || 

!jTSStringTransWrite || !jTSStringTransUpdate || [jTSStringTransRead || 

! jTSStringTransTake) 

return FALSE; 


logError("init Methods Ok!\n"); 
return TRUE; 

//- 

} 

void logError(char* string) 

{ 

printf("%s M , string); 

} 

//**★********************★***************************************** 
// Terminate Agent - Stop agent and release all resources 
//***************************************************************** 

void endAgent(void) 

{ 

if ((*env)->ExceptionOccurred(env)) 

(*env) ->ExceptionDescribe (env) ; 

(* jvm) ->DestroyJavaVM (jvm) ; 

} 


int InitializeAgent(long timeout) 

{ 

if ( agentObject == 0 || jInitializeAgent ==0) 

{ 

logError("Fail! InitializeAgent \n") ; 
return 0; 

} 

return (*env)->CallBooleanMethod(env, agentObject, jInitializeAgent, timeout); 

> 

//***************************************************************** 

// Set/Get AgentSecurityPolicy 

//**★***•********★******★★*****★******★*•*•*************************** 
void setAgentSecurityPolicy(char* buf) 

{ 

jstring jstr; 

if { agentObject == 0 || jSetAgentSecurityPolicy ==0) 

{ 

logError("Fail! setAgentSecurityPolicy \n") ; 
return; 

} 


145 




jstr = (*env) ->NewStringUTF (env,buf) ; 

(*env)->CallVoidMethod(env, agentObject, jSetAgentSecurityPolicy, jstr); 


void getAgentSecurityPolicy(char* buf) 

{ 

jstring jstr; 
const jbyte *str; 

if ( agentObject == 0 || jGetAgentSecurityPolicy ==0) 

{ 

logError("Fail I getAgentSecurityPolicy \n M ); 
return; 

} 

jstr = (*env)->CallObjectMethod(env, agentObject, jGetAgentSecurityPolicy) 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NOLL); 
if(str != NULL) 

sprintf(buf,"%s",str); 

(*env)->ReleaseStringUTFChars(env,j str, str)? 

} 

else 

sprintf(buf," ") ; 

} 

//it**************************************************************** 

// Set/Get Agent SpaceName 

//******★********************************************************** 
void setAgentSpaceName(char* buf) 

{ 

jstring jstr; 

if ( agentObject == 0 || jSetAgentSpaceName ==0) 

{ 

logError("Fail! setAgentSpaceName \n"); 
return; 

} 

jstr = (*env)->NewStringUTF(env,buf); 

(*env) ->CallVoidMethod(env, agentObject, jSetAgentSpaceName, jstr); 

void getAgentSpaceName(char* buf) 

{ 

jstring jstr; 
const jbyte *str; 

if ( agentObject == 0 || jGetAgentSpaceName ==0) 

{ 

logError("Fail! getAgentSpaceName \n"); 
return; 

} 

jstr = (*env)->CallObjectMethod(env, agentObject, jGetAgentSpaceName); 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(buf,"%s",str); 

(*env)->ReleasestringUTFChars(env,jstr,str); 

} 

else 

sprintf(buf," ") ; 

} 

j Z ***************************************************************** 

// Set/Get AgentServerCodebase 


146 


//**************★************************************************** 
void setAgentServerCodebase(char* buf) 

{ 

jstring jstr; 

if ( agentObject == 0 | | jSetAgentServerCodebase ==0) 

{ 

logError("Fail! setAgentServerCodebase \n"); 
return; 

} 

jstr = (*env)->NewStringUTF(env,buf); 

(*env) ->CallVoidMethod(env, agentObject, jSetAgentServerCodebase, jstr); 

} 

void getAgentServerCodebase(char* buf) 

{ 

jstring jstr; 
const jbyte *str; 

if ( agentObject == 0 || jGetAgentServerCodebase ==0) 

{ 

logError("Fail! getAgentServerCodebase \n”); 
return; 

} 

jstr = (*env)->CallObjectMethod(env, agentObject, jGetAgentServerCodebase) 
if(jstr != 0) 

{ 

str = (*env)~>GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf (buf, "%sL str) ; 

(*env)->ReleaseStringUTFChars(env,jstr,str); 

} 

else 

sprintf(buf," ") ; 

} 

j/***************************************************************** 

// Set/Get AgentLookupGroup 

//***************************************************************** 
void setAgentLookupGroup(char* buf) 

{ 

jstring jstr; 

if ( agentObject -= 0 || jSetAgentLookupGroup ==0) 

{ 

logError("Fail! setAgentLookupGroup \n"); 
return; 

} 

j str = (* env) ->NewStringUTF (env, buf) ; 

(*env) ->CallVoidMethod(env, agentObject, jSetAgentLookupGroup, jstr); 

} 

void getAgentLookupGroup(char* buf) 

{ 

j string jstr,- 
const jbyte *str; 

if ( agentObject == 0 || jGetAgentLookupGroup ==0) 

{ 

logError("Fail! getAgentLookupGroup \n"); 
return; 

} 

jstr = (*env)->CallObjectMethod(env, agentObject, jGetAgentLookupGroup); 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(buf,■%s",str); 

(*env)->ReleaseStringUTFChars(env,jstr,str); 


147 


} 

else 


sprintf(buf," "); 

} 


// Set/Get AgentLookupURL 

//***************************************************************** 
void setAgentLookupURL(char* buf) 

{ 

jstring jstr; 

if ( agentObject == 0 || jSetAgentLookupURL ==0) 

{ 

logError("Fail! setAgentLookupURL \n"); 
return; 

} 


j str = (*env)->NewStringUTF(env,buf); 

(*env)->CallVoidMethod(env, agentObject, jSetAgentLookupURL, jstr); 


void getAgentLookupURL(char* buf) 

{ 

jstring jstr; 
const jbyte *str; 

if ( agentObject =- 0 [| jGetAgentLookupURL ==0) 

{ 

logError("Fail! getAgentLookupURL \n"); 
return; 

} 

jstr = (*env)->CallObjectMethod(env, agentObject, jGetAgentLookupURL); 
if (jstr ! = 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(buf,"%s", str); 

(*env)->ReleasestringUTFChars(env,jstr,str); 

} 

else 

sprintf(buf," "); 


} 

//***********-*****************************.**********.***.**^ 1lr **^* 1fr *** 

// Create/Remove tuple ID 

//*********************************************** ****************** 
int createID(int classType, char* objectID) 

{ 

jstring jstr; 

if ( agentObject == 0 || jCreatelD ==0 |[ objectID == 0) 

{ 

logError("Fail! createlD \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,objectID); 

return (*env)->CallBooleanMethod(env, agentObject, jCreatelD, classType, jstr); 

} 

int removeID(int classType,char* objectID) 

{ 

jstring jstr; 

if ( agentObject == 0 || jRemovelD ==0 || objectID == 0) 

{ 

logError("Fail! removelD \n"); 
return FALSE; 

} 


148 


jstr = (*env)->NewStringUTF(env,objectID); 

return (*env)->CallBooleanMethod(env, agentObject, jRemovelD, classType, jstr); 

> 

int cleanTSClass(int classType,char* objectID) 

{ 

jstring jstr; 

if ( agentObject == 0 || jCleanTSClass ==0 || objectID == 0) 

{ 

logError("Fail I cleanTSClass \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,objectID}; 

return (*env)->CallBooleanMethod(env, agentObject, jCleanTSClass, classType, 

jstr) ; 

} 

jobject getTSObject(int classType, char* objectID) 

{ 

jstring jstr; 

if { agentObject == 0 || jGetTSObject ==0 || objectID == 0) 

{ 

1ogError("Fai1! getTSObj ect \n"); 
return 0; 

> 

jstr = (*env)->NewStringUTF(env,objectID); 

return (*env)->CallObjectMethod(env, agentObject, jGetTSObject, classType, jstr); 

> 

int startTransaction() 

{ 

if ( agentObject == 0 || jStartTransaction ==0 ) 

{ 

logError("Fail! startTransaction \n"); 
return 0; 

} 

return (*env)->CallBooleanMethod(env, agentObject, jStartTransaction); 

} 

jobject getTransaction() 

{ 

if ( agentObject == 0 || jGetTransaction ==0 ) 

{ 

logError("Fail I getTransaction \n"); 
return 0; 

} 

return (*env)->CallObjectMethod(env, agentObject, jGetTransaction); 

> 

int isTransactionStarted() 

{ 

if ( agentObject == 0 || jlsTransactionStarted ==0 ) 

{ 

logError("Fail! isTransactionStarted \n"); 
return 0; 

} 

return (*env)->CallBooleanMethod(env, agentObject, jlsTransactionStarted); 

} 

int abortransaction {) 

{ 

if ( agentObject == 0 || jAbortTransaction ==0 ) 

{ 

logError("Fail! abortTransaction \n"); 
return 0; 

} 

return (*env)->CallBooleanMethod(env, agentObject, jAbortTransaction); 


149 



} 


int c1oseTransaetion() 

{ 

if { agentObject == 0 || jCloseTransaction ==0 ) 

{ 

logError("Fail! closeTransaction \n"); 
return 0; 

} 

return (*env)->CallBooleanMethod(env, agentObject, jCloseTransaction); 

> 

int updateTransactionHandle(int classType, char* objectID) 

{ 

jstring jstr; 

if ( agentObject == 0 || jUpdateTransactionHandle =-0 || objectID == 0) 

{ 

logError("Fail! createlD \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,objectID); 

return (*env)->CallBooleanMethod(env, agentObject, jUpdateTransactionHandle, 
classType, jstr); 

} 

//******************************************************************************* 

//★★a************************************************************** 

// TSInteger Methods 

//★a-*************************************************************** 

// *** Write *** 

int TSIntegerWritel(char* objectID, int value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if ( jTSIntegerWritel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSIntegerWritel \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSIntegerWritel, value); 

} 

int TSIntegerWrite2(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if ( jTSIntegerWritel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSIntegerWrite2 \n"); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSIntegerWrite2, value, lease); 

) 


// *** Update *** 

int TSIntegerUpdatel(char* objectID, int value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject { (int) TS__INTEGER, objectID); 
if ( jTSIntegerUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSIntegerUpdatel \n"); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSIntegerUpdatel, value); 

) 


150 



int TSIntegerUpdate2(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if ( jTSIntegerUpdatel ==0 || jTSObject == 0) 

{ 

logError ("Fail! TSIntegerUpdate2 \n M ); 
return FALSE; 

return (*env)->CallBooleanMethod(env, jTSObject, jTSIntegerUpdate2, value, lease) 

} 

// *** Read *** 

int TSIntegerReadl(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if ( jTSIntegerReadl ==0 || jTSObject == 0) 

{ 

logError{"Fail! TSIntegerReadl \n"); 
return FALSE; 

} 

return (*env)->CallIntMethod(env, jTSObject, jTSIntegerReadl); 

} 

int TSIntegerRead2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if { jTSlntegerRead2 ==0 | | jTSObject == 0) 

{ 

logError ("Fail! TSlntegerRead2 \n"); 
return FALSE; 

) 

return (*env)->CallIntMethod(env, jTSObject, jTSIntegerRead2, timeout); 

} 

// *** Take *** 

int TSIntegerTakel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if { jTSIntegerTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSIntegerTakel \n"); 
return FALSE; 

> 

return (*env)->CallIntMethod(env, jTSObject, jTSIntegerTakel); 

} 

int TSIntegerTake2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 
if ( jTSIntegerTake2 ==0 || jTSObject == 0) 

{ 

logError("Fail! TSIntegerTake2 \n”); 
return FALSE; 

} 

return (*env)->CallIntMethod(env, jTSObject, jTSIntegerTake2, timeout); 

> 

II *** Transaction *** 

int TSIntegerTransWrite(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 


151 



0 | | updateTransactionHandle( 


if ( jTSIntegerTransWrite ==0 | | jTSObject == 

(int)TS_INTEGER, objectID)== 0) 

{ 

logError("Fail! TSIntegerTransWrite \n"); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSIntegerTransWrite, value, 

lease); 

} 

int TSIntegerTransUpdate(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 

if ( j TSIntegerTransUpdate ==0 | | jTSObject == 0 | | updateTransactionHandle ( 

(int)TS_INTEGER, objectID)== 0) 

{ 

logError("Fail! TSIntegerTransUpdate \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSIntegerTransUpdate, value, 

lease) ; 

} 


int TSIntegerTransRead(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 

if ( jTSIntegerTransRead ==0 || jTSObject == 0 || updateTransactionHandle( 

TS_INTEGER, objectID)== 0) 

{ 

logError ("Fail! TSIntegerTransRead \n") ,- 
return FALSE; 

> 

return (*env)->CallIntMethod(env, jTSObject, jTSIntegerTransRead, timeout); 

} 

int TSlntegerTransTake(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_INTEGER, objectID); 

if ( j TSlntegerTransTake ==0 || jTSObject == 0 || updateTransactionHandle ( 

TS_INTEGER, objectID)== 0) 

{ 

logError("Fail! TSlntegerTransTake \n"); 
return FALSE; 

> 

return (*env)->CallIntMethod(env, jTSObject, jTSlntegerTransTake, timeout); 

} 

//***★*************************************************************************** 

//*****-****************************^*****************************^*************** 

//******************★***★**★*******★*********★*****★**********•**★** 

// TSFloat Methods 

//************************************************************★**** 

// *** Write *** 

int TSFloatWritel(char* objectID, float value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_FLOAT, objectID); 
if ( jTSFloatWritel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSFloatWritel \n"); 
return FALSE; 

} 

return (*env)“>CallBooleanMethod(env, jTSObject, jTSFloatWritel, value); 

> 


152 



int TSFloatWrite2(char* objectID, float value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_FLOAT, objectID); 
if ( jTSFloatWritel ==0 || jTSObject == 0) 

{ 

logError (’’Fail 1 TSFloatWrite2 \n" ) ; 
return FALSE; 

return (*env)~>CallBooleanMethod(env, jTSObject, jTSFloatWrite2, value, lease); 

} 

// *** Update *** 

int TSFloatUpdatel(char* objectID, float value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_FLOAT, objectID); 
if ( jTSFloatUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSFloatUpdatel \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSFloatUpdatel, value); 

} 

int TSFloatUpdate2(char* objectID, float value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObj ect((int)TS_FLOAT, objectID); 
if ( jTSFloatUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSFloatUpdate2 \n") ; 
return FALSE; 

) 

return (*env)->CallBooleanMethod(env, jTSObject, jTSFloatUpdate2, value, lease); 

} 


// *** Read *** 

float TSFloatReadl(char* objectID) 

{ 

jobject jTSObject; 

jTSObject - getTSObject((int)TS^FLOAT, objectID); 
if ( j TSFloatReadl ==0 | | jTSObject == 0) 

{ 

logError("Fail! TSFloatReadl \n") ? 
return FALSE 

} 

return (*env)->CallFloatMethod(env, jTSObject, jTSFloatReadl); 

} 

float TSFloatRead2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_FL0AT, objectID); • 

if ( jTSFloatRead2 ==0 | | jTSObject == 0) 

{ 

logError("Fail! TSFloatRead2 \n"); 
return FALSE; 

) 

return (*env)->CallFloatMethod(env, jTSObject, jTSFloatRead2, timeout); 

> 

// *** Take *** 

float TSFloatTakel(char* objectID) 

{ 

jobject jTSObject; 


153 




jTSObject = getTSObject((int) TS_JFLOAT, objectID); 
if ( jTSFloatTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSFloatTakel \n")? 
return FALSE; 

} 

return (*env)->CallFloatMethod(env, jTSObject, jTSFloatTakel); 

} 

float TSFloatTake2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_FLOAT, objectID); 
if ( jTSFloatTake2 ==0 j| jTSObject == 0) 

{ 

logError("Fail! TSFloatTake2 \n")? 
return FALSE; 

} 

return (*env)->CallFloatMethod(env, jTSObject, jTSFloatTake2, timeout); 

> 

// *** Transaction *** 

int TSFloatTransWrite(char* objectID, float value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS^FLOAT, objectID); 

if ( j TSFloatTransWrite ==0 || jTSObject == 0 || updateTransactionHandle ( 

(int)TS^FLOAT, objectID)== 0) 

{ 

logError("Fail! TSFloatTransWrite \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSFloatTransWrite, value, 

lease); 

} 

int TSFloatTransUpdate(char* objectID, float value, long lease) 
jobject jTSObject; 

jTSObject = getTSObject((int)TS_FLOAT, objectID); 

if ( jTSFloatTransUpdate ==0 |[ jTSObject == 0 || updateTransactionHandle{ 

(int)TS_FLOAT, objectID)== 0) 

{ 

logError("Fail! TSFloatTransUpdate \n"); 
return FALSE; 

} 

return (*env)->CallBooleahMethod(env, jTSObject, jTSFloatTransUpdate, value, 

lease); 

} 


float TSFloatTransRead(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_FLOAT, objectID); 

if ( jTSFloatTransRead ==0 | | jTSObject == 0 | | updateTransactionHandle ( TS__FLOAT, 
objectID)== 0) 

{ 

logError{"Fail! TSFloatTransRead \n")y 
retum FALSE; 

} 

return (*env)->CallFloatMethod(env, jTSObject, jTSFloatTransRead, timeout); 


float TSF1oatTransTake(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS^FLOAT, objectID); 


154 



if ( jTSFloatTransTake ==0 | | jTSObject == 0 || updateTransactionHandle( TS_FLOAT, 
objectID)== 0) 

{ 

logError{"Fail! TSFloatTransTake \n"); 
return FALSE; 

} 

return (*env)->CallFloatMethod(env, jTSObject, jTSFloatTransTake, timeout); 

> 

//it*********************************************************************:********* 

//******************************************************************************* 

//****************************************************★************ 

// TSLong Methods 

//***************************************************************** 

II *** Write *** 

int TSLongWritel(char* objectID, long value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 
if ( jTSLongWritel ==0 || jTSObject == 0) 

{ 

logError ("Fail« TSLongWritel \n") ,- 
return FALSE; 

} . 

return (*env)->CallBooleanMethod(env, jTSObject, jTSLongWritel, value); 

} 

int TSLongWrite2(char* objectID, long value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 
if ( jTSLongWritel ==0 || jTSObject == 0) 

{ 

logError ("Fail! TSLongWrite2 \n") ,- 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSLongWrite2, value, lease); 

} 


// *** Update *** 

int TSLongUpdatel(char* objectID, long value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 
if ( jTSLongUpdatel ==0 || jTSObject == 0) 

{ 

logError{"Fail! TSLongUpdatel \n"); 
return FALSE ,- 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSLongUpdatel, value); 

} 

int TSLongUpdate2(char* objectID, long value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 
if ( jTSLongUpdatel ==0 || jTSObject -- 0) 

{ 

logError("Fail! TSLongUpdate2 \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSLongUpdate2, value, lease); 

} 


// *** Read *** 

long TSLongReadl(char* objectID) 



{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 
if { jTSLongReadl ==0 || jTSObject == 0) 

{ 

logError("Fail! TSLongReadl \n"); 
return FALSE; 

} 

return (long)(*env)->CallLongMethod(env, jTSObject, jTSLongReadl); 

} 

long TSLongRead2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 
if ( jTSLongRead2 ==0 || jTSObject =- 0) 

{ 

logError("Fail! TSLongRead2 \n"); 
return FALSE; 

} 

return (long)(*env)->CallLongMethod(env, jTSObject, jTSLongRead2, timeout); 

} 

// *** Take *** 

long TSLongTakel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS^LONG, objectID); 
if ( jTSLongTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSLongTakel \n"); 
return FALSE; 

> 

return (long)(*env)->CallLongMethod(env, jTSObject, jTSLongTakel); 

} 

long TSLongTake2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject ( (int)TS__LONG, objectID); 
if { jTSLongTake2 ==0 || jTSObject == 0) 

{ 

logError("Fail! TSLongTake2 \n"); 
return FALSE; 

} 

return (long)(*env)->CallLongMethod(env, jTSObject, jTSLongTake2, timeout); 

} 

I! *** Transaction *** 

int TSLongTransWrite(char* objectID, long value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 

if ( j TSLongTransWrite ==0 | | jTSObject == 0 | | updateTransactionHandle ( 

{int)TS_LONG, objectID)== 0) 

{ 

logError("Fail! TSLongTransWrite \n"); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSLongTransWrite, value, lease); 

> 

int TSLongTransUpdate(char* objectID, long value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_LONG, objectID); 

if ( jTSLongTransUpdate ==0 || jTSObject == 0 || updateTransactionHandle( 

(int)TS_LONG, objectID)== 0) 

{ 


156 



logError("Fail! TSLongTransUpdate \n"); 
return FALSE? 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSLongTransUpdate, value, 

lease) ? 

} 


long TSLongTransRead(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_LONG, objectID); 

if ( j TSLongTransRead ==0 | | jTSObject == 0 | | updateTransactionHandle { TS_LONG, 

objectID)== 0) 

{ 

logError("Fail! TSLongTransRead \n"); 
return FALSE? 

} 

return (long)(*env)->CallLongMethod(env, jTSObject, jTSLongTransRead, timeout); 

) 

long TSLongTransTake(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_LONG, objectID); 

if ( j TSLongTransTake ==0 | | jTSObject == 0 | | updateTransactionHandle ( TS_LONG, 

objectID)== 0) 

{ 

logError{"Fail! TSLongTransTake \n") ? 
return FALSE? 

} 

return (long)(*env)->CallLongMethod(env, jTSObject, jTSLongTransTake, timeout); 

} 

//******************************************************************************* 

f /******************************************************** *************** ******** 
//************★**************************************************** 

// TSDouble Methods 

//****★★******★★***★***★*★***★★**************************** ******** 

// *** Write *** 

int TSDoubleWritel{char* objectID, double value) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_D0UBLE, objectID); 
if { jTSDoubleWritel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleWritel \n n ); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSDoubleWritel, value); 

> 

int TSDoubleWrite2(char* objectID, double value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSDoubleWritel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleWrite2 \n M ); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSDoubleWrite2, value, lease); 

} 


// *** Update *** 

int TSDoubleUpdatel(char* objectID, double value) 
{ 


157 



jobject jTSObject; 

jTSObject = getTSObject { (int)TSJX)UBLE, objectID); 
if ( jTSDoubleUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleUpdatel \n"); 
return FALSE; 

} 

return {*env)->CallBooleanMethod(env, jTSObject, jTSDoubleUpdatel, value); 

int TSDoubleUpdate2(char* objectID, double value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSDoubleUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleUpdate2 \n"); 
return FALSE,- 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSDoubleUpdate2, value, lease) 


// *** Read *** 

double TSDoubleReadl(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSDoubleReadl ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleReadl \n"); 
return FALSE; 

> 

return (*env)->CallDoubleMethod(env, jTSObject, jTSDoubleReadl); 

> 

double TSDoubleRead2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSDoubleRead2 ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleRead2 \n”); 
return FALSE; 

} 

return (*env)->CallDoubleMethod(env, jTSObject, jTSDoubleRead2, timeout); 

} 

// *** Take *** 

double TSDoubleTakel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSDoubleTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSDoubleTakel \n") ; 
return FALSE; 

} 

return (*env)->CallDoubleMethod(env, jTSObject, jTSDoubleTakel); 

} 

double TSDoubleTake2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_D0UBLE, objectID); 
if ( jTSDoubleTake2 ==0 | | jTSObject == 0) 

{ 

logError("Fail! TSDoubleTake2 \n"); 
return FALSE; 

158 


} 

return (*env)->CallDoubleMethod(env, jTSObject, jTSDoubleTake2, timeout); 

} 

// *** Transaction *** 

int TSDoubleTransWrite(char* objectID, double value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if ( j TSDoubleTransWrite ==0 || jTSObject == 0 || updateTransactionHandle ( 

{int)TS_DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSDoubleTransWrite \n") ; 
return FALSE? 

return (*env)->CallBooleanMethod(env, jTSObject, jTSDoubleTransWrite, value, 

lease)? 

} 

int TSDoubleTransUpdate(char* objectID, double value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if ( j TSDoubleTransUpdate ==0 || jTSObject == 0 || updateTransactionHandle { 

(int)TS_DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSDoubleTransUpdate \n"); 
return FALSE; 

return (*env)->CallBooleanKethod(env, jTSObject, jTSDoubleTransUpdate, value, 

lease) ; 

} 


double TSDoubleTransRead(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if ( j TSDoubleTransRead ==0 || jTSObject == 0 || updateTransactionHandle ( 

TS_DOUBLE, objectID)== 0) 

{ 

logError(“Fail! TSDoubleTransRead \n w ); 
return FALSE; 

) 

return (*env)->CallDoubleMethod(env, jTSObject, jTSDoubleTransRead, timeout); 

} 

double TSDoubleTransTake(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if ( j TSDoubleTransTake ==0 | | jTSObject == 0 | | updateTransactionHandle ( 

TS_DOUBLE, ObjectID)== 0) 

{ 

logError("Fail! TSDoubleTransTake \n"); 
return FALSE? 

} 

return (*env)->CallDoubleMethod(env, jTSObject, jTSDoubleTransTake, timeout); 

> 

//********★**************************★******************************************* 

//*******★+*****★******★*★******★************************************************ 

//***************************************************************** 

// TSBoolean Methods 

//a**************************************************************** 

If *** Write *** 

int TSBooleanWritel(char* objectID, int value) 


159 


{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_DOUBLE, objectID); 
if ( jTSBooleanWritel ==0 || jTSObject == 0) 

{ 

logError (’'Fail! TSBooleanWritel \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanWritel, value); 

int TSBooleanWrite2(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_DOUBLE, objectID); 
if ( jTSBooleanWritel ==0 || jTSObject == 0) 

{ 

logError(“Fail! TSBooleanWrite2 \n") ? 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanWrite2, value, lease); 


// *** Update *** 

int TSBooleanUpdatel{char* objectID, int value) 

{ 

jobject jTSObject; 

jTSObject =s getTSObject ( (int) TS_DOUBLE, objectID); 
if ( jTSBooleanUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSBooleanUpdatel \n"); 
return FALSE; 

} 

^ return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanUpdatel, value); 

int TSBooleanUpdate2(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_D0UBLE, objectID); 
if ( jTSBooleanUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSBooleanUpdate2 \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanUpdate2, value, lease) 


// *** Read *** 

int TSBooleanReadl(char* objectID) 

{ 

jobject jTSObject? 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSBooleanReadl ==0 || jTSObject == 0) 

{ 

logError("Fail! TSBooleanReadl \n"); 
return FALSE; 

} 

return (*env)->CallBooleariMethod(env, jTSObject, jTSBooleanReadl); 

} 

int TSBooleanRead2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSBooleanRead2 ==0 || jTSObject == 0) 

{ 


160 


logError{"Fail! TSBooleanRead2 \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanRead2, timeout); 

} 

// *** Take *** 

int TSBooleanTakel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject - getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSBooleanTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSBooleanTakel \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanTakel); 

} 

int TSBooleanTake2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObj ect((int)TS_DOUBLE, objectID); 
if ( jTSBooleanTake2 ==0 || jTSObject == 0) 

{ 

logError("Fail 5 TSBooleanTake2 \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanTake2, timeout); 

> 

// *** Transaction *** 

int TSBooleanTransWrite(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObj ect((int)TS_DOUBLE, objectID); 

if ( j TSBooleanTransWrite ==0 | | jTSObject == 0 | | updateTransactionHandle ( 

(int) TS__DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSBooleanTransWrite \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanTransWrite, value, 

lease) ; 

} 

int TSBooleanTransUpdate(char* objectID, int value, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObj ect((int)TS_D0UBLE, objectID); 

if ( j TSBooleanTransUpdate ==0 | | jTSObject == 0 | | updateTransactionHandle ( 

(int)TS_DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSBooleanTransUpdate \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanTransUpdate, value, 

lease); 

} 


int TSBooleanTransRead(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObj ect((int)TS_DOUBLE, objectID); 

if ( jTSBooleanTransRead ==0 || jTSObject == 0 || updateTransactionHandle ( 

TS_DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSBooleanTransRead \n"); 


161 



return FALSE; 


} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanTransRead, timeout); 

} 

int TSBooleanTransTake(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TSJDOUBLE, objectID}; 

if { jTSBooleanTransTake ==0 || jTSObject == 0 || updateTransactionHandle( 

TS_DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSBooleanTransTake \n"); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSBooleanTransTake, timeout); 

} 

//*x***************************************************************************** 


//a****************************************************************************** 

//**•*******************************★********★*★★****★**★★★******★** 

// TSString Methods 

//***************************************************************** 

// *** Write *** 

int TSStringWritel(char* objectID, char* inputstring) 

{ 

jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS„STRING, objectID); 
if ( j TSStringWritel ==0 | | jTSObject == 0) 

{ 

logError("Fail! TSStringWritel \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,inputString); 
if (jstr ! = 0) 

return (*env)->CallBooleanMethod(env, jTSObject, jTSStringWritel, jstr); 

else 

return FALSE; 

} 

int TSStringWrite2(char* objectID, char* inputstring, long lease) 

{ 

jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject{(int)TS_STRING, objectID); 
if ( jTSStringWrite2 ==0 || jTSObject == 0) 

{ 

logError("Fail! TSStringWrite2 \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,inputstring); 

return (*env)->CallBooleanMethod(env, jTSObject, jTSStringWrite2, jstr, lease); 


// *** Update *** 

int TSStringUpdatel(char* objectID, char* inputstring) 
{ 

jobject jTSObject; 
jstring jstr; 


162 



jTSObject = getTSObject((int)TS_STRING, objectID); 
if ( jTSStringUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSStringUpdatel \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,inputString); 
if(jstr != 0) 

return <*env)->CallBooleanMethod(env, jTSObject, jTSStringUpdatel, jstr) 

else 

return FALSE; 

} 

int TSStringUpdate2(char* objectID, char* inputstring, long lease) 

{ 

jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID); 

if ( jTSStringUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSStringUpdate2 \n"); 
return FALSE; 

} 

jstr = (*env)->NewStringUTF(env,inputstring); 

return (*env)->CallBooleanMethod(env, jTSObject, jTSStringUpdate2, jstr, lease) 

} 


// *** Read *** 

void TSStringReadl(char* objectID, char* outputBuf) 

{ 

const jbyte *str; 
jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID); 
if ( jTSStringReadl ==0 || jTSObject == 0) 

{ 

logError("Fail! TSStringReadl \n"); 

} 

jstr = (*env)->CallObjectMethod(env, jTSObject, jTSStringReadl); 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars (env, jstr,NULL) ; 
if(str != NULL) 

sprintf(outputBuf,"% s",str); 

(*env)->ReleaseStringUTFChars(env,jstr,str) ; 

> 

else 

sprintf(outputBuf," "); 

} 

void TSStringRead2(char* objectID, char* outputBuf, long timeout) 

{ 

const jbyte *str; 
jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID); 
if ( jTSStringRead2 ==0 || jTSObject == 0) 

{ 

logError("Fail \ TSStringRead2 \n"); 

163 



} 


jstr = (*env)->CallObjectMethod(env, jTSObject, jTSStringRead2 / timeout); 
if{jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(outputBuf,"%s",str); 

(*env)~>ReleaseStringUTFChars(env,jstr,str); 

> 

else 

sprintf(outputBuf, " ”); 

} 


// *** Take *** 

void TSStringTakel(char* objectID, char* outputBuf) 

{ 

const jbyte *str; 
jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID) ,- 
if ( jTSStringTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSStringTakel \n ")7 

} 

jstr = (*env)->CallObjectMethod(env, jTSObject, jTSStringTakel); 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(outputBuf,"%s",str )7 
(*env)->ReleaseStringUTFChars(env,jstr,str); 

} 

else 

sprintf(outputBuf," ■)? 

} 

void TSStringTake2(char* objectID, char* outputBuf, long timeout) 

{ 

const jbyte *str; 
jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID)? 
if ( jTSStringTake2 ==0 || jTSObject == 0) 

{ 

logError("Fail! TSStringTake2 \n"); 

} 

jstr = (*env)->CallObjectMethod(env, jTSObject, jTSStringTake2, timeout); 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str i- NULL) 

sprintf(outputBuf,"%s",str); 

(*env)“>ReleaseStringUTFChars(env,jstr,str)? 

} 

else 

sprintf(outputBuf," "); 

} 

// *** Transaction *** 

int TSStringTransWrite(char* objectID, char* inputstring, long lease) 

{ 

jobject jTSObject; 


164 



jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID); 

if ( jTSStringWritel ==0 || jTSObject == 0 || updateTransactionHandle ( 

{int)TS_STRING/ objectID)== 0) 

{ 

logError{"Fail! TSStringTransWrite \n"); 
return FALSE; 

} 

jstr = {*env)->NewStringUTF(env,inputstring)? 

return (*env)->CallBooleanMethod(env, j TSObj ect, j TSStringTransWrite, j str, 

lease); 

} 

int TSStringTransUpdate(char* objectID, char* inputstring, long lease) 

{ 

jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject<(int)TS_STRING, objectID); 

if ( jTSStringWritel ==0 || jTSObject == 0 | | updateTransactionHandle ( TS_STRING, 

objectID)== 0) 

{ 

logError("Fail! TSStringUpdate2 \n"); 
retum FALSE; 

} 

jstr = (*env)->NewStringUTF(env,inputString); 

return (*env)->CallBooleanMethod(env, jTSObject, jTSStringTransUpdate, jstr, 

lease) ; 

) 

void TSStringTransRead(char* objectID, char* outputBuf, long timeout) 

{ 

const jbyte *str; 
jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID); 

if ( jTSStringWritel ==0 | | jTSObject == 0 | | updateTransactionHandle( TS_STRING, 

objectID)== 0) 

{ 

logError("Fail! TSStringTransRead \n")? 

> 

jstr = (*env)->CallObjectMethod{env, jTSObject, jTSStringTransRead, timeout); 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(outputBuf,"%s",str); 

(*env)->ReleaseStringUTFChars(env,jstr,str); 

} 

else 

sprintf(outputBuf, M "); 

> 

void TSStringTransTake(char* objectID, char* outputBuf, long timeout) 

{ 

const jbyte *str; 
jobject jTSObject; 
jstring jstr; 

jTSObject = getTSObject((int)TS_STRING, objectID); 

if ( jTSStringWritel —0 | | jTSObject == 0 j | updateTransactionHandle( TS_STRING, 
objectID)== 0) 

{ 

logError("Fail I TSStringTransTake \n"); 


165 




} 


jstr = (*env)->CallObjectMethod(env, jTSObject, jTSStringTransTake, timeout) 
if(jstr != 0) 

{ 

str = (*env)->GetStringUTFChars(env,jstr,NULL); 
if(str != NULL) 

sprintf(outputBuf,"%s",str)? 

(*env)->ReleaseStringUTFChars(env, j str,str); 

} 

else 

sprintf(outputBuf," "); 

} 

//****★***★**★*******★*•*************★*★**★************★*****★******************** 

//***************************************************************** 

// TSHash Methods 

//*★★******★****★*************************************★*********★** 

// *** Write *** 

int TSHashWritel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject{(int)TS_D0UBLE, objectID)? 
if ( jTSHashWritel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSHashWritel \n M ); 
return FALSE; 

> 

return (*env)->CallBooleanMethod(env, jTSObject, jTSHashWritel); 

} 

int TSHashWrite2(char* objectID, long lease) 

( 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSHashWritel ==0 || jTSObject == 0) 

{ 

logError{"Fail! TSHashWrite2 \n") ; 
return FALSE; 

} 

return (*env)->CallBooleanMethod{env, jTSObject, jTSHashWrite2, lease); 

} 


If *** update *** 

int TSHashUpdatel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSHashUpdatel ==0 || jTSObject == 0) 

{ 

logError ("Fail! TSHashUpdatel \n") 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSHashUpdatel); 

} 

int TSHashUpdate2(char* objectID, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS^DOUBLE, objectID); 
if ( jTSHashUpdatel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSHashUpdate2 \n")? 
return FALSE? 

} 

return (*env)->CalIBooleanMethod(env, jTSObject, jTSHashUpdate2, lease); 

} 


166 




// *** Read *** 

int TSHashReadl(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSHashReadl ==0 || jTSObject == 0) 

{ 

logError("Fail! TSHashReadl \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSHashReadl); 

} 

int TSHashRead2{char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS^DOUBLE, objectID); 
if { jTSHashRead2 ==0 || jTSObject == 0) 

{ 

logError("Faili TSHashRead2 \n"); 
return FALSE,- 

} 

return (*env)->Ca11BooleanMethod(env, jTSObject, jTSHashRead2, timeout); 

) 

// *** Take *** 

int TSHashTakel(char* objectID) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSHashTakel ==0 || jTSObject == 0) 

{ 

logError("Fail! TSHashTakel \n M ); 
return FALSE ,- 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSHashTakel); 

} 

int TSHashTake2(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 
if ( jTSHashTake2 ==0 || jTSObject == 0) 

{ 

logError{"Fail! TSHashTake2 \n"); 
return FALSE; 

} 

return (*env)->CallBooleanHethod(env, jTSObject, jTSHashTake2, timeout); 

} 

// *** Transaction *** 

int TSHashTransWrite(char* objectID, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if { j TSHashTransWrite ==0 || jTSObject == 0 || updateTransactionHandle { 

(int)TS_DQUBLE, objectID)== 0) 

{ 

logError("Fail I TSHashTransWrite \n"); 
return FALSE; 

• } 

return (*env)->CallBooleanMethod(env, jTSObject, jTSHashTransWrite, lease); 

> 

int TSHashTransUpdate(char* objectID, long lease) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS^DOUBLE, objectID); 


167 





if ( jTSHashTransUpdate ==0 || jTSObject == 0 || updateTransactionHandle( 

(int)TS_DOUBLE, objectID)== 0) 

{ 

logError("Fail! TSHashTransUpdate \n"); 
return FALSE; 

} 

return (*env)->CallBooleanMethod(env, jTSObject, jTSHashTransUpdate, lease); 

} 


int TSHashTransRead(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if ( jTSHashTransRead ==0 || jTSObject == 0 | | updateTransactionHandle( TS_DOUBLE, 
objectID)== 0) 

{ 

logError{"Fail! TSHashTransRead \n"); 
return FALSE; 

} 

return {*env)-^allBooleanMethodienv, jTSObject, jTSHashTransRead, timeout); 

> 

int TSHashTransTake(char* objectID, long timeout) 

{ 

jobject jTSObject; 

jTSObject = getTSObject((int)TS_DOUBLE, objectID); 

if ( jTSHashTransTake ==0 || jTSObject == 0 || updateTransactionHandle( TS_DOUBLE, 
objectID)== 0) 

{ 

logError("Fai1! TSHashTransTake \n"); 
return FALSE; 

) 

return {*env)->CallBooleanMethod(env, jTSObject, jTSHashTransTake, timeout); 

} 


168 



APPENDIX E. AGENT API LISTING 


A. SERVICE PACKAGE 

1. AgentServiceInterface.java 

// This is the interface that the service's proxy 
// implements 

package tuplespace.services; 

public interface AgentServicelnterface { 
public String getMessage(); 

public boolean joinService(String id. String password); 
public boolean endService(); 

} 

2. AgentService.java 

package tuplespace.services; 

import net.jini.discovery.DiscoveryListener; 

import net.jini.discovery.DiscoveryEvent; 

import net.jini.discovery.LookupDiscovery; 

import net.jini.core.entry. *; 

import net.jini.lookup.entry.*; 

import net.jini.core.lookup.Serviceltem; 

import net.jini.core.lookup.ServiceRegistrar; 

import net.jini.core.lookup.ServiceRegistration; 

import net.jini.core.lease.Lease; 

import net.jini.core.lease.UnknownLeaseException; 

import java.util.Hashtable; 

irnport java.io.IOException; 

import java.io.Serializable; 

import j ava.rmi.RemoteException; 

inport j ava. rmi.RMISecurityManager; 

import java.util.Vector; 

import java.util-Enumeration; 

// This is the proxy object that will be downloaded 
// by clients. It's serializable and implements 
// our well-known AgentServicelnterface. 
class AgentServiceProxy implements Serializable, 
AgentServicelnterface { 
public AgentServiceProxy{) { 

} 

public String getMessage() { 
return "Hello, world!"; 

} 

public boolean joinService(String id. String password){ 
return true; 

> 

public boolean endService(){ 
return true; 

} 

> 

// AgentService is the "wrapper" class that 
// handles publishing the service item, 
public class AgentService implements Runnable { 

// 10 minute leases 

protected Thread leaseThread = null; 
protected final int LEASE_TIME = 10 * 60 * 1000; 
protected Hashtable registrations = new HashtableO; 
protected Serviceltem item; 
protected LookupDiscovery disco; 

// Inner class to listen for discovery events 

169 



class Listener implements DiscoveryListener { 

// Called when we find a new lookup service, 
public void discovered(DiscoveryEvent ev) { 

System, out .println ("discovered a lookup service!'*)? 

ServiceRegistrar[] newregs = ev.getRegistrars()? 
for (int i=0 ; i<newregs.length ; i++) { 

if {!registrations.containsKeytnewregs[i])) { 
registerWithLookup(newregs[i]); 

} 

} 

) 

// Called ONLY when we explicitly discard a 
// lookup service, not "automatically" when a 
// lookup service goes down. Once discovered, 

// there is NO ongoing communication with a 
// lookup service. 

public void discarded(DiscoveryEvent ev) { 

ServiceRegistrar[] deadregs = ev.getRegistrars(); 
for (int i=0 ; i<deadregs.length ; i++) { 
registrations.remove(deadregs[i])? 

> 

} 

} 

public AgentService() throws IOException { 

item = new Serviceltern (null, createProxy(), getAttributes())? 

// Set a security manager 

if (System.getSecurityManager() == null) { 

System.setSecurityManager(new RMISecurityManager())? 

> 

// Search for the "public" group, which by 
// convention is named by the empty string 
disco = new LookupDiscovery(new String[) { "" >)? 

// Install a listener. 

disco.addDiscoveryListener(new Listener())? 

} 

protected AgentServicelnterface createProxy() { 
return new AgentServiceProxy()? 

} 

// This work involves remote calls, and may take a 
// while to complete. Thus, since it's called from 
// discovered(), it will prevent us from responding 
// in a timely fashion to new discovery events. An 
// improvement would be to spin off a separate short- 
// lived thread to do the work. 

protected synchronized void registerWithLookup(ServiceRegistrar registrar) { 
ServiceRegistration registration = null; 

try { 

registration = registrar.register(item, LEASE_TIME)? 

} catch (RemoteException ex) { 

System.out.println("Couldn't register: " + ex.getMessage{))? 
return? 

} 

// If this is our first registration, use the 
// service ID returned to us. Ideally, we should 
// save this ID so that it can be used after 
// restarts of the service 
if (item.servicelD == null) { 

item.servicelD = registration.getServicelD()? 

System.out.println("Set servicelD to * + item.servicelD)? 

> 


170 



registrations.put(registrar, registration); 
leaseThread.interrupt(); 

} 

// run now maintains our leases 
public void run() { 
while (true) { 
try ( 

long sleepTime = computeSleepTime(); 
Thread.sleep(sleepTime); 
renewLeases() ; 

> catch (InterruptedException ex) { 

} 

} 

} 


// Figure out how long to sleep. 

protected synchronized long computeSleepTime() { 
long soonestExpiration = Long. MAX_VALUE ; 

Enumeration enum = registrations.elements(); 
while (enum.hasMoreElements()) { 

Lease 1 = ((ServiceRegistration) enum.nextElement0).getLease(); 
if (1.getExpiration() - (20 * 1000) < soonestExpiration) { 
soonestExpiration = 1.getExpiration() - (20 * 1000); 

} 

) 

long now = System, cur rentTimeMi 11 is () ; 

if (now >= soonestExpiration) { 
return 0; 

} else { 

return soonestExpiration - now; 

} 

} 

//Do the work of lease renewal, 
protected synchronized void renewLeases() { 
long now = System, cur rentTimeMi 11 is () ; 

Vector deadLeases = new Vector(); 

Enumeration keys = registrations.keys() ; 
while (keys.hasMoreElements()) { 

ServiceRegistrar lu = (ServiceRegistrar) keys.nextElement(); 
ServiceRegistration r = (ServiceRegistration) registrations.get(lu) 
Lease 1 = r.getLease(); 
if (now <= 1.getExpiration() && 

now >= 1 .getExpiration () - (20 * 1000)) { 
try { 

System.out.printIn("Renewing lease."); 

1.renew( LEASE_TIME); 

} catch (Exception ex) { 

System.err.println("Couldn't renew lease: " + 
ex.getMessage()); 
deadLeases.addElement(lu); 

> 

} 

} 

// clean up after any leases that died 
for (int i=0, size=deadLeases.size() ; i<size ; i++) { 
registrations.remove(deadLeases.elementAt(i)); 

} 

) 

protected Entry[] getAttributes(){ 


171 



Entry[] entries = new Entry[23; 
entries[0] = new Servicelnfo("Tiptop", 

"Agent", 
"Agent", 

"Tiptop", 
"vl.O"); 

entries[1] = new Name("Agent")? 
return entries; 


// Create the service and start the leasing 
// thread. 

public static void main(String args[3) { 
try { 

AgentService hws = new AgentService{)? 
hws.leaseThread = new Thread{hws); 
hws.leaseThread.start(); 

} catch (IOException ex) { 


System.out.printIn("Couldn't create service: " + 


} 


ex.getMessage()); 


} 


172 


B. CORE PACKAGE 
1. Agent.java 

package tuplespace.core; 


import java.net.URLClassLoader; 
import java.net.URL; 

import java.net.MaiformedURLException ; 
import tuplespace.entries.*; 

import net. jini .core.entry.UnusableEntryException? 

import net.jini.core.lease.Lease ? 

import net.jini.core.transaction.*; 

import net.jini.core.transaction.server.*; 

import net.jini.space.JavaSpace; 

import java.util.*; 

import j ava. awt. event. * ; 

j ★ * 

* The <code>Agent</code> class implements the methods to 

* configure agent properties, establish connection with Jini Services, 

* request for transaction and create new entry handlers 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 
*/ 

public class Agent implements java.io.Serializable, SpaceActionHandler, TSConstants 
{ 

private JavaSpace space; 
private TransactionManager txnMgr; 
private Transaction txn? 
private TSList tsList; 
private TSStack tsStack? 

private Vector pushListeners = new Vector(); 

private Map tsStringMap? 

private Map tsBooleanMap; 

private Map tsIntegerMap; 

private Map tsFloatMap; 

private Map tsLongMap; 

private Map tsDoubleMap? 

private Map tsQueueMap; 

private Map tsStackMap; 

private Map tsLinkListMap; 

private Map tsHashMap? 


public Agent 0 
{ 


System.setProperty{"java.security.policy","d:\\jinil_l\\example\\books\\policy.all"); 
System. setProperty ("outrigger.spacename","JavaSpaces"); 

//System.setProperty("com.sun.jini.lookup.locator",null); // unicast 


property to a proper jini URL 

System.setProperty("com.sun.jini.lookup.groups","public"); 

System. setProperty("java.rmi.server.codebase","http://tiptop:8081/entries.jar") 
System.out.printIn{" *** Default System properties ***"); 

System.out.printIn(" 1- Security Policy : 

System.getProperty("java.security.policy")); 

System, out.printIn(* 2. Space Name : 

System.getProperty{"outrigger.spacename")); 

System, out.printIn(■ 3. Server Codebase : 

System.getProperty("j ava. rmi.server.codebase")); 

System.out .println ( n 4. Lookup URL : 

System.getProperty("com.sun.jini.lookup.locator")); 

System, out.println(" 5. Lookup groups * 

System.getProperty ("com.sun. jini .lookup.groups")) ; 

System.out.println("... Agent Loaded \ but still not started"); 


//InitAgent(10000)? 




txn - null; // Disable Transaction 

addActionListener(this); 

//Initialize Hash Maps 
tsStringMap = new HashMapO; 
tsBooleanMap = new HashMap(); 
tslntegerMap = new HashMapO; 
tsFloatMap = new HashMapO; 
tsLongMap = new HashMap(); 
tsDoubleMap = new HashMap(); 
tsQueueMap = new HashMap(); 
tsStackMap = new HashMapO ; 
tsLinkListMap = new HashMap(); 
tsHashMap = new HashMap{); 


/** look for the Jini/Space and test whether the interface is functioning 
@retum <tt>true</tt> if agent is successfully initialized. */ 

public boolean InitAgent(long timeout) 

{ 

System.out.println("Security Policy ; 

System.getProperty{"java.security.policy")) ; 

System.out.println("Space Name 

System.getProperty("outrigger.spacename")); 

System.out.println("Server Codebase : 

System. getProperty ( • j ava. rmi . server. codebase")),- 
System.out.println{"Lookup URL 

System.getProperty("com.sun.jini.lookup.locator")); 

System.out.printIn("Lookup groups . 

Systern.getProperty("com.sun.jini.lookup.groups")); 

space = null; 
txnMgr = null? 
try{ 

if( ServiceAccessor.getLocator( timeout) != null){ 

space = ServiceAccessor.getSpace(getAgentSpaceName()) ; 
txnMgr = ServiceAccessor.getManager(); 
if(space == null || txnMgr -= null) 
return false; 
else 

return true; 

} 

} catch (Exception e){ 
e.printStackTrace() ; 

} 

return false; 

} 

public void TerminateAgent() 

{ 

Iterator it; 

for (it=tsStringMap.keyset().iterator()? it.hasNext{)? ) { 

^ remove ID ( TS_STRING, (String) it.nextO); 

for (it=tsBooleanMap.keyset().iterator(); it.hasNext()? ) { 

^ removelD( TS_BOOLEAN/(String) it.nextO); 

for (it=tslntegerMap.keyset().iterator(); it.hasNext(); ) { 
removeID( TS_INTEGER, (String) it.nextO); 

for (it=tsFloatMap. keyset () . iterator (); it.hasNextO? ) { 
removelD( TS^FLOAT, (String) it.nextO); 

} 

for (it=tsLongMap. keyset O .iterator () ? it.hasNextO; ) { 
removelD( TS_LONG, (String) it.nextO); 


174 



for (it=tsDoubleMap.keyset().iterator(); it .hasNext 0 ; ) { 
removeID( TS_DOUBLE, (String) it.nextO); 

} 

for (it=tsQueueMap.keySet0.iterator(); it.hasNext(); ) { 
reinoveID( TS_QUEUE, (String) it.nextO ); 

} 

for (it=tsStackMap.keyset 0-iterator(); it-hasNext(); ) { 
removelD( TS_STACK,(String) it.next{)); 

} 

for (it=tsHashMap.keyset().iterator(); it.hasNext()? ) { 
removelD( TS_HASH,(String) it.next()); 

} 

//System.runFinalizersOnExit(0); 

System.exit (0); 

} 

/** returns the spaceAction handle 

* ©return <tt>null</tt> if space action handle is invalid. */ 

public SpaceActionHandler getActionHandler(){ 
return this; 

} 

/** start transaction manager; transaction handle will remain valid 

* for a maximum of 5 minutes (Default setting) 

* ©return <tt>false</tt> if transaction manager false to start. */ 
public boolean startTransaction(){ 

if(txnMgr != null){ 

Transaction.Created trc = null; 
try { 

trc = TransactionFactory.create(txnMgr, 300000); 
txn = trc.transaction; 

return true; 

) catch (Exception e) { 

System.err.println("Could not create transaction " + e); 
return false; 

} 

}else 

return false; 

> 

/** returns the transaction handle; transaction manager must be 

* initialized and started 

* ©return <tt>null</tt> if transaction handle is invalid. */ 

public Transaction getTransaction(){ 
return txn; 

} 


/** returns the current state of transaction handle 

* ©return <tt>true</tt> if transaction handle is valid. */ 
public boolean isTransactionStarted(){ 

if(txn != null) 
return true; 
else 

return false; 

} 

/** aborts the current transaction; all the commands issued with 

* transaction after the start transaction will be rolled back. 

* ©return <tt>true</tt> if transaction is successfully aborted. */ 
public boolean abortTransaction(){ 

try { 

txn.abort(); 
txn = null; 
return true; 

} catch (Exception e) { 


175 


return false; 

> 

} 

/** closes the current transaction; all the commands issued with 

* transaction after the start transaction will become active. 

* ©return <tt>true</tt> if transaction is successfully closed. */ 

public boolean closeTransaction(){ 
try { 

txn. commit {) ; 
txn = null? 
return true; 

} catch (Exception e) { 
return false; 

} 

} 

/** update the transaction handle in TSObject 

* ©param type the type of entry to create. E.g Entrylnteger 

* ©param id a ID that identifies this entry 

* ©return <tt>true</tt> if entry is successfully created. */ 
public boolean updateTransactionHandle(int type. String id) { 

TSBase obj = (TSBase) getTSObject(type, id); 
if{obj -= null) 
return false; 

obj . setTransactionHandler(txn); 
return true; 

} 


j / ********★**■*****★★★★**★*•********★*★******★*•*****★************★★****★★*■**★ 

//*** System Property Methods 
★ * * 

//**************★********★*********★***************★*********************★* 

/** Set Agent Security Policy path and filename*/ 
public void setAgentSecurityPolicy(String str){ 

System, setProperty!"java.security.policy",str); 

} 

/** Returns Agent Security Policy path and filename*/ 
public String getAgentSecurityPolicy{){ 

return System.getProperty("java.security.policy"); 

> 

/** Set Agent Space Name */ 

public void setAgentSpaceName(String str){ 

System.setProperty("outrigger.spacename",str); 

} 

/** Returns Agent Space Name */ 
public String getAgentSpaceName(){ 

return System.getProperty(“outrigger.spacename"); 

} 

/** Set Agent Server Codebase */ 

public void setAgentServerCodebase(String str){ 

System.setProperty(*j ava.rmi.server.codebase",str)? 

} 

/** Returns Agent Server Codebase */ 
public String getAgentServerCodebase(){ 

return System, get Property( "java, rmi. server. codebase") ; 

} 

/** Set Agent Lookup Group */ 


176 


public void setAgentLookupGroup(String str){ 

System.setProperty("com.sun.jini.lookup.groups",str); 

> 

/** Returns Agent Lookup Group */ 
public String getAgentLookupGroup{){ 

return System.getProperty{"com.sun.jini.lookup.groups")? 

} 

/** Set Agent Lookup URL */ 
public void setAgentLookupURL(String str){ 
if(str != null || str.length() > 0) 

System, setProperty("com.sun.jini.lookup.locator",str); 

} 

/** Returns Agent Lookup URL */ 
public String getAgentLookupURL(){ 

return System.getProperty("com.sun.jini.lookup.locator"); 

} 


//************************************************************************* 

// *** IDs 

* * * * 

//************************************************************************* 

/** Create a new entry in agent 

* @param type the type of entry to create. E.g Entrylnteger 

* @param id an unique ID that identifies this entry 

* ^return <tt>true</tt> if entry is successfully created. */ 

public boolean createID(int type, String id){ 
switch(type){ 

case TS_BOOLEAN: 

if(!tsBooleanMap.containsKey(id)){ 

TSBoolean ts = new TSBoolean(space,this,id); 
tsBooleanMap.put(id,ts); 
return true; 

} 

break; 

case TS_INTEGER: 

if(!tsIntegerMap.containsKey(id)){ 

TSInteger ts = new TSInteger(space,this,id); 
tsIntegerMap.put(id,ts); 
return true; 

> 

break; 

case TS_FLOAT: 

if(!tsFloatMap.containsKey(id)){ 

TSFloat ts = new TSFloat(space,this,id); 
tsFloatMap.put(id,ts); 
return true; 

} 

break; 

case TS_LONG: 

if(!tsLongMap.containsKey(id)){ 

TSLong ts = new TSLong(space,this,id); 
tsLongMap.put(id,ts); 
return true; 

} 

break; 

case TS_DOUBLE: 

if(!tsDoubleMap.containsKey(id)){ 

TSDouble ts - new TSDouble(space,this,id); 
tsDoubleMap.put(id,ts); 
return true; 

> 


177 



break; 

case TS_STRING: 

if(!tsStringMap.containsKey(id)){ 

TSString ts = new TSString(space,this,id); 
tsStringMap.put(id,ts),- 
return true; 

} 

break; 

case TS_QUEUE: 

if(!tsQueueMap.containsKey(id)){ 

TSQueue ts = new TSQueue(space,this,id,100) ; 
tsQueueMap.put(id,ts); 
return true; 

} 

break; 

case TS_STACK: 

if{!tsStackMap.containsKey(id)){ 

TSStack ts = new TSStack(space,id); 
tsStackMap.put(id,ts); 
return true; 

} 

break; 

case TS_LINKLIST: 
break; 

case TS_HASH: 

if(!tsHashMap.containsKey(id)){ 

TSHash ts = new TSHash(space,this,id); 
tsHashMap.put(id,ts); 
return true; 

> 

break; 

> 

return false; 

} 

/** Remove an existing TSString ID */ 
public boolean removeID(int type. String id){ 
switch(type){ 

case TS_BOOLEAN: 

if(tsBooleanMap.containsKey(id)){ 

TSBoolean ts = (TSBoolean) tsBooleanMap.get(id) 
ts.stopEvent(); 
tsBooleanMap.remove(id); 
return true; 

} 

break ,- 

case TS_INTEGER: 

if(tsIntegerMap.containsKey(id)){ 

TSInteger ts = (TSInteger) tsIntegerMap.get(id) 
ts.stopEvent{); 
tsIntegerMap. remove (id) ; 
return true; 

} 

break; 

case TS_FLOAT: 

if(tsFloatMap.containsKey(id)){ 

TSFloat ts = (TSFloat) tsFloatMap.get(id); 
ts.stopEvent()? 
tsFloatMap.remove(id); 
return true; 

} 

break; 

case TS_LONG: 

if (tsLongMap.containsKey(id)){ 

TSLong ts = (TSLong) tsLongMap.get(id); 
ts.stopEvent()? 
tsLongMap.remove(id); 
return true; 


178 





} 

break; 

case TS_DOUBLE: 

if(tsDoubleMap.containsKey(id)){ 

TSDouble ts = (TSDouble) tsDoubleMap.get(id); 
ts.stopEvent(); 
tsDoubleMap.remove(id); 
return true; 

} 

break; 

case TS_STRING: 

if(tsStringMap.containsKey(id)){ 

TSString ts = (TSString) tsStringMap.get(id); 
ts.stopEvent(); 
tsStringMap.remove(id); 
return true; 

} 

break; 

case TS_QUEUE: 

if (tsQueueMap.containsKey (id) ) { 
tsQueueMap. remove (id) ; 
return true; 

> 

break; 

case TS_STACK: 

if(tsStackMap.containsKey(id)){ 
tsStackMap.remove(id); 
return true; 

} 

break; 

case TS_LINKLIST: 
break; 

case TS_HASH: 

if(tsHashMap.containsKey(id)){ 

TSHash ts = (TSHash) tsHashMap.get(id); 
ts.stopEvent(); 
tsHashMap. remove (id) ; 
return true; 

} 

break; 

} 

return false; 

} 


/** Remove an existing TSString ID */ 
public Object getTSObject(int type. String id){ 
switch(type){ 

case TS_BOOLEAN: 

if(tsBooleanMap.containsKey(id)) 
return tsBooleanMap.get(id) ; 
break; 

case TS_INTEGER: 

if(tsIntegerMap.containsKey(id)) 
return tsIntegerMap.get(id) ; 
break; 

case TS_FLOAT: 

if(tsFloatMap.containsKey(id)){ 
return tsFloatMap.get(id) ; 

} 

break; 

case TS_JLONG: 

if(tsLongMap.containsKey(id)){ 
return tsLongMap.get(id)? 

} 

break; 

case TSJDOUBLE: 

if(tsDoubleMap.containsKey(id)){ 
return tsDoubleMap.get(id); 

} 


179 



break; 

case TS_STRING: 

if(tsStringMap.containsKey(id)) 
return tsStringMap.get(id); 
break; 

case TS_QUEUE: 

if(tsQueueMap.containsKey(id)) 
return tsQueueMap.get{id); 
break; 

case TS_STACK: 

if(tsStackMap.containsKey(id)) 
return tsStackMap.get(id); 
break; 

case TS__LINKLI ST: 
break; 

case TS_HASH: 

if(tsHashMap.containsKey(id)) 
return tsHashMap.get(id); 
break; 
default: 

break; 


} 

System.out.printIn("Cannot find TSClass! Type:" +type+ " ID:" + id) 
return null; 


/** Creates a new TSString ID */ 

public boolean cleanTSClass(int type. String id){ 
switch (type) { 

case TS_BOOLEAN: 

if(tsBooleanMap.containsKey(id) ){ 

TSBoolean ts = (TSBoolean) tsBooleanMap.get(id); 
ts.cleanSpace(); 
return true; 

} 

break 

case TS_INTEGER: 

if(tsIntegerMap.containsKey(id)){ 

TSInteger ts = (TSInteger) tsIntegerMap.get(id); 
ts.cleanSpace(); 
return true; 

} 

break; 

case TS_FLOAT: 

if(tsFloatMap.containsKey(id)){ 

TSFloat ts = (TSFloat) tsFloatMap.get(id); 
ts.cleanSpace(); 
return true; 

} 

break; 

case TS_LONG: 

if(tsLongMap.containsKey(id)){ 

TSLong ts = (TSLong) tsLongMap.get(id) ; 
ts. cleanSpace () 
return true; 

} 

break; 

case TS_DOUBLE: 

if(tsDoubleMap.containsKey(id)){ 

TSDouble ts = (TSDouble) tsDoubleMap.get(id); 
ts.cleanSpace(); 
return true; 

} 

break; 

case TS_STRING: 

if(tsStringMap.containsKey(id)){ 

TSString ts = (TSString) tsStringMap.get(id); 
ts.cleanSpace(); 


180 



return true; 


} 

break; 

case TS_QUEUE: 

if(tsQueueMap.containsKey(id)){ 

//TSQueue ts = (TSQueue) tsQueueMap.get(id); 

//ts.cleanSpace(); 
return true; 

} 

break; 

case TS_STACK: 

if(tsStackMap.containsKey(id)) { 

TSStack ts = (TSStack) tsStackMap.get(id); 

//ts.cleanSpace(); 
return true; 

} 

break; 

case TS__LINKLIST: 

break; 

case TS_HASH: 

if(tsHashMap.containsKey(id)){ 

TSHash ts = (TSHash) tsHashMap.get(id); 

//ts.cleanSpace(); 
return true; 

} 

break; 

} 

System.out.printIn("Cannot findTSClass! Type:" +type+ " ID:" + id) 
return false; 

} 


/** Returns all TSString IDs created */ 
public String getTSClassIDs(int type){ 
Map map = nul1; 
switch(type){ 

case TS_BOOLEAN: 

map = tsBooleanMap; 
break; 

case TS_INTEGER: 

map = tsIntegerMap; 
break; 

case TS_FLOAT: 

map = tsFloatMap; 
break; 

case TS_LONG: 

map = tsLongMap; 
break; 

case TS_DOUBLE: 

map = tsDoubleMap; 
break; 

case TS_STRING: 

map = tsStringMap; 
break; 

case TS_QUEUE: 

map = tsQueueMap; 
break; 

case TS^STACK: 

map = tsStackMap; 
break; 

case TS_LINKLIST: 

map = tsIntegerMap; 
break; 

case TS_HASH: 

map = tsHashMap; 
break; 

} 


181 




if (map ‘ = null) { 

String tmpStr = null; 
int i =0; 

for (Iterator it=map.keyset().iterator() ;it.hasNext(); ) { 
if(tmpStr == null) 

tmpStr = (String) it.nextO ; 

else 

tmpStr = tmpStr + "," + it.nextO; 

//print( M Key["+ i++ + "] -> " + tmpStr); 

} 

return tmpStr; 

}else 

return null; 


//★★★★★★★★★it*************************************************************** 

// *** Miscellaneous Methods 

* * * * 

//★***■***★***★***■**★*★**★*•★*★**•*★★*********★*********★***★***■*************★ 

public void actionPerformed(ActionEvent e){ 

print("action ID :[" + e.getIDO + "3 Command:[" + e.getActionCommand() + 

} 


public synchronized void addActionListener(ActionListener 1) { 
pushListeners.addElement(1); 

} 

public synchronized void removeActionListener(ActionListener 1) { 
pushListeners.removeElement(1); 

} 

public void fireAction(int entryType, String entrylD) { 

Vector targets; 

synchronized (this) { 

targets = (Vector) pushListeners.clone(); 

> 

ActionEvent actionEvt = new ActionEvent(this, entryType, entrylD); 
for (int i = 0; i < targets.size(); i++) { 

ActionListener target = (ActionListener)targets.elementAt(i); 
target.actionPerformed(actionEvt); 

//print("FireAction triggered!"); 

} 


public void print(String str){ 
System,out .println{str) ; 

} 


public int getTSType(String type){ 

if( type.compareTo("BOOLEAN") == 0) 
return TS_BOOLEAN; 

else if( type.compareTo("INTEGER") == 0) 
return TS_INTEGER; 

else if( type.compareTo("FLOAT") == 0) 
return TS_FLOAT; 

else if( type.compareTo("LONG*) == 0) 
return TS_LONG; 

else if( type.compareTo("DOUBLE") == 0) 
return TS_DOUBLE; 

else if( type.compareTo("STRING”) == 0) 
return TS_STRING; 

else if( type.compareTo("QUEUE") == 0) 
return TS_QUEUE; 

else if( type.compareTo("STACK") == 0) 


182 



0 } 


return TS_STACK; 

else if( type.compareTo("LINKLIST") == 
return TS__LINKLIST; 
else if{ type.compareTo("HASH") == 0) 
return TS_HASH; 
else 

return 0; 

} 


public void SearchTSClassIDs{) 

{ 

System.out.println( "Start Search") 
startTransaction()? 
searchSpace(TS_STRING); 
searchSpace(TS_INTEGER); 
searchSpace(TS_LONG); 
searchSpace(TS_DOUBLE); 

abortTransaction(); 

} 

private void searchSpace(int type) 

{ 

boolean breakLoop = false? 
do{ 

try{ 

switch (type) { 
case TSJBOOLEAN: 

EntryBoolean testO = (EntryBoolean) space.takelfExists(new 

EntryBoolean( ) ,txn, 1000); 

createlD(type, testO.entrylD); 
break? 

case TS_INTEGER:. 

EntryXnteger testl = (EntryInteger) space.takelfExists (new 

Entrylnteger(),txn,1000)? 

createID(type, testl.entrylD); 
break; 

case TS_FLOAT: 

EntryFloat test2 = (EntryFloat) space.takelfExists(new 

EntryFloat(),txn,1000); 

createlD(type, test2.entrylD)? 
break; 

case TS_LONG: 

EntryLong test3 - (EntryLong) space.takelfExists(new 

EntryLong(),txn,1000); 

createlD(type, test3.entrylD); 
break; 

case TS_DOUBLE: 

EntryDouble test4 = (EntryDouble) space.takelfExists( new EntryDouble() 

,txn,1000)? 

createlD(type, test4.entrylD); 
break; 

case TS^STRING: 

Entrystring tests = (Entrystring) space -takelfExists(new 

Entrystring(),txn,1000); 

createlD(type, tests.entrylD); 
break; 

case TS_QUEUE: 

EntryQueueltem test6 = (EntryQueueltem) space.takeIfExists(new 

EntryQueueItem(),txn,1000); 

createlD(type, test6.entrylD)? 
break; 

case TS_STACK: 

//EntryStack test = (EntryStack) space.takelfExists((EntryStack) 

template,null, 1000)? 

//createlD(type, test.entrylD); 
break; 

case TS_LINKLIST: 


183 




//test = space.takelfExists((EntryLinkList) template,null,1000); 

//createlD(type,(EntryLinkList) test.entrylD); 
break; 

case TS_HASH: 

EntryHash test7 = (EntryHash)space.takelfExists(new 

EntryHash(),txn,1000); 

createlD{type, test7.entrylD); 
break; 

} 

}catch (Exception e){ 
breakLoop = true; 

} 

>while(breakLoop == false); 

} 

} 


i 




184 



2. ServiceFinder.java 

package tuplespace.core; 


import net. jini.core.lookup.*; 

import net.jini.discovery.*; 

import net. j ini .core, entry. *; 

import net.jini.lookup.entry. Name; 

import com.sun.jini.mahout.Locator; 

import com.sun.jini.outrigger.Finder; 

import com.sun.jini.outrigger.DiscoveryLocator; 

import java.rmi-Remote; 
import java.rmi.RemoteException; 
import java.rmi-AccessException; 
import java.util.Iterator; 

j * * 

* A <code> ServiceFinder </code> implements the 

* methods needed locate a service in a Jini(tm) Lookup service. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 
*/ 

public class ServiceFinder extends Finder { 

private ServiceRegistrar lookup,- 
private int retry; 

private static final boolean DEBUG = false; 
private static final int MAX_DISCOVERY_RETRY = 10; 
private static final byte PACKETJTTL = 100; 

//Allow us to easily choose whether or not we want 
//to use the supplied means of locating the lookup 
//within the djinn. 


/ ** 

* Create a new <code>LookupFinder</code> object 
*/ 

public ServiceFinder() { 

} 

/** 

* Using the Jini lookup service returned by <code>locator</code> 

* find the service registered with a 

* <code>net.jini.lookup.entry.Name</code> attribute who's value 

* is <code>name</code>. If no service is registered under the 

* specified name retry until such a service appears. <p> This 

* method returns null if the lookup service can not be contacted. 

*/ 

public Object find (Locator locator. String name) { 

Object tmpobj = null; 

try { 

if (!(locator instanceof DiscoveryLocator)) 

throw new ClassCastException("LookupFinder: find: " + 

"locator must be a LookupLocator"); 

//by casting to ServiceRegistrar here, we 
//are implicitly checking if what is eventually 
//returned by find() is really an instance of 
//ServiceRegistrar. 

ServiceRegistrar registrar = (ServiceRegistrar)locator.locate() ; 

Entry[] attrs = new Entry[1]; 

Name n = new Name () ; 
n.name = name; 
attrs[0] = n; 


185 



ServiceTemplate tmpl = 

new ServiceTemplate(null, null, attrs); 

if (DEBUG) { 

System.out.printIn{"LookupFinder: find: name = " + name); 
System, out.println("LookupFinder: find: registrar = " + 

registrar); 

System.out.printIn("LookupFinder: find: tmpl = " + tmpl); 

> 

retry = 0; 
do { 

tmpobj = registrar.lookup(tmpl); 
if (tmpobj == null) { 
try { 

System.out.println("waiting for " + name); 
Thread.sleep(2000); 

} catch (Exception te) { 

} 

} 

retry++; 

} while (tmpobj == null && retry <10); 

} catch (Exception e) { 

System.out.println{"LookupLocator: find: " + e.getMessage()); 
e.printStackTrace()? 

} 

System, out .println ("found " + name +'' = "+ tmpobj) ; 
return tmpobj; 

> 

} 


186 


3. ServiceAccessor.java 

package tuplespace.core; 


import tuplespace. services - AgentServicelnterf ace ; 

import j ava.rmi .*; 

import java.awt.event.*? 

import ne t.jini.spac e.JavaSpac e; 

inport net.jini.core.transaction.server.TransactionManager 7 
irrport com. sun. jini .mahalo.TxnManagerlmpl; 

import com.sun.jini.mahout.binder.RefHolder; 
inport com.sun.jini.mahout.Locator; 
irrport com. sun. jini .outrigger .Finder 7 
import com. sun.jini.*; 

/** 

* The <code>ServiceAccessor</code> class implements the methods for 

* registering the Services 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 
*/ 

public class ServiceAccessor implements java.io.Serializable{ 
private static Locator locator; 

public static Locator getLocator( long lookupTimeout){ 
try { 

if (System.getSecurityManager() == null) { 

System. setSecurityManager( new RMISecurityManagerO); 

System.out.printIn(" Running RMISecurity Manager"); 

} 

locator = new com.sun.jini.outrigger.DiscoveryLocator(lookupTimeout) 
return locator; 

} catch (Exception e) { 
locator = null; 

System, err.println(e.getMessage()); 

} 

return null; 

} 

public static JavaSpace getSpace() { 
return getSpace("JavaSpaces"); 

} 

public static JavaSpace getSpace(String name) { 
try { 

if (System.getSecurityManager() == null) { 

System. setSecurityManager( new RMISecurityManager()); 

System.out.println(" Running RMISecurity Manager”); 

> 

if (System.getProperty("com.sun.jini.use.registry") == null) 

{ 

if(locator != null){ 

Finder finder = new ServiceFinder ()7 
return (JavaSpace)finder.find(locator, name) ; 

} 

} else { 

RefHolder rh - (RefHolder)Naming.lookup(name )7 
return (JavaSpace)rh.proxy{); 

> 

> catch (Exception e) { 

System, err.println(e.getMessage{)); 



> 

return null; 

) 

public static TransactionManager getManagerO { 

return getManager(com.sun.jini.mahalo.TxnManagerlmpl.DEFAULT_NAME) 

} 

public static TransactionManager getManager(String name) { 
try { 

if (System.getSecurityManager() == null) { 

System.setSecurityManager( new RMISecurityManager()); 
System.out.printIn{" Running RMISecurity Manager"); 

} 

if <System.getProperty("com.sun.jini.use.registry") == null) 

{ 

if(locator != null){ 

Finder finder = new ServiceFinder(); 

return (TransactionManager)finder.find(locator, name); 

} 

} else { 

RefHolder rh = (Ref Holder) Naming, lookup (name); 
return (TransactionManager) rh.proxy () ; 

> 

} catch (Exception e) { 

System, err.println(e.getMessage()); 

} 

return null; 

} 

} 


188 



4. SpaceEventRegistration.java 

package tuplespace.core; 


import tuplespace.entries.*; 
import net.jini.core.transaction.*; 

/ * * 

* The <code>SpaceEventRegistration</code> class implements the methods for 

* for registering with Space Service to monitor new entries written into 

* the space. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 
*/ 

public interface SpaceEventRegistration 

{ 

public abstract boolean startEvent <) ,- 

public abstract boolean startEventl(SpaceActionHandler spaceAction); 
public abstract boolean startEvent2(SpaceActionHandler spaceAction, long lease ); 
public abstract boolean startEvent3(SpaceActionHandler spaceAction, long lease , 
Transaction txn); 

public abstract boolean stopEventO; 

} 


TSConstants.j ava 
package tuplespace.core; 


public interface TSConstants { 

public static final int TS_INTEGER = 5000; 
public static final int TS_FLOAT = 5001; 
public static final int TS_LONG = 5002; 
public static final int TS_DOUBLE = 5003; 
public static final int TS_STRING = 5004; 
public static final int TS_QUEUE = 5005; 
public static final int TS_STACK = 5006; 
public static final int TS_LINKLIST = 5007; 
public static final int TS__HASH = 5008; 


public static final int TS_BOOLEAN = 5009; 

> 


189 




5. TSBase.java 

package tuplespace.core ? 

import tuplespace.entries.*; 

import net.jini.space.JavaSpace; 

import net.jini.core.entry.Entry; 

import net.jini.core.lease.Lease; 

import net.jini.core.transaction.*; 

import net.jini.core.event.EventRegistration; 

j * * 

* The <code>TSBase</code> class implements the methods for setting the 

* attribute of entry. Every entry handler will inherit this class 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 
*/ 

public class TSBase implements java.io.Serializable{ 
protected JavaSpace spacer- 

protected long writeLeaseTime, updateLeaseTime, notifyLeaseTime; 
protected long readTimeOut, takeTimeOut; 
protected String entrylD; 

protected EventRegistration eventRegistration; 
protected SpaceActionHandler spaceAction; 
protected Transaction transaction; 
protected boolean result; 

public TSBase<) { 

System.out.println{"TSBase Constructor"),- 

writeLeaseTime = Lease.FOREVER; 

updateLeaseTime = Lease.FOREVER; 

notifyLeaseTime =10000; //I minute 

readTimeOut = Long.MAX_VALUE; 

takeTimeOut = Long.MAX_VALUE; 

transaction = null; 

eventRegistration = null; 

spaceAction = null; 

space = null; 

result * false; 

} 

public void initTSBase(JavaSpace space, SpaceActionHandler spaceAction, String 
entrylD) 

{ 

this.space = space; 

this.entrylD = entrylD; 

this.spaceAction = spaceAction; 

> 

//*★*★★******★★*★*****★★****+*★********************^************** 

//*** Change Entry Setting 
* ★ * 

//**************************************************************** 

/** set space 

* ©param space JavaSpace handle */ 
public void setJavaSpace(JavaSpace space){ 

this.space = space; 

} 

/** set action listener 

* ©param spaceAction the class that implements the actionPerformed (ActionE'vent e) 

* method; called when remote event is raised. * I 

public void setSpaceActionHandler( SpaceActionHandler spaceAction){ 
this.spaceAction = spaceAction; 

} 

/** set action listener 


190 



* ©param spaceAction the class that implements the actionPerformed{ActionEvent e) 

* method; called when remote event is raised. */ 
public void setTransaetionHandler( Transaction trans){ 

this.transaction = trans; 

} 

public Transaction getTransactionHandler(){ 
return this - transaction; 

> 

/** set write lease time 

* ©param leaseTime the amount of time for entry to remain valid in space; 

* used when writing entry to space */ 
public void setWriteLeaseTime(long leaseTime){ 

this.writeLeaseTime = leaseTime; 

} 

/** get write lease time 

* ©return the current time setting for entry to remain valid in space*/ 
public long getWriteLeaseTime(){ 

return this.writeLeaseTime; 

> 

/** set update lease time 

* ©param leaseTime the amount of time for entry to remain valid in space; 

* used when updating an existing entry in space */ 
public void setUpdateLeaseTime{long leaseTime){ 

this.updateLeaseTime = leaseTime; 

} 

/** get update lease time 

* ©return the current time setting for entry to remain valid in space*/ 
public long getUpdateLeaseTime{){ 

return this.updateLeaseTime; 

} 

/** set read time out 

* ©param timeOut the maximum waiting time when reading an entry from space*/ 
public void setReadTimeOut{long timeOut){ 

this.readTimeOut = timeOut; 

> 

/** get read time out 

* ©return the current waiting time setting for reading an entry from space*/ 
public long getReadTimeOut{){ 

return this.readTimeOut; 

} 

/** set take time out 

* ©param timeOut the maximum waiting time when taking an entry from space*/ 
public void setTakeTimeOut(long timeOut){ 

this.takeTimeOut = timeOut; 

} 

/** get take time out 

* ©return the current waiting time setting for taking an entry from space*/ 
public long getTakeTimeOut(){ 

return this.takeTimeOut; » 

} 

/** For debugging purposes */ 
protected void print(String str){ 

System.out-printIn(str); 

} 

public void setResult(boolean value){ 
result = value; 

} 


191 


public boolean getResult(){ 
return result; 

} 

6. TS Constants 

package tuplespace.core; 

public interface TSConstants { 

public static final int TS_INTEGER = 5000; 

public static final int TSJFLOAT = 5001; 

public static final int TS_LONG = 5002; 

public static final int TS_DOUBLE = 5003; 

public static final int TS_STRING = 5004; 

public static final int TS_QUEUE = 5005; 

public static final int TS_STACK = 5006; 

public static final int TS_LINKLIST = 5007; 

public static final int TS_HASH = 5008; 
public static final int TSJBOOLEAN = 5009; 

} 


192 


TSBoolean.java 

package tuplespace.core; 

import tuplespace.entries.*; 

import tuplespace.entries.SpaceActionHandler; 

inport net.jini.space.JavaSpace; 

inport net.jini.core.entry.Entry; 

import net.jini.core.lease.Lease; 

import net.jini.core.transaction.*; 

inport net.jini.core.event.EventRegistration; 

j * * 

* The <code>TSBoolean</code> class implements the methods for reading, writing, 

* updating, notifying and retrieving EntryBoolean entry from space. Every 

* EntryBoolean entry in the space is identified by an unique ID (entrylD). 

* 

* A subclass that inplements the SpaceActionHandler interface has to loaded 

* during initialization if remote event notification is used. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 

* ©see EntryBoolean 
*/ 

public class TSBoolean extends TSBase inplements java.io.Serializable, 
SpaceEventRegistration, TSConstants{ 
private EntryBoolean entry, entryTemplate; 

/** Constructor for TSBoolean 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerfoxmed(ActionEvent e) 

* method, called when remote event is rised. 

* ©param entrylD the unique ID that identifies the Boolean Entry 
*/ 

public TSBoolean(JavaSpace space, SpaceActionHandler spaceAction, String entrylD) { 
super(); 

initTSBoolean(space, spaceAction, entrylD); 

> 

/** initialize TSBoolean 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerfoxmed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param entrylD the unique ID that identifies the Boolean Entry 

* ©return <tt>true</tt> if internal states are sucessfully reinitialized. 

*/ 

public boolean initTSBoolean(JavaSpace space, SpaceActionHandler spaceAction, String 
entrylD) 

{ 

try{ 

initTSBase(space, spaceAction, entrylD); 
entry = new EntryBoolean(entrylD); 
entryTemplate = new EntryBoolean(entrylD); 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 

/** Remove all existing entries from space */ 
public void cleanSpaceO 
{ 

cleanSpacel(null); 

} 

/** Remove all existing entries from space 
* ©param txn a valid transaction handle */ 
public void cleanSpacel(Transaction txn) 

{ 

Object test; 

193 



do{ 

try{ 

test = space.takelfExists(entryTemplate,txn,1000); 

//print("remove [" + entrylD + "] from space”); 

}catch (Exception e){ 
e.printStackTrace(); 
test = null; 

} 

}while(test ! = null); 

} 

//****************★*********************************************** 
//*** Write Entry 

//*★*************★****★******************************************* 

/** Writes value to space 

* ©param value the entry value (Boolean) 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean writel(boolean value){ 

return write3( value, this.writeLeaseTime, null); 

> 

/** Writes value to space 

* ©param value the boolean value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write2(boolean value, long lease){ 

return write3( value, lease, null); 


/** Writes value to space 

* ©param value the boolean value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write3(boolean value, long lease. Transaction txn){ 

try{ 

entry = new Ent ryBoo lean (this. entry ID, value); 
space.write(entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 

//***************★************************************************ 
//*** Update Entry 
* * ★ 

//**********★********************★**★***********************★***** 
/** Updates an existing entry value 

* ©param value the entry value (Boolean) to be updated 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 

public boolean updatel(boolean value) { 

return update3( value, this.updateLeaseTime, null); 

> 

/** Updates an existing entry value 

* ©param value the boolean value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update2(boolean value, long lease) { 

return update3{ value, lease, null); 


/** Updates an existing entry value 

* ©param value the boolean value that is to be updated 


194 




* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update3(boolean value, long lease, Transaction txn) 

{ 

try{ 

cleanSpacel(txn); 

entry = new EntryBoo lean (this .entry ID, value); 
space.write(entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace() ; 
return false; 

} 

} 


//*** Read Entry 

★ ★ * 


/** Reads an entry value 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 
public boolean readlfExists() 

{ 

return readIfExists2(this.readTimeOut, null); 

} 

/** Reads an entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean readlfExistsl(long timeOut) 

{ 

return readIfExists2(timeOut, null); 

} 

/** Reads an entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean readIfExists2(long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try{ 

entry = (EntryBoo lean) space. readlf Exists (entryTeirpl ate, txn, timeOut) 
if( entry != null) 

{ 

this.setResult(true); 

return entry.entryBoolean.booleanValue(); 

> 

else 

return false; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 


//*** Take Entry 

* * * 


195 



/** Takes an entry value; entry will be removed from space 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 
public boolean takelfExists{) 

{ 

return takelfExistsi{this.takeTimeOut); 

} 

/** Takes an entry value; entry will be removed from space 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean takelfExistsl( long timeOut) 

{ 

return takelfExists2(timeOut, null); 

} 

/** Takes an entry value; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean takelfExists2( long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try{ 

entry = (EntryBoolean) space.takelfExists(entryTemplate, txn, timeOut); 
if{ entry != null) 

{ 

this. setResult (true) ; 

return entry.entryBoolean.booleanValue () ; 

> 

else 

return false; 

} 

catch {Exception e){ 

e-printStackTrace{); 
return false; 

} 

> 


//**************************************************************** 

//*** Notify 

* * * 

//**************** ************************************************ 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventO 

{ 

return startEvent3(this.spaceAction, this.notifyLeaseTime, null ); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventl(SpaceActionHandler spaceAction) 

{ 

return startEvent3(spaceAction, this.notifyLeaseTime, null ); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 


196 




* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent2(SpaceActionHandler spaceAction, long lease ) 

{ 

return startEvent3(spaceAction, lease , null); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* @param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent3(SpaceActionHandler spaceAction, long lease , Transaction 
txn) 

{ 

try{ 

// Remove earlier event notification 
if(eventRegistration != null) 

eventRegistration.getLease().cancel(); 

// Register new event notification 

SpaceEventListener listener = new SpaceEventListener(TS_BOOLEAN, entrylD, 
space, spaceAction) ,- 

eventRegistration = space.notify(entryTemplate, txn, listener, lease, null); 
return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 

/** Stop notification 

* ©return <tt>true</tt> if notification is disabled. */ 
public boolean stopEvent(){ 

try{ 

if{ eventRegistration != null) 

{ 

eventRegistration.getLease{).cancel 0; 
eventRegistration = null; 

} 

return true; 

} 

catch (Exception e){ 
return false; 

} 

} 


//*****************************************************★********** 
//*** Transaction Methods 
* * * 

//**************************★************************************* 
/** writes entry value with transaction 

* ©param value the boolean value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transWrite(boolean value, long lease) 

{ 

return write3(value,lease,this.getTransactionHandler()); 

) 

/** Updates an existing entry value with transaction 

* ©param value the boolean value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 


197 



public boolean transUpdate(boolean value, long lease) 

{ 

return update3(value,lease,this.getTransactionHandler()),- 

} 

/** Reads an entry value with transaction 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method «”</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean transRead(long timeOut) 

{ 

return readIfExists2(timeOut, this.getTransactionHandler()); 

} 

/** Takes an entry value with transaction; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean transTake( long timeOut) 

{ 

return takeIfExists2(timeOut, this.getTransactionHandler()); 

} 

} 


198 



7. TSDouble.java 

package tuplespace.core; 

import tuplespace.entries.*; 

import net.jini.space.JavaSpace; 

import net.jini.core.entry.Entry; 

import net.jini.core.lease.Lease ? 

import net.jini.core.transaction.* ? 

import net.jini.core.event.EventRegistration; 

f * * 

* The <code>TSDouble</code> class implements the methods for reading, writing, 

* updating, notifying and retrieving EntryDouble entry from space. Every 

* EntryDouble entry in the space is identified by an unique ID (entrylD). 

* 

* A subclass that implements the SpaceActionHandler interface has to loaded 

* during initialization if remote event notification is used. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 

* ©see EntryDouble 
*/ 


public class TSDouble extends TSBase implements java.io.Serializable, 
SpaceEventRegistration, TSConstants{ 
private EntryDouble entry, entryTemplate; 

/** Constructor for TSDouble 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method, called when remote event is rised. 

* ©param entry ID the unique ID that identifies the Double Entry 
*/ 

public TSDouble(JavaSpace space, SpaceActionHandler spaceAction, String entrylD) { 
super(); 

initTSDouble(space, spaceAction, entrylD); 

} 

/** initialize TSDouble 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param entrylD the unique ID that identifies the Double Entry 

* ©return <tt>true</tt> if internal states are sucessfully reinitialized. 

*/ 

public boolean initTSDouble(JavaSpace space, SpaceActionHandler spaceAction, String 
entrylD) 

{ 

try{ 

initTSBase(space, spaceAction, entrylD); 
entry = new EntryDouble (entrylD) ; 
entryTemplate = new EntryDouble(entrylD); 
eventRegistration = null; 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 

/** Remove all existing entries from space */ 
public void cleanSpaceO 
{ 

cleanSpacel(null); 

} 

/** Remove all existing entries from space 
* ©param txn a valid transaction handle */ 
public void cleanSpacel(Transaction txn) 

{ 


199 



Object test; 
do{ 

try { 

test = space.takelfExists(entryTemplate,txn,1000); 
//print("remove [" + entrylD + "3 from space"); 

}catch (Exception e){ 
e.printStackTrace(); 
test = null; 

} 

}while(test != null); 


//*** Write Entry 

★ ★ 


/** Writes value to space 

* ©param value the entry value (Double) 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean writel(double value) 

{ 

return write3( value, this.writeLeaseTime, null); 

} 

/** Writes value to space 

* ©param value the double value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write2(double value, long lease) 

{ 

return write3 ( value, lease, null) ,- 
} 

/** Writes value to space 

* ©param value the double value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write3(double value, long lease, Transaction txn) 

{ 

try{ 

entry = new EntryDouble (this. entrylD, valued- 
space, write (entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

> 


//**************************************************************^ 
//*** Update Entry 
* * + 

//**************************************************************** 
/** Updates an existing entry value 

* ©param value the entry value (Double) to be updated 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean updatel(double value) 

{ 

return update3( value, this.updateLeaseTime, null); 

> 

/** Updates an existing entry value 

* ©param value the double value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 


200 


public boolean update2(double value, long lease) 

{ 

return update3 { value, lease, null),* 

} 

/** updates an existing entry value 

* ©param value the double value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update3(double value, long lease. Transaction txn) 

{ 

try{ 

cleanSpacel(txn); 

entry = new EntryDouble(this.entrylD, value); 
space.write(entry, txn, lease); 

return true; 

) 

catch (Exception e){ 

e.printStackTrace(); 
return false,- 

} 

} 


^**************************************************************** 
//*** R ea d Entry 

* * * 

//**************************************************************** 
/** Reads an entry value 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 
public double readlfExists() 

{ 

return readlfExists2(this.readTimeOut, null); 

} 


/** Reads an entry value 

* ©param timeout the maximum waiting time when reading the entry from space 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public double readlfExistsl(long timeOut) 

{ 

return readlfExists2(timeOut, null); 

} 

/** Reads an entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public double readlfExists2(long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try { 

entry = (EntryDouble) space.readlfExists(entryTemplate, txn, timeOut) 
if( entry != null) 

{ 

this.setResult(true); 

return entry.entryDouble.doubleValue(); 

} 

else 

return -1; 

) 

catch (Exception e){ 

e.printStackTrace(); 
return -1; 

) 


201 



} 


//**************************************************************** 

//*** Take Entry 

** * 

//a*************************************************************** 

/** Takes an entry value; entry will be removed from space 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public double takelfExists() 

{ 

return takelfExistsl(this.takeTimeOut); 

} 

/** Takes an entry value? entry will be removed from space 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public double takelfExistsl( long timeout) 

{ 

return takeIfExists2(timeOut, null); 

} 

/** Takes an entry value; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public double takeIfExists2( long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try { 

entry = (EntryDouble) space.takelfExists(entryTemplate, txn, timeOut) 
if{ entry != null) 

{ 

this.setResult(true)? 

return entry.entryDouble.doublevalue()? 

} 

else 

return -1? 

> 

catch (Exception e){ 
e.printStackTrace(}; 

return -1? 

} 

} 


//★★★★a*********************************************************** 

//*** Notify 

* * * 

//**************************************************************** 

/** Start notification; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEvent() 

{ 

return startEvent3(this.spaceAction, this.notifyLeaseTime, null ); 

} 

/** Start notification? remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method? called when remote event is raised. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventl(SpaceActionHandler spaceAction) 

{ 

return startEvent3(spaceAction, this.notifyLeaseTime, null ); 


202 



} 


/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent2(SpaceActionHandler spaceAction, long lease ) 

{ 

return startEvent3(spaceAction, lease , null); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent3(SpaceActionHandler spaceAction, long lease , Transaction 
txn) 

{ 

try{ 

// Remove earlier event notification 
if(eventRegistration != null) 

eventRegistration.getLease().cancel(); 

// Register new event notification 

SpaceEventListener listener = new SpaceEventListener(TS_DOUBLE, entrylD, 
space,spaceAction); 

eventRegistration = space.notify(entryTemplate, txn, listener, lease, null); 
return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 

/** Stop notification 

* ©return <tt>true</tt> if notification is disabled. */ 
public boolean stopEvent(){ 

try{ 

if( eventRegistration != null) 

{ 

eventRegistration.getLease().cancel(); 
eventRegistration = null; 

} 

return true; 

} 

catch (Exception e){ 
return false; 

} 

> 


//**************************************************************** 
//*** Transaction Methods 
★ * 

//******************★********************************************* 
/** Writes entry value with transaction 

* ©param value the boolean value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this. transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transWrite(double value, long lease) 

{ 

return write3(value,lease,this.getTransactionHandler()); 


203 



} 

/** Updates an existing entry value with transaction 

* ©param value the boolean value that is to be written to space 

* @param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transUpdate(double value, long lease) 

{ 

return update3 (value, lease, this.getTransactionHandler () ) 

} 

/** Reads an entry value with transaction 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public double transRead(long timeOut) 

{ 

return readIfExists2(timeOut, this.getTransactionHandler()); 

} 

/** Ta-kes an entry value with transaction; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param this.transaction must be a valid transaction handle 

* ^return <tt> M Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public double transTake( long timeOut) 

{ 

return takeIfExists2(timeOut, this.getTransactionHandler()); 

} 


8 , 


TSLong.java 


package tuplespace.core? 

import tuplespace.entries.*? 

import net.jini.space.JavaSpace? 

import net.jini.core.entry- Entry ; 

import net.jini.core.lease.Lease; 

import net.jini.core.transaction.*; 

import net.jini.core.event-EventRegistration? 

/** 

* The <code>TSLong</code> class implements the methods for reading, writing, 

* updating, notifying and retrieving EntryLong entry from space. Every 

* EntryLong entry in the space is identified by an unique ID (entrylD) . 

* 

* A subclass that implements the SpaceActionHandler interface has to loaded 

* during initialization if remote event notification is used. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 September 2000 

* ©see EntryLong 
*/ 


public class TSLong extends TSBase implements java.io.Serializable, 

SpaceEventRegistration, TSConstants{ 
private EntryLong entry, entryTemplate; 

/** Constructor for TSLong 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method, called when remote event is rised. 

* ©param entrylD the unique ID that identifies the Long Entry 
*/ 

public TSLong(JavaSpace space, SpaceActionHandler spaceAction, String entrylD) { 
super{); 

initTSLong(space, spaceAction, entrylD); 

} 

/** initialize TSLong 

* ©param space JavaSpace handle 

* ©param spaceAction the class that irrplements the actionPerformed(ActionEvent e) 

* method? called when remote event is raised. 

* ©param entrylD the unique ID that identifies the Long Entry 

* ©return <tt>true</tt> if internal states are sucessfully reinitialized. 

*/ 

public boolean initTSLong(JavaSpace space, SpaceActionHandler spaceAction, String 
entrylD) 

{ 

try { 

initTSBase(space, spaceAction, entrylD) 
entry = new EntryLong (entrylD) ; 
entryTemplate = new EntryLong(entrylD); 
eventRegistration = null; 
return true; 

} 

catch(Exception e){ 
return false; 

} 

> 

/** Remove all existing entries from space */ 
public void cleanSpaceO 
{ 

cleanSpacel(null)? 

> 

/** Remove all existing entries from space 
* ©param txn a valid transaction handle */ 


205 



public void cleanSpacel(Transaction txn) 

{ 

Object test; 
do{ 

try{ 

test = space.takelfExists(entryTemplate,txn,1000); 

//print("remove [" + entrylD + "] from space"); 

}catch (Exception e){ 
e.printStackTrace() ; 
test = null; 

} 

}while(test ! = null); 

} 

//********************************■******************************** 
//*** Write Entry *** 

//**************************************************************** 


/** Writes value to space 

* ©param value the entry value (Long) 

* ^return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean writel(long value) 

{ 

return write3( value, this .writeLeaseTime, null); 

} 

/** Writes value to space 

* @param value the long value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write2(long value, long lease) 

{ 

return write3( value, lease, null); 

} 

/** Writes value to space 

* ©param value the long value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write3(long value, long lease. Transaction txn) 

{ 

try{ 

entry = new EntryLong (this .entrylD, valued- 
space, write (entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 


//********★******************************************************* 
//*** Update Entry *** 

//★★Hr************************************************************* 

/** Updates an existing entry value 

* ©param value the entry value (Long) to be updated 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean updatel(long value) 

{ 

return update3( value, this.updateLeaseTime, null); 

} 

/** Updates an existing entry value 

* ©param value the long value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 


206 



public boolean update2(long value, long lease) 

{ 

return update3{ value, lease, null); 

} 

/** Updates an existing entry value 

* ©param value the long value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update3(long value, long lease. Transaction txn) 

{ 

try{ 

cleanSpacel(txn),- 

entry = new EntryLong(this.entrylD, value); 
space.write(entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 


//★★★★•a*********************************************************** 

//*** Read Entry *** 

//*******************************************★******************** 

/** Reads an entry value 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 
public long readlfExists() 

{ 

return readIfExists2(this.readTimeOut, null); 

} 

/** Reads an entry value 

* @param timeout the maximum waiting time when reading the entry from space 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public long readlfExistsl{long timeOut) 

{ 

return readIfExists2(timeOut, null); 

> 

/** Reads an entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public long readIfExists2(long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try { 

entry = (EntryLong) space.readlfExists(entryTemplate, txn, timeOut); 
if( entry != null) 

{ 

this.setResult(true); 

return entry.entryLong.longValue(); 

} 

else 

return -1; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return -1; 

} 

> 


207 




//★★★★fr*********************************************************^ 

//*** Take Entry *** 

//**************************************************************** 

/** Takes an entry value; entry will be removed from space 

* @retum <tt>-l</tt> if entry is not available/ otherwise 

* the entry value. */ 
public long takelfExists() 

{ 

return takelfExistsi(this.takeTimeOut); 

> 

/** Takes an entry value; entry will be removed from space 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public long takelfExistsl{ long timeOut) 

{ 

return takelfExists2(timeOut, null); 

} 

/** Takes an entry value; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 

public long takeIfExists2{ long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try{ 

entry = (EntryLong) space.takelfExists (entryTemplate, txn, timeOut) 
if{ entry != null) 

{ 

this.setResult(true); 

return entry.entryLong.longValue() ; 

} 

else 

return -1; 

} 

catch (Exception e){ 
e.printStackTrace()? 

return -1; 

> 

} 


//***★★***r******************************************************** 

//*** Notify *** 

//**************************************************************** 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventO 

{ 

return startEvent3{this.spaceAction, this.notifyLeaseTime, null ); 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventl(SpaceActionHandler spaceAction) 

{ 

return startEvent3 (spaceAction, this .notifyLeaseTime, null ),- 

} 

/** Start notificiation; remote event will be raised if any entry 


208 



* that matches the entry ID is added into the space. 

* @param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent2(SpaceActionHandler spaceAction, long lease ) 

{ 

return startEvent3(spaceAction, lease , null); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent3(SpaceActionHandler spaceAction, long lease , Transaction 
txn) 

{ 

try{ 

// Remove earlier event notification 
if(eventRegistration != null) 

eventRegistration.getLease().cancel(); 

// Register new event notification 

SpaceEventListener listener = new SpaceEventListener(TS_LONG, entrylD, 
space,spaceAction); 

eventRegistration = space.notify(entryTemplate, txn, listener, lease, null); 
return true; 

) 

catch (Exception e){ 

e.printstackTrace()? 
return false; 

} 

) 

/** Stop notification 

* ©return <tt>true</tt> if notification is disabled. */ 
public boolean stopEvent(){ 

try{ 

if( eventRegistration != null) 

{ 

eventRegistration.getLease().cancel(); 
eventRegistration = null; 

} 

return true; 

> 

catch (Exception e){ 
return false; 

} 

) 


//********************************★********★***★*********★**★****★ 
//*** Transaction Methods *** 

//***********★***★***************★******************************** 

/** Writes entry value with transaction 

* ©param value the long value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this. transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transWrite(long value, long lease) 

{ 

return write3(value,lease,this.getTransactionHandler()) ; 

> 

/** Updates an existing entry value with transaction 

* ©param value the long value that is to be written to space 

* ©param lease the amount of time entry is placed in space 


209 




* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transUpdate(long value, long lease) 

{ 

return update3(value,lease,this.getTransactionHandler())? 

} 

/** Reads an entry value with transaction 

* ©param timeout the maximum waiting time when reading the entry from space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method ! M </tt> if entry is not available, otherwise 

* the entry value. */ 

public long transRead(long timeOut) 

{ 

return readIfExists2(timeOut, this.getTransactionHandler()); 

} 

/** Takes an entry value with transaction; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public long transTake( long timeOut) 

{ 

return takelfExists2(timeOut, this.getTransactionHandler()); 

} 


210 




9. TSHash.java 

package tuplespace.core; 

import tuplespace.entries.*; 

import java.util.HashMap; 

import net-jini.space.JavaSpace; 

import net.jini.core.entry.Entry; 

import net.jini.core.lease.Lease; 

import net.jini.core.transaction.*; 

import net.jini.core.event.EventRegistration; 


f * * 

* The <code>TSHash</code> class implements the methods for reading, writing, 

* updating, notifying and retrieving EntryHash entry from space. Every 

* EntryHash entry in the space is identified by an unique ID (entrylD). 

* A subclass that implements the SpaceActionHandler interface has to loaded 

* during initialization if remote event notification is used. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 

* ©see EntryHash 
*/ 


public class TSHash extends TSBase implements java.io.Serializable, 
SpaceEventRegistration, TSConstants{ 
private EntryHash entry, entryTemplate; 
private HashMap container; 

/** Constructor for TSHash 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEveht 

* method, called when remote event is rised. 

* ©param entrylD the unique ID that identifies the Hash Entry 
*/ 

public TSHash(JavaSpace space, SpaceActionHandler spaceAction, String entrylD) { 
super(); 

initTSHash{space, spaceAction, entrylD); 

} 

/** initialize TSHash 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent 

* method; called when remote event is raised. 

* ©param entrylD the unique ID that identifies the Hash Entry 

* ©return <tt>true</tt> if internal states are sucessfully reinitialized. 

*/ 

public boolean initTSHash(JavaSpace space, SpaceActionHandler spaceAction, 
entrylD) 

{ 

try{ 

initTSBase(space, spaceAction, entrylD); 
container = new HashMap(); 
entry = new EntryHash(entrylD); 
entryTemplate - new EntryHash(entrylD); 
eventRegistration = null; 
return true; 

} 

catch(Exception e){ 
return false; 

} 

> 

/** Remove all existing entries from space */ 
public void cleanSpace() 

{ 

cleanSpacel(null); 

} 

/** Remove all existing entries from space 


e) 


String 


211 




* @param txn a valid transaction handle */ 
public void cleanSpacel(Transaction txn) 

{ 

Object test; 
do{ 

try{ 

test = space, takelfExists (entryTemplate, txn, 1000) ; 
//print{"remove [" + entrylD + "] from space"); 
>catch (Exception e){ 
e.printStackTrace() ; 
test = null; 

} 

}while(test != null); 

} 


//****★***************★***************************** 

//*** HashMap Operation *** 

//*★***★******************************************** 
public boolean clearContainer(){ 
container - new HashMap(); 
return true; 


public HashMap getContainer{){ 
return container ; 

} 

public void getContainer(HashMap map){ 
container = map; 

> 

public boolean setBoolean(String id, boolean value){ 
try{ 

container.put(id,new Boolean(value)); 
return true; 

> 

catch(Exception e){ 
return false; 

} 

} 

public boolean setlnteger(String id, int value){ 
try{ 

container.put(id,new Integer(value)); 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 

public boolean setFloat(String id, float value){ 
try{ 

container.put(id,new Float(value)); 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 

public boolean setLong(String id, long value){ 
try{ 

container.put(id,new Long(value)); 
return true; 

} 

catch(Exception e){ 
return false; 

} 


212 



public boolean setDouble{String id, double value){ 
try{ 

container.put(id,new Double(value)); 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 

public boolean setstring(String id, String content){ 
try{ 

container.put(id,content); 
return true; 

) 

catch(Exception e){ 
return false; 

> 

> 

public boolean remove{String id){ 
if(container.containsKey(id)){ 
container.remove(id); 
return true; 

} 

else{ 

return false; 

} 

} 

public int getlnteger(String id){ 

Integer item; 
try{ 

item = (Integer) container.get(id); 
return item.intValue(); 

} catch (Exception e) { 

System.err.printIn(e.getMessage()); 
return -1? 

> 

} 

public boolean getBoolean(String id){ 

Boolean item; 
try{ 

item = (Boolean) container.get(id)? 
return item.booleanValue(); 

} catch (Exception e) { 

Systern.err.println(e.getMessage()); 
return false; 

} 

} 


public float getFloat(String id){ 

Float item; 
try{ 

item = (Float) container.get(id); 
return item.floatValue(); 

} catch (Exception e) { 

System.err.println(e.getMessage()); 
return -1; 

} 

} 

public long getLong{String id){ 

Long item; 
try{ 

item = (Long) container.get(id); 


213 




return item.longValue(); 

} catch (Exception e) { 

System.err.printIn(e.getMessage()); 
return -1; 

} 

} 

public double getDouble(String id){ 

Double item; 
try { 

item = (Double) container.get(id); 
return item.doubleValue(); 

} catch (Exception e) { 

System.err.println(e.getMessage()); 
return -1; 

> 

} 

public String getString(String id) { 

String item; 
try{ 

item = (String) container.get(id); 
return item; 

} catch (Exception e) { 

System.err.println(e.getMessage()); 

return "Error finding ID["+id+"] in Hash Map"; 

} 

} 


//**************************************************************** 
//*** Write Entry 

★ * * 

//**************************************************************** 
/** Writes value to space 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write() 

{ 

return write2( this.writeLeaseTime, null); 

} 

/** writes value to space 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean writel( long lease) 

{ 

return write2( lease, null); 

} 

/** Writes value to space 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write2( long lease. Transaction txn) 

{ 

try { 

entry = new EntryHash(this.entryID, container); 
space.write(entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printstackTrace(); 
return false; 

} 

} 




214 



//*** Update Entry 

* * * 

//*************************************************★************** 

/** Updates an existing entry value 

* @param value the entry value (Hash) to be updated 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update() 

{ 

return update2( this.updateLeaseTime, null); 

} 

/** Updates an existing entry value 

* ©param value the double value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean updatel( long lease) 

{ 

return update2( lease, null); 

} 

/** Updates an existing entry value 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update2( long lease, Transaction txn) 

{ 

try{ 

cleanSpacel(txn); 

entry = new EntryHash(this.entrylD, container); 
space.write(entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 


//*********************★** ***************************** *********** 

//*** Read Entry 

★ * * 

//★*•******* *********************************************** ******** 

/** Read entry value 

* ©return <tt>-l</tt> if entry is not available, otherwise 

* the entry value. */ 
public boolean readlfExists() 

{ 

return readlfExists2(this.readTimeOut, null); 

} 

/** Read entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean readlfExistsi(long timeOut) 

{ 

return readlfExists2(timeOut, null); 

} 

/** Read entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean readlfExists2(long timeOut, Transaction txn) 

{ 


215 



this.setResult(false) ; 
try{ 

entry = (EntryHash) space.readlfExists(entryTemplate, txn, timeOut); 
if( entry != null) 

{ 

this.setResult(true); 
container = entry, get Ha shMap {) ,- 
return true; 

} 

else 

return false; 

} 

catch (Exception e){ 

e.printstackTrace()? 
return false; 

} 


//**************************************************************** 

//*** Take Entry 

* * * 

//****★*********************************************************** 

/** Take entry value; entry will be removed from space 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 
public boolean takelfExists() 

{ 

return takelfExistsl(this.takeTimeOut)? 

} 

/** Take entry value? entry will be removed from space 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean takelfExistsl( long timeOut) 

{ 

return takelfExists2(timeOut, null); 

} 

!** Take entry value? entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>false</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean takeIfExists2( long timeOut, Transaction txn) 

{ 

this.setResult{false)? 
try{ 

entry = (EntryHash) space.takelfExists(entryTemplate, txn, timeOut) 
if( entry != null) 

{ 

this.setResult(true)? 
container = entry.getHashMap(); 
return true? 

> 

else 

return false? 

} 

catch (Exception e){ 
e .printStackTrace () 

return false; 

} 

} 


//*** Notify 



/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventO 

{ 

return startEvent3(this.spaceAction, this.notifyLeaseTime, null ); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventl(SpaceActionHandler spaceAction) 

{ 

return startEvent3(spaceAction, this.notifyLeaseTime, null ); 

> 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the ac tionPer formed (Act ionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent2(SpaceActionHandler spaceAction, long lease } 

{ 

return startEvent3(spaceAction, lease , null); 

} 

/** start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent3(SpaceActionHandler spaceAction, long lease , Transaction 
txn) 

{ 

try{ 

// Remove earlier event notification 
if(eventRegistration != null) 

eventRegistration.getLease().cancel(); 

// Register new event notification 

SpaceEventListener listener = new SpaceEventListener(TS_HASH, entrylD, 
space,spaceAction); 

eventRegistration = space.notify(entryTemplate, txn, listener, lease, null); 
return true; 

) 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 

/** Stop notification 

* ©return <tt>true</tt> if notification is disabled. */ 
public boolean stopEvent(){ 

try{ 

if( eventRegistration != null) 

{ 

eventRegistration.getLease().cancel 0; 
eventRegistration = null; 

} 

return true; 

} 

catch (Exception e){ 


217 



return false; 



//*** Transaction Methods 
* * * 


/** Writes entry value with transaction 

* ©param value the float value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transWrite{ long lease) 

{ 

return write2(lease,this.getTransactionHandler ()); 

} 

/** Updates an existing entry value with transaction 

* ©param value the float value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transUpdate( long lease) 

{ 

return update2(lease,this.getTransactionHandler()); 

} 

/** Reads an entry value with transaction 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean transRead(long timeOut) 

{ 

this.setResult(false)? 
try { 

entry - (EntryHash) space.readlfExists (entryTemplate, 

this.getTransactionHandler(), timeOut); 
if( entry «= null) 

{ 

this.setResult(true); 
container = entry.getHashMap(); 
return true; 

} 

else 

return false; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

> 

} 

/** Takes an entry value with transaction; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param this. transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public boolean transTake( long timeOut) 

{ 

this.setResult(false); 
try{ 

entry = (EntryHash) space.takelfExists(entryTemplate, 

this.getTransactionHandler(), timeOut); 
if( entry != null) 

{ 


this.setResult(true); 
container = entry.getHashMap(); 


218 



return true; 


} 

else 

return false; 

> 

catch {Exception e){ 
e.printStackTrace(); 

return false; 

} 

> 

} 


219 



10. TSQueue.java 

package tuplespace.core; 

import tuplespace.entries.* ? 

import net.jini.space.JavaSpace; 

import net.jini.core.entry.Entry; 

import net.jini.core.lease.Lease,- 

import net.jini.core.transaction.*; 

import net.jini.core.event.EventRegistration; 

f * * 

* The <code>TSQueue</code> class implements the methods for reading, writing, 

* updating, notifying and retrieving EntryQueue entry from space. Every 

* EntryQueue entry in the space is identified by an unique ID (entrylD). 

* A subclass that implements the SpaceActionHandler interface has to loaded 

* during initialization if remote event notification is used. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 

* ©see EntryQueue 
*/ 

public class TSQueue extends TSBase implements java.io.Serializable, 

SpaceEventRegistration, TSConstants{ 
private EntryQueueltem item, itemTemplate; 
private EntryQueueStatus status, statusTemplate,- 
private long bufferSize; 

/** Constructor for TSQueue 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method, called when remote event is rised. 

* ©param entrylD the unique ID that identifies the Queue Entry 
*/ 

public TSQueue(JavaSpace space, SpaceActionHandler spaceAction, String entrylD, long 
size) { 

super(); 

initTSQueue(space, spaceAction, entrylD, size); 

} 

/** initialize TSQueue 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param entrylD the unique ID that identifies the Queue Entry 

* ©return <tt>true</tt> if internal states are sucessfully reinitialized. 

*/ 

public boolean initTSQueue(JavaSpace space, SpaceActionHandler spaceAction, String 
entrylD, long size) 

{ 

this.bufferSize = size; 
try { 

initTSBase(space, spaceAction, entrylD); 
item = new EntryQueue I tern (entry ID) ; 
itemTemplate = new EntryQueueltem (entrylD) ; 

status = new EntryQueueStatus(entrylD,size); 
statusTemplate = new EntryQueueStatus (entrylD) ,- 
initQueueIndexes() ; 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 

/** Initialize */ 

private boolean initQueuelndexes() 


220 



{ 

try{ 

status = (EntryQueueStatus) space.read(statusTemplate,null,2000) 
if(status == null ){ 
cleanSpace{); 

status = new EntryQueueStatus(entrylD,bufferSize); 
space.write(status,null, Lease.FOREVER); 
print{"Initialized! TSQueue"); 
return true; 

> 

else 

return false; 

}catch (Exception e){ 

e.printStackTrace() ; 
return false; 

} 

} 

/** Remove all existing entries from space */ 
public void cleanSpace() 

{ 

cleanSpacel(null); 

> 

/** Remove all existing entries from space 

* @param txn a valid transaction handle */ 
public void cleanSpacel(Transaction txn) 

{ 

Object test; 
do{ 

try{ 

test = space.takelfExists(statusTemplate,txn,2000); 
print("removing stack Start Index from space"); 

}catch (Exception e){ 
e.printStackTrace(); 
test = null; 

> 

}while(test != null); 
do{ 

try{ 

test = space. takelf Exists (itemTernplate, txn, 2000) ; 
print("removing stack item from space"); 

}catch (Exception e){ 
e.printStackTrace(); 
test = null; 

> 

}while(test != null); 

} 

/** Remove all existing entries from space */ 
public void cleanltern(long index) 

{ 

cleanlteml (null, index); 

} 

/** Remove all existing entries from space 

* @param txn a valid transaction handle */ 
public void cleanlteml(Transaction txn, long index) 

{ 

Object test; 
do{ 

try { 

EntryQueueltem itemTmp = new EntryQueueltem(entrylD); 

itemTmp.position = new Long(index); 

test = space.takeIfExists(itemTmp,txn,1000); 

print("removing stack item from space"); 

}catch (Exception e){ 


221 



e.printStackTrace{)? 
test = null; 

} 

}while(test != null); 

} 


/** Remove all existing entries from space * I 
public void cleanStatus() 

{ 

cleanStatusl(null)? 

} 

/** Remove all existing entries from space 
* ©param txn a valid transaction handle */ 
public void cleanStatusl(Transaction txn) 

{ 

Object test; 
do{ 

try{ 

EntryQueueStatus itemTmp = new EntryQueueStatus(entrylD); 
test = space.takelfExists(itemTmp,txn,1000); 
print ("removing stack item from space"}; 

}catch (Exception e){ 
e.printStackTrace(); 
test - null; 

} 

}while(test != null); 

} 


public String readKlong index) { 
try{ 

itemTemplate.position = new Long(index) ; 

item = (EntryQueueltern) space.readlfExists(itemTemplate,null,2000); 
if(item •= null){ 

print("Queue item[" + index + "] -> " + item.content); 
return item.content; 

} 

else 

return null; 

} catch(Exception e){ 
e.printStackTrace(); 
return null; 

} 

} 

/** Updates an existing entry value 

* @param value the String value that is to be updated 

* @param lease the amount of time entry is placed in space 

* @param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 

private boolean update3(String msg, long lease, Transaction txn, long index) 
{ 

try{ 

cleanlteml(txn, index); 

item = new EntryQueueItem(entryID,index,msg); 
space.write(item, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace() ; 
return false; 

) 

} 

public String take{){ 
return takel(null); 

> 


public String takel( Transaction txn){ 
long startIndex; 


222 



try{ 

status = (EntryQueueStatus) space.readlfExists (statusTemplate,txn,2000); 
if{status i= null){ 

if(!status.isEmpty()){ 
startlndex = status.startIndex.longValue(); 
itemTemplate.position = new Long(startlndex); 

item = (EntryQueueltem) space.takelfExists(itemTemplate,txn,2000); 
status.incrementStartlndex {); 
cleanStatusl(txn)? 

space.write{status,txn. Lease.FOREVER); 

print("Queue item[" + startlndex + "3 -> " + item.content)? 
return item, content? 

} 


} 

return null? 

}catch{Exception e){ 
e.printstackTrace{)? 
return null? 

} 

} 

public boolean writel(String msg){ 
return write2(msg,null)? 

} 

public boolean write2(String msg. Transaction txn){ 
long nextIndex; 
try{ 

status = (EntryQueueStatus) space.readlfExists(statusTemplate,txn,2000); 
if(status != null ){ 

if( !status.isFull()){ 

status.incrementEndlndex()? 

nextIndex = status.endlndex.longValue()? 

print("Written! " + msg + " to space" + " Index->" + nextIndex)? 
update3(msg. Lease.FOREVER, txn,nextIndex); 
cleanStatusl(txn)? 

space.write(status,txn, Lease.FOREVER)? 
return true; 

} 

> 

return false; 

} catch (Exception e){ 
e.printstackTrace()? 
return false? 

> 

} 

public void printQueue(){ 
try{ 

status a (EntryQueueStatus) space.read(statusTemplate,null,2000); 
print("Start Index : " + status.getStartlndex() + " End Index 

status.getEndlndex())? 

for(long i = status.getStartlndex()? i <= status.getEndlndex()?i++) 

{ 

itemTeirplate.position = new Long(i) ? 

item = (EntryQueueltem) space.readlfExists(itemTemplate,null,2000)? 
if(item != null) 

print("Queue item[" + i + "3 -> " + item.content); 

} 

} catch (Exception e){ 
e.printStackTrace{)? 

} 

} 




223 


//*** Notify 


* * * 




/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ^return <tt>true</tt> if notification is enabled- */ 
public boolean startEventO 

{ 

return startEvent3(this.spaceAction, this.notifyLeaseTime, null ); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventl(SpaceActionHandler spaceAction) 

{ 

return startEvent3{spaceAction, this.notifyLeaseTime, null ); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent2(SpaceActionHandler spaceAction, long lease ) 

return startEvent3(spaceAction, lease , null); 

} 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent3(SpaceActionHandler spaceAction, long lease , Transaction 
txn) 

{ 

try{ 

// Remove earlier event notification 
if(eventRegistration != null) 

eventRegistration.getLease().cancel (); 

// Register new event notification 
itemTemplate = new EntryQueueltem(entrylD) ; 

SpaceEventListener listener = new SpaceEventListener(TS_QUEUE, entrylD, 
space,spaceAction),- 

eventRegistration = space.notify(itemTemplate, txn, listener, lease, null)? 
return true; 

} 

catch (Exception e){ 

e.printStackTrace()? 
return false? 

} 

} 

/** Stop notification 

* ©return <tt>true</tt> if notification is disabled. */ 
public boolean stopEvent{){ 

try { 

if( eventRegistration != null) 

{ 


eventRegistration.getLease{).cancel (); 
eventRegistration = null; 


224 


} 

return true; 

} 

catch (Exception e){ 
return false; 

} 

} 

public long getStartlndex(){ 
try{ 

status = (EntryQueueStatus) space.readlfExists<statusTemplate,null,2000) 
return status -getStartlndex(); 

> catch(Exception e){ 
return -1; 

} 

} 

public long getEndlndex(){ 
try{ 

status = (EntryQueueStatus) space.readlfExists(statusTemplate,null,2000) 
return status.getEndlndex{),* 

} catch(Exception e){ 
return -1; 

} 

} 

} 


225 


11. TSString.java 

package tuplespace.core; 

import tuplespace.entries.*; 

import net.jini.space.JavaSpace; 

import net. j ini. core, entry. Entry,- 

import net.jini.core.lease.Lease; 

import net.jini.core.transaction.*; 

import net.jini.core.event.EventRegistration; 

j * * 

* The <code>TSString</code> class implements the methods for reading, writing, 

* updating, notifying and retrieving EntryString entry from space. Every 

* Entrystring entry in the space is identified by an unique ID (entrylD). 

* 

* A subclass that implements the SpaceActionHandler interface has to loaded 

* during initialization if remote event notification is used. 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 October 2000 

* ©see Entrystring 
*/ 


public class TSString extends TSBase implements java.io.Serializable, 
SpaceEventRegistration, TSConstants{ 
private Entrystring entry, entryTemplate; 


j * * 


* 


*/ 


Constructor for TSString 
©param space JavaSpace handle 

©param spaceAction the class that implements the actionPerformed(ActionEvent 
method, called when remote event is rised. 

©param entrylD the unique ID that identifies the String Entry 


e) 


public TSString(JavaSpace space, SpaceActionHandler spaceAction, String entrylD) { 
super(); 

initTSString(space, spaceAction, entrylD); 

} 


/** initialize TSString 

* ©param space JavaSpace handle 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param entrylD the unique ID that identifies the String Entry 

* ©return <tt>true</tt> if internal states are sucessfully reinitialized. 

*/ 

public boolean initTSString(JavaSpace space, SpaceActionHandler spaceAction, String 
entrylD) 

{ 

try{ 

initTSBase(space, spaceAction, entrylD); 
entry = new Entrystring(entrylD)? 
entryTemplate = new Entrystring(entrylD); 
return true; 

} 

catch(Exception e){ 
return false; 

} 

} 


/** Remove all existing entries from space */ 
public void cleanSpace{) 

{ 

cleanSpacel(null); 

} 

/** Remove all existing entries from space 
* ©param txn a valid transaction handle */ 
public void cleanSpacel(Transaction txn) 

{ 


226 


Object test; 
do{ 

try{ 

test = space.takelfExists(entryTemplate,txn,1000); 

//print(”remove [" + entrylD + "] from space”); 

}catch (Exception e){ 
e.printstackTrace(); 
test = null; 

} 

}while(test != null); 

} 

//★a************************************************************** 

//*** Write Entry 

* * * 

//***************************** *********************************** 

/** Writes value to space 

* ©param value the entry value (String) 

* ©return <tt>true</tt> if entry is sucessfully written to space. *f 
public boolean writel(String value) 

{ 

return write3( value, this.writeLeaseTime, null); 

> 

/** Writes value to space 

* ©param value the String value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write2(String value, long lease) 

{ 

return write3( value, lease, null); 

} 

/** Writes value to space 

* ©param value the String value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean write3(String value, long lease, Transaction txn) 

{ 

try{ 

entry = new Entrystring (this.entrylD, valued- 
space, write (entry, txn, lease) 
return true; 

} 

catch (Exception e){ 

e.printStackTrace(); 
return false; 

} 

} 


//*****★**★******★***************************★******************** 
//*** Update Entry 

* * ★ 

//*************************★**************************★*********** 
/** Updates an existing entry value 

* ©param value the entry value (String) to be updated 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean updatel(String value) 

{ 

return update3( value, this.updateLeaseTime, null); 

> 

/** Updates an existing entry value 

* ©param value the String value that is to be updated 

* ©param lease the amount of time entry is placed in space 


227 


* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update2(String value, long lease) 

{ 

return update3{ value, lease, null); 

} 

/** Updates an existing entry value 

* ©param value the String value that is to be updated 

* ©param lease the amount of time entry is placed in space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if entry is sucessfully updated. */ 
public boolean update3(String value, long lease, Transaction txn) 

{ 

try{ 

cleanSpacel(txn)? 

entry = new Entrystring (this. entrylD, valued- 
space .write (entry, txn, lease); 

return true; 

} 

catch (Exception e){ 

e.printStackTrace{); 
return false; 

} 

} 


//**************************************************************** 

//*** Read Entry 

* * * 

//I'*************************************************************** 

/** Reads an entry value 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. *l 

public String readlfExists() 

{ 

return readIfExists2(this.readTimeOut, null); 

} 

/** Reads an entry value 

* ©param timeout the maximum waiting time when reading the entry from space 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public String readlfExistsl(long timeOut) 

{ 

return readIfExists2(timeOut, null); 

} 

/** Reads an entry value 

* ©param timeOut the maximum waiting time when reading the entry from space 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public String readlfExists2(long timeOut, Transaction txn) 

{ 

this.setResult(false); 
try{ 

entry = (Entrystring) space. readlfExists (entryTemplate, txn, timeOut); 
if( entry != null) 

{ 

this.setResult(true)? 

return entry. entrystring; 

> 

else 

return "No Entry Found! 

} 

catch (Exception e){ 

e.printStackTrace{); 

return "Exception in method !"; 


228 


} 


} 


Z/************************************************************^^ 

//*** Take Entry 

* * * 

//**************************************************************** 

/** Takes an entry value; entry will be removed from space 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 
public String takelfExists() 

{ 

return takelfExistsl(this.takeTimeOut); 

} 

/** Takes an entry value; entry will be removed from space 

* ^return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public String takelfExistsl{ long timeOut) 

{ 

return takeIfExists2{timeOut, null); 

} 

/** Takes an entry value; entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public String takeIfExists2( long timeOut, Transaction txn) 

{ 

this.setResult(false)? 
try { 

entry = (Entrystring) space.takelfExists(entryTemplate, txn, timeOut) 
if( entry I- null) 

{ 

this.setResult(true); 

return entry.entrystring; 

} 

else 

return "No Entry Found!"; 

} 

catch (Exception e){ 
e.printStackTrace(); 

return "Exception in method !"; 

} 

} 


//**************************************************************** 

//*** Notify 

* * * 

//***********************************★**************************** 

/** Start notification; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEvent() 

{ 

return startEvent3 (this.spaceAction, this.notifyLeaseTime, null ),- 

/** Start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 


229 



* ©return <tt>true</tt> if notification is enabled. */ 
public boolean startEventl(SpaceActionHandler spaceAction) 

{ 

return startEvent3(spaceAction, this.notifyLeaseTime, null ); 

} 

/** start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent2(SpaceActionHandler spaceAction, long lease ) 

{ 

return startEvent3(spaceAction, lease , null )7 

} 

/** start notificiation; remote event will be raised if any entry 

* that matches the entry ID is added into the space. 

* ©param spaceAction the class that implements the actionPerformed(ActionEvent e) 

* method; called when remote event is raised. 

* ©param lease the amount of time for notification to remain active 

* ©param txn a valid transaction handle, if transaction is involved 

* ©return <tt>true</tt> if notification is enabled. */ 

public boolean startEvent3(SpaceActionHandler spaceAction, long lease , Transaction 
txn) 

{ 

try{ 

// Remove earlier event notification 
if(eventRegistration '= null){ 
try { 

Lease 1 = eventRegistration.getLease{); 

1.cancel(); 

}catch (Exception e){> 

} 

// Register new event notification 

SpaceEventListener listener = new SpaceEventListener(TS__STRING, entrylD, 
space,spaceAction); 

eventRegistration - space.notify(entryTemplate, txn, listener, lease, null); 
return true; 

} 

catch (Exception e){ 

e.printStackTrace()? 
return false; 

} 

> 

/** Stop notification 

* ©return <tt>true</tt> if notification is disabled. */ 
public boolean stopEvent(){ 

try{ 

if( eventRegistration != null) 

{ 

try { 

Lease 1 = eventRegistration.getLease(); 

1.cancel(); 

}catch (Exception e){} • 

eventRegistration = null; 

} 

return true; 

} 

catch (Exception e){ 
return false; 

} 

} 

//***************************★************************************ 

//*** Transaction Methods 
* * * 


230 



//**************************************************************** 

/** Writes entry value with transaction 

* ©param value the String value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transWrite(String value, long lease) 

{ 

return write3(value,lease,this.getTransaetionHandler()); 

} 

/** Updates an existing entry value with transaction 

* ©param value the String value that is to be written to space 

* ©param lease the amount of time entry is placed in space 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>true</tt> if entry is sucessfully written to space. */ 
public boolean transUpdate(String value, long lease) 

{ 

return update3 (value, lease,this.getTransactionHandler()); 

} 

/** Reads an entry value with transaction 

* ©param timeout the maximum waiting time when reading the entry from space 

* ©param this - transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public String transRead(long timeOut) 

{ 

return readIfExists2{timeOut, this.getTransactionHandler()); 

} 

/** Takes an entry value with transaction,* entry will be removed from space 

* ©param timeOut the maximum waiting time when reading the entry 

* ©param this.transaction must be a valid transaction handle 

* ©return <tt>"Exception in method !"</tt> if entry is not available, otherwise 

* the entry value. */ 

public String transTake( long timeOut) 

{ 

return takeIfExists2(timeOut, this.getTransactionHandler())? 

} 

> 


231 




C. ENTRIES PACKAGE 

1. EntryBoolean.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

/** 

* The <code>EntryBoolean</code> is the entry template for type - Boolean 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryBoolean implements Entry { 
public String entrylD; 
public Boolean entryBoolean; 

public EntryBoolean{){ 

} 

public EntryBoolean(String entrylD){ 
this.entrylD = entrylD; 

} 

public EntryBoolean(String entrylD, boolean entryValue){ 
this.entrylD = entrylD; 

this.entryBoolean = new Boolean(entryValue); 

} 

} 


2. EntryBytes.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 


j * * 

* The <code>EntryBytes</code> is the entry template for type - Bytes 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryBytes implements Entry { 
public String entrylD; 
public Byte(] entryBytes; 

public EntryBytes(){ 

} 

public EntryBytes(String entrylD){ 
this.entrylD = entrylD; 

} 

public EntryBytes(String entrylD,Byte[] entryValue){ 
this.entrylD = entrylD; 
this.entryBytes = entryValue; 

} 

} 


232 




3. EntryClass.java 

package tuplespace.entries; 
import net.jini.core.entry-Entry; 


/** 

* The <code>EntryClass</code> is the entry template for type - Class 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryClass implements Entry { 
public String entrylD; 
public String codeURL; 
public String className; 

public EntryClass(){ 

} 

public EntryClass(String entrylD){ 
this.entrylD = entrylD; 

} 

public EntryClass(String entrylD, String codeURL, String className){ 
this.entrylD = entrylD; 
this.codeURL = codeURL; 
this. className = className; 

} 

} 

4. EntryDouble.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

/** 

* The <code>EntryDouble</code> is the entry template for type - Double 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryDouble implements Entry { 
public String entrylD; 
public Double entryDouble; 

public EntryDouble{){ 

} 

public EntryDouble(String entrylD){ 
this.entrylD = entrylD; 

} 

public EntryDouble(String entrylD, double entryValue){ 
this.entrylD = entrylD; 

this.entryDouble = new Double(entryValue); 

} 

} 

5. EntryFloat.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

j * *■ 

* The <code>EntryFloat</code> is the entry template for type - Float 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 


233 



/ 


public class EntryFloat implements Entry { 
public String entrylD; 
public Float entryFloat; 

public EntryFloat(){ 

} 

public EntryFloat(String entrylD){ 
this.entrylD = entrylD; 

} 

public EntryFloat(String entrylD, float entryValue){ 
this.entrylD = entrylD; 
this.entryFloat = new Float(entryValue)? 

> 

} 

6. EntryHash.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 
import java.util.HashMap; 

/** 

* The <code>EntryHash</code> is the entry template for type - User Defined 

★ 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryHash implements Entry { 
public HashMap map; 
public String entrylD; 
public Integer entrylnteger; 

public EntryHash(){ 

} 

public EntryHash(String entrylD){ 
this.entrylD = entrylD; 

> 

public EntryHash(String entrylD, HashMap map){ 
this.entrylD = entrylD; 
this, map = map; 

} 

public HashMap getHashMap{){ 
return map; 

} 

public void setHashMap(HashMap map){ 
this.map = map; 

} 

} 

7. Entrylnteger.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 


/** 

* The <code>EntryInteger</code> is the entry template for type - Integer 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 


234 


*/ 

public class Entrylnteger implements Entry { 
public String entrylD? 
public Integer entrylnteger; 

public Entrylnteger0{ 

} 

public Entrylnteger(String entrylD){ 
this.entrylD = entrylD; 

} 

public Entrylnteger(String entrylD, int entryValue){ 
this.entrylD = entrylD; 

this.entrylnteger = new Integer(entryValue); 

> 

} 

8. EntryLong.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

j * * 

* The <code>EntryLong</code> is the entry template for type - Long 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryLong implements Entry { 
public String entrylD; 
public Long entryLong 

public EntryLong(){ 

} 

public EntryLong(String entrylD){ 
this.entrylD = entrylD; 

> 

public EntryLong(String entrylD, long entryValue){ 
this.entrylD = entrylD; 
this.entryLong = new Long(entryValue); 

> 

} 


9. EntryListItem.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

I * * 

* The <code>EntryListItem</code> is the entry template for List item 

★ 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryListltem implements Entry { 
public String entrylD; 
public Long position; 
public String content; 

public EntryListItem(){ 

} 

public EntryListltem(String entrylD){ 
this.entrylD = entrylD; 

} 


235 



public EntryListItem{String entrylD, long position. String msg) { 
this.entrylD = entrylD; 
this.position = new Long(position); 
this.content = msg; 

} 

public EntryListItern(String entrylD, long position){ 
this.entrylD = entrylD; 
this.position = new Long(position); 

} 

} 


10 EntryListStatus.java 

package tuplespace.entries; 

import net.jini.core.entry.Entry; 

* The <code>EntryListStatus</code> is the entry template for List status 

* 

* ^author Kin Boon Kwang 

* Aversion 1.0, 01 Oct. 2000 

*/ 

public class EntryListStatus implements Entry { 
public String entrylD; 
public Long startIndex; 
public Long endlndex,- 
public Long maxSize; 

public EntryListStatus(){ 

} 

public EntryListStatus(String entrylD){ 
this.entrylD = entrylD; 

> 

public EntryListStatus(String entrylD, long maxSize){ 
this.entrylD = entrylD,- 
this.maxSize = new Long(maxSize); 
this.startlndex = new Long(0); 
this.endlndex = new Long(-l); 

} 

public long getCurSize(){ 

return (endlndex.longValue() - startlndex.longValue() +1); 

} 

public long getMaxSize(){ 
return maxSize. longValue () ,- 

} 

public long getStartIndex(){ 

return startlndex.longValue (); 

} 

public long getEndlndex(){ 

return endlndex.longValue (); 

> 


public boolean isEmpty(){ 

if(startlndex.longValue() > endlndex.longValue()) 
return true; 
else 

return false; 

} 


236 


public boolean isFull(){ 

if(maxSize.intValue() <= (endlndex.longValue() - startlndex.longValue())) 
return true; 
else 

return false? 

} 

public boolean incrementStartIndex(){ 

if(startlndex.longValue() <= endlndex.longValue(}){ 
startlndex = new Long(startlndex.intValue()+1); 
return true; 

}else 

return false; 

} 

public boolean incrementEndlndex0{ 

if(maxSize.longValue{) > (endlndex.longValue() - startlndex.longValue())){ 
endlndex = new Long(endlndex.intValue()+1); 
return true? 

}else 

return false? 

} 

} 


11 Entry Queueltem.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

/** 

* The <code>EntryQueueItem</code> is the entry template for Queue item 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryQueueltem implements Entry { 
public String entrylD,- 
public Long position? 
public String content; 

public EntryQueueltem(){ 

} 

public EntryQueueltem(String entrylD){ 
this.entrylD = entrylD; 

} 


public EntryQueueltem(String entrylD, long position, String msg){ 
this.entrylD = entrylD; 
this.position = new Long(position); 
this.content = msg; 

} 

public EntryQueueltem(String entrylD, long position){ 
this.entrylD = entrylD; 
this.position = new Long(position)? 

} 

) 

12 EntryQueueStatus.java 

package tuplespace.entries; 

import net.jini.core.entry.Entry; 

/ ** 

* The <code>EntryQueueStatus</code> is the entry template for Queue status 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 


237 



*/ 


public class EntryQueueStatus implements Entry { 
public String entrylD; 
public Long startlndex; 
public Long endlndex; 
public Long maxSize; 

public EntryQueueStatus(){ 

} 

public EntryQueueStatus(String entrylD){ 
this.entrylD = entrylD; 

} 

public EntryQueueStatus(String entrylD, long maxSize){ 
this.entrylD = entrylD; 
this .maxSize = new Long (maxSize) ; 
this.startlndex = new Long(O); 
this.endlndex = new Long{-1); 

} 

public long getCurSize(){ 

return (endlndex.longValue() - startlndex.longValue{) +1); 

} 

public long getMaxSize(){ 
return maxSize.longValue(); 

} 

public long getStartlndex(){ 

return startlndex.longValue (),* 

} 

public long getEndlndex(){ 

return endlndex.longValue (); 

} 


public boolean isEmpty{){ 

if(startlndex.longValue() > endlndex.longValue()) 
return true; 
else 

return false; 


public boolean isFull(){ 

if(maxSize.intValue() <= (endlndex.longValue() - startlndex.longValue())) 
return true; 
else 

return false; 


public boolean incrementStartIndex(){ 

if(startlndex.longValue() <= endlndex.longValue()){ 
startlndex = new Long(startlndex.intValue()+1); 
return true; 

}else 

return false; 


public boolean incrementEndlndex(){ 

if (maxSize.longValue() > (endlndex.longValue() - startlndex.longValue())){ 
endlndex = new Long{endlndex.intValue()+1); 
return true; 

}else 

return false; 

} 

} 


238 



12 EntryStackItem.java 

package tuplespace.entries; 
import net.jini.core.entry-Entry; 

/ * * 

* The <code>EntryStackItem</code> is the entry template for Stack item 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class EntryStackltem implements Entry { 
public String entrylD; 
public Long position; 
public String content; 

public EntryStackItem{){ 

} 

public EntryStackltem(String entrylD){ 
this.entrylD = entrylD; 

> 

public EntryStackltem(String entrylD, long position, String msg){ 
this.entrylD = entrylD; 
this.position = new Long(position); 
this.content = msg; 

} 

public EntryStackltem(String entrylD, long position){ 
this.entrylD = entrylD; 
this-position = new Long(position); 

} 

} 

14 EntryStackStatus-java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

j ** 

* The <code>EntryStackStatus</code> is the entry template for Stack status 

* 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 


public class EntryStackStatus implements Entry { 
public String entrylD; 
public Long startlndex; 
public Long endlndex; 
public Long maxSize; 

public EntryStackStatus(){ 

} 

public EntryStackStatus(String entrylD){ 
this.entrylD = entrylD; 


public EntryStackStatus(String entrylD, long maxSize){ 
this.entrylD = entrylD; 
this.maxSize = new Long (maxSize) ; 
this.startlndex = new Long(0); 
this.endlndex = new Long(-l); 


public long getCurSize(){ 

return (endlndex.longValue() - startlndex.longValue() +1); 

} 


239 



public long getMaxSize{){ 
return maxSize.longValue(); 

} 

public long getStartIndex(){ 

return startlndex.longValue {); 

} 

public long getEndlndex{){ 

return endlndex.longValue (); 

} 


public boolean isEmpty{){ 

if(startlndex.longValue() > endlndex.longValue()) 
return true; 
else 

return false; 

} 

public boolean isFull(}{ 

if(maxSize.intValue() <= {endlndex.longValue() - startlndex.longValue{))) 
return true; 
else 

return false; 

} 

public boolean incrementStartlndex{){ 

if{startlndex.longValue() <= endlndex.longValue()){ 
startlndex = new Long(startlndex.intValue()+1); 
return true; 

}else 

return false; 

} 

public boolean incrementEndlndex(){ 

if(maxSize.longValue() > (endlndex.longValue() - startlndex.longValue{))){ 
endlndex = new Long(endlndex.intValue()+1); 
return true? 

}else 

return false? 

} 

} 

15 EntryString.java 

package tuplespace.entries; 
import net.jini.core.entry.Entry; 

/ * * 

* The <code>EntryString</code> is the entry template for type - String 

★ 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class Entrystring implements Entry { 
public String entrylD; 
public String entrystring? 
public String entryType; 

public Entrystring(){ 
entryType = "STRING"? 

} 

public Entrystring(String entrylD){ 
entryType = "STRING"; 
this.entrylD = entrylD; 

} 


public Entrystring(String entrylD, String entrystring){ 
entryType = "STRING"? 


240 


this.entrylD = entrylD; 
this.entrystring = entrystring; 

} 

} 

16 SpaceActionHandle.java 

package tuplespace.entries; 

import java.util.EventListener; 
import j ava.awt.event.*; 

/** 

* The <code>SpaceActionHandler</code> 

★ 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public interface SpaceActionHandler extends ActionListener { 

public void actionPerformed(ActionEvent e) ; 
public void fireAction(int eventType, String id); 

} 


17 SpaceEventListener.java 

package tuplespace.entries; 

import tuplespace.entries.*; 
import j ava.rmi.server.*; 
import j ava.rmi.RemoteException; 
import net.jini.core.event.*; 
irtport net.jini.space.JavaSpace; 
import j ava.awt.event.ActionListener; 

I * * 

* The <code>SpaceEventListener</code> 

★ 

* ©author Kin Boon Kwang 

* ©version 1.0, 01 Oct. 2000 
*/ 

public class SpaceEventListener implements RemoteEventListener { 
private int eventType; 
private String eventID; 
private JavaSpace space; 
private SpaceActionHandler action; 


public SpaceEventListener(int eventType, String eventID, JavaSpace 
SpaceActionHandler action) throws RemoteException { 
this.eventType = eventType; 
this.eventID - eventID; 
this.space = space; 
this.action = action; 

UnicastRemoteObject.exportObject(this); 

> 

public void notify(RemoteEvent ev) { 
try { 

action.fireAction(eventType, eventID); 

} catch (Exception e) { 
e.printStackTrace() ; 

} 

> 

} 


space, 


241 




THIS PAGE INTENTIONALLY LEFT BLANK 


242 




INITIAL DISTRIBUTION LIST 

1. Defense Technical Information Center.2 

8725 John J. Kingman Road, Suite 0944 

Ft. Bel voir, VA 22060-6218 

2. Dudley Knox Library.2 

Naval Postgraduate School 

411 Dyer Road 
Monterey, CA 93943-5101 

3. Computer and Information Programs Office.1 

Code 32 

Naval Postgraduate School 
833 Dyer Rd., Room 404 
Monterey, California 93943-5120 

4. Chair, Computer Science Department.1 

Naval Postgraduate School 

833 Dyer Rd. 

Monterey, California 93943-5118 

5. Dr Luqi.1 

Naval Postgraduate School 

833 Dyer Rd. 

Monterey, California 93943-5118 

6. Dr Valdis Berzins.3 

Naval Postgraduate School 

833 Dyer Rd. 

Monterey, California 93943-5118 

7. Dr Ge Jun.2 

Naval Postgraduate School 

833 Dyer Rd. 

Monterey, California 93943-5118 

8. Mr. Kin Boon Kwang.3 

Depot Road, Defense Technology Tower A, 

Level 20B, Singapore 109679 


243 












