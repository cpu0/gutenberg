Field Model: An Object-Oriented Data Model for Fields 


Technical Report NAS -01 -005 


Patrick J. Moran* 
NASA Ames Research Center 

pmoran@nas . nasa . gov 


Abstract 

We present an extensible, object-oriented data model designed for 
field data entitled Field Model ( FM ). FM objects can represent a 
wide variety of fields, including fields of arbitrary dimension and 
node type. FM can also handle time-series data. FM achieves 
generality through carefully selected topological primitives and 
through an implementation that leverages the potential of templated 
C++. FM supports fields where the nodes values are paired with 
any cell type. Thus FM can represent data where the field nodes 
are paired with the vertices (“vertex-centered” data), fields where 
the nodes are paired with the .D-dimensional cells in R D (often 
called “cell-centered” data), as well as fields where nodes are paired 
with edges or other cell types. FM is designed to effectively han- 
dle very large data sets; in particular FM employs a demand-driven 
evaluation strategy that works especially well with large field data. 
Finally, the interfaces developed for FM have the potential to ef- 
fectively abstract field data based on adaptive meshes. We present 
initial results with a triangular adaptive grid in R 2 and discuss how 
the same design abstractions would work equally well with other 
adaptive-grid variations, including meshes in R 3 . 

CR Categories: E. Data (large); 1.1.3 Languages and Systems, 

Evaluation strategies; 1.3.8 Computer Graphics Applications 

Keywords: data models, object-oriented, C++, templates, scien 
title visualization, demand-driven evaluation. 


1 Introduction 

Underlying virtually every object-oriented visualization system is a 
data model. The data model forms a key part of the system design, 
effectively spelling out the types of data that can be analyzed by the 
system. A well-designed data model component can significantly 
enhance the capabilities of the overall system. For example, the de- 
velopers of OpenDX (formerly IBM Data Explorer) often cite the 
consistent, unified nature of the DX data model as one of the key 
reasons for the success of their' system [13, 1]. For large data vi- 
sualization, the data model can have a significant impact on system 
efficacy. Poorly chosen abstractions can lead to performance prob- 
lems or make development awkward. Well-designed abstractions 
can enhance code reuse and enable the coupling of components in 
new and interesting ways. 

A recent trend in numerical computing is the growing popularity 
of adaptive meshes. Adaptive meshes increase or decrease reso- 
lution automatically as required by a simulation code. Adaptive 
meshes free the scientist from having to construct a mesh initially 
that completely anticipates where high resolution will be required. 
Adaptive meshes are also a natural choice when the resolution re- 
quired in various regions of the domain changes over the course 
of the simulation, for instance, following a shock wave. Adaptive 


"Mail Stop T27A-2, Moffett Field, CA 94035 


mesh techniques are often implemented as parallel algorithms, re- 
quiring careful load balancing and communication strategies in or- 
der to be most effective. Unfortunately, adaptive meshes tend not 
to match well with the data models underlying current general vi- 
sualization systems, prompting mesh library developers to resort to 
developing visualization modules custom to their mesh design. 

For those in the visualization community, adaptive meshes offer 
the possibility of new and interesting research topics. For exam- 
ple, one might want to couple various multi-resolution visualization 
techniques with the adaptive mesh data structures. For visualiza- 
tion system developers, adaptive meshes are a challenge. There are 
a number of current adaptive mesh development efforts, each with 
its own custom algorithms and data structures. One would like to 
apply the wealth of visualization techniques that have already been 
developed, yet one is likely not to have the resources to devote to in- 
terfacing to each adaptive mesh variation. This is where a carefully 
designed data model comes in. With appropriately chosen abstrac- 
tions, a data model can insulate the visualization techniques from 
the majority of the idiosyncrasies of the mesh and field data struc- 
tures. A carefully designed model can also enhance modularity: 
newly added mesh and field types in the future should not require 
significant modifications to existing code. 

In general, the advantages of a good data model are not limited 
to adaptive meshes alone. Overall, our goal is to provide a common 
model for field data that will enhance the sharing of data sets and 
of visualization technique implementations. In the next section we 
provide an overview of some of the key concepts in the FM design 
that are intended to take us towards our goal. Following that we 
survey related data model work within the visualization community. 
Next, we discuss key features of the FM design, and then present 
current results. Finally, we conclude with a discussion of future 
plans for the FM project. 

2 Field Model Concepts 

Field Model objects are embedded irr R°, also known as physical 
space. Objects in R D are also said to have a physical dimensional- 
ity of D. The regions irr R D where fields are defined are discretized 
by meshes, which irr turn are composed of cells. A k-cell is a subset 
of R d that is homeomorphic (topologically equivalent) to a A; -ball. 
Cells in FM are currently all linear objects. A 0-cell is a vertex, a 
1-cell is an edge, 2-cells include triangles, quadrilaterals, and other 
polygons. Hexahedra, tetrahedra, pyramids and prisms are all ex- 
amples of 3-cells. Every cell cr has a set of vertices. We use a more 
general concept of face than some are familiar with: a face of a is 
specified by a non-empty subset of the vertices of cr 1 . For example, 
a hexahedron has not only quadrilateral faces, but also vertex and 
edge faces. Every cell is also a face of itself. The general face def- 
inition enables us to develop a more uniform treatment of objects 

1 If a cell a is not a simplex, then not every subset of the vertices of a 
constitutes a face. In practice it is clear which subsets define valid faces. 












0 1 2 3 

B 

Figure 1: Example FM meshes organized in columns and rows by base dimensionality (B) and physical dimensionality (D), respectively. 
Note that the model is general enough to represent not only the input to visualization techniques, but also the output. For example, regular 
meshes in R 2 ((B,D) = (2,2)) could serve as the underlying discretization for images, and surfaces in R 3 naturally correspond to (2,3) meshes. 


with general dimension. A mesh Ad is a finite set of cells such that 
if cr € Ad, and r is a face of cr, then r € Ad. Typically, cells 
in a mesh share common faces, so for example two tetrahedra can 
share triangle, edge, and vertex faces. If the cells with the highest 
dimensionality in mesh Ad are B -cells, then Ad is a B-mesh, and 
Ad has a base dimensionality of B. The base dimensionality of a 
mesh must be less than or equal to its physical dimensionality. The 
shape of a mesh Ad is the space occupied by the union of all the 
cells of Ad. In most cases, the shape of a B mesh is equivalent to 
a B-manifold with boundary. In order to rule out some cell col- 
lections that do not have a manifold shape, we require that eveiy 
cell in a B-mesh Ad must be the face of some B-cell in Ad. This 
requirement, for instance, rules out cases where we have a surface 
(B = 2) with spurious edges and vertices that are not part of the 
surface. 

Figure 1 illustrates example meshes that can be constructed in 
FM. Note that FM meshes can represent familiar objects such as 
regular meshes, curvilinear meshes, and tetrahedral unstructured 
meshes. Note too that our definition is general enough that we can 
represent objects less commonly thought of as meshes, such as a 
collection of vertices and edges signifying the atoms and bonds of 
a molecule (B = 1, D = 3). Also, note that the molecular example 
is a case where the set of cells adheres to our mesh definition, but 
the shape of the mesh is non-manifold. 

A field defines a function within a region of space. In FM, each 
field object has a set of values called nodes (which can be accessed 
on demand), a mesh, and a pairing between the At-cells in the mesh 
and the nodes. The value of k for a particular field is known as its 
node association index. The base and physical dimensionalities of a 
field are the dimensionalities of its underlying mesh. For fields with 
base dimensionality B, the most common node association indices 
seen in visualization data are 0 (“vertex centered”) and B (typi- 
cally called “cell centered”). Other node association indices tend 
to be underrepresented in visualization studies, though they are still 


important scientifically. Node association index 1 fields often oc- 
cur in electromagnetics simulations as well as some adaptive mesh 
systems, where adaptation criteria are paired with the edges. Node 
association index 2 fields are useful in some flow studies, where 
fluxes are tracked at the 2-cells in order to verify the correctness of 
the simulation. 

For a field with node association index k, the user can request 
a single value at a particular fc-cell or request multiple values at a 
j'-cell, j ^ k. We define later how the field selects node values in 
the case where j / k. The user can also request a field value at an 
arbitrary point in physical space, or for fields based on meshes with 
structured behavior, at an arbitrary point in base space. In response 
to such queries, fields return an integer code indicating whether the 
quety was successful (e.g., depending upon whether the given point 
was within the part of the domain where the field is defined), and 
a field value. Appropriate interpolation techniques are fairly well 
agreed upon for fields witli node association index 0; for other node 
association indices appropriate interpolation methods are still under 
investigation. 

Before proceeding with a description of the FM design and im- 
plementation, we review previous data model work. 

3 Related Work 

The importance of a well-designed data model has been recognized 
early on in the visualization community, and there have been a 
number of efforts to develop a general design with a strong, for- 
mal foundation. One of the earliest was the fiber bundle model by 
Butler and Pendley [5], Their model was inspired the mathemat- 
ical abstraction of the same name. Fiber bundles have proven to 
be somewhat difficult to implement in their pure form, though the 
concepts have inspired several follow-on efforts. The original fiber 
bundle abstractions did not provide a convenient means to access 


2 




the underlying discretization (mesh) of a data set. This was a prob- 
lem since many visualization algorithms operate by iterating over 
various types of cells of the mesh. 

One system in particular that has been influenced by fiber bundle 
concepts is OpenDX (formerly IBM Data Explorer[13, 1]). Begin- 
ning with Haber et al [8], the fiber bundle model was adapted into a 
model that would support a general-purpose data-flow visualization 
system. OpenDX can handle fields with node association indices 0 
or B , where B is the base dimensionality of the field. OpenDX does 
not support adaptive meshes, though more recent work by Treinish 
[23] describes a model that would accommodate such data. 

Another field modeling effort was the Field Encapsulation Li- 
brary (FEL) project, first presented at Visualization ’96 [3], FEL 
excelled with the multi-block curvilinear grids that are popular in 
computational fluid dynamics applications. FEL differed from most 
other modeling efforts in that it defined separate class hierarchies 
for meshes and fields, rather than a single combined object type. 
A second version of FEL, FEL2, followed after a basic redesign 
and total rewrite [16, 15]. FEL2 introduced fundamental design 
features that enabled the library to operate with far larger data sets, 
including a consistent demand-driven evaluation model [14] and the 
integration of demand-paging techniques [6]. FEL2, like the orig- 
inal version of FEL, assumed that all objects were in R 3 physical 
space, and that all fields effectively had a node association index of 
0 . 

The Visualization Toolkit (vtk) [20], like OpenDX, is an open 
source visualization system with a fairly general data model. The 
vtk data model uses an extended concept of cells, including such 
primitives as polylines and triangle strips as cell types. Recent ex 
tensions [12] have focused on enabling the data model (and thus the 
whole system) to handle large data. Like FM, vtk utilizes a demand- 
driven evaluation strategy. In vtk, visualization techniques negoti- 
ate with a data source in order to determine appropriate streaming 
parameters, then the streaming commences. FM demand-driven 
evaluation is maximally fine-grained: visualization teclmiques re 
quest data one cell at a time, and the lazy evaluation happens at the 
same granularity. The FM approach leads to more function calls 
between the data consumer and producer, while the vtk approach 
implies that the data consumer has to know more about the charac- 
teristics of the data set it is accessing. 

Another object-oriented data flow visualization system intended 
for large data visualization is SCIRun [2, 19]. One distinguish- 
ing characteristic of the SCIRun development effort was the focus 
on computational steering, i.e., analyzing data from a simulation 
and modifying simulation parameters, as the simulation is running. 
SCIRun also allowed for some mesh adaptation during a simula- 
tion run. The data model was not the primary focus of the overall 
development effort. 

VisAD [10, 9] is a relatively general, object-oriented model for 
numerical data. The user can construct data objects with a style sim- 
ilar to expressing mathematical functions. In contrast to the models 
described previously, VisAD is implemented in Java. The VisAD 
model is quite flexible, though the Java implementation makes it 
less suitable for veiy large data. The VisAD model does put more 
effort into the inclusion of metadata - data about data - than most 
other designs. For example, VisAD provides for the specification of 
the units of measurement. Thus, for example, VisAD users should 
be less likely to confuse distances measured in miles with distances 
measured in kilometers. 

4 Design and Implementation 

Object-oriented design is hard. As Gamma et al. point out: 

Experienced object-oriented designers will tell you that 

a reusable and flexible design is difficult if not impossi- 


f 



abc ace bcf cde cdf def efg 



Figure 2: A small 2-mesh and its corresponding incidence graph. 
Answering faces queries is equivalent to following paths upwards 
or downwards in the graph. 


ble to get “right” the first time. Before a design is fin- 
ished, they usually tty to reuse it several times, modify- 
ing it each time [7]. 

In the case of the design of FM, we benefit from our experience with 
the original [3] and second generation [16, 15] Field Encapsulation 
Library (FEL) projects. Both generations had relatively demanding 
performance requirements from applications such as Virtual Wind- 
tunnel [4], Both also faced large data challenges. The second gen- 
eration FEL was used by several different applications, providing 
reuse cases that helped us refine the class interfaces. 

In FM, as in FEL, the two main types of objects in the model are 
meshes and fields. We discuss key features of both types next. 

4.1 Shared Mesh and Field Interface 

Both mesh and field classes inherit interface from the class 
FM_f ielcLinterf ace<B, D, T>, where the template argu- 
ments B, D and T specify the base dimensionality, physical dimen- 
sionality and node type, respectively. For meshes, the node type 
is the coordinate type: FM_vector<D, FM_coord>. The inter- 
face class specifies the member functions at. cell, at .base, and 
at.phys. The at.cell call takes a cell argument and appends 
values to a C++ standard library vector [11] passed in by pointer. 
The at .base and at.phys member functions provide access to 
field values at a single point in base space or physical space, respec- 
tively. We provide detail on the access function semantics below. 

4.2 Mesh Interface 

In general an application can access two types of information from a 
mesh object: geometric and topological. Geometric information is 
accessed primarily through the at.cell call, which produces the 
coordinates of the vertices of its cell argument. The at.base call 
takes a point in base coordinates and produces physical coordinates, 
thus it provides a means to convert between the two coordinate sys- 
tems. (There is also a routine to do the opposite conversion). The 
at.phys call may at first seem redundant for meshes, but via its 
integer return value it does provide a means for verifying whether a 
given physical point is within the region where the field is defined. 


3 


FM mesh objects have several member functions that provide 
topological information. Here we focus on one particular method, 
faces, that is key to the general node association design. To illus- 
trate the faces method, we consider the small 2-mesh in Figure 2. 
Below the the mesh is an incidence graph which captures all the 
face relationships of the mesh. Each row of nodes 2 in the graph cor- 
responds to a particular cell dimensionality, with the rows ordered 
by increasing dimensionality from bottom to top. The graph con- 
tains an edge between nodes representing a Atcell a and a (k + 1) 
cell r if <t is a face of t . The faces methods takes a A; -cell a and 
an integer argument j. If j < k, then faces returns the j cells 
that are faces of a. If j > k, then faces returns the j-cells that 
a is the face of. If j = k , then faces returns a. In terms of 
the graph in Figure 2, the j < k case is equivalent to following all 
paths downward to the jth row from the node corresponding to <r; 
the j > k case is equivalent to following all paths upward instead 
of downward. For those familiar with algebraic topology, the func- 
tionality of the faces call is essentially equivalent to the closure 
and star operators combined [17]. The faces method has many 
uses, for example it may be used for obtaining the edges of a given 
hexahedron. We will see how faces is used in conjunction with 
general node association below in Section 4.4. 

The FM mesh interface also supports iterator functionality com- 
patible with the C++ standard library [11], Meshes behave as col- 
lections of cells, and one can iterate over the cells. Unlike standard 
library collections, mesh objects provide a richer set of iteration 
possibilities. Typically one wants to iterate over cells of a particu- 
lar dimension, or some other subset of the total collection of cells. 
FM provides this control via optional arguments to the begin it- 
erator initializer call. Other than that difference, FM iterator style 
is compatible with the standard library, and one should be able use 
any of the standard library algorithms that operate with a collection 
that provides a const-iterator. 

4.3 Mesh Implementation 

Figure 3 summarizes the FM mesh hierarchy. All mesh 
objects share common interface defined by FM_mesh_ and 
FM_mesh<B, D>. The subclasses also share implementation 
through inheritance. For example, topological methods such as 
faces are implemented in FM_structured_mesh<B, D> and 
used by all structured mesh subclasses. Meshes are also responsi- 
ble for point location and contribute geometric information that is 
used for interpolation. Efficient point location is critical in a high- 
performance field model, as it is an intermediate step when com- 
puting field values at arbitrary points in space. Through the class 
hierarchy we are able to provide point location routines that ex- 
ploit characteristics of various types of meshes in order to provide 
increased performance. 

4.4 Field Interface 

Fields are all templated on base dimensionality, physical dimen- 
sionality and node type. FM uses the same source for scalar, vector 
and in general tensor fields — all are instantiated from the same 
class definitions. The fundamental field member function for ob- 
taining field values is at_cell, which produces one or more field 
values, returning them in a C++ standard library vector object [11]. 
For a field with node association index k, an at.cell call with 
a A; -cell argument will produce a single field value. The same call 
with a j-cell argument, j ^ k, first would use the faces call on 
the underlying mesh to convert the j-cell into a collection of k 
cells. Then, for each of the resulting A; -cells the field would append 
a single value to the result collection. Thus, for example, a node as- 
sociation index 0 field given a hexahedron argument would produce 

2 Note that graph nodes and field nodes are different concepts. 


FM_mesh_ 

FMj+esh<B, D> 

FM_structured_mesh<B, D> 
FM_curvilinear_mesh<B, D> 
FM.regular .interval 
FM_ir regular -interval 
FM_product-mesh<B, D> 
FM_regular_mesh<B, D> 
FM_unstructured_mesh<B, D> 
FM_multi-mesh<B, D> 
FM_time_series_mesh<B, D> 

Figure 3: A synopsis of the main mesh classes, with the inheritance 
hierarchy signified by indentation. The integer template arguments 
B and D to FM_mesh<B, D> and the classes below it specify the 
base and physical dimensionality, respectively. The FM_mesh_ par- 
ent class provides a convenient handle when an application only re- 
quires the portion of the mesh interface that is not dependent upon 
the mesh dimensionality, e.g., the iterator interface. 

FM.f ield. 

FM_field<B,D, T> 

FM-Core_f ield<B, D , T> 

FMjnulti.f ield<B, D , T> 
FM-unary_derived_field<B, D , T> 
FM_binary_derived_f leld<B, D, T> 
FM_time_series-field<B, D, T> 

Figure 4: A synopsis of the main field classes, with the inheritance 
hierarchy signified by indentation. The B and D template argu- 
ments have the same meaning as for meshes. The T template ar- 
gument specifies the field node type, e.g., float. The purpose of 
the FM.fl eld_ parent class is analogous to that of FM_mesh_: it 
provides a convenient handle when an application only requires the 
portion of the field interface that is not dependent upon the template 
arguments. 


8 values, 1 for each vertex. Or, for example, a node association in- 
dex 3 ("finite volume”) field at_cell call with a vertex argument 
would return in general 8 values. We say “in general” since a vertex 
at the boundary of the mesh is the face of fewer than 8 hexahedra. 

The utility of the at-cell definition becomes further appar- 
ent when we consider cases where we have a field with one par- 
ticular node association index, but want it to behave like another. 
Our approach would be to define an adapter class [7], derived from 
FM_f ield<B, D , T>, with its own at.cell method implementa- 
tion. For instance, consider the case where we have a visualization 
algorithm that expects a single value when calling at.cell with 
a vertex, but our field has a node association index not equal to 
0. The adapter would take an incoming vertex argument and call 
at_cell on the adapted field. The multiple values received in re- 
sponse could be averaged (perhaps with some weighting factors) 
to produce the final single value response. Such an adapter would 
enable us to reuse some older visualization techniques that make 
vertex-centered data assumptions. 

4.5 Field Implementation 

The FM.fleld- class liierarchy is summarized in Figure 4. The 
subclasses are primarily responsible for providing implementations 
for the at-cell member function. Core fields produce values 
from a memory buffer. FM_multi_f ield<B, D, T> represents 
fields consisting of multiple subfields; at.cell calls are delegated 
to the appropriate subfield. The derived field classes produce values 
on demand, applying a mapping function to the values produced by 


4 



Mesh 

Cardo 

Cardi 

Card2 

Initial 

14605 

43009 

28404 

Level 1 

26189 

88991 

59000 

Level 2 

62926 

235331 

156498 

Level 3 

169933 

662344 

441147 

Level 4 

380877 

1505024 

1003313 

Level 5 

488574 

1935619 

1291834 


Table 1: Cell set cardinalities for the 0-cells, 1 -cells, and 2-cells 
in the airfoil example illustrated in Figure 5. The levels denote the 
number of refinement steps taken. 


at.cell calls on the underlying fields. 

The FM_field<B, D, T> class provides default implementa- 
tions for the at.phys and at_base methods. Both implementa- 
tions operate by locating a cell containing the given point, obtaining 
field values in the neighborhood of the point using at.cell, and 
then interpolating based on the geometry of the cell. Since both 
at.phys and atJoase are implemented in terms of at.cell, 
field subclasses are not required to provide implementations of 
these two functions. Nevertheless, some subclasses do provide their 
own implementations in order to employ optimizations that are spe- 
cific to certain field types. 

4.6 Time 

In the previous sections we have said little about time, but this is not 
because time-varying data is unimportant. To the contrary, marry 
large data sets come in the form of a time series. There are two 
main strategies we could choose in order to address the needs of 
time-varying data in FM. One approach would be to simply treat 
time as an added dimension, utilizing the general -dimeirsion mech- 
anisms in we have already developed. The alternative would be to 
treat time as special, distinct from the spatial coordinates. At first 
glance, the former strategy may seem more appealing we would 
like to reuse implementation when we can - but we decided to go 
the latter route instead, for several reasons. First, the spatial and 
temporal resolutions of the data can be dramatically different. Es 
pecially in post-processing applications, what is saved of the sim- 
ulation is typically down sampled in time from the resolution used 
during the run. This implies we may want to do spatial and tempo- 
ral interpolation differently. Second, many visualization techniques 
are designed to work at some instance in time, and they do not han- 
dle time explicitly. If time were an added dimension, then the user 
of FM would need to reduce the data dimensionality before pass- 
ing the data to the visualization technique. While such a design is 
possible, we concluded that it could be somewhat awkward for our 
users, and there is some question as to how great of a performance 
hit we would take if we were to employ such an approach. 

In FM, time-varying meshes and fields are repre- 
sented by the classes FM_time_series_mesh<B, D> and 
FM.time.series.f ielcKB, D, T>, respectively. Base po- 
sition, physical position, and cell arguments all contain a time 
member. Objects that do not vary with time ignore this member. 
Time series objects use the time member to index into the series 
and as part of the interpolation process when needed. Within this 
design, visualization techniques are free to request values in space 
and time as needed by the particular algorithms. 

5 Results 

5.1 2-D TAG 

As a demonstration of the Field Model capabilities, we consider a 
2-D Triangular Adaptive Grid (TAG) code that has served as the 


basis for previous research efforts on adaptive grid techniques [18]. 
The TAG system is designed to be relatively insulated from a par- 
ticular flow solver. TAG provides mesh geometry and connectivity 
information used by the solver; the solver in turn computes field 
node values and adaptation criteria that are associated with the mesh 
edges. Based on the adaptation criteria, the TAG system refines or 
coarsens the mesh. Figure 5 illustrates the airfoil test case that we 
consider here. Table 1 quantifies the mesh size in terms of the num- 
ber of fc -cells, k = 0..2, for each level of refinement. 

Our' motivation for choosing the TAG 2-D example is to test ex- 
tensibility, in particular, with an adaptive mesh object. It is nei- 
ther feasible nor desirable for FM to provide built-in support for 
every mesh data structure; the library implementation would be- 
come too bulky and difficult to maintain. Instead, our goal is 
a design that is modular enough that new types of meshes can 
be added without significant modification to existing parts of the 
model. To be successful in this endeavor, we have three crite- 
ria. First, the class interfaces should be general enough to be 
applicable to a variety of object types. So far we consider our- 
selves to have met this requirement. FM can represent a vari- 
ety of objects, including structured and unstructured objects and 
multi-block objects. We have not encountered significant limi- 
tations due to the interfaces. Second, the interface abstractions 
should not cause us to suffer an unacceptable loss in performance. 
We address this issue below. Finally, the class design should sup- 
port reuse of parts of the implementation, so that newly introduced 
mesh and field types do not have to reimplement common rou- 
tines. Our design has been successful in this respect as well. For 2- 
D TAG, we defined a new class TAG2D_unstructured_mesh, 
which is derived from FM_unstructured_mesh<2 , 2>. Note 
that the TAG2D class is not templated; the base dimensionality 
and physical dimensionality are hard-coded in the 2-D TAG im- 
plementation that we obtained. OurTAG2D class must provide im- 
plementation of some basic member functions such as at.cell 
and faces, since these functions refer to TAG-specific data struc- 
tures. Other functionality, such as iterator support, is inherited from 
FM_unstructured_mesh<2, 2>; our TAG class can reuse the 
existing code. 

The version of the 2-D TAG code we adapted for our example 
here executes serially. Oliker and Biswas [18] also have versions of 
the same code designed for parallel architectures, including mes- 
sage passing systems. We do not have experience yet with how 
well FM would accommodate such generalizations, but we are in- 
terested in investigating tlris. There is also a 3-D version of the 
adaptive grid code, developed by the same research group, that is 
analogous in many respects to 2-D TAG. The 3-D version contains 
non-simplicial cells, including pyramids, prisms and hexahedra, 
which should provide some additional challenge, although we do 
not anticipate any fundamental problems adapting such objects. 

5.2 Performance 

Field Model at its heart is about abstractions, and it is natural to 
ask what cost one has to pay for the benefits of abstraction. This in 
general is a difficult question to answer, because: 

• cost is relative to some alternative, and what alternatives we 
have vary from case to case; 

• how much abstraction overhead is apparent depends on the 
balance between data access and computation using the data; 

• with large data, access time can be significantly influenced by 
the locality or lack thereof in data access patterns. 

Despite these difficulties, it is still important to quantify the perfor- 
mance of the data model. We present the results from two initial 


5 





Figure 5: The airfoil data set with 2-D TAG. At the upper left is a close-up of the whole airfoil. At the upper right is a much closer view of 
the leading edge of the airfoil. The two images in the lower row display successive refinement iterations within the same region. 


6 





Mesh 

Bounding Box 
Abstract Direct 

Edge Drawing 
Abstract Direct 

Initial 

13.9 

1.1 

1395.9 

1324.5 

Level 1 

23.5 

1.8 

2634.7 

2555.9 

Level 2 

56.3 

4.3 

6929.4 

6583.7 

Level 3 

152.4 

11.7 

20276.7 

18841.9 

Level 4 

343.8 

26.4 

45754.7 

44351.6 

Level 5 

462.8 

35.7 

59516.6 

58007.2 


Table 2: Initial FM example timings, in msec. The “Bounding Box” 
columns illustrate a worst case scenario for FM: we compare an al- 
gorithm written using FM to a hand-coded implementation that ac- 
cesses the data structures directly, and the amount of compute rel- 
ative to each data access is small, hi this scenario the FM version 
comes out over an order of magnitude slower. The “Edge Draw- 
ing” columns illustrate a scenario that may be more typical. Once 
again we compare an algorithm written using FM to a hand-coded 
implementation that accesses the data structures directly, but in our 
second scenario the compute time is more significant. In this sec- 
ond scenario, the FM version is slower, but by roughly only 5%. 


tests based on the 2-D TAG example discussed in the previous sec- 
tion. Our first test involves computing the bounding box of the TAG 
mesh. This test is in many respects a worst case scenario because 
we compare the abstract FM method to a hand-coded C style im- 
plementation that has direct access to the data buffers, the amount 
of computation using the data is minimal, and the data are not re- 
ally large enough for cache -miss rates to dominate. The columns 
under “Bounding Box” in Table 2 summarize the results for the ex 
ample airfoil data set, measured on a 195 MHz, dual processor SGI 
Onyx2 workstation with 5 12M of memoty. The worst case does 
look pretty bad: the difference in total times in each case is over an 
order of magnitude. Still, depending on the application, the abstract 
performance may be fast enough. 

As a second example, we consider a scenario where we gener- 
ate postscript images consisting of the edges in the TAG mesh. We 
time the actual code we used to generate the images in Figure 5. 
Like the first scenario, we compare access through FM to hand- 
coded direct access to the data structures. Unlike the first scenario, 
the computation involves some simple transformations followed by 
a write to our postscript file. This is clearly more expensive than 
our bounding box computation. The columns under “Edge Draw- 
ing” summarize the results. The FM version runs slower, but by 
roughly only 5%. For this application the overhead is likely to be 
acceptable. 

The timings in Table 2 clearly are not a thorough assessment 
of FM performance. Field Model is still relatively early in its de- 
velopment process, and we have done little performance tuning so 
far. Our plan is to port the VisTech library [21] to FM in the near 
future. VisTech consists of a collection of standard visualization 
algorithms, written in terms of FEL2 [16, 15]. We will be able to 
compare FM/VisTech performance with that of FEL2/VisTech, and 
in some cases with implementations hand-coded for specific mesh 
and field types. VisTech applications will provide examples with 
more typical balance between data access and computation as well 
as relatively typical data access patterns for visualization applica- 
tions. 

6 Conclusion 

We have presented an overview of Field Model (FM), an object- 
oriented data model for mesh and field data. FM benefits signifi- 
cantly from our experiences with FEL2 [16, 15], an earlier effort 
focused on the development of high-performance library for large 
data. FM goes beyond FEL2 in generality: FM can represent data 


with general base and physical dimensionality as well as fields with 
general node association. Furthermore, we anticipate that FM will 
be able to successfully handle adaptive mesh types. Our experience 
so far with the 2-D TAG [18] adaptive code confirms our expecta- 
tions. 

Two of the primary design goals of the FM project are modular- 
ity and extensibility. Our vision is that FM will serve as a common 
model where others in the community can contribute extensions 
specific to then mesh and field objects. The incentive would be 
that data brought into the shared model could be analyzed by what 
we hope will be a wide collection of analysis techniques written in 
terms of the model. Towards this end, we are working to establish 
FM as an Open Source [22] project, with its development home on 
SourceForge. We have established a site there (http ^/field- 
model . sourcef orge . net), and we currently have a few ini- 
tial files uploaded to the repository. We anticipate that by Vis’d 
all the source used to create objects such as those displayed in this 
article will be available from our site. 

Acknowledgements 

We would like to thank Ernst Mficke for the interlinked tori point 
set used in Figure 1 . We would also like to thank Rupak Biswas for 
providing the 2-D TAG code and example data used in Section 5.1 
We are also grateful to Pete Vanderbilt and all the members of the 
Data Analysis Group for helpful insights. Finally, we would like to 
thank VA Linux for their ongoing support of the Open Source [22] 
software movement, and SourceForge in particular. 

References 

[1] G. Abram and L. Treinish. An extended data-flow architecture 
for a data analysis and visualization. In Proceedings of Visu- 
alization ’95, pages 263-270. IEEE Computer Society Press, 

1995. 

[2] S. Parker amd D. Weinstein and C. lohnson. The SCIRun 
computational steering software system. In E. Arge, A. Bru- 
aset, and H. Langtangen, editors, Modem Software Tools for 
Scientific Computing. Birkhauser, 1997. 

[3] S. Bryson, D. Kenwright, and M. Gerald-Yamasaki. FEL: The 
field encapsulafion library. In Proceedings of Visualization 
’96, pages 241-247. IEEE Computer Society Press, October 

1996. 

[4] S. Bryson and C. Levit. The virtual windtunnel: An environ- 
ment for the exploration of three-dimensional unsteady flows. 
In Proceedings of Visualization ’91 . IEEE Computer Society 
Press, October 1991 . 

[5] D. M. Butler and M. H. Pendley. A visualization model based 
on the mathematics of fiber bundles. Computers in Physics, 
3(5):45 51, Sep/Oct 1989. 

[6] M. Cox and D. Ellsworth. Application-controlled demand 
paging for out-of-core visualization. In Proceedings of Visu- 
alization ’97, pages 235-244. IEEE Computer Society Press, 
October 1997. 

[7] E. Gamma, R. Helm, R. lohnson, and I. Vlissides. Design 
Patterns: Elements of Reusable Object-Oriented Software. 
Addison- Wesley, 1995. 

[8] R. Haber, B. Lucas, and N. Collins. A data model for scientific 
visualization with provisions for regular and irregular grids. 
Irr Proceedings of Visualization ’91, pages 298-305, October 
1991. 


7 




Appendix A 

We provide the Field Model ( FM) source for the examples pre- 
sented in the body of this report in the following pages. 


[11] N. M. Josuttis. The C++ Standard Library: A Tutorial and 
Reference. Addison-Wesley, 1999. 

[12] C. Law, K. Martin, W. Schroeder, and J. Temkin. A multi- 
threaded streaming pipeline architecture for large structured 
data sets. In Proceedings of Visualization ’99, pages 225-232, 
October 1999. 

[13] B. Lucas et al. An architecture for a scientific visualization 
system. In Proceedings of Visualization ’92, pages 107-114. 
IEEE Computer Society Press, 1992. 

[14] P. Moran and C. Henze. Large data visualization with 
demand-driven calculation. In Proceedings of Visualization 
’99, pages 27-33. IEEE Computer Society Press, October 

1999. 

[15] P. Moran and C. Henze. The FEL 2.2 reference manual. Tech- 
nical report, National Aeronautics and Space Administration, 

2000. NAS-00-007. 

[16] P. Moran, C. Henze, and D. Ellsworth. The FEL 2.2 user 
guide. Technical report, National Aeronautics and Space Ad- 
ministration, 2000. NAS -00-002. 

[17] I. R. Munkres. Elements of Algebraic Topology. Addison 
Wesley, 1984. 

[18] L. Oliker and R. Biswas. Parallelization of a dynamic un 
structured application using three leading paradigms. In Pro- 
ceedings of SC ’99. IEEE Computer Society Press, November 
1999. 

[19] S. Parker. The SCIRun Problem Solving Environment and 
Computational Steering Software System. PhD thesis. Uni- 
versity of Utah, 1999. 

[20] W. Schroeder, K. Martin, and B. Lorensen. The Visualiza- 
tion Toolkit: An Object-Oriented Approach to 3D Graphics. 
Prentice-Hall Inc., New lersey, second edition, 1997. 

[21] H.-W. Shen, T. Sandstrom, D. Kenwright, and L.-J. Chiang. 
VisTech Libraty User and Programmer Guide. National Aero- 
nautics and Space Administration, 1999. 

[22] Open Source, http : / /www . opensource . org. 

[23] L. A. Treinish. A function-based data model for visualiza- 
tion. In Visualization ’99 Late Breaking Plot Topics. IEEE 
Computer Society Press, 1999. 


[9] W. Hibbard. VisAD: Connecting people to computations and 
people to people. Computer Graphics, 32(3), 1998. 

[10] W. Hibbard, C.R. Dyer, and B. Paul. A lattice data model 
for data display. In Proceedings of Visualization ’94, pages 
310-317, October 1994. 


8 



// Emacs mode -*-c++-*- // 

#ifndef _FM_BASE_H_ 

#def ine _FM_BASE_H_ 

/* 

* NAME: FM_base . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude "FM_vector . h" 
tinclude "FM_submesh_id. h" 
tinclude "FM_time.h" 


template <int B, typename T = FM_coord> 
class FM_base : public FM_vector<B, T> 

{ 

public : 

FM_time<T> time; 

FM_submesh_id submesh_id; 

FM_base ( ) { } 

FM_base (const FM_time<T>& t, const FM_submesh_id& sid) : 
time(t), submesh_id(sid) {} 

FM_base (const FM_vector<B, T>6 v) : FM_vector<B, T> (v) {} 

FM_base (const FM_vector<B, T>6 v, 

const FM_time<FM_u32>S t, const FM_submesh_id& sid) : 
FM_vector<B, T> (v) , time(t), submesh_id (sid) {} 

} ! 

template <typename T> 

class FM_base<l,T> : public FM_vector<l, T> 

{ 

public : 

FM_time<T> time; 

FM_submesh_id submesh_id; 

FM_base ( ) { } 

FM_base (const FM_time<T>& t, const FM_submesh_id& sid) : 
time(t), submesh_id (sid) {) 

FM_base (const FM_vector<l, T>& v) : FM_vector<l , T> (v) {} 

FM_base (T c) : FM_vector<l, T> (c) {) 

FM_base(T c, const FM_time<FM_u32>& t, const FM_submesh_id& sid) : 
FM_vector<l, T> (c) , time(t), submesh_id (sid) {) 

} ; 

template <typename T> 

class FM_base<2,T> : public FM_vector<2, T> 

< 

public : 

FM_time<T> time; 

FM_submesh_id submesh_id; 

FM_base ( ) { } 

FM_base (const FM_time<T>& t , const FM_submesh_id& sid) : 
time(t), submesh_id (sid) {) 

FM_base (const FM_vector<2, T>& v) : FM_vector<2,T> (v) {} 

FM_base (T cO, T cl) : FM_vector<2, T> (cO, cl) (} 

FM_base(T cO, T cl, const FM_time<T>& t, const FM_submesh_idS sid) : 
FM_vector<2, T> (cO, cl), time(t), submesh_id(sid) {} 

} ; 

template <typename T> 

class FM_base<3, T> : public FM_vector<3, T> 

{ 

public : 

FM_time<T> time; 

FM_submesh_id submesh_id; 

FM_base ( ) { } 

FM_base (const FM_t ime<T>& t, const FM_submesh_id& sid) : 
time(t), submesh_id (sid) {) 

FM_base (const FM_vector<3, T>& v) : FM_vector<3,T> (v) {) 

FM_base (T cO, T cl, T c2) : FM_vector<3, T> (cO, cl, c2) {) 

FM_base (T cO, T cl, T c2, 

const FM_time<FM_u32>& t, const FM_submesh_id& sid) : 
FM_vector<3, T> (cO , cl, c2) , time(t), submesh_id (sid) {} 

} i 


* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

tendif 


template <int B, typename T> 

std: :ost reams operator« (std: : ost reams lhs, const FM_base<B, T>S rhs) 

{ 

lhs « "(”; 

int i; 

for (i = 0; i < B; i4+) { 

if (i > 0) lhs « ", "; 
lhs « rhs [ i] ; 

} 

if (rhs. time .defined () ) { 
if (i++ > 0) lhs « ", "; 
lhs « "time=" « rhs. time; 

} 

if (rhs . submesh_id. defined () ) { 
if (i++ > 0) lhs « ", "; 
lhs « "submesh_id=" « rhs. submesh_id; 

} 

return lhs « ") "; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction. 


9 



// Emacs mode -*-c++-*- // 
#ifndef _FM_CELL_H_ 

#def ine _FM_CELL_H_ 

/* 

* NAME: FM cell . h 


WRITTEN BY: 

Patrick Moran 


elude 

elude 


<stdexcept> 

<iost ream> 

<typeinfo> 

<assert . h> 
"FM_shared_ob ject .h" 
"FM_submesh_id . h " 
"FM_vector . h" 
"FM_base . h" 

"FM_time . h" 
"FM_combinatorics . h" 
”FM_ost ringst ream . h" 


pmoran@nas . nasa . gov 


enum FM_cell_type_enum 

{ 

FM_0 TH ER_C ELL = -1, 
FM_VERTEX_CELL = 0, 
FM_EDGE_CELL = 1, 

FM_T RI AN GL E_C ELL = 2, 
FM_TETRAHEDRON_CELL = 3, 
FM_QUADRILATERAL_CELL = 4, 
FM_P YRAM I D_CE LL = 5, 

FM_P RI SM_CELL = 6, 

FM HEXAHEDRON CELL = 8 


FM_u32 FM_cell_type_to_dimension (FM_cell_type_enum ct) 

{ 

const FM_u32 dimension [9] = {0, 1, 2, 3, 2, 3, 3, 0, 3); 
if (ct == FM_OTHER_CELL) ( 

FM_ost ringst ream err; 

err « ”FM_cell_type_to_dimension (FM_OTHER_CELL) undefined"; 
throw std: : logic_error (err. str () ) ; 

) 

return dimension [ct] ; 


class FM_mesh_; 

class FM_cell : public FM_shared_ob ject 

{ 

public : 

FM_cell ( ) {} 

FM_cell (const FM_time<FM_u32>& t, const FM_submesh_id& s) : 
time (t) , submesh_id (s) ( } 

FM_cell (const FM_cell& c) : time (c. time) , submesh_id (c . submesh_id) {} 
virtual ~FM_cell() () 

FM_time<FM_u32> get_time() const ( return time; ] 

virtual void set_time (const FM_time<FM_u32>& t) { time = t; } 

FM_submesh_id get_submesh_id ( ) const { return submesh_id; } 

virtual void set_submesh_id (const FM_submesh_id& sid) { submesh_id = sid; } 

virtual FM_u32 get_dimension () const = 0; 

virtual FM_u32 get_n_faces (FM_u32) const = 0; 

virtual FM_cell_type_enum get_type() const = 0; 

virtual bool is_equal_to (const FM_cell&) const = 0; 

virtual bool is_subs implex () const { return false; } 

virtual std: :ost reams str (std: :ost reams o) const = 0; 

virtual void 

structured_mesh_vertex_indices (const FM_mesh_* , FM_u32*, FM_u64[]) const 

{ 

FM_ost ringst ream err; 

err « *this « ":: struct ured_mesh_vert ex_indices () : not allowed"; 
throw std: : logic_error (err. str () ) ; 

) 


protected: 

FM_time<FM_u32> time; 
FM_submesh_id submesh_id; 

)•»■ 


bool operator== (const FM_cellS lhs, const FM_cellS rhs) 

{ 

return lhs. is_equal_to (rhs) ; 

} 


bool operator != (const FM_cellS lhs, const FM_cells rhs) 

{ 

return ! (lhs == rhs) ; 

} 


template <int B> class FM_structured_mesh_0_cell_iter_impl; 
template <int B> class FM_structured_mesh_B_cell_iter_impl; 


protected: 

FM_structured_cell () { ] 

FM_structured_cell (const FM_vector<B, FM_u32>S i) : indices (i) {] 

FM_structured_ce 11 (const FM_time<FM_u32>S t, const FM_submesh_idS si 
const FM_vector<B, FM_u32>& i) : 

FM_cell(t, sid), indices(i) {} 

friend class FM_structured_mesh_0_cell_iter_impl<B>; 
friend class FM_structured_mesh_B_cell_iter_impl<B>; 

public : 

virtual FM_u32 get_alignment () const 

{ 

FM_ostringstream err; 

err « *this « ": : get_alignment () : not allowed"; 
throw std : : logic_error (err . str ( ) ) ; 

} 


virtual void set_alignment (FM_u32) 

{ 

FM_ost ringst ream err; 

err « *this « " : : set_alignment () : not allowed"; 
throw std : : logic_error (err . str ( ) ) ; 


virtual FM_u32 get_subid() const 

{ 

FM_ostringstream err; 

err « *this « " : : get_subid ( ) : not allowed"; 
throw std: : logic_error (err. str () ) ; 


virtual void set_subid(FM_u32) 

{ 

FM_ostringstream err; 

err « *this « " : : set_subid() : not allowed”; 
throw std: : logic_error (err. str () ) ; 


const FM_u32* get_indices () const { return indices. v(); } 

FM_u32 get_index (FM_u32 k) const { return indices [k]; } 

virtual void set_in dices (const FM_u32 i [ ] ) 

{ 

for (int j = 0; j < B; j++) 
indices [j] = i [ j ] ; 

) 


virtual void set_index (FM_u32 k, FM__u32 i) ( indices [k] = i; ) 

virtual FM_cell_type_enum get_type() const 

{ 

FM_cell_type_enum res; 
switch (get_dimension () ) { 
case 0 : 

res = FM_VE RT EX_CE LL ; 
break; 
case 1 : 

res = FM_EDGE_CELL; 
break; 
case 2 : 

res = is_subsimplex() ? FM_TRIANGLE_CELL : FM_QUADRILATERAL_CELL 
break; 
case 3: 

res = is_subsimplex() ? FM_TETRAHEDRON_CELL : FM_HEXAHEDRON_CELL 
break ; 
default : 

res = F M_0T H E R_C EL L ; 

) 

return res; 


virtual FM_u32 get_n_faces (FM_u32 k) const 

{ 

FM_u32 d = get_dimension () ; 

return FM_choose (d, (d - k) ) * FM_pow_2 (d - k) ; 


virtual std : : ostreamS str (std : : ostreamS o) const 

{ 

switch (get_dimension () ) { 
case 0 : 
o « "V”; 
break ; 
case 1 : 
o « ”E"; 
break ; 
case 2 : 

o « (is_subsimplex () ? "F" : "Q") ; 
break; 


o « (is_subsimplex ( ) ? "T" 


default 
o « 1 

] 


"H" << get_dimension () ; 


"H") ; 


// d-cube 


o « "("; 

FM_u32 j; 

for (j = 0; j < B; j++) { 
if (j > 0) o « ", ” ; 

o « indices [j]; 


template <int B> 

class FM_st ructured_cell : public FM_cell 

{ 


if ( is_subs implex () ) { 
if (j++ >0) o « ", "; 

o « "subid=" « get_subid(); 

} 


10 



0 ; ) 


if (! (get_dimension ( ) == 0 | | get_dimension ( ) == B) ) { 
if (j++ >0) o « ", "; 

o << "alignment=" « get_alignment ( ) ; 

} 

} 

if (time . defined () ) { 
if (j++ > 0) o « ", 

o « "time= " « time; 

} 

if (submesh_id . defined () ) { 
if (j++ >0) o « ", ”; 

o << "submesh_id=" « submesh_id; 

} 

} 

protected: 

FM_vector<B, FM_u32> indices; 

} ; 


template <int B> class FM_structured_0_cell; 
template <int B> class FM_structured_B_cell; 


template <int B> 

class FM_structured_k_cell : public FM_structured_cell<B> 

{ 

public : 

FM_structured_k_cell (FM_u32 k, FM_u32 a, const FM_vector<B, FM_u32>S i) 
FM_structured_cell<B> (i) , dimension (k) , alignment (a) {) 

FM_structured_k_cell (const FM_time<FM_u32>S t, const FM_submesh_id& sid, 
FM_u32 k, FM_u32 a, const FM_vector<B, FM_u32>& i) : 
FM_structured_cell<B> (t, sid, i) , dimension (k) , alignment (a) {) 

virtual FM_u32 get_dimension () const { return dimension; } 

virtual void set_dimension (FM_u32 d) { dimension = d; } 

virtual FM_u32 get_alignment () const { return alignment; } 

virtual void set_alignment (FM_u32 a) { alignment = a; } 

virtual bool is_equal_to (const FM_cellS c) const 

{ 

const FM_structured_k_cell<B>* skc = 

dynamic_cast<const FM_structured_k_cell<B>*> (Sc) ; 
if (skc) { 
return 

time == skc->time SS 
submesh_id == skc->submesh_id SS 
dimension == skc->dimension SS 
alignment == skc->alignment SS 
indices == skc->indices; 

) 

if (dimension == 0) { 

const FM_structured_0_cell<B>* sOc = 

dynamic_cast<const FM_structured_0_cell<B>*> (Sc) ; 
if (sOc) { 
return 

time == s0c->get_time () SS 
submesh_id == s0c->get_submesh_id() SS 
indices == s0c->get_indices () ; 

} 

) 

else if (dimension == B) { 

const FM_structured_B_cell<B>* sBc = 

dynamic_cast<const FM_structured_B_cell<B>*> (Sc) ; 
if (sBc) { 
return 

time == sBc->get_time () 66 
submesh_id == sBc->get_submesh_id() SS 
indices == sBc->get_indices () ; 

) 

) 

return false; 

) 

virtual void 

structured_mesh_vertex_indices (const FM_mesh_* , FM_u32*, FM_u64[]) const; 
private : 

FM_u32 dimension; 

FM_u 32 a 1 ignme nt ; 

}/ 


template <int B> 

class FM_structured_0_cell : public FM_structured_cell<B> 

{ 

public : 

FM_structured_0_cell (const FM_time<FM_u32>S t, const FM_submesh_idS sid, 
const FM_vector<B,FM_u32>S i) : 
FM_structured_cell<B> (t, sid, i) { } 

FM_structured_0_cell (const FM_vector<B, FM_u32>S i) : 
FM_structured_cell<B> (i) { ) 

FM_structured_0_cell () { ) 

FM_structured_0_cell (const FM_base<B, FM_u32>6 b) : 

FM_structured_cell<B> (b . time, b . submesh_id, b) {) 

virtual FM_u32 get_dimension () const { return 0; } 

virtual FM_u32 get_n_faces (FM_u32 d) const { return d == 0 ? 1 : 0; ) 
virtual FM_cell_type_enum get_type() const { return FM_VERTEX_CELL; ) 


virtual FM_u32 get_alignment () const { return 

virtual bool is_equal_to (const FM_cell6 c) const 

{ 

const FM_structured_0_cell<B>* sOc = 

dynamic_cast<const FM_structured_0_cell<B>*> (Sc) ; 
if (sOc) { 

time == sO c->t ime SS 
submesh_id == s0c->submesh_id SS 
indices == s0c->indices; 

) 

const FM_structured_k_cell<B>* skc = 

dynamic_cast<const FM_structured_k_cell<B>*> (Sc) ; 
if (skc) { 

time == skc->get_time () SS 
submesh_id == skc->get_subcnesh_id() SS 
0 == skc->get_dimension () SS 
indices == skc->get_indices() ; 

} 

return false; 

J 

virtual void 

structured_mesh_vertex_in dices (const FM_mesh_*, FM_u32*, FM_u64[]) const; 


template <int B> 

class FM_structured_B_cell : public FM_structured_cell<B> 

{ 

public : 

FM_structured_B_cell (const FM_time<FM_u32>S t, const FM_submesh_idS sid, 
const FM_vector<B, FM_u32>S i) : 

FM_structured_cell<B> (t, sid, i) {) 

FM_structured_B_cell (const FM_vector<B, FM_u32>6 i) : 

FM_structured_cell<B> { i) { ) 

FM_structured_B_cell () { ) 

virtual FM_u32 get_dimension () const { return FM_u32 (B) ; ) 

virtual FM_u32 get_alignment () const { return 0; ) 

virtual bool is_equal_to (const FM_cellS c) const 

< 

const FM_structured_B_cell<B>* sBc = 

dynamic_cast<const FM_structured_B_cell<B>*> (Sc) ; 
if (sBc) { 
return 

time == sBc->time SS 
submesh_id == sBc->submesh_id SS 
indices == sBc->indices; 

} 

const FM_structured_k_cell<B>* skc = 

dynamic_cast<const FM_structured_k_cell<B>*> (Sc) ; 
if (skc) ( 
return 

time == skc->get_time () SS 
submesh_id == skc->get_submesh_id ( ) SS 
FM_u32(B) == skc->get_dimension ( ) SS 
indices == skc->get_indices () ; 

} 

return false; 

) 

virtual void 

structured_mesh_vertex_indices (const FM_mesh_*, FM_u32*, FM_u64[]) const; 


template <int B> 

class FM_structured_subsimplex : public FM_structured_cell<B> 

{ 

public : 

FM_structured_subsimplex (FM_u32 d, FM_u32 s, 

const FM_vector<B, FM_u32>S i) 
FM_structured_cell<B> (i) , dimension (d) , subid(s) {} 

FM_structured_subsimplex (const FM_time<FM_u32>6 t, 
const FM_submesh_idS sid, 

FM_u32 d, FM_u32 s, 
const FM_vector<B, FM_u32>S i) : 
FM_structured_cell<B> (t, sid, i) , dimension (d) , subid(s) {} 

virtual FM_u32 get_dimension () const { return dimension; ) 

virtual void set_dimension (FM_u32 d) { dimension = d; ) 

virtual FM_u32 get_subid() const { return subid; ) 

virtual void set_subid (FM_u32 s) { subid = s; ) 

virtual FM_u32 get_n_faces (FM_u32 k) const 

{ 

if (k > dimension) 
return 0 ; 

return FM_choose (dimension +1, k + 1) ; 

} 

virtual bool i s_sub simp lex () const { return true; ) 

virtual bool is_equal_to (const FM_cellS c) const 

{ 

const FM_structured_subsimplex<B>* ss = 

dynamic_cast<const FM_structured_subsimplex<B>*> (Sc) ; 
if (ss) { 


11 



return 

time == ss->time SS 
submesh_id == ss->submesh_id && 
dimension == ss->dimension && 
sub id == ss->subid ss 
indices == ss->indices; 


if (time . defined () ) 

o « ", time=" « time; 

if (submesh_id.def ined () ) 

o « ", submesh_id=" « submesh_id; 

return o « ") "; 


return false; 

} 


virtual void 

structured_mesh_vertex_indices (const FM_mesh_*, FM_u32*, FM_u64[]) const; 

FM_u32 dimension; 

FM_u32 subid; 


virtual bool is_equal_to (const FM_cell& c) const 

{ 

const FM_unstructured_pyramid* up = 

dynamic_cast<const FM_unstructured_pyramid*> (Sc) ; 
if (up == 0) return false; 

time == up -> time SS 
submesh_id == up->submesh_id £S 
index == up->index; 



class FM_unstructured_cell : public FM_cell 

{ 

public : 

const FM_u32 dimension; 
const FM_u64 index; 

FM_unstructured_cell (const FM_time<FM_u32>& t, const FM_submesh_id& s, 
FM_u32 d, FM_u64 i) : 

FM_cell(t, s) , dimension (d) , index(i) {} 

FM_unstructured_cell (const FM_unstructured_cell& uc, FM_u32 d, FM_u64 i) : 
FM_cell(uc), dimension (d) , index (i) {} 

virtual FM_u32 get_dimension () const { return dimension; } 

); 

class FM_unstructured_simplex : public FM_unstructured_cell 

{ 

public : 

FM_unstructured_s implex (const FM_time<FM_u32>S t, const FM_submesh_id£ s, 
FM_u32 d, FM_u64 i) : 

FM_unstructured_cell (t, s, d, i) {] 

FM_unstructured_s implex (const FM_unst ructu red_s implex S us, 

FM_u32 d, FM_u64 i) : 

FM_unstructured_cell (us, d, i) {) 

virtual FM_cell_type_enum get_type() const 

{ 

const FM_cell_type_enum types [4] = [ 

FM_VERTEX_CELL , FM_EDGE_CELL , FM_TRIANGLE_CELL, FM_TETRAHEDRON_CELL 

} ; 

return dimension <= 3 ? types [dimension] : FM_OTHER_CELL; 

} 

virtual FM_u32 get_n_faces (FM_u32 k) const 

i 

return FM_choose (dimension +1, k + 1) ; 

} 

virtual bool is_equal_to (const FM_cell& c) const 

< 

const FM_un st ructu red_simplex* us = 

dynamic_cast<const FM_unstructured_simplex*> (Sc) ; 
if (us == 0) return false; 
return 

time == us->time SS 
submesh_id == us->submesh_id SS 
dimension == us->dimension && 
index = us->index; 

) 

virtual std: :ost reams str (std: :ost reams o) const 

< 

const char letters [] = "VEFT"; 
if (dimension < 4) 

o « letters [dimension] ; 
else 

o « "S" « dimension; 
o « "(" « index; 
if (time . defined () ) 

o « ", time=" « time; 

if (submesh_id . defined () ) 

o « ", submesh_id=" « submesh_id; 

return o « ")"; 

} 

}; 


class FM_un st ructu red_pyramid : public FM_unstructured_cell 

{ 

public : 

FM_unstructured_pyramid (const FM_time<FM_u32>£ t, const FM_submesh_ids s, 
FM_u64 i) : 

FM_unstructured_cell (t, s, 3, i) {] 

FM_unstructured_pyramid (const FM_unst ructu red_cells uc, FM_u64 i) : 
FM_unstructured_cell (uc, 3, i) {) 

virtual FM_cell_type_enum get_type() const { return FM_PYRAMID_CELL; ) 

virtual FM_u32 get_n_faces (FM_u32 k) const 

{ 

const FM_u32 n_faces[] = {4, 8, 5, 1]; 
return k <= 3 ? n_faces[k] : 0; 

} 

virtual std : : ostreamS str (std: : ost reams o) const 

{ 

o « "P (" « index; 


class FM_unstructured_prism : public FM_unst ructu red_cell 

{ 

public : 

FM_unstructured_prism(const FM_time<FM_u32>£ t, const FM_submesh_idS s, 
FM_u 6 4 i) : 

FM_unstructured_cell (t, s, 3, i) {) 

FM_unstructured_prism( const FM_unstructured_cellS uc, FM_u64 i) : 
FM_unstructured_cell (uc, 3, i) { ) 

virtual FM_cell_type_enum get_type() const { return FM_PRISM_CELL; ) 

virtual FM_u32 get_n_faces (FM_u32 k) const 

{ 

const FM_u32 n_faces[] = { 6, 9, 5, 1); 
return k <= 3 ? n_faces [k] : 0; 

} 

virtual std: : ost reams str (std: : ostreamS o) const 

{ 

o « "W(" « index; // "Wedge" 
if (time, defined () ) 

o « ", time=” « time; 

if (submesh_id.def ined () ) 

o « ", submesh_id=” « submesh_id; 

return o « ") ”; 

} 

virtual bool is_equal_to (const FM_cellS c) const 

{ 

const FM_unstructured_prism* up = 

dynamic_cast<const FM_unstructured_prism*> (Sc) ; 
if (up == 0) return false; 
return 

time == up->time ££ 
submesh_id == up->submesh_id ss 
index == up->index; 



class FM_unstructured_hexahedron : public FM_unstructured_cell 
public : 

FM_unstructured_hexahedron (const FM_time<FM_u32>£ t, const FM_submesh_idS 
FM_u 64 i) : 

FM_unstructured_cell (t , s, 3, i) {) 

FM_unstructured_hexahedron (const FM_unstructured_cell£ uc, FM_u64 i) : 
FM_unstructured_cell (uc, 3, i) {) 

virtual FM_cell_type_enum get_type() const { return FM_HEXAHEDRON_CELL; ) 

virtual FM_u32 get_n_faces (FM_u32 k) const 

{ 

const FM_u32 n_faces[] = (8, 12, 6, 1); 
return k <= 3 ? n_faces[k] : 0; 

) 

virtual std :: ostreamS str (std :: ostreamS o) const 

{ 

o « "H(” « index; 
if (time . defined () ) 

o « ", time=” « time; 

if (submesh_id. defined () ) 

o « ", submesh_id=" « submesh_id; 

return o « ") "; 

) 

virtual bool is_equal_to (const FM_cellS c) const 

const FM_unst ructu red_hexahedron* uh = 

dynamic_cast<const FM_unstructured_hexahedron*> (Sc) ; 
if (uh == 0) return false; 
return 

time == uh->time SS 
submesh_id == uh->submesh_id SS 
index == uh->index; 



/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 


12 



* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_COMBINATORICS_H_ 

♦define _FM_COMBINATORICS_H_ 

/* 

* NAME: FM_combinatorics . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include <vector> 

♦include "FM_vector . h” 

template <typename T> 
void FM_swap(T* lhs, T* rhs) 

{ 

T tmp = *lhs; 

*lhs = *rhs; 

) 

template <typename T> 

T FM_fact (T n) 

{ 

T res = 1; 

for (T i = 2; i <= n; i++) 
res *= i; 
return res; 

} 


template ctypename T> 

T FM_choose (T b, T k) 

{ 

const T LUT_SIZE = 4; 
const char lut [LUT_SIZE] [LUT_SIZE] = 
{ 


<1. 

0, 

0, 

0), 


1, 

0, 

0), 

<1. 

2, 

1, 

0), 

<1. 

3, 

3, 

1} 


}; 

// assert (k <= b) ; 
return b < LUT_SIZE ? 

T (lut [b] [k] ) : FM_f act (b) / (FM_fact(b - k) * FM_fact(k)); 


template <int B> 

void FM_choose_choices (FM_u32 k, std: : vector<FM_vector<B, bool> >* choices) 

{ 

int i, ik = int(k); 
assert (ik <= B) ; 

FM_u32 n_choices = FM_choose (FM_u32 (B) , k) ; 
choices->resize (n_choices) ; 
int indices [B + 1]; 
for (i =0; i < ik; i++) 
indices [i] = i; 
indices [k] = B; 

FM_vector<B,bool> all_false, choice; 
for {i =0; i < B; i++) 
all_false[i] = false; 

for (FM_u32 c = 0; c < n_choices; C++) { 
choice = all_false; 
for (i = 0; i < ik; i++) 
choice [ indices [i] ] = true; 

(*choices) [c] = choice; 

for (i = ik - 1; i >= 0; i — ) { 

if {indices [i] + 1 < indices [i +1]) { 
indices [i]++; 

for (int j = i + 1; j < ik; j++) 
indices [j] = indices [j - 1] + 1; 
break ; 

} 

} 

} 

} 


template <typename T> 
inline T FM_pow_2 (T i) 

{ 

return 1 « i; 

} 

template ctypename T> 
inline int FM_sign (T i) 

< 

return i == T(0) ? 0 : (i > T(0) ? 1 : -1) ; 

} 

template Ctypename T> 
inline T FM_abs(T t) 

{ 

return t >= T (0) ? t : -t; 

} 


template ctypename T> 
inline T FM_min(T lhs, T rhs) 

{ 

return lhs c rhs ? lhs : rhs; 

} 


template cint N, typename T> 
bool FM_odd (const FM_vectorCN, T>& v) 
{ 

T sum = v [ 0 ] ; 

for (int i = 1; i C N; i++) 
return (sum & 1) ? true : false; 


13 



/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 


// Emacs mode — *— C++— *— // 
♦ifndef _FM_C ON S TANT_F IE LD_H_ 
♦define _FM_C ON S TANT_F IE LD_H_ 
/* 

* NAME: FM constant field. h 


* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include "FM_field.h" 

template <int B, int D, typename T> 

class FM_constant_field : public FM_f ield<B, D, T> 

{ 

public : 

const T constant; 


FM_constant_field( const FM_ptr<FM_mesh<B, D> >& m, const TS c, int 
FM_p rope rties_c ache* pc = 0) : 

FM_f ield<B, D, T> (m, na, pc), 
constant (c) {) 


virtual std: :ost reams str (std: : ostreamS o) 

{ 


return 

} 


« "FM_constant_field<” « B « 
« typeid(T) .named « ">”; 


const 

” , " « D « 


virtual int at_ce 11 (const FM_cell* c, std: : vector <T>* vals) const 
{ 

std : : vector<FM_ptr<FM_cell> > faces = 
mesh->faces (c, node_association_index) ; 
for (size_t i = 0; i < faces . size () ; i++) 
vals->push_back (constant) ; 
return FM_OK; 


virtual int at_cell (const FM_cell* c, T* vals) const 

{ 

std : : vector<FM_ptr<FM_cell> > faces = 
mesh->faces (c, node_association_index) ; 
for (size_t i = 0; i < faces . size () ; i++) 
vals[i] = constant; 
return FM_0K; 



/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


14 



// Emacs mode -*-c++-*- // 

#ifndef _FM_CONTEXT_H_ 

#def ine _FM_CONTEXT_H_ 

/* 

* NAME: FM_context . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include "FM_cell.h" 


class FM_context 

{ 

public : 

FM_context () : 

simplicial_decomposition (0) , 
locate_verbosity (0) , 
locate_effort (4) 

{} 

FM_u 32 simplicia l_de composition ; 
FM_ptr<FM_cell> last_cell; 

FM_u32 locate_verbosity; 

FM_u32 locate_ef fort; 

} ; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software”) , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_CORE_FIELD_H_ 

♦define _FM_CORE_F IELD_H_ 

/* 

* NAME: FM_core_f ield.h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include "FM_f ield.h" 

template <int B, int D, typename T> 

class FM_core_field : public FM_f ield<B, D, T> 

{ 

public : 

FM_core_fie Id (const FM_ptr<FM_mesh<B, D> >& mesh, 

FM_u32 na, FM_properties_cache* pc) 
FM_field<B, D, T> (mesh, na, pc) {) 

virtual std: :ost reams str(std: :ostreamS o) const 

{ 

return o « "FM_core_field<" « B « “," « D « "," « 
typeid(T) .name () « ">"; 

} 

} ; 


template <int B, int D, typename T> 
class FM_core_field_T_layout; 

template <int B, int D, typename T> 
std: :pair<T, T> 

FM_get_min_max_aux (const FM_ptr<FM_core_field_T_layout<B, D, T> >& field, 
const FM_time<FM_u32>* t, const FM_submesh_id* sid, 
const FM_true_typeS ) ; 

template <int B, int D, typename T> 

class FM_core_field_T_layout : public FM_core_f ield<B, D, T> 

{ 

public : 

const T* const data; 

const bool delete_suppression; 

FM_core_f ield_T_layout (const FM_ptr<FM_mesh<B, D> >& m, 
const T* d, FM_u32 na, bool ds, 
FM_properties_cache* pc = 0) : 

FM_core_f ield<B, D, T> (m, na, pc), 
data(d), delete_suppression (ds) {) 

virtual ~FM_core_f ield_T_layout () 

{ 

if ( ! delete_suppression) 
delete [] data; 

} 


virtual std : : pair<T, T> get_min_max (const FM_time<FM_u32>* t = 0, 

const FM_submesh_id* sid = 0) const 

{ 

return FM_get_min_max_aux (this, t, sid, FM_traits<T> : : is_scalar () ) ; 


virtual int at_cell (const FM_cell* c, std : : vector<T>* vals) const 

{ 

std : : vector<FM_ptr<FM_cell> > faces = 
mesh->faces (c, node_association_index) ; 
for (size_t i = 0; i < faces . size () ; i++) 

vals->push_back (data [mesh->cell_to_enum(faces [i] ) ]) ; 
return FM_0K; 


virtual int at_cell (const FM_cell* c, T* vals) const 

{ 

std : : vector<FM_ptr<FM_cell> > faces = 
mesh->faces (c, node_association_index) ; 
for (size_t i = 0; i < faces . size () ; i++) 

vals[i] = data [mesh->cell_to_enum( faces [i] ) ] ; 
return FM_0K ; 

} 

} : 


template <int B, int D, typename T> 
std: :pair<T, T> 

FM_get_min_max_aux (const FM_ptr<FM_core_field_T_layout<B, D, T> >& field, 
const FM_time<FM_u32>* t, const FM_submesh_id* sid, 
const FM_true_type& tt) 

{ 

bool blank_checking; 

field->get_simple_value ("blank_checking" , &blank_checking) ; 
if (blank_checking) 

return FM_get_min_max_aux (field, t, sid, tt) ; 

std : : pair<T, T> min_max (f ield->data [0] , field- >data [0] ) ; 
const T* d = field- >data + 1; 
const T* e = field- >data + 

f ield->mesh->get_card (f ield->node_associat ion_index) ; 
while (d != e) { 

if (*d < min_max . first) 
min_max . first = *d; 
else if (*d > minjnax . second) 
min_max . second = *d; 
d++; 

) 


// "Classic" meaning based on structured mesh, and node association index of 0 
template <int B, int D, typename T> 

class FM_classic_core_field_T_layout : public FM_core_f ield_T_layout<B, D, T> 


15 



public : 

FM_c la ss ic_co re_f ie ld_T_layout 

(const FM_ptr<FM_structured_mesh<B, D> >& m, const T* d, bool ds, 
FM_properties_cache* pc = 0) : 

FM_core_f ield_T_layout<B, D, T> (m, d, 0, ds, pc) 

{} 

virtual int 

at_cell (const FM_cell* c, std : : vector<T>* vals) const 

{ 

FM_u32 n_in dices, ■ 

FM_u64 indices [1 « B]; 

c->structured_mesh_vertex_indices (mesh, &n_indices, indices); 
if (n_indices == 1) 

vals->push_back (data [indices [0] ] ) ; 

FM_u32 previous_size = vals->size () ; 
vals->resize (previous_size + n_indices) ; 

T* dst = & (*vals) [previous_size] ; 

for (FM_u32 i = 0; i < n_indices; i++) [ 

*dst++ = data [indices [i] ] ; 

} 

} 

return FM_0K; 


virtual int 

at_cell (const FM_cell* c, T* vals) const 

{ 

FM_u32 n_indices; 

FM_u64 indices [1 « B]; 

c->structured_mesh_vertex_indices (mesh, &n_indices, indices); 
for (FM_u32 i = 0; i < n_indices; i++) 
vals[i] = data [indices [i] ] ; 
return FM_0K; 

) 

) ! 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_CURVILINEAR_MESH_H_ 

♦define _FM_CURVILINEAR_MESH_H_ 

/* 

* NAME: FM_curvilinear_mesh . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include <algorithm> 

♦include <queue> 

♦include "FM_structured_mesh . h" 

♦include "FM_orient . h" 

♦include "FM_functional. h" 

template <int B, int D> class FM_curvilinear_mesh; 


template <int B, int D> 

int FM_curvilinear_mesh_adapt ive_vertex_walk 
(const FM_curvilinear_mesh<B, D>* cm, 
const FM_phys<D>& p, 

const FM_structured_0_cell<B>& initial, FM_structured_0_cell<B>* final) 

{ 

FM_vector<D, FM_coord> cv; 

FM_structured_0_cell<B> current = initial; 
int res = cm->at_cell(Scurrent, Scv) ; 
if (res ! = FM_OK) 
return res; 

FM_coord current_distance = FM_distance2 (p, cv) ; 

FM_coord stride_size = FM_coord (0 . 1) ; 

FM_vector<B, FM_u32> stride; 
int d; 

for (d =0; d < B; d++) { 

stride[d] = FM_u32 (FM_coord(cm->dimensions [d] ) * stride_size) ; 
if (stride [d] == 0) 
stride [d] = 1; 

} 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the ''Software'') , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


for ( ; ; ) { 

bool making_progress = true; 
while (making_progress) { 

FM_coord post_step_distance, best_post_step_distance = cur rent_di stance; 
FM_structured_0_cell<B> post_step; 
post_step . set_time (initial . get_time ( ) ) ; 

FM_vector<B, FM_u32> best_post_step_indices; 

for (d = 0; d < B; d++) { 
if (stride [d] == 0) 
continue; 

if (stride [d] <= current . get_index (d) ) { 

post_step . set_indices (current ,get_indices ( ) ) ; 
post_step . set_index (d, current . get_index (d) - stride [d] ) ; 
res = cm->at_cell (Spost_step, Scv) ; 
if (res ! = FM_OK) 
return res; 

post_step_distance = FM_distance2 (p, cv) ; 
if (post_step_distance < best_post_step_distance) { 
best_post_step_distance = post_step_distance; 
best_post_step_indices = post_step . get_indices ( ) ; 

) 

) 


if (stride [d] + current . get_index (d) < cm->dimensions [d] ) { 
post_step . set_indices (current .get_indices ( ) ) ; 
post_step . set_index (d, stride[d] + current . get_index (d) ) ; 
res = cm->at_cell (&post_step, Scv) ; 
if (res != FM_OK) 
return res; 

post_step_distance = FM_distance2 (p, cv) ; 
if (post_step_distance < best_post_step_distance) { 
best_post_step_distance = post_step_distance; 
best_post_step_indices = post_step . get_indices ( ) ; 

} 

} 

} 

making_progress = best_post_step_distance < current_distance; 
if (making_progress) { 

current . set_indices (best_post_step_indices . v () ) ; 
current_distance = best_post_step_distance; 

} 

} 

bool has_a_non_zero_stride = false; 
for (d = 0; d < B; d++) { 
st ride [d] /= 2; 
if (stride [d] > 0) 

has_a_non_zero_stride = true; 

) 

if ( ! has_a_non_zero_stride) 
break ; 

} 

f inal->set_time (initial . get_time ( ) ) ; 
final->set_submesh_id(initial . get_submesh_id () ) ; 
f inal->set_indices (current . get_indices () ) ; 
return FM_OK; 


// 

// The generic FM_curvilinear_mesh<B, D> class. 

// 

template <int B, int D> 

class FM_curvilinear_mesh : public FM_structured_mesh<B, D> 
protected: 

// Note: curvilinear_mesh_initialize ( ) needs to be called by 

// the derived classes that define at_cell so this routine 


16 



// has the option of accessing vertex coordinates as part of the 

// initialization. 

void curvilinear_mesh_initialize ( ) 

{ 

FM_vector<B, FM_u32> initial_location = dimensions; 
initial_location /= 2; 

initial_locations .push_back (initial_location) ; 

} 

public : 

FM_curvilinear_mesh (const FM_vector<B, FM_u32>& dimensions, 
FM_properties_cache* pc =0) : 

FM_structured_mesh<B, D> (dimensions, pc) , 
bounding_box_valid (false) 

{} 

virtual std: :ostream& str(std: :ostream& o) const 

{ 

return o « , 'FM_curvilinear_mesh< , ' « B « ", " « D « ">"; 

} 

virtual int 

phys_to_cell (const FM_phys<D>&, FM_context*, FM_ptr<FM_cell>*) const 

{ 

FM_o string stream err; 

err « *this « " : :phys_to_cell () : not defined"; 
throw std: : logic_error (err. str () ) ; 

} 

virtual int 

adaptive_vertex_walk (const FM_phys<D>& p, 

const FM_structured_0_cell<B>& initial, 
FM_structured_0_cell<B>* final) const 

{ 

return FM_curvilinear_mesh_adaptive_vertex_walk (this, p, initial, final); 

} 

protected: 

// assume we do not need a mutex for these mutable members 

mutable std : :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > bounding_box; 
mutable bool bounding_box_valid; 

private : 

std: : vector<FM_vector<B, FM_u32> > initial_locations; 

} ; 


// 

// FM_curvilinear_mesh<3, 3> defines hexahedral and tetrahedral walk 
// point location methods. 

// 

template <> 

class FM_curvilinear_mesh<3, 3> : public FM_structured_mesh<3, 3> 

{ 

protected: 

// Note: curvilinear_mesh_initialize ( ) needs to be called by 

// the derived classes that define at_cell so this routine 
// has the option of accessing vertex coordinates as part of the 
// initialization, 
void curvilinear_mesh_initialize ( ) 

{ 

// choose initial positions for starting searches for a close vertex 
// choose center of each of the 6 mesh faces as FEL1 does 
FM_u32 dim0_050 = (dimensions [ 0] - 1) / 2; 

FM_u32 dimOml = dimensions [0] - 1; 

FM_u32 diml_050 = (dimensions [ 1] - 1) / 2; 

FM_u32 dimlml = dimensions [1 ] - 1; 

FM_u32 dim2_050 = (dimensions [ 2] - 1) / 2; 

FM_u32 dim2ml = dimensions [2] - 1; 

int d; 

FM_vector<3, FM_u32> initial_location; 
for (d = 0; d < 3; d++) 

initial_location [d] = dimensions [d] / 2; 
initial_locations .push_back (initial_location) ; 

initial_locations .push_back (FM_vector<3, FM_u32> (dim0_050, diml_050, 1)) ; 
init ial_locations .push_back 

(FM_vector<3, FM_u32> (dim0_050, diml_050, dim2ml) ) ; 
init ial_lo cat ions .push_back (FM_vector<3, FM_u32> (dim0_050, 1, dim2_050) ); 
init ial_lo cat ions .push_back 

(FM_vector<3, FM_u32> (dim0_050, dimlml, dim2_050) ) ; 
init ial_lo cat ions .push_back (FM_vector<3, FM_u32> (1, diml_050, dim2_050) ); 
init ial_lo cat ions .push_back 

(FM_vector<3, FM_u32> (dimOml, diml_050, dim2_050) ) ; 

) 

public : 

FM_curvilinear_mesh (const FM_vector<3, FM_u32>& dimensions, 

FM_p rope rties_c ache* pc = 0) : 

FM_structured_mesh<3, 3> (dimensions, pc) , 
bounding_box_valid (false) 

{} 

virtual std: :ost reams str (std: :ost reams o) const 

{ 

return o « "FM_curvilinear_mesh<3, 3>” ; 

} 

virtual int 

adapt ive_vertex_walk (const FM_phys<3>& p, 

const FM_structured_0_cell<3>& initial, 
FM_structured_0_cell<3>* final) const 

{ 

return FM_curvilinear_mesh_adaptive_vertex_walk (this, p, initial, final); 

} 

int hexahedral_walk_locate (const FM_phys<3>& p, 

const FM_ptr<FM_structured_cell<3> >& initial, 
FM_context * ct xt , 


FM_ptr<FM_cell>* c) const 

{ 

FM_ostringstream verbose_pref ix; 
if (ctxt->locate_verbosity >0) { 

verbose_prefix « *this « ": : hexahedral_walk_locate ( ” « p « ", ” « 
initial «",,): "; 

std::cout « verbose_pref ix . str ( ) « std::endl; 

) 

assert (initial->get_dimension () == 3); 

FM_vector<3, FM_u32> indices = initial->get_indices () ; 

FM_u32 face = 0; 

FM_u32 faces_tested = 0; 

FM_u32 total_faces_tested = 0; 

FM_u32 total_faces_tested_threshold = 

2 * (dimensions [ 0] + dimensions [1] + dimensions [2] ) ; 
bool suppressed_step_of f_mesh = false; 

FM_vector<3 , FM_coord> cv [ 8 ] ; 

FM_u32 even_odd = 

FM_simplicial_decomposition_odd (indices, 

ctxt->simplicial_decomposition) ? 1 : 0; 

int res; 

while (faces_tested < 6) { 
total_faces_tested += 1; 

if (total_faces_tested > total_faces_tested_threshold) { 
if (ctxt->locate_verbosity > 0) 

std::cout « verbose_pref ix . str () « 

"stuck, giving up" « std::endl; 
return FM_POINT_LOCATE_STUCK; 

} 

*c = new FM_structured_B_cell<3> (initial->get_time () , 

initial->get_submesh_id() , 
indices) ; 

res = at_cell(*c, cv) ; 
if (res != FM_0K) return res; 

int orientation = 

FM_orient (cv [FM_hexahedron_face [even_odd] [face] [0] ] , 
cv [FM_hexahedron_face [even_odd] [face] [1] ] , 
cv [FM_hexahedron_face [even_odd] [face] [2] ] , 
cv [FM_hexahedron_f ace [even_odd] [face] [3]] , 

P) / 

bool outside = orientation < 0; 
if (ctxt->locate_verbosity > 1) 

std::cout « verbose_pref ix . str () « **c « ", face: " « face « 

", " « FM_orientation_names [orientation + 1] « std::endl; 

if (outside) { 

// step to next hexahedron, if step does not take us off mesh 
FM_u32 axis = face / 2; 
bool low_side = !bool(face S 1); 
if (low_side) [ 

if (indices [axis] == 0) { 

suppressed_step_of f_mesh = true; 
goto next_hexahedron_face; 

} 

indices [axis] -= 1; 

} 

else { 

if (indices [axis] == dimensions [axis] - 2) { 
suppressed_step_of f_mesh = true; 
goto next_hexahedron_face; 

) 

indices [axis] += 1; 

) 

even_odd ' = 1; 
face = face ' 1; 
faces_tested = 0; 
suppressed_step_of f_mesh = false; 

) 

next_hexahedron_face : 
face = (face + 1) % 6; 
faces_tested += 1; 

) 

ctxt->last_cell = *c; 

if ( ! supp re s s ed_st ep_o f f _me sh ) { 
res = FM_0K; 

if (ctxt->simplicial_decomposition) [ 

FM_ptr<FM_structured_B_cell<3> > sc = *c; 
res = phys_to_subsimplex (p, sc, ctxt, c) ; 

) 

) 

else 

res = FM_POINT_LOCATE_WALKED_OFF_MESH; 
if (ctxt->locate_verbosity > 1) 

std : : cout « verbose_pref ix. str () « "tested " « total_faces_tested « 
" quadrilaterals" « std::endl; 
if (ctxt->locate_verbosity > 0) 

std :: cout « verbose_pref ix. str () « **c « ", returning " << 
res « std::endl; 

return res; 


int tetrahedral_walk_locate (const FM_phys<3>& p, 

const FM_ptr<FM_structured_cell<3> >& initial, 
FM_context* ctxt, 

FM_ptr<FM_cell>* c) const 

FM_ostringstream verbose_prefix; 
if (ctxt->locate_verbosity >0) { 

verbose_pref ix « *this « ": : tetrahedral_walk_locate (" « p « ", " << 


17 



« ”, returning " << 


* initial « 

std::cout « verbose_pref ix . str () « std: :endl; 

} 

assert (initial->get_dimension ( ) == 3) ; 

FM_vector<3, FM_u32> indices = initial- >get_indices ( ) ; 

FM_u32 subid; 

if (initial->is_subsimplex ( ) ) 
subid = initial->get_subid ( ) ; 

! FM_s implicial_decomposit ion_odd 

(indices, ctxt->simplicial_decomposition) ? 4 : 9; 
bool new_cell = true; 

FM_u32 face = 0; 

FM_u32 faces_tested = 0; 

FM_u32 total_faces_tested = 0; 

FM_u32 total_faces_tested_threshold = 

4 * 5 * (dimensions [ 0] + dimensions [1] + dimensions [2] ) ; 
bool suppressed_step_off_mesh = false; 

FM_vector<3, FM_coord> cv[8]; 
int res; 

while (faces_tested < 4) { 
total_faces_tested += 1; 

if (total_faces_tested > total_faces_tested_threshold) { 
if (ctxt->locate_verbosity > 0) 

std::cout « verbose_pref ix . str ( ) « 

"stuck, trying hexahedral_walk_locate" « std: :endl; 
return hexahedral_walk_locate (p, initial, ctxt, c) ; 

} 

if (new_cell) { 

*c = new FM_structured_B_cell<3> (initial->get_time () , 

initial->get_submesh_id() , 
indices) ; 

res = at_cell (*c, cv) ; 
if (res != FM_OK) return res; 
new_cell = false; 

) 

int orientation = 

FM_orient (cv [FM_subtetrahedron_face [ subid] [face] [0]], 
cv [FM_subtetrahedron_face [subid] [face] [1]], 
cv [FM_subtetrahedron_face [ subid] [face] [2]], 

P) ! 

bool outside = orientation < 0; 

if (ctxt->locate_verbosity > 1) 

std::cout « verbose_pref ix . str () « **c « ”, subid: ” « 
subid « ", face: " « face << ", " « 

FM_orientation_names [orientation + 1] « std::endl; 

if (orientation == 0) 

return hexahedral_walk_locate (p, *c, ctxt, c) ; 
if (outside) ( 

// step to next tetrahedron, if step does not take us off mesh 
FM_u32 axis = FM_tetrahedron_step [subid] [face] .axis; 
switch (FM_tetrahedron_step [ subid] [face] .dir) { 
case 0 : 
break; 
case -1 : 

if (indices [axis] == 0) { 

suppressed_step_of f_mesh = true; 
goto next_subtetrahedron_face; 

) 

indices [axis] -= 1; 
new_cell = true; 
break; 
case 1 : 

if (indices [axis] == dimensions [axis] - 2) { 
suppressed_step_of f_mesh = true; 
goto next_subtetrahedron_face; 

) 

indices [axis] += 1; 
new_cell = true; 
break; 
default : 
abort () ; 

} 

FM_u32 prev_subid = subid; 

FM_u32 prev_face = face; 

subid = FM_tetrahedron_step [prev_subid] [prev_face] . subsimplex; 
face = FM_tetrahedron_step [prev_subid] [prev_face] . subsimplex_face; 
faces_tested = 0; 
suppressed_step_of f_mesh = false; 

} 

next_subtetrahedron_face : 
face = (face + 1) & 3; 
faces_tested += 1; 

} 

if ( ! suppressed_step_off_mesh) { 

if (ctxt ->s imp licial_decomposit ion) 

*c = new FM_structured_subsimplex<3> ( (*c) ->get_time ( ) , 

(*c) ->get_submesh_id () , 

3, subid, indices) ; 

res = FM_0K ; 

} 

res = FM_POINT_LOCATE_WALKED_OFF_MESH; 
ctxt->last_cell = *c; 
if (ctxt->locate_verbosity > 1) 

std::cout « verbose_pref ix . str () « "tested " « total_f aces_tested « 
" triangles" « std::endl; 
if (ctxt->locate_verbosity > 0) 


std : : cout « verbose_pref ix . str ( ) « **c 
res « std::endl; 

return res; 

J 

virtual int 

phys_to_cell (const FM_phys<3>& p, FM_context* ctxt, FM_ptr<FM_cell>* c) const 

{ 

FM_ostringstream verbose_pref ix; 
if (ctxt->locate_verbosity >0) { 

verbose_pref ix « *this « ": :phys_to_cell (” « p « ", , ) : "; 
std:: cout « verbose_pref ix . str ( ) « std: :endl; 


int res; 

FM_u32 axis; 

while (1) { 

// if we have a previous cell, try walking from there 
if (ctxt->last_cell) { 

if (ctxt->locate_verbosity >0) { 

std:: cout « verbose_pref ix . str () « "starting from last_cell " « 
*ctxt->last_cell « std: :endl; 

) 

res = tetrahedral_walk_locate (p, ctxt->last_cell, ctxt, c) ; 
if (res == FM_0K) break; 


// first test against bounding box 
if (!bounding_box_valid) 

(void) get_bounding_box () ; 
bool outside = false; 
for (axis = 0; axis < 3; axis++) { 

if (! (bounding_box . first [axis] <= p[axis] SS 

p[axis] <= bounding_box. second [axis] ) ) { 
res = FM_POINT_OUTSIDE_BOUNDING_BOX; 
outside = true; 
break ; 

} 

} 

if (outside) break; 

// put initial locations in priority queue (pq) , ordered by 
// distance to p (closest to farthest) ; adaptive vertex walk, 

// then tetrahedral walk from each unique adaptive walk destination 
// until success or queue is empty 

typedef std: :pair<FM_coord, FM_vector<3, FM_u32> > pq_element; 
typedef std: : vector<pq_element> pq_impl; 
typedef FM_f irst_greater_pred<pq_element> pq_pred; 
std : : pr iority_queue<pq_element , pq_impl , pq_pred> 
initial_locations_priority_queue; 

FM_structured_0_cell<3> v; 

// v.set_time 

// fill priority queue 

for (FM_u32 i = 0; i < initial_locations . size ( ) ; i++) { 
v. set_indices (initial_locations [i] . v () ) ; 

FM_vector<3, FM_coord> cv; 
res = at_cell(Sv, Scv) ; 
if (res ! = FM_0K) break; 

FM_coord d2 = FM_di stance 2 (p, cv) ; 
initial_locations_priority_queue . push 

(std: :make_pair (d2, initial_locations [ i] ) ) ; 

} 

if (res != FM_0K) break; 

// walk from each location in queue 

std : : vector<FM_vector<3, FM_u32> > adapt ive_walk_dest inat ions; 
while (! initial_locations_priority_queue . empty () ) { 

v. set_indices (initial_locations^priority_queue . top ( ) . second. v() ) ; 
initial_locations_priority_queue.pop () ; 

FM_st ructured_0_cell<3> adapt ive_wa lk_dest inat ion ; 

res = adaptive_vertex_walk (p, v, & adapt ive_walk_dest inat ion) ; 

if (res != FM_0K) break; 

// do not repeat tetrahedral walk if already done from this 
// adaptive vertex walk destination — i.e, been there, done that 
if (std: : find (adaptive_walk_destinations .begin () , 
adaptive_walk_destinations . end () , 
adaptive_walk_destination. get_indices () ) != 
adapt ive_walk_dest inat ions . end ( ) ) 
continue; 

adaptive_walk_destinations . push_back 

(adaptive_walk_destination . get_indices () ) ; 

// step back if necessary from boundary before constructing hexahedron 
FM_vector<3, FM_u32> indices = adaptive_walk_destination . get_indices () ; 
for (axis = 0; axis < 3; axis++) { 

if (indices [axis] == dimensions [axis] - 1) 
indices [axis] — ; 

) 

FM_ptr<FM_structured_cell<3> > initial_cell = 
new FM_structured_B_cell<3> (indices) ; 

res = tetrahedral_walk_locate (p, initial_cell , ctxt, c) ; 
if (res == FM_OK) break; 




if (ctxt->locate_verbosity > 0) 

std :: cout « verbose_pref ix . str ( ) « "returning " << res << std::endl; 


protected: 

// assume we do not need a mutex for these mutable members 

mutable std : : pair<FM_vector<3, FM_coord>, FM_vector<3, FM_coord> > bounding_box; 
mutable bool bounding_box_valid; 


18 



private : 

std: : vector<FM_vector<3, FM_u32> > initial_locations; 

} ! 


1 1 

// FM_curvilinear_mesh_T_layout<B, D> is a curvilinear mesh where the 
// coordinates are contained in a single array of FM_vector<D, FM_coord>, 

// i.e., an array where the coordinates for each vertex are contiguous. 

// 

template <int B, int D> 

class FM_curvilinear_mesh_T_layout : public FM_curvilinear_mesh<B, D> 

{ 

public : 

const FM_vector<D, FM_coord>* const coordinates; 
const bool delete_suppression; 

FM_curvilinear_mesh_T_layout (const FM_vector<B, FM_u32>& dimensions, 

const FM_vector<D , FM_coord>* c, bool ds, 
FM_propert ies_cache* pc =0) : 
FM_curvilinear_mesh<B, D> (dimensions, pc) , 
coordinates (c) , 
delete_suppression (ds) 

{ 

curvilinear_mesh_initialize () ; 

} 

~FM_curvilinear_mesh_T_layout () 

{ 

if ( ! delete_suppression) 
delete [] coordinates; 

} 

virtual std : :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > 
get_bounding_box (const FM_time<FM_u32>* = 0, 

const FM_submesh_id* = 0) const; 

virtual int 

at_cell (const FM_cell* c, std : : vector<FM_vector<D, FM_coord> >* vals) const 

{ 

FM_u32 n_indices; 

FM_u64 indices [1 « B]; 

c->structured_mesh_vertex_indices (this, &n_indices, indices); 
if (n_indices == 1) 

vals->push_back (coordinates [indices [0] ] ) ; 
else { 

FM_u32 previous_size = vals->size () ; 
vals->resize (previous_size + n_indices) ; 

FM_vector<D, FM_coord>* dst = S (*vals) [previous_size] ; 
for (FM_u32 i = 0; i < n_indices; i++) { 

*dst++ = coordinates [ indices [i] ] ; 

} 

} 

return FM_0K; 

} 

virtual int 

at_cell (const FM_cell* c, FM_vector<D, FM_coord>* vals) const 

{ 

FM_u32 n_indices; 

FM_u64 indices [1 « B]; 

c->structured_mesh_vertex_indices (this, Sn_indices, indices); 
for (FM_u32 i = 0; i < n_indices; i++) 
vals[i] = coordinates [ indices [i] ] ; 
return FM_0K; 

) 

} ; 


bb. second = *cp; 

Cp44; 

// k = 0 slice 

FM_u32 dimens ion s_0_dimensions_l = dimensions [0 ] * dimensions 
for (i = 1; i < dimen sions_0_dimensions_l; i++) 
FM_operator_min_max_equals (bb, *cp++) ; 

// edge of k = 1 to dimensions [2] - 2 slices 
for (k = 1; k < dimensions [ 2] - 1; k++) { 
for (i =0; i < dimensions [ 0] ; i++) 

FM_operator_min_max_equals (bb, *cp++) ; 
for (j =1; j < dimensions [ 1] - 1; j++) { 
FM_operator_min_max_equals (bb, *cp) ; 
cp += dimensions [ 0] - 1; 

FM_operator_min_max_equals (bb, *cp++) ; 

} 

for (i =0; i < dimensions [ 0] ; i++) 

FM_operator_min_max_equals (bb, *cp++) ; 

} 

// k = dimensions [2] - 1 slice 

for (i = 0; i < dimensions_0_dimensions_l; i++) 
FM_operator_min_max_equals (bb, *cp++) ; 

bounding_box = bb; 
bounding_box_valid = true; 

} 

return bounding_box; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the ''Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

fendif 


// 

// FM_curvilinear_mesh_T_layout<B, D> : : get_bounding_box works with 

II a pointer directly into the coordinates buffer, testing every vertex. 

// 

template <int B, int D> 

std: :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > 
FM_curvilinear_mesh_T_layout<B, D>: : 

get_bounding_box (const FM_time<FM_u32>*, const FM_submesh_id* ) const 

{ 

if ( !bounding_box_valid) { 

std: :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > bb; 

const FM_vector<D, FM_coord>* cp = coordinates; 

bb. first = *cp; 

bb . second = *cp; 

cp++; 

FM_u64 cardO = get_card(0); 

for (FM_u64 i = 1; i < cardO; i++) 

FM_operator_min_max_equals (bb, *cp++) ; 
bounding_box = bb; 
bounding_box_valid = true; 

} 

return bounding_box; 


// 

// FM_curvilinear_mesh_T_layout<3, 3> : : get_bounding_box works with 
// a pointer directly into the coordinates buffer, testing vertices 
// on the boundary of the mesh. 

// 

template <> 

std: :pair<FM_vector<3, FM_coord>, FM_vector<3, FM_coord> > 
FM_curvilinear_mesh_T_layout<3, 3>: : 

get_bounding_box (const FM_time<FM_u32>* , const FM_submesh_id* ) const 

{ 

if ( !bounding_box_valid) { 

FM_u32 i, j, k; 

std: :pair<FM_vector<3, FM_coord>, FM_vector<3, FM_coord> > bb; 
const FM_vector<3, FM_coord>* cp = coordinates; 
bb. first = *cp; 


19 



// Emacs mode -*-c++-*- // 

#ifndef _FM_DERIVED_FIELD_H_ 

#def ine _FM_DERIVED_FIELD_H_ 

/* 

* NAME: FM_derived_f ield. h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude "FM_f ield . h" 


template <int B, int D, typename S, typename T, typename F> 
class FM_unary_derived_field : public FM_f ield<B, D, T> 

{ 

public : 

const FM_ptr<FM_shared_ob ject> so; 
const FM_field_interface<B, D, S>* field; 
const F function; 

FM_unary_derived_f ield (const FM_ptr<FM_f ield<B, D, S> >& f, 

const FS fun, FM_properties_cache* pc = 0) : 
FM_f ield<B, D, T> (f->mesh, f->node_association_index, pc), 
so (f ) , 
field (f) , 
function (fun) 

{} 

FM_unary_derived_f ield (const FM_ptr<FM_mesh<B, D> >& m, 

const FS fun, FM_properties_cache* pc = 0) : 
FM_field<B,D,T> (m, 0, pc), 
so (m) , 
field (m) , 
function (fun) 

<) 

virtual std: :ost reams str (std: :ost reams o) const 

{ 

return o « "FM_unary_derived_f ield<" « 

B « ", " « D « " « typeid(S) .named << ", " « 

typeid (T) . name () « "," « typeid (F) . name () « ">"; 

) 

virtual int at_cell (const FM_cell* c, std: : vector<T>* vals) const 

{ 

std: :vector<S> tmp; 

int res = f ield->at_cell (c, Stmp) ; 

if (res != FM_0K) return res; 

FM_u32 previous_size = vals->size () ; 
vals->resize (previous_size + tmp. sized); 

T* dst = S(*vals) [previous_size] ; 
for (size_t i = 0; i < tmp. sized; i++) { 
res = function (tmp [i] , dst++) ; 
if (res ! = FM_0K) break; 

} 

return res; 

} 

virtual int at_cell (const FM_cell* c, T* vals) const 

{ 

std: : vector<S> tmp; 
int res = f ield->at_cell (c, Stmp) ; 
if (res != FM_0K) return res; 
for (size_t i = 0; i < tmp. sized; i++) { 
res = function (tmp [i] , Svals[i]); 
if (res != FM_0K) break; 

) 

return res; 

) 

} ; 


template <int B, int D, typename R, typename S, typename T, typename F> 
class FM_binary_derived_f ield : public FM_f ield<B, D, T> 

{ 

public : 

const FM_ptr<FM_shared_ob ject> lhs_so; 
const FM_ptr<FM_shared_ob ject> rhs_so; 
const FM_f ield_interface<B, D, R>* lhs_field; 
const FM_field_interface<B, D, S>* rhs_field; 
const F function; 

FM_binary_derived_f ield (const FM_ptr<FM_field<B, D, R> >S lhs, 
const FM_ptr<FM_field<B, D, S> >S rhs, 
const FS fun, 

FM_properties_cache* pc = 0) : 

FM_f ield<B, D, T> (lhs->mesh, lhs->node_association_index, pc), 

lhs_so (lhs) , 

rhs_so (rhs) , 

lhs_field (lhs) , 

rhs_field (rhs) , 

function (fun) 

{ 

init () ; 

} 

virtual std: :ost reams str(std: :ostreamS o) const 

{ 

return o « "FM_binary_derived_f ield<" « B « "," « D « « 

typeid(R) .named « "," « typeid (S) . name ( ) « "," « 
typeid(T) .named « "," « typeid (F) . name ( ) « ">"; 

} 

virtual int at_cell (const FM_cell* c, std :: vector <T>* vals) const 

{ 

std: :vector<R> lhs_tmp; 
int res; 

res = lhs_f ield->at_cell (c, Slhs_tmp) ; 

if (res ! = FM_0K ) return res; 

std: :vector<S> rhs_tmp (lhs_tmp . size () ) ; 


rhs_tmp . clear ( ) ; 

res = rhs_f ield->at_cell (c, Srhs_tmp) ; 
if (res != FM_0K) return res; 

FM_u32 previous_size = vals->size () ; 
vals->resize (previous_size + lhs_tmp . size ( ) ) ; 
for (size_t i = 0; i < lhs_tmp . size () ; i++) { 

res = function (lhs_tmp [i] , rhs_tmp[i], S (*vals) [previous_size + i] ) ; 
if (res ! = FM_0K) break; 

} 

J 

virtual int at_cell (const FM_cell* c, T* vals) const 

{ 

return — 1; 

) 


private : 

void init () const { 

if (lhs_f ield->mesh != rhs_field->mesh) { 

FM_ostringstream err; 

err « "FM_b inary _derived_f ield ("; 

err « *lhs_so « ", " « *rhs_so « ", ) : "; 

err « "fields must be based on same mesh"; 

throw std : : logic_error (err . str ( ) ) ; 

J 

if (lhs_f ield->node_association_index != 
rhs_f ield->node_association_index) { 

FM_ostringstream err; 

err « "FM_b inary _derived_f ield ("; 

err « *lhs_so « ", " « *rhs_so « ", ) : 

err « "node association indices must match (node_association_indices 
err « lhs_f ield->node_association_index « ", "; 
err « rhs_f ield->node_association_index « ") "; 
throw std: : logic_error (err. str () ) ; 



/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

#endif 


20 



// Emacs mode -*-c++-*- // 

#ifndef _FM_FIELD_H_ 

#def ine _FM_FIELD_H_ 

/* 

* NAME: FM_f ield. h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

finclude <typeinfo> 
finclude <string> 
finclude <vector> 

finclude "FM_shared_ob ject_with_p roper ties_cache . h" 
finclude "FM_f ield_interf ace . h" 
finclude "FM_mesh . h" 
finclude "FM_ostringstream.h'' 


template <int B, int D, typename T> 

class FM_field : public FM_field_, public FM_field_interface<B, D, T> 

{ 

public : 

FM_field( const FM_ptr<FM_mesh<B, D> >6 m, FM_u32 na, 

FM_p rope rties_c ache* pc) : 

FM_field_(m, typeid(T) .named , pc) , 

FM_field_interface<B, D, T> (m, na) 

{ 

} 

virtual std : : ostreamS str (std : : ostreamS o) const 

{ 

return o « FM_field_type_name (B, D, typeid (T) . name ()) ; 

) 


finclude "FM_structured_mesh . h" 

std:: string FM_f ield_type_name (FM_u32 b, FM_u32 d, const char* t) 

{ 

FM_o string stream os; 

os « "fieldc" « b « ", “ « d « " « t « ">"; 

return os . str ( ) ; 


class FM_field_ : public FM_shared_ob ject_with_properties_cache 

{ 

public : 

const FM_ptr<FM_mesh_> mesh_; 
const char* const node_type; 
const bool structured_behavior; 

FM_field_( const FM_ptr<FM_mesh_>6 m, const char* nt, 
FM_properties_cache* pc) : 

FM_shared_ob ject_with_properties_cache (pc) , 
mesh_(m) , 
node_type (nt) , 

structured_behavior (mesh_->get_structured_behavior () ) 

{} 

inline FM_iter begin () const { return mesh_->begin () ; } 
inline FM_iter begin (const FM_iter_attrs6 ia) const 
{ 

return mesh_->begin (ia) ; 

) 

inline FM_iter end() const { return mesh_->end() ; } 
protected: 

virtual FM_ptr<FM_shared_ob ject> 

get_aux (const std:: strings key, FM_u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) const 

{ 

if (key == "node_type") { 

return new FM_simple_value<std : : string> (node_type) ; 

} 

else if (key == "field_type_name") { 

return new FM_simple_value<std : : string> 

(FM_f ield_type_name(mesh_->base_dimensionality, 
mesh_->phys_dimensionality, 
node_type) ) ; 

) 

else if (key == "mesh") { 
return mesh_; 

) 


virtual std: :pair<T, T> get_min_ma 

{ 

return FM_get_min_max_aux (this, 

} 


inst FM_time<FM_u32>* t = 0, 

inst FM_submesh_id* sid = 0) const 

sid, FM_traits<T> : : is_scalar () ) ; 


virtual int at_phys (const FM_phys<D>& p, FM_context* ctxt, T* val) const 

{ 

int res ; 

if (structured_behavior 66 node_association_index == 0 66 
ctxt->simplicial_decomposition == 0) { 

FM_base<B> b; 

FM_pt r < FM_s t r u ct ur ed_B_ce 1 1 <B > > sc; 

res = mesh->phys_to_base (p, ctxt, Sb, Ssc) ; 

if (res ! = FM_0K) return res; 

T vals [ 1 « B] ; 

res = at_cell(sc, vals); 

if (res ! = FM_0K) return res; 

res = FM_linear_interpolate (b, sc, vals, val); 

} 

else { 

FM_pt r<FM_cell> c; 

res = mesh->phys_to_cell (p, ctxt, 6c); 

if (res != FM_0K) return res; 

std: : vector<T> vals; 

res = at_cell (c, 6 vals) ; 

if (res != FM_0K) return res; 

// interpolate . . . 
res = -1; 

} 

return res; 


protected: 

virtual FM_ptr<FM_shared_ob ject> 

get_aux (const std::string& key, FM_u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) const 

< 

if (key == "node_association_index") { 

return new FM_simple_value<FM_u32> (node_association_index) ; 

) 

else if (key == "min_max") { 

std: : pair<T, T> min_max = get_min_max (t, sid); 

return new FM_tuple_value (new FM_simple_value<T> (min_max . first) , 

new FM_simple_value<T> (min_max . second) ) ; 

) 

return FM_f ield_: : get_aux (key , pass, t, sid); 


FM_ptr<FM_shared_ob ject> me sh_p roper ty; 
try { 

mesh^property = mesh_->get (key, t, sid) ; 

) 

catch (...) { 

) 

if (mesh_property != 0) 
return mesh_property; 

return FM_shared_ob ject_with_properties_cache: : 
get_aux(key, pass, t, sid); 

) 

virtual std : : set<std : : string> 

get_property_names_aux (std : : set<std : : string>6 property_names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) const 

{ 

property_names . insert ("node_type") ; 
property_names . insert ("f ield_type_name") ; 
property_names . insert ("mesh") ; 

std: : set<std: : string> mesh_property_names = 
mesh_->get_property_names (t , sid) ; 
std: :set<std: : string> : : const_iterator iter; 
for (iter = mesh_property_names .begin () ; 

iter != mesh_property_names .end () ; ++iter) 
property_names . insert (*iter) ; 

return FM_shared_ob ject_with_properties_cache: : 
get_property_names_aux (property_names, t, sid); 

} 

} ; 

template <int B, int D, typename T> 
class FM_f ield; 

template <int B, int D, typename T, typename S> 
std: :pair<T, T> 

FM_get_min_max_aux (const FM_f ield<B, D, T>* , const FM_time<FM_u32>*, 
const FM_submesh_id*, const S6) ; 


virtual std : : set<std : : string> 

get_property_names_aux (std: :set<std: :string>6 property_names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) const 

{ 

property_names . insert ( "node_association_index") ; 
property_names . insert ( "min_max" ) ; 

return FM_f ield_: : get_property_names_aux (property_names, t, sid); 

} 

} ; 


template <int B, int D, typename T, typename S> 
std: :pair<T, T> 

FM_get_min_max_aux (const FM_f ield<B, D, T>* field, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid, const S6) 

i 

FM_ostringstream err; 

err « *field « ": : get_min_max (" « 

(t ? *t : FM_time<FM_u32> () ) « ", " « 

(sid ? *sid : FM_submesh_id ( ) ) « ") : "; 
err « "not defined for node type " « typeid (T) .named ; 
throw std: : logic_error (err. str () ) ; 


template <int B, int D, typename T> 
std: :pair<T, T> 

FM_get_min_max_aux (const FM_f ield<B, D, T>* field, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid, 
const FM_t rue_type6 ) 

std: :pair<T,T> min_max; 

FM_iter_attrs iter_attrs; 

iter_attrs . push_back (new FM_cell_dimension_iter_attr 

(field->node_association_index) ) ; 

if (t 66 t->def ined ( ) ) 

iter_attrs . push_back (new FM_time_iter_attr (*t) ) ; 
if (sid 66 sid->def ined () ) 

iter_attrs . push_back (new FM_submesh_id_iter_attr (*sid) ) ; 

FM_iter i = field->begin (iter_attrs) ; 

FM_iter e = f ield->end ( ) ; 


21 



std: : vector<T> vals(l); 
for ( ; i != e; ++i) { 
vals. clear () ; 

int res = f ield->at_cell (*i, Svals) ; 
if (res == FM_OK) break; 

} 

if (i == e) { 

FM_o string stream err; 

err « * fie Id « " : : get_min_max ( ” « 

(t ? *t : FM_time<FM_u32> ( ) ) « ", " « 
(sid ? *sid : FM_submesh_id ( ) ) « 

") : no valid values"; 
throw std : : logic_error (err . str ( ) ) ; 

} 

min_max. first = vals[0]; 
mi n_max. second = vals[0]; 

++i; 

for ( ; i != e; ++i) { 
vals. clear () ; 

int res = f ield->at_cell (*i, Svals); 
if (res ! = FM_OK ) continue; 
if (vals[0] < min_max . first) 
min_max . first = vals[0]; 
else if (vals[0] > min_max . second) 
min_max . second = vals [0 ] ; 

} 

return min_max; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software”) , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


/ / Emacs mode — *— C++— *— / / 

♦ifndef _FM_FIELD_INTERFACE_H_ 

♦define _FM_FIELD_INTERFACE_H_ 

/* 

* NAME: FM_field_interf ace. h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include <vector> 

♦ inc lude "FM_phy s . h " 

♦include "FM_base . h" 

♦include "FM_context . h " 

♦include "FM_cell.h" 

♦include "FM_shared_ob ject . h" 


template <int B, int D> 
class FM_mesh; 

template <int B, int D, typename T> 
class FM_field_interface 
{ 

public : 

const FM_mesh<B, D>* const mesh; 
const FM_u32 node_association_index; 

FM_field_interface (const FM_mesh<B, D>* m, FM_u32 nai) : 
mesh(m) , node_association_index (nai) { ) 

virtual std: :ost reams str (std: : ostreamS o) const = 0; 

virtual int at_base (const FM_base<B>S b, FM_context*, T* val) const 
{ 

int res ; 

FM_ptr<FM_structured_B_cell<B> > sc; 
res = mesh->base_to_cell (b, Ssc) ; 
if (res ! = FM_0K) return res; 

T vals [ 1 « B] ; 

res = at_cell (sc, vals) ; 

if (res ! = FM_0K) return res; 

return FM_linear_interpolate (b, sc, vals, val); 


virtual int at_base (const FM_base<B, FM_u32>S b, T* val) const 
< 

FM_structured_0_cell<B> sc(b); 
return at_cell(Ssc, val); 


virtual int at_phys (const FM_phys<D>S, FM_context*, T*) const = 0; 

virtual int at _ce 11 (const FM_cell*, std: : vector<T>*) const = 0; 
virtual int at_cell (const FM_cell*, T*) const = 0; 

virtual int blanks_at_cell (const FM_cell* c, std : : vector<int>* blanks) const 
{ 

std : : vector<T> vals; 
int res = at_cell(c, svals); 
for (size_t i = 0; i < vals. sized; i++) 
blank s- >push_back (1) ; 
return res; 

) 

) ; 


void FM_throw_bad_cell_argument (const FM_shared_ob ject* so, 

const char* method, const FM_cell* c) 

< 

FM_ostringstream err; 

err « *so « ": :" « method « "(" « *c « ",...): bad cell argument type" 
throw std: : logic_error (err. str () ) ; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 



// Emacs mode -*-c++-*- // 

# i f n de f _FM_FUNC T I ONAL_H_ 

#de f in e _FM_FUNC T I ONAL_H_ 

/* 

* NAME: FM_f unctional . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude cfunctional> 
tinclude "FM_ostringstream.h” 
tinclude "FM_vector . h" 
tinclude "FM_shared_ob ject .h" 

// 

// from <functional> : 

// plus, minus, multiplies, divides, modulus, negate, 

// equal_to, not_equal_to, greater, less, great er equal, less_equal, 
// logical_and, logical_or, logical_not 
// 


template <typename T> 

class FM_negate_fun : public std: :unary_function<T, T> 

{ 

public : 

int operator () (const TS t, T* res) const 

{ 

*res = -t; 

return FM_OK; 

} 

} ! 


template <typename T> 

class FM_plus_fun : public std: : binary _function<T, T, T> 

{ 

public : 

int operator () (const TS lhs, const TS rhs, T* res) const 

{ 

*res = lhs + rhs; 
return FM_OK; 

) 

} ; 


template ctypename T> 

class FM_minus_fun : public std : : binary_function<T, T, T> 

{ 

public : 

int operator () (const TS lhs, const TS rhs, T* res) const 

{ 

*res = lhs - rhs; 
return FM_OK; 

} 

} ; 


template <typename T> 

class FM_multiplies_fun : public std: : binary_function<T, T, T> 

{ 

public : 

int operator () (const TS lhs, const TS rhs, T* res) const 

{ 

*res = lhs * rhs; 
return FM_OK; 

) 

} ; 

template <typename T> 

class FM_divides_fun : public std: :binary_function<T, T, T> 

{ 

public : 

int operator () (const TS lhs, const TS rhs, T* res) const 

{ 

*res = lhs / rhs; 
return FM_OK; 

) 

} I 


template <typename S, typename T> 

class FM_fun_ptr_fun : public std: : unary _function<S, T> 

{ 

public : 

FM_fun_ptr_fun (const FM_shared_ob ject* ctxt, 

int (*f) (const FM_shared_ob ject*, const SS, T*)) : 
fun_ctxt (ctxt) , fun(f) {] 

int operatorO (const SS s, T* t) const { return fun (fun_ctxt, s, t) ; } 
private : 

FM_ptr<FM_shared_ob ject> fun_ctxt ; 

int (*fun) (const FM_shared_object*, const SS, T* ) ; 

} 1 


template <typename T> 

class FM_abs_f un : public std: : unary_f unction <T, T> 

{ 

public : 

int operatorO (const TS t, T* res) const 

{ 

*res = t >= T (0) ? t : -t; 
return FM_OK; 



template <typename S, typename T> 

class FM_static_cast_f un : public std: : unary_function<S, T> 

{ 

public : 

int operatorO (const SS s, T* t) const 

{ 

*t = static_cast<T>(s) ; 
return FM_OK; 

} 

) ; 


template <typename T> 

class FM_min_fun : public std :: binary_f unction <T, T, T> 

< 

public : 

int operatorO (const TS lhs, const TS rhs, T* res) const 

{ 

*res = lhs < rhs ? lhs : rhs; 
return FM_OK; 



template ctypename T> 

class FM_max_fun : public std: : binary _f unction <T, T, T> 

{ 

public : 

int operatorO (const TS lhs, const TS rhs, T* res) const 

{ 

*res = lhs > rhs ? lhs : rhs; 
return FM_OK; 



template cint N, typename T> 

class FM_dot_fun : public std :: binary _function<FM_vector<N, T>, FM_vector<N, T>, T> 

< 

public : 

int operatorO (const FM_vector<N, T>S lhs, const FM_vector<N, T>S rhs, 

T* res) const 

< 

*res = FM_dot (lhs, rhs) ; 
return FM_OK; 



template ctypename T> 
class FM_cross_fun : 

public std: :binary_f unction CFM_vectorc 3, T>,FM_vectorc3, T>, FM_vectorc3, T> > 

< 

public : 

int operator () (const FM_vectorc3, T>S lhs, const FM_vectorc3, T>S rhs, 
FM_vectorc3, T>* res) const 

{ 

*res = FM_cross (lhs, rhs); 
return FM_OK; 



template cint N, typename T> 

class FM_mag_fun : public std : : unary_functioncFM_vectorCN, T>, T> 

{ 

public : 

int operatorO (const FM_vectorCN, T>S v, T* res) const 

{ 

*res = FM_mag (v) ; 
return FM_OK; 

} 

} ; 


template cint N, typename T> 

class FM_brackets_fun : public std: :unary_functionCFM_vectorCN, T>, T> 

< 

public : 

FM_brackets_fun (int i) : index (i) 

{ 

if ( ! (0 c= index SS index c N) ) { 

FM_ostringstream err; 

err cc "FM_brackets_f unc" cc N cc ”, T> : : FM_brackets_fun ( ” cc 
i cc ") : bad index”; 
throw std: : logic_error (err. str () ) ; 

} 

} 

int operatorO (const FM_vectorCN, T>S v, T* res) const 

{ 

*res = v [index] ; 
return FM_0K; 

) 

private : 

const int index; 

) ; 


template cint M, int N, typename T> 
class FM_slice_brackets_fun : 

public std: : unary_functionCFM_vectorCM, T>, FM_vectorCN, T> > 

{ 

public : 

FM_slice_brackets_fun (int i) : index (i) 

{ 

if 0 (0 C= index SS index 4 N c= M) ) { 

FM_ostringstream err; 

err cc ”FM_slice_brackets_funC” cc M cc ”, " cc N cc 


23 



", T> : : FM_slice_brackets_fun (" « i « "): bad index"; 
throw std : : logic_error (err . str ( ) ) ; 

} 

} 

int operator () (const FM_vector<M, T>& v, FM_vector<N, T>* res) const 

*res = FM_vector<N, T> (static_cast<const T*> (v) + index) ; 
return FM_OK; 


const int index; 

} 


template <typename T> 

class FM_swap_endian_fun : public std: : unary _function<T, T> 

{ 

public : 

int operator () (const TS t, T* res) const 

{ 

union { 

T t; 

char chars [8]; 

} u; 
char c; 
u.t = t; 

size_t sizeof_T = sizeof(T); 
switch (sizeof_T) { 
case 1: 
break; 
case 2: 

c = u . chars [0 ] ; 
u. chars [0] = u. chars [ 1] ; 
u. chars [1] = c; 
break; 
case 4: 

c = u . chars [0] ; 
u. chars [0] = u. chars [3]; 
u. chars [3] = c; 
c = u . chars [1 ] ; 
u. chars [1] = u. chars [2]; 
u. chars [2] = c; 
break; 
case 8: 

c = u . chars [0 ] ; 
u. chars [0] = u. chars [7]; 
u. chars [7] = c; 
c = u . chars [1] ; 
u. chars [1] = u. chars [6]; 
u. chars [6] = c; 
c = u . chars [2 ] ; 
u. chars [2] = u.chars[5]; 
u. chars [5] = c; 
c = u . chars [3] ; 
u. chars [3] = u. chars [4]; 
u. chars [4] = c; 
break; 
default : 
abort () ; 

) 

*res = u.t; 
return FM_0K; 

) 

} ; 


template <> 

class FM_swap_endian_fun<int> : public std: :unary_function<int, int> 

{ 

public : 

int operator () (const int& i, int* res) const 
*res = 

( (i & OxFF) « 24) | 

((i & OxFFOO) « 8) | 

( (i & OxFFOOOO) >> 8) | 

( (i & OxFFOOOOOO ) » 24); 
return FM_OK; 

) 


u.f = f; 

( (u. i & OxFF) « 24) | 

( (u. i & OxFFOO) « 8) | 

( (u. i S OxFFOOOO) » 8) | 

( (u. i 6 OxFFOOOOOO) » 24); 

*res = u.f; 
return FM_OK; 

J 

); 

template <typename T> 

class FM_identity_fun : public std: : unary_function<T, T> 

{ 

public : 

int operator () (const T6 t, T* res) const { *res = t; return FM_OK; ) 

) ; 


template <typename T> 

struct FM_f irst_greater_pred : public std: :binary_function<T, T, bool> 

{ 

bool operator () (const TS lhs, const TS rhs) const 

{ 

return lhs. first > rhs. first; 

} 

) ; 


// T (S ( ) ) 

template ctypename S, typename T> 
class FM_compose_fun : 

public std: :unary_function<typename S: : argument_type, typename T : : result_type> 

< 

public : 

FM_compose_fun (const SS s, const TS t) : first (s), second (t) {) 

typename T: : result_type operator () (const typename S : : argument_typeS a) const 

{ 

return second (first (a) ) ; 

) 

private: 

const S first; 
const T second; 

] ; 

I* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

fendif 


template <> 

class FM_swap_endian_fun<unsigned> : 

public std: : unary_function<unsigned, unsigned> 

{ 

public : 

int operator () (const unsignedS i, unsigned* res) const 

{ 


((i & OxFF) « 24) | 

( (i & OxFFOO) « 8) | 

((i & OxFFOOOO) » 8) | 

( (i & OxFFOOOOOO) » 24); 
return FM_OK; 

} 

} ; 


template <> 

class FM_swap_endian_f un< float > : public std: : unary_function<f loat, float > 

{ 

public : 

int operator () (const floats f, float* res) const 

< 

union { 
float fl- 
int i; 


24 



// Emacs mode -*-c++-*- // 

#ifndef _FM_INTERPOLATE_H_ 

#def ine _FM_INTERPOLATE_H_ 

/* 

* NAME: FM_interpolate . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude <vector> 
tinclude "FM_vector . h" 
tinclude "FM_cell . h" 
tinclude "FM_returns .h" 


template <int B, typename T> 

int FM_linear_interpo late (const FM_vector<B, FM_coord>S f, 
T vals [ ] , T* val) 

{ 

for (int i = B - 1; i >= 0; i — ) { 
if (f [ i ] == FM_coord(0)) continue; 
int n = FM_pow_2 (i) ; 
for (int j = 0; j < n; j++) 

vals[i] += f[i] * (vals[i + n] - vals[i]); 

} 

*val = vals [0] ; 
return FM_0K; 


template <int B, typename T> 
int 

FM_linear_interpolate (const FM_base<B>& b, 

const FM_pt r<FM_st ructured_B_cell<B> >& sc, 
T vals [] , T* val) 

{ 

FM_vector<B, FM_coord> f; 
for (int i = 0; i < B; i++) 

f[i] = b[i] - FM_coord (sc->get_index (i) ) ; 
return FM_linear_interpolate (f , vals, val); 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the ''Software'') , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

tendif 


// Emacs mode — *— C++— *— // 
tifndef _FM_IO_H_ 
t define _FM_IO_H_ 

/* 

* NAME: FM io.h 


* WRITTEN BY: 

* Patrick Moran 


*/ 

finclude 
finclude 
finclude 
finclude 
finclude 
* include 
finclude 
* include 
finclude 
f include 


<vector> 

<string> 

<unistd . h> 

<fcntl. h> 

<assert . h> 
<sys/stat .h> 

<sys / types . h> 
<stdio . h> 
"FM_vector . h" 
"FM_functional. h" 


pmoran@nas . nasa . gov 


inline bool FM_little_endian_hardware () 

{ 

unsigned ui = 1; 

return static_cast<char*> (static_cast<void*> (Sui) ) [0] == 1 ? true : false; 


size_t FM_file_size (const std: : strings file_name) 

{ 

struct stat sbuf; 

int stat_res = stat (f ile_name. c_str () , Ssbuf ) ; 
return stat_res == 0 ? sbuf.st_size : 0; 


template <typename T> 

int FM_f read (FILE* fp, T* dat, size_t n_items, bool swap_endian) 

{ 

size_t fread_res = fread(dat, sizeof (T) , n_items, fp) ; 
if (fread_res != n_items) 
return FM_I 0_ERR0R ; 
if (swap_endian) { 

FM_swap_endian_fun<T> swap_endian_f un; 
for (size_t i = 0; i < fread_res; i++) { 

(void) swap_endian_fun (dat [i] , Sdat [i] ) ; 

) 


return FM_OK; 

) 


template ctypename T> 

int FM_f read (FILE* fp, T* dat, size_t n_items, bool swap_endian, bool fortran, 
std : : vector<int>* extra = 0) 

int res ; 

FM_u32 n_bytes_f ortran; 

size_t n_bytes_expected = n_items * sizeof (T); 
size_t start = ftell(fp); 
if (fortran) { 

res = FM_fread(fp, Sn_bytes_fortran, 1, swap_endian) ; 
if (res != FM_OK) return res; 
if (n_bytes_fortran < n_bytes_expected) 
return FM_IO_ERROR; 

) 

res = FM_fread(fp, dat, n_items, swap_endian) ; 
if (res != FM_OK) return res; 

if (fortran) { 

if (extra SS n_bytes_fortran > n_bytes_expected) ( 

size_t n_extra = (n_bytes_fortran - n_bytes_expected) / sizeof (T) ; 
extra->resize (n_extra) ; 

res = FM_fread(fp, S (*extra) [0] , n_extra, swap_endian) ; 
if (res != FM_OK) return res; 

} 

(void) fseek(fp, start + n_bytes_fortran + 2 * sizeof (FM_u32) , SEEK_SET) ; 

} 

return FM_OK; 

} 


template <typename F> 

int FM_fread_fun (FILE* fp, typename F: : result_type* dat, size_t n_items, 
bool swap_endian, bool fortran, const FS fun) 

{ 

typedef typename F: : argument_type argument_type; 
typedef typename F : : result_type result_type; 

FM_u32 n_bytes_f ortran; 
size_t start = ftell(fp); 
if (fortran) { 

FM_fread(fp, Sn_bytes_f ortran, 1, swap_endian) ; 
size_t n_bytes_expected = n_items * sizeof (argument_type) ; 
if (n_bytes_f ortran < n_bytes_expected) 
return FM_IO_ERROR; 

} 


if (sizeof (argument_type) == sizeof (result_type) ) { 
int res = FM_fread(fp, dat, n_items, swap_endian) ; 
if (res ! = FM_OK) 

for (size_t i = 0; i < n_items; i++) { 

res = f un (reinterpret_cast<argument_type*> (dat ) [i], &dat[i]); 
if (res ! = FM_OK) 

} 


25 



FM_OK) 


std: : vector<argument_type> tmp (n_items) ; 
int res = FM_f read (fp, & tmp [ 0 ] , n_items, swap_endian) ; 
if (res ! = FM_OK ) 
return res; 

for (size_t i = 0; i < n_items; i++) { 
res = fun (tmp [i] , &dat[i]); 
if (res ! = FM_0K) 
return res; 

} 


if (fortran) 

(void) fseek(fp, start + n_bytes_fortran 4 2* sizeof (FM_u32) , SEEK_SET) ; 
return FM_0K; 


template <int N, typename T> 

int FM_f read_transpose (FILE* fps[], FM_vector<N, T>* dat, 

size_t n_items, bool swap_endian, bool fortran) 

{ 

size_t start = ftell (fps [ 0] ) ; 
size_t n_bytes_fortran; 
if (fortran) { 

FM_f read (fps [0] , &n_bytes_fortran, 1, swap_endian) ; 
if (n_bytes_fortran < N * sizeof (T) * n_items) 
return FM_I 0_ERR0R ; 

} 


size_t i, j; 

std: :vector<T> components [N] ; 

T* bps [N] ; 

const FM_u32 N_DAT = 1024; 
for (i = 0; i < N; i+4) ( 

components [i] . resize (N_DAT) ; 

size_t offset = start 4 i * sizeof (T) * n_items; 
if (fortran) offset 4= sizeof (FM_u32) ; 

(void) fseek (fps [i] , offset, SEEK_SET) ; 


size_t n_remaining = n_items; 

T* dst = reinterpret_cast<T*> (dat) ; 
while (n_remaining >0) { 

size_t n_to_read = (n_remaining > N_DAT) ? N_DAT : n_remaining; 
for (i = 0; i < N; i44) { 

int res = FM_f read (fps [i] , Scomponents [i] [0] , n_to_read, swap_endian) ; 
if (res ! = FM_0K) 
return res; 

bps[i] = Scomponents [i] [ 0] ; 

) 

for (i = 0; i < n_to_read; i44) 
for (j = 0; j < N; j44) 

*dst44 = *bps [ j ] 44; 
n_remaining -= n_to_read; 


if (fortran) 

(void) fseek (fps [0 ] , start 4 n_bytes_fortran 4 2 * sizeof (FM_u32) , 
SEEK_SET) ; 

else 

(void) fseek (fps [0 ] , ftell (fps [N - 1] ) , SEEK_SET) ; 
return FM_0K; 


template <int N, typename F> 

int FM_f read_transpose_fun (FILE* fps[], 

FM_vector<N, typename F : : result_type>* dat, 
size_t n_items, bool swap_endian, bool fortran, 
const FS fun) 

< 

typedef typename F: : argument_type argument_type; 
typedef typename F : : result_type result_type; 

size_t start = ftell (fps [0] ) ; 
size_t n_bytes_fortran; 
if (fortran) { 

FM_f read (fps [0] , Sn_bytes_fortran, 1, swap_endian) ; 
if (n_bytes_fortran < N * sizeof (argument_type) * n_items) 
return FM_1 0_ERR0R ; 

) 

FM_u32 i, j; 

std: : vector<argument_type> components [N] ; 
argument_type* bps[N]; 
const FM_u32 N_DAT = 1024; 
for (i = 0; i < N; i44) { 

components [i] . reserve (N_DAT) ; 

size_t offset = start 4 i * sizeof (argument_type) * n_items; 
if (fortran) offset 4= sizeof (FM_u32) ; 

(void) fseek (fps [i] , offset, SEEK_SET) ; 

} 


size_t n_remaining = n_items; 

result_type* dst = reinterpret_cast<result_type*> (dat) ; 
int res; 

while (n_remaining >0) { 

size_t n_to_read = (n_remaining > N_DAT) ? N_DAT : n_remaining; 
for (i = 0; i < N; i44) { 

res = FM_f read (fps [i] , Scomponents [ i] [ 0] , n_to_read, swap_endian) ; 
if (res ! = FM_OK) 
return res; 

bps [i] = Scomponents [i] [0 ] ; 

} 

for (i = 0; i < n_to_read; i44) 
for (j = 0; j < N; j44) { 

res = fun (*bps [ j]44, dst 44); 


if (res 1 

) 

n_remaining - 

) 




if (fortran) 

(void) fseek (fps [0] , start 4 n_bytes_fortran 4 2 * sizeof (FM_u 32) , 
SEEK_SET) ; 

(void) fseek (fps [0] , ftell(fps[N - 1]), SEEK_SET) ; 
return FM_OK; 


int FM_f skip (FILE* fp, size_t size, size_t n_items, 
bool swap_endian, bool fortran) 

{ 

FM_u32 n_bytes_fortran; 
size_t start = ftell(fp); 
if (fortran) { 

int res = FM_fread(fp, Sn_bytes_fortran, 1, swap_endian) ; 
if (res ! = FM_OK) 
return res; 

size_t n_bytes_expected = n_items * size; 
if (n_bytes_fortran < n_bytes_expected) 
return FM_IO_ERROR; 

(void) fseek (fp, start 4 n_bytes_fortran 4 2 * sizeof (FM_u32) , SEEK_SET) ; 

} 

else ( 

(void) fseek (fp, start 4 size * n_items, SEEK_SET) ; 

} 

return FM_OK; 


template ctypename T> 

int FM_fwrite (FILE* fp, const T* dat, size_t n_items, bool swap_endian) 

size_t fwrite_res; 
if ( ! swap_endian) ( 

fwrite_res = fwrite(dat, sizeof (T) , n_items, fp) ; 

) 

else { 

std : : vector<T> tmp (n_items ) ; 

FM_swap_endian_fun<T> swap_endian_f un; 
for (FM_u32 i = 0; i < n_items; i44) 

(void) swap_endian_fun (dat [i] , Stmp [ i] ) ; 
fwrite_res = fwrite(tmp, sizeof (T) , n_items, fp) ; 

} 

return fwrite_res == n_items ? FM_0K : FM_I0_ERR0R; 


template Ctypename T> 

size_t FM_fwrite (FILE* fp, const T* dat, size_t n_items, 
bool swap_endian, bool fortran) 

< 

int res ; 

FM_u32 n_bytes_fortran = sizeof (T) * n_items; 
if (fortran) { 

res = FM_fwrite (fp, &n_bytes_fortran, sizeof (FM_u32) , 1, swap_endian) ; 
if (res != FM_0K) return res; 

) 

res = FM_fwrite (fp, dat, n_items, swap_endian) ; 
if (res ! = FM_OK) 
return res; 
if (fortran) ( 

res = FM_fwrite (fp, &n_bytes_fortran, sizeof (FM_u32) , 1, swap_endian) ; 
if (res != FM_OK) return res; 

) 

return FM_OK; 


template cint N, typename T> 

int FM_fwrite_transpose(FILE* fp, const FM_vector<N, T>* dat, 

FM_u32 n_items, bool swap_endian, bool fortran) 

{ 

int res ; 

FM_u32 n_bytes_fortran = n_items * N * sizeof (T); 
if (fortran) { 

res = FM_write(fp, &n_bytes_fortran, 1, swap_endian) ; 
if (res != FM_OK) return res; 

} 

for (FM_u32 i = 0; i < N; i44) { 

for (FM_u32 j = 0; j < n_items; j+4) ( 

res = FM_fwrite (fp, &dat[j][i], 1, swap_endian) ; 
if (res ! = FM_OK) return res; 

} 


if (fortran) { 

res = FM_write(fp, Sn_bytes_f ortran , 1, swap_endian) ; 
if (res ! = FM_OK) return res; 

} 

return FM_OK; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 


26 



* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_IRREGULAR_INTERVAL_H_ 

♦define _FM_I RREGULAR_INTERVAL_H_ 

/* 

* NAME: FM_irregular_interval . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include "FM_structured_mesh . h" 


class FM_irregular_interval : public FM_structured_mesh<l, 1> 

{ 

public : 

const FM_coord* const coordinates; 
const bool delete_supression; 

FM_irregular_interval(FM_u32 d, const FM_coord* c, 
bool ds = false, 

FM_properties cache* pc = 0) : 
FM_structured_mesh<l, l>(d, pc) , coordinates (c) , 
delete_supression (ds ) 

{ 

for (FM_u32 i = 0; i < d - 1; i++) { 
if ( ! (c [i] < c [i + 1] ) ) { 

FM_ostringstream err; 

err « "FM_irregular_interval: :FM_irregular_interval 
err « "coordinates must be strictly ascending"; 
throw std: : logic_error (err . str () ) ; 



} 


virtual ' - FM_irregular_interval () 

{ 

if ( ! delete_supression) 
delete [] coordinates; 

} 


virtual std: :ost reams str (std: : ostreamS o) const 

{ 

return o « "FM_irregular_interval"; 

) 


virtual int 

at_cell (const FM_cell* c, std : : vector<FM_vector<l, FM_coord> >* vals) const 

{ 

FM_u32 n_indices; 

FM_u64 indices [2]; 

c->structured_mesh_vertex_indices (this, Sn_indices, indices); 
for (FM_u32 i = 0; i < n_indices; i++) 

vals->push_back (coordinates [indices [ i] ] ) ; 
return FM_0K; 


virtual int 

at_cell (const FM_cell* c, FM_vector<l , FM_coord>* vals) const 

{ 

FM_u32 n_indices; 

FM_u64 indices [2]; 

c->structured_mesh_vertex_indices (this, Sn_indices, indices); 
for (FM_u32 i = 0; i < n_indices; i++) 
vals[i] = coordinates [indices [ i] ] ; 
return FM_OK; 


virtual int 

phys_to_base (const FM_phys<l>S p, FM_context*, FM_base<l>* b, 
FM_ptr<FM_structured_B_cell<l> >* sc = 0) const 

< 

if (p [ 0 ] < coordinates [0] || p[0] > coordinates [dimensions [0 ] - 1]) 
return FM_OUT_OF_BOUNDS; 

FM_u32 lo =0, hi = dimensions [ 0] - 1; 
while (hi - lo > 1) { 

// assert (coordinates [ lo] <= p[0] && p[0] <= coordinates [hi] 
int mid = (lo + hi) / 2; 
if (p [ 0 ] >= coordinates [mid] ) 
lo = mid; 
else 

hi = mid; 

) 

FM_u32 index = (lo < dimensions [0] - 1) ? lo : lo - 1; 

(*b) [0] = FM_coord (index) + 

(p[0] - coordinates [index] ) / 

(coordinates [index + 1] - coordinates [index] ) ; 
int res = FM_OK; 
if (sc) 

*sc = new FM_structured_B_cell<l> (index) ; 
return res; 


virtual std : : pair<FM_vector<l , FM_coord>, FM_vector<l , FM_coord> > 
get_bounding_box (const FM_time<FM_u32>* = 0, const FM_submesh_id* = 0) const 
{ 

return std: :pair<FM_vector<l, FM_coord>, FM_vector<l, FM_coord> > 

(coordinates [0] , coordinates [dimensions [ 0] - 1]); 

} 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 


27 



* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_I TER_H_ 

♦define _FM_I TER_H_ 

/* 

* NAME: FM_iter . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include "FM_shared_ob ject . h” 

♦include "FM_cell . h" 


enum FM_iter_attr_enum 

< 

FM_ITER_ATTR_CELL_DIMENSI ON , 

FM_I T ER_ATT R_C EL L_T Y PE , 

FM_ITER_ATTR_T IME , 

FM_ITER_ATTR_SUBME SH_I D , 
FM_ITER_ATTR_AXI S_BEGIN, 
FM_ITER_ATTR_AXI S_END, 
FM_ITER_ATTR_AXI S_STRIDE , 
FM_ITER_ATTR_SIMPLICIAL_DECOMPOSITION 

} ; 


class FM_iter_attr : public FM_shared_ob ject 

{ 

public : 

const FM_iter_attr_enum attr; 

FM_iter_attr (FM_iter_attr_enum a) : attr (a) {) 
virtual '•FM_iter_attr() {} 

) ; 


typedef std : : vector<FM_ptr<FM_iter_attr> > FM_iter_attrs; 

std: :ost reams operator« (std: : ostreamS o, const FM_iter_attrsS ia) 

{ 

o « "["; 

for (FM_u32 i = 0; i < ia.sizeO; i++) { 
if (i > 0) 
o « ", "; 
o « *ia [i] ; 

} 

return o « "] "; 


class FM_cell_dimension_iter_attr : public FM_iter_attr 

< 

public : 

const FM_u32 cell_dimension; 

FM_cell_dimension_iter_attr (FM_u32 cd) : 

FM_iter_attr (FM_ITER_ATTR_CELL_DIMENSION) , cell_dimension (cd) { ) 
virtual std :: ostreams str (std :: ostreams o) const 
{ 

return o « "FM_cell_dimension_iter_attr (" « cell_dimension « ") " 

) 


class FM_cell_type_iter_attr : public FM_iter_attr 

< 

public : 

const FM_cell_type_enum cell_type; 

FM_cell_type_iter_attr (FM_cell_type_enum ct) : 

FM_iter_attr (FM_ITER_ATTR_CELL_TYPE) , cell_type (ct ) {) 
virtual std :: ostreams str (std :: ostreams o) const 
{ 

return o « "FM_cell_type_iter_attr (" « cell_type « ") "; 

} 


class FM_time_iter_attr : public FM_iter_attr 

{ 

public : 

const FM_time<FM_u32> time; 

FM_time_iter_attr (const FM_time<FM_u32>S t) 
FM_iter_attr (FM_ITER_ATTR_TIME) , t ime (t ) { ) 
virtual std :: ostreams str (std :: ostreams o) const 
{ 

return o « "FM_time_iter_attr (" « time « ") "; 

} 


class FM_submesh_id_iter_attr : public FM_iter_attr 

{ 

public : 

const FM_submesh_id submesh_id; 

FM_submesh_id_iter_attr (const FM_submesh_idS sid) : 

FM_iter_attr (FM_ITER_ATTR_SUBMESH_ID) , submesh_id (sid) {} 
virtual std :: ostreams str (std :: ostreams o) const 
{ 

return o << "FM_submesh_id_iter_attr (" « submesh_id « ") "; 

} 


class FM_axis_begin_iter_attr : public FM_iter_attr 

{ 

public : 

const FM_u32 axis, index; 

FM_axis_begin_iter_attr (FM_u32 a, FM_u32 i) : 

FM_iter_attr (FM_ITER_ATTR_AXIS_BEGIN) , axis (a) , index (i) { ) 
virtual std :: ostreams str (std :: ostreams o) const 
{ 

return o « "FM_axis_begin_iter_attr (" « axis << ", " << index << 

) 


class FM_axis_end_iter_attr : public FM_iter_attr 


28 



public : 

const FM_u32 axis, index; 

FM_axis_end_iter_attr (FM_u32 a, FM_u32 i) : 

FM_iter_attr (FM_ITER_ATTR_AXIS_END) , axis (a), index (i) {} 
virtual std : : ostreamS str (std: :ost reams o) const 
{ 

return o « "FM_axis_end_iter_attr ( " « axis « ", " « index « ")"; 

} 


class FM_axis_stride_iter_attr : public FM_iter_attr 

{ 

public : 

const FM_u32 axis, stride; 

FM_axis_stride_iter_attr (FM_u32 a, FM_u32 s) : 

FM_iter_attr (FM_ITER_ATTR_AXIS_STRIDE) , axis (a), stride (s) {} 
virtual std: : ostreamS str (std: : ostreamS o) const 
{ 

return o « "FM_axis_stride_iter_attr (” « axis « ", " « stride « ")"; 

} 


* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

fendif 


class FM_simplicial_decomposition_iter_attr : public FM_iter_attr 

{ 

public : 

const FM_u32 simplicial_decomposition; 
FM_simplicial_decomposition_iter_attr (FM_u32 sd) : 

FM_iter_attr (FM_ITER_ATTR_SIMPLICIAL_DECOMPOSITION) , 
simplicial_decomposition (sd) {) 
virtual std: : ostreamS str (std: : ostreamS o) const 
{ 

return o « "FM_simplicial_decomposition_iter_attr (” « 
simplicial_decomposition « ”)”; 

} 


class FM_iter_impl 

{ 

public : 

vi rt ua 1 ~ FM_it er_imp 1 ( ) { ) 
virtual FM_iter_impl* copy() const = 0; 
virtual const FM_cell* advance () = 0; 
virtual const FM_cell* dereference () const = 0; 

virtual std: : ostreamS str (std: : ostreamS o) const 

{ 

return o « "FM_iter_impl"; 

) 

} ; 


class FM_iter 

{ 

public : 

FM_iter() impl(0), cell(0) {} 

FM_iter (FM_iter_impl* i) : impl (i) , cell (impl->dereference () ) {) 
FM_iter (const FM_iterS iter) 

impl (iter . impl->copy ()) , cell (impl->dereference () ) {} 

FM_iterS operator= (const FM_iterS rhs) 

{ 

impl = rhs . impl->copy ( ) ; 
cell = impl->dereference ( ) ; 
return *this; 

) 

~FM_iter () 

{ 

if (impl) delete impl; 

) 

inline const FM_cell* operator4+() 

< 

return cell = impl->advance () ; 

) 

void operator++ (int) { (void) operator++ () ; ) 

inline const FM_cell* operator* () const { return cell; ) 

inline bool done() const { return cell == 0; ) 

friend bool operator== (const FM_iterS lhs, const FM_iterS rhs) 

< 

if (lhs. cell == 0 | | rhs. cell == 0) 
return lhs. cell == rhs. cell; 
else 

return *lhs.cell == *rhs.cell; 

} 

friend bool operator != (const FM_iterS lhs, const FM_iterS rhs) 

{ 

return ! (lhs == rhs) ; 

} 

FM_i t e r_imp 1 * imp 1 ; 
const FM_cell* cell; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction. 


29 



// Emacs mode -*-c++-*- // 

#ifndef _FM_MATRIX_H_ 

#def ine _FM_MATRIX_H_ 

/* 

* NAME: FMjnatrix.h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude "FM_vector . h" 


for (int p = 0; p < P; p++) { 
sum = (T) 0; 

for (int n = 0; n < N; n++) { 
sum += lhs [m] [n] * rhs[n][p]; 

} 

tmp [m] [p] = sum; 

} 

) 

return FM_vector<M, FM_vector<P, T> >{tmp); 


template <int M, int N, typename T> 

FM_vector<N, T> 

operator* (const FM_vector<M, T>& lhs, 

const FM_vector<M, FM_vector<N, T> >& rhs) 

T tmp [N] , sum; 

for (int n = 0; n < N; n++) { 
sum = (T) 0; 

for (int m = 0; m < M; m++) { 
sum += lhs[m] * rhs [m] [n] ; 

} 

tmp[n] = sum; 


template <int M, int N, typename T> 

FM_vector<N, EM_ve ct o r <M , T> > 

FM_transpose (const FM_vector<M, FM_vector<N, T> >& in) 

{ 

FM_vector<M, T> tmp[N]; 
for (int m = 0; m < M; m++) { 
for (int n = 0; n < N; n++) { 
tmp [n] [m] = in [m] [n] ; 

) 

} 

return FM_vector<N, FM_vector<M, T> >(tmp); 


return FM_vector<N, T> (tmp) ; 


template <typename T> 

FM_vector<3, T> 

operator* (const FM_vector<3, T>& lhs, 

const FM_vector<3, FM_vector<3, T> : 


{ 


return FM_vector<3, T> (lhs [0] * rhs[0][0] + 
lhs [ 1] * rhs [1] [0] + 
lhs [2] * rhs [2] [0] , 
lhs [ 0] * rhs [ 0] [1] + 
lhs [ 1] * rhs [1] [1] + 
lhs [2] * rhs [2] [1] , 
lhs [ 0] * rhs [ 0] [2] + 
lhs [ 1] * rhs [ 1] [2] + 
lhs [2] * rhs [2] [2] ) ; 


) 


template <typename T> 

FM_vector<4, T> 

operator* (const FM_vector<4, T>& lhs, 

const FM_vector<4, FM_vector<4, T> : 

{ 


template <typename T> 

FM_vector<3, IW_vector<3, T> > 

FM_transpose (const FM_vector<3, FM_vector<3, T> >& in) 

{ 

return FM_vector<3, FM_vector<3, T> > 

(FM_vector<3, T> (in [0] [0] , in[l][0], in[2][0]), 
FM_vector<3, T> (in [0 ] [1], in[l][l], in[2][l]), 
FM_vector<3, T> (in [0] [2] , in[l][2], in [2] [2])); 


template <int N, typename T> 

T FM_det (const FM_vector<N, FM_vector<N, T> >&) ; 
template <int N, typename T> 

T FM_minor (const FM_vector<N, FM_vector<N, T> >£ in, int row, int col) 
< 

FM_vector<N-l, FM_vector<N-l,T> > tmp; 
int dst_row, dst_col; 
dst_row = 0; 

for (int src_row = 0; src_row < N; src_row++) { 
if (src_row == row) continue; 
dst_col = 0; 

for (int src_col = 0; src_col < N; src_col++) { 


return FM_vector<4 , T> (lhs 

:o] 

* 

rhs [0] [0] 

4 

if (src_col == col) continue; 

lhs 

[1] 

* 

rhs [ 1] [0] 

4 

tmp [dst_row] [dst_col] = in [ src_row] [src_col] 

lhs 

[2] 

* 

rhs [2] [0] 

4 

dst COl44; 

lhs 

[3] 

* 

rhs [ 3] [0], 


} 

lhs 

!0] 

* 

rhs [ 0] [1] 

4 

dst rOW44 ; 

lhs 

[1] 

* 

rhs [ 1] [1] 

4 

} 

lhs 

i 2] 

* 

rhs [2] [1] 

4 

return FM det (tmp) ; 

lhs 

[3] 

* 

rhs [ 3] [1], 


) 

lhs 

!0] 

* 

rhs [ 0] [2] 

4 


lhs 

[1] 

* 

rhs [ 1] [2] 

4 

template <int N, typename T> 

lhs 

i 2] 

* 

rhs [2] [2] 

4 

T FM det (const FM vector<N, FM vector<N, T> >& in) 

lhs 

[3] 

* 

rhs [ 3] [2], 


{ 

lhs 

[0] 

* 

rhs [0] [3] 

4 

T sum = (T) 0; 

lhs 

[1] 

* 

rhs [1] [3] 

4 

for (int n = 0; n < N; n44) { 

lhs 

[2] 

* 

rhs [2] [3] 

4 

T minor = FM minor (in, n, 0) ; 

lhs 

[3] 

* 

rhs [ 3] [3]) 

; 

T cofactor = (n 6 1) ? -minor : minor; 


sum += in[n][0] * cofactor; 


template <int M, int N, typename T> 

FM_vector<M, T> 

operator* (const FM_vector<M, FM_vector<N, T> >& lhs, 
const FM_vector<N, T>& rhs) 

{ 

T tmp [M] ; 

for (int m = 0; m < M; m44) { 

tmp [m] = FM_dot (lhs [m] , rhs) ; 

) 

return FM_vector<M, T> (tmp) ; 

) 

template <typename T> 

FM_vector<3, T> 

operator* (const FM_vector<3, FM_vector<3, T> >£ lhs, 
const FM_vector<3, T>& rhs) 

{ 


return FM vector<3,T> 


(FM_dot (lhs [0] , rhs), 
FM_dot (lhs [1] , rhs), 
FM_dot (lhs [2] , rhs) ) ; 


} 


template ctypename T> 

FM_vector<4, T> 

operator* (const FM_vector<4, FM_vector<4, T> >£ lhs 
const FM_vector<4, T>£ rhs) 

{ 

return FM_vector<4 , T> (FM_dot (lhs [ 0] , rhs), 
FM_dot (lhs [1] , rhs) , 
FM_dot (lhs [2] , rhs) , 
FM_dot (lhs [3] , rhs) ) ; 


return sum; 


template <typename T> 

T FM det (const FM vector<l,FM vector<l,T> >& in) 


return in [0 ] [ 0] ; 


template <typename T> 

T FM det (const FM vector<2,FM vector<2,T> >& in) 


return in [ 0 ] [ 0] * in [ 1 ] [1 ] - in [ 1 ] [ 0] * in [ 0 ] [ 1 ] ; 


} 


template <typename T> 

T FM_det (const FM_vector<3, FM_vector<3, T> >& in) 

{ 

return 

in [0] [0] * ( in [ 1 ] [ 1 ] * in[2][2] - in[2][l] * 

in [ 1 ] [ 0 ] * (in [0] [1 ] * in[2][2] - in[2][l] * 

in [2] [0] * (in [0] [1 ] * in[l][2] - in[l][l] * 

} 


template <typename T> 

T FM_det (const FM_vector<4, FM 

{ 

// columi 
T rOrl = 

T r0r2 = 

T r0r3 = 

T rlr2 = 

T rlr3 = 

T r2r3 = 


ector<4, T> >& 


in [ 1] [2]) 
in [ 0] [2]) 
in [ 0] [2]) 


2,3 
[0] [2] 

* i 

i[l] [3] - i 

i[l] [2] 

* ir 

[0] 

[3] 

[0] [2] 

* i 

i[2] [3] - i 

[2] [2] 

* ir 

[0] 

[3] 

[0] [2] 

* i 

[ 3] [3] - i 

[3] [2] 

* ir 

[0] 

[3] 

[1] [2] 

* i 

i[2] [3] - i 

[2] [2] 

* ir 

[1] 

[3] 

[1] [2] 

* i 

[ 3] [3] - i 

[3] [2] 

* ir 

[1] 

[3] 

[2] [2] 

* i 

[ 3] [3] - i 

[3] [2] 

* ir 

[2] 

[3] 


template <int M, int N, int P, typename T> 


FM_vector<P, T> tmp [M] ; 
T sum; 

for (int m = 0; m < M; 


// ■ 


FM vector<M, FM vector<P,T> > 


T minorO = i 

Ln [ 1] [1] 

* r2r3 - 

Ln [2] [1] 

* rlr3 

4 i 

n [ 3] 

[1] 

* rlr2 

operator* (const FM vector<M, FM vector<N, T> >& 

lhs, 

T minorl = i 

L n[0] [1] 

* r2r3 - 

Ln [2] [1] 

* r0r3 

4 i 

n [ 3] 

[1] 

* r0r2 

const FM vector<N, FM vector<P,T> >& 

rhs) 

T minor2 = i 

L n[0] [1] 

* rlr3 - 

Ln [ 1 ] [1] 

* r0r3 

4 i 

n [ 3] 

[1] 

* rOrl 

{ 


T minor3 = i 

Ln [ 0] [1] 

* rlr2 - 

Ln [ 1 ] [1] 

* r0r2 

+ i 

n [2] 

[1] 

* rOrl 


in [0] [0] 


30 



in [2] [0] * minor2 - 

(*out) [0] [0] = in 

det * minorO; 





in [3] [0] * minor 3; 

(*out) [0] [1] = in 

det * -minorl; 





) 

(*out) [0] [2] = in 

det * minor2; 






(*out) [0] [3] = in 

det * -minor 3; 





template <int N, typename T> 

// column 1 






FM vector<N, FM vector<N, T> > 

minorO = in[l][0] 

* r2r3 - in[2] [0] * 

rlr3 + 

in [3] 

0] 

* 

FM adj (const FM vector<N, FM vector<N,T> >& in) 

minorl = in[0][0] 

* r2r3 - in[2] [0] * 

r0r3 + 

in [3] 

0] 

* 

{ 

minor 2 = in[0][0] 

* rlr3 - in [1] [0] * 

r0r3 + 

in [3] 

0] 

* 

FM vector<N, FM vector<N, T> > res; 

minor 3 = in[0][0] 

* rlr2 - in [1] [0] * 

r0r2 + 

in [2] 

0] 

* 

for (int row = 0; row < N; row++) { 







for (int col = 0; col < N; col++) { 

(*out) [1] [0] = in 

det * -minorO; 





T minor = FM minor (in, row, col); 

( * out ) [1] [1] = in 

det * minorl; 





T cofactor = ( (row + col) & 1) ? -minor : minor; 

(*out) [1] [2] = in 

det * -minor 2; 





res [col] [row] = cofactor; // transpose 

(*out) [1] [3] = in 

det * minor3; 





} 

// columns 0,1 






return res; 

rOrl = in [0] [0] * 

in[l] [1] - in [1] [0] 

* in [0] 

[1] ; 



} 

r0r2 = in [0] [0] * 

in [2] [1] - in [2] [0] 

* in [0] 

[1] ; 




r0r3 = in [0] [0] * 

in [3] [1] - in [3] [0] 

* in [0] 

[1] ; 




rlr2 = in [1] [0] * 

in [2] [1] - in [2] [0] 

* in [1] 

[1] ; 



template <int N, typename T> 

rlr3 = in [1] [0] * 

in [3] [1] - in [3] [0] 

* in [1] 

[l] / 



int FM_inv (const FM_vector<N, FM_vector<N, T> >& in. 

r2r3 = in[2] [0] * 

in [3] [1] - in [3] [0] 

* in [2] 

[1] / 



FM vector<N, FM vector<N, T> >* out) 

{ 

// column 2 






T det = FM_det (in) ; 

minorO = in[l][3] 

* r2r3 - in[2] [3] * 

rlr3 + 

in [3] 

3] 

* 

if (det == (T) 0) 

minorl = in[0][3] 

* r2r3 - in[2] [3] * 

r0r3 + 

in [3] 

3] 

* 

return 1; 

minor2 = in[0][3] 

* rlr3 - in [1] [3] * 

r0r3 + 

in [3] 

3] 

* 

*out = (T) 1 / det * FM_adj (in) ; 

minor3 = in[0][3] 

* rlr2 - in [1] [3] * 

r0r2 + 

in [2] 

3] 

* 


rOrl 

rOrl 


rlr2 

r0r2 

rOrl 

rOrl 


template <typename T> 

int FM_inv (const FM_vector<2, FM_vector<2, T> >& 
FM_vector<2, FM_vector<2, T> >* out) 

{ 

T det = FM_det (in) ; 
if (det == (T) 0) 
return 1; 

T inv_det = (T) 1 / det; 

(*out) [0] [0] = inv_det * in[l][l]; 

(*out) [0] [1] = inv_det * -in[0] [1]; 

(*out) [1] [0] = inv_det * -in[l] [ 0 ] ; 

(*out) [1] [1] = inv_det * in[0][0]; 
return 0; 


template <typename T> 

int FM_inv (const FM_vector<3, FM_vector<3, T> >& 
FM_vector<3, FM_vector<3, T> >* out) 


// column 0 
T minorO = in[l] [1] 

T minorl = in[0] [1] 

T minor2 = in[0] [1] 

T det = 

in[0][0] * minorO - 
in[l] [0] * minorl + 
in [2 ] [ 0] * minor 2; 


if (det == (T) 0) 
return 1; 

T inv_det = (T) 1 / det; 


in [2] [2] 
in [2] [2] 
in[l] [2] 


in [2] [1] 
in [2] [1] 
in [1 ] [1] 


in [1] [2]; 
in [0] [2]; 
in[0] [2] ; 


template <typename T> 

int FM_inv (const FM_vector<4, FM_vector<4, T> >& 
FM vector<4,FM vector<4,T> >* out) 


// compute minors column by column, 
//by row to effectively transpose 


// columns 2, 3 


but fill in (*out) row 


(*out) [2] [0] = inv_det * minorO; 
(*out) [2] [1] = inv_det * -minorl; 
(*out) [2] [2] = inv_det * minor2; 
(*out) [2] [3] = inv_det * -minor3; 


// column 3 
minorO = in[l][2] 
minorl = in [0] [2] 
minor 2 = in[0][2] 
minor3 = in [ 0 ] [ 2 ] 


r2r3 - in[2] [2] 
r2r3 - in[2] [2] 
rlr3 - in [ 1] [2] 
rlr2 - in [ 1] [2] 


rlr3 + in [ 3] [2] 
r0r3 + in [ 3] [2] 
r0r3 + in [ 3] [2] 
r0r2 + in [2] [2] 


(*out) [3] [0] = inv_det 
(*out) [3] [1] = inv_det 
(*out) [3] [2] = inv_det 
(*out) [3] [3] = inv_det 

return 0; 


-minorO; 
minorl ; 
-minor 2; 
minor3; 


template <int N, typename T> 

void FM_identity (FM_vector<N, FM_vector<N, T> >* out) 

< 

T zero = (T) 0; 

T one = (T) 1; 

for (int row = 0; row < N; row++) 
for (int col = 0; col < N; col++) 

(*out) [row] [col] = row == col ? one : zero; 

) 


typedef FM_vector<2, FM_vector<2 , f loat> > FM_matrix22f , 
typedef FM_vector<2, FM_vector<3, f loat> > FM_matrix23f , 
typedef FM_vector<3, FM_vector<2 , f loat> > FM_matrix32f , 
typedef FM_vector<3, FM_vector<3, f loat> > FM_matrix33f , 


*out) 

[0] 

0] 

= 

inv 

det 

* 

minorO; 






typedef FM vector<3,FM 

vector<3, double> > FM matrix33d 

*out) 

[0] 

1] 

= 

inv 

det 

* 

-minorl; 






typedef FM vector<4,FM 

vector<4 , f loat> > FM matrix44f; 

*out) 

[0] 

2] 

= 

inv 

det 

* 

minor2; 






typedef FM vector<4,FM 

vector<4 , double> > FM matrix44d 

*out) 

[1] 

0] 

= 

inv 

det 

* 

(in [2] [0] 

* 

in [1] [2] 

- in [1] [0] 

* 

in [2] [2]) 



*out) 

[1] 

1] 

= 

inv 

det 

* 

(in [0] [0] 

* 

in [2] [2] 

- in [2] [0] 

* 

in [0] [2]) 



*out) 

[1] 

2] 

= 

inv 

det 

* 

( in [ 1 ] [0] 

* 

in [0] [2] 

- in [0] [0] 

* 

in [1] [2]) 

/* 


*out) 

[2] 

0] 

= 

inv 

det 

* 

( in [ 1 ] [0] 

* 

in [2] [1] 

- in [2] [0] 

* 

in [1] [1]) 

* Copyright (c) 2000 


*out) 

[2] 

1] 

= 

inv 

det 

* 

( in [ 2 ] [0] 

* 

in [0] [1] 

- in [0] [0] 

* 

in [2] [1]) 

* Advanced Management 

Technology, Incorporated 

*out) 

[2] 

2] 

= 

inv 

det 

* 

(in [0] [0] 

* 

in [1 ] [1] 

- in [1] [0] 

* 

in [0] [1]) 

* 



rlr2 

r0r2 

rOrl 

rOrl 


' Permission is hereby granted, free of charge, 

1 to any person obtaining a copy of this software 
' and associated documentation files (the "Software") , 

1 to deal in the Software without restriction, 

' including without limitation the rights to use, 

1 copy, modify, merge, publish, distribute, sublicense, 

' and/or sell copies of the Software, and to permit 
1 persons to whom the Software is furnished to do so, 

1 subject to the following conditions: 

r The above copyright notice and this permission 
' notice shall be included in all copies or substantial 
: portions of the Software. 


T 

rOrl = 

in 

[0] [2] 

* 

in [1] [3] 

- in [1] [2] 

* 

in [0] [3] 




* 


T 

r0r2 = 

in 

[0] [2] 

* 

in [2] [3] 

- in [2] [2] 

* 

in [0] [3] 




* 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

T 

r0r3 = 

in 

[0] [2] 

* 

i 

[ 3] [3] 

- in [3] [2] 

* 

in 

[0] [3] 




* 

OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

T 

rlr2 = 

in 

[1] [2] 

* 

i 

i[2] [3] 

- in [2] [2] 

* 

in 

[1] [3] 




* 

LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

T 

rlr3 = 

in 

[1] [2] 

* 

i 

[ 3] [3] 

- in [3] [2] 

* 

in 

[1] [3] 




* 

FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

T 

r2r3 = 

in 

[2] [2] 

* 

i 

[ 3] [3] 

- in [3] [2] 

* 

in 

[2] [3] 




* 

EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 















* 

FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

// 

columi 

0 












* 

IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

T 

minorO 

= 

in [1] 

1] 

* 

r2r3 - 

in [2] [1] * 

rlr3 

+ in [3] 

[1] 

* rlr2; 

* 

FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

T 

minorl 

= 

in [0] 

1] 

* 

r2r3 - 

in [2] [1] * 

r0r3 

+ in [3] 

[1] 

* r0r2; 

* 

THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

T 

minor2 

= 

in [0] 

1] 

* 

rlr3 - 

in [1] [1] * 

r0r3 

+ in [3] 

[1] 

* rOrl; 

* 


T 

minor3 

= 

in [0] 

1] 

* 

rlr2 - 

in [1] [1] * 

r0r2 

+ in [2] 

[1] 

* rOrl ; 

* 



T det = 
in [0 ] [0] 


minorO - 
minorl - 
minor2 - 
minor 3; 


if (det == (T) 0) 

T inv_det = (T) 1 / det; 


31 



// Emacs mode -*-c++-*- // 
#ifndef _FM_MESH_H_ 

#def ine _FM_MESH_H_ 

/* 

* NAME: FM mesh . h 


public : 

FM_mesh (FM_properties_cache* pc) : 

FM_mesh_(FM_u32 (B) , FM_u32 (D) , pc), 

FM_field_interface<B, D, FM_vector<D, FM_coord> >(this, 0) 

U 


* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

#include "FM_shared_ob ject_with_p roper ties_cache . h” 
tinclude "FM_f ield_interf ace . h" 
tinclude "FM_iter . h" 
tinclude "FM_interpolate . h" 


class FM_mesh_ : public FM_shared_ob ject_with_properties_cache 

{ 

public : 

const FM_u32 base_dimensionality; 
const FM_u32 phys_dimensionality; 


virtual std : : ostreamS str (std : : ostreamS o) const 

{ 

return o « "FM_mesh<" « B « « D « ">"; 

} 

virtual FM_vector<B, FM_u32> 

get_base_dimensions (const FM_time<FM_u32>* t = 0, 

const FM_submesh_id* sid = 0) const 

{ 

FM_ostringstream err; 

err « *this « ” : : get_base_dimensions (" « 

(t ? *t : FM_time<FM_u32> {) ) « ", " « 

(sid ? *sid : FM_submesh_id () ) « ") : not for this mesh"; 
throw std : : logic_error (err . str ( ) ) ; 


FM_mesh_ (FM_u32 b, FM_u32 d, FM_properties_cache* pc) 
FM_shared_ob ject_with_properties_cache (pc) , 
base_dimensionality (b) , 
phys_dimensionality (d) 

{} 


virtual FM u6> 


get_card (FM_u32, FM_u32 = 0, const FM_time<FM_u32>* 
const FM_submesh_id* = 0) const = 0; 


virtual bool get_structured_behavior (const FM_time<FM_u32>* = 0, 

const FM submesh id* = 0) const 


return false; 


virtual FM_u64 cell_to_enum (const FM_cell*) const = 0; 
virtual FM_ptr<FM_cell> enum_to_cell(FM_u64, FM_u32 , FM_u32 = 0, 

const FM_time<FM_u32>* = 0, 

const FM_submesh_id* = 0) const = 0; 


virtual std: : vector<FM_ptr<FM_cell> > 
faces (const FM_cell*, FM_u32) const = 0; 

virtual std: : vector<FM_ptr<FM_cell> > 
ad jacencies (const FM_cell* c) const 
< 

std: : vector<FM_ptr<FM_cell> > adjacent_cells; 

FM_u32 d = c->get_dimension () ; 

if (d == 0 || d == base_dimensionality ) { 

FM_u32 dl = (d == 0 ? 1 : d - 1) ; 

std : : vector<FM_ptr<FM_cell> > cellsl = faces(c, dl); 
std :: vector <FM_ptr<FM_cell> > : : const_iterator iter; 
for (iter = cellsl . begin () ; iter != cellsl. end( ) ; ++iter) { 
std : : vector<FM_ptr<FM_cell> > cells = faces (*iter, d) ; 
if (cells . size () == size_t(2)) 

adjacent_cells .push_back (*cells [0] != *c ? cells[0] : cells[l]); 

} 

return ad jacent_cells; 

} 

FM_o st ring stream err; 

err « *this « ":: ad jacencies (” « *c « ”) : " « 

"only for cells with dimension 0 or B (" « base_dimensionality « ")"; 
throw std: : logic_error (err. str () ) ; 


virtual FM_iter begin () const = 0; 

virtual FM_iter begin (const FM_iter_attrs&) const = 0; 
inline FM_iter end() const { return FM_iter(); ) 

virtual FM_ptr<FM_shared_ob ject> 

get_aux (const std::string& key, FM_u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) const 

< 

if (key == "base_dimensionality”) { 

return new FM_simple_value<FM_u32> (base_dimensionality) ; 

) 

else if (key == "phys_dimensionality ”) ( 

return new FM_simple_value<FM_u32> (phys_dimensionality) ; 

) 

else if (key == "n_submeshes") { 

return new FM_simple_value<FM_u32> (0) ; 

} 

else if (key == "structured_behavior”) { 

return new FM_simple_value<bool> (get_structured_behavior (t, sid)); 

) 

return FM_shared_ob ject_with_properties_cache: : get_aux (key , pass, t, sid); 


virtual std: :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > 
get_bounding_box (const FM_time<FM_u32>* t = 0, 

const FM_submesh_id* sid = 0) const 

{ 

std : : pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > bb; 
FM_iter_attrs iter_attrs; 
if (t SS t->defined () ) 

iter_attrs.push_back (new FM_time_iter_attr (*t) ) ; 
if (sid && sid->def ined () ) 

iter_attrs.push_back (new FM_submesh_id_iter_attr (*sid) ) ; 
FM_iter iter = begin (iter_attrs) ; 

FM_iter e = end(); 

FM_vector<D, FM_coord> cv; 
int res = FM_0K; 
bool first = true; 
for ( ; iter != e; ++iter) { 
res = at_cell (*iter, Scv) ; 
if (res ! = FM_0K) break; 
if (first) ( 
bb . first = cv; 
bb . second = cv; 
first = false; 
continue; 

) 

FM_operator_min_max_equals (bb, cv) ; 

} 

if (res ! = FM_0K) { 

FM_ostringstream err; 

err « *this « " : : get_bounding_box ( ” « 

(t ? *t : FM_time<FM_u32> () ) « ”, " « 

(sid ? *sid : FM_submesh_id () ) « ") : got res " « res; 
throw std: : logic_error (err. str () ) ; 

} 

return bb; 


virtual int 

at_phys (const FM_phys<D>& p, FM_context* ctxt, 

FM_vector<D, FM_coord>* val) const 

< 

FM_pt r<FM_cell> c; 

int res = phys_to_cell (p, ctxt, &c) ; 
if (res != FM_0K) return res; 

*val = p; 
return res; 

) 

virtual int 

base_to_cell (const FM_base<B>&, FM^ptr<FM_structured_B_cell<B> >*) const 

{ 

return FM_N 0T_DE FINED; 

) 

virtual int 

base_to_phys (const FM_base<B>S b, FM_context* ctxt, FM_phys<D>* p) const 

{ 

int res = at_base(b, ctxt, p) ; 
p->time . set_undef ined ( ) ; 
return res; 

} 


virtual int 

phys_to_base (const FM_phys<D>&, FM_context*, 
FM_pt r < FM_s t r u ct u r ed_B_ce 1 1 <B > 


< 


return FM_N OT_DE FINED; 

} 


FM_base<B>*, 
>* = 0) const 


virtual std : : set<std : : string> 

get_property_names_aux (std: : set<std: : string>& property_names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) const 

< 

property_names . insert ("base_dimensionality") ; 
property_names . insert ("phys_dimensionality") ; 
property_names . insert ("n_submeshes" ) ; 
property_names . insert ("structured_behavior") ; 
return FM_shared_ob ject_with_properties_cache: : 
get_property_names_aux (property_names, t, sid) ; 

} 

} 1 

template <int B, int D> 
class FM_me sh : 
public FM_mesh_, 

public FM_f ield_interf ace<B, D, FM_vector<D, FM_coord> > 


virtual int 

phys_to_cell (const FM_phys<D>& , FM_context*, FM_ptr<FM_cell>*) const = 0 


virtual FM_vector<D, FM_coord> centroid (const FM_cell* c) const 

< 

std : : vector<FM_vector<D, FM_coord> > vertex_coordinates; 
int res = at_cell (c, &vertex_coordinates) ; 
if (res ! = FM_OK) { 

FM_ostringstream err; 

err « *this « ”:: centroid (" « *c « ") : at_cell res " « res; 
throw std : : logic_error (err . str ( ) ) ; 

) 

FM_vector<D, FM_coord> cen = vertex_coordinates [ 0 ] ; 
for (size_t i = 1; i < vertex_coordinates . size () ; i++) 
cen += vertex_coordinates [ i] ; 
cen *= FM_coord(l) / FM_coord (vertex_coordinates . size () ) ; 


32 



virtual FM_ptr<FM_shared_ob ject> 

get_aux (const std: : strings key, FM_u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) const 

{ 

if (key == "bounding_box”) { 

std : : pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > min_max = 
get_bounding_box (t , sid) ; 

std : : vector<FM_ptr<FM_shared_ob ject> > lo_values (D) ; 
std : : vector<FM_ptr<FM_shared_ob ject> > hi_values (D) ; 
for (int j = 0; j < D; j++) { 

lo_values [ j ] = new FM_simple_value<FM_coord> (min_max . first [ j ] ) ; 
hi_values[j] = new FM_simple_value<FM_coord> (min_max. second [ j] ) ; 

} 

return new FM_tuple_value (new FM_tuple_value (lo_values) , 
new FM_tuple_value (hi_values) ) ; 

} 

return FM_mesh_: :get_aux (key, pass, t, sid); 

} 

virtual std : : set<std : : string> 

get property_names_aux (std : : set<std : : string>s property names, 
const FM_t ime<FM_u3 2 > * t, 
const FM_submesh_id* sid) const 

{ 

property_names . insert ( "bound in g_box " ) ; 

return FM_mesh_: :get_p roper ty_names_aux (property_names, t, sid); 

} 

} ; 

/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software”) , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_MUTEX_H_ 

♦define _FM_MUTEX_H_ 

/* 

* NAME : FM_mutex . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include <pthread.h> 

class FM_mutex 

{ 

public : 

FM_mutex() { pthread_mutex_init (Smutex, 0); ) 

~FM_mutex ( ) { pthread_mutex_destroy (Smutex) ; ) 

inline int lock{) { return pthread_mutex_lock (Smutex) ; ) 
inline int unlock () { return pthread_mutex_unlock (Smutex) ; ) 

private: 

pthread_mutex_t mutex; 

} ; 

/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


*/ 

♦endif 


33 



// Emacs mode -*-c++-*- // 

#ifndef _FM_OR I ENT_H_ 

#def ine _FM_ORIENT_H_ 

/* 

* NAME: FM_orient . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude <stdlib.h> 
tinclude <assert.h> 
tinclude "FM_vector . h" 
tinclude "FM_combinatorics . h” 


const char* FM_orientation_names [ 3] = { 
"outside", "orientation 0”, "inside” 

} ; 


FM_vector<3, double> cb(c - b) ; 

FM_vector<3, double> dc(d - c) ; 

FM_vector<3, double> eb(e - b) ; 

FM_vector<3, double> ec(e - c) ; 

FM_vector<3, double> ed(e - d) ; 

const char* triangle_names [4 ] = {"abd”, "abc”, "bed", "acd"] 
double results [4] ; 

results [0] = FM_dot (ea, FM_cross(ba, da)); 
results [1] = FM_dot (eb, FM_cross(cb, -ba) ) ; 
results [2] = FM_dot (ec, FM_cross(dc, -cb) ) ; 
results [3] = FM_dot (ed, FM_cross (-da, -dc) ) ; 

int i, largest_result = 0; 
for (i =1; i < 4; i++) { 

if (FM_abs (results [i] ) > FM_abs (results [ largest_result] ) ) 
largest_result = i; 

) 


// Return: 

// 1 if c is to the left of the line through ab (from a to b) 

// -1 if c is to the right of the line through ab 

// 0 if c is colinear with ab 

// 

// This is equivalent to evaluating the sign of the determinant: 

// 

// | a [0 ] a [ 1] 1 | 

// | b [0] b [1] 1 I 

// | c [0 ] c [1] 1 | 

// 


template <typename T> 

int FM_orient (const FM_vector<2, T>& a, 
const FM_vector<2, T>& b, 
const FM_vector<2, T>& c) 

{ 


) 


return FM_sign(a[0] 
c [0 ] 


(b [1] - c[l]) - b[0] 
(a [1] - b [1] ) ) ; 


(a [1] - c[l]) + 


// Return: 

// 1 if d sees triangle abc vertices counterclockwise 

// -1 if d sees triangle abc vertices clockwise 

// 0 if d is coplanar with abc 

// 

template ctypename T> 

int FM_orient (const FM_vector<3, T>& a, const FM_vector<3, T>& b, 
const FM_vector<3, T>& c, const FM_vector<3, T>& d) 


{ 


return FM_sign (FM_dot (d - a, FM_cross(b - a, c - a))); 

} 


template <> 

int FM_orient (const FM_vector<3, float>& 
const FM_vector<3, float >& 


{ 


// computed manually 
double ba_x = b [ 0 ] - 
double ba_y = b [ 1 ] - 
double ba_z = b [ 2 ] - 
double ca_x = c[0] - 
double ca_y = c[l] - 
double ca_z = c[2] - 
return FM_sign ( (d [ 0] 
(d [ 1] 
(d[2] 


for performance, 
a [ 0 ] ; 
a [1] 
a [2] 
a [0] 
a [ 1] 
a [2] 


[ 0 ]) 

[ 1 ]) 

[ 2 ]) 


(ba_y 

(ca_x 

(ba_x 


a, const FM_vector<3, f loat>& b, 
c, const FM_vector<3, f loat>& d) 

doubles for fewer round-off problems 


ca_z - ca_y * ba_z) + 
ba_z - ba_x * ca_z) + 
ca_y - ca_x * ba_y) ) ; 


// Compute orientation of e with respect to quadrilateral abed 
// by treating abed as two triangles: abc and acd. 

// 

II Let there be a viewer who sees abed counter-clockwise (e.g. from 
// a position inside a 3-cell) . Return: 

// 

// 1 if e on same side of quadrilateral abed as viewer 

// -1 if e on opposite side of quadrilateral abed with respect to viewer 

// 0 if e is coplanar with abed 

// 

// The result is computed by doing two orientation tests, one for e 
// with respect to abc, and one for e with respect to acd. 

// If these two tests agree, we conclude we're done. If they don't, 

// take the largest magnitude result, based on triangles abd, abc, 

// bed, and acd. 

// 

template <typename T> 

int FM_orient (const FM_vector<3, T>& a, const FM_vector<3, T>& b, 
const FM_vector<3, T>& c, const FM_vector<3, T>& d, 
const FM_vector<3, T>& e) 

{ 

FM_vector<3, double> ba (b - a); 

FM_vector<3, double> ca(c - a); 

FM_vector<3, double> da(d - a); 

FM_vector<3, double> ea(e - a) ; 


int abc_orient = FM_sign (FM_dot (ea, FM_cross(ba, ca) ) ) ; 
int acd_orient = FM_sign (FM_dot (ea, FM_cross(ca, da))); 

if (abc_orient == acd_orient) 
return abc_orient; 


int verbosity = 1; 
if (verbosity >0) { 
std : : cerr « "FM_or 
d « ", " « e « 
std: :cerr « "abc_o 
std: :cerr « ", acd 

} 


ient ( ” « a « " , " « b « " , " « c « 
") " « std::endl; 
rient : " « abc_orient; 

_orient: " « acd_orient « std: :endl; 


« 


int res = FM_sign (results [largest_result] ) ; 

if (verbosity >0) { 

for (i =0; i < 4; i++) 

std: : cerr « triangle_names [i] « ” orient result: " « 
results[i] « std::endl; 

std:: cerr « "largest magnitude result ” « 

"(triangle ” « triangle_names [largest_result] « ") : " « 
results [largest_result] « std: :endl; 

std:: cerr « ”FM_orient (” « a « ", " « b « ", " « c « ", " « 
d « ", " « e « ") returning " « res « std: :endl; 

} 


return res; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

#endif 


34 



// Emacs mode -*-c++-*- // 

#ifndef _FM_OSTRINGSTREAM_H_ 

#def ine _FM_OSTRINGSTREAM_H_ 

/* 

* NAME: FM_ostringstream. h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

* DESCRIPTION: 

* FM_ostringstream provides a work-around for systems 

* that do not have std: :ostringstream yet, using the 

* deprecated std: :ostrstream. We basically define a 

* new class (FM_ostringstream) derived from std: : strstream, 

* with a redefined str() method that handles string termination 

* and memory management properly. 

* SEE ALSO: 

* N. Josuttis. The C++ Standard Library: A Tutorial and 

* Reference, Addison-Wesley, 2000, pages 649-651. This 

* is the best reference I have found that explains how 

* strstream works. 

*/ 

#if defined ( GNUC ) 

fifndef FM_NO_STRINGSTREAM 
fdefine FM_NO_STRINGSTREAM 
fendif 
#endif 


fifndef FM_NO_STRINGSTREAM 
finclude <sstream> 

typedef std: : ostringstream FM_ostringstream; 
felse 

finclude <strstream> 
finclude <string> 

class FM_ostringstream : public std: :ostrstream 

{ 

public : 

std: : string str() 

{ 

// the std: : ostrstream : : str () method does not automatically 
// terminate the string with 0, so we must ensure that it is 
// terminated ourselves. 

*this « std: :ends; 

// The std: : ostrstream :: str () call internally calls freezeO 

// on the buffer, meaning that ownership of the memory is 

// transferred to the caller. We do not want to be responsible 

// for the deallocation (for among other reasons because we do 

// not know how it was allocated) so we ''unfreeze" to transfer 

// deallocation duties back to ostrstream. 

const char* res = std :: ostrstream: : str () ; 

freeze (false) ; 

return std: : string (res) ; 

} 

} ; 

fendif 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

fendif 


// Emacs mode — *— C++— *— // 
fifndef _FM_PHYS_H_ 
fdefine _FM_PHYS_H_ 

/* 

* NAME: FM_phys.h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

finclude "FM_vector . h" 
f inc lude "FM_t ime . h " 

template <int D> 

class FM_phys : public FM_vector<D, FM_coord> 

< 

public : 

FM_t ime<FM_coo rd> t ime ; 

FM_phys () { ) 

FM_phys (const FM_coord dat[]) : FM_vector<D, FM_coord> (dat) {) 

FM_phys (const FM_vector<D, FM_coord>& v) : FM_vector<D, FM_coord> (v) { } 

}; 


template <> 

class FM_phys<l> : public FM_vector<l, FM_coord> 

{ 

public : 

FM_time<FM_coord> time; 

FM_phys() {) 

FM_phys (const FM_coord dat[]) : FM_vector<l, FM_coord>(dat) {) 

FM_phys (const FM_vector<l, FM_coord>& v) : FM_vector<l, FM_coord> (v) { } 
FM_phys (const FM_coord£ aO) : 

FM_vector<l , FM_coord> (aO) { } 

); 


template <> 

class FM_phys<2> : public FM_vector<2 , FM_coord> 
public : 

FM_t ime<FM_coo rd> t ime ; 

FM _phys () {} 

FM_phys (const FM_coord dat [ ] ) : FM_vector<2, FM_coord> (dat) {) 

FM_phys (const FM_vector<2, FM_coord>& v) : FM_vector<2, FM_coord> (v) {} 
FM_phys (const FM_coord£ aO, const FM_coordS al) : 

FM_vector<2 , FM_coord> (aO, al) {) 

) ; 


template <> 

class FM_phys<3> : public FM_vector<3, FM_coord> 

{ 

public : 

FM_time<FM_coord> time; 

FM _j>hys () { ) 

FM^phys (const FM_coord dat[]) : FM_vector<3, FM_coord> (dat) {) 

FM_phys (const FM_vector<3, FM_coord>& v) : FM_vector<3, FM_coord> (v) { ) 
FMj?hys (const FM_coord& aO, const FM_coord£ al, const FM_coord& a2) : 
FM_vector<3, FM_coord> (aO, al, a2) {) 

) ; 


template <int D> 

std: :ost reams operator« (std : : ostreamS lhs, const FM_phys<D>S rhs) 

< 

lhs « "("; 

int i; 

for (i =0; i < D; i++) { 
if (i > 0) lhs « ", "; 
lhs « rhs [ i] ; 

} 

if (rhs .time, defined () ) { 
if (i++ > 0) lhs « ", ” ; 
lhs « "time=" « rhs .time, get () ; 

} 

return lhs « ")"; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


35 



*/ 

#endi: 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_PRODUCT_MESH_H_ 

♦define _FM_PRODUCT_MESH_H_ 

/* 

* NAME: FM_product_mesh . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include "FM_structured_mesh . h" 


template <int B, int D> 

class FM_product_mesh : public FM_structured_mesh<B, D> 

< 

public : 

const std : : vector<FM_ptr<FM_structured_mesh<l, 1> > > axes; 

FM_product_mesh (const std: : vector<FM_ptr<FM_structured_mesh<l, 1> > >& a, 
FM_p rope rties_c ache* pc =0) 

FM_structured_mesh<B, D> (pc) , 
axes (a) 

{ 

if (axes. size () != size_t (B) ) { 

FM_ostringstream err; 

err « ,, FM_product_mesh< , ' « B « ", " « D « ”> : : FM_product_mesh : ” 
err « "expecting " « B « " axes, got " « axes, size (); 
throw std: : logic_error (err. str () ) ; 

) 


FM_vector<l , FM_u32 > dimension ; 
for (int i = 0; i < B; i++) { 

dimension = axes[i]->get_base_dimensions(); 
const_cast<FM_u326> (dimensions [i] ) = dimension [0] ; 

} 

init (dimensions) ; 


protected: 

FM_product_mesh (const FM_vector<B, FM_u32>& d, FM_properties_cache* pc = 0) 
FM_structured_mesh<B, D> (d, pc) , 
axes (B) 

< 

// axes filled in by derived class constructor 

} 


public : 

virtual std : : ostreamS str (std :: ostreamS o) const 

< 

return o « , 'FM_product_mesh<" « B « « D « ">"; 

} 

virtual int 

at_cell (const FM_cell* c, std : : vector<FM_vector<D, FM_coord> >* vals) const 

{ 

FM_u32 d = c->get_dimension ( ) ; 

FM_u32 n = c->is_subsimplex ( ) ? d + 1 : FM_pow_2 (d) ; 

FM_u32 previous_size = vals->size () ; 
vals->resize (previous_size + n) ; 

return FM_product_mesh : : at_cell (c, £ (*vals) [previous_size] ) ; 

) 

virtual int 

at_ce 11 (const FM_cell* c, FM_vector<D, FM_coord>* vals) const 

{ 

const FM_structured_cell<B>* sc = 

dynamic_cast<const FM_structured_cell<B>*> (c) ; 
if (sc == 0) 

FM_throw_bad_cell_argument (this, "at_cell", c) ; 

FM_base<l , FM_u32> b (c->get_time ( ) , c->get_submesh_id () ) ; 

FM_u32 d = sc->get_dimension () ; 

FM_vector<l , FM_coord> coordinate; 
if (sc->is_subsimplex () ) ( 

//assert (B == 2 | | B == 3) ; 

FM_u32 sub id = sc->get_subid () ; 

FM_u32 n = d + 1; 

for (FM_u32 i = 0; i < n; i++) { 

FM_u32 mask = 1; 
int j ; 

for (j = 0; j < B; j++) ( 
b[0] = sc->get_index ( j) ; 

if (FM_structured_hexahedron_sub faces [d] [subid] [i] & mask) 
b[0]++; 

int res = axes [ j] ->at_base (b, Scoordinate) ; 
if (res != FM_0K) return res; 
vals[i][j] = coordinate [ 0] ; 
mask «= 1 ; 

} 

for ( ; j < D; j++) 

vals[i][j] = FM_coord(0) ; 

} 

} 

FM_u32 n = FM_pow_2 (d) ; 

FM_vector<B, bool> free_indices = alignments [d] [ sc- >get_alignment ()] ; 
for (FM_u32 i = 0; i < n; i++) { 

FM_u32 mask = 1; 

for (j = 0; j < B; j++) { 
b[0] = sc->get_index ( j) ; 
if (free_indices [ j] && (i & mask)) 
b [ 0 ] ++; 

int res = axes [ j] ->at_base (b, Scoordinate); 
if (res ! = FM_OK) return res; 
vals[i][j] = coordinate [ 0] ; 
mask «= 1; 

} 

for ( ; j < D; j++) 

vals[i][j] = FM_coord(0) ; 


36 



} 

} 

return FM_OK; 

} 

virtual int phys_to_base (const FM_phys<D>& p, FM_context* ctxt, 
FM_base<B>* b, 

FM_ptr<FM_structured_B_cell<B> >* sc = 0) const 

{ 

int res; 

FM_base<l> bl; 

FM_vector<B, FM_u32> indices; 
for (int i = 0; i < B; i++) { 

res = axes [ i] ->phys_to_base (p [i] , ctxt, &bl); 
if (res ! = FM_0K) return res; 

(*b) [i] = bl [ 0] ; 

indices [i] = FM_u32 ( (*b) [i] ) ; 

if (indices [i] == dimensions [i] - 1) indices [i] — ; 

} 

if (sc) 

*sc = new FM_structured_B_cell<B> (indices) ; 
return res; 


virtual std : :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > 
get_bounding_box (const FM_time<FM_u32>* t = 0, 

const FM_submesh_id* sid = 0) const 

{ 

std: :pair<FM_vector<D, FM_coord>, FM_vector<D, FM_coord> > bb; 
int i; 

for (i = 0; i < B; i44) { 

std : : pair<FM_vector<l, FM_coord>, FM_vector<l, FM_coord> > 

axis_bounding_interval = axes [i] ->get_bounding_box (t, sid); 
bb. first [i] = axis_bounding_interval. first [0] ; 
bb. second [i] = ax is_bounding_interval . second [0] ; 

) 

for ( ; i < D; i44) { 

bb. first [i] = FM_coord(0); 
bb.second[i] = FM_coord(0); 

) 

return bb; 

) 

} ! 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the ''Software 1 ') , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


// Emacs mode — *— c44— *— // 

♦ifndef _FM_PROPERTIES_CACHE_H_ 

♦define _FM_PROPERTIES_CACHE_H_ 

/* 

* NAME: FM_p roper t ies_cache . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include <map> 

♦include "FM_shared_ob ject . h” 


typedef std:: string FM_properties_key; 

typedef std : : map<FM_properties_key, FM_pt r<FM_shared_ob ject> > 

FM_p rope rt ie s_map ; 

class FM_properties_cache : public FM_shared_ob ject 

< 

public : 

FM properties_cache ( ) {} 

FM_properties_cache (const FM_properties_map& props) 
properties_cache (props) {) 

virtual FM_pt r<FM_shared_ob ject> 
get (const std: : strings key, 

const FM_time<FM_u32>* = 0, const FM_submesh_id* = 0) const 

{ 

FM_ptr<FM_shared_object> res; 
properties_cache_mutex . lock () ; 

FM_properties_map: :const_iterator 

properties_iter = properties_cache. find (key) ; 
if (properties_iter != p roper t ies_cache. end() ) 
res = (*properties_iter) . second; 
properties_cache_mutex .unlock () ; 
return res; 

} 

virtual std: : set<std: : string> 

get_property_names_aux (std: :set<std: :string>S property_names, 

const FM_time<FM_u32>*, const FM_submesh_id* ) const 

{ 

properties_cache_mutex . lock () ; 

FM_properties_map: :const_iterator i; 

for (i = p rope rties_cache .begin () ; i != properties_cache . end () ; 44i) 
property_names . insert ( (*i) . first) ; 
properties_cache_mutex .unlock () ; 
return property_names; 

} 

virtual void 

set (const std::strings key, const FM_shared_ob ject* property, 
const FM_time<FM_u32>* = 0, const FM_submesh_id* = 0) 

< 

properties_cache_mutex . lock () ; 
properties_cache [key ] = property; 
properties_cache_mutex . unlock () ; 

) 

private: 

FM_properties_map properties_cache; 
mutable FM_mutex properties_cache_mutex; 

} 1 
/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


37 



// Emacs mode -*-c++-*- // 

# i f n de f _FM_RE GULAR_INTERVAL_H_ 

#de f in e _FM_RE GULAR_INTERVAL_H_ 

/* 

* NAME: FM_regular_interval . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include "FM_structured_mesh . h" 

class FM_regular_interval : public FM_structured_mesh<l, 1> 

{ 

public : 

const FM_coord origin; 
const FM_coord spacing; 

FM_r egular_interval (FM_u32 d, 

FM_coord o = FM_coord(0), 

FM_coord s = FM_coord(l), 

FM properties cache* pc =0) : 

FM_structured_mesh<l, 1> (d, pc), origin (o), spacing (s) {) 

virtual std: :ost reams str (std: :ost reams o) const 

{ 

return o « "FM_regular_interval"; 

} 

virtual int 

at_cell (const FM_cell* c, std: : vector<FM_vector<l, FM_coord> >* vals) const 

{ 

FM_u32 n_indices; 

FM_u 64 indices [ 2 ] ; 

c->structured_mesh_vertex_indices (this, Sn_indices, indices); 
for (FM_u32 i = 0; i < n_indices; i++) 

vals->push_back (origin + FM_coord (indices [i] ) * spacing); 
return FM_0K; 


virtual int 

at_cell (const FM_cell* c, FM_vector<l, FM_coord>* vals) const 

{ 

FM_u32 n_indices; 

FM_u64 indices [2]; 

c->structured_mesh_vertex_indices (this, Sn_indices, indices); 
for (FM_u32 i = 0; i < n_indices; i++) 

vals[i] = origin + FM_coord ( indices [i] ) * spacing; 
return FM_0K; 


virtual int 

phys_to_base (const FM_phys<l>& p, FM_context*, FM_base<l>* b, 
FM_ptr<FM_structured_B_cell<l> >* sc = 0) const 

{ 

(*b) [0] = (p [ 0 ] - origin) / spacing; 
int res = (FM_coord(0) <= (*b) [0] SS 

(*b) [0] <= FM_coord (dimensions [0] -1)) ? 

FM_0K : FM_0UT_0F_B0UNDS; 
if (res != FM_0K) return res; 
if (sc) 

res = base_to_cell (*b, sc) ; 
return res; 


virtual std : :pair<FM_vector<l , FM_coord>, FM_vector<l, FM_coord> > 
get_bounding_box (const FM_time<FM_u32>* = 0, const FM_submesh_id* = 0) const 

return std: :pair<FM_vector<l, FM_coord>, FM_vector<l, FM_coord> > 

(origin, origin + FM_coord (dimensions [0] - 1) * spacing); 

) 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_REGULAR_MESH_H_ 

♦define _FM_REGULAR_MESH_H_ 

/* 

* NAME: FM_regular_mesh . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include "FM_product_mesh . h" 

♦include "FM_regular_interval . h” 


template <int B, int D> 

class FM_regular_mesh : public FM_product_mesh<B, D> 

< 

public : 

FM_regu la r_mesh (const FM_vector<B, FM_u32>& d, FM_properties_cache* pc 
FM_product_mesh<B, D> (d, pc) 

{ 

for (int i = 0; i < B; i++) 

const_cast<FM_ptr<FM_structured_mesh<l , 1> >&> (axes [ i] ) = 
new FM_regular_interval (d[i] ) ; 

J 

virtual std: :ost reams str(std: :ostreamS o) const 

{ 

return o « ■'FM_regular_mesh< , ' « B « « D « ">"; 

} 

) ; 

/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software'') , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


38 



// Emacs mode -*-c++-*- // 
#ifndef _FM_RE SUIT S_H_ 
#def ine _FM_RE SUIT S_H_ 

/* 

* NAME: FM results. h 


// Emacs mode — *— C++— *— // 
♦ifndef _FM_SHARED_OBJECT_H 
♦define _FM_SHARED_OBJECT_H_ 
/* 

* NAME : FM_s ha r ed_ob j ec t . h 


* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 


const int 
const int 
const int 
const int 
const int 
const int 
const int 
const int 
const int 
const int 


FM_OK = 0; 

FM_OUT_OF_BOUNDS = 1; 
FM_BLANKED_DATA = 2; 

FM_P 0 1 NT_L OC AT I ON_F AI LED = 3; 
FM_ I0 _ER R ° R = 4; 
FM_INTERPOLATION_ERROR = 5; 
FM_NOT_DEF INED = 6; 

FM_P 0 1 NT_L OC AT E_WAL KE D_OFF_ME S H = 7; 
FM_POINT_LOCATE_STUCK = 8; 

FM_P 0 1 NT_0 UT S I DE_BO UND I NG_BO X = 9; 


* WRITTEN BY: 

* Patrick Moran 


*/ 

♦include 
♦include 
♦include 
♦include 
♦include 
♦include 
♦include 
♦include 
♦include 
♦ include 
♦include 


<iostream> 

<vector> 

<set> 

<stdexcept> 

<typeinfo> 

<assert . h> 

"FM_mutex . h " 
"FM_submesh_id. h" 
"FM_time. h" 
"FM_returns . h" 
"FM_ostringstream. h” 


pmoran@nas . nasa . gov 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software”) , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


// FM_ptr is a "smart pointer" for pointing at FM_shared_ob ject ' s . 
template ctypename T> 
class FM_ptr 
{ 

public : 

FM_pt r ( ) : ptr(O) {) 

FM_ptr (const T* p) : ptr(p) 

{ 

if (ptr) ptr->increment_reference () ; 

J 

// NOTE: 

// It is essential to still provide the copy constructor 
// and assignment operator definitions as untemplated member 
// functions, in addition to the corresponding templated 
// member functions. Without the untemplated member functions, 

// the compiler will silently generate its default code 
// when it encounters an argument of the type *this. The 
// implicit code does not manage reference counts properly, 

// so we must prevent the compiler from emitting it. 

// 

template ctypename S> 

FM_ptr (const FM_ptrCS>& p) : 

ptr (dynamic_cast<const T*> (static_castCconst S*>(p))) 

{ 

if (ptr) { 

ptr->increment_reference () ; 

) 

else ( 

if (static_cast<const S* > (p ) ) { 

FM_ostringstream err; 

err « "FM_ptr<" « typeid (T) . name ( ) « "> : : FM_ptr (FM_ptr<" « 
typeid(S) .named « ">&) : bad dynamic cast"; 
throw std : : logic_error (err . str () ); 



) 


FM_ptr (FMj?trCT>& p) : ptr (static_cast<const T*> (p) ) 

< 

if (ptr) ptr->increment_reference () ; 

) 

template ctypename S> 

const FM_ptrCT>& operator= (const FM_ptrcS>& rhs) 

{ 

const T* tmp = dynamic_castcconst T*> (static_castcconst S*>(rhs)); 
if (static_castcconst S*>(rhs) && !tmp) { 

FM_ostringstream err; 

err cc "const FM_ptrC" cc typeid(T) .named « 

">& operator= (const FM_ptrC" cc 
typeid(S) .named « ">&) : bad dynamic cast"; 
throw std : : logic_error (err . st r ( ) ) ; 

} 

set (tmp) ; 
return *this; 


const FM_ptrCT>& operator= (const FM_ptrCT>& rhs) 

{ 

set (static_castcconst T*>(rhs) ) ; 
return *this; 


~FM_ptr () 

< 

if (ptr) { 

if (ptr->decrement_ref erence ( ) == 0) { 
delete ptr; 

) 



inline const T* operator->() const { return ptr; ) 
inline operator const T* () const { return ptr; ) 

void set (const T* t) 

{ 

if (t) t->increment_reference () ; 
if (ptr) { 

if (ptr->decrement_ref erence ( ) == 0) { 
delete ptr; 

} 

} 

ptr = t; 


39 



const FM_pt r<T>S operator= (const T* rhs) 

{ 

set (rhs) ; 
return *this; 


protected: 

const T* ptr; 

} ; 


template <typename S, typename T> 

bool operator== (const FM_ptr<S>& lhs, const FM_ptr<T>S rhs) 

{ 

return static_cast<const S*>(lhs) == static_cast<const T*>(rhs); 

} 


// We can get the following from some STL implementations, to 
// avoid ambiguity problems we do not define our own if we get 
// STL's definition: 

// 

//template cclass _Tp> 

//inline bool operator != (const _TpS x, const _TpS y) { 

// return ! ( x == y) ; 

//} 

fifndef SGI_STL_INTERNAL_RELOPS 

template <typename S, typename T> 

bool operator != (const FM_ptr<S>S lhs, const FM_ptr<T>S rhs) 

{ 

return ! (lhs == rhs) ; 

} 

fendif 

template <typename T> 

std: :ost reams operator« (std: : ost reams s, const FM_ptr<T>S p) 

{ 

return s « static_cast<const T*>(p); 

) 

// FM_shared_ob ject is the base class for reference counted shared objects, 
class FM_shared_ob ject 
{ 

public : 

FM_shared_ob ject ( ) : reference_count (0) 
fifdef FM_S HARED_0 B JEC T_DEBUG 

// do not call virtual functions (re) defined by subclasses yet . .. 

// std::cout « *this « " constructing” « std::endl; 
std : : cout « this « " constructing” « std::endl; 
fendif 
} 

virtual ~FM_shared_ob ject () 

{ 

fifdef FM_SHARED_OBJECT_DEBUG 

//do not call virtual functions (re) defined by subclasses now ... 

// std : : cout « *this « ” destructing” « std: :endl; 
std : : cout « this « ” destructing” « std: :endl; 
fendif 

assert (ref erence_count == 0); 

} 

inline int get_reference_count ( ) const { return reference_count; } 

virtual std: : ost reams str (std: : ost reams o) const 

{ 

return o « this; 

) 


virtual std: : set<std: : string> 

ge t_p rope rty_names_aux (std: :set<std: :string>S property_names, 

const FM_time<FM_u32>*, const FM_submesh_id* ) 


{ 


return property_names; 

J 


private : 

template <typename T> friend class FM_ptr; 

int increment_reference () const 

{ 

mutex . lock ( ) ; 

int res = ++reference_count ; 
fifdef FM_SHAKED_OBJECT_DEBUG 

std:: cout « *this « " increment_ref erence ( ) , now 
« ref erence_count « std::endl; 

fendif 

mutex . unlock ( ) ; 
return res; 

} 


int dec rement_ref erence () const 

{ 

mutex . lock ( ) ; 

int res = — reference_count; 
fifdef FM_SHARED_OBJECT_DEBUG 

std: : cout « *this « ” decrement_ref erence () , now 
« reference_count « std::endl; 

fendif 

mutex . unlock ( ) ; 
assert (res >= 0); 
return res; 

} 


// prevent copy construction and assignment 
private: 

FM_shared_ob ject (const FM_shared_ob jectS) ; 

const FM_shared_ob jectS operator= (const FM_shared_ob jectS) ; 

private: 

mutable int reference_count; 
mutable FM_mutex mutex; 


template <typename T> 

class FM_simple_value : public FM_shared_ob ject 

{ 

public : 

const T value; 

FM_simple_value (const TS v) : value (v) {) 

virtual std : : ostreams str (std :: ostreams o) const { return o « value; 

) ; 


class FM_tuple_value : public FM_shared_ob ject 

< 

public : 

FM_tuple_value (const std : : vector<FM_ptr<FM_shared_ob ject> >S vs) 
values (vs) {) 

FM_tuple_value (FM_shared_ob ject* vO) : values (1) 

{ 

values [0] = vO; 

) 


friend std: : ostreams operator« (std: : ostreams o, const FM_shared_ob jectS so) 

< 

return so . str (o) ; 

) 

virtual FM_ptr<FM_shared_ob ject> 
get (const std:: strings key, 

const FM_time<FM_u32>* t = 0, const FM_submesh_id* sid = 0) const 

{ 

FM_ptr<FM_shared_ob ject> property = get_aux(key, 0, t, sid); 
if (property == 0) 

property = get_aux(key, 1, t, sid); 
if (! property) { 

FM_ostringstream err; 

err « *this « ”::get(\"” « key « ”, ”; 

err « (t ? *t : FM_time<FM_u32> () ) « ”, ”; 

err « (sid ? *sid : FM_submesh_id ( ) ) « ”\”) : undefined”; 

throw std: : logic_error (err. str () ) ; 

} 

return property; 


virtual std : : set<std : : string> 

get_property_names (const FM_time<FM_u32>* t = 0, 

const FM_submesh_id* sid = 0) const 

{ 

std: :set<std: :string> p roper ty_names; 

return get_property_names_aux (p roper ty_names, t, sid) ; 

} 

template ctypename T> 

void get_simple_value (const std: : strings, T*, const FM_time<FM_u32>* = 0, 
const FM_submesh_id* = 0) const; 

protected: 

virtual FM_ptr<FM_shared_ob ject> 
get_aux (const std: : strings, FM_u32, 

const FM_time<FM_u32>*, const FM_submesh_id* ) const 

{ 

return 0; 

} 


FM_tuple_value (FM_shared_ob ject* vO, FM_shared_ob ject* vl) 
values (2) 

{ 

values [0] = vO; 
values [1] = vl; 

) 

inline size_t sized const { return values, size () ; ) 
const FM_ptr<FM_shared_ob ject>S operator [] (int i) const 
{ 

return values [i] ; 

) 

virtual std :: ostreams str (std :: ostreams o) const 

{ 

o « ”(”; 

for (size_t i = 0; i < values. size () ; i++) { 
if (i > 0) o « ", "; 
o « *values[i]; 

) 

return o « ") ”; 

) 

private : 

std: : vector <FM_ptr<FM_shared_object> > values; 

) ; 


template <typename T> 
void FM_shared_ob ject : : 

get_simple_value (const std: : strings key, T* v, const FM_time<FM_u32>* t 
const FM_submesh_id* sid) const 

{ 

FM_ptr<FM_shared_ob ject> so_sv = get (key, t, sid) ; 
const FM_simple_value<T>S sv = 

dynamic_cast<const FM_simple_value<T>S> (*so_sv) ; 


/* 


40 



* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_SHARED_OBJECT_WITH_PROPERTIES_CACHE_H_ 
♦define _FM_SHARED_OBJECT_WITH_PROPERTIES_CACHE_H_ 
/* 

* NAME: FM_shared_ob ject_with_properties_cache . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include "FM_shared_ob ject . h” 

♦include "FM_properties_cache . h" 


class FM_shared_ob ject_with_properties_cache : public FM_shared_ob ject 

< 

public : 

FM_shared_ob ject_with_properties_cache () { } 

FM_shared_ob ject_with_properties_cache (FM_properties_cache* pc) : 
properties_cache (pc ? pc : new FM_properties_cache () ) {) 

virtual FM_pt r<FM_shared_ob ject> 
get (const std: : strings key, 

const FM_t ime<FM_u 32 >* t = 0, const FM_submesh_id* sid = 0) const 

{ 

// 1. check cache 

FM_ptr<FM_shared_object> property = properties_cache->get (key , t, sid); 
if (property) 

return property; 

// 2. first pass: bottom up, through class lineage 
property = get_aux(key, 0, t, sid) ; 

// 3. second pass: opportunity to query composed classes 
property = get_aux(key, 1, t, sid); 

if (! property) { 

FM_ostringstream err; 

err « *this « "::get(\"" « key « ”\”, "; 
err « ( (t ) ? *t : FM_time<FM_u32> () ) « ", "; 

err « ((sid) ? *sid : FM_submesh_id() ) « ") : property undefined"; 
throw std: : logic_error (err. str () ) ; 

) 


// do not cache if property specific to a time step or submesh 
if (!(((t) SS t->def ined ( ) ) || ((sid) SS sid->def ined () ) ) ) { 
const_cast<FM_properties_cache*> 

(static_cast<const FM_properties_cache*> (properties_cache) ) -> 
set (key, property, t, sid); 

} 


return property; 

} 


virtual void set(const std::stringS key, const FM_shared_ob ject* property, 

const FM_time<FM_u32>* t = 0, const FM_submesh_id* sid = 0) 


{ 


const_cast<FM_properties_cache*> 

(static_cast<const FM_properties_cache*> (properties_cache) ) -> 
set (key, property, t, sid); 


virtual std : : set<std : : string> 

get_property_names_aux (std: :set<std: :string>& property_names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) const 

{ 

property_names = 

properties_cache->get_property_names_aux (property_names, t, sid) ; 
return FM_shared_object : : get_property_names_aux (property_names, t, sid); 

) 

protected: 

FM_pt r < FM_p roperties_cache> p r ope r t ie s_c a c he ; 

} ; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


41 



// Emacs mode -*-c++-*- // 
#ifndef _FM_STRUCTURED_MESH_H_ 
#def ine _FM_STRUCTURED_MESH_H_ 
/* 


* 

NAME : FM st 

ructured m 

esh . h 

* 




* 

WRITTEN BY: 



* 

Patrick Moran 


*/ 



til 

iclude "FM m 

.esh.h" 


til 

iclude "FM c 

ombinatorii 

cs.h" 

til 

iclude "FM o 

rient.h" 


// 




// 

The canonic 

:al vertex : 

n umbei 

// 

The vertex 

indices in 

the 1 

// 

hexahedron 

numbering. 


// 




// 


6 


// 


/I 

/ 

// 


/ 1 

/ 

// 


4/ 

5/ 

// 


1 2 1 

1 

// 


1 / 

1 / 

// 


1 / 

1 / 

// 


1/ 

_\l : 

// 


0 

l 

// 


i -> 


// 




// 

Hexahedron 

faces : 



pmoran@nas . nasa . gov 


ng for a structured hexahedron . 
bles below are in terms of this 


FM_u32 FM_hf 0_0 [ ] = {0}; 

FM_u32 FM_hsf 0_0 [ ] = {0}; 

FM_u 32 * FM_hf 0 [] = { FM_hf 0_0 } ; 


FM_u3; 

FM_u3; 

FM_u3; 

FM_u3; 

FM_u3: 

FM_u3: 

FM_u3: 

FM_u3: 

FM_u3: 

FM_u3: 

FM hfl 0, FM hfl 1, FM hfl 2 


FM_hsf 0 [ 

= { FM_ 

hsf0_0 

FM_hf 1_0 [ 

= {0, 

l ) ; 

FM_hf 1_1 [ 

= <o. 

2}; 

FM_hf 1_2 [ 

= {0, 

4}; 

FM_hsf 1_0 

] = {0. 

3} 


FM_hsf 1_1 

] = 10, 

5} 


FM_hsf 1_2 

] = 10, 

6} 


FM_hsf 1_3 

] = a. 

2} 


FM_hsf 1_4 

] = {1. 

4) 


FM_hsf 1_5 

] = {2, 

4} 


FM hfl [] 

= { 



u32* FM_hsf 1 [ ] = { 

M_hsf 1_0, FM_hsfl_l , FM_hsfl_2, FM_hsfl_3, FM_hsfl_4, FM_hsfl_5 


FM_hf2_0 [ ] 

= {0, 1, 2, 3); 

FM_hf2_l [ ] 

= {0, 1, 4, 5); 

FM_hf2_2 [ ] 

= <0, 

, 4, 6 

: 

FM_hsf2_0 [ 

= 10, 

1, 3} ; 

II 

FM_hsf2_l [ 

= <0, 

3, 2); 

II 

FM_hsf2_2 [ 

= 10, 

1, 2 } 

II 

FM_hsf2_3 [ 

= {1, 

3, 2); 

II 

FM hsf2 4 [ 

= 10, 

5, 1); 

II 

FM_hsf2_5 [ 

= {0, 

4, 5); 

II 

FM hsf2_6 [ 

= 10, 

4, 1 } 

// 

FM_hsf 2_7 [ 

= u. 

4, 5); 

// 

FM_hsf 2_8 [ 

= 10, 

2, 6); 

// 

FM_hsf 2_9 [ 

= |0, 

6, 4}; 

// 

FM hsf 2 10 

] = |0, 

2, 4] 

// 

FM_hsf2_ll 

] = |2, 

6, 4] 

// 

angles interior to 

hexahedron 

FM_hsf2_12 

] = {0, 

5, 3} 

// 

FM_hsf2_13 

] = 10, 

3, 6} 


FM_hsf2_14 

] = {0, 

6, 5} 


FM_hsf2_15 

] = {3, 

5, 6} 


FM_hsf 2_1 6 

] = {1, 

2, 4] 

// 

FM_hsf2_17 

] = U, 

4, 7} 


FM_hsf2_18 

] = (1, 

7, 2} 


FM_hsf 2_1 9 

] = <2, 

7, 4} 



II /I 

l/_0| 


15 /| 
l/_4| 


19 /I 

l/_8| 


l\ 3| 
12 \| 


l\ 7| 

| 6 _\| 


l\ll| 

|10\| 


// even 5-tetrahedra decomposition 


// odd 5-tetrahedra decomposition 


FM_u32* FM_hf 2 [ ] = { 

FM_hf 2_0 , FM_hf 2_1 , FM_hf2_2 

}/ 

FM_u32* FM_hsf 2 [ ] = { 

FM hsf 2 0, FM hsf2 1, FM hsf2 


FM_hsf 2_7, 
FM hsf 2 13 


FM_hsf 2_3 , FM_hsf 2_4, FM_hsf2_5, FM_hsf2_ 
FM_hsf 2_8 , FM_hsf 2_9, FM_hsf2_10, FM_hsf2_ll, FM_hsf2_12, 

FM hsf 2 14, FM hsf2 15, FM hsf2 16, FM hsf2 17, FM hsf2 18, 


FM hfO, FM hfl, FM hf2, FM hf3 


M_u32** FM_structured_hexahedron_subf aces [4] 
FM hsfO, FM hsfl, FM hsf 2, FM hsf 3 


const FM_u32 FM_subtetrahedron_f ace [ 10] [4 ][ 3] = { 


/ / even hexahedron 
{{3, 6, 5], <3, 5, 

7], {3, 

7, 

6], 

{ 5 , 

6, 

7}} 

HO, 

. 3, 5], 

{0, 

1, 

3], 

<0, 

5, 

1), 

{1. 

5, 

3}} 

HO, 

. 6, 3), 

{0, 

3, 

2), 

{0, 

2, 

6], 

{2, 

3, 

6]} 

HO, 

. 5, 6], 

<0, 

4, 

5], 

{0, 

6, 

4), 

{4, 

6, 

5]} 

HO, 

. 5, 3}, 

{0, 

3, 

6], 

{0, 

6, 

5), 

{3, 

5, 

6}} 

/ / odd hexahedron 

HI, 4, 2), { 0 , 1, 

2], {0, 

2, 

4), 

{0, 

4, 

1}} 

{{1. 

, 2, 7), 

{1, 

3, 

2), 

{1- 

7, 

3], 

{2, 

3, 

7}} 

{{1. 

. 7, 4), 

{1. 

4, 

5], 

{1. 

5, 

7), 

{ 4 , 

7, 

5]} 

{{2, 

, 4, 7), 

{2, 

6, 

4), 

{2, 

7, 

6} , 

{4, 

6, 

7)} 

{{1. 

. 2, 4), 

{1. 

4, 

7], 

{1. 

7, 

2). 

{2, 

7, 

4)} 


7), 

{0, 

4, 

5, 

1), 

2], 

{5, 

4, 

6, 

7}} 

3), 

{1, 

0, 

4, 

5), 

0], 

{4, 

6, 

7, 

5]} 


const FM_u32 FM_hexahedron_f ace [ 2] [ 6] [4 ] = { 
// even hexahedron case 
{{0, 2, 6, 4), {3, 1, 5, 

{3, 7, 6, 2), {0, 1, 3, 

// odd hexahedron cases 
{{2, 6, 4, 0), {1, 5, 7, 

{ 2, 3, 7, 6), {1, 3, 2, 


struct FM_cell_step 
{ 

int dir; 

FM_u32 axis; 

FM_u32 subs implex; 
FM_u32 subs imp lex_f ace; 


const FM_cell_step FM_tetrahedron_step [ 10 ] [4] = { 
// even hexahedron cases 
{ // stepping from subtetrahedron 0 

< 0, 0, 4, 3), 

{ 1, 0, 8, 1), 

{ 1, 1, 7, 1), 

< 1 , 2 , 6 , 1 ) 

}. 

{ // stepping from subtetrahedron 1 
< 0, 


{- 1 , 

{ 1 . 


», o. 

4, 0), 

, 2, 

7. 3), 

, 1, 

6, 3), 

., 0, 

5, 2} 


// stepping from subtetrahedron 2 

< 0, 0, 4, 1), 

{-1, 2, 8, 3), 

{- 1 , 0 , 6 , 2 ), 

{ 1, 1, 5, 3) 

// stepping from subtetrahedron 3 
{ 0, 0, 4, 2), 

{-1, 1, 8, 2), 

{-1, 0, 7, 2), 

< 1, 2, 5, 1) 

// stepping from subtetrahedron 4 

< 0 , 0 , 1 , 0 ), 

{ 0 , 0 , 2 , 0 ), 

< 0, 0, 3, 0), 

{ 0, 0, 0, 0) 


). 


// odd hexahedron cases 
{ // stepping from subtetrahedron 5 
< 0, 0, 9, 0), 

{-1, 2, 3, 3), 

{-1, 0, 1, 3), 

{-1, 1, 2, 3} 

). 

{ // stepping from subtetrahedron 6 


< 0, 

{- 1 , 2 , 0 , 

{ 1 , 0 , 2 , 

{ 1, 1, 1, 


2 ), 

3), 

2 ), 

2} 


{ II stepping from subtetrahedron 7 


FM hsf2 19 

- 


- 


{-1 

1, 

0, 2), 

]; 







{ 1 

0, 

3, 2), 








{ 1 

2, 

1- 1] 

FM 

32 

FM hf3 0 [] 

= {0, 

1, 

2, 

3, 

5, 5, 6, 7); ), 



FM 

32 

FM hsf 3 0 [] 

= {3, 

6, 

5, 

7) 

{ // 

steppina from 

FM 

32 

FM hsf 3 1 [] 

= {0, 

3, 

5, 

1) 

{ o 

0, 

9, 3], 

FM 

32 

FM hsf 3 2 [] 

= {0, 

6, 

3, 

2] 

{-1 

0, 

0, 1), 

FM 

32 

FM hsf 3 3 [ ] 

= {0, 

5, 

6, 

4} 

{ 1 

1, 

3, 1), 

FM 

32 

FM hsf 3 4 [ ] 

= |0, 

5, 

3, 

6} 

{ 1 

2, 

2, 1} 

FM 

32 

FM hsf 3 5 [ ] 

= {1, 

4, 

2, 

0) 

), 



FM 

32 

FM hsf 3 6 [ ] 

= {1, 

2, 

7, 

3] 

{ // 

stepping from 

FM 

32 

FM hsf 3 7 [] 

= {1, 

7, 

4, 

5] 

{ 0 

0, 

5, 0], 

FM 

32 

FM hsf 3 8 [] 

= {2, 

4, 

7, 

6} 

{ 0 

0, 

7, 0), 

FM 

32 

FM hsf 3 9 [ ] 

= u. 

2, 

4, 

7] 

{ 0 

0, 

6, 0), 

FM 

32 

FM hf 3 [ = 

{FM hf 3 

0); 


{ 0 

0, 

8, 0) 

FM 

32 

FM hsf3[] 

= { 




} 




FM_h' 
FM h' 


f3_0, FM_hsf3_l, FM_hsf3_2, FM_hsf3_3, FM_hsf3_' 
f3 5, FM hsf3 6, FM hsf3 7, FM hsf3 8, FM hsf3 ! 


FM structured hexahedro: 


// Helper routines for FM_structured_mesh<B, D> : Most rout 


42 



// assist topological member functions such as faces () and adjacencies () . 

// These functions in general are dependent upon the base dimensionality B, 
// but not the physical_dimensionality D, thus they are templated only 
// by B rather than by both B and D. 

// 


template <int B> 

bool FM_simplicial_decomposition_odd (const FM_vector<B, FM_u32>& indices, 

FM_u32 simplicial_decomposition) 

{ 

bool res = FM_odd (indices) ; 

if (simplicial_decomposition == 2) res = Ires; 


template <int B, int D> 
class FM_structured_mesh; 


template <int B, int 
void FM_st ructured_m< 


{ 


D> 

jsh_init (FM_structured_mesh<B, D>* sm, 
const FM_vector<B, FM_u32>& d) 


const_cast<FM_vector<B, FM_u32>S> (sm->dimensions) = d; 


int i, j; 

for (i = 0; i < B; i44) { 

if (! (sm->dimensions [i] >1)) { 
FM_ostringstream err; 

err « , 'FM_structured_mesh< , ' « B « ">"; 
err « "::init(" « sm->dimensions « ") : "; 
err « "each dimension must be > 1"; 
throw std: : logic_error (err. str () ) ; 

) 

} 


for (i = 0; i <= B; i44) { 

FM_choose_choices<B> (FM_u32 (i) , &sm- alignments [i] ) ; 
std: : vector<FM_vector<B, bool> > : : const_iterator iter; 

for (iter = sm->alignments [ i] .begin () ; iter != sm->alignments[i] .end() ; 

44 iter ) { 

FM_u 6 4 card = 1; 

FM_ve ct o r <B , FM_u 3 2 > dims; 
for (j = 0; j < B; j44) { 

dims[j] = (*iter) [j] ? sm->dimensions [ j] - 1 : sm->dimensions [ j] ; 
card *= dims[j]; 

} 

sm->alignment_dimensions [ i] .push_back (dims) ; 

const_cast<std : : vector<FM_u64>&> (sm->alignment_cards [i] ) .push_back (card) ; 

) 

} 

const_cast<FM_u64&> (sm->cube_of fsets [0] ) = 0; 

FM_u64 offset = 1; 
for (i = 0; i < B; i44) { 
int n = FM_pow_2 (i) ; 
for (j = 0; j < n; j44) 

const_cast<FM_u64&> (sm->cube_of fsets [j 4 n] ) = 
sm->cube_of fsets [ j] 4 offset; 
offset *= sm->dimensions [i] ; 


std::cout « "FM_structured_mesh<" « B « ">(" 
« dimensions « "):" « std::endl; 
for (i = 0; i <= B; i44) { 

std::cout « "alignments!" « i « "]:”; 
for (j =0; j < alignments [i] . size () ; j44) 
std::cout « " " « alignments [ i] [ j ] ; 
std: : cout « std: :endl; 


FM_u64 index = sc->get_index (B - 1); 
for (int i = B - 2; i >= 0; i — ) 

index = index * alignment_dimensions [d] [a] [i] 4 sc->get_index (i) ; 
for (FM_u32 j = 0; j < a; j44) 
index 4= alignment_cards [d] [ j] ; 
return index; 


template <int B> 

FM_ptr<FM_cell> FM_st ructured_mesh_enum_to_cell 
(const std: : vector<FM_vector<B, bool> > alignments!], 
const std: : vector<FM_vector<B, FM_u32> > alignment_dimensions [ ] , 
const std: : vector <FM_u6 4 > alignment_cards [ ] , 

FM_u64 e, FM_u32 d, FM_u32, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) 

{ 

FM_u64 e_original = e; 

for (a =0; a < alignments [d] .size() ; a44) { 
if (e < alignment_cards [d] [a] ) break; 
e -= alignment_cards [d] [a] ; 

} 

if (a == alignments [d] . size () ) { 

FM_ostringstream err; 

err « "FM_structured_mesh<" « B « ", D>: : enum_to_cell (" « 
e_original « ", “ « d « ") : "; 
err « "bad argument"; 
throw std : : logic_error (err . str ( ) ) ; 

) 

FM_vector<B, FM_u64> strides; 
int i ; 

strides [0] = 1; 

for (i = 1; i < B; i44) 

stridesfi] = strides[i - 1] * alignment_dimensions [d] [a] [i - 1]; 
FM_vector<B, FM_u32> indices; 
for (i = B - 1; i > 0; i — ) { 
div_t d = div(e, strides[i]); 
indices [i] = d.quot; 
e = d.rem; 

} 

indices !0] = e; 

FM_cell* res = new FM_structured_k_cell<B> (d, a, indices); 
if (t) 

res->set_time (*t) ; 
if (sid) 

res->set_submesh_id(*sid) ; 
return res; 


template <int B> 

std: : vector<FM_ptr<FM_cell> > 

FM_structured_mesh_faces (const FM_vector<B, FM_u32>& dimensions, 

const std: : vector<FM_vector<B, bool> > alignments!], 
const FM_cell* c, FM_u32 k) 

< 

const FM_structured_cell<B>* sc = 

dynamic_cast<const FM_structured_cell<B>*> (c) ; 
assert (sc 1=0); 

FM_u32 d = sc->get_dimension () ; 

FM_u32 a = sc->get_alignment () ; 

std : : vector<FM_jptr<FM_cell> > cells; 

// g44 version 2.96 20000731 (Red Hat Linux 7.1 2.96-81) 

// crashes when compiling -03, do not use ref here: 

// const FM_vector<B,bool>6 alignment = alignments [d] [a] ; 
const FM_vector<B, bool> alignment = alignments [d] [a] ; 


std:: cout « "alignment_dimensions [ " « i « "]:"; 
for (j =0; j < alignments [i] . size () ; j44) 

std:: cout « " " « alignment_dimensions [i] [ j] ; 
std::cout « std::endl; 

std:: cout « "alignment_cards [ " « i « "]:"; 
for (j =0; j < alignments [i] . size () ; j44) 
std:: cout « " " « alignment_cards [i] [ j ] ; 
std::cout « std::endl; 

) 

std::cout « "cube_of fsets :" ; 
for (i = 0; i < 1 « B; i44) 

std:: cout « " " « cube_of fsets [i] ; 
std: : cout « std: :endl; 

7 


FM_u64 FM_structured_mesh_get_card(FM_u32 base_dimensionality, 

const std: : vector<FM_u64> alignment_cards [ ] , 
FM_u32 k) 

{ 

if (k > base_dimensionality ) return 0; 

FM_u64 card = 0; 

for (size_t j = 0; j < alignment_cards [k] .size(); j++) 
card 4= alignment_cards [k] [ j] ; 


template <int B> 

FM_u 64 FM_structured_mesh_cell_to_enum 

(const std: : vector<FM_vector<B, FM_u32> > alignment_d intensions [ ] , 
const std: : vector <FM_u 64 > alignment_cards [ ] , 
const FM_cell* c) 

{ 

const FM_structured_cell<B>* sc = 

dynamic_cast<const FM_structured_cell<B>*> (c) ; 

FM_u32 d = sc->get_dimension ( ) ; 

FM_u32 a = sc->get_alignment ( ) ; 


for (a =0; a < alignments [k] . size () ; a44) ] 
if (k > d) { 

if (I (alignment <= alignments [k] [a] ) ) 
continue; 

) 

else { 

if (! (alignment >= alignments [k] [a] ) ) 
continue; 

) 

FM_vector<B,bool> free_indices = alignment ' alignments [k] [a] ; 
FM_u32 n_candidates = FM_pow_2 (k > d ? k - d : d - k) ; 
for (FM_u32 i = 0; i < n_candidates; i44) { 
bool out_of_bounds = false; 

FM_vector<B, FM_u32> indices = sc->get_indices () ; 

FM_u32 f ree_index_mask = 1; 
for (int j = 0; j < B; j44) { 

if (free_indices [ j] ) { 
if (k > d) { 

if (i S free_index_mask) { 

out_of_bounds = indices [j] == 0; 
if ( !out_of_bounds) 

— indices [ j] ; 

} 

out_of_bounds = indices [j] >= dimensions [ j] - 1; 
if (out_of_bounds) break; 

} 

if (i& free_index_mask) 

44indices [ j] ; 

} 

f ree_index_mask «= 1; 

} 

) 

if (out_of_bounds) continue; 

cells ,push_back (new FM_structured_k_cell<B> (c->get_time () , 

c->get_submesh_id ( ) , 
k, a, indices) ) ; 


43 



cells; 


} 

return 


template <int B> 

std: : vector<FM_ptr<FM_cell> > 

FM_structured_mesh_ad jacencies (const FM_vector<B, FM_u32>S dimensions, 
const FM_structured_cell<B>* sc) 

{ 

assert (sc- >get_dimens ion () == B) ; 
assert ( ! sc ->is_subs implex ( ) ) ; 

std: : vector<FM_ptr<FM_cell> > adjacent_cells; 
for (int i = 0; i < B; i++) { 

FM_u32 hi = dimensions [i] - 2; 
if (sc->get_index (i) < hi) { 

FM_vector<B, FM_u32> indices = sc->get_indices ( ) ; 

++indices [i] ; 

ad jacent_cells .push_back (new FM_structured_B_cell<B> 

(sc->get_time () , sc->get_submesh_id() , 
indices) ) ; 


if (sc->get_index (i) >0) { 

FM_vector<B, FM_u32> indices = sc->get_indices ( ) ; 

— indices [i] ; 

adjacent_cells .push_back (new FM_structured_B_cell<B> 

(sc->get_time () , sc->get_submesh_id() , 
indices) ) ; 


template <int B> 

c las s FM_st ru ctu red_me sh_0_ce ll_ite r_imp 1 : 
public FM_structured_mesh_iter_impl<B> 

{ 

public : 

FM_st ructured_mesh_0_cell_iter_impl ( const 
FM_structured_mesh_iter_impl<B> (b, e, s) 

{ 

structured_0_cell = new FM_structured_0_ 

} 


FM_t ime<FM_u 32 >& time, 
FM_submesh_idS submesh_id, 
FM_vector<B, FM_u32>& b, 
FM_vector<B, FM_u32>& e, 
FM_vector<B, FM_u32>& s) : 


cell<B> (time, submesh_id, b) ; 


FM_structured_mesh_0_cell_iter_impl (const FM_structured_0_cell<B>* sc, 
const FM_vector<B, FM_u32>& b, 
const FM_vector<B, FM_u32>& e, 
const FM_vector<B, FM_u32>& s) : 

FM_structured_mesh_iter_impl<B> (b, e, s) , structured_0_cell (sc) { } 

virtual FM_iter_impl* copy() const 

{ 

return new FM_structured_mesh_0_cell_iter_impl (structured_0_cell, 

begin, end, stride) ; 


return ad jacent_cells; 

) 


template <int B> 

int FM_structured_mesh_base_to_cell (const FM_vector<B, FM_u32>S dimensions, 
const FM_base<B>& b, 

FM_ptr<FM_structured_B_cell<B> >* sc) 

{ 

FM_vector<B, FM_u32> indices; 
for (int i = 0; i < B; i++) { 

if (! (FM_coord(0) <= b[i] && b[i] <= FM_coord (dimensions [i] -1))) 
return FM_0UT_0F_B0UNDS; 
indices [i] = FM_u32 (b [i] ) ; 

if (indices [i] == dimensions [i] - 1) indices [i] — ; 

) 

FM_time<FM_u32> time; 

*sc = new FM_structured_B_cell<B> (time, b . submesh_id, indices); 
return FM_0K; 


template <int B, int D> 

int FM_structured_mesh_phys_to_subs implex 
(const FM_phys<D>& p, 

const FM_ptr<FM_structured_B_cell<B> >& sc, 
const FM_vector<D, FM_coord> [], 

FM_context*, FM_ptr<FM_cell>*) 

i 

FM_o st ring st ream err; 

err « ”FM_structured_mesh<" « B « ,, , ,, « D « 

"> : : phys_to_subsimplex (" « p « ”, " « *sc « ”, , ) : ” « 

"no simplicial decomposition”; 
throw std: : logic_error (err. str () ) ; 

) 

template <> 

int FM_structured_mesh_phys_to_subsimplex<3, 3> 

(const FM_phys<3>& p, 

const FM_ptr<FM_structured_B_cell<3> >& sc, 
const FM_vector<3, FM_coord> cv[], 

FM_context* ctxt, FM_ptr<FM_cell>* c) 

{ 

bool sdo = 

FM_simplicial_decomposition_odd<3>(sc->get_indices () , 

ctxt->simplicial_decomposition) ; 

FM_u32 subid = ! sdo ? 0 : 5; 
for (FM_u32 i = 0; i < 4; i++) { 
int orientation = 

FM_orient (cv[FM_subtetrahedron_face[ subid] [0] [0]], 
cv [FM_subtetrahedron_f ace [subid] [0] [1]], 
cv [FM_subtetrahedron_face [subid] [0] [2] ] , p) ; 
if (orientation > 0) 
break; 
subid++; 

) 

*c = new FM_structured_subsimplex<3> (sc->get_time () , sc->get_submesh_id () , 

3, subid, sc->get_indices () ) ; 

return FM_0K; 

} 


virtual const FM_cell* advance () 

{ 

if (structured_0_cell->get_reference_count () == 1) { 

FM_structured_0_cell<B>* sc = const_cast<FM_structured_0_cell<B>*> 
(static_cast<const FM_structured_0_cell<B>*> (structured_0_cell) ) ; 
for (int d = 0; d < B; d++) { 
sc->indices [d] += stride [d] ; 
if (sc->indices [d] < end[d]) 
return structured_0_cell; 
sc->indices [d] = begin [d]; 


else { 

FM_vector<B, FM_u32> indices = structured_0_cell->indices; 
for (int d = 0; d < B; d++) { 
indices [d] += stride[d]; 
if (indices [d] < end[d]) { 

return new FM_structured_0_cell<B> 
(structured_0_cell->get_time ( ) , 
structured_0_cell->get_submesh_id () , 
indices) ; 

} 

indices [d] = begin [d] ; 


return 0; 

} 


virtual const FM_cell* dereferenced const 

{ 

return structured_0_cell; 

) 

protected: 

FM_ptr<FM_structured_0_cell<B> > structured_0_cell; 

}; 


template <int B> 

class FM_structured_mesh_B_cell_iter_impl : 
public FM_structured_mesh_iter_impl<B> 


{ 

public : 

FM_structured_mesh_B_cell_iter_impl (const 
const 
const 
const 
const 

FM_structured_mesh_iter_impl<B> (b, e, s) 


{ 


FM_time<FM_u32>& time, 
FM_submesh_id& submesh_id, 
FM_vector<B, FM_u32>& b, 
FM_vector<B, FM_u32>& e, 
FM_vector<B, FM_u32>& s) : 


structured_B_cell = new FM_structured_B_cell<B> (time, submesh_id, b) ; 

} 


FM_structured_mesh_B_cell_iter_impl (const FM_structured_B_cell<B>* sc, 
const FM_vector<B, FM_u32>& b, 
const FM_vector<B, FM_u32>& e, 
const FM_vector<B, FM_u32>& s) : 

FM_structured_mesh_iter_impl<B> (b, e, s) , structured_B_cell (sc) {} 


// 

// The following are iterator implementations used when 
// constructing iterators for structured meshes. The particular 
// implementation choice depends on the type of iteration specified 
// by the iter_attrs argument to begin () . 

// 

template <int B> 

class FM_structured_mesh_iter_impl : public FM_iter_impl 

{ 

public : 

FM_structured_mesh_iter_impl (const FM_vector<B, FM_u32>& b, 
const FM_vector<B,FM_u32>& e, 
const FM_vector<B,FM_u32>& s) : 

begin (b) , 
end (e) , 
stride (s) 

{} 


protected: 

const FM_vector<B, FM_u32> begin, end, stride; 


virtual FM_iter_impl* copy() 

< 

return new FM_structured_m 

) 


const 

ssh_B_cell_iter_impl (structu 
begin, 


red_B_cell, 
end, stride) ; 


virtual const FM_cell* advanced 

{ 

if (structured_B_cell->get_reference_count () == 1) ( 

FM_structured_B_cell<B>* sc = const_cast<FM_structured_B_cell<B>*> 
(static_cast<const FM_structured_B_cell<B>*> (structured_B_cell) ) ; 
for (int d = 0; d < B; d4+) { 
sc->indices [d] += stride [d] ; 
if (sc->indices [d] < end[d]) 
return structured_B_cell; 
sc->indices [d] = begin [d] ; 


FM_vector<B, FM_u32> indices = structured_B_cell->indices; 
for (int d = 0; d < B; d++) { 


44 



indices [d] += stride [d] ; 
if (indices [d] < end[d]) { 

return new FM_structured_B_cell<B> 
(structured_B_cell->get_time () , 
st ructured_B_cell->get_submesh_id () , 

} 

indices [d] = begin [d] ; 


return 0; 

} 


FM_structured_mesh_iter_impl<B> (b, e, s) , 
simplicial_decomposition (sd) 

{ 

FM_u32 subid = 0; 

bool sdo = FM_simplicial_decomposition_odd (b, sd) ; 
if (d == 3) 

subid = sdo ? 5 : 0; 

subid = subid % 4 4 (sdo ? 2 : 0) ; 
structured_subsimplex = 

new FM_st ructured_subs imp lex<B> (time, submesh_id, d, subid, b) ; 


virtual const FM_cell* dereference () const 
return structured_B_cell; 

} 

protected: 

FM_ptr<FM_structured_B_cell<B> > structured_B_cell; 

) ; 


template <int B> 

class FM_structured_mesh_multi_alignment_iter_impl : public FM_iter_impl 

{ 

public : 

FM_s t r u c t u r ed_me s h_mu It i_a 1 i gnme nt_it e r _imp 1 

(const FM_time<FM_u32>& time, const FM_submesh_idS submesh_id, 

FM_u32 d, 

const std: : vector<FM_vector<B, FM_u32> >& e, 
const FM_vector<B, FM_u32>& s) : 
ends (e) , 
stride (s) 

{ 

FM_vector<B, FM_u32> indices; 
for (int i = 0; i < B; i++) 
indices [i] = 0; 
structured_k_cell = 

new FM_structured_k_cell<B> (time, submesh_id, d, 0, indices); 


FM_st r uctu red_mesh_mu It i_a lignment_it er_impl 
(const FM_structured_k_cell<B>* sc, 
const std: : vector<FM_vector<B, FM_u32> >& e, 
const FM_vector<B, FM_u32>& s) 
structured_k_cell (sc) , ends(e), stride (s) {} 

virtual FM_iter_impl* copy() const 

{ 

return new 

FM_structured_mesh_multi_alignment_iter_impl<B> (structured_k_cell, 


virtual const FM_cell* advance () 

{ 

FM_u32 d = structured_k_cell->get_dimension ( ) ; 

FM_u32 a = structured_k_cell->get_alignment ( ) ; 

FM_vector<B, FM_u32> indices = structured_k_cell->get_indices () ; 
int i; 

for (i = 0; i < B; i44) { 
indices [i] 4= stride [i]; 
if (indices [i] < ends [a] [ i] ) { 
structured_k_cell = 

new FM_structured_k_cell<B> (structured_k_cell->get_time () , 

st ru ct ur ed_k_ce 11 ->get_s ubme sh_id ( ) , 
d, a, indices); 

return structured_k_cell; 

) 

indices [i] = 0; 

) 

a 4= 1; 

if (a == ends, size ()) 
return 0; 

for (i = 0; i < B; i44) 
indices [d] = 0; 

structured_k_cell = 

new FM_structured_k_cell<B> (structured_k_cell->get_time () , 

structured_k_cell->get_submesh_id () , 
d, a, indices) ; 

return structured_k_cell; 

) 

virtual const FM_cell* dereferenced const 

{ 

return structured_k_cell; 

} 

protected: 

FM_ptr<FM_structured_k_cell<B> > structured_k_cell; 
const std : : vector<FM_vector<B, FM_u32> > ends; 

FM_vector<B, FM_u32> stride; 


FM_st ruct ur ed_me sh_sub simplex_ite r_imp 1 
(const FM_structured_subsimplex<B>* ss, 
const FM_vector<B, FM_u32>& b, 
const FM_vector<B, FM_u32>& e, 
const FM_vector<B, FM_u32>& s, 

FM_u32 sd) : 

FM_structured_mesh_iter_impl<B> (b, e, s) , 
structured_subsimplex (ss) , 
simplicial_decomposition (sd) 

{} 

virtual FM_iter_impl* copy() const 

{ 

return new 

FM_st ruct ur ed_mesh_sub simp lex_ite r_imp 1 ( st ru ct u red_subs imp lex , 

begin, end, stride, 
simplicial_decomposition) ; 


virtual const FM_cell* advanced 

{ 

FM_u32 d = structured_subsimplex->get_dimension () ; 

FM_u32 subid = structured_subsimplex->get_subid () ; 

FM_vector<B, FM_u32> indices = structured_subsimplex->get_indices ( ) ; 

subid 4= 1; 
if (d == 3) ( 

if (! (subid == 5 | | subid == 10) ) { 
structured_sub simp lex = 

new FM_structured_subsimplex<B> 

(structured_subsimplex->get_time () , 
structured_subsimplex->get_submesh_id () , 
d, subid, indices) ; 
return structured_subsimplex; 

) 

} 

else { 

assert (d == 2) ; 
if (! (subid % 2 == 0)) { 
structured_subsimplex = 

new FM_structured_subsimplex<B> 

(structured_subsimplex->get_time ( ) , 
structured_subsimplex->get_submesh_id () , 
d, subid, indices) ; 
return structured_subsimplex; 

) 

) 

int i ; 

for (i = 0; i < B; i44) { 
indices [i] 4= stride [i]; 
if (indices [i] < end[i]) 
break ; 

indices [i] = begin [i]; 

} 

if (i == B) 
return 0; 

bool sdo = FM_simplicial_decomposition_odd( indices, 

simplicial_decomposition) ; 

if (d == 3) 

subid = sdo ? 5 : 0; 
else 

subid = subid % 4 4 (sdo ? 2 : 0) ; 

structured_subsimplex = 

new FM_structured_subsimplex<B> 

(structured_subsimplex->get_time ( ) , 
structured_subsimplex->get_submesh_id () , 
d, subid, indices) ; 
return structured_subsimplex; 


virtual const FM_cell* dereference () const 

< 

return structured_subsimplex; 

) 

protected: 

FM__pt r<FM_st ruct ured_subs implex<B> > st ruct ured_sub simp lex; 
const FM_u32 simplicial_decomposition; 

) ; 


template <int B> 

class FM_structured_mesh_subsimplex_iter_impl : 
public FM_structured_mesh_iter_impl<B> 

{ 

public : 

FM_structured_mesh_subsimplex_iter_impl (const FM_time<FM_u32>& time, 

const FM_submesh_id& submesh_id, 
FM_u32 d, 

const FM_vector<B, FM_u32>& b, 
const FM_vector<B, FM_u32>& e, 
const FM_vector<B, FM_u32>& s, 
FM_u32 sd) : 


template <int B> 

FM_iter FM_structured_mesh_begin 

(const std: : vector<FM_vector<B, FM_u32> > alignment_dimensions [ ] 
const FM_iter_attrs& ia) 

int i; 

// set defaults 
FM_time<FM_u32> time; 

FM_submesh_id submesh_id; 

FM_u32 simplicial_decomposition = 0; 

FM_u32 cell_dimension = 0; 

FM_cell_type_enum cell_type = FM_VERTEX_CELL; 


45 



//bool cell_alignment_given = false; 

FM_u32 cell_alignment = 0; 

FM_vector<B, FM_u32> begin_indices; 
for (i = 0; i < B; i++) 
be gin_in dices [i] = 0; 

FM_vector<B, FM_u32> strides; 
for (i = 0; i < B; i++) 
strides [i] = 1; 

FM_vector<B, FM_u32> end_indices; 

// cell_type and end_indices can be implied by other parameters 
FM_vector<B, bool> end_indices_given; 
for (i = 0; i < B; i++) 

end_indices_given [i] = false; 
bool cell_type_given = false; 

int n_ignored = 0 ; 

FM_iter_attrs : : const_iterator iter; 
for (iter = ia.beginO; iter != ia.endO; ++iter) { 
const FM_iter_attr* it = *iter; 
switch (it->attr) { 
case FM_ITER_ATTR_TIME: 

time = dynamic_cast<const FM_time_iter_attr*> (it) ->time; 
break; 

case FM_ITER_ATTR_SUBMESH_ID: 
submesh_id = 

dynamic_cast<const FM_submesh_id_iter_attr*> (it) ->submesh_id; 
break; 

case FM_I TE R_ATT R_CE LL_D I MEN SION : 
cell_dimension = 

dynamic_cast<const FM_cell_dimension_iter_attr*> (it ) ->cell_dimension; 
break; 

case FM_ITER_ATTR_CELL_TYPE: 
cell_type = 

dynamic_cast<const FM_cell_type_iter_attr*> (it) ->cell_type; 
cell_type_given = true; 
break; 

ca se FM_I TE R_ATT R_AX I S_BEGI N : 

{ 

const FM_axis_begin_iter_attr* axis_begin_iter_attr = 
dynamic_cast<const FM_axis_begin_iter_attr*> (it) ; 
assert (axis_begin_iter_attr->axis < B) ; 
begin_indices [axis_begin_iter_attr->axis] = 
ax i s_be gi n_ite r_at t r -> index ; 

) 

break; 

case FM_I TE R_ATT R_AX I S_END : 

{ 

const FM_axis_end_iter_attr* axis_end_iter_attr = 
dynamic_cast<const FM_axis_end_iter_attr*> (it) ; 
assert (axis_end_iter_attr->axis < B) ; 
end_indices [axis_end_iter_attr->axis] = 
axis_end_iter_attr->index; 

} 

break; 

ca se FM_I TER_ATTR_AXI S_STRI DE : 

< 

const FM_axis_stride_iter_attr* axis_stride_iter_attr = 
dynamic_cast<const FM_axis_stride_iter_attr*> (it) ; 
assert (axis_stride_iter_attr->axis < B) ; 
strides [axis_stride_iter_attr->axis] = 
axi s_st r ide_it er_att r- >st ride ; 

) 

break; 

case FM_I TE R_ATTR_SI MP LIC IAL_DEC0MP0 SI TI ON : 
simplicial_decomposition = 

dynamic_cast<const FM_simplicial_decomposition_iter_attr*> (it) -> 
simplicial_decomposition; 
break; 
default : 

n_ignored++; 

) 

) 

// cell_type trumps cell_dimension 
if (cell_type_given) { 

cell_dimension = FM_cell_type_to_dimension (cell_type) ; 
if (cell_type == FM_TRIANGLE_CELL | | 

cell_type == FM_TETRAHEDRON_CELL S6 
simplicial_decomposition == 0) 
simplicial_decomposition = 1; 

) 


} 

// else if (cell_alignment_given) { 

//} 

ii = new FM_structured_mesh_multi_alignment_iter_impl<B> 
(time, submesh_id, cell_dimension, 
alignment_dimensions [ cell_dimension] , strides) ; 



return FM_iter(ii); 

} 


template <int B, int D> 

FM_ptr<FM_shared_ob ject > 

FM_structured_mesh_get_aux (const FM_structured_mesh<B, D>* sm, 

const std: : strings key, FM u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) 

{ 

if (key == ,, base_dimensions") { 

std: : vector<FM_ptr<FM_shared_ob ject> > values (B); 
for (FM_u32 i = 0; i < B; i++) 

values [i] = new FM_simple_value<FM_u32> (sm->dimensions [i] ) ; 
return new FM_tuple_value (values) ; 

} 

else if (key == ” cards” ) { 

std: : vector<FM_ptr<FM_shared_ob ject> > values (B + 1); 
for (FM_u32 i = 0; i <= B; i++) 

values[i] = new FM_simple_value<FM_u64> (sm->get_card (i, 0, t, sid)); 
return new FM_tuple_value (values) ; 

J 

return sm->FM_mesh<B,D>: :get_aux (key, pass, t, sid) ; 


template <int B, int D> 
std: :set<std: :string> 

FM_structured_mesh_get_property_names_aux (const FM_structured_mesh<B, D>* sm, 

std: : set<std: : string>S names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) 

{ 

names . insert (”base_dimensions”) ; 

names . insert ("cards”) ; 

return sm->FM_mesh<B,D>: :get_property_names_aux (names, t, sid) ; 

) 


// 

// The generic FM_structured_mesh<B, D> declaration: 

// 

template <int B, int D> 

class FM_structured_mesh : public FM_mesh<B,D> 

< 

public : 

const FM_vector<B, FM_u32> dimensions; 
protected: 

void in it (const FM_vector<B, FM_u32>& d) 

< 

FM_structured_mesh_init (this, d) ; 

) 

FM_structured_mesh (FM_properties_cache* pc) : 

FM_mesh<B, D> (pc) 

{} 

FM_structured_mesh (const FM_vector<B, FM_u32>& d, 

FM_properties_cache* pc) : 

FM_mesh<B, D> (pc) , 
dimensions (d) 

{ 

init (dimensions) ; 

) 

public : 

virtual FM_u64 

get_card (FM_u32 k, FM_u32 = 0, const FM_time<FM_u32>* = 0, 
const FM_submesh_id* = 0) const 

{ 

return FM_structured_mesh_get_card(FM_u32 (B) , alignment_cards, k) ; 

} 


for (i = 0; i < B; i++) { 
if ( ! end_indices_given [i] ) 
end_indices [i] = 

alignment_dimensions [cell_dimension] [cell_alignment] [i]; 

} 


virtual FM_vector<B, FM_u32> 
get_base_dimensions ( const FM_time<FM_u32 : 
const FM_submesh_id* 




return dimensions; 


•* = 0, 

= 0) const 


// simplicial decomposition only supported for cells of dimension 2 or 3 
if ( ! (cell_dimension == 2 | | cell_dimension == 3)) 
simplicial_decomposition = 0; 

// construct impl 
FM_i t e r_imp 1 * i i ; 
if (simplicial_decomposition) 


virtual bool 

get_structured_behavior (const FM_time<FM_u32>* 
const FM_submesh_id* = 


{ 


return true; 

} 


= 0 , 

0) const 


new FM_structured_mesh_subsimplex_iter_impl<B> (time, submesh_id, 

cell_dimension, 
begin_indices, 
end_indices, strides, 
simplicial_decomposition) ; 

if (cell_dimension == 0) { 

ii = new FM_structured_mesh_0_cell_iter_impl<B> 

(time, submesh_id, begin_indices, end_indices, strides) ; 

} 

else if (cell_dimension == B) { 

ii = new FM_structured_mesh_B_cell_iter_impl<B> 

(time, submesh_id, begin_indices, end_indices, strides) ; 


virtual FM_u64 cell_to_enum (const FM_cell* c) const 

{ 


return FM_structured_mesh_cell_to_enum (alignment_dimensions, 

alignment_cards, c) ; 


virtual FM_ptr<FM_cell> 

enum_to_cell (FM_u64 e, FM_u32 d, FM_u32 sd = 0, 
const FM_time<FM_u32>* t = 0, 
const FM_submesh_id* sid = 0) const 

{ 

return FM_structured_mesh_enum_to_cell (alignments, alignment_dimensions, 

alignment_cards, e, d, sd, t, sid) ; 


46 



0 , 


} 

virtual std: : vector<FM_ptr<FM_cell> > 
faces (const FM_cell* c, FM_u32 k) const 
{ 


return FM_structured_mesh_f aces (dimensions, 

} 


alignments, 


c, k) ; 


virtual std: : vector<FM_ptr<FM_cell> > 
ad jacencies (const FM_cell* c) const 

const FM_structured_cell<B>* sc = 

dynamic_cast<const FM_structured_cell<B>*> (c) ; 
if (sc == 0) 

FM_throw_bad_cell_argument (this, "adjacencies", c) ; 
return FM_structured_mesh_adjacencies (dimensions, sc) ; 


virtual 

{ 


int 

cell (const FM_base<B>& b, 

FM_ptr<FM_structured_B_cell<B> 


return FM_structured_mesh_base_to_cell (dimensions, 

} 


b, sc) ; 


get_card (FM_u32 k, FM_u32 sd = 0, const FM_time<FM_u32>* ■ 
const FM_submesh_id* sid = 0) const 

{ 

FM_u64 card = FM_structured_mesh_get_card (3, alignment_ 
II sd == 2) { 


{ 


if (sd 

switch (k) 

card += get_ 

card *= 2; 
card += 4 * 
break ; 

default : 
abort () ; 


get_card(3, 0, t, sid) ; 


return card; 

J 


virtual int 

phys_to_cell (const FM_phys<D>6 p, FM_context* ctxt, FM_ptr<FM_cell>* c) const 

{ 

FM_base<B> b; 

FM_ptr<FM_structured_B_cell<B> > sc; 
int res = phys_to_base (p, ctxt, Sb, Ssc) ; 

*c = sc; 
return res; 

} 

virtual int 

phys_to_sub simp lex (const FM_phys<D>& p, 

const FM_ptr<FM_structured_B_cell<B> >& sc, 

FM_context* ctxt, FM_ptr<FM_cell>* c) const 

i 

FM_vector<D, FM_coord> cv[l « B]; 
int res = at_cell(sc, cv) ; 
if (res ! = FM_0K ) 
return res; 

return FM_structured_mesh_phys_to_subsimplex (p, sc, cv, ctxt, c) ; 


virtual FM_iter begin () const 

{ 

FM_iter_attrs iter_attrs; 
return begin (iter_attrs); 


virtual FM_vector<3, EW_u32> 

get_base_dimensions (const FM_time<FM_u32>* = 
const FM_submesh_id* = 0) 


{ 


return dimensions; 

} 


0 , 

I const 


virtual bool 

get_structured_behavior (const FM_time<FM_u32>* 
const FM submesh id* = 


{ 


return true; 

} 


= 0 , 

0) const 


virtual FM_u64 cell_to_en urn (const FM_cell* c) const 

{ 


return FM structured mesh cell to 


snum (alignment_dimensions, 
alignment_cards, c) ; 


virtual FM_ptr<FM_cell> 

enum_to_cell (FM_u64 e, FM_u32 d, FM_u32 sd = 0, 

const FM_time<FM_u32>* t = 0, const FM_submesh_id* 


< 


sid 


0) const 


} 


return FM_structured_mesh_enum_to_cell (alignments, alignment_dimensions, 

alignment_cards, e, d, sd, t, sid) ; 


virtual FM_iter begin (const FM_iter_attrs& ia) const 

{ 

return FM_structured_mesh_begin (alignment_dimensions, ia) ; 

} 

virtual FM_ptr<FM_shared_ob ject> 

get_aux (const std: : strings key, FM_u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) const 

i 

return FM_structured_mesh_get_aux (this, key, pass, t, sid); 

) 

virtual std : : set<std : : string> 

get_property_names_aux (std : : set<std : : string>& names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) const 

{ 

return FM_structured_mesh_get_property_names_aux (this, names, t, sid); 

) 

FM_u64 cube_of fsets [ 1 « B] ; 

std: : vector<FM_vector<B, bool> > alignments [B + 1] ; 

std: : vector<FM_vector<B, FM_u32> > alignment_dimensions [B + 1] ; 

std: :vector<FM_u64> alignment_cards [B + 1]; 


// 

1 1 The FM_structured_mesh<3, D> partial specialization: This 

// specialization contains the extra code needed to handle 
// simplicial decomposition for meshes with base dimensionality 3. 

// 

template <int D> 

class FM_structured_mesh<3, D> : public FM_mesh<3,D> 

{ 

public : 

const FM_vector<3, FM_u32> dimensions; 
protected: 

void init (const FM_vector<3, FM_u32>& d) 

{ 

FM_structured_mesh_init (this, d) ; 

} 

FM_structured_mesh (FM_properties_cache* pc) : 

FM_mesh<3, D> (pc) 

{} 

FM_structured_mesh (const FM_vector<3, FM_u32>& d, FM_properties_cache* pc) 
FM_mesh<3, D> (pc) , 
dimensions (d) 

{ 

init (dimensions) ; 


virtual std : : vector<ET4_ptr<FM_cell> > 
faces (const FM_cell* c, FM_u32 k) const 
< 

return FM_structured_mesh_f aces (dimensions, alignments, c, k) ; 

) 

virtual std : : vector<ET4_ptr<FM_cell> > 
adjacencies (const FM_cell* c) const 
< 

const FM_structured_cell<3>* sc = 

dynamic_cast<const FM_structured_cell<3>*> (c) ; 
if (sc == 0) 

FM_throw_bad_cell_argument (this, "adjacencies", c) ; 
if ( ! sc->is_subsimplex () ) 

return FM_structured_mesh_ad jacencies (dimensions, sc) ; 

std : : vector<FM_ptr<FM_cell> > ad jacent_cells; 
for (int i = 0; i < 4; i++) { 

FM_cell_step cell_step = FM_tetrahedron_step [sc->get_subid ( ) ] [ i] ; 
FM_vector<3, FM_u32> indices; 
switch (cell_step .dir) { 
case -1 : 

if (sc->get_index (cell_step .axis) >0) ( 
indices = sc->get_indices () ; 
indices [cell_step. axis] -= 1; 
adjacent_cells .push_back 

(new FM_structured_subsimplex<3> (sc->get_time () , 

sc->get_submesh_id ( ) , 3, 
cell_step. subsimplex, 
indices) ) ; 

) 

break ; 
case 0 : 

ad jacent_cells .push_back 

(new FM_structured_subsimplex<3> (sc->get_time () , 

sc->get_submesh_id () , 3, 
cell_step . subsimplex, 
sc->get_indices () ) ) ; 

break; 

if (sc->get_index (cell_step .axis) < dimensions [cel l_step . axis] - 2) { 
indices = sc->get_indices () ; 
indices [cell_step. axis] += 1; 
ad jacent_cells .push_back 

(new FM_structured_subsimplex<3> (sc->get_time () , 

sc->get_submesh_id ( ) , 3, 
cell_step. subsimplex, 
indices) ) ; 

} 

default : 
abort () ; 


public : 

virtual FM u64 


return ad jacent_cells; 


47 



virtual 

{ 

returi 

} 


int 

cell (const FM_base<3>& b, 

FM_ptr<FM_structured_B_cell<3> >* sc) const 

1 FM_structured_mesh_base_to_cell (dimensions, b, sc) ; 


const FM_structured_mesh<3 / 3>* sm = 

reinterpret_cast<const FM_structured_mesh<3, 3>*>(m) ; 

FM_u64 index = indices[2] * sm->dimensions [0 ] * sm->dimensions [1] + 
indices [1] * sm->dimensions [ 0] + indices [0]; 
for (FM_u32 i = 0/ i < *n_ind; i++) 

ind[i] = index + sm->cube_of f sets [ vi [i ] ] ; 

) 


virtual int 

phys_to_cell (const FM_phys<D>& p, FM_context* ctxt, FM_ptr<FM_cell>* c) const 

{ 

FM_base<3> b; 

FM_ptr<FM_structured_B_cell<3> > sc; 
int res = phys_to_base (p, ctxt, Sb, Ssc) ; 



virtual int 

phys_to_sub simp lex (const FM_phys<D>& p, 

const FM_ptr<FM_structured_B_cell<3> >S sc, 
FM_context* ctxt, FM_ptr<FM_cell>* c) const 

{ 

FM_vector<D, FM_coord> cv[l « 3]; 
int res = at_cell(sc, cv) ; 
if (res ! = FM_0K ) 
return res; 

return FM_structured_mesh_phys_to_subsimplex (p, sc, cv, ctxt, c) ; 


virtual FM_iter begin () const 

{ 

FM_iter_attrs iter_attrs; 
return begin (iter_attrs) ; 

} 

virtual FM_iter begin (const FM_iter_attrs& ia) const 

return FM_structured_mesh_begin (alignment_dimensions, ia) ; 

) 

virtual FM_ptr<FM_shared_ob ject> 

get_aux (const std: : strings key, FM_u32 pass, 

const FM_time<FM_u32>* t, const FM_submesh_id* sid) const 

{ 

return FM_structured_mesh_get_aux (this, key, pass, t, sid); 

) 

virtual std : : set<std : : string> 

get_property_names_aux (std: : set<std: : string>& names, 
const FM_time<FM_u32>* t, 
const FM_submesh_id* sid) const 

< 

return FM_structured_mesh_get_property_names_aux (this, names, t, sid) ; 

} 


template <int B> 

void FM_structured_0_cell<B>: : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n_ind, 
FM_u64 ind[]) const 

{ 

*n_ind = 1; 

const FM_structured_mesh<B, B>* sm = 

reinterpret_cast<const FM_structured_mesh<B, B>*> (m) ; 

FM_u64 index = indices [B - 1]; 
for (int i = B - 2; i >= 0; i — ) { 
index *= sra->dimensions [i] ; 
index += indices [i]; 

} 

ind[0] = index; 


template <> 

void FM_structured_0_cell<l>: : 

structured_mesh_vertex_indices (const FM_mesh_*, FM_u32* n_ind, 
FM_u64 ind[]) const 

{ 

*n_ind = 1; 

ind[0] = indices [0]; 


template <> 

void FM_structured_0_cell<2>: : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n_ind, 
FM_u64 ind[]) const 

< 

*n_ind = 1; 

const FM_structured_mesh<2, 2>* sm = 

reinterpret_cast<const FM_structured_mesh<2, 2>*>(m) ; 
ind[0] = indices [1] * sm->dimensions [0] + indices [0]; 


template <> 

void FM_structured_0_cell<3>: : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n_ind, 
FM_u64 ind[]) const 

< 

*n_ind = 1; 

const FM_structured_mesh<3, 3>* sm = 

reinterpret_cast<const FM_structured_mesh<3, 3>*>(m) ; 
ind[0] = indices[2] * sm->dimensions [ 0] * sm->dimensions [1 ] + 
indices [1] * sm->dimensions [ 0] + indices [0]; 


FM_u64 cube_of fsets [ 1 « 3]; 

std: : vector<FM_vector<3, bool> > alignments [3 + 1] ; 

std: : vector<FM_vector<3, FM_u32> > alignment_dimensions [3 + 1] ; 

std: : vector<FM_u64> alignment_cards [3 + 1]; 


II 

// The following member function definitions for structured_cell subclasses 
// specify the cell's role in computing linear indices in association 
// with a structured_mesh . We provide optimized specializations for the 
// base dimensionalities that are most common. 

// 


template <int B> 

void FM_structured_k_cell<B> : : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n_ind, 

FM_u64 ind[]) const 

{ 

const FM_u32* vi = FM_structured_hexahedron_faces [dimension] [alignment] ; 

*n_ind = FM_pow_2 (dimension) ; 

const FM_structured_mesh<B, B>* sm = 

reinterpret_cast<const FM_structured_mesh<B, B>*> (m) ; 

FM_u64 index = indices [B - 1] ; 

for (int i = B - 2; i >= 0; i — ) { 
index * = sm->dimensions[i] ; 
index += indices [i]; 

} 

for (FM_u32 i = 0; i < *n_ind; i++) 

ind[i] = index + sm->cube_of fsets [vi[i]]; 


template <> 

void FM_structured_k_cell<2> : : 
structured_mesh_vertex_indices (const FM_mesh 
FM_u64 ind[]) 


{ 


* m, FM_u32* 


n_ind. 


const FM_u32* vi = FM_structured_hexahedron_f aces [dimension] [alignment] ; 
*n_ind = FM_pow_2 (dimension) ; 
const FM_structured_mesh<2, 2>* sm = 

reinterpret_cast<const FM_structured_mesh<2, 2>*>(m) ; 

FM_u64 index = indices [1] * sm->d intensions [0 ] + indices [0]; 
for (FM_u32 i = 0; i < *n_ind; i++) 

ind[i] = index + sm->cube_of fsets [vi[i]]; 


template <> 

void FM_structured_k_cell<3> : : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n 
FM_u64 ind[]) const 

{ 

const FM_u32* vi = FM_structured_hexahedron_f aces [dimens ii 
*n_ind = FM_pow_2 (dimension) ; 




i] [alignment]; 


template <int B> 

void FM_structured_B_cell<B> : : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n_ind, 
FM_u64 ind[]) const 

*n_ind = FM_pow_2(B); 

const FM_structured_mesh<B, B>* sm = 

reinterpret_cast<const FM_structured_mesh<B, B>*> (m) ; 

FM_u64 index = indices [B - 1]; 

for (int i = B - 2; i >= 0; i--) { 
index *= sm->dimensions [i] ; 
index += indices [i]; 

} 

for (FM_u32 i = 0; i < *n_ind; i++) 
ind[i] = index + sm->cube_of fsets [ i] ; 


template <> 

void FM_structured_B_cell<3>: : 

structured_mesh_vertex_indices (const FM_mesh_* m, FM_u32* n_ind, 
FM_u64 ind[]) const 

{ 

*n_ind = 8; 

const FM_structured_mesh<3, 3>* sm = 

reinterpret_cast<const FM_structured_mesh<3, 3>*>(m) ; 

FM_u64 index = indices[2] * sm->dimensions [0] * sm->dimensions [1] + 
indices [1] * sm->dimensions [ 0] + indices [0]; 

for (FM_u32 i = 0; i < 8; i++) 

ind[i] = index + sm->cube_of fsets [ i] ; 


template <int B> 

void FM_structured_subsimplex<B> : : 

structured_mesh_vertex_indices (const FM_mesh_*, FM_u32* n_ind, FM_u64[]) const 

{ 

*n_ind = 0; 

} 


template <> 

void FM_structured_subsimplex<2> : : 
structured_mesh_vertex_indices (const FM_mesh 
FM_u64 ind[]) 




i, FM_u32* 
ist 




const FM_u32* vi = FM_structured_hexahedron_subfaces [dimension] [subid]; 

*n_ind = dimension + 1 ; 

const FM_structured_mesh<2, 2>* sm = 

reinterpret_cast<const FM_structured_mesh<2, 2>*> (m) ; 

FM_u64 index = indices[l] * sm->dimensions [0 ] + indices [0]; 
for (FM_u32 i = 0; i < *n_ind; i++) 

ind[i] = index + sm->cube_of fsets [vi [i] ] ; 


48 



template <> 
void FM_stn 
st ructured_r 

< 


ictured_subsimplex<3> : : 

iesh_vertex_indices (const FM_mesh_* m, FM_u32* 
FM_u64 ind[]) const 




const FM_u32* vi = FM_structured_hexahedron_sub faces [dimension] [subid] ; 

*n_ind = dimension + 1; 

const FM_structured_mesh<3, 3>* sm = 

reinterpret_cast<const FM_structured_mesh<3, 3>*>(m) ; 

FM_u64 index = indices[2] * sm->dimensions [0 ] * sm->dimensions [1] + 
indices[l] * sm->dimensions [ 0] + indices [0]; 
for (FM_u32 i = 0 ; i < *n_ind; i++) 

ind[i] = index + sm->cube_of f sets [vi [i] ] ; 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_SUBMESH_ID_H_ 

♦define _FM_SUBMESH_ID_H_ 

/* 

* NAME : FM_submesh_id . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include <iostream> 

♦include <stdexcept> 

♦include "FM_types . h ” 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software”) , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


class FM_submesh_id 

< 

public : 

FM_submesh_id ( ) : id ( -1 ) { ) 

FM_submesh_id(int i) : id(i) {) 

FM_submesh_id(FM_u32 i) : id(int(i)) {) 

void set (FM_u32 i) { id = int(i); ) 

inline bool defined () const { return id != -1; ) 

friend std: :ost reams operator« (std: :ostreamS o, const FM_submesh_idS s) 

{ 

if (s .defined () ) 
o « s.id; 
else 

o « ”<submesh_id undefined>”; 
return o; 


friend bool operator== (const FM_submesh_idS lhs, const FM_submesh_idS rhs) 

{ 

return lhs. id == rhs. id; 

} 

friend bool operator< (const FM_submesh_idS lhs, const FM_submesh_idS rhs) 

{ 

return lhs. id < rhs. id; 

J 

FM_u32 index () const 

{ 

if ( ! defined ( ) ) 

throw std :: logic_error ("attempting to access undefined submesh_id") ; 
return FM_u32 (id) ; 

} 


private : 
int id; 

} # 

bool operator != (const FM_submesh_ids lhs, const FM_submesh_ids rhs) 

< 

return ! (lhs == rhs) ; 

) 

/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS”, WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


49 



// Emacs mode -*-c++-*- // 

#ifndef _FM_T I ME_H_ 

#def ine _FM_T I ME_H_ 

/* 

* NAME: FM_t ime . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

♦include <iostream> 

♦include "FM_types . h" 


template <typename T> 
class FM_t ime 
{ 

public : 

FM_time() : value (undefined_value) {) 

FM_t ime ( T t) : value (t) {} 

T& operator= (const T& t) { value = t; } 

T get () const 
{ 

if (! defined ()) 

throw std :: logic_error ("attempting to access undefined time"); 
return value; 

} 

void set (T t) { value = t; ) 

void set_undef ined () { value = undefined_value; } 

inline bool defined () const { return value != undef ined_value; ) 

friend bool operator== (const FM_time& lhs, const FM_time& rhs) 

{ 

return lhs. value == rhs. value; 

} 

friend bool operator != (const FM_time& lhs, const FM_time& rhs) 

{ 

return lhs. value != rhs. value; 

) 

friend bool operator< (const FM_time& lhs, const FM_time& rhs) 

< 

return lhs. value < rhs. value; 

} 

T value; 

static const T undef ined_value; 

} ; 


template <typename T> 

const T FM_time<T> : : undefined_value = T(-le30); 
template <> 

const FM_u32 FM_time<FM_u32> : : undef ined_value = OxFFFFFFFF; 


template <typename T> 

std: :ost reams operator« (std: : ost reams lhs, const FM_time<T>S rhs) 
{ 

if (rhs . defined () ) 

return lhs « rhs.getO; 
else 

return lhs « "<time undef ined>"; 

) 


// Emacs mode — *— C++— *— // 

♦ifndef _FM_T IMER_H_ 

♦define _FM_T IMER_H_ 

/* 

* NAME : FM_t imer . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas . nasa . gov 

*/ 

♦include <sys/time.h> 

class FM_timer 

{ 

public : 

FM_timer() { reset (); ) 
void reset () ( total =0.0; } 

void start () { gettimeofday (Sstart_tv, (struct timezone 
void stop() 

{ 

struct timeval stop_tv; 

gettimeofday (Sstop_tv, (struct timezone *) 0); 
long dts = stop_tv. tv_sec - start_tv. tv_sec; 
long dtus = stop_tv.tv_usec - start_tv.tv_usec; 
double dt = (double) dts + (double) dtus * 1.0e-6; 

// round to milliseconds 

long millisec = (long) (dt * 1000.0 + 0.5); 
total += millisec * 1000.0; 

} 

double elapsed () { return total; ) 
private: 

struct timeval start_tv; 
double total; 

); 

/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

♦endif 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

♦endif 


50 



// Emacs mode -*-c++-*- // 

#ifndef _FM_TYPES_H_ 

#def ine _FM_TYPES_H_ 

/* 

* NAME: FM_t ype s . h 

* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tifndef FM_COORD 
#def ine FM_COORD 
typedef float FM_coord; 
tendif 

typedef unsigned short FM_ul6; 
typedef unsigned FM_u32; 
typedef unsigned long long FM_u64; 

struct FM_true_type {}; 
struct FM_false_type {); 

template <int N, typename T> class FM_vector; 

template <typename T> 
struct FM_traits 
{ 

typedef T element_type; 
typedef FM_false_type is_scalar; 

} ! 

template <> 

struct FM_traits<char> 

{ 

typedef char element_type; 
typedef FM_true_type is_scalar; 

) ; 

template <> 

struct FM_traits<unsigned char> 

{ 

typedef unsigned char element_type; 
typedef FM_true_type is_scalar; 

} 

template <> 

struct FM_traits<short> 

< 

typedef short element_type; 
typedef FM_true_type is_scalar; 

} : 

template <> 

struct FM_traits<unsigned short> 

< 

typedef unsigned short element_type; 
typedef FM_true_type is_scalar; 

} ; 

template <> 

struct FM_traits<int> 

{ 

typedef int element_type; 
typedef FM_true_type is_scalar; 

} ; 

template <> 

struct FM_traits<unsigned int> 

{ 

typedef unsigned int element_type; 
typedef FM_true_type is_scalar; 

} l 

template <> 

struct FM_traits<long> 

{ 

typedef long element_type; 
typedef FM_true_type is_scalar; 

} : 

template <> 

struct FM_traits<unsigned long> 

{ 

typedef unsigned long element_type; 
typedef FM_true_type is_scalar; 

} ! 

template <> 

struct FM_traits<long long> 

{ 

typedef long long element_type; 
typedef FM_true_type is_scalar; 

}/ 

template <> 

struct FM_traits<unsigned long long> 

{ 

typedef unsigned long long element_type; 
typedef FM_true_type is_scalar; 

} ; 

template <> 

struct FM_t rait s<f loat > 

{ 

typedef float element_type; 
typedef FM_true_type is_scalar; 

} ; 


typedef double element_type; 
typedef FM_true_type is_scalar; 

) ; 

template <> 

struct FM_traits<long double> 

typedef long double element_type; 
typedef FM_true_type is_scalar; 

J; 

template <int N, typename T> 
struct FM_traits<FM_vector<N, T> > 

{ 

typedef typename FM_t rait s<T> :: element_t ype element_type; 
typedef FM_false_type is_scalar; 

J; 

/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

*/ 

fendif 


template <> 

struct FM_traits<double> 

{ 


51 



// Emacs mode -*-c++-*- // 
#ifndef _FM_VECTOR_H_ 

#def ine _FM_VECTOR_H_ 

/* 

* NAME: FM vector.h 


{ 

T tmp [N] ; 

for (int i = 0; i < N; i++) 
tmp[i] = lhs[i] - rhs[i]; 
return FM_vector<N, T> (tmp) ; 

) 


* WRITTEN BY: 

* Patrick Moran pmoran@nas.nasa.gov 

*/ 

tinclude <iostream> 
tinclude <utility> 

#if defined ( sgi) && ! defined ( GNUC ) 

tinclude <math.h> 
telse 

tinclude <cmath> 
tendif 

tinclude "FM_types . h" 


template <int N, typename T> 

T FM_dot (const FM_vector<N, T>&, const FM_vector<N, T>&) ; 
template ctypename T> 

FM_vector<3, T> FM_cross (const FM_vector<3, T>&, const FM_vector<3, T>& ) ; 


friend FM_vector<N, T> 

operator* (typename FM_traits<T> : : element_type lhs, 
const FM_vector<N, T>& rhs) 

{ 

T tmp [N] ; 

for (int i = 0; i < N; i++) 
tmp[i] = lhs * rhs[i]; 
return FM_vector<N,T> (tmp) ; 


friend FM_vector<N, T> 

operator* (const FM_vector<N, T>& lhs, 

typename FM_traits<T> : : element_type rhs) 

{ 

T tmp [N] ; 

for (int i = 0; i < N; i++) 
tmp[i] = lhs[i] * rhs; 
return FM_vector<N,T> (tmp) ; 


template <int N, typename T> 
class FM_vector 
{ 

public : 

FM_vector() {} 

FM_vector (const T dat[]) 

{ 

for (int i = 0; i < N; i++) 
d [i] = dat [i] ; 

) 

template <typename S> 

explicit FM_vector (const FM_vector<N, S>& dat) 

{ 

for (int i = 0; i < N; i++) 
d[i] = static_cast<T> (dat [i] ) ; 

) 

T& operator [] (int i) { return d [ i ] / } 

const T& operator [] (int i) const { return d[i]; } 


private: 
T d [N] ; 

}; 


template <typename T> 
class FM_vector<l, T> 

{ 

public : 

FM_vector() {} 

FM_vector (const T dat[]) 

{ 

d[0] = dat [0] ; 

} 

template <typename S> 

explicit FM_vect or (const FM_vector<l, S>& dat) 

< 

d[0] = static_cast<T> (dat [0] ) ; 

) 


typename FM_traits<T> : : element_type* v() 

{ 

return reinterpret_cast<typename FM_traits<T>: : element_type*> (d) ; 

) 

const typename FM_traits<T> : : element_type* v() const 

{ 

return reinterpret_cast<const typename FM_traits<T>: :element_type*> (d) ; 

} 

friend bool operator== (const FM_vector<N, T>& lhs, 
const FM_vector<N, T>& rhs) 

i 

bool res = true; 
for (int i = 0; i < N; i+4) { 
if ( ! (lhs [i] == rhs [i] ) ) { 
res = false; 
break; 

} 

) 

return res; 


FM_vector<N, T>& operator+= (const FM_vector<N, T>& v) { 
for (int i = 0; i < N; i++) 
d[i] += v [ i ] ; 
return *this; 


FM_vector<N, T>& operator-= (const FM_vector<N, T>S v) { 
for (int i = 0; i < N; i++) 
d[i] -= v [ i ] ; 
return *this; 


FM_vector<N, T>& operator*= (typename FM_traits<T> : : element_type s) { 
for (int i = 0; i < N; i++) 
d[i] *= s; 
return *this; 


FM_vector<N, T>& operator/= (typename FM_traits<T> : : element_type s) { 
for (int i = 0; i < N; i++) 
d[i] /= s; 
return *this; 

} 

friend FM_vector<N, T> operator- (const FM_vector<N, T>S u) 

{ 

T tmp [N] ; 

for (int i = 0; i < N; i++) 
tmp [ i ] = -u [ i ] ; 
return FM_vector<N, T> (tmp) ; 

} 


FM_vector (const T£ aO) 
d[0] = a0; 

) 


T£ operator!] (int i) { return d[i]; ) 

const T& operator [] (int i) const { return d[i]; ) 

typename FM_traits<T>: :element_type* v() 

return reinterpret_cast<typename FM_traits<T> : : element_type*> (d) ; 

} 

const typename FM_traits<T> : : element_type* v() const 

return reinterpret_cast<const typename FM_traits<T>: : element_type*> (d) ; 

) 


friend bool operator== (const FM_vector<l, T>& lhs, 
const FM_vector<l , T>& rhs) 


return 

lhs . d [0 ] == rh s . d [ 0 ] ; 


FM_vector<l , T>S operator+= (const FM_vector<l, T>& v) 

{ 

d[0] += v [ 0 ] ; 
return *this; 


FM_vector<l, T>S operator-= (const FM_vector<l, T>& v) 

{ 

d[0] -= v [ 0 ] ; 
return *this; 


FM_vector<l , T>& operator*= (typename FM_traits<T>: : element_type s) 

{ 

d[0] *= s; 
return *this; 


FM_vector<l , T>& ope rator/= (typename FM_traits<T> : : element_type s) 

{ 

d [ 0 ] /= s; 
return *this; 


friend FM_vector<l , T> operator- (const FM_vector<l, T>& u) 

< 

return FM_vector<l , T> (-U . d [ 0] ) ; 

) 


friend FM_vector<N, T> operator+ (const FM_vector<N, T>& lhs, 
const FM_vector<N, T>& rhs) 

{ 

T tmp [N] ; 

for (int i = 0; i < N; i++) 
tmp [ i ] = lhs [ i] + rhs [i] ; 
return FM_vector<N, T> (tmp) ; 

} 

friend FM_vector<N, T> operator- (const FM_vector<N, T>& lhs, 
const FM_vector<N, T>& rhs) 


friend FM_vector<l , T> opera to r+ (const FM_vector<l, T>& lhs, 
const FM_vector<l , T>& rhs) 

{ 

return FM_vector<l , T> (lhs . d [0 ] + rhs.d[0]); 

) 

friend FM_vector<l , T> operator- (const FM_vector<l, T>& lhs, 
const FM_vector<l , T>& rhs) 

{ 

return FM_vector<l , T> (lhs . d [0 ] - rhs.d[0]); 

) 


52 



friend FM_vector<l , T> 

operator* (typename FM_traits<T> : : element_type lhs, 
const FM_vector<l , T>& rhs) 

{ 

return FM_vector<l , T> (lhs * rhs.d [0]); 

} 

friend FM_vector<l , T> 

operator* (const FM_vector<l, T>£ lhs, 

typename FM_traits<T> : : element_type rhs) 

return FM_vector<l , T> (lhs . d [0 ] * rhs); 


operator* (typename FM_traits<T> : : element_type lhs, 
const FM_vector<2, T>& rhs) 

{ 

return FM_vector<2 , T> (lhs * rhs.d[0]. 


friend FM_vector<2 , T> 

operator* (const FM_vector<2, T>& lhs, 

typename FM_traits<T> : : element_type rhs) 

{ 

return FM_vector<2 ,T> (lhs . d [0 ] * rhs, 
lhs . d [1 ] * rhs); 


friend T FM_dot<T> (const FM_vector<l, T>S , 
const FM_vector<l , T>£ ) ; 


P 

} 


T d [ 1 ] 


friend T FM_dot<T> (const FM_vector<2, T>&, 
const FM_vector<2 , T>£ ) ; 


private : 
T d [ 2 ] ; 

) ; 


template <typename T> 
class FM_vector<2, T> 

{ 


public : 

FM_vector() {} 

FM_vector (const T dat[]) 

{ 

d [ 0] = dat [0] ; 
d [ 1] = dat [1] ; 

} 

template <typename S> 

explicit FM_vector (const FM_vector<2, S>£ 

{ 


d[0] = static_cast<T> (dat [0] ) ; 
d[l] = static_cast<T> (dat [1] ) ; 

) 

FM_vector (const TS aO, const TS al) 

{ 


d [ 0] = aO; 
d [ 1] = al; 


dat) 


T& operator [] (int i) { return d [ i ] ; } 

const TS operator [] (int i) const { return d[i]; } 


template <typename T> 
class FM_vector<3, T> 

{ 

public : 

FM_vector() {} 

FM_vector (const T dat[]) 

{ 

d [ 0 ] = dat [0] ; 
d[l] = dat [ 1] ; 
d [ 2] = dat [ 2] ; 


template <typename S> 

explicit FM_vector (const FM_vector<3, S>£ dat) 

< 

d[0] = static_cast<T> (dat [0] ) ; 
d [ 1 ] = static_cast<T> (dat [1 ] ) ; 
d[2] = static_cast<T> (dat [2] ) ; 

} 

explicit FM_vect or (const FM_vector<4, T>£ v) 

{ 

d [ 0 ] = v [ 0 ] ; 
d[l] = v [ 1 ] ; 
d [ 2 ] = v [ 2 ] ; 


typename FM_traits<T> : : element_type* v() 

{ 

return reinterpret_cast<typename FM_traits<T>: : element_type*> (d) ; 

) 

const typename FM_traits<T> : : element_type* v() const 

{ 

return reinterpret_cast<const typename FM_traits<T>: :element_type*> (d) ; 

} 


friend bool operator== (const FM_vector<2, T>£ 
const FM_vector<2, T>S 


{ 


return 


lhs, 

rhs) 


lhs . d [0 ] == rhs .d [0] SS 
lhs . d [1 ] == rhs .d [1] ; 


FM_vector<2, T>S operator+= (const FM_vector<2, T>S v) 

{ 

d [ 0] += v [ 0 ] ; 
d[l] += v [ 1 ] ; 
return *this; 

) 


FM_vector<2, T>& operator-= (const FM_vector<2, T>S v) 

{ 

d [ 0] -= v [ 0 ] ; 
d [ 1] -= v [ 1 ] ; 
return *this; 

) 


FM_vector<2, T>& operator*= (typename FM_traits<T> : : element_type s) 

< 

d [ 0] *= s; 
d[l] *= s; 
return *this; 


FM_vector<2, T>& operator/= (typename FM_traits<T> :: element_type s) 

{ 

d [ 0] /= s; 
d [ 1] /= s; 
return *this; 


friend FM_vector<2, T> operator- (const FM_vector<2, T>& u) 

{ 

return FM_vector<2, T> (-u. d[0] , -u.d[l]); 

} 


{ 


FM_vector<2, T> operator 4 (const FM_vector<2, T>S 
const FM_vector<2,T>& 

:n FM_vector<2, T> (lhs .d [0] 4 rhs.d[0], 
lhs. d[l] 4 rhs.d [1] ) ; 


lhs, 

rhs) 


{ 

} 


FM_vector<2, T> operator- (const FM_vector<2, T>& 
const FM_vector<2 , T>& 


FM_vector<2, T> (lhs .d [0] 
lhs . d [ 1] 


rhs.d [0] , 
rhs.d [1] ) ; 


lhs, 

rhs) 


friend FM_vector<2 , T> 


FM_vector (const TS aO, const TS al, const TS a2) 

{ 

d[0] = aO; 
d[l] = al; 
d [ 2 ] = a2; 

} 

TS operator!] (int i) { return d[i]; ) 

const TS operator [] (int i) const ( return d[i]; ] 

typename FM_traits<T>: :element_type* v() 

! 

return reinterpret_cast<typename FM_traits<T> : : element_type*> (d) ; 

) 

const typename FM_t raits<T> : : element_type* v() const 

! 

return reinterpret_cast<const typename FM_traits<T>: : element_type*> (d) ; 

) 


friend bool operator== (const FM_vector<3, T>£ lhs, 
const FM_vector<3, T>S rhs) 


return 
lhs.d [0] 
lhs . d [1 ] 
lhs.d [2] 


rhs.d [0] SS 
rhs.d [1] SS 
rhs.d [2]; 


FM_vector<3, T>S operator4= (const FM_vector<3, T>£ v) 

{ 

d[0] 4= v [ 0 ] ; 
d[l] 4= v [ 1 ] ; 
d [ 2] 4= v [ 2 ] ; 
return *this; 

) 


FM_vector<3, T>S operator-= (const FM_vector<3, T>S v) 

{ 

d [ 0] -= v [ 0 ] ; 
d[l] -= v [ 1 ] ; 
d [ 2] -= v [ 2 ] ; 
return *this; 

) 


FM_vector<3, T>S operator*= (typename FM_traits<T> : : element_type s) 

{ 

d [ 0] *= s; 
d[l] *= s; 
d [ 2] *= s; 
return *this; 


FM_vector<3, T>S operator/= (typename FM_traits<T> : : element_type s) 

d [ 0] /= s; 
d [ 1] /= s; 
d[2] /= s; 
return *this; 

} 


friend FM_vector<3, T> operator- (const FM_vector<3, T>S u) 

{ 

return FM_vector<3, T> (-u . d [ 0] , -u.d[l], -u.d[2]); 

) 


53 



friend FM_vector<3, T> operator+ (const FM_vector<3, T>S lhs, 
const FM_vector<3, T>S rhs) 

{ 

return FM_vector<3, T> (lhs .d [0] + rhs.d[0], 
lh s . d [ 1 ] + rhs . d [1 ] , 
lhs . d [ 2] + rhs . d [2 ] ) ; 

} 

friend FM_vector<3, T> operator- (const FM_vector<3, T>& lhs, 
const FM_vector<3, T>S rhs) 

return FM_vector<3, T> (lhs .d [0] - rhs.d[0], 
lhs.d[l] - rhs.d [1] , 
lhs. d[2] - rhs.d [2] ) ; 


friend FM_vector<3, T> 

operator* (typename FM_traits<T> : :element 
const FM_vector<3, T>& rhs) 


{ 


return FM_vector<3, T> (lhs * rhs.d[0], 
lhs * rhs .d [1] , 
lhs * rhs.d [2]) 


type 


lhs. 


FM_vector<4 , T>S operator*= (typename FM_traits<T> : : element_type s) 

{ 

d[0] *= s; 
d[l] *= s; 
d [2 ] *= s; 
d [ 3 ] *= s; 
return *this; 

} 


FM_vector<4 , T>S ope rator/= (typename FM_traits<T> : : element_type s) 

{ 

d [0 ] /= s; 
d [ 1 ] /= s; 
d[2] /= s; 
d [ 3 ] /= s; 
return *this; 

) 


friend FM_vector<4,T> operator- (const FM_vector<4, T>S u) 

{ 

return FM_vector<4,T>(-u.d[0] , -u.d[l], -u.d[2], -u.d[3]); 

} 


friend FM_vector<3, T> 

operator* (const FM_vector<3, T>S lhs, 

typename FM_traits<T> : : element_type rhs) 


return FM_vector<3, T> (lhs .d [0] 
lhs . d [ 1] 
lhs.d[2] 


rhs, 
rhs, 
rhs) ; 


friend FM_vector<4, T> operator+ (const FM_vector<4, T>S lhs, 
const FM_vector<4 , T>S rhs) 

{ 

return FM_vector<4 ,T> (lhs.d [0] + rhs.d[0], 
lhs.d [1] + rhs.d[l] , 
lhs.d [2] + rhs .d[2] , 
lhs.d [3] + rhs.d [3] ) ; 


friend T FM_dot<T> (const FM_vector<3, T>S, 
const FM_vector<3, T>6) ; 

friend FM_vector<3, T> FM_cross<T> (const FM_vector<3, T>S, 
const FM_vector<3, T>S) ; 

private : 

T d [ 3 ] ; 

} ; 


template <typename T> 
class FM vector<4,T> 


public : 

FM_vector() {} 


TS operator [] (int i) { return d[i]; ) 

const TS operator [] (int i) const { return d[i]; ) 


typename FM_traits<T> : : element_type* 


friend FM_vector<4,T> operator- (const FM_vector<4, T>S lhs, 
const FM_vector<4, T>S rhs) 

{ 

return FM_vector<4,T>( lhs.d [0] - rhs.d[0], 
lhs.d [1] - rhs .d[l] , 
lhs.d[2] - rhs .d[2] , 
lhs.d [3] - rhs .d[3] ) ; 


friend FM_vector<4, T> 

operator* (typename FM_traits<T>: :element_type lhs, 
const FM vector<4,T>S rhs) 


return FM_vector<4,T>(lhs ; 

lhs ' 
lhs ' 


rhs .d [0] , 
rhs . d [1 ] , 
rhs .d [2] , 


FM_vector (const T dat[]) 

lhs * rhs.d [3]) ; 

d[0] 

= 

dat [0 ] ; 

friend FM_vector<4 , T> 


d [ 1] 

= 

dat [ 1] ; 

operator* (const FM vector<4,T>S 

lhs, 

d [2] 

= 

dat [ 2] ; 

typename FM traits<T>: 

element type 

d [ 3] 

} 

' 

dat [3] ; 

return FM_vector<4,T> (lhs.d [0] 

* rhs, 

template 

<typename S> 

lhs.d [1 ] 

* rhs, 

explicit 

FM vector (const FM_vector<4 , S>S dat) 

lhs.d [2] 

* rhs, 

{ 



lhs.d [3] 

* rhs ) ; 

d [ 0] 

= 

static_cast<T> (dat [0] ) ; 

) 


d[l] 

= 

static_cast<T> (dat [1 ] ) ; 



d [2] 

= 

static_cast<T> (dat [2] ) ; 

friend T FM_dot<T> (const FM_vector<4, T>S , 

d[3] 

= 

static_cast<T> (dat [3] ) ; 

const FM vector<4 , T>S ) ; 

FM vector (const TS aO, const TS al, const TS a2, const 

TS a3) private: 





T d [ 4 ] ; 


d [ 0] 

= 

aO ; 

} ; 


d [ 1] 

= 

al ; 



d [2] 

= 

a2 ; 



d [ 3] 

= 

a3; 

template <int N, typename T> 



bool operator != (const FM_vector<N, T>S lhs, 
const FM_vector<N,T>S rhs) 

{ 

return ! (lhs == rhs); 

} 


return reinterpret_cast<typename FM_traits<T>: : element_type*> (d) ; 

) 

const typename FM_traits<T> : : element_type* v() const 


return reinterpret_cast<const typename FM_traits<T>: :element_type*> (d) ; 


friend bool operator== (const FM_vector<4, T>S lhs, 
const FM_vector<4, T>S rhs) 

{ 

return 

lhs.d[0] == rhs.d[0] ss 
lhs . d [1 ] == rhs .d [1] SS 
lhs . d [2 ] == rhs . d [2 ] SS 
lhs . d [3] == rhs . d [3] ; 


template <int N, typename T> 

std: :ost reams operator« (std : : ostreamS lhs, const FM_vector<N, T>& rhs) 

{ 

lhs « "("; 
int i ; 

for (i =0; i < N; i++) { 
if (i > 0) lhs « ", "; 
lhs « rhs[i]; 

} 

return lhs « ")"; 

) 


FM vector<4,T>s operator+= (c 

onst FM vector<4,T>S v) 

for (int i = 1; 

{ 


res += lhs[i] 

d [ 0] += v [ 0 ] ; 


return res; 

d[l] += v [ 1 ] ; 


} 

d [ 2] += v [ 2 ] ; 



d [ 3] += v [ 3 ] ; 



return *this; 


template ctypename 

} 


T FM dot (const FM 



const FM 

FM vector<4, T>S operator-= (c 

onst FM vector<4 , T>S v) 

{ 

{ 


return 

d [ 0] -= v [ 0 ] ; 


lhs.d[0] * rhs 

d[l] -= v [ 1 ] ; 


} 

d [ 2] -= v [ 2 ] ; 



d [ 3] -= v [ 3 ] ; 


template ctypename 

return *this; 


T FM dot (const FM 


template <int N, typename T> 

T FM_dot (const FM_vector<N, T>S lhs 

{ 

T res = lhs [0] * rhs[0] ; 

< N; i++) 
rhs [i ] ; 


ector<l,T>S rhs) 


const FM_vector<2, T>S rhs) 


const FM vector<N, T>s rhs 


54 



{ 

return 

lhs . d [ 0] * rhs.d [0] + 
lhs.d[l] * rhs.d [1]; 

} 


template <typename T> 

T FM_dot (const FM_vector<3, T>& lhs, 
const FM_vector<3, T>& rhs) 

{ 

lhs . d [ 0] * rhs . d [0 ] + 
lhs . d [ 1] * rhs . d [1 ] + 
lhs . d [ 2] * rh s . d [ 2 ] ; 


template <typename T> 

T FM_dot (const FM_vector<4, T>& lhs, 
const FM_vector<4 , T>& rhs) 


eturn 

lhs . d [ 0] * rhs.d [0] 
lhs . d [ 1] * rhs . d [1 ] 
lhs . d [ 2] * rhs.d [2] 
lhs . d [ 3] * rhs . d [3] 


template <typename T> 

FM_vector<3, T> FM_cross (const FM_vector<3, T>6 lhs, 
const FM_vector<3, T>& rhs) 


i 


return FM_vector<3, T> (lhs .d [1] 
rhs . d [ 0] 
lhs.d[0] 


rhs.d [2] - rhs .d[l] 
lhs.d [2] - lhs .d[0] 
rhs.d [1] - rhs .d[0] 


lhs.d [2], 
rhs. d[2] , 
lhs. d[ 1] ) 


template <int N, typename T> 

T FM_mag (const FM_vector<N, T>& v) 

return (T) sqrt (FM_dot (v, v) ) ; 

) 


template <int N, typename T> 

T FM_distance2 (const FM_vector<N, T>& lhs, const FM_vector<N, T>& rhs) 

i 

FM_vector<N, T> d = rhs - lhs; 
return FM_dot (d, d) ; 

} 


template <int N, typename T> 

inline std: :pair<FM_vector<N, T>, FM_vector<N, T> >& 

FM_operator_min_ma>:_equals (std : : pair<FM_vector<N, T>, FM_vector<N, T> >& mm, 
const FM_vector<N, T>& v) 

{ 

for (int i = 0; i < N; i+4) { 
if (v[i] < mm.first[i]) 
mm.first[i] = v[i]; 
else if (mm . second [i] < v[i]) 
mm. second [i] = v[i]; 

) 

return mm; 


template <int N> 

FM_vector<N, bool> operator ! (const FM_vector<N, bool>S u) 

i 

bool tmp[N]; 

for (int i = 0; i < N; i++) 
tmp [ i] = ! u [ i ] ; 

return FM_vector<N, bool> (tmp) ; 


template <int N> 

FM_vector<N, bool> operator&S (const FM_vector<N, bool>& lhs, 
const FM_vector<N,bool>S rhs) 

{ 

bool tmp[N]; 

for (int i = 0; i < N; i++) 
tmp[i] = lhs[i] && rhs[i]; 
return FM_vector<N, bool> (tmp) ; 


{ 

bool res = true; 
for (int i = 0; i < N; i++) { 
if (lhs [i] 6& ! rhs [i] ) { 


} 


template <int N> 

bool operator>= (const FM_vector<N, bool>& lhs, 
const FM_vector<N,bool>& rhs) 


{ 


bool res = true; 
for (int i = 0; i < N; i++) { 
if (! lhs[i] 6 & rhs[i] ) { 


return res; 

} 


typedef 

typedef 

typedef 

typedef 

typedef 

typedef 

typedef 

typedef 

typedef 


FM_vector<2, int> FM_vector2i; 
FM_vector<2, float> FM_vector2f ; 
FM_vector<2, double> FM_vector2d; 
FM_vector<3, int> FM_vector3i; 
FM_vector<3, float> FM_vector3f ; 
FM_vector<3, double> FM_vector3d; 
FM_ve cto r< 4 , int> FM_vector4i; 
FM_vector<4, float> FM_vector4f ; 
FM_vector<4, double> FM_vector4d; 


/* 

* Copyright (c) 2000 

* Advanced Management Technology, Incorporated 

* Permission is hereby granted, free of charge, 

* to any person obtaining a copy of this software 

* and associated documentation files (the "Software") , 

* to deal in the Software without restriction, 

* including without limitation the rights to use, 

* copy, modify, merge, publish, distribute, sublicense, 

* and/or sell copies of the Software, and to permit 

* persons to whom the Software is furnished to do so, 

* subject to the following conditions: 

* The above copyright notice and this permission 

* notice shall be included in all copies or substantial 

* portions of the Software. 

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY 

* OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 

* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 

* FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT . IN NO 

* EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 

* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 

* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 

* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 

* THE USE OR OTHER DEALINGS IN THE SOFTWARE. 


*/ 

f endif 


template <int N> 

FM_vector<N, bool> operator | | (const FM_vector<N, bool>& lhs, 
const FM_vector<N,bool>& rhs) 

{ 

bool tmp[N]; 

for (int i = 0; i < N; i++) 
tmp [ i ] = lhs [ i] | | rhs [ i] ; 
return FM_vector<N, bool> (tmp) ; 


template <int N> 

FM_vector<N, bool> operator' (const FM_vector<N, bool>& lhs, 
const FM_vector<N, bool>& rhs) 

{ 

bool tmp[N]; 

for (int i = 0; i < N; i++) 
tmp [ i ] = lhs [ i] ' rhs [i] ; 
return FM_vector<N, bool> (tmp) ; 


template <int N> 

bool ope rator<= (const FM_vector<N, bool>& lhs, 
const FM_vector<N,bool>& rhs) 


55 



