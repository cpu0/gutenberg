










































Fortran-64 

Programming language 
for the Commodore 64 

(c) 1988 Bob Stover & Tim Adams 


Published By: 

AbacusD 




Copyright Notice 

Abacus makes this package available for use on a single computer 
only. It is unlawful to copy any portion of this software package 
onto any medium for any purpose other than backup. It is 
unlawful to give away or resell copies of this package. Any 
unauthorized distribution of this product deprives the authors of 
their deserved royalties. For use on single-site multiple 
computers, please contact Abacus to make arrangements. 


Warranty 

Abacus makes no warranties, expressed or implied, as to the 
fitness of this software package for any particular purpose. In no 
event will Abacus be liable for consequential damages. Abacus 
will replace any copy of this software which is unreadable, if 
returned within 30 days of purchase. Thereafter, there will be a 
nominal charge for replacement. 


First Printing, November 1988 
Printed in U.S.A. 

Copyright © 1986 Bob Stover and Tim Adams 

Copyright© 1988 Abacus 

5370 52nd Street, S.E. 
Grand Rapids, MI. 49508 


ISBN 


0-916439-91-7 




TABLE OF CONTENTS 


Writing a Fortran program j 

Compiling a program 3 

The Program Format 4 

Program Creation 5 

TEST Program (Translatable) 6 

Getting started 7 

The main menu g 

Compiler mode 9 

Back to BASIC 11 

Linker mode 12 

Help mode 15 

Color mode 16 

Translator mode 17 

Directory lg 

Creating a data disk 19 

Statement descriptions 21 

Arithmetic Expressions 22 

CALL 23 

CALL EXEC 23 

CLOSE 24 

COMMENTS 24 

COMMON 25 

CONTINUE 25 

DATA 26 

DIMENSION 27 

DO 27 

ELSE 28 

END 29 



ENDCOMMON 30 

ENDIF 29 

FORMAT 31 

FUNCTION 30 

GOTO 32 

IF 33,35 

IF THEN 34 

IMPLICIT 35 

MEM 35 

OPEN 36 

PAUSE 37 

PROGRAM 37 

READ. 37, 38 

RETURN 39 

STOP 39 

SUBROUTINE 39 

TYPE statements 40 

WAIT 41 

WRITE 41,42 

Operators 43 

Appendix A—Built-in functions 44 

Appendix B—Format descriptor 45 

Appendix C—Data types 46 

Appendix D—Error descriptions 47 



Writing a Fortran program 


WRITING A FORTRAN PROGRAM 

Writing a Fortran file involves a number of different files. Before 
starting your programming effort, you must create a data disk (see 
Creating a Data Disk). There are a number of files on your disk that 
are vital to the programming process. The steps needed to produce 
an executable program follow (see page 5, Program Creation). 

The first file you will create is the Fortran source file (the file that 
holds your Fortran statements). The program must adhere to the 
format described on pages 4-6, Program Format. If the program is 
to be executed it must contain one main program unit and any 
number of subroutine or function units. If the file does not contain a 
main program it can still be compiled and later linked with a file that 
does have a main program. 

The source file can be created using two methods. The first is to use 
any word processor which produces sequential ASCII output files. 

The other alternative, is to create a file using the BASIC editor (see 
Back to BASIC) and translate it into a sequential file using the 
Translator (see Translator mode). The TEST program on page 8 
gives an example of a Fortran program written in the BASIC editor, 
before it is translated. Each line is entered as in BASIC, with the 
following exception: A colon (:) must appear on the line between the 
line number and the statement. After the program is written and all 
editing is completed, it is simply saved to the disk using the BASIC 
SAVE command. 

Once a sequential file has been created with either method, enter the 
Compiler mode to compile the source program into an object file. 
The object file contains relocatable, binary machine code. 

At this point object files can be combined by linking them together 
and loading them into memory. This is done in the Linker mock. 

After the linking process is completed, an executable program 
resides in memory. If the BASIC LIST command is used, a REM 
statement appears on the first line along with the name of your 


1 




Writing a Fortran program 


Fortran-64 


Fortran program. A SYS statement also exists with the execution 
address. 

The rest of the program is in machine language. At this point the 
program can be saved to disk or it can be executed using the BASIC 
RUN command. This program can be put on any disk. It does not 
have to reside on your data disk. 


2 




Abacus 


Compiling a program 


COMPILING A PROGRAM 

The Fortran-64 disk contains many example programs. The 

following is an example of the complete compilation process: 

1) Load Fortran-64 (see GETTING STARTED.) 

2) Press the F6 key for translator mode (see Translator mode.) 

2) Enter DOC-READER.FOR as the filename then press Return. 

3) Enter DOC-READER.SEQ as the sequential filename then press 
Return. The file will be converted to a sequential file. Press 
Return when the translation process is finished. 

4) Press FI to enter Compiler mode (see Compiler mode.) Enter 
DOC-READER.SEQ as the source filename then press Return. 

5) Enter DOC-READER.OBJ as the object filename then press 
Return. Enter n for HARDCOPY. The file will be displayed on 
the screen as it is compiled. Press the Return key when the 
compilation process is finished. 

6) Press F3 to enter the Linker mode (see Linker mode). Press y 
to confirm entering Linker mode. Enter DOC-READER.OBJ as 
the object filename and press Return. 

7) Enter n in response to the LI ST MODULES questions. 

8) Enter STRING.LIB in response to the UNDEFINED 
EXTERNAL message. 

9) The program is ready to save and run. To save the program to 
disk, enter SAVE "DOC-READER”,8 and press Return . 

10) Enter RUN and press Return to run the program. Enter 0 for no 
printout. Next enter TOPICS.DOC. The TOPICS.DOC will be 
displayed. Read each screen then press the Return key to move 
to the next screen. 


3 




Compiling a program 


Fortran-64 


THE PROGRAM FORMAT 

PROGRAM name 
declarations 


label statements 


SUBROUTINE name (arguments) 


FUNCTION name (arguments) 
declarations 


RETURN 

END 

Note: Source lines are entered in free field format. This means that 
all spaces are ignored unless they appear between single quote 
marks. This allows indention of loops and decision blocks. Labels 
can appear anywhere on the line if they are the first on the line. 

Comment lines must start with *. Blank lines are ignored. 

Any statement can be continued onto the next line by placing a # at 
the end of a line. The following example would be considered one 
line although it is typed in on two: 


WRITE (4,*) I,J,A,B.C,D#,X,Y,Z 



Abacus 


Compiling a program 


PROGRAM CREATION 


CREATE SOURCE 
FILE CONTAINING 
MAIN AND 
SUBROUTINES 
USING 

WORD PROCESSOR 
(SEQ. FILE) 


CREATE SOURCE 
FILE CONTAINING 
MAIN AND/OR 
SUBROUTINES 
USING 

BASIC EDITOR 
(PRG. FILE) 


CREATE SOURCE 
FILE CONTAINING 
ONLY 

SUBROUTINES 

USING 

WORD PROCESSOR 
(SEQ. FILE) 






Compiling a program 


Fortran-64 


TEST PROGRAM (TRANSLATABLE) 

10 : PROGRAM TEST 

15 :* THIS PROGRAM WILL WRITE A 

16 :* LIST OF THE ODD NUMBERS 

16 :* FROM 1 TO 10 TO A PRINTER 
20 : INTEGER A,B 

30 : OPEN 4,4 

40 : DO 10 I - 1, 10, 2 

50 : WRITE(4, 100) I 

60 : 10 CONTINUE 

65 : CLOSE 4 

70 : STOP 

80 : 100 FORMAT(15) 

90 : END 

Note: Source lines are entered in free field format with a line ■ 
number and colon appearing first on the line. This means 
that all spaces are ignored unless they appear between single 
quote marks. This allows indention of loops and decision 
blocks. Labels can appear anywhere on the line as long as 
they are the first things on the line. The Translator mode is 
used to convert this program to a sequential file. 




Abacus 


Getting started 


GETTING STARTED 

1. ) Turn on your computer and all attached disk drives and 

printers. 

2. ) Insert the Fortran-64 disk, label side up, in you 1541 or 

compatible disk drive. 

3. ) Type the following: 


LOAD "0:*",8 

then press Retum.The computer should reply with: 

SEARCHING FOR * 

LOADING 

READY 

4. ) Now, type the following: 

RUN 

then press Return. After approximately 25 seconds, the 
Abacus Software logo and title screen appears and the main 
program begins to load. 

5. ) After an additional delay of about 65 seconds, the Main Menu 

displaying the Copyright message appears. 


7 



The Main Menu 


Fortran-64 


THE MAIN MENU 

The Main Menu lets you select the Compiler, Linker and other 
features by pressing a function key. When depressed, the function 
keys perform the following: 

FI Enter the Compiler mode 
F2 Back to BASIC 
F3 Enter the Linker mode 
F4 Enter the Help mode 
F5 Enter the Color mode 
F6 Enter the Translator mode 
F7 View the directory on disk drive #8 
F8 View the directory on disk drive #9 


FORTRAN-64 

FORTRAN RESIDENT COMPILER VX.X 
COPYRIGHT (C) 1986 BOB STOVER/TIM ADAMS 
ALL RIGHTS RESERVED 

MAIN MENU 

FI COMPILER 

F2 BACK TO BASIC 

F3 LINKER 

F4 HELP 

F5 COLOR 

F6 TRANSLATOR 

F7 DIRECTORY 8 

F8 DIRECTORY 9 


Screen for Main Menu 






Abacus 


Compiler mode 


COMPILER MODE 

If you press function key FI you enter Compiler mode. You are 
asked to type the name of your source file. 

ENTER SOURCE FILENAME: 

Type the name of the source File to be compiled. You can specify a 
separate disk drive by typing as follows: 

To select drive #8: 


filename or D8:filename 


To select drive #9: 


D9:filename 

The filename typed is a string of 1 to 16 characters. 

Note: Only drives #8 and #9 are supported in the Compiler mode. 
However, the syntax for using these two drives permits 
maximum flexibility, by allowing the user to enter the source 
file from either drive and direct the object file to either drive. 

Note: After entering the Compiler mode, function key FI can be 
used to return to the Main Menu, before the object filename 
is specified. 

After the source filename is entered, the compiler asks for the object 

filename as follows: 

ENTER OBJECT FILENAME: 

The object filename can be entered using the same syntax as 

described for entering the source filename. 

Note: If the object filename already exists on the disk, an error 
message appears. A new filename can then be entered or the 
old file can be replaced using the following syntax: 


9 




Compiler mode 


@0:filename or 
D8:@0:filename or 
D9:00:filename 


Fortran-64 


The compiler now asks if a printer listing of the source file during 
compilation is desired as follows: 

HARDCOPY? (Y/NCR-N) 

If a Y is entered, the compiler asks for the device number as follows: 

HARDCOPY DEVICE? (4/5CR-4) 

If a N or CR is entered, the compiler begins to compile the source file 
entered and creates an object File on disk. 

Any errors found during compilation are indicated either on the 
screen or on the hardcopy device (if selected). See the Error 
Description section of this manual for details on error determination. 

Anytime during the compilation process, the compiler can be paused 
or aborted with the following keystrokes: 

Run/Stop key forces the compiler to pause 

space bar permits the compiler to continue after pause 

Q aborts the compilation process 

After compilation, the results of the process are indicated as follows: 

***** ERRORS DETECTED. 

@@0@@ SOURCE LINES READ. 

where ***** is the number of errors detected and 0 0 0 0 0 is the 
number of source lines encountered. 

A prompt then appears allowing the user to return to the Main Menu. 


10 




Abacus 


Back to BASIC 


BACK TO BASIC 

After function key F2 is depressed, the user is given the option to 
return to BASIC (see Figure 2). This permits creation or editing of a 
Fortran source file while in BASIC. However, the following prompt 
allows the user to change his mind: 

ARE YOU SURE? (Y/N CR-N) 

Note: In order to allow creation or editing of your Fortran file with 
the BASIC editor and allow re-entry into Fortran-64 without 
reloading, a SYS 49152 must be performed immediately 
after returning to BASIC. After saving the file, a second 
SYS 49152 can be performed to return to the Main Menu. 



Screen for Back to BASIC 


11 








Linker mode 


Fortran-64 


LINKER MODE 

After function key F3 is depressed, the Linker mode is entered. (See 
Figure 3) 

Note: If linking is carried out, no further returns to the Main Menu 
are possible. However, if linking is performed, additional 
object files can be linked or relinked by typing SYS 49152, 
followed by the Return key. 

Note: Due to memory limitations, only drive #8 is supported in 
Linker mode. 

The first question asked by the linker is as follows: 

ARE YOU SURE (Y/N CR-N) 

If an N is entered, a prompt appears allowing the user to return to the 
Main Menu. If a Y or CR is entered, the linker first tries to load the 
system table (SYTEM.TAB). If successful, the linker then asks for 
the object filename as follows. 

ENTER OBJECT FILENAME: 

Note: The object filename is the name entered in the Compiler 
mode. 

After the object filename is entered, the linker asks if the user wants 
a list of the modules loaded as follows: 

LIST MODULES/ (Y/N CR-N) 

If an N is entered, the linking process begins. If a Y or CR is 
entered, the linker asks if a printer listing of the loaded modules is 
desired as follows: 

HARDCOPY? (Y/N CR-N) 

Depending on the replay, all modules loaded during the linking 
process are listed on the printer or the screen. 


12 



Abacus 


Linker mode 


Note: Due to memory limitations, only print device #4 is supported 
in Linker mode. 

If an external subroutine is called in the main routine of a Fortran 
program but the external subroutine was compiled separately, a 
message is displayed as follows: 

UNDEFINED EXTERNAL 


ARE YOU SURE? (Y/NCR-Y) 
ENTER OBJECT FILENAME: 
LIST MODULES? (Y/NCR-N) 
HARDCOPY? (Y/NCR-N) 

MODULES LOADED: 


Screen for Linker Mode 


The linker also displays the name of the subroutine and asks for the 
filename of the library where the user may have included this 
external subroutine as follows: 

ENTER LIBRARY NAME: 

After the filename is entered, the linking process continues. When 
linking is completed, the following message appears: 

RUNABLE CODE RESIDES 
FROM $0850 TO $**** 

Where $ * * * * is the ending address. 


13 







Linker mode 


Fortran-64 


Note: If a library filename is entered that doesn't contain the 
external subroutine requested or if any disk errors occur, an 
error message is displayed on the screen and a retry message 
appears. This can be helpful if libraries or modules are 
located on separate disks. This message allows the user to 
swap disks until the required file is located. 

The final message to appear is the completed message as follows: 

LINK COMPLETE 

At this point, a runable/saveable version of the program is resident 
in memory. USe the normal save command to save the program to 
diskette. 


14 



Abacus 


Help mode 


HELP MODE 

After function key F4 is depressed, the Help mode is entered. This 
mode describes the options available from the Main Menu. 

A prompt appears allowing the user to return to the Main Menu. 


HELP 

FI SELECTS COMPILER 
SYNTAX: 

FOR SOURCE OR OBJECT FILENAME : 
FILENAME OR D8 :FILENAME 
OR D9:FILENAME: 

F2 RETURNS TO BAS IC: 

F3 SELECTS LINKER: 

IF SELECTED: 

ALLOWS FOR SAVE AND/OR RUN: 

F 4 SELECTS THIS HELP FEATURE: 

F5 SELECTS COLOR CHANGE MENU: 

F6 SELECTS TRANSLATOR: 

F7 SELECTS DIRECTORY ON DRIVE 8 : 

F8 SELECTS DIRECTORY ON DRIVE 9: 

PRESS RETURN WHEN READY: 


Screen for Help Mode 


15 






Color mode 


Fortran-641 


COLOR MODE 

After function key F5 is depressed, the Color mode is entered. This 
mode allows the user to select the color you desire to work with. 

A prompt appears allowing the user to return to the Main Menu. 

After the source filename is entered, the compiler asks for the object 
filename as follows: 


COLOR 


(S) CREEN COLOR CHANGE 

(B) ORDER COLOR CHANGE 

(C) HARACTER COLOR CHANGE 

PRESS RETURN WHEN READY: 


Screen for Color Mode 


16 







Abacus 


Translator mode 


TRANSLATOR MODE 


After function key F6 is depressed, the Translator mode is entered. 


TRANSLATOR 


ENTER PROGRAM FILENAME: 
ENTER SEQUENTIAL FILENAME: 


Screen for Translator Mode 


Note: Due to memory limitations, only drive #8 is supported in 
Translator mode. 


The Translator first asks for the program filename as follows: 
ENTER PROGRAM FILENAME: 

The program filename is the name of the file originally created using 
the Commodore BASIC editor and saved on the disk. 


The Translator then asks for the sequential filename as follows: 
ENTER SEQUENTIAL FILENAME: 

Note: The sequential filename is the name of the source file used as 
input to the Compiler in Compiler mode. 

After entering this name the Translator converts your program file to 
a source file. 

If a disk error is detected, it is displayed on the screen as follows: 
DISK ERROR xx FOUND 


17 










Translator mode 


Fortran-64 


where xx is the error number, (see your disk drive manual for erro 
explanations) 

However, if the sequential filename already exists, the Translate 
displays an error, and also allows the user to enter a new filename as 
follows: 

FILE EXISTS. 

REPLACE FILE? (Y/N CR-Y) 

If an N is entered, the Translator allows a new sequential filename tc 
be entered. If a Y is entered or the Return key is pressed, th< 
Translator deletes the original sequential file and saves the file unde 
the old name. 

If a colon is not detected on a line, an error is also generated ai 
follows: 


ERROR: COLON MISSING ON LINE xx 

Note: The sequential file is still generated after detecting missin 
colons. However, the program file must be corrected an 
retranslated before proceeding to the Compiler mode. 

After successful completion of the Translation process, a messag 
appears as follows: 

TRANSLATION COMPLETE 

A prompt then appears allowing the user to return to the Main Menu 

DIRECTORY 

Function keys F7 and F8 allow the disk directory from drive #8 o 
#9 respectively, to be viewed. Pressing the spacebar while viewin; 
the directory will pause the display. Depressing any key allow 
continued viewing. If the Run/Stop key is pressed or when the en< 
of the directory is reached, a prompt appears allowing the user t 
return to the Main Menu. 


18 


Abacus 


Creating a Data disk 


CREATING A DATA DISK 

In order to link a compiled program in the shortest amount of time, it 
is advisable to create a data or source disk. On this disk, the library 
and runtime routines should appear first before any user created 
source files. In order to achieve this, a program has been supplied to 
copy the basic libraries and runtime routines to the data disk. The 
following steps should be performed: 

1. ) Insert the Fortran-64 disk into drive #8. 

2. ) Type the following: 

LOAD "CREATE",8 

followed by a carriage return. The computer should replay 
with: 

SEARCHING FOR CREATE 

LOADING 

READY 

4. ) Now, type the following: 

RUN 

followed by a carriage return. 

5. ) The following prompt appears: 

INSERT FORTRAN-64 DISK 
AND PRESS RETURN 

6. ) Now press the Return key All library and runtime routines are 

read from the disk. An asterisk appears to show you the 
progress. 

7. ) When complete, a new prompt appears as follows: 

INSERT DATA DISK 
AND PRESS RETURN 


19 




Creating a Data disk 


Fortran-641 


8. ) Insert the new data disk and press the Return key. A new 

prompt appears as follows: 

DO YOU WANT TO FORMAT? (Y/NCR-N) 

If Y is entered this prompt appears: 

ENTER DISK NAME: 

Type a new disk name and press the Return key. 

A second prompt then appears as follows: 

ENTER DISK ID: 

The new disk ID (not greater than 2 characters) can then be 
entered and a carriage return is depressed. 

After formatting or if N or CR is depressed, all required 
libraries and runtime routines are copied to your disk. 

9. ) When complete a message is displayed as follows: 

DATA DISK CREATED 

10. ) At this point, source programs can be stored on the data disk 

along with any user-defined libraries. You can now start 
Fortran-64. 

Note: If any disk errors are detected during the create process, they 
are displayed on the screen as follows: 

DISK ERROR XX FOUND 

where xx is the error number (see your disk drive manual for 
error explanations). 


20 


Macias 


Statement descriptions 


STATEMENT DESCRIPTIONS 

In the following pages are the statements recognized by Fortran-64. 
The descriptions consist of a short explanation of the statement, 
syntax for the statement, examples and notes for its use. The syntax 
shows, in a condensed form, the structure of the statement. To 
expand the syntax into a usable form the following rules must be 
followed: 

I. Capitalized words and punctuation should be used exactly as 
shown. 

Small lettered words represent place holders for user supplied 
syntax. 

All spaces, except spaces between quotes, are optional. For 
example the following two statements are equivalent: 

IF (I.EQ.J) GOTO 10 
IF (I.EQ.J) GO TO 10 

4. The following symbols have special meaning: 

[ ] syntax contained within is optional. 

{ } syntax contained within can be 
repeated. 

| OR - one or the other symbol on 

either side of the | can be used at this 
position. 

Examples: 

Syntax Expansion: 

CLOSE filenumberf [,filenumber]} CLOSE 8 

CLOSE 8,9,10 

WRITE <f ilenumber,* |+) WRITE (4,*) 

WRITE (6,+) 

5. Variable names are up to 5 characters long. They must begin 
with an alphabetical character (A-Z) 


21 



Statement descriptions 


Fortran-! 


ARITHMETIC EXPRESSION 

PURPOSE: To allow the calculation of arithmetic equations usit 
variables and constants. 

SYNTAX: varnam = varban | const I funcnan {[ope 

varnam|const Ifuncnam]1 

where: varban is a simple variable or array 
element. 

const is a constant of the same type as t 

variables being used. 

funcnam is the name of a function being 

invoked. 

oper is a mathematical operator. 

EXAMPLES: X= 1.0 

IY= (<J+ 4) * 3) / 6 * 4 
A= SIN (X) + 6.0 

NOTES: 1) Mixed mode operations are not permitted (reals 

and integers mixed). 

2) Variables must be explicitly converted using 
IFIX or FLOAT. 

3) For a list of operators see Appendix A. 

4) All variables on the right side of the equal sign 
must have been previously defined in the 
program. 



Abacus 


Statement descriptions 


PURPOSE: 

SYNTAX: 

EXAMPLES: 

NOTES: 

PURPOSE: 

SYNTAX: 

EXAMPLES: 


CALL 

To transfer program control to the specified 
subroutine. 

CALL subname {varnam | arithmetic 
expression I constant {[.varnam| 
arithmetic expression | constant] )) 

where varnam is a simple variable or array 
element 

subname is the subroutine name up to 5 
characters long. 

CALL SUB1 <X,Y) 

CALL TEXT (1.3.X.I) 

CALL XXX (X.l.I + 6) 

1) Values in parameters can be passed to and from 
the subroutine. 

2) Entire arrays cannot be passed as parameters. 
(See the COMMON statement) 


CALL EXEC 

To allow direct access to Kemal or user written 
machine language subroutines. 

CALL EXEC (ia.ix.iy.istat.iaddr) 

where: ia, ix, iy, istat are integer variables 
or constants with values 0 to 255. 
iddr is an integer variable or constant with 
a value 0 to 65535. 

: CALL EXEC (IA,IX,IY,ISTAT,LDTIM) 

CALL EXEC (6,3,8,1,64233) 

CALL EXEC (0,OIVAL1,IVAL2,IADDR) 


23 




Statement descriptions 


Fortran-! 


H 


NOTES: 1) ia, ix, and iy represent the contents of the 

internal 6510 registers A, X, and Y before the 
call. 

istat represents the 6510 STATUS register. If 
variables are used instead of constants in these 
positions, they will contain the new values of the 
A,X,Y, and STATUS registers, after returning 
from the subroutine. 


CLOSE 

PURPOSE: To close a file previously opened for communicatioi 
SYNTAX: CLOSE filenumber ([.filenumber]) 

where: filenumber is a constant or variable. 

EXAMPLES: CLOSE I,J 
CLOSE 15 

NOTES: 1) Performs the same function as in BASIC. 

2) The filenumber must have been defined in an 
OPEN statement 


COMMENTS 

PURPOSE: To allow embedded documentation in programs. I 
SYNTAX: * any characters 

EXAMPLES: * This is a comment line 

* comments make programs more readable 


24 



Abacus 


Statement descriptions 


PURPOSE: 

SYNTAX: 

EXAMPLES: 

NOTES: 1) 

2) 


PURPOSE: 

SYNTAX: 


COMMON 

To allow arrays in different subprogram units to 
share the same block of memory. 

COMMON 

COMMON 

INTEGER IAXX (25), C (10) 

REAL XXXX(4) 

CHARACTER NAME (15) 

ENDCOMMON 

The COMMON statement signals the beginning of an 
array block that can be shared by many subprogram 
units. The ENDCOMMON statement ends the block of 
common. 

The COMMON block can be used to equivalence two 
different data types between two program units. An 
example, an array of S integers in a subroutine can be 
treated as an array of 10 characters in another 
subroutine. 


CONTINUE 

To allow block structuring of a program, 
[label] CONTINUE 

where: label is an unsigned integer constant 


25 




Statement descriptions 


Fortran- 



EXAMPLES: 100 CONTINUE 


CONTINUE 
DO 10 I - 1,10 

10 CONTINUE 

NOTES: 1) The CONTINUE statement can be used for clarity. 

2) The CONTINUE statement should be used to end 
DO block. 


DATA 

PURPOSE: To assign values to a variable. 

SYNTAX: DATA varnam/constant /1 /' string' / 

{ [.varnam/constant/1/'string'/]} 

where: varnam is a simple variable or array 
element or array name, 
constant is a value to be assigned to the 
variable. 

EXAMPLES: DATA A/1.26/,1/29/ 

DATA X/ ’ test' /,J/ 6*327/ 

DATA I (6)/1.2,4,8/ 

DATA Z/.TRUE./.Y/.FALSE./ 

NOTES: 1) There are no restrictions on where a DATA statemen 
can appear in a program. In fact, to conserv< 
memory, it is suggested that a DATA statement b< 
used to replace a simple assignment statement 

2) The following multiple assignment is not permitted 
a,b,c/1.2,3.45,1.9 

3) The * symbol can be used as a repeat specifier to fil 
an array more efficiently, as in the example above 
As shown, the six elements of J would contain 327. 


26 


Abacus 


Statement descriptions 


DIMENSION 

PURPOSE: To define the dimensions and bounds of arrays. 

SYNTAX: DIMENSION varnam (bounds) 

{[.varnam(bounds) ]) 

where: varnam is an array variable. 

bounds is the integer dimension. 

EXAMPLES: DIMENSION J(2,6),A(6) 

DIMENSION K(10) 

NOTES: 1) 1 or 2 dimensional arrays are permitted. 

2) An array can also be dimensioned using the type 
statement. 

DO 

PURPOSE: To allow a method of looping on a group of 
statements. 

SYNTAX: DO label varnam - is,if [,ic] 

where: label is an unsigned integer, 
varnam is a simple variable, 
is is a signed integer constant or variable 
(starting value). 

if is a signed integer constant or variable 
(final value). 

ic is a signed integer constant (increment) 

EXAMPLES: DO 10 J-1,10 
DO 200 K-I.J.2 
DO 60 I—0,-5,-1 


27 




Statement descriptions 


Fortran-! 


I 


NOTES: 1) The integer specified as a label should correspond tc 
a labeled continue statement used later in the 
program. 

2) DO loops can be nested. 

ELSE 

PURPOSE: To allow one of two blocks of statements to b< 
executed depending on a conditional statement. 

SYNTAX: IF (conditional) THEN 

statement 


statement 


statement 
END IF 

EXAMPLES: IF (TIME .EQ. 0.0) THEN 

WRITE (3,*) 1 TIME IS UP.' 

TIME - 100.00 
ELSE 

WRITE (3,*) 'WAITING...' 

TIME-TIME - 1.0 
ENDIF 

NOTES: 1) The ELSE block can contain IF statements to furtht 
the decision making process. 

2) The ELSE must be used in conjunction with the I 
THEN and ENDIF statements. 


28 



Abacus 


Statement descriptions 


ENDIF 

PURPOSE: To terminate the end of a block IF statement 
SYNTAX: ENDIF 

EXAMPLE: IF (X .EQ. 1) THEN 
WRITE (3,*) X 
ENDIF 

IF (X .EQ. 6) THEN 
WRITE (3,*) X 
ELSE 

WRITE (3,*) 

ENDIF 

NOTES: 1) ENDIF is required at the end of any compound IF 
statement. 

2) When nesting compound IF statements within 
blocks each must have a corresponding ENDIF. 

END 

PURPOSE: To indicate the end of a program unit 
SYNTAX: END 

EXAMPLES: PROGRAM TEST 
COMMON 

INTEGER X (5),J (20) 

ENDCOMMON 
READ (0,*) I 
CALL SUB1 (I) 

WRITE (3,*)X(1) 

STOP 

END 

SUBROUTINE SUB1 (J) 

COMMON 


29 




Statement descriptions 


Fortran-) 


I 

a 


INTEGER I(10) ,A (15) 

ENDCOMMON 
1(1) - J 
RETURN 
END 

NOTES: 1) END is required at the end of all program units 
(Program, Subroutine or Function) 

ENDCOMMON 

PURPOSE: To signal the end of a common block of arra; 
storage. 

SYNTAX: ENDCOMMON 

EXAMPLES: COMMON 

INTEGER XXX (10) 

ENDCOMMON 

NOTES: 1) See the COMMON statement for general comments. 

FUNCTION 

PURPOSE: To define the beginning of a function subprogram. 
SYNTAX: FUNCTION name (varnaml [.varnam])) 

where: varnam is a variable or array element 
name is the function name up to 5 
characters. 

EXAMPLES: FUNCTION SUB1 (X,Y) 

NOTES: 1) Expressions are not allowed as arguments. 

2) Entire arrays cannot be passed as parameters. (S< 
the COMMON statement) 


30 



Abacus 


Statement descriptions 


3) An argument is always required even if it's a dummy 
argument. 

4) The FUNCTION is invoked by name in an expression 
as follows: 

x 3 + subl (i, j) 

5) The function name must occur on the left side of an 
assignment statement, somewhere within the subpro¬ 
gram body. 

6) The function only returns one value, all other argu¬ 
ments remain unchanged. 

7) See Appendix B for a list of build-in functions. 


FORMAT 


PURPOSE: To structure input and output information 
SYNTAX: label FORMAT <desc{ [,desc] )) 

where: desc is a format descriptor. 

label is an unsigned integer. 


EXAMPLES: 100 FORMAT (I3.5F12.3) 

200 FORMAT (IX,'ANSWER - ',3 (2X,I4,L2) ) 


NOTES: 


1) See Appendix C for a list of format descriptors. 

2) Parenthesis can be used to nest format descriptions 
as shown in the second example above. 


31 




Statement descriptions 


Fortran-64 


computed GOTO 

PURPOSE: To allow branching to a labeled statement depending 
on the result of an integer expression. 

SYNTAX: GOTO (label! [.label])} I 

where: label is an unsigned integer. 

I is an integer expression. 

EXAMPLES: GOTO (10,20,30) J 

GOTO (10,20) (1+3)/6 

NOTES: 1) In the first example, if J«1 then branch is made to 
10, of J-2 then a branch is made to 20, etc. 

2) If the expression is less than 1, a branch is made to 
the Tint label. If it is greater than or equal to the 
number of labels, a branch is made to the last label. 


unconditional GOTO 

PURPOSE: To allow branching to a labeled statement. 

SYNTAX: GOTO label 

where: label is an unsigned integer. 

EXAMPLES: GOTO 10 
GOTO 999 

NOTES: 1) The statement immediately after the GOTO statement 
must have a label to allow access to that statement 


32 




Abacus 


Statement descriptions 


arithmetic IF 

PURPOSE: To allow control to pass to one of three different 
labeled statements depending on the evaluation of an 
arithmetic expression. 

SYNTAX: IF (express) label, label [.label] 

where: express is an arithmetic expression, 
label is an unsigned integer. 

EXAMPLES: IF (I) 10,20,30 
IF (X-3) 10,20 

IF ( (SIN (X) +2) / 3) 30,25,100 

NOTES: 1) Transfer to first label if expression is < 0. 

2) Transfer to second label if expression is = 0. 

3) Transfer to third label if expression is > 0. 

4) When the last label is omitted, transfer goes to the 
second label when the expression is >= 0: 

The following two examples are equivalent: 

IF (I) 10,20 
IF (I) 10,20,20 


logical IF 

PURPOSE: To allow action to be taken depending on a condi¬ 
tional expression within the IF. 

SYNTAX: IF (logical expression) statement 

where: logical expression - RE.LO.RE 
RE = arithmetic expression 
RO.= arithmetic expression 
RO = relational operator 
relational operators are: 


33 




Statement descriptions 


Fortran-64 


. EQ. - equal 
.NE. - not equal 
.LT. - less than 
. GT. - greater than 
. GE. - greater than or equal 
LO = logical operator 
logical operators are: 

. OR. - or 
.AND.- and 
. NOT. - not 

EXAMPLES: IF (X .EQ. 0) GOTO 10 

IF (I.LT. J+2) WRITE (4,*) I 

IF ((I.EQ. 1) .AND. (J.EQ. 2)) READ (0,10) 

A.B 

NOTES: 1) The following statements can only be used with IF 
THEN and cannot be part of logical IF; 

a) DO 

b) CONTINUE 

IF THEN 

PURPOSE: To allow conditional execution of a group of 
statements. 

SYNTAX: IF (logical expression) THEN 

statement 


END IF 

EXAMPLES: IF (I .EQ. 0) THEN 
READ (0,*) NAME 
WRITE (3,*) ' name isNAME 
I-I + 1 


34 



Abacus 


Statement descriptions 


NOTES: 1) The END IF statement terminates the end of the block 
statements. 


IMPLICIT 

PURPOSE: To override or confirm the type associated with the 
first letter of a variable name. 

SYNTAX: IMPLICIT typnam (char | char_range) 

{[,typnam(char I char_range) )] 

where: typnam is any standard data type, 
char is any letter of the alphabet. 
char_range is a character range. 

EXAMPLES: IMPLICIT REAL (A,B), INTEGER (C-R), 
LOGICAL (E) 

NOTES: 1) The IMPLICIT statement can only be used once in 
any program module. 

2) The type declaration can still override the type 
implicitly specified by the starting letter of a variable 
name. 


MEM 

PURPOSE: To examine or alter individual memory locations. 

SYNTAX: MEM (varnamlconstant)-integer 

expression 

varnam = MEM (varnam|constant) 

where: the argument between the () is an address 
between 1 and 65535 
varnam is an integer variable. 


35 



Statement descriptions 


Fortran-6 


EXAMPLES: MEM (16763) = 1 + 6 
I -MEM (0) 

MEM (IADD) = 4 

J — MEM (I ADD) + 6 — 3 * (J+2) / MEM (J) 

NOTES: 1) Using MEM on the left side of an equation is equiva 
lent to the poke in BASIC. Using MEM on the righ 
side of an equation is equivalent to the peek i. 
BASIC. 

2) Memory locations can only hold values between 1 
and 255. Only the low order byte of the integer i 
transferred to memory. Getting a value from memorj 
stores a 0 in the upper byte of the integer variable. 


OPEN 

PURPOSE: To establish a connection between a file and a devic 

SYNTAX: OPEN filenumber.devicenumber 

l.secondary address 
filename' I name)] 

where: filenumber, devicenumber and 
secondary address are constants or 
variables. 

1 filename' is the actual filename in 
quotes. 

name is the filename stored in an array of 
type CHARACTER. 

EXAMPLES: OPEN I,J,K,L 
OPEN I,J 
OPEN I,J,K 

OPEN I.J.K,' test file' 

NOTES: 1) Performs the same function as BASIC. 


36 


Abacus 


Statement descriptions 


2) Refer to a particular device manual for more informa¬ 
tion on the syntax of the OPEN statement for the 
device. 

PAUSE 

PURPOSE: To allow program execution to stop until a key on the 
keyboard is depressed. 

SYNTAX: PAUSE constant 

EXAMPLES: PAUSE 148 

NOTES: 1) Refer to the Commodore keyboard codes to deter¬ 
mine the value of the constant in the above syntax. 

PROGRAM 

PURPOSE: To name a program. After linking the program must 
be manually saved. 

SYNTAX: PROGRAM name 

EXAMPLE: PROGRAM TEST 

READ, (free-format) 

PURPOSE: To acquire data from the keyboard or from a file or 
device. 

SYNTAX: READ (f ilenum,* | *) ['string',] 

varnaml [.varnam] } 

where: filnum is an unsigned integer repre¬ 
senting the file-number used in the OPEN 
statement 


37 




Statement descriptions 


Fortran-64 


varnam is a simple variable, array element 
or array name of type CHARACTER. 

EXAMPLES: READ (10,*) A3,IX 

READ (0,*0 'Enter a value: ',IY 
READ (0,#) 'Enter Password',PASWD 


NOTES: 


1) A string to be used as a prompt can only appear as 
the first thing after the right parenthesis. 

2) Filenumber 0 is reserved for the keyboard. 

3) If a pound sign (#) is used in place of the asterisk 
(*), a no-echo read is performed. 

4) Only arrays of type CHARACTER can be read in 
directly. 

5) Logical values are read in as 'T' or 'F'. 

6) A READ statement without variables skips a record. 

7) A space is used as a delimiter between values of type 
INTEGER, REAL and LOGICAL. 


READ (formatted) 

PURPOSE: To acquire data from the keyboard or from a File or 
device according to a specified format 

SYNTAX: READ (filenum,label) varnam{ [.varnam] } 


where: f i lenum is an unsigned integer 

representing file-number used in the OPEN 
statement 

varnam is a simple variable, array element 
or array name of type CHARACTER, 
label is an unsigned integer constant. 

EXAMPLES: READ (10,100) A,B,IX 
100 FORMAT (2F8.2.I6) 

NOTES: 1) Filenumber 0 is reserved for the keyboard. 


Abacus 


Statement descriptions 


PURPOSE: 

SYNTAX: 

EXAMPLES: 

NOTES: 1) 

PURPOSE: 

SYNTAX: 

EXAMPLES: 

NOTES: 1) 

PURPOSE: 

SYNTAX: 

EXAMPLES 


RETURN 

To transfer control from a subprogram back to the 
calling program unit 

RETURN 

RETURN 

IF (x.LT. 0.0) RETURN 

Subprogram units must have at least one RETURN 
statement. 


STOP 

To allow program flow to cease and execution return 
to BASIC. 

STOP 
: STOP 

IF (ix.LT. 0) STOP 

STOP should only be executed within a main 
program unit 


SUBROUTINE 

To define the beginning of subroutine subprogram. 
SUBROUTINE subnam (varnam{ [.varnam] }} 

where: varnam is a variable. 

subnam is the subroutine name up to 5 
characters. 

: SUBROUTINE SUB 1 (x) 


39 




Statement descriptions 


Fortran-i 


I 

> 


NOTES: 1) The argument list determines two things about 
passing values: 

type of argument - determined by 1st character of 
varnam 

placement of argument - determines placement of 
parameters in a CALL statement 

2) An argument is always required even if it's a dummy 
argument. 

3) A subroutine is invoked by the CALL statement. 


TYPE STATEMENTS 

PURPOSE: To specify the type of variables listed in the state 
ment. 

SYNTAX: type varnam( [,varnam] } 

where: type is the variable type such a 
INTEGER,REAL,CHARACTER O 
LOGICAL. 

varnam is a variable definition. 

EXAMPLES: INTEGER STATE, COUNT, Z IP 
REAL COST, VALUE 
LOGICAL FLAG 
CHARACTER CH 
INTEGER K (10) 

NOTES: 1) This declaration overrides the type implicitly speci 
fied by the IMPLICIT statement 

2) An array can be dimensioned with a type statement 

3) This declaration assigns an explicit type to symboli 
names that would otherwise have their type implicitl 
determined by the first letter of their names. 

4) See Appendix C for data types. 


40 


Abacus 


Statement descriptions 


PURPOSE: 

SYNTAX: 

EXAMPLE: 

NOTES: 

PURPOSE: 

SYNTAX: 

EXAMPLE 

NOTES: 


WAIT 

To allow program execution to be suspended for a 
specified time period. 

WAIT n 

where: n is an integer constant. 

WAIT 2 

1) Resolution is in seconds. 


WRITE (free-format) 

To transfer data from memory to the screen, printer 
or file. 

WRITE(filenum,* !+){['string'Ivarnam| 
/decimal number,} ] 

where: filenum is an unsigned integer repre¬ 
senting the filenumber used in the OPEN 
statement 

varnam is a simple variable or array ele¬ 
ment or array name of type CHARACTER, 
/decimal number sends the single byte 
equivalent of the decimal number. 

WRITE (10,*) 'The answers are: ',A,B,IX 
WRITE (3,*) /147.IX,' is the value.' 

WRITE (3,+) ' ENTER YOUR PASSWORD : ' 

1) Filenumber 3 is reserved for the screen and need not 
be opened previously. 

2) Only arrays of type CHARACTER can be written out 
directly. 

3) Logical values are written out as T or F. 


41 



Statement descriptions 


Fortran-! 


i 


4) A write statement without variables isn't permittee 

5) The following field lengths are used on outputs: 

REAL 12 Columns 

INTEGER 6 Columns 

LOGICAL 1 Column 

CHARACTER 1 Column 

CHARACTER array number = size of array 

6) If the ’+' symbol is used instead of the symbol, 
no return WRITE is performed. 


WRITE (formatted) 

PURPOSE: To transfer data from memory to the screen, printe 
or file according to a specified format. 

SYNTAX: WRITE (filenum,label) variable 

{ [.variable]} 

where: filenum is an unsigned integer repre 
sen ting the filenumber used in the OPE 
statement. 

variable is a simple variable or arra; 

element or array table. 

labe 1 is an unsigned integer constant I 

EXAMPUES: WRITE (10,100) A3,IX 
100 FORMAT (2F8.2.16) 

NOTES: 1) Filenumber 3 is reserved for the screen and need nc 
be OPENed first. 

2) Filenumber 4 and 5 are reserved for the printer. 

3) Filenumber 8,9,10,11 and 15 is reserved for the dis! 
drive. 

4) Only arrays of type CHARACTER can be writta 
directly. 


42 





Abacus 


Statement descriptions 


5) A WRITE statement without a label referencing a 
format skips a record or line. 


OPERATORS 

+ Addition 

Subtraction 

* Multiplication 

/ Division 

Integer Exponentiation 

(see built in functions for real 

exponentiation) 


43 




Appendix A—Built-in functions 


Fortran-64 


APPENDIX A 
BUILT-IN FUNCTIONS 


Trigonometric functions: 


(trig.lib) 
















Abacus 


Appendix B—Format descriptor 


APPENDIX B 


FORMAT DESCRIPTOR 


Aw 

CHARACTER type 


LOGICAL type 

FTI^B 

INTEGER type 

m 


E33DM 

■nsamesnEEJSsss* 


Skip n positions 

fMKKM 

«r»i>ir- !■ *'-... i" 


literal characters (ignored in the formatted 

read) 

where: 



45 

















Appendix C—Data types 


Fortran-64 


APPENDIX C 


DATA TYPES 

MAGNITUDE 

INTEGER 16 bits 17 8 

*SIGN 

MANTISSA 

REAL 32 bits 1 7 8 8 7 1 

*SIGN EXPONENT* 

SIGN* 

UNDEFINED 

LOGICAL 16 bits 17 8 

*SIGN 

CHARACTER 8 bits 8 

ASCII VALUE 


46 


Abacus 


Appendix D—Error descriptions 


APPENDIX D 


ERROR DESCRIPTIONS 

error message format: * * * * * ERROR xxx yyy * * ** 


= error number from list below 
= character position in line that caused 
the error (not including spaces) 


Examples: IF (x .LT. 1.0 GOTO 10 

*****ERROR 008 012**’ 




0 


1 

slash missing 

2 

constant missing 

3 

illegal type 

4 

quantity of elements exceeds size of 


array 

5 

array too large 

6 

array not dimensioned/variable has 


no initial value 

7 

element subscript outside boundary 


of dimensioned array 

8 

parenthesis missing 

9 

bad repeat specifier 

10 

invalid real number 

11 

sign missing 

12 

exponent too large 

13 

exponent missing 

14 

number or label too large 

15 

comma missing 

16 

value not assigned to identifier 

17 

filename too large 


47 








r 


Appendix D—Error descriptions 





nptor m tormat 
only 2 dimension array permitted 
first statement or END missing 
quote missing 
symbol table overflow 
invalid identifier name 
identifier already defined 
implicit statement used more than 
once 

format not found 
format too long 

data memory requirements too large 
object file too big 

no corresponding label for DO loop 
undefined 
label not found 
constant must be integer 
’=' expected 
identifier not found 
increment cannot be zero 
DO's nested too deep 
type mismatch 
invalid operator 
parameter expected 
'if nested too deep 
<cr> <Retum> expected 
corresponding 'IF not expected 
SUBROUTINE expected 
comma expected 
inteeer variable 



48 









Abacus 


Index 


INDEX 


Built in functions 44 

CALL 23 

CALL EXEC 23 

CLOSE 24 

Color mode 16 

COMMENTS 24 

COMMON 25 

Compiler mode 9 

CONTINUE 25 

DATA 26 

Data types 46 

DIMENSION 27 

Directory 18 

DO 27 

ELSE 28 

END 29 

ENDCOMMON 30 

ENDIF 29 

Error descriptions 47 

FORMAT 31 

Format descriptor 47 

FUNCTION 30 

GOTO 32 

Help mode 15 


IMPLICIT 

35 

Linker mode 

12 

MEM 

35 

OPEN 

36 

Operators 

43 

PAUSE 

37 

PROGRAM 

37 

Program format 

4 

READ. 

37, 38 

RETURN 

39 

STOP 

39 

SUBROUTINE 

39 

Translator mode 

17 

Type statements 

40 

WAIT 

41 

WRITE 

41,42 


IF 

IF THEN 


33, 35 
34 


49 













































MM 
























BeckerBASIC for GEOS 

Now you can write BASIC applications to work with GEOS 





































Cadpak 











































































































































Selected Abacus Ml Products forjDommodore computers 




































Learn the the language of 
the 80'9 and beyond 
on your 064 and 128 



















