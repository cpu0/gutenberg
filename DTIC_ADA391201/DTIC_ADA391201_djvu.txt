
THE DISTRIBUTER’S THREE-DIMENSIONAL PALLET-PACKING 
PROBLEM: A HUMAN INTELLIGENCE-BASED 
HEURISTIC APPROACH 

THESIS 


Erhan BALTACIOGLU, First Lieutenant, TUAF 
AFIT/GOR/ENS/01M-02 

DEPARTMENT OF THE AIR FORCE 
AIR UNIVERSITY 

ATR FORCE INSTITIJDE OF TECHNOLOGY 

Wright-Patterson Air Force Base, Ohio 

APPROVED FOR PUBLIC RELEASE: DISTRIBUTION UNLIMITED. 


20010619 005 







The views expressed in this thesis are those of the author and do not reflect the official 
policy or position of the United States Air Force, Department of Defense, or the U. S. 
Government. 




AFIT/GOR/ENS/Ol M-02 


THE DISTRIBUTER’S THREE-DIMENSIONAL PALLET-PACKING 
PROBLEM: A HUMAN INTELLIGENCE-BASED 
HEURISTIC APPROACH 

THESIS 

Presented to the Faculty 
Department of Operational Sciences 
Graduate School of Engineering and Management 
Air Force Institute of Technology 
Air University 

Air Education and Training Command 
In Partial Fulfillments of the Requirements for the 
Degree of Master of Science 

Erhan BALTACIOGLU, B.S. 

First Lieutenant, TUAF 

March 2001 


APPROVED FOR PUBLIC RELEASE; DISTRIBUTION UNLIMITED. 




AFIT/GOR/ENS/Ol M-02 


THE DISTRIBUTOR’S THREE-DIMENSIONAL PALLET-PACKING PROBLEM: A 
HUMAN INTELLIGENCE-BASED HEURISTIC APPROACH 


Erhan BALTACIOGLU, 
First Lieutenant, TUAF 


Approved: 

Janies T. Moore, Lt Col, USAF (RET) (Advisor) date 


Raymond R. Hill, Jr., Lt Col, USAF (Reader) 


date 




Acknowledgements 


I would like to thank my thesis advisor, Dr. James T. Moore and my thesis reader 
LtCol Raymond Hill for their guidance, support and being fully open to innovative ideas 
through this research. Their experience and knowledge helped me to have continuous 
progress on my thesis and to develop a successful model. 

I also would like to thank the Turkish Air Force for providing me such a quality 
Master’s program opportunity. I will take full advantage of the experience that I got in 
this program, in my whole life to serve my country better. 

Mr. and Mrs. Graziers also deserve a lot of thanks for the support they provided 
me during these trying months. 

Lastly, I am extra grateful to my parents and my family for all the values they 
taught me, which helped to complete this program. 


IV 



Table of Contents 


Page 

Acknowledgements.iv 

Table of Contents.v 

List of Figures.vii 

List of Tables.viii 

Abstract.ix 

Chapter 1 - Background and Statement of the Problem.1-1 

1.1 Introduction.1-1 

1.2 Background.1-2 

1.3 Statement of the Problem.1-4 

1.4 Scope and Methodology.1-5 

1.5 Overview.1-7 

Chapter 2 - Literature Review.2-1 

2.1 Introduction. 2-1 

2.2 Previous Research.2-1 

2.3 Existing Commercial Software Packages.2-13 

Chapter 3 - Methodology.3-1 

3.1 Introduction.3-1 

3.2 Overview.3-1 

3.2.1 Human Intelligence. 3-3 

3.2.2 Attributive Memory.3-4 

3.3 Input Data.3-4 


v 
























3.4 Data Structure.3-5 

3.5 Numerical Limits.3-7 

3.6 Flow Chart of The Algorithm.3-7 

3.7 How Does The Heuristic Work?.3-10 

3.7.1 Preparation For Iterations.3-10 

3.7.2 Execution Of An Iteration.3-13 

3.8 Output Data.3-19 

3.9 Graphical Interface Program.3-21 

3.10 Summary.3-21 

Chapter 4 - Results.4-1 

4.1 Introduction.4-1 

4.2 Numerical Tests and Comparisons.4-1 

4.3 Summary.4-8 

Chapter 5 - Conclusions and Recommendations.5-1 

5.1 Research Results.5-1 

5.2 Recommendation for Future Research.5-2 

Appendix A - Pseudo-codes of The Functions.A-l 

Appendix B - The C Program Code of the Model.R-l 

Appendix C - The C Program Code of the Visualizer.C-l 

Appendix D - The Test Problems That We Generated.D-l 

Appendix E - Solutions of B/R Test Sets.E-l 

Bibliography.BIB-1 

Vita.V-l 


vi 


























List of Figures 


Page 

Figure 3-1: Input File Format.3-4 

Figure 3-2: Flow Chart of the Algorithm.3-9 

Figure 3-3: Creating the Boxlist[] Array.3-10 

Figure 3-4: Creating the LayersQ Array.3-12 

Figure 3-5: Packing a layer.3-15 

Figure 3-6: Findbox Function Parameters.3-16 

Figure 3-7: Leaving a Gap Unpacked.3-17 

Figure 3-8: Layer in Layer Packing.3-18 

Figure 3-9: Visudat File Format.3-20 

Figure 3-10: Output File Format.3-21 

Figure 4-1: Creating Box Sets.4-2 


vii 














List of Tables 


Page 

Table 3-1: Key Packing Program Functions.3-15 

Table 4-1: Randomly generated problem solutions.4-1 

Table 4-2: Specially Generated Problem Solutions.4-3 

Table 4-3: Specially Designed MPPP Solutions.4-3 

Table 4-4: Solution Summary Of The Given Problem Set.4-4 

Table 4-5: Comparisons for the Bischoff/Ratcliff Examples.4-4 

Table 4-6: Comparisons for the Loh/Nee Examples.4-5 

Table 4-7: Chen et al. and Faina’s Example Box Set.4-6 

Table 4-8: Comparisons with Premature Solution Times.4-7 


viii 












AFIT/GOR/ENS/01M-02 


Abstract 

The Distributor’s Pallet Packing Problem is to load a set of distinct boxes with 
given dimensions on pallets or in containers to maximize volume utilization. This 
problem is still in its early stages of research, but there is a high level of interest in 
developing effective models to solve this NP-hard problem to reduce the time, energy and 
other resources spent in packing pallets. 

In its search to improve operations, the Air Force is also making an effort to solve 
this problem. Building an analytical model and developing a genetic algorithm approach 
have been tried, but the problem requires additional research and there is a need to 
produce realistic solutions in a reasonable amount of time. 

We develop a special heuristic algorithm and code it in the C programming 
language. In our model, we used powerful heuristic tools and dynamic data structure to 
mimic human intelligence, providing a new solution approach to pallet packing. We 
created another program to visualize packing results. Tests on hundreds of problems 
show that our model makes the most of volume utilization in minimal time making it a 
leader among presented and published works. 


IX 



THE DISTRIBUTER’S THREE-DIMENSIONAL PALLET-PACKING 
PROBLEM: A HUMAN INTELLIGENCE-BASED 
HEURISTIC APPROACH 

Chapter 1 - Background and Statement of the Problem 

1.1 Introduction 

Everyday many items are shipped from one place to another. These items are put 
in containers or pallets. To ship more items while spending less energy, time and money, 
the items should be packed optimally, or at least near optimally. This problem becomes 
even more important when we start to talk about air shipping. 

The Air Force uses standard HCU-6/E (463L) pallets in air shipping. The length 
and the width of the pallets are 88 inches (7 feet 4 inches) and 108 inches (9 feet), 
respectively. However, only 84 inches of the length and 104 inches of the width are 
actually available. Loadmasters are required to leave the outside two inches of the pallet 
unpacked so a cargo net can securely fit around the packed boxes. The maximum height 
of a pallet is 96 inches (8 feet) for pallets loaded in the main compartment and 76 inches 
(6 feet 4 inches) for pallets loaded on the ramp (Taylor, 1994). 

By eyeballing the items to be packed, experienced Air Force loadmasters can 
efficiently pack Air Force standard HCU-6/E (463L) pallets. However, the questions are 
“How efficiently do they pack?” or “Can those items be packed more efficiently and even 
provide a reduction in the number of sorties required?” A scientific approach is required 
to answer these questions. 

For these reasons, the Air Force is in search of a model that will help efficiently 
pack the pallets and provide loadmasters with a report stating where the boxes should be 


1-1 



placed on the pallet to minimize unused space. This will save time and resources. If the 
pallets are more efficiently packed, the number of sorties flown may decrease and aircraft 
may be freed to carry other items in large-scale mobilizations (Ballew, 2000). 

1.2 Background 

This research is a follow-on of Ballew’s (2000) research. He developed an 
integer programming mathematical formulation of a simplified version of the three- 
dimensional pallet-packing problem. Some of the problem’s constraints were not 
included in the formulation. Unfortunately, the solver package found a local optimum to 
a simplified and small problem (just 3 boxes). The formulation of a bigger problem with 
more boxes is not practical because the number of variables and constraints increase 
incredibly fast as the number of boxes increase. Ballew did employ a simple genetic 
algorithm to solve a slightly larger but still a small problem (11 boxes) but found no 
reasonable solution within 45 minutes. 

The Air Force has sponsored research in this area on multiple occasions in search 
of a better way to pack the pallets and load the aircraft. These include an early effort by 
Taylor (1994), research on an airlift-loading model by Chocolaad (1998) and Romaine 
(1999), and a three-dimensional packing problem approach by Manship and Tilley 
(1998). None of the developed techniques are able to pack hundreds of various sized 
boxes on an HCU-6/E (463L) pallet while considering realistic constraints. They also do 
not have acceptable solution times for this problem. 

Bischoff, Janetz, and Ratcliff (1995) developed a three-dimensional heuristic 
approach to pack multiple sized boxes on a pallet. Their algorithm packs the boxes in 


1-2 


layers allowing up to two different box types per layer; however, it gives preference to 
layers filled by a single box type. The algorithm did produce stable loads, but as the 
number of various sized boxes increased, the packing efficiency declined. 

Martello, Pisinger and Vigo (2000) developed a branch-and-bound algorithm to 
solve a three-dimensional bin-packing problem. Their solution however, is not strictly 
three-dimensional. They first construct bin slices having width W, height H, and 
different depths. The slices are then combined into three-dimensional bins. However, 
they do not include various important constraints, and they assume that no items can be 
rotated. Under these relaxed conditions, their approach had good results. 

Real world packing problems are complex and have many constraints. The boxes 
have different weights, volumes, and dimensions. The varied dimensions of the boxes 
can cause gaps in the usable packing space. Additional wasted space can be caused by 
weight balancing and box placement restrictions. Hence, in most cases, the total volume 
of the boxes packed is considerably less than the available volume of the container. Most 
research has focused on packing a certain number of boxes in a container. But in a real 
world problem, this is not always the case. One tries to pack as many boxes as a 
container can hold before moving to another container. Because this changes the domain 
space, considering this important point changes the approach that must be taken to get a 
good solution 

The three-dimensional packing problem is a natural generalization of the classical 
one- and two-dimensional problems, and therefore it is NP-hard (Reeves 1995). This 
means that, in general, optimal solutions are computationally impractical to achieve. For 
this reason, most of the studies have focused on the practical aspects of loading a 


1-3 



container and developing heuristic solutions based on the concept of filling out the 
container with boxes organized in layers, walls, and columns. In other cases, two- 
dimensional pallet packing heuristics are applied to the general three-dimensional 
container-loading problem. These heuristics are, in general, on-line packing algorithms, 
which means they pack boxes one-by-one in a given order. More precisely, when the 
algorithm is packing a box, it has information only about the boxes previously packed, 
and once a box is packed, it cannot be moved to another place. This technique is not 
efficient and is also not applicable, when applying the load balance and other constraints. 

Since the pallet-packing problem has a large solution space, it is extremely 
difficult to prove a solution is the global optimum. Only with many different sets of 
boxes can an algorithm be tested and its performance evaluated. 

1.3 Statement of the Problem 

The problem is a three-dimensional pallet-packing problem. There are basically 
two general types of pallet packing problems. They are the “manufacturer’s pallet 
packing problem” and the “distributor’s pallet packing problem.” The ‘manufacturer’s 
pallet packing problem’ is easier to solve since it seeks the optimum layout of identical 
rectangular boxes on a rectangularly shaped pallet. 

For the “distributor’s pallet packing problem,” the objective is to load boxes of 
varying dimensions onto as few pallets as possible (Askin and Standridge, 1993). This 
problem is more difficult to solve than the manufacturer’s problem. For the case in 
which only one pallet is loaded, the objective is to minimize unused pallet space since Air 
Force 463L pallets are usually “cubed out” before they are “grossed out” (Taylor, 1994). 


1-4 




This means that, in general, the total available volume of a pallet is filled before its 
weight limit is reached. Most of the time, the items packed are rectangular in shape, and 
this property makes the problem easier to solve, compared to trying to pack items with 
different shapes. 

The problem is to pack as many boxes as possible from a given set of rectangular¬ 
shaped items into a three-dimensional rectangular bin. The objective is to minimize the 
unused bin volume while considering many different kinds of constraints. These 
constraints are explained in the Scope and Methodology Section. The problem is 
strongly NP-hard and extremely difficult to solve in practice (Martello, Pisinger and 
Vigo, 2000). 

The purpose of this research is to develop a three-dimensional pallet-packing 
algorithm and an executable written code employing the developed algorithm. 

1.4 Scope and Methodology 

In our problem, all items are rectangular boxes. We solve this problem as a 
single-pallet packing problem, not as a multiple-pallet packing problem where an entire 
aircraft is loaded. Trying to pack all pallets to be loaded on an aircraft is more difficult to 
solve. The reason is that the balance of the aircraft has to be considered, and this means 
that the problem has to be considered as a single hierarchical problem, instead of being 
considered as a combination of several single-pallet packing problems. 

Our single pallet problem has many constraint types. The first one is that every 
box takes a unique space in the pallet, with no overlapping allowed. A second type 
prevents packing beyond the dimension limits of the pallet. Another constraint type 


1-5 




actually accounts for several different restrictions. The packing must be realistic. It must 
be stable. No overhang is allowed when the boxes are packed. For a box to be packed, 
its entire base must be on top of either the pallet or other boxes. Boxes can be rotated and 
packed with one of six different options. Heavy boxes should be packed below lighter 
ones. For flight safety reasons, the Air Force prefers the center of gravity of a loaded 
pallet to be within four inches of the center of the pallet. (TASC, 1998) 

The problem is extremely hard to solve with all the constraints stated above. 

Most approaches start simple and then add other constraints. Some simplifying 
assumptions are employed in our approach. In our approach, we initially include the first 
two constraint types. So that every box takes a unique space in the pallet (no 
overlapping allowed) and packing beyond the dimension limits of the pallet is prevented. 
We also allow packing of the boxes in all six orientations. Before a pallet is loaded onto 
a plane, the loadmaster secures the pallet by tying down cargo nets around the load. 

Thus, in our approach the top of the load is close to level to accomodate the cargo net. 
When the cargo net is thrown over a load, level at the top, boxes do not shift or fall. 

We also allow overhang and unstable packing to simplify the problem, so some 
boxes might not have a complete foundation under them. Since Air Force 463L pallets 
are usually “cubed out” before they are “grossed out” (Taylor, 1994), we omitted all 
constraints dealing with weight and center of gravity. 

We do not employ an existing heuristic technique such as genetic algorithms, tabu 
search, or simulated annealing. A genetic algorithm is not sufficient because it does not 
appear practical to consider all of the stated constraints while performing a multiple 
crossover and expect termination in a reasonable time. Representing a solution in a 


1-6 



genotype form with hundreds of boxes turns out to be a very long gene, which 
excessively increases the storage space and the computational time. Tabu search is not 
applicable because one cannot define the move that we need to apply to our problem. 

Since the boxes have various dimensions, it is impractical to define the move as a 
swapping of locations of two boxes. Simulated annealing is a stochastic heuristic 
technique which has been employed by Faina (Faina, 2000) and it is not, in our opinion, 
intelligent enough for this problem type. When we try to pack a large number of boxes, 
we have a very large solution space and this renders stochastic techniques very 
inefficient. 

We create our own problem-specific heuristic technique using a composition of 
the tools that other heuristic methods use. We develop an adaptive heuristic algorithm 
modeling human intelligence. We employ an algorithm that combines an adaptation of 
the human intelligence with extensive data analysis applied to the candidate boxes by « 

taking the advantages of some smart programming tools and data structures. We write 
the three-dimensional pallet-packing algorithm in the C programming language. We test 
it with several different sets of boxes, and apply a validation and verification process. 

1.5 Overview 

Chapter Two presents a detailed review of past work and some solution 
techniques developed to solve three-dimensional packing problems. Additionally it 
presents information about the most promising commercial three-dimensional pallet 
packing software packages. 


1-7 



Chapter Three describes in detail the heuristic algorithm we developed along 
with the data structure and other programming tools used. Chapter Four presents 
solutions generated by our approach for different sized and different featured problems 
while discussing and comparing the qualities of each solution with previously 
published solutions. Chapter Five provides conclusions and recommendations for 
future work. 


1-8 



Chapter 2 - Literature Review 


2.1 Introduction 

The packing problem is a problem with many different variants. Tbe early form 
of this type of problem was the one-dimensional packing or partitioning problem, in 
which a set of n positive values Wj, e.g. weight values, must be partitioned into the 
minimum number of subsets so that the total value in each subset does not exceed a given 
bin capacity W. 

The two-dimensional bin-packing problem extends the one-dimensional bin¬ 
packing problem. Instead of considering only one set of positive values, we consider two 
different sets of positive values, namely two different dimensions, e.g. width and length 
of the rectangular pieces to be cut out of big industrial plastic film. As expected, this 
problem is harder to solve than the one-dimensional bin-packing problem. 

These packing problems are NP-hard problems. NP stands for ‘non-deterministic 
polynomial’. NP-hard means the solution time increases exponentially as the size of the 
problem increases. The three-dimensional bin-packing problem is strongly NP-hard 
because the three-dimensional bin-packing problem is a special case of the one¬ 
dimensional bin-packing problem (Martello, Pisinger and Vigo, 2000). 

2.2 Previous Research 

Packing problems have been considered by a number of researchers, but past 
work was largely restricted to the one- or two-dimensional cases. It is widely agreed that, 
due to its complexity, any analytical solution to this problem is unlikely in the 


2-1 



foreseeable future. As a result, most those successful approaches to the problem have 
taken the form of heuristics. 

The volume of published work discussing three-dimensional solutions is still very 
limited due in part, one suspects, to the level of complexity involved, and there appear to 
be no clear measures of success (or failure). This might be expected in light of a survey 
of such analysis for the two-dimensional problem by Coffman and Shor (1990). This 
survey concludes that the field is still in the early stages of development—algorithms and 
probability models tend to be simplistic, and estimates of performance are far more 
common than exact measures. As the three-dimensional case is less well-studied and 
more complex, it is not surprising that the published work generally presents successful 
implementations, but it fails to provide the reader with any clear measure of scientific 
success. They do, however, provide some interesting insights into the various views on 
how successful packings are best achieved. Most of the approaches are based on a basic 
wall-building concept although, as described below, this is achieved in a variety of 
different ways. 

Among the earliest publications are those of Tinarelli and Addonizio (1978) and 
George and Robinson (1980). The former of these papers addresses the problem of 
minimizing the number of containers used for transporting a given cargo. Identical items 
are grouped together and layers are developed. These generally take a simple block form. 
George and Robinson (1980), in the first English language paper to directly address the 
container loading problem, describe in detail an algorithm developed to load a container 
with cargo consisting of a number of distinct types (sizes) of boxes. They utilize a fairly 
sophisticated 'wall building' approach in which sections of the container across the full 


2-2 



width and height are packed. Such an approach in many ways mirrors how die real-life 
packing of containers is carried out, and ensures that cargo of the same type is largely 
kept together. They describe the implementation of their algorithm for a cargo of 20-box 
types. A variety of solutions may be obtained by commencing packing with different box 
types and utilizing different orientations. When there are insufficient boxes to complete a 
wall utilizing one box type, spaces are generated above and to the right of the wall and 
these are packed utilizing a space filling procedure. At all times, the method attempts to 
retain a flat forward packing face. The procedure endeavors to keep boxes of like type 
together by defining 'open' and 'closed' box types, and it also accounts for box orientation 
constraints. Open type boxes are certain box types that are already started to be packed, 
while closed type boxes are the boxes of the types that are yet to be used. 

Bischoff and Dowsland (1982) had an approach also based on the principle of 
filling the container by building layers across its width. However, there are two main 
differences between their procedure and that of George and Robinson: first, each layer is 
constructed only from a single type of box; and second, the arrangement of boxes within 
a layer is determined through a two-dimensional packing procedure, which aims to 
maximize the area utilization of the cross-section (i.e. of the rectangle formed by the 
width and height of the container). This two-dimensional pallet-packing procedure is a 
heuristic and was originally proposed as an approach for calculating efficient layout 
patterns for boxes on a pallet. 

The filling of spaces in a layer is not considered in the procedure proposed by 
Bischoff and Dowsland (1982) and therefore the order in which the layers are formed has 
no influence on the packing efficiency achieved. The criterion used to decide the depth 


2-3 



dimension of a layer, however, is of crucial importance. Each of the three sides of a box 
is examined in turn as a potential depth dimension for a layer. With this dimension fixed, 
the maximum number of boxes, which can be accommodated in the cross-section, is then 
determined by means of the two-dimensional packing routine. In other words, if the 
container width and height are denoted by W and H, and the three box dimensions are w, 
l and h, respectively, with, say, w being currently considered as the depth of the layer, the 
figure calculated is the number of rectangles IX h which fit into the rectangle W X H. If 
this is greater than the number of boxes of that particular type still to be loaded, a full 
layer cannot be formed and the depth dimension concerned is consequently dropped from 
further consideration. If, on the other hand, there is more than one possible depth-wise 
orientation yielding a complete layer, a choice needs to be made between them. One 
obvious criterion for making this choice is the percentage fill of the cross-section (in 
either volume or area terms). Following another rationale, however, it might be desirable 
to attempt to maximize the number of boxes which are accommodated in complete layers. 
It could therefore be advantageous to select the orientation, which leaves the least number 
of boxes unpacked once as many identical layers as possible have been constructed. 

At some stage in this procedure, a point will be reached where either all boxes are packed 
in complete layers or -as is more likely- it is not possible to form further complete layers 
of any box type. In this case the remaining boxes are packed using the George and 
Robinson (1980) approach. 

Mention has already been made of the fact that in many cases several different 
variants of the same heuristic can be devised. George and Robinson (1980) explicitly 
point out the two alternative rules for choosing among open box types. In a set of trial 


2-4 


runs discussed in George and Robinson’s (1980) paper, the results obtained by using the 
second rule -which orders open types according to the same principle as closed types- 
were slightly better, but the authors make no general suggestions as to which criterion 
should be used for more efficient packings. Test runs with a different priority key for 
unopened box types are also referred to in their paper. Here the authors conclude, "that 
the original priority structure more often gives the best results". However, no precise 
details are given of how much better the results obtained were and, vice versa, how much 
worse they were when another ranking rule produced the best solution. 

A wall building approach is a natural simplification of the problem. It forms an 
important component of the algorithm described by Bischoff and Marriott (1990), and 
has been adopted by a number of other authors. Liu and Chen (1981) also present a wall- 
based algorithm in which they consider the different ways in which valid box orientations 
may be used to maximize the widthwise utilization of the container. Having assigned the 
wall base, a similar approach is applied to the container height. Gehring, Menschner and 
Meyer (1990) also present a heuristic for packing non-identical items within a container. 
They, like George and Robinson (1980), utilize the idea of packing sections of the 
container across the full width and height. They utilize an ordering based on decreasing 
volume, and having placed the first block in a section (layer), the layer determining box 
(LDB), they develop a packing across the container floor first and then upwards. This 
tends at first to produce something of a decreasing wedge across the width of the 
container. The authors report that good solutions are obtained, but they only present 
results for its application on two problems. They too ensure that they retain a flat front 
packing wall but differ from George and Robinson (1980) in that they prohibit boxes 


2-5 




from straddling adjacent layers. As they state, this approach does ensure that cargo 
sections can be moved around so as to provide appropriate weight redistribution, but it 
will clearly lead in some instances to reduced volume utilization. A further aspect 
associated with not allowing boxes to straddle sections is that of load stability. Packings 
where boxes do straddle between layers can produce a more cohesive load. 

Han, Knott and Egbelu (1989) show that the idea of walls need not be restricted to 
the vertical sides of the container. They describe an algorithm in which the container 
(major prism) is packed with identical boxes (minor prisms). The algorithm as described 
is designed for only a single box type that is constant in both size and shape and no 
practical constraints are considered. The approach is to produce packings of L-shaped 
modules, with the initial module considered spanning the whole of the container base, 
and one of the container walls. The arrangement within the 'L' is determined by dynamic 
programming (similar to the approach of Steudel, 1979), which maximizes the edge 
utilization. The idea of building walls along any of the six faces of the container is an 
interesting one; however, the example they use fits one less box than that obtained by 
stacking multiples of two different 'wall' arrangements on the floor of the container. The 
weakness in the approach of Han et al. (1989) is a result of maximizing the utilization of 
the perimeter of the 'L' module. No evidence is presented to suggest why an L-shaped 
module approach should be adopted. (Their example consists of packing a container of 
size 48" by 42" and 40" with boxes 11" by 6" by 6". They are able to fit 195 boxes, a 
95.16% volume utilization of the container. They quote the US General Services 
Administration whose published results (1966) for the same problem only provide 82.5% 
utilization). 


2-6 



Bischoff and Marriott (1990) did a case study on the development of composite 
heuristics, without proposing any solution procedures. The case study has reported and 
discussed the results of an analysis of 14 heuristic procedures for producing efficient 
container loading patterns, based on a two-dimensional packing technique. It has been 
shown that the performance of such heuristics may be very domain-dependent and, more 
particularly, may vary crucially with the number of different items in a load. The 
approach described was demonstrated to be superior, but only for certain types of 
problems. 

The Bischoff and Marriott study used an idealized problem formulation in which 
cargo weight, materials handling aspects and other such factors were not considered and 
the objective was defined as minimizing the container length needed to accommodate a 
given cargo. The situation handled in the paper is different from merely determining a 
feasible arrangement for stowing all of a given cargo. The results of the study suggest 
that the most efficient order is likely to depend on the number of different box types in 
the' cargo under consideration. 

The heuristic method suggested by Haessler and Talbot (1990) is based primarily 
on the assignment of boxes to stacks, these then being placed across the container. 
Although this is done in part in order to simplify the problem, an approach based upon 
sectioning the packing face into two or more components, 'sub-walls', which fall between 
the ideas of stack and 'full-walls', may be worth pursuing. Haessler and Talbot's heuristic 
also utilizes the fact that they allow the adjustment of order quantities so as to make best 
use of the space available. 


2-7 



Mohanty, Mathur and Ivancic (1994) proposed a multi-dimensional knapsack 
problem approach to the three-dimensional packing problem dealing with filling up 
various containers with boxes. Their objective was to maximize utilization of the space 
in the containers or the value of the contents of the containers. They present a column 
generating procedure which heuristically uses a ‘greedy approach’ to generate columns 
one at a time, without considering any constraints other than overlapping and dimensions 
of the containers. Since they use a ‘greedy approach’, their approach is not robust and is 
strongly affected by the number of different items to be packed. 

Chen, Lee, and Shen (1995) presented a zero-one mixed integer linear 
programming model for the general three-dimensional container-loading problem. The 
problem involves packing a set of non-uniform cartons into unequal-sized containers. 
The model considers die issues of carton orientations, multiple carton sizes, multiple 
container sizes, avoidance of carton overlapping, and space utilization. Several special 
container loading problems such as selecting one container from several alternatives, 
weight balance, and variable container length were addressed. The modifications to the 
general model needed for these situations were also provided. Very small-scale example 
problems (with only 6 cartons) were illustrated to validate the models. For further 
development, additional constraints can be introduced to the models to include other 
concerns in the container-loading problem such as the stability of the packing pattern, 
stackability, the integrity of each carton type, and weight restriction. Unfortunately, this 
work presented only an analytical model. Using this model, it is impossible to solve a 
real world problem, since the number of variables and the number of constraints increase 
quadratically as the number of cartons increases (it grows as 2n 2 , where n is the number 


2-8 




of cartons). Also, in the conclusion section, the author says that a more efficient solution 
procedure is needed to solve large-scale container loading problems. 

Bischoff, Janetz and Ratcliff (1995) developed a model producing a high degree 
of stability. The basic concept underlying their algorithm is simple: The loading pattern 
is constructed from the bottom upwards using single layers of up to two different box 
types at a time. The choice of box type(s) and orientation(s) is governed by the resulting 
utilization of the loading surface onto which a layer is to be placed. They developed and 
tested three algorithms with slight modifications: the first one packs up to two different 
box types per layer, the second one packs up to two different box types but of the same 
height, and the third one allows packing only one box type per layer. They solved 1400 
different problems and compared three algorithms’ solution efficiencies. Their most 
efficient model was the first one, but as the number of different box types increases, the 
solution quality declines. 

Temo, Scheithauer, SommerweiO and Riehme (1997) employed a different 
heuristic algorithm. In addition to the dimension and overlapping constraint, they take 
total weight limit of the pallet and the stability constraints into account. They basically 
employed a layering approach while packing each layer by using a branch and bound 
solution method. They solved 700 problem sets among the problems that Bischoff et al. 
(1995) solved and made comparisons with past work. Their solutions were better than 
Bischoff et al. ’s solutions, but since their model was mainly designed for the 
“Manufacturer’s Pallet Packing Problem”, as the number of different items increases, the 
volume utilization declines. 


2-9 




Martello, Pisinger and Vigo (2000) present a branch-and-bound method to solve 
the three-dimensional packing problem. They tried to orthogonally pack all the items 
into the minimum number of bins. A computational test is presented showing that 
problems with the number of boxes less than 30 and 50 were solved. When the average 
number of items per bin gets bigger, the problem becomes harder to solve. Another 
weakness was that they assumed that the items may not be rotated. They considered only 
basic type of constraints (overlapping and bin dimension limits). 

Faina (2000) developed a geometrical model that reduces the general three- 
dimensional packing problem to a finite enumeration scheme. Cartons were loaded only 
on volume restrictions; no other restrictions were considered, and the boxes can assume 
any of the six possible orthogonal orientations. He pointed out that adding more 
constraints could possibly result in the algorithm giving worse results. He also says that 
the use of an approximation algorithm, which derives from a truncation of a global 
optimization algorithm, is, from all points of view, better than a mere heuristic procedure, 
but he does not substantiate this statement. He developed a simulated annealing 
algorithm called zone 3 d. The results of many statistical tests were given with different 
numbers of boxes. He had many approximations in his algorithm and due to these 
approximations, he explained that the algorithm is not guaranteed to find a global 
minimum of the wasted container volume. 

Faina (2000) starts his algorithm with the first box placed at the origin. By 
induction, it is supposed that the i 111 box has been located; now the method of zones 
locates at most 2n+l points where the (i+l)* box could be located, and this point is 
chosen at random; and so on. In this way the initial configuration is obtained. Then the 


2-10 




algorithm performs a small perturbation to this initial configuration by altering slightly 
the order of the boxes, for instance by changing the positions of any two boxes at 
random, and by constructing a new configuration. 

With up to 32 boxes, Faina could choose cooling schedules which support at best 
the quality of the final placings; but with over 64 boxes, the effort to improve the final 
placing is too unfavorable from a computational point of view. Therefore, the results 
obtained get worse as the number of boxes increases. 

Ballew (2000) developed a mathematical formulation similar to the analytical 
method of Chen, Lee, and Shen (1995), by using nonlinear integer programming on a 
simplified version of this problem. He presented a general mathematical formulation. 
Unfortunately, when implemented, the solver package Hyperlingo found a local optimum 
to a very simplified and small problem of just three boxes without considering several 
important constraints. The formulation of a bigger problem with more boxes was 
unrealistic because the number of variables and constraints increase incredibly fast as the 
number of boxes increase. 

Alternatively, Ballew employed a simple genetic algorithm with single crossover 
to solve a small sample (only 11 boxes) problem using the genetic algorithm software 
library Genesis. The length of the genotype for such a small problem was 1,232 bits. 
Unfortunately, Genesis did not show any signs of convergence in a reasonably amount of 
time. Ballew concluded that one reason for this might be that Genesis only allows for 
single-point crossover, which is too simplistic for this problem. After 1,000 generations, 
which took about 45 minutes, the best solution did not come close to a feasible packing 
of 11 boxes (Ballew, 2000). 


2-11 


Ballew speculated that one potential method for determining the number of 
crossover points is to base it on the number of boxes. We doubt this approach would 
succeed because, increasing the number of crossover points does not necessarily mean 
that a genetic algorithm will provide better solutions. There is always a strong possibility 
of achieving a deteriorated solution set if we increase the number of crossover points. 

In Chapter One, we pointed out the importance of the efficient packing of a pallet 
especially for the Air Force. For those reasons, along with the research done at the Air 
Force Institute of Technology (AFIT), the Air Force has contracted research on problem 
tthrough Computer Science Corporation (1997) and TASC, Inc. (1998). 

In its research, the Computer Science Corporation concluded that an analytical 
model giving a global optimum might not be possible, but with heuristic techniques, it is 
possible to develop an algorithm giving near optimum solutions in a reasonable time. 
Therefore, they stated that a software package using such a heuristic algorithm could be 
developed (Computer Science Corporation, 1997). 

At the end of TASC’s research, they developed a software package in C++ 
language considering some of the required constraints of the problem to test the 
performance of the algorithm they developed. After performing some tests, they 
concluded that they could develop a software package including other required 
constraints, providing better solutions than those software packages found on the market. 
They suggested it would require about six months to develop and the cost of such a 
product would be $150,000 (TASC, Inc., 1998). 


2-12 



2.3 Existing Commercial Software Packages 

There are a few companies that have developed packing software packages. We 
found two companies with commercial products. 

One of the companies is CAPE Systems, Inc. (2000) offers two different types of 
products. One is called Truckfill. The program provides help on planning, creating, 
editing, viewing, printing and maintaining Multi-Product load plans for trucks, container 
loads and railcars. On their website, it said that the package uses the latest optimization 
techniques and can quickly build truck and container loads based on realistic loading 
rules and restrictions, but there is no other specific information. We sent an e-mail 
asking about the technique they have used to develop the package, but they replied that 
all available information is on their web site. Also Truckfill recalculates load counts, 
load weight, load dimensions and the center of gravity of the total load after any changes 
are made to the Load Plan. 

Cape Systems, Inc. (2000) other product is Cape Pack’99, which is a packaging 
design and pallet loading software. There are basically three main groups in the software 
package: Design Group, Arrange Group and Pallet Group. The design group resizes an 
existing primary pack or designs a completely new product. Starting with a proposed 
size and specifying the scope for dimensional and/or volumetric changes, the program 
can establish what it calls the best possible primary pack size. The arrange group creates 
new case sizes for existing primary pack sizes. These first two program groups are not 
appropriate for our problem. 

The third program group in Cape Pack ‘99 is the one that is related to our 
problem; the Pallet Group. It generates a range of numerical and graphical solutions for 


2-13 



loading objects onto pallets and into trucks. Pallet layers and cases can be added or 
deleted and pattern layouts can be rearranged with the drag and drop Layer Editor. This 
group also includes Display Pallet for loading different size products onto the same 
pallet. Using basic information about the size and weight of the outer packaging, the type 
of pallet and the maximum height and weight of the pallet load, these programs generate 
numerical and graphical solutions for loading packages onto pallets and into trucks. In 
this program group, one can calculate up to three different pallets simultaneously and 
work with cases, trays, bags, cylinders, ovals and trapezoidal shapes. This module allows 
the user to load products of up to 40 different sizes. Unfortunately, there is a restriction 
on the dimensions of the container: each dimension must be less than 100 inches, which 
is less than the length of the 463L pallet of 108 inches. Depending on the number of 
different sized boxes to be packed, the solution time is around 1 minute. Although we do 
not know what kind of optimization technique it uses, the program uses some algorithms 
for packing loads in layers or columns. 

Another commercial packing software is Cube-IQ, which is the product of Magic 
Logic Optimization, Inc (2000). This software package is a product of Remarkable 
Software Company, and from its specifications, it appears it might be of use to the Air 
Force. 

Cube-IQ is very flexible, and allows the containers (trucks, pallets, crates) to be 
either rectangular, or have a non-flat roof or floor, such as sliced-off comers of airline 
containers. An overall weight limit is taken into account and the system automatically 
handles axle weight limits. There is also an option for the correct positioning of the 
center of gravity. Cube-IQ optimizes over multiple containers, optionally in multiple 


2-14 



sizes. It also allows the items to be rectangular, cylinder and 'sofa' (3D L-shapes). Other 
box data include switches for 'tumable', 'allowed on its side', 'allowed on its end', 'bottom- 
only', and 'top-only' (possibly in maximum number of layers). Box weight is taken into 
account. Cube-IQ supports loading and stacking rules for each orientation of the package 
separately. This allows the user to set up more complex loading rules, such as 'flat only if 
on top' (for large, but flat boxes), and 'straight up unless on top' (for boxes that can only 
support other boxes if they are loaded upright). 

It produces an output of the volume and weight capacity utilization for all loaded 
containers, and for each loaded package the container number and, within that container, 
the 3-D loading coordinates. Cube-IQ has a graphics window in which the user can see 
the container as it is loaded. The picture can be rotated, and it will build up one block of 
boxes at a time. It gives a print out of complete manifests and loading instructions, 
showing for each block of similar boxes exactly where it is to be loaded, including 
pictures. Its runtime is fairly short: From one second on a Pentium III-500 PC for a case 
with 25 loaded parcels, to one minute to load hundreds of boxes. 

It seems like it is a good optimization package but there is little insight into the 
techniques Cube-IQ uses to pack items. Since it finds a good solution, not the optimal 
solution, it likely uses a heuristic algorithm. It is also not clear whether or not Cube-IQ 
ensures heavier boxes are packed towards the bottom. 


2-15 



Chapter 3 - Methodology 


3.1 Introduction 

We have developed a robust pallet-packing model that solves challenging 
problems in short times while finding near optimal to optimum solutions. In this chapter 
we present our model in detail; the input and output data, the data structure, and the 
heuristic method that we developed are discussed. 

Ravindran et al. (1986) present the principles of modeling. The first four 
principles they present are key to successful model building: 

1. Do not build a complicated model when a simple one will suffice, 

2. Beware of modeling the problem to fit the technique, 

3. The deduction phase of modeling must be conducted rigorously, and 

4. Models should be validated prior to implementation. 

We followed these principles while building our model. We started simple but 
challenging enough to solve big problems in a reasonable amount of time while relaxing 
some constraints as we pointed out in Section 1.4. 

As the second principle advises, we did not try to force fit an existing solution 
technique onto our problem. We examined past related work in depth to determine the 
efficiencies of existing solution techniques. 

3.2 Overview 

Based on this start, we developed a special heuristic for our problem and 
implemented it in the C programming language. We performed debugging, verification, 


3-1 



and validation to produce a software package that packs a number of given boxes into a 
given container considering only the restrictions presented in Section 1.4. Our model 
packs as many boxes as possible in a given container while selecting tbe suitable boxes 
from a given box set. This property makes our approach more realistic. The model is 
also able to pack rectangular boxes in any orientation. Actually, our model not only 
packs rectangular boxes in any orientation, it also packs according to different 
orientations of the pallet. In other words, it builds walls or layers along any of the six 
faces of the given container if all three pallet dimensions are not the same. 

The model basicly builds a new packing during each iteration. Our approach does 
not limit the number of different boxes in each layer. It may pack any number of 
different boxes within a layer if their surfaces make a good match to reduce the unpacked 
gaps within the layer. This property makes it robust. 

Our heuristic employs both layer packing and wall building approaches. There 
are some other important methods that our program uses to pack boxes efficiently and 
quickly. One of them is packing a sublayer into any of the available unused space in the 
last packed layer, which we call a layer-in-layer packing approach. Another new, and the 
most important, feature of our heuristic is an adaptation of human behavior and 
intelligence to decide which box to pack. Considerable improvement also comes from 
the data structure we employ. For verification, validation and debugging purposes, we 
also have written a program to visualize the best solution found. Since the output of our 
program contains x, y, z coordinates and x, y, z dimensions of the packed orientation of 
each packed box, it is difficult to manually check a solution to see if there is any 


3-2 





constraint violation or numerical error. To make that process easier and to increase the 
presentability of solutions, we display the best solution in a box-by-box format. 

3.2.1 Human Intelligence 

Tabu search developed by Glover (1986) was motivated by Glover’s observation 
of how people approach problem solving. Faced with the tough pallet-packing problem, 
we sought, and found similar motivation. We call our approach an adaptation of human 
intelligence because we pack boxes onto the pallet just like a human, from bottom to top 
or by building walls. This actually ensures a level top of the load for the cargo net. 
Humans prefer to pack boxes to reduce packing surface irregularities. We eyeball the 
dimensions of any gap to be packed and pick the most suitable boxes to keep the 
topology as smooth as possible. Our heuristic does the same thing. While packing a 
layer, it attempts to retain a flat forward packing face. In each step, the dimensiones of 
the gaps to be filled are determined, all the eligible boxes and their orientations are 
analyzed, and the best fitting box is selected and packed. Before starting to pack any 
layer, it analyzes all unpacked boxes to pick the most suitable layer thickness to reduce 
wasted volume. However, the selected layer thickness is flexible and might be increased 
to accomodate the height of the selected box. Finally, a human will also fill uneven 
layers, if possible. This led us to our layer-in-layer approach. 

Our layer building technique is so effective that after a few iterations, the model 
can be stopped with the solution quality only about 1-8% less than the volume utilization 
of the best solution. This feature is effective especially when we deal with a large 
number of boxes and computing time is scarce. 


3-3 


3.2.2 Attributive Memory 

An important tool we use is attributive memory. We use attribute-based memory 
to avoid using a huge amount of memory to save evey solution produced during the 
solution process. Our model keeps only three parameters of the solution found during 
iterations. These attributes are the pallet orientation of the solution, another one is the 
starting layer thickness value, and the last one is the volume utilization of the solution. 
The attributes of the best solution are then used to reconstruct that best solution. 

3.3 Input Data 

All box dimensions and the pallet dimensions are read from a text file specified 
by the user, (.txt ectension assumed). This file must be in the same hard drive folder 
where the program is executing. The user must follow the necessary format of the input 
file. 

Figure 3-1 provides an example of an input file: 


Figure 3-1: Input File Format 

In the first line, the three numbers are the x, y, and z dimensions of the pallet. 
The order of the dimensions is important because at the end, we convert the output data 
format of the best solution to the orientation of the pallet entered in the input file. 



3-4 





All subsequent lines contain box information. In each line, the first number is the 
box label and has no affect on the solution since the program does not take these labels 
into consideration. Box labels merely provide an organized way to input the data file. 
The second, third, and fourth numbers are the x, y, and z dimensions of each box type, 
respectively. Since the program tries all possible orientations of each box, the order of 
the box dimensions actually has no importance. The fifth number represents the number 
of boxes of the same type. Although commas between the numbers are not required, at 
least one space character must delimit the numbers. No error handling is included in the 
current program so the input criteria should be followed. 

3.4 Data Structure 

Data structure is a critical component of any program. Choosing the proper data 
structure affects both performance and solution time. For our program, it is important to 
reach data quickly We use two different arrays and a double linked list to accomplish 
this. 

The first array is the Boxlist[] array, which keeps all box dimensions, coordinates 
of packed boxes in the container, and other necessary data. There is a total of twelve 
fields in each record of this array: 


Element 

Name 

Description 

1 . 

Packst 

: Status of packing (0: Not packed; 1: Packed), 

2. 

N 

: The number of boxes that have the same dimensions, 

3. 

Diml 

: The length of one of the three dimensions, 

4. 

Dim2 

: The length of another of the three dimensions, 


3-5 



Element 

Name 

Description 

5. 

Dim3 

: The length of the other of the three dimensions, 

6. 

Cox 

: X-coordinate of the location of the packed box, 

7. 

Coy 

: Y-coordinate of the location of the packed box, 

8. 

Coz 

: Z-coordinate of the location of the packed box, 

9. 

Packx 

: X-dimension of the orientation of the box as it has been packed, 

10. 

Packy 

: Y-dimension of the orientation of the box as it has been packed, 

11. 

Packz 

: Z-dimension of the orientation of the box as it has been packed, 

12. 

Vol 

: Volume of the box (Diml *Dim2*Dim3) 


We also store the volume of each box so the model does not have to calculate it 
each time it needs the box volume. Fields 6-11 are meaningless if Packst value is zero, 
but they provide the packing information once the box is packed and Packst is set to one. 
Each box has a record in the Boxlist[] array. 

The other array is the Layers [] array. This array stores all the different lengths of 
all box dimensions. Each Layerdim value in this array represents a different layer 
thickness value with which each iteration can start packing. Before starting iterations, all 
different lengths of all box dimensions along with evaluation values are stored in this 
array. The evaluation values (Layereval values) are calculated by the Listcanditlayers 
function as explained in Section 3.6.1. There are two different data fields for each record 
in this array: 

Element Name Description 

1. Layerdim : A dimension value, 

2. Layereval : Evaluation weight value for the corresponding layerdim value. 


3-6 




The double linked list we use keeps the topology of the edge of the current layer 
under construction. We keep the x and z coordinates of each gap’s right comer. The 
program looks at those gaps and tries to fill them with boxes one at a time while trying to 
keep the edge of the layer even. Each entry in the double linked list has these data fields: 


Element Name 

Description 

1 . 

*pre 

: Pointer that keeps the address of die previous entry, 

2. 

Cumx 

: Keeps the x-coordinate of the gap’s right comer, 

3. 

Cumz 

: Keeps the z-coordinate of the gap’s right comer, 

4. 

*pos 

: Pointer that keeps the address of the following entry. 


During execution of each iteration, this double link list may have only one entry, 
or may have hundreds of entries based on the box sizes of the box set being packed. 

Most of the time, new entries are inserted while useless entries are removed. Therefore, a 
double linked list is used to handle these needs dynamically and efficiently. 

3.5 Numerical Limits 

These model limitations were decided considering both memory limitations for an 
average computer memory capacity and the nature of the realistic packing problems: 
Maximum number of boxes in a box set : 5000 

Number of total different dimension values : 1000 

Max dimension length for either pallet or any box : 32,767 
All dimension values must be integer numbers. 

3.6 Flow Chart of The Algorithm 


3-7 




Figure 3-2 depicts the flow chart of how the iterations are performed. The 
pseudo-codes of the functions are provided in Appendix A. The program itself is in 
Appendix B. 










Figure 3-2: Flow Chart of the Algorithm 












Figure 3-2: Flow Chart of The Algorithm 
3.7 How Does The Heuristic Work? 

3.7.1 Preparation For Iterations 

Assume Figure 3-1 presents the problem to solve. Figure 3-3 is the corresponding 
BOXLISTf] array. 

Variable assignments: XX=104; YY=96; ZZ=84; 

Boxlist[X]=(Packst, N, Diml, Dim2, Dim3, Cox, Coy, Coz, Packx, Packy, Packz, Vol) 
Boxlist[l]=( 0, 4, 70, 104, 24, 0, 0, 0, 0, 0, 0, 174720) 

Boxlist[2]=( 0, 4, 70, 104, 24, 0, 0, 0, 0, 0, 0, 174720) 

Boxlist[3]=( 0, 4, 70, 104, 24, 0, 0, 0, 0, 0, 0, 174720) 

Boxlist[4]=( 0, 4, 70, 104, 24, 0, 0, 0, 0, 0, 0, 174720) 

Boxlist[5]=( 0, 2, 14, 104, 48, 0, 0, 0, 0, 0, 0, 69888) 

Boxlist[6]=( 0, 2, 14, 104, 48, 0, 0, 0, 0, 0, 0, 69888) 

Boxlist[7H 0, 3, 40, 52, 36, 0, 0, 0, 0, 0, 0, 74880) 

Boxlist[8]=( 0, 3, 40, 52, 36, 0, 0, 0, 0, 0, 0, 74880) 

Boxlist[9H 0, 3, 40, 52, 36, 0, 0, 0, 0, 0, 0, 74880) 

Figure 3-3: Creating the Boxlist[] Array 


3-10 






After the input process is complete, the model creates a layer thickness array 
named LAYERS []. This array contains every unique dimension of the boxes less than 
the y dimension of the current orientation of the pallet with their individual evaluation 
values. The Layers[] array is created for each orientation of the pallet. Each entry is a 
possible layer thickness value for iterations with the current orientation of the pallet to 
start the packing. 

The evaluation value of a layerdim represents how close all other boxes are to this 
layer height if we selected this value as a layer thickness for the packing. The model 
calculates these evaluation values as follows: 

Retrieve a box and one of its dimensions. Examine the previously set layerdim 
values in the array. If this is a different length and less than the y dimension of the 
current orientation of the pallet, store the length in a new element in the layerdim array. 
Then it goes through every other box retrieving its dimension closest to the layerdim 
value, and adds up the absolute value of the differences between that dimension and the 
layerdim value. The layerdim value with the smallest layereval weight value is the most 
suitable layer thickness value; this value should yield the smoothest layer height. 

Continuing our example, calculations for the Layers[] array for the pallet 
orientation X=104, Y=96, Z=84 are: 

Layers[X]=(Layerdim, Layereval) 

Abs(70-70)+Abs(70-70)+Abs(70-70)+Abs(70-48)+Abs(70-48)+Abs(70-52)+Abs(70-52)+Abs(70-52)=98 

Layers[l]=(70,98) 

Abs(24-24)+Abs(24-24)+Abs(24-24)+Abs(24-14)+Abs(24-14)+Abs(24-36)+Abs(24-36)+Abs(24-36)=56 
Layers[2]=(24, 56) 

Abs(14-24)+Abs(14-24)+Abs(14-24)+Abs(14-24)+Abs(14-14)+Abs(14-40)+Abs(14-40)+Abs(14-40)=106 


3-11 



Layers[3]=(14,106) 

Abs(48-70)+Abs(48-70)+Abs(48-70)+Abs(48-70)+Abs(48-48)+Abs(48-40)+Abs(48-40)+Abs(48-40)=100 

Layers[4]=(48,100) 

Abs(40-24)+Abs(40-24)+Abs(40-24)+Abs(40-24)+Abs(40-48)+Abs(40-48)+Abs(40-40)+Abs(40-40)=80 

Layers[5]=(40, 80) 

Abs(52-70)+Abs(52-70)+Abs(52-70)+Abs(52-70)+Abs(52-48)+Abs(52-48)+Abs(52-52)+Abs(52-52)=80 

Layers[6]=(52, 80) 

Abs(36-24)+Abs(36-24)+Abs(36-24)+Abs(36-24)+Abs(36-48)+Abs(36-48)+Abs(36-36)+Abs(36-36)=72 

Layers[7]=(36, 72) 

There are 8 different dimension values but since the dimension value 104 is larger 
than the y dimension of the current pallet orientation 96, we do not evaluate it as a 
possible layer thickness. After having such a Layers[] array prepared, it is sorted 
ascending order with respect to its layereval values: 


Layers[X]=(Layerdim, Layereval): Layers[l]=( 

24, 

56 ) 

Layers[2]=( 

36, 

72) 

Layers[3]=( 

52, 

80) 

Layers[4]=( 

40, 

80) 

Layers[5]=( 

70, 

98) 

Layers[6]=( 

48, 

100) 

Layers[7]=( 

14, 

106) 


Figure 3-4: Creating the Layers[] Array 


3-12 





Since the smallest layereval value potentially may be the most suitable layer 
thickness value, having that list sorted and starting to pack from the most promising layer 
thickness values would be an important factor to reduce the solution time, especially if 
we consider packing a large number of different box types. However, this greedy 
approach does not always hold. Sometimes an iteration starting with a larger layerdim 
value yields the best solution. 

3.7.2 Execution Of An Iteration 

Iterations tie closely to the six possible orientations of a pallet. During iterations, 
all six orientations of the pallet are packed. Each unique orientation of the pallet is 
treated as a pallet to pack. Obviously, if a pallet has three identical dimensions, it has 
only one orientation. In general, we have 1,2 or 6 orientations for 1,2 or 3 unique 
dimensions, respectively. In each iteration, each orientation of the pallet is packed once 
for each element in the Layers [] array. Each iteration begins packing with an initial layer 
thickness taken from layerdim value in the Layers [] array. Thus, if we have 7 different 
dimension values in our Layers[] array and the pallet has 3 unique dimensions, die 
program potentially performs 6*7=42 iterations. Thus, the solution time of our program 
is effected by both the number of different dimension values and the number of total 
boxes to be packed. The number of different box types does not have a direct affect on 
the solution time. It is always possible to terminate the program prematurely by pressing 
the ‘Q’ key whenever a sufficient ‘best so far’ value has appeared on the console. Since 
the layer packing approach of the program is really effective, to get a very high volume 
utilization in a very short time is strongly possible. 


3-13 



Before explaining the details of the heuristic, we need to mention its 
computational complexity. If we have n boxes in our box set and d different dimension 
values for all boxes, the worst solution time is given by: 

fr(t)=6ndP(t) (1) 

where P(t) is the time spent to find and pack any box, which can be defined: 

P(t)=6 n E(t) (2) 

where E(t) is time to examine an orientation of a box. E(t) depends upon the computer. 
We ran all the test problems on a Pentium III 750 MHz computer, and for that computer, 
E(t)~ 0.18 microseconds (10‘ 6 ). 

Therefore the worst-case solution time performance is: 

0(t)=36 n 2 d E(t) (3) 

Each iteration starts with the pallet empty, all boxes available, a pallet orientation 
and a layer thickness from the Layers[] array. Subsequent iterations change the starting 
layer thickness or the pallet orientation. The parameters of the best packing found, based 
on volume packed, are saved as the current packing solution. 

We perform layer packing or wall building thus reducing the problem to a 
systematic series of two-dimensional packing problems. As Figure 3-5 depicts, we pack 
along the x- and z-axis. To track the current topology, each right comer coordinate data 
is maintain ed in a doubly linked list. As boxes are packed, this coordinate data will 
change. The doubly linked list facilitates the change to the coordinate data. This 
approach means we only need to track the current edge being packed, and we avoid 
overlaps of layers and pallet edges. 


3-14 



Each packing action begins by finding the smallest z-value in the coordinate data 
list and from that list finding the current gap in the layer to fill. The candidate boxes are 
examined to find one that fills the gap, with the correct layer thickness, and to find a box 
that fills the gap yet exceeds the current layer thickness by as small an amount as 
possible. If no box is found to fill the gap, the gap is ignored. Each box is examined in 
each orientation. 



*POS 


NULL 



*PRE, 

XCUM. 

ZCUM. *POS 

NULL, 

35, 

? 20 

|§f§ 


WM New entry 


68,. 

14 


104, 

21, NULL 


Figure 3-5: Packing a layer 


Table 3-1: Key Packing Program Functions 


FUNCTION 

PURPOSE 

Packlayer 

Update the linked list and the Boxlist[] array as a box is packed. 

Findsmallestz 

Determine the gap with the smallest z value in the current layer. 

Findbox 

Find the box that best fits to the current gap. 

Analyzebox 

Used by Findbox to analyze box dimensions. 


3-15 





Checkfound 

Determine which box to pack. 

Execiterations 

Execute iterations by calling proper functions. 

Report 

Duplicate best-so-far packing. 

Outputboxlist 

Writes packing information to file. 

Graphunpackedout 

Writes packing order for visualization program. 


The Findbox function analyzes the unpacked boxes using the Analyzebox 
function. For each different orientation of the unpacked boxes, the Analyzebox 


parameters are: 


Hmx 

Hy 

Hmy 

Hz 

Hmz 

Diml 

Dim2 

Dim3 


Maximum available x-dimension of the current gap to be filled. 
Current layer thickness value. 

Maximum available y-dimension of the current gap to be filled. 
Z-dimension of the current gap to be filled. 

Maximum available z-dimension to the current gap to be filled. 
X-dimension of the orientation of the box being examined. 
Y-dimension of the orientation of the box being examined. 
Z-dimension of the orientation of the box being examined. 



Figure 3-6: Findbox Function Parameters 





Analyzebox seeks, in precedence order, a box with a y-dimension closest to Hy 
but not more than Hmy, with an x-dimension closest to, but not more than Hmx, and a z- 
dimension closest to Hz, but not more than Hmz. This means it considers the y- 
dimension, then among boxes having the same y-dimension, it looks at the x-dimension, 
and finally among the boxes having the same y- and x-dimension, it looks at the z- 
dimension. It calculates the differences between the gap’s dimensions and the box 
dimensions for each box and picks the box with the least differences to be the best fitting 
one. It also finds a second box with a y-dimension bigger than the current layer 
thickness, but closest to the current layer thickness. Boxes that fit and are the proper 
thickness (y-values) are packed. Uneven boxes require extra consideration. 

We developed a layer-in-layer packing to accommodate packing of uneven 
heights. A layerinlayer variable determines if there is any unevenness in the current 
packing layer. 

If there is no box to fit the current gap, the gap under consideration is left 
unpacked. Figure 3-7 depicts this situation. 


Top view of a layer: 



3-17 






If it is required; the current layer thickness is increased to the y-dimension of the 
taller box found by the Findbox function. When the current layer thickness is increased, 
the total increment of the layer, from the beginning to the end of the current layer 
packing, is saved in the layerinlayer variable. After finishing the packing of the current 
layer, if the layerinlayer variable is greater than zero, another packing within the layer, 
for that layerinlayer thickness value, is performed. 



Figure 3-8: Layer in Layer Packing 

Layer-in-layer packing means our approach can utilize more space in the pallet. 
Although not used often in the problem set we examined, when used, layer-in-layer 
packing gave much better results. 

While the Layers[] array entries are used to start the first layer of each iteration, 
subsequent layers require calculation to determine good layer thickness values. These 


3-18 







calculations duplicate these described for the Layers[] array entries, but apply only to the 
as yet unpacked boxes. The best layer value is used as the layer thickness for subsequent 
packing layers. Layering continues until the pallet can no longer accommodate further 
layers. The pallet is then considered packed. 

Each packing tracks the volume of boxes packed and volume of boxes not packed 
to derive a pallet utilization measure and percentage of packed box volume. Each 
packing also has an associated pallet orientation and Layers[] array index. The best 
packing found becomes the final solution of the model. 

After getting the best solution’s parameters, the function Report is called. The 
Report function re-performs the packing with the parameters of the best solution found, 
but now calls the Outputboxlist function to generate the report file and the 
Graphunpackedout function to generate the visualization program input file. Information 
about unpacked boxes is included at the end of the report file. 

3.8 Output Data 

The model has three output streams. One is to the console, another to the report 
file, and the final to “visudat” file. Both the console and the report file report the overall 
numerical summary of the solution as well as the packing coordinates and the orientation 
of each packed box. The list of any unpacked boxes, is appended to the end of the report 
file. The dimensions of the pallet along with the packing coordinates and the orientation 
of each packed box are output to the file “visudat”. The graphical interface program uses 
the “visudat” file to visualize the solution. 


3-19 


The name of the report file uses the same root name of the input file but with the 
extension “out”. Figure 3-9 presents a “visudat” file format, and Figure 3-10 presents a 


report file format. 



Figure 3-9: Visudat File Format 


bonesS * WordPad 


Ffc Edit 


gew Insert Format Help 




..i' v- ; 

mmt:\ m 


’M s 


d m 




. 


<■: ... 


*** REPORT *** 


ELAPSED TIKE 

TOTAL NUMBER OF ITERATIONS DONE 
BEST SOLUTION FOUND AT 
TOTAL NUMBER OF BOXES 
PACKED NUMBER OF BOXES 
TOTAL VOLUME OF ALL BOXES 
PALLET VOLUME 

BEST SOLUTION'S VOLUME UTILIZATION 
PERCENTAGE OF PALLET VOLUME USED 
PERCENTAGE OF PACKED BOXES (VOLUME) 
UHILE PALLET ORIENTATION 


Almost 0 sec 
18 

ITERATION: 4 OF VARIANT: 3 
9 
6 

1063296 

838656 

838656 OUT OF 838656 
100.000000 % 

78.873239 % 

X= 84; Y= 104; Z= 96 


NO: 

PACKSTA 

DIMEN-1 

DIMEN-2 

DIMEN-3 

COOR-X 

COOR-Y 

COOR-Z 

PACKEDX 

PACKEDY 

PACKEDZ 

1 

1 

70 

104 

24 

0 

0 

0 

104 

24 

70 

5 

1 

14 

104 

48 

0 

0 

70 

104 

48 

14 

2 

1 

70 

104 

24 

0 

24 

0 

104 

24 

70 

3 

1 

70 

104 

24 

0 

48 

0 

104 

24 

70 

6 

1 

14 

104 

48 

0 

48 

70 

104 

48 

14 

4 

1 

70 

104 

24 

0 

72 

0 

104 

24 

70 


7 

40 

52 

*** LIST OF UNPACKED BOXES *** 

36 

_ 8 

40 

52 

36 

~ 9 

40 

52 

36 


















Figure 3-10: Output File Format 


3.9 Graphical Interface Program 

The graphical interface program, which is available in Appendix C, aids 
verification, checks for possible errors, and promotes the presentability of the best 
solution found. It reads the pallet dimensions and the box packing information from the 
“visudat” file and displays them on the screen interactively starting from the far end 
towards the user. This ensures a clear view of the box as it is packed. The program 
scales all dimension values and corresponding coordinates to properly fit the screen. 

3.10 Summary 

We developed a very efficient and robust heuristic technique to solve the three- 
dimensional pallet-packing problem. We implemented it in a program and our testing 
shows good results. In Chapter Four, we present the test problem solutions and some 
comparisons with other pallet-packing approaches. 


3-21 



Chapter 4 - Results 


4.1 Introduction 

We employed several different techniques to test our model. We created special 
test problem sets and examined performance on readily available, standard problem sets. 
In this chapter, we present testing results to learn about the important characteristics of 
our model. 


4.2 Numerical Tests and Comparisons 

To test our model, we created many different box sets. Prior works tested their 
methods with randomly generated box sets. While we also used random problems, it is 
impossible to evaluate the solution qualities of these random problems because the 
optimum solution is unknown. Thus, we developed a technique to generate problem sets 
with known solutions. 

We used the Exel software to produce uniformly distributed random dimension 
values between certain numerical limits and then we arranged the box quantities to be 
close to the pallet volume. Table 4-1 summarizes a sample of those randomly generated 
problem solutions. 


Table 4-1: Randomly generated problem solutions 


Box Set 

# of Boxes 

# of Box Types 

% Vol. Utilization 

Solution Time(sec) 

Set#l 

307 

5 

89.5 

2 

Set #2 

1728 

5 

97.5 

189 

Set #3 

637 

11 

92.4 

44 

Set #4 

1493 

21 

96.4 

255 

Worst Case(#5) 

31 

31 

68.7 

<1 


4-1 

























For all randomly generated problems, the pallet dimensions are 104, 96, 84. The 
volume utilization of the pallet is fairly high, but the optimum solutions are unknown. 
We do know our solution times are quite low. In the very last line of Table 4-1, we 
present results for a problem that is extremely difficult to solve because all boxes are 
unique. The volume utilization is very low, but seems reasonable given the unique size 
of each box. We also obtained the solution very quickly. We packed 10 different 
realizations of the difficult problem type and found the worst-case solution was greater 
than 65%. 

Since we wanted to evaluate our solutions by comparing them with optimal 
solutions, we developed a technique to generate problem sets. In our technique, we 
divide the container into many different sized boxes. These boxes can then be listed in 
any order, even rotated, to yield a packing problem with a known, optimal solution of 
100% pallet volume utilization. All problem sets that we generated are in Appendix D. 



Figure 4-1: Creating Box Sets 


The box sets that we generated with this problem generation technique and our 
solutions are presented in Table 4-2. Overall, our method does quite well. 


4-2 









Table 4-2: Specially Generated Problem Solutions 


Box Set 

# of Boxes 

# of Box Types 

% Vol. Utilization 

Solution Time(sec) 

Set #6 

6 

2 

100 

<1 

Set #7 


3 

100 

<1 

Set #8 

12 

4 


<1 

Set #9 

18 

6 

89.7 

<1 

Set #10 

86 

7 

91.6 

<1 

Set #11 

39 

15 

84.5 

1 


We developed our model as a distributor’s pallet packing problem but wanted to 
test it on the manufacturer’s pallet packing test problems (MPPP). Since the distributor’s 
pallet packing problem is much harder than the MPPP, we expected our model to yield 
very good results on the MPPP. We created these problem sets using the same problem 
generation technique and and solved the problems. Our results are presented in Table 4- 
3. As expected, the model does very well on the MPPP. 


Table 4-3: Specially Designed MPPP Solutions 


Box Set 

# of Boxes 

# of Box Types 

% Vol. Utilization 

Solution Time(sec) 

Set #12 

576 

1 

100 

4 

Set #13 

1152 

1 

100 1 

18 

Set #14 

4992 

1 

100 

228 

Set #15 

1152 

2 


8 

Set #16 

2784 

2 

98 

315 


There are also 700 problems generated by Bischoff et al. (1995) readily available 
on the Imperial College Management School web page (2001). These problems are 
randomly generated and come in 7 files. Each of the 100 problems in 7 files contain 3, 5, 


4-3 


















































8,10,12,15, and 20 box types, respectively. All problems use the same pallet 
dimensions of 587,233, and 220. We solved these 700 problems and obtained the results 
presented in Table 4-4. Solution detailes are presented in Appendix E. 


Table 4-4: Solution Summary Of The Given Problem Set 


Box 

# of box 

# of Boxes 

% of Pallet Utilization 

Utilization 

Solution Time(sec) 

Set 

types (n) 

min 

ave 

max 

min 

ave 

max 

Std. Dev. 

min 

ave 

max 

BR-3 

3 

TSM 

BEM 

476 

■HI 

89.0 

95.3 

2.93 

<i 

1.07 

12 

BR-5 

5 

El 


266 





<i 

1.23 

5 

BR-8 

8 

80 

134 

232 

84.5 

88.4 

92.1 

1.56 

<i 

1.85 

5 

BR-10 


75 

133 

233 

84.4 

88.2 

91.9 

1.52 

i 

2.19 

6 

BR-12 

12 

84 

133 

218 

■aw 

■2QI 

89.9 

1.33 

i 

2.73 

8 

BR-15 

15 



203 


iifti 

91.3 

1.28 

i 

3.39 

9 

BR-20 

20 

90 

130 

172 

84.3 

87.1 

90.2 

1.15 

2 

4.47 

9 


We compared our solutions with the solutions of Bischoff, and Ratcliff (1995) 
(denoted by B/R), and Gehring and Bortfeld (1996) (denoted by G/B); Bortfeld and 
Gehring (1997) (denoted by B/G); Temo, Scheithauer, SommerweiG, and Riehme (1997) 
(denoted by T/S/S/R) in Table 4-5. Information about the G/B and the B/G results come 
from the Temo, et al. (1997). We know that G/B uses a Genetic Algorithm model and 
B/G uses a Tabu Search model. 


Table 4-5: Comparisons for the Bischoff/Ratcliff Examples 























































































































The best competitor to our model seems to be T/S/S/R. However, it appears that 


our model is more dependable. All of the minimum values of our results are 1 to 4% 
better than T/S/S/R minimum values while average and maximum values are very 
comparable. Solution time is another important factor of interest. Our model solves any 
of 700 box sets in 1 to 12 seconds on a Pentium III 750 MHz computer. The T/S/S/R 
model uses 150 to 600 seconds on a PentiumPro 200 MHz computer. Their computer is 
about 4 times slower than ours, but our solution time is about 50-100 times faster than 
theirs. Thus, it appears we may have some processing time advantage. 

Another box set has been used by Loh and Nee (1992) (denoted by L/N); Ngoi, 
Tay, and Chua (1994) (denoted by N/T/C); Bischoff, Janetz, and Ratcliff (1995) (denoted 
by B/J/R); Bischoff, and Ratcliff (1995) (denoted by B/R); Gehring and Bortfeld (1996) 
(denoted by G/B); Bortfeld and Gehring (1997) (denoted by B/G); Temo, Scheithauer, 
Sommerweifi, and Riehme (1997) (denoted by T/S/S/R). In the Table 4-6 we compare 
the volume utilization percentages for 4 instances in that problem set. The other 11 
instances are not presented since all boxes could be packed in the container by our model. 
Again our results compare favorably. 


Table 4-6: Comparisons for the Loh/Nee Examples 


Set# 

# of 
Boxes 

# of Box 
Types 

L/N 

1992 

N/T/C 

1994 

B/J/R 

1995 

B/R 

1995 

G/B 

1996 

B/G 

1997 

T/S/S/R 

1997 

OURS 

2001 

Solution 
time (sec) 



8 

76.8 



90.0 


EZ39 

93.9 

93.3 

3 

LN #6 

200 

8 

88.6 

88.7 

89.5 

l&ll 

91.1 

91.2 

91.6 

91.7 

3 

LN #7 

200 

8 




EH 

83.3 

84.7 

84.7 

84.7 

1 

LN-#13 

130 

7 

77.0 

84.1 

82.3 

78.1 

85.6 

84.3 

85.1 

85.6 

<1 


4-5 








































In Section 2.2, we stated that the model developed by Han et al. (1989) was able 
to pack 195 boxes of 11" by 6" by 6" into a 48" by 42" by 40" container. Their volume 
utilization of the container was 95.16%. They also quoted the US General Services 
Administration whose published results in 1966 for the same problem only provide 
82.5% utilization. We solved the same problem. Our model packed 196 boxes, with a 
utilization of 96.25% in less than a second. 

Another test problem that we solved was created and solved by Chen et al. (1995) 
while developing an analytical model. Faina (2000) solved the same problem by using a 
special simulated annealing algorithm. They both solved this small instance with some 
fixed orientation of each box. The problem is provided in Table 4-7. 


Table 4-7: Chen et aL and Faina’s Example Box Set 


Box 

Number 

Dimensions Of Boxes 

X 

y 

z 

1 

25 

8 

6 

2 

20 

10 

5 

3 

16 

7 

3 

4 

15 

12 

6 

5 

22 

8 

3 

6 

10 

20 

4 


They were able to pack these six boxes into a container with dimensions of 10, 

20,35, by packing the boxes in certain defined orientations. Their solution is the optimal 
solution. Since our model rotates each box, we tested our model on this small problem 


4-6 
























allowing full rotation of all boxes. We actually improved the packing using a container 
with dimensions of 10,20, 33. 


We wanted to make further comparisons with Faina’s (2000) solutions, but the 
problem sets were not presented in the paper. He provides but emphasizes that beyond 
64 boxes, the effort to improve the final placing is too expensive computationally. 
Therefore it is hard to make further comparisons. Faina also states that the results 
obtained are worse as the number of boxes increases. With our method, we see that 
increasing the number of the boxes has little affect on the solution quality, but it affects 
solution time. 


Recall our model’s worst case solution time formulation with E(t)=0.18 
microseconds (10‘ 6 ) for our computer, a Pentium III 750 MHz, 256 Mb, Windows 2000 


Professional. For Problem #2 presented in Table 4-1; with n=1728 and d=15, ft(t)=290 
seconds, greater than actual solution time of 189 seconds. For very large problems of say 
5000 boxes with 100 box types, ft(t)=16200 seconds=4.5 hours. Since these times are 
large, we examined the impact of stopping our model early after a few iterations. A 
comparison is shown in Table 4-8. Notice our approach gives very good, possibly 


acceptable, results after just a couple of iterations. 

Table 4-8: Comparisons with Premature Solution Times 


BOX SET 

NUMBER 
OF BOXES 
INSET 

SOLUTION 
UTILIZATION 
FULL % 

FULL 
SOLUTION 
TIME (sec) 

SOLUTION 
UTILIZATION 
PREMATURE % 

PREMATURE 
SOLUTION 
TIME (sec) 

Set #2 

1728 

97.5 

189 

93.2 

6 

Set #3 

637 

92.4 

44 

87.4 

3 

Set #4 

1493 

96.4 

255 

88.2 

4 

Set #12 

576 

100 

4 

93.8 

1 

Set #13 

1152 

100 

18 

99.5 

2 

Set #14 

4992 

100 

228 

97.8 

93 

S9H 

1152 


8 

98.2 

2 

Set #16 

2784 

98 

315 

91.7 

13 

BR-3 #65 

476 

94.4 

12 

92.9 

1 




















































BR-5 #39 

266 

93.8 

5 

89.5 

1 

BR-8 #39 

232 

89.7 

5 

85.9 

1 

BR-10 #56 

233 

91 

6 

89 

1 

BR-12 #56 

218 

88.1 

8 

86 

1 

BR-15 #13 


88.4 

9 

85.2 

1 

BR-20 #51 

166 

88.1 

9 

86 

1 


4.3 Summary 

An algorithm is an abstraction best evaluated by experimenting with a specific 
implementation. A heuristic is a special type of algorithm. We implemented our packing 
heuristic and solved various sets of problems. Our tests demonstrate the validity of the 
model and its performance. Our model proved to be an innovative and quick running 
algorithm, producing extremely good results. 


4-8 





































Chapter 5 - Conclusions and Recommendations 


5.1 Research Results 

This research developed a solution approach to the three dimensional pallet¬ 
packing problem. Ballew (2000) developed a mathematical formulation and explored a 
heuristic approach using a genetic algorithm. His research found that it is not practical to 
try to solve this problem by using an analytical approach. Based on not only Ballew but 
the research of others, the complexity of the three-dimensional pallet-packing problem 
appears to rule out any type of search heuristic such as genetic algorithms or simulated 
annealing. These problems do not exploit enough problem-specific knowledge. 

We built a new heuristic method. Our heuristic technique tries to mimic human 
intelligence and behavior, in particular how one would build layers, fill gaps in a layer, 
and examine various box orientations. We wrote a C program to test our algorithm, 
developed another program to visualize the best solution found, and used attributive 
memory and dynamic data structures, such as arrays and double linked lists, to improve 
processing efficiency. 

Our heuristic not only solves large problems in a small amount of time, but it also 
gives very good or optimal solutions. It is also robust and high solution quality is not 
affected by different problem characteristics. We make these claims based on empirical 
results from literature problems, test bank problems, and problems we created with a 
known optimal solution. 


5-1 


5.2 Recommendation for Future Research 


Our research showed us that powerful heuristic techniques would solve the 
distributor’s three-dimensional pallet packing problem in a reasonable amount of time. 
Thus, we recommend working on employing other powerful heuristic tools or using those 
stated tools more extensively. 

The primary objective should be adding other constraints rather than increasing 
the volume utilization of the pallet. The first essential constraint to add would be the load 
stability. Other necessary constraints such as loading boxes in some certain orientations 
and weight and balance should be added one by one. 

Another avenue is to implement our heuristic within some other approach to solve 
multi-pallet packing problem. As Choocolaad (1998) and Romaine (1999) mentioned, 
the multi-pallet problem is important for Air Force mobility and deployment planning 
studies. 

A final avenue of research might be to add some sort of local improvement 
heuristic. Given some solutions, based on some pallet orientation and layer thickness, 
can minor changes yield better packings. 


5-2 




Appendix A - Pseudo-codes of The Functions 


MAIN 

Perform initialization by calling INITLALIZE(); 

Get time(START); 

Execute iterations and find the parameters of the best solution by calling 
EXECITERATIONSO; 

Get time(FINISH); 

Using the parameters found, pack the best solution found, report to the console 
and to an output text file by calling REPORT(); 

Wait until a keystroke entered by the user; 

End; 


FUNCTION INITIALIZEO 

Get the input FILENAME from die user; 

Get the pallet and box set data entered by the user from the input file by calling the 
function INPUTBOXLISTO; 

Calculate the volume of the pallet; 

Calculate the total volume of all boxes; 

Create a node and call it SCRABFIRST. Each of these double linked list nodes keeps X 
and Z coordinates of each gap in the layer currently being packed. 
SCRABFIRST.PRE=NULL; SCRABFIRST.POS=NULL; 

Initialize variables those keep the best so far and its parameters. 


FUCTION INPUTBOXLISTO 

If exists, open the file FILENAME; 

Else {Tell the user “Cannot open the file FILENAME”; end;} 

Read the first line of the input file and set the pallet dimension variables XX, YY, ZZ; 
Read every other lines in the input file and fill each field in the array BOXLIST[]. 
Now the variable TBN is already set to the total number of boxes input from the file; 
Close the file FILENAME; 

RETURN; 


A-1 



FUNCTION EXECITERATIONSQ; 


For VARIANTS to 6 { 

For each value of VARIANT get a different orientation of the pallet to the 
variables PX, PY, PZ; 

List all possible candidate values by calling LISTCANDITLAYERS(); 

Sort the array LAYERS in respect to its LAYEREVAL fields in increasing order 
by using QSORT; 

For each layer values in the LAYERS [] array, perform another iteration starting 
with that layer value as the starting layer thickness: 

For LAYERSINDEX=1 to LAYERLISTLEN { 

Get the first value of the LAYERS array as the starting 
LAYERTHICKNESS value: 

LAYERTHICKNESS=LAYERS[LAYERSINDEX].LAYERDIM 
Set all boxes’ packed status to 0: 

For X=1 to TBN do BOXLIST[X].PACKST=0; 

do { 

Set the variable that shows remaining unpacked potential second 
layer height in the current layer: LAYERINLAYER=0; 

Set the flag variable that shows packing of the current layer is 
finished or not: LAYERDONE=0; 

Call PACKLAYERO, to pack the layer, and if a memory error is 
responded, exit the program; 

If there is a height available for packing in the current layer, 
perform another layer packing in the current layer: 

If LAYERINLAYER^O do{ 

Get the height available for packing in the current layer as 
the layer thickness to be packed: 
LAYERTHICKNESS=LAYERINLAYER; 

Call PACKLAYERO, to pack the layer, and if a memory 
Error is responded, exit the program; 

} 

Call FINDLAYER(REMAINPY) to determine the most suitable 
layer height fitting in the remaining unpacked height of the 
pallet; 

} While PACKINGS; 

If the volume utilization of the current iteration is better than the best so 
far, and the iterations were not quit, keep the parameters: 

(Pallet orientation, utilization, and the index of the initial layer 
height in the LAYERS array); 

If a hundred percent packing was found, exit doing iteration and 
RETURN; 

} 

} 


A-2 


FUNCTION LISTCANDITLAYERSQ; 


LAYERLISTLEN-O; 

For X=1 toTBN { 

Get each dimension of each box, one at a time by doing: 

For Y=1 to 3 { 

If Y=1 do { 

EXDIM=BOXLIST[X].DIMl; 

DIMEN2=BOXLIST[X].DIM2; 

DIMEN3=BOXLIST[X].DIM3; 

} 

If Y=2 do { 

EXDIM=BOXLIST[X] .DIM2; 

DIMEN2=BOXLIST[X] .DIM 1; 

DIMEN3=BOXLIST[X].DIM3; 

} 

If Y=3 do { 

EXDIM=BOXLIST[X] .DIM3; 

DIMEN2=BOXLIST[X].DIMl; 

DIMEN3=BOXLIST[X].DIM2; 

} 

If any of the dimensions of the box being examined cannot fit into the 

pallet’s respective dimensions, exit this loop and continue with the 
next loop; 

If EXDIM is the same as any of previously examined dimension lengths, 
exit this loop and continue with the next loop; 

Set the evaluation value of the EXDIM to 0 by doing LAYEREVAL=0; 
For Z=1 to TBN do{ 

Get the closest dimension value of each box to the EXDIM by 

looking at the absolute values of differences between each 
dimension and EXDIM, and selecting the smallest value; 
and set the variable DIMDIF to this value; 

Add those values cumulatively by doing: 

LAYEREVAL=LAYEREVAL+DIMDIF; 

} 

LA YERLISTLEN=L AYERLISTLEN+1; 
LAYERS[LAYERLISTLEN].LAYEREVAL=LAYEREVAL; 

LAYERS [L AYERLISTLEN] .LAYERDIM=EXDIM; 

} 

} - 

RETURN; 


A-3 



FUNCTION COMPLAYERLIST(ij); 


This function is required for the compiler built in function QSORT(). 
It returns the difference between the values i and j. 


FUNCTION PACKLAYER(); 

If LAYERTHICKNESS=0 do {PACKINGS; RETURN;}; 

Initialize the first and only node to the layer’s X and Z values: 

SCRAPFIRST.CUMX=PX; SCRAPFIRST.CUMZ=0; 

Perform an infinite loop unless ‘Q’ is typed to quit { 

Check the keyboard input, if ‘Q’ is hit, exit die loop and RETURN; 

To find the gap with the least Z value in the layer call FINDSMALLEST(); 

SITUATION-1: 

If there is no box on both sides of the gap do { 

Calculate the gap’s X and Z dimensions; 

To find the most suitable boxes to the gap found, by looking at; 
the X-dimension of the gap: LENX, 
layerthickness of the gap: LAYERTHICKNESS, 
maximum available thickness to the gap: REMAINPY, 
maximum available Z dimension to the gap: LPZ; 
call FINDBOX(LENX, LAYERTHICKNESS, REMAINPY, LPZ, 
LPZ); 

Check on the boxes found by the FINDBOX() function by calling 
CHECKFOUND(); 

If the packing of the layer is finished, exit the loop; 

If the edge of the layer is evened, go to the first line of the next loop; 

Add a new node to the linked list showing the topology of the edge of the 
currently being packed layer after packing a new box, and set all 
the necessary variables and pointers properly; 

To check the hundred percent packing condition, 
call VOLUMECHECKQ; 



SITUATION-2: 

If there is no box on the left side of the gap do { 

Calculate the gap’s X and Z dimensions; 

To find the most suitable boxes to the gap found, by looking at; 
the X dimension of the gap: LENX, 
layerthickness of the gap: LAYERTHICKNESS, 
maximum available thickness to the gap: REMAINPY, 
the Z dimension of the gap: LENZ, 
maximum available Z dimension to the gap: LPZ; 
call FINDBOX(LENX, LAYERTHICKNESS, REMAINPY, 
LENZ, LPZ); 

Check on the boxes found by the FINDBOX() function by calling 
CHECKFOUND(); 

If the packing of the layer is finished, exit the loop; 

If the edge of the layer is evened, go to the first line of the next loop; 

Set all the necessary variables and pointers properly to represent the 
current topology of the edge of the layer that is currently being 
packed; 

If the edge of the current layer is evened, set all the necessary variables 
and pointers properly and dispose the unnecessary node; 

To check the hundred percent packing condition, call VOLUMECHECKO 

} 

SITUATION-3: 

If there is no box on the right side of the gap do { 

Calculate the gap’s X and Z dimensions; 

To find the most suitable boxes to the gap found, by looking at; 
the X dimension of the gap: LENX, 
layerthickness of the gap: LAYERTHICKNESS, 
maximum available thickness to the gap: REMAINPY, 
the Z dimension of the gap: LENZ, 
maximum available Z dimension to the gap: LPZ; 
call FINDBOX(LENX, LAYERTHICKNESS, REMAINPY, 
LENZ, LPZ); 

Check on the boxes found by the FINDBOXO function by calling 
CHECKFOUND(); 

If the packing of the layer is finished, exit the loop; 

If the edge of the layer is evened, go to the first line of the next loop; 

Set all the necessary variables and pointers properly to represent the 
current topology of the edge of the layer that is currently being 
packed; 

If the edge of the current layer is evened, set all the necessary variables 
and pointers properly and dispose the unnecessary node; 

To check the hundred percent packing condition, call VOLUMECHECKO 


} 





SITUATION-4: IF THERE ARE BOXES ON BOTH SIDES OF THE GAP 


SUBSITUATION-4A 

If the Z dimensions of the gap is the same on both sides { 

Calculate the gap’s X and Z dimensions; 

To find the most suitable boxes to the gap found, by looking at; 
the X dimension of the gap: LENX, 
layerthickness of the gap: LAYERTHICKNESS, 
maximum available thickness to the gap: REMAINPY, 
the Z dimension of the gap: LENZ, 
maximum available Z dimension to the gap: LPZ; 
call FINDBOX(LENX, LAYERTHICKNESS, REMAINPY, 
LENZ, LPZ); 

Check on the boxes found by the FINDBOX() function by calling 
CHECKFOUNDO; 

If the packing of the layer is finished, exit the loop; 

If the edge of the layer is evened, go to the first line of the next loop; 

Set all the necessary variables and pointers properly to represent the 
current topology of the edge of the layer that is currently being 
packed; 

While updating the edge of topology information, if a part of the topology 
is evened, dispose unnecessary nodes, and update the others 
properly; 

While updating the edge of topology information, if another gap is added 
to the topology, add a new node to keep this gap, and update the 
others properly; 

To check the hundred percent packing condition, 
call VOLUMECHECKQ; 


} 



SUBSITUATION-4B 

If the Z dimension of the gap is different on both sides { 

Calculate the gap’s X and Z dimensions; 

To find the most suitable boxes to the gap found, by looking at; 
the X dimension of the gap: LENX, 
layerthickness of the gap: LAYERTHICKNESS, 
maximum available thickness to the gap: REMAINPY, 
the Z dimension of the gap: LENZ, 
maximum available Z dimension to the gap: LPZ; 
call FINDBOX(LENX, LAYERTHICKNESS, REMAINPY, 
LENZ, LPZ); 

Check on the boxes found by the FINDBOX() function by calling 
CHECKFOUNDO; 

If the packing of the layer is finished, exit the loop; 

If the edge of the layer is evened, go to the first line of the next loop; 

Set all the necessary variables and pointers properly to represent the 
current topology of the edge of the layer that is currently being 
packed; 

While updating the edge of topology information, if another gap is added 
to the topology, add a new node to keep this gap, and update the 
others properly; 

To check the hundred percent packing condition, 
call VOLUMECHECKO; 




FUNCTION FINDLAYERO; 


Set the overall evaluation value to a big number: EVAL=1000000; 

For X=1 to TBN { 

If the box number X has already been packed continue with the next loop: 

If BOXLIST[X].PACKST*0 continue; 

Get each dimension of each box, one at a time by doing: 

For Y=1 to 3 { 

If Y=1 do { 

EXDIM=BOXLIST[X].DIMl; 

DIMEN2=BOXLIST[X].DIM2; 

DIMEN3=BOXLIST[X].DIM3; 

} 

If Y=2 do { 

EXDIM=BOXLIST[X].DIM2; 

DIMEN2=BOXLIST[X].DIMl; 

DIMEN3=BOXLIST[X].DIM3; 

} 

If Y=3 do { 

EXDIM=BOXLIST[X].DIM3; 

DIMEN2=BOXLIST[X].DIMl; 

DIMEN3=BOXLIST[X].DIM2; 

} 

If any of the dimensions of the box being examined cannot fit into the 

pallet’s respective dimensions, exit this loop and continue with the 
next loop; 

Set the evaluation value of the EXDIM to 0 by doing LAYEREVAL=0; 
ForZ=l to TBN do{ 

Get the closest dimension value of each box to the EXDIM by 

looking at the absolute values of differences between each 
dimension and EXDIM, and selecting the smallest value; 
and set the variable DIMDIF to this value. 

Add those values cumulatively by doing: 

LAYEREVAL=LAYEREVAL+DIMDIF; 

} 

If the dimension that has just been examined has a smaller evaluation 
value, keep that dimension: 

If (LAYEREVAL<EVAL) do { EVAL=LAYEREVAL; 
LAYERTHICKNESS=EXDIM}; 

} 

} 

RETURN; 





FUNCTION FINDBOX (HMX: Maximum X dimension of the gap; 

HY: Y dimension of the gap; HMY: Maximum Y dimension of the gap; 

HZ: Z dimension of the gap; HMZ: Maximum Z dimension of the gap); 

Set all evaluation values to big numbers: 

For the box type fitting in the current layerthickness: 

BFX=32767; BFY=32767; BFZ=32767; 

For the box type that cannot fit in the current layerthickness, but the closest one: 
BFX=32767; BFY=32767; BFZ=32767; 

For Y=1 to TBN with step BOXLIST[Y].N do{ (Examines only different boxes) 

If the box that is being examined has been packed before, continue with the next 
loop; 

X=The index of the box that has not been packed before among a certain type of 
box; 

Analyze all six possible orientations of the box being examined: 

ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, BOXLIST[X].DIMl, 
BOXLIST[X].DIM2, BOXLIST[X].DIM3); 

ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, BOXLIST[X].DIMl, 
BOXLIST[X].DIM3, BOXLIST[X].DIM2); 

ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, BOXLIST[X].DIM2, 
BOXLIST[X].DIMl,BOXLIST[X].DIM3); 

ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, BOXLIST[X].DIM2, 
BOXLIST[X].DIM3, BOXLIST[X].DIMl); 

ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, BOXLIST[X].DIM3, 
BOXLIST[X].DIM1, BOXLIST[X].DIM2); 

ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, BOXLIST[X].DIM3, 
BOXLIST[X].DIM2, BOXLIST[X].DIMl); 

} 

RETURN; 


A-9 




FUNCTION ANALYZEBOX (HMX, HY, HMY, HZ, HMZ, DIM1, DIM2, DIM3); 

(If all dimensions of the given box fit the maximum space in the gap:) 

If (DIM1<=HMX and DIM2<=HMY and DIM3<=HMZ) do{ 

(If the y-dimension of the current orientation of the box fits to the gap’s 

layer thickness:) 

If (DIM2<=HY) do { 

If the current box is a better fit in respect to its y-dimension compared to 
the one selected before, keep the index of the current box in the 
variable BOXI; 

If the current box has the same y-dimension as the y-dimension of the 

selected one before, and the current box is a better fit in respect to 
its x-dimension compared to the selected one before, keep the 
index of the current box in the variable BOXI; 

If the current box has the same y and x-dimensions as the y and x 

dimensions of the selected one before, and the current box is a 
better fit in respect to its z-dimension compared to the one selected 
before, keep the index of the current box in the variable BOXI; 

} 

(If the y-dimension of the current orientation of the box is bigger than the gap’s 

layer thickness:) 

If (DIM2>HY) do { 

If the current box is a better fit in respect to its y-dimension compared to 
the one selected before, keep the index of the current box in the 
variable BBOXI; 

If the current box has the same y-dimension as the y-dimension of the 

selected one before, and the current box is a better fit in respect to 
its x-dimension compared to the selected one before, keep the 
index of the current box in the variable BBOXI; 

If the current box has the same y and x-dimensions as the y and x- 

dimensions of the selected one before, and the current box is a 
better fit in respect to its z-dimension compared to the one selected 
before, keep the index of the current box in the variable BBOXI; 

} 

} 

RETURN; 


A-10 


FUNCTION FINDSMALLESTQ; 


Get the first node of the linked list representing the edge topology of the current layer: 
SCRAPMEMB=SCRAPFIRST; 

Assign it to the variable which will keep the node with a smallest z-value: 

SMALLESTZ=SCRAPMEMB; 

While SCRAPMEMB.POS*NULL do { 

If (SCRAPMEMB.POS).CUMZ < SMALLEST.CUMZ then 
SMALLESTZ=SCRAPMEMB .POS; 
SCRAPMEMB-SCRAPMEMB.POS; 

} 

RETURN; 


FUNCTION CHECKFOUND (); 

(If a box fitting in the current layer thickness has been found, keep its index and 
orientation for packing:) 

If BOXteO then do{ CBOXI=BOXI; CBOXX=BOXX; CBOXY=BOXY; 
CBOXZ=BOXZ}; 

Else { 

If a box with a bigger y-dimension than the current layer thickness has been found 
and the edge of the current layer is even then select that box and set 
LAYERINLAYER variable for a second layer packing in the current layer 
and update the LAYERTHICKNESS=BBOXY; 

Else { 

If there is no gap in the edge of the current layer, packing of the layer is 
done: LAYERDONE= 1; 

Else: Since there is no fitting box to the currently selected gap, skip that 
gap and even it by arranging and updating the necessary nodes and 
variables; 

} 

} 

RETURN; 


A-ll 



FUNCTION VOLUMECHECK (); 


Mark the current box as packed: BOXLIST[CBOXI].PACKED=l; 

Keep the orientation of the current box as it is packed: 
BOXLIST[CBOXI].PACKX=CBOXX; 

BOXLIST[CBOXI].PACKY=CBOXY; 

BOXLIST[CBOXI].PACKZ=CBOXZ; 

Update the total packed volume: 

P ACKED V OLUME=P ACKED V OLUME+BOXLIST[CBOXI] .VOL; 

Update the number of boxes packed: PACKEDNUMBOX=PACKEDNUMBOX+l; 

(If performing the best so far packing after being done with the iterations:) 

If PACKINGBEST=1 do { 

To write the information of the packed box to the visualization data file named 
“VISUAL”, call GRAPHUNPACKEDOUT; 

To write the information of the packed box to the report file, 
call OUTPUTBOXLIST; 

} 

Else if a hundred percent packing of the pallet has been reached or the total volume of the 
packed boxes is equal to the total volume of the input box set { 

Packing is finished: PACKING=0; 

A hundred percent packing has been reached: HUNDREDPERCENT=1; 

} 

RETURN; 


FUNCTION GRAPHUNPACKEDOUT(); 

If this function is called for a visualization data out, write the necessary information to 
the file “VISUAL”; 

Else merge the unpacked box information to the end of the report file; 

RETURN; 


OUTPUTBOXLIST (); 

Transform the coordinate system and orientation of every box from the best solution 

format to the pallet orientation entered by the user in the input text file by looking 
at the value of the variable BESTVARIANT; 

Write the transformed box information (coordinates and the dimensions as is has been 
packed) to the REPORT file; 

RETURN; 


A-12 



FUNCTION REPORT (); 


Set the necessary variables to start the best packing found properly; 

According to the BESTVARIANT value, determine the orientation of the pallet; 

To tell other functions that the best packing found is being performed: 

PACKINGBEST=1; 

Write the header information about the best solution found to the visualization data file 
“VISUAL”; 

Write the header information about the best solution found to the report data file; 

List all possible candidate values by calling LISTCANDITLAYERSO; 

Sort the array LAYERS in respect to its LAYEREVAL fields in increasing order by 
using QSORT; 

Set the starting layer thickness value to the best solution’s starting layer thickness value: 

LAYERTHICKNESS^ LAYERS [BESTITE] .LAYERDIM; 

Set all boxes’ packed status to 0: For X=1 to TBN do BOXLIST[X].PACKST=0; 
do { 

Set the variable that shows remaining unpacked potential second layer height in 
the current layer: LAYERINLAYER=0; 

Set the flag variable that shows packing of the current layer is finished or not: 
LAYERDONE=0; 

Call PACKLAYER(), to pack the layer, and if a memory error is responded, exit 
the program; 

If there is a height available for packing in the current layer, perform another 
layer packing in the current layer: 

If LAYERINLAYER^O do { 

Get the height available for packing in the current layer as the layer 

thickness to be packed: LAYERTHICKNESS=LAYERINLAYER; 
Call PACKLAYERO, to pack the layer, and if a memory error is 
responded, exit the program; 

} 

Call FINDLAYER(REMAINPY) to determine the most suitable layer height 
fitting in the remaining unpacked height of the pallet; 

} While PACKING*0; 

Get the difference of the start time and the finish time; 

Close both the visualization data file and the report file; 

Write all the information about packing to the console; 

RETURN; 


A-13 



Appendix B - The C Program Code of the Model 


// INCLUDED HEADER FILES 


#include <time.h> 
#include <stdio.h> 
#include <string.h> 
#include <stdlib.h> 
#mclude <malloc.h> 
#include <conio.h> 


// FUNCTION PROTOTYPES 


void initialize(void); 

void inputboxlist(void); 

void execiterations(void); 

void listcanditlayers(void); 

int complayerlist(const void *i, const void *j); 

int packlayer(void); 

int findlayer( short int thickness); 

void findbox(short int hmx, short int hy, short int hmy, short int hz, short int hmz); 
void analyzebox (short int hmx, short int hy, short int hmy, short int hz, short int hmz, 

short int diml, short int dim2, short int dim3); 

void findsmallestz(void); 
void checkfound(void); 
void volumecheck (void); 
void graphunpackedout(void); 
void outputboxlist(void); 
void report(void); 



/y'******************************************************** 

// VARIABLE, CONSTANT AND STRUCTURE DECLARATIONS 

^sie^s^^* *********************************** **************** 


char strpx[5], strpy[5], strpz[5], strcox[5], strcoy[5], strcoz[5], strpackx[5], strpacky[5], 
strpackz[5], filename[12], strtemp[]="", packing, layerdone, evened, variant, 
bestvariant, packingbest, hundredpercent, graphout[]="visudat", unpacked, quit; 

short int tbn, x, n, layerlistlen, layerinlayer, prelayer, lilz, itenum, hour, min, sec, 

layersindex, remainpx, remainpy, remainpz, packedy, prepackedy, layerthickness, 
itelayer, boxx, boxy, boxz, boxi, bboxx, bboxy, bboxz, bboxi, preremainpy, cboxi, 
cboxx, cboxy, cboxz, bfx, bfy, bfz, bbfx, bbfy, bbfz, bestite, packednumbox, 
bestpackednum, xx, yy, zz, px, py, pz; 

double packedvolume, bestvolume, totalvolume, totalboxvol, temp, percentageused, 
percentagepackedbox, elapsedtime; 

struct boxinfo { 

char packst; 

short int diml, dim2, dim3, n, cox, coy, coz, packx, packy, packz; 
long int vol; 

} boxlist[5000]; 

struct layerlist{ 

long int layereval; 
short int layerdim; 

} layers[1000]; 

struct scrappad{ 

struct scrappad *pre, *pos; 
short int cumx, cumz; 


struct scrappad *scrapfirst, *scrapmemb, *smallestz, *trash; 
time_t start, finish; 

FILE *ifp, *ofp, *gfp; 


B-2 




//MAIN PROGRAM 


int main(int argc, char *argv[]) { 
if (argc==l){ 

printf ("(ASSUMED TO HAVE ’.TXT' EXTENSION; UP TO 8 
CHARACTERS LONG)\n"); 

printf ("PLEASE ENTER THE NAME OF THE INPUT FILE :"); 
scanf ("%s",filename); 

} 

else { 

printf("%s", argv[l]); 
strcpy(filename, argv[l]); 

} 

initialize(); 

time(&start); 

printf("\nPRESS Q TO QUIT AT ANYTIME AND WAIT\n\n"); 

execiterations(); 

time(&finish); 

report(); 

getch(); 

return 0; 

} 


// PERFORMS INITIALIZATIONS 


void initialize(void) { 

if (filename=""){ 

printf("\nINVALID FILE NAME\n"); 
exit(l); 

} 

inputboxlist(); 

temp=1.0; totalvolume=temp*xx*yy*zz; totalboxvol=0.0; 
for (x=l; x<=tbn; x++) totalboxvol=totalboxvol+boxlist[x].vol; 
scrapfirst=malloc(sizeof(struct scrappad)); 
if ((*scrapfirst).pos==NULL){ 

printf("Insufficient memory available\n"); 
exit(l); 

} 

(* scrapfirst).pre=NULL;(* scrapfirst) .pos=NULL; 
bestvolume=0.0; packingbest=0; hundredpereent=0; itenum=0; quit=0; 

} 


B-3 



yy********************************************************************** 

// READS THE PALLET AND BOX SET DATA ENTERED BY THE USER FROM 
// THE INPUT FILE 


void inputboxlist(void){ 
short int n; 

char lbl[5], diml[5], dim2[5], dim3[5], boxn[5], strxx[5], stryy[5], strzz[5]; 

strcpy(strtemp, filename); 

strcat(strtemp,".txt"); 

if ((ifjp=fopen(strtemp,"r , '))==NULL) { 

printf("Cannot open file %s", strtemp); 
exit(l); 

} 

tbn=l; 

if (fscanf(ifp,"%s %s %s",strxx, stryy, strzz)=EOF) exit(l); 
xx=atoi(strxx); yy=atoi(stryy); zz=atoi(strzz); 

while (fscanf(ifp,"%s %s %s %s %s",lbl,diml ,dim2,dim3,boxn) !=EOF) { 
boxlist[tbn] .dim 1 =atoi(dim 1); 
boxlist[tbn] .dim2=atoi(dim2); 
boxlist[tbn] .dim3=atoi(dim3); 

boxlist[tbn]. vol=boxlist[tbn] .diml *boxlist[tbn] .dim2*boxlist[tbn] .dim3; 

n=atoi(boxn); boxlist[tbn].n=n; 

while (--n) boxlist[tbn+n]=boxlist[tbn]; 

tbn=tbn+atoi(boxn); 

} 

-tbn; 

fclose(ifp); 

return; 

} - 


B-4 



// ITERATIONS ARE DONE AND PARAMETERS OF THE BEST SOLUTION ARE 
// FOUND 

yy * * * * * * * * * * S|c * * * * * * * * * * * * * * * * * * * * * * 5jj * * * * * * * Jj. 5J. * ,J. Jj. * Jj. * £ £ £ jJj ^ Jj. Jj. £ Jj. Jj, ^ £ Jjj jjj ^ £ * Jj, £ Jj. Jj. 


void execiterations(void) { 

for (variant=l; (variant<=6) & !quit; variant++){ 
switch(variant){ 
case 1: 

px=xx; py=yy; pz=zz; 
break; 

case 2: 

px=zz; py=yy; pz=xx; 
break; 

case 3: 

px=zz; py=xx; pz=yy; 
break; 

case 4: 

px=yy; py=xx; pz=zz; 
break; 

case 5: 

px=xx; py=zz; pz=yy; 
break; 

case 6: 

px-yy; py=zz; pz=xx; 
break; 

} 

listcanditlayers(); 
layers[0] ,layereval=-1; 

qsort(layers,layerlistlen+1 ,sizeof(struct layerlist),complayerlist); 
for (layersindex=l; (layersindex<=layerlistlen) & !quit; layersindex++){ 
++itenum; 
time(&ftnish); 

elapsedtime = difftime( finish, start); 

printf("VARIANT: %5d; ITERATION (TOTAL): %5d; BEST SO 
FAR: %.3f %%; TIME: %.0f, 
variant, itenum, percentageused, elapsedtime); 
packedvolume=0.0; 
packedy=0; 
packing=l; 

layerthickness=layers[layersindex].layerdim; 
itelayer=layersindex; 
remainpy=py; remainpz=pz; 
packednumbox=0; 

for (x=l; x<=tbn; x++) boxlist[x] .packst=0; 


B-5 



do { 

layerinlayer=0; 

layerdone=0; 

if (packlayer()) exit(l); 

packedy=packedy+layerthickness; 

remainpy=py-packedy; 

if (layerinlayer & !quit){ 

prepackedy=packedy; 

preremainpy=remainpy; 

remainpy=layerthickness-prelayer; 

packedy=packedy-layerthickness+prelayer; 

remainpz=lilz; 

layerthickness=layerinlayer; 

layerdone=0; 

if (packlayer()) exit(l); 

packedy=prepackedy; 

remainpy=preremainpy; 

remainpz=pz; 

} 

findlayer(remainpy); 

} 

while (packing & !quit); 

if ((packedvolume>bestvolume) & !quit) { 
bestvolume=packedvolume; 
bestvariant^variant; 
bestite=itelayer; 

bestpackednum=packednumbox; 

} 

if (hundredpercent) break; 

percentageused=bestvolume* 100/totalvolume; 

printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 

\b\b\b\b\b\b\b\b\b\b\b"); 

printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 

\b\b\b\b\b\b\b"); 

} 

if (hundredpercent) break; 

if ((xx==yy) & (yy==zz)) variant=6; 



// LISTS ALL POSSIBLE LAYER HEIGHTS BY GIVING A WEIGHT VALUE TO 
// EACH OF THEM. 

//********************************************************************** 


void listcanditlayers(void){ 


char same; 

short int exdim,dimdif,dimen2,dimen3,y,z,k; 
long int layereval; 


layerlistlen=0; 

for (x=l; x<=tbn; x++){ 

for (y=l; y<=3; y++){ 
switch(y){ 
case 1: 

exdim=boxlist[x] .dim 1; 
dimen2=boxlist[x] .dim2; 
dimen3=boxlist[x] .dim3; 
break; 

case 2: 

exdim=boxlist[x].dim2; 
dimen2=boxlist[x].diml; 
dimen3=boxlist[x] .dim3; 
break; 

case 3: 

exdim=boxlist[x] .dim3; 
dimen2=boxlist[x] .dim 1; 
dimen3=boxlist[x] .dim2; 
break; 

} 

if ((exdim>py) || (((dimen2>px) || (dimen3>pz)) & 

((dimen3>px) || (dimen2>pz)))) continue; 

same=0; 

for (k=l; k<=layerlistlen; k++) if (exdim=layers[k].layerdim){ 
same=l; 
continue; 

} 

if (same) continue; 
layereval=0; 


B-7 




for (z=l; z<=tbn; z++) { 
if(!(x==z)){ 

dimdif=abs(exdim-boxlist[z] .diml); 
if (abs(exdim-boxlist[z] .dim2)<dimdif) 

dimdif=abs(exdim-boxlist[z].dim2); 
if (abs(exdim-boxlist[z] .dim3)<dimdif) 

dimdif=abs(exdim-boxlist[z].dim3); 

layereval=layereval+dimdif; 

} 

} 

layers[++layerlistlen].layereval=layereval; 
layers [layerlistlen].layerdim=exdim; 

} 

} 

return; 

} 


// REQUIRED FUNCTION FOR QSORT FUNCTION TO WORK 


int complayerlist(const void *i, const void *j){ 
return *( long int*)i-*( long int*)j; 

} 


// PACKS THE BOXES FOUND AND ARRANGES ALL VARIABLES AND 
// . RECORDS PROPERLY 

yy******$*******$************************************************ 


int packlayer( void){ 

short int lenx, lenz, lpz; 

if (! layerthickness) { 

packing=0; return 0; 

} 

(* scrap first). cumx=px;(* scrapfirst). cumz=0; 
for (;!quit;){ 

if (kbhitO) if (toupper(getch())=='Q') { 
quit=l; 

printf("\n\nWait please...\n"); 

} 

findsmallestz(); 


B- 8 




II*** SITUATION-1: NO BOXES ON THE RIGHT AND LEFT SIDES *** 


if (!(*smallestz).pre & !(*smallestz).pos){ 
lenx=(* smallestz). cumx; 
lpz=remainpz-(*smallestz).cumz; 
findbox(lenx, layerthickness, remainpy, lpz, lpz); 
checkfound(); 
if (layerdone) break; 
if (evened) continue; 

boxlist[cboxi].cox=0; boxlist[cboxi].coy=packedy; 
boxlist[cboxi] ,coz=(*smallestz) .cumz; 
if (cboxx—(*smallestz).cumx) 

(*smallestz).cumz=(*smallestz).cumz+cboxz; 

else { 

(*smaliestz).pos=malloc(sizeof( struct scrappad)); 
if ((*smallestz).pos==NULL){ 

printf("Insufficient memory available\n"); 
return 1; 

} 

(*((*smallestz).pos)).pos=NULL; 

(*((*smallestz).pos)).pre=smallestz; 

(*((*smallestz).pos)).cumx=(*smallestz).cumx; 

(*((*smallestz).pos)).cumz=(*smallestz).cumz; 

(*smallestz).cumx=cboxx; 

(*smallestz).cumz=(*smallestz).cumz+cboxz; 

} 

volumecheck(); 

} 

II*** SITUATION-2: NO BOXES ON THE LEFT SIDE *** 

else if (!(*smallestz).pre){ 

lenx=(*smallestz).cumx; 

lenz=(*((*smallestz).pos)).cumz-(*smallestz).cumz; 
lpz=remainpz-(* smallestz). cumz; 
fmdbox(lenx, layerthickness, remainpy, lenz, lpz); 
checkfound(); 
if (layerdone) break; 
if (evened) continue; 
boxlist[cboxi].coy=packedy; 
boxlist[cboxi].coz=(*smallestz).cumz; 
if (cboxx==( !i: smallestz).cumx){ 
boxlist[cboxi].cox=0; 


B-9 




} 


if (*smallestz).cumz+cboxz=(*((*smallestz).pos)).cumz) { 
(*smallestz).cumz=(*((*smallestz).pos)).cumz; 

(* smallestz). cumx=( * ((* smallestz) .pos)). cumx; 
trash=( * smallestz) .pos; 
(*smallestz).pos=(*((*smallestz).pos)).pos; 
if ((* smallestz).pos) 

(*((*smallestz).pos)).pre=smallestz; 

free(trash); 

} 

else (* smallestz). cumz=(* smallestz) .cumz+cboxz; 

} 

else { 

boxlist[cboxi].cox=(*smallestz).cumx-cboxx; 
if ((*smallestz).cumz+cboxz==(*((*smallestz).pos)).cumz) 
(*smallestz).cumx=(*smallestz).cumx-cboxx; 

else { 

(*((*smallestz).pos)).pre= 

malloc(sizeof(struct scrappad)); 
if ((*((*smallestz).pos)).pre=NULL) { 

printf("Insufficient memory available\n"); 
return 1; 

} 

(*((*((* Sma ll eS t Z ).p OS )).pre)).p OS =(*s ma llestz).pos; 

(*((*((* Srna lle S t Z ).p 0S )).p re )).p re = S mall eS tz; 

(*smallestz).pos=(*((*smallestz).pos)).pre; 

(*((*smallestz).pos)).cumx=(*smallestz).cumx; 

(* smallestz). cumx=(*smallestz).cumx-cboxx; 
(*((*smallestz).pos)).cumz= 

(*smallestz).cumz+cboxz; 


} 

} 

volumecheck(); 


B-10 



II*** SITUATION-3: NO BOXES ON THE RIGHT SIDE *** 


else if (!(*smallestz).pos){ 

lenx=(*smallestz).cumx-(*((*smallestz).pre)).cumx; 

lenz=(*((*smallestz).pre)).cumz-(*smallestz).cumz; 

lpz=remainpz-(* smallestz). cumz; 

findbox(lenx, layerthickness, remainpy, lenz, Ipz); 

checkfound(); 

if (layerdone) break; 

if (evened) continue; 

boxlist[cboxi].coy=packedy; 

boxlist[cboxi].coz=(*smallestz).cumz; 

boxlist[cboxi].cox=(*((*smallestz).pre)).cumx; 

if (cboxx=(*smallestz).cumx-(*((*smallestz).pre)).cumx) { 

if((*smallestz).cumz+cboxz==(* ((* smallestz) .pre)). cumz) { 
(*((*smallestz).pre)).cumx=(*smallestz).cumx; 
(*((*smallestz).pre)).pos=NULL; 
free(smallestz); 

} 

el se (* small estz). cumz=( * smallestz). cumz+cboxz; 


} 

else { 


if ((*smallestz).cumz+cboxz=(*((*smallestz).pre)).cumz) 
(*((*smallestz).pre)).cumx= 

(*((*smallestz).pre)).cumx+cboxx; 


else { 


(*((*smallestz).pre)).pos= 

malloc(sizeof(struct scrappad)); 
if ((*((*smallestz).pre)).pos=NULL) { 

printf("Insufficient memory available\n"); 
return 1; 

} 

(*((*((* Sma ll eS t Z ).p re )).p 0S )).p re =(* Sma lle S tz).pre; 

(*((*((* Sm allest Z ).p re )).p 0S )).p 0S = Sma llestz; 

(*smallestz).pre=(*((*smallestz).pre)).pos; 

(*((*smallestz).pre)).cumx= 

(* ((*((* smallestz) .pre)) .pre)). cumx+cboxx; 
(*((*smallestz).pre)).cumz= 

(*smallestz).cumz+cboxz; 


volumecheck(); 


B-11 



II*** SITUATION-4: THERE ARE BOXES ON BOTH OF THE SIDES *** 

II*** SUB SITUATION-4 A: SIDES ARE EQUAL TO EACH OTHER *** 

else if ((*((*smallestz).pre)).cumz=(*((*smallestz).pos)).cumz){ 
lenx=(*smallestz).cumx-(*((*smallestz).pre)).cumx; 
lenz=(*((*smallestz).pre)).cumz-(*smallestz).cumz; 
lpz=remainpz-(*smallestz).cumz; 
findbox(lenx, layerthickness, remainpy, lenz, lpz); 
checkfoundO; 
if (layerdone) break; 
if (evened) continue; 

boxlist[cboxi] .coy=packedy;boxlist[cboxi] .coz=(*smallestz).cumz; 
if (cboxx==(*smallestz).cumx-(*((*smallestz).pre)).cumx) { 
boxlist[cboxi].cox=(*((*smallestz).pre)).cumx; 
if((*smallestz).cumz+cboxz==(*((*smallestz).pos)).cumz){ 
(*((*smallestz).pre)).cumx= 

(*((*smallestz).pos)).cumx; 
if ((*((*smallestz).pos)).pos) { 

(*((*smallestz).pre)).pos= 

(*((*smallestz).pos)).pos; 
(*((*((* smallestz) .pos)) .pos)) .pre= 

(*smallestz).pre; 

free(smallestz); 

} 

else { 

(*((*smallestz).pre)).pos=NULL; 

free(smallestz); 

} 

} 

else (* smallestz). cumz=( * smallestz). cumz+cboxz; 

} 

else if ((*((*smallestz).pre)).cumx<px-(*smallestz).cumx){ 

if((*smallestz).cumz+cboxz=(*((*smallestz).pre)).cuinz){ 

(*smallestz).cumx=(*smallestz).cumx-cboxx; 

boxlist[cboxi].cox=(*smallestz).cumx-cboxx; 

} 

else { 

boxlist[cboxi].cox=(*((*smallestz).pre)).cumx; 

(* ((* smallestz) .pre)) .po s= 

malloc(sizeof(struct scrappad)); 
if ((*((*smallestz).pre)).pos==NULL) { 

printf("Insufficient memory available\n"); 
return 1; 

} 

(*((*((* smallestz) .pre)) .pos)) .pre=(*smallestz).pre; 


B-12 



} 


} 

else { 


} 


(*((*((* Sma ll eS tz).p r e)).po S )).pos= Sma llest Z ; 

(*smallestz).pre=(*((*smallestz).pre)).pos; 

(*((*smallestz).pre)).cumx= 

(*((*((* sma ll eS tz).pre)).p re )).cuinx+cboxx; 

(*((*smallestz).pre)).cumz= 

(*smallestz).cumz+cboxz; 


if((*smallestz).cumz+cboxz==(*((*smallestz).pre)).cumz){ 

(*((*smallestz).pre)).cumx= 

(*((*smallestz).pre)).cumx+cboxx; 

boxlist[cboxi].cox=(*((*smallestz).pre)).cumx; 

} 

else { 

boxlist[cboxi].cox=(*smallestz).cumx-cboxx; 

(*((*smallestz).pos)).pre= 

malloc(sizeof(struct scrappad)); 
if ((*((*smallestz).pos)).pre=NULL) { 

printf("Insufficient memory available\n"); 
return 1; 


} 

(*((*((* sma ll eS tz).p 0 s)).p r e)).po S =(*s ma lle S tz).p 0 s; 

(*((*((* S ma lle S t z ).po S )).p r e )).p r e =s ma ll e S t z ; 

(*smallestz).pos=(*((*smallestz).pos)).pre; 

(*((*sm a llestz).pos)).cumx=(*smallestz).cumx; 

(*((*smallestz).pos)).cumz= 

(*smallestz).cumz+cboxz; 

(*smallestz).cumx=(*sm a llestz).cumx-cboxx; 

} 


} 

volumecheckQ; 


II*** SUBSITUATION-4B: SIDES ARE NOT EQUAL TO EACH OTHER *** 
else { 

lenx=(*smallestz).cumx-(*((*smallestz).pre)).cumx; 

lenz=(*((*sm a llestz).pre)).cumz-(*smallestz).cumz; 

lpz=rem a inpz-(*smallestz).cumz; 

findbox(lenx, layerthickness, remainpy, lenz, lpz); 

checkfound(); 

if (layerdone) break; 

if (evened) continue; 

boxlist[cboxi] .coy=packedy;boxlist[cboxi] .coz=(*smallestz).cumz; 


B-13 



} 

} 

return 0; 


boxlist[cboxi].cox=(*((*smallestz).pre)).cumx; 
if (cboxx==(*smallestz).cumx-(*((*smallestz).pre)).cumx) { 

if((*smallestz).cumz+cboxz==(*((*smallestz).pre)).cumz){ 

(*((*smallestz).pre)).cumx=(*smallestz).cumx; 

(*((*smallestz).pre)).pos=(*smallestz).pos; 

(*((*smallestz).pos)).pre=(*smallestz).pre; 

firee(smallestz); 

} 

else (*smallestz).cumz=(*smallestz).cumz+cboxz; 

} 

else { 

if ((*smallestz).ciunz+cboxz==(*((*smallestz).pre)).cumz) 
(*((*smallestz).pre)).cumx= 

(*((*smallestz).pre)).cumx+cboxx; 
else if ((*smallestz).cumz+cboxz== 

(*((*smallestz).pos)).cumz) { 
boxlist[cboxi].cox=(*smallestz).cumx-cboxx; 
(*smallestz).cumx=(*smallestz).cumx-cboxx; 

} 

else{ 

(* ((* smallestz).pre)) .pos= 

malloc(sizeof(struct scrappad)); 
if ((*((*smallestz).pre)).pos==NULL) { 

printf("Insufficient memory available\n"); 
return 1; 

} 

(*((*((* S m a lle S t Z ).p re )).pos)).pre=(*s ma llestz).pre; 

(*((*((* S m a ll eS t z ).pr e )).p o s)).p° S : = sma llest z ; 

(*smallestz).pre=(*((*smallestz).pre)).pos; 

(*((*smallestz).pre)).cumx= 

(*((*((* smallestz) .pre)) .pre)). cumx+cboxx; 
(*((* smallestz) .pre)).cumz= 

(*smallestz).cumz+cboxz; 


} 

} 

volumecheckQ; 


B-14 



// FINDS THE MOST PROPER LAYER HIGHT BY LOOKING AT THE UNPACKED 
// BOXES AND THE REMAINING EMPTY SPACE AVAILABLE 

u ********************************************************************** 


int findlayer( short int thickness) { 

short int exdim,dimdif,dimen2,dimen3,y,z; 
long int layereval, eval; 

layerthickness=0; 

eval=T000000; 

for (x=l; x<=tbn; x++){ 

if (boxlist[x].packst) continue; 
for(y=l;y<=3;y++){ 
switch(y){ 
case 1: 

exdim=boxlist[x] .dim 1; 
dimen2=boxlist[x] .dim2; 
dimen3=boxlist[x] .dim3; 
break; 

case 2: 

exdim=boxlist[x] .dim2; 
dimen2=boxlist[x] .dim 1; 
dimen3=boxlist[x] .dim3; 
break; 

case 3: 

exdim=boxlist[x] .dim3; 
dimen2=boxlist[x] .dim 1; 
dimen3=boxlist[x] .dim2; 
break; 

} 

layereval=0; 

if ((exdim<=thickness) & (((dimen2<=px) & 

(dimen3<=pz)) || ((dimen3<=px) & (dimen2<=pz)))) { 
for (z=l; z<=tbn; z++){ 

if (!(x==z) & !(boxlist[z].packst)){ 

dimdif=abs(exdim-boxlist[z] .diml); 
if (abs(exdim-boxlist[z] .dim2)<dimdif) 

dimdif=abs(exdim-boxlist[z].dim2); 
if (abs(exdim-boxlist[z].dim3)<dimdif) 

dimdif=abs(exdim-boxlist[z].dim3); 

layereval=layereval+dimdif; 

} 

} 

if (layereval<eval) { 


B-15 



} 


eval=layereval; 

layerthickness=exdim; 

} 

} 

} 

} 

if (layerthickness==0 j| layerthickness>remainpy) packing=0; 
return 0; 


// FINDS THE MOST PROPER BOXES BY LOOKING AT ALL SIX POSSIBLE 
// ORIENTATIONS, EMPTY SPACE GIVEN, ADJACENT BOXES, 

// AND PALLET LIMITS 


void findbox(short int hmx, short int hy, short int hmy, short int hz, short int hmz){ 
short int y; 

bfx=32767; bfy=32767; bfz=32767; 

bbfx=32767; bbfy=32767; bbfz=32767; 

boxi=0; bboxi=0; 

for (y=l; y<=tbn; y=y+boxlist[y].n){ 

for (x=y; x<x+boxlist[y].n-l; x++) if (!boxlist[x].packst) break; 

if (boxlist[x].packst) continue; 

if (x>tbn) return; 

analyzebox (hmx, hy, hmy, hz, hmz, boxlist[x].diml, boxlist[x].dim2, 

boxlist[x].dim3); 

if ((boxlist[x].diml=boxlist[x].dim3) & 

(boxlist[x] .dim3==boxlist[x] .dim2)) continue; 

analyzebox (hmx, hy, hmy, hz, hmz, boxlist[x].diml, boxlist[x].dim3, 

boxlist[x].dim2); 

analyzebox (hmx, hy, hmy, hz, hmz, boxlist[x].dim2, boxlist[x].diml, 

boxlist[x].dim3); 

analyzebox (hmx, hy, hmy, hz, hmz, boxlist[x].dim2, boxlist[x].dim3, 

boxlist[x].diml); 

analyzebox (hmx, hy, hmy, hz, hmz, boxlist[x].dim3, boxlist[x].diml, 

boxlist[x].dim2); 

analyzebox (hmx, hy, hmy, hz, hmz, boxlist[x].dim3, boxlist[x].dim2, 

boxlist[x].diml); 

} 

} 


B-16 



// ANALYZES EACH UNPACKED BOX TO FIND THE BEST FITTING ONE TO 
// THE EMPTY SPACE GIVEN 




void analyzebox (short int hmx, short int hy, short int hmy, 

short int hz, short int hmz, 
short int dim 1, short int dim2, short int dim3){ 
if (diml<=hmx && dim2<=hmy && dim3<=hmz){ 
if (dim2<=hy) { 

if (hy-dim2<bfy) { 

boxx=diml; boxy=dim2; boxz=dim3; 
bfx=hmx-diml; bfy=hy-dim2; bfz=abs(hz-dim3); boxi=x; 

} 

else if (hy-dim2==bfy && hmx-diml <bfx) { 
boxx=diml; boxy=dim2; boxz=dim3; 
bfx=hmx-diml; bfy=hy-dim2; bfz=abs(hz-dim3); boxi=x; 

} 

else if (hy-dim2==bfy && hmx-diml— 

bfx && abs(hz-dim3)<bfz) { 
boxx=diml; boxy=dim2; boxz=dim3; 
bfx=hmx-diml; bfy=hy-dim2; bfz=abs(hz-dim3); boxi=x; 

} 

} 

else { 

if (dim2-hy<bbfy) { 

bboxx=diml; bboxy=dim2; bboxz=dim3; 
bbfx=hmx-diml; bbfy=dim2-hy; 
bbfz=abs(hz-dim3); bboxi=x; 

} 

else if (dim2-hy==bbfy && hmx-diml<bbfx) { 
bboxx=dim 1; bboxy=dim2; bboxz=dim3; 
bbfe=hmx-diml; bbfy=dim2-hy; 
bbfz=abs(hz-dim3); bboxi=x; 

} 

else if (dim2-hy==bbfy && 

hmx-diml=bbfx && abs(hz-dim3)<bbfz) { 
bboxx=diml; bboxy=dim2; bboxz=dim3; 
bbfx=hmx-diml; bbfy=dim2-hy; 
bbfz=abs(hz-dim3); bboxi=x; 


B-17 



//;fc:ic;f:;i;;J;:|;:JC5|;jf:sfc:J:;f;5l::f:;i:sfc**************************************** 

// FINDS THE FIRST TO BE PACKED GAP IN THE LAYER EDGE 

^***** 51 :************************************************** 


void fmdsmallestz(void) { 

scrapmemb=scrapfirst; 
smallestz=scrapmemb; 
while (!((*scrapmemb).pos=NULL)){ 

if ((*((*scrapmemb).pos)).cumz<(*smallestz).cumz) 

smallestz=(*scrapmemb).pos; 

scrapmemb=(*scrapmemb).pos; 

} 

return; 

} 


^************************************************************ 
// AFTER FINDING EACH BOX, THE CANDIDATE BOXES AND THE 
// CONDITION OF THE LAYER ARE EXAMINED 

y^*********************************************************** 


void checkfound(void){ 
evened=0; 
if (boxi) { 

cboxi=boxi;cboxx=boxx;cboxy=boxy;cboxz=boxz; 

} 

else { 

if ((bboxi>0) & (layerinlayer || (!(*smallestz).pre & !(*smallestz).pos))){ 
if (! layerinlayer) { 

prelayer=layerthickness; 

lilz=(*smallestz).cumz; 

} 

cboxi=bboxi;cboxx=bboxx;cboxy=bboxy;cboxz=bboxz; 

layerinlayer=layerinlayer+bboxy-layerthickness; 

layerthickness=bboxy; 

} 

else { 

if (!(*smallestz).pre & !(*smallestz).pos) layerdone=l; 
else { 

evened=l; 

if (!(*smallestz).pre){ 

trash=(*smallestz).pos; 

(*smallestz).cumx=(*((*smallestz).pos)).cumx; 

(* smallestz).cumz=(*((* smallestz) .pos)) .cumz; 
(*smallestz).pos=(*((*smallestz).pos)).pos; 
if ((*smallestz).pos) 


B-18 



} 

} 

return; 


(*((*smallestz).pos)).pre=smallestz; 

ffee(trash); 

} 

else if (!(*smallestz).pos) { 

(*((*smallestz).pre)).pos=NULL; 

(*((*smallestz).pre)).cumx=(*smallestz).cumx; 

free(smallestz); 

} 

else { 

if((*((*smallestz).pre)). cum z= 

(*((*smallestz).pos)).cumz) { 
(*((*smallestz).pre)).pos= 

(*((*smallestz).pos)).pos; 
if ((*((*smallestz).pos)).pos) 

(*((*((*s ma llest Z ).p 0S )).p 0 s)).p re = 

(*smallestz).pre; 

(*((*smallestz).pre)).cumx= 

(*((*smallestz).pos)).cumx; 

free((*smallestz).pos); 

free(smallestz); 

} 

else { 

(*((*smallestz).pre)).pos= : (*smallestz).pos; 
(*((*smallestz).pos)).pre=(*smallestz).pre; 
if ((*((*smallestz).pre)).cumz< 

(*((*smallestz).pos)).cumz) 

(*((*smallestz).pre)).cumx= 

(*smallestz).cumx; 

free(smallestz); 

} 

} 


B-19 




// AFTER PACKING OF EACH BOX, 100% PACKING CONDITION IS CHECKED 


void volumecheck (void) { 

boxlist[cboxi].packst=l; 

boxlist[cboxi] .packx=cboxx;boxlist[cboxi] .packy=cboxy; 
boxlist[cboxi] .packz=cboxz; 
packedvolume=packedvolume+boxlist[cboxi].vol; 
packednumbox++; 
if (packingbest) { 

graphunpackedout(); 

outputboxlist(); 

} 

else if (packedvolume==totalvolume || packedvolume=totalboxvol) { 
packing=0; 
hundredpercent=l; 

} 

return; 

} 


/y;ic:j;:i::j:;f::fcjf::icif::i:H:H:************************************************* 

// DATA FOR THE VISUALIZATION PROGRAM IS WRITTEN TO THE 
// “VISUDAT” FILE AND THE LIST OF UNPACKED BOXES IS 
// MERGED TO THE END OF THE REPORT FILE 

//************************************************************* 


void graphunpackedout(void) { 
char n[5]; 
if (! unpacked)! 

itoa( boxlist[cboxi].cox, strcox, 10); itoa( boxlist[cboxi].coy, strcoy, 10); 

itoa( boxlist[cboxi].coz, strcoz, 10); 

itoa( boxlist[cboxi].packx, strpackx, 10); 

itoa( boxlist[cboxi].packy, strpacky, 10); 

itoa(boxlist[cboxi].packz, strpackz, 10); 

} 

else { 

itoa( cboxi, n, 10); itoa( boxlist[cboxi].diml, strpackx, 10); 
itoa( boxlist[cboxi].dim2, strpacky, 10); 
itoa( boxlist[cboxi].dim3, strpackz, 10); 

} 

if (lunpacked) fprintf(gfp,"%5s%5s%5s%5s%5s%5s\n", 

strcox,strcoy,strcoz,strpackx,strpacky,strpackz); 
else fprintf(ofp,"%5s%5s%5s%5s\n",n,strpackx,strpacky,strpackz); 


B-20 



//********************************************************************* 
// TRANSFORMS THE FOUND COORDINATE SYSTEM TO THE ONE ENTERED 
// BY THE USER AND WRITES THEM TO THE REPORT FILE 

n******************************************************* ************** 


void outputboxlist(void) { 

char strx[5], strpackst[5], strdiml[5], strdim2[5], strdim3[5], strcox[5], strcoy[5], 
strcoz[5], strpackx[5], strpacky[5], strpackz[5]; 
short int x, y, z, bx, by, bz; 
switch(bestvariant) { 
case 1: 

x=boxlist[cboxi].cox; y=boxlist[cboxi].coy; z=boxlist[cboxi].coz; 
bx=boxlist[cboxi] .packx; by=boxlist[cboxi] .packy; 
bz=boxlist[cboxi].packz; 
break; 

case 2: 

x=boxlist[cboxi].coz; y=boxlist[cboxi].coy; z= : boxlist[cboxi].cox; 
bx=boxlist[cboxi] .packz; by=boxlist[cboxi] .packy; 
bz=boxlist[cboxi] .packx; 
break; 

case 3: 

x=boxlist[cboxi].coy; y=boxlist[cboxi].coz; z=boxlist[cboxi].cox; 
bx=boxlist[cboxi] .packy; by=boxlist[cboxi] .packz; 
bz=boxlist[cboxi] .packx; 
break; 

case 4: 

x=boxlist[cboxi].coy; y=boxlist[cboxi] .cox; z=boxlist[cboxi] .coz; 
bx=boxlist[cboxi] .packy; by=boxlist[cboxi] .packx; 
bz=boxlist[cboxi] .packz; 
break; 

case 5: 

x=boxlist[cboxi].cox; y=boxlist[cboxi].coz; z=boxlist[cboxi].coy; 
bx=boxlist[cboxi] .packx; by=boxlist[cboxi] .packz; 
bz=boxlist[cboxi].packy; 
break; 

case 6: 

x=boxlist[cboxi] .coz; y=boxlist[cboxi] .cox; z=boxlist[cboxi] .coy; 
bx=boxlist[cboxi] .packz; by=boxlist[cboxi] .packx; 
bz=boxlist[cboxi] .packy; 
break; 

} 

itoa( cboxi, strx,10); 

itoa( boxlist[cboxi].packst, strpackst, 10); 
itoa(boxlist[cboxi].diml, strdiml, 10); 
itoa( boxlist[cboxi].dim2, strdim2,10); 
itoa(boxlist[cboxi].dim3, strdim3,10); 


B-21 



itoa( x, strcox, 10); 
itoa( y, strcoy, 10); 
itoa( z, strcoz, 10); 
itoa(bx, strpackx, 10); 
itoa(by, strpacky, 10); 
itoa(bz, strpackz, 10); 

boxlist[cboxi].cox=x; boxlist[cboxi].coy=y; boxlist[cboxi].coz=z; 
boxlist[cboxi] .packx=bx; boxlist[cboxi] .packy=by; boxlist[cboxi] .packz=bz; 
fprintf(ofp,"%5s%5s%9s%9s%9s%9s%9s%9s%9s%9s%9s\n",strx,strpackst, 

strdim 1 ,strdim2,strdim3,strcox,strcoy,strcoz,strpackx,strpacky,strpackz); 

return; 


// USING THE PARAMETERS FOUND, PACKS THE BEST SOLUTION FOUND 
// AND REPORS TO THE CONSOLE AND TO A TEXT FILE 

u ******************************************************************* 


void report(void){ 
quit=0; 

switch(bestvariant) { 
case 1: 

px=xx; py=yy; pz=zz; 
break; 

case 2: 

px=zz; py=yy; pz=xx; 
break; 

case 3: 

px=zz; py=xx; pz=yy; 
break; 

case 4: 

px=yy; py=xx; pz=zz; 
break; 

case 5: 

px=xx; py=zz; pz=yy; 
break; 

case 6: 

px=yy; py=zz; pz=xx; 
break; 

} 

packingbest=l; 

if ((gfp=fopen(graphout,"w"))=NULL) { 

printf("Cannot open file %s", filename); 
exit(l); 


B-22 



itoa(px, strpx, 10); 
itoa( py, strpy, 10); 
itoa( pz, stipz, 10); 

fprintf(gfp,"%5s%5s%5s\n", strpx, strpy, strpz); 
strcat(filename,". out"); 
if ((ofp=fopen(filename,"w"))=NULL) { 

printf("Cannot open file %s", filename); 
exit(l); 

} 

percentagepackedbox=bestvolume* 100/totalboxvol; 
percentageused=bestvolume* 100/totalvolume; 
elapsedtime = difftime( finish, start); 

fprintf(ofp," *** REPORT ***\n\n"); 

fprintf(ofp," ELAPSED TIME : 

Almost %.0f sec\n", elapsedtime); 

fprintf(ofp," TOTAL NUMBER OF ITERATIONS DONE : %d\n", 

itenum); 

fprintf(ofp," BEST SOLUTION FOUND AT : 

ITERATION: %d OF VARIANT: %d\n", bestite, bestvariant); 
fprintf(ofp," TOTAL NUMBER OF BOXES : %d\n", tbn); 

fprintf(ofp," PACKED NUMBER OF BOXES : 

%d\n", bestpackednum); 

fprintf(ofp," TOTAL VOLUME OF ALL BOXES : %.0f\n", 

totalboxvol); 

fprintf(ofp," PALLET VOLUME : %.0f\n", 

totalvolume); 

fprintfiofp," BEST SOLUTION'S VOLUME UTILIZATION : 

%.0f OUT OF %.0f\n", bestvolume, totalvolume); 
fprintf(ofp," PERCENTAGE OF PALLET VOLUME USED : 

%.6f %%\n", percentageused); 

fprintf(ofp," PERCENTAGE OF PACKED BOXES (VOLUME) : %.6f %%\n", 

percentagepackedbox); 

fjprintf(ofp," WHILE PALLET ORIENTATION : 

X= %d; Y= %d; Z= %d\n", px, py, pz); 

fprintf(ofp,"- 

-\n"); 

fprintf(ofp," NO: PACKSTA DIMEN-1 DIMEN-2 DIMEN-3 COOR-X 

COOR-Y COOR-Z PACKEDX PACKEDY PACKEDZ\n"); 

fprintf(ofp,"--- 

-\n"); 

listcanditlayers(); 

Iayers[0].layereval=-1; 

qsort(layers,layerlistlen+l,sizeof(struct layerlist),complayerlist); 

packedvolume=0.0; 

packedy=0; 

packing=l; 


B-23 






layerthickness=layers[bestite].layerdim; 
remainpy=py; remainpz=pz; 
for (x=l; x<=tbn; x++) boxlist[x].packst=0; 
do { 

layerinlayerO; 

layerdone=0; 

packlayer(); 

packedy=packedy+layerthickness; 

remainpy=py-packedy; 

if (layerinlayer){ 

prepackedy=packedy; 

preremainpy=remainpy; 

remainpy=layerthickness-prelayer; 

packedy=packedy-layerthickness+prelayer; 

remainpz=lilz; 

layerthickness=layerinlayer; 

layerdone=0; 

packlayerO; 

packedy=prepackedy; 

remainpy=preremainpy; 

remainpz=pz; 

} 

if (!quit) findlayer(remainpy); 

} 

while (packing & !quit); 

fprintf(ofp,"\n\n *** LIST OF UNPACKED BOXES ***\n"); 

unpacked=l; 

for (cboxi=l; cboxi<=tbn; cboxi++) if (!boxlist[cboxi].packst) 

gr aphunpackedoutO; 

unpacked=0; 

fclose(ofp); 

fclose(gQ)); 

printf("\n">; 

for (n=l; n<=tbn; n++) 

if (boxlist[n].packst) printf("%d %d %d %d %d %d %d %d %d %d\n",n, 
boxlist[n].diml,boxlist[n].dim2,boxlist[n].dim3,boxlist[n].cox, 
boxlist[n] .coy,boxlist[n] .coz,boxlist[n] .packx,boxlist[n]. 

packy,boxlist[n] .packz); 

printf(" ELAPSED TIME : Almost %.0f sec\n", 

elapsedtime); 

printf(" TOTAL NUMBER OF ITERATIONS DONE : %d\n’\ itenum); 
printf(" BEST SOLUTION FOUND AT : 

ITERATION: %d OF VARIANT: %d\n", bestite, bestvariant); 
printf(" TOTAL NUMBER OF BOXES : %d\n", tbn); 

printf(" PACKED NUMBER OF BOXES : %d\n", 

bestpackednum); 


B-24 





printf(" TOTAL VOLUME OF ALL BOXES 


: %.0f\n", 

totalboxvol); 

printf(" PALLET VOLUME : %.0f\n", totalvolume); 

printf(" BEST SOLUTION'S VOLUME UTILIZATION : %.0f OUT OF 

%.0f\n", bestvolume, totalvolume); 

printf(" PERCENTAGE OF PALLET VOLUME USED : %.6f %%\n", 

percentageused); 

printf(" PERCENTAGE OF PACKED BOXES (VOLUME) : %.6f %%\n", 

percentagepackedbox); 

printf(" WHILE PALLET ORIENTATION : 

X= %d; Y= %d; Z= %d\n\n\n", px, py, pz); 
printf(" TO VISUALIZE THIS SOLUTION, PLEASE RUN 'VISUAL.EXEV'); 

} 


B-25 



Appendix C - The C Program Code of the Visualizer 


// INCLUDED HEADER FILES 

#include <stdio.h> 

#include <stdlib.h> 

#include <stdarg.h> 

#include <graphics.h> 


/* Function prototypes */ 


void Initialize(void); 
void Pack(void); 
void PutBox(void); 
void SayGoodbye(void); 
void Pause(void); 
void MainWindow(char *header); 
void StatusLine(char *msg); 
void DrawBorder(void); 

void changetextstyle(int font, int direction, int charsize); 
int gprintf(int *xloc, int *yloc, char *fint,...); 


// VARIABLE, CONSTANT AND STRUCTURE DECLARATIONS 


int GraphDriver; /* The Graphics device driver */ 

int GraphMode; /* The Graphics mode value */ 

double AspectRatio; /* Aspect ratio of a pixel on the screen*/ 

int MaxX, MaxY; /* The maximum resolution of the screen */ 

int MaxColors; /* The maximum # of colors available */ 

int ErrorCode; /* Reports any graphics errors */ 

struct palettetype palette; /* Used to read palette info */ 

struct dataarray {int cx, cy, cz, pax, pay, paz;} data[2000]; 
int px, py, pz, cox, coy, coz, packx, packy, packz, a, b, index, currenty, q; 
double max, sc; 

char strpx[8], stipy[8], strpz[8], oldstrcoy[8], strcox[8], strcoy[8], strcoz[8], strpackx[8], 
strpacky[8], strpackz[8]; 

FILE *igf; 



/* BEGIN MAIN FUNCTION */ 




int main() 

{ 

Initialize(); /* Set system into Graphics mode */ 

Pack(); 

SayGoodbye(); /* Give user the closing screen */ 

closegraph(); /* Return the system to text mode */ 

retum(0); 

} 


/4c4c4<****************** ********************************* *******/ 

/* INITIALIZE: INITIALIZES THE GRAPHICS SYSTEM AND */ 
/* REPORTS ANY ERRORS WHICH OCCURED. */ 

y4c4c 4:4:4:4c 4 : 4 c 4c 4c 4c 4 :4c4c4< ****** **************************** ***********/ 


void Initialize(void) 

{ 

int xasp, yasp; /* Used to read the aspect ratio*/ 

GraphDriver = DETECT; /* Request auto-detection */ 

initgraph( &GraphDriver, &GraphMode,""); 

ErrorCode = graphresult(); /* Read result of initialization*/ 

if( ErrorCode != grOk) { /* Error occured during init */ 

printf(" Graphics System Error: %s\n", grapherrormsg( ErrorCode )); 
exit( 1); 

} 

getpalette( &palette); /* Read the palette from board */ 

MaxColors = getmaxcolor() + 1; /* Read maximum number of colors*/ 

MaxX = getmaxx(); 

MaxY = getmaxyO; /* Read size of screen */ 

getaspectratio( &xasp, &yasp); /* read the hardware aspect */ 

AspectRatio = (double)xasp / (double)yasp; /* Get correction factor */ 

} 


C-2 




/* PACK: READS THE DATA FROM “VISUDAT” FILE AND ARRANGES */ 
/* BOXES TO PACK FROM FAR END TO THE CLOSE */ 


void Pack(void) 

{ 

struct viewporttype vp; 
char buffer[10]; 

MainWindow( "PACKING OF THE BEST SOLUTION FOUND" ); 
if ((igf=fopen("visudat","r"))=NULL) { 

outtextxy(0,0,"CANNOT OPEN FILE visudat"); 
exit(l); 

} 

fscanf(igf,"%s %s %s",strpx, strpy, strpz); 
px=atoi(strpx); py=atoi(strpy); pz=atoi(strpz); 
max=px; 

if (py>max) max=py; 
if (pz>max) max=pz; 
sc= 120/max; 
getviewsettings( &vp); 

settextjustify( CENTER_TEXT, TOP_TEXT ); 
changetextstyle( TRIPLEX_F ONT, HORIZ_DIR, 4); 
changetextstyle( DEF AULT_F ONT, HORIZJDIR, 1); 
setviewport( vp.left+50, vp.top+40, vp.right-50, vp.bottom-10,1); 
getviewsettings( &vp ); 

settextjustify( CENTER_TEXT, CENTER_TEXT); 
outtextxy( 20, 0, "PRESS 'Q' TO QUIT" ); 
setcolor(3); 

outtextxy( 220, 0, "PALLET ORIENTATION (X Y Z): " ); 

outtextxy( 350,0, stipx); 

outtextxy( 390, 0, strpy); 

outtextxy( 430,0, strpz); 

setfillstyle( EMPTY_FILL, 1); 

bar3d( 10,350-sc*2*py, 10+sc*2*px, 350, sc*pz, 1 ); 

outtextxy(460, 30, "COORDINATES:"); 

outtextxy(460,40, "CX: CY: CZ:"); 

outtextxy(460, 70, "DIMENSIONS:"); 

outtextxy(460,80, "DX: DY: DZ:"); 

index=l; 

fscanf (igf,"%s %s %s %s %s %s", strcox, strcoy, strcoz, strpackx, strpacky, strpackz); 
cox=atoi(strcox); coy=atoi(strcoy); coz=atoi(strcoz); 
packx=atoi(strpackx); packy=atoi(strpacky); packz=atoi(strpackz); 
data[index].cx=cox; data[index].cy=coy; data[index].cz=coz; 
data[index].pax=packx; data[index].pay=packy; data[index].paz=packz; 


C-3 




index++; currenty=data[index].cy; 

while (fscanf (igf,"%s %s %s %s %s %s", strcox, strcoy, strcoz, strpackx, strpacky, 

strpackz)! =EOF) { 

cox=atoi (strcox); coy=atoi(strcoy); coz=atoi(strcoz); 
packx=atoi(strpackx); packy=atoi(strpacky); packz=atoi(strpackz); 
data[index].cx=cox; data[index].cy=coy; data[index].cz=coz; 
data[index].pax=packx; data[index].pay=packy; data[index] .paz=packz; 


if (data[index].cy! =currenty) { 
b=index; index--; 

PutBoxQ; 

} 

index++; 
if (q=l) return; 

} 

index—; 

PutBox(); 

fclose(igf); 

PauseO; /* Pause for user's response */ 

} 

/********** puTBOX: DRAW BOXES IN THEIR LOCATIONS **********/ 


void PutBox(void) 
{ 


for (a=index; a>0; a—){ 

setcolor(O); ^ 

90, 

setcolor(r andom( 15)+1); 

itoa(data[a].pax, strpackx, 10); outtextxy(410, 90, strpackx); 
itoa(data[a].pay, strpacky, 10); outtextxy(460, 90, strpacky); 
itoa(data[a].paz, strpackz, 10); outtextxy(508, 90, strpackz); 
itoa(data[a].cx, strcox, 10); outtextxy(410,50, strcox); 
itoa(data[a].cy, strcoy, 10); outtextxy(460, 50, strcoy); 
itoa(data[a].cz, strcoz, 10); outtextxy(508, 50, strcoz); 
bar3d( 10+sc*2*data[a].cx+sc*data[a].cz, 

350-sc*2*data[a].cy-sc* .74*data[a] .cz-sc*2*data[a] .pay, 
10+sc*2*data[a].cx+sc*data[a].cz+sc*2*data[a].pax, 
350-sc*2*data[a].cy-sc*.74*data[a].cz, sc*data[a].paz, 1); 
if (toupper(getch())='Q'){ q=l; break;} 


); 

); 


} 

data [ 1 ]. cx=data[b]. cx; data[ 1 ]. cy=data[b] .cy; 
data[ 1 ]. cz=data[b]. cz; data[ 1 ] .pax=data[b] .pax; 
data[ 1 ] .pay=data[b] .pay; data[ 1 ] .paz=data[b] .paz; 


index=l; 


currenty=data[index] .cy; 

} 


C-4 




/* SAYGOODBYE: GIVE A CLOSING SCREEN */ 
/* TO THE USER BEFORE LEAVING. */ 


void SayGoodbye(void) 

{ 

struct viewporttype viewinfo; /* Structure to read viewport */ 
int h, w; 

MainWindow( "== The End =="); 

getviewsettings( &viewinfo); /* Read viewport settings */ 

changetextstyle( TRIPLEX_F ONT, HORIZ_DIR, 4); 
settextjustify( CENTER_TEXT, CENTER_TEXT ); 
h = viewinfo.bottom - viewinfo.top; 
w = viewinfo .right - viewinfo.left; 
outtextxy( w/2, h/2, "That's all, folks!"); 

StatusLine( "Press any key to EXIT"); 
getch(); 

cleardevice(); /* Clear the graphics screen */ 

} 


/* PAUSE: PAUSE UNTIL THE USER ENTERS A KEYSTROKE. */ 


void Pause(void) 

{ 

static char msg[] = "Esc aborts or press a key..."; 
int c; 

StatusLine( msg); 
c=getch(); 
if( 0 = c){ 

c = getchQ; 

} 

cleardevice(); 

} 


/* Put msg at bottom of screen */ 
/* Read a character from kbd */ 

/* Did use hit a non-ASCII key? */ 

/* Read scan code for keyboard */ 

/* Clear the screen */ 


C-5 




/* MAIN WINDOW: ESTABLISH THE MAIN WINDOW */ 


void MainWindow( char *header) 

{ 

int height; 

cleardeviceO; /* Clear graphics screen */ 

setcolor( MaxColors -1); /* Set current color to white */ 

setviewport( 0,0, MaxX, MaxY, 1); /* Open port to full screen */ 

height = textheight( "H"); /* Get basic text height */ 

changetextstyle( DEFAULT_FONT, HORIZ.DIR, 1); 

settextjustify( CENTER_TEXT, TOP_TEXT); 

outtextxy( MaxX/2,2, header); 

setviewport( 0, height+4, MaxX, MaxY-(height+4), 1); 

DrawBorderO; 

setviewport( 1, height+5, MaxX-1, MaxY-(height+5), 1); 

} 


/* STATUSLINE: DISPLAY A STATUS LINE */ 
/* AT THE BOTTOM OF THE SCREEN. */ 


void StatusLine( char *msg ) 

{ 

int height; 

setviewport( 0,0, MaxX, MaxY, 1); /* Open port to full screen */ 

setcolor( MaxColors -1); /* Set current color to white */ 

changetextstylef DEF AULT_F ONT, HORIZ_DIR, 1); 
settextjustifyf CENTER_TEXT, TOP_TEXT ); 
setlinestylef SOLID_LINE, 0, NORM_WIDTH ); 
setfillstylef EMPTY_FILL, 0); 

height = textheight( "H"); /* Detemine current height */ 

bar( 0, MaxY-(height+4), MaxX, MaxY); 

rectanglef 0, MaxY-(height+4), MaxX, MaxY ); 

outtextxy( MaxX/2, MaxY-(height+2), msg); 

setviewport( 1, height+5, MaxX-1, MaxY-(height+5), 1 ); 

} 


C-6 


/* DRAWBORDER: DRAW A SOLID SINGLE LINE */ 
/* AROUND THE CURRENT VIEWPORT. */ 




void DrawBorder(void) 

{ 

struct viewporttype vp; 

setcolor( MaxColors -1); /* Set current color to white */ 

setlinestyle( SOLID_LINE, 0, NORM_WIDTH); 
getviewsettings( &vp); 

rectangle( 0,0, vp.right-vp.left, vp.bottom-vp.top); 

} 


/**********************************************************************/ 
/* CHANGETEXTSTYLE: SIMILAR TO SETTEXTSTYLE, BUT CHECKS FOR */ 
/* ERRORS THAT MIGHT OCCUR WHIL LOADING THE FONT FILE. */ 

y********************************************^*************************/ 


void changetextstyle(int font, int direction, int charsize) 

{ 

int ErrorCode; 

graphresult(); /* clear error code */ 

settextstyle(font, direction, charsize); 

ErrorCode = graphresult(); /* check result */ 

if( ErrorCode != grOk ) { /* if error occured */ 

closegraph(); 

printf(" Graphics System Error: %s\n", grapherrormsg( ErrorCode )); 
exit( 1); 

} 

} 


C-7 


/* *:!:** *** **** ******* ************************************* *************/ 
/* GPRINTF: USED LIKE PRINTF EXCEPT THE OUTPUT IS SENT TO THE */ 


/* SCREEN IN GRAPHICS MODE AT THE SPECIFIED CO-ORDINATE. */ 


y*********************************************************************/ 


int gprintf( int *xloc, int *yloc, char *fint,...) 

{ “ 

va_list argptr; /* Argument list pointer */ 

char str[ 140]; /* Buffer to build sting into */ 

int cnt; /* Result of SPRINTF for return */ 

va_start( argptr, format); /* Initialize va_ functions */ 

cnt = vsprintf( str, fmt, argptr); /* prints string to buffer */ 

outtextxy( *xloc, *yloc, str); /* Send string in graphics mode */ 

*yloc += textheight( "H") + 2; /* Advance to next line */ 

va_end( argptr); /* Close va_ functions */ 

retum( cnt); /* Return the conversion count */ 

} 


C-8 


Appendix D - The Test Problems That We Generated 

Randomly Generated Sets: 



_ SET #4 

104,96,84 

I. 1,2, 3,200 
2. 2, 4, 5, 200 

3.6, 7,1,200 

4. 6, 8, 2, 29 

5. 11,2, 3, 29 

6. 9, 4, 2, 29 

7. 14, 5, 3, 30 

8. 10, 4, 6, 30 

9. 11,8,3,30 

10. 1,2,19, 50 

II. 8,13,11,50 

12. 1,3,21,10 

13. 8, 9, 10, 30 

14. 7,13,31,115 

15. 12, 66,3,30 

16. 4,15,19, 90 

17. 5,16, 9,100 

18. 10, 2, 5, 100 

19. 10,10,1,90 

20. 9,18,15, 50 

21.6, 9, 14,1 


4 . 10 , 11 , 12,1 

5 . 13 , 14 , 15 , 1 

6 . 16 , 17 , 18 , 1 

7 . 19 , 20 , 21,1 

8 . 22 , 23 , 24,1 

9 . 25 , 26 , 27,1 

10 . 28 , 29 , 30 , 1 

11 . 31 . 32 . 33.1 
12 . 34 , 35 , 36 , 1 
13 . 37 , 38 , 39 , 1 
14 . 40 , 41 , 42 , 1 

15 . 43 . 44 . 45.1 

16 . 46 . 47 . 48.1 

17 . 2 , 3 , 4 , 1 

18 . 5 , 6 , 7,1 

19 . 8 , 9 , 10,1 

20 . 11 . 12 . 13.1 

21 . 14 , 15 , 16 , 1 

22 . 17 , 18 , 19 , 1 

23 . 20 , 21 , 22 , 1 

24 . 23 , 24 , 25 , 1 
25.26 27 28 1 

26 . 29 30 31 1 

27 . 32 33 34 1 

28 . 35 36 37 1 

29 . 38 39 40 1 
30.41 42 43 1 
31.44 45 46 1 


D-l 











Sets Generated by Dividing Into: 


Distributor’s Pallet Packing Problem Samples: 


SET #6 

SET #7 

SET #8 

104, 96, 84 

1. 70,104, 24, 4 

2. 14, 104, 48, 2 

104,96, 84 

1. 70, 50, 24,4 

2. 70, 54,24,4 

3.14,104,48,2 

104, 96, 84 

1.70, 45, 24,4 

2. 70, 59,24,4 

3.14,40,48,2 

4.14, 64,48,2 


SET #9 

SET #10 

SET #11 

104, 96, 84 

1.70, 45, 24,4 

2. 70, 30, 24,4 

3. 70, 29, 24,4 

4.14,40, 48,2 

5.14, 32, 48,2 

6.14, 32, 48,2 

104, 96, 84 

1.28, 32,18,9 

2. 24, 21, 35,16 

3. 19, 26, 20,4 

4. 19, 26,16,16 

5. 16, 26,20,4 

6. 20, 20, 26,1 

7. 16,14, 25, 36 

104, 96, 84 

I. 19, 20,42,2 

2.25,20, 30,1 

3. 25,20,25,1 

4. 25, 20, 29,1 

5.8, 20,21,4 

6. 36,46, 84,1 

7.16, 46,10,2 

8. 16, 46, 32,2 

9. 20, 30,15,1 

10. 20, 30, 69,1 

II. 20, 30, 21,4 

12.12, 30, 7,12 

13. 52, 60, 42, 2 

14. 26, 36,21,4 

15.26,36, 84,1 


Manufacturer’s Pallet Packing Problem Samples: 


SET #12 

SET #13 

SET #14 

104 96 84 

1.14,13,8,576 

104 96 84 

1. 14,13,4,1152 

104 96 84 

1.4,6,7,4992 


SET #15 

SET #16 

104 96 84 

104 96 84 

1.14,13,2, 576 

1.4,6, 7,2496 

2.21,13,4, 576 

2.14,13,8,288 


D-2 

























Appendix E - Solutions of B/R Test Sets 

BOX SET BR #1: 3 DIFFERENT BOX TYPES 





E-l 























































































































































































SET# 


39 


40 


41 


42 


43 


TOTAL 

NUMBER 

BOXES 


243 


107 


109 


168 


141 
















PACKED 
NUMBER OF 
BOXES 


229 


98 


91 


152 


135 


























% PALLET 
VOLUME 
UTILIZATION 


% PACKED 
VOLUME OF 
ALL BOXES 


6 


86.98 


89.66 


82.80 


87.26 


86.17 






86.06 


92.24 


SOLUTION 

TIME 

(SECOND) 


2 


0 


0 



86.87 

1 

79.08 

0 

88.45 

1 

94.39 

12 

89.82 

0 

87.31 

3 

89.73 

3 

83.57 

1 

87.77 

1 

86.46 

0 

86.51 

0 

90.49 

0 

86.66 

0 

92.46 

1 














































































































































































































BOX SET BR #2: 5 DIFFERENT BOX TYPES 



E-3 













































































































































































152 

136 

90.23 

9 


169 

156 

90.79 

91.54 

114 

89 

85.75 

8 

6.07 


156 _145_ 85.95 _ 86.08 _2 

196 _191_ 92.23 _ 92.70 _1 

142 _126_ 88.42 _ 88.47 _1 

142 125 89.49 89.72_2 


116 

110 

90.31 

92.01 

1 

156 

139 

89.23 

89.47 

2 

147 

139 

93.98 

94.47 

2 




95 


88 

116 

107 

266 

246 

96 

78 

98 

94 

158 

133 

102 

91 

129 

114 

161 

139 

101 

89 

160 

149 

139 

117 

94 

85 | 

155 

146 

152 

139 

101 

83 

141 

129 

141 

120 

117 

101 

181 

172 

159 

136 

114 

110 

201 

184 

113 

99 

83 

65 


88.88 _ 88.92 _1 

89.16 90.24 _1 


87.70 

88.14 

1 

93.82 

93.91 

5 

87.80 

88.81 

0 

91.71 

93.54 

1 

89.75 

89.77 

1 

89.70 

90.22 

0 

87.22 

87.81 

1 

90.19 

90.99 

2 

91.78 

92.39 

0 

90.41 

90.56 

1 

88.35 

88.85 

1 

88.87 

89.88 

1 


89.90 

2 

91.39 

92.08 

1 

88.92 

89.00 

0 

89.67 

89.69 

1 

89.39 

89.49 

1 

85.17 

85.72 

1 

92.70 

92.72 

2 

89.44 

89.92 

1 

91.51 

92.38 

1 

91.85 

92.25 

3 

88.86 

89.23 

1 

84.98 

85.64 

0 


E- 

























































































































































































































SET# 


62 


63 


64 


TOTAL 

NUMBER 

BOXES 


109 



PACKED 
NUMBER OF 
BOXES 

% PALLET 
VOLUME 
UTILIZATION 

92 

88.49 

110 

90.01 

112 

85.88 

174 

88.35 

115 

91.15 

160 

87.95 

117 

87.16 

135 


108 

87.45 

111 

87.24 

67 

88.03 

117 

88.12 



% PACKED 
VOLUME OF 
ALL BOXES 


88.58 


91.26 


86.54 


89.49 


92.40 


8 


8 


8 


8 


87.79 


88.05 


88.36 



159 

89.49 

131 

89.15 


























































































































































































BOX SET BR #3: 8 DIFFERENT BOX TYPES 


TOTAL 

NUMBER 

BOXES 

94 

115 

143 

185 

113 

143 

144 
104 
133 
180 

119 

103 
199 

104 
103 
128 
86 

85 
176 
135 
94 
111 

130 
112 

135 
161 

120 
143 
194 
161 

136 
141 

131 
164 
149 
111 
112 
103 
232 

86 
124 


PACKED 
NUMBER OF 
BOXES 

86 

105 

117 
159 

93 
125 
128 
85 

118 
161 
103 
90 
187 

94 
85 
117 
80 
78 
157 
107 
80 
101 
121 
96 
111 
146 
105 
122 
173 
144 
119 
127 
121 
149 
136 
101 
100 
94 
217 
73 
107 


% PALLET 
VOLUME 
UTILIZATION 

88.59 

88.00 

86.78 

86.67 
88.61 
87.48 

86.56 

88.68 

87.65 
87.06 
90.61 

85.21 
88.84 

90.78 

87.56 
89.03 
84.51 
88.03 

89.38 

90.69 

88.66 

88.76 

87.39 

88.69 
88.59 

88.81 

87.34 
86.01 
88.18 

88.67 
87.63 
88.44 
90.08 
89.20 

90.22 
86.99 

89.79 

86.67 
89.72 

86.56 
90.25 


% PACKED 
VOLUME OF 
ALL BOXES 

88.88 

88.19 

86.80 

87.02 

88.76 

87.86 

86.88 

89.96 
87.74 

87.97 

91.14 

85.54 
89.25 

90.90 

87.82 

89.70 
85.09 

88.83 

89.67 
91.04 

88.87 

88.88 
88.31 
89.10 
89.16 
89.10 
87.36 

86.34 
88.51 
88.73 

88.15 
89.18 

90.34 

89.91 

90.55 
87.43 
90.38 

87.30 

90.30 

87.31 
91.27 


SOLUTION 

TIME 

(SECOND) 

1 

1 

3 

4 
1 
2 
2 
1 
2 

5 
2 
1 
4 
1 
1 
1 
0 
0 
2 
2 
1 
1 
1 
1 
2 
2 
1 
2 
3 
1 

3 
2 
2 

4 
2 
1 
1 
1 

5 
0 
1 


E-6 





































































































































































































TOTAL 

NUMBER 

BOXES 

131 

92 

142 

147 
110 

148 
103 
105 
136 
165 

143 
100 
178 

154 
212 
118 
87 
216 
114 
90 
114 
124 
134 
140 
97 
169 
119 
162 
108 
131 

138 
105 
114 

139 

144 
201 

155 
195 
114 
80 
174 

140 
101 


PACKED 
NUMBER OF 
BOXES 


117 


82 


117 


129 


97 


133 


95 


96 


115 


143 


128 


85 


169 


143 


196 


107 


80 


194 


92 


76 


103 


113 


123 


130 


89 


148 


103 


144 


100 


117 


125 


94 


104 


130 


127 


182 


140 


179 


97 


73 


160 


122 


% PALLET 
VOLUME 
UTILIZATION 

89.80 
86.83 

85.65 
89.50 

89.25 
86.55 

87.96 

88.90 
88.98 
91.06 

89.68 

87.80 

90.70 

86.68 

89.38 

87.80 
88.21 
87.33 
87.23 
88.61 
85.16 

89.15 
87.09 
89.48 

87.66 

87.96 
89.59 
90.42 

87.71 
86.76 
89.54 
85.35 

88.71 
87.46 

88.92 
91.70 

88.81 
90.86 
88.63 

88.92 

87.92 

90.25 
92.14 


% PACKED 
VOLUME OF 
ALL BOXES 
90.77 
88.02 
85.98 
90.35 
89.49 

86.96 
88.95 

89.39 
89.09 

91.44 

90.18 
88.21 

91.14 
86.79 

90.29 
87.87 
88.66 
87.43 

87.66 

89.15 
85.34 
90.31 
87.11 

90.37 

88.19 
88.09 
90.86 

90.92 

87.91 

86.92 
90.17 

85.71 

89.15 

88.40 

89.97 
91.74 
89.00 
90.94 

89.30 

89.38 

88.45 

90.41 
92.48 


1 


0 


1 


95 





































































































































































































































BOX SET BR #4: 10 DIFFERENT BOX TYPES 


TOTAL 

NUMBER 

BOXES 


106 


% PALLET 
VOLUME 
UTILIZATION 


8 



PACKED 
NUMBER OF 
BOXES 


94 


109 


118 


145 


118 


112 


116 


94 


133 


114 


114 


101 


150 


98 


86 


116 


83 











































































































































































































TOTAL 

NUMBER 

BOXES 

PACKED 
NUMBER OF 
BOXES 

% PALLET 
VOLUME 
UTILIZATION 

% PACKED 
VOLUME OF 
ALL BOXES 

111 

104 

89.10 

89.26 

98 

72 

87.22 

89.55 

137 

116 

85.11 

85.15 

133 

122 

88.07 

88.45 



143 89.00 I 89.09 


111 87.45 88.51 


161 86.72 I 86.83 


113 86.62 I 86.85 


132 88.26 I 88.40 


129 88.62 88.70 


139 1 87.20 I 87.72 


105 89.26 1 89.46 


124 89.80 90.16 


89.26 I 89.72 


89.60 89.73 


122 88.94 | 90.01 


115 

98 

86.25 

86.56 

225 

208 

90.11 

90.17 

102 

82 

84.38 

84.58 

113 

89 

89.49 

89.75 

121 

100 

87.62 

87.78 

90 

68 

86.23 

86.52 

138 

114 

85.87 

86.05 

158 

141 

88.62 

88.63 

98 

87 

89.88 

90.00 

138 

122 

86.40 

86.81 

109 

96 


89.19 

106 

91 

89.00 

90.43 

167 

152 

88.95 

89.55 

184 

166 

91.87 

92.23 

143 

124 

89.23 

89.39 

101 

78 

87.20 

87.71 

172 

155 

90.02 

90.41 

143 

125 

85.69 

85.92 


233 

213 

91.04 

92.02 

96 

85 

87.53 

88.23 

106 

95 

90.05 

90.37 

199 

168 

88.85 

88.87 

125 

113 

87.15 

87.36 

121 

105 

89.14 

89.76 

125 

118 

88.22 

88.67 

100 

82 

90.46 

90.56 

118 

106 

86.36 

86.97 


























































































































































































































SET# 


65 


66 


67 


68 


69 


70 




72 


TOTAL 

NUMBER 

BOXES 


156 


105 


170 


103 


157 


117 




129 




91 


148 




179 




217 


132 












PACKED 
NUMBER OF 
BOXES 


148 


92 


154 


87 


146 


104 




114 




72 


125 




150 




198 


121 




















% PALLET 
VOLUME 
UTILIZATION 


90.52 


% PACKED 
VOLUME OF 
ALL BOXES 


90.59 


87.08 




85.49 




89.69 


88.99 


90.06 


88.82 

2 

87.78 

2 

90.27 

2 

89.52 

2 

90.88 

3 



E-10 



























































































































































































BOX SET BR #5: 12 DIFFERENT BOX TYPES 


TOTAL 

NUMBER 

BOXES 

PACKED 
NUMBER OF 
BOXES 

% PALLET 
VOLUME 
UTILIZATION 

% PACKED 
VOLUME OF 
ALL BOXES 

98 

84 

88.24 

89.41 

138 

131 

86.82 

88.05 

133 

118 

87.59 

87.65 

142 

130 

86.52 

86.55 

129 

118 

88.68 

89.39 

140 

125 

87.51 

87.99 

132 

117 

87.83 

88.14 

98 

91 

88.84 


135 

121 

86.74 

87.13 

133 

113 

87.19 

87.34 

144 

131 

89.53 

89.57 


92 

86.16 

86.43 

199 

179 

88.15 

88.70 

123 

115 

87.74 

88.76 

104 

92 

84.67 

86.17 

118 

106 

85.31 

86.05 

108 

100 

88.87 

89.37 

87 

76 

88.20 

88.48 

142 

132 

88.26 

89.24 

138 

124 

88.24 

89.21 

128 

120 


89.54 

116 

94 

87.69 

87.71 

143 

124 

87.91 

89.25 

111 

97 

86.37 

86.86 

143 

123 

85.88 

86.59 

161 

147 

89.79 

89.82 

120 

110 

86.39 

87.09 

180 

161 

87.44 

87.59 

120 

104 

87.51 

89.61 

135 

120 

88.29 

89.42 

147 

127 

88.07 

88.51 

163 

150 

87.62 

87.75 

141 

133 

88.52 

88.79 

115 

99 

88.19 

88.48 

143 

130 

88.71 

89.12 

124 

113 

87.72 

87.95 

122 

109 

89.90 

91.01 

118 

108 

84.80 

85.72 

196 

174 


88.86 

106 

93 

85.87 

86.14 

133 

114 

87.70 

88.07 









































































































































































































SET# 


42 


43 


44 


45 


46 


47 


48 


49 


50 


51 


52 


53 


TOTAL 

NUMBER 

BOXES 


113 


113 


136 


171 


99 


146 


111 


104 



PACKED 
NUMBER OF 
BOXES 


94 


102 


118 


153 


89 


125 


99 


95 


152 


170 


117 


110 


158 



% PALLET 
VOLUME 
UTILIZATION 


87.78 


86.79 


86.25 


88.85 


88.48 


86.38 


87.63 


86.22 


88.22 


88.94 


88.77 


86.03 


89.79 


86.31 


88.14 


86.52 


88.76 


88.70 


85.43 


88.86 


87.01 


8 


89.24 


84.66 


86.74 


89.19 


86.42 


87.31 


84.26 


87.26 


88.34 


89.66 


88.69 


8 


87.80 


89.18 


88.83 


% PACKED 
VOLUME OF 
ALL BOXES 


88.33 


8 


8 


89.53 


89.18 


86.74 


88.08 


87.13 


88.39 


89.12 


89.07 


86.66 


89.87 


86.53 


88.15 


87.14 


90.05 


89.05 


85.90 


90.31 


88.47 


8 


9 


8 


85.57 


87.12 


90.40 


86.69 


87.79 


84.36 


87.34 


86.06 


87.50 


89.72 


90.05 


89.43 


88.27 


88.88 


86.42 


87.18 


88.20 


89.54 


89.51 


E-12 























































































































































































































BOX SET BR #6: 15 DIFFERENT BOX TYPES 



E-13 










































































































































SET# 


21 


TOTAL 

NUMBER 

BOXES 


129 












PACKED 
NUMBER OF 
BOXES 


114 














% PALLET 
VOLUME 


% PACKED 
VOLUME OF 


UTILIZATION ALL BOXES 




E-14 



















































































































































































SET# 


TOTAL 

NUMBER 

BOXES 


PACKED 
NUMBER OF 
BOXES 


















% PALLET 
VOLUME 
UTILIZATION 










% PACKED 
VOLUME OF 
ALL BOXES 














E-15 













































































































































































BOX SET BR #7: 20 DIFFERENT BOX TYPES 


TOTAL 

NUMBER 

BOXES 

110 

129 

126 

153 

126 

156 
109 
119 

129 
135 

143 
146 
172 

119 

117 

118 
125 
103 
135 

130 
133 
130 

157 

105 
130 
151 
121 

144 
117 
143 
161 
149 
142 

106 
162 
133 
99 

120 
167 
119 


PACKED 
NUMBER OF 
BOXES 

97 
117 
109 

138 
116 
135 

94 

105 
116 

119 
126 

133 
158 
111 

106 
106 
113 
91 
121 
116 
126 
124 
135 

95 
113 

134 
116 
134 
105 
127 
144 
133 

120 

98 

139 
123 
88 
107 
143 
109 


% PALLET 
VOLUME 
UTILIZATION 

86.13 
86.10 

86.89 

86.72 
86.61 
88.36 

86.73 
87.69 
86.25 

87.14 
87.95 

86.73 
87.75 

88.19 

85.50 

88.16 

85.88 
87.04 

88.20 

88.98 
88.33 
87.39 
86.07 
87.27 
85.04 
86.04 

87.88 

88.24 

85.90 

86.88 

87.02 

88.14 
89.04 

86.51 
88.05 
87.09 

87.51 
86.42 
87.35 

86.98 


% PACKED 
VOLUME OF 
ALL BOXES 

88.00 

87.42 

87.06 

86.72 
86.93 

88.65 
86.97 

87.81 

86.82 
87.27 

88.21 
86.80 
88.64 

88.41 

85.52 

88.31 
87.09 
87.26 
89.36 

89.32 
89.50 
87.69 
86.63 

87.66 
85.71 
86.13 

88.24 

89.17 

86.24 
87.09 

87.22 

88.53 

89.41 

87.32 
88.10 
88.12 
88.31 

86.73 

88.00 

87.18 


SOLUTION 

TIME 

(SECOND) 

3 

4 

5 
5 
4 
7 

3 

4 

4 

5 

5 

6 
9 

3 

4 

3 

4 

3 

5 

4 

5 
4 

7 
2 

4 

6 
3 

5 
3 

6 

8 

7 

5 
3 

6 
5 

3 

4 

8 
3 


E-16 




































































































































































































SET# 


41 


42 


43 


44 


45 


46 


47 


48 


49 


5 


51 


52 


53 


TOTAL 

NUMBER 

BOXES 




PACKED 
NUMBER OF 
BOXES 


108 




135 


144 


% PALLET 
VOLUME 
UTILIZATION 


87.78 


87.02 


87.70 


87.02 


85.80 


87.18 


86.97 


88.02 


87.56 


89.17 



108 

89 

168 

160 

117 

109 

162 

149 

105 

95 

155 

134 

111 

97 

127 

111 



86.83 


85.34 


86.20 


86.75 


85.21 


87.87 


% PACKED 
VOLUME OF 
ALL BOXES 


88.84 


88.00 


89.18 


87.92 


86.79 


88.15 


87.60 


89.18 


88.09 


89.70 


88.25 


86.88 


86.78 


89.25 


88.68 


88.30 


86.48 


91.65 


86.71 


86.56 


88.36 


87.08 


88.18 


88.59 


90.20 


85.05 


86.91 


5 


85.38 


87.93 


86.20 


85.14 


88.29 


89.12 


87.44 


87.30 


86.22 


86.50 


86.82 


85.65 


88.51 



E-17 












































































































































































SET# 

TOTAL 

NUMBER 

BOXES 

PACKED 
NUMBER OF 
BOXES 

% PALLET 
VOLUME 
UTILIZATION 

% PACKED 
VOLUME OF 
ALL BOXES 

WmssmM 

83 

139 

118 

86.73 

87.15 

5 

84 

154 

136 

88.10 

88.72 

6 

85 

108 

99 

86.11 

87.93 

3 

86 

134 

109 

88.50 

90.17 

4 

87 

117 

105 

86.14 


3 

88 

142 

119 

86.52 

87.81 

5 

89 

105 

94 

88.66 

88.74 

3 

90 

97 

86 

88.11 

88.35 

3 

91 

106 

93 

85.27 

86.05 

2 

92 

118 

109 

89.09 

89.19 

4 

93 

90 

75 

84.49 

84.78 

3 

94 

134 

125 

87.13 

87.52 

4 

95 

146 

124 

86.52 

87.20 

6 

96 

151 

135 

87.68 

87.96 

6 

97 

124 

111 

86.25 

87.10 

4 

98 

144 

127 

88.50 

88.58 

6 

99 

145 

132 

86.52 

87.25 

6 

100 

122 

107 

86.53 

86.79 

4 


E-18 




















































































Bibliography 


Askin, Ronald G., and Charles R. Standridge. Modeling and Analysis of Manufacturing 
Systems . New York: John Wiley and Sons, Inc., 1993, (320-321). 

Ballew, P. Brian. The Distributor’s Three-Dimensional Pallet-Packing Problem: A 
Mathematical Formulation and Heuristic Solution Approach . MS Thesis, 
AFIT/GOR/ENS/00M-02. Graduate School of Engineering, Air Force Institute 
of Technology (AU), Wright Patterson AFB OH, March 2000. 

Barr, R. S., Golden, B. L., Kelly, J. P., Resende, M. G. C., and Stewart, W. R., Jr. Journal 
of Heuristics. 1995,1:9-32. 

Bischoff, E., and Dowsland, W. B., An application of the micro to product design and 

distribution. Journal of the Operational Research Society. 1982, 33 (3), 271-281. 

Bischoff, E. E., and Marriott, M. D., A comparative evaluation of heuristics for Container 
loading. European Journal of Operational Research. 1990,44 (2), 267-276. 

Bischoff, E. E., and Ratcliff, M. S. W. Issues in the development of approaches to 
container loading. OMEGA. 1995.23(41:377-390. 

Bischoff, E. E., F. Janetz, and M. S. W. Ratcliff. “Loading pallets with non-identical 
Items,” European Journal of Operational Research 84 : 681-692 (1995). 

Bortfeld, A., and Gehring, H. Ein tabu search-Verfahren mit schwach heterogenem 
Kistenvorrat. FB Wirtschaftswissenschaft. Fem Universitat Hagen. 1997, 
Technical Report 240. 

Chocolaad, Christopher A. Solving Geometric Knapsack Problems Using Tabu Search 
Heuristics . MS Thesis, AFIT/GOR/ENS/98M-05. Graduate School of 
Engineering, Air Force Institute of Technology (AU), Wright Patterson AFB OH, 
March 1998. 

CAPE Systems, Inc., CAPE PACK'99 and Truckfill packaging design and pallet loading 
softwares, http://www.canesvstems.com . 24 November 2000. 

Chen, C.S., Lee, S. M., Shen, Q. S., An analytical model for container loading problem. 
European Journal of Operational Research 80,1995, 68-76. 

Coffman, E. G. JR., and Shor, P. W. Average-case analysis of cutting and packing 

in two-dimensions. European Journal of Operational Research. 1990,44 (2), 134- 
145. 


BIB-1 





Computer Sciences Corporation. Unit Type Code Development, tailoring, and 

Optimization (UTC-DTO) Phase 2 Final Report . Contract DC A 100-94-D-00144. 
Falls Church VA: Defense Enterprise Integration Services, December 1997. 

Faina, L., A global optimization algorithm for the three-dimensional packing problem. 
European Journal of Operational Research 126, 2000, 340-354. 

Gehring, H., Menschner, K., and Meyer, M., A computer-based heuristic for packing 

pooled shipment containers. European Journal of Operational Research. 1990,44 
(2), 277-289. 

Gehring, H., and Bortfeld, A. Ein genetischer Algorithmus fur das Containerbe- 

Ladungsproblem. FB Wirtschaftswissenschaft. Fem Universitat Hagen. 1996, 
Technical Report 227. 

George, J. A., and Robinson, D. F., A heuristic for packing boxes into a container. 
Computers and Operational Research. 1980, 7,147-156. 

Glover, F., Future Paths for Integer Programming and Links to Artificial Intelligence, 
Computer and Operations Research. 1986, Vol. 13,533-549 (9-21) 

Glover, F., Laguna, M., Tabu Search . USA: Kluwer Academic Publishers, 1997. 

Haessler, R. W., and Talbot, F. B., Load planning for shipments of low density products. 
European Journal of Operational Research. 1990, 44 (2), 289-299. 

Han, C. P., Knott, K., and Egbelu, P. J., A heuristic approach to the three-dimensional 
cargo-loading problem. International Journal of Production Research. 1989,27 
(5), 757-774. 

Imperial College Management School. 2001, 

http://mscmga.ms.ic.ac.uk/ieb/orlib/thpackinfo.html . 13 January 2001 

Liu, N. C., and Chen, L. C., A new algorithm for container loading. Compsac 81-5 th 

International Computer Software and Applications Conference Papers (Chicago: 
IEEEh 1981,292-299. 

Loh, H. T., and Nee, A. Y. C. A packing algorithm for hexahedral boxes . In Proceedings 
of the Industrial Automation '_92 Conference. Singapore. 1992, pages 115-126. 

Manship, Wesley E., and Jennifer L. Tilley. A Three-Dimensional 364L Pallet Packing 
Model and Algorithm . MS Thesis, AFIT/GIM/LAL/98S-3. School of Systems 
and Logistics, Air Force Institute of Technology (AU), Wright Patterson AFB 
OH, September 1998. 


BIB-2 





Magic Logic Optimization, Inc., Cube-IQ Load Optimization Software. 
http://www.magiclogic.com/cube-iq.html 6 June 2000. 


Martello Silvano, Pisinger, David, and Vigo, Daniele. The Three-Dimensional Bin 

Packing Problem. Operations Research. 2000 Informs . Vol. 48, No. 2, March- 
April 2000, pp. 256-267. 

Mohanty, B. B., Mathur, K., Ivancic, N. J., Value considerations in three-dimensional 

packing - A heuristic procedure using the fractional knapsack problem. European 
Journal of Operational Research 74.1994,143-151. 

Ngoi, B. K. A., Tay, M. L., and Chua, E. S. Applying spatial representation techniques to 
the container packing proble m. Int. J. Prod. Res. 1994,32:111-123. 

Ravindran, A., Phillips, Don T., Solberg, James J., O perations Research Principles and 
Practice. Second Edition . U.S.A.: John Wiley & Sons, Inc., 1986. 

Reeves, Colin R. Modem Heuristic Techniques for Combinatorial Problems . London: 
McGraw-Hill Book Company, 1995,151-188. 

Romaine, Jonathan M. Solving the Multidimensional Multiple Knapsack Problem with 
Packing Constraints Using Tabu Search . MS thesis, AFIT/GOR/ENS/99M-15. 
Graduate School of Engineering, Air Force Institute of Technology (AU), Wright- 
Patterson AFB OH, March 1999. 

Steudel, H. J., Generating pallet loading patterns: a special case of the two-dimensional 
Cutting stock problem. Management Science. 1979, 25 (10), 997-1004. 

TASC, Inc. (8 May 1998) Interim Project Report on the Feasibility of Finding Optimal 

Solutions to Three-Dimensional Packing Problems . Contract number F41624-97- 
D-5002, Air Force Research Labs/HESR, Wright-Patterson AFB OH. 

Taylor, Gregory S. A Pallet Packing Postprocessor for the Logistics Composite Model . 
MS thesis, AFIT/GST/ENS/94M-11. Graduate School of Engineering, Air Force 
Institute of Technology (AU), Wright-Patterson AFB OH, March 1994. 

Temo, J., Scheithauer, G., SommerweiB, U., and Riehme, J. An Efficient Approach for 
the Multi-Pallet Loading Problem. Institute for Numerical Mathematics, 
Technical University Dresden Mommsenstr. 13. D-01062 Dresden, Germany 
1997. 

Tinarelli, G. U., and Addonizio, M., Un problema di caricamento di containers, 

Proc. AIRO. Rome. Italy 1978. 


BIB-3 





> 


Vita 

lLt. Erhan BALTACKXjLU was bom in Ankara, Turkey. He grew up in Istanbul 
and eventually graduated from Kuleli Military High School. He then attended the Turkish 
Air Force Academy in Istanbul. On 30, August 1994 he received his commission as well 
as his Bachelor’s of Science degree in Computer Science. On 25, May 1996 he graduated 
from Turkish Flight School in Izmir. He was assigned to be a C-13Q pilot in Kayseri. In 
August of 1999, he was assigned by the Turkish Air Force to the Air Force Institude of 
Technology in pursuit of a Master’s degree in Operations Research. 


V4 



Form Approved 
OMBNo. 074-0188 


REPORT DOCUMENTATION PAGE 


The public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing instructions, searching existing data sources, gathering and 
maintaining the data needed, and completing and reviewing the collection of information. Send comments regarding this burden estimate or any other aspect of the collection of information, including 
suggestions for reducing this burden to Department of Defense, Washington Headquarters Services, Directorate for Information Operations and Reports (0704-0188), 1215 Jefferson Davis Highway, 
Suite 1204, Arlington, VA 22202-4302. Respondents should be aware that notwithstanding any other provision of law, no person shall be subject to an penalty for failing to comply with a collection of 
information if it does not display a currently valid OMB control number. 

PLEASE DO NOT RETURN YOUR FORM TO THE ABOVE ADDRESS. _ _ 


1. REPORT DATE (DD-MM-YYYY) 2. REPORT TYPE 

20-03-2001 Master’s Thesis 


4. TITLE AND SUBTITLE 

THE DISTRIBUTER’S THREE-DIMENSINAL PALLET-PACKING 
PROBLEM: A HUMAN INTELLIGENGE-BASED HEURISTIC 
APPROACH 


3. DATES COVERED (From - To) 

March 2001 - March 2001 


5a. CONTRACT NUMBER 


5b. GRANT NUMBER 


5c. PROGRAM ELEMENT NUMBER 


6. AUTHOR(S) 


Erhan BALTACIOGLU, First Lieutenant, TUAF 


5d. PROJECT NUMBER 

HE-AFIT-99-10 


5e. TASK NUMBER 

ZA 


5f. WORK UNIT NUMBER 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 


AFIT/GOR/EN S/01M-02 


10. SPONSOR/MONITOR’S ACRONYM(S) 

DAGSI 


11. SPONSOR/MONITOR’S REPORT 
NUMBER(S) 


7. PERFORMING ORGANIZATION NAMES(S) AND ADDRESS(S) 

Air Force Institute of Technology 

Graduate School of Engineering and Management (AFIT/EN) 
2950 P Street, Building 640 
WPAFB OH 45433-7765 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Dayton Area Graduate Studies Institute 

Attn: Dr. Frank Moore 

3155 Research Blvd, Suite 205 

Kettering, OH 45420 (937) 781-4000_ 


12. DISTRIBUTION/AVAILABILITY STATEMENT 

APPROVED FOR PUBLIC RELEASE; DISTRIBUTION UNLIMITED. _ 


13. SUPPLEMENTARY NOTES _ 


14. ABSTRACT 

The Distributor’s Pallet Packing Problem is to load a set of distinct boxes with given dimensions on pallets or in 
containers to maximize volume utilization. This problem is still in its early stages of research, but there is a high level of interest in 
developing effective models to solve this NP-hard problem to reduce the time, energy and other resources spent in packing pallets. 

In its search to improve operations, the Air Force is also making an effort to solve this problem. Building an 
analytical model and developing a genetic algorithm approach have been tried, but the problem needs more research and there is a 
need to produce realistic solutions in a reasonable amount of time. 

We develop a special heuristic algorithm and code it in the C programming language. In our model, we used powerful heuristic 
tools and dynamic data structure to mimic human behavior, providing a new solution approach to pallet packing. We created another 
program to visualize packing results. Tests on hundreds of problems show that our model makes the most of volume utilization in 
minimal time making it a leader among presented and published works.___ 


15. SUBJECT TERMS 

Three-dimensional pallet-packing, packing problem, bin-packing problem, multi-dimensional knapsack problem, 
pallet-loading problems, distributor’s pallet packing problem, meta-heuristic algorithms 


16. SECURITY CLASSIFICATION OF: 


a. REPORT 

u 


b. ABSTRACT 

u 


C. THIS PAGE 

u 


17. LIMITATION OF 

18. NUMBER 

ABSTRACT 

OF 

uu 

PAGES 

135 


19a. NAME OF RESPONSIBLE PERSON 

James T. Moore, Lt Col, USAF 


19b. TELEPHONE NUMBER (Include area code) 

(937) 255-6565, ext 4337 (James.Moore@afit.edu) 

Standard Form 298 (Rev. 8-98) 

Prescribed by ANSI Std. Z39-18 





















