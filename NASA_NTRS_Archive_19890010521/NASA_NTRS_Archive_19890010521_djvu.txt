NASA Technical Memorandum 87652 


OPERATION OF THE HP2250 WITH THE 
HP9000 SERIES 200 USING PASCAL 3.0 


John Perry and C. W. Stroud 


FEBRUARY 1986 


2 3 1989 

7 ^ 








'-/*f 




(OSA-Tfl -6765 2 ) 
fcilH 10 LF 5 CCC 
(IASI) 35 f 


Cf £R At IC K Cf to HE 225 C 
SIBILS ICC CStBfc FISCAL 3.0 

CSCL 12 A 


G 3/59 


Date for general release 


IW\SA 

National Aeronautics and 
Space Administration 

Langley Research Center 

Hampton. Virginia 23665 


N89- 1S6S2 

Uncla 

01929 

1989 


O* tfi 


OPERATION OF THE HP2250 


WITH THE HP9000 USING 
PASCAL 3.0 

SUMMARY 

A computer program has been written to provide an interface between the 
HP Series 200 desktop computers, operating under HP Standard PASCAL 3.0, and 
the HP2250 Data Acquisition and Control System. PASCAL 3.0 for the HP9000 
desktop computer gives a number of procedures for handling bus communication 
at various levels. It is necessary, however, to reach the lowest possible 
level in PASCAL to handle the bus protocols required by the HP2250. This 
makes programming extremely complex since these protocols are not documented. 
The program described herein solves those problems and allows the user to 
immedately program, simply and efficiently, any measurement and control 
language (MCL/50) application with a few procedure calls. The complete set of 
procedures is available on a 5 1/4" diskette from Cosmic. Included in this 
group of procedures is an Exerciser which allows the user to exercise his 
HP2250 interactively. The Exerciser operates in a fashion similar to the 
Series 200 operating system programs, but is adapted to the requirements of 
the HP2250. 

The requirements for linking to a user's programs are described in detail 
when the diskette is used as received. The procedure for communicating with 
the HP2250 is very straightforward, once a user's program has been debugged 
and compiled. The programs on the diskette and the user's manual assume the 
user is acquainted with both the MCL/50 programming language and HP Standard 
PASCAL 3.0 for the HP series 200 desktop computers. 


I. Introduction 


2 , 


The Hewlett Packard HP2250 is a high performance data acquisition and 
control system that permits users to control and monitor large process control 
systems using a host computer to interface with the HP2250. The HP2250's 
processor is programmed in a dedicated programming language, MCL/50 (ref. 1). 
Communication is via the IEEE 488 standard General Purpose Interface Bus, and 
14 secondary addresses give the host access to all data defined by user 
programs downloaded to the HP2250 and to numerous status blocks defined within 
the system. The HP2250 can be operated by the HP9836A computer from BASIC. 
However, this BASIC is too slow for many applications, and no PASCAL-based 
operating program is available. 

A program named PASCAl__HP2250 has been written to give a user full access 
to the features of the HP2250 data acquisition system by using a few simple, 
efficient procedure calls from PASCAL 3.0 (ref. 2). This paper gives a 
functional explai nation of PASCAL_HP2250, and explains how to operate the 
system. The paper is intended to serve as a user's reference and operating 
manual for the program, which can be obtained from COSMIC (ref. 3). 

The main bus address, secondary 0 (zero), allows loading and execution of 
tasks written in MCL. These tasks may be temporary tasks executed immediately 
or they may be permanent "resident" tasks identified by a TASK command. 

Secondary addresses 1, 2, 3, and 4 give the host computer access to vari- 
ous MCL status blocks. The status may only be read: the host may not modify 
any status variables. The host must, however, write to Secondary 3 to tell it 
which task status is desired. 

Secondaries 5 and 6 write to and read from MCL buffers in real time, 
i.e., they immediately receive the current values, and these values may change 
at any time. 

Secondaries 7 and 8 write to and read from MCL variables in real time. 



3 


Secondary address 9 allows the host to write down-loaded precompiled 
machine code (for the HP1000 computer) subroutines to the HP2250. 

Secondary address 10 is not used by the HP2250. 

Secondary addresses 11, 12, 13, and 14 are "Ports". MCL tasks may assign 
a buffer to a port, whereupon that buffer may not be modified by MCL I/O 
commands until it is read by the host computer. Buffers released to ports are 
thus protected from intervening modification and are consequently not real 
ti me . 

Pascal 3.0 for the HP9000 series 200 desk top computer gives a number of 
procedures for handling bus communications at various levels. It is 
necessary, however, to reach the lowest posssible level in Pascal in order to 
handle the bus protocols required by the HP2250. This makes programming 
extremely complex--particularly since these protocols are not documented. 

Pascal_HP2250 raises the programming level, giving the user full access 
to all features of MCL tasks and permitting the user to program simply and 
efficiently any MCL application with a few simple, efficient procedure calls 
(figure 1). It does not handle secondary address 9; however, facilities are 
present in the module which allow a user to build a procedure analogous to 
TRANSFER_TASK which will do this. Such a user must have ready access to an 
HP1000 computer, and have a real need for machine language routines. 

This report assumes that the user is acquainted with both MCL/50, the 
HP2250's programming language, and HP Standard Pascal 3.0 for the HP Series 
200 desktop computers. The complete set of procedures is available on a 5 
1/4" diskette from COSMIC. Information included as appendix A is a set of 
instructions for linking the program as received from COSMIC to a user program 
in Pascal. Appendix B is a complete listing of the program with a minimal 


4 


driving program and a sample HP2250 program for demonstration of the Transfer_ 
Task procedure. 

II . Decription of Program: 

A. Data Structures 

The data structures in PASCAL_HP2250 are determined by the HP2250's data 
structures. 

Type com_strg is an 80-character command string; its primary use is to 
give a single short command. More complex main tasks may be entered, however, 
by simply putting commands into the main address line by line without entering 
the "!" character. 

Status_type and Interr_type are determined by the structure of their 
secondary addresses' data; their use is straightforward. 

Buffer_type is a record having a count field "count" and a data array 
field "data". The count field gives the number of valid items in the data 
array field. 

B. Procedures 

1. Exported Procedures. 

Each of the exported procedures performs a specific function, and most 
completely handle one secondary address. These procedures are: 

Ini t 2250 : 

Readjnain: 

Wri te_mai n : 

Transfer task: 


sets up the internal bus addresses for the module's 
other procedures. Must be executed before any other 
procedure. 

reads data from the main address. 

writes an MCL command string to the main address. 

reads an MCL task from a disk file and writes it to the 


main address. 



5 


System_status: 
Main_status: 
Resident_status: 
Interrupt_status: 
Write_buff : 
Read_buff : 

Write variable: 


Read variable: 


Read_port: 


reads system status from secondary address 1. 
reads main task status from secondary address 2. 
reads resident task status from secondary address 3. 
reads interrupt status from secondary address 4. 
writes data to an MCI buffer via secondary address 5. 
reads data from an MCL buffer via secondary address 6. 
writes data to a sequence of MCL variables via 
secondary address 7. Since a number of consecutive 
variables may be written in one command, buf_type is 
used to hold the data to be written, 
reads data from a sequence of MCL variables via 
secondary address 8. Uses buf_type in the same way 
Write_Variable does. 

reads data from one of the four port addresses. 


2. Internal Procedures 


The internal procedures are not available outside the module 
Pascal_hp2250. They are very useful within it, however, for making the 
procedures and the bus protocols much easier to understand and use. 

Talk_to_sec: sets up the bus to allow the host computer to talk to 

the HP2250 secondary addresses. 

Listen_to_sec: sets up the bus to allow the host computer to listen. 

Word_eoi : divides output 16-bit integers into two bytes so that 

the EOI control line drops with the last byte. 

3. Exerciser 



6 


The exerciser is a procedure which allows the user to handle interac- 
tively all the facilities in module Pascal_HP2250. It prompts the user for a 
single-character command in the fashion of the operating system, and depending 
upon that command executes or prompts for further input. The exerciser in 
combination with user-applied MCL commands can exercise every facet of HP2250 
operation under Pascal 3.0 except machine language subroutine downloading. 

The only external code needed to operate the exerciser is a program call- 
ing Init_2250 with the correct interface select code and bus address for the 
user's system, and a call to the exerciser. The user may terminate the 
program in any convenient manner outside the exerciser. 

The main program HPROG supplied on the diskette illustrates the use of 
Exerciser and Init_2250 on the system described herein. If the user's 
addresses are different, it is necessary to change only the declarations. 

Ill . Use of Program 

A. Data Structures 

1. Constants : Maxram=16384 is the maximum user ram available in the 

HP2250 system processor. It is thus impossible to have 
a larger data array than Maxram. 

Port_a--Port_d: The secondary addresses of the 

respective ports. 

2. Types : Com_Strg=String[80]; String variable type that handles 

command strings to the hp2250 main address and the file 
name for task transfers. It holds an alphanumeric 
string up to 80 characters long which the user's 
program must fill. 



7 


buffer_type= record count: 0..maxram; 

data: array[l . .maxram] of integer; 

end; 

Buffer_type is a general-purpose integer array with 
associated count variable. All secondary addresses 
return integers, and some require integer inputs. 

Since it is not possible to predict the exact size each 
user program will require, buffer_type is defined to 
include the largest possible data array. The user must 
define his own record type similar to buffer_type, but 
with an appropriate data array size. 

The count field in the user's record must always reflect the 
true data count in the array; it is strongly recommended 
that both the count field and the data array size be limited 
with an appropriate constant size in the same manner as 
buffer_type' s were. Since the compiler does not generate 
value checking for the "anyvar" declarations in buffer_type 
usage, careless use of this type can crash your system. It 
is further recommended that the count field be updated 
immediately whenever the data field is changed: this allows 

the user to keep track of the true size of the data array. 



8 


The procedures that use buffer_type as an output take care 
of these operations internally; the procedures that use 
bufferjtype as input depend upon the count field for their 
operation. This affords some protection from trouble, as 
long as the user is careful to assign values to the data 
field only in concert with correct updating of the count 
field. 

Status_type=array [1..8] of integer; 

All status addresses except the interrupt status have an 
eight-element integer array as output. These are read-only 
arrays which are used as output by their respective 
procedures. 

Interr_type=array [1..16] of integer; 

A 16-element array used as output by the interrupt_status 
procedure. 

Port type=port a.. port d; 

Port type defines the addresses of the ports corresponding to 
their namesakes. It is used as input by the Read_Port 
procedure. 


B. Procedures 

Init_2250 (select_code: type_isc; addr: type_hpib_addr; ) ; 


I nit 2250 sets up the addressing structure for the 



9 


user's system. It must be the first call to the module 
Pascal_HP2250. 

Select_code will be 7 if the internal hpib is used; it 
will usually be 8 if a single external hpib card is 
used. Addr may be determined by the user for his 
system. 

Read_main (anyvar data: buffer_type) ; 

Read_main reads the main result buffer from the HP2250's 
primary address. It leaves the data in the lowest 
elements of data. data, and leaves the number of elements 
in data. count. 


Write_main (strg: com strg); 

Writejnain sends a user- specified MCL command to the 
primary address of the HP2250. Refer to the HP2250 
Programmer's manual (ref. 1) for valid MCL commands. 

Transfer task (taskfile: com strg); 


Transfer_Task allows the user to hold complete tasks on 
disk and transfer them by specifying the file name 



10 

holding the task. Taskfile must be the valid file 
specifier of an existing text file; this file must 
contain an MCL task. 

System_Status (var status: status_type) ; 

Main_Status (var status: Status_type) ; 

System_Status and Main_Status get the status arrays from 
secondaries 1 and 2, respectively. Their parameters are 
output only, and the status may be read at any time by 
calling the procedure, then examining the array. 

Resident_Status (task: integer; var status: status_type) ; 

' Resident_Status differs from Main_status only in that 
it may retrieve the status of any task— not just the main 
task. It therefore requires an input parameter, task, to 
tell it which status to read; status may then be read 
from secondary 3 like main_status. 

Interrupt_Status (var interrupts: interr_type) ; 

Interrupt_Status reads the 16-element interrupt status 
array from secondary address 4. Interrupts is an output 
array only. 


Write buff (bufno: integer: anyvar data: buffer_type) ; 



11 


Write_buff writes via secondary 5 the number of elements 
given in data. count from the array data. data to the MCL 
buffer number given in bufno. 

Bufno must contain the integer name of the desired MCL 
buffer; data. count must contain the number of words to be 
written; and data. data must contain the data values to be 
written. 

Read_buff (bufnorinteger; anyvar data: buffer_type) ; 

Read_buff reads into variable data. data via secondary 6 
data from the MCL buffer specified in bufno. 

Bufno must contain the integer name of the desired MCL 
buffer; data. count must contain the number of words to be 
read; and data. data will contain upon return to the 
caller the data values in the buffer. 

Write__variable (varno: integer; anyvar data: buffer_type) ; 

Write_variable writes via secondary 7 the number of 
elements in data. count from the array data. data to a 
sequence of MCL variables starting with that named in 
"varno" and continuing until the array is exhausted. 


12 


Varno must contain the integer name of the first desired 
MCL variable; data. count must contain the number of data 
to be transferred, therefore the number of variables to 
be written to; and data. data must contain the values to 
be written. There must be exactly as many values in 
data. data as are specified by data. count. 

Read_variable (varnorinteger; anyvar data: buffer_type) ; 

Read_variable reads, via secondary 8, the number of 
elements in data. count from a sequence of variables 
starting with that named in varno and continuing for the 
number of variables given in data. count. The data are 
read into the array data. data. 

Varno must contain the integer name of the first desired 
MCL variable; data. count must contain the number of 
variables to be read; and data. data will contain the 
values, in order, upon return from Read_Variable. 


Read_port (port:port_type; anyvar data: buffer_type) ; 

Read_port reads a buffer from the port named in "port" 
into "data". Before any data can be expected at the 
port, an MCL task running in the HP2250 must have 


13 


executed a RELEASE command to the port named. The array 
data. data must be declared large enough to hold the 
entire expected buffer. 

Port must contain an element of the integer subrange 
port_a. .port_d (11. .14); upon return, data. count will 
contain the number of data elements found at the port; 
data. data will contain the data found. 

Exerciser; 

The Exerciser allows the user to exercise his HP2250 
interactively. It operates in a fashion similar to the 
operating system programs; however, it is augmented to 
reflect the different nature of the HP2250. 

Several levels of prompts must be traversed before a 
command is executed; the number of levels and the details 
of the level structure depend upon which selection is 
made at each level. This is not complex, however, 
because the levels and the prompts are arranged in an 
orderly, logical fashion. 

Each level's prompt gives a set of single-character 
commands possible within its level; upon receipt of a 
valid character, the level prints out the remainder of 



14 

the command's text and goes to the next level. 

Thus: 

r)ead, w)rite, t)ask, s)tatus, q)uit: expects a single 
character, V, "w\ "t" , “s", or "q". 

If the operator types "r", he will see upon the screen 

r)ead, w)rite, t)ask, s)tatus q)uit: Read 

m)ain, v)ariable, b)uffer, p)ort: 

If he then types "m", he will see 
r)ead, w)rite, t)ask, sltatus, qluit: read 

m)ain, v)ariable, b)uffer, p)ort: main 

0 


Since read_main requires no more input, the exerciser 
immediately reads the main result data, which in this 
case was a single word zero. Characters will be accepted 
until a "q" or "Q" is typed; the exerciser will then 
return to the calling program. 

Some levels require input data from the keyboard. In all 
cases the prompts are straightforward and depend upon the 
parameters required by the procedures they exercise. 



15 


CONCLUDING REMARKS 


This program solves the problem of communication between the HP9000 
series 200 computer and the HP220 data acquisition and control system. The 
program removes the need for low level access to the Pascal input/output 
system, making all facilities of the HP2250 available to the Pascal user in 
simple procedure calls. The only facility not currently supported is 
machine-language down loading. The complete set of procedures is available 
from COSMIC on a 5 1/4" diskette. Included in this group of procedures is an 
Exerciser, which allows the user to exercise his HP2250 interactively. 



16 


APPENDIX A 




Linking to a User Program 

If the diskette is used as it is, the requirements for 
linking are given in the Pascal 3.0 User's Manual for HP 
Series 200 Computers. In summary, the requirements for 
this program are: 

In the text of your Pascal source, insert the line 


$ search 'PA2250:PASC_2250'$. 

This tells the compiler where to find the module. In 
the declaration part of your source, insert 

Import Pascal_HP2250; 

All the export declaration will then be available for 
linking to your program. 

After the user program has been debugged and compiled, it 
will be necessary to link the modules using the 
Librarian. 

An example is given on the diskette in the stream file 
PA2250 :HPR0G .LNK .TEXT 

for the sample program HPROG on the diskette. HP. CODE is 
the linked, executable version given for this document. 


i 


17 


APPENDIX B 


The program HP (file HPROG) is a minimum driving program for module 
Pascal_HP2250. If the HPIB select code or device number are different, the 
sel_code and address must be changed to match your system's. The program will 
then execute properly. 

This program can, in fact, be used to check out your system's operation, 
and to train personnel in the use of the HP2250, since its only limitation is 
its lack of a procedure to transfer machine code to the HP2250. Every other 
facility is available to the user, depending upon the input/output cards 
installed in the system. 


THE FOLLOWING 
PAGES ARE 


PROGRAM LISTINGS 



cal L Rev 3.0 b/ 4/84] HPRGG . 1 LX I 


4 -Dec -85 14:35:5 


1 

D 

0 

Siist onS 


2 

U 

0 

Si mes 

58$ 


3 

D 

0 

$ page width 80S 


4 

1) 

0 

Ssearch 

' PA2250 : PASC_225U S 

3 

D 

0 

PROGRAM 

HP (input, out 

put ) : 

6 

o 



P as c a i 1 1 1' 1 a 2 5 U . 


7 

t 

p 

D 

l 

impor t 

i ocomasm , 

o 

9 

O 

r\ 

Li 

1 

! 

const 

se i._code = 8 ; 

it or the 

1 0 
i t 

D 

f - 

1 


address =5 : 


1 1 
1 

1 c_ 

O 

D 

t 1 

« i 

- i t 

v a i 

ch : char: 


! o 

14 

o 

c 

i 

begin 

hp } 


15 

C 

i 

i n i t_ 

2250 <sei_code. 

address) ; 

1 b 


I 

exerc 

i ser ; 


17: 

c 

i 

end . 

{ hp> 



e r ro r s . No yarn i ngs . 


i odec l arat ions ; 
author's system) 


ORIGINAL PAGE SB 

OF. POOR QUALITY 


18 • 

Page 


ORIGINAL 

OF POOR QUALfTY 


19 


Pascal i Kev i . 0 / 4/y4i f‘ABb_.22..)Q . ir. Xi 


t\ - Dec ~85 ! 4 : 26 : 1 L Page 1 


l : u 
2:0 
3:0 
4:0 
5 : o 
b : S 

2 . 1 

7 : 0 
8 : S 
9 : S 
1 0 : D 
general _1 
i 1 : 0 
1 2 : S 
! 3 : 0 
14:0 

15:0 
1 6 : D 

1 7 : D 
1 8 : D 
! 9 : S 

2 C : 3 
2 1 : 1 ) 

fa use) 

>:• ■ n 


j.ng program 
24:0 

n t ! ) 

26 : 0 
26 : D 

ms in array ) 
27:0 

er: (data array. 
28 : L) 

29 : S 
30:0 

s data array) 

3 1 : 0 

rapt data) 

32 . D 

ress of ports) 


0 $i .isr oriS 
0 SsysprogS 

0 $ lines S8S 

I) Spageuidth BOS 

MODUlL Pasca i_,HP225G : (interface between 983b Pascal 

! and hp2250 ) 

1 import up i b_ 0 . hp i b 1 , hpib_2, hoib_3 , general_U, generai_i , 

1 general _3, generai_4, iocomasrn, lodeciarat ions , is; 


export 


cor.sr mcixraro* 1 6384 : (maximum RAH available to user 


oor t_,a= I ’ ; 

por t d = I 2 . 

nor 1 3 ; 
por t d ^ 1 4 ; 


secondary addresses of } 
ports in HP225G > 


t'/P 1 


o pi _.s trg- s c r i n g [ 8 0 1 ; 


i command s t r i rig i o r a i 


'User of out f er_type must be careful in call 

chat count ALAAfS reflects true data cou 

bu+ i er _type= record 

coun t : 0 . .max r am ; { data i Le 

data: array M.maxrantJ of mteg 

end ; { buf i er_ type > 

status,_ty pe-'array L1..81 of integer: \statu 

i nter r_type r - array lI., 161 of integer; » inter 
por t_type=port_a. . port_d; (secondary add 



Pascal i Kev 


3.e b/ 4/84] P9SC„225Q . 1 LXT 


4 -Dec -85 14:26:18 Page <rc 


35 :D 

1 

SpageS 

Jb ; D 

! 

3 list onS 

37:0 

\ 

procedure 

p ib addr > ; 

38 : D 

! 

procedure 

39 ;D 

i 

p rocedure 

40:0 

i 

procedure 

41 : D 

i 

procedure 

42 : D 

i 

procedure 

43 :D 

i 

procedure 

44 :D 



e > ; 

45 ;D 

} 

procedure 

46 : D 

t 

procedure 

r type > : 

4 7 : D 

i 

procedure 

type) ; 

48 :D 

i 

procedure 

er_type ) ; 

49 :D 

i 

proceoure 

er type ) ; 

50:0 

i 

p r o c ed are 

type) ; 

51 :D 

i 

p rocedur e 


in 1 t_.2250 (select_code : type_isc; addi : t;ype._h 

read_.main (anyvar data: buf f er„type ) : 
wr !. tc_uain (strg: com_strg) ; 

t f ansf e r task ( t ask fixe: com — s t r g ) < 

systemlstatus (var status: status_ty pe ) : 
main_..status (va.r status: st.atus._type ) , 
resident status (task; integer; 

var status: status_typ 

interrupt status (var interrupts: interr_type) 

uritejouff (buf no: integer; anyvar data: butte 

read. buff (but no: integer; anyvar data: buffer 

uir ite_var labie (varno: integer; anyvar data: buff 

read_var lable (varno: integer; anyvar data: but f 

read_por t (port: port_type; anyvar data: buHe:r_ 

exerciser: ^exercise module interactively 


ORIGINAL PAGE IS 
OF POOR QUALfTY 



ORIGINAL PAGE $S 

OF POOR QUALITY 


Pascal LKev 3.0 6 / 4/84 ) PhSC 2250 . 1 LXT 


4-Dec-85 14:26: IS Page 3 


53 : D 
54:0 
55 : D 


] & p ag e 3 
I 3 list on$ 
1 implement 


card; type_.isc; 


thpib card interface select 


•b I 
-8 1 


bus_aadr, my_addr: type_hp ib_addr ; 

dev : rype_dev ice ; (composite address tor certain 


i (set up hpib to talk to a secondary or the main address! 

1 procedure taik_to_.sec (sec: type_np ib_addr > ; 

.i begin 

2 an t is ten (card); talk (card, my_addr); 

2 listen (card. bus_addr ) ; if sec <>0 then secondary (card, sec 


6 8 : L 

63 : S 
70 :S 

7 I : D 
72:0 
73 :S 
? 3 : C 
7 5 : C 
7 6 : C 
77 :C 


end ; 


:.aik to sec. 


82 : 0 
83 :S 
84 : D 


' (set up hpib to j isten to a secondary or the main address! 

1 procedure 1 isten_to_sec (sec: type_hp ib_addr ) ; 

2 . begin 

2 am isten (card): talk (card, bus._addr); 

2 it secOtJ then secondary (card, sec): 

2 listen (card, my aadr); if sec <>0 then secondary <card, sec) 


i T 

sec<>U then 

seconuar 

li 

5 . ten (card. 

[ny_adclr ) ; 

end ; 

i j s i e n_ 

ro^sec f 

(put 

eo i. si gna 1 

o n t o last 

proceamre 

uord_eo 1 


t»y re_s i ze^25b : 


8 b : C 

87 iC 
88 : C 

88 :C 
90 :C 
9 ! : S' 
92 : S 
93 : 0 


d. oegin 

2 untecmar vcard, chr (word div byte_size)); 
2 set_.npiD (card, eoi._iine); 

2 jritechar (card, chr (word mod byte_size>>; 

2 end; {word_eoi* 


! (set up s 


select code, bus address, and device address for u25Ui 


94 : 0 

pib_addr) ; 
95 : S 
96 : C 
37 : C 
98 :C 
39 : C 
1 00 : S 
1 0 1 : S 


procedure imt__225G ( se iect_code : type_isc ; ad dr ; type._h 

begin . . 

card : r_ se iect_code : bus_addr : “addr ; dev : “card* I UU+bus_addr ; 

m y ,_ad d r : = m y __ad dress (car d > : 
end; ( in i ?._ 2^50 > 



Pascal i Rev 3.0 b/ 4/843 PAbC._2250 . 1EXT 


4-Dec-85 14:2b: 1b Page 4 


102 

D 

-8 

1 

$page$ 

103 

i) 

r> 

u 

1 

$1 ist onS 

104 

I) 

" d 

1 

{ read main address message from hp2250) 

10b 

D 


1 

procedure read_main (anyvar data: butfer_ 

10b 

s 




107 

0 

-8 

C. 

var i, uiords: integer; 

108 

D 

-40 

2 

status: status_type; 

109 

t'* 

O 




1 10 

C 


L. 

begin 

i i 1 

c 


2 

systam_s talus (status) ; 

112 

c 


4 . 

1 isten_to_sec (0); 

1 1 3 



2 

for i:=I to status! 4] do readuord (card, data 

114: 

c 


2 

data. count : ^status! 4 ] ; 

115: 

C 


iL 

untalk (card); uniisten (card); 

11b: 

r 


C. 

end; {read_main> 

117: 

y 




118: 

s 



furite a command to the main address) 

119: 

D 

-8 

! 

120 

D 

-82 

1 

procedure mr i te_mai n (strg: com_strg); 


2 var 


2 begin 


i. words: integer; 


2 uir l tes t r mg (dev/.^trg); set_hpib (card, eo inline); 
2 writechar (card. chr<10>); 

2 un talk (card); uniisten (card); 

2 end; { wr 1 te_main > 


1 (write task to tiiairi adGress from a disk file.* 

1 procedure t ransf er__task (task file: com_s t r g ) ; 


1 34 : D 

-74b 


^ar task ; text; it 

text) 
1 35 : L) 

“ O C O 

2 

command ; com_s t. r g ; 

j 

1 Jb ; y) 

1 37 : C 


> 

<— 

begin 

1 38 : C 


"i 

21 

reset (task, task tile); 

1 39 : C 


£ 

while not eof(task) do 

1 40 :C 


3 

begin 

14 1 : C 


3 

r sad 1 n ( t ask , command ) 

1 42 : C 


3 

end; (while*- 

1 43 : C 


t. 

set_hpih (card, eo inline 

1 44 : C 


2 

untalk (card); uniisten 

1 45 : C 


2 

end : { transf er_task > 


(rile cental rung task code -“must be ly 
g; ; name of f lie- -form XXXXXXXX.T 


1 card ) ; 


ORIGINAL PAGE IS 
OF POOR QUALITY 



ORIGINAL page is 
pf POC° niTAUTY 


23 


cai 

1 Rev 

3.0 

b 

,/ 4/84 j P66C_2250 . 1 EXT 4-Dec-85 14:26:16 Page 5 

148 

D 

-8 

1 

SpageS 

149 

I) 

-8 

! 

Siist on$ 

lbO 

U 

. O 
o 

i 

{get system status from secondary l> 

151 

D 


*i 

procedure system_status ivar status: status_type > : 

1 52 

s 




153 

D 

-4 

2 

var i: integer; 

154 

o 

V.} 




155 

L 


,> 

Degi n 

15b 

c 


2 

i isten_.to._sec < 1 ) : 

157 

c 



for i:=l to 8 oo readuord (card, statuslii); 

158 

c 


<i 

untaik (card/; uni is ten (card); 

159 

c 


2 

end ; ■. system s tat us/ 

1 bu 

s 




161 

8 




162 

0 

_ o 
o 

1 

{get main task; status from secondary de- 

163 

D 


1 

procedure main_status (var status: status_.type > : 

164 

c 

O 




165 

u 


9 

var i: integer; 

1 66 

o 




167 

l 

k- 


■> 

beg i n 

1 68 

c 



i isven_to_sec (2); 

169 

r ' 


■“> 

£ 

for i : = 1 to 8 do readword (card, status! il); 

1 70 

c 


/ 

untaik (card); unlisten (card); 

1 71 

r 


2 

end: f mam. status > 

1 72 

s 




1 73 

s 




174 

D 

-a 

i 

(get resident, cask status i rom secondary 3> 

175 

D 



procedure res ident_status (task; integer; 

176 

0 


2 

var status; status 

1 77 

o 




1 78 


-4 

2 

var 1 : integer: 

179 

s 




180 

c 


L~ 

beg l n 

1 8 i 

c 


Cl 

taik__to_sec (3): 

182 : 



C. 

uiord__eoi (task); 

183 

Vj 


C— 

untaik (card); uni is ten (card); 

184; 

I" 

V,- 


2 

i isten_to_sec (3): 

1 85 

c 


y 

for i : = 1 to 3 do reaaword (card, status! i 3 > ; 

1 86 : 

c 



untaik (card); uniisten (card); 

187 

c 


L. 

end; < resident_statu.s> 

188; 

■:> 




1 89 ; 

o 






24 


Pascal l Kev 

3.0 

t./ 4/84] PP3C._2250. I6XT 4 -Dec -85 14:26:16 Page 6 

ISO: I) 

-8 

1 

$ page’S 

1 9 1 : 

-8 

! 

$ i ist onS 

192:0 

" 6 

i 

(get interrupt status from secondary 4> 

1 S3 : D 


1 

procedure interrupt_status (var interrupts: inter r._type ) 

194:3 




195:0 

-4 

2 

var i: integer; 

1 36 : S 




197: C 


2 

begin 

1 98 : C 


-> 

1 isten_to__sec (4): 

1 99 : C 


2 

for i : = 1 to 16 do readuord (card, interrupts! i J ) ; 

200 :C 


2 

untaik (card): uni is ten (card); 

201 :C 


lL- 

end; { inter rupt_stat.us> 

202 :S 




203 :S 




204:0 


1 

: write data to ouffer with secondary bi- 

205:0 


1 

procedure write_buff (bufno: integer; anyvar data; bufte 

r type) : 




206 :S 




207 :D 

-4 

2 

var i: integer. 

208: S 




209 :C 


Z 

beg i ri 

21 0 : C 


2 

taik_to_sec (5>: 

2 1 1 : C 



wr l teword (card, bufno); 

212 :C 


2 

(jriieuord (card. data. count ) ; 

213: C 


s 

for i:-1 to data. count do writeword (card, data. dataL i J ) ; 

2 1 4 : C 


2 

untalk (card); un I is ten (card); 

2 1 5 : C 


o 

lL. 

end; { wr i te_buf f > 

2 i 6 : S 




217:3 




218:0 

-8 

t 

; reau data from buffer with secondary bi- 

219: 0 


1 

procedure read_bu.ff (bufno: integer; anyvar data; buffer 

type) : 




220:3 




22 1 : D 

-4 

2 

var i: integer; 

222:3 




223 :C 


2 

beg i n 

224 : C 


j 

C- 

taik_to_sec <B); 

225 :C 


2 

writeuord (card, but no); 

226 :C 


tL 

word_eoi (data, court t ) ; 

227 :C 


;> 

untalk (card); uniisten (card); 

228 : C 


“) 

1 is ten_to_sec (6); 

229 :C 


2 

for i : = 1 to data. count do readword (card, data. data! l i ) ; 

230 :C 



untalk (card); uniisten (card); 

231 ;C 
232 : 3 


L_ 

end; Ire ad_t>uf f > 

O O' j * c 
L. O O 4 O 





ORIGINAL PAGE IS 
OF POOR QUALITY 



ORIGINAL PAGE IS 

OF POOR QUALITY 


Pascai i.Rev 3.0 b./ RAbC_22bO.iE.XT 


■ Oec - 85 


1 4 : 26 


25 

lb F’age 


234 : D 
235:1) 
236 : D 
237 : D 
er_type> ; 


-8 


1 $page$ 

! Siist on$ 

1 \ w r i te data 
1 procedure 


to variable with secondary /> 
write variable (varno: integer 


anyvar data: but 


238 :S 


239 : 0 

-4 2 

240 :S 


241 : C 

2 

242 : C 

2 

243 :C 

;> 

244 :C 

2 

245 : C 

2 

246 :C 

*~> 

C. 

247 :C 

<1 

248 : C 


249 : S 


250 :S 


251:0 

-8 1 

252 :i) 

1 


var i: integer; 

begin 

taik__to_sec (?); 
writeword ( card . varno); 
writeword (card. data. count) ;• 

for i : — 1 to data. count - 1, do wr iteword (card, data. oatal i i ) ; 
worcl_eoi (data. dataidata. count i > ; 
untalk (cara); uni is ten (card); 
end: iwr ite_var i ablet 


; read oats from variable with secondary 8) 


procedure 


read variable (varno: integer; anyvar data: buf 


er type); 




253 :S 




254 : D 

-4 

£ 

var j ’• integer; 

255 :S 




256 :C 



beg i n 

257 : C 



talk_to_sec (8): 

258 : C 


"> 

C- 

writeword (card, varno): 

259 :C 


2 

word_.eo i < data, coun t ) : 

260 :C 


2 

untalk (card); unlisten (card); 

261 : C 


A 

t— 

i isten_to_sec (8); 

262 : C 


y 

for i : =1 to data. count do readuord 

263 :C 


~> 

un talk (card); uniisten (card); 

264 : C 


7> 

end*. { read. .var i able > 

265 : 3 




266 : S 




267 ;S 




268 : D 

a 

O 

! 

(read data from port with secondary 

269:D 


1 

procedure read_por t (port: por t_ 

type) ; 




270 :S 




271 :D 

-4 


var i: integer; 

272:0 

- 3 6 

_■) 

status: status._type ; 

273 ;S 




274 :C 


2 

begin 

275 : C 


2 

sy s t em_s tat us ( s t at us > ; 

2 76:6 


2 

data, count : = statu.sL por t - 6 j ; 

277 :C 


2 

1 isten_to„sec (port); 

2 7 8 : C 


2 

for 1 1 — 1 to data. count do readuord 

279;C 


y 

untalk (card); uniisten (card): 

280:6 



end; iread_port> 


1 1 - 14 } 


buf f er. 


ascai iKev 3.0 6/ 4/84 J i-'A8C_2250 . TEX 


284 

•D 

-8 

1 

285 

D 

-8 

1 

( 

28b 

D 


1 

287 

3 



288 

D 


') 

289 

S 



290 

D 

-32 

2 

291 

D 

-60 

2 

292 

D 

-61 

2 

293 

D 

-224 

> 

i 

294 

D 

-224 

2 

295 

0 

-224 

2 

296 

D 

-354 

2 

297 

D 

-418 

3 

298 

D 

-420 

2 

299 

c 

> J 



300 

c 


J 

i— 

301 

c 


0 

<_ 

302 

c 


o 

,_> 

303 

L 


4 

304 

C 


4 

305 

, L 


Q 

q ) ui t ; 

> ; 


306 

c 


O 

307 

c 


3 

308: 

c 


4 

309 



4 

3 ! 0 

$ 




r l SpageS 
Slist otiS 
1 procedure 


exerciser: 


cons i 
var 


c r = c h r < i 3 > : 


826 

4- Dec-85 14:26: ib Page 8 

(exercise module interactively 
(carriage return char s 


status : status_type ; 

row, col, i. j, varno, but no, task: integer; 
ch: char: 

command, filename: com_strg; 
data:' record count: 0 . . 32 : 

data: array [1..321 of integer; 
end; (data record / 

inters; interr_type; 
port: port_type; 


begin 
repeat 

for i : - L» to !U do begin 
tgotoxy (output, 0,i>; for j : 3 1 to 

0 FlC I 

tgotoxy (output, 0,1); ante ( r>ead, w>rite, t>ask: 


do write ( ’ 


tgetxy (output, col. row); 
repeat 

tgotoxy (output, col, row); read (ch) 
until c h in L r ' , ' R . w . 8 , t , T , s 


) ; 

, ) tat u.s 


, ' q ' . ' Q ' 1 


ORIGINAL PAGE IS 
Op POOR QUALITY 



ORIGINAL PAGE IS 
OF POOR QUALriY 


’ascai Lt\ev J.U 


b i '-i / 8 4 J PhSC 2 2 6 0 . i EXT 


4-Dec~85 14:26:16 Page 9 


311 : C 
3 1 2 : C 


3 $>pageS 
3 Si ist onS 


o r d t c h ) o r 


• read .... 

oratr >. ovd ('FT): begin 

ut r i te i n { ead ) : write ( iti ) ai n . v ) ar i ab i e « b Hu" t e i . I-*) 

1 ge t x y ( output , co i . r ow ) ; 
reoeat 

fgotoxy (output, coi , row) ; read (eft); 
until cb in 1 in ’ , ’ H ’ , v , ' V , ' b , B « p . 6 •* ! 

case ord (cn) of 


324 : C 
325 : C 
326 : C 
327 ;C 
328 : C 
i t e 1 n 
329 : C 

33 U : o 


tread main/ 

ord < m ' > , ord < 'M ' ,> : 

Deg in 

or i te in ( ain ) : read niaxn (data): 

tor i ; = i to data. co un t do write ( dat a . oat ai i j : 3 ) , w r 


end : 


o r c v 


( ' fit ' ) , ord ( !1 ) 



10 


nr 

28 


Pascal tKev 3.0 

331 :C 
332 : 0 
333 : C 
3 3 A *.3 
335 :C 
336 : C 

no. data, count) 

337 :C 
338 : C 
339 : C 


O 

341 :C 
342 : C 
343:0 
344 : C 
ta. count ) : 
343 :C 
346 :C 
34? :C 
348:3 

349 :C 

350 :C 

35 1 : C 
352 : 0 
353 : C 
354 :C 
355 : C 
35b : C 
357 ;C 
358 : C 
359:0 

360 :C 

36 1 : C 
362 : C 
363 : 0 
364:0 
365 :S 


U/ 4/84 J P680_2250 . i 6XT 


4 --Dec "65 14:26:16 Page 


S $ pageS 
5 Siist c>n '5 


5 

5 


5 


5 

5 

5 

5 


5 

5 


f.. 

sJ 

t; 

.j 

6 

6 

5 

5 


5 


5 


•>, <«<.*« <«■ 

1 1 Ja J J^do J i t. ‘data.aata! 0:8.! 

J: ‘lord rv'», ord < V >. 

JrrJ’Jd . .. 

r J'< dJJ Jb... * words: read Iri — 

?.?■ t J J:cJ a, do writ, (data.datal .1:8): 
J?’ (ord < ' b' > , ord 

rrrrord <■?■>: 

write In Oort >< c D >: '>; 

write < port name <6,b.L.u 

“getxv (output, col. ro»> . 

repeat , rouO ; read <ch >1 

t a o t o x y t output , - ' V> ] . 

ur.tU ch in 18,8,0. 

per t: w ord<cti)"54; . 

HfrrOJ^a.cJt'do write <data.dataU f :U • 
end' 'lord <V>. ord < 8 >' 

otherwise ido nothing} 
en(j ' { or d Of ), ord t K > ■- 


ena : 


ORIGINAL PAGE IS 
OF POOR QUALITY 



ORIGINAL PAGE IS 
OF POOR QUALITY 


Pascal i.F<ev 3.0 


6/ 4/841 PfiSC 2350 . I'LX' 


29 

4- Dec-85 14:26:16 Page 11 


366 : 6 

4 

SpageS 

367: 6 

4 

Siist on'5 

368 : C 

4 

(write...) 

369 : C 

4 

ord('w ), ord ( W): begin 

370 : C 

4 

wr t te in ("rite'); 

371 : C 

4 

write (or, m)ain, v)ariable, bluffer: ’): 

372 :C 

4 

fgetxy (output, col, row); 

373: C 

4 

repeat 

374 :C 

5 

fgotoxy (output, col, row); read (ch) 

375 :C 

5 

until c h j r L ' m ' , ' M ' . ' v ' , ' V ' , ' b ' , ' B ' 1 ; 

376 :C 

4 

case ord < c ft ) of 

377:3 



3/8 : C 

5 

(write main) 

379 : C 

3 

ord ('m ) .ord ( M' ) : begin 

380:6 

J 

w r 1 1 e 1 n < ’ a i n ) : 

38 1 :C 

5 

write ( MCl command: ); readin (command) 

( command ) 



382 : C 

3 

end : lord < ' m ' ) , ord ( M ' ) ) 

383:8 



384:6 

3 

(write variable) 

385:6 

3 

ord ( ' v ) . o r d <'V'): begin 

386 :C 

5 

wr l te in ( ar i abi e ) ; 

387:6 

3 

write < start variable, r variables: ' ) ; 


write mat 


); read In (va 


mo, data, count ) : 

. , r ' r 


388 

: C 

3 

389 

: C 

3 

390 

:C 

3 

39 i 

; C 

5 

392 

J vJ 

3 

393 

: S 


394 

: C 

3 

393 

* r 

♦ i.. 

(_ 

._) 

396 

6 

b 

397 

:C 

b 

ta . count ) ; 


398 

C 

r 

O 

399 

:C 

3 

4 ClU 

:6 

L 

40': 

:C 

b 

402 

* i*' 

b 

403 

:C 

b 

404 

: C 

l; 

403 

: C 

3 

406 

r 

« V-- 

4 

407 

, (“ 
♦ O 


408 

:C 

4 

409 

:C 

4 

4 1 0 

: C 

L\ 

4 i 1 

:C 

4 

sk ( f i 

Leriame > : 


412 


4 

4 1 3 

c 

4 

414 

r - 
O 



write ( data. count : 2 , values: 

tor i:-1 to oat a . count - 'I do read (data. data! i 1 ) ; 
re ad In ( data. datat data. count ] > ; 
wr i te„.var lab ie (varno, data) 
end i ■ o rd v ’ v ' ) , o r d ( ' V ' > ) 

l write buffer) 
ord (, D > . ord < ' B ' > : begin 
w r i to 1 n ( uf f er ’ > ; 

write (buffer number, n words: ): readln (bufno.da 

write ( data. count : 2 , ' values: '); 

for i: = ': to oata . count - 1 do read ( data, data! 1 1 > ; 

readln ( data. dataL data. count 3 ) ; 
write_buff (bufno. data) 
end: lord <b'), ord (B'>/ 

otherwise Ido nothing) 
end: { case ord ( c h ) ) 

end ; : o r d ( w ' > , o r a ( d ' ) 

i transf er task: . . . ) 
ord( t ) , ord ('!'): beg in 
write in i ransfer task'); 

write < task filename: ') {readln (filename); transfer_ta 

w r i te 1 n < f l i e name , sen t ) : 

e no : f o r d ( ’ t ' > , ord (’[")) 



30 ' 


Pascal 

1 Kev 3 

U 6/ 4/84] PASC_2250 . i EXT 4-Dec-85 14:26:16 Page 12 


4 1 5 

C 

4 

$page$ 


416 

C 

4 

$iist on$ 


417 

C 

4 

(status of...) 


418 

C 

4 

ord('s'), ord (S'): begin 


419 

c • 

4 

write In < ' tatus of: ' > ; 


420 

c 

4 

write ( siystem, m)ain, r>esident, i)nterrupt; ); 


421 

c 

4 

(getxy (output, col, row); 


422 

c 

4 

repeat 


423 

c 

12 

_J 

fgotoxy (output, col. row): read (ch) ; 


424 


t: 

until ch in l ' s ' , ' S ' , ' m ‘ , ' M ' , " r ' , R , i ' » I i J 


429 

«’* 

v> 

4 

case ord (ch) of 


426 

S 




427 

c 

c 

ji 

■.status of system) 


428 

c 

b 

ord ( s > . ord (S'): 


429 

c 

6. 

begin 


430 

C' 

5 

writein ( ystem ) ; sysxem_status (status); 


431 

c 

5 

for i : = 1 to 8 do write (status! iJ:4); write In 


432 

c 

5 

end ; (ord (s’), ord (S’) ) 


433 

s 




434 

c 

c 

(status of main) 


435 

r 

s 

ord ( ' m ' ) , o r d < ' M ) : begin 


436 

c 

17 

writein ('am'); main_status (status): 


437 

r 

o 

5 

for i.* = 1 to 8 do write ( status [ i i : 4 ) j writein 


438 

C 

5 

end ; i ord ( ' m ' ) , crd ( li ' ) .1 


439 

s 




440 

c 

2) 

(status of resident task / 


441 

: C 

5 

ord ( ' r ) . o r d ( ' R ' ) : beg i n 


442 

C 

5 

writein ('esident task'); 


443 

:C 

5 

write (task: ' ) ; reaciin (task); res ident_status 

sk 

status ) ; 




444 

C 

5 

tor i.'-i to 8 do write (status! i j :4) ; writein 


445 

c 

b 

end ; f ord < r ' ) , ord < ' K ' ) ) 


446 

6 




447 

C 

b 

(status of interrupts) 


448 

c 

s 

ord ('i').ord ('!'): begin 


449 

c 

5 

writein ( ' nter r apt ) ; 


450 

c 

5 

i n te r r up t_s ta t us ( i n ter r ) ; 


451 

c 

5 

for i : - ! to 16 do write ( interr ! i ] : 4) ; writein 


452 

c 

5 

end ; lord < i ) , ord ( i ' ) ) 


453 

c 

b 



454 

c 

s 

otherwise (do nothing) 


455 

c 

b 

end; lease ord (ch>) 


456 

c 

ix 

end ; (ord ('s'), o rd ( ' S ' ) > 


457 

s 




458 

c. 

A 

otherwise (do nothing) 


459 

c 

A 

end ; ( case ord ( ch ) ) 


460 

c 

-j 

w> 

unt l i ch in i q > ' Q ' J 


461 

3 




462 

c 


end; (exerciser) 


483 

o 




464 

c: 

1 

end. ( Pascal __HP 2 2 5 0 ) 

No 

errors. No 

warnings. 


***** Nonstandard language features enabled ***** 


ORIGINAL PAGE IS 
OF POOR QUALITY 



ORIGINAL PAGE IS 
OF POOR QUALITY 


•* j-Lt Hh KLiG . LNK. . i LX i ■** 

■front opera! ing system level use 
to lmic HPRUG and PAi>L_2250 . 


stream command on this tile 


LOHP 

IHPROG 

AIPASC_22S0 

ALKQ 


»‘*FILL i NI T DAS . *'LX‘ ** 

use t h is as s o u ice for t r an s t e r 
10 variables, 10 butters each 
amount of available memory. 


task command • 
10 words long, 


Def mes 
and ask 


10 task 
s for 


n tasks <0* ; n tastes ( !0> : dimension (d0, 10.02 
cibd): cib < 2 > ; cib (3): aon < '• M 


1 Z ♦ i u > 



32 


REFERENCES 


1. Hewlett-Packard Measurement and Control Processor Programmer's Manual, HP 

part number 25580-90001, Mar. 1981. 

2. Hewlett-Packard Pascal Language Reference for the HP9000 series 200 

computers. HP part number 98615-90050, Feb. 1984. 


3. Computer Software Management and Information Center, 112 Barrow Hall 
The University of Georgia, Athens, GA, 30602. VPD 7744/7-82. 






Standard Bibliographic Page 


1. Report No. 


I ; rivfJp I i 


4. Title and Subtitle 


2. Government Accession No. 


OPERATION OF THE HP2250 WITH THE HP9000 SERIES 200 
USING PASCAL 3.0 


7. Author(s) 

John Perry (PRC Kentron, Inc.) and C. W. Stroud (LaRC) 

9. Performing Organization Name and Address 


3. Recipient’s Catalog No. 


5. Report Date 

February 1986 

6. Performing Organization Code 

506-43-81 

8. Performing Organization Report No. 
10. Work Unit No. " ~ 


NASA Langley Research Center 
Hampton, VA 23665-5225 

12. Sponsoring Agency Name and Address 

National Aeronautics and Space Administration 
Washington, DC 20546-0001 


11. Contract or Grant No. 

13. Type of Report and Period Covered 

Technical Memorandum 

14. Sponsoring Agency Code 



16. Abstract . . 

A computer program has been written to provide an interface between the 
HP Series 200 desktop computers, operating under HP Standard PASCAL 3.0, and 
the HP2250 Data Acquisition and Control System. PASCAL 3.0 for the HP9000 
desktop computer gives a number of procedures for handling bus communication 
at various levels. It is necessary, however, to reach the lowest possible 
level in PASCAL to handle the bus protocols required by the HP2250. This 
makes programming extremely complex since these protocols are not documented. 
The program described herein solves those problems and allows the user to 
immedately program, simply and efficiently, any measurement and control 
language (MCL/50) application with a few procedure calls. The complete set of 
procedures is available on a 5 1/4" diskette from Cosmic. Included in this 
group of procedures is an Exerciser which allows the user to exercise his 
HP2250 interactively. The Exerciser operates in a fashion similar to the 
Series 200 operating system programs, but is adapted to the requirements of 
the HP2250. 

The requirements for linking to a user's programs are described in detail 
when the diskette is used as received. The procedure for communicating with 
the HP2250 is very straightforward, once a user's program has been debugged 
and compiled. The programs on the diskette and the user's manual assume the 
user is acquainted with both the MCL/50 programming language and HP Standard 
PASCAL 3.0 for the HP series 200 desktop computers. 


17. Key Words (Suggested by Authors(s)) 

HP2250 
HP9000 
PASCAL 3.0 


18. Distribution Statement 


Subject Category 5 


19. Security Classif.(of this report) 

Unclassified 









