REP 


AD-A242 278 


PuMe raporting burdtn for thit o 
nMdtd. and ra^nwn g tho colac 
HMdquartMS Sarvfco, Oiroctorai 
Managamont and Budgat. Waaht 


1. AGENCY USE ONLY (Leave Blank) 


AGE 


Form Approved 
OPM No. 0704-018$ 


I 


2. REPORT DATE 


nw lor r oi^owlng MrucUano. l Oi r cWng wIMInc <Ma •omn gattitring and maMiMng tia dn 
vao o< Mi colactton of Momution. Indudkig tuggaMona for taduckig Ma biadan, to WaahingBn 
>04. Aikiglon. VA ZZ2a2-430Z and to lha OlHca of Moimalion and Ragulaloiy Mlain. OlHca of 


3. REPORT TYPE AND DATES COVERED 

Rnal; 09 Aug 1991 to 01 Jun 1993 


4. TITLE AND SUBTITLE 


Alsys, Inc., AlsyCOMP_058, Version 5.3, Unisys B39 under BTOSII, v3.2.0 (Host & 

Target), 910809W1.11196 



O ' ; i 

6. AUTHOR(S) 

Wright-Patterson AFB, Dayton, OH 

■ ? 1' . 

USA 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Ada Validation Facility. Language Control Facility ASD/SCEL 

Bldg. 676, Rm135 

Wright-Patterson AFB, Dayton, OH 45433 

r 


9. SPONSORING/MONITORING AGENCY NAME(S) AND A00RESS<ES) 

Ada Joint Program Office 

United States Department of Defense 

Pentagon. Rm 3E114 

Washington, D.C. 20301-3081 



RMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-5000-0891 


10. SPONSORINGAUIONITORING AGENCY 
REPORT NUMBER 


11. SUPPLEMENTARY NOTES 

^ J If- 4-(. v.'£.i 1 ^ cX.-- L'-it L 'i-t V (./.<- -v '// 1 (C^ k'p 

‘ I I ' '* / - • 

. 4 A I i { H < 4- ^ ^ ^ 1 ' 


12a DISTRIBUTION/AVAILABILITY STATEME 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

Alsys, Inc., AlsyCOMP_058, Version 5.3, Wright-Patterson AFB, OH. Unisys B39 under BIOS II, v3.2.0 (Host & Target), 
ACVC 1.11. 


91-1|0|4 


14 SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


NSN 7540-01-280-550 


18. SECURITY CLASSIFICATION 

UNCLASSIFED 


19. SECURITY CLASSIFICATI 
OF ABSTRACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. LIMPTATION OF ABSTRACT 


Standard Form 298, (R«v. 2-89) 
Prescribed by ANSI Std. 239-128 

























AVF Control Number: AVF-VSR-500-0891 

26 August 1991 
91-04-22-ALS 


Ada COMPILER 
VALIDATIOJ SUMMARY REPORT: 
Certificate Number: 910809W1.11196 
Alsys, Inc. 

AlsyCOMP_058, version 5.3 
Unisys B39 under BTOS II, v3.2.0 *> 
Unisys B39 under BTOS II, v3.2.0 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 






4 r- 




Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 9 August 1991- 

Conpiler Name and Version; AlsyCCMP_058, version 5.3 

Host Coo^JUter System: Unisys B39 under BTOS II, v3.2.0 

Target Computer System: Unisys B39 mder BTOS II, v3.2.0 

Customer Agreement Number: 91-04-22-ALS 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
910809W1.11196 is awarded to Alsys, Inc. This certificate expires on 1 
June 1993. 


This report has been reviewed and is approved. 


Ada Validation Facility 
Steven P. Wilson 
Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


■ 

.Tv^rr _ 

itxon Organization 

Ccmjuter and Software Engineering Division 
for Defense Analyses 


, Ada VsHidatioh Organization 
Director,^-CcOT4juter and Softwar 
Institute for Defense Analyses 
Alexeuidria VA 22311 



Department of Defense 
Washington DC 20301 



DECLARATION OF CONFORMANCE 
CUSTOMER; Alsys, Inc. 

ADA VALIDATION FACILITY: Ada Validation Facility (ASD/SCEL) 

Computer Operations Division 
Information Systems and Technology Center 
Wright-Patterson AFB OH 45433-6503 

ACVC VERSION: 1.11 

ADA IMPLEMENTATION: 

COMPILER NAME AND VERSION: ALSYCOMP_058, version 5.3 

HOST COMPUTER SYSTEM: Unisys B39 

under BTOS II, v3.2.0 

TARGET COMPUTER SYSTEM: Unisys B39 

under BTOS II, v3.2.0 

CUSTOMER’S DECLARATION 


I, the undersigned, representing Alsys, Inc., declare that Alsys, Inc. has no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A in the implementation listed in this 


Date: S' 


George Ronanski, 
Vice-President, Engineering 
Alsys, Inc. 

67 South Bedford Street 
Burlington, MA 01803-5152 



1 






TABLE OF COJTENTS 


CHAPTER 1 INTRODUCTIC»I 

1.1 USE OF THIS VALIDATICW SUMMARY REPORT .1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITIC»« OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATiai DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS .2-1 

2.3 TEST MODIFICATIONS .2-4 

CHAPTER 3 PROCESSING INFORMATICS 

3.1 TESTING ENVIRCSMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTIOJ.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIOIS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 














CHAPTE31 1 


INTRODUCTION 


The Ada inplementation described eibove was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Stemdard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For euiy technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATIOJ SUMMARY REPORT 

Consistent with the national laws of the originating coxjntry, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the united States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the counters, operating systems, auid compiler versions identified 
in this report. 

The orgeinizations represented on the signature page of this report do not 
represent or warrauit that all statements set forth in this report are 
accurate eind conplete, or that the subject implementation has no 
nonconformities to the Ada Standard other them those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from; 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 






INTRODUCTiaa 


1.2 REFE31ENCES 

Reference Maniial for the Ada Programming Language, [Ada83] 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Ada Compiler Validation Procedures, Version 2.1, [Pro901 
Ada Joint Program Office, August 1990. 

Ada Compiler Validation Capability User's Guide, [UG89] 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test name identifies the class to 
which it belongs. Class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at compile time and link time, 
respectively. 

The executcible tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
cptimisations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal leinguage usage. Class 
B tests are not executable. Each test in this class is compiled cuid the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Stauidard involving multiple, separately compiled units. Errors 
are expected at link tiime, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in ^pendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 


INTRODUCTIW 


For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1), and 
possibly removing some inapplicable tests (see section 2.2 cuid [UG89]). 

In order to pass eui ACVC eui Ada implementation must process each test of 
the customized test suite according to the Ada Steuidard. 


1.4 DEFINITIC24 OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 
to a given host and target conputer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 
Capedaility user's guide eind the tenplate for the validation summary 

(ACVC) report. 

Ada An Ada conpiler with its host computer system eind its 

Implementation target computer system. 

Ada Joint The part of the certification body v4iich provides policy and 
Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body vrtiich carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Orgauiization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations cind logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 



INTRODUCTiai 


Conformity 


Customer 


Declaration of 
Conformance 


Host Con^juter 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process, or service of all 
requirements specified. 

An individual or corporate entity vdio enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system vdiere Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Orgcinization for Stcindardization. 

The Ada steindard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system \diere the executeible form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 





CHAPTER 2 


IMPLEMENTATIOI DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 


publication 

date for this 

list of withdrawn tests 

is 2 August 

1991. 

E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C8304LA 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inappliccible if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicadiility may 
be supported by documents issued by the ISO euid the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 



implementatioi dependencies 


Hie following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DrGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a predefined 
integer type with a name other than INTEGER, LCNG_INTEGER, or 
SHORT_INTEGER; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLQAT, or SHORT_FLQAT; for this 
inplementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
inplementation, MAX_MANTISSA is less thcui 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain length clauses 
that specify values for 'SMALL that are not powers of two or ten; this 
inplementation does not support such values for 'SMALL. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHlNEjOVERFLCWS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base 
type; for this inplementation, MACHINE_OVERFLCWS is TRUE. 

B86001y uses the name of a predefined fixed-point type other than type 
DURATIC»I; for this inpleraentation, there is no such type. 

C96005B uses values of type DURATIW's base type that are outside the 
reinge of type DURATION; for this implementation, the reinges are the 
same. 


CD1009C checks whether a length clause can specify a non-default size 
for a floating-point type; this implementation does not support such 
sizes. 

CD2A53A checks operations of a fixed-point type for which a length 
clause specifies a power-of-ten TYPE'SMALL; this inplementation does 
not support decimal 'SMALLs. (See section 2.3.) 

CD2A84A, aD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this implementation 
does not support such sizes. 


2-2 



IMPLEMENTATiai DEPENDENCIES 


BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this inplementation provides no package MACHINE_CODE. 

The following 16 tests check operations on sequential, direct, euid 
text files ^en multiple internal files are associated with the same 
external file and one or more are open for writing; USE_ERROR is 
raised when this association is attempted. 


CE2107B..E CE2107G..H CE2107L CD2110B CE2110D 
CE2111D CE2111H CE3111B CE3111D..E CE3114B 
CE3115A 

CE2111C checks whether a sequential file can be reset from mode 
IN_FILE to mode OUT_FILE; this implementation does not support this 
operation and raises USE_ERROR. 

CE2401H, EE2401D, eind EE2401G use instantiations of DIRECT_IO with 
unconstrained array eind record types; this implementation raises 
USE_ERROR on the attempt to create a file of such types. 

The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given 


combination of mode and access method; this implementation 
these operations. 

Test File Operation Mode File Access Method 

c:e2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

c:e2102f 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT_FILE 

DIRECT 10 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT_IO 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT 10 


The tests listed in the following table check the given file 
operations for the given combination of mode and access method; this 
implementation does not support these operations. 


2-3 




IMPLEMENTATIW DEPENDENCIES 


Test File Operation Mode File Access Method 


CE2105A CREATE IN_FILE SEQUENTIAL_IO 

CE2105B CREATE IN_FILE DIRECT_IO 

CE3109A CREATE IN FILE TEXT 10 


CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot restrict 
file capacity. 

CE3304A checks that SET_LINE___LENGTH and SET_PAGE_LENGTH raise 
USE_ERROR if they specify an Tnappropriate value for the external 
file; there are no inappropriate values for this inplementation. 

CE3413B checks that PAGE raises LAYOUT ERROR v^en the value of the 
page number exceeds COUNT'LAST; for this Tmplementation, the value of 
COUNT'LAST is greater them 150000, making the checking of this 
objective impractical. 

CE3202A expects that function NAME can be applied to the standard 
input and output files; in this inplementation these files have no 
names, and USE ERROR is raised. (See section 2.3.) 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 20 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the 
way expected by the original tests. 

B23004A B24007A B24009A B28003A B32202A B32202B 

B32202C B37004A B61012A B91004A B95069A B95069B 

B97103E BAllOlB BC2001D BC3009C 


BA2001E was graded passed by Evaluation Modification as directed by the 
AVO. The test expects that duplicate names of subunits with a common 
ancestor will be detected as compilation errors; this iirplementation 
detects the errors at link time, and the AVD ruled that this behavior is 
acceptable. 

EA3004D was graded passed by Evaluation cind Processing Modification as 
directed by the AVO. The test requires that either pragma INLINE is 
obeyed for a fvinction call in each of three contexts and that thus three 
library units are made obsolete by the re-compilation of the inlined 


2-4 





IMPLEMENTATiai DEPENDENCIES 


function's body, or else the pragma is ignored conpletely. This 
implementation obeys the pragma except when the call is within the package 
specification. When the test's files are processed in the given order, 
only two units are made obsolete; thus, the expected error at line 27 of 
file EA3004D6M is not valid and is not flagged. To confirm that indeed 
the pragma is not obeyed in this one case, the test was also processed 
with the files re-ordered so that the re-conpilation follows only the 
package declaration (and thus the other library units will not be made 
obsolete, as they are conpiled later); a "NOT APPLICABLE" result was 
produced, as expected. The revised order of files was 0-1-4-5-2-3-6. 

When run as is, the inplementation fails to detect an error on line 27 of 
test file EA3004D6M. This is because the pragma INLINE has no effect when 
its object is within a package specification. However, the results of 
running the test as-is do not confirm that the pragma had no effect, only 
that the package was not made obsolete. By re-ordering the conpilations 
so that the two siJibprograms are compiled after file D5 (the re-conpilation 
of the "with"ed package that makes the various earlier units obsolete), we 
create a test that shows that indeed pragma INLINE has no effect vdien 
applied to a si±program that is called within a package specification. 

The test must execute and produce the expected NOT_APPLICABLE result (as 
though INLINE were not supported at all). The recommended re-ordering of 
EA3004D test files is: 0-1-4-5-2-3-6. 

CD2A53A was graded inapplicable by Evaluation Modification as directed by 
the AVO. The test contains a specification of a power-of-10 value as 
'SMALL for a fixed-point type. The AVO ruled that, under ACVC 1.11, 
support of decimal 'SMALLs may be omitted. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies function NAME to the standard input file, 
which in this implementation has no name; USE_ERROR is raised but not 
hcindled, so the test is adaorted. The AVO ruled that this behavior is 
acceptcible pending ainy resolution of the issue by the ARC. 


2-5 







CHAPTER 3 


PROCESSING INFORMATIOI 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical auid sales information about this Ada implementation, contact: 

George Romanski, Vice-President, Engineering 
Alsys, Inc. 

67 South Bedford Street 
Burlington, MA 01803-5152 
(617) 270-0030 

Testing of this Ada inplementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Inplementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada In^jlementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Steindard. 


3-1 




PROCESSING INFORMATICS 


The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the implementation's maximum 
precision (item e; see section 2.2), and those that depend on the support 
of a file system — if none is supported (item d). All tests passed, 
except those that are listed in sections 2.1 and 2.2 (counted in items b 
and f, below). 


a) Total Number of ^plicable Tests 3792 

b) Total Number of Withdrawn Tests 95 

c) Processed Inappliceible Tests 82 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 283 


g) Total Number of Tests for ACVC 1.11 4170 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto a VAX system (from a standard 1/2 
inch, 9-track VMS BACKUP tape) and then transferred to the Unisys B39 via 
ethernet. 

After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada inplementation. 

The tests were conpiled, linked, and executed on the host computer system, 
as appropriate. The results were captured on the computer system. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See i^pendix B for a complete listing of 
the processing options for this inplementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were; 


Cottpiler Options: 


TEXT *> 

NO 

Do not show source code in listing 
(used for all but the B tests) 

TEXT => 

YES 

Show source code in listing 
(used for the B tests) 


3-2 



PROCESSING INFORMATICS 


SHCW -> NO 

WARNING -> NO 
ERRORS •> 999 

CALLS -> INLINED 

GENERICS => STUB 


Do not show header nor error svttmnary in 
listing. 

Do not include warning messages. 

HeociiRuro number of compilation errors 
permitted before terminating the compilation. 

This option allows insertion of code for 
subprograms inline and must be set for the 
pragma INLINE to be operative. 

This option places code of generic 
insteintiations in separate subunits. 


The default options were used for all binds. 

Test output, conpiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meeining cind purpose of these parameters are explained in [UG89]. Itie 
parameter values are presented in two tadales. The first table lists the 
values that are defined in terms of the naximum input-line length, v^ich is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V represents the maucimum input-line 
length. 


Macro Parameter 

Macro Value 


$MAX_IN_LEN 

255 


$BIG_ID1 

(1..254 -> 'A', 255 -> '1') 


$BIG_ID2 

(1..254 -> 'A', 255 -> '2') 


$BIG_ID3 

(1..127 => 'A') & '3' & (1..127 -> 

'A') 

$BIG_ID4 

(1..127 -> 'A') & '4' & (1..127 -> 

'A') 

$BIG_INT_LIT 

(1..252 => '0') & "298" 


$BIG_REAL_LIT 

(1..250 => '0') & "690.0" 


$BIG_STRING1 

& (1..127 -> 'A') & 


$BIG_STRING2 

& (1..127 -> 'A') & '1' & 


$BLANK5 

{1..235 => ' ') 


$MAX_LEN_INT_BASED_ 

LITERAL 

"2:" & (1..250 -> '0') & "11:" 



$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..248 -> '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..253 => 'A') & 


A-1 





MACRO PARAMEMERS 


The following table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 


$ACC_SIZE 

32 

$ALiaJMENT 

2 

$COUNT_LAST 

2147483647 

$DEFAULT_MEM_SIZE 

2**24 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

180X86 

$DELTA_DOC 

2#1.0#E-31 

$ENTRY_ADDRESS 

FCNDECL.ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

FCNDECL.ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

FCNDECL.ENTRY_ADDRESS2 

$FIELD_LAST 

255 

$FILE_TERMINATOR 

t f 

$FIXED_NAME 

NO_SUCH_FIXED_TyPE 

$FLQAT_NAME 

NO_SUCH_FLQAT_TYPE 

$FORM_STRING 

tf If 

$FORM_STRING2 

"CANNOT_RESTRICT_FILEj 

$GREATER THAN DURATIC»I 

75_000.0 

SGREATER THAN DURATICX^ BASE LAST 

T31_073.0 


$GREATER_THAN_FLQAT_aASE LAST 

1 .TyE+39 

$GREATER_THAN_FLCIAT_SAFE LARGE 

1 .^E+38 


A-2 




MACRO PARAMETERS 


SGREATER THAN_SHORT_FLQAT_SAFE_LARGE 

l.OE+38 

$HI(2i_PRI0RITir 10 

$ILLEGAL_EXTERNAL_FILE NAMEl 

TSYS]<NODIRECTORY>FILENAME 

$IIl£GAL_EXrERNAL_FILE_NAME2 

THIS-FILE-NAME-IS-NCW-MUCH-TOO- 

LCMJ-FOR-A-NAME-C^I-MY-SYSTEM 

$INAPPROPRIATE_LINE_LENGTH 

-1 

$INAPPROPRIATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAOIA INCLUDE ("A28006D1.TST") 

$INCLUDE_PRAGMA2 PRAffllA INCLUDE ("B28006D1.TST") 

$INTEGER_FIRST -32768 

$INTEGER_LAST 32767 

$INTEGER_LAST_PLUS_1 32768 

$INTERFACE_LANGUAGE ADA 

$LESS_THAN_DURATI(»I -75_000.0 

$LESS THAN DURATIOTJ BASE FIRST 

-131_073,0 

$Lir^_TERMINATOR ASCII.CR & ASCII.LF 

$LCW_PRIORITY 1 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2_147_483_648 

$MIN_INT -2147483648 


A-3 




MACRO PARAMETERS 


$NAME 

NO_SUCH_TYPE_AVAILABLE 

$NAME_LIST 

S370,180X86,i80386,MC680X0,VAX 
TRANSPUTER,RS_6000,MIPS 

$NAME_SPECIFICATIC»I1 

[SYS1<CE>X2120A 

$NAME_SPECIFICATI(»I2 

[SYS1<CE>X2120B 

$NAME_SPECIFICATI(»I3 

[SYS]<CE>X3119A 

$NEG_BASED_INT 

16#F000000E# 

$NEW_MEM_SI2E 

2**24 

$NEW_STOR_UNIT 

16 

$N04_SyS_NAME 

180X86 

$PAGE_TERMINATOR 

ASCII.CR & ASCII.LF & ASCII.FF 

$RECORD_DEFINITiaJ 

NEW INTEGER 

$RECORD_NAME 

NO_SUCH_MACHINE_CODE TYPE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

1024 

$TICK 

0.1 

$VARIABLE_ADDRESS 

FCNDECL.VAR1ABLE_ADDRESS 

$YARIABLE_ADDRESS1 

FCNDECL.VARLABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

FCNDECL. VARU^LE_ADDRESS2 

$YOUR PRAGMA 

INTERFACE 


A-4 






APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
^pendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 

Compiler Options: 

COMPILE (SOURCE -> source_name | INSTANTIATICW, 

LIBRARY -> library_na»e, 

OPTIWS -> 

(ANNOTATE «> character string, 

ERRORS *> positive_Tnteger, 

LEVEL -> PARSE | SEMANTIC | CODE | UPDATE, 

CHECKS => ALL | STACK | NC»JE, 

GENERICS -> STUBS | INLINE, 

TASKING -> YES | NO, 

MEMORY => number_of_kbytes), 

DISPLAY -> 

(OUTPUT -> SCREEN | NONE | AUTOMATIC | file_name, 

WARNING -> YES | NO, 

TEXT -> YES I NO, 

SHOW -> BANNER | RECAP | ALL | NONE, 

DETAIL «> YES 1 NO, 

ASSEMBLY =-> CODE | MAP | ALL ] NCWE), 

ALLOCATION -> 

(STACK => positive_integer, 

GLOBAL => positive_integer), 

IMPROVE => 

(CALLS «> NORMAL | INLINED, 

REDUCTION -> NONE 1 PARTIAL | EXTENSIVE, 

EXPRESSIONS -> NONE j PARTIAL j EXTENSIVE), 

KEEP -> 

(COPY »> YES I NO, 

DEBUG -> YES | NO, 

TREE -> YES ! NO)); 


B-1 





COMPILATIOI SYSTEM OPTIOIS 


OPTIOJ/SWITCH 


EFFECT 


SOURCE 

LIBRARY 

ANNOTATE 

ERRORS 

LEVEL 

CHECKS 

GENERICS 

TASKING 

MEMORY 

OUTPUT 

WARNING 

TEXT 

SHCW 

DETAIL 

ASSEMBLY 

STACK 

GLOBAL 

CALLS 

REDUCTICN 

EXPRESSIC»JS 

COPY 

DEBUG 

TREE 


“> source_naine | INSTANT1ATIC»I Name of source file. 

-> library_name Name of program library. 

«> character_string Comment string for library 

addition. 

-> positive_integer Abort compilation after co\ant 

of errors. 

-> PARSE I SEMANTIC | CODE | UPDATE Specify level of 


-> ALL 1 STACK | NCXJE 

-> STUBS 1 INLINE 

-> YES I NO 
-> number_of_kbytes 

*> SCREEN 1 NOSIE | AUTCMATIC | 
-> YES I NO 
-> YES I NO 

-> BANNER 1 RECAP ( ALL | NONE 
-> YES 1 NO 

-> CODE I MAP I ALL | NC»IE 

=> positive_integer 

*> positive_integer 

-> NORMAL I INLINED 

-> NONE 1 PARTIAL | EXTENSIVE 

-> NONE I PARTIAL | EXTENSIVE 

-> YES I NO 

-> YES I NO 

»> YES I NO 


conpilation. 

Specify v^ich compilation 
checks to be done. 

Specifies where expansion of 
generic instantiation are. 

Skip Optimization for tasking? 
Sizes internal conpiler work 
area. 

file_name Directs the output 
Generate warning messages? 
Include full source text in 
listing? 

Specify beuiner and error 
siammary display. 

Generate detailed diagnostics? 
Controls listings of generated 
code and data layout. 

Controls run-time location of 
stack data. 

Controls runtime location of 
global data. 

Activates pragma inline. 
Controls high level optimizer. 
Controls low level optimizer. 
Copy source text to library? 
Save debug info in library? 
Save intermediate program 
representation? 





COMPILATION SYSTEM OPTIOIS 


LINKED OPTIONS 

The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and not 
to this report. 


Binder Options: 

BIND (PROGRAM => main_program_name, 

LIBRARY => library_name, 

OPTICMS -> 

(LEIVEX -> CHECK | BIND | LINK, 

EXECUTIC»r -> AUTOMATIC | DYNAMIC | PROTECTED, 
OBJECT -> AUTOMATIC j file_name, 

UNCALLED => REMOVE | KEEP, 

TIMER => NORMAL j FAST, 

SLICE => NO I positive_integer), 

STACK *> 

(MAIN *> positive_integer, 

TASK => positive_integer, 

HISTORY «> YES | NO), 

HEAP *> 

(SIZE *> positive_integer, 

INCREMENT => positive_integer), 

INTERFACE => 

(DIRECTIVES -> options_for_linker, 

MODULES -> file_names, 

SEARCH -> library_names), 

DISPLAY -> 

(OUTPUT => SCREEN | NONE | AUTOMATIC | file_name, 

DATA => BIND | LINK | ALL | NC»IE, 

WARNING => YES I NO), 

KEEP => 

(DEBUG => YES | NO)); 


B-3 





COMPILATiaa SYSTEM OPTICAS 


OPTIC»J/SWITCH 


EFFECT 

PROGRAM 

-> 

main_program_naine 

Ada name of main subprogram. 

LIBRARY 

-> 

library name 

Name of program library. 

LEVEL 

-> 

CHECK 1 BIND I LINK 

Specify level of bind. 

EXECUTIC»I 

«> 

AUTOMATIC 1 DYNAMIC | PROTECTED Controls use of dynamic 

loader. 

OBJECT 

-> 

AUTOMATIC 1 file name 

Name of object module. 

UNCALLED 

=> 

REMOVE 1 KEEP 

Removes or keeps uncalled 
sijbprograms. 

SLICE 

=> 

NO 1 positive integer 

Define time-slice. 

MAIN 

=> 

positive integer 

Size of main stack. 

task 

-> 

positive integer 

Size of task stack. 

HISTORY 

-> 

YES 1 NO 

Generate stack traces for 
unhcuidled exceptions? 

SIZE 

-> 

positive_integer 

Size the initial heap 
allocation. 

INCREMENT 

-> 

positive_integer 

Size s\ibsequent heap 
allocations. 

DIRECTIVES 

-> 

options for linker 

Supplies linker directives. 

MODULES 

«> 

file_names 

Additional object mod\iles. 

SEARCH 

-> 

library names 

Additional object libraries. 

OUTPUT 

=> 

SCREEN T none | AUTOMATIC | 

file_name Location of 

binder listing. 

DATA 

=> 

BIND 1 LINK 1 ALL | NONE 

Amount of data to be 
included in binder listings. 

WARNING 

-> 

YES 1 NO 

Generate warning messages? 

DEBUG 

-> 

YES 1 NO 

Generate debug information? 


B-4 





APPEM)IX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Stzmdard, and to certain allowed 
restrictions on representation clauses. The inplementation-dependent 
characteristics of this Ada inplementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler doojmentation and not to this 
report. In^lementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are; 


package STANDARD is 

type INTEGER is range -32_768..32_767; 

type FLOAT is digits 6 rauige 

-2#1.111 1111 1111 1111_1111_1111#E+127.. 

2#1.111~1111_1111_1111_1111_1111#E+127; 

type DURATION is delta 2#0.000_000_000_000_01# range 
-131072.00000..131071.99994; 

type SHORT_INTEGER is range -128..127; 

type LCM3_INTEGER is range -2_147_483_648. .2_147_483_647; 

type SHORT FLOAT is digits 6 range 

-2#1.11T 1111_1111_1111_1111_1111#E+127 .. 

2#1.111_1111_1111_1111_1111_1111#E+127; 

type LCM3 FLOAT is digits 15 range 

-2#1.1111_111T_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111#E+1023 
2#1.1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111#E+1023; 


end STANDARD; 


C-1 






Copyright 1991 by Alsys 


All rights reserved. No part of this document may be reproduced in any form or by any 
means without permission in writing from Alsys. 


Printed: May 1991 

Alsys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice. Consult Alsys to determine 
whether such changes have been made. 


Alsys. AdaWortd. AdaProbe. AdaXref, Ada Reformat. AdaMake. AdaVerify, AdaCount. and 
AdaSplii are registered trademarks of Alsys. 

INTEL is a registered trademark of Intel Corporation. 



TABLE OF CONTENTS 


appendix F 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

13 INTERFACE_NAME 

1.4 INDENT 

1.5 Other Pragmas 


2 Implementation-Dependent Attributes 

2-1 P’IS.ARRAY 

2.2 FEXCEPTION_CODE 

23 Attributes Used in Record Represenution Clauses 


3 Specification of the package SYSTEM 


4 Support for Representation Oauses 


15 


4.1 Enumeration Types 

4.1.1 Enumeration Literal Encoding 

4.1.2 Enumeration Types and Object Sizes 

4.2 Integer Types 

4.2.1 Integer Type Representation 

4.2.2 Integer T^ and Objea Size 
43 Floating Point Types 

43.1 Floating Point Type Representation 

43.2 Floating Point T^ and Object Size 
4.4 Fixed Point Types 

4.4.1 Fixed Point Type Representation 

4.4.2 Fixed Point T^ and Object Size 


16 

16 

16 

18 

18 

18 

20 

20 

21 

21 

21 

22 


Table of Contents 


I 




4.5 Access Types and Collections 24 

4.6 Task Types 24 

4.7 Array Types 25 

4.7.1 Array Layout and Structure and Pragma PACK 25 

4.7.2 Array Subtype and Object Size 28 

4.8 Record Types 29 

4.8.1 Basic Record Structure 29 

4.8.2 Indirect Components 31 

4.83 Implicit Components 34 

4.8.4 Size of Record Types and Objects 38 

5 Conventions for Iniplementation>Generated Names 39 

6 Address Clauses 41 

6.1 Address Gauses for Objects 41 

6.2 Address Causes for Program Units 42 

7 Unchecked Conversions 43 

8 Input-Output Packages 45 

8.1 Correspondence between External Files and CTOS Files 45 

8.2 Error Handling 46 

8.3 Sequential Files 46 

8.4 Direa Files 46 

8.5 Text Files 46 

8.6 Access Protection of External Files 48 

8.7 The Need to Cose a File Explicitly 48 

8.8 Limiution on the Procedure RESET 48 

8.9 Sharing of External Files and Tasking Issues 48 

9 Characteristics of Numeric Types 49 

9.1 Integer Types 49 

a 


Appendix F, Version 5 



9.2 Floating Point T^pe Attributes 
93 Attributes of DURATION 


10 Other Implementation-Dependent Characteristics 

10.1 Charaaeristics of the Heap 

10.2 Characteristics of Tasks 

10.3 Definition of a Main Subprogram 

10.4 Ordering of Compilation Units 


11 Limitations 

11.1 Compiler Limitations 

11.2 Hardware Related Limitations 


INDEX 


Table of Contents 






IV 


Appendix F, Version 5 








APPENDIX F 


Implementation • Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys 
Ada Software Development Environment for BTOSIL Appendix F is a required part of 
the Reference Manual far the Ada Programming Language (c^ed the RM in this 
appendix). 

The seaions of this appendix are as follows: 

1. The form, allowed places, and eHect of every implementation-dependent pragma. 

2. The name and the type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The description of the representation clauses. 

5. The conventions used for any implementation-generated name denoting im- 
plemenution-dependent components. 

6. The interpretation of expressions that appear in address clauses, including those 
for interrupts. 

7. Any restriaions on unchecked conversions. 

8. Any implementation-dependent charaaeristics of the input-output packages. 

9. Characteristics of numeric types. 

10. Other implementation-dependent charaaeristics. 

11. Compiler limitations. 


Implemeruation-Dependent Characteristics 


1 



The nuatAJsys Runtime Executive Programs or simply Runtime Executive refers to the 
runtime library routines provided for all Ada programs. These routines implement the 
Ada heap, exceptions, tasking control, and other utility functions. 

General systems programming notes are given in another document, the Application 
Developer's Guide (for example, parameter passing conventions needed for interface with 
assembly routines). 


2 


Appendix F, Version 5 


Section 1 


Implementation-Dependent Pragmas 


1.1 INLINE 

Pragma INLINE is fully supported; however, it is not possible to inline a subprogram in a 
declarative part 


1.2 INTERFACE 

Ada programs can interface with subprograms written in Assembler and other languages 
through the use of the predefined pragma INTERFACE and the implemenution-defined 
pragma INTERFACE_NAME 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of 
the programming language for which parameter passing conventions will be generated. 
Pragma INTERFACE takes the form specified in the RM: 

pragma INTERFACE (languagejtame,subprogiumjuime); 

where, 

> languagejiame is ASSEMBLER or ADA 

■ subprogram jiame is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language names accepted by pragma INTERFACE are ASSEMBLER or ADA 
The full implementation requirements for writing pragma INTERFACE subprograms are 
described in the Application Developer s Guide. 

The language name used in the pragma INTERFACE does not have to have any 
relationship to the language aaually used to write the interfaced subprogram. It is used 
only to tell the Compiler how to generate subprogram calls; that is, what kind of 
parameter passing techniques to use. The programmer can interface Ada programs with 
subroutines written in any other (compiled) language by understanding the mechanisms 


Implementation-Dependent Pragmas 


3 



used for parameter passing by the compiler and the corresponding mechanisms of the 
chosen external language. 


13 INTERFACE_NAME 

Pragma INTERFAC£_NAME associates the name of the interfaced subprogram with the 
external name of the interfaced subprogram. If pragma INTERFACE_NAM£ is not used, 
then the two names ate assumed to be identical. This pragma takes the form: 

pragma INTERFACE_NAME {subprogram jume, stringjiteral); 

where, 

. subprogram jume is the name used within the Ada program to refer to the 
interfaced subprogram. 

• stringjiteral is the name by which the interfaced subprogram is referred to at link 
time. 

The pT3gjna 1NTERFACE_NAM£ is used to identify routines in other languages that are 
not named with legal Ada identifiers. Ada identifiers can only contain letters, digits, or 
underscores, whereas the BTOS II Linker allows external names to contain other 
charaaeis, for example, the dollar sign ($) or commercial at sign (@). These charaaers 
can be specified in the stringjiteral argument of the pragma INTERFACE_NAM£. 

The pragma INTERFACE.NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE. (Lotion restrictions can be found in section 13.9 of the RM.) 
However, the pragma INTERFACE_NAME must always occur after the pragma 
INTERFACE declaration for the interfaced subprogram. 

The stringjiteral of the pragma INTERFACE_NAME is passed through unchanged to the 
BTOS n objea file. The maximum length of the stringjiteral is 40 charaaers. This limit 
is not checked by the Compiler, but the string is truncated by the Binder to meet the 
Intel objea module format standard. 

The user must be aware however, that some tools from other vendors do not fully 
support the sundard Intel objea file format and may restria the length of symbols. For 
example, the Microsoft assemblers silently truncate symbols at 31 charaaers. 

The Runtime Executive contains several external identifiers. All such identifiers begin 
with either the string *ADA@'' or the string ’ADAS@*. Accordingly, names prefixed by 
"ADA®" or "ADAS®* should be avoided by the user. 


4 


Appendix F, Version 5 





Example 


package SAMPL£_DATA is 

function SAMPLE_DEVICE (X: INTEGER) return INTEGER; 
function PROCESS_SAMPLE (X: INTEGER) return INTEGER; 
private 

pragma INTERFACE (ASSEMBLER, SAMPLE_DEVICE); 
pragma INTERFACE (ADA, PROCESS.SAMPLE); 

pragma INTERFACE_NAME (SAMPLE_DEVICE, T>EVIOSGET,SAMPLE'); 
end SAMPLE_DATA; 


1.4 INDENT 

Pragma INDENT is only ased 'NixhAdaReformat. AdaReformat is the Alsys refonnatter 
which offers the ^ .onalities of a pretty-printer in an Ada environment. 

The pragm' i-i 'aced in the source file and interpreted by the Refonnatter. The line 

pragma INDENT(OFF); 

(si'jse& AdaReformat not to modify the source lines after this pragma, while 
pragma INDENT(ON); 

CZMSCS AdaReformat to resume its action after this pragma. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the seaion on representation 
clauses and records (Chapter 4). 

Pragma PRIORITY is accepted with the range of pnorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Section 3). Undefined priority (no 
pragma PRIORITT) is treated as th«jugh it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress all checks in a given compi¬ 
lation by the use of the Compiler option CHECKS. (See Chapter 4 of the User’s Guide.) 


Implementation-Dependent Pragmas 


5 




6 


Appendix F, Version 5 







Section 2 


Implementation-Dependent Attributes 


2.1 P’IS_ARRAY 

For a prefix P that denotes any type or subtype, this attribute yields the value TRUE if P 
is an array type or an array subtype; otherwise, it yields the value FALSE. 

2.2 E’EXCEPnON_CODE 

For a prefix E that denotes an exception name, this attribute yields a value that 
represents the internal code of the exception. The value of this attribute is of the type 
INTEGER. 


23 Attributes Used in Record Representation Clauses 

In addition to the Representation Attributes of [13.7.2] and [13.73], the following 
attributes are used to form names of indirect and implicit components for use in record 
represenution clauses, as described in Section 4.8. 

'OFFSET 

'RECORD.SIZE 

•varianiFindex 

’ARRAY_DESCRIPTOR 

’RECORD_DESCRIPTION 


Implementation-Dependent Atrribuies 


7 







8 


Appendix F, Version 5 







Section 3 


Speciflcation of the package SYSTEM 


The implementation does not allow the recompilation of package SYSTEM. 


package SYSTEM ia 


(1) Required Definitions. 


type NAME is (180X86); 

SrSTEM.NAME .* constant NAME :« )80X86; 

STORAGE.UNIT : constant :« 8; 

MEM(»Y_SIZE : constant :■ 2**24; 

*• Systeai-Dependent Naned Numbers: 

MAX_INT ; constant :» 2»*31 - 1; 

MIH_INT : constant * <2**31); 

MAX_MANTISSA : constant :> 31; 

FINE_DELTA ; constant := 2#1.0(l(e'31; 

MAX_0IGITS : constant IS; 

-- For the high-resolution timer, the clock resolution is 
" 1.0 / 1024.0. 

TICK : constant :« 0.1; 


Specification of the package SYSTEM 


9 







-- other SystCMfOependent Declarations: 
subtype PRIORITY is INTEGER range 1 .. 10; 

-- The type ADDRESS is, in fact, iaplenented as a 
-- seg^-^t:offset pair, 
type ADDRESS is private; 

NULL ADDRESS : constant ADDRESS; 


* (2) Operations on Address • 


•• VALUE converts a string to an address. The syntax of the string and its 
meaning are target dependent. 

-• For the S086, 80186 and 80286 the syntax is: 

•• "SSSSrOOOO* where SSSS and OOOO are a 4 digit or (ess hexadecimal 
*- nutter representing a segment value and an offset. 

*■ The physical address corresponding to SSSS:0000 dependents 

on the execution mode. In reel mode it is 16*SSSS+OOQO. 

In protected mode the value sSSS represents a segaent 
-- descriptor. 

-• Example: 

-- "0014:00F0" 


-• The exception CONSTRAINT_ERROR is raised if the string does not have 
-- the proper syntax. 

function VALUE (LEFT : in STRING) return ADDRESS; 


10 


Appendix F, Version 5 




•• IMAGE converts an address to a string. The syntax of the returned string 
is described in the VALUE function. 

subtype AODRESS_STRING is STRIMG(1..9>; 

function IMAGE (LEFT : in ADDRESS) return ADDRESS_STR1NG; 


*■ SAME_SEGMEMT returns true if the two addresses have 
** the sane segment value. 

function SAME_SEGMENT (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

■■ The following routines provide support to perform address 
-- computation. For the and operators the OFFSET parameter 
•• is added to, or subtracted from the offset part of the address, 
•• the segment remaining untouched. 

type OFFSET is range 0 .. -1; 

•• The exception AOORESS_ERROR is raised by "<", ">»•*, 

•* if the two addresses do not have the same segment value. 

-- The exception CONSTRAINT_ERROR can be raised by and 

AOORESS_ERROR : exception; 

function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

function (LEFT : in OFFSET; RIGHT ; in ADDRESS) return ADDRESS; 

function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 


Specification of the package SYSTEM 


11 





•• The exception ADORESS.ERROS is raised if the two addresses do 
not have the sasK aegmsnt valua. 

function •••■• (LEFT : in ADDRESS; RIGHT : in ADDRESS) return OFFSET; 

-- Perform an unsigned conparison on offset part of addresses. 

function «<*•• (LEFT. RIGHT : in ADDRESS) return BOOLEAN; 

function <•<" (LEFT. RIGHT : in ADDRESS) return BOOLEAN; 

function (LEFT. RIGHT : in ADDRESS) return BOOLEAN; 

function »>" (LEFT. RIGHT : in ADDRESS) return BOOLEAN; 

function ••mod" (LEFT : in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


•* Returns the given address rounded to a specific value. 


type RaUNO_OIRECTION is (DOWN. UP); 

function ROUND (VALUE : in ADDRESS; 

DIRECTION : in ROUW.DIRECTION; 

MODULUS : in POSITIVE) return ADDRESS; 


-• These routines are provided to perform REAO/URITE operation 
-- in mesnry. 

-- Warning: These routines will give unexpected results if used with 
-- unconstrained types. 

generic 

type TARGET is private; 

ftfKtion FETCH_FROM_AODRESS (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASSIGN_TO_ADDRESS (A : in ADDRESS; T : in TARGET); 


12 


Appendix F, Version 5 





-■ Procadur* to copy LENGTH storage unit starting at the address 
•• FROM to the address TO. The source and destination may overlap. 
-- OBJECT_LENGTH designates the size of an object in storage units. 

type 08JECT_LENGTH is range 0 .. 2**16 -1; 
for OeJECT_LENGTH<SIZE use 16; 

procedure HOVE (TO : in ADDRESS; 

FROM : in ADDRESS; 

LENGTH : in OBJECT_LENGTH); 

private 


end SYSTEM; 


Specification of the package SYSTEM 


13 





14 


Appendix F, Version 5 







Section 4 


Support for Representation Clauses 


This seaion explains how objects are represented and allocated and how it is possible to 
control this using representation clauses. Applicable restriaions on representation 
clauses are also described. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is described. 

Except in the case of array and record types, the description for each class of type is 
independent of the others. To understand the representation of array and record types it 
is necessary to understand first the representation of their components. 

Apan from implementation defined pragmas, Ada provides three means to control the 
size of objects; 

• a (predefined) pragma PACK, applicable to array types 

■ a record representation clause 

■ a size specification 

For each class of types the effect of a size specification is described. Interaaions among 
size specifications, packing and record representation clauses is described under the 
discussion of array and record types. 

Representation clauses on derived record types or derived tasks types are not supported. 

Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


Support for Represenrarion Clauses 


15 






4.1 Enumeration Types 


4.1.1 Enumeration Literal Encoding 

When no enumeration representation clause applies to an enumeration type, the 
internal code associated with an enumeration literal is the position number of the 
enumeration literal Then, for an enumeration type with n elements, the internal codes 
are the integers 0,1,2,... n-1. 

An enumeration representation clause can be provided to specify the value of each 
internal code as described in RM 133. The Al^ compiler f^ implemenu enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -2^^ _ 2^^-l. 

An enumeration value is always represented by its internal code in the program 
generated by the compiler. 


4.1.2 Enumeration Types and Object Sizes 

Minimum size of an auuimntionsabtypt 

The minimum possible size of an enumeration subtype is the minimuni number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form. 

A static subtype, with a null range has a minimum size of 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m > » 0, L is the 
smallest positive integer such that M < » 2^-1. For m < 0, L is the smallest positive 
integer such that -2^*^ < * m and M < a 2^’*-l. For example: 

type COLOR is (GREEN, BLACK, WHITE, RED, BLUE, YELLOW); 

-> The minimum size of COLOR is 3 bits. 

subtype BLACK,AND_WHITE is COLOR range BLACK.. WHITE; 

- The minimum size of B1ACK^AND_WHITE is 2 bits. 


16 


Appendix F, Version 5 






subtype BLACK_OR_WHITE is BLACK_AND_WHITE range X.. X; 

- Assuming that X is not static, the minimum size of BLACK.OR.WHTTE is 

- 2 bits (the same as the minimum size of its type mark BLACK.AND.WHTTE). 


Size of an enumeration subtype 

When no size specification is applied to an enumeration type or first named subtype, the 
objects of that type or first named subtype are represented as signed machine integers. 
The machine provides 8,16 and 32 bit integers, and the compiler selects automatically 
the smallest signed machine integer which can hold each of the internal codes of the 
enumeration type (or subtype). The size of the enumeration type and of any of its 
subtypes is thus 8,16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type EXTENDED is 

(•> The usual ASQl character set. 

NUL, SOH, STX, ETX, EOT, ENQ, ACK, BEL, 

X y. X T. DEU 
- Extended characters 

C_CEDIL1A_CAP. U^UMLaUT, E.ACUTE, ...); 
for EXTENDED’SIZE use 8; 

- The size of type EXTENDED will be one byte. Its objects will be represented 

- as unsigned 8 bit integers. 

The Alsys compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 


Size of the objects of an enumeration subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an enumeration subtype has the same size as its subtype. 


Support for Representation Clauses 


17 






4.2 Integer Types 

There are three predefined integer types in the Alsys Ada Software Development 
Environment for BTOSII implementation: 

type SHORT_INTEGER is range -2**07.. 2**07-l; 

type INTEOro is range -2**15.. 2**15-1; 

type LONG_INTEGER U range-2**31.. 2**31-1; 


4.2.1 Integer Type Representation 
An integer type declared by a declaration of the form: 
type T is range L.. R; 

is implicitly derived from a predefined integer type. The compiler automatically selects 
the predefteed integer type whose range is the smallest that contains the values L to R 
inclusive. 

Binary code is used to represent integer values. Negative numbers are represented using 
two’s complement 


4.2.2 Integer Type and Object Size 

Minimum size of an integer nUttype 

The minimum possible size of an integer subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binaiy 
form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > * 0, L is the smallest positive integer such that M < = 2^*^ For m < 
0, L is the smallest positive integer that -2^'^ < » m and M < » 2^'^-l. For example: 

subtype S is INTEGER range 0.. 7; 

- The minimum size of S is 3 bits. 


18 


Appendix F, Version 5 




subtype D is S range X.. Y; 

- Assuming that X and Y are not static, the minimum size of 

- D is 3 bits (the same as the minimum size of its type mark S). 


Size of an integer subtype 

The sizes of the predefined integer types SHORT_INTEGER, INTEGER and 
LONG_INTEGER are respectively 8,16 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, direaly or indirectly. For example: 

type S is range 80.. 100; 

-- S is derived from SHORT_INTEGER, its size is 8 bits, 
type J is range 0.. 255; 

- J is derived from INTEGER, its size is 16 bits, 
type N is new J range 80.. 100; 

- N is indirectly derived from INTEGER, its size is 16 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is range 80.. 100; 
for S’SIZE use 32; 

- S is derived from SHORT_lNTEGER, but its size is 32 bits 
~ because of the size specification. 

type J is range 0.. 255; 
for J’SIZEuseS; 

- J is derived from INTEGER, but its size is 8 bits because 

- of the size specification. 

type N is new J range 80.. 100; 

~ N is indirealy derived from INTEGER, but its size is 
~ 8 bits because N inherits the size specification of J. 


Support for Representation Clauses 


19 






Size of the objects of an integer subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an integer subtype has the same size as its subtype. 


4.3 Floating Point Types 

There are three predefined floating point types in the Alsys implemeniatior. for IS0xS6 
machines: 

type SHORT_FLOAT is 

digits 6 range -(2.0 - 2.0**(-23))*2.0**127.. (2.0 - 2.0**(-23))*2.0**127; 
type FLOAT is 

digits 6 range -(2.0 - 2.0**(.23))*2.0**127.. (2.0 - 2.0**(-23))*2.0**127; 
type LONG_FLOAT is 

digits 15 range -(2.0 - 2.0**(-52))*2.0**1023.. (2.0 - 2.0**(-52))*2.0**1023; 
Note that SHORT_FLOaT has the same range as FLOAT. 


43.1 Floating Point Type Representation 
A floating point type declared by a declaration of the form: 
type T is digits D [range L.. Rj; 

is implicitly derived from a predefined floating point type. The compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L to R inclusive. 

In the program generated by the compiler, floating point values are represented using 
the IEEE standard formats for single and double floats. 

The values of the predefined types SHORT_FLOAT and FLOAT are represented using the 
single float format. The values of the predefined type LONG_FLOATare represented 
using the double float format. The values of any other floating point type are represented 
in the same way as the values of the predefined type from which it derives, directly or 
indirectly. 


20 


Appendix F, Version 5 



432 Floating Point T^pe and Object Size 

The minimum possible size of a floating point subtype is 32 bits if its base type is 
SHORT_FLOAT or FLOAT or a type derived from SHORT_FLOAT or FLOAT; it is 64 bits 
if its base type is LONG_FLOAT or a type derived from LONG_FLOAT. 

The sizes of the predefined floating point types SHORT_FLOAT and FLOAT is 32 bits 
and LONG_FLOAT is 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirealy. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32 or 64 bits). 

An objea of a floating point subtype has the same size as its subtype. 


4.4 Fixed Point T^pes 


4.4.1 Fixed Point Type Representation 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by RM 3.5.9. 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

To implement fixed point types, the Alsys Ada Software Development Environment for 
BTOS II uses a set of anonymous predefined types of the form: 

type SHORT_FIXED Is delta D range (-2.0**7.1)*S.. 2.0**7*S; 
for SHORT^roCED’SMALL use S; 

type FIXED is delta D range (-2.0**15-1)*S.. 2.0**15*S; 
for FIXED’SMALL use S; 

type LONG_FIXED is delta D range (-2.0**31-1)‘S.. 2.0**31*S; 
for LONG.FIXED’SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 


Support for Representation Clauses 


21 




A fixed point type declared by a declaration of the form: 


type T is delta D range L ~ R; 

possibly with a small specification: 
for TSMALL use S; 

is implicitly derived from a predefined fixed point type. The compiler automatically 
selects the predefined Hxed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L to R inclusive. 

In the program generated by the compiler, a safe value V of a fixed point subtype F is 
represented as the integer 

V/FBASE’SMALL 


4.4.2 Fixed Point T^pe and Object Size 
Minimum size of a fixed point subtype 

The minimum possible size of a fixed point subtype is the minimum number of binary 
digits that is necessary for representing the values of the range of the subtype using the 
small of the base type. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S being 
the bounds of the subtype, if i and I are the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
thpn the minimum size L is determined as follows. For i > * 0, L is the smallest positive 
iiitejger si:ch that I < s 2^'^ For i < 0, L is the smallest positive integer such that - 
2^*“<=iandI<=2^*U. 

type F is delta 2.0 range 0.0.. 500.0; 

- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0.. 250.0; 

- The minimum size of S is 7 bits. 

subtype D is S range X » Y; 

~ Assuming that X and Y are not static, the minimum size of D is 7 bits 

- (the same as the minimum size of its type mark S). 


22 


Appendix F, Version 5 





Size of a fixed point subtype 

The sizes of the predefined fixed p jint types SHORT_FIXED, FIXED and LONG_FIXED 
are respectively 8,16 and 32 bits. 

When no size specification is applied to a Hxed point type or to its first named subtype, 
its size and the size of any of its subtypes is the size of the predefined type from which it 
derives directly or indirealy. For example: 

type S is delta 0.01 range 0.8.. 1.0; 

- S is derived from an 8 bit predefined fixed type, its size is 8 bits, 
type F is delta 0.01 range 0.0.. 2.0; 

- F is derived from a 16 bit predeHned fixed type, its size is 16 bits, 
type N is new F range 0.8.. 1.0; 

- N is indirectly derived from a 16 bit predefined fixed type, its size is 16 bits. 

When a size specification is applied to a fixed point type, this fixed point type and each of 
its subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is delta 0.01 range 0.8.. 1.0; 
for S'SIZE use 32; 

- S is derived from an 8 bit predefined fixed type, but its size is 32 bits 

- because of the size specification. 

type F is delta 0.01 range 0.0.. 2.0; 
for FSI2IE use 8; 

“ F is derived from a 16 bit predefined fixed type, but its size is 8 bits 

- because of the size specification. 


tyr*? N is new F range 0.8.. I.O; 

- N is indirectly derived from a 16 bit predefined fixed type, but its size is 

— 8 bits because N inherits the size specification of F. 


Support for Representation Clauses 


23 





The Alsys compiler fully implements size specifications. Nevertheless, as fixed point 
objects are represented using machine integers, the specified length cannot be greater 
than 32 bits. 


Sag of the objects of a fixed point subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of a fixed point type has the same size as its subtype. 


4.5 Access T^pes and Collections 

Access Types and Objects of Access Types 

The only size that can be specified for an access type using a size specif '^tion is its usual 
size (32 bits). 

An objea of an access subtype has the same size as its subtype, thus an object of an 
access subtype is always 32 bits long. 


Collection Sbe 

As described in RM 13.2, a specification of collection size can be provided in order to 
reserve storage space for the collection of an access type. 

When no STORAGE_SIZE specification applies to an access type, no storage space is 
reserved for its colleaion, and the value of the attribute STORAGE.SIZE is then 0. 

The maximum size allowed for a collection is 64k bytes. 


4.6 Task Types 

Storage for a task activation 

As described in RM 13.2, a length clause can be used to specify the storage space (that is, 
the stack size) for the aaivation of each of the tasks of a given type. Al^ also allows the 
task stack size, for all tasks, to be established using a Binder option. If a length clause is 
given for a task type, the value indicated at bind time is ignored for this task type, and the 
length clause is obeyed. When no length clause is used to specify the storage space to be 


24 


Appendix F, Version 5 





Teserved for a task aaivation, the storage space indicated at bind time is used for this 
activation. 

A length clause may not be applied to a derived task type. The same storage space is 
reserved for the aaivation of a task of a derived type as for the aaivation of a task of the 
parent type. 

The minimum size of a task subtype is 32 bits. 

A size specification has no effect on a task type. The only size that can be specified using 
such a length clause is its usual size (32 bits). 

An objea of a task subtype has the same size as its subtype. Thus an objea of a task 
subtype is always 32 bits long. 


4.7 Array Types 

Each array is allocated in a contiguous area of storage units. All the components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 


4.7.1 Array Layout and Structure and Pragma PACK 



□ 

ii^miiiin 

□ 




Componer.; Gap Component Gap Component Gap 


If pragma PACK is not specified for an array, the size of the components is the size of the 
subtype of the components; 


Support for Representation Clauses 


25 







type A is array (1 ~ 8) of BOOLEAN; 

- The size of the components of a is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIGIT is range 0.. 9; 
for DECIMAL.DIGn^IZE use 4; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range < >) of DECIMAL_DIGrr: 

- The size of the type DECIMAL_DIGrr is 4 bits. Thus in an array of 

- type BINARY_CODED_DECIMaL each component will be represented on 

- 4 bits as in the usual BCD representation. 

If pragma PACK is specified for an array and its components are neither records nor 
arrays, the size of the components is the minimum size of the subtype of the components; 

type A is array (1.. 8) of BOOLEAN; 
pragma PACK(A); 

- The size of the components of A is the minimum size of the type BOOLEAN: 
-IbiL 

type DECIMAL_DIGrT Is range 0.. 9; 
for DECIMAL_DIGrrsiZE use 32; 
type BINARYJcODED.DECIMaL is 

array (INTEGER range < >) of DEaMAL.DIGIT, 
pragma PACK(BINARY_C0DED_DECIMAL); ~ 

- The size of the type DECIMAL_DIGn' is 32 bits, but, as 

- BINARY_C0DED_DECIMAL is packed, each component of an array of this 

- type will be represented on 4 bits as in the usual BCD representation. 

Packing the array has no effea on the size of the components when the components are 
records or arrays, since records and arrays may be assigned addresses consistent with the 
alignment of their subtypes. 


Gaps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the compiler may choose a 
representation with a gap after each component; the aim of the insertion of sutdi gaps is 
to optimize access to the array components and to their subcomponents. The size of the 
gap is chosen so that the relative displacement of consecutive components is a multiple 


26 


Appendix F, Version 5 


of the alignment of the subtype of the components. This strategy allows each component 
and subcomponent to have an address consistent with the alignment of its subtype: 

type R is 
record 

K: INTEGER; 

B: BOOLEAN; 

end record; 
for Ruse 
record 

KatOrange0.. IS; 

B at 2 range 0.. 0; 
end record; 

~ Record type R is byte aligned. Its size is 17 bits, 
type A is array (1.. 10) of R; 

•• A gap of 7 bits is insened after each component in order to respect the 
- alignment of type R. The size of an array of type A will be 240 bits. 




Coaponant Gap Cowp o nent Cap Cuasonant Gap 
Array of type A: each subcomponent K has an even offset 

If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are inserted: 

type R is 
record 

K: INTEGER; 

B: BOOLEAN; 

end record; 

type A is array (1.. 10) of R; 
pragma PACK(A); 

~ There is no gap in an array of type A because A is packed. 

~ The size of an objea of type A will be 270 bits. 


Support for Representation Clauses 


27 








type NR is new R; 
rorNR’SIZEiue24; 

type B is array (1.. 10) of NR; 

~ There is no gap in an array of type B because 

- NR has a size specification. 

- The size of an objea of type B will be 240 bits. 






B 


mm 

D 

II^B 

D 





CowMiwnt Conporant 

Array of typeA orB 


4.7.2 Array Subtype and Object Size 

Size of an array atbtype 

The size of an array subtype is obtained by multiplying the number of itt components by 
the sum of the size of the components and the size of the gaps (if any). If the subtype is 
unconstrained, the maximum number of components is consktered. 

The size of an array subtype cannot be computed at compile time 

■ if it has non*static constraints or is an unconstrained array type w: Ji non-static 
index subtypes (because the number of components can then only be determined at 
run time). 

• if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not static (because the size of the components and 
the size of the gaps can then only be determined at run time). 

As has been indicated above, the effect of a pragma PACK on an array type is to suppress 
the gaps. The consequence of packing an array type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not static, the compiler ignores any 
pragma PACK applied to the array type but issues a warning message. Apart from this 
limiution, array packing is fully implemented by the Alsys compiler. 


28 


Appenda F, Version 5 





A size specification applied to an array type or first named subtype has no effect The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verily that the layout of an array is as expeaed by 
the application. 


Size of the objects of an array subtype 

The size of an object of an array subtype is always equal to the size of the subtype of the 
object 


4.8 Record Types 

4.8.1 Basic Record Structure 

Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. 

The positions and the sizes of the components of a record type object can be controlled 
using a record representation clause as described in RM 13.4. In the Alsys Ada Software 
Development Environment for BTOSII implementation there is no restriction on the 
position that can be specified for a component of a record. If a component is not a record 
or an array, its size can be any size from the minimum size to the size of its subtype. If a 
component is a record or an array, its size must be the size of its subtype. 

type DEVICE.INFO.RECORO is 
record 

Bins : BOOLEAN; 

CTRL : BOOLEAN; 

NETUORK : BOOLEAN; 

BinZ : BOOLEAN; 

BIT11 : BOOLEAN; 

BIT10 : BOOLEAN; 

BIT9 : BOOLEAN; 

BITS : BOOLEAN; 

ISOEV : BOOLEAN; 


-• Bit 15 (reserved) 

" Bit H (true if control strings processed) 
** Bit 13 (tme if device is on network) 

" Bit 12 (reserved) 

” Bit 11 (reserved) 

•• Bit 10 (reserved) 

-• Bit 9 (reserved) 

-- Bit 8 (reserved) 

Bit 7 (true if device, false if disk file) 


Support for Representation Clauses 


29 




I 

I 


EOF 

BOOLEAN; 

*> Btt 6 (true {f at and of fila) 

BINART 

BOOLEAN; 

— Bit 5 (true if binary (raw) aoda) 

■ lU 

BOOLEAN; 

*■ Bit 4 (raaarvad) 

ISCU 

boolean; 

“ Bit 3 (trua if clock davica) 

ISttUL 

BOOLEAN; 

Bit 2 (trua if NUL davica) 

ISCOT 

BOOLEAN; 

" Bit 1 (trua if conaola output davica) 

ISCItt 

boolean; 

•* Bit 0 (trua if conaola input davica) 

and record; 




for OCVtCE.INFO.RECtIRO uftO 


roeord 


Bins 

at 

1 

range 

7 


7; 


Bit 15 

CTRL 

at 

1 

range 

6 


6; 


Bit 14 

NETWORK 

at 

1 

range 

5 


5; 


Bit 13 

B1T12 

at 

1 

range 

4 


«; 


Bit 12 

BIT11 

at 

1 

range 

3 


3; 


Bit 11 

BIT10 

at 

1 

range 

2 


2; 


Bit 10 

BIT9 

at 

1 

range 

1 


1; 


Bit 9 

BITS 

at 

1 

range 

0 


0; 


Bit 8 

ISOEV 

at 

0 

range 

7 


7; 


Bit 7 

EOF 

at 

0 

range 

6 


6; 


Bit 6 

BINART 

at 

0 

range 

5 


5; 


Bit 5 

BIT4 

at 

0 

range 

4 


*; 


Bit 4 

ISCLK 

at 

0 

range 

3 


3; 


Bit 3 

ISNUL 

at 

0 

range 

2 


2; 


Bit 2 

ISCOT 

at 

0 

range 

1 


1; 


Bit 1 

ISCIN 

and record; 

at 

0 

range 

0 


0; 


Bit 0 


Pragma PACK has no effect on records. It is unneoessaiy because record representation 
clauses provide full control over record layout 

A record representation clause need not specify the position and tbe size for every 
component If no component clause applies to a component of a record, its size is the 
size of its subtype. 


SO 


j4pperuIaF, Version 5 










4.8^ Indirect Components 

•OFFSET 


If the of&et of a component cannot be computed at compile time, this o&et is stored in 
the record objects at run time and used to access the component Such a component is 
said to be indirea while other components are said to be direct: 



Beginning of the record 
Coepile tioM offset 

Coeipile tiae offset 


Run time offset 


A direct and an indirect component 

If a record component is a record or an array, the size of its subtype may be evaluated at 
run time and may even depend on the discriminants of the record We will call these 
components dynamic components: 

type DEVICE Is (SCREEN, PRINTER); 

type COLOR is (GREEN, RED, BLUE); 

type SERIES is array (POSITIVE range < >) of INTEGER; 

type GRAPH (L: NATURAL) is 
record 

X: SERIES( 1.. L); - The Sk'e of X depends on L 
Y: SERIES( 1 ~ L); - The size of Y depends on L 
end record; 

Q; POSITIVE; 


Support for Representation Clauses 


31 




type PICTURE (N: NATURAL; D: DEVICE) is 
record 

F: GRAPH(N); - The size of F depends on N 
S: GRAPH(Q); - The size of S depends on Q 
case D is 

when SCREEN » > 

C: COLOR; 
when PRINTER » > 

null; 
end case; 
end record; 

Any component placed after a dynamic component has an o&et which cannot be 
evaluated at compile time and is thus indireo. In order to minimize the number of 
indirea components, the compiler groups the dynamic components together and places 
them at the end of the record; 


0 • SCKEEN D > PRINTER 

N ■ 2 N > 1 



The record type PICTURE: F and S are placed at the end of the record 


32 


Appendix F, Version 5 







Note that Ada does not allow representation clauses for record components with non- 
static bounds [RM 13.4.7], so the compiler’s grouping of dynamic components does not 
conflia with the use of representation clauses. 

Because of this approach, the only indirect components are dynamic components. But 
not all dynamic components are necessarily indirect: if there are dynamic components in 
a component list which is not followed by a variant pan, then exactly one dynamic 
component of this list is a direct component because its offset can be computed at 
compilation time (the only dynamic components that are direa components are in this 
situation): 



Beginning of the record 
Conpile tine offset 


Conpile tine offset 
Size dependent on discrininant I. 
" ■ Hun tine offset 

Size dependent on discrininant L 


The record type GRAPH: the dynamic component X is a direct component 


The offset of an indirect component is always expressed in storage units. 

The space reserved for the offset of an indirect component must be large enough to store 
the size of any value of the record type (the maximum potential offset). The compiler 
evaluates an upper bound MS of this size and treats an of&et as a component having an 
anonymous integer type whose range is 0.. MS. 

If C is the name of an indirea component, then the offset of this component can be 
denoted in a component clause by the implementation generated name COFFSET. 


Support for Representation Clauses 


33 






4.83 Implicit Components 

In some circumstances, access to an objea of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid 
recomputation (which would degrade performance) the compiler stores this information 
in the record objects, updates it when the values of the discriminants are modified and 
uses it when the objects or its components are accessed. This information is stored in 
special components called implicit components. 

An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record objea (the implicit component is considered to be declared before any variant 
part in the record type declaration). There can be two components of this land; one is 
called RECORD.SIZE and the other VaRIANT_INDEX. 

On the other hand an implicit component may be used to access a given record 
component In that case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the 
record component). Components of this kind are called ARRAY DESCRIPTORS or 
RECORD.DESCRIPTORs. 


VECORDJIZE 

This implicit component is created by the compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the situ of the storage space 
necessary to store the current value of the record objea (note that the storage effectively 
allocated for the record objea may be more than this). 

The value of a RECORD_SIZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offiet or a size wUch carmot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maTimnm 
size of any value of the record type. The compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer type 
whose range is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’RECORDJIZE. This 
allows user control over the position of the implicit component in the record. 


34 


Appendix F, Version 5 



VARIANTJNDEX 

This implicit component is created by the compiler when the record type has a variant 
part It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists in variant parts that themselves do not contain a variant part are 
numbered. These numbers are the possible values of the implicit component 
VARIANT.INDEX. 

type VEHICLE is (AIRCRAFT, ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND : VEHICLE ;= CAR) is 
record 

SPEED: INTEGER; 
case KIND is 

when AIRCRAFT | CAR = > 

WHEELS; INTEGER; 
case KIND is 

when AIRCRAFT = > ~ 1 

WINGSPAN: INTEGER; 
when others = > - 2 

null; 
end case; 

when BOAT = > ~ 3 
STEAM . BOOLEAN; 
when ROCKET = > - 4 

STAGES; INTEGER; 

end case; 
end record; 

The value of the variant index indicates the set of components that are present in a 
record value: 


Variant Index 

Set 

1 

OCINO, SPEED, WHEELS, WINGSPAN) 

2 

(KINO, SPEED, WHEELS) 

3 

(KINO, SPEED, STEAM) 

4 

(KIND, SPEED, STAGES) 


Support for Representation Clauses 


35 








A comparison between the variant index of a record value and tiie bounds of an interval 
is enough to check that a given component is present in the value: 


Component 

Interval 

KINO 

.. 

SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAM 


STAGES 



The implicit component VARIANT_INDEX must be large enough to store the number v 
of component lists that don't contain variant parts. The compiler treats this implicit 
component as having an anonymous integer type whose range is 1.. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’VARIANT_INDEX. This 
allows user control over the position of the implicit component in the record. 


•AJtXAYJfESCRIPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The struaure of an implicit component of kind ARRAY_DESCRIFTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, size of the component 
may be obuined using the ASSEMBLY parameter in the COMPILE command. 

The compiler treats an implicit component of the kind ARRAY_DESCR1PT0R as having 
an anonymous array typ>e. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name CARRAY_DESCRIPTOR. 

This allows user control over the position of the implicit component in the record. 


36 


Appendix F, Version 5 








•RECORDJOESOUPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
discriminant of the record. It contains information about the component subtype. 

The struaure of an implicit component of kind RECORD_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, the size of the 
component may be obtained using the ASSEMBLY parameter in the COMPILE 
command. 

The compiler treats an implicit component of the kind RECORD_DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 
CRECORD_DESCRIPTOR. This allows user control over the position of the implicit 
component in the record. 


Suppression of Implicit Components 

The Alsys implementation provides the capability of suppressing the implicit 
components RECORD_SIZE and/orVARIANTJNDEX from a record type. This can be 
done using an implemenution defined pragma called IMPROVE. The syntax of this 
pragma is as follows: 

pragma IMPROVE (TIME | SPACE, {ON = >] simple_name); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the representation of the record type that is denoted by the second argument 

If TIME is specifled, the compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the compiler only inserts a VARIANT_INDEX or a 
RECORD_SIZE component if this component appears in a record representation clause 
that applies to the record type. A record representation clause can thus be used to keep 
one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Support for Representation Clauses 


37 



4.8.4 Size of Record Types and Objects 
Size of a record subtype 

Unless a component clause specifies that a component of a record type has an oCEset or a 
size which cannot be expressed using storage units, the size of a reco^ subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its 
components and the sizes of its gaps (Kany). This size is not computed at compile time 

■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at compile 
time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant. If the size of a 
component or of a gap cannot be evaluated exaaly at compile time an upper bound of 
this size is used by the compiler to compute the subtype size. 

A size specification applied to a record type or fitai named subtype has no effect The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of a record is as expected by 
the application. 


Sag an object of a record sut e 

An objea of a constrained record subtype has the same size as its subtype. 

An objea of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 8k bytes. If the size of the subtype is greater than this, the objea 
has the size necessary to store its current value; storage space is allocated and relea^ as 
the discriminants of the record change. 


38 


Appendix F, Version 5 





Section 5 


Conventions for Implementation-Generated Names 


The following forms of implementation-generated names [13.4(8)] are used to denote 
implementation-dependent record components, as described in S^ion 4.8 in the 
seaions on indirea and implicit components: 


COFFSET 

R*RECORD_SI2I 

R-VARIANlilNDEX 

R'ARRAY_DESCRrPTORs 

R’RECORD^DESCRIPTORs 


where C is the name of a record component and R the name of a record type. 

The following predefined packages are reserved to Alsys and cannot be recompiled: 


ALSYS.BASICJO 

alsys”ada_runtime 

ALSYS_BASIC_DrRECr_IO 

alsys_basic"sequential_io 


Conventions for Implementation-Generated Names 


39 







40 


Appendix F, Version 5 







Section 6 


Address Clauses 


6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an objea as described in RM 13^. 

en such a clause applies to an object the compiler does not cause storage to be 
allocated for the object The program accesses the object using the address specified in 
the clause. It is the responsibility of the user therefore to make sure that a valid 
allocation of storage has been done at the specified address. 

An address clause is not allowed for task objects, for unconstrained records whose size is 
greater than 8k bytes or for a constant 

There are a number of ways to compose a legal address expression for use in an address 
clause. The most direct ways are: 

• For the case where the memory is defined in Ada as another object use the 
’ADDRESS attribute to obtain the argument for the address clause for the second 
object 

■ For the case where the desired location is memory defined in assembly or another 
non-Ada language (is relocatable), an interfaced routine may be used to obtain the 
appropriate address from referencing information known to the other language. 

■ For the case where an absolute address is known to the programmer, use the 
funaion SYSTEM.VALUE. This function has one (1) parameter of type string. The 
string is of the form ''ssss:0000*. The length is 9, and the *:’ is required to separate 
the segment and offset portion of the address. SYSTEM.VALUE returns a value of 
type SYSTHMj\DDRESS. The string representing the desired address can be passed 
as the aaual parameter to SYSTEM.VALUE in the simple expression pan of the 
address clause. See Section 3 for the specification of package SYSTEM. 

In all cases other than the use of an address attribute, the programmer must ensure 
that the segment pan of the argument is a seleaor if the program is to run in 
protected mode. Refer to Application Developers' Guide, Seaion 5.1.5 for more 
information on protected mode machine oriented programming. 


Address Clauses 


41 






6.2 Address Clauses for Program Units 

Address clauses for program units are not implemented in the current version of the 
compiler. 


42 


Appendix F, Version 5 



Section 7 


Unchecked Conversions 


Unchecked type oonveisions are described in [13.10.2]. The following restrictions apply 
to their use: 

■ Unconstrained arrays are not allowed as target types. Unconstrained record types 
without defaulted discriminants are not allowed as target types. Access types to 
unconstrained arrays are not allowed as target or source typ<s. Notes also that 
UNCH£CKED_CONVERSION cannot be used for an access to an unconstrained 
string. 

• If the target type has a smaller si 2 e than the source type then the target is made of 
the least significant bits of the source. 

If the source and the target types are each of scalar or access type or if they are both of 
xmposite type, the effea of the function is to return the operand. 

in other cases the effea of unchecked conversion can be considered as a copy; 

■ If an unchecked conversion of a scalar or access source type to a composite target 
type is performed, the result is a copy of the source operand. The result has the size 
of the source. 

• If an unchecked conversion of a composite source type to a scalar or access target 
type is performed, the result is a copy of the source operand. The result has the size 
of the target 


Unchecked Conversions 


43 





44 


Appendix F, Version 5 







Section 8 


Input-Output Packages 


The RM defines the predefined input-output packages SEQUENTlAL_IO, DIRECT_IO, 
and TEXT JO, and describes how to use the fadliUes available within these packages. 
The RM a^ defines the package lO.EXCEPTIONS, which specifies the exceptions that 
can be raised by the predefined input-output packages. 

In addition the RM outlines the package LOW_LEVELJO, which is concerned with low- 
levei machine-dependent input-output, such as would possibly be used to write device 
drivers or access device registers. LOW_LEVELJO has not been implemented. The use 
of interfaced subprograms is recommended as an alternative. 


8.1 Correspondence between External Files and BTOS n 
Files 

Ada input-output is defined in terms of external files. Data is read from and written to 
external files. Each external file is implemented as a standard BTOS II file, including the 
use of STANDARD_INPUT and STANDARD_OUTPUT. 

The name of an external file can be either 

■ the null string 

• a BTOS n filename 

If the name is a null string, the associated external file is a temporary file and will cease 
to exist when the program is terminated. The file will be plac^ in the current direaoiy 
and its name will be chosen by BTOS II. 

If the name is a filename, the filename will be interpreted according to standard BTOS II 
conventions (that is, relative to the current direaoty). The exception NAME.ERROR is 
raised if the filename has more than 50 characters. 

If an existing BTOS II file is specified to the CREATE procedure, the contents of the file 
will be deleted before writing to the file. 


Input-Ouqnit Packages 


45 





If a non-existing direaoiy is specified in a file path name to CREATE, the directory will 
not be created, and the exception NAME.ERROR is raised. 


8.2 Error Handling 

BTOS II errors are translated into Ada exceptions, as defined in the RM by package 
IO_EXCEPnONS. In particular, DEVICE_ERROR is raised in cases of .LOrive not 
ready;.LErTors:drive not ready;drive not ready, xUnknown media;.L£rrors:unknown 
media;unknown media, .LDisk full;.LErrors:disk fulkdisk full or .LHardware 
errors;.LErrors:hardware;hardware errors on the disk (such as read or write fault). 


8.3 Sequential Files 

For sequential access the file is viewed as a sequence of values that are transferred in the 
order of their appearance (as produced by the program or run-time environment). This 
is sometimes called a stream file in other operating systems. Each object in a sequential 
file has the same binary representation as the Ada objea in the execuuble program. 


8.4 Direct Files 

For direct access the file is viewed as a set of elements occupying consecutive positions in 
a linear order. The position of an element in a direa file is specified by its index, which is 
an integer of subtype POSmVE^COUNT. 

DIRECT_IO only allows input-output for constrained types. If DIRECT JO is instantiated 
for an unconstrained type, all calls to CREATE or OPEN will raise USe'error. Fr^ rh 
objea in a direa file will have the same binary representation as the Ada objea in the 
executable program. All elements within the file will have the same length. 


8.5 Text Files 

Text files are used for the input and output of information in ASCII character form. 
Each text file is a sequence of charaaers grouped into lines, and lines are grouped into a 
sequence of pages. 

All text file column numben, line numbers, and page numbers are values of the subtype 
POSmVE_COUNT. 


46 


Appendix F, Version 5 






Note that due to the definitions of line tenninator, page tenninator, and file terminator 
in the RM, and the method used to mark the end of file under BTOSII, some ASC3I files 
do not represent well-formed TEXTJO files. 

A text file is buffered by the Runtime Executive unless 

■ it names a device (for example, [VID]). 

. it is STANDARD_INPUT or STANDARD_OlJTPUT and has not been ledireaed. 

If not redireaed, prompts written to STANDARD_OUTPUT with the procedure PUT will 
appear before (or when) a GET (or GET_LINE) occurs. 

The funaions END_OF_PAGE and END_OF_FlLE always return FALSE when the file is a 
device and STANDAEUJJNPUT when it is not redirected. Programs which would like to 
check for end of file when the file may be a device should handle the exception 
END.ERROR instead, as in the following example: 


Example 

begin 

loop 

-* Display tho pranpt: 

TEXT_IO.PUT <■—> '•); 

— Rood the next line: 

TEXT_IO.GET_LIME (COMMAND, UST); 

-- Mow do sosiething with COMMAND (1 .. LAST) 
end loop; 
exception 

when TEXT_IO.EMO_ERROR => 
null; 

end; 

END.ERROR is raised for STAN DARDJNPUT when F6 (ASCn.SUB) is entered at the 
keyboard. 


Input-Output Packages 


47 




8.6 Access Protection of External Files 


All BTOS n access protections exist when using files under BTOSIL If a file is open for 
read only access by one process it can not be opened by another process for read/v^te 
access. 


8.7 The Need to Close a File Explicitly 

The Rundme Executive will flush all buffets and close all open files when the program is 
terminated, either normally or through some exception. 

However, the RM does not define what happens when a program terminates without 
closing all the opened files. Thus a program which depends on this feature of the 
Rundme Executive might have problems when ported to another system. 


8.8 Limitation on the Procedure RESET 

An internal file opened for input cannot be RESET for output However, an internal file 
opened for output can be RESET for input and can subsequently be RESET back to 
output 


8.9 Sharing of External Files and Tasking Issues 

Several internal files can be associated with the same external file only if all the internal 
files are opened with mode lN_MODE. However, if a file is opened with mode 
OUT_MOOE and then changed to IN^MODE with the RESET procedure, it cannot be 
shared. 

Care should be taken when performing multiple input-output operations on an exte rnal 
file during tasking because the order of calls to the I/O primitives is unpredictable. Fbr 
example, two strings output by TEXT_IOJ*UT_LlNE in two Jifferent tasks may appear in 
the output file with interleaved charaaers. Synchronization of I/O in cases such as this is 
the vscfs responsibility. 

The TEXTJO files STANDARD_INPUT and STANDARD^OUTPUT are shared by all 
tasks of an Ada program. 

If TEXT_IOSTANDARD_INPUT is not redirected, it will not block a program on input. 
All tasks not waiting for input will continue running. 


48 


Appendix F, Version 5 


Section 9 


Characteristics of Numeric T^es 

9.1 Integer T^pes 

The ranges of values for integer types declared in package STANDARD are as follows: 

SHOBTJMTEGER -128 .. 127 -- 2~7 - 1 

INTEGER -32768 .. 32767 - 2**15 - 1 

LONO_IMTEGER -2147483648 .. 2147483647 -- 2**31 - 1 

For the packages DIRECTJO and TEXTJO, the range of values for types COUNT and 
POSrnVE_COUNT are as follows: 

COUNT 0 .. 2147483647 - 2~31 - 1 

POSITIVE_COUNT 1 .. 2147483647 — 2^31 • 1 

For the package TEXTJO, the range of values for the type FIELD is as follows: 

FIELO 0 .. 255 -- 2**8 - 1 

9.2 Floating Point Type Attributes 


SHORT JLOAT LONCJLOAT 

and FLOAT 

DIGITS 6 IS 

MANTISSA 21 51 

EMAX 84 204 

Characteristics of Numeric Types 49 







EPSILON 

9.53674E-07 

8.88178E-16 

LARGE 

1.93428E-'^25 

2.57110E*«1 

SAFE_EMAX 

125 

1021 

SAFE_SNALL 

1.17549E-38 

2.22507E-308 

SAFE.LARGE 

4.25353E^37 

2.24712E+307 

FIRST 

-3.40282E-'-38 

-1.79769E*308 

UST 

3.40282E-'-38 

1.79769E+308 

MACHINE_RAOIX 

2 

2 

NACHINE.EMAX 

128 

1024 

MACHINE.ENIN 

-125 

-1021 

NACHINE.ROUNOS 

true 

trtje 

NACNINE.OVERFLOWS 

false 

false 

SIZE 

32 

64 

Attributes of Type DURATION 


DURATION'DELTA 

2.0 •* (-14) 


DURATION'SMALL 

2.0 •* (-14) 


DURATION'FIRST 

-131.072.0 


DURATION'LAST 

131.072.0 


DURATION'LARGE 

same as DURATION'LAST 



50 


Appendix F, Version 5 


Section 10 


Other Implementation-Dependent Characteristics 


10.1 Characteristics of the Heap 

All objects created by allocators go into the heap. Also, portions of the Runtime Execu¬ 
tive represenution of task objects, including the task stacks, are allocated in the heap. 

UNCHECKED^DEALLOCATION is implemented for all Ada access objects except access 
objects to tasks. Use of UNCHECKED_DEALLOCATION on a task objea will lead to 
unpredictable results. 

All objects whose visibility is linked to a subprogram, task body, or block have their 
storage reclaimed at exit, whether the exit is normal or due to an exception. Effeaively 
pragma C0N1110L1.ED is automatically applied to all access types. Moreover, all 
compiler temporaries on the heap (generated by such operations as function calls 
returning unconstrained arrays, or many concatenations) allocated in a scope are 
deallocated upon leaving the scope. 

Note that the programmer may force heap reclamation of temporaries associated with 
any statements by enclosing the statement in a begin.. end blodc. This is especially 
useful when complex concatenations or other heap-intensive operations are performed 
in loops, and can reduce or eliminate STORAGE_ERRORs that might otherwise occur. 

The maximum size of the heap is limited only by available memory. This includes the 
amount of physical memory (RAM) and the amount of virtual memory (hard disk swap 
space). 


10.2 Characteristics of Tasks 

The default task suck size is IK bytes (32K bytes for the environment task), but by using 
the Binder option STACKTASK the size for all task sucks in a program may be set to a 
size from IK bytes to 64K bytes. 


Other Implementation-Dependent Characteristics 


51 



Normal priority rules are followed for preemption, where PRIORITY values are in the 
range 1.. 10. A task with undefined priority (no pragma PRIORITY) is considered to be 
lower than priority 1. 

The maximum number of active tasks is restricted only by memory usage. 

The accepter of a rendezvous executes the accept body code in its own stack. 
Rendezvous with an empty accept body (for synchronization) does not cause a context 
switch. 

The main program waits for completion of all tasks dependent upon librp'y packages 
before termirating. 

Abnormal completion of an aborted task takes place immediately, except when the ab¬ 
normal task is the caller of an entry that is engaged in a rendezvous, or if it is in the 
process of activating some tasks. Any such task becomes abnormally completed as soon 
as the state in question is exited. 

The message 

GLOBAL BLOCKING SITUATION OcTECTEC 

is printed to STaNDARD.OUTPUT when the Runtime Executive detects that no further 
progress is possible for any task in the program. The execution of the program is then 
abandoned. 


10 J Definition of a Main Subprogram 

A library unit can be used as a main subprogram if and only if it is a procedure that is not 
generic and that has no formal parameters. 


10.4 Ordering of Compilation Units 

The Alsys Ada Software Development Environment for BTOSII imposes no additional 
ordering constraints on compilations beyond those required by the language. 


52 


Appendix F, Version 5 





Section 11 


Limitations 


11.1 Compiler Limitations 

. The maximum identifier length is 255 characters. 

■ The maximum line length is 255 characters. 

■ The maximum number of unique identifiers per compilation unit is 2500. 

■ The maximum number of compilation units in a library is 1000. 

■ The maximum number of Ada libraries in a family is 15. 


11.2 Hardware Related Limitations 

• The maximum amount of data in the heap is limited only by available memory. 

• If an unconstrained record type can exceed 40% bytes, the type is not permitted 
(unless constrained) as the element type in the definition of an array or record type. 

• The maximum size of the generated code for a single compilation unit is 65535 
bytes. 

■ The maximum size of a single array or record object is 65522 bytes. Anobjea 
bigger than 40% bytes will be indirealy allocated. Refer to ALLOCATION 
parameter in the COMPILE command. (Section 4.2 of the User’s Guide.) 

m The maximum size of a single stack frame is 32766 bytes, including the data for 
inner package subunits unnestcd to the parent frame. 

■ The maximum amount of data in the global data area is 65535 bytes, including 
compiler generated data that goes into the GDA (about 8 bytes per compilation unit 
plus 4 bytes per externally visible subprogram). 


Limitations 


53 



54 


Appendix F, Venial 5 






INDEX 


Abnormal completion 52 
Aborted task 52 
Access protection 47 
Access types 24 
Allocators 51 

Application Developer’s Guide 3 
Array gaps 26 
Array subtype 7 
Array subtype and object size 28 
Array type 7 

ARRAY_DESCRIPT0R 36 
assembler 3 

Attributes of type DURATION 50 

Basic record struaure 29 
Binder 51 
Buffered files 46 
Buffers 

flushing 47 

C 3 

Charaaeristics of tasks 51 
Collection size 24 
Collections 24 
Column lumbers 46 
Compiler limitations 53 

maximum identifier length 53 
maximum line length 53 
maximum number of Ada libraries 
53 

maximum number of compilation 
units 53 

maximum number of unique 
identifien 53 
Constrained types 
I/O on 46 
Control Z 47 


COUNT 49 
CREATE 45,46 
CTOS conventions 45 
CTOS files 45 

DEVICE ERROR 46 
DIGITS 49 
Direct files 46 
DIRECT lO 45,46,49 
Disk full 46 
DOS Linker 4 
Drive not ready 46 
DURATIONDELTA 50 
DURATION’FIRST 50 
DURATION’LARGE 50 
DURATIONl-AST 50 
DURATION’SMALL 50 

FEXCEPTION_CODE 7 
EMAX 49 

Empty accept body 52 
END_ERROR 47 
END“oF FILE 47 
ENdIoF~PAGE 47 
Enumeration literal encoding 16 
Enumeration subtype size 17 
Enumeration types 16 
EPSILON 5C 
Errors 

disk full 46 
drive not ready 46 
hardware 46 
unknown media 46 
EXCEPTION_CODE 
Attribute 7 

FIELD 49 


Index 


55 







File closing 
esqpUdt 47 
Hie names 4S 
Hie terminator 46 
FIRST 50 

Fixed point type represenution 21 
Hxed point type size 22 
Hoating point type attributes 49 
Hoating point type representation 20 
Hoating point type size 21 

GET 47 
GET LINE 47 

GLOBAL BLOCKING SITUATION 
DETECTED 52 

Hardware errors 46 
Hardware limiutions 

maTimnin amount of data in the 
global data area 53 
maximum data in the heap 53 
maximum size of a single array or 
record objea 53 

maximum size of the generated code 
53 

Hardware related limiutions 53 
Heap 51 

I/O synchronization 48 
Implicit component 36,37 
Implicit components 34 
IN MODE 48 
INDENT 5 

Indirect record components 31 
INTEGER 49 

Integer type and object size 18 
Integer type represenution 18 


Integer types 49 
Intel objea module format 4 
INTERFACE 3,4 
INTERFACE_NAME 3,4 
Interfaced subprograms 45 
Interleaved cb^cters 48 
lO EXCEPTIONS 45,46 
ISJ^RRAY 
Attribute 7 

LARGE 50 
LAST 50 

Layout of a record 29 
Legal file names 45 
Library unit 52 
Limiutions 53 
Line numbers 46 
line terminator 46 
LONG INTEGER 49 
LOW^LEVELJO 45 

MACHINE EMAX 50 
MACHINE”EMIN 50 
MACHINE MANTISSA 50 
MACHINE’oVERFLOWS 50 
MACHINE"RADDC 50 
MACHINE_ROUNDS 50 
Main program 52 
Main subprogram 52 
MANTISSA 49 

Maximum amount of dau in the global 
dauarea 53 

Maximum dau in the heap 53 
Maximum identifier length 53 
Maximum line length 53 
Maximum number of Ada libraries 53 


56 


Appendix F, Version 5 




Maxinium number of compilation units 
53 

Maximum number of unique identifiers 
53 

Maximum size of a single array or 
record objea 53 

Maximum size of the generated code 53 
NAME_ERROR 45,46 

Non-bloddng I/O 48 
Number of active tasks 52 

OPEN 46 

Ordering of compilation units 52 
OUT_MODE 48 

P’IS ARRAY 7 
PAOC 5 
Page numbers 46 
Page terminator 46 
Parameter passing 2 
POSrnVE_COUNT 46.49 
Pragma IMPROVE 5,37 
Pragma INDENT 5 
Pragma INTERFACE 3,4 
Pragma ENTERFACE^NAME 4 
Pragma PACK 5,25,26,30 
Pragma PRIORITY 5,52 
Pragma SUPPRESS 5 
Predefined packages 39 
PRIORITY 5,52 
PUT 47 
PUT_LINE 48 

RECORD DESCRIPTOR 37 
RECORDIsIZE 34,37 
Rendezvous 52 


Representation clauses 15 
RESET 48 

Runtime Executive 2,4,46,47,48,51, 
52 

SAFE EMAX 50 
SAFE~LARGE 50 
SAFEIsMALL 50 
Sequential files 46 
SEQUENTIALJO 45 
Sharing of external files 48 
SHORT INTEGER 49 
SIZE so' 

Size of record types 38 
SPACE 37 

STANDARD.INPUT 45,47,48 
STANDARD'oUTPUT 45,47,48,52 
Storage reclamation at exit 51 
STORAGE_SIZE 24 
Stream file 46 
SUPPRESS 5 
Synchronization of I/O 48 
SYSTEM 5 

Task activation 24 
Task stack size 24,51 
Task sucks 51 
Task types 24 
Tasking issues 48 
Tasks 

charaaeristics of 51 
Text file 
buffered 46 
Text files 46 
TEXT lO 45,49 
TIME"37 


Inda 


57 








UNCHECKED_DEALLOCATION 

51 

Unknown media 46 
USE_ERROR 46 

Variant part 35 
VARIANT_INDEX 35,36,37 


58 


AfpentUxF, Version5 







