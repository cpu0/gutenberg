REPORT DOCUMENTATION PAG 


PuMciomint > !*<>" iwur >«r f urm. Wudiwt W 

i<m«i w iwimWw<—»i>i<id.«wdw»<ii*<g»»i>wlM l lin»tlntwwaio»>. Sand MiwMnit Mi kw 

iLimn"l" M iMiMw i Mi fewiMn. •• W«Nngtofi HadiuMii Btfuim, piiM U Ml M feMmMwi Opiniii 
I2f0}430a. and 10 dw OIMi al In Mw ialiaw and W a gu litan Aflaaa. OMaa al Mwaaiiwaia and lydiiai. WiaNn 


AD-A279 804 




940325S1.11351, AVF: • 9Addc500_3c, Compiler: DACS Sun SPARC/ 
SunOS to Pentium PM Bare Ada Cross Compiler System with Rate 
MonotonicScheduling, Version A.6.4 




National Institute of Standards and Technology 
Gaithersburg, Maryland 







ORGANIZATION 


ISH3?S5 iSIJ'SSSS Technology 

Gaithersburg, Maryland 20899 

USA 


W r*T; 


ING AGENCY NAME(S) AN 

Ada Joint Program Office 
The Pentagon, Rn 3E118 
Washington. DC 20301 -3080 





10 . 
AGENCY 



Kf 71 i eTT^Sifr :T*i I 


lON/AVAILABIL 


Approved for Public Release; cdistribution unlimited 


(Maximum 



Host: Sun SPARCStatiOB .IPX (under SunOS, Release 4.1.2) 

Target: Intel Xpress Desktop (product number XBASE6E4F~B, with Pentdum 6pu), 
operating as a bare machine (bare machine) 


Ada programming linguage, Ada Compler Validation Summary Report, At 

Wa vm. office. Wa Val. I 




1 



CLASeriCATION 

UNCLASSIFED 






















AVF Control Nuabor: NIST94DDC500_3C_1.11 
Cortificate Inforaation 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on November 19, 1993. 


Compiler Name and Version: 

Host Computer System: 
Target Computer System: 


DACS Sun SPARC/SunOS to Pentium PM Bare 
Ada Cross Compiler System with Rate 
Monotonic Scheduling, Version 4.6.4 

Sun SPARCstation IPX running under SunOS, 
Release 4.1.2 

Intel Pentium (operated as Bare Machine) 
based in Xpress Desktop (Intel product 
number: XBASE6E4F-B) 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
940325S1.11351 is awarded to DDC-I. This certificate expires 2 years 
after ANSI/MIL>STD-1815B is approved by ANSI. 

This report has been reviewed and is approved. 


y 

Ada Vdli^atiodf Facility Adi^^al^^ion^^^c^^^"^*^^ 

Dr. David K. Mff^r^n Nr. L. Arnold Jo^uison 

Chief, Information Systems Manager, Softwal^ Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CSL) 

National Institute of Standards emd Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 




V 

, - 

rganization 


Ada Va] 

Director', Cdfiputer 6 Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



94-16091^^ 


Ada Joint Program Office 
David R. Basel 
Deputy Director, 

Ada Joint Program Office 
Defense Information Systems Agency, 
Center for Information Management 
Washington DC 20301 


U.S.A. 



94 5 27 050 





AVF Control Number; NIST94DDC500_3C_1.11 
DATE COMPLETED 

BEFORE ON-SITE; 94-03-18 
AFTER ON-SITE; 94-03-28 
REVISIONS; 94-04-11 


Ada COMPILER 
VALIDATION SUMMARY REPORT; 

Certificate Number; 940325S1.11351 
DDC-I 

DACS Sun SPARC/SunOS to Pentium PM Bare Ada 
Cross Compiler System with Rate Monotonic Scheduling, 

Version 4.6.4 

Sun SPARCstation IPX »> Intel Pentium (operated as Bare Machine) 
based in Xpress Desktop (Intel product number; XBASE6E4F-B) 


Prepared By; 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Accesfon For 


NTIS CRA&I 

OTIC TAB 

Unannou'ced 

Justification 

1 

By.. 

Dist; ibution / 

_ I 

1 

1 

Availabilny 'J;.. 

-1 

"t * * 

Dist 

tl 

Avail 0: 1 

j 

i 







AVF Control Nuabor: NZST94DDC500 3C 1.11 


Cortiflcato Information 


Tha following Ada implaaantation vaa tastad and datarminad to pass ACVC 
1.11. Tasting was complatad on Novaabar 19, 1993. 


Coapilar Naaa and Varsion: 

Host Coaputar Systaa: 

Targat Coaputar Systaa: 


DACS Sun SPARC/SunOS to Pantiua PM Bara 
Ada Cross Coapilar Systaa with Rata 
Monotonic Schaduling, Varsion 4.6.4 

Sun SPARCstation IPX running undar SunOS, 
Ralaasa 4.1.2 

Intal Pantiua (oparatad as Bara Machina) 
basad in Xprass Daslctop (Intal product 
nuabar: XBASE6E4F-B) 


Saa section 3.1 for any additional inforaation ed»out tha tasting 
environaent. 

As a result of this validation effort. Validation Certificate 
940325S1.11351 is awarded to ODC-I. This certificate expires 2 years 
after ANSI/MIL-STO*1815B is approved by ANSI. 

This report has bean raviawcKl and is approved. 



Engineering Division (ISED) 



Ada Validation Facility 







Mr. L. Arnold Jo^son 
Mamager, Software Standards 
Validation Group 


Computer Systems Laboratory (CSL) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
D. S. A. 


Ada Joint Progreun Office 
David R. Basel 
Deputy Director, 

Ada Joint PrograuB Office 
Defense Information Systems Agency, 
Center for Information Management 
Washington DC 20301 
U.S.A. 



Ada Vali^tf^ Organization 
Director, Compuxer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexamdria VA 22311 








msiscocsoo ac i.u 


ODClIMmi CF OOiCRfiCE 

ftt foUouing dsclsration of aonfisDnnot ws by the custcsBr. 

Cuatager: OOC-l 

OKtifUau tedas: cooi 

Adh \Uidtatian FbeiUty: ttticnal Institute of «d 

Ttertmlnay 

Co n paar Systm laboeatOEy (CSL) 

Softkois StandBsds Mklidttlon 
BaiMiig22S, ItaBA266 
GsitbeeAuEg. Iteyland 20899 
OJJL 

lOK \%i3Ud: 1.11 


Ads XtapleBBotation: 


Ocapiler ihm and ^te^lion; DKCS Sm SMC/SunOS to Fentun EM Ban Ms 

Qs6s CtnpiW Syatao with Bate MnXcnic 
Srtifrtiling, Afeeaicn 4.6.4 

fioit Ospasr Syston: Sun SMCstation QX zumin? undhr 9uaQ6, 

Beleeee 4.L.Z 


Bttgat Cn i p t er Systan: Intel Bentiua (qpaoted as Bam (Mcbine) based 

in AExeas Desktop (IcCel {zodiet ludaer: 
XBKE6E4E^) 

n^r1ayat^^/^»l » 


I the ladeaignad dKd a ie that I ham no loodadlB of deviations 

ftSB the Ak language Standard AI6I/MIL-51IH81SA ISO 8652-1987 in the 
iqplnaatatia listed above. 



Goaiaqr OK-l 
Title 


TCe 


*l\-oh-2Z 

Otte 





TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3.3-1 

PROCESSING INFORMATION.3-1 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS.B-1 

LINKER OPTIONS.B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 





























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 



1.2 REFERENCES 


[Ada83] Reference_ Ma nuial_ for the Ada Programming _ Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro92] Ada Compiler Validation Procedures . Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User's Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, O, E, and L. The first letter of a test 
name Identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FIIiE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 





largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4. DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The software and any needed hardware that 
have to be added to a given host and target 
computer system to allow transformation of 
Ada programs into executable form and 
execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 






Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable Test 

ISO 

LRM 


Operating System 


Target Computer 
System 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or part of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/MIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form ''<section>.<subsection>: 
<paragraph>. •' 

Software that controls the execution of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 


1-4 




Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn Test 


The compiler of a validated Ada 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF testing 
or by registration [Pro92]. 

The process of checking the conformity of an 
Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or illegal use of the Ada 
programming language. 


1-5 





CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 93-11-22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

C04024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 


2-1 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 






C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 

C24113I..K (3 tests) use a line 
exceeds 126 characters. 


C35802L..Z (15 tests) 
C45321L..Y (14 tests) 

C45521L..Z (15 tests) 

C45621L..Z (15 tests) 

C46012L..Z (15 tests) 

length in the input file which 


C35404D, C45231D, B86001X, C86006E, and CD7101G ChecJc for a 
predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 


CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 


2-2 




CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
Clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files: 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 1 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B. .D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A,.F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A. .B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E. .F 

(2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an 

attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USE_ERROR. (See section 2.3.) 

2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 71 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 


2-3 





the way expected by the original tests. 


B22003A 

B35101A 

B38009B 

B61001R 

B83E01D 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B85001D 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BAIOOIA 

BC1202G 


B28003A 

B38003A 

B61001H 

B83A07B 

B91001A 

B91002G 

B95061A 

BAllOlB 

BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may-be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAMERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D Were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification as directed by the AVO. The tests abort 
with an unhandled exception when USE_ERROR is raised on the attempt 
to create an external file. This is acceptable behavior because 
this implementation does not support external files (cf. AI-00332). 


2-4 







CHAPTER 3 


^PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adec[uately by the information given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

For sales information abort this Ada implementation, contact: 

Mike Halpin 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system—if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 








a) Total Number of Appliceible Tests 3562 

b) Total Nximber of Withdrawn Tests 104 

c) Processed Inapplicable Tests 504 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


f) Total Niimber of Inapplicable Tests 504 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation teaun for processing. The 
contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded onto the host computer, the full 
set of tests was processed by the Ada implementation. The DDC-I 
Ada downloader runs on the host machine and is used for downloading 
the executable ixnages to the target machine. The DDC-I Debug 
Monitor runs on the target machine and provides communication 
interface between the host downloader and the executing target 
machine. The two processes communicate via ethemet. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 

-list 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-2 







APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IN LEN—also listed here. These values are expressed here as 
Ada string aggregates, where "V** represents the maximxun input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 => 'A', V => '!•) 

$BIG_ID2 (1..V-1 *> ‘A*, V «> '2') 

$BIG_ID3 (1..V/2 => 'A*) & '3' & (1..V-1-V/2 *> 'A') 

$BIG_ID4 (1..V/2 => 'A') & *4' & (1..V-1-V/2 «> 'A') 

$BIG_INT_LIT (1..V-3 «> '0') & "298'' 

$BIG_REAL_LIT (1..V-5 => '0') & ••690.0" 

$BIG_STRING1 •""• & (1..V/2 => •A^) & •""• 

$BIG_STRING2 •""• & (1..V-1-V/2 => •A^) & •!• & •""• 

$BLANKS (1..V-20 => • •) 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => •O^) & "11:" 

$MAX_IiEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => •O^) & "F.E:" 

$MAX_STRING_LITERAL •""• & (1..V-2 *> •A^) & •""• 


A-1 






The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


ACC_SIZE 

ALIGNMENT 

CX>UNT_LAST 

DEFAULT_MEM_SIZE 

DEFAULT_STOR_UNIT 

DEFAULT_SyS_NAME 

DELTA_DOC 

ENTRY_ADDRESS 

ENTRY_ADDRESS1 

ENTRY_ADDRESS2 

FIELD_LAST 

FILE_TERMINATOR 

FIXED_NAME 

FLOAT_NAME 

FORM_STRING 

FORM STRING2 


48 

2 

2_147_483_647 

16#1_0000_0000# 

16 

IAPX586_PM 

2«1.0iE-31 

(140,0) 

(141,0) 

(142,0) 

35 

ASCII.SUB 

NO_SUCH_FIXED_TYPE 

SHORT_SHORT_FLOAT 

It It 


"CANNOT_RESTRICT_FILE_CAPACITY" 
GREATER_THAN_DURATION : 75_000.0 

GREATER_THAN_DURATION_BASE_LAST : 131_07 3.0 

GREATER_THAN_FLOAT_BASE_LAST : 16#1.0#E+32 

GREATER_THAN_FLOAT_SAFE_LARGE : 16#5.FFFF_F0#E+31 

GREATER_THAN_SHORT_FLOAT_SAFE_LARGE: 1.0E3 08 
HIGH_PRIORITY : 31 

ILLEGAL_EXTERNAL_FILE_NAME1 : \NODIRECTORY\FILENAME 

ILLEGAL_EXTERNAL_FILE_NAME2 : 

THIS-FILE-NAME-IS-TOO-LONG-FOR-MY-SYSTEM 
INAPPROPRIATE_LINE_LENGTH : -1 

INAPPROPRIATE_PAGE_LENGTH ; -1 

INCLUDE PRAGMAl : 


PRAGMA INCLUDE ("A28006D1.ADA") 


INCLUDE_PRAGMA2 

INTEGER_FIRST 

INTEGER_LAST 

INTEGER_LAST_PLUS_1 

INTERFACE_LANGUAGE 

LESS_THAN_DURATION 

LESS_THAN_DURATION_BASE_FIRST 

LINE_TERMINATOR 

LOW_PRIORITY 

MACHINE_CODE_STATEMENT 

MACHINE_CODE_TYPE 
MANTISSA DOC 


PRAGMA INCLUDE ("B28006E1.ADA”) 

: -2147483648 
: 2147483647 

: 2_147_483_648 
: ASM86 
: -75_000.0 
: -131_073.0 
: ASCII.CR 

: 0 

• 

« 

MACHINE_INSTRUCTION'(NONE,m_NOP); 
: REGISTER_TYPE 
: 31 


A-2 












MAX_DIGITS 
MAX_INT 
MAX_INT_PLUS_1 
MIN_INT 
NAME 

NAME_LIST 

NAME_SPECIFICATIONl 

DISK$AWC_2 
NAME_SPECIFICATION2 

DISK$AWC 2 
NAME_SPECIFICATION3 

DISK$AWC_2 
NEG_BASED_INT 
NEW_MEM_SIZE 
NEW_STOR_UNIT 
NEW_SYS_NAME 
PAGE_TERMINATOR 
RECORD_DEFINITION 
RECORD_NAME 
TASK_SIZE 
TASK_STORAGE_SIZE 
TICK 

VARIABLE_ADDRESS 
VARIABLE_ADDRESS1 
VARIABLE_ADDRESS 2 
YOUR PRAGMA 


15 

9223372036854775807 
9223372036854775808 
“9223372036854775808 
SHORT_SHORT_INTEGER 
IAPX586 PM 


:_2 :[ CROCKETTL. ACVC11. DEVELOPMENT ] X212 0A 

_2:[CROCKETTL.ACVC11.DEVELOPMENT]X212 OB 

• 

t CROCKETTL.ACVCl1.DEVELOPMENT]X3119A 

16# FFFF_PFFF_FFFF_FFFF # 
16#1_0000_0000# 

16 

IAPX586_PM 
ASCII.FF 

RECORD NULL;END RECORD; 
NO_SUCH_MACHINE_CODE_TYPE 
32 

1024 

0.000_000_062_5 
(16#0#,16#44#) 
(16#4#,16#44#) 
(16#8#,16#44#) 

EXPORT OBJECT 


A“3 










APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-1 




5 THE ADA COMPILER 


The Ada Compiler compiles all progrun units within the specified source file and insens the 
generated objects into the cunem program library. Cornier options are provided to allow the 
user control of optimization, nm-time checks, and compiler input and output options such as list 
files, configuration files, the program library used. etc. 

The input » the compiler consists of the source file, the configuration file (which controls the 
format of the list file), and the compiler options. Section S.l provides a list of all compiler 
options, and Section 5.1 describes the source and configuration files. 

If any diagnostic messages are produced during the compilation, they are output on the diagnostic 
fde and on the current output file. The diagnostic file and the diagnorik messages are described 
in Section 5.32. 

Output consists of an objea placed in the program library, diagnostic messages, and optional 
listings. The configuration file and the compiler options specify the format and contents of the 
list information. Output is described in Section 5.3. 

The compiler uses a program library during the compilation. The compilation unit may refer to 
units from the program library, and an internal representation of the compilation unit will be 
included in the program library as a result of a successful compilation. The program library is 
described in CHiapter 3. Section 5.4 briefly describes how the Ada compiler uses the library. 


5.1 Invoking the Ada Compiler 

Invoke the Ada compiler with the following command to the SunOS shell: 

S ada {<option>} <source>file-name> 
where the options and parameters are: 


35 





DACS*80x 86 User’s Guide 
Ada Compiler 


OPTION DESCRIPTION 


REFERENCE 


•[nolautojnline 

Specifies whether local subprograms should be 
inline expanded. 

5.1.1 

•chedi 

Controls nm-drne checks. 

5.1.2 

•configuration^fllc 

Specifies the configuration file used by the 
compiler. 

5.1.3 

•[no]dcbug 

Includes symbolic debugging infonnadon in 
program Ubrary. Does not include symbolic 
information. 

5.1.4 

-[no]fixpoint_rounding 

Generates fixed poim rounding code. Avoids fixed 
point rounding code. 

5.1J 

•[no Ifloat, allowed 

Flags generation of float instructions as 

5.1.6 

. 

error if selected. 


•[no [library 

Specifies program library used. 

5.1.7 

•(nojlist 

Writes a source listing on the list file. 

5.1.8 

•[no [optimize 

Specifies compiler optimization. 

5.1.9 

•(nojprogess 

Displays compiler progress. 

5.1.10 

•[nojxref 

Creates a cross reference listing. 

5.1.11 

•[nojsave source 

Copies source to program libraiy. 

5.1.12 

•[nojtargM.debug 

Includes Intel debug information. Does not include 
Intel debug information. 

5.1.13 

•unit 

Assigns a specific unit number to the compilation 
(must be free and in a sublibrary). 

5.1.14 

•recompile 

Interpret the file name as a compilation unit body 



that must be recompiled from libraiy. 

5.1.15 

•specification 

With •recompile interpret file name as a 



compilation unit specification rather than body. 

5.1.16 


Examples: 

$ ada -liat tastprog 

This example compiles the source file testprogJida and generates a list file with the name 
testprogJis. 

$ ada -library ayJLlbrary tart 

This example compiles the source file testada into the libraiy myjibrary. 

Default values exist for most options as indicated in the following sections. Option names may 
be abbreviated (charaaers omitted from the right) as long as no ambiguity arises. 


36 







DACS*80x86 User's Guide 
Ada Ccmipiler 


KSOurce'ClIC’^uimo 

The Ada compiler has one mandatory parameter that should specify the Ada source file. 

This parameter specifies the text file coiuaining the soutk text to be compiled. If the flle type 
is omitted in the source nie specification, the file type ".ada" is assumed by default 

The allowed format of the source text is described m Section S2.1. 


Below follows a description of each of the available options to the invocation of the Ada 
compiler. 


5.1.1 •[no]auto_inline 

•autojnline local | (lobal 
*noauto_inline (default) 

This option specifies whether subprograms should be inline expanded. The inline expansion only 
occurs if the subprogram has less than 4 object declarations and less than 6 statements, and if the 
subprogram ftilftlls the requirements defined for pragma INLINE (see Section C23). LOCAL 
specifies that only inline expansion of locally defined subprograms should be done, while 
GLOBAL will cause inline expansion of all subprograms, including subprograms from other units. 


5.U <check 


•dieck [ <keyword> » ON 1 OFF { ,<keyMrord> s ON | OFF ) ) 
•check ALL^N (default) 


•check specifies which run-time checks should be perforated. Setting a run-time check to ON 
enables the check, while setting it to OFF disables the check. All run-time checks are enabled by 
default. The following explicit checks will be disabled/enabled by using the name as <keyword>: 


ACCESS 

ALL 

DISCRIMINANT 

ELABORATION 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


Check for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

Checks for subprograms being elaborated. 
Index check. 

Array length check. 

Explicit overflow checks. 

Q^ks for values being in range. 

Checks for sufficient storage available. 


37 



DACS*80x86 User’s Guide 
Ada Compiler 


S.IJ -conflguration^file 


•conflgunition_filc <file-spco 
•€onnguration.nie conflg (default) 

This option specifies the configuration file to be used by the compiler in the cunem compilation. 
The configuration file allows the user to format compiler listings, set error limits, etc. If the 
option is omitted the conligutation file config located in the same directory as the Ada compiler 
is used by default Section 52,2 contains a description of the configuration fik. 


5.1.4 •[noldcbug 
•debug 

•nodebug (default) 

Generate debug infotmation for the compilation and store the information in the program library. 
This is necessary if the unit is to be debugged with the ODC-I Ada Symbolic Cross Debugger. 
Note that the program must also be linked with the •debug option, if the program is to be 
debugged with the DDC-1 Ada Symbolic Cross Debugger. See S^on 6.5.11. 


5.14 •[no]flxpoint_rounding 

•fixpoint^rounding (default) 

•nonxpoint_rounding 

Normally all inline generated code for fixed point MULTIPLY and DIVIDE is rounded, but this 
may be avoided with •nofixpoint^rounding. Inline code is generated for all 16 bit fixed point 
types and for 32 bit fixed point types, when the target is 80386PM or 80486PM. 


5.1.6 •(no]f1oat_allowed 

•float_allowed (default) 

•nofltrat^allowed 

Boat instruction generation may be flagged as errors, if •nofloat is selected. This is for use in 
systems, where no floating poim processor (nor emulator) is available. Notice that TEXTJO uses 
floats in connection with FLOATJO and FIXED_IO. 


38 






DACS-80x86 User's Guide 
Ada Compiler 


5.1.7 -library 

-library <file-spco 

-library SadaJibrary (default) 

This ofmon specifies the current sublibrary that will be used in the compilation and will receive 
the objea when the compilation is complete. By specifying a current sublibrary, the current 
program library (current sublibr4.ry and ancestors up to root) is also implicitly specified. 

If this option is omitted, the sublibrary designated by the environmental variable ada_library is 
used as the current sublibrary. Section S.4 describes how the Ada compiler uses the library. 


5.1.8 -(nollist 


-list 

-nolist (default) 

-list specifies that a source listing will be produced. The source listing is written to the list file, 
which has the name of the source file with the extension Jis. Section 5.3.1.1 contains a description 
of the source listing. 

If -nolist is active, no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


5.1il -optimize 

-optimize ( <keyword> s on | off { ,<keyword> s on | off} ] 

-optimize allsoff 

This option specifies which optimizations will be perfonned during code generabon. The possible 
keywords are: (casing is irrelevant) 


all 

All possible optimizations are invoiced. 

check 

Eliminates superfluous checks. 

cse 

Performs common subexpression elimination including common 
address expressions. 

fct2proc 

Change fu^on calls returning objects of constrained array types 
or objects of record types to procedure calls. 

reordering 

Transforms named aggregates to positional aggregates and named 
parameter associations to positio^ associations. 

stack_height 

Performs stack hei^ t^uctions (also called Aho UUman 
reordering). 

block 

Optimize block and call flames. 


Setting an optimization to on enables the optimization, while setting an optimization to off disables 
the optimization. AU optimizations are disabled by default In addition to the optional 
optimizations, the compiler always performs the following optimizations: constaiu folding, dead 
code elimination, and selection of optimal jumps. 


39 





DACS-80k 86 User’s Guide 
Ada OmpOer 


5.1.10 •(nolprogress 
•progress 

•noprogress (default) 

When this option is given, the compiler wiU output dau about which pass the compiler is 
cunently ninning. 


5.1.11 •(no]xref 
•xref 

•noxref (default) 

A cross-reference listing can be requested by the user by means of the option •xref. If the •xref 
option is given and no severe or fatal errors are found during the compilation, the cross-reference 
listing is written to the list file. The cross-reference listing is described in Section ?. 


5.1.12 -[nolsave-source 

-save^source (default) 

•nosave.source 

When •save.jource is specified, a copy of the compiled source code is placed in the program 
library. !f •nosave_source is used, source code will not be retained in the program library. 

Using -nosave-source. while helping to keep library sizes smaller, does affen the operation of 
the recompiler, see Qupter 7 for more details. A^. it will not be possible to do symbolic 
debugging at the Ada source code level with the DACS-80x86 Symbolic Ada Debugger, if the 
source code is not saved in the library. 


5.1.13 •(noltarget.debug 

•target_debug 
•notar^t_debug (default) 

Specifies whether symbolic debug information on standard OMF is included in the objea die. 
Currently the linker does not support the OMF debug information. 

This option may be used when debugging with starxlard OMF tools G-e.. FICE). 


40 


DACS-80X86 User’s Guide 
Ada Cwnpiler 


5.1.14 Hinit 


•unit s <unit_nuinber> 

The specified unit number wiU be assigned lo the compilation unit if it is free and it is a legal 
unit number for the library. 


5.1.15 •recompile 
•recompile 

The file name (source) is interpreted as a compilation unit nanre which has its source saved from 
a previous compilation. If -specification is not specified, it is assumed to be body which must be 
recompiled. 


5.1.16 -specification 
•specincation 

Works only together with -recompile, see Section S.1.15. 


5JZ Compiler Input 

Input to the compiler consists of the command line options, a source text file and. optionally, a 
configuration file. 


5JZ.1 Source Text 

The user submits one file containing a source text in each compilation. The source text may 
consist of one or more compilation units (see ARM Section 10.1). 

The format of the source text must be in ISO-FORMAT ASQl. This format requires that the 
source text is a sequence of ISO characters (ISO standard 646). where each line is tenninated by 
either one of the following termination sequences (CR means carnage return, VT means vertical 
ubulation, LF means line feed, and FF means form feed): 

• A sequence of one or more CRs, where the sequence is neither immediately preceded nor 
immediately foUowed by any of tire characters VT, LF. or FF. 

• Any of the characters VT. LF, or FF, immediately preceded and followed by a sequence of zero 
or more CRs. 

In general. ISO control characters are not pcnnitied in the source text with the following 
exceptions: 


41 




DACS-80X86 User's Guide 
Ada Compiler 


• The horizontal tabulation (HT) character may be used as a separator between lexical units. 

• LF. VT. FF. and CR may be used to terminate lines, as described above. 

The maximum number of characters in an input line is determined by the contents of 
configuration file (see section S.I.3). The control charaaers CR. VT, LP. and FF are 
considered a pan of the line. Lines containing more than the maximum number of charaaers 
truncated and an error message is issued. 


522 Configuration File 

Certain processing chaiaaeristics of the compiler, such as format of input and output, and error 
limit, may be modified by the user. Tliese characteristics ate passed to the compiler by means 
of a corifigutation file, which is a standard SPARC/SunOS text file. The contents of the 
configuration file must be an Ada positional aggregate, written on one line, of the type 
CONFICURATION.RECORD, which is described below. 

The configuration file (config) is not accepted by the compiler in the following cases: 

• The syntax does not conform with the syntax for positional Ada aggregates. 

• A value is outside the ranges specified. 

• A value is not specified as a literal. 

• LINES.PER.PAGE is not greater than TOP.MARGIN + BOTTOM.MARGIN. 

• The aggregate occupies mote than one line. 

If the compiler is unable to accept the configuration flle. an error message is written on the 
current output file and the compilation is terminated. 

This is the record whose values must appear in aggregate form within rhe configuration file. The 
record declaration makes use of some other types (given below) fci ^e sake of clarity. 


42 




DACS-SOxSe User's Guide 
Ada Compiler 


type CONFXGUMTZON_RECORO is 
record ~ 

ZN_FORMAT: INrORMATTING; 

OUT FORMAT: OUTFORMATTZNG; 
ERROR_l.ZMZT: INTEGER; 
end record; 


type 1NPUT_F0RMATS is (ASCII); 

type INFORMATTZNG is 
record 


INPUT FORMAT: 
INPUT'lINELENGTH: 
end record; 

type OUTFOBMATTZNG is 
record 

LINES_PER PAGE 
TOP MARGIN 
BOTTOM MARGIN 
OUT LZNELENGTH 
SUPPR£SS_ERRORNO : 
end record; 


INPUT FORMATS; 

INTEGER range 70..250; 


ZNTEGER range 30..100; 
INTEGER range 4.. 90; 
INTEGER range 0.. 90; 
INTEGER range 80..132; 
BOOLEAN; 


The Tutformaoing parameters have the following meaning: 


1) LINES.PER.PAGE: specifies the maximum number of lines written on each page 
(including top and bottom margin). 

2) TOP_MARGIN: specifies the number of lines on top of each page used for a standard 
heading and blank lines. The heading is placed in the middle lines of die top margiiL 

3) BOTTOM.MARGIN: spedfies the minimum number of lines left blank in the bottom of 
the page. The number of lines available for the listing of the program is LINES 
PER.PAGE - TOP_MARGIN - BOTTOM.MARGIN. 

4) OUT.LINELENGTH: specifies the maximum number of characters written on each line. 
Lines longer than OUT.LINELENGTH are sepaiated into two lines. 

5) SUPPRESS.ERRORNO: specifies the format of error messages (see Section 5.3.5.1). 


The name of a user-supplied configuration file can be passed to the compiler through the 
configuration-file option. DDC-l supplies a default configuration file (coniig) with the following 
comem: 


43 








DACS-80)i86 User’s Guide 
Ada Compiler 


((ASCn. 126). (48.5.3.100JfALSE), 200) 


Top 

Mtpln 




LlnM 

W* 


Bottea 

■argln 





Outjine.lengih 


Figure 5*1. Page Layout 


5 J Compiler Output 

The compiler may produce output in the list file, the diagnostic file, and the cunent output file. 
It also uj^ates the program library if the compilation is successful. The present section describes 
the text output in the three files mentioned above. The updating of the program library is 
described in Section 5.4. 


The compiler may produce the following text output: 

1) A listing of the source text with embedded diagnostic messages is written on the list file, 
if the option -list is active. 

2) A compilation summary is written on the list file, if -list is active. 

3) A cross-reference listing is written on the list file, if -xref is active and no severe or fatal 
errors have been detected during the compilatioa 

4) If there are any diagnostic messages, a diagnostic file containing the diagnostic messages 
is written. 

5) Diagnostic messages other than warnings are written on the current output file. 


44 












DACS-80x 86 User's Guide 
Ada Compiler 


SJ.1 The List FUe 

The name of the list file is identical to the name of the source file except that it has the flle type 
".lis". The file is located in the current (default) directory. If any such fde exists prior to the 
compilation, the newest version of the Tde is deleted. If the user requests any listings by 
specifying the options 'list or -xref, a new list fde is created. 

'The list fde may itKlude one or more of the following parts; a source listing, a cross-reference 
listing, and a compdadon summary. 

The parts of the list file are separated by page ejects. The contents of each pan are described in 
the following sections. 

The format of the output on the list file is controlled by the configuration file (see Section 522 ) 
and may therefore be controlled by the user. 


5J.1.1 Source Listing 

A source listing is an unmodified copy of the source text The listing is divided into pages and 
each line is supplied with a line number. 

The number of lines output in the source listing is governed by the occurrence of LIST pragmas 
and the number of objectionable lines. 

• Pans of the listing can be suppressed by the use of the LIST pragma. 

• A line containing a construct that caused a diagnostic message to be produced is prirued even 
if it occurs at a point where listing has been suppressed by a LIST pragma. 

5J.1JI Compilation Summary 

At the end of a compilation, the compiler produces a atmmary that is output on the list file if the 
option -list is active. 

The summary contains infomnation about; 

1) The type and name of the compilation unit, and whether it has been compiled successfully 
or not. 

2) The number of diagnostic messages produced for each class of severity (see Section 
5.3.2.1). 

3) Which options were active. 

4) 'The full name of the source file. 

5) The full name of the current sublibrary. 

6) The number of source text lines. 


45 





DACS-80X86 User’s Guide 
Ada Compiler 


7) The size of the code produced (specified in bytes). 

8) Bapsed real time and elapsed CPU time. 

9) A "Compilation terminated" message if the compilation unit was the last in the compilation 
or "Compilation of next unit initiated" otherwise. 


5J.U CrQflB>Refierenoe Listing 

A cross'iefeience listing is an alphabetically sotted list of the identifiers, opeiaiois, and character 
literals of a compilation unit. The list has an entry for each entity declared andArr used in the 
unit, with a few exceptions stated below. Overloading is evidenced by the occurrence of multiple 
entries for the same identifier. 

For instantiations of generic units, the visible declarations of the generic unit are included in the 
cross-reference Ibdng as declared immediately after the instantiation. The visiUe declarations are 
the subprogram parameters for a generic su b progra m and the declarations of the visible part of the 
package declaration for a genetic package. 

For type declarations, all implicitly declared operations are included in the cross-reference listing. 

Cross-reference information will be produced for every consOtuem character literal for string 
literals. 

The following ate not included in the cross reference listing: 

• Pragma identifiers and pragma argumenc identifiers. 

• Numeric literals. 

• Record component identifiers and discriminam identifiers. FOr a selected name whose selector 
denotes a record compotKnt or a discriminatu. only the prefix generates cross-refereiKe 
infonnation. 

> A parem unit name (following the keyword SEPARATE). 


Each entry in the cross-refereiKe listing contains: 

• The identifier with, at most. 15 characters. If the identifier exceeds IS characters, a bar Cf) 
is written in the 16th position and the rest of the characters are not primed. 

• The place of the definition, i.e.. a line number if the entity is declared in the currem 
compilation unit, otherwise the name of the compilatioa unit in which the entity is declared 
and the line number of the declaratioa 

• The numbers of the lines in which the entity is used. An asterisk offer a line number 
indicates an assignmem to a variable, initialization of a constant, ass ignment s to fimctions, or 
user-defined operators by means of RETURN statements. Please refer to Appendix B.3 for 
examples. 


46 






DACS-80x86 User's Guide 
Adt Compiler 


5 The Diagnostic File 

The name of the diagnostic file is identical to the name of the source file except that it has the 
file t^ ".enr”. It is located in the current (default) directory. If any such file exists prior to the 
compilatiotu the newest version of the file is deleted. If any diagnostic messages are produced 
during the compilation a new diagnostic file is created. 

The diagnostic file is a text file containing a lis of diagnostic messages, each followed by a line 
showing the number of the line in the source text causing the message, and a blank line. There 
is no separ^on into pages and no headings. The file may be used by an interactive editor to 
show the diagnostic messages together with the erroneous source text. 


5JJ.1 Diagnostic Messages 

The Ada compiler issues diagnostic messages on the diagnostic file. Diagnostics other than 
warnings also appear on the current output file. If a source text listing is required, the diagnostics 
are also found embedded in the list file (see Section S.3.1). 

In a source listing, a diagnostic message is placed immediately after the source line causing the 
message. Messages not related to any particular line are placed at the top of the listing. Every 
diagnostic message in the diagnostic file is followed by a line stating the line number of the 
objecbonal line. The lines are ordered by increasing source line numbers. Line number 0 is 
assigned to messages not related to any particular line. On the currem output file the messages 
appear in the order in which they are generated by the compiler. 

The diagnostic messages are classified according to their severity and the compiler action taken: 


Warning: Reports a questionable construa or an error that does not influence the meaning of the 
program. Warnings do not hinder the generation of objea code. 

Example: A warning will be issued for constructs for which the compiler detects will 
raise CONSTRAlNT_ERROR at run time. 


Error Reports an illegal construct in the source program. Compilation continues, but no object 
code will be generated. 

Examples: most syntax errors; most static semantic errors. 


Severe Reports an error which causes the compilation to be terminated immediately, 
error No object code is generated. 

Example: A severe error message will be issued if a library unit mentioned by a 
WITH clause is not presem in the currem program library. 


47 








DACS<80x86 User's Guide 
Ada Compiler 


Fatal Repons an error in the compiler system itself. Compilation is terminated immediately 

error. aixl no objea code is prodiKed. The user may be able to circumvem a fatal error by 

correcting the program or by replacing program constnicts with alternatives. Rease 
inform DDC-I about the occurrence of fatal errors. 


The detection of more erron than allowed by the number specified by the ERROR_LlMrr 
parameter of the configuration file (see section 522 ) is considered a severe error. 


5 Fonmt and Content of Diagnostic Messages 

For certain syntactically incotiea constnicts. the diagnostic message consists of a pointer line and 
a text line, other cases a diagnostic message consists of a text line only. 

The pointer line contains a pointer (a carat symbol to the offending symbol or to an illegal 
character. 

The text line contains the following information: 

• the diagnostic message identification "• * ***" 

• the message code XY-Z where 

X is the message number 

Y is the severity code, a letter showing the severity of the error 

W: warning 
E: error 
S: severe error 
F: fatal error 

Z is an integer which, together with the message number X. uniquely identifies the compiler 
location that generated the diagnostic message; Z is of importaiKe mainly to the compiler 
maintenance team - it does not contain information of interest to the compiler user. 

The message code (with the exception of the severity code) will be suppressed if the 
parameter SUPPRESS.ERROR.NO in the configuration file has the value TRUE (see 
section S.2.2). 

• the message text; the text may include one context dependent field that contains the name of 
the offending symbol; if the name of the offending symbol is longer than 16 characters only 
the first 16 chapters are showit 

Examples of diagnostic messages: 

18H-3: Warning: Exception CtWSTRAZNTJERROR will be raised here 

*** 320E-2: Name OBJ does not denote a type 
*** S3SE'-0: Expression in return statement missing 


48 


DACS*80x86 User’s Guide 
Ada Ompiler 


*** 1S08S-0: Specification foe this package body not present in the library 


5.4 The Program Library 

This section briefly describes how the Ada compiler dianges the program library. For a mote 
general description of the program library, the user is tefetied to Chapi^ 3. 

The compiler is allowed to read horn all sublibraries constituting the cunem program library, but 
only the cunem sublibtary may be changed. 


5.4.1 Correct Compilations 

In the following examples it is assumed that the compilation units ate correctly compiled. i.e.. that 
no errors are detected by the compiler. 


Compilation of a library unit whtdi is a declaration 

If a declaration unit of the same name exists in the currem sublibrary, it is deleted together with 
its body unit and possible subunits. A new declaration unit is insetted in the sublibrary, together 
with an empty body unit 

Compilation of a library unit which is a subprogram body 

A su^togtam body in a compilation unit is treated as a secondary unit if the currem sublibrary 
contains a subprogram declaration or a generic subprogram dedarauon of the same name and this 
declaration unit is not invalid. In all other cases it will be treated as a library unit i.e.: 

• when there is no library unit of that name 

• when there is an invalid declaration unit of that name 

• when there is a package declaratiait generic package declaration, an instantiated package, cr 
subprogram of thiu name 


Compilation of a library unit which is an instantiation 

A possible existing declaration unit of that name in the cunem suUibrary is deleted together with 
its body unit and possible subunits. A new declaration unit is inserted. 


Compilation of a secondary unit which is a library unit body 

The existing body is deleted from the sublibtaty together with its possible subunits. A new body 
unit is inserted. 


49 




DACS*80x86 User's Guide 
Ada Compiler 


Compilatioii of a secondary unit which is a subunit 

If the subunit exists in the sublibiary it is deleted together with its possible subunits. A new 
subunit is insened. 


5.4JI Incorrect Conq)ilations 

If the compiler detects an error in a compilatioo unit, the (xogram library will remain unchanged. 

Note that if a file consists of several compilation units and an error is detected in any of these 
compilation units, the program library will not be updated for any of the compilation units. 

5J Instantiation of Generic Units 

This section describes the rules after which generic instantiation is performed. 

5J.1 Order of Compilation 

When instantiating a genetic unit, it is requited that the entire unit, including body atxl possible 
subunits, be compiled before the first instantiation. This is in accordance with the ARM Chapter 
10.3 (1). 


SJJ Generic Formal Private Types 

The present section describes the treatment of a generic unit with a generic fonnal private type, 
where there is some construa in the genetic unit that requites that the corresponding actual type 
must be constrained if it is an array type or a type with discriminams. and there exists 
instantiations with such an unconstrain^ type (see A^. Section 12.32(4)). This is considered 
an illegal combination. In some cases the error is detected when the instantiation is compiled, in 
other cases when a constraim-tequiring construa of the genetic unit is compiled: 

1) If the instantiation appears in a later compilation unit than the first constraim-tequiring 
construa of the generic unit, the error is associated with the instantiation which is rejected 
by the compiler. 

2) If the instantiation appears in the same compilation unit as the first constraim-tequiring 
construction of the genetic unit, there ate two possibilities: 

a) If there is a constraim-requiiing construction of the gerwric unit after the instantiation, 
an error message appears with the instamiatitm. 

b) If the instantiation appears after all constraim requiring constructs of the generic unit 
in that compilation unit, an error message appean with the constraim-tequiring 
construct, but will refer to the illegal instantiation. 


50 




DACS-80x86 User's Guide 
Ada Compiler 


3) The instantiation appears in an earlier compilation unit than the hist constraint-requiring 
construction of the generic unit, which in that case will appear in the generic body or a 
subunit. If the instantiation has been accepted, the instantiation will correspond to the 
generic declaration only, and not include the body. Nevertheless, if the generic unit and 
the instantiation are located in the same sublibrary. then the compiler will consider it an 
error. An error message will be issued with the constraint-requiring construa and will refer 
to the illegal instantiation. The unit coiuaining the instantiation is not changed, however, 
and will not be marked as invalid. 


5.6 Uninitialized Variables 

Use of uninitialized variables is not flagged by the compiler. The effect of a program that refers 
to the value of an uninitialized variable is undefined. A cross-reference listing may help to find 
uninitialized variables. 


5.7 Program Structure and Compilation Issues 

The following limitations apply to the DACS-80x86 Ada Compiler Systems for the Real Address 

Mode and 286 protected mode only: 

• The Ada compiler supports a "modified large" memory model for data references. The 
"modified large" memory model associates one data segmem for each hierarchical sublibrary in 
the Ada program library. All package data declared within a sublibrary is efficiently referenced 
from Ada code compiled into the same sublibrary. A slight increase in code size results from 
referencing package dau compiled into a different hierarchical level. Intel’s medium memory 
model can thus be obtained by utilizing only one level of Ada program library, the toot 
sublibrary. 

• The Ada compiler supports a lai^e memory model for executable code. Although the size of 
a single compilation unit is restricted to 32K words, the total size of the code portion of a 
program is not restricted. 

• The space available for the static dau of a compilation unit is 64K - 20 bytes. 

• The space available for the code generated for a compilation unit is limited to 32K words. 

• Any single object cannot exceed 64K - 20 bytes. 

The following limiutions apply to all DACS-80x86 products: 

• Each source file can ctmtain, at most, 32,767 lines of code. 

• The name of compilation units and identifiers may not exceed the number of characters given 
in the INPUT.LINELENGTH parameter of the configuration file. 

• An integer literal may not exceed the range of LONG.INTEGER. a real literal may not exceed 
the range of LONG.FLOAT. 


51 




DACS*80x 86 User’s Guide 
Ada Cdmpiler 


foimal parweten penniaed in a proceduie is limited to 127 per parameter 
specincttoa *n)ere is no limit tm the number of proceduie specifications. For example, the 
declaranon: 

procedure OVER^LIMIT (INTEGEROl, 

INTEGER02. 

• • • • « 

1NTEGER166; in INTEGER); 

exceeds the limit, but the proceduie can be accomplished with the following; 

procedure UNDER_L1M1T (INTEGEROl : in INTEGER; 

INTEGER02 : in INTEGER; 

INTEGER166 : in INTEGER); 

The riwve limitations are diagnosed by the compiler. In practice these limiudons are seldom 
resmcuve and may easily be circumvented by using subunits, separate compilation, or creating new 


5.8 Compiler Code Optimizations 

Ada compiler for the iAPX 80x86 microprocessor family generates compact, efficient 
co^. This effiaency is achieved, in part, by the compiler's global optimizer. Optimizations 
performed include: 

• Common subexpression elimination 

• Elimination of redundant constraint 

• Elimination of redundara elaboration checks 

• Constam folding 

• Dead code elimination 

• Optimal register allocation 

• Selection of optimal jumps 

• Optional iun*time check suppression 


52 



LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 


B-2 







6 THE ADA LINKER 


The DACS linker must be executed to create an executable program in the target environmem. 
Linking is a two suge process that includes an Ada link using the compilabon units in the Ada 
program library, and a target link to integrate the application code, run-time code, and any 
additional configuration code developed by the user. The linker performs these two stages with a 
single command, providing options for controlling both the Ada and target link processes. 

This chapter describes the link process, except for those options that configure the Run-Time 
System, which is described in detail in Qiapter 7. 


6.1 Invoking the Linker 

Enter the following command at the shell to invoke the linker 
S ada-Jink {<option>} <unit-naiiie> 
where the options and parameters are: 

Ada Linker Options 


OPTION 

DESCRIPTION 

REFERENCE 

•[nojdebug 

Links an application for use with the 

DACS-80x86 Symbolic Cross Debugger. 

6.5.11 

•enable_task_trace 

Enables trace when a task terminates in 
unhandled exception. 

6.528 

•exception_space 

Defines area for exception handling in task stack. 

6.529 

•[nolextract 

Extracts Ada Object modules 

6.5.14 

-intemipt_entryjable 

Range of interrupt entries. 

6.5.27 

•library 

The library used in the link. 

6.5.7 

•[nojlog 

Specifies creation of a log file. 

6.5.9 

-It_seginent_si 2 e 

Library task default segment size. 

6.523 

•It3stack_size 

Library task default stack size. 

6.5.22 

•inp_segnient_size 

Main program segment size. 

6J.25 

•tnp~stack_size 

Main program stack size. 

6.524 

•[nolnpx 

Use of the 80x87 numeric coprocessor. 

6J.16 

-options 

Specihes target link options. 

6.5.6 

-priority 

Default task priority. 

6.5.18 

•reserve_stack 

Size of reserve sack. 

6.521 

•rms 

Select Rate Monotonic Scheduling Run-Tune 

Kernel (optional). 

6.5.13 

•[no]root_extract 

Using non-DDC-I units in the root library. 

6.5.10 


53 









DACS-80X86 User’s Guide 
The Ada Linker 


•(no]rts 

Includes or excludes the run-time system. 

6.5.12 

•sca^lib 

Target libraries or object modules to include 
in target link. 

6.5.4 

•selectiveJink 

Removes uncalled code from final program. 

6.5.8 

•sign_on 

Produce sign on and sign off messages. 

6.5.30 

•stop_bcfore-link 

Performs Ada link only. 

6.5J 

•tasks 

Maximum number of tasks or ntm-tasking 
application. 

6.5.17 

•task_storage_size 

Taidcs default storage size. 

6J.26 

•template 

Specifies temfdate file. 

6.5.15 

•timer 

Tuner resoludoa 

6JJ0 

•time_siice 

Task time slicing. 

6.5.19 


All options may be abbreviated (characters omitted from the right) as long as no ambiguity arises. 
Casing is significant for options but iwt for options keywords. 

Note: Several simultaneous links of the same program should not be performed in the same 
direaory. 


6.1.1 Diagnostic Messages 

Diagnostic messages from the Ada Linker are output on the currem output file and on the optional 
log file. The messages are output in the order they are generated by the linker. 

The linker may issue two kinds of diagnostic messages: warnings and severe errors. 

A warning reports something which does not prevera a successful linking, but which might be an 
error. A warning is issued if there is something wrong with the body unit of a program unit 
which formally does not need a body unit, e.g. if the body unit is invalid or if there is no objea 
code container for the body unit. Warnings are only output on the log file, not on the currem 
output file. The linking summary on the log file will contain the total number of warnings issued, 
even if the issued warnings have not been output. 

A severe error message reports an error which prevents a successful linking. Any inconsistency 
detected by the linker wiU, for instance, cause a severe error message, e.g. if some required unit 
does not exist in the library or if some time stamps do not agree. If the linker is used for 
consequence examination, all inconsistencies introduced by the hypothetical recompilations ate 
reported as erron. 

A unit not marked as invalid in the program library may be repotted as being invalid by the 
linker if there is something wrong with the unit itself or with some of the units it depends oa 


6.2 The Linking Process 

The linking process can be viewed as two consecutive processes. Both are automatically carried 
out when issuing the littk command ada Jink. 


54 



DACS-80x86 User’s Guide 
The Ada Linker 


The first process constitutes the Ada link process and the second constitutes the target link 
process. 

The Ada link process 

• retrieves the required Ada objea modules from the program library. 

• deieimines an elaboration order for all Ada units. 

• creates a module containing the User Configurate Data (UCD) from the specified configuration 
options to the linker and 

• creates a sheO script that carries out the target link process (i.e.. dlnkbldx86). The locate/build 
phase is an integral pan of the target link. 


If the option •stop-bcfore-Iink is NOT specified (default), the above script is executed 
automatically. Otherwise the linking process is halted at this point 

When •stop-bcforeJink is specified, all temporary files are retrieved for inspection or 
modificatiott The target linker is invoked by executing the shell script. 


6.2.1 Temporary Files 

The following temporary files are in use during the link phase: 

<main_program>_link.com The shell script which invokes the target linker. 

<main_program>_elabcode.o The objea code for the calling sequence of the elaboration 

code. 

<main_program>.ucd.o The objea code generated from the RTS configuration 

options (see Section 7.2). 

<main_program>_uxxxxx.o The Ada objea modules which have been extracted from the 

program library, xxxxx is the unit number of the Ada unit 


55 







DACS-80XS6 User's Guide 
TIk Ada Linker 





Figure 6-3. The Linking Process 


The following components make up the run-time system: 

1) User configurable portion of the RTS 

a) User configurable dau (UCD) and 

b) User configurable code (UCQ 

2) Pennanent pan of the RTS 

a) Non-taddng RTS (r 11 Jib) or 

b) Tasking RTS (rl2Jib) 

c) RMS Tasking RTS (rl 3 Jib) 

The User Configurable Code (tefined by the environmental variable ada_uGcJib is included in the 
link. If no tasking has been specified, then the RTS non-tasking library''(rIIJib) will be included. 
If tasking has been specified, then suppon for tasking will be included (rl2Jib or, when -rms, 
i!3.1ib). 


36 












DACS-80x86 User’s Guide 
The Ada Linker 


*rhe output of the linker step is an absolute executable ob^ file with the extension ".dat” and 
a map file with the extension "jnpS". 


6^ Environmental Variables 

When a link is executed, a number of flies are referred to and most are accessed through 
environmental variables. The locate/build phase uses the control file Sada.ucc_dir/bonflg.bld_ddci. 
the remaining variables are: 


VARUBLE 

PURPOSE 

ada_system_library 

Identifies the root library where the system compilation units reside. 

ada_library 

Identifies the default library used by all DACS-80x86 tools. It is the 
lowest level sublibrary in the program library hierarchy. 

ada_rootjib 

Identifies the OMF library where the system library units have been 
extracted fiom the system library. By having a separate Library for the 
root compilation units, the link process is much faster than otherwise 
having to extract each unit from the system library for each link. 

ada.rl l_lib 

Identifies the OMF library for the Peimanem Part of the non-tasking 
version of the Run-Time System. 

ada.rl2_Iib 

Identifies the OMF library for the Permanent Part of the tasking version 
of the Run-Tune System. 

ada_rl3Jib 

Identifies the OMF library for the Petmanem Pan of the optional Rate 
Monotonic scheduling Run-Tune System. 

ada_ucc_lib 

Identifies the OMF library for the User Configurable Code portion of 
the Run-Time System. 

ada_iemplate 

Identifies the template file for the Linker. 

ada.ucc-dir 

Identifies the directory of the curtem UCC. 


With each of these environmental variables, the name will differ depending on bow the system 
was installed (ada86, adal86 etc). 'Throughout this documem ada is assumed. For example, the 
environmental variables for the root library for the 80186 version of the compiler would be 
adal86_rQOt_lib, and the RTS UCC library environmental variaUes for the 8066 version would 
be adaM_utx_Ub. 


57 



DACS-80x86 User's Guide 
‘Hie Ada Linker 


6J Run<Tiine System Overview 

The Run-Time System for DACS-80x86 is defined as all code and data, other than the code and 
dau produced by the code generator, required to make an embedded system application operate 
properly on a specific hardware system. 

In general, there are two major components that make up the Run-Time System. 

1) Code and dau assumed to exist by the code generator. This is hardware independent and 
known as the RTS Permanent Pan. 

2) Code and dau tailoring the application with respect to the characteristics of the hardware 
and other requirements of the embedded systems developer. This code is called the RTS 
User Configunble Part 

Both of the above components consist of modular OMF libraries. The modules are only included 
in the user program if they are needed, i.e.. if a call or reference is made to the module. This 
ensures a compact RTS (typical applications are 4 KB to 10 KB). 

The RTS Permanent Pan does not make any assumptions about the hardware other than an 80x86 
and some amount of memory available. 

There are several versions of the RTS User Configurable Pan available for different development 
targets. Also, the source code is provided to allow the modification of the User Configurable 
Code (UCC) to operate on other 'argets. Refer to the RTS Configuration Guide for complete 
information on minifying the UCC. 

DDC-I has carefully analyzed and selected the pans of the Run-Time System that must be 
configurable for hardware independence, freeing the user from major rewrites whenever the 
Run-Time System is retargeted while, still allowing for almost unlimited adaptability. 

Four imporunt features of the run-time system are: 

• It is small 

• It is completely ROMable 

• It is configurable 

• It is efficient 


Conceptually, an Ada nm-time system can be viewed as consisting of the following components: 

• Executive. i.e.. the stan-up mechanism 

• Storage Management 

• Tasking Management 

• Input/Output 

• Exception Handling 


58 




DACS-80x86 User's Guuk 
The Ada Linker 


• Run-Tune Library Routines 

• Package CALENDAR suppon routines 


The nin>tinie system (RTS) can be configured by the user through Ada Linker command options. 
The Ada Linker will generate appropriate dau stniciures to lepresem the configured characteristics 
(UCD). 

Two veisions of the RTS are supplied, one including tasking and one excluding tasking. The 
linker selects the RTS veision indudir^ tasking only if the option ‘tasks is presem or •tasks n 
is presem and n > 0. Otherwise, the linker selects the RTS version excluding tasking. 


6.4 Linker Elaboration Order 

The elaboration order is primarily given by the unit dependencies, but this leaves some freedom 
here and there to arbitrarily choose between two or more alternatives. This arbitrary is in the 
DACS-80 x 86 linker comroUed by the speUing of the involved library units, in order for "free” 
units to become alphabetically sorted. 

Recompiling from scratch, an entire system may thus affea the allocation of unit numbers, but the 
elaboration order remains the same. 

It is also attempted to elaborate "body after body", so that a body having a with to a specification, 
will be aaempied elaborated c^ter the body of this specification. 

Also elaboration of units from diff^rem library levels is attempted to complete elaboration of a 
father-level prior to the son-leveL 

This strategy should in many cases reduce the need for resetting pragma ELABORATE. 


6J Ada Linker Options 

This section describes in detail the Ada linker option atxl parameters. 


6J.1 The Parameter <unit-name> 

<unit>natne> 

Tire <unii_name> must be a library unit in the cutiem program library, but not necessarily of the 
cunem sublibrary. 

Note that a main program must be a procedure withottt parameters, and that <unit-name> is the 
identifier of the procedure, not a file specificatioa Tire main procedure is not dredced for 
parameters, but the execution of a program with a main procedure with parameters is undefirred. 


59 








DACS-80X86 User's Guide 
The Ada Linker 


6JJ The Paramcicr <r econipUatioo-spcc> 

The syntax of <rccoiiipilatioii>spco is: 

<uiiit_spco(*body|<4pcdficatioa](^] 

This parameter tdb the linker to petfonn a oonsistency check of the entiie program u»ng the 
hypodieticai recompilation of all units designated in the <recompilatioa>spec>. The link process 
in this instance is not actually p e i fonned. 

The <unit.speo is a list of unit-names (wildcards are allowed), separated by comma (.) or plus 
(4-). Each umt-name should include an option to indicate if the body or spedlicaiion is to be 
hypothetically compiled (-qrec is the default). 


6J3 Required Recompilations 

If the consistency chedc found that recompilations are required, a list of required recompilations 
is written to the cuirem output file or to a text file if the -log qxion is specified (the name of 
Jie text file is indicated in the log file, line 8). The lis will include any inconsistencies detected 
m the library and recompilations required by the hypothetical recompilations specified with the 
options -declaration and -body. 

The entries in the list contain: 

1) The unit name. 

2) Indication of what type of unit (declaration unit, body unit, or subunit). 

3) If the unit is specified as recompiled with the -dedaratlon or -body option, it is matked 
with "-R-". 

4) The environmental variaUe of the sublibraiy containing the unit 

In the recompilation list the units are listed in a recommended recompilation order, consistem with 
the dependencies among the units. 


6J.4 -searchlib 

•searchlib <file_naine> {,<filc_namo} 

The -searchlib option directs the Ada Linker to search the specified 80x86 target libraries for 
objea modules in order to resolve symbol references. The 80x86 target libraries for otajea files 
will be searched before the DACS Run-Time System (RTS ) Igy ary normally searches for nm-time 
routines; in this way one can replace the standard DACS RTS routines with custom routines. 

The -sear chlib option is also intended to specify libiaries of modules referenced from Ada via 
pragma INTERFACE 


60 




OACS*80x 86 User’s Cuitk 
Tbe Ada Linker 


Examples: 

$ adaJink -Kardilib interfacejib p 

Links the subprogram p. resolving referenced symbols flia with the target library imerface.Iib 
and then with the siartdard RTS target library. 


6JJ •stop.bcfore-link 
•stop_beforeJink 

The •stop_bcfbrcJink option allows the user to introduce assembkis and linkers from third 

parties or~to othnwise configure the link to suit the api^cation. The link is halted with the 

following conditions: 

• The user configurable data file. <main>-ucd.o, is produced with the default or user specified 
linker option values included. 

• The elaboration code is contained in the <main>-elabcode.o file. 

• The shell script file that comains the link command is presem and has not been executed. The 
file's name is <main>_link.com. 

• The temporary Ada object file(s) used by the target linker are produced. These objects are 
linked and deleted when <main>_link.com is executed. 

• With -sciectivejink the objea files comprise all Ada units including those from the toot 
library. At this ^int it is possible to disassemble the "cut” object files using -object with the 
disassembler. 

To complete the link, the <main> Jink.com script must be executed. To use third party tools, this 

file may have to be modified. 


-options 

•options <parameter> 

•options allow the user to pass options onto the target luiker. 


61 



DACS-80)(86 User’s Guide 
Run-Time System 


&5.7 -library 

•library <file-aaine> 

•library $ada Jibrary (default) 

The -library option specifies the current sublibrary, from which the linking of the main unit will 
lake place. If this option is not specified, the subUbiaiy specified by the environmental variable 
ada Jibrary is used. 


6J.8 -sdectivcjink 
-selectiveJink 

This extracts all required objea modules from the Ada library (iiKluding the root library) and cuts 
out exactly those parts that are actually called, in order to make the resulting target program 
considerably smaller. If a program uses e.g. PUT_LINE as (he only routine from TEXT.IO. the 
contribution from the TEXTJO objeo module will only contain PirT_LlNE (and whatever that 
needs). Note that disassemblies of units used in a selective link normally will not match what is 
linked, because of the cutting. Such disassemblies may though be obtained by disassembling 
directly those units that made up the selective link, by stopping the linking before the target link 
phase (•stop_bcforeJink). making disassemblies using -object and then resuming the link. 

Note also that unused constants and permanent variables are not removed. 

OrUy "level 1" subprograms may be removed. Nested subprograms (that are irot called) are to be 
removed during compilation using the -optimize option. Nested subprograms are only removed, 
if the routine in which the nesting occurs is removed. 


6J.9 -[nojlog 

•log [<flle-spec>] 

-nolog (default) 

The option specifies if a log file will be produced from the front end linker. As default, no log 
file is produced. If <rile-speo is not entered with -log the default file name for the log file will 
be link.log in the current directory. 

The log file contains extensive information on the results of the link. The file includes: 

• An elaboration order list with an entry for each unit included, showir^ the order in which the 
units will be elaborated. For each unit, the unit type, the time stamp, and the dependmicies are 
showa Furthermore, any elaboration inconsistencies will be reported. 

• A linking summary with the following information: 

• Parameters and active options. 

• The full name of the program library (the currem suUibrary and its ancestor sublibraries). 


62 





# 


DACS-80x86 User’s Guide 
The Ada Linker 

• The number of each type of diagnostic message. 

• A tenninatioo message, stating if the linking was tenninaied successfully or unsuccessfully or 
if a consequence examination was teiminated. 

• Diagr»>stic messages and warnings are written on the log fQe. 


If recompilations are required (as a result of the consistency check) a text file is produced 
conaining exempts of the log file. The name of this text file is written in the log Hie, line 8. 


The log file consists of: 

• Header consisting of die linker name, the linker version number, and the link time. 

• The elaboration order of the compilation units. The units are displayed in the order elaborated 
with the unit number, compilation time, unit type, (^pendencies, and any linking errors. 

• If retompilations are required, the units that must be recompiled are listed along with its unit 
type and sublibrary level 

• The linking summary that includes the main unit name, the program library, any recompilations 
that are reciuired. and if any errors or warnings occurred. 


6J.10 •{nolroot.extract 
•root.extract 

•noroot^extract (default) 

The units contained in the Ada system library supplied by OOC-l have been extracted and insened 
into the Sada.iootjib OMF Library, thus eliminating extractions from the system library at link 
time and improving link performance. 

The user should normally not modify or compile into the Ada system library supplied by DDC*I. 
If however, a unit is compiled into the Ada system library, the Sada.tootjib will no Itmger 
match the Ada system library and >root_extract must be ^cified in order to link from the Ada 
system library. 


6.5.11 '(noldebug 
•ttebug 

•nodebug (default) 

The •debug option specifies that debug infonnation is generated. The debug infonnadon 
required to enable symbolic debugging. If •nodebug is specified, the Ada linker will skip 
generation of debug information, thus saving link time, and will rxx insert the debug informal 


63 





DACS-SOxSd User’s Guide 
The Ada Linker 


into the chosen sublilHiry, duis saving disk space. N<Me that any unit which should be 
symboiicaUy debugged with the DDC-I Ada Symbolic Cross Debugger must also be compiled with 
the 'debug option. 


6J.12 '(nolrts 

•Its (default) 

•norts 

‘Hie •Its option directs the Ada Linker to include the appropriate Run>Time System (RTS) in the 
link, •iioits directs the Ada Linker to exclude the RTS in the link. 

The ability to exclude the Run-Ti me S ystem from the link allows the user to do an additional link 
with a private copy of a custom RTS. The Ada Linker may report unresolved references to RTS 
routines, but will still produce a relocatable object file. 


6J.13 '1111$ 


•rms 

This option selects the Rate Monotonic Scheduling Tasking Kernel (if tasking is selected). The 
default is to use the Standard Tasking Kernel. This feature is supplied as an option. 


6.5.14 '(nolextract 

•extract (default) 

•nocxtract 

This option to the linker allows the user to specify that program unit objects should not be 
extracted from the Ada program library. This option woidd be used if the user knows that many 
objects have not changed since the last link and does not want the linker to waste time extracting 
thm. 

To use this feature, the user should modify the template to not delete unit objea files after a 
target link is perfoimed. This way the objea files remain in the current directoiy (or whereever 
the user decides to put them). On sub^uem links the user can extiaa objea m o dules of 
modified units from the Ada library using the standalone DACS extraa tool. A new targa link 
can then be perfoimed using a combination of newly extracted objects and the objea files ftom 
previous links that have gone unchanged. This could sigraficantly improve linker speed when 
linking programs that share common and rarely modified libraries and when relinking programs 
that have had only a few units modified. 


64 



DACS-80x86 User's Guide 
The Ada Linker 


6J.15 -template 

•template <file-name> 

-template Sada_tempiaie (default) 

The template file is known to the linker via the environmental variable adajemplate. DDC-I 
supplies a default template file as part of the standard release system. Please lefer to t^tpendix H 
for detailed infoimation. 


6J.16 -npx 

•npx (default) 

•nonpx 

The -npx option specifies that the 80x87 (8087. 80287. or 80387) numeric coprocessor is used 
by the Ada program. When -npx is specified, the 80x87 is initialized by the task initialization 
routine, the floating point stack is reset during exception conditions, and the 80x87 context is 
saved during a task switch. 


Configurable Data 

A 16 bit boolean constant is generated by the Ada Linker 


CO NPX USED 


boolean 


s 0 • 80x87 is not used 

3 1 - 80x87 is used 


6J.17 -tasks 
•tasks (nl 

(default is no usking) 

This option specifies the maximum number of tasks allowed by the RTS. If specified, n must be 
greater than zero. If -tasks is specified without a value for n. n defaults to 10. If -tasks is not 
specified, the RTS used will not include support for tasking. If -tasks is specified, the RTS used 
will include suppon for tasking. 

Ada Interrupt tasks identified with pragma INTERRUFT.HANDLER need not be included in the 
count of maximum number of tasks. The main program must be counted in the maximum number 
of tasks. Note that the main program, which may implicitly be considered a task, will not run 
under control of the tasking kernel when -notasks -is specified. See also -irns option. 


Configurable Data 

For -tasks, the linker generates the following configurable data: 


65 








DACS>80x86 User's Guide 
The Ada Linker 


CO NM( xasu 


nfftam - m 


a Teas 


N tuk 

CoACrol 

•loeiw 

(TCMI 

ZC -af> la 
aeciv*. ■ 
niMMCie CO- 

pioeMaec 


Examine: 

S ada-link 'tasks 3 p 

• Link the program P. which has at most 3 tasks, including the main program. 


6J.18 'priority 
'priority n 

'priority 15 (default) 

The 'priority option specifies the default priority for task execution. The main program wiU run 
at this priority, as well as tasks which have had no priority level defined via pragma PRIORITY. 
The range of priorities is from 0 to 31. 

Priorides can be set on a per task basis dynamically at tun dme. See section E.I (Package 
RTS.EntryPoints) for mote details. 


Configurable Data 

The Ada Linker generates the following constant dau: 

_CD_a*xoaiTr 

Example: 

$ ada_link 'tasks 'priority 8 p 

* Link the subprogram P which has the main program and ninning at 
default priority 8. 


66 






DACS-80x86 User’s Guide 
The Ada Linker 


6J.19 •time-siice 

-time^slke [r] (default no time slicing is active) 

The ••tinie_siice options specifies whether or not time slicing will be used for tasks. If specified, 
R is a dedmal number of seconds lepiesendng the default time slice to be used. If R is not 
specified, the default time slice will be 1/32 of a second. R must be in the range Duration’Small 
^ R ^ 2.0 and must be greater than or equal to the •tuner linker option value. Time slicing only 
apidies to tasks running at equal priority. Because the RTS is a preemptive priority scheduler, the 
highest priority task will always run before any lower priority task. Oiily when two or more tasks 
are tunning at the same priority is time slicing applied to e^ task. 

Tune slicing can be spedhed on a per task basis dynamically at tun<time. See Section El 
(Package RTS.EntryPoints) for more details. 

Time slicing is not applicable unless tasking is being used. This means that the 'tasks option 
must be used for 'tinie slice to be effective. 


Conngurabie Data 

The Ada Linker generates the following data: 


_CD_T1ME_SIICE_0SED 

0 'Ho tlM slicing 
1 - Tim* slleinq 


CD TIMC SLICE 


BOOLEAM 


sbsoluf InfoT 


• representing the number Y that satisfies Y • DURATION’SMALL = R 


Example: 

S ada_link •tiine_slice 0.125 'tasks p 

• Specifies tasks of equal priority to be time sliced each eighth of a second. 


6JJ0 'timer 
•timer R 

•timer 0.001 (default) 

The 'timer option specifies the resolution of calls to the Run-Time System routine TIMER (see 
the Run-Time System Configuration Guide for DACS-SOxSfi for more information). The number, 
R, specifies a decimal number of seconds which have elapsed for every call to TIMER. The 
default TIMER resolution is one millisecond. R must be in the range DURATION’SMALL< R 
< 2 . 


67 






DACS-80X86 User’s Guide 
The .\da Linker 


Configurable Data 


The Ada Linker generates the following 16 bit constant: 


CD Tzwa 


Abaeluf Infwr 


• representing the number Y that satisfies Y * DURATION'SMALL>R 


6^J1 •reserve.stack 
•reserve stack [n] 


The •rcserve^stack option designates how many words are reserved on each task stack. This 
space is reserved for use by the RTS, which does no diecking for stack overflow. This reserved 
space also allows the RTS to function in situations such as handling a storage error exception 
arising flom stack overflow. 

The •reservc^stack option also reserves pan of the main program suck size, specified by the 
linker option'iiip_stack_stze. 


Configurable Data 


The Ada Linker generates the following integer constant: 


CD RESSRVe STACK 


IMTESEK 


Examples: 

S ada-link •reserve_stack 200 'tasks p 

• Reserve 200 words from each stack for use by the RTS. 


6^22 •It-stack.size 

•It_stack_si 2 e n 
•Itlstackisize 500(default) 

The -It stackjsize option designates the library ta^ default size in words. A library task is 
formed'when's task objea is declared at the outermost level of a package, library tasks are 
created and activated during the initial main program elaboradoiL (See the Ada Reference Manual 
for iiKire details). 


68 






OACS>80x86 User's Guide 
The Ada Linker 


For each library task, the representation spec: 

FOR Task^objeci’STORAGE_SIZE USE N; 

can be used to specify the library task stack size. However, if the representation spec is not used, 
the default library task size specified by •lt_stack_size will be used. 

For efficiency reasons, all tasks created within library tasks will have stacks allocated within the 
same segment as the library task stack. Normally, the segment which contains the library task 
stack is allocated just large enough to hold the default library task stack. Therefore, one must use 
the option •U-stack_opUon or the pragma LT_SEGMENT_SIZE to reserve more space within the 
segment that may be used for ne^ tasks’ stacks. (See the imfdementation depimdem pragma 
LT.SEGMENT.SIZE in Section F.l for more information). 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase of rhe link, and the maximum segment size (64K for all except the 386/486 
protected mode, which is 4 GB). 

Configurable Data 

The Ada Linker generates the following integer constant* 


CO IT STACK Size 


IHTESCT 


Example: 

S adaJink •It^stack^size 2048 'tasks p 

• Link the subprogram P using a 2K words default library stack size. 


6.5.23 •It-stack.size 
-lt_segment_size n 

•lt_segment_size (lt-stack_size + 20 > exception-stack space) (default) 

This parameter defines in words the size of a library task segment The library task segment 
contains the task stack and the stacks of all its nested tasks. 

The default value is only large enough to hold one default task stack. If •lt_stack_size is used and 
specifies a value other than the default value. •It_seginent_size should also be s^dfied to be the 
size of <task_stack_size> + ~ ” 

<total_ofjnested_tasks_sizes> + 

<20_words_ovcrhead> + 
exception.stack_space. 

Note that the task stack size spedfied by the *STORAGE_size can be representation spec or by 
the option 'It-stack-size. 

Dynamically allocated tasks receive thdr own segmem equal in size to the mp_segmem_size. 


69 








DACS-80x86 User's Guide 
Tbe Ada Linker 


The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase, and the maximum segmem size (64K for ail except the 386M86 protected mode, 
which is 4 GB). 


Configurable Data 


The Ada Linker generates the following dau structure: 


cs u saatENT sxzz 


niTgap 


Example: 

$ ada-Jink •lt_segment_sizc 2048 'tasks p 

• Link the program P using a library task segment size of 2K words. 


6J24 -mp^tack-size 


•mp_stack_stze n 
-mplstack_size 8000 (default) 

The 'mp^stack^size option specifies the main program stack size in words. 

The range of this parameter is limited by physical memory size, task stack size allocated during 
tlM build phase (in tasking programs only), the maximum segmem size (64K for all except the 
386/486 protected mode, which is 4 GB), and the size of mp.segmem_size. 

Configurable Dau 


The Ada Linker generates the following dau suuctures for nontasking programs: 


CD HP STACK SIZE 


nrrrgEK 


CD HP STACK 


HP^STACK.SIZE 
jwerda of" 


CO HP STACK STAKT 


BlghMt addr. 
og HP »t«clc 


For tasking programs, the Ada Linker generates the same structures but limits the size to 1024 
words. This stack is only used for the execution of the system startup code and elaboration. 
At main program activation, a segmem for the main ptognm equal to the size specified by • 
•mp_seginent_size will be allocated from the dynamic memory pool and a stadc for the main 
ptog^ equal to the size specified by 'tiip^sUck^size will be allocated from the memory 
pool. 


70 







DACS-80x86 User's Guide 
Tbe Ada Linker 

Example: 

$ adaJink 'inp^stack^sixe 1000 p 

• Link the subprogram P with a stack of 1000 words. 


6J125 •mp-segment-size 


•mp_segiiient_size n 
•mpIsegmenCsize 8100 (Default) 

The •mp_segiimt_size option specifies the size, in words, of the segnwnt in which the main 
program ^k is allocated. The default setting can be calculated from the formula: 

mp_segment_size s mp_stack.size + 

overhead + (tasks * 1) * 

(overhead * task_storage_size) 

Normally, the main program segment size can be set to the size of the main program stack. 
However, when the main program contains nested tasks, the stacks for the nested tacits will be 
allocated from the data segment which coruains the main program stack. Therefore, when the 
main program contains nested tasks, the main program stack segmem must be extended via the 
•mp_segment_size optioa 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking programs only), and the maximum segmem size (64K for all except 
the 386/486 protected mode, which is 4 GB). 

Note: Dynamically allocated tasks receive their own segmem equal in size to mp_segmem_size. 


Configurable Dau 

The Ada Linker allocates the _CDJMP_STACK (see the •inp_stack_size option) within a dau 
segment called _CD_MP_STACK_SEGMENT: 


CO MP STACK SEOMEHT 


W STACK 


T T T 

(0_STACK_STAXT I* STACK SZZX W SCOOMT SZZS 


Example: 

$ ada-link 'tasks «inp_segment_size 32000 program^a 

Links the subprogram PROGRAM_A, which contains tasks nested in the main program 
allocating 32,0(X) words for the main program stack segment 


71 







DACS-80x86 User's Guide 
Tile Ada Linker 


6JJj6 •task-storafe^ac 

•task_stonige_size n 
•tasklatoragCsize 1024 (default) 

This option sets the default storage size in words for stacks of tasks that are not library tasks. 
This value can be overridden with a representation clause. 

The range is limited by the size of the lt_segment_size (if it is a subtask to a library task), or by 
mp.segment.size (if it is a subtask to the main program). 


Configurable Data 


The Ada Linker generates the foUovidng dau structure: 


CB TASK STOMSB SZU 


nCTESEK 


6.5J7 •inteiTupt.entry_table 
•intemipt_entry_tabie L 41 

The •intemipt_entry_table option specifies the range of imemipt vector numbers used by the 
Ada program in imerrupt tasks. 

The number, L. specifies the lowest numbered interrupt handler. The number. H, specifies the 
highest numbered interrupt handler. The range for low and lu^ inienupis is 0 to 255. 


Configurable Data 

If •interrupt_entry_tablc is specified, the Ada Linker will generate the following dau structure: 


co_LOH nnawapT 


CO_BZGa IMTSMtOPT 


CO zmEMtort vector 


COWSTAWT 


C0H3TMIT 


(a-i.4>i)*s 
liocda tM«rv«d 
ter Zntertupc 
Vector_ 


tX.) 


(11 


If the user ever detects unresolved references to the symbols: 

_CD_LOW INTERRUPT 
_CD_HIGH_INTERRUPT 
_CD_INTERRUPT_VECrOR 


72 







DACS-80)i86 User’s Guide 
The Ads Linker 


the Ada progrm oomains standard tatemipt tasks for which the RTS requires the above dau 
structure. You must relink the Ada pmgrm specifying the •iatcrr^_^enti 7 _tablc option. 

Example: 

$ adaJink 'tasks •inteiTupt_cntr]r_tablc S«20 p 

• Links the subprogram P, which has staitdaid Ada imenupt entries numbered 5 
through 20. 


6JJS '{nolciuible-.taak .trace 

•cnable_task_trace 
•nocnabU_task_trace (default) 

This option insmicts the exception handler uf produce a stack trace when a task terminates because 
of an unhandled exception. 


Configurable Data 


a TMCE EUABLTD 


tootum 


■ 0 - 

- 1 - 


task trae* diaablad 
cask Csaes anablad 


6JJ9 •exception^space 

•exception_space n 
•exception-space OaOh (default) 

Each stack will have set its top area aside for exception space. When an exception occurs, the 
exception handler may switch stack to this area to avoid accidental overwrite below the stack 
bottom (which may lead to protection exceptions) if the size of the remaining part of the stack 
is smaller than the N value. Specifying a value aO will never cause stack switching. Otherwise an 
N value below the default value is not recommended. 


Configurable Data 

CD excemoa szacx space szzx 


nrexaea 


Note that this value is added to all requests for task stack space, thus requiring an increase in the 
requirements of the appropriate segmM's size 


73 









DACS-80X86 User s Guide 
The Ada Linker 


6JJ0 •rign_on 
•sifn_on (<string>] 

When this option is specified the linker will generate code to output a sign on message, before 
the Ada elaboration is initiated and a sign off message when the target program has terminated 
successfully. If the piograin tenninates with an uncaught exception, the sign off message is not 
printed. 

The sign on message consists of: 

START (<string>] <pn>gnm namo 
and the sign off message 
STOP (<stiing>] <prognm naffle> 

The <stiing> may contain spaces. e.g. 

•sign^n "Test 3" (remember the quotes). 

This facility is very useful to sepatate output from several target programs run after each other, 
and to verify that a program that produces little or no output has actuaUy been loaded and nin 
successfully. 


74 



APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647 ; 

type LONG_INTEGER is 

range -16#8000_0000_0000_0000# .. 16#7FFF_FFFF_FFFF_FFFF#; 

type FLOAT is digits 6 

range -16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 16#0.FFFF_FFFF_FFFF_F8#E256; 
type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131071.0; 


end STANDARD; 




APPENDIX F - IMPLEMENTATION-DEPENDENT CHARACTERISTICS 


This appendix describes the implememaiion-dependem characteristics of DACS-80X86^ as required 
in Appendix F of the Ada Reference Manual (ANSI/MIL-STD-181SA). 


F.l Implementation'Dqiendent Pragmas 

This section describes all implemeniation defined pragreas. 


F.1.1 Pragma INTERFACE^PELUNG 

This pragma allows an Ada prognun to call a non-Ada program whose name contains characters 
thi$ are invalid in Ada subprogram identifiers. This pragiiu must be used in conjunction with 
pragma INTERFACE, i.e.. pr^ma INTERFACE must be specified for the Ada subprogram name 
prior to using pragma INTERFACE.SPELLING. 

The pragma has the format: 

pragma INTERF.^CE.SPELLING (subprogram name, string literal); 

where the subprogram name is that of orx previously given in pragma INTERFACE and the string 
literal is the exaa spelling of the interfaced subprogram in itt native language. This pragma is 
only required when the subprogram name contains invalid characters for Ada identifiers. 

Example: 

function RTS^GetOataSegment return Integer; 
pragma INTERFACE (ASM86, RTS_GetDataSegaent); 

pragma INTERFACE_S?EI,1.ING (RTS^GetOataSegment. ”RlSMGS?GetDataSegment*') ; 

The string literal may be appended ’NEAR (or ’FAR) to specify a particular method of call The 
default is 'FAR. This suffix should only be used, when the called routines require a near call 
(writing ’FAR is however harmless). If ’NEAR is added, the routine must be in the same segment 
as the caller. 


F.1J Pragma LT-SEGMENT-SIZE 

This pragma sets the size of a library task stack segment 
The pragma has the fonnac 

pragma LT_SEGMENT_SIZE (T, N); 

where T denotes either a task object or task type and N designates the size of the library task 


193 





OACS*80x86 User’s Gui<k 
Imptemenution-Oepemtem Chanoenstics 


stack segment in words. 


The library task's stack segment defaults to the size of the library task stack. The size of the 
library task stack is normally specified via the representation clause (note that T must be a task 
type) 


for T’STORAGE.SIZE use N; 

The siss of the library task stack segment determines how numy tasks can be created which are 
nested within the lib^ task. All tasks created within a library task will have their stacks 
allocated from the same segmem as the litnary task stack. Thus, pragma LT.SECMENT.SIZE 
must be specified to reserve space within the library task stack segment so that nested tasks' 
stacks may be allocated (see section 7.1). 

The following restrictions are places on the use of LT.SEGMENT.SIS: 

1) It must be used only for library tasks. 

2) It must be placed immediately after the task object or type name declaration. 

3) The library task suck segment size (N) must be greater than or equal to the library task 
stack size. 


F.IJ Pragma EXTERNAL^AME 


F.lJ.l Function 

The pragma EXTERNAL.NAME is designed to make permanent Ada objects and subprograms 
externally available using names supplied by the user. 


F.U,2 Format 

The format of the pragma is: 

pragma EXTERNAL_NAME(<ada_entity>.<exterrul name>) 
where <ada_entity> should be the name of: 

• a pennanem object, i.e. an objea placed in the permanem pool of the compilation unit - such 
objects originate fnxn package specifications and bodies otily, 

• a constant object, i.e. an objea placed in the constant pool of the compiladtm unit • please 
note that scalar constants are embedded in the code, and composite constants are not always 
placed in the constant pool, because the constant is not considered constam by the compiler. 


194 




DACS-80X86 User's Guide 
Impieineiuation>DependefU Cbaracterisucs 


• a subprogram name, i.e. a name of a subprogram defined in this compilation unit • please 
notice that separate subprogram specifications cannot be used, the code for the subprogram 
must be present in the compilation unit code, and where the <extemal name> is a string 
specifying the external name associated the <ada_entity>. The <extemal names> should be 
unique. Specifying identical spellings for different <ada_entiues> will generate errors at compile 
and/or lirik dme. and the responsibility for this is left to the user. Also the user should avoid 
spellings similar to the spellings geiKtated by the compiler, e.g. E_xxxxx_yyyyy. P.xxxxx, 
C.xxxxx and other internal identifications. The target debug type information associated with 
such external names is the null type. 


F.UJ Restrictions 

Objects that are local variables to subprograms or blocks cannot have external names associated. 
The entity being made external ("public") must be defined in the compilation unit itself. Attempts 
to name entities ftom other compilation units will be rejected with a warning. 

When an entity is an object the value associated with the symbol will be the relocauble address 
of the first byte assigned to the objea 


F.U.4 Example 

Consider the following package body fragment: 

package body example is 

subtype stringlO is string<1..10); 

type s is 
record 

len : integer; 
val : StringlO; 
end record; 

global_s : s; 

con3t_s : constant stringlO :■ "1234567890'*; 

pragma EXTERNAI._NAME (global_3, "GI,OBAL_S_OBJECT") ; 
pragma EXTERNAL_NAME(const_3, "CONST_S"r; 

procedure handle (...) is 

end handle; 

pragma EXTERNAL_NAME(handle, "HANDI.E_PROC"); 


end example; 

The objects GLOBAL_S and CONST_S will have associated the names "GLOBAL_S_OBJECT" 
and "CONST.S". The procedure HANDLE is now also kruwn as "HANDLE_PROC". It is 


195 


DACS*80x86 User’s Guide 
I m p tonen mion-Dependent CharacteristiGs 


allowable to assign more than one external name to an Ada entity. 


F.UJ Object Layouts 

Scalar objects are laid out as described in Chapter 9. FOr arrays the objea is described by the 
address of the fim element; the array constraintfs) are NOT passed, and therefore it is 
recommended only to use arrays with known constraints. Non* discriminated records take a 
consecutive numb^ of bytes, whereas records may contain pointen to the heap. Such 

complex objects should be made externally visible, only if the user has thorough knowledge about 
the layout. 


F.lJil Parameter Passing 

The foUovtang section describes briefly the fundamentals regarding parameter passing in ctmnection 
with Ada subprograms. For more detail, refer to Chapter 9. 

Scalar objects are always passed by value. For OUT or IN OUT scalars, code is generated to 
move the modified scalar to its destination. In this case the stack space for parameters is not 
removed by the procedure itself, but by the caller. 

Composite objects are passed by reference. Records are passed via the address of the first byte 
of the record. Constrained arrays are passed via the address of the fust byte (plus a bitoffset when 
a packed array). Unconstrained arrays are passed as constrained arrays plus a pointer to the 
constraints for each index in the array. These constraints consist of lower and upper bounds, plus 
the size in words or bits of each element depending if the value is positive or neg^ve 
respectively. The user should study an appropriate disassembler listing to thoroughly understand 
the compiler calling conventions. 

A function (which can only have IN parameters) returns its result in registerfs). Scalar results are 
registers/float registers only; composite results leave an address in some registers and the rest, if 
any, are placed on the stack top. The stack still contains the parameters in this case (since the 
function result is likely to be on the stack), so the caller must restore the stack pointer to a 
suiuble value, when the function call is dealt with. Again, disassemblies may guide the user to 
see how a panicuiar function call is to be handled. 


F.1.4 Pragma INTERRUPT-HANDLER 

This pragma will cause the compiler to generate fast iruerrupt hatuUer enuies instead of the normal 
task calls for the entries in the task in which it is specified. It has the format: 

pragma INTERRUPT.HANDLER; 

The pr^a must appear as the first thing in the speciheation of the task object The task must 
be specified in a package and not a procedure. See Section F.6.2.3 for more details and lestrictions 
on specifying address clauses for task entries. 


1 % 







OACS-80x86 User's Guide 
Impleinemauon>Dependem Chancteristics 


F.IJ Pragma MONITOR_TASK 


F.U.l Function 

The pragma MONITOR.TASK is used to specify that a task with a certain structure can be 
handled in a special way by the Run-Tune Systm. enabling a very efTiciem context switch 
operation. 


F.UJ Format 
The foraiat of the pragma is 
pragma MONTTORJTASK; 

The pragma must be given in a task specificadon before any entry declarations. 


F.UJ Restrictions 

The following restrictions apply on tasks containing a pragma MONTTOR.TASK : 

• Only single anonymous tasks can be "monitor tasks". 

• Entries in "monitor tasks" must be single entries (i.e. not family entries). 

• The task and entry attributes are not allowed for "monitor tasks" and "monitor ' ’ entries. 

• The <declarative part> shouTld only contain declaration of objects; no types or nested sturctures 
must be used. 

• The structure of the task body must be one of the following: 

tMk body MON_TASK la 
<d«clar«cl^ part> 
b« 9 ln 

<scat«BMnt llst> 
loop 

salacc 

aeeapt ENTRY KparaaMtar llst> tde 
•ndj; ~ 

or 

aeeopt ENTRY_2<p«raaMtor_llst> Ido 
<ac«c«aMnt~llsc> ~ 

•nd]; ~ 

or 

tormlnato 
•nd s«l«et; 

•nd loop; 

•nd; 


where each entry declared in the specirication must be accepted unconditionally exactly once. 


197 




DACS-80x86 User's Guide 
IinplenieniJtion*Oependem Characteristics 


2 . 

task b«Uy HOM_TASX Is 
<daclaraciM parc> 
b«9tn 

<stscaaMnt llst> 
loop 

aeeapc HON_eNTIlY<pacaaMtac_llst>tdo 
<scataawnc_llst> ~ 

and!; ” 

and loop; 
and; 

where the task only has one entry. 

In both cases the declarative pans, the statement liss and the parameter lists may be empty. 
The statement list can be arbitrarily complex, but no nested selea or accept statements are 
allowed. 

No exception handler in the monitor task body can be given. 

The user must guarantee that no exceptions are propagated out of the accepts. 


F.1,5.4 Example 

The following tasks can be defined 

task IISZ HANDLER Is 

pCSqM monitor TASK; 
sntry INSERT(ELCH:ELEM TYPE); 
snciy REMOVE (ELZM:out ELEM TYPE) ; 
sntry is PRESENT(ELEM:ELEm'TYPE; 

RESOLTiout^BOOLEAN); 

snd LIST_aANDLER; 

task body LIST HANDLER is 
‘dsflns list* 

bs9ln 

•inisiaiixs ll»f 
sslact 

aeespt INSERT (ELEM :ELEM_TYPE) do 
*lnasrt In lljt* ~ 
and INSERT; 
ox 

aceopc REMOVE (CLEM; out CLEM_TYPE)do 
*£lnd In list and rsaovs ftoa list* 
and REMOVE 
or 

aceapt IS_PRESCNT(ELCM;eLIM_rYPE 

RES: out ioOLEANIdo 

'scan list* 
and IS.PRESCNT; 
or ~ 

taxsanata, 
and salaet 

and MON TASK; 


The task can be used 

task typa L1ST_DSER Is 

snd LIST_OSCR; 

task body LIST.OSCR Is 


198 






DACS-80x86 User’s Guide 
Implemenution-Dependeiu Chancteiistics 


b««ln 

LIST UMOLEK.nUEXKrZMT SUM) ; 

cals* nunT.tXROR; 
and aalaet; ~ 
loop 

t.IST_HJUISIXX. niSEltT(lieXT_EUH) ; 
and loop: ~ 

and LIST OSER; 


F.l^ Pragma TASK_STORAGE_SIZE (T. N) 

This pragma may be used as an alternative to the attribute TASK_STORAGE_SIZE to designate 
the storage size (N) of a particular task objea (T) (see section 7.1). 


FJ Implementation-Dependent Attributes 
No implementation-dependent attributes are defmed. 


FJ Package SYSTEM 

The specifications of package SYSTEM for all DAC:S-S0x86 in Real Address Mode and 
DACS-80286PM systems are identical except that type Name arxl constant System_Name vary; 


Compiler Svstem_ System Name 

DACS-8086 iAPX86 

DACS-80186 iAPX186 

DACS-80286 Real Mode iAPX286 

DACS-80286 Pioteaed Mode iAPX286^PM 


Below is package system for DACS-8086. 

packag* Systaa la 

typ* Hoed la now Intagac: 

typ* DHoed la now Long_lntag*c; 

typ* OnalgnadHocd la rang* 0..C3S3S; 

for QnalgnadHord'SIZE ua* 1(; 

typa byta la rang* 0..235; 

for byta' SIZE us* S; 

subeypa Sagmantid la OnalgnadNord; 

typa Addraas la 

racoed 

offsat : OnalgnadKord; 
aagoMnt : Sagmantid; 
and raeoed; 

aubtypa Priority la Intagar rang* 0..31; 


199 






DACS*80x86 User's Guide 
Inqdemenuiion-Oependefu Chaiacteiistics 


typa lUM Is <lArxt«>; 

STStlM MMC : censtSOC IUbmi lAPXtC; 

SXOMti OMIT ; constant :• IS; 

lOMORY Size : constant 1_04S SYS; 

MZM nf : constant ;• -2 ISY 413 S47-1; 

HAX'INT ; constant ;> 2_l47 4S3 S47; 

MJUc'dISITS : constant IS; 

mx'lOIRISSA : constant :« 31; 

rim.OELTA : constant :• 2S1.0SK-31; 

TZCX~ : constant :• 0.000_000_12S; 

typo intorZaeo languago la 

(Asms, piMS, ess. css uvntse, 

ASM ACT, SUM ACT, C ACT, C nVEKSE ACT, 
ASMjMAcr, piMjnAcr, c~iiQAcr. c~iisvsMEjnAer) ; 

typo txeaptlonid la caeocd 

unlt_nuabor : OnalgnodMocd; 
unlquo_niiaboc : OnalgnodMocd; 
ond coeocd; 

typo taskValua la now Xntoqoc; 

typo AecTaskValuo is aecoas TaskValuo; 
typo SonaphoroValuo la now Into^oc; 

typo SasMphoro is rococd 

counter ; Intoqor; 

flcst : TaskValuo; 

last : TaakValuo; 

SQHoxt : SoaaphocoValuo; 

— only usod In BOS. 

and rococd; 

ZnltSaaaphora : constant Soaaphoro SOBaphoro'(1,0,0,0); 
and SyatOB; 


The package SYSTEM speciftcation for DACS<80386PM package system is: 

packavo Systaa Is 

typo Word Is now S)iort_Intovor; 

typo DHord is now intovor; 

typo QWord Is now Lan 9 _Inta 9 as; 

typo OnslvnodNocd Is range 0..SSS3S; 

for UnaIgnadHord'Size use 16; 

typo OnslgnodDHord Is range 0. .lSSrrFF_mTS; 

for OnslgnodDHocd'SIZE use 32; 

CyP* Byte la range 0..2S5; 

for Byte'SIZE use S; 

subtypo Sagmontld Is UnalgnodHocd; 

typo Address is 

cocord 

offset : OnslgnadDWord; 
sagMnt : Sognontld; 
ond rococd; 


for Address use 
record 

offset at 0 range 0..31; 
sogaant at 2 range 0..1S; 
ond rocord; 


subtype Priority Is Intagor range 0..31; 


200 









DACS*80x86 User’s Guide 
linplementaiion>Dependem Chaiactenstics 


cyp« EMM 

U (UFXStC.m; 



SYSTCM mm 

: constant Mmm 


1A»X3S« fM; 

sTCKxa mxT 

: eonotaat 


l«; 

mMOKY SIZE 

: constant 


ICIl 0000 0000*; 

Mill IMT 

: constant 


-ICMOOO 0000 0000 oooot 

mx'ZNT 

: constant 


is#7iTr rrrr frrr rrrr#; 

MAX~0I3XrS 

: constant 


13; 

lttX~MMITZSSA 

: constant 


31; 

rare DBLXx 

; constant 


2*1.0*K-31: 

tick" 

: constant 


0.000_000_0€2_S; 


typ« Ine«rf«e*_laagiia 9 « la 


(Asme. 

fime. 

esc. css sKvnsz, 

ASM_ACr, 

PLM ACT, 

C ACT. C SEVEASS ACT. 

ASN~NOACr, 

nM~MQAcr, 

c~iioAcr, c~ seveme'iioac 


typ« Cxcaptlonld la racerd 

unlt_nuab«r : OnalgnadOWocd; 
ualqua_nuaib«r : OnalgnadOHerd; 

•nd raeerd; 

typ* TaakValua la naa Inta^ar; 
cypa AecTaakvalua la aeeaaa Taakvalua; 
cypa SanMphoraValua la naw Intafar; 

cypa Sanaphota la caeord 

eountar 
flrat. laat 
SONaxt 

and racord; 

InlcSamaphoca ; eaaatant SaMphora :■> SaaMphota'(l.O.O.O); 
and Syatam; 


Intaqar; 

TaakValua; 

SaaaphocaValua: 

— only uaad In EDS. 


F.4 Representation Clauses 

The DACS-80x86'’^ fully supports the 'SIZE representation for derived types. The representation 
clauses that are accepted for non-derived types are described in the following subsections. 


F.4.1 Length Clause 

Some remarks on impiementaiion dependent behavior of length clauses are necessary: 

• When using the SIZE attribute for discrete types, the maximum value that can be specified is 
16 bits. For DACS-80386PM/80486PM the maximum is 32 bits. 

• SIZE is only obeyed for discrete types when the type is a pan of a composite object. e.g. 
arrays or record^, for example: 

type byte is range 0..2S5; 
for byte'size use 8; 

sixteen_bits_allocated : byte; — one word allocated 


201 








DACS*80x86 User's Guide 
Implementaaon-Dependem Characteristics 


eight_bit_p«r_«l«jn«nt ; array(0..7) of byte; — four words allocated 
type rec is 
record 

cl,c2 ; byte; — eight bits pet component 

end record; 


• Using the STORAGE.SIZE attribute for a coUectitm will set an upper limit on the total size 
of objects allocated in this collection. If further allocation is attempted, the exception 
STORAGE.ERROR is raised. 

• When STORAGE.SIZE is specified in a length clause for a task type, the process stack area 
will be of the specified size. The process stack area will be allocated inside the "standard" stack 
segment. Note that STORAGE.SIZE may not be specified for a task object 


F.4J Enumeration Representation Clauses 

Enumeration represeiuation clauses may specify represenutions in the range of -32767..-I-32766 (or 
-16#7FFF..16#7FFE). 


F.4J Record Representation Clauses 

When representation clauses are applied to records the following restrictions are imposed: 

• if the component is a record or an unpacked array, it must stan on a storage unit boundary 
(16 bits) 

• a record occupies an integral number of storage units (words) (even though a record may have 
fields that only define an odd number of bytes) 

• a record may take up a maximum of 32K bits 

• a component must be specified with its proper size (in bits), regardless of whether the 
component is an array or not (Please note that record and unpacked array components take up 
a number of bits divisible by 16 (sword size)) 

• if a non-array component lias a size which equals or exceeds one storage unit (16 bits) the 
component must start on a storage unit boundary. i.e. the componem must be specified as: 

component at N range 0..16 * M • I: 

where N specifies the relative storage unit number (0,1,...) from the beginning of the record, and 

M the required number of stor^ units (1,2,...) 

• the elements in an array componem should always be wholly contained in one storage unit 

• if a component has a size which is less than one storage unit, it must be wholly contained 
within a single storage unit: 


202 








DACS*80x86 User's Guide 
Implemenution-Dependem Characteristics 


componera at N range X .. Y; 

where N is as in previous paragraph, and 0 <s X <a> Y <s 15. Note that for this restriction 
a component is not required to start in an integral number of storage units from the beginning 
of the record. 

If the record type contains components which are not covered by a component clause, they are 
allocated consecutively after the componem with the value. Allocation of a record component 
without a component clause is always ^gned on a storage unit boundary. Holes created because 
of componem clauses are not othervrise utilized by the compiler. 

Pragma pack on a record type will attempt to pack the components iK>t already covered by a 
representation clause (perhaps none). This padting will begin with the small scalar components and 
larger components will follow in the order specified in the record. The packing begins at the first 
storage unit after the components with representation clauses. 


F.4J.1 Alignment Clauses 

Aligiunent clauses for records are implemented with the following characteristics: 

• If the declaradon of the record type is done at the outermost level in a library package, any 
alignment is accepted. 

• If the record declaration is done at a given static level higher than the outermost library level, 
i.e.. the permanent area), only word alignments are accepted. 

• Any record object declared at the outermost level in a library package will be aligned according 
to the alignment clause specified for the type. Record objects declared elsewhen; can ottly be 
aligned on a word boundary. If the record type is associated with a differetit alignment, an 
error message will be issued. 

• If a record type with an associated alignment clause is used in a composite type, the alignment 
is required to be one word; an error message is issued if this is not the case. 


FJ Implementaticn-Depencent Names for Implementation Dependent Components 
None defined by the compiler. 


F.6 Address Clauses 

This section describes the implementation of address clauses aitd what types of entities may have 
their address specifted by the user. 


203 








DACS-80X86 User’s Guide 
Imptemenution-Dependeiu Charaaeristics 


F.6.1 Objects 

Address clauses are supported for scalar and composite objects whose size can be determined at 
compile time. The address clause may denote a dynamic value. 


F.6J Task Entries 

The implemeiuation supports two methods to equate a task entry to a hardware interrupt through 
an address clause: 

1) Ditea transfer of control to a task accept statemeru when an ituemtpt occun. This form 
requires the use of pragma INTERRUFT.HANDLER. 

2) Mapping of an imemipt onto a normal conditional entry call. This form allows the interrupt 
entry to be called from other tasks (without special actions), as well as being called when 
an ituenupt occurs. 


F.6.2.1 Fast Interrupt Tasks 

Directly transferring control to an accept statement when an iruerrupt occurs requites the 
implemenution dependent pragma INTERRUFT.HANDLER to tell the compiler that the task is 
an interrupt handler. 


F.6JL2 Features 

Fast interrupt tasks provide the following features: 

• Provide the fastest possible response time to an interrupt. 

• Allow entry calls to other tasks during interrupt servicing. 

• Allow procedure and function calls during interrupt servicing. 

• Does not requite its own stack to be allocated. 

• Can be coded in packages with other dedarations nat desired visiUity to appropriate parts 
of the program can be achieved. 

• May have multiple accept statements in a single fast iruerrupt task, each mapped to a different 
interrupt If more than one interrupt is to be serviced by a single fast iruerrupt task, the accept 
statements should simply be coded consecutively. See example 2 bow this is done. Note tha 
no code outside the accept statemetus will ever be execut ed. 


204 




DACS-80x 86 User's Gtti(k 
Implementation-Depen^ Characteristics 


F.6JL3 LimiUitioiis 

By using the fast inienupt feature, the user is agreeing to place certain restrictions on the lasu in 

order to speed up the software response to the interrupt. Consequently, use of this meUiod to 

capture interrupts is much faster than the normal method. 

The following limitations are placed on a fast interrupt task: 

• It must be a task object, not a task type. 

• The pragma must appear first in the specification of the task object 

• All entries of the task objea must be single entries (no families) with no parameters. 

• The entries must not be called from any task. 

• The body of the task must not contain any statements outside the accept statemera(s). A loop 
statemem may be used to enclose the accept(s). but this is meaningless because no code outside 
the accept statements will be executed. 

• The task may make one entry call to another task for every handled interrupt, but the call must 
be single and parameteriess and must be made to a normal tasks, not another fast interrupt 
task. 

• The task may only reference global variables; no data local to the task may be defmed. 

• The task must be declared in a library package. i.e.. at the outermost level of some package. 

• Explicit saving of NPX sute must be performed by the user within the acceix sutement if such 
state saving is required. 


F.6JL4 .Making Entry Calls to Other Tasks 

Fast interrupt tasks can make entry calls to other normal tasks as long as the entries are single (no 
indexes) and parameterless. 

If such an entry call is made and there is a possibility of the normal task not being ready to 
accept the call, the entry call can be queued to the normal task's emry queue. This can be forced 
by using the normal Ada conditional entry call construct shown below: 

accept E do 
selea 
T.E; 
else 

null: 

end select; 
end E: 

Normally, this code sequence means make the call and if the task is not wailing to accept it 
immediately, cancel the call and continue. In the context of a fast inienupt task, however, the 
semantics of this construct are modified slightly to force the queuing of the entry call. 


205 






DACS-80x86 User's Guide 
Implementation-Dependem Characterisbcs 


If an unconditional entry call is made and the called task is not waiting at the conesponding 
accept statement, then the interrupt task will wait at the entry call. Alternatively, if a timed entry 
call is made and the called task does not accept the call tjefore the delay expires, then the call 
will be dropped. The conditional entry call is the preferred method of making task entry calls 
from fast interrupt handlers because it allows the imerrupt service routine to complete straight 
through and it guarantees queueing of the entry call if the called task is not waiting. 

When using this method, make sure that the interrupt is included in the •inteiTupt_entry_tabie 
specified at link time. See Section 12.\5 for more details. 


F.6JJ Implementation of Fast Interrupts 

Fast interrupt tasks are not actually implemented as tnie Ada tasks. Rather, they can be viewed 
as procedures that consist of code simply waiting to be executed when an interrupt occurs. They 
do not have a state, priority, or a task control block associated with them, and are not scheduled 
to "run" by the run-time system. 

Since a fast interrupt handler is not really a task, to code it in a loop of somekind is meaningless 
because the task will never loop: it will simply execute the body of the accept statemeru whenever 
the interrupt occurs. However, a loop construa could make the source code more easily understood 
and has no side effects except for the generation of tlK executable code to implement to loop 
construct. 


F.6J.6 Flow of Control 

When an interrupt occurs, control of the CPU is transferred directly to the accept statement of the 
task. This means that the appropriate slot in the interrupt vector table is modified to contain the 
address of the corresponding fast interrupt accept statement. 

Associated with the code for the accept statement is 

at the very begituiing: 

code that saves registers and sets (E)BP to look like a frame where the interrupt return 
address works as return address. 

at the very end: 

code that restores registers followed by an IRET instruction. 

Note that if the interrupt handler makes an entry call to another task, the iiuerrupt handler is 
completed through the IRET before the rendezvous is actually completed. After the rendezvous 
completes, normal Ada task priority rules will be obeyed, aixi a task context switch may occur. 

Normally, the interrupting device must be reenaUed by receiving End-Of-Inierrupt messages. These 
can be sent from machine code insertion statements as demonstrated in Examine 7. 


206 





DACS'80x86 User’s Guide 
Implememation-Oependent Ouracteiistics 


F.6J.7 Savins; NPX Sute 

If the interrupt handler will perform floating poiru calculations and the state of the NPX must be 
saved because other tasks also use the numeric coprocessor, calls to the appropriate save/rtstore 
routines must be made in the statement list of the accept statement. These routines are located 
in package RTS_EntryPoirus and are called RTS_Store_NPX_State and RTS_Restore_NPX_State. 
See example 6 for more irtformation. 


F.6.2.8 Storage Used 

This section details the storage requirements of fast interrupt handlers. 


F.6J.9 Stack Space 

A fast interrupt handler executes off the stack of the task executing at the time of the interrupt 
Since a fast interrupt handler is not a task it does not have its own stack. 

Since no local data or parameters are permitted, use of stack space is limited to procedure and 
funcdon calls from within the interrupt handler. 


F.6J.10 Run-Time System Data 

No task control block (TCB) is created for a fast iruerrupt handler. 

If the fast interrupt handler makes a task entry call, an entry in the _CT)_INTERRirPT_VECTOR 
must be made to allocate storage for the queuing mechanism. This table is a run-time system dau 
struaute used for queuing interrupts to normal tasks. Each entry is only 10 words for 80386/80486 
protected mode compilers and S words for all other compiler systems. This table is created by 
the linker and is constrained by the user through the linker option 'interrupt_entry_table. For 
more information, see Section F.6.2.1 on linking an application with fast internipts. 

If the state of the NPX is saved by user code (see Sectiem F.6.2.7), it is done so in the NPX save 
area of the TCTB of the task executing at the time of the interrupL This is appropriate because it 
is that task whose NPX state is being saved. 


F.6J Building an Application with Fast Interrupt Tasks 

This section describes certain steps that must be followed to build an application using one or 
more fast interrupt handlers. 


207 





DACS*80x86 User’s Guide 
Implementation-Dependem Characteristics 


F.6J.1 Source Code 

The pragma INTERRUFT.HANDLER which indicates that the interrupt handier is the fast form 
of interrupt handling and not the normal type, must be placed in the task specification as the first 
statement. 

When specifying an address clause for a fast interrupt handler, the offset should be the interrupt 
number, not the offset of the interrupt in the interrupt vector. The segment is not applicable 
(although a zero value must be specifi^) as it is not used by the compiler for interrupt addresses. 
The compiler will place the interrapt vector into the INTERRUPTVECTORTABLE segrnem. For 
real address mode programs, the interrupt vector must always be in segrnem 0 at execution time. 
For proteaed mode programs, the user specifies the intenupt vector location at build time. 

Calls to RTS_Store_NPX_State and RTS_Restore_NPX_State must be included if the state of the 
numeric coprocessor must be saved when the fast intemifK occius. These routines are located in 
package RTS.EntiyPoints in the root library. See example 6 for more information. 


F.6JJ Compiling the Program 
No special compilation options are required. 


F.6JJ Linking the Program 

Since fast interrupt tasks are not real tasks, they do not have to be accounted for when using the 
•tasks option at link dme. In fact, if there are no normal tasks in the application, the program 
can be linked without 'tasks. 

This also means that the linker options -It.stack^size. •It_scgment_size. •mp.segment^size. and 
•task_storage_size do not apply to fast interrupt tasks, except to note that a fast interrupt task will 
execute off the stack of the task niruting at the time of the interrupt. 

If an entry call is made by a fast interrupt handler the interrupt number must be included in the 
•interrupt_entry_tabie option at link time. This option builds a table in the run-time system data 
segment tcThandle entry calls of imerrupt handlers. The uble is indexed by the interrupt number, 
which is bounded by the low and high interrupt numbers specified at link time. 


F.6J.4 Locating/Building the Program 

For real-address mode programs, no special actions need be performed at link time; the compUer 
creates the appropriate entry in the INTERRUPTVECTORTABLE segment. This segment must be 
at segment 0 before the first interrupt can occur. 

For proteaed mode programs no special actions need be performed. The Ada Link automatically 
recognizes Ada interrupt handlers and adds them to the IDT. 


208 





DACS*80x86 User’s Guide 
Implememaiion-Dependeiu Characteristics 


F.6.4 Examples 

These examples illustrate how to write fast intenupt tasks and then how to build the application 
using the fast intenupt tasks. 


F.6.4.1 Example 1 

This example shows how to code a fast interrupt handler that does not make any task entry calls, 
but simply performs some interrupt harxlling code in the accept body. 

Ada source: 

with System; 
package P is 

<potentially other declarations> 

task FastJnterrupt.HarxUer is 
pragma INTERRUPT_HANDLER: 
entry E; 

for E use at (segmem s> o, offset s> 10): 
end; 


<potentially other declarations> 


end P; 

package body P is 

<potentially other declarations> 

task body Fast.Interrupt.Handler is 
begin 

accept E do 

<handle interTupt> 
end E; 

end; 


<potentially other declatations> 


end P; 


with P; 

procedure Example.l is 
begin 

<main ptogram> 
end Example.!; 


Compilation and Unking: 


209 






DACS>80x86 User’s Cuide 
Impkmentaiioa-Dependem Characteristics 


$ ada E^iiiplc_l 

S ada-link Exaiii^_l ! Note: no other tasks in the system in this example. 
F.6.4J Example 2 

This example shows how to write a fast inienupt handler that services more than one iniemipt. 


Ada source: 

with System: 
package P is 

task Fast.Imemipt.Handler is 

pragma INTERRUPT_HANDLER; 

entry El: 
entry E2: 
entry E3: 

for El use at (segment 0. offset s> S): 
for E2 use at (segment »> 0. offset 9): 
for E3 use at (segment -> 0. offset >> 11): 

end; 

end P: 

package body P is 

task body Fast_InterTupt.Handler is 
begin 

accept El do 

<service interrupt 5> 
end El; 

accept E2 do 

<service inienupt 9> 
end E2: 

accept E3 do 

<service inienupt 11> 
end E3: 
end; 

end P, 


Compilation and Linking: 


210 





OAC^>80x86 User’s Guide 
Imfdemenution'Oependem Charaoeristics 


S ada Exaniple_2 

S ada Jink 'tasks • Exaniplc_2 # assumes ^)pUcaiion also has nonnal task< (not shown) 


F.6.4J Example 3 

This example shows how to access global data and make a procedure call from within a fast 
intemipt handler. 


Ada source: 

with Syston; 
package P is 

A : Integer. 

task Fast_Intemipt_Handler is 
pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment => 0. offset => 16#127#); 

end; 
end P; 

package body P is 
B : Integer. 

procedure P (X ; In out Integer) is 
begin 

X := X + 1; 
end; 

task body Fast.Interrupt.Handler is 
begin 

accept E do 
A ;= A + B; 

P (A); 
end E; 

end; 
end P; 


Compilation and Linking: 

$ ada Example_3 
S ada-link Example_3 


211 





DACS-80x86 User’s Guide 
Iinpleinentation>Dependent Characteristics 


F.6.4.4 Example 4 

This example shows how to make a task entry call and force it to be queued if the called task 
is not waiting at the accept at the time of the call. 

Note that the application is linked with -tasks=2, where the tasks are T and the main program. 
Since the fast imemipt handier is making an entry call to T. the techniques used guarantee that 
it will be queued, if mcessary. This is accomplished by using the condibonal call construa in 
the accept body of the fast iiuemipt handler and by including the interrupt in the - 
ineerrupt_entry_Uible at link time. 


Ada source: 

with System; 
package P is 

task FastJnterrupt.Handler is 

pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment => 0. offset s> 8); 
end; 

task T is 
entry E; 
end; 

end P; 

package body P is 

task body Fast.Interrupt.Handler is 
begin 

accept E do 
selea 
T.E; 
else 

null; 

end selea; 
end E; 

end; 

task body T is 
begin 
loop 
selea 
accept E; 
or 

delay 3.0; 
end select; 
end loop; 
end; 

end P; 


212 





DACS*80x86 User’s Guide 
Implemenuiioii'Dependent Characteiistics 


Compilation and Linking: 

S ada Exaniple_4 

$ ada-Iink 'tasks 2 •inteiTupt_enti 7 _table M Exaniple_4 


F.6.4J Example 5 

This example shows how to build an application for 80386/80486 protected mode programs using 
fast interrupt handlers. 


Ada source: 

with System: 
package P is 

task Fast.Intemipt.Handler is 
pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment »> 0. offset »> 17); 
end; 

end P. 

package body P is 

task body Fast.Intemipt.Handler is 
begin 

accept E do 
null: 
end E: 
end; 

end P; 


Compilation and Linking: 

S ada Example_5 
S ada-link 'tasks ' Example_S 


213 






DACS-80X86 User's Guide 
Impiememadon-Dependent Chaiacteiistics 


F.6.4^ Example 6 

This example shows how to save and restore the state of the mimetic coprocessor from within a 
fast interrupt handler. This would be required if other tasks are using the coprocessor to perfoim 
floating point calculations and the fast interrupt handler also will use the coprocessor. 

Note that the state of the NPX is saved in the task control block of the task executing at the time 
of the imerrupL 

Ada source: 

with System: 
package P is 

task Fast Inienupt.Handler is 
pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment »> 0. offset -> 25): 

end: 


end P: 

with RTS.EntryPoints: 
package body P is 

task body Fast.Interrupt.Handler is 
begin 

accept E do 

RTS_EntryPoints.Store_NPX_State: 
<user code> 

RTS_EntryPoints.Restore_NPX_State: 
end E: 

end: 
end P: 

Compilation and Linking: 

$ ada Exampie_6 

$ ada-link -npx -tasks - Example_6 


F.6.4.7 Example 7 

This example shows how to send an End-Of-Interrupt message as the last step in servicing the 
interrupt. 


Ada source: 


214 




DACS-80x86 User’s Guide 
Implememadon-Dependem Chaiecteristics 


with System: 
package P is 

task Fast_Inienupt_Handler is 
pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment «> 0, offset a> 5); 
end: 

end P. 

with Machine.Code: use Machine.Code: 
package body P is 

procedure Send.EOI is 
begin 

machinejnstiuction* 

(registerjmmediate. m_MOV. AL, 16#66#): 
machinejnstiuction' 

Ummediate_register, m_OUT. 16#0e0#. AL): 
end: 

pragma inline (Send.EOI): 

task body Fast.Imemipt.Handler is 
begin 

accept E do 
<user code> 

Send.EOI: 
end E: 
end: 

end P: 

Compilation and Linking: 

S ada Exaniple_7 
S adaJink 'tasks • Example^? 


F.6J Normal Interrupt Tasks 

"Nornial" interrupt tasks are the standard method of servicing interrupts. In this case the interrupt 
causes a conditional entry call to be made to a normal task. 


F.6.5.1 Features 

Normal interrupt tasks provide the following features: 

1) Local data may be defined and used by the interrupt task. 


215 





DACS-80x86 User's Guide 
Impiemenution-Oepeiideitt Characteristics 


2) May be called by other tasks with no restrictions. 

3) Can call other normal tasks with no restrictitms. 

4) May be declared anywhere in the Ada program where a normal task declaration is allowed. 


F.6JJ Limitations 

Mapping of an ituemipi otuo a normal conditional entry call puts the following constraints on the 
involved entries and tasks: 

1) The afTeaed entries must be defined in a task objea only, not a task type. 

2) The entries must be single and parameterless. 


F.6J3 Implementation of Normal Interrupt Tasks 

Normal interrupt tasks ate standard Ada tasks. The task is given a priority and nuis as any other 
task, obeying the normal priority rules and any time-slice as configured by the user. 


F.6J.4 Flow of Control 

When an interrupt occurs, control of the CPU is transferred to an interrupt service routine 
generated by the specification of the irueriupt task. This routine preserves the registers and calls 
the ran-time system, where the appropriate intemipt task and entry are determined from the 
information in the _CD_INTERRUPT_VECTOR uble and a conditional entry call is made. 

If the interrupt task is waiting at the accept statement that corresponds to the interrupt, then the 
interrupt task is scheduled for execution upon return from the interrupt service routine and tlx call 
to the run-time system is completed. The interrupt service routine will execute an IRET, which 
reenables interrupts, and execution will continue with the interrupt task. 

If the interrupt task is not waiting at the accept statement that corresponds to the interrupt, and 
the interrupt task is not in the body of the acc^ statemeiu that corresponds to the interrupt, then 
the entry call is automatically queued to the task, and the call to the nm-time system is 
completed. 

If the interrupt task is not waiting at the accept statement that corresponds to the interrupt, and 
the interrupt task is executing in the body of the accept statement that corresponds to the interrupt, 
then the interrupt service routine will NOT complete until the interrupt task has exited the body 
of the accept statement. During this period, the interrupt will not be serviced, and execution in 
the accept body will continue with interrupts disabled. Users are cautioned that if from within 
the body of the accept statement corresponding to an interrupt, an unconditional entry call is made, 
a delay statement is executed, or some other non-deterministic action is invoked, the result will 
be erratic and will cause non-deterministic 'nterrupt response. 

Example 4 shows how End-Of-Intemipt messages may be sem to the interrupting device. 


216 




DACS-80x 86 User's Guide 
Itnplementation-Dependem Characteristics 


F.6JJ Saving NPX SUte 

Because normal interrupt tasks are standard tasks, the state of the NPX numeric coprocessor is 
saved automatically by the run-time system when the task executes. Therefore, no special actions 
are necessary by the user to save the state. 


F.6J.6 Storage Used 

This section describes the storage requirements of standard interrupt tasks. 

F.6J.7 Stack Space 

A normal interrupt task is allocated its own stack and executes off that suck while servicing an 
interrupt. See the appropriate sections of this User's Guide on how to set task stack sizes. 


F.6.5.8 Run-Time System Data 

A task control block is allocated for each normal interrupt task via the -tasks option at link time. 

During task elaboration, an entry is made in the run-dme system _CDJNTERRUPT_VECTOR 
uble to "define" the standard interrupt This mechanism is used by the run-dme system to make 
the condidonal entry call when the interrupt occurs. This means that the user is responsible to 
include all interrupts serviced by interrupt tasks in the -interrupt^entry^table opuon at link time. 


F.6.6 Building an Application with Notmul Interrupt Tasks 

This secdon describes how to build an applicadon that uses standard Ada tasks to service 
interrupts. 


F.6.ii.l Source Code 

No special pragmas or other such directives are required to specify that a task is a normal interrupt 
task. If it contains interrupt entries, then it is a noraial interrupt task by default 

When specifying an address clause for a normal interrupt handler, the ofto should be the 
interrupt number, not the offset of the interrupt in the interrupt vector. The segment is not 
applicable (although some value must be specify) beemise it is not used by the compiler for 
interrupt addresses. The compiler will ^ace the interrupt vector into the 
INTERRUPTVECTORTABLE segment For teal address mode programs, the interrupt vector 
must always be in segmem 0 at execution time. This placemem can be accomplished by specifying 


217 






DACS<80x86 User's Guide 
Implememtfion-Oependem Characteiistics 


the address to locate the INTERRUPTVECTORTABLE segment with the locS6 command, or at 
run time, by having the sunup code routine of the UCC copy down the 
INTERRUTTVECTORTABLE segment to segment 0 and the compiler will put it there 
automatically. For protected mode programs, the user sped/ies the intemipt vector location at 
build time. 


F.6.6J Compiling the Program 
No special compilation options are required. 


F.6.6J Linking the Program 

The interrupt task must be included in the -tasks option. The link options •lt_stack_size. — 
it_segment_size. •mp_segment_sixe. and •task_storage_size apply to normal interrupt tasks and 
m^st be sef to approbate valutt for your application. 

Every interrupt task must be accounted for in the •interrupt_cntry_uble option. This option 
causes a table to be built in the run-time system dau segment to han^e interrupt entries. In the 
case of standard interrupt tasks, this table is used to map the interrupt onto a normal conditional 
entry call to another task. 


F.6.7 Examples 

These examples illustrate how to write normal interrupt tasks and then how to build the application 
using them. 


F.6.7.1 Example 1 

This example shows how to code a simple normal interrupt handler. 

Ada source: 

with System; 
package P is 

task Notmal_Interrupt_Handler is 
entry E; 

for E use at (segment » 0. ofEret «> 10); 

end; 
end P; 

package body P is 

task body Nbtmal.Imerrupt.Handler is 


218 



DACS*80x86 User's Guide 
Implememaiion-Dependera Characteristics 


begin 

accept E do 

<handle intemipo 
end E: 
end: 

end P: 

with P; 

procedure Example.l is 
begin 

<main piogtain> 
end Example.!: 


Compilation and Linking: 

$ ada Example_l 

S ada Jink 'tasks 2 •intefTupt_entry_tabic 10,10 Exampie_l 


F.6.7J Example 2 

This example shows how to write a normal interrupt handler that services more than one imetrupt 
and has other standard task entries. 

Ada source: 

with System; 
package P is 

task Normal.Task is 

entry El; 

entry E2; - standard entry 

entry E3; 

for El use at (segmem «> 0. offset 7); 
for E3 use at (segmem «> 0, ofbet » 9); 

end; 

end P; 

package body P is 

task body Nonnal.Task is 
begin 
loop 
selea 

accept El do 

<service imemipt 7> 


219 








DACS-80x86 User’s Guide 
Implementarion- Dependent Characteiistics 


end El; 
or 

accept E2 do 

<standard rendezvous> 
end E2: 
or 

accept E3 do 

<service iniemipt 9> 
end E3: 
end select; 
end loop; 

end Nonnal.Task; 


end P; 

Compilation and Linking: 

S ada Examplc_2 

S adaJink -tasks -intemipt^entry^tabic 7,9 Exaniple_2 


F.6.7J Example 3 

This example shows how to build an application for 80386 protected mode programs using noimal 
interrupt handlers. 


Ada source: 

with System; 
package P is 

task Notmal.lnterrupt.Handler is 
entry E; 

for E use at (segment «> 0, offset » 20); 
end; 

end P; 

package body P is 

task body Nonnal.lntemipt.Handler is 
begin 

accept E do 
n^ 
end E; 
end; 

end P; 


220 


OACS*80x86 User's Guide 
Impleineittadon-Dependeiu Qiaractenstics 


Compilation and Linking: 

S ada Exaniple_3 

S adaJlink -tasks -intemipt^cntry^Tabic 20,20 Example_3 


F.6.7.4 Example 4 

This example shows how an End-Of-Inienupt message may be sent to the inteimpting device. 

Ada source: 

with System; 
pacicage P is 

task Notmai_InteErupt_Handlet is 
entry eT ~ 

for E use at (segment » 0, offset ■> 7); 

end; 


end P; 

with Machine_Code; use Machine_Code; 
pacicage body P is ~ 

procedure Send_EOI is 
begin 

machine^inst ruction' 

'‘(regi3ter_iinnediate, m_MOV, AL, 16#66#); 
machine_instruction' ~ 

(immediate_register, m_OUT, I6#0e0#, AL); 
end; “ ~ 

pragma inline (Send_E01); 

task body NoEmal_lnterrupt_Handler is 
begin ~ ~ 

accept E do 
<user code> 

Send_EOI; 
end E;~ 

end; 


end P; 


Compilation and Linking: 

$ ada Example_4 

S ada-link -tasks -intemipt_entry_tablc 7,7 Example_4 


221 





DACS>80x86 User’s Guide 
Impiemenution-Dependem Chaiacieiistics 


F.6^ Interrupt Queuing 

DDC-I provides a useful feature that allows task entry calls made by interrupt handlers (fast and 
normal variant) to be queued if the called task is not waiting to accept the call, enabling the 
interrupt handler to complete to the IRET. What may not be clear is that the same interrupt may 
be queued only once at any given time in DDC-I’s implementation. We have made this choice 
for two reasons: 

a) Queuing does not come for free, and queuing an interrupt more than once is considerably 
mote expensive than queuing just one. DDC*I feels that most customers prefer their 
interrupt handlers to be as fast as possible and that we have chosen an implementation that 
balances performance with functionality. 

b) In most applications, if the servicing of an interrupt is not performed in a relatively short 
period of time, there is an unacceptable and potentially dangerous situation. Queuing the 
same interrupt more than once represents this situation. 

Note that this note refers to queuing of the same interrupt mote than once at the same time. 
Different interrupts may be queued at the same time as well as the same interrupt may be queued 
in a sequential manner as long as there is never a situation where the queuing overlaps in time. 

If it is acceptable for your application to queue the same interrupt more than once, it is a 
relatively simple procedure to implement the mecharusm yourself. Simply implement a high 
priority agent task that is called from the interrupt handler. The agent task accepts calls from the 
interrupt task and makes the call on behalf of the interrupt handler to the originally called task. 
By careful design, the agent task can be made to accept all calls from the interrupt task when they 
are made, but at the very least, must guarantee that at most one will be queued at a time. 


F.6.9 Recurrence of Interrupts 

DDC-I recommends the following techniques to ensure that an interrupt is completely handled 
before the same interrupt recurs. There ate two cases to consider, i.e. the case of fast interrupt 
handlers and the case of normal interrupt handlers. 


F.6.9.1 Fast Interrupt Handler 

If the fast interrupt handler makes an entry call to a normal task, then place the code that 
reenables the interrupt at the end of the accept body of the called task. When this is done, the 
interrupt will not be reenabled before the rendezvous is actually completed between tiie fast 
interrupt handler and the called task even if the call was queued. Note that the interrupt task 
executes all the way through the IRE” before the rendezvous is completed if the entry call was 
queued. 

NotmaUy, end-of-interrupt code using Low_Level_IO will be presem in the accept body of the fast 
interrupt handler. This implies that the end-of-interrupt code will be executed before the 
rendezvous is completed, possibly allowing the inierru(H to come in again before the application 
is ready to handle iL 

If the fast interrupt handler does not make an entry call to another task, then placing the 


222 





DACS-80x86 User's Guide 
Impleinenution-Dependem Characteristics 


end*of*intenupt code in the accept body of the fast interrupt task will guarantee that the iiuerrupt 
is completely serviced before another interrupt happens. 


F.6.9 J Normal Interrupt Handler 

Place the code that reenables the interrupt at the end of the accept body of the normal interrupt 
task. Vrhen this is done, the iruerrupt will not be reenabled before the rendezvous is actually 
completed between the normal interrupt handler aiKl the called task even if the call was queued. 
Even though the intermpt "completes" in the sense that the ERET is executed, the interrupt is not 
yet reenabled because the rendezvous with the normal task's interrupt entry has not been made. 

If these techniques are used for either variant of interrupt handlers, caution must be taken that 
other tasks do not call the task entry which reenables iitterrupts if this can cause adverse side 
effects. 


F.7 Unchecked Conversion 

Unchecked conversion is only allowed between objects of the same "size". However, jf scalar type 
has different sizes (packed and unpacked), unchecked conversion between such a type and anotter 
type is accepted if either the packed or the unpacked size fits the other type. 


F.8 Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O system, but in order to support 
testing and validation. DDC-I has developed a small temsinal oriented I/O system. This I/O system 
consists essentially of TEXTJO adapted with respect to handling only a terminal and not file lO 
(file I/O will cause a USE error to be raised) and a low level package called 
TERMINAL.DRIVER. A bASICJO package has been provided for convenience purposes, 
forming an interface between TEXTJO and TERMINAL.DRIVER as illustrated in the following 
figure. 




TEXT 10 



BASIC lO 

TEIWZIIAI. OrOVEK 
(R/w XntareAC*! 


The TERMINAL.DRIVER package is the only package that is target dependent, i.e.. it is the only 


223 






DACS-80X86 User’s Guide 
Itnidemenuuion-Dependeiu Charaaeristics 


package that med be changed when changing communications comioUers. The actual body of the 
TERMINAL.DRIVER is written in assembly language and is part of the UCC modules DlIPUT 
and OlIGET. The user can also call the tenninal driver routines directly, i.e. from an assembly 
language routine. TEXT.IO aixl BASICJO are written completely in Ada and need not be 
changed. 

BASIC.IO provides a mapping between TEXT JO coturol characters and ASCII as follows: 
TEXT.IO ASCII Character 


LINE.TERMINATOR 

PAGE.TERMINATOR 

FILE.TERMINATOR 

NEW.UNE 


ASaiCR 

ASai.FF 

ASai.SUB (CTRUZ) 
ASaiJLF 


The services provided by the tenninal driver are: 

1) Reading a character from the conunutucaiions port. Get.Character. 

2) Writing a character to the communications port, Put.Charaaer. 


FJ.1 Package TEXTJLO 

The specification of package TEXTJO: 

pc«qa« pa9«,- 
VIeh BASTC_IO; 

Vieh IO_EXCrP«ONS; 
p*chaj#~TEXT_IO Is 

typ* riLE_TYTE la liaiead privaea; 

typa rm!_MOOC la (Itl_riLE, OOT_ril«) ; 

typ* C00K7 la ran?* 0 .. INTESCX' lAST; 

aubtyp* POSITIVE_COUNT la COONT ran?* 1 .. COOMT'LAST: 

OMBOUMOeO; eonacant CoaNT;« 0; — lln* and pa?* l*n?th 

" max. alx* o{ an lne*?*r output tl«ld 21—.# 
auhtyp* FIELD la IHTESCR ran?* 0 .. 3S; 

auhtyp* MDMBER^BASE la INTEGEK ran?* 2 .. IS; 

typ* TYPE.SET la (LOWER-CASE, 07FER_CASE) ; 

pra?na PAGE; 


—' FIX* Mana?*Mne 





proe*dur* CREATE (FILE 

: In 

out 

FILE TTPE; 


MODE 

: in 


file'moob 

^WTJFILE; 

NAME 

: In 


STRING 

*** » 

FORM 

); 

: In 


STRING 


proe*dur* OPEN (FILE 

: in 

out 

FILE TTPE; 


MODE 

: in 


file'nsoe; 


NAME 

: in 


STRING; 



224 




DACS>80x86 User’s Guide 
Implememation-Dependeitt Characteristics 


rom ; m strimg ;-•* 

); 

preeaduta CLOSE (FILE : In out FILE FTFE): 
ptocadusa DELETE (FILE ; in out FILE~TTFE); 
pcocadura RESET (FILE : in out FILE TTPE; 

HODE ; in FILE_HOf£r; 
procadura RESET (FILE : in out FILE.TYFE): 

function MODE (FILE ; in FILE TYPE) ratuzn FILE NODE; 

function NMC (FILE ; in FILE'tyPE) catucn STRING; 

function FORM (FILE ; in FILE~TYPE) tatuni STRUM; 

function lS_OPeM(FILE : in FILE_TTPE raturn ROOLERM; 

pcadM PAGE; 

— control of default input and output filaa 

pcocadura SET IMPOT (FILE : in FILE TYPE); 
pcocadura SEt'oDTPOT (FILE ; in FILE.YYPE); 

function rTAMOARD IRPOT raturn FILE TYPE; 

function sTAHOARD~oirrp(iT raturn file~TYPE; 

function CDRREMT IMPOT ratum FILE TYPE; 

function CawrmT OOTPOT ratum FILE~T»E; 


pragma PA3E; 

— spacifieation of lina and paga langttis 

pcocadura SET LIME LENGTH (FILE : in FILE TYPE; 

~ “ TO : in COOMT); 

pcocadura SET_LIME_LEMaTB (TO ; in COOMT); 

procadura SET PAGE LEMGTB (FILE : in FILE TYPE; 

TO : in COOMT); 

pcocadura SET_PAGE_LEMGTB (TO ; in COOMT); 

function LIME LraCTB (FILE : in FILE TYPE) 

ratum COOMT; 
function LIME_LENaTH ratum COOMT; 

function PAGE.LEMCTB (FILE : in FILE_TYPE) 

~ ratum COOMT; 

function PAGE l^GTH coturn COOMT; 


pragma PAGE; 

" Column, Lino, and Paga Control 

procadura HEM LIME (FILE : in riL£_TYPE; 

SPACING : in POSITIVE COOMT 1); 

procadura NEW_LINE (SPACING : in POSITIVE~COOMT 1); 

pcocadura SKIP LINE (FILE : in FILE TYPE; 

“ SPACING : in POSITIVE COONT 1); 

procadura SXIP_LINE (SPACING : in POSITIVE~COOMT 1); 

function END OF LIME (FILE : in FILE TYPE) ratum BOOLEAN; 
function EMO^OF^LIME ~ ratum BOOLEAN; 

procadura MEH__PAaE (FILE : in FILE_TYPE) ; 
procadura MEN_PAGE; 

procaduro SXIP_PAGE (FILE : in FILE.TYPE); 
procadura SKIP_PAGE; 

function END OF PAGE (FILE : in FILe_TTPE) ratum BOOLEAN; 

function END~OF~PAaE ~ ratum BOOLEAN; 

function END OF FILE (FILE ; in FILE.TYPE) ratum BOOLEAN; 

function EMD~OF~FILE ~ ratum BOOLEAN; 


225 






DACS-80X86 User’s Guide 
Iin|rien>enMion*Dependem Characteristics 


preeatfura 

SET_COL 

(FILE : 

In FILE TYPE; 





TO 

la POSITIVE OOOMTI 

; 

preeaduca 

StT_COL 

(TO : in POSITXVB.COOIfT); 


preeadRica 

Sn^LXME 

(FILE : 

In PILE TYPE; 





TO : In POSITIVE COOMTI; 


preeadura 

scT^izm 

(TO : in POSirrVE^COOUT); 


function 

COL 

(File : 

: In FILE TYPE) 





return 

POSITIVE~COOirT; 



function 

COL 

c«tttra 

POSITtVEjCOOHT: 



function 

LIME 

crxzx ; 

: In FILE TYPEt 





ncttsn 

POSITIVE~OOaWT: 



function 

LZME 

r«tuca 

POSmVE^OOOMT; 



function 

PAGE 

(PIU : 

: la FILE TYPE) 





raturn 

POSITIVE~COai(T; 



function 

PACE 

return 

POSiriVE'cOOMT; 



pragBM PAOE; 






— Charactar lnput'>Otttput 




procaduca 

SET (FILE 

: In FILE TTPE: ITEM : 

out 

CEASACTEIl) 

preeaduca 

GET ( 


ITEM : 

put 

CSAJUCTElt) 

procaduca 

POT (FILE 

: In FILE TYPE; ITEM ; 

In 

CEASACTEA) 

procaduca 

POT ( 


ITEM : 

in 

CBAAACTEA) 

— String 

Input-Output 




procaduca 

GET (FILE 

: In FILE TTPE; ITEM : 

out 

CBASACTEX) 

procaduca 

GET ( 


ITEM ; 

out 

CEARACTEA) 

procaduca 

POT (FILE 

: In FILE TYPE; ITEM ; 

in 

CEAAACTEA) 

procaduca 

POT ( 


ITEM : 

in 

CEAAACTEA) 

preeaduca 

GET_LI1IE 

(FILE ; 

In FILE TYPE; 





ITEM ; 

out sniXNG; 





LAST : 

out MATOKAL); 



preeaduca 

GET.LXME 

(ITEM : 

out SnUMG; 





LAST ; 

out RATOAAL); 



procaduca 

POT_LI»E 

(FILE : 

in PILE TYPE; 





ITEM : 

In STkImG); 



preeaduca 

P0T_LIIIE 

(ITEM : 

In STAING); 




pragma FASC; 

— Ganacle Packaga for Inpuc-Oucput ot Intagar Typaa 


ganarle 

eypa OTM la raaga o; 


paeliaga I1ITEGEA_I0 

la 


DEFAOLT HIDTE : 

FIELD 

;• WOM'WIOTB; 

DEFAOLT~BASe 

tAEOEA, 

_SASe ;> 10; 

procaduca GET 

(FILE 

: In FILE_TYPE; 


ITEM 

: out ROmT 


WIOTE 

: la FIELD 0); 

preeaduca GET 

(ITEM 

: out WON; 


NIOTB 

: la FIELD :• 0); 

pcoeadura POT 

(FILE 

la FILE TYPE; 


ITEM 

In womT 


WIOTE 

In FIELD :• DEFAOLT WIOTE; 


EASE 

In WOWEA EASE :• O&AOLT EASE); 

procaduca POT 

(ITEM 

10 MOM; ” ~ 


WIOTE 

In FIELD :> OCFAOLT WIOTE; 


EASE 

la MOmEA_EASE 0EFA0LT_EASE) ; 

procaduca GET 

(FROM 

: In STAIWG; 


ITCH ; out mM; 


226 






LAST 


DACS-80X86 User's Cuide 
Implemeiuaiion-Dependem Characteristia 


: out POSrrXVK); 

prs:«<llir« POT (TO : one STRXIR; 

XTSM in IIOH; 

BASE ; la NOmeA.BASE OErAOLTJUSC) ; 

•ad IMTSQCA 10; 


pragaM fASE; 

~ Saaarlc Saekapaa for laput-Outpuc of Aaal Typaa 


paaartc 

typa HDH la dlpita O; 
paekapa rL0AT_I0 la 


DETAOLT FORE : 

FIELO : 

• 2; 

DEFAOLT art : 

FIELD : 

• ROM'DISITS - 1: 

OEFAOLT~E» 

FIELD : 

- 3; 

procadura SET 

(FILE 

: in nLE_TrPE; 


ITEM 

: out MOmT 


WIOTR 

: la FIELD :> 0): 

pcoeadvra SET 

(ITEM 

: out MOM; 


MZOTH 

: in FIELD 0); 

procadura POT 

(FILE 

In FILE TTPE; 


ITEM 

In MOM;* 


FORE 

In FIELO :> DETAOLT FORE; 


ATT 

In FIELD :> DEFAOLT'*ArT; 


EXP 

In FIELD ;* DEFAOLT~EXP>; 

procadura POT 

(ITEM 

In MOM; ~ 


FORE 

In FIELO :• DEFAOLT FORE; 


AFT 

In FIELO :• OEFAOLT'aFT; 


EXP 

In FIELO :« OEFAOLT^EXP); 

procadura SET 

(FROM 

In STRZM6; 


ITEM 

out MOM; 


LAST 

eut POSITIVE); 

procadura POT 

(TO 

out STRIMS; 


ITEM 

la MOM; 


ATT 

in FIELD !- DETAOLT AFT; 

aad FLOAT.IO; 

prapma PASE; 

EXP 

In FIELD :■ OEFAOLT'eXP); 

paaarle 

cypa MOM la dalta o; 


packapa FZXE0_I0 

la 


DEFAOLT FORE 

FIELD 

> MOM'FORE; 

DErAOLT~AFT 

FIELD 

> MOM'AFT; 

DEFAOLT JEXP 

FIELI 

- 0; 

procadura SET 

(FILE 

: In FILE_TTPE; 


ITEM 

: out ROmT 


HIOTB 

: In FIELD :■ 0) ; 

procadura BET 

(ITEM 

: out MOM; 


mOTE 

: la FIELD :> 0); 

procadura POT 

(FILE 

: in FILE TTPE; 


ITEM 

: in ROM;* 


FORE 

: la FIELD :> DEFAULT FORE; 


AFT 

; in FIELD OEFAOLT'AFT; 


EXP 

; in FIELO :• OEFAOLT.EXF); 

procadura POT 

(ITEM 

: in MOM; 


FORE 

; in FIELO :> DETAOLT FORE; 


AFT 

: In FIELO DEFAOLT*AFT; 


227 







DACS*8(te86 User’s Guide 
Imptenieniiiioo-Dependem Chencterisics 


B» : in riXXA OmOLT CX»); 


precadnra SET 

(VHOM 

In STAZHQ; 


XTIM 

: out MM; 


LAST 

: out POSXTXVE); 

procadura PUT 

(TO 

out STAXW; 


XTEM 

la NON; 


ATT 

la rXELO :• OETAOLT ATT; 


EXV 

In rXElB :> OBrAOLT~EXV); 


•nd rzXSO lO; 


pCddM VMB; 

•• 6«i«cle t«eka«* toe Xiipttt*Ouepat of KatiMratioa Typ«a 
9«n«cle 

typ« EMCM la (O); 
paekag* ORMBUnON XO la 


DEFAULT NXOTB 

: FIELD 

:• 0; 

0EFAULT~StTTXN6 

: TTVE.SET 

:• mn^cxsc; 

procadura SET 

(FILE : 

la FILE TYPE; XTEM : out EIRMI; 

procadura SET 

< 


ITEM : out EMUM); 

procadura PUT 

(FILE 

FILE TYPE; 


XTEM 

in 

EMUM; 


NXOTB 

in 

FIELD ;• DEFAULT NXOTB; 


SET 

in 

TYPE SET DXFA0LT~SETTItl6) 

procadura PUT 

(ITEM 

in 

emumT ~ 


HIOTa 

: In 

FIELD ;• DEFAULT NXOTB; 


SET 

: In 

TYPE.SET DEFAOLT~SETTXMO) 

procadura SET 

(FROM : 

in 

STAINS; 


ITEM ; 

out 

EMM; 


LAST : 

out 

POSXTXVE); 

procadura PUT 

(TO 

out 

STAINS; 


XTEM : 

in 

EMUM; 


SET : 

in 

TYPE SET DEFAULT SETTXMS) ; 


and EmncMTiOM^XO; 
pragma PAGt; 

— Cxeaptlona 

STATUS OWOR : axcaptlon ranaaiaa XO EXcePTXOMS.STATUS cmOR; 
MOOE dwOR : axcaptloo canaawa XO~exCDTXOIIS.NOOE_CmOR; 

NAKE~emOR : axcaptlon ranaaaa XO~EXCEmOHS.IIAIS~tMIOR; 

USE ERPOR : axcaptlon tanaaMa XaTEXCBPTXONS. USt.OWOA; 
DEVICE EMOR : axcaptlon ranaaaa XO~EXCEVTXONS.OEvTcE.EmOA; 
END EIWOR : axcaptlon ranaaaa X0~EXCEVTI0NS.ElO_EIU(0A; 
DATA EAAOA : axcaptlon ranaaaa XO~EXCEVTXOHS.OATA EAAOA; 
lAYOUT.EMlOA ; axcaptlon ranaaaa XO~EXCXVTXOHS.LATaUT.EAAOA; 

praqaa paga; 
prlvata 

typa rXLE.TTVE la 
racord ~ 

FT : XMTEOEA -1; 
and racord; 

and TEXT XO; 


228 





DACS-80X86 User’s Guide 
Iiii|>leinenuiion-Dq>endem Chancterisdcs 


FA2 Package 10JEXCEPTIONS 

The specification of the package lO.EXCEFTlONS: 


p«elut 9 « lO.EXCimaMS la 

STATOS saaOK : Mcaptlea; 
NCOS SMtOX : •xeaptlen: 
tmaTmOR : Mcaptlpn; 
OSE nam : •xea^lea; 
oenctJBMOR : Mcaptlea: 
IIIO_EaiiOR : •xcpptlon; 
DAU CMOA : •xepptioa: 
lAVOOr.nWOR : MMptlea; 

•nd 10 DCCSmOHS: 


F^J Package BASIC JO 

The specification of package BASICJO: 


with lO.EXCtPTIOHS; 
p*ek*gm aASIC_IO Is 

eyp« count Is canfo 0 .. intodor'last; 

subtypo poslttvo^eount is count raa«o 1 .. count'last; 


function 90 t_lato 9 or rotucn stslng; 

— Skips any loading blanks, lino tncalaateca »c pap* 

— totalnatots. Tbon toads a plus os a sdnus sign if 
'» pcosont, than toads aceotdlnp to tha syntax of an 
—• Intapat lltotal, which SMy ba basod. Stotas la Itasi 

— a stslnp containing an optional sign and an Intogor 
•• lltotal. 

" Tltm oxcaptlon OATAJEIWOR Is talsad If tha saquanea 
" of chataetoss deas~not eottospoad to tha syntax 

— dosetlbad abovo. 

" Tha oxcaptlon OtD_EMtoii Is talsad If tha flla tatsUnatot 

— Is toad. This siasns that tha stattlng saquanea of an 
" Intagot has not boon aat. 

— Meta that tha ehatactat tatsUnatlng tha oporatlon aust 

— ba avallabla fot tha naxt gat opatatlon. 

function gat_taal tatutn sttlng; 

— Cortasponds to gat_lntagot oxeapt that It toads aeeotdlng 
•• to tha syntax of a~toal lltotal, which mmr ba basod. 


function gat_anntMtatlon tatutn string; 

— Cortasponds to gat^lntogar oxeapt that It toads according 

— to tha syntax of m idantifias, whara uppat and lowat 

— casa lattats ata aquivalant to a ebataetat litatal 
~ including tha spostr^has. 


229 






DACS-80X86 User’s Guide 
Implemcnation-Depcndent Chanaerisiics 


fwietlen (length : In Incngnrl tnCnn ntclng; 

— Knnrtn n atrtng (re* chn currant line and ataran It in 
•• Itan. If tha ranalnlng nuntoar of ebarantara an tha 

— currant llna la laaa than length than anly thaaa 

— charaetara are ratumad. the llna tannlaatar la act 
•• aklppad. 

precadura put_ltan (itan : In atrlagi; 

— Xf tha length of tha atrlag la greater than tha currant 

— narlnun llna (Uaalaagthl, tha aacaptloa UTOOTJtmOR 
—• la ralaad. 

— t£ tha atrlng doaa not tit an tha currant llna a llna 

— taialaatcr la output, than tha Itan la output. 

-- Lino and page langtha - hPM 14.3.3. 

precadura aat_llaa_laagth (to : In couatt; 

precadura aat_paga_langth (to : In count); 

function llno_longth totucit count: 
function pago_longth tatum count ; 

— Oparatlona on eolunna, llnoa and pagaa • AIM 14.3.4. 

precadura na«_llna,- 

procedure aklp_llna: 

function aad_of.llao return hoolaan; 

precadura nav^jtaga; 

precadura aklpjpaga: 

function and^ef„paga return boolean; 

function and_of_fllo return beolaan: 

procedure aat_eel (to ; In pealtlaa_eeunt); 

precadura aat_llna (to : In poaltlva_eouatl: 

function col return poaltlva_eeunt; 

functlon lino return poaltlvo_eeunt: 

function page return pealtlvo_ceunt; 

— Character and atrlng proeoduraa. 

— Cerraaponda to the proeoduraa daflnad la AIM 14.3.4. 

precadura gat_eharaetar (itaa ; out characterI; 

proeadura gatjatrlng (itaa : out atrlag): 

proeaduro gat_llao (Itaa : out atrlng; 

" laat : out natural); 

proeaduro put_eharaetar (Itaa : la eharaetar); 

proeadura pnt_atrlag (Itaa : la atrlag): 


230 






DACS>80x86 User’s Guide 
lii^ilementttiop»Depende« Cbanciaistics 


^(•Mdara <ltMi ; la atciav); 


— aaeaptlona: 


on BMiae 
ocvies^awoK 

BS i nf ipf 

oksS Bmae 
LATon Bmae 


aaeaptlon raiMM* 
aaeaptlea r«n«Ma 
axeapcien caiuwaa 
axeapctoa raniiaa 
axeapcioa raiMMS 


zo excemom.osx neoit: 
zo"BXCxrrzoMs.oiviee smoR; 
zoTncsrTzaMs.iw bmor: 
zo'ncxrrzoMs.oAn smim; 
zo"oKsmaiis. uMmtMan: 


and MSZC ZO; 


FA4 Package TERMINAL.DRIVER 

The specification of package TERMINAL.DRIVER: 


paeicaga TEMIZ1UU._0RZVU la 

preeaOura put_eharaetar (eh : in eharaetar); 
proeadura 9 at_eharaetar (eh : out eharaetar); 
prlvata 

praqaM laeartaea (ASMC, put_eharaetar) ; 

pragaia intarfaea_spallln9(pu?_eharaetar. *01ZPOT?put_eiiaraetar*) ; 
praqaia inearfaea (ASMSC, 9 ae_eharaetar) ; 

pragma lntar£aea_,apalllii« (gac^eharaetar. *01ZsaT?9ac_ebaraetar*) ; 
and TEmaiiU ORZveit; 


Packages SEQUENTIAL-IO and DIRECTJO 

The specifications of SEQUENTIALJO and DIRECT.IO are specified in the ARM: 

Since files are not supported the subprograms in these units reaise USE_ERROR or 
STATUS.ERROR. 


231 





DACS-80X86 User's Guide 
Imptemenudao-Oependeitt Chencteristics 


FA6 PKkafe LOW^EVELJO 

The spedflcation of LOW.LEVELJO (16 bits) is: 


witlt Syscaa; 


p«ekA«a LOM_IXVEL_IO la 

aubtyp* port_a4drMa ta Syataa.OnaifnadHerd; 


eyp« la nan latagar canya 'ISt.-Ut?; 

typa Xl~le~lC la naa intaqar; 

preeadara aandi_eoiittel (davlca : la poct^addraas: 

daea : la Syaeas.lytal; 

— uaalgnad • bit aatlty 

preeadura aand^eentrel(davlca ; In pert.addraaa; 

" data : in SyatM.OnaldnadMocd); 

— unalpnad 1( bit antlty 

preeadura aand_eentrol(davlca : In pert^addraaa; 

” data : In ll_lo_SI; 

" algnad • bit antlty ~ 


preeadura sand_eantral(davlca : In port_addraan; 

~ data : In ll_lo_l«l ; 

•• ilgnad IS bit antlty ~ 


preeadura raealva_eentrol(davlca 
~ data 

— unalpnad • bit antlty 


In pert_addraaa: 
out Syseaa.Bytal; 


preeadura raealva_,eenttel (davlca 

data 

— unalgnad 1( bit antlty 


In port_addraaa; 

cut Syataa.OnalpnadNerd) 


preeadura raealva_eontrel(davlca 
** data 

•• al«nad S bit antlty 


In pert_addraaa; 
eut liJIo_S); 


preeadura raealva^eentrel(davlca 

data 

•' algnad 1< bit antlty 


in pert^addraaa; 
eut 11 _To_1€»; 


private 

pra«M Inline (aand_eentrel, racalva_eeatrel>; 
and LEVEL XO; 


The apaelfleatlen ot LOH_LEVXL_ZO (32 blta) la: 

with SYSTEM; 

paekapa LOW_level_IO la 

aubtypa pert_addraaa la Syataai.Onalgi i addord; 

type ll_le_S la new abert^lntadar range -US..127; 

type ll~le~l< la new abert_lntagac; 

type ll~le~32 la new Intagar; 

preeadura aand_eoatrel(device : la port_addraaa; 

~ data : la Syataa-Pytal ; 

— unalgnad • bit antlty 

preeadura aand.eentrel(device : la port.addreaa; 

~ data : la Syataai.aaalgnadeacd); 


232 


DACS-80X86 User's Guide 
Iiiiplemenittian*Dependent Ouncterisdcs 


—' «a«l«n«4 If bit Mtlcy 

preeadur* aand^eoatrol Idavtea : in port_a4dxMa; 

^ data : ta syatw.onaigaadBMocd); 

— uaalgnad 32 bit aetity 

praeadura aand_eaiitral (daviea : la patt_addtaaa; 

~ data : la 

— alpaad • bit aatity 

praeadura aaad^eaatrai(daviea : ia part_addraaa; 

" data : ta ll_ie_l<); 

— aigaad iS bit aatity ~ 

praeadura aaad_eaatreX(daviea : ia part_addraaa; 

data : ia ll_la_32>; 
aigaad 32 bit aatity ~ 

praeadura raeaiva_eaatral(daviea : ia pert^addraaa: 

~ data : aut Syatad.Bytai; 

uaaigaad • bit aatity 

praeadura raeaiva_eaatrel(daviea ; ia part_addraaa; 

~ data : aut Syataa.OaalgaadNardi; 

" uaaigaad 1( bit aatity 

praeadura raeatva_eeatrel(daviea : ia part_addraaa; 

~ data ; aut Syataai.OaaignadDNerd) ; 

•• uaaigaad 32 bit aatity 

praeadura raealva_caatral(daviea ; ia part_addraaa; 

~ data : aut il_te_S); 

" aigaad • bit aatity ~ ' 

praeadura raeaiva_eaatral(daviea : in pert_addraaa; 

~ data : aut ll_Te_l<); 

•• aigaad i< bit aatity ~ 

praeadura raeaiva eaatrai(daviea : ia part addraaa; 

data : aut ilj[a_32); 

•• aigaad 32 bit aatity 


private 

pragaa lnlina(aand_cantrel, raeaiva_eeatral); 
and VM LCVSL XO; 


F.9 Machine Code Insertions 

The reader should be familiar with the code generation strategy and the 80x86 instruction set to 
fully benefit from this section. 

As described in chapter 13.8 of the ARM (DoD 83] it is possible to write procedures containing 
mtly code statements using the predefined package MACHINE.CODE The pack ag e 
MACHINE.CODE defines the type MACHlNE_INSTRUCnON whicb, used as a record aggregate, 
defines a machine code insertion. The following sections list the type MACHINE_INSTRUCnON 
and types on which it depends, give the restrictions, and show an example of how to use the 
pack;^ MACHINE.CODC. 


233 




DACS*80x86 User’s Guide 
Implemenution-Dependem Chencteristics 


F.9.1 Predefined Types for Machine Code Insertions 

The following types are defined for use when making machine code insertions (their type 
declarations are given on the following pages): 

type opcode.type 
type operand.r^ 
type register.!!^ 
type segment.register 
type machine.insiniction 

The type RECISTER.TYPE defines legisiers. The registers STi describe registers on the floating 
stack. (ST is the top of the floating stack). 

The type MACHINE_INSTRUCTION is a discriminant record type with which every kind of 
instruction can be described. Symbolic names may be used in the form 

name'ADDRESS 

Restrictions as to symbolic names can be found in section F.9.2. 

It should be mentioned that addresses are specified as 80386/80486 addresses. In case of other 
targets, the scale faaor should be set to "seke.r. 


typ* opeod«_cyp« ij ( 

-- S0t€ Injtrueclen*: 



a_AAD, a_AAM, 

a_AAS, a_A&C, a_AD0, b_AND, 

a_CAU„ 

n odu). 




~B_caN, 

a CLC, a CIO, 

a CLl, a CMC, a CMP, a CMPS, 

a cm, am 

B^DAS, 

a~OtC, a“DIV, 

a“BtT, a^lBIV, a'lMtn., a^IM, 

a INC, iTic 

aTitm, 

a^lNET, a~JA, 

a^JAE, a^JB, a^JBE, a^JC, 

aTjezz. iTx, 

B^JS. 

a^JGE, a^Jlf* 

a^^TLE, a JNA, a JNAE, a JMB, 

a JNIE, aJC 

s_JNC, 

a^JNQ, a^JNGE, 

a_Jm., a_jinx, a_JMO, a^JMP, 

a JNS, 

m~JQ. 

a^JP, a^JPE, 

a“jpo, a'js. a~JZ, a”jMP, 

a.LABF, alSA 

mZtXS, 

a.LEA, a*LOCK, 

a_XjOOS, a^LOOP, a'LOOPE, " 


a LOOPNE, a LOOPNt, 



m_LOOPZ, 

a MOV. a Movs, 

a_MOL, a HES. a NOP, a NOT, 

a OR, aOK 

B~POP, 

a~POPF, a^POSB, 

a.POSBF, a_^RCL, a“ACR, “ 

a ROL, a^ROR, 

B~REP, 

a REPE, a^REPNE, 

a“RET, *“rEIP, a“BETN, 

a^RETNP, “ asr. 

B sal, 

a~SAR, a~SBL, 

a^SBR, a SBB, a~SCAB, a STC, 

~ a_STD, iTs 

b“stos, 

B_SaB, a^TESI, 

a'uAlT, a'xCBC, a'xLAT, a~XOR, 


— S0S7/|01S'7/802S7 rioaeln« Point 

Pree**aer Instruecion*: 


a rABS, 

a FADD, a FADOD. 

a FABDP,a FBLO, a FBSTP, 

a FCBS, 

a~FNCLEX, 

B~FCOM, a~Fcaie), 

a~FecMP, a^FCOMPO, a~FC0MPP, 

a~FDECSTP, 

b'foiv. 

a'roiVD, a”FBlVP, 

a~FBIVN, a^rOXVAD, a~FDrVNP, 

a'FFREE, 

B~riADO, 

a~riAOOO, a~FICOH. 

a_ricaM), ajrzcoMP, a fzcompd, a Fiozv, 

B~riBrvD, 

a”FIDIVR, a”FIOZVBO. 

a FZU, a FZLDD,a FZLOL, 

a FIMDL, 

m~FIMDLO, 

a~FIHCSTP, a“FliniIT, 

a_FISt, a~FISTO,a"FISTP, 

a”FISTPD, 

bTfistpl, 

a~FZSOa, a~FISOBO, 

a FISOIA, a~FISOBRD7 a FIO, 

a~F10D. 

B~FL0CH, 

a'FLOEMV, a~rU>1.62, 

a_rLOLH2. a_nOL2E, a.FUUT, a FLOP!, 

s~FtOZ, 

a~FL01, a'pim. 

a fMOU, a PMOLP, a FNOP, 

a FPATAR, 

a~FPN£M, 

a~FPTAM, a~nWDINT, 

a'mSTOR, ~ a rSAVE,a~FSCALE, 

a~FSETPM, 

b“fsoiit. 

a~FST, a“rSTO, 

a rSTCN,a rSTtMV, a~FSTP, 

a FSTPD, 

b”fsism. 

a~FSTSIIAX, a~rSOB, 

a rSOBO, B~rsOBP, a'FSOIN, 

a~FSOBRD, 

a~FsnaNP, 

m~rmxpi, 

a~FTST. a^FMAZT, 

, a~F2XMl, 

a_FEAI«, a_FXCa. a_FXTIUCT. a_rn,2X, 


— soitc/toasc/sosss mactuctlena: 

— Neele* that »omm 1—aiUat* varalena ot Ch* SOtC 

— Inatrucclena only axlac on eh«a* t«C 9 «e* 

— (ahifea, recae*a,piiah, 1ml,...) 

ai_80UMD, ■_CLTS, a^CMTeR, ■ INS, ■ IM, ■ LUVE, ■ L6ST, 

a.LSt, ■_OOTS, mJTOPA, ■jrOMU, ■_S66 t, ■_SX0T, “ 


234 






DACS-80X86 User's Guide 
liiipieniem«ion>Oepeiidem CStancteristics 


■_uoT, ■.uoN, ■.ltk. 

— 1 < bie 

■_StDT, a_SMSN, a^sni, a_vtm. ajm, 

— cha S03S< apaelfle tnstcuetloaa 

a.SXTA. a_S gTAE , a_SCXa, a_smc. a SBTC, a SBTC, 

•_SSTQ, a_ SCTaK . a^seXL, a~SRXX. a'sSTHA. a~SETllM, 

■_srn», a^s cna e, a_s*wc, a'sem, a'sciiK. 

a^ senw e. a_Stm, a_SBSIIliS. a~SnMO, a~SSTm. a sstms. 

=_s**>»s, a^SSTO. assert, a~SR*e, a'SRtO. a~StTS. 

a^isr, a_MR, a“eT. “a KC. “ a W*. 

~_ 3tS. a_irs. a_ua, a_U3. ajOVSX.a MOm. 

s_»VCR. ajnVDB, a_HOVTIt, a_siu, a_snD, “ 

— Cha S03S7 apaelfle inatzaeeioaa: 

a_racoM, a_roca«. a ncowt, a mma. a rsn, a rcos, 

a rsxacos, “ “ “ ~ 


— byta/« acd/dwerd varlaata (to ba uaad, whan 

— not dadaetlbla fxea eeataxt): 


a ADCS, 

a ADCM, 

a ADCS, 

a ADDS, 

a AOOW, 

a ADDD, 

a^AMDS, 

aTtaWM, 

a'AMOO, 

a'BW, 

a^BTO, 

a“Blcii, 

m~BTCO, 

a~BTKN, 

a~BTIID, 

a~BTSH, 

a BT», 

a~CBIW, 

a'cMDE, 

a'cMDN, 

a”cOQ. 

a~CMPB, 

a'ovw. 

a~OIPD, 

m~CMPS8, 

a~CMPSM, 

a CMPSO, 

a~oeCB, 

a'‘DECN, 

a^DECD, 

«“0IVB, 

a~OIVW. 

a^OXVO, 

a~IOIVB, 

a XDXVN, 

a lom. 

a~IMDLB, 

a'lMOLN, 

a~IMDIO, 

a” nics. 

~ a XMCN, 

~ a nco. 

a~IHSB, 

a'lNSH, 

a'lMSO, 

a~Lcoa, 

a LOOSM, 

a LOOSD, 

a~MOVB. 

a~H0V1l, 

a~MOVD, 

a MCva, 

a~HOVSN, 

a~HOV», 

a'HOVSXB, 

a~NOVSXM, 

a~MOVZXB, 

a~MCVZXH 

, ~ a MOLB, 

~ a MDLM, 

m~vmo. 

a~tn:sB, 

a~IieeH, 

a~NEaO, 

a~«OtB, 

a~MOTM, 

a~NOTD, 

a~ora. 

a~OIW, 

a~ORO, 

a'oOTSB, 

a OOTSM, 

a~00TS0, 

a“fO»ll, 

a~MrO, 

a”POSHN, 

a posao. 

a~RCLB, 

a'ltCLM, 

a~RCLO. 

a'acRB, 

a~nCRM, 

~ a RCBO, 

a ROLB, 

a~KOLH, 

a~SALU, 

a^BOLO, 

a^SALD, 

a ROM, 
a'sAM, 

a'RORM, 

a~SAMf, 

a^ROIIO, 

a~SAIlO, 

a^BALB, 
a SBLB, 

a^saLM, 

a~SBLOH, 

a SBM, 

a sam. 

a^SBRON, 

a SBM, 

a'SBBM, 

a~SBBO, 

a'sCASB, 

a~SCASN, 

a_SCA», 

a^SIOM, 

a“sTOSI», 

a~STQSO, 

a SOM, 

a~SOBW, 

a SOBO, 

a TESTS 

a"tESTII, 

a'tlSTO, 

a XQM, 

a'xomt. 

a_xaiu». 

a OAXM 

a'OATAH, 

a OATAD, 






** Spaclal 'Inatxuetlena*: a_labal, a_raaat, 

“ S087 taav raal load/atora_and_pop: a_nBT, a_rSTPT»; 


praqaa paga; 

typa oparand_typa la ( nena, — 

laaadlata, 

raglatae, 

addeaaa, 

a]rataB_addraaa, 

aaaM, 

ragiatar_lMadlata, 


ra 9 latar_ra 9 latar, 
raglatar^addraaa. 


addraaa_,ragla tac. 


no epacaada 

— ana laaadlata eparaad 

— ana raglatar eparaad 
~ ana addraaa apaeand 

— aoa 'addraaa eparaad 
— CALL aaaa 

two aparaada : 

— daatloatian la 
~ ragiatar 

— aaarea la laaadlata 

— tae raglatar aparaada 

— twe aparaada : 

— daatlaatlaa la 
ragiatar 

— aaarea la addraaa 

— twe aparaada : 


235 





DACS*80x86 User's Guide 
IiR|deoieniaiion>Depen(tem Characteristics 


sagtst«r_ty«tMi_«ddxMa, 

syatMi_addrM*_r«qlie«r, 

aUdraaa^liadlata, 

ayata«_a«ldraaa_lHMeiata, 

1 M adl ata_fglatT. 

1i a d lata_ t— adlata, 

raqiaf t_fqlat> tjatartiaf, 

r«9iatar_a4draaa_iaMdlac«, 
r«9lat«r_ayataa3^*** ianadlaca, 
addraaa_r««latar_laMdlMa, 

ayataM_addr«aa_ra9latar_laMdlat« 


" daaetaatlon la 

— addxaaa 

aourea la raylatar 
*- two epataada : 

" tfaatlaatlan la 
~ taylatar 

— aaurea la 'addraaa 
cwa opacanda ; 
daaeiBatlen la 

— 'addraaa 

" aaurea la caylatac 
~~ twa opatanda : 
daatlaaciaa la 

— addraaa 

— aaurea la iaaadlata 

— tua oparanda : 

— daatlnaelaa la 

— ‘addraaa 

-- aaurea la 1 —adlata 

— anly allawad far OOT 

— part la laaadlata 
*- aaurea la raglacar 

— aaly allawad for 

“ nrm 

allawad far iMDLlaa, 

— SHPfilaai. SUDlaa 
" allawad far XMOLlaai 
allawad far XMOLImi 

" allawad far SSKDlaai, 

.. SflUlM 

" allawad far snoiaa, 

•• SlUlM 


typa ra«latar_cypa la (AX, at, ox, ax, St. BP, si, oi, — ward ra«a 
Al, O., DI, at, Aa, cn. oa, aa. -■> byta raga 
EAX,£CX,C0X,CBX,ESP,eaP,ESi,£0l,-> dward ra«a 
as, cs, ss, os, PS, 6S, — aalaetara 

BX_SX, 8X^01, BP_SI, BP_0I, — fOSS/aOiac/tOZac eeaStlaatlana 
ST, STl, ST2, ST3, — flaatliif radiatara (ataek) 

ST*, STS, STS, STl, 

nil) ; 


— tha axtandad ragiatara (SAX .. EDI) plua rs and <SS ara anly 
allawad in S03S« targaca 

typa seala^cypa la (acala^l, aeala_2, aeala_4, aeala_a); 
aubtypa naehlna_strln« la string<1..100); 


pragata paga; 

typa aaehlna^lnatruetlan (aparand_klnd : eparand typa) la 
raeard ” ~ 

apeada : epeeda_typa; 

easa aparaad_klnd la 
whan liiadlata -> 

laaMdlatal t Intagar; — lanadlata 


whan raglstar » 

r_raglatar : raglatar_typa; ~ aaurea and/or dostlnatlen 


whan addraaa ■ 
a_sagaMnt 
a_addrassjbaaa 

a^addraaa^tndax 

a^addraaa^seala 

a_addrass~effaat 


raglatar.typa; >- aaurea and/ar doatlaacian 
: raglstar_typa; 

: taglstar~typa; 

: aeala_typa; 

: Intagar; 


whan ayataai_addrass » 

sa_addraas : aystaa.addraaa; — dastlnatlaa 


236 





OACS'Wxiio User's Cuuk 
laqtementation-Dependem Oiaracterisocs 


whMI IMM •» 

n_serln 4 : MchlM^atclnv: ~ CIOL dasciaatlon 
when ra«tse«c_lfMdlat* » 

c_l_c*«tat«t_to ; r««lac«r_typ«; — daatiMtlon 

r~l~l»aii1ata : Incagar: — aoure* 

Mh«n r«9lat«r_r««lat«r •> 

r_r_ra9lat5r_to : caglatar^typa; — dMClnatlon 

e~r~r* 9 latar 3 tw» : raqlatac^typ*; -- aottse* 

whan ra4iatac_a4draaa •> 

t_a_ca 9 latar_co : ra 9 latar_typa: — daatlnacion 

r~a~aa«Maat ” : raglatac~cypa; — aowsea 

r~a~addraaa_baaa : raglatar^typa; 

r~a~addxaaa~ladax : raglatac^typa; 

ajhZ*^**^***!*^*^* = aeala^typa; 


ra9tatac_typa; — daatlnatlen 
ra9latar~typa; 
raglatar'eypa; 
acala^Cypa; 
lttta9ar; 

ra^laeac^typa; — aousea 

whan ta9latar_ayataai_addraaa ■> 

r_aa_tn9laear_to ~ : ra9lacar_typa; — daatlnatlon 

r'aa^addraaa *' : ayataa.addraaa; — aourea 

whan ayataa_addraaa_ra9latar •> 

aa_r^aedzaaa ~ : ayataai.addraaa; -- daatlnacion 

^a~r”ta9_fro« : ra«lacar_cypa; — aeucea 

whan addcaaa_laBwdlaca •> 

a_l_aa9Mnt : ra^latac.cypa; 

a^lZ**^***.^*** • ra9lacac_cypa; 

= cafiaeac^yP*' 

a'l^addraaa^acala : aeala_cy^; 

a_l~addcaaa~o££aac : intadac; 

a^l^l—adlata : intagac; 

whan ayataa_addcaaa_laaMdlaCa » 

aa_l^ad£aaa : ayataai.addraaa; — daatlnacion 

aa~l'laBMdlaca ; incofoc; aourea 

whan lnaiadlaca_ra9lacar •> 

l_c_laawdlaea : Intagar; -- daatlnacion 

I'r^rafllatar : ro9iaear_typa; — aourea 

whan laanadlata_laBadlaea •> 

l_l_laiBadlatal : InCa^ar; — laawdlaeal 

l~l~ lwi adlata 2 : InCagar; -- la i adlataS 

whan caqlaear.ragiatar^laMdlaea •> 

r_r_l~raglatarT ; ra9latar_typa; — daatlnacion 

r 2 tZC^* 9**®**2 = ra^latar^typa; — aoureal 

rZr 33 ‘'—*'^^*** ’ Intagar; ~ aeurea 2 

whan ra9laeac_addraaa_lMadlaea •> 

r_a_l_raglatar ~ : raglatac^typa; 

: ca9lacar_typa; 

~r 33 —*^^***-^"* • ra 9 laCM_cypa; 

r_X_T_addraaa_Tadax : ra9latar_cypa; 

i_a 3 l_addraaa 2 aeala : aeala_cy^; 

rZaZlZ*^^***Z^^^**^' Intaqar; 
rZ '*33 —*<Sata : Intavac; 

whan ra9latac_ayacaai_addraaa_laMdlaCa >> 

r_aa_T.r* 9 i»t*r taglatar_typa; — daatlnatlon 

addrIo~' : ayataai.addcaaa; aoureal 

r_aa_l—artlata : intagar; aoureaS 


— daatlnatlon 
~ aoureal 


aoureaS 


daatlnatlon 


— aourea 


whan addraaa_rn«lacar • 
a_r_aa 9 Banc 

a~rZ*^^***-^*** 

a~cZ*^’^***Z^"^** 

a3Z*^^^**Z*<^* 

a3Z*^^***Z°^^**^ 

a~c~ra«laear £reai 


237 





DACS-80X86 User's Guide 
ImplemenuKion-Oependlem Ounaerisdcs 


wh«a 4ddf r_1—dl*f •> 

~ : n«lataz_typ«,- 

a_^l_addrMs_taa« : raglata^typ*; 
a~r2l~addzaaa~ladax : r« 9 latar~typa; 

• aeala^ty^: 

4~c2lZ*edraaa2efraat: intayar; 
a~t~l~ta 9 latar : caglaear^typa; 

ajrji3**>*Ulata : tiiCa 9 ar; ~ 


—' daatlMtlen 


— aoureal 
— aottte«2 


whan ayataat_adideaaa_ta«l.atat_iaMadiatn 


aa_r_t_addxaa a 
a^^l_ra9iatar 
aajr3-*—a dlata 


ayataa.addraaa; 
ra«latar_typa: 
laea«ar;^ 


— daatlaaclen 

— aoureal 
~ aeurea2 


whan oehaca •>> 
null; 
and eaaa; 
and raeerd; 


and aMchlna eeda; 


Restrictions 

Only procedures, and not functions, may contain machine code insertions. 

Symbolic names in the form x'ADDRESS can only be used in the foUowing cases: 

1) X is an objea of scalar type or access type declared as an object, a formal parameter, or 
by static renaming. 

2) X is an array with sutic constraints declared as an objea (not as a formal parameter or by 
renaming). 

3) X is a record declared as an objea (not a formal parameter or by renaming). 


The m.CALL can be used with "name" to call (for) a routine. 

Two opcodes to handle labels have been defirred: 

mjabei: defines a label The label number must be in the range i <x x <» 999 and is put 

in the offset field in the hrst operand of the MACHINE.INSTRUCnON. 

m.reset: used to enable use of more than 999 labels. The label number after a m_RESET 

must be in the range l<- x <s 999. To avoid errors you must make sure that all 
used labels have been defined before a reset, since the reset operation clears aU used 
labels. 

All floating instructions have at most one operand which can be any of the following: 

• a memory address 

• a register or an immediate value 

• an entry in the floating stack 


238 



OACS>80x86 User’s Guide 
Imfriemeniation-Dependent Qiaracteristics 


FJJ Examples 

The following section contains examples of how to use the machine code insertions and lists the 
generated code. 


F^.4 Example Uting Labels 

The following assembler code can be described by machine code insertions as shown: 

MOV AX,7 
MOV CX,4 

cm Ax.cx 
J6 1 
JS 2 
MOV CX.AX 
1: ADO AX,CX 
2; MOV SS: AX 

p«CkA9« ■Timit«_MC 1* 

pceevduc* 

ptA99A Inlln* 7t«at_lAb«la); 

•nd •XABpl«_MC; 

with MAC8IMX_C00£; uaa MACaZMe^CaOC; 
paekAf* body~«XAml«_MC Is " 


procaduts t«st_lsbsls is 
b«9ln 

MACSmX IMSTKOCTIOM' (s«9lstsr iSMadlACa, ■ MOV, AX, 7 ) ; 
MACaiMX mSTXOCTIOM* (rS9lStsr_ l— S d lAes, B.MOV, CX, 4); 
MACaillE'niSTllOCTZOM'(r«9tstar M9ts««c, m cm, AX, CX); 
MACSZta.tMSnuiCtXaM' tilMdlAt*, iTm, l); 

MACaZHS tMSTXOCZXOM' (imsdlAts, ■ JX, 2 ); 

MACBZNK.ZNSTRUCZZON' (ra«lst«r_t«9lstss, MJIOV, CX, AX); 
MACIZXK.ZIISTXOCTZOH' (loaMdlats, a^labsl, X); 

MACHZNt.ZNSTKUCTZOH' (rs9iat«r_rs«lstat, a.AOD, AX, CX); 
HACBZNeIzmstROCTZON' (ismdisca, ■ labsl, xT; 

MAcaZNE ZNSTROCZZON' (sddcsss rsglstsr, a MOV, SS. m. 

OZ, seals 1 . 0 . AX); 


and tasc^labals; 
and axaBipla_MC; 


F.9S Advanced Topics 

This section describes some of the more intricate details of the workings of the machine 
code insertion facility. Special attention is paid to the way the Ada objects are referenced in 
the machine code body, and various alternatives are shown. 


239 





DACS-80x86 User's Guide 
Implemenution-Dependeni Characteristics 


F.93.1 Address Spcdflcations 

Package MACHINE.CODE provides two alternative ways of speci^ng an address for an 
instruction. The first way is referred to as SYSTEM.AODRESS and the parameter associated 
this one must be specified via OBJECT'ADDRESS in the actual MACHINE.CODE insertion. Ttw 
second way closely relates to the addressing which the 80x86 machines employ: an address has 
the general form 

segment:[base+index*scale-K)ffsetl 

The ADDRESS type expects the machine insertion to contain values for ALL these fields. The 
default value NIL for segment, base, and index may be selected (however, if base is NIL. so 
should index be). Scale MUST always be specified as scale.l. scale_2. scale.4. or scale_8. For 
16 bit targets, s^e 1 is the only legal scale choice. The offset value must be in the range of 
-32768 .. 32767. 


F.9.5J Referencing Procedure Parameters 

The parameters of the procedure that consists of machine code insertions may be 
referenced by the machine insertions using the SYSTEM.ADDRESS or ADDRESS formats 
explained above. However, there is a great difference in the way in which they may be specified; 
whether the procedure is specified as INLINE or not 

INLINE machine insertions can deal with the parameters (and other visible variables) using the 
SYSTEM.ADDRESS form. This will be dealt with correctly even if the aaual values are 
constants. Using the ADDRESS form in this context will be the user's responsibility since the 
user obviously attempts to address using register values obtained via other machine insertions. It 
is in general not possible to load the address of a parameter because an 'address' is a two 
component structure (selector and offset), and the only instruction to load an immediate address 
is the LEA, which will only give the offset. If coding requires access to addresses like this, one 
cannot INLINE expand the machine insertions. Care should be taken with references to objects 
outside the current block since the code generator in order to calculate the proper frame value 
(using the display in each frame) will apply extra registers. The parameter addresses will, 
however, be calculated at the entry to the INLINE expanded routine to minimize this problem. 
INLINE expanded routines should NOT employ any RET instructions. 

Pure procedure machine insertions need to know the layout of the parameters presented to. in this 
case, the called procedure. In particular, careful knowledge about the way parameters are passed 
is required to achieve a succesfiil machine procedure. When not INLINE a block is created around 
the call which allows addressing of parameters, arxl code for exiting the procedure is also 
automatic. 

The user takes over the responsibility for correa parameter addressing. The rules of Ada 
procedure calls must be followed. The calling conventions are summarized below. 


240 






DACS*80x86 User's Guide 
Implementation-Dependent Characteristics 


F.9JJ Parameter Transfer 

It may be a problem to figure out the correct number of words which the parameters take up on 
the stack (the x value). The following is a short description of the transfer method: 

INTEGER types take up at least 1 storage unit 32 bit integer types take up 2 words, and 64 bit 
integer types take up 4 words. In 32 bit targets, 16 bit integer types take up 2 words the low 
word being the value and the high word being an alignment word. TASKs are transferred as 
INTEGER. 

ENUMERATION types take up as 16 bit INTEGER types (see above). 

FLOAT types take up 2 words for 32 bit floats and 4 words for 64 bit floats. 

ACCESS types ate considered scalar values and consist of a 16 bit segment value and a 16 or 
32 bit offset value. When 32 bit offset value, the segment value takes up 2 words the high word 
being the aligment word. The offset wotd(s) are the lowest, and the segment wotd(s) ate the 
highest. 

RECORD types are always transferred by address. A record is never a scalar value (so no 
post-procedure action is carried out whm the record parameter is OUT or IN OUT). The 
representation is as for ACCESS types. 

ARRAY values are transferred as one or two ACCESS values. If the array is constrained, only 
the array data address is transferred in the same marmer as an ACCTESS value. If the array is 
unconstrained below, the data address will be pushed by the address of the constraint. In this 
case, the two ACCESS values will NOT have any alignment words in 32 bit targets. 

Packed ARRAY values (e.g. STRING types) ate transferred as ARRAY values with the addition 
of an INTEGER bit offset as the highest wotd(s): 

+H: Brr.OFFSET 
♦L: DATA_ADDRESS 

+0: CONSTRAINT.ADDRESS - may be missing 

The values L and H depend on the ptesence/absence of the constraint address and the sizes of 
constraint and data addresses. 

In the two lauer cases, the form parameter’addtess will always yield the address of the data. If 
access is requited to constraim or bit offset, the instructions must use the ADDRESS form. 


F.9,S.4 Example 

A small example is shown below (16 bit target): 

procedure unsigned.add 

(opl : in integer; 

op2 : in integer, 

res : out integer); 


241 






DACS'80x86 User's Guide 
Impleniematton-Dependem Characteristics 


Notice that machine subprograms cannot be functions. 
The parameters take up: 


opl 

: integer 

I word 

op2 

: integer 

1 word 

res 

: integer 

1 word 

Total 

; 

3 words 


The body of the procedure might then be the following assuming that the procedure is 
defined at outermost package level: 


preeaUur* uaal9iMd_mdd 

: la latagar; 

ap2 : in intagat; 

cat out tatagar) la 


bagln 

pcagaa atoatraet_aeo<ia_iaaartloaa(ttual; 
aa_lnscr'(aa_CtaataJilaek.3,1.0,0,0); — 

4a~lnstr' (aa_aad_of_daelpaxt, 0,0,0,0.01; 
pra^M abstraet_aeoda^laaartlena(falaa); 


X 


3. y 


1 


aaehina_lnatnietlan' (raglatar_ayataB_addraaa. 

~ m 7 opl'aiddcaaat: 

■aeklna^inacruetlon' (caglaear_ayacaai_addraaa. 

" AX. ap2'a4draaa); 

aHMhlna_lnatxuetlon' <t—adiiata, 
«aehlaa~laacruetion' <taMdlata, 
aachiaa^inatiuctlea' (laMdlata, 
Mchlaa^laaeraetian • ( ayataai.addsaaa^taglaeaa, 
' raa'addxMa, AXi; 


mjm, 

a_ADO, 

■ JMC, 1) 

wr. 5) 

a.labal.1> 
•~MOV, 


pragaa abatraet^aeada_taaartlena(tnia); 
aa_iaatt' <aajCxlt_ai>tipi:gxai.0,0,0,nll_,acg,ni3_asg);» (2) 
aa^lnatr'(aa_aat_bleek_laval,0,0,0,0,0); — y-1 • 0 

pta^H abattaet_acoda^laaactlona < talaa); 
and uaalgna<t_add; ~ 


A routine of this complexity is a candidate for INLINE expanaon. In this case, no changes to the 
above 'machinejnstruction' statements are requited. Please notice that there is a difference between 
addressing record fields when the routine is INLINE and when it is not: 


type tec is 


record 


low 

: integer; 

high 

end record; 

: irueger. 

procedure add_32 is 


(opl 

: in integer. 

op2 

; in integer; 

res 

: out tec); 


The parameters take up 1 4’ 1 2 words > 4 words. The RES parameter will be 

addressed directly when INLINE expanded, ix. it is possible to write: 


242 






DACS*80x86 User’s Guide 
Imidemeniation-Depenkm Characteristics 


machineJnstniction'(sysiein_address_register. m_MOV. 

res'addiess. AX); 

This would, in the not INLINEO version, be the same as updating that place on the stack where 
the address of RES is placed. In this case, the insertion must read: 

machineJnstniction’(register_system_addtess. m_LES. 

SI. res’address); 

- LES SI.(BP+...] 

machineJnsmiction'(address_regisier. m MOV. 

ES. SI nU. scale.l, 0. AX); 

- MOV ES;[SI+01,AX 


As may be seen, great care must be taken to ensure correa machine code insertions. A help 
could be to first write the routine in Ada, then disassemUe to see the involved addressings, and 
finaUy write the machine procedure using the collected knowledge. 

Please notice that INLINEO machine insertions also generate code for the procedure itself. This 
code will be removed when the •nochcck option is applied to the compilation. Also not 
INLINEO procedures using the AA.INSTR insertion, which is explained above, will automatically 
get a storage.check call (as do all Ada subprograms). On top of that, 8 bytes are set aside in the 
created frame, which may freely be used by the routine as temporary space. The 8 bytes are 
located just below the display vector of the f^e (from SP arxl up). The storage.check call will 
not be generated when the compiler is invoked with 'nocheck. 

The user also has the option NOT to create any blocks at all, but then he should be certain that 
the return from the routine is made in the proper way (use the RETP instruction (return and pop) 
or the RET). Again it will help first to do an Ada version and see what the compiler expects to 
be done. 

Symbolic fixups are possible in certain instructions. With these you may build ’symbolic’ 
instructions byre for byte. The instructions involved all require the operand type NAME Oike used 
with CALL), and the interpretation is the following; 

(name. m.DATAD, "MYNAME”) a full virtual address (offset and selector) of the 

symbol MYNAME (no additional offset is possible). 

(name, m.DATAW, "MYNAME") the offset pan of the symbol MYNAME (no additional 

offset is possible). 

(name, m.DATAB, "MYNAME") the selector value of symbol MYNAME 

In inlined machine instructions it may be a ptoUem to obtain the address of a parameter (rather 
than the value). The LEA instruction may be used to get the oflxt part, but now the following 
form allows a way to load a selector value as well; 

(system.addtess, LES. param’address) ES is loaded with the selector of PARAM. If this 

selector was e.g. SS, it would be pushed and popped 
into ES. LES may be substituted for LFS and LX3S 
for 80386. 


243 





DACS-80X86 User's Guide 
linptemeraation*Dependem Characteristics 


F.IO Package Tasktypcs 

The TaskTypes packages defines the TaskControlBlock type. This dau structure could be useful 
in debugging a tasking ptogram. The following package Tasktypes is for all DACS-80x86 except 
for DAC:S-80386PM/DACS-80486PM. 

with Systw: 
p«ek««« TMkTypM is 

subtyps Offsat is Systaa.OnsigaadMord; 

subtyp* aieekZd is Systsa-OnsifnadHerd; 

typa TaskXatty is saw Syataa.OnsignadNerd; 

typa Battyladas is naw Systaa.OnaignaOlerd; 

typa AltarnativaZd is naw 3ystaa.anai«nadHerd; 

typa Ticks is saw Systsai.DMocd; 

typa Bool is naw ■eelaan; 

for 1001 'sisa usa •: 

typa OZatg is naw Systaa.OnsifnadNerd; 

typa TaskStata is (Initial, 

— Tha task is eraatad, but activation 

— has net started yat. 

ea«a«ad, 

•• Tha task has called an entry, and tha 
•• call is now aeeaptad, ia. tha randasvous 

— ia in progress. 

Running, 

— Covers all other states. 

Oalayad, 

•> Tha task awaits a tisMout to aapira. 

BatryCallinyTiSMkl, 

— Tha task has called an entry which 

— ia not yat accepted. 

EatryCallinganeenditional. 

•• The task has called an entry unconditionally, 

•• which is net yat aeeaptad. 

SalactingTiawd, 

" The task is waitiny in a salaet stataaant 
•• with an open delay alternative. 

SalaetiagOneenditional, 

•• Tha task waits ia a select statcsMnt 

— entirely with accept stataaants. 

SalactingTaiBinabla, 

" Tha task waits in a salaet statsns n t 

— with an opan tamiaata altamativa. 

Aceaptiny, 

— Tha task waits ia an accapt stataaant. 

Synch roaisiny, 

— Tha task waits ia an accept stataaaat 

— with nc statasMot list. 

Ccsiplatod, 

— The task has ecnplacad tha ameutien of 

— its stataaont list, but not all dspandsnt 
~ tasks are tomiaatad. 

Tansinatod ) ; 

— Tha task and all its descendants 
are taxainatad. 


244 






DACS*80kS6 User’s Guide 
Imptemenurion-Dependent Chanoetisttcs 


for T«aUt«t« aa« (Zaltlal » ISIOO* , 

In g auad -> ISSOa* , 

Riuuiiay » ISSIOS , 

B«l«y«d ■> KSlt* , 

BatcyCalliavTlMd •> ISMO* , 
KattyCAlUafOncaadltlonal •> liiSSS , 
SalaetUtvTlMd <o ICSSl* , 
SalaetlAfOnecMidtttoMl •> ICSSt* . 
SalcecinyTaaBlaabl* •> ICMlt . 
Aee«peifl« ■> 1SS4A# , 

SynehraAtsiAt «> IStSSS , 

CeaplACAd » ISSSei , 

TMMlMCAd » l<SC4t): 

for TaskStaco'also uao •; 

typo TaakTypoOoaerlptoc la 
roeerd 

priority : Syataa. Priority; 

ontry count ; Olatp: 

bloek_ld : SlockSd; 

flrat_OMn_addroaa : Syataai.Addroaa; 

■odHlo_n«atoor : OZntp; 

oatry^auaibor : OZatg; 

eodo.addroaa ; Syatoa.kddroaa; 

. ataek_alto ; Syataai.Oiiord; 

duciay ; intodor; 

ataek_ao 9 »ont_alro: OZatg; 
ond record; ~ 

typo AecTaaktypaOoaerlptor la aecoaa TaakTypoOoacrlptor; 

typo MPXSavoAroa la array (1.. 41) of Syatoa.OnalfnodWord; 

typo rXa«aTypo la 
record 

Mtxria« ; tool; 

Xntocruptria« : tool; 

and record; 

pra^H pack(ria«aTypo); 

typo statoaTypo la 
record 

atato : TaakStato; 

la_abnet«al ; Bool; 

la~aetlvatod : Bool; 

failure : Bool; 

and rocord; 

praqaa pack(StatoaTypo); 

typo aer_typo la 
record 

bp : Offaot; 

addr : Syataai.Addroaa; 

end rocerd; 

praqM paek(Aier_typol ; 
praqaM page; 

typo TaakContrelBleck la 
record 

aoa : SyatoA. SoMpbero; 

laMonlter ; latogor; 

— Delay qoauo ttandllng 

dnoxt : Syatoai.TaskTaluc ; 

dprov : SyatOB.TaakValua ; 

ddolay : tlcka ; 

— Saved roglatora 

SS : Syatoai.OaalqnodNord ; 


24S 










DACS-SQxM User's Guide 
Implenieniaiioii-Dependem Chsnaeristics 


n 


OffMC : 


—' RMdy handllny 

next : Syatw.taakVeliM ; 

— Seaaphor* hMUllng 

••anext : syatM.TukValue ; 

— trlectty field* 

prteclty : Syataai.rrierlty; 

aeved_pcteclty : SyataM.trlerity: 

Mlacellaaeoua flelda 


tla*_alle* : Syataai.OaalfnedMoxd; 

tla«a : ria«aType: 

See^amt : Syatea.Merd; 

" Steek Speelfleetlon 

ateek_aCert : Offaet; 

ateek_*nd ; Offaet; 

State fields 

states : StateaType; 

ketlvatlen handlinf flelda 


activator 
aec_ehaln 
naxt_ehaln 
no_not_act 
act blMk 


Syataa.r takValue; 
Syataai. TaakValue; 
Systaai. taakvalue; 
Syatae.Nerd; 
■loekid; 


— Accept queue flelda 


partner : Systea.Taakvalue; 

next^rtner : Syateai.taakvalue; 

Entry queue fields 

next^caller : Syataa.Taakvalue; 

Renderveua flelda 


call*d_task 
laAsynclT 
taak_satry 
*atry_lndex 
*ntry~asaee 
call „^ram 
alt_ld 
*xep_ld 


: Syateai.Taakvalue; 

: inteqer; 

: TaakEntry; 

: tntryXndex; 

: Systea.Address; 

; Syateai.Address; 

: AltematlveSd; 

: Syateai.ExceptlenXd; 


Dapandency flelda 


pat*nt_taak 

par*nt~block 

ehlld_task 

nextj^lld 

flrst_ehlld 

prevjebild 

ehild_aet 

bleek^aet 

terminated task 


Syataai. Taakvalue; 
SleckXd; 

Systea.Taakvalue; 
Systea.Taakvalue; 
Systea.Taakvalue; 
Systea.Taakvalue; 
Systea.Nerd; 
System.Nerd; 
System. Taakvalue; 


Abortion handling fields 


busy : System.Nord; 


246 







OACS-80X86 User's Guide 
Implementaiioii-Dependem Charaaeiistia 


— JUixtllury eialda 

ctd : *eeTukfyp«OMeclptoc; 

riraccallar : Systaa.taakValiM; 

•- Rua-TlM SyatM flalda 

ACT : Acr_typ«; — et. Oaar'a ««lda •.4.2 

aorirat : latagar; -> Only uanU In RMS 

Satfirat : Xatagnc; ~ Only nand la RMS 

TRloeklafTaak : SyaCM.ZaakVnlun; — Only vand la RMS 

nioeklastaak : SyataM.TaakValun; — Only nand la RMS 

eollnetlon : Syataa.Addrnaa; 
partition : Zntagar; 

laakChacktllt : Offaat; — to aaanta lallaa atora«o ekaek 

taattocaptloa : SyatoM.ONocd; — 2 * 1< blta 

SavadRdakddr : Offaat; — to Uapcoon condoavena'a 

>• m aava asaa 

— Whan tha application la llakad with -npK, a apaelal 

— aava araa for tba MVX la alloeatad at tha vary and 
of ovary TCI. 

— la: 

caaa NPX_Rraaanc la 

— Mhan TXOE » NPXaava : MPXSavoAraa; 

— whan rALSK •> null; 

— and eaaa; 

oad raeord; 

-o Tha following la to aaaura that tha TO haa tha axpaetad alia: 

TO_alsa : eonaeaat iMTSSn :> TaakControllloek'alaa / •; 

aubtypa TO.ok^valua la nnxstx raapa 13C .. 13C; 

TO.ok : cMacaat TO_ok_valao :■ TaakCoatrolBloek'also / •; 

and TaakTypaa; 


F.ll RMS Tasking (OPTIONAL) 

The DACS-80x86 systems may nin tasking applications by means of Rate Monotonic Scheduling 
(RMS). RMS capability is purchased optionally, and is thus not included by default Please coniaa 
DDC-I for more information regarding RMS and your system. RMS allows the programmer to 
guarantee properties of a tasking system. i.e. that tasks will meet their hard deadlines. The RMS 
tasking is selected by specifying •mis to the Ada link command. 


247 





