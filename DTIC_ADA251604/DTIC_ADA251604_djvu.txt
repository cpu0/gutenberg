AD-A251 604 ITATION PAG 


Form Approvod 
OPMNo. 


! 


m 



iwrag* 1 hour par raaponta, including tha lima tor laaiawing inatruoliana, aa a re h in g aidaling dtoa 
Iton. Sand comma ma r agai d ing Ihia bwdan aaUmata or any olhar aapact cl thia oolae l ion of intormalion, 
oa, Diradorala tor Intonnalion Opar a Mona and (lapafta, ISIS Jaftoraon Dmria llghai a y. Suia 1204, Arimglon, VA 
la of Managa m ant and Budgal. WatNngton, DC 20603. 


3. REPORT TYPE AND DATES 
Rnal: 06 Mar 1992 


4. TITLE AND 

Validation Sumniary Report: NATO SWG on APSE Compiler for VAXA/MS 
to MC68020. Version VCM1.82-02, VAX 8350 under VMS 5.4-1 with CAIS 
5.5E (Host) Motorola MVME 133XT(Target), 92030611.11248 


6 . 

lABG-AVF 

Ottobrunn, Federal Republic of Germany 


7. PERFORMING ORGANIZATION NAME(S) AND 

lABG-AVF, Industrieanlagen-Betriebsgeselschaft 
Dept. SZT/ Einsteinstrasse 20 
D-8012 Ottobrunn 

FEDERAL REPUBLIC OF GERMANY 


9. SP0NS0RING4y40NIT0RING AGENCY NAME(S) AND 

Ada Joint Program Office 

United States Department of Defense 

Pentagon, Rm 3E114 

Washington, D.C. 20301-3081 - 


5. FUNDI 



8. PERFORMING 
ORGANIZATION 

lABG-VSR 102 


10. SPONSORINGAAONITORING 
AGENCY 



12a. DSTRIBUTION/AVAILABILITY 

Approved for public release; distribution unlimit 


13. (Maximum 200 

NATO SWG on APSE Compiler for VAXA/MS to MC68020. Version VCM1.82-02, VAX 8350 under VMS 5.4-1 
with CAIS 5.5E (Host) Motorola MVME 133XT(MC68020 bare machine)(Target). ACVC 1.11. 



15. NU 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Cap^lity, Val. Testing, Ada Val. Office, Ada Val. Facility. ANSI/MIL-STD-1815A, I 




CLASSIFICATION 

UNCLASSIFIED 




UNCLASSIFED 


CLASSIFICATION 

UNCLASSIFIED 



NSN 


Standard Form 298, (Rev. 2-89) 
PreaeribedbyANSI Sid. 





































Cartificata Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on March 06, 1992. 


Compiler Name and Versiont 

MATO SWO on APSE Coi^iler for VAX/VMS to NC68020 
Version 1.82-02 

Host Computer System: 

VAX 8350 under VMS Version 5.4-1 
with CAXS Version 5.5B 

Target Computer System: 

Motorola NVNB 133XT (NC68020 bare machine) 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
92030611.11248 is awarded to Alsys. This certificate expires on 
1 June, 1993. 


This report has been reviewed and is approved. 


[L: 1J? 


XABG, Abt. XTE 
Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 







Ada Organization 

Director, ^gmputer & Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



Accesion For 


NTIS CRA&I 
DTIC TAB 
Unaimouficed 
Justification 




By. 

Disti ibjtio' f 


Avjiia: > .:y 


L 'Uii 


^-^da Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 



92-14405 

lllllllll 


074 








AVF control Numbor: XABG-VSR 102 
06 March 1992 


Ada CONPILBlt 

VALXSAXIOH StnOORT KBPORS: 

Cartifleata Modtari 920306X1.11248 
mxo SWO ea 8P8B Ca^pilar 
for VAZ/VMS to 11068020 
Varslea VCNl.82-02 

VAX 8350 nadar Vm 5.4-1 with ChXS 5.5B lost 
Motorola MVNB 133XT (11068020 bara aaehiaa) T ar ga t 


basad on TIKPXATX Varsion 91-05-08 •> 


Praparad By: 
XABG abR, Abt. XT! 
Klnstainstr. 20 
W-8012 Ottobrunn 
Oamany 






DECLARATION OF CONFORMANCE 


Hie following declaration of conformance was supplied by the customer. 

Dedaration of Co nf onn a nce 
Custmnen Al^ QnbH & Co. KG 
Certificate Awardee: Alsys / Gennan MoD 
Ada VaUdation Facility: lABG mbH, Gomany 
ACVC Version: 1.11 


NATO SWG on APSE Compiler for VAX/VMS to MC68020 Version VCMl.82-02 
Host Cmnputer Syston: 

VAX 8350 under VMS Version S.4>1, with CA15 Version 5JSE 
Target Computer System: Motorola MVME 133XT (MC68020) (bare machine) 


Dedaratkm: 

We, the undersigned, declare that we ha^e no knowledge tii deliberate deviations 
from the Ada Language Standard ANSI/MILrSTD-1815A ISO 8652>1987 in the 
implanentation listed above. 



- 

M.0721/M302S fill0721/187964 


Certificate Awardee Signature 


Date 


Date 








TABLE OP CONTENTS 

CHAPTER 1 INTROOnCTZON 

1.1 USE OP THIS VALIDATION SUMMARY REPORT.1-1 

1.2 RSPERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OP TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS ..2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OP TEST RESULTS.3-1 

3.3 TEST EEECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX P OP THE Ada STANDARD 






















CHAPTBR 1 
INTROOOCrZOM 


Th« Ada implamantation dascrlbad abova was tastad according to tha Ada 
Validation Procaduras (Pro90] against tha Ada Standard (Ada83] using tha 
currant Ada cooipilar Validation Capability (ACVC). This Validation Sumnary 
Raport (VSR) givaa an account of tha tasting of this Ada inplaoiontation. 

For any tachnical tarms usad in this raport, tha raadar is rafarrad to 
[Pro90]. A datailad dascription of tha ACVC may ba found in tha currant 
ACVC Usar'a Guida [0089]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consiatant with tha national laws of tha originating country, tha Ada 
Cartification Body may maka full and fraa public disclosura of this- raport. 
In tha Unitad Statas, this is providad in aceordanca with tha "Fraadom of 
Information Act" (5 U.S.C. #SS2). Tha rasults of this validation apply 
only to tha computars, oparating systams, and compilar varsions idantifiad 
in this raport. 

Tha organizations raprasantad on tha signatura paga of this raport do not 
raprasant or warrant that all statasiants sat forth in this raport ara 
accurata and complata, or that tha subjact ia^laoiantation has no 
nonconformitias to tha Ada Standard othar than thosa prasantad. Copias of 
this raport ara availabla to tha public from tha AVF which parformad this 
validation or from: 

National Tachnical Information Sarvica 
'5285 Port Royal Road 
Springfiald VA 22161 

Quastions ragarding this raport or tha validation tast rasults should ba 
diractad to tha AVF which parformad this validation or to: 

Ada Validation Oirganization 

Computar and Softwara Enginaaring Division 

Instituta for Dafansa Analysas 

1801 North Baauragard Straat 

Alaxandria VA 22311-1772 


1-1 








INTRODUCTION 


1.2 REFERENCES 

[Ada83] Raference Manual for the Ada Proorammlno Lanouaga . 

ANSI/MIL-STD-181SA, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Proeedurea. Version 2.1, Ada Joint 
Program Office, August 1990. 

[UG89} Ada Compiler Validation Capability User's Guide . 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of teat programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test name identifies the class to 
which it belongs, class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are vrritten in a self-checking Dinner and produce a 
passed, failed, or NOT APPLICABLE OMSsage indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHBCK._FILE are used for this purpose. The package REPORT 
also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that %K>uld circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CRECK^FILE is used to cheek the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECX:_FILE is checked by a set of 
executable testa. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is cooqpiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is atteoipted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for exan^le, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes uy be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 


1-2 





ihtroductiom 


this iniplMMntation «r« d««crib«d in ■•ctlon 2.3. 

For oach Ada io^loiiMintationr a custonizad taat suit# la producad by tha 
AVF. Thla cuatonizatlon conslats of making tha modifications daseribad in 
tha pracading paragraph, ramoving withdrawn tasts (saa saction 2.1), and 
possibly-ramoving soma inapplicabla tasts (saa saction 2.2 and [UG89]). 

In ordar to pass an ACVC an Ada implamantation must procass aach tast of 
tha cuatomizad tast suits according to tha Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compilar Tha softwara and any naadad hardwara that hava to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compilar Tha means for tasting compliance of Ada implamentations. 
Validation consisting of the taat suite, tha support programs, tha ACVC 
Capability user's guide and tha tan^late for tha validation sunoutry 

(ACVC) report. 

Ada An Ada compilar with its host computer system and its 

Implamantation target computer system. 

Ada Joint Tha part of tha certification body which provides policy and 

Program guidance for tha Ada certification system. 

Office (AJPO) 

Ada The part of tha certification body which carries out tha 

Validation procedures required to establish tha compliance of an Ada 
Facility (AVF) implamantation. 

Ada Tha part of tha certification body that provides technical 

Validation guidance for operations of tha Ada certification system. 

Organization 
(AVO) 

Compliance of Tha ability of tha implasientation to pass an ACVC version, 
an Ada 

Implementation 

Computer 
System 


A functional unit, consisting of one or more computers and 
associated softwara, that uses eoamon storage for all or 
part of a program and also for all or part of tha data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify thesiaelves during execution. A 
computer system may be a stand-alone unit or may consist of 


1-3 






INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada • 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


several inter-connected units. 

Fulfillment by a product, process, or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada Implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
AMSI/MIL-STD-181SA-1983 and ISO 8652-1987. Citations from 
the LRM take the form '‘<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada iaqplementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
teat objective, fails to meet its test objactive*, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 


I 







CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Th« following tests have been wlthdravm by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 02 August 1991. 


E28005C 

B28006C 

C32203A 

C34006D 

C3SS08I 

C35508J 

C3S508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C4S612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B8S001L 

C86001P 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

B01B02B 

B01B06A 

AD1B08A 

B02A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41B 

CD2A87A 

CD2B15C 

B03006A 

B04008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD40240 

CD4031A 

C04051D 

CD5111A 

CD7004C 

BD700SD 

CD700SE 

AD7006A 

CD7006E 

AD7201A 

AD7201B 

CD7204B 

A07206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CB2119B 

CB220SB 

CE2405A 

CE3111C 

CB3116A 

CB3118A 

CB3411B 

CB3412B 

CB3607B 

CB3607C 

CE36070 

CE3812A 

CB3814A 

CB3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by docuoients issued by ISO and the AJPO known as Approved Ada 
Commentaries and comsionly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicatedi references to Approved Ada Commentaries are 
Included as appropriate. 


2-1 






IMPLEMENTATION DEPENDENCIES 


B22005A..C and B22005P (4 tests), respectively, check that the control 
characters SOH, STX, ETX, and DLE are illegal when outside of character 
literals, string literals, and comments; for this implementation those 
characters have a special meaning to the underlying system such that the 
test file is altered before being passed to the compiler. (See section 
2.3.) 


The following 159 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 


C241130..Y (11 teats) (*) 
C35706O..Y (11 tests) 
C3S708O..Y (11 tests) 
C452410..Y (11 tests) 
C454210..Y (11 testa) 
C455240..Z (12 tests) 
C456410..Y (11 tests) 


C3570SO..y (11 tests) 
C35707O..y (11 tests) 
C3S802O..Z (12 tests) 
C453210. .y (11 tests) 
C455210..Z (12 tests) 
C456210..Z (12 tests) 
C46012O..Z (12 tests) 


(*) C24113W. .y (3 tests) contain lines of length greater than 255 
characters which are not supported by this implementation. 

The following 20 testa check for the predefined type LONG_INTEGER: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101P 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a predefined 
integer type with a name other than INTEGER, LONG_INTEGER, or 
SHORT INTEGER. 


C35713D and B86001Z check for a predefined floating-point type with a name 
other than FLOAT, LONG^FLOAT, or SHORT_FLOAT. 

C41401A checks that CONSTRAINT_ERROR is raised upon the evaluation of 
various attribute prefixes; this implementation derives -the attribute 
values from the subtype of the prefix at compilation time, and thus does 
not evaluate the prefix or raise the exception. (See Section 2.3.) 

C45531M..P (4 tests) and C45532N..P (4 tests) check fixed-point operations 
for types that require a SYSTEM.MAX^MANTISSA of 47 or greater. For this 
implementation, MAX_MAMTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINEjOVERFLOHS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base 
type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

B8600iy checks for a predefined fixed-point type other than DURATION; for 
this implementation, there is no such type. 


2-2 






IMPLBMBMTATION DEPENDENCIES 

C96005B chttcks for valuos of typ« DURATION'BASE that ara outaida the rangm 
of DURATION. Thera ara no auch valuaa for thia implamentation. 

CD1009C uaea a repraaentation clauaa apecifying a non-default aize for a 
floating-point type; thia implementation doea not aupport auch aizea. 

CD2A84A, CD2A84E, CD2A84I..J (2 teata), and CD2A840 uae repraaentation 
clauaea apecifying non-default aizea for acceaa typea; thia implementation 
doea not aupport auch aizea. 

BD8001A, BD8003A, BDS004A..B (2 teata), and AD8011A uae machine code 
inaertiona; thia implementation providea no package MACHINE_CODE, 

The following 264 teata check operationa on aeguential, text, and 
direct acceaa filea; thia implementation doea not aupport external 
fileai 


CE2102A. .C 

(3) 

CE21026..H 

(2) 

CE2102K 


CE2102N..y 

(12 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

:2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CB2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE220SA 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401B..F 

(2) 

BE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CB3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..B 

(2) 

CB3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CS3208A 


CE3301A 


EE3301B 


CE3302A 


CS3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

'CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M. .O 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..6 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

OE3806G • ail 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CS3906A.aC 

(3) 

CE3906E..F 

(2) 


CE2103A, CE2103B, and CE3107A expect that NAME_ERROR ia raiaed when an 
attempt ia made to create a file with an illegal name; thia 
implementation doea not aupport the creation of external filea and ao 
raiaea USE_ERROR. (See aection 2.3.) 


2-3 






implementation dependencies 


2.3 TEST MODIFICATIONS 

Modifications (sae section 1.3) were required for 30 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the 
way expected by the original tests. 

B22003A B24009A B29001A B38003A B38009A B38009B 
B91001H BC20010 BC2001E BC3204B BC3205B BC3205D 

B22005A..C and B22005P (4 tests) %fere graded inapplicable by Evaluation 
Modification as directed by the AVO. These testa, respectively, check 
that control characters SOH, STX, ETX, and DLE are illegal outside of 
character literals, string literals, and coiianents. This implementation's 
underlying CAIS system gives special meaning to each of these control 
characters such that their effect is to alter the test files in a way that 
defeats the test objectives—either the characters alone, or together with 
any text that follows them on the line, are not passed to the compiler. 
Hence, B2200SB and B2200SP compile without error, while the other tests 
‘have syntactic errors introduced by the loss of test text. 

B2S002A, B2600SA, and B27005A tMre graded passed by Evaluation 
Modification as directed by the AVO. These tests check that control 
characters SOH, STX, ETX, and DLE are illegal within of character 
literals, string literals, and comments, respectively. This 
implementation's underlying CAIS system gives special meaning to each of 
these control characters such that their effect is to alter the test files 
in the following way: these characters, and except in the case of DLE any 
text that follows them on the line, are not passed to the compiler. The 
tests were thus graded without regard for the lines that contained one of 
these four control characters. 

C34007P and C34007S were graded passed by Evaluation Modification as 
directed by the AVO. These tests include a check that the evaluation of 
the selector "all" raises CONSTBAINT_ERROR when the value of the object is 
null. This implementation determines the result of the equality tests at 
lines 207 and 223, respectively, based on the subtype of the object; thus, 
the selector is not evaluated and no exception is raised, as allowed by 
LBM 11.6(7). The tests were graded passed given that their only output 
from REPORT.FAILED was the message "NO EXCEPTION FOR NULL.ALL - 2". 

C41401A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test checks that the evaluation of attribute prefixes that 
denote variables of an access type raises CONSTRAINT^ERROR when the value 
of the variable is null and the attribute is appropriate for an array or 
task type. This implementation derives the array attribute values from 
the subtype; thus, the prefix is not evaluated and no exception is raised, 
as allowed by LRM 11.6(7), for the checks at lines 77, 87, 97, 108, 121, 
131, 141, 152, 165, 6 175. 

C83030C and C86007A %rare graded passed by Test Modification as directed by 
the AVO. These tests were modified by inserting "PRAGMA ELABORATE 


2-4 







IMPLEMENTATION DEPENDENCIES 


(REPORT);" b«for« th« package declarations at lines 13 and 11, 
respectively. Without the pragma, the packages may be elaborated prior to 
package Report's body, and thus the packages' calls to function 
REPORT. IDENT_INT at lines 14 and 13, respectively, will raise 
PR06RAM_BRR0R. 

BC3204C..D and BC3205C..0 (4 tests) were graded passed by Evaluation 
Modification as directed by the AVO. These tests are expected to produce 
compilation errors, but this implementation compiles the units without 
error; all errors are detected at link time. This behavior is allowed by 
AI-00256, as the units are illegal only with respect to units that they do 
not depend on. 

CE2103A, CE2103B, and CE3107A were graded inapplicedsle by Evaluation 
Modification as directed by the AVO. The tests abort with an unhandled 
exception when USE_ERROR is raised on the attempt to create an external 
file. This is acceptable behavior because this implementation does not 
support external files (cf. AI-00332). 


2-5 





CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


Th« Ada Iffiplamantation taatad in this validation affort is dascribad 
adaquataly by tha information givan in tha initial pagas of this raport. 

For a point of contact for tachnical and salas information about this Ada 
implamantation aystam, saas 

Alsys GmbH & Co. KG 
Am RUppurrar SchloB 7 
N-7500 Karlsruha 51 
Garmany 

Tal. •f49 721 883025 

Tasting of this Ada implamantation was conductad at tha AVF's sita by a 
validation taam from tha AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implamantation passas a givan ACVC varsion if it procassas aach 
tast of tha customizad tast suita in accordanca with tha Ada Programming 
Languaga Standard, whathar tha tast is applicabla or inapplicabla; 
otharwisa, tha Ada Implamantation fails tha ACVC [Pro90]. 

For all procassad tasts (inapplicabla and applicabla), a rasult was 
obtainad that conforms to tha Ada Programming Languaga Standard. 

Tha list of itams balow givas tha numbar of ACVC tasts in various 
catagorias. All tasts wars procassad, axcapt thosa that wmrm withdrawn 
bacausa of tast arrors (itam b; saa saction 2.1), thosa that raquira a 
floating-point praciaion that axcaads tha iatplasiantation's maximum 


3-1 







raoasszws zhforiaticmi 


praeision (Itam •; ••• ••etlon 2.2), and thoaa that dapand on tha support 
of a fila systam — If nona is supportad (Itam d). All tasts passad, 
axcapt thosa that ara llstad In sactiona 2.1 and 2.2 (countad in itams b 
and f, balow). 


a) Total Number of Applicable Tasts 3593 

b) Total Number of Withdrawn Tasts 95 

c) Processed Inapplicable Tasts 59 

d) Non-*Procassad I/O Tasts 264 

a) Non-Processad Floating-Point 

Precision Tests 159 


f) Total Number of Inapplicable Tasts 482 (e-t^-fa) 

g) Total Number of Teats for ACVC 1.11 4170 


3.3 TEST EXECUTION 

ACVC 1.11 was run at lABG's premises as follows: With tha customer's macro 
parameter fila tha customised ACVC 1.11 was produced. Than CAIS version 
5.5E as supplied by tha customer was loaded and installad on tha candidate 
VAX 8350 computer. Next tha basic CAIS node modal and tha candidate Ada 
implementation were installed. Than tha full sat of testa was processed 
using command scripts provided by tha customer and reviewed by the 
validation team. Tests were processed in two steps. In the first step 
tests vrere compiled and linked as appropriate, producing listings and 
possibly load modules. In the second step load modules «iere downloaded to 
the target computer via a serial communications line using a command 
script provided by the customer and reviewed by the validation team 
and executed on the target. The results were captured on the host system. 
See Appendix B for a complete listing of the processing options for this 
implementation. It also indicates the default options. 

Compilation was made using the following parameter settings: 

SOURCE -> "'CURRENT_USSR'DOT(SRC)" 

LIBRARY •> "'CURRENT~USER'AOA_LIBRARY(SAMPLE)” 

LIST ■> CURRENTJJSER'DOtTlIS)" 

LOG ■> "'CURRENt”uSER'DOT(LOG)" 

The parameters SOURCE and LIBRARY do not have a default value and need to 
be specified anyway. 

The default of the parameters LIST and LOG means that no listing, resp. no 
log output is to be produced. The values used for validation are CAIS 
pathnames in order to obtain the corresponding output in the file nodes 
specified by the respective pathnames. 

Linking was made using the following parameter settings: 


3-2 







PROCESSING INFORMATION 


UNIT B> ... — Main Program to b« linkad 

LIBRARY » "'CURRENT_USER'AOA_LIBRARY(SAMPLE)" 

EXECUTABLE ■> "'CURRENT~USER*DOtTeXE)" 

KERNEL «> "'EXECUTABLE_IMAGE'DOT_PARENT'DOT(MTK_133)" 

DEBUG » NO 

LOG »> "'CURRENT_USER*DOT(LOG)" 

The parameters UNIT, LIBRARY and EXECUTABLE do not have a default value 
and need to be specified anyway. 

The default value for the parameter KERNEL means that no kernel is 
linked. The value used for validation is a CAIS pathname to the 
minimal target kernel for the MVME133XT board. This is the only 
kernel provided by the customer with the candidate Ada implementation. 

It does neither contain debugger support nor communication support. 

The default of the parameter LOG means that no log output is to be 
produced. The value used for validation is a CAIS pathname in order to 
obtain the corresponding output in the file node specified by the 
pathname. 

The default value for the parameter DEBUG is not used, since ALSYS has 
provided only the runtime system which does not include debugger support. 

Test output, compiler and linker listings, and job logs were captured on 
a Magnetic Tape and archived at the AVT. The listings examined by the 
validation team were also archived. 





APPENDIX A 


MACRO PARAMETERS 

This sppsndix contains ths macro paramstsrs uasd for customizing ths ACVC. 
Ths moaning and purpose of thsso paramstars ars explained in [0G89]. The 
pareuneter values are presented in two tables. The first table lists the 
values that are defined in terms of the maxjimim input-line length, which is 
the value for $MAX_IM_LEM—-also listed here. These values are expressed 
here as Ada string aggregates, where ”V” represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 2SS — Value of V 

$BIG__ID1 (1..V-1 ■> 'A', V «> '1') 

SB1G_ID2 (1..V-1 •> 'A', V -> '2') 

SB1G_ID3 (1..V/2 •> 'A*> 6 '3' 6 

(1..V-1-V/2 •> 'A') 

$BIG_1D4 . (1..V/2 •> 'A') 6 '4' A 

” (1..V-1-V/2 ■> 'A') 

SBIG_INT_LIT (1..V-3 •> '0') A "298" 

$BIG_RBAI.__LIT (1..V-5 -> '0') A "690.0" 

$BIG_STRING1 A (1..V/2 ■> 'A') A 

$BI0_STRIHG2 A (1..V-1-V/2 •> 'A') A '1' A 

$BLANKS (1..V-20 ) 

$MAX_LEN_XNT_BASED_LZTXRAL 

"2:" A (1..V-5 -> '0') A "11s" 

$MAX LEM REAL BASED LITERAL 

"16s" A (1..V-7 -> '0') A "P.Es" 

$MAX STRING LITERAL '-'ft (1..V-2 -> 'A') A 








MACRO PARAMETERS 


Th« following tabl* list* all of tha othar macro paramatars and thair 
raspactiva valuas. 


Macro Paramatar 

Macro Valua 

$ACC_SIZE 

32 

$ALI6NMENT 

4 

$COUNT_LAST 

2_147_483_647 

$DEFAOLT_MEM_SIZE 

2147483648 

SDEPAUI.T_STOR_ON1T 

8 

$DEFAaLT_SYS_NAME 

MOTOROLA_68020__BARE 

$OELTA_DOC 

2#1.0#E-31 

$ENTRY_ADORSSS 

SYSTEM.INTERRUPT_VECTOR(1) 

$RMTRy_ADORESSl 

SYSTEM.ZNTERRUPTJ/ECTOR(2) 

$BIITRy_A0DRESS2 

SYSTEM.IMTERRUPT_yECTOR(3) 

$FIELO_LAST 

512 

SFILBJTBRMIIIATOR 


$FIXBD__NAME 

NO_SUCH_FIXED_TYPE 

$FLOAT_NAME 

HO__SOCH_FLOAT_TYPE 

$FORM_STRING 

ft ft 

$FORM_STRZNG2 

"CAM!I0T__RESTR1CT_FILE_CAPACITY 

$GRBATER_THAM_OURATZON 

0.0 


$6RSATER_THAM_0URATZ0N_BASB_LAST 

200_000.0 

$ORSATBR_THAN_PLOAT_BASE_LAST 

16#1.0#E+256 

$6RBATBR_TRAM_FLOAT_8AFE_LAROB 

16M.8#E-»-256 

$GRBATBR_THAN_SHORT_FLOAT_SArB_LAROB 

16#D.8#E+32 






SHXOR PRIORITY 


15 


$ILLB0AI._1XTSRHAL_FZLS_HAMB1 

PZLBl 

$ ZLLEGAL_EXTBRNAL_FZLK_NAME2 

P1LB2 

$IHAPPROPRIRTB_LINE_LEMGTH 

" -1 

$IHAPPROPRZATR_PAGB_LBMGTH 

” -1 

SIHCLODB^PRACMAl PRAGMA IMCLODB (-A28006D1.TST*) 

$IMCLOOB_PRAOMA2 PRAGMA IHCLODB ("B28006F1.TST") 

$IMTBGBR_FIRST -2147483648 

$ZNTBGBR_LAST 2147483648 

$IHTBGBR_IAST_PLU8_1 2147483648 

$XNTBRFACB_LAMGaAGB ASSEMBLER 

$LESS_TBAN_DnRATXON -0.0 

$LESS_THAHJ)URAT10H^BASEjriRST 

- 200 ^ 000.0 

$LXNE_TERMXNATOR ' ' 

$LOW_PRXORXTY 0 

$MACHXNE_CODE_STATEMBirr 

NULL; 

$MACHXME_OODE_TYPE NO_SOCHjrYPB 
$MANTXSSA_OOC 31 

$MAX_DXGXTS 18 

$MAX_XMT 2147483647 

$MAX_XlPr_PLOS_l 2_147_483_648 

$MXN_XHT • -2147483648 

NO_SUCH_TYPB 

A-3 


$NAMB 



mCRO PARAMETERS 


$NAME_LIST 

MOTOROLA_68020_BARE 

$NAME_SPECXFICATXONl 

X2120A 

$NAME_SPECXFXCATXON2 

X2120B 

$NAME_SPECXFXCATXON3 

X3119A 

SNEG_BASED^XMT 

16#FFFFFFFE# 

$IIEHJMEM_SXZE 

2147463648 

$NSW_SYS_RAMB 

MOTOROLA_68020_BARS 

$PAGE_TERMXNATOR 

« 0 

$RECORO_DEFXNXTXON 

NEW XNTSGER 

$RECORO_NAME 

HO_SOCH_MACHXNE_CODE_TyPE 

$TASX_SXZE 

32 

$TASK_STORA6E_SXZE 

10240 

$TXCK 

1.0 

$VARXABLE_AOORESS 

GET_yARXABLE_AODRXSS 

$VARXABLB_AOORXSSl 

GXT_VARXABLS_ADDRXSS1 

$VARXABX^_AODRXSS2 

GST_VARXABLE ADDRESS2 


A-4 





APPENDIX B 


COMPILATION AND LINKER SYSTEM OPTIONS 


Th« cooipilar and linkar options of this Ada Implsnsntatlon, as dsscrlbsd 
In this Appsndlx, ars provldsd by ths customar. Unlass spaclflcally notad 
otharwlsa, rafarancaa In this appandlx ara to cooipllar docuotantatlon and 
not to this raport. 






Compiling 


Chapter 4 


4 Compiling 


After a program library has been created, one or more compilation units be com¬ 
piled in the context of this library. The compilation units must adl be on the *»Tnm gje. 
One unit, a parameterless procedtire, acts as the program. If all units needed by 
the m ai n program and the main program itself have been compiled successfully, they 
can be linked. The resulting code can then be downloaded by using appropriate toob 
of the SWG APSE (Loader, Debugger). 

§4.1 and Chapter 5 describe in detail how to call the Compiler and the Linker. Li 
§4.2 the Completer, which b called to goierate code for instances of generic units, b 
described. 

Chapter 6 es^lains the information which b given if the execution of a program b 
abandoned due to an unhandled exception. 

The information the Compiler produces and outputs in the Compiler lif ting is 
in §4.4. 

Finally, the log of a sample session b given in Chapter 7. 


4.1 Compiling Ada Units 

To start the SYSTEAM Ada Compiler, use the coa^ile.target command. 


compile.target 


Cozxmiand Description 


Format 


PROCEDURE eoa^ile.target ( 


source 

analyze_dependeney 

cheek 

eopy_aouree 

given_b7 

Inline 

library 

Ust 

log 

Baehine.eode 


string 

yes-no-anawer :• no: 

yes_no_ans«er :■ yes; 

yes.no.ansver :■ yes; 

souree-cholees :• pathnaae; 

yes_no_ans«er :• yes; 

pathnaae.type 

:■ default^ibrary: 


pathname .type 
pathname .type 
yes.ao.answer 


nolist: 

nolog: 

no; 


9YSTEAM Ada System • User Manual 


39 








Compiling 


Chapter 4 


Debugger know this name. You can use the directory-target (.... 
full •> yes. ...} command to see the file name of the copy. If a specified 
file contains several compilation units a copy contuning only the source text 
of one compilation unit is stored in the library for each compilation unit. 
Thus the Recompiler can recompile a single unit. 

If copy.8ource » no is specified, the Compiler only stores the name of 
the source file in the program library. In this case the Recompiler and the 
Debugger are able to use the original file if it still exists, 
copy-source »> yes cannot be specified together with analyze-depen¬ 
dency. 

given-by : source-choices :• pathname 

given-by •> pathname indicates that the string of the source parameter 
is to be interpreted as a pathname. 

given-by » unique-identifier indicates that the string of the source 
parameter is to be interpreted as a unique identifier. 

By default it is interpreted as a pathname. 

inline : yes-no-ansver :■ yes 

Controls whether inline expansion is performed as requested by PRAGMA 
inline. If you specify no these pragmas are ignored. 

By default, inline expansion is performed. 

library : pathname.type :« default-library 

Specifies the program library the command works on. The compile-target 

command needs write access to the library. 

The default is ’CURRENT-USER’ADA-LIBRART(STD). 

list : pathname-type :■ nolist 

Controls whether a listing is written to the given file. 

By default, the compile command does not produce a listing file. 

log : pathname-type :• nolog 

Controls whether the Compiler appends additional messages to the speci¬ 
fied file. 

By default, no ad(Rtional messages are written, 
machine-code : yes-no-answer :■ no 

Controls whether machine code is appended at the listing file, machine- 
code has no effect if list is nolist or analyze-dependency ■> yes is 
specified. 

By default, no machine code is appended at the listing file, 
optimize : yes-no-answer :« yes 

Controls whether full optimizatimi is applied in generating code. There is 
no way to specify that only certain optimizations are to be performed. 

By default, full optimization is done. 


SYSTEAM Ada System - User Manual 


41 





Compiling 


Chapter 4 


4.2 Completing Generic Instances 

Since the Compiler does not generate code for instances of generic bodies, the Com¬ 
pleter must be used to complete such units before a program using the instances can 
be executed. The Completer must also be used to complete packages in the program 
which do not require a body. This is done implicitly when the Linker b called. 

It is also possible to call the Completer explicitly with the coaplete-target command. 


complete-target 


Command Description 


Format 


PROCEDURE coBplete.target ( 


unit 

check 

Inline 

library 

list 

log 

aachine^code 

optimize 


unitname .type 
yes.no.answer :■ yes; 

yes.no.jms«er :« yes; 

pathnaae.type 

:« delaultJLibzary; 


pathnaae.type 
pathnaae.type 
ye8.no.answer 
yes.no.answer 


« nolist; 
« nolog; 
• no; 

■ yes); 


Description 

The coa^lete.target command invokes the SYSTEAM Ada Completer. 
The Completer generates code for all instantiations of generic units in 
the execution closure of the specified unit(s). It also generates code for 
packages without bodies (if necessary). 

By default, the Completer is invoked implicitly by the link.targst com¬ 
mand. In normal cases there is no need to invoke it e^licitly. 

Parameters 

unit : unitnaae.type 

specifies the unit whose execution closure is to be completed, 
cheek : yes.no.answer :• yes 

Controls whether all run-time chetks are suppressed. If you specify no this 
is equivalent to the use of PRAGMA suppress for all kinds of checks. 


SYSTEAM Ada S]r8texn • User Manual 


43 








Compiliag 


Chapter 4 


In the following the term recompilation stands for the recompilation of an obsolete 
unit using the identical source which was used the last time. (This kind of recom¬ 
pilation could alternatively be implemented by using some appropriate intermediate 
representation of the obsolete unit.) This definition is stronger than that of the LRM 
(10.3). If a new version of the source of a unit is compiled we call it compilation^ not 
a recompilation. 

The set of units to be checked for recompilation or new compilation is described by 
specifying a imit and the kind of a closure which is to be built on it. In many cases 
you will simply specify your main program. 

The automatic recompilation of obsolete units is supported by the recoopile.target 
command. It determines the set of obsolete units and generates a command file for 
calling the Compiler in an appropriate order. This command file is in fact an Ada 
program using the facilities of the package CLI-JNTERFACE provided by the SWG APSE 
CLL 

The recompilation is performed using the copy of the obsolete units which is (by 
default) stored in the library. (If the user does not want to hold a copy of the sources 
the recooplle .target command offers the facility to use the ori^al source.) 

The automatic compilation of modified sources is rapported by the autocospile, 
target command. It determines the set of modified sources and generates a command 
file for calling the Compiler in an appropriate order. This conunand file is in &ct an 
Ada program using the facilities of the package CLI.INTEEFACE provided by the SWG 
APSE CLL The basis of both the reeoa^ile.target and the autocospile.target 
command is the information in the library about the dependencies of the concerned 
units. Thus neither of these conamands can handle the compilation of units which have 
not yet been entered in the library. 

The automatic compilation of new sources is supported by the cospile.target com¬ 
mand together with the analyze.dependescy parameter. This command is able to 
accept a set of sources in any order. It makes a syntactical analysis of the sources and 
determines the dependencies. The units ’’compiled” with this command are entered 
into the library, but only their names, their dependencies on other units and the name 
of the source files are stored in the library. Units which are entered this way can 
be automatically compiled using the autocoi&pile.target command. They cannot 
be recompiled using the recoapile.'targe't command because the recompile .target 
command only recompiles units which were already compiled. 

The next sections explain the usage of the reconpile.target command, the auto** 
cosipile.target command, and the compile.target command with analyze.depen** 
dency <■> yes. 


SYSTEAM Ada System - User 


45 





Compiling 


Chapter 4 


The recompile.target command uses the copy of the source which is 
stored in the library for the recompilation. By default, the compile com¬ 
mand stores a copy of the soiirce in the library. If there is no copy in 
the library - because the unit was compiled using the copy-source ■> no 
parameter - the recooplle-target issues a warning and generates a com¬ 
pile-target command for the original source file name. It is not checked 
whether such a file still exists. This command only performs a real recom- 
pdlation if the current source is the same which was last compiled. 

In the co mman d file each recompilation of a unit is executed under the 
condition that the recompilation of other units it depends on was successful. 
Thus useless recompilations are avoided. The generated command file only 
works correctly if the library was not modified since the command file was 
generated. 

Note: If a unit firom a parent library is obsolete it is compiled in the 
sublibrary in which the recompile-target command is used. In case 
a later recompilation in the parent library may be hidden afterwards. 

Parameters 

unit : unitnane.type 

Specifies the unit whose closure is to be built. 

output : pathname-type 

Specifies the name of the generated command file. 

body-ind : yes-no-anawer :• no 

specifies that unit stands for the secondary unit with that tutTn«». By 
default, unit denotes the library unit. If unit specifies a subunit, the 
body-ind parameter need not be specified. 

bodies-only : yes-no.answer :« no 

Controls whether all units of the closure are recompiled (default) or only 
the secondary units. This parameter is only effective if conditional ■> 
no is specified. 

check : yes-no-same-answer :■ same 

check ■> same means that the same value for the parameter check is 
included in the generated command file which was in effect at the last 
compilation. See the same parameter of the compile-target command. 
Chherwise the given value for the check parameter is included in the com¬ 
mand file. 

By default the parameter value of the last compilation is included, 
closure : closure-choices :• execute 


SYSTEAM Ada System • User Manual 


47 





Compiling 


Chapter 4 


Otherwise the given value for the optimize parameter is included in the 
command file. 

By default the parameter value of the last compilation u included. 


End of Conunand Description 


4.3.2 Compiling Nefw Sources 


The autocospile.target command supports the automatic compilation of units for 
which a new source exists. The command receives as parameters a set of units which 
are to be used to form the closure of units to be processed. The kind of closure can be 
specified. For every unit in the closure, the autocoapile.target checks whether there 
exists a newer source than that which was used for ^e last compilation. It generates a 
command file with a sequence of compile-target commands to compile the units for 
which a newer source exists. If a unit to be compiled depends on another unit which 
is obsolete or which will become obsolete and for which no newer source exists, the 
autocoa^ile.target command always adds an appropriate coapile.target (.... 
reeas^ile ■> yes. ...) command to make it current; the recosqpile parameter 
controls which other obsolete units are recompiled, and can indeed be used to sped^ 
that the same recompilations are done as if the reeoapile-target command was 
applied subsequently. The generated command file is in fact an Ada program using 
the facilities of the package CLI-IKTERFACE provided by the SWG APSE CLL The 
name of the command file can be specified using the output parameter. 


autocompile-target 


Command Description 


Format 


PROCEDURE autoeos^ile-target ( 


unit 

unitnaae-type 

• 

s 

output 

pathnaae -type 

f 

body-ind 

yes_no-answer 

;■ no; 

bodies-only 

yes_no.answer 

:■ no; 

cheek 

yes-no-saae-answer 

:■ saae; 

closure 

closure-choices 

:■ execute; 

conditional 

yes-no-answer 

;■ yes; 

copy-souree 

yes-no-answer 

;■ yes; 

inline 

yes-no-saae-answer 

:« saae; 

library 

pethnaae-type 



default-library; 


SYSTEAM Ada System • User Manual 


49 







Compiling 


Chapter 4 


The autoeon^lle.target command does not folly handle the problem 
which arises when several compilation units are contained within one source 
file; it only avoids the multiple compilation of the same source file. If you 
want to use the autocomplle.target command it is recommended not to 
keep several compilation units in one source. 

Parameters 

unit : unitname.type 

Specifies the unit whose closure is to be built. 

output : pathname-type 

Specifies the name of the generated command file. 

body-lnd : yes_no.ans«er :• no 

specifies that unit stands for the secondary unit with that name. By 
default, unit denotes the library unit. If unit specifies a subunit, the 
body-ind parameter need not be specified. 

bodies.only : yea.no-ans«er :• no 

Controls whether all new units of the closure rre compiled (default) or only 
the secondary units. This parameter is only effective if conditional *> 
no is specified 

cheek : yes-no-same..ans»#r :« same 

cheek •> same means that the same value for the parameter check is 
included in the generated command file which was in effect at the last 
compilation. See the same parameter of the compile-target command. 
Otherwise the given value for the check parameter is included in the com¬ 
mand file. 

By default the parameter value of the last compilation is included, 
closure : closure-choices :■ execute 

Controls the kind of the closure which is built and which is the basis for the 
investigation for new sources, closure •> noclosure means that only the 
specified unit is to be checked, closure ■> compile means that oxily those 
units on which the specified unit transitively depend(s) are regarded, clo¬ 
sure •> execute means that - in addition - all relat^ secondary units and 
the units they depend on are regarded. If closure ■> tree is specified, a 
warning is issued stating that this is not meaningful for this co mm a n d and 
that the de&ult value is taken instead. 

By default, the esracution closure is investigated for new sources, 
conditional : yes-no-ans«er :■ yes 

Controls whether the check for new sources is performed (default), no 
means that all units in the closure are compiled disregarding the modifica^- 
tion date. This parameter is useful for compiling the complete closure with 
different parameters than the last time. 


SYSTEAM Ada System - User Manual 


51 





Compiling 


Chapter 4 


Controb whether the autocompilo .target command additionally recom¬ 
piles obsolete units. With recompile ■> ae^necessary only those units 
are recompiled which are obsolete or become obsolete and are used by 
other units which axe to be compiled because of new sources, recompile 
■> same .status additionally recompiles those units of the considered clo¬ 
sure which will become obsolete during the compilation of new sources. 
Thb option specifies that there shall not be more obsolete units after the 
execution of the command file than before, recompile »> as.possible 
specifies that all obsolete units of the closure and all units which will be¬ 
come obsolete are recompiled. Thb b equivalent to a subsequent call of the 
recompile.target command after the run of the command file generated 
by the autocompile.targe-t command. 


End of Command Description 


4.3.3 First compilation 

The SYSTEAM Ada System supports the first compilation of sources for which no 
compilation order b known by the compile.target command with parameter ana- 
lyze.dependency in combination with the autocoi^ile.target command. 

With the analyze.dependency parameter the Compiler accepts sources in any order 
and performs the syntax analysb. the sources are syntactically correct the units 
which are defined by the sources are mtered into the library. Their names, their de¬ 
pendencies on other units and the name of the source files are stored in the library. 
Units which are entered thb way can be automatically compiled using the autocom- 
pile.target command, i.e. the Autocompiler computes the first compilation order 
for the new sources. The name of the main program, of course, must be known and 
specified with the autocomplle.target command. 

Note that the compile.target C.... analyze.dependency «> yes. ...) command 
replaces other units in the library with the same name as a new one. Thus the library 
may be modified even if the new units contain semantic errors; but the errors will not 
be detected until the command file generated by the autocomplle.target command b 
nm. Hence it b recommended to use an empty sublibrary if you do not know anything 
about the set of new sources. 

If there are several sources contuning units with the same name the last analyzed one 
will be kept in the library. 

The autocomplle.target command issues special warnings if the information about 
the new units b incomplete or inconsistent. 


SYSTEAM Ada System - User Manual 


53 




Compiling 


Chapter 4 


Warnings and information messages have no influence on the success of a compilation. 
If there are any other diagnostic messages, the compilation was unsuccessful. 

Ail error messages are self-explanatory. If a source line contains errors, the error 
messages for that source line are printed immediately below it. The exact position in 
the source to which an error message refers is marked by a number. This number is 
also used to relate different error messages given for one line to their respective source 
positions. 

la order to enable semantic analysis to be carried out even if a program is syntactically 
incorrect, the Cpmpiler corrects syntax errors automatically by inserting or deleting 
symbols. The source positions of insertions/deletions are marked with a vertical bar 
and a number. The number has the same meaning as above. 1£ a larger region of the 
source text is affected by a syntax correction, this region is located for the user by 
repeating the number and the vertical bar at the end as well, with dots in between 
these bracketing mairkings. 

A complete Compiler listing follows which shows the most common kinds of error 
messages, the technique for marking affected regions and the numbering scheme for 
relating error messages to source positions. It is slightly modified so that it fits into 
the page width of this document: 


e********************************************************************* 
«* * 

** SYSTEAM ADA • COMPILER VAX/VMS/CAIS X MC68020/BARE 1.82 * 

** 

** 90-01-29/08:39:44 • 

** * 

4i**«*«****««******«**)|i**«*********4i*********«**********************«** 


Started at : 08:39:44 


. procedure listing_example 


1 procedure listing-sxaapls IS 

2 abe : procedure integer RAHGE 0 .. 9 :« lOE-1: 


»»> SYNTAX ERROR 

SyaboKs) deleted (1) 

»»> SYMBOL ERROR (1) An exponent for an integer literal oust not 

have a sinus sign 
3 def integer RANGE 0 .. 9: 


SYSTEAM Ada System - User Manual 


55 












Lmlrint 


Cliapter 5 


5 Linking 

The Linker of the SYSTEAM Ada System either performs incremental linViTig or 
linking. 

Final linking produces a program image file (see §5.6) which contains a loadable pro¬ 
gram. The code portion which is part of the program image file must be loaded onto 
the target lata on. Final linking can (but need not) be based on the results of previous 
incremental linking. 


Incremental linking means that a program is linked step by step (say in N ^ 1 steps 
1 ... N). All steps except the last one are called incremental linlring steps. In an 
incronental linking step, a collection image JUe (see §5.6) containing a collection is 
produced; a collection is a set of Ada units and external units. 

Each step X € {2 ... N} is based on the result of step X-1. The last step is always 
a final link, Le. it links the Ada main program. The result of an incremental linlring 
step is also a code portion which must be loaded onto the target later on. 

So the code of a program may consist of several code portions which are loaded onto 
' the target one by one. This is called incremental loading. 

The reasons for the introduction of the concept of incremental Kwlrfwg and loading into 
the Ada Cross System are the foUovnng: 

• It should be possible that some Ada library units and external units are compiled, 
linked, and burnt into a ROM that is plugged into the target, and th%t programs 
using these units are linked afterwards. 

• The loading time during program development should be as short as possible. 
This is achieved by linking those parts of the program that are not expected 
to be changed (e.g. some library units and the Ada Runtime System). The 
resulting code portion is loaded to the target and need not be linked or loaded 
later on. Instead, only those parts of the program that have been modified or 
introduced since the first link must be linked, so that the resulting coe portion 
is much smaller in size than the code of the whole program would be. Because 
typically this code portion is loaded several times during program development, 
the development cycle thne is reduced drastically. 

The Runtime System (which is always necessary for the execution of Ada programs) 
is always linked during the first Imklng step. ^ particular, this means that also the 
version of the Runtime System (Debug or Non-Debug) is fixed during the first step. 

The Linker gives the user great fiesdbility by alloemg him to prescribe the mapping 
of single Ada units and assembler routines into the memory of the target. This, for 


SYSTEAM Ada System - User Manual 


57 






Chapter 5 


Linking 




link -maSn^target 

Command Description 


Forxnat 


PROCEDUBE Unk-aain 
unit 

executable 

baee 

check 

co^lete 

debug 

directlTe 

exteznal 

inline 

kernel 

library 

liBker.Jdsting 

list 

log 

aachine.eode 

■ap 

optiaixe 


target ( 

: uttitnane.tTpe 
: pathnaae.type 
: pathnane.type 
: 7 ee_no.answer 
: yes.no.ans«er 
: yesuko_ans«er 
: pathnaae.tTpe 
:• 

: extern-list 
: yes-no-answer 
: pathnane.type 
: pathnane.type 

:■ 

: pathnane.type 
: pathnane.type 
: pathnane.type 
: yesjo-answer 
: pathnane.type 
: yes .no .answer 


■ nobase: 

■ yes; 

- yes: 

- yes; 

default.directive; 
:■ noextemal; 

:■ yes; 

:• nokemel; 

default.library; 

:• nolist: 

:• nolist: 

:■ aolog: 

:■ no; 

:« nonap: 
yes); 


Description 

The link..nain.taTget eomznaad isvokss the SYSTEAM Ada Linker for 

The Linker generates a program image and writes it into the file given by 
the parameter executable. The code portion of this file can be loaded and 
executed by means of the S WG APSE Loader, resp. SWG APSE Debugger. 

.Parameters 


unit : unitnane.type 

Specifies the library unit vriiich is the m^n program. This most be a 
parameterless library procedure. 

executable : pathnane.type 

Specifies the name of the file which will contain the result of the final 
link, see $5.6. The named node most not yet exist. It is created by this 
commaa^ 


SYSTEAM Ada System - User Manual 


59 







Linking 


Cliapter 5 


k«Z3i«l : pathnam«.t7p« :■ nok«rn«l 

Specifies the name of the file that contains the assembled code of the Target 
Kernel that is to be linked to the program. 

If lcernel«>nokemel is specified, then no Target Kernel is linked to the 
program. Note that this feature is not meaningful in the SWG APSE. 

If you want to link the Minimal Target Kernel for the MVME133XT board 
to your program, specify kernel«>aiAimaUceznel. If you want to link 
one of the target kernels which support the SWG APSE Loader (XTBS 
Target Kernel) or the SWG APSE Debugger (XSDB Target Kernel) see 
the corresponding User Manuals of these components. 

Note, the Miniinal Target Kernel must not be linked to the final program 
if the Debug Runtime System is used. 

library : pathname.type :• defaT 2 lt.library 
Specifies the program library the command works on. The link main 
target command needs write access to the library unless coi^lete«>no is 
specified. If coiqplete«>no is specified the link-gain-target command 
needs only read access. 

The default Ubrary is *CUBREirr.USEE*ADAU.IBaARY(STD). 
linkerJListing : pathnaae.type :* nolist 

Unless linker JListing •> nolist is specified, the Linker of the SY^ 
TEAM Ada System produces a listing file containing a table of sirmbols 
which are used for linking the Ada units. 

By default, the Linker does not produce a listing file. 

list : pathnaae.type :« nolist 

This parameter is passed to the implicitly invoked Completer. See the same 
parameter with the cooplete.target command. 

log : pathnaae.type :• nolog 

This parameter controb whether the command writes additional messages 
onto the specified file, and b also passed to the implicitly invoked Com¬ 
pleter. See the same parameter with the cooplete.target command. 

aachine.code : yes.no.answer :• no 

Thb parameter b passed to the implicitly invoked Completer. See the same 
parameter with the coaplete.target command. If linker.listing b not 
equal to nolist and aachine.eede ■> yes b specified, the L inker of the 
SYSTEAM Ada System generates a Ibting with the machine code of the 
program starter in the file given by linker .listing. The program starter 
b a routine which contains the calb of the necessary elaboration routines 
and a for the Ada subprogram which b the main program. 

By default, no machine code Ibting b generated. 

nap : pathnaae.type :■ noaap 


SYSTEAM Ada System - User Manual 


61 




Chapter 5 


Linking 


This program image file serves as input for the Loader or the Debugger in order to 
load the code portion included in the file onto the target. 


5.2 Linking Collections 

A set of Ada units and external units which can be linked separately is called a col¬ 
lection. Such a collection consists on <me hand of all compilation units needed by 
any of the given library units, and on the other hand of all given external units. All 
compilation units must successfully have been compiled or completed previously. 

The code of a linked collection does not contain any unresolved references and can 
thus be loaded to the target and used by programs linked afterwards without any 
changes, hi particular, this allows the code of a linked collection to be burnt into a 
ROhl Linking a collection is called incremental linking. 

Contrary to final linking, incremental linlring is not done selectively. Instead all code 
and data belonging to the collection is linked, because the T.inVar does not know which 
programs or collections will be linked on the collection as a base. 

Incremental IbiHng results in a collection image file. There is a code portion in this 
image file which, together with the code of the g i ven base (if any), is the code of all 
Ada units and all external (assembler written) units that belong to the collection. 

For incremental linking, the Linker is started by the llnk-lncr-target command. 


link^ncT.target 


Command Description 


Format 


PROCEDUBE link lncr,target ( 


coXlection 

• 

• 

pathnaae.type 


base 

• 

pathaaae.type 

:■ nbbase; 

contains 

• 

UBit.liSt 

:■ noonits: 

debug 

• 

• 

yes-ao.aaswer 

:• yes; 

directire 

• 

• 

pathnaas-type 

defattlt.direetiTe; 

external 

• 

m 

mcteza.^st 

:• aoextexnal; 

library 

• 

• 

pathaane.type 

• 

defattlt.library: 

log 

• 

• 

patbnans.type 

:■ nolog: 

nap 

• 

• 

pathnaae.type 

:■ aeaap): 


SYSTEAM Ada System • User Manual 


63 





Liskinc 


Chapter 5 


Specifies a list of file nodes which contain the object code of those program 
units which are written in Assembler; these file nodes contain information 
generated by the Cross Assembler, see §5.5. When extexiial«>noexternal 
is given, external program units are not linked. 

library : pathname-type :• default.J^brary 
Specifies the program library the command works on. The link-incr. 
target command needs write access to the library unless complete»no is 
specified. If eoa^lete>>no b specified the link-incr.target command 
needs only read access. 

The default library b ‘CURREHT-USER*ADAU.IBRAKy(STD}. 
log : pathname.type :• nolog 

Thb parameter controb whether the command writes additional messages 
onto the specified file, and b also passed to the implicitly invoked Com¬ 
pleter. See the same parameter with the coi^lete-target command. 

By default, no additional messages are written. 

map : pathname.type :• nomap 

Specifies whether the map listing of the Linker and the table of symbob 
whidi are used for linking the Ada units are to be produced in the specified 
file. 


End of Command Description 


The contains and external parameters define a collection C as defined at the be¬ 
ginning of thb section. If a base collection b specified (parameter base), then C b 
enlarged by all units belonging to thb base collection. The units belonging to the base 
collection are identified by their names (Ada name of a library unit or name of the 
external unit) and by their compilation or assembly times. The T.iwV^r uses these to 
check whether a base unit b obsolete or not. 

See §5.4 for the mapping process. 

no errors are detected within the linking process, then the result of an incremental 
link b a collection image file containing the following: 

• A code portion that contains the complete code of the linked collection, except 
the code of the base collection. 

• Base addresses and lengths of the regions actually occupied by the complete col¬ 
lection (including the base collection). 

• Checksums of the regions which contain code sections and which are Mtually 
occupied by the complete collection (including the base collection). 

• The names of all library umts as specified by the user (parameter unite) (including 
those of the base collection). 


SYSTEAM Ada System - User Manual 


65 




Linking 


Chapter 5 


regionJistregion-name [(, region-name)+] 


The syntax is specified in an extended Backns-Naur notation with start symbol linker- 
directive-file. [X] means that X is optional, X + means that X is repeated several 
times (but at least once), X I Y means that X or Y is used. 

All characters are case insensitive. Hexadecimal numbers must be in the range 0 .. 
FFFFFFFF. i^ion-name, library-unit-name, and object-module-name ratn be any 
sequence of readable characters except comma and b lanV 

The user has to specify all contiguous memory regions of the target that are to be used 
for the program or the collection to be linked. Each REGION description defines the 
name, the base address, and the size in bytes of one region. 

The RESET directive specifies a region whose first 8 bytes are to be reserved for 
the initisi program counter and the initial stack pointer. This directive supports the 
generation of ROMable programs: If a hardware reset occurs, then the processor fetches 
its reset vector from the stairt address of the given region. The RESET directive is 
ignored if KERNEL is not specified. 

The STACK directive teUs the Linker the size of the twatiw task’s stack and t he 
of the region into which the stack is to be mapped. 

It is possible to specify specific regions for the code or the data of Ada library units 
or of external ( assemb ler written) units in LOCATION directives. If a region for a 
library unit is specified, this causes this unit and all its secondary units to be mapped 
into this region. A region for the code or data of a library unit or of an external unit 
most not be specified more th«^n once. 

In the CODE <Brective, a list of regions naust be specified to be used for the code and 
the constants of those units for which no LOCATION CODE directive b given. The 
specified regions are filled in tiie pven order. 

In the DATA directive, a list of regions must be specified to be used for the data of 
those units for which no LOCATION DATA directive b given. The specified regions 
are filled in the given order. 

A list of regions must be given to be used for the heap of the program (HEAP directive). 

The following objects are allocated on the heap: 

• All Ada collections for which no length clause b specified; 

• the storage for a task activation (see §10.3); 

• all task control blocks (see §10.3). 

Enough space for these objects must be allocated; otherwbe storage-error will be 
rused when the heap space b exhausted. 


SYSTEAM Ada System - User Manual 


67 




LmVmj 


Chapter 5 


resulting image may be reduced drastically when a base collection is given, even if 
memory space occupied by the *old” section is not reused. 

The L mk er automatically takes care that the regions specified by the user in the RD- 
GION descriptions of the directive file do not overlap with the regions actually occupied 
by the given base collection. If the Linker detects an overlap, then it issues an informa¬ 
tion message and uses a region description which does not overlap with a base region 
any longer. 


( 


'v 




The mapping of the sections of S into the regions proceeds as follows: 

1. Final linkin g only: If there is a RFSFT directive, then space for the initial program 
counter and for the initial stack pointer is reserved at the bottom of the given 
region. 

2. Final l i n k in g only: The stack is mapped into the specified region with the given 
size. If the given region has not enough space for the stack, then an error message 
is issued. 

3. The LOCATION directives are processed in the order in which they appear in the 
Lily’s directive file. Each directive is treated as follows: If the specified library 
unit or external unit is not part of the resulting program (e.g. as a consequence of 
selective finkin g), then the directive is ignored and a warning is issued. Otherwise 
all memory sections belonging either to the given library unit or one of its se&> 
ondary umts or to the i^ven external unit, and containing code or data (as given 
in the directive), are mapped into the given region. If the given region has not 
enough space 1^ for this mapping, then an error message is issued. 

4. Then all sections not yet mapped are processed in an arbitrary order. If a section 
contains code or constants, then the regions specified in the CODE directive are 
scanned in the given order and the section is mapped into the first region 

has enough space left. If the section is a data section, then the same is done with 
the regions specified in the DATA directive, iff no region is found has 
space left, then an error message is issued. 

Now each region is filled without any gaps, beginning at its base address. The sections 
which are mapped into a region are sor^ as follows: First the stack, then code 
sections, then data sections. If there is any space left in a region, then this space is a 
contiguous byte block at . the top of the region. 

5. Final link only: The heap is located in those regions that have space of at least a 
certain minimum size (100 byte) left and are listed within the HEAP directive. 

6. Final link onlir: If there is a RESET directive, then the values of the initial stack 
pointer and of the kernel entry point are written into the first 8 bytes of the given 
region. . 

Unless the parameter aap«>noBap is given, the result of this mapping is written into 
the specified map file. The map file is generated even if errors were detected during 
fi n king . The information written into the map file has the following structure: 


SYSTEAM Ada System - User Manual 


69 





Linking 


Cli&pter 5 


5.6 Image Files 

Tke files whose contents can be downloaded to a target board are called target izna^e 
files. Two different kinds of target images adst: 

• program images 

• collection images 


Collection images are the result of an incremental link step (command link..lncr- 
target), see §5.2. Program images are the result of linking a mw program using the 
command link, aaln. target, see §5.1. 

In order to distinguish these kinds of images in a CAIS database from executable 
images for the host computer the SYSTEAM Ada System defines a node kind TA&GET- 
INAGE and a relation TARGET.IMA(«£ which can terminate at nodes of this kind. Hence, 
this relation most always be used as the last relation in pathnames denoting target 
image files of this SYSTEAM Ada System. This applies to pathnames given as values 
to the parameters BASE, COLLECTIOH and EXECUTABLE in the commands mentioned. 

As an exception to the general rule that nodes have to exist before they can be passed 
in patlmames to the SYSTEAM Ada System, target image nodes are created, see 
the description of the parameters COLLECTIOB and EXECUTABLE in the respective link 
commands. 


of target image files to a target board is supported by the SWG APSE Loader 
and SWG APSE Debugger. They take target image files produced by this SYSTEAM 
Ada System as input. 


SYSTEAM Ada System - User Manual 


71 


J 




APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


Th« only allovMd Implementation dependencies correspond to implementation- 
dependent pragmas, to certain machine-dependent conventions as mentioned 
in Chapter 13 of the Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of 
this Ada implementation, as described in this Appendix, are provided by 
the customer. Unless specifically noted otherwise, references in this 
Appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are not a 
part of Appendix F, are contained in the following Predefined Language 
Enviroment (chapter 13 of the compiler user manual). 


C-1 




Predefined Language En^onment 


Chapter 13 


13 Predefined Language Environment 


The predefined language environment comprises the package standard, the language- 
defined library units and the implementation-defined library units. 


13.1 The Package STANDARD 

The specification of the package standard is outlined here; it contains all predefined 
identifiers of the implementation. 


PACKAGE standard IS 

TYPE boolean IS (false. true); 


•• The predefined relational operators for this type are as follows: 


— FOHCnOH 

— FUHCTIOH "/•" 

— FUHCTIOH "<" 

— FUHCTIOH "<■" 

— FUHCTIOH •*>" 
~ FUHCTIOH ">■" 


(left, right 
(left, right 
(left, right 
(left, right 
(left, ri^t 
(left, right 


boolean) RETURH boolean: 
boolean) RETURH boolean; 
boolean) RETURH boolean; 
boolean) RETURH boolean: 
boolean) RETURH boolean: 
boolean) RETURH boolean: 


~ The predefined logical operators and the predefined logical 
negation operator are as follows: 


- FUHCTIOH ”AHD” (left, right : boolean) RETURH boolean: 

• FUHCTIOH "OR” (left, right : boolean) RETURH boolean; 

- FUHCTIOH "XOR" (left, right : boolean) RETURH boolean: 


FUHCTIOH "HOT” (right : boolean) RETURH boolean; 


The universal type universal-integer is predefined. 

TYPE integer IS RAHGE • 2.147.483-648 .. 2-147-483.647; 

-- The predefined operators for this type are as follows: 

** FUHCTIOH ”•" (left, right : Integer) RETURH boolean: 
•• FUHCTIOH "/■" (left, right : integer) RETURH boolean: 


SYSTEAM Ada S 3 rstem - User Mamual 


107 




Predefined Language Environment 


Chapter 13 


— FUNCTION 


(left, right : 

— FUNCTION 

ff.tt 

(left, right : 

~ FUNCTION 


(left, right : 

— FUNCTION 

n fn 

(left, right : 

— FUNCTION 


(left : float: 


float) RETURN float: 
float) RETURN float: 
float) RETURN float: 
float) RETURN float: 

right : integer) RETURN float: 


**** An iapleaentation aay provide additional predefined floating 

— point types. It is recoamended that the nanes of such additional 

— types end with FLOAT as in SHORT-FLOAT or LONG-FLOAT. 

~~ The specification of each operator for the type universal-real, 
or for any additional predefined floating point type, is obtained 
by replacing FLOAT by the naoe of the type in the specification of 

— the corresponding operator of the type FLOAT. 


TYPE short-float IS DIGITS 6 RANGE 

- ie#0.FFFF-FF#E32 .. 16#O.FFFF-FF#E32: 


TYPE long-float IS DIGITS 18 RANGE 

- 1«#0.FFFF-FFFF-FFFF-FFFF#E4096 .. 
ie#0. FFFF-FFFF-FFFF-FFFF#E4096; 


In addition, the following operators are predefined for universal 

— types: 

— .FUNCTION (left : UNIVERSAL-INTEGER: right : UNIVERSAL-REAL) 

RETURN UNIVERSAL.REAL: 

— FUNCTION ■*" (left : UNIVERSAL-REAL: right ; UNIVERSAL-INTEGER) 

RETURN UNIVERSAL.REAL: 

~ FUNCTION "/• (left : UNIVERSAL-REAL: right : UNIVERSAL-INTEGER) 

RETURN UNIVERSAL-REAL: 

— The type universal-fixed is predefined. 

The only operators declared for this type are 

— FUNCTION (left : ANY-FIXED-POINT-TYPE: 

right : ANY-FIXED-POINT-TYPE) RETURN UNIVERSAL-FIXED: 

— FUNCTION ■/" (left : ANY-FIXEDJ»OINT-TYPE: 

right : ANY-FIXED-POINT-TYPE) RETURN UNIVERSAL-FIXED: 

— The following characters form the standard ASCII character set. 
Character literals corresponding to control characters are not 

" Identifiers. 

TYPE character IS 

(nul. soh. stx, etx. eot. enq. ack. bel. 


SYSTEAM Ada Sjrstem - User Manual 


109 





Predefined Language Environment 


Chapter 13 


dollar 

COHSTAKT character :« *$• 

percent 

CONSTANT character :- ’X* 

as^ersand 

CONSTANT character :• 

colon 

CONSTANT character :■ *:* 

seaicolon 

CONSTANT character :« *;* 

query 

CONSTANT character :- •?* 

at_sign 

CONSTANT character :• *0* 

l_bracket 

COHSTAHT character :- *[* 

back-slash 

COHSTAHT character :- ’X* 

r-brackat 

CONSTANT character :• *]* 

cireuoflex 

CONSTANT character 

underline 

CONSTANT character :* •-* 

grave 

CONSTANT character :« *’* 

L-brace 

CONSTAHT character :» *{• 

bar 

CONSTANT character :* * 1 * 

r-brace 

CONSTANT character :• '}’ 

tilde 

CONSTAHT character :■ *“* 


Ic-a : CQKSTAHT character :• *a*: 
• • • 

Ic^ : CQKSTAHT character :• *z*; 
EHD ascii; 


Predefined subtypes: 

SUBTYPE natural IS integer RAHGE 0 .. integer’last: 
SUBTYPE positive IS integer RAKCE 1 .. integer'last; 

Predefined string type: 

TYPE string IS ARRAY (positive RAHGE <>) OF character; 


PRAGMA pack(string); 

The predefined operators for this type are as follows: 



FUHCnOH 

•■n 

(left 

— 

FUHCnOH 


(left 

— 

FUNCTION 


(left 

m m 

FUNCTION 

«<■« 

(left 

— 

FUNCTION 


(left 

— 

FUNCTION 

•>■« 

(left 

— 

FUNCTION 


(left 


FUNCTION 


(left 

— 

FUNCTION 

m^m 

(left 


right : string) RETURH boolean; 
right : string) RETURH boolean; 
right : string) RETURH boolean; 
right : string) RETURH boolean; 
right : string) RETURH boolean; 
right : string) RETURH boolean; 


string; right : string) RETURH string; 
character; right : string) RETURH string; 
string; right : character) RETURH string; 


SYSTEAM Ada System - User Manual 


111 











Predefined Language Environment 


Chapter 13 


13.3.1 The Package COLLECTION31ANAGER 

In addition to unchecked storage deallocation (cf. LRM(§13.10.1)), this implementa¬ 
tion provides the generic package collection .aanager, which has advantages over 
unchecked deallocation in some applications; e.g. it makes it possible to clear a collec¬ 
tion with a single reset operation. See §15.10 for farther information on the use of the 
collection manager and unchecked deallocation. 

The package specification is: 


GENERIC 

TYPE elea IS LIMITED PRIVATE: 

TYPE acc IS ACCESS elea; 

PACKAGE coUectlon-aanager IS 

TYPE status IS LIMITED PRIVATE; 

PROCEDURE SHirk (s : OUT status): 

— Marks the heap of type ACC and 

-** delivers the actual status of this heap. 

PROCEDURE release (s : IN status); 

~~ Restore the status s on the collection of ACC. 

— release without previous MARX raises CONSTRAINT-ERROR 

PROCEDURE reset; 

Deallocate all objects on the heap of ACC 
PRIVATE 

private declarations 
END collectlon-aanager; 


A of the procedure release with an actual parameter s causes the storage occupied 
by those objects of type acc which were allocated after the call of mark that delivered 
s as result, to be reclaimed. A call of reset causes the storage occupied by all objects 
of type acc which have been allocated so &r to be reclaimed and cancels the effect of 
all previous caUs of amrk. 


SYSTEAM Ada System > User Manual 


113 




Predefined Language Environment 


Cliapter 13 


WITH systea; 

PACKAGE prlvlleged.operatlQns IS 

SUBTYPE long-range IS Integer RANGE *2**31 .. 2**31-1; 

SUBTYPE word-range IS integer RANGE *2**15 .. 2**15*1: 

SUBTYPE byte-range IS integer RANGE *2**7 .. 2**7*!; 

SUBTYPE bit-nuaber IS integer RANGE 0 .. 7; 

** 0 designates the least significant bit of a byte. 
** 7 designates tbs aost significant bit of a byte. 

SUBTYPE vector-nuaber IS integer RANGE 0 .. 255; 


PROCEDURE assign-byte (dest : systea.address; 

itea : byte-range); 

PROCEDURE assign-word (dest : systea.address; 

itea : word-range); 

PROCEDURE assignJLong (dest : systea.address; 

itea : long-range); 

PROCEDURE asslgn..addr (dest : systea.address; 

itea : systea.address); 

PROCEDURE bit-set (dest : systea.address; 

bltno : bit-noaber); 

PROCEDURE bit-dear (dest : systea.address; 

bitno : bit-nuaber); 

FUNCTION byte-value (addr : systea.address) RETURN byte-range; 
FUNCTION word-value (addr : systea.address) RETURN word-range; 
FUNCTION long-value (addr : systea.address) RETURN Imig-range; 

FUNCTION addr-value (addr : systea.address) RETURN systea.address; 

FUNCTION bit-value (addr : systea.address; 

bitno : bit-xraaber) RETURN boolean: 

** true is retuzned if tbs bit is set. false otherwise. 

PROCEDURE define-lntermpt-servlee-routlne 

(routine : systea.address: 

for-vector : vector-nuaber); 

** defines an asseabler routine as interrupt service routine 
END privileged-operations; 


SYSTEAM Ada System • User Manual 


115 








Predefined Lenguege Environment 


Chapter 13 


PROCEDUBE sincos (x : long^loat: 

cos : OUT long^loat; 
sin : OUT long-float): 

FUKCTIOH sinh (x : long-float) RETORH long-float; 

FUHCTIOH sqrt (x : long-float) RETORH long-float; 

FOHCTIOH tan (x ; long-float) RETORH long-float; 

FUHCTIOH tanh (x ; long-float) RETORH long-float; 

FOHCTIOH tentox (x : long-float) RETORH long-float; 

FOHCTIOH twotox (x : long-float) RETORH long-float; 

EHD coprocessor-interface: 


SYSTEAM Ada System * User Manual 


117 



Appendix F 


Chapter 15 


15 Appendix F 


This chapter, together with the Chapters 16 and 17, is the Appendix F required in the 
LRM, in which all implementation-dependoit characteristics of an Ada implementation 
are described. 


15.1 Implementation-Dependent Pragmas 

The form, allowed places, and effect of every implementationniependent pragma is 
stated in this section. 


15.1.1 Predefined Language Pragmas 

The form and allowed places of the following pragmas are defined by the language; 
their effect is (at least partly) implementation-dependent and stated here. 

CONTROLLED 
has no effect. 


ELABORATE 

is fully implemented. The SYSTEAM Ada System assumes a PRAGMA elaborate, 
Le. stores a unit in the library as if a PRAGMA elaborate for a unit u was given, 
if the compiled unit contvns an instantiation of u (or a generic program unit in 
u) and if it is clear that u must have been elaborated before the compiled unit. In 
this case an appropriate information message is given. By this means it is avoided 
that an elaboration order is chosen which would lead to a PROGRAM-ERROR 
when elaborating the instantiation. 


INLINE 

Inline e3g>ansion of subpregrams is supported with the following restrictions: 
the subprogram must not contain declarations of other subprograms, tasks, generic 
units or body stubs. If the subprogram is called recursively only the outer call of 
this subprogram will be eiqpanded. 


SYSTEAM Ada System - User Manual 


123 



ApptadixF 


Chapter 15 


^ect on scheduling ' Vaving the priority of a task or main program undefined by 
not giving PRAGMA priority for it is the same as if the PRAGMA priority 0 
had been given (i.e. the task has the lowest priority). 


SHARED 

is fully supported. 


STORAGE.X7N1T 
has no effect. 


SUPPRESS 

has no effect, but see §15.1J2 for the implementation-defined PRAGMA suppress, 
all. 


SYSTEM.NAME 
has no effect. 


15.1.3 Implementation-Defined Pragmas 

BYTEJ»ACK 
see §16.1. 


EXTERNAL.NAME (<string>, <ada.name>) 

<adajiame> spedfies the name of a subprogram or of an object declared in a 
library package, <string> must be a string literal It defines the external n a me 
of the specified item. The Gompiler uses a syxnbol with this name in the call 
instruction finr the subprogram. The subprogram declaration of <ada-naine> most 
precede this pragma. H several subprograms with the same name satisfy this 
requirement the pragma refers to that subprogram which is declared last. 

Upper and lower cases are distinguished within <string>, Le. <Btring> most W 
given exactly as it is to be used by external routines. This pragma will be used in 
connection with the pragma interface (asseabler) (see §15.1.1). 


8YSTEAM Ada System - User Manual 


135 





Appendix F 


Chapter 15 


15.1.3 Pragma Interface (Assembler,...) 


This section describes the internal calling conventions of the SYSTEAM Ada System, 
which are the same ones which are used for subprograms for which a PRAGMA Interface 
(ASSEMBLER....) is given. Thus the actual meaning of this pragma b simply that the 
body needs and must not be provided in Ada, but in object form using the external 
parameter at link time. 

The internal calling conventions are explained in four steps: 

. Parameter passing mechanism 
• Ordering of parameters 

- Type mapping 

- Saving registers 


Parameter passing mtehanism: 

The parameters of a call to a subprogram are placed by the caller in an area called 
poftimefer block. Thb area b aligned on a longword botmdary and contains parameter 
values (for parameter of scalar types), descriptors (for parameter of composite types)* 
and alignment gaps. 

For a function subprogram an extra field b assigned at the beginning of the parameter 
block containing the function result upon return. Thus the return value of a function b 
treated like an anonymous parameter of mode OUT. No special treatment b required 
for a function result except for return values of an unconstrained array type (see below). 

A subprogram b called using the JSR instruction. The address pointing to the begin¬ 
ning of the parameter block b pushed onto the stack before calling the subprogram. 

In general, the ordering of the pauameter values within the parameter block does not 
agree with the order specified in the' Ada subprogram specification. When determining 
the position of a parameter within the parameter block the calling mechanism and the 
sue and alignment requirements of the parameter type are considered. The size and 
aligntnamt requirements and the passing mechanbm are described in the following: 

Scalar parameters or parameters of access types are passed by value, Le. the values of 
the actual parameters of modes IN or IN OUT are copied into the parameter block 
before the call. Then, after the subprogram has returned, values of the actual pa¬ 
rameters of modes IN OUT and OUT are copied out of the parameter block into the 
associated actual parameters. The parameters are aligned within the parameter block 
according to their sbe: A parameter with a size of 8, 16 or 32 bits (or a multiple of 
8 bits greater 32) has an alignment of 1, 2 or 4 (which means that the object 
b aligned to a b]rte, word or longword boundary within the parameter block). U the 
size of the parameter b not a multiple of 8 bits (which may ^ achieved by attaching 


SYSTEAM Ada System - User Manual 


127 




Appendix F 


Chapter IS 


requirements of a parameter it is not always possible to place parameters in such a way 
that two consecutive parameters are densely located in the parameter block. In such a 
situation a gap, i.e. a piece of memory space which is not associated with a parameter, 
exists between two adjacent parameters. Consequently, the size of the parameter block 
will be larger than the sum of the sizes used for all parameters. In order to minimize 
the size of the gaps in a parameter block an attempt is made to fill each gap with a 
parameter that occurs later in the parameter list. If during the allocation of space 
within the parameter block a parameter is encountered whose size and alignment fit 
the characteristics of an available gap, then this gap is allocated for the parameter 
instead of appending it at the end of the parameter block. As each parameter will be 
aligned to a byte, word or longword boundary the size of any gap may be one, two 
or three bytes. Every gap of size three bytes can be treated as two gaps, one of size 
one byte with an alignment of 1 and one of size two bytes with an alignment of 2. So, 
if a parameter of size two is to be allocated, a two byte gap, if available, is filled up. 
A parameter of size one will fill a one byte gap. If none exists but a two byte gap b 
available, thb b used as two one byte gaps. By thb first fit adgorithm all parameters 
are processed in the order they occur in the Ada program. 

A called subprogram accesses each parameter for reading or writing using the param¬ 
eter block address incremented by an ofbet from the start of the parameter block 
suitable for the parameter. So the value of a parameter of a scalar type or an access 
type b read (or written) directly from (into) the parameter block. For a parameter of a 
composite type the actual parameter value b accessed via the descriptor stored in the 
parameter block which contains a pointer to the actual object. When standard entry 
code sequences are used within the assembler subprogram (see below), the parameter 
block address b accessible at address 8(A6). 


TVpe mapping: 

To access individual components of array or record types, knowledge about the type 
mapping for array and record types b required. An array b stored as a sequential con¬ 
catenation of all its components. Normally, pad bits are used to fill each component 
to a byte, word, longword or a multiple thereof depending on the sbe and alignment 
requirements of the components’ subt]rpe. Thb padding may be influenced using one 
of the PRAGMAS pack or byte.pack (cf. §16.1). The ofiset of an individual array 
component b then obtained hy multiplying the padded size of one array component by 
the number of components stored in the array before it. Thb number may be deter¬ 
mined from the number of elements for each dimension using the fact that the array 
elements are stored row by row. (For unconstrained arrays the number of elements for 
each dimension can be found in the descriptor stored in the parameter block.) 

A record object b implemented as a concatenation of its components. Initially, loca¬ 
tions are reserved for those components that have a component clause applied to them. 
Then locations for all other components are reserved. Any gaps large enough to hold 
components without component claiises are filled, so in general the record components 
are rearranged. Components in record variants are overlaid. The ordering mechanism 


SYSTEAM Ada System - User Manual 


129 





Appendix F 


Chapter 15 


for procedures without parameters and 
RID #4 


for functions and procedures with parameters. 

Consider the following example. A fimcticm sin is to be implemented by an assembler 
routine. Its Ada specification is as follows: 


FUHCnOH sin (x : long^loat) RETURN long^loat; 
PRAOfA interface (asseobler. sin); 

PRAGMA extenLal.naae ("CPSIN”. sin); 


It is implemented by the following assembler routine: 


CPSIN: 


LIIK.W 

A«.#-4 


CLR.L 

(•4.A6) 


MOVEA.L 

(8.A6).A0 

*— 

FSIH.X 

a2.AO).FP0 

*— 

FMOVE.Z 

FPO.CAO) 

*— 

UNLK 

A6 

*— 

RID 

«4 



allocate frame 

clear the indicator bits 

address of parameter block 

parameter x 

store function result 

remoTs frame 

return to caller 




15.2 Implementation>Dependent Attributes 

The name, type and implementation-dependent aspects of every implementation-de- 
pendent attribute is stated in this section. 




SYSTEAM Ada System • User Manual 


131 




Appendix F 


Cliapter 15 . 


The vaine delivered by this attribute applied to a task type or task object is as 
follows: 

If a length specification (STORAGE^IZE, see §16.2) has been given for the task 
type, the attribute delivers that specified value; otherwise, the default value is 
returned. 


15.2.2 Implementation-Defined Attributes 
There are no implementation-defined attributes. 

15.3 Specification of the Package SYSTEM 

The package system as required in the LRM(§13.7) is reprinted here with all imple¬ 
mentation-dependent characteristics and extensions filled in. 


PACKAGE system IS 

TTPE designated.by.address IS LIMITED PRIVATE: 

TYPE address IS ACCESS deslgnated-by_addresB; 

FOR address'storage-size USE 0; 

address..jeero : CONSTAHT address :• VULL; 

FUHCTIOH Cleft : address; ri^t : integer) RETURI address; 

FUHCTIOH Cleft : integer; right : address) RETURH address; 

FUHCTIOH *>* Cleft : address; right : integer) RETURH address; 

FUHCTIOH Cleft : address: right : address) RETURH integer: 

SUBTYPE extemal-address IS STRIHG: 

External addresses use hexadecimal notation with characters 

— 'O'..'O', 'a'..'f' and 'A*..'F'. For instance: 

■7FFFFFFF" 

”80000000” 

— ”8” represents the same address as ”00000008” 

FUHCTIOH eonvert.i.address Caddr : exter n al-address) RETURH address: 
convert-address raises COHSTRAIHT-ERROR if the external address 


SYSTEAM Ada System - User Manual 


133 






Appendix F 


Chapter 15 


Bode-error-id : CONSTANT exception-id :* ...: 

naae-error-id : CONSTANT exception-id 

use-error-id : CONSTANT exception-id :■ ...; 

device-error-id : CONSTANT exception-id :■ 

end-error-id : CONSTANT exception-id :■ ...: 

data-error-id : CONSTANT exception-id :* ...; 

layout-error-id : CONSTANT exception-id :■ 

tiae-error-id : CONSTANT exception-id :■ ...; 

no-error-code ; CONSTANT :« 0; 

TYPE exception-information 
IS RECORD 

excp.id : exception-id: 

— Identification of the exception. The codings of 

— the predefined exceptions are given above, 

eode-addr : address: 

Code address where the exception occurred. Depending 

on the kind of the exception it may be be address of 

— the instruction which caused the exception, or it 
— Bay be the address of the instruction which would 

have been executed if the exception had not occurred, 
error-code : integer; 

END RECORD: 

PROCEDURE get-exception-inforaation 

(excp-info : OUT exception-information): 

The subprogram get-exception-inforaation Bust only be called 
froa within an exception handler BEFORE ANT OTHER EXCEPTION 
IS RAISED. It then returns the information record about the 
" actually handled exception. 

Otherwise, its result is undefined. 

PROCEDURE raise.exception-id 

(excp-id : exception-id); 

PROCEDURE raise-exception-info 

(excp-inf o : exception - information) ; 

The subprogram raise-exc option-id raises the exception 
given as paraaeter. It corresponds to the RAISE statement. 

The subprogram raise-exception - info raises the exception 
’** described by the information record supplied as paraaeter. 

— In addition to the subprogram raise.exception-id it allows to 
" e^^licitly define all coaponents of the exception information 

— record. 


SYSTEAM Ada System - User Manual 


135 











Appendix F 


Chapter 15 


15.7 Restrictions on Unchecked Conversions 

The implementation supports unchecked type conversions for all kinds of source and 
target types with the restriction that the target type must not be an unconstrained 
array type. The result value of the unchecked conversion is unpredictable, if 

target.type'SIZE > source-type‘SIZE 


15.8 Characteristics of the Input-Output Packages 

The implementation-dependent characteristics of the input-output packages as defined 
in the LRM(Chapter 14) are reported in Chapter 17 of this manual. 


15.9 Requirements for a Main Program 

A main program mnst be a parameterless library procedure. This procedure may be 
a generic instantiation; the generic procedure need not be a library unit. 


15.10 Unchecked Storage Deallocation 

The generic procedure unchecked-deallocation is provided; the effect of an 

instance of this procedure is as described in the LRM(§13.10.1). 

The implementation also provides an implementation-defined package collectlon- 
aanager, which has advantages over unchecked deallocation in some applications (cf. 
§13.3.1). 

Unchecked deallocation and operations of the collection-aanager can be combined 
as follows: 

• collectlon.manager.reset can be applied to a collection on which unchecked 
deallocation has also been used. The effect is that storage of all objects of the 
collection is reclaimed. 

• After the first unchecked-deallocation (release) on a collection, all following 
calls of release (unchecked deallocation) until the next reset have no effect, 
Le. storage is not reclamed. 


SYSTEAM Ada System - User Manual 


137 




Appendix F: Representation Clauses 


Chapter 16 


16 Appendix F: Representation Clauses 

In this chapter we follow the section nunabering of Chapter 13 of the LRM and provide 
notes for the use of the features described in each section. 


16.1 Pragmas 

PACK 

As stipulated in the LRM(§13.1), this pragma may be given for a record or array 
type. It causes the Compiler to select a representation for this type such that gaps 
between the storage areas allocated to consecutive components are minimized. 
For components whoee type is an array or record type the PRAGMA PACK has no 
effect on the mapping of the component type. For all other component types the 
Compiler will choose a representation for the component type that needs minimal 
storage space (packing down to the bit level). Thus the componeits of a packed 
data structure will in general not start at storage unit boundaries. 


BYTE-PACK 

This is an implementation-defined pragma which takes the same argument as the 
predefined language PRAGMA PACK and b allowed at the same positions. For 
components whose type b an array or record t 3 rpe the PRAGMA BYTE-PACK has 
no effect on the mapping of the component type. For all other component types 
the Compiler will try to choose a more compact representation for the component 
type. But in contrast to PRAGMA PACK all components of a packed data structure 
will start at storage unit boundaries and the size of the components will be a 
multiple of system, storage-unit. Thus, the PRAGMA BYTE-PACK does not 
effect packing down to the bit level (for thb see PRAGMA PACK). 


SYSTEAM Ada System - User Manual 


139 


j 





Appendix F: Representation Clauses 


Cliapter 16 


16.4 Record Representation Clauses 

Record representation clauses are supported. The value of the expression given in an 
alignment clause must be 0, 1, 2 or 4. this restriction is violated, the Compiler 
responds with a RESTRICTION error message in the Compiler listing. If the value is 
0 the objects of the corresponding record type will not be aligned, if it is 1, 2 or 4 the 
starting address of an object will be a multiple of the specified alignment. 

The number of bits specified by the range of a component clause must not be greater 
than the amount of storage occupied by this component. (Gaps between components 
can be forced by leaving some bits unused but not by specifying a bigger range tb^n 
needed.) Violation of this restriction will produce a ^STRICTION error message. 

There are implementation-dependent components of record types generated in the 
following cases : 

• If the record type includes variant parts and if it has either more than one 
discriminant or else the only discriminant may hold more than 256 different values, 
the generated component holds the size of the record object. 

• If the record type includes array or record components whose sizes depend on dis¬ 
criminants, the generated components hold the offsets of these record components 
(relative to the corresponding generated component) in the record object. 

But there are no implementation-generated names (cf. LRM(§13.4(8))) denoting these 
components. So the mapping of these components cannot be infiuenced by a represen¬ 
tation clause. 


16.5 Address Clauses 

Address clatises are supported for objects declared by an object declaration and for 
single task entries. If an address clause is given for a subprogram, package or a task 
unit, the Compiler responds with a RESTRICTION error message in the Compiler 
listing. 

an address clause is given for an object, the storage occupied by the object starts at 
the given address. Address clauses for single entries are described in §16.5.1. 


SYSTEAM Ada System - User Manual 


141 






X. 


Appendix F: Representation Clauses 


Clxapter 16 


.IRRETURN is defined by the Ada Runtime System. It contains the start address of 
the Target Kernel routine that carries out the return from interrupt handling. It is 
very important that when leaving ISR all registers (except the stattis register) have the 
same values as they had when entering ISR. ISR is executed in the supervisor state of 
the processor, so all instructions (including privileged ones) can be used within ISR. 
The processor’s priority depends on the interrupt source. 

If you want to call the interrupt entry with the number N, then you must set a bit 
within the interrupt entry call pending indicator .IREinilYC by the instruction: 

bfset (..lEREHTRYC) *— prepare call of 

*— interrupt entry H 

(Note: The Microware Cross Assembler has a bug which causes wrong code to be 
generated for the bfset. The example shows a work around for this bug.) 

This instruction should be placed immediately in front of the last instruction of ISR. 
ISR need not caU the interrupt entry each time it is activated. Instead ISR can, for 
example, read one character each time it is activated, but call the interrupt entry only 
when a complete line has been read. 

A complete example for mterrupt handling follows. For this example the second RS232 
serial line of the MVME133XT board is used (available through the P2 coxmector). 
The assembler routine ISB^JLEMi is activated ea^ time a character is received on that 
line. ISR-BEAD calls interrupt entry char.entry of TASK terainal,-ln. termlnal_in 
uses TASK termlnal.out to output each character read. 

The terminal should be set up for XON/XOFF (not CTS/RTS) fiow control. 

VITH system. 

privileged-operations. 
text-io; 

USE privileged-operations. 
text-io; 

PROCEDURE terminal IS 
PRAGMA priority (2); 

PROCEDURE setup-scc; 

PRAGMA interface (assembler, setup-scc); 

PRAQIA external-name ("SETUP-SCC. setup-scc); 

PROCEDURE isr-read; 

PRAGMA interface (assembler, isr-read); 

PRAGMA external-name ("IS R - R E A D". isr-read); 


SYSTEAM Ada System - User Manual 


143 






Appendix F: Representation Clanses 


Cliapter 16 


END LOOP; 

END ternlnal-ottt; 

BEGIN 

setup.sec: 

define-intem^t-serrice^outine 

(isr^ead*addreas. 16*80#); 

END terminal; 

Tlie following assembler routines also belong to the example: 


typlang 

equ 0 


attrrsY 

*— 

equ $8000 


pseet 

terminal. typlang, attrreT .0.0.0 

8eeb_rro 

equ 

IFFFAOOOO 

secb.wro 

equ 

IFFFAOOOO 

seeb_rdr 

equ 

IFFFAOOOl 

seeb.tdr 

equ 

IFFFAOOOl 


•— 


SETDP^CC: 

more.b 

#$30.(secb.wro).1 

l^eeee 

clear receirer error status 

moTe.b 

#$10,(secb.wro).1 


clear external status interrupts 

moye.b 

#$09.(secb.wro).1 

*— 

WE 9 ' « 

moTe.b 

#$40,(secb.wro).1 

•— 

reset channel A A B. disable IBs 

more.b 

#$0A.(secb.wro).1 

*— 

WE 10 

moYe.b 

#$00.(secb.wro).1 

♦— 

NEZ format 

moTe.b 

#$0E.(secb.wro).1 

•— 

WE 14 

moYe.b 

•$82,(seeb.wro).1 

*— 

sonree*BE generator. ETZC iiqmt 

*— 



disable BE generator 

moTe.b 

#$04.(sceb.wro).1 

•— 

WE 4 

move.b 

,#$44.(sceb.wro).1 

•— 

elck aodo«xl6.1 atop bit.no parity 

move.b 

#$03.(sceb.wro).1 

•— 

WE 3 

more.b 

#$C1.(sceb.wro).1 

•— 

8 bits, enable receirer 

more.b 

#$05.(sceb.wro).1 

•— 

WE 6 

more.b 

#$EA.(sceb.wro).1 

•— 

DTBAETS«on.8 bits.enable transmtr 

more.b 

#$0C.(sceb.wro).1 

•— 

WE 12 

more.b 

#$02.(seeb.wro).1 

*— 

lower byte of time const (9600 Bd) 

bore.b 

. #$0D.(seeb.wro).1 

•— 

WE 13 

more.b 

#$00.(seeb.wro).1 


upper byte of time const (9600 Bd) 

more.b 

#$0B.(seeb.wro).1 


WE 11 

more.b 

#$66.(seeb.wro).1 


BxCloek«TxCloek*TBxClock*BE output 

*— 


*— 

TSxC output 


SYSTEAM Ada System - User Manual 


145 









Appendix F: biput-Output 


Chapter 17 


17 Appendix F: Input-Output 

ha this chapter we follow the section numbering of Chapter 14 of the LRM and provide 
notes for the use of the features described in each section. 


17.1 External Files and File Objects 

The implementation only supports the files standaztLJLnput and standard_output 
^ of PACKAGE text_io. Any attempt to create or open a file raises the exception use. 
error. 


17.2 Sequential and Direct Files 

Sequential and direct files are not supported. 


17.3 Text Input-Output * 

sta n da ir d- i n p ut and stanidard_output are associated with the RS232 serial port of 
the target. 

If the Minimal Target Kernel is used, then this serial port is used and all data of 
standard-output is directly written to this port and all data of standard-lnput h 
directly read firam this port. 

If the XTBS or XSDB Target Kernel is used, see the corresponding user manual for 
the behaviour of the text input/output. 

For tasking aspects of I/O operations see Chapter 14. 

For farther details on the I/O implementation within the Target Kernel see Chapter 
19. 


SYSTEAM Ada System - User Manual 


147 







