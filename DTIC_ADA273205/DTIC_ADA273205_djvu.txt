

NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



An Automated Toot To Facilitate Code Translation 
for Software Fault Tree Analysis 
by 

Robert R. Oidonio 
September 1993 

TJiesis Advisor: Dr-Tlmothy L Shimeall 

Approved for imblic rdease; distribution is uniimiied. 


93-29347 



' w 


\ 






REPORT DOCUMENTATION PAGE 


Form Approved 

0704-0188 




-ww HTTWfWTwwing Bivimowoo*, •••fcmno •xwna o«ifouro#t 

'**^*'***’*^ »U 99 »«wi^or rcdueiig ttw buidtn to Wtihington HMtoquaitMi SaivioM, Dittctor*!* for Wonnrtion Oponliant «nd Ropoits. 1216 J«*»i»on 
D«va Hnhwty, Su>« 1204, Aifington, VA 222024302. and to Iho Offion of Moiaqomonf ond Budgot, Pip«work fMuotion Projoet (0701.0188), W«*hii^on. DC 20503. 


REPORT DATE 

September 1993 


1 : 14 A 87 ^ 1 ^ I >1 •TT d :l d >1 


1. AGENCY USE ONLY (Lmv. BtaniO l2. REPORT DATE - la.HkPbl^ l I VMi AHR 6ATt!5 66VEBE6 

I September 1993 I Master’s Thesis. July 1991 - September 1993 

A TITLE AND SUBTITLE IS FUNDING NUMBERS 

An Automated Tool to Facilitate Code TVanslation for Software Fault 
Tree Analysis (U) 


6.AUTHOR(S} 

Ordonio, Robert Romero 


7. PERFORMING ORGANIZATION NAME(S} AND AO0RESS{ES) 

Computer Science Department 
Navd Postgraduate School 
Monterey, CA 93943-5000 


a. PERFORMING ORGANIZATION 
REPORT NUMBER 


a. SPONSORING.' MONITORING AGENCY NAME(S) AND AOOReSS(ES) 

Naval Postgraduate School 
Monterey, CA 93943-5000 




AGENCY REPORT NUMBER 


It. SUPPLEMENTARY NOTES 

The views expressed in this thesis arc those of the author and do not reflect the oflScial policy or position 
of the Department of Defense or the United States Government 


tJA. IKST.RIBUTICN i AVAIUOILlTY STATEMENT 

UnclassifiedAJnlimited 


iSb. distribut 


lltUBaTRAOr TMuinwig^ "*" "..... .... | Ii i r i.i.. l. . mm .. . 

A safe system is defined as a system that prevents unsafe states from producing safety failures, where 
an unsafe state is defined as a state that may lead to safety failure unless some specific action is taken to 
avert it The problem that this thesis addresses is how to find places in Ada programs where faults arc 
likeiy to occus' during progiam execution. 

The approach is to build an automated translation tool that translates Ada programs into a software fault 
tree. [Lev 83] The tool works as follows; 1). The Ada parser- and lexical analyzer calls the Automated Code 
Translation Tool (ACll') upon recognition of an Ada statement; 2). The ACTT produces a template 
representing the statement; 3). The templates arc linked together as a software fault tree. 

The result is a program that takes Ada source code as input and produces a software fault tree as output 


11 SUBJECT TERMS 

Ada, Fault TVec Analysis, Fault Tree Editors, Lexical Analyzers, Parsers, 
Safety, Software Fault Tree Analysis, Software Safely, System Safety. 


IS. NUMBER OF RAGES 
212 


WlhTI rfRY WliVUVIl 


17 . 

OF REPORT 

Unclassified 


MSN 754tW)l-280-S500 


•1 j»ni:n fZRr 


II. 

CFTTiSPAOE 

Unclassified 





II. 

OF abstract 
Unclassified 


UMITATION OF ABSTRACT 


Sundaid Focm 29S (Rev. 2-89) 










Approved for public release; distribution is unlimited 


An Automated Tool To Facilitate Code Translation 
for Software Fault Tree Analysis 

by 

Robert Romero Ordonio 
Captain, United States Army 
Mclntire School of Commerce 
University of Virginia, 1984 

Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF COMPUTER SCIENCE 






ABSTRACT 


A safe system is defined as a system that prevents unsafe states from producing safety 
failures, where an unsafe state is defined as a state that may lead to safety failure unless 
some specific action is taken to avert it The problem that this thesis addresses is how to 
find places in Ada programs where faults are likely to occur during program execution. 

The approach is to build an automated translation tool that translates Ada programs 
into a software fault tree. [Lev 83] The tool works as follows: 1). The Ada parser and lexical 
analyzer calls the Automated Code Translation Tool (ACTT) upon recognition of an Ada 
statement; 2). The ACTT produces a template representing the statement; 3). The templates 
are linked together as a software fault tree. 

The result is a program that takes Ada source code as input and produces a software 
fault tree as output. 




ovhllTi INS-PECTED 8 


Accesion For ^ 1 

NTJS 

CRA&I 

W 

one 

U8 

Q 

UiJji.l’ 

01 ;(;d 


1 JuMitication 


By . 



Di i.iO 

•dfon / 


[ AvailtiOilily Codes 


Avail 

Jf'd / ot 

DisI 

Spe 

ctal 

H 








TABLE OF CONTENTS 


l. INTRODUCTION.1 

A. SAFETY.1 

B. SYSTEM SAFETY.3 

C SOFTWARE SAFETY.4 

D. STATEMENT OF PROBLEM.5 

E. SUMMARY OF CHAPTERS.7 

n. BACKGROUND INFORMATION.8 

A. FAULT TREE ANALYSIS....8 

B. SOFTWARE FAULT TREE ANALYSIS.9 

C PREVIOUS WORK.11 

1. FAULT TREE EDITORS.11 

2. SOFTWARE FAULT TREE TEMPLATES.12 

3. AUTOMATED SOFTWARE FAULT TREE ANALYSIS.13 

m. AUTOMATED CODE TRANSLATION TOOL PROTOTYPE.15 

A. THE LEXICAL ANALYZER AND PARSER. 16 

B. THE TEMPLATE GENERATOR.17 

C THE FILE GENERATOR....27 

D. THE DATA STRUCTURE. 28 

E. THE INPUT/OUTPUT.29 

F. EXTENDED EXAMPLE ..30 

G. FINISHING THE EXAMPLE ANALYSIS. .43 

IV.CCWCLUSIONS. 46 

A. INTRODUCTION. 46 

B. RESEARCH SUMMARY..46 

C RECOMMENDATIONS..47 

D. FUTURE RESEARCH. 48 

iv 































APPENDIX A: AYACC AND AFLEX INPUT.49 

A. AYACC SPECIHCATION FILE:.49 

B. AFLEX SPECmCATION FILE.73 

APPENDDC B: SOURCE CODE FOR TEMPLATE GENERATOR TOOL.77 

A. PACKAGE SPEOFICnON FOR FAULT TREE GENERATOR.77 

B. PACKAGE BODY FOR FAULT TREE GENERATOR.83 

C. PACKAGE SPECMCATION FOR TRAVERSE PACKAGE.125 

D. PACKAGE BODY FOR TRAVERSE PACKAGE.127 

APPENDDC C:ADA STRUCTURE TEMPLATES.138 

APPENDDC D: AUTOMATED CODE TRANSLATION TOOL OUTPUT FOR PROCE- 
DURE FAKE_OVEN_CONTROL.156 

A. LITERAL TREE REPRESENTATION.156 

B. FTC NODE LISTING.164 

C PROCEDURE, FUNCTION, AND EXCEPTION LISTING.171 

D. FTC COMPATIBLE FILE, "NEW.FTC”. 172 

LIST OF REFERENCES.200 

INITIAL DISTRIBUTION LIST.203 


V 





















LIST OF FIGURES 


Figure 1 Common Software Fault Tree Symbols .9 

Figure 2 Example Node Values.12 

Figure 3 Automated Code Translation Tool Structure.16 

Figure 4 If-Statement Example .18 

Figure 5 Production Rule for If-Statement.19 

Figure 6 Relation Template for If Condition.20 

Figure 7 Relation Template for Assignment-Statement. 21 

Figure 8 Assignment-Statement Template for If Clause.22 

Figure 9 Sequence Of Statements Template for If Qause.23 

Figure 10 Production Rule for Elsif Qause.24 

Figure 11 Elsif Template for Example.25 

Figure 12 Production Rule for Else Clause...26 

Figure 13 Else Template for Example.26 

Figure 14 If-Statement Template for Example .27 

Figure 15 Software Fault Tree Node Data Structure.29 

Figure 16 Sample Ada Code Input. 31 

Figure 17 Embedded For-Loop Template for Procedure FAKE„OVEN_CONTROL .33 

Figure 18 If-Statemcnt Template for Procedure FAKJEuOVEN.CONTROL.34 

Figure 19 Condition Template for If-Statemcnt.35 

Figure 20 Sequence of Statements Template for If-Statcmcnt .36 

Figure 21 Sequence of Statements Tcntplatc for If-Siatcmcnt (Continued).37 

Figure 22 Elsif Template for If-Staicmcnt.38 

Figure 23 Elsif Template for If-Statemcnt (Continued). .39 

Figure 24 Sequence of Statements Template for Outer For-Loop. 41 

Figure 25 Outer For-Loop Template for Procedure FAKE_OVEN^CONTROL.42 

Figure 26 Sequence of Statement Tonplate for Procedure FAKE^OVBN^CONTROL 43 
Figure 27 Modified Software Fault TYce for Procedure FAKE^OVEN^CONIKOL. .45 


vi 






























ACKNOWLEDGEMENTS 


I would like to take this opportunity to thank a number of people, for without their 
assistance, guidance, and especially patience, this thesis would not have been completed. 
First, I would like to thank Professor Shimeall for the endless support he gave me 
throughout the entire process. His willingness to provide assistance in solving problems 
and his constant availability throughout were key contributing factors to this thesis 
completion. Additionally, I would like to thank Professor Erickson for his contributions in 
making this thesis more understandable. Thanks are also due to Dr. Friedman and Mr. 
Lombardo for their previous works on automated code translation and fault tree editors, 
respectively. 

Last, but most defmitely not least, I would like to especially thank my wife, Gemma. 
Her loving support, patience, understanding, and encouragement during our stay in 
Monterey provided me the inspiration to finish this project 


vii 




I. INTRODUCTION 


Since the invention of computers, from main frames to the micro systems, the 
appearance and usage of these devices in today’s society has grown at a tremendous pace. 
Computers today are used in all aspects of everyday life. The range of devices that use 
computers include the complicated systems of the space shuttle and different weapon 
systems to the less intricate systems of calculators and small appliances. With the 
introducdon of computer systems, there exists the requirements to ensure that these systems 
will perform as intended without catastrophic side effects. In essence, the goal is to ensure 
that the computer systems operate safely. A system is defined by The American Heritage 
Dictionary as a group of interacting, intenelated, or interdependent elements forming a 
complex whole. 

A, SAFETY 

Safety has been defmed as a state that is free from conditions that can cause death, 
injury, occupational illness, or damage to or loss of equipment or property. {Lev 86] 
Leveson, along with others, have stated that this definition is unrealistic because by this 
definitiun any system tliat presents any element of risk would be Labeled unsafe. (Lev S6] 
Risk is defined as a function of the probability of the hazardous state occurring, the 
probability of the hazard leading to a mishap, and the perceived severity of the worst 
potential mishap that could result from the hazard. [,bXV 86] 

Safety can be used as a relative term depending on the situation. An item may not be 
safe under all circumstances and conditions, but compared to the alternatives to that item, 
it may be the safest choice available. For example safety razors and safety matches by Uieir 
very nature poses some risk; however, they are safer then their alternatives and they provide 
benefits to the user at a more acceptable level of risk then their alternatives. (Lev 86] 

In the devdopment of a system, trying to eliminate all unsafe or hazardous conditions 
may be impossible. Instead of removing the risk, a displacement of the risk to another area 


1 




is frequently the result In these situations one must use a risk/benefit analysis to determine 
what is the best solution. For example, nitrate, which is used in foods, have been linked to 
cancer. However, nitrate is also used to prevent botulism. '^Benefits and risks often have 
trade-offs, such as trading off the benefits of improved medical diagnosis capabilities 
against the risks of exposure to diagnostic X-rays.” [Lev 86] The trade-offs between the 
benefits and the risks are dependent on the particular situation and are usually defined by 
political, moral and economical decisions of the users. 

Safety depends on the situation in which it is measured. Leveson stated that nothing is 
completely safe und^ all conditions. Items that may be relatively safe under most 
conditions could become hazardous if the right conditions exist An example of this is 
drinking too much water, which could in turn, lead to kidney failure. [Lev 86} 

To understand safety, one must distinguish safety from rcbability. Reliability pertains 
to the probability that a system will perfoim its intended function for a specified period of 
time under a set of specified environmental conditions, thus making a system failure free. 
(Sal 76] Safety is concerned with the possible errors that may lead to a hazard and reliability 
looks at all possible errors. Since not all errors cause hazards, safety requirements only look 
at the subset of the errors that cause the undesired events. [Lev 86] 

According to Brown, safety is not reliability, availability or any other attribute or 
combination of attributes. In some situations, safety and reliability may actually counter 
each other. If the design is unsafe to start with, no degree of reliability is given to make it 
safe. Along will) this, if a system fails to u state, it is not reliable but it is safe. (Bro 88] 
Leveson states that safety and reliability can complement each other or can have no 
direct relationship with each otltcr. A hydraulic system of an afrcra.fr is more safe when it 
is more reliable. On the other hand, n^asiuing reliability for munitions pertains to 
detonation at the “desired time and place, while safety is related to inadvertent 
functioning”. For reliability and safety in this example, there is no direct relationship. [Lev 
86 ] 


2 





In addition, another aspect of reliability, availability, does not equate to safe. 
Availability is the probability that a system or component is operational at a qieciiic time, 
available when needed. [Sal 76] “A system may be safe but not available and may also be 
availaUe but unsafe (e.g., operating inconectly).** [Lev 86] 

B. SYSTEM SAFETY 

System safety pertains to the safety of the system, both hardware and software. A safe 
system is defined as a system that prevents unsafe states from producing safety failures, 
where an unsafe state is defmed as a state that may lead to safety failure unless some 
^cific action is taken to avert it [Lev 86] In the past hardware-oriented system engineers 
have treated the computer as a black box because of the **newness” of software engineering 
and the “significant difference between software and hardware". [Lev 86] Software 
engineers on the other hand ’^treated the computer as merely a stimulus response system". 
[Lev 86] According to Leveson “the greatest cause of problems experienced when 
computers are used to control complex processes may be a lack of system-level methods 
and view points". [Lev 86] In order to better resolve problems with systems, Uiese old 
views must be changed to an outlook that views the system as a whole. Leveson stated, 
"...that software itself is not ‘unsafe*. Only the hardware that it controls can do damage " 
(Lev 86] 

System safety is a subdiscipline of systems engineering that applies scientific 
management and engineering principles to ensure adequate safety throughout the system 
life cycle, within die constraints of operational effectiveness, schedule, cost and 
performance. (Lev 86] The primary goal system safety is to develop an acceptable safety 
level into the product before production or operations occur. This goal can be achieve in 
two steps. Ftr^ hazards need to be identified by applying scientific and engineering 
principles. Along with this, hazards need to be controlled through analysis, design and 
management procedures. The second step is to eliminate the hazards that post an 


3 





unacceptable risk from the system design. [Lev 86] Even though this is simply stated, the 
process is very complex. 

C SOFTWARE SAFETY 

In the previous section the overall safety of the system was considered. This section 
takes a look at specifically the software issue because hardware rehabUity has improved 
impressively in the last few years and they are no longer a major cause of system failures. 
According to Cha, software has become the major “bottleneck” in further unproving the 
system. He also stated that perfectly safe software is impossible and un-netxssary and that 
a more realistic goal is to develop software that is free from hazardous behavior. [Cha 91] 

Brown defines software safety as the optimization of system tiafety in the design, 
development, use and maintenance of software systems and their integration with safety 
critical hardware systems in an operational environment. [Bro 88] The intent of software 
safety is to ensure the software will function in a system context without creating an 
unacceptable level of risk. 

Software safety, however, is difficult to achieve. All methodologies in developing 
software use humans and humans m fallible. [Lev 83) According to Brown, virtually all 
enors that occur in software may be attributed to humans. These errors can be grouped into 
four categorit^; design, coding and testing, operator, and maintenance. (Bro SB] 
Additionally, “software..J)as a large number of discrete states without the repetitive 
structure found in computer circuitry. Although mathematical logic can be used to deal with 
functions (hat are not continuous, the large number of states and lack of regularity in the 
software results in extremely complex mathematical expresrions.” [Lev 86] 

Along with this, software safety is difficult because it is hard to develop realistic test 
conditions. Even with the use of simulatitms, it is difftcult to guarantee that the simulation 
is accurate. “Software faults may not be detectable except under just the right combination 
of circumstances, and it is difficult, if not impossible, to consider and atx^ount for all 


4 





environmental factors and all conditions under which the system may be operating.” [Lev 
86 ] 

Problems with the requirement specifications can also pose a problem to software 
safety. In a study of computer mishaps by Erickson and Griggs, it was determined tliat 
inadequate design foresight and specification errors arc the greatest cause of software 
safety problems. [Eri 81] [Gri 81] In performing tests on software, the test can only 
consider the specified requirements and can not look at what was intended by the designer. 

D. STATEMENT OF PROBLEM 

Although there exists potential problems and several unknowns in the use of 
computers in systems that control critical devices, the advantages that computers provide 
including increased versatility and power, improved performance, greater efficiency, and 
decreased cost, lend merit to their use in these systems. Computer systems consist of two 
major components, hardware and software. Even though new discoveries in hardware are 
occurring constantly, there exist techniques that allow engineers to better handle the 
problems that arise in hardware. Engineers working with hardware are better able to 
anticipate the possible problems with hardware because the development of hardware 
follows long-established procedures. Software, on the other hand, is more complex than 
hardware because of the large number of states present in software. Additionally, software 
is normally developed for a particular application only using tests in simulations and 
controlled environments as a basis for reliability. [Lev 86] 

Analyzing software with a purely manual technique is expensive because the step to 
traverse through the code requires an extra-ordinary amount of time. In addition, 
performing any function manually may introduce errors because humans are fallible. 
Automating the entire process poses other problems. One problem with automating the 
entire process is the loss of human insight required to see the intricacies of the system. 
Additionally, the experience of the analyst is lost when the process is fully automated. To 


5 





achieve a proper balance of manual and automated techniques in software safety analysis, 
both techniques arc required. 

This research pertains to software safety analysis, specifically increasing automation 
of the process. Introducing automated methods into software analysis may provide the 
analyst the opportunity to use his time more efficiently. The removal of the detailed work 
of code translation allows the analyst to focus on the semantics of the analysis, not the 
syntax of code. The primary purpose of this research is to assist in automating the process 
of translating code into usable structures for software fault tree analysis. 

Software fault tree analysis is a method of software safety analysis that looks at the 
logic of the software. In this proces.«, an undesired event caused by the software is identified 
and is labeled as the top node. The process works by looking at the top node and identifying 
the preconditions that are required for the top node to occur, given the design of the 
software. This process continues for each node at each level until the current node can not 
be further decomposed. 

This thesis introduces a prototype tool that wUl translate Ada statements into pre¬ 
defined template structures that are used in software fault tree analysis. This tool performs 
a static analysis of Ada code using Ayacc, an Ada parser generator; Aflex, an Ada lexical 
analyzer generator; FTE, a gr^hical fault tree editor; and self-generated code. After 
inputting the Ada code into the tool, the tool will basically parse the given Ada input and 
upon recognition of various Ada structures, build pre-dellned templates. Upon completion 
of the parsing and template generation, an FUB-compatible file will be generated. 

One question addressed by this research looks at the ability to automate the software 
fault tree analysis. Introducing automation to most processes reduces the time required to 
complete the process since machine is inherently faster than man. If automating software 
fault tree analysis provides more benefits compared to costs, then it may be of value to 
implement some automation m tlte process. 

Another question addressed pertains to the cost of automating software fault tree 
analysis A purely manual technique is too expen^ve, but a puiely automated process also 


6 



has problems. If a tool can be developed that strikes a balance between manual and 
automated techniques, the cost of automating software fault tree analysis could be reduced. 

E. SUMMARY OF CHAPTERS 

Chapter n provides background information that is related to this thesis. Areas 
covered m this chapter are fault tree analysis, software fault tree analysis, and previous 
works in this area including fault tree editors, the use of templates to represent statements, 
and the automation of code translation for software fault tree analysis. Chapter m covers 
the actual tool developed. Information on Ayacc and Aflex are also provided. Additionally, 
an extended example is reviewed in this chapter. Chapter IV provides the conclusions 
including the recommendations and provides a summary of possible future work. Appendix 
A contains the Ayacc and Aflex specification file input Appendix B is a listing of the 
source code excluding the generated code by Ayacc and Aflex. Appendix C provides the 
templates for individual Ada structures. Appendix D co-ttains the output of the Automated 
Code Translation Tool when the example procedure FAKEu.OVEN_CONTROL was 
inputted into the tool. 


7 



n. BACKGROUND INFORMATION 


A. FAULT TREE ANALYSIS 

Fault tree analysis (FTA) is a method of deductive safety analysis where a fault tree 
depicts the logical interrelations of basic events that lead to a particular event of interest 
[Lev 91] FTA originated initially in 1961 at Bell Laboratories to aid in the analysis of the 
Minuicman missile. Boeing further developed FTA in the mid 1960’s. [Sal 76] A fault tree 
consists of a fault event a failure situation resulting from the logical interaction of primary 
failures or failures of interest; a branch, the connection between two fault events or fault 
tree gates; and a fault tree gate, the boolean logic symbol that relates the input to its output 
event, [Fus 73] The fundamental concept of FTA is to decompose a physical system into a 
fault tree, al. o kn^'wn as a logic diagram, where certain specified causes lead to one 
specified event of interest This specified event of interest is also known as the “Top'’ event 
[Sal 76] 

To develop a fault tree, the mitial step is to define the top event that will be analyzed. 
After the top event is defined, the next step is to locate the cvent(s) that by themselves, or 
in combination with others lead tc the top event This analysis looks for a plausible 
sequence of events tiiat can lead to the event of interest in the context of the system’s 
environment [Meg 89] If one or niore event(s) is/are required to produce the event of 
intturest an And Gate is used to connect Uie evcnt(s) to the event of interest If one or more 
eveni(s) can lead to the event or interest, the cvent(s) is/are connected to the event of 
interest with an Or Gate. This process will cortinuc until all events in the tree arc defined 
or are not decomposable. [Sal 76j The resuU jf the fault tree jithcr depict the method of 
how the top event could occur or show that top event can not occur. [Meg 89] For a 
more detailed discussion on fault trees stthe papers by Salem and Fussell. [Sal 76] [Fus 
73] 


8 



B. SOFTWARE FAULT TREE ANALYSIS 


Mclntee coined a phrase “Soft Tree” in 1983 for a process which looked at software 
analysis using FTA techniques. This technique required a schematic of the system and a 
flow diagram of the software. His work basically started by identifying a top event and 
worked backward through the schematic and flow diagram. The result of this process 
provided a detailed path for how the process worked from the top to the bottom and through 
the hardware and software. [Mci 83] 

Taylor in 1982 [Tay 82] and Leveson and Harvey in 1983 [Lev 83] provided initial 
information on software fault tree analysis (SFTA). SFTA is a technique to analyze the 
safety of a software design that is similar to Soft Tree which uses methods similar to FTA. 
SFTA looks at the logic contained in the software. The primary purpose of SFTA is to 
ensure that the logic of the software docs not produce system safety failures. Additionally, 
SFTA determines environmental conditions that could cause the software to create a safety 
failure. [Lev 83] 


RECTANGLE 



DIAMOND 


O 

QRCLE 



O A 

EULIPSE TRIANGLE 


□ Q 

AND GATE OR GATE 


Figure 1 Common Software Fault IVee Symbols 
SFTA. like FTA, is designed to work ftom the identified hazard backwards to the 

initial command to execute the system. In addition, SFTA uses a subset of the symbols used 


9 





for FTA. (See Figure 1) The “rectangle” represents an event that will be further analyzed. 
The “diamond” is used for nonprimal events, which are not developed further for lack of 
information or insufficient consequences. The “circle” indicates an elementary event or 
primary failure of a component where no further development is required. The “house” is 
used for events that normally occur in the system. It represents the continued operation of 
the component The “ellipse” is used to indicate a state of the system that permits a fault 
sequence to occur. This system state may be normal or a result of failures. The “triangle” 
represents another sub-tree for the node which is not depicted on the current tree. The “and 
gate” serves to indicate that all input events are required in order to cause the output event. 
The “or gate” indicates that any of the input events may produce the gated event. [Rol 86] 
This common use of symbols allows for the interfacing of SFTA and FTA, thus 
providing a means for systems analysis of the hardware and software. The process of SFTA 
is similar to FTA, the difference is that SFTA pertains to software events and that SFTA 
does not employ the probabilistic approach of FTA, but instead deals with logic. “The basic 
procedure is to assume that the software has performed in a manner, which has been 
determined by the hazard analysis will lead to a catastrophe, and tlien to work backward to 
determine tlie set of possible causes." [Lev 91] After determining the catastrophe that 
occuned, the process works backward to the next level to determine the necessary 
preconditions for the catastrophic event to occur. Each child of each node will encounter 
the same process until the child can not be analyzed for some reason. The result of this 
process is a tree diagraming how an undesired event could occur or proof tliat an event 
could not occur. [Lev 91] 

SFTA provides many advantages to software analysis. The advantages include the 
following: 

• Provides the focus needed to give priority to catastrophic events and 
to determine the environmental conditions under which a correct state 
becomes unsafe. 

• Provides a convenient structure to store the information gathered 
during Uie analysis which can be used later for redesign. 


10 



• The technique is familiar to hardware designers. 

• Provides a single structure for specifying software, hardware, 
human actions and interfaces with the system. 

• Allows the examination of the effects of underlying machine 
failures or environmental changes versus verification techniques 
which assume system operates correctly. [Lev 83] 

C. PREVIOUS WORK 

1. FAULT TREE EDITORS 

Editors to graphically display fault trees have been developed to facilitate the 
drawing of fault trees by the analyst These tools allow the user to interactively modify the 
graphic representation of a fault tree using an automated graphic editor. The use of 
automated editors reduces the time required to draw the trees by removing the manual tasks 
necessary. Additionally, some of the errors that may have been caused by the manual 
drawing can be eliminated with an automated graphic editor. Two tools reviewed during 
the research of this thesis are the Software Fault Tree Analysis Tool [Rol 86], developed at 
the University of California, Irvine and Fault Tree Editor (FTE), developed at the Naval 
Postgraduate School. This thesis used FTE because it was readily available and operational 
at the time this thesis was initiated. 

The Fault Tree Editor is an interactive fault tree design tool. FTE was written by 
Charles P. Lombardo, a computer systems programmer at the Computer Science 
Departinent at the Naval Postgraduate School in Monterey California. FTE was developed 
using the C programming language and XView, an OPEN LOOK toolkit for the XI1 
Windowing system. 

Once FTE is running, the user can load a file to display a fault tree. The file can 
either be a file created by the tool or a file that meets the specifications of FTE. The 
^)ecification of an FTE file consists of four lines for each node on the tree. The first line is 
a string of characters that represent the label of the node. This value is the label displayed 
on the node within the tree. The second line is another string of characters that re{»esent the 
description of the faulL The third line is also a string of characters. This string of characters 


11 




is the file name of the code associated with the node. Tlie fourth line contains seven integer 
fields that are separated by any white space except a new line. These values represent the 
starting and ending line numbers of the code associated with the node, the X and Y 
coordinates where the node is located in the FTE graphical drawing field, the type of node, 
the type of gate attaching the node to its children, and the number of children of the node. 
The file is arranged with the four lines of each node grouped together and each node 
ordered in a pre-order fashion according to its relationship to the root node. (Sec Figure 2) 


- Node Values 


Label: 

‘Top” 

Fault: 

“Node caused fault” 

File: 

“Example.a” 

Start Line: 

1 

End Line: 

55 

X Coordinate: 

200 

Y Coordinate: 

300 

Type Node: 

1 

Type Gate 

0 

No. Children: 

0 

- The above node in FTE type specification 

1 Top 


1 Node caused fault 1 

Example.a 

55 200 3001 00 



Figure 2 Example Node Values 
2. SOFTWARE FAULT TREE TEMPLATES 

Taylor discussed the building of fault trees and software fault trees in his paper in 
1982. Using techniques from FTA and SFTA discussed above, Taylor used finite state 
models of plant components in tlie development of the fault tree. Taylor's process used the 


12 








plant components, also known as “mini-templates”, in building the fault trees. At each 
level, the event being analyzed would be matched to the mini-template to determine the 
events required to cause the undesired event The process terminated when a spontaneous 
or normal event was encountered. 

Leveson, Cha, and Shimeall wrote several papers on SFTA in 1987, 1989, and 
1991. Their work provided a manual means to perform SFTA for Ada code. Their work 
used predefined templates as the failure semantic of the Ada programming language 
statements. These templates were based on Ada statement stmetures, sliowing that if a 
particular Ada structure caused a fault where could that structure have caused the fault By 
linking the templates according to the code, the software fault tree generated would provide 
a tree depicting where faults, if they occurred, could occur. [Lev 91] Modified versions of 
the templates are in Appendbc C. 

3. AUTOMATED SOFTWARE FAULT TREE ANALYSIS 

Friedman automated SFTA for certain code structures of Pascal in 1993. His 
procedure consisted of four steps. Initially, a lexical analysis of the input would remove the 
blanks, tabs, and carriage returns and breakdown the code into distinguishable items called 
tokens. The second step involved the parsing of the tokens. This parsing step would 
generate a list structure that described the syntactic structure of the program. Upon 
completion of the parsing step, the list would be traversed creating the software fault tree 
using pre-defined templates and rules. This step would produce an ASCII file that would 
be compatible to a proprietary editor tool so that the tree could be drawn. The final step is 
the actual drawing of the tree using the generated ASCII code and the editor tool. 
Friedman’s tool used a commercial software product called Tlrec-Master that allowed the 
analyst to edit, display, and print the tree. [Fri 93] 

Friedman’s research provides an introduction of automation to the software fault 
tree analysis methodology of software analysis. His tool, however, only looks at a limited 
number of code structures of Pascal, namely the assignment-statement, the if-statement. 


13 





and the while-statement This research looks at the use of automation in the code translation 
of Ada code since Ada code is used in control systems more than Pascal and Ada code 
contains unique structures, such as exceptions and tasking. 


14 




m. AUTOMATED CODE TRANSLATION TOOL PROTOTYPE 


In the past, the code translation for SFTA has normally been performed using manual 
techniques. The use of manual techniques is a timely proposition. In addition, the use of 
manual techniques can lead to the introduction of errors because humans are fallible. This 
thesis introduces a prototype for an automated code translation tool to minimize the amount 
of manual code translation needed for SFTA. This tool is intended to reduce the amount of 
time necessary and reduce the number of errors in translating code by limiting the amount 
of human involvement This chapter will discuss the tool, detailing the items used in the 
development of the tool and the methodology used in building the tool. 

The Automated Code Translation Tool, as its name suggests, is a tool that will 
translate Ada statements into template structures to be used in SFTA. The tool consists of 
basically four components. The first component is a lexical analyzer. The lexical analyzer 
will determine if the given input consists of valid tokens. The next component is a parser. 
This part of the tool will check the given input to ensure that valid Ada constructs arc used. 
The third component is a template generator that will transform valid statements into 
templates representing possible events associated with the statement in a format suitable for 
SFTA. The final component of the tool is a file generator that will create a file that meets 
the specifications of on FTE file type. Each component will be discussed in the following 
sections. (See Figure 3) 


15 




INPUT FILE 



OUTPUT FILE 
“NEW_FTE” 


Figure 3 Automated Code IVanslation Tool Structure 

A. THE LEXICAL ANALYZER AND PARSER 

A lexical analyzer is a part of a system that breaks up the inputted code into 
meaningful units called tokens. Tokens can be names, constants, reserved words, or 
operators, among other things that are defmed by the programming language. The lexical 
analyzer will also remove white space including blank spaces, empty lines, and carriage 
returns. The primary purpose of the lexical analyzer is to determine ii' the given input 
consists of valid tokens for the programming language. [Ill 90] Ihe lexical analyzer for die 
Automated Code lYansIation Tool was buUt using an Ada based lexical analyzer generator 
called Aflex. For more information on Ailex, see the Ailex user manual. [Ngu 88] 

The specification fde for Aflex used to develop the lexical analyzer in the Automated 
Code Translation Tool was developed by Herman Fischer of Litton Data Systems in March 
1984. The lexical input information in this file represents the grammar for ANSI Ada. No 


16 








modifications to the file were required in the development of the tool. The Aflex 
specification file for the Automated Code Translation Tool is located in Appendix A. 

A parser is the programming module that performs parsing operations on a computer 
language. Parsing is the process of deciding whether a string of input symbols is a sentence 
of a given language, and if so, determining the syntactic structure of the string as defined 
by a grammar for the language. The primary purpose of the parser is to validate the string 
as a correct statement for a given language. [HI 90] The parser for the Automated Cede 
Translation Tool was built using an Ada based paiser-generator called Ayacc. For more 
information on Ayacc, see the Ayacc user manual. [Tab 88] 

The Ayacc specification file used to develop the parser in the Automated Code 
Translation Tool was a modified version of the David Taback and Deepak Tolani 
specification file. The Taback and Tolani version was an adaptation of the Herman Fischer 
file used in Yacc. The grammar for the file is organized in die same order as the ANSI Ada 
Reference Manual. 

The modifications to the Taback and Tolani file for the tool consisted of added actions 
to be performed when particular code struaures were recognized. These actions are related 
to functions and procedures located in separate packages and are components of the 
template generator which will be discussed in the next section. The packages are 
FA’JLT^TREE^GENERATOR and TOAVERSE^PKG and arc located in Appendix B. 
The specification file for Ayacc used in the development of the parser for the Automated 
Code Translation Tool is located in Appendix A. 

B. THE TEMPLATE GENERATOR 

Basically the templates represent the idea “if this statentent caused a fault, where could 
that fault have been introduced within the statement". These templates were developed 
using die previous work of Levt^n, Cha. and Shimeaii. [Lev 91] The templates were 
sligtiUy modified to accommodate the parsing of the Ada grammar. The templates for the 


17 






implemented code stiucturcs arc located in Appendix C. The symbols used in the templates 
arc similar to the symbols used in software fault trees. (See Figure 1) 

The template generator consists of Unctions and procedures that are called when 
various Ada structures are recognized. The template generator works in concert with the 
parser. As the parser identifies various structures, the template generator will be called to 
build the template for the particular structure. This process is exemplified with an if- 
statement example. (See Figure 4) The following is a description of how the if-statement 
is parsed using the Ada grammar and how the template is built witfi the tool. 

IF temperature < 15.0 THEN 
rad_sct;= rad_set + 5.0; 

ELSIF temperature < 18,0 THEN 
radLsci;= radLset +1.0; 

ELSE 

radLset:® radLset -1.0; 

END IF; 

Figure 4 If^Statement Example 

When the parsing of Ada source code begins, it initially starts at the starting non* 
tenninal “compilation". Eventually it proceeds to the sequence of statements non-terminal 
and then to the statement non-terminal. Using the current token "if*, the if-statement 
grammar rule is selected and (he process to build the template for the if-statement begins. 
The if-statement grammar rule consists of seven ^nmar symbols. (SeeHgureS) Before 
the if-statement template is built, the pars<^ must identify and parse the individual grammar 
symbols. This discussion looks at only the parsing of tire non-temunais because terminal 
symbols are recognized by lexical analysis. (When looking at the grammar rules, the capital 
words identify non-terminals in the rule.) 


18 







IF_STMT: if_token COKD then_token 


SECLOF_STMTS 

..ELSIF_COND_THEN_SECLOF _STMTS.. 
.ELSE_SEQ_OF_STMS. 

end_toke^' if_token ; 


Figure 5 Production Rule for If>Statement 
The first non terminal of the if-statement rule is the condition non-terminal. The 

condition represents a boolean expression for the if-statcment. In parsing the condition non¬ 
terminal, the expression non-terminal will be called. From the expression non-terminal, the 
relation non-terminal with one or more relations and zero or more logic operators, 
depending on the actual input, will be executed. At the relation level, a template containing 
possible events related to the actual condition will be built by the template generator and 
returned to the expression non-terminal level. Thi template will be passed backward to the 
condition non-terminal level and in turn passed back to the if-statement non-terminal level 
for use in the building of the if-statcment template. 

In the example, the condition is a simple relation, “temperature < 15.0”. For this 
condition the template generator v/ill build the simple relation template, (See Figure 6) 
This template would be passed back from the relation non-texminal back to the if-statement 
non-terminal through both the expression and condition non-terminals. 


19 








Figure 6 Relation Template for Condition 
Following the condition non>tenninal» the sequence of statements non-tenninal of the 

if'Statement production rule would be parsed. This sequence of statements represents the 

action that would be performed if the condition evaluated to true. In the example, the 

parsing would again start at the sequence of statements non-terminal and recognize that the 

next non-terminal was a single statement This statement would be identified as a simple 

statement, followed by recognition as an assignment-statement At the assignment- 

statement production rule, the parser would parse the individual components of the rule, 

The rule consists of two non-terminals, name and expression. For the name non-terminal, 

the parser would recognize that ‘*rad„set" is a simple name and at the simple name nmi- 

terminal the name template for 'Vad^set" would be generated by the template generator. 

The next non-terminal of tlic assignment-statement is the relation, ‘had^sci + 5.0”. 

This example is another simple relation. The relation template would be built for this 

expression by the template generator and passed back to the assignment-^tement (See 

Figure 7) 


20 











Figure 7 Relation Template for Assignment*Statement 
When the parser returns to the assignment-statement non-terminal, the template 

generator will create the assignment-statement template with the simple name template and 

the relation template for the assignment-statement as components to the template. The two 

previously generated templates would be placed as children to the ^'Operand Evaluation 

Caused Fault” node. (See Figure 8) The assignment template will be incorporated into the 

template for the sequence of statements to represent the sequence of statements for the if 

condition. (See Figure 9) Since there is only one statement in the sequence of statements, 

the nodes pertaining to the previous statements will not be necessary. The sequence of 

statements template would be returned to the if-statement non-terminal level to be used in 

the creation of the if-statement template. 


21 











22 















Sn^fuuc* of Stt twnwrti 
CilMdFailt 



Figure 9 Sequence Of Statements Template for If Clause 
The next non-terminal token to be evaluated from the if-statement production rule 

vk'ould be the token referring to the **elsir' clause. The elsif clause is optional This non¬ 
terminal has three non-teiminais in the production rule. These non-terminals are a non¬ 
terminal for other elsif s if applicable, a condition non-terminal, and a sequence of 
statements non-terminal (See Figure 10) For the example there is only one elsif clause, 
therefore the other elsif non-tominal will not be executed. The elsif non-terminal is a 
recursive call to itself and will stop only after all elsif s have been parsed. 


23 











..ELSIF_COND_THEN_SEQ_OF_STMTS.. 

I 

..ELSIF_COND_THEN_SEQ_OF_STMTS, 
elsif_token COND thcn_tokcn 
SEQ_OF_STMTS; 


Figure 10 Production Rule for Elsif Clause 
The condition for the elsif in the example is “temperature < 18.0". This condition is 

another simple relation and would produce a template similar to the condition template for 

the if condition. The sequence of statements following the elsif condition is also similar to 

the previous sequence of statements, another single assignment-statement The assignment- 

statement is “rad.sct := rad_sct -f 1,0;”. The template generated by the template generator 

for this statement is identical to the previous sequence of statements except for a change in 

some of the values to the variables. 

The condition template for the elsif and the sequence of statements template for the 
elsif will be passed back to the elsif non-terminal. The template generator, after the parser 
completes the parsing of the non-terminals in the elsif example, will use these templates to 
build the elsif template for the if-statement. Since there are no other elsifs in this example, 
the node “Next Elsif Caused Fault", which pertains to the other elsifs of the statement, will 
not be required. (See Figure 11) 


24 






Figure U Elsir Template for Example 

The final non-tenninal token for the if-statement is the t^en xepresenting the ‘^else** 
clause. The else clause is optional and if it exists, it will be executed if there are no previous 
conditions that evaluated to true. The production rule for the else clause consist of only the 
sequence of statements nnn«terminal. (See Figure 12) 
















^LSE_SEQ_OF_STMTS. 


clsc_token 
SEQ_OF_STMTS; 

Figure 12 Production Rule for Else Clause 
In parsing the sequence of statements for the example, the parser would again 

recognize that it consists of only one statement This statement is the assignment-statement 

“rad_set := rad_set - 1.0;”. Upon recognition ot this fact, the template generator would 

create similar templates as before, excluding the condition template because the condition 

for the else clause is implicitly deHned. The sequence of statements template will be passed 

back to the else non-terminal where the template generator will build the else template with 

the sequence of statements as a child of the template. The else template, when built, will be 

passed back to the if-statement non-terminal to be included in the if-statement template. 

(See Figure 13) 



Figure 13 Else Template for Example 


26 













Once all the components of the if-statement have been parsed and the appropriate 
templates have been built, the template generator would be called to build the template for 
the if-statement This template would be built using all of the templates that werr generated 
by the non-terminals of the statement (See Figure 14) Appendix C gives a more detailed 
version of a generic if-statement template. 






_[ 

_IL 


]_ 

EvdMtioa of If Co«4U1ob 

CiMtd Flmii 

euir Ebt 

CauMd Fuitt C«uHd PuU 

zxzxzxzx 

CondllloaTmnpUi* S^quMMofSUItmtaU EtilfTmpUt* Eti«TMipUU 

(SMFaunO 'nnpttit (S«n(ur«n) (SMFIlMttS) 


Figure 14 If-Statement Template for Example 

C. THE FILE GENERATOR 

The file generator is the part of the Automated Code Translation Tool that produces a 
FTE type file for the given input The file generator is composed of Ada procedures that 
will take the generated templates and convert the data structures into FTB data structures. 


27 











Additionally, in accordance to FTE file specifications, the file generator will place the 
individual nodes in pre-order fashion with respect to their relationship to the root node. The 
file generator is embedded in the parser as actions and will be invoked when the parsing of 
the given input is complete. The file generator will produce a file called “NEW_FTE”. This 
file can be loaded into FIE to display a graphical depiction of the software fault tree for the 
given input 

D. THE DATA STRUCTURE 

The data stracture for the nodes of the software fault tree was constructed using the 
FTE data structure as a model. This structure was used to facilitate the drawing of the 
software fault tree upon completion of the parsing and template building. (See Figure 15) 
The individual fields of the data structure that are similar to the FTE data structure have 
the same meaning as discussed earlier. The added fields CHILDREN_NODES and 
PREV_ST_PTR were added to keep track of the family ties because the nodes’ 
relationships as parents and children are maintained by using a linked list. The other added 
field, OUTPUT^FLAG was not used in the prototype, but was included to allow the tool to 
identify structures diat provide output in the program. In order to make the data structure 
compatible, a routine is used to equate the generated file to an FTE compatible file. This 
routine will remove the additional fields tliat were added to the data structure to facilitate 
the parsing. This routine is part of the file generator as discussed in the previous section. 


28 





type ST_LIST_NODE_PTR is access ST J.IST_NODE; 
tyi)eST^LIST_NODEis 

ST_NODE_LABEL: STRING (l..MAX^CHAR_SHORT); 
« ROOT_FAULT: STRING (l..MAX:_CHAR^LONG); 

* FILE_NAME: STRING (l..MAXL.CHARJLX)NG); 

* START_LINE: NATURAL; 

* END_LINE: NATURAL; 

* X.COORDINATE: INTEGER; 

« Y.COORDINATE: INTEGER; 

* TYPE_NODE: NODE_TYPE; 

* TYPE.GATE: GATE.TYPE; 

* NUMBER OF CHILDREN: NATURAL; 
PREV_ST_FIR: ST_LIST_NODE_PTR; 
aiILDREN_NODES: ST.LIST^NODE^PTR; 
OUTPUTJ5LAG: BOOLEAN; 

end record; 

^Derived from data fields in the FTE data structure 


Figure 15 Software Fault Tree Node Data Structure 

E. THE INPUT/OUTPUT 

When execution begins, the tool will prompt the user for an Ada file to work with. 
After the user enters the file name, the tool wUl process the file. The prototype has limited 
syntax-error detection, so it is assumed that the file is syntactically correct The output of 
the tool will consist of two items. The first item generated by the tool will be an on-screen 
display of three lists. A listing of the software fault tree wUl be printed to the screen first 
The information provided includes the node’s label and fault and the parent’s label and 
gate, if applicable. The next Ust is a list of the nodes in numeric sequence. This listing was 
generated to facilitate the reading of the generated FTE software fault tree, which in the 
prototype, labels nodes by number. The last item di^layed on the screen consists of a 


29 







listing of the procedures, functions, and exceptions that were located in the input file along 
with the first node’s root fault associated with the procedure, function, or exception. 

The second item produced by the tool is an ASCU file called “NEW^FTE”. This file 
is compatible to FTE and represents the nodes produced in a pre-order listing. To display 
the software fault tree in FTE, FTE must be started and NEW_FTE must be in the current 
directory. Once FTE is started, the generated file can be loaded into FTC using the 
appropriate FTC commands. This will generate the software fault tree in a graphical form. 

F. EXTENDED EXAMPLE 

In order to see the actual code translation for a set of Ada statements performed by tliis 
tool, the tool was invoked with the file EXAMPLE.A. This file contained the procedure 
FAKE_OVEN_CONTROL. (Sec Figure 16) The procedure FAKE_OVEN_CONTROL 
was created to simulate an oven-control system. This procedure is by no means an accurate 
representation of an oven-control system, but is intended to represent source code where 
safety could be an important issue 


30 



prccedure FAKE_OVEN_CONTROL(SAMPLING_DURATION ; INTEGER; 

GOAL_TEMP : INTEGER) is 

OVEN^UF is access INTEGER; 
for OVEN_BUF use at 1234567; 

OVEN_TEMP is access INTEGER; 
for OVEN_TEMP use at 2345671; 

LAST_CMD ; INTEGER; 

begin 

for SAMPLE in 1..SAMPLING.DURATION loop 

if (OVEN_TEMP < GOAI^TEMP - 10 and LAST_CMD /= 1) then 

OVEN_BUF := 1; 

LAST^CMD := 1; 

elaif {OVEN_TEMP < GOAL_TEMP - 10) then 
RAISE OVEN_NOT_RESPONDING; 

elaif (OVEN_TEMP > GOAL^TEMP ♦ 10 and lAST^CMD /= 2) then 
OVEN_BUF 2; 

LAST_CMD := 2; 

elaif (OVEN^TEMP > GOAL_TEMP ♦ 10) then 
RAISE OVEfU<OT_RESPON01NG; 
end if; 

for 1 in l.,SAMPLING_DORATION loop 
null; 
end loop; 

end loop; 

end FAKE_OVEK_CONTROL; 


Figure 16 Sample Ada Code Input 

For the procedure FAKE_OVEN_CONl'ROL, the body of the procedure consists of a 
sequence of statetnents. A careful review of the procedure FAKE_OVEN„CONTROL 
shows that the sequence of statements consists of a for^loop, which is the main part of the 
procedure, and two embedded statements within the for-loop. The first statement within the 
for-loop is an if-statement that contains three elsif clauses. The second statement is another 
for-loq) that conuuns the nuU-statemenL The following discussion details how the 


31 







procedure is transformed from Ada source code to software fault tree structures. Before this 
discussion starts, it needs to be noted that the tool will translate the source code bottom-up, 
meaning that the last statement will be translated first and the first statement will be 
translated last In this example thwe is only one statement in the outer level; however, 
within the outer for-loop there are two statements. The inner for-loop will be translated first 
and the if-statement will be translated next The last statement to be translated will be the 
outer for-loop. A discussion on the translation process of the proceduio follows. 

In the Ada programming language, three types of loops exist including the “for”, 
“while", and plain loop. The Automated Code Translation Tool will build a similar 
template for all three loops. The major difference between the three types of loops is the 
iteration scheme for each loop. 

If a loop caused a fault there are three possible reasons why de loop caused the fault 
First thete may exist a situation where the loop was not executed and its non-execution 
may cause a fault Another possible reason may involve tire evaluation of the loop 
condition. Finally, there may have been some situation during the Nth iteration that caused 
the fault The Automated Code Translation Tool incorporates all three reasons in the loop 
template when the template is built 

Since the example contains a for-loop, the Automated Code lYansiation Tool will 
tailor the generic loop template accordingly. The tool will build the “Parameters Specified 
Caused Fault” node as a child to the “Iteration Scheme Caused Fault” node, instead of dte 
“Evaluation of Condition Caused Fault” node which is used for a while loop. Along with 
this, the tool will place the sequence of statements template for the statments in the for- 
loop in two places. This is done to rex:ognize the fact that the sequence of statements may 
have caused the fault or that the sequence of statements may have kept the loop condition 
true when it should have been false. In the embedded for-loop. the only statement in the 
sequence of statements is the nuU-statemenL In this case, the tree representing the sequence 
of statements will be null. (See Figure 17) 


32 






Figure 17 Embedded For>Loop Template for Procedure FAKE^OVEN.CONTROL 


33 


























The if-slatement for the procedure FAKE_OVEN_CONTROL is similar to the 
example if-statement discussed earlier in the template generator section. The if-statement 
for the procedure, however, has three elsif clauses and no else clause. The Automated Code 
Translation Tool will build the if-statement template using the node “Next Elsif Caused 
Fault” and its associated nodes several times and not using the node “Else Caused Fault”. 
Due to the large size of the software fault tree representing the if-statement in the 
procedure, the software fault tree is depicted in several figures. The figures are shown in 
the order that they would appear in the software fault tree and not in the order that they were 
generated. 



Figutt! 18 ir-Statement Template for Procedui^ FAKE.OVEN^CONTROL 


34 











Node Fault for Node 

62 Evai^Ofl of conation caused fault 
73 Relaikm caused the fault 

85 And Relation caused the fault 

97 Left or Prior relation caused fauU 

98 Right relation caused fault 

112 Relation caused the fault 

113 Relation caused the fault 
1290VFJ^^TBMP 

130 AddiUi^Subtraction F^ 

131 LASt.CMD 
1321 

1S3G0AL_TOMP 

154 Sutmaction Fault 

155 10 


Figure 19 ContUUon Template fbr If«$Utemeat 


35 




















































Node Fault for Node 


63 Condition true and statements caused fault 

74 If condition true 

75 If statements caused fault 

86 Sequence of statements caused fault 

99 Last statement caused fault 

100 Previous statements caused fault 
114 Assignment Statement Fault 

1 IS Last Statement did not mask fault 
116 Sequence prior to last caused fault 

133 Change in values caused Fault 

134 Excqttion causes Fault - Not implemented 

135 Oper^d Evaluation causes Fault 

136 Sequence of statements caused fault 
156LAST.CMD 

157 Relation caused the fault 

158 Last statement caused fault 

159 Previous statements caused fault 
1851 

186 Assignment Statement Fault 

187 Last Statement did not mask fault 

188 And Sequence prior to last caused fault 

212 Change in values caused Fault 

213 Exception causes Fault - Not implemented 

214 Or Operand Evaluation causes Fault 

233 0VEN_BUF 

234 Relation caused the lault 
2541 


Figure 21 Sequence of Statements Template for lf>Statenient (Continued) 


37 








Figure 22 Elsif Template for If-Statement 


38 



























No de Fa u lt for Node 
64 ELSIF caused the fault 

76 Previous conditions evaluated to false 

77 Curreni/future ELSIF caused the fault 

87 Evaluation of Elsif condition caused fault 

88 Current ELSIF caused the fault 

89 Other ELSIFs caused the fault 

101 Relation caused the fault 

102 Current ELSIF condition caused the fault 

103 Cunent ELSIF sequence of statements caused the fault 

104 ELSIF caused the fault 

117 Relation caused the fault 

118 Sequence of statements caused fault 
1370VEN_TEMP 

138 Addition/Subtraction Fault 

139 Last statement caused fault 

140 Previous statements caused fault 
160GOAL_TEMP 

161 Addition Fault 
16210 

163 Raise Statement Caused Fault 

164 Last Statement did not mat.«fault 

165 Sequence prior to last caused fault 

189 Wrong Exception Raised Caused Fault 

190 Excqi&m Handier Caused Fault 
215 OVENjNOTJlESPONDINO 


5 _ 


Figure 23 Elsif Template for lf>Statement (Continued) 


39 







For brevity, the templates representing the other elsif alternatives are not depicted. The 
templates are identical to the elsif template displayed except for a different sequence of 
statements for each elsif. Upon completion of the if-statement translation, the Automated 
Code Translation Tool builds the sequence of statements template for the outer for-loop. 
This template contains both the embedded for-loop and the if-statement This template is 
used in the outer for-loop template representing the statements within the outer for-loop. 
(See Figure 24) 

Basically, the template for the outer for-loop will almost be identical to the embedded 
for-loop. The only difference is the software fault tree representing the sequence of 
statements within the for-loop. For the embedded for-loop, the software fault tree was null 
because the statement within the loop is the null-statement The outer for-loop contains the 
two statements discussed above and is represented by the sequence of statements for the 
outer for-loop. 


40 






B wb«d<k J For-Uop SUUttMl 
rttvnt? 




Node Fault for Node 



14 Sequence of statements caused fault 

19 Last statement caused fault 

20 Previous statements caused fault 

25 Last Statement did not mask fault 

26 Sequence piior to last caused fault 


Figure 24 Sequence of Stateirients Template for Outer Foi^Loop 











Figure 25 Outer For-Loop Template for Procedure FAKE.OVEN.CONTROL 


42 



















For the procedure FAKE_OVEN_CONTROL, the Automated Code Translation Tool 
will build the sequence of statements template to represent the body of the procedure. The 
“Last Statement Caused Fault” node will have as its child the software fault tree 
rq)resenting the outer for-loop. Since there is only one statement for this procedure, the 
“Sequence Prior to Last Caused Fault” node will be null. (Sec Figure 26) The result from 
the Automated Code Translation Tool was a software fault tree that consisted over 300 


nodes. This software fault tree depicted many possible events that could cause a fault It is 
now the analyst’s job to select relevant events and expand the analysis accordingly. 



Node Fault for Node 


0 Sequence of staicments caused fault 

1 Last statement caused fault 

2 Previous statements caused fault 

4 Last Statement did not mask fault 

5 Sequence prior to last caused fault 


Figure 26 Sequence of Statement Template for Procedure 
FAKE^OVEN^COhrrROL 

G. FINISHING THE EXAMPLE ANALYSIS 

To view the generated software fault tree in FTE, the user .starts FTB and loads the file 

by clicking on the “LOAD" icon. PTE will now ask the user for the file to load. By typing 


43 







“NEW_FTE”, the software fault tree generated by the Automated Code Translation Tool 
will now appear in the graphical box. The software fault tree depicted by FTE may not 
contain all the nodes of the NEW_FTE file because the drawing field available in FTE is 
limited. In order to view as many nodes as possible in the FTE drawing field, the algorithm 
used to generate the X and Y coordinates for the individual nodes was to place nodes on the 
appropriate level according to their relationship to the root node and to left justify the nodes 
on each level. 

The Automated Code Translation Tool provides a service to the analyst By 
automating the code translation, the amount of errors occurring in the translation is reduced 
to a minimum. Additionally, the time required by the analyst to perform this step is 
drastically reduced, allowing the analyst to make better use of his time. The tool, however, 
does not pin-point one specific fault. In order to use the generated software fault tree in 
SFTA, the analyst must identify a particular fault and modify the generated software fault 
tree accordingly. 

For example in the FAICE_OVEN_CONTROL procedure there existed a for-Ioop that 
at first glance appeared to have nc purpose since the loop body contained only the null- 
statement. In actuality, this loop was inserted as a delay to provide the control system the 
required time needed to perform its sensing. If this loop was removed when the code was 
compiled because of code optimization, the time required to sense the oven temperature 
would not be sufficient This would likely cause the exception 
OVEN_NOT_RESPONDINO to be raised. Using the generated software fault tree, the 
analyst could detect this fault 

Initially, the analyst must select a root fault to analyze. With the selected root fault, U:c 
analyst will eliminate the nodes from the ouqiut of the Automated Code Translation 
that do not pertain to tlie selected root fault. Upon completion of this step, tlie analy u will 
need to modify the remaining nodes to ensure that they are relevant to the root fault The 
end result of this process would be a software fault tree similar to the one in Figure 27. (See 
Figure 27) 


44 




Figuit 27 Modified Software Fmat llree for Procedure FAKE^OVEN.CONTROL 


43 














IV. CONCLUSIONS 


A. INTRODUCTION 

One question addressed by this research was to look at the possibility of automating 
the software fault tree analysis. Another question addressed pertained to the cost of 
automating the process. This chapter provides the answers to the questions. Section B 
summarizes the significant results of this research. Section C offers recommendations to 
practitioners in applying techniques of this sort Section D concludes by giving suggestions 
for future research. 

B. RESEARCH SUMMARY 

One result of this research demonstrated that SFTA can be automated to some extent. 
Analyzing software in a purely manual technique is expensive because of the labor and time 
ir 4 tensive step to traverse and translate the code. A purely manual technique may also 
introduce errors because humans make mistakes. The opposite solution, a totally automated 
proce^, has deficiencies because of the loss of human insight attd experience of the analyst 
TIterefore a balance between manual and automated techniques in SFTA should be applied. 
The SFTA process contains a code translation step that is repetitive and labor intensive. 
This step is a prime candidate for automation because this step does not require much 
foresight since the structures of tire programming language are constant WiUr machines 
inherently faster titan man, using ntachines to perfonn this task can reduce the amount of 
time required. This, howsver, does not replace the need for the analyst in SFTA. 

Another outcome of this study demonstrated that the cost to automate a portion of 
SFTA is signiHcantiy lower than the benefits that automation provides. With tiic existence 
severai tools, most notably Aflex to produce a lexical analyzer, Ayacc to produce a 
pars^; and FTE to provide a tool to draw software fault trees, the cost to develop a tool to 
automatically translate code was minimal. This tool provides many benefits. An automaM 
code tranriation tool provides the analyst the opportuni^ to use his tinte more efficiently 


46 



by reducing the detailed work of code translation. Additionally, the tool allows the analyst 
the opportunity to focus on semantics of the analysis and not the syntax of the code. 
Comparing the costs versus the benefits of automation, the benefits out weigh the 
associated costs. 

C. RECOMMENDATIONS 

The results of this research can help the analyst in providing safe software by 
facilitating the SFTA process. This thesis uses the concept of SFTA in ensuring that the 
software for the computer systems is safe. SFTA is not a new idea in software safety, 
however, the majority of research in SFTA has been performed using manual techniques. 
Since it has been proven in various research that tasks that require continuous and/or 
repetitive work is better performed by machines than man, this thesis looked at automating 
part of the SFTA process, specifically the code translation step. This thesis introduces a tool 
that removes a large percentage of the human interface. With the introduction of the 
Automated Code Translation Tool prototype, the tool eliminates the possible errors that 
could have occurred if the code translation step of SFTA was performed manually. 

The Automated Code Translation Tool is a prototype to perform code translation for 
Ada statements. This tool works on several assumptions. Primarily, this tool is intended to 
provide an initial translation of the code. This translation is developed with the intention 
that it will be refined by the analyst. Additionally, this tool looks only at the syntax of the 
code. Assuming that the code is syntactically correct and that there are no overt logic errors 
or other errors in the code, this tool will take the input code and translate it into structures 
that can be used in SFTA. 

This tool was developed to look at programs written in the Ada programming 
language. This tool should be used as a means to hanslate Ada statements into software 
fault tree structures representing the statements. The results from this tool should be 
followed by a thorough review by the analyst to make adjustments where necessary. This 
tool is a prototype and the result should not be used without art analyst 


47 







D. FUTURE RESEARCH 


There are several avenues of research that can be examined in the future as follow-up 
studies to this work. As a prototype, this tool looked at only a subset of Ada structures. This 
work can be expanded to contain the Ada structures that were not included. More 
specifically, the concept of tasks and exception handling need to be addressed. This tool is 
a stepping stone in the direction to automate code translation; however, the tool can not be 
complete until all of the Ada structures are implemented. 

Another potential area of research might involve the interface with a graphical editor 
to display the software fault tree. Even though FTE provides a good graphical editor, the 
limitation on the drawing field poses a problem. Software fault trees tend to be large by 
their very nature and a graphical editor is needed to be able to depict the software fault tree 
in its entirety. Along with this, the algorithm used in the prototype to give the nodes X and 
Y coordinates was simple. To make the software fault tree more aesthetically pleasing, a 
more sophisticated algorithm should be developed and implemented. 

Translating the output from the Automated Code Translation Tool to a usable software 
fault tree is another possible area of futuie research. An automated process to eliminate 
unrelated parts of the software fault tree and modify the remaining parts to be relevant to 
the selected root fault would reduce the amount of time necessary for software fault tree 
analysis and reduce the amount of possibl'* errors caused by the human factor. 

Finally, this tool provides a static code translation without any consideration to the 
actual fault. Future work can examine the possibility of expanding automation in SFTA by 
looking at the faults more dynamically as the software is working. The process of SFTA is 
lengthy and costly. With the introducuon of automation into the process both tlte time to 
perform SFTA and the cost of SFTA can be reduced. This research has established some 
initial observations and steps towards automation of SFTA, but many more question ait left 
unanswered. 


48 


APPENDIX A: AYACC AND AFLEX INPUT 


A. AYACC SPECIFICATION FILE: 


>• Specification file is a modified vsnsioo of the Taback and Deepak specification 
- file. The Taback and Deepak version was an adtqttation of the Herman Fischer file 
file used for Yacc. 


%tok?n ■&' •' T y '+' V • V •/ V 
%token'<''=”>'T 

%token ARROW DOUBLE_DOTDOUBLE_STAR ASSIGNMENT INEQUALITY 
%token GREATER^THAN_OR_EQUAL L£SS_THAN..OR_EQUAL 
%token LEFTJLABEL_BRACKETRIGHT_LABEL3RACKET 
%token BOX 

%token AB0RT_T0KEN ABS.TOKEN ACCEPT_T0KEN 
ACCESS.TOKEN 

%token ALL.TOKEN AND_TOKEN ARRAY_TOKEN AT^TOKEN 
g^tokenBEGIN.TOKEN BODY.TOKEN 
%tokenCASE_TOKEN CONSTANT.TOKEN 
%token DECLARE_TOKEN DELAY.TOKEN DELTA^TOKEN 
DIGITS.TOKEN DO_TOKEN 

%tokenELSE_TOKENELSIF^TOKENEND,TOKEN ENTRY^TOKEN 
EXCEPTION TOKEN 
%tokenEXIT_TOKEN 
%token FOR_TOKEN FUNCTION^TOKEN 
%token GENERIC.TOKEN GOTO^TOKEN 
%tokeit IF.TOKBN IN.TOKEN IS_TOKEN 
%tokcn UMrreD_TOKEN LOOP^TOKEN 
%token MOD.TOKEN 

%U)kcnNEW.,TOKENNOT_TOKEN NULL^TOKEN 
%U)kcn OF.TOKEN OR^TOKEN OTHERS^TOKEN OUT„TOKEN 
%tokenPACKAOE_TOKENPRAGMA^TOKEN PRTVATE^TOKBN 
PROCEDURE_TOKEN 

%tokenRAISE„TOKEN RANGE_TOKEN RECORD.TOKEN REMLTOKEN 
RENAMES„*rOKEN 

%tokcn RETURN^TOKBN RBVERSE.TOKEN 
%tokcn SELECT.TOKEN SEPARATB.TOKEN SUBTYPE^TOKEN 
%token TASieTOKEN TERMINATE_TOKEN THEN^TOKEN 
TYPE^TOKEN 
%tok«rt USE.TOKEN 

%tokcn WHEN_TOKEN WHILE„1X)KEN WmLTOKEN 
%tokcn XOR^TOKEN 
%tokcn IDENTIFIER 

%token INTCOERJJIERAL REALJ-ITBRAL 
%tokcn CHARACIER^UTERAL STTUNO^LITERAL 
^(okenERRORl ERROR2 ERROR3 ERROR4 ERRORS BRROR6 
ERROR? ERRORS 

%tokeQ ERROR9 ERRORIO ERRORl 1 ERRORi2 ERROR13 mORU 


49 








ERRORIS 
%stait compilation 

%with &ult_iree_generator, tracejackage, traverse_pkg, textjo 
%use faultjree_generator,tiace_package,traveise_idcg,U!xt_io 
{ 

TAB.COUNTER :INTEGER:*!; 

CUILTABLE ; SYS.TABLE; 

EXCEPT_COUKTER: INTEGER:«1; 

EX_TAB : EXCEPT.TABLE; 

FTEJTLE : FILE_TYPE; 

OTHERS.CHECK: BOOLEAN:» FALSE; 
type s^.var is (int, nde); 
type yystype <form:stype_var := int) is 
rec^ 
casefonnis 

when int s>int_t: integer, 
when nde *> node.t: sLlisLnode_ptr; 
end case; 
end record; 

1 

%% 

seLothers true ; {OTHERS_QIECK :«TRUE;} ; 
seLothersJalse: (OTHERS.CHECK FALSE;); 

prag ; 

PRAGMA^TOKEN IDENTIFIER ,arg.ascs V; 
argjisc 
expr 

I IDENTIFIER ARROW cxpr; 

Added •« 
numericJi tend 

:REALJJTERAL 

iihnEGEiLLrnsRAL 

tbasic.d : 
objct^d 

I iy„d I subty.d 

I sul^g^d I pkg.d 

I fjiskji I gen^d 

I excptn.d 1 gcnjnst 

I renaming„d 

I numbered 

I eaorV; 

objed^d : 

idents V fubty_ind .^ASN^cxpr. V 

I IdotlsV CONSTANT^TOKENsubty_lnd.J\SN.eai>r.V 
I idents':’ c_«nLdef.^ASNjexpr. 

I idents CC»1STANT.T0KEN c_«r^dcf ,_ASN_expr. ; 


SO 




number.d : 

idents V CONSTANT.TOKEN ASSIGNMENT expr V; 
idents : IDENTIFIER ...ident.; 
ty_d : 

full_ty_d 

I incoinplete_ty_d 
I priv_ty_d ; 

full_ty_d : 

TYPE.TOKEN IDENTIFIER IS TOKEN ty defV 
I TYPE_TOKENroENTIFIERdiscr_partIS_TOKENty_defV; 

ty_def : 

enum_ty_<tef I integer_ty_def 

I reaLty.def 18nay_ty_def 

• rec_ty_def I access_ty_def 

1 derivcd_ty_def; 

subiy_d : 

SUBTYPE^TOKEN IDENTIFIER IS_TOKEN subtyjnd V: 

subty.ind :ty_ink .constrt: 

tyjnk : expandeO; 

constn : 
mg_c 

I fltgjxrfnLc 

I ftxedjKunLc 

I aggr: 

derivedLty^def: NEW„TOKEN subiyJnd; 
ing_c ; RANGE^TOKEN mg {$$ := $2;}; 
mg : 

name (S$:«(form » nde, 

nodej BUILDJRANOBJ4AME ($I.nodoj));) 

I sira_eJtprDOUBLE.DOTsimjexpr( 

S$:«(form ■> nde, 

node_l-> BU1LD.RNO ($l.node_l, 

$3jH)dej));) ; 


enumjy_dcf 

'Cenumjiupec 

-xmiraJiLspcc.. T; 


enomJiLspec : enumJU; 


51 


enujnJit: IDENTIFIER I CHARACTERJ-ITERAL; 
in!ieger_ty_dfif: ing_c; 


reaLty.def : 

fltg_pdnt_c I fixc4_point;_c; 

fltgjxrinLc ; 

fitgjaccuracy.def jng_c.; 

fltg_«xuracy_clef : 

DIOITSJTOKEN siiu_exi>r; 

fixedj)olnt.c: 

fixedjccuiacy.def jng^c.; 

fixedjBccutacy (tef ; 

DELTA_TOKEN sim^expr; 

anay_ty_def : 

unciuitnxl.anay.defl c.an.def: 
uncnstind_anay.def: 

ARRAY.TOKEN X idx_subty.def ...idx.subly.def.. y OF.TOKBN 

subty.ind: 

cjan.def ; 

ARRAY.TOKEN idx_c OF.TOKBN subtyJnd; 
ldx.8ttbty.def i name RANOE.TOKEN BOX; 
idx_c : X dscumg ...dscrjng., y ; 
dscr.tng: 

mg (S$ > (form «> ndc. 

node.! -> BUILD.DESCRJRNG.I ($l.iK)de.l)); i 
I name rog_c($S:« (form i^nde, 

node.! -> BUILD.DESCRJINO.2 ($l.iu)dc.l, 
Slnode.O);): 


iec.ty.def: 

RE(X)RD.TOKEN 

empons 

END.TOKENRECORD.TCBCEN; 
empons: 

..prag.. ..empoTLd.. empon.d ..png., 
t ..prag» .xmpofLd. vaiianuwt ..pngM 
I 4Wfi-.NlJlJ^TOKBNV4«lg..; 

capoiud : 

tdenuVciiiq)oojwbty.def,_ASN.expr.V ; 


52 



cmpoiiL^ubtyjdef ; subtyjnd; 


disoLpart: 

'(' discr_^pec ...discr_ 3 )ec.. y ; 
disajspec : 

idents V ty_ink ,_ASN_expr.; 
variantjuit: 

CASE_TOKEN siin_n IS.TOKEN 
..prag.. variant ..variant. 

END.TOKEN CASE_TOKEN V; 

variant: 

WHEN.TOKEN choice .or_cholce„ ARROW 
cmpons; 

choice : sim.exi^ $$ :* $1;} 

I name mg_c ($$ :■ (form ■> nde, 

node_t -> BinLD_CHOICB_2 
($l.nodej, 

S2jiode_t));} 

I siniLexpr DOUBLE_DOT 3iin_6xpr 
{SS:>(form ac^nde, 
nodeJ -> BUILD.CHOICEJ 
(Sl.node.t 
S3.nodej));) 

I OTHERS_TOKEN S6Lotheia_true 
lentw; 

accessLty.def; ACXESS.TOKBN suUyJnd; 

incompletojy.d ; 

TYPE^TOKEN IDENTBPIBR 
I TYPE^TOKENmEhmi^discrjpartV ; 

dcdLpart: 

-teslc^tiecUtem.. 

t Mbasic.decUtcm.. body .iaia^decUtem..; 

basicjdedLhem: 
basic_d 

1 i^jcl I use.d; 

Uter^decUtcm: body 
I sub|)ig.d I pkgj) 

( lariLd 1 gen.d 

I use_cl I goUast : 

body : properjbody 


53 



I body_stub : 


proi)er_body : 

subprgjbody 
I pkgjbody 
I tadcjx)dy; 

name : siin_n {$$:« $1;} 

I CHARACIBRJJTERAL 
I (^^ymbol 
I idxe^cmpon {$$ :> $1;} 

I sekctedLcropon 
I attribute; 

sitQj) ODENrilMHR {S$ 

(fonn ■>nde, 

iK)de_t «> NAMBuTEMPLATB (YYText));) 

prefix : name {$$:>$!;); 

idxedLcmpon : 

pr^a£gr(SS> 

(fonii ionde, 

nodej «> INEffiK-COMP^TEMPLATE 
($lJK)de.t. 

sziKxkLO);); 

selectedLcmpon : prefix'.'selector ; 
selector : simjn 

I CHAIUOBIUJmRAL I opjsymbcd I AU^TOK^ 

attribute : prefix'"attributo.desigaator: 

attribute.designator; 
sinun 

I DIGITS^TOKEN 
I DBLTA.TOKEN 
I RANGfi_TOKEN; 

aggr: 

'C cmpoiuisc ..xmpoiutsc..')'{S$ > S2;); 

cmpocLUc 

ei^ (SS :«S1:} 

I choice .XNLchoice.. ARROW expr 
I tinLeiprD()UBL^JK)Tsiflt.t»^ 

I namenig^c; 

expr: 

nLAND^. (»>$!;} 


54 






I reLAND_THEN_jeL. {$$>=$1;} 

I reI..OILjeL. {$$:=$!;} 

I rcL.OILJLSE_rel„ {SS :=$!;} 

I xeI..XO^_jreL {$$:=$!;}; 


lel: 

sim_cjpr 4eIal_op__siin_exiff. {$$ ;= (fonn => nde, 

node_t => BUILDJffiL ($l.node_t, 
$2.nodc_t));} 

I sim_exprJJOT.IN_jiigjx_siin_exprJ^C)T.IN_tyjnk; 
simjexpr : 

.unaiy_add_op.tenn„binary_ad(Lop_tenn.. {$$;» $1;}; 


tenn : 6ctor..mulLop_factor.. {$$ := $1;}; 

factor : pri .^XP_pri. {$$:» $1;) 

I ABS_TOKENpri {$$:»$2;) 
INOT.TOKENpri {$$>$2;}: 


pri: 

numericJiteral {S$ :b (form >>n(le. 

node_t -> VALUE.TBMPLATC (YYText));) 
I NULL_TOKEN {$$;=:(foim =>nde, 
nodej»null):) 

I allocator 
i qualifiecLexpr 
t name |S$(form » nde. 

nodeJ ■> CHECKJPUNCnON (S1JJODB T, 
CUILTABLE. 

TAB.CXMJNTER));) 

I aggr($S:»$l;); 

rdal^op : 

I INEQUALITY 
I ’<’ 

I LBSS„THAN_ORJBQUAL 

I y 

I greateilthan^oilequal ; 

binaiy„add.q>: V ($$:«(fonn «>nde, 

nodcj «> (ADD^FAULT.TEMPLATB)):) 

I ($$:«i(fonn londe. 

nodej *> (SUBJFAULT^TOMPLATE));) 

I 

UMBy_add.q): V I v ; 

mulLop t**'|S$ :• (form -> nde, 

nodej»>nult);) 

I 7(J$»> (fonn •>nd^ 


55 



nodej => DIVISION^ Y_2ERO_TCMPLATE);} 

I MOD_TOKEN 
I REM.TOKEN; 


qualified.expn 

ty_mkaggr_or_tyjnkPexprP^; 


allocator: 

NEW_TOKENty_mk 
I MEW.TOKEN ty.mlc aggr 

I NEW_TOKEN tyjnk " aggr ; 

seq_of_8tmts: ..pag.. stmt .^L. 

{$$ := (forai *> nde, 

node^t*> STATEMENTS 
(SSJ^ODE.T, 
SZNODE^'D);): 


stmt: 

..label.. sim_stmt {$$ := S2;) 

I .JabeI..compoundLstmt (S$:>b$2;} 

I error ; 

siiiLStmt muILstmt ($$>$1;) 

I assignmenLstmt (S$ :■ $1;} 

lexit_stmt 

lretum_stmt 

lgoto_simt 

Idelay^stmt 

laboiijstmt 

I raisejmmlSS :«$!:) 

Icode^tmi 

(name';' 

{$S:»(forfn ■>1x16. 

nodcj«» BUILDJ»ROC_CALL 
($l.Rode„t. 
CUR.TABLE. 
TAB^COUNTER));) ; 


cotnpoundLsbm : 

ICamt (S$s»$l;) 

I case^iimi ($$;»SI;1 

f I(K^_$tmt iwi:«B$l;) 

I blo^stmt (SS:aSt:} 

i accqx^i^t 

I select^stmt: 

UtKl : LEFTJLABEL^BIUCKETsimjtRIOmjLABELjBRACKET ; 

nuUjstmt: NULL.TOKENV 

($S:«(foaQ M>ode.nodej«>(tull};); 


56 







assignmen^slmt: name ASSIGNMENT exprV 
{$$ := (fonn -> nde, nodeJ => ASSIONMENTJIEMPLATE 

(Slmode.t, 

$3j»ode_t));}; 


IF.TOKEN cond THEN.TOKEN 
sei.of_iStmts 

.JLSIF_cond_THEN__seqjof_jstmts.. 

•ELSE_scq_of_stmts. 

END.TOKEN IF.TOKEN V 

{$$:=(form *>nde,node_t->IF_STATBMENT_TEMPLATE 
($2juxkLt. 

$4jiode_t. 

$5.node_t, 

$6jiode_t));); 


cond : expr {$$ .*= SI;}; 
case_stmt‘ 

CASE_TOKEN expr IS.TOKEN 
casc_simt.alt.casc_s»jnt_alt. 

END^TOKEN CASE^TOKEN V 
secodienjalse 

(SS:»(fonn a> nde, nodej«» BinLDjCASE.STMT.TCMPLATC 
($2.nodc_t. 

$4jiode_t));); 


Gase_snnLaIt : 

WHEN.TOKEN choice ARROW 

soLoCstmts 

{$$:-(fonn •»ndc,W)dej«>BUa,D^CASEj;TMTjVLT 
(S2.node.i, 

$3.nodc„l, 

SS.noikLt, 

OTHERS^CHECK)); |; 


toop.sbnt: 

jlmjnC. 

iimtkMLscheme. LOOP.TOKEN 

se<uolLso«ts 

ENDJiOKBN LOOP^TOKBN .$im.n. V 
($$:«(foim ->nde.nodcj-o.BUILDJLOOPjSTMr 
(S2j)ode_l, $4j)odo.t));) ; 

ittraiion_schcme 

-.WHlLE^TOKENcoad 

iSSt-Obon ■>nde,i»dcj-i>BUILD„WHILEjn£RATIQN 

($ 2 j»odc^l));l 

tWHILE.TOK£Nemit 


57 




I FOR_TOKEN Ioop_pnn_iq)CC 

{$$ := (fwm *> nde, nodejt«> BUiLDJFORJlERATION ($2jiode_t)):} 
IFOILTOKENenor 

jinn_q)ec : 

IDENTIFIEK 

($$:B(fonn a>nde,iK)de_ta>NAMB_TEMPLA'IB(YYlEXI});} 

IN.TOKEN 

JIEVERSE 

dscr_ing 

{$$ :s (fonn «> nd« nodejt ■> BUILD_^OOPJ’RM_SPEC 

($2jiode_u $4jiode>_t, SSjiodej));} ; 


blocItLjStint: 

^_nC. 

J)ECLARE_decLpait. 

BEGIN.TOKEN 

scq„of_stmls 

JXCIEPTO'I_exci>in_haiuUer..cxcpliU>andlcr... 

END_TOKENjun_n.V 

($$:«• (forni >>nde,no(teja>BUILD^LOCK^STMr 
($IJ^ODE^T. 

$4J^ODE„T. 

S5JMODE.T));); 


exiLSdnt: 

EXTLTOKEN .capandcdLn, .WHm_coiul V; 

reuin\_strol: RETURN.TOKEN .exi*. V; 

goto^stml : GOTO.Tt)KEN«qpaJwkdj»V; 

sot^vgjl: subfKgjpecV ; 

subprg.^ : 

PROCEDURE.TOKEN 

IDEmiFlER 

|$S(form -> udo. nodu -> NAME.TEMPLATTIYYTEXT));) 
imLpwt 
(SS;«S3:) 

I FUNCnONJTOKEN 
designiior 
.fmljMttt 

RBTURN_TCaCEN 

ly^tnk 

(W:-$2;i: 

designator : IDENtP’IER 

{S$;«(ronn tt>iide.QO(k^:«>NA!^imO>U1E(YYmi3):) 


58 





q)_syinbol {$$:»$!;); 


op.symbol : STOINGJJTERAL 

{$S := (forni => nde, nodej => NAME.TEMPLATECmBXT));); 
fin^part: 

'C pnnJ 5 )cc „_.prnLq)cc..')’; 

prmj^ : 

idents':'inodctyjnk^ASN_.expr, ; 

mode : JN. I IN.TOKEN OUT_TOKEN I OUT.TOKEN; 

sut^ng_body : 

sub{^^)ec IS.TOKEN 
.dccljait 
BEGIN_TOKEN 
scq_of_slmts 

JEXCEPnON_exq)tn_handIcr..cxq)Ou,handlcr.- 
END_TOKEN .designator. V 
(ClBLTABLE(TAB_COUNTER)J>J!J'IAME 
RETURNJROOT_FAULT($lJ<ODE_T); 
CUILTABLE(TAB_COUNTER).STMT_m $ 5 J<ODE_T; 
TAB.COUNTER TAB.COUNTER + 1 ; 

$$:«$5;); 

pkg_d : pkg_ 5 pecV ; 
pkg.^pcc ; 

PACKAOE^TOKBN mENUFIER IS.TOKEN 
..hasIc.dccUtem.. 

J»lllVAm.basic.dscUtem-. 

END„TOKEN.siau». 1 


pkg.body ; 

package JOKBN BODV^-DKEN simji l$_TX)KEN 
.deeljJSTt 

.BEGB>I„s(^_<d!jftniisJSXCiBi^^I_^exc|)inJttwUer.4S3«|>mJ^^ 
END„TOKENJsiraj9.V ; 

T:Yt>E_TOKEN IDEI^IBR IS„TX)KfiN .LiM*lBD. PRIVATE^TOKEN V 
f TYPE_TOXEN txmmm. discuHit IS.TOKEN iiMHlD. WU VATE^TOKEN V; 

usejcl : USE.EOKEK eapaoded^e .jexpai^^ ; 

t ei)au;ing.d : 

idous ? lyjnk. RENAMES TOKEN name 
! idottsVEXCEPnONJTOKBN REN/UViES„TOKEN expanded^n V 
I PACKAGE.TOKENiDBNTTFIER RENAMESjIGKENejqjwdeO 
i 5ubf)r&ji»;!mNAMES.TDK£NtuttneV ; 


5? 





tasl(_d : tasltjqiecV ; 


task..^Kc : 

TASK.TOKEN .TYPE. IDENTIFIER 
JS.xnl_d^jqj)_cUEND.siinju 


task_body : 

TASK_TOKEN BODY.TOKEN sun_n IS.TOKEN 
.decljsait 
BEOIN.TOKEN 
seq_of_s!ints 

JEXCEPTION_«q)»n_handlcr..«u^>iiUu«d{iir.- 

END_TOKEN.suiu>/:‘: 

encd : 

ENTRY^TOKEN IDENTIFIER V 

I E^^mY_TOKENmENTIFlERT<lsaJT^gTimLpart. 

cm^call^scnt : 

..png., name; 


accf^stmt : 

ACCEPT„TX)KEN slm^n .PeaLidjtJ*..fmIj)a«. 

JX).^se<^of_5untOBND4iiTt.^ V; 

calWx :Mpr ; 

dcUy^sum : mAY^TOKENsirn^ciiJf*;*; 

;se4GC_wait 

I coodaLc(ii.c^ lia^ciujcall; 

Sclec.wiut: 

SELECT.-mKBN 

seiectjrit 

.-ORujsakxt_alt. 

JLSB_soi.of_swnts. 

END.TOKEN SSLEC1_T0ICEN V; 

sdecL»t( *. 

.WH£N__cadilARROWjeIec_w«io^ * 

Ge)ec.«aU^]gli ; acc«{3t_«li 
I dclay^ib I tctisuAaiejdt ; 

uccetiCtlt : 
delay JL& : 


60 



delay_stint.se^of_stmts. ; 


terminate_alt : TERH-Stmt ; 

cond 2 l_.«it_call: 

SELECT.TOKEN 

ent_call_stmt 

.seq_of_stints. 

ELSE_TOKEN 

seq_of_stmts 

END.TOKEN SELECr_TOKEN V; 

tiined_ent_call : 

SELECT_TOKEN 

ent_call_stmt 

.se<i_of_stmts. 

OR_TOKEN 

delay_alt 

END_TOKEN SELECT.TOKEN; 

abort_stmt: ABORT_TOKEN name ..jiame..; 

compilation :..compiIadon_unit.. 

{Code to print out the system table of proc and funct 
NEW.PAGE; 

NHW_LINE; 

if TAB.COUNTER • 1 > 0 then 

PUT ("The number of ptocedures/functions on die table are"); 
PUTCTAB^COUNTER -1, width «> 5); 

NEW_LINE(2); 

PUTJ-INE("'nie procedures/functions and their root faults on the table *): 
PUTJLINE("arethefoUowing: "); 

NEWJ-INE; 

for INDEX in l.,TAB„COU>rraR • 1 loop 
PUT_UINE(CUR_TABLE(INDEX).P_F_NAME); 
PUTJLINE(RE'rURNJlOOTJ5AULT(CUR^TABLE(INDEX)^TMrjPTO)): 
NEWJLINE; 
end loop: 

PUTJLINECAbove ore the procedures/functions and root faults.*); 
PUTJ.INE("- H t ♦ »*); 

else 

PUT_UINE(*There are no procedures defined within the input 
code. *); 

NEWJJNE(5); 
end if; 

•* Code to print out the exception table of exceptions 
NF.WJJNE(10); 

if EXCEPT^COUNTER -1 > 0 then 
PUT ("The number of exceptioas on the table are*); 


61 





PUT0EXCEPT_COUNTER -1. width => 5); 

NFW_iir^’l3(2); 

PUT J,INS("The exceptions and dieir root falults on the table"); 
PUTJ.INE("are the following: "); 

PUrjUINEC---■•); 

NEWJJNE; 

for INDEX in l.£XCEPT_COUNTER -1 loop 

PUTJJNE(EX_TAB(INDEX)£XCCEPTJJAME); 

PUTJLINE^TURN_ROOT_FAULT 

(EX_TAB{INDEX)£XCEPt3tR)); 

NEWJLINE; 
end loop; 

PUTJLINE(” Above are the exceptions and their root faults.”); 
else 

PUT_LINE("There are no defined exceptions within the input 
code."); 

NEWJJNE(5); 
end if;}; 

conipilation.unit ; 

contexLcl Ubraiy.unit (S$S2; 

- Procedure to print nodes to screen 
NEWJ>AGE; 

•niEE_TRAVERSAL($2>IODE_1); 

•• Procedure to create file for FTE interface 
TEXTJO.CREATEOTE^FILE. 
mode a> OUTJFILE, 
namor»"NEW_Fra"); 
CREATE_FILE($2.NODE_T. FIEJFUJB); 
TOXTJO.aOSB<FrELFILB); 

- Procedure to print text output for fto file 
NEWJ»AOE; 

FrB_HI^l(S2J40DE^T);} 

! comexi.cl secondary.unit; 

Ubraty.untt : 
subprg.d 
I pkg^d 
I gciud 
1 genjnsi 

1 subpriLbody ; 

secondary.uniL’ 

lihraty.tiniLbody I subunit; 

librury.unlLbody : 

pkg^bodyjorjtubpr^body ; 

contcxLcl ; -wiil\^cl..usc.cl«.; 


62 



with_cl : WITBLTOKEN simji ; 

body_stub : 

subprg_spec IS.TOKEN SEPARATE.TOKEN 
I PACKAGE.TOKEN BODY_TOKEN sim.n ISJIOKEN SEPARATB_TOKEN V 
I TASK^TOKENBODY_TOKENsim_n IS_TOKEN SEPARAIE.TOKEN; 

subunit : SEPARATE_TOKEN'Cexpanded_n*)'l5roper_body ; 

cxcpm.d : idents V EXCEPnON_TOKEN V: 

excptn_handlen 

WHEN_TOKEN excptn_choice ,.or_excptn_choice.. ARROW 
seq_of_stmts 

{$$:s3(fonn s>nde, node_t => BUILD_BXCEPnON 

($2J<ODE_T. $5^0DE_T)); 

EX_TAB(EXCEPT_<X)UNTER).EXCEPTJ^AME ;= 
RETURNJlOOT.FAULT(S2J^ODE_T): 
EX,TAB(EXCEPT_COUNTER)^CEPT_PTR ;« $5.NODE_T; 

EXCEPT.COUNTER ;= EXCEPT_COUNTER +1; ); 

excptn_choice : expanded.n {$$:»$];) 

I OTHERS.TOKENISS:»(form =>nde. 

nodej»>NAME_TEMPLATE(YYTEXT)):); 

raiscjstmt : RA1SE„TOKEN .apandc<Ln. V 
{SS:s!(fonn sondc, 

nodej ^ BUILDJIAISE($2J40DE„T});); 
gen>d : gcj\.spcc V ; 
gen_spec : 

gcn_fmJ_iWrt subprg^spec 
I gcnJmLpartpkgjspcc ; 

geu^finljiart K}ENERIQ.TOKEN ^gcnjjrm.d.. ; 

gcnjpnn„d : 

idenis V .IN.Oin'.. ty^mk ..ASN.exF- V 
I TYl»E_,TOKENlDEKriFmRIS.TX)KENgai^ty_dcfV 
I priv_ty_d 

I WrnLTOICEN5ubpi&jpcc.IS^X..V; 
gcajy.def: 

•('BOXT I RANGE.TOKENBOX I DIOITS.TOKEN BOX I DBLT\.TOKEN BOX 
1 inuyjy^def I acccssjy_dcf ; 

gcnjnst : 

PACKAGE.TOKEN IDENTIFIER IS_10KEN 


63 




NEW_TOKEN expanded_n .gen_act_part 
I HlOCEDURE_Jdcnt_JS_ 

NEWJTOKEN expandedji .gen_act_part 
I FUNCnON„TOKEN designator IS.TOKEN 
NEWJTOKEN expandedji .geiuacuait V ; 

geiiL.act_pan ; 

'C genjsc .«geimsc„ y ; 

gen_asc : 

4enJtnLpnnARROW.geiiijacU>nn; 

genJmijHm ; 

sitiLO I op_jymbol ; 

geiuacLpnn : 

exiHLor_namc_wj5ul^«g_it_orjenL«Uor_tyj^; 
rep_cl : 

tyjep_cl I addiess_cl; 

ty_wp_cl : length_cl 
I enumjrep.cl 
I iecjfep_d ; 

kflgih_cl : K)ILTOKBN««ributeUSE_TOKENsinLe*ptV; 
enurajrep^cl : 

F0R_ty..4nuu,USE_ aggr ; 

FOIUty„siirLn_USE^ 

RECORD^TOKEN jlgLd. 

..cmponLcl.. 

END_TOKENRECORD.TOKENV ; 
algLcl : AT.TOKEN MOD.TOKEN lim^expr V; 
cmpoi\.cl: 

name AT^TOKEN lim^cxpr RANOB^TOKEN ing ; 

»ddi«*.cl : FOILTOKENainutUSEJTOKENATJ^ ; 

code jtmi: iy_«lua:ji«*rV; 

: (SS :•> (fonn «» nde. 
tKide_t*>nuIl};) 

I .4»ai.pag: 

jrg,.^: 

I •('•ig-Mcs')’; 


64 





ai:g_ascs: 

argjasc 

I arg.ascs V arg_asc; 
._ASN_expr.; 

I ASSIGNMENT expr ; 


.Jdent. : 

I ...idenL.','IDENTIFIER ; 

xonstct : 

I consm ; 

expandedjn : 

IDENTlPffiR ($$:»(fonn -> nde, 

node .t => N AMB,TEMPLATE(YYI15XT));) 
I expandedLn V IDENTIFIER ; 

...tnuinJiLspec..; 

I ...enumJiLspec.. V 

enumJiL^icc; 


jng_c. : 

I nig^c : 

«4d3Lsub»w def.. : 

I -iU.subty_def.Vidxjsubty.act ; 

jmg..: 

I ..jlscrjug.. Vdscrjtjg ; 

..cmpon_d..; 

I .xrr^)OlUd..cunp(>u_d.{Wlg.. ; 

.jliscr.spcc..: 

f ..di^jspec.. V discf_^|>ec ; 

.vadtnt. : 

I ..vaiiaiu. vsriam : 

..or.cboice.; {SS(fwtn •> nde, 

»»odcJ»»>null); | 

t .or_cfaoice..TGttoice (SS;«(f(»m) »>nde, 

oode_i «> BUILD_OR_CHOICE ($1 jjodc i, 

Sijoodcjiy .); 

.ba^.ded.iienu : 

-pwg.. 

I J>ask:_dccUtem. baskjdecUteat .4)fag.: 


6S 



~later_decljtsfn.. ; 

..prag.. 

I .Jater_decUteni..Iater_decl_itein piag.. ; 

^xroponjBSC.. ; 

I ..xiuponjisc.. V cinpoQjasc; 


rel~AND_jrel.. : 

idAND^TOKENiel {S$.-=(fonn =>n(le. 

ncde_t ■> BUILD_PEL_AND ($1 juxb.t, 
$3.node_t)):) 

I rel..AND_|d..AND_TOKENicl j$$;-(fonn ->iide, 

nodO “> BUEJJJIHL^AND ($1 jiode.t, 
SSxodej));); 


rel..OIL_iel..: 

rclOILTOKENid {$$3«(fonn ->nde, 

nodd.i «> Bl)ILD_REL^.OR ($1 Jtode.t, 
S3.nodcj));) 

I id,.OR_Jct. ORjrOKEN le! (SS;s:(fonn ■>n(le, 

nodej ■> BUILD_REL_OR ($1 JK)de_t, 
S3.nodej));); 


rel..XOR^l. : 

I .XOR_jieL. : 

-XOILjtl.. : 

rdXOILTOKENtd 
I .XOIOel. XOILTOKEN wl; 

Wl.AND^TUSN^xel.. : 

idAND.TOKENTHEN^TOKENrel ($$:«(fonn «>n(Ie, 

nodcj •> BUtLD.REt.AND„THEN ($1 jjodej, 
$4.nodej});) 

I id-AND^THEN^jel,. AND_TX)KEN raEN.TOKEN rcl 

(S$ J* (fonn *> ndc, 

nodcj -> BUILD^REL^AND^THEN (Slxodc^l. 
S44aodcj0);); 


rel^OJCJBLSELjwl.: 

id(»LT(»C£NELS£_TOK£Ntel ($$:«(fonn 

nodej «> BUILD^REL^ORJELSB ($1 JWd«L!* 
$4.naJcj)):) 

I itL0iL.^i5B_«i.0Rjro!mNEi^m 
(SS:>(fofm aORde. 

nodeJ -> BUlLD^REL.OiLELSE (SI jlod(Ll. 
SdjQode.t));); 

j«laU9LJC>i<i.expr. : |SS:«(fonn e^odc. 

QodejB>iuiU);) 


66 



I reIal_op sira_expr {$$ := $2;); 


sira_exprJ^OT,IN_jng_or_sim_cxprJ^OT.IN_tyjTik: 
sim^expr J^OT. INJTOKEN mg; 

J^OT. : 

I NOT.TOKEN ; 

.iinaiy_add_op.tem..binary_add_op_tcnn..: 
tenn {$$:»$!;) 

I unaiy„add_op tom 

I .unaiy_add_q).tenii..binary_add_op_tenn.. 
binary_add_op Jenn {$$ :■ (form *=> nde, 

node_t »> ADD_SUB_TEMPLATE (Sl 4 »cde_t, 
S2.node_t, 

$3jiode_t));); 


factor.jnulLop_factor..; 
factor {$$ :*s$l:) 

I factor. jnulLop__£waor.. raulLop factor | S$ := (fwm => nde, 

nodcj «> DIV^MULT TCMPLATB 
($l.NODE T, 

$3J^ODE T. 

$2J^ODE.T));); 


I DOUBLE_STARpri; 

tyjnkaggr.or.ty^mldPaprP. ; 
prcfix-aggr; 

..sunt. : 

..prag.. (SS:*>S1;) 

I -stmt, sum .^jrag.. |$S:« (form e>iHle, 

nodej «> STATEMENTS (SI.NODE..T. 
SINODI^T));}; 


.labels ; 

I .Jabd.. label; 

JELSIF_cond_-THEN_se<u>Ls»nits., ; t$$>(fora aonde. 

nodcj •> null);} 

I -ELSJF^corm^THEN^scqjoCstrnts.. 

ELSIF^TOKEN cood TlffiN^TOKEN 
seq_oO&nts (SS:«(fonn »>nde, 

nodeJ «> ELSnLTEMPLATE(S3 JJodc^t 
SSjiodCjt 
$lJjod*Li));); 


67 



JELSE__seq_of_stmts.: {$$:=(fonn onde, 
node_t=>null);} 

1 ELSE.TOKEN 

scq_of_stmts {$$ := (form *> nde, 

node_t«>ELSE_TEMPLATE($2J»ode_t));); 


case_simLalt.case_stint_alt..: 

..pcag.. 

casc_stmt_alt 

..case_stmt_alL. 

{$5:)B(fonn ■>nde, 

node_t «> BUE,D.CASE_ALT_l_M0I!E($24Mxlc_t. 
$3.nodej));); 

..case^inn.a!t.: {$$ :• (form ■> nde, 

node_tB>nulI);) 

I ,.casej5anC.alt.. case^imLali ($$ :■ (fonn ■> nde, 

node_i => BUILD_CASE_ALT_0_M(»tE 
($l.nodej, 

Slnodcj)): 1; 


jimjiC: {S$ := (form »=> nde, 
nodej •> null);) 

I sim_nV |S$:»$1;); 

jimji.: 

1 simji; 

i(milon.^chemo.: {S$:M(fom) tondo, 
nodej »> null);) 

I iterailoiuscheine (S$ :«•$!;); 

JIEVERSB.: |SS;ai(fonn «>>itde, 

nodcjionuU):) 

I REVERSB_110KEN (S$:-(form ^>ndc. 

a)dej-> BUBJUtEVERSEJ^OIffi);); 

J)ECjLARE_dcc! 4 «ut : 

1 DEaARE^TOKEN 
decljait ; 

JBXGEPtI(]d4^6)U|)(A.^andla.x^^ : i $S > <fona *>> ode. 

oodej»(uilD;} 

I EXCEfTtONjnOKEN 
ekcp(n_hand)eri: 

cscpm^har.dkf ($S',«»$1;) 

( excpujumdktsexc^^ (SS (form »> nde, 

oodcj -> JOIN«BXCEPT10NS(S1 J«)DE.T. 
S1N0DE_D);); 


68 


.expandedji. ; {$$:=(fonn =onde, 

node_t=>null);) 

I expandedji {$$:=$!;}; 

.WHEN_cond. : 

I WHEN_TOKENcond; 

xxpr. : 

I ; 

AnLpart : 

I finLpart; 

«_.pnn_q)cc.. : 

I .wI»ni_^pec,.Vpnn,.S>cc ; 

JN. : 

I IN.TOKEN ; 

4lecl_pan. : decljiait; 

.designator. ; 
i designator ; 

JWUVATE..basic_decLltcin.„: 

( PRIVATB„TOKEN 
..basic_d«djtem..; 

3EOIN_^eq_oC8Unts.EXCEraON_mp(n_handlcr.<^^ 

» 

I BEOIN_TOKEN 
se<i_oL^ts 

£XCEfTION_.c«|)UL^aiullcr.usxcpinJjandlcr.^ 


UMITED. : 

I UMrreD_TOKEN ; 

-jCX|»ndod_n..: 

I ..xa|>u)dedju. VexpaodetU) ; 
.TY1>E.: 

I TyPE^TOKEN ; 

JS.xoL<J_..rep„cljEND.jlm n ; 

I IS.TOKEN 
..cnLd.. 

..rcp^cl.. 

ENDjmKEN4inu». ; 


69 



..ent_d.. : 

..prag.. 

I ..ent_i. ent_d „prag..; 

I ~rqp_cl.. rcp_cl ..prag.4 

J»enUdtJ».iniljjart.: 

•ftnljpart 

I '(’ensjdx ■)’jMljMiit ; 

JX)_jeq_of_stints_pND.sijnji„ : 

I DO^TOKEN 
scq_of_stints 
END_TOKEN .sim j». : 

„OR_j5elecLalL.; 

I ^OIOelecLalt.. OILTOKEN selecLialU 
.WHEN__con(lARROW,sdec_waiLall : 

sclec_wait_alt 

I WHEN^TOKEN cond ARROW sclec.waiualt ; 

accqjLstnit-s«l_oLscmts. : 

..prag.. accq}Cstint .seq_ofj^ts. : 

delay_ 5 iint.scq_of_stn«s. : 

..prag.. ddayjstmi .5e<i.of„sim{s.; 

TERM_sum : ..prag.. TERMINATE^TOKEN V .4wa8- ; 


.soLoCstmis.: 

..prag.. 

( s«l_oLsunts; 

..jnvno..: 

J ..jvunc..name ; 

.xompUal(on„uidL. 

.*prag.. 

t »corapilaiio(uunit. compikiio(L.uiiit .^irag..: 
pk^bodyjor_su&prg_body : pkg.!body ; 
_wUh_cL«sc*cl 

I wid).cl use_cls; 

uscjcls : 

-prag.. 

I u£e_clsuse.cl.^ag.. ; 


70 





I Vsimji; 


..orjBxq)in_^chdcc..; 

I ..or_exq>tit.choice.. T e3iq)tn_chcice; 

~gcn_pnnjL. : 

I ..gciu>rai_d« gen_pnn_d; 

JN.OUT.. : 

JN. 

I IN_TOKEN OUT_TOKEN; 

JS30X_4 
I IS.TOKENnamc 
I IS.TOKENBOX; 

PROCEDURE_J<lcm_IS_ : subprgj^xsc IS.TOKEN; 


.gen_acij)ar(, ; 
i g«^actjpait; 

-4CiLasc..: 

I ..^cn_asc..genjtsc; 

4caJinLpnnARR0W.gcn_acLpnn : 
gcn_acuin« 

f gcnLfaUjpnn ARROW gscij^nj^ ; 

: cxpr ; 


FOH_ty„sii»v,n_USE^ : 

FOiLTOKEN siau» USE.irOKEN; 


jdgLcl- : 

..prag.. 

I .4)r3g>.«lgLcl.4)ng- ; 

-cmpoo.cl.. : 

1 .xii^xiqjcl. aapoajd ; 
ty-^recjtSgr : qualllkdjupr ; 

%% 

with f«tiJLttec_geocraofi cncej>ack«ge. (nversejpltg; 
use {kuIi^oee.jcoeator.tiace4t^^ 

padugftpitfscris 


71 



procedine yypazse; 

echo ; boolean ;= fiilse; 
nuinber_of_emxs: natural0; 


end parser; 

with ada_tokens, ada_goto, adi^shiftjreduce, ad^Llex, adaLlex_dfa. textjo; 
use adaLtokens,ada_goto,ad^shiftjedttce,adaJex,adaJex_dfa.text„io; 
package body parser is 

package INTEGEILINOUT is new INTEGEILIO(INTEGER): 
use INTEGEILINOUT; 

pFOcedure yyerrar(s: in string:«‘syntax error”) is 
begin 

nuniber_of_eiTors :■ number^ofjenore +1; 
put(*«< ■); 

pm_Une(s); 
endyyeiTor, 


#i%procedure 4 iarse 


endparso; 


72 



B. AFLEX SPECIFICATION F3DLE 


------•/ 

“/* Lexical input for LEX for LALR(l)Giainmar for ANSI Ada */ 

-/• ♦/ 
Kftmian Fischer */ 

~/* Litton Data Systems *! 

~l* March 26.1984 •/ 


-/* Accampanies Public Domain YACC format Ada grammar 
-/* -- 


%STARTIDENTZ 


A 

B 

C 

D 

E 

F 

G 

H 

I 

J 

K 

L 

M 

N 

O 

P 

Q 

R 

S 

T 

U 

V 
W 
X 

Y 
Z 


taA] 

[bBl 

[cCJ 

[di>j 

(cE) 

[iFl 

IgO) 

(hHl 

fin 

on 

fkK] 

flL] 

fmMl 

m 

(oO) 

m 

m) 

m 

m 

ffT] 

fuUJ 

fvV) 

(wW) 

[xXJ 

fyY} 

liZJ 


%% 

(A) IBI lOJ {RI {T) I ECHO: ENIBRO); rcitanf ABORT.TOKEN);) 
IAMBUS) mm: Emma); ret«ni{ABS:.TOKEN);) 

{AMC) {Cl IB) IP) IT) (ECHO. EKTmOi: retum(ACCmjt>KBN);) 
I A) |C) ICJ (E}{S) m (ECHO; EmmO); rcturnfACCESS^TOKEN):) 
lAMDIL) lEOfO; ENTERaEftauttKALL.TOKEN);) 

{A){N)|Dj |ECHO;gm’ERa);rctu«KAND^TOKEN);) 

I AMR j |R) I A) (Y) {ECHO; ENTERfZ); retumfARRAY^lTOKEN):) 

I A) IT) lEaiO; ENTER(Z)i WmnfAT^TKCEN):) 

IBME) IG) UHNIfECHO; ENIBRfZ); «aum{BEGIN_TOiCEN);) 


73 





{B) JO) {D} {Y J {ECHO; ENTERfZ); i«um(30Dy_T0KEN),) 


fC) {AHS){E} {ECHO; ENTER©; retiini(CAS£ TOKEN);} 

{C} {0} IN) {SI {T} {A) {N} {T) {ECHO; ENTER©; retum(CONSTANT_TOKEN);} 
{D){E){C){L){A){R}{E} {ECHO;BNrim(Z);retiifn(DECLARE TOKEN);) 

{D) {E} {L) {A) {Y) {ECHO; ENT1R(Z); rett!ni(DELAY_TOKEN);} 

{D}{E) (L) {T) {A) {ECHO; ENTER<Z); rsttmCDELTA^TOKEN);) 
{D){I){G){I){T}{S} {ECHO;ENTER©;rstamOJIGITSJ'OKEN);) 

{D}{0} {ECHO; ENTER©; iBtum(DO_TOKEN);} 

{E) {L) {S) {E) {ECHO; ENTER©; reiuin(ELSB„TOKEN);) 

{E) {L){S) {I){F) {ECHO; ENTER©; retuni(ELSIF_TOKEN);} 

{E){N){D) {ECHO; ENTER©; retum(END_TOKENl);) 

{E) {N) {T) {R) {Y) {ECHO; ENTER©; rehini(BNTRY_TOKEN);) 

{E){X) {C) {E){P} {T) {I} {0}{N} {ECHO; ENTER©; retum(EXCEPnON_TOKEN);) 
{E){X){I){T} {ECHO; ENTER©; retunt(EXrr_TOKEN);) 


{F}iO}{R) {ECHO; ENTER©; retuni(FOILTOKEN);) 

{?) {U) {N) {C) {T) {!) {0) {N) {ECHO; ENTER©; rctum(FUNCnON_TOKEN);) 
{G) {£) {N}{E) {R}{I) {C) {ECHO; ENTER©; rctum(GENERlC_TOKEN);) 


{G){0) {T){0) {ECHO; ENTER©; retuni(GOTO_TOKEN);) 

{I)(F) {ECHO; ENTER©; retunj(IF_TOKEN);) 

{I)|N) {ECHO; ENTER©; rettim(IN_TOKEN):) 

{II {SI (E{:TI0; ENTER©; tetuii»aS^TOKEN);) 

{L){I){Mj{1}{T}{Ej(D) {ECHO;ENTER©;rctum(UMITED_TOKEN);) 
{Lj {O) (0) iP) {ECHO; ENTER©; retumO-OOP.TOKEN);) 

{M)(0){D) {ECHO, ENTER©; rttumCMOD.TOKEN);) 

{N){E)(W) {ECHO; ENTER©: rctum{NEW_TOKEN);) 

{N) {0| (T) {ECHO; ENT0i©; mum(NOT„TOKEN);) 

(N) {U) ILHt) {ECHO; ENTER©; ^^toaCNliLL^TOKEN);) 

{0)(F) {ECfiO; ENTER©; {«Mm(OF^TOKBN);) 

{0){R) {ECH0;evTER©;ii5tu*n{0R^Tt}KEN);) 

{0)(T){H){E){R{{S) (ECHO;ENTER©;mufn(OTHERSjrOKEN):) 


{ 0 ){U){T) (BCHO;FJ^TER©:n;Utfn<Qinr^TOKEN)i) 

{P)(A)|C) (K) IA){G){B) {ECHO;ENTER©;mum(PACKAOB^TOKEN);) 

{P){RJ(A)jG)|M)(A} {ECHO;ENTER©;r«uni(PRAOMA^TOKEN):) 

{Pj|R|{1)1 Vj{A)(T){E) (ECHO;ENTER©;r«um{PRIVATE„TOKEN):) 

IP) (R ) {0) |C) (E) ID) (U) {R) (B) {ECHO; ENTER©; rttum{PROCEDURE.TOKEN);j 
{R){A)(I)(S)|E) {ECHO; ENTER©; rc4uj«(RAlSE^T0KEN);) 

{R) {A| (N) (0) IE) {ECHO; ENTER©: i«um{RANGE_TOKEN):) 

|R}{E){C){0)(R|ID) {ECHO;ENTER©;rctttm{RJBCORD.-roKBN):) 

{R){E)(M) {ECHO; ENTER©; mitfiilREM.TOKEN):) 

(R) (E) (N) (A) (M) IE) (S) (ECHO; ENTER©; relum(RENAMES^TOKEN):) 

IR) IE) (T) {Uj |R| INHBCHO; ENTER©; rcium(RETURN_TOKEN):) 

{R) {E){ V) (E) (RHS) (E) {ECHO; ENTER©; tctum(REVERSE^TOKEN);) 

(S) |E) ID IE) (C) IT) (ECHO; ENTER©; n5ium(SELECrr_T0KEN); | 

IS) IE) {PH A) (R) I A) (T) (EHECKO; ENTER©; rtmm{SEPARATE_TOKEN);) 

{S) |UM B) (T) i Y) IP) {E| {ECHO; ENTER©: mian(SUBTyre^TX)KEN);| 

IT) {A) (S) (K) {ECHO; ENTER©: f«um(TASK^TOKEN);) 

IT) |E) (RUM) IMIN) (A)(T| lEHECHO; ENIERIZ); reium(TERMINATE«TX)iaEN);) 
|T|(H)(B)|N){ECHO; ENTER©; itturti(THEN_TOKEN);j 
{T)|y)(P)(E) {ECHO; ENTER©; mum(TYPE..TX)KEN);) 

(U)|S|{E) {ECHO; ENTER©; i«uifl(USE„TOKEN);} 

i WHH) (E) IN) (ECHO; ENTERfZ); «iura(WHEN_TC»iEN);) 


74 




{W} {H} {1} {L} {E} {ECHO; ENTER{Z); retum(WHILE_TOKEN);} 

{W} {1} {T} {H) {ECHO; ENTER(Z); retum(W]TH_TOKEN);} 

{X}{0}{R} {ECHO;ENTER(Z);i8tum(XOR TOKEN);) 

"=>" {ECHO; ENTERCZ); rctum(ARROW);} 
{ECHO;ENTER(Z);retum(DOUBLE_DOT);} 

"**" {ECHO;ENTER(Z'nretuni(r)OUBLE STAR);} 

•;*" {ECHO; ENTFRCZ); retum(ASSIGNMENT);} 

7*" {ECHO; ENTER(Z); reti£ni(INEQUALITY);} 

">=" {ECHO; ENTER(Z); rctum(GREAlER^THAN_OILEQUAL);} 

"<=" {ECHO; ENTER(Z); rctum(LESS_THAN_OR_EQUAL);} 

•«" {ECHO; ENTER(Z); retuni(LEFr_LABEL_BRACKET);} 

"»" {ECHO; ENTERCZ); retumCRIGHT.LABEL^RACKET);} 

-o" {ECHO; ENTERCZ); rcnunCBOX);) 

{ECHO; ENTERCZ); retumC&');) 

T {ECHO; ENTERCZ); retumCO:) 

T {ECHO; ENTERCIDENT); retumO');) 

{ECHO; ENTERCZ); retumC'*');} 

"+* {ECHO; ENTERCZ); retumC'+');) 

(ECHO; ENTERCZ); tetumC*,');) 

{ECHO; ENTERCZ); retumC’-');) 

{ECHO; ENTERCZ); retum('.');) 

T {ECHO; ENTERCZ); retumC/);} 

{ECHO; ENTERCZ); retumC:');) 

{ECHO; ENTERCZ); retumC';');} 

(ECHO; ENTERCZ); retunjC'<');) 

{ECHO; ENTERCZ): retuniC'=');) 

">" {ECHO; ENTERCZ): retumC‘>');} 

"I" (ECHO; ENTERCZ); rctumCT);} 

<IDEhrO»V {ECHO; ENTERCZ); retumC");) 

[a-z_A-Z][a-z,A-Z0-9]* {ECHO; ENTER(roENT);retum(IDENTIFIER);) 
[0-9][0-9J*({.K0-9J+)?C[EelW?[0-9J+)? { 

ECHO; ENTERCZ); 
retumCINTEGEI^LnERAL);) 

f0-9][0-9J7f[0-9a-fA-FJ-K[.][0-9a-fA-FJ+)?#C[Ee)[-+]?[0-9J+)? { 

ECHO; ENTERCZ); 
retum(INTEGER_LnERAL);) 

VCt^"]*C^^")*)*^" {ECHO: ENTERCZ); retumfSTRING.LnERAL);} 

<Z>VCnK\)\' (ECHO; ENTERCZ); retumCCHARACTERJJTERAL);} 

[ Nt] ECHO; ignore spaces and tabs 

ECHO; - ignore comments to end-of-line 

{ECHO; 

textJo.putJine("?? lexical error" & adajex_dfa.yytext & *??"); 
num_etrors := nuin_etTors +1;) 

[Nn] {ECHO:linenum;) 

%% 


73 





wiA ad^tokens; 
use ada_t(dcens; 
use texLio; 

package ada_lex is 

lines : positive := 1; 
nuin_crrors: natuial:» 0; 
procedure linenum; 
function yylex return token; 

end ada_lex; 

package body ada_I»( is 

procedure linenum is 
begin 

text_io.put(integer'image(Iincs) & 
lineslines +1; 
end linenum; 

## 

end adtLlex; 


76 



APPENDIX B: SOURCE CODE FOR TEMPLATE 
GENERATOR TOOL 


A. PACKAGE SPECIFICTION FOR FAULT TREE GENERATOR 

with TEXTJO, TRACE_PACKAGE; 
use TEXTJO. TRACE_PACKAGE; 

package FAULT_'niEsE_GENERATOR is 

package INTEGER_INOUT is new INTEGER JO(INTEGER); 
use INTliGER_INOUT; 

package BOOLEAN_INOUT is new ENUMERATIONJO(BOOLEAN); 
use BOOLEAN_INOUT; 

MAX_CHAR_LONG : INTEGER :=80: 

MAX_CHAR_SHORT : INTEGER := 10; 

MAX_ENTOY : INTEGER := 100; 


subtype GATE_TYPE is INTEGER range 0..2; 
subtype NODE_TYPE is INTEGER range 1..6; 


- Represents types of gates for fault tree 
NO.GATE : CONSTANT GATE.TYPE 0; 

AND.GATE : CONSTANT GATEJYPE := 1; 

OR^GATE : CONSTANT OATE_TYPE;= 2; 


~ Represents figures for fault tree 


RECTANGLE 

CIRCLE 

DIAMOND 

ELLIPSE 

HOUSE 

TRIANGLE 


: CONSTANT NODE.TYPE :=> 1; 
: CONSTANT NODE.TYPE := 2; 
: CONSTANT NODE.TYPE := 3; 
; CONSTANT NODE_TYPE:« 4; 
: CONSTANT NODE.TYPE ;= 5; 

: CONSTANT NODE.TYPE 6; 


Data structure to represent a node within fault tree 
type ST_LISTJ'IODE is private; 
type STJJSTJ40DEJ>TR is access ST_LIST_NODE; 

- Data structure to represent output locations 
type OUTPUT_LOCATION is private; 

type OUTPUTJ.OCATION_PTR is access OUTPUTJ-OCATION; 

- Data structure for system table reconis 
typeTABJBNTRY is 

record 

P_F_NAMB ;STRING(I..MAX;„CHARJLONO):-(OTHERS «>•'); 
STMT..P1R : STJJSTJ^ODEJTR; 


77 



end record: 


- Data structure representing system table 

type SYS.TABLE is ARRAY(1..MAX_ENTRY) of TAB3NTRY; 

~ Data structure for exception table records 
typeEXCEPT_PNTRYis 
record 

EXCEPTJ^AME : STRING(l..MAX_CHAILLONG) := (OTHERS =>' y, 
EXCEPT_PTR : STJJSTJ40DE_PTR; 
end record; 

- Data structure representing the excqition table 

type EXCEPT^TABLE is array (1„100) of EXCEPT JNTllY; 


-< Functions to access part of the data structure, due to private type 

function RETURN_CHILD (FIRST: ST_LISTJ^ODE_PTR) 
return ST_LIST_NODEJTll; 

function RETURN„CHILD_PREV (FIRST: STJJSTJ^ODEJTE) 
return ST_LIST_NODE_PTR; 

function RETURNJROOTJJAULT (FIRST: STJJSTJ^ODEJ>TR) 
return SHUNG; 

function RETURN,GATE_TYPE (FIRST: STJ-1STJI0DEJ>TO) 
return GATE.TYPE; 

function RETXJRN_NO_CHILDREN (FIRST: ST.UST_NODEJPTR) 
return NATURAL; 

function RETURN^NODE_TYPE (FIRST: ST_LIST_NODE_m) 
return NODB_TYPE; 

function RETURNJLCX)ORD (FIRST: STJ-ISTJMODEJTR) 
return INTEGER; 

function RETURN^Y.COORD (FIRST: ST_LISTJ^ODE_PTR) 
return INTEGER; 

function RETURN_START_L (FIRST: STJJSTJNODELPTR) 
return NATURAL; 

function RETTJRN.JNDJ- (FIRST: ST_LIST_NODEJ>TO) 
return NATURAL: 

function RETURNJ^JIAMB (FIRST; STJJSTJ40DEJTR) 
return STRING: 


78 






function RETURNJ^EL (FIRST: STJJSTJ<ODE_PTR) 
return SHUNG; 

~ Procedures to put values onto node structure 

onxedure PUSHJ.ABEL (FIRST : ST_UST_NODEJTll; 

LABEL : STRING); 

procedure PUSHJ^LEJ^ (FIRST : STJJST_NODEJ>TR; 

LABEL : STRING); 

procedure PUSH.X COORD (FIRST : STJJSTJ^ODEJTR; 

NUMBER : INTEGER); 

procedure PUSH_Y„COORD (FIRST : ST.UST NODE JTll; 

NUMBER : INTEGER); 

•• Procedures to print the values of the nodes 

procedure PRINT.NODE (NODE: in STJJSTJ^ODEJPTR); 

procedure PRINT.CHILDRENJMODES (NODE: in STJJSTJ40DEJTR); 

procedure PRINT_CHILDREN_OF_CHILDREN (NODE: in out ST_LISTJ^ODEJTR); 

procedure PRINT.CHILDREN_OF.CHILDRENJ»REVIOUS (NODE: in out 
ST_LIST_NODEJ>TR); 

Functions to build templates 

function NAME.TEMPLATB (ID: STRING) return STJ-IST_NODE_pTO; 

function VALUE^TEMPLATE (ID: STRING) return STJLISTJ^ODEJTR; 

function DIVISION_BY.JZERO_TEMPLATE return STJJSTJIODEJTR; 

function ADDJ^AULT.TEMPLATE return STJJSTJ^ODEJTR; 

function SUB^AULT.TEMPLATE return STJJSTJJODEJTR; 

fimetion ADD_SUB_TEMPLATE (FIRST, SECOND, THIRD; STJ.ISTJIODEJTR) 
return STJ.ISTJIODEJTR; 

fimetion DIV^MULT.TBMPLATE (FIRST, SECOND, THIRD: STJJST_NODEJ>TR) 
return STJ.ISTJ^ODEJTR; 

function INDEX_COMP_TEMPLATB (FIRST, SECOND; STJ,lST^NODEJTR) 
return STJLISTJNODEJTR; 


79 






function ASSIGNMENT.TEMPLATE (FIRST, SECOND: STJ,ISTJJODE_FIR) 
return STJ.ISTJ^ODE_Pm; 

function IF_STATEMENT_TEMPLATE (FIRST, SECOND, THIRD, FOURTH: 

STJ-IST_NODEJ>TR) 
return STJ-IST_NODEJTR; 

function ELSIF.TEMPLATE (FIRST. SECOND. THIRD; STJ,ISTJ^ODEjnil) 
return ST_LISTJJODEJ>TR; 

function ELSE_TEMPLATE (FIRST: STJJSTJ^ODEJTR) 
return ST.LISTJ^ODEJTR; 

function STATEMENTS (FIRST, SECOND: ST_LISTJJODEJ>TR) 
return STJ-ISTJMODE.PTR; 

function BUILD_REL (FIRST, SECOND: ST_LISTJJODEJTE) 
return ST.LIST.NODE.PTO; 

function BUILD_REL_AND (FIRST. SECOND; STJL4STJ^ODE_m) 
return ST.LIST^NODE.PTO; 

function BUILD JIEL.OR (FIRST. SECOND: ST_LIST_NODE_PTR) 
return ST_LISTJ^ODE_Pm; 

function BUILDJREI^AND_THEN (FIRST, SECOND: ST_LISTJ^ODE 
return ST_LISTJ^ODE_m; 

function BLBLD JlEL_OR_ELSE (FIRST, SECOND: STJ.ISTJ^ODEJ>TR) 
return STJ-ISTJ^ODE_PTR; 

function BUILD^RANGE_NAME (FIRST: ST_LISTJ^ODE_PTO) 
return ST_UISTJ^ODEJ>TR; 

function BUILD_RNO (FIRST. SECOND: ST_LISTJJODEJTO) 
return STJ,IST_NODE_PTR: 

function BUILD_DESCR_RNG_1 (FIRST: ST_USTJ>lODEJ>TR) 
return STJ-ISTJMODEJ>TO; 

function BUILD J)BSCR^RNG_2 (FIRST, SECOND: STJLISTJ^ODE JTE) 
return STJ-ISTJ^ODEJPTO; 

function BUILDJIEVERSBJ^ODB 
return STJ-ISTJ^ODEJ>TO; 

function BUlLDJLOOPJ»RK.SPEC (FIRST, SECOND, THIRD: STJJSTJ^ODEJ>TR) 
return STJ,ISTJ40DEJPTR; 

function BmLDJFORJTERATION (FIRST; STJ-ISTJiODBJ’TO) 


80 





return STJ.ISTJ<ODE_Pni; 


function BUILD_WHILEJTERATION (FIRST: STJ.ISTJ>IODEJTR) 
return STJ.ISTJ^ODEJTR; 

function BUILD_EOOP_STMT (FIRST. SECOND: STJ-ISTJJODE_m) 
return STJ-IST_NODE_PTR; 

function BUILD_CASE_STMT_TCMPLATE (FIRST. SECOND; STJ.ISTJJODEJ»m) 
return STJ.IST_NODEJTR; 

function BUILD_CASE_ALT_l_MORE (FIRST. SECOND: STJJSTJ^ODEJTR) 
return ST_LISTJ^ODE_Pni; 

function BUILD_CASE_ALT_0_MORE (FIRST. SECOND; STJJSTJMODEJ>TR) 
return STJLIST_NODE_Pni: 

function BUILD_CASE_STMT_ALT (FIRST, 

SECOND, 

THIRD ; ST_LIST_NODE_PTO: 

OTHERS_CHK : BOOLEAN) 
return ST_LIST_NODE_PTR: 

function BUILD.OR^CHOICE (FIRST, SECOND: STJ.ISTJIODEJ>TR) 
return ST_LIST_NODE_PTR; 

fiincUon BUILD^CHOICEJl (FIRST. SECOND: ST_LIST_>IODBJTIR) 
return ST_LIST„NODE_PTR; 

function BUILD„CHOICEL3 (FIRST, SECOND: STJ.1STJ^0DEJTIR) 
return ST_L1STJ^0DEJ>TR; 

function BUILD J»ROC_CALL (FIRST : STJLISTJ^ODE_pm; 

TABLE :SYS_TABLE; 

COUNTER; INTEGER) 
return STJ.IST_NODE.Fm; 

function BUILD^LOCiC.STMT (FIRST ; ST.LISTJ40DEJ>TR; 

SECOND : STJLIST.NODE.Fm; 

THIRD : ST.LIST_NODE JTR) 
return STJLIST_NODE_PTR; 

function JOIN JBXCEFnONS (FIRST : ST USTJIODE J>TR; 

SECOND : STJ.ISTJlODEJ>m) 
return ST_LIST_NODE J>TO; 

function BUILDJSXCEFnON (FIRST : ST_JJSTJIODEJ>TO; 

SECOND : ST_LISTJIODE PTO) 
return ST_LISTJIODEJ>TO; 

function CHECKJ^UNCnON (FIRST ; STJ.IST_NODEJ>m; 


81 



TABLE :SYS_TABLE; 

CX)UNTER: INTEGER) 
return STJJSTJ^ODEJTR; 

function BUILDJIAISE (FIRST : STJJSTJ^ODEJ>TR) 
return STJ.ISTJMODEJ>TR; 

function CHEOLEXCEPT (FIRST : STJ-ISTJ^ODEJTR; 

EX_TAB : EXCEPT.TABLE; 

EXCEPT.COUNTER: INTEGER) 
return STJ-ISTJ40DEJTR; 


pivate 

typeSTJJSTJ^ODBis 

record 

ST NODE LABEL : STRING(L.MAX^CHAR.SHORT):»(others => ’'); 
ROOTJFAULT : STRINQ(l..MAX_CHAIU-ONG) .•» (others =>' ■); 
FILE.NAME : STRING(l..MAX_CHAR^LONG) :* (others-> "); 
START.LINE : NATURAL :=0: 

END LINE : NATURAL ;=0; 

X.COORDINATE : INTEGER :»=0; 

Y_CXX)RDINATE : INTEGER :»0: 

TYPE.NODE : NODE^TYPE ral; 

TYRE.GATE : OATE_TYPE :»0; 

NUMBER„OF„CHILDREN : NATURAL :««0; 

PREV.ST_PTR : STJ.IST^NODE_PTR :«NULL; 
CHILDREN.NODES : STJLISTJ^ODBJPTR :»NULL; 
OUTTUTJPLAO : BOOLEAN ;«FALSE; 

end record; 

type OUTPUTJ-OCATTON is 
record 

OUTPUTJ-ABEL : STRING(1..MAX„CHA1UjONO) :«(others ■> "); 
OUTPUTJ.INE : NATURAL 0; 

OUTPUT^ST^START^NODB ; ST„USTJ40DEJ>TR :«NULL; 
PREV.OUTPUTJLOCATTON ; OUTPUTJ,OCATTONJ>TR •.■»NULL; 

NBXT.OUTPUTJ.OCATTON : OUTPUTJOCATTONJ>TE t-NULL; 

end record: 

end FAULT_TREE_OENERATOR; 


82 






B. PACKAGE BODY FOR FAUI.T TREE GENERATOR 


package body FAULT.lIlEEjGENERATOR is 

~ Function to return child to other package for visibility 

function RETURN.CHILD (FIRST: STJJSTJIODEJTR) 
return ST J.IST_bIODE_PIR is 

TEMP : STJ-ISTJ^ODEJTR; 

begin - RETURN CSDLD 

TEMP:« FIRST.CHILDREN_NODES; 

RETURN TEMP; 

endRETURN.CHCLD; 

- Function to return child piev to other package for visibility 

funcUon RETURN_CHILD_PRE V (FIRST: STJJST_NODEJ>TR) 
return ST_LIST_NODEJPTR is 

TEMP : ST„USTJ40DE,PTll: 

begin - RETURN CHILD PREV 

TEMP FIRST.PREV.STJTR; 

RETURN TEMP. 

end RETURN_CHILDJ>REV; 

" Function to return root fault to other package for visibility 

function RETURN.ROOTJJAULT (FIRST: STJLIST_NODE_PTR) 
jetuitr STRING is 

begin - RETTJRN ROOT FAULT 

RETURN FmSTJtOOTJPAULP, 

end RETLJRNJIOOTJJAULT; 

~ Function to return gate type to other package for visibility 

function RBTURN.G ATB_TYPB (FIRST: STJJSTJiODEJTR) 
return OAlE.TYre is 


83 







begin - RETURN GATE TYPE 
RETURN FIRST.TYPE.GATE; 
end RETURN.GA1E_TYPE; 


-- Function to letum number of children to other package for visibility 

function RETURNJ^O_CHILDREN (FIRST: STJJSTJ<ODEJ»TO) 
leturo NATURAL is 

begin - RETURN NO CHILDREN 
RETURN FIRSTNUMBER_OF_CHILDREN; 

end RETURN J^O.CHILDREN; 

~ Function to itticn node type to other package for visibility 

function RETURNJ^ODE_TYPE (FIRST: ST_LIST_NODEJPTR) 
return NODE.TYPE is 

begin ~ RETURN NODE^TYffi 
RETURN FIRST.TYPE.NODE; 

end RBTURN_NODE.TYPE; 

- Function to return x coordinate to other package for visiblliiy 

function RETURN^X.COORD (FIRST: STJJSTJ^ODEJTR) 
mum INTEGER is 

begin - RETURN X.COORDINATB 
RETURN PIRST.X.COORDlNA'm; 

end RETURN JLCOORD; 

Function to return y coordinate to other package for visibility 

function RETURN_V.CX)ORD (FIRST: STJJSTJdODEJTll) 
return INTEGER is 

begin ~ RETURN Y COORDINATE 


84 






RETURN FIRST.Y_COORDINAra; 


end EETURN_Y_CCX)RD; 


Function to return node type to other package for visibiliQr 

function RETURN.STARTJ. (FIRST: ST.USTJIODEJ>TR) 
return NATURAL is 

begin -RETURNSTARTL 
RETURN FIRST.STARTJLINE; 

end RETURN_START_U 

- Function to return end line to other package for visibility 

function RETURN..ENDJL (FIRST: STJ-ISTJ^ODEJPTO) 
return NATURAL, is 

begin - RETURN ENDL 
RETURN F1RST£ND_LINE; 

endRETURN^DJ-; 

- Function to return file name to other package for visibility 

function RBTURNJPILE„NAME (FIRST; STJLiST^NODEjPTR) 
return STRING is 

begin -RETURN FOE NAME 
RETURN F1RST.FILE J^AMB; 

end RETURN_FILFJ'IAME; 

- Function to reiuro label to otho’ package for visibility 

function RETURN^LABEL (FIRST: STJJSTJ^ODEjTR) 
return STRING is 

begin - RETURN LABEL 
RETURN FIRST.STJ'IODEJ-ABEU 


85 



endRETURNJLABEU 


- Procedure to push label into data structure 
procedure PUSILLABEL (FIRST : STJJST_NOjDEJTR; 
LABEL : STRING) is 

begin 

FIRST.STJ^ODEJLABEL<LABEL‘iangc)LABEL; 
fiiidPUSILLABEL; 


~ Procedure to push file natne into data stnicnue 
procedure PUSH_FILE_N (FIRST : STJJSTJNODEJTR; 
LABEL : STRING) is 

begin 

FIRSTJILBJ^AMEO-ABEL-rangc) LABEL; 
cndPUSHJPILB.N; 


» Procedure to push x coordinate into data stntctme 
prtxedure PUSH_X_COORD (FIRST : STJJSTJ<lODEJPTR; 
NUMBER : INTEGER) is 

begin 

FIRSTXCOORDINATB > NUMBER; 
codPUSILX.CXX)RD; 


- Procedure to push y coordinate into data structure 
procedure PU$H^Y„CXX)RD (FIRST : ST.1JSTJNODEJPTR; 
NUMBER ;imEGER)is 

b^ln 

FIRST. Y_CXX)RDINA‘reNUMBER; 
eadPUSH.V_(X)ORD; 


- Procedure to print the values of a node 

procedure PRINTJ<ODB (NODE: ia STJJSTJJODEJPTR) is 


86 










begin-PRINTNODE 

if NODE NULL then 
new_line (2); 

put_line ("Printing values of current node. "); 
put CST_NODEJ,ABEL :"); 
put.Iine (NODE.STJJODE_LABEL); 
put ("ROOT^PAULT : *); 
put_line (NODE JlOOTJ’AUL'n; 
put ("FILE.NAME ;"); 
put line(NODEmE_NAME); 
put ("START.UNE :"); 
put (NODESTARTJJNE): 
new line; 

put ("END.LINE :"); 
put (NODE.END,LINE); 
new line; 

put ("X.COORDINATE : “}; 
put (NODEX_COOSDINA'Il); 
new^Unc; 

put (“Y-COORDINATE : "i; 
put (NODEY,COORDINATE); 
new Une; 

put (TYPB^NODE ;"); 
put (NODETYPE„NODE); 
ncw_line: 

pot ("TYPE^GATB :"); 
put (NODETYPE.OATC); 
ncw^linc; 

pot (•rWMBER..OF..CHILDREN:"); 
pot (NODENUbiBEILOF.CHlLDREN); 
new^Une; 

pul (*OUrPOT_FLAG : *): 
put (NODEOUWrj=LAG); 
ncw„Unc(2); 
else 

ncw^Ijnc(2); 

puisne ("No iU>d3pri{U&(L the value is null *); 
ftcw_tiiiic: 
end if; 


e3ulPiUNT>‘ODE; 


- Ptoceduie to print the values of the children nodes 
procedure PRINT^CHILDRENJ^ODBS (NODE: in STJJSt-NOI«jmi) is 
NEXT ; STJJST.NCHJEjrrR; 
begin - PfUNTCHEHREN NODES 


87 





if NODE = NULL then 
NEWJLINE; 

PUT_LINE("No valfie for node passed in, value=null."); 
NEWJ.INE; 
else 

NEWJLINE(2); 

PUT^lNErinsidc PRINT OffiLDRBN NODES preoedise. *“): 
PUT_LINE{"Th9 paresa node is the '); 

NEWJJNl: 

PRlHt,NODB(NOOE>: 

NEWj.lHE; 

PLXLIN^'lrfegelaidisaiK«tesac as follows: y, 

if NOM-CtfJt»REN_NODES = NULL then 
R'rjJNEf^'o children nodes the vahffi is null 
else 

n?INr „NOrja(NODE.CilILDREN_NODBS); 

N&Xr h'aDS.C3BLDRSNJ^E®SJ?R£V,STjn'R; 

%hae NEXT h null loop 
HliNT^NODSfKEXT); 
hmXT > NBXTJREV_ST_PTR; 
end loop; 
cad if; 

NEWJ.INE; 

Pirr_LlNErit« above sad/asneUechUdnat nodes. *); 
endif; 


ojd PRim’^CHILDREhLNOEmS; 


—~ .— ... . — ■. ■ 

•> PincKodui^ to priM the values of the children of childit^ nodes 

piocetfore PiUNT_CHILDREN^OF_,CHJLI)REN (NODE: in out STJLIST_NOD2J*tTi) is 

NEXT : STJJSTJdODBJ»m; 

TEhiP : ST„UST.NODE_Pm:« NODE; 

begin *• PRINT CHILDREN OP CHILDREN 

- This will advance dtepointer to tlKchiM of the node passed in 
if NODS/* NULL then 
NODENODE.<mDiRENJ^ODES; 
else 

Pin'_LlNE(Trhercisoochildoftheoodc. *); 
endif; 

ifNODE* NULL then 
NEWSLINE; 

PtJTjLlNE{*No value foroode passed in, value * noli 
NEWJLINE; 


88 



else 

NEW_L1NE(2); 

PUT_LINE("Inside PRINT CHILDREN OF CHILDREN NODES procedure. "); 
PUrj-INECTlie parent node is the following: *); 

NEWJ.INE: 

PRINT_NODE(NODE); 

NEWJ.INE; 

PUTJ-INECThe children nodes are as follows: "): 

NEWJLINE; 

if NODE.CHILDREN_NODES = NULL then 
PUT_LINE("No children nodes the value is nuU "); 
else 

PRINT_NODE(NODE.CHILDREN_NODES); 

NEXT := N0DE.CH1LDRENJI0DESPREV_ST_PTR; 
while NEXT /» null loop 
PRINTJ40DE(NEXD; 

NEXT := NEXTi>REV_ST_PTR; 
end loop; 
end if; 

NEW_L1NE; 

PUT_LINE("The above nodes are the tdaldren nodes. "); 

NODE;*TEMP; 
end if: 

end PaiNT>CHILDREN.OF.CHlLDREN; 


Piocedine to prim the values of the diildren jwevious of ciiildren nodes 

proocdure miNllCHILDRBN„(^^CHILDREN J»RE VIOUS (NODE: in out 
STJLISTJ^DBJ>TK)i5 

NEXT : STJLISTJIODB^PTR; 

TENIP :S’CUSt;^OPB„m:<*NODE; 

begin -HUhTTCimjKIlENOFailLDRENPR^ 

>• this will advance the pointer to the child die node passed in 
if NODE/-NULL then 

NODE:« NODE^CHILDRENJ^ODES J»REV_STJPTR; 
else 

Pirr.L!NB("Tbsre is not* second child. •); 
end if; 

ifNODE-NULL then 
NEWJLINE; 

PUT.L!h£(*No value for node pa^ in. v^ ■ null. '0; 

NEWJLINE; 

else 

NBWJL1NE(2); 

iVrjJNE(“lmidc PRINT CimjJREN OP (mDRENJ>RE\aOUSNOI^proce^ •); 


S9 






PUT J-INECThe parent node is the following: "); 

NEWJLINE: 

PRINTJ40DE(N0DE); 

NEWJ-INE; 

PUTJLINECnie children nodes are as follows: "); 
NEWJ-INE; 

if NODE.anLDRENJ^ODES = NULL then 
PUTJJNE("No children nodes the value is null ”); 
else 

PftINT_>IODE(NODE.CHILDRENJ40DES); 

NEXTNODE.CHILDRENJJODESJ»REV STJ>TR; 
while NEXT/= null loop 
PRINTJ^ODE(NEXT); 

NEXT :* NEXrj>REV_ST J>TR; 
end Io(^; 
end if; 

NEWJLINE; 

PUT.LINECThe above nodes are the children nodes. ''}; 
NODE:* TEMP, 
end if; 

end PiUOT_CHlLDREN.OE_CH!LDREN.PREVIOUS; 


» Function to create node for a name 

function NAME.l'EMPLATE (ID: STRING) retuin STJL1STJ40DE_PTR is 

TEMP : ST,USTJNODE_pm; 

begin - NAMELTEMPLATE 

TEMP :-newSTJJST„NODB; 

TBMPJlOOTJJAULTODVaage);« H); 
return TEMP; 

endNAME^TEMPLATB; 


~ Pundion to create node for a value 

function VALUE_TEMPLATE (ID: STRING) retain STJLISTJ^ODEJPTR is 

TEMP : STJLISTJJODEJTR; 

begin - VAI.UE-.TEMPLATE 

TEMP ;-ncwSTJJST.NOi:ffi; 

TEMP’ROOTjPAULTflDhage) :• ID; 
return TEMP, 


90 



end VALUE.TEMPLATE; 


- Function to build node for division bj* zero 

function DIVISION_BY_2ERO_'IEMH-ATE return STJJSTJ^ODE_PTR is 

TCMP : ST_UST_NODEJ>TR; 

TEMP.S’IR : STWNG (l.:i3):»"Division By Zero Fault 

begin ~ DIVISION BY ZERO TEMPLATE 

TEMP := new STJ-IST_NODE: 

TEMP.ROOT_FAULT(IEMP STRTange) := TEMP^STR; 
lEMP.TYPEJIODB .-•RECTANGLE; 

return TEMP; 

end DIVISION_BY_ZERO_TEMPLATE; 


» Function to build node for aditing fault 

function ADD«FAULT_TEMPLATE retuni ST.UST_NODEJTR is 

TEMP : ST^USTJNODE^PTO; 

TEMP_STR ;STRINGa.l5):»"AdditionFault"; 

begin -^ADDITK^ FAULT TEMPLATE 

TEMP ;«newSTa.lST^NODE; 

TEMPJROOT_PAULTaEMP„STR'rsinge)TEMP.STR; 
TBMP.TYPEJ^ODB i- RECTANGLE; 

return TEMP: 

end ADDJ^AULT^TEMPLAIE; 


~ friction to buiM node for subtracting fault 

function SUB J^AULT^TEMPLATE rotutn STJUSTJ^ODE JTR is 

TEMP ; STJL1ST^N0DE.PIR; 

TEMP.STR : STTUNO (l.,I8)"Subtraction FauU 

begin - SUBTRACTION FAULT TEMPLATE 

TEMP ;*ncwSTJLISTJNODE: 

TEMPROOTJPAUtTOEMPJSTRrangc):» TEMP.STR; 
TEMP.TYPE.NODE RECTANGLE; 

leturoTEMP; 


91 




end SUB_FAULT_TEMPLATE; 


- Function to build node for adding or subtracting 

function ADD_SUB_1EMPLA'nB (FIRST. SECOND. THIRD: ST_LISTJ^IODE_m) 
return STJ-ISTJ^ODEJTR is 

TEMP : STJLIST_NODE_PTR; 

TCMP.STR ; STRING(1^27) := "Addition/Subtraction Fault 

begin ~ ADD SUB TEMPLATE 

TEMP :» new ST_LISTJ^ODE; 

TEMPJlOOT_FAULT(TEMP^STTl'range) :-TEMP^STR; 

TEMPMIMBEILOF.CHILDREN := 3; 

TEMP.TYPE_GATE toQILOATE; 

TEMP.CHILDREN.NODES :»FIRST, 

TEMP.CKILDREN_NODESi«EVJSTJTR SECOND; 

TEMP.CHILDRENJ^ODESi>REV„ST_PnLPREV_STJPTO:» TinRD; 
return TEMP; 

end ADD^SUB.TEMPLATE; 


•'Function to build node for division 

function DlVJdULT^TEMR ATE (FKST. SECOND, THIRD: STJJSTJNODfiJPTR) 
rcium STOdST^NODEJPTR is 

TEMP ; ST UST_NODE_PTR: 

TEMP.STR : ST1UNO(1..32):»•Division / MuliipUcaiion FauU 

begin -DIV MULTTEMPLATE 

TEMP new ST„LISTJ^ODE; 

TEMPROOTJJAULT(TEMP_STR‘fangc) :-TEMP.S1R; 

TEMP.NUMBER_OF^CHlLDREN 3; 

TENiP.TYPE.GATE :-OR^GATE: 

TEMP.CHILDRBN.NODES :* FIRST. 

TEMP.CHILDRBN NODES,PREV_ST_m :• SECOND; 

TEMP.CmiDRENJ^ODES J>RBV_STJ>TTlJ1lBV^ST.mTHIRD; 

return TEMP: 

end DIVJdULT.TEMPLATE; 


•• Fiu»aioQ to build node for an index (»nponeoi 

function INDEX_C0MP.TEMPLA1E (FIRST, SECOND; STJJSTJ«)DEJPTO) 


92 







retura STJ-ISTJfODE_Fni is 


TEMP : STJJST_NODE_PTR; 

TEMP_S'ni : STRING(l^) 3* "Indexed Component Fault 

begin - INDEX COMPONENT TEMPLATE 

TEMP .•= new ST J.ISTJ>IODE; 

TEMPAOOTJJAULTOEMP^STE'iange) :«TEMP_STR; 
TEMPJ^UMBEILOF.CHILDREN :»2; 

TEMP.TYPE.GATE :«OR_GATE; 

TEMP.CHILDREN_NODES :«FIRST; 

TEMP.CffiLDREN_NODESJ»REVjSTJ»TR := SECOND; 

return TEMP; 

end INDEX_COMP„TEMPLATE; 


- Function to build a node for an assignment statement 

function ASSIGNMENT^TEMPLATE (FIRST, SECOND; STJUSTJ<ODEJ=TR) 
return STJJSTJJODEJPTR is 

TEMP : STJJSTJNODB^PTR; 

TEMP.CHANGE : STJ-IST^NODE^PTR: 

TEMP^CEPT ; ST^LISTJ^ODEJPTR; 

TEMP.OPJSVAL :STJL1STJ'I0DBJTR; 

TEMP^TR : STRINO(l .^7)"Assignment Stiicmcni Fault 
TBMP^CHANGB STR : STRING(I..30);«‘Change in values caused Fault"; 
TEMP^CEPCSTR : STRING(I..42);«"Exception causes Fault - Not implemented 
TEMP_OP^EVAL.STR: STRiNO(l-32)"Opeiand Evaluation causes FauU “; 

begin ~ ASSlGNMEhTT TEMPLATE 

Creating Change in values Node 

TEMP.CHANGE :« new ST_UST_NODE; 

TEMP_CHANOE.ROOT ..FAULTCrEMP_CMANGE„STRVangc) :• 1BMP^C31ANGE_STR; 
TEMP_CHANGETYPE>NODE t-RECTANGlE; 

- Creating ExcqHion Node 

TEMPJEXCEPT t- new STJUSTjNODE; 

TBMP^EXCEPT,ROOT^FAULTXlEMP^C^.STRTningc) t.TEMP^CEPTjSlR; 
TEMP^OIANOETYPfiJ^ODE > RECTANGLE; 

- Creating C^peration Evaluatioa Node 

TEMP^OP^VAL :« new STJUSTJNODE; 

TEMPjOPjEVALROOTJ’AULTClEi^.OPJBVALjSTH^e) :• 

TEMP^OPjEVALjSTR; 


93 




if FIRST A= NULL and SECOND/= NULL then 
TEMP.OP.EVAL^IUMBEILOF^CHILDREN :=2; 

TEMP_OP_EVAL.TYPE_GATE := OE^GATE; 

■IEMP_OP_EVAL.CHILDREN_NODES := FIRST; 

TEMP_OP_EVAL.CHILDREN_NODES J>REV_STJ>1R ;= SECOND; 

elsif FIRST s NULL and SECOND/s NULL then 
TEMP.OP^VAL JMUMBEILOF.CffiLDREN := 1; 

1EMP_OP3VAL.CHILDRENJ^ODES :■ SECOND; 

elsif FIRST /= NULL and SECOND - NULL then 
TEMP OP_EVALJ^UMBER^OF_CHILDREN := 1; 

TEMP.OPJVAL.CHTLDRENJIODES :»FIRST; 

endi^ 


- Creating Assignment Node 

TEMP :« new ST_USTJ40DB; 

TEMPJlOOTJfAULTCIEMP.STR'rangc) t^TEMP^STE; 

TEMPMJMBER_OF„CHILDREN ;»3; 

TEMP.TYPE_GATE :»OR^OATE; 

TEMP.CHILDRFJ^_NODES := TEMP.CHANGE; 

TBMP.CHILDREN_NODESJ»REV_ST^PTR :«TEMP.EXCEPT; 

TEMP.CHILDRENJ^ODES J»REV_ST_PmPREV.STJ>TO :• TEMP.OPJEVAL; 

return TEMP, 

end ASSIGNMENT_TEMPLATE: 


- Function to build IF node 

function IF^STATEMENT^TEMPLAlE (FIRST, SE(XM), THIRD. FOURTH; 
STJ,IST_NODEJPTR) 
itttum STJLISTJIODBJTR is 

TEMP ; ST^UST_NODB^FrR; 

TEMP.COND.TRUE : ST^LIST^NODE^PIR; 

TEMP.COND :STJ.ISTJUODE^inR; 

TEMPJEa,STMrS : ST^UST^NODE PIR; 

TEMPJSVALs^COND : STJLISTJJODEJTR; 

TEMP_STR : STRING(1.,26):«’If statemem caused fault *; 
TBMP.CONO^IRUE^STR :S'miNO(1..43):« 

*C<»Ktiiioa true and statemenu caused fvdt 
TEMP.COND.STR ;SnUNG(I..I8);- ‘If condition iw'; 

TEMP^SECLSTMTSJTR : STRING(L.27) :• If aaimei^; faalt *; 
TEMP3VAL.CX)ND_STR : S11UNO(l,37) :»*Evaluation of cutdi^ c«U£^ 

begin - IF STATEMENT1EMPLATB 


~ Creating the evaluatkm of the condition node 
TEMPJBVAL.COND .*« new STJ.1STJIODB; 

TEMP^VAL^(X)NDROOTjJAULTCIEMPJEVALjCOND.STR1«nge) :• 
TEMP^VAU.COND.S'm; 


94 





'IEMP_5VAL_C0ND.CHILDRENJJ0DES :* FIRST; 


~ Oreating node for condition true 

TCMP.COND :» new STJJST_^^ODE; 

TEMP_COND AOOT.FAULTOEMP.CONDJS'ni'rangc) := TCMP.COND.STR; 


- Creating node fx statements when condition true 
TCMP_SEQ_STMTS := new ST_HST_NODE; 

TO>n»_SEQ.STMTS Jl(X)TJ’AULT(TEMP_SECLSTMrS_STR’range) := 
1EMP_SEQ_STMrS_S'ITl; 

TEMP_SEQ_STMrS.CHILDREN_NODES SECOND; 


- Creating true condition node for if statement 
TEMP.COND.TOUE :» new STJ.IST_NODE; 

TCMP_COh®.TRUE JlCKDTJ’AULTCrEMP.COND.TRUB^'m'ninge) := 
TCMP.COND^TRUE.STR; 

TCMP_COND_TOUEJWMBER_OF_CHILDREN :»2: 

TCMP_COND_'mUE.CHILDREN_NODES ;■ TEMP.COND; 

TEMP_COND_TRUE.CHILDREN_NODESJ>REV^J=TR := TBMP.SEQJTMTS; 
TCMP.COND.IRUE.TYPE.OATE AND.OATB; 


*• Creating node fx if satement 
TEMP t-ncwSTJJSTJMODE; 

TCMPJROOT.FAULTCIBMP^STR'iangc) TEMP.STR; 

■lEMP.TYPE^GATB :«01LGATC; 

HBMP.CHILDREN^NODES :* TBMPJSVAL^COND; 

TBMP.CHIU»ENJ^ODESi>REV_STJTTl ;»TEMP.COND.'mUE 

if THIRD/« hRJll tnd FOURTH/• hRAX then 
TEMPrHILDREN.JNODESJPREVJST^PTO.PREV„STJTR :»THIRD; 
TBMP.CKILDRENJ^ODESJ«EVJT^PTTU>REVJTJTRJTlEV_STJ^ 

FOURTH; 

TEMPJ4UMBER.OF„CHILDREN :-4; 

dsif THIRD - NULL and FOURTH/• NULL then 
TEMPXHILDREN^NODESiTmV_STJPrRJ>REV_STjPTR FOURTH; 
TEMPJWMBER.OF^CHILDREN 3; 

elsif THIRD /- NULL and FOURTH - NULL then 
TEMP.CHILDREN^NODESJRBVJTJTILPREV.STJTR :«THIRD; 
TEMPJWMBER.OF.CHILDREN ;»3; 

else 

■rEMPNUMBER.OF_CHlLDREN 2; 

end if; 

lefumTEMP; 


end IF^STATEMENT^TEMPLATE; 


~ Function to build &LSIF node for IP statement 


function ELSIF^TBMPLATE (FIRST. SECOND. THIRD: STJJSTJIODEJ>TR) 


95 





return ST^LISTJ^ODEJTH is 


TEMP : STYLISTJ^ODE_pTR; 

•reMPJ>«BV_COND : STJLISTJ^ODEJ>TO; 

TEMP.CURJUTURE : STJJSTJ^ODE 
TEMP_CUR_ELSIF : ST_EISTJNODEJ>TRj 
TEMP CX)ND_TOUE : STJJST NOI®JTE; 

TEMPJEQ_STMrS : STJJSTJNODBJ>TR; 

TEMP.OTBESLELSIF :STJJSTJ40DBJPTR; 

TEMPJSLSIF_CX)ND : STJUSTJ^ODEJTR; 

TEMP.STO : STRING(1.^3)"ELSIF caused the fault •; 

TEMPJ*REV COND STR : ST11ING(1..39) := "Previous conditions evaluated to false 
TEMP_CUIUVrURE„STR: STRING(1..38) :• "Cuirent/ftiture ELSE* caused the fault 
TEMP_CUILELSIF_STR : STlUNGd.Jl):«"Cunent ELSIF caused the fault 
TEMP.COND.TWJELSTR : ST1UNG(1„41)"Current ELSIF condition caused the fault 
TEMP.SEQ_STMTS^STR : STWNG{1„S4):«"Qment ELSIF sequence of statements caused 
the fault"; 

TEMP.OTHER^IFJTR: S7RB^G(L.31)"Other ELSIFs caused the fault 
1EMP_ELS1F_C(M).STK: SlEINGCLdS) :•> EvaluaEo of Elsif conditton caused fault 

begin - function ELSIP.TEMPIATE 


- Creating node for all previous conditions evaluated to false 
TEMPJPREV^COND :• new ST^USTJNODB; 

TEMP_PREV„COhn).ROOTJPAULTClEMPJPREV.€X)ND.S'niVange) 
>TEMPJPREV_COND„STR: 

TEMPJflREV.C<M).Tmj^O0E RECTANGLE} 

~ Creating node for current ELSIF condition evaluating to true 
TEMP.COND TRUE :• new ST^LIST.NO0B; 

TEMP„CONDji:^UEJ(l()OT^AULT(IEMP^CCa«)^llttlE^S > 

lEMP^COND.TEUE STR; 


TEMP^ELSIF^COND new ST.USTJiODEJPTR; 

TEMP^ELSlF.COhmjROOrjPAl^T<TEMPJELSff.COND„STR*rwge);« 
1TMP„ELSIF_C0ND„STR; 

TE'APJBUSF.COhrorifllJaRENJ^Sl^ FIRST; 

» Creating node for current ELSIF acqueare of statements 
TBMP„SE(LSTMTS :• new STJLISTJNOim; 

TEMP^SEQ^STMTO JlOOT.FAULTCIEMP^E(i.STMTS.STRreoge) 
TBMP_SEQl.STMTS_STR; 

1EMP_SE(LST»mrHlL0RENJ4DDE5 :«SECOND: 

»• Dealing node for current ELSIF causing fault 
TCMPjCUR^ELSlF :» new $TJ.IST.NODE: 

TEMP_CUR^ELSIFjROOT_FAULT(lEMP.CUR_ELSlF.STR’tangc) 
TBMP.CURJELSIF.STO; 

TBMP^aJILELSIFJ4UM3EiLOP.CHIU»^ >2; 

1EMP^CUILELSIF.C!iILOR£Nj«fOD&S :»t£MPJX}NDjnUES: 


96 





TEMP_CURJELSIFrHIIJ)REN_NODES J1lEV_ST_m :«■EEMP_SEQ_STMTS; 

•IEMP_CUR_ELSIF.TYPE_GA'li :aAND_GATE; 

- Creating node for other ELSIFs possibly causing fault 

TEMP.OTOERJBLSIF := new ST.LISTJ'iODE; 

TEMP_OTHER3LSIFJlOOTJ’AULTaEMPjOTHERJI51F_STR'iange) J- 

TEMP_arHE!LELSIF_Sra; 

m4P_OTHERJElJSIF.CIDLDRENJNODES THIRD; 

- Creating node for current w previous ELSIF causing the fault 

TEMP.CURwFUTURE :» new STJLISTJNODE; 

TEKa»_CUILFimjRE.R(X)T_FAULT(TEI^jCUIUVrUREJSTO^ := 

TEMP CURJVnjRE_STR; 

TEMP_CURJFUTIJRETYPE_GATE :«OILGATB; 

TEMP_CURwFIJTURE>IUMBER_OF_CHILDREN .--a; 

TEMP_CUILFimjRE.CHILDRENJ^ODES :■ TEMP_ELSIP_OOND; 

TEMP CUR_FUT(JRE.CHILDREN_NODES^V^ST_Fm ;• TEMP.CURJEUSIF; 
TEMP^ajR_FUTDRE.CHIIJaRENJ40DESi»REV^JPTRJ«EVjSTJ>Tll:« 
TEMP^OTHEILELSIF; 

~ Crating node for the ELSIF statements 
TEMP new STJJSTJWDE; 

TEMPROOT^FAULT(TEMP„$TR‘range) ipTEMP^STR; 
TEMPJWMBER^OF„CHlL£»EN :p2; 

TEMP.TYPE^GATE ..AND^GATE; 

TEMP.CH1LDREN„N0DBS :* TEMPJPREV„COND; 

TBMPXHILORENJiOEaBSJ>RBV3TJPm t-TEMP.CURJWURE; 

return TEMP; 

endELSIF_TEMPLATE; 

•< Fimetion to build ELSE i»de ftnr IF tuie^^ 

funclioo ELSEJEMPUTE (FIRST : STJJSTJ4C>DEJ=TIG return STjaSTj<()DEJ^ 


TEMP ; STjJSTJMODE^m; 

TEMP.COM) : STJLISTJIODEJPTR; 

TEbiP.STMTS : STJJS'fJJODEJPTR; 

TEMP^TR ;STRING(I.23)>’mSB part caused Fault’; 
TEMP.COND.STR : STR1N0(1..61) > 

’OF cooditioo and ELSQP conditioti. if any. evaluated to false 
TEMP.STMTS.STK :STRJMHl.J2}>*S(atemeiUa in ELSE caused 

begin-ELSE TEMPLATE 

- Creating conditkn node for else staionent 
TEbiP.COND new STJLISTJMODE; 

TEI^.CONDJR()ClTJSAULTCTBMP.COND.Smi^ z-TEMP.COND^TR; 


91 



temp_cx)nd.tym;j<ode 


:=3; 

- Creating statements node for else statement 

TEMP^STMTS :» new STJ.ISTJ<ODE; 

TEMP_STMTSJlCX)TJ5AULTaEMP STItflS STR*Tange):»TEMP SlMrS_STO; 
TEMP_STMrS.CHILDREN_NODES > FIRST; 

- Creating Else luxk for else 

TEMP :-newSTJLlST_rJODE; 

TEMPJlOOT_FAULTCIEMP_Sni'ijuige) TEMP.STE; 

TEMPJWMBER^OF.CHILDREN ;«2; 

TEMP.TYPE^GATE :»1; 

TEMP.CHILDREN_NODES :-TEMP»COND; 

TEMP.CHILDREN_NODESJ>REVJSTJTR ;»TEMP_STMrS; 

return TEMP; 

cndELSE_TEMPLATE; 

~ Function to build nodes for sequence of statements -STMT.. 

function STATEMENTS (FIRST. SECOND: STJLISTJ^OMJPTR) 
return STJUSTJ^ODEJPTR is 

TEMP ; ST.UST^NODB_m; 

TEMP.LAST : STJLIST^NODBJPTR; 

TEMP^PREV : ST_UST„NODB_PTR; 

TEMPJ^ST^MASK ; ST^UST^NODB^FTR; 

TBMP.SEdJfWOR : STJJST^NODEJTTil; 

TEMP.STR :ST1UN0(1.,36):« “Sequence of statements caused CwiU"; 

TEMPJ^AST.STR :STRB<0(1..36);»“Ua statement caused fault *; 
TEMP^PREV^STR ;STRiNG(J..36):-*l^vious«atemBnU caused fau^^ *; 
TEMPJ.AST^MASIC.Sim :STIUNO(1..36):-T4taStatcm<mi did i»l mask faul^ •; 
TBMP_SEQJ»IUOR^STR :StlUN<Kk.36):-“Sequence prior to last caus^ 

NEXT : STJ.ISTJN0DE^P1E; 

ADD_LOC :ST^UST„NODE m*. 

END^NODE : BOOLEAN;« FALSE; 

be^ ~ function Statements 

- Creating nodes for template of sequence of statements 

X Building node for Ian statement did not fault 

TEMPJLASTJ^K :• new STJJST_NODE; 

TEMPJjSST^MAS!CRC)OTJPAULT(TEMPJ-ASTJ4ASIL3TE^c) 

TEMP_LAST..MASIC_STIl; 

- Building node for sequence prior to latt statement caused fault 

TBMP_SE(LPRIOR s-newSTJUSTJ^ODE; 


98 



TEMP„SE(LPRI0RilCK>TJ?AULTam4P.JE(lJ»RI0R_STR’nuige):» 
TEMP_SEaPRIOR_STR; 

- BuOding node for previous statements caused the fault 

TEMPJWV :« new ST_UST_NODE; 

TBMP.PRBVJlOOT.FAULTCIEMP.PREV^TRtange) :-miPJ«EV_S'ni; 

TBMP.PREV.TTPE.GATE .^AND.OATE; 

1EMP_PREVJWMBEILOF_CHILDREN :-2; 

TEMP PREV.CHILDREN_NODES .••TEMP.LAST.MASK; 

TEMPJ1lEV.CHIU)RENJ^ODESi^V_STJ>TR :«TENiP„SE(l.PRICmj 

~ Budding node for the last statemei;^ caused the fault 
TEMPJAST :» new STJJST_NODE; 

TBMP.UtSTJtOOTJJAUlTCIEMPJLAST.S'm^c) 5-TEIi®LMST_STR; 

- Building iwde for the sequence caused the fault 

TEMP :»newSTJJ[STJ<ODE; 

TEMPJlOOT.FAULTCrEMP.STO'iange) >tTEMP_STR; 

TEMP.TYPE.OATE :-OB,GAlB: 

TEMPJWMBER^OF^CHILDREN :»2; 

TEMP.CHILDREN^NODES :«Tfi&fPJLAST^ 

TEMP.CmDRENJ^Ot^FREVJSTJim 3»1EMPJPREV; 

“ If bo^ .^tmt. and stmt m null 
if FIRST » NUiX and S£C<^D • NULL then 
reiuronulh 

- If is null ami is not null 

tlsif FIRST - NUa and SECQNI? NUa dien 
TEMPJ.AST.CHK>DREN_NODES :*« SECOND; 
TEhiP„lJ\STJ4UMimiLOF>CIfili>R^ I; 
ittum TEMP; 

»If .jttrnt.. is not null but stmt is null 
elslf FIRST/. NULL wd SECOND « NULL then 
TEhi^.LAST.CHIU)REN.NOISES FIRST; 
TEMP^LASTJWMSER^OF.CHILDREN:«1; 
naumTEhC*: 

~ Both ..sina.. and stroi have a valid statemem 
else 

hutialize tempocary poittEcxs to help plsis the statements 
NEXT :« 

HRST.Cmi:^IUEhU^OI}®SJ1lEV^STjn^ .3lJ^<M)ESJ>R£V.STjnR.€mDft 
ENJ«)DES; 

ADD^LOC > 

ifqRST.anLDR£NJ^ESJ>REVJTJ»m.CHIU>RENJ^ODESi^V^STJ^ 

^ Loop tuitd )in) find the to insesi the nodes 

white NOT END>‘OD£ loop 
if NElff-NULL then 

ADDJLOC>CHIU)RBN„NOr«S >TBMP; 

ADD^LOC>JUM»ER.OF OfiL^N 1; 

lEMI^CIfllJ>RENJjODeS.Cmmt£NJ«KH)eS ;» SECOND; 


99 




mO>.CHILDRENJ^ODESJJlJMBER^OF_CHILDREN := 1; 

END.NODB ^TOUE: 

rcdim FIRST; 
else 

ADDJ.OC:- 

NEXT.CHlLDREN_NODESJRBV_STJ>TR,CHILDRENJ^ODESi«EV_ST_pTO; 

NEXT 

NEXT.CHILDRENJ^ODES^V_STJTTl.CHILDREN_NODESJ«EV_ST,JTO.CHILX)R 
EN_NOE«ES: 
end if; 
endlooft; 
end if; 

end STATEMENTS; 


~ Function to build node joining elements of n lelaiion 

function BIULDJREL (FIRST. SECOND; ST.USTJ^ODEJPTR) 
iwuro STJJSTJ^ODEJTO is 

TEMP : ST^USTJ^ODBjna; 

TEMP^STR :string{i.J6);@'1Se!aiioQc»ised 

begin ^ BUILD R£t 

TEMP ;^newSTJt.IST.NODE; 

TBMPiiOOTJPAULT(TEMP.SW«cgfc):« TEMP.ST1L 
if SECOND ^NULLOwa 
TEMP.TYPE^OATB :«=(^!^GATE; 

mfPNUMBEiLOF-CHILDREN 
TBMP.CmLDRBN.NODES FIRST. 

iBKfP.CHBJDRENJWDESJPimv^St^ SECOND; 
eDa 

1EMPJNUMBER„OP^CHiLI«EN :• 1; 
miP.Cmi»tENj«)DES ;«FiRSr; 

Rsum lEMP; 
end BUILD JIEL; 


•-to build and 

femction BUB J>JREL_AND (FIRST. SECXJND: STJJST,N0DEJ1R) 
Ktum STJJSTJiODEJPm is 

TEMP : STJLlST.NOI«JTR; 

mtPjJEFT :STJUST_NODE PTR; 

TEMPJUGHT tSTJJSTJJODEJTfe 


100 







TEMP_S'IR : S'nUNGCl.JO):»"And Relation caused the fault 
■IEMP_LEFr_STR : STRING(1..36) := "Left or Prior relation caused fault *; 
TEMPJUGHr_STR : STRING(1..28)"Right relation caused fault 

begin - Beginning of the RELAND template 

- Building left node for and relation 

TEMP_LEFT r« new ST_USTJNODE; 

TEMPJEFT.RCKDT_FAlJLT(TEMP_LEFr_STTl'range) :aTEMPJ£FT„SlR; 
TEMPJEFTJ^UMBER^OF_CHILDREN 1; 

•IEMP_LEFT.CH1LDRENJJODES :« FIRST; 

- Building right node for and relation 

TEMPJUGKT :» new STJJSTJIODE; 

TEMP_RIGHTJlOOT_FAULTCIEMP^GHT_STR’range) := TEMPJUGHT_STR; 
TEMP_RIGHTJ^UMBER^OF_CHILDREN 1; 

TEMP_RIGHT.CHILDREN_NODES := SECOND; 

- Building and relation node 

TEMP ;=newST_LIST_NODE; 

TEMPJlOOT_FAULT(TEMP_STR'iange) := TBMP.STR; 

TEMP jmiBER^OF_CHILDREN :■ 2; 

TEMP.TYPE_GATE := OR.GATE; 

TEMP.CHILDREN_NODES := TEMPJLEFT'; 

TEMP.CHILDREN_NODESPREV_STJ>TR :* TEMP_RIGHr; 

RETURN TEMP; 

end BUILDJffiL_AND; 


- Function to build or relation node 

function BUILDJlEL_OR (FIRST, SECOND: STJJSTJIODEJTE) 
return STJ,ISTJ^ODEis 

TEMP : ST.LIST_NODEJ>TR; 

TEMP LEFT : ST_USTJ^ODE_PTR; 

TEMPJUGHT : STJJST_NODEJTE; 

TEMP_STR : STRING(1.59) ;«"Or Relation caused the fault *; 

TEMPJJEFT_STR ; STWNG(1..36) :«"Left or Prior relation caused fault 
TEMPJUGirr_STR :STRING(L,28):- "Right relation caused fault"; 

begin - Beginning of the REL AND template 

- Building left node for and relation 
TEh4PJ-BFT’ :»newSTJJSTJNODE; 

TEMPJJOTAOOTJJAULT(TBMPJJEaT’_STR'range) TEMPJOT^STR; 
TEMPJEFT.NUMBER.OF.CHILDREN 1; 

TBMPJEFT.CHILDRENJ10DES :»FIRST; 


101 





- Building right node for and relation 
1EMP_RIGHT := new ST„UST NODE; 

■reMPJUGHrJlOOTJJAULTCreMP.RIGHT.STR’range) := TCMP.RIGHX.STR; 
TEMPJlIGHTJ<UMDER_OF_CHILDREN := 1 ; 

■IEMP_RIGHT.CHILDRENJMODES := SECOND; 


" Building and relaricm node 

TEMP := new ST J.IST_NODE; 

TEMPJlOOT_FAULT(TEMP_S'ni'range) TEMP.S'm; 

TEMPJWMBER_OF_CHILDREN := 2; 

TEMP.TYPE_GATE := OILGA1E; 

TEMP.CHD-DREN.NODES r-TEMP^LEFT; 

•IEMP.CHILDRENJ^ODESJ«EV_ST_PTR :»TBMP^RIGHT; 


RETURN TEMP. 


end BUILD JIEL.OR; 


Function to build and then lelation node 


funcUon BUILD_REL_AND_THEN (FIRST, SECOND: ST.LIST_NODBJ>TR) 
return STJJSTJ^ODE_PTR is 


TEMP : STaiST_NODE.PrR; 
TEM?_LEFT : STJUST^NODE^PTR; 
TEMP..RIOHT -•ST_UST^NODE.PTR; 
•rEMP_RJ- : STJ.IST_NODE„PTR: 

TBMPJCR : STJ.ISTJJODB^PTR; 


TEMP^Sm : STRINO(1..35)“And Then Relaiion caused Use fiailt 
TBMP^LBFXSTR : S*miNO(l.,36)“Left or Prior relation caused fault 
TBMPJUOHT_3TR :STTUNG(1.^):-“Right reiatioo caused fauU*; 
TBMP^RJL^STK : STRINGd ..19) “Left relaiioo m»"; 

TEMPjm^STR ; STR1NG(L.42)“Evaluation of right retationcaised fault 


begin - Beginning of the R£L AND THEN tereplaie 


~ Building right node's left child 

TEMPJU- :»ncwST^USTJ^ODE: 

TBMP^RJ-ilOOTJJAULT(TBMPJU-.STRYangc) >imfPJULSm; 

~ Building right node's right ctdid 
TEMPJUl :« new ST.LISTJ'IOM; 

TBMPJlJR.ROOT„FAULTflEMP^lULSlRVange) :«TBMPJULS1R; 
TBMPJl_R.NUMBEtLOF^CHlLDREN :• 1; 

lEMPJULCHILDaEN_NOO£S SECOND; 


Building right node for and relaiion 
tBMPJUOHT :»aewSTJJST^NODB; 


102 





llMP_RIGm’JROC)T_FAULTaEMP_MGHT_Sm’iange) TEMPJIIGHT_STR; 
•rcMPJUGHTUUMBER OF.OQLDREN :=2; 

TEMPJRIGHT.TYPE.GATC := AND^GATE; 

■IEMPJUGirr.CHILDRENJ^ODES :xTEMPJU-; 

TEM?JUGHT.CHEJ)RENJ^IODESi«EV_STJ>TR :»IEMPJL^ 

•> Building left node for and relation 
TEMPJ.EFT >>newST_USTJJODE; 

TEMPJ£FTJROar.JAULTfrEMPJOT_SlRtangc) :»TEMPJLEFr_STO; 
TOMPJOTJ^UMBEIL.OF^CHILDREN :«1; 

TBMP_LEFT.CHE-DREN.NODES FIRST. 

- Building and relation node 

TEMP :« new STJ4STJ10DE; 

TCMPJlOOTJJAULTaEMPJ'ni’ongo) ;»TEMP_Sra; 

TEMPJ'JUMBEK.OF.ODLDREN ?-2; 

TEMP.TVPE.GATE :«OR^OATB; 

•reMP.CHILDREN_NODES t-TlMPJLEFr. 

TCMP.CHILDRENJJODESTREVJSTJTTI :»TEMPJUGHT; 

RETURN TEMP; 

end BUILD^REU AND.THEN; 


~ Ftinciion to build or el^ idation node 

function BinLDJREL^OR.ELSE (FIRST, SECOND: STJLISTJ^ODEJPTR) 
leusm STJJSTJ^ODEJPTR is 

TEMP ; ST^LISTJ^ODE^Pm- 
TEMPJ^ ; ST.UST„NODE„PIR; 

TOMPJ?iGHT ; STJL!$TJI0DE.FTR; 

TBMPJU- : STJLIST^NODBjm; 

TBMPJRJl tST„UST_NODBJPm; 

TOMP^STR : STIUNGd.34) ;• ^Or dse Relation caused the fault *: 

TCMP^LEFTJTR :StRING(J.36)>aeft or prior idati^ 
TBKflPJWOHT^STR : STRING0.38)sedation caused 
TEMPJUL.,STR :STRLNO(1..20):-T^wlstionlirise*: 
tEMPJULSTR ; S1R1N0(LA2) ;<« ‘Evaluation of rigtitielation caused 

l«gb •> Beginning of tite REL AN1D TIIEN tetnpl^ 

~ Building right node's left child 

TBMPJRJL :-newST„UST„NODE; 

TEMPJUJROOTJ^AULTa^MPJU^SmVa^ ;«TEMPJU.*STR; 

^ Building rig& node's ri^ child 

m/!PJtJL :-newSTJJSTJiOIffi; 

TEMPJUUiOOTJ^AULTtlBMPJUL^lRVange) :*1[1!MPJR,JLSTR: 


103 






TEMP_RJU<UMBER_OF_CHILDREN 

TEMPJl^anLDREN_NODES 


:= SECOND; 


- Building right node for and relation 
TEMP_RIGHT :» new ST.USTJ^ODE; 

TEMP.RIGHTJlOOTJJAULTCreMPJUGHT.STR’range) lEMPJUGHr_STR; 
TEMPJUGHTJ4UMBEILOF.CH1LDREN :»2; 

TEMP_RIGHT.TYPE^GATE ;= AND.GATE; 

TEMPJtlGHT.CHILDRENJNODES TEMPJU-; 

TEMPJUGHr.CHILDRENJ^ODESJREV_STJ>TO :-TEMPJUl; 


- Building left node for and relation 

TEMP_LEFT new STJJST_NODE; 

TEMP^I£FTJlOGr_FAIR.T(TEMPJEFTJSTRtange) :»TEMPJEFr_STR; 
TEMPJ-EFTJWMBEILOF_CHILDREN :«1; 

TEMPJEFT.CHILDRENJ^ODES := FIRST; 

- Building and relation node 

TEMP :» new ST^LISTJJODE; 

TEMPJIOOT FAULTCIEMP STR’iange) :»TEMP^S1R; 
TEMPJMUMBER^OF^CHRDREN := 2; 

TEMP.TYP:2_G/"E :«OR_GATE; 

TEMP.CFUDRENJNODES :»TEMPJLEFT; 

TFMF.CHILDREN_NODESJ>REV_ST_FTR u»TEMPJUGHT; 

RETURN TEMF, 

end BUILDJtEI.^OR. ELSE; 


- Futiciion to build node for tange name 4 >ecified causing fault 

functkw BUILD_RANGE.NAME (FIRST: ST ,USTJ40DEJ>TR) 
tsxm STJJST^NODEJ>TR is 

TEMP :ST.UST^NODE-Fm; 

TBMP_STR :STKIN0<1.29):^*1tange specified caused 

be^ >- Beginf^ of fiiUcUon to build tango specified node 

TEMP now STJLIST„N0DB: 

TEMPJlOOT.FAOLT(TEMP_3TR'tangc) :• TTilVu'JlR; 
TEMP.CHILDRENJ^ODES FIRST: 

TEMPi4UMBEILOF_CiflLDREN ;-I: 

RETURN 

end BbUDJIANGlLNAME; 


~ Function 10 bulU node for lange spectfied caustng fault 


104 





function BUEJ)JING (FIRST. SECOND ; STJJSTJ^ODEJTR) 
return STJ.ISTJ^ODE_Pm is 

TEMP : STJLIST_NODEJPTR; 

lEMP.STE :STRlNO(1..29):a "Range specified caused fault": 

begin - Beginning of function to build range specified node 

TEMP := new STJLIST.NODE; 

TEMPJROOTJ'AULTCIEMP.STR'range):» TEMP_STR; 
TEMP.CHILDREN_NODES FIRST; 

TEMP.CHILDREN^NODES J>REV_STJ>TESECOND; 
TEMPJiUMBER_OF_CHILDREN :»2; 

TEMP.TYPE.OATE :«OR_GATE; 

RETURN TEMP; 

endBUILDJRNG; 


- Function to build node for discreet range 1 child causing fault 

function BUIU)„DESCILRNG„I (FIRST: STJLISTJMODEuiTR) 
retuin STJJSTJ^ODEJTR is 

TEMP ; STJJST„NODE„PTR; 

TEMP.STR :ST1UNG(1..28):» "Discreet range caused fault *; 

begin ~ Function to (wild discreet range node causing fault 

TEMP fnewST^LIST^NODE; 

TEMPJlOOTJFAULTCIEMP.STR’range)TBMP^TR; 
TEMP.CWLDRBNJ^ODES FIRST; 

TBMPMIMBEILOF.CHILOREN 1; 

RETURN TEMP: 

end BUILDJ)ESauWO_l; 


~ Function to build node for discreet range 2 children causing fault 

function BUILDJ>ESCILRN0^2 (FIRST, SECOND; STJUSTJIODEJPTK) 
return STJJSTJtfODBjrra is 

TEMP :ST_LISTJ^ODE.m; 

TEMP.STR : STfUNG(l.i8) ;« "Discreet range caused (auU"; 

begin « Function 10 build discreet range node cau^ fiuilt 






TEMP > new ST_LIST.NODE; 

TEMPAOOT.FAULTCreMP.STR'iange) := TEMP.STR; 
•IEMP.CHILDREN_NODES :«FIRST; 
TEMP.CHILDRENJ^ODESFREV_ST^PTR :* SECOND; 
TEMPJNUMBEILOF CHILDREN .-=2; 
TBMP.TYPE.GA’IE r-OILOATE; 


RETURN TEMP; 


end BUE.DJ)ESCILRNG_2; 


~ Function to build node for leveree qiecification causing fuilt 

function BUILDJtEVERSEJNODE 
return ST_USTJ<ODEJTR is 

TEMP : ST.USTJ'IODEJTR; 

1EMP_S1E :STRING(1.35):«*Reverse^)6dfication caused fault”: 

begin Function to build discreet range node causing fault 

TEMP > new STJLIST_NODE; 

TEMPJlOOTJ’AULTaEMP_S'm‘range) :• lEMP^TR; 


RETURN TEMP; 
end BUILDJfEVERSE_NODE: 


- Function to build nodes for the loop poraineter causing fiutlt 

function BUILDJLOOPJPRM.SPEC (FIRST, SECOND. THIRD: STJLISTJ40DEJ1E) 
return STJJSTJs-ODEJ>TR is 

TEMP ; STJJSTJ^DB.PTR: 

TBMP.ID :STJL!STJ<ODBJ>TO: 

TEMPJTR ; STRING(L37)"Paiamcter specification caused fauii 
TEMPJD^S'm: STRlNOd J4)”ldentirier spedfied caused fault *: 

begin - Fundion to build loop parameter tenaplaie 

- Building left child where name of range specified 

TEMP^ID ^tnewSTJLISTJ^ODE; 

TEMP..IDROOTJPAULTXTEMP_©_S'mVinge)TEMPJDJSER; 
TEMPJDJ4UMBER.0F„CHILDREN :«I; 

TEMP.1D.CHILI»£NJI0DES :«FOSSE, 

- Building loop parameter specification node 

TEMP > new STJLISTJIODE; 


106 




'IEMPJlOOTJ*AULTCIEMP_STR'range) := TEMP.S'ni; 
TEMP.CHILDREN_NODES ;=TCMP_ID; 
ifSECX)ND/aNULLthen 

1EMP.CHILDRENJ40DESJREV_ST_m :«SECOND; 

TEMP.CHILDREN_NODES J»REV_STJPT1LPREV_STJ»TR:» THIRD; 
TEMPJ^UMBEILOF.CHILDREN :=3; 

else 

TEMP.CHILDRENJ^ODESJ»REV_STJTll :»THIRD; 

TEMPJiUMBEILOF.CHILDREN 5= 2; 

end if; 

TEMP.TYPE_GATE :»OILGATE; 

RETURN TEMP; 
end BUILD J,OOP_PRM_SPEC; 


- Function to build for loop iteration node 

function BUILDJ^OILnERATION (FIRST: ST_LISTJ<ODE_PTR) 
return ST_LIST_NODEJ>TR is 

TEMP : ST_LISTJIODE_PTR; 

TBMP.STR: S'nUNG(1..30)'Iteration scheme caused fault 

begin - Function to build for loop node 

TEMP new STJ.ISTJ^ODB; 

TEMPJtOOTJJAULTOEMP^STR’range) :• TEMP.STR; 
TEMPJWMBEIL0F„CH1LDREN 1; 
TEMP.CHILDREN.NODBS :*• FIRST; 

TEMP.TYPE.GATE :-OR>GATB; 


RETURN TEMP; 


end BUILDJFORJTERATTON: 


~ Function to build while loop iteration iwde 

function BinLD„WHILE.nERATTON (FIRST: STJJSTJ^OIffiJTR) 
return STJJSTJNODE J>TR is 

TEMP : STJUSTJ^ODBJPIR; 

TEMP_COND; STJLJST_N01^J?TR; 

TEMP.STR :ST1UNG(I»30):«'ltenulonschen)e caused fault”; 
TEMP^COND.STR; STRING(1«.4I) :■ ^valuadoo of cooditioa caused the fiuilt ”; 

begin •• Function ID build while loop node 


107 




- Building while condition node 

TEMP.COND := new STJLISTJ^ODE; 

‘reMP_CONDJlOOT_FAULT(TCMP_CX)ND_S'ni'range) := TCMP_CX)ND_S'm; 
TEMP_CONDJ^UMBER_OF_CHILDREN := 1; 
TEMP_COND.CHILDRENJ^ODES ;= FIRST; 

- Building iteration node 

TEMP :a new STJLIST_NODE; 

TEMPJlOOT_FAULT(TEMP_STR*range) := TEMP_STR; 
TEMPJiUMBEILOF.CHILDREN := 1; 

TEMP.CHILDRENJ'JODES :=TEMP_COND; 

TEMP.TYre_GATE :■ OR^GATE; 

RETURN TEMP; 

end BUILD_WHILE_nERATION; 


Function to build loq) statement template 

function BUILDJLOOP_STMT (FIRST. SECOND: STJLISTJ10DE_PTR) 
return STJJSTJIODEJTR is 

TEMP ; ST.USTJ^ODEJTR; 

TEMP.2 : STJJSTJMODB^PTR; 

TEMP.3 ; ST_LISTJIODBJTR; 

TEMPJ : STJLIST JIODEJTR; 

TEMPJ : STJJSTJ^ODEJTR; 

TEMPJ : ST_USTJ^ODE^PTR; 

TEMPJ : ST„LISTJ^ODE_PTR; 

TEMP.II : STJ.ISTJ<ODBJPTR; 

TEMP_12 : ST_LISTJ^ODBJ>TR; 

TEMP^TR : STRINO(1..28):»“Loop Statement caused fault *; 

TEMP.2_STR ; STRING(1..20);«“Loop never executed “; 

TEMP_3„STR : S'nUNO(I..39) ;«"Loop condition evaluation caused lauU"; 
TEMPJ„STR : STRING(1..27)"Nth Itcrarion caused fault 
TEMPJ.STR : STR1N0{I..24) >i "Wrong Type of loop used"; 

TEMPJ^TR ; STRINGd ..36)"Sequence of statements caused feuU"; 
TEMPJJTK : S'nUNG(1..24) > "Condition true past n-I 
TEMP^I LSTR: STHlNOd. J2)"Condition true at n-1 iteration"; 
TEMP^i2LS*ni: STRINGd.43)"Sequence of statements kept condition true *; 

begin - Beginning of function to build loop statement template 

- Building node 12 

TEMP.12 :-ncwSTJLIST_NODB: 

TEMP«llROOTJ!AULT(TBMP^I2„STR'range)TBMP_12^TR; 
TEMP_12JWMBER.OF^CHILDREN 1; 
TEMP.12.CHILDRENJ^ODES -^SECOND; 

-Building node 11 


108 



TEMP„11:« new STJJST_NODE: 

TOMP_llJlOOTJ’AULT(TEMP_ll_STR*range) := TEMPJl.S'IR; 

- Building node 8 

TCMP.g :-newST_USTJIODE; 

TOMPJ JlOOOAULTCTEMPXSTR'range) >* TEJdPJ_STO; 
TEMPJ JWMBEILOF.CHEDREN :« 2; 

TEMP_8.CHILDRENJN0DES .^TEMPJl; 

TOMP_8.CHILDRENJN0DESJ«EV_STJ>TR ;»TEMP_12; 
TBMF_8.TYFE_GATE ;sAND_GATE; 

-Building node 7 

TEMP_7 ;« new STJJST.NODE; 

TEMP.7JlOOt.PAULT(TEMP_7 STR'range) TEMP^7.STR; 
TEMP_7J^UMBE[LOF_CHILDREN :«1; 

TEMPJ.CHILDIIENJIODES SECOND; 

-Building node 4 

TEMP 4 new ST UST_NODB; 

TEMP_4 JiOOT_PAULT(TBMP_4_STR’nuige) := TEMP.4_STR; 
TEMP_4J^UMBER_OF^CHILDREN :-2; 

TEMP_4.CHILDREN_NODES :-TEMP^7; 

TEMP 4.CHILDRENJ^ODESi«EV_ST_?ra c-TEMEJ; 
TEMP_4.TYPE_GATE :»AND.GATE; 

- Building node S 

TEMPOS new STJLIST_NODE; 

TEMPJ JIOOTJJAULTCTEMPJJTE’range):« TEMPJ.STE; 

- Building node 3 

TEMPJ •.■ncwSTJJSTJIODE; 

TBMPJJlOOTJPAGLTaEMPJ_S'm*range) :»TEMPJ_SHU 
TEMPJ.TYPE.OATB ;«OILOATB; 

TEMPJ.CHILDRBNJiODES >T1MPJ; 
if FIRSTS NULL then 

TEMPJ.CraLDRENJlODES.PREV_STjm;« FIRST, 
TEMPJJWMBEILOF^CHILDREN :«2; 

else 

TEMPJJ4UMBERJ)F_CHILDRBN :•!; 

end if; 

-Building node 2 

TBMPJZ r-newSTJJSTJ^ODB; 

TEMP^ROOTJJAULTCTEMPJLSTO’fange) >i TEMPXSTR; 

- Building iwde 1 loop stsiemem template 

TEMP :• new STJUSTJIO0E; 

TBMPJlOOTJ*AULT(TBMP^STRTange) :«TBMP STR; 

TEMP.TYPB^OAIE ;-OK.OATB; 

TEMP.CHILDREN_NODES t-TBMPJl; 

TBMP.CmLDRENJ40IffiSi«BV^TJPTR > TEMPJ; 


109 








TEMP.CHE,DREN_NODES J>REVjST_FnU»REV_ST.JTR := TEMP_4; 
TEMPJ4UMBBR^0F_CHILDREN ;=3; 


RETURNTEMP; 
end BinLD_LOCa*„STMr; 


- Function to build case statement template 

function BUILD_CASE_STMT_1EMPLATB (FIRST. SECOND: STJUSTJ40DEJPTR) 
return ST_WSTJ^ODE.I>TR is 

TEMP : STJJST^NODEJTR; 

1EMP_2 ; STJLISTJ40DEJ>TR; 

TEMP.STR :STRING(1.^):b "Case statement caused fault”; 

1B^0*_2_STR ; STRINQ(1.^8) :■ "Evaluation of expression caused fault *; 


begin BUED^CASEJTML.TEMMATE 


•> Building evaluation of expression node 
TEMPJ » new STJJST_NODE: 

TEMP„2JlOOTJAULT(TEMPj_STO*range)TEMPJZ.STR; 
TEMP,2J4UMBER_OF^CHEDRBN :«= 1; 
m«P_2.CHILDRENJNO]^ :• FIRST; 

Building Case stmt node 

TEMP :«e$wSTJ.lSTJ40DE; 

TEMPJlOOTJfAULTCmNSLS'miJsngc) .'-TEMP^TR; 
TEMP.Tm^OATB :«OR.OATE; 

TBMPJ'JUMBBILOF^CHILKiEN :• 2; 
TEMP.CHILDR£NJ^ODBS :-TEMPJ; 

TEMP.CHILDREN.NODESJP»EVJSTJ>TO ;«SECOND; 

RETURNTEMP; 


end BinLD.CASE.STMT..TEMPLAlE; 


~ Funtaion to build at least mre rnore case alteinadves templates 

function BmiD.CASBJiLT.l JMORE (FIRST. SECOND: STJJSTj4Ca)EJ>TR) 
mum STJUSTJ40DB is 

TEMP ; STJUSTJ40DBJTO; 

TEMPjm ; smUNOCOO):»"Case altouaiive caused ftuiU 

NEXT ; ST.USTJIODBJPTO; 

AKIJLjOC tSTJLISTJlODEJTR; 


no 







END_NODE :BCX)LEAN:« FALSE; 

begin - Build case alt 1 more 


TEMP new ST_LIST_HODE; 

TEMPJlOOTJ’AULTCTEMP.STR'range) ;* TEMP.STE; 
TEMPJJUMBEILOF^CHILDREN :»1; 

if SECOND* NULL then -Only one case alternative 

TEMP.CHILDREN_NODES :• FIRST; 
else - Muldple case alternatives (> 2) 

TEMP.CHILDREN.NODES '.-SECOND; 

- Initialize temporary variables 

NEXT ;-SECOND.CHILDREN_NODESJ»REV_STjnil.CHILDREN_NODES; 
ADD_LOC :• SECOND.CHILDRENJiODES JTlEVjSTJTE; 

- Iteration to find location to add cluld 
whUe NOT END JIODE loop 

if NEXT-NULL then 
ADD_LOC.CHILDREN>tODES:« FIRST; 

ENDJ^ODE t-TEUE; 
else 

ADDJLOCNEXT.CHILDREN_NODES.PREV„STJPm; 

NEXT >NEXT.CHILDRENJ<ODESJ>REV.STJPnLCHILDRENJ^ODES; 
end if; -next-null 
end loop; - not end^node 

endif; -second-null 


RETURN TEMP; 


end EUILD_CASB„ALT.LMORE; 


- Function to build 0 or more case altemafives ien^.ate 

function BUlLD.CASB_ALT„OJdORB (FIRST. SECOND; STJJSTJIODBJTR) 
lelum STJJSTj;ODBJTO is 

TEMP ;STJLIST,NODEJPm; 

TEMPJ : STJJSTJIODEJW; 

TSivffl,3TR ; $TR!NG(L.42)•Curreni/jjeevtous alternative caused fault 
TBMFX^’n^ ;STRINQ(l.J4):-^^viou$alteiiudive caused 

begin - BUILDCAmALtOM^ 

TEMP„9 :-»tewST^USTJ40DB; 

TBMP^9 JflOOT: JPAULTCTBMPASm’fiatgc) ;s 
TEMP^NUMBER^OP^CttlLOREN :-l; 

•mMPJ).CHlLDRENJ40DES ;a«FIRSr. 


nt 









TEMP :«newST_LISTJ'JODE; 

TEMPJlOOTJJAULTCIEMP.STR'range) :« TEMPJTR; 
TEMP.TYPE_GATE :«OILGATE; 

TOMPJWMBER.OF.CHILDREN :»2; 
TEMP.CHILDRENJ^ODES := SECOND; 

TEMP.CHILDRENJJODESfREV_5T_pm :«TEMPJ); 

RETURN TEMP; 

end BUE,D_CASEjM-T_O^MORE; 


- Function to build individual case statement alteznaiive template 

function BUILD^CASE_STMTJ^LT (FIRST, 

SECOND, 

THIRD : STJLIST_N0DB„PTR; 

OTHERS_CHK: BOOLEAN) return STJJSTJiODEJTO is 

TEMP_4 : ST_LISTJNODEJPTR; 

TBMP_6 : ST_LISTJ^ODE 

TEMP_7 : STJJSTJNODEJ^IR; 

TEMPJ ; STJ-ISTJ^ODBjnE; 

TEMP^IO ; STJJSTJNODBJTB; 

TEMPJ 1 : ST.USTJIODB,PTll: 

TEMPJ2 :STJJSTJ^ODE.Pm; 

TEMPJ3 :STJJSTJNODE^PTR; 

TEMP.14 ; STJJSTJMODBjnR; 

TEMPJ JTR ;STRINO(l.,27):-*OtheiscI«ise caused fault-; 

TEMPJJTR ;STRINO(1.,24);--Noothercoivlitlootwe-; 

TEMPJ_STR :ST1UN0(1JS):--Body of othere clause caused &ult-; 

TEMPXSTR ! STR1NG(L.33) :• "Cunent alternative caused fiuili 
TBMP^IO.STR ; STRINO(L^) > -Cholcefs) condition bve ’; 
TEMPJLSTR : STRI^TS(iJ8)^•'Current alteraadve body oMtsw^ 
T«MP_12.STR : STRINO(1..36)-Cuirent/lrrevious choice cased fault'; 
TEMP^13.STR : STRING(1 .i8):«"Current choice caused fault *; 

TEMP.14 JTR : STR]NG(1 J9) ;* -previo«;s choice caused fault *; 


begin - BUILD CASE STMT ALT 


-• Condition to check if alternative is an othere altesnative 
ifNOTOTHERS.CHKtNea 

- Building pitv dwicenode 
TEMPJ4 ;-ncwSTJLISTJK)DB: 

TEMP„14JlOOTjJAULTCIEMPJ4.SlRTange):*lEMP M^STR; 
if SECOND)^ NULL then 


112 








•reMP_14J4UMBEILOF_CHILDREN :«1; 
■reMPJ4.C3nLDRENJ40DES > SECOND; 

end if, 

~ Building cunent choice node 

lEMP.lS new STJJSTjaOI^; 

TEMP^IS JlOOTJ'AULTCIEMPJS.STKtenge)TEMP.13uS1R; 
TEMPJ3J4UMBEILOF.CHILDREN :• 1; 

1EMPJ3.CHILDREN_N0DES >FmST; 

- Building cunent pKVious choice 

TEhff.l2 :• new STJJSTJ'JODE; 

TEMP 12JlOOT_FAULTCIEMPJ2_S'mYwtge):« TBMP^RJSTR; 
TEMPJ2.TypE_GATB :* CHOATE: 

TEMP_12JWMBER..(a5_CHILDRBN :»2; 

TEMP_i2.CHILDRENJ4QDES ;®TEMP„J3; 

TEMP_i2-(mi»ENJNOI«SJ^V^J>TR »*TB4P„I4; 

» Buihhng condition ttue node 
TEMPJO :«newSTJUSTJNOfi®; 

TEMPJOJl^CWTJ’AULTCIEMPjO.Sm^tangc);»tEMP.lO.SlE; 
TBMP.10J«JMBER.CHF.CHIU)REN :•* 1; 

tEMP.10.CHlLDSEN_NODES »«TEMP.l2; 

•'BuOdtng cwient siii^native bod^ 

TEMP.n :«inewS7JJfSTJN0DB; 

TEMP.tt JtOOT.FAULT(TEMPJl.STRV»nge)TEMP.U.STE; 
TEJ«».UJ4UMEfiR.pP.a^^ :«!; 

TEMPJuaaUDB^ 3iTlffiU>; 

<» Building cunent alieimtive node 
1EMP.8 new ST.UST.NODBi 

TEMP.a.ROOT.FAULTflEMP.g.STR'mnge) :• 1EMP.8.ST8; 
TEMP_8.TYPE.OATE :«AND.OATE; 

TEMP.8jaiJMBER.C»J.CHIU)REN 2; 

TEMP.8.(mDRENJ40DES :-1EMP.lO: 

TEKIP.8,CHILl»ENJ40DESi>REV.STJTK :-TEMP.II; 


RETURN TEMP.8; 
else 

Buildii^t i» oihn«)aUdoa (me no^ 

TEMP.6 5-newSTJLISTJlODE: 

TBMP.6E<X)TJ’AULTXlEMP.6jStEY«>ge) :-TEMP.6.STR; 

- Building body of other node 
TEMP.7 >inewSTJUSTJ«)»E; 

lEMP.TACXyrjJAULTTilEMP.t.SlR^c) .*• TBMP.7.STR; 
TEMP.7.NUMBEIL0FJCH1LDREN :• I; 
TEMP.7.cmDRENJ10D£S :«THIRD; 


113 



- Building other node 

TEMP^4 new STJJSTJ40DE: 

TBMP_4JiOOTJ»AULT(TEMP_4_STO'range) >TEMPj4,STR; 
•reMP_4.TYPB_GATE reAND.OAlE; 

’IEMP_4 J«JMBEILOF_CHILDREN :* 2; 

TEMPJ.CHDLDRENJNODES :«TOMP_6; 

mffL4.CHILDRENJNODESJ>REV^JTR >TEMP^7; 

RETURN TlMPjt; 

end if; 

end BUUD^CASELSTMTJVLT; 


«IHmction to build « ciwux (eropUte for case statKnent 

function BUflJD^OR^CHOICE (FIRST. SECX^ID: ST_UST^NODEJPIR) 
return STJ4STJ400BJ>TO is 

TBMP.IS : STJJSTJ^ODE^Fm; 

TCMP_16 :STjJSTJ40r^JPTR: 

TEMP.!? : STJLISTJ10EMU>TR; 

TEMPJS^STR ;STlUNG{l„36)?«‘tXaiti«/)previouscl^ 
*IBMPJ6„STR :ST1UNG(1..28):-Tu«tntcl»icec*^ 
imiPJ7.STR :StKJ[NG(l.J9):»*Fl(evious choice 

begin‘•BUILD OR aiOICS 

— SuUdtrg current choke node 

TBMP.I6 :<.ticwSTJUST„NODB; 

1BMF„l6^00T^FAUL11(m!P_l6JTRV«n|<^1BMP^I6«STR; 
TBMF^16.bnJMBER^OP^CIiILI«£N :* I; 
lEMF.l&CmDRENJvtODES SECOND; 

- Bvdtding prtv choice iwde 

TEMP_!7 :-r>ewST^UST^NODE; 

TEAO^^I^ROOTJFAin^ItTEMPJ?JIR^) :• tEMPj7^IR; 
if SECOND ^NUaaicn 
TEMPJ7,NUMBER.OF^CHIU«EN 1; 
TEMPl17.CH1LI)R£NJ40£)BS > FIRST; 

eadif; 

•-Buildint cutveia prevkws choice 
TBMPJS r-newSTJUST^NODE; 

TCl^_:-\ROOTJPAULTXTBh0LlS.STRVwge) :»TEMP_I5.^ 
TEMFLI5.TyFBJ3A1E ;-OR^GAlE; 

TBMPJ5J^UMBER„0F_CHRJ>REN >2; 
lEMILllCmDRENJIODES >1BIP 16; 


114 




TEMP_15.CinLDREN_N0DES J'REV_ST_PTR :» TEMP^l?; 
RETURN TEMP_15; 
end BU1LD_0R_CH0ICE; 


*• Function to build choice template for name mgjc 

fiinction BUILDjCHOICE_2 (FIRST, SECOND: ST_LISTJNODE_PTR) 
retain STJLISTJNODE.PIR is 

TBMP : ST_UST_NODE_PTR; 

TBMP_STR : STRING(1 ..35) := "Choice discreet range caused fault 

begin ~ Function to build discreet range node causing fault 

TEMP :» new STJLIST..NODE; 

■lEMPJlOOT.FAULTCIEMP^STR'range)TEMP.STR; 
TEMP.CHILDRENJJODES :=FIRST; 
TEMP.CHILDREN_NODESPREV„Sl_PTR := SECOND; 

TEMP J4UMBER_OF_CHILDREN ;= 2; 

TEMP.TYPE.GATE := OR_GATE; 

RETURN TEMP; 

endBUILD.CHOirE_2; 


- Function to build choice statement template for sim expr.. sim eapr 

function BUILD„CHOICEJ (FIRST, SECOND : STJ.:ST_NODEJTR) 
return STJLISTJNODE.PIR is 

TEMP : ST.UST_NODE_PTR; 

TBMP.STR : STRING(i..36);«"Choice range speciSed caused fault" 

begin •• Beginning of function to build range specitied >,ode 

TEMP :« new STJLIST.NODE; 

TEMPROOT.FAULT(TOMP.STR’range) := TEMP.STR; 
1EMP.CHILDREN_NODES FIRST; 

TEMP.CHILDRENJNODESPREV_STJ>TR:» SECOND; 
TEMPJNUMBER^OF.aULDREN :»2; 

TEMP.TYPE.GATE ;-OR.GATE; 


RETURN TEMP: 
endBWLD.CHOICBJ; 









~ Function to build piocedm? call template 


function BUILDJ>ROC_CALL (FIRST : STJLIST_N0DEJ>1R; 

TABLE :SYS_TABLE; 

COUNTER rlKIEGER) 
return ST J.IST_NODE JTR k 

TEMP :STJJSTJNODL.PTR; 

TEMP_2 : STJJST.NO’OEJ^ 

TBMPJ : ST.UST.NODEJPTR; 

TEMP_4 : STJJST.NODE PTR; 

TEMPJ^ : STJJST^NOIffi J>TR; 

TEMPORARY ; STJ-ISTJ40DEJTR: 

TEMP.STR :STRING(1..28):» "Procedure caU caused fault"; 

TEMP,.2.S‘ni : S1RING(1 ..3S) is "Procedure elaboration caused fault"; 

TEM?J_STR : S'reiNG(1..28) .•» "Procedure body caused fault 

TEMP_4_STR : STRING(1 ..24) := "Parameters caused fault *; 

TEMPJJFJTR :STRING(1..29):» "Procedure not found on table"; 

NOJ»ARA : BOOLEAN; 

PROGiDURE_NAME : STRING(l.mX^CHARJjONG)(OTHERS »>’•); 

FOUND : BOOLEAN :• FALSE; 

LOCATION : INTEGER; 

begin - function build procedure call 

•< Building of elaborsdion node 

TEMP.2 :«ncwST„USTJ^ODE: 

TEMP.2JlOOT^FAULTaEMP.2.STR'tange) .•» 1EMP_^STR; 

~ Building of procedure body node 

TEMPJ a new ST„USTJ<ODE: 

TEMPJ JlOOT.FAULTCIEMPJ.STTl'rangc):» TEMPJ.STR; 
TEMPJJ4 UMBER_OFj:HILDREN 1: 

- Conditional determines if sim_n or index^empon was used 
if FmST.CHlLD EN_N0DES « NULL then 
NOJPARA ;«TRUE; 

TEMPJ.CHILDRENJ40DES FOIST; 

TEMPJ.CHEi)RENJfODESJ4UMBEILOP_CmDREN > 1; 
cbe 

NOJ»ARA FALSE; 

TEMPORARY new STJJST^NODB; 

TEfdPORARYJlOOTJJAULT :-FIRST.CHlLDRLNJbK)DESJlOCnLFA^^^ 

TEMPJ.CHlLDREN«NODES TEMPORARY; 

TEMPJ.CHILDRENJ40DESFREV_STJTR :«NfUa: 
TEMPJ.CHILDRENJdODESJ4Uf ffiEILOF^Cia^^:«1; 
end if; 


116 





- Identifies the name of the procedure 

PR(X:EDURE_>IAME := RETURN_R(X>TJFAULT(TBMPJ.CIfflJ)RENJ^ODES); 

- For loop to search table to see if procedure is in the table 
for IND^ in 1..COUNTER loop 

if PROCEDURE_NAME « TABLE(INDEX)PJJNAMB then 
FOUND :=TRUE; 

LOCATION:»INDEX; 
end if; 
endloq); 

- Conditional win add sequence of statements to procedure if found 
if FOUI'ID then 

TCEMPJ.CHILDRENJ^ODES.CHILDREN_NODES :» TABLE(L0CAT10N),STMTJTR; 
else 

TEMPJ4F :a new ST^USTJIODE; 

TCMP_bIFROOTJFAULT(TCMP.NF_STR*tange) ;= TEMP_NF_STR; 
•reMP_3.CHILDREN_NODES.CffiLDRENJJODES :«TE^!PJ^?F; 
end if; 

-<• Builds procedure call node 

TEMP :» new ST_LIST_NODE: 

TEMPJROOTJAULTCreMP.STR’range) :-TCMP,S'ni; 

TCMP.TyPE.GATE :aOR^QATE; 

TCMP.CHILDRENJNODES :"TEMP.2; 
TCMP.CHILDREN.NODESPREV.STJ>TR ^TEMPJ; 

~ Will build parameters node if parameters used 
lfNOTNOJ»ARAthcn 

Builds the parameters node and attaches child 
TCMP.4 new STJLISTJ^ODE; 

TBMP_4.ROOTJJAULT(TEMP.4_S-m’range) TCMP.4JTR; 
TCMP.4.NUMBER.OF.CHttJDREN :«1; 

TCMP.4.CraLDRENJ10DES :«FIRST.CHILDRENJJODESJ>REV.STJ»TC; 

TCK1P.CHILDRBNJ'10DES.PIIBV.STJ>T11J?REV.STJPTR :«TBMP 4; 
TBMPJWMBER_OF.CHILDREN > 3; 

ebe 

TCMPJWBEILOF.CHILDREN 2; 

end if; 


RETURN TCMP. 
eodBUEDJIlOCjCALL; 


t^mdion to buiU block stJdemcjUs temple 
fuacdooBUEJDJBLOCK^lMT (FIRST ; STJiSTJJOraJTR; 


117 





SECXDND :ST_LIST_NODE FIR; 

THIRD :STJ,ISTJ^ODE_m) 
ittom STJLIST. J^ODE^m is 

TEMP_1 : STJ<IST_NODEJ>TR; 

T6MP_2 ; ST^USTJJODEJTR; 

TBMPJ : STJJST.N0DEJ*TR; 

“IEMPJ ; STJJSTJ^ODILFni; 

TEMP^USTR : STOING(1.^) :■ "Block Statement Caused Fault •; 
TEMP_2_S‘IK : S‘nUNO(l.^) "Exertion C«n!c<^ Fault *; 
'IEMPJ_5TR. t STRING(1„24) "Block Body Fault 
T®MFj 4_STR; STOING(1,»34):» "ExcejAion Frapagated Caused Fault"; 

- Building block body node 

TEMPJ :*new ST_EIST NODE; 

TCMP_3A001_FAULTCreKS»J_STR’range):=TEMP 3 STR; 
•raMPJJWMBBB^OF^CHILDREN := 1; 
TIMPJ.CHILDREN.NODES > SECOND; 

- Building Exception Node 

TKMPJI ;■ new ST^USTJ^ODE; 

'reMP_2JlOOTJJAULT(TEMP_2„STR’range)TEMP 2 STR; 
TCMF_2>IUS.ffiER.OF_CHILDREN 1; 

- Conditional to dctenBtote if excqjtion declared in Wock 
if THIRD/e NULL then 

TEMP_2.CHDLaDREN_NODES :«THIRD; 
else 

“TEMP-* J-ncwST.USTJ^ODE; 

TBMP_4.ROOTJFAULTfiEMPjl_SlR'i«»ge) :»TEMP 4 STR; 
11MPJLCHILDRENJ<0DES ;mTBMP 4; 

endif; 

~ Built&g bead node for template 

EBMP_1 :-newST„USTJ^ODB; 

TEMF^UCKJTJFAULTaEMP.UTRVange) > TEMP.ljSTR; 

»»Conditkmal to see if block named 
if FIRSTS NULL then 

- Assigns niuite as child of block 
TBMFJ J^IUMBm.OP^CH^J)ftEN1; 
TBMP.LCHE^RENJNODES :• FIRSTS 


- Asttigns ebSdren to ruune block 
FIRST.TYFE^OATE .•-OILOATE; 

PmST,NUMBER.OF„CHILDREN ;-2; 
F1RST.CHILDRENJ«>DBS TEMPJ; 
P1RST.CMIUHIBNJI0I«SJ>RBV^STJP1R > TEMPJ- 


118 


dse 


- No name assigned to block 
TEMP_1JWMBER^0F_CHILDREN :»2; 
TOMPJ.TYPE.GA'n :«OR^GATE; 

TOMP^l.CHILDREN.NODES :=TEMP_2; 
TEMPJ.CHILDRENJJODESJ>REV_ST_m := lEMPJ; 
end if, 


return lEMP^l; 
end BUILX>^OCaL.STMr; 


- Funnion to Join list of exceptiicms 

function JOlNJBXCEPnONS (FIRST : STJUST_NODBJ>TR; 

SECOND ; STJ.IST_NODBJFIR) 
return STJUSTJ^ODEJTR is 

begin 

if FIRSTNULL then 

SECOND.CHILDREN_NOOESFREV^ST_FmCHILDREN_NODES FIRST; 
SECOND.aiILDRENJ^ODESFREV_ST_FnLNUMBER„OF_,CHttI)REN:= 1; 
end if; 

return SECOND; 
endJOINJBXCEPTiONS; 


» Function to build template for one excretion 
- Assumes 1 exoqtdon per altomative and simple not concat name 

function BUlLDJBXCEPTrON (FIRST ; STJJST_NODE_m: 

SECXKMD '.STJLBTJNODEJTO) 
return STJLIST_NODEJPTR is 

TEMP ; STJ.lST^NODB_nR; 

TBMP^ rSTJUSTJ^ODBJPTR; 

TBMP.STR :SlRINO(L.13);-"Bxception(s)‘; 

TBMPJB JTR; STIIIN0(1..19)“Other Exceptiools) “; 

begin 

» Building other exceptions node 

TBMPJB ;-newSTJJSTJIODB; 

TEMP^AOOTJ*AULTCI1MP^JTR’rangc) > imi?JB>STR; 


119 






- Building Excqidons node 
lEMP := new STJLBTJ^ODE; 

TEMPJl(X)T_FAULT(lEMP_S‘IR^ge) :«TEMP.STO; 
lEMP.TYPEjGATE >OILGATE; 

TEMPJ^UMBERjOF^CHILDREN 2; 

TEMP.CHILDREN_NODES :«FIRST; 

TEMP.CHILDREN_NODES.CHILDRENJ^ODES ;» SECOND; 
TEMP.CHILDREN_NODESJ>REVJSTJTR ;=TEMP_B; 

RETURN TEMP; 

end BUILD JBXCEPTION; 


» Function to build function call template if required 

function CHECK_FUNCTION (FIRST : STJJSTjaODEJTR; 

TABLE tSYS.TABLE; 

COUNTER: INTEGER) 
return STJJSTJNODEJTRis 

TEMP : ST_LIST_NODEJTR; 

TEMP.2 : STJJSTJIODEJPTR; 

TEMPJ : STJJSTJ^ODEJPTR; 

TEMPJ :STJJST_NODEuPTR; 

TEMP.STR :STRINQ(l„27)^«Tunciion Call Caused Fault”; 

TEMPJ_STR :STRINO(1..34) TuncUcm Elaboration Caused Fault ”; 
TEMPJ.STR : ST1UNG(1..27)"FuncUon Body Caused Fault"; 

TEMP.4_STR : STRIriOU m 24) "Parameters Caused Fault *; 

FUNCnONJ^AME: STTUNGd.JtlAX.CHARJJONO)(OTHERS =>' ’); 
FOUND : BOOLEAN :>■ FALSE; 

NOJ>ARA ; BOOLEAN :«FALSE; 

LOCATION : INTEGER; 

begin - Function Check Function 

- Determines location of name (Simple name or index component) 
if FIRST.CHILDRENJ40DES - NULL then 

NOJPARA .“mTEUE; - Simple name used 
end if; 

- Returns the name of the function, if it ii a (iinctioa 
ifNOJ*ARAthen 

FUNCTIONJ4AMBRETURNJROOTJ>AULT(FIRST); 
else 

FJNCHONJNAME:« RETURNJt00T^AULT(FlIBT.CHIL0RB4J40I^); 
end if; 


120 





- DetNinines if it is on the Proctdure/Punction Table 
for INDEX in l..(X)UNTERIoop 

if FUNCnONJiAME » TABLE(INDEX)PJFJ^AME then 
FOUND :»TRUE; 

LOCATION INDEX; 
end if; 
endloop; 

- If not on table then lebun pointer sent in, if found then 

- return Function Call Template 

if NOT FOUND then 

~ Name not found on table therefore return ori^nal node 
return FIRST; 

ELSE 

TEMP 2 :« new ST_UST_NODE; 

TEMP_2JlOOTJJAULTCrEMP_2_S'IR'range):» TEMP_2_STO; 

TBMP_3 :» new ST_USTJ<ODE; 

TEMP 3JlOOTJPAULT(TfiMP_3_STR'range):=TEMPJ_STR; 
TEMP_3JWMBER_OF_CHILDREN :»1; 

- The name of the function 
ifNOJ>ARAthen 

TEMPJ.CH1LDREN_N0DES ;»FIRST, 

else 

TEMPJ.CHE,DRENJ<ODBS ;»FIRST.CHILDREN_NODES; 

end if; 

TEMPJ.CHI1I)RENJ<0DES JJUl^EILOF.CHILDREN:»1; 

-* The sequence of statements for the name 

TOMPJ.CHILDRENJ«)DES.CHILDRENJNODES ;• TABLE(L0CATI0N)5TMrjTE; 

- Builds function call node 

TEMP new ST.USTJ10DE; 

TEMPJROOTJJAULTCIEMPJITR’range):« TEMP.STR; 

TCMP.TYPE^OATE :»OILOATE: 

TOMP.CHILDRBNJ^ODES r-TEMPjZ; 

TEMP.CHILDRENJNODES J>REV_STJ>TO :• TEMPJ; 

- Conditional to build parameters node if needed 
ifNOTNOJPARAthen 

Builds the parameters node and attaches child 
TEMPJ :-.newSTJLISTJNODE; 

TEMPJ JlOOTJPAULT(IEMP_4.STR’iange):« TBMPJJTR; 
TEMPJJWMBER_OF„CHILDREN 1; 

TBMPJ.CHaJ)RENJ«)DBS :«FIRST.CHIU»ENJ40raBSJ»REV_STjn[^ 
FIRST.CHILDREN_NOI«ESi»REVJTJTll i-NUlL; 


121 



TEMP.CHnj)RENJ^ODESJ»REV_STJ>mPREV STJTRr-lEMPjt; 
TEMPJ'IUMBEILOF.CHILDREN :«3; 

else 

TEMPJWMBER_OF_CHILDREN:« 2; 
end if; 


mumlEMP; 


end if; 

endCHECILFUNCnON; 


- Function to build raise statement template 

function BUILDJIAISE (FIRST : STJJST_NODE_PTR) 
retum STJLISTJJODEJTR is 

TEMP : STJ-ISTJ^ODEJTR; 

TEMP_2 : STJ.ISTJ^ODEJ>TR; 

TEMP_3 : ST_LIST_NODEJ»TR; 

TEMP_4 : STJ-ISTJ40DEJ*TR; 

TEMP_STR : STIUNQ(1.,29):«"Raise Statement Caused Fault"; 
TBMP_2_STR: STRINO(1..36) :■ "Wrong Excq)tion Raised Caused Fault *; 
TEMP_3_STR: STRINQ(1,.31) ;• "Exception Handler Caused Fault"; 
TEMP_4_STR : STRING(1.33):«"Exception not defined in program"; 

begin 

TEMP_2 :»newSTJJST^NODE; 

TEMPJl JlOOTJ»AULT(IEMP_2_STR'range):» TEMPJ_STR; 

TEMPJ new ST_USTJ40DE; 

lEMP>3JROOT_PAULTriEMP_3_STR'range) :■ TEMPJ_STR; 

- Conditional to detennine if exc^^tkm stated 
if FIRST/-NULL then 
TEMPJ J4UMBER.OF.CHILDRBN1; 

TEMPJ.CHILDRENJIODES :• FIRST, 
else 

TEMPJ new STJUSTJIODE; 

TEMPJJIOOTJAULT(TEMP_4JTR’range)TEMPJJTR; 

TEMPJ.NUMBEBwOF_CHILDREN1; 

T1MPJ.CHILDRENJIODES TEMPJ; 
end if; 

TEMP :«newSTJLISTJIODB; 

TBMPAOOTJ’AULTOEMPjSTR'range) t-TBMPJTO; 


122 







TEMP.TYPEjGATE ORJjATE; 

TEMPJ^UMBEiLOP.CmDREN := 2; 

TEMP.CHILDRENJ^ODES >miP_2; 

TEMP.CHILDREN_NODESJ>REV_ST_PIR :=TEMP_3; 

letum IBMP; 

endBinLDJlAISE; 


- Funcdon to see if excq>tion in exception table 

fiinction CHEOCJEXCEPT (FIRST : STJ.ISTJIODEJ>TO; 

EXJTAB : EXCEPT^TABLE; 

EXCEPT.COUNTER : INTEGER) 
return STJ-ISTJIODEJTR is 

TEMP ; ST_LIST_NODEJTR; 

TBMP_STE : STRING(1..23) :■ "Exception not on table 

NEW_pm : STJ-ISTJ^ODEJPTO ?= new STJ,1STJ^0DE; 

EXCEPnONJ^AME : STRINQ(l.MAX_CHAIU-ONG):« (OTHERS -> ’ ■); 

FOUND ; BOOLEAN :»FALSE; 

LOCATION : INTEGER; 

begin 

- Conditional to detennine if exce|)tion name stated 
if FIRST-NULL then 
return FIRST; 
else 

Assigns name of excq)tion to variable 
EXCEFnON_NAMBRETURN.ROOTJ»AULT(PIRST); 

- Loop will determine if exception is on table 
for INDEX in L.BXCEPT_COUNTBRIoop 
if EXCEPTION J^AMB - E3LTAB(INDEX)£XCEPTJ4AME then 
FOUND :-TRUB; 

LOCATION INDEX; 
end if; 
end loop; 

if FOUND then 

~ Option will attach sequence of statements for exception 
NBWJPTR :-BX_TAB(LOCA’nON)EXCEPTJTR; 

FIRST.CHILDRENJ^ODES j-NBWJTR; 
FIRSTMJMBEILOF.CHILDREN1; 
else 

- Option will create node stating exception not defined 
TEMP t-newSTJJSTJTODB; 


123 







TEMPJlOOTJ’AULT(TBMP_$TR'range):» TEMP_STR; 


FIRST.CHILDREN NODES 
FIRSTJiUMBEILOF_CHILDREN 
end if; 

return FIRSl^ 
end if; 

endC3ffiCILPXCEFr. 


end FAULT_'niEE_GENERATOR; 


.•sTBMP; 

:»!; 


124 






C PACKAGE SPECIFICATION FOR TRAVERSE PACKAGE 


with TEXT JO, FAULT.TOBE^GENERATOR; 
use TEXTJO.FAULT^'IHEE.GENERATOIl; 

padcage 7RAVERSE_FKG is 

pisckage INTEGEILir^OUT is new INIBGEILIOaNraGER); 

Bse INTEGaLINOUT; 

package BOOiEAN_INOlIT is new ENUMERATIONJO(EOOLEA>0; 
use BOOLEANJNOUT. 

MAXJIODES: INTEGER:»iOOO; - Aibitraiy numlber 

subtype NODE JJUMBER isINlEOER range O..MAXJNODES; 
subtype LEVELJIUMBER is INTEGER tangeO.AlAX J^ODES; 
subtype QUEUEJJST is INTEGER range O.A4AX_NODES; 

•> Declaration of variables for Queue 
^ QUEUEJtECORD is 
record 

N(M)E : STJ,ISTJ!0DE_P1R; 

NODEJIO tNODEJlUMBER; 

LBVELJ40 tLEVBU'IUMBER; 
end record; 

type QUEUE is airay (1. JdAX JIOOES) of QUEUE JIECORD; 

TOEB : QUEUE: 

FRONT : QUEUEJJST :-0; 

REAR ; QUEUEJJST :-0; 

PARENT ;STJISTJIODEJ>TR; 

CHILD : STJISTJIODEJ>TR; 

EMPTY.QUE : BOOLEANFALSE; 

PARENT JIO :NODEJNUMBER .--O; 

CHILDJIO :NODEJIUMBER ;-0; 

COUhnER :NODE_NUMBER :«0; 

GATE ; STR1NQ(1..5) (others ^ ’'); 
OATB„VALUE;OATE,TYPB ;-0; 

~ Declaration of variables for stick 
typeSTACKJECORDis 
record 

NODE : STJISTJNODBJTR; 

NODEJIO: NODEJIUMBER; 


123 








end record; 


type STACK is array (l..MAXJ^ODES) of STACKJ^CORD; 

TEMP.STACK : STACK; 

MAIN_STACK .‘STACK; 

MAXSTK :INm}ER >MAXJ40DES: 

TOP ;INTEGER :«0; 

TJTOP ; INTEGER ;«0; 

function IS_EMPTy (FRONT: QUEUE.UST) return btxdean; 

procedure ENQUECITREE tinoutQUEUE; 

FRONT ; in out QUEUE_LIST: 

REAR : in out QUEUE_UST; 

POINTER : in out STJJST„NODEJ>TR; 

NUMBER : in out NODE_NUMBER; 

LEV_NO : in out LEVEL_NUMBBR); 

procedure DEQUE (TTRBE : in out QUEUE; 

FRONT ; in out QUEUE_UST; 

REAR : in out QUEUEJJST; 

POINIER : outSTJLISTJNODBJ>TR; 

NUMBER : outNODE_NUMBER: 

LEVJJO ; outLEVEU4UMBBR); 

procedure TRBE_TRAVERSAL (ROOT : STJJSTJNODEJ>TR); 

procedure FIEJPILBl (ROOT ; STJJSTJ^ODEJTR); 

functkm EMFTVa^ : INTBOBR) return boolean; 

pocedBre PUSHCr.STACK : in out STACK; 

TOPJIO ; in out INTEGER; 

NOE® :ao8,‘STJJST.NODBJTR); 

piocftfere POP CLSTACK ; to out STACK; 

TOPJ^O jInowINTSOER; 

NODE : outSTJJSTJWDEJTR); 

pioce^ CREATEJPHE (ROOT : ST.USTJ'tODEjTR; 
PrE^Ftt£;IPILia.TyPE); 


CUdTRAVERSB^G; 





D. PACKAGE BODY FOR TRAVERSE PACKAGE 


package body IRAVERSE^KG is 


function IS.EMPTY (FRONT: QUEUEJJST) return bodean is 

begin - function is.empty 

ifFRONT-Othen 

fstumtiue; 

else 

letuinfidse; 
end if; 

cndIS.EMPTY; 


procedure ENQUE(T7REE : in out QUEUE; 
FRONT tinoutQUEUE.LIST; 

REAR : in out QUF.UEJUST; 
POINTER :inoutST„UST_NODE_nR; 
NUMBER ;inoutNODE_NUMBER; 
LEV_NO :inoolLEVElJ^UMBER)is 

begin ~ procedure enque 


if FRONT »1 and REAR « MAXJNODES then 
new^Une; 

putjincCOVERFLOW ERRCKl. *); 
ncwjine; 
else 

if FRONT MOdien «Queu6cnw 

FRONT 1; 

REAR >1; 

elsifREAR-MAXJlODEStlKO -At end of queue 
REAR :«1; 

else -Incteinemcpieue 

REAR .‘•REAR'fl; 
end if; 

T1REE(RBAR)N0DE :*POINTBR; 
TrREE(REAR)NODEJ^O NUMBER; 
TlREEfREARUSVEUWLEVJ^O; 
end if; 

endENQUE; 


procedure DEQUE (TfREE ; in out QUEUE; 
FRONT : in out QUEUE JJST; 


127 



REAR : in out QUEUEJJST; 

POINTER ; out STJ,IST_NODEJ»Tll; 
NUMBER : outNODEJ^UMBER; 
LEVJ«IO : outLEVElJWMBER)is 

begin - procedure deque 

ifFRONTaOlfaen -Trying to deque null 

new_Hnc; 

puLlMTJNDERFLOW ERROR. 
new.line; 

POINTER > TIREECFRONTT J^ODE; 

NUMBER ?.*nREE(FRONTTJ«ODE.NO; 

LEV_NO :-TTREE(FRONDXEVELJNO; 
if FRONT* REAR then -1 item in queue 

FRONT fO; 

REAR :a0; 

elsif FROI'rr* MAXJ<IOD£S then - At end of queue 
FRONT :»1; 

else -Anywhere in queue 

FRONT ;• FRONT ♦ 1; 
endif:-iffi(ont*rev 

end if; - if front * 0 


end DEQUE: 


procedure TREE„TRAVERSAL (ROOT: STJUSTJ^ODE^FTR) is 


DUMMY^VAJUABIE; INTEGER >0; 
begin - procedure tree_treveml 

- IniiMizatioo of Variables used 
FRONT :-0: 

REAR :-0; 

EMPTY^QUB :* FALSE; 

PARENTJJO >0; 
aSLDJiO :«0; 

COUNTER :*0; 

GATE.value :-0; 

- ifeadkii fbrtcaweaal 
Mwjine; 

SET.COLdI): 

PUraiTERAL TREE OUTPUT"); 


t2E 




new_line; 

SET.COUU); 

PUT(---); 

new_line(2); 

SBT.COUIT); 

PUT ("Parent"); 
new_!ine; 

PUT ("Parent"); 

SET_COL(ll); 

PUT ("Node"); 

SET.COmS); 

PUT ("GATE"); 

SET_COL(24); 

PUT (Tault for Node"); 
newjine; 

PUT("-•); 

SET_COL(ll); 

PUT ("—"); 

SET_COL(18); 

PUT ("—"); 

SET_COU24); 

PUT("-"); 

new_line; 

~ Setting Head of tree to the root 
PATIENT := ROOT; 

ENQUECTREE, FRONT, REAR, PARENT, PARENTJ^O, DUMMY.VARIABLE); 

~ Printing taie values of the toot 
new_iine; 

SET_COL(7); 

PUT ("=>"); 

PUT (PARENT JiO, width => 5); 

SET_COL(18); 

PUT("NuU"); 

SET_(X)L(24); 

PUT (RETURN_ROOT_FAULT(PARENT)); 
new_Une; 

- 'Haversing the remaining nodes and printing the values 
whUe not IS_EMPTY(FROND loop 

DEQUECTREE, FRONT. REAR, PARENT, PARENTJ^O, DUMMY_VAR1ABLE); 

ifPARENT/a NULL then 

- Sets pointer to first child 

CHILD:« RETURN.Gm .D(PARBND: 

Function will retrieve gate type of parent 
GATEuVALUERETURN.GAm-TYPE(PARENT); 


129 







- Conditional to convett type gate from integeii’ to string 
if GATE_VALl]E»Othen 
' GATE:=*Wull"; 

elsif GATE_VALUE = 1 then 
GATE:*"And 
dse 

GATE:."Or "; 
end if; 


—IMnts children and puts children on queue 
if CHILD/= NULL then 

-* Conditional determines the child and puts the child on anay 
while CHILD /* NULL loop 
COUNTER :a COUNTER +1; 

CHILDJ^O:= COUNTER; 
new_line; 

PUT (PARENTJNO, width »> 5); 

SET_COL(7); 

PUT (*»>"); 

PUT(CHILD_NO. width «> 5); 

SET_COL(18): 

PUT (GATE); 

SET_COL(24); 

PUT (RETTJRNJlOOT_FAULT(CHILD)); 
new^line; 

BNQUECTREB. FRONT, REAR. CHILD. CHILDJMO, DUMMY^VARIABLE); 
CHILD;« RETURN_CHELDJPREV(CHILD); 
end loop; - while cliiid... 

end if; ~ if child... 

end if; - if parent.. 

end loop; - white noL. 


endTREB_TRAVERSAL; 


procedure PTEJTLBl (ROOT: STJJSTJiODE.PIR) is 


DUMMY^VARIABLB: INTEGER 0; 
begin - procedure FTEJTLE 


- Initializadoo of Varieties used 
FRONT tmO; 

REAR :»0; 


130 



EMPTY.QUE 


:= FALSE; 


PARENTJ^O :=0; 

CHDLD.NO :»0; 

COUNTER :a0; 

GATE.VALUE :=0; 

- Heading for traversal 
newjinc; 

SET.COUll); 

PUT("FTE PILE OUTPUT-); 
new_line; 

SET_COL(ll); 

PUT (--•); 

ncw.Une; 

new_line; 

SET.COLdl); 

PUT ("Node"); 

SBr_COL(24); 

PUT ("Fault for Node"); 
ncw_Une; 

SET.COLdl); 

PUT ("—•); 

SET.COL(24); 

PUT(»-•); 

new.line; 

~ Setting Head of tree to the root 
PARENT;* ROOT; 

ENQUECIREE. FRONT. REAR. PARENT. PARENTJ^O. DUMMY.VARIABLE); 

- Printing the values of the loot 
new.line; 

SET.COLdl): 

PUT (PARENT JIO. width «> 5): 

SET.COL(24); 

PUT (RETURN JlOOTJ^AULTfPARENDX 
new.lino; 


~ TVaveiling the temaining nodes and priming (be values 
while not IS.EMPrV(FRONT) loop 

DEQUECTREE, FRaNT, REAR. PARENT. PARENTJ^O. DUMMY.VARIABLB); 

ifPARENT/a NULL then 

-> Sets pointer to fust child 

CHILDRETURN.CHILD(PAREND; 


131 










- Prints children and puts childiai on queue 
if CHILD/-NULL then 

— Conditional determines the child and puts the child on array 
while CfflLD /« NULL loop 
COUNTER COUNTER +1; 

CHILD_NOCOUNTER; 
newjine; 

SET_COL(ll); 

PUT (CHILD J^O. width->5); 

SET_COL(24); 

PUT (RETURN JlOOT_FAULT(CHILD)); 
new„Iine; 

ENQUECIREE, FRONT, REAR. CHILD. CHILDJ*IO, DUMMY VARIABLE); 
CHILD :■ RETURN.CfflLDJ‘REV(CHILD); 
end loop; ~ while chilcL. 

end if; -if child... 

end if; - if parent.. 

end luq); - while not.. 


endFIEJ^l; 


function EMPTY(TOP : INTEGER) return boolean is 

begin ~ Function Empty 

ifTOP-Othen 
return TRUE; 
else 

return FALSE; 
end if; 

end EMPTY; 


procedure PUSH (T„STACK : in out STACK; 
TOPJ^O tin out INTEGER; 

NODE ; in out STJJSTJ^ODEJTR) is 


begin 

if TOPJ»lO - MAXSTK then 
NEWJLINB; 

PUTJJNE("OVERFLOW. ERROR. ERROR.*); 
NEWJJNE; 

TOPJIO :-TOPJI04l; 


132 






T_STACKCrOPJ^O)NODE :*NODE; 
end if; 

end PUSH; 


procedure POP (T_STACK : in out STACK; 
TOPJ^O : in out INTEGER; 

NODE : outST_USTJJODE_PTR)is 


begin 

ifTOP_NO = Othen 
NEWJLINE; 

PUTJLINE(-UNDERFLOW. ERROR. ERROR"); 
NEWJ.INB; 
else 

NODE :«T_STACK(TOP_NO)J^ODE; 
TOP_NO :=TOP.NO-l; 
end if; 

end POP; 


procedure CREATEJTLE (ROOT : ST_LISTJ<ODE_PTR; 
FTEJ5LE;FILE_TYPE)is 

» Declaration of local variables used in procedure 
BJLINE ; NATURAL >0; 

BJ.INE : NATURAL :«0: 

X. COORD ;INTBOBR :»0; 
y^CODRD : INTEGER ;«0; 

VARIABLE : INTEGER ;-0; 

TOGGLE : BOOLEAN FALSE; 

VARX ; constant INTEGER:-75; 

VARY : constant INTEGER;-85; 

LEVEL„CHO : INTEGER :»0; 

Y. LEVELJIO : INTEGER :«0; 

PLEVH.J40 : INTEGER :-0; 

CLEVELJ^O : INTEGER :«0; 

OLDJ>LEVEL : INTEGER :-0; 

LAST.CHAR ; INTEGER :«0; 

LABEL :STTUNG(LJ^tAX.CHAR_SHORT):-(OTHERS *>''); 
ROOTJJAULT :STlUNO(l..MAK.CHARJLONO) f (OTHERS «>’•); 
FILEJ^AMB ; ST1UNG(l.AiAX.CHARJLaNG)(OTHERS ' *); 


133 









begin 


- Lnitializatkm of variables declared in ^ificarion 
FRONT :«0; 

REAR :-0; 

EMPTY.QUE :• FALSE; 

PARENTJIO 
CHILD.NO :»0; 

COUNTER :«0; 

GATE.VALUE :-0; 

- Setting Head of tree to die root 
PARENT:» ROOT; 

ENQUEOREE. FRONT, REAR, PARENT, PARENT_NO, PLEVBLJ^O); 

PUSHJ-ABEL (PARENT, INTE0ERTMAGE(PARENTJ40)); 
PUSH_FILE_N (PARENT, "EXAMPLE.A"); 

PUSH_X COORD (PARENT. X_COORD); 

PUSH_Y_COORD (PARENT. Y_COORD); 


~ Traversing the remaining nodes and printing the values 
while not IS JSMPTY(PROND loop 

DEQUECTREE. FRONT. REAR,PARENT, PARENTJIO, PLEVELwNO); 

if PARENT/-NULLthen 

if PLE VELJ^O /• OLDJ>LEVEL then 
X_COORD ;-0; 
end if; 

- Sets pointer to first child 

CHILDRETURN„CHILD(PAREND; 


~ Prints children and puts children on queue 
if CHILD M NULL then 

- Conditional determines the child and puts the child on array 
while CHILD/-NULL loop 
COUNIBR COUNTER ♦ 1; 

CHEJ)J40:« COUNTER: 

PUSHLLABEL (CHILD, INIEQER1MA0E(CHILDJ40)): 
PUSHJWN (CHILD. "EXAMPLE.A"); 

PUSlULCOORD(CHILD. K.COORD); 


134 



x_coord := x_coord+vane; 

PUSH_Y_CC)ORD(CinLD, RETURN_Y_COORD(PARENT) + VARY); 
C3-EVELJ^0 ;»PLEVEL_N0 + 1; 


ENQUECIREE, FRONT, REAR, CmLD,CHILDJ^O.CLEVEL NO); 
CHILD := RETURN_CHILDJ>REV(CHILD); 

if CHILD® NULL then 
OLD.PLEVEL;« PLEVELJ<0; 
end if; 

end loop; - while child... 
end if; - if child... 

end if; ~ if parent., 

end loop; - while not.. 


— Initialization of variables 
PARENT.NO :«0; 

CHILDJ^O ;=0; 

COUNTER ;a0; 

~ Placing the root node into the stack 
PARENT :®ROOT; 

PUSH(MAIN_STACK, TOP. PARENT); 

— Conditional to do depth first traversal of tree 
while NOT EMPTY(T0P) loop 

POP(MAIN_STACK. TOP. PARENT); 

- Putting the label of node into the now file 
LABEL RETURNJ-ABEL(PAREND; 

LAST.CHAR :• LABEL! AST; 

while LABEL(LAST„CKAR) - ’ * and LAST CHAR /- 0 loop 
LAST_CHAR:«LAST.CHAR.l; 
endloq); 

ifLAST_CHAR-Olhcn 

PUT(FrBJfTLE.*-); 

NEWJLINE(FTEJP1LB>; 

else 

PUT(F1:E„PILB,LAjjEL(IXAST_CHAR)); 

NBWJLINE(FnLFiLE); 

endif; 

~ I^itting the fault of the node into the new file 


135 










ROOTJ*AULT :*:RETORNJlOOTJfAULT(PAREND; 
LAST_CHAR i-ROOTJ’AULTLAST; 


while ROOTJJAULT(LAST_CHAR) = * ‘ and LAST^CHAR h 0 loop 
L AST.CHARLAST.CHAR -1; 
end loop; 

ifLAST_CHAR«Othen 

PUT(FTEJTLE/*); 

NEWJLINE(FTEJ5LE); 

else 

PUT(Fre_FILE, ROOT^FAULTXIXAST.CHAR)); 
NEWJ.INE(Fra;„FILE); 
end if; 

- Putting file of node into the new file 
FILB_NAME :«RETURN_FE£JJAME(PAREND; 

LAST_CHAR :-FILE_NAME'LAST; 

while FILE_MAME(LAST_CHAR) *' * and LAST.CHAR /W 0 loop 
LAST.CHAR:« L AST_CHAR -1; 
end loop; 

if LAST CHAR-O then 
PUTaTEJ^.""); 

NBWJ.INE(FTEJTLE); 

else 

PUT(FTE_FILE, FILEJIAMB(1.XAST_CHAR)); 
NBWJLINE(FrejPILB); 
end if; 

- Putting line 4 of node(Line no's, X & Y coord, node, gate, children) 
PUTfFTEJPILB, RETURNJTARTJL(PARENT). width »>0); 
PUT(FTEJTLE,”); 

PUT(FTEJPn-B,RETURN_END_L(PARBNT), width->0); 
PUT\FTBJ’ILB,' y, 

PUTCFTEJTLE, RETURNJf_COORD(PARENT). width »>0); 
PUT(FTE_FILB."); 

PUT(FTEJFILB,RETURN_Y_.COORD(PARB>rn. width «>0); 
PUT(FTBJILB,"); 

PUT(FTOJ>ILa RETURNJ40DE_'rYPE(PARBNT), width->0); 
PUT(FTBJ>ILB,"); 

IVr(niJ=lLB,RETURN.OATEjrn«(PARBN^ width->0); 
PUTfFlTBJFILB,"); 

Pirr(PTBJTLB. RBT\JRNJ40.CHILDRBN(PAREND, width -> 0); 
NEWJUNECPTBJPILE); 

CHILDRETURN.CHaJXPARENl): 
if CHILD/-nuU then 

~ Conditional to determine children of par^ 


136 




while CHILD fa null lo(^ 

COUNTER :« COUNTER +1; 

CHa,D_NO := COUNTER; 
PUSHCmMP_STACK, T.TOP, CHILD); 
CHILD :»RETURN_CHILDJPREV(CHILD); 
endlcK^; 

- Conditional to place children on stack in order 
while not EMPTYCTJTOP) loop 
POP (TEMP_STACK. T.TOP, CHILD); 

PUSH (MAIN^STACK. TOP, CHILD); 
end loop; 

endiP, 

end loop; 

endCREATB_FILE; 


end TRAVERSE J»KG; 


137 








APPENDIX C: ADA STRUCTURE TEMPLATES 

Sequence of Statements Template 



Sequence of statements template was not depicted in the 
works of Leveson, Cba, and Shimeall. 


138 











* There is no difference between the tool generated Assignment Template 
and the Leveson, Cha» and Shimeall template. 


5 . 


139 









If St M M l W It 

CMtMdntaK 



* The Leveson, Cha, and Stt^meali template dfd n^ disdngntsh between the 
associated nodes and the **etsir* ass^idated nodes, hut tool general^ 
template presented the two separately. 


140 




























wiM| i>p« or t<M# utMi 


SdlMM 


CWM*mail 


GwtttMTttwrM 

N'lIuntiM 



* The tool generated Loop Template distinguisiied between, the differoit types 
of loops and expanded the assodUded ^Sxmfitioa’* nodes and the Leveson^ Cha 
and Shimeall template did not 

























Case Template 


CiMStKf ft 
CtaMdFkall 


n 



* Hfe tool generated Case Template piiyskally placed tlte ‘T)t!ier*s Clause 
Caused Fault” and associated nodes on a tower level then tbe Leve^, Cha, 
and Shimeall template, nevertheless, the two templates are equivalent. 


142 




















Procedure Call Template 



* The too! g'^nerated Procedure Call Template added the node 
<<Procedure Elaboration Caused FaulP’ to the template ft*om 
Leveson, Cha, and Shimeall. 


143 














* The S^ncdon Call Template was not depicted in the works 
of Leveson, Cha, and Shimeall. 


144 















Tlie tool generatod BlocJt Statement Template elaborated more 
on die ‘‘Exception Caused Fatdt** node then did the works of 
Levesim, Cha, and Shimeall. 






















Raise Template 



* There was no difTerence in the Raise Template between the tool 
generated and the Leveson, Cha, and Shimeall templates. 






Division and Multiplication Template 


DiTWoi^ultipUcaltai 
ExpnMioB CauiMl Fault 



ETahuUoo or L«ft nrm 
CauMd Fault 


E»atMalloaor«/"or“»" 
Cauaed Fault 


Evaluatloa of Rlfht Twm(t) 
Cauead Fault 

Term 

Operator* / DirUlao b; Zero 

Tifm(i) aad/or Operatora 


* Division / Multiplication Template was not depicted in the works 
of L^veson, Cha, and Shimeall. 


147 










Addition and Subtraction Template 


AddttkMi^iibtndiM 
ExpnolM C»uMd Fault 

IT 


Bvilutlloo of L/tft Ttm 
CauMd Fault 


ETaJuatl<»or'V>*or>‘-’' 
CauMd Fault 


BTaluallMi of Ritbi Tina(>) 
Cautad Fault 


S ^ 

Ttrn Ttra(i) tod/or Optfalon 


* Addition / Subtraction Template was not depicted in the works 
of Leveson, Cha, and Shimeall. 


148 












Lift ar Prior RtUttai 
CaaMiPMilt 


RitkiBibNM 

CMJodPUK 



* And Relation Template was not depicted in tbe works 
Levesmi, Cha, and Shimeall. 

















And Then Relation Template 



UftorPrtarRttalioa 


RitliiRcititMi 

CauMdFMlt 


CiMNdr^uR 



AodThtsRtlaUoa 




LdlKdiUoiilhM 


ETtlMt4M«riUtlil 
RitattM CmMi Ftittt 



And Then Relation Template was not depicted in the works of 
Leveson, Cha, and Shimeall. 


ISO 











OrRii*tkM(l) 


* Or Relation Template was not depicted in the works of 
Leveson, Cha, and Shimeall. 


isi 

















RtfttlMI 


* Or Else Relation Template was not depicted in the works of 
Leveson, Cha, and Shimeali* 


1$2 



































* Index Component Template was not depleted in the works of 
Leveson, Cba, and ShimealL 











Range Template 



N4iM«fRaa|* 


^•dAidllMg* 

CuMdftnM 


CftmadPaall 



jbill SiMpti RapfiiMiM 





cmmewM 









* Range Template was not depleted in tbe warks of Leveson^ 
Cha, and Shimeall 


155 



















APPENDIX D: AUTOMATED CODE TRANSLATION TOOL 
OUTPUT FOR PROCEDURE FAKE,OVEN_CONTROL 


A. LITERAL TREE REPRESENTATION 

LITERAL TREE OUTPUT 


Parent 

Parent Node GAIE Fault for Node 


0 «> 
0 s> 

1 ®> 
2 •> 
2 

3 *> 
3 «> 
3 »s> 
7 «> 

7 

8 w> 
8 •> 

10 aO 

11 »£> 
12 -> 
12 «> 
13 *> 

13 •«> 

14 

M «> 
16 «> 
It ^ 
18 -> 
10 
20 

w ^ 

21 

2l =s> 
23 aO 

23 «> 

34 *0 

24 

24 *> 


0 Null Sequence of statements caused fault 

1 Or Last sttuement caused fault 

2 Ot Previous statements caused fault 

3 Null Loop Statonent caused fault 

4 And Last Statement did not mask fault 

5 And Sequence prior to last caused fault 

6 Or Loop never exeotited 

7 Or Loop condition evalutiion caused fault 

8 Or Nth Iteration caused fault 

9 Of Wrong Type of loop used 

10 Or Itemlon scl^me caused fiuili 

11 And Sequence of suuements caused fault 

12 And Coiwlitton true past n-l 

13 Or Pwameterj^iflcationcaus^ 

14 NuU SequeiKe of statements caused (lult 
1$ And Condition true at n-l ia^on 

16 And $»iUcnceofstau»nemskepi(Xxiditk^ 

17 Or IfkintiTiars^^eciOf^causedfi)^ 

18 Or Discreet range caused &u!t 

19 Or statement caused Otuli 

20 Or f^vkMsiEUtemeriScausedfauIt 

21 Null Sequence of statements caused fault 

22 NuU SAMPLE 

21 NuU Range speciHedouse^ 

24 NuU Loop $t»ementcaau»ed fault 

25 And LaiaStatsroent did nm mask fa^^ 

36 And SeqoGiiCspdortoIastauiSod&uli 
S? Or Last statemerd caused fii^ 

28 Or P^cevk^staceme^ caused 
290r 1 

30 Or SAMPLS«3„DURAmN 

31 Or U«p never esecutfid 

32 Or 

33 Or NdiItcsatioac«sied£suti 






26 => 34 Null Sequence of statements caused fault 

27 s> 35 Null Lx)op Statement caused fault 

28 36 And Last Statement did not mask fault 

23 37 And Sequence prior to last caused fault 

32 => 38 Or Wrong Type of loop used 

32 a> 39 Or Iteration scheme caused fault 

33 40 And Sequence of statements caused fault 

33 => 41 And Condition true past n>l 

34 a> 42 Or Last statement caused fault 

34 s> 43 Or Previous statments caused fault 

35 *s> 44 Or Loop never executed 

35 s> 45 Or Loop condition evaluadon caused fault 
35 => 46 Or Nth Iteration caused fault 
37 B> 47 Null Sequence of statements caused fault 
39 48 Or Parmeter^ification caused fault 

41 s> 49 And Condition true at n-1 iteration 

41 s> 50 And Sequence of statements kept condition true 

42 51 Null If statement caused fault 

43 => 52 And Last Statement did not mask fault 
43 »> 53 And Sequence prior to last caused fault 
45 => 54 Or Wrong Type of loop used 

45 55 Or Iteration scheme caused fault 

46 3> 56 And Sequence of statements caused fault 

46 => 57 And Condition true past n-1 

47 s> 58 Or Last statement caused &ult 

47 => 59 Or Previous statements caused fault 

48 => 60 Or Identifier specified caused fault 
48 s> 61 Or Discreet range caused fault 

SI s> 62 Or Evaluation of condition caused fault 
51 »> 63 Or Condition true and statements caused fhult 
51 a> 64 Or ELSIF caused the fault 
55 3> 65 Or Parameter specification caused fault 
57 s> 66 And Condition true at n-1 iteration 

57 3> 67 And Sequence of statements kept condition true 

58 <B> 68 Null If statement caused fault 

59 a> 69 And Last Statement did not mask fault 

59 s> 70 And Sequence prior to last caused fault 

60 «> 71 Null I 

61 s> 72 Null Range specified caused fault 

62 e> 73 Null Relation caused the fault 

63 bo 74 And If condition true 

63 => 75 And If statements caused fault 

64 s> 76 And Previous conditions evaluated to false 

64 3> 77 And Cuirent/future ELSIF caused the fault 

65 s> 78 Or Identifier specified caused fault 

65 79 Or Discreet range caused fault 

68 ■> 80 Or Evaluation of condition caused fault 
68 B> 81 (h* Condition true and statements caused fault 
68 B> 82 Or ELSIF caused the fault 
72 -> 83 Or 1 

72 «> 84 Or SAMPUNQ.DURAnON 


157 









73 >s> 85 Null And Relation caused the fault 
75 s> 86 Null Sequence of statements caused fault 
77 => 87 Or Evaluation of Elsif condition caused fault 
77 => 88 Ot Current ELS.IF caused the ^t 

77 => 89 Or Other ELSlFs caused the fault 

78 => 90 Null I 

79 91 Nun Range ^)ecified caused feult 

80 s> 92 Null Relation caused the fault 

81 => 93 And If condition true 

81 ^ 94 And If statements caused fault 

82 cs> 95 And Previous condidmis evaluated to false 

82 96 And Cuirent/futuxeELSIF caused the fault 

85 => 97 Or Left or Prior relation caused faidt 

85 ao 98 Or Right relation caused fault 

86 s> 99 Or Last statement caused &ult 

86 s> 100 Or lYevious statements caused fault 

87 B> 101 Null Relation caused die fault 

88 102 And Current ELSIF condition caused the fault 

88 s> 103 And Current ELSIF sequence of statements cmised tire fault 

89 B> 104 Null ELSIF caused the fault 

91 ■> 105 Or 1 

9! ■> 106 Or SAMPLING^DURATION 

92 a> 107 Null And Relation caused the fault 

94 B> 108 Null Sequence of statements caused fault 
96 <B> 109 Or Evaluation ofEIsifcondition caused fault 
96 0 110 Or Current ELSIF caused the fault 

96 o 111 Or Other ELSlFscaused the fault 

97 o 112 Null Relation caused fault 

98 »> 113 Null Reladofl caused the fault 

99 o 114 Null Assignment Statement Fault 

100 «» 115 And Last Statement did not mask fuilt 

100 e> 116 And Sequence prior to last caused fault 

101 a> 117 Null Rel^on caused the fault 

103 3» 118 Null Sequence of statements causer'fault 

104 o 119 And lYevlous conditions evaluated to false 
104 n> 120 And Curreiu/futise ELSIF caused the fault 
107 »> 121 Or Left or friar relation caused lauli 

107 »> 122 Or Right lelatimi cmised fault 

108 123 Or Last statement caused fault 

108 w> 124 Or Previous st^emems caused fault 

109 »> 125 Null Relaticn cruised the fault 

110 a> 126 And Current ELSIF condition caused the fault 

110 127 And Current ELSIF sequence ofst^ements caused the fault 

in «> 128 Null ELSIF caused the lauU 
112 »> 129 Or OVEN.TEMP 

112 ■> 130 Or Addiiion/Subtractioo Fault 

113 «> 131 Ot LAST^CMD 

113 » 132 Or 1 

114 » 133 Or Change in values caused Fault 

114 ■> 134 Or Exception uuses Fault - Not implemented 
114 •>> 135 Or Oper^ Evaluation causes Fattit 


158 






116 s> 136 Ntdl Sequence of statements caused fault 

117 => 137 Or OVENJIBMP 

117 s> 138 Or AdditionySubtracdon Fault 

118 s> 139 Or Last statement caused fault 

118 s> 140 Or Previous statements caused fault 
120 s> 141 Or Evaluation ofElsifcondidon caused fault 
120 «> 142 Or CunentELSIF caused the fault 

120 o> 143 Or Other ELSIFs caused the fault 

121 e> 144 Null Reladon caused the fault 

122 s> 145 Null Reladon caused the fault 

123 146 Null Assignment Statement Fault 

124 >s> 147 And Last Statement did not mask fault 

124 s> 148 And Sequence iniOT to last caused fault 

125 B> 149 Null Reladon caused the fault 

127 => ISO Null Sequence of statemmts caused fault 

128 ISl And Pri^ous conditions evaluated to false 
128 a> 1S2 And Cunent/futureELSIF caused the fault 


130 

s> 

153 

Or 

GOAL.TEMP 

130 

a> 

154 

Or 

Subtraction Fault 

130 

a> 

155 

Or 

10 

135 

*=> 

156 

Or 

LAST.CMD 

13:; 

e> 

157 

Or 

Relation caused the fault 

136 

=> 

158 

Or 

Last statement caused fault 

136 

«> 

159 

Or 

Previous statements caused fault 

138 

O 

160 

Or 

GOAL_TBMP 

138 

»> 

161 

Or 

Addition Fault 

138 

■> 

162 

Or 

10 

139 

=> 

163 

Null Raise Statement Caused Fault 

140 

»> 

164 

And 

Last Statement did not mask fault 

140 

■!> 

165 

And Sequence prior to last caused fault 

141 

»> 

165 

Null Relation caused the fault 

142 


167 

And 

Oarent BLSIP condition causMl the fault 

142 

K> 

168 

And CunentELSIF sequence of statements caused the ftailt 

143 


169 

Null BLSIF caused the fault 

144 


170 

Oi' 

OVEN.TBMP 

144 


171 

Or 

Addition/Subtraciion Fault 

145 

s=> 

172 

Or 

lastj:md 

145 

«> 

173 

Or 

1 

146 

■> 

174 

Of 

Change in values caused Fault 

146 

«> 

175 

Or 

Ext^on caus^ Fatdt Not implemented 

146 

■> 

176 

Or 

Operand Evaluation causes Fault 

148 

*«> 

177 

Null SequoKe of aatements caused fatJt 

149 

«> 

178 

Or 

OVBN.TCMP 

149 


179 

Or 

Addition/Subtnctioo Fault 

ISO 

•> 

180 

Or 

Last statement caused fault 

ISO 

«*> 

181 

Of 

Previous statements caused fault 

152 

«> 

182 

Or 

Evaluation of Elsif condhion caused fault 

152 

•> 

183 

Or 

Current ELSIF caused the fault 

1S2 


184 

Of 

Other ELSIFa caused the fault 

157 

■> 

183 

Null 1 

158 

■t> 

186 

Null Assignment Suuement Fault 


159 












159 s> 187 And Last Statement did not mask fault 
159 B> 188 And Sequence prior to last caused fault 
163 B> 189 Or Wrong Excepdcm Raised Caused Fault 
163 => 190 Or Exception F^dler Caused Fault 
166 s> 191 Null And Relation caused the fault 

168 B> 192 Null Sequence of statements caused fault 

169 s> 193 And Previous conditions evaluated to false 
169 *> 194 And Current/futureELSIF caused the foult 
171 «> 195 Or OOALJiEMP 

171 => 196 Or Subtraction FiUilt 

171 *> 197 Or 10 

176 => 198 Or LAST„CMD 

176 B> 199 Or Relation caus'jd the fault 

177 B> 200 Or Last statement caused fault 

177 B> 201 Or Previous statements caused fault 
179 a> 202 Or GOAL.TEMP 
179 a> 203 Or Addition Fault 

179 *> 204 Or 10 

180 => 205 Null Raise Statement Caused Fault 

181 a> 206 And Last Statement did not mask fault 
131 »> 207 And Sequence prior U) last caused fatilt 

182 «> 203 Null Relation caused the fault 

183 => 209 And Current BLSIF condition caused the fault 

183 B> 210 And Current ELSIP sequence of statements caused the fault 

184 211 Null ELSIF caused the fault 

186 ■» 212 Or Change in values caused Fault 

186 •> 213 Or Exception causes Fault ~ Not implemented 

186 B> 214 0 0)ei^ Evaluation causes Fault 

190 «> 215 NuU OVENJNOT^RESPONDINO 

191 «> 216 O Left or Pdor relation caus6l fault 
191 «> 217 O Right relation caused fault 

191 •» 218 O Last statement caused fault 

192 ■> 219 O Previous staiermsms caused fault 

194 »> 220 O Evaluation of Elsif condition caused fault 
194 » 221 O Current ELSIF caused the fault 
194 »> 222 0 Other ELSlFs caused the flult 

199 223 NuU I 

200 ■> 224 Null A^gnmentStyement Fault 

201 225 And Last Statement did not mask faidt 
201 » 226 And Sequence prior to last caused fault 
20S •*> 227 O Wrong Exception Raised Caused Fault 
^>> 228 0 Bxce^on Handler Caused Fault 

^ 229 Null And Retaiion caused the fiutlt 

210 230 NuU Sequetu^ of staternems caused fault 

211 K> 231 And Pn^ous conditions evaluated to false 
211 ■> 232 And Cutreru/future ELSIF caused the fault 
214 -> 233 O OVEN^BUF 

214 no 234 O Relation caused the fault 

216 M> 233 NuU Relation caused the fault 

217 •> 236 NuU Relation caused the fault 

218 «> 237 Null AssignmemSiateottatFault 


160 





219 s> 238 And Last Statement did not mask fault 

219 s> 239 And Sequence prior to last caused fault 

220 «> 240 Null Relation caused tlie fault 

221 c> 241 And Current ELSIF condition caused the fault 

221 a> 242 And Current ELSIF sequence of statements caused the fault 

224 s> 243 Or Change in values caused Fault 

224 a> 244 Or E:iception causes Fault-Not imptemented 

224 s> 245 Or Operand Evaluation causes Fault 

228 => 246 Null OVEN.NOTJ^ESPONDING 
2^ «:> 247 Or Left or Prior relation caused fault 

229 248 Or Right relation caused fault 

230 s> 249 Or Last statement caused fault 


230 250 Or Previous statements caused fault 

232 «> 251 Or Evaluation of Blsif condition caused fault 
232 s> 252 Or Current ELSIF caused the fault 
232 B> 253 Or Other ELSIFs caused the fault 

234 «> 254 Null 1 

235 => 255 Or OVEN.TEMP 

235 <B> 256 Or Addition/Subtractioo Fault 

236 => 257 Or LAST.CMD 

236 => 258 Or 2 

237 *> 259 Or Change in values caused Fault 

237 260 Or Exception causes Fault-Not implemented 

237 s> 261 Or Operand Evaluation causes Fault 

239 s> 262 Null Sequence of statements caused fault 

240 263 Null Relation caused the fault 

242 264 Null Sequence of statements caused fault 

245 *> 265 Or OVEN.BOF 

245 » 266 Or Relation caused the fault 

247 »> 267 1 w a RwaOon caused the 

248 a> 268 Null Relation caused the fault 

249 •> 269 Null Assignment Statement Fault 

250 £10 And La^ Statement (hd not mask fault 

250 *.' 271 And Sequence prior to la» cruised fault 

251 ■» 272 Null Relation caused the fault 

252 273 And Currant ELSIF condition caused the fault 

252 274 And CurtemEI^IF sequence of staiernenis caused the fault 

25.; »> 275 Or GOAL^TEMP 

256 «> 276 Or Addition Fault 

256 •> 277 Or 10 

261 -> 278 Or LAST_CMD 

261 i*> 279 Or Relation caused the fault 

262 >■> 280 Or Last statement caused fault 

262 281 Or Previous statements caused fault 

263 »> 282 Or OVEN^TEMP 

263 •» 283 Or Addidort/Subtraciion Fault 

264 » 284 Or Last statement caused fault 
264 «» 285 Or Previous staleinems caused fault 

266 >» 286 Null 1 

267 «> 287 Or OVEN.TOMP 

267 <0^288 Or AddMSuUtactioaFault 


161 









268 »> 289 Or LAST.CMD 

268 => 290 Or 2 

269 B> 291 Or Change in values caused Fa>ilt 

269 s> 292 Or Exception causes Fault-Not uitplenicnted 

Wi s> 293 Or Operand Evaluation caih^es Fault 

271 s> 294 Null Sequence of statement; caused fault 

272 295 Null Relation caused the fault 

274 s> 296 Null Sequence of statements caused fault 

279 »> 297 NuU 2 

280 => 298 Null Assignment Stab^ent Fault 

281 s> 299 And Last Statement did not mask fault 
281 s> 300 And Sequence prior to last caused &ult 
283 »> 301 Or OOAL.TEMP 

283 s> 302 Or Subtraction Failt 

283 » 303 Or 10 

284 ■» 304 Null Raise Siatemeat Caused Fault 

285 ■> 30S And Last Statement did not mask f^t 
28S ■» 306 And Sequence prior to last caused fault 
288 =» 307 Or GOAL.TEMP 

288 » 308 Or Addition Fault 

288 -> 309 Or 10 

293 => 310 Or LAST^CMD 

293 m> 311 Or Relation caused the fault 

294 «> 312 Or Last statement caused fault 

294 » 313 Or Previous statements caused fault 

295 »> 314 Or OVEN.TEMP 

295 »> 315 Or Addition/Subtractlon Fault 

296 so 316 Or Last statement caused fault 
296 B> 317 Or Previous statements caused fault 
298 ■» 318 Or Change in values caused Fault 

298 e> 319 Or Exception causes FaultNot impletnenicd 
298 ■» 320 Or (^tenutd Evaluation causes Fault 
304 321 Or Wrong Exception Raised Caused Fault 

304 ■> 322 Or Exception Handler Caused Fault 

311 »> 323 NuU 2 

312 •> 324 NuU Assignment Statement Fault 

313 «> 325 And Ust Statement did not mask fault 

313 326 And Sequence prior to last caused fault 

315 •> 327 Of GOAL^TEMP 

315 ■>> 328 Or SubowitUm Fault 

315 -> 329 Or 10 

316 «> 330 NuU Raise Statement Caused Fault 

317 »> 331 And Last Statement did not mask fault 
317 ■» 332 And Sequence prior to last caused fuilt 
320 •> 333 Or OVEN^UF 

320 334 Or Relation caused the fault 

322 -> 335 NuU OVEN^NOTJRESPONDING 

324 «> 336 Or Change in values caused Fault 

324 m> 337 Or Exce^on causes Fault - Not im^eincnted 

324 <*> 338 Or Oper^ Evaluaiioc causes Fault 

330 » 339 Or Wrong Excepdoo Raised Caused FauU 


162 







B. FTE NODE LISTING 


PTE FILE OUTPUT 


Node Fault for Node 


G 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 
11 
12 

13 

14 

15 

16 

17 

18 

19 

20 
21 
22 

23 

24 

25 

26 

27 

28 

29 

30 

31 

32 

33 

34 

35 

36 

37 

38 

39 

40 

41 


Sequence of statements caused fiuilt 
Last statement caused Omit 
Previous statements ct^'tsed fault 
Loop Statement caused fault 
Last Statement did not mask fault 
Sequence prior to last caused fault 
Lo^ never executed 
Loop condition evaluation caused fault 
Nth Iteiatkm caused fault 
Wrong Type of loqj used 
Iteration scheme caused fault 
Sequence of statements caused fault 
Condition true past n-1 
Parameter qteciGcation caused fault 
S^uence of statements caused fault 
Coition true at n*! iteration 
Sequence of statements kept condidon tree 
IdenUfter ^[KcifiGd caused fatdt 
Discreet range caus<»i fault 
last statenumt cmised fault 
Previous statements caused fault 
Sequence of statements caused fuilt 
SAMPLE 

Range specified caused fault 
Loop Statement caused fault 
Last Statement did not mask fault 
Sequence prior to last caused fault 
l4Bi statement caused fault 
Previous statements caused fault 
1 

SAMPUNG^DURATiON 
Loop never executed 
Loop condition evalutuion caused fuili 
Nth Iteration caused fault 
Sequence of ttatenumis caused fault 
Lo^ Statement caused fault 
Last Statetnent did not mask fault 
Sequence prior to last caused full 
Wrong lype of loop used 
Iteration scheme caused fault 
Sequence of tiumtm f uth 

Condition true past i)>l 


164 




42 Last statement caused &ult 

43 Previous statements caused fault 

44 Loop never executed 

45 Lo (9 ccmdition evaluation caused font* 

46 Nth Iteiaiim) caused fault 

47 Sequence statements caused fault 

48 Parameter qwcificadcm caused fault 

49 Condition true at n-1 itermion 

50 Sequence of statements k^t condition true 

51 If statement caused fault 

52 Last Statement did not mask ftuilt 

53 Sequence prior to last caused fault 

54 Wrong T>pe of loop used 

55 Iteration scheme caused fault 

56 Sequence of statements caused fault 

57 Condition true past n-1 

58 Last statement caused fault 

59 Previous statements caured fault 

60 Identifier ^lecified caused fault 

61 Discreet range caused fault 

62 Evaluation of condition caused fuilt 

63 Condition true and statements caused fawit 

64 ELSIF caused the fault 

6 5 Parameter specification caused fault 

66 Condition true at ml iteration 

67 Sequence of statements kept condition true 

68 If statement caused fault 

69 Last Statement did not nuuk fault 

70 Sequence prior to last caused fault 

71 I 

72 Range specified caused fault 

73 Relation caused the fault 

74 If condition true 

75 If statements caused fault 

76 Previous ooodiiiom evaluated to frise 

77 Current/fuiuro ELSIF caused the fault 

78 Idcnuncr^ified caused fault 

79 Discreet range caused fault 

80 fivaluiUoQ of condition caused fault 

81 Conditkm true and simnents caused £a^ 

82 ELSO^ caused the fautt 

83 1 

84 SAMPUNG^DURATION 

85 And Relation caused the fault 

86 Sequence of statements caused fault 

87 Ev^uation of El^ condition caused fault 

88 Current ELSIF caused the fault 

89 CHherELSIFV Caused the fault 

90 ] 

91 Range ^tecUied caused fault 

92 Relatioocauaedihefitdt 


165 












93 Ifc(»ididontrue 

If statements caused fault 
Previous conditions evaluated to &lse 
Cunent/fiiture ELSIF caused the fault 
Left (M^PriOT relation caused fault 
Right relation caused fault 
Last statement caused fault 
Previous statements caused fault 
Relation caused the fault 
Current ELSIF condition caused the fault 
Current ELSIF sequence of statements caused the fault 
ELSIF caused the ftuilt 
1 

SAMPLINO_DURATION 
And Relation caused the fault 
Sequence of statements caused fault 
Ev^uadon of Elsif condition caused fault 
Current EI^IP caused the fault 
Other BLSIFs caused the fault 
Relation causal the fault 
Relation caused the fault 
Assignment Statement Fault 
Last Statement did not mask fault 
Sequence prior to last caused fault 
Relarion caused die fault 
Sequence of statements caused fault 
Pre^ous conditions evaluated to false 
Currendftituie ELSIF caused the fault 
Left or Prior relation caused fiuiU 
Right lelaiiw caused fault 
La^ suiemtmt caus^ fault 
Previous staiaments caused fault 
Relation caused the fiudt 
Current ELSIF condition caused the f«dt 
Current ELSIF sequent^ of statements (uuiscd the ftuU 
caused (he 
OVBNJfEMP 
AddiUon/Subtracdon Fault 
'ST_CMD 

1 

Change in values caused !%ult 
Exception causes Fault»)Mo( imideateated 
Operand E valuation causes Fault 
S^U6or» of stattuuents outsed fault 
OVEN„TBMP 
Additiott/Sukraction Fauh 
Last statement caused fault 
Previous statements caused fault 
Evaluation of Eliif condition caused fault 
Current ELSIF caused the fault 
ether ELSFs caused the fudt 


166 





144 Relation caused the &ult 

145 Relatkm caused the fiuilt 

146 Assignment Statement Fault 

147 Last Statement did not mask fault 

148 Seqimncepiioc to last caused fault 

149 Relation caused the fault 

150 Sequence of statements caused fault 

151 Previous conditions evalmued to false 

152 Cunent/fiituieELSIF caused the fault 

153 GOAL.IEMP 

154 Subinclioa Fault 

155 10 

156 LAST_CMD 

157 Relation caused the fiuilt 

158 Last statement caused fault 

159 Previous statemout caused fault 

160 GOALJIRMP 

161 Addition Fault 

162 10 

163 Raise Statement Caused Fault 

164 Last Statement did not mask fault 

165 Sequence prior to last caused fault 

166 Relation caused the fault 

167 Current ELSIP condition caused the fault 

168 Current ELSIF sequence of statements caused the fmdi 

169 ELSIFctwsedthefauU 

170 OVENJTBMP 

171 Addition/Suhtractioa!%alt 

172 LAST.CMD 

173 1 

174 Change in values cittuedPiult 

175 Ejtceptkm causes Fault •^hkuimidemeti^ 

176 Operand Evaluation causes Pauli 

177 Sequence of stiuemcna caused 

178 OVEM^TEMP 

179 Addition^tdiiiacdon Fault 

ISO Lauriiiement caused fault 

181 Previous staremenis caused fault 

182 E^mluadon of l^sif condition caused fault 

183 Current ELSE’caurediheOuilt 

184 Other ELSIFs caused the fauU 

IBS 1 

186 Asrigtuneot Statement Fault 

187 Lari Starmem did not fttask fault 

188 Sequence priorto last caused fiwit 

189 Wrong Exception Raised Caused Fault 

190 Exception Handler OuiSedFtt^ 

191 Ai4Relttik»ca»sedthe£sult 

192 Sequence of atatements caused Caidi 

193 Previous conditkms evaluated to 

ISM Cismd/fuiureELSiF caused die fault 


167 











195 GOAL.TEMP 

196 Subtraction Fault 

197 10 

198 LAST.CMD 

199 Relation caused the &u]t 

200 Last statement cruised fault 

201 Previous statements caused fault 

202 GOALjraMP 

203 Addition Fault 

204 10 

205 Raise Statement Caused Fault 

206 Last Statement did not mask fault 

207 Sequence prior to last caused fiuilt 

208 Relation caused the fault 

209 Current ELSIF condition caused the i^t 

210 Current ELSIP sequence of statements caused the f^t 

211 ELSIF caused the &uU 

212 Change in values caused Fault 

213 ExcqKion causes Faidt - Not imjdemented 

214 Operrmd Evaluation causes Fault 

215 OVEN^NOT_RESPONDINO 

216 Left w Prior leltoion caused fault 

217 Right relation caused fault 

218 Last statement caused fault 

219 Previous statements caused fault 

220 EvaluationofElsifcondiiioncausedfauli 

221 Current ELSIF ctuised the fault 

222 Other ELSlFs caused the fault 

223 1 

224 Assignment Statement Fault 

225 Last Statement did not mask fault 

226 Sequent* prior to last caused fault 

227 Wrong BuGcpUon Raised Caused Ruth 

228 Exception Kartdier Caused Fault 

229 And Relation caused tite fault 

230 Sequence ofsuiements caused fault 

231 Previous conditions evaluated to false 

232 Current/future ELSIF caused the 

233 OVEN^BUF 

234 Relttion caused the ftiuU 

235 Relation caused tite fault 

236 Relation caused the ftult 

237 Assignmem Statement Fault 

238 Last Staiernem did tKX mask fault 

239 SequetK* prior to last caused fkuti 

240 Relation caused the Ctult 

241 Current ELSEPtWKUtioacaus^ the (ktii 

242 Gurrtru ELSIF sequence of ttitcfneruj caused the fault 

243 Change in values caused Fault 

244 Exception causes Faults Not implemented 

Z4S Operand Evaluation causes Fault 


168 



246 OVENJ^OT_SESK)HDIKO 

247 Left or Prior nslaiKHic^^&aalt 

248 Right relation caused fault 

249 Last statement caused f%tlt 

230 Previous ststemcLits cau^ fault 

231 Evaiuadon of Blsii condition caused fault 

252 Current ^IF caused the fault 

253 Other ELSlFs caused the &u!i 

254 1 

255 OVEN.TEMP 

256 Addidon/Subtractionl^uU 

257 LAST.CMD 

258 2 

259 Change in vak^ caused Fault 

260 Exce{Uionc^ses Fault-Not implmented 

261 Operand Evalutgion causes f^t 

262 Sequem^ of stat^entscau^ fault 

263 Relation caused the fault 

264 Sequence of statet^ents caused fault 

265 OVEN3UF 

266 Relation caused the fautt 

267 Relation caused the fault 

268 Relation caused the feadi 

269 Assignnwftt Stafement P 

270 Last Suueinent did n(gn»)«sk fault 

271 St > r as prior to last caused 

272 Rclieriun caused the l^t 

273 CtttnmtELSIFcondiden caused t©f^t 

274 Current BlSlFseqtgmcecd^itatetnemcaus^ 

275 GOAt.miP 

276 Addition 

277 10 

278 LASt-CMD 

279 Rchtficit caused tl» fault 

280 lA^riatmeni caused fmU 

28! I^riousaote^nentscst^^^ 

282 OVEN.TEMP 

283 Addition/Subtracdon Fault 

284 ijMUstatemeM caused 

285 Previous sutmeuis caused 

286 I 

287 OTO TEMP 

288 Additi^td)tractionM 

B9 LASt.CMI> 

290 2 

291 Change bvak^ caused F^i ' 

292 Esc^kiB {^3*5 Vnf^ - ^K^lssstsaed 

293 Operand Ev^uatkm )%dt 

294 Seq«»ence of stafi^ivents canted 

295 Relkibnc^risedtlie fruit 

2^ Seqarmee of fiiicmcfus caused 


169 










W 1 

298 AssignmmStatm^ Fault 

299 last Stat^ent did not mask fault 

100 Ssiue}K>e{Kior tocaused i^t 

3C1 OOAL_TEMP 

302 Subtractioa Fault 

303 10 

30^ Raise Statement Caused Fault 

305 Last Stteem^ii did not mask fault 

306 Sequence prior to caused fault 

307 GOAL„ma» 

308 Addition Fault 

309 10 

310 LAST.CMD 

311 Relation caused the &ult 

312 Issl statement caused fault 

313 Pseviuus statements caused fault 

314 OVEN^TCMP 

3 IS Addidon/Subtracdon Fault 

316 Last statemtmt caused fm;lt 

317 Previous statements caused &uli 

318 Change in Fault 

319 Excepilen causes Fauk <• Not impiemested 

320 Op^nd Evaluation causes F^i 

321 Wn^tgBacqMion Raised Caused l^tuk 

322 ExcqitioQH^er Caused Fault 

323 2 

324 Asslf^a Statement P^ik 

325 L^^itcfnem did wa mask 

326 Sequence pdork^ls^ caused 

327 GOAL^TEMP 

328 Subtraction Fault 

329 10 

330 Raise Statement Caused Fault 

331 last Statement did not rnask fault 

332 Sequence prior to last caused Dun 

333 OVENJBUF 

334 Relation caused the Ouih 

335 0VENJ90TJRESP0NPINQ 

336 Change in values caused Fault 

337 Baetption causes Fault Not implmenied 

338 (^mndEvalutfton causes Fault 

339 Wrong Exception Raised €«used Fault 

340 Exception Handier Caused Fatdt 

341 2 

342 OVEN^UF 

343 Relidon caused the fault 

344 0\^J90TJiESPONjDlNO 

345 2 


170 



C. PROCEDURE, FUNCTION, AND EXCEPTION LISTING 


Hie number of procedure^/funcdons on the table are 1 

The procedures/functions and their root faults on the table 
are the following: 


FAKE_OVEN_CONTROL 
Sequence of statemmts caused fault 

Above are the procedurea^ctions and root faults. 

H I I I KI H H I W f - H W 4 " »- H I H I 


There are no defined exceptions within the input code. 


— Finished Code TYansladon — 


0 errors found 


171 









D 


FTE COMPATIBLE FILE, "NEW FTE” 


0 

Sequence of statements caused fault 
EXAMPLE.A 
0000122 
1 

Last statement caused fault 
EXAMPLE.A 
00085101 
3 

Loop Statement caused fault 
EXAMPLE.A 
000170123 
6 

Loop never executed 
EXAMPLE.A 
0 0 0 255 1 00 
7 

Loop condition evaluation caused fault 
EXAMPLE.A 
0 0 75 255 1 22 

9 

Wrong Type of loop used 

EXAMPLE.A 

000340100 

10 

Iteration scheme aused fault 
EXAMPLE.A 
0075340121 
13 

Parameter specification caused fault 

EXAMPLE.A 

000425122 

17 

Identifier specified caused fault 
EXAMPLE.A 
000510101 
22 

SAMPLE 
EXAMPLB.A 
0 0 0 595 1 00 

18 

Discreet range caused fault 
EXAMFLE.A 
0075 510101 
23 

Range specified caused fault 
EXAMPLE.A 
0 0 75 595 1 22 


172 





29 
1 

EXAMPLE.A 
0 0 0 680 1 00 

30 

SAMPLING DURATION 
EXAMPI-E.A 
0 0 75 680 1 00 
8 

Nth Iteration caused fault 
EXAMPLE.A 
00150 2551 12 
11 

Sequence of statements caused fault 
EXAMPLE.A 
00 150 340 1 01 
21 

Sequence of statements caused fault 
EXAMPLE.A 
0 0 300510 1 22 
27 

Last statement caused faul t 
EXAMPLES 
00375 595 101 
35 

Loop Statement caused fault 
EXAMPLE.A 
0 0 450680 1 23 

44 

Loop never exe^iuted 
EXAMPLE.A 
0 0 450765 1 00 

45 

L>oop condition evaluation caused fault 
EXAMPLE.A 
0 0 525765 1 22 

54 

Wrong Type of loop used 
EXAMPLE.A 
0 0 450850 1 00 

55 

Iteration scheme caused fault 
EXAMPLE.A 
0 0 525 850 1 21 
65 

Parameter speciHcation caused fault 
EXAMPLE.A 
0 0 375 935 1 22 
78 

Identifier specified caused fru it 
EX.^1PLB^ 


173 








005251020101 

90 
I 

EXAMPLES 
0 0 5251105 1 00 
79 

Discreet range caused fault 

EXAMPLES 

006001020101 

91 

Range speciHed caused fault 
EXAMPLE.A 
0 0 6001105 1 22 

105 
1 

EXAMPLE.A 

006001190100 

106 

SAMPLING.DURA'nON 
EXAMPLE.A 
0 0 6751190 1 00 
46 

Nth Iteration caused fault 
EXAMPLE.A 
0 0 6007651 12 

56 

Sequence of statements caused fault 
EXAMPLE.A 
0 0 600850 1 01 

57 

Condition true past n<l 
EXAMPLE.A 
0 0 675 8501 12 
66 

Condition true at n-1 iteration 
EXAMPLE.A 
00450935100 
67 

Sequence of statements kept condition true 
EXAMPLE.A 
0 0 525935 1 01 
28 

Previous statements caused fault 
EXAMPLE.A 
0 0 4505951 12 

36 

Last Statement did not mask fault 

EXAMPLE.A 

00S25 680100 

37 

Sequence prior to last caused fault 


174 



EXAMPLE.A 
0 0 600680 1 01 
47 

Sequence of statements caused fault 
EXAMPLE.A 
00675765122 
58 

Last statement caused fault 
EXAMPLEA 
0 0 750850 1 01 
68 

If statement caused fault 
EXAMPLEA 
0 0 600935 1 23 
80 

Evaluation of contEtion caused fault 
EXAMPLEA 
0 0 675 1020 1 00 
92 

Relation caused the fault 
EXAMPLEA 
0 0 6751105 1 01 
107 

And Relation caused the fault 
EXAMPLEA 
0 0 7501190 1 22 
121 

Left or Prior relation caused fault 
EXAMPLEA 
0 0 675 1275 1 01 
144 

Relation caused the fault 
EXAMPLEA 
001125 1360 1 22 

170 

OVEN.TEMP 
EXAMPLEA 
00 1275 1445 1 00 

171 

Addition/Subtraction Fault 
EXAMPLEA 
0013501445 1 23 

195 

GOAL^TEMP 
EXAMPLEA 
0 0 7501530 1 00 

196 

Subtraction Fault 

EXAMPLEA 

008251530100 

197 








10 

EXAMPLE.A 
0 0 9001530 1 00 
122 

Right relation caused fault 

EXAMPLES 

007501275101 

145 

Relation caused tlte fault 
EXAMPLES 
0012001360 1 22 

172 

LAST.CMD 
EXAMPLE.A 
0014251445 1 00 

173 
1 

EXAMPLE.A 
0015001445 1 00 
81 

Condition true and statements caused fault 
EXAMPLE.A 
0 0 7501020112 

93 

If condition true 
EXAMPLES 
0 0 7501105 1 00 

94 

If statements caused fault 
2XAMPLE.A 
0 0 8251105 1 00 
108 

Sequence of statements caused fault 

EXAMPLB.A 

0082S1190I22 

123 

Last statement caused fault 
EXAMPLE.A 
0 0 8251275 1 01 

146 

Assignment Statement Fault 
EXAMPLB.A 
0012751360 1 23 

174 

Change in values caused Fault 

EXAMPLE.A 

0015751445100 

175 

Exc(^)tion causes Fault ~ Not implemented 

EXAMPLE.A 

0016501445 1 00 


176 



176 

Operand Evaluation causes Fault 
EXAMPLEA 
0017251445 1 22 

198 

LAST_CMD 
EXAMPLEA 
0 0 975 1530 1 00 

199 

Relation caused the fault 

EXAMPLEA 

0010501530101 

223 
1 

EXAMPLEA 

008251615100 

124 

Previous statements caused fault 
EXAMPLEA 
0 0 900 12751 12 

147 

Last Statement did not mask fault 
EXAMPLEA 
00 13501360 1 00 

148 

Sequence prior to last caused fault 

EXAMPLEA 

0014251360101 

177 

Sequence of statements caused fault 

EXAMPLEA 

0018001445 1 22 

200 

Last statement caused fault 
BXAMaEA 
001125 1530 1 01 

224 

Assignment Statement Fault 
EXAMPLEA 
0 0 9001615 1 23 

243 

Change in values caused Fault 
EXAMPLEA 
0 0 7501700 1 00 

244 

Exception causes Fault - Not implemeioed 
EXAMREA 
0 0 8251700 1 00 

245 

Opercutd Evaluation causes Fault 
EXAMPLEA 


177 










009001700122 

265 

OVEN.BUF 

EXAMPLEA 

008251785100 

266 

Relation caused the fault 
EXAMPLEA 
009001785101 
286 
1 

EXAMPLEA 
0 0 8251870 1 00 
201 

Previous statements caused fanh 

EXAMPLEA 

0012001530112 

225 

Last Statement did not mask fault 
EXAMPLEA 
0 0 975 1615 1 00 

226 

Sequence prior to last caused fault 
EXAMPLEA 
0010501615 1 00 
82 

BLSIF caused the fault 
EXAMPLEA 
0082510201 12 

95 

Previous conditions evaluated to false 

EXAMPLEA 

009001105100 

96 

Cunent/future BLSIF caused the fault 

EXAMPUBA 

00975 1105123 

109 

Evaluation of Elsif condition caused fault 
EXAMPLEA 
0 0 9001190 1 00 
125 

Relation caused the fault 
EXAMPLEA 
0 0 9751275 1 01 
149 

Relation earned the fault 
EXAMPLEA 
0015001360 1 22 
178 

OVEN_TBMP 


178 



EXAMPLES 
0018751445 1 00 

179 

Addition/Subtiaction Fault 
EXAMPLEA 
0019501445 1 23 
202 

GOAL.TEMP 

EXAMPLEA 

0012751530100 

203 

Addition Fault 
EXAMPLEA 
0013501530 1 00 

204 
10 

EXAMPLEA 

0014251530100 

no 

Cuirent ELSIF caused the fault 
EXAMPLEA 
0 0 9751190112 
126 

Cuirent ELSIF condition caused the fault 
EXAMPLEA 
0010501275 1 00 
127 

Cunent ELSIF sequence of statements caused the fault 
EXAMPLEA 
001125 1275 1 00 
150 

Sequent^ of siaiemenis caused fault 

EXAMPLEA 

001575 1360122 

180 

Last statement caused fault 
EXAMPIEA 
0 0 20251445 1 01 

205 

Raise Statement Caused Fault 

EXAMPLEA 

0015001530 1 22 

227 

Wrong Exception Raised Caused Fault 

EXAMPLEA 

001125 1615100 

228 

Excqxion Handler Caused Fault 

EXAMPLEA 

0012001615101 

246 


179 



OVEN_NOTJlESPONDING 

EXAMPLE.A 

009751700100 

181 

Ftevious statements caused fault 
EXAMF1£.A 
0 0 21001445112 
206 

Last Statement did not mask fault 
EXAMra£.A 
0015751530 1 00 

207 

Sequence prior to last caused fault 
EXAMPLE.A 
0016501530100 
111 

Other ELSIFs caused the fault 
EXAMPLE.A 
0010501190100 
128 

ELSIF caused the fault 
EXAMPLE.A 
001200 12751 12 

151 

Previous conditions evaluated to false 

EXAMPUB.A 

0016501360100 

152 

Cument/future caused the fault 
EXAMPLE.A 
0017251360123 
182 

Evsduation of Elsif condition caused ikilt 

EXAMPLB.A 

0021751445100 

208 

Relation caused the fault 
EXAMPLB.A 
001725 1530 1 01 
229 

And Relation caused the fault 
EXAMPLE.A 
0012751615122 
247 

Loft or Prior relation caused fault 

EXAMPLB.A 

0010501700101 

267 

Relation caused the fault 
EXAMPLE.A 
0 0 9751785 1 22 


180 



287 

OVEN.IEMP 

EXAMPLE.A 

009001870100 

288 

Addition/Subiracdoa Fault 

EXAMPLEA 

009751870123 

307 

GOAL_TEMP 

EXAMPLEA 

007501955100 

308 

Additkm Fault 
EXAMPLE.A 
0082S1955 1 00 

309 
10 

EXAMPLEA 
0 0 9001955 1 00 
248 

Right relation caused lault 
EXAMPIEA 
001125 1700101 
268 

Relation caused IMt 
EXAMPLEA 
00 10501785 1 22 

289 

UST.CMD 
EXAMPLEA 
00 lOSO 1870100 

290 
2 

EXAMPLEA 
001125 1870100 
183 

rurrent BLSIF caused the ^udt 
L 'AMPLEA 
0022S0144S112 

209 

Ciment ELSQ’ccnditioQ caused tiui iault 

EXAMPLEA 

0018001530100 

210 

Current ELSIF sequence of sutemenis caused the lault 

EXAMPLEA 

0018751530100 

230 

Sequence of statements caused fault 
EXAMPLEA 


181 








0013501615 1 22 

249 

Last statement caused £uilt 

EXAMPLES 

0012001700101 

269 

As^gnment Statement Fault 
EXAMPLES 
0011251785123 

291 

Change in values caused Fault 
EXAMPLES 
0012001870 1 00 

292 

Exception causes Fault - Not implemented 

EXAMPLE.A 

0012751870 1 00 

293 

Operand Evaluation cautes I^oult 

EXAMPLB.A 

0013501870122 

310 

LAST.CMD 
BXAMPLE.A 
0 0 975 1955 1 00 

311 

Relation caused the fault 
EXAhl»LE.A 
0010501955 1 01 
323 
2 

EXAMPLES 

003752040100 

250 

l^vious mtcments caused fault 

EXAMPLE.A 

001275 17001 12 

270 

Last Statement did not mask fault 
EXAMPLE.A 
0012001785 1 00 

271 

Sequence prior to fast caused fault 

EXAMPLES 

0012751785101 

294 

Sequence of aatements caused fault 

EXAMPLES 

0014251870122 

312 

Last statfement caused fault 


182 



EXAMPLES 

0011251955101 

324 

Assignment Stat(»nem Fault 
EXAMPLES 
0 0 4502040 1 23 

336 

Change in values caused Fault 

EXAMH-EA 

002252125100 

337 

Exception causes Fault ~ Not implement 
HXAMPLBA 
0 0 3002125 1 00 

338 

Operand Evaluation causes Fault 

BXAMPLEA 

003752125122 

342 

OVEN^BUF 

EXAMPLBA 

00752210100 

343 

Relation caused the fault 
BXAMPLEA 
001502210101 
345 
2 

BXAMPLEA 

0002295100 

313 

Previous sutemcnts caused (luU 

EXAMPLBA 

001200 1955112 

325 

Last Statement did not mask fault 

BXAMPLEA 

005252040100 

326 

Sequence prior to last caused 
EXAMHJb-A 
006002040100 
184 

Other ELSIFs caused the Cault 
EXAMPLEA 
0023251445100 
211 

ELSIF caused the OkuU 
EXAjMPLEA 
00195015301 12 
231 


183 










Previous conditions evaluated to false 

EXAMPLE.A 

0014251615100 

232 

Cunent/fiiture ELSIF caused the /ault 

EXAMPLE.A 

0015001615 1 23 

251 

Evaluation of Elsif condition caused f^t 

EXAMPLE.A 

0013501700100 

272 

Reltuion caused the <si<lt 
EXAM^^:.A 
001350 ms 101 
295 

Relation caused the 
OOi5(K)lS70U2 

?i4 

OVEtVffih?? 
gXAMH-B.A 
00 im m5 100 
SB 

Additian^ubaacttGii Fault 

EKAMPi6.A 

0015501955123 

327 

OOAL„TBMP 

EXAMPLES 

006752040100 

328 

Subo'actitm Fault 

EXAMPLE.A 

007502040100 

329 
10 

OOS2S2040100 

252 

Current ELSIF caused the Otult 
gXAhiPLE.A 
00142517001 12 

273 

Current ELSIF condition caused the fault 

EXAMPLES 

001425 17SS 100 

274 

Cllrti^nt El SitP Cft q twwx. nf raifti«.t |Kft 

BXAMPLE.A 
00150017SS 100 


164 



296 

Sequence of statements caused fiuilt 

EXAMPLE.A 

0015751870122 

316 

Last statement caused fault 
EXAMPLE.A 
0014251955 1 01 

330 

Raise Statement Caused Fault 

EXAMFLE.A 

009002040122 

339 

Wiong Excqition Raised Caused Fault 

EXAMH-EA 

004502125100 

340 

Exception Handler Caused Fault 

EXAMPLEA 

0052521251QI 

344 

OVEN_NOT RESPONDINO 

EXAMPIEA 

002252210100 

317 

Pitevious statemerds caused fault 

HXAMPLJA 

00 1500 1955112 

331 

Last Statement did not mask fault 

EXAMHLE.A 

009752040100 

332 

Sequence prior to last caused (ault 

EXAmEA 

0010502040100 

253 

Other ELSIFs caused the fault 
EXAMPLEA 
0013001700100 
59 

IVevious stitements caused fault 
EXAMPLE.A 
00S258501 12 

69 

Last Statement did not mask fault 

EXAMPLEA 

00675935100 

70 

Scqumtce prior u last cmed fault 
EXAMPLEA 









0 0 750935 1 00 
12 

Condition true past n-1 
EXAMPLE.A 
002253401 12 

15 

Condition true at n-1 iteration 

EXAMPLE.A 

00150425100 

16 

Sequence of statements kept condition true 
EXAMPLJBA 
0 0 225425 1 01 
21 

Sequence of statements range d fault 
EXAMPLE.A 
0 0 300510 1 22 
27 

Last statement caused fault 
EXAMPLBA 
0 0 375595 1 01 
35 

Statement caused fault 
EXAMPLES 
00450680 1 23 

44 

Loop never executed 

EXAMPLEA 

004S076S100 

45 

Loop condition evaluatkw caused fiuiit 
EXAMPLEA 
0 0 525765 1 22 

54 

Wrong Type of loop used 

EXAMPLEA 

00450850100 

55 

Iteration sdme caused fault 
EXAMPLEA 
0 0 525850 1 21 
65 

i^uriraeter spocificaiiOQ caused f^ 
EXAMPLEA 
00375935122 
78 

Identifier specified caused Cult 

EXAMPLEA 

00525102010! 

90 

1 


186 



EXAMPLE.A 

005251105100 

79 

Discreet range caused fault 
EXAMPLE.A 
0 0 6001020 1 01 
91 

Range qxscified caused fault 

EXAMPLE.A 

006001105122 

105 
1 

EXAMPLES 

006001190100 

106 

SAMPLING^DURATION 
EXAMPLEJV 
0 0 6751190 1 00 
46 

Nth Iteration caused fault 
EXAMPLE.A 
006007651 12 

56 

Sequence of statements caused fault 

EXAMPLE.A 

00600850101 

57 

Condition tiue past n-1 
EXAMPLE.A 
0 0 675 8501 12 
66 

Condition true at n>l Ueraiion 
EXAMPtJB.A 
00450935100 
67 

Sequence of statements kept condiikw cue 
£XAM3>IjB.A 
00SZS935101 
28 

Previous sta^menis caused fuiU 
EXAMPLE.A 
004505951 12 

36 

Last Staiemetit did not mask fault 

BXAMFLE.A 

00525680100 

37 

Sequence prior to but caused fault 
EXAMPLE.A 
00600680101 

47 


137 











Sequence of statements caused fault 
EXAMPLEA 
00675765122 
58 

Last statement caused fault 
EXAMPLEA 
00750850101 
68 

If statement caused fault 
EXAMPLEA 
0 0 600935 1 23 
80 

Evaluation of condition fault 

EXAMPLEA 
006751020100 
92 

Relation caused the fault 
EXAMPLEA 
0 0 6751105 1 01 
107 

And Relation caused the fault 
EXAMPLEA 
0 0 7501190 1 22 
121 

LeO w Prior relation caused fault 
EXAMPLEA 
006751275101 
144 

Relation caused the fault 
EXAMPLEA 
0011251360122 

170 

OVEN.TEMP 
EXAMPLEA 
001275 1445 100 

171 

Addiikut/Subtraction Fault 
EXAMPLEA 
0013501445 1 23 

195 

CX)AL_1EMP 
EXAMPLEA 
007501530100 

196 

Subtraction Fault 

EXAMPLEA 

008251530100 

197 
10 

EXAMPLEA 

009001530100 



122 

Right lelalion caused &ult 
EXAMPLEA 
0 0 7501275 1 01 

145 

Relation caused the fault 
EXAMPLEA 
0012001360 1 22 

172 

lAST.CMD 
EXAMPLEA 
0014251445 1 00 

173 
1 

EXAMPLEA 
0015001445 1 00 
81 

Condition true and statements caused fault 

EXAMPLEA 

007501020112 

93 

If condition tiue 

EXAMPLEA 

007501105100 

94 

If statements caused fault 
EXAMPLEA 
008251105100 
108 

Sequence of statements caused fault 
EXAMPLEA 
008251190122 
123 

Last statement caused fault 
EXAMPLEA 
00825127S101 

146 

Asdgimtent Suiemetu Eauli 
EXAMPLEA 
0012751360 1 23 

174 

Change in values caused Auik 

EXAMPLEA 

0015751445 1 00 

175 

Exception causes Not tffipletaenie^ 

EXAMPLEA 

0016501445100 

176 

Opeiand Evaluatkn causes Eauli 
EXAMPLEA 



0017251445 1 22 

198 

LAST_CMD 
EXAMPLES 
0 0 9751530 1 00 

199 

Relation caused the fault 
EXAMPLES 
0010501530 1 01 

223 
1 

EXAMPLE.A 

008251615100 

124 

Previous statements caused fault 

EXAMPLE.A 

009001275112 

147 

Last Statement did not mask fault 
EXAMPLE.A 
0013501360 1 00 

148 

Setjuence prior to last causal fault 
EXAMPLE.A 
0014251360 1 01 
177 

Sctptence of statements caused fault 

EXAMPLE.A 

0018001445 1 22 

200 

Last statement caused fuilt 
EXAMPLES 
0011251S3010I 

224 

Mstgomem Statement Fault 

EXAMPLE.A 

009001615123 

243 

Change in values caused Fault 

EXAMPLBA 

007SO1700 1 00 

244 

Exception causes •> Not tmpkmenieu 

BXAMFIEA 

008231700100 

245 

Operand Evaluatioa cauiea Fault 
EXAMFLEA 
0 0 9001700 1 22 
265 

OVEN3UF 


190 



EXAMPUE.A 
0 0 8251785 1 00 
266 

Relatim caused the fault 
EXAMPLE.A 
0 0 9001785 1 01 
286 
1 

EXAMFLE.A 

008251870100 

201 

Previous statements caused fault 
EXAMPLE.A 
00120015301 12 

225 

Last Statement did not mask fault 
EXAMRE.A 
0 0 9751615 1 00 

226 

Sequence prior to last caused fault 
EXAMPLE.A 
0010501615100 
82 

ELSIF caused the fault 

BXAMPLE.A 

008251020112 

95 

Previous conditions evaluated to false 

EXAMPLE.A 

009001105100 

96 

Cutrent^tme ELSIF caused the fault 
EXAMPLJB.A 
009751105123 
109 

Evalttaiion of Elsif conditioo caused fault 
EXAMPLE.A 
009001190100 
125 

Rdaiion caused the fkult 
BXAMPLE.A 
009751275101 
149 

Relation caused the Cult 
EX AMPLE 
0015001360122 

178 

OVEN^TBMP 

EXAMP1JE.A 

0018751445100 

179 


191 












Addidon/Subtiactioa Fault 
EXAMPLES 
0019501445 1 23 
202 

GOAL_TEMP 

EXAMPLES 

0012751530100 

203 

Addition Fault 
EXAMPLES 
0013501530 1 00 

204 
10 

EXAMPLES 
0014251530 1 00 

no 

Cuirent ELSIP caused the fifuilt 
EXAMPLE.A 
009751190112 
126 

Cunent ELSIF conditioo caused the fault 

EXAMPLES 

0010501275100 

127 

Cunent EL^IF sequence of swemeots caused the £iult 
EXAMPLE.A 
0011251275100 
150 

Set^Rce of ^atetnents caused fault 
EXAMPLES 
0015751360 1 22 
180 

Last Aaiement caused fauli 
EXAMPLES 
002025 ia5101 

205 

Raise StmerRQtt Caused 
EXAMPLB.A 
0015001530122 

227 

Wrong Exception Raised Caused Fault 

EXAMPLE.A 

0011251615100 

228 

Exception Handler Caused Fault 

EXAMPLEik 

0012001615101 

246 

OVEN^NOTJRESPONMNO 

EXAMPLES 

009751700100 


192 



181 

IVevious statements caused fault 
EXAMPLE.A 
002100144S112 
206 

Last Statement did not mask fault 

EXAMPLBA 

0015751530100 

207 

Sequence prior to last caused fault 
EXAMPLES 
0016501530100 
111 

Other ELSIFs caused the fault 
EXAMPtBA 
0010501190100 
128 

ELSIF caused the fault 
EXAMPLE.A 
00120012751 12 

151 

Previous conditions evaluated to false 

EXAMPLES 

0016501360100 

152 

Cufrent/futuie ELSIF r- wi<ed the fault 
EXAMPLES 
0017251360123 
182 

Evalouion of Elsif condition caused Omit 
EXAMPIEA 
0 0 21751445 1 00 

208 

Relation caused the fault 
EXAMHEA 
00I72S1530101 
229 

And Relation caused the fault 
EXAMPLES 
0012751615122 
247 

Left or Rrior rtlMioa caused fault 

EXAMPLES 

0010501700101 

267 

Reladon caused the fault 
EXAMPLEJ^ 

009751785122 

287 

OVENJEMP 

EXAMPUBA 










009001870100 

288 

Addition/Subtractioo Fault 

EXAMPLE.A 

009751870123 

307 

GOAL_TEMP 
EXAMPLES 
0 0 75019SS100 

308 

Addition Ftttilt 
EXAMPLEA 
0 0 825 1955 1 00 

309 
10 

EXAMPLES 

009001955100 

248 

Right relation caused fault 
EXAMPLE.A 
0011251700101 
268 

Relation caused ttie fault 

BXAMPLE.A 

0010501785122 

289 

UST„CMD 

EXAMPLEA 

0010501870100 

290 
2 

EXAMPjUBA 
001125 1870100 
183 

Outent EL8IF caused the Cult 
EXAMPLEA 
00225014451 12 

209 

Cuntni ELSIF condition caused the &uU 

EXAMPLEA 

0018001530100 

210 

rtwirwil FI faneM rtM* f*iiti 

EXAMPLEA 

0018751530100 

230 

Sta^uence of ttatements caused fault 

EXAMPLEA 

0013501615122 

249 

1 Att fault 


194 




iJCAMPL£.A 

0012001700101 

269 

Asagnmem Stattmem Fault 
EXAMPLES 
0011251785123 

291 

Change in values caused Fauk 

EXAMPLES 

0012001870100 

292 

Exception causes Fault - Not impleiQBiUed 

EXAMPLES 

0012751870100 

293 

Operand Evaluation causes Fault 
EXAMPLE.A 
0013501870 1 22 

310 

UST,CMD 

EXAMPLE.A 

009751955100 

311 

Relation caused the fault 

EXAMPIE.A 

0010S01955101 

323 
2 

EXAMPLE.A 
00 3752040100 
230 

(^vious suuemettts caused fault 
EXAMPtEA 
00127517001 12 

270 

l4M StaicttMMt did not nuude fault 

EXAMPLES 

0012001785100 

271 

Sequence iiirioi'to last earned‘ 

EXAMPLEA 

0012751785 1 01 

294 

Sequence of satetnents caused fault 

EXAMPtEA 

0014251870122 

312 

Last statement caused fault 

EXAMPtEA 

0011251955101 

324 










Asstgnmem Statement 

EXAMPLE.A 

004502040123 

336 

Change in values causetl I^uib 

EXAMPLE.A 

002232125100 

337 

Exception causes l^t - Not implemented 

EXAMPLES 

003002125100 

338 

Operand Evaluation causes I^ult 

EXAMPLE.A 

00 375 2125122 

342 

OVEN.BUF 
EXAMPLE.A 
0075 2210100 

343 

Relation caus^ the £uilt 
EXAMPLES 
001502210101 
345 
2 

EXAMPLEA 

0002293100 

313 

tVevious tiaieme:.«is caused Cult 

EXAMPLES 

00120019551 12 

323 

Un Staijanou did tHM misk (a^ 

EXAMPtE>A 

0OS252O4O1OO 

326 

Se<N<^iKe pHor to last caused (auU 
EXAMPLE.A 
006002040100 
164 

Other HLSIFs caused the (iutii 
EXAMF1E.A 
00232S1445 1 00 
211 

H^IP caused the bull 
EXAMPiE.A 
0019501530112 
231 

PKvious conditions evaluated to (alse 

EXAMPLES 

0014251615100 


196 



232 

Current/future ELSF caused the fault 

EXAMPLE.A 

001500 1615 1 23 

251 

Evaluation of Elsif condition caused fault 

EXAMPUE.A 

0013501700100 

272 

Relation caused the fEuilt 
EXAMPLE.A 
0013501785 1 01 

295 

Relation caused the fault 

EXAMPLEA 

0015001870122 

314 

OVEN_TEMP 
EXAMPLEA 
00 1275 1955 1 00 

315 

Addidon/Subtiaction Fault 
EXAMPLEA 
0013501955 1 23 

327 

GOAL^TEMP 

EXAMPLEA 

006752040100 

328 

Subtraction Fault 
EXAMPLEA 
0 0 7502040 1 00 

329 
10 

EXAMPLEA 

008252040100 

252 

Current ELSIF caused the fault 

EXAMPLEA 

0014251700112 

273 

Current ELSIF condition caused the fault 

EXAMPLEA 

0014251785 1 00 

274 

Current ELSIF sequence of statements caused the fault 

EXAMPLEA 

0015001785100 

296 

Sequence of statements caused fault 
EXAMPLEA 


197 









0015751870 1 22 

316 

Last statement caused fault 

EXAMPLES 

0014251955101 

330 

Raise Statement Caused Fault 

EXAMPLEJV 

009002040122 

339 

Wrong Excq>ti(m Raised Caused Fault 

EXAMPLE.A 

004502125100 

340 

Exception Handler Caused Fault 

EXAMPLES 

005252125101 

XAA 

OVEN_NOT_REdPONDING 

EXAIvlPLE.A 

00225 2210100 

317 

Previous statements caused fault 

EXAMPLES 

00150019551 12 

331 

Last Statement did not mask fault 

EXAMPLB.A 

0097S 2040100 

332 

Sequence prior to last emtsed Guilt 

EXAMnE,A 

0010502040100 

253 

Other ELSIF*s caused the Guilt 
EXAMPLE.A 
0015001700 1 00 
59 

Pmvious statements caused Guilt 
BXAMPLB.A 
008258501 12 

69 

Last Statement did not mask Guilt 

EXAMPLES 

00675935100 

70 

Sequence prior to last caused Guilt 
examplejv 

00750935100 

2 

lYevious itatanenu causod Guilt 


198 



EXAMPLE.A 

007585112 

4 

Last Statemeni did not mask fimit 

0 0 75170 1 00 

5 

Sequence prior to last caused fault 

EXAMFLE.A 

00150170100 













LIST OF REFERENCES 


[Bro88] 
[Bry 88] 

[Cha91] 

[EriSl] 

[Fri93] 

[Gri 81] 

(Fu* 73] 
111190] 
[Lev 86] 
[Lev 87] 

(Lev 89] 

(Uv 91] 


Brown, Michael L., “Software Systems Safety and Human Errors”, 
Proceedings of IEEE Compass *88, pp. 19 - 28, 1988. 

Bryan, William and Siegel, Stan, “Software Product Assurance -- Reducing 
Software Risk in Critical Systems”, Proceedings of IEEE Compass *88, pp. 
67 - 74,1988. 

Cha, Stephen S., A Safety-Critical Software Design and Verification 
Technique, Ph. D. Dissertation, Department of Information and Computer 
Science, University of California, Irvine, Irvine, CA, 1991 

Erickson, C. A., “Software and System Safety”, in Proceedings of the Sth 
International System Safety Cotference, Denver, CO., Volume 1, Part 1, 
System Safety Society, pp III-B-l to EI-B-ll, 1981. 

Friedman, Michael A., “Automated Software Fault-TYee Analysis of Pascal 
Programs”, 1993 Proceedings Annual Reliability and Maintainability 
Synqtosium, pp. 458 - 461,1993. 

Griggs, J. G., “A Method of Software Safety Analysis”, in Proceedings of the 
3th International System Safety Conference, Denver, CO., Volume 1, Part 1, 
System Safety Society, pp UI-D-l to III-D-18,1981. 

Fusscll, J. B.. “A Formal Methodology for Fault Tlrcc Construction", Science 
ard Engineering, Volume 52, pp. 421 - 432, July 1973. 

Ulingv/orth, Valerie, Dictionary of Ctmputing, pp. 250 and 330 * 331, 
Oxford University f^ess, 1990. 

Ixvcson, Nancy G., “Software SafeQr: Why, what, and How”, ACM 
Computing Surveys, \olumt 18, Number 2, pp. 125 • 163, June 1986. 

Levcsoii, Nancy C., Cha, Stephen S., and Shimcall, Timothy J., “Fault TYce 
Analysis Applied to Ada”, Depaitmerit of Information and Computer 
Science, University of California, irvine, Irvine, CA, pp. 1-31, November 
11,1987 

Leveson, Nancy Q. Cha, Stephen S., and Shimeall, Timothy J., “Safety 
Verification in Murphy using Fault TVee Analysis", TWoriat: Software Risk 
Management, ILEE C(»nputer Society Press, pp. 394 - 403,1989. 

Leveson. Nancy G., Cha, Stephen S., and Shimeall, Timothy J., “Safety 
Verificatior of Ada Programs Using Software FaJt IVees", IEEE Software, 
pp. 48 - 59, July 1991. 


200 




[Lev 83] Lcveson, Nancy G. and Harvey, P. R., “Analyzing Software Safety”, IEEE 
Transactions on Software Engineering, Volume SE-9, Number 5, pp. 569 - 
579, September 1983. 

[Lub 88] Lubbes, H. O., et al,, “Compass Past and Future”, Proceedings of IEEE 
Compass ‘58, pp. V - Vn, 1988. 

[Mcc 88] McCarthy, Roger L., “Present and Future Safety Challenges of Computer 
Control”, Proceedings of IEEE Compass’88, pp. 1-7,1988. 

[Meg 89] McGiaw, Richard J., Petri Net and Fault Tree Analysis: Combining two 
Techniques for a Software Strfety Analysis on an Embedded Military 
^plication. Master’s Thesis, Naval Postgraduate School, Monterey, CA, 
December, 1989. 

[Mci83] United States Air Force, Technical Report, “Fault Tree Techniques as 
Applied to Software (Soft 'Dec)”, Mclntec, J. W. Jr., pp. 1 -12, March 1983. 

[Nee 90] Needham, Donald M., A Formal Approach to Hazard Decomposition in 
Software Fault Tree Analysis, Master’s Thesis, Naval Postgraduate School, 
Monterey, CA. June 1990. 

[Ngu88] Nguyen, Thieu and Fbrester, Kaii, Alex - An Ada Lexical Analysis 
Generator, Version 1.0, Arcadia Environment Research Project, Department 
of Information and Computer Science, University of C^oniia, Irvine, 
Irvine, CA, pp. 1 -12, May 1988. 

(Par 90] Pamas, D. L., Van Shouwen, J. A., and Kwan, S. P., “Evaluation of Safety • 
Criticai Software”, Communications of the ACM, Volume 33, Number 6, pp. 
636-648, June 1990. 

[Rol 86] Department of Information and Computer Science, Univemity of California, 
Irvine, Irvine, CA, Technical Rqport Number 86-06, “Software Fault Tree 
Analysis Tool User's Manual”, Rolandelli, Craig, Shimeall, Timothy J., 
Oenung, C^sti, uid Lcveson, Nancy, pp. 1-6,1986. 

(Sal 76] Salem, S. L, d Computer Oriented Approach to Fault Dree Construction, Ph. 

D. Dissertation, University of California, Los Angeles, Los Angeles, CA, 
1976. 

[Tab 88] Tibeck, David and Tolaiu, Deepak, Ayacc User's Manual Version 1.0, 
Arcadia Environment Research Project, Department of Information and 
Computer Science, University of Califomia, Irvine, Irvine, CA, j^. 1 -15, 
May, 1988. 


201 



[Tay 82] Taylor, J. R., Fault Tree and Cause Consequence Analysis for Control 
Software Validation, Riso National Laboratory, DK-4000 Dosldlde, 
Denmark, pp.5 -17, January 1982. 


202 




INITIAL DISTRIBUTION LIST 


Defense Technical Information Center 2 

Cameron Station 
Alexandria, VA 22304-6145 

Dudley Knox Library 2 

Code 052 

Naval Postgraduate School 
Monterey, CA 93943-5002 

Dr. Timothy J. Shimeall 4 

Computer Science Department Code CS/SM 
Nav^ Postgraduate School 
Monterey, CA 93943 


Dr. David A. Erickson 2 

Computer Science Department Code CS/ER 
Naval Postgraduate School 
Montert^, CA 93943 

Mr. Bob F. Westbrook (Code 31) 1 

Naval Air Warfare Center. Weapons Division 
CSiina Lake, CaUfomia 93SSS 

Ms. Eileen T.Takach 1 

Naval Air Warfare Center, Aircraft Division, Indpls. 

6000 E. 21st Stieet 
Indianapolis, Indiana 46219-2189 

Dr. Michad Friedman 1 

18950 Mt Castile Circle 
Fountain Valley. California 92708 

Dr. Ted Lewis 1 

Computer Science Department Code CS/LT 
Naval Postgraduate School 
Monterey, CA 93943 

CPTRobetiROrdonio 1 

9828 Bristol Avenue 

Silver Spring, Maryland 20901 


203 













