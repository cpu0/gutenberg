Draoer Pascal 
Release 1.6 
Manual Addendum 


O -v erview 

The enclosed software is at Release 1.6 level. The differences between Release 1.5 (as 
documented in the manual) and Release 1.6 are as follows: 

1. SuDport has been added to make use of the "Ramdisk" cacabiiitv orovided bv usina 

Atari DOS 2.5 with an Atari 130XE Comouter Svstem. While usina this feature, the 
Editor takes less than two seconds to load and the ComDiler takes less than three 
seconds. 

2. The cooy protection method has been chanaed to be much more convenient. 

The following files have been added to the suDolied Draoer Pascal diskettes in order to 
support the "Ramdisk" feature. 

SETUPD8.PA3 - Setuo Ramdisk Program Source 

SETUPD8.PCD - Setup Ramdisk Program Pcode 

COPYFILE.OBJ - Machine languaae subroutine used bv the SETUPD8 proaram 

COFYLIST.TXT - List of files to be coDied to the "Ramdisk" 

This addendum describes how to make use of these enhanced features. 

Diskette Preparation for Ramdisk 11 supoort 

To utilize the "Ramdisk" supoort, vou must replace the supplied DOS with vour coov of 
Atari DOS 2.5. We suggest that you onlv prepare ONE of the enclosed diskettes and save 
the other one as-is for use as a backuD. 

1. Boot your Atari DOS 2.5 diskette. 

2. Replace the Atari DOS 2.5 diskette with one of the suDolied Draoer Pascal 
diskettes. 

3. Use the DOS function "G" to Unlock DOS.SYS and DUP.SYS. 

4. Use the DOS function "H" to save DOS to the Draoer Pascal diskette. 

5. Use the DOS function "O'* (or ,, C , ‘ if you have two disk drives) to coov the file 

RAMDISK.COM from your DOS 2.5 diskette onto the Draper Pascal diskette. 

How to use the "Ramdisk 8 ' feature. 

1. Boot the Draper Pascal diskette that was properly prepared, as described above. 

2. Select "1 - Run Program" from the menu and enter the program name SETUPD8. 


If you have additional files that vou would like to have automatical^ loaded into the 
"Ramdisk", just add the file name into the file COFYLIST.TXT, usina the Editor. You can 
copy and modify the program SETUPD8.PAS to coov files back to a real diskette from the 
"Ramdisk", if you like. 

If you setup the Ramdisk, then ao to DOS, you can get back into Pascal by using the DOS 
L function to load the file D6:PASCAL.OBJ. Then vou will have to out the Draoer Pascal 
disk in drive one and select "1" to run SETUPD8 again. 

Note that the Pascal source code on the disk for the EDITOR and INIT programs is 
slightly different than that shown in the manual. Chances were made to suooort the 
Ramdisk enhancement. 

Copy Proteotion Enchancement 

Using Release 1.5, you were required to have the Draoer Pascal diskette in drive 1 
whenever you did a compile. In release 1.6, this is not necessarv. The Suoervisor must 
now be loaded using a supolied diskette, if a comoile is to be done later. Copy 
protection is checked at Supervisor load time. After the Suoervisor is loaded, you mav 
remove the Draper Pascal diskette and use a copied version from that point on. 





DRAPER 

PASCAL 


Draper Software 
307 Forest Grove 
Richardson, Texas, 75080 
<214) 699-9743 
CompuServe 70235,602 


Required hardware: 

Atari 400, 800, XL, or XE series computer 
48K RAM Memory <For Compiles) 

32K RAM Memory (For Compiled program execution) 
1 Atari 810/1050 Disk Drive (or equivalent) 


Copyright 1985 by Norm Draper 

No part of this manual or machine 
readable material may be reproduced 
without the consent of the author. 


* Atari is a registered trademark of Atari, Corp. 










TABLE O IF* C OMTEMTS 


Introduction--- 

What is Pascal? - 

What is Draper Pascal? - 

About this manual - 

What is Draoer Pascal made of? 

About the DOS - 

Getting Started - 

The Main Menu - 

1 - Run Program - 

2 - Disk Directory - 

3 - Compile Program —- 

4 - Edit a Program - 

5 - Exit to DOS - 

6 - List a file - 

7 - Trace on-- 

The Edi tor --- 

Key Points -- — 

General Prompts - 

The Commands --- 

A - Add line(s) at end - 

C - Change line(s) - 

D - Delete Iine(s) --- 

E - Edit Iine(s) - 

F - Filer menu - 

A - Append file - 

D - Directory list - 

L - Load file - 

S - Sa v e file -- 

I - Insert before line --- 

L - List Iine(5) - 

M - Menu ——- 

P - Print 1ine(s ) - 

Q - Quit - 

3 - Sc an 1ine(s ) - 

X - Exit to Compiler - 

The Compiler --- 

The Supervisor - 

Pascal Definitions - 

ABS- 

ADDR- 

AND- 

ARCTAN - 

ARRAY - 

ASC- 

BEGIN - 

BLOAD - 

BOOLEAN--- 

CALL- 

CASE - 

CHAR- 

CHR- 

CLOSE- 

COLOR--- 

CONCAT - 

CONST - 

COPY- 

COS- 

CVTREAL-- 

DEG--- 

DELETE- 

D I V- 

DOS- 

DRAWTO - 

DUMPSTK - 

DVSTAT - 

EOF- 

EOLN - 

EXIT- 

EXP- 

EXP10 - 

FALSE - 

FILE- 

FOR- 

FUNCTION - 

GOTOXY - 

GRAPHICS - 

HIMEM - 


1 - 1 

— 1-1 
■- 1-1 

- i -1 
■- l-l 

- 1-1 
2-1 

3- 1 

- 3-1 

- 3-1 

- 3-1 

- 3-1 

- 3-1 

- 3-2 

- 3-2 

4- 1 

- 4-1 

- 4-2 

- 4-2 

- 4-2 

- 4-2 

- 4-2 

- 4-2 

- 4-3 

- 4-3 

- 4-3 

- 4-3 

- 4-3 

- 4-3 

- 4-3 

- 4-3 

- 4-3 

- 4-4 

- 4-4 

- 4-4 

5- 1 

6 - 1 
7-1 

- 7-1 

- 7-1 

- 7-1 

- 7-2 

- 7-2 

- 7-2 

- 7-3 

- 7-3 

- 7-4 

- 7-4 

- 7-4 

- 7-5 

- 7-5 

- 7-5 

- 7-5 

- 7-6 

- 7-6 

- 7-6 

- 7-7 

- 7-7 

- 7-7 

- 7-8 

- 7-3 

- 7-8 

- 7-9 

- 7-9 

- 7-10 

- 7-10 

- 7-11 

- 7-11 

- 7-11 

- 7-12 

- 7-12 

- 7-12 

- 7-12 

- 7-13 

- 7-13 

- 7-14 

- 7-14 


i 
















































































IF --- 7-15 

INSERT- 7-15 

INTEGER - 7-15 

IORESULT- 7-15 

KEYPRESS- 7-16 

LENGTH -- 7-16 

LN- 7-16 

LOCATE- 7-16 

LOCK - 7-17 

LOG - 7-17 

LPENH, LPENV - 7-17 

MAXGRAPH- 7-13 

MOD- 7-13 

NOT--- 7-13 

NOTE - 7-1? 

ODD - 7-19 

OPEN- 7-20 

OPT IONKEY - 7-20 

OPTIONS - 7-20 

OR- 7-21 

ORD- 7-21 

PADDLE - 7-22 

PEEK - 7-22 

PLOT- 7-22 

POINT- 7-22 

POKE - 7-23 

FOS- 7-23 

PROCEDURE - 7-23 

PROGRAM- 7-24 

PTRIG- 7-24 

PURGE - 7-25 

RAD - 7-25 

READ, READLN- 7-25 

REAL - 7-25 

REPEAT- 7-26 

RESET- 7-26 

REWRITE - 7-26 

RND- 7-26 

SELECTKEY- 7-26 

SETCOLOR - 7-27 

SHL- 7-27 

SHR- 7-27 

SIN- 7-23 

SOUND- 7-28 

SQR- 7-23 

SORT- 7-23 

STARTKEY- 7-29 

STATUS - 7-2? 

STICK- 7-2? 

STR-----7-2? 

STRIG - 7-30 

STRING--- 7-30 

TRACEOFF----- 7-30 

1RACEON- 7-31 

TRUE ---- 7-31 

UNLOCK - 7-3 1 

VAL- 7-32 

VAR- 7-32 

WAIT ----- 7-3 2 

WHILE- 7-33 

WRITE - 7-33 

WRITELN----- 7-33 

XCTL -----7-34 

XIO - 7-34 

System Information---- ------ 8-1 

Reserved Word List--- 9-1 

Operators ------ 10-1 

Editor Command Summary------— -- 11-1 

Error Messages - --—-—-- ----- — 12-1 

Compile Time Error Messages - 12-1 

Execution Time Error Messages ------—-— -___- 12-2 

Main Menu Program Source Listing - 13-1 

Editor Program Source Listing-_____-----14-1 

Sample Program Source Listings -- 15-1 

Software License --- 16-1 

Limited Warranty - 17-1 

Owner Registration Fora- 18-1 

i i 
















































































IMTRODUCTIOM 


Draper Software welcomes vou to the world of Pascal for the Atari 400/800 and XL 
series Computer systems. ~ “ " ~ ~ V T 


Wlia.t is Pascal? 

- . r - ' 

Pascal is a hiqh-level structured programming lanauaae developed bv Niklaus Wirth in 
1971. It is easv to understand and well suited for oroqram development and 
maintenance. 


Wfiat xs H> raoer Pascal? 

Draper Pascal is not a "standard” Pascal. It has a number of commands which are 
exactly like ISO and UCSD versions, some which are similar, and many "extensions" 
which brina out the true power of the Atari computer in an easv to use manner. It 
was desianed to require only one disk drive for operation, but not be limited to only 
one. At this time, it has been shown to work with all hardware and software 
configurations where enouah memory is provided. This implementation also has a 
number of commands which are familiar to Atari BASIC users, such as POKE, PEEK, 
SETCOLOR, NOTE, POINT, etc.. 


About tlxis ma.nu a. 1 

This manual is intended to familiarize vou with all the features of Draper Pascal. It 
is not intended to teach you how to program in Pascal. However, if you alreadv know 
Atari BASIC, then you can understand the Pascal statements more easilv bv referring 
to their BASIC equivalents shown after the definition of each Pascal reserved word. 
It is recommended that you read this manual completely to be familiarized with its 
features and restrictions. 


x ss D r a. d e r Faxscoaxl m ^ d ee <o £ ? 

This implementation of Pascal is made up of three mam components. They are the 
Supervisor (sometimes referred to as runtime routines), the Compiler, and the Editor. 
The Supervisor is a high performance machine language program which simulates a 
16-bit pseudo computer. The Compiler translates Pascal source code into pseudo-code 
instructions to be executed by the Supervisor. The Editor is used to enter and 
modify Pascal source programs. It may also be used to edit data files, or BASIC 
programs which have been LISTed to a disk or tape. These components are explained 
in detail within this manual. 

For a description of the various files included on the supplied diskette, refer to the 
’System Information’ section. 


W lx y T w o Diskettes 

The two diskettes included with your Draper Pascal system are identical. One is to 
be used as a backup in the event that something happens to vour first one. You can 
restore the original diskette from the backup diskette using the "J" command of the 
supplied DOS. Never format the supplied diskettes with the DOS "I" command! The 
diskettes supplied with the system are specially altered and one must be resident in 
drive number 1 for the Compiler to function. The Compiler is the only program that 
checks for the special diskette being resident. 


About “t Jtl ee DOS 

The Disk Operating System supplied with Draper Pascal is a special version written 
by Charles Marslett. It’s functions are similar to Atari’s DOS 2.OS with the following 
exceptions. The ’J’ command will not duplicate all 720 sectors of a disk. There is 
one altered sector, for copy protection purposes, which is not copied by the ’J‘ 
command. Also, a new feature is added to the DOS. If you have a dual density 
Percom disk drive, you may easily change the density from sinale to double, or vice 
versa, with the ’P’ command. To do it, enter ’P’ and press RETURN. Then enter the 
disk drive number (usually i or 2), followed by a comma, and the density desired CD ! 
for double, or ’S’ for single). That’s all there is to it. 


1-1 




GETTING STARTED 


This section is intended to show by example how to use the Draper Pascal system. 

You will edit, compile, and run a sample program. Information displayed by the 

computer is shown in normal type while responses to be entered by you are shown in 
To begin with, make sure you have 48K RAM installed and no 

cartridge in place. Boot the disk now by placing it in disk drive 1 and turning on 

the power to the Atari computer. 


DRAPER SOFTWARE 
ATARI PASCAL SYSTEM 

1 - Run Program 

2 - Disk Directory 

3 - Compile Program 

4 - Edit a Program 

5 - Exit to DOS 

6 - List a file 

7 - Tr ace on 


Copyright 1985 
b y No rm Dr a pe r 


<3 


Select the Editor 


DRAPER SOFTWARE 
EDITOR 

A - Add 1ine(s) at end 
C - Change line(s) 

D - Delete line(s) 

E - Edit a line 
F - Filer menu 
I - Insert before line 
L - List line(s) 

M - Menu 

P - Print line(s) 

Q - Quit 

S - Scan line<s) 

X - Exit to Compiler 
A ,C ,D, E ,F , I ,L,M,P,Q,S,X # ? — > F 

A - Append file 
D - Directory list 
L - Load file 
S - Save file 

IE- 


Select Filer menu 


Load a file 


Enter filename -> S A M P L E 1 


A,C,D,E,F,I,L,M,P,Q,S,X,?-> E. 


Enter the name of the file to be 
loaded. The name of the last 
file edited, compiled, or run will 
be filled in bv the Editor. You 
may have to overtype it with 
the name shown. 

List the file on the screen 


2-1 



Line from -> 

Line to - > 

1 : PROGRAM KALEIDOSCOPE ; 

2 :VAR I /J,X,V,X : INTEGER ; 

3 : BEGIN 

4: MAXGRAPH(19); 

5: GRAPHICS<19); 

6 : X: =0 ; 

7: REPEAT 

8: FOR W:*3 TO 50 DO 
9: BEGIN 

10: FOR I:=1 TO 10 DO 

1 1 : BEGIN 

12: FOR J:=0 TO 10 DO 

13: BEGIN 

14: K : = I + J ; 

15 : COLOR<J*3/ < I+ 3 > + I*W/ 12) ; 

16 : P LOT < I + 8,K) ; 

17 : P LOT< K + 8 , I) , 

18 : P LOT <32—1 ,24-K) ; 

19 : P LOT <32-K, 24-1) ; 

20 : PLOTCK + 8,24-1) ; 

2 1 : P LOT(3 2-1 ,K> ; 

22 : P LOT( I + 8 ,24-K) ; 

23 : P LOT <32-K, I > 

24: END 

2 5 : END 

26 : END 

27: UNTIL X=99 <* UNENDING LOOP *) 

2 8 : END . 

A,C,D,E,F,I,L,M,F,Q,S,X,?-> I 


Line - > IS 


Just press RETURN for 'Line 
from* and 'Line to*. This will 
give a list of the entire 
program in memory. 


Let’s insert a comment line 
before line number 15. 

Enter the data to be inserted 
when prompted for line 15. J 
press RETURN when promo 
for line 16. This will termin 
insert mode. 


15: <** r1Y FIRST 

1 6 : 

A,C,D,E,F / I ,L,M,F,Q,S,X, ?->H. 



EDI T ** > 


List again to verify that the 
change was made correctly. 


2-2 


p ^ d 




L 

L 


i ne 
i ne 
1 : 
2 : 

3 : 

4 : 

5 : 

6 : 

7 : 

8 : 
9 : 

1 0 : 
1 1 : 
1 2 : 
1 3 : 
1 4 : 
1 5 : 
1 6 : 
1 7 : 
18 

1 9 : 
20 : 

2 1 : 
22 : 

23 : 

24 : 
2 5 : 
26 : 

27 : 

28 : 
29 : 


£ r om -> 
to - > 

PROGRAM KALEIDOSCOPE; 

VAR I,J,K,V,X:INTEGER; 

BEGIN 

MAXGRAFH(19); 

GRAPHIC3 < 19); 

X : =0 ; 

REPEAT 

FOR W:=3 TO 50 DO 
BEGIN 

FOR I:=1 TO 10 DO 
BEGIN 

FOR J:sO TO 10 DO 
BEGIN 
K : * I + J ; 

<* MY FIRST EDIT *) 
COLOR <J*3/CX+3> + X*W/l 
P LOT < X+8 ,K) ; 

PLOTCK+8,I>; 

P LOT < 32-1 , 24—K) ; 

P LOT(3 2-K, 24-1 ) ; 

PLOT < K + 8 , 24-1 ) ; 

P LOT(3 2-1 /K) ; 

PLOT < 1+8 , 24—K) ; 

P LOT <32-K, I ) 

END 

END 

END 

UNTIL X = 9 9 <* UNENDING LOOP 

END . 


2 ) ; 


* ) 


A , C , D , E , F , I ,L,M,P,Q,S,X,?-> IF* 
A - Append file 
D - Directory list 
L - Load file 
S - Save file 


Let's save 
disk drive 
name. 



the program back to 
1 under the same 



Enter filename -> S A ML L E ± 

Now let's exit directly to the 
Compiler. 

A,C,D,E,F,I,L,M,P,Q,S,X,?->X 
Draper Software 

Pascal Compiler 

Version 1.5 


Copyright 1985 
b y No rm Draper 


Enter Filename: 


S A. r-1 IP L E 1 


Enter List Output Filespec 

Default is E: 


Enter name of program to be 
compiled. The name of the last 
program edited, compiled/ or run 
will be filled m by the 
Compiler. 


Just press RETURN at this 
point to have the compile list 
directed to the screen. 



2-3 




0000 PROGRAM KALEIDOSCOPE; 

0000 VAR I,J,K,V,X:INTEGER; 

0003 BEGIN 

0003 MA XGRAPH < 19); 

0017 GRAPHICS(19); 

001B X; =0 ; 

001E REPEAT 

0022 FOR W:»3 TO 50 DO 

0 0 2A BEGIN 

0035 FOR I:*1 TO 10 DO 

0 0 3 D BEGIN 

0048 FOR J:=r0 TO 10 DO 

0 0 4 F BEGIN 

0 0 5 A K: »I+J; 

00 6 2 COLOR <J*3/<I+3)+I*W/12>; 

0 0 8 A PLOT < 1 + 8 ,K) ; 

0098 P LOT < K + 8, I ) ; 

0 0 A 6 PLOT<32-1,24-K); 

0 0 B 8 PLOT <3 2-K, 24—1 > ; 

00CA PLOT <K+8,24-I>; 

0 0 DC P LOT < 32-1 ,K) ; 

0 0 EA P LOT < 1 + 8 ,2 4 —K) ; 

00FC P LOT <32-K, I > 

010A END 

010A END 

010C END 

0 1 1C UNTIL X = 9 9 <* UNENDING LOOP *) 

0142 END. 

0 14 7 

5 Compiler table entries used 
ADDR NAME 


0003 I 
0004 J 
0005 K 
0006 W 
00 07 X 

*** Program Execution Completed *** 

Highest Staok Address Used = SAFF8 
<START)Repeat,<SELECT>Menu,<ESC>Exit 

Press the SELECT key at this 
point to take us to the main 
menu. 

DRAPER SOFTWARE 
ATARI PASCAL SYSTEM 

1 - Run Program 

2 - Disk Directory 

3 - Compile Program 

4 - Edit a Program 

5 - Exit to DOS 

6 - List a file 

7 - Traoe on 


Copyright 1985 
b y No rm Draper 

X 

Select ' 1' to run the program 
that was just compiled. 


2-4 




Enter name of program to be run 


S AMP LEI 

The name of the last program 
edited, compiled, or run wili be 
filled in by the main menu 
program. Overtype the name if 
you want to run a different 
program. 


I8S3SS33SSSSS: 




At this point you should have a nice kaleidoscope pattern being displayed on your 
television screen. To stop it, press the BREAK key. To repeat execution, press the 
START key. To return to the main menu, press the SELECT key. To exit to DOS, 
press the ESC key. 

Another program, SAMPLE2, is also provided for you to practice with. It will display 
Roman numerals for powers of two between 1 and 4096. Compile it, turn on the trace 
via the main menu, and run it. After it is finished, press CTRL-T to display the 
trace table, and CTRL-S to display the stack contents. When prompted for ’Where? 
Filespeo’, enter 'E:'. For a description of the stack display line, refer to the 
’DUMPSTK’ command in the 'Pascal Definitions' section. 


2-5 



MAIN MEMU 


The Main Menu is the initial oroaram to be run bv the SuDervisor. It is written in 
Pascal. The source code is provided for it and you mav customize it as vou see fit. 
The disk filename for the source is 'INIT.PAS*. The Dseudo code oroaram that is 
initially executed is 'INIT.PCD'. It would be wise to coov TNIT.PCD' to another name 
to be used in case vour comDile of the menu oroaram is not successful. Or, vou could 
rename INIT.PAS to somethina else, like NEWINIT.FAS, and compile it to produce 
NEWINIT.PCD. Then vou can use the 'run' option (mentioned below) to test vour 
modified program. 

The Main Menu appears as follows: 

DRAPER SOFTWARE 
ATARI PASCAL SYSTEM 

1 - Run Proar am 

2 - Disk Directory 

3 - Compile Program 

4 - Edit a Program 

5 - Exit to DOS 

6 - List a file 

7 - Trace on 


Copvriaht 1985 
by Norm Draper 


Each of the menu options will now be explained: 


X — Run Proaram 

Use this option to execute a program that has previously been successfuliv compiled. 
You will see the following prompt: 

Enter name of program to be run 

The Main Menu program will fill in the name of the last proaram edited, compiled, or 
run. If this is the one vou want, all you have to do is press RETURN. If it is not 
the one you want, just overtype the name shown with the one you want. 


ZZ — Disk Direct or v 

This option will provide you with a list of all, or selected, files on one of vour disk 
drives. You will receive the prompt 'Filesoec? 1 . If you iust press RETURN at this 
point, you will see a list of all files on drive 1. If you enter ’D2:', vou will see all 
files on drive 2. To show only selected files, use wildcards in the normal manner. 
For example, enter 'DiINIT.*' to show onlv files named INIT with anv suffix. At the 
end of the list, you will be prompted to cress any key to continue. After oressina 
any key, the Main Menu will be re-disolayed. 


3 — Compile Proaram 

This option sends you directlv to the Pascal compiler. You will be prompted for the 
name of the proaram to be comoiled, after the Compiler is loaded. For more 
information, refer to the section of this manual on ’The Compiler'. 


3-1 



4 — Edit a. Pr oq ram 

Control is transferee! to the Draper Software Editor when this option is chosen. For 
more information, refer to the section of this manual on 'The Editor'. 


5 — Exit *<=> DOS 

Pascal execution is terminated by this option. Control is passed to the Atari Disk 
Operating System. 


<S — List: aa. file 

This convenience entry is provided to allow you to view, on the screen, any text file 
on disk or tape. You are prompted to enter the name of the file to be listed. The 
file is assumed to reside on disk drive 1 if a colon <:) is not found within the name 
you specify. At the end of the list, you will be prompted to press any key to 
continue. After pressing a key, the Main Menu will appear again. 


"7 — Trance <z> n 

The wraparound internal trace may be turned on (or off) with this option. The trace 
is used only for debugging purposes and may be viewed at program termination time 
by pressing CTRL-T. Program execution speed is slightly degraded while the trace is 
active. You will be prompted to enter the number of trace entries to be maintained 
by the system. Each trace entry requires 9 bytes of storage at the high end of 
memory. The trace may not be used during graphics displays because screen memory 
is also at the high end of memory. To turn the trace off and remove the memory 
allocation of the trace table, enter zero when prompted for the number of entries to 
maintain. 


3-2 



THE EDITOR 


The Editor is used to create, modify, and save Pascal source files. It may also be 
used to process other text type files, like BASIC programs which have been LISTed 
to disk or tape. It is a line oriented editor. Combined with some type of formatting 
program, it may be used for word processing applications. The entire source to be 
edited must be in memory at one time. If your Pascal program will not fit within the 
limits of the Editor, then you can use the INCLUDE feature of the Compiler to allow 
segments of a program to be edited separately. Refer to the section on "THE 
COMPILER" for more information on the INCLUDE feature. Source code for the Editor 
is provided on the diskette supplied under filename 'EDITOR.PAS'. Some key points to 
be noted about this editor are as follows: 


1. Each line is referred to by line number, however, no line numbers are stored 
either internally or on the disk or tape. 

2. Each line may contain up to 80 characters. This may be changed by altering 
the constant called MAXLENGTH and re-compiling the Editor. 

3. A maximum of 250 lines of text may be edited at' one time. This may be 
changed by altering the constant called MAXLINES and re-compiling the Editor. 
An increase in MAXLINES should correspond with a decrease in MAXLENGTH, 
and vice versa. 

4. When entering or editing a line, the line must be terminated by pressing the 
RETURN key. 

5. As lines are inserted into, or deleted from, the source file, the remaining 
lines are automatically renumbered. 

6. A line of source may extend onto more than one screen line. 

7. Due to operation of the Atari operating system, a blank line may not be 
directly entered. To enter a blank line, you must first enter a non-blank 
character (like a period), then use the Editor Change command to change the 
character to a space. 

8. Input operations (Append and Insert) are terminated by entering a null line 
(just pressing the RETURN key). 

9. The BREAK key is disabled by the Editor to prevent loss of data. It is enabled 
again at termination of the Editor. 

10. If you enter or change data then try to Quit or exit to the Compiler without 
first saving the data onto disk, you will receive an option to either save the 
data or ignore it and continue. 

11. Cassette tape files may be loaded, edited, and saved by the Editor. The 
Compiler does not support tape input, though. You would first have to load the 
file from tape, with the Editor, then save it to disk. 


4-1 



EDITOR 


COMMANDS 


General Prompts 

The following prompts are general in nature and are common among many of the 
editor commands to be described below. 

Line — > 

You are prompted to enter one line number, as opposed to a range of line numbers. 
It is used by the INSERT Editor command and refers to the line before which the 
inserted line(s) will be placed. 

Line from —> 

This is the first prompt for a range of line numbers. Enter the low number of the 
range. If you just press RETURN, line number 1 is assumed. 

Line -to —> 

Enter the high line number in the range desired. If only one line is to be acted 
upon, that number must be entered in both this prompt and the one mentioned above. 
If you just press RETURN, the highest line number in the buffer will be assumed. If 
the number you enter is less than the 'Line from' value, the 'Line from* value will be 
used here. 

Ent e r filename —> 

This prompt is shown when loading, appending, and saving files. The last filename 

used is filled in after the arrow. If this is the file you wish to use now, then all 

you have to do is press RETURN. A full filespec may be entered, but is not required. 

If a colon (:) is not found within the filename specified, then 'Dl:' is assumed, if the 

filename given does not contain a period (.), then a suffix of PAS is assumed. 

X hi e Commands 

A — Add line(s) a t end 

This command is used to add lines after the last line currently in the buffer. If the 
buffer is currently empty, then line 1 will be assumed as the starting point. In this 
manner, you can create a new file if one has not been loaded. You can append as 
many lines as you like. When you are finished entering lines, just press RETURN 
without entering any data on the line (null line). 

Prompts used: None 

C — Gbiange line (s) 

The Change command allows you to change one specified string pattern to another 
for the first occurance in each line within the range of lines specified. After being 
prompted for the line number range, you are asked for the data to 'Change from ->' 
and 'Change to ->'. Enter any string of characters at each prompt. Imbedded blanks 
are allowed. If you just press RETURN for the 'Change to' prompt, the first 
occurance of the 'Change from' data within each line will be deleted. 

Prompts used: 'Line from', 'Line to', 'Change from', 'Change to' 

D — Delete lxn«a Css> 

This command allows you to delete a line or a range of lines from the file in 
memory. The whole file in memory will be deleted if you just press RETURN when 
prompted for both 'Line from' and 'Line to*. Be aware that all lines following the 
range deleted will be renumbered, to fill the gap just made. If you desire to delete a 
number of line ranges, delete those with the highest numbers first and proceed 
toward the beginning of the file. That way, you won't have to do a LIST after each 
range delete to find out what the new line numbers for the following lines are. 
Prompts used: 'Line from', 'Line to’ 

E — Edit line(s) 

The Edit command is used to edit (or make individual changes to) a line or range of 
lines that already exist in memory. If a range is specified, the lines are presented 
to you one at a time. As each line is presented, you may use any of the normal 
Atari editing keys (like right and left cursor, insert, delete), to alter the data. Just 
press RETURN when you are finished with each change. If you don't want to make a 
change to a line shown, just press RETURN. 

Prompts used: 'Line from', 'Line to’ 


4-2 



F — Filer menu 

The Filer is a subsystem which handles communication with an external device (disk 
or tape). The features provided are as follows: 

A — Append file 

A file is read from disk or tape and added to the end of the file currently in 
memory. The data in memory prior to the append remains unchanged. 

Prompts used: ‘Enter filename' 

JD — D irectory list 

This command is used to provide a directory list of the different files on a 
diskette. You are prompted for ‘Filespec?'. Enter the disk drive number and 
selection criteria for the directory list. If you just press RETURN you will see 
a directory list of all files on drive number one. To see all files on drive 
two, enter 'D2:' or *D2:*.*'. To see only files with a suffix of PAS on drive 
one, enter ’D:*.PAS’ or ’D1:*.PAS'. 

Prompts used: ’Filespec?' 

L — Load file 

This is the way to load a file into memory from disk or tape. If any data was 
currently in memory, it is deleted and replaced by the file read in. 

Prompts used: 'Enter filename' 

S — Save file 

Data is copied from memory to disk or tape with this command. The data 
currently in memory remains unchanged. You are prompted for filename and may 
use whatever name you wish. It is not necessary to save a file under the 
same name as was used to load the file. You should save data to disk 
frequently if you are making extensive changes. That way you won't have to 
re-do as much if something goes wrong. 

Prompts used: 'Enter filename' 

I — Insert before line 

This command allows you to insert one or more lines at any point within the file in 
memory. The inserted data is placed before the line number you specify. To terminate 
insert mode, just press RETURN without entering any data on the same line (null 
line). Note that all lines after the point of insertion will automatically be 
renumbered. 

Prompts used: 'Line ->' 

3L — List line > 

One or more lines of data from memory are listed on the screen with this command. 
During the list, you may stop the scrolling by pressing either the space bar or 
RETURN. To resume scrolling, press any other key other than ESC. The ESC key may 
be pressed to prematurely terminate the listing. 

Prompts used: 'Line from', 'Line to' 

r-t — Menu' 

The main Editor menu is presented in response to this command. A question mark (?) 
may also be used to display the main menu. 

Prompts used: None 


F — Print line<s) 

This command is used to create a list of data in memory on a printer attached to 
the parallel port of an Atari 850 Interface <P:>. Internal line numbers are also 
directed to the printer although they do not actually exist within the file on disk or 
tape. 

Prompts used: 'Line from', 'Line to' 


4—3 



Cal — Ql uit 

This command is used to exit from the Editor when you are finished editina your 
data. Control is given to the Main Menu program. If you have changed the data in 
memory and have not saved it prior to, guittina, you will be given the option of 
saving the data or ignoring the changes and exiting. If you are going to compile a 
Pascal program immediately after guittina the Editor, you may use the 'X' command 
described below. 

Promots used: None 


— S c an 


This command allows you to display all lines within a specified range which contain 
a specified character string. The character string may contain any characters, 
including imbedded blanks. To temporarily stop the listing, press either the space bar 
or RETURN. To abort the listing, press ESC. Press any other key to continue as 
normal. 

Prompts used: 'Line from', 'Line to', 'Scan for' 

X — Exit to Compiler 

This command terminates the Editor and transfers control directly to the Compiler. If 
the file in memory has been changed but not saved prior to the Exit command, you 
will be prompted to either save the file or ignore the changes and proceed to the 
Compiler. 

Prompts used: None 



4-4 



THE COMPILER 


The compiler is used to translate words that we humans understand into "words' 8 
that the computer can understand. The computer words are referred to as 
pseudo-code, or p-code for short. These pseudo-code instructions are understood and 
executed by the Supervisor. 

This is a goal oriented compiler. It expects the proper syntax for a statement. If 
correct syntax is not found, the compilation stops, and an error number with 
associated text description is displayed. At this point, you are given the option of 

quitting or returning to the Editor to correct the problem and do the compile again. 

The Compiler itself is written in Draper Pascal and occupies about 28K of RAM 
memory space. 

The first prompt from the Compiler is 'Enter filename:'. The name of the last program 
edited, run, or compiled is filled in for your convenience. If this is the one you 

want, just press RETURN. If it is not the one you want, just overtype it with the 

name you desire. The name you provide will become the new default name for the 
Editor, Compiler, and Main Menu 'Run' option. No suffix is allowed when specifying 
filename. The Compiler will add the standard '.PAS' to it for you. If the source does 
not reside on disk drive 1, then you must prefix the filename with 'Dn:' where 'n' is 
the disk drive number where the source resides. 

The next prompt is 'Enter List Output Filespec'. The default (if you just press 
RETURN) is the screen <E:>. The list output may go to any normal output device, such 
as printer or disk. 

A number of additional points are mentioned below: 


1. Comments are delimited by '<*' on the left end and '*)' on the right end. Any 
characters may appear within comments. Comments may appear anywhere within 
the program. 

2. 'Include' files are supported. You may have procedures, functions, or any part 
of a program included in a compile, even though it is not actually part of the 
file being compiled. It is a variation of a comment which allows you to do 
this. The format is as follows: 

<*$I D1:XXXXXXXX.PAS *> 

The format is strict. The dollar sign and 'I' must be right next to '<*' and 
must be followed by one space. Then you should mention the 'D' for disk and 
drive number (if other than drive 1). Follow it with a colon (:) and the 
filename, including the '.PAS' suffix. Then have one space and '*)*. 

3. Pascal source files must reside on disk. 

4. The output pseudo-code from the compile will be directed to the same disk 
drive that the Pascal source resides on. It will be created with a filename 
suffix of '.PCD'. 

5. The hexadecimal offset of the pseudo instructions generated is given at the 
left side of the output listing. This offset may be useful for debugging 
purposes. It may be referred to when looking at a program trace (see TRACEON 
in the Pascal Definitions section of this manual). It also may be referred to 
in case of an error message or termination caused by pressing the BREAK key. 
The offset shown may not always be accurate. If not exact, the values are 
very close. 

6 . The name and stack offset of each variable defined is shown at the end of 
the compile listing. The offset value is shown in hexadecimal. Each stack 
entry is two bytes wide. The first three stack entries are reserved for system 
use. Therefore, the offset of the first variable will be 0003, which is actually 
six bytes into the stack. If a variable is defined within a procedure or 
function, the offset shown is relative the beainning of that procedure or 
function. 

7. The program is ready to run immediately after the compile is finished. No 

linking is required. (Some Pascal systems require linking of output code after 
the compile and before execution). » ^ 

8. Nested procedures are supported. You may define one procedure within another. 


5-1 



9. 


Recursive procedures are supported. A procedure may call itself. If variables 
are defined within the procedure, they are cleared with each entry into the 
procedure and refreshed upon exit from the recursive procedure call. 

10. No forward references are allowed. A procedure may not be referenced before 
it is defined. In most cases, nesting the procedures will take care of this 
problem. 

11. The Compiler disk must be in drive number 1 during each compile. 

12. Double density disk drives are supported for both source and pcode files. 

13. Only integer type parameters may be passed to procedures and functions. Other 
types of data may be passed by using global type variables setup at the 
beginning of the program (not within a procedure or function). 

14. A function may only return an integer type value. Procedures do not return 
values. 

15. Hexadecimal constants are prefixed by dollar signs ($). 

16. To write out an integer in hexadecimal format, precede the variable name with 
a percent sign (%). 

17. A total of 200 compiler table entries may be used. One table entry is used for 
each variable definition, procedure name, function name, and parameter name 
used with procedures and functions. The number of table entries used within a 
compile is displayed at the end of the output list from the Compiler. 

18. The time needed to compile a program can be reduced by turning off the 
ANTIC chip within the computer. This turns off the display to the screen yet 
gives a fairly significant increase to the Atari’s internal speed. In a normal 
Pascal program, you can have POKE<559,0) to turn it off and POKE(559,34) to 
turn it back on. But a special compile time option is provided to make use of 
this feature to speed up compiles. It is as follows. Have a statement (*$S+*> 
to turn the ANTIC off (increase speed), and use (*$S-*> to turn the ANTIC on 
(resume normal speed). These options may appear anywhere within a program. 
The ANTIC is automatically turned back on at compile termination and at time 
of error (if any). 


5-2 



THE 


UPERVISOR 


The Supervisor is a high performance machine language program which simulates a 
pseudo 16-bit stack oriented computer. It executes the pseudo code that is generated 
by the Compiler. 

It is loaded into memory by a custom loader program at the location S1D7C, which is 
just above DOS in memory. It should work with any DOS that allows a program to 
load at that address, such as Atari DOS 2.OS. 


If you have an Atari 850 Interface attached and turned on, the loader program will 
load the RS232 serial interface routine into memory. It will be placed at the high 
end of available memory so that subsequent DOS utility use will not overlay it. 

The disk filename for the loader program is ' AUTORUN.SYS'. The disk filename for 
the Supervisor's object code is 'PASCAL.OBJ*. To start the Pascal system from the 
DOS menu, use the 'L' f binary load, option to load either 'AUTORUN.SYS' or 
'PASCAL.OBJ' into memory. Execution will begin automatically. 

The Supervisor begins execution by loading and executing the Pascal program 
TNIT.PCD' from disk drive 1. TNIT.PCD' is the name of the main menu program. You 
may substitute any compiled Pascal program of your own by naming it 'INIT.PCD'. In 
this manner, you can have a true turnkey system where your program begins 
execution after booting the disk. u 

After termination of each Pascal program, the Supervisor gives you a choice of what 
to do next. You are prompted with the following line. 

<START>Repeat,<SELECT>Menu,<ESC>Exit 

If you press the START key, your Pascal program will execute again from the 
beginning. If you press the SELECT key, control will be transfered to the main menu 
program (INIT.PCD). If you press the ESC key, you will exit to the DOS utility menu. 
You also have two other options at this point. They are both used for debugging 
purposes. If you press CTRL-S (the 'S' key while holding down the CTRL key), the 
stack values, at termination time, will be displayed. If you press CTRL-T, the 
internal trace table, if active, will be displayed. With either of these two debugging 
options, you will be asked where the display should be sent by the prompt 'WHERE? 
(FILESPEC)'. To see it on the screen, enter 'E: 1 . It also may be sent to printer or 
disk by following normal filespec naming conventions. If the display is sent to the 
screen, you may stop the scrolling by use of the space bar. Press the ESC key if you 
have seen enough and wish to return to the Supervisor termination prompt. Any other 
key causes scrolling to continue as normal. 


Trace Format 


A few lines of trace information would look like the following: 


PC = 0 186 
PC = 0 18? 
PC = 0 1 8 C 
PC = 01 8 E 
PC=0190 


INs 2 0 04 

I N = 0 0 88 

IN=10 0C 
I Ns 6 0 07 

INslO 00 


00 SP s 3D E 0 
13 SP s3DE0 
SP s 3D E 2 
SP s 3 D E 0 
SP s 3DDE 


SV=0000 
SVs 0 0 2 0 
SVs 8 8 1 3 
SV=0 100 
SVs 0 0 2 0 


The 'PC' stands for program counter. It actually refers to the offset of the 
instruction to be executed. This corresponds to the offset shown on the left side of 
the compile listing. The 'IN' stands for instruction. The three bytes following it are 
the actual hex values of the pseudo code to be executed next. 'SP* stands for stack 
pointer. It is the actual address of the current location on the stack. 'SV‘ is stack 
value. The stack width is two bytes, so two bytes are shown. The whole line of 
information is displayed before the instruction is actually executed. The actual 
meanings of the various pseudo instruction codes are not included with this manual 
but may become available in the future. 



F> AS CAL DEFIMITIONS 


ABS FUNCTION AES(Number) .INTEGER; 

This function returns the absolute value of ‘Number 1 . In effect, all % it does is 
return the value of ‘Number' with a positive sign. 'Number* may be any integer 
expression. 

Example; PROGRAM ABS_DEMO; 

VAR AJ , J : INTEGER *, 

BEGIN 

J: = - 7; 

AJ : = ABS <J) ; 

WRITELN('ABS OF -7 IS ',AJ) 

END . 

BASIC Equivalent: AJ * ABS<J> 


ADD Ft FUNCTION ADDR(Var): INTEGER; 

This function returns the integer absolute address of the specified variable. 
The variable may be of any type. If it is an element of an array, the address 
returned is that of the particular element specified. For a description of the 
data formats, see the item titled 'Internal Data Formats' in the 'System 
Information' section of this manual. 

Example; PROGRAM ADDR__DEMO ; 

VAR A,B:INTEGER; 

BEGIN 

A := ADDR< B) ; 

WRITELN<'ADDRESS OF B IS *,A) 

END . 

BASIC Eauivalent: A ■ ADR(J$) (Applies only to string variable in Atari 
BASIC) 


AND 

This operator sets the resulting condition as true if both the left and right 
factors around it are true, otherwise, the condition is set to false. 
Parentheses should surround the factors on each side. ' 

Example: PROGRAM AND_DEMO; 

VAR A:INTEGER; 

BEGIN 

IF (A > 0) AND < A < 7) THEN 

WRITELNC'VALUE WITHIN RANGE'> 

END . 

BASIC Equivalent; Same as Pascal 


7-1 



ARCTAN 


FUNCTION ARCTAN(Var):REAL; 


ARCTAN is a REAL built-in function that returns the value of an angle whose 
tangent is equal to the value of the variable specified. 'Var' may be either a 
REAL variable or an INTEGER variable, but the value returned is always REAL. 

Example: PROGRAM ARCTAN^DEMO; 

VAR R1 ,R 2 :REAL; 

BEGIN 

VRITELNC 'Enter a numb er ' ) ; 

READ < R1 ) ; 

R 2 : =ARCTAN < R1 ) ; 

WRITELN<'The ARCTAN of ',R1,' is ' ( R2) 

END . 

BASIC equivalent: R 2 =ATN < R1 ) 


ARRAY ARRAYCNumberl OF Type 

ARRAY specifies that multiple occurances of a variable are to be defined. Only 
single dimension arrays may be defined. 'Number' may be either an integer 
number or a previously defined integer constant. It soecifies the number of 
elements to be dimensioned. Space is reserved for 'Number' + l entries because 
occurance numbers of zero through 'Number* are allocated. This means that 
ARRAYC23 defines space for three entries, numbered 0, 1, and 2. While using an 
array, note that the index for the element in tire array, which is specified 
within parentheses 'O', must either be an integer number or an integer type 
variable. Integer type expressions may be allowed in a future release of the 
Compiler. , 

Examples: PROGRAM ARRAY DEMO; 

CONST S I Z E = 4 
VAR I:INTEGER; 

Al: ARRAY C 3 3 OF INTEGER ; 

A2 : ARRAY C SIZE 3 OF STRING; 

BEGIN 

FOR I : a 0 TO 3 DO 
Al < I > : = 1 ; 

FOR I:s0 TO SIZE DO 
A 2 ( I > : * ’ ' 

END . 

BASIC Equivalent: DIM A<3> 

No equivalent for BASIC string variables. 


ASC FUNCTION AS C(Cvar): INTEGER; 

This function returns the ASCII value (integer) of the specified character 
variable. 

Example: PROGRAM ASC^DEMO; 

VAR I:INTEGER; 

CH:CHAR; 

BEGIN 

CH:='A'; 

I : » ASC(CH) ; 

WRITELNC'THE ASCII VALUE OF ',CH,' IS *,I) 

END . 

BASIC Equivalent: I a ASC(CH) 


7-2 



BEGIN 


BEGIN marks the start of a block or compound statement within a Pascal 
program. END marks the termination of the block or compound statement. Each 
statement between the BEGIN and the END, except for the last one, should be 
followed by a semicolon (;>. 

Example: PROGRAM BEGIN. DEMO; 

BEGIN 

VRITE LN('My name is Fred’); 

WRITELN; 

VRITELN 
END ; 

BASIC Equivalent: None 


BLOAD PROCEDURE BLOAD(Program); 

This exclusive built-in procedure loads the specified program (or data) from 
disk into memory. The program to be loaded should be in the standard DOS II 
load format as generated by an appropriate assembler or the binary save 
function of DOS II. 'Program' should be specified in the normal filespec 
format, including extension, if any. The obiect loaded will not automatically 
begin execution after completion of the load, as some programs do. The 
machine language program will be executed by use of the CALL built-in 
procedure. Refer to the CALL description for further information. The 
IORESULT value should be checked after the BLOAD to verify that the program 
did, in fact, exist on the disk. 


Explanation for example: 

The Pascal program below sends the ASCII value of each of the upper case 
letters to the 6502 assembler subroutine. The subroutine changes the 
character to inverse and then changes it into a lower case character before 
returning control to the Pascal program. The Pascal program then retrieves 
the character from the subroutine, prints it on the screen, and repeats until 
the alphabet is complete. 


Example: PROGRAM BLOAD DEMO; 

VAR I.INTEGER; 

CH:CHAR; 

BEGIN 

BLOAD('D:TEST.OBJ'); 

IF IORESULT <> 0 THEN 

WRITELN('TEST.OBJ NOT ON DISK'); 
FOR I : = ' A * TO •2’ DO 
BEGIN 

POKE($600,1); 

CALL($601) ; 

CH:sPEEK($ 600 ) ; 

WRITE(CH) 

END ; 

WRITELN 
END . 


* * * 6 5 0 2 


Assembler subroutine used in above demo 


10 

20 

30 

4 0 

5 0 
60 
70 
80 
90 


* = $600 
ADDR1 .BYTE 
LDA ADDR1 
ORA #$80 
CLC 

ADC #32 
STA ADDR1 
RTS 
. END 


0 

Get character from Pascal 
Make character inverse 
Prepare for add instruction 
Make character lower case 
Put back character for Pasca 
Return to Pascal program 


1 


BASIC Equivalent: None, however some BASIC programs POKE machine language 
programs into memory after READing the ASCII values for each byte of the 
program as contained in DATA statements. 


7-3 



OOLEAN 


BOOLEAN is a type code which can represent one of two states, TRUE of 
FALSE. The actual value is either zero for FALSE or one for TRUE. A BOOLEAN 
variable can be used to save the result of a condition. 

Example: PROGRAM BOOLEAN DEMO; 

VAR ANSWER:BOOLEAN; 

BEGIN 

ANSWER:=TRUE; 

ANSWER: * FA LSE ; 

ANSWER:* X < 0 

ANSWER:* <X < 0) OR <X > 99) 

END . 

BASIC Equivalent: None 


CALL PROCEDURE CALL(Address); 

The CALL procedure transfers execution to a machine language proaram at the 
specified address. 'Address* is any integer expression, which includes hex 
constants It is equivalent to the assembler operation JSR (jump to 
subroutine). The subroutine should return control to the Pascal program by 
using the RTS (return from subroutine) operation. No parameters are passed to 
the subroutine directly, so the 6502 stack will not be loaded with a number of 
parameters, as is done by Atari BASIC. This simplv means that the machine 
language subroutine should not have a PLA (pull accumulator) instruction at 
its start as is customary with machine language subroutines called from an 
Atari BASIC USR instruction. 

Example: Refer to BLOAD example 

BASIC Equivalent: None, but quite similar to the USR instruction, as mentioned 
above. 


CASE 

CASE 

exprl 

OF const 1 
const2 : 

: stmtl; 
stmt2; 


END; 


constn 

: stmtn 


CASE 

exprl 

OF const 1 
const 2 : 

: stmtl; 
stmt2; 


ELSE 

END; 

stmtx 

constn 

: stmtn 


The CASE statement compares the result of an expression with several 
constants to determine the appropriate statement to be executed. 

Example: PROGRAM CASE DEMO; 

VAR DAY:INTEGER; 

BEGIN 

WRITE( 'Enter day numb e r ' ) ; 

READ(DAY); 

CASE DAY OF 

1 : WRITELN(‘Monday'); 

2 : WRITELN('Tuesday'); 

3 : WRITELN('Wednesday'); 

4 : WRITELN('Thursday'); 

5 : WRITELN('Friday'); 

6 : WRITELN('Saturday'); 

7 : WRITELN(■Sunday»> 

ELSE 

WRITELN('Invalid day number') 

END 
END . 


BASIC Equivalent: None 


7-4 





<3 HAH 


This is a type code assigned to variables to be used in character format. 

Example: PROGRAM CHAR DEMO; 

VAR CH:CHAR; 

BEGIN 

READ < CH) ; 

CASE CH OF 

•A' : WRITELNC’First letter 1 ); 

'B’ : VRITELNC'Last letter’) 

END 
END . 

BASIC Equivalent: None. 


CHR FUNCTION CHR<exprl):CHAR; 

This function changes an integer value into a character format, ’exprl’ may be 
any integer expression. If the value of 'exprl' is greater than 255, then the 
ASCII value of the character value returned will be ’exprl’ modulo 256. 

Example: PROGRAM CHR DEMO; 

VAR CH:CHAR; 

I:INTEGER; 

BEGIN 

VRITE<'Enter a number between 0 and 255 '); 

READ <I) ; 

CH:=CHR<I); 

WRITELNC'The character equivalent is ',CH) 

END . 

BASIC Equivalent: CH = CHR$CI) 


CLOSE PROCEDURE CLOSECFile); 

This built-in procedure closes a previously opened file. ’File' may either be a 
variable of type FILE, or an absolute IOCB number, such as #1. It does not 
hurt to close a file which is already closed. Multiple files may be specified if 
separated by commas. 

Example: Refer to examples for EOF and EOLN 
BASIC Equivalent: CLOSE #2 


COLOR PROCEDURE COLOR(Number); 

This built-in procedure determines the data to be stored in the display 
memory for all subsequent PLOT and DRAWTO built-in procedures. It’s purpose 
is identical to that of the COLOR command in BASIC. Please refer to your 
Atari BASIC manual for further information. 'Number' may be any integer 
expression. 

Example: Refer to example for GRAPHICS 
BASIC Equivalent: COLOR 2 


7-5 



CONCAT 


PROCEDURE CONCAT (P arm 1 ,Farm2,...) .STRING; 


This built-in function returns a string value equal to the concatenation of all 
parameters specified in the CONCAT function. These parameters may be of type 
string constant, string variable, or character variable. 

Enamele: PROGRAM CONCAT DEMO; 

VAR PGMNAME:STRING; 

BEGIN 

WRITE('Enter file name '); 

READLN(PGMNAME > ; 

PGMNAME :« CONCAT< PGMNAME, * .TXT * ) ; 

END . 

BASIC Equivalent: PGMNAME$<LEN<PGMNAME$+ !>) = '.TXT* 


CONST CONST namelsvaluel; n am e 2 * v a 1 u e 2 ; ... 

CONST is used to declare constants to be used within a program. The value of 
a constant cannot be changed. The values may be of type integer or real. 
String constants are not permitted. The most efficient method for simulating 
string constants is to declare space for them with the VAR declarative, then 
read in the values from a disk file. 

Example: PROGRAM CONST DEMO; 

CONST NUMTIMES = 4; PI * 3. HU; 

VAR I:INTEGER; 

RAD IUS,ANSWER:REAL ; 

BEGIN 

FOR I:»l TO NUMTIMES DO 
BEGIN 

WRITE('Enter radius •>; 

READ(RAD I US) ; 

ANSWER := PI * (RADIUS * RADIUS); 

WRITELN < ‘Circumference is ' ,ANSWER) 

END 

END . 

BASIC Equivalent: None 


CZCDIP'Y FUNCTION COPY(Source,Index,Length) : STRING; 

This built-in function returns a string value composed of a portion of the 
string named by ‘Source*. The portion consists of ‘Lenath* characters starting 
at offset ‘Index* into 'Source'. The first position of a string has the index 
value of 1. 'Index 1 and 'Length' are integer expressions, while 'Source' must be 
of type string. 'Length' must not be negative and must have a value in the 
range 1-255. The same is true for 'Index'. If the value of 'Index' plus 'Length' 
is greater than the length of 'Source', then 'Lenqth' assumes the value of the 
length of 'Source' minus 'Index'. 

Example: PROGRAM COPY DEMO; 

VAR FULL NAME,LAST NAME:STRING; 

I:INTEGER; 

BEGIN 

FULL. NAME := 'SMITH, JOHN B'; 

I := POS(',',FULL NAME); 

LAST NAME : = COPY(FULL NAME,1,I-1); 

WRITELN('The last name of ',FULL NAME, 

' is ',LAST NAME) 

END . 

BASIC Equivalent: A$s=B$(4,7) 


7-6 



cos 


FUNCTION COS(Var) :REAL; 


COS is a built-in function which returns the cosine of the value of the 
variable 'Var'. 'Var* may be either an INTEGER variable or a REAL variable. 
The value returned will always be a REAL value. 

Example: PROGRAM COS DEMO; 

VAR R1 .R2 REAL ; 

BEGIN 

WRITELN('Enter a real number’); 

READ ( R 1> ; 
r 2 * = COS < R 1 ) * 

WRITELN('The cosine of ' f Rl,' is *,R2> 

END . 

BASIC equivalent: R2 = COS(Rl> 

CVTREAL FUNCTION CVTREALCI var) :REAL 

This built-in function can be used to copy the value of an INTEGER variable 
into a REAL variable. ’Ivar 1 must be an INTEGER type variable. 

Example: PROGRAM CVTREAL DEMO; 

VAR I 1 : INTEGER; 

R1 :REAL ; 

BEGIN 

VRITELN('Enter an inteqer number'); 

READ ( ID; 

R 1 : =sCVTREAL (II); 

VR ITELN(R 1 , 1 is now a real number* ) 

END . 

BASIC Equivalent: None 


ID EG PROCEDURE DEG; 

DEG is used to specify that the output values from ARCTAN, COS, and SIN are 
to be expressed in degrees, as opposed to radians. The system defaults to 
radians unless DEG is specified. Once specified, all output is in degrees until 
RAD is specified for radians, or the computer is turned off and back on. 
Example: PROGRAM DEG RAD DEMO; 

VAR R1 ,R2 :REAL ; 

REPLY:CHAR; 

BEGIN 

VRITELN('Enter a D for output in degrees’); 

VRITELN(' or R for output in radians'); 

READ(REPLY); 

CASE REPLY OF 
•D': DEG; 

* R' : RAD 
ELSE 

WRITELNC'That was not one of the choices') 

END ; 

WRITELNC'Enter a real number'); 

READ(R1); 

R2 :=SIN(R1 ) ; 

WRITELNC'The sine of 1 ,R1,' is ',R2) 

END . 

BASIC Equivalent: DEG 


7-7 



DELETE 


PROCEDURE DELETE(Source,Index,Size); 


The DELETE built-in procedure removes a specified number of characters from 
a string. 'Size' characters are removed from the strina, ‘Source', startina at 
offset 'Index*. 


Examole: PROGRAM DELETE DEMO; 

VAR ALPHABET:STRING; 

BEGIN 

ALPHABET: = 'ABCDEFG' ; 
DELETE(ALPHABET,3,2); 
VRITELNCALPHABET) 

END . 


The resultina value of ALPHABET will be 'ABEFG'. 
BASIC Equivalent: None 


DI V 


This operator computes the quotient of the two factors surrounding it. The 
factors may be either of type REAL or type INTEGER. DIV is eauivalent to '/' 
in this implementation of Pascal. 


Ex amp 1e: 



PROGRAM DIV DEMO; 
VAR 11,12:INTEGER; 
R1 ,R 2,R 3 :R EAL ; 

BEGIN 


11 

= 20 

; 

I 2 

= I 1 

DIV 2 ; 

R 1 

= 20 

. 0 ; 

R 2 

= 5 . 

2 ; 

R3 

= R 1 

DIV R 2 


END ; 


BASIC Equivalent: R3=R1/R2 


ID OS PROCEDURE DOS; 

This built-in procedure terminates execution of the Pascal supervisor and 
transfers control to the standard Atari Disk Operating System. For more 
information on the use of DOS, refer to the Atari DOS Manual. 

Example: PROGRAM DOS^DEMO 

BEGIN 
DOS 
END . 


BASIC Equivalent: DOS 



7-8 



ID Ft AWT O 


PROCEDURE DRAWTO(X,Y>; 


The DRAVTO built-in procedure causes a graphic line to be drawn from the 
last coordinate refered to in a PLOT or DRAVTO built-in procedure. The color 
of the line is determined by the most recent setting of the COLOR procedure. 
•X* and 'Y* may be any valid integer expressions. 

Example: PROGRAM DRAVTO; 

VAR X,Y:INTEGER; 

BEGIN 
COLOR( 1 ) ; 

P LOT < 10 , 10 > ; 

X:*20; 

Y : » 3 0 > 

DRAVTO< X,Y) 

END ; 

BASIC Equivalent: DRAWTO X,Y 


DUMPSTK PROCEDURE DUMPSTK; 

This exclusive built-in procedure dumps the values of the Pascal stack to the 
output device of your choice. The output is sent to IOCB #7. If it is already 
open, then it will be used as is. If it is not open, the following prompt will 
be displayed on the screen: 'WHERE? (FILESPEC)'. Enter with a normal device 
specification, such as E:. Each stack entry is two bytes wide. It is displayed 
in the following format: 

STACK ADDRs a a a a HEX = hhhh CHAR = cc 

'aaaa' is the absolute address of this stack entry, shown in hexadecimal 
format, 'hhhh' is the value of this stack entry shown in hex. ‘cc* is the same 
stack entry value shown in character format if the value is determined to be 
printable. Refer to the 'System Information' section of this manual for a 
description of internal variable formats. 

Example: PROGRAM DUMPSTK DEMO; 

BEGIN 

DUMPSTK 
END . 


BASIC Equivalent: None 



DVSTAT 


PROCEDURE DVSTAT(A,B,C,D>; 


This exclusive built-in procedure reads the device status information as 
requested from the STATUS command and stores the values into variables *A\ 
'B', 'C', and *D'. These variables may have any names, but must be predefined 
as integer variables. The values stored into the named variables are taken 
from locations 746 through 749, decimal, within the operating system. The most 
common usaae for DVSTAT would be in checking the status of RS232 ports. 
Consult your Atari 850 Interface Module Operator’s Manual for the meanings 
associated with these different status bytes. 

Example: PROGRAM DVSTAT DEMO; 

VAR BYTE 1 ,BYTE 2 ,BYTE 3 ,BYTE 4 : INTEGER; 

BEGIN 

STATUS < # 1 > ; 

DVSTAT< BYTE 1 ,BYTE2,BYTE3 ,BYTE4) ; 

WRITELN< * Status values are ' , 

BYTE 1 , 1 1 , 

BYTE2,' * , 

BYTE 3 , 1 * , 

BYTE 4> 

END . 

BASIC Eauivalent: A=PEEK<746> 

BssPEEK < 747 ) 

CaPEEK < 748 ) 

DsPECK< 749 ) 


EOF EOF(File); 

This reserved word checks for end of file of an input device. It returns a 
true value if the most recent read of the file has detected an end of file 
mark. 'File* may be either a variable of type FILE, or an absolute IOCB number 
preceded by a 

ExamDle: PROGRAM EOF DEMO; 

VAR INPUT,OUTPUT:FILE; 

DATA:STRING; 

BEGIN 

RESET<INPUT,'D:TEST.TXT'); 

REWRITE(OUTPUT,'D:TEST.NEW 1 ); 

R E P E AT 

READLNCINPUT,DATA); 

WRITELN<OUTPUT,DATA) 

UNTIL EOF(INPUT); 

CLOSE(INPUT.OUTPUT) 

END . 

BASIC Equivalent: 100 TRAP 2000 

2000 IF PEEK(195)®136 THEN ... 


7- 10 



EOLN 


EOLN(File); 


This reserved word checks for end of line of an inout device. It returns a 
true value if the most recent read of the file has detected an end of line 
condition <$9B character). 'File 1 may be either a variable of type FILE, or an 
absolute IOCB number preceded by a *#'. 

Example: PROGRAM EOLN DEMO; 

VAR DATA:CHAR; 

BEGIN 

OPEN< #1 ,4,0, ’D:TEST.TXT* ) ; 

OP EN(#2,8,0, 'D:TEST.NEW' > ; 

REPEAT 

READ <#1 ,DATA) ; 

WRITE(#2,DATA); 

IF EOLN(#1) THEN VRITELN<#2>; 

UNTIL EOF< # 1 > ; 

CLOSE(#1,#2) 

END . 

BASIC Ecuivalent: 100 GET #1,A 

200 IF A s 1 5 5 THEN . . . 


EXIT PROCEDURE EXIT; 

This built-in procedure causes immediate termination of the currently 
executing Pascal program. Control is transfered to the Pascal Supervisor. No 
files are closed. 

Example: PROGRAM EXIT DEMO; 

BEGIN 
EX IT 
END . 

BASIC Equivalent: END 


EXE FUNCTION EXP<Var):REAL; 

The function EXP(Var) computes the value of e to the 'Var* power. 'Var' may 
be either an INTEGER variable or a REAL variable. Tine value returned is 
always a REAL number, e is the base of the natural logarithm. The exponential 
function <EXP) and the natural logarithmic function <LN) are inverse functions. 

Example: PROGRAM EXP DEMO; 

VAR R1 ,R 2 :REAL; 

BEGIN 

R 1 : 3 3 . 0 ; 

R2: 3 EXP <R1 > 

END . 

BASIC equivalent: R23EXP(R1) 


7-11 



EXP X O 


FUNCTION EXP 10 (Var): REAL; 


The function EXPlO(Var) computes the value of 10 to the *Var' power. 'Var' may 
be either an INTEGER variable or a REAL variable. The value returned is 
always a REAL number. The exponential function <EXP10) and the decimal 
logarithmic function (LOG) are inverse functions. 

Example: PROGRAM EXP10 DEMO; 

VAR R1 ,R 2 :REAL; 

BEGIN 

R 1 : = 3 . 0 ; 

R2 : s E X P10 (R1 ) 

END . 

BASIC equivalent: R2 = 10 a R1 


F ALS E 


FALSE is a BOOLEAN constant representing the untrue state. It is internally 
equal to an integer value of zero. 

Example: Refer to the example under BOOLEAN 
BASIC Equivalent: None 


This is a type code used in a VAR declaration. Each file defined is internally 
assigned an IOCB number. These numbers start at one, for the first file 
defined, and increment up to a maximum value of seven. The FILE type 
variables may only be used in input-outout type commands such as OPEN, 
CLOSE, READ, READLN, WRITE, WRITELN, EOF, EOLN, RESET, and REWRITE. 

Example: (Refer to example under EOF) 

BASIC Equivalent: None 


FOR FOR var : = exprl TO expr2 DO statement; 

FOR var : = exprl DOWNTO expr2 DO statement; 

The FOR statement is used to repeat execution of a statement for a predefined 
number of times, 'var* and 'exprl' and *expr2' must be of the same type. The 
types allowed are INTEGER and REAL. Execution is as follows: 

1. 'var' is set to 'exprl'. 

2. 'var' is compared with 'expr2'. 

If 'var' is greater than or equal to 'expr2' (for TO) 
or 'var' is less than or equal to 'expr2' (for DOWNTO) 
proceed to step 6. 

3. 'statement' is executed. 

4. 'var' is incremented by 1 (for TO) 

or decremented by 1 (for DOWNTO). 

5. go to step 2. 

6. exit 

Example: PROGRAM FOR TEST; 

VAR I:INTEGER; 

BEGIN 

FOR I:=l TO 5 DO WRITELN('TEST') 

END . 


BASIC Equivalent: FOR 1 = 1 TO 5 



FUNCTION 


A FUNCTION is a aroup of statements that has a name and executes a certain 
task or alaorithm. The identifier name for the FUNCTION mav be used as a 
variable of tvpe INTEGER. Parameters may be passed to the FUNCTION. These 
parameters must also be of type INTEGER. In this implementation of Pascal, 
FUNCTION may be abbreviated as FUNC. 

Example: PROGRAM FUNCTION TEST > 

VAR A,B:INTEGER; 

FUNCTION SQUARE < NUMB ER) ; 

BEGIN 

SQUARE:= NUMBER*NUMBER 
END ; 

BEGIN <*MAIN*> 

FOR A:=1 TO 5 DO 
BEGIN 

B:aSQUARE(A); 

WRITELNC'THE SQUARE OF ' , A , ' IS ' , B ) 

END 

END . 

BASIC Equivalent: None 


G O T7 OXY PROCEDURE GOTOXY<X,Y); 

This built-in procedure is used to set the position of the cursor. The next 
WRITE will have it's output begin at x-coordinate 'X* and y-coordinate ’Y*. The 
cursor will not actually be moved until the next WRITE occurs. ’X 1 AND ’Y‘ can 
be any integer expressions. 

Example: PROGRAM GOTOXY TEST ", 

BEGIN 

GOTOXY< 12,12) ; 

VRITELN(’MIDDLE OF SCREEN 1 ) 

END . 

BASIC Equivalent: POSITION 12,12 


7-13 



GRAPHICS 


PROCEDURE GRAFHICS(Number); 


The GRAPHICS command is used to select one of the many graphics modes 
available on the Atari computer. For a complete description of the command 
and the modes available, please refer to your Atari BASIC manual. 'Number* 
may be anv integer expression. Note that before using the GRAPHICS command, 
you should execute the MAXGRAFH command to reserve screen memory for the 
mode desired. If you don't, the Pascal stack may overlay part of the screen 
memory and the results would be unpredictable. 

Example: PROGRAM KALEIDOSCOPE; 

VAR I,J,K,W:INTEGER; 

BEGIN 

MAXGRAPH < 19); 

GRAPH ICS < 19) ; 

X : =0 ; 

REPEAT 

FOR W:=3 TO 50 DO 
BEGIN 

FOR I :a 1 TO 10 DO 
BEGIN 

FOR J : = 0 TO 10 DO 
BEGIN 

K : = I + J ; 

COLOR <J*3/(I+3)+I*W/12); 

P LOT < 1 + 8 ,K> ; 

PLOT < K+ 8 , I ) ; 

PLOT( 32- 1 ,24-K) ; 

PLOT <32-K. 24-I ) ; 

P LOT < K + 8,24-1 > ; 

PLOT <32-1 ,K) ; 

P LOT < 1 + 8,24-K) ; 

PLOT(32-K,I) 

END 

END 

END 

UNTIL KEYPRESS 
END . 

BASIC Equivalent: GRAPHICS 8 


HIMEM PROCEDURE HIMEM(Value); 

This built-in procedure is used to set the upper boundary of memory to be 
used by the Pascal supervisor during execution. 'Value' may be any integer 
expression. HIMEM may be used to protect a machine language subroutine in 
upper memory, or to protect an area of memory where you may store data. 

Example: PROGRAM HIMEM.DEMO; 

BEGIN 

HIMEM($ 5 FF F) ; 

BLOAD < 'D:TEST.OBJ' ) ; 

CALL($6000) 

END . 

BASIC Equivalent: POKES into locations 144 and 145 (decimal) 


7-14 



IF 


IF exorl THEN stmtl; 

IF exorl THEN stmtl ELSE stmt2; 


The IF statement evaluates exoressions to see if they are true or false, 
'exprl' is anv kind of exDression. If the expression is true, then ’stmtl' will 
be executed. If the expression is false, then 'stmtl' is not executed. If ELSE is 
used then 'stmt2' is executed when the expression is false. 

Example: PROGRAM IF DEMO; 

VAR I:INTEGER; 

BEGIN 
I : = 5 ; 

IF 1=5 THEN VRITELN('FIVE'> 

ELSE WRITELN<'NOT FIVE') 

END . 

BASIC Equivalent: IF 1 = 5 THEN ... (No ELSE) 


INSERT PROCEDURE INSERT (Source,Destination, Index); 

This built-in procedure inserts a string, or string literal, into another strina 
at a specified position. 'Source' may be either a string variable, a string 
literal (within quotes), or a character type variable. 'Destination' must be a 
variable of type string. 'Index' may be any inteaer expression having a value 
in the range i-255. 

Example: PROGRAM INSERT DEMO; 

VAR PGMNAME:STRING!203; 

BEGIN 

VRITE('Enter filename '); 

READLN(PGMNAME); 

IF POS(':',PGMNAME) » 0 THEN 

INSERT('D1:',PGMNAME,1>; 

WRITELN('New filename is ’,PGMNAME) 

END . 

BASIC Equivalent: None 


INTEGER 

INTEGER is a type code assigned to integer variables. Integer variables 
contain values which are whole numbers in the range -32768 to +32767. 

Example: Refer to ASC example 

BASIC Equivalent: None 


IORESULT FUNCTION IORESULT.TNTEGER; 

The IORESULT built-in function returns the value of the return code from the 
most recent input-output operation. It is normally used after disk operations 
to verify that the requested action successfully completed. If the value of 
IORESULT is zero, then the operation was successful. If it is other than zero, 
some kind of error has occurred. End-of-file and end-of-line are not 
considered errors and are handled by the EOF and EOLN built-in functions. An 
integer variable may be assigned the value of IORESULT if the value is to be 
saved. Remember that WRITE and WRITELN cause input-output operations to 
occur and set the value of IORESULT. Refer to the BASIC or ASSEMBLER 
manuals for a list of the error codes and their meanings. The error numbers 
above 127 are the ones you should be concerned with. The value of 137 
(truncated record) may pertain to some of the built-in string functions and not 
actually be caused by an input-output request. 

Example: Refer to BLOAD example 

BASIC Equivalent: The TRAP instruction is used to provide a line number to 
branch to on error conditions. 


7-15 



KEYPRESS 


FUNCTION KEYPRESS! INTEGER; 


This built-in function returns a one (true value) if any kev on the keyboard 
has been pressed. Otherwise the value returned is a zero (false value). It 
allows a program to continue executing until interrupted by someone pressing 
a key on the keyboard. 

Example: Refer to example under GRAPHICS 
BASIC Eauivalent: IF FEEK(764)<>255 THEN ... 


LENGTH FUNCTION LENGTH(svar):INTEGER; 

The LENGTH built-in function returns the length of a string, 'svar' must be a 
string type variable. 

Example: PROGRAM LENGTH DEMO; 

VAR I:INTEGER; 

S:STRING; 

BEGIN 

S : = 'ABCDEFG 1 ; 

I : = LENGTH < S) ; 

VRITELN('The length of ' ,S,‘ is ',1) 

END . 

BASIC Equivalent: I = LEN(S$) 


LN FUNCTION LN(Var):REAL; 

The LN function returns the natural logarithm of the value of 'Var'. 'Var* mey 
either be an INTEGER variable or a REAL variable, but must be positive and 
greater than zero. The value returned will always be REAL. 

Example: PROGRAM LN DEMO; 

VAR R1,R2:REAL; 

BEGIN 

R1 : =3.0 ; 

R 2 :s LN(R1 ) 

END . 


BASIC Equivalent: R2=LOG(Rl) 


L O GATE FUNCTION LOCATE(X / Y):INTEGER; 

The LOCATE function positions the invisible graphics cursor at the specified 
location in the graphics window and returns a value equal to the data at that 
pixel. Graphics modes 0 through 2 will return a value of 0-255. The 2-color 
graphics modes will return a value of 0 or 1. The four color modes will return 
a value in the range 0-3. You should reposition the cursor using GOTOXY 
prior to doing a WRITE after LOCATE. 

Example: PROGRAM LOCATE DEMO; 

VAR I,X,Y:INTEGER; 

BEGIN 

MAXGRAPH < 19); 

GRAPHICS < 19 ) ; 

SETCOLOR(2,8,10) ; 

PLOT<8 ,12); 

DRAWTO(12,12); 

I := LOCATE(10,12); 

GRAPHICS(0); 

WRITELN< * The data was • ,1) 

END . 

BASIC Equivalent: LOCATE 10,12,1 


7-16 



LOCK 


PROCEDURE LOCK(Filename); 


LOCK is used to lock a file on disk. After a file is locked, it is protected 
from being accidentally deleted or renamed. ‘Filename' mav either be a string 
literal (in quotes) or a string tvDe variable. 

Example: PROGRAM LOCK DEMO; 

VAR FIL ENAME : STRING ; 

BEGIN 

FILENAME: = * D :TEST.TXT’ ; 

LOCK < FILENAME) ; 

LOCK( 1 DiTEST.TXT') 

END . 

BASIC Equivalent: XIO 35,#1,0,0, M D:TEST.TXT“ 


LOG FUNCTION LOG(Var):REAL; 

The LOG function returns the decimal logarithm (to the base 10) of the value 
of 'Var'. 'Var 1 may be either an INTEGER variable or a REAL variable. The 
value of ‘Var* must be positive. The value returned will always be REAL. 

Example: PROGRAM LOG DEMO; 

VAR R1,R2:REAL ; 

BEGIN 

R 1 : ss 3.0 > 

R 2 : sb LOG ( R 1 ) 

END . 

BASIC Equivalent: R2s=LOG(Rl)/LOG<10) 


LPENH, LPENV FUNCTION LPENH: INTEGER; 

FUNCTION LPENV:INTEGER; 

These two functions are used for light pen support. LPENH returns the 
horizontal <X-coordinate> of the light pens position, while LPENV returns the 
vertical (Y-coordinate) position. 

Examole: PROGRAM LPEN DEMO; 

VAR A,X,Y:INTEGER; 

BEGIN 

MAXGRAPH(8); 

GRAPH ICS(8 > ; 

COLOR(1); 

REPEAT 

IF SELECTKEY THEN GRAPHICS(8); 

WHILE STICK < 0 > * 15 DO 
BEGIN 

X : sbLPENH ; 

Y : s*LPENV ; 

P LOT(X Y) * 

IF IOR ESULT< > 0 THEN EXIT 
END 

UNTIL A ss 9 9 <* UNENDING LOOP *> 

END . 


BASIC Equivalent: X=sPEEK(564>:YssPEEK<565> 


7-17 



MAXGRAPH 


PROCEDURE MAXGRAPH(Mode); 


The MAXGRAPH procedure is used to inform Pascal of the maximum graphics 
mode to be used within the oroqram. Internal pointers are adjusted to allow 
for the required amount of screen memory to be reserved. If MAXGRAPH is not 
used, you may get undesirable results if the internal stack overlays part of 
the screen memory. 'Mode' may be any valid graphics mode, including those 
with 16 or 32 added to them. If the internal trace (see TRACEON) is active, 
it is forced off by the MAXGRAPH command. 

Examde: Refer to examole under LPENH 

BASIC Equivalent: None 


MOD 

MOD is an operator used to compute the remainder after the division of two 
integer factors. The left factor is divided by the right factor with the value 
returned being the remainder of the division. 

Examole. PROGRAM MOD DEMO; 

VAR I,YEAR:INTEGER; 

BEGIN 

VRITELN('Enter year '); 

READ<YEAR); 

I : = YEAR MOD 4 ; 

IF 1=0 THEN 

VRITELN( 1 Leapyear * > 

ELSE 

WRITELN('Not leapyear') 

END . 

BASIC Equivalent: None 


WOT 

This is an operator used to complement the factor which follows it. It is most 
commonly used to determine when to stop readina input (WHILE NOT EOF DO 

...). 

Example: Refer to example under EOF 
BASIC Equivalent: NOT 



NOTE 


PROCEDURE NOTECIocbno,Sect or,Byte); 


The NOTE procedure is used to retrieve and save the current access location 

of a disk file. 'Iocbno* may be any valid IOCB number which refers to an open 

disk file. The IOCB number should be preceded by a #. 'Byte' and ’Sector* 

refer to previously defined integer type variables. NOTE and POINT are used 

together to provide random access to disk files. 

Example: PROGRAM NOTE_FOINT_DEMO; 

VAR SECTOR,BYTE,I,REPLY:INTEGER; 

S_TABLE,B_TABLE :ARRAY C5 3 OF INTEGER; 

DATA:STRING; 

BEGIN 

C* CREATE THE FILE *> 

OPEN(#1,8,0, * D:TEST.TXT‘ > ; 

FOR I:=1 TO 5 DO 
BEGIN 

VRITELN( * Enter record number ’,1); 

READLN(DATA > ; 

NOTE(#1,SECTOR,BYTE); 

S_TABLE < I ) : ^SECTOR; 

B_TABLE < I ) : =BYTE; 

WRITELN< #1 ,DATA> 

END ; 

CLOSE < #1 > ; 

<* RANDOMLY ACCESS THE FILE *) 

OP EN(#1,4,0, ’D:TEST.TXT' > , 

FOR I:=1 TO 5 DO 
BEGIN 

REPEAT 

WRITE < 'Enter a record number * > ; 

UNTIL 0 (REPLY)0) AND (REPLY < 6) ; 

SECTOR : *S__TABLE (REPLY) ; 

BYTE : =*B__TABLE (REPLY) ; 

POINT < #1 ,SECTOR,BYTE) ; 

READLN(#1,DATA); 

WRITELN<'Record REPLY,' is '); 

WRITE LN < DATA) 

END ; 

CLOSE(#1 ) 

END 

BASIC Equivalent: NOTE 


ODD FUNCTION ODD(iexp); 

The ODD function returns a true value if the value of the specified integer 
expression is odd. 'iexp' may be any integer type expression. 

Example: PROGRAM ODD_DEMO; 

VAR I:INTEGER; 

BEGIN 

WRITE<'Enter an integer number '); 

READ(I > ; 

IF ODD < I ) THEN 
WRITE LN < 'Odd' ) 

ELSE 

WRITELN < ' Even' ) 

END . 

BASIC Equivalent: None 


7-1? 



OPEN 


PROCEDURE 0PENCFileno. Auk l.Aux2,Filename) ;; 


The OPEN is used to connect a proaram to a device. Each device or file must 
be opened before it may be accessed. The RESET and REWRITE commands may 
also be used to open files. ’Fileno' may either be a variable of type FILE, or 
an absolute IOCB number preceded by a #. 'Filename* may be either a variable 
of type string, or a strinq literal (within quotes). 'Auxl' specifies the type of 
open to be performed. Valid values for 'Auxl' are as follows: 

4 : Input operation 
6 : Disk directory input operation 

8 : Output operation 

9 : End of file append operation 
12 : Input and output operation 

'Aux2* is a device dependant value but is normally zero. Refer to the 
appropriate manuals for information on specific control codes. 

Example: Refer to the example for NOTE 

BASIC Equivalent: OPEN # 1,4,0,”D:TEST.TXT" 


OPTIONKEY 

This special built-in function returns a true value if the OPTION key on the 
Atari keyboard is beinq pressed at the time the instruction is executed. 

Example: PROGRAM OPTIONKEY DEMO; 

VAR I:INTEGER; 

BEGIN 

WRITELNC'Press BREAK key to stop'); 

RE PEAT? 

IF OPTIONKEY THEN VRITELN('Option key 

pressed' ) ; 

IF SELECTKEY THEN VRITELN<’Se1ect key 

pressed* > ; 


IF 

STARTKEY THEN VRITELN('Start 

key 

pressed* ) 

UNTIL 

1-99 

<* UNENDING 

LOOP *) 


END . 






BASIC Equivalent 

I F 

PEEK( 5 3279 )=4 

THEN ... 

REM 

OPTION KEY 


I F 

PEEK < 5 327 9 ) =2 

THEN ... 

REM 

SELECT KEY 


IF 

PEEK(53279)= 1 

THEN ... 

REM 

START KEY 


OPTIONS OPTIONSCOpt l,Opt2,...,Optn); 

This special built-in procedure allows you to control certain events at 
program execution time. The options specified are always inteqer numbers. 
They are defined in pairs so that one number can set an option while the 
other number of the pair can reset the same option. An option remains in 
effect until reset by the other option in the pair, or the Pascal Supervisor is 
reloaded. The 'S' on the end of the word OPTIONS is required, even if only 
one option number is specified. If an invalid option number is qiven, it will be 
iqnored and execution will continue as normal. The available options are 
shown below with defaults shown: 

0 - TURN OFF ERROR DISPLAY 

The display of CIO error messages is suppressed with this option. 
Error conditions can be checked for by looking at the value of 
IORESULT after each input-output operation. 

1 - TURN ON ERROR DISPLAY (DEFAULT) 

This option allows CIO error messages to be displayed when they 
occur. 

(Continued on next page) 


7-20 





2 


- TURN OFF PROMPT DISPLAY 

This option suppresses the printina of the 'Execution Completed' 
message and the 'Highest Stack Address Used* message. 

3 - TURN ON PROMPT DISPLAY (DEFAULT) 

This option allows the above mentioned messages to be once again 
displayed at program termination. 

4 - DISABLE BREAK KEY 

This option prevents the BREAK key on the Atari keyboard from 
interrupting execution of a program. In order to keep the BREAK kev 
disabled, it mav be necessary to have OFTION3(4) specified after 
the first WRITE or WRITELN that goes to the screen or any OPEN. 
RESET, or REWRITE that addresses the screen <E: or S:>. It should 
also be reissued after the GRAPHICS command. 

5 - ENABLE BREAK KEY (DEFAULT) 

The BREAK key may once again be used to stop execution of a 
program after this option is put into effect. 


Example: PROGRAM OPTION DEMO; 

VAR REPLY:CHAR; 

BEGIN 

WRITELN('Enter D to disable break key’); 
WRITELN('Enter E to enable break key'); 
READ(REPLY); 

CASE REPLY OF 
'D' : OPTIONS(4); 

'E' : OPTIONS(5) 

END . 

BASIC Equivalent: None 


OR 


This operator sets the resulting condition as true if either the left or the 
right factors around it are true, otherwise, the condition is set to false. 
Parentheses should surround the factors on each side. 

Example: PROGRAM OR DEMO; 

VAR A:INTEGER; 

BEGIN 

WRITE('Enter a number between 1 and 6 '); 

READ(A) ; 

IF (A < 1 ) OR (A > 6) THEN 

VRITELN(‘Value outside of range*> 

ELSE 

WRITELN( 'Value okay * ) 

END . 

BASIC Equivalent: Same as Pascal 


ORD 


FUNCTION ORD(Realvar).INTEGER; 


The ORD function is used to convert a real number into an integer number. 
'Realvar* must be a variable of type REAL. 

Example: PROGRAM ORD DEMO; 

VAR I:INTEGER; 

R:REAL; 


BEGIN 

WRITE('Enter a real number '); 

READ(R); 

I:=ORD(R); 

WRITELN('The inteqer value is 

END . 


I ) 


BASIC Equivalent: I = INT(R) 


7-21 



ADDLE 


FUNCTION PADDLE(Number):INTEGER; 


This function returns the status value of a particular paddle controller. The 
controllers are numbered 0-7 from left to right. The value returned will be an 
integer number between 1 and 228. The value increases as the knob on the 
controller is rotated counterclockwise. 'Number* may be any integer expression 
having a value in the range 0-7. 

Example: PROGRAM PADDLE DEMO; 

VAR I,J:INTEGER; 

BEGIN 

REPEAT 

I : -PADDLE( 0 ) ; 

WRITELNC'Value of paddle(O) is M) 

UNTIL J-99 <* UNENDING LOOP *> 

END . 

BASIC Equivalent: I-PADDLE(O) 


PEEK FUNCTION PEEK(Address)INTEGER; 

This function returns the contents of a SDecific memorv address location. The 
value returned will be an inteaer in the ranoe 0-255. 'Address' may be any 
integer expression, including hexadecimal constants (preceded bv a $>. 

Example: PROGRAM PEEK DEMO; 

VAR I,REPLY:INTEGER; 

BEGIN 

WRITE( 'Enter a memory address in decimal'); 

I:-PEEK(REPLY); 

VRITELN( 'Tha t location contains hex ' , %I ) 

END . 

BASIC Equivalent: I-PEEK (REPLY) 


F>H.OT PROCEDURE FLOT(X,Y); 

PLOT is used to display a point within one of the graphics windows. The color 
of the point plotted is determined by the hue and luminance in the color 
register from the last COLOR statement executed. The color of the plotted 
point is changed by use of the SETCOLOR command 'X' and 'Y' may be any 
integer expressions. 

Example: Refer to example under GRAPHICS 
BASIC Equivalent: PLOT(X,Y) 


POINT PROCEDURE POINT(Iocbno, Sector, Byte); 

The POINT procedure is used to position the disk file pointer to the next 
location to be read or written. It is used in conjunction with NOTE to provide 
random access capabilities. 'Iocbno' may be anv valid IOCB number which 
refers to an open disk file. It must be preceded by a 'Sector' and 'Byte' 

refer to previously defined integer type variables. They normally contain a 
value which was set by a NOTE command. 

Example: Refer to example under NOTE 

BASIC Equivalent: POINT #1,SECTOR,BYTE 


7-22 




POKE 


PROCEDURE FOKE(Address,Value); 


The POKE procedure is used to store a certain value into a specific memorv 
location. 'Address' may be any integer expression, including hexadecimal 
constants (preceded bv a S). 'Value' may be any integer expression. 'Value' 
should be in the ranae 0-255. If it is areater than 255, then the value stored 
will be 'Value' MOD 256. 

Example: PROGRAM POKE DEMO; 

CONST LEFT MARGIN = 82; 

VAR I:INTEGER; 

BEGIN 

WRITE('Enter new left marain value '); 

READ < I > ; 

POKECLEFT MARGIN,I) 

END . 

BASIC Eguivalent: POKE 82,1 


FOS FUNCTION POS(Pattern, Source) :INTEGER; 

This function returns the Dosition of the first occurence of a given string in 
another string. 'Pattern' and 'Source' may be either string variables, character 
variables, or string literals (within guotes), or any mixture thereof. A value 
of zero is returned if the pattern is not found. You can easily check for the 
presence or absence of a pattern by checking to see if the value returned is 
zero or not. 

Example. Refer to example under INSERT 
BASIC Equivalent: None 


PROCEDURE PROCEDURE Name; 

PROCEDURE Name(Parml,Parm2,. . . , F armn) ; 

A procedure is a named group of statements that executes a specific task or 
algorithm. No value is associated with it, as with a function. Parameters may 
be passed to the procedure. All parameters must be of type integer. A 
procedure is activated just by specifying it's name. It must be defined before 
it's name is mentioned. Variables mav be defined within procedures. If they 
are, they are local to that procedure and may be referenced only from within 
that procedure. The variable names may be the same as variables defined 
elsewhere within the program without interferina with their values. In this 
implementation of Pascal, you mav use PROC as an abbreviation for 
PROCEDURE. 

(Continued on next page) 


7-23 













Example: PROGRAM PROCEDURE_DEMO, 

VAR NUMLINES:INTEGER, 

<* WRITE VARIABLE NUMBER OF BLANK LINES *> 

PROCEDURE LINES(NUMB ER) , 

VAR I INTEGER, 

BEGIN 

FOR I:«l TO NUMBER DO WRITELN 
END ; 

<* DISPLAY MENU LIST *> 

PROCEDURE MENU; 

BEGIN 

<* THE 125 BELOV IS A CLEAR SCREEN CODE *) 

WRITE LN < 12 5 , * TITL E• ) ; 

WR I TE LN ( ' 1 - Choice one*)*, 

VRITE LN <’2 - Choice t wo 1 ) 

END , 

<* MAIN PROGRAM SECTION *> 

BEGIN 
MENU ; 

WRITE('Enter number of lines to blank '), 

R EAD(NUMLINES) , 

LINES(NUMLINES) 

END . 


BASIC Equivalent: The object of a GOSUB 


FRO GRAM PROGRAM Name; 

PROGRAM is used to give a name to the Pascal program which follows it. No code is 
generated from it. It's only purpose is to provide documentation. 'Name' may be any 
string of characters, of any length, which is terminated by a semicolon <;>. 

ExamDle: PROGRAM ANY_NAME_AT_ALL, 

BEGIN 

WRITE LN < 'This prooram has a name' > 

END . 

BASIC Ecuivalent: None 


PTRIG FUNCTION PTRIG(Number):INTEGER; 

This function is used to determine the status of the trigger button on the designated 
paddle controller. A value of 0 is returned if the trigger is pressed, otherwise the 
value returned is a 1. 

ExamDle: PROGRAM PTR I G__DEMO ; 

BEGIN 

REP EAT 

WRITELN('Press Daddle 0 trigger to stop') 

UNTIL PTRIG(0)=0 
END 

BASIC Equivalent: IF PTRIG(0> = 0 THEN ... 


7-24 




















PURGE 


PROCEDURE PURGE(Filesoec); 


This procedure is used to remove a file from a diskette. 'Filesoec' mav be 
either a string variable or a string literal (within auotes). 'Filesoec' must 
indicate the device and filename extension (if present). 

Example: PROGRAM PURGE DEMO ; 

BEGIN 

PURGE( 1 D:TEST.TXT') 

END . 

BASIC Equivalent: XIO 33,1,0,0, M D:TEST.TXT" 


RAD 

RAD is used to indicate that the output from all triqonometric computations 
that follow is to be expressed in radians, rather than degrees. Radians are the 
default unless DEG is specified. You can switch back and forth between 
degrees and radians as often as you like. 

Example: Refer to example under DEG 

BASIC Equivalent: RAD 


READ # READLM PROCEDURE READ (File, Varl,Var2,...Varn); 

READ and READLN are used to supply data to a program from a keyboard or 
any other input type device. In this implementation of Pascal, READ and 
READLN are identical and may be used interchangeably. Variables must be 
predefined to hold the data to be read. These variables may be of type 
character, integer, real, or string, or elements of an array of one of these 
types. The type code of the variable determines how it is read into the 
program. For character type variables, one character of data is transfered from 
the input device to the variable. No carriage return (RETURN) is required for 
character type variables. The carriage return is required, however, for all 
other data types, since each may be entered as a variable number of 
characters. 'File' is optional, and if present, determines the device from which 
the data will be read. 'File' may be specified as either an absolute IOCB 
number (preceded by a #), or a variable of type FILE. If 'File* is not specified, 
then the Atari keyboard is assumed to be the input device. Any number of 
variables may be mentioned within a READ statement. 'File' may also be 
repeated and sets the device to be used as input for each variable that 
follows it until either another 'File* or the right parenthesis •)• is 
encountered. 

Example: Refer to EOF and EOLN examples 
BASIC Equivalent: INPUT # 1 •,VARIABLE 


REAL 

The REAL type code is used to define variables which are numeric but not 
integers (contain decimal points) or have values outside the integer range 
(-32768 through +32767). Each real variable defined occupies three stack 
positions (six bytes). The format used is identical to that used by BASIC and 
the Atari operating system. When a real variable is set to a real constant 
value within a program, the constant must start with an integer, and be 
followed by a decimal point, and optionally an exponent portion. 

Example: PROGRAM REAL DEMOj 
VAR R:REAL; 

BEGIN 

R:=0 . 5 5 E + 3 ; 

WRITE LN( 'R= 1 ,R) 

END . 

BASIC Equivalent: All numerio variables used by Atari BASIC are considered 
REAL numbers. 


7-25 



REPEAT 


REPEAT Stmtl; Stmt2; ... ;Stmtn UNTIL Condition; 


REPEAT is used to loop through a group of statements until a specified 
condition occurs. The statements are executed at least once, even if the 
UNTIL condition is initially false. The condition is tested after the group of 
statements is executed. 'Condition* may be any normal expression. To test a 
condition before executing a group of statements, use WHILE. 

Example: Refer to example under EOF 

BASIC Equivalent: None 


RESET PROCEDURE RESET(File,Filespec); 

RESET is used to open a file which will be used in input mode. The IOCB is 
first closed by RESET before the open takes place. 'File' must refer to a 
variable of type FILE. 'Filespec' refers to the file specifications and may be 
either a string literal (within quotes) or a string type variable. 

Example: Refer to example under EOF 

BASIC Equivalent: CLOSE #1 

OPEN #1,4,0,"D:TEST.TXT" 


REWRITE PROCEDURE REWRITE(File,Filespec); 

REWRITE is used to open a file which will be used in output mode. The IOCB 
# is first closed by REWRITE before the open takes place. 'File* must refer to a 
variable of type FILE. 'Filespec' refers to the file specifications and may be 
either a string literal (within quotes) or a string type variable. 

Example: Refer to example under EOF 

BASIC Equivalent: CLOSE #1 

OPEN #1,8 ,0,"D:TEST.TXT" 


RMD FUNCTION RND(Iexp):INTEGER; 

The END function is a random number generator. A random integer number is 
returned between zero and the value of Texp', inclusive. 'lexp' may be any 
integer expression. 

Example: PROGRAM RND DEMO; 

VAR 11,12:INTEGER; 

BEGIN 

FOR I 1 : si TO 5 0 DO 
BEGIN 

I 2:=RND(25) ; 

WRITELN < 12 ) 

END 

END . 


BASIC Equivalent: I2 = RND(0>*25 
SELECT KEY 

This special built-in function returns a true value if the SELECT key on the 
Atari keyboard is being pressed at the time the instruction is executed. 

Example: Refer to example under OPTIONKEY 

BASIC Equivalent: IF PEEK(53279) = 2 THEN ... 


7-26 



SETCOLOR. 


PROCEDURE SETCOLOR(Reqister,Hue,Luminance); 


This built-in orocedure is used to set the particular hue and luminance to be 
assigned to a particular color register. 'Register* may be any integer 
exDression which results in a value in the range 0-4. 'Hue* may be any 
integer expression which results in a value in the ranqe 0-15. 'Luminance* may 
be any integer expression which results in an even number in the ranoe 0-14. 
For further information on the SETCOLOR command, refer to the Atari EASIC 
manual. 


Example: PROGRAM SETCOLOR. DEMO; 
BEGIN 

MAXGRAPH < 3) ; 

GRAPHICS ( 3 > ; 

SETCOLOR(0,2,8); 

P LOT( 17,1) ; 

DRAVTO(17,10); 

DRAWTO(9 , 18) ; 

PLOT( 19,1); 

DRAVTO(19,18); 

PLOT <20,1); 

DRAWTO (20,18); 

PLOT(22,1); 

DRAWTO(22,10); 

DRAWTO(30,18) 

END . 

BASIC Equivalent: Same as BASIC 


S ML 


Exprl SHL Expr2 


The SHL operator performs a bitwise shift of 'Exprl' to the left by ’Expr2' bit 
positions. Each bit position shifted is equivalent to 'Exprl* multiplied by 2. 
The value returned is an integer and both ‘Exprl' and 'Expr2' refer to integer 
type expressions. When multiplying an integer by a value which is a power of 
two, the SHL is more efficient than the multiply (*). 

Example: PROGRAM SHL DEMO; 

VAR I,J:INTEGER; 

BEGIN 
J : = 2 *, 

I :=J SHL 8; 

VRITELN( ' 2*256 = » , I ) 

END . 


BASIC Equivalent: I=J*(some power of 2) 


SHE Exprl SHR Expr2 

The SHR operator performs a bitwise shift of 'Exprl' to the right by ’Expr2' 
bit positions. Each bit position shifted is equivalent to 'Exprl' divided by 2. 
The value returned is an integer and both 'Exprl' and 'Expr2‘ refer to integer 
type expressions. When dividing an integer by a value which is a power of 
two, the SHR is more efficient than the divide (DIV or '/'). 

Example: PROGRAM SHR DEMO; 

VAR I,J:INTEGER; 

BEGIN 

J : = 1 0 2 4 ; 

I :=J SHL 7; 

WRITE LN( ' 1024/128=' ,1) 

END . 

BASIC Equivalent: I=J/(some power of 2) 



7-27 




ITsI 


FUNCTION SIN(Var):REAL; 


SIN is a function which returns the sine of the value of *Var‘. 'Var' may be 
either an INTEGER variable or a REAL variable. The value returned is always 
REAL. 

Example: Refer to the example under DEG 
BASIC Equivalent: A = SIN(2) 


S OUMD PROCEDURE SOUND (Voice,Fitch,Distortion, Volume); 

This built-in procedure is used to support the sound capabilities of the Atari 
computer. 'Voice' refers to one of the four sound registers and may be any 
inteaer expression which results in a value 0-3. 'Pitch' is used to set the 
frequency of the sound. It may be any integer expression which results in a 
value 0-255. 'Distortion' is used to set the purity of the tone. It may be anv 
integer expression which results in an even number in the ranae 0-14. A value 
of 10 creates a pure tone. 'Volume' determines hoW loud the tone will be 
played. It may be any integer expression which results in a value 1-15. A 
value of 1 creates a barely audible sound and a value of 15 creates a loud 
sound. A value of 0 is used to turn off the sound. For additional information 
on SOUND, refer to the Atari BASIC manual. 

Example: PROGRAM SOUND DEMO; 

VAR I:INTEGER; 

BEGIN 

FOR I:*29 TO 121 DO 
.BEGIN 

SOUND(0,1,10,10); 

WAIT < 15) (* HOLD FOR 1/4 SECOND *> 

END ; 

SOUND(0,0,0,0) (* TURN OFF SOUND *) 

END . 

BASIC Equivalent: SOUND (Same as BASIC) 


SOlFL FUNCTION SQR(Var):REAL; 

The SQR function returns the square of the value of 'Var'. 'Var' may either be 
an INTEGER variable or a REAL variable. The value returned will alwavs be 
REAL. 

Example: PROGRAM SQR DEMO; 

VAR R1,R2:REAL; 

BEGIN 

R 1 : = 1 0 0 ; 

R 2:* SQR(R1 ) 

END . 

BASIC Equivalent: R2 = R1*R1 


SQRT FUNCTION SQRT(Var):REAL; 

The SQRT function returns the square root of the value of 'Var'. 'Var' may 
either be an INTEGER variable or a REAL variable. The value returned will 
always be REAL. 

Example: PROGRAM SQRT DEMO; 

VAR R1 ,R 2:REAL ; 

BEGIN 

HI :=10.0 ; 

R 2 : * SQRT(R1) 

END . 

BASIC Equivalent: R2 = SQR(R1) 


7-28 



STARTKEY 


This special built-in function returns a true value if the START key on the 
Atari keyboard is being pressed at the time the instruction is executed. 

Example: Refer tp example under OPTIONKEY 

BASIC Equivalent: IF PEEK(5327?) = 1 THEN ... 


STATUS PROCEDURE STATUS(Iocbno,Ivar>; 

This built-in procedure is used to retrieve status information from a 
particular device. 'Iocbno' refers to either an absolute IOCB number (preceded 
by a #>, or a FILE type variable. 'Ivar' is an INTEGER variable which will 
contain the return code of the STATUS command. The actual status values 
returned from the device can be interrogated by using DVSTAT. 

Example: Refer to example under DVSTAT. 

BASIC Equivalent: STATUS (Same as BASIC) 


STXOC FUNCTION STICK(Number):INTEGER; 

This function returns the status value of a particular joystick attached to the 
computer. 'Number' refers to the controller jack that the joystick is plugged 
into. It may be any integer expression which results in a value of 0-3. Values 
returned for the various positions of the joystick are shown below. 


1 0 

1 A 

i 

6 

11 - 

i 

1 5 
* 

- 7 

9 

t 

1 3 

5 


Example: PROGRAM JOYSTICK DEMO; 

VAR I:INTEGER; 

BEGIN 

REPEAT 

I : -STICK < 0) ; 

VRITELN('Stick 0 is ',1) 
UNTIL KEYPRESS 
END . 

BASIC Equivalent: I-STICK(O) (Same as BASIC) 


STR FUNCTION STR(Var):STRING; 

This built-in function is used to convert a number into it's string equivalent. 
'Var* may either be an integer type variable or a real type variable. 

Example: PROGRAM STR DEMO; 

VAR I:INTEGER; 

R:REAL; 

S:STRING; 

BEGIN 
I : =20 ; 

S:= STR<I) ; 

WRITELN(S); 

R : = 3 . 1 4 1 6 ; 

S: = STR(R) ; 

VRITELN(S) 

END . 

BASIC Equivalent: S = STR(I) 


7-2? 



STRI G 


FUNCTION STRIG (Number): INTEGER; 


This function is used to check on the status of the joystick trigger button. A 
value of zero is returned if the button is beinq pressed at the time the 
instruction is executed. A value of one is returned when the button is not 
pressed. 'Number 1 refers to the controller jack that the joystick is plugged 
into. It may be any integer expression which results in a value 0-3. 

Example: PROGRAM STRIG DEMO; 

VAR I:INTEGER; 

BEGIN 

REPEAT 

VRITELN('Press button on joystick 0 to stop’) 
UNTIL STRIG < 0)*0 
END . 

BASIC Equivalent: IF STRIG(0) = 0 THEN ... 


STRIMG 

STRING is a type code used to define variables which contain a number of 
characters. A fixed amount of memory is reserved for each string, but the 
actual length of the string is variable. Any ATASCII codes may be contained 
within a string variable. String variables may be defined with lengths of 1-255 
characters. The length specification is made by putting the iength within 
brackets 'Cl' after the word STRING. If no length code is specified, a default 
lenqth of 80 characters is assumed. The functions and procedures used to 
manipulate strings are CONCAT, COPY, DELETE, INSERT, LENGTH, and POS. 

Example: PROCEDURE STRING DEMO; 

VAR A: STRING ; 

B:STRING!103; 

C:ARRAY!53 OF STRING!203; 

BEGIN 


< * 

• A • 

i s 

a 

s t ring 

of 1 eng t h 

80 

* > 

< * 

• B 1 

is 

a 

s t ring 

of 1enq th 

10 

* ) 

< * 

' C ' 

i s 

a 

six element (0-5) 

string 

* ) 


( * array with each element having * ) 

<* a lenqth of 20 *> 

END . 

BASIC Equivalent: DIM A$<80) No equivalent for string arrays. 


TRACEOFT PROCEDURE TRACEOFF; 

This special built-in procedure is used to turn off a pseudo instruction code 
trace that is active if turned on by TRACEON. The wraparound buffer used by 
the trace is not released by TRACEOFF. 

Example: Refer to example under TRACEON. 

BASIC Equivalent: None 



TRACEON 


PROCEDURE TRACEON; 
PROCEDURE TRACEONCNumber); 


This special built-in procedure is used to turn on a pseudo instruction trace, 
for debugging purooses. The trace table is maintained in a memory buffer. 
'Number' is used to specify the number of trace entries to maintain. It is a 
wraoaround type trace buffer where new entries overlay old entries if the 
buffer is not large enough to contain all of the instructions executed. Each 
trace entry is nine bytes iong. The trace entries may be displayed at program 
termination by entering CTRL-T. Refer to the 'Supervisor' section of this 
manual for more information. 'Number* may be any integer expression. If 
'Number' (and the parentheses) are not specified, then the trace is 
re-activated using an existing buffer from a previous TRACEON where 'Number' 
was specified. If the value of 'Number' is zero, then the trace buffer is 
released from memory and the trace is turned off. Note that the MAXGRAPH 
command will also turn off the trace and release the memory used for the 
trace buffer. 

Example: PROGRAM TRACE DEMO; 

VAR NAME.STRING; 

BEGIN 

TRACEON(100); 

VRITE < 'Enter your n ame ' ) ; 

READLN < NAME) ; 

TRACEOFF 
END . 

BASIC Equivalent: None 


TT Ft T_J E 

TRUE is a BOOLEAN constant representing the true state. It is internally 
equivalent to an integer constant of one. 

Example: Refer to the example under BOOLEAN 

BASIC Equivalent: None 


UNLOCK PROCEDURE UNLOCK(Filespec); 

This procedure is used to unlock a disk file which was previously locked. 
'Filespec' specifies the name of the file to be unlocked. It may be either a 
variable of type string or a string literal (within quotes). 

Example: PROGRAM UNLOCK DEMO; 

VARIABLE FILENAME:STRING; 

BEGIN 

FILENAME:a'D:TEST.TXT•; 

UNLOCK < FILENAME) 

END . 

BASIC Equivalent: XIO 36,#1,0,0,"D:TEST.TXT" 


7-31 



V AL 


FUNCTION VAL(S var) : INTEGER or REAL; 


This function is used to return the value of a strina variable which contains 
a number. 'Svar' must be a strina type variable. The number must start at the 
beginning of the string variable. REAL values are returned to REAL variables, 
and INTEGER values are returned to INTEGER variables. 

Example: PROGRAM VAL DEMO; 

VAR I:INTEGER; 

R :REAL *, 

S;STRING; 

BEGIN 

S: * * 1 234 ' ; 

I : =VAL< S) ; 

VRITELN( 'VAL(S > = 1 , I ) ; 

S:»• 12. 34 1 > 

R : asVAL < S ) ; 

WRITELNC‘VAL<S>=‘,R> 

END . 

BASIC Equivalent: I=VAL<S$> 


\yA!Ft VAR Namel,Name2,...,Namen : Tvoe; 

VAR Namel,Name2,... ,Namen ARR AY [Number 3 
OF Type; 

VAR is used to allocate variables to be used bv a orooram. Variables which 
are defined at the beainnina of a proaram, before procedures and functions, 
are global and may be referenced by any statement in the program. Variables 
which are defined within procedures and functions are local variables and mav 
only be referenced by statements within those procedures and functions. Valid 
•Type 1 codes are FILE, CHAR, INTEGER, REAL, and STRING. Refer to the 
descriptions of the individual type codes for more information about them. 
ARRAYS may be specified for any type other than FILE. Refer to the 
description under ARRAY for more information. The variable names mav be anv 
words that beain with a letter and are not the same as Pasoal reserved words. 
The name may be of anv length, but onlv the first eiaht characters are 
significant and must be unique. A section listina Pascal reserved words is 
included within this manual. 

Example: Refer to the example under STRING. 

BASIC Equivalent: None for files. DIM for strings and arrays. None reauired 
for numbers. 


WAIT PROCEDURE WAIT(Number); 

This special built-in procedure is used to suspend proaram execution for a 
specified length of time. ‘Number 1 is the number of sixtieths of a second for 
the proaram to wait. A value of 60 is eaual to 1 second. ‘Number 1 may be anv 
integer expression. 

Example: Refer to example under SOUND 
BASIC Equivalent: None 


7-32 



WHILE 


WHILE Condition DO Statement; 


WHILE is used to repeat execution of a statement until a specified condition is 
false. 'Condition* may be any expression which results in a true <1> or false 
<0> condition. The condition is evaluated before the statement is executed. If 
the condition is initially false, 'Statement' will not be executed. 

Example: PROGRAM WHILE DEMO; 

VAR INPUT:FILE; 

DATA: STRING > 

BEGIN 

RESET< INPUT, 'D:TEST.TXT * ) ; 

WHILE NOT EOF(INPUT) DO 
BEGIN 

READLN(INPUT,DATA); 

WRITE LN< DATA) 

END ; 

CLOSE(INPUT) 

END . 

BASIC Equivalent: None 


WRITE PROCEDURE WRITE<File,Varl,Var2,.. . ,Varn); 

The WRITE is used to move data from memory to an external device, such as 
the television screen, disk drive, cassette recorder, or modem. 'File' is 
optional and, if present, determines the device to receive the data. If 'File' is 
not present, then the screen is used. The variables may be of any type other 
than FILE. Expressions are not allowed in the WRITE statement for this 
implementation of Pascal. A variable may receive the value of the expression 
and that variable name can appear in the WRITE statement. The end-of-line 
character (carriage return) will not follow the data (see WRITELN). In this 
implementation of Pascal, inteqer numbers with values of zero through 255 may 
be sent to the output device. For example, to send a form feed command to a 
printer (defined as file PRINTER), you can use WRITE(PRINTER,12);. Literal 
constants may be used in the WRITE statement, also. The literal must be 
enclosed within a pair of single quote marks. It may be any character other 
than a quote mark. To write a quote mark, say WRITE(3?>, because 3? is the 
ASCII value of the quote mark. 

Example: Refer to example under PROCEDURE 

BASIC Equivalent: PRINT (followed by a semicolon) 


WRIT ELM PROCEDURE WR ITELN (File, Var 1 , V ar2,..., Varn); 

The WRITELN is identical to the WRITE except that an end-of-line character 
is sent to the output device after the variables (if present) have been written. 
If no variables are present then only the end-of-line character is written. If 
all parameters and the parenthesis are missing, then an end-of-line character 
is written to the screen. 

Example: Refer to example under PROCEDURE 

BASIC Equivalent: PRINT (not followed by a semicolon) 


7-33 



XCTL 


PROCEDURE XCTL(Filespec); 


This special built-in procedure is used to transfer control to another Pascal 
program. 'Filespec' may be either a string variable or a string literal (within 
quotes). It must completely SDecify the P-code to be executed next. This 
means that the '.PCD* extension must be present in the filename. If data is to 
be passed from the current program to the next program, then it must first be 
stored somewhere (like disk) by the current program and retrieved by the next 
program. If the program to be transferred to is not on the diskette currently 
in the drive specified, a messaae is given asking you to insert the correct 
diskette. 

Example: PROGRAM XCTL. DEMO; 

BEGIN 

XCTL( 'D:NEXT.PCD 1 ) 

END . 

BASIC Equivalent: RUN "D:NEXT M 


XI O PROCEDURE XIO(Number,File,Auxl,Aux2,Filespec); 

XIO is used to perform special input/output operations. It may be used with 
any device. One use is to fill an area on the screen between plotted points 
and lines with a specific color. ‘Number' is an integer number with a value in 
the range 0-255. The number specified depends on the operation requested and 
the device. ‘File* may be either an absolute IOCB number (preceded by a #) or 
a variable of type FILE. 'Auxl' and *Aux2‘ are auxiliary control codes and are 
dependant on the particular device and command number. 'Filespec 1 supplies the 
file specification to the device handler. It may be either a string variable or 
a string literal (within quotes). The standard values for ‘Number* are as 
follows: 


3 OPEN 

5 GET RECORD 

7 GET CHARACTERS 

9 PUT RECORD 

11 PUT CHARACTERS 

12 CLOSE 

13 STATUS REQUEST 

17 DRAW LINE 

18 FILL 

32 RENAME 

33 DELETE 

35 LOCK FILE 

36 UNLOCK FILE 

37 POINT 

38 NOTE 

254 FORMAT 


Example: PROGRAM X I O. F I LL. DEMO ; 
BEGIN 

MAXGRAPH(5); 

GRAPHICS(5) ; 

COLOR( 3 ) ; 

PLOT( 7 0,45) ; 

DRAWTO(50,10); 

DRAWTO(30,10); 

GOTOXY(10,45); 

POKE(765,3); 

XIO(18,#6,0,0,'S:•) 
END . 

BASIC Equivalent: XIO 18,#6,0,0,"S: M 


7-34 




SYSTEM I ME ORM A. T I O M 


The Supervisor uses zero page locations $A0 - $BF. Locations $80 - $9F are available 
for vour use if desired. Various locations between $D4 and $FD are used by the 
floating point routines. Paqe six <$600 - $6FF) is available for your use and not used 
by the Pascal system. 

The Supervisor is loaded into memory by a custom loader program at the MEMLO 
address supplied by DOS, which is $1D7C. The pseudo code program to be executed is 
loaded in memory immediately after the end of the Supervisor. The pseudo machine 
stack extends from the end of the pseudo code program to the MEMTOP position, just 
before screen memory. 

The Supervisor may be copied to any other disk of your choice. The loader program 
may also be copied but is not required unless the RS232 serial interface is to be 
used. Disk filenames are ’AUTORUN.SYS’ for the loader program, and ’PASCAL.OBJ* for 
the Supervisor. The loader program may be renamed to anything else, like 'PASCAL', 
if you wish. 'PASCAL.OBJ' must not be renamed if it is to be loaded by the loader 
program. 


Disk Filename 


Descriptions 


The files named below are included on your supplied diskette: 


DOS.SYS 
DUP . SYS 
AUTORUN.SYS 
PASCAL.OBJ 
COMP ILER .PCD 
EDITOR.PCD 
EDITOR.PAS 
EDITOR1.PAS 
EDITOR 2 .PAS 
EDITOR3.PAS 
EDITOR4.PAS 
EDITOR5.PAS 
EDITOR 6 .PAS 
EDITOR7.PAS 
INIT.PCD 
INIT.PAS 
EXPLNERR.PCD 
RSVDWRDS.TXT 
ERRORS.TXT 
ASOFDATE.TXT 
SAMP LEI .PAS 
SAMP L E 2 .PAS 


DOS Resident code 

DOS Utility Program 

Loader program for Supervisor 

Supervisor object code 

Compiler pcode 

Editor pcode 

Editor Pascal source (INCLUDE statements) 

Editor Pascal source part 1 

Editor Pascal source part 2 

Editor Pascal source part 3 

Editor Pascal source part 4 

Editor Pascal source part 5 

Editor Pascal source part 6 

Editor Pascal source part 7 

Main Menu pcode 

Main Menu Pascal source 

Error code explainor (used by Compiler) 

Reserved word list (used by Compiler) 

Text for compile errors (used by E X P L N E R R . P C D ) 
Date of software release 

Kaleidoscope sample program Pascal source 
Roman numeral sample program Pascal source 


Internal Data Formats 


Variables are allocated on the stack. Variables of type FILE reserve no space on the 
stack. The others are allocated as follows. 


VAR XrBOOLEAN 
VAR X:INTEGER 
VAR X:ARRAYCn3 OF INTEGER 
VAR X:CHAR 

VAR XiARRAYCnl OF CHAR 
VAR X:REAL 

VAR X:ARRAYCnH OF REAL 

VAR XiSTRINGCal 

VAR X:ARRAYCn3 OF STRINGCal 


2 bytes 
2 bytes 

2 * (n + 1) bytes 
2 bytes 

2 * <n + 1) bytes 
6 bytes 

6 * (n + 1) bytes 
(Explained below) 
(Explained below) 


Strings and string arrays have exactly the same format internally. The first two 
bytes hold the actual number of elements in the string array. If it is not an array, 
this value is 1. The next two bytes tell the maximum length of a string entry. This 
ends the fixed part of string allocations. The remaining parts are repeated for as 
many times as there are entries in the array. Only one set is present for non-array 
string definitions. There is a one byte long prefix which shows the actual length of 
that particular string entry. It is followed immediately by the data of the string. If 
the maximum length of the string entries is an even number, then a one byte filler 
byte is added to the end of each string entry. This is required because the variables 
are stored on the stack and the stack width is two bytes. Non-array strings of 80 
and 81 bytes long each, would each take up 86 bytes total. A two element string 
array of length 10 would require 28 bytes total. 


8-1 



RESERVED WORD LIST 


ABS 

ELSE 

NOT 

SETCOLOR 

ADDR 

END 

NOTE 

SHL 

AND 

EOF 

ODD 

SHR 

ARRAY 

EOLN 

OF 

SIN 

ARCTAN 

EXIT 

OPEN 

SOUND 

ASC 

EXP 

OPTIONKEY 

SQR 

BEGIN 

EXP1 0 

OPTIONS 

SORT 

BLOAD 

FALSE 

OR 

STARTKEY 

BOOLEAN 

FILE 

ORD 

STATUS 

CALL 

FOR 

PADDLE 

STICK 

CASE 

FUNC 

PEEK 

STR 

CHAR 

FUNCTION 

PLOT 

STR I G 

CHR 

GOTOXY 

POINT 

STRING 

CLOSE 

GRAPHICS 

POKE 

THEN 

COLOR 

HIMEM 

POS 

TO 

CONCAT 

I F 

PROC 

TRACEOFF 

CONST 

INSERT 

PROCEDURE 

TRACEON 

COPY 

INTEGER 

PROGRAM 

TRUE 

COS 

IORESULT 

PTRIG 

UNLOCK 

CVTREAL 

KEYPRESS 

PURGE 

UNTI L 

DEG 

LENGTH 

RAD 

VAL 

DELETE 

LN 

READ 

VAR 

D I V 

LOCATE 

READLN 

WAIT 

DO 

LOCK 

REAL 

WHILE 

DOS 

LOG 

REPEAT 

WRITE 

DOVNTO 

LPENH 

RESET 

WRITE LN 

DRAVTO 

LPENV 

REWRITE 

XCTL 

DUMPSTK 

MAXGRAPH 

RND 

XIO 

DVSTAT 

MOD 

SELECTKEY 



9-1 



OPERATORS 


Operator 


Operation 


assignment 


arithmetic: 

+ addition 

- subtraction 

* multiplication 

/ or DIV division 

MOO modulo (remainder after 


Relational: 

<> 

< 

> 

< = 

>=* 


equality 

inequality 

less than 

greater than 

less than or equal to 

greater than or equal to 


Logical: 

OR 

AND 

NOT 


division) 


10-1 



EDITOR. 


C O T-I M A InI XD 


SUM M A Ft Y 


A Add lines to end of file in memory. 

Terminate add mode by entering a null line. 

G Change string of characters in one or more lines. 

ID Delete one or more lines. 

E Edit one or more lines. Make change directly on the line presented. 

E Filer commands 

A Append disk file to end of file currently in memory. 

ID List disk directory on screen. 

TLm Load disk file into memory. Anything currently in memory will be erased. 

S Save file currently in memory onto disk. 

I Insert before line number you specify. 

Terminate insert mode by entering a null line. 

L List lines from memory on the screen. 

M Display Editor menu 

F Print one or more lines on printer <F:>. 

Q Quit Editor execution and return to Main Menu screen. 

S Scan one or more lines for character string you specify. 

X Exit directly to the Compiler. 

■? Display Editor menu 


11-1 



G O M £=» I X- E 


I ME E 


ERROR 


MESSAGES 



0 

0 

0 

0 

0 

0 

0 

0 

0 

1 

1 

1 

1 

1 

1 

1 

1 

1 

1 

2 

2 

2 

2 

2 

2 

2 

2 

2 

2 

3 

3 

3 

3 

3 

3 

3 

3 

3 

3 

4 
4 
4 



1 

2 

3 

4 

5 

6 

7 

8 
9 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 
0 
1 
2 


COMPILER TABLE OVERFLOW (MAX 200) 

NUMBER EXPECTED 
EXPECTED 

I DENTIFIER EXPECTED 

CONSTANT TYPE IDENTIFIER, NUMBER. OR STRING CONSTANT EXPECTED 
‘BEGIN’ EXPECTED 
TOO MANY NESTING LEVELS 
•:’ EXPECTED 
’.' EXPECTED 

« ' PYPPTTPn 

UNDECLARED IDENTIFIER 
INVALID TYPE OF IDENTIFIER 
' *’ EXFECTED 

•END’ EXPECTED 

’’ELSE*, OR 'END' EXPECTED 
•THEN* EXPECTED 
'#• EXPECTED 
•DO* EXPECTED 

•#' OR FILE TYPE IDENTIFIER EXPECTED 
’C’ EXPECTED 
* 3 1 EXPECTED 
*) 1 EXPECTED 

ILLEGAL FACTOR OR IDENTIFIER TYPE 
INCLUDE FILE NESTING TOO DEEP 
INCORRECT DISKETTE IN DRIVE NUMBER 1 
» of * EXPECTED 

CANNOT MIX TYPES IN EXPRESSION 
•TO’ OR ’DOWNTO' EXPECTED 
‘UNTIL 1 EXPECTED 
RANGE ERROR 
’( 1 EXPECTED 
’,’ EXPECTED 


INCORRECT NUMBER OF PARAMETERS 
INTEGER TYPE IDENTIFIER EXPECTED 
STRING TYPE IDENTIFIER EXPECTED 
REAL TYPE IDENTIFIER EXPECTED 
CHAR TYPE IDENTIFIER EXPECTED 
FILE TYPE IDENTIFIER EXPECTED 
HEX TYPE IDENTIFIER EXPECTED 
STRING CONSTANT EXPECTED 


12-1 




EXECUTION TIME 


ERROR MESSAGES 


INDEX TOO HIGH 


This message occurs if an attempt is made to store a 
string array element into an occurance that is higher than 
defined for the variable. For example, if you tried to store 
the twentieth entry of an array that was only defined to 
hold ten occurances, you would get the message. This 
message onlv applies to string arrays since other array 
types are not checked for valid occurance numbers. 

UNABLE TO OPEN DEBUG IOCB <7> 

This message is issued if the list output device you 
specify in response to the 'WHERE? (FILESPEC)' prompt 
cannot be opened. The prompt is issued only for the debug 
features trace and stack display. 

CIO ERROR xxx FOR IOCB # y 

Some kind of Input-Output operation was performed which 
resulted in an abnormal return code from the Atari 
operating system. Refer to your BASIC or Assembler/Editor 
cartridge manual for the meaning of the error number 
'xxx*. 'y' is the IOCB number which the error occured on. 
Note that this message will not be printed if OPTIONS(Q) 
is in effect. In this case it is your responsibility to check 
the return code by interrogating IORESULT after each I/O 
type instruction. 


AT OFFSET 


This message accompanies some other error message and 
refers to the offset within the pseudo code of the 
instruction that had the error. Refer to the offset shown 
on your compile listing to determine the Pascal instruction 
that experienced the error. 


STOPPED BY <BREAK> KEY 


This message indicates that execution of the program was 
stopped because the BREAK key was pressed. The offset of 
the instruction executing is shown in the 'AT OFFSET' 
message. Note that this message will not occur (and the 
program will not stop after BREAK is* pressed) if 
OPTIONS<4> is in effect. 


INSUFFICIENT MEMORY 


This message indicates that an attempt was made to 
increase the value of the stack pointer to a value which 
would overlay screen memory or the trace buffer, if the 
trace was active. Check to make sure that no cartridge is 
in the computer. 

INVALID OPCODE 


This message should not occur. It indicates that a pseudo 
instruction was encountered which is invalid. If you get 
this message, it means that your '.PCD' file has been 
corrupted somehow or an XCTL was made to a file that 
was not a pseudo code file. To correct, re-compile the 
program in question. 


12-2 



MA I 1M ME NU EFtOGFtAM SOURC 


INIT . E A S 


<* INITIAL MENU PROGRAM *> 


PROGRAM INIT ^ 

CONST C L EAR &125; CURSOR=:752; 

ON=0 ; OFFal ; 

RAMTOP = $ 6 A; 

LASTFILE » $ 1D 8 2 ; 

VAR BASENAME:STRINGC113; 

PGMNAME:STRINGC 30 3; 

DATA;STRINGC1283, 

I,J:INTEGER; 

REPLY:CHAR; 

PROCEDURE PRESSANY; 

BEGIN 

VRITELN; 

VRITE('Press tny key to continue’); 
READ < REPLY> 

END ; 


BEGIN <*MAIN*> 
GRAPHICS < 0) ; 

POKE < CURSOR,OFF) ; 
WRITE < CLEAR ) ; 
GOTOXY <2,22) ; 

WRITE LN < ’ 

WR ITE < * 

GOTOXY < 2,0); 

WRITE LN < 1 
WRITELN; 

WRITE LN < • 

WRITELN; 

WRITE LN < ’ 

WRITELN ; 

WRITE LN < ' 

WRITELN; 

WRITE LN < • 

WRITELN; 

WRITE LN < ' 

WRITELN; 

WRITE LN < ’ 

WRITELN; 

WRITE LN < * 

WRITELN; 

WRITE LN < • 

REPEAT READ < REPLY 
UNTIL (REPLY) * 0 ’ ) 


Copyright 1985'); 
by Norm Draper'); 

DRAPER SOFTWARE’); 

ATARI PASCAL SYSTEM’); 

1 - Run Program'); 

2 - Disk Directory*); 

3 - Compile Program'); 

4 - Edit a Proaram'); 

5 - Exit to DOS'); 

6 - List a file*); 

7 - Tr ace on' ) ; 

) 

AND < REPL Y < ’ 8 ’ ) ; 


13-1 



Run Proaram *) 


CASE REPLY OF 
• 1 1 : BEGIN < * 

REPEAT 

WRITELN; 

WRITELN(' Enter name of proaram to be run* 
WRITELN; 

POKE(CURSOR,ON); 

J : sADDH< PGMNAME> ; 

FOR I:=0 TO 16 DO 

POKE ( J ♦ I ,P E EK < LASTFIL E+I ) > > 

WRITE < 1 ' ) ; 

WRITELN(PGMNAME); 

WRITE( 1 ‘ , 2 8 ) , 

READLN<BASENAME); 

J : =s AD DR < BASENAME ) ; 

FOR I:=0 TO 16 DO 

POKE < LASTFILE+I ,PEEK(J+I ) ) i 
I:*POS( ' . 1 ,BASENAME); 

IF I<>0 THEN 
BEGIN 

J: =LENGTH(BASENAME) ; 

DELETE(BASENAME,X,J-I+1>; 

WRITELN, 

WRITELN('Suffix not required, ignored*) 
WRITELN 
END ; 

IF POS(':',BASENAME)= 0 THEN 
INSERT < 'D: * ,BASENAME f 1 ) ; 

PGMNAME: = CONCAT(BASENAME, 1 .PCD * ) ; 

OPTIONS ( 0 ) ; 

OPEN< #4 , 4 f 0 ,PGMNAME) ; 

I : = I ORESULT ; 

CLOSE(#4 ) ; 

IF 1=170 THEN 

WRITELN < 'Program not found'); 

OPTIONS <1 ) 

UNTIL 1=0; 

WRITE(CLEAR); 

XCTL< PGMNAME) END; 

*2*: BEGIN <* Disk Directory *> 

CLOSE ( # 1 ) ; 

WRITE('Filespec? *); 

POKE(CURSOR,ON); 

READLN < DATA) ; 

POKE(CURSOR,OFF) ; 

IF DATA= 1 ' THEN 
DATA: = 1 D1 : *. * # ; 

IF POS< 1 : * ,DATA)= 0 THEN 
INSERT < * D1 : * ,DATA, 1 ) ; 

IF POS(,DATA>-LENGTH(DATA) THEN 
INSERT( 1 * . * • ,DATA,LENGTH(DATA)♦1 ) ; 

OP EN(#1,6,0 ,DATA) ; 

READLN(#1,PGMNAME); 

WRITE(CLEAR); 

WHILE NOT EO F(#1 ) DO 

BEGIN WRITELN<PGMNAME); 

READLN(#1,PGMNAME) END; 

CLOSE(#1); 

PRESSANY; 

XCTL( * D: INIT.PCD' ) END; 




13-2 




' 3 ‘ 


' 4 1 


' 5 ' 


BEGIN (* Compile Program *> 

MAXGRAPH <0) ; 

WRITELN ; 

WRITELN( 'Loading Compiler . . . 1 ) ; 
POKE < CURSOR,ON) ; 

XCTL( ’D:COMP ILER.PCD• ) 

END ; 

BEGIN (* Edit a Program *> 

MA XGRAPH(0) ; 

WRITELN; 

WRITELN(‘Loading Editor...*); 
XCTL < ' D : EDITOR.PCD * > 

END ; 

BEGIN <* Exit to DOS *) 

POKE < CURSOR,ON) ; 

DOS 
END ; 


‘ 6 



' 7 


’: BEGIN <* List a file *> 
VRITELN(‘Enter filename of file 
POKE < CURSOR,ON) ; 

WRITELN; 

READLN<PGMNAME); 

POKE < CURSOR,O F F > ; 

IF POS< 1 :',PGMNAME)=0 THEN 
INSERT < 1 D: ‘ .PGMNAME, 1 > ; 

CLOSE < #1 ) ; 

OP EN(#1,4,0 .PGMNAME) ; 

READLN(#1,DATA); 

WRITE(CLEAR); 

WHILE NOT EOF ( # 1 > DO 
BEGIN WRITELN(DATA>; 

READLN(#1.DATA) END; 

CLOSE(#1>; 

PRESSANY; 

XCTL( ‘D: INIT.PCD 1 ) END; 

1 : BEGIN (* Trace on *) 

POKE(CURSOR,ON); 

WRITELN('Enter number of entries 
READ(I); 

TRAC EON( I) ; 

XCTL('D:INIT.PCD') END 


to be listed 1 ) 


t o main t ain: 


END 
END . 



1 > ; 


13-3 



EDITOR F FtOG Ft AM S O \J Ft G E LIST 

EDI TO Ft . F> A S 


PROGRAM EDITOR; 

<* A part of Draper Pascal 
(* By Norm Draoer 
( * $ 5 + * ) 

<*$I D:EDITOR1.PAS *> 

<*$I D:EDITOR2.PAS *> 

<*$I D;EDITOR3.PAS *) 

(*$I D:EDITORS.PAS *> 

(* $ I D: EDITOR 5 .PAS *) 

(*$I D:EDITOR6.PAS *> 

<*$I D:EDIT0R7.PAS *> 


* ) 
* > 


E D I TO Ft 1 . E A S 


CONST CLEARs125 ; BELL=$FD ; ESC * 2 7 ; 

UP = 28 ;RIGHT= 31 ; 

MAXLINES = 2 51 ;MAXLENGTH-80 ; 

RAMTOP = $ 6 A ; 

LMARGIN= 8 2 ; 

C U R S O R_H ORIZ=$55 ; 

VAR CMD:CHAR; 

I ,CHGSV,LMO # LM1 ,LASTLINE,LOW,HIGH,X,Y,SW: INTEGER } 
FIL ENAME :STRING Z 3 0 3 ; 

DATA,DATA1 ,DATA2 : STRING C MAX LENGTH3 ; 

INPUT ,OUTPUT:FILE ; 

T:ARRAY CMAXLINESI OF STRINGCMAXLENGTH3 ; 

PROCEDURE MENU ; 

BEGIN 


WRITE(CLEAR); 
WRITE LN( ' 


DRAPER SOFTWARE’ 

) ; 

WRITE LN( • 

WRITE LN; 

WRITE LN( ‘ 

A 


EDITOR'); 

Add 1ine(s) at 

end • ) ; 

WRITE LN( 1 

C 

- 

Change 1 ine(s) 

* ) > 

WRITE LN( * 

D 

- 

Delete 1 ine(s) 

' ) ; 

WRITE LN( 1 

E 

- 

Edit line(s)') 

/ 

WR IT E LN ( 1 

F 

- 

Filer menu * ) ; 


WRITE LN( • 

I 

- 

Insert before 

line'); 

WRITE LN < 1 

L 

— 

List line(s)') 

; 

WRITE LN( 1 

M 

- 

Menu'); 


WRITE LN( 1 

P 

- 

Print line(s)* 

) ; 

WRITE LN( ‘ 

Q 

- 

Quit'); 


WRITE LN( 1 

S 

- 

Scan 1ine < s > ' ) 

; 

WRITELN(' 

X 

- 

Exit to Compiler') 


END ; 

PROCEDURE SHOWLINE(NUMBER); 

BEGIN 

IF NUMBERUOO THEN WRITE (OUTPUT, ' *); 

IF NUMBER <10 THEN WRITE<OUTPUT, • '); 

WRITE(OUTPUT,NUMBER,' : ' ) 

END ; 

PROCEDURE GETDATA(NUMBER); 

BEGIN 

SHOWLINE(NUMBER); 

POKE(LMARGIN,LM1); 

READLN(DATA); 

IF IORESULTsl37 THEN 

VRITELN(BELL,’Line *,NUMBER, ' truncated 1 ); 
POKE(LMARGIN,LMO); 

POKE(CURSOR HORIZ,LMO) 

END ; 


I MG 


14 — 1 



EDITOR2 . A S 


PROCEDURE INC LASTLINE; 

BEGIN 

LASTLINE:ss L ASTLINE +1 ; 

IF LASTL INE > MAX LINES THEN 
BEGIN 

VRITELN<•BUFFER FULL - STANDBY’); 
LASTLINE:»MAXLINES 
END 

END ; 


PROCEDURE GETRANGE; 

BEGIN 

LOW: =1 ; 

HIGH:=LASTLINE; 

WRITE('Line from -> '); 

READLN < DATA) ; 

IF DATA < > ’ ' THEN LOW:=VAL(DATA) ; 

IF LOW<1 THEN LOW:»1; 

IF LOW)LASTLINE THEN LOW:=LASTLINE; 
WRITE < •Line to -> ' > ; 

READLN(DATA); 

IF DATA < > ' ’ THEN H I GH : *= VAL ( DATA ) ; 

IF HIGH<LOW THEN HIGH:=LOW; 

IF HIGH > LASTLINE THEN HIGH: =LASTLINE 
END ; 


PROCEDURE EDIT; 

BEGIN 

CHGSW: = 1 ; 

GETRANGE; 

FOR I:sLOW TO HIGH DO 
BEGIN 

SHOWLINE(I); 

POKE<LMARGIN,LM1); 

WRITELN(T(I)); 

FOR Y : ss 0 TO L ENGTH ( T < I ) ) / (40-LM1) 

WRITE <UP > ; 

READ LN (T (I ) ) ; 

POKE ( LMARGIN,LMO) ; 

POKE(CURSOR HORIZ,LMO) 

END 

END ; 


PROCEDURE GETFN; 

CONST LASTFILE=$1D82; 

BEGIN 

WRITE('Enter filename -> '); 

Y:=ADDR(DATA); 

FOR X:=0 TO 16 DO 

POKE(Y + X,FEEK(LASTFILE + X) ) ; 

WRITE LN(DATA) ; 

WRITE < ' * , 28 ) ; 

READLN(FILENAME); 

Y:=ADDR(FILENAME); 

FOR X : = 0 TO 16 DO 

POK E(LASTFILE + X,PEEK(Y+X) ) ; 

IF POS( 1 :’,FILENAME)=0 THEN 
INSERT('D:’,FILENAME,1); 

I:=LENGTH(FILENAME); 

IF POS(’.',FILENAME)=0 THEN 
INSERT('.PAS’,FILENAME,I+1) 

END ; 


DO 


14 — 2 



EDITOR3 . E* A S 


PROCEDURE GETONE *, 

BEGIN 

VRITE < 'Line -> 1 ) ; 

READ(LOW), 

IF LOW < 1 THEN LOV:=l 
END ; 


PROCEDURE SAVE; 

BEGIN 
GETFN; 

Y : = 0 ; 

REWRITE(OUTPUT,FILENAME); 

X : = I ORESULT ; 

IF XOO THEN 
Y : = X 
ELSE 

FOR I;si TO LASTLINE DO 
BEGIN 

WRITE LN < OUTPUT,T( I ) ) ; 

X : ss I ORESULT ; 

IF XOO THEN 
Y : sX 

END ; 

REWRITE(OUTPUT,'E:*); 

OPTIONS( 4 ) ; (* DISABLE BREAK KEY *> 

IF Y < > 0 THEN 

WRITELN(BELL, 1 ***Error ',Y,* while savinq to disk’) 
CHGSW.sO 
END ; 


PROCEDURE CHECKUPD; 


BEGIN 

IF CHGSW=1 THEN 
BEGIN 

VRITELN('File changed but no 
WRITELN( * Enter "I” to IGNORE 

WRITE LN( ' or M S" to SAVE 

REPEAT 

READ(CMD) 

UNTIL ( CMD=s ' I ' ) OR <CMD-'S') 
IF CMDs’S’ THEN SAVE 
END 


t saved') 
and co 
and c o 


END ; 


PROCEDURE KEYBOARD; 
BEGIN 

IF SW=1 THEN 
REPEAT 
SW:»SW 

UNTIL KEYPRESS; 

IF KEYPRESS THEN 
BEGIN 

READ(CMD); 

IF CMD a* ' ' THEN 

SW: =1 
ELSE 

SW: = 0 

END 

END ; 


14-3 


3 3 



E ID I TOR <3 . E»AS 


PROCEDURE APPEND; 

BECIN 

REPEAT 

INC LASTLINE; 
GETDATA<LASTLINE); 
T<LASTLINE):*DATA 
UNTIL DATA*’’; 

CHGSV:*1; 

LASTLINE:*LASTLINE-1 
END ; 


PROCEDURE COMPILE; 

BEGIN 

CHECKUPD; 

I : =PEEK(RAMTOP) ; 

IF I>*192 THEN 
BEGIN 

CLOSE(OUTPUT); 

MAXGRAPH < 0) ; 

WRITELN; 

VRITELN < 'Loadinq Compi1er ...'); 

OPTIONS ( 5 ) ; <* ENABLE BREAK KEY *) 

XCTL < 'D;COMP ILER .PCD * ) 

END 

ELSE 

BEGIN 

WRITELNC'NEED 48K RAM TO COMPILE. •) 

WRITELN< 1 REMOVE CARTRIDGE, IF PRESENT,’) 
WRITELN('AND RE-BOOT DISK ’) 

END 

END ; 


PROCEDURE DLTE; 

BEGIN 

GETRANGE; 

FOR I :* 0 TO LASTLINE-HIGH-1 DO 
BEGIN 

X: * LOW+I ; 

Y: *HIGH+ 1 + 1 ; 

T(X):*T(Y) 

END ; 

CHGSW:*1; 

LASTLINE:*LASTLINE-(HIGH-LOW)-1 
END ; 


PROCEDURE DIRECTORY; 

BEGIN 

WRITE < ' Filespec? '); 

READLN < DATA) ; 

IF DATA*’* THEN 
DATA: * * D1 :* . *' ; 

IF POS< ’ : ’ ,DATA)* 0 THEN 
INSERT( •D1 : ’ ,DATA, 1 ) ; 

IF POS('.',DATA)=0 THEN 

INSERT< DATA , LENGTH ( DATA > 4-1 ) ; 

OP EN (#5,6,0 ,DATA) ; 

READLN(# 5 ,DATA) ; 

P P P r* A *T» 

WRITE LN(DATA) ; 

READLN(# 5 ,DATA) 

UNTIL EOF(#5); 

CLOSE( #5 ) 

END ; 


14-4 



EDITORS.EAS 


PROCEDURE INSRT, 

BEGIN 

CHGSW : *1 ; 

GETONE; 

GETDATA(LOV); 

WHILE DATA < > 1 1 DO 
BEGIN 

FOR I:aLASTLINE DOWNTO LOW DO 
BEGIN 

X: = U1 ; 

T< X) : = T( I ) 

END ; 

INC LASTLINE; 

T <LOW) ;=DATA; 

LOW: = LOW-*-1 ; 

GETDATA < LOW) 

END 

END ; 


PROCEDURE LIST; 

BEGIN 

GETRANGE; 

FOR I:=LOW TO HIGH DO 
BEGIN 

SHOWLINE(I); 

POKE<LMARGIN,LM1); 

WRITE LN < T < I) ) ; 

POKE(LMARGIN,LMO); 
POKECCURSOR HORIZ,LMO); 
KEYBOARD; 

IF CMD *ESC THEN 
I : -HIGH-*- 1 

END 

END ; 


PROCEDURE PRINT; 

BEGIN 

GETRANGE; 

OPTIONS < 0) ; 

REWRITE(OUTPUT, * P : ' ) ; 

IF IORESULTOO THEN 
BEGIN 

WRITELN< * PRINTER NOT READY '); 

WRITELNC 1 PRESS START WHEN READY’); 
REPEAT 

OPTIONS(0) 

UNTIL STARTKEY; 

REWRITE(OUTPUT, 1 P: 1 ) 

END ; 

FOR I:=LOW TO HIGH DO 
BEGIN 

SHOWLINE(I); 

WRITE LN(OUTPUT,T( I ) ) 

END ; 

OPTIONS( 1) ; 

REWRITE(OUTPUT,'E: 1 ); 

OPTIONS(4) (* DISABLE BREAK KEY *) 

END ; 


14-5 



ED ITOR6 . IP A S 


PROCEDURE APNDFILE > 
VAR IOR:INTEGER; 


BEGIN 

OPTIONS(0); 

REPEAT 
GETFN; 

RESET(INPUT,FILENAME); 

I OR : a IORESULT; 

IF IORESULTOO THEN 

WRITE LN < 'File not found') ; 

UNTIL IOR a 0 ; 

WHILE NOT EOF(INPUT) DO 
BEGIN 

TlSir T ASTL INF • 

READLN( INPUT , # T( LASTLINE) ) ; 

IF IORESULTa 13 7 THEN 

WRITELN(BELL,’Line ’,LASTLINE,' truncated’) 


END ; 

LASTLINE:=LASTLINE-1; 

CLOSE < INPUT) ; 

WRITELN<LASTLINE, 1 lines now in memory*) 
END ; 


PROCEDURE CHANGE; 
VAR PRTSW:INTEGER; 



BEGIN 

GETRANGE; 

WRITE<’Chanqe from ->*); 

READLN < DATA1) ; 

WRITE('Change to ->’); 

READLN(DATA2); 

Y: sLENGTH(DATA 1) ; 

FOR I : a LOW TO HIGH DO 
BEGIN 

DATA:*T(I); 

PRTSW:=0; 

X : = POS < DATA1 ,DATA) ; 

IF POS(DATA1,DATA)<>0 THEN 
BEGIN 

CHGSW:=1; 

PRTSW:»1; 

DELETE(DATA,X ,Y> ; 
INSERT(DATA2,DATA,X); 

T(I):= DATA 
END ; 

IF PRTSWal THEN 
BEGIN 

SHOWLINE(I); 

WRITELN(DATA); 

KEYBOARD 

END 

END 

END ; 


PROCEDURE SCAN; 


BEGIN 

GETRANGE; 

WRITE(•Soan for ->’>; 
READLN(DATA1); 

FOR I := LOW TO HIGH DO 
BEGIN 


DATA:=T(I); 

IF POS(DATA 1 ,DATA) < > 0 
BEGIN 

SHOWLINE(I); 

WRITE LN(DATA) ; 
KEYBOARD; 

IF CMDaESC THEN 
I : aHIGH+1 


END 


END 


THEN 


END ; 


14-6 



E H> I TO Ft . IP A S 


PROCEDURE FILER, 


BEGIN 

VRITE LN( * A 

WRITE LN( ’ D 

WR I T E L N < ' L 

VRITELN(' S 

REPEAT 


READ(CMD) 

UNTIL < CMD- 1 A' ) 
OR < CMD— 1 D * > 
OR (CMD-‘L•) 
OR < CMD—'S'); 
CASE CMD OF 
‘ A 1 : BEGIN 


Append file 1 ); 
Directory list'); 
Load file'); 

Save file') ; 


IF LASTLINE>0 THEN CHGSW:-1, 
APND FILE 


END ; 

‘D 1 :DIRECTORY ; 

1 L':BEGIN 

CHECKUPD; 
CHGSW:-0; 
LASTLINE:-0; 
APNDFILE 
END ; 

'S':SAVE 
END 


END ; 

BEGIN <* MAIN *) 

CHGSW:-0; 

REWRITE(OUTPUT, * E: 1 ) ; 

MENU ; 

OPTIONS ( 4 ) ; <* DISABLE BREAK KEY *> 

LMO : -PEEK < LMARGIN) ; 

LM1:-LM0+4; 

REPEAT 

WRITE < 'A,C,D,E,F, I ,L,M,P,Q,S,X, ? - > ' ) ; 
READ(CMD); 

WRITELN(CMD); 

CASE CMD OF 
'A•:APPEND; 

’C• :CHANGE ; 

'D•:DLTE; 

1 E':EDIT; 

‘F 1 :FILER; 

' I * : INSRT; 

1 L’:LIST; 

'M','?':MENU; 

•P':PRINT; 

•Q' : ; 

•S':SCAN; 

‘X•:COMPILE 
ELSE 

WRITELN(BELL,'Invalid c oromand 1 ) 

END 

UNTIL CMD-* Q• ; 

CHECKUPD; 

CLOSE(OUTPUT); 

OPTIONS(5); (* ENABLE BREAK KEY *) 

XCTL( 1 D1 : INIT.PCD * > 

END . 



14-7 





S A M JP L E 3P IP. CD G R A T"! S O X-T FICE LXSTTXrsIGS 


SAME LEI 


PROGRAM KALEIDOSCOPE; 

VAR I,J,K,W,X:INTEGER; 

BEGIN 

MAXGRAPH(3) ; 

GRAPHICS < 1 9 ) ; 

X : =0 ; 

REPEAT 

FOR W: = 3 TO 50 DO 
BEGIN 

FOR I : = 1 TO 10 DO 
BEGIN 

FOR J:=0 TO 10 DO 
BEGIN 
K : a I + J ; 

COLOR<J*3/<I+3>+I*W/12>; 
PLOT < 1+8 .K> ; 

PLOT(K + 8 , I ) ; 

P LOT <32-1 , 24-K) ; 

PLOT < 3 2-K , 24-1 ) ; 

P LOT < K + 8 ,24-1 ) ; 

PLOT(32-1,K>; 

PLOT < 1+8 ,2 4-K > ; 

P LOT <3 2 —K, I ) 

END 

END 

END 

UNTIL X=*9 9 <* UNENDING LOOP *> 

END . 


S AM JP L E 2 


PROGRAM ROMAN; 

<* ROMAN NUMERAL SAMPLE PROGRAM *> 
<* ADAPTED FROM PASCAL USER MANUAL 

WIRTH *> 

VAR X,Y:INTEGER; 

BEGIN Y:=l; 

REPEAT X:=Y; WRITE <X, f *>; 

WHILE X>«1000 DO 
BEGIN 

WRITE < 'M 1 > ; X:=X-1000 

END ; 


IF X > ss 5 0 0 THEN 
BEGIN 

WRITE <'D’); X:=X- 
END ; 

WHILE X>*100 DO 
BEGIN 

WRITE ('C•); X:=X- 
END ; 

IF X > a 5 0 THEN 
BEGIN 

WRITE ('L'); X:=*X- 
END ; 

WHILE X>=10 DO 
BEGIN 

WRITE ('X•); X:=X- 
END ; 

IF X > * 5 THEN 
BEGIN 

WRITE ('V'); X:»X- 
END ; 

WHILE X>=1 DO 
BEGIN 

WRITE ( ' I ' ) ; X : scX — 
END ; 

WRITELN; 

Y as Y * 2 

UNTIL Y > 5 0 0 0 
END . 


500 


1 00 


50 


1 0 


5 


1 


AND REPORT BY JENSEN AND 


15-1 



MOM- E X CLUS I V E 


ROYALTY — FRE E 


LIC EMS E 
DR AP E R 


TO L> I STR X BUTE THE 
RASCAL SUP ERV I SOR 


I. Purpose 

This royalty-free, non-exclusive license is provided to allow widespread use of 
software developed using Draper Pascal. It applies only to the original purchaser of 
Draper Pascal (’’Licensee**). 


II. The License 

Subject to the conditions stated herein, Draper Software will grant to the Licensee a 
royalty-free, non-exclusive license to distribute the run-time system (“Supervisor 1 '). 
Licensee is only authorized to distribute the Supervisor in object code form and only 
in conjunction with software developed by Licensee which requires the Supervisor for 
proper operation. Licensee shall not use or purport to authorize any person to use 
any of the copyrights, trademarks, service marks, or trade names of Draper Software 
without prior written consent from Draper Software. 

The Supervisor consists of the file named AUTORUN.SYS on the supplied diskette. It 
may be distributed under another name if Licensee so desires. 

The supplied Disk Operating System (DOS) is excluded and may not be distributed bv 
Licensee. 


III. The License Term 

This license will run for a term of five (5) years from date of license acceptance. 
Extensions beyond that term may be secured by written permission from Draper 
Software. 


IV. Acceptance 

The term of this license will begin two weeks after Licensee has signed and returned 
a copy of this license to Draper Software, providing that no reject notioe was sent 
to you by Draper Software within the two week period. 


V . Additonal T e tt m s and C o n d i t ions 


A. Licensee understands and agrees that: 

1. The Supervisor is distributed on an "as is" basis without warranty of any 
kind from Draper Software. 

2. The entire risk as to the performance and quality of the Supervisor is with 
the Licensee. 

3. If the Supervisor, as incorporated into Licensee’s products proves defective 
following it's purchase. Licensee and not Draper Software, Draper Software's 
distributors, or retailers, assumes all costs associated with or resulting from 
use of Licensee’s products including all necessary repair or servicing. 

4. Draper Software shall have no liability to Licensee or to customers of 
Licensee for loss or damage, including consequential and/or incidental 
damage, caused or alleged to be caused, directly or indirectly, by the 
Supervisor. This includes, but is not limited to, any interruption in service 
or loss of business or anticipatory profits resulting from the use or 
operation of the Supervisor. 

B Licensee shall indemnify and hold Draper Software harmless from any claim, loss, 
or liability allegedly arising out of or relating to the operation of the Supervisor 
as used by Licensee or customers of Licensee pursuant to this license agreement. 

C. Licensee shall not suggest, imply or indicate in any manner that any of 
Licensee’s software products which incorporate or use the licensed Supervisor are 
approved or endorsed by Draper Software. 


16-1 




D. Licensee acknowledges that a failure to conform to the provisions of Section V, 
Subsection C (above) will cause Draper Software irreparable harm and Draper 
Software's remedies at law will be inadequate. Licensee acknowledges and agrees 
that Draper Software shall have the riaht, in addition to other remedies, to 
obtain an immediate injunction enjoining anv breach of Licensees obligations set 
forth in Section V.C above. 


E. No waiver or modification of any provisions of this license shall be effective 
unless in writing and signed by the party aqainst whom such waiver or 
modification is sought to be enforced. No failure or delay by either party in 
exercising any right, power or remedy under this license shall operate as a 
waiver of any such right, power or remedy. 

F. This license shall bind and work to the benefit of the successors and assiqns of 
the parties hereto. Licensee may not assign rights or delegate obligations which 
arise under this license to any third party without the express written consent 
of Draper Software. Any such assignment or delegation, without written consent 
of Draper Software, shall be void. 

G. The validity, construction and performance of this license shall be governed by 
the substantive law of the State of Texas and of the United States of America 
excluding that body of law related to choice of law. Anv action or proceeding 
brought to enforce the terms of this license shall be brouqht in the County of 
Dallas, State of Texas, if under state law. 

H. In the event of any legal proceeding between the parties arisinq from this 
license, the prevailing party shall be entitled to recover, in addition to anv 
other relief awarded or granted, its reasonable costs and expenses, including 
attorneys' fees, inourred in the proceeding. 


Your Name _ 

Company Name (if any) 


Address 


City, State, Zip 
Telephone Number 


Signature and Date 


16-2 


SATISFACTTIOINI 


GUARANTEED 


If, within the first 30 days of ownership, you are not satisfied with the quality or 
performance of Draper Pascal, you may return it to the place of purchase for a 
refund of the price paid for the software. It must be in original condition and 
accompanied by the purchase receipt or invoice. Please also mention the reason for 
return so that future versions of this product can be improved. If you purchased 
Draper Pascal from a dealer that does not normally accept returns, please have the 
dealer contact Draper Software to arrange for return to us for the price the dealer 
paid for it. 


LIMITED WARRANTY FOR DRAPER PASCAL 


Draper Software makes no warranties, implied or expressed, as to the fitness of this 
software product for any particular purpose. In no event will Draper Software be 
liable for consequential damages. Draper Software will replace any copy of Draper 
Pascal which is unreadable if returned within 90 days of purchase. There will be a 
nominal charge for replacement after the 90 day period. 

If a software problem (bug) is encountered, please contact Draper Software riaht 
away. In our opinion, if it is considered a software bug, it will be fixed, free of 
charae. We don't believe that you should pay for any of our mistakes. Do not return 
your diskette for replacement without first contacting us. Either call us on the phone 
and describe the problem, or write to us including a thorough description of the 
problem. 

When a new version of Draper Pascal becomes available, you will be notified and 
given the opportunity to obtain it for a nominal charge. Details of the enhancements, 
and problems fixed, and the charge for the upgrade will be specified in the 
notification. You must fill out and return the Owner Reaistration Form, included with 
this manual, in order to be notified of future versions. 


17-1 





DRAPER PASCAL 


OWNER Ft E G I STRATI Olsl FORM 

You must send in this owner registration form in order to be notified of future 
upgrades or purchase a backup diskette. 

Serial Number (from diskette label) _ 

Name __ 

Address _ 

City, State, Zip code _ 

Purchased from _ 

City, State ____ _ _ 

Comments/Suggestions/Problems encountered _ 



C 3 Please send me a backup Draper Pascal diskette. Enclosed is $10.00. 

Fold and mail to: 

Draper Software 
307 Forest Grove 
Richardson. Texas, 75080 


18-1 





F r om 



Draper Soft w are 
3 0 7 Forest C xr o v e 


Ri ohardson , Texas , 7 5 O 8 O 





