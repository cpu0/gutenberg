AD-A208 830 


UNCLASSIFIED 

_SCCUb:^* ClasSHICATIO*. Of This RA&i 0#f* fnwrf eO ^ / . ill u 1/^ 

REPORT DOCUMZNTATION PAGE 

•KaO OYtTRUCnOMS 
•trORE COMRlETEn^C rOR-V 

1. RERORT NUMBER |2. SOVT ACCESSION NO. 

3. RECIRIENT'S CATVlOG NUMBER 

4. TJTlE iubt’tie) 

Ada Compiler Validation Summary Report: Digital 
Equipment Corporation, VAX Ada Version 2.0, VAX 8800 (host 
to VAX 8800 (target), 890127S1.10033 

4. TYRE Of RERORT A RERJOD COVERED 

27 Jan 1989 - 1 Dec 1990 

e. RlRfORMINGtlRG. RERORT NUMBER 

'. AUTHORu; 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 

B. cor'RACE OR GRANT NUME:r(i; 

1. RERFORMINC OR&ANWATlOh AND ADDRESS 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 

10. rrogram element, rrcject. tasa 
AREA A NORA UNIT NUMBERS 

1. controlling office name and ApORESS 

Ada Joint Program Office 

United States Departfient of Defense 

Washington, DC 20301-3081 

12. RERORT DATE 

13. NUMoIirur PAGLS 

4. MONITORING AGENCY NAME & AOORESSpFafFYcrcnt from Contro/Zinp Of/<cr; 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 

IS. security CLASS (of this report) 

UNCLASSIFIED 

iSt. g^C^AS^piCATION/DOwsGRADING 

N/A 


16. DISTRIBUTIOK SIATEMENT (of thf tut port) 


Approved for public release; distribution unlimited. 

17. OISTRIBJUON SIA’tK-M (ofthetbnrtcirntert^inBipckiO if cl'fftrtnr froiri 

UNCLASSIFIED 


18. SuPF.tMiMARi NOTlS 


IB . RE vir^'S.'S (Conjinut O') tfvfif t'Of if nrctu*') tnd icirntif) ty blO(k rtumbt’) 

Ada ProcrarjT.ing language, Ada Compiler Validation Sumjr.ary Report, Ada 
Cor.piler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/MIL-STD- 
1815A, Ada Joint Program Office, AJPO 


20 . ABSTRACT (Conrinur on rr,er,, iitfr if nKtmr^ tndidrntif) by block number) 

VAX Ada Version 2.0, Digital Equipment Corporation, National Institute of Standards 
and Technology, VAX 8800 under VMS, Version 5.0 (host and target), ACVC 1.10 


f 89 5 30 004 

DD 1473 EOITIOR OF 1 NOV 6S IS obsolite 



1 JAM 79 


S/M 0102-LE*01«-e601 


UNCLASSIFIED 


security ClASSH KAT10*» or THIS RACE (»vnfnO,t, Enfffftf) 
















AVF Control Number; NIST89DEC510 1 1.10 


Ada Compiler Validation Summary Report: 

Compiler Name: VAX Ada Version 2.0 
Certificate .Number; 890127S1.10033 

Host: V,VM 8800 V.NS, Version 5.0 

Target; V.AX 8800 under V.MS, Version 5.0 

Testing Completed 01-27-89 Using ACVC 1.10 


This report has been reviewed and is approved. 



Chief, Information Systems 
Engineering Division 

National Computer Systems Laboratory (NCSL) 
National Institiite of Standards and T':chnol'>py 
Building 225, Room .A266 
Gaithersburg, MD 20899 



Institute for Defense .Analyses 
Alexandria VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Washington D.C. 20301 


/ 

I 

'\ 


Accer.rilon For 

“nTIS GPAil 
DTIC T-A 
Unann □ 

Justification- 




By--- 

Distribution/ 


Availabili ty C odes 
|AvaiT and/or 
Dlst I Special 











AVF Control Number: NIST89DEC510_1_1.10 
DRAFT PREPARED AFTER ON-SITE: 01-27-89 
FINAL PREPARED: 04-27-89 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 890127S1.10033 
Digital Equipment Corporation 
VAX Ada Version 2.0 
VAX 8800 Host and VAX 8800 Target 


Completion of On-Site Testing: 
01-27-89 


Prepared By: 

Software Standards Validation Group 
National Computer Systems 
Laboratory 

National Institute of Standards 
and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Prepared For; 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 






AVF Control Number; NIST89DEC510 1 1.10 


Ada Compiler Validation Summary Report: 

Compiler .Name: V.AX .Vda Version 2.0 
Certificate .Number; 890127S1.10033 

Host: ViNM 8800 V.^S, Version 5.0 

Target: VAX 8800 under V.'IS, Version 5.0 


Testing Completed 01-27-89 Using ACVC 1.10 


This report has been reviewed and is approved. 



Chief, Information Systems 
Engineering Division 

National Computer Systems Laboratory (NCSL) 
National Institute of Standards and T'-.chnol‘’py 
Building 225. r.oom ,A2'56 
Gaithersburg, XD 20899 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Washington D.C. 20301 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . . 3-6 

3.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Prevalidacion.3-7 

3.7.2 Test Method.3-7 

3.7.3 Test Site.3-8 

APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B .APPENDIX F OF THE Ada STAI.’DARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

APPENDIX E COMPILER OPTIONS AS SUPPLIED BY 

Digital Equipment Corporation 






















CHAPTER 1 


INTRODUCTION 


This Validation Summary Report <VSR^ describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of testing this compiler using the Ada Compiler 
Validation Capability. (ACVC). An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler prop-rly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the .Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 


1-1 



1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


On-site testing was completed 01-27-89 at Nashua, New Hampshire. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OVSDRE 

The Pentagon, Pun 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Laboratory 
National Bureau of Standards 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 


1-2 





Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A. February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada .Compiler Validation Capability User's Guide, December 1986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada An Ada Commentary contains all information relevant to 

the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 


Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 


Applicant 


The agency requesting validation. 


AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
C7uidelines. 


AVO 


Compiler 


The Ada Validation Organization. The AVO has oversight 
authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 
technical support for Ada validations to ensure 
consistent practices. 

A processor for the Ada language. In the context of 


1-3 




this report, a compiler is any language processor, 
including cross-compilers, translators, and 

interpreters. 

An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding 

a particular feature or a combination of features to the 
.Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 

1.5 ACVC TEST CLASSES 

Conformity to the .Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal .Ada programs structured into six test 
classes: A, 5, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 


Failed test 

Host 


1-4 







program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the com.piler for an allowable reason. 

Class L tests check that incom.plete or illegal Ada programs involving 
multiple, separatelv compiled units are detected and not allowed to 
execr'■.e. Class L tests are com.piled separately and execution is 
attempted. .A Class L test passes if it is rejected at link time--that 
is, an atte.-pt t;. execute the m.ain program, must generate an error 
message before any declarations in the miain program or any units 
referenced bv the m.ain program are elaborated. In some cases, an 
implementation may legitimately aetect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self - checking features of the executable tests. The package 
REPORT provides the m.echanism by which executable tests report PASSED, 
FAILED, or NOT .APPLIC.ABLE results. It also provides a set of identity 
functions used to defeat som.e compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 


1-5 






of the Class C tests for Chapter 14 of the A.da Standard, The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features chat may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent x'alidacion. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is v.-iti'.ctuv.-r. from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdravm at the time of this validation 
are given in .-^ppendi.x D. 


1-6 



CHAPTER 2 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate coir.pilation system for this validation was tested under 
the following configuration: 


Compiler: 

ACVC Version: 
Certificate !U.:::.ber: 
Host Coirputer: 


Van Ada Version 2.0 

1.10 

C9012'S1.10033 


a c! 'i i e : V.AM 8800 

Operating System: VMS, Version 5.0 
MaiTiory Size: 68 MBytes 


1 a r tl 6 t w 0 ir.‘,1 Z i 


S . Version 5.0 
’ ;• .':Bvtts 


2-1 




2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such im.plementarion differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics ; 


(1) The compiler correctly processes a compilation containing 
72 3 variables in the same declarative part. (See test 

D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

(3) The compiler correctly processes tests containing block 
state::.ents nested to C5 levels. (See test D56001B.) 

(u) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 


(1) This implementation supports the additional predefined 
types SHbRT_INTEGER, SHORT_SHORT_INTEGER, LONG_FLOAT. and 
LO^'G_LO^^G_FLOAT in the package STANDAPvD . (See tests 
BS60C1T..Z n tests).) 


c . 


or.. 


The order in which e-:-:pressions are evaluated and the time at 
which constraints are checked are not defined by the language, 
uhiile the .ACVC tests do not specifically attempt to determine 
the order of evaluation of expressions, test results indicate 
the following: 

(1) .All of the default initialization expressions for record 
com.pon.ents are evaluated before any value is checked for 
membership in a co.mponent's subtype. (See test C32117A.) 


Assignments for subtypes 
precision as the base type. 


( 2 ) 


2-2 


are performed with the same 
(See test C35712B.) 







(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 

C35903A.) 

(4) NU.MERIC_ERROR is raised when an integer literal operand in 
a comparison or membership test is outside the range of the 
base type. (See test C45232A.) 

(5) NUMERIC_ERROR is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is not gradual. (See tests C45524A..Z (26 

tests) . ) 


d. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. While Che ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 

(1) The method used for rounding to integer is round away from 
zero, (See tests C46012A..Z (26 tests).) 

(2) The method used for rounding to longest integer is round 
away from zero. (See tests C46012A..Z (26 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round away from zero. (See test 

C4A014A.) 


e. Array types. 

An i;r.p lerr.entation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a ’LENGTH that exceeds 
STANDARD . INTEGER ' LAST and/or SYSTEM.MAX_INT. For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises NUMERIC_ERROR. 
(See test C36003.A.) 


(2) 

NUM£RIC_ERROR 
INTEGER'LAST 
C36202A.) 

is raised 

2 componen 

when 
ts is 

an array 
declared. 

type 

(See 

with 

test 

(3) 

NUMERIC ERROR 
SYSTEM.MAX_INT 

is raised when 
+ 2 components is 

an array 
declared. 

type 

(See 

with 

test 


C36202B.) 


2-3 



(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises NUMERIC_ERROR when the array type is 
declared. (See test C52103X.) 

(.5) A racked two-dimensional BOOLEAN array with more than 
INTEGER'Last components raises NUMERIC_ERROR when the array 
subtvpe is declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises NUMERIC_ERROR when the array type is 
declared. (See test E52103y.) 

(7) In assigning one-dimensional array t)^es, the expression is 
evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

(5) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before C0NSTRAINT_ERR0R is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

f. Discrim.inated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
C0NSTRAINT_ERR0R is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 


g. Aggregatis. 

(1) In the evaluation of a multi -dimensional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 

C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised before all choices are evaluated 
when a bound in a non-null range of a non-null aggregate 
does not belong to an index subtype. (See test E43211B.) 


2-4 





h. Pragmas. 


(1) The pragma INLINE is supported for functions or procedures. 
(See tests LA300LA..B (2 tests), EA3004C..D (2 tests), and 
CA3004E..F (2 tests).) 


i. Generics . 

(1) Generic specifications and bodies can be compiled in 

separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 


(4) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(5) Generic non-library subprogram bodies can be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits can be 
compiled in separate co.mpilations. (See test CA2009C.) 

(9) Generic unit bodies and their subunits can be compiled in 
separate compilations . (See test C.A3011.\.) 


j. Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with 

uncons trained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.) 

(2) The package DIRECT_IO cannot be instantiated with 

unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101H, 
EE2401D, and EE2401G.) 


2-5 







(3) Mode IN_FILE is supporced for the operation of CREATE for 
SEQUENTIAL_I0. (See test CE2102D.) 

(4) Mode IN_FILE is supported for the operation of CREATE for 
DIRECT_IO. (See test CE2102I.) 

(5) Mode IN_FILE is supported for the operation of CREATE for 
text files. (See test CE3102E.) 

(6) DELETE operations are supported for SEQUENTIAL_IO. (See 
test CE2102X.) 

(7) RESET operations of OUT_FILE to IN_FILE are supported but 
RESET operations of IN_FILE to OUT_FILE are not supported 
for SEQUENTIAL_I0. (See test CE2102G.) 

(8) RESET and DELETE operations are supported for DIRECT_IO 
with the exceptions that RESET from IN_FILE to _OUT_FILE 
and RESET from IN_FILE to INOUT_FILE are not allowed. (See 
tests CE2102K and CE2102Y.) 

(9) RESET and DELETE operations are supported for text files. 

(See tests CE3102F..G (2 tests), CE3104C, CE3110A, and 

CE3114A.) 

(10) Overwriting to a sequential file truncates to the last 

element written. (See test CE2208B.) 

(11) Temporary sequential files are not given names. (See test 
CE2108B. ) 

(12) Temporary direct files are not given names. (See test 

CE2108D.) 

(13) Temporary text files are not given names. (See test 

CE31125. )" 

(14) More t'r.an one internal file can be associated with each 

exterr.al file for sequential files when reading only 
(See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 

CE2111D.) 

(15) .More than one ititernal file can be associated with each 
external file for direct files when reading only . (See 
tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(16) More than one internal file can be associated with each 

external file for text files when reading only. (See tests 
CE2:ilA..E (5 tests). CE3114B, and CE3115A.) 


2-6 






CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 43 tests imd been withdrawn because of test errors. The AVF 
determined that 150 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing. 
Modifications to the code, processing, or grading for 4 tests were 
required to successfully demonstrate the test objective. (See section 
3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard, 


3.2 SU.MMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 


L 

TOTAL 

Passed 

129 

1132 

2173 

17 

26 

46 

3523 

Inapplicable 

0 

6 

143 

0 

2 

0 

151 

■■.■ithdrav.-n 

1 

2 

34 

0 

6 

0 

43 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 







3.3 SU>MARY OF TEST RESULTS BY CHAPTER 


RESULT 

0 

*3 

4 


6 

7 

CHAPTER 
8 9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

0 f>0 

K 0 

w. -♦ O 

661 

245 

172 

99 

162 

331 

137 

36 

252 

296 

275 

3523 

Inapplicable 

3 

1 

19 

3 

0 

0 

4 

2 

0 

0 

0 

73 

4-6 

151 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

1 

0 

0 

1 

35 

4 

43 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 43 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

B97102E 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A72A 

CD:a73£ 

C02A73C 

CD2 7 2D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A63G 

CD2A84!'. 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD5011O 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 

ED7006D 

E28005C 

ED7004B 

ED7005C 

ED7005D 

ED7006C 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a com.piler is not required by the Ada Standard to support. 
Others m^ay depend on the result of another test that is either 
inapplicable or ■..• i thdr awn.. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test chat is inapplicable for one validation attem.pt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 150 
tests were inapplicable for the reasons indicated: 


C24113V..Y (3 tests) have source lines chat exceed the VAX Ada 
im.plem.entation lim.it of 255 characters. 

C35702A and 5S6001T (2 tests) are not applicable because this 

implementation supports no predefined type SH0RT_FL0AT. 


3-2 






C45531M..P and C45532M,.P ( 8 cests) are not applicable because 
this implementation does not support the particular fixed point 
base types required by these tests. 


C45231C, C453CUC, C45502C, C45503C, C45504C, C45504F, C45611C, 
C45613C, C-56wC, C45631C. C45632C, B52004D, C55B07A, B55B09C, 
B86001W, and CD7101F (16 tests) are not applicable because this 
implementation does not support a predefined type LONG_INTEGER. 

B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

C86001F is not applicable because, for this implementation, the 
package TE.\T_IO is dependent upon package SYSTEM. This test 
recompiles package SYSTE.M, making package TEXT_IO, and hence 
package REPORT, obsolete. 

B91001H is not applicable because this implementation does not 
support address clauses for task entries (Al-325). Typically, the 
address of the code to be executed when an interrupt occurs is 
scored in an interrupt vector at some particular memory location. 
However, the V.MS operating system uses asynchronous system trap (or 
AST) for a software interrupt. The ASTs receive dynamically the 
address of tiie code to be executed when an interrupt occurs as a 
parameter to a system service routine when a service is requested. 

C96005B is not applicable because there are no values of type 
DURATION' BASE that are outside the range of DURATION. 

CD1009C, CD2A41A, CD2.A41B, CD2A41E, CD2A42A, CD2A42B, CD2A42C, 
CD2A42D, CD2A42E, CD2A42F, CD2A42G, CD2A42H, CD2A42I, and CD2A42J 
(14 tests) are not applicable because this implementation does not 
support shortened mantissa and/or exponent lengths for floating 
point types. 

CD1CC4C, CD2.A53C, and C02.A54G (3 tests) are not applicable because 
a representation clause specifying SMALL for a derived fixed point 
type is on.ly allov.-ea if the resulting model numbers are 
(representable) values cf the parent type. 

CD2A52C. CD2A52D. CD2A52G. CD2A52K, CD2A54C, CD2A54D, and CD2A54H ( 
7 tests) are not applicable because these tests contain size 
representation clauses that are illegal for certain derived fixed- 
point subtypes due to the particular base type selected by the 
implementation. 

CD2A61A, C02A61S, CD2A61C. CD2A61D, CD2A61F, CD2A61H, CD2A61I, 
CD2A61J, CD2.-.61K, CDr.--.6iL. CD2A62A, CD2A62B, CD2A62C, CD2A64A, 
CD2A64B, C;;2.A6-:*C. CD2.A6-D. CD2A65A, CD2A65B, CD2A65C, and CD2A65D 
(21 tests) are not applicable because this implementation does not 
support packing by means of a length clause for an array type. 


3-3 






CD2A71A, CD:a'1B. CD:a71C. CD2A71D, CD2A72A, CD2A72B, CD2A72C, 
CD2A72D, CD2A7-.A. CD2A74B. CD2A74C, CD2A74D, CD2A75A, CD2A75B, 
CD2A7 5C, aiid CD2A7 5D '16 tests) are not applicable because this 
implementation does not support packing by means of a length clause 
for a record type. 

CD2aS^B, CD2AS-.2, CD2aS:.D , CDBaS-^E, CD2A84F, CD2A84G, CD2A84H, 
CD2a8‘4I , CD.;aS-.k, and CL2AS-+L (10 tests) are not applicable because 
this i m p 2 V !i', e n t a t i o n does not support biased pointer 
representations. 

CD2B15B is not applicable because the LRM 13.7.2(12) states that 
T'ST0RAGE_SIZE for an access type or subtype T "yields the total 
number of storage units reserved for the collection associated with 
the base type of T." The meaning of "total number of storage units 
reserved" is open to interpretation and it is possible for an 
implementation to return one of two values: the number of bytes 
requested (and reserved) or the number of bytes actually allocated. 
T).*s compiler im.plements the former. 


CE2102D is 
CREATE with 

not applicable because this 
IN_FILE m.ode for SEQUENTIAL_10. 

implementation 

supports 

CE2102E is 

liut applicaii.e because this 

implementation 

supports 

CREATE with 

0l'T_FILE mode for SE0UENTIAL_I0 

• 


CE2102F is 
CREATE with 

not applicable because this 
IL'01'T_FILE mode for DIRECT_I0. 

implementation 

supports 

CE2102I is 
CREATE with 

not applicable because this 
IL’ FILE mode lor DIRECT 10. 

implementation 

supports 

CE2102J is 
CREATE with 

n.ot applicable because this 
:LT_FILE mode for DIRECT_I0. 

implementation 

supports 


CE21C2b’ is I'.Gt applicable because this implementation supports OPEN 
.k.' * .T. oc»c ^01 ^ ^. 

CE21C20 is -.'.Dt applic.-.ble because this im.plementation supports 

P.ESuT wit:'. *1 r * La m.oGe tor SuxLaL * I.Au_I0 . 

CE2102? is ;'.ot applicable because this implementation supports OPEN 
with 0L'T_FILE mode for SE0L'Ei.'TIAL_I0. 

CE2102Q is not applicable because this implementation supports 

RESET with 0LT_FILE mode for SEQUENTIAL_I0. 

CE2102R is net applicable because this implementation supports OPEN 
with I!;0UT_FILE mode tor 2'IRZCT_I0. 

CE2102S is not applicable because this implementation supports 

RESET with INOUT FILE mode for DIRECT 10. 




CE2102T is not applicable because this implementation supports OPEN 
with IN_FILE mode for DIRECT_IO. 

CE2102U is not applicable because this implementation supports 

RESET with IN'_FILE mode for DIRECT_IO. 

CE21C2V is not applicable because this implementation supports OPEN 
with OUT_FIbE mode for DIRECT_IO. 

CE2102W is not applicable because this implementation supports 

RESET with OUT_FILE mode for DIRECT_10. 

CE2105A is inapplicable because CREATE with IN_FILE mode is not 

supported by this implementation for SEQUENTIAL_IO. 

CE2105B is inapplicable because CREATE with 1N_FILE mode is not 

supported by this implementation for DIRECT_IO. 

CE2107S CE2107E, CE2107G, CE2107L. CE2110B, CE2110D, CE2111H, 

CE3111B, CE3111D. CE3111E, CE3114B, and CE3115A (12 tests) are not 
applicable because this implementation does not allow more than one 
association for OUT_FILE or INOUT_FILE in combination with mode 
Ih’_FILE or another mode 0UT_FILE or INOUT_FILE (mixed readers and 

writers or multiple writers) unless a non-default FORM string is 

specified. The proper e;-;ception is raised when multiple access is 
attempted. 

CE2107C, CE2107D, CE2107H, CE2108B, CE2108D. and CE3112B (6 tests) 
are not applicable because this implementation does not support 
names for tem.porary file.' arid the NAME function raises USE_ERROR if 
called with such a file under the terms of AI-00046. 

CE2111C and CE2111D are not applicable because this im.plementatior 
does not allow the m.ode of the file to be changed from IN_FILE to 
INOTT_FILE or OUT_FILE. 

CE2--1H is r.or arplisable because this im.plementation does not 

support the instantiation of EIRECT_:0 with unconstrained record 
f.-pes ur.iv:D.= ::.a:-;i;: u.:. elen.er.t site is specified in the FORM 
parameter of the CRE.ATE procedure. This instantiation is rejected 
by this compiler. 

CE3102F is not applicable because this implementation supports 

RESET for QUT_FILE to IN_FILE. 

CE31C2G is net applicable because this implementation supports 

deletion of an external file, 

CE3102I is not applicable because this implementation supports 

CREATE with O'JT FILE mode. 


3-5 







CE3102J is not applicable because this implementation supports OPEN 
with IN_FILE mode. 

CE3102K is not applicable because this implementation supports OPEN 
with Ol’T_FIl.E mode . 

CE3109A is inapplicable because text file CREATE with IN_FILE mode 
is not supported by this implem.entation. 

EE2401D and EE2401G are not applicable because this implementation 
does not support the instantiation of DIRECT_IO with unconstrained 
record types unless a maximum element size is specified in the FORM 
parameter of the CREATE procedure. This instantiation is rejected 
by this compiler. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases 
where 1 egi t i;: . 1 1c im plementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modifications include; adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

Modifications were required for 4 tests. 

Tests CS’:C12.-. and C86002B check that library units can be named 
ST.-2.'D.ARD 'Without affecting the predefined environment. There is no 
difficulty using these tests independently; however, if they are 
attempted in the same com.pilation library in the order named, then 
the seco'.'. 1 n.e fails to compile because the function body named 
ST.-.11..L1 Ji'lT 2."1 con.s titutes an illegal redeclaration of the 
package s; e . i f ication •.'.amed ST.AND.ARD left over from the compilation 
of CS6002.■■•. j . 

CBICIOD uses a procedure GVERFLOW_STACK that is coded so that it 
needs essentially no local storage. Thus, it allows the maximum 
number of frames to be allocated in a given amount of memory. The 
VAX/V.MS operating environment limits the number of frames that an 
exception can propagate to 65,535 frames; beyond that limit the 
run-time structure of the program is assumed to be corrupted and 
the program is aborted abnormally. execution of the program using 
common user allocation quotas typically results in more than 65,535 
frames and leads to abnormal termination when STORAGE_ERROR is then 
detected. This test was included in the normal batch command test 
sequence, but processing '.vas modified so that the test was executed 


3-6 






in a n’ore 1 limited address spare. 

C3-.0CcD cherks that a derived tp-pe inherits various properties from 
the parer.r; the 'SIZE attribute is used in the tests under 
assarr.ptio: that are not fully supported by the Ada standard, and 

are su't'c.t tAi'.S re'.-ic-v.-. Thais, an implementation is ruled to 
have t:..'s.- t-.sta if the result (REPORT.RESULT) is PASSED, or 

if t:te Its .r :r.-.il.EL' ^nd the sole cause of failure is indicated 
by ti.e -titular autput of REPORT. FAILED below: 


Cl-.: 160: "INCORRECT OBJECT'SIZE" 

This i:rpile:i t. i:tat ion reports the above message and only the above 
message, 


3.7 ADDITIONAL TESTI.N’G INFCRJLATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced bv the V.Ai'l Ada Version Z.O compiler was submitted to the AVF by 
the applica; - f r review .-.r.alvsis cf these results demonstrated that 
the compiler sucss ily p-i_u<.u. ..11 applicable tests, and the compiler 
exhibited the e.xrected beha-'ior o:. all inapplicable tests. 


3.7.2 Test Method 

Testing of the V.-Jl .Ada Version 1.0 compiler using ACVC Version 1.10 was 
conducted on-site bv .. validation teami from the AVF. The configuration 
in which the testing -was performed is described by the following 
designations of hardware and software com.ponents: 



A magnetic toitc containing all tests was taken on-site by the validation 
team for processing. Tests t'nat make use of implementation-specific 
values were customized before being written to the magnetic tape. Tests 
requiring modifications during the prevalidation testing were included 
in their m.ocificc for.m on the magnetic tape. 


TEST INFORILATION 

The contents of the magnetic tape w'ere loaded directly onto the host 


3-7 














computer. After the test files were loaded to disk, the full set of 
tests was compiled, linked, and all executable tests were run on the VAX 
8800. Results were printed from the host computer. 

The compiler v.-as tested using command scripts provided by Digital 
Equipment Corporation and revieioed by the validation team. The compiler 
was tested using the following option settings. See Appendix E for a 
complete listing of the compiler options for this implementation. 

/NO.AiiALYS I S_DATA 
/CHECK 

/C0PY_S0URCE 

/NODEBUG 

/NODIAGN’OSTICS 

/ERROR_LI.MIT=1000 

/LIBRARY-ADA8LIB 

/LIST 

/N0MACHINE_C0DE 

/N0TE_S0URC£ 

/OPTIMIZE 

/NOSHOW 

/WARNINGS^delauit 

Tests were compiled, linked, and e.xecuted using a single computer. Test 
output, compilation listings, and job logs were captured on magnetic 
tape and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 


3.7.3 Test Site 

Testing was conducted at Nashua, New Hampshire and was completed on 
01-27-89. 


3-8 





APPENDIX A 


Digira 1 
Declara 


DECLAPa\TION OF CONFORMANCE 




A-l 


Digital Equipment Corporation is currently engaged in an Ada 
validation and has submitted the following declaration of 
conformance concerning VAX Ada. 


Declaration of Conformance 

Compiler Implementer: 

Digital Equipment Corporation 

Ada Validation Facility: 

National Institute of Standards and Technology 

Ada Compiler Validation Capability Version: 1.10 

Base Configuration: 

Compiler: VAX Ada Version 2.0 

Host Configuration: 

VAX 8800 (under VMS, Version 5.0) 

Target Configuration; 

VAX 8800 (under VMS, Version 5.0) 

MicroVAX II (under VAXELN Toolkit, Version 3.2 
in combination with VAXELN Ada, Version 2.0) 


1 






Declaration of Conformance 


Derived Compiler Registration: 

Compiler: VAX Ada Version 2.0 

Host Configurations: 

MicroVAX I 
MicroVAX II 
MicroVAX 2000 
MicroVAX 3500 
MicroVAX 3600 
VAXstation II 
VAXstation 2000 
VAXstation 3200 
VAXstation 3500 
VAXstation 8000 
VAXserver 3500 
VAXserver 3600 
VAXserver 3602 
VAXserver 6210 
VAXserver 6220 
VAX-11/730 
VAX-11/750 
VAX-11/780 
VAX-11/785 
VAX 6210 
VAX 6220 
VAX 6230 
VAX 6240 
VAX 8200 
VAX 8250 
VAX 8300 
VAX 8350 
VAX 8500 
VAX 8530 
VAX 8550 
VAX 8600 
VAX 8650 
VAX 8700 

VAX 8800 (base configuration) 

VAX 8810 
VAX 8820 
VAX 8830 
VAX 8840 
VAX 8842 
VAX 8974 
VAX 8978 

Raytheon Military VAX Computer Mod^' 
(all under VMS, Version 5.0) 


p <; n 


2 





Declaration of Conformance 


Target Configuration: 

Same software and configurations as Host; 

And the following VAXELN configurations 

MicroVAX I 
MicroVAX II 
MicroVAX 2000 
MicroVAX 3500 
MicroVAX 3600 
IVAX 620 
IVAX 630 
rtVAX 1000 
rtVAX 3200 
rtVAX 3500 
rtVAX 3600 
rtVAX 8550 
rtVAX 8700 
KA620 
KA8 00 

VAX-11/725 
VAX-11/730 
VAX-11/750 
VAX 6210 
VAX 6220 
VAX 6230 
VAX 6240 
VAX 8500 
VAX 8530 
VAX 8550 
VAX 8700 
VAX 8800 
VAX 8810 
VAX 8820 

(all under VAXELN Toolkit, Version 3.2 in 
combination with VAXELN Ada, Version 2.0) 


3 







Declaration of Conrormance 


All of the processors listed above, including MicroVAX, VAXstation, 
and VAXserver systems, are members of the VAX family. The VAX 
family includes multiple hardware/software implementations of the 
same instruction set architecture. All processors of the VAX family 
together with the VMS operating system provide an identical user 
mode instruction set execution environment and need not be 
distinguished for purposes of validation. Similarly, all VAX family 
processors supported as VAXELN Toolkit targets provide an identical 
user mode instruction set execution environment. 

The Military VAX Computer Model 860 is an implementation of the VAX 
architecture that is manufactured by Raytheon Corporation. This 
implementation has been tested by Digital Equipment Corporation for 
conformance with the VAX Architecture Standard and provides a user 
mode instruction set environment that is identical to other members 
of the VAX family. 

The identical VAX Ada compiler is used on all hosts, and the 
compiler has no knowledge of the particular VAX model on which it is 
being executed. Further, the compiler generates identical code for 
all targets. Thus, the code generated on any VAX host can be 
executed without modification on any of the VAX targets listed 
above. 


All of the 
registration 
That is, all 
compiled and 


configurations listed under the derived 
section above are equivalent to the base confi 
applicable ACVC Version 1.10 tests could be 
executed on any of the configurations listed. 


compiler 
guration. 
correctly 



Bill KeatirTg 

Senior Group Manager 

Software Development Technologies 


15 February 1989 


4 





APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed itr. ple:r. entacion dependencies correspond to 
implementa t i on - dependent pragrras , to certain machine - dependent 
conventions as iventioned i;. chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the VAX Ada Version 2.0 
compiler, as described in this Appendix, are provided by Digital 
Equipment Corporation. Unless specifically noted otherwise, references 
in this appendix are to coinpiler documentation and not to this report. 
Implementation-spec ific portions of the package STANDARD, which are not 
a part of Appendix F, are: 

package ST.ANDARD is 


type INTEGER is range - 21-7483648..2147483647; 
type SH0RT_:::TEGER is range - 32T'oS .. 32768 ; 
type SH0RT_SH0RT_INTEGER is range -128..127; 

type FLOAT is digits 6 range -1.70141E+38..1.70141E+38; 
type L0NG_FL0.AT is digits 15 range 

-8.988465674312E+307. . 8.988465674312E-I-307 ; 
type L0NG_L0NG_FL0.AT is digits 33 range 

-5.9486574767861588254287966331400E4-4931. . 
5.9486574767861588254287966331400E-(-4931; 


type DUR.ATICN is delta l.OE-4 range -131072.0 .. 131071.9999 ; 


end ST.AN2.--..R1 : 


B-1 



APPENDIX B 


APPENDIX F OF THE ADA STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of ANSI/MIL-STD-1815A-1983, 
and to certain allowed restrictions on representation classes. The 
implementation-dependent characteristics are described in the 
following sections which discuss topics one through eight as stated 
in Appendix F of the Ada Language Reference manual 
(ANSI/MIL-STD-1815A). Two other sections, package STANDARD and file 
naming conventions, are also included in this appendix. 

Portions of this section refer to the following attachments: 

1. Attachment 1 - Implementation-Dependent Pragmas 

2. Attachment 2 - VAX Ada Appendix F 


( 1 ) 


Implementation-Dependent Pragmas 
See Attachment 2, Section F.l 


and Attachment 1. 


(2) Implementation-Dependent Attributes 


Name 

IZ£e 




P'AST_ENTRY 

The value of this attribute 
SYSTEM.AST_HANDLER. 

is 

of 

type 

P'BIT 

The value of this attribute 
universal_integer. 

i s 

of 

type 

P'MACHINE_SIZE 

The value of this attribute 
universal integer. 

i s 

of 

type 


B-1 







APPENDIX r OF THE ADA STANDARD 


P'NULL_PARAMETER The value of this attribute is of type 

P. 

P'TYPE_CLASS The value of this attribute is of type 

SYSTEM.TYPE CLASS. 


(3) Package SYSTEM 

See Attachment 2, Section F.3. 


(4) Representation Clause Restrictions 
See Attachment 2, Section F.4. 


( 5) Conventions 

See Attachment 2 , Section F.6. 


(6) Address Clauses 

See Attachment 2 , Section F.7. 


(7) Unchecked Conversions 

See Attachment 2, Section F.5. 


(8) Input-Output Packages 

SEQUENTIAL_IO Package 

SEQUENTIAL 10 can be instantiated with any file 
type, incTuding an unconstrained array type or an 
unconstrained record type. However, input-output 
for access types is erroneous. 

VAX Ada provides full support for SEQUENTIAL_IO, 
with the following restrictions and clarifications: 

1. VAX Ada supports modes IN_FILE and 0UT_FILE for 
sequential input-output. However, VAX Aca does 
not allow the creation of a file of mode 
IN FILE. 


B-2 


APPENDIX F OF THE ADA STANDARD 


2. More than one internal file can be associated 
with the same external file. However, with 
default FORM strings, this is only allowed when 
all internal files have mode IN_PZLE (multiple 
readers). If one or more internal files have 
mode OUT_FILE (mixed readers and writers or 
multiple writers), then sharing can only be 
achieved using FORM strings. 


3. VAX Ada supports deletion of an extern^ file 
which is associated with more than one internal 
file. In this case, the external file becomes 
immediately unavailable for any new 
associations, but the current associations are 
not affected; the external file is actually 
deleted after the last association has been 
broken. 


4. VAX Ada allows resetting of shared files, but an 
implementation restriction does not allow the 
mode of a file to be changed from IN_FILE to 
OUT_FILE (an amplification of accessing 

privileges while the external file is being 
accessed). 


DIRECT_IO Package 

type CNT is range 0 .. 2147483647; 

TEXT_IO Package 

type CNT is range 0 .. 2147483647; 

subtype FIELD is INTEGER range 0 .. 2147483647; 

LOW_LEVEL_IO 

Lcw-level input-output is not provided. 


B-3 







APPENDIX r OF THE ADA STANDARD 


(9) Package STANDARD 

type INTEGER is range -2147483648 .. 2147483647; 
type SHORT_INTEGER is range -32768 .. 32767; 
type SHORT_SHORT_lNTEGER is range -128 .. 127; 

— type LONG_INTEGER is not supported 

type FLOAT is digits 6; 

type LONG_FLOAT is digits 15; 

type LONG_LONG_FLOAT is digits 33; 

— type SHORT_FLOAT is not supported 

type DURATION is delta l.OE-4 

range -131072.0 .. 131071.9999; 


(10) File Names 

File names follow the conventions and restrictions of 
target operating system. 


the 


B-4 







ATTACHMENT 1 

Predefined Language Pragmas 


This annex defines the pragnnas LIST, PAGE, and OPTIMIZE, and 
summarizes the definitions given elsewhere of the remaining language- 
defined pragmas. 

The VAX Ada pragmas IDENT and TITLE are also defined in this annex. 
Pragma Meaning 

AST.ENTRY Takes the simple name of a single entry 

as the single argument; at most one 
AST.ENTRY pragma is allowed for any 
given entry. This pragma must be used 
in combination with the AST.ENTRY 
attribute, and is only allowed after the 
entry declaration and in the same task 
type specification or single task as the 
entry to which it applies. This pragma 
specifies that the given entry mav be 
used to handle a VMS as\Tichronous 
system trap (.AST) resulting from a \T\1S 
system ser\-ice call. The pragma does 
not affect normal u.'-e of the entrv (see 
9.12a). 

CONTROLLED Takes the simple name of an access tj'pe 

as the single argument. This pragma 
is only allowed immediately within the 
declarative part or package specification 
that contains the declaration of the 
access t)’pe; the declaration must occur 
before the pragma. This pragma is 


Predefined Language Pragmas 1-1 


3 ELABORATE 


EXPORT. EXCEPTION 


not allowed for a derived type. This 
pragma specifies that automatic storage 
reclamation must not be performed 
for objects designated by values of the 
access type, except upon leaving the 
innermost block statement, subprogram 
body, or task body that encloses the 
access tjrpe declaration, or after leaving 
the main program (see 4.8). 

Takes one or more simple names 
denoting library units as arguments. This 
pragma is only allowed immediately 
after the context clause of a compilation 
unit (before the subsequent library unit 
or secondary unit). Each argument must 
be the simple name of a library unit 
mentioned by the context clause. This 
pragma specifies that the corresponding 
library unit body must be elaborated 
before the given compilation unit. If the 
given compilation unit is a subunit, the 
library unit body must be elaborated 
before the body of the ancestor library 
unit of the subunit (see 10.5). 

Takes an internal name denoting an 
exception, and optionally takes an 
external designator (the name of a VMS 
Linker global symbol), a form (ADA 
or VMS), and a code (a static integer 
expression that is interpreted as a VAX 
condition code) as arguments. A code 
value must be specified when the form 
is VMS (the default if the form is not 
specified). This pragma is only allowed 
at the place of a declarative item, and 
must apply to an exception declared bv 
an earlier declarative item of the same 
declarative part or package specification; 
it is not allowed for an exception 
declared with a renaming declaration. 
This pragma permits an Ada exception 
to be handled by programs wriben in 
other VAX languages (see 13.9a.3.2). 


1-2 Predefined Language Pragmas 





EXPORT. FUNCTION 


EXPORT.OBJECT 


Takes an internal name denoting a 
function, and optionally takes an external 
designator (the name of a VMS Linker 
global symbol), parameter types, and 
result type as arguments. This pragma is 
only allowed at the place of a declarative 
item, and must apply to a function 
declared by an earlier declarative item 
of the same declarative part or package 
specification. In the case of a function 
declared as a compilation unit, the 
pragma is only allowed after the function 
declaration and before any subsequent 
compilation unit. This pragma is not 
allowed for a function declared with a 
renaming declaration, and is not allowed 
for a generic function (it may be given 
for a generic instantiation). This pragma 
permits an Ada function to be called 
from a program written in another VAX 
language (see 13.9a.1.4). 

Takes an internal name denoting an 
object, and optionally takes an external 
designator (the name of a VMS Linker 
global symbol) and size designator (a 
VMS Linker global symbol whose value 
is the size in bytes of the exported 
object) as arguments. This pragma is 
only allowed at the place of a declarative 
item at the outermost level of a library 
package specification or body, and 
must apply to a variable declared by 
an earlier declarative item of the same 
package specification or body; the 
variable must be of a type or subtype 
that has a constant size at compile time 
This pragma is not allowed for objects 
declared with a renaming declaration, 
and is not allowed in a generic unit. 

This pragma permits an Ada object to 
be referred to by a routine written in 
another VAX language (see 13.9a.2.2). 


Predefined Language Pragmas 1-3 



EXPORT.PROCEDURE 


Takes an internal name denoting a 
procedure, and optionally takes an 
external designator (the name of a VMS 
Linker global symbol) and parameter 
types as arguments. This pragma is only 
allowed at the place of a declarative 
item, and must apply to a procedure 
declared by an earlier declarative 
item of the same declarative part or 
package specification. In the case of 
a procedure declared as a compilation 
unit, the pragma is only allowed after 
the procedure declaration and before 
any subsequent compilation unit. This 
pragma is not allowed for a procedure 
declared with a renaming declaration, 
and is not allowed for a generic 
procedure (it may be given for a generic 
instantiation). This pragma permits an 
Ada routine to be called from a program 
written in another VAX language (see 
13.9a.l.4). 

EXPORT_VALUED_PROCEDURE Takes an internal name denoting a 

procedure, and optionally takes an 
external designator (the name of a VMS 
Linker global symbol) and parameter 
types as arguments. This pragma is only 
allowed at the place of a declarative 
item, and must apply to a procedure 
declared by an earlier declarative 
item of the same declarative part or 
package specification. In the case ot 
a procedure declared as a compilation 
unit, the pragma is only allowed alter 
the procedure declaration and before 
any subsequent compilation unit. The 
first (or only) parameter of the procedure 
must be of mode out. This pragma is not 
allowed for a procedure declared with a 
renaming declaration and is not allowed 
for a generic procedure (it may be given 
for a generic instantiation). This pr .gma 
permits an Ada procedure to behave as 


1-4 


Predefined Language Pragmas 









IDENT 


IMPORT, 


IMPORT 


a function that both returns a value and 
causes side effects on its parameters 
when it is called from a routine written 
in another VAX language (see 13.9a. 1.4). 

Takes a string literal of 31 or fewer 
characters as the single argument. The 
pragma IDENT has the following form: 

pri^ak IDENT (•trlng.lltaral); 

This pragma is allowed only in the 
outermost declarative part or declarative 
items of a compilation unit. The ■’iven 
string is used to identify the object 
module associated with the compilation 
unit in which the pragma IDENT occurs. 

EXCEPTION Takes an internal name denoting an 

exception, and optionally takes an 
external designator (the name of a 
VMS Linker global symbol), a form 
(ADA or VMS), and a code (a static 
integer expression that is interpreted as 
a VAX condition code) as arguments. 

A code value is allowed only when the 
form is VMS (the default if the form 
is not specified). This pragma is only 
allowed at the place of a declarative 
item, and must apply to an exception 
declared by an earlier declarative item 
of the same declarative part or package 
specification; it is not allowed for an 
exception declared with a renaming 
declaration. This pragma permits a 
non-Ada exception (most notably, a VAX 
condition) to be handled by an Ada 
program (see 13.9a.3.1). 

FUNCTION Takes an internal name denoting a 

function, and optionally takes an external 
designator (the name of a VMS Linker 
global symbol), parameter types, result 
tv'pe, and mechanism as arguments. The 
pragma INTERFACE must be used with 
this pragma (see 13.9). This pragma is 


Predefined Language Pragmas 1-5 




IMPORT.OBJECT 


IMPORT_PROCEDURE 


only allowed at the place of a declarative 
item, and must apply to a function 
declared by an earlier declarative item 
of the same declarative part or package 
specification. In the case of a function 
declared as a compilation unit, the 
pragma is only allowed after the function 
declaration and before any subsequent 
compilation unit. This pragma is allowed 
for a function declared with a renaming 
declaration; it is not allowed for a 
generic function or a generic function 
instantiation. This pragma permits a 
non-Ada routine to be used as an Ada 
function (see 13.9a.1.1). 

Takes an internal name denoting an 
object, and optionally takes an external 
designator (the name of a VMS Linker 
global symbol) and size (a VMS Linker 
global symbol whose value is the size 
in bytes of the imported object) as 
arguments. This pragma is only allowed 
at the place of a declarative item at the 
outermost level of a library package 
specification or body, and must apply 
to a variable declared by an earlier 
declarative item of the same package 
specification or body; the variable 
must be of a type or subtype that has 
a constant size at compile time. This 
pragma is not allowed for objects 
declared with a renaming declaration, 
and is not allowed in a generic unit. This 
pragma permits storage declared in a 
non-Ada routine to be referred to by an 
.Ada program (see 13.9a.2.1). 

Takes an internal name denoting a 
procedure, and optionally takes an 
external designator (the name of a 
VMS Linker global symbol) parameter 
types, and mechanism as arguments. 

The pragma LNTERFACE must be 
used with this pragma (see 13.9). This 


-6 


Predefined Language Pragmas 



pragma is only allowed at the place 
of a declarative item, and must apply 
to a procedure declared by an earlier 
declarative item of the same declarative 
part or package specification. In the case 
of a procedure declared as a compilation 
unit, the pragma is only allowed after 
the procedure declaration and before 
any subsequent compilation unit. This 
pragma is allowed for a procedure 
declared with a renaming declaration; it 
is not allowed for a generic procedure 
or a generic procedure instantiation. 

This pragma permits a non-Ada routine 
to be used as an Ada procedure (see 
I3.9a.l.l). 

IMPORT_VALUED_PROCEDURE Takes an internal name denoting a 

procedure, and optionally takes an 
external designator (the name of a 
VMS Linker global symbol), parameter 
types, and mechanism as arguments. 

The pragma INTERFACE must be 
used with this pragma (see 13.9). This 
pragma is only allowed at the place 
of a declarative item, and must apply 
to a procedure declared oy an earlier 
declarative item of the same declarative 
part or package specification. In the case 
of a procedure declared as a compilation 
unit, the pragma is only allowed after 
the procedure declaration and before 
any subsequent compilation unit. The 
first (or only) parameter of the procedure 
must be of mode out. This pragma 
is allowed for a procedure declared 
with a renaming declaration; it is not 
allowed for a generic procedure. This 
pragma permits a non-Ada routine that 
returns a value and causes side effects 
on its parameters to be used as an Ada 
procedure (see 13.9a.1.1). 

4 I.NLINE Takes one or more names as arguments; 

each name is either the name of a 


Preaefined Language Pragmas 1-7 


INLINE. GENERIC 


INTERFACE 


subprogram or the name of a generic 
subprogram. This pragiira is only 
allowed at the place of a declarative 
item in a declarative part or package 
specificahon, or after a library unit in a 
compilation, but before any subsequent 
compilation unit. This pragma specifies 
that the subprogram bodies should be 
expanded inline at each call whenever 
possible; in the case of a generic 
subprogram, the pragma applies to calls 
of its instantiations (see 6.3.2). 

Takes one or more names as arguments; 
each name is either the name of a 
generic declaration or the name of an 
instance of a generic declaration. This 
pragma is only allowed at the place 
of a declarative item in a declarative 
part or package specification, or after a 
library unit in a compilation, but before 
any subsequent compilation unit. Each 
argument must be the simple name of 
a generic subprogram or package, or a 
(nongeneric) subprogram or package, 
declared by an earlier declarative item 
of the same declarative part or package 
specification. Tlus pragma specifies that 
inline expansion of the generic template 
is desired for each instantiation of the 
named generic declarations or of the 
particular named instances; the pragma 
does not apply to calls of instances of 
generic subprograms (see 12.1a). 

Takes a language name and a 
subprogram name as arguments. This 
pragma is allowed at the piace of a 
declarative item, and must apply in 
this case to a subprogram declared by 
an earlier declarative item of the same 
declarative part or package specification. 
This pragma is also allowed for a library 
unit; in this case the pragma must appear 
after the subprogram declaration, and 


1-8 Predefined Language Pragmas 




UST 


LONG. 


MAIN 


before any subsequent compilation unit. 
This pragma specifies the other language 
(and thereby the calling conventions) 
and informs the compiler that an 
object module will be supplied for the 
corresponding subprogram (see 13.9). 

In VAX Ada, the pragma INTERFACE 
is required in combination with the 
pragmas IMPORT_FUNCTION, 
IMPORT.PROCEDURE, and IMPORT. 
VALUED.PROCEDURE when any of 
those pragmas are used (see 13.9a.1). 

T^dces one of the identifiers ON or OFF 
as the single argument. This pragma is 
allowed anywhere a pragma is allowed. 

It specifies that listing of the compilation 
is to be continued or suspended until a 
LIST pragma with the opposite argument 
is given within the same compilation. 
The pragma itself is always listed if the 
compiler is producing a listing. 

.FLOAT Takes either D.FLOAT or C.FLOAT 

as the single argument. The default is 
G_FLOAT. This pragma is only allowed 
at the start of a compilation, before 
the first compilation unit (if any) of 
the compilation. It specifies the choice 
of representation to be used for the 
predefined tv'pe LONG.FLOAT in the 
package STAND.ARD, and for floating 
point U'pe declarations with digits 
specified in the range 7..15 (see 3.5.7a). 

STOR.AGE Takes one or two nonnegative static 

simple expressions of some integer 
type as arguments. This pragma is only 
allowed in the outermost declarative 
part of a library subprogram; at most 
one such pragma is allowed in a library 
subprogram. It has an effect only when 
the subprogram to which it applies is 
used as a main program. This pragma 
causes a fixed-size stack to be created 


Predefined Language Pragmas 1-9 



MEMORY 


8 OPTIMIZE 


9 PACK 


for a main task (the task associated with 
a main program), and determines the 
number of storage units (bytes) to be 
allocated for the stack working storage 
area or guard pages or both. The value 
specified for either or both the working 
storage area and guard pages is rounded 
up to an integral number of pages. A 
value of zero for the working storage 
area results in the use of a default size; a 
value of zero for the guard pages results 
in no guard storage. A negative value for 
either working storage or guard pages 
causes the pragma to be ignored (see 
13.2b). 

SIZE Takes a numeric literal as the single 

argument. This pragma is only allowed 
at the start of a compilation, before 
the first compilation unit (if any) of the 
compilation. The effect of this pragma is 
to use the value of the specified numeric 
literal for the definition of the named 
number MEMORY.SIZE (see 13.7). 

Takes one of the identifiers TIME 
or SPACE as the single argument. 

This pragma is only allowed within a 
declarative part and it applies to the 
block or body enclosing the declarative 
part. It specifies whether time or space 
is the primar\' optimization criterion. 

In VAX Ada, this pragma is only allowed 
immediately with)' a dc. larative part of 
a body declaration 

Takes the simple name of a record or 
array tj'pe as the single argument. The 
allowed positions for this pragma, and 
the restrictions on the named type, 
are governed by the same rules as for 
a representation clause. The pragma 
specifies that storage minimization 
should be the main criterion when 


1-10 Predefined Language Pragmas 



-0 PAGE 


n PRIORITY 


PSECT.OBJECT 


12 SHARED 


selecting the representation of the given 
type (see 13.1). 

This pragma has no argument, and is 
allowed anywhere a pragma is allowed. 

It specifies that the program text which 
follows the pragma should start on a 
new page (if the compiler is currently 
producing a listing). 

Takes a static expression of the 
predefined integer subtype PRIORITY as 
the single argument. This pragma is only 
allowed within the specification of a task 
unit or immediately within the outermost 
declarative part of a main program. It 
specifies the priority of the task (or tasks 
of the task type) or the priority of the 
main program (see 9.8). 

Takes an internal name denoting an 
object, and optionally takes an external 
designator (the name of a program 
section) and a size (a VMS Linker global 
symbol whose value is interpreted as the 
size in bytes of the exported/imported 
object) as arguments. This pragma is 
only allowed at the place of a declarative 
item at the outermost level of a library 
package specification or body, and must 
apply to a variable declared by an earlier 
declarative item of the same package 
specification or body; the variable 
must be of a U-pe or subtype that has 
a constant size at compile time. This 
pragma is not allowed for an object 
declared with a renaming declaration, 
and is not allowed in a generic unit. This 
pragma enables the shared use of objects 
that are stored in overlaid program 
sections (see 13.9a.2.3). 

Takes the simple name of a variable as 
the single argument. This pragma is 
allowed only for a variable declared by 
an object declaration and whose tj’pe 


Predefined Language Pragmas 1-11 



SHARE.GENERIC 


•3 STORAGE.UNIT 


is a scalar or access type; the variable 
declaration and the pragma must both 
occur (in this order) immediately within 
the same declarative part or package 
specification. This pragma specifies that 
every read or update of the variable 
is a synchronization point for that 
variable. An implementation must 
restrict the objects for which this pragma 
is allowed to objects for which each of 
direct reading and direct updating is 
implemented as an indivisible operation 
(see 9.11). 

Takes one or more names as arguments; 
each name is either the name of a 
generic declaration or the name of an 
instance of a generic declaration. This 
pragma is only allowed at the place 
of a declarative item in a declarative 
part or package specification, or after a 
librar/ unit in a compilation, but before 
any subsequent compilation unit. Each 
argument must be the simple name of 
a generic subprogram or package, or a 
(nongeneric) subprogram or package, 
declared by an earlier declarative item 
of the same declarative part or package 
specification. Tliis pragma specifies 
that generic code sharing is desired for 
each instantiation of the named generic 
declarations or of the particular named 
instances (see 12.1b). 

Takes a numeric literal as the single 
argument. This pragma is only allowed 
at the start of a compilation, before 
the first compilation unit (if any) of the 
compilation. The effect of this pragma is 
to use the value of the specified numeric 
literal for the definition of the named 
number STORAGE.UNIT (see 13.7). 

In VAX Ada. the only argument allowed 
for this pragma is 8 ^its). 


1-12 Predefined Language Pragmas 



.4 SUPPRESS 


SUPPRESS.ALL 


15 SYSTEM.NAME 


Takes as arguments the identifier of a 
check and optionally also the name of 
either an object, a type or subtype, a 
subprogram, a task unit, or a generic 
unit. This pragma is only allowed 
either immediately ivithin a declarative 
part or immediately within a package 
specification. In the latter case, the 
only allowed form is with a name that 
denotes an entity (or several overloaded 
subprograms) declared immediately 
within the package specification. The 
permission to omit the given check 
extends from the place of the pragma 
to the end of the declarative region 
associated with the inivermost enclosing 
block statement or program unit. For a 
pragma given in a package specification, 
the permission extends to the end of the 
scope of the named entity. 

If the pragma includes a name, the 
permission to omit the given check is 
further restricted: it is given only for 
operations on the named object or on 
all objects of the base type of a named 
type or subtype; for calls of a named 
subprogram; for activations of tasks of 
the named task tj^e; or for instantiations 
of the given generic unit (see 11.7). 

This pragma has no argument and is 
only allowed follov\ing a compilation 
unit. This pragma specifies that all run¬ 
time checks in the unit are suppressed 
(see 11.7). 

Takes an enumeration literal as the single 
argument. This pragma is only allowed 
at the start of a compilation, before 
the first compilation unit (if any) of the 
compilation. The effect of this pragma 
is to use the enumeration literal with 
the specified identifier for the definition 
of the constant SYSTEM_NAME. This 


PreOetmed Language Pragmas 1-13 




pragma is only allowed if the specified 
identifier corresponds to one of the 
literals of the type NAME declared in the 
package SYSTEM (see 13.7). 

TASK_STORAGE Takes the simple name of a task t3T3e 

and a static expression of some integer 
type as arguments. This pragma is 
allowed anywhere that a task storage 
specification is allowed; that is, the 
declaration of the task type to which the 
pragma applies and the pragma must 
both occur (in this order) immediately 
within the same declarative part, package 
specification, or task specification. The 
effect of this pragma is to use the value 
of the expression as the number of 
storage units (bytes) to be allocated as 
guard storage. The value is rounded up 
to an integral number of pages; a value 
of zero results in no guard storage; a 
negative value causes the pragma to be 
ignored (see 13.2a). 

TIME.SLICE Takes a static expression of the 

predefined fixed point type DURATION 
(in package STANDARD) as the single 
argument. This pragma is only allowed 
in the outermost declarative part of a 
library subprogram, and at most one 
such pragma is allowed in a library 
subprogram. It has an effect only when 
the subprogram to which it applies is 
used as a main program. This pragma 
specifies the nominal amount of elapsed 
time permitted for the execution of a task 
when other tasks of the same priority are 
also eligible for execution. A positive, 
nonzero value of the static expression 
enables round-robin scheduling for all 
tasks in the subprogram; a negative or 
zero value disables it (see 9.8a). 


1-14 Predefined Language Pragmas 





TITLE 


Takes a title or a subtitle string, or both, 
in either order, as arguments. The 
pragma TITLE has the following form; 

pragBk TITLE (tltllng-optlon 
[,tltllng-optlon]); 

tltllng-optlon :» 

[TITLE •>] •trlng_llt*ral 
I [SUBTITLE ■>] itring.lltaral 

This pragma is allowed anywhere a 
pragma is allowed; the given strings 
supersede the default title and/or subtitle 
portions of a compilation listing. 

VOLATILE Takes the simple name of a variable 

as the single argument. This pragma 
is only allowed for a variable declared 
by an object declaration. The variable 
declaration and the pragma must both 
occur (in this order) immediately within 
the same declarative part or package 
specification. The pragma must appear 
before any occurrence of the name of the 
variable other than in an address clause 
or in one of the VAX Ada pragmas 
IMPORT.OBJECT, EXPORT.OBJECT, 
or PSECT.OBJECT. The variable cannot 
be declared by a renaming declaration. 
The pragma VOLATILE specifies 
that the variable may be modified 
asynchronously. This pragma instructs 
the compiler to obtain the value of a 
variable from memory each time it is 
used 'see 9 11). 


Predefined Language Pragmas 1-15 




ATTACHMENT 2 


Implementation-Dependent Characteristics 


NOTE 

This appendix is not part of the standard definition of the Ada 
programming language. 

This appendix summarizes the implementation-dependent characteristics of 

VAX Ada by presenting the following: 

• Lists of the VAX Ada pragmas and attributes. 

• The specification of the package SYSTEM. 

• The restrictions on representation clauses and unchecked type 
conversions. 

• The conventions for names denoting implementation-dependent 
components in record representation clauses. 

• The interpretation of expressions in address clauses. 

• The implementation-dependent characteristics of the input-output 
packages. 

• Other implementation-dependent characteristics. 


F.1 Implementation-Dependent Pragmas 

VAX Ada provides the following pragmas, which are defined elsewhere in 
the text. In addition, VAX .Ada restricts the predefined language pragmas 
INLINE and INTERFACE, and provides alternatives to the pragmas SHARFD 
and SUPPRESS (VOLATILE and SUPPRESS.ALL). See Annex B for a 
descriptive pragma summaiy. 

• AST.ENTRY (see 9.12a). 

• EXPORT.EXCEPTION (see 13.«a.3.:) 


Imoiementanon-Oeoendent Characteristics 2-1 




• EXPORT.FUNCTION (see 13.9a. 1.4). 

• EXrORT.OBJECT (see 13.9a.2.2). 

• EXPORT.PROCEDURE (see 13.9a.1.4). 

• EXPORT_VALUED_PROCEDURE (see 13.9a.1.4). 

• IDENT (see Annex B). 

• IMPORT.EXCEPTION (see 13.9a.3.1). 

• IMPORT.FUNCTION (see 13.9a.l.l). 

• IMPORT.OBJECT (see I3.9a.2.1). 

• IMPORT.PROCEDURE (see 13.9a.1.1). 

• IMPORT.VALUED.PROCEDURE (see 13.9a.l.l). 

• INLINE.GENERIC (see 12.1a). 

• LONG.FLOAT (see 3.5.7a). 

• MAIN.STORAGE (see 13.2b). 

• PSECT.OBJECT (see 13.9a.2.3). 

• SUPPRESS.ALL (see 11.7). 

• TASK.STORAGE (see 13.2a). 

• TIME.SLICE (see 9.8a). 

• TITLE (see Annex B). 

• VOLATILE (see 9.11). 


F.2 Implementation-Dependent Attributes 

\'AX .Ada provides the following attributes, which are defined elsewhere in 
the text. See .Arnex A for a descriptive attribute summary. 

• AST.ENTRY (see 9.12a). 

• BIT (see 13.7.2). 

• MACHINE.SIZE (see 13.7 2). 

• \ULL_PARAMETER (see 13.^a 1.3) 

• TA PE.CLASS (see 13.7a.2). 


2-2 impiementation-DeDenOent Characteristics 










F.3 Specification of the Package System 


p«ck»g« SYSTEM II 

typi NAME li (VAX.VMS, VAXELN), 


eo&ltint NAME - VAX.^iTtS 
eonstint 


SYSTEM.NAME 

STORACE.UNIT 

MEMORY.SIZE 

MAX.INT 

MIN.INT 

MAX.DIGITS 

MAX.MANTISSA 

FINE.DELTA 

TICK 


conitint 
conitint • 
eottitint > 
conitint - 
conitint 
conitint : - 
conitint 


8 . 

2*»31-1. 

-(2*«31). 
33. 

31: 

2 0»»(-31)i 

10 o»»(- 2 ); 


lubtypi PRIORITY li INTEGER ring* 0 .. ISj 
-- Addresi typi 


typi ADDRESS li print!; 
ADDRESS.ZERO : conitint ADDRESS; 


function (LEFT 
function (LEFT 
function aEFT 
function (LEFT 


ADDRESS; RIGHT 
INTEGER; RIGHT 
ADDRESS; RIGHT 
ADDRESS; RIGHT 


INTEGER) riturn ADDRESS 
: ADDRESS) ritum ADDRESS 
ADDRESS) ritum INTEGER 
: INTEGER) ritum ADDRESS 


.. function 

H^H 

(LEFT. 

RIGHT 

function 

"/*" 

(LEFT, 

RIGHT 

function 

i« ^ n 

(LEFT. 

RIGHT 

function 

!.<*.. 

(LEFT. 

RIGHT 

function 

II y It 

(LEFT, 

RIGHT 

function 

">»” 

(LEFT. 

RIGHT 


ADDRESS) ritum BOOLEAN 
ADDRESS) ritum BOOLEAN 
ADDRESS) ritum BOOLEAN 
ADDRESS) ritum BOOLEAN 
ADDRESS) ritum BOOLEAN 
ADDRESS) ritum BOOLEAN 


Note that because ADDRESS is a private type 
the functions and "/*" are already available and 
-- do not have tc be explicitly defined 

generic 

type TARGET ii private; 

function FETCH.rRO?<_ADDRESS (A ADDRESS) return TARGET. 


generic 

type TARGET is private, 

procedure ASSIGN_TO_ADDRESS (A ADDRESS; T TARGET); 

VAX Ada floating point type declarations for the VAX 
hardware floating point data types 

typi F.FLOAT is tmpIrmintatii'n^definr.H, 
type D.FLOAT is impl'mfntnii 'n^d'fxnni. 
type G.FLOAT is implemfntiiti”n_d'firird. 
type H.FLOAT is implfm'ritatt''n^drfirird. 


(mpipmentation-Dependent Characteristics 


2-3 








typ« TYPE.CUSS la (TYPE.CUSS.EtrUMERATION. 

TYPE_CUSS_nrrECER, 

TYPE_CLASS.FIXED_POIMT. 

TYPE.CLASS_FLOATItlG_POIMT. 

TYPE_CLASS_ARRAY. 

TYPE_CLASS_RECORD. 

TYPE.CUSS.ACCESS. 

TYPE.CLASS.TASK. 

TYPE.CUSS.ADDRESS) ; 

-- AST handlar typa 

typa AST.HANDLER la llaltad prlTata, 

NQ.AST.HAUDLER : conatant AST.HANDLER, 

Non-Ada axcaption 

NQN_ADA_ERROR : axcaption; 

VAX hardvara-orlented typaa and Tunctiona 

typa BIT.ARRAY la array (INTEGER raaga <>) of BOOLEAN, 
pragaa PACK(BIT.ARRAY); 

aubtypa BIT.ARRAY.a la BIT.ARRAY (0 7). 

aubtypa BIT.ARRAY.ie la BIT.ARRAY (0 16); 

aubtypa BIT_ARRAY.32 la BIT.ARRAY (0 31); 

aubtypa BIT_ARRAY.64 la BIT.ARRAY (0 . 63); 

^ypa UNSIGNED.BYTE la ranga 0 .. 266; 
for UNSIGNED.BYTE'SIZE uaa 8; 

function "not" (LEFT : UNSIGNED.BYTE) ratum UNSIGNED.BYTE; 

function "and" (LEFT. RIGHT UNSIGNED.BYTE) return UNSIGNED.BYTE; 

function "or" (LEFT. RIGHT : UNSIGNED.BYTE) ratum UNSIGNED.BYTE. 

function "xor" (LEFT, RIGHT ; UNSIGNED.BYTE) ratum UNSIGNED.BYTE, 

function TO.UNSIGNED.BYTE (X : BIT.ARRAY.B) ratum UNSIGNED.BYTE; 
function TO.BIT.ARRAY.a (X UNSIGNED.BYTE) return BIT.AR.RAY.S, 

typa UHSIGNED.EYTE.ARRAY la array (INTEGER range <>) of 'UNSIGNED.BYTE, 

typa UNSIGNED.vrORD la range 0 66535, 

for UNSIGHEDjaORD'SIZE uaa 16. 


function 

"not ” 

(LEFT 


UNSIGNED.’KORD) 

return 

'Ut.’SIGt.'ED, 

.WORD 

function 

"tnd" 

(LEFT, 

RIGHT 

UNSICNED.'ACRD) 

ratum 

'JNSIGN'ED. 

.WORD 

function 

"cr" 

(LEFT, 

RIGHT 

UNSIGNED.WORD) 

ratum 

UNSIGNED, 

.WORD 

function 

"xor" 

(LEFT, 

RIGHT 

UNSIGNED.WORD) 

ratum 

UNSIGNED, 

.WORD 


function TO.UNSIGNED.WDRD (X BIT.ARRAY.16) return UNSIGNEDjaORD; 
function TO.BIT.ARRAY.ie (X UNSIGNED.WORD) ratum BIT.ARRAY.16. 


typa UNSIGNED.'jTORD.ARRAY la array (INTEGER ranga <>) of UNSICNED.'AORD, 

typo UNSIGNED.LONG'jrORD la ranga HIH.INT MAX.INT, 
for UNSIGNED.LONGWORO’SIZE uaa 32. 


2-4 ImDiementaiion-Dec^nclent Characteristics 











function "not" (LEFT UHSIGtJED.LOMGWORD) roturn UNSIGNED.LONGWORD 

function "and" (LE"". RIGHT UNSICKED.LOtJGWORD) roturn UNSIGNED.LONCWORD 

function "or" (LEFT, RIGHT UNSIGHED_LOMGWORD) roturn UNSIGNED.LONGWORD 

function "xor" (LEFT. RIGHT : UNSIGNED.LOHGWORD) rtturn UMSIGNED.LONGWORD 

function TC.UNSIGNED.LQNG'JfORD (X BIT_ARRAY_32) 
raturn UNSIGNED.LOHCWORD; 

function T0_BIT_ARRAY_32 (X : UNSIGHED.LONGWORD) roturn BIT_ARRAY_3:; 

typ* UNSIGHED.LOHGWORD.ARRAY la 

array (INTEGER ranga <>) of UHSIGNED.LONGWORD; 

typa UNSIGHED.QUAOWORD la racord 
LO UNSIGNED.LONGWQRD; 

LI UNSICNED.LQNCWORD; 

and racord; 

for UNSIGNED.OUADWORD'SIZE uaa 84; 

function "not" (LEFT : UNSlGHED.QUADaORD) ratum UNSIGNED.QUADWORD 

function "and" (LEFT. RIGHT : UNSIGNED.QUADWORD) ratum UNSIGNED.QUADWORD 

function "or" (LEFT. RIGHT UNSTGHED.QUADWORD) ratum UNSIGNED.QUADWORD 

function "xor" (LEFT. RIGHT UNSIGNED.QUADWORD) ratum UNSIGNED.QUADWORD 

function TO.UNSIGNED.OUADWORD (X BIT.ARRAY.64) 
ratum UNSIGNED.QUADWORD; 

function TO.BIT.ARRAY.e-; (X . UNSIGNED.QUADWORD) ratum BIT.ARRAY.BA, 

typa UNSIGNED.QUADWORD.ARRAY la 

array (INTEGER ranga <>) of UNSIGNED.QUADWORD. 

function TO.ADDRESS (X : INTEGER) ratum ADDRESS, 

function TO.ADDRESS (X UNSIGNED.LOHCWORD) ratum ADDRESS; 

function TO.ADDRESS (X : untversal^mleger) ratum ADDRESS; 

function TO.INTEGER (X ; ADDRESS) ratum INTEGER; 

function TO.UNSIGNED.LONGWORO (X : ADDRESS) ratum UNSIGHED.LONGWORD; 

function TO.UNSIGNED.LONGWORD (X AST.HANDLER) return UNSIGNED.LONGWORD; 

Conventional names for static subtypes of type UNSIGNED.LONGWORD 


subtype 

UNSIGNED.! 

la 

UNSIGNED. 

LONGWORD 

range 

0 

2*" 

1-1 , 

subtype UNSIGNED.2 

la 

UNSIGNED. 

LONGWORD 

ranga 

0 , 

2«* 

2-1 , 

subtype 

UN 0 X G Nc.D _3 

Is 

UNSIGNED. 

LONGWORD 

range 

0 

2** 

3 -1 ' 

subtype 

UNSIGNED.4 

is 

UNSIGNED. 

LONGWORD 

range 

0 

2«. 

4-1 . 

subtype 

UN 5 X GNc.D .5 

is 

UNSIGNED. 

LONGWORD 

range 

0 

2** 

S - 1 , 

subtype 

UNSIGNED.6 

Is 

UNSIGNED. 

LONGWORD 

range 

0 

2*. 

5 - > 

subtype 

UNSIGNED.? 

Is 

UNSIGNED. 

LONGWORD 

range 

0 

2-. 

7- 1 . 

subtype UNSIGHED.B 

la 

UNSIGNED. 

LONGWORD 

range 

0 

2»* 

8-1 . 

subtype 

UNSIGNED.9 

Is 

UNSIGNED. 

LONGWORD 

range 

0 

2** 

9-1 . 

subtype UNSIGNED.IC 

la 

UNSIGNED. 

LONGWORD 

range 

0 

2.. 

10-1 ; 

subtype UNSIGHED.ll 

is 

UNSIGNED. 

LONGWORD 

range 

0 

2** 

11-1. 

subtype 

UNSIGNED.12 

is 

UNSIGNED. 

LONGWORD 

range 

0 

2"" 

12-1 , 

subtype 

UNSIGNED.13 

la 

UNSIGNED. 

LONGWORD 

range 

0 

2.. 

13-1 . 

subtype UNSIGNED.14 

la 

UNSIGNED. 

LONGWORD 

range 

0 

2"* 

14-1 , 

subtype 

UNSIGNED.16 

la 

UNSIGNED. 

LONGWORD 

range 

0 

2.. 

16-1 . 


impiemertanor'-DeDendent Chafaciensucs 2-5 













•Ubtjp* UNSICNED.ie ll UNSIGHED.LONCWORD rftAg* 0 2«»16-l, 

•Ubtyp« UNSIGNED.!? It UNSIGNED.LONGWORD rtngt 0 2«»17-1, 

iUbtypt UNSIGNED.IS It UNSIGNED.LQNGWQRD rtngt 0 2««18-l; 

iubtypt UNSIGNED.IO It UNSIGNED.LONGWORD rtngt 0 2«»19-1; 

tubtypt UNSIGHED_20 It UHSIGNED.LQNGbORD rtngt 0 . 2»*20-l: 

tubtypt UNSIGNED_21 It UNSIGNED.LONGWORD rtngt 0 2«»21-1; 

IUbtypt UNSICNED_22 it UNSIGHED.LONGWORD rtngt 0 2»«22-l, 

IUbtypt UNSIGNED_23 It UNSIGHED.LOHGWORD rtngt 0 .. 2**23-l: 

IUbtypt UNSIGHED_24 It UNSIGNED.LOHGWORD rtngt 0 .. 2««24-l: 

tubtypt UNSIGNED.26 ll UNSIGNED.LOHGWORD rtngt 0 .. 2**25-l: 

IUbtypt UNSIGHED.26 ll UHSIGHED.LOHCWQRD rtngt 0 .. 2«*2e-l; 

IUbtypt UNSIGNED.27 It UNSIGNED.LOHGWORD rtngt 0 .. 2*»27-l; 

IUbtypt UNSIGHED.28 It UNSIGNEO.LONGWORD rtngt 0 .. 2**28-l: 

IUbtypt UNSIGNED.29 li UNSIGNED.LOHGWORD rtngt 0 .. 2«*29-!; 

IUbtypt UNSIGHED.30 It UNSIGHED.LOHGWORD rtngt 0 .. 2>*30-!; 

IUbtypt UHSIGNE0.31 li UNSIGNED.LOHGWORD rtngt 0 .. 2>*31-1. 

-- Function iar obtaining global ayabol Ttluea 

function IMPORT.VALUE (SYMBOL : STRING) rttum UNSIGNED.LOHGWORD, 

-- VAX device and proceae register operations 

function READ.REGISTER (SOURCE : UNSIGNED.BYTE) return UNSIGNED.BYTE; 

function READ.REGISTER (SOURCE : UNSIGNED.WORD) return UNSICNED.WORD; 

function READ.REGISTER (SOURCE : UNSIGHED.LOHGWORD) return UIJSIGIIED.LOHGWORD 

procedure WRITE_REGISTER(SOURCE : UNSIGNED.BYTE; 

TARGET : out UNSIGNED.BYTE); 
procedure WRITE.RECISTER(SOURCE . UHSICWED.WORD; 

TARGET : out UNSIGNED.WORD); 
procedure WRITE.REGISTER(SOURCE : UNSIGNED.LOHGWORD; 

TARGET : out UNSIGNED.LONGWDRD); 

function MFPR (REG.NUNBER : INTEGER) return UNSIGNED.LOHGWORD, 
procedure MTPR (REG.NUMBER : INTEGER; 

SOURCE : UNSIGHED.LOHCWCRD), 

\'AX Interloc.'^ed-instruction procedures 

procedure CLEAR.INTERLOCKED (BIT 

OLD.VALUE 

procedure SET.INTERLOCKED (BIT 

OLD.VALUE 

type ALIGNED.WORD Is 

record 

VALUE : SHORT.INTEGER, 

•nd record, 
for ALICNED.WORD use 
record 

at mod 2; 
and record, 

procedure ADD.INTERLOCKED (ADDEND . In SHORT.INTEGER. 

AUGEND In out ALICNED.WORD, 

SIGN out INTEGERr 


In out BOOLEAN, 
out BOOLEAN). 
in out soolea:;, 
out boolean;, 


2-6 ImDiementation-Dependent Coaractensiics 










typ* INSQ.STATUS !■ (OK_NQT_FIRST. FAIL.NO.LOCK. OK.FIRST); 
typ« REMQ.STATUS !■ (OK.NOT.EMPTY. FAIL.NO.LOCK. 

QK.EMPTY, FAIL_WAS.EMPTY), 


procBdura INSQHI 

(ITEM 

In 

ADDRESS: 


HEADER 

In 

ADDRESS; 


STATUS 

out 

INSQ.STATUS) 

procadur* REMQHI 

(HEADER 

in 

ADDRESS; 


ITEM 

out 

ADDRESS; 


STATUS 

out 

REMQ.STATUS) 

procadura IHSQTI 

(ITEM 

In 

ADDRESS; 


HEADER 

In 

ADDRESS; 


STATUS 

out 

INSQ.STATUS) 

procadura REMtJTI 

(HEADER 

In 

ADDRESS; 


ITEM 

out 

ADDRESS; 


STATUS 

out 

REMQ.STATUS) 


prlT»ta 

-- Not Bhown 
•nd SYSTEM, 


F.4 Restrictions on Representation Clauses 

The representation clauses allowed in VAX Ada are length, enumeration, 
record representation, and address clauses. 

In VAX Ada, a representation clause for a generic formal tj'pe or a type 
that depends on a generic formal type is not allowed. In addition, a 
representation clause for a composite type that has a component or 
subcomponent of a generic formal t\-pe or a type derived from a generic 
formal t\’pe is not allowed. 


F.5 Restrictions on Unchecked Type Conversions 

V.AX .Ada supports tiie generic function UNCHECKED_C0N’VERS10N witn 
the following restrictions on the class of types involved: 

• The actual subtype corresponding to the formal type TARGET must not 
be an unconstrained array type. 

• The actual subtype corresponding to the formal type TARGET must not 
be an unconstrained type with discriminants. 


imoipmentaticn-DeDenrieni Characteristics 2-7 






Further, when the target type is a type with discriminants, the value resulting 
from a call of the conversion function resulting from an instantiation of 
UNCHECKED_C0NVERS10N is checked to ensure that the discriminants 
satisfy the constraints of the actual subtype. 

If the size of the source value is greater than the size of the target subtype, 
then the high order bits of the value are ignored (truncated); if the size of 
the source value is less than the size of the target subtype, then the value is 
extended with zero bits to form the result value. 


F.6 Conventions for Implementation-Generated Names 
Denoting Implementation-Dependent Components in 
Record Representation Clauses 

VAX Ada does not allocate implementation-dependent components in 
records. 


F.7 Interpretation of Expressions Appearing in Address 
Clauses 

Expressions appearing in address clauses must be of the type ADDRESS 
defined in the package SYSTEM (see 13.7a.1 and F.3). In VAX Ada, values 
of type SYSTEM.ADDRESS are interpreted as virtual addresses in the VAX 
address space. 

V.^X .^da allows address clauses for variables (see 13.5). 

WAX Ada does not support interrupts as defined in section 13.5.1. VAX 
Ada does provide the pragma AST_ENTRY and the .A5T_EN'TRY attribute a: 
alternative mechanisms for handling asynchronous interrupts from the VMS 
operating svstem (see 9.12a), 


F.8 Implementation-Dependent Characteristics of 
Input-Output Packages 

The VAX Ada predefined packages and their operations are implemented 
using VAX Record Management Services (RMS) file organizations and 
facilities. To give users the maximum benefit of the underlying V.AX RMS 
input-output facilities, V.AX Ada provides packages in addition to the 
packages SEQUENTlAL_lO, DIRECT_IO, TEXT JO, and IO_ EXCEPTIONS, 


2-8 Imoiementation-Deoencient Characteristics 







and VAX Ada accepts VAX RMS File Definition Language (FDL) statements 
in form strings. The following sections summarize the implementation- 
dependent characteristics of the VAX Ada input-output packages. The VAX 
Ada Run-Time Reference Manual discusses these characteristics in more detail. 


F.8.1 Additional VAX Ada lnput>Output Packages 

In addition to the language-defined input-output packages (SEQUENTIAL. 
10, DIRECT.IO, and TEXT.IO), VAX Ada provides the following input- 
output packages: 

• RELATFVE.IO (see 14.2a.3). 

• INDEXED.IO (see 14.2a.5). 

• SEQUENTIAL.MIXED.IO (see 14.2b.4). 

• DIRECT_MIXED_IO (see 14.2b.6). 

• RELATIVE.MIXED.IO (see 14.2b.8). 

• INDEXED.MIXED.IO (see 14.2b.10). 

VAX Ada does not provide the package LOW.LEVEL.IO. 


F.8.2 Auxiliary Input-Output Exceptions 

VAX Ada defines the exceptions needed by the packages RELATIVE.IO, 
INDEXED.IO, RELATIVE.MIXED.IO, and'iNDEXED.MIXED.IO in the 
package AUX.IO.EXCEPTIONS (see 14.5a). 


F.8.3 Interpretation of the FORM Parameter 

The value of the FORM parameter for the OPEN and CRE.ATE procedure? 
of each input-output package may be a string whose value is interpreted as a 
sequence of statements of the V.AX Record Management Services (RlvlSi Fiie 
Definition Language (FDL). or it mav be a string whose value is interpre.cd 
as the name of an external file containing FDL statements. 

The use of the FORM parameter is described for each input-output package 
in chapter 14. For information on the default FORM parameters for each 
VAX Ada input-output package and for information on using the FORM pa¬ 
rameter to specify external file attributes, see the VAX Ada Riin-Tiiue Reference 
Manual. For information on FDL, see the Guide to VMS File Applicatwns and 
the VMS File Definition Lan^ua^e Factlitu Manual. 


Impiementaiion-Dependent Characteristics 2-9 









F.8.4 Implementation-Dependent Input-Output Error Conditions 


As specified in section 14.4, VAX Ada raises the following language-defined 
exceptions for error conditions that occur during input-output operations: 
STATUS_ERROR, MODE.ERROR, NAME.ERROR, USE.ERROR, END. 
ERROR, DATA.ERROR, and LAYOUT.ERROR. In addition, VAX Ada raises 
the following exceptions for relative and indexed input-output operations; 
LOCK.ERROR, EXISTENCE.ERROR, and KEY.ERROR. VAX Ada does not 
raise the language-defined exception DEVICE.ERROR; device-related error 
conditions cause the exception USE.ERROR to be raised. 

The exception USE.ERROR is raised under the following conditions: 

• If the capacity of the external file has been exceeded. 

• In all CREATE operations if the mode specified is IN.FILE. 

• In all CREATE operations if the file attributes specified by the FORM 
parameter are not supported by the package. 

• In all CREATE, OPEN, DELETE, and RESET operations if, for the 
specified mode, the envnronment does not support the operation for an 
external file. 

• In all NAME operations if the file has no name. 

• In the WRITE operations on relative or indexed files if the element in the 
position indicated has already been written. 

• In the DELETE.ELEMENT operations on relative and indexed files if the 
current element is undefined at the start of the operation. 

• In the UPDATE operations on indexed files if the current element is 
undefined or if the specified key violates the external file attributes. 

• In the SET.LINE.LENGTH and SET.PAGE.LENGTH operations on text 
files if the lengths specified are inappropriate for the external file. 

• In text files if an operation is attempted that is not possible for reasons 
that depend on characteristics of the external file 

The exception N.AME.ERROR is raised as specified in section 14.4; b\' a call 
c' a CRE.ATE or OPEN procedure if the string gn en for the .\',A,\fE parameter 
does not allow the identification of an external file. In V.AX Ada. the value 
of a N.AME parameter can be a string that denotes a V'MS file specification 
or a \TVIS logical name (in either case, the string names an external file). For 
a CREATE procedure, the value of a NAME parameter can also be a null 
string, in which case it names a temporary external file that is deleted when 
the main program exits. The A<in Run-Ttmc Rctcrcncc \\n}uinl explains the 
naming of external files in more detail 


2-10 ImDiementaiicn Decencieni Cnarac:‘=‘f'S:iCS 





F.9 Other Implementation Characteristics 


Implementation characteristics relating to the definition of a main program, 
various numeric ranges, and implementation limits are summarized in the 
following sections. 


F.9.1 Definition of a Main Program 

A main program can be a library unit subprogram under the following 
conditions; 

• If it is a procedure with no formal parameters. In this case, the status 
returned to the VMS environment upon normal completion of the 
procedure is the value 1. 

• If it is a function with no formal parameters whose returned value is of a 
discrete type. In this case, the status returned to the VMS environment 
upon normal completion of the function is 'he function value. 

• If It is a procedure declared with the pragma EXrORT_V'ALUED_ 
PROCEDURE, and it has one formal out parameter that is of a discrete 
type. In this case, the status returned to the \'MS environment upon 
normal completion of the procedure is the value of the first (and only) 
parameter. 

Note that when a main function or a main procedure declared with the 
pragma EXPORT.V.ALUED.PROCEDURE returns a discrete value whose size 
is less than 32 bits, the value is zero or sign extended as appropriate. 


F.9.2 Values of Integer Attributes 

The ranees of values for integer U-pe^ declared in the package ST.'\NDARD 
are as follows: 

SHORT.SHORTJNTEGER -i:' .. 127 

SHORT.INTEGER -32768 .. 32767 

INTEGER -2147483648 .. 2147483647 

For the packages DIRECT.IO, RELATIVE.IO, SEQUENTlAL_MIXED_IO, 
DIRECT_MIXED_IO. RELATIVE.MIXED.IO, INDEXED_M1XED_10, and 
TEXT_IO, the ranges of values for the types COUNT and POSITIVE_COUNT 
are as follows; 


Implementation-Dependent Characteristics 2-11 




COUNT 

POSmVE.COUNT 


0 .. 2147483647 
1 .. 2147483647 


For the package TEXT_IO, the range of values for the h^pe FIELD is as 
follows: 

FIELD 0 .. 2147483647 


F.9.3 Values of Floating Point Attributes 

Attribute 

F_floating value and approximate decimal equivalent 
(where applicable) 

DIGITS 

6 

MANTISSA 

21 

EMAX 

84 

EPSILON 

16#0.1(K)0.000#e-4 

approximately 

9.53674E-07 

SMALL 

16''0.8000.000*e-21 

approximately 

2.58494E-26 

LARGE 

16#0.FFFF.F80#e + 21 

approximately 

1.93428E + 25 

SAFE.EMAX 

127 

SAFE.SMALL 

16i»0.10(K).000#e-31 

approximately 

2.93874E-39 

SAFE.LARGE 

16*0.7FFF.FC0*e-32 

approximately 

1.70141E + 38 

FIRST 

-16*0.7FFF.FF8»e-32 

approximately 

-1.70141E 4-38 

LAST 

16«0.7FFF_FF8«e*': 

approximately 

1.70141E-38 

MACHINE.RADIX 

T 

MACHINE.MANTISSA 

n 1 

MACHINE.EMAX 

127 

MACHINE.EMIN 

-127 

MACHtNE.ROUNDS 

T rue 

MACHINE.OVERFLOWS 

True 


2-12 Implementation-Dependent Characteristics 





Attribute 

□.floating value and approximate decimal equivalent 
(where applicable) 

DIGITS 

9 

MANTISSA 

31 

EMAX 

124 

EPSILON 

16#0.4000.(X)00.(X)00.000*e-7 

approximately 

9.3132257461548E-10 

SMALL 

16#0.8000.0(X)0.0000.000#e-31 

approximately 

2.35098876i6446E-38 

LARGE 

16#0. FFFF.FFFE.(K)00.(X)0#e -t- 31 

approximately 

2.1267647922655’e + 37 

SAFE.EMAX 

127 

SAFE SMALL 

16#0. l(X)0.(X)00.0000.0(XI#e-31 

approximately 

2.9387358770557E-39 

SAFE LARGE 

16#0.7FFF.FFFF.OOOO.OOO#e + 32 

approximately 

1.70141183381 24’e +38 

FIRST 

-16*'0.7FFF.FFFF.FFFF.FF8#e + 32 

afTproximately 

-1.7014118346047’e+38 

LAST 

16#0.7FFF.FFFF.FFFF.FF8#e + 32 

approximately 

1.7014118346047’e + 38 

MACHINE.RADIX 

2 

MACHINE.MANTISSA 

56 

MACHINE.EMAX 

127 

MACHINE.EMIN 

-127 

MACHINE.ROUNDS 

True 

machine.overflows 

True 



G.floating value and approximate decimal equivalent 

Attribute 

(where applicable) 

DIGITS 

15 

MANTISSA 

51 

EMAX 

204 

EPSILON 

1 ( 1 * 0 .4noo,ooooj)ooo.no*e -1 2 

approximately 

g 8«}7g41')7001E-16 


Imolementation-DependGnt Characteristics 2-13 




Attribute 

G_floating value and approximate decimal equivalent 
(where applicable) 

SMALL 

16#0.8(X)0.(X)00.0(XX)_(X)»e-51 

approximately 

l.°4469:274332E-62 

LARGE 

16#0.FFFF.FFFF,FFFF.E0»e-5l 

approximately 

2.571100870814E + 61 

SAFE.EMAX 

1023 

SAFE.SMALL 

16i*0.10(X).OOOO.OOOO.OOee-255 

approximately 

5.562684646268E-30O 

SAFE.LARGE 

16*0.7FFF.FFFF.FFFF.F0i»e + 256 

approximately 

8 .488465674312E +307 

FIRST 

-16*0.7FFF.FFFF.FFFF.FC#e + 256 

approximately 

-8.988465674312E-1-307 

LAST 

16*0.7FFF.FFFF,FFFF.FC#e -i- 256 

approximately 

8.988465674312E-1-307 

MACHINE.RADIX 

2 

MACHINE.MANTISSA 

53 

MACHINE.EMAX 

1023 

MACHINE.EMIN 

-1023 

MACHfNE.ROUNDS 

Tme 

MACHINE.OVERFLOWS 

True 


H.floating value and approximate decimal equivalent 
Attribute (where applicable) 


DIGITS 33 

MANTISSA m 

EMAX 4-4 


EPSILON 

appro'.!m.'!t"'v 

SMALL 

approximately 

LARGE 

approximately 

SAFE.EMAX 


ih»o 4(yoo.oooo_0(ioo onpn 0''00.0c^'T^r'00_n‘'e-i:7 
7.7','3710777548‘>434i;Z23‘4| 177033° 7E-34 

I P'0.8OO().O0OO,'JOOO.OOOO,OOO0.OOOO.0QO0.0*e -111 
l.l(X)o5o8h463791821093431802093o’E-134 

16*0.FFFF_FFFF,FFFF.FFFF.FFFF.FFFF.FFFE_0*e* 111 
4.342742O26847543Oe.5°332737QQ3600E - 133 

16383 


2-14 imDiementaiion-Depenaent Characteristics 









Attribute 

H_f1oating value and approximate decimal equivalent 
(where applicable) 

SAFE.SMALL 

approximately 

16410.1000.0000.0000.0000.0000.0000.0000.0#e-4095 

8.4052578577802337f.5b5nb045433044E -4033 

SAFE.LARGE 

approximately 

16«i0.7FFF.FFFF.FFFF.FFFF_FFFF.FFFF.FFFF.0#e -i- 4096 

5.948b574767861588254287966331400E + 4931 

FIRST 

approximately 

-16#0.7FFF.FFFF.FFFF.FFFF.FFFF.FFFF.FFFF.C*e-1-4096 
-5.9486574767861588254287966331400E-1-4931 

LAST 

approximately 

1 61 * 0 .7rFF.FFFF.FFFF.FFFF.FFFF.FFFF.FFFF.C#e - 1 - 4096 
5.94865747678bl588254287966331400E-t-4931 

MACHINE. RADIX 


MACHINE.MANTISSA 

113 

MACHINE.EMAX 

16383 

MACHINE.EMIN 

-16383 

MACHINE.ROUNDS 

True 

MACHINE.OV'ERFLOWS 

True 


F.9.4 Attributes of Type DURATION 


The values of the significant attributes of the t\'pe DURATION are as follows: 


DURATION'DELTA 
DURATION'SMALL 
DURATION'FIRST 
DURATION'LAST 
DURATION'LARGE 


1.000(X)E-04 

2-14 

-131072.0000 

131071.9900 

1.31 071Oooo38Oo484375!: 4 - 05 


F.9.5 Implementation Limits 


Limit Description 

32 Maximum number of formal parameters in a subprogram or entry 

declaration that are of an unconstrained record type 

255 Maximum identifier length (number of characters) 

255 Maximum number of characters in a source line 


Implementation-Dependent Characteristics 2-15 






Limit Description 

245 Maximum number of discriminants for a record type 

24^^ Maximum number of formal parameters in an entry or subprogram 

declaration 

255 Maximum number of dimensions in an array type 

1023 Maximum number of library units and subunits in a compilation 

closure' 

4095 Maximum number of library units and subunits in an execution 

closure* 

32757 Maximum number of objects declared with the pragma PSECT.OBJECT 

65535 Maximum number of enumeration literals in an enumeration type 

definition 

65535 Maximum number of characters in a value of the predefined type 

STRING 

65535 Maximum number of frames that an exception can propagate 

65535 Maximum number of lines in a source file 

2"’ - 1 Maximum number of bits in any object 

'The compilation closvire of a given unit is the total set of units that the given unit depends 

on, directly and indirectly. 

’The execution closure of a given unit is the compilation closure plus all associated secondary 

units (library bodies and subunits). 


2-16 Implemenialion Deoendeni Chafactenstics 





c 


. J ^ 


Tc:'^ I'-’-p■-'.'^TERS 


Certain tests i:. •, :.o. ATVJ ir.oi.L usv or iir.plementation-dependent values, 
such as the Icr.r.t;, ,i ..n ii.pvt line and invalid file names. A 
test that makes nse c^r sue;. '.-al'.Les is identified by the extension .TST 
in its file nar.i^:. .Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these nair.es before the test is run. The values used for this 
validation are given below. 


$ACC_SIZE 

An integer literal w’nose value 
is the number of bits sufficient 
to hold an;.’ value of an access 
type . 

$BIG_ID1 

r.iH’,: i Li.c* 

maximum ixr-;:: lenf.ri: vitii 

vaiVin^ j.cisz cr*aracc.£;i*. 

$BIG_ID2 

Identifier t'ne size of the 
maximum in.put line leiigti; ’with 
varvi.-.g last c'naracter. 

$BIG_ID3 

Identifier the size of the 
maximum ir.r .;t line length ’with 
var;.'ing michhe '■::aracter, 

$ B i. a_ ^ 



$BIG_INT_LIT 

An integer literal of value 29S 
with enough, leading zeroes so 
that it i.s the size of the 
maxi mum. 1 i n e length. 

$BIG_REAL_LIT 

A universe... real literal or 
value 690.0 with enough leading 
zeroes to be the size of the 


1..254 -> 'A', 255 -> '1' 


1..254 => 'A', 255 -> ' 2 ' 


1..127 => 'A'. 128 -> '3'. 
125 .. 255 => '.A' 



1..252 -> 'O', 253..255 -> '298' 


1..250 => '0', 251..255 -> 
'690.0' 


C-1 









maximum line length. 


$BIG_STRIh’Gl 

A string literal which when 

catenated with BIG^STRING2 

yields the im.ir.e of E>IG IDl. 

1.195 _> "A” 

$big_str::;g2 

A s ^ 1 * n ^ ^ ^ ^ ^ ' ..non 

catenated to t!;e ei;d of 

BIG STRI.’h;! '■•ieids the iir.age of 
BIG_ID1. 

196..254 -> "127, : 

$ BLANKS 

A sequence of blanks twenty 

characters Ic-ss tliaTi the site 
of the maxiii;u:i. lino Ici'ig.tli. 

1..235 -> ' ' 

$COUNT_LAST 

A tini'.’ersa 1 integer 

literal whoso val'co is 

TEXT^IO. COUNT' L'-.ST, 

2_147_483_647 

$defaultj;em_s:ue 

An integer litoral who.so value 
is SYSTEM . M E;I0 RY_ S 12E . 

2^^31-1 

$DEFAULT_STOR_U::iT 

An integer literal whose value 
is SYSTEM , STOR.AGE_UNIT . 

8 

$ DEFAULT_S YS_NAME 

The value of the cor.stant 

SYSTEM.SYSTEM J;AME. 

VAX_VMS 

$delta doc 

2.0--.-w-(-31) 

$FIELD_L.1ST 

A 'ur.i'.’tr-r sa * integer 

literal wr.cj.so vaxue is 

TEXT_IO. FIEL0'L.-'.ST. 

2 14 / 4S3 6‘4 ! 

$FIXED_NAME 

The name of a predefined 
fixed-point f.'pe otlier than 
DURATION. 

NO_SUCH_FIXED_TYPE 

$FL0AT_:;.-01E 

The nam.e of a predefined 

floating-point other than 

LONG_LONG_FLOAT 













:t^t: :n_bas£_last 131_073 . o 

A ur.i’.'ersal real literal that is 
greater that. DfRA.i: Oh'’ EASE ' LAST. 


ca'C'-- rr 


15 


value 


Ar. i: teger *itera. '.vTiosc- 
IS tr.e upper 'jou:.! or the rauge 
:cr t'ne su'tt.pe S'lSTEM. PRIGRITY. 

$:LLEoAL_E;';TER:;.";L_;':LE_h.A:-‘El BADCHAR"(a. ■ ! 

Ar exterral file r;an:e which 
err.rair.s irr'alid characters. 


; A L _ r : L E _ N A M E 2 
E GTL'l- LEGAL- IF - IT-VERE-NOT - SO-LONG. SO_THERE 
name v.''nic'n 


•teger literal 
INTEGER'FIRST. 


eager .^iteraj 




-2147483648 


2147463647 


2 147 483 648 


ur.I’.’c-rsa 1 rea.!. -iteral tnat 



ir. the range of DUPvATION'. 


c 


SS THAN GT 


^. t: ^ a> 


^ess 


RAT I ON'_BAS E_FI R 
^ i‘ (jci ^ I i 16 r u i 
L 'J T T10!«'' 5 A S E ' 



IS 



r.teger literal v;hose 
he lower bound of the 


value 

range 


-75 000.0 


-131 073.0 


0 


C-3 












for the sub 


SYSTEM.PRIORITY. 


$MANTISSA_DOC 31 

An integer literal whose value 
is SYSTE.'i . LA.Y'TISS.A. 

$MAX_DIGITS 33 

Maxirr.u.'Ti ciigits surpovted for 
floatir.g-tvpes . 

$MAX_IN_LEN 255 

Maximum input line length 
permitted by the implementation. 


$MAX_1NT 21A7483647 

A universal integer literal 
whose value is SYSTE.M.MAX IMT. 


$.MAX_INT_PLUS_1 
A universal 
whose value is 

$.M.AX_LEM_:.\T_5ASE0_LITERAL 1..2->"2:". 3. 

.A universa_ integer based 251..255 => '11; 
literal wi'cst 'taiue is 2“li — 
with enough leading zeroes in 
the mantissa to be .'-lAM IN' LEN' 


2_147_483_648 

integer literal 
SYSTEM.M-YM IN'T+1. 


$MAX_LEN'_REAL_E.ASEO_LITER.AL 1..2 => '16:', 3 

A universal real based literal 249..255 ■=> '16: 

whose value is 16:F.E; with 
enough leading zeroes in the 
mantissa to be MY'''._IN'_LEM long. 

$.max_stri::g_l:te?-al 

A £ t r i r. t literal c f size 
MAi'l lil TEib ir.t T.;cir.z ti'.e cuote 
charac ters . 

$.MIM_I.N'T -21474S3648 

A universal 
whose value is 



=> ' 
;■ A =' 


:. .204 


$MIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 


C-4 


.250 -> '0', 


..248 -> '0' 
F.E' 


=> "A" 








$NAME 

A name of a predefined numeric 
type other than FLOAT, ILTEGER, 
SHORT_FLCAT. SHORT_IN'TEGER. 

LONG_FLOAT, or LOL’G_I.\'TEGER. 

$NAME_LIST 

A list of t 
in the 
separated b;. 

$neg_based_:::t 

A based integer literal v:hose 
highest order nonzero bit 
falls in the sign. bit 
position of the representation 
for SYSTEM. 

$NEW_ME.M_SIZE 


An integer literal 

whose 

value 

is a permitted 

argument 

for 

pragm.a me.niory size. 

other 

than 

$DEFAULT_ME.';_S:ZE, 

If ther 

e is 

no other value. 

then. 

use 

$DEFAULT_ME.M_SIZE. 



f_ST0R._UNIT 

An integer literal 

whose 

value 

is a permitted 

argument 

for 

pragma storage_unit 

, other 

than 


$DEFAULT_ST0R_UFIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE UNIT 

$new_sys_na:-ie 

A value of t 
other than S 
there is or.l 

type, then tu.e ti'.at value. 


SYSTEM. NA1;E. 
SYS_!.'.-J’IE. It 
jlue of ti.at 


; . cl'catllOll 

type SYSTE.M . N’.AME , 
■ commas. 


$TASK_SIZE 

An integer literal uhose value 
is the number of bits required 
to hold a task object wh.ich has 
a single entry vith one inout 
param.eter. 

$TICK 

A real literal whose a’alue is 
SYSTEM.TICR. 


SHORT SHORT INTEGER 


VAX_VMS,VAXELN 


16-FFFFFFFE# 


1 048 576 


8 


VAMELN 


32 


10 . 0 **(- 2 ) 


C-5 







APPENDIX D 


NITHDF^AWN TESTS 


Some tests ‘. sr a- 1 . fro:; the ACVC because they do not conform to 

the Ada Sta-. d.-r ; h e roflovir'.r tests had been withdrawn at the time 
of validciti_;. : orii.r for t’.;c reasons indicated. A reference of the 
form Al ‘caucc to an Asa eoitineiitary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a ;r.inimum size (line 30). 

B97102E 

This test contains an unintended illegality; a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

BC3009B 

This test x.ronglv expects tiiat circular instantiations will be detected 
in several co:npilation units even though none of the units is illegal 
with respect to ti'.e units it depends on; by AI-00256, the illegality 
need not be cit‘. ted '-;r.til execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2a 6'3A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to checit the size of objects of a derived 
type (for v.-hich a 'SIZE length clause is given) by passing them to a 
derived subprogrrur', /.-.•hich implicitly converts them to the parent type 
(Ada standard 2 . ^: 1- ’ . .Additionally, they use the 'SIZE length clause 
and attribute, •..hose interpretation is considered problematic by the WG9 
.i-RG. 

CD2AS1G. ';D_A: 

i'nfis© tifeSwS lii 

program exex.it 
not the case, 

£6 & 96 , £6 d 

CD2B15C & CD7205C 

These tests expect that a 'ST0RAGE_SIZE length clause provides precise 
control over the num.ber of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMAZZ representation clause for a derived fixed-point 
type (at line 30) t'nat defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 


;i.:A£-N i. & cdsciio 

e '-'.'.at dependent tasks will terminate while the main 
7; loop that simply tests for task termination; this is 
the main program may loop indefinitely (lines 74, 85, 
c-.-.’.d 58, resp.). 


D-1 




model numbers of a derived rixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wronglv eMtects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, EDTOOtC d j, d B '5 tests] 

These tests ciiecr: various aspects of the use of the three SYSTE.M 
pragmas; the .■^VO v.-i thdravs th.ese tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTE.'-'.. TICK.: however, by Commentary Al-00201, it is only the 
expected f r equen.c;,- of change that must be at least SYSTEM.TICK -- 
particular instances of cr.ange m.ay be less (line 29) . 

CD7203B, d CD720dB 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARC. 

CD7205D 

This test checks an, invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished '•■.•her. read from a file--DATA_ERROR is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly hov the Ada standard 14.2.d:4 is to be interpreted; 
thus, this test objective is net considered valid. (line 90) 

CE3111C 

This test requires certain beh.avior. when two files are associated with 
the same external file, t'r.at is not required by the Ada standard. 

CE3301A 

This test contains s----er.sl ca^ls to E:.'D_0F_LII.'E A END_0F_PAGE that have 
no parameter; tne..e calls v.-ere intended to specify a file, not to refer 
to STANDARD_i;;PUT -'lines 103. 107. 118, 132. A 136). 

CE3411B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that L.AY0UT_EPvR0R is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack, of a/ailable disk space, and the test would thus encumber 
va..idatton testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 

D-2 



will appear az che cop of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D-3 







APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
DigiCul Equipment Corporation 

Compiler: V/Cl ACa Version 2.0 

AC VC '.'e r s i o II: 1,10 


/ANALYSlS_D.nTA or /NOANaLYSIS_D.ATA 

Controls v;hether a data analysis file containing source code cross- 
referencing and static analysis information is created. The 
default is /.V .NALYSIS_D.VTA. 

/CHECK or /NOCHECK 

Controls vhetr.er run-time error checking is suppressed. (Use of 
/NOCHEC”. is t ; uivalci.t to giving all possible suppress pragmas in 
the source program.' The default is /CHECK (error checking is not 
suppressed accept by pragma). 

/C0?Y_S0YRCE or /;;0C0PY_S0URCE 

Controls •..'nether the source being compiled is copied into the 
compilation library for a successful compilation. The default is 
/C0?Y_S0YRCE. 

/DEEYG or i-lDEEVG or •''DE5YG=option 


4 i C C' 


ne o: 


TILVCESACK or N0TRACE3ACK, or NONE 


cor 

/Dl 


c 


led 0 'r 
G=ALL. 


i ;.s:cr. cr .tc-tugging symbol table information in the 
:rodule. The defa'ult is /DEBUG or, equivalently, 


E-1 







/DIAGNOSTICS, /DIAGNOSTICS-filename. or /NODIAGNOSTICS 

Controls whether a special diagnostics file is produced for use 
with the VAX Xanguagc- S ens itive Editor (a separate DIGITAL 
product^ Ti;e dc-fault is V^ODIAGNOSTICS. 


Cont 


-s t'ne nurr.ber of error level diagnostics chat are allow- d 
within a single compilation unit before the compilation is aborted. 
The default is /ERROR LIMIT=30. 


/LIBRARY=directory-name 

Specifies th.e nair.e of the Ada compilation libra''y to be used as the 
context for the compilation. The default is the library last 

established bv the ACS SET LIBRARY command. 

/LIST, /LIST^filename. or /NOLIST 

Controls whic-ther a listing file is produced. /LIST without a 
filename uses a default filename of the form sourcename.LIS, where 

sourcena::',e is ti.e r,;-.:re -: tiic- source file being compiled. The 

default is N'OLIST (for both ir.teractive and batch mode). 

/MACHINE_CODE or /NO.'-LACHINE_CODE 

Controls whether generated machine code (approximating assembler 
notation) is included in the listing file, if produced. The 

default is /N0;ACHINE_C0DE. 


/ 


■'NOTE SOURCE cr /NCNOTE_SCUR‘; 


Controls 
is note; 
c c r w t: 1 r. 


'.er the file specification of the current source file 
ccmr i lat ion librarv. (This copy is used for 


w . . t' 


f-oatures.'i The default is 


Controls w:the r full or minimal optimization is applied in 
producing the compiled code. The default is /OPTIMIZE. 
(/NOOPTIMIZE is primarily of use in combination with /DEBUG.) 


/SH0U-PCRTA3ILITY or . NOSHOU 


Controls •..■l.eti'.er a perta::'i 1 ity summary is included in the listing. 
The defa-ult is SHC'.-.'=P0RT.--.5ILITY. 


E-2 







J 


/WARNIl'.'GS*i catv^orv : destirrition, . . . ) 

Specifies which caregories of informational and warning level 
messages are displayed for wi.ich destinations. The categories can 
be WARN'Ih'GS. VE.hK jiAR\'I.\‘GS, SUPPLEMENTAL, COMPILATION_NOTES AND 
ST.-.TUS. Tiu Ccst ir.atior.s can be ALL, NONE or combinations of 
TEPdlli.'AL, L:ST:::G or GIAGNOSTICS . The default is 

UAR;;i:;GS= . Ur.RN ; all, tear . all, SUPP : all, comp : NONE. STAT: LIST) 


E-3 








