UNCLASSIFIED 2 ; 

SECURI T Y CLASSlf 1CATI0*. Of THJS (When Dele f me red) 


REPORT DOCUMENTATION PAGE 



1. REPORT NUMBER 


kcas wrmumoKS 
•trout C0MP.tTt:NC ro*.v 


12. GOVT ACCESSION NO. 3. RECIPIENT'S CATALOG NUMBER 
„„„ — 5. TYPE Of REPORT t PERIOD COVERED 


4. TITLE (endiubvtle) 5 TYPE Of REPORT t PERIOD COVERED 

Ada Compiler Validation Summary Report: Concurrent 18 Aug. 1989 to 18 Aug. 1990 

Computer Corporation, MC-Ada .Version 1.2, Concurrent 6600 7—ii.tniymr ,. 11MOtB 

with MC68030 CPU, Lightning Floating Point (Host & Target) 6 ' CORNING DR& • A^ORT number 


1 . author^ 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 
•. VCRfORNING ORGANIZATION AND ADDRESS 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 

n. CONTROLLING OffECE name AND ADDRESS ~ ™“ ™—- 

Ada Joint Program Office 

United States Department of Defense 

Washington, DC 2D301-3081 

14. MONITORING AGENCY NAME A ADORESSfif different from Controlling Office) 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 

16. DISTRIBUTION STATEMENT (of ihn tepon) 


t. CONTRACT or grant numbered 


10. PROGRAM ELEMENT. PROJECT. TASK 
AREA A NORA UNIT NUMBERS 


[if. REPORT 0ATE 


15. SECURITY Class (of thu report) 

UNCLASSIFIED _ 

15* . gEC^AS^flCATlON/DOMNGRADING 

N/A 


Approved for public release; distribution unlimited. 


17. DISTRIBUTION STATEMENT (of the ebnrsct tnltrt dm Block 20 If different from Report) 

UNCLASSIFIED 


IB. SUPPLEMENTARY notes 


DTIC 


DECO 41989 


19. KEYWORDS (Continue on revent t‘dt if neceuery end identify by block number) 

* 

Ada Programming language, Ada Compiler Validation Summary Report, Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/MIL-STD- 
1815A, Ada Joint Program Office, AJPO 

10. ABSTRACT (Con:,nut on reverie iide if necetury end identify 6, 6*oc* number) 

Concurrent Computer Corporation, MC-Ad Version 1.2, Gaithersburg, MD, Concurrent 6600 
with MC68030 CPU, Lightning Floating Point (Host & Targt), ACVC 1.10. 


AD-A214 907 


CD 0158 1473 TpitT. . . . 

t JAN 7) $/N 0103-LP-014-6601 

8 ? // So OY 6 


UNCLASDlr £ED _ 

SECURITY CLASSIFICATION OF THIS PAGE (*ntn Del* entered) 





AVF Control Number: NIST89CON570_2_1.10 
DATES COMPLETED PRE-VAL 07-13-89 
DATES COMPLETED ON-SITE 08-18-89 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 890818S1.10131 
Concurrent Computer Corporation 
hC-Aaa Version 1.2 

Concurrent 6600 with MC68030 CPU, Lightning Floating Point Host 

and 

Concurrent 6600 with MC68030 CPU, Lightning Floating Point Target 


Completion of On-Site Testing: 
August 18, 1989 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 








Ada Compiler Validation Summary Report: 


Compiler Name: MC-Ada Version 1.2 
Certificate Number: 890818S1.10131 


Host: 

Concurrent 6600 with MC68030 
Point under RTU Version 5.0 

CPU, 

Lightning 

Floating 

Target: 

Concurrent 6600 with MC68030 
Point under RTU Version 5.0 

CPU, 

Lightning 

Floating 


Testing Completed August 18, 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 



Chief, Information Systems 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Mr. L. Arnold Johns^pX 
Manager, Software Standards 
Validation Group 
Engineering Division 
National Computar Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Ada Validation Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 


Alexandria VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 








TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 


1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 AC VC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . .3-5 

3.7 ADDITIONAL TESTING INFORMATION . 3-5 

3.7.1 Prevalidation.3-6 

3.7.2 Test Method.3-6 

3.7.3 Test Site.3-7 


APPENDIX 

A 

CONFORMANCE STATEMENT 

APPENDIX 

B 

APPENDIX F OF THE Ada STANDARD 

APPENDIX 

C 

TEST PARAMETERS 

APPENDIX 

D 

WITHDRAWN TESTS 

APPENDIX 

E 

COMPILER OPTIONS AS SUPPLIED BY 
Concurrent Computer Corporation 



Aooesslon For 

NT IS GR.UI 
DTIC TAB 
Unannounced 

Justification__ 


By- 

Elg » rlhntion/ 

__Availabllit/ Codes 
(Avail and/or 
Dlat I Special 


fH 


□ □ 

























CHAPTER 1 


INTRODUCTION 


This Validation Summary Report fVSR^ describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of test _ing this compiler using the Ada Compiler 
Validation Capability , fA€VCJU^_ An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies*-for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results, h, The purpose of validating is to ensure 
conformity of the compiler \ to the Ada Standard by testing that the 
compiler properly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is J implementation dependent, but is permitted 
by the Ada Standard. Six alasses of tests are used. These tests are 
designed to perform checks j at compile time, at link time, and during 
execution. i 




1-1 








1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


On-site testing was completed August 18, 1989 at Westford, MA. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 


1-2 










Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 

1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada An Ada Commentary contains all information relevant to 

the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 



AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 
technical support for Ada validations to ensure 
consistent practices. 

Compiler A processor for the Ada language. In the context of 


1-3 












this report, a compiler is any language processor, 
including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding 

a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 

1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 


1-4 












program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters-- for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D ‘est fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is , an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 
FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 


1-5 












of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


1-6 










CHAPTER 2 


CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 

Compiler: MC-Ada Version 1.2 

ACVC Version: 1.10 

Certificate Number: 890818S1.10131 

Host Computer: 

Machine: Concurrent 6600 with MC68030 CPU, Lightning 

Floating Point 

Operating System: RTU Version 5.0 
Memory Size: 8MBytes 

Target Computer: 

Machine: Concurrent 6600 with MC68030 CPU, Lightning 

Floating Point 

Operating System: RTU Version 5.0 
Memory Size: 8MByes 


2-1 








2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

(3) The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tescs D64005E..G (3 tests).) 


b. Universal integer calculations. 

(1) Ar implementation is allowed to reject universal integer 
calculations having values that exceed SYSTEM. MAX_INT 
ih:s implementation processes 64-bit integer calculations 
(See tests D4A002A, D4A002B, D4A004A, and D4A004B.) 


c. Predefined types. 

(1) This implementation supports the additional predefined 
types SHORT_INTEGER, TINY_INTEGER, SHORT_FLOAT in the 
package STANDARD. (See tests B86001T..Z (7 tests).) 

d. Expression ev=luation. 

The order in which expressions are evaluated and the time at 
which constraints are checked are not defined by the lan to uage. 
While the ACVC tests do not specifically attempt to determine 
the order of evaluation of expressions, test results indicate 
the following: 


2-2 









(1) All of che default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component’s subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 

(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) NUMERIC_ERROR is raised for pre-defined integer comparison, 
pre-defined integer membership, LARGE_INT comparison, 
LARGE_INT membership and SMALL_INT comparison and no 
exception is raised for SMALL_INT membership when an 
integer literal operand in a comparison or membership test 
is outside the range of the base type. (See test C45232A.) 

(5) CONSTRAINT_ERROR is raised by membership test "1.0E19 in 
LIKE_DURATION_M23" and "2.9E9 in MIDDLE_M3" when a literal 
operand in a fixed-point comparison or membership test is 
outside the range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A..K (11 
tests).) 


e. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. While the ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 

(1) The method used for rounding to integer is round to even. 
(See tests C46012A.,K (11 tests).) 

(2) The method used for rounding to longest integer is round to 
even. (See tests C46012A..K (11 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round to even. (See test C4A014A.) 

f. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD. INTEGER'LAST and/or SYSTEM. MAX_INT. For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 


2-3 






more than SYSTEM.MAX_INT components raises no exception. 
(See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST t- 2 components. (See test C36202A.) 


(3) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 

type with SYSTEM. MAX_INT + 2 components. (See test 

C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding 

INTEGER'LAST raises NUMERIC_£RROR when the array type is 
declared. (See test C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more than 

INTEGER'LAST components raises NUMERIC_ERROR when the array 
type is declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 

INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 

implementation may accept the declaration. However, 
lengths must match in array slice assignments This 
implementation raises NUMERIC_ERROR when the array type is 
declared. (See test E52103Y.) 

(7) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression’s subtype is 
compatible with the target's subtype. (See test C52013A.) 

(8) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

g. Discriminated types. 

(1) During compilation, an implementation is allowed to either 
accept or reject an incomplete type with discriminants that 
is used in an access type definition with a compatible 
discriminant constraint. This implementation accepts such 
subtype indications. (See test E38104A.) 

(2) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
C0NSTRAINT_ERR0R is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 


2-4 











h. Aggregates. 


(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised after all choices are evaluated 
when a bound in a non-null range of a non-null aggregate 
does not belong to an index subtype. (See test E43211B.) 


i. Pragmas. 

(1) The pragma INLINE is supported for functions or procedures. 
(See tests LA3004A..B (2 tests), EA3004C..D (2 tests), and 
CA3004E..F (2 tests) .) 

j. Generics. 

(1) Generic specifications and bodies can be compiled in 

separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 

(4) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(5) Generic non-library subprogram bodies can be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits can be 
compiled in separate compilations. (See test CA2009C.) 


2-5 













(9) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


k. Input and output. 

(1) The package SEQUENT1AL_I0 can be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.) 

(2) The package DIRECT_IO can be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101H, 
EE2401D, and EE2401G.) 

(3) Modes IN_FILE and OUT_FILE are supported for SEQUENTIAL_IO. 
(See tests CE2102D..E, CE2102N, and CE2102r.) 

(4) Modes IN_FILE, OUT_FILE, and INOUT_FILE are supported for 

DIRECT_IO. (See tests CE2102F, CE2102I..J (2 tests), 

CE2102R, CE2102T, and CE2102V.) 

(5) Mode IN_FILE is supported for the operation of CREATE for 
text files. (See test CE3102E.) 

(6) Modes IN_FILE and OUT_FILE are supported for text files. 
(See tests CE3102E and CE3102I..K (3 tests).) 

(7) RESET and DELETE operations are supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 

(8) RESET and DELETE operations are supported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(9) RESET and DELETE operations are supported for text files. 

(See tests CE3102F..G (2 tests), CE3104C, CE3110A, and 

CE3114A.) 

(10) Overwriting to a sequential file truncates to the last 

element written. (See test CE2208B.) 

(11) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

(12) Temporary direct files are given names and deleted when 

closed. (See test CE2108C.) 

(13) Temporary text files are given names and deleted when 

closed. (See test CE3112A.) 

(14) More than one internal file can be associated with each 


2-6 









external file for sequential files when writing or reading. 
(See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 

CE2111D.) 

(15) More than one internal file can be associated with each 
external file for direct files when writing or reading. 
(See tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(16) More than one internal file can be associated with each 

external file for text files when writing or reading. (See 
tests CE3111A..B (2 tests), CE3111D..E (2 tests), and 

CE3114B.) 


2-7 








CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 329 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

129 

1132 

1992 

17 

28 

46 

3344 

Inapplicable 

0 

6 

323 

0 

0 

0 

329 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 





3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

7 

CHAPTER 
8 9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

198 

577 

545 

245 

172 

99 

161 

331 

137 

36 

252 

292 

299 

3344 

Inapplicable 

14 

72 

135 

3 

0 

0 

5 

1 

0 

0 

0 

77 

22 

329 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD5011O 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 

E28005C 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 






See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 329 
tests were inapplicable for the reasons indicated: 

a. The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 


3-2 










C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


C35702B and B86001U are not applicable because this implementation 
supports no predefined type LONG_FLOAT. 

The following 16 tests are not applicable because this 
implementation does not support a predefined type LONG_INTEGER: 



C45231C 

C45304C 

C45502C 

C45503C 

C45504C 


C45504F 

C45611C 

C45613C 

C45614C 

C45631C 


C45632C 

CD7101F 

B52004D 

C55B07A 

B55B09C 

B86001W 

d. 

C45531M..P (4 

tests), C45532M..P 

(4 tests) 

are not . 


because this implementation does not support a 48 bit integer 
machine size. 


e. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

f. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT or 
SHORT_FLOAT. 

g. C86001F is not applicable because, for this implementation, the 
package TEXT_IO is dependent upon package SYSTEM. This test 
recompiles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. A link-time error is generated. 

h. C96005B is not applicable because there are no values of type 
DURATION'BASE that are outside the range of DURATION. 

i. CD1009C, CD2A41A, CD2A41B, CD2A41E, CD2A42A, CD2A42B, CD2A42C, 
CD2A42D, CD2A42E, CD2A42F, CD2A42G, CD2A42H, CD2A42I, CD2A42J (14 
tests) are not applicable because this implementation does not 
support 'SIZE representations for floating-point types. 

j. CD2A61I..J (2 tests) are not applicable because this implementation 
does not support size specifications for array types that imply 

. compression of component type when the component type is a 

composite or floating point type. This implementation requires an 
explicit size clause on the component type. 

k. CD2A84B..I (8 tests) and CD2A84K..L (2 tests) are inapplicable 
because this implementation does not support size clauses for 
access types. Access types are represented by machine addresses 
which are 32 bits. 


1. CD2A91A..E (5 tests) are not applicable because this implementation 


3-3 







does not support the 'SIZE representation clauses for task types. 

m. CD5003B, CD5003C, CD3003D, CD5003E, CD5003F, CD5003G, CD5003H, 

CD5011A, CD5011B, CD5011C, CD5011D, CD5011E, CD5011F, CD5011G, 

CD5011H, CD5011L, CD5011M, CD5011N, CD5011Q, CD5011R, CD5012A, 

CD5012B, CD5012C, CD5012D, CD5012E, CD5012F, CD5012G, CD5012H, 

CD5012I, CD5012L, CD5013B, CD5013D, CD5013F, CD5013H, CD5013L, 

CD5013N, CD5013R, CD5014T, CD5014U, CD5014V, CD5014W, CD5014X 

(42 tests) are not applicable because this implementation does not 
support 'ADDRESS clauses where a dynamic addresses is applied to a 
variable requiring an initialization. The AVO has ruled that these 
tests may declared to be inapplicable. 

n. CD5012J, CD5013S, CD5014S are not applicable because this 

implementation does not support 'ADDRESS clauses for tasks. The 
host system linker does not support location of object segments or 
of data items. 

o. CE2102D is inapplicable because this implementation supports CREATE 
with IN_FILE mode for SEQUENTIAL_IO. 

p. CE2102E is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for SEQUENTIAL^IO. 

q. CE2102F is inapplicable because this implementation supports CREATE 
with mode INOUT_FILE for direct access files. 

r. CE2102I is inapplicable because this implementation supports CREATE 
with IN_FILE mode for DIRECT_IO. 

s. CE2102J is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for DIRECT_IO. 

t. CE2102N is inapplicable because this implementation supports OPEN 

with IN_FILE mode for SEQUENTIAL_10. 

u. CE21020 is inapplicable because this implementation supports RESET 
with IN_FILE mode for SEQUENTIAL_IO. 

v. CE2102P is inapplicable because this implementation supports OPEN 

with OUTJFILE mode for SEQUENT1AL_I0. 

w. CE2102Q is inapplicable because this implementation supports RESET 
with OUT_FILE mode for SEQUENTIAL_IO. 

x. CE2102R is inapplicable because this implementation supports OPEN 

with mode INOUT_FILE for direct access files. 

y. CE2102S is inapplicable because this implementation supports RESET 
with INOUT_FIL£ mode for DIRECT_I0. 

z. CE2102T is inapplicable because this implementation supports OPEN 


3-4 







with IN_FILE mode for DIRECT_IO. 

aa. CE2102U is inapplicable because this implementation supports RESET 
with IN_FILE mode for DIRECT_IO. 

ab. CE2102V is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for DIRECT_IO. 

ac. CE2102W is inapplicable because this implementation supports RESET 
with OUTJFILE mode for DIRECT_IO. 

ad. CE3102E is inapplicable because text file CREATE with IN_FILE mode 
is supported by this implementation. 

ae. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

af. CE3102G is inapplicable because text file deletion of an external 
file is supported by this implementation. 

ag. CE3102I is inapplicable because text file CREATE with OUT_FILE mode 
is supported by this implementation. 

ah. CE3102J is inapplicable because text file OPEN with 1N_FILE mode is 
supported by this implementation. 

ai. CE3102K is inapplicable because text file OPEN with OUT_FILE mode 
is not supported by this implementation. 

aj . CE3115A is inapplicable because this implementation does not 

support RESET to mode OUT_FILE when another internal file is 
associated with the same external file which is opened to mode 
IN FILE. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases 
where legitimate implementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

No modifications were required for any tests. 


3.7 ADDITIONAL TESTING INFORMATION 


3-5 











3.7.1 Prevalidation 


Prior to validation, a set of test results for A CVC Version 1,10 
produced by the MC-Ada Version 1.2 was submitted to the AVF by the 
applicant for review. Analysis of these results demonstrated that the 
compiler successfully passed all applicable tests, and the compiler 
exhibited the expected behavior on all inapplicable tests. 


3.7.2 Test Method 


Testing of the MC*Ada Version 1.2 compiler using ACVC Version 1.10 was 
conducted on-site by a validation team from the AVF. The configuration 
in which the testing was performed is described by the following 
designations of hardware and software components: 


Host computer: 

Host operating system: 
Target computer: 

Target operating system: 
Pre-linker: 

Linker: 


Concurrent 6600 with MC68030 CPU, 
Lightning Floating Point 
RTU Version 5.0 

Concurrent 6600 with MC68030 CPU, 

Lightning Floating Point 

RTU Version 5.0 

a. Id 

Id 


A magnetic tape containing all tests except for withdrawn tests and 
tests requiring unsupported floating-point precision was taken on-site 
by the validation team for processing. Tests that make use of 
implementation-specific values were customized before being written to 
the magnetic tape. 


TEST INFORMATION 

The contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded to disk, the full set of tests was 
compiled and linked on the Concurrent 6600 with MC68030 CPU, Lightning 
Floating Point, and all executable tests were run on the Concurrent 6600 
with MC68030 CPU, Lightning Floating Point. Results were printed from 
the host/target computer. 

The compiler was tested using command scripts provided by Concurrent 
Computer Corporation and reviewed by the validation team. See Appendix 
E for a complete listing of the compiler options for this 
implementation. The compiler options invoked during this test were: 

-M -01 (invoked by default) 

Tests were compiled, linked, and executed (as appropriate) using a 


3-6 



single computer. Test output, compilation listings, and job logs were 
captured on magnetic tape and archived at the AVF. 

3.7.3 Test Site 

Testing was conducted at Westford, MA and was completed on August 18, 
1989. 


3-7 











APPENDIX A 


DECLARATION OF CONFORMANCE 


Concurrent Computer Corporation has submitted the following 
Declaration of Conformance concerning the MC-Ada Version 1.2. 


A -1 








Appendix A 


Declaration of Conformance 


Compiler Implementer: 
Ada Validation Facility: 


ACVC Version: 


Concurre.it Computer Corporation 

U.S. Department of Commerce 

National Institute of Standards and Technology 

Gaithersburg, MD 20899 

1.10 


Base Configurations 


Base Compiler Name: 
Host Architecture: 

Target Architecture: 


MC-Ada Version 1.2 

Concurrent 6600 with MC68030 CPU, 
Lightning Boating Point, running 
RTU Version 5.0 

Same 


Base Compiler Name: MC-Ada Version 1.2 

Host Architecture: Concurrent 6600 with MC68030 CPU, 

MC68882 Boating Point, running 
RTU Vers ; on 5.0 


Target Architecture: 


Same 









Derived Compiler Registration 


Base Compiler Name: 

MC-Ada Version 1.2 

Host Architecture: 

Concurrent 6000 series with MC68030 CPU, 
Lightning Roaring Point, running 

RTU Version 5.0 

Target Architecture: 

Same 

Base Compiler Name: 

MC-Ada Version 1.2 

Host Architecture: 

Concurrent 6000 series with MC68030 CPU, 
MC68882 Floating Point, running 

RTU Version 5.0 

Target Architecture: 

Same 

Base Compiler Name: 

MC-Ada Version 1.2 

Host Architecture: 

Concurrent 5000 series with MC68020 CPU, 
Lightning Floating Point, running 

RTU Version 5.0 

Target Architecture: 

Same 

Base Compiler Name: 

MC-Ada Version 1.2 

Host Architecture: 

Concurrent 5000 series with MC68020 CPU, 
MC68881 Floating Point, running 

RTU Version 5.0 

Target Architecture: 

Same 








Implementer’s Declaration 


We, the undersigned, representing Concurrent Computer Corporation have implemented 
no deliberate extensions to the Ada Language Standard ANSI/MIL-STD-1815A In the compiler 
listed in this declaration. We declare that Concurrent Computer Corporation is the owner of 
record of the Ada language compiler listed above and, as such, is responsible for maintaining 
said compiler in conformance to ANSI/MIL-STD-1815A. All certificates and registrations for 
the Ada language compiler listed in this declaration shall be made only in the owner’s name. 

Clark D’Elia 

Director, Software Development 






Bruce Lutz 
Senior Engineer 
Languages 



Owner’s Declaration 


We, the undersigned, representing Concurrent Computer Corporation take full responsi¬ 
bility for implementation and maintenance of the Ada compiler listed above, and agree to the 
public disclosure of the final Validation Summary Report. We further agree to continue to com¬ 
ply with the Ada trademark policy, as defined by the Ada Joint Program Office. We declare that 
all of the Ada language compiler listed, and their host/target are in compliance with the Ada 
Language Standard ANSI/MIL-STD-1815A. We have reviewed the Validation Summary 
Report for the compiler and concur with the contents. 



Clark D’Elia 


Director, Software Development 



Languages 














APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
imp 1ement a tion - dependent pragmas, to certain machine - dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the MC-Ada Version 1.2 
compiler, as described in this Appendix, are provided by Concurrent 
Computer Corporation. Unless specifically noted otherwise, references in 
this appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are not 
a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -2147483648 .. 2147483647; 
type SHORT_INTEGER is range -32768 .. 32767; 
type TINY_INT£GER is range -128 .. 127; 
type FLOAT is digits 15 range 

-1.79769313486232E308 .. 1.79769313486232E308; 
type SHORT_FLOAT is digits 6 range -3.40282E38 .. 3.40282E38; 

type DURATION is delta 1.0E-3 range -2.147483648E6 .. 2.147483648E6; 


end STANDARD; 


B-l 









ATTACHMENT I 


APPENDIX F. Implementation-Dependent Characteristics 


1. Implementation-Dependent Pragmas 
1.1. INLINEONLY Pragma 

The INLINE _ONLY pragma, when used in the same way as pragma INLINE, indicates to the compiler 
that the subprogram must always be iniined. This pragma also suppresses the generation of a callable ver¬ 
sion of the routine which save code space. 

1 2 . BUILTJN Pragma 

The BUILT_IN pragma is used in the implementation of some predefined Ada packages, but provides no 
user access. It is used only to implement code bodies for which no actual Ada body can be provided, for 
example the MACHINE_CODE package. 

1 2 . SHARE_CODE Pragma 

The SHARE_CODE pragma takes the name of a generic instantiation or a generic unit as the first argument 
and one of the identifiers TRUE or FALSE as the second argument This pragma is only allowed immedi¬ 
ately at the piace of a declarative item in a declarative pan or package specification, or after a library unit 
in a compilation, but before any subsequent compilation unit. 

When the first argument is a generic unit the pragma applies to all instantiations of that generic. When the 
first argument is the name of a generic instantiation the pragma applies only to the specified instantiation, 
or overloaded instantiadons. 

If the second argument is TRUE the compiler will try to share code generated for a generic instantiation 
with code generated for other instantiations of the same generic. When the second argument is FALSE 
each instantiation will get a unique copy of the generated code. The extent to which code is shared 
between instantiations depends on this pragma and the kind of generic formal parameters declared for the 
generic unit. 

The name pragma SHARE_BODY is also recognized by the implementation and has the same effect as 
SHARE_CODE. It is included for compatability with earlier versions of VADS. 

1.4 . NO_IMAGE Pragma 

The pragma suppresses the generation of the image array used for the IMAGE attribute of enumeration 
types. This eliminates the overhead required to store the array in the executable image. 

1 2 . EXTERNAL_NAME Pragma 

The EXTERNAL_NAME pragma takes the name of a subprogram or variable defined in Ada and allows 
the user to specify a different external name that may be used to reference the entity from other languages. 
The pragma is allowed at the place of a declarative item in a package specification and must apply to an 
object declared earlier in the same package specificauon. 

1.6 . INTERFACE_NAME Pragma 

The INTERFACE_NAME pragma takes the name of a variable defined in another language and allows it 
to be referenced directly in Ada. The pragma will replace all occurrences of the variable name wuh an 
external reference to the second, link_argument. The pragma is allowed at the place of a declarative item 
in a package specification and must apply to an object declared earlier in the same package specification. 
The object must be declared as a scalar or an access type. The object cannot be any of the following: 
a loop variable, 












a constant, 

an initialized variable, 
an array, or 
a record. 

1.7 . IMPLICrr_CODE Pragma 

Takes one of the identifiers ON or OFF as the single argument. This pragma is only allowed within a 
machine code procedure. It specifies that implicit code generated by the compiler be allowed or disal¬ 
lowed. A warning is issued if OFF is used and any implicit code needs to be generated. The default is ON. 

2. Implementation of Prede^ned Pragmas 
2.1. CONTROLLED 

This pragma is recognized by the implementation but has no effect. 

2-2. ELABORATE 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 J. INLINE 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 .4. INTERFACE 

This pragma supports calls to ’C* and FORTRAN functions. The Ada subprograms can be either functions 
or procedures. The types of parameters and the result type for functions must be scalar, access or the 
predefined type ADDRESS in SYSTEM. Record and array objects can be passed by reference using the 
ADDRESS attribute. 

2 £. LIST 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 .6 . MEMO RY_SIZE 

This pragma is recognized by the implementation. The implementation does not allow SYSTEM to be 
modified by means of pragmas, the SYSTEM package must be recompiled. 

2 .7 . OPTIMIZE 

This pragma is recognized by the implementation but has no effect. 

2 .8 . PACK 

This pragma will cause the compiler to choose a non-aligned representation for composite types. It will not 
causes objects to be packed at the bit level. 

2 .9 . PAGE 

This pragma is implemented as described in Appendix B of the Ada RM. 

2.10. PRIORITY 

This pragma is implemented as described in Appendix B of the Ada RM. 

2.11. SHARED 

This pragma is recognized by the implementation but has no effect. 












2.12. STORAGE UNIT 

This pragma is recognized by the implementation. The implementation does not allow SYSTEM to be 
modified by means of pragmas, the SYSTEM package must be recompiled. 

2.13. SUPPRESS 

This pragma is implemented as described, except that RANGE_CHECK and DIVISION_CHECK cannot 
be supressed. 

2.14. SYSTEMJNAME 

This pragma is recognized by the implementation. The implementation does not allow SYSTEM to be 
modified by means of pragmas, the SYSTEM package must be recompiled. 

3. Implementation-Dependent Attributes 

3 .1. P’REF 

For a prefix that denotes an object, a program unit, a label, or an entry: 

This attribute denotes the effective address of the first of the storage units allocated to P. For a subpro¬ 
gram, package, task unit, or label, it _|g£prs to the address of the machine code associated with the 
corresponding body or statement For* entry for which an address clause has been given, it refers to the 
corresponding hardware interrupt The attribute is of the type OPERAND defined in the package 
MACHINE_CODE. The attribute is only allowed within a machine code procedure. 

See section F.4.8 for more information on the use of this attribute. 

(For a package, task unit or entry, the ’REF attribute is not supported.) 










4. Specification Of Package SYSTEM 


package SYSTEM 
i t 

typu NAkfl it ( oancaaf.«Qix ); 


SYSTEMJMfl 


ceaatiat SMC :• umcnz^.iioit; 


STORAGE .UNIT 
NtJKORY_S l ZB 


conataai :■ I; 

con uai 16.777.216; 


*• SyaUa'Dipaadiat Named Numbers 


MIN.1NT 
MOC_ INT 
M4X.DIQIT3 
NKXJMNTISSA 

pikbjdelta 

TICK 


constant ;• '2.147.463.641; 

coa.ti.t 2.147.463.647; 

constant :■ 1 5 ; 

cons t ant :■ 31; 

coBBtaat •* 

constant :■ 0.0166666; 


-* Other Syatam*dapandant Dac1 


sabtypo WICRITY n INTEGER rung* 0 99; 

MOCJtEC.SlZE : integer :• 64-1024; 


typo ADDRESS is private; 

NO. ACER : constant ADDRESS ; 


faact i on PHYS1 CAL^ACDRESS ( t: INTEGER) rat am ADDRESS ; 

function AEOR_GT(A. B: ADDRESS) ratnrn BOOLEAN; 

faact ion ACOR_LT(A. B: ADDRESS) return BOOLEAN; 

faact ion ADQR_GB(A, B: ADDRESS) ratnrn BOOLEAN; 

reaction ADDRJJK A, B: ADDRESS) ratnrn BOOLEAN; 

function ADORJDIPFfA. B: ADDRESS) ratnrn INTEGER: 

function lNCR_ADOR(A: ADDRESS; INCR: INTEGER) return ADDRESS; 

function DECRjXDRiA: ADDRESS; DECS: INTEGER) re tars ADDRESS; 

function “> a (A. B: ADDRESS) return BOOLEjW ranras ACDR GT; 

function *<*(A. B: ADDRESS) return BOOLEAN ronama ADDR.LT; 

function *>-'(A. B: ADDRESS) return BOOLEAN r enema a ACDR.GE; 

function "<■*(A, B: ADDRESS) ratnrn BOOLEAN ranamaa ADOR.LE; 

function a - a (A, B: ADDRESS) ratnrn INTEGER ranama ADORJ31PF; 

function "♦* (A: ADDRESS; INCR: INTEGER) return ADDRESS ranama INC3l_ADDR; 

function a .“(A: ADDRESS; DECR: INTEGER) return ADDRESS rename a DECR.ACDR; 

pragma ini Ue ( PHYSI CAL. ADDRESS ) ; 
pragma iai ine(ADOR_GT) ; 
pragma iniine(ADOR_LT); 
pragma ini ina(ADDR_GE); 
pragma ini ina(ADOR_LE) ; 
pragma ini ina(ADDR.DIFF); 
pragma ini ia«( INC3LADCR); 
pragma ini iae(DECR. aOCR) ; 


private 

type ADDRESS i» new integer; 
NO.ADOR : coni tant ADDRESS :• 0; 
and SYSTB4; 


5. Restrictions On Representation Clauses 
5 .1. Pragma PACK 

In the absence of pragma PACK record components are padded so as to provide for efficient access by the 
target hardware, pragma PACK applied to a record eliminate the padding where possible. Pragma PACK 
has no other effect on the storage allocated for record components a record representation is required. 

5 . 2 . Record Representation Clauses 

For scalar types a represenation clause will pack to the number of bits required to represent the range of the 
subtype. A record representation applied to a composite type will not cause the object to be packed to fit in 
the space required. An explicit representation clause must be given for the component type. An error will 
be issued if there is insufficient space allocated. 














5 3 . Address Clauses 

Address clauses are supported for variables and constants. 

5 .4. Interrupts 

Interupt entries are not supported. 

5 3 . Representation Attributes 

The ADDRESS attribute is not supported for the following entities: 

Packages 

Tasks 

Labels 

Entries 

5 .6 . Machine Code Insertions 
Machine code insertions are supported. 

The general definition of the package MACHINE_CODE provides an assembly language interface for the 
target machine. It provides the necessary record type(s) needed in the code statement, an enumeration type 
of all the opcode mneumonics, a set of register definitions, and a set of addressing mode functions. 

The general syntax of a machine code statement is as follows: 

CODE_n’( opcode, operand {, operand } ); 

where n indicates the number of operands in the aggregate. 

A special case arises for a variable number of operands. The operands are listed within a subaggregate. 
The format is as follows: 

CODE_N’( opcode, (operand [, operand})); 

For those opcodes that require no operands, named notation must be used (cf. RM 4.3(4)). 

CODE_0’( op => opcode ); 

The opcode must be an enumeration literal (i.e. it cannot be an object, attribute, or a rename). 

An operand can only be an entity defined in MACHINE_CODE or the ’REF attribute. 

The arguments to any of the functions defined in MACHINE_CODE must be static expressions, string 
literals, or the functions defined in MACHINE_CODE. The ’REF attribute may not be used as an argu¬ 
ment in any of these functions. 

Inline expansion of machine code procedures is supported. 









6. Conventions for Implementation-generated Names 
There are no implementation-generated names. 


7 . Interpretation of Expressions in Address Clauses 
Address clauses are supported for constants and variables. 


8. Restrictions on Unchecked Conversions 
None. 

9 . Restrictions on Unchecked Deallocations 
None. 

10 . Implementation Characteristics of 170 Packages 

Instantiations of DIRECTJO use the value MAX_REC_S IZE as the record size (expressed in 
STORAGE_UNITS) when the size of ELEMENT_TYPE exceeds that value. For example for uncon¬ 
strained arrays such as string where ELEMENT JTPE’SIZE is very large, MAX_REC_S EZE is used 
instead. MAX_RECORD_SIZE is defined in SYSTEM and can be changed by a program before instan¬ 
tiating DIRECTJO to provide an upper limit on the record size. In any case the maximum size supported 
is 1024 x 1024 x STORAGEJJNTT bits. DIRECTJO will raise USE_ERROR if MAX_REC_SIZE 
exceeds this absolute limit 

Instantiations of SEQUENTIAL JO use the value MAX_REC_SIZE as the record size (expressed in 
STORAGE JJNITS) when the size of ELEMENT_TYPE exceeds that value. For example for uncon¬ 
strained arrays such as string where ELEMENT_TYPE‘SIZE is very large, MAX_REC_SIZE is used 
instead. MAXJ*ECORD_SI2E is defined in SYSTEM and can be changed by a program before instan¬ 
tiating INTEGER JO to provide an upper limit on the record size. SEQUENTIAL JO imposes no limit on 
MAX_REC_SIZE. 


II. Implementation Limits 

The following limits are actually enforced by the implementation. It is not intended to imply that resources 
up to or even near these limits are available to every program. 


11.1. Line Length 

The implementation supports a maximum line length of 500 characters including the end of line character. 

11 2 . Record and Array Sizes 

The maximum size of a statically sized array type is 4,000,000 x STORAGEJJNITS. The maximum size 
of a statically sized record type is 4,000,000 x STORAGE_UNITS. A record type or array type declaration 
that exceeds these limits will generate a warning message. 

11 2 . Default Stack Size for Tasks 

In the absence of an explicit STORAGE_SIZE length specification every task except the main program is 
allocated a fixed size stack of 10E40 STORAGE_UNTTS. This is the value returned by 
T’STORAGE_SIZE for a task type T. 

11.4. Default Collection Size 

In the absence of an explicit STORAGE JJIZE length attribute the default collection size for an access type 
is 100 times the size of the designated type. This is the value returned by T’STORAGE_SIZE for an 










access type T. 

11 .5. Limit on Declared Objects 

There is an absolute limit of 6,000,000 x STORAGE_UNITS for objects declared statically within a compi¬ 
lation unit If this value is exceeded the compiler will terminate tne compilation of the unit with a FATAL 
error message. 












APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


C-l 












ATTACHMENT III 

Values Needed as Parameters for the “ .TST” Tests 


-- M4CRO.DEFS 

-- THIS FILE CONTAINS THE MACRO DEFINITIONS USED IN THE ACVC TESTS. 

-- THESE DEFINITIONS ARE FOR; 

-- NC-Ada Veriion 1.2 

-- $M4X_IN_LEN 

-- AN INTEGER LITERAL GIVING THE MAXIMLM LENGTH PERMITTED BY THE 
-• COMPILER FOR A LINE OF ADA SOURCE CODE (NOT INCLUDING AN END-OF-LINE 
- - CHARACTER) . 

-- USED IN: A26007A 
M4X_IN_LEN 499 

-- SBIG_ID1 

-- AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX IN LEN. 

USED IN: C23003A C23003B C23003C B23003D B23003E C23003G 

C23003H C23003I C23003J C35502D C35S02F 

BIG_ID1 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 


aaaaaaaaaaaaaaaaaaaaaaaaaa1 
-- SBIG_IP2 

-- AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX_IN_LEN, 

-• DIFFERING FRCM SBIG.IDl CNLY IN THE LAST CHARACTER. 

-- USED IN: C23003A C23003B C23003C B23003F C23003G C23003H 

C23003I C23003J 

BI G_ ID2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/aaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaa2 

-- SBIG_ID3 

-- AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX IN LEN. 

-- USED IN: C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 

BIG_ID3 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

aaaaaaaaaaaaaaaaa3aaaaaaaaaaaaaaa/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

aaaaaaaaaaaaaaaaaaaaaaaaaaa 

•• SBIG.ID4 

-- AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX IN LEN. 

-- DIFFERING FRCM SBIG.ID3 CNLY IN THE NODDLE CHARACTER. 

-- USED IN: C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 

BIG_ID4 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 














AAAAAAAAAAAAAAAAAAA 


- - SBIG STRING1 

-- A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH SBIG STRING! 

-- (SBIG STRING1 A SBIG STRING!) PRODUCES THE IMAGE OF SBIG Idi , 

•- L'SED IN: C35S02D C35502F 

8IG_STRINGt " AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAA 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 


•- SBIG STRING2 

•• A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH SBIG STRING1 
-- (SBIG_STRING1 St SBIG.STRING2) PRODUCES THE IMAGE OF SBIG IDI. 

-- USED IN: C3J502D C35502F 

BIG_STRING2 " AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa. AAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 ” 

-- SMAX_STRING_LITERAL 

-- A STRING LITERAL CCNSISTING OF SMAX_IN LEN CHARACTERS (INCLUDING THE 
- - QUOTE CHARACTERS). 

-- USED IN: A26007A 

MAX_STRING_LITERAL "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 


-- SNEG_BASED_INT 

-- A BASED_INTEGER LITERAL (PREFERABLY BASE 8 OR 16) WHOSE HIGHEST ORDER 
-- NON-ZERO BIT WOULD FALL IN THE SIGN BIT POSITION OF THE 
.. REPRESENTATION FOR SYSTEM.MAX.INT, I.E. , AN ATTEMPT TO WRITE A 
-- NEGATIVE VALUED LITERAL SUCH AS -2 BY TAKING ADVANTAGE OF THE 
- - BIT REPRESENTATION. 

-• USED IN: E24201A 
NEG_BASED_INT 16#FFFFFFFD# 

SBIG_INT_LIT 

-- AN INTEGER LITERAL WHOSE VALUE IS 298, BUT WHICH HAS 
-- (SMAX_IN_LEN - 3) LEADING ZEROES. 

-- USED IN: C24003A 

BIG_INT_LIT 00000000000000000000000000000000000000000000000000000000000000000000 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 

00000000000000000000000000000000000000000000000000000000000000000000000000000000 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 

00000000000000000000000000000000000000000000000000000000000000000000000000000000 

00000000000000000000000000000000000000000000000000003000000000000000000000000000 

0000000000000000000000000000298 

SBIG_REAL_LIT 

-- A UNIVERSAL_REAL LITERAL WHOSE VALUE IS 690.0. BUT WHICH HAS 
-- (SMAX IN LEN - 5) LEADING ZEROES. 

-- USED IN: C24003B C24003C 

BIG_REAL_LIT 

00000000000000000000000000000000000000000000000000000000000000000000030000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
OGOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOCOOOOOOO 
000000000000069.0E1 

-- SMAX_LEN_INT BASED LITERAL 

-- A BASED INTEGER LITERAL (USING COLONS) WHOSE VALUE IS 2:11:, HAVING 
-- (SMAX IN.LEN - J) ZEROES BETWEEN THE FIRST COLON AND THE FIRST 1. 

-- USED IN: C2A009A 

MAX_LEN_INT_BASED_LITERAL 2:0000000000000000000000000000000000000000000000000000 
OOOOOOOOOOQOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOQOOOOOOOOOOOOOOOOOOOOOOO 











ooooooooooeocooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 

OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOoOOOOOOOOO000000000 
00000000000000000000000000000000000000000000000OOOOOOOOOOOOOOOOOOOOOOOOOOC000000 
00000000000000000000000000000000000000000011 : 

- - SMAX LLN REAL BASED LITERAL 

-- A BASED REAL LITERAL (USING COLON’S) WHOSE VALUE IS 16:F . E:, HAVING 
-- (iMAX IN LEN - 7) ZEROES BETWEEN THE FIRST COLON AND THE F. 

- - USED r N: C2A009A 

MAX.LEN.REAL.BASED LITERAL 16:OOOOOOOOOOOOOOOOUOOOOOOOOOCOOOOOOOOOOOOOOOOOOOCOOO 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 
oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 

OOOOOOOOOOOOOOOOOOOGOOOOOOOOOOOOOOOOOOOOOOF.E: 


- 5BLANKS 

■ A SEQUENCE OF (SMAX_IN LEN 

- USED IN: B23001A B22001B 

B22001G B22001I 

B22001N 

< LIMITS OF SAMPLE SHOWN BY ANGLE 

BLANKS 


20) BLANKS. 
B22001C B22001D 

B22001J B22001K 


B22001E 

B22001L 

BRACKETS 


B22001F 

B22001M 


> 


-- SMAX.DIGITS 

-- AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX.DIGITS. 

-- USED IN: B35701A CD7102B 
MAX.DIGITS 15 

-- SNAME 

-• THE NAME OF A PREDEFINED INTEGER TYPE OTHER THAN INTEGER. 

-- SHORT INTEGER. OR LCNG INTEGER. 

-- (IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE .AN UNDEFINED 
-- IDENTIFIER SUCH AS NO SUCH TYPE AVAILABLE.) 

-- USED IN: AVAT007 C45231D B86001X 
NAME TINY_ INTEGER 

- - SFLOAT NAME 

-- THE NAME OF A PREDEFINED FLOATING POINT TYPE OTHER THAN FLOAT. 

-- SHORT FLOAT. OR LONG FLOAT. (IMPLEMENTATIONS WHICH HAVE NO SUCH 
-- TYPES SHOULD USE AN UNDEFINED IDENTIFIER SUCH AS NO SUCH.TYPE.) 

-- USED IN: aVATO13 B86001Y 

FLOAT.NAME NO.SUCH.FIXED.TYPE 

- - SFIXED NAME 

-- THE NAME OF A PREDEFINED FIXED POINT TYPE OTHER THAN DURATION. 

-- (IMPLEMENTATIONS WHICH HAVE NO SUGI TYPES SHOULD USE AN UNDEFINED 
-- IDENTIFIER SUCH AS NO SUCH T YPE. , 

-- USED IN: AVaTO30 B86001Z 

FIXED.NAME NO.SUCH.TYPE 

-• SINTEGER.FIRST 

-- AN INTEGER LITERAL, WITH SIGN’. 'WHOSE VALUE IS INTEGER'FIRST. 

-- USED IN: C35503F B54B0I8 

INTEGER.FIRST - 2_147.483.648 

-- 5INTEGER.LAST 

-- AN INTEGER LITERAL WHOSE VALLE IS INTEGER' LAST, 

-• USED IN: C35J03F B45232A B45B0IB 

INTEGER LAST 2 147 483.647 


S INTEGER.LAST.PLUS.1 

AN INTEGER LITERAL WHOSE VALUE IS INTEGER'LAST * 1 














-- USED IN: C4J232A 
INTEGER.LAST.PLUS,1 2,147,483,648 

-- SMI N_INT 

-- AN INTEGER LITERAL, WITH SICN, WHOSE VALUE IS SYSTEM.MIN INT. 

-- THE LITERAL MUST NOT CONTAIN UNDERSCORES OR LEADING OR TRAILING 
-- BLANKS. 

-- USED IN: C35503D C35503F CD7101B 

MIN_INT -2147483648 

-- SMAX_INT 

-- AV INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX INT. 

- - THE LITERAL MIST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 
-- BLANKS. 

-- USED IN: C35503D C35S03F C4A007A CD710IB 

MAX_INT2147483647 

-- SMAX_INT_PLUS_1 

-- AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX_INT * 1. 

-- USED IN: C4S232A 
MAX_INT_PLUS _12,147,483,648 

- - SLESS.THAN.DURATION 

-• A REAL LITERAL (WITH SIGN) WHOSE VALUE (NOT SUBJECT TO 
-- ROUND-OFF ERROR IF POSSIBLE) LIES BETWEEN DURATION - BASE• FIRST .AND 
-- DURATION - FIRST. IF NO SUCH VALUES EXIST. USE A VALLE IN 
-- DURATION'RANGE. 

-- USED IN: C960058 
LESS_THAN_DURATICN -100_000.0 

- - SGR£ATER_THAN DURATION 

- - A REAL LITERAL WHOSE VALUE (NOT SUBJECT TO ROUND-OFF ERROR 

-- IF POSSIBLE) LIES BETWEEN DURATION - BASE' LAST AND DURATION - LAST. IF 
-- NO SUCH VALUES EXIST. USE A VALUE IN DURATION’RANGE. 

-- USED IN: C96005B 
GREATER_THAN_DURATION 100,000.0 

-- SLESS_THAN_DURATICN_BASE FIRST 

-- A REAL LITERAL (WITH SIGN) WHOSE VALLE IS LESS THAN 
-- DURATICN’BASE'FIRST. 

-- USED IN: C96005C 

LESS_THAN_DURATICN_BASE_FIRST -10_000_000 

- ■ SGREATER_THAN_DURATION BASE LAST 

-- A REAL LITERAL WHOSE VALUE IS GREATER THAN DURATION - BASE’LAST. 

-- USED IN: C96005C 

GREATER_THAN_DURATION_BASE_LAST 10_000_000 

-- S COUNT. LAST 

-- AN INTEGER LITERAL WHOSE VALUE IS TEXT_IO. OOUNT' LAST. 

-- USED IN: CE3002B 
COUNT_LAST 2.147,483,647 

-- SFI ELD,LAST 

-- AN INTEGER LITERAL WHOSE VALUE IS TEXT IO.FIELD - LAST. 

-- USED IN: CE3002C 
FIELD.LAST 2,147,483.647 

-- SILLEGAL.EXTERNAL.FILE.NAMEl 

-- AN IL LEGA L EXTERNAL FILE .NAME (E.G.. TOO LONG, CONTAINING INVALID 
-- CHARACTERS, CONTAINING WILD-CARD CHARACTERS, OR SPECIFYING A 
-- NONEXISTENT DIRECTORY). 

-- USED IN: CE2103A CE2102C CT2102H CE2103B CE3102B CE3107A 

ILLEGAL.EXTERNAL.FILE.NAMEl '/illegil/fil e.nune / 2 ( ] S?»2102C.DAT" 

-- SILLEGAL.EXTERNAL FILE NAME2 

-- AN ILLEGAL EXTERNAL FILE NAME, DIFFERENT FROM SEXTERNAL FILE NAME1 . 
-- USED IN: CE2102C CE2102H CE2103A CE2103B 

ILLEGAL_EXTERNAL_FILE_NAME2 ’/i11eg»l/f i 1e.nime/CE2102C*.DAT* 


SACC.SIZE 












-- AN INTEGER LITERAL WHOSE VALUE IS THE MINIMUM NUMBER OF BITS 
-- SUFFICIENT TO HOLD ANY VALUE OF AN ACCESS TYPE. 

-- USED IN: CD1C03C CD2A8 1A CD2A8 1B CD2A81C CD2A8ID C32A8 1E 

CD2A81F CD2A81G CD2A83A CD2A83B CD2A63C CD2A83E 

CD2A83F CD2A83G ED2A86A CD2A87A 

ACC.SIZE 32 

-- STASK.SIZE 

-- AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

-- HOLD A TASK OBJECT WHICH HAS A SINGLE ENTRY WTTH ONE IVYT PARAMETER. 

-- USED IN: CD2A91A CD2A91B CD2A91C CD2A9ID CD2A91E 

TASK_SIZE 32 

-- SMIN_TASK_SIZE 

-- AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

-- HOLD A TASK OBJECT WHICH HAS NO ENTRIES, NO DECLARATIONS, AND "NULL;" 

-- AS THE ONLY STATEMENT IN ITS BODY. 

-- USED IN: CD2A95A 
MIN_TASK_SIZE 32 

- - SNAME LIST 

-- A LIST OF THE ENUMERATION LITERALS IN THE TYPE SYSTEM.NAME, SEPARATED 
-- BY COVMAS. 

- - USED IN: CD7003A 

NAME.LIST MASSCOAP.UNIX 

-- SDEFAULT SYS_NAME 

-- THE VALUE OF THE OCNSTANT SYSTEM. SYSTEM_NAME. 

-- USED IN: CD7004A CD7004C CD7004D 

DEFAULT_SYS_NAME MASSCCMP.UNIX 

-- SNBV.SYS.NAME 

-- A VALUE OF THE TYPE SYSTEM.NAME, OTHER THAN SDEFAULT SYS NAME. IF 
-- THERE IS ONLY ONE VALUE OF THE TYPE. THEN USE THAT VALUE. 

- - NOTE: IF THERE ARE MORE THAN TWO VALUES OF THE TYPE. THEN THE 

PERTINENT TESTS ARE TO BE RUN ONCE FOR EACH ALTERNATIVE. 

-- USED IN: ED7004B1 
NEW_.SYS.NAME MASSCCMP.UNIX 

-- SDEFAULT STOR.UNIT 

-- AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.STORAGE UNIT. 

-- USED IN: CD7005B ED7005D3M CD7005E 

DEFAULT.STORJJNIT 8 

-- SNEW.STOR.UNIT 

-- AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 
-- PRAGMA STORAGE_UNIT, OTHER THAN SDEFAULT STOR UNIT. IF THERE 
-- IS NO OTHER PERMITTED VALUE, THEN USE THE VALLE OF 
-- SSYSTEM. STORAGE .UNIT. IF THERE IS MORE THAN ONE ALTERNATIVE. 

-- THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR EACH ALTERNATIVE. 

-- USED IN: ED7005C1 ED7005D1 CD7005E 

NEW. STOR.UNIT 8 

-- SDEFAULT.MEM.SIZE 

-- AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MEMORY SIZE. 

-- USED IN: CD7006B ED7006D3M CD7006E 

DEFAULT J*EM_SIZE 16.777.216 

-• SNBV.MEM.SIZE 

-- AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 
-■ PRACMA MEMORY SIZE. OTHER THAN SDEFAULT^MEM SIZE. IF THERE IS NO 
-- OTHER VALUE. THEN USE SDEFAULT.MEM SIZE. IF THERE IS .ACRE THAN 
-- CKE ALTERNATIVE, THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR 
-- EACH ALTERNATIVE. IF THE NUMBER OF PERMITTED VALUES IS LARGE, THEN 
-• SEVERAL VALUES SHOULD BE USED, COVERING A WIDE RANGE OF 
-- POSSIBILITIES. 

-- USED IN: ED7006C1 ED7006D1 CD7006E 

NEW_MEM_SIZE 16.777.216 

-- SLOW.PRIORITY 

-• AN INTEGER LITERAL WHOSE VALUE IS THE LOWER BOUND OF THE RANGE 










-- FOR THE SUBTYPE SYSTEM. PRIORITY. 

- - USED IN: CD7007C 
LCW_ PRIORITY 0 

-- SHIuH PRIORITY 

-- AN INTEGER LITERAL WHOSE VALUE IS THE UPPER BOUND OF THE RANGE 
-- FOR THE SUBTYPE SYSTEM. PRIORITY. 

-- USED IN: C337007C 
HIGH_PRIORITY 99 

-- SMANTISSA DOC 

- AN INTEGER LITER*' WHOSE value IS SYSTEM.MAX_MANTISsA AS SPECIFIED 
-- IN TOE IMPLEMENTOR’S DOCUMENTATION. 

-- USED IN: CD7103B CD7103D 

MANTISSA_DOC 31 

-- STICK 

-- A REAL LITERAL WHOSE VALUE IS SYSTEM.TICK AS SPECIFIED IN THE 
-- IMPLEMENTOR’S DOCUMENTATION. 

-- USED IN: CD7104B 
TICK 0.0166666 





APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84M & N, & CD50110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for task termination; this is 
not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 


D-2 












i 


CD2B15C & CD7205C 

These tests expect that a 'STORAGE_SIZE length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the ’SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERR0R is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer 
to STANDARD INPUT (lines 103, 107, 118, 132, & 136). 


D-3 











CE3411S 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 
will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 







APPENDIX E 


Compiler: 
ACVC Version: 


COMPILER OPTIONS AS SUPPLIED BY 
Concurrent Computer Corporation 


MC-Ada Version 1.2 

1.10 


E-1 










Ada Command Directives 

The only option used with the Ada command during the validation was the -M option. 

Ada Library Info Directives 

Two different INFO directives were used to prepare the validation results. The directives, specified 
In the a da .lib file, are used to control the type of floating point instructions generated. 

The following directive generates floating point instructions that are executed on the MC6888] co¬ 
processor. 


FLOATING_POINT_SUPPORT:INFO:MC68881: 

To generate floating point instructions that are executed on the LIGHTNING co-processor, the fol 
lowing directive was placed In the ada.lib file. 

FLOATING_POINT_SUPPORT:INFO:LIGHTNING; 


( 


July 18.1989 


1 











ada — Ada compiler 
Syntax 

ada [ options ) [ ada_sourct.a ] ... \ldj 3 pti 0 ns ) [object_/iit.o) . . . 

Description 

The command ada executes the Ada compiler and compiles the named Ada 
source file, ending with the .a suffix. The file must reside in a VaDS library 
directory. If the source file name has the form aaatbbb.a, aaa must be a VADS 
library directory. The ada.llb file in this directory is modified after each Ada 
unit is compiled. 

All files created and modified are located in subdirectories of the directory that 
contains the ada_source.a file. The object program is left in a file with the 
same name as that of the source with .0 substituted for .a unless the -o option 
is used. The object file is written to the .objects subdirectory of the VADS 
library. 

By default, ada produces only object and net files. If the -M option is used, the 
compiler automatically invokes a.ld and builds a complete program with the 
named library unit as the main program. 

Non-Ada object files (e.g., .0 files produced by the C or FORTRAN compiler) 
may be given as arguments to ada. These files will be passed on to the linker 
and will be linked with the specified Ada object files. 

Command line options may be specified in any order, but the order of 
compilation and the order of the files to be passed to the linker can be 
significant. 

Options 

-a fikjiame (archive) Treat filename as an ar file. Since archive files end 
with .a, -a is used to distinguish archive files from Ada 
source files. 

-d (dependencies) Analyze for dependencies only. Do not do 

semantic analysis or code generation. Update the library, 
marking any defined units as uncompiled. The -d option is 
used by a.make to establish dependencies among new files. 

-e (error) Process compilation error messages using a.error and 

direct it to stdout. Only one -e or -E option should be used. 






-E 

-E file 
-E directory 


-el 


-El 

-El file 
-El directory 


-ev 


(error output) Without a file or directory argument, ada 
processes error messages using a.error and directs the output 
to stdout; the raw error messages are left in source.err. If a 
file pathname is given, the raw error messages are placed in 
that file. If a directory argument is supplied, the raw error 
output is placed in dlr/source.err. Only one -e or -E option 
should be used. 

(error listing) Intersperse error messages among source lines 
and direct to stdout. 


(error listing) Same as the -E option, except that source 
listing with errors is produced. 

(error vi) Process the raw error messages using a.error, 
embed them in the source file, and call vi on the source file. 


-\file_abbreviation 

(link) Link this library' file. (Do not space between the -1 and 
the file abbreviation.) Set Id(l). 

-M unit_name (main) Produce an executable program using the named unit 
as the main program. The unit must be either a parameterless 
procedure or a parameterless function returning an integer. 
The executable program will be left in the file a.out unless 
overridden with the -o option. 

-M adajource.a 

(main) Like -M unitjiame , except that the unit name is 
assumed to be the root naqje of the .a file (e.g., for foo.a the 
unit is foo). Only one .a file may be preceded by -M. 

-o executableJile 

(output) This option is to be used in conjunction with the -M 
option, executable Jile is the name of the executable rather 
than the default a.out. 


-0(1-9] (optimize) Invoke the code optimizer. An optional digit limits 

the number of optimization passes. The default, 0. optimizes 
as far as possible. 

-R VADSJibrary 

(recompile instantiation) Force analysis of all generic 
instantiations, causing reinstantiation of any that are out of 
date. 





ada 


-S (suppress) Apply pragma SUPPRESS to the entire 

compilation. 

-T (timing) Print timing information for the compilation. 

-u (update) Cause library status to reflect the current program 

source. Unless the source is syntactically incorrect, the 
compiler updates the library ada.lib. Normally, the library is 
changed only if the unit compiles without errors of any kind. 

-v (verbose) Print compiler version number, date and time of 

compilation, name of file compiled, command input line, total 
compilation time, and error summary line. 

-w (warnings) Suppress warning diagnostics. 

FUes 
file.a 

/tmp/flle.$$ 
ada.lib 
gnrx.lib 
GVAS^table 
ada.lock 
gnrx.lock 

GVAS_table.LOCK 

See Also 

a.db, a.error, a.ld, a.mklib, ld(3) 

Diagnostics 

The diagnostics produced by the VADS compiler are intended to be 
self-explanatory. Most refer to the RM. Each RM reference includes a section 
number and optionally, a paragraph number enclosed in parentheses. 


Ada source input file 
IL code file created by front end 
VADS directory information file 
VADS generics library information file 
GVAS table in the current VADS project 
lock link to ada.lib, for mutual exclusion 
lock generics library, for mutual exclusion 
lock link to GVAS table, for mutual exclusion 




