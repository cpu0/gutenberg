REPORT DOCUMENTATION PAGE 

FOrm Approved 

OPMNo. 

Public reporting hurdan tor IN* eoftae f\ | /\ ~y "9 the time lor reviewing inetruclione, Marching anting data eouroee grihering 

end meMeining the date needed, ertc ~ v *“■ ** ... • 'n'-'j Ml > burden aatimda or any othar aapad oi thie ooHaction ol inhumation, including 

•uggaatioo* lor radioing lhi» burden, | ta|l|U III! Ml! lilll III ||i| 1|| l||| |l ationa and Heporte. IMS Jefferaon Deni Hqhttm/. Suita 1204, Arlington. VA 

22202-4302. and to the Oftioeol Inter 1 IIUll llil 111) ill 111: lilt lilll 111! til' Mngton. DC 20603. / -% 

1 . AGENCY U6£ (LSS75 - 

3. REPORT TYPE AND DATES / 1 

Final: 18 Mar 1992 to 01 Jun 1993 

4. TITLE AND 

Validation Summary Report: Tartan, Inc., Tartan Ada SPARC 680X0 Version 
4.2, Sun SPARCstation/ELC (Host) to Motorola MVME 134 
(MC6820)(Target), 92031311.11246 

5. FUNDING 

6. 

IABG-AVF 

Ottobrunn, Federal Republic of Germany 

7. PERFORMING ORGANIZATION NAME(S) AND 

IABG-AVF, Industrieanlagen-Betriebsgeselschaft 

Dept. SZT/ Einsteinstrasse 20 

D-3012 Ottobrunn 

FEDERAL REPUBLIC OF GERMANY 

8. PERFORMING 

ORGANIZATION 

IABG-VSR 85 

9. SPONSORING/MONITORING AGENCY NAME(S) AND 

Ada Joint Program Office 

United States Department of Defense 

Pentagon, Rm 3E114 | __ t 

Washington, D.C. 20301-3081 || | J 

10. SPONSORING/MONITORING 

AGENCY 

\ 

y 

" su ™ TARy g% ELECTE |% 

VJUL°61992 |1 


12a. DI^TRIBUTION/AVAILABILITY £1 WK0 

Approved for public release; distribution unlimited. 

12b. DISTRIBUTION 

13. (Maximum 200 

Tartan, Inc., Tartan Ada SPARC 680X0 Version 4.2, Sun SPARCstation/ELC (Host) to Motorola MVME 134 
(MC6820)(Target), ACVC 1.11. 

liiiiiifi 

** u ^ ou£ 

iTsubject 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, 

is. Number of 

16. PRICE 

17. SECURITY 118. SECURITY 119. SECURITY 

CLASSIFICATION 1 1 CLASSIFICATION 

UNCLASSIFIED UNCLASSIFED | UNCLASSIFIED 

20. LIMITATION OF 


MSN Standard Form 296, (Rav. 2-80) 

Praacribad by ANSI Sid. 











THIS 

PAGE 

IS 

MISSING 

IN 

ORIGINAL 

DOCUMENT 

A WKO\&e/i Of tRtyiiAi- 
pfl^es /Me f*\iss/#j 






Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 13 March, 1992. 


Compiler Marne and Version: 
Host Computer System: 
Target Computer System: 


Tartan Ada SPARC 680X0 version 4.2 

Sun SPARCstation/ELC under SunOS Version 4.1.1 

Motorola MVME134 (MC6820, bare machine) 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
92031311.11246 is awarded to Tartan, Inc. This certificate 
expires 24 months after ANSI approval of MIL-STD 1815B. 


This report has been reviewed and is approved. 

iXu JLc^ \ 

«aUi.. Vffin » 


IABG, Abt. ITE 
Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 


Ada ValidatK'onAOrganization 

Director,Computer & Software Engineering Division 
Institute for 7 Defense Analyses 
Alexandria VA 22311 




Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 


Aoesssi on For 

ins qrjwi 
OTIC TAB' 
Unannounced 
Justification. 



By--- 

Distribution / 

_Availability Codsa* 

r vall and/or 
Special 


□ □ 







AVF Control Number: 


IABG-VSR 85 
18 (torch, 1992 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 92031311.11246 
Tartan, Inc. 

Tartan Ada SPARC 680Z0 version 4.2 
Sun SPARCatation/ELC *> 
Motorola KVME134 (MC6820) 


Prepared By: 
IABG mbH, Abt. ITE 
Eineteinatr. 20 
W-8012 Ottobxunn 
Germany 







Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 13 March, 1992. 

Compiler Marne and Version! Tartan Ada SPARC 680X0 version 4.2 

Host Computer Systems Sun SPARCstation/ELC under SunOS Version 4.1.1 

Target Computer Systemt Motorola MVME134 (MC6820, bare machine) 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort, Validation Certificate 
92031311.11246 is awarded to Tartan, Inc. This certificate 
expires 24 months after ANSI approval of MIL-STD 1815B. 


This report has been reviewed and is approved. 


iXu JLJ! 


IABG, Abt. ITE 



Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 



Ada Va 
Director, 
Institute' 
Alexandria 



n Organisation 


puter & Software Engineering 
Defense Analyses 
22311 


Division 


Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 




DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the customer. 

Declaration of Conformance 
Customer: Tartan, Inc. 

Certificate Awardee: Tartan, Inc. 

Ada Validation Facility: IABG mbH 
ACVC Version: 1.11 
Ada Implementation: 

Ada Compiler Name and Version: Tartan Ada sparc 680X0 version 4.2 

Host Computer System: SPARC S tation/ELC SunOS version 4.1.1_ 

Target Computer System: Motorola MVME134 (MC68020) (bare machine) 

Declaration: 

I, the undersigned, declare that I have no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MI L-STD-1815A ISO 8652-1987 in the 
implementation listed above. 

/{. /ffe 

Date 



Customer Signature 



TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1: 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-2 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS. 2-3 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 
















CHAPTER 


1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) giveB an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act” (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1.2 REFERENCES 

[Ada83] BligEgnSE LflPflUaflg> 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validat ion Procedures. Version 2.1, Ada Joint 
Program Office, August 1990. 

[UG89] Ada Compiler Validation Capability UserGuide, 21 June 1989. 


1-1 






INTRODUCTION 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test name identifies the class to 
which it belongs. Class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Tdentity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (Bee section 2.1), and 
possibly removing some inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


The means for testing compliance of Ada implementations, 
consisting of the test suite, the support programs, the ACVC 
user's guide and the template for the validation summary 
report. 


Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 


Ada Joint 


The part of the certification body which provides policy and 


1-2 





Program 
Office (AJPO) 

Ada 

Validation 
Facility (AVF) 

Ada 

Validation 
Organization 
(AVO) 

Compliance of 
an Ada 

Implementation 

Computer 

System 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


XNTMOOCTXOai 


guidance for the Ada certification system. 


The part of the certification body which carries out the 
procedures required to establish the compliance of an Ada 
implementation. 

The part of the certification body that provides technical 
guidance for operations of the Ada certification system. 


The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 

Fulfillment by a product, process, or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANS1/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 


1-3 






INTRODUCTION 


Validation Tha process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

Withdrawn A test found to be incorrect and not uaed in conformity 

test testing. A test may be incorrect because it has an invalid 

test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


t 


i 


I 


1-4 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 02 August 1991. 


E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

C35S08M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B63022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD70P5E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L..Y 

(14 

tests) 

C35705L..Y 

(14 

tests) 

C35706L..Y 

(14 

tests) 

C35707L..Y 

(14 

tests) 

C35708L..Y 

(14 

tests) 

C35802L..Z 

(15 

tests) 

C45241L..Y 

(14 

tests) 

C45321L..Y 

(14 

tests) 

C45421L..Y 

(14 

tests) 

C45521L..Z 

(15 

tests) 

C4S524L..Y 

(15 

tests) 

C45621L..Z 

(15 

tests) 

C45641L..Y 

(14 

tests) 

C46012L..Z 

(15 

tests) 


2-1 





IMPLEMENTATION DEPENDENCIES 


The following 20 testa check for the predefined type LONG_INTEGER; for 
this implementation, there is no such type: 


C3S404C 

C4S502C 

C45613C 

C5SB07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C4S304C 

C45S04C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

BS2004D 

CD7101F 


C35713B, C45423B, B86001T, and C86006H check for the predefined type 

SHORT FLOAT; for this implementation, there is no such type. 


C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 


C4S531M..P and C45S32M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain length clauses 
that specify values for 'SMALL that are not powers of two or ten; this 
implementation doeB not support such values for 'SMALL. 


C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base 
type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this implementation, there is no such type. 


CA2009A, CA2009C..D (2 tests), CA2009F and BC3009C instantiate 

generic units before their bodies are compiled; this implementation 
creates a dependence on generic units as allowed by AI-0408 £ AI-0506 
such that the compilation of the generic unit bodies makes the instan¬ 
tiating units obsolete, (see 2.3.) 

CD1009C checks whether a length clause can specify a non-default size 
for a floating-point type; this implementation does not support such 

sizes. 




CD2A53A checks operations of a fixed-point type for which a length 
clause specifies a power-of-ten TYPE'SMALL; this implementation does 
not support decimal 'SMALLs. (See section 2.3.) 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this implementation 
does not support such sizes. 

CD2B15B checks that STORAGEJERROR is raised when the storage size 
specified for a collection is~too small to hold a single value of the 
designated type; this implementation allocates more space than was 
specified by the length clause, as allowed by AI-00558. 

The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files: 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 1 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) J 

CE2110A..D 

(4) 

CE2111A..I 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) i 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE220SA 

CE2206A 

CE2208B 

i 

CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2’03A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 

CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) i 


i 


2-2 







IMPLEMENTATION DSPKNDXKCXKS 


CE2410A..8 

(2) 

CE2411A 


CE3102A..C 

(3) 

CS3102F. .H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CB3107B 

CE3108A..B 

(2) 

CE3109A 

CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 

CE3119A 


EE3203A 

EB3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 

EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 

CE3411A 


CE3411C 


CE3412A 

EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


• CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 

CE3706F. .G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 

CE3906A..C 

(3) 

CE3906E..F 

(2) 

CE2103A, CE2103B, 

and CE3107A expect that NAME 

! ERROR is raised 

when an 

attempt is 

made 

to create 

a 

file with 

an 

illegal name; this 


implementation does not support the creation of external files and so 
raises USE_ERROR. (See section 2.3.) 


2.3 TEST MODIFICATIONS 

Modifications (see Section 1.3) were required for 111 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B24007A 

B24009A 

B25002B 

B32201A 

B33204A 

B33205A 

B35701A 

B36171A 

B36201A 

B37101A 

B37102A 

B37201A 

B37202A 

B37203A 

B37302A 

B38003A 

B38003B 

B38008A 

B38008B 

B38009A 

B38009B 

B38103A 

B38103B 

B38103C 

B38103D 

B38103E 

B43202C 

B44002A 

B48002A 

B48002B 

B48002D 

B48002E 

B48002G 

B48003E 

B49003A 

B49005A 

B49006A 

B49006B 

B49007A 

B49007B 

B49009A 

B4A010C 

B54A20A 

B54A25A 

B58002A 

B58002B 

B59001A 

B59001C 

B59001I 

B62006C 

B67001A 

B67001B 

B67001C 

B67001D 

B74103E 

B74104A 

B74307B 

B83E01A 

B85007C 

B85008G 

B85008H 

B91004A 

B91005A 

B95003A 

B95007B 

B95031A 

B95074E 

BA1001A 

BC1002A 

BC1109A 

BC1109C 

BC1206A 

BC2001E 

BC3005B 

BD2A06A 

BD2B03A 

BD2D03A 

BD4003A 

BD4006A 

BD8003A 





E28002B was graded inapplicable by Evaluation and Test Modification 
as directed by the AVO. This test checks that pragmas may have 
unresolvable arguments, and it includes a check that pragma LIST has 
the required effect; but, for this implementation, pragma LIST has no 
effect if the compilation results in errors or warnings, which is the 
case when the test is processed without modification. This test was 
also processed with the pragmas at lines 46, 58, 70 and 71 commented 
out so that pragma LIST had effect. 

Tests C45524A..K (11 tests) were graded passed by Test Modification 
as directed by the AVO. These tests expect that a repeated division 
will result in zero; but the Ada standard only requires that the 
result lie in the smallest safe interval. Thus, the tests were 
modified to cheek that the result was within the smallest safe 
interval by adding the following code after line 141; the modified 
tests were passed: 

ELS IF VAL <- F' SAFE_SMALL THEN COMMENT ("UNDERFLOW SEEMS GRADUAL"); 


2-3 







IMPLEMENTATION DEPENDENCIES 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting "PRAGMA 
ELABORATE (REPORT);" before the package declarations at lines 13 and 
11, respectively. Without the pragma, the packages may be elaborated 
prior to package report's body, and thus the packages' calls to 
function Report.Ident Int at lines 14 and 13, respectively, will raise 
PROGRAM_ERROR. 

B83E01B was graded passed by Evaluation Modification as directed by 
the AVO. This test checks that a generic subprogram's formal parameter 
names (i.e. both generic and subprogram formal parameter names) must 
be distinct; the duplicated names within the generic declarations are 
marked as errors, whereas their recurrences in the subprogram bodies 
are marked as "optional" errors—except for the case at line 122, 
which is marked as an error. This implementation does not additionally 
flag the errors in the bodies and thus the expected error at line 122 
is not flagged. The AVO ruled that the implementation's behavior was 
acceptable and that the test need not be split (such a split would 
simply duplicate the case in B83E01A at line 15). 

CA2009A, CA2009C..D (2 tests), CA2009F and BC3009C were graded 
inapplicable by Evaluation Modification as directed by the AVO. These 
tests instantiate generic units before those units' bodies are 
compiled; this implementation creates dependences as allowed by AI- 
00408 & AI—00506 such that the compilation of the generic unit bodies 
makes the instantiating units obsolete, and the objectives of these 
tests cannot be met. 

BC3204C and BC3205D were graded passed by Processing Modification as 
directed by the AVO. These tests check that instantiations of generic 
units with unconstrained types as generic actual parameters are 
illegal if the generic bodies contain uses of the types that require 
a constraint. However, the generic bodies are compiled after the units 
that contain the instantiations, and thiB implementation creates a 
dependence of the instantiating units on the generic units as allowed 
by AI—00408 & AI-00506 such that the compilation of the generic bodies 
makes the instantiating units obsolete—no errors are detected. The 
processing of these tests was modified by compiling the seperate files 
in the following order (to allow re-compilation of obsolete units), 
and all intended errors were then detected by the compiler: 

BC3204C: CO, Cl, C2, C3M, C4, C5, C6, C3M 
BC3205D: DO, DIM, D2, DIM 

BC3204D and BC3205C were graded passed by Test Modification as 
directed by the AVO. These tests are similar to BC3204C and BC3205D 
above, except that all compilation units are contained in a single 
compilation. For these two tests, a copy of the main procedure (which 
later units make obsolete) was appended to the tests; all expected 
errors were then detected. 

CD2A53A was graded inapplicable by Evaluation Modification as directed 
by the AVO. The test contains a specification of a power-of-ten value 
as small for a fixed-point type. The AVO ruled that, under ACVC 1.11, 
support of decimal smalls may be omitted. 

AD9001B and AD9004A were graded passed by Processing Modification as 
directed by the AVO. These tests check that various subprograms may 
be interfaced to external routines (and hence have no Ada bodies). 
This implementation requires that a file specification exists for the 
foreign subprogram bodies. The following command was issued to the 
Librarian to inform it that the foreign bodies will be supplied at 
link time (as the bodies are not actually needed by the program, this 
command alone is sufficient): 

Interface -sys -L»library ad9001b & ad9004a 


2-4 





CK2103A, CB2103B and CK3107A were graded Inapplicable by Valuation 
Modification as directed by the A VO. The tests abort with an unhandled 
exception when USB ERROR is raised on the attempt to create an 
external file. This Is acceptable behavior because this implementation 
does not support external files (cf. AI-00332). 


2-5 




CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

Por technical information about this Ada implementation, contact: 

Mr Ron Duursma 
Director of Ada Products 
Tartan, Inc. 

300 Oxford Drive 
Monroeville, PA IS146 
USA 

Tel. (412) 856-3600 


For sales information about this Ada implementation, contact: 

Ms. Marlyse Bennett 
Director of Sales 
Tartan, Inc. 

12110 Sunset Hills Road 
Suite 450 
Reston, VA 22090 
OSA 

Tel. (703) 715-3044 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customised test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 








floating-point precision that exceeds tha implementation's maximum 
praciaion (itam a; aaa aaction 2 . 2 ), and thoaa that dapand on tha aupport 
of a file system — if none ia supported (item d). All taata paaaad, except 
thoaa that are listed in sections 2.1 and 2.2 (counted in itams b and f, 
below). 


a) Total Number of Applicable Testa 3552 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicable Tests 58 

d) Non-Processed I/O Tests 264 

e) Non-Processed Floating-Point 

Precision Tests 201 


f) Total Number of Inapplicable Tests 523 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic data cartridge containing the customized test suite (see section 1.3) 
was taken on-site by the validation team for processing. The contents of 
the magnetic data cartridge were loaded directly onto the host computer. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target computer 
system by the communications link, an RS232 Interface, and run. The results 
were captured on the host computer system. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were for compiling: 

-f forces the compiler to accept an attempt to compile a unit 
imported from another library which is normally prohibited. 

-c suppresses the creation of a registered copy of the source 

code in the library directory for use by the REMAKE and MAKE 
subcommands. 

-La forces a listing to be produced, default iB to only produce a 
listing when an error occurs. 

No explicit Linker options were used. 


Test output, compiler and linker listings, and job logs were captured on 
magnetic data cartridge and archived at the AVF. The listings examined on-site 
by the validation team were also archived. 


3-2 








MACRO PARAMETERS 


APPENDIX A 
MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string~aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 

$MAX_IN_LEN 240 

$BIG_ID1 (1..V-1 *> 'A', V -> '1') 

$BIG_ID2 (1..V-1 «> 'A', V ■> '2') 

SBIG 103 (1..V/2 «> 'A') & '3' & 

(1..V-1-V/2 «> 'A') 

$BIG_ID4 (1..V/2 «> 'A') & '4' & 

(1..V-l-V/2 «> 'A') 

$BIG_INT_LIT (1..V-3 »> '0') & *298" 

$BIG_REAL_LIT (1..V-5 «> '0') & "690.0" 

$BIG_STRING1 & (1..V/2 «> 'A') 6 

$BIG_STRING2 6 (1..V-l-V/2 «> 'A') 6 '1' 6 

$BLANKS (1..V-20 «> ' ') 

$MAX_LEN_XNT BASED LITERAL 

"2s" S (1..V-5 -> '0') 6 "11:" 

$MAX LEN REAL BASED LITERAL 

"16:" S (1..V-7 »> '0') & "F.E:" 

SMAX STRING LITERAL & (1..V-2 ■> 'A') & 


A—1 







The following table lists all of tha other macro parasieters and their 
respective values. 


Macro Parameter 

Macro Value 

$ACC_SIZE 

32 

$ALIGNMENT 

4 

$ COUNT_LAS T 

2147483646 

$DEFAULT_MEM_SIZE 

1_000_000 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

MC68020 

$DELTA_DOC 

2#1.0/E-31 

$ENTRY_ADDRESS 

SYSTEM.ADDRESS'(16#F0#) 

$ENTRY_ADDRESS1 

SYSTEM.ADDRESS'(16#F1#) 

$ENTRY_ADDRESS2 

SYSTEM.ADDRESS'{16#F2#) 

$FIELD_LAST 

240 

S FILE_TERMINATOR 

9 9 

$FIXED_NAME 

NO_SUCH_TYPE 

$FLOAT_NAME 

NO_SDCH_TYPE 

$FORM_STRING 

m w 

SFORM_STRING2 

"CANNOT_RESTRICT_FILE_C 

SGREATER THAN DURATION 


100_000.0 


SGREATER THAN DURATION BASE LAST 

Too_o5o_ooo.o 

r 

SGREATER THAN FLOAT BASE LAST 

~ 1.5E+39 

SGREATER THAN FLOAT SAFE LARGE 

l.SE+38 

SGREATER THAN SHORT FLOAT SAFE LARGE 

1.0E+38 “ 

$HIGH_PRIORITY 200 

SILLEGAL EXTERNAL FILE NAME1 

Tllegal_external_file_namei 

SILLEGAL EXTERNAL FILE NAME2 

ILLEGAL_EXTERNAL_FILE_NAME 2 

$INAPPROPRIATE LINE LENGTH 

-1 

$INAPPROPRIATE PAGE LENGTH 

~ -1 




MACRO PARAMETERS 


$INCLUDE_PRAGMA1 
$ INCLUDE_PRAGMA2 
$INTBGER_FIRST 
$INTEGER LAST 


PRAGMA INCLUDE 
PRAGMA INCLUDE 
-2147483648 
2147483647 


$INTECER_LAST_PLUS_1 2147483648 
$INTERFACE_LANGUAGE C 

$LESS_THAN_DURAT10N -100_000.0 
$LESS_THAN DURATION BASE FIRST 

~ -lfto 000 000.0 


("A28006D1.TST") 
("B28006F1.TST") 


$LINE_TERMINATOR ' * 

$LOW_PRIORITY 10 

5MACHINE CODE STATEMENT 

Two_Opnda*(MOVE_L,(IMM, 2),(ARIDEC,al)); 


$MACHINE_CODE_TYPE 
SMANT ISS A_DOC 
$MAX_DIGITS 
SMAX_INT 
$MAX_INT_PLUS_1 
$MIN INT 


Addreas_Mode 

31 

15 

2147483647 

2147483648 

-2147483648 


$NAME 
$NAME_LIST 
$NEG_BASED_INT 
$ NEW_MEM_SIZE 
$NEW_STOR_UNIT 
$NEW_SYS_NAME 
$ PAGE_TERMINATOR 
$R£CORD_DEFINITION 

$RECORD_NAME 
$TASK_SI2E 
$TASK_STORAGE_SIZE 
STICK 

$VARIABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLE ADDRESS2 


BYTE_INTEGER 

MC68020 

8*777777777776# 

1_0°°_ 000 

8 

MC68020 


record Operation: Instruction_Mnemonic; 
Operand_l: operand; end record; 

One_Opnda 

96 

4096 

0.01 

SYSTEM.ADDRESS'(16#C0000#> 

SYSTEM.ADDRESS'(16#C0004#) 

SYSTEM.ADDRESS'(16#C0008#) 


A-3 






APPENDIX B 


COMPILATION AND LINKER SYSTEM OPTIONS 


The compiler and linker options of this Ada implementation, as described 
in this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 




APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation- 
dependent pragmas, to certain machine-dependent conventions as mentioned 
in Chapter 13 of the Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of 
this Ada implementation, as described in this Appendix, are provided by 
the customer. Unless specifically noted otherwise, references in this 
Appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, are outlined 
below for convenience. 


package STANDARD is 

type BYTE INTEGER is range -128 .. 127; 

type SHOR? INTEGER is range -32768 .. 32767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647 ; 

type FLOAT is digits 6 range -16#0.FFF FFF#E+32 .. 16#0.FFF FFF#E+32; 
type LONG FLOAT is digits 15 range -16?0.FFFF FFFF FFFF_F8#E+256 .. 
l£#0.FFFF_FFFF_FFFF_F8#E+2 5 6 ; 

type DURATION is delta 0.0001 range -66400.0 .. 86400.0; 

e • • 

end STANDARD; 


C-l 



Chapter 4 

Compiling Ada Programs 


The tada680x0 command is used to compile and assemble Ada compilation units. 

4.1. THE t ada 6 8 0x0 COMMAND FORMAT 

The t ada 6 8 0x0 command has this format: 

% tada680x0 [option...] /lie... [option^.] 

tada680x0 invokes the MC680X0-targeted compiler. Replace the “x” in tada680x0 with the ap¬ 
propriate digit to specify the target processor for which the compiler is to generate object code. tada68020 
specifies the MC68020 processor. tada68030 specifies the MC68030 processor. tada68040 specifies the 
MC68040 processor. 

Arguments that start with a hyphen are interpreted as options; otherwise, they represent filenames. There 
must be at least one filename, but there need not be any options. Options and filenames may appear in any order, 
and all options apply to all filenames. For an explanation of the available options, see Section 4.2. 

If a source file does not reside in the directory in which the compilation takes place, the file must include a 
path sufficient to locate the file. It is recommended that only one compilation unit be placed in a file. 

If no extension is sup; : 4th die file name, a default extension of . ada will be supplied by the compiler. 

Files are processed in me order in which they appear on the command line. The compiler sequentially 
processes all compilation units in each file. Upon successful compilation of a unit: 

• The library data b ase. Lbrry. Db, is updated with the new compilation time and any new dependencies. 

• One or more separate compilation files and/or object files are generated. 

If no errors are detected in a compilation unit, tadaSSOxO produces an object module and updates the library. 
.I any error is detected, no object code file is produced, a source listing is produced, and no library entry is made 
for that compilation unit If warnings are generated, both an object code file and a source listing are produced. 
For further details about the process of updating the library, files generated, replacement of existing files, and 
possible error conditions, see Sections 43 through 43. 

The output from tada680x0 is a file of type . stof or . tof, for a specification or a body unit respec¬ 
tively. containing object code. Some other files are generated as well. See Section 4.4 for a list of extensions of 
files that may be generated. 

The compiler is capable of limiting the number of library units that become obsolete by recognizing 
refinements. A library unit is a refinement of its previously compiled version if the only changes that were made 
are: 


• Addition or deletion of comments. 

• Addition of subprogram s p ec ifi catio n s after the last declarative item in the previous version. 

An option is required to cause the compiler to detect refinements. When a refinement is detected by the 
compiler, dependent units are not marked as obsolete. 


4>1 




COMPILING ADA PROGRAMS 


-Mw 


-Opn 


P 


-r 


-S[ACDEILORSZ] 


that has incorrect address modes. An error message is issued for any incorrect 
machine code insertion. With the default, the compiler attempts to generate extra 
instructions to fix incorrect address modes in the array aggregates operand field. 

The compiler attempts to generate extra instructions to fix incorrect address 
modes. A warning message is issued if such a fixup is required. With the default, 
the compiler attempts to generate extra instructions to fix incorrect address modes 
in the array aggregates operand field. 

Control the level of optimization performed by the compiler, requested by n. The 
optimization levels available are: 

n « 0 Minimum • Performs context determination, constant folding, 
algebraic manipulation, and short circuit analysis. 

n * 1 Low * Performs level 0 optimizations plus common subexpres¬ 
sion elimination and equivalence propagation within basic 
blocks. It also optimizes evaluation order. 

n m 2 Best tradeoff for space/time - the default level. Performs level 
1 optimizations plus flow analysis which is used for common 
subexpression elimination and equivalence propagation across 
basic blocks. It also performs invariant expression hoisting, 
dead code elimination, and assignment killing. Level 2 also 
performs lifetime analysis which is used to improve register al¬ 
location. It also performs inline expansion of subprogram calls 
indicated by pragma inline, if possible. 

n * 3 Time • Performs level 2 optimizations plus inline expansion of 
subprogram calls which the optimizer decides are profitable to 
expand (from an execution time perspective). Other optimiza¬ 
tions which improve execution time at a cost to image size are 
performed only at this level. 

Extracts syntactically correct compilation unit source from the parsed file and 
loads this file into the library as a parsed unit. Parsed units are, by definition, 
inconsistent. This switch allows users to load units into the library without regard 
to correct compilation order. The command remakecu is used subsequently to 
reorder the compilation units in the correct sequence. See Section 9.2.5 for a 
more complete description of this command. 

Data on this switch is provided for information only. This switch is used ex¬ 
clusively by the librarian to notify the compiler that the source undergoing com¬ 
pilation is an internal source file. The switch causes the compiler to retain old 
external source file information. This switch should be used only by the librarian 
and command files created by the librarian. See Section 3.6.1. 

Suppress the given set of checks: 

A ACCES S_CHECK 

C CONSTRAINT CHECK 

D DISCRIMINANT CHECK 

E ELABORATION CHECK 

I INDEX CHECK" 

L LENGTH CHECK 

0 OVERFLOW CHECK 

R RANGE CHECK 

S STORAGE CHECK 

Z "ZERO" DIVISION CHECK 


4-3 






1 



Chapter 5 

Appendix F to MIL-STD-1815A 


This chapter the required Appendix F to the LRM which is Military Standard, Ada Programming 

Language, ANSI/MIL-STD-1815A (American National Standards Institute. Inc_ February 17,1983). 

5.1. PRAGMAS 

5.1.1. Predefined Pragmas 

This section summarizes the effects of and restrictions on predefined pragmas. 

• Access collections are not subject to automatic storage reclamation so pragma CONTROLLED has no effect. 
Space deallocated by means of UNCH£CK£D_DEALLOCATlON will be reused by the allocation of new 
objects. 

• Pragma ELABORATE is supported. 

• Pragma INLINE 

• Pragma interface is supported. It is assumed that the foreign code interfaced adheres to Tartan Ada 
calling conventions as well as Tartan Ada parameter passing mechanisms. Any other Language_Name 
will be accepted, but ignored, and the default will be osed. 

• Pragma LIST is supported but has the intended effect only if the command line option -La was supplied 
for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma memory_S I ZE is supported. See Section 5.1.3. 

• Pragma OPTIMIZE is supported except when at the outer level (that is, in a package specification or 
body). 

• Pragma PACK is supported. 

• Pragma PAGE is supported but has the intended effect only if the command line option -La was supplied 
for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma PRIORITY is supported. 

• Pragma STORAGE_unit is accepted but no value other than that specified in package System (Section 
S3) is allowed. 

• Pragma shared is not supported. 

• Pragma SUPPRESS is supported. 

• Pragma SYSTEM name is accepted but no value other than that specified in package System (Section 
S3) is allowed. ~ 

5JJ2. Implementation-Defined Pragmas 

Implementation-defined pragmas provided by Tartan are described in the following sections. 


5-1 





APPENDIX F TO MH.-STD-1815A 


pragma must be given prior to any declarations within the package specification. If the pragma is not located 
before the first declaration, or any lestricboo on the declarations is violated, the pragma is ignored and a warning 
isgenerated. 

The foreign body is entirely responsible for initialing objects declared in a package utilizing pragma 
FORE I GN_BODY . In particular, the user should be aware that the implicit initializations described in LRM 3.2.1 
are not done by the co m pile r . (These implicit initializatioos are with objects of access types, certain 

record types and composite types containing comp o nent s of the preceding kinds of types.) 

Pragma linkage_name should be used for all declarations in the package, including any declarations in a 
nested package speci fi cation to be sure that there are no conflicting link names. If pragma linkage_name is 
not used, the cross-reference qualifier, -x, (see Section 42) should be used when invoking the compiler and the 
resulting cross-reference table of Hnknames i ns pe ct ed to identify the linknames assigned by the compiler and 
determine that there are no conflicting linknames (see alsc Section 4.6). In the following example, we want to 
call a function plan which computes polynomials and is written in C. 

package Math_Functions is 
pragma foreign_BODY ("C"); 

function POLYNOMIAL (X: INTEGER) return INTEGER; 

— Ada spec matching the C routine 
pragma LINKAGE_NAM£ (POLYNOMIAL, "plmn”); 

— Force compiler to use name -plmn" when referring to this 

— function 

— Note: The linkage name "plmn" may need to be "_plmn", 

— if the C compiler produces leading underscores 

— for external symbols. 

end Math_Functions; 

with Math_Functions; use Math__Functions? 

procedure MAIN is 

X:INTEGER POLYNOMIAL(10); 

— Will generate a call to "plmn" 

begin ... 

end MAIN; 

To compile, link and run the above program, you do the following steps: 

1. Compile Math_Functions 

2. Compile MAIN 

3. Provide the object module (for example, math.tof) containing the compiled “C” code for plmn, 
convened to Tartan Object File Fonnat (TOFF); if the module is written in assembly code, for example, 
using the ien«2t utility (See Object File Utilities, Chapter 4) 

4. Issue the command: 

t adalib680x0 foreign Math_Functions math.tof 

3. Issue the command: 

% adalib680x0 link main 

Without Step 4, an attempt to link will produce an error message informing you of a missing package body for 
Ma th_Funct ions. 

Using an Ada body from another Ada pragma library. The user may compile a body written in Ada for a 
specification into the library, rega r dless of the language specified in the pragma contained in the specification. 
This capability is useful for rapid prototyping, where an Ada package may serve to provide a si mu la ted response 
far the functionality that a foreign body may eventually produce. It also allows the user to replace a foreign body 
with an Ada body without recompiling the specification 

The user can either compile an Ada body into the library, or use the co mm and adalibS 80 x 0 foreign 
(see Sections 32.3 red 9.5.7) to uae an Ada body from another library. The Ada body from another library must 


5-3 








ATTENVU P TO tCL^TD-ISl JA 


5.42. Length Clauses 

Length clauses (LRM 13.2) are, in general, su pported. The following sections detail use and restrictions. 

SA2J. Size Specifications for Types 

The rules and restrictions for sire specifications applied to types of various classes are described below. 

The following principle roles apply: 

1. The sire is specified in bits and must be given by a static e xp ress io n . 

2. Hie specified sire is taken as a mandate to store objects of the type in the given sire wherever feasible. 
No attempt is made to store values of the type in a smaller sire, even if possible. The following roles 
apply with regard to feasibility: 

• An object that is not a component of a compo sit e object is allocated with a sire and alignment that 
is referable on the target machine; that is, no attempt is made to create objects of non-referable sire 
on the stack. If such stack compression is desired, it can be achieved by the user by combining 
multiple stack variables in a composite object; for example: 

type My_Enum is (A,B); 
for My_enuxn'size use 1; 

V,W: My_enum; — will occupy two storage 

— units on the stack 

— (if allocated at all) 
type rec is record 

V,W: My_enum.- 
end record; 
pragma PACK(rec); 

O: rec; — will occupy one storage unit 

• A formal parameter of the type is sized according to calling conventions rather than sire specifica¬ 
tions of the type. Appropriate size conversions upon parameter passing take place au t o m a ti cally 
and are transparent to the user. 

• Adjacent bits to an object that is a component of a composite object, but whose size is non- 
referable. may be affected by assignments to the object, unless these bits are occupied by other 
components of the composite object; that is, whenever possible, a component of non-referable size 
is made referable. 

In all cases, the compiler generates correct code for all operations on objects of the type, even if they are 
stored with differing representational sizes in different contexts. 

Note: A sire specification cannot be used to force a certain sire in value operations of the type; for 
example: 

type my_int ia range 0..65535; 
for my_Tnt'size use 16; — o.k. 

A, B: nsy_int; 

...A~+ B... — this operation will generally be 
— executed on 32-bit values 

3. A sire specification for a type specifies the size for objects of this type and of all its subtypes. For 
components of composite types, whose subtype would allow a shorter representation of the component, 
no attempt is made to take advantage of such shorter representa tions. In contrast, for types without a 
length clause, such co mp one n ts may be re p resen ted in a lesser number of bits than the number of bits 
required to represent all values of the type. For example: 


5-5 



APPENDIX F TO VHL-STO-1H5A 


A size specification cannot be applied to a record type with components of dynamically determined size. 

Note: Size specifications for records can be used only to widen the representation accomplished by padding at 
the beginning or end of the r ecord. Any narrowing erf the rep r esen ta tion over default type mapping must be 
accomplished by rep r esen tation clauses or pragma PACK. 

5A23. Specification of Collection Sim 

The specification of a collection size causes the collection to be allocated with the specified size. It is 
expressed in storage units and need not be static; refer to package System for the meaning of storage units. 

Any attempt to allocate more objects than the collection can hold causes a storage_error exception to be 
raised. Dynamically sized records or arrays may carry hidden administrative storage requirements that must be 
accounted for as part of the collection size. Moreover, alignment constraints on the type of the allocated objects 
may make it impassible to use all memory locations of the allocated collection. No matter what the requested 
object size, the allocator must allocate a minimum of 2 words per object This lower limit is necessary for 
administrative overhead in the allocator. For example, a request of 5 words results in an allocation of 5 words; a 
request of 1 word results in an allocation of 2 words. 

In the absence of a specification of a collection size, the collection is extended automatically if more objects 
are allocated than possible in the collection originally allocated with the compiler-established default size. In (his 
case. STORAGE_ERROR is raised only when the available target memory is exhausted. If a collection size of 
zero is specified, no access collection is allocated. 

SA2.6. Specification of Task Activation She 

The specification of a task activation size causes the task activation to be allocated with the specified size. It 
is expressed in storage units; refer to package System for the meaning of storage units. 

Any attempt to exceed the activation size during execution causes a STORAGE_ERROR exception to be 
raised. Unlike collections, there is no extension of task activations. 

5.42.7. Specification of ' SMALL 

Only powers of 2 are allowed for' SMALL. 

The length of the representation may be affected by this specification. If a size specification is also given for 
the type, the size specification takes precedence; it must then be possible to accommodate the specification of 
' SMALL within the specified size. 

5.43. Enumeration Representation Clauses 

For enumeration representation clauses (LRM 13.3), the following restrictions apply. 

• The internal codes specified for the literals of the enumeration type may be any integer value between 
INTEGER' FIRST and INTEGER' LAST. It is strongly advised to not provide a representation clause that 
merely duplicates the default mapping of enumeration types, which assigns consecutive numbers in as¬ 
cending order starting with 0, since unnecessary runtime cost is incurred by such d upl icatio n . It should be 
noted that the use of attributes on enumeration types with user-specified encodings is costly at run time. 

• Array types, whose index type is m enumeration type with noo-contiguous value encodings, consist of a 
contiguous sequence of com p onents. Indexing into the may involves a runtime translation of the index 
value into the co rr es ponding position value of the enumeration type. 

5.4.4. Record Representation Clauses 

The alignment clause of record represe n tatio n clausa (LRM 13.4) is observed. 

Static objects may be aligned M pow ers at 2 19 to a page boundary. The specified align ment b ecomes the 
minimum rfifUMw of the meow ! type, the minimum alignment of the record forced by the co m p on e n t 







APPENDIX F TO ML-STD-1I15A 


5.4.6J. Pragma PACK for Records 

If pragma PACK is applied to a record, the densest possible representation is chosen that is compatible with 
the sizes and alignment co n st r ai n ts of the individual component types. Pragma PACK has an effect only if the 
sizes of some component types are specified explicitly by size specifications and are of noo-referable nature. In 
the absence of pragma PACK, such components generally consume a referable amount of space. 

It should be noted that the default type mapping far records maps components of boolean or other types that 
require only a single bit to a single bit in the record layout, if there are multiple such components in a record. 
Otherwise, it al l ocates a referable amount of storage to the component. 

If pragma PACK is applied to a record for which a record representation clause has been given detailing the 
allocation of some but not all components, the pragma PACK affects only the components whose allocation has 
not been de ra iled . Moreover, the strategy of not utilizing gaps between explicitly allocated components still 
applies. 

5.4.7. Minimal Alignment for Types 

Certain alignment properties of values of certain types are enforced by the type mapping rules. Any represen¬ 
tation specification that cannot be satisfied within these constraints is not obeyed by the compiler and is ap¬ 
propriately diagnosed. 

Alignment constraints are caused by properties of the target architecture, most notably by the capability to 
extract non-aligned component values from composite values in a reasonably efficient manner. Typically, 
restrictions exist that make extraction of values that cross certain address boundaries very expensive, especially 
in contexts involving array indexing. Permitting data layouts that require such complicated extractions may 
impact code quality on a broader scale than merely in the local context of such extractions. 

Instead of describing the precise algorithm of establishing the minimal alignment of types, we provide the 
general rule that is being enforced by the alignment rules: 

• No object of scalar type including components or subcomponents of a composite type, may span a target- 
dependent address boundary that would mandate an extraction of the object’s value to be performed by two 
or more extractions. 

5.5. IMPLEMENTATION-GENERATED COMPONENTS IN RECORDS 

The only implementation-dependent components allocated by Tartan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record. These components cannot be named by the user. 

5.6. INTERPRETATION OF EXPRESSIONS APPEARING IN ADDRESS CLAUSES 

Section 13.5.1 of the Ada Language Reference Manual describes a syntax for associating interrupts with task 
entries. Tartan Ada implements the address clause 

for toentry use at intXD; 

by associating the interrupt specified by intID with the toentry entry of the task containing this address 
clause. The interpretatio n of intXD is both machine and compiler dependent 

The Motorola 680X0 specification provides 256 interrupts that may be associated with task entries. These 
interrupts are identified by an integer in the range 0..255, corresponding to the interrupt vector numbers in 
Section 92 of the MC68040 32-Bit Microprocessor User's Manual. When you specify an interrupt address 
clause, the intXD argument is interpreted as follows: 

• If the argument is in the range 0-255, a full support intemipt association is made between the interrupt 
spe cif ied by the argument and the task entry. That is, the runtimes make no assumptions about the task in 
question. This method is the slower. 

• If the argument is in the range 256-511, a fast interrupt association is made between the interrupt number 
( ar g u me nt- 256) and the task entry. This method provides faster execution became the runtimes can 
depend upon the assumptions previously described. 


5-9 







APPENDIX F TO ML-STD-lllJA 


5 S3. Implementation-Defined Characteristics in Package STANDARD 
The imptencnapoo-dependcm characteristics in package STANDARD (Annex Q are: 
package standard ii 

type BYTE_INTEGER is range -128 .. 127; 

type SHORT_INTEGER is range -32768 .. 32767; 

type INTEGER is range -2_147 483 648 .. 2 147 483 647; 

type FLOAT is digits 6 range -r6#07FFFFFF#E+32 7. 16*0 .FFFFFF8E+32 

type LONG FLOAT is digits 9 range -1680. FFFFFFFFFFFFF8#E+256 .. 

T6 # 0.FFFFFFFFFFFFF8♦E+2 56 ; 
type DURATION is delta 0.0001 range -86400.0 .. 86400.0; 

• • « 

end STANDARD; 

5S.4. Attributes of Type Duration 

The type duration is defined with the following characteristics: 


Attribute 

Value 

DURATION'DELTA 

0.0001 sec 

DURATION'SMALL 

6.103516E’ 3 sec 

DURATION'FIRST 

•86400.0 sec 

DURATION'LAST 

86400.0 sec 


5-11 








APPENDIX FTOMIL-CTD-1I15A 


5.9.6. Values of Floating-Point Attributes 

Tartan Ada supports the predefined floating-point types FLOAT and LONG_FLOAT. 


Attribute 

Value for FLOAT 

DIGITS 

6 

MANTISSA 

21 

EMAX 

84 

EPSILON 

16#0.1000_00#E-4 (approximately 9.53674E-07) 

SMALL 

16#0^000_00#E-21 (approximately 2^8494E-26) 

LARGE 

1640JFFF_F8#E+2l (approximately 1.93428E+25) 

SAFE_EMAX 

126 

SAFE_SMALL 

16#0-2000_000#E-31 (approximately 5.87747E-39) 

SAFE_LARGE 

16#03FFF_FE0#E+32 (approximately 830706E+37) 

FIRST 

-16#0JTFFFF#E+32 (approximately -3.40282E+38) 

LAST 

16#0 JFFFFF#E+32 (approximately 3.40282E+38) 

MACHINE_RADIX 

2 

MACHINE_MANTISSA 

24 

MACHINE_EMAX 

128 

MACHINE_EMIN 

-125 

MACHINE__ROUNDS 

TRUE 

MACHINE_0 ,r ERFLOWS 

TRUE 


5-13 





APPENDIX FTOMIL-STD-ltlJA 


5 . 10 . SUPPORT FOR PACKAGE MACHINE_CODE 

Package machine CODE provides the programmer with an interface to request the generation of any 
instruction that is available on the MC68020, MC68881. MC68882, MC68030 and MC68040 processors. Hie 
implementation of machine_code is similar to that described in Section 13.8 of (he Ada LRM, with 

several added features. Please refer to Appendix A for the Package MACHINE_CODE specificatio n . 

SJ0.1. Basie Information 

As requited by LRM, Section 13.8, a routine which contains m»rhiw» code inserts may not have any other 
kind of statement, and may not contain an exception handler. The only allowed declarative item is a ns* clause. 
Comments and pragmas are allowed as usual. 

SJ02. Instructions 

A machine code insert has the form TXPE_MARK' R£CCRD_AGGREGATE, where the type must be one of the 
records defined in package MACHXNE_CODE. Package MACHXNE_CODE defines seven types of records. Each 
has an opcode and zero to 6 operands. These records are adequate for the expression of all instructions provided 
by the 680X0. 

5.10J. Operands and Address Modes 

An operand consists of a record aggregate which holds all the information to specify it to the compiler. All 
operands have an address mode and one or more other pieces of information. The operands correspond exactly to 
the operands of the instruction being generated. 

Each operand in a machine code insert must have an AddressJdode. The address modes provided in package 
MACHINE_CODE provide access to all address modes supported by the 680X0. 

In addition, package MACHlNE_CODE supplies the address modes Symbolie_Address and 
Symbolic_Vaiue which allow the user to refer to Ada objects by specifying Object' ADDRESS as the value 
for the operand. Any Ada object which has the 'ADDRESS attribute may be used in a symbolic operand. 
SymboIie_Address should be used when the operand is a true address (for example, a branch target). 
Symbolic_Value should be used when the operand is actually a value (for example, one of the source 
operands of an ADD instruction). 

When an Ada object is used as a source operand in an instruction (that is, one from which a value is read), the 
compiler will generate code which fetches the value of the Ada object When an Ada object is used as the 
destination operand of an instruction, the compiler will generate code which uses the address of the Ada object as 
the destination of the instruction. 

5.10.4. Examples 

The implementation of r* rira E* MACHlNE__CODE makes it possible to specify both simple machine code 
inserts such as: ~ 

TwojOpnds'(MOVEQ, (lam, 3), (DR, DO)) 
and more complex inserts such as 

Two_Opnd»'(ADDI_L, 

(Xn»n,”l0), 

(Symbolic_Valu«, Array_Var(X, X, 27)'ADDRESS)) 

In the first example, the compiler will emit the instruction MOVEQ 3, DO. In the second example, the 
compiler will first emit whatever instructions are needed to form the address of Array_Var (X, X, 27) and 
then emit the ADDI_L instruction. The various error c h ecks specified in the LRM will be performed on all 
compiler-generated code unless they are s up pr es sed by the programmer (either through pragma SUPPRESS, or 
through command qualifiers). 


5-15 







APPENDIX F TO MZL-5TD-1I15A 


• All ocher operands are interpreted as directly specifying the destination for the ope rat ion. 

5J0.7. Register Usage 

The compiler may need several registers to generate code for operand corrections in machine code inserts. If 
you use all the registers, corrections will not be possible. In general, when more registers are available to the 
compiler it is able to generate better code. 

Since the compiler may need to allocate registers as temporary storage in machine code routines, there are 
some restrictions placed on your register usage. The compiler will automatically free all registers which are 
volatile across a call for your use (that is DO, Dl, AO, Al, FpO, Fpl). 

If you reference any other register, the compiler will reserve it for your use until the end of the machine code 
routine. The compiler will not save the register automatically if this routine is inline expanded. This means that 
the first refe re n ce to a register which is not volatile across calls should be an instruction which saves its value in a 
safe place. 

The value of the register should be restored at the end of the machine code routine. This rale will help ensure 
correa operation of your machine code insert even if it is inline explained in another routine. However, the 
compiler will save the register automatically in the prolog code for the routine and restore it in the epilog code for 
the routine if the routine is not inline expanded. 

5.10.8. Data Directives 

Four special instructions are included in package Machine_Code to allow the user to place data into the 
code stream. These four instructions are DATA8, DATA16, DATA.32 and DATA64. Each of these instructions 
can have from 1 to 6 operands. 

DATA8 and DATA16 are used to place 8-bit and 16-bit integer data items into the code stream. 

DAT A3 2 is used to place 32-bit data into the code stream. The value of an integer, a floating point literal, or 
the address of a label or a routine are the legal operands (Le. operands whose address mode is either ism. 
Float_Lit_Single, or Symbolic_Addreas of an Ada objea). 

« LI » 

Three_ppnds'(DATA32, ( Symbol ic_Address, LI'Address ), 

(Float Lit_Single, 2.0), 

(lam, ” 99)); 

will produce a code sequence such as: 

LI: .long LI 

.long 1073741824 I 0.2el 

.long 99 

DATA64 is used to place a 64-bit data into the code stre am . The only legal operand is a floating literal (Le 
operand whose address mode is FIoat — Lit_5ingle or Float_Lit_Double). 

5.10.9. Inline Expansion 

Routines which contain machine code inserts may be inline expanded into the bodies of other routines. This 
may happen under programmer control through the use of pragma inline, or with -op-3 when the compiler 
selects that optimization as an appropriate action for the given situation. The compiler will treat the m ac hine 
code insert as if it were a call. Volatile registers will be saved and r est o re d around it and similar optimizing steps 
will be taken. 


5-17 




APJ’B'TDDCFTO VCL-5TD-1113A 


• la Address Modes in which two displacements are allowed only base displacement can be re pre se n t ed by a 
symbolic address. Outer displacement must be an integer. For example, this operand is legal: 

(MEMPOST2, Bd MEMPOST2 *> Some Routine'ADDRESS, — base displacement 

An~MEMPOST2 -> AO, 

XnJ<EMPOST2 »> DO, 

Xn_Size_MEMPOST2 ■> Long, 

Scale_M£MPOST2 •> One, 

Od_MEMPOST2 •> 16) — outer Displacement 

while the following operand is illegal: 

(MEMPOST2, Bd MEMPOST2 -> Routine 1'ADDRESS, —base displacement 

An_MEMPOST2 -> AO, 

Xn_MEMPOST2 -> DO, 

Xn~Size_MEMPOST2 ■> Long, 

Scale_MEMPOST2 -> One, 

Od_MEMPOST2 -> Routine^'ADDRESS) —outer Displacement 

• PC-relative Address Modes with a suppressed base register field can sometimes be handled incorrectly by 
the current implementation of the compiler. 

• Extended precision floating point literals are not supported. 

5.10.12. Address_Mode Usage 

• Addressing modes that accept 16 or 32-bit displacements are represented by two entries in package 
Machine_Code’s Address_Mode enumeration: one that accepts an integer, and one that accepts a 
symbolic address. For example. Memory Indirect Pre-Indexed addressing mode is represented by MEMPRE 
and MEMPRE2 Address Modes. 

• DARI (Data or Address Register Indirect) Address.Mode is provided exclusively for use with operands 

. five and six of the CAS 2 instruction. 

• ARXDX (Address Register Indirect with Index and Displacement) Address.Mode represents both the 8-hit 
displacement and the base displacement sub-modes of the Address Register Indirect with Index addressing 
mode. The compiler will pick the most economical form. 

• PCZDX (Program Counter Indirect with Index and Displacement) Address_Mode represents both die 
8-bit displacement and the base displacement sub-modes of the Program Counter Indirect with Index 
addressing mode. The compiler will pick the most economical form. 

5.10.13. lnstruction_Sfnemonic Usage 

• Instruction_Mneaonic names in package Machine_Code are farmed by concatenating the base 
instruction name with a suffix representing the size of the instruction. For example, cmp_b, cmp_w, 
and CMP_L are package Machine_Code entries for the MC68OX0 CMP instruction. If the instruction 
exists in a single size only, it is represented by two entries in package Machina_Coda: one with and one 
without a suffix. For example, the MC680X0 LEA instruction is represented by LEA and LEAJL. Unsized 
instructions are re p resen ted by their base names with no suffix. 

• For instructions that operate on control registers the control register operand needs to be explicitly supplied 
in the machine code insert: 

Two_Opnds' (ANDXtoCCR, (Im, 3), (CR, CCR)) ; 

• For Conditional Branch, Branch Always, and Branch to Subroutine instructions an un si ze d entry (for 
example, BEQ) lets the compiler pick the instruction of the optimal size. 

• BSRnornt and JSRnomt mnemonics are aliases for BSR and JSR res pective l y. Use them when a 
called routine is known to never return. 


5*19 







APPENDIX FT© IAL4TD-1U3A 


• text 
.even 

I Total bytes of cods ■ 28 
I Total bytes of data ■ 0 


5 . 11 . INLINE GUIDELINES 

The following d is cu ssi on oo inlining is based on the the next two example*. From these sample programs, 
general rule*, procedures, and cautions are illustrated. 

Consider a package with a subprogram that is to be inlined. 

package In_P»ck is 

procedure X Will Be Xnlined; 
pragma INLINE (l“wiTl_Be_Inlined) ; 
end In_Pack; ~ 

Consider a procedure that makes l call to an inlined subprogr am in the package, 
with In_Pack; 

procedure use*_Xnlined_Subp is 
begin 

I_will_Be_Inlined; 
end; ” ' 

After the package specification for Xn_Paek has been compiled, it is possible to compile the unit 
Uses_Xnlined_Subp that makes a call tothe subprogram I_will_Be_Inlined. However, because the 
body of the subprogram is not yet available, the generated code will not have an inlined version of the sub¬ 
program. The generated code will use an out of line call for I_Nill_B«_Inlinud. The compiler will issue 
warning message #2429 that the call was not inlined when u * • 7_I nl Inodes ubp was compiled. 

If Xn_Paek is used across libraries, it can be exported as part of a specification library after having compiled 
the package specification. Note that if only the specification is exported, that in all units in libraries that import 
In_Pack there will be no inlined calls to ln_Pack. If only the specification is exported, all calls that a ppe ar in 
other libraries will be out of line calls. The compiler will issue warning message *6601 to indicate the call was 
not inlined. 

There is no warning at link time that subprograms have not been inlined. 

If the body for package in_Pack has been compiled before the call to I_Wi 1 nlined is compiled, 

the compiler will inline the su b program. In the example above, if the body of In_Pack has been compiled 
before uses_Inlinad_Subp, when uses_Inlinad_Subp is compiled, the call will be inlined. 

Having an inlined call to a subprogram makes a unit dependent oo the unit that contains the body of the 
subprogram. In the example, once usea_inlinod_Sutop has been compiled with an inlined call to 
XJNj.ll_Bu_Xnli.ned, the unit uaea_lrtlin#d_Subp will have a d e p en d enc y oo the package body 
In.Pack. Thus, if the body for package *body In.Pack is recompiled, uaea_Inlined_Subp will b eco m e 
obsolete, and must be recompiled before it can be linked. " 

It is possible to export the body for a library unit. If the body for package Xn_Pack is added to the 
spe cifi catio n library, exportlib command, other libraries that import package Xn~Pack wifi be able to 
compile inlined calls across library units. 

At optimization levels lower than the default, the compiler will not inline calls, even when pragma inline 
has been used and the body of the s ub progr am is in the library prior to the unit that makes the call Lower 
optimization levels avoid any changes in flow of the code that causes movement of code sequences, as happens in 
a pragma inline. If the compiler is running at a low optimization level, the user will not be waned that 
iniining is not happening. 


5-21 







APPENDIX F TO MIL-STD-UISA 


with Intrinsic®; us* Intrinsics; 


function Shift_Left (Shift_Ma int*g«r; 

” ^ Shift”Count : positive; 

Signed : boolean) return integer is 

function Log_Shift_Left is new LSL (Source_Typ* •> 

Result^typ* ■> 

function Ari_Shift_Iieft is new ASL (Source”Typ* “> 
~ ~ R*sult~Typ* -> 

integer, 
integer); 
integer, 
integer); 

begin 

if Signed then 

return Ari_Shift__I«eft. (Shift_Me, Shift_Count); 
else “ ~ 

return Log_Shift_Left (Shift__Me, Shift_Count); 
end if; * ~ 

end Shift_Left; 


Figure 5-2: LSL and ASL Used To Define a Shift-Le f t Routine 


5.122. No-Overflow Integer Arithmetic 

Occasionally, it is desirable to generate code seque n ces using operations defined for two's complement 
integer arithmetic, but without the overflow checks that usually come with them. Such is the case when 
emulating unsigned 32-bit arithmetic, for example. Four functions are provided. All of them are generic cm 
source and result types and can thus be instantiated for 8.16 or 32-bit arithmetic. 


Name 

Meaning 

| 

D 

Two’s complement add with no 
overflow detection. 

Result is always same as true 
mathematical answer truncated to 

8,16 or 32-bits. 

No_Overflow_SUB 

Two’s complement subtract with no 
overflow detection. 

Result is always same as true 
mathematical answer truncated to 

8,16 or 32-bits. 

s 

I 

Two’s complement multiply with no 
overflow detection. 


Result is always same as true 
mathematical answer truncated to 

8.16 or 32-bits. 

No_Overflow_NEG 

Two’s complement negate with no 
overflow detection. 

Remit is always same as true 
mathematical answer truncated to 

8,16 or 32-bits. 


5-23 






APPENDIX F TO MILSnMIlSA 


Name 

Meaning 


Processor 

FABS 

Absolute Value 

All processors 

FSABS 

Absolute Value, Single Predsioa 

MC68040 only 

FDABS 

Absolute Value, Double Precisian 

MC68040 only 

FACOS 

Arccosine 

MC68881; optionally in software on MC68040 

FADD 

Add 

AH processors 

FSADD 

Add, Single Predsioa 

MC68040 only 

FDADD 

Add, Double Precision 

MC68040 only 

FASIN 

Arcsine 

MC68881; optionally in software on MC68040 

FATAN 

Arctangent 

MC68881; optionally in software on MC68040 

FATANH 

Hyperbolic Arctangent 

MC68881; optionally in software on MC68040 

FCOS 

Cosine 

MC68881; optionally in software on MC68040 

FCOSH 

Hyperbolic Cosine 

MC68881; optionally in software on MC68040 

FDrv 

Divide 

AH processors 

FSDFV 

Divide, Single Precision 

MC68040 only 

FDDIV 

Divide, Double Precision 

MC68040 only 

FETOX 

E to the Power X 

MC68881; optionally in software on MC68040 

FETOXM1 

E to the Power (X-l) 

MC68881; optionally in software on MC68040 

FGETEXP 

Get Exponent 

MC68881; optionally in software on MC68040 

FGETMAN 

Get Mantissa 

MC68881; optionally in software on MC68040 

FLOGIO 

Log Base 10 

MC68881; optionally in software on MC68040 

FLOG2 

Log Base 2 

MC68881; optionally in software on MC68040 

FLOGN 

Log Base E 

MC68881; optionally in software on MC68040 

FLOGNP1 

Log Base E of X+ 1 

MC68881; optionally in software on MC68040 

FMOD 

Modulo Remainder 

MC68881; optionally in software on MC68040 

FMUL 

Multiply 

AH processors 

FSMUL 

Multiply. Single Precision 

MC68040 only 

FDMUL 

Multiply, Double Precision 

MC68040 only 

FNEG 

Negate 

AH processors 

FSNEG 

Negate, Single Precision 

MC68040 only 

FDNEG 

Negate, Double Precision 

MC68040 only 

FREM 

IEEE Remainder 

MC68881; optionally in software on MC68040 

FSCALE 

Scale Exponent 

MC68881: optionally in software on MC68040 

FSGLDIV 

Single Precision Divide 

MC68881; optionally in software on MC68040 

FSGLMUL 

Single Precision Multiply 

MC68881; optionally in software on MC68040 

FSIN 

Sine 

MC68881; optionally in software on MC68040 

FSINH 

Hyperbolic Sine 

MC68881; optionally in software on MC68040 

FSQRT 

Square Root 

AH processors 

FSSQRT 

Square Root, Single Precision 

MC68040 only 

FDSQRT 

Square Root, Double Predsioa 

MC68040 only 

FSUB 

Subtract 

AH processors 

FSSUB 

Subtract, Single Precision 

MC68040 only 

FDSUB 

Subtract, Double Predsioa 

MC68040 only 

FTAN 

Tangent 

MC68881; optionally in software on MC68040 

FTANH 

Hyperbolic Tangent 

MC68881; optionally in software on MC68040 

FTENTOX 

Tea to Source 

MC68881; optionaUy in software on MC68040 

FTWOTOX 

Two to Source 

MC68881; optionaUy in software on MC68040 


5-25 





