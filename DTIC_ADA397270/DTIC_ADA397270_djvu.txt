NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



THESIS 


ELECTRONIC MANEUVERING BOARD AND DEAD 
RECKONING TRACER DECISION AID FOR THE 
OFFICER OF THE DECK 

by 

Joey L. Frantzen 
Kenneth L. Ehresman 

September 2001 

Thesis Co-Advisors: Riehard D. Riehle 

Luqi 


Approved for public release; distribution is unlimited. 





Report Documentation Page 


Report Date Report Type Dates Covered (from... to) 

30 Sep 2001 N/A 

Title and Subtitle Contract Number 

Electronic Maneuvering Board and Dead Reckoning 

Tracer Decision Aid for the Officer of the Deck Grant Number 

Program Element Number 

Author(s) Project Number 

Joey L. Frantzen & Kenneth L. Ehresman 

Task Number 
Work Unit Number 

Performing Organization Name(s) and Address(es) Performing Organization Report Number 

Research Office Naval Postgraduate School Monterey, 

Ca 93943-5138 

Sponsoring/Monitoring Agency Name(s) and Sponsor/Monitor’s Acronym(s) 

Address(es) 

Sponsor/Monitor’s Report Number(s) 

Distribution/Availability Statement 

Approved for public release, distribution unlimited 

Supplementary Notes 
Abstract 


Subject Terms 



Number of Pages 

210 






REPORT DOCUMENTATION PAGE 


Form Approved OMB No. 0704-0188 
Public reporting burden for this collection of information is estimated to average 1 hour per response, including 
the time for reviewing instruction, searching existing data sources, gathering and maintaining the data needed, and 
completing and reviewing the collection of information. Send comments regarding this burden estimate or any 
other aspect of this collection of information, including suggestions for reducing this burden, to Washington 
headquarters Services, Directorate for Information Operations and Reports, 1215 Jefferson Davis Highway, Suite 
1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project 

(0704-0188) Washington DC 20503. _ 

2. REPORT DATE 
September 2001 


6. AUTHOR(S) Joey L. Frantzen & Kenneth L. Ehresman 


11. SUPPLEMENTARY NOTES The views expressed in this thesis are those of the author and do not reflect the official 
policy or position of the Department of Defense or the U.S. Government. 


13. ABSTRACT (maximum 200 words) 

The U.S. Navy currently bases the majority of our contact management decisions around a time and manning 
intensive paper-based Maneuvering Board process. Additional manning requirements are involved on many Naval Ships in 
order to accurately convey the information to the OOD and/or the Commanding Officer. When given situations where there 
exist multiple contacts, the current system is quickly overwhelmed and may not provide Decision-Makers a complete and 
accurate picture in a timely manner. 

The purpose of this research is to implement a stand-alone system that will provide timely and accurate contact 
information for Decision-Makers. By creating a reliable, automated system in a format that is familiar to all Surface Warfare 
Officers we will provide the Navy with a valuable decision-making tool, while increasing ease of data exchange and reducing 
current redundancies and manning inefficient practices. 

Our software design is based upon the Unified Modeling Language (UML). UML allows us to construct a software 
model that is supported by the Ada programming language. Our design is based upon these fundamental tenants: Non- 
Operating System dependent, Non-Hardware System dependent, Extensible and Modular design. Ada provides a certified 
compiler, making our code robust and assuring the “buyer” that the program does what we advertise it to do. 


18. SECURITY CLASSIFICATION 19. SECURITY 

OF THIS PAGE CLASSIFICATION OF 

Unclassified ABSTRACT 

Unclassified 

NSN 7540-01-280-5500 Standard Form 298 (Rev. 2-89) 

Prescribed by ANSI Std. 239-18 


17. SECURITY 

CLASSIFICATION OF REPORT 

Unclassified 


15. NUMBER OF 
PAGES: 197 

16. PRICE CODE 

20. LIMITATION OF 
ABSTRACT 

UL 


14. SUBJECT TERMS: Maneuvering Boards, Dead Reckoning Tracker, Safety, OODA Loop, Ada95, 
GtkAda Toolkit, GNAT Compiler, GNU Visual Debugger, Object-Orientation, Operating System 
Portability, Model View Controller, UML, GUI Graphics, Closest Point of Approach (CPA), Collision 
at Sea, Certified Compiler, Linux, and Windows 2000. 


12b. DISTRIBUTION CODE 


12a. DISTRIBUTION / AVAILABILITY STATEMENT 

Approved for public release; distribution is 

unlimited. 


7. PEREORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Naval Postgraduate School 
Monterey, CA 93943-5000 

9. SPONSORING / MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

N/A 


5. LENDING NUMBERS 


8. PEREORMING 
ORGANIZATION REPORT 

NUMBER _ 

10. SPONSORING / MONITORING 
AGENCY REPORT NUMBER 


4. TITLE AND SUBTITLE: Title (Mix case letters) 

ilectronic Maneuvering Board and Dead Reckoning Tracer Decision Aid for the 
Tfficer of the Deck 


3. REPORT TYPE AND DATES COVERED 

Master’s Thesis 


1. AGENCY USE ONLY (Leave blank) 


1 




























THIS PAGE INTENTIONALLY LEET BLANK 


11 



Approved for public release; distribution is unlimited. 


ELECTRONIC MANEUVERING BOARD AND DEAD RECKONING TRACER 
DECISION AID FOR THE OFFICER OF THE DECK 

Joey L. Frantzen 
Lieutenant, United States Navy 
B.S., United States Naval Academy, 1994 

Kenneth L. Ehresman 
Lieutenant, United States Navy 
B.S., University of Maryland, 1995 


Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF SCIENCE IN COMPUTER SCIENCE 


from the 


NAVAL POSTGRADUATE SCHOOL 
September 2001 


Authors: 



Approved by: 




res. 


Kenneth L. Ehresman 






Richard D. Riehle, Thesis Co-Advisor 



Dr. LjaqI>Thesis Co-Advisor 



Christopher S. Eagle^^hairman 
Computer Science Department 



iii 







THIS PAGE INTENTIONALLY LEET BLANK 


IV 



ABSTRACT 


The U.S. Navy currently bases the majority of our contact management decisions 
around a time and manning intensive paper-based Maneuvering Board process. 
Additional manning requirements are involved on many Naval Ships in order to 
accurately convey the information to the OOD and/or the Commanding Officer. When 
given situations where there exist multiple contacts, the current system is quickly 
overwhelmed and may not provide Decision-Makers a complete and accurate picture in a 
timely manner. 

The purpose of this research is to implement a stand-alone system that will 
provide timely and accurate contact information for Decision-Makers. By creating a 
reliable, automated system in a format that is familiar to all Surface Warfare Officers we 
will provide the Navy with a valuable decision-making tool, while increasing ease of data 
exchange and reducing current redundancies and manning inefficient practices. 

Our software design is based upon the Unified Modeling Language (UML). 
UML allows us to construct a software model that is supported by the Ada programming 
language. Our design is based upon these fundamental tenants: Non-Operating System 
dependent, Non-Hardware System dependent. Extensible and Modular design. Ada 
provides a certified compiler, making our code robust and assuring the “buyer” that the 
program does what we advertise it to do. 


V 



THIS PAGE INTENTIONALLY LEET BLANK 


VI 



TABLE OF CONTENTS 


L INTRODUCTION.1 

A, PROBLEM STATEMENT.1 

IT BACKGROUND.3 

A, TRADITIONAL DECISION-MAKING PROCESS.3 

1. The OODA Loop.3 

a. Observation . 4 

b. Orientation . 4 

c. Decision . 4 

d. Action . 4 

B, INCREASING COLLISIONS AT SEA.5 

C, PAPER VS. DIGITAL.7 

D, MANNING THE FUTURE NAVY.9 

III. OVERALL SOFTWARE DESIGN.11 

A. UNIFIED MODELING LANGUAGUE.11 

1. Use-Case Diagram.11 

2. Class Diagram.12 

a. DRT Class . 12 

b. Date Class . 13 

c. Time Class . 13 

d. Latitude/Longitude Class . 14 

e. Hit Class . 15 

f. Track Class . 16 

g. OwnShip Class . 17 

h. GPS Class . 18 

L Speed Class . 18 

j. Realnum Class . 19 

k. Degree Class . 19 

l. Radar Class . 19 

m. Network Class. . 19 

n. CPA Class . 20 

o. Moboard Class . 20 

p. MainScreen-Pkg Class . 21 

q. MainScreen-Pkg-Callbacks Class . 22 

r. Sketchpad Class . 23 

s. Utilities Class . 24 

t. File 10 Class . 24 

V. Historical 10 Class . 25 

w. Wind Class . 26 

3. Deployment Diagram.26 

4. GtkAda and GNAT.27 

vii 











































5. GNU Visual Debugger (GVD).28 

IV. CONCLUSION.31 

A, SUMMARY.31 

B, RECOMMENDATIONS FOR FUTURE WORK.31 

1. GPS Integration.32 

2. Radar Data Integration.32 

3. Touch screen displays.33 

4. Wireless LAN connectivity.33 

5. Voice recognition technology.34 

6. Mobile headset/communications.34 

7. Automated Deck Log.35 

8. Palm Pilot/CE devices providing information on demand.35 

9. Integrated multiple views (FalconView, Heads-up displays, 

etc.).36 

10. Ada enabled Applets for browsers exchange.36 

11. Artificial Intelligent Maneuvering Modules.36 

APPENDIX A, DIGITAL MOBOARD CODE.39 

A-1 DATES.ADS.39 

A-2 TIME,ADS.45 

A-3 HIT,ADS.49 

A-4 REALNUM,ADS.73 

A-5 SPEEDS.ADS.73 

A-6 DEGREES.ADS.74 

A-7 OWNSHIP,ADS.75 

A-8 TRACKS.ADS.82 

A-9 FILE IO.ADS.106 

A-10 HISTORICAL IO.ADS.115 

A-11 LAT LONG.ADS.120 

A-12 UTILITIES.ADS.137 

A-13 MOBOARD.ADS.140 

A-14 CPA.ADS.161 

A-15 MAINSCREEN-PKG.ADS.172 

A-16MAINSCREEN-PKG-CALLBACKS.ADS.181 

A-17 SKETCHPAD,ADS.188 

A-18 WIND,ADS.191 

LIST OF REFERENCES.195 

INITIAL DISTRIBUTION LIST.197 


viii 







































LIST OF FIGURES 


Figure 1. The OODA Loop for Offieer of the Deck (From; OOD).4 

Figure 2. The OODA Loop Cycle.5 

Figure 3. USS DENVER (EPD 9) pulls into Pearl Harbor hollowing An at-Sea Collsion.7 

Eigure 4. The Paper-based Moboard.7 

Eigure 5. The Digital Moboard.8 

Eigure 6. Picture of DD-21 Concept.9 

Eigure 7. Use-Case Diagram.12 

Eigure 8. Dates Class.13 

Eigure 9. Times Class.14 

Eigure 10. Eat Eong Class.15 

Eigure 11. Hit Class.16 

Eigure 12. Track Class.17 

Eigure 13. Ownship Class.18 

Eigure 14. Speed Class.19 

Eigure 15. Realnum Class.19 

Eigure 16. Degree Class.19 

Eigure 17. CPA Class.20 

Eigure 18. Moboard Class.21 

Eigure 19. MainScreen-Pkg Class.22 

Eigure 20. MainScreen-Pkg-Callbacks Class.23 

Eigure 21. Sketchpad Class.23 

Eigure 22. Utilities Class.24 

Eigure 23. Eile lO Class.25 

Eigure 24. Historical 10 Class.25 

Eigure 25. Wind Class.26 

Eigure 26. Deployment Diagram.26 

Eigure 27. GtkAda layered structure.27 

Eigure 28. Screenshot of GVD Version 1.2.1.29 


IX 































THIS PAGE INTENTIONALLY LEET BLANK 


X 



ACKNOWLEDGMENTS 


Sincere appreeiation to 

Dr. Luqi & Mr. Richard Riehle 

for their guidanee and support in this endeavor. 


XI 



THIS PAGE INTENTIONALLY LEET BLANK 



I. 


INTRODUCTION 


A. PROBLEM STATEMENT 

The U.S. Navy currently bases the majority of our contact management decisions 
around a time and manning intensive paper-based Maneuvering Board process. The use 
of Maneuvering Boards is a perishable skill that has a steep learning curve. In order to 
overcome inherent human error, it is not uncommon to have up to four people 
simultaneously involved in solving just one maneuvering problem. Additional manning 
requirements are involved on many Naval Ships in order to accurately convey the 
information to the Officer of the Deck (OOD) and/or the Commanding Officer. When 
given situations where there exist multiple contacts, the current system is quickly 
overwhelmed and may not provide Commanding Officers and OODs a complete and 
accurate picture in a timely manner. 

Since 1996, there has been an increase in the number of collisions at sea, resulting 
in the loss of millions of dollars and thousands of operational hours for ships that are 
critical to our force structure. Although the time-tested method we use to make 
maneuvering decisions works, its technology has not kept pace with the increase in the 
ocean’s traffic density. What is required is a faster and more accurate means by which 
this method is executed 

The purpose of this research is to implement a stand-alone system that will 
provide timely and accurate contact information for U.S. Navy Commanding Officers, 
OODs, and CIC watch teams. By creating a reliable, automated system in a format that is 
familiar to all Surface Warfare Officers we will provide the Navy with a valuable 
decision-making tool, while increasing ease of data exchange and reducing current 
redundancies and manning inefficient practices. 

Our software design is based upon the Unified Modeling Language (UML). 
UML allows us to construct a software model that is supported by the Ada programming 
language. UML also provides significant benefits to us, as software engineers, by 
helping to build rigorous, traceable and maintainable models that will support the 

software development cycle. Our design is based upon these fundamental tenants: Non- 

1 



Operating System dependent, Non-Hardware System dependent, Extensible and Modular 
design. Ada provides a certified compiler and environment, making our code robust and 
assuring the “buyer” that the program does what we advertise it to do. We also chose 
Ada because of the Re-usability inherent to the modular design structure. Our program 
does not use hardware specific libraries/architecture such as MFC. 

This system will significantly enhance Safe Navigation at Sea while maintaining 
the age old, time tested ways of avoiding other vessels at sea. 

Our software design is implemented via using Gtk-Ada, which allows the 
development of a GUI-based program that is neither operating system nor hardware 
dependent. Gtk-Ada is supported on a wide range of platforms, and its use can ultimately 
allow the U.S Navy to develop operational tools and programs without being limited to 
any specific hardware or operating system. The flexibility that this tool affords can 
reduce development and maintenance cost significantly as the amount of rework due to a 
paradigm shift in any operating system vendor will be greatly reduced or eliminated. 
Additionally, Ada’s ability to interoperate with other programming languages make it an 
excellent candidate for integrating with current stove-piped systems. 

Our system provides the basis for a robust fusion analysis plot that, due to its 
modular design, can interact with virtually any other system. 


2 



II. BACKGROUND 


A. TRADITIONAL DECISION-MAKING PROCESS 


Prior to Maneuvering Boards, the traditional mariner relied upon the seaman’s eye 
and the knowledge gained from many hours of standing watches on the bridge. This 
knowledge pool helped the ship driver make the right decision when confronted with 
other vessels. The evolution of radar allowed vessels to see contacts at great distances 
and measure the bearing and ranges of those contacts. The Maneuvering Board quickly 
followed the radar allowing ship drivers an alternate visual representation of radar 
contacts based upon trigonometric fundamentals. This now allowed OODs and 
Commanding Officers a better way to frame the problem in more concrete terms. 

1, The OODA Loop 

The OOD decision-making process is designed to try and reduce uncertainty by 
gathering information, and transforming this information into knowledge and 
understanding. The utilization of radars and Maneuvering Boards aids a 
Commander/OOD in reducing the level of uncertainty. This decision process is known as 
the OODA Loop; Observation, Orientation, Decision, and Action. 

Whenever trying to establish Command and Control there exists two fundamental 
factors that shape the environment: uncertainty and time. The Moboard model lies within 
the Orientation phase of the OODA Loop. The Electronic Maneuvering Board Decision 
Aid reduces the level of uncertainty and the amount of time inherent to the Maneuvering 
Board process. 


OBSERVATION 



ORIENTATION 


• Naked Eye 

• Binoculars (Lookouts) 

• Surface radar 

• Sonar 

• Audible noise 

• Compass (Magnetic/Gyroscope) 


* Moboards 

* Dead Reckoning Trace 

* Experience 

* Assumptions 

* Estimates 

* Judgments 


3 




• Bearings 

• Altimeter 


ACTION 




DECISION 


• Issue orders * Decide course of action 

Figure 1. The OODA Loop for Officer of the Deck (From; OOD) 

a. Observation 

Observes the environment (using all sensors, information systems, and 
situational reports from his subordinates) to collect data about their surroundings and the 
status of contacts. This data is typically correlated, fused, and displayed in a common 
tactical picture—a representation or image of the contact space. A Commander or OOD 
had several methods of retrieving data via visual lookouts, surface radars, sonar, and/or 
his/her own eyes. 

b. Orientation 

A Commander/OOD orients themselves to the environment—that is, they 
form a mental picture of the situation—by converting sensor data and other information 
into estimates, assumptions, and judgments about what is happening. From this 
orientation a commander/OOD derives his understanding of the contact space, or 
situational awareness, 

c. Decision 

Based on the understanding derived from his/her Orientation, the 
commander/OOD then decides on a course of action and comes up with a plan. 

d. Action 

The commander/OOD sets forth his intent and issues orders to put that 
plan into action. 


4 





Figure 2. The OODA Loop Cyele 


B. INCREASING COLLISIONS AT SEA 

Sinee 1996, there has been a marked inerease in the number of eollisions at sea, 
resulting in the loss of millions of dollars and thousands of operational hours for ships 
that are eritical to our foree structure. A Navy investigation into the collision of USS 


5 













Denver (LPD 9) with USNS Yukon (T-AO 202) found that Captain should have realized 
his ship was on a eollision eourse with the oiler. In hindsight, had the CO of the Denver 
had more time to make his eritical maneuvering decision and had he been given more 
accurate contact information in a timelier manner, the CO of the Denver would never 
have made such a critical mistake. 

There are many variables that play a significant part in the reasons for more 
frequent collisions at sea over the past 5 years. These factors range from inexperience, 
training, crew fatigue. Op Tempo, and higher traffic densities on today’s seas. The end 
result is OODs and CO’s who may not have complete situational awareness, who become 
complacent, and decision-makers who don’t receive safety critical information in a timely 
and accurate manner. The primary issue is not the decisions that are made when it comes 
to maneuvering, but the information that decision-makers have when making those 
decisions. Although collisions are a high profile issue, it’s the numerous and countless 
“near misses” that go unreported and often untreated. Looking back into our crystal ball 
we can see many instances where Commanding Officers and OODs could have benefited 
from a better system and a better means by which contact information was being 
displayed and presented to them. The time-tested method we use to make maneuvering 
decisions works. The problem is that technology has not kept pace with the increase in 
the ocean’s traffic density. What is required is a faster and more accurate means by 
which this method is executed. 


6 




Figure 3. USS DENVER (LPD 9) pulls into Pearl Harbor Following An at-Sea Collsion 


C. PAPER VS. DIGITAL 


MANEUVERING BOARD 





Figure 4. The Paper-based Moboard 


7 
























The argument for or against traditional paper-based Moboards versus Digital- 
Based Moboards is based upon two simple factors. 

Traditional paper-based Moboards are done with a pencil and straightedge. This 
process can be inaccurate and is often prone to human error. Even a very experienced 
sailor can make mistakes when doing a Moboard solution, especially in time critical 
situations, periods of rough seas, night time operations, or situations where there are 
multiple contacts. 

Digital-based Moboards will speed this process up and eliminate the inherent 
human error innate to the paper-based Moboard process. By decreasing the time required 
to produce a Moboard solution it in turn decreases the time required to complete the 
orientation process and thus speeds up the overall decision process. Having more time 
and more accurate information in an understandable and easy to assimilate presentation is 
every Commander’s desire. This is what Digital-based Moboards provide. 



Figures. The Digital Moboard 


8 




























D. MANNING THE FUTURE NAVY 



Figure 6. Picture of DD-21 Concept 


With the evolution of “Smart Ship” and the DD-21 initiative the manning of Navy 
Ships has become a high profile issue. The future Navy will no longer have the luxury of 
350-manned combatant ships. The Navy of the future will require less men and women 
who are more technically proficient and better trained. The bridge of the next generation 
will still rely on good seamanship, experience, and a trained eye while instead of using 
paper-based tools, the tasks and aids used to process contacts and information will be 
done in a digital-based medium. The modem Navy will have to depend on exceptional 
sensors and computer systems that are able to frame an abundance of information into a 
manageable and clear presentation. The Electronic Maneuvering Board Decision Aid is 
designed to meet this emerging need. With this computerized decision tool the 
requirements for multiple junior officers doing Moboards or several Operation Specialists 
in Combat maintaining a DRT contact picture will be reduced greatly. GPS will 
automatically be updated into the system, instantly giving the Commanding Officer and 
OOD Latitude and Longitude information of all the local area contacts at the mere click 
of the mouse. 

Additionally our computer program will have the ability to maintain a digital log, 
vice having a paper-based Deck Log maintained by the Quartermaster (QM). This may 
be another avenue by which the U.S. Navy can reduce the manning requirements on the 
bridge while maintaining and improving upon the safety of ships at sea. The 
Quartermaster will no longer be required to log each course and speed change, OOD 
watch changes, casualties, etc. This will all be maintained in a central database allowing 
for a visual playback of events for any post-operations analysis. This feature will allow 

9 







the evaluator to view a list of events as well as display a visual eontaet picture 
chronologically corresponding with these logged events. Thus, the end result is better 
post-operations analysis and understanding of the environment on the bridge at the time 
of the operation, mishap, or exercise. 


10 



III. OVERALL SOFTWARE DESIGN 


A. UNIFIED MODELING LANGUAGUE 

Our software design is based upon the Unified Modeling Language (UML). 
UML allows us to eonstruct a software model that is supported by the Ada programming 
language. UML also provides signifieant benefits to us, as software engineers, by 
helping to build rigorous, traeeable and maintainable models that will support the 
software development eyele. Our design is based upon these fundamental tenants: Non- 
Operating System dependent, Non-Hardware System dependent. Extensible and Modular 
design. Ada provides a eertified eompiler and environment, making our eode robust and 
assuring the “buyer” that the program does what we advertise it to do. We also ehose 
Ada beeause of the Re-usability inherent to the modular design strueture. Our program 
does not use hardware speeific libraries/architeeture sueh as MFC. 

Our design was based upon the following UML diagrams: Use-Case, 
Sequence, Class, Object, and Deployment Diagrams. 

1. Use-Case Diagram 

The Use-Case Diagram was based upon what an OOD or CO would require the 
computer system to do. Basic functions such as Plot Contact, Display Contact, 

Calculate Contact Course and Speed, and Calculate CPA were the primary Use- 
cases for the basic computer program. Other actors such as Global Positioning 
System and Generic Radar System will be required for implementation at a later 
date. All of these actors interact with two systems. Dead Reckoning Trace and 
Maneuvering Board. These two systems are just separate views of the same data, 
framing our visual representation for the user. 


11 



Co Xb 


display_contact_cseSpd .calc_contact_cseSpd 


display_Contact 


User 


plot_Contact 

display_os_vBCtorLocation 


ODD 


display_desired_wind plot_os_vector 


display _cse_spd_time_Tostation compute_desired_wind 

calc_cse_spd_time_Tostation 


display _CPA 


calc CPA 


w 


save data ToDB 


gps_class 


Figure 7. Use-Case Diagram 


2, Class Diagram 

To truly make a computer program reusable, modular, and maintainable the 

programmer must adhere to a strict Objected Oriented Methodology (OOM). 
Understanding this key concept, the programmer must build his/her classes in an Object 
Oriented approach. With this in mind, our Electronic Moboard and DRT was structured 
to be modular, maintainable, and reusable. 

fl. DRT Class 

Description: The DRT Class is similar to the Moboard Class in that it 

displays information from the Ownship and Tracks Class. The main difference is the 
DRT Class presents a true picture vice a relative picture presented in the Moboard Class. 


12 


b. Date Class 


Description: The Date Class contains a type Date (Day, Month, Year). 

The Class includes Functions and Procedures to Get a Date from the computer system or 
GPS, as well as, return all the Date values and set all the Date values. 


dates Class 

i^Date : Record 

^Month : Month_Number = Calls Ada.Calendar 
^Day : Day_Number = Calls Ada.Calendar 
^Year : Year_Number = Calls Ada.Calendar 

♦Get_Date_From_System() 

♦Set_Date() 

♦Set_Day() 

♦Set_Month() 

♦Set_Year() 

♦Get_Day() 

♦Get_Month() 

♦Get_Year() 

♦Get_Date() 


Figure 8. Dates Class 

c. Time Class 

Description: The Time Class contains a type Tim (Hours, Minutes, Seconds). 

The Class includes Functions and Procedures to Get a Time from the computer system or GPS, as 
well as, return all the Time values and set all the Time values. 


13 






times Class 

^Tim : Record 
^Hours : Integer = 0 
^Mins : Integer = 0 
i^Secs : Integer = 0 


♦Get_Ti m e_Of_Day() 

%Set_Time() 

♦Set_Hours() 

♦Set_Mins() 

♦Set_Secs() 

♦Get_Hours() 

♦Get_Mins() 

♦Get_Seconds() 

♦Get_Time() 


Figure 9. Times Class 

d. Latitude/Longitude Class 

Description: The Lat Long Class contains a type Latitude (Degrees, 

Minutes, Seconds, Sign) and type Longitude (Degrees, Minutes, Seconds, Sign). The Class 
includes functions to convert from Nautical Miles to Kilometers, Yards to Kilometers, Yards to 
Nautical Miles and the converse functions as well. Also included in this class are two unique 
procedures. The first, Calculates a Latitude and Longitude given a bearing and range from a 
known Lat/Long Position. This Procedure also returns the back bearing based on trigometric 
formulas that take into account the curvature of the earth. The other Procedure takes two known 
Lat/Long Positions and then calculates the distance between them and the forward and back 
bearings. The Class also contains the basic set and get procedures/ functions for each Latitude and 
Longitude type. 


14 






Lat_Long Class 
atitude : Record 
^j>Longitude : Record 
<^L at_Degree : Lat_Degree 0..9 0 
^>Lat_l\/lin : Lat_Min 0..60 
^>Lat_Sec : Lat_Sec 0..6 0 
(^Long_Degree :Long_Deg 0..180 
^>Long_Min :Long_Min 0..60 
^;>Long_Sec : Long_Sec 0..60 


♦g et_N M_From _Yards{) 
♦Get_Yards_From _N M{) 
♦g e t_K M_Fro m _Ya rd s () 
♦Get_Yards_From _KM() 
♦Get_N M_From _KM() 
♦Get_KM_From _N M() 

♦l at_To_Degrees() 

♦Lo n g_T o_Degrees() 

♦d eg_To_Lat{) 

♦d eg_To_Long() 

♦c alc_Lat_Long{) 
♦Calc_Bearing_D istance() 
♦Set_Latitude() 
♦Set_Longitude() 

♦s e t_ L a t_ D e g () 

♦s e t_ L a t_ M i n {) 

♦s e t_ L a t_ S e c () 

♦s e t_ L a t_ S i g n () 

♦s et_Long_Deg() 

♦s et_Long_Min() 

♦s et_Long_Sec{) 

♦s et_Long_Sign() 
♦Get_Latitude() 

♦g e t_ L a t_ D e g () 

♦g e t_ L a t_ M i n () 

♦g e t_ L a t_ S e c {) 

♦g e t_ L a t_ S i g n () 

♦g et_Long_Deg{) 

♦g et_Longitude{) 

♦g et_Long_Min() 

♦g et_Long_Sec() 

♦g et_Long_Sign() 


Figure 10. Lat Long Class 


e. Hit Class 

Description: The Hit class contains all of the data necessary when a hit is taken 

(a bearing and range to a contact from a radar scope). A hit type includes Bearing, Range, 
Latitude, Longitude, Date, Time, Ownship Course and Speed, Target Course and Speed, and 


15 






Target Angle. Hit Class contains all the procedures necessary to set and get data from each 
element of the Hit type. 


H i t C la s s 

it : R eCOrd 
ear : Deg re e = 0.0 
ng:Real = 0.0 
^>Lat : Latitude 
on :Longitude 

at: Date = Get_Date_From_System 
ime :Tim = Get_Time_From_System 
^^Target_Cse : Degree = 0.0 

w n S h ip_C s e : Degree = 0.0 
^>Target_Speed : Speed = 0.0 

w nShip_Speed : Speed = 0.0 


♦Set_H it_Tim e() 
♦Set_Hit_Hour() 

♦Set_H it_Min() 

♦Set_H it_Sec() 

♦Get_H it_Tim e() 

♦Get_H it_H our() 

♦Get_H it_Min() 

♦Get_H it_Sec() 

%Set_H it_Date() 

♦Set_H it_Day() 

%Set_H it_Month() 
♦Set_H it_Year() 

♦Get_H it_D ate() 

♦Get_H it_D ay() 
♦Get_Hit_Month() 
♦Get_H it_Year() 

♦Set_H it_Lat() 

♦Get_H it_Lat() 
♦Set_Hit_Long() 

♦Get_H it_Long() 

♦s e t_ Hit_Bearing() 

♦g et_FI it_Bea rin g 0 
♦s et_ H it_ R a n g e 0 
♦g et_Flit_Range() 

♦s et_OwnShip_Cse() 
♦g et_OwnShip_Cse{) 
♦s et_ Targe t_Cse() 

♦g et_ Targe t_Cse() 

♦s et_OwnShip_Speed{) 
♦g et_OwnShip_Speed() 
♦s et_ Targe t_Speed() 
♦g et_ Targe t_Speed{) 
♦c a lc_H it_Lat_Lo n g {) 


Figure 11. Hit Class 

f. Track Class 

Description: The Traek Class eontains all of the data neeessary to traek a 

eontact. The track type includes Track Number, Track Ident, Track Course and Speed, 

CPA Bearing, CPA Range, CPA Time, a Hit Count and a List of Hits. Track includes 

16 







functionality to set and get all of the elements of hit type. Track also maintains an array 
of 10,000 elements that are of type track. This is the memory allocation for all of the 
tracks prior to being saved onto a harddisk or storage device. 


Track Class 

^track: Record 
^Point: Array of Hit 
^Track_Number: Integer 1100..11 00 
^Track_ID :string 
^Track_Cse: Degree 
^Track_Spd: Speed 
^CPA_Bearing : Degree 
^CPARange : Real 
^CPA_Tim e: Tim 
it_List: Point 
^Hit_Count: Integer 

♦Add_Track() 

♦Add_Track_Hit() 

♦Set_Track_Cse() 

♦Set_Track_Speed() 

♦Set_Track_ld() 

♦Set_Track_Number() 

♦Get_Track_Cse() 

♦Get_T rack_Spe ed() 
♦Get_Track_ld() 
♦Get_Track_Point_Lat() 
♦Get_Track_Point_Long() 
♦Get_Track_Hit_C)wns hip_Cse() 
♦Get_Track_Hit_Owns hip_Speed() 


Figure 12. Track Class 

g. OwnShip Class 

Description: OwnShip Class manages and maintains all information concerning 

OwnShip. This includes Number, Identification, Course and Speed, Latitude, and Longitude. 
The OwnShip Class contains all of the required Get and Set functions and procedures necessary 
to modify and retrieve type data. OwnShip Class also retrieves Latitude and Longitude 
Information from either manual keyboard entry or from a GPS port (ex. COMl). This is based 
upon the user-selected mode. 


17 






OwnShip Class 

^OvvnShip Number: integer 

^OvvnShip_ld : string 
^OvvnShip_Cse : Degree 
^OvvnShip_Speed : Speed 
^Lat: Latitude 
i^Lon : Longitude 

^Dat: Date = Get_Date_From_S^tem 
^T_ ime : Tim =Get_Time_From_System 


♦lnit_OwnShip() 

♦Set_OwnShip_Number() 

♦Get_OwnShip_Number() 

♦Set_OwnShip_ld() 

♦Get_OwnShp_ld() 

♦Set_OwnShip_Cse() 

♦Get_OwnShip_Cse() 

♦Set_OwnShip_Speed() 

♦Get_OwnShip_Speed() 

♦Set_OwnShip_Lat() 

♦Get_OwnShip_Lat() 

♦Set_OwnShip_Long() 

♦Get_OwnShip_Long() 


Figure 13. Ownship Class 

h. GPS Class 

Description: This Class manages the interface between the GPS System 

and the Computer system. This Class retrieves GPS information from the designated port 
(ex. COMl) then parses and stores this information into usable formats, i.e. Latitude, 
Longitude, Date, Time, etc. 

L Speed Class 

Description: Defines subtype Speed that is a Real type with digits 1 range 

0.0 to 130.0 This maximum values was chosen based on the simple fact that our design 
of this system is intended to track surface vessels, not aircraft, etc. 


18 









Figure 14. Speed Class 

j. Realnum Class 

Description: Defines subtype Real that is digits 12. This elass instantiates 

Generic Elementary Functions (Real) allowing the Real Type to use all of the Generie 
Elementary Funetions. 

Realnum Class 
^Real: Digits 12 

♦Generic_Elementary_Functions() 

Figure 15. Realnum Class 

k. Degree Class 

Description: Defines subtype Degree that is a Real type with digits 1 
range 0.0 to 359.9 



Figure 16. Degree Class 

l. Radar Class 

Deseription; This is a future Class that will be designed to handle Radar 

input of traek information and manage the interface between the two systems. 

m. Network Class 

Description: Manages all of the network traffic and sequence of events 
required to pass data over a small network. 


19 














n. CPA Class 


Description; This Class handles all Closests Point of Approach (CPA) 
calculations and then plots those DRM, SRM, and Associated Speed Traingle and CPA 
information to the Moboard, DRT, or specified view. 


CPACIass 

^Speed_Scale :CONSTNATRealnum : = 5.0 
^Number_0_Cirdes : CONSTANT Integer: = 11; 

^One_Degree : Realnum.Real 
i^CPA_Drawing_Aea : Sketchpad.Gtk_Sketchpad 
Origin 
^Y_ Origin 

^CPA_Alert_Distance : Realnum 
(^Fa ired Xpos and Faired Ypos 

^Fa ired First Bearing, Faired Second Bearing : Utilities.My_Degree 

♦Calculate_SRM() 

♦Finish_Speed_Triangle() 


Figure 17. CPA Class 
o. Moboard Class 

Description: The Moboard Class displays OwnShip and Track Class Data 

in a relative 0 to 360 degree coordinate system scale based upon the speeds of the 
vectors.. 


20 






Moboard Class 
urrent_Contact_N um ber 
urrent_Contact_Bearing 
urrent_Contact_Range 
oboa rd_Radius 
lack, Current_color,Red 
^^R a tio -Ar ra y 

um ber_0-Circles : Constant 
(^ne D eg re e 

wn_Ship_Course 
i^O wn_Ship_Speed 
et_U p-D istance 
u r re n t-A re a 
0 n ta ct X p 0 s 
0 n ta ct Y p 0 s 
hip Xpo s 
<%>s hip Ypo s 
raw W id th 
raw Height 
o r ig 
<^Y o r ig 

ashed Green GC 
r e e n G C 
Iu e G C 
<^>R e d G C 


^G e t_ B I a ck_ C o I o r() 

^G et_R ed_Color{) 

e t_ C u rre nt_Contact_Num {) 
e t_ C u rre nt_Contact_Bearing() 
et_C urrent_Contac t_ Range 0 
et_C urre n t_ C 0 lo r{) 

^ et_Ship_XPos() 

^ et_Ship_YPos() 

♦g et_Own_Ship_Course() 

♦G et_0 wn_Ship_Speed() 

♦S et_Current_Color() 

♦S et_C urrent_C onta ct_Be aring() 
♦S et_Current_Contact_Num () 

♦S et_C urrent_C onta ct_Ran ge{) 
♦S e t_ C o n ta ct_ XP os () 

♦S e t_ C o n ta ct_ YP os () 

♦S et_Ow n_Ship_Course{) 

♦S et_Ow n_Ship_Speed() 
i n d _ D i s ta n ce {) 

♦Find_D R M 0 


Figure 18. Moboard Class 
p. MainScreen-Pkg Class 

Description; This Class handles all the Packages for the Mainscreen. 


21 







MainScreen-Pkg Class 
^Show_Cpa1 

^Show Lines 1 
^y\dc!_N ew_Contact1 
^lnput_Contact_Hit1 
^Drop_Contact1 
^Update_Contact1 
^OwnShp LatClist 
^Ownshp Course Clist 
^CPACIist 
^Contact Clist 
^Track Clist 
^Track LatClist 
(^Course Text1 
^Speed Text1 
^Lat Degrees Text1 
^Lat Minutes Text1 
^Lat Seconds Text1 
^Lat Hemisphere Text1 
^Long Degrees Text1 
^Long Minutes Text1 
^Long Seconds Text1 
^Long Hemisphere Text1 

♦DisplayCPAO 
%Display_Track lnfo() 

♦Gtk New() 

♦initiializeO 
♦input Lat LongO 
♦input Measured Wind() 
♦input New Contact() 
♦input New Hit() 

^Input CPA Aert Distance() 


Figure 19. MainScreen-Pkg Class 
q. MainScreen-Pkg-Callbacks Class 

Description; This Class handles all the Callbacks for the Main Screen 

Packages. 


22 







MainScreen-Pkg-Callbacks Class 
^Textl 

^ShowCourse 

(^Color_Done 


♦On_Cpa1 _ActivatB() 

♦On_P ref e re n c e s_Acti \a t e () 
♦On_Show_Closest-Activa1e() 
♦Put_Lat_Long_lnto_Ownship() 
♦On_Sho w_L ines _A;tiva1e() 

♦On_U pda te-Conta ct_ lnfo_Acti \ate() 
♦On-Course1 _Text_Changed () 
♦On-DrDp_Contact_Ac1i\ate() 
♦On_New_Contact-Button_Clicked() 
♦On_New- Co ntact_Bu tton_Cancel() 


Figure 20. MainScreen-Pkg-Callbacks Class 
r. Sketchpad Class 

Description; This class is similar to the name, it’s a Sketch Pad that 
allows the programmer to draw in the back ground and then load the information to the 
front of the view. 


Sketchpad Class 

^Draw Width 
^Draw Height 
^XOrig 
Orig 

♦Gtk_New() 

♦initializeO 

♦Set_Allow_CPA() 

♦Allow_Drawing_Fairline() 

♦Set_Anchor_Pixels () 

♦Get_Allow_CPA() 

♦Get_Moboard_PixMap() 


Figure 21. Sketchpad Class 


23 










s. Utilities Class 


Description; This Class is designed to encompass all generic functions 
and procedures, such as converting real and integer numbers to strings, as well as any 
generic type definitions that multiple classes require to use as part of the program. 


Utilities Class 

^LAST TRACK SLOT CONSTANT 
^BEGIN TRACK SLOT CONSTANT 

♦Validate Time() 

♦Get_Default String() 

♦Convert String to Realnum() 
♦Convert to Degree String() 
♦Convert to Hours String() 
♦Convert Track Number to String() 
♦Convert Integer to String() 
♦Calculate Scale() 


Figure 22. Utilities Class 


t File 10 Class 

Description; This Class is designed to handle all data recovery/restoration 

of track, hit, and ownship information. The database maintains the last known state in 
three (3) separate files. Should the system shutdown or crash, the program will 
automatically load the last stored information from the Latest files kept under File lO 
Class. 


24 






File 10 Class 

^OS Data Type 
it Data Type 
(^Track Data Type 


♦Save Last Owns hip State() 
♦Save Last Track State() 

♦Save Last Hit State() 

♦Save Two Hit Track Numbers() 
♦Save Three Hit Track Numbers() 
♦Drop Track From State() 

♦Drop All Track Hits from State() 
♦Delete Latest Files() 

♦Get Ownship Data from File() 
♦Get All Saved Tracks() 

♦Get All Saved Hits() 


Figure 23. File lO Class 
V. Historical 10 Class 

Description; This Class is designed to save all data for every change or 

update made to ownship, track, or hit information. The database is a sequential database 
that has a sentinal designating the type of data to be stored. This will allow for future 
expansion for data re-play, reconstruction of events, and/or data playback for mishaps, 
exercise evaluations, etc. 


Historical 10 Class 
(^Historical Data type 

♦New Day Change File Name() 
♦Save Data to File() 


Figure 24. Historical 10 Class 


25 










w. Wind Class 


Description; This Class is designed to calculate True wind and Desired 
wind and then ploat the result onto the Moboard, DRT, or specified view that the user 
desires. 


Wind Class 
^XOrig 
^YOrig 
^One Degree 
^Wind Drawing Area 
(^Speed Scale Const 
^NumherOCirdes Const 

♦Calculate True Wind() 
♦initialize! ) 


Figure 25. Wind Class 


3, Deployment Diagram 



Captain's 
Portable Device 


Figure 26. Deployment Diagram 
26 
























4. 


GtkAda and GNAT 


There are several reasons we ehose to use GtkAda and GNAT eompilers. First 
off, as students with no funding, both of these compilers are free, a very attractive 
quality. Secondly, part of our research was to design a computer program that was 
hardware and software (Operating System) independent, thus portable. GtkAda is a high 
level portable graphical toolkit based on the gtk+ toolkit and one of the official GNU 
toolkits. Additionally, GtkAda uses Ada95 features and supports Object Orientation. 
Another attractive feature of GtkAda is that it supports OpenGL. 



Figure 27. GtkAda layered structure 

There is no guarantee that the DOD will be using Windows NT or Linux, or any 
other operating system 5 years from now. Our program is designed to be and is hardware 
and software independent. This is an attractive feature that gives the DOD flexibility in 
operating system procurement, as well as, makes our code more maintainable and robust. 
Our code can be run on all of the following platforms; 

• Linux/x86 

• Linux/sparc 

• Linux/ppc 

• Solaris/sparc 

• Solaris/x86 

• Dec Unix 

• SGI IRIX 6.5 

• HP/UX 

• NT 4.0 

• Windows 2000 

27 










• Aix 4.3.2 

• SCO UnixWare 7.1 

• FreeBSD 3.2 

5. GNU Visual Debugger (GVD) 

GVD is a graphieal front-end for the text based GDB debugger that is provided 
with the GNAT paekage. The GNU Visual Debugger enables you to see what is going 
on inside the program while it is executing, or what the program is doing when it crashes 
and where it crashes. During the preliminary stages of our research, GVD was not 
available for use. This required us to do Ada.Text_10 style debugging. If there were 
runtime errors, it was a requirement to insert dos based Print Lines, or 
Ada.Text lO.Put Line statements into the code in order to track down the procedure or 
function that the program was halting/crashing in. This was a very time consuming and 
tedius method of debugging. With the release of GVD, debugging became a much easier 
task. The debugger itself is very user friendly, it’s style is consistent with with any 
standard debugger that an accomplished programmer would be familiar with. GVD 
features of note include Open Core Dump, Edit Source, Attach to process. Detach 
process. Show call stack, show local variables, show arguments, show registers, examine 
memory, and simple task analysis. 

GVD is a very simple debugger and does not take a lot of time to become familiar 
enough with to use. GVD has many advanced features like the ability to leist the threads 
an executable is currently running by internal identifier, name, and status. Then the user 
can click on the thread and change the context variables, call stack, or source file. 

The Call Stack Window gives you a list of frames that correspond to the current 
stack of execution for the current thread or task. By simple mouse click you can choose 
what information you want to disply in the call stack window. By default the subprogram 
and parameters are displayed. The options to display frame number, program counter, 
and file location are available. 

Overall, GVD was a very robust and usable tool. Attractive to students because 
of the wonderful price tag of being free, the quality of the product is on a much higher 

scale then the typical Freeware that floats around on the Internet. Our experience was 

28 



very positive. The only negative eomment is that when using GtkAda graphics, it is 
sometimes difficult to step through line by line while within the graphics portions of the 
code and it often became necessary to run to specific points in the code, and then do step- 
by-step debugging. We would recommend this Visual Debugger front-end to anyone 
doing large or small Ada programs using the GNAT compiler. 



Figure 28. Screenshot of GVD Version 1.2.1 


29 























































THIS PAGE INTENTIONALLY LEET BLANK 


30 



IV. CONCLUSION 


A. SUMMARY 

The project began with a very simple idea. Take a proven method, known and 
understood by all Surface Warfare Officers and make the means by which the process is 
executed better. The Moboard is based on technology of the 1940s, we know the process 
works, and it has been time-tested over generations of sailors. The method of using 
pencil and paper is littered with points where even the most capable naval officer can 
make a mistake that can result in less then accurate answers. The paper-base process 
takes time to complete, and when given more then one contact to track, the problem 
becomes increasingly harder, especially when dealing with different range scales on a 
single Moboard. 

What our program has done is change the medium by which the traditional 
Moboard is calculated. There is no doubt, that given a head-to-head match-up our 
program as accurate, if not more accurate then the paper version, and much faster. In our 
current version there is limited Artifical Intelligence that alerts the user when a contact 
will be coming closer then the Captains set standing order distance, or when a track is 
Constant Bearing Decreasing Range (CBDR). The project has the potential to grow into 
a much more intelligent program and there is a host of future work to be studied and 
worked on. 

B. RECOMMENDATIONS FOR FUTURE WORK 

Future work will include a set of additional views (an extensibility of our design). 
There are extensive areas of follow-on work. For this program to truly meet the needs of 
tomorrow’s navy, continued and future research is required. We expect the project will 
evolve to incorporate (but not limited to) the following technologies: 


31 



1, GPS Integration 

Our current implementation is in the development stages of receiving GPS via a 

computer COM port. These reeeivers are inexpensive and offer a high degree of 
accuracy. One of the tenants of our software design is to maintain platform portability, 
by remaining hardare and operating system independent. To date, we have been unable 
to design the system to be completely operating system independent due to the 
differences between how Windows NT based systems and Linux based systems handle 
COM ports. Future work will include building drivers and program integration that 
supports USB interfaees and designing for portability. Additionally, work on integrating 
shipboard based GPS systems is an additional avenue that could also be persued in future 
research. Additionally, the integration of Wireless GPS conneetivity in a shipboard 
environment (where a hard mounted GPS reeeiver broadcasts to a mobile platform and 
continuously updates a ship’s postion to the program) would make the system entirely 
mobile within the confines of the ship. 

2, Radar Data Integration 

When you discuss radar integration with any system, it is important to design your 
system to be able to integrate with any current or future radar. Our modular design will 
enable us to integrate easily and quickly with new and existing radar systems. There are 
two thought proeesses when we discuss radar integration. One system would maintain the 
“man in the loop” principle, and the other is a more automated system, similar to the 
SPY-1 radar system. 

Considering radar integration with a man in the loop, the vision is a radar repeater 
similar to the SPA-25 where the actual “blip” or radar return is displayed on the seope. 
Our Moboard program would be the overlay on the repeater seope. When a new traek is 
seen on the scope, the JOOD/OOD or whoever is designated as the operater takes a 
plastie pen device and clicks on the screen “New Contacf’ and then takes the pen and 
touches the screen where the radar video is. A hit symbol and all the info assoeiated with 
that point is automatieally displayed and it automatically calculates assoeiated 
information. Then to traek the eontaet, the operator simply selects the traek they are 
interested in, and then marks a new position of the radar video. This automatically gives 


32 



the operator warnings and alerts for CBDR, vessels of high interest, rules of the road, and 
any vessel projeeted to be within the Captains standing distance. 

The second avenue that radar integration could follow is a more automated system 
where the system detects, based on some level of sensitivity, a new contact, and 
automatically plots and can calculates all associated information. This could also have 
automatically generated alerts and warnings. This could be an option on the program, 
either in manual mode or auto mode. The auto mode would still have the ability to add 
hits manually. The potential for extensive follow work exists in the area of Radar 
integration. 

3, Touch screen displays 

In a similar fasion, part of our usabilty studies resulted with feedback from 
Surface Warfare Officers who felt that the system and the idea were a great start, but to 
make the system even better we could replace the mouse or touch pad with a touch¬ 
screen. This would make the system more usuable and easier to operate in “at-sea” 
conditions. 

We envision a future system being completely touch-screen based. In this system 
the operator or user would not have to operate a mouse or touch pad. There is 
considerable work in applying touch-screen technology. The current system is modular 
enough that reprogramming would mesh well with the integration of touch-screens. The 
future work would include integrating touch-screens, developing the callbacks and new 
code to handle the different events from a touch-screen. Additionally, linking this work 
and technology with the integration of the radar video. The ultimate vision is a flat- 
screen display above the Commanding Officers chair on the bridge where the CO can 
instantly look up and get critical safety information related to the maneuvering of his/her 
ship. If the CO desires to get additional information or tunnel deeper into the problem, 
then he/she can simply pull the information with a touch of the screen. 

4, Wireless LAN connectivity 

Another area of work is Wireless LAN connectivity. Specifically we are talking 
about the connectivity of wireless data transfer internal to the ship. The work would be 
related to the Wireless portion of the LAN. That is, ensure that the LAN, baring hardware 


33 



failures, from a software viewpoint is error free and maintains eontinuous eonneetivity. 
For, example, if a Commanding Offieer has a portable deviee, and the OOD sends a 
signal to notify the Captain that there is a eontaet of interest or eontaet report for him, the 
system must have a level of reliability that ensures that reguardless of where the CO is 
onboard the ship, he will be guaranteed to reeeive those messages with some level of 
eonfidenee. Additionally, there is work in design, eoding, and implmentation of the Ada 
modules that would handle the Wireless Network traffie and funetionality. 

5, Voice recognition technology 

Extensive work remains in the area of Voiee reeognition teehnology. If in the 
future, a voiee reeognition system is implemented where the Conning Offieer ean wear a 
headset and give eommands like “Right Standard Rudder” and the stearing system simply 
responds, then this type of system must have 100 pereent reliability and be zero error 
prone. 

On a less eritieal level, the Automatie Deek Log eould utilize voiee reeognition 
teehnology. In less sealed version of this design, the OOD or Conning offieer would give 
the eommands and voiee reeognition teehnology would automatieally enter speed and 
eourse ehanges into the Automatie Deek Log as well as the Digital Moboard Computer. 
The voiee eommands would not be eonneeted to the stearing system direetly, a 
Helmsman would still be “in the loop” per say, and respond to the eommands and exeeute 
the order. 

6. Mobile headset/communications 

This area of researeh is elosely related to the voiee reeognition teehnology, but 

foeuses more on the area of headset usability, environment analysis of headset 
teehnology, and the suitability of those produets in the shipboard environment. 
Additionally, researeh in the area of wireless headset eommunieations, the reliability of 
those eommunieations, maximum noise and distortion levels allowed while still 
maintaining the elarity and reliability required for eontinuous uninterrupted 
eommunieations is required. Extensive work must be done testing this type of system to 
validate and verify its reliability. One of the most important aspeets of maneuvering the 
ship is safety and reliability of any system. Before implementing this type of system, the 


34 



system must be thoroughly tested to demonstrate adequate data integrity and reliability to 
allow safety eritieal information to be transmitted via wireless communications. 

7. Automated Deck Log 

This research is a direct follow-on from our Digital Moboard program. The Deck 
Log should be written in Ada using the GNAT compiler and the GtkAda toolkit so that 
our original design of hardware and operating system portability, maintainability, 
extensibility are maintained with the additional functionality. The Automated Deck Log 
could be integrated with our Digital Moboard program in the following aspects. The 
Automated Deck Log would be a separated entity, a separate program that would 
maintain a log of events. The information could be entered via keyboard input, voice 
data entry, or stylis touch-screen type technology. The means by which the data or log 
entries are made is part of the follow-on research, but the design of the program should 
be modular enough that it does not matter how the data gets there, a standard interface 
and common protocol should be used. When either a speed or course is made in the 
Digital Moboard, a message would be sent to tell the Automatic Deck Log to make an 
entry, for example, “Course 183 Speed 13 knots.” Customized entries could be made in 
the log. During watch turnover the oncoming and offgoing OODs could digitally sign 
with the stylis on the screen. At the end of the day, the deck logs would be backed up for 
permanent archives, and both the paper and digital version would be signed by the 
Commanding Officer. 

8, Palm Pilot/CE devices providing information on demand 

Imagine that you’re the OOD underway; you have a contact that you have done a 
moboard on, and you need to call the Captain. The Captain is down in Engineering doing 
a Walkthrough, you have called, done an announcement on the IMC and still have not 
heard from the Captain. What do you do? The vision we forsee is a portable device that 
the Captain can carry on his belt with a graphical display that would display a mirror 
image of what the OOD sees on the bridge. When a contact of interest requires the 
Captain’s attention, his/her portable device vibrates and/or beeps until he reviews the 
contact of interest and presses his approval of the OODs recommendation or sends the 
OOD a message saying, “Do this instead.” Now that the CO has an instantaneous 


35 



graphical picture of the situation on the bridge; he/she ean eall the OOD and diseuss the 
situation further if he/she feels neeessary, or make his/her way to the bridge. 

Researeh should inelude a eomprehesive study on types of portable deviees, from 
both a usablity point of view to a functionality point of view. Additionally, researeh 
should be linked with the Wireless eonneetivity of those deviees on a shipboard 
environment. 

9. Integrated multiple views (FalconView, Heads-up displays, etc.) 

Researeh in the area of developing and/or integrating mulitiple views of the traek 
information that we have in our system eould inelude: Integrating FaleonView style 
programs. These programs will use the Latitude and Longitude information that Digital 
Moboard eontains and display the traek hits within FaleonView so that the user ean see 
the geographieal loeation on a NIMA ehart of both your own ship as well as any eontaets 
that you are traeking via radar. Additional views or uses remain open to researeh; sueh 
studies inelude usability work on the best way to present data to the ship driver. 
Additional researeh ean be done in the area of Heads-up display sereens, 3-D Graphieal 
representations, Holographie data representations, ete. 

10. Ada enabled Applets for browsers exchange 

Future work in this area would inelude enabling Ada Applets for Web based 
applieations. This would inelude, the ability to pull information up from speeifie 
platforms to a web browser as well as tunnel down into the data that specified platforms 
have. This would allow the Battle Group Commander to view the “pieture” that eaeh 
ship has, or eonsolidate the data from eaeh platform and display it in a web-based format. 

11. Artificial Intelligent Maneuvering Modules 

Our program contains the functionality to alert the OOD and CO when a contact 
will be within a set distance based upon the Commanding Officers Standing Orders. 
Future work includes more expert systems that generate signals for the OOD and/or CO 
that the designated contact will be within minimum distances set combined with 
maneuvering recommendations. The program should include functionality that gives the 
OOD recommendations based upon a standared Rules of the Road library. This library 
will alert the OOD/CO of important Rules of the Road and give recommended course and 


36 



speed ehanges based upon those rules and the Captains Standing Orders. The default 
being, maneuver the ship to maintain minimum set Closets Point of Approaeh (CPA). 
The eomputer program will also alert the OOD/CO if a course and/or speed change will 
affect the CPA of other contacts adversely or affect the safe navigation of the ship. These 
enhancements will be a guide/aid to the OOD/CO helping ensure safe navigation at sea 
thereby preventing collisions resultant to human-error, fatigue, or oversight. 


37 



THIS PAGE INTENTIONALLY LEET BLANK 


38 



APPENDIX A. DIGITAL MOBOARD CODE 


This appendix contains the object-oriented code of the Digital Moboard program. 
Included in this appendix are all of the .ads fdes used in our Object-orientated design. 

The current version of the program is divided into twenty-two classes. Enclosed 
are the .ads files and the Main program start point Navigator.adb 

A-1 DATES.ADS 

—I FILE: dates.ads 

—I AUTHOR: Joey L. Frantzen, Naval Post Graduate School 
-I LAST MODIFIED: II September 2001 

-I OPERATING ENVIRONMENT: Windows 2000(Designed to be 0/S Independent) 

-I COMPILER: GNAT 3.13p 

—I DESCRIPTION: This class is an upgrade taken from Ada 95 Problem Solving and 
—I Program Design pg. 492 - 493, 2nd Edition, by Feldman & Koffmann. 

—I Specification for package to represent dates, Orig Author Michael B. Feldman 
— I The George Washing University wrote Get_Date_From_System(everything else is 
— I orignal work. 

-I INPUTS: Ada.Calendar 

— I OUTPUTS: Outputs based on what Functions are requested and run. 

— I Process: None to note 
— I Assumptions: N/A 
— I Warnings: None 


39 






WITH Ada.Calendar; 
PACKAGE dates IS 


TYPE Date Type IS PRIVATE; 

SUBTYPE Month Number IS Ada.Calendar.Month Number; 

SUBTYPE Year Number IS Ada. Calendar.Year Number; 

SUBTYPE Day Number IS Ada.Calendar.Day Number; 

Date Error: EXCEPTION; 

—I Eunction: Get_Date_String_Erom_Number 
--1 Input: Month Number 

—I Output: Returns String related to Inputted Number Date 
—I Description: Input of a Month Number I-12 and returns a string 
—I associated with that date. Example Number One Inputted returns String 
—|"January" 

EUNCTION Get_Date_String_Erom_Number(M : IN Integer) RETURN String; 


40 




—I Function: Get_Date_From_System 
—I Input: Year, Month, Day 

—I Output: Returns a Date Type; analogous to Ada. Calendar. Clock 
—I Warnings: Date_Error if the year, month, day triple do not 
—I form a valid date (Feb 30th, for example) 

—I Analogous to Ada. Calendar. Time Of 

FUNCTION Get_Date_From_System RETURN Date Type; 

—I Procedure: Set_Date 

—I Input: Year_Number, Month_Number, Day_Number, Date_Type 
—I Output: Date_Type 

—I Description: Sets Year, Month, and Day into Date Type 
—I Warnings: None 

PROCEDURE Set_Date( D : IN Day Number; M : IN Month_Number; 
Y : IN Year_Number; 

Dat: IN OUT Date Type); 

—I Procedure: Set Month 
—I Input: Month Number, Date Type 
—I Output: Date Type 


41 





—I Description: Sets Year into Date_Type 
—I Warnings: None 

PROCEDURE Set_Month(M : IN Month_Number; Dat: IN OUT Date Type); 

—I Procedure: Set_Day 
—I Input: Day_Number, Date_Type 
—I Output: Date_Type 
—I Description: Sets Day into Date Type 
—I Warnings: None 

PROCEDURE Set_Day(D : IN Day Number; Dat: IN OUT Date_Type); 

—I Procedure: Set_Year 
—I Input: Year_Number, Date_Type 
—I Output: Date_Type 
—I Description: Sets Year into Date_Type 
—I Warnings: None 

PROCEDURE Set_Year(Y : IN Year_Number; Dat: IN OUT Date Type); 


42 





—I Function: Get Date 
—I Input: Date_Type 
—I Output: Date_Type 
—I Description: Returns a Date_Type value 
—I Warnings: None 

FUNCTION Get_Date(D : Date_Type) RETURN Date_Type; 

—I Function: Get Month 
—I Input: Date_Type 
—I Output: Month_Number 
—I Description: Returns a integer value 
—I Warnings: None 

FUNCTION Get_Month(D : Date_Type) RETURN integer; 

—I Funetion: Get Day 
—I Input: Date Type 
—I Output: Dat_Number 
—I Description: Returns a integer value 
—I Warnings: None 


43 






FUNCTION Get_Day(D : Date Type) RETURN integer; 

—I Funetion: Get Year 
—I Input: Date Type 
—I Output: Year_Number 
—I Deseription: Returns a integer value 
—I Warnings: None 

FUNCTION Get_Year(D : Date_Type) RETURN integer; 


PRIVATE 

TYPE Date Type IS RECORD 

Month : Month Number := Ada.Calendar.Month(Ada.Calendar.Clook); 
Day : Day Number := Ada.Calendar.Day(Ada.Calendar.Clock); 

Year : Year_Number := Ada.Calendar.Year(Ada.Calendar.Cloek); 

END RECORD; 

END dates; 


44 




A-2 TIME.ADS 


--| FILE: Time.ads 

— I AUTHOR: Joey L. Frantzen, Naval Post Graduate Sehool 
-I LAST MODIFIED: 11 September 2001 

-I OPERATING ENVIRONMENT: Windows 2000(Designed to be 0/S Independent) 
-I COMPILER: GNAT 3.13p 

—I DESCRIPTION: This elass is contains all of the data types and 
—I functionality to manipulate and type record Time 
-I INPUTS: N/A 

—I OUTPUTS: Outputs based on what Functions are requested and run. 

—I Process: None to note 
—I Assumptions: N/A 
—I Warnings: None 


PACKAGE times IS 


TYPE Time Type IS PRIVATE; 




45 




—I Function: Get_Time_Of_Day() 

—I Input: None 

—I Output: Current Time from Ada.Calendar.Cloek in a Time Type 

—I Proeess: Finds today's Time and returns it as a reeord of type Time 

—I Today's Time is gotten from PACKAGE Ada. Calendar 

FUNCTION Get Time Of Day RETURN Time Type; 

—I Proeedure: Set_Time 
—I Input: Hour, Minutes, Seeonds, Time_Type 
—I Output: Time_Type 

—I Description: Sets Hour, Minutes, and Seeonds into Time_Type 
—I Warnings: None 

PROCEDURE Set_Time(Hr : IN Integer; Min : IN Integer; See : IN Integer; 
T: IN OUT Time Type); 

—I Proeedure: Set_Hours 
—I Input: Hour, Time Type 
—I Output: Time Type 
—I Deseription: Sets Hours into Time Type 
—I Warnings: None 


46 






PROCEDURE Set_Hours(Hr : IN Integer; T ; IN OUT Time Type); 

—I Procedure; Set_Mins 
—I Input: Minutes, Time Type 
—I Output: Time_Type 

—I Description: Sets Mintues into Time_Type 
—I Warnings: None 

PROCEDURE Set_Mins(Min ; IN Integer; T ; IN OUT Time Type); 

—I Procedure; Set_Secs 
—I Input: Seconds, Time Type 
—I Output: Time_Type 

—I Description: Sets Seconds into Time Type 
—I Warnings: None 

PROCEDURE Set_Secs(Sec ; IN Integer; T ; IN OUT Time Type); 

—I Eunction: Get Time 
—I Input: Time Type 


47 





—I Output: Time_Type 
—I Description: Returns Time Type 
—I Warnings: None 

FUNCTION Get_Time(T : Time Type) RETURN Time Type; 

—I Function: Get Hours 
—I Input: Time_Type 
—I Output: Integer(Hours) 

—I Description: Returns an Integer from Time_Type(Hours) 

—I Warnings: None 

FUNCTION Get_Hours(T: Time_Type) RETURN Integer; 

—I Function: Get Mins 
—I Input: Time Type 
—I Output: Integer(Minutes) 

—I Description: Returns an Integer from Time_Type(Minutes) 

—I Warnings: None 

FUNCTION Get_Mins(T : Time Type) RETURN Integer; 


48 





—I Function: Get_Secs 
—I Input: Time_Type 
—I Output: Integer(Seconds) 

—I Description: Returns an Integer from Time_Type(Seoonds) 
—I Warnings: None 

FUNCTION Get_Sees(T : Time Type) RETURN Integer; 


PRIVATE 


TYPE Time Type IS RECORD 

Hours : Integer RANGE 0..24 := 0; 
Mins : Integer RANGE 0..59 := 0; 
Sees : Integer RANGE 0..59 := 0; 
END RECORD; 

END times; 

A-3 HIT.ADS 

-I FILE: Hit.ads 


49 




— I AUTHOR: Joey L. Frantzen, Naval Post Graduate School 
-I LAST MODIFIED: II September 2001 

-I OPERATING ENVIRONMENT: Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER: GNAT 3.13p 

— I DESCRIPTION: This class is contains all of the data types and 
—I functionality for a specific data point(or Hit) taken from manual 
—I or auto input. 

-I INPUTS: N/A 

—I OUTPUTS: Outputs based on what Eunctions are requested and run. 

—I Process: None to note 
—I Assumptions: N/A 
—I Warnings: None 

WITH lat long; 

WITH dates; 

WITH times; 

WITH Realnum; 

WITH degrees; 

WITH speeds; 

WITH ownship; 


PACKAGE hit IS 


50 




TYPE Hits IS PRIVATE; 


-TIME PROCEDURES and FUNCTIONS 




—I Procedure: Set_Hit_Time 

—I Input: Hour, Minute, Seeonds(all type Integer), Hit Type 
—I Output: Hit_Type 

—I Deseription: Saves Hour, Minute and Seeonds into Hit_Type.T_ime 

PROCEDURE Set_Hit_Time(Hr : IN Integer; Min : IN Integer; See : IN Integer; 

H : IN OUT Hits); 

—I Proeedure: Set Hit Time 
—I Input: Time_Type, Hit_Type 
—I Output: Hit Type 

—I Deseription: Saves Time Type into Hit Type.T ime 

PROCEDURE Set_Hit_Time(T_ime : IN times.Time Type; H : IN OUT Hits); 

—I Proeedure: Set Hit Hours 


51 



—I Input: Hours(integer), Hit_Type 
—I Output: Hit_Type 

—I Description: Saves Hours into Hit_Type.T_ime 

PROCEDURE Set_Hit_Hours(Hr : IN Integer; H : IN OUT Hits); 

—I Procedure: Set_Hit_Mins 
—I Input: Minutes(integer), Hit_Type 
—I Output: Hit Type 

—I Description: Saves Minutes into Hit_Type.T_ime 

PROCEDURE Set_Hit_Mins(Min : IN Integer; H : IN OUT Hits); 

—I Procedure: Set_Hit_Secs 
—I Input: Seconds(integer), Hit Type 
—I Output: Hit Type 

—I Description: Saves Seconds into Hit Type.T ime 

PROCEDURE Set_Hit_Secs(Sec : IN Integer; H : IN OUT Hits); 

—I Eunction: Get Hit Time 


52 



—I Input: Hit Type 
—I Output: Time_Type 

—I Description: Returns Hit Type.T ime Value of inputed Hit_Type 

FUNCTION Get_Hit_Time(H : Hits) RETURN times.Time Type; 

—I Function: Get_Hit_Hours 
—I Input: Hit_Type 
—I Output: Integer 

—I Description: Returns Integer Value(Hours) of inputed Hit_Type.T_ime 

FUNCTION Get_Hit_Hours(H: Hits) RETURN Integer; 

—I Function: Get_Hit_Mins 
—I Input: Hit Type 
—I Output: Integer 

—I Description: Returns Integer Value(Minutes) of inputed Hit Type.T ime 

FUNCTION Get_Hit_Mins(H : Hits) RETURN Integer; 

—I Function: Get Hit Secs 


53 



—I Input: Hit Type 
—I Output: Integer 

—I Deseription: Returns Integer Value(Seeonds) of inputed Hit_Type.T_ime 

FUNCTION Get_Hit_Sees(H : Hits) RETURN Integer; 


^ I H, P!R.OC^E/DT_J!R.!E d-iid 


—I Procedure: Set Hit Date 

—I Input: Day_Number, Month_Number, Year_Number, Hit_Type 
—I Output: Hit Type 

—I Description: Saves Day, Month and Year into Hit Type.Dat 

PROCEDURE Set_Hit_Date(D : IN dates.Day Number; M : IN dates.Month Number; 

Y : IN dates.Year_Number; H: IN OUT Hits); 

—I Procedure: Set_Hit_Date 
—I Input: Date_Type, Hit Type 
—I Output: Hit Type 

—I Description: Saves Date_Type into Hit Type.Dat 


54 



PROCEDURE Set_Hit_Date(D ; IN dates.Date_Type; H: IN OUT Hits); 

—I Procedure: Set Hit Month 
—I Input: Month_Number, Hit_Type 
—I Output: Hit_Type 

—I Description: Saves Month into Hit_Type.Dat 

PROCEDURE Set_Hit_Month(M : IN dates.Month_Number; H : IN OUT Hits); 

—I Procedure: Set_Hit_Day 
—I Input: Day_Number, Hit_Type 
—I Output: Hit Type 

—I Description: Saves Day into Hit_Type.Dat 

PROCEDURE Set_Hit_Day(D : IN dates.Day Number; H : IN OUT Hits); 

—I Procedure: Set_Hit_Year 
—I Input: Year_Number, Hit_Type 
—I Output: Hit Type 

—I Description: Saves Year into Hit Type.Dat 


55 



PROCEDURE Set_Hit_Year(Y ; IN dates.Year Number; H : IN OUT Hits); 

—I Eunction; Get Hit Date 
—I Input: Hit Type 
—I Output: Date Type 

—I Description: Returns Hit Type.Dat Value of inputed Hit_Type 

EUNCTION Get_Hit_Date(H : Hits) RETURN dates.Date_Type; 

—I Eunction: Get Hit Month 
—I Input: Hit_Type 
—I Output: Month_Number 

—I Description: Returns Month Value of inputed Hit_Type.Dat 

EUNCTION Get_Hit_Month(H : Hits) RETURN dates.Month_Number; 

—I Eunction: Get_Hit_Day 
—I Input: Hit Type 
—I Output: Day_Number 

—I Description: Returns Day Value of inputed Hit Type.Dat 


56 



FUNCTION Get_Hit_Day(H : Hits) RETURN dates.Day_Number; 

—I Function; Get Hit Year 
—I Input: Hit Type 
—I Output: Year_Number 

—I Description: Returns Year Value of inputed Hit_Type.Dat 

FUNCTION Get_Hit_Year(H : Hits) RETURN dates.Year_Number; 

-SET and GET HIT LATITUDE PROCEDURE and FUNCTIONS************* 

—I Proeedure: Set Hit Eatitude 

—I Input: Degree, Minute, Seeonds, Hemisphere Sign, Hit_Type 
—I Output: Hit Type 

—I Deseription: Saves Degree, Minute, Seconds, and Hemisphere into Hit Type.Eat 

PROCEDURE Set_Hit_Eatitude(D : IN Integer; M ; IN Integer; S : IN Integer; 

Sign ; IN Charaeter; H; IN OUT Hits); 

—I Proeedure: Set Hit Eatitude 


57 



—I Input: Latitude Type, Hit_Type 
—I Output: Hit_Type 

—I Deseription: Saves Latitude Type into Hit Type.Lat 

PROCEDURE Set_Hit_Eatitude(Eat: IN lat long.Eatitude; H: IN OUT Hits); 

—I Procedure: Set_Hit_Eat_Deg 
—I Input: Degree, Hit Type 
—I Output: Hit Type 

—I Description: Saves Degree into Hit Type.Eat 

PROCEDURE Set_Hit_Eat_Deg(D : IN Integer; H : IN OUT Hits); 

—I Procedure: Set_Hit_Eat_Min 
—I Input: Minutes, Hit Type 
—I Output: Hit Type 

—I Description: Saves Minutes into Hit_Type.Eat 

PROCEDURE Set_Hit_Eat_Min(M : IN Integer; H : IN OUT Hits); 

—I Procedure: Set Hit Eat Sec 


58 



—I Input: Seconds, Hit Type 
—I Output: Hit_Type 

—I Description: Saves Seconds into Hit Type.Lat 

PROCEDURE Set_Hit_Eat_Sec(S : IN Integer; H : IN OUT Hits); 

—I Procedure: Set Hit Eat Sign 
—I Input: Sign, Hit_Type 
—I Output: Hit Type 

—I Description: Saves Hemisphere Sign into Hit_Type.Eat 

PROCEDURE Set_Hit_Eat_Sign(Sign : IN Character; H : IN OUT Hits); 

—I Eunction: Get Hit Eatitude 
—I Input: Hit Type 
—I Output: Eatitude Type 

—I Description: Returns Eatitude Value of inputed Hit_Type.Eat 

EUNCTION Get_Hit_Eatitude(H : Hits) RETURN lat long.Eatitude; 

—I Eunction: Get_Hit_Eat_Deg 


59 



—I Input: Hit Type 
—I Output: Latitude Degree(Integer) 

—I Description: Returns Latitude Degree Value of inputed Hit Type.Lat 

FUNCTION Get_Hit_Lat_Deg(H : Hits) RETURN Integer; 

—I Function: Get Hit Lat Min 
—I Input: Hit_Type 
—I Output: Latitude Minute(Integer) 

—I Description: Returns Latitude Minute Value of inputed Hit Type.Lat 

FUNCTION Get_Hit_Fat_Min(H : Hits) RETURN Integer; 

—I Function: Get_Hit_Fat_Sec 
—I Input: Hit Type 
—I Output: Fatitude Seconds(Integer) 

—I Description: Returns Fatitude Seconds Value of inputed Hit_Type.Fat 

FUNCTION Get_Hit_Fat_Sec(H : Hits) RETURN Integer; 

—I Function: Get Hit Fat Sign 


60 



—I Input: Hit Type 

—I Output: Latitude Hemisphere Sign(Character) 

—I Description: Returns Latitude Hemisphere Sign Value of inputed Hit Type.Lat 

FUNCTION Get_Hit_Lat_Sign(H : Hits) RETURN Character; 


-SET and GET HIT LONGITUDE PROCEDURE and FUNCTIONS************* 

—I Procedure: Set_Hit_Longitude 

—I Input: Degree, Minute, Seconds, Hemisphere Sign, Hit_Type 
—I Output: Hit_Type 

—I Description: Saves Degree, Minute, Seconds, and Hemisphere into — - 

--| Hit Type.Lon 

PROCEDURE Set_Hit_Eongitude(D : IN Integer; M : IN Integer; S : IN Integer; 

Sign : IN Character; H: IN OUT Hits); 

—I Procedure: Set Hit Longitude 
—I Input: Eongitude Type, Hit Type 
—I Output: Hit_Type 

—I Description: Saves Longitude Type into Hit Type.Lat 


61 




PROCEDURE Set_Hit_Eongitude(Eon : IN lat long.Eongitude; 

H: IN OUT Hits); 

—I Procedure: Set_Hit_Eong_Deg 
—I Input: Degree, Hit_Type 
—I Output: Hit Type 

—I Deseription: Saves Degree into Hit Type.Eon 

PROCEDURE Set_Hit_Eong_Deg(D : IN Integer; H : IN OUT Hits); 

—I Proeedure: Set_Hit_Eong_Min 
—I Input: Minute, Hit Type 
—I Output: Hit_Type 

—I Deseription: Saves Minute into Hit Type.Eon 

PROCEDURE Set_Hit_Eong_Min(M : IN Integer; H : IN OUT Hits); 

—I Proeedure: Set_Hit_Eong_See 
—I Input: Seeonds, Hit Type 
—I Output: Hit Type 


62 



—I Description: Saves Seconds into Hit_Type.Lon 

PROCEDURE Set_Hit_Eong_Sec(S : IN Integer; H : IN OUT Hits); 

—I Procedure: Set Hit Eong Sign 
—I Input: Hemisphere Sign, Hit_Type 
—I Output: Hit Type 

—I Description: Saves Hemisphere Sign into Hit_Type.Eon 

PROCEDURE Set_Hit_Eong_Sign(Sign : IN Character; H : IN OUT Hits); 

—I Eunction: Get Hit Eongitude 
—I Input: Hit Type 
—I Output: Eongitude Type 

—I Description: Returns Eongitude Value of inputed Hit Type.Eon 

EUNCTION Get_Hit_Eongitude(H : Hits) RETURN lat long.Eongitude; 

—I Eunction: Get_Hit_Eong_Deg 
—I Input: Hit Type 
—I Output: Eongitude Degree(Integer) 


63 



—I Description; Returns Longitude Degree Value of inputed Hit_Type.Lon 

FUNCTION Get_Hit_Long_Deg(H : Hits) RETURN Integer; 

—I Function; Get Hit Long Min 
—I Input; Hit Type 
—I Output; Longitude Minute(Integer) 

—I Description; Returns Longitude Minute Value of inputed Hit_Type.Lon 

LUNCTION Get_Hit_Long_Min(H ; Hits) RETURN Integer; 

—I Function; Get Hit Long Sec 
—I Input; Hit Type 
—I Output; Longitude Seconds(Integer) 

—I Description; Returns Longitude Seconds Value of inputed Hit_Type.Lon 

LUNCTION Get_Hit_Long_Sec(H ; Hits) RETURN Integer; 

—I Function; Get_Hit_Long_Sign 
—I Input; Hit Type 
—I Output; Longitude Sign(Character) 


64 



—I Description; Returns Longitude Hemisphere Sign Value of inputed 
—I Hit Type.Lon 

FUNCTION Get_Hit_Long_Sign(H : Hits) RETURN Character; 

-SET and GET BEARING PROCEDURE and FUNCTIONS**************** 

—I Procedure: Set_Hit_Bearing 
—I Input; Bearing, Hit Type 
—I Output: Hit_Type 

—I Description: Sets Hit Bearing in Hit_Type to Inputed Value 

PROCEDURE Set_Hit_Bearing(Bear : IN degrees.Degree; H ; IN OUT Hits); 

—I Eunction: Get_Hit_Bearing 
—I Input: Hit Type 
—I Output: Bearing (Realnum.Real) 

—I Description: Returns Bearing Degree Value of inputed Hit Type 

EUNCTION Get_Hit_Bearing(H : Hits) RETURN Realnum.Real; 

-SET and GET RANGE PROCEDURE and FUNCTIONS****************** 


65 



—I Procedure: Set_Hit_Range 
—I Input: Range, Hit_Type 
—I Output: Hit_Type 

—I Deseription: Sets Hit Range in Hit Type to Inputed Value 

PROCEDURE Set_Hit_Range(Rng : IN Realnum.Real; H : IN OUT Hits); 

—I Eunction: Get_Hit_Range 
—I Input: Hit Type 
—I Output: Range (Realnum.Real) 

—I Deseription: Returns Range Value of inputed Hit_Type 

EUNCTION Get_Hit_Range(H : Hits) RETURN Realnum.Real; 

-SET and GET OWNSHIP CSE PROCEDURE and FUNCTIONS************* 

—I Procedure: Set_Hit_OwnShip_Cse 
—I Input: Course, Hit_Type 
—I Output: Hit Type 

—I Description: Sets OwnShip Course into Hit Type to Inputed Value 


66 



PROCEDURE Set_Hit_OwnShip_Cse(Course : in degrees.Degree; H : IN OUT Hits); 

—I Eunction; Get Hit OwnShip Cse 
—I Input: Hit Type 

—I Output: OwnShip Course(Realnum.Real) 

—I Deseription: Returns OwnShip Course Value of inputed Hit Type 

EUNCTION Get_Hit_OwnShip_Cse(H : Hits) RETURN Realnum.Real; 

-SET and GET TARGET CSE PROCEDURE and FUNCTIONS************** 

—I Procedure: Set Hit Target Cse 
—I Input: Course, Hit_Type 
—I Output: Hit Type 

—I Description: Sets Target Course into Hit_Type to Inputed Value 

PROCEDURE Set_Hit_Target_Cse(Course : in degrees.Degree; H : IN OUT Hits); 

—I Eunction: Get_Hit_Target_Cse 
—I Input: Hit Type 


67 



—I Output: Target Course(Realnum.Real) 

—I Description: Returns Target Course Value of inputed Hit_Type 

FUNCTION Get_Hit_Target_Cse(H : Hits) RETURN Realnum.Real; 

-SET and GET OWNSHIP SPEED PROCEDURE and FUNCTIONS************* 

—I Procedure: Set_Hit_OwnShip_Speed 
—I Input: Speed, Hit Type 
—I Output: Hit_Type 

—I Description: Sets OwnShip Speed into Hit_Type to Inputed Value 

PROCEDURE Set_Hit_OwnShip_Speed(Spd : IN speeds.Speed; H : IN OUT Hits); 

—I Function: Get_Hit_OwnShip_Speed 
—I Input: Hit Type 

—I Output: OwnShip Speed(Realnum.Real) 

—I Description: Returns OwnShip Speed Value of inputed Hit Type 

FUNCTION Get_Hit_OwnShip_Speed(H : Hits) RETURN Realnum.Real; 

-SET and GET HIT COUNTER PROCEDURE and FUNCTIONS************** 


68 



—I Procedure: Set_Hit_Counter 
—I Input: Counter, Hit Type 
—I Output: Hit_Type 

—I Deseription: Sets Counter into Hit Type to Inputed Value 

PROCEDURE Set_Hit_Counter(Counter : IN integer; H : IN OUT Hits); 

—I Eunction: Get_Hit_Counter 
—I Input: Hit Type 
—I Output: Hit Counter(Integer) 

—I Deseription: Returns Hit Counter Value of inputed Hit Type 

EUNCTION Get_Hit_Counter(H : Hits) RETURN integer; 


-SET and GET TARGET SPEED PROCEDURE and FUNCTIONS************ 

—I Procedure: Set_Hit_Target_Speed 
—I Input: Target Speed, Hit Type 
—I Output: Hit Type 


69 



—I Description: Sets Target Speed into Hit_Type to Inputed Value 

PROCEDURE Set_Hit_Target_Speed(Spd : IN speeds.Speed; H : IN OUT Hits); 

—I Eunction: Get_Hit_Target_Speed 
—I Input: Hit Type 

—I Output: Target Speed(Realnum.Real) 

—I Description: Returns Hit Target Speed Value of inputed Hit Type 

EUNCTION Get_Hit_Target_Speed(H : Hits) RETURN Realnum.Real; 

—I Procedure: Calc_Hit_Target_Angle 
—I Input: Hit Type 
—I Output: None 

—I Description: Calculates Target Angle based on inputed Hit current Bearing 
—I and Course. Once it calculates Target Angle the algorithm then saves it 
—I into Hit.Target_Angle 

PROCEDURE Calc_Hit_Target_Angle(H : IN OUT Hits); 

—I Procedure: Set_Hit_Target_Angle 


70 




—I Input: Target Angle, Hit_Type 
—I Output: Hit_Type 

—I Deseription: Sets Target Angle into Hit_Type to Inputed Value 

PROCEDURE Set_Hit_Target_Angle(Target_Angle : IN degrees.Degree; 

H : IN OUT Hits); 


—I Eunction: Get_Hit_Target_Angle 
—I Input: Hit Type 

—I Output: Target Angle(degrees.Degree) 

—I Deseription: Returns Hit Target Angle Value of inputed Hit Type 

EUNCTION Get_Hit_Target_Angle(H : Hits) RETURN degrees.Degree; 




—I Procedure: Calc Hit Eat Eong 
—I Input: Hit Type 
—I Output: None 

—I Description: Calculates Eatitude and Longitude of the inputed Hit based on 
—I Bearing and Range and OwnShips Lat/Long. This Procedures calls 
—I lat long.Calc Lat Long procedure to calculates the new lat/long. 


71 




PROCEDURE Calc Hit Eat Eong (Eatl ; IN lat long.Eatitude; 

Eongl ; IN lat long.Eongitude; H : IN OUT Hits); 


PRIVATE 


TYPE Hits IS RECORD 


Bear: degrees.Degree := 0.0; 

Rng : Realnum.Real := 0.0; —Stored in Yards 
Eat: lat long.Eatitude; 

Eon : lat long.Eongitude; 

Dat: dates.Date_Type := dates.Get Date Erom System; 
T ime: times.Time Type := times.Get Time Of Day; 
Target Cse : degrees.Degree := 0.0; 

OwnShip_Cse : degrees.Degree := 0.0; 

Target Speed : speeds.Speed := 0.0; 

OwnShip Speed : speeds.Speed := 0.0; 

Target Angle : degrees.Degree := 0.0; 

Hit Counter : integer := 0; 

END RECORD; 

END hit; 


72 



A-4 REALNUM.ADS 


—I File ; realnum.ads 

—I Purpose : This file defines a Real type that has preeision of digits 12. 

—I This also uses the Generie Elementary Functions for all Real Types 

WITH Ada.Numerics.Generic_Elementary_Functions; 

WITH Ada.Numerics; USE Ada.Numerics; 

PACKAGE Realnum IS 

TYPE Real IS DIGITS 12; 

PACKAGE Real Functions IS 

NEW Generic_Elementary_Functions(Real); 

END Realnum; 

A-5 SPEEDS.ADS 

--| File : speeds.ads 

—I Purpose : This file defines a type Speed that is of Realnum. Real with digits 
—I 1 precision and a range of 0.0 to 1000.0 knots 


73 





WITH Realnum; USE Realnum; 


PACKAGE speeds IS 

SUBTYPE Speed IS Real DIGITS I RANGE O.O.. 1000.0; 

— Max speed set to 1000.0 Knots; 

— this is designed this way beeause our program is designed to traek 

— surfaee/subsurfaee eontacts, and possibly helieopters. This upper range is 

— set because a user could input a wrong bearing that causes the speed 

— calculated to go outside normal reasonable knots. 

END speeds; 

A-6 DEGREES.ADS 

—I Eile ; degrees.ads 

—I Purpose : This file defines a type Degree that is of Realnum.Real type with 
—I a precision of digits one and range of 0.0 to 359.9 


74 



WITH Realnum; 


USE Realnum; 


PACKAGE degrees IS 

SUBTYPE Degree IS Real DIGITS I RANGE 0.0..359.9; 

END degrees; 

A-7 OWNSHIP.ADS 

— I EIEE: ownship.ads 

— I AUTHOR: Joey E. Erantzen, Naval Post Graduate Sehool 
-I EAST MODIEIED: 11 September 2001 

-I OPERATING ENVIRONMENT: Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER: GNAT 3.13p 

—I DESCRIPTION: This class is contains all of the data types and 
—I functionality for your ownship. 

-I INPUTS: N/A 

—I OUTPUTS: Outputs based on what Eunctions are requested and run. 

—I Process: None to note 
—I Assumptions: N/A 
—I Warnings: None 

WITH lat long; 

WITH degrees; 

75 




WITH speeds; 

WITH Utilities; 

WITH file io; 

WITH historiealio; 

WITH times; 

WITH Ada.Strings.Fixed; 

PACKAGE ownship is 

—I Procedure: Init_OwnShip 

—I Input: OS Number, OS Id, OS Course, OS Speed, Latitude, Longitude 
—I Output: None 

—I Description: Initializes and sets all inputed values into Ownship record 

PROCEDURE Init_OwnShip(OS_Number : IN integer; OS Id : IN String; 

OS_Cse : IN degrees.Degree; OS_Speed : IN speeds.Speed; 
Latl : IN lat_long.Latitude; Longl : IN lat_long.Longitude); 

—Eventually LAT/LONG will be pulled from either Manual/GPS entry 
—Eor now will pass in manually 

—I Eunction: Reset OwnShip 


76 



—I Input: None 
—I Output: Boolean 

—I Deseription: Resets all inputed values into Ownship reoord(Zero's Out) 

FUNCTION Reset Ownship RETURN Boolean; 

—I Proeedure: Set_OwnShip_Number 
—I Input: Integer 
—I Output: None 

—I Deseription: Sets Ownship Number into Ownship reeord Ownship Number 

PROCEDURE Set_OwnShip_Number(OS_Number : IN integer); 

—I Funetion: Get OwnShip Number 
—I Input: None 
—I Output: Integer 

—I Deseription: Gets Ownship Number info from Ownship reeord Ownship Number 

FUNCTION Get_OwnShip_Number RETURN integer; 

—I Proeedure: Set_OwnShip_Id 


77 



—I Input: String 
—I Output: None 

—I Description: Sets Ownship Number into Ownship record Ownship id 

PROCEDURE Set_OwnShip_Id(OS_Id : IN String); 

—I Eunction: Get OwnShip Id 
—I Input: None 
—I Output: String 

—I Description: Gets Ownship Id info from Ownship record Ownship id 

EUNCTION Get OwnShip Id RETURN string; 

—I Procedure: Set OwnShip Cse 
—I Input: Course (degrees.degree) 

—I Output: None 

—I Description: Sets Ownship Course into Ownship record Ownship_Cse 

PROCEDURE Set_OwnShip_Cse(OS_Cse : IN degrees.Degree); 

—I Eunction: Get OwnShip Cse 


78 



—I Input: None 

—I Output: degrees.Degree(Course) 

—I Description: Gets Ownship Course info from Ownship record Ownship Cse 

FUNCTION Get_OwnShip_Cse RETURN degrees.Degree; 

—I Procedure: Set OwnShip Speed 
—I Input: Speed (speeds.Speed) 

—I Output: None 

—I Description: Sets Ownship Speed into Ownship record Ownship Speed 

PROCEDURE Set_OwnShip_Speed(OS_Speed : IN speeds.Speed); 

—I Function: Get OwnShip Speed 
—I Input: None 

—I Output: speeds.Speed(Speed) 

—I Description: Gets Ownship Speed info from Ownship record Ownship Speed 

FUNCTION Get_OwnShip_Speed RETURN speeds.Speed; 

—I Procedure: Set OwnShip Lat 


79 



—I Input: Degrees, Minutes, Seeonds, Hemisphere Sign 
—I Output: None 

—I Description: Sets Ownship Latitude into Ownship record Ownship Lat 

PROCEDURE Set_OwnShip_Eat(D : IN lat long.Eat Degree; M: IN lat long.Min utes; 

S : IN lat_long.Sec_onds; Sign : IN Character); 

—I Eunction: Get_OwnShip_Eat 
—I Input: None 
—I Output: lat_long.Eatitude 

—I Description: Gets Ownship Eatitude info from Ownship record Ownship Eat 

EUNCTION Get_OwnShip_Eat RETURN latJong.Eatitude; 

—I Procedure: Set OwnShip Eong 
—I Input: Degrees, Minutes, Seconds, Hemisphere Sign 
—I Output: None 

—I Description: Sets Ownship Eongitude into Ownship record Ownship Eon 

PROCEDURE Set_OwnShip_Eong(D : IN lat long.Eong Degree; 

M : IN lat long.Min utes; 

S : IN lat_long.Sec_onds; Sign : IN Character); 


80 



—I Function: Get OwnShip Long 
—I Input: None 
—I Output: lat_long.Longitude 

—I Description: Gets Ownship Longitude info from Ownship record Ownship Lon 

FUNCTION Get OwnShip Long RETURN lat long.Longitude; 

—I Procedure: Load OwnShip Data 
—I Input: OwnShip_Data Type 
—I Output: None 

—I Description: Sets Ownship Data Type info into Ownship record 

PROCEDURE Eoad_Ownship_Data(Ownship_Data : IN file io.OS Data Type); 

TYPE own ship IS RECORD 

OwnShip_Number : integer := 0; —Set to Hull Number/Associated Number 
OwnShip_Ident: String(L.20) := Utilities.Get Default String; 

—max length is 20 characters 

OwnShip Cse : degrees.Degree := 0.0; 

OwnShip Speed : speeds.Speed := 0.0; —Expressed in Knots 
Eat: lat long.Eatitude; 


81 



Lon: lat long.Longitude; 

END RECORD; 

OS Data : file io.OS Data Xype; 

Eile Saved ; Boolean; 

OWNSHIP CONST : CONSTANT integer := 1; 

Ship Data ; historical_io.Historieal_Data_Type(OWNSHIP_CONST); 

Own Ship Info ; own ship; 

END ownship; 

A-8 TRACKS.ADS 

—I EIEE: traeks.ads 

— I AUTHOR: Joey E. Erantzen, Naval Post Graduate Sehool 
-I EAST MODIEIED: 14 September 2001 

-I OPERATING ENVIRONMENT: Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER: GNAT 3.13p 

— I DESCRIPTION: This elass is eontains all of the data types and 
—I funetionality for a speeifie traek and an array of traeks that eontains a 
— I link list of hits associated with that track. 

-I INPUTS: N/A 

— I OUTPUTS: Outputs based on what Eunctions are requested and run. 

— I Process: None to note 
— I Assumptions: N/A 
— I Warnings: None 


82 






WITH hit; 

WITH times; 

WITH dates; 

WITH Realnum; 

WITH degrees; 

WITH speeds; 

WITH ownship; 

WITH lat long; 

WITH Utilities; 

WITH fde io; 

WITH historieal io; 

WITH Ada.Strings; 

WITH Ada.Strings.Fixed; 

WITH Ada.Uneheeked Dealloeation; 
WITH Gdk.Color; 


PACKAGE tracks IS 


Number Of Tracks : integer := Utilities.LAST TRACK SLOT - 

Utilities.BEGINTRACKSLOT; 


83 



SUBTYPE Active index IS integer RANGE l..Number_Of_Traeks; 

—Maintains sorted Eist of all tracks that are active 

TYPE Active Track Eist Array IS ARRAY (Active index) OE integer; 


TYPE Eist Hit Type; —Declaration of Eist Hit Type is promise for full 
—declaration in follow on code. 


TYPE Eist Hit Pointer Type IS ACCESS Eist Hit Type; —Delcares Type pointer to 

—EistHitType 


TYPE Eist Hit Type IS 
RECORD 
H : hit.Hits; 

Next: Eist_Hit_Pointer_Type := NULE; 

Prev : Eist_Hit_Pointer_Type := NUEE; 

END RECORD; 

—I Procedure: Clear_Active_Track_Eist 
—I Input: None 
—I Output: None 

—I Description: Sets all values in Active_Track_Eist to Zero. 

PROCEDURE Clear Active Track Eist; 


84 



—I Function: Get_Active_Track_List 
—I Input: None 

—I Output: Active Traek List Array 
— I Deseription: Returns Aetive_Traek_List. 

FUNCTION Get_Aetive_Traek_List RETURN Active_Track_List_Array; 

—I Proeedure: Get_A_New_Traek_Number 
— I Input: None 

— I Output: Traek Number and Boolean(Can_Make_Track) 

— I Deseription: Cyeles through the Traek_List Array and finds first available 

— I track Number. If on the first eyele track array is full, then runs 

— I Purge Old Traeks. The algorithm will then run through the traek array a 

— I seeond time and find the first available slot. If on the seeond eyele 

— I there are no track numbers available, returns LAST_TRACK_SLOT Number and 

-I Boolean set to FALSE(Meaning NO TRACKS AVAIEABLE). 

PROCEDURE Get_A_New_Traok_Number(Track_Num : OUT 

Utilities.Traok_Number_Range; 

Can Make Traek : OUT Boolean); 


85 




—I Procedure: Add_Track 

—I Input: Track Number, Traek id, Bearing, Range, Traek Seale 
—I Output: None 

—I Deseription: Checks if Track_Number IN is Available, if Available then 
—I stores inputed data into TrackNumber slot of Track List Array. If Track 
—I Num in is not available, algorithm finds a available then saves data into 
—I next available track slot. Add_Track also calls Add A Hit, which builds a 
—I new Hit with the bearing and range entered and puts it at the Head of 
—I Hit List. Additionally Saves Hit and Track Data into the Lastest and 
—I Historical datafiles. 

PROCEDURE Add_Traek(Traek_Num : IN Utilities.Track_Number_Range; 

Track_Id: IN String; 

Bear : IN degrees.Degree; Rng : IN Realnum.Real; 

T Scale : IN integer; Traek Color : Gdk.Color.Gdk Color); 

—I Procedure: Add Track Hit 

—I Input: Traek Number, Bearing, Range, Track Scale 
—I Output: None 

—I Deseription: Stores Track Scale into Track Num and Adds a New Hit to 
—I Hit_Eist for associated Track Number via Add_A_Hit Proeedure. Additionally 
—I Saves Hit and Traek Data into the Eastest and Historical datafiles. 


86 





PROCEDURE Add_Track_Hit(Track_Num : IN Utilities.Track_Number_Range; 

Bear: IN degrees.Degree; 

Rng : IN Realnum.Real; T Scale : IN integer); 

—I Procedure: Set_Purge_Time 
—I Input: Old Time 
—I Output: None 

—I Description: Sets variable Purge Time to inputed integer Old Time. Old 
—I Time represents the purge time in hours(1..12) and is the range of hours. 

—I If the integer is not within the Purge_Time Range then Purge Time does not 
—I change. Purge_01d_Tracks is run whenever Purge Time is changed to a 
—I smaller value. 

PROCEDURE Set_Purge_Time(New_Time : IN integer); 

—I Procedure: Purge Old Tracks 
—I Input: None 

—I Output: None - At least, no return values 

—I Description: Cycles through the Track Eist Array and checks to see last hit 
—I update for each track. If the last hit on that track is older then the set 
—I Oldest Time then Purges this track from the array and resets the track data 


87 





—I to Zero point. 

PROCEDURE Purge Old Tracks; 


—I Procedure: Change Track Number 

—I Input: Request Track Number, Current Track Number 

—I Output: Boolean representing if Requested Track Number was free. 

—I Description: Algorithm bas two cases. Case 1, tbe requested track number is 
—I free and then current Track number is moved into requested track number 
—I slot. Current Slot is then cleared. Track Tree is Returned TRUE. Case 2, 

—I Requested Track Number is not free.In this case, Track Info in Requested 
—I Slot moved into first available slot. Then Current Track Number is moved 
—I into wanted slot, and current slot is cleared. Track Tree is returned True. 

—I If in both cases there are NO free slots, Purge_01d_Tracks is executed and 
—I both cases are tried again. If again, there are no free slots, then Track 
—I Tree is returned false. Historical and Eatest Eile Database are updated 
—I after each change. 

PROCEDURE Change_Track_Number( Wanted_Track_Number : IN 

Utilities.Track_Number_Range; 

Current_Track_Number: IN 
Utilities.TrackNumberRange; 


88 




Track Num Free : OUT Boolean); 

—I Procedure: Set_Track_Cse_And_Speed 
—I Input: Track Number, Course, Speed 
—I Output: None 

—I Description: Saves Track Course and Speed into the Last Hit Target_Course 
—I and Speed variables, then Calls Calculate Target Angle in the Hit Class, 

—I Saves the Hit into the latest and historical databases. Then saves course 
—I and speed in Track and saves target angle in track. Then the algorithm 
—I saves the updated Track in Latest and historical databases. 

PROCEDURE Set_Track_Cse_And_Speed(Track_Num: IN 
Utilities.TrackNumberRange; 

Course : IN degrees.Degree; 

Spd : IN Realnum.Real ); 

—I Procedure: Set_Track_Id 
—I Input: Track Number, Strmg(Track Id) 

—I Output: None 

—I Description: Saves Track Id into the Track Number variable called Track id. 
—I Saves the New Track Information into the latest and historical database 
—I fdes. 


89 







PROCEDURE Set_Track_Id(Track_Num : IN Utilities.Track_Number_Range; 

Track_Id : IN String); 

—I Procedure: Set Track Scale 
—I Input: Track Number, Scale(Integer) 

—I Output: None 

—I Description: Saves Track Scale into the Track Number variable called 
—I Track Scale. Algorithm Checks if Track Scale has been set, if not then 
—I saves inputed Track Scale If Track Scale already set, then does a 
—I comparison and saves the Track Scale whose value is greater. I.E. If I go 
—I from a 5:1 to 10:1 Scale then Track Scale is 10:1 overall. Saves the Track 
—I Information into the latest and historical database files. 

PROCEDURE Set_Track_Scale(Track_Num : IN Utilities.Track_Number_Range; 

Scale : IN integer); 


I Procedure: Set_Track_Color 

I Input: Track Number, Track_Color(Gdk.Color.Gdk_Color) 

I Output: None 

I Description: Saves Track Color into the Track Number variable called 


90 




—I Track Color. Saves the New Track Information into the latest and historical 
—I database files. 

PROCEDURE Set_Track_Color(Track_Num : IN Utilities.Track_Number_Range; 

Track Color; IN Gdk.Color.Gdk Color); 

—I Procedure: Set Track CPA 
—I Input: Track Number, Bearing, Time, and Range 
—I Output: None 

—I Description: Saves CPA Bearing, Time and Range into the associated Track 
—I Number variables. Verifies CPA Range vs. Closest CPA Track Number Range, 
—I if less then current closest CPA, then sets Closests_CPA_Track_Number to 
—I Track Num. Saves the New Track Information into the latest and historical 
—I database files. 

PROCEDURE Set_Track_CPA(Track_Num : IN Utilities.Track_Number_Range; 
Bearing : IN Utilities.My_Degree; 

T ime : IN integer; Rng : IN Realnum.Real); 

—I Procedure: Set Track CPA Bearing 
—I Input: Track Number, Bearing 
—I Output: None 


91 




—I Description: Saves CPA Bearing into the associated Track Number CPA Bearing 
—I variable. Saves the New Track Information into the latest and historical 
—I database fdes. 

PROCEDURE Set_Track_CPA_Bearing(Track_Num: IN 
Utilities.Track_Number_Range; 

Bearing : IN Utilities.My_Degree); 

—I Procedure: Set_Track_CPA_Time 
—I Input: Track Number, Time 
—I Output: None 

—I Description: Saves CPA Time into the associated Track Number CPA_Time 
—I variable. Saves the New Track Information into the latest and historical 
—I database fdes. 

PROCEDURE Set_Track_CPA_Time(Track_Num : IN Utilities.Track_Number_Range; 

T_ime : IN integer); 

—I Procedure: Set_Track_CPA_Range 
—I Input: Track Number, Range 
—I Output: None 

—I Description: Saves CPA Range into the associated Track Number CPA_Range 


92 




—I variable. Saves the New Track Information into the latest and historical 
—I database files. 

PROCEDURE Set_Track_CPA_Range(Track_Num ; IN Utilities.Track_Number_Range; 

Rng ; IN Realnum.Real); 

—I Procedure: Set Track CPA Eaired 
—I Input: Track Number, Boolean 
—I Output: None 

—I Description: Saves CPA Boolean Paired into the associated Track Number 
—I CPA_Is_Paired variable. Saves the New Track Information into the latest 
—I and historical database files. 

PROCEDURE Set_Track_CPA_Paired(Track_Num : IN Utilities.Track_Number_Range; 

Paired: IN boolean); 


—I Punction: Get_Purge_Time 
—I Input: None 

—I Output: integer(represents Purge time in hours) 

—I Description: Returns Purge_Time variable which represents time late in 
—I hours that Purge Tracks drops tracks that last hit was greater than or 


93 





—I equal to Purge Time. 

FUNCTION Get Purge Time RETURN integer; 

—I Funetion; Get Traek Cse 
—I Input; Traek Number 

—I Output: degrees.Degree(represents Traek Course in Degrees) 

—I Deseription: Returns Traek Course assoeiated with Traek Number entered. 

FUNCTION Get_Traek_Cse(Traek_Num : IN Utilities.Traek Number Range) 
RETURN degrees.Degree; 

—I Eunetion: Get Traek Speed 
—I Input: Traek Number 

—I Output: Realnum.Real(represents Traek Speed in Realnum.Real) 

—I Deseription: Returns Traek Speed assoeiated with Traek Number entered. 

EUNCTION Get_Traek_Speed(Traek_Num : IN Utilities.Traek Number Range) 
RETURN Realnum.Real; 

—I Eunetion: Get Traek Id 


94 



—I Input; Track Number 
—I Output: String(represents Track Id in String) 

—I Description: Returns Track Id associated with Track Number entered. 

FUNCTION Get_Track_Id(Track_Num : IN Utilities.Track_Number_Range) RETURN 
String; 

—I Function: Get Track Scale 
—I Input: Track Number 

—I Output: integer(represents Track Scale in integer) 

—I Description: Returns Track Scale associated with Track Number entered. 

FUNCTION Get_Track_Scale(Track_Num : IN Utilities.Track Number Range) 
RETURN integer; 

—I Function; Get Track Color 
—I Input; Track Number 

—I Output: Gdk.Color.Gdk_Color(represents Track Color) 

—I Description: Returns Track Color associated with Track Number entered. 

FUNCTION Get_Track_Color(Track_Num : IN Utilities.Track_Number_Range) 
RETURN Gdk.Color.Gdk Color; 


95 



—I Function: Get_Track_Last_Hit_Lat 
—I Input: Track Number 

—I Output: lat_long.Latitude(represents Tracks Last Latitude Coordinate) 

—I Deseription: Returns Traek Latitude(of last Hit) assoeiated with Traek 
—I Number entered. 

FLTNCTION Get_Traek_Last_Hit_Lat(Traek_Num : IN Utilities.Traek Number Range) 
RETURN lat long.Latitude; 

—I Funetion: Get_Track_Last_Hit_Long 
—I Input: Traek Number 

—I Output: lat_long.Longitude(Represents Traeks Last Longitude Coordinate) 

—I Deseription: Returns Traek Longitude(of last Hit) assoeiated with Traek 
—I Number entered. 

FUNCTION Get_Traek_Last_Hit_Long(Track_Num: IN 

Utilities.Track_Number_Range) RETURN lat long.Eongitude; 

—I Eunetion: Get_Traek_CPA_Bearing 
—I Input: Traek Number 


96 





—I Output: Utilities.My_Degree(represents Track CPA in Degrees) 

—I Description: Returns Track CPA Bearing associated with Track Number 
—I entered. 

FUNCTION Get_Track_CPA_Bearing(Track_Num : IN Utilities.Track_Number_Range) 
RETURN Utilities.My_Degree; 

—I Function: Get Track CPA Time 
—I Input: Track Number 

—I Output: Integer(represents Track CPA in Time(I230) 

—I Description: Returns Track CPA Time associated with Track Number entered. 

FUNCTION Get_Track_CPA_Time(Track_Num : IN Utilities.Track_Number_Range) 
RETURN integer; 

—I Function: Get_Track_CPA_Range 
—I Input: Track Number 

—I Output: Realnum.Real(represents Track CPA in Range 

—I Description: Returns Track CPA Range associated with Track Number entered. 

FUNCTION Get_Track_CPA_Range(Track_Num : IN Utilities.Track_Number_Range) 
RETURN Realnum.Real; 


97 



—I Function: Get Track CPA Faired 
—I Input: Track Number 

—I Output: boolean (represents Traek CPA Faired status 

—I Deseription: Returns Track CPA Faired variable associated with Track Number 
—I entered. 

FUNCTION Get_Track_CPA_Faired(Track_Num : IN Utilities.Track_Number_Range) 
RETURN boolean; 

—I Procedure: Get_CPA_Info 
—I Input: Track Number 

—I Output: Last Hit Bearing, Range, and Time and Second to Last Hit Bearing, 

—I Range, and Time. Returns Seale that the Track Should be ploted in. 

PROCEDURE Get_CPA_Info(Track_Num : IN Utilities.Traek_Number_Range; 

Eirst Bearing : IN OUT degrees.Degree; 

Seeond Bearing : IN OUT degrees.Degree; 

Eirst Range : IN OUT Realnum.Real; 

Seeond Range : IN OUT Realnum.Real; 

Eirst Time : IN OUT times.Time Type; 

Seeond Time : IN OUT times.Time Type; 


98 




Scale ; IN OUT integer); 


—I Proeedure; Get Hit Counter 
—I Input: Track Number 
—I Output: Hit_Counter 

—I Description: Returns Hit Counter, whieh represents number of Hits a traek 
—I has entered. 

FUNCTION Get_Hit_Counter(Traek_Num : IN Utilities.Track_Number_Range) 
RETURN integer; 

—I Procedure: Recalc_AIl_Traek_CPAs 
—I Input: None 
—I Output: None 

—I Description: This Procedure has not been implemented yet. 

PROCEDURE Recalc AII Track CPAs; 

—I Procedure: Get Paired Track Info 
—I Input: Traek Number 

—I Output: Pirst Bearing, East Bearing, Pirst Range, East Range, Pirst Time, 


99 




—I Last Time. Description; Receives a Track number and gets the First and Last 
—I Hit and returns the Bearing, Range, and Time of each of the hits. 

PROCEDURE Get_Eaired_Track_Info(Track_Num: IN 
Utilities.TrackNumberRange; 

Bearing 1 : OUT Utilities.My_Degree; 

Bearing! : OUT Utilities.My Degree; 

Rangel : OUT Realnum.Real; 

Range! : OUT Realnum.Real; 

Timel : OUT times.Time Type; 

Time! : OUT times.Time Type); 

—I Procedure: Get_East_Track_Bearing_Range 
—I Input: Track Number 
—I Output: Bearing, Range of Track Number 

—I Description; Procedure Returns the values of East Bearing and Range so that 
—I Moboard can load values into the list. 

PROCEDURE Get_East_Track_Bearing_Range(Track_Num: IN 
Utilities.Track_Number_Range; 

Bearing : OUT Utilities.My Degree; 

Rng : OUT Realnum.Real); 


100 




—I Procedure: Get Traek Info 
—I Input: Traek Number 

—I Output: Bearing, Range, Course, Speed, and Target Angle of Traek Number 
—I Deseription: Proeedure Returns the values of Bearing, Range, Course, Speed, 

—I and Target Angle of speeified traek number so Moboard ean load values into 
—I the list. 

PROCEDURE Get_Traek_Info(Traek_Num : IN Utilities.Traek_Number_Range; 

Brg : OUT Utilities.My Degree; Rng : OUT Realnum.Real; 
Cse : OUT Utilities.My Degree; 

Speed : OUT speeds.Speed; 

Target_Angle : OUT Utilities.My Degree); 

—I Eunetion: Drop Traek 
—I Input: Traek Number 

—I Output: Boolean(represents whether traek was sueeessfully dropped or not 
—I Deseription: Calls Clear Traek Data whieh resets and elears all traek and 
—I assoeiated Hit data. Also removes traek and assoeiated Hits from Eatest 
—I Database Eile. Cheeks if Traek Number is equal to Closest_CPA_Traok_Number 
—I then reealeulates it. 

EUNCTION Drop_Traek(Traek_Num : IN Utilities.Traek_Number_Range) RETURN 
Boolean; 


101 





—I Function: Command Data Reset 
—I Input: None 
—I Output: None 

—I Deseription: Clears Traek and Hit Information from Resident Memory, i.e. 
—I resets the database. Clears the Latest database files for Traeks, Hits, 

—I and Ownship. 

FUNCTION Command_Data_Reset RETURN Boolean; 

—I Function: Load_Last_Saved_Data 
—I Input: None 
—I Output: Boolean 

—I Deseription: Loads the Latest Database for Traeks, Hits, and Ownship into 
—I the Memory. 

LUNCTION Load_Last_Saved_Data RETURN Boolean; 

—I Function: Get_Track_Hit_List 
—I Input: Track Number 
—I Output: List_Hit_Pointer_Type 


102 





—I Description; Returns the Head Pointer of Hit_List for the associated Track 
—I Number. 

FUNCTION Get_Track_Hit_List(Track_Num : IN Utilities.Track Number Range) 
RETURN List Hit Pointer Type; 

—I Function: Get_Closest_CPA_Track_Number 
—I Input: None 
—I Output: Track Number 

—I Description: Returns the Track Number of the Track with the Closest CPA. 

FUNCTION Get_Closest_CPA_Track_Number RETURN 
Utilities.TrackNumberRange; 

—I Function: Get_Number_Of_Active_Tracks 
—I Input: None 

—I Output: Number of Active Tracks 
—I Description: Returns the Number of Active Tracks. 

FUNCTION Get_Number_Of_Active_Tracks RETURN integer; 

PRIVATE 


103 



TYPE Track Type IS RECORD 

Track_Number : Utilities.Track Number Range := Utilities.EAST_TRACK_SEOT; 
—Intialize All Records Track Number 

Track_Id : String(1..20) := Utilities.Get_Default_String; 

—max length is 20 characters 

Track Cse : degrees.Degree := 0.0; — average/faired Course of Track 

Track Speed : Realnum.Real := 0.0; — average/faired Speed of Track 
Target Angle ; degrees.Degree := 0.0; 

Track Scale : integer := 0; 

Track Color : Gdk.Color.Gdk Color := Gdk.Color.Null Color; 

—have to change later to right type 

CPA_Bearing : Utilities.My Degree := 0; 

CPA Range : Realnum.Real := 0.0; 

CPA Time ; integer := 0; 

CPA Is Eaired ; boolean := EALSE; 

—bit setting on whether CPA Values are faired values 
Hit Eist: Eist Hit Pointer Type; 

Hit Counter : integer := 0; 

END RECORD; 

—Defines the Upper and Lower Limites for Purge Time settings 
BOTTOM OLD TIME : CONSTANT integer := 1; 

TOP OLD TIME : CONSTANT integer := 12; 


104 



—Represents the Time in hours when Purge_Tracks will delete any tracks 
—older then this set time. Default is 12 hours 


Purge Time : integer RANGE BOTTOM_OLD_TIME..TOP_OLD_TIME := 12; 


TYPE Track Array IS ARRAY (Eltilities.Track Number Range) OE Track Type; 
—Holds records of Track Type and maintains all info on Tracks 
Track Eist: Track Array; 

—Maintains sorted Eist of all tracks that are active 
Active_Track_Eist: Active_Track_Eist_Array := ( others => 0 ); 

—Maintains total number of active tracks 
Number_Of_Active_Tracks : integer := 0; 

—Variable holds temporary Track data for saving to Eile Database 
Track Data : file_io.Track_Data_Type; 

—Variable holds tempoary Hit data for saving to Eile Database 
Hit Data : file_io.Hit_Data_Type; 

—Constant sets the Historical Database Type to contain Track Info 
TRACK CONST : CONSTANT integer := 2; 


105 



—Constant sets teh Historical Database Type to contain Hit Info 
HIT CONST ; CONSTANT integer := 3; 

—Variable holds tempoary Track data for saving to Historical Database 
Track Hist Data : historical_io.Historical_Data_Type(TRACK_CONST); 

—Variable holds tempoary Hit data for saving to Historical Database 
Hit Hist Data : historical_io.Historical_Data_Type(HIT_CONST); 

Track Saved ; Boolean; 

Hit Saved: Boolean; 

—Represents the track number that has the 
—current closest CPA value in yards. 

Closest_CPA_Track_Number : Utilities.Track Number Range := 
Utilities.LASTTRACKSLOT; 

END tracks; 

A-9 FILE lO.ADS 

—I FILE: file io.ads 

—I AUTHOR: Joey L. Frantzen, Naval Post Graduate School 
-I LAST MODIFIED: 12 September 2001 


106 



-I OPERATING ENVIRONMENT; Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER; GNAT 3.13p 

—I DESCRIPTION: This class is contains all of the data types and 
—I functionality allowing to save a database for crash recovery, restart 
—I recovery, or error recovery from a datebase that holds all current 
—I information. 

—I INPUTS: Based on specific functions and procedures are called. 

— I OUTPUTS: Based on what functions and procedures are called. 

— I Process: None to note 
— I Assumptions: N/A 
—I Warnings: None 

WITH utilities; 

WITH speeds; 

WITH degrees; 

WITH Realnum; 

WITH lat long; 

WITH times; 

WITH dates; 

WITH GNAT.IO Aux; 

WITH Gdk.Color; 

WITH Ada.Direct IO; 


107 




PACKAGE file io IS 


— record type represents all pertinent data for ownship and is used in file 

— io operations 

TYPE OS Data Type IS RECORD 

OwnShip_Number : integer := 99; —Set to Hull Number/Associated Number 
OwnSbip Ident: String(1..20) := Utilities.Get_Default_String; 

—max length is 20 characters 
OwnShip Cse ; degrees.Degree := 0.0; 

OwnShip Speed : speeds.Speed := 0.0; —Expressed in Knots 
Eat: lat long.Eatitude; 

Eon : lat long.Longitude; 

END RECORD; 


— record type represents all pertinent data for Hit type and is used in file 

— io operations 

TYPE Hit Data Type IS 
RECORD 

Track Number : Utilities.Track Number Range := Utilities.LAST_TRACK_SLOT; 
Bear: degrees.Degree := 0.0; 

Rng : Realnum.Real := 0.0; —Stored in Yards 
Eat: lat long.Latitude; 

Lon: lat long.Longitude; 


108 



Dat: dates.Date_Type; 

T ime: times.Time Type; 

Target Cse : degrees.Degree := 0.0; 
OwnShip Cse : degrees.Degree := 0.0; 
Target_Speed : speeds.Speed := 0.0; 
OwnShip_Speed : speeds.Speed := 0.0; 
Target_Angle : degrees.Degree := 0.0; 
Hit Counter : integer := 0; 

END RECORD; 


—reeord represents all pertinent data for traek type and is used in file io 
—operations 

TYPE Track Data Type IS 
RECORD 

Traek Number : Utilities.Track Number Range :=Utilities.EAST_TRACK_SLOT; 
—Intialize All Reeords Traek Number 
Traek id : String(1..20) := Utilities.Get Default String; —max length is 

—20 eharacters 

Traek Cse : degrees.Degree := 0.0; — Course of Traek 

Track Speed : Realnum.Real := 0.0; — Speed of Traek 

Target Angle : degrees.Degree := 0.0; 

Traek Seale : integer := 0; 


109 



Track Color : Gdk.Color.Gdk Color := Gdk.Color.Null Color; 

CPA Bearing : Utilities.My Degree := 0; 

CPA Range : Realnum.Real := 0.0; 

CPA Time ; integer := 0; 

CPA Is Faired : boolean := FALSE; 

Hit Counter ; integer := 0; 

END RECORD; 

—I Eunetion: Save_East_OwnShip_State 
—I Input: OS Date Type 
—I Output: Boolean 

—I Description: This is a Eatest(East State) recovery file. Saves the East 
—I updated information about ownship into file called ownship data.db If the 
—I file does not exist then the algorithm creates the file and saves the data. 

EUNCTION Save_East_OwnShip_State(Ownship_Data : IN OS Data Type) RETURN 
Boolean; 

—I Procedure: Save_East_Track_State 
—I Input: Track Date Type 
—I Output: Boolean 

—I Description: This is a Eatest(East State) recovery file. Saves the East 


no 




—I updated information about each Track into file called track data.db If the 
—I file does not exist then the algorithm creates the file and saves the data. 

PROCEDURE Save_East_Track_State(Track_Data : IN OUT Track Data Type; 

Track Saved : OUT Boolean); 

—I Procedure: Save_Last_Hit_State 
—I Input: Hit Date Type 
—I Output: Boolean 

—I Description: This is a Eatest(East State) recovery file. Saves the East 
—I updated information about each Hit into file called hit data.db If the file 
—I does not exist then the algorithm creates the file and saves the data. 

PROCEDURE Save_East_Hit_State(Hit_Data : IN OUT Hit Data Type; 

Hit Saved: OUT Boolean); 

—I Eunction: Save_Two_Hit_Track_Numbers 
—I Input: Wanted Track Number, Current Track Number 
—I Output: Boolean 

—I Description: This procedure takes two track numbers, one that the user 
—I wants to change the track number two, and the previous used track number. 

—I This procedure cycles through the Hit database and changes the the hits 


111 





—I with the current track track number to associate with the wanted track 
—I number. 

FUNCTION Swap_Two_Hit_Track_Numbers(Wanted; IN 

Utilities.Track_Number_Range; 

Current: IN Utilities.Track Number Range) 

RETURN Boolean; 

—I Function; Save_Three_Hit_Track_Numbers 

—I Input: Wanted Track Number, Current Track Number, New Track Number 
—I Output: Boolean 

—I Description: This procedure takes three track numbers, one that the user 
—I wants to change the track number too, and the previous used track number, 
—I and the new track number. This procedure cycles through the Hit database 
—I and changes the the hits to the associatede track numbers. 

FUNCTION Swap_Three_Hit_Track_Numbers(Wanted : IN 

Utilities.TrackNumberRange; 

Current: IN Utilities.Track Number Range; 

New_Track : IN Utilities.Track_Number_Range) 

RETURN Boolean; 

—I Function: Drop Track From Track State 

112 




—I Input; Track Number 
—I Output: Boolean 

—I Deseription: This proeedure deletes inputed traek number from the 
—I Latest(Last State).This is done by overwriting the index number(traek 
—I number) position with a null value. 

FUNCTION Drop_Traek_From_Traek_State(Traek_Num: IN 

Utilities.Traek Number Range) RETURN Boolean; 

—I Funetion; Drop_All_Traek_Hits_From_Hit_State 
—I Input; Traek Number 
—I Output: Boolean 

—I Deseription: This proeedure deletes all hits assoeiated with inputed traek 
—I number from the Latest(Last State). This is done by overwriting the hits 
—I assoeiated with index number(traek number) with a null value. 

FUNCTION Drop_All_Traek_Hits_From_Hit_State(Traek_Num: IN 
Utilities.Traek Number Range) RETURN Boolean; 

—I Function: Delete_OS_Eatest_Files 
—I Input: None 
—I Output: Boolean 


113 





—I Description; This procedure deletes all Latest files Ownship database.db, 

—I track database.db, and hit database.db 

FUNCTION Delete_Latest_Files RETURN Boolean; 

—I Function; Get Ownship Data From File 
—I Input; None 
—I Output; OS Data Type 

—I Description; This procedure returns the OS Data Type stored in Ownship 
—I database. This function accesses ownship database.db to retrieve the 
—I information. 

FUNCTION Get Ownship Data From File RETURN OS Data Type; 

—I True; Get_All_Saved_Tracks 
—I Input; Index 

—I Output; Track Data Type, Index, and Boolean 

—I Description; This procedure returns the Track_Data_Type stored in Track 
—I T database, he procedure will cycle through the complete database track by 
—I track as each sequential call is made. Once all tracks are loaded the 
—I Eoaded boolean is returned with value True. 


114 





PROCEDURE Get_All_Saved_Tracks(Track_Data ; OUT Track Data Type; 
Index : IN OUT Utilities.Track_Number_Range; 

Eoaded ; OUT Boolean; Eile Exists ; OUT Boolean); 

—I True; Get_All_Saved_Hits 
—I Input: Index 

—I Output: Hit Data Type, Index, and Boolean 

—I Deseription: This proeedure returns the Hit_Data_Type stored in Hit 
—I database. The proeedure will cycle through the complete database hit by Hit 
—I as each sequential call is made. Once all tracks are loaded the Eoaded 
—I boolean is returned with value True. 

PROCEDURE Get_All_Saved_Hits(Hit_Data : OUT Hit Data Type; 

Index : IN OUT integer; 

Eoaded; OUT Boolean); 


END fde_io; 

A-10 HISTORICAL lO.ADS 

—I EIEE: historical io.adb 

—I AUTHOR: Joey E. Erantzen, Naval Post Graduate School & Kenneth E. 
—I Ehresman(Sentry Eine). 


115 




-I LAST MODIFIED; 12 September 2001 

-I OPERATING ENVIRONMENT; Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER; GNAT 3.13p 

—I DESCRIPTION; This elass is contains all of the data types and 
—I functionality allowing to save a database for historical playback or 
— I display, this is a historical database by day, each new day there is a new. 

— I fde created or auto input. 

— I Due to Ada's limited ability to do fde io, delete, etc. There is one date 
— I type that exists based upon what the user case is, ownship data, track data, 

—I or hit data.There is also a Sentry case, that is saved into the historical 
— I file prior to each historical save, allowing the customer to read the 
— I sentry, determine the data tructure (next) and then reading the data 
— I structure, etc. 

— I INPUTS; Based on specific functions and procedures are called. 

— I OUTPUTS; Based on what functions and procedures are called. 

— I Process; None to note 
— I Assumptions; N/A 
— I Warnings; None 

WITH utilities; 

WITH speeds; 

WITH degrees; 

WITH Realnum; 

WITH lat long; 


116 




WITH times; 

WITH dates; 

WITH GNAT.IO Aux; 

WITH Gdk.Color; 

WITH Ada.Sequential lO; 

PACKAGE historic alio IS 

TYPE Historical_Data_Type(In_Use ; integer := 1) IS 
RECORD 
CASE In Use IS 
WHEN 1 => 

Time Stamp : times.Time Type := times.Get Time Of Day; 

OwnShip_Number : integer := 99; —Set to Hull Number/Associated Number 

OwnShip Ident: String(1..20) := Utilities.Get_Default_String; —max 

length is 20 character 

OwnShip Cse ; degrees.Degree := 0.0; 

OwnShip Speed : speeds.Speed := 0.0; —Expressed in Knots 
OwnShip Eat: lat long.Eatitude; 

OwnShip Eon : lat long.Eongitude; 

WHEN 2 => 

Track Number : Utilities.Track Number Range := 

Utilities.EAST TRACK SEOT; —Intialize All Records Track Number 

Track id : String(1..20) := Utilities.Get_Default_String; —max length is 

20 characters 


117 



Track Cse ; degrees.Degree := 0.0; — Course of Track 

Track Speed ; Realnum.Real := 0.0; — Speed of Track 

Track Target Angle ; degrees.Degree := 0.0; 

Track Scale ; integer := 0; 

Track Color ; Gdk.Color.Gdk Color := Gdk.Color.Null Color; 
CPA Bearing : Utilities.My Degree := 0; 

CPA Range : Realnum.Real := 0.0; 

CPA Time ; integer := 0; 

CPA Is Faired : boolean := FALSE; 

Track Hit Counter ; integer := 0; 

WHEN 3 => 

Hit Counter : integer := 0; 

Hit_Track_Number : Utilities.Track_Number_Range := 
Utilities.EASTTRACKSEOT; 

Bear; degrees.Degree := 0.0; 

Rng : Realnum.Real := 0.0; —Stored in Yards 
Hit Eat: lat long.Eatitude; 

Hit Eon : lat long.Eongitude; 

Dat: dates.Date Type; 

T ime: times.Time Type; 

Target Cse : degrees.Degree := 0.0; 

Hit_OwnShip_Cse ; degrees.Degree := 0.0; 

Target Speed : speeds.Speed := 0.0; 

Hit OwnShip Speed : speeds.Speed := 0.0; 


118 



Hit_Target_Angle : degrees.Degree := 0.0; 


WHEN 4 => 

Sentry : integer := 0; —Great and Many thanks go out to Ken Ehresman. 
WHEN OTHERS => 

NUEE; 

END CASE; 

END RECORD; 


—I Proeedure: New_Day_Change_Eile_Name 
—I Input: None 
—I Output: None 

—I Deseription: This proeedure retrieves the eurrent system date, eonverts the 
—I date into a string, for example 08/08/2001 is converted into 20010808.db 
—I and this is saved into the Historical Eile Name variable. 

PROCEDURE N ewDayChangeE ile_N ame; 

—I Eunction: Save Data To Eile 
—I Input: Historical Data Type 
—I Output: Boolean 

—I Description: This is a historical data file. Saves the historical data 


119 




—I information based on what case it is. Case 1, 2, 3 are data types for 
—I ownship, tracks, and hits.The data is saved in a file based on the date 
—I i.e. 20010808.db is for Aug 8 2001 

FUNCTION Save_Data_To_File(Data_In : IN Historical Data Type; 

Data Case : IN integer) RETURN Boolean; 


PRIVATE 


—stores the current date based off the system clock 
Current Date ; integer := 0; 

—stores the current file name for the historical database 
Historical Eile Name : String(1..12) := "2001hist.db 

END historical io; 

A-11 LAT LONG.ADS 

—I EIEE: lat_long.ads 

—I AUTHOR; Joey E. Erantzen, Naval Post Graduate School 
-I EAST MODIFIED; II September 2001 

-I OPERATING ENVIRONMENT; Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER; GNAT 3.13p 

—I DESCRIPTION; This Class defines a Eatitude and Eongitude type and 


120 




—I contains all of the fuctions and procedures to calculate a new 
—I latitude and longitude when given a point that is at a specific bearing 
—I and range. This class also handles computing distance between two 
—I given latitude and longitude coordinates. This class contains functions 
—I to convert between Kilometers, Yards, and Nautical Miles. This Class 
—I also contains two functions that call the Gps Class and retrieve a latitude 
—I and longitude. 

—I INPUTS; Ada.Numerics, Realnum.Real 
—I OUTPUTS: Outputs based on user request and data input 
—I Process: None to note 
—I Assumptions: N/A 
—I Warnings: None 

WITH Ada.Numerics; 

WITH Realnum; USE Realnum; 

USE TYPE Realnum.Real; 

PACKAGE lat long IS 


—Best Math Set Constant Declarations 


121 




RADIAN; CONSTANT Realnum.Real := 180.0/ Ada.Numerics.Pi; —Ada.Numerics.Pi 
==3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511 

TWO PI: CONSTANT Realnum.Real := 2.0 * Ada.Numeries.Pi; —Two Pi 

DEG TO RADIAN: CONSTANT Realnum.Real := Ada.Numerics.Pi/180.0; -Deg to 
Radian 

RADIAN TO DEG: CONSTANT Realnum.Real := 180.0/Ada.Numerics.Pi; -Radian 
to Deg 

EETH: CONSTANT Realnum.Real := 0.335_28106_6474E-2; —Elatting Constant(about 
1/298) 

RE: CONSTANT Realnum.Real := 6378.137; —Radius Earth at Equator=Semi- 

Major Axis 

ESQ: CONSTANT Realnum.Real := 2.0 * EETH - (EETH * EETH); 

A: CONSTANT Realnum.Real := 1000.0 * RE; 

TOE: CONSTANT Realnum.Real := 5.0E-15; 

SUBTYPE Min utes IS integer RANGE 0..59; 

SUBTYPE See onds IS integer RANGE 0..59; 

SUBTYPE Eat Degree IS integer RANGE 0..90; 

SUBTYPE Eong Degree IS integer RANGE 0..180; 


TYPE Eatitude IS private; 
TYPE Eongitude IS private; 


122 



— I Function: Get_NM_From_Yards(Realnum.Real) 

— I Input: Yards 
— I Output: Nautical Miles 

— I Description: Algorithm converts Yards to Nautieal Miles is taken from 
— I pg. 7 of Piloting and Dead Reckoning 3rd Ed written by 
-I H.H. Shufeldt, CAPT, USNR (Ret.). 

— I This standard was aecepted as Offieal by the United States in 1959. 

FUNCTION Get_NM_From_Yards(Yardl : Realnum.Real) RETURN Realnum.Real; 

—I Eunetion: Get_Yards_Erom_NM(Realnum.Real) 

— I Input: Nautieal Miles 
— I Ouput: Yards 

— I Deseription: Algorithm to eonvert Nautical Miles to Yards is taken from 
— I pg. 7 of Piloting and Dead Reekoning 3rd Ed written by 
— I H.H. Shufeldt, CAPT, USNR (Ret.). This standard was 
— I This Standard was aeeepted as Offieal by the United States in 1959. 

EUNCTION Get_Yards_Prom_NM(Natl : Realnum.Real) RETURN Realnum.Real; 

— I Eunetion: Get_NM_Erom_KM(Realnum.Real) 

— I Input: Kilometers 


123 





—I Output: Nautical Miles; 

—I Description: Algorithm to convert Kilometers to Nautical Miles is taken from 
—I pg. 7 of Piloting and Dead Reckoning 3rd Ed written by 
—I H.H. Shufeldt, CAPT, USNR (Ret.). This standard was 
—I This Standard was aecepted as Offical by the United States in 1959. 

FUNCTION Get_NM_From_KM(Kilo : Realnum.Real) RETURN Realnum.Real; 

—I Function: Get_Yards_From_KM(Realnum.Real) 

—I Input: Kilometers 
—I Output: Yards 

—I Discription: Algorithm to convert Kilometers to Yards is taken from 
—I pg. 7 of Piloting and Dead Reckoning 3rd Ed written by 
—I H.H. Shufeldt, CAPT, USNR (Ret.). This standard was 
—I This Standard was aecepted as Offical by the United States in 1959. 

FUNCTION Get_Yards_From_KM(Kilo : Realnum.Real) RETURN Realnum.Real; 

—I Function: Get_KM_From_Yards(Realnum.Real) 

—I Input: Yards 
—I Output: Kilometers 

—I Description: Algorithm to convert Yards to KM is taken from 


124 





—I pg. 7 of Piloting and Dead Reckoning 3rd Ed written by 

—I H.H. Shufeldt, CAPT, USNR (Ret.). This standard was 

—I This Standard was accepted as Offical by the United States in 1959. 

FUNCTION Get_KM_From_Yards(Yardl ; Realnum.Real) RETURN Realnum.Real; 

—I Function: Get_KM_From_NM(Realnum.Real) 

—I Input: Nautical Miles 
—I Output: Kilometers 

—I Description: Algorithm to convert Nautical Miles to Kilometers is taken from 
—I pg. 7 of Piloting and Dead Reckoning 3rd Ed written by 
—I H.H. Shufeldt, CAPT, USNR (Ret.). This standard was 
—I This Standard was accepted as Offical by the United States in 1959. 

FUNCTION Get_KM_From_NM(NatI : Realnum.Real) RETURN Realnum.Real; 

—I Function: Fat_To_Degrees 
—I Input: Fatitude 
—I Output: Degrees(0..360) 

—I Description: Convert Fatitude Type to Degrees 

FUNCTION Fat_To_Degrees(FatI: Fatitude) RETURN Realnum.Real; 


125 




—I Function: Long_To_Degrees 
—I Input: Longitude 
—I Output: Degrees(0..360) 

—I Description: Convert Longitude Type to Degrees 

FUNCTION Long_To_Degrees(LongI: Longitude) RETURN Realnum.Real; 

—I Function: Degrees To Lat 
--| Input: Degrees(0..360) 

—I Output: Latitude 

—I Description: Convert Degrees to Latitude Type 

FUNCTION Degrees_To_Lat(Deg: Realnum.Real) RETURN Eatitude; 

—I Function: Degrees To Eong 
--| Input: Degrees(0..360) 

—I Output: Eongitude 

—I Description: Convert Degrees to Eongitude Type 

EUNCTION Degrees_To_Eong(Deg: Realnum.Real) RETURN Eongitude; 


126 



—I Function: calc_lat_long 

—I Input: Latitude, Longitude, Bearing, Range(in Yards) 

—I Output: Latitude, Longitude, Bearing 

—I Deseription: All Values are Realnum.Real whieh has 12 digits of preeision 
—I Algorithm takes a Bearing and Distanee from a known Latitude & Longitude 
—I and eomputes new Latitude and Longitude, Baek Bearing. This Algorithm is 
—I from Professor John Clyneh, Naval Postgraduate sehool. Original program was 
—I written in Fortran and eonverted to Ada Code. Professor John Clyneh stated 
—I that this Algorithm has been reviewed and approved by the USGS. 

PROCEDURE eale lat long (Eatl: IN Eatitude; Eongl: IN Eongitude; 

Bearing 1: IN Realnum.Real; 

Rangel: IN Realnum.Real; Eat2: OUT Eatitude; 

Eong2: OUT Eongitude; 

Bearing2: OUT Realnum.Real); 


Eunetion: eale bearing dist 

Input: Eatitude, Eongitude, Eatitude, Eongitude 

Output: Bearing, Bearing, Range(in Yards) 


127 




—I Description; All Values are Realnum.Real which has 12 digits of precision 
—I Algorithm takes a two known Latitude & Longitude's and 
—I computes a fwd and back bearing, and Range. This Algorithm was take from 
—I Professor John Clynch, Naval Postgraduate school. Original program was 
—I written in Fortran and converted to Ada Code. Professor John Clynch stated 
—I that this Algorithm has been reviewed and approved by the USGS. 

PROCEDURE calc bearing dist (Eatl: IN Eatitude; Eongl; IN Eongitude; 

Eat2: IN Eatitude; 

Eong2: IN Eongitude; Bearingl; OUT Realnum.Real; 
Bearing2: OUT Realnum.Real; 

Rangel: OUT Realnum.Real); 

-SET and GET EATITUDE PROCEDURE and FUNCTIONS****************** 

—I Procedure: Set Eatitude 

—I Input: Degree, Minutes, Seconds ; Integers; Eatitude 
—I Output: Eatitude 

—I Description: Sets Degrees, Minutes, and Seconds into Eatitude Type 
—I Warnings: None 

PROCEDURE Set_Eatitude(D : IN Integer; M : IN Integer; S : IN Integer; 


128 





Sign : IN Character; Lat: IN OUT Latitude); 


—I Proeedure: Set_Lat_Deg 
—I Input: Degree: Integer; Latitude 
—I Output: Latitude 

—I Deseription: Sets Degrees into Latitude Type 
—I Warnings: None 

PROCEDURE Set_Eat_Deg(D : IN Integer; Eat: IN OUT Eatitude); 

—I Proeedure: Set_Eat_Min 
—I Input: Minutes: Integer; Eatitude 
—I Output: Eatitude 

—I Deseription: Sets Minutes into Eatitude Type 
—I Warnings: None 

PROCEDURE Set_Eat_Min(M : IN Integer; Eat: IN OUT Eatitude); 

—I Proeedure: Set_Eat_Sees 
—I Input: Seeonds: Integer; Eatitude 
—I Output: Eatitude 


129 





—I Description: Sets Seconds into Latitude Type 
—I Warnings: None 

PROCEDURE Set_Eat_Sec(S : IN Integer; Eat: IN OUT Eatitude); 

—I Procedure: Set_Eat_Sign 
—I Input: Sign: Character; Eatitude 
—I Output: Eatitude 

—I Description: Sets Sign into Eatitude Type 
—I Warnings: None 

PROCEDURE Set_Eat_Sign(Sign : IN Character; Eat: IN OUT Eatitude); 

—I Eunction: Get Eatitude 
—I Input: Eatitude 
—I Output: Eatitude 
—I Description: Returns Eatitude Type 
—I Warnings: None 

EUNCTION Get_Eatitude(Eat: Eatitude) RETURN Eatitude; 


130 





—I Function: Get Lat Deg 
—I Input: Latitude 
—I Output: Integer(Degrees) 

—I Description: Returns Integer Type 
—I Warnings: None 

FUNCTION Get_Lat_Deg(Lat: Latitude) RETURN Integer; 

—I Function: Get Lat Min 
—I Input: Latitude 
—I Output: Integer(Minutes) 

—I Description: Returns Integer Type 
—I Warnings: None 

FUNCTION Get_Lat_Min(Lat: Latitude) RETURN Integer; 

—I Eunction: Get Eat Sec 
—I Input: Eatitude 
—I Output: Integer(Seconds) 

—I Description: Returns Integer Type 


I3I 





—I Warnings: None 

FUNCTION Get_Lat_Sec(Lat: Latitude) RETURN Integer; 

—I Function: Get Lat Sign 
—I Input: Latitude 
—I Output: Character(Sign) 

—I Description: Returns Integer Type 
—I Warnings: None 

FUNCTION Get_Lat_Sign(Lat: Latitude) RETURN Character; 


-SET and GET LONGITUDE PROCEDURE and FUNCTIONS****************** 

—I Procedure: Set_Longitude 

—I Input: Degree, Minutes, Seconds : Integers; Longitude 
—I Output: Longitude 

—I Description: Sets Degrees, Minutes, and Seconds into Longitude Type 
—I Warnings: None 

PROCEDURE Set_Longitude(D : IN Integer; M : IN Integer; S : IN Integer; 


132 





Sign : IN Character; Lon: IN OUT Longitude); 


—I Procedure: Set Long Deg 
—I Input: Degree: Integer; Longitude 
—I Output: Longitude 

—I Description: Sets Degrees into Longitude Type 
—I Warnings: None 

PROCEDURE Set_Eong_Deg(D : IN Integer; Eon : IN OUT Eongitude); 

—I Procedure: Set Long Min 
—I Input: Minutes: Integer; Eongitude 
—I Output: Eongitude 

—I Description: Sets Minutes into Eongitude Type 
—I Warnings: None 

PROCEDURE Set_Eong_Min(M : IN Integer; Eon : IN OUT Eongitude); 

—I Procedure: Set_Eong_Sec 
—I Input: Seconds: Integer; Eongitude 
—I Output: Eongitude 


133 





—I Description: Sets Seconds into Longitude Type 
—I Warnings: None 

PROCEDURE Set_Eong_Sec(S : IN Integer; Eon : IN OUT Eongitude); 

—I Procedure: Set Eong Sign 
—I Input: Sign: Character; Longitude 
—I Output: Longitude 

—I Description: Sets Sign into Longitude Type 
—I Warnings: None 

PROCEDURE Set_Eong_Sign(Sign : IN Character; Eon : IN OUT Eongitude); 

—I Eunction: Get Eongitude 
—I Input: Eongitude 
—I Output: Eongitude 
—I Description: Returns a Eongitude Type 
—I Warnings: None 

EUNCTION Get_Longitude(Eon : Eongitude) RETURN Eongitude; 


134 





—I Function: Get Long Deg 
—I Input: Longitude 
—I Output: Integer(Degree) 

—I Description: Returns a Integer Type 
—I Warnings: None 

FUNCTION Get_Long_Deg(Lon : Longitude) RETURN Integer; 

—I Function: Get_Long_Min 
—I Input: Longitude 
—I Output: Integer(Minute) 

—I Description: Returns a Integer Type 
—I Warnings: None 

FUNCTION Get_Long_Min(Lon : Longitude) RETURN Integer; 

—I Funetion: Get Eong See 
—I Input: Eongitude 
—I Output: Integer(Second) 

—I Description: Returns a Integer Type 
—I Warnings: None 


135 






FUNCTION Get_Long_Sec(Lon : Longitude) RETURN Integer; 


—I Funetion: Get_Long_Sign 
—I Input: Longitude 
—I Output: Character(Sign) 

—I Description: Returns a Character Type 
—I Warnings: None 

FUNCTION Get_Long_Sign(Lon : Longitude) RETURN Character; 


PRIVATE 

TYPE Latitude IS RECORD 
latd : Lat Degree := 0; 
latm : Min utes := 0; 
lats : Sec onds := 0; 
AngleSign: Character := 'N'; 
END RECORD; 

TYPE Longitude IS RECORD 


136 




longd : Long Degree := 0; 
longm : Min_utes := 0; 
longs : Sec onds := 0; 
AngleSign : Character := 'W; 
END RECORD; 


END lat_long; 

A-12 UTILITIES.ADS 

—I EIEE: Utilities.ads 

—I AUTHOR; Kenneth E. Ehresman and Joey E. Erantzen, NPGS 
-I EAST MODIFIED; II September 2001 

-I OPERATING ENVIRONMENT; Windows 2000(Designed to be 0/S Independent) 
-I COMPIEER; GNAT 3.13p 

—I DESCRIPTION; This class is contains all of the data types and 
—I functionality for generic general purpose procedures and functions 
—I for the navigator program. 

— I INPUTS; Based on specific function or procedure. 

— I OUTPUTS; Outputs based on what Functions are requested and run. 

— I Process; None to note 
—I Assumptions; N/A 


137 




—I Warnings: None 

WITH Realnum; 

WITH Ada.Strings; USE Ada.Strings; 

WITH Ada.Numerics.Generic_Elementary_Functions; 

WITH Ada.Numerics; USE Ada.Numerics; 


PACKAGE Utilities IS 


TYPE My Degree IS RANGE 0 .. 359; 

—Defines range of traek numbers allowed, 1100..2101 for total of 1000 
—The last slot is never used unless it is an overflow error 

EAST TRACK SEOT : CONSTANT INTEGER := 2101; 

BEGIN TRACK SEOT : CONSTANT INTEGER := 1100; 

SUBTYPE Track Number Range IS Integer RANGE 1100..EAST_TRACK_SEOT; 

EUNCTION Validate_Time( T ime : IN Realnum.Real) RETURN integer; 


138 



FUNCTION Get_Default_String RETURN String; 

PROCEDURE Convert_String_To_Real(Temp_String ; String; 

Temp_Number ; IN OUT Realnum.Real; 
Okay : IN OUT Boolean ); 

FUNCTION Convert_To_Degree_String( Degree Number : My Degree ) 
RETURN String; 

FUNCTION Convert_To_Hours_String( Hours : Integer ) RETURN String; 

FUNCTION Convert_Track_Number_To_String( New Track Number : Integer ) 
RETURN String; 

FUNCTION Convert_Integer_To_String( New_Number : Integer ) 

RETURN String; 

FUNCTION Caleulate Seale ( Hit Range ; Realnum.Real ) RETURN Integer; 


END Utilities; 


139 



A-13 MOBOARD.ADS 


—I FILE: moboard.ads 

—I AUTHOR: Kenneth L. Ehresman, Naval Post Graduate Sehool 
-I EAST MODIEIED: 1 October 2001 

-I OPERATING ENVIRONMENT: EINUX & Windows 2000(Designed to be 0/S 
Independent) 

-I COMPIEER: GNAT 3.13p 

—I DESCRIPTION: This class draws a moboard, and provides functionality for drawing 
lines, 

—I plotting contacts, and refreshing the moboard. It is used by other classes 

—I Eike CPA, Wind, etc that rely on the digitally-drawn moboard. 

— I INPUTS: Eunction Specific 
-I OUTPUTS: None 
— I Process: None to note 
— I Assumptions: N/A 
—I Warnings: None 


WITH Ada; 
WITH Gtk; 
WITH Glib; 


USE Ada; 
USE Gtk; 
USE Glib; 


WITH Gdk.Color; 


140 



WITH Gdk.Drawable; 


USE Gdk.Drawable; 


WITH Gdk.Gc; USE Gdk.Gc; 

WITH Gdk.Pixmap; 

WITH Gtk.Drawing Area; 

WITH Ada.Numerics; USE Ada.Numerics; 

WITH Ada.Numerics.Elementary_Eunctions; USE 

Ada.Numerics.ElementaryEunctions; 

WITH Degrees; 

WITH Eat Eong; 

WITH Realnum; USE Realnum; 

WITH Sketchpad; 

WITH Tracks; 

WITH Utilities; 


PACKAGE Moboard IS 


Eunction: Get Current Contact Num 
Input: None 

Output: Returns the active contact Number 


I4I 



—I Preconditions: None 
—I Description: See output 
—I Side Effects: None 

FUNCTION Get_Current_Contact_Num RETURN Integer; 


—I Function: Get Current Contact Bearing 
—I Input: None 

—I Output: Returns the active contact number's current bearing 
—I Preconditions: None 
—I Description: See output 
—I Side Effects: None 

FUNCTION Get_Current_Contact_Bearing RETURN Realnum.Real; 


I Function: Get_Current_Contact_Range 
I Input: None 

I Output: Returns the active contact number's current range in yards 


142 




—I Preconditions: None 
—I Description: See output 
—I Side Effects: None 

FUNCTION Get_Current_Contact_Range RETURN Realnum.Real; 


—I Function: Get Current Color 
—I Input: None 

—I Output: Returns the Moboard's current forground drawing color 
—I Preconditions: None 
—I Description: See output 
—I Side Effects: None 

FUNCTION Get Current Color RETURN Gdk.Color.Gdk Color; 


I Function: Get Black Color 
I Input: None 


143 




—I Output: Returns the Moboard's ereated eolor blaek 
—I Preeonditions: None 
—I Description: See output 
—I Side Effects: None 

FUNCTION Get Black Color RETURN Gdk.Color.Gdk Color; 


—I Function: Get Red Color 
—I Input: None 

—I Output: Returns the Moboard's created color red 
—I Preconditions: None 
—I Description: See output 
—I Side Effects: None 

FUNCTION Get Red Color RETURN Gdk.Color.Gdk Color; 




144 




—I Function: Get_Own_Ship_Course 
—I Input: None 

—I Output: Returns own ship eourse in true degrees as drawn in the moboard center via a 
speed veetor 

—I Preeonditions: None 

—I Deseription: See output 

—I Side Effeets: None 


FUNCTION Get_Own_Ship_Course RETURN Utilities.My Degree; 


—I Function: Get_Own_Ship_Speed 
—I Input: None 

—I Output: Returns own ship speed in knots as drawn in the moboard eenter via a speed 
vector 

—I Preconditions: None 
—I Deseription: See output 
—I Side Effeets: None 

FUNCTION Get_Own_Ship_Speed RETURN Realnum.Real; 


145 



—I Function; Get_Ship_XPos 
—I Input: None 

—I Output: Returns own ship x-pixel eoordinate for the drawn speed veetor, ealled in 
CPA.FinishSpeedTriangle 

—I Preeonditions: None 

—I Deseription: See output 

—I Side Effeets: None 


FUNCTION Get Ship XPos RETURN Gint; 


—I Eunetion; Get_Ship_YPos 
—I Input: None 

—I Output: Returns own ship y-pixel eoordinate for the drawn speed veetor, ealled in 
CPA.EinishSpeedTriangle 

—I Preeonditions: None 

—I Deseription: See output 

—I Side Effeets: None 


EUNCTION Get Ship YPos RETURN Gint; 


146 



—I Procedure; Set Contaet XPos 

—I Input: New XPos - X-pixel position of the contact, used for calculating contacts 
course & speed in CPA.Finish_Speed_Trinagle 

—I Output: None 

—I Preconditions: None 

—I Deseription: See input 

—I Side Effects: None 


PROCEDURE Set_Contact_XPos( New XPos : Gint); 


—I Proeedure: Set_Contact_YPos 

—I Input: New_YPos - Y-pixel position of the contact, used for calculating contacts 
course & speed in CPA.Pinish_Speed_Trinagle 

—I Output: None 

—I Preeonditions: None 

—I Deseription: See input 

—I Side Effeets: None 

PROCEDURE Set_Contact_YPos( New_YPos : Gint); 


147 





—I Procedure: Set Current Color 

—I Input: New Color - the new foreground drawing eolor 
—I Output: None 
—I Preeonditions: None 

—I Deseription: sets the new foreground drawing eolor 
—I Side Effects: None 

PROCEDURE Set_Current_Color( New Color : Gdk.Color.Gdk Color ); 


—I Proeedure: Set_Current_Contaot_Bearing 

—I Input: Temp Bearing - the current bearing of the aetive eontact, used in CPA 
—I Output: None 
—I Preconditions: None 

—I Deseription: sets the current eontaet bearing 
—I Side Effeets: None 

PROCEDURE Set_Current_Contaet_Bearing( Temp Bearing : Realnum.Real ); 


148 







—I Procedure: Set_Current_Contact_Range 

—I Input: Temp_Range - the current range of the aetive contaet, used in CPA 
—I Output: None 
—I Preconditions: None 
—I Deseription: sets the current contact range 
—I Side Effects: None 

PROCEDURE Set_Current_Contact_Range( Temp Range : Realnum.Real ); 


—I Procedure: Set_Current_Contact_Num 
—I Input: Temp Num - the new eontact number to be proeessed 
—I Output: None 
—I Preconditions: None 

—I Description: sets the contact number to be proeessed 
—I Side Effects: None 


149 





PROCEDURE Set_Current_Contact_Num( Temp Num ; Integer ); 


—I Proeedure: Set_Own_Ship_Course 
—I Input: New_Course - the new eourse 
—I Output: None 
—I Preeonditions: None 
—I Deseription: sets the new own ship eourse 
—I Side Effeets: None 

PROCEDURE Set_Own_Ship_Course( New Course : Utilities.My_Degree ); 


I Proeedure: Set_Own_Ship_Speed 
I Input: New_Speed- the new speed 
I Output: None 
I Preeonditions: None 


150 




—I Description: sets the new own ship speed 
—I Side Effects: None 

PROCEDURE Set_Own_Ship_Speed( New Speed : Realnum.Real); 


—I Procedure: Draw_A_Eine 

—I Input 1 : Xl Pos - The x-pixel coordinate of the first pixel 
—I Input 2 : Yl Pos - The y-pixel coordinate of the first pixel 
—I Input 3 : X2_Pos - The x-pixel coordinate of the second pixel 
—I Input 4 : Y2_Pos - The y-pixel coordinate of the second pixel 

—I Output: A line from one cartesian coordinate to another drawn in the current drawing 
color 

—I Preconditions: None 

—I Description: This procedure draws a line from one pixel to another 
—I Side Effects: None 
—I Assumptions: None 

PROCEDURE Draw_A_Eine( Xl Pos : Gint; Yl Pos : Gint; X2_Pos : Gint; Y2_Pos : 
Gint); 


151 



—I Procedure; Calculate_X_Y_Pixels 
—I Input 1 : Input Bearing - the true bearing of a contaet 
—I Input 2 : Input Range - the range of the contact in yards 
—I Input 3 : Return_XPos - the caleulated x-pixel position 
Input 4 ; Retum YPos - the caleulated y-pixel position 

—I Input 5 : The Scale - the display seale used for ensuring the hit plots to the sereen 
—I Output: See description 
—I Preconditions: None 

—I Description: Calculates, displays and returns the X and Y Pixel corrdinates of 

aeontaet given 

the bearing and range and scale 
—I Side Effeets: None 
—I Assumptions: None 

PROCEDURE Calculate_X_Y_Pixels( Input Bearing ; Realnum.Real; Input Range : 
Realnum.Real; 

Return XPos ; IN OUT Gint; Return YPos ; IN OUT Gint; 

The_Scale : Integer); 


152 



—I Procedure: Calculate Slope Of Line 
—I Input 1 : Ml_XPos - The X Pixel Position of First Hit 
—I Input 2 : M2_XPos - The X Pixel Position of Second Hit 
—I Input 3 : Ml_YPos - The Y_Pixel Position of First Hit 
—I Input 4 : M2_YPos - The Y_Pixel Position of Second Hit 
—I Input 5 : X Fact - The delta of the two X_Positions in Pixels 
—I Input 6 : Y Fact - The delta of the two Y Positions in Pixels 
—I Input 7 : Slope - The ratio of Y Faet / X Fact 
—I Output: See description 
—I Preconditions: None 

—I Description: This procedure calculates the slope of a line, as well as the deltas of the 
—I X and Y Positions. Note Paramters 5, 6, and 7 are caleulated and returned. 

—I Side Effects: None 
—I Assumptions: None 


PROCEDURE Calculate_Slope_Of_Eine( Ml XPos : Gint; M2_XPos : Gint; Ml YPos 
: Gint; M2_YPos : Gint; 

XEact: IN OUT Realnum.Real; YEact : IN OUT 

Realnum.Real; 


Slope : IN OUT Realnum.Real ); 




153 




—I Function: Find_Distance 

—I Input 1 : M1_X - the x-pixel position of the first point 
—I Input 2 : M2_X - the y-pixel position of the second point 
—I Input 3 : MI_Y - the y-pixel position of the first point 
—I Input 4 : M2_Y - the y-pixel position of the second point 
—I Output: See description 

—I Preconditions: Two valid points must be passed in 
—I Description: Calculates the distance between tow point in pixels 
—I Side Effects: None 
—I Assumptions: None 

FUNCTION Find_Distance( MI X: Realnum.Real; M2_X: Realnum.Real; M1_Y 
Realnum.Real; M2_Y: Realnum.Real) RETURN Realnum.Real; 


I Eunction: Eind_DRM 
I Input 1 : Ratio - the slope of a line 
I Input 2 : Xfact - the delta of two X Positions (Pixels) 
I Input 3 : Yfact - the delta of two Y Positions (Pixels) 


154 




—I Input 4 : Print_It - used to determine whether or not to graphieally print out the CPA 
—I Output: See description 
—I Preconditions: None 

—I Description: Takes the slope of a line as input and returns the Direction of Relative 

Motion 

—I Side Effects: None 
—I Assumptions: None 

FUNCTION Find_DRM( Ratio : Realnum.Real; Xfact: Integer; Yfact : Integer; Print it: 
Boolean) RETURN Utilities.My Degree; 


—I Procedure: Update_Course_Speed 
—I Input 1 : Course Str - a non-empty string 
—I Input 2 : Speed Str - a non-empty string 
—I Output: See description 
—I Preconditions: None 

—I Description: Converts the inputted srings, checks their validity, and then update both 
the Ownship Course and Speed Clist 

—I as well as the database 

—I Side Effects: None 

—I Assumptions: None 

PROCEDURE Update_Course_Speed( Course Str : String; Speed Str : String ); 


155 





PROCEDURE Draw Moboard (New Area : Sketchpad. Gtk Sketchpad ); 


PROCEDURE Init( D Width; Gint; D Height: Gint; X Orig ; Gint; Y Orig ; Gint; 

GreenGc : Gdk GC; BlueGc : Gdk GC; Dashed GreenGc : Gdk GC; 

RedGC : Gdk GC; New Area : Sketchpad.Gtk Sketchpad; 

Red Color : Gdk.Color.Gdk Color; Black Color : Gdk.Color.Gdk Color ); 


PROCEDURE Replenish Screen; 


PROCEDURE Draw All Contacts; 


— This procedure draws an arrow at the end of a vector 

— Argument 1; Vector Direction - is the direction the line is going 

— Argument 2: X Position - is the screen X_Position to center around 


156 



— Arguemnt 3: Y Position - is the screen Y Position to center around 

PROCEDURE Draw_An_Arrow( Vector Direction : Realnum.Real; X Position : Gint; 
Y Position: Gint); 


PROCEDURE Update_Contact( ContactNum : String; ContactID: String; 
Contact_Bearing : String; 

Contact Range : String; New_Contact: Boolean ); 

PROCEDURE Plot_A_Point( PlotBearing : Realnum.Real; PlotRange ; 
Realnum.Real; Scale : Integer ); 


— This procedure saves the own ship Longitude 

— Argument 1: valid longitude degrees 

— Argument 2: valid longitude minutes 

— Argument 3: valid longitude seconds 

— Argument 4: valide llongitude hemisphere 

PROCEDURE Update_Longitude( LongDegrees : LatLong.LongDegree; 
Long Minutes : Lat Long.Min utes; 


157 



Long Seconds : Lat Long.Sec onds; Long Hemisphere : 


String ); 




— This procedure saves the own ship Latitude 

— Argument 1: valid latitude degrees 

— Argument 2: valid latitude minutes 

— Argument 3: valid latitude seeonds 

— Argument 4: valide latitude hemisphere 


PROCEDURE Update_The_Eatitude( 
Eat Minutes : Eat Eong.Min utes; 

EatSeeonds 

String ); 


EatDegrees : EatEong.EongDegree; 


: Eat Eong.See onds; Eat Hemisphere : 




PRIVATE 


Current_Contaet_Num ; Integer; 


CurrentContaetBearing, 


158 



CurrentC ontactRange, 

Moboard Radius : Realnum.Real; 

Black, 

CurrentColor, 

Red : Gdk.Color.Gdk Color; 

Ratio Array : ARRAY(0..2, Utilities.My_Degree) OF Realnum.Real; 


NUMBER O CIRCLES : CONSTANT Integer := 11; 

One Degree : Realnum.Real := Pi /180.0; 

Own Ship Course : Utilities.My Degree := 0; 

Own Ship Speed : Realnum.Real := 0.0; 

Set Up Distanee : Realnum.Real := 100 000.0; 

Current Area : Sketchpad.Gtk_Sketehpad; 

Contaet_XPos, 

ContaetYPos, 

Ship_XPos, 

ShipYPos, 

Draw_Widtli, 


159 



DrawHeight, 

XOrigin, 

Y Origin : Gint; 


DashedGreenGC, 

GreenGC, 

BlueGc, 

Red Gc :Gdk_GC; 

—I Procedure: Initialize Ratio Array 
—I Input: None 
—I Output: None 
—I Preconditions: None 

—I Deseription: This procedure ealeulates the ratio of Y over X for determining a unique 
slope and value for every degree 

—I from 0 to 359 degrees. The values are stored in Ratio Array for use in 

determining whieh degree the slope of 

—I a line represents. 

—I Side Effects: Ratio Array values are set and caleulated using a range of 100000 yards 
in order to make them distinctly 

—I unique. 

PROCEDURE Initialize Ratio Array; 


160 





—I Procedure: Plot Course Vector 

—I Input 1 : Ship Course - A Realnum.Real number representing Own Ships Course in 
degrees 

—I Input 2 : Ship Speed - A Realnum.Real number representing Own Ships Speed in 
knots 

—I Output: See description 
—I Preconditions: None 

—I Deseription: Draws the course and speed vector for the ship 
—I Side Effects: None 
—I Assumptions: None 

PROCEDURE Plot_Course_Vector( Ship Course : Realnum.Real; Ship Speed : 
Realnum.Real); 


END Moboard; 

A-14 CPA.ADS 

-I EIEE: CPA.ads 


161 



AUTHOR: Kenneth L. Ehresman, Naval Post Graduate Sehool 


-I LAST MODIFIED: I Oetober 2001 


-I OPERATING ENVIRONMENT: LINUX & Windows 2000(Designed to be 0/S 


Independent) 


-I COMPILER: GNAT 3.13p 

— I DESCRIPTION: This elass ealeulates a eontaet's CPA whieh ineludes: 
—I CPA Time, Bearing, Range, 

—I Contaet Course, Speed and Target Angle 

—I INPUTS: Funetion Specifie 
-I OUTPUTS: None 
—I Proeess: None to note 
—I Assumptions: N/A 
—I Warnings: None 


WITH Ada; 

WITH Gtk; 

WITH Glib; 

WITH Gdk.Color; 
WITH Gdk.Drawable; 


USE Ada; 

USE Gtk; 

USE Glib; 

USE Gdk.Drawable; 
USE Gdk.Ge; 


WITH Gdk.Ge; 
WITH Gdk.Pixmap; 


162 




WITH Gtk.Drawing Area; 


WITH Ada.Numerics; USE Ada.Numerics; 

WITH Ada.Numerics.Elementary_Functions;USE Ada.Numerics.Elementary Eunctions; 


WITH Degrees; 

WITH Realnum; USE Realnum; 
WITH Sketchpad; 

WITH Times; 

WITH Tracks; 

WITH Utilities; 


PACKAGE cpa IS 

—I Eunction: Get Alert Distance 
—I Input: None 

—I Output: Returns the user-defined CPA alert distance 
—I Preconditions: None 
—I Description: See output 
—I Side Effects: None 


163 




FUNCTION Get_Alert_Distance RETURN Realnum.Real; 

—I Procedure; Set_Alert_Distance 

—I Input: A real number, representing the new user-defined CPA alert distanee 
—I Output: None 
—I Preconditions: None 

—I Deseription: Sets the CPA Alert Destance to a new distance seleeted from a 
ComboBox by the user 

—I Side Effects: None 


PROCEDURE Set_Alert_Distance( New Distance : Realnum.Real ); 


—I Procedure: Calculate_CPA 

—I Input 1 : Track_Num - The track number of the eontact whose CPA is to be calculated 

—I Output: The seleeted contaets graphieally generated CPA, as well as an update to the 
screen of the CPA details in 

—I the Contact CPA Clist 

—I Preconditions: The track number must have two Radar hits. 

—I Deseription: This procedure uses the last two Radar hits of a eontaet, and graphieally 
draws the CPA. While drawing 

—I CPA the SRM and MRM are caleulated, the speed triangle is generated, and 

the contact's current eourse. 


164 



—I speed, and all CPA details are ealculated and displayed. Upon completion 

the boolean in the Sketchpad 

—I class which allows manual fairing of all bearings is set to true, thereby 

enabling the user's ability to 

—I recalculated the Course, Speed and CPA of the contact using faired bearings. 

—I The contacts last two radar hits are plotted and the Measure of Relative 

Motion (MRM) 

—I is calculated in yards. 

—I Next, the Direction of Relative Motion (DRM) is calculated and the slope of 

the inter- 

—I connected line between the two hits is determined. 

—I A line projection using the DRM is drawn to the edge of the outer-moboard 

ring, and the CPA 

—I is calculated by the closest part of this line to the Moboard's origin (center). 

—I The CPA Bearing, Time, and Range are then displayed, and the contact's 

course and speed 

—I are determined by calling the procedure "Finish Speed Triangle" 

—I Side Effects: The current contact's CPA, course and speed are saved into the Track 
Class. 

—I Sketchpad's Boolean allowing the fairing of bearings is set to True. 

—I Assumptions: None 

PROCEDURE Calculate_CPA( Track Num : Utilities.Track Number Range ); 


165 



—I Procedure: Initialize 

—I Input 1 : Current Area - The double-buffered drawing area maintained in the 
Sketehpad elass 

—I Input 2 : Current_X_Origin - The x-pixel position of the eenter of the drawing area 
—I Input 3 : Current_Y_Origin - The y-pixel position of the eenter of the drawing area 
—I Output: None 

—I Preeonditions: A eurrent drawing area in the Sketchpad class has been instantiated. 

—I Deseription: This proeedure is passed in the double-buffered drawing area 

maintained in the Sketehpad elass, as well 

—I as the X and Y pixel eoordinated of the eenter of the drawing area. 

—I This proeedure is ealled from within Moboard's Init proeedure 

—I Side Effeets: None 
—I Assumptions: None 

PROCEDURE Initialize( Current Area : Sketchpad.Gtk Sketehpad; Current X Origin : 
Gint; Current Y Origin : Gint); 


I Proeedure: Manually Pair Bearings 

I Input 1 : X_Pos - The x-pixel position ehosen by left clieking the mouse 


166 



—I Input 2 : Y Pos - The y-pixel position chosen with the mouse 
—I Output: Same as Calculate CPA 

—I Preconditions: A CPA for the currently selected contact must have been calculated. 
This will have set a boolean variable 

—I in sketchpad which allows the fairing of bearings. 

—I Description: This procedure is the same as calculate CPA except. It uses the original 
times of both the first and last RADAR 

—I hit and outputs a new CPA based on user Faired bearings. 

—I Side Effects: The current contact's CPA, course and speed are saved into the Track 
Class. 

—I Sketchpad's Boolean allowing the fairing of bearings is set to False. 

—I Assumptions: The SRM and MRM used are the average over the entire track's hit life 


PROCEDURE Manually_Fair_Bearings( X Pos : Gint; Y Pos : Gint ); 


—I Procedure: Initialize Faired Bearing Variables 

—I Input 1 : Track_Num - The track number of the contact ot Fair Bearings on 
—I Input 2 : Track Bearingl - The contact's first bearing to be faired in degrees 
—I Input 3 : Track Rangel - The contact's first range in yards 
—I Input 4 : Xl Pos - The x-pos pixel position of the first bearing 
—I Input 5 : Y I Pos - The y-pos pixel position of the first bearing 


167 




Input 6 : Scale - The eontaet's seale for plotting the points 
Input 7 : Traok_Bearing2 - The eontaet's seeond bearing to be faired in degrees 
Input 8 : Traek Rangel - The eontaet's seeond range in yards 
Input 9 : Xl Pos - The x-pos pixel position of the seeond bearing 
Input 10 ; Y I Pos - The y-pos pixel position of the seeond bearing 
Input 11 ; Timel - The time of the eontaet's first hit 
Input 12 : Time2 - The time of the eontaet's last hit 
Output: None 
Preeonditions: None 

Deseription: This proeedure initializes all the variables required to Fair a eontaet's 

bearings and 


—I ealeulated a new CPA 

—I Side Effeets: None 
—I Assumptions: None 


PROCEDURE Initialize_Eaired_Bearing_Variables( Traek Num : Integer; 

Traek Bearing 1 : Utilities.My Degree; 

Traek Rangel : Realnum.Real; Xl Pos : Gint; Yl Pos : Gint; 

Seale : Integer; Traek_Bearing2 : Utilities.My_Degree; 

Traek_Range2 : Realnum.Real; X2_Pos : Gint; Y2_Pos : Gint; Timel 
Times.Time Type; Time2 : Times.Time Type ); 


168 




PRIVATE 


SPEED SCALE : CONSTANT Realnum.Real := 5.0; 
NUMBER O CIRCEES : CONSTANT Integer := 11; 

One Degree : Realnum.Real := Pi /180.0; 

CPA Drawing Area : Sketehpad.Gtk Sketehpad; 

XOrigin, 

Y Origin ; Gint; 

CPA Alert Distanee ; Realnum.Real := 10000.0; 

— The following variables are for fairing the bearings. 
EairedPirstXPos, 

EairedPirstYPos, 

EairedSeeondXPos, 

Eaired Second YPos : Gint; 

EairedPirstBearing, 

Eaired Seeond Bearing : Utilities.My_Degree; 


169 



F airedF irst_Range, 

Faired Second Range : Realnum.Real; 


FairedScale, 

Faired Track Num ; Integer; 


FairedTimel, 

Faired_Time2 ; Times.Time Type; 


—I Proeedure: Caleulate SRM 

—I Input I : MRM - Measure of Relative Motion in yards 
—I Input 2 : MlTime - Time of First Hit 
—I Input 3 : M2_Time - Time of Seeond Hit 

—I Input 4 : First Hit Time - Time of First Hit converted to just Hours and minutes 
—I Input 5 : SRM - the Speed of Relative Motion in knots 

—I Input 6 : Valid - a boolean that indicates if the calculated SRM is valid and therefore 
usable 

—I Output: The SRM is calculated and returned, as well as the Boolean value Valid, 
which indicates if the SRM is usable 

—I Preconditions: Two RADAR hists must be available as well as the Measure of 
Relative motion. Each RADAR hit must have an 


170 



—I associated time, whieh ean not be identieal. Additionally, the ealeulated 

SRM must be > 0.0 knots to be valid. 

—I Deseription: This proeedure takes the measure of relative motion, measured in yards, 
and returns the Speed of Relative motion 

—I in knots. 


PROCEDURE Caloulate_SRM( MRM ; Realnum.Real; Ml Time ; Times.Time Type; 
M2_Time : Times.Time Type; 

EirstHitTime ; IN OUT Realnum.Real; SRM ; IN OUT 
Realnum.Real; Valid : IN OUT Boolean ); 


—I Proeedure: Einish Speed Triangle 

—I Input I : SRM - the speed of relative motion in knots 

—I Input 2 : DRM - the direetion of relative motion in Degrees 

—I Input 3 : Contact Number - the contact number of input contact 

—I Output: Graphically displayed as per Deseription. ( Contact's Course and Speed 

veetor as well as relative DRM ) 

—I Preeonditions: This proeedure is ealled by Caleulate_CPA; therefore, all of 
Caleulate CPA's post-eonditions must be met 

—I Deseription: This proeedure takes as input the speed of relative motion and direetion 
of relative motion, whieh are used 

—I for drawing the speed triangle, just like a regular moboard does. During 

proeedure instantiation, the 


171 



scale for the contaet number is retrieved from the Tracks class, as well as the 


X and Y pixel coordinates 

—I of own ship's speed veetor (via Moboard class). 

—I The contact's course and speed are graphieally drawn, then inferred from the 

drawing, and saved via the Traeks 

—I class. 

—I Side Effects: The Traek Num's calculated course and speed are updated. 


PROCEDURE Einish_Speed_Triangle( SRM : Realnum.Real; DRM 
Utihties.My_Degree; Track_Num : Utilities.Track_Number_Range ); 




END epa; 


A-15 MAINSCREEN-PKG.ADS 


WITH Gtk.Arguments; 


WITH Gtk.Widget; USE Gtk.Widget; 


WITH Gtk.Color Selection Dialog; USE Gtk.Color Selection Dialog; 


172 



WITH Gtk.Text; 


USE Gtk.Text; 


WITH Gtk.Window; USE Gtk.Window; 


WITH Gtk.Button; 


WITH Gtk.Menu Item; 


PACKAGE Main Screen Pkg.Callbacks IS 


Text I : Gtk Text; 


Show Course; Boolean := True; 


Color Done ; Boolean := Ealse; 

— The first three procedures must be instantiated, even though they will 
connected! 

PROCEDURE On_Cpal_Activate( Object : 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


never be 


ACCESS 


173 



PROCEDURE 


ACCESS 


On_Preferencesl_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Contactl_Activate( Object: 

Gtk.Menu Item.Gtk Menu Item Record'Class); 


PROCEDURE On_Show_Closest_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE Put_Eat_Eong_Into_Ownship_Eat_Eong_Clist; 


— Manually fair the bearing to recalculate the CPA 


PROCEDURE On_Manual_Eair_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


—The following will eventually be implemented 


ACCESS 


ACCESS 


ACCESS 


174 



PROCEDURE On_Show_Cpas_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Show_Eines_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Update_Contact_Info_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Coursel_Text_Changed( Object 
Gtk Text Record'Class); 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


175 



— the following proceures have been implemented 


PROCEDURE On_Drop_Contact_Aetivate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


— The next three are for creating a new contact, and responding to the submit and 
Cancel buttons 

PROCEDURE On_Create_New_Contact_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_New_Contact_Button_Clicked( Object : ACCESS 

Gtk.Button.GtkButtonRecord'Class); 


PROCEDURE On_New_Contact_ButtonCancel_Clicked( Object : ACCESS 
Gtk.Button.Gtk Button Record'Class ); 


— the next three are for inputting a new hit, and responding to its submit and Cancel 
buttons 


176 



ACCESS 


PROCEDURE On_Input_New_Contact_Hit_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Input_Hit_Button_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 

PROCEDURE On_Input_Hit_ButtonCancel_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


— The next three are for inputting own ships course and speed 

PROCEDURE On_Input_Course_Speed_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Course_Button_Clicked( Object 
Gtk.Button.GtkButtonRecord'Class); 


PROCEDURE On_Course_ButtonCancel_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


177 



—The next three are for inputting own ships lat and long 


PROCEDURE On_Input_Eat_Eong_Aotivate( Objeet 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Eat_Button_Clicked( Objeet 
Gtk.Button.Gtk Button Reeord'Class ); 


PROCEDURE On_Eat_ButtonCaneel_Clieked( Object 
Gtk.Button.GtkButtonRecord'Class); 


— The next few things are for inputting a contact's color 


PROCEDURE On_Color_Button_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


PROCEDURE On_Color_ButtonCancel_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


178 



PROCEDURE Put_Eat_Eong_Into_Track_Eat_Eong_Clist( Track Number 


PROCEDURE Change The Contacts Colors; 


— Process the wind options 


PROCEDURE On_Wind_Activate( Objeet 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_True_Wind_Activate( Objeet 
Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_Wind_Course_Activate( Object 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_Wind_Button_Clicked( Object 

Gtk.Button.GtkButtonRecord'Class); 


PROCEDURE On_Wind_ButtonCancel_Clicked( Object 

Gtk.Button.Gtk Button Record'Class ); 

—Process all contact purge times 

PROCEDURE On_Track_Purge_Time_Activate( Object 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


Integer ); 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


179 



PROCEDURE On_Purge_Button_Clicked( Object : ACCESS 

Gtk.Button.Gtk Button Record'Class ); 


PROCEDURE On_Purge_ButtonCancel_Clicked( Object : ACCESS 

Gtk.Button.GtkButtonRecord'Class); 


— This procedure checks the number of currently held contacts in the database, and 
deletes 

— any extraneous tracks that are being displayed in the contact clist. In other words, 

— it keeps the screen current with tracks that are dropped by the db due to age 


PROCEDURE Purge The Contact Clist; 

—Process the setting of the Minimum_CPA_Alert_Range 

PROCEDURE On_CPA_Alert_Range_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Alert_Button_Clicked( Object : ACCESS 

Gtk.Button.GtkButtonRecord'Class); 


PROCEDURE On_Alert_ButtonCancel_Clicked( Object : ACCESS 

Gtk.Button.GtkButtonRecord'Class); 


END Main_Screen_Pkg.Callbacks; 


180 



A-16MAINSCREEN-PKG-CALLBACKS.ADS 

WITH Gtk.Arguments; 

WITH Gtk.Widget; USE Gtk.Widget; 

WITH Gtk.Color Selection Dialog; USE Gtk.Color Selection Dialog; 
WITH Gtk.Text; USE Gtk.Text; 

WITH Gtk.Window; USE Gtk.Window; 

WITH Gtk.Button; 

WITH Gtk.Menu Item; 

PACKAGE Main Screen Pkg.Callbacks IS 

Text I : Gtk Text; 

Show Course: Boolean := True; 

Color Done : Boolean := Ealse; 


181 



— The first three proeedures must be instantiated, even though they will 
eonneeted! 

PROCEDURE On_Cpal_Aetivate( Objeet : 

Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE On_Prefereneesl_Aetivate( Objeet 
Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE On_Contactl_Activate( Objeet: 

Gtk.Menu Item.Gtk Menu Item Reeord'Class); 


PROCEDURE On_Show_Closest_Aetivate( Objeet 
Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE Put_Lat_Eong_Into_Ownship_Eat_Eong_Clist; 


never be 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


182 



— Manually fair the bearing to reealculate the CPA 


PROCEDURE On_Manual_Eair_Aetivate( Objeet 

Gtk.MenuItem.GtkMenuItemReeord'Class); 

—The following will eventually be implemented 

PROCEDURE On_Show_Cpas_Activate( Objeet 

Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE On_Show_Eines_Activate( Objeet 
Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE On_Update_Contaet_Info_Aetivate( Objeet 
Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE On_Coursel_Text_Changed( Object 
Gtk Text Record'Class); 


— the following proceures have been implemented 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


183 



PROCEDURE On_Drop_Contact_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


— The next three are for creating a new contact, and responding to the submit and 
Cancel buttons 

PROCEDURE On_Create_New_Contact_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_New_Contact_Button_Clicked( Object : ACCESS 

Gtk.Button.Gtk Button Record'Class ); 


PROCEDURE On_New_Contact_ButtonCancel_Clicked( Object : ACCESS 
Gtk.Button.GtkButtonRecord'Class); 


— the next three are for inputting a new hit, and responding to its submit and Cancel 
buttons 

PROCEDURE On_Input_New_Contact_Hit_Activate( Object : ACCESS 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


184 



PROCEDURE On_Input_Hit_Button_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


PROCEDURE On_Input_Hit_ButtonCancel_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


— The next three are for inputting own ships course and speed 

PROCEDURE On_Input_Course_Speed_Activate( Object 
Gtk.MenuItem.GtkMenuItemRecord'Class); 


PROCEDURE On_Course_Button_Clicked( Object 
Gtk.Button.GtkButtonRecord'Class); 


PROCEDURE On_Course_ButtonCancel_Clicked( Object 
Gtk.Button.Gtk Button Record'Class ); 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


185 



— The next three are for inputting own ships lat and long 


PROCEDURE On_Input_Eat_Eong_Aotivate( Objeet 
Gtk.MenuItem.GtkMenuItemReeord'Class); 


PROCEDURE On_Lat_Button_Clioked( Objeet 
Gtk.Button.GtkButtonReeord'Class); 


PROCEDURE On_Eat_ButtonCaneel_Clieked( Objeet 
Gtk.Button.Gtk Button Reeord'Class ); 


— The next few things are for inputting a eontacfs eolor 

PROCEDURE On_Color_Button_Clioked( Objeet 
Gtk.Button.GtkButtonReeord'Class); 


PROCEDURE On_Color_ButtonCancel_Clieked( Object 
Gtk.Button.GtkButtonRecord'Class); 


PROCEDURE Put_Eat_Eong_Into_Track_Eat_Eong_Clist( Track Number 


PROCEDURE Change The Contacts Colors; 
— Process the wind options 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


ACCESS 


Integer ); 


186 



PROCEDURE On_Wind_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_True_Wind_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_Wind_Course_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_Wind_Button_Clicked( Object : ACCESS 

Gtk.Button.Gtk Button Record'Class ); 

PROCEDURE On_Wind_ButtonCancel_Clicked( Object : ACCESS 

Gtk.Button.GtkButtonRecord'Class); 

—Process all contact purge times 

PROCEDURE On_Track_Purge_Time_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_Purge_Button_Clicked( Object : ACCESS 

Gtk.Button.Gtk Button Record'Class ); 

PROCEDURE On_Purge_ButtonCancel_Clicked( Object : ACCESS 

Gtk.Button.Gtk Button Record'Class ); 


187 



— This procedure checks the number of currently held contacts in the database, and 
deletes 

— any extraneous tracks that are being displayed in the eontact clist. In other words, 

— it keeps the sereen current with traeks that are dropped by the db due to age 
PROCEDURE Purge The Contact Clist; 


—Process the setting of the Minimum_CPA_Alert_Range 

PROCEDURE On_CPA_Alert_Range_Activate( Object : ACCESS 

Gtk.MenuItem.GtkMenuItemRecord'Class); 

PROCEDURE On_Alert_Button_Clicked( Object : ACCESS 

Gtk.Button.Gtk Button Record'Class ); 

PROCEDURE On_Alert_ButtonCancel_Clicked( Object : ACCESS 

Gtk.Button.GtkButtonRecord'Class); 


END Main Screen Pkg.Callbacks; 


A-17 SKETCHPAD.ADS 

WITH Glib; USE Glib; 


WITH Gdk.Color; 


WITH Gdk.Drawable; 


188 



WITH Gdk.Gc; 


WITH Gdk.Pixmap; 

WITH Gdk.Window; 

WITH Gtk.Drawing Area; 

PACKAGE Sketchpad IS 

DrawWidth, 

DrawHeight, 

XOrigin, 

Y Origin : Gint; 

type Gtk Sketchpad Record is new 

Gtk.Drawing_Area.Gtk_Drawing_Area_Record with private; 

type Gtk Sketchpad is access all Gtk Sketchpad Record'Class; 


189 



PROCEDURE Gtk_New( Drawing Widget: Out Gtk Sketchpad; Video Width ; Gint; 
Video Height: Gint); 


PROCEDURE Initialize( Drawing Widget : ACCESS Gtk Sketchpad Record'Class; 
Video Width ; Gint; Video Height: Gint); 


PROCEDURE Set_Allow_CPA( Enable CPA ; Boolean ); 

PROCEDURE Allow_Drawing_Eairhne( Allow Drawing : Boolean ); 

PROCEDURE Set_Anehor_Pixels( Xl Pos : Gint; Yl Pos : Gint ); 

EUNCTION Get Allow CPA RETURN Boolean; 

EUNCTION Get_Moboard_Pixmap( DrawingWidget : ACCESS 

Gtk Sketehpad Reeord'Class ) RETURN Gdk.Drawable.Gdk Drawable; 


PRIVATE 


TYPE Gtk Sketehpad Reeord IS NEW 


190 



Gtk.Drawing_Area.Gtk_Drawing_Area_Record 

WITH RECORD 


— The pixmap used for double buffering 


Pixmap ; Gdk.Pixmap.Gdk Pixmap := Gdk.Pixmap.Null Pixmap; 


END RECORD; 


Caleulate CPA : Boolean := Ealse; 
Permission ; Boolean := Ealse; 

E airedXPosAnehor, 

Eaired YPos Anehor ; Gint; 


END Sketehpad; 

A-18 WIND.ADS 

— Eilename: wind.ads 

— Author: Ken Ehresman 

— This file is for ealeulating true wind, and desired wind as well as plotting their 

— solutions onto a moboard. 


191 



WITH Ada; 

USE Ada; 

WITH Gtk; 

USE Gtk; 

WITH Glib; 

USE Glib; 


WITH Gdk.Color; 

WITH Gdk.Drawable; USE Gdk.Drawable; 

WITH Gdk.Gc; USE Gdk.Gc; 

WITH Gdk.Pixmap; 

WITH Gtk.Drawing Area; 

WITH Ada.Numerics; USE Ada.Numerics; 

WITH Ada.Numerics.ElementaryEunctions; USE 

Ada.Numerics.ElementaryEunctions; 

WITH Degrees; 

WITH Realnum; USE Realnum; 

WITH Sketchpad; 

WITH Tracks; 

WITH Utilities; 

PACKAGE Wind IS 

PROCEDURE Calculate True Wind; 


192 



— This procedure is ealled in order to initialize elass variables. It is ealled from within 
Moboard's Init proeedure 


PROCEDURE Initialize( Current Area : Sketehpad.Gtk Sketehpad; Current X Origin 
: Gint; Current Y Origin : Gint); 

— This proeedure is called in order ealculate the True Wind from measured wind 

— Argument 1: Measured Wind Direetion - Direetion from whieh wind was measured 
from 

— Argument 2: Measure_Wind_Speed - Speed or measured wind 

— Arguments: Measured_Wind_Type - Relative or Apparant wind 


PROCEDURE Caloulate_True_Wind( MeasuredWindDireetion : Integer; 
Measured_Wind_Speed : Integer; Relative Wind Type : Boolean ); 


PRIVATE 


Wind_Drawing_Area : Sketchpad.Gtk_Sketehpad; 
SPEED SCALE : CONSTANT Realnum.Real := 5.0; 
NUMBER O CIRCEES : CONSTANT Integer := II; 


193 



One Degree : Realnum.Real := Pi /180.0; 


XOrigin, 

Y Origin : Gint; 
END Wind; 


194 



LIST OF REFERENCES 


Riehle, Richard, T).,Ada and Object Technology, 1999. 

Feldman, M. B. and Koffman, E. B., Ada 95 Problem Solving and Program Design, 2"'^ Ed., Addison- 
Wesley Publishing Company, 1996. 

Cohen, Norman, FI., Ada as a second language, Ed., McGraw-Flill Companies, 1996. 

Schufeldt, FI.FI. USNR (Ret.) and Dunlap, G.D., Piloting and Dead Reckoning, 3"^“^ Ed., Naval Institute 
Press, 1991. 

Etter, Delores, M., Structured Fortran 77 for Engineers and Scientists, 5* Ed., Addison-Wesley Publishing 
Company, 1997. 

Bowditch, Nathanial., American Practical Navigator—An Epitome of Navigation, Volume 1, Defense 
Mapping Agency Hydrographic/Topographic Center, 1984. 

Clynch, J. R., Fortran Algorithm for GEODESIC GDSDIR and GDSINVfrom Geodesic Routines, 1999. 

Brobecker, J. and others, GtkAda Reference Manual, Version 1.2.10, Document Revision level 1.12, 2000. 

Ada Core Technologies, Inc., GNAT User Guide, GNAT for Windows NT, GNAT GNU Ada 95 Compiler, 
Document Revision Level 1.316, GNAT Version 3.13p, 2000. 

Ada Core Technologies, Inc. GNAT Referenc Manual, GNAT for Windows NT, GNAT GNU Ada 95 
Compiler, Document Revision Level 1.135,GNAT Version 3.13p, 2000. 

Brukardt, R, Ada 95 Reference Manual, Technical Corrigendum 1 (ISO/IEC 8652:1995/COR1:2000). 

Using the GNU Visual Debugger, Version 1.2.1 Document Revision level 1.55, 05/15/2001. 


195 



THIS PAGE INTENTIONALLY LEET BLANK 


196 



INITIAL DISTRIBUTION LIST 


1. Defense Teehnieal Information Center 
Ft. Belvoir, VA 22060-6218 

2. Dudley Knox Library 
Naval Postgraduate School 
Monterey, CA 93943-5101 

3. Dr. Luqi 

Naval Postgraduate School 
luqi@cs.nps.navv.mil 

4. Professor Richard Richie 
Naval Postgraduate School 
rdriehle@nps.naw.mil 

5. Professor Mantak Shing 
Naval Postgraduate School 
shing@nps.navv.mil 


197 





