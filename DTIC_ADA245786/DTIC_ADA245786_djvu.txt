NAVAL POSTGRADUATE SCHOOL 
Monterey, California 


AD-A245 786 





OTIC 



ELECTE 
FEB 121932 




THESIS 


THE DEVELOPMENT OF A DESIGN DATABASE 
FOR THE 

COMPUTER AIDED PROTOTYPING SYSTEM 

by 

Andrew Patrick Dwyer 
and 

Garry Wayne Lewis 
September, 1991 

Thesis Advisor: Dr. Luqi 


Approved for public release; distribution unlimited 








UNCLASSIFIED 

SECURITY CLASSIFICATION OF THIS PAGE 




REPORT DOCUMENTATION PAGE 


UNCLASSIFIED 





Approved for public release; 
distribution is unlimited 


6c. ADDRESS (City, Slate, and ZIP Code) 

Monterey, CA 93943-5000 


Naval Postgraduate School 


7b. ADDRESS (City, State, and ZIP Code) 

Monterey, CA 93943-5000 




ORGANIZATION 

National Science Foundation/NSWC 


8c. ADDRESS (City, State, andZtP Code) 

Washington, DC 20550 




(H applicable) 


CCR-9058453 





11. TITLE (Include Security Classification) 

THE DEVELOPMENT OF A DESIGN DATABASE FOR THE COMPUTER AIDED PROTOTYPING SYSTEM (U) 


wis, Garry W. 



iT>HI? 


14. DATE OF REPORT (Year, Month, Day) 

September, 1991 


FROM 09/90 TO 09/91 


The views expressed in this thesis are those of the authors and do not reflect the 
official policy or position of the Department of Defense or the United States Government. 


COSATI CODES 


GROUP 


SUB-GROUP 


18. SUBJECT TERMS (Continue on reverse it necessary and identity by block number) 

Design Database, Engineering Database, Object Orient^ Database. 
Computer Aided Prototyping System, 


19 ABSTRACT (Continue on reverse H necessary and identify bv block number) 

The Computer Aided Prototyping System (CAPS) was created to rapidly prototype real-time systems to determine 
early in the development cycle whether system requirements can be met. The CAPS consists of several software 
tools that automatically generate an executable Ada model of the proposed system. This thesis describes the devel¬ 
opment of a design database (DDB) for the CAPS. The DDB is an engineering database that contains all information 
related to a prototype software design. The DDB enhances the CAPS environment and the prototyping paradigm by 
providing to the designer the functions of storage, retrieval, viewing, and versioning of prototype components. 

Garry Lewis is the primary author of chapters I and II and Drew Dwyer the primary author of chapters HI and FV. 
In the joint implementation, Lewis focused on the design database schema and C++/ONTDS issues. Dwyer was re¬ 
sponsible for building the command line interface, the hierarchical k-ary data structures and the C++ classes/methods 
for traversing this structure. Items not covered in the above description were mutually developed. 






13 UNCLASSIFIED/UNLIMITED □ SAME AS RPT. Q DTIC USERS | UNCXASSIFIED 


22t)^IEL£PHQNE^^cluete Area Code) 


|:1I^I?U1WI»T1 


DD FORM 1473, 84 MAR 




83 APR edition may be used until exhausted 
All other editions are obsolete 



SECURITY CLASSIFICATION OF THIS PAGE 

UNCLASSIFIED 






































Approved for public release; distribution is unlimited 

THE DEVELOPMENT OF A 
DESIGN DATABASE 

FOR THE COMPUTER AIDED PROTOTYPING SYSTEM 

by 

Andrew Patrick Dwyer 
Captain, United States Marine Corps 
B.S., Juniata College, 1980 
M.B.A. Webster University, 1983 
and 

Garry Wayne Lewis 
Major, United States Marine Corps 
B.A. University of Virginia, 1974 
M.B.A. Golden Gate University, 1985 


Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF SCIENCE IN COMPUTER SCIENCE 

from the 


Authors: 


Approved By: 


NAVAL POSTGRADUATE SCHOOL 
September 1991 


/' /-i 



- ^ 



Garrywayne Lewis 


Luqi, Thesis Advisor 

_!S: 



Robert B. McGhee, Chairman, 
Department of Computer Science 


II 




ABSTRACT 


The Computer Aided Prototyping System (CAPS) was created to rapidly prototype 
real-time systems to determine early in the development cycle whether system 
requirements can be met. The CAPS consists of several software tools that automatically 
generate an executable Ada model of the proposed system. This thesis describes the 
development of a design database (DDB) for the CAPS. The DDB is an engineering 
database that contains all information related to a prototype software design. The DDB 
enhances the CAPS environment and the prototyping paradigm by providing to the 
designer the functions of storage, retrieval, viewing, and versioning of prototype 
components. 

Garry Lewis is the primary author of chapters 1 and II and Drew Dwyer the primary 
author of chapters III and IV. In the joint implementation, Lewis focused on the design 
database schema and C+- 1 -/ONTOS issues. Dwyer was responsible for building the 
command line interface, the hierarchical k-ary data structures and the C-(-t- classes/methods 
for traversing this structure. Items not covered in the above description were mutually 
developed. 


Accesion For 

NTIS CRV..I 
D r I ^ 1 8 

I' J:.. c.. .Cod 
J •. t'llCJlIOi'. 


i 

r.) 

Li 


By 









THESIS DISCLAIMER 


Trademarks 

Ada is a registered trademark of the United States Government, Ada Joint Program Office. 
Glockenspiel C++ is a trademark of Glockenspiel Ltd. 

ONTOS is a trademark of Ontologic, Inc. 

UNIX is a registered trademark of AT&T Bell Laboratories. 





TABLE OF CONTENTS 


I. INTRODUCTION.1 

A. SOFTWARE ENGINEERING.1 

B. THE COMPUTER AIDED PROTOTYPING SYSTEM (CAPS) ... 2 

C. PROBLEM STATEMENT.5 

D. OBJECTIVES.6 

E. ORGANIZATION.6 

II. BACKGROUND.7 

A. ENGINEERING DATABASE.7 

B. OBJECT-ORIENTED DATABASE MANGEMENT SYSTEMS ... 9 

1. Modelling Object Relationships.9 

2. Data Abstraction and Data Hiding.10 

3. Property/Operation Inheritance.10 

4. Method and Trigger Combination.10 

5. Generic Programming.11 

C. ONTOS OBJECT DATABASE.11 

III. REQUIREMENTS SPECIFICATION.14 

A. GOALS.14 

B. DDB INTERFACES.14 

1. Tool Interface.14 

2. End User Interface.16 

C. ENVIRONMENTAL MODEL.20 

1. Working Environment.20 

2. Version Structure.21 

D. BEHAVIORAL MODEL.23 

1. Design Constraints.24 






























2. Requirements.25 

IV. ARCHITECTURAL DESIGN.28 0 

A. GOALS.28 

B. DESIGN DATABASE.29 

1. Informal Solution.29 

2. Entities and Their Relationships.29 

3. Pre-defined ONTOS Classes.29 

a. Object.30 

b. List.31 

c. Dictionary.31 

4. Design Database Classes.31 

C. TESTING AND EVALUATION.47 

D. MAINTENANCE NOTES.47 

V. CONCLUSIONS AND RECOMMENDATIONS.48 

A. SUMMARY.48 

B. RECOMMENDATIONS FOR FUTURE WORK.48 ^ 

1. Variations.48 

2. Security. 49 

3. Evolution Management.49 

APPENDIX A ENVIRONMENTAL MODEL.50 

A. STATEMENT OF PURPOSE.50 

B. EVENT LIST.51 

C. CONTEXT DIAGRAM.52 

APPENDIX B COMMAND DO'ERFACE.53 

A. PROTOTYPE COMMANDS.53 

B. CONFIGURATION COMMANDS.54 

C. VERSIONED COMPONENT COMMANDS.56 


VI 


































APPENDIX C TESTING AND EVALUATION.59 

A. NOTES ON TESTING AND EVALUATION.59 

B. TEST SCRIPT.59 

C. TEST RESULTS.71 

APPENDIX D CODE.126 

A. PREPARATION NOTES.126 

B. PRINTING NOTES.126 

C. MAINTENANCE.126 

APPENDIX E SETUP FILES.348 

A. ONTOS HEADERS/MAKEFILES PREPARATION NOTES .... 348 

B. PRINTING NOTES.348 

C. MAINTENANCE.348 

LIST OF REFERENCES.356 

INITIAL DISTRIBUTION LIST.359 

















LIST OF FIGURES 


Figure 1. Piocess Model for Software/System.3 

Figure 2. Computer Aided Prototyping Environment.15 

Figure 3. DDE User Interface (Search for Component).17 

Figure 4. DDE User Interface (View PSDL Source).18 

Figure 5. DDE User Interface (Edit Prototype )).19 

Figure 6. DDE User Interface (Edit Prototype Panel).20 

Figure 7. Threaded Components.21 

Figure 8. CAPS Files in Versioned Component.22 

Figure 9. Basic DDB/CAPS Functions.24 

Figure 10. Tool/User Interface.25 

Figure 11. Design Database Data Flow Diagram.26 

Figure 12. Design Database Entity Relationship Diagram -High Level.30 

Figure 13. Design Database Entity Relationship Diagram - Low Level.31 

Figure 14. Design Database Descendants of Class Object 


33 

















ACKNOWLEDGMENTS 


Sincere thanks to the following contributors of this thesis effort: 

To our families: 

Words can not express the support, devotion, and patience we received from 
them. Many thanks for your prayers and encouragement; 

Professors Luqi and Valdis Berzins: 

For their excellent guidance and suppon; 

Professor Lawrence Williamson: 

For his many tireless hours, depth of knowledge, and devotion to the cause; 
Captain Patrick Barnes, USAF: 

For his overall knowledge of the CAPS system and his development of a user 
interface for the design database. 

Albert Wong and Rosalie Johnson: 

For outstanding technical support and encouragement; 

Suleyman Bayramoglu; 

For his extensive knowledge of Unix and various application programs, and his 
willingness to impart that knowledge to others. 





1. INTRODUCTION 


A. SOFTWARE ENGINEERING 

Each year billions of dollars are allocated for the development and maintenance of 
progressively more complex weapons and communications systems [Ref. l:p. 14], These 
systems increasingly rely on information processing using embedded computers systems. 
Satellite control systems, missile guidance systems and communication networks are 
examples of embedded systems. Correctness and reliability of these software systems is 
critical to the reliable operation of national defense systems. Moreover, software 
development of these systems is an immense task with increasingly higher costs and 
potential for misdevelopment. 

Studies conducted in the early 1970’s showed that computer software alone 
comprised approximately 46 percent of the estimated total DoD computer cost. Of this cost, 
56 percent was devoted specifically to embedded systems [Ref. l:p. 14]. In spite of the 
tremendous cost, there were examples of software systems produced that exceeded 
estimated development cost, fell behind the production schedule and were delivered not 
fully functional. 

Software engineering developed in response to the need to design, implement, test, 
install and maintain more efficiently and correctly larger and more complex software 
systems. Numerous methodologies have been introduced to support software engineering. 
The two major approaches which underlie these different methodologies are the phased 
refinement and prototyping method of development. 

The predominant model for current application development is the phased refinement 
approach. In this approach, all system functionality is specified in the first step of 
development, and subsequent implementation phases add prescribed design details. This 


1 





approach is criticized for its high cost of maintenance, failing to abstract tasks early in the 
development process, and for complications in system integration. Prototyping, as an 
evolutionary system development paradigm in which a number of nonstandard concepts 
work together, promises to achieve effective evolution of integrated hardware/software 
systems. 

Prototyping is the process of developing a scaled-down version of a system to use in 
building a full-scale system. Computer-aided rapid prototyping promises to provide a 
means for building a scaled-down version of a system more quickly than using 
conventional approaches. The final product of the prototyping activity is a working model 
that can be used for many purposes, such as requirement validation, feasibility study for a 
complex system, and functional specification of a system design. [Ref 2:p.9] Figure 1 
illustrates the role of prototyping in software development.. 

The process m.odel differs from the traditional phased approach in that it concentrates 
on the hard problem of system development, namely; requirement specification, and design 
rather than coding. Equally important, validation, evaluation, and hardware/software trade¬ 
off analysis are all part of the development process-tbey do not just follow completion of 
the development in each phase. Rapid prototyping works by providing continuous feedback 
information as rapidly and efficiently as possible. [Ref 2:p. 9] 

B. THE COMPUTER AIDED PROTOTYPING SYSTEM (CAPS) 

The evolution development of a software system design requires an integrated design 
support environment. A typical structure for a design environment that supports the rapid 
prototyping paradigm and the evolution process model is that provided by the CAPS[Ref 
4:p. 15]. 

CAPS is a rapid prototyping environment which includes the ability to prototype hard 
real-time systems. This approach to rapid prototyping uses a specification language called 





Figure 1. Process Model for Software/System [Ref. 3: p.7] 

Prototyping System Design Language (PSDL) and an integrated set of prototyping tools. 
The tools are integrated through the user interface. The primary tools in CAPS may be 
divided into three main systems [Ref. 4;p. 15]. The subsystem and their tools are: 

The User Interface which is composed of the following tools: 

• Graphic Editor 

• Syntax Directed Editor 

• Browser 

• Expert System 


The Software Base System which is composed of the following tools: 


3 









• Software Design Management System 

• Design Database 

• Software Base 

The Execution Support System which is composed of the following tools: 

• Translator 

• Static Scheduler 

• Dynamic Scheduler 

• Debugger 

The Graphic Editor is a tool which permits a designer to specify a portion of a PSDL 
prototype using graphical objects to represent the system. Graphical objects include 
operators, inputs, outputs, data flows, and self loops on operators. All graphic objects are 
named and may have time constraints associated with them. 

The Syntax Directed Editor is used by the designer to enter the text portions of the 
prototype design not represented by the graphic editor and to ensure that the prototype is 
syntactically correct PSDL. 

The Browser provides a means for die designer to view reusable components in the 
software base. 

The Expert System provides a paraphrasing capability that generates English text 
descriptions of PSDL specTication. This tool pemiits users who are unfamiliar with the 
PSDL language to evaluate a prototype. 

The Software Design Management System manages and retrieves the versions, 
refinements, and alternatives of the prototype in the Design Database and the reusable 
components in the software base. 

The Design Database contains PSDL prototype descriptions for all software projects 
developed using CAPS. 

The Software Base contains PSDL descriptions and implementations for all reusable 
software components developed using CAPS. (Ref. 5] 


4 






The Translator generates high level code from the PSDL prototype which binds the 
reusable components from the software base to the executable prototype. [Ref. 6] 

The Static Scheduler attempts to allocate time slots for the representation of PSDL 
operators with real-time constraints before the prototype is executed. If the allocation 
succeeds, all operations are guaranteed to meet their deadlines. [Ref. 7] 

The Dynamic Scheduler invokes representation of operators with real-time constraints 
at run-time to occupy time slots which are not used by operators with real-time constraints. 
The time slot which the dynamic scheduler uses are “slack times”. Dynamic scheduling 
occurs during execution of the prototype. [Ref. 7] 

The Debugger allows the designer to interact with the execution support system. The 
debugger has facilities for initiating the execution of a prototype, displaying execution 
results or tracing information of the execution and gathering statistics about a prototype’s 
behavior and performance. 

Prior to the work described in this thesis, implementations had been developed for the 
graphic editor, translator, static scheduler, and user interface. The design of a debugger has 
been defined. Feasibility studies had been conducted for the syntax directed editor, design 
database and the software base. 

C. PROBLEM STATEMENT 

Vast amounts of evolving data are created in the design of hard real-time systems. The 
data must be managed so that it can be stored and retrieved according to the needs of a team 
of design engineers. In CAPS, the Design Database (DDB) must manage the storage and 
retrieval of the PSDL program. The DDB must be a specialized DBMS which will store 
PSDL specifications in a hierarchical format and manage all support files associated with 
a software design project. [Ref 8:p. 5] 


5 




The DDB also provides concurrency control functions that allow multiple designers to 
update parts of the prototype without unintentional interference. In the interest of 
minimizing delay, the design database will not lock out read-only access to any part of the 
design, even while the design is being updated. Instead, the system will allow examination 
of the previous version of the component, with a warning that a new version is currently in 
preparation. On request, the system will provide information about the reason for 
modification of the component (such as a new or modified requirement). 

D. OBJECTIVES 

The objective of this thesis is to develop an object-oriented design database for the 
CAPS. The design database must be accompanied by a user interface that enables the 
designer to perform routine database tasks such as opening, closing, querying, storing, and 
retrieving operations. 

E. ORGANIZATION 

Chapter n contains a survey of the requirements for an engineering database with an 
emphasis on the object-oriented approach. An introduction to ONTOS, a state of the art 
object database will conclude Chapter II. Chapter III contains the design of the database 
objects. Chapter IV shows the design database implementation details using C++ and 
ONTOS. Conclusions and recommendations will be presented in Chapter V. 


6 







11. BACKGROUND 


A. ENGINEERING DATABASE 

An engineering database should provide the following facilities to support computer- 
aided software development environments: 

• Persistence 

• Concurrency control 

• Version control 

• Reuse of past design objects 

• Configuration control 

• A wide variety of data storage 

• Guarantees data will not be corrupted due to system or media failure 


A fundamental feature provided by a database is persistent storage. If objects are 
persistent, this means the objects in the database will exist after the process that created 
them has terminated. [Ref. 9:p.472] 

In a design environment, one usually has to keep data on several design alternatives, 
revisions, design stages, and so on. Hence information about the same semantic entity has 
to be recorded more than once. If versioning is implemented in the DBMS’s storage 
subsystem, then it can be done on fine granularity components. When creating a new 
version, only those components that have changed since the previous version need to be 
stored. In the new version, unchanged components can be represented by pointers to their 
previous versions. This is efficient in storage because only the changed components are 
repeated in the new versions. It is also efficient in execution time; since versions are not 
encoded they can be retrieved directly instead of being reconstructed using change logs, as 
in RCS and SCCS. [Ref. 10:p. 168] 

The goals of configuration management include recording the development history of 
evolving systems, and aiding the management of the systems in guiding and controlling 


7 






their evolution [Ref. 11 :p. 918]. A structure that captures the evolution of a design in terms 
of its hierarchical decomposition, alternative implementation and revision history, is 
crucial to the effective reuse of past design objects. 

The partitioning of the design task across levels of abstraction and between many 
design engineers requires the design database to support concurrent access and implement 
concurrency controls. The issue of concurrent access for a design is significantly different 
than for a conventional database application due to the different lengths of transactions that 
each must support. In a design environment, individual design objects may be “checked- 
out” for long periods of time [Ref. 12;p. 661. However, over the course of some transactions 
other designers may require “access” to a design object that is already checked-out. The 
concurrency control system must therefore support an object locking mechanism that 
remains in the database after the current process has ended and permits a designer to view 
objects already checked out to be operated on by another designer. 

The design database must store a variety of formatted, unformatted, and variable- 
length objects such as program text. In addition to program text, the design database must 
store management information and natural language descriptions for documentation/ 
historical purposes. One of the criticisms of relational DBMS is that they are inadequate for 
the data handling requirements of a support environment. 

Securing data stored in a design database is another concern [Ref. 13: p. 37]. Some 
type of mechanism must exist whereby access to objects in the database can be restricted. 
Protecting high-value data (a civilian company’s proprietary information, or sensitive 
military data) from compromise requires a system that is sophisticated enough to 
distinguish different user access privileges and appropriately grant or deny access to a 
particular object in the database. 

Finally the database must ensure that data will not be corrupted due to system or media 
failures. 


8 



B. OBJECT-ORIENTED DATABASE MANGEMENT SYSTEMS 


Object-oriented database management systems (OODBMSs) in particular offer 
several features that promote rapid prototyping. One of the major advantages of the object- 
oriented paradigm is increased modeling power. Objects and their relationships in 
OODBMSs can be aligned very closely to objects and their relationships in the real-world. 
On the other hand, conventional data modeling paradigms such as file formats or relational 
models require considerable effort to force real-world objects into fixed programming 
constructs. Thus, a semantic gap exist between the way information is stored and the way 
it is used. Relational databases, in particular, are inadequate for storing complex 
information structures such as those in the CAPS. [Ref. 14:p. 32] 

OODBMSs typically provide a set of predefined system types, such as set, queue, 
stack, list, and ordered dictionary. This simplifies the modeling effort as the designer can 
concentrate on the problem at hand and not clutter the solution with “data structure” 
specific procedures. 

1. Modelling Object Relationships. 

Using a limited set of constructs to model diverse concepts inevitably leads to loss 
of exact meaning. OODBMSs provide several mechanisms to model different relationships 
among objects. Object specialization/generalization refers to the ability to organize objects 
in an is-a-kind-of hierarchy. Classification is the ability to relate an object to a group of 
objects via the is-an-instance-of relationship. Aggregation allows the programmer to model 
an object as an aggregate of its constituent objects. This type of relationship is known as 
the is-a-part-of relationship. [Ref 14;p. 32] 


9 



2. Data Abstraction and Data Hiding. 

The advent of third-generation programming languages points out the need for a 
clear distinction between the storage structures associated with the data and the logical 
structure of the information. Data abstraction refers to the extreme case of this separation, 
where access to the storage structure may only be gained through a set of predefined 
operations. Data hiding insulates the programmer from the actual structure where data is 
stored. In CX)DBMSs, completely encapsulating an object with its data and operations 
forces the programmer to use the correct operations on all objects. In addition, a 
programmer need only know about the objects that his or her code uses. [Ref. 14:p. 33] 

3. Property/Operation Inheritance. 

Property/operation inheritance implies that an object type automatically has all 
the properties/operations of its parent type. This is one of the fundamental differences 
between OODBMSs and relational databases. [Ref. 14:p. 33] 

From the standpoint of rapid prototyping, operation inheritance is perhaps more 
valuable than property inheritance. A programmer does not need to reimplement the 
behavior that a type shares with its supertype. More importantly, this allows a programmer 
to assign default behavior to objects. In fact, once the subtype-supertype link is established 
in the is-a-kind-of hierarchy, a large amount of code automatically become available to the 
object, even before a single line of code specific to the new object type has been written. 
[Ref. 14;p. 33] 

4. Method and Trigger Combination. 

Method and trigger combination invokes writing several small modules of code 
and using them in different combinations to form methods for different types and situations. 
In conventional programming, this would involve many checks which would make the 
code inefficient. However, with OODBMSs, the automatic dispatching mechanisms (see 
the next section) allows programmers to combine modules by triggering them at the 


in 






appropriate places. Each object-specific operation module is designed to handle its 
additional set of properties and then invoke the corresponding module of its supertype. 

5. Generic Programming. 

In generic programming, programmers write code modules as general as possible 
so they can be used by different types of objects. Two essential features of the object 
paradigm-polymorphism and access to metainformation-help generic programming. 
Polymorphism is the ability to automatically dispatch a call to an appropriate routine 
according to the type of parameters passed. This feature makes code upward compatible 
and resilient to modifications [Ref 14:p. 34). Another characteristic of OODBMSs that 
makes a program resilient to the addition of new types is the accessibility of 
metainformation. The user- defined types are actually objects compiled into the database. 
They are therefore available to a program just like any other project. The advanced 
exception-handling capability of OODBMSs comes in handy in rapid prototyping. 
Typically, a large amount of code in an application’s final version deals with erroneous 
input data or other anomalous situations. Programmers would like to avoid such detailed 
error handling in early prototypes. If exceptions are also treated as objects, a programmer 
can initially write a simple exception handler for the most general type of exception. The 
programmer can then gradually refine this default exception handler as the prototype 
grows. 

C. ONTOS OBJECT DATABASE 

We used the ONTOS Object Database as the database engine for the design database. 
ONTOS, and its predecessor Vbase, are products of Ontologic, Inc. Vbase was used at the 
Naval Postgraduate School to test the feasibility of a design database after completion of a 
conceptual level design [Ref 8:p. 9]. 

We conclude this section with a description of the functionality provided by the 
ONTOS Object Database. 


11 







ONTOS supports the full object model. The database schema represents object 
classes, data members (properties) and member functions (operations). Any class definition 
which can be specified in C++ can be stored in ONTOS as an ONTOS Type. 

ONTOS supports both the single and multiple inheritance model of object oriented 
programming. TTie class model that is used in the C++ application is represented in the 
database as object schema. ONTOS schema information is stored directly in the database 
as object data. 

ONTOS provides three interfaces for use by the application programmer: a C++ 
interface, an Object SQL interface, and a programmatic schema manipulation facility. We 
are primarily concerned with the C++ interface. ONTOS provides an interface to C++ 
which is simple to use. It provides a transparent database interface which is generated by 
ONTOS utilities. 

ONTOS uses a standard client-server architecture. C++ client applications interact 
with a logical ONTOS database server. The ONTOS database server provides object 
storage, transactions, concurrency control and other database services. C++ client 
application make requests to the database server to access and store objects. When a client 
application requests an object, the system automatically translates the object into its C++ 
in-memory representation and places the object in the C++ client application’s in-memory 
process heap. 

ONTOS provides Aggregate classes including Set, List, Array, and Dictionary. Sets 
adds the functionality of mathematical sets to C++. Sets are unordered, unkeyed 
Aggregates with no duplicate members. Lists provide the abstraction of linked list; 
logically, members are stored serially, in a chain. Each position in the chain is numbered, 
starting at position zero. An Array is an Association of declared size whose keys are a 
continuous range of integers and whose members are Entities. Dictionaries are 


12 




Associations whose keys and members are Entities and whose size is unrestricted. 
Dictionaries may be ordered or unordered. 

ONTOS supports the standard, locked-based transaction model which is common to 
all major database systems. The transaction protocol supports transaction start, checkpoint, 
commit and abort. Checkpoint allows a transaction to commit the changes made up to 
checkpoint and then to continue with the transaction. ONTOS transactions also support 
transaction journaling. Journaling maintains a log of changes made to the database within 
a transaction, which can be used to provide roll-forward recovery after a server process 
failure. 

In addition to the standard transaction model, ONTOS supports high-concurrency and 
shared tran.sactions for workgroup applications, as well as nested transactions with 
transaction-based undo capabilities. 

Onto suppons locking at the level of object, aggregate and page. Object-level locking 
provides locks on individual objects, thus providing the highest possible concurrency. 
Aggregate -level locking allows any aggregate of objects to be locked as a group, to provide 
higher-granularity locking and concurrency control strategies. Page-level locking provides 
optimum locking performance for large groups of objects physically clustered on disk. 

The high level of abstraction provided by C+-t-, together with ONTOS’ complete 
support of the object model, matched against the requirements for a engineering database 
gave us complete confidence in our choice of tools for implementing a design database for 
CAPS. 


13 




ni. REQUIREMENTS SPECIFICATION 


Here we define and present a summary of the requirements specification for the DDE. 
This set of requirements was developed using the Berzins and Luqi model of Software 
Engineering. This model requires a problem statement, development of an 
environmental model and goals, and consideration of the constraints imposed on the 
system. (Ref. 9:p. 24] 

An additional methodology providing complimentary structure and style is Yourdon 
[Ref 15]. In this approach the designer develops an Environmental Model and a Behavioral 
Model. TTie environmental model details interactions between the DDB and the user. The 
users in our model are the tool interface of the CAPS system and the end user (designer). 
The tool interface responds to the needs and queries of the end user and other tools in the 
CAPS system. The behavioral model describes the internal mechanisms at work in the 
DDB system. 

A. GOALS 

The goals of the DDB are as follows: 

• Provide functionality which supports the needs of a prototype designer 
using the CAPS system. 

• Develop a system which encapsulates data and functions together 

• Provide flexibility for future development and change 

B. DDB INTERFACES 
1. Tool Interface 

The tool interface is the glue which binds the individual CAPS tools together. A 
picture containing the tool interface and its relationship to the other tools is provided in 
Figure 2. The tool interface interprets and reformulates requests sent from one tool to 


14 




Figure 2. Computer Aided Prototyping Environment [Ref. 3:p. 16] 


another - modifying the request to achieve the desired output. A typical sequence of 
requests is shown in Table 1 in informal language. 


15 







TABLE 1: TYPICAL TOOL INTERFACE INTERACTION 


Tool 

Converses with 

Operation 

Graphic Editor 

Tool Interface 

“1 want to view operator X” 

Tool Interface 

Design Database 

“Return operator X in Read Mode” 

Design Database 

Tool Interface 

“Operation Complete” 

Tool Interface 

Graphic Editor 

“Resume Operation” 


In the previous design of CAPS, if the designer had to communicate with a tool, 
that tool provided its own end user interface [Ref. 3:p. 21], However, the DDB responds to 
commands only from the tool interface. The user interface required to query the DDB and 
store, retrieve, or manipulate prototypes is important for extending the DDB’s services to 
the end user. A graphical user interface has been developed as a separate tool that interacts 
with the DDB via the tool interface. This end user interface extends to the user those 
functions defined in chapter IV of this thesis. The end user interface is discussed briefly in 
the next section. 

2. End User Interface 

Due to the scope of the DDB’s requirements, we need to separate the DDB’s 
functionality from the user interface functionality. For this reason the end user interface 
requirements of the DDB were removed and developed separately from the functions 
provided by the DDB. A graphical user interface developed at the Naval Postgraduate 
School allows the designer to take full advantage of the functions provided by the DDB 
[Ref. 14). The user interface runs under the control of the tool interface. An example of the 
screens which a user will see when he requests access to prototypes stored in the DDB is 
illustrated in Figures 3 through 6 . These figures illustrate the sequence of panels a designer 
will see/use when generating the following DDB commands; 

• List the names of the initial decomposition of prototype operators stored in 
the DDB and search for a component contained inside of the composite 


16 






















component “user_interface” 

View a component’s PSDL Source 
Select and Edit a prototype’s attributes 


File Edit View Select Quit 


Database: 

Prototype: 




c3i 


Operator 

Version 

m 

t • 



cowwis_ijnterface 

1 


co«ms_liiiks 

1 


navigatiQn_systew 

1 


sensor^ihterface 

1 


sensors 

1 


track_database_iiianatrRr 

1 


user_interface 1 

1 


reapons_iiiterfa:e 

1 


reapons_syste»s 

1 


Figure 3. DDB User Interface (Search for Component) 


The user moves the selection bar to the desired versioned component (Operator). After 
the operator (user_interface) is highlighted, double click on that component to see the 
decomposition of that operator. The resulting view of the decomp>osition of the 
user_interface operator is shown in Figure 4. 

After the PSDL operator message_editor is highlighted (single clicking on that 
operator) the designer selects the pull-down menu option File and moves the selection bar 


17 







File 

FYototype 
Qmriguratian 
Version 
Graphic PS 


Edit View Select 
|ddbS3 

|c3i. user iinterface ~ 


t'SDL Source 


Ada Source 

M_ 

Operator Subtree 


ton: isparc 


or 


Config Tree 


Quit 


Version 


PS 




displayLQxaphic^tracks 

1 


di^layitradcs 

1 


e»ergenc:y_status_screen 

1 


get_iiodificatian_data 

1 


get_user_iiiputs 

1 


intelligence_reportjpaaiel 

1 


nanage_user_interface 

1 


message_arrival 

1 


inessaige_arrival_painel 

1 


message editor ■ 

1 


resolutian_naticejpanel 

1 


status_screen 

1 


Figure 4. DDB User Interface (View PSDL Source) 


to PSDL Source. When that option is activated the user is able to view the contents of the 
PSDL Source for the message_editor (not shown). 

In Figure 5 the user highlights the prototype c3i and selt-cts edit prototype. The results 
of this action (Figure 6) present the user with an edit screen which allows him to edit 
various data fields of the prototype. The composition of prototypes and other classes 
implemented in the DDB will be explained in Chapter IV. 

This method of developing the user interface (DDB->tool interface->user interface) 
enhances modularity and provides flexibility to the overall CAPS system. Consequently, 


18 




















Figure 5. DDB User Interface (Edit Prototype )) 


whatever form the tool interface and other tools assume in the future, the functions of the 
DDB shall require little modification. Designing the DDB in this manner permits porting 
the CAPS system to different graphical user interfaces existing on a wide variety of system 
platforms. 

The above examples represent a small portion of the capabilities of this engineering 
database. These functions are further defined later in this thesis. Hereafter in this chapter 
the term “user” will be used generically to refer to the tool interface and/or prototype 
designer (end user). 


19 











Save Quit _ 

Prototype: c3i Date: Thu Sep 1216:00U)0 1991 
Leader: Iwariarme Aiello 


Description: 


rhis project deals with the cowmand and control 
functions in the Aegis Cruiser line. 

Expected completion date is December, 1992. 

Team Members assigned to develop this Prototype 

John 646-5123 

Henry 646-7815 

MaryAnne 646-0917 

P3 

d 0 

■ 


Figure 6. DDB User Interface (Edit Prototype Panel) 


C. ENVIRONMENTAL MODEL 

The DDB statement of purpose, event list, and context diagram are contained in 
Appendix A. A summary of the model is presented in the remainder of this chapter. 

1. Working Environment 

Prototypes are developed in a system work area for CAPS development specified 
by a case sensitive Unix environment variable (SPROTOTYPE) defined by the user . The 
value of this variable should be the path name of a unique Unix directory. The DDB reads 
this system variable to ascertain where to output prototype components. Components are 


20 














immutable snapshots of prototype development efforts. Components may be composite - in which 
case they contain other components, or they may be atomic - in which case they do not have a 
decomposition. Atomic components may be transformed to composite components in future 
decompositions. Once a prototype is stored into the DDB, the database copy may not be altered. 
To modify a prototype, a copy of the prototype must be checked out of the DDB and put into the 
user’s local area. The user then modifies the working copy. When this copy is significantly altered 
and certified as an updated version it is checked back into the DDB as a new version of the 
prototype. This process is called threading com{X)nents [Ref. 11]. 

2. Version Structure 

Each component represents a PSDL operator or type. Every component in the DDB has 
its own unique thread. This concept is illustrated in Figure 7. 


Versions of an Object 



Versions of a component are ordered by a thread. Each component in the database may 
reference several types of files generated by various CAPS tools. Figure 8 shows the potential set 
of files generated for a single component in the DDB. 

Inserting a component in a thread and storing it into the database can be modeled as 
creating a node in a multi-level acyclic graph. In the fully developed model, threads may split at 


21 





any point into variations [Ref 11]. In the current implementation, there is no provision for 
a segmented join of separate variations, although the groundwork has been laid in the 
design of object oriented structures which suppons a transition to the full model. 
Decomposing components is an essential requirement for modeling the problem domain. 
This decomposition produces a multi-level k-ary hierarchy that must be navigated 
effectively to view and modify any version object upon demand. For this reason “walking 
the graph” [Ref. 17] is essential. 

Three of the primary entities identified for the DDB - a prototype, a 
configuration, and a versioned component will be discussed in the next section. 

Taken as a whole, CAPS, PSDL, and the DDB provides the software developer 
the ability to store, retrieve, and manipulate an unlimited number of prototypes and 
components. Working jointly with the other tools in the CAPS system, the DDB provides 
a capability never before available in computer aided prototyping. This enables the 


22 








development of large, real time, or embedded application prototypes more quickly and 
efficiently. 

D. BEHAVIORAL MODEL 

Just as a motion picture is a collection of still pictures, a prototype is a collection of 
versioned components. Our ability to understand a movie is directly related to how well we 
can grasp the relationship and flow from one frame to the next. Taken together as a movie, 
these frames can convey something of power and beauty. Developing a software prototype 
is analogous to understanding a movie. With the right grasp of the tools available in 
computer aided prototyping, we can form truly productive prototypes. It is the relationship 
of one version to the next that conveys the direction of future development. As this 
transformation is captured and tools such as this DDB become fully mature, changes in one 
component that are dependent on another will be largely realized by automated 
transformations internal to the tool. These DDB consistency checks ensure that all 
components interact through their relationship in a database hierarchy. It is for this reason 
that cataloging and indexing individual CAPS components is essential. This is referred to 
as Evolution Management. [Ref 11] 

The basic prototype functions are illustrated in Figure 9. 

The DDB supports the viewing, storing, and retrieving of prototype components in a 
central design repository. Since prototypes are usually multi-level decomposed subtrees, 
the DDB provides a mechanism for viewing the complete hierarchy of a prototype 
components. The DDB stores components required by the other CAPS tools indefinitely. 
The DDB has no destructive capabilities on the attributes displayed in Figure 8. Once 
prototypes are px)Sted to the DDB they will never be removed - although a capability to 
migrate prototypes to archival storage such as tape is planned. The DDB supports the 
concept of configuration control on a desired slice of the entire prototype history. The DDB 
does not store repetitive copies of individual components which do net have different 
versions. 


23 





1. Design Constraints 

The DDB processes commands from the tool interface. The manner in which data 
is passed between the tool interface, the DDB, and the end user interface is illustrated in 
Figure 10. The tool interface controls the user interface. The DDB communicates indirectly 
with the end user through the user interface’s handling of output from the main function 
calls to the DDB. Since the functionality of the DDB is separated from the user, security is 
enhanced and there is less chance for error. 


24 







Tool 



UNIX 

Work 

Area 


Stderr 


User ^ 



Interface 


Figure 10. Tool/User Interface 


2. Requirements 

The user interface captures the standard output and displays it to the user in a window. The data flow 
diagram of the DDB is shown in Figure 11. The DDB first parses the command line to verify that the command 
contains a legal function tag and the appropriate number of arguments. A listing of the valid commands to the 
DDB is contained in Appendix B. After parsing the command, the DDB prepares the ONTOS DBMS for 
storage and/or retrieval by issuing specific ONTOS DBMS calls. Next the DDB reformulates the command 
and initiates the sequence of functions required to perform the transaction. At this point, the DDB will perform 
a query of persistent objects stored in the database or will create and input components designated to be 
checked into the database. The remaining step displays confirmation and/or displays the data to standard 
output (stdout). 

The end user can then choose to work with one of the other tools in the CAPS system for an indefinite 
period of time. When the designer/manager is ready to check a revision of the prototype back into the DDB 
he will provide the tool interface a prototype name and have the tool interface command the DDB to search 


25 





Figure 11. Design Database Data Flow 

the working directory defined by $PROTOTYPE to check modified or newly created 
components into the database as a new version of the prototype. 

The capabilities provided to the user will at a minimum contain the following high 
level operations: 

• Insert new prototypes into the DDB 

• View existing prototypes available in the DDB 

• View/Update prototype attributes 

• Insert new configurations into the DDB 

• View existing configurations available in the DDB 

• View/Update configuration attributes 

• Insert new components into the design DDB 

• View versioned components available in the DDB 

• Retrieve selected versions of components from the DDB 

• Prevent others from versioning components which are currently evolving 

• Update previous versions spawning alternate thread histories 

• View/Update component descriptions in the DDB 


In addition to the above capabilities, the DDB will allow the tool interface to: 

• Override component locking mechanisms 

• View component lock status 


26 









• View a worker which currently has a component locked 

• List decomposition of operator/type components and their descendants 

• Attach any component to a configuration 

• Navigate the hierarchy from any component directly or through a 
configuration. 

More generic database management capabilities are provided by the ONTOS 
object oriented database. These DBMS capabilities are considered vital to the successful 
implementation of any database management system. For further information pertaining to 
these and other ONTOS issues the reader is referred to Chapter II and the ONTOS (version 
2.01 beta) users’ manual. 




IV. ARCHITECTURAL DESIGN 


Much of the analysis and research in this area dictates an object oriented approach for 
classifying the schema and functions of a prototyping storage and retrieval system. To 
version components which carry information relating to specifications of a software 
prototype the DDE is modeled in terms of its major classes TEXT_OBJECT, 
COMPONENT, VERSIONED_OBJECT. THREAD, CONFIGURATION, and 
PROTOTYPE. In this chapter we define these classes, their behavior and attributes, and the 
operations they perform. 

A. GOALS 

The process of developing this application utilizes the object-oriented Programming 
concepts of specification, implementation, and refinement [Ref. 18:p. 5]. First we collect 
the requirements in terms of user needs. The result of this phase is documented in Chapter 
III. The next step is to develop a conceptual solution to the requirements. We then convert 
these conceptual ideas into concrete classes and operations. This is accomplished by first 
converting the entity-relationship (ER) diagram to a functional specification. 

From the functional specification we determined that a command line interface would 
best satisfy the requirement for separating the functionality of the tool from other CAPS 
tools and from the end user. The command line interface divides the functionality into three 
distinct classes - functions dealing with prototype level operations, those concerned with 
configurations, and those dealing with versioned component objects. The complete 
command line interface is contained in Appendix B. 

Now we develop an informal solution followed by a formal solution to the stated 
design requirements. 


28 




B. DESIGN DATABASE 


1. Informal Solution 

The DDB must contain a class structure and methods which support the 
storage, retrieval, and management of CAPS prototypes. Next we integrate the ONTOS 
object oriented Database Management System with locally engineered classes and methods 
designed to support the informal solution and stated requirements. This equates to 
designing a database schema. Choosing this approach carries several distinct advantages: 

• Saves money because the DDB can be develop)ed in less time 

• The ONTOS system provides an extensive developer’s library 

• Enhances Security 

• Network capabilities are built in 

• Encourages the use of off the shelf generic software programs 

• Incorporates enhanced documentation on data structures provided by 
ONTOS 

• Ensures modularity 

These and other advantages are discussed in Chapter II. 

2. Entities and Their Relationships 

The set of files reflected in Figure 8 become the primary attributes of a versioned 
component in the database. Other attributes required to effectively scope and manage these 
components and the unique capabilities supported by versioning are contained in the ER 
diagram shown in Figure 12. 

Figure 13 shows the lower level entities required to support the data structure of a 
versioned component. The entities THREAD, COMPONENT, and TEXT_OBJECT 
reflect the core elements stored as objects in the ONTOS database. 

3. Pre-defined ONTOS CIas.«es 

The main ONTOS classes used in this DDB application are: 


29 




^ ^ ^^sionN um^r 






Vereioned 

Compwnentl^ ^ 


■^'■^Qntained 

Contai 


contained 
child of '(0.1) 

( 0 , 1 ) 



... 

V Vobjecls 



Contains 
(0,n) 




Prototype 

✓ 




-yConfiguration_(Man5l^r 


(^r e^onP ^ j ( ^scripti ^ 

Prototype 
Controried 

[l^oi^ain^ 

Controls 

(0,n) ^-^ 

^^^Configuratioi^ 




j^eationD^ 

Figure 12. Design Database Entity Relationship Diagram 


a. Object 

Object is the class used to create persistent objects in the DBMS. All classes 
requiring persistence must inherit from Object. Persistent objects exist for longer than the 
immediate I/O session. An object is persistent if you can store it in the database and retrieve 
it at a later time. If an object is persistent it must have a unique id. This identification 


30 

















Figure 13. Design Database Entity Relationship Diagram 


number may be explicitly assigned by the DDB application or defaulted to a unique id key 
field generated by methods provided by this ONTOS class. This allows us to store several 
different components in the database with the appearance of each component having the 
same name. 

b. List 

Lists belong to a container class which can store other objects of any type. As 
a basic data structure, its sister class List_Iterator is used to iterate from one instance of an 
object to the next. 

c. Dictionary 

Working on an indexed set of objects contained within it. Dictionary is also a 
container class. It differs from List in its implementation and in its available methods for 
directly accessing any item contained within it based on key values. 

4. Design Database Classes 

The DDB classes and methods work to provide the user the functionality of a 
library. You can check components in or out. However, unlike a library, when you check 


31 








components out of the database for updating, a “copy” of the components is put into your 
private work area. These components are then flagged inside the DDB as being “locked”. 
This lock prevents other designers from checking out the same components for updating. 
The original component remains in the database and can never be altered. It is an immutable 
copy of the designer’s prototyping effons at the time it was checked into the DDB. Other 
workers who attempt to check out the same versioned components may “view” the 
prototype, but may not modify or evolve the prototype into a newer version. The designer 
unlocks the prototype when it is checked back into the database. If changes were made to 
a component then that component will version. If no changes were made then versioning 
will not be necessary and will not occur. In either case, when a prototype is checked back 
into the DDB, the locks on components in that prototype are removed. 

A diagram of the class hierarchy for the persistent objects in the DDB is included 
as Figure 14. A class is a high level abstraction that represents something in the real world. 
All classes developed to support this model are further elaborated with a class description, 
behavior, attributes, and operations in the rest of this section: 

Persistent DDB Classes 

Class COMPONENT 

COMPONENT is an abstract class in the DDB. It is the core element in the DDB 
and represents a composite or atomic PSDL operator/type. As reflected in the ER diagram 
contained in Figure 10, a component contains a variable number of TEXT_OBJECTS. 

COMPONENT, like all persistent classes, is a descendant of the ONTOS class 
Object. If a class intends to store persistent objects in the ONTOS database then the class 
must inherit from the Object class. 

A diagram of these dependencies is shown in Figure 14. 

Behavior: 

COMPONENT is an abstract container class for TEXT_OBJECTS. It is 
important to note the distinction between atomic and composite components in the DDB. 
Atomic objects differ from composite objects in the following way: composite objects 


32 










Figure 14. Design Database Descendants of Class Object 


decompose into other composite and/or atomic objects, but an atomic object has no further 
decompositions. In the multi-way tree utilized by this application, atomic objects have no 
children. 

Set of Attributes: 

text_object_list -> contains the list of text_objects in the component. May contain 
between zero and five of the following files: 

Postscript: A file containing Postscript Description Language required by the 
graphic editor. 

Graph: A file containing shapes and geometric point information required by the 
graphic editor. 

Implementation: A file containing either Ada source code or a PSDL 
decomposition. This file is used by the syntax directed editor, the dynamic 
scheduler, and the translator. 

Specification: A file containing Prototype Specification Description Language 
(PSDL). This file is used by the syntax directed editor, the software base, the 
dynamic scheduler, and translator. 


33 











Source: ADA Code - a special file containing the source code for the component 
and/or prototype. 

Operations: 

COMPONENT -> creates an instance of the COMPONENT class. 

getDirectType -> returns an ONTOS Type^ 

getComponentNames -> returns the names of the TEXT_OBJECTS. 

getComponentSource -> restores the Postscript, graph, implementation, 

specification, and source file attributes of a versioned component to the 

appropriate files in the designer’s work area. 

addTextObject -> adds a TEXT_OBJECT to the COMPONENT. 

getPSfile -> restores the Postscript file attribute of a versioned component to the 

appropriate files in the designer’s work area. 

getGRAPHfile *> restores the graph file attribute of a versioned 

component to the appropriate files in the designer’s work area. 

getSPECfile -> restores the graph file attribute of a versioned component to the 

appropriate file in the designer’s work area. 

getIMPfile -> restores the graph file attribute of a versioned 

component to the appropriate file in the designer’s work area. 

getSOURCEfile -> restores the graph file attribute of a versioned 

component to the appropriate file in the designer’s work area. 

Class CONFIGURATION 

When a large prototype is developed and evolved from one version to another, the 
user may wish to selectively group different versions of the component and its graph 
subtree into more manageable sets. CONFIGURATION is an abstract class which allows 
the designer to more effectively deal with selected subsets of components. Remembering 
that the database will eventually consist of several versions of a prototype and its 
1. Refer to Chapter II Section C for definition of ONTOS Type 


34 



decomposed components, the user may decide to set up a configuration to reflect version 
number 1 (CXI)NFIGl)and a newer configuration to reflect those components contained in 
version number 2 (CX)NFIG2). Working with configurations, the user may decide that the 
earlier configuration needs further refinement or that the older configuration is more suited 
to his application development needs. The DDB will allow the prototype developer to 
check out the older configuration and retrieve all components contained in that 
configuration with one single command. When the DDB is fully matured, that 
configuration will be checked back into the database as version 1.1 - spinning off a new 
thread from the base thread. This concept of a variation is not implemented in this version 
of the DDB, but will be developed in the next generation of the tool. 

Behavior: 

CONFIGURATIONS are entered into the database with commands given in 
Appendix B. A versioned component is then attached to the configuration as that 
configurations’ default versioned object. With this hook into the prototype tree structure, 
configurations allow the designer to navigate the prototype hierarchy - to store and/or 
retrieve versioned components quickly and efficiently to different work areas. 

Set of Attributes: 

config_status -> reflects the current status of design work. Possible values are ‘A’ 
- active; T’ - archive to tape. 

config_manager -> shows who is managing the configuration. 

ConfCreationDate -> time/date that the configuration was created. 
conf_num_vobJects -> derived field containing the number of versioned 
components in the configuration. 

config_log_entry -> contains a running, non-erasable log journal reflecting all 
changes to the configuration. 

config_description -> A modifiable attribute which contains a generic description 
of the configuration. 


35 




theVersioned_Object -> the default versioned component which serves as this 
configuration’s entry point to the prototype hierarchical data structure. There is 
only one default versioned component per configuration. This is attached to a 
configuration after the configuration is inserted into the DDB. 

Operations: 

CONFIGURATION -> creates an instance of the CONFIGURATION class. 
getDirectType -> returns an ONTOS Type. 

Destroy -> cleans up the heap. 

getConfigName -> displays the configuration name to stdout. 
name -> returns the configuration name. 
getConfigStatus -> displays the configuration status to stdout. 
getConfigManager -> displays the configuration manager to stdout. 
getConfigLog -> displays the configuration Log to stdout. 
getConfigDescription -> displays the configuration description to stdout. 
dumpConfigSummary -> displays the date created, manager, default versioned 
component, and description to stdout. 

listConfigOperators -> lists the entire configuration subtree (all operators from 
default versioned component). 

updateConfigManager -> updates the manager attribute. 
updateConfigName -> updates the name attribute. 
updateConfigStatus -> updates the status attribute. 
addtoConfigLog-> appends entry to the log attribute. 
ujxlateConfigDescription -> updates the configuration description. 

Class PROTOTYPE 

PROTOTYPE is the highest level abstract class. A prototype represents all of the 
information associated with one prototyping project. 

Behavior. 


36 






PROTOTYPES are entered into the DDB with commands reflected in Appendix 
B. PROTOTYPE is a container class which maintains references to CONFIGURATIONS 
and versioned components (V_OBJECTS). This ability to logically group several 
configurations and/or components into one prototype allows the designer to more easily 
manage a variable number of projects at any one time. 

Set of Attributes: 

protleader -> the name of the prototyping project leader. 
protDictIndex -> Required by ONTOS for Dictionary maintenance. 
protCreationDate -> The time/date that the prototype was created. 
protDescription -> A reference to a TEXT_OB JECT containing a text description 
of the prototype. 

prot_configuration_list ->A reference to a hst of configurations associated with a 
prototype. 

prot_default_configuration -> A reference to the last configuration inserted into 
the prototype. 

Operations: 

PROTOTYPE -> creates an instance of the PROTOTYPE class. 
getDirectType -> returns an ONTOS Type. 

Destroy -> cleans up the heap. 

getName -> returns the PROTOTYPE object name. 

getConfigName -> returns default configuration object name. 

getPrototypeName -> displays prototype name to stdout. 

getPrototypeLeader -> displays prototype leader to stdout. 

getPrototypeDescription -> displays prototype description to stdout. 

changePrototypeName -> substitutes new name for existing name. 

changePrototypeLeader -> substitutes new leader for existing leader. 

upxlatePrototypeDescription -> substitutes new description for current 

description. 


37 





dumpPrototypeSummary -> displays the date created, leader, default 

configuration name, and description to stdout. 

addConfiguration -> adds configuration to prototype configuration list. 

listConfigurations -> lists configurations to stdout. 

setProtCreationDate -> sets the prototype creation date to system time. 

getProtCreationDate -> returns a time/date of prototype creation. 

getDefaultConfigName -> displays the default configuration name to stdout. 

getConfiguration -> returns the configuration requested. 

getDefaultConfiguration -> returns the default configuration. 

getVobject -> returns the most current versioned component matching the 

prototype name. 

Class TEXT OBJECT 

TEXT_OBJECT contains a file name and its associated text. 

Behavior: 

Accept the file name, construct an object in the ONTOS database to store the 
name and file contents, and read the file contents into the persistent object. 

Set of Attributes: 

the_file_name -> name of the tool file. 
the_text -> contents of the text file. 

Operations: 

TEXT_OBJECT -> creates an instance of the TEXT_OBJECT class. 
getDirectType -> returns an ONTOS Type. 

Destroy -> cleans up the heap. 

append -> reads the contents of the file into the ONTOS object, 
text -> sends a stream to output file. 

rebuildTextFile -> rebuilds the text file in the user’s work area and returns 
completion status. 


38 







displayFileName -> displays the file name to stdout. 
getFileName -> return the file name, 
text -> returns the object’s text. 
resetTheText -> resets the text attribute. 

Class THREAD 

THREAD is a high level abstract class which contains one or more versions of the 
same component. Additional components added to a thread have a version number 
determined by incrementing the highest version number of a component in the thread by 
one. 

Behavior : 

A thread is created for every new component entered into the database. Most 
methods check for the existence of a THREAD prior to executing a requested operation. 
Set of Attributes: 

cuirencversion -> version number of the most recent version on the thread. 
the_list -> an ONTOS reference to a List containing different versions of a 
component. 

Operations’. 

THREAD -> creates an instance of the THREAD class. 
getDirectType -> returns an ONTOS Type. 

Destroy -> cleans up the heap. 

getCurrentVersionNum -> returns the integer current version. 

current -> returns the versioned component (V_OBJECT) having the same 

version number as the current version attribute of the thread. 

version -> returns the versioned component (V_OBJECT) having the version 

number supplied by the calling method. 

add_object -> adds a new versioned component (V_OBJECT) to the thread. 


39 



displayThreadVersions -> display the version number of every versioned 
component (V_OBJECT) in the thread. 

displayThreadContents -> displays the version number and the description of 
every versioned component (V_OBJECT) in the thread. 

Class V_OBJECT 

V_OBJECT is an abstract persistentclass. It represents an immutable snapshot in 
time of an operator/type that was checked into the database as part of a prototype design. 
Behavior. 

V_OBJECTS are entered into the DDB with commands reflected in Appendix B. 
Only the root V_OBJECT must be entered by the user (tool interface). The TREE class then 
scans the directory for other operators which are descendants of that operator and 
constructs a tree structure for comparison to the contents of the database. 

Set of Attributes: 

theVersionNumber -> the component’s version number. 
creationDate -> the date the component was created. 

lockTime -> the date the component was created. Evaluated as the system’s epoch 
time if not locked. Epoch time means no lock is set and lockTime equals zero. 
node_name -> short node name. No ancestor information. The long name is 
contained in the THREAD class. 

creator -> name of the end user who created the component. 

worker -> if the component is locked, then this attribute contains the name of the 

worker who checked it out. 

visited -> a boolean used to navigate the tree structure. 
last_op_checkin -> a boolean used to prevent duplicate checkin operations. 
theDescriptionPtr -> TEXT_OBJECT containing the description for this 
versioned component. 

theThreadPtr -> pointer to the THREAD this versioned component is contained 
in. 


40 





theCOMPONENTPtr -> points to the component which contains the text object’s 

for this versioned object. 

theChildFhr -> points to a list of Children. 

theParentPtr -> points to the most current parent. 

Operations: 

V_OBJECT -> creates an instance of the V_OBJECT class. 
getDirectType -> returns an ONTOS Type. 

Destroy -> cleans up the heap. 

connect_vobject_to_thread -> attaches a versioned component to a thread. 

setParent -> set’s versioned components Parent. 

setNodeName -> pulls the short node name from the thread name. 

getNodeName -> returns the short node name. 

getVobjName -> displays the component name. 

getName -> returns the component name. 

resetVisitedFlag -> used to navigate the tree. 

setVisitedFIag -> used to navigate tree. 

getVisitedFlag -> TRUE if visited, FALSE otherwise. 

getVObjComponentsName -> display the names of the text objects associated 
with this versioned component. 

displayVersionNumber -> displays the component’s version number to stdout. 

getVersionNumber -> return the component’s version number. 

dumpVobjSummary -> displays the date created, creator, worker (or None if 

unlocked), lockTime (or NONE if unlocked), and description to stdout. 

setCreationDate -> The time/date that the component was created 

getCreationDate -> returns the time/date the component was created. 

setLock -> set’s the lockTime immediately following checkout. 

getVv orker -> return the worker who has the component locked. 

getCreator -> return the end user who created the component into the DDB. 


41 




setWorker -> set the worker to the $USER environment variable. 
resetLastOpTrue -> if last operation was a checkin, then set the last operation 
checkin attribute to TRUE, prevents duplicate checkins. 
resetLastOpFalse -> on a checkout, reset the last operation checkin to FALSE. 
get_last_operation -> returns TRUE if last operation was a checkin. 
leleaseLock -> resets lock and returns completion status. 
getLockTime -> returns the lockTime of the component. 
getDescription -> displays the description to stdout. 

hstChildren -> displays a list of children of this versioned component to stdout. 
longlistOperatorNames -> displays a long list of all operators/types in the subtree 
of this versioned component. 

listOperatorNames -> displays a list of all operators/types in the subtree of this 
versioned component. 

updateDescription -> updates the description attribute. 
addCOMPONENTNode -> adds a component to this versioned object. 
deleteChildNode -> deletes a reference from the list theChildPtr. 
addChildNode -> adds a reference to the list theChildPtr. 
getParent -> returns the parent of this versioned component. 
getCOMPONENT -> returns the component of this versioned object. 
dumpSubtree -> rebuilds the versioned components in read-only or read-write 
mode into an end user’s SPROTOTYPE directory. 

releaseLockSubtree -> releases the lockTime on all versioned components in this 
component’s subtree. 

getChildren -> returns the list of Children of this versioned component. 
getChildPtr -> returns TRUE if the cardinality of children of this component is 
greater than zero. 

checkoutCOMPONENTNode -> rebuilds all text objects of the component 
attribute of this versioned object and returns completion status. 


42 




Non Persistent DDB Classes 


Class DIRECTORY 

A non-persistent class designed to evaluate the status of prototypes being checked 
into the DDB. 

Behavior. 

This class has no direct relationship to the end user interface. The directory class 
searches the $PROTOTYPE subdirectory of the designer, determines what 
operators exist that match the prototype name, and develops a linked list of nodes 
to be inserted into a multi-way tree. The output from this class is passed to the 
TREENODE class for insertion of nodes into the persistent database. 

Set of Attributes: 

TREENODE_linked_list -> operator/type nodes contained in the user’s 
PROTOTYPE directoo'. 

Operations: 

DIRECTORY -> constructor for building a directory scanner. 
read_directory -> Given a root operator, scans the user subdirectory for prototype 
component matches. Builds a list of all prototype components. Stores the 
potential component matches in a linked list of operator nodes, 
updatetimestamp -> evaluates whether component files in the user work area are 
newer than the versioned component stored in the ONTOS database. This 
information is used by the TREENODE class when determining whether to create 
a new version of the component. 

rind_treenode -> scans the linked list of operator nodes to build the multilevel k- 
ary tree of TREENODES. Both operator nodes and TREENODES use the same 
class structure, except that the operator nodes have no children (subtree) 
references. 


43 





getOperatorList -> required to build the multilevel k-ary tree. Retum.s the operator 
list defined by evaluating the users work area with the read_dir^ lurv . .ation. 

Class QUEUE 

QUEUE contains the basic non-persistent queue dai-s siucture required to 
construct the multi-level k-ary hierarchy. 

Behavior: 

Implements basic queue functions. 

Set of Attributes: 

None. 

Operations: 

put -> append an operator TREENODE on the queue, 
get -> get an operator TREENODE from the queue, 
empty -> test the queue for empty status. 

Class slist, slink, slistjterator, slinkjterator 

These classes are non persistent abstract classes providing the generic capabilities 
of a singly linked list. 

Behavior: 

these classes contain the basic data structures required for queues and linked lists. 

Set of Attributes: 

e -> treenode pointer. 

next -> link pointer. 

ce, last -> slink pointer. 

cs -> slist pointer. 

Operations: 

slist, slink, slist_iterator, slink_iterator -> constructors, 
insert -> add TREENODE at head of list. 


44 





append -> add TREENODE at tail of list, 
get -> return TREENODE. 
clear -> remove all links, 
empty -> test for empty list. 

Class TREE 

A non-persistent class designed to build a multi-way tree of operator/types 
developed by the end user in the $PROTOTYPE directory. 

Behavior: 

The TREE class will establish the root operator and build the tree. 

Set of Attributes: 

tree_name -> assumes the name of the prototype root versioned component. 
theTreeRootNode -> TREENODE (root of multi-level k-ary tree). 

Operations: 

TREE -> constructor for building the root TREENODE. 
build_tree -> builds the multi-level tree. 

find_treenode -> returns a TREENODE from the input list of Operator nodes 
returned from DIRECTORY. 

Class TREENODE 

The most important non-persistent class designed to build a multi-way tree of 
operator/types developed by the end user in the $PROTOTYPE directory. 

Behavior : 

The TREENODE class is used to establish the operator node list, to convert the 
operator node list to a multi-level tree, and to compare each node in the multi-ievel tre'* to 
versioned components in the database. Component versioning occurs where the 
TREENODES have newer timestamps than the lockTime on the versioned components. 
Set of Attributes: 


45 






tree_node_nanie -> explicit name of node (from root node to level in subtree). 
Taken in its entirety, the tree_node_name contains the sequence of ancestor 
names from the entire prototype name to the given sub-component’s node_name. 
node_name -> unique name of operator/type without level/ancestor information, 
timestamp -> contains the operator/types most recent system time. Each tool 
updates the file when it creates or updates its product files, 
level -> root operator equals 1. Other nodes reflect the level where they reside. 
ChildrenList -> linked list of TREENODE descendants of this instance. 
ParentNode -> parent TREENODE of this instance. 

Operations: 

TREENODE -> constructor which reads directory and builds operator list, 
updatetime stamp -> reads the directory again for the newest of potential files for 
each operator/type developed by CAPS tools. Stores the result in timestamp, 
gemame -> returns the TREENODE name. 
insenChildNode -> inserts a TREENODE into the ChildrenList. 
getChildren -> returns the linked list of Children TREENODES. 
getParentNode -> returns the Parent TREENODE of this instance. 
get_asc_time -> returns the 26 character ASCII time from the standard C function 
ctime. 

getlevel -> return the level of this TREENODE. root is level 1, successive levels 
increment by 1. 

get_long_time -> return the timestamp. 

list_subtree -> lists each TREENODE from the root to each leaf node. 
checkin_subtree -> initiates the recursion for comparing the tree of TREENODEs 
to the hierarchical structure in the ONTOS database. 

checkin_node -> does the bulk of the loading into the ONTOS database. Creates 
new threads and versioned components when the TREENODE timestamp is more 


46 



current than the versioned component’s lockTime or where no thread with that 
operator name exists (new operator). 

C. TESTING AND EVALUATION 

The method used for checking the functionality of the DDB required an exhaustive 
check of many possible variations of the functions documented in Appendix B. To 
demonstrate that each of the commands produce the desired output, a unix shell script was 
generated which tested all of the functions. The complete version of this shell script test is 
contained in Appendix C. 

The output from this sequence of commands, also contained in Appendix C, shows 
that the testing phase answered two very important questions affirmatively - that this tool 
could successfully store and retrieve versioned components of prototypes as dictated by the 
design criteria; and that the software engineering design database could be developed as a 
stand-alone tool which interacted with other tools through the tool interface. 

The results of some commands can not be verified by running that command alone. It 
is only by running several commands in a series that the effect of one command changing 
the state of the database can be verified. Consequently, these types of tests were included 
in the testing phase. 

D. MAINTENANCE NOTES 

All code generated by the authors in support of this implementation effort is contained 
in Appendix D. 

This code was developed using version 2.0 of the Glockenspiel C-n- compiler and the 
beta version 2.01 of the ONTOS object-oriented Database Management System. ONTOS 
tools included packages containing extensive capabilities for debugging in the form of the 
ONTOS graphical database browser (DBrowser). 

Special ONTOS header files and the makefiles used during compilation are contained 
in Appendix E. 


47 



V. CONCLUSIONS AND RECOMMENDATIONS 


A. SUMMARY 

The goal of this thesis research was to design and develop an engineering database 
which could store, version, and retrieve software prototype components. This database 
provides concurrent users the command functions to insert prototypes, store and manage 
configurations, and insert and retrieve components throughout the software engineering life 
cycle. 

The prototype functions allow the designer to store and retrieve management 
information concerning any of several potential prototype designs. 

The configuration functions allow the designer to more easily navigate the various 
versions of a software prototype. It provides him a “hook” for navigating the hierarchy 
from any specified component. With additional features such as grouping by configuration 
and logging, configurations provide powerful features and a sound design for the 
development of evolution management into the engineering database model. 

The versioned component functions give the designer the flexibility to checkout for 
modification or viewing specific prototype components; to expand, modify, and 
decompose these components with other tools in the CAPS system; and to check selected 
portions of those components back into the database at any time[Ref. 19]. 

B. RECOMMENDATIONS FOR FUTURE WORK 

1. Variations 

Variations will allow users to check out older versions of components and/or groups 
of components and evolve them to newer versions. When the updates are completed 
components will version correctly - splitting, updating, and rejoining threads where 
appropriate. Work must be done on other tools in the CAPS system to make them accept as 
input and produce as output components which contain version information. This will 


48 





provide the DDB with the necessary information for re-attaching components to the 
hierarchical structure at the correct location. 

2. Security 

This implementation of the engineering database does not address the issue of 
security other than the concurrency control mechanisms. This thesis makes no effort to 
distinguish between different levels of access or authorization for access to objects and 
their attributes. This is a subject that requires additional research and development. 

3. Evolution Management 

This program must be enhanced to incorporate the “uses” and “derives” 
prop)erties [Ref. 11]. The database will then be capable of automatically flagging the effects 
that changing one component has on other components in the prototype. As components 
are checked out of the database they must take information with them pertaining to the 
version checked out. This is required to reattach components to the multi-way tree upon 
update. These and other evolution attributes v-ill become an important ingredient for 
providing a fully functional engineering database. 


49 




APPENDIX A 


ENVIRONMENTAL MODEL 
A. STATEMENT OF PURPOSE 

The Piupose of the design database is to provide the designer a method of storing 
and retrieving components generated by the various tools of the COMPUTER AIDED 
PROTOTYPING SYSTEM (CAPS). This tool shall be flexible enough to expand as other 
tools are developed. It shall be capable of maintaining older versions of components as new 
components are developed. It shall allow the user to version new and/or older components 
with the common interface considerations. 


50 






B. EVENT LIST 


List prototypes 

List current version of prototype 
Select current version of protot>pe 

Check out current version of prototype’s components for viewing/update 
Add new version of prototype’s components 
List previous versions of prototype 
Select previous version of prototype 

Check out previous version of prototype’s components for viewing/update 
List selected prototype attributes (creation date, leader, etc) 

Update selected prototype attributes (leader, description, etc) 

List composite components (operators/types) 

List atomic components (operators/types) 

List selected versioned component attributes (date created, description, etc.) 
Upxlate selected versioned component attributes (date created, description, etc.) 
List configurations 

List current default version of configuration in prototype 
Select current default version of configuration in prototype 
Check out current version of configuration for update 
Add new version of configuration’s components 


51 







C. CONTEXT DIAGRAM 



graphic 

editor 


Ada 

compiler 


prototype 


dynamic 
scheduler 1 


syntax 

directed 


translator 


static 

scheduler 


syntax j 

i 

directed 1 


CAPS Interface Data Flow Diagram (partiai/modified) [Ref. 3:p. 19] 











APPENDIX B 


COMMAND INTERFACE 


A. PROTOTYPE COMMANDS 

Table 1: PROTOTYPE COMMANDS 


Tag 

Description 

Output 

CaU^ 

PIP 

Insert Prototype 

Confirmation 

ddb <db> pip <p>^ 
[leader] [description]'^ 

PLN 

List Names 

Names (1 per line) 

ddb <db> pin 

PLL 

Long List 

Name/Default Config/ 
Default VOBJECT 

ddb <db> pll 


Retrieval Commands: 



PDS 

Dump Summary 

Date Created 

Leader 

Default Config 
Description 

ddb <db> pds <p> 

PRD 

Retrieve Date 

Date Created 

ddb <db> prd <p> 

PGL 

Get Leader 

Leader 

ddb <db> pgl <p> 

PGC 

Get Configuration 

Default Config 

ddb <db> pgc <p> 

PCD 

Get Description 

Description 

ddb <db> pgd <p> 


Update Commands: 



PUL 

Update Leader 

Confirmation 

ddb <db>pul <p> “new 
leader” 

PUD 

Update Description 

Confirmation 

ddb <db>pud <p> file 


a. <angle brackets> rcticci required paramcicrs. {square brackeisj denoie optional parameters. 

b. <db> db=any Ontos Database name. <p> p=any prototype name 

c. Passed in as a file-name or string 








































B. CONFIGURATION COMMANDS 


Table 2: CONFIGURATION COMMANDS 


Tag 

Description 

Output 

Call® 

CIC 

Insert Configuration 

Confirmation 

ddb <db>cic <p> 

u 

<c> [manager] 
[description]® 

CLN 

List Names 

Names (1 per line) 

ddb <db> cln <p> <c> 

CLV 

List Default VOBJECT 

NameA^ersion 

ddb <db> civ <p> <c> 

CLO 

List Operators 

Operator Name*^/ 
Version 

ddb <db> do <p> <c> 

CLL 

Long List Default VOB- 
JECT’s Children 

Node® Name Aver¬ 
sion 

ddb <db> cll <p> <c> 


Retrieval Commands: 



CDS 

Dump Summary 

Date Created 

Date Changed 
Manager 

Default VOBJECT/ 
Version 

Description 

ddb <db>cds <p> <c> 

CDA 

Get Date Created 

Date Created 

ddb <db> cda <p> <c> 

CGM 

Get Manager 

Manager 

ddb <db> cgm <p> <c> 

CGD 

Get Description 

Description 

ddb <db> cgd <p> <c> 

CGL 

c 

ViewLog 

Log Entries 

ddb <db> cgl <p> <c> 


Update Commands: 



CUN 

Update Name 

Confirmation 

ddb <db> cun <p> <c> 
new_name 

CUM 

Update Manager 

Confirmation 

ddb <db> cum <p> <c> 
new_name 

CUD 

Update Description 

Confirmation 

ddb <db> cud <p> <c> 
file 


54 





























































Table 2: CONFIGURATION COMMANDS 



CPL Post Log 


CRL Release Lock 


Confirmation 


Confirmation 


CAA Update VOBJECT’s sub- Confirmation 


ddb <db> cpl <p> <c> 
file 


ddb <db> crl <p> <c> 
[version] 


ddb <db> caa <p> <c> 


CAO Attach VOBJECT to CON- Confirmation 
nCURATION 


Extraction Commands: 


CDT Dump VOBJECT subtree file(s) 


ddb <db> cao <p> <c> 
<vobject> [version] 


ddb <db> cdt <p> <c> 
R/W®[ version] 


a. <angie Drackets> reiieci required parameters, isquare brackets] denote opuonal parameiers. 

b. <db> dl^any Ontos Database name. <p> p=any prototype name <c> c = any configuration 


c. Passed in as a file-name or string 

d. Operator name containing explicit path information for determining location (level) in heirar- 
chical data structure 

e. Node name containing no reference to location (level) in heirarchical data structure 

f. Log may be viewed only. Log can not be updated. Additional log entries are posted to the bot¬ 
tom of the current log. 

g. R/W dump file for Read-Only (R) or Write (W). Tool interface must supply either R or W to 
build files. 


55 





























C. VERSIONED COMPONENT COMMANDS 


Table 3: VERSIONED COMPONENT COMMANDS 


Tag 

Description 

Output 

Call® 

VAA 

Add VOBJECT & Sub¬ 
tree 

Confirmation 

ddb <db>vaa <p> <v>*’ 

VLO 

List Operators 

VOBJECT Name‘s/ 
Version 

ddb <db> vlo <p> <v> 
[version] 

VLL 

Long List VOBJECT’s 
Children 

VOBJECT Name'*/ 
Version 

ddb <db> vll <p> <v> 
[version] 

VLP 

Long List VOBJECT’s 
Parent & Siblings 

VOBJECT NameA^er- 
sion 

ddb <db> vlp <p> <v> 
[version] 


Retrieval Commands 



VDS 

Dump Summary 

Date Created 

Creator 

Worker (or NONE) 
Lock Time (or 

NONE) 

Description 

ddb <db> vds <p> <v> 
[version] 

VDD 

Get Date Created 

Date Created 

ddb <db> vdd <p> <v> 
[version] 

VGL 

Get Lock Time 

DateATime Locked 

ddb <db> vgl <p> <v> 
[version] 

VGV 

Get Versions 

Version Number 
(1 per line) 

ddb <db> vgv <p> <v> 

VGD 

Get Description 

Description 

ddb <db> vgd <p> <v> 
[version] 


Update Commands: 



VUD 

Update Description 

Confirmation® 

ddb <db> vgd <p> <v> 
file^ 

[version] 



56 




















































Table 3: VERSIONED COMPONENT COMMANDS 


Tag 

Description 

Output 

Call® 

VAA 

Add VOBJECT and 
subtree 

Confirmation 

ddb <db> vaa <p> <v> 
[version] 

VRO 

Release Lock Operator 

Confirmation 

ddb <db>vro <p> <v> 
[version] 

VRS 

Release Lock Operator 
and Subtree 

Confirmation 

ddb <db> vrs <p> <v> 
[version] 


Extraction Commands: 



VGP 

Get Postscript 

file 

ddb <db>vgp <p> <v> 
R/W® 

[version] 

VGG 

Get Graphics 

file 

ddb <db>vgg <p> <v> 

R/W 

[version] 

VGI 

Get Implementation 

file 

ddb <db>vgi <p> <v> 

R/W 

[version] 

VGC 

Get Specification 

file 

ddb <db>vgc <p> <v> 

R/W 

[version] 

VGS 

Get Source 

file 

ddb <db>vgs <p> <v> 

R/W 

[version] 

VDF 

Dump Operator 

Atomic*’ 

file 

ddb <db>vdf <p> <v> 

R/W 

[version] 

VDT 

Dump Operator and 
Subtree 

file(s) 

j 

ddb <db> vdt <p> <v> 

R/W 

[version] 


b. <clb> db=any Ontos Database name. <p> p=any prototype name <c> v=any vobject name 

c. Operator name containing explicit path information for determining location (level) in heirar- 
chical data structure 

d. Node name containing no reference to location (level) in heirarchical data structure 
c. Only Creator may update description 


57 








































f. file containing description 

g. R/W dump file for Read-Only (R) or Write (W). Tool interface must supply either R or W to 
build files 

h. Atomic is considered collection containing .ps .graph .imp.psdl .spec.psdl and .a file(s) 


*^8 





APPENDIX C 

TESTING AND EVALUATION 

A. NOTES ON TESTING AND EVALUATION 

For functions which return no visible output, the successful completion is marked by 
the standard output of: 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Three Prototypes are inserted into the Engineering Database. These include one 
Command and Control Application (c3i) and two classroom applications (FishFarm and 
Robot). The purpose for inserting three applications is to test working with several 
prototypes. After demonstrating these functions, the remaining functions are run against the 
more comprehensive prototype created by the CAPS system called c3i. This prototype was 
selected due to it’s ability to fully exercise the “graph walking” capabilities of the model. 

B. TEST SCRIPT 


# I/asr/loriVc i.V'f' ch 
clea*’ 

echo “***•*•***♦*•♦**********•*•*♦**•*•*••*•••***»»*»*••******♦»•*•*♦***♦•**” 

echo ••♦NAVALPOSTGRADUATESCHOOL*” 

echo “ * Software Engineering *” 

echo “ * Design Database *” 

echo “ * Thesis Advisor Dr. Luqi 

echo “ * Wriuen by: Drew Dwyer and Garry Lewis *” 

echo “ * Design Database vl.l WP.D.A.L.G . *” 

echo“**********************************************************+***********” 

echo “ “ 
echo" “ 

echo -n “Press Return to oegin demonstration “ 

set a=($<) 

clear 

echo “Running main ddb53 pip c3i...” 
echo “ “ 

main ddb53 pip c3i 

echo “Running main ddb53 pip fishfarm ‘Drew Dwyer’...” 
echo “ “ 

main ddb53 pip fishfarm “Drew Dwyer” 

echo “Running main ddb53 pip robot ‘Garry W. Lewis’ filel ...” 

echo “ “ 

main ddb53 pip robot “Garry W. Lewis” filel 


echo “ “ 


59 






echo -n “INSERT PROTOTYPE test complete ... Press Return to continue “ 
set a=($<) 
echo “ “ 
clear 

echo “Running main ddbS3 pgd robot.. jetums description to screen...” 
echo “ “ 

main ddb53 pgd robot 

echo “Ruiming main ddbS3 pud robot file! ...updates description ...” 
echo “ “ 

main ddb53 pud robot rile2 

echo “Running main ddb53 pgd robot ..returns the new description.” 
ccho“ “ 

main ddb53 pgd robot 
echo “ “ 

echo -n “GET/UPDATE PROTOTYPE DESCRIPTION test complete ... Press Return to continue 

set a=($<) 

clear 


echo “Running main ddb53 prd c3i “ 
echo “ “ 

main ddb53 prd c3i 
echo “ “ 

echo -n “RETRIEVE PROTOTYPE DATE test complete ... Press Return to continue 

set a=($<) 

clear 


echo “Running main ddb53 pul robot Larry Williamson ...” 

main ddb53 pul robot “Larry Williamson” 

echo “ “ 

echo “ " 

echo “ “ 

echo “Running main ddb53 pgl robot” 
main ddb53 pgl robot 
echo “ “ 

echo -n “UPDATEAjET PROTOTYPE test complete ... Press Return to continue “ 

set a=($<) 

clear 


echo “Running main ddb53 pds c3i 
echo “ “ 

main ddb53 pds c3i 

echo -n “Press Return to continue " 

set a=(S<) 

clear 


echo “Running main ddb53 pds fishfarm ...” 
echo “ “ 

main ddb53 pds fishfarm 

echo -n “Press Return to continue “ 

set a=(S<) 

clear 


echo “Running main ddb53 pds robot...” 
echo “ “ 


main ddb53 pds robot 


60 



echo “ “ 

echo -n “DUMP PROTOTYPE SUMMARY tesl complete ... Press Return to continue 

act a=(S<) 

clear 

echo “ “ 

echo “Running main ddbS3 pin ..." 

echo “ “ 

main ddbS3 pin 

echo “ “ 

echo -n “LIST PROTOTYPE NAMES test complete ... Press Return to continue “ 

set a=($<) 

clear 


echo “Running main ddb53 cic c3i unix ...” 
echo “ “ 

main ddbS3 cic c3i unix 
echo “ “ 

echo “Running main ddb53 cic c3i dos ‘Drew Dwyer’...” 
main ddb53 cic c3i dos “Drew Dwyer” 
echo “ “ 

echo “Running main ddb53 cic c3i spare ‘Garry Lewis’ filel ...” 
main ddb53 cic r3i spare “Garry Lewis” ftlel 
echo “ “ 

echo -n “INSERT CONFIGURATION test complete... Pres cium to continue 

set a=(S<) 

clear 


echo “Running main ddb53 cum c3i dos ‘Marty Shoppenheimer’...” 
main ddb53 cum c3i dos “Marty Shoppenheimer” 
echo “ “ 

echo -n “UPDATE CONFIGURATION MANAGER test complete... Press Return to continue “ 

set a=($<) 

clear 

echo “Running main ddb53 cds c3i unix ...” 

main ddb53 cds c3i unix 

echo -n “Press Return to continue “ 

set a=($<) 

clear 


echo “Running main ddb53 cds c3i dos ...” 

main ddb53 cds c3i dos 

echo -n “Press Return to continue “ 

set a=(S<) 

clear 


echo “Running main ddb53 cds c3i spare ...” 
main ddb53 cds c3i spare 

echo -n “DUMP CONFIGURATION SUMMARY test complete... Press Return to conunuc “ 

set a=($<) 

clear 

echo “Running main ddb53 cgd c3i spare ...” 
echo “ “ 

main ddb53 cgd c3i spare 


61 





echo -n “Press Return to continue 

set a=($<) 

clear 


echo “Running main ddb53 cud c3i spare file2 ...” 
echo “ “ 

main ddbS3 cud c3i ^)arc file2 
echo -n “Press Return to continue “ 
set a=($<) 
clear 


echo “Running main ddb53 cgd c3i spare ...” 
main ddbS3 cgd c3i spare 

echo -n “CONFIGURATION DUMP SUMMARY test complete... Press Return to continue 

set a=($<) 

clear 


echo "Running main ddb53 eda c3i spare ...” 
echo “ “ 

main ddbS3 eda c3i spare 
echo " “ 

echo -n “GET CONFIGURATION DATE test complete... Press Return to continue” 

set a=($<) 

clear 


echo “Running main ddb53 cpl c3i spare ‘This is the first Post to Sparc Log’ “ 
echo “ “ 

main ddb53 cpl c3i spare “This is the first Post to Sparc Log” 
echo “ “ 

echo “Now check it to see that it’s posted...” 
echo “ “ 

echo “Running ddb53 cgl c3i spare ...” 
echo “ “ 

main ddb53 cgl c3i spare 

echo -n “Press Return to continue “ 

set a=($<) 

clear 

echo “Add another line to the log ...” 

echo “Running main ddb53 cpl c3i spare ‘This is the second Post to Sparc Log’ “ 
echo “ “ 

main ddb53 cpl c3i spare “This is the second Post to Sparc Log” 
echo “ “ 

echo “Show the results ...” 

echo “Running ddb53 cgl c3i spare ...” 

echo “ “ 

main ddb53 cgl c3i spare 
echo” “ 

echo -n “POST/GET CONFIGURATION LOG test complete... Press Return to continue” 

set a=($<) 

clear 


echo “ “ 

echo “Running main ddb53 cgm c3i dos ..’ 
main ddb53 cgm c3i dos 


62 




echo “Now we’ll change the manager to ‘Kelly Mcdowell’ “ 
echo “ “ 
echo “ “ 

echo “Running main ddbS3 cum c3i dos ‘Kelly Mcdowell’...” 
main ddbS3 cum c3i dos “Kelly Mcdowell” 
echo “ “ 
echo “ “ 

echo “Now make sure it posted...” 
echo “Running main ddb53 cgm c3i dos...” 
main ddb53 cgm c3i dos 
echo” “ 

echo -n “GETAJPDATE CONFIGURATION MANAGER test complete... Press Return to continue” 

set a=($<) 

clear 


echo “Running main ddb53 cln c3i...” 
main ddbS3 cln c3i 
echo “ “ 

echo -n “LIST CONFIGURATION NAMES test complete... Press Return to continue” 

set a=($<) 

clear 

echo “We now move on to the actual loading of the ONTOS Database. “ 
echo “ “ 

echo “Running main ddb53 vaa c3i c3i...” 
main ddb53 vaa c3i c3i 
echo “ “ 

echo “Add c3i lest complete... Now we’ll add a different Prototype “ 
echo -n “called fishfarm. Press Return to continue...” 
set a=($<) 
clear 


setenv PROTOTYPE Ai/gemini/work/dwyer/SCCS/fish 
echo “Running main ddbS3 vaa Hshfarm Hshfarm ...” 
main ddbS3 vaa fishfarm fishfarm 
echo “ “ 

echo “Add fishfarm test complete... Now we’ll add a different Prototype 
echo -n “called robot Press Return to continue...” 
set a=(S<) 
clear 


setenv PROTOTYPE Ai/gemini/work/dwyer/SCCS/robot 
echo “Running main ddb53 vaa robot robot...” 
main ddb53 vaa ro^ t robot 

echo “Add robot test complete ... Press return to continue” 

set a=(S<) 

clear 

setenv PROTOTYPE Ai/gemini/work/dwyer/caps/proto 
echo “ “ 

echo “Now show the PLL command to reflect that each Prototype has a default version” 
echo “ “ 

echo “Running ddb53 pll...” 
main ddb53 pll 

echo -n “LOAD V_OBJECT and SUBTREE test complete... Press Return to continue” 

set a=($<) 

clear 


63 





echo “Running main ddb53 vlo c3i c3i...” 
echo" “ 

main ddb53 vlo c3i c3i 
echo 

echo -n “Press return to continue...” 

set a=($<) 

clear 

echo “Running main ddbS3 vll c3i c3i...” 
echo “ “ 

main ddbS3 vll c3i c3i 

echo -n “Press Return to continue ...” 

scta=($<) 

clear 

echo “Running main ddbS3 vlo c3i c3i.comms_inierface ...” 
echo “ “ 

main ddb53 vlo c3i c3i.comms_interface 
echo -n “Press Return to continue ...” 
set a=($<) 
clear 

echo “Running main ddb53 vll c3i c3i.comms_interface ...” 
echo “ “ 

main ddb53 vll c3i c3i.comms_interface 
echo “ “ 

echo -n “V_OBJECT LISTA.ONG LIST OPERATORS test complete... Press Return to continue” 

set a=(S<) 

clear 

echo “Running main ddb53 vlo c3i c3i.commsJntcrface.resolve_oulgoing_messages...” 
echo" " 

main ddb53 vlo c3i c3i.comms_interface.resolve_ouigoing_messages 
echo -n “Press Return to continue ...” 
set a=($<) 
clear 

echo “Running main ddb53 vll c3i c3i.comms_intcrface.resolve_outgoing_messagcs ...” 
echo “ “ 

main ddb53 vll c3i c3i.comms ,intcrfacc.resolve_oulgoing_messages 
echo “ “ 

echo -n “V_OBJECT LIST/LONG LIST OPERATORS lest complete... Press Return to continue” 

set a=(S<) 

clear 

echo “Running main ddb53 CAO c3i unix c3i...” 
echo “ “ 

main ddbS3 cao c3i unix c3i 
echo “ “ 

echo “Running main ddb53 cao c3i dos c3i.user_intcrface “ 
e.' ho “ " 

main ddb53 cao c3i dos c3i.user_interface 

echo “Running main ddb53 cao c3i spare c3i.comms_inicrface.resolve_outgoing_mcssages” 
echo “ “ 

main ddb53 cao c3i spare c3i.comms_inlerface.resolve_outgoing_messagcs 
echo “ “ 

echo -n “ATTACH OPERATORS to a CONFIGURATION test complete... Press Return to continue” 

set a=($<) 

clear 


64 




echo “Running main ddb53 do c3i unix ...” 
main ddbS3 do c3i unix 
echo “ “ 

echo -n “Press Return to continue” 

seta=($<) 

clear 


echo “Running main ddb53 do c3i dos ...” 
echo 

main ddbS3 do c3i dos 
echo “ “ 

echo -n “Press Return to continue” 

set a=($<) 

clear 


echo “Running main ddb53 do c3i spare ...” 
echo “ “ 

main ddb53 do c3i spare 
echo “ “ 

echo -n “CONFIGURATION LIST OPERATOR test complete... Press Return to continue” 

set a=($<) 

clear 


echo “Running main ddb53 ell c3i unix ...” 
ech('“ “ 

maia ddb53 dl c3i unix 
echo “ “ 

ec! t -n “Press Return to continue” 
set .i=(S<) 
cl' a; 

eciio “Running main ddb53 dl c3i dos ...” 
echo “ “ 

maji ddb53 dl c3i dos 
ec»’0 “ “ 

echo -n “Press Return to continue” 
set a=($<) 
cU u 


et' O “Running main ddb53 dl c3i spare ...” 
mi.in ddb53 dl c3i spare 
eci'o” “ 

ed 0 -n “CONFIGURATION LONG LIST OPERATORS test complete... Press Return to continue” 
se‘ a=(S<) 
cU ar 

echo “Running main ddb53 cdl c3i unix r...” 
rm -f AVgemini/work/dwyer/caps/proio^ 
echo “ “ 

main ddb53 cdl c3i unix r 
echo “ “ 

echo -n “Examine the directory now and you’ll sec the checked out subtree ...” 

set a=($<) 

clear 


f).S 





echo “Running main ddbS3 cdt c3i unix w ...Dumping Tree” 
rm -f A>/gemini/work/dwyer/caps/proto/* 
echo “ “ 

main ddbS3 cdt c3i unix w 
echo** ** 

echo -n **Examine the directory now and you’ll see the checked out subtree ...” 

seta=($<) 

clear 


echo **Running main ddb53 crl c3i unix .. Jiesetting Locks” 
main ddbS3 cri c3i unix 

echo **Running main ddb53 cdt c3i dos r ...Dumping Tree” 
rm -f Ai/gemini/work/dwyer/caps/proto/* 
echo ** ** 

main ddbS3 cdt c3i dos r 
echo ** ** 

echo -n **Examine the directory now and you’ll see the checked out subtree ...” 

set a=(S<) 

clear 


echo “Running main ddb53 cdt c3i spare w ...Dumping Tree” 
rm -f At/gemini/work/dwyer/caps/prolo/* 
echo ** ** 

main ddbS3 cdt c3i spare w 
echo ** ** 
echo ** ** 

echo “Examine the directory now and you’ll sec the checked out subtree ...” 

echo -n “Press return to continue ** 

seta=($<) 

clear 

###«############################################# 

# 

#VERSIONING STARTS HERE ... 

# 

################################################# 

echo “Running main ddbS3 crl c3i unix ...Resetting Locks” 
main ddbS3 cri c3i spare 

echo “Running main ddb53 cdt c3i unix w ...Dumping Tree for UPDATE” 

rm -f Ai/gemini/work/dwycr/caps/proto/* 

main ddb53 cdt c3i unix w 

echo ** “ 

echo ** “ 

echo “ ** 

echo -n ’‘CONFIGURATION DUMP TREE lest complete ... Press Return to continue” 

set a=($<) 

clear 

echo “Simulating updates by TOUCHING files “ 
echo " ** 

echo “ Running touch c3i.ps ...” 

touch /n/gemini/work/dwyer/caps/proto/c3i.ps 

echo ** ** 

echo " Running touch c3i.userjntcrface.imp.psdi...” 
echo “ ** 

touch Ai/gemini/work/dwyer/caps/proto/c3i.uscr_intcrfacc.imp.psdl 


66 






ccho“ “ 

echo" Running touch c3i.user_interface.message_arrival_panel.spec.psdl...” 

touch /n/gemini/work/dwyer/caps/proio/c3i.user_interface.inessage_aiTival_panel.spec.psdl 

echo" “ 

echo" Running touch c3i.uscr_interface_emergency_status_screen.imp.psdl...” 

touch /n/gemini/work/dwyer/caps/proto/c3i.user_interface.emergency_status_screen.imp.psdl 

echo" “ 

echo" “ 

echo"" 

echo “We have just simulated editing several op^tors....” 
echo -n “Press Return to continue” 
set a=($<) 
clear 

echo “Running a CONFIGURATION update now (Posting version #2 of c3i)...” 
echo “ “ 

echo “Running main ddbS3 caa c3i unix ...” 
echo" “ 

main ddbS3 caa c3i unix 
echo “ “ 
echo “ “ 
echo “ “ 

rm -f At/gemini/work/dwyer/caps/proto/* 

echo -n “CONFIGURATION UPDATE TREE test complete ... Press Return to continue” 

set a=($<) 

clear 

echo “ “ 
echo “ “ 
echo “ “ 

echo “Show the versions of the root vobject...” 
echo “Running ddb53 vgv c3i c3i...” 
echo" “ 

main ddb53 vgv c3i c3i 
echo “ “ 
echo “ “ 

echo “Show the versions of the user_interface vobject...” 
echo “ “ 

echo “Running ddb53 vgv c3i c3i.user_interface ...” 
echo “ “ 

main ddb53 vgv c3i c3i.user_inierface 
echo" “ 

echo “Show the versions of the cmergency_stauis_screen vobject...” 
echo “ “ 

echo “Running ddb53 vgv c3i c3i.uscr_intcrface.emergcncy_suius_scrccn ...” 
echo " “ 

main ddb53 vgv c3i c3i.uscr_inierfacc.emcrgcncy_slatus_screen 
echo" " 
echo " " 

echo “Show the version of an OPERATOR which DID NOT version ...” 
echo “ “ 

echo “Running ddb53 vgv c3i c3i.comms_interface ...” 
echo “ “ 

main ddb53 vgv c3i c3i.comms_interface 
echo -n “Press Return to continue” 
set a=(S<) 
clear 

echo “ “ 
echo “ “ 

echo “Running main ddb53 vdt c3i c3i w “ 


67 





echo “ “ 

main ddbS3 vdt c3i c3i w 
echo “Now updating modules...” 
echo “ “ 

echo “ Running touch c3i.ps...” 

touch A)/gemini/work/dwyer/caps/proto/c3i.ps 

echo"" 

echo “ Running touch c3i.user_interface.imp.psdl...” 
echo “ “ 

touch/n/gemini/work/dwyer/caps/proto/c3i.user_interface.imp.psdl 
echo “ “ 

echo “ Running touch c3i.user_interface.message_arrival_panel.spec.psdl...” 

touch Ai/gemini/work/dwyer/caps/proto/c3i.user_interface.message_aiTival_panel.spec.psdl 

echo “ “ 

echo “ Running touch c3i.user_interface_emergency_status_screen.imp.psdl...” 

touch /n/gemini/work/dwyer/caps/proto/c3i.user_interface.emergency_status_screen.imp.psdl 

echo “ “ 

echo “ “ 

echo “ “ 

echo “We have just simulated editing several operators....” 
echo “ “ 
echo “ “ 

echo “Now Posting Version 3 to the database ...” 
echo “ “ 
echo “ “ 

echo “Running main ddb53 vaa c3i c3i “ 
echo “ “ 

main ddbS3 vaa c3i c3i 

echo -n “Press Return to continue “ 

rm -f At/gemini/work/dwyer/caps/proto/* 

set a=(S<) 

clear 

echo “ “ 
echo “ “ 

echo “Now check the versions of c3i in the database “ 
echo “ “ 
echo “ “ 

echo “Running main ddb53 vgv c3i c3i...” 
echo “ “ 

main ddb53 vgv c3i c3i 
echo “ " 
echo “ “ 

echo “Show the versions of the user_inierface vobjeci...” 
echo “ “ 

echo “Running ddb53 vgv c3i c3i.uscr_inicrfacc ...” 
echo “ “ 

main ddb53 vgv c3i c3i.uscr_intcrface 
echo “ “ 

echo “Show the versions of the emergency_status_scrccn vobject...” 
echo “ “ 

echo “Rurming ddb53 vgv c3i c3i.user_interface.emcrgency_slatus_screen ...” 
echo “ “ 

main ddb53 vgv c3i c3i.user_interfacc.emergency_stalus_screen 
echo “ “ 
echo " “ 

echo “Show the version of an OPERATOR which DID NOT version ...” 
echo “ “ 

echo “Running ddb53 vgv c3i c3i.comms_intcrfacc ...” 


68 




echo" “ 

main ddbS3 vgv c3i c3i.comms_interface 

echo -n “Show Versions (VGV) test complete.. J*iess Return to continue” 

seta=($<) 

clear 

echo “Running main ddbS3 vud c3i c3i.user_interface file3 ...” 
echo” “ 

main ddbS3 vud c3i c3i.user_interface rile3 
echo” “ 
echo" " 

echo “Here is the description entered to that operator...” 
echo” “ 

echo “Running main ddbS3 vgd c3i c3i.userjnterfacc...” 
echo “ “ 

main ddbS3 vgd c3i c3i.user_interface 
echo” “ 
echo “ “ 

echo -n “Press Return to continue...” 

set a=($<) 

clear 

echo “Now let’s update an OLDER version of an operator previously stored ...” 
echo “Running main ddb53 vud c3i c3i.user_interface file4 1 ...” 
echo “ “ 

main ddb53 vud c3i c3i.user_interface file4 1 
echo” “ 
echo “ “ 

echo “Here is the description entered to that operator...” 
echo” “ 

echo “Running main ddb53 vgd c3i c3i.user_interface 1 ...” 
echo “ “ 

main ddb53 vgd c3i c3i.user_interface 1 
echo “ “ 
echo “ “ 

echo -n "UPDATE VOBJECT/OPERATOR (VUD) test complete... Press Return to continue ...” 

set a=(S<) 

clear 

echo “Now attach the configurations to different versions of RCK)T VOBJECT ...” 
echo “Running main ddbS3 cao c3i unix c3i 1 “ 
echo “ “ 

main ddb53 cao c3i unix c3i 1 

echo “Running main ddb53 cao c3i dos c3i 2 “ 

echo” “ 

main ddb53 cao c3i dos c3i 2 

echo “Running main ddb53 cao c3i spare c3i 3 “ 

echo “ “ 

main ddb53 cao c3i spare c3i 3 
echo -n “Press Return to continue “ 
set a=($<) 
clear 

echo “One Last list to verify everyihings in order ...” 
echo “ “ 

echo “Press Return to continue ...” 

set a=($<) 

clear 

echo “Running main ddb53 do c3i unix” 
echo “ “ 


69 



main ddbS3 do c3i unix 

echo -n "Press Return to continue ...” 

seta=($<) 

clear 

echo "Running main ddb53 do c3i dos” 
echo" " 

main ddbS3 do c3i dos 

echo -n “Press Return to continue ...” 

set a=($<) 

dear 

echo “Running main ddbS3 do c3i spare” 
echo “ “ 

main ddbS3 do c3i spare 

echo -n “Press Return to continue ...” 

set a=($<) 

dear 

echo “ “ 

echo" “ 

“*****»•*•**••*•»*»*«*•»«*»»«»*»**»»*»»» 

echo “*NAVALPOSTGRADUATESCHOOL*” 

echo “ * (T H E E N D) *” 

echo “ * Software Engineering *” 

echo “ • Design Database *” 

echo “ • Thesis Advisor Dr. Luqi 

echo “ * By Drew Dwyer and Garry Lewis 

echo" * Design Database vl.l WP.D.A.L.G *” 

^^0 •«*•*•*****«»«]»»««««****««**««««« 


70 






C. TEST RESULTS 


echo "‘NAVAL POSTGRADUATESCHOOL*” 

echo “ * Software Engineering •" 

echo “ * £)esi^ Eiatabase •” 

echo “ * Thesis Advisor Dr. Luqi 

echo “ * Written by: Drew I>wyer and Garry Lewis 

echo “ • Design Database vl.l WP.D.A.L.G . •” 


Press Return to begin demonstration 
Running main ddb53 pip c3i... 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Running main ddb53 pip fishfarm ‘Drew Dwyer’... 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Running main ddb53 pip robot ‘Garry W. Lewis’ filel ... 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


71 




INSERT PROTOTYPE test complete ... Press Return to continue 


Running main ddb53 pgd robot ...reuims description to screen... 


*****»»*******»*»**4i***«**4i**** «***»••****»*»» 
••****•«***•**»**•********»•*»**••••»****•*»»» 


################### 

###### 

###### 

UUUUU U U U 

f» »» FT r¥ rw fT fT ff fFTI fl W rr 
##### 

##### 

# ### m^mm mmn 


This is a simple text file 

to lest Drew and Garr)'’s Prototype Program. 


******* *****••»* 
********************************************** 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Running main ddb53 pud robot filc2 ...updates description ... 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Running main ddb53 pgd robot ...returns the new description. 


********************************************** 
********************************************** 


####### ### # #####11# ##### 
###### 

##### 

##### # # ##### ##### 

#### # 

##### 

# ### ####### ####### ####### 


This file is used lo update the 
DESCRIPTION ATTRIBUTE 
in the Design Database. 

«< FILE UPDATED SUCCESSFULLY »» 


72 





CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

GETAJPDATE PROTOTYPE DESCRIPTION test complete ... Press Return lo continue 
Running main ddb53 prd c3i 
Tue Sep 3 11:05:42 1991 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

RETRIEVE PROTOTYPE DATE test complete ... Press Return to continue 
Running main ddb53 pul robot Larry Williamson ... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Running main ddb53 pgl robot 
Larry Williamson 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

UPDATE/GET PROTOTYPE test complete ... Press Return to continue 
Running main ddb53 pds c3i.... 

Creation Date: Tue Sep 3 11:05:42 1991 
Leader: 

Default Config: 

<No configurations are contained in this protoiypc.> 

Prototype Description follows: 

<This prototype does not contain a descripuon> 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 
Running main ddb53 pds fi.shfami ... 


73 






Creation Dale: Tue Sep 3 11:05:47 1991 

Leader: Drew Dwyer 
E>efaiilt Config: 

<No configurations are contained in this prototypes 
Prototype Description follows: 

<'Miis prototype does not contain a description> 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Press Return to continue 

Running main ddb53 pds robot... 

Creation Date: Tue Sep 3 11:05:50 1991 

Leader: Larry Williamson 
Default Config: 

<No configurations are contained in this prototype.> 
Prototype Description follows: 




####### ### P ####### ##### 
###### 

#### # 

##### # # ##### ##### 

##### 

##### 

# ### ####### ####### ####### 


This file is used to update the 
DESCRIPTION ATTRIBLTE 
in the Design Database. 

«< FILE UPDATED SUCCESSFULLY »» 

**«**•***«***••*****«*:^**A******************** 
»•»*••**•****»»**•**************************** 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


DUMP PROTOTYPE SUMMARY test complete ... Press Return to continue 


74 







Running niain ddb53 pin ... 
c3i 

fishfarm 

robot 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

LIST PROTOTYPE NAMES test complete ... Press Return to continue 
Running main ddbS3 cic c3i unix ... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Running main ddb53 cic c3i dos ‘Drew Dwyer’... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Running main ddb53 cic c3i spare ‘Garry Lewis’ filel ... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

INSERT CONFIGURATION test complete... Press Return to continue 
Running main ddb53 cum c3i dos ‘Marty Shoppenheimer’ ... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

UPDATE CONFIGURATION MANAGER test complete... Press Return to continue 

Running main ddb53 cds c3i unix ... 

Creation Date: Tue Sep 3 11:08:26 1991 

Manager: 

Version Number- NONE 
Default VOBJECT Name 

<This configuration has not been assigned a V_OBJECT> 

Configuration Description follows: 

<This configuration does not contain a dcscription> 


75 











CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 

Running main ddbS3 cds c3i dos ... 
Creation Date: Tue Sep 3 11:08:28 1991 

Manager Marty Shoppenheimer 
Version Number: NONE 

Default VOBJECT Name 


cThis configuration has not been assigned a V_OBJECT> 
Configuration Description follows: 


<This configuration does not contain a description> 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 

Running main ddb53 cds c3i spare ... 
Creation Date: Tue Sep 3 11:08:31 1991 

Manager: Garry Lewis 
Version Number: NONE 

Default VOBJECT Name 


<This configuration has not been assigned a V_OBJECT> 
Configuration Description follows: 


*****♦«*******««*** «««**««* 

***************** tit ****♦♦♦** *««■«** 4* * 4> «**** 4> 

####### ### # ####### # 

###### 

###### 

####« # # ##### # 

##### 

##### 

# ### ####### ####### ##### 


This is a simple text file 

to test Drew arid Garry’s Prototype Program. 


********************************************** 
******* ***«**«4i**4i************* *************** 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


76 














DUMP CONFIGURATION SUMMARY lesi complete... Press Return to continue 
Running main (ldb53 cgd c3i spare ... 




uuuuuuu uuu u 

nfTfftTfTrTTt ttITtT tT fTrt tf ft ft tfTt ft 
###### 

###### 
trtTft ft FT W It tttTttTTTT ft 
##### 

##### 

# ### ####### ####### «»#### 


This is a simple text file 

to lest Drew and Garry’s Prototype Program. 




CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 

Running main ddb53 cud c3i spare file! ... 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 
Running main ddb53 cgd c3i spare ... 

m^***********************^******************** 

t********************************************* 


nmnum ### # 

###### 

##### 

##### # # ##### ##### 

##### 

##### 

# ### ####### ####«## «###### 


This file is used to update the 
DESCRIPTION ATTRIBUTE 
in 'he Design Database. 


77 




«< FILE UPDATED SUCCESSFULLY »» 

*«*«*•*•***•***««***»**«•»*»*•**•*»•»•«*»»»*** 

CAf*S Engineering Design Database 1991(c) WP.D.Ai.G 

CONFIGURATION DUMP SUMMARY test complete... Press Return to continue 
Running main ddb53 cda c3i spare ... 

TueSep3 11:08:31 1991 

CAPS Engineering Design Database 1991(c) WP.D.AJ-.G 

GET CONFIGURATION DATE test complete... Press Return to continue 
Running main ddb53 cpl c3i spare ‘This is the first Post to Sparc Log’ 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Now check it to see that it’s posted... 

Running ddb53 cgl c3i spare ... 

Tue Sep 3 11:09:50 1991 
This is the first Post to Sparc Log 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Press Return to continue 
Add another line to the log ... 

Running main ddb53 cpl c3i spare ‘This is the second Post to Sparc Log’ 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Show the results ... 

Running ddb53 cgl c3i spare ... 

Tue Sep 3 11:09.50 1991 


78 






This is the first Post to Sparc Log 

Tue Sep 3 11:09:56 1991 

This is the second Post to Sparc Log 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

POST/GET CONFIGURATION LOG lest complete... Press Return to continue 

Running main ddb53 cgm c3i dos ... 

Marty Shofqxnheimer 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 
Now we’ll change the manager to ‘Kelly Mcdowcll’ 

Running main ddb53 cum c3i dos ‘Kelly Mcdowell’... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Now make sure it posted... 

Running main ddbS3 cgm c3i dos ... 
Kelly Mcdowell 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


GET/UPDATE CONFIGURATION MANAGER test complete... Press Return to continue 

Running main ddb53 cln c3i... 

Unix 

dos 

spare 


CAPS Engineering Design Daia'oa.sc 1991(c) WP.D.A.L.G 


LIST CONFIGURATION NAMES test complete... FTcss Return to continue 

We now move on to the actual loading of the ONTOS Database. 

Running main ddb53 vaa c3i c3i... 

CHECKlN--> c3i 
CHECKIN-> c3i.comms_intcrface 

CHECKIN--> c3i.comins_interfacc.prcpare_pcriodic_repon 


79 



CHECKIN- 

CHECKEN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKDM- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHFCKIN- 

CH :kjn- 

CHl-CKIN- 

CHECKIN- 

CHECKIN- 


> c3 

> c3 

> c3; 

> c3 

> c3i 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3 
■> c3 
■> c3 
■> c3 

> c3 

> c3 

> c3 

> c3 

> c3 

> cl 

> c3 

> c3 

> c3 

> c3 

> c3 


.interface .resol ve_incoin ing_messages 
.inierface.resolve_incoming_messages.decide_for_archiving 
.interface .resolve_incoining_messages.decide_for_relaying 
.interface jesolve_incoming_messages.extract_tracks 
.interface jesolve_incoming_messages.parse_input_file 
.interface jesolve_cutgoing_messages 
.interface jesolve_outgoing_messages.convert_to_text_file 
.interface jesolve_outgoing_messages.forward_for_translation 
.interface jesolve_outgoing_messages.forward_for_transmission 
.interface jresolve_outgoing_messages.make_routing 
.interface.translate.message 
links 


•comms. 

-comms 
.comms 
.comms 
.comms 
.comms 
.comms 
.comms 
.comms 
.comms 
.comms 
.comms^ 

.navigation_system 

.sensar_inter&ce 

.sensor_inierface.analy 2 e_sensor_daia 

.sensar_inierface.norinalize_sensor_information 

.sensor_inierface.prepare_sensor_track 

.sensors 

.track_database_manager 

.track_database_manager.monitor_database 

.track_database_manager.updatc_tracks 

.track_database_manager.update_tracks.add_comms_tracks 

.track_database_manager.update_tracks.add_scnsor_track 

.track_database_manager.update_tracks.add_user_track 

.track_database_manager.update_tracks.delete_the_track 

.track_database_manager.update_tracks.filter_comms_tracks 

.track_database_manager.updaie_tracks.rilter_sensor_tracks 

.track_database_manager.update_tracks.moniior_ownship_posilion 

. track_database_m anager. updaie_trac ks. upda tc_the_track 

.userjnierface 

.user_interface.display_graphic_tracks 

.user_interface.display_tracks 

.user_inierface.emcrgency_status_scrcen 

.user_interface.get_modification_data 

.user_interface.get_user_inpuis 

.user_inierface.inieUigence_report_panel 

.user_inlerface.manage_user_intcrfacc 

.user_inierface.message_arrival 

.uscr_inierface.mcssage_arrival_panel 

.user_interface.message_editor 

.user_interfaceJesoIulion_noucc_panel 

.user_interface.status_scrccn 

. weapons_interfacc 

■weapons^systcms 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Add c3i test complete... Now we’ll add a different Prototype 
called flshfarm. ^ess Return to continue... 

Running main ddb53 vaa fishfarm ftshfarm ... 

CHECKIN -> fishfarm 
CHECKIN--> fishfarm.ControLfeeding 
CHECKIN-> fishfarm.Control_feeding_timcs 
CHECKIN-> fishfarm.Determine_actual_inlct_valvc_seUing 
CHEClCIN-> fishfarm.Determiiie_actual_outlct_valvc_sctling 
CHECKIN-> fishfarm.H20_scnsor 

CHECKIN--> fishfarm.Determinc_dcsircd_inlcl_valvc_scuing_NH3 


80 





CHECKIN--> fishfarm.Determine_{lesired_inlcl_valve_seuing_02 

CHECKIN--> fishfann.Display_system_status 

CHECKIN-> fishfann.Inlet, valve 

CHECKIN-> fishfann JWS.sensor 

CHECKIN—> fishfann.Outlet.valve 

CHECKIN-> fishfann .ffconsole 

CHECKIN-> fishfann.mytime 

CHECKIN-> fishfann.o2 sensor 


CAPS Engineering Design Database 1991(c) WP.D.A1..G 


Add fishfann test complete... Now we’ll add a different Prototype 
called robot. Press Return to continue... 

Running main ddb53 vaa robot robot... 

CHECKIN-> robot 
CHECKIN-> robotAccelerometer 
CHECKIN-> robouCalculate.Position 
CHECKIN-> robotFire.Thrusters 
CHECKIN-> robotGet.Keys 
CHECKIN-> robotUpdate.Acceleration 
CHECKIN-> robotUpdate.Display 
CHECKIN-> robotUpdate.Thrnst.Rcq 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Add robot test complete ... Press return to continue 


Now show the PLL command to reflect that each Prototype has a default version 
Running ddbS3 pll... 

Name: c3i Default Config: spare Version: 1 
Name: fishfarm Default Config: NONE Version: I 
Name: robot Default Config: NONE Version: 1 


CAPS Engineering Design Databa.se 1991(c) WP.D.A.L.G 


LOAD V.OBJECT and SUBTREE test complete... Press Return to continue 

Running main ddb53 vlo c3i c3i... 

Operator: c3i 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 

Operator: c3i.comms_interface.prepare_periodic_report 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator; c3i.comms_interface.resolve_incoming_mcssagcs.deci(le_for_archiving 
Version: 1 

Locktime is; Wed Dec 31 16;(X);00 1969 


81 





Opei^r: c3i.comms_interfacejesolve_incoming_messages.decide_for_relaying 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interfacejesoive_incoming_messages.extract_tracks 
VCTsion: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.comms_interfacejesolve_incoming_messages.parse_input_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.comms_inieifacejesoIve_incoming_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.comms_interfacejesolve_ouigoing_messages.convert_to_text_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolvc_outgoing_messages.forward_for_translalion 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_outgoing_messages.forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interfacejesolve_outgoing_messages.make_routing 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interfacejesolve_outgoing_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^r: c3i.comms_inu:rface.translale_messagc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 196° 

Operator: c3i.comms_interface 
Version: 1 

Locktimc is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_links 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.navigation_system 
Version: 1 

Locktimc is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.sensorJnterface.analyzc_scnsor_dala 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^uor: c3i.sensor_interface.normalize_scnsor_infomiaiion 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


82 





Opei^r: c3i scnsor_interface.prepare_sensor_track 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.sensor_interface 
Vwsion; 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator; c3i.sensors 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.monitor_datal)ase 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.track_daiabase_manager.update_tracks.add_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.track_database_manager.updatc_tracks.add_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r; c3i.track_database_manager.update_tracks.add_user_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r; c3i.track_database_managcr.updatc_tfacks.dclcie_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_managcr.updaie_tracks.filier_comms_iracks 
Version: I 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.fillcr_scnsor_iracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_daiabase_manager.updale_tracks.moniior_ownship_posilion 
Version; 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.updaic_lracks.update_the_track 
Version; 1 

Lockumc is; Wed Dec 31 16:00:00 1969 

Operator: c3i.track_databasc_managcr.updaie_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator: c3i.user_inlerface.display_graphic_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 
Operator; c3i.user_inlerface.display_tracks 


83 




Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.user_inteiface.emergency_status_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.userJnterface.get_modirication_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_inlerface.get_user_inputs 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interface.intelligence_reportj)anel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.manage_user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.message_arrival 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Oper^r: c3i.uscr_interface.message_arrival_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_inierface.message_editor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator; c3i.uscr_interface.resolution_notice_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.userjnlcrface.status_screcn 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.uscr_inu:rfacc 
Version: I 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.weapons_inicrfacc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.wcapons_systems 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press return to continue ... 


84 




Running main ddb53 vU c3i c3i... 

Operator; comms_interface 
Version: 1 

Locktime is: Wed Dec 31 16;(X):(X) 1%9 

Operator: comms_links 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator navigation_system 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: sensor_interface 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator; sensors 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opci^r: track_database_manager 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r; user_inlcrfacc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: weaponsjnierfacc 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator; wcapons_systems 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 199;(c) WP.D.A.L.G 


Press Return to coniince ... 

Running main ddb53 vlo c3i c3i.comms_intcrfacc . 

Operator: c3i.comms_inU:rfacc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator; c3i.comms_inierfacc.prepare_periodic_rcport 
Version: 1 

Locktime is: Wed Dec 3l 16:00:00 1%9 

Operator: c3i.comms_interface.resolve_incoming_messages.accide_for_archiving 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator. c3i.comms_interface.resc.ve_incoming_messages.dccidc_ror_rclaying 


85 




Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i,cotnms_inlerface.resolve_incoming_inessages.extraci_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.comms_interfacejesolve_incoming_messages.parse_input_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.comms_interface.resolve_incoming_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 196<5 

Operator: c3i.comms_interfacej'esolve_oulgoing_messages.conven_lo_lext_filc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_inierfacc.rcsolve_outgoing_mcssagcs.forward_for_translalion 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_outgoing_mcssagcs.forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 3’ 16:00:00 1969 

Operator: c3i.comms_intcrface.rcso’vc_outgoing_mcssagcs.make_rouling 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_inicrface.resolve_outgoing_mcssagcs 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.comms_inlerface.translaic_mcssagc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to conunue 

Running main ddb53 vll c3i c3i.comms_inicrfacc ... 

Operator: prcpare_periodic_report 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator resolve_incoming_messagcs 
Version: 1 

Locktime is: Wed Dec 31 16:00:(X) 1969 

Oper^r rcsolvc_outgoir.g_mcssagcs 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 
Operator: translate_message 


86 





Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991 (c) WP.D.A.L.G 


V_OBJECT LIST/LONG LIST OPERATORS test complete... Press Return to continue 

Running main ddbS3 vk) c3i c3i.comms_interface.resolve_outgoing_messages ... 

Operator: c3i.comms_interfacejesolve_outgoing_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interfacej’esolve_outgoing_messages.convert_to_text_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_outgoing_messagcs.forward_for_translation 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_outgoing_messages.forward_for_n‘ansmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_oulgoing_messages.make_rouling 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue ... 

Running main ddb53 vU c3i c3i.commsJnterface.resolve_outgoing_mcssages ... 

Operator: convert_to_texl_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: forward_for_translalion 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: make_routing 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


87 




V.OBJECT LIST/LONG LIST OPERATORS test complete... Press Return to continue 
Running main ddb53 CAO c3i unix c3i... 

CAPS Engiiieering Eiesign Database 1991(c) WP-D.Ai.G 

Running main ddbS3 cao c3i dos c3i.user_interface 

CAPS Engineering Design Database 1991(c) >\T.D.A.L.G 

Running main ddb53 cao c3i spare c3i.comms_inlcrface.resolve_outgoing_messages 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


ATTACH OPERATORS to a CONHGURATlON test complete... Press Return to continue 

Running main ddb53 do c3i unix ... 

Operator: c3i 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 l%9 

Operator: c3i.comms_interface.prepare_periodic_report 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_inierfacejesolve_incoming_messagcs.decide_for_archiving 

Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_incoming_mcssages.dccide_for_rclaying 

Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_incoming_messages.exUaci_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Oper^r: c3i.comms_inlerface.resolve_incoming_messages.parse_input_filc 
Version: 1 

Locktime is: Wed Dec 31 16:00:(X) 1969 

Operator: c3i .com m.s_interface.resotve_incom ing_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:(K) 1%9 

Operator: c3i.commsJnterfacejesoIve_outgoing_mcssagcs.convcrt_to_lcxt_filc 

Version: 1 


88 





Locktime is: Wed Dec 31 16:00:00 1969 


Opei^r: c3i.comms_interfacejesolve_outgoing_messages.forward_for_translation 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.comms_inteifacej'esolve_outgoing_messages.forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

OperattM^ c3i.comms_interfacejesolve_outgoing_messages.make_routing 
Version: 1 

Locktimc is: Wed Dec 31 16:00:00 1%9 

Oper^r: c3i .commsjnterfacejesolve_outgoing_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.commsJnterface.translate_message 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.commsJnterface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_links 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.navigation_system 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.sensor_interface.analyze_sensor_daia 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.sensor_interface.normalize_sensor_informalion 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.scnsor_interface.prepare_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16;00;00 1969 

Operator: c3i.scnsorJnterface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.sensors 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.track_database_managcr.monitor__database 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.track_database_managcr.up)datc_tracks.add_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


89 






Operaux: c3i.track_database_inanager.update_tracks^dd_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operatw: c3i.track_database_manager.update_iracks.add_user_track 
VCTsion: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operattx". c3i.track_database_manager.updaie_tracks.delete_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.track_database_manager.update_tracks.filter_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.track_database_n[uinager.update_tracks.filier_sensor_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.track_database_manager.updatc_tracks.monitor_ownship_positjon 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.track_database_manager.update_tracks.updaie_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^r: c3i.track_database_manager.update_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opex^r: c3i.track_database_manager 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.user_interface.display_graphic_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.userjnterface.display_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.userjnterface.emergency_status_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Openttor: c3i.user_inierface.get_modificauon_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interfacc.get_user_inputs 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Openaor; c3i.user_interface.intelligence_report_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


90 




Operator: c3i.user_interface.manage_user_imerface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.message_aiTival 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

OperaUx': c3i.user_interface.message_arrivaljpanel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operalra^ c3i.user_interface.message_editor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interface.resolution_notice_panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.user_imerface.status_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.weapons_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.weapons_systems 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 

Running main ddb33 do c3i dos ... 

Operator: c3i.uscr_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.userjnterface.(lisplay _graphic_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.user_interface.display_tracks 
Version: 1 

Lockiime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interface.emergency_status_scrccn 
Version: 1 

Lockiime is: Wed Dec 31 16:(X):00 1969 


91 




Operator: c3i.userJnterface.get_modificalion_daia 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator • \iiser_interface.get_user_inputs 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^ow: c3i.user_interface.intelligence_report_panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.user_interface.manage_user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.user_interface.message_arrival 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interface.message_arrival_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.user_inlerface.message_edilor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.userJnterface.resolution_noticc_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.user_interface.status_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 

Running main ddb53 do c3i spare ... 

Operator: c3i.comms_interface.resolve_ouigoing_mcssagcs 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 

Oper^r: c3i.comms_interface.resolve_outgoing_messages.convert_to_tcxi_rilc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_ouigoing_mcssagcs.forward_for_translaiion 

Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_outgoing_mcs.sages.forward_for_transmission 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 


92 






Operator: c3i.comms_interface.resolve_outgoing_messages.make_iouiing 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991 (c) WP.D.A.L.G 


CONFIGURATION LIST OPERATOR test complete... Press Return to continue 

Running main ddbS3 cll c3i unix ... 

Opei^r: comms_inierface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: commsjinks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: navigation_system 
Vasion: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: sensor_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: sensors 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: track_database_manager 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: weaponsjnicrface 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1969 

Oper^r: weapons_systems 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 
Running main ddb53 cll c3i dos ... 


93 





Opei^r: display_graphic_tracks 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: display_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Openuor. emergency_status_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator get_modification_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^r get_iiser_inputs 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: intelligence_repon_panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opci^r; manage_user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator; message_arrival 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Oper^r; messagc_arrival.panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator; message_editor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: resolution_notice_pancl 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator; status_screcn 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 

Running main ddb53 cll c3i spare ... 
Operator: convert_to_tcxi_rile 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 


94 





Operator: forward_for_translation 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operakv: make.routing 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 199i(c) WP.D.A1..G 


CONFIGURATION LONG LIST OPERATORS test complete... Press Return to continue 

Running main ddb53 cdt c3i unix r ... 

NODENAME —> c3i 
Version: I 

NODENAME —> prepare_periodic_report 
Version: 1 

NODENAME —> decide_for_archiving 
Version: 1 

NODENAME —> decide_for_relaying 
Version: 1 

NODENAME —> extract_tracks 
Version: 1 

NODENAME —> parse_input_file 
Version: 1 

NODENAME —> resolve_incoming_messagcs 
Version: 1 

NODENAME —> convert_to_tcxt_filc 
Version: 1 

NODENAME --> forward_for_translation 
Version: 1 

NODENAME —> forward_for_transmission 
Version: 1 

NODENAME —> make_routing 
Version: 1 

NODENAME —> resolve_outgoing_mcssagc.s 
Version: 1 

NODENAME —> translate_message 
Version: 1 


95 



NODENAME —> comms_interface 
Version: 1 

NODENAME —> commsjinks 
Version: 1 

NODENAME —> navigation_system 
Version: 1 

NODENAME —> analyze_sensor_data 
Version: 1 

NODENAME —> nonnalize_sensor_infonnation 
Version: 1 

NODENAME —> prepare_sensor_track 
Version: 1 

NODENAME —> sensor_interface 
Version: 1 

NODENAME —> sensors 
Version: 1 

NODENAME —> moniior_database 
Version: 1 

NOOENAME —> a(ld_comms_tracks 
Version: 1 

NODENAME —> a(kl_sensor_track 
Version: 1 

NODENAME —> add_user_txack 
Version: 1 

NODENAME —> delete_the_track 
Version: 1 

NODENAME —> rilter_comms_tracks 
Version: 1 

NODENAME —> fiIter_sensor_tracks 
Version: 1 

NODENAME —> monitor_ownship_position 
Version: 1 

NODENAME —> update_the_track 
Version: 1 

NODENAME —> update_tiacks 
Version: 1 

NODENAME —> track_(latabase_inanagcr 
Version: 1 

NODENAME —> display _graphic_tracks 
Version: 1 

NODENAME —> display_tracks 


96 



VCTsion: 1 


NODENAME —> emergency_slalus_screen 
Version; 1 

NODENAME —> get_modificaUon_daia 
Version: 1 

NODENAME —> gei_user_inputs 
Version: 1 

NODENAME —> imeUigence_report_panel 
Version: 1 

NODENAME —> manage_user_interface 
VCTsion; I 

NODENAME —> message_amvai 
Version: 1 

NODENAME —> message_arrival_pancl 
Version: 1 

NODENAME —> message_edilor 
Version: 1 

NODENAME —> resoIuuon_notice_pancl 
Version; 1 

NODENAME —> stalus_screen 
Version: 1 

NODENAME —> user_interface 
Version; I 

NODENAME —> weapons_interface 
Version: 1 

NODENAME —> weapons_systems 
Version: 1 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Examine the directory now and you’ll see the checked out subtree ... 

Running main ddb53 cdt c3i unix w ...Dumping Tree 

NODENAME -> c3i 
Version: 1 

setworker --> to dwyer 

NODENAME --> prepare_periodic_report 

Version; 1 

setworker -> to dwyer 
NODENAME --> decidc_for_an:hiving 
Version; 1 


97 




setworker --> to dwyer 
NODENAME —> decide_for_relaying 
Version: 1 

setworker -> to dwyer 
NODENAME —> exlract_tracks 
VCTsion: 1 

setworker -> to dwyer 
NODENAME —> parse_input_file 
Version: 1 

setworker --> to dwyer 

NODENAME —> rcsolve_incoming_messages 
Version: 1 

setworker —> to dwyer 
NODENAME —> convert_lo_text_file 
Version: 1 

setworker -> to dwyer 

NODENAME --> forward_f'jr_translation 

Ve*'sion: 1 

setworker —> to dwyer 

NODENAME —> forward_for_transmission 

Version: 1 

setworker -> to dwyer 
NODENAME —> make_rouling 
Version: 1 

setworker --> to dwyer 

NODENAME —> resolve_ouigoing_messages 
Version: 1 

setworker --> to dwyer 
NODENAME —> translale_message 
Version: 1 

setworker --> to dwyer 
NODENAME —> ?omms_interface 
Version: 1 

setworker —> to dwyer 
NODENAME —> comms_links 
Version: 1 

setworker --> to dwyer 
NODENAME —> navigauon_system 
Version: 1 

setworker -> to dwyer 
NODENAME —> anaIyze_sensor_data 
Version: 1 

setworker -> to dwyer 

NODENAME —> normalize_sensor_informalion 
Version: 1 


98 







setworker -> to dwyer 
NODENAME —> prepare_sensor_track 
Version: 1 

setworker -> to dwyer 
NODENAME —> sensor_inlerface 
Version: 1 

setwoilrer -> to dwyer 
NODENAME —> sensors 
Version: 1 

setworker -> to dwyer 
NODENAME —> moniior_database 
Version: 1 

setworker -> to dwyer 
NODENAME —> add_conims_tracks 
Version: 1 

setworker —> to dwyer 
NODENAME —> add_sensor_track 
Version: 1 

setworker -> to dwyer 
NODENAME —> add_user_track 
Version: 1 

setworker —> to dwyer 
NODENAME —> deteie_lhe_lrack 
Version: 1 

setworker --> to dwyer 
NODENAME —> rilter_comms_tracks 
Version: 1 

setworker --> to dwyer 
NODENAME —> filter_scnsor_tracks 
Version: 1 

setworker -> to dwyer 

NODENAME —> nionitor_ownship_posilion 
Version: 1 

setworker -> to dwyer 
NODENAME —> update_lhe_track 
Version: 1 

setworker —> to dwyer 
NODENAME —> update_tracks 
Version: 1 

setworker -> to dwyer 

NODENAME —> tiack_database_managcr 

Version: 1 

setworker -> to dwyer 

NODENAME —> display_graphic_tracks 

Version: 1 

setworker --> to dwyer 


99 






NODENAME —> display_tracks 
Version: 1 

setworicer —> to dwyer 

NODENAME —> emergency_staius_screcn 

Version: 1 

setworker -> to dwyer 
NODENAME —> gel_modification_daia 
Version: 1 

setworker -> to dwyer 
NODENAME —> get_user_inputs 
Version: 1 

setworker -> to dwyer 

NODENAME —> inteUigence_report_pancl 

Version: 1 

setworker -> to dwyer 

NODENAME —> managc_user_inlcrfacc 

Version: 1 

setworker -> to dwyer 
NODENAME —> message_arrival 
Version: 1 

setworker —> to dwyer 
NODENAME —> message_arrival_pancl 
Version: 1 

setworker -> to dwyer 
NODENAME —> message_editor 
Version: 1 

setworker -> to dwyer 

NODENAME —> resoluuon_notice_pancl 

Version: 1 

setworker —> to dwyer 
NODENAME —> stalus_screcn 
Version: 1 

setworker -> to dwyer 
NODENAME —> user_inicrface 
Version: 1 

setworker -> to dwyer 
NODENAME —> weapons_interface 
Version: 1 

setworker —> to dwyer 
NODENAME —> weapons_syslems 
Version: 1 

setworker -> to dwyer 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


100 





Running main ddb53 crl c3i unix ...Resetting Locks 


CAPS Engineering Design Database 1991 (c) WP.D. A.L.G 


Examine the directory now and you’ll see the checked out subtree . 

Running main ddb53 cdt c3i dos r ...Dumping Tree 

NODENAME —> user_inierfacc 
Version: 1 

NODENAME —> display_graphic_tracks 
Version: 1 

NODENAME —> display_tracks 
Version: 1 

NODENAME —> cmergcncy_status_.scrccn 
Version: 1 

NODENAME —> gct_modification_da[a 
Version: 1 

NODENAME —> get_user_inputs 
Version: 1 

NODENAME —> intelligence_report_pancl 
Version: 1 

NODENAME —> manage_user_interface 
Version: 1 

NODENAME —> message_arrival 
Version: 1 

NODENAME —> message_arrival_pancl 
Version: 1 

NODENAME —> mcssagc_editor 
Version: 1 

NODENAME —> resolution_notice_pancl 
Version: 1 

NODENAME —> statu.s_screcn 
Version: 1 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Examine the directory now and you’ll .sec the checked out subtree 
Running main ddb53 cdt c3i spare w ...Dumping Tree 
NODENAME —> resolve_outgoing_mcs.sagcs 


101 



Version: 1 


setworker -> to dwyer 
NODENAME —> convert_to_text_file 
Version: 1 

setworker -> to dwyer 

NODENAME —> forward_for_translation 

Version: 1 

setworker -> to dwyer 

NODENAME —> forward_for_transmission 

Version: 1 

setworker -> to dwyer 
NODENAME —> make_routing 
Version: 1 

setworker —> to dwyer 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Running main ddb53 crl c3i unix ...Resetting Locks 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Examine the directory now and you’ll see the checked out subtree ... 
Press return to continue 

Running main ddb53 cdt c3i unix w ...Dumping Tree for UPDATE 
NODENAME —> c3i 
Version: 1 

setworker --> to dwyer 

NODENAME —> prepare_periodic_report 

Version: 1 

setworker -> to dwyer 
NODENAME —> decide_for_archiving 
Version: 1 

setworker -> to dwyer 
NODENAME —> decide_for_relaying 
Version: 1 

setworker -> to dwyer 
NODENAME —> extract_tracks 
Version: 1 

setworker --> to dwyer 
NODENAME —> parse_input_file 
Version: 1 

setworker —> to dwyer 

NODENAME —> resoIve__incoming_me.s'.agcs 


102 





Version; 1 


setworker -> to dwyer 
NODENAME —> conven_to_text_file 
Version: 1 

setworker -> to dwyer 

NODENAME —> forward_for_translaUon 

Version: 1 

setworker -> to dwyer 

NODENAME —> forward_for_ transmission 

Version; 1 

setwotker --> to dwyer 
NODENAME —> make_routing 
Version: 1 

setworker -> to dwyer 

NODENAME —> resolve_outgoing_messages 
Version; 1 

setworker -> to dwyer 
NODENAME —> translate^message 
Version; 1 

setworker -> to dwyer 
NODENAME —> comms^interfacc 
Version: 1 

setworker -> to dwyer 
NODENAME —> comms^links 
Version: 1 

setworker -> to dwyer 
NODENAME —> navigauon_syslcm 
Version: 1 

setworker -> to dwyer 
NODENAME —> analyEe_sensor_data 
Version: 1 

setworker -> to dwyer 

NODENAME —> normalizc_scnsor_informauon 
Version: 1 

setworker -> to dwyer 
NODENAME —> prcparc_sensor_irack 
Version; I 

setworker -> to dwyer 
NODENAME —> sensor_intcrfacc 
Version: 1 

setworker -> to dwyer 
NODENAME —> sensors 
Version; 1 

setworker -> to dwyer 
NODENAME —> monilor_databa.se 
Version; 1 


103 




setworker --> lo dwyer 
NODENAME —> add_comms_tracks 
Version: I 

setworker -> to dwyer 
NODENAME —> add_sensor_track 
Version; 1 

setworker —> to dwyer 
NODENAME —> add_user_track 
Version: I 

setworker —> to dwyer 
NODENAME —> deleie_the_track 
Version: 1 

setworker -> to dwyer 
NODENAME —> fiiller_comms_tracks 
Version: 1 

setworker -> to dwyer 
NODENAME —> filicr_sensor_lracks 
Version: 1 

setworker -> to dwyer 

NODENAME —> monitor_ownship_posilion 
Version: 1 

setworker --> to dwyer 
NODENAME —> update_thc_track 
Version; I 

setworker --> to dwyer 
NODENAME —> update_tracks 
Version; 1 

setworker --> to dwyer 

NODENAME —> track_database_managcr 

Version; 1 

setworker -> to dwyer 

NODENAME —> display_graphic_tracks 

Version: 1 

setworker —> to dwyer 
NODENAME —> display_tracks 
Version: 1 

setworker -> to dwyer 

NODENAMH —> emergency_status_scrccn 

Version: 1 

setworker --> to dwyer 
NODENAME —> get_modiricalion_(lata 
Version; 1 

setworker -> to dwyer 
NODENAME —> get_uscr_inpuls 
Version: 1 



setworker -> to dwyer 

NODENAME —> inteIligence_report_panel 

Version: 1 

setworker -> to dwyer 

NODENAME —> ntanage_user_interface 

Version: 1 

setwoiicer -> to dwyer 
NODENAME —> message.airival 
Version: 1 

setworker -> to dwyw 
NODENAME —> niessage_arrival_panel 
VCTSion: 1 

setworker -> to dwyer 
NODENAME —> message_editor 
Version: 1 

setworker -> to dwyer 

NODENAME —> resolution_notice_pancl 

Version: 1 

setworker --> to dwyer 
NODENAME —> status_screen 
Version: 1 

setworker --> to dwyer 
NODENAME —> user_inicrface 
Version: 1 

setworker --> to dwyer 
NODENAME —> weapons_interface 
Version: 1 

setworker --> to dwyer 
NODENAME —> weapons_syslcms 
Version: 1 

setworker to dwyer 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


CONFIGURATION DUMP TREE lest complete ... Press Return to continue 
Simulating updates by TOUCHING files 
Running touch c3i.ps... 

Running touch c3i.uscr_interface.imp.psdl... 

Running touch c3i.uscr_intcrface.mcssagc_arrival_pancl.spcc.psdl... 
Running touch c3i.uscr_intcrfacc_emcrgency_status_.scrccn.imp.psdl... 


105 





We have just simulated editing several operators.... 
Press Return to continue 


Running a CONFIGURAIION update now (Posting version #2 of c3i)... 
Running main ddbS3 caa c3i unix ... 


CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKDM- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECICIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECION- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKP<1- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKJN- 

CHECKIN 

CHECKIN- 

CHECKJN- 

CHECKIN- 

CHECKEN- 

CHECKIN- 

CHECKIN 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN 

CHECKIN 

CHECKIN 

CHECKIN 

CHECKIN 


> c3 

> c3i 

> c3 

> c3 

> c3 

> c3 

> c3 

> c3: 
■> c3 

> c3 

> c3 

> c3 

> c3 

> c3 
■> c3 
■> c3 
•> c3 
■> c3 
■> c3 
-> c3 

> c3 
-> c3 
-> c3 

> c3 

> c3 
-> c3 

> c3 

> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 

> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 
-> c3 


.interface 

.interface.prepare_periodic_report 
.interface jesolve_incoming_messages 
.interfacejesolve_incoming_messages.decide_for_archiving 
.interface jesolve_incoming_messages.decide_for_relaying 
.interface jesolve_incoming_messages.extract_tracks 
.interface jesolveJncoming_mcssages.parse_input_file 
_interface.resolve_outgoing_messages 
.interface.resolve_outgoing_mcssages.convert_to_text_file 
.interface.resolve_outgoing_messages.forw'ard_for_iranslalion 
.interface j'esolvc_outgoing_mcssagcs.forward_for_transmission 
.interface.resolve_oulgoing_messagcs.makc_routing 
.interface.translate_message 
links 


comms. 
comms 
comms. 
comms 
comms 
comms 
comms. 
comms. 
comms. 
comms. 
comms. 
comms 
comms 
.comms 
.navigation_system 
.sensor_interface 

.sensor_interfaceanalyze_sensor_data 
.sensor_interface.normalize_sensor_informalion 
.sensor_interface .prepare_sensor_track 
.sensors 

.track_database_manager 

.track_database_manager.monitor_daiabasc 

.track_database_manager.update_iracks 

.track_database_manager.update_uacks.add_comms_u-acks 

.track_database_manager.update_tracks.add_sensor_track 

.track_database_manager.update_U‘acks.add_uscr_track 

.track_database_manager.update_tracks.delete_ihe_lrack 

.track_database_manager.updatc_tracks.filicr_comms_iracks 

.track_database_managcr.updatc_tracks,riltcr_scnsor_tracks 

.track_database_managcr.update_tracks.moniior_ownship_posilion 

.track_database_managcr.updatc_tracks.updaic_llie_track 

.user_interface 

.user_interface.display _graphic_tracks 

.user_interfacc.display_tracks 

.user_interface.emergcncy_status. screen 

.user_intcrface .gct_modi fication_daLa 

.user_interface.get_uscr_inputs 

.userJntcrface.intclligencc_rcporl_pancl 

.user_interface.managc_user_intcrfacc 

.user_interface.message_arrival 

.user_interface.message_arrival jjanel 

.user_interface.message_editor 

.user_interfacejesolution_noticc_pancl 

.user_interfacc.staujs_scrccn 

.weapons_interface 

.weapons_systems 


CAPS Engineering Design Database 1991(c) WP.D A.L.G 


106 






CONFIGURATION UPDATE TREE test complete... Press Return to continue 


Show the versions the root vobject... 

Running ddb53 vgv c3i c3i... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 

2 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Show the versions of the uscrjntcrface vobject... 

Running ddb53 vgv c3i c3i.user_intcrfacc ... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 

2 



CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Show the versions of the emergency_stalus_scrcen vobject... 

Running ddb53 vgv c3i c3i.user_intcrface.emcrgcncy_staius_screen ... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 

2 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Show the version of an OPERATOR which DID NOT version ... 
Running ddb53 vgv c3i c3i.comms_interface ... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 


107 






CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 


Running main ddbS3 vdt c3i c3i w 

NODENAME --> c3i 
Version: 2 

setwwker -> to dwyer 

NODENAME —> prepate_periodic_report 

Version: 1 

setworker -> to dwyer 
NODENAME —> decide_for_archiving 
Version: 1 

setworker to dwyer 
NODENAME —> dccidc_for_rclaying 
Version: 1 

setworker -> to dwyer 
NODENAME —> extract_tracks 
Version: 1 

setworker to dwyer 
NODENAME —> parse_input_rile 
Version: 1 

setworker --> to dwyer 

NODENAME —> resolve_incoming_messagcs 
Version: 1 

setworker to dwyer 
NODENAME —> convert_to_text_rile 
Version: 1 

setworker to dwyer 

NODENAME —> forward_for_transIauon 

Version: 1 

setworker —> to dwyer 

NODENAME —> forward_for_transmission 

Version: 1 

setworker --> to dwyer 
NODENAME —> make_routing 
Version: 1 

setworker -> to dwyer 

NODENAME —> resolve_outgoing_messages 
Version: 1 

setworker -> to dwyer 
NODENAME —> translate_message 
Version: 1 

setworker —> to dwyer 


108 





NODENAME —> commsjnterface 
Version: 1 

setwoiker -> to dwyer 
NODENAME —> coinins_links 
VCTsion: 1 

setworker -> to dwyer 
NODENAME —> navigation_sysiem 
Version: 1 

setworker -> to dwyer 
NODENAME —> analyze_sensor_data 
Version: 1 

setworko’ --> to dwyer 

NODENAME —> normali 2 e_sensor_information 
Version: 1 

setworker --> to dwyer 
NODENAME —> prcparc_sensor_track 
Version: 1 

setworker -> to dwyer 
NODENAME —> sensor_intcrface 
Version: 1 

setworker --> to dwyer 
NODENAME —> sensors 
Version: 1 


setworker --> to dwyer 
NODENAME —> monitor_databasc 
Version: 1 

setworker --> to dwyer 
NODENAME —> add_comms_tracks 
Version: 1 

setworker -> to dwyer 
NODENAME —> add_sensor_track 
Version: 1 

setworker to dwyer 
NODENAME —> add_uscr_uack 
Version: 1 

setworker —> to dwyer 
NODENAME —> delete_the_track 
Version: 1 

setworker -> to dwyer 
NODENAME —> filter_comms_tracks 
Version: 1 

setworker -> to dwyer 
NODENAME —> filter_sensor_tracks 
Version: 1 

setworker -> to dwyer 


109 







NODENAME —> monitDr_ownship_posilion 
Version; 1 

setworker -> to dwyer 
NODENAME —> updaie_lhe_track 
Vision: 1 

setworker to dwyer 
NODENAME —> update_tracks 
Version; 1 

setworker -> to dwyer 

NODENAME —> track_database_managcr 

Version; 1 

setworker -> to dwyer 

NODENAME —> display_graphic_lracks 

Version; 1 

setworker —> to dwyer 
NODENAME —> display_lracks 
Version; 1 

setworker --> to dwyer 

NODENAME —> emcrgcncy_slatus_scrccn 

Version; 2 

setworker —> to dwyer 
NODENAME —> gel_modirication_dala 
Version; 1 

setworker --> to dwyer 
NODENAME —> get_user_inpuls 
Version; 1 

setworker --> to dwyer 

NODENAME —> inteUigence_report_panel 

Version; 1 

setworker to dwyer 

NODENAME —> tnanage_user_interface 

Version; 1 

setworker —> to dwyer 
NODENAME —> message_arrival 
Version; 1 

setworker -> to dwyer 
NODENAME —> niessage_arrival_panct 
Version; 2 

setworker -> to dwyer 
NODENAME —> message_editor 
Version; 1 

setworker -> to dwyer 

NODENAME —> resolution_notice_panc! 

Version; 1 

setworker -> to dwyer 
NODENAME —> status_screen 


1 







Version; 1 

setworker -> to dwyer 
NODENAME —> user_interface 
Version: 2 

setworker -> to dwyer 
NODENAME —> weapons_interface 
Version: 1 

setworker --> to dwyer 
NODENAME —> weapons_systems 
Version; 1 

setworker --> to dwyer 


CAPS Engineering Design Daubase 1991(c) WP.D.A.L.G 


Now updating modules... 

Running touch c3i.ps... 

Running touch c3i.uscr_interfacc.imp.psdl... 


Running touch c3i.user_interface.mcssage_arrivalj)ancl.spcc.psdl... 
Running touch c3i.uscr_intcrface_emergency_status_screen.imp.psdl... 


We have just simulated editing several operators.... 


Now Posting Version 3 to the database ... 


Running main ddb53 vaa c3i c3i 
CHECKJN-> c3i 

CHECKIN-> c3i.comms_interface 

CHECKIN—> c3i.comms_intcrface.prcparc_pcriodic_rcport 

CHECKIN-> c3i.comms_interfacc.rcsolveJncoming_mcssagcs 

CHECKIN-> c3i.comms_intcrfacc.rcsolve_incoming_mcssagcs.dccidc_for_archiving 

CHECKIN-> c3i.comms_interface.resolve_incoming_mcssagcs.decidc_for_relaying 

CHECKIN-> c3i.comms_interface.resolve_incoming_mcssages.extract_tracks 

CHECKIN-> c3i.comms_interface.resoIve_incoming_mcssages.parseJnput_fiIc 

CHECKlN-> c3i.comms_interface.resolve_outgoing_messagcs 

CHECKIN-> c3i.comms_interface.resolve_oulgoing_messagcs.convcr*_to_tcxt_rilc 

CHECKIN-> c3i.comms_inter''ace.resolve_oulgoing_mcssages.forward_for_translalion 

CHECKIN-> c3i.comms_intcrface.resolve_outgoing_messagcs.forward_for_transmis,sion 

CHECKIN-> c3i.comms_interfacejesolvc_outgoing_mcssagcs.make_rouiing 

CHECKIN-> c3i.comms_interface.translatc_mcssagc 

CHECKIN-> c3i.comms_links 

CHECKIN"> c3i.navigation_system 

CHECKIN-> c3i.sensor_interfacc 

CHECKIN-> c3i.sensor_inlerfaceiinalyze_sensor data 

CHECKIN-> c3i.sensor_interface.normali7e_scnsor_information 

CHECI<lN-> c3i.sensor_interface.prcpare_scnsor_irack 


III 



CHECKJN- 

CHECKIN- 

CHECKIN- 

CHECKIN-- 

CHECKIN- 

CHECKJN- 

CHECKIN- 

CHECKIN- 

CHECKIN-- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN-- 

CHECKIN- 

CHECKIN- 

CHECKIN-- 

CHECKIN- 

CHECK1N-- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN- 

CHECKIN-- 

CHECKIN-- 

CHECKIN- 

CHECKIN- 


•sensors 

.track_database_manager 

.track_daiabase_manager.moniior_database 

.track_database_manager.update_uacks 

.track_daiabase_manager.updaie_tracks^d_comms_tracks 

.track_(latabase_manager.updai£_tracks^d_sensor_track 

i.track_database_inanager.updaie_tracks^dd_i:ser_irack 

. track_dalabase_manager.update_tracks.delete_thc_track 

.track_database_manager.upd^_tracks.filter_comms_tracks 

i.tiack_dalabase_manager.updaie_tracks.filler_sensor_tracks 

i.track_database_manager.updaie_tracks.monitor_ownship_position 

nrack_database_manager.upaaie_uacks.updaie_lhe_track 

i.user_interface 

i.user_interface.display_grapfiic_tracks 

i.user_imerface.display_tracks 

i.UwCr_interface.emergency_stalus_screen 

i.user_imerface.gc5_modificaiion_daia 

i. user_in terface .get_user_inpms 

i.user_interface.inielligence_icport_pancl 

i.user_interface.manage_user_inierface 

i.user_inierface.message_aiTival 

i.user_intcrface.message_arrival_pancl 

i.user_intcrfacc.mcssage_cdiior 

i.user_interface.resoluuon_noiicc_pancl 

i.uscr_imcrface.slatus_screcn 

Lweaponsjnterface 

i. weapons_sy sic ms 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue 


Now check the versions of c3i in the database 
Running main ddb53 vgv c3i c3i... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 

2 

3 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Show the versions of the uscr_inlcrface vobjcct... 

Running ddb53 vgv c3i c3i.userjntcrfare ... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS; 

1 

2 


112 









3 


CAPS Engineering Design Database 1991(c) WP.D.AJ-.G 

Show the versions of the emergency_status_screen vobjeci... 

Running ddb53 vgv c3i c3i.user_interface.einergency_status_screen ... 
THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 

2 

3 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Show the version of an OPERATOR which DID NOT version ... 
Running ddb53 vgv c3i c3i.comms_interface ... 

THIS THREAD CONTAINS THE FOLLOWING VERSIONS: 

1 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Show Versions (VGV) test complete ...Press Return to continue 
Running main ddb53 vud c3i c3i.user_interface rilc3 ... 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Here is the description entered to that operator... 
Running main ddb53 vgd c3i c3i.user_inlerface ... 


********************************************* * 4 >****» 4 >**** 4 '**** 


# # ####### ###### # ####### ##### ####### ##### 
############# 

########### 

# # # # ###### # ##### # # ##### 
############ 


113 



############## 

UUUU4M uuuuuu u MMitUU U MUMMU 

ffnTtTTfTTTtt fftf fTff““ IT IT H HIT TtTtntttTTTTT WTTTTTTtt TT TT h h fr it 

IT TT IT H II 

UjiUU M M U 

fTWTTjT TT TT TT 
#### 

ITWWffTT 
### 

##### 
uuuu uuuuu u 

II II II II II II HIT If TT 


This file is a test file used 
to update the VOBJECT 
DESCRIPTION ATTRIBUTE. 

«« UPDATED SUCCESSFULLY »» 

»«**«»»*4i4ii#*****»***4i»*»*»***»»»4i»»»»»***»*»»»»***4>*»»»***»»»» 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue ... 

Now let’s update an OLDER version of an operator previously stored ... 
Running main ddb53 vud c3i c3i.user_interface file4 1 ... 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Here is the description entered to that operator... 

Running main ddb53 vgd c3i c3i.user_interface 1 ... 

**••*♦•*♦••*•♦•**•*♦•**♦**♦**••*♦***♦♦**•*♦♦*♦•*****♦******* 


# # ####### ###### # ####### ##### ####### # 
############# 

############ 

# # # # ###### # ##### # # # 

############ 

############# 

# ###### ##### nnttnn n ##### # ##### 


IT IT ff If n 
#### # # # 


114 






#### 

####### 

### 

##### 

IJ IJ IJ IJ IJ IJ JJ IJ I1 11 

W fr n rr If rf ff If fl TT 


This file is a test file used 
to update the VOBJECT 
DESCRIPTION ATTRIBUTE. 

«« UPDATED SUCCESSFULLY »» 

************************************************************ 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


UPDATE VOBJECT/OPERATOR (VUD) test complete... Press Return to continue ... 

Now attach the configurations to different versions of ROOT VOBJECT... 

Running main ddb53 cao c3i unix c3i 1 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 
Running main ddb53 cao c3i dos c3i 2 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 
Running main ddb53 cao c3i spare c3i 3 

CAPS Engineering Design Database 1991(c) WP.D.A.L.G 

Press Return to continue 

One Last list to verify everythings in order ... 

Press Return to continue ... 

Running main ddb53 do c3i unix 

Operator: c3i 
Version: 1 

Lockume is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.prepare_periodic_rcport 


115 







Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 




Opei^n c3i.coinms_interfacejesolve_inconiing_messages.decide_for_archiving 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.comms_interfacejesolve_incoming_messages.decide_for_relaying 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opeidlor. c3i.comms_interfacejesolve_incoming_messages.extiact_tiacks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^r: c3i.comms_interfacejesolve_incoming_messages.parseJnput_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interfacejresolve_incoming_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.comms_interfacejesolve_outgoing_messages.convert_to_text_rile 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^r: c3i.comms_interface.resolve_oulgoing_messages.forward_for_translation 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Opei^r: c3i.commsJnterface.resolve_oulgoing_mcssages.forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.commsJnterface.resolve_ouigoing_messages.make_routing 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.comms_inierfacejesolve_outgoing_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.comms_intcrface.translatc_messagc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.commsJnterface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.comms_links 
VCTsion: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 


Operator: c3i.navigation_system 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Oper^r: c3i.sensorJnlerfacc.analyze_sensor_data 
Version: 1 


116 





Locktime is: Wed Dec 31 16:00:00 1969 


Operator c3i.sensor_interface.nonnalize_sensor_infonnation 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.sensor_interface.ptepare_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opemor. c3i.sensor_incerface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.sensors 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.track_database_manager.monitor_database 
VCTsion: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.add_comms_tracks 
Version: 1 • 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.track_database_manager.update_uacks.add_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.add_user_track 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Oper^r: c3i.track_database_manager.update_tracks.delete_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.filter_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.filter_sensor_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opet^r: c3i.track_database_manager.update_tracks.monitor_ownship_posiuon 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.tTack_database_manager.update_tracks.update_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Oper^r: c3i.tr3ck_database_manager.updatc_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_managcr 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


117 





Operator cSi.userJmerface.display _graphic_tracks 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1969 

Opo^utx: c3i.userjnterface.display.tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Openuor c3i.user_interface.emergency_staius_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.user_intBrface.get_modincalion_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.user_interface.get_user_inputs 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_inlerface.intelligence_rcport_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interface.manage_user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.user_interface.message_arrival 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.userjnierface.message_arrivaljpanel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operaior: c3i.user_intcrface.message_editor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.userJnierface.resoIulion_noticc_pancl 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_inierface.status_scrccn 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_inlerface 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.weapons_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.weapons_syslems 
Version: 1 

Locklime is: Wed Dec 31 16:00:00 1969 


118 





CAPS Engineering Design DaUibase 1991(c) WP.D.A.L.G 


Press Return to continue... 

Running main ddbS3 do c3i dos 

Operator c3i 
Version: 2 

Locktime is: Wed Dec 31 16:(X):(X) 1969 

Operator c3i.comms_interface.prepare_periodk:_report 
Version: 1 

Locktime is: Wed Dec 31 16:00:(X) 1%9 

Operator c3i.comms_interfacejesolve_incoming_messages.decide_for_archiving 
Version: 1 

Locktime is: Wed Dec 31 16:(X):(X) 1969 

Operator: c3i.comms_interface.resolve_incoming_mcssages.decide_for_relaying 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Openuor c3i.comms_interface.resolve_incoming_messages.exlracl_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:(X) 1%9 

Operator: c3i.comms_interfacejesolve_incoming_messages.parse_input_filc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interfacejesolve_incoming_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.resolve_outgoing_messages.convert_lo_iext_file 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1%9 

Oper^r: c3i.comms_interface.resolve_ouigoing_messages.forward_for_translaiion 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 

Operator c3i.comms_interface.resolve_oulgoing_messages.forward_for_transmission 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.comms_interfacej'esolve_oulgoing_mcssagcs.make_rouung 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 

Operator c3i .comms_interfacejesolve_outgoing_messagcs 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1%9 

Operator c3i.comms_interface.translate_message 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 


119 





Opei^r: c3i.c(xnms_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.comins_links 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator. c3i.navigation_system 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.sensor_interface.analyze_sensor_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.sensor_interface.normalize_sensor_information 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.sensor_interface.prepare_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.sensor_inierface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.sensors 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.monitor_databasc 

Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.track_database_manager.update_tracks.add_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.track_database_tTianager.update_tracks.add_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


Operator: c3i.track_database_manager.update_tracks.add_user_track 
Version: 1 


120 






Lockiime is: Wed Dec 31 16:00:00 1%9 


Operator c3i .track_datahase_inanager.update_tracks.deleie_the_tiack 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.filler_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.track_database_manager.update_tracks.filier_sensor_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

OperatCM^ c3i.track_database_manager.update_tracks.monitor_ownship_position 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update_tracks.updaie_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.updaie_iracks 
Version: 1 

Lockiime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager 
Version: 1 

Lockiime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.user_interface.display_graphic_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_inierface.display_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.uscr_inlcrface.emergency_slalus_scrccn 
Version: 2 

Lockiime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_inlerface.get_modificaiion_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_inierface.get_uscr_inputs 
Version: 1 

Lockiime is: Wed Dec 31 16:00:00 1969 

Operator c3i.uscrJnicrface.inlclligcncc_rcport_pancl 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_inlerface.manage_user_inlerface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.userjnterface.message_arrival 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


121 






Operator c3i.user_interface.inessage_arrival_panel 
Version: 2 

Locktime is: Wed Dec 31 16:00:00 1969 

Operaux^ c3i.user_interface.message_editor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.iesolution_notice_panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator. c3i.user_interface.status_screen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_inierface 
Version: 2 

Locktime is: Wed Dec 31 16:00:00 1969 

Opei^r: c3i.weapons_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.weapons_systems 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 


Press Return to continue ... 

Running main ddbS3 do c3i spare 

Operator: c3i 
Version: 3 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_interface.prepare_pcriodic_rcport 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.comms_interfacejesolve_incoming_messages.decide_for_archiving 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 

Operator: c3i.comms_interfacejesolve_incoming_messages.decide_for_relaying 
Version: 1 

Locktime is: Wed Dec 31 16:00:(X) 1%9 

Operator: c3i.comms_inierfacejresolvc_incoming_mcssages.extracl_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:(X):00 1969 

Operator: c3i.comms_interfacejesoive_incoming_messages.parseJnput_file 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 


122 





Operator: c3i.comms_interfacejesolve_incoming_messages 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operate^:: c3i.coinms_interfacejesolve_outgoing_inessages.convert_lo_text_file 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.comms_interfacejesolve_outgoing_messages.forward_for_translauon 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.comms_interfacejesolve_outgoing_messages.forward_for_transmission 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Oper^r: c3i.comms_interface.resolve_outgoing_messages.make_iouling 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Oper^r c3i.comms_inlerface.rcsolve_oulgoing messages 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator: c3i.comms_intcrface.translate_niessagc 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator; c3i.commsJnierface 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opoaior: c3i.commsJinks 
Version: 1 

Locktime is; Wed Dec 31 16:00.00 1%9 

Operator: c3i.navigation_system 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.sensorJnterface.analyze_scnsor_data 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator; c3i.sensorJnterface.normalize_scnsor_infonnalion 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1%9 

Operator c3i.sensorJnterface.prepare_sensor_track 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator: c3i.sensor_interface 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.sensors 
Version; 1 

Locktime is: Wed Dec 31 16:00:00 1%9 


123 





Operator: c3i.track_database_inanager.monitOT_database 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.track_database_inanager.update_tTacks.add_comins_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.track_database_manag».update_tTacks^dd_sensor_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

OperaUM: c3i.track_database_manager.update_tracks^dd_user_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Opei^r: c3i.track_database_manager.update_tracks.delete_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator c3i.track_database_manager.update_tracks.filier_comms_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.track_database_manager.update_tracks.rilter_scnsor_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.update„tracks.monitor_ownship_position 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager.updaic..tracks.update_the_track 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Oper^r: c3i.track_database_manager.update_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.track_database_manager 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.userjnterface.display_graphic_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_inierface.display_tracks 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3 i .user_interface.emergency_status_screcn 
Version: 3 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.user_interface.get_modification_data 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 
Operator: c3i.userjnterface.get_uscr_inputs 


124 




Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator c3i.user_interface.intelligence_report_panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Openttor c3i.user_interface.manage_user_interface 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Opwator: c3i.user_inierface.message_arrival 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.message_arrival_panel 
Version: 3 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.message_editor 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1969 

Operator: c3i.user_interface.resolulion_notice_panel 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.uscr_inlerface.status_scrcen 
Version: 1 

Locktime is: Wed Dec 31 16:00:00 1%9 

Operator: c3i.user_interface 
Version; 3 

Lockume is: Wed Dec 31 16:00:00 1%9 

Operator; c3i.weapons_interface 
Version: 1 

Locktime is; Wed Dec 31 16:00:00 1969 

Operator; c3i.weapons_systems 
Version: 1 

Locktime Ls: Wed Dec 31 16:00:00 1969 


CAPS Engineering Design Database 1991(c) WP.D.A.L.G 
Press Return to continue ... 

• *«*»*»*****************»*4i«»*******************»»******»»*****»4i4i»**4' 

echo‘‘*NA V ALPOSTGR ADU ATESCHOOL*” 

echo “ • Software Engineering •” 

echo “ • Design Database •” 

echo “ * Thesis Advisor Dr. Luqi 

echo “ • Written by: Drew Dwyer <ind Garry Lewis •” 

echo “ * Design Database vl.l WP.D.A.L.G . •” 

•*************«*****»***********************»*******************»**4i** 

(7msun53:/n/geminiAvork/dwyer/SCCS»[m exit 
exit 

script done on Tue Sep 3 11:36:13 1991 


125 



APPENDIX D 


CODE 


A. PREPARATION NOTES 

This code was written using Glockenspiel C++ version 2.0a. 

B. PRINTING NOTES 

This code was prepared for printout using the c++2Iatex code generator. This 
generator parses the ASCII text input files and places latex commands where directed. This 
makes the code layout more readable and highlights the important data strucutes and key 
words within the C++ code. The latex output was then c onvert'*d to postscript format with 
the dvitops program. 

C. MAINTENANCE 

This code is maintained at the Naval Postgraduate School Computer Science 
department. 


126 






// File Header -- 

// . 

I!.Filename .; main.cix 

I/.sees ID . : l.S 

//.Release No....: 1 

I/.Date .; 9/16/91 

11 .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .Compiler .; Glockenspiel C4-+ 2.1 

// 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char mairi-SccsIdQ = "C(#)main. exx 1.3\t9/l6/91"; 

// Interface Dependencies -—- 

#ifndei _DDBDEFINES-H 
tinclude "ddbdef ines .h” 

#endil 

#iivclude <Object .h> 

•include <Transaction.h> 

•include <Directory.h> 

•include <GlobalEntities.h> 

•include <Database.h> 

•include <List.h> 

• include <streain.hxx> 

extern "C—" 

{ 

•include <stdlib.h> 

•include <8tddef.h> 

•include <8tring.h> 

•include <ctype.h> 

} 

• ilndeJ _VOBJECTFUNC.n 

• include ’'vobjectfunc.h” 

•endif 

• ifndef _EVALUATION JI 

• include "evaluation.h” 

•endif 

• ifndef _PROTFUNC-n 

• include "protfunc.h” 

• er.dii 


127 















#ilndel -CONFFUNCJi 
#include ’’conllunc .h” 

#endif 

// End Interface Dependencies - 

Type ♦V.OBJECT.OType; 

Type ♦THREAD-OType; 

Type ♦COMPONENT.OType; 

Type ♦TEXT.OBJECT.OType; 

Type ♦PROTOTYPE-OType; 

Type ♦CONFIGURATION.OType; 

Type ♦DDB-OType; 

Directory ♦prototype.dir = (Directory*)0; 
Directory ♦ddbRootDir = (Directory*)0: 
List ♦myPrototypeList = (List*)0; 
char ♦databaseJiame = (char ♦)0; 
char ♦userPtr = (char ♦)0; 
char ♦dirNamePtr = (char ♦)0; 
void initialize.types(void); 
void setUpDirectory(char ♦, char ♦); 

int main(int argc, char ♦argvQ) 

{ 

dirNamePtr = getenv("PROTOTYPE"); 
userPtr = getenv("USER"); 

Boolean done=FALSE; 
int menu-option=0; 
ifstream inFile; 


char ♦function-tag; 

int number-arguments; 
int run = 0; 

if (argv[l]) 

{ 

database-name = new char[strlen(argv[l])+l]; 
strcpy(database_name,argv[l]); 

} 

if (argv[2]) 

{ 

function-tag = new cliar[strlen(argv[2])4-l]; 
strcpy( function-tag, argv[2]); 

} 

number-arguments = argc - 3; 


128 




// subtract the "design” "database” & "function” 
II from the argument(s) we evaluate. 


if (number-arguments < 0) 

{ 

cerr "<ERROR: Mot enough arguments specified>\n\n*' 

" Format for Usage; \n\n" 

<C’* designdb dbasename function Caigument, ...]\n\n"; 
exit(l); 

} 

if (OCjopen(database-name)) 

{ 

OC-transactionStart(); 
initialize.types(); 

setUpDirectorv(argv[3]. function-tag); 

} 

else 

{ 

cerr "<ERR0R: Error attempting to open database " 

<C database-name 

"-> database does not exist in registry\n\n\n"; 

exit(l); 

} 

if (strlen(function.tag)<3 || slrlen(function-tag)>3) 

{ 

cerr <C "<ERR0R: illegal function type—> <" 

C function-tag •C "> >\n"; 

} 

else 

{ 

if (function-tag[0] == 'F' H function-tag[0]=='p') 

run = evaluate 4 )rototypeJunction(upper(functionjtag), 

number-arguments); 

else if (function-tag[0] == 'C’ || function-tag[0]==’c') 
run=evaluate-Configuration Junction(upper(function-tag), 

number.arguments); 

else if (function-tag[0] == ’V’ || functiorutag[0]==’v’) 
run = evaluate-vobject Junction(upper(function-tag), 

nu mber-arguments); 

else 

cerr <C "<ERR0R: illegal function type—> <"; 
cerr C function-tag "> >\n"; 

} 

} 

switch (run) 


129 





{ 

case LISTJ'ROTOTYPES; 


list 4 )rotJ'unc(number.arguments); 

break; 

case LONG-LISTJ’ROTOTYPES: 
longJist.protJ'unc(number.arguments); 
break; 

case GET_PROTOTYPE_LEADER; 

get 4 )rot Jeader Junc(number-arguments, argv[3]); 

break; 

case DUMPJPROTOTYPE^UMMARY; 

dump.prot^ummary.func(number-arguments, argv[3]); 

break; 

case GET.PROTOTYPEJDESCRIPTION: 
get-prot_descriptionJunc(number-arguments, argv[3]); 
break; 

case RETRIEVE.PROTOTYPE.DATE: 

retrieve-prot.date J'unc(number.arguments, argv[3]); 

break; 

case INSERTJROTOTYPE: 
insert 4 )rotJ'unc( number .arguments, argv[3], 
argv[4], argv[5]); 

break; 

case UPDATEJ’ROTOTYPE.LEADER: 

update.prot deader J'unc(number.arguments, 

argv[31, argv[4]); 

break; 

case UPDATE_PROTOTYPEJ)ESC: 

update .prot _desc-func(number .arguments, 

argv[3], argv[4]); 

break; 

case UPDATEJ’ROTOTYPEJ^AME: 

update 4 )rotJiameJ'unc( number-arguments, 

argv[3], argv[4]); 

break; 

case DUMP-CONFIGURATION-SUMMARY; 

dump.conf.summary-func(number.arguments, 

argv[3],argv[4]); 

break; 

case GETJ.ATEST.CONFIGURATION: 
get Jatest jconf Junc(number Jirguments, 
argv[3]); 

break; 

case ADD.CONFIGURATION.OPERATORS: 

add.confjoperatorsJ'unc(number.arguments, 

argv[3],argv[4]); 

break; 

case DUMP-CONFIGURATION-OPERATORS: 


dump.conf-operatorsJunc(number-arguments. 

argv[3],argv[4],argv[5]): 


break; 


130 




case RELEASE-CONFIGURATION-LOCK: 
release-confJockJunc(number-arguments, 

argv[3],argv[4]); 

break; 

case LONG-LIST-CONFIGURATION-OPERATORS: 
longJist-conf-operators-func(number-arguments, 

argv[3],argv[4]); 

break; 

case LIST-CONFIGURATION-OPERATORS: 
list-Conf-operators-func(number-arguments, 

argv[3],argv[4]); 

break; 

case LIST-CONFIGURATION-DEFAULT-OPERATOR. 
Hst-conf-default-operator Junc(number-arguments, 

argv[3],argv[4]); 

break; 

case LIST-CONFIGURATIONS: 

list-Conf-func(number-arguments, argv[3]); 

break; 

case UPDATE-CONFIGURATION-NAME: 
update-conf_name-func(number-arguments, 

argv[3], argv[4], 
argv[5]); 

break; 

case GET.CONFIGURATION.DESCRIPTION: 
get-conf-desc iunc(number -arguments, 
argv[3], argv[4]); 

break; 

case INSERT.CONFIGURATION: 

insert-conf Junc(number-arguments, argv[3], 
argv(4], argv[5], argv[6]); 

break; 

case UPDATE-CONFIGURATION-DESCRIPTION: 
update-conf-desc Junc(argv[3], argv[4], 

argv[5]); 

break, 

case GET-CONFIGURATION-MANAGER: 
get-conf-manager-func(number-arguments, 

argv[3], argv[4]); 

break; 

case UPDATE-CONFIGURATION-MANAGER: 

update-conf-manager_func(number-arguments, argv[3], 

argv[4], argv[5]); 

break; 

case GET-CONFIGURATION-DATE: 
get-conf-date-func(number-arguments, 
argv[3], argv[4]); 

break; 

case GET-CONFIGURATION-CHANGED: 
case POST-CONFIGURATION-LOG: 


131 



post.confJog-func(argv[3], argv[4], argv[5]); 

break; 

case GET-CONFIGURATION_LOG; 
get.confJogJ'unc(number-arguments, 
argv[3], argv[4]); 

break; 

case ATTACH.OPERATOR: 
attach-vobject J.o.conf Junc(numberjLrgunients, 

argv[3],argv[4], 

argv[5],argv[6]); 

break; 

//- X - X - X -A' 

// 

// VOBJECT CASE STATEMENTS 

case LIST.OPERATORS; 

list joperatorsJ'unc(number.arguments,argv[3], 
argv[4],argv[5]); 

break; 

case GET.VOBJECTJDESCRIPTION: 
get.vobject-desc J'unc(number.arguments, argv[3], 

argv[4], argv[5]); 

break; 

case UPDATE.VOBJECTJDESCRIPTION: 
update-vobject.descJ’unc(number .arguments, 

argv[3], argv(4], 
argv[5i, argv[6]); 

break; 

case GET-VOBJECTJ)ATE: 
get.vobject.dateJ'unc(numberjarguments, argv[3], 

argv[4], argv[5]); 

break; 

case GET.VOBJECT.VERSIONS; 

get.vob ject.versions Junc( number .arguments, 

argv[3], argv[4]); 

break; 

case GET.VOBJECTXOCK: 

get.vobject Jock Junc(number.arguments, 

argv(3], argv[4], argv[5]); 

break; 

case GET.VOBJECT.VERSION: 
get.vobject.version Junc(); 

break; 

case DUMP.VOBJECTJSUMMARY; 

dump-vobject.summary.func(number.arguments, argv[3], 

argv[4], argv[5]); 

break; 

case GET.VOBJECTJ’OSTSCRIPT: 

get.vobject.psfileJiinc(number Jirguments, argv[3]. 

argv[4], argv[5],argv[()]); 


132 



break; 

case GET.VOBJECT.GRAPH: 
get-Vobject-graphfileJ'unc(numberjirguments,argv[3], 

argv[4], argv[5],argv[6]); 

break; 

case GET.VOBJECTJMPLEMENTATION: 
get.vobject Jmpfile.func(number-arguments, argv[3], 

argv[4], argv[5],argv[6]); 

break; 

case GET.VOBJECT^PECIFICATION: 
get-Vobject^pecfile-func(number^rguments, argv[3], 

argv[4], argv[5],argv(6]); 

break; 

case GET-VOBJECT-SOURCE: 
get-vobject-sourcefileJunc(number .arguments, 

argv[3], argv[4], 
argv[5],argv[6]); 

break; 

case DUMP.VOBJECT-FILES: 

dump-Vobject.files-func(number-arguments, 

argv[3], argv[4], 
argv[5],argv[6]); 

break; 

case DUMP-VOBJECT-TREE: 

dump-vobject_tree.func(number-arguments, argv[3]. 

argv[4], argv[5],argv[6]); 

break; 

case ADD-VOBJECT-AND-SUBTREE: 
add-vobject-and-subtree.func( number-arguments, 

argv[3],argv[4]); 

break; 

case RELEASE-OPERATOR.LOCK: 

releasejoperator Jock June (number-arguments, 

argv[3],argv[4], 

argv[5j); 

break; 

case RELEASEJSUBTREE-LOCK: 

release .subtree Jock Junc(number .arguments, 

argv[3],argv[4], 

argv[.5j); 

break; 

case LONG-LIST-OPERATORS: 

longJist-operators Junc(number-arguments,argv[3]. 

argv[4j,argv[.5]); 

break; 

case LONG-LIST-CHILDREN: 
long Jist-childrenJunc( number.arguments.argv[3]. 

argv[4],argv[5]); 

break; 

case LONG-LIST-PARENTS 

longJist.parents Junc( number.arguments. argv[3]. 


133 




argv[4],argv[5]); 


break; 

case ERRORJN.EVALUATION: 
cerr "<ERROR: Error reLurned iroa evaluation" 

C " lunction>\n"; 
break; 
default: 

{ 

cerr "<ERROR: Unknosn error with function " 

" call, .euitch (run) .. .>\n"; 
exit(l); 

} 

} 

OC-transactionCommit(); 

OC-close(database jiame); 
cerr <C "\n\nDe8ign Database " 

<C"vl.l Copyright 1991(c) WP.D.A.L.G Inc.\n\n\n"; 
exit(O); 

} 

// - 

// END OF MAIN 

II 

11 - 

void initialize-types(void) 

{ 

THREAD.OType=(Type *)OCJookup("THREAD"); 
COMPONENT-OType=(Type *)OCJookup("C0HP0RE»T"); 
V.OBJECT-OType=(Type ♦)OCJookup("V_0BJECT"): 
TEXT.OBJECT-OType=(Type ♦)OCJookup("TEXT-OBJECT"); 
PROTOTYPE-OType=(Type *)OCJookup{"PR0T0TYPE"); 
CONFlGURATION.OType = (Type *)OCJookup("C0NFIGURATI0N"), 
DDB.OType = (Type ♦)OCJookup("DDB"); 

}: 

void setUpDirectorv(cbar ♦protName, char ♦func.tag) 

{ 


ddbRootDir = (Directory ♦) OCJookup(DESIGN.DATABASE-DIRECTORY); 
if(ddbRootDir) 

{ 

OC-setWorkingDirectory (ddbRootDir); 

myPrototypcList = (List ♦) OCJookup(PROTOTYPE_LlST); 

} 

else 

{ 

ddbRootDir = new Directory(DESIGN-DATABASE_DIRErTORY): 
ddbRootDir — putObject(); 

OC-setVVorkingDirectory (ddbRootDir); 

myPrototypeList = new List(OC-string.PROTOTYPE_LIST); 


131 






myPrototypeList —> putObject(); 

} 

char ♦yourDirChoice; 

if ((slrcmp(func.tag, LIST.PROTOTYPE-UPC) == 0) |1 
(strcmp(func.tag, LIST JROTOTYPEXC) == 0) |1 
(strcmp(func-tag, LONG-LIST-PROTOTYPEXC) == 0) 1| 
(strcmp(func.tag, LONG_LIST-PROTOTYPEXC) == 0)) 

{ 

return, 

} 

else 

{ 

yourDirChoice = new char[l + strlen(protNamc) + 5]; 
strcpy(yourDirChoice, protName); 
strcat(yourDirChoice, "jdir"); 

} 

prototypejdir = (Directory ♦)OCJookup(yourDirChoice); 

if ((!(strcmp(func.tag,lNSERT.PROTOTYPE.UPC))==0) tt 
(!(strcmp(func.tag,INSERT.PROTOTYPEJ.C))==0) kL 
(!(prototype_dir))) 

{ 

cerr "<ERR0R; Prototype " <C protName 
«C " not found>\n" 

C "<Did you remember to run " 

< 'TMSERT PROTOTYPE lir8t’>\n*'; 
OC-transactionCommitO; 

OC-close(database-name); 

exit(O); 

, } 

if (Iprototype.dir) 

{ 

prototype.dir = new Directory(yourDirChoice); 
prototype.dir—putObject(): 
if (Iprototype.dir) 

cerr <§; "Did not setup database directory\n"; 
OC.setWorkingDirectory( prototype.dir); 

} 

else 

OC.setW'orkingDirectorv( prototype .dir); 

} 




// File Header -- 

//••■■.: 

//.Filename .; component.h 

//.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

// eompiler .; Glockenspiel C++ 2.1 

n .•• 

// End header comments -- 

#ifndel _COMPONENT.H 
#define _COMPONENT.H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char COMPONENT Ji^ccsld[] = “C(#)component. h 1.3\t9/16/91" 

// Gontents -- — 

// 

// eOMPONENT 

// 

// Description 

II 

// Defines class GOMPONENT. 

11 

// End - 

// Implementation Dependencies - 

#include <Typ«.h> 

#include <List.h> 

#include <Referance.h> 

#include ”Ref erenceMacros. h" 
tinclude <8tr«aB.hxz> 

// End Implementation Dependencies - 

// Interface Dependencies - 

#ifndef _TEXT.OBJECT_H 
tinclude "taxt.objact .h” 

#endif 

// End - - 

TypeCheckReference(TextObjDictReference, Reference. List); 

// Glass // 


136 























class COMPONENT : public Object 

{ 

private : 

TextObj Diet Reference text jobject Jist; 
public: 

COMPONENTO; 

COMPONENT(APL ♦theAPL); 

virtual void Destroy (Boolean abort = FALSE); 

virtual Type *getDireclType(); 

void getComponentNames{); 

Boolean getComponentSource(char+); 
void addTextObject(TEXT-OBJECT ♦), 

Boolean getPSfile{char*); 

Boolean getGRAPHfile(char*); 

Boolean getSPECfile(char*); 

Boolean getlMPfile(cliar»); 

Boolean getSOURCEfile(char*); 

~COMPONENT() { Destroy(FALSE); }; 

}: 

// Desenption - 

// 

// Defines an COMPOSEST class. The class COMPONENT ts a derived 
II class of Object. 

II 

II Constructor 

II 

u COMPONENT 

II 

II Constructs an COMPONENT object 

II 

u COMPONENT -A PL 
// 

// ONTOS required constructor 

II 

II Public Members 

II 

II Destroy 

n 

II ONTOS heap mangagement method 

II 

II getDireciType 

II 

u Return the ONTOS Type of cla.ss COMPONENT. 

II 

II gelComponentNames 

n 


137 





// Display the file names of the file contained in the COMPONENT node 

// 

// getComponentSource 

// 

// Output the contents of an COMPONENT node to files. 

// 

// addTextObject 

n 

II Inserts a texi.object into the COMPONENT node. 

// 

// getPSfile 

II 

II Output the .ps file contained in the COMPONENT node. 

II 

u getCRAPHfile 
// 

// Output the .graph file contained in the COMPONENT node. 

// 

// getSPECfile 

II 

II Output the .spec file contained in the COMPONENT node. 

II 

u getIMPfile 

II 

II Output the .imp file contained in the COMPONENT node. 

n 

U getSOURCEfile 

II 

II Output the .a file contained in the COMPONENT node. 

II 

u -^COMPONENT 
II 

II Destructor for the COMPONENT class. 

II 

u End - 

#endif // ^COMPONENT.II 


138 







// Flit Header --- 

// . •• 

I! .Filename ..■ component.cxx 

I/.sees ID .; 1.3 

/1 .Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.Compiler .; Glockenspiel C++ 2.1 

// . 

// End header comments - 

// sees ID follows: Will compile to place date/ttme stamp in 
// object file 

static char COM PONF.NT_cxx.SrcsId[j = "®(#)coinponent. cxx 1.3\t9/16/91" 

// eontents -- 

// 

// eOMPONENT::eOMPOSESr ONTOS constructor 
// eOMPONENT::eOMPONEST constructor 
// eOMPONENT.-.getDireclType 
// eOMPONENT. Destroy 
// eOMPONES'^ jeteomponentNames 
// eOMPONE' i ::geteomponeniSource 
// eOMPONLNT::addTeilObjecl 
// eOMPONENT::getPSfile 
// eOMPONENT::g€tGRAPHfile 
// eOMPONENT .getSPEefile 
// eOMPONESr::geiIMPfile 
/ / eOM PONEN T::getSO U REE file 
// 

// Description 

// 

// Implementation of class eOMPONENT member functions. 

/i 

// End - 

// Implementation Dependencies - 

#ifndef _DDBDEFINES.H 
#includ« "ddbdefines.h" 
tendif 

#include <Object.h> 

•include <GlobalEntities.h> 

extern "C—" 

{ 

•include <strings.h> 

} 


139 



















#ilndei _TRACER-H 
tinclude ”tracer.h” 
#endif 


#ifndef _COMPONENT-H 
#iiiclude ” component. h” 

#endil 

// End Implemeniaiton Dependencies - 

extern Type ♦COMPONENT.OType; 
extern Type ♦TEXT.OBJECT.OType; 

// ONTOS required constructor // 

COMPONENT::COMPONENT(APL *theAPL);(tlieAPL) 

}. 

// Constructor // 

COM PO N E NT:: CO M PO N E NT () 

// Summary --- 

// 

// Constructs a persistent COMPONENT object. 

II 

II Parameter 
/ : 
f / 

// None 

// 

// Functional description 

II 

II Creates a list to hold text objects, then reset a reference 
II to point to the list. 

II 

u End - 

{ 

initDirectType(COMPONENT-OType); 

List *newTextObjList = new List(TEXT-OBJECT-OType); 
newTextObjList -* putObject(): 
textjobjectJist.Reset(newTextObjList, this); 
putObject(); 

}: 

II End Constructor COMPONENT::COMPONENT// 

II Member Function // 

Type ♦COMPONENT;;getDirecl'l ype() 


140 







// Summary - 

// 

// returns the ONTOS Type for the COMPONENT class. 

// 

// Return value 

n 

II A pointer to an ONTOS Type. 

II 

u End - 


return COMPONENT.OType; 

}; 

// End Member Function COMPONENTr.geiDirectType // 

// Member Function // 

void COMPONENT::Destrov(Boolean aborted) 

{ , 

if(aborted) 

{ 

Object;; Oestroy (aborted); 

} 

} 

// End Member Function COMPONENT::Destroy --—- 

// Member Fun :tion // 

void COM PON ENT: :getConiponent Names() 

// Summary - 

// 

// Displays the name of each component ni an COMPONENT object. 

II 

II Parameter 

// 

// None 

n 

II Functional description 

// 

// We get a pointer to the list and then create an iterator 
II for the list. We iterate over each text object and 
II display the contents of the name field. 

II 

II 

u End - 

{ 

List ♦my-list = (List*)text.objectJist.Binding(this); 


Ml 










Listiterator myJterator(my.list); 
TEXT-OBJECT ♦the.textjobject; 


while(my iterator .moreData()) 

{ 

thejicxt j^bject = (TEXT_OBJECT*)(Entity*)my jterator(); 
theiextjobject —» displayFileName(); 

} 

} 

// End Member Function COMPONENT::geiComponentNames - 

// Member Function // 

Boolean COMPONENT:;getComponentSource(char *fileMocle) 

List ♦myJist = (List*)text.objectJist.Binding(this); 

Listiterator my.iterator(my-list); 

TEXT-OBJECT ♦the.text-object; 

Boolean writeJailed = FALSE; 
while(myJterator.moreData()) 

{ 

the-text jDbject = (TEXT-OBJECT*)(Entity*)my Jterator(); 
if (!the-text-object —• rebuildTextFile(fileMode)) 
writeJailed = TRUE; 

} 

if (writeJailed) 
return FAILED; 
else 

return SUCCESS; 

} 

// End Member Function COMPONENT::getComponentSource - 

// Member Function // 

void COMPONENT::addTextObject(TEXTOBJECT ♦ my J.extx)bject) 

List ♦myJist = {List^)text-objectJist,Binding(this); 
myJist — Insert(my-text-object); 
myJist —► putObject(); 
putObject(); 

} 

// End Member Function COMPONENTr.addTextObject - 

// Member Function // 

Boolean COMPONENT::getPSfile(char ♦fileMode) 

{ 

List ♦rny-list = (List^)text-objectJist.Binding(this); 


142 







Listiterator my-iterator(my_list); 


while(myJterator.moreData()) 

{ 

TEXT.OBJECT *thejtext^bject = (TEXTX)BJECT*)(Entity+)my Jterator(); 
char ♦theJile_name = the.textjabject—►getFileName(); 
theJile jiame=(the-file_name + 

(strlen(the-text jDbject—»getFileName())-LENGTH-PS_EXT)); 
if(strcmp(theJilejiame,PS-EXT)==0) 

if (theJ,ext jobject—►rebuildTextFile(fileMocle)); 
return SUCCESS; 

} 

} 

} 

// End Member Function COMPONENT::geiPSjile - 

// Member Function // 

Boolean COMPONENT::getSPECfile(char ♦fileMode) 

{ 


List *my.list = (List*)text.object Jlst.Binding(this); 

Listiterator niy.iterator(my.list); 
while(myJterator.moreData()) 

{ 

TEXT.OBJECT *theJextj^bject = (TEXTX)BJECT*)(Entity+)myJteralor(); 
char *theJilejiame = the.textjabject—getFileName(); 
theJile Jiame=(the Jile jiame + 

(strlen(the-text jDbject—getFileName())-LENGTH.SPECT]XT)); 
if(strcmp(theJilejiame,SPEC-EXT)==0) 

{ 

if (the.text jobject—>rebuildTextFile(fileMode)) 

return SUCCESS; 
else 

return FAILED; 

} 

} 

} 

// End Member Function COMPONENT::getSPECfile -- 

// Member Function // 

Boolean COMPONENT:;getGRAPllfile(cliar *fileMode) 

{ 

List *my.list = (List*)text.objectJist.Binding(this); 

Listiterator my-iterator(my.list); 
while(myJterator.moreData()) 

{ 


143 





TEXT.OBJECT ♦thejtextx)bject = (TEXTJ[)BJECT*)(Entity+)myJterator(); 
char ♦theJilejvame = the.textjobject—♦getFileName(); 
theJilejiaine=(theJilejiame + 

(strlen(the.textjDbject-.getFileName())-LENGTH.GRAPH_EXT)); 

if(strcmp(theJile_name,GRAPH_EXT)==0) 

{ 

if (the_textjobject—>rebuildTextFile(fiIeMode)) 
return SUCCESS; 
else 

return FAILED; 

} 

} 


// End Member Function COMPONENTr.getGRAPHfile - 

// Member Function // 

Boolean COMPONENT:;getIMPfile(char ♦fileMode) 

{ 

List *myJist = (List+)text.objectJist.Binding(this); 

Listiterator myJterator(my.list); 
while(myJte. ator.moreData()) 

{ 

TEXT.OBJECT *theTextjDbject = (TEXTX)BJECT*)(Entify*)my Jterator(); 
char •thejilejname = Ihe.lexljobjecl—♦getFileName(); 
theJilejiame=(the Jilejiame + 

(strlen(the.text jibject—‘getFileName())-LENGTH JMP JiXT)); 
if{strcmp(theJilejiame,IMP-EXT)=:=0) 

{ 

if (the.text jDbject—♦rebuildTextFile(fileMode)) 
return SUCCESS; 
else 

return FAILED; 

} 

} 

} 

// End Member Function COMPONENT::getIMPfile -- 

// Member Functton // 

Boolean COMPONENT:;getSOURCEfile(char ♦fileMode) 

{ 

List ♦my.list = (List*)text.objectJist.Binding(this); 

Listiterator inyJterator(my-list); 
while( my J terator. moreData()) 

{ 

TEXT-OBJECT ♦the-textjDbject = (TEXT-DBJECT^)(Entity+)myJterator(); 
char ♦the-file_name = the-texljobject—•getFileName(); 
theJile-name=(the-file-name + 


144 





(strlen(the_textjDbject—*getFileName())-LENG'i'H SOURCE-EXT)); 
if(strcmp(the.filejiame,SOURCE-EXT)=:=0) 

{ 

if (the_text jjbject—‘rebuildTextFile(fileMode)) 
return SUCCESS; 
else 

return FAILED; 

) 

} 

} 

// End Member Function COMPONENT::geiSOURCEfile - 


145 






// File Header --—--- 

II . 

/!.Filename .; conffunc.h 

II.sees ID . : 1.3 

//.Release No....: 1 

//.Dale .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C7++ S.l 

II .•• 

// End header comments --- 

#ilndel -CONFFUNC-H 
#deline _CONFFUNC-H 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char conffuncJi-SccsIdP = "•(#)conllunc.h 1.3\t9/16/91"; 
// Gontents - 

II 

// Prototypes for functions related to manipulating 
// configurations. 

II 

u End - 

void list.conf-func(int, char ♦); 
void dump.confjiummary.func(int,char ♦.char ♦); 
void get Jatest.confJunc(int, char ♦); 

void attach.vobject.to-conf-func{int,char ♦, char ♦, char *, char ♦); 

void update.confjiameJunc(int, char+, char^, char*): 

void get.conf.desc Junc(int, cheir^, char+); 

void insert.conf Junc(int, char^, char^, char^, char*); 

void updatexonf-desc Junc(char*, char*, char*); 

void get.confjnanagerJ'unc(int, char*, char*); 

void updatej:onfjnanagerJ'unc(int, char*, char*,char*); 

void get.conf-dateJunc(int, char*, char*); 

void post.confJogJ’unc(char*, char*, char*); 

void get.conf Jog J’unc(int, char*, char*); 

void dump.conf.operatorsJ'unc(int,char *,char *,char *); 

void add.confj)peratorsJunc(int,char *,char *); 

void releasejonfJock Junc(int,char *.char *); 

void longJist.conf-operatorsJ'unc(int,char *,char *); 

void list.conf.operatorsJ'unc(int,char *,char *); 

void list.conf-default.operatorJ‘unc(int,char *,char *); 

// Description - 

II 

// list.confifunc 

II 


146 















// Provides a Itsi of configurations associated with a 
II designated prototype. 

// 

// dump.confjsummary.func 

// 

// Provides summary information of a configuration to 
11 to include: creation date, manager, version number and 
II default VOBJECT name, and a description. 

II 

// getJatest.conf.func 

II 

II Provides the name of the most recently added conHguration. 

II 

II attach-vobjectJo.conf.func 

II 

II Attaches an instance of the VOBJECT class to a configuration. 

II 

II update.conf.name June 

// 

// Changes the name of a designated configuration. 

II 

II get.conf.desc.func 

II 

II Provides a description of the designated confiouration. 

n 

II insert.conf.func 

II 

II Creates a new configuration and binds it to a particular 
II prototype. 

II 

II update.conf.desc.func 

II 

II Updates the description text of a designated configuration. 

II 

II get.conf.manager.func 

// 

// Provides a configuration manager's name. 

II 

II update.conf.manager.func 

// 

// Changes a configuration manager's name. 

II 

II get.conf .date .func 

II 

II Provides the creation date of a given configuration. 

II 

II post.conf.log.func 

II 

II Adds a timestamped log entry (translated char string) 

II to a configuration 

II 


147 




// get.conf.logjunc 

// 

// Provides the text of a configuration log. 

II 

II dump.conf.operators.func 

// 

// Write a copy of the operators in a designated configuration 
II to disk. 

n 

II add-conf.operators-func 

n 

II Add operator from disk to a particular configuration in the 
II database. 

II 

II release^confJock-func 

n 

II Provide a method to release locked operators in a given 
II configuration. 

II 

II longJist.conf.operators.func 

// 

// List all the children’s names and version numbers of a 
II given configuration. 

// 

// list.conf.operators.func 

II 

II List the immediate children's name and version number of 
II a given configuration. 

II 

II list.conf.default.operator.func 

II 

II Provides the name and version number of the default VOBJECT 
II assigned to the configuration. 

// 

// End Description —----- 

# end if // —CONFFUNC-Il 


148 





// File Header - 

// . 

//.Filename .; conffunc.czz 

I/.sees ID .; 1.3 

//.Release No....: 1 

//.Daie .; 9/16/91 

I/.Author .; Garry Lewis 

II .; Drew Dwyer 

11 .eompiler ..■ Glockenspiel G+A- 2.1 

11 . 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char conffunc-cxx-SccsId[] = "e(#)conilunc.cxx 1.3\t9/16/91" 

// Gontents ------- 

// 

// hst.conf.func 

II dump .conf.summary June 

II getJatest.confJune 

II attach.vobjectJo.confJunc 

II update.conf.name June 

II get.conf.descJune 

II insert.conf.func 

II update.conf.desc.June 

II get.conf.manager.func 

II update.conf.manager.func 

II get.conf.date.func 

II post.conf.log.func 

II get.conf.log.func 

II dump.conf.operators.func 

II add.conf.operators.func 

II release.conf.lock.func 

II long.list.conf.operaters.func 

II list.conf.operators.func 

II list.conf.default.operator.func 

n 

U End -- 

// Implementation Dependencies - 

• include <8treajn.hxx> 

•include <Directory.h> 

extern "C—" 

( 

•include <8y8/ti*e.h> 

•include <8y8/type8.h> 

•include <8tdlib.h> 

















} 


#ilndef _DIRECTORY_H 
#include "directory .h” 

#endil 

#ilndel _TREE-H 
finclude "tree.h” 
tendif 

#ilndef _TREENODE_H 
#include "treenode.h” 
tendif 

tifndef _PROTOTYPE_H 
tinclude "prototype.h” 
tendif 

tifndef _THREADJI 
tinclude ”thread.h" 
tendif 

tifndef _CONFIGURATION-H 
tinclude "configuration.h” 
tendif 

tifndef -CONFFUNCJI 
tinclude "conffunc.h” 
tendif 

tifndef -DOBDEFINES-H 
tinclude "ddbdef ines .h” 
tendif 

PROTOTYPE *protoPtr; 

CONFIGURATION ♦configurationPtr; 
extern THREAD ♦threadPtr; 

// End Implementation Dependencies - 

ifstream inputfile; 

void list-conf_func(int number-arguments, char ^argl) 

{ 

char *prototype_name = new char [strlen{argI)+5]; 
strcpy(prototype-name,argl), 
strcat(prototype.name, PROTOTYPE-EXT); 

switch (number.arguments) 

{ 

case 1: 


I.'iO 











protoPtr = (PROTOTYPE*)OC Jookup(prototypejiame); 
protoPtr —► listConfigurations(); 

break; 
case 3: 
default: 

cerr 'C "<ERROR: extra airgunents in list conf igurations>\n’'; 

} 


void dump.conf-summary-func(int number^rguments, char ♦argl, char *arg2) 

{ 

char *prototype_name = new char [strlen(argl)+5]; 

8trcpy(prototype_name,argl); 

8trcat(prototypejiame,PROTOTYPE-EXT); 

switcl»(number arguments) 

{ 

case 2; 

protoPtr = (PROTOTYPE*)OC Jookup(prototype-name); 
if (protoPtr) 

{ 

configurationPtr = (C0iNTIGURATI0N*)0CJookup(arg2); 
if(configurationPtr) 

{ 

configurationPtr —• dumpConfigSummary(); 

} 

elae 

cerr "<ERR0R: " <C arg2 <C " configuration not found>\n‘'; 
cerr "<Dump configuration operation terminated>\n"; 
return; 

} 

} 

else 

{ 

cerr "<ERROR: " <C argl " prototype not found>\n"; 
cerr " Dunp configuration operation terminated\n"; 
return; 

} 

break; 

default: 

cerr <C "<ERROR: extra arguments in diunp configuration 8ummary>\n’' 

} 

} 

void getJatest-Conf-func(int number-arguments, char ♦argl) 

{ 

char ♦prototype-name = new char [strlen(argl)+5]; 
strcpy( prototype _name,arg 1): 
strcat(prototype.name,PROTOTYPE JEXT); 


151 







switch (numberjirguments) 

{ 

case 1: 

protoPtr = (PROTOTYPE»)OC Jookup(prototype_name); 
protoPtr —* getDefaultConfigName(); 
break; 
case 3: 
default: 

cerr •C "<ERROR: extra airgumenta in get default configurations>\n"; 

} 

} 

void attach-Vobject.tO-ConfJ'unc{int number-arguments,char ♦proto.name, 

char ♦config-name,char ♦operator-name,char ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(proto_name)+5]; 
strcpy (prototype-name,proto-name); 
strcat(prototype-name,PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 3: 

protoPtr = (PROTOTYPE^)OC Jookup(prototype-name); 
if (protoPtr) 

{ 

threadPtr = (THREAD ♦)©€Jookup(operatorJiame); 
if (threadPtr) 

{ 

configurationPtr = (CONFIGURATION ♦)OCJookup(config_name); 
if (configurationPtr) 

{ 

V-OBJEiCT ♦vobjectPtr; 
vobjectPtr = threadPtr—*current(); 
configurationPtr—‘attach VobjecttoConfig( vobjectPtr); 
configurationPtr—>putObject(); 

} 

else 

{ 

cerr "<Error getting configuration in attach vobject to config>\n 

} 

} 

else 

{ 

cerr C "<Error getting thread in ATTACS-VOBJECT-TCLCONFIG: >\n"; 

} 

} 

else 

{ 

cerr ^ "<Error getting Prototype in ATTACE.VOBJECT-TO-COKFIG: >\n"; 

} 

break; 


152 





case 4; 

protoPtr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (protoPtr) 

{ 

threadPtr = (THREAD ♦)0CJookup(operator Jiame); 
if (threadPtr) 

{ 

configurationPtr = (CONFIGURATION ♦)OCJookup(configjiame); 
if (configurationPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—►version(atoi(versionstr)); 
configurationPtr—‘attach VobjecttoConfig( vobjectPtr); 
configurationPtr—‘putObJectO; 

} 

else 

{ 

cerr "<Error getting configuration in attach vobject to config>\n'' 

} 

} 

else 

{ 

cerr <C "<Error getting thread in ATTACH_VOBJECT.TO_CONFIG: >\n"; 

} 

} 

else 

{ 

cerr ^ "<Error getting Prototype in ATTACE.VOBJECT.TO-COKFIG: >\n’‘; 

} 

break; 

default: 

cerr "<ERROR: invalid number args for get vobject description>\n’’; 

} 

} 


void update_conf_name_func(iut numberJirguments, char targl, char ♦arg2, char *arg.'5) 

{ 

char ♦prototype_name = new char [strlen(argl)+5j; 

8trcpy( prototype Jiame,arg 1); 
strcat(prototypejiame, PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 3 ; 

protoPtr = (PRCTOTYPE*)OC Jookup(prototype-name); 
if (protoPtr) 

{ 

configurationPtr = (C0NFIGURAT10N*)0CJookup(arg2); 
if (configurationPtr) 

{ 


153 





configurationPtr — updateConfigNaine(arg3); 

} 

else 

{ 

cerr •C "<Prototype " <C argl C ''do«s not " 

<C "contain conliguration " arg2 C ">\n" 

•C "<Update conliguration laae operation aborted. >\n"; 
break; 

} 

} 

else 

{ 

cerr < "<Prototype " < argl < " not lound>\n" 

<C "<update conliguration name operation aborted>"; 

} 

break; 

default: 

cerr <C "<ERR0R: invalid number args for update Config Ncune>\n": 

} 


void gel_conf_desc Junc(int number_arguinents, char ♦argl, char ♦arg‘2) 

{ 

cliar ♦prototypeji.ime = new char [strlen(argl)+5]; 
strcpy(prololype jiariie.argl); 
slrcat(prototypp jiame,PROTOTYPE-EXT); 

switcli (number.argunients) 

{ 

case 2: 

protoPtr = (PROTOTYPE^)OC Jookup(prototypejiame); 
if (protoPtr) 

{ 

configurationPtr = (CONFIGURATION ♦)OCJookup(arg2); 
if (configurationPtr) 

{ 

configurationPtr — getConfigDescription(); 

} 

else 

{ 

cerr "<Configuration: " -C arg2 •C " is not contained " 

<C "in prototype " C argl <C ".>\n" 

■C ”<get configuration Description Operation Aborted. >\n 

} 

} 

else 

{ 

cerr <C "<Prototype " argl " not lound>\n" 

<C "<get conliguration description operation aborted>"; 

} 


154 




break; 

default: 

cerr ■<; "<ERROR: invalid nunber args for get configuration description>\n"; 

} 


void insert^onfJ'unc(int number_arguments, char ♦argl, char *arg2, char *arg3, char *arg4) 

{ 

char ♦prototypejiame = new char [strlen(argl)+5]; 
strcpy (prototype _name,argl); 
strcat(prototypejiame,PROTOTYPE j;XT); 

switch (numberjirguments) 

{ 

case 2: 

protoPtr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (protoPtr) 

{ 

configuratioriPtr = (CONFIGURATION ♦)0CJookup(arg2); 
if (IconfigurationPtr) 

{ 

configuratioriPtr = new C0NFIGURATI0N(arg2); 
protoPtr —* addConfiguration(configurationPtr); 

} 

else 

{ 

cerr ^ ''<ERROR: Configuration name " <C arg2 <C " already exists!>\n 
return; 

} 

} 

else 

{ 

cerr -C "<Prototype " <C argl <C " not found>\n" 

•C "<no Configuration operation conducted>"; 

} 

break; 

case 3: 

protoPtr = (PR0T0TYPE*)0C Jookup(prototype-naiTie); 
if (protoPtr) 

{ 

configurationPtr = (CONFIGURATION »)OCJookup(arg2); 
if (IconfigurationPtr) 

{ 

configurationPtr = new C0NFIGURATI0N(arg2, arg3); 
protoPtr —> addConfiguration(configurationPtr); 

} 

else 

{ 

cerr ”<ERR0R; Configuration naune " <C arg2 <C " already exists! >\n 
return; 


15o 






} 


} 

else 

{ 

cerr •C "<Prototype " -C argl '* not iound>\n" 

<C "<no Configuration operation conducted>"; 

} 

break; 

case 4: 

protoPtr = {PROTOTYPE*)OC Jookup(prototypejiame); 
if (protoPtr) 

{ 

configurationPtr = (CONFIGURATION ♦)OCJookup(arg2); 
if (IconfigurationPtr) 

{ 


configurationPtr = new CONFIGURATION(arg2, arg3); 
inputfile.open(arg4, ios::in); 
if (linputfile) 

{ 

cerr <C '‘<File with conf ig description contents does not exist>\n" 
•eg; "<Constructing configuration B/Name k Mamager only>\n"; 

} 

else 

{ 

configurationPtr — updateConfigDescription(arg4,inputfile); 

} 

protoPtr — addConfiguration(configurationPtr); 
inputfile.close(): 

} 

else 

{ 

cerr •C "<ERROR: Configuration name " -C arg2 C " already exists!>\n"; 
return; 

} 

} 

else 

{ 

cerr ■C "<Prototype " -C argl " not found>\n" 

•<C "<no Configuration operation conducted>"; 

} 

break; 

default: 

cerr C "<ERROR: invalid number args for insert configuration>\n"; 

} 


void updatexonf.desc j'unc(char ♦argl, cliar ♦arg2, char ♦ arg3) 

{ 

char ♦prototypejiamo = new char [strlen(argl)+5]; 


156 





strcpy (prototype .name,argl); 
strcat(prototypejiame,PROTOTYPE_EXT); 

protoPtr = (PROTOTYPE*)OC Jookup(prototypejname); 
if (protoPtr) 

{ 

configuration Ptr = (C0NFIGURATI0N*)0CJookup(arg2); 
if (configurationPtr) 

{ 

inputfile.open(arg3, ios;:in); 
if (linputfile) 

{ 

cerr <§; "<File with config description contents not lound>\n" 
•C *'<Aborting update configuration operation>\n"; 

} 

else 

{ 

configurationPtr —<• updateConfigDescription(arg3, inputfile); 
inputfile.close(); 

} 

} 

else 

{ 

cerr <C "<Prototype " <C argl "does not " 

<C "contain configuration " arg2 <C ">\n" 

•C "<Update configuration Description operation aborted. >\n" 

} 

} 

else 

{ 

cerr "<Prototype " ^ argl " not found>\n" 

<§; "<no Configuration operation conducted>"; 

} 


void get-Conf-manager_func(int nuniher.arguments, char *argl, char ♦arg2) 

{ 

cliar ♦prototype-name = new char [strlen(argl)+.5]; 
strcpy (prototype jiame ,arg 1); 
strcat(prototypc jiame,PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 2; 

protoPtr = (PROTOT'\'PE^)OCJookup(prototypc_name); 
if (protoPtr) 

{ 

configiirationPlr = (CONFIGURATION ♦)OCJookup(arg2); 
if (configurationPtr) 

{ 


luT 



configurationPtr —► getConfigManager(); 

} 

else 

{ 

cerr <C "<Coiiliguration: *' arg2 <C *' is not contained " 

< "in prototype " < argl < ".>\n" 

^ "<get configuration Manager Operation Aborted.>\n"; 

} 

} 

else 

{ 

cerr "<Prototype " argl <C " not found>\n" 

"<get configuration manager operation aborted>"; 

} 

break; 

default: 

cerr <C "<ERRQR: invalid number args for insert configuration>\n"; 

} 


void updatejconfjnanager_func(int number-arguments, char *argl, char ♦arg2, char ♦argS) 

{ 

char ♦prototype.name = new char [strlen(argl)+5]; 
strcpy( prototype Jiame.argl); 
strcat{prototype-name,PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 3: 

protoPtr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (protoPtr) 

{ 

configurationPtr = (CONFIGURATION*)OCJookup(arg2); 
if (configurationPtr) 

{ 

configurationPtr —► updateConfigManager(arg3); 

} 

else 

{ 

cerr "<Prototype " <C argl <C "does not " 

■<C "contain configuration " arg2 •C ">\n" 

<C "<Update configuration Manager operation aborted.>\n"; 

} 

} 

else 

{ 

cerr <C "<Prototype " ■<C argl •C " not found>\n" 

<C "<update configuration Manager operation aborted>"; 

} 

break; 


158 





default: 

cerr <C "<ERROR: invalid number arge lor update Conlig Manager>\n"; 

} 


void get-Conf.dateJ'unc(int number_arguments, char ♦argl, char ♦arg2) 

{ 

char ♦prototypejiame = new char [strlen(argl)+5]; 
strcpy (prototype jiame,arg 1); 
strcat(prototypejiame,PROTOTYPE_EXT); 

switch (number^rguments) 

{ 

case 2: 

protoPtr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (protoPtr) 

{ 

configurationPtr = (CONFIGURATION*)OC Jookup(arg2); 
if (configurationPtr) 

{ 

time.t systemtime = configurationPtr —► getConfCreationDate(): 
cout <C ctime(A:svstemtime) <C "\n"; 

} 

else 

{ 

cerr C "<Conf iguration " C arg2 " not lound>\n" 

"<no Configuration operation conducted>"; 

} 

} 

else 

{ 

cerr "<Prototype " argl <C '* not lound>\n” 

C "<lind configuration creation date operation aborted>”; 

} 

break; 

default: 

cerr -C "<ERROR: invalid number args to get configuration creation date>\n" 

} 


void post-confJogJfunc(char ♦argl, char *arg2, char ♦argS) 

{ 

cliar ♦prototype-name = new char [strlen(argl)+5]; 
strcpy (prototype_name,argl); 
strcat(prototype name, PROTOTYPE JEXT): 

protoPtr = (PROTOTYPE* )OCJookup(prototype-name); 
if (protoPtr) 

{ 


159 




configurationPtr = (C0NFIGURATI0N*)0CJookup(arg2); 
if (configurationPtr) 

{ 

inputfile.open(arg3, ios::in); 
if (linputfile) 

{ 

configurationPtr —» addtoConfigLog(arg3); 

} 

else 

{ 

configurationPtr —► addtoConfigLog(inputfile); 
inputfile.close(); 

} 

} 

else 

{ 

cerr *'<Prototype " argl <§; “does not " 

C "contain configuration " arg2 ■C ">\n" 

"<Update configuration Log operation aborted. >\n"; 

} 

} 

else 

{ 

cerr <tC "<Prototype " -C argl " not found>\n" 

"<no Configuration operation conducted>”; 

} 


void get.confJogJunc(int numberjirguments, char ♦argl, char ♦arg2) 

{ 

char ♦prototypejiame = new char [strlen(argl)+5]; 
strcpy( prototype jiame, arg 1); 
strcat(prototypejiame,PROTOTYPE_EXT); 

switch (number^rguments) 

{ 

case 2: 

protoPtr = (PROTOTYPE+)OC Jookup(prototype-name); 
if (protoPtr) 

{ 

configurationP'r = (CONFIGURATION ♦)0CJookup(arg2); 
if (configurationPtr) 

{ 

configurationPtr —* getConfigLog(); 

} 

else 

{ 

cerr -C "<Configuration: ” ■C arg2 ■C " is not contained 
< "in prototype " C argl ".>\n" 

"<get configuration log operation aborted. >\n’'; 


IfiO 





} 


} 

else 

{ 

cerr «C "<Prototype " C argl C " not found>\n** 

■C "<g«t coniigiiration log operation aborted>"; 

} 

} 

} 


void dump.conf.operators_func(int number^rguments.char ♦proto_name,char ♦conf,char 
♦ file.write.option) 

char *prototype_name = new char [strlen(proto_name)+5]; 
strcpy{prototypejiame,proto-name); 

St real (prototype jiame, PROTOTYPE-EXT); 

switcli (number.arguments) 

{ 

case 3: 

protoPtr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (protoPtr) 

{ 

configuration Ptr = protoPtr—getConfiguration(conf); 
if (configurationPtr) 

{ 

V.OBJECT *vobjectPtr = configurationPtr—getDefaultVobject(); 
if (vobjectPtr) 

{ 

long vobject Jocktime =0; 

vobject Jocktime = vobjectPtr-getLockTime(); 

if (vobject Jocktime>0) // prevent checkout 

{ _ 

if (strcmp(file-write-option."B")==0) // change "w" to "r" 

{ 

cerr "<ERR0R: Module " <C vobjectPtr-getNodeName() 

" locked by ; " •C vobjectPtr—get\Vorker() 

<C " Resetting write option to read-only>\n"; 

strepy (file -Write .option,"r"). 

} 

cerr <C "<Caution; ” <C vobjectPtr—getNodc.Natiie() 

<C " is locked. > \n'' <C "Date Locked: " 

■C rtime(&:vobject Jocktime) 

<C "Subtree checked out in read-only mode\n": 

} 

else 

cerr "BODEIAME-> " •C vobjectPtr—getNode.\ame() 

■C "\nVer8ion: " C vobjectPtr-getVersionNumber() •C"\n\n" 
Boolean file.operation-successful = FALSF', 
file.operat ion-successful = 


161 



vobjectPtr —♦ checkoutCOMPONENTNode(file_write jDption); 
if ((file-operation-successful) 

((strcmp(file_writejoption,**tf'‘)==0) || 

(strcmp(file.writejoption,'’w”)==0))) 

{ 

vobjectPtr —♦ setLock(); // sei root lock 
vobjectPtr —► setWorker(); 
vobjectPtr —♦ resetLastOpFalse(); 
vobjectPtr —►putObject(); 

, } 

if (filejoperationjsuccessful) 

vobjectPtr —► dumpSubtree(file.writejoption); // dump rest of tree 
else 

cerr <C "<Error checking out '* <C vobjectPtr —►getNodeName() 

<C " Aborting duinp_vobject.tree_lunc>\n"; 

} 

else 

cerr <C "<Error: Mo Vobject is attached to dump configuration>\n"; 

} 

else 

{ 

cerr "<Error getting conliguration in dump configuration operators: >\n" 

} 

} 

else 

{ 

cerr <C "<Error getting Prototype in dump configuration operators: >\n"; 

} 

break; 

default. 

cerr "<ERROR: invalid number args for dump configuration operators>\n": 

} 


} 

void add.conf-operators-func(int number.arguments.cliar *protojianie.char ♦conf) 

{ 

char ♦prototype-name = new char [strlen(protcjiame)+5]; 
strcpy( prototype jiame,proto_name); 
strcat(prototype jiame,PROTOTYPE_EXT); 

switcli (number-arguments) 

{ 

case 2: 

protoPtr = (PROTOTYPE^)OC Jookup(prototype-name); 
if (protoPtr) 

{ 

configurationPtr = protoPtr—•getConfiguration(conf): 
if (configurationPtr) 

{ 

V’_OBJECT ♦vobjectPtr = configurationPtr—*getDefaultVobject(); 


162 





if (vobjectPtr) 

{ 

DIRECTORY ♦capsdirectory; 
capsdirectory = new DIRECTORY(); 

char ♦operator Jiame = new char [strlen(vobjectPtr—►getName())+!]; 
strcpy (operator -name, vobjectPtr—►getN ame()); 
capsdirectory—»read jdirectory (operator jiame); 
capsdirectory—»updatetimestamp(); 

TREENODEJinkedlist operatorList = capsdirectory—►getOperatorList(); 
TREENODE ♦rootnode = capsdirectory—* find J.reenode(operatorjiame); 
TREENODE ♦treej-oot = new TREENODE(rootnode,NULL); 

TREE ♦workingtree = new TREE( tree-root, operator .name); 
workingtree—>build-tree( tree .root,operatorList); 
cerr "CHECKIl—> " operator-name <C "\n"; 

V-OBJECT ♦new.parent = (V.OBJECT ♦)0; 
new .parent = vobjectPtr—>getParent(); 

V'-OBJECT ♦new.root = treej’oot—*checkin jiode(new 4 )arent); 
if( !new joot) 

{ 

cerr <C "<Error; Could not establish neHJOot in" 

•C "add-conl-operators.func. Aborting. >\n"; 
break; 

} 

new_root—set NodeName(tree .root—getnameO); 
tree joot —checkin.subtree(new joot); 

} 

else 

cerr C "<Error: lo Vobject is attached to this configuration>\n"; 

} 

el,s<> 

( 

cerr <C "<Error getting configuration in list configuration operators: >\n" 

} 

} 

else 

{ 

cerr <C "<Error getting Prototype in list configuration operators: >\n"; 

) 

break; 

default: 

cerr <g: "<ERROR: invalid number args for list configuration operators>\n"; 

} 


void release_ronf Jock Jiinc(int number.arguments. char ♦proto.name, 

char ♦conf) 

{ 

cliar ‘prototypeJiame = new char [strlen(protojiame)+5]; 
strcpy(prototype Jiame, proto Jiame); 
strcat(prototype jiamc.PROTOT'i'PE JuX I ); 


163 




switch (number_arguments) 

{ 

case 2; 

protoPtr = (PROTOTYPE*)OCJookup(prototypejiame); 
if (protoPtr) 

{ 

configurationPtr = protoPtr—►getConfiguration(conf); 
if (configurationPtr) 

{ 

V-OBJECT ♦vobjectPtr = configurationPtr—►getDefaultV'object(); 
if (vobjectPtr) 

{ , 

if (vobjectPtr—*releaseLock()) 

{ 

vobjectPtr—*putObject(); 
vobjectPtr —► releaseLockSubtree(); 

} 

} 

else 

cerr <C "<Error: Mo Vobject is attached to this configuration>\n". 

} 

else 

{ 

cerr ^ "<Error getting configuration in Release configuration Lock:>\n" 

} 

} 

else 

{ 

cerr C "<Error getting Prototype in Release configuration Lock:>\n"; 

} 

break; 
default; 

cerr "<ERR0R: invalid nunber args for Release configuration lock>\n"; 

} 


void longJist.conf-operators-func(int numberjirgunients, char *prolO-nainc, 

char ♦conf) 

{ 

char ♦prototypejiame = new char [strlen(proto_name)+5]; 

St rcpy (prototype jiame,proto Jiame); 
strcat( prototype jiame.PROTOTYPEJ^XT); 

switch (number_arguments) 

{ 

case 2: 

protoPtr = (PROTOTYPE+)OC Jookup(prototype_name); 
if (protoPtr) 

{ 

configurationPtr = protoPtr—getConfigurationfconf); 


164 



if ^configurationPtr) 

{ 

V.OBJECT ♦vobjectPtr = configurationPtr—►getDefaultVobject(); 
if (vobjectPtr) 

{ 

// cerr << ”Operator: 

// cout << vobjectPir->getName(); 

II //♦♦♦♦♦♦♦♦***♦ 

II// following for loop provides spacing... 

II // ♦♦♦♦♦♦♦♦♦♦♦ 

// ini i=0; 

// for (i=0;i<(PRINT- VERSION.LOCATION-sirlen(vobjeciPir->getName()));i++) 
!I cout « ” 

II cerr « "Pcrsion; 

II cout « vobjectPtr->getVersionNumber(); 

II cout « ”\n”; 

// txme.t locktime = vobjectPtr->geiLockTtme(); 

II cerr « ”Lockitme is: ”« citme(&lockiime) << ”\n’': 

vobjectPtr —* longlistOperatorNames(); 

} 

else 

cerr <C "<Error: Mo Vobject is attached to this configuration>\n"; 

} 

else 

{ 

cerr < "<Error getting configuration in list configuration operators: >\n"; 

} 

} 

else 

{ 

cerr tg; "<Error getting Prototype in list configuration operators: >\n"; 

} 

break; 

default; 

cerr <g "<ERROR: invalid number args for list configuration operators>\n"; 

} 


void list.conf_operatorsJ'unc(int number^rguments. char ♦protojiame, 

char ♦conf) 

{ 

char ♦prototypejiame = new char [strlen(protojiame)+5]; 

St ropy (prototype .name,proto jiame); 
strcat(prototype-name,PROTOTYPE-EXT); 

switch (number^rguments) 

{ 

case 2: 

protoPtr = (PROTOTYPE*)OC Jookup(prototype_name): 






if (protoPtr) 

{ 

configurationPtr = protoPtr—►getConfiguration(conf); 
if (configurationPtr) 

{ 

V-OBJECT ♦vobjectPtr = configurationPtr—►getDefaultVobject(); 
if (vobjectPtr) 

{ 

char ♦name=vobjectPtr—*getName(); 
int version =vobJectPtr—►getVersionNumber(); 
cerr <g; "Operator: 
cout name; 

//♦♦♦♦♦♦♦♦♦♦♦♦ 

// Added following for siaiemeni for spacing... 

II ♦♦♦♦♦♦♦♦♦♦♦ 

int i=0; 

for (i=0;i<(PRlNT.VERSION_LOCATION - 

strlen( vobjectPtr—►getNodeName()));i++) 

cout <C " 

cerr <C "\nVer8ion: 
cout <C version <g; "\n"; 

time.t locktime = vobjectPtr—»getLockTime(); 

cerr <C "Locktime is: " -C ctime(A:locktime) ^ "\n"; 

vobjectPtr —« listOperatorNames(); 

} 

else 

cerr <§; "<Error: Ho Vobject is attached to this configuration>\n"; 

} 

else 

{ 

cerr-C "<Error getting configuration in list configuration operators: >\n" 

} 

} 

else 

{ 

cerr "<Error getting Prototype in list configuration operators: >\n"; 

} 

break: 

default: 

cerr <C "<ERROR: invalid number args for list configuration operators>\n"; 

) 

} 

void list.conf-default-operator.funclint number^rguments, char ♦protomame, 

char * 0001 ) 

{ 

char *prototype_name = new char [strlen(proto_name)+5]; 

St rcpy( prototype name, protojiame): 

St rcat (prototype name, PROTOTY PE-EXT): 

switcli (number-arguments) 


166 




{ 

case 2; 

protoPtr = (PROTOTYPE*)OC Jookup(prototype jiame); 
if (protoPtr) 

{ 

configuration Ptr = protoPtr—•getConfiguration(conf); 
if (configurationPtr) 

{ 

V_0EJECT ♦vobjectPtr = configurationPtr—►getDefaultVobject(); 
if (vobjectPtr) 

{ 

char ♦name=vobjectPtr—►getName(); 
int version =vobjectPtr—♦getVersionNumber(); 
cerr "Operator; 
cout <C name; 

//♦♦♦♦♦♦♦♦♦♦♦♦ 

// Added followtng for statement for spacing... 

II «****#«*«# 4 > 

int i=0; 

for (i=0;i<(PRINT.VERSION_LOCATION - 

strlen(vobJectPtr—‘getName()));i++) 

cout <C " 

cerr " Version: 

cout C " " ^ version •< "\n"; 

} 

else 

cerr ^ "<Error: lo Vobject is attached to this cor.liguration>\n’' 

} 

else 

{ 

cerr <C "<Error getting configuration in lis- " 

C "configuration default operator:>\n"; 

} 

} 

else 

{ 

cerr < "<Error getting Prototype in list " 

"configuration default operator: >\n”; 

} 

break; 

default: 

cerr <§; "<ERROR: invalid number args for list " 

"configuration default operator>\n"; 


167 











// File Header - 

// . •• 

//.Filename .; configuration.h 

I/.sees ID .; 1.3 

j/.Release No....: 1 

//.Date .; 9/16/91 

11 .Author .; Garry Lewis 

II .; Drew Dwyer 

II.Compiler .; Glockenspiel C++ 2.1 

n .•• 

// End header comments - 

#ilndel _C0NF1GURATI0N_H 
#define _CONFIGURATION_H 

// sees ID follows: will compile to place date/time stamp in object file 
static char configuration.h-SccsIdQ = "®(#)conf iguration.h 1.3\t9/16/91" 
1/ Co Rents 
// CONFIGURATION 

II 

II Description 

n 

U Defines class CONFIGURATION 

II 

u End - 

// Implementation Dependencies - 

#include <Object.h> 

#include <Reference.h> 

#include <Dictionary.h> 

#include <8tream.hxx> 

extern "C—" 

( 

#include <sys/tiine. h> 

#include <8ys/types.h> 

} 


#include”ReferenceMacro8.h” 

// End Implementation Dependencies - 

// Interface Dependencies -— 


# iIndel _TFXT .0BJ IX'T Jl 
#incl ade "text.object. h" 
#endil 


16 !) 






















#ilndef _VERSIONED.OBJECT_H 
#include ’’versioned-object .h” 

#endif 

// End Interface Dependencies -- 

TypeCheckReference{VX)bjectReference, Reference, ViDBJECT); 
TypeCheckReference(LogReference, Reference, TEXT-OBJECT); 
TypeCheckReference(Desc2Reference, Reference, TEXT-OBJECT); 

#define DEFAULT-MANAGER 

// Class // 

class CONFIGURATION : public Object 

{ 

private: 

cliar config-status; 
cliar ♦config-manager; 
time-t ConfCreationDate; 
iut config-num.vobjects; 

LogReference configJog.entry; 

Desc2Reference config.description; 

V'-ObjectReference the Versioned-Object; 

public; 

CONFIGURATION(APL *), 

C0NFIGURAT10N(char *name, char *manager=DEFAULT-MANAGER); 

virtual void Destroy (Boolean aborted = FALSE); 

virtual Type ♦getDirectType(): 

void getConfigName(); 

cliar ♦name(); 

void getConfigStatusO; 

void getConfigManagerO; 

void getConfigLog(); 

void getConfigDescription(); 

void dumpConfigSummaryO; 

void listConfigOperatorsO; 

void updat<:ConfigManager(char *new_config-manager); 
void updateConfigName(char ♦new-config-name); 
void updateConfigStatus(cliar new-config-status); 
void addtoConfigLog(char ♦new.log-entry) 
void addtoConfigLoglifstreami:); 
void updateConfigDescription(char ♦, ifstreamt ); 

V-OBJECT *CONFlGURATION;;updateVobjectAtlachment(); 
void attachVobjecttoConfig( V-OBJECT*); 
time-t setConfCreationDateO; 
time.t getConfCreatioriDate(); 

V'-OBJECT *getDefauItVobjecf(); 

~CONFIGURATION!) { Destroy!FALSE); } 


170 







}; 


// Description - 

// 

// Defines a CONFIGURATION class. 

II 

II Constructor 

II 

II configuration -APL 

II 

II ONTOS required constructor 

n 

II configuration 

II 

II constructs a configuration object with the given name, 

// and manager. 

II 

II Public Members 

II 

II destroy 

// 

// Used to cleanup memory during deletion and transaction aborts. 

II 

II getDirectType 

II 

II Returns the ONTOS type for this class. 

// 

// gelConfigName; 

n 

II Sends the configuration name to standard out. 

n 

// name 

// 

// Returns a pointer to the configuration name. 

n 

II getConfigStatus 

II ^ 

II Sends the configuration status to standard out. 

n 

II getConf.gManager 

// 

// Sends the manager's name for this particular configuration. 

// 

// gctConfigLog 

II 

II Sends the configuration log to standard cut. 

// 

// getConfigDescription 

// 


171 





// Sends the configuration description to standard output. 

tl 

II dumpConfigSummary 

II 

II Provides name, version number of root voujcci , date and 
II description of configuration. 

11 

II listConfigOperators 

11 

II list the name of component operators in a configuration. 

II 

II updateConfigManager 

// 

// Changes the manager’s name for this configuration. 

n 

II updaieConfigName 

// 

// Changes the configuration name. 

n 

II updateConfigStatus 

It 

II Changes the configuration status field. 

II 

II addtoConfigLog 

n 

II A log to maintain a history of the configuration. 

II 

II updateConfigDescription 

// 

// Replaces the existing description if otu exist or adds a new description. 

II 

II attachVobjecttoConfig 

// 

// Adds a versioned object to configuration. 

II 

II setConfCreationDate 

// 

// Time stamp this object with the current system time. 

II 

II getConfCreationDate 

// 

// Displays the time an instance of this class was created. 

II 

II getDefaultVobject 

n 

II Returns a pointer to the attach vobject. 

// 

// configuration 

// 

II A destructor for the configuration class. 

II 


172 



// End - 

#endif // -CONFIGURATION.il 






// File Header -- 

// . •• 

//.Filename .; configuration.cxx 

II.sees ID .; 1.3 

II.Release No....: 1 

U.Date .; 9/16/91 

11 .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .eompiler .; Glockenspiel C++ 2.1 

II .•• 

// End header comments --- 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char configuration-cxx-SccsId[| = "€(#)configuration. cxx 1.3\t9/16/91" 

// Gontents -- 

// 

// eONFIGURATION::eONFIGURATION ONTOS constructor 

u eONFlGURATION-.-.eONFIGURATION new instance 

U eONFIGURATION .Destroy 

H eONFlGURATION::getDirectType 

// eONFIGURATION::geteonfigName 

U eONFIGURATION::name 

U eONFIGURATION::geteonfigStaius 

// eONFIGURATION::geteonfigManager 

u eONFIGURATlON-.-.getConfigLog 

II eONFIGURATION::geteonfigDescription 

// eONFIGURATION::dumpeonfigSummary 

// eONFIGURATION::listeonfigOperaiors 

u GONFIGURATION.-.-updateGonfigManager 

// eONFIGURATION::updateOonfigName 

// eONFIGURATION::updateeonfigStatus 

II eONFIGURATION::addtoeonfigurationLog - string 

II eONFIGUR.ATION::addtoeonfigurationLog - file 

// eONFIGURATION..updateGonfigDescription 

II eONFIGURATION:-.attach VobjeettoGonfig 

U eONFIGURATION::seteonferealionDate 

II GONFIGURATION::getGonfGreationDaic 

// GONFIGURATION::getDefaultVob)eci 

// GONFIGVRATION:GONFIGURATION 

II 

II Description 

II 

// Implementation of class GONFIGUR.ATION member functions. 

II 

II End - 

// Implementation Dependencies --- 


174 



















tinclude <GlobalEntities.h> 
•include <Directory.h> 

• include <streain.hxx> 


extern "C—" 

{ 

«i.iclude <8tring.h> 

} 

// End Implementation Dependencies - 

// Interface Dependencies - 

• ilndef -CONFIGURATIONJi 

• include ’’configuration.h" 

•endif 

• ifndef _DDBDEF1NES-H 

• include ’’ddbdef ines .h” 

•endif 

// End Interface Dependencies - 

extern Type *V'-OBJECT-OType: 
extern Type *C0NFlGURAT10N.0Typc; 

// ONTOS required constructor // 

C0NFIGURAT10N::C0NF1GURATI0N(AF>L ♦theAPL) : (theAPL) 

{ 

}•. 

// AVu' Instance Constructors // 

CONFIGURATION: CONFIGURATION(cliar *nanie. 

cFiar *managcr):(namc) 


// Summary --- 

// 

// Constructs a persistent COXFIGl RATIOS' object. This object 
II contains management (header information) about a COS FIG [’RATIOS 
II and a select group of modules in the configuration 
1 / 

II Parameter 

II 

II name 

II 

II A pointer to a character string 

II 

II manager 

II 


175 









Ij A pointer to a character string. 

II 

// Functional Description 

II 

II Copies the manager’s name into private data member. Initializes 
II ike description and log entry to null and creates a dictionary to 
II hold the configuration modules. 

II 

// End - 


{ 

initDirectType(CONFIGURATION-OType); 
configjnanager = new char[strlen(manager)+l]; 
strcpy(config_manager, manager); 
config^tatus = ’A’; 
configjium.vobjects = 0; 

ConfCreationDate = setConfCreationDate(); 

config-description.initToNull(); 

config Jog-entry. initToNull(); 

IheVersioned -Object.ini tToNullO; 

putObject(); 


} 

// End Constructor for CONFIGURATION-CONFIGURATION 
II Member Functions // 

void CONFIGURAT10N::Destrov(Boolean aborted) 

{ 

delete con fig-manager; 
if (aborted) 

{ 

Object:: Dest rov( aborted); 

} 

} 

Type ♦C0NFIGURAT10N::getDirertTvpe() 

{ 

return CONFIGURATION-OTvpe; 

} 

void CON FIG U RATION : get ConfigNameO 

{ 

Directory ‘directory: 
char *name; 

ifjithis) 

{ 

cerr "<ERR0R: cannot gat the nave of a null C01iFIGURATI0R>\n' 
return; 


176 











} 

name = Name(); 

OC-getNameComponents(name, irdirectory, tname); 
cout name <C "\n"; 

} 

char ♦CONFIGURATION::name() 

{ 

Directory ♦directory; 
char ♦name; 

name = Name(); 

OC-getNameComponents(name, iidirectory, tname); 
return name; 

} 

void CONFlGURATION;:getConfigStatus() 

{ 

iff !this) 

{ 

cerr •C ‘'<ERR0R: cannot gat the Status ol a null Configuration>\n" 
return; 

} 

cout config-status "\n"; 

} 


void CON FIG U RATION: :getConfigManager{) 

{ 

ifflthis) 

{ 

cerr ■C "<ERROR: cannot get the Manager ot a null Coniiguration>\n 
return; 

} 

cout C configjnanager "\n": 

} 


void (’ONFIGI RATION getConliKLogf) 

{ 

if; 'this) 

{ 

cerr -C "<ERR0R: cauinot dump the Log of a null Conf iguration>\n", 
return; 

} 

if ('config Jog_entry) 

( 

cerr <C "<Cannot display an empty log>\n''; 
return; 

} 

else 

{ 


ITT 




TEXT-OBJECT* myTextObject = (TEXT.OBJECT*)configJogjgntry.Binding(this); 
myTextObject —♦ text(cout); 

} 

} 

void CON FIG U RATION: :getConfigDescription() 

{ 

if(!this) 

{ 

cerr C "<ERROR: cannot gat the description of a null Conliguration>\n"; 
return; 

. } 

if (Iconfig-description) 

{ 

cerr ^ "<Thi8 configuration does not contain a de8cription>\n"; 
return; 

} 

else 

{ 

TEXT.OBJECT* myTextObject = (TEXT-OBJECT*)configjdescription.Binding(this); 
myTextObject —♦ text(cout); 

} 

} 


void CONFIGURATION ::dumpConrigSummarv{) 

{ 

int i=0; 

cerr "Creation Date: "; 

cout c; ctime(4;ConfCreationDate) "\n"; 

cerr C "Manager: "; 

getConfigManager(); 

if(! the Versioned-Object) 

{ 

cerr < "VOBJECT lame: "; 
cerr <g; ' 'lOME ASSIGNED "; 

for (i=0;i<PRlNT.VERSION-I,OCATlON -strleiiC'VOBJECT Name: NONE ASSIGNED ");i++) 
cout <C " 

cerr <g; "Version Number: ”; 
cerr < "N0NE\n"; 

} 

else 

{ 

V.OBJECT *vobjectPtr = (V-OBJECT*) theVersioncd Object Binding(this); 
cerr < "VOBJECT Name: ", 
cout “C vobjectPtr —getNamej); 

for (i = 0;i<PRlNT.VERS10N-LOCAT10N - strlen(vobjectPtr-*getName()),i + + ) 
cout < " ": 

cerr "C "Version Number: "; 

cout vobjectPtr — get Version Number(); 

} 


178 



cout <C "Configuration Dascription follons: 

\n===: ================== = = ===========\n"; 

getConfigDescriptionO; 

} 

void CON FIGURATION ::listConfigOperators() 

{ , 

if(! the Versioned .Object) 

{ 

cerr 'C "This configuration does not contain a v.object"; 

} 

else 

{ 

V.OBJECT ♦theVObjectPtr = 

(V.OBJECT*) theVersioned.Object.Binding(this); 
theVObjectPtr —► getVObjName(); 
theVObjectPtr —♦ listOperatorNames(); 

} 


void CONFIGURATION::updateConfigManager(cljar *new.config.manager) 

{ 

if(!this) 

{ 

cerr "<ERROR: cannot change the manager of a null C0NFIGURATI01I>\n" 
return; 

, } 

if(configJT»anager) 

{ 

strcpy(config jnanager, ""); 

} 

con fig jnanager = new char[strlen(new.configjnanager)-f 1); 
strcpy(configJnanager, new.configjnanager); 
putObject(); 


void CONFIGURAT10N;:up(iateConrigNatne(char ♦new.config.nanie) 

{ 

if(!this) 

{ 

cerr < "<ERROR; cannot change the name of a HULL CONFIGURATION>\n"; 
return; 

} 

N amc( new.config Jiame); 

} 


void CONFIGURATION::updateConfigStatus{char new.config.status) 

{ 


179 







if(!thi8) 

{ 

cerr < "<ERROR: cannot change the status of a null COIFIGURATIOII>\n"; 
return; 

} 

configjBtatus = newjconfig^tatus; 

} 


void CONFIGURATION::addtoConfigLog(char *newJog_entry) 

if( Iconfig Jog-entry) 

{ 

TEXT-OBJECT ♦textObjectPtr = new TEXTX>BJECT(); 
textObjectPtr —► append(new Jogjentry); 
configJog-entry.Reset(textObjectPtr, this); 

} 

else 

{ 

TEXT-OBJECT ♦textObjectPtr = 

(TEXT-OBJECT*) configJog-entry.Binding{this); 
textObjectPtr —• append(new Jogjentry); 

} 

putObject(); 

} 

void CONFIGURATION::addtoConfigLog(ifstreami: input-file_stream) 

if(!configJog-entry) 

{ 

TEXT.OBJECT *textObjectPtr = new TEXT jOBJECT(); 
textObjectPtr —* append(input-file-Stream); 
config-descriptlon. Reset (textObjectPtr, this); 

} 

else 

{ 

TEXT-OBJECT ♦textObjectPtr = 

(TEXT-OBJECT*) configJog-entry.Binding(this); 
textObjectPtr —> append(input-file.streani); 

} 

putObject(); 

} 


void CONFIGURATION::updateConfigDescription(char *fileName, ifstream.t file_stream 

{ 

if(!config-description) 

{ 

TEXT-OBJECT *textObjectPtr = new TEXTDBJECT(); 
textObjectPtr —• append(fileName, input-filejstream); 


180 





config-description.Reset(textObjectPtr, this); 

} 

else 

{ 

TEXT.OBJECT ♦textObjectPtr = 

(TEXT-OBJECT*) config-descriptton.Binding(this); 
textObjectPtr —♦ resetTheText(); 
textObjectPtr —• append(fileName, inputJile.stream); 

} 

putObject(); 

} 

V-OBJECT ♦CONFIGURATION::updateV'objectAttachment() 

{ 

if (!this) 

{ 

cerr "<ERR0R; cannot set the V-object of a null conf iguration\n" 
return NULL; 

} 

V’-OBJECT ♦vobjectPtr = gctDefault\'object(); 
if (vobjectPtr) 

{ 

THREAD ♦IhreadPtr = (THREAD ♦)OCJookup(vobjectPtr—getNanie()): 
if (threadPtr) 

{ 

vobjectPtr = threadPtr—current(); 
theVersioned-Object.Reset(vobjectF’tr,this); 
putObject(); 

} 

} 

return vobjectPtr; 

} 

void CONFlGURATION::attach\'objecttoConfig(V-OBJECT *theV-Object) 

{ 

if (!this) 

{ 

cerr <§; "<ERR0R: cannot set the V-object of a null configuration\n’' 
return; 

} 

if {!theV-Object) 

{ 

cerr <C "<ERROR: cannot give to a configuration a null V-object>\n' 

} 

the Versioned -Object ini tToN ull(): 

the Versioned-Object. Reset (t he V JDbject, this); 

) 

//Member Functton // 

time_t CON EIGURATION::sctConfCreatioiiDateO 


181 





{ 

time.t mytloc=0; 
time.t theTime; 

return theTime = time(mytloc); 

} 

// End - 


// Member Funciton // 

time t CONFIGURATION::getConfCreationDate() 

{ 

return ConfCreationDate; 

} 

// Member Funciton // 

V-OBJECT ♦ CONFIGURAT10N::getDefaultVobject() 

{ 

return (V.OBJECT *)(Entity »)theV'ersioned Object. BirKiing( this) 

} 

// End - 

if end functions 


182 










// File Header - 

// . 

/!.Filename .; ddbdefines.h 

ll-SCCSID .; J.3 

If .Release No....: 1 

//.Dale .; 9/16/91 

//.Author .; Garry Lewis 

II .; Drew Dwyer 

11 .Compiler .; Glockenspiel C++ 2.1 

n .•• 

// End header comments - 

#ifndel _DDBDEFINESJI 
#deline -DDBDEFINES.H 

// sees ID follows: will compile to place date/time stamp in object file 
static char ddbdefinesJiJSccsldQ = "fl(#)ddbdef ines .h 1.3\t9/16/91"; 

// Contents --———-___ 

II 

II Number Defines for Evaluations functions 

If 

II Description 

II 

II These ^defines are all designed just to pass information back and forth 
II between the main program and the modules which evaluate the command line 
II for what function to run. There are basically three types of function 
II arguments CONFIGURATION arguments - beginning with a ’C’, PROTOTYPE 
II arguments - beginning with a ’P’, and VOBJECTfunctions - beginning 
II with a ’V’. All arguments are exactly 3 characters in length and must 
II conform to one of the valid arguments in the designed interface. All 
II other arguments will be invalid and return Kinvalid Function> to the 
II Standard I/O. 

If 

II 

u End - 

// Interface Dependencies - 

II 

u NONE 

// 

// End Interfaee Dependencies - 

#delin« PRINTJCONFIGLOCATION 20 
#d«line PRINT .VERSION XOCATION 50 
#deline MAXXINEXENGTH 1024 
#d«f in* COMMAND.TABLE.SIZE 50 
#define SUCCESS TRUE 
#delin« FAILED FALSE 




















#defin« LIST-PROTOTYPES 1 
#deline LONGXIST.PROTOTYPES 81230 
#deline GET.PROTOTYPE.LEADER 2 
#d*fine GET.PROTOTYPELDESCRIPTION 3 
•define RETRIEVE.PROTOTYPET)ATE 5 
•define INSERT-PROTOTYPE 6 
•define UPDATE-PROTOTYPEXEADER 7 
•define UPDATE-PROTOTYPE-DESC 8 
•define UPDATE-PROTOTYPE-NAME 9 
•define GETXATEST-CONFIGURATION 10 
•define DUMP-PROTOTYPE-SUMMARY 987 

•define LIST-CONFIGURATIONS 21 

•define DUMP-CONFIGURATION-OPERATORS 91372 

•define ADD-CONFIGURATION-OPERATORS 91378 

•define LONGXIST-CONFIGURATION-OPERATORS 92351 

•define LIST-CONFIGURATION-DEFAULT-OPERATOR 6189 

•define LIST-CONFIGURATION.OPERATORS 91375 

•define UPDATE-CONFIGURATION-NAME 22 

•define GET-CONFIGURATION-DESCRIPTION 23 

•define INSERT-CONFIGURATION 24 

•define UPDATE-CONFIGURATIONXESCRIPTION 25 

•define GET-CONFIGURATION-MANAGER 26 

•define UPDATE-CONFIGURATIONJVIANAGER 27 

•define GET-CONFIGURATION-DATE 28 

•define GET-CONFIGURATION-CHANGED 29 

•define POST-CONFIGURATION-LOG 30 

•define GET-CONFIGURATION.LOG 31 

•define ATTACH-OPERATOR 32 

•define DUMP-CONFIGURATION-SUMMARY 33 

•define RELEASE-CONFIGURATION.LOCK 8124 

•define LIST-OPERATORS 41 
•define GET.VOBJECT.DESCRIPTION 42 
•define GET-VOBJECT-DATE 43 
•define GET-VOBJECT-VERSIONS 44 
•define GET.VOBJECTXOCK 45 
•define GET-VOBJECT.VERSION 46 
•define DUMP.VOBJECT-SUMMARY 47 
•define GET-VOBJECT.POSTSCRIPT 48 
•define GET-VOBJECT.GRAPH 49 
•define GET-VOBJECT-IMPLEMENTAHON 50 
•define GET.VOBJECT.SPECIFICATION 51 
•define GET-VOBJECTJSOURCE 52 
•define UPDATE-VOBJECT-DESCRIPTION 53 
•define ADD.VOBJECT.AND-SUBTREE 58 
•define DUMP.VOBJECT-FILES 59 
•define DUMP.VOBJECT.TREE 60 
•define LONG.LIST.CHILDREN 61 
•define LONG. LIST-PA RENTS 62 
•define LONG.LIST-OPERATORS 32981 


184 




#deline RELEASE-SUBTREEXOCK 8281 
#deliM RELEASE.OPERATOR-LOCK 8992 

•define ERROR-IN.EVALUATION 9999 

•define LENGTH-PS-EXT 3 
•define LENGTH_GRAPH-EXT 6 
•define LENGTH.1MP.EXT 9 
•define LENGTH-SPEC-EXT 10 
•define LENGTH-SOURCELEXT 2 

•define PSJEXT ".ps" 

•define GRAPH_EXT ".graph" 

•define IMPJEXT ".iBp.pedl" 

•define SPEC-EXT ".spec.psdl" 

•define SOURC E E XT ".a" 

•define DESIGN-DATABASE-DIRECTORY "ADesignDat abase" 
•define PROTOTYPE-LIST "PrototypeList" 

•define LONG-LIST-PROTOTYPE-UPC "PLL" 

•define LONG-LIST-PROTOTYPE-LC "pll" 

•define LIST.PROTOTYPE-UPC "PLM" 

•define LIST.PROTOTYPE-LC "pin" 

•define INSERT-PROTOTYPE-UPC "PIP" 

•define INSERT-PROTOTYPE.LC "pip" 

•define PROTOTYPE-EXT ".prj" 

•endif // -DDBDEFINES.H 


18.5 




// File Header -- 

//-■.-• 

I!.Filename .; directory.k 

//.sees ID . : l.S 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .: Glockenspiel C++ 2.1 

// . •• 

// End header comments --- 

#ilndel _DIRECTORY_H 
#define _DIRECTORY_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char directory_h.Sccsld[] = "C(#)dtrectory .h 1.3\t9/16/91" 
// Gontents -- 

II 

// DIREGTORY HEADER 

// 

// Description 

II 

// Defines class DIREGTORY. 

II 

// End - 

// Interface Dependencies - 

#ifndef _TREENODE-H 
#include ’’treenode.h" 

#endil 

// End Interface Dependencies -—-- 

class DIRECTORY 

{ 

private: 

TREENODEJinkedlist operator_nodes; 
public: 

DIRECTORYO {}; 

void read.directory(char ♦root.oper); 

void updatetimestampO; 

TREENODE ♦find.treenode(cliar ♦); 

TREENODEJinkedlist getOperatorList(); 

}; 























// Description -- 

// 

// Defines class DIRECTORY. Class DIRECTORY is a non- 
II persistent class. 

II 

II Constructor 

n 

U DIRECTORY 

II 

II Public Members 

II 

II read.directory 

II 

II Read a list of file from a directory defined by the environment 
II variable PROTOTYPE, creates a corresponding list of operator nodes. 

II 

II updateiimestamp 

// 

// Updates the nodes time to reflect the time of the file 
II most recently updated. 

II 

// findJrcenode 

II 

II Find a given node in the list of operator nodes. 

II 

II getOperatorList 

II 

II Returns the operator node list. 

II 

II End Description - 

#endil // header file 


187 






// Ftle Header --- 

// . 

/!.Filename .; directory.cxx 

I/.sees ID .. 1. 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

//.; Drew Dwyer 

//.Compiler .; Glockenspiel C++ 2.1 

// . 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char directory.cxx_SccsId[] = "C(#)directory.cii 1.3\t9/16/91" 

// eonients —---— 

// 

// DIREeTORY::read.directory 
II DIREeTORY::updatetimestamp 
II DlREeTORY::find.treenode 
II DIREeTORY:igetOperatorList 

n 

II Description 

// 

u IMPLEMENTS class DIREeTORY eONSTRUeTORS. 

fl 

U End - 

// Interface Dependencies --- 

#include <8tr«a]n.hxx> 

extern "C—" 

{ 

#include <stddel.h> 

•include <8tdlib.h> 

•include <8tring.h> 

•include <dirent.h> 

•include <8y8/8tat.h> 

• include <tiiiie.h> 

) 

• ilndef -DIRECTORYJi 

• include "directory .h” 

•endif 

• ifndef -DDBDEFINES-H 

• include "ddbdef inee .h" 

•endif 

// - End Interface Dependencies - 


188 


















extern char *dirNamePtr; 

void DIRECTORY::reacLdirectory(char ♦root.oper) 

{ 


//- - 

// /n body comment: 

II 

II Here I will create the list to hold those filenames that 

II contain (as a substring) the operator name. This method 

II will also scan those files that do match the pattern input 

II and throw out those with the .ps, .graph, .imp.psdl, .spec.psdl 

II and .a files. What I hope will remain is a list of only those 

II filenames which represent that operator node and it’s 

II associated SUBTREE operator nodes. We’ll then turn around and 

II process the resulting list into an operator tree structure and 

II compare against the database schema for storage of the 

II .ps, graph, .spec.psdl, .imp.psdl, and .a text objects into 

// the database as collected sets of COMPONENT objects. 

11 

If - 

DIR *dirp; 

struct dirent ♦capsdirent; 

char ♦path[MAX-LINE-LENGTH]; 

char ♦pschk = NULL; 

char ♦graphchk =NULL; 

char ♦specchk = NULL; 

char ♦impchk = NULL; 

cliar ♦sourcechk =NULL; 

TREENODE ♦operatornode =NULL; 
char ♦filename = NULL; 
strcpy(path,dirNamePtr); 
dirp = opendir(dirNamePtr); 
int count=0; 

TREENODE ♦temp; 

for (capsdirent = readdir(dirp); capsdirent NULL; 
capsdirent = readdir(dirp)) 

{ 

filename=capsdirent—*d jiame; 

pschk = capsdirent —>d_name + strlen(capsdirent —>djiame) - 3; 
graphchk = capsdirent —‘djiame + strlen(capsdirent —‘djiame) - 6; 
specchk = capsdirent —‘d Jiame + strlen(capsdirent —‘djiame) - 10; 
impchk = capsdirent —‘djiame + strlen(capsdirpnt —►djiame) - 9; 
sourcechk = capsdirent —‘djiame + strlen(capsdirent —+d_name) - 2; 


if (strcmp(pschk," .pB")==0) 








{ 

pschk[0] = ’\0’; 


} , 

else if {strcmp(graphchk," .graph" )==0) 

{ 


graphchk[0] = ’\0’; 


} . 

else if (strcnip(specchk,".«pec.p8dl")==0) 
{ 


8pecchk[0] = ’\0’; 

} . 

else if (strcmp(impchk,". imp.pa<il")==0) 

{ 


impchk[0] = ’\0’; 

} , 

else if (strcmp(sourcechk," .a")==0) 
{ 


sourcechk[0] = ’\0’; 

} 

if (strncmp(capsdirent —»d_name,root_oper,strlen(root-oper))==0) 

{ 


if (!(temp=find-treenode(capsdirent—»d Jiame))) 

{ 

operatornode = new TREENODE(capsdirenl—*d_nanie,NULL) 
operator jiodes.insert(operatornode); 

} 

} 

} 

closedir(dirp); 

} 

void DIRECTORY::updatetimestamp() 

{ 

DIR ♦dirp; 
struct dirent ♦filep; 

struct stat timestats; 

char ♦psfilename = NULL; 
char ♦graphfilename = NULL; 
char ♦specfilename = NULL; 
char ♦impfilename = NULL; 
char ♦sourcefilename = NULL; 
char *path[MAX-LINE-LENGTH]; 
char ♦nodejiame = NULL; 

TREENODE ♦node; 
long temptime = 0; 
long filetime = 0; 
dirp = opendir(dirNamePtr); 


190 




slistiterator OperatorPtr(operator _aodes); 


while (node = OperatorPtr()) 

{ 


nodejiame = node—‘getnameO; 

psfilename = new char [strlen(node_name)+3]; 
strcpy (psfilename,node_name); 
strcat (psfilename," .ps"); 

graphfilename = new char [strlen(nodejiame)-l-6]; 
strcpy (graphfilename,node-name); 
strcat (graphfilename,".graph"); 

impfilename = new char [strlen(node.name)+9]; 
strcpy (impfilename,node_name); 
strcat (impfilename,". imp.psdl"); 

specfilename — new char [strlen(node_name)+10]; 
strcpy (specfilename,node-name); 
strcat (specfilename," . spec. psdl"); 

sourcefilename = new char [strlen(node-name)+2]; 
strcpy (sourcefilename,nodejname); 
strcat (sourcefilename,". a"): 

filep = readdir(dirp); 

while ((filep / NULL) kL (!(strcmp(filep—>d-name,psfilename) ==0))) 

{ 

filep = readdir(dirp): 

} 

if ((filep ^ NULL) && (strcmp(filep—d-name,psfilename)==0)l 

{ 

strcpy (path,dirNamePtr); 

strcat (path,"/"); 

strcat (path,filep—>d-nanie); 

stat(path,&:,timestats); 

filetime = timestats.st.ctime; 

temptime = node—*get-long-time(); 

node—*updatetimestamp(temptime < filetime ? filctime : temptime); 

} 

rewinddir(dirp); 
filep = readdir(dirp); 

while ((filep ^ NULL) kk (!(strcmp(filep—d-name.graphfilename) ==0))) 

{ 

filep = readdir(dirp); 

} 

if ((filep 9 ^ NULL) A'i' (strcmp(filep—>d_name,graphfilename)==0)) 


101 









strcpy (pathjdirNamePtr); 

strcat (path,"/"); 

strcat (path,filep—*d-name); 

stat(path,&timestats); 

filetime = timestats.st.ctime; 

temptime = node—►get_long_time(); 

node—*updatetimestamp(temptime < filetime ? filetime : temptime); 

} 

rewinddir(dirp); 
filep = readdir(dirp); 

while ((filep / NULL) ick, (!(strcmp(filep—►d-name,impfilename)==0))) 

{ 

filep = readdir(dirp); 

} 

if ((filep ^ NULL) icic (strcmp(filep—►d_name,impfilename)==0)) 

{ 

strcpy (path,dirNamePtr); 

strcat (path,"/"); 

strcat (path,filep—►d.name); 

stat(path,&;timestats); 

filetime = timestats.st.ctime; 

temptime = node—»get.long-time(); 

node-*updatetimestamp(temptime < filetime ? filetime ; templime): 

} 

rewinddir(dirp); 
filep = readdir(dirp); 

while ((filep ^ NULL) kk (!(strcmp(filep—»djiame,specfilename) ==0))) 

{ 

filep = readdir(dirp): 

, } 

if ((filep ^ NULL) kk {strcmp(filep—•djiame,specfilename)==0)) 

{ 

strcpy (path,dirNamePtr); 

strcat (path,"/"); 

strcat (path,filep—‘djiame); 

stat(path,i:timestats); 

filetime = timestats.st.ctime; 

temptime = node—‘get.long.time(); 

node—‘updatetimestamp(temptime < filetime ? filetime : temptime); 

} 

rewinddir(dirp); 
filep = readdir(dirp); 

while ((filep ^ NULL) kk (!(strcmp(filep—*djiame,sourcefilename)==0))) 

{ 

filep = readdir(dirp); 

} 

if ((filep NULL) kk (strcmp(filep—d Jiame,sourcefilename) = =0)) 

{ 


192 






strcpy (path,dirNamePtr); 

strcat (path,"/"); 

strcat (path,filep—►d_name); 

stat(path,&:timestats); 

filetime = timestats.st.ctime; 

temptime = node—* get Jong.time(); 

node—►updatetimestamp(temptime < filetime ? filetime ; temptime); 

} 

rewinddir(dirp); 

} 

closedir(dirp); 

} 


TREENODE ♦DlRECTORY:;find.treenode(char ♦node_name) 

{ 

slistiterator listJterator(operatormodes); 

TREENODE ♦tnode; 
while (tnode=:list JteratorO) 

if (strcmp(tnode—getnanie(),node-name)==0) 
return tnode; 
return NULL; 

} 


TREENODEJinkedlist DIRECTORY::getOperatorList() 

{ 

return operator-nodes; 

} 


193 





// File Header -- 

// . ■■ 

I!.Filename .; evaluation.h 

11.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// . Drew Dwyer 

//.eomyiler .; Glockenspiel C++ 2.1 

// . 

// End header comments - 

#ifndel -EVALUATION _H 
#def ine -EVALUATIONJH 

// sees ID follows: will compile to place date/time stamp in object file 

static char evaluation_h-SccsId[] = "fi(<()evaluation .h 1.3\t9/16/91" 

// Gontents -- 

// 

// Prototypes of functions to evaluate the command line TAG 
// argument and set the appropriate case statement in main. 

// 

// 

// End - 

// Interface Dependencies --— 

// 

// NONE 
// ^ 

// End Interface Dependencies ——-- 

cliar charupper(char c); 
char ♦upper(cliar *argument); 

int evaluate.configuration Junctioii(char ♦function, int arguments); 

Int evaluate.vobject J'unction(cIiar ♦function, int arguments); 
int evaluate.prototype Junction(cIiar ♦function, int arguments): 

// Description ----— 

// 

// charupper 

// 

// Gonverts lower case letters to upper case. 

// 

// upper 

// 

// Gonverts the command line TAG field to upper case. Galls 
// charupper to convert each letter. 

// 

// evaluate-Configuration.function 


191 


















// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 


Determines the appropriate case statement to be executed for 
database operation pertaining to configurations. 

evaluate,vobject,function 

Determines the appropriate case statement to be executed for 
database operations pertaining to versioned objects. 

evaluate,prototype.function 

Determines the appropriate case statement to be executed for 
database operations pertaining to prototypes. 

End Description -— 


#endii // ..EVALUATION,!! 






// File Header - 

// . ■■ 

//.Filename .; evaluation.cxx 

11 sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .: Garry Lewis 

//.; Drew Dwyer 

//.eompiler .; Glockenspiel C++ S.l 

II . 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char evaluation_cxx_SccsId[j = "C(#)evaluation.cxx 1.3\t9/16/91‘‘ 

// Gontenis --- 

// 

// charupper 

H ^PPer 

// evaluatc-configuration Junction 
// evaluate.vobject.function 
// evaluate.prototype.function 

II 

// Description 

II 

// Defines FUNCTIONS FOR SWITOII STMT IN M.' LK. 

II 

// This information is required to evaluate the command 
// line input and reconstruct the proper commands internal 
// to the design database program. 

II 

II 

// End - 

// Interface Dependencies - 

#ilndef _X)DnDEFINES-H 
#include ’’ddbdelines .h" 

#endif 

#include <8treajB.hxx> 
extern "C—" 

{ 

#include <8tdlib.h> 

•include <8tring.h> 

•include <ctype.h> 

} 


lOf) 


• ifndef .-EVALUATION_H 





















#include "evaluation.h" 
tendil 


// End Interface Dependencies - 

char charupper(char c) 

{ 

return islower(c) ? (c-’a’+’A’) : c; // change char to upper case 

}. 


char +upper(char ♦argument) 

{ , 

int i; 

for (i=0; i<strlen(argument); i++) // convert argument to upper case 

argument[i] = charupper(argument[i]); // call charupper to convert each one 
return argument; 

}; 


int evaluate-configuration-function(char ♦function, int arguments) 

{ . 

if (strcmp(function,"CLH")==0) 

{ . 

if (arguments< 1 || arguments >1) 

{ 

cerr "<ERR0R: Invalid number arguments for List Configiirations>\n"; 

return ERRORJN.EVALUATION; 

} 

else 

return LIST.CONFIGURATIONS; // tell mainfj to run List.Prototypes 

} . 

else if (strcmp(function,"CU¥" )==0) 

{ , 

if (arguments<3 || arguments>3) 

{ 

cerr ■C "<ERR0R; Invalid number of arguments for Update Configuration Name>\n" 

return ERRORJN-EVALUAT 10N; 

} 

return UPDATE-CONFIGURATION-NAME; 

} . 

else if (strcmp(function,"CGD")==0) 

{ . 

if (arguments<2 1| arguments >2) 

{ 

cerr <C "<ERROR; Invalid number arguments for Get Configuration Description>\n 

return ERRORJN-EVALUATION; 

} 

return GET-CONFIGURATION-DESCRIPTION; 

} 

else if (strcmp(function,"CIC")==0) 







{ . 

if (!arguments>0) 

{ 

cerr <g: "<ERROR: lot enough argunents for Insert Configuration>\n"; 
return ERRORJN_EVALUATION; 

} 

return INSERT-CONFIGURATION; 

} . 

else if (strcmp(function,"CUD")==0) 

{ , 

if (arguments<3 || arguments>3) 

{ 

cerr "<ERR0R: Invalid nunber arguments for Update Configuration 
Descript ion>\n"; 

return ERRORJN-EVALUATION; 

} 

return U PDATE-CON FIG U RATION .DESCRIPTION; 

} . 

else if (strcmp(function,"CGM")==0) 

{ _ 

if (arguments<2 |{ arguments >2) 

{ 

cerr ■C "<ERR0R: Invalid number arguments for Get Configuration Majiager>\n" 

return ERRORJN.EVALUATION; 

} 

return GET.CONFIGURATION.MANAGER; 

} 

else if (slrcmp(function,"CDT")==0) 

{ , 

if {arguments<3 || arguments>3) 

{ 

cerr ■C "<ERR0R: Invalid number arguments for Checkout Configuration>\n"; 

return ERRORJN.EVALUATION; 

} 

return DUMP.CONFIGURATION.OPERATORS; 

} 

else if (strcmp(function,"CRL")==0) 

{ , 

if (arguments<2 || arguments>2) 

{ 

cerr "<ERROR: Invalid number 2 Lrguments for Release Configuration Lock>\n 

return ERRORJN.EVALUATION; 

} 

return RELEASE-CONFIGURATIONXOCK; 

} , 

else if (strcmp{function,"CAA")==0) 

{ _ 

if (arguments<2 |1 arguments>2) 

{ 

cerr <C "<ERROR: Invalid number arguments for Checkin Configuration>\n"; 

return ERRORJN.EVALUATION; 


1!)8 





} 

return ADD.CONFIGURATION.OPERATORS; 

} , 

else if (strcmp(function,"CLL")==0) 

{ , 

if (arguments<2 H arguments>2) 

{ 

cerr "<ERROR: Invalid number arguments lor List Configuration Operators>\n" 
return ERRORJN.EVALUATION; 

} 

return LONG_LIST.CONFIGURATION.OPERATORS; 

} 

else if (strcmp(funclion,"CLV")==0) 

{ . 

if (arguments<2 |1 arguments>2) 

{ 

cerr C "<ERR0R: Invalid number curguments for List Default Configuration 
Operator>\n"; 

return ERRORJN-EVALUATION, 

} 

return LIST.CONFIGURATION.DEFAULT.OPERATOR; 

} . 

else if (strcmp(function,"CL0")==0) 

{ , 

if (arguments<2 || arguments>2) 

{ 

cerr "<ERR0R: Invalid number arguments for List Configuration Operators>\n" 

return ERRORJiV-EVALUATIOiN'; 

} 

return LIST.CONFIGURATION.OPERATORS; 

} . 

else if (strcnip(function,"CUM")==0) 

{ , 

if (arguments<3 || arguments>3) 

{ 

cerr <C "<ERROR: Invalid number arguments lor Update Configuration Manager>\n" 

return ERRORJN J:VALUAT10N; 

} 

return UPDATE.CONFIGURATION-MANAGER; 

} , 

else if (slrcmp(function,"CDA")==0) 

{ , 

if (arguments<2 1| arguments >2) 

{ 

cerr "<ERR0R: Invalid number of arguments for Get Configuration Date>\n"; 
return ERRORJN-EVALUATION; 

} 

return GET.CONFIGURATION-DATE; 

} 

else if (strcmp(function,"CDS")==0) 

{ 





if (arguments<2 || arguments >2) 

{ 

cerr "<ERROR: Invalid number arguments ...Dump Configuration Summary>\n" 

return ERRORJN.EVALUATION; 

} 

return DUMP-CONFIGURATIONJSUMMARY; 

} 

else if (strcmp(function,"CDC")==0) 

{ , 

if (arguments<2 || arguments >2) 

{ 

cerr <C "<ERROR: Invalid number arguments ...Get Last Date Changed>\n"; 

return ERRORJNJEVALUATION; 

} 

return GET.CONFIGURATION.CHANGED; 

} , 

else if (strcmp(function,"CPL") ==0) 

{ _ 

if (arguments<3 || arguments>3) 

{ 

cerr <C "<ERRQR: Invalid number arguments lor Post to Configuration Log>\n" 

return ERRORJN.EVALUATION; 

} 

return POST.CONFIG URATIONXOG; 

} , 

else if (strcmp(function,"CGL")==0) 

{ , 

if (arguments<2 || arguments >2) 

t 

\ 

cerr <C "<ERR0R; Invalid number arguments for Get Configuration Log>\n''. 

return ERRORJN.EVALUATION; 

} 

return GET.CONFIGURATION.LOG; 

} , 

else if (strcmp(function,"CA0")==0) 

{ _ 

if (arguments<3 || arguments >4) 

{ 

cerr <C "<ERR0R: lot enough arguments for Attach Operators>\n"; 

return ERRORJN.EVALUATION; 

} 

return ATTACH .OPERATOR, 

} 

else 

{ 

cerr "Error in Configuration Command syntax \n\n"; 

} 


nt evaluate.vobject Junction(char ♦function, int arguments) 


200 





if (slrcmp(function,"VLO")==0) 

{ . 

if (arguments<2 || arguments >3) 

{ 

cerr "<ERROR: Invalid number arguments ioz List Operators>\n"; 

return ERRORJN-EVALUATION; 

} 

return LIST.OPERATORS; // tell matn() to run Ltsi Operators 

) 

else if (strcmp(function,"VUD")==0) 

{ , 

if (!arguments>0) 

{ 

cerr -C "<ERR0R: Invalid number of arguments for Update VOBJECT Description>\n" 

return ERRORJN-EVALUATION; 

} 

return UPDATE.VOBJECT-DESCRIPTION; 

} 

else if (strcmp(function,"VGD")==0) 

{ _ 

if {!arguments>0) 

{ 

cerr <C "<ERROR: lot enough arguments to Get VOBJECT Description>\n": 

return ERRORJN-EVALUATION; 

} 

return GET-VOBJECT J)ESCR1PT10N; 


else if (strcmp(function,"VDD")==0) 

{ 

if (!arguments>0) 

{ 

cerr "<ERR0R; Invalid number of arguments for Get VOBJECT Date>\n"; 

return ERRORJN-EVALUATION, 

} 

return GET-VOBJECT JJATE; 

} 

else if (strcmp(function,"VGV")==0) 

{ 

if (arguments<2 || arguments >2) 

{ 

cerr "<ERROR: Invalid number arguments for Get VOBJECT Versions>\n"; 

return ERRORJN-EVALUATION; 

} 

return GET-VOBJECT .VERSIONS; 

} 

else if (strcmp(function,"VVV")=^=0) 

( 

if (arguments< 1 || arguments >1) 


201 








{ 

cerr <C "<ERROR: Invalid number of arguments for Get VOBJECT Current Version>\n' 

return ERRORJN.EVALUATION; 

} 

return GET.VOBJECT.VERSION; 

} 

else if (strcmp(function,"VGL")==0) 

{ 

if (arguments <2 || arguments >3) 

{ 

cerr <§; "<ERROR: Invalid number of arguments for Got VOBJECT Lock>\n"; 

return ERRORJN.EVALUATION; 

} 

return GET.VOBJECTXOCK; 

} 

else if (strcmp(function,"VDA") ==0) 

{ _ 

if (arguments<2 || arguments >3) 

{ 

cerr "<ERR0R; Invalid number of argiunents for Get VOBJECT Summary>\n"; 

return ERR0R.1N.EVALUAT10N; 

} 

return UUM P.\'0BJ ECTSUMMAR^'; 

} 

else if (strcmp(function,"VGP") ==0) 

{ . 

if (arguments <3 || arguments >4) 

{ 

cerr <C "<ERROR: Invalid number of eurguments for Get VOBJECT Postscript>\n"; 

return ERRORJN.EVALUATION; 

} 

return GET VOBJECT.POSTSCRIFT; 

} _ 

else if (strcmp(function,"VGG") ==0) 

{ , 

If (arguments <3 || arguments >4) 

{ 

cerr "<ERR0R; Invalid number of arguments for Get VOBJECT GRAPH>\n"; 

return ERRORJN.EVALUATION; 

) 

return GET.VOBJECT .GRAPH; 

} 

else if (sf rcmp(fimction,"VGI")==0) 

{ _ 

if (arguments <3 || arguments >4) 

{ 

cerr "<ERR0R: Invalid number of arguments for Get VOBJECT Implementation>\n" 


202 






return ERRORJN_EVALUATION; 

} 

return GET.VOBJECT JMPLEMENTATION; 


else if (strcmp(function,"VGC")==0) 

{ . 

if (arguments <3 || arguments >4) 

{ 

cerr •C "<ERROR; Invalid nuaibar of argunents for Get VOBJECT Specification>\n'' 

return ERR0RJN.EVALUAT10N; 

} 

return GET-VOBJECT^PECIFICATION; 

} 

else if (8trcmp(function,"VGS")==0) 

{ _ 

if (arguments <3 || arguments >4) 

{ 

cerr "<ERROR: Invalid number of arguments for Get VOBJECT Source>\n"; 

return ERRORJN.EVALUATION; 

} 

return GET.VOBJECT^OURCE; 

} ^ 

else if (strcmp(function,"VDS")==0) 

{ . 

if (arguments <2 || arguments >3) 

{ 

cerr "<ERROR; Invalid number of arguments for Dximp VOBJECT Source>\n‘'; 

return ERRORJN.EVALUATION; 

} 

return D U M P .VO BJ ECT ^ U M M A RY; 

} . 

else; if (strcmp(function,"VAA")==0) 

{ , 

if (areuments<2 || arguments >3) 

{ 

cerr <C "<ERR0R: Invalid number of arguments for Add VOBJECT Subtree>\n"; 

return ERRORJN.EVALl ATION; 

} 

return ADD.VOBJECTJ^ND.SUBTREE; 

} 

else if (strcmp(function,"VDF")==0) 

{ , 

if (arguments <3 || arguments >4) 

{ 

cerr "<ERROR: Invalid number of arguments for Dump VOBJECT FILE(S)>\n''; 

return ERRORJN.EVALUATION; 

} 

return DUMP.VOBJECT JILLS; 

} 

else if (strcmp(function,"VLL'') ==0) 


203 






{ , 

if (!arguments>l) 

{ 

cerr 'C "<ERROR: Invalid nuabar of arguments lor long list 0perator8>\n"; 

return ERRORJNJ:VALUAT10N; 

} 

return LONGXIST.OPERATORS; 

} . 

else if (strcmp(function,"VLO")—=0) 

{ , 

if (!arguments>l) 

{ 

cerr •C "<ERR0R: Invalid number of arguments for list Operators>\n"; 

return ERRORJN.EVALUATION; 

} 

return LIST.OPERATORS; 

} , 

else if (strcmp(function,"VLP") ==0) 

{ _ 

if (!arguments>l) 

{ 

cerr <C "<ERR0R: Invalid number of arguments for list Parent/Siblings>\n"; 

return ERRORJN.EVALUATION; 

} 

return LONG JLISTBARENTS; 

} 

else if (strcmp(function,"VLC")==0) 

{ , 

if (!arguments>l) 

{ 

cerr "<ERR0R: Invalid number of arguments for list Children>\n"; 

return ERRORJN.EVALUATION; 

} 

return LONG J.IST.CH1LDREN; 

} 

else if (strcmp(function,"VDT")==0) 

{ 

if (!arguments>l) 

{ 

cerr ^ "<ERR0R: Invalid number of arguments for Dump VOBJECT TREE FILE(S)>\n' 

return ERRORJN.EVALUATION; 

} 

return DUMP.VOBJECT.TREE; 

} 

else if (strcmp(function,"VR0")==0) 

{ , 

if (arguments <2 || arguments >3) 

{ 

cerr <?; "<ERR0R: Invalid number of arguments for Release Operator Lock>\n’'; 

return ERRORJN.EVALUATION; 

} 


204 






return RELEASE.OPERATORJLOCK; 

} 

else if (strcmp(function,"VRS")==0) 

{ , 

if (arguments <2 |1 arguments >3) 

{ 

cerr 'C ''<ERROR: Invalid number of arguments lor Release Operator Subtree 
Locks>\n"; 

return ERRORJN_EVALUATION; 

} 

return RELEASE^UBTREEXOCK; 

} 

else 

{ 

cerr "<<<Error in VOBJECT Command syntax>>> \n\n’'; 

} 


int cvaluate-prototvpeJ'unction(cliar ♦function, int arguments) 

{ 

if (strcmp(function,"PLH")==0) 

{ . 

if (!arguments==0) 

{ 

cerr -C "<ERROR; Too many arguments lor List Prototype llaines>\n’': 

return ERRORJN.EVALUATION; 

} 

else 

return LIST.PROTOTV'PES; // tdl main() to run List.Prototypes 

} _ 

else if (strcmp(function,"PLL") ==0) 

{ . 

if (!arguments==0) 

{ 

cerr -C "<ERR0R: Invalid number of arguments for Long List Prototypes>\n" 

return ERROR-IN-EVALUATION; 

} 

return LONGXIST-PROTOTYPES; 

} , 

else if (strcmp(function,"PDS")==0) 

{ _ 

if (arguments<l || arguments >1) 

{ 

cerr <C "<ERR0R: Invalid number of arguments lor Dump Prototype Summary>\ 

return ERRORJN-EVALUATION; 

} 

rcturnDUMPX ROTOT Y P E U M M A RY; 

} 







else if (strcmp(function,"PGL")==0) 

{ , 

if (arguments<l || arguments >1) 

{ 

cerr "<ERROR: Invalid number of arguments for Get Prototype Leader>\n"; 

return ERRORJN-EVALUATION; 

} 

return GET-PROTOTYPE_LEADER; 

} 

else if (8trcmp(function,"PGD")==0) 

{ . 

if (arguments<l || arguments >1) 

{ 


cerr "<ERROR; Invalid number arguments for Get Prototype Description>\n" 
return ERRORJN-EVALUATION; 

) 

return GET-PROTOTYPE JDESCRIPTION; 

} _ 

else if (strcmp(function,"PRD" ) ==0) 

{ _ 

if (arguments< 1 |1 arguments >1) 

{ 

cert "<ERR0R: Invalid number arguments for Retrieve Prototype Date>\n": 

return ERRORJN-EVALUATION; 

} 

return RETRIEVE-PROTOTYPEJDATE; 

} , 

else if (strcmp(funclion,"PIP" )==0) 

{ , 

if (!arguments>0) 

{ 

cerr ■C "<ERR0R: Invalid number arguments for Insert Prototype>\n"; 

return ERRORJN-EVALUATION; 

} 

return INSERT-PROTOTYPE; 

} , 

else if (strcmp(function,"PUL'‘)==0) 

{ , 

if (arguments<2 || arguments >2) 

{ 

cerr <tC "<ERR0R: Invalid number arguments for Update Leader>\n"; 

return ERRORJN-EVALUATION; 

} 

return UPDATEJPROTOTYPEXEADER; 

} 

else if (strcmp(function,"PUD")==0) 

{ 

if(! arguments= = l) 

{ 

cerr <C "<ERROR: Invalid number arguments for Update Description>\n"; 

return ERRORJN-EVALUATION; 


206 




} 

return UPDATE_PROTOTYPE-DESC; 

} 

else if (strcmp(function,"PUM")==0) 

{ 

if (! arguments==l) 

{ 

cerr <C "<ERROR: Invalid number arguments for Update Mame>\n"; 

return ERRORJN.EVALUATION; 

} 

return UPDATEJPROTOTYPEJVAME; 

} 

else if (strcmp(function,"PGC‘‘)==0) 

{ _ 

if (arguments< 1 || arguments>l) 

{ 

cerr ^ "<ERR0R: Invalid niunber arguments for Get_Latest_Configuration>\n' 

return ERROR.IN.EVALUATION; 

} 

return GET.LATESTXONFIGURATION; 

} 

else 

{ 

cerr "Error in Prototype Command syntax \n\n"; 

} 


207 





// File Header - 

//...■.: 

/!.Filename .; nodesupport.h 

//.sees ID .: l.S 

//.Release No....: 1 

//.Date ..■ 9/16/91 

//.Author .; Garry Lewis 

// . Drew Dwyer 

//.Compiler ..• Glockenspiel e++ 2.1 

//..... 

// Fnd header comments - 

#ilndef -NODESUPPORTJI 
#define —NODESUPPORT .H 


// sees ID follows: will compile to place datc/time stamp in 
// object file 

static char nodesupport Ji-Sccsld|] = "e(#)nodesupport. h 1.3\t9/16/91"; 

// Contents — - 

// 

// NODKSVPPPORT HEADER FILE 

// 

// Description 

// 

// SIMPLE NODE SUPPORT Functions 

// 

// End - - 

// Interface Dependencies — -- 

#ilndef _TREENODE_H 
#include "treenode.h" 

#endif 

// End Interface Dependencies ----- 

TREENODE* rootTind(TREEN’ODEJInkedlist list.to_searcli, const char* str) 
int strjsuftix-check(char* str,char ch); 
int proper^uper jtring(char* strl, char* str2); 

int proper.-super J'<ODE-check(TREENODE* node^itr, char* target jitring): 

// Description -- 

// 

// root^find 

// 

// Locates the root node associated with given operator name 

// 

// str.siiffir.rheck 


208 


















// 

// Locates the suffix of a gtven string. 

// 

// proper.super.string 

II 

II Determines whether one sirtng is a prefix of another string 
II (t.e., one operator is the child of another operator). 

II 

// proper.super^NODE.check 

II 

// Determines whether a gtven node should be added to the childltst 
II of a given operator name. 

II 

II End Description -- 

#endil // end nodesupport header file 


209 







// File Header -. 

// -.•• 

/!.Filename .; nodesupport.cxx 

U.sees ID .; 1.3 

I /.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .: Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// . 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char nodesupport.cxx_SccsId(] = •‘C(#)nodesupport. cxi 1.3\t9/16/91" 

// Gontents - 

// 

// rooFfind 
// str.suffii-check 
// proper.super.string 
// proper^super.NODE.check 

II 

// End - 

// Interface Dependencies - 

extern "C—" 

{ 

#include <string.h> 

} 

#if.idef -NODESUPPORT-H 
#include ”nr>desupport .h" 

#endif 

// End Interface Dependencies - -- 


TREENODE* root jind(TREENODE Jinkedlist list Jo-search, const char* str) 

// Summary --- 

// 

// this function returns the address of the NODE in the hst 
// that has its operator.name matching *str. 

II 

// End Summary - 


{ 

slist-Jterator ret jiodc( list .tosearch); 


210 




















TREENODE* node; 
while (ret-node()) 

{ 

node = ret jiode(); 

if ( !strcmp(str,node—*getname() ) ) return node; 

} 

return NULL; 

} 


int str^uffix.check(cbar* sti.char ch) 

// Summary - 

// 

// this function checks to see if the char at address sir is ch 
II and that ch only appears in the string ♦sir at this position. 

II Thus *str with ch = is of the form ’'.example with no more 
II periods” . 

n 

II End Summary —-— --- 

{ _ 

if (♦str ^ ch ) return 0; 

else // check for ”ch” in rest of string 

{ , 

if (strchr(str+l, ch ) ) return 0; 
else return 1; 

} 

} 


int proper juper^tring(char* strl, char* str2) 

// Summary -- 

// 

// This function checks to see if strl is a candidate to be a 
II child of strS in the multi-way tree. 

II 

II End Summary --- 

{ 

// check to see if str2 is a prefix of strl 
if (strl ^ strstr(strl,str2) ) 
return 0; 
else 
{ 

char* loc = strl + strlen(str2); 
return strjsuffix.check(loc , 

} 

} 


211 






int proper-super J^ODExheck(TREENODE+ node.ptr, char* target string) 

// Summary -- 

// 

// This functions checks to see if the NODE returned by 
II Listiterator should be added to the childJtst of the NODE 
II associated with target string. It return a 1 if it should. 

n 

II End Summary - 


{ 

return proper.super-string(node 4 >tr—*getname(), target .string) ; 

} 


212 








// File Header —- 

//■■•■.: 

//.Filename .; proifunc.h 

//.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// . 

// End header comments - 

ttiindut -PROTFUNC-H 
#defin® -PROTFUNCJI 

// sees ID follows: will compile to pla ce date/time stamp in 
// object file 

static char protfunc.h.SccsId[] = "®(#)protfunc.h 1.3\t9/16/91" 

// Gontents --- 

// 

// Prototypes for functions related to manipulating 
// instances of the class PROTOTYPE. 

// 

// End - 

void list.protJunc(int); 
void longJist-protJ'unc(int); 
void get^irotdeader J'unc(int, char*); 
void get.prot-description Junc(int, char*); 
void dump-protjsummary.func(int, char *); 
void retrieve 4 )rot-date Junc(int, char*); 
void insert_prot Junc(int, cliar*, char*, char*); 
void update^irotdeader J'unc(int, char*, char*); 
void update^jrot-desc J'unc(int, char*, char*); 
void update 4 )rot-nameJ'unc(int, char*, char*); 

// Description - 

// 

// list.prot.func 

// 

// Provide the name of prototypes in the design database. 

// 

// longJist.prot.func 

// 

// Provides a list of all prototypes, the default configuration 
// assigned to a prototype and the version number of the root 
// versioned object. 

// 

// get.prot leader.func 


213 



















// 

// Provides the name of the leader assigned to a prototype. 

n 

II get-prot-description.func 

II 

II Provides the description of a given prototype. 

n 

II dnmpjprot^ummary^fnnc 

II 

II Provides a summary of the prototype. Include creation date, 
II leader, default configuration, and a description. 

II 

II retrieve.proLdate.func 

II 

II Provides the creation date. 

II 

II insert.prot.func 

// 

// Creates a new prototype in the database. 

II 

II updatejprotJeader.func 

n 

II Changes the prototype leader’s name. 

II 

II update.prot.desc.func 

II 

II Changes the description of a prototype. 

II 

II update.prot.name.func 

II 

II Changes thr prototype name. 

II 

II End Description - 

#endif // -PROTFUNC.H 


214 






// Ftle Header -- 

II .•• 

//.Filename .; proifunc.cxz 

II . sees ID .; 1.3 

/1 .Release No....: 1 

II.Date .; 9/16/91 

/1 .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .eomptler .; Glockenspiel C++ 2.1 

// . 

// End header comments --- 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char protfunc-cxx_SccsId|] = *'€(#)protfunc.exx 1.3\t9/16/91" 

// Gontents ---- 

// 

// lisLproLfunc 
II longJist-proLfunc 
II get.protjeader.func 
II get.proLdescnptionJuuc 
II dump.prof.summary.func 
II retrieve.prot.date.func 
II insert.proLfunc 
II update.prot.leader.func 
II update.prot.desc.func 
II update.pIot.name.func 

n 

U End - 

// Implementation Dependencies --- 

#ifnd«f _DDBDEFINES.H 
#include "ddbdef inas.h” 
tfendif 

#include <str«an.hxx> 

•include <LiBt.h> 

•include <Directory.h> 

extern ”C—" 

{ 

• include <8y8/tijBe .h> 

•include <8y8/type8.h> 

} 

• ifndef -PROTOTYPE Jl 

• include "prototype.h” 

•endif 


215 
















// End Implemeniaiton Dependencies 


II Interface Dependencies -—-- 

#ifndef _PROTFUNC-H 
#include "protfunc.h” 

#«ndif 

// End Interface Dependencies - 

extern List ♦myPrototypeList; 
extern char ♦ddbRootDir; 

PROTOTYPE ♦prototypePtr; 
ifstream inFile; 

void list-prot Junc(int number-arguments) 

{ 

switch (number-arguments) 

{ 

case 0: 

{ 

OC-setWorkingDirectory(ddbRootDir); 

Listiterator myJterate(myPrototypeList); 
while( myJterate.moreData()) 

{ 

cout ■C (char *)myJterate() 

} 

} 

break; 

default: 

cerr «C "<ERR0R: probl«m listing prototypes in databaso>\n” 

} 

} 

void longJist.prot.func(int number-arguments) 

{ 

char ♦protojiame = (char *)0; 
char ♦configname = (char ♦)0; 
switch (number-arguments) 

{ 

case 0: 

{ 

OC-setWorkingDirectory(ddbRootDir); 

List tprotoReference = ♦myPrototypeList; 

List ♦protojiames = (List^)O; 
proto-names = new List(protoReference); 

Listiterator my-iterate(proto_names), 
while(myJterate.moreData()) 

{ 


21f. 








Directory ♦prototype-dir=(Directory*)0; 
char *protoj\ame = (char ♦)0; 
char *name = (char ♦)0; 
protojianie = (char ♦)my.iterate(); 
name = new char [strlen(protojiame)+5]; 

8trcpy(name,proto_name); 

8trcat(name,"jdir"); 

prototype.dir = (Directory •)OCJookup(name); 
if (prototype.dir) 

OC.set WorkingDirectory (prototype-dir); 
char ♦prototypeJiame = new char [strlen(protojiame)+5]; 
8trcpy(prototype Jiame.proto Jiame); 
strcat(prototype jiame.PROTOTYPE XXT); 
prototypePtr = (PROTOTYPE^)OC Jookup(prototype jiame); 
if (prototypePtr) 

{ 

CONFIGURATION ♦configPtr; 

configPtr = prototypePtr—>getDcfaultConfigurationQ; 
if (configPtr) 

{ 

coiifigname =new cliar (strlen(configPtr—name()+l)]; 
strcpy(configname,configPtr—»nanie()); 

} 

else 

configname =new char [5]; 
strcpy(configname,"MOIIE"); 

} 

cerr <ti "lajna; 
cout -C protojiamo; 
int i=0; 

for (i=0;i<(PRlNT.CONFIG.LOCATlON-strlcn(protojiame));i + + ) 
cout < " 

cerr <C "Default Config: 
cout configname; 

for (i=0;i<(PRINT.VERSION.LOCATION- 

(PRINT-CONFIGXOCATiON+strlen(configname)));i++ 

cout < " 

cerr <C "Version; "; 

V.OBJECT ♦vobjectPtr = prototypePtr—*getVobject(); 
if (vobjectPtr) 

{ . 

int version = vobjectPtr—-getVersionNumber(); 
cout <§; version "\n";; 

} 

else 

cout < "HOME \n"; 
delete name; 
delete configname; 

} 


217 




} 

break; 

default: 

cerr <C "<ERROR: problaa long listing prototypes in databa8e>\n" 

} 

} 

void get_prot Jeader-func(int number.arguments, char *argl) 

{ 

switch (number^rguments) 

{ 

case 1: 

cliar ♦prototype-name = new char [strlen(argl)+5]; 

St rcpy (prototype _name ,arg 1); 
strcat(prototype.name,PROTOTYPE.EXT); 
prototypePtr = (PROTOTYPE^)OC Jookup(prototype-nanie); 
prototypePtr —► getPrototypeLeader(); 
break; 
default: 

cerr "<ERROR: extra a^rguments in get description call\n"; 

} 

} 


void get-prot.description Junc(int number-arguments, cliar ‘argl) 

{ 


switch (number-arguments) 

{ 

case 1: 

char ♦prototypejiame = new char [strlen(argl )+5]: 
strcpy(prototype_name,argl); 
strcat( prototype jiame,PROTOTYPE_EXT); 
prototypePtr = (PROTOTYPE+)OC Jookup(prototype_name); 
prototypePtr —♦ getPrototypeDescription(); 
break; 
default: 

cerr <C "<ERROR: extra eirgunents in get description call\n"; 

} 

} 

void dump-prot-summary-func(int number-arguments, char *argl) 

{ 


switcli (number-arguments) 

{ 

case 1: 

char ♦prototype-name = new char [strIen(argl)+5]; 

strcpy (prototype-name,argl); 

strcat(prototypejiame,PROTOTYPE-EXT); 

prototypePtr = (PROTOTYPE^)OC Jookup(prototype-name), 


218 






prototypePtr —♦ dumpPrototypeSummary(); 

break; 
default: 

cerr <C "<ERROR: extra arguments in dump Prototype Summary call\n"; 

} 

} 


void retrieve 4 )rotjdate J'unc(int number .arguments, char ♦argl) 

{ 

switch (number.arguments) 

{ 

case 1: 

char ♦prototypejiame = new char [strlen(argl)+5]; 

strcpy(prototypejname,argl); 

strcat(prototypejiame,PROTOTYPE j;XT); 

prototypePtr = (PROTOTYPE*)OC Jookup(prototypejiame); 

if (prototypePtr) 

{ 

time.t protTime = prototypePtr —► getProtCreationDate(); 
cout <C ctime{iiprotTime) <C 

} 

else 

{ 

cerr "<Protof'p'= argl <C " not found>\n" 

<C "<lind pio- vcype creation date operation aborted>"; 

} 

break; 

default: 

cerr <C "-^ERROR: invalid number args lor prototype time retrieval>\n’ 

} 

} 


void insert 4 )rotJunc(int number-arguments, char *argl, char *arg2, char *arg;t) 

{ 

cliar ♦prototype-name = new char [strlen(argl)+5]: 
strcpy (prototype .name,argl); 
strcat(prototype.name, PROTOTYPE-EXT); 

prototypePtr = (PROTOTYPE ♦)0CJookup(prototype-name); 
if (IprototypePtr) 

{ 

switch (number-arguments) 

{ 

case 1: 

prototypePtr = new PROTOTYPE(prototype.name); 
OCjsetWorkingDirectory(ddbRootDir); 
myPrototypeList —► Insert(argl); 
myPrototypeList — putObject(); 

break; 


219 



case 2: 
case 3: 

prototypePtr = new PROTOTYPE(prototype jiame, arg2); 
inFile.open(arg3, io8::in); 
if (inFile) 

prototypePtr —♦ updatePrototypeDescription(arg3,inFile); 
OC-setWorkingDirectory(ddbRootDir); 
myPrototypeList —* In8ert(argl); 
myPrototypeList —» putObject(); 
inFile.ciose(); 
break; 
default: 

cerr <C *'<ERR0R: invalid number args for insert prototype>\n" 

} 

} 

else 

{ 

cerr ^ "<I0TE; " argl <C " already existsi>\n*‘; 
return; 

} 

} 


void update 4 )rot Jeader-func(int number-arguments, cliar »argl. char »arg2) 

{ 

switch (number-argumenls) 

{ 

case 2: 

char ♦prototypejiame = new char [strlen(argl)+5]; 
strcpy (prototype .name,argl); 
strcat(prototypejiame,PROTOTYPEJEXT); 
prototypePtr = (PROTOTYPE*)OC Jookup(prototype.name); 
prototypePtr — changePrototypeLeader(arg2); 
break; 
default: 

cerr <C "<ERROR: invalid number args lor update Leader>\n"; 

} 

} 


void update.prot.desc.func(int number .arguments, cliar *argl. char ♦arg2) 

{ 

switch (number-arguments) 

{ 

case 2: 

{ 

inFile.open(arg2,ios::in); 
if (linFile) 

{ 

cerr <C "File with description contents does not exist\n" 
« " Aborting prototype updateLjdescription\n"; 


220 







} 

else 

{ 

char ♦prototypejiame = new char [strlen(argl)+5]; 

strcpy(prototype_name,argl); 

strcat(prototypejiame,PROTOTYPEJEXT); 

prototypePtr = (PROTOTYPE*)OC Jookup(prototype_name); 

prototypePtr —► updatePrototypeDescription(arg2,inFile); 

inFile.close(); 

} 

break; 

) 

default: 

cerr <C "<ERR0R: invalid number args lor update description>\n" 

} 


void update_prot_namejrunc(int number-arguments, char »argl, char *arg2) 

{ 

switch (number-arguments) 

{ 

case 2: 

cliar ♦prototype-name = new char [strlen(argl)+5]; 

strcpy(prototype jiame,argl): 

strcat(prototype.name,PROTOTYPE-EXT); 

cliar ♦new-prototype-name = new char [strlen(arg2)+5]; 

strcpy{new-prototype.name,arg2); 

St rcat( new .prototype .name, PROTOTVTE-EXT); 
prototypePtr = (PROTOTYPE^)OC Jookup(prototype_name); 
prototypePtr — changePrototypeName( new .prototype-name); 
break; 
default: 

cerr ■<C "<ERROR: invalid number args for update Mame>\n"; 

} 


221 




// Ftle Header -- 

// . •• 

//.Filename .; prototype.h 

//.sees ID .; 1.3 

I/.Release No....: 1 

I/.Date .; 9/16/91 

/1 .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .Compiler .; Glockenspiel C++ 2.1 

// . 

// End header comments - 

#iJndef .PROTOTYPE 
•define _PROTOTYPEJI 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char prototype_h.Sccsld[] = "C(#)prototype.h 1.3\t9/16/91" 

// Contents -- 

// 

// PROTOTYPE 

// 

// Description 

II 

u Defines class PROTOTYPE. 

II 

U End - 


// Interface Dependencies - 

•include <Object.h> 

• include <DictionaLry .h> 
•include <Reference.h> 

• include "ReferenceMacros .ti" 

extern "C—" 

{ 

• include <8ys/tiine.h> 
•include <8y8/type8.h> 

} 

• ifndel .TEXT.OBJECTJI 

• include "text-object .h" 
•endif 

• ifndef _CONFIGURATION-H 

• include "configuration.h" 
•endif 


222 


















TypeCheckReference(ConfDictReference, Reference, Dictionary); 
TypeCheckReference(TextObjectReference, Reference, TEXT .OBJECT); 
TypeCheckReference(DefaultConfReference, Reference, CONFIGURATION); 

// End Interface Dependencies -- 

#deline DEFAULT J'lAME 

// Class // 

class PROTOTYPE ; public Object 

{ 

private: 

char ♦protleader; 
int protDictIndex; 
time.t protCreationDate; 

TextObjectReference protdescription; 

ConfDictReference prot.configuration Jist; //points to a Dictionary 
DefaultConfReference prot.default.configuration; 

public: 

PROTOTYPE(APL *); 

PROTOTYPE(char *prototypejiame, 

char ♦prototypeJeader=DEFAULTJ'JAME); 
virtual void Destroy (Boolean aborted=FALSE); 
virtual Type ♦getDirectType(); 
char ♦getName(); 
char ♦getConfigNameO; 
void getPrototypeNanie(); 
void getProiotypeLeader(); 
void getPrototypeDescriptionO; 

void changePrototypeName(char ♦new.prototypejiame); 
void changePrototypeLeader(cheu: ♦new.prototypeJeader); 
void updatePrototypeDescription(char*, ifstreami;); 
void dumpPrototypeSummaryO; 

void addConfiguration(CONFIGURATION ♦configuration); 
void listConfigurationsO; 
time.t setProtCreationDate(); 
time.t getProtCreationDate(); 
void getDefaultConfigName(); 

CONFIGURATION ♦getConnguration(char ♦); 

CONFIGURATION ♦getDefaultConfiguration(); 

V.OBJECT ♦getVobjectO; 

~PROTOTYPE() { Destroy(FALSE); } 


); 

// Description - 

ft 

// Defines a PROTOTYPE class. 


223 






// 

// Constructor 

// 

// prototype -APL 

// 

// ONTOS required constructor 

II 

II prototype 

II 

II Constructs a prototype object from the given name, 

II and optional team leader of the prototype. 

II 

II Public Members 

II 

// Destroy 

II 

II used to cleanup memory during deletion and aborts. 

II 

II getDirectType 

II 

u Return the ONTOS Type of class PROTOTYPE. 

H 

// getName 

// 

// Returns a character string containing the name of the prototype 

II 

II getConfigName 

II 

II Returns a character string containing the last configuration 
II worked on by a user 

II 

II get Prototype Name 

n 

II Prints the prototype name to standard output 

n 

II getPrototypeLeader 

II 

II Displays the prototype designer team leader’s name. 

II 

II getPrototypeProtdescription 

II 

II Displays a protdescription of the prototype. 

n 

II change Prototype Name 

II 

II Change the name of the prototype. 

II 

II changePrototypeLeader 

II 

II Change the prototype leader's name. 

II 


224 




// updaiePrototypeProtdescription 

II 

II Adds a protdescripiion to a PROTOTYPE object. 

II 

II dumpPrototypeSummary 

n 

II Provides date created, leader, default configuration, 

II and description of a prototype. 

// 

// addConfiguration 

// 

// Adds a configuration with a given name to the prototype 

II 

II listConfigurations 

// 

// List the names of all the configurations in the prototype. 

II 

II getDefaultConfigName 

II 

II Displays the name of the default configuration. 

n 

II getConfiguration 

II 

II Used by this class as a support function to update the default 
II configuration. 

II 

II getDefaultConfiguration 

II 

II returns a pointer to the default Configuration 

II 

H getVobject 

II 

II returns the most current root V.OBJECT (Operator or Type) 
II associated with a prototype. 

II 

II ^prototype 

II 

II The class destructor. 

II 

u End - 

#endil // ^PROTOTYPE.H 


225 





// File Header -- 

// . •• 

//.Filename .: prototype.cxz 

Ij.sees ID .; 1.3 

fI-Release No....; 1 

11.Date .; 9/16/91 

//.Author .: Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// . •• 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char prototype.cxx-SccsId(] = "e(#)prototype.cxx 1.3\t9/16/91" 

// Gontents --- 

// 

// PROTOTYPE::PROTOTYPE ONTOS constructor 
// PROTOTYPE .PROTOTYPE constructor 
// PROTOTYPE:.Destroy 
// PROTOTYPE::getDirectType 
// PROTOTYPE::getName 
// PROTOTYPE::geteonfigName 
/ / PROTOTYPE::get Prototype Name 
// PROTOTYPE::getPrototypeLeader 
// PROTOTYPE::getPrototypeDescription 
// PROTOTYPE::changePrototypeName 
/ / PROTOTYPE: :change Prototype Leader 
// PROTOTYPE::updatePrototypeDescription 
// PROTOTYPE::dumpPrototypeSummary 
// PROTOTYPE.-.addeonfiguratwn 
// PROTOTYPE::listeonfigurations 
// PROTOTYPE::setProtereationDate 
// PROTOTYPE::getProtereattonDaie 
// PROTOTYPE::getDefaulteonfigName 
// PROTOTYPE.'.geteonfiguration 
// PROTOTYPE::getDefaulteonfiguration 
// PROTOTYPE::getVobject 
// 

// Description 

// 

// Implementation of class PROTOTYPE member functions. 

// 

// End - 

// Interface Dependencies - 

tinclud* <GlobalEntiti«8.h> 

#includ« <Directory .h> 


226 






















#include <streajB.hzx> 


extern "C—" 

{ 

tinclude <8ys/tiBe.h> 
#iiiclude <8trings.h> 

} 

#ilndel _PROTOTYPE-H 
tinclude "prototype .h” 
Xendil 


// End Interface Dependencies -- 

extern Type *PROTOTYPE_OType; 
extern Type *CONFIGURATION-OType; 

// ONTOS required constructor // 

PROTOTYPE::PROTOTYPE(APL ♦theAPL) : (theAPL) 

{ 

}; 


// New Instance Constructor // 

PROTOTYPE::PROTOTYPE(char ♦prototypejname, 

char ♦prototypeJeader) : (prototype_name) 


// Summary - 

// 

// Constructs a persistent prototype object. A PROTOTYPE object 
II contains general management information about a prototype and 
II a reference to a container holding configuration objects. 

II 

II Parameter 

II 

II prototypejname 

II 

II A pointer to a character string. 

II 

II prototypeJeader 

II 

II A pointer to a character string. 

II 

II Functional Description 

II 

II Passes the object name to class Object. Copies the leader's name 
II into private data members. We initialize the description to null 
II and create a dictionary to hold various configurations. 

II 


227 








// End 


{ 

initDirectType(PROTOTYPE.OType); 

protleader = new char[strlen(prototypeJeader)+l]; 
strcpy(protleader, prototypeJeader); 
protDictIndex = 0; 

protCreationDate = setProtCreationDate(); 

protdescription.initToNull(); 
prot_default .configuration .initToN ull(); 

if(!CONFIGURATION.OType) 

{ 

CON FIG U RATION.OType = (Type*)OCJookup("C0KFIGURATI0H"); 

} 

Dictionary ♦new.configuration = new Dictionary(OC-integer, 

CONFIGURATION.OType, 
TRUE, FALSE); 

new.configuration —♦putObject(); 

prot.configurationJist.Reset(new.configuration, this); 

putObject{); 

} 

// End Constructor PROTOTYPEr.PROTOTYPE // 

II Member Function // 

void PROTOTYPE::Destroy(Boolean aborted) 

{ 

delete protleader; 
if (aborted) 

{ 

Object :;Destroy (aborted); 

} 

} 

Type* PROTOTYPE::getDirectType() 

// Summary - 

II 

II returns the ONTOS Type for the prototype class. 

1 / 

II Return value 

II 

II A pointer to an ONTOS Type. 

If 

// End - 


228 






{ 

return PROTOTYPE.OType; 

} 

char ♦ PROTOTYPE;:getName() 

// Summary —-- 

// 

// rtiums the name of the prototype 

If 

II Return value 

II 

II A pointer to a character string 

II 

u End - 


{ 

Directory *directory=(Directory *)0; 
char ♦name=(char *)0; 
char ♦temp=(char ♦)0; 

if(!this) 

{ 

cerr "<ERRQR; cannot get the name of a null PROTOTYPE>\n’ 
return NULL; 

} 

else 

{ 

name = Name(): 

OC-getNameComponents(name, irdirectory, iiname); 
temp = new char [strlen(name)+l]; 
temp = strtok(name,". 
return temp; 

} 


void PROTOTYPE: :getPrototypeName() 

// Summary - 

II 

II Displays the name of the prototype 

II 

II Return value 

If 

II Displays the Prototype Same and a linefeed to the sidout 

// 

// End - 


( 

Directory »dircctory. 


220 











char *name; 

if(!thi8) 

{ 

cerr <C "<ERROR: cannot gat tha name of a null PROTOTYPE>\n"; 
return; 

} 

else 

{ 

name = Name(); 

OC-getNameComponents(name, ^directory, tname); 
cout <C name <C "\n"; 

} 


void PROTOTYPE::getPrototypeLeader() 

// Summary -- 

// 

// Displays the name of the prototype leader 

// 

// Return value 

It 

II Displays the Prototype leader and a linefeed to the stdoui 

n 

U End - 


{ 

if(!this) 

{ 

cerr "<ERROR: cannot gat tha laader's name of a null PR0T0TYPE>\n" 
return; 

} 

cout C protleader "\n"; 

} 

void PROTOTYPE::getPrototypeDescriptionO 

// Summary- 

// 

// Displays the prototype description 

// 

// Return value 

II 

II Displays description to stdout if a description exists 

1/ 

11 End - 

{ 

if(lthis) 


230 










cerr <g; "<ERROR; cannot get the description oi a null PROTOTYPE>\n"; 
return; 


{ 


, } 

if(!protdescription) 

{ 

cerr ^ "<This prototype does not contain a description>\n"; 
return; 

} 

else 

{ 

TEXT-OBJECT* mvTextObjPtr = (TEXT-OBJECT*) protdescription.Binding(this) 
myTextObjPtr —► text(cout); 

} 


void PROTOTYPE::changePrototypeName(char *new-prototype-name) 

// Summary - 

// 

// Changes the prototype name 

n 

II Parameter 

II 

II new.prototype.name 

II 

II a character string pointer containing the new name 

II 

II Return value 

II 

II ^/A 
// 

// End - 


{ 

if(!this) 

{ 

cerr •C "<ERROR: cannot set the name of a null PR0T0TYPE>\n"; 
return; 

} 

Name(new-prototype-name); 

} 

void PROTOTYPE::changePrototypeLeader(char *new-prototypedeader) 

// Summary - 

II 

II changes the prototype leader 

II 

II Parameter 


231 









// 

// newjprototypedeader 

II 

jj a character siring pointer containing the new leader’s name 

II 

II Return value 

II 

II n/a 
// 

// End - 


{ 

if(!this) 

{ 

cerr "<ERROR: cannot change the leader oi a null PROTOTYPE>\n"; 
return; 

} 

delete protleader; 

protleader = new char[strlen(new 4 )rototypeJeader)+l]; 
strcpy (protleader, new .prototype deader); 
putObject(); 

} 

void PROTOTYPE::updatePrototypeDescription(char ♦fileName, ifstreamii inputJile.stream) 
// Summary - 

II 

II changes the prototype description 

// 

// Parameter 

n 

II fileName 

II 

// a character string pointer containing the new name of 
II the file containing the new descnvtion. 

II 

II input-file.stream 

II 

II the file handle of the input description file. 

II 

II Return value 

II 

II n/a 
II 

U End - 

{ , 

if (Iprotdescription) 

{ 

TEXT.OBJECT ♦textObjectPtr = new TEXTJDBJECT(); 
textObjectPtr —• append(fileName, input Jile.stream); 


232 










protdescription.Reset(textObjectPtr, this); 
putObject(); 

} 

else 

{ 

TEXT.OBJECT ♦textObjectPtr = (TEXTDEJECT*) protdescription.Binding(this) 

textObjectPtr —* resetTheText(); 

textObjectPtr —► append(fiieName, inputJile^tream); 

putObject(); 

} 


void PROTOTYPE;:dumpPrototypeSummary() 

{ 


// Summary - 

// 

// Displays the date created, leader, default config, and 
II description of a prototype to stdout 
II 1 item per line ending with the (potentially) multi-line 
II description. 

n 

II Parameter 

// 

// N/A 

n 

II Return value 

II 

n n/a 

II 

// End - 

tinie.t creationdate = 0; 

creationdate = getProtCreationDate(); 

cerr <g; "Creation Date: 

cout ctime(&'creationdate) •C "\n"; 

cerr <C "Leader: "; 

getPrototypeLeader(); 

cerr C'Default Config: "; 

getDefaultConfigName(); 

cerr •C "Prototype Description 

follows :\n===== = = = = =====================\n\n"; 

getPrototypeDescription(); 

} 

void PROTOTYPE;;addConfiguration(CONFIGURATION ‘configuration) 

{ 


// Summary - 

II 

II adds a configuration to the prototype 


233 












// 

// Parameter 

// 

// configuration 

fl 

//a pointer to the configuration to be added to the 
II prototype. 

fl 

fl 

II Return value 

II 

II m 
If 

u End - 

if(!thi8) 

i 

cerr <1; "<ERROR: cannot set the description of a null PRDTOTYPE>\n" 
return; 

, } 

if(!configuration) 

{ 

cerr ■C "<ERR0R: cannot give to a PROTOTYPE a null configuration>\n 
return; 

} 

else 

{ 

protDictIndex = protDictIndex + 1; 

Dictionary ♦confDictionaryPtr= 
(Dictionary*)prot.configurationJist.Binding(this); 
confDictionaryPtr — Insert(protDictlndex, (Entity *)configuration): 
confDictionaryPtr —> putObject(); 
prot-default-Configuration.Reset(configuration, this); 
putObject(); 

} 


void PROTOTYPE::listConfigurations() 

// Summary ---—- 

// 

// Display the configuration names contained in this prototype 
II to stdout. 1 configuration / line. 

If 

II Parameter 

If 

If n/a 

n 

II Return value 

II 

If ‘VA 


234 









// 

// End 


{ 

CONFIGURATION ♦the.configuration; 
char *name; 

Directory ♦directory; 


if(!prot-conflgurationjist) 

{ 

cerr "<ERROR: caomot return a prototype from am empty li8t>\n" 
return; 

} 

Dictionary ♦confDictionaryPtr = 

(Dictionary^)prot ronfiguration-list.Binding(this); 

Dictionary Iterator configlist Jterator(confDictionaryPtr); 

while( the.configuration ={CONFIGURATION^)(Entitv^)configlist Jterator()) 

if (name = the.configuration—>Name()); 

{ 

OC.getNameComponents(name, icdirectory, A:name); 
cout name "\n"; 

} 

} 


I!Member Function // 

tirne.t PROTOTYPE::setProtCreationDate() 

// Summary - -- 

// 

// sets ike creation date to system date at time of this call. 

II 

II Parameter 

II 

II n/a 
II 

// Retuim value 

II 

II tirne.t as a default long value containing the system time 
II This function as a byproduct updates the protCreationDate 
II attribute field. 

II 

u End - 


{ 

tirne.t mytloc=0; 


235 







time.t theTime; 

return theTime = tirne(mytloc); 

} 

// End - 


// Member Function // 

time.t PROTOTYPE::getProtCreationDate() 

// Summary - 

// 

// Returns the prototype's creation date 

II 

j / Parameter 

II 

II n/a 
II 

II Return value 

II 

II time.t as a long value containing the system time 

II 

u End - 


return protCreationDate; 

} 

// End - 


void PROTOTYPE::getDefaultConfigName() 

// Summary --- 

II 

II Displays the default Configuration name for this prototype 
II to stdout 

II 

II Parameter 

n 

// n/a 

// 

// Return value 

II 

// m 

II 

U End - 

{ 

Directory *directory; 


236 











char ♦name; 


if(!prot-default-Configuration) 

{ 

cerr "\n\n<Io configurations ars contained in this prototype. >\n\n" 

} 

else 

{ 

CONFIGURATION ♦the.configuration = 
(CONFIGURATION^)prot-default.configuration.Binding(this); 
name = the.configuration —♦ Name(); 

OC.getNameComponents(name, ^directory, &name); 
cout <C name <C "\n"; 

} 


char ♦ PROTOTYPE; :gelConfigName() 

{ 

// Summary - 

II 

II Returns a character string pointer to an area in memory 
II containing the name of the default Configuration name 
II for this prototype. 

II 

II ParamCer 

n 

n N/A 

u 

// Return val le 

II 

II character string pointer 

II 

u End - 

Directory ♦directory; 
cliar ♦name; 

if(!prot-default.configuration) 

{ 

cerr <C "<Io configurations eure contained in this prototype. >\n\n"; 
return NULL; 

} 

else 

{ 

CONFIGURATION ♦the.configuration = 

(CONFIGURATlON^)prot-default-configuration.Binding(this); 
name = the.configuration —» Name(); 

OC.getNameComponents(name, ^directory, fcname); 
return name; 

} 


2.17 





) 

CONFIGURATION ♦PROTOTYPE::getConfiguration(char ♦confName) 

// Summary -- 

// 

// Used by this class as a support function to update the default 
II configuration. 

II 

II Parameter 

II 

II confName 

II 

II configuration name to lookup the default configuration 
II for this prototype 

n 

II Return value 

II 

II Configuration pointer tf successful. Null pointer tf 
II failed. 

II 

u End - 

{ 

CONFIGURATION *myConfPtr = (CONFIGURATION *)OCJookup(confName); 
if (myConfPtr) 

{ 

return myConfPtr; 

} 

else 

{ 

return (CONFIGURATlON*)0; 

} 


CONFIGURATION *PROTOTYPE::gttDefaultConfiguration() 

// Summary ---— -— 

II 

II Returns the default configuration for this prototype. 

II The last configuration worked on. 

II 

II Parameter 

II 

n m 

II 

// Return value 

II 

II Configuration pointer tf successful. Null pointer if 
// failed. 

II 


238 






// End 


{ 

CONFIGURATION *the.configuration =(CONFIGURATION ♦)0; 

if(!prot_default.configuration) 

{ 

leturn NULL; 

} 

else 

{ 

the.configuration = 

(CONFIGURATION*)prot-default.configuration.Binding(thi8); return the-configuration; 

} 


V-OBJECT ♦PROTOTYPE::getVobject() 

// Summary —-—-- 

// 

// This method assumes that the root versioned object (V.OBJECT) 
II has the same name as the prototype. If this is not the case 
II then this function will not work. Taking the prototype name, 

II a thread lookup is performed and the most current V.OBJECT 
II in the thread is returned. 

// 

II Parameter 

n 

// ^/A 

u 

II Return value 

n 

II V.OBJECT pointer if successful. Null pointer if 
II failed. 

// 

// End - 

{ 

THREAD ♦threadPtr=(THREAD*)0; 

char ♦name = new char [strlen(getName())+l]; 

strcpy (name,get Name()); 

threadPtr = (THREAD ♦)OCJookup(name); 

if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr = threadPtr—*current(); 
if (vobjectPtr) 

return vobjectPtr; 
else 
{ 

return NULL: 

} 


239 









} 

else 

{ 


return NULL; 


} 

} 

// end functions 


240 





// File Header -—- 

// . •• 

I/.Filename .; queue.h 

//.sees ID .; 1.3 

//.Release No....: 1 

//.Dale .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// .■■ 

// End header comments —---— 

#ilndef _QUEUEJI 
#deline _QUEUE_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char QUEUE_h_Sccsld[] = "Q(#)queue.h 1.3\t9/16/91"; 

// Gontents - 

// 

// QUEUE 

// 

// Description 

// 

// IMPLEMENTS class QUEUE GONSTRUeTORS. 

// 

// End - 

// Interface Dependencies -— — —- 

// 


#include <io8traaa.hxx> 

extern "C—"{ 

#include <stdio.h> 

#includa <8tring.h> 

} 

// 

// End Interface Dependencies -- 

// Description - 

// 

// Defines the slink, slist, slisLiterator, 

// treenodeJinkedlist, and treenode-queue classes 

// 

// 

// There are no ontos mechanisms in these classes. The primary 
// purpose of these classes is to provide the support structures 


241 























// of Itnked-lisis and queues in order to process the CAPS 
// PROTOTYPE subdirectory. 

// 

// As a subdirectory is read, each file is analzed to determine 
// whether it is an operator/type. If found to belong to 
II an operator which might version, the operator and operator 
II information is placed into a multi-way tree parrallelling the 
II decomposition of an operator in the CAPS system. The 
II TREENODES are then compared against operator structures in 
// the Ontos Database in other programs documented elsewhere. 

// 

// These structures are simple in nature and can be found in 
II any good C++ textbook. These particular examples came from 
II Bjame Stroustrup’s C++ Programming Language textbook (pg 203). 
II Please refer to the textbook for further explanation of the 
II data structures and how they are manipulated. 

II 

II End - 

class TREENODE; 

class slist; 

class slist iterator; 

class slink { 

friend class slist; 
friend class slistJterator; 

private: 

slink* next; 

TREENODE * e; 
slink(TREENODE * a, slink* p); 

}; 


class slist { 

friend class slistJterator; 


private: 

slink* last; // last-> next ts head of list 


public: 

slist(); // { last = NULL; } 
slist(TREENODE * a); 

int insert(TREENODE * a); // add at head of list 
int append(TREENODE * a); // add at tail of list 
TREENODE * get(); // relum and remove head of list 
void clear(); // remove all links 
int emptyO; // returns 1 if list is empty 
~siist(); // { clear(); } 

}; 


242 







class slist iterator { 


private: 

slink* ce; 
slist* cs; 

public: 

slist Jterator(slisti: s); 
TREENODE * operator()(); 


class TREENODEJinkedlist : public slist 

{ 

public: 

TREENODEJinkedlist(); 
int mennber(char ♦name); 

}; 


class TREENODELqueue : private slist 

{ 

public: 

TREENODE-queue(){} 

void put(TREENODE * a) {append(a); } 

slist::empty; 

slist::get; 

}; 


#endif // QUEUE Class header 



// Ftle Header -- 

// . •• 

U.Filename .; queue.cxz 

I/.sees ID .; 1.3 

I/.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.Compiler .; Glockenspiel C++ 2.1 

// . 

// End header comments --- 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char QUEUE-Cxx_SccsId[] = "®(#)qu«tte.cxx 1.3\t9/16/91" 

// Contents -— 

// 

// QUEUE 

// 

// Description 

// 

// IMPLEMENTS class QUEUE CONSTRUCTORS. 

// 

// End - 

// Interface Dependencies - 

// 

#ilndel _QUEUE_H 
tinclude ”qu«u«.h’' 

#endil 

// 

// End Interface Dependencies --- 


//-X-.V--A'-A- 

// these are the implementation methods of classes 
// slink, slist, slistJterator, and TREENODEJinkedlist 
// - X -A'-A- X -A' 

//-A-A-A-A-A 

// 

// slink methods 

// 

// -A-A-A-A-A 


slink::sIink(TREENODE ♦ a. slink* p) 

{ 

e = a; 


244 



















next = p; 

} 

//- X -A'-A-A-A 

// 

// slxst methods 

II 

H - X -A-A-A-A 

slist::slist() 

{ 

last = NULL; 

} 

slist::slist(TREENODE ♦ a) 

{ 

last = new slink(a,NULL); 
last —* next = last; 

} 

int slist:;insert(TREENODE ♦ a) 

{ 

if (last) 

last—‘next = new slink(a, last—‘next); 
else { 

last = new slink(a,NULL); 
last —» next = last; 

} 

return 0; 

} 

int sIist;:append(TREENODE * a) 

{ 

if (last) 

last = last —» next = new slink(a, last—next); 
else 
{ 

last = new slink(a,NULL): 
last — next = last; 

} 

return 0; 

} 

TREENODE * slist::get() 

{ 

// improve the following line for better error detection 
if (last == NULL) cout "gat fro* aapty 8li8t\n''; 
slink* f = last— next; 

TREENODE ♦ r = f—e. 


24 .', 





if (f == last) last = NULL; 
else last —*next = f-*next; 
delete f; 
return r; 

} 

void slist;:clear() 

{ 

slink* 1 = last; 
if ( 1 == NULL ) return; 
do 
{ 

slink* 11 = 1; 

1 = 1—* next; 
delete 11; 

} while (1 ^ l 2 ist); 

} 

int sli8t::empty() 

{ 

if (last == NULL) return 1; 
else return 0; 

} 

slist::~slist() 

{ 

clear(); 

} 


//-^-A'-;i:-A'— 

// 

// shst iterator methods 

n 

11 -A-A-A-A— 

slist jterator::slist jterator(slistA: s) 

{ 

cs = k.B\ 

ce = cs —♦ last; 

} 

TREENODE *8list jterator:'.operator()() 

{ 

TREENODE * ret = ce ? (ce = ce —► next) —► 
if ( ce == cs —•last) ce = NULL; 
return ret; 

} 


-A 




e : NULL; 


246 






//- X -X- X - X - -X 

II 

II TREENODEJinkedlist methods 

II 

u -X-X-X-A'--A 

TREENODEJinkedUst;:TREENODEJinkedlist() 

{ 

} 

int TREENODEJinkedlist;:member(char ♦name) 

{ 

char ♦temp = name; 
return 1; 

} 


2-17 






// File Header ---- 

// . 

//.Filename .; iext.objeci.h 

//.sees ID .; l.S 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

// eompiler .; Glockenspiel C++ S.l 

// . ■■ 

// End header comments ——----- 

-TEXT.OBJECTJI 
idefine _TEXT.OBJECT 

// sees ID follows: will compile to place date/time stamp in object file 

static char text.objcct Ji^ccsld[] = "C(#)text.object .h 1.3\t9/16/91" 

// Gontents -- 

// 

// TEXT.OBJEer 

// 

// Description 

// 

// Defines class TEXT-OBJEGT. 

// 

// End - 

// Interface Dependencies - 

// sees ID follows: will compile to place date/time stamp «n object file 

// Interface Dependencies - 

#includ« <0bject.h> 

#include <8tr«aB.lucz> 

// End Interface Dependencies - 


class TEXT-OBJECT : public Object 
private; 

char ♦the-filejiame; 
char ♦the-text; 
public: 

TEXT-OBJECT(APL *); 
TEXT-OBJECT(); 

void Destroy (Boolean aborted=FALSE); 
Type *getDirectType(); 


248 





















void append(char ♦, ifstream&); 
void append (char ♦); 
void append(if8tream&); 
void text(ostreamt); // standard output 
Boolean rebuildTextFile(char+); 
void displayFileName(); 
char ♦getFileNameO; 
char ♦textO; 
void resetTheText(); 

-TEXT.OBJECTO { Destroy(FALSE); } 

}; 

// Description - 

// 

// Defines a TEXT-OBJECT class. The class TEXT.OBJECT ts a derived 
II class of Object. 

II 

// Constructor 

II 

u TEXT.OBJECT - A PL 
// 

// ONTOS required constructor 

II 

n TEXT.OBJECT 

II 

II Creates a new instance of TEXT.OBJECT 

II 

II Public Members 

II 

II Destroy 

II 

II ONTOS required method. 

II 

II getDirectType 

// 

// ONTOS rquired method used to return the class Type. 

II 

II append 

// 

// Reads in a text file. 

II 

II append 

// 

// Read in a string append to existing string in log fashion. 

II 

// text 

II 

II Send the text contents to standard output. 

II 

II rebuildTextFile 

n 


249 






// Write the contents of a text object to a file. 

II 

// display File Name 

II 

II Send the file name to standard output. 

n 

II getFileName 

n 

II Return a pointer the file name contained in the text object. 

II 

II text 

// 

// Returns a pointer to the text contained in the text object. 

II 

II reseiTheText 

II 

II Set the text field to a empty string. 

II 

u '-TEXT-OBJECT 

II 

II class destructor. 

II 

II End Description - 

#endil II^TEXT-OBJECT-H 


250 










// File Header - 

// . •• 

11-Filename .; iexi.objeci.cxx 

I/.sees ID .; 1.3 

11-Release No....: 1 

//.Date .; 9/16/91 

11 .Author .; Garry Lewis 

II .; Drew Dwyer 

II.Compiler .; Glockenspiel C++ 2.1 

II .•• 

// End header comments - 


// sees ID follows: will compile to place date/time stamp 
II in object file 

static char composite-Cxx_SccsId[] = "e(#)text.object.exx 1.3\t9/16/91" 
// Contents - 

II 

u TEXT-OBJECT::TE.XT.OBJECT Ontos Constructor 
U TEXT.OBJECT::TEXT.OBJECT 
U TEXT.OBJECT::Desiroy 
// TEXT.OBJECT::getDtrectType 
U TEXT.OBJECT::append 
// TEXT.OBJECT::app€nd 
U TEXT.OBJECT::append 
U TEXT.OBJECT::text 
U TEXT.OBJECT-.rebutldTextFik 
II TEXT.OBJECT:-display I tit Name 
H TEXT.OBJECT::getFileName 
H TEXT.OBJECT::teit 
H TEXT..OBJECT::resctTheTeit 

II 

II Description 

II 

II Implementation of class TEXT.OB JECT member functions. 

// T d 

II Interface Dependencies -- 

#include <str8trean.hxx> 

#ilndef _TEXT.OBJECTJ{ 

^include "text.object .h” 

#endif 


#ifndef _TRACER-H 
#include "tracer.h" 
#endit 

















#ilndel _DDBDEFINES-H 
#include ”ddbdef ines .h” 
*«ndil 


extern "C—" 

{ 

#inclad« <8tdio.h> 
tinclude <sy8/tiBe.h> 

•include <8y8/type8.h> 

•include <8tdlib.h> 

•include <8tring8.h> 

} 

// End - 

extern Type fTEXT-OBJECT JDType; 
extern char ♦dirNamePtr; 

TEXT-OBJECT;:TEXT.OBJECT(APL ♦theAPL) : Object(theAPL) 

// Summary - 

// 

// Onios Required Constructor 

// 

// Return value 

II 

u A TEXT.OBJECT object 

II 

u End - 


{ 

}; 

TEXT DBJ ECT: :TEXT DBJ ECT() 

// Summary -- 

II 

II Constructor 

II 

II Return value 

II 

u A TEXT.OBJECT object 

II 

II the.file.name and the.text attributes are initialized to NULL; 
II End - 


{ 

the.text=new char[l]; 
strcpy( the.text,""); 
theJilejiame = new char[l]; 
strcpy(theJilejiame, 


252 











putObject(); 

}; 

void TEXT-OBJECT::Destroy(Boolean aborted) 

// Summary -- 

// 

// Constructor 

II 

// Return value 

II 

11 A TEXT.OBJECT object 

II 

// the-file.name and tkeJext attributes are inittalized to NULL; 
11 End - 

{ , 

if(the-file.name); 
delete the-filejiame; 
delete the.text; 
if( aborted) 

{ 

Object:: Destroy (aborted); 

} 

}; 

Type ♦TEXT.OBJECT::getDirectType() 

// Summary -—- 

II 

II Ontos required method which returns the type of this object. 

II 

II Parameter 

II 

// m 

II 

II Return Value 

II 

II the type of this object. TEXT.OBJECT. 

II 

// End - 

{ 

return TEXT-OBJECT.OType; 

}: 

void TEXT.OBJECT::append(char *filename, ifstreami: inpulTilc) 
// Summary - 

II 

II append a file as a text object 

II 

II Parameter 


25.1 












// 

// filename 

// 

// character airing * containing the name of the file which 
// is read into a text.object. 

// 

// input.file 

II 

II file handle of input file 

II 

II Return Value 

II 

// stores the file as a text-object in the database 
U End - 


{ 

theJilejiame = new char[strlen(filename) + 1]; 
strcpy(theJileJiame, filename); 

ostrstream buf; 
char ch; 

while (buf hk. input_file.get(ch)) 

{ 

buf.put(ch); 

} 

the.text = buf.str(); 
putObject(); 

}; 

void TEXT.OBJECT;:append(char *instring) 

// Summary - 

II 

II append a character string as a text object, stores the character 
II string as a text.object in the database 

II 

II Parameter 

// 

// xnstrxng 

// 

// character string * contaxnxng the description to be added as 
II a text.object. 

II ^ 

// Return Value 

II 

II m 
II 

u End - 

( 

fime.t mytloc=:0; 


251 










time.t theTime; 


char ♦temp.text=the.text; 

the-text=new char[strlen(temp.text)+strlen(instring)+ 
strlen(ctime(&;theTime))4-l]; 

strcpy (the J.ext .temp .text); 
strcat(the.text, "\n"); 

theTime = time(mytloc); 
strcat(the.text, ctime(fctheTime)); 
strcat(the_text, 

strcat(the.text,instring); 

8trcat(the_text, "\n"); 

putObject(); 

}; 

void TEXT-OBJECT::append(ifstreamA: inputJile) 

// Summary - 

// 

// append a file as a text object, .stores the file as a 
// texi.object in the database 

II 

II Parameter 

II 

II input.file 

n 

II file handle of input file 

n 

II Return Value 

II 

// m 

II 

II End - 

{ 

time.t mytloc=0; 
time_t theTime = 0; 

char ♦temp-text=the-text; IIsave old text 

ostrstream buf; 
char ch; 

while (buf icic inputJile.get(ch)) 

{ 

buf.put(ch); 

} 

theTime = time(mytloc); 


255 






char ♦file.text = buf.str(); 

the-text=new char[strlen(temp_text)+strlen(filejtext) + 
strlen(ctime(&:theTime))+256]; 
int tempsize = strlen(temp.text)+strlen(file_text) + 
strlen(ctime(iitheTime))+256 ; 
strcpy (the Jtext,temp .text); 
strcat(the_text, "\n"); 
strcat(the.text, ctime(&theTime)); 

8trcat(the.text, *'\n"); 
strcat(the Jtext,file Jtext); 
strcat(the-text, ”\ii"); 

putObject(); 

} 

void TEXT.OBJECT::text(ostream& outstream) 

// Summary ---- 

// 

// output the text.object as a file, dumps the text.object to 
II the PROTOTYPE environment subdirectory 

II 

II Parameter 

II 

II outstream 

II 

II file handle of output file 

II 

II Return Value 

II 

II N/A 

n 

II End - 


outstream the.text; 

}; 


Boolean TEXT.OBJECT::rebuildTextFile(char *(116X10(16) 

// Summary - 

// 

// output the text.object as a file in ”r” - read only or "w” read 
II and u~ite mode (refer to Unix system manual), dumps *he 
II text.object to the PROTOTYPE environment subdirectory 

II 

II Parameter 

// 

// file Mode 

II 


250 








// "r” - read only. ”w” read/wrUe. 

II 

II Return Value 

II 

II Boolean SUCCESS or FAILURE - refers to success of 
II rebuilding file on the disk. 

II 

u End - 

{ 

ofstream ©File; 

char ^rnypath = new char[MAX_LINE-LENGTH]; 

strcpy(mypath, dirNamePtr); 

strcat(mypath, 

8trcat(mypath, theJilejiame); 

if (strcmp(fileMode, "h") == 0 || strcmp(fileMode, "W") == 0) 

{ 

©File.open(my path,ios::noreplace); 
if (!oFile) 

{ 

return FAILED; 

} 

} 

else 

{ 

©File.©pe'i(mypath, ios::n©replace, 0444); 
if (!oFile) 

{ 

cerr C "<ERR0R: file "<Cthe.file.name <c " already exists. >\n’ 
return FAILED; 

} 

} 

if (the.text) 

©File <C th '.text ; 

©File.cl©se(); 

return SUCCESS; 

} 

void TEXT.O^'JECT::displayF’ileNanie() 

// Sumnt .ry ---- 

II 

II Displa 'S the teit.object filename to stdout. 

II 

II Parar -ter 

II 

// A'/A 
II 

II Return Value 

II 

II A'/A 
II 

u End - - 


2.i7 





{ 

cout <C the-filejiame <C "\n"; 

} 

char *TEXT.OBJECT:;getFileName() 

// Summary --- 

// 

// Returns the attribute containing the name of the file 
II as it was stored on the disk. 

II 

II Parameter 

II 

II n/a 
II 

II Return Value 

II 

II character string containing the file name of the object 

II 

u End - 

{ 

return theJiie-name; 

) 


char ♦TEXT.OBJECT::text() 

// Summary -- 

II 

II return the contents of the.text 

II 

II Parameter 

II 

II n/a 
II 

II Return Value 

II 

II character string pointer with the text in the texLobjecl. 

II 

II End - 

{ 

return the.text; 

}; 

void TEXT-OBJECT: resetTheTextO 

// Summary - 

II 

II Reinitialize the.text attribute to a blank character. 

II 

II Parameter 

II 

// m 


258 











{ 

} 


// 

// Return Value 

11 

11 n/a 

II 

11 End - 

strcpy(the.text, 









// File Header - 

II .■■ 

I!.Filename .; thread.h 

II.sees ID .; 1.3 

II.Release No....: 1 

U.Date .; 9/16/91 

! I .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .eompiler ..• Glockenspiel G++ 2.1 

II . 

// End header comments - 

#ilndel _THREADJI 
#def in« -THREADJI 

// sees ID follows: will compile to place date/time stamp in 
II object file 

static char thread.h_SccsId[] = "«(#)thread.h 1.3\t9/16/91" 
// Gontents -- 

II 

// THREAD 

II 

II Description 

II 

II Defines class THREAD. 

n 

U End - 

// Interface Dependencies - 

#includ« <Obj«ct.h> 

#includ« <Dictionary.h> 

#inclttde <R«l«renc«.h> 

#includa”R«farancaNacros .h” 

#includa <8traaB.hxx> 

class V.OBJECT; 

// End Interface Dependencies - 

TypeCheckReferencefVOListReference, Reference, Dictionary); 

class THREAD : public Object 

{ 

private: 

int current-version; If most recent ret. 

VOListReference theJist; 

public: 


260 
























THREAD(APL ♦theAPL); 

THREAD(char ^id); 

virtual void Destroy (Boolean aborted=FALSE); 
virtual Type ♦getDirectType(); 
int getCurrentVersionNumO; 

V-0EJECT ♦currentO; 

V.OBJECT ♦version(int versionJd); 
void add_object(V.OBJECT *newjDbject); 
void displayThreadVersions(); 
void displayThreadContents(); 

}; 


// Description - 

// 

// Defines a THREAD class. The class COMPONENT is a derived class 
II of Object (i.e. It is a persistent class). A thread may 
II contain multiple versions of an COMPONENT, composite or 
II configurations. 

II 

II Constructor 

// 

// Thread - A PL 

// 

// ONTOS required constructor. 

II 

II Thread 

II 

II Constructs a thread with the given name. 

II 

II Public Members 

II 

II Destroy 

II 

II Used in lieu of a class destructor. 

II 

II getDirectTypc 

II 

II ONTOS required method to return the class type. 

II 

II getCurrentVersionNum 

// 

// Returns the version number of the vobject last add to the thread. 

II 

II current 

II 

II Returns a pointer to the current vobjeci in the thread. 

II 

II version 

n 

II Returns a pointer to a user designated version of a vobjeei. 

II 


261 








// add.Object 

// 

// inserts a vobject into the thread. 

// 

// displayTkreadVersions 

// 

II List the version numbers of vobjects contained in the thread. 

II 

II displayThreadContents 

n 

II Displays the version number and description of each vobject in the thread. 

II 

u End - 


#endil // -THREAD.H 


262 








// File Header -- 

// . 

I/.Filename .; thread.cxx 

11.sees ID ..• 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

11 . 

// End header comments - 

// sees ID follows: will compile to pla ce date/iime stamp in object file 

static char thread.cxx-SccsldO = "®(#)thr«ad.cxx 1.3\t9/16/91"; 

// Gontents --- 

// 

// THREAD::THREAD ONTOS constructor 

// THREAD.-.THREAD new instance constructor 

// THREAD::Destroy 

// THREAD::getDirectType 

// THREAD::geteurreni VerswnNum 

// THREAD::current 

// THREAD::verston 

// THREAD::add,object 

// THREAD::displayThreadVersions 

// THREAD::displayThreadeontenls 

n 

// Description 

// 

// Implementation of class THREAD member functions. 

1/ 

// End ---- 


#includ« <GlobalEntitie8.h> 
tinclude <8treaa.hxx> 

#ifndef _THREAD_H 
#includ« ’’thraad.h" 

#endif 

#ifnd«l _VERSIONED-OBJECT_H 
• include ’’v8r8ioned_object.h” 

•endil 

extern Type •THREAD.OType; 
extern Type ♦V.OBJECT-OType; 

THREAD;:THREAD(APL *theAPL); (theAPL) 


263 



















{ 

}; 

THREAD;:THREAD(char ♦!<!): (id) 

// Summary -- 

// 

// Constructs a persistent THREAD object. A thread contains 
II a list of V.OBJECTS (objects which version), and maintains 
II the most current version from that list of versioned 
// objects. 

II 

II A thread is stored in the ONTOS database and is given 
II visibility. Therefore, only one opeiator may generate any 
II given thread. 

II 

11 It is expected that Variations will inherit from threads 
II with two distinctive bits of information: 

II 

II the thread from which it spawned - 

II the version number from which it originated 

n 

II Parameter 

II 

II 

II 

II passed to the ONTOS database and gives persistence and 
II ONTOS visibility to that object 

II 

II Return Value 

II 

II a persistent THREAD in the ONTOS database 

II 

II End --—------- 


( 

itiitDirectType(THREAD_OType): 
current .vcrsion=0; 

Dictionary ♦newJist=new Dictionary(OC-integer. 

V-OBJECT-OType, 

TRUE.FALSE); 

newJist —*putObject(); 

theJist.Reset(newJist, this); 

putObject(); 

); 

void THREAD:;Destroy(Boolean aborted) 

{ 

Destrov(aborted); 

}: 


261 










Type *THREAD:;getDirectType() 


// Summary - 

// 

// returns the ONTOS Type for the prototype class. 

II 

// Return value 

II 

II A pointer to an ONTOS Type. 

II 

u End - 

{ 

return THREAD.OType; 

}: 

int THREAD:;getCurrentVersionNum() 

// Summary - 

II 

II returns *he current version number tn the thread of 
II versioned objects 

II 

// Parameter 

II 

n n/a 

n 

II Return value 

// 

// An integer value representing the current version of the 
II operator/type (as defined by CAPS) 

n 

U End - 

{ 

return current .version: 

} 

V.ORJECT *THREAD;:current() 

// Summary - 

// 

// returns the current versioned object in the thread. 

II 

II Parameter 

II 

n ^/A 

// 

// Return value 

II 

// A V.OB.JECT pointer 


2fio 










// 

// End 


{ 

Dictionary ♦tempJist= (Dictionary*)the_list.Binding(this); 

V-OBJECT ♦mytempvo = (V-OBJECT*)(Entity*)(*tempJist)[current.version] 
return mytempvo; 

}; 


V.OBJECT ♦THREAD;:version(int the.version) 

// Summary - 

// 

// returns the desired version in the thread of versioned 
II objects 

II 

II Parameter 

// 

// A’/^ 

// 

// Return value 

II 

// A V.OBJECT pointer 

II 

II End - 

{ 

Dictionary »tenip-lisf = (Dietionary♦)the-list.Binding(this), 

V-OBJECT ♦mytempvo = (V.OBJECT^)(Entity+)(^tempJist)[lhc.version]; 
return mvtempvo; 

}; 


void THREAD::add-object('/-OBJECT ♦new.object) 

// Summary -- 

II 

II adds a versioned.object to the thread, and updates the 
// current.version attribute to reflect the newer version 

II 

II Parameter 

II 

II new.vobject 

II 

II V.OBJECT pointer 


266 








// 

// Return Value 

il 

11 n/a 

n 

11 End -- 


{ 

if(!this) 

{ 

cout "<ERROR; cannot attach a v.object to a null THREAD>\n"; 
return; 

_ } 

if(!newjobject) 

{ 

cout "<ERR0R: cannot insert a null V-object into a thread>\n ' 
return; 

} 

else 

{ 

current .version = current .version + 1; 

Dictionary ♦tenip.list = (Dictionary*)the.list.Binding(this); 
tempJist —> lnsert(current.version,(Entity ♦)new.object); 
tempJist —> putObject(); 
putObject(); 

} 

}; 

void THREAD:.displayThreaciV’ersions() 

// Summary -- 

// 

// Display the versions within a thread to stdout 

// 

// Parameter 

II 
11 
II 

II Return Value 

II 
11 
// 

// End - 


{ 


Dictionary *temp.list= (Dictionary*)the.list.Binding(this); 

Diet ionary Iterator next( tempJist); 

rerr < "THIS THREAD COHTAIHS THE FOLLOWING VERSIONS:\n\n"; 


267 







while(next.moreData()) 

{ 

V-OBJECT ♦temp=(V.OEJECT ♦)(Entity ♦)next(); 
temp—^display VersionN umber(); 

}; 

}; 


void THREAD;:displayThreadContents() 

{ 


// Summary - 

// 

// Displays the version and description of each versioned 
// object of a thread. 

II 

II NOT USED in current implementation of Design Database. 

II 

II Parameter 

II 

II A’/^ 

// 

// Return Value 

II 

II N/A 
II 

// End - 

Dictionary ♦temp.list= (Dictionary*)the-list.Binding!this); 

Diet ionary Iterator next(tempJist); 

cerr « "THIS THREAD COHTAIHS THE FOLLOWING VERSIONS: \n\n’' 
while(next.moreData()) 

{ 

V-OBJECT ♦temp=(V.OBJECT *)(Entitv ♦)next(); 

temp—‘display Version Number!); 

cout "\n"; 

temp—‘get Description!); 

cout <§: "\n"; 

}; 

}; 


268 







// File Header -- 

// . •• 

jj.Filename .; iree.h 

U-sees ID .; 1.3 

fj.Release No....; 1 

I j.Date .; 9/16/91 

II .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .eompiler .; Glockenspiel (?++ 2.1 

n .•• 

// End header comments -- 

#ilndel _TREE_H 
#define _TREE-H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char tree_h^ccsld[] = "®(#)tree.h 1.3\t9/16/91‘'; 

// Gontents ---- 

// 

// TREE HEADER 

II 

II Description 

II 

II Defines class TREE. 

II 

u End - 

// Interface Dependencies - ----- 

#iindol _TREENODE-H 
#include"treenode.h” 

#endif 

// End Interface Dependencies --- 

class TREE 

{ 

private; 

cliar ♦treejiame; 

TREENODE ♦ theTreeRootNode; 

public: 

TREE(TREENODE ♦.char ♦); // input list and resulting rootnode 
void build-tree(TREENODE ♦.TREENODEJinkcdlist); 
TREENODE ♦find.treenode(TREENODEJinkedlist, char ♦); 

}; 

// Description - 


209 



















// 

// Defines the TREE class. 

II 

II Constructor 

II 

II Constructs a multiway tree from a linked list of nodes 
II identified as operators from reading the subdirectory in 
II TREENODE class. In this tree is one unique TREENODE - 
II the ’’root”. Once the root is identified, reference to 
II the tree can be passed to other classes who can then deal 
II individually with nodes in that tree through the TREENODE 
II class. 

II 

u TREE 

n 

II constructs the tree given a TREENODE object and a character 
II string pointer to the root operator. 

II 

II Public Members 

n 

II build.tree 

// 

// takes in the root TREENODE and a linked list of other 
II generic operator nodes and builds the mvltiway tree using 
II pointers and lists of children nodes. 

II 

II findJreenode 

// 

// given a character string of a TREENODE and a linked list of 
II TREENODES, search the linked list and return a TREENODE 
II pointer on a match. Return a NULL pointer if fails. 

II 

u End - 

#endil // —TREE.H 


270 







// File Header - 

// . 

//.Filename .; tree.cxi 

//.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// . 

// End header comments --- 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char trec-CXx.SccsIdQ = "C(#)tree. exx 1.3\t9/16/91" 

// Gontents --- 

// 

// TREE::TREE 
// TREE::build.tree 
// TREE::findJreenode 
// 

// Description 

// 

// IMPLEMENTS class TREE GONSTRUeTORS. 

// 

// End - 

// Interface Dependencies - 

tinclude <Database.h> 

#includ« <8treaffl.hxx> 

extern "C—" 

( 

#include <8tddel.h> 

#include <8tdlib.h> 

#include <8tdio.h> 

#includa <8tring.h> 

#iiiclud 0 <direiit.h> 
tfinclud* <8y8/8tat.h> 

#include <tiae.b> 

} 

iifndef —TREEJi 
#includ« "trea-h" 

#endif 

#ifnd«f _Ql'El’E_H 
#includ« "queue.h” 


271 
















tendif 


#ilnd«f -NODESUPPORT JI 
tinclude ”nodesupport.h” 
tendif 


//- End Interface Dependencies - 

TREE::TREE(TREENODE ♦future.root,char ♦treename) 

// Summary----— 

// 

// Constructor 

II 

II Parameter 

// 

// future.root 

II 

II TREENODE pointer containing the future root of the multiway 
II tree 
// 

// treename 

II 

II character string - the same name as the root operator 

II 

II Return Value 

II 

II A construted multiway tree reflecting the nodes which 
II exist in the subdirectory and which will be checked into 
II the design database 
, / 

// End - 


{ 

treejiame = new char [strlen(treename)+lj; 
strcpy( tree jiame, treename): 
theTreeRootNode = future joot; 

} 

TREf'NODE ♦TRE E::find.trecnode(T REE NODE Jiiikedlist list.to.search, 

char ♦nodejiame) 


// Summary ---- 

II 

II findJreenode 

II 

II Parameter 

II 

II list.to.search 

II 

u a linked list of TREENODES 


272 







// 

// node.name 

II 

II ike operator/iype io search for (t.e. - ike name of the 
II operators filename MINUS the .ps, .graph, .imp.psdl, 
II .spec.psdl, .a extension 

n 

II Return Value 

II 

II TREENODE tf found - NULL pointer if not found. 

II 

// End - 


{ 

slist jterator listJterator(list-to_search); 
TREENODE ♦tnode; 
while (tnode=list Jterator()) 

if (strcmp(tnode—'gelname().node_nanie)==0) 
return tnode; 
return NULL; 


} 

void TREE:;builcLtree(TREENODE ♦root-node,TREENODE.linkedlist search Jisi) 
// Summary —- 

II 

II Builds a multiway tree containing the nodes in the directory 
II and information required to determine whether a new version 
II of the node must be created in the ONTOS Design Database. 

II 

II Parantcter 

// 

// root.node 

n 

II the unique TREENODE which is the root of this multiway tree 

II 

II searchJist 

II 

II a list of operators in the subdirectory pointed to by the 
II environment variable PROTOTYPE 

II 

II Return Value 

II 

n n/a 
u 

U End - 


{ 

TREENODE ♦ nodeptr; 


273 









TREENODE ♦ temp.TREENODE_ptr; 

TREENODE * new.TREEN0DE4>tr; 

// create the queue inorder to construct the tree 
TREENODE.queue treejiodejqueue; 
tree jiode jqueue.put(root jiode); 

// now the queue has the first TREENODE on it 
while (It'-eejiodejqueue.emptyO) 

{ 

temp.TREEN0DE4)tr = treejiodejcjueue.get(); 

// now iterate through searchJist , look for NODES whose associated 
II strings are ”proper” superstrings of temp^TREENODE.ptr->opera!or.name 
II If they are create a TREENODE for these child nodes, 

II put the TREENODE in queue as well as in temp-TREENODE.ptr->chtldren 
U list. 

slistJterator OperatorPtr(search Jist); 
while (nodeptr=OperatorPtr()) 

{ . 

if (proper-super JV’ODE xheck(nodeptr,temp-TREENODE .ptr—*getname())) 

// create the new TREENODE 

{ 

new-TREEN0DE4)tr = new TREENODE(nodeptr, temp-TREENODE.ptr); 

tree-node-queue, pu t(new-TREENODE-ptr); 

temp-TREENODE-ptr—*insertChildNode(new-TREENODE-ptr); 

} 

} 

} 

} 


274 






// File Header --- 

// . 

/!.Filename .; ireenode.h 

11-sees ID .; 1.3 

jj.Release No....: 1 

II.Dale ..• 9/16/91 

II.Author .; Garry Lewis 

II .; Drew Dwyer 

11 .eompiler .; Glockenspiel C++ 2.1 

// . •• 

II End header comments - 

#ifndel _TREENODE_H 
•define _TREENODE_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char treenodeJi_SccsId|] = "e(#)treenode .h 1.3\t9/16/91" 

II Gontents --— 

// 

// TREE NODE HEADER 

n 

II Description 

II 

u Defines class TREENODE. 

n 

U End - 

// Interface Dependencies - 

• ifndef -QUEUE-H 

• include ”queue.h" 

•endif 

• ifndef -VERSIONED.OBJECTJi 

• include ” vereioned-object. h” 

•endif 

// End Interface Dependencies —- 

class TREENODE; 

class TREENODE 

{ 

private: 

char *tree_nodejiame: 
char *nodejiame; 
long timestamp; 
int level; 

TREENODEJinkedlist ChildrenList; 


27.5 






















TREENODE ♦ ParentNode; 


public: 

TREENODE(cbar ♦.TREENODE ♦); 

TREENODE(TREENODE ♦.TREENODE ♦); 
void updatetimestamp(long time); 
char ♦getname(); 

void insertChildNode(TREENODE ♦); 

TREENODEJinkedlist getChildren(); 

TREENODE ♦getParentNode(); 

char ♦get^c_time(); 

int getlevel(); 

long getJong.time(); 

void list^ubtree(); 

void checkin^ubtree(V-OBJECT ♦); 

V.OBJECT ♦checkinjiode(V-OBJECT ♦); 

}; 

// Description --- 

// 

// TREENODE 

n 

II TREENODE 

II 

II Constructor • Builds a treenodc to be a node plus pointer 
II information for building a multiway tree. 

II 

II updaletimestamp 

// 

// used to compare the most current filestamp of the group of 
II five files in a versioned object from the disk directory 
II pointed to by the CAPS environment variable PROTOTYPE to 
II the locktime of the matching versioned object stored 
II in the Design database. 

II 

II getname 

II 

II returns the character string name of the treenodc. 

II 

II insertChildNode 

// 

// used to insert a node as a child of the current treenodc 

II 

II geiChildren 

// 

// re<ams the linked list of children of this node 

II 

II getParentNode 

II 

II returns the parent of this node 

n 


276 









// gei.ascJime 

// 

// returns the dime fundton for the treenode ttmestamp attribute 

n 

II getJevel 

1 / 

II returns the integer level (0 = root, 1 is removed from root 

III level, etcetera 

II 

II getjongjime 

II 

II returns the timestamp from the treenode as a long that can 
11 be used in a comparison in the checkin^node function 

II 

// lisLsubtree 

II 

II used for debugging. Lists the multiway tree 

n 

II checkin^subtree 

// 

// after the multiway tree built, this function launches the 
II recursion which does the bulk of the work. 

II 

II checkin.node 

// 

// the function which compares the TREENODE (as read from 
II disk) to threads in the database. If a match is found. 

II lockiimes are compared to timestamp and if timestamp is 
II more recent, then a new versioned object is created for 
II the database. All version links are set up in this 
II function 

II 

II End Description ----- 


#endif // header file 


277 












// File Header -- 

// . 

I!.Filename .; treenode.czi 

//.sees ID .; J.a 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// . •• 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char treenode.cxx-SccsIdf] = "«(#)treenode.cxx 1.3\t9/16/91"; 

// eonlents -- 

// 

// TREENODE.-.TREENODE 
// rREENODE::TREENODE 
// TREENODE::updatetimestamp 
// TREENODE::getname 
// TREENODE::insertChildNodc 
// TREENODE::getehildren 
// TREENODE::getParenlNodc 
// TREENODE::get.ascJtm( 

// TREENODE .getlevel 
// TREENODE::get.longMme 
// TREENODE:-.list.subtree 
// TREENODE::cher.kin.subtree 
// TR EE NODE:: checkin,node 
// 

// Description 

// 

// IMPLEMENTS class TREENODE eONSTRlTTORS and methods 

// 

// End - - 

// Interface Dependencies -- 

#includ« <Directory.h> 

#include <8traaa.hzx> 

extern "C—" 

( 

•include <8tddef.h> 

•include <8tdlib.h> 

•include <8tdio.h> 

•include <8tring.h> 

•include <dirent.h> 

•include <8y8/8tat.h> 


278 





















#include <tij[ie.h> 

} 

#ilnd«l _THREAD_H 
#include ”thread.h” 

#endif 

#ilndel _COMPONENT_H 
#include ” component. h” 

#endif 

#ilndel -TEXT-OBJECT JI 
tinclude ”text_object .h” 
tendil 

#ilndef _TREENODE.H 
tinclude ’’treenode.h” 
tendil 

#ilndei -DDBDEFINES.H 
#include ’’ddbdelines .h” 

#endil 

//- End Interface Dependencies 

extern char ♦dirNamePtr; 


TREENODE::TREENODE(char ♦name, TREENODE^ future-parent) 

{ 

treeJiode.name = new char^trlen(name)+i]; 
strcpy (tree jiodejiame, name); 
level=0; 
timestamp = 0; 

ParentNode =future.parenl; 

} 

TREENODE::TREENODE(TREENODE ♦inc.data, TREENODE^ future.parcnt) 

{ 

treejiodejiame = new char[strlen(inc-data—►getname())+l]; 
strcpy (tree .node jiame,inc.data—‘getnameO); 
if ((future.parent)^NULL) 

level=future.parent—*getlevel()+l; 
else 
level=l; 

timestamp = inc.data—‘get.long_time(); 

ParentNode = future 4 )arent; 

} 

void TREENODE::updatetimestamp(long time) 

{ 

timpsfamp=time; 


279 






} 

char ♦TREENODE::getname() 

{ 

return tree Jiodejname; 

} 

void TREENODE::insertChildNode(TREENODE ♦new.child) 

{ 

ChildrenList.in8ert(new.child); 

} 

TREENODEJinkedlist TREENODE:;getChildren() 

{ 

return ChildrenList; 

} 

TREENODE ♦TREENODE;;getParentNode() 

{ 

return ParentNode; 

} 

char *TREENODE::get.asc.time() 

{ 

return ctime(&timestamp); 

} 

int TREENODE:;getlevel() 

{ 

return level; 

} 

long TREENODE::getJong-time() 

{ 

return timestamp; 

} 

void TREENODE:;list jubtree() 

{ 

slistiterator ChildrenPtr(ChildrenList); 

TREENODE ♦tnode; 

for (;;) // recursive call inside infinite for loop 

{ 

tnode = ChildrenPtr(); 
if (tnode^^NULL) 

{ 

char *name=tnode—»getname(); 

int level = tnode—'getlevelO; 

char ♦asctime = tnode—*get.asc_time(); 

cout ■C level "—>" <C name "time: "■Casctime 

tnode—►list-subtree(); /!preorder 


280 



} 

else 

break; // breaks when end of li:i reached. 

} 

} 

void TREENODE::checkin_subtree(V_OBJECT ♦new 4 )arent) 

{ 

slistJterator ChildrenPtr(ChildrenList); 

TREENODE ♦tnode; 

for (;;) // recursive call inside infinite for loop 

{ 

tnode = ChildrenPtr(); 
if (tnode^NULL) 

{ 

V-0EJECT *parent; 

char ♦name = tnode—►getname(); 

cerr < "CHECKIN—> " < name < "\n"; 

parent = tnode—»checkinjiode( new 4 >arent); 

tnode—►checkin^ubtree(parent); / fpreorder 

} 

else 

break; // breaks when end of list reached. 

} 

} 

V.OBJECT ♦TREENODE;:checkin-node(V.OBJECT ♦future.parent) 

{ 

ifstream psfile; 
ifstream graphfile; 
ifstream impfile; 
ifstream specfile; 
ifstream sourcefile; 

Boolean createjiew.vobject = FALSE; 

char ♦psfilename; 

char ♦graphfilename; 

char ♦impfilename; 

char ♦specfilename; 

char ♦sourcefilename; 

char ♦COMPONENT.psfilename; 
char ♦COMPONENT.graphfilename; 
char ♦COMPONENTJmpfilename; 
char ♦COMPONENT.specfilename; 
char ♦COMPONENT.sourcefilename; 

C0MP0NENT4)sfilename = new char[strlen(treejiodejiame)+LENGTH J’SJDXT+2]; 
COMPONENT.graphfilename = new char[strIen(treejiodejiame)+LENGTH.GRAPH Ji)XT+2]; 
COMPONENTJmpfilename = new char[strlen(treejiodejiame)4-LENGTHJMP.EXT+2]; 
COMPONENTjpecfilename = new char[strlen(treejiodejiame)+LENGTH.SPECT.X'I+2]: 


281 




COMPONENT^urcefilename = new char[strlen(treeJiodejiame)+LENGTH-S0URCE-EXT+2]; 

psfilename = new char[strlen(dirNamePtr) +strlen(treejiodejiame)+LENGTH J'S-EXT4-2]; 
graphfilename = new char[strlen(dirNamePtr)+8trIen(tree_nodejiaine)+LENGTH.GRAPH_EXT+2]; 
impfilename = new char[strlen(dirNamePtr)+8trlen(tree_nodejiame)+LENGTHJMP.EXT+2]; 
specfilename = new char[8trlen(dirNamePtr)-f8trlen(treejiodejiame)+LENGTH^PEC-EXT+2]; 
80 urcefilename = new char[8trlen(dirNamePtr)+8trlen(treejiode-name)+LENGTH^OURCEJEXT+2]; 


8trcpy (psfilename,dirN amePtr); 
strcpy (graphfilename,dirNamePtr); 
8trcpy(8pecfilename,dirNamePtr); 
strcpy (impfilename,dirN amePtr); 

8 trcpy( 80 urcefilename,dirNamePtr); 

8trcat(psfilename,"/"); 
strcat(graphfilename,•'/"); 
strcat(specfilename,"/"); 
strcat(impfilename,"/"); 
strcat(sourcefilename,"/"); 

strcat(psfilename,treejiodejiame); 
strcat(graphfilename,treejiodejiame); 
strcat(specfilename,tree jiode jiame); 
strcat(impfikname,tree Jiodejiame); 
strcat(sourcefilename,tree Jiode jiame); 

strcat(psfilename," .ps"); 

8trcat(graphfilename,". graph"); 
strcat(impfilename,". inp.psdl"); 
strcat (specfi len ame,". spa c. psdl"); 
strcat(sourcefilename," .a"); 

strcpy(COMPONENT ^isfilename.treejiode jiame); 
strcpy (COMPONENT graphfilename,tree Jiode Jiame); 
strcpy(COMPONENTjspecfilename,tree Jiode Jiame); 
strcpy(COMPONENTJmpfilename, tree Jiode Jiame); 
strcpy (COMPONENT ^urcefilename,tree jiode jiame); 

8trcat(COMPONENT ^sfilename," -ps"); 
strcat(COMPONENT^raphfilename,". graph"); 
8trcat(COMPONENT Jmpfilename,". imp .psdl"); 
strcat(COMPON ENT specfilename,". spec, psdl"); 
8trcat(COMPONENT sourcefilename," .a"); 

psfile.open(p8filename); 

graphfile.open(graphfilename); 

impfile.open(impfilename); 

specfile.open(specfilename); 

8ourcefile.open(sourcefilename); 


282 






THREAD ♦threadPtr= (THREAD *)0; 

V.OBJECT ♦vobjectPtr =(VjOBJECT ♦)0; 

V-OBJECT ♦new.vobject = (V.OBJECT ♦)0; 
long vobjectJocktime = 0; 
int version N urn = 1; 

if (threadPtr =((THREAD *)OCJookup(treejiodejiame))) 

{ 

vobjectPtr = threadPtr —*current(); // return current vobject 
vobjectJocktime = vobjectPtr —►getLockTime(); // return locktime 
Boolean lastjoperation.was.checkin = vobjectPtr—♦getJastj5peration(); 
if (vobjectJocktime < timestamp) 

{ , 

if (lastjoperation.was.checkin) 

{ 

cout "C "Last operation vas VIA ... Preventing duplicates\n" 
return vobjectPtr; 

} 

else 

{ 

versionNum = vobjectPtr —♦ getVersionNumber() + 1; 
create Jiew.vobject = TRUE; 

} 

} 

} 

else 

{ 

threadPtr = new THREAD(treemode jiame); 
createmew .vobject = TRUE; 

} 

if (vobjectPtr) 

{ 

vobjectPtr—♦release Lock(); 
vobjectPtr—♦resetLastOpTrue(); 

vobjectPtr—‘resetVisitedFlagO; // Just for good measure, before pass 2 
vobjectPtr—♦putObject(); 

} 

if (create jiew.vobject) // if compare says / need a new 
{ 


new_vobject=: new V.OBJECT(versionNum); 
new.vobject—♦connect .vobject-to.thread(threadPtr); 
COMPONENT ♦new.COMPONENT=new COMPONENT(); 
if (psfile) 

{ 

TEXT-OBJECT ♦new4)sfilej3bject= new TEXT.OBJECT(V 
new 4 )sfile job ject—♦append(COM PON ENT 4 )sfilename,psfil' ) 
new-COM PON ENT —•addTextObject(new 4 )sfilejobject' 

} 


283 





if (graphfile) 

{ 

TEXT.OBJECT * n^.-graphfilejobject=new TEXTDBJECT(); 
new^raphfilejobject—append(COMPONLNT^raphfilename,graphfile); 
new.COMPONENT —►addTextObject(new graphfile jobject); 

} 

if (specfile) 

{ 

TEXT-OBJECT * newj5pecfilejobject=new TEXTDBJECT(); 
new .specfile jobject—+append(COMPON ENT ^pecfilename,specfile); 
new-COM PON ENT —►addTextObject(new .specfile jobject); 

} 

if (impfile) 

{ 

TEXT-OBJECT * newJmpfile-object=new TEXT-OBJECT(); 
new jmpfile-object—append(COMPONENTJmpfilename,impfile); 
new-COMPONENT —►addTextObject(new-impfile-object); 

} 

if (sourcefile) 

{ 

TEXT-OBJECT *new .sourcefile x)bject=new TEXT OBJ ECT(); 
newjsourcefilejobject—*append(COMPONENT .sourcefilename,sourcefile); 
new-COMPONENT —►addTextObject(newjsourcefile jobject); 

} 

new .vobject—addCOMPONENTNode(new-COMPONENT); 
threadPtr—►addjobject(new-vobject); 

if (future-parent) 

{ 

if (vobjectPtr) 

future-parent—►deleteChildNode(vobjectPtr); 
future 4 )arent—‘addChildNode(new-vobject); 
future-parent—*putObject(); 

} 

} 

else 

{ . 

if (future-parent) 

{ 

future-parent—*addChildNode( vobjectPtr); 
future-parent—►putObjectO; 

} 

} 

psfile.closeO; 
graphfile.close(); 
impfile.closed; 
specfile.closed; 


284 






sourcefile.close{); 

if (create-new.vobject) 

{ 

new.vobject—►setNodeNatne(getname()); 
new _vobject—»setParent(future .parent); 

return new.vobject; // return new version of vobject as parent 

} 

else 

{ 

vobjectPtr—>setParent(future.parent); 

return vobjectPtr; // return old version of vobject as parent 

} 


28 o 







// File Header --- 

// . ■■ 

//.Filename .; versioned.objeci.h 

//.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.eomptler .; Glockenspiel G++ 2.1 

// . ■■ 

// End header comments --- 

#ilndef -VERSIONED.OBJECTJI 
#delin« _VERSIONED.OBJECTJI 

// sees ID follows: will compile to place date/time stamp in object file 

static char versioned-object_h_SccsId[] = "®(#)versioned_object .h 1.3\t9/16/91" 

#include <0bj «ct.h> 

#includ« <Li8t.h> 

#include <Dictionary.h> 

#include <Refer«nce.h> 

#include”ReferanceMacros .h” 

#includa <streain.hxx> 

extern "C—" 

{ 

#includa <8y8/tima.h> 

#includa <8y8/typa8.h> 

#include <8tring.h> 

} 

#ilndal _THREAD-H 
fincluda "thread.h” 

#endif 

#ilndef -COMPONENT.H 
# include ” component. h” 

#endif 

•define DEFAULT.VER 1 

TypeCheckReference(DescReference, Reference, TEXT-OBJECT); 
TypeCheckReference(COMPONENTObjReference, Reference, COMPONENT); 
TypeCheckReference(ChildVObjReference, Reference, List); 
TypeCheckReference(ThreadObjReference, Reference, THREAD); 

class V-OBJECT : public Object 

{ 

TypeCheckReference(ParentObjReference, Reference, V .OBJECT); 


286 















private: 


int theVersionNumber; 
time.t creationDate; 
time.t lockTime; 
char ♦node_name; 
char ♦creator; 
char ♦worker; 

Boolean visited; // for navigation through tree structure 
Boolean lastjop.checkin; // guards against double checkin 
DescReference theDescriptionPtr; 

ThreadObjReference theThreadPtr; 

COMPONENTObjReference theCOMPONENTPtr; 
ChildVObjReference theChildPtr; 

ParentObjReference theParentPtr; 

public: 

V.OBJECT(APL ♦); 

V-OBJECT(int= DEFAULT .VER); 
void Destroy (Boolean aborted=FALSE); 

Type ♦getDirectTypeO; 

void connect-vobject-to-thread(THREAD ♦); 

void setParent(V-OBJECT ♦); 

void setNodeName(char ♦); 

char ♦getNodeName(); 

void getVObjName(); 

char ♦getNameO; 

void resetVisitedFlagO; 

void setVisitedFlagO; 

Boolean getVisitedFlag(); 
void getVObjComponentsName(); 
void displayVersionNumber(); 
int getVersionNumber(); 
void dumpVObjSummaryO; 
timeT setCreationDate(); 
time.t getCreationDatc(); 
vo'd set Lock (); 
char ♦getWorker(); 
chsu* ♦getCreator(); 
void setWorker(); 
void resetLastOpTVueO; 
void resetLastOpFalseO; 

Boolean get Jastjoperation(); // returns true if last op was checkin 

int releaseLock(); 

time-t getLockTime(); 

void getDescription(); 

void listChildren(); 

void longlistOperatorNames(); 

void listOperatorNaniesl'; 


287 









void updateDescription(char *, ifstream k); 
void addCOMPONENTNode(COMPONENT ♦); 
void deleteChildNode(V_0EJECT ♦); 
void addChildNode(V.OBJECT ♦); 

V.OBJECT *getParent(); 

COMPONENT ♦getCOMPONENTO; 
void dumpSubtree(char ♦); 
void releaseLockSubtreeO; 

List ♦getChildrenO; 

Boolean getChiIdPtr(); 

Boolean checkoutCOMPONENTNode(char *); 
~V.OBJECT() { Destroy(FALSE); }; 

}; 


// Description - 

// V.OBJECT 
11 V.OBJECT 
// 

// Constructors - builds a persistent object in the Ontos 
II database. 

II 

II Destroy 

// 

// Required by Ontos. Every persistent object must have a 
II destroy function. 

II 

II getDirectType 

II 

II Returns an Ontos Type 

II 

II connect.vobject.to.thread 

n 

II Connects a vobject to a thread bearing it’s name. 

II 

II setParent 

II 

II Used to establish links (Transparent References as Ontos 
II calls them) in the Design Database reflecting the 
II decomposition of CAPS operators/types. 

II 

II setNodeName 

// 

// NodeName is maintained as a separate character string field. 

II 

II getNodeName 

n 

II get the shorter NodeName 

II 

II getVObjName 

// 

// Displays the versioned object's name to sidout 


288 






// 

// getName 

II 

11 returns the character string pointer of the Operator Name 

II 

II resetVisitedFlag 

n 

II resets visited to FALSE 

II 

II setVisitedFlag 

II 

II sets visited to TRUE 

II 

II getVisitedFlag 

// 

// returns the value of visited (Boolean) 

// 

// getVObjComponentsName 

// 

// display the different components in the Operator 

II 

II display VerstonNumber 

II 

II Display the version number of the V.OBJECT to stdoui 

// 

// getVersionNumber 

n 

II return the int versionNumber 

n 

II dumpVObjSummary 

II 

II dump predetermined attribute values to the stdout/stdcrr 

// 

// setCreationDate 

II 

II gets the system time and stores it in CreationDate 

n 

II getCreationDaie 

// 

// Displays the creation date as a 26 character ascii text 
II string of the date and time 

II 

II setLock 

n 

II sets the lock to the system time 

II 

II get Worker 

// 

// returns the character string containing the workers name 

II 

II getCreaior 


289 



// 

// returns the character string containing the V-OBJECT 
II creators name 

II 

II set Worker 

II 

II gets the UNIX UserPtr variable and stores the value of that 
II variable into worker 
11 

II reseiLastOpTrue 

II 

II Tells the system that the last operation on that V-OBJECT 
II was a checkin. Prevents duplicate checkins from creating 
II new versioned objects on each checkin 

n 

II resetLastOpFalse 

// 

// resets the last operation immediately following checkin 

II 

// getJast.operation 

n 

II returns a Boolean TRUE if last operation was an add 

II 

II release Lock 

II 

II sets the lockTime back to 0 (epoch time) Sometime in >969. 

1 / 

II gelLockTime 

H 

II return the lockTime as a time.t (long) structure 

II 

II getDescnption 

// 

// Display the V.OBJECT description (if one exists) 

II 

II listChildren 

// 

// list V.OBJECT's chilren 

II 

II longlistOperatorNames 

// 

// list V.OBJECT’s children 

n 

II list Operator Names 

n 

II gives the explicit name of the operator (to include 
II path information from the root V-OB.IECT 
// 

// update Description 

II 

II updates the versioned-objects description. 


200 





// 

// addCOMPONENTNode 

It 

II adds an COMPONENT object to this V.OBJECT using the Ontos 
II binding mechanism 

If 

II deleteChildNode 

n 

II removes an operator from the children list of the 
11 current V.OBJECT 

tl 

II addChildNode 

II 

II adds an operator to the children lisi of the V.OBJECT 

II 

II getParent 

II 

II returns the parent V.OBJECT 

II 

u getCOMPONENT 
// 

// returns an COMPONENT pointer if one is contained in this 
U V.OBJECT 
// 

// dumpSubtree 

tl 

II attempts to rebuild files from versioned objects onto 
II the UNIX subdirectory referenced by the UNIX variable 
U PROTOTYPE 

tl 

II releaseLockSubtree 

tl 

II resets that node and every node under it to zero 
II epoch time (sometime in 1969) 

II 

II getChildren 

It 

II returns a list of the children of the current V.OBJECT 

I! 

II getChildPtr 

It 

II returns a Boolean TRUE if the Cardinality of the list 
II referenced by the theChildPtr is > zero 

tl 

// checkoutCOMPONENTNode 

It 

II attempts to rebuild the .ps, .graph, .imp.psdl, .spec.psdl 
II and .a files of an operator/type stored in the Design 
II Database 

It 

u End - 


291 







#endil 



292 






// File Header - 

// . •• 

I!.Filename .; versioned.object.cxx 

I/.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .; Garry Lewis 

// .; Drew Dwyer 

//.Compiler .; Glockenspiel C++ S.l 

II . 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in object file 

static char versioned-object.cxx^ccsIdQ = "C(#)versionecLobject. exx 1.3\t9/16/91" 

// Contents -- 

II 

// V.OBJECT::V.OBJECT 

// V.OBJECT.-.V.OBJECT 

// V.OBJECT.-.Destroy 

// V.OBJECT'.-.getDirectType 

// V.0BJECT::connect-VobjectJo-thread 

// V.OBJECT::setPareni 

// V.OBJECT::setNodeName 

// V.OBJECT::getNodeName 

// V.OBJECT::getVObjName 

// V.OBJECT::getName 

// V.OBJECT:.resetVxsitedFlag 

// V.OBJECT::setVisttedFlag 

// V.OBJECT::getVisttedFlag 

// V.OBJECT::getVObjComponentsName 

// V.OBJECT:.display VersionNumber 

// V.OBJECT.'.get VersionNumber 

// V^OBJECT::dumpVObjSummary 

// V.OBJECT::setCreaiionDate 

// V.OBJECT.-.getCreationDate 

// V.OBJECT::seiLock 

// V.OBJECT::get Worker 

// V.OBJECT::getCreator 

// V.OBJECT::setWorker 

// V-OBJECT::reseiLastOpTrue 

// V.OBJ ECT ::resetLastOp False 

/ / V.OBJ ECT: :get.last.operatton 

// V.OBJECT::releaseLock 

/ / V.OBJ ECT:: getLockTime 

// V.OBJECT::getDescription 

// V.OBJ ECT::lisiChildren 

// V.OBJECT::longlistOperatorNames 

// V.OBJECT::listOperatorNames 

// V.OBJECT::updateDescription 


293 
















// V.OBJECTr.addCOMPONENTNode 
11 V.OBJECT::deleieChtldNode 
11 V.OBJECTr.addChUdNode 
11 V.OBJECT::geiParent 
11 V.OBJECT::getCOMPONENT 
11 V-OBJECT::dumpSubtrte 
// V-OBJECTr.releaseLockSubtree 
11 V.OBJECTr.getChxldrer. 

11 V.OBJECTr.gtiChildPtr 
11 V-OBJECT::chtckoutCOMPONENTNode 

n 

II Description 

II 

II methods for manipulating versioned objects 

II 

u End - 

// Interface Requirements - 

#include <GlobalEntities.h> 

#include <Directory.h> 

#iindel _VERSIONED.OBJECT 
#include ”ver8ion«d_object .h” 

Xendi'f 

#ilndef _TRACER.H 
#include ’’tracer.h” 
tendil 

#ifndef -DDBDEFINES-H 
#include ’’ddbdelines .h” 

#endif 

// Constructor // 

// End Interface Requirements - 

extern Type ♦V.OBJECT.OType; 
extern userPtr; 


V-OBJECT::V.OBJECT(APL ♦theAPL) : Object(theAPL) 

// Summary - 

II 

II This IS an activation constructor required by ONTOS. 

II ONTOS calls the activation constructor anytime an object 
11 IS brought into memory. Note the constructor passes 
II theAPL to the base class A PL constructor. 


294 










// 

// Parameter 

// 

// theAPL 

// 

// >1 pointer to an APL (for Activation Parameter List) a 
II structure. 


{ 

II empty by design 

}; 

// End -- 

// Constructor // 

V iI)BJECT::V' JDBJECT(int versionNum) 

// Summary - 

It 

II Parameter 

II 

II Functional Description 

11 

{ 

initDirectType(V.OBJECT.OType); 
theVersionNumber = versionNum; 
creation Date = setCreationDate(); 
lockTime = 0; 
last.op.checkin = TRUE; 
visited = FALSE; 

creator = new cheir [strlen(userPtr)+l]; 

strcpy (creator,user Ptr); 

worker = (char ♦)0; 

node-name = (char *)0; 

theDescriptionPtr.initToNullO; 

theCOMPONENTPtr.initToNullO; 

theThreadPtr.initToNullO; 

theParentPtr.initToNull(); 

List ♦newChildList = new List(V-OBJECT-OType); 
newChildList —» putObject(); 
theChildPtr.Reset(newChildList, this); 
putObject(); 

}; 

// End - 

// Member Function (tn lieu of destructor)// 
void V-OBJECT■.■.Destroy(Boolean aborted) 


295 









// Summary - 

// 

// This one is semi tricky. Destroy redefined the Destroy 
II function inherited from the class CleanupObj. Destroy!) 

11 is used to delete CleanupObj objects and those of all its 
// derived classes. In defining any class that is directly 
11 or indirectly derived from CleanupObj, provide the 
II function DestroyfBoolean aborted) in place of a destructor 
II if there is any special processing required when the 
II object's memory is deallocated. 

II 

II Parameter 

n 

// aborted 

II 

II If Destroy!) is called as a result of an abort, aborted 
II is set to TRUE; if it is called to delete the object for 
II other reasons, aborted is set to False. 

// 

// Functional Description 

II 

II CleanupObj in effect provides an audit trail of the 
II creation of all stack-based instances of its derived 
II classes, so that they can be cleanly deleted in the 
II case of an abort during exception handling. Hence 
II the Destroy function. 


{ 

Object;: Destroy (aborted); 

}; 


// End - 

// Member Function // 

Type* V^.OBJECT::getDirectType() 

{ 

return V.OBJECT.OType; 

} 

// Member Function // 

void V-OBJECT::connect.vobjectJ.oJ.hread(THREAD *threadPtr) 

{ 

theThreadPtr.Reset(threadPtr,this); 

putObject(); 

} 

void V.OBJECT::setParent(V-OBJECT ♦parent) 

{ 

theParentPtr.Reset(parent,this); 


296 






putO^ ject(); 

} 

void V.OBJECT::setNodeName(char ♦treejiodejiame) 

{ 

char *token = (chcir *)0; 

token = strrchr(tree Jiode Jiame,’.’); 

if (token) 

{ 

node-name = new char[strlen(token)+l]; 
strcpy(node_name,token); // token in the subtree 
node.name++; // discard period (.) 

} 

else 

{ 

node-name = new char [strlen(treejiode-name)+l]; 
strcpv(node-name,tree-node-name); // must be root root. 

} 

putObject(); 

} 

char ♦V-OBJECT::getNodeName() 

{ 

return node_name; 

} 

char ♦ V-OBJECT::getName() 

( 

char *name; 

Directory *directory; 


if(!this) 

{ 

cerr ■C "<ERROR: cannot get the name of a null V-OBJECT>\n’'; 
return NULL; 

} 

if (ItheThreadPtr) 

{ 

cerr •C "<ERR0R: cannot display the name of a null thread>\n" 
return NULL; 

} 

else 

{ 

THREAD ♦myThreadPtr = (THREAD*) theThreadPtr.Binding(this); 
name = myThreadPtr —» Name(); 

OC-getNameComponents(name, ^directory, tname); 
return name; 

} 

} 


297 





// Member Function // 


void V.OBJECT:;getVObjName() 

{ 

char ♦name; 

Directory ♦directory; 

if(!this) 

{ 

cerr "<ERROR; cannot gat th« nane of a null VJDBJECT>\n"; 
return; 

} 

if (ftheThreadPtr) 

{ 

cerr •C '‘<ERRQR: cannot display th« name of a null thread>\n"; 
return; 

} 

else 

{ 

THREAD ♦myThreadPtr = (THREAD^) theThreadPtr.Binding(this); 
name = myThreadPtr —► Name(); 

OC-getNameComponents(name, Icdirectory, i;name); 
cout name <C "\n"; 

} 


// Member Function // 

void V.OBJECT::getVObjComponentsName() 

{ if(!this) 

{ 

cerr <C "<ERROR: cannot get the names of a null V_OBJECT>\n"; 
return; 

} 

if (ItheCOMPONENTPtr) 

{ 

cerr <C "<Thi8 v.object does not have am COMPONENT coniponent>\n"; 
return; 

} 

else 

{ 

COMPONENT ♦myCOMPONENTPtr = (COMPONENT^) theCOMPONENTPtr.Binding(tliis); 
myCOMPONENTPtr —* getComponentNames(); 

} 


// Member Function // 
void V.OBJECT;:displayVersionNumber() 
// Summary - 


238 




// 

// This function displays the version number of an object. 


{ 

cout <C theVersionNumber <C "\n"; 

}; 

int V'.OBJECT;:getVersionNumber() 

{ 

return theVersionN umber; 

} 

// End - 


// Member Function // 

void V.OBJECT::dumpV'ObjSummary() 

{ 

// display VersionNumber(): 
cerr "Date: 

cout <g; ctime(A:creationDate): 

cerr "Creator. ", 

cout <C getCreatorO 

cerr <g; "Checked out out by "; 

if (worker) 

{ 

cout ^ worker <C "\n"; 

} 

else 

cout < "lOIE \n"; 
cerr <g: "LockTiae: 
if (!lockTime==0) 

cout ctime(A:lockTime): 
else 

cout < "IOME\n\n"; 
cerr <C "\n" 

"De8cription\n" 

< " = = = = = = = = = = = = = = = = = : 
getDescription(); 

} 

!/Member Function // 

time.t V'-OBJECT::setCreationDate() 

{ 

time.t mytloc=0; 
time.t theTime; 

return theTime = time(mytloc): 

} 


\n\n 


20 !) 









I!Member Function // 


void V-OBJECT::setLock() 

{ 

lockTime = setCreationDate(); 

} 

//Member function// 

char ♦V.OBJECT::getWorker() 

{ 

return worker; 

} 

/!Member function// 

char *V.OBJECT;:getCreator() 

{ 

return creator; 

} 

//Member function// 

void V.OBJECT::set\Vorker() 

{ 

ciiar ♦temp.worker = new char [strlen(userPtr)+l]; 
strcpy( temp.worker,userPtr); 
if (worker) 

( 

cerr < "resatworker --> from "< getWorker() < " to temp.worker <"\n' 
delete worker; 

} 

else 

cerr •< "8«tvork«r —> to " <C temp.worker <C"\n"; 
worker = new char[strlen(temp.worker)+l]; 
strcpy( worker, temp.worker); 

} 

//Member Function // 

void V.OBJECT::resetVisitedFlagO 

{ 

visited = FALSE; 

} 

void V’.OBJ ECT: :setVisi ted FlagO 

{ 

visited = TREE; 

) 

Boolean V.O BJ ECT ;:get Visited Flag() 


300 






{ 

return visited; 

} 

I!Member Function // 

void V.OBJECT::resetLastOpTrue() 

{ 

last.op.checkin = TRUE; 

} 

void V-OBJECT:;resetLastOpFalse() 

{ 

last J3p_checkin = FALSE; 

} 

//Member Function // 

Boolean V'.OBJECT::getJast.operation() 

{ 

return last.op.checkin; 

} 

I!Member Function // 

int V'.OBJECT::releaseLock() 

{ 

if (! worker) 

{ 

last.op.checkin = TRUE; 
lockTime = 0; 
return SUCCESS; 

} 

if (strcmp(userPtr,getWorker())==0) 

{ 

last.op.checkin = TRUE; 
lockTime = 0; 
delete worker; 
worker = (char ♦)0; 
return SUCCESS; 

} 

else 

{ 

cerr C "<ERR0R: Only " <C get\Vorker() •C " Hay unlock this object! . . .Aborting>\n" 
return FAILED; 

} 

} 

I/Member Function // 


301 










time.t V-OBJECT.:getCreationDate() 

{ 

return creationDate; 

} 

// Member Function // 

time.t V.OBJECT::getLockTime() 

{ 

return lockTime; 

} 

// Member Function // 

void V.OBJECT;;getDescription() 

// Summary - 

// 

// Tbts function displays the description of an object 

II 

{ 

if(!this) 

{ 

cout "<ERR0R: cannot get the description of a null V.0BJECT>\n"; 
return; 

} 

if (ItheDescriptionPtr) 

{ 

cerr "<Thi8 v.object does not have a description>\n"; 
return; 

} 

else 


TEXT-OBJECT ♦myTextObjectPtr = 

(TEXT.OBJECT*) theDescriptionPtr.Binding(this); 
myTextObjectPtr —»text(cout); 

} 

} 

// Member Function // 

void V.OBJECT::updateDescription(char ♦fileName, ifstreamij input.file.stream) 

{ 

if(!this) 

{ 

cerr "<ERR0R: cannot update the description of a null V_0BJECT>\n” 
return; 

} 


302 




else 

{ , 

if (strcmp(userPtr,getCreator())==0) 

{ 

if( ItheDescriptionPtr) 

{ 

TEXT.OBJECT ♦textObjectPtr = new TEXTDBJECT(); 
textObjectPtr —► append(fileName, inputJile^tream); 
textObjectPtr —*putObjecl(); 
theDescriptionPtr.Reset(textObjectPtr, this); 

} 

else 

{ 

TEXT-OBJECT ♦textObjectPtr = 

(TEXT-OBJECT^) theDescriptionPtr.Binding(this); 
textObjectPtr —» resetTheText(); 
textObjectPtr —> append(filcNatne, inpiit-file.stream); 

} 

} 

else 

cerr ■C "<'ERRQR: only " C gctCreator() <C " Bay update description. Aborting. . .>\n" 

) 

pufObject(); 

} 

// Member Function // 

void V-OBJECT::addCOMPONENTNode(COMPONENT ♦mvCOMPONENTPtr) 

{ 

if (!this) 

{ 

cerr <C! "<ERR0R: cannot set ;he COMPONENT node of a null V_0BJECT\n"; 
return, 

) 

if (IrnyCOMPONENTPtr) 

{ 

cerr ■C "<ERR0R; cannot give to a V_0BJECT a null C0MP0NENT>\n"; 
return: 

} 

theCOMPONENTPtr.Reset(myCOMPONENTPtr, this); 
putObject(); 

} 

// Member Function // 

void V'-OBJECT::deleteChildNode(V'-OBJECT ♦mvV-ObjPtr) 

{ 

List ♦child-nodes = (List ♦)theChildPtr Binding!this); 

if (Ithis) 

{ 


303 





cerr "<ERROR: ceinnot delete the child node of a null V_OBJECT\n' 
return; 

_ } 

if (!child_nodes) 

{ 

cerr <C "<ERR0R: cannot remove a lULL child>\n”; 
return; 

} 

long location =0; 

if (child.nodes—>isMember(my V-ObjPlr)) 

( 

location = child_nodes—>Index(my V.ObjPtr); 
child-nodes—•Rernove(location); 
child-nodes—putObject(), 

} 


// Member Function // 

void \'.OPJF;CT::addC'hildNode(V-OBJECT ♦mvV-ObjPtr) 

{ 

List ♦child-noues = (Idst ♦)theChildPtr.Binding(tliis); 

if ('this) 

{ 

cerr "<ERRQR: cannot set the child node of a null V.0BJECT\n"; 
return; 

_ } 

if (Ichild-nodes) 

{ 

cerr <C "<ERR0R: caumot give to a V-OBJECT a null child>\n"; 
return; 

) 

child-nodes—Insert(my\'-ObjPtr); 
child-nodes—putObject(); 

} 

I!Member Function // 

V -OBJ F:CT ♦ \'-OBJF,CT::get Parent!) 

{ 

return (V'-OBJECT ♦)(Entity *) theParentPtr.Binding(this); 

) 

rOMPONENT *V-OBJECT::getCOMPONENT() 

return (COMPONENT *) (Entity *) theCOMPONENTPtr.Binding(this); 

} 

void V-OBJECT::liotChiidren() 

{ 


304 




if (!this) 

{ 

cerr "<ERROR: can not dump childran o1 a null VJDBJECT! >\n"; 
return; 

} 

if(!theChildPtr) 

{ 

cerr <C "<ERROR: cem not print childran ol a null childPtr!>\n"; 
return; 

} 

else 

{ 


List *childjiodes = (List *) theChildPtr.Binding(this); 

Listiterator ChildrenPtr(child_nodes); 

V.OBJECT ♦cnode; 

while(ChildrenPtr.moreData()) 

{ 

cnode = (V.OBJECT ♦) (Entity ♦) ChUdrenPtr(); 

cerr <C "Operator: "; 

cout -C cnode—►getNodeName(); 

//**♦+♦♦♦♦♦»♦♦ 

// following for loop provides spacing... 
jj «:f*:»t*****t 
int i=0; 

for (i=0;i<(PRINT.VERSION-LOCATlON-strlen(cnode—>getNodeName()));i+ + ) 
cout " "; 
cerr >C "Version: "; 
cout < 1 ; cnode—*getVersionNumber(); 
cout <C "\n"; 

time.t locktime = cnode—‘getLockTimeO; 

cerr -C "Locktime is: " <C ctime(&locktime) -C "\n"; 

} 

return; 

} 

} 

void V.OBJECT::longlistOperatorNames() 

{ 


if (Ithis) 

{ 

cerr C "<ERR0R: can not dump operators of a null VJBJECT! >\n"; 
return; 

} 

if(!theChildPtr) 

{ 

cerr •C "<ERROR: can not print list of a null childPtr! >\n"; 


305 




return; 


} 

else 

{ 


List ♦childjiodes = (List ♦) theChildPtr.Binding(this); 

Listiterator ChildrenPtr(childjiodes); 

V.OBJECT ♦cnode; 
while(ChildrenPtr.moreData()) 

{ 

cnode = (V.OBJECT *) (Entity ♦) ChildrenPtr(); 

// if (cnode->getChUdPtr()) 

//{ 

// cnode-> longlisiOperatorNames(); 

//} 

cerr •C "Operator: 

cout cnode—►getNodeName(); 

/ 

// following for loop provides spacing... 
int i=0; 

for (i=0;i<(PRINT.VERSION-LOCATION-strlen(cnode^getNodeName()));i++) 
cout < " 

cerr -C "\nVer8ion; 

cout cnode—►getVersionNumberO; 

cout ^ "\n"; 

time.t locktime = cnode—►getLockTimeO; 

cerr "Locktine is: " -C ctime(&locktime) "\n”; 

} 

return; 

} 

} 

void V.OBJECT;:listOperatorNames() 

{ 

Boolean node-WoS.visited = FALSE; 
if (ithis) 

{ 

cerr <tC "<ERR0R: can not dump children of a null V.OBJECT! >\n"; 
return; 

} 

if(!theChildPtr) 

{ 

cerr < 1 ; "<ERROR: can not print children of a null childPtr I >\n"; 
return; 

} 

else 

{ 

List ♦childjiodes = (List ♦) theChildPtr.Binding(this); 

Listiterator ChildrenPtr(childmodes); 

V.OBJECT ♦cnode; 


306 




int index = 1; 

while(ChildrenPtr.moreData()) 

{ 

cnode = (V.OBJECT ♦) (Entity ♦) ChildrenPtr(); 
node.was.visited = cnode—►getVisitedFlag(); 
if (cnode—*getChildPtr()) 

{ 

cnode—<■ listOperatorNames(); 

. } 

if (node.was.visited && index >1) 

{ 

cnode—►resetVisitedFlagO; 
cnode—*putObject(); 

break; 

} 

else 

{ 

cnode—* reset VisitedFlagO; 
cnode—►putObjectO; 

} 

if (index ==1) 

cnode—»set Visited Flag(); 
index++; 

cerr •C "Operator: 
cout cnode—►getNameO; 

//♦♦♦♦**♦♦♦♦♦♦ 

// following for loop provides spacing... 

II M********** 

II int i=0; 

// for (t=0;t<(PRINT.VERSION.LOCATION-strlen(cnode->getName())):t++J 

II cout « " 

cerr ^ "\nVer8ion; 

cout <C cnode—‘getVersionNumber(); 

cout < "\n"; 

time.t locktime = cnode—‘getLockTime(); 

cerr "Locktime is: " <€. ctime(A:locktime) •C "\n"; 

} 

resetVisitedFlagO; 

putObject(); 

return; 

} 

} 

void V_OBJECT:;releaseLockSubtree() 

{ 

List ♦childjiodes = (List ♦) theChildPtr.Binding(this); 

List Iterator ChildrenPtr(child Jiodes); 

V.OBJECT *cnode: 

while(ChildrenPtr.moreData()) 

{ 


307 




cnode = (V.OBJECT ») (Entity ♦) ChildrenPtr(); 
if (cnode—>releaseLock()) 
cnode—►putObject(); 
else 
{ 

cerr <C "<Error while unlocking " <C cnode—♦getName() <C " Aborting. . .>\n" 
break; // should try io unlock other siblings and their children. 

} 

if (cnode—♦getChildPtrO) 

{ 

cnode—* releaseLockSubtreeO; 

} 

} 

return; 

} 

void V_OBJECT::dumpSubtree(char ♦file.write-option) 

{ 

Boolean node.was.visited = FALSE; 

Boolean file.operation-successful = FALSE; 

Boolean write.operation = FALSE; 

if (strcmp(file.write-option,"H")==0 || strcmp(file.write.option,"W")==0) 
write.operation = TRUE; 
if (Ithis) 

{ 

cerr "<ERROR: can not dump children of a null V.0BJECT! >\n": 
return; 

} 

if(!theChildPtr) 

{ 

cerr "<ERR0R: can not print children of a null childPtr! >\n"; 
return; 

} 

else 

{ 

List ♦child-nodes = (List ♦) theChildPtr.Binding(this); 

Listiterator ChildrenPtr(child.nodes); 

V.OBJECT ♦cnode; 
int index = 1; 

■while (cnode = (V.OBJECT ♦) (Entity ♦)ChildrenPtr()) 

{ 

node.was.visited = cnode—♦getVisitedFlag(); 
if (cnode—*getChildPtr()) 

{ 

cnode—* dumpSubtree(file.writejoption); 

. } 

if (node.was.visited &A: index > 1) 

{ 

cnode—*rssetVisitedFlag(); 
cnode—*putObject(); 

break; 


308 







} 

else 

{ 

cnode—> reset VisitedFlagO; 
cnode—►putObject(); 

} 

if (index ==1) 

cnode—+set Visited Flag(); 
else 
{ 

cnode—►resetVisitedFlagO; 
cnode—+putObject(): 

} 

index++; 

long cobjectJocktime = 0; 
cobjectJocktime = cnode—►getLockTime(); 
if (cobjectJocktime>0) // prevent checkout 

if (strcmp(file_write.option,"w")==0) // change ’'w" to ”r” 

{ 

cerr -C "<ERR0R: Nodule " •C cnode—►getNodeName() 

■C " locked by : " •C cnode—*getWorker() 

■C " Resetting vrite option to read-only>\n’'; 
strcpy (file.write j3ption,"r*'); 

} 

cerr "<Caution: " < cnode—»getNodeName() 

" is locked.> \n" C "Date Locked; " 

C ctime((i:cobjectJocktinie) 

^ "Mode checked out in read-only mode\n"; 

} 

cerr "lODEHAHE-> " <C cnode—>getNodeName() <C"\n"; 

cerr <§; "Version: " cnode—*getVersionNumber() <C "\n\n": 

file.operation.successful = cnode—►checkoutCOMPONENTNode(file .write xiption); 
if ((file.operationjsuccessful) 

((strcmp(file-writejoption,"W")==0) || 

(strcmp(file.write.option,"w")=:=0))) 

{ 

cnode—»setLock(); 
cnode—►set Worker(); 
cnode—►resetLastOpFalseO; 
cnode—‘putObjectO; 

, } 

if (write.operation) 

strcpy (file.write joption,"®"); 

} 

resetVisitedFlagO; 

putObject(); 

return; 


309 





List ♦ V.OBJECT:;getChildren() 

{ 

List *tempJist = (List ♦)theChildPtr.Binding(this); 
if (tempJist—►CardinalityO > 0) 
return tempJist; 
else 

return NULL; 

} 

Boolean V-OBJECT::getChildPtr() 

{ 

List ♦tempJisi, — (List ♦)theChildPtr.Binding(thi8); 
if (tempJist—♦CardinalityO > 0) 
return TRUE; 
else 

return FALSE; 


// Member Function // 

Boolean V.OBJECT::checkoutCOMPONENTNode(char ♦file.write.option) 

{ 

if (!this) 

{ 

cerr <C "<ERR0R: cannot checkout CQMPOREIIT nodes of a null V-0BJECT\n"; 
return FAILED; 

} 

if (ItheCOMPONENTPtr) 

cerr C "<ERR0R: cannot get the source code from a null C0MP0NEKT>\n"; 
return FAILED; 

} 

else 

{ 

COMPONENT *myCOMPONENTPtr = (COMPONENT*) theCOMPONENTPtr.Binding(this); 
return (myCOMPONENTPtr —* getComponentSource(file-write-option)); 

} 


310 





// File Header - - 

// . 

//.Filename .; vobjecifunc.h 

U-SCCSID .; 1.3 

11 .Release No....: 1 

Ij.Dale .; 9/16/91 

/1 .Author .; Garry Lewis 

II .; Drew Dwyer 

11 .Compiler .; Glockenspiel C++ S.l 

II . 

// End header comments - 

#ilnd«l -VOBJECTFUNC-H 
#d*fin« -VOBJECTFUNCJI 

// sees ID follows: will compile to pla ce date/time stamp in object file 
static char vobjectfunc.h.SccsIdQ = "®(#)vobjectfimc.h 1.3\t9/16/91" 
// eontents ------- 

II 

u VOBJEeTFUNe 
II 

II Description 

II 

II Defines functions manipulating Versioned Objects 
II (Operators) as called by main() 

// 

// End - 

// Interface Dependencies -- 

II 

u NONE 
II 

II End Interface Dependencies -—- 

void list-operatorsJunc(int, char ♦, char ♦. char ♦): 
void update.vobject.desc Junc(int, char *.char *,char ♦,cliar *); 
void get-vobject-desc J'unc(int ,char ♦, char ♦.char ♦); 
void get.vobjectjdateJunc(int , char ♦.char ♦.char ♦); 
void get.vobject.versionsJ‘unc(int . char ♦.char ♦); 
void get.vobject Jock Junc(int, char ♦, char ♦. char ♦); 
void get.vobject.version J'unc(); 

void dump.vobjcctJ3uinmary-func(int . char ♦.char ♦.char ♦); 
void get.vobject 4 ) 8 file Junc(int . char ♦. char ♦.char ♦. char ♦); 
voidget.vobject.graphfileJ'unc(int , char ♦.char ♦.char ♦. char ♦); 
void get.vobject JmpfileJ'unc(int . char ♦. char ♦.char ♦, char ♦), 
void get.vobject.specfile Junc(int . char ♦.char ♦.char ♦, char ♦); 
void get.vobject jourcefileJunc(int , char ♦.char ♦.char ♦, char ♦); 
void dump.vobject JilesJ‘unc(int , char ♦, char ♦.char ♦. char ♦), 
void dump.vobject.treeJunc(int , char ♦, char ♦.cliar ♦, char ♦); 


311 


















void longJist-children-func(int,char ♦, char ♦, char ♦); 
void longJist_parentsJ’unc{int,char ♦, char ♦, char *); 
void longJist.operatorsJ'unc(int, char ♦, char *, char ♦); 
void releasejoperator Jock J‘unc(mt, char ♦, char *, char *); 
void release-subtree Jock J'unc(int, char *, char ♦, char *); 
void add-vobject-andj5ubtree.func(iiit , char ♦, char ♦); 

// Description - 

II 

II Ixst.operatoTs.func 

// 

// Provides a list of operators associated with a 
II subtree of a designated versioned.object. 

n 

// updaie.vobject.desc.func 

II 

II Updates the description text of a designated versioned 
II object. 

II 

II get.vobject.desc.func 

II 

II Provides a description of the designated versioned object. 

II 

II get.vobject.date.func 

II 

II Displays the date that the versioned object was created. 

II 

II get.vobject.versions.func 

II 

II Checks the thread and displays the different versions. 

II 

II get.vobject.lock.func 

II 

II Displays a 26 character text entry reflecting the time 
II and date that the versioned object was locked. 

II 

II gei.vobject.version.func 

II 

II returns the version of the versioned object instance. 

II 

II dump.vobject.summary.func 

II 

II displays predetermined attribute fields to stdout/stderr. 

II 

II get.vobject.psfile.func 

II 

II rebuilds the CAPS postscript file to the PROTOTYPE 
II directory. 

II 

II get.vobject.graphfile.func 

II 


312 




// rebuilds the CAPS graph file to the PROTOTYPE directory. 

II 

II geLvobject.impfile.func 

// 

// rebuilds the CAPS implementation file to the PROTOTYPE directory. 

II 

// get.vobject^pecfile.func 

// 

// rebuilds the CAPS specification file to the PROTOTYPE directory. 

II 

II geLvobject^ourcefile.func 

II 

II rebuilds the CAPS source file to the PROTOTYPE directory. 

II 

II dumpjvobject.files.June 

n 

II rebuilds all of the above files (of one operator) to the 
U PROTOTYPE directory. 

II 

II dump^vojjectJree.func 

II 

u rebuilds all existing TEXT.OBJECT attributes to the PROTOTYPE 
II directory for the entire decomposition of the root operator 
II down to the component operators. May be dumped in "read only" 

II or ”read/write". When dumped, all versioned objects are 
II locked for modification by other users. 

II 

II long.list.children.func 

n 

II lists the node name and version number of children. 

n 

II long.list.parents.func 

n 

II lists the most current parent (and that parents siblings). 

// 

// longjist.operators.func 

II 

II lists the node name and version number of a node's children. 

II 

II release.operatorjock^func 

II 

// reset the locktime of a versioned operator. 

'll 

II release.subtreeJock.func 

II 

II reset the locktime of a versioned operator and all children 
II of that versioned operator. 

II 

/ / add Atobject.and ^subtree.func 

// 

// the reverse of a dumping vobjects. this checks versioned 


313 







// objects back into the database, versioning them if necessary. 

n 

II End Description --- 

#endif // end vobjectfunc header function 


314 






// File Header ---- 

// . 

I!.Filename .; vobjectfunc.cxx 

//.sees ID .; 1.3 

//.Release No....: 1 

//.Date .; 9/16/91 

//.Author .: Garry Lewis 

// .; Drew Dwyer 

//.eompiler .; Glockenspiel C++ 2.1 

// . ■■ 

// End header comments - 

// sees ID follows: will compile to place date/time stamp in object file 

static char vobjectfunc_cxx.SccsId|] = "•(#)vobjactlunc. exx 1.3\t9/16/91*' 

// Gontents - 

// 

// lisLoperators.func 
// update-vobject.desc.func 
// get-vobject.desc.func 
// gei.vobject.date.func 
// geLvobject.versions.func 
// get.vobjectjock.func 
// get-vobject.version.func 
// dump.vobject^ummaryjunc 
// get.vobject.psfile.func 
// get.vobject.graphfileJunc 
// gei.vobject.impfile.func 
// get.vobject^pecfile.func 
// get.vobject^ourcefile.func 
// dump.vobject.files.func 
// dump.vobject-treeJune 
// long.list.children.func 
// long.Ust.parents.func 
// long.list.operators.func 
// release.operator.lock.func 
// release.subtree.lock.func 
// add.vobject.and.subtrec.fuuc 
// 

// Description 

// 

// this contains the functions for manipulating versioned objects 

// 

// End - 

// Interface Dependencies - 

// 


«includ« <8tr«aB.hxx> 
•include <Li8t.h> 


315 



















#include <Directory.h> 

extern "C—"{ 

#includa <stdlib.h> 

} 

#ilndel _DIRECTORYJI 
#include "directory .h” 

#endif 

#ifndef _TREE 
#include "tree.h” 

#endif 

#iliidef _TREENODE_H 
tinclude "treenode.h” 
fendif 

#ifndef _PROTOTYPEJI 
tinclude "prototype .h” 
tendif 

tifndef _COMPONENT_H 
tinclude "component .h” 
tendif 

tifndef _VOBJECT-H 
tinclude ” versioned.object .h” 
tendif 

tifndef _THREAD-H 
tinclude "thread.h” 
tendif 

tifndef _VOBJECTFUNC-H 
tinclude "vobjectfunc.h” 
tendif 

tifndef -DDBDEFINES-H 
tinclude "ddbdef ines .h” 
tendif 

// 

// End Interface Dependencies — 


extern Type ♦THREAD.OType; 
extern Directory ♦prototype.dir; 
PROTOTYPE ♦prototypeptr; 
THREAD *threadPtr; 
COMPONENT ♦COMPONENTPtr. 


316 




long vobjectJocklime =0; 


void list_operators J'unc(int number-arguments, char *proto-name, 

char *operator-name, char ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(proto-name)+5]; 
strcpy (prototype-name,proto-name); 
strcat(prototype-name,PROTOTYPE-EXT); 
switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype-narr''); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—>current(); 
cerr "Operator; 
cout vobjectPtr—«getName(); 

cerr "\nVersion: 

cout -C vobjectPtr—getV'ersionNumberO; 
cout < "\n"; 

time-t locktime = vobjectPtr—getLockTime(); 

ccrr C "Locktime is: " <§; ctinie(i:locktime) «C "\n"; 

vobjectPtr —listOperatorNames(); 

} 

else 

{ 

cout <C "<Error getting thre^-l in LIST OPERATORS• . 

} 

} 

else 

{ 

cout •C "<Error getting Prototype in LIST OPERATORS : >\n' 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operatorjiame); 
if (threadPtr) 

{ 

V'-OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—version(atoi(versionstr)); 

cerr <C "Operator ; 

cout <C vobjectPtr—getName(); 


317 






cerr •<C "\nVer8ion: 

cout <C vobjectPtr—»getWrsionNuinber(); 
cout -C "\n"; 

time.t locktime = vobjectPtr—►getLockTime(); 
cerr "LocktiHe is: ** <; ctime(&locktime) <g; 
vobjectPtr —►listOperatorNamesO; 

} 

else 

{ 

cout "<Error getting thread in GET.VOBJECT.DESC: >\n"; 

} 

} 

else 

{ 

cout <C "<Error getting Prototype in GET-VOBJECT_DESC: >\n’'; 

} 

break; 

default: 

cout <C "<ERR0R: invalid number cirgs for get vobject description>\n" 

} 

} 


void update.vobject.desc j'unc(int number_arguments,char *proto_name, 

char »operator-name, char ♦filename, 
cliar ♦versionstr) 

{ 

char ♦prototype-name = new chfu* [strIen(proto_name)+5]; 

strcpy (prototype .name,proto jiame); 

str*. at(prototype Jiame,PROTOTYPE_EXT); 

ifstream description-file; 
description-file.open(filename); 
if (Idescription Jile) 

cout "<Description File not Found! >\n" 

•C "<Abnonaal terminate from update.vobject-desc_func>\n"; 

else 

{ 

switcli (number.arguments) 

{ 

case 3; 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)0CJook'jp(operator-name), 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—currents); 

vobjectPtr —updateDescriplion(filename,descript ion .file); 

) 

else 


318 









{ 

cout < "<Error getting thread in UPDATE-VOBJECT_DESC:>\n"; 

} 

} 

else 

{ 

cout <c "<Error getting Prototype in UPDATE.VOBJECT-DESC: >\n"; 

} 

break; 
case 4; 

prototypeptr = (PROTOTYPE+)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator_name); 
if (threadPtr) 

{ 

V'-OBJECT ♦vobjectPtr; 

vobjectPlr = threadPtr—*version(atoi(versionstr)); 
vobjectPtr —*updateDescription(filename,description_rile); 

} 

else 

{ 

cout <C "<Error getting thread in UPDATE_VQBJECT-DESC: >\n"; 

) 

} 

else 

{ 

cout < "<Error getting Prototype in UPDATE.VOBJECT-DESC:>\n"; 

} 

break; 
default: 

cout >C "<ERROR: invalid number args lor update vobject description>\n‘' 

} 

} 

} 

void get-vobject-desc J'unc(int number-arguments,char ♦proto_name, 

char ♦operator-name,clrar ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(proto-name)+5]; 
strcpy (prototype-name,proto .name); 
strcat(prototype-name,PROTOTYPEXXT); 

switch (number jirguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(pTototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 


319 



{ 

V-OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—>curreiit(); 
vobjectPtr —►getDescription(); 

} 

else 

{ 

cout "<Error getting thread in GET_VOBJECT.DESC:>\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET_VOBJECT_DESC:>\n"; 

} 

break; 
case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator_name); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—►version(atoi(versionstr)); 
vobjectPtr —►getDescription(); 

} 

else 

{ 

cout "<Error getting thread in GET.VOBJECT.DESC: >\n"; 

} 

} 

else 

{ 

cout •<C "<Error getting Prototype in GET-VOBJECT_DESC: >\n"; 

} 

break; 

default: 

cout "<ERROR: invalid number args lor get vobject description>\n’' 

} 

} 

void release jsubtree Jock Junc(int number-arguments, char ♦protojiame, 

char ♦operator-name,char ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(protoJiame)+5]; 
strcpy (prototype-name,proto-name); 
strcat( prototype-name, PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 2: 


320 



prototypeptr = (PROTOTYPE*)OC Jookup{prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD *)OCJookup(operator_name); 
if (threadPtr) 

{ 

V.OBJECT *vobjectPtr; 
vobjectPtr = threadPtr—►current(); 

if (vobjectPtr—►releaseLockO) 

{ 

vobjectPtr—► putObject(); 
vobjectPtr—♦release LockSubtree(); 

} 

else 

cerr "<Error: Couldn't unlock **<CvobjectPtr—*getNaine() 

<C " Aborting releaseLock for rest of subtree>\n"; 

} 

else 

{ 

cout •C "<Error getting thread in SUBTREE.RELEASE-LOCK: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in SUBTREE.RELEASE-LOCK: >\n’’; 

} 

break; 
case 3: 

prototypeptr = (PROTOTYPE»)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD *)OCJookup(operatorJiame); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—♦version(atoi(versionstr)); 
if (vobjectPtr —►relesiseLock()) 

{ 

vobjectPtr—*putObject(); 
vobjectPtr —»releaseLockSubtree(); 

} 

else 

cerr "<Error: Couldn't unlock "•CvobjectPtr—►getName() 
■C " Aborting releaseLock for rest of subtree>\n"; 

} 

else 

{ 

cout <C "<Error getting thread in SUBTREE.RELEASE.LOCK; >\n"; 

} 


321 








else 

{ 

cout < "<Error getting Prototype in SUBTREE-RELEASE-LOCK: >\n" 

} 

break; 

default; 

cout << "<ERROR: invalid nuaber args for subtree release lock>\n"; 

} 

} 

void releasejaperatorJock.func(int number-arguments, char ♦proto.name, 

char ♦operator-name,char ♦versionstr) 

{ 

char ♦prototype-name = new char [8trlen(proto-name)+5]; 

strcpy{prototypejiame,proto-name); 

strcat(prototype.name,PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—►currentO; 
if (vobjectPtr—*releaseLock()) 
vobjectPtr—►putObjectO; 
else 

cerr "<Error: Couldn’t unlock "CvobjectPtr—*getName() 
•C " Aborting release lock>\n"; 

} 

else 

{ 

cout -C "<Error getting thread in RELEASELLOCK: >\n"; 

} 

} 

else 

{ 

cout < "<Error getting Prototype in RELEASEXOCK: >\n"; 

} 

break; 
case 3: 

prototypeptr = (PROTOTYPE^)OCJookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

{ 


322 







V.OBJECT *vobjectPtr; 

vobjectPtr = threadPtr—►version(atoi(versionstr)); 
if (vobjectPtr—►releaseLockO) 
vobjectPtr—►putObjectO; 
else 

cerr "<Error: Couldn't unlock '‘»CvobjectPtr—►getName() 
" Aborting release lock>\n"; 

} 

else 

{ 

cout ■< "<Error getting thread in RELEASEJ-OCK: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in RELEASEJ,OCK:>\n"; 

} 

break; 

default; 

cout "<ERR0R; invalid number args lor release lock>\n"; 

} 


void get.vobjectjdateJ'unc(iiit number-arguments, char ♦protojiame, 

char *operator-name,char ♦versionstr) 

{ 

char *prototype.name = new char [strlen{protojiame)+5]; 
strcpy (prototype jiame,proto Jiame); 
strcat(prototypejiame,PROTOTYPE_EXT); 
time.t creation-date; 

switch (number-arguments) 

case 2: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD *)OCJookup(operator.name); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—»current(); 
creation.date = vobjectPtr —^getCreationDateO; 
cout C ctime(i:creation-date) <C "\n"; 

} 

else 

{ 

cout <C "<Error getting thread in GET_VOBJECT-DATE: >\n"; 

} 

} 

else 


323 






{ 

cout <C "<Error getting Prototype in GET.VOBJECT.DATE: >\n" 

} 

break; 
case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator Jiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—►ver8ion(atoi(versionstr)); 
creation-date = vobjectPtr —►getCreationDate(); 
cout ctime(&creation-date) *‘\n"; 

} 

else 

{ 

cout < "<Error getting thread in GET.VOBJECT_DATE: >\n' 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET-VOBJECT-DATE: >\n" 

} 

break; 

default; 

cout "<ERROR: invalid number args lor get vobject date>\n"; 

} 

} 

void get.vobject.versions Junc(int number.arguments, char *proto_name, 

char ♦operator-name) 

{ 

char ♦prototype_name = new chsu* [strlen(proto.name)+5]; 
strcpy (prototype .name,proto-name); 
strcat(prototype.name,PROTOTYPE_EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype.name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator.name); 
if (threadPtr) 

{ 

threadPtr—‘displayThreadVersionsO; 

} 

else 

{ 


324 






cout <C "<Error getting thread in GET.VOBJECT.VERSIONS: >\n 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET.VOBJECT.VERSIONS:>\n" 

} 

break; 
default: 

cout "<ERROR: invalid number args for get vobject VERSIONS>\n" 

} 

} 

void get.vobject Jock J‘unc(mt nuniber.arguments, char ♦protojiame, 

char ♦operatorjiame.char ♦versionstr) 

{ 

char *prototypejiame = new char [strlen(protojiame)+5]; 
strcpy(prototypejiame,protojiame); 
strcat(prototypejiame,PROTOTYPE J^XT); 
time.t lock.time; 

switch (numberJirguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)0CJookup(operatorjiame); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—‘CurrentO; 

lock.time = vobjectPtr —►getLockTime(); 

cerr "Locktiae: "; 

cout -C ctime(&lock-time) <C "\n"; 

} 

else 

{ 

cout "<Error getting thread in GET.VOBJECT.LOCK: >\n"; 

} 

} 

else 

{ 

cout ’'<Error getting Prototype in GET.VOBJECT.LOCK: >\n"; 

} 

break: 

case 3: 

prototypeptr = ( PRO JO T^’PF,« )0(' Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadl’tr = (J HRF AI) • K)( ’ Jookup(operator jiame); 


32 .'. 





if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—*version(atoj(versionstr)); 

lock-time = vobjectPtr —»getLockTime(); 

cerr "Locktiae: 

cout <C ctime(&lock-time) •C "\n“; 

} 

else 

{ 

cout < 'VError getting thread in GET.VOBJECT-LOCK; >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET.VOBJECT_LOCK:>\n"; 

} 

break; 

default: 

cout •C "<ERRQR: invalid number args ior get vobject lock>\n"; 

} 


} 

void get.vobject.version_func() 

{ 

cout "lot implemented. Unclear specs for get version of vobject\n’' 

} 

void dump.vobject..summary-func(int number-arguments, char »protojiarne, 

char ♦operator-name,cliar ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(protO-name)+5]; 
strcpy (prototype-name, protojiame); 
strcat(prototype jiame,PROTOTYPE JEXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—»current(); 
vobjectPtr—‘dumpVObjSummaryO; 

} 

else 

{ 


326 




cout C "<Error getting thread in GET.VOBJECT.SUMMARY: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET_VOBJECT_SUMMARY:>\n"; 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejiaine); 
if (protoiypeplr) 

I 

threadPtr = (THREAD *)OCJookup(operator_name); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—•version(atoi(versionstr)); 
vobjectPtr—dumpVObjSummaryO; 

} 

else 

{ 

cout <C "<Error getting thread in GET.VOBJECT.SUMMARY: >\n": 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET.VOBJECT_SUMMARY:>\n"; 

} 

break; 

default: 

cout 4 ; "<ERROR: invalid number args lor get vobject sujiuBary>\n"; 

} 

} 

void get-vobject 4 )sfileJunc(int number^rguments, char ♦protojiame, 

char *operatorJiame.char *file-write.option,cliar *versionstr) 

{ 

char *prototype_name = new char [strlen(proto-name)+5]; 

strcpy(prototypejiame,proto-name); 

strcat( prototype .name,PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype.name); 
if (prototypeptr) 

I 

\ 

threadPtr = (THREAD *)OCJookup(operator-name); 
if (threadPtr) 

{ 

V'-OBJECT *vobjectPtr; 


327 




vobjectPtr = threadPtr—►current(); 

vobject Jocktime = vobjectPtr—►getLockTime(); 

if (vobjectJocktime>0) // prevent checkout 

{ , 

if (strcmp(file.write.option,"B*')==0) // change ”w” to ”r” 

{ 

cerr <C "<E1U10R: Modulo " <C vobjectPtr—»getNodeName() 

" lockod by : " vobjectPtr—►getWorkerO 

" Rosotting vrlto option to read-only>\n“; 

strcpy(file.writej3ption,"r**); 

} 

cerr <C "<Caution; " vobjectPtr—*getNodeName() 

■C " ia locked.> \n" < "Data Locked: " 

<g; ctime(&vobjectJocktime) 

'C "operator files checked out in read-only mode\n" 

} 

else 

cerr "IQOEIAME-> " <g; vobjectPtr—►getNodeName() <g;"\n"; 

COMPONENTPtr =vobjectPtr-.getCOMPONENT(); 
if ((COMPONENTPtr—►getPSfile(file-writej3ption)) 
((strcmp(file_writejDption,"W")==0) 1| 
(strcmp(file.write^ption,"u")==0))) 

{ 

vobjectPtr —» setLock(); // set root lock 
vobjectPtr —► setWorker(); 
vobjectPtr — resetLastOpFalse(); 
vobjectPtr—‘putObjectO; 

} 

} 

else 

{ 

cout <C: "<Error getting thread in GET.VOBJECT.PS: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET.VOBJECT_PS:>\n"; 

} 

break; 
case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator_name); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—*version(atoi(versionstr)); 
vobject Jocktime = vobjectPtr—*getLockTime(); 
if (vobject Jocktime>0) // prevent checkout 
{ 


328 





if (strcmp(file.write-option,"H’')==0) // change ”w” to ”r” 

{ 

cerr < "<EIIR0R: Module *' < vobjectPtr-*getNodeName() 

" locked by : “ vobjectPtr—►getWorker() 

<C " Resetting write option to read-only>\n"; 
strcpy(file.writejDption,*'r"); 

} 

cerr "<Caution: '* ^ vobjectPtr—►getNodeNaine() 

<C " is locked.> \n" 

<C "Date Locked: ctime(fcvobjectJocktime) 

C; "operator files checked out in read-only node\n"; 

} 

else 

cerr < "lODEIlME-> " < vobjectPtr—getNodeName() <"\n"; 

if ((strcmp(file.write.option,"W")==0) || 
(strcmp(file.writej3ption,"s")=:=0)) 

{ 

vobjectPtr — setLock(); // set root lock 
vobjectPtr — setWorker(); 
vobjectPtr — resetLastOpFalse(); 
vobjectPtr—putObject(); 

} 

COMPONENTPtr = vobjectPtr—getCOMPONENT(); 
COMPONENTPtr —getPSfile(file.writejoption); 

} 

else 

{ 

cout <C "<Error getting thread in GET.VOBJECT.PS: >\n"; 

) 

} 

else 

{ 

cout <C "<Elrror getting Prototype in GET_VOBJECT-PS>"; 

} 

break; 

default: 

cout "<ERR0R; invalid number airgs lor get vobject PS>\n"; 

} 


} 


void get-vobject_graphfileJunc(int number.arguments, char ♦protojiame, 

char *operator.name,char *file.write-option,char *versionstr) 

{ 

char ♦prototype-name = new char [strlen(protojiame)+5]; 

strcpy (prototype-name,protomame); 

strcat( prototype .name, PROTOTYPE-EXT); 

switch (number-arguments) 

{ 


329 





case 2; 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)0CJookup(operator Jiame); 
if (threadPtr) 

{ 

V-0EJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—►current(); 
vobjectjocktime = vobjectPtr—♦getLockTime(); 
if (vobjectJocktiine>0) // prevent checkout 

{ , 

if (strcmp(file.write-option,**B")==0) // change "w” to ”r” 

{ 

cerr <C "<ERROR: Module " vobjectPtr—♦getNodeName() 

" locked by : " vobjectPtr—‘getWorkerO 

<C " Resetting write option to read-only>\n"; 
strcpy (file.write jDption,**r"); 

} 

cerr C '‘<Caution: " vobjectPtr—>getNodeName() 

" is locked. > \n" C "Date Locked; " 

-C ctime(icvobjectJocktime) 

•C "operator files checked out in read-only mode\n" 

} 

else 

cerr <IC "lODEIAME-> " C vobjectPtr—♦getNodeName() <C"\n’'; 

COMPONENTPtr =vobjectPtr—getCOMPONENT(); 
if ((COMPONENTPtr—»getGRAPHfile(file.writej3ption)) kk 
((slrcmp(file.writejoption,"¥")==0) H 
(st rcmp(file .write.option. "w")==0))) 

{ 

vobjectPtr —► setLock(); // set root lock 
vobjectPtr —• setWorker(); 
vobjectPtr —* resetLastOpFalse(); 
vobjectPtr—*putObject(); 

} 

} 

else 

{ 

cout <C "<Error getting thread in GET.VOBJECT.GRAPH: >\n"; 

} 

} 

else 

{ 

cout «C "<Error getting Prototype in GET.VOBJECT.GRAPH: >\n"; 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE»)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 


330 



threadPtr = (THREAD *)OCJookup(operator-name); 
if (threadPtr) 

{ 

V-OBJECT *vobjectPtr; 

vobjectPtr = threadPtr—►version(atoi(versionstr)); 
vobjectJocktime = vobjectPtr—►getLockTime(); 
if (vobjectJocktimOO) // prevent checkout 
{ 

if (strcmp(file.write.option,***'*)==:0) // change ”w” to ”r” 

{ 

cerr •C "<ERROR; Module “ ■<C vobjectPtr—►getNodeName() 

" locked by : " 4 ^ vobjectPtr—►getWorkerO 

<C '* Resetting srite option to read-only>\n"; 
strcpy(fiie_writejDption,**r”); 

} 

cerr <C "<Caution: " C vobjectPtr—►getNodeNaine() 

■C " is locked. > \n" 

<C "Date Locked: "<C ctime(&vobjectJocktime) 

«C "operator files checked out in read-only mode\n"; 

} 

else 

cerr •C "lODENANE-> “ <C vobjectPtr—►getNodeNameO •C"\n"; 

if ((strcmp(file-write.option,"W")==0) || 
(strcmp(file.writejDption,"B")==0)) 

{ 

vobjer'Ptr — setLock(); // set root lock 
vobi ^Ptr — setWorker(); 
vol ectPtr — resetLastOpFaIse(); 
vjbjectPtr—»putObject(); 

} 

COMPONENTPtr = vobjectPtr—getCOMPONENT(); 
COMPONENTPtr —getGRAPHfile(file.write.option); 

} 

else 

{ 

cout <C "<Error getting thread in GET_VOBJECT-GRAPH:>\n"; 

} 

} 

else 

{ 

cout ■C "<Error getting Prototype in GET_VOBJECT-GRAPH>"; 

} 

break; 

default; 

cout <C "<ERROR: invalid nuaber args for get vobject GRAPH>\n"; 

} 


} 

void get.vobjectimpfile_func(int number.arguments, char *proto-name. 

char ♦operator-name,char ♦file_write-option,cliar ♦vcrsion.'^tr) 


331 




{ 

cliar ♦prototypejiame = new char [strlen(proto_name)+5]; 
strcpy(prototype Jiame,proto Jiame); 
strcat(prototype jiame,PROTOTYPE_EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)0CJookup(operator-name); 
if (threadPtr) 

{ 

V_OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—i-currentO; 
vobject Jocktime = vobjectPtr—►getLockTime(); 
if (vobjectJocktime>0) // prevent checkout 
{ 

if (strcmp(file-write.option,"s")==0) // change "w” to ”r” 

{ 

cerr ^ "<ERR0R: Nodule *' vobjectPtr—‘getNodeNameO 

■C " locked by : " -C vobjectPtr-►getWorker() 

•C " Resetting write option to read-only>\n’‘; 
strcpy (file.write jDption,"r"); 

} 

cerr "<Caution: " < vobjectPtr—►getNodeName() 

•C " is locked. > \n" < "Date Locked: " 

<SC ctime(X:vobjeciJocktime) 

"operator files checked out in read-only mode\n" 

} 

else 

cerr < "lODEMAME —> " < vobjectPlr^getNodeName() <"\n"; 
COMPONE.NTPtr =vobjectPtr—getCOMPONENT(); 
if ((COMPONENTPtr—*getIMPfile(file-writejDption)) Aife 
((strcmp(file-write-Dption,"W")==0) || 
(strcmp(file.write.option,"w")==0))) 

{ 

vobjectPtr —• setLock(); // set root lock 
vobjectPtr —► setWorker(); 
vobjectPtr —♦ resetLastOpFalse(); 
vobjectPtr—*putObject(); 

} 

} 

else 

{ 

cout <C "<Error getting thread in GET.VOBJECT.IMP: >\n"; 

} 

} 

else 

{ 


332 



cout < "<Error getting Prototype in GET.VOBJECT.IMP: >\n"; 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator Jiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—►version(atoi(versionstr)); 
vobject Jocktime = vobjectPtr—►getLockTime(); 
if (vobjectJocktime>0) // prevent checkout 

{ . 

if (strcmp(file_write-option,"H‘')==0) // change ”w” to ”r” 

{ 

cerr -"C "<ERR0R: Module '' <C vobjectPtr—►getNodeName() 
<C " locked by : " <C vobjectPtr—►getWorker() 

" Resetting write option to read-only>\n"; 
strcpy (file.write joption,"r**); 

} 

cerr "<Caution: " vobjectPtr—►getNodeName() 

<C " is locked. > \n“ 

"Date Locked: "«C ctime(fcvobjectJocktime) 

"operator files checked out in read-only mode\n" 

} 

else 

cerr <IC "8 ''DESAME-> " ■C vobjectPtr—»getNodeName() >C"\n"; 

if ((strcmp(fi'e.write.option,"W")==0) || 

(strcmp( ile.writejoption,"w")==:0)) 

{ 

vobject'Hr —» setLock(); // set root lock 
vobjec'.Ptr —► setWorker(); 
vobjectPtr —* resetLastOpFalse(); 
vobjectPtr—►putObjectO; 

} 

COMPONENTPtr = vobjectPtr^getCOMPONENT(); 
COMPONENTPtr —getlMPfile(file.writejoption); 

} 

else 

{ 

cout C "<Error getting thread in GET.VOBJECT.IMP: >\n"; 

} 

} 


cout <C "<Error getting Prototype in GET-VOBJECT.IMP>"; 

} 

break; 
default: 


333 




cout <C "<ERROR: invalid number eorgs for get vobject IMP>\n"; 

} 


void get.vobjectjspecfile j'unc(int number^rguments, char ♦protojiame, 

char ♦operatorjiame,char ♦file.write_option,char ♦versionstr) 

{ 

char ♦prototypejiame = new char [8trlen(proto_name)+5]; 
strcpy(prototype jiame,proto Jiame); 
strcat(prototypejiame,PROTOTYPE_EXT); 

switch (number^rguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operatorJiame); 
if (threadPtr) 

{ 

V.OEJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—►currentO; 
vobject Jocktime = vobjectPtr—+getLockTime(); 
if (vobjectJocktime>0) // prevent checkout 
{ 

if (strcmp(file-write_option,'*H")==0) // change "w” to ”r” 

{ 

cerr "<ERR0R: Module " <C vobjectPtr—►getNodeName() 

" locked by ; " vobjectPtr—^getWorkerO 

<C " Resetting write option to read-only>\n"; 

strcpy(file.writex>ption,"r"): 

} 

else 

cerr C "<Caution: " vobjectPtr—►getNodeName() 

<C " ie locked.> \n" <C "Date Locked: " 

•C ctime(fcvobjectJocktime) 

■C "operator files checked out in read-only mode\n": 

} 

else 

cerr <C "lODEIAME > " vobjectPtr—>-getNodeName() <C"\n"; 

COMPONENTPtr =vobjectPtr^getCOMPONENT(); 
if ((COMPONENTPtr-*getSPECfile(file_writejoption)) kk 
((strcmp(file.writejoption,"W")==0) || 

(strcmp(file.write.option,"w")==0))) 

{ 

vobjectPtr —* setLock(); // set root lock 
vobjectPtr —> setWorker(); 
vobjectPtr —► resetLastOpFalse(); 
vobjectPtr—*putObject(); 

} 

} 


334 








else 

{ 

cout <C "<Error getting thread in GET_VOBJECT_SPEC:>\n"; 

} 

} 

else 

{ 

cout '‘<Error getting Prototype in GET_VOBJECT-SPEC:>\n"; 

} 

break; 
case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)0CJookup(operatorJiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—>version(atoi(versionstr)); 
vobjectJocktime = vobjectPtr—►getLockTime(); 
if (vobjectJocktime>0) // lock was set..prevent ’’w” checkout 

{ . 

if (strcmp(file-write-option,"B")==0) // if attempting "w” - change to 

{ 

cerr <IC "<ERROR: Module " C vobjectPtr—+getNodeName() 

" locked by : " <C vobjectPtr—►getWorker() 

" Resetting nrite option to road-only>\n"; 
strcpy(file.write jDption,“r"); 

} 

else 

cerr "<Caution: ” <C vobjectPtr—♦getNodeName() 

" is locked.> \n*' "Date Locked; " 
ctime(&vobjectJocktiine) 

< " operator files checked out in read-only mode\n"; 

} 

else 

cerr < "lODEIAME —> " < vobjectPtr—getNodeName() <"\n"; 
COMPONENTPtr = vobjectPtr—getCOMPONENT(); 
if ((COMPONENTPtr —getSPECfile(fiIe.writex.ption)) kk 
((strcmp(file-writej3ption,"W")=:=0) || 
(strcmp(file.write-option,"B")=:=0))) 

{ 

vobjectPtr — setLock(); // set root lock 
vobjectPtr — setWorker(); 
vobjectPtr — resetLastOpFalse(); 
vobjectPtr—putObject(); 

} 

} 

else 

{ 

cout •C "<Error getting thread in GET.VOBJECT-SPEC: >\n"; 


335 





} 

} 

else 

{ 

cout <C "<Error getting Prototype in GET_VOBJECT_SPEC>"; 

} 

break; 
default: 

cout "<ERROR: invalid nuaber arge tor get vobject SPEC>\n"; 

} 


void get.vobjectjsourcefileJ'unc(int number arguments, char ♦proto.name, 

char *operatorjjame,char ♦file.write.option.char *versionstr) 

{ 

char ♦prototypeJiame = new char [strlen(protojaame)+5]; 
strcpy (prototype jiame,proto_name); 
strcat(prototypejiame,PROTOTYPE_EXT); 


switch (number^.rguments) 
{ 


case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototypejname); 
if (prototypeptr) 

{ 

threadPtr = (T 'iREAD ♦)OCJookup(operatorjiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—*current(); 
vobject Jocktime = vobjectPtr—►getLockTime(); 
if (vobjectJocktimoO) // prevent checkout 
{ 

if (strcmp(file-write.option,”w'')==0) // change to "r” 

{ 

cerr «C '’<ERROR; Module " •C vobjectPtr—►getNodeName() 
•C " locked by : " •< vobjectPtr—^getWorkerO 

<C " Resetting urite option to read-only>\n"; 
strcpy(file .write x)ption,"r''); 

} 


} 


else 

cerr "<Caution: " vobjectPtr—►getNodeName() 

-C " is locked.> \n" ^ "Date Locked; " 

•C ctime(&vobjectJocktime) 

<C "operator files checked out in re'.d-only 


inode\n"; 


else 

cerr < "lODEIAHE-> " < vobjectPtr-*getNodeName() <"\n"; 

COMPONENTPtr =vobjectPtr—getCOMPONENT(); 
if ((COMPONENTPtr—•getSOURCEfile(file-writejoption)) kk 
((strcmp(file.writejoption,"W")==0) || 


336 





(strcmp(file.write.option,”B'*)=:=0))) 

{ 

vobjectPtr —> setLock(); 
vobjectPtr —► 8etWorker(); 
vobjectPtr —► resetLastOpFalse(); 
vobjectPtr—♦putObjectO; 

} 

} 

else 

{ 

cout <C "<Error getting thread in GET_VOBJECT_SOURCE: >\n"; 

} 

} 

else 

{ 

cout <C "<Error getting Prototype in GET.VOBJECT.SOURCE: >\n"; 

} 

break; 
case 3; 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype_name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦jOCJookup(operatorJiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—‘version(atoi(versionstr)); 
vobjectJocktime = vobjectPtr—►getLockTime(); 
if (vobjectJocktimoO) // prevent checkout 
{ 

if (strcmp(file.write.option,"w")==0) // change "w” to ”r” 

{ 

cerr •C "<ERR0R: Module " vobjectPtr—»getNodeName() 

•C " locked by : '' <C vobjectPtr-*getWorker() 

" Resetting vrite option to read-only>\n"; 
strcpy(file-writejoption,"r”); 

} 

else 

cerr •C "<Caution: " <C vobjectPtr—►getNodeName() 

^ " is locked.> \n’' "Date Locked: " 

<g; ctime(&:vobjectJocktime) 

"operator files checked out in read-only mode\n" 

} 

else 

cerr ^ "iODEIAHE-> " vobjectPtr—*getNodeName() <t;"\n"; 

COMPONENTPtr = vobjectPtr^getCOMPONENT(); 
if ((COMPONENTPtr—♦getSOURCEfile(file.writejDption)) 
((strcmp(file.writej3ption,”W")==0) || 
(strcmp(file.writejoption,"w")==0))) 

{ 

vobjectPtr —* setLock(); // set root lock 


337 






vobjectPtr —► 8etWorker(); 
vobjectPtr —* resetLastOpFalse(); 
vobjectPtr-+putObject(); 

} 

} 

else 

{ 

cout <C "<Error getting thread in GET_VOBJECT_SOURCE: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in GET_VOBJECT.SOURCE>"; 

} 

break; 

default: 

cout ■C "<ERR0R: invalid number args for get vobject S0URCE>\n"; 

} 


void dump.vobject_filesJ'unc(int number-arguments, char *proto_name, 

char ♦operator.name,char ♦file-write-option,cliar +versionstr) 

{ 

cliar ♦prototype-name = new char [strlen(proto-name)+o]; 

strcpy(prototype-name,proto-name); 

strcat(prototype-name,PROTOTYPE_EXT); 

Boolean filejoperationjsuccessful = FALSE; 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE#)OC Jookup(prototype.name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 
vobjectPtr = threadPtr—»current(); 
vobject Jocktime = vobjectPtr—*getLockTime(); 
if (vobject JocktimoO) 

// lock was set..prevent ”w” checkout 

{ 

if (strcmp(file-writejoption,"H*’)==0) 

//if attempting ”W” - change to ’r" 

{ 

cerr < "<ERR0R: Module ” 

<C vobjectPtr—•getNodeNameO " locked by : 

•C vobjectPtr—*getWorker() 

•C ” Resetting vrite option to read-only>\n"; 
strcpy(file-writej3ption,"r"); 


338 




} 


} 

else 

cerr •< •'<Caution: “ <C vobjectPtr—*getNodeName() 

< •• is locked.> \n" < "Date Locked: " 

< ctime(&vobject Jocktime) 

'•C "operator files checked out in read-onlj siode\n" 


else 

cerr •C "iODEiAME-> " vobjectPtr—►getNodeName() <C"\n"; 

file^perationjsuccessful = 

vobjectPtr —► checkoutCOMPONENTNode(file .writexiption); 
if ((file.operation-successful) iik 

((strcmp(file.writex>ption,"W“)==0) || 

(strcmp(file-write joption,"■")== 0))) 

{ 

vobjectPtr —► setLockO; // set root lock 
vobjectPtr —» setWorker(); 
vobjectPtr —» resetLastOpFalse(); 
vobjectPtr—‘putObjectO; 


, } 

if (Ifile.operation-successful) 

cerr < "<Error checking out " <C vobjectPtr —getName() ; 

} 

else 

{ 

cout < "<Error getting thread in GET.VOBJECT.FILES:>\n’‘; 

} 

} 

else 

{ 

cout < "<Error getting Prototype in GET.VOBJECT.FILES: >\n”; 

} 

break: 
case 3; 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejname): 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operatorJiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr; 

vobjectPtr = threadPtr—►version(atoi(versionstr)); 
vobject Jocktime = vobjectPtr—*getLockTime(); 
if (vobject JocktimoO) // prevent checkout 
{ 

if (strcmp(file.write.option,"w")==0) // change ’’w” to ”r’’ 

{ 

cerr "<ERR0R: Nodule " vobjectPtr—‘getNodeName() 

•C " locked by : " •C vobjectPtr—‘getWorker() 

■C " Resetting srite option to read-only>\n": 


339 





strcpy(file.writej3ption,”r'*); 

} 


} 


else 

cerr •<C ''<Caution: ” <C vobjectPtr—‘getNodeName() 

<C " is locked.> \i»" "Date Locked: " 

C ctime(<£Vobject Jocktime) 

"operator files checked out in read-only mode\n"; 


else 

cerr < "lODElAME-> " < vobjectPtr—getNodeName() <"\n"; 

COMPONENTPtr = vobjectPtr—getCOMPONENT(); 
file.operation^uccessfuI = 

vobjectPtr —► checkoutCOMPONENTNode(file.writex)ption); 
if ((file.operation^ucce8sful) kii 

((8trcmp(file_writejoption,"W")==0) || 
(8trcmp(file.writejoption,"w")==0))) 

{ 


vobjectPtr —♦ setLock(); // set root lock 
vobjectPtr —» setWorker(); 
vobjectPtr —* resetLastOpFalse(); 
vobjectPtr—'putObjectO; 


\ 

if (Ifile.operationjsuccessful) 

cerr ^ "<Error checking out " <C vobjectPtr —'getNameO ; 

} 

else 

{ 

cout "<Error getting thread in CET.VOBJECT.FILES: >\n"; 

} 

} 

else 

{ 

cout <g; "<Error getting Prototype in GET_VOBJECT-FILES>"; 

} 

break; 

default: 

cout "<ERROR: invalid number args for get vobject FILES>\n"; 

} 

) 

void dump-vobject.treeJunc(int numberjirguments, char ♦protojiame, 

char *operator Jiame.char *file.write.option, char ♦versionstr) 

{ 

char ♦prototypejiame = new char (strlen(protojiame)+5]; 
strcpy(prototypejiame,proto-name); 
strcat(prototypejiame,PROTOTY'PE_EXT); 

Boolean file-operationsuccessful = FALSE; 

switch (number-arguments) 


340 




case 3: 

prototypeptr = (PROTOTYPE#)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator Jiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr = threadPtr—‘CurrentO; 
vobjectJocktime = vobjectPtr—♦getLockTime(); 
if (vobjectJocktime>0) // prevent checkout 
{ 

if (strcmp(file.write.option,”B**)==0) // change ”w” to "r” 

{ 

cerr < ''<EilIlOR: Nodule " <. vobjectPtr—►getNodeName() 

" locked by : *‘4; vobjectPtr—►getWorker() 

4; *' Resetting write option to read-only>\n"; 
strcpy(file.writex>ption,“r"); 

} 

cerr 4C "<Caution: " 4 ; vobjectPtr—►getNodeName() 

4; " is locked. > \n" 4 C "Date Locked: " 

4 ; ctime(A:vobjectJocktime) 

4: "Subtree checked out in read-only mode\n"; 

} 

else 

cerr 4 "lODEIAME -> " 4 vobjectPtr—►getNodeName() 

4 "\nVer 8 ion: " 4 vobjectPtr—►getVersionNumber() 4"\n\n" 
file.operationjuccessful = 

vobjectPtr —► checkoutCOMPONENTNode(file.writei3ption); 
if ((file.operationj8uccessful) kk 

((strcmp(file.writejoptiot),"w")==0) {{ 
(strcmp(file.write.option,"M")==0))) 

{ 

vobjectPtr —► setLock(); // set root lock 
vobjectPtr —► setWorker(); 
vobjectPtr —► resetLastOpFalse(); 
vobjectPtr—'putObjectO; 

. } 

if (file-operation-successful) 

vobjectPtr — dumpSubtree(file-writex)ption); 

// dump rest of tree 
else 

cerr 4 "<Error checking out " 4 vobjectPtr -*getName() 

4 " Aborting duBp.vobject.treeLfunc>\n"; 

} 

else 

{ 

cout 4 "<Error getting thread in DUMP.VOBJECT-TREE: >\n"; 

} 


} 

else 

{ 


341 






cout <C "<Error getting Prototype in DUMP_VOBJECT_TREE: >\n"; 

} 

break; 
case 4: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

threadPtr = (THREAD *)OCJookup(operator Jiame); 
if (threadPtr) 

{ 


V.OBJECT ♦vobjectPtr = threadPtr—>ver8ion(atoi(versionstr)); 
vobjectJocktime = vobjectPtr—*getLockTime(); 
if (vobjectJocktime>0) // prevent checkout 
{ 

if (strcmp(file.write.option,**w")==0) // change ’’w” to ”r” 

{ 

cerr •C "<ERR0R: Module " vobjectPtr—‘getNodeNameO 

■C " locked by : ” •C vobjectPtr—'getWorkerO 

•C " Resetting vrite option to read-only>\ii"; 

strcpy (file.write j3ption,*‘r"); 

} 


} 


else 

cerr "<Caution: " iti vobjectPtr—►getNodeName() 

<C " is locked. > \n” "Date Locked: " 

<C ctime(A:vobjectJocktime) 

< "Subtree checked out in read-only mode\n"; 


else 

cerr <C "lODElAME-> " vobjectPtr—*getNodeName() 

<C "\nVersion; " •C vobjectPtr—►getVersionNumber() C'\n\n" 
file.operationjsuccessful = 

vobjectPtr —♦ checkoutCOMPONENTNode(file.write j^ption); 
if ((file.operationjsuccessful) && 

((strcmp(file.writejDption,"w")==0) || 
(strcmp(file-write.option,"W")==0))) 

{ 


vobjectPtr —► setLock(); // set root lock 
vobjectPtr —» setWorker(); 
vobjectPtr —► resetLastOpFalse(); 
vobjectPtr—*putObject(); 


, } 

if (filejoperation successful) 

vobjectPtr — dumpSubtree(file.writejDption); 

// dump rest of tree 
else 

cerr <C "<Error checking out " vobjectPtr —►getName() 
" Aborting duMp.vobject.treeLfunc>\n"; 


} 

else 

{ 


342 




cout <C "<Error getting thread in DUMP_VOBJECT-TREE: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in DUMP_VOBJECT_TREE>"; 

} 

break; 

default: 

cout ''<ERROR: invalid number args lor get vobject TREE FILES>\n" 

} 

} 

void longJist.operators_func(int numberjirguments, char ♦protojiame, 

char ♦operator-name,char ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(proto-name)+5]; 
strcpy( prototype mame,proto-name); 
strcat(prototypemame,PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype.name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

{ 

V'-OBJECT ♦vobjectPtr = threadPtr—‘CurrentO; 
vobjectPtr —♦ longlistOperatorNames(); 

} 

else 

{ 

cout ■C "<Error getting thread in long list operators: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in long list operators: >\n’'; 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operatorJiame); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr = threadPtr—*version(atoi(versionstr)); 
vobject Ptr—‘longlistOperatorN ames(); 


343 





} 

else 

{ 

cout C "<Error getting thread in long list operators:>\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in long list operators>''; 

} 

break; 
default: 

cout "<E]lROR: invalid number args lor long list operators>\n"; 

} 

} 

void longJist.children-func(int number-arguments, char ♦proto.name, 

char ♦operator-name,char ♦versionstr) 

{ 

char ♦prototype-name = new char [strlen(protO-name)+5]; 
strcpy (prototype-name,proto-name); 
strcat(prototype-name,PROTOTYPE_EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototypejiaine); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)0CJookup(operatorjiame); 
if (threadPtr) 

{ 

V-OBJECT ♦vobjectPtr = threadPtr—‘current(); 
vobjectPtr —* listChildren(); 

} 

else 

{ 

cout "<Error getting thread in LOIG-LIST-CHILDREK: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in LOKLLIST.CHILDREI: >\n’'; 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE^)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)©€Jookup(operator-name); 
if (threadPtr) 


344 





{ 

V'-OBJECT ♦vobjectPtr = threadPtr—►version(atoi(versionstr)); 
vobjectPtr—►listChildrenO; 

} 

else 

{ 

cout <C "<Error getting thread in L0IG.LIST.CHILDRE1: >\n" 

} 

} 

else 

{ 

cout "<Error getting Prototype in L01IG_LIST_CHILDREI>"; 

} 

break; 
default: 

cout <C "<ERROR: invalid number args lor long list children >\n" 

} 

} 

void longJist.parents_func(int number-arguments, char ♦proto_name, 

char ♦operator.name,char ♦versionstr) 

{ 

cliar ♦prototype.name = new char [strlen(proto.name)+5]; 
st rcpy (prototype jiame,proto-name); 

St rcat(prototypejiame, PROTOTYPE-EXT); 

switch (number-arguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE#)OC Jookup(prototype-name); 
if (prototypeptr) 

{ 

threadPtr = (THREAD ♦)OCJookup(operator-name); 
if (threadPtr) 

V-OBJECT ♦vobjectPtr = threadPtr—‘CurrentO; 

V-OBJECT ♦parentPtr = vobjectPtr—getParent(); 
if (parentPtr) 

{ 

V-OBJECT ♦grandparent = parentPtr—getParent(); 
if (grandparent) 

grandparent — listChiIdren(); 
else 

cout •C " <\nRoot lode: " 

•C parentPtr—getNodeNameO •C ">\n"; 

} 

else 

cout <C "<Already at Root V-DBJECT>\n"; 

} 

else 

{ 


345 





cout "<Error getting thread in LOHG-LIST.CHILDREH: >\n"; 

} 

} 

else 

{ 

cout "<Error getting Prototype in LOM(LLIST_CHILDREI: >\n"; 

} 

break; 

case 3: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototype_nanie); 
if (prototypeptr) 

{ 

threadPtr — (THREAD ♦)0CJookup(operator Jiame); 
if (threadPtr) 

{ 

V.OBJECT ♦vobjectPtr = threadPtr—►version(atoi(versionstr)); 
V-OBJECT ♦parentPtr = vobjectPtr—»getParent(); 
if (parentPtr) 

{ 

V-OBJECT ♦grandparent = parentPtr—‘getParent(); 
if (grandparent) 

grandparent —> listChildren(); 
else 

cout "<Can’t list Parent/siblings of Root V-Object>\n" 

} 

else 

cout C "<Already at Root VJ3BJECT>\n"; 

} 

else 

{ 

cout «C "<Error getting thread in LOKG.LlST_CHILDRElf: >\n"; 

} 

} 

else 

{ 

cout «C "<Error getting Prototype in LONG.LIST-CBILDREK>"; 

} 

break; 

default; 

cout ■C "<ERR0R; invalid number args for long list children >\n"; 

} 

} 

void add.vobject^ndsubtree Junc(int number.arguinents, char ♦protojiame, 

char ♦operator_name) 

{ 

char ♦prototypeJiame = new char [strlen(protojiame)+5]; 

St rcpy(prototypejiame.proto jiame); 

st rcat( prototy pejiame, PROTOTYPE JEXT); 


346 




switch (numberjirguments) 

{ 

case 2: 

prototypeptr = (PROTOTYPE*)OC Jookup(prototypejiame); 
if (prototypeptr) 

{ 

DIRECTORY ♦capsdirectory; 
capsdirectory = new DIRECTORY(); 
capsdirectory—+readjdirectory(operator .name); 
capsdirectory—►updatetimestampO; 

TREENODEJinkedlist operatorList = capsdirectory—►getOperatorList(); 
TREENODE ♦rootnode = capsdirectory—►findjtreenode(operatorjiame); 
TREENODE *tree_root = new TREENODE(rootnode,NULL); 

TREE ♦workingtree = new TREE(treej’oot, operator .name); 
workingtree—»build_tree(treejoot,operatorList); 
cerr "CHECKIV—> " operatorjiame “C *'\n*'; 

threadPtr = (THREAD ♦)OCJookup(operatorJiame); 

V.OBJECT ♦new4)arent = (V.OBJECT •)0; 
if (threadPtr) 

{ 

V.OBJECT »vobjectPtr = threadPtr—►current(); 
new .parent = vobjectPtr—>getParent(); 

} 

V.OBJECT ♦newj'oot = tree joot—►checkinjiode(new 4 )arent); 
if (!new_-oot) 

{ 

cerr <C "<Error: Could not establish newjroot in" 

•C "add.vobject.and_8ubtree_func. Aborting.>\n"; 
break; 

} 

new j-oot—*set NodeN ame( t ree j-oot—►getname()); 
treejoot—►checkin .subtree(newjoot); 

} 

else 

{ 

cout ■C "<Error getting Prototype in ADD.VOBJECT.Subtree:>\n": 

} 

break; 

default: 

cout "<ERR0R: invalid number args lor add vobject t SUBTREE>\n" 

} 


347 






APPENDIX E 


SETUP FILES 

A. ONTOS HEADERS/MAKEFILES PREPARATION NOTES 

Only the ReferenceMacros.h ONTOS specific header file is included in this appendix 
due to its unique nature. It is a file built after the ONTOS system was released and was not 
included with the standard beta package. 

The makefiles are included as an aid for the user in developing ONTOS applications. 

B. PRINTING NOTES 

This code was prepared for printout using the c-t-+21atex code generator. This generator parses the 
ASCII text input files and places latex commands where directed. This makes the code layout more readable 
and highlights the important data sDoicutes and key words within the C++ code. The latex output was then 
converted to postscript format with the dvitops program. 

C. MAINTENANCE 

This code is maintained at the Naval Postgraduate School Computer Science department. 


348 





// File Header.. 

// . : 

//.Filename.; ReferenceMacros.h 

//.sees ID.: 1.3 

//.Release No....: 1 

//.Date.: 9/16/91 

//.eompiler.: Glockenspiel e-H- 2.1 

// . : 

// End header comments. 

/* 


* Disclaimer: 

* 

* This header Tile is a special header developed entirely by 

* Ontologic, Inc. 

* eopyright (c) 1990, Ontologic, Inc. USA All rights reserved. 

* 

* It’s purpose is to handle Ontos References within the user code of 

* the Design Database System and thus is included as an integral portion 

* of the Design Database code. 

•/ 

#include <Reference.h> 

// Note that the compiler must know that SpecType is an Entity*, 

// e.g., by having seen the appropriate class definition. 

// FOR Macro form use this define and continuation characters. 

#define TypeCheckRefercnce( SpecRcfcrcnce, SupcrRcfcrcnce, SpccTypc )\ 

class SpecReference : public SupcrRcfcrcnce {\ 

public:\ 

SpecReferenceO {)\ 

SpecRefercnce(SpecType* referent. Entity* contexl)\ 

: (referent, context) {}\ 

SpecReference(SpecTypc* referent, StoragcManagcr* conicxt)\ 

: (referent, context) {)\ 

SpccReference(SpecType* refcrcni)\ 

: (referent) {)\ 

void Reset(Entity* referent, Emily* context)\ 

{\ 

SuperReference; :Reset( referent, context);\ 

)N 

void ResetfEntity* referent, StoragcManagcr* contcxt)\ 

{\ 


349 














SuperReference::Reset(teferent, contexi);\ 

)\ 

void Reset(EnUty* refer ^nt)\ 

{\ 

SuperRefcrence;:Reset(referent);\ 

)\ 

void Reset(SpecRefeience& otherRef.\ 

StorageManager* oldContext,\ 

StorageManager* cuirentContext)\ 

{\ 

SuperReference::Reset(otherRef, oldContext, curreniContext);\ 

)\ 

void Reset(SpecReference& otherRef,\ 

Entity* oldContext, \ 

Entity* currentContext)\ 

{\ 

SuperReference:;Reset(otherRef, oldContext, curreniConiexi);\ 

)\ 

void Init(SpecType* referent. Entity* context)\ 

(\ 

SuperReference: :Init(referent, context);\ 

}\ 

void Init(SpecType* referent, StorageManager* contexi)\ 

{\ 

SuperReference; :Init(referent, context);\ 

)\ 

void Init(SpecType* referent)\ 

{\ 

SuperReference::Init(referent);\ 

)\ 

void Init(SpecReference& otherRef, \ 

StorageManager* oldContext, \ 

StorageManager* currentContext)\ 

(\ 

SuperReference::Init(otherRef, oldContext, currentContext);\ 

)\ 

void Init(SpecReference<& otherRef, \ 

Entity* oldContext, \ 

Entity* currentConlexl)\ 

{\ 

SuperReference;:Init(otherRef, oldContext, currentConiexi);\ 

1 \ 

SpccType* Binding(£ntity* context. LockType lock=DefauItLock)\ 

{\ 

return (SpecType*) SuperReference::Binding(conlext, lock);\ 

}\ 

SpecType* Binding(StorageManager* context, \ 

LockType lock=DefaultLock)\ 

{\ 

return (SpecType*) SuperRcfercncc::Binding(context, lock):\ 

)\ 


350 






SpecType* activeBinding(Entity* coniext)\ 

(\ 

return (SpecType*) SuperReference;:acuveBinding(context);\ 

)\ 

SpecType* acUveBinding(StorageManager* context)\ 

{\ 

return (SpecType*) SuperReference::activeBinding(context);\ 

)\ 

) /* invocation supplies final *;’ */ 


#* 

^******«i*»«*«*»»i)i**** ***:«>»»»*»»»»••»*•»**»«***•*»***»* »»»«*****»***»*****4i* 
#* 

#* Oncologic, Inc. 

#* Copyright (c) 1990, Onlologic, Inc. USA All righu reserved. 

#* 

#* 


# file: makefile 
include make-macros 

OBJECTS = main.o componento vcrsioned_objecLo thrcad.o texi_objecLo \ 
prototype.o configuration .o evalualion.o directory .o\ 
tree.o treenode.o queue.o nodesupport.o protfunc.oX 
conffunc.o vobjectfunc.o 

CLASSIFY_HDRS = thread.h lexi_object.h prototype.h configuration.hX 
componenLh versioned_objeci.h 

NONCLASS IF Y_HDRS = evaluation.h directory .h tree.h treenode.hX 

queue.h nodesuppoith protfunc.hX 

conffunc.h vobjcctfunc.h ddbdefines.h tracer.h 

HEADERS = $(CLASSIFY_HDRS) S(NONCLASSIFY_HDRS) 

# . 

# Objectfile/Headerfile dependencies: 

# Persistent classes need their headers, and the application 

# needs all headers. 

# . 

tree.o: tree.h 

nodesupport.o: nodesupport.h 
protfunc.o: protfunc.h 
evaluation.o: ddbdefines.h 
componento: componenLh ddbdefines.h 
thread.o: thread.h ddbdefines.h 
versioned_objecLo: versioned_objecLh 
text_object.o: text_objecuh ddbdefines.h 
configuration.o: configuralion.h 
prototype.o: prototype.h 
main.o: $(HEADERS) 


351 





include make-targets 


#• 

^4i********4i»****»********»*»4i**«**«i**»4i**»********»*****4i********* ********* 
#* 

#• Ontologic, Inc. 

#• Copyright (c) 1990, Ontologic, Inc. USA All rights reserved. 

#• 

^************»4i«»««««*»**«««»•••»*««»««************************************ 
#• 

# file: make-macros 

# . . 

# Cplus sets up function bindings and then calls CC, but 

# doesn’t always produce the best warnings and error-messages 

# So use CC when debugging warnings and eirors, and use 

# cplus to prepare for linking 

# You can choose a compiler on the UNIX command line; just 

# specify COMPILER, e.g., ‘make COMPILER=CC’ 

# . . 

COMPILER = $(ONTOS_BIN)/cplus 
#COMPILER = CC 

# We have versions for SUN and CLOCK 
#WHICH_COMPILER = CC_SUN 
WHICH_COMPILER = CC.GLOCK 

# .-. 

# Flags for classify: See the System Reference 

# By choosing EXTENSION=+X (perhaps on the command line) one 

# enables instance-iteration 

# 

# By choosing VERBOSE=+v (perhaps on the command line) one 

# can see output from ‘classify’ 

# 

#-.- . 

VERBOSE = 

#VERBOSE = +v 
EXTENSION = 

#EXTENS10N = +X 

ONTOS_DIR= /usr/local 
ONTOS_BIN= S(ONTOS_DIR)/bin 

INCLUDE = -l$(ONTOS_DIR)/include/ONTOS -lS(ONTOS_DIR)/incIude/hxx -1/usr/includc 
LIBRARY = -L$(ONTOS_DIR)/lib -lONTOS 


352 








KERNEL.DB = $(ONTOS_DIR)/onios/db/Ontt>sSchema 
REG1STER_FLAG = $(THE_DB_DIR)/alreadyRegistered 

SERVER_HOST= sunSl 

THE_DB_DK = $(HOME)/ontos 
MY.NAME = ddb53 

flrst.target: again 

#• 

#• 

#* Ontologic, Inc. 

#* Copyright (c) 1990, Ontologic, Inc. USA All rights reserved 
#* 

|^******»****»****»**«**»*»**»»*»**»»****»»»»*»*»«*»»4>****»*»4>»**4i*****»»»»* 

#• 


# file: make-targets 

#========================= 

#==========:================= 

# The Tirst part of this file establishes relevant information. 
#========:================= 

#=======:================= 

# . 

# Extra flags for the compiler/1 inker, -g means include debug info. 

# -Bstatic forces the loader to use static libraries, which may 

# help debugging. 

# . - . 

CFLAGS = -g 

LFLAGS = -g -Bstatic 

#. 

# How to make a .0 when its .cxx has been touched. 

#-. 

.SUFFIXES: .cxx 
.cxx.o; 

@echo ‘... Compiling $*.cxx with S(C0MP1LER)’ 

@if 1 ‘‘$(COMPILER)” = “CC” ]; \ 

then ${COMPILER) -c -DS(WHlCH_COMPILER) $(CFLAGS)\ 
SflNCLUDE) $*.cxx;\ 
rm -f $*.o;\ 
elsc\ 

S(COMPILER) -c -DS(WHlCH_COMPlLER) $(CFLAGS)\ 
SaNCLUDE) $*.cxx;\ 
fi 


353 














#= ===== =========— ^==== == 

# The second pan of this file uses the above information to 

# let you ‘make* the various goals. 
#====================== 

# ==^=====^ ===========- == 

# Recompile/relink/ieload-schemata if necessary 

# --- 

again: main loadTypes 

test: again 

main $(MY_NAME) 

# - 

# Register, compile, link, load-schemata 

# . - . . 

first: register main loadTypes 

#. 

# Link/compile the program, if necessary 

# . 

main: $(OBJECTS) 

@echo... Linking main 

@($(COMPILER) $(LFLAGS) -o main -QUIET\ 

$(Ob;ects) $(library)) 

#.. 

# Establish logical-to-physical mapping for database fragment 

# - - 

register: 

@if {-f $(REGISTER_FLAG) ]; then \ 
echo You are already registered!; \ 
exit 1;\ 

else touch $(REGISTER_FLAG); \ 
fi 

#cp $(KERNEL_DB) S(THE_DB_DIR)/$(MY_NAME) 
#chmod u+w $(THE_DB_DIR)/S(MY_NAME) 

#@echo ... Running DBATool to register 
#(a)S(ONTOS_BIN)/DBATool -e\ 

# register kernel S{M Y_NAME)_kem on S(SER VER_HOST) \ 

# at $(THE_DB_DIR)/$(MY_NAME) 
#@$(ONTOS_BIN)/DBATool -e\ 

# add area $(MY_NAME)_kem to $(MY_NAME) 

#--- 

# Add two more areas to the logical database, which initially 

# contained only the kernel-area. 

# 

# We also illustrate the process of determining which area is 

# primary. 

#-.-.-. 

<a$(ONTOS_BIN)/DBATool -e\ 
create area $(MY_NAME)_A1 on S(SERVER_HOST) \ 


354 











at $(THE_DB_DIRy$(MY_NAME)_areal 
@$(ONTOS_BIN)/DBAToo 1 -e\ 
create area $(MY_NAME)_A2 on $(SERVER_HOST) \ 
at $(THE_DB_DIR)/$(MY_NAME)_area2 
@$(ONTOS_BIN)/DBAToo 1 -e\ 
add area $(MY_NAME)_A1 lo $(MY_NAME) 
@$(ONTOS_BIN)/DBATool -e\ 
add area $(MY_NAME)_A2 to $(M Y_NAME) 
@$(ONTOS_BIN)/DBATool -e\ 
set db $(MY_NAME) primary $(MY_NAME)_kem 
@$(ONTOS_BIN)/DBATool -e\ 
show db $(MY_NAME) 

@$(ONTOS_BIN)/DBATooI -e\ 
show db 

# ---- 

# Make backup copies of the areas, so that we can always start 

# fresh. We can’t simply copy the master version of OnlosSchema 

# since (a) we can register a kernel only once and (b) when 

# we register the kernel, OCServer changes an area-mapping 

# section in the header of the area. 

# . 

@echo 

@echo Waning for the above changes to take hold before 
(S)echo making backup copies, 
sleep 20 

•mkdir $(THE_DB_DIR)/backup 

cp $(THE_DB_DIR)/$(MY_NAME)_Kemel $(THE_DB_DIR)/backup 
cp $(THE_DB_DIR)/S(MY_NAME)_area? $(THE_DB_DIR)/backup 

#. 

# Refresh your Directory in the kernel database, and prime 

# schema for reloading. 

# . 

freshDB: 

@rm -f loadTypes 

@rm -f $(THE_DB_DIR)/*JRN* 

@cp $(THE_DB_DIR)/backup/* $(THE_DB_DIR) 
chmod ugo+rw $(THE_DB_DIR)/S(MY_NAME) 

# . - . 

# Load schemata, i.e., information about user-defined types 

# into the database. Since we don’t support migration, load 

# is performed only on a fresh database 

# 

# -fD indicates logical database. 

# .. 

kMdrypes: $(CLASSIFY_HDRS) 

@make heshDB 
@make loadTypes2 
@ touch loadTypes 


355 





LIST OF REFERENCES 


[Ref. 1] 
[Ref. 2] 
[Ref. 3] 

[Ref. 4] 
[Ref. 5] 

[Ref. 6] 

[Ref. 7] 

[Ref. 8] 

[Ref. 9] 
[Ref. 10] 

[Ref. 11] 
[Ref. 12] 


Booch, G., Software Engineering with ADA, 2d ed., Benjamin/ Cummings, 
1987. 

Tanik, M. M. & Yeh, R. T., “Rapid Prototyping in Software Development”, 
Computer, v. 22, n. 5, pp. 9-11, May 1989. 

Cummings, M.A., The Development of User Interface Tools for the 
Computer Aided Prototyping System, Master’s Thesis, Naval Postgraduate 
School, Monterey, California, December, 1990. 

Luqi, Software Evolution Through Rapid Prototyping, IEEE Computer, v. 22, 
n. 5, pp. 13-25, May 1989. 

McDowell, J. K., A Reusable Component Retrieval System for Prototyping, 
Master’s Thesis, Naval Postgraduate School, Monterey, California, 

September, 1991. 

Bayramoglu, S., The Design and Implementation of an Expander for the 
Hierarchical Real-Time Constraints of Computer-Aided Prototyping System 
(CAPS), Master’s Thesis, Naval Postgraduate School, Monterey, California, 
September, 1991. 

Levine, J., An Efficient Heuristic Scheduler for Hard Real-time Systems, 
Master’s Thesis, Naval Postgraduate School, Monterey, California, 

September, 1991. 

E>ouglas, B. S., A Conceptual Level Design of a Design Database for the 
Computer-Aided Prototyping System, Master’s Thesis, Naval Postgraduate 
School, Monterey, California, March 1989. 

Berzins, V. A., and Luqi, Software Engineering with Abstraction, Addison- 
Wesley Publishing Company, Inc., 1991. 

Berstein, P. A., “Database System Support for Software Engineering — An 
Extended Abstract”, IEEE 9th International Conference on Software, pp. 
166-178,1987. 

Luqi, A Graph Model for Software Evolution, IEEE Transactions on 
Software Evolution, v. 16, n. 8, pp. 917-927, August 1990. 

Loomis, M. E. S., “More on Transactions”, Journal of Object-Oriented 
Programming, v. 3, n. 5, pp. 63-67, January 1990. 


356 




[Ref. 13] Kim, W., “Architectural Issues in Object-Oriented Databases”, Journal of 
Object-Oriented Programmings v. 2 n.6, pp. 29-38, March/April 1990. 

[Ref. 14] Rajiv, G. and Others, “An Object-Oriented VLSI CAD Framework A Case 
Study in Rapid Prototyping”, Computer, v.22, n. 5, pp. 28-37, May 1989. 

[Ref. 15] Yourdon, E., Modern Structured Analysis, Yourdon Press, 1989. 

[Ref. 16] Barnes, R , Graphical User Interface for the CAPS Design Database, 
Software Research Project, Naval Postgraduate School, 1991. 

[Ref. 17] Nestor, Toward a Persisteiu Database, Technical Memorandum, Software 
Engineering Institute, Camegie-Mellon Institute, SEI-86-TM-8, pp 1- 
19DDB. 

[Ref. 18] Mullin, M., Object Oriented Program Design, Addison Wesley, 1989. 

[Ref. 19] Luqi, Computer Aided Software Prototyping, IEEE Computer, pp. 111-112, 
September 1991. 


357 



BIBLIOGRAPHY 


Elmasri, R. & Navathe, S. B., Fundamentals of Database Systems, Benjamin/Cummings 
Publishing Company, 1989. 

Fisher, A.S., Using Software Development Tools, John Wiley & Son, Inc., 1988. 

Lippman, S. B., C+ + Primer, Addison-Wesley Publishing Company, 1990. 

Luqi, Ketabchi, A Computer Aided Prototyping System, IEEE Transactions on Software 
Evolution,March 1988. 

McMenamin, S. M. & Palmer, J. F. , Essential Systems Analysis, Yourdon Press, April 
1984. 

Miller, The Magical Number Seven, Plus or Minus Two : Some Limits on our Capacity for 
Processing Information, The Psychological Review, v. 63, n. 2, pp. 81-97, March, 1956. 

Ontologic Inc., ONTOS Release 2.0 Product Description, Burlington, MA. 

Ontologic Inc., ONTOS Object Database Documentation Release 15, Burlington, MA. 

Nelson, M. L., Object-Oriented Database Management Systems, Technical Report 
NPS52-9G 025, Naval Postgraduate School, Monterey, California, May 1990. 

Page-Jones, M.,The Practical guide to Structured Systems Design, Yourdon Press, 1980. 

Rumbaugh, J. and Others, Object-Oriented Modeling and Design, Prentice Hall, 1991. 

Stroustrup, B., The C++ Programming Language, Addison Wesley, 1986. 

Van Wyk, C. J., Data Structures and C Programs, Addison Wesley, 1988. 

Ward, P. T, Systems Development without Pain, Yourdon Press, 1984. 


358 





INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center 
Cameron Station 

Alexandria, VA 22304-6145 

2. Dudley Knox Library 
Code 52 

Naval Postgraduate School 
Monterey, CA 93943 

3. Computer Science Department 
Code CS 

Naval Postgraduate School 
Monterey, CA 93943 

4. Office of the Assistant Secretary of the Navy 
Research Development and Acquisition 
Department of the Navy 

Attn: Mr. Gerald A. Cann 
Washington, DC 20380-1000 

5. Office of the Chief of Naval Operations 
OP-094 

Department of the Navy 
Attn: VADM J. O. Tuttle, USN 
Washington, DC 20301-3040 

6. Director of Defense Information 

Office of the Assistant Secretary of Defense 
(Command, Control, Communications, & Intelligence) 
Attn: Mr. Paul Strassmann 
Washington, DC 20301-0208 

7. Center for Naval Analysis 
4401 Ford Avenue 
Alexandria, VA 22302-0268 





8. Director of Research Administration 
Attn: Prof. Howard 
CodeOSHk 

Naval Postgraduate School 
Monterey, CA 93943 

9. Chairman, Code CS 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5100 

10. Prof. Luqi, Code CSLq 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943 

11. Chief of Naval Research 
800 N. Quincy Street 
Arlington, VA 22217 

12. Director, Ada Joint Program Office 
OUSDRE (R&AT) 

Room 3E114, The Pentagon 
Attn: Dr. John P. Solomond 
Washington, DC 20301-0208 

13. Carnegie Mellon University 
Software Engineering Institute 
Attn: Dr. Dan Berry 
Pittsburgh, PA 15260 

14. Office of Naval Technology (ONT) 

Code 227 

Attn: Dr. Elizabeth Wald 
800 N. Quincy St. 

Arlington, VA 22217-5000 

15. Defense Advanced Research Projects Agency (DARPA) 
Integrated Strategic Technology Office (ISTO) 

Attn: Dr. B. Boehm 
1400 Wilson Boulevard 
Arlington, VA 22209-2308 


360 






1 


16. Defense Advanced Research Projects Agency (DARPA) 

ISTO 

1400 Wilson Boulevard 
Attn: LCol Eric Mattala 
Arlington, VA 2209-2308 

17. Defense Advanced Research Projects Agency (DARPA) 1 

Director, Tactical Technology Office 

1400 Wilson Boulevard 
Arlington, VA 2209-2308 

18. Attn; Dr. Charles Harland 1 

Computer Science 

Department of the Air Force 
Bolling Air Force Base 
Washington, DC 20332-6448 

19. Chief of Naval Operations 1 

Attn: Dr. R. M. Carroll (OP-01B2) 

Washington, DC 20350 

20. Dr. Amiram Yehudai 1 

Tel Aviv University 

School of Mathematical Sciences 
Department of Computer Science 
Tel Aviv, Israel 69978 

21. Dr. Robert M. Balzer 1 

USC-Information Sciences Institute 

4676 Admiralty Way 
Suite 1001 

Marina del Ray, CA 90292-6695 

22. Dr. Ted 1 ewis 1 

OR State University 

Computer Science Department 
Corvallis, OR 97331 

23. International Software Systems Inc. 1 

12710 Research Boulevard, Suite 301 

Attn; Dr. R. T. Yeh 
Austin, TX 78759 


361 





1 


24. Kestrel Institute 
Attn: Dr. C. Green 
1801 Page MiU Road 
Palo Alto. CA 94304 

25. National Science Foundation 1 

Division of Computer and Computation Research 

Atm: K. C. Tai 
Washington, DC 20550 

26. Commander Space and Naval Warfare Systems Command 1 

SPAWAR 3212 

Department of the Navy 
Attn: Cdr M. Romeo 
Washington, DC 20363-5100 

27. Naval Ocean Systems Center 1 

Atm: Linwood Sutton, Code 423 

San Diego, CA 92152-5000 

28. Office of Naval Research 1 

Computer Science Division, Code 1133 

Atm: Dr. Gary Koob 
800 N. Quincy Street 
Arlington, VA 22217-5000 

29. Commander, Naval Sea Systems Command (PMS-4123H) 1 

Atm: William Wilder 

Washington, DC 20380-1000 

30. New Jersey Institute of Technology 1 

Computer Science Department 

Atm: I>r. Peter Ng 
Newark, NJ 07102 

31. Office of Naval Research 1 

Computer Science Division, Code 1133 

Atm: Dr. A. M. Van Tilborg 
800 N. Quincy Street 
Arlington, VA 22217-5000 


362 






32. Office of Naval Research 
Computer Science Division, Code 1133 
Atm: Dr. R. Wachter 

800 N. Quincy Street 
Arlington, VA 22217-5000 

33. OR Graduate Center 
Portland (Beaverton) 

Atm: Dr. R. Kieburtz 
Portland, OR 97005 

34. Santa Clara University 

Department of Electrical Engineering and 
Computer Science 
Atm: Dr. M. Ketabchi 
Santa Clara, CA 95053 

35. Software Group, MCC 
9430 Research Boulevard 
Atm: Dr. L. Belady 
Austin, TX 78759 

36. University of CA at Berkeley 
Department of Electrical Engineering and 
Computer Science 

Computer Science Division 
Atm: Dr. C.V. Ramamoorthy 
Berkeley, CA 90024 

37. University of CA at Irvine 

Department of Computer and Information Science 
Atm: Dr. Nancy Leveson 
Irvine, CA 92717 

38. Chief of Naval Operations 
Atm: Dr. Earl Chavis (OP-lf^T) 

Washington, DC 20350 

39. Office of the Chief of Naval Operations 
Atm: Dr. John Davis (OP-094H) 

Washington, DC 20350-2(XX) 


1 


1 


1 


1 


1 


1 


1 


1 


363 







40. University of Illinois 
Department of Computer Science 
Atm: Dr. Jane W. S. Liu 
Urbana Champaign, EL 61801 

41. University of MD 

College of Business Management 
Tydings Hall, Room 0137 
Attn: Dr. Alan Hevner 
College Park, MD 20742 

42. University of MD 
Computer Science Department 
Atm: Dr. N. Roussapoulos 
College Park, MD 20742 

43. University of Massachusetts 

Department of Computer and Information Science 
Atm: Dr. John A. Stankovic 
Amherst, MA 01003 

44. University of Pittsburgh 
Department of Computer Science 
Atm: Dr. Alfs Berztiss 
Pittsburgh, PA 15260 

45. University of TX at Austin 
Computer Science Department 
Atm: Dr. A1 Mok 

Austin, TX 78712 

46. Commander, Naval Surface Warfare Center, 

Code U-33 

Attn: Dr. Philip Hwang 
10901 New Hampshire Avenue 
Silver Spring, MD 20903-5000 

47. Atm: George Sumiall 
US Army Headquarters 
CECOM 

AMSEL-RD-SE-AST-SE 
Fort Monmouth, NJ 07703-5000 




1 



1 


1 


1 


1 



1 


1 


1 


364 



48. Attn: Joel Trimble 

1211 South Fern Street, Cl07 
Arlington, VA 22202 

49. United States Laboratory Command 
Army Research Office 

Atm: Dr. David Hislop 
P. O. Box 12211 

Research Triangle Park, NC 27709-2211 

50. George Mason University 
Computer Science Department 
Atm: Dr. David Rine 
Fairfax, VA 22030-4444 

51. Hewlett Packard Research Laboratory 
Mail Stop 321 

1501 Page Mill Road 
Atm: Dr. Martin Griss 
Palo Alto, CA 94304 

52. Carnegie Mellon University 
SEl 

Atm: Dr. Mario Barbacci 
Pittsburgh, PA 15213 

53. Persistent Data Systems 
75 W. Chapel Ridge Road 
Atm: Dr. John Nester 
Pittsburgh, PA 15238 

54. Sun Microsystems Inc. 

MS MTV 100-01 

Silicon Valley Government District 
1842 N. Shoreline Boulevard 
Attn: Vice President c/o Don Chandler 
Mountain View, CA 94043 

55. Commandant of the Marine Corps 
Ada Joint Program Representative 
Code CCl 

Atm: Capt Gerald Depasquale 
Washington, DC 20301 






1 


56. Commandant of the Marine Corps 
Code TE-06 

Washington, DC 20301 

57. Commandant of the Marine Corps 
Code CCT-60 

Atm: Ltcol L. Machabee 
Washington, DC 20301 

58. Commanding General 

Marine Corps Research, Development, 
and Acquisition Command 
Atm.: LtCol Garry W. Lewis 
Quantico, VA 22134 

59. Ontologic, Inc. 

Three Burlington Woods 
Attn: Mr. Gregory Harris 
Burlington, MA 01803 


1 


1 



366 





