INTELLIGENT TUTORING SYSTEM 

THESIS 

Jeremy E. Thompson 
Captciin, USAF 

AFIT/GCS/ENG/96D-27 


affXffcMafr 

kpprarmd ter ptifaittr rateoMN 

Dtetribptkm Dnltettixl quALTIT INSPECTED 3 

DEPARTMENT OF THE AIR FORCE 
AIR UNIVERSITY 

AIR FORCE INSTITUTE OF TECHNOLOGY 


Wright-Patterson Air Force Base, Ohio 





AFIT/GCS/ENG/96D-27 


STUDENT MODELING IN AN 
INTELLIGENT TUTORING SYSTEM 

THESIS 

Jeremy E. Thompson 
Captain, USAF 

AFIT/GCS/ENG/96D-27 


19970317 027 


DnC QUALITY mSPBLTED S 


Approved for public release; distribution unlimited 


AFIT/GCS/ENG/96D-27 


STUDENT MODELING IN AN 
INTELLIGENT TUTORING SYSTEM 


THESIS 


Presented to the Faculty of the Graduate School of Engineering 
of the Air Force Institute of Technology 
Air University 
In Partial Fulfillment of the 
Requirements for the Degree of 
Master of Science 


Jeremy E. Thompson, B.S. 
Captain, USAF 


December 17, 1996 


Approved for public release; distribution unlimited 





Table of Contents 


Page 

List of Figures. iv 

List of Tables. v 

Acknowledgements. vi 

Abstract. vii 

I. Introduction. 1 

1.1 Motivation. 1 

1.2 Background. 2 

1.3 Current Knowledge . 4 

1.4 Assumptions. 5 

1.5 Scope. 5 

1.6 Approach/Methodology. 6 

1.7 Organization of Thesis. 6 

II. Literature Review. 7 

2.1 Introduction. 7 

2.2 Artificial Intelligence. 7 

2.3 Artificial Intelligence in Education. 7 

2.3.1 Computer-Assisted Instruction. 8 

2.3.2 Intelligent Tutoring Systems . 9 

2.4 The Student Model. 10 

2.5 Summary. 13 


11 
























Page 

III. Building the Intelligent Tutoring System (ITS). 14 

3.1 Introduction. 14 

3.2 The Man Behind the Curtain Experiment. 14 

3.3 Modeling the Student. 15 

3.3.1 Overlay models. 15 

3.3.2 Multiple agents in student modeling. 17 

3.4 Learning From the Student. 19 

3.5 Identifying Student Knowledge. 22 

3.6 Student Models vs Instructor Modules. 24 

IV. Contributions and Recommendations . 25 

4.1 Contributions. 25 

4.2 Recommendations. 26 

4.3 Overall Conclusions. 27 

Appendix A. Curtain Driver C"*”'' and C Code. 28 

Appendix B. Curtain ITS CLIPS Code. 38 

Appendix C. Curtain Interface Tcl/Tk Code. 85 

Bibliography. 100 

Vita. 102 


111 























List of Figures 


Figure Page 

1. Bisected Parallel Lines. 16 

2. Expert Solution State Diagram . 16 

3. Alternative Expert Solution State Diagram. 19 

4. Student Solution State Diagram. 21 

5. Alternative Student Solution State Diagram. 21 

6. Lengthy Student Solution State Diagram. 23 


IV 








List of Tables 


Table Page 

1. Sample Geometry Problem. 15 

2. Sample Geometry Proof. 17 








Acknowledgements 

I thank my research advisor, Dr Steven K. Rogers, for his expert advice and assistance. His 
patience and encouragement while I was working on my thesis made my research not only 
educational, but also interesting and bearable. He is the ideal advisor for guiding a wayward 
thesis student to a realizable goal. There is no better research advisor at AFIT. I also wish 
to thank my readers. Dr Matthew Kabrisky and Dr Eugene Santos for their comments 
and suggestions. Their comments helped me recognize shortcomings in my analysis, which 
enabled me to build a stronger thesis. I also owe great thanks to Dan Zambon and Dave 
Doak, the system operators for the Hawkeye computer laboratory. Without their help 
and support, my days would have been consumed with installing and configuring software, 
chasing down untraceable system errors, and pleading with the printers to actually print 
my output, leaving me little time for research. 

Finally, my wife, Colleen, and my sons, Christopher and Stephen, all deserve my 
unending gratitude for suffering through my long education, which began with my under¬ 
graduate studies in 1988. They have supported me throughout my six years of advanced 
education. 


Jeremy E. Thompson 




AFIT/GCS/ENG/96D-27 


Abstract 

This thesis explores a new approach to modeling the student in an intelligent tutoring 
system (ITS), by providing a student model which learns new solutions from the student. 
A prototype of the new approach to ITS is demonstrated in the Euclidean geometry do¬ 
main. Complete CLIPS, and Tcl/Tk code listings are included in the appendices 

for reference. Adaptable multiple software agents were targeted for implementation, based 
on current literature. However, the student model is found to be maintainable without 
multiple software agents, while still allowing for tracking several possible solution paths 
when monitoring student solutions. This capability contradicts previous research reported 
in the literature. The student model is extended by providing a learning module, which 
is capable of recognizing new solutions provided by the student. These new solutions may 
then be included in the expert knowledge base. In addition to a learning student model, 
other concepts from the current ITS literature are explored and implemented. Diiferential 
modeling and expectation driven analysis are analyzed, as well as the use of production 
rules and overlay models. Mastery levels are implemented to aid in cognitive diagnosis. 
Several cognitive and pedagogical concepts, such as symbolic knowledge, procedural skill, 
and conceptual knowledge, are explored and applied to the research. The student model 
prototype is both a pedagogic-content model and a subject-matter model. Additionally, a 
new division of labor between the student model and the instructor module in intelligent 
tutoring systems is described. Particularly, the student model acts strictly as a pedagogic- 
content model and subject-matter model, with no inferencing other than that expected 
of the real student. The instructor module performs all inferencing about the student’s 
actions and knowledge. 


Vll 





[This page intentionally left blank] 









STUDENT MODELING IN AN 


INTELLIGENT TUTORING SYSTEM 

I. Introduction 

1.1 Motivation 

The computer world has been striving to emulate the intelligence of the human brain 
for many years. These attempts at mimicking the reasoning ability of the brain are fre¬ 
quently described as artificial intelligence (AI). One of the most promising, yet most elusive, 
goals of AI is to create an intelligent tutoring system (ITS) with the human teacher’s ability 
to infer a pupil’s level of understanding. An ITS is desirable because schools could better 
afford individualized attention for students if that attention were provided by inexpensive 
computer programs. Currently, all students are required to do all problems because teach¬ 
ers cannot provide individualized attention. Since not all students are the same, not all 
students require the same amount of reinforcement in order to grasp a particular topic. 
Ideally, with an ITS, the student can progress at a pace exactly corresponding to his un¬ 
derstanding. Concepts the student does not understand well will be repeated, while others 
may be presented only once, thus avoiding the workbook mentality of standard classrooms. 
As stated by Anderson, Boyle, and Reiser, we want an ITS that “understands the student 
and responds to the student’s special needs.” (1) 

ITS research is also important to the Air Force and to the military in general. Train¬ 
ing personnel is an expensive requirement. As equipment and weapons become more 
technologically complex, training requirements for maintenance and operations increase. 
Potentially, automated training and education could reduce the number of hours spent 
training and retraining troops, while also freeing domain experts from training require¬ 
ments for actual mission work. A robust ITS could serve the Air Force well: it would not 
only allow automated training of troops, but could train them at the optimal rate for each 
individual. Anderson (1) found a four-to-one advantage for tutored students over classroom 
taught students, when measuring time required to reach proficiency in programming. If 


1 


ITSs successfully attain a similar success rate, all organizations requiring extensive training 
of employees stand to benefit. 

1.2 Background 

Commonly, an ITS is composed of at least three modules: an expert (or domain) 
model, a student model, and an instructor (or pedagogical) module (14). The expert model 
represents information specific to the subject being taught, the student model portrays 
the current student understanding or misunderstanding of the subject domain (9), and the 
instructor module contains knowledge required of teachers to select meaningful lessons for 
their students. 

For example, if the educational topic of interest is a subset of Euclidean geometry such 
as geometric proofs, the expert model might contain information such as the relationships 
between angles in a triangle, e.g. the sum of the measures of the interior angles in a triangle 
is 180 degrees. The student model would then contain a representation of the geometric 
knowledge the student has grasped, possibly including any misconceptions the student 
has apparently formed. In contrast, the instructor module should be wholly, or at least 
primarily, independent of the domain. It would contain, for instance, generic information 
about what criteria determine when a student needs to repeat a portion or all of a topic, 
and an engine for generating or selecting relevant questions. 

One of the most difficult problems when designing an ITS is effectively determining 
and representing the student’s current knowledge of the subject at hand. While important 
progress has been made in ITS development, effectively modeling the student continues to 
present the designer with significant challenges (9). These challenges arise primarily from 
inconsistencies in student reasoning. Students sometimes change their minds, learn new 
material, unlearn old material, and make careless mistakes (17, 7). Moreover, students do 
not necessarily have the ability to completely search their knowledge (7). They may know 
a concept but not recall it for an application. 

In order to model the student’s state of understanding, the program must attempt 
to follow the student’s reasoning. A common method for modeling the student is through 


2 





the use of state models. By providing expert solutions in the form of state models, an 
overlay method can be used to track the student’s progress towards expert solutions (20). 
The overlay method treats student knowledge as a subset of expert knowledge. When the 
student attempts a solution to a posed problem, an overlay student model tries to “overlay” 
the student’s solution onto the expert solution. This works fine when there is one expert 
solution to the problem. In such a case, the student is either working on the expert 
solution, or not. A problem arises when there are multiple solutions to the given problem 
(14). Since the student could choose one of many solutions, or possibly try several before 
settling on one, tracking these many approaches with a state model has been a problem. 
Recalling the inconsistencies in student reasoning discussed in the previous paragraph, it 
is evident that multiple expert solutions magnify the problem of the student changing his 
mind. 

One proposed solution is to use multiple agents to simultaneously represent states in 
several different solution paths (14). Using independent agents allows representing several 
possible states for the student. These states can then be used to help predict the next state 
the student will enter. By using expectation driven analysis, the best student model can be 
selected based on how well it’s predicted state agrees with the student’s actual behavior. 
In most other student models, only one path for modeling the student is tracked, thus 
restricting the expected next states to those that follow the selected line of reasoning. 
Since it is not uncommon for a student to try multiple approaches to a problem before 
settling on one, the multi-agent method allows for more flexibility in modeling student 
behavior, and thus a better match with the student’s real behavior. 

A shortcoming of the multi-agent model, as presented by Leman, (14), is the inabil¬ 
ity to learn from student solutions. The student model expects to have a complete set of 
solutions for the problems presented. Any solutions not found in its knowledge base are 
considered wrong. Acquiring knowledge from the student would avoid classifying poten¬ 
tially correct student solutions as wrong, and would provide for a more robust, complete 
domain model. This author is aware of only one ITS research effort that explores learning 
from the student (16). 


3 





Problem Statement: 

This research will explore the use of multiple software agents to model stu¬ 
dent reasoning. Additionally, the multi-agent student model will be extended 
to include adaptive agents capable of recognizing and learning new solutions 
provided by the student. 

1.3 Current Knowledge 

The genesis of interest in AI in Education at the Air Force Institute of Technology 
(AFIT) was a paper by Matthew Kabrisky (12). Kabrisky discussed the positive impact 
an artificial tutor could have on education. As a hypothetical example of the potential 
for AI, he provided a convincing excerpt of a child’s interactive learning session with an 
ITS. However, his emphasis was the treatment of human/computer interfacing problems, 
leaving the actual tutoring aspects to other authors. 

The basis of this research is the paper by Leman, (14). The authors implemented a 
student model built on an existing ITS known as EDDI (15). EDDI’s student model divided 
knowledge into three levels: static knowledge (S), dynamic knowledge (D), and reasoning 
knowledge (R). Static knowledge was defined as knowledge about the basic concepts of the 
domain being studied, while dynamic knowledge concerned more functional aspects of the 
domain. Reasoning knowledge was defined as knowledge about the student’s reasoning. 

Again using the geometry domain for an example, static knowledge would be general 
concepts about geometry, such as geometrical figures and their configuration. Dynamic 
knowledge would be geometric theorems, which could be used to generate specific static 
knowledge. Finally, an example of reasoning knowledge is the observation that the student 
consistently reasons incorrectly concerning equilateral triangles. 

The authors devised several different types of agents to assist in modeling the student. 
Spy agents were used to record local student actions which would be useful in determining 
the pupil’s reasoning method. Task agents were implemented to examine the student’s 
actions while considering the task to be attempted. Three different types of task agents 
were employed: S-agents for storing the student’s static knowledge, D-agents for handling 
the student’s dynamic knowledge, and R-agents for representing the student’s reasoning. 


4 


D-agents could produce new static knowledge based on provided static and functional 
knowledge. 

Because of the method employed for modeling the student, EDDI had noticeable 
difficulty in modeling a student’s misconceptions. Leman (14) attributed this problem to 
the model’s inability to track multiple lines of reasoning, as well as the lack of knowledge 
about a global solution before the student even began the problem. Their answer was 
to seed the knowledge base with multiple solutions to the given problem, then track the 
student’s progress on all the solution paths, attempting to reconcile the student’s actions 
with those required in each solution. By processing the student’s reasoning in parallel 
through the use of multiple software agents, the student’s progress along all of the known 
solutions could be tracked simultaneously, and the student’s final solution method would 
be readily apparent. Simultaneous tracking of multiple solutions was used to justify the 
introduction of software agents into the student model. 

1.4 Assumptions 

The support software for the student model, including user interfaces and an ITS, 
will be fundamentally implemented with a high degree of human instructor guidance for 
the instructor module. Without an existing ITS, the problem of modeling pedagogical 
knowledge becomes as critical as modeling the student. By allowing a human instructor to 
make course-work decisions based on information provided by the student model, modeling 
the instructor can be circumvented. Since the thrust of this research is modeling the 
student, designing an intelligent instructor module is not relevant. 

1.5 Scope 

The emphasis of this research is to implement a multi-agent student model similar to 
that described by Leman, Giroux, and Marcenac (14). The student model will be extended 
to credit the student for correct solutions not found in the knowledge base. Implementation 
of support software, to include interfaces and the remainder of the ITS, will be minimized. 


5 







C Language Integrated Production System (CLIPS) will be used to implement the 
ITS. CLIPS is an expert system tool developed by the Software Technology Branch of 
NASA. Tcl/Tk will be used for the user interface, and C"*"^ will be used for the main 
procedure. 

1.6 Approach/Methodology 

As discussed earlier, much of this research will include building a basic multi-agent 
student model. Once this basic model is in place, modifications to the multi-agent system 
will be accomplished, to allow the ITS to both realize when a student has produced a 
solution unique to the ITS’s knowledge base, and to incorporate that solution into its 
knowledge base. 

A problem domain must also be selected for the ITS. A subset of Euclidean geometry 
has been identified as suitable. The area of geometric proofs allows for known (expert) 
solutions, but additional (potentially less efficient) solutions may also be found. Multiple 
solutions are necessary to test both the multiple agent student modeling and the learning 
ability of the ITS. 

1.7 Organization of Thesis 

Chapter II contains a literature review of the history of AI in education, ITSs, and 
student modeling. Chapter III describes building the ITS, and results from that experience. 
Finally, Chapter IV identifies contributions and recommendations. 


6 


II. Literature Review 


2.1 Introduction 

In order to provide a comprehensive background on ITSs, the literature is reviewed 
in order of increasing specificity. To begin with, a brief introduction to AI is provided. 
A historical perspective on AI applied to education is furnished, including discussion of 
computer-assisted instruction (CAI) and of ITSs. Finally, methods for modeling student 
cognition in ITSs are discussed. 

2.2 Artificial Intelligence 

Many definitions have been attempted for AI, but defining the term continues to 
present authors a challenge. Dean (6:1) effectively defines AI as “... the design and study 
of computer programs that behave intelligently.” The idea is to construct programs which 
behave in a manner similar to humans or other intelligent animals. Some idea of why AI 
has been studied can be gained by examining the following two goals of AI: (22) 

• the engineering goal, which is to solve real-world problems, and 

• the scientific goal, that of determining which AI related ideas aid in explaining human 
intelligence. 

Some of the most interesting and challenging problems to explore are often interesting 
because of the scientific goal, but the engineering goal actually drives most AI research. 

2.3 Artificial Intelligence in Education 

A paper by Matthew Kabrisky (12) initiated AFIT’s research in the use of AI in edu¬ 
cation. Kabrisky discussed the positive impact an artificial tutor could have on education. 
As a hypothetical example of the potential for AI, he provided a convincing excerpt of a 
child’s interactive learning session with an ITS: 

Imagine an elementary school child entering a small comfortably appointed 
room, perhaps something like a cockpit with a video screen, some desk space 
and perhaps a mouse or some sort of convenient mechanically driven input to 


7 





the data handling system. The child walks in, says, “Hi, It’s me, Linda,” and 
sits down. The machine says “Hi, Linda, How are you?”? Linda says, “Gee, I 
saw a neat program on bugs last night. I really wanted to watch cartoons but 
daddy made me, I mean it was neat with all the pretty and squishy looking 
things and there was a spider that hid in a trap door and grabed [sic] bugs 
walking by.” The machine says, “Yes, I saw it too, would you like to see the 
part with the trap door spider? I’ll play it for you if you want.” Linda says, 

“Oh yea, let me get Joey, he didn’t believe me.” 

After a while, Joey and Linda are through with the nature program, Joey runs 
outside, and the machine says, “I have a really neat math game. Would you like 
to play it”? Linda says, “OK, what’s it like”? They do math for a while. Note 
that Linda never has to take tests because the machine always knows where 
she is in the curriculum and how well she’s doing. When Linda’s through with 
math, the computer plays a game tying together geography, bugs, and natural 
history. The machine knows from its experience with Linda that she now needs 
a break and sends her out to play. 

Though Kabrisky identified the desirability of the machine being able to evaluate the 
student’s progress, his emphasis was on human/computer interfacing problems, identifying 
three components necessary for a friendly max:hine: 

1. a speech recognizer for converting human speech into text; 

2. a natural-language handler for analyzing the content of the text and for generating 
intelligent responses; and 

3. a speech synthesizer for reading back the responses in a near-human voice. 

While much progress has been made in items one and three, the natural language 
handler turns out to be a challenging application for AI. Hidden within this proposed 
handler is the requirement for generating intelligent responses to whatever the topic of 
conversation might be. For the hypothetical example, this response mechanism would in 
fact need to be an ITS, or at least an intelligent CAI system. 

2.3.1 Computer-Assisted Instruction. CAIs were an attempt to automate the 
pedagogical method known as programmed instruction (PI) (20). PI was the structured, 
goal oriented instruction technique popular in the early 1960’s. It required the instructor 
to determine inputs, the skills known upon entering the PI, and outputs, the behaviors 
learned when finished with the PL Learners were led through a PI curriculum in a lock- 


8 





step manner, with every incorrect response corrected immediately. Learners were always 
informed of the accuracy of their solutions before they moved on. When PI is implemented 
in a computer, CAI results. 

CAI doesn’t owe its entire origin to PI, though; it also evolved from stimulus-response 
psychology. When stimulus response psychology is applied to CAI, the computer evaluates 
a student’s answers at every stage of instruction, then determines the next path of in¬ 
struction. In a standard CAI, the path the computer chooses is already predetermined by 
the programmer and by the student’s success. Intelligent CAI (ICAI), on the other hand, 
attempts to evaluate why a student missed a particular problem, then varies the curricu¬ 
lum based on its evaluation. In standard CAI, if two students missed the same problem 
(possibly even only the same number of problems in the same section), the two students 
will invariably receive the same set of problems next. However, with ICAI, if student A 
missed the problem because he miscarried the hundreds digit, while student B erred in 
her addition of the nine and seven in the tens place, then the two students could receive 
different problems to reinforce the particular concepts with which they were struggling. 

The step from CAI to ICAI is not an abrupt step, but rather a gradual evolution from 
a basic computer-interaction method to a refined computer evaluation of student progress. 
At some point along this progression of refining ICAI, intelligent tutoring systems (ITSs) 
result. 

2.3.2 Intelligent Tutoring Systems. Commonly, an ITS is composed of three 
modules (14): 

1. an expert (or domain) model, 

2. a student model, and 

3. an instructor (or pedagogical) module. 

The expert model represents information specific to the subject being taught, the student 
model portrays the current student understanding or misunderstanding of the subject 
domain (9), and the instructor module contains knowledge required of teachers to select 
meaningful lessons for their students. Hartley and Sleeman (8) identified these same basic 


9 






requirements for an ITS in 1973. In fact, an ITS can be regarded as a distinct type of 
ICAI, with these three components making the distinction (20). Some authors have even 
come to regard ITSs as the ICAI of the 1980’s (23), while ITSs have come much closer to 
realizing their full potential in the 1990’s. The prototype for this research makes use of 
expert and student models, and the functionality of the instructor module is provided by 
a human instructor. A graphical interface module is also included in the implementation. 

Despite numerous examples of ITSs employing many different approaches to intelli¬ 
gence in tutoring, there are two terms most often associated with them (20): 

1. cognitive diagnosis, and 

2. adaptive remediation. 

Cognitive diagnosis entails forming an idea of the student’s cognition or knowledge, usually 
in the form of student modeling. Cognitive diagnosis is addressed again in Chapter III, 
where it is applied to reasoning about student knowledge. Adaptive remediation is the 
dynamic application of tutoring based on specific difficulties encountered by the student. 
Adaptive remediation is typically included in the instructor (or pedagogical) module. 

2-4 The Student Model 

One of the most difiicult problems when designing an ITS is effectively determining 
and representing the student’s current knowledge of the subject at hand (2). Modeling the 
student remains difficult because students are capable of inconsistent reasoning. Students 
may be distracted while working on a problem and produce sub-optimal work. They may 
also learn new material, unlearn known material, or simply not recall a known item at 
the particular moment it is required (17, 7). An optimal student model would include all 
information about the student, both relevant and seemingly irrelevant (9). The source of a 
student inconsistency or misunderstanding cannot be perfectly derived without a complete 
history of the student. Obviously, such a complete model is both impossible and imprac¬ 
tical. An effective student model is possible, however, by including key elements in the 
model. 

Student modeling is characterized by two principal activities (10): 


10 



1. behavior analysis, and 

2. model management. 

Behavior analysis is a cornerstone of student modeling, and is present throughout the 
prototype. Cognitive diagnosis (20) and behavior analysis are very similar terms, and are 
applied in roughly the same circumstances in a student model. Behavior analysis describes 
the entire process of examining student actions, while cognitive diagnosis includes behavior 
analysis, with the specific objective of diagnosing the student’s state of understanding and 
misunderst anding. 

Although most systems inevitably deal extensively with behavior analysis, few apply 
anything but ad hoc techniques to the model management (7). A concerted effort at model 
management has been explored by Giangrandi and Tasso (7) through the use of truth main¬ 
tenance techniques. Interestingly, this effort includes the use of multiple student models to 
refiect multiple hypotheses about the student’s reasoning. Although their research appears 
both relevant and useful, the application of their described model management methods 
must be recommended for further research. 

Several different approaches to behavior analysis have been attempted, including the 
following (9): 

1. production rules, 

2. logic programming, 

3. machine learning, 

4. Bayesian networks (4, 21, 13), 

5. artificial neural networks (ANNs), and 

6. overlay models. 

Production rules provide the opportunity to represent both ideal (expert) rules and mal- 
rules (rules defining incorrect beliefs or logic). For a simpler approach, logic programming 
offers the ability to implement inferencing and knowledge representation easily, while ma¬ 
chine learning eases representing the changing knowledge of the student. Bayesian network 


11 



models provide a probabilistic method for handling the uncertainties in student reasoning 
(4, 21, 13). ANNs allow the student model to adjust tutoring strategies to the student, and 
even allow initial training of the ANN by an expert, rather than explicitly coding domain 
knowledge (24). Finally, overlay models incorporate a model of expert knowledge, where 
known solutions are mapped onto the expert model, and student knowledge is always rep¬ 
resented as a subset of the expert knowledge. Overlay models are readily implemented in 
multi-agent form, thus allowing for tracking multiple solutions to problems. Both overlay 
models and production rules are used in this research. 

Shute (19) identified three categories of knowledge to be learned by the student and 
to be represented by the student model. Symbolic knowledge is familiarity with symbols 
and equations. Procedural skill concerns the apphcation of rules (i.e. knowledge) to 
problem solving. Procedural skill is easily represented as a series of concept and equation 
applications. Finally, conceptual knowledge corresponds to knowledge about relationships 
between concepts, schemas, and rules. It represents a higher-level of understanding. 

Not all tutoring systems apply, or even require, all three types of learning. For ex¬ 
ample, intelligent training systems frequently require only procedural skill and symbolic 
knowledge. Training systems are used to train individuals in skills requisite for a particular 
job, and often do not require conceptual knowledge, and only a limited amount of sym¬ 
bolic knowledge. All three concepts will be discussed in the context of the implemented 
prototype in the next chapter. 

Ragnemalm (18) describes two types of student models: 

1. a pedagogic-content model, and 

2. a subject-matter model. 

A pedagogic-content student model contains pedagogical measurements of the student’s 
progress, and therefore requires specific pedagogical goals for the student to attain. A 
subject-matter model is closely tied to the domain model, and is typically runnable. In a 
runnable student model, the model may be executed with the student’s (perceived) knowl¬ 
edge and misunderstandings determining the model’s actions. A subject-matter model al- 


12 


lows for differential modeling (3) and expectation driven analysis, which will be described 
in Chapter III. The ITS prototype is both a pedagogic-content and a subject-matter model. 

2.5 Summary 

Coaxing computers into becoming effective, personal tutors has developed into an 
ambitious and elusive goal. The problem began as a question of how best to integrate the 
computer’s abilities into pedagogical uses, but has evolved into a search for the holy grail 
of computer programming: artificial intelligence. Evolving from simple computer-assisted 
instruction (CAI), to intelligent CAI (ICAI), and eventually to intelligent tutoring systems 
(ITSs), implementing computer-assisted education has become increasingly more complex. 
Fortunately, the added complexity has increased the effectiveness of computer-assisted 
education. As we discover new tools for increasing the power and utility of computers, 
these tools are applied to producing more effective artificially intelligent tutors. The latest 
of these tools, software agents, have had some success already (14, 5). The goal of this 
thesis effort is to further explore the use of software agents in modeling student reasoning. 
The next chapter begins that effort with a description of the ITS implemented, focusing 
primarily on the student model. 


13 




III. Building the Intelligent Tutoring System (ITS) 

3.1 Introduction 

Our intent was to build a student model, and a minimal amount of support software 
to go with that model. In order to ax:complish this goal, the manageable domain of high 
school geometry, specifically parallel bisected lines proofs, was selected as the test domain. 
Additionally, the instructor module was not coded, but its functionality is provided by 
a human instructor. The method for accomplishing this task is described, followed by 
a discussion of the student model used. Next, the addition of adaptable software agents 
to student modeling is discussed, and the problem of identifying student knowledge is 
examined. Finally, the roles of the student model and the instructor module are redefined, 
based on insights gained during this research effort. 

3.2 The Man Behind the Curtain Experiment 

The vision for an artificially intelligent tutor described by Kabrisky (12) includes a 
natural language interface to allow the student more natural communication with the ITS. 
While a natural language processor is currently unavailable, it can be simulated using the 
“man behind the curtain” methodology. By placing a student at a workstation, within 
earshot (but not eyesight) of a human instructor at another workstation, the student can 
communicate audibly to the instructor, while the instructor communicates to the student 
through a remote terminal session. The student is told she is orally communicating with 
the ITS. The instructor provides educational material to the student by typing text and 
displaying images on the student’s monitor. 

The instructor is responsible for receiving the student’s answers, relaying them to 
the domain model, and monitoring the student model’s analysis of the student’s responses. 
The instructor then acts on behalf of the instructor module in deciding what material 
would best be presented next. Thus, the human instructor is acting both as a natural 
language processor, and as the instructor module of the ITS. In this way, a student model 
can be developed without building a complete ITS. Hereafter, this implementation of an 


14 





ITS will be referred to as the Curtain ITS. The Curtain interface was implemented using 
Tcl/Tk. For reference, Appendix C includes the complete Tcl/Tk source listings. 

3.3 Modeling the Student 

The basis of this research is the paper by Leman, Marcenac, and Giroux (14). The 
authors implemented a student model built on an existing ITS known as EDDI (15). 
EDDI’s student model divided knowledge into three levels: static knowledge, dynamic 
knowledge, and reasoning knowledge. Static knowledge was defined as knowledge about 
the basic concepts of the domain being studied, while dynamic knowledge concerned more 
functional aspects of the domain. Reasoning knowledge was defined as knowledge about 
the student’s reasoning. 

Using the vocabulary described by Shute (19), static knowledge falls into the sym¬ 
bolic knowledge category, while dynamic knowledge could be either symbolic knowledge or 
conceptual knowledge. Reasoning knowledge is obtained by tracking a student’s procedu¬ 
ral skill, but inferences about the student’s symbolic knowledge or conceptual knowledge 
are possible using cognitive diagnosis (20). 

The Curtain prototype makes use of the concepts just discussed, as well as others, 
yet to be presented. The and CLIPS source listings for Curtain are included in 
Appendices A and B, respectively, for further reference. 


Given: 

Measure of angle 1 = 120 degrees 

Find: 

Measure of angle 6 = ? 

Solution: 

Relate angle 1 to angle 5 

Relate angle 5 to angle 6 


Table 1 Sample Geometry Problem (see Figure 1) 


3.3.1 Overlay models. Leman (14) made use of an overlay model in their research. 
Likewise, in the Curtain ITS, an overlay model is employed for comparing the student 
solution to a library of expert solutions. A concrete example from the Curtain ITS may 
help illuminate the use of overlay models. 


15 





Figure 1 Bisected Parallel Lines 

Consider the problem posed in Table 1. The solution provided in Table 1 is only 
one of many. The actual proof for this solution contains much more detail (see Table 2), 
but the provided detail is ail that is required for matching solution strategies. Figure 2 
displays a state model representation of the solution. 


relate(l,5) 


relate(5,6) 

111= 120 

151 = 120 

161 = 60 


111 = 120 

151 = 120 



111 = 120 


Figure 2 Expert Solution State Diagram 


The provided solution is relatively straightforward: 

1. define the relationship between angles 1 and 5 in order to determine the measure of 
angle 5, 

2. then define the relationship between angles 5 and 6, thus yielding the desired answer, 
the measure of angle 6. 


16 





Given: 

Lines A and B are parallel 

Lines A and B are bisected by Line C 
Measure of angle 1 = 120 degrees 


Prove: 

Measure of angle 6 = 60 degrees 


PROOF 

Statement 

Reason 

1 

Measure of angle 1 = 120 

given 

2 

Angles 1 and 5 are corresponding angles 

observation and definition of corresponding angles 

3 

Angles 1 and 5 are congruent 

(2) and definition of corresponding angles 

4 

Measure of angle 5 = 120 

(1), (3), and definition of congruent angles 

5 

Angles 5 and 6 are adjacent angles 

observation and definition of adjacent angles 

6 

Angles 5 and 6 are supplementary angles 

(5) and definition of adjacent angles 

7 

Measure of angle 6 = 180 - 120 = 60 

(4),(6), and definition of supplementary angles 

8 

Done 



Table 2 Sample Geometry Proof (see Figure 1) 


With the overlay method, the student model can check the student’s actions against 
the provided expert solution, applying what has been called a differential modeling tech¬ 
nique (3). The state model in Figure 2 demonstrates the ease with which solution strategies 
can be compared. The nodes represent states (known information), and the arcs represent 
actions required in order to reach the next state. 

One of the weaknesses of overlay models is that they do not allow for student knowl¬ 
edge or information outside of the expert’s knowledge. Also, by using state models for 
representing the expert knowledge, overlay models can represent multiple solutions to a 
proposed problem, but they struggle with tracking the student’s line of reasoning when 
the student makes multiple attempts at the problem. Since the student could possibly try 
several solution paths before settling on one, representing these many approaches with a 
state model has been difficult (14). 


3.3.2 Multiple agents in student modeling. Because of the overlay method em¬ 
ployed for modeling the student, EDDI had noticeable difficulty in modeling a student’s 
misconceptions. Leman (14) attributed this problem to the model’s inability to track mul¬ 
tiple lines of reasoning, as well as the lack of knowledge about a global solution before the 
student even began the problem. Their answer was to seed the knowledge base with mul- 


17 















tiple solutions to the given problem, then track the student’s progress on all the solution 
paths, attempting to reconcile the student’s actions with those required in each solution. 
By processing the student’s reasoning in parallel, the student’s progress along all of the 
known solutions could be tracked simultaneously, and the student’s final solution method 
would be readily apparent. 

Using independent agents allows representing several possible states for the student. 
These states represent distinct steps along a solution path, and can be used to help predict 
the next state the student will enter. Predicting the next state is important because, 
through the use of differential modeling (3) and expectation driven analysis, the student 
model’s predictions can be compared to the student’s actual actions. The student model 
is validated if the actions match, while corrections may be made to the student model if 
they do not. In most other models, only one path for modeling the student is tracked, 
thus restricting the expected next states to those that follow the selected line of reasoning. 
Since it is not uncommon for a student to try multiple approaches on a problem before 
settling on one, the multi-agent method allows for more flexibility in modeling student 
behavior by allowing the selection of the model which produces a predicted action most 
closely matching that of the student’s. 

In order to accommodate expectation driven analysis. Curtain’s student model was 
implemented with production rules, thus allowing mal-rules to represent student miscon¬ 
ceptions. Ideal rules in the expert model fire to demonstrate correct actions, while ideal 
rules and mal-rules fire in the student model in an attempt to accurately predict student 
actions, and thus validate the student model. During the course of this research, it was 
discovered that implementing software agents to allow for multiple solution paths was un¬ 
necessary. By comparing solutions as sets of solutions steps, it was possible to distinguish 
when a student’s solution was identical to one of the expert’s, a superset of one of the 
expert’s, or completely unrelated to all of the expert’s solutions. 

Figure 3 shows an alternative solution to the problem in Table 1. This new solution is 
both correct and equal in efficiency to the previous solution. If only one of these solutions 
was selected for tracking the student’s reasoning based on how the student first attempted 
a solution, while the student first attempted one solution strategy, but settled on another. 


18 







relate( 1,3) relate(3,6) 


111 = 120 131 = 60 

161 = 60 

111 = 120 

131 = 60 


111 = 120 


Figure 3 Alternative Expert Solution State Diagram 


a standard overlay model would not be able to credit the student with a correct solution. 
According to Leman (14), a multi-agent student model would be able to track student 
progress on both expert solutions, and thus correctly deduce which of the strategies the 
student eventually employed. However, the Curtain prototype successfully tracked the 
student’s strategy without the use of software agents. 

Tracking multiple solutions was made possible with the use of set functions in CLIPS. 
K each solution, both expert and student, is treated as a set, it is possible to examine the 
student solution’s relationship to the expert solution(s) with standard subset operations. 
If the student solution is a subset to the expert solution, then the student hasn’t completed 
a solution. However, if a particular expert solution is a subset of the student solution, then 
the student has completed an expert solution, but has included more steps than necessary, 
possibly because the student has wandered through other solution attempts. These extra 
steps can be readily compared to other expert solutions to determine if the student has 
attempted, but abandoned, another strategy. If the student solution is a subset of a 
particular expert solution, and that expert solution is a subset of the student solution, then 
the student has exactly applied that expert solution. Of course, these comparisons may be 
made after each student action to maintain a current model of the student’s strategy. 

3.4 Learning From the Student 

A shortcorhing of Leman’s (14) multi-agent model is the inability to learn from 
student solutions. The student model expects to have a complete set of solutions for the 
problems presented. Any solutions not found in its knowledge base are considered wrong. 
It would be useful if the model could recognize and adopt new solutions when presented 


19 







with them. Moreover, the ability to recognize a solution which seems unique, but is really 
just a combination of existing solutions, would also be of great benefit. 

An extension to Leman’s current model is to provide a learning agent (L-agent) 
which checks for unique student solutions. This agent need only be invoked if a match is 
not found in the expert solution library. If no match is found, then the solution must be 
evaluated to determine its correctness. If it is indeed a correct solution, the student must 
be given credit for it. If it is also as efficient as the expert solution(s), the student model 
must be updated accordingly, and the expert solution library may be updated as well. 

Based on the discovery that software agents were not required for processing multiple 
solutions, the L-agent wasn’t required to be an agent at all, and so is described as an agent 
only in the weakest sense. Here, as in the multiple solution processing, a module is all that 
is required. 

In order for the L-module to determine if a student solution is correct, the domain 
model must have a complete set of rules governing legal transitions in the solution space, 
and the student model must be a subject-matter model. The complete set of rules is 
required to ensure the assertions made by the student are valid. The subject-matter model 
is necessary so that the model may be executed to determine if the goal was actually 
achieved. Without a subject-matter model, it would be necessary to search the student’s 
solution space to determine if any of the possibly many solution paths leads to the goal. 

The solution space in Curtain was completely specifiable because of the procedural 
solutions required for geometrical proofs. Implementing learning modules such as this is 
possible in any domain where procedural knowledge dominates. Training environments 
favor procedural skills (11), as do other types of ITSs. 

Some examples from Curtain may help to illustrate the points just discussed. Con¬ 
sider the proposed student solution in Figure 4. This solution is a correct solution. It is 
also a completely unique solution. The L-module should evaluate the solution as valid, and 
add it to the knowledge base. In fact, the prototype’s L-module did update the student 
model with the fact that the student satisfactorily solved the problem. 


20 





relate(l,2) _ relate(2,6) _ | 

111 = 120 121 = 60 

161 = 60 

111 = 120 

121 = 60 


111 = 120 


Figure 4 Student Solution State Diagram 


In contrast, the solution in Figure 5 is a valid solution, but takes a longer approach. 
In this case, the solution should not be added to the solution library. The L-module updates 
the student model with the knowledge that the student solved the problem correctly, but 
solved it less efficiently, avoiding the use of corresponding angles. 


relate(l,4) relate(4,5) 

relate(5,6) ^ 

111 = 120 141 = 120 

151 = 120 

161 = 60 

111 = 120 

141 = 120 

151 = 120 


111 = 120 

141 = 120 



111 = 120 


Figure 5 Alternative Student Solution State Diagram 


The idea that the student may have avoided the use of corresponding angles inten¬ 
tionally is an important one. If she has not already demonstrated mastery of the concept 
of corresponding angles, she may be avoiding them out of ignorance. In this case, an ap¬ 
propriate next problem would be one which forces the use of corresponding angles, or asks 
specifically about them. It is also possible, however, that she avoided them out of bore¬ 
dom, having already solved several problems using corresponding angles, in which case the 
omission is not critical. Identifying the avoidance of a particular theorem requires more 
information than that provided in the state diagrams, which is the subject of the next 
section. 


21 









3.5 Identifying Student Knowledge 

Though the meta-steps displayed in Figures 2, 3, 4, and 5 are sufficient for comparing 
solution strategies, they are insufficient for determining the correct application of concepts. 
By breaking each solution step into sub-steps, student error detection is facilitated (17), 
through the use of cognitive diagnosis (20) and behavior analysis (10). In interactive 
tutoring environments, subquestions can be posed to aid in student error detection, but this 
can be intrusive and distracting for the student (3). In situations where subquestions are 
impossible, or merely undesirable, the problem of determining student knowledge becomes 
even more difficult. 

In the geometric proof domain, these sub-steps are an inherent requirement for prob¬ 
lem completion, and therefore easily obtained. Consider, for example, the problem pre¬ 
sented in Table 1. The key concepts the student is required to master in order to prove 
the solution are: (see Table 2) 

1. congruent angles, 

2. adjacent angles, and 

3. supplementary angles. 

If the student does not successfully apply these three concepts, then the student 
cannot have a correct solution. However, the student has a multitude of correct solutions 
to choose from, as demonstrated in Figures 2, 3, 4, and 5. Furthermore, the student may 
choose from several correct and efficient solutions, as shown in Figures 2, 3, and 4. There¬ 
fore, making inferences about knowledge the student is avoiding is not as straightforward 
as one might think; yet, it is not exceptionally difficult either. 

The key symptom which lends insight into the student’s motivations is the obser¬ 
vation that the student takes multiple steps to transition between two nodes that have a 
direct link. This is the case in Figure 5. As mentioned in Section 3.4, the solution seems to 
avoid the use of corresponding angles. The formula for discovering such a circumvention 
makes the nonuse of corresponding angles more apparent, but does not aid in establishing 
the student’s motive. Additional clues to the student’s motive can be obtained from the 
student model. 


22 


The most helpful information to be gained from the student model is some form 
of performance history with respect to the avoided concept, in this case corresponding 
angles. The most direct information is an actual record of all the student’s applications 
and misapplications of the concept. 

While a complete history is possible in small domains, and is available for Curtain, 
it could certainly become unwieldy as the number of concepts and students increases. 
Shute (19) suggests mastery levels be defined to assist in determining amount and level 
of remediation, but they may also be applied to aid decisions regarding student motiva¬ 
tions. Curtain was implemented with a binary mastery threshold for exactly this purpose. 
Enhancing the mastery levels to approach that described by Shute would ease student 
motivation determinations. 

Even with knowledge on how well the student has (apparently) mastered a concept, 
inferring the student avoids a mastered concept because she is bored, or avoids an untried 
or misunderstood concept because she doesn’t know or understand that concept, is still 
a leap of faith. To make an even more effective estimation, a truth maintenance system, 
such as that outlined by Giangrandi and Tasso (7), would be beneficial. 


relate(l,5) _ relate(5,7) _ relate(7,6) _ j 

111 = 120 151 = 120 

171 = 60 

161 = 60 

111 = 120 

151 = 120 

171 = 60 


111 = 120 

151 = 120 



111 = 120 


Figure 6 Lengthy Student Solution State Diagram 


Although the lengthy but correct solution in Figure 5 has proved useful for cognitive 
analysis, this is not always the case. Consider, for example, the solution in Figure 6. Like 
Figure 5, Figure 6 has one more step than the expert solutions in Figures 2 and 3. Unlike 
Figure 5, Figure 6 makes use of all the essential relations identified earlier in this section: 
congruent angles, adjacent angles, and supplementary angles. Recognizing this fact is not 
difficult; flagging the essential components may seem more diflicult, but it is only a matter 
of identifying the intersection of all the concepts applied by all of the expert solutions. 


23 





Knowing Figure 6 contains all of the essential relations, it follows that the student has 
merely included unnecessary steps in her solution. These extra steps, then, can be expected 
to be a result of distraction, inferior reasoning, etc., but not a deficiency in geometry. 

3.6 Student Models vs Instructor Modules 

While performing the research for this thesis, the definition for a student model 
seemed to become more blurred and indefinite, rather than more distinct, as one would 
hope. The cause for the haziness seems to lie in the preponderance of new functions and 
capabilities being added to the student model. Many authors (19,18, 3, 4, 7,16) are includ¬ 
ing processing in the student model which seems more in place in the instructor module. 
The student model should contain the student’s actions and any inferred understandings 
or misunderstandings. 

In contrast, the instructor (or pedagogical) module should contain any functions 
which reason about the student’s actions, or reason about the student’s reasoning. The 
only reasoning the student model should perform is any reasoning the student might be 
expected to make, and only then if the student model is a subject-matter model. 

Thus, the student model would be primarily a container for information about the 
student, including inferences made by the instructor module, with a secondary task of being 
able to reason in a manner similar to the actual student, if it is a subject-matter model. 
The instructor module would be responsible for all type of pedagogical matters, including 
the inferencing a human instructor might do about the student’s state of understanding or 
misunderstanding. With this new division of labor, the instructor module is responsible 
for all behavior analysis and cognitive diagnosis, while the student model stores the results 
from the instructor module, acting as a pedagogic-content model /citeragnemalm. 

The final chapter discusses author contributions and recommendations. 


24 








IV. Contributions and Recommendations 


4.1 Contributions 

In this thesis, a new method for incorporating learning into the student model of an 
ITS has been presented. This method was demonstrated effectively with a prototype ITS. 
The usefulness of subject-matter models for learning was emphasized. Software agents 
were shown to be unnecessary for processing multiple solutions in the student model, and 
likewise not required for adding learning to the student model. 

While it is recognized that the learning module relies on having a complete set of 
rules for the domain model, it has also been argued that the main requirement for a domain 
model with this capability is a domain which relies heavily on procedural knowledge. Many 
tutoring domains meet this criteria. More importantly, nearly all training domains rely 
primarily on procedural skill (11). Since the Air Force’s chief concern is more efficient 
training, the application of learning to Air Force ITSs is quite feasible. 

Even though a learning student model was the initial focus of this thesis, several other 
useful concepts emerged during the research. First among these was the identification and 
resolution of some inconsistencies in the division of labor between the student model and 
the instructor module. Effectively, the student model is a container of information about 
the student, while the instructor module performs all reasoning or inferencing expected of 
the human instructor. 

Additionally, an alternate use for Shute’s (19) mastery levels was demonstrated. As 
discussed in section 3.5, mastery levels can not only be used for determining remediation 
as suggested by Shute, but can also be used to gain insight into student motivations. 

Also identified in this thesis were appropriate uses for meta-steps and sub-steps 
in solution analysis. Meta-steps frequently can lead to information about correct and 
incorrect solution strategies, but sub-step analysis aids making inferences about student 
thought processes. Sub-steps are particularly effective for cognitive diagnosis. Again, it 
is recognized that many domains do not have a natural requirement for explicit student 
identification of sub-steps, unlike geometric proofs, but in these cases a special effort at 


25 


deducing these sub-steps can frequently be effective (3). In other cases, explicitly querying 
the student for solution sub-steps may prove necessary. 

Differential modeling (3) and expectation driven analysis were concretely demon¬ 
strated as useful for validating student models. These techniques are particularly applica¬ 
ble to overlay methods, which were employed in the Curtain prototype, and lend themselves 
to intelligent training systems. 

Finally, the cognitive terms identified by Shute (19) were successfully applied to 
Curtain. In section 3.3, the relationships between Leman’s (14) static, dynamic, and 
reasoning knowledge and Shute’s symbolic, conceptual, and procedural knowledge were 
outlined. These relationships are important because new terms are continually being in¬ 
vented for very similar concepts in ITSs, and the relations between these concepts are not 
always obvious, but remain, nevertheless, important. 

Recommendations 

There remains much that can be further explored with respect to this research effort, 
both in concept and in application. The principal area for further research is the application 
of the new division of labor between the student and instructor modules. A demonstration 
of the proposed student and instructor module responsibilities would provide evidence that 
the division is both logical and practical. 

Additionally, the inclusion of a truth maintenance system to the student model would 
be a significant contribution. As discussed briefly in section 2.4 and in detail by Gian- 
grandi (7), a truth maintenance system aids deconflicting student model inconsistencies 
generated by student learning, student unlearning, student misconceptions, and others. 

The mastery levels in the student model could also be improved. The current binary 
threshold is serviceable, but a more robust system, similar to that described by Shute (19), 
could provide more insight into student motivations, as well as aid remediation. 

Beyond student modeling, there is the entire realm of the instructor module, which 
includes topics such as remediation, problem selection, and tutoring strategies. Incorpo- 


26 




rating an instructor module with these capabilities can then require enhancements to the 
student model, such as inclusion of a student’s preferred learning strategy. 

4-3 Overall Conclusions 

This research has proposed and demonstrated a method for expanding the solution 
library in the expert module through the use of a learning student model. The method 
demonstrated has application in a wide variety of tutoring domains, including most training 
scenarios. 


27 







Appendix A. Curtain Driver ( 7 ^+ and C Code 


tinclude <stdlib.h> 

#include <8tdio.h> 

#include <string.h> 

#include <fstream.h> 

#include <unistd.h> 

//Mnclude <vfoTk.h> 
tinclude "curtain.h" 

tdeflne MAXSTRING 100 

extern "C" { 
tinclude "clips.h" 

/* */ 

/♦ Define C functions to CLIPS ♦/ 

/* */ 

// This function may be called from CLIPS, and passes a Tcl command 
II and a string of parms to Tcl, thus invoking that Tcl function. 
char* TclFuncO 
{ 

DATA_OBJECT msg,pipe; 

FILE *write_pipe; 

VOID *MainPtr, *InstPtr; 

if (ArgCountCheck("TclFunc", EXACTLY,!) == —1) 

{ 

fprintf(stderr,"Wrong number of arguments! \n"); 
return "FALSE"; 

} 

if (! ArgTypeCheck("TclFunc",l,STRING,&msg)) 

{ 

fprintf(stderr,"Wrong type of argument: msg! \n"); 
return "FALSE"; 


10 


20 


30 


28 






} 

MainPtr = FmdDefmodule("MAIN"); 

InstPtr = FindIn8tance(MamPtr,"pipe-ptr",CLIPS_FALSE); 


DirectGetSlot(InstPtr,"pipe",S<pipe); 
write-pipe = (FILE *) DOToPointer(pipe); 
fprmtf(write_pipe,"'/,s\n",DOToString(m8g)); 
return DOToString(insg); 

;;return "TRUE"; 

} 

int UserFunction8() 

{ 

extern VOID TcIFunc(); 


DefineFunction2("TclFunc",'u',PTIF TclFunc, "TclFunc", "lie"); 

} 


/*♦»♦*♦*♦+♦♦*♦♦***♦♦♦♦♦♦♦♦*♦♦♦*♦♦♦*♦♦*♦♦**♦♦*****♦*♦*♦♦♦♦♦**♦»****♦♦*/ 

/* */ 

/* Initialize CLIPS */ 

/* */ 

j +,(i**i(t***+*+****+****************»+***************+*+*******»*»+*****/ 

void C_IiiitCIip8(FILE *pipe_ptr, cheir ♦8tudent, char ♦path) 

{ 


char tempBuffer[MAXSTRING]; 
char temppath[8trlen(path)+25]; 
int thre8hoId; 

DATA.OBJECT rtn,vPtr,pipe; 

VOID ♦MainPtr, ♦StudentPtr, ♦ExpertPtr, ♦InstPtr; 


InitializeCLIPSO; 

SetDynamicConstraintChecking (TRUE); 
SetStaticConstraintChecking (TRUE); 
strcpy(temppath,path); 
strcat(temppath,"/clips/main.clp"); 


40 


50 


60 


70 


29 


Load(temppath); 


MaiaPtr = FindDefmodule("MAIN"); 

Expert Ptr = FindDefmodule( "EXPERT"); 

StudentPtr = FindDefmoduleC’STUDENT"); 

SetCurrentModule(ExpertPtr); 

strcpy(temppath,path); 80 

strcat(temppath,"/clips/both, clp"); 

Load(temppath); 
strcpy (temppath,path); 
strcat(temppath,"/clips/expert. clp"); 

Load(temppath); 

SetCurrentModule(StudentPtr); 
strcpy (temppath,path); 
strcat(teinppath,"/clipa/both.clp"); 

Load(temppath); 

3trcpy(temppath,path); 90 

8trcat(temppath,"/clipa/stiident. clp"); 

Load(temppath); 

SetCurrentModule(MainPtr); 

CLIPSFunctionCall(" init",student ,&rtn); 

// Insert pointer to pipe to Tel/Tk into CLIPS object 
InstPtr = FindInstance(MainPtr,"pipe-ptr",CLIPS_FALSE); 

SetpType(&pipe,EXTERNAL. ADDRESS); 

SetpValue(&pipe,pipe-ptr); 

DirectPutSlot(InstPtr,"pipe",&pipe); 100 

CLIPSFunctionCaJl("CLIPS-get-thre8hold",NULL,&rtn); 

} // end function C-InitClips 

/ + * + + + + + + ♦♦* + * + ♦ + *♦*♦ + + *** + **♦*♦♦*♦** ******* ♦****♦ + ♦ + *♦♦*/ 

/* Exec the named cmd as a child process, returning two pipes to */ 

/* communicate with the process, and the child’s process ID */ 

/*******************************************************************/ 
int start_child(char *cmd, FILE ♦♦readpipe, FILE ♦♦writepipe) 

{ 


30 


int childpid, pipel[2], pipe2[2]; 


if ((pipe(pipel) < 0) 11 (pipe(pipe2) < 0)) 

{ 

perror("pipe"); 
exit(—1); 

} 

if ((childpid = vfork()) < 0) 

{ 

perror("fork"); 

exit(—1); 

} 

else if (childpid >0) // Parent 

{ 

close(pipel[0]); 

close(pipe2[l]); 

// Write to child is pipel[l], read from child is pipe2[0j 
♦readpipe = fdopen(pipe2[0],"r"); 

♦writepipe = fdopen(pipel[l],"w"); 
if (setvbuf(*writepipe,NULL,-lOLBF,100) != 0) 

{ 

perror("iio line buffering"); 
exit(—1); 

} 

return childpid; 

} 

else // Child 

{ 

close(pipel[l]); 

clo8e(pipe2[0]); 

// Read from parent is pipelfO], write to parent is pipe2[l] 

dup2(pipel[0],0); 

dup2(pipe2[l],l); 

close(pipel[0]); 







close(pipe2[l]); 


if (execlp(cmd,cmd,NULL) < 0) 
perror("execlp"); 

// Never returns 

} 

} // end of procedure start-child 


llt:**IHS‘******************S‘l^****************^‘S"IHf*****’lf****S‘************/ 

/* ♦/ 

/* Man behind the curtain program to simulate an ITS. */ 

h *! 

int main(int argc, char ♦♦argv) 

{ 


DATA.OBJECT rtn; 
char »buf, *path; 


// Set up pipe for Tcl process 
FILE *read.froin, ♦write.to; 

char result [MAXSTRING], textBuf[MAXSTRING], cmd[MAXSTRING]; 
int childpid; 

path = getenv("CURTAIN_PATH"); f j get path from env var 
if (path == NULL) // if no CURTAIN.PATH env var... 

{ 

cout << "You need to set an environment veuriable CURTAIN.PATH " 
<< "with the path to curtain directory. Continuing with " 
<< "current directory." << endl; 
path = getenv("PWD"); / f assign path to current directory 
} 

if (path == NULL) exit(O); j j if no current dir, exit program 
childpid = start_child("wish",44read_froin,&write_to); 

// Tell wish to read the init script 

fprintf(write.to," source */,s/TCL/curtain. tcl\n" ,path); 


150 


160 


170 


180 


32 







while(l) 

{ // Blocks on read from wish 

if (fgets(result,80,read_froiii) <= 0) exit(O); // Exit if wish dies 
// Scan the string from wish 

if ((sscanf(result,'7.s '/.["N"]",cmd,textBuf)) <= 2) 

{ // sort out which procedure must be called 190 

// CJlnitClips 

if (strcnip(cmd,"C_IiiitClip8") == 0) 

C_InitClips(write_to,textBuf,path); // Call C-InitClips 

II CLIPS-quit 

if (Btrcmp(cmd,"CLIPS-quit") == 0) 

CLIPSPunctionCall( "quit",NULL,iirtn); 

// CLIPS-get-student-concept function 200 

if (8trcmp(cmd,"CLIPS-gat-student-ooncept") == 0) 

{ // Call get-student-concept CLIPS function 
char tmp[MAXSTRING]; 
if ((sscanf(textBuf,"Xs",tmp)) == 1) 

{ 

CLIPSPunctionCall(cmd,textBuf,iirtn); 
buf = strdup(DOToString(rtn)); 
sscanf (buf," '/,s " ,cmd); 
if (strcmp(cmd,"TRUE")!=0) 

cerr << "CLIPS-get-student-concept returned illegal \ 210 

value: " << cmd << endl; 
free(buf); 

} 

else 

cerr << "Bad change-threshold command: " 

<< cmd << textBuf << endl; 

} 

// CLIPS-get-threshold function 

if (strcmp(cmd, "CLIPS-get-threshold") === 0) 220 


33 





{ // Call get-threshold CLIPS function after getting parms 

CLIPSPuiictionCall(cmd,NULL,i4rtii); 

buf = strdup(DOToStrmg(rtn)); 

sscanf (buf,"'/, s " ,cmd); 

if (strcmp(cmd,"TRUE")!=0) 

cerr << "CLIPS-get-threshold returned illegal value: " 

<< cmd << endl; 
free (buf); 

} 

230 

// CLIPS-change-threshold function 
if (3trcmp(cmd,"CLIPS-change-threshold") == 0) 

{ // Call change-threshold CLIPS function after getting parms 
char tmp[MAXSTRING]; 
if ((8scanf(textBuf,"y,8",tmp)) == 1) 

{ 

CLIPSPunctionCall(cmd,textBuf,&rtn); 
buf = strdup(DOToStriiig(rtn)); 
sscanf (buf," */, a " ,cmd); 

if (8trcmp(cmd,"TRTO")!=0) 240 

cerr << "CLIPS-change-threshold returned illegal value: " 

<< cmd << endl; 
free(buf); 

} 

else 

cerr << "Bad change-threshold conunand: " 

<< cmd << textBuf << endl; 

} 

// CLIPS-get-definition function 250 

if (8trcmp(cmd,"CLIPS-get-delinition") == 0) 

{ // Call the get-definition CLIPS function after getting parms 
char tmp[MAXSTRING]; 
if ((sscanf(textBuf,"*/,s",tmp)) == 1) 

{ 

CLIPSPunctionCall(cmd,textBuf,&rtn); 
buf = strdup(DOToStrmg(rtn)); 


34 








sscanf (bufs " ,cmd); 
if (8trcmp(cmd,"TR.UE")!=0) 

cerr << "CLIPS-get-definition returned Illegal value: " 
<< cmd << endl; 
free(buf); 

} 

else 

cerr << "Bad get-definition command: " 

<< cmd << text Buf << endl; 

} 

// CLIPS-define-problem function 
if (8trcmp(cmd,"CLIPS-define-problem") == 0) 

{ // Call the define-problem CLIPS function after getting parms 
int tmp; 

if ((s8canf(textBuf,"*/,i Xi */,i",4ttmp,4ttmp,i£tmp)) == 3) 

{ 

CLIPSFunctionCall(cmd,textBuf,itrtn); 
buf = 8trdup(DOToString(rtn)); 
free(buf); 

} 

else 

cerr << "Bad define-problem command: " 

<< cmd << textBuf << endl; 

} 

// CLlPS-relate function 
if (8trcmp(cmd,"CLIPS-relate") == 0) 

{ // Call the relate CLIPS function after getting parms 
int tmp; 

char tBuf[MAXSTRING]; 

if ((8scanf(textBuf,"*/,i Xi Xs Xs",&tmp,&tmp,tBuf,tBuf)) == 4) 

{ 

CLIPSPunctionCall(cmd,textBuf,&rtn); 
buf = 8trdup(DOToString(rtn)); 
sscanf(buf,"Xs X ["N"] ",cmd,textBuf); 
if (strcmp(cmd,"TRnE")!=0) 


35 




cerr << "CLIPS-relata returned illegal value: " 

<< cmd << endl; 
free(buf); 

} 

else 

cerr << "Bad relate command: " << cmd << textBuf << endl; 

} 

// CLIPS-solution function 
if (strcmp(cmd,"CLIPS-solution") == 0) 

{ // Call the CLIPS-solution function after getting farms 
int tmp; 

if ((s8canf{textBuf,"y,i",&tmp)) == 1) 

{ 

CLIPSPunctionCall(cmd,textBuf,fcrtn); 
buf = strdup(DOToString(rtn)); 
ascanf (buf," ‘/.a " ,cmd); 
if (strcmp(cmd,"TRtJE")!=0) 
cerr << "CLIPS-solution returned illegal value: " 

<< cmd << endl; 
free(buf); 

} 

else 

cerr << "Bad solution command: " << cmd << textBuf << endl; 

} 

// CLIPS-get-mag function 
if (strcmp(cmd,"CLIPS-get-mag") == 0) 

{ // Call the CLIPS-get-mag function after getting farms 
int tmp; 

if ((s8canf(textBuf,"'/,i",&tmp)) == 1) 

{ 

CLIPSFunctionCall(cmd,textBuf,&rtn); 
buf = 8trdup(DOToString(rtn)); 
sscanf(buf,"'/,s ’/, ["N"] ",cmd,textBuf); 
if (strcmp(cmd,"tcl_IEOmsg")==0) 
fprintf(write_to,"tcl_IEOmsg \"'/.s\"\n",textBuf); 


300 


310 


320 


330 


36 







else if (strcmp(cmd,"NULL")!=0) 
cerr << "CLIPS-get-mag returned illegal value: " 

<< cmd << endl; 
free(buf); 

} 

else 

cerr << "Bad get-mag command: " << cmd << textBuf << endl; 

} 

} 340 


else 

cerr << "Bad command: " << cmd << textBuf << endl; 

} 


/***+♦♦+♦*+♦********♦♦♦♦♦*♦**♦****♦♦»♦♦»♦♦♦♦♦»♦♦♦♦♦»♦♦******♦*♦♦*♦♦**/ 

/* Clean up before exiting... */ 

/♦ */ 

y*4i;f4i«*4<«4<]|i«*4<******4i>t<*«*********4<***'l<****4‘4‘********4'******4<***4'4>****/ 

return 0; 350 

} 


37 


Appendix B. Curtain ITS CLIPS Code 


;; MAIN CONSTRUCTS ;; 

These axe constructs which are defined once, and are exported ;; 

;; to both EXPERT and STUDENT. ;; 

(defmodule MAIN (export ?ALL)) 

(defglobal ?*result+ = NULL) 

(defglobal ?*student* = NULL) 

(defglobal ?*given—angle—nbr* = NULL) 

(defglobal ?»find—angle—nbr* = NULL) 10 

(defglobal ?*given—angle* = NULL) 

(defglobal ?*find—angle* = NULL) 

(defglobal ?*given—mag* = NULL) 


lltlftltltllMMMMtlfMftfMIMPfltfflfMflftllfllfMItltPMItltltP 

CLASSES 

ItlMIPIfltlPfltlfllftltMttPlfMPPPMtPfflltntlMtPtfUPMtMItMX 


(defclass MAIN—SOLUTION "object specifying a solution to a problem" 

(is—a USER) 20 

(slot given—angle 
(create—accessor read—write) 

(type INSTANCE-NAME) 

(default ?NONE) 

(visibility public) 

) 

(slot find—angle 
(create—accessor read—write) 

(type INSTANCE-NAME) 

(default ?NONE) 30 

(visibility public) 

) 

) 

(defclass WORK—SOLUTION "list multiple solutions to a problem" 


38 















(is-a MAIN-SOLUTION) 

(multislot solution—track 
(create—accessor read—write) 

(type LEXEME)) 

) 

(defclass EXPERT—SOLUTION "list multiple solutions to a problem" 
(is-a WORK-SOLUTION) 

(role concrete) 

) 

(defclass STUDENT—SOLUTION "list multiple solutions to a problem" 
(is-a WORK-SOLUTION) 

(role concrete) 

) 

(defclass PIPE-ADDRESS 
(is-a USER) 

(role concrete) 

(slot pipe 

(create—accessor read—write) 

(type EXTERNAL-ADDRESS)) 

) 

(defclass STUDENT-MODEL 
(is-a USER) 

(role concrete) 

(pattern—match reactive) 

;; slot to record number of correct responses required for mastery 
(slot mastery—threshold 
(create—accessor read—write) 

(type INTEGER) 

(pattern—match reactive) 

(default 3) 

(range 1 7VARIABLE)) 

(multislot student—misconceptions 
(create—accessor read—write) 


39 






(type SYMBOL) 

(pattern—match non—reactive) 

(allowed—values supplementary congruent adjacent vertical 
alternate—interior corresponding) 

;; assume new student knows nothing <grin> 

(default supplementary congruent adjacent verticeJ 
alternate—interior corresponding)) 

(multislot supplementary 
(create—accessor read—write) 

(type SYMBOL) 

(allowed—values correct incorrect)) 

(multislot congruent 
(create—accessor read—write) 

(type SYMBOL) 

(allowed—values correct incorrect)) 

(multislot adjacent 
(create—accessor read—write) 

(type SYMBOL) 

(allowed—values correct incorrect)) 

(multislot vertical 
(create—accessor read—write) 

(type SYMBOL) 

(allowed—values correct incorrect)) 

(multislot alternate—interior 
(create—accessor read—write) 

(type SYMBOL) 

(allowed—values correct incorrect)) 

(multislot corresponding 
(create—accessor read—write) 

(type SYMBOL) 

(allowed—values correct incorrect)) 

) 

(defclass CONCEPT 
(is-a USER) 

(role concrete) 

(slot defn 






110 


(create—accessor read—write) 

(access initialize—only) 

(type STRING) 

(default ?NONE)) 

) 

(definstances CONCEPTS 
(supplementary of CONCEPT 

(defn (str—cat "Two angles are supplementary angles if and only if" 

" the sum of their magnitudes is 180 degrees." 

" e.g. Anglel and Angle2 are supplementary."))) 120 

(congruent of CONCEPT 

(defn (str—cat "Two angles which have the same meeisure are" 

" congruent, e.g. Angle2 and AngleS are congruent."))) 

(adjacent of CONCEPT 

(defn (str—cat "Two angles are adjacent if and only if they are in" 

" the same plane and share a common side so that their non—common" 

" sides lie in different half-planes determined by the line" 

" containing the common ray. e.g. Anglel and Angle2 are adjacent" 

" angles."))) 

(vertical of CONCEPT 130 

(defn (str—cat "If the sides of two angles form two pairs of" 

" opposite rays, then the angles are vertical angles, e.g. Anglel" 

" and Angles are vertical angles."))) 

(alternate—interior of CONCEPT 
(defn (str—cat "Two angles are alternate interior angles" 

" if and only if they lie on opposite sides of the traversal, but" 

" between the two lines traversed, e.g. AngleS and AngleG are" 

" alternate interior angles."))) 

(corresponding of CONCEPT 

(defn (str-cat "Two angles are corresponding angles if and" 140 

" only if they lie on the same side of the traversal, and there" 

" exists an angle which is vertical to one of the angles, and" 

" alternate interior to the other, e.g. Angle2 and AngleG are" 

" corresponding angles."))) 


41 


(definstances PIPES (pipe—ptr of PIPE—ADDRESS)) 


150 




FUNCTIONS 


;; Convenience function for testing the equality of strings 
(deffunction str—eq (?strl ?str2) 

(= 0 (str—compare Tstrl ?str2)) 

) 


Convenience function for returning the last member in a multislot 
(deffunction last$ ($?ms) 

(prognS (?generic $?ms) (bind ?result ?generic)) 160 

(return ?result) 

) 

;; Convenience function for returning the last word in a string 
(deffunction last (?str) 

(return (last$ (explodeS ?str))) 

) 


;; Convenience function for returning the first word in a string 

(deffunction first (?str) 170 

(return (nth$ 1 (explodeS ?str))) 

) 

;; Convenience function for appending member to multislot 
(deffunction appendS (?ms ?append) 

(return (inserts ?ms (+ 1 (lengthS ?ms)) ?append)) 

) 


;; Convenience function for switching the first member in a multislot 

;; to be the last member 180 

(deffunction front—to—backS (?ms) 

(return (createS (restS ^ms) (firstS ?nis))) 

) 


42 






;; Shortcut for front—to—back$ 
(deffunction ftb$ (?ms) 

(front—to— backs ?ms) 

) 


;; Convenience function for switching the first word in a string 190 

;; to be the last word 
(deffunction front—to—back (?str) 

(return (implodeS (front—to—backS (explodeS ?8tr)))) 

) 

;; Shortcut for front—to—back 
(deffunction ftb (?ms) 

(front—to—back ?ms) 

) 

200 

;; Function to reverse the elements in multi—slot, and quantify 
;; correct as —1 and incorrect as +1 
(deffunction quantify—model! (?ms) 

(bind $?result (create!)) 

(progn! (?quality ?ms) 

(if (str—eq ?quality correct) 
then (bind ?quantity —1) 
else (bind ?quantity 1) 

) 

(bind !?result (insert! ?result 1 ?quantity)) 210 

) 

(return ?result) 

) 


;; This function initializes the CLIPS environment and sets up 
;; the geometry domain 
(deffunction init (?student) 

(unwatch all) 

;;(dribble—on debug.txt) 

;;(watch facts) 220 


43 


;;(watch rules) 

;;(watch defFunctions) 

"(watch statistics) 

;;(watch activations) 

;;(watch instances) 

;;(watch focus) 

(reset) 

(close) 

(set—static—constraint—checking TRUE) 230 

(set—dynamic—constraint—checking TRUE) 

(bind ?*student* Tstudent) 

(make—instance ?+student* of STUDENT—MODEL) 

(if (open (str—cat ?*student* ".model") tempFile "r") 
then 

(close tempFile) 

(load—instances (str—cat ?*student* ".model")) 

) 

(open (str—cat ?*8tudent+ ".log") log "w") 

(printout log 240 

"Logfile to store student approaches to problem solving." crlf crlf) 

(run) 

) 

;; This function displays the message included in the parameters 
;; of the function call to the STUDENT. The message is 
;; NOT enclosed by quotes. NOTE; avoid the use of single and 
;; double quotes. 

;; — textstring: a multivalue variable which is converted to a string 

(deffunction stu—msg ($?text) 250 

(if (not (str—eq nil (nth$ 1 $?text))) 

then (bind ?message (str—cat "tcl_student_msg " (implodeS $?text))) 

) 

(TclFunc ?message) 

(return) 

) 


44 










This function displays the message included in the parameters 
;; of the function call to the INSTRUCTOR only. The message is 

;; NOT enclosed by quotes. NOTE: avoid the use of single and 260 

double quotes. 

;; — textstring: a multivalue variable which is converted to a string 
(deffunction lEOmsg {$?text) 

(if (not (str—eq nil (nth$ 1 $?text))) 

then (bind ?message (str—cat "tcLIEOmsg " (implodeS $?text))) 

) 

(TclPunc ?message) 

(return) 

) 

270 

;; This function binds results from rules for use in the original 
;; calling function. 

(deffunction bindresult ($?textstring) 

(if (= 0 (lengths $?textstring)) 

empty parmlist —> NULLify result global 
then (bind ?*re3ult* NULL) 

;; bind parms to current result global 
else 

(bind ?result (implodeS $?textstring)) 

(if (str—eq ?*result* NULL) 280 

then (bind ?*re8ult* Tresult) 

else (bind ?+result* (str—cat ?*result* " " Tresult)) 

) 

) 

) 

;; This is a function to get the definition of a geometric term 
;; — term: the term which needs defined 
(deffunction get—definition (?term) 

(send (instance—name ?term) get—defn) 290 

) 

;; Shortcut for get—definition 
(deffunction gd (?term) 


45 








(get—definition ?term) 

) 


;; quit saves the current student model before exiting CLIPS 
(deffunction quit () 

(save—instances (str—cat ?*student* .model) local STUDENT—MODEL) 
(exit) 

) 


;; This function prints out the specified student—model 
(deffunction printstudent (?student) 

(send (instance—name ?student) print) 

) 

;; Shortcut for printstudent 
(deffunction ps () 

(printstudent ?*student*) 

) 


Function to compare two solutions 

— if the first solution track is a subset of the second, 

;; then the second solution is a valid one. 

— if the first solution matches the second, 
then the second is the exact same solution. 

(deffunction compare—solutions (?expert—soln ?student—soln) 
(bind ?expert—track (send ?expert—soln get—solution—track)) 
(bind Tstudent—track (send ?student—soln get—solution—track)) 
(bind ?result NULL) 

(progn$ (?pair ?expert—track) 

(if (not (members ?pair ?student—track)) 

;; student solution completely different from expert 
then 

(bind ?result NO—MATCH) 

(break) 

) 

) 

(if (str—eq ?result NULL) 







then 

(prognS (?pair ?student—track) 

(if (not (members ?pair ?expert—track)) 

;; student solution -contains, the expert solution, but also 

;; contains unnecessary steps 

then 

(bind ?result MATCH) 

(break) 

) 340 

) 

) 

(if (str—eq ?result NULL) 

;; student solution is .exactly, the same as the expert solution 
then 

(bind ?result PERFECT-MATCH) 

) 

(return ?result) 

) 

350 

;; Shortcut for compare—solutions 
(deffunction c—s () 

(compare—solutions [expert—soln] [student—solnj) 

) 


;; Function to copy all the EXPERT solutions for the current problem 
into the MAIN module 
(deffunction get—expert—solutions () 

(assert (get—expert—solutions ?*given—angle* ?*find—angle*)) 

(run) 360 

(return TRUE) 

) 

;; Shortcut for get—expert—solutions 
(deffunction g—e—s () 

(get—expert—solutions) 

) 


47 







;; Function to copy the STUDENT solution for the current problem 
;; into the MAIN module 
(delFunction get—student—solution () 

(assert (get—student—solution ?*given—angle* ?*find—angle*)) 
(run) 

(return TRUE) 

) 


;; Shortcut for get—student—solution 
(deffunction g—s—s () 

(get—student—solution) 

) 

;; Function to copy all the EXPERT and STUDENT solutions for the 
;; current problem into the MAIN module 
(deffunction get—all—solutions () 

(g-s-s) 

(g-e-s) 

) 

;; Shortcut for get—all—solutions 
(deffunction g—a—s () 

(get—all—solutions) 

) 


;; Function to remove all the solutions from MAIN 
(deffunction delete—all—solutions () 

(do—for—all—instances ((?soln EXPERT—SOLUTION)) TRUE 
(send ?soIn delete) 

) 

(do-for-all-instances ((?soln STUDENT-SOLUTION)) TRUE 
(send ?soln delete) 

) 

) 


;; Shortcut for delete—all—solutions 
(deffunction d—a—s () 




(delete—all—solutions) 

) 


;; function to get all expert magnitudes 
(deffunction expert—gma () 

(assert (expert—gma)) 

(run) 

) 

;; shortcut for function expert—gma 
(deffunction egma () 

(expert—gma) 

) 

;; function to get an expert magnitude 
(deffunction expert—gm (Tangle) 

(assert (expert-gm Tangle)) 

(run) 

(bind Tresult T*result*) 

(bindresult) 

(return Tresult) 

) 

;; shortcut for function expert-gm 
(deffunction egm (Tnbr) 

(return (expert-gm (sym—cat Angle Tnbr))) 

) 


;; function to get a student magnitude 
(deffunction student—gm (Tangle) 
(assert (student—gm Tangle)) 

(run) 

(bind Tresult T*result*) 

(bindresult) 

(return Tresult) 

) 


49 






;; shortcut for function student—gm 
(deffunction sgm (?nbr) 

(return (student—gm (sym—cat Angle ?nbr))) 

) 


;; function to get all student magnitudes 
(deffunction student—gma () 

(assert (student—gma)) 450 

(run) 

) 


;; shortcut for function student—gma 
(deffunction sgma () 

(student—gma) 

) 

;; function to change the mastery threshold in the current student 

(deffunction chajige—threshold (?threshold) 460 

(send (instance—name ?*student*) put—mastery—threshold ?threshold) 

) 


;; shortcut for function change—threshold 
(deffunction c—t (?threshold) 

(change—threshold ?threshold) 

) 


;; Function to get the relation between two angles as defined by 

;; the EXPERT module 470 

(deffunction expert—relate (?angl ?ajig2) 

(assert (expert—relate ?angl ?ang2)) 

(run) 

(bind $?re8ult (explodeS ?*result*)) 

(bindresult) 

(return $?result) 

) 

;; Shortcut for function expert—relate 


50 


480 


(defFunction e—r (?nbrl ?nbr2) 

(bind ?angl (sym—cat Angle ?nbrl)) 

(bind ?ang2 (sym—cat Angle ?nbr2)) 

(expert—relate ?angl ?ang2) 

) 

;; Function to get the expert magnitude relation for a specified angle 
;; relation 

(deffunction expert—mag—relation (?relation) 

(assert (expert—mag—relate ?relation)) 

(run) 490 

(bind ?result (sym—cat ?*result»)) 

(bindresult) 

(return ?result) 

) 

;; Shortcut for function expert—mag—relation 
(deffunction emr (Trelation) 

(expert—mag—relation ?relation) 

) 

500 

;; The following functions are support functions designed to be 
;; called from outside of the CLIPS environment. 

;; This is a function to get a definition for a geometric term. 

;; Designed to be called from outside the CLIPS environment. 

(deffunction CLIPS—get—definition (?term) 

(bind ?message (get—definition ?term)) 

(stu—msg ?message) 510 

(return TRUE) 

) 

;; Shortcut for function CLIPS—get—definition 
(deffunction C—gd (?term) 

(CLIPS—get—definition ?term) 

51 











(return TRUE) 

) 


;; Function to display the magnitude of a STUDENT angle. Designed to 520 

;; be called from outside the CLIPS environment. 

;; — nbr: the number of the angle whose magnitude you wish to know 

(deffunction CLIPS—stu—get—mag (Teingle) 

(bind ?message (str—cat Tangle " = " (student—gm Tangle))) 

(lEOmsg Tmessage) 

(return TRUE) 

) 

;; Shortcut for function CLIPS—stu—get—mag 

(deffunction C—sgm (Tnbr) 530 

(return (CLIPS—stu—get—mag (sym—cat Angle Tnbr))) 


;; Function to display the magnitude of an EXPERT angle. Designed to 
;; be called from outside the CLIPS environment. 

;; — nbr: the number of the angle whose magnitude you wish to know 
(deffunction CLIPS—exp—get—mag (Tangle) 

(bind Tmessage (str—cat Tangle " = " (expert—gm Tangle))) 

(lEOmsg Tmessage) 

(return TRUE) 540 


;; Shortcut for function CLIPS—exp—get—mag 
(deffunction C—egm (Tnbr) 

(return (CLIPS—exp—get—mag (sym—cat Angle Tnbr))) 

) 


;; This is a function to build parallel, bisected line problems. 

;; Designed to be called from outside of the CLIPS environment. 

— given: the angle number of the given cingle magnitude 550 

;; — mag: the magnitude of the given angle 
;; — find: the angle whose magnitude the student is to find 
(deffunction CLIPS—define—problem (Tgiven Tmag Tfind) 


52 









(bind ?*given—angle—nbr* ?given) 

(bind ?*find—angle—nbr* ?find) 

(bind ?*given—angle* (sym—cat Angle ?given)) 

(bind ?*find—angle* (sym—cat Angle ?find)) 

(bind ?*given—mag* ?mag) 

(printout log crlf 

"Given: Magnitude of angle " ?given " = " ?mag crlf) 560 

(printout log "Find; Magnitude of angle " ?find " = ? " crlf) 

(assert (define—problem ?given ?mag ?find)) 

(run) 

(return TRUE) 

) 


Shortcut for function CLIPS—define—problem 
(deffunction C—dp (?given ?mag ?find) 

(CLIPS—define—problem ?given ?mag ?find) 

(return TRUE) 570 

) 


This is a function to compare the student provided solution 
;; to the expert derived solution. Designed to be called from 
;; outside the CLIPS environment. 

(deffunction CLIPS—solution (?mag) 

(bind Texpert—mag (expert—gm ?*find—angle*)) 
check solution tracks 
(get—all—solutions) 

(do-for-instance ((?stu-soln STUDENT-SOLUTION)) TRUE 580 

(bind ?student—solution Tstu—soln) 

) 

(prognS (?exp—soln 

(find-all-instances ((?exp-soln EXPERT-SOLUTION)) TRUE) 

) 

(bind ?result (compare—solutions ?exp—soln Tstudent—solution)) 

(if (or (str-eq Tresult "MATCH") (str-eq ’result "PERFECT-MATCH")) 
then 

(bind ?expert—solution ?exp—soln) 

(break) 590 


53 









) 

) 

(bind ?student—track (send Tstudent—solution get—solution—track)) 

(if (str—eq ?result "NO—MATCH") 
then 

(bind ?message (str—cat "The student solution strategy does " 

"not match the expert.")) 

;; Check to see if student solution strategy is a valid approach 
(bind ?valid TRUE) 

(prognS (?ajigle—pair ?student—track) 600 

(bind ?ajigl (sym—cat (sub—string 2 7 Tangle—pair))) 

(bind ?ajig2 (sym—cat (sub—string 9 14 Tangle—pair))) 

(bind Trelated (implode$ (expert—relate Tangl Tang2))) 

(if (str-eq "UNRELATED UNRELATED" Trelated) 
then (bind Tvalid FALSE) 

) 

) 

(if (str—eq Tvalid FALSE) 
then 

(bind Tmessage 610 

(str—cat Tmessage 

"\\n The student's solution path is NOT valid.") 

) 

else ;; check for path from given angle to goal 

;; by executing student model get—magnitude 
;; for the find angle, if it has the solution 
;; magnitude, then there is a correct path from 
;; given to find 

(bind Tstudent—mag (student—gm T*find—single*)) 

(if (str-eq Texpert—mag Tstudent—mag) 620 

then new valid solution 
(bind Tmessage (str—cat Tmessage 
"\\n However, the student solution path IS valid.")) 
else ;; not a valid solution 
(bind Tmessage (str—cat Tmessage 
"\\n And, the student solution path IS NOT valid.")) 

) 


54 



630 


) 

else 

(if (str—eq Tresult "MATCH") 
then 

(bind Tmessage "The student solution strategy matches the expert,\ 
\\n but the student has more steps than necessary:") 

else 


(if (str-eq Tresult "PERFECT-MATCH") 
then 

(bind ?message (str—cat "The student solution strategy " 
"exactly matches the expert: ")) 


else 

(bind ?message "ERROR in CLIPS—solution!") 

) 

) 

(bind ?expert—track (send ?expert—solution get—solution—track)) 
(bind ?message 
(str—cat Tmessage 

"\\n\\tStudent relate pairs: " (implode$ ?student—track) 
"\\n\\tExpert relate pairs: " (implode$ ?expert—track) 

"\\n" ) 

) 

) 

(lEOmsg ?message) 


(delete—all—solutions) 


;; check resulting magnitude found 

(bind ?message (str—cat "Expert magnitude = " ?expert—mag 
"\\nStudent magnitude = "?mag "\\n" )) 

(lEOmsg ?message) 

(bindresult) 

(return TRUE) 

) 


640 


650 


660 


;; Shortcut for function CLIPS—solution 
(deffunction C—s (?mag) 


55 







(CLIPS—solution ?mag) 
(return TRUE) 

) 


;; Function to define relationship between two angles, as defined by 

;; the student. Designed to be called from outside of the 670 

;; CLIPS environment. 

;; — nbrl: the angle number of first angle to relate 
;; — nbr2: the angle number of second angle to relate 
;; — relation: the geometric relation specified by the student 
;; — relation—defn; specifies whether the student believes the 
;; relation indicates congruent or supplementary angles. 

(deffunction CLIPS—relate (?nbrl ?nbr2 Trelation Trelation—defn) 

(assert (relate ?nbrl ?nbr2 Trelation Trelation—defn)) 

(run) 

;; add to student model 680 

(set—current—module MAIN) 

(bind $?expert—relations (e—r ?nbrl ?nbr2)) 

(bind ?expert—relation (nth$ 1 $?expert—relations)) 

(bind ?expert—relation—defn (nth$ 2 $?expert—relations)) 

(bind ?message 

(str—cat "Relate Angle" ?nbrl " to Angle" ?nbr2)) 

(if (str—eq ?relation Texpert—relation) 
then 

(bind Tmessage (str—cat ?message "\\n\\t" ?relation correct")) 

(slot—inserts (instance—name ?*student*) Texpert-relation 1 correct) 690 

else 

(bind Tmessage (str—cat Tmessage "\\n\\t" Trelation incorrect")) 

(if (str—eq "UNRELATED" Texpert—relation) 
then 

(slot—inserts (instance—name ?*student*) Trelation 1 incorrect) 
else 

(slot— inserts (instance—name ?*8tudent*) Texpert—relation 1 
incorrect) 

) end if 

) ;; end if 700 

(run) 


56 







(if (str—eq ?relation—defn ?expert—relation—defn) 
then 

(bind Tmessage 

(str—cat ?message "\\n\\t" ?relation—defn correct")) 

(slot—inserts (instance—name ?*student*) ?expert—relation—defn 
1 correct) 
else 

(bind ?message 

(str-cat ?mes8age "\\n\\t" ?relation—defn incorrect")) 

(if (not (str—eq "UNRELATED" ?expert—relation—defn)) 
then 

(slot—inserts (instance—name ?*student+) ?expert—relation—defn 1 
incorrect) 

else do nothing because no data on cong vs suppl 
) ;; end if 
) ;; end if 
(run) 

(lEOmsg ?message) 

;; save results to the student log 

(printout log "relating Angle" ?nbrl " to Angle" ?nbr2 ": " crlf) 
(printout log " student; " ?relation " " ?relation—defn crlf) 

(printout log " expert; " ?expert—relation " " ?expert—relation—defn 
crlf) 

(return TRUE) 

) ;; end of functions CLIPS—relate 

;; Shortcut for function CLIPS—relate 

(deffunction C—r (?nbrl ?nbr2 ?relation ?relation—defn) 

(CLIPS—relate ?nbrl ?nbr2 ?relation ?relation—defn) 

(return TRUE) 

) 


;; Function to print all EXPERT solutions to the specified problem 
(deffunction CLIPS—expert—solutions (?given ?find) 

(assert (expert—solutions ?given ?find)) 


740 


(run) 

) 


;; Shortcut for function CLIPS—expert—solutions 
(deffunction C—es (?given ?find) 

(CLIPS—expert—solutions ?given ?find) 

) 


;; Function to print all STUDENT solutions to the specified problem 
(deffunction CLIPS—student—solutions (?given ?find) 

(assert (student—solutions ?given ?find)) 

(run) 750 

) 


;; Shortcut for function CLIPS—student—solutions 
(deffunction C—ss (?given ?find) 

(CLIPS—student—solutions ?given ?find) 


Function to change mastery threshold from outside CLIPS 
(deffunction CLIPS—change—threshold (?threshold) 

(change—threshold ?threshold) 760 

(return TRUE) 

) 


;; Function to get the mastery threshold from outside CLIPS 
(deffunction CLIPS—get—threshold () 

(bind Tthreshold 

(send (instance—name ?*8tudent*) get—mastery—threshold)) 

(TclFunc (str—cat "set curtain-threshold " Tthreshold)) 

(return TRUE) 

) 770 


;; Function to get concept count in STUDENT—MODEL from outside CLIPS 
(deffunction CLIPS—get—student—concept (?concept) 

(bind $?temp (send (instance—name ?*student+) 

(sym—cat get— Tconcept))) 


58 






(bind $?quantity_list (quantify—modelS ?temp)) 

(TclPunc 

(str—cat "set curtain_list(" ?concept ") {" (implodeS 
$?quantity_list) "}") 

) 780 

(return TRUE) 


• I I • I t I I • I f • f t I M t I » * f I M I M I I I i > M » M i I I >1 I M t t r I t M « n It M » 

; RULES 




(defrule update—supplementary—misconceptions "checks misconception list" 

(declare (auto—focus TRUE)) 

?inst <— (object (is—a STUDENT—MODEL) 790 

(supplementary $?correct&:(> (lengthS $?correct) 0)) 

) 

=> 

(assert 

(update—generic—misconception supplementary ?inst ?correct)) 

(run) 

) 

(defrule update—congruent—misconceptions "checks misconception list" 

(declare (auto—focus TRUE)) 800 

?inst <— (object (is—a STUDENT—MODEL) 

(congruent $?correct&;(> (length! $?correct) 0)) 

) 

= > 

(assert 

(update—generic—misconception congruent ?inst Tcorrect)) 

(run) 

) 

(defrule update—alternate—interior—misconceptions "misconception list" 810 

(declare (auto—focus TRUE)) 

?inst <— (object (is—a STUDENT—MODEL) 


59 











(alternate—interior $?correct4i:(> (lengthS $?correct) 0)) 


) 

= > 

(assert 

(update—generic—misconception alternate—interior ?inst ?correct)) 

(run) 

) 

820 

(defrule update—corresponding—misconceptions "checks misconception list" 

(declare (auto—focus TRUE)) 

?inst <— (object (is—a STUDENT—MODEL) 

(corresponding $?correctii:(> (lengthS $?correct) 0)) 

) 

=> 

(assert 

(update—generic—misconception corresponding ?inst ?correct)) 

(run) 

) 830 

(defrule update—vertical—misconceptions "checks misconception list" 

(declare (auto—focus TRUE)) 

?inst <- (object (is-a STUDENT-MODEL) 

(vertical $?correctii:(> (lengthS S?correct) 0)) 

) 

= > 

(assert 

(update—generic—misconception vertical ?inst ?correct)) 

(run) 840 

) 

(defrule update—adjacent-misconceptions "checks misconception list" 

(declare (auto—focus TRUE)) 

?inst <- (object (is-a STUDENT-MODEL) 

(adjacent S?correcti4:(> (lengthS S?correct) 0)) 

) 

= > 

(assert 


60 


(update—generic—misconception adjacent ?inst ?correct)) 
(run) 


850 


) 

(defrule update—generic—misconceptions "generalize update process" 

?temp <— (update—generic—misconception ?concept ?8tu—model $?correct) 

=> 

(retract ?temp) 

(bind ?mastery (send ?stu—model get—mastery—threshold)) 

(if (< (lengths ?correct) ?mastery) 

then (bind ?check ?correct) 860 

else (bind ?check (subseqS ?correct 1 ?mastery)) 

) 

(bind ?stu—misc (send ?stu—model get—student—misconceptions)) 

(bind ?position (memberS ?concept ?stu—misc)) 

(if (members incorrect ?check) 

;; student has misapplied concept in last attempts 
then 

(if (not (integerp ?position)) 

;; concept is not already in the misconception list 

then ;; add concept to misconception list 870 

(send ?stu—model put—student—misconceptions 
(appends ?stu—misc ?concept)) 

(lEOmsg 

(str—cat ?*student* " has not mastered " ?concept " angles.")) 

) 

else ;; student may have demonstrated mastery over last attempts 
(if (and (integerp Tposition) (= Tmastery (lengthS ?check))) 

;; concept is already in the misconception list AND 
;; student has successfully (and repeatedly) applied concept 

then ;; delete concept from misconception list 880 

(send ?stu—model put—student—misconceptions 
(deletes ?stu—misc Tposition ?position)) 

(lEOmsg (str—cat ?*student* " has apparently mastered " 

?concept " angles.")) 

) 

) 


61 



) 


ADDITIONAL MODULES 




(defmodule EXPERT (import MAIN ?ALL)) 
(defmodule STUDENT (import MAIN ?ALL)) 


890' 


EXPERT and STUDENT CONSTRUCTS i 

These are constructs which must be defined for EXPERT and STUDENT;; 
separately. ;; 


;; CLASSES ;; 

10 

(defclass ANGLE 
(is-a USER) 

(role concrete) 

(pattern—match reactive) 

(slot magnitude 
(pattern—match reactive) 

(create—accessor read—write) 

(type INTEGER) 

(range —1 180) 

(default —1) 20 

) 

) 

(definstances ANGLE-INSTANCES 
(Anglel of ANGLE) 

(Angle2 of ANGLE) 

(Angles of ANGLE) 

(Angle4 of ANGLE) 

(Angles of ANGLE) 


62 
















(AngleG of ANGLE) 

(Angle? of ANGLE) 

(Angles of ANGLE) 

) 

;; field relate—angle—pairs points to instances of RELATION 

(defclass SOLUTION "object specifying a solution to a problem" 

(is-a MAIN-SOLUTION) 

(role concrete) 

(pattern—match reactive) 

(multislot relate—angle—pairs 
(create—accessor read—write) 

(type INSTANCE-NAME) 

) 

) 

(defclass RELATION "container class for angle relations" 

(is—a USER) 

(role concrete) 

(pattern—match reactive) 

(slot angle—relation 
(pattern—match reactive) 

(create—accessor read—write) 

(type SYMBOL) 

(allowed—values adjacent vertical corresponding alternate—interior) 
(default ?NONE) 

) 

(slot magnitude—relation 
(pattern—match reactive) 

(create—accessor read—write) 

(type SYMBOL) 

(allowed—values congruent supplementary) 

(default ?NONE) 

) 

(multislot angles 
(pattern—match reactive) 

(create—accessor read—write) 


63 





(type INSTANCE-NAME) 
(default ?NONE) 

) 


;; Message—handlers for objects 


t t I ri I » f M t I I * I t I » M r t M • I t M > t I t M I I t i ) I M t M I I I ( M I r I M I t r 11 If 


;; set—mag sets the magnitude for an ANGLE object 
(defmessage—handler ANGLE set—mag primary (?mag) 

(if (= ?self:magnitude —1) then 
(bind ?self:magnitude ?mag) 

else (printout werror (instance—name ?self) " already has a " 
"magnitude!" crlf) 

) 

) 

;; myget—relate—angle—pairs goes out to the RELATION instances 
;; pointed to by the multislot, and retrieves the angle pairs related 
(defmessage—handler SOLUTION myget—relate—angle—pairs () 
(bind $?angle—pairs ?self:relate—angle—pairs) 

(bind $?result (createS)) 

(if (prognS (Tangle—pair $?angle—pairs) 

(bind ?inst (instance—name Tangle—pair)) 

(bind Tpair (implodeS (send Tinst get—angles))) 

(bind Tnew—pair (sym—cat < (first Tpair) , (last Tpair) >)) 
(bind STresult (append$ Tresult Tnew—pair)) 

) 

then (return Tresult) 
else (return NONE) 

) 

) 


;; pp pretty prints an instance of a SOLUTION object 
(defmessage—handler SOLUTION pp primary () 

;;(bind $Tangle—pairs Tself:relate—angle—pairs) 


64 









(printout t (instance—name ?self) " of " 

(get—current—module):;(class ?self) crlf) 
(printout t " (given—angle " ?self;given—angle ")" crlf) 
(printout t " (find—angle " ?self:find—angle ")" crlf) 
(printout t " (Solution track:") 

(prognS (?pair (send ?self myget—relate—angle—pairs)) 
(printout t crlf " (relate " ?pair ")") 

) 

(printout t ")" crlf) 

) 


ItllMtlllMMflfMIflMMfliMIflMMdtMfltlMrflOlltMtMMMMt 

FUNCTIONS 




;; The following functions are user interface functions for use 
;; the instuctor. 

;; Function to set the magnitude of an angle. 

;; — angle: the angle to set 

;; — mag: the magnitude to assign to the angle 

(deffunction set—mag (Tangle ?mag) 

(send (instance—name Tangle) set—mag Tmag) 

(run) 


;; shortcut for set—mag 

;; — nbr: the number of the angle to set 

(deffunction sm (Tnbr Tmag) 

(set—mag (sym—cat Angle Tnbr) Tmag) 

) 


;; Function to display the magnitude of an angle. 

;; — angle: the angle whose magnitude is required 
(deffunction get—mag (Tangle) 

(bind Tmag (send (instance—name Tangle) get—magnitude)) 











(run) 

(return ?mag) 

) 


;; shortcut for get—mag 

;; — nbr: the number of the angle whose magnitude you wish to know 
(deffunction gm (?nbr) 

(return (get—mag (sym—cat Angle ?nbr))) 

) 

150 

;; Function to get ALL the angles' magnitudes. 

(deffunction get—mag—all () 

(loop—for—count (?nbr 1 8) do 
(printout t "Angle" ?nbr " = " (gm ?nbr) crlf) 

) 

(return) 

) 

;; shortcut for get—mag—all 

(deffunction gma () 160 

(get—mag—all) 

) 


;; This is a function to build parallel, bisected line problems 
;; — given: the angle number of the given angle magnitude 
;; — mag: the magnitude of the given angle 

;; — find: the angle number whose magnitude the student is to find 

(deffunction define—problem (?given ?mag ?find) 

(sm ?given ?mag) 

) 170 

;; Shortcut for function define—problem 

;; — given: the angle number of the given angle magnitude 

;; — mag: the magnitude of the given angle 

;; — find: the angle whose magnitude the student is to find 

(deffunction dp (?given ?mag ?find) 

(define—problem ?given ?mag ?find) 


66 







) 


;; Function to print ALL solutions 180 

(deffunction print—solutions—all () 

(do—for—all—instances ((?soln SOLUTION)) TRUE 
(send ?soln pp) 

) 

) 


;; Shortcut for function print—solutions—all 
(deffunction p—s—a () 

(print—solutions—all) 

) 190 


;; Function to print all solutions for the specified problem 
(deffunction print—solutions (?given ?find) 

(do—for—all—instances ((?soln SOLUTION)) 

(and (str—eq ?given (send ?soln get—given—angle)) 

(str—eq ?find (send ?soln get—find—angle)) 

) 

(send ?soln pp) 

) 

) 200 


;; Shortcut for function print—solutions 
(deffunction p—s (?given ?find) 

(print—solutions (str—cat Angle ?given) (str—cat Angle ?find)) 

) 


;; Function to copy solution to MAIN 
(deffunction copy—solution (?old—soln) 

(bind ?soln—instance (instance—name ?old—soln)) 

(make—instance of (sym—cat (get—current—module) —SOLUTION) 210 

(given—angle (send ?soln—instance get—given—angle)) 

(find—angle (send ?soln—instance get—find—angle)) 

(solution—track (send ?soln—instance myget—relate—angle—pairs)) 

) 


67 


;; Function to make copies of all solutions for the specified problem 
(deffunction copy—all—solutions (?given ?find) 

(do—for—all—instances ((?soln SOLUTION)) 

(and (str—eq ?given (send ?soln get—given—angle)) 220 

(str—eq ?find (send ?soln get—find—angle)) 

) 

(copy—solution ?soln) 

) 

) 


RULES 

lllfMtitMilMtMMtMIMriMMtlMIMflllfMMMtftMrMfMttttrrMM 

230 

(defrule congruent—angle "set magnitude on congruent angles" 

(declare (auto—focus TRUE)) 

(object (is—a RELATION) (magnitude—relation congruent) 

(angles ?al ?a2)) 

(object (is—a ANGLE) (name ?al) (magnitude ?magl)) 

(object (is—a ANGLE) (name ?a2) (magnitude ?mag2)) 

(test (or (= ?magl —1) (— ?mag2 —1))) 

(test (!= ?magl ?mag2)) 

= > 

(if (= ?magl —1) then (set—mag ?al ?mag2) 240 

else (set—mag ?a2 ?magl)) 

) 

(defrule supplementary—angle "set magnitude of supplementary angles" 

(declare (auto—focus TRUE)) 

(object (is—a RELATION) (magnitude—relation supplementary) 

(angles ?al ?a2)) 

(object (is—a ANGLE) (name ?al) (magnitude ?magl)) 

(object (is—a ANGLE) (name ?a2) (magnitude ?mag2)) 

(test (or (= ?magl —1) (= ?mag2 —1))) 250 

(test (!= ?magl ?mag2)) 


68 










=> 

(if (= ?magl —1) then (set—mag ?al (— 180 ?mag2)) 
else (set—mag ?a2 (— 180 ?magl))) 


EXPERT CONSTRUCTS 

These are constructs which must be defined for EXPERT module 


RELATION INSTANCES 


(definstances ALTERNATE-INTERIOR-RELATIONS 

(Relates—6 of RELATION (angle—relation alternate—interior) 
(magnitude—relation congruent) 

(angles [AngleS] [Anglefi])) 

(Relate4—5 of RELATION (angle—relation alternate—interior) 
(magnitude—relation congruent) 

(angles [Angle4] [Angle5])) 

) 

(definstances CORRESPONDING-RELATIONS 

(Relatel—5 of RELATION (angle—relation corresponding) 
(magnitude—relation congruent) 

(angles [Anglel] [AngleS])) 

(Relates—6 of RELATION (angle—relation corresponding) 
(magnitude—relation congruent) 

(angles [AngleS] [Anglefi])) 

(Relates—7 of RELATION (angle—relation corresponding) 
(magnitude—relation congruent) 

(angles [AngleS] [Angle?])) 

(Relate4—8 of RELATION (angle—relation corresponding) 
(magnitude—relation congruent) 

(angles [Angle4] [AngleS])) 

) 

(definstances VERTICAL-RELATIONS 


10 


20 


30 


69 







(Relatel—4 of RELATION (angle—relation vertical) 

(magnitude—relation congruent) 

(angles [Anglel] [Angle4])) 

(Relate2—3 of RELATION (angle—relation vertical) 

(magnitude—relation congruent) 

(angles [Angle2] [Angle3])) 

(Relates—8 of RELATION (angle—relation vertical) 

(magnitude—relation congruent) 

(angles [AngleS] [AngleS])) 40 

(Relate6—7 of RELATION (angle—relation vertical) 

(magnitude—relation congruent) 

(angles [Angle6] [Angle?])) 

) 

(definstances ADJACENT-RELATIONS 
(Relatel—2 of RELATION (angle—relation adjacent) 

(magnitude—relation supplementary) 

(angles [Anglel] [Angle2])) 

(Relatel—3 of RELATION (angle—relation adjacent) 50 

(magnitude—relation supplementary) 

(angles [Anglel] [Angle3])) 

(Relate2—4 of RELATION (angle—relation adjacent) 

(magnitude—relation supplementary) 

(angles [Angle2] [Angle4])) 

(Relate3—4 of RELATION (angle—relation adjacent) 

(magnitude—relation supplementary) 

(angles [Angle3] [Angle4])) 

(Relates—6 of RELATION (angle—relation adjacent) 

(magnitude—relation supplementary) 60 

(angles [AngleS] [Angle6])) 

(Relates—7 of RELATION (angle—relation adjacent) 

(magnitude—relation supplementary) 

(angles [AngleS] [Angle?])) 

(RelateG—8 of RELATION (angle—relation adjacent) 

(magnitude—relation supplementary) 

(angles [AngleG] [AngleS])) 

(Relate?—8 of RELATION (angle—relation adjacent) 


70 


(magnitude—relation supplementary) 
(angles [Angle?] [AngleS])) 


70 


) 

;; SOLUTION INSTANCES ;; 

(definstances EXPERT-SOLUTIONS 
(of SOLUTION 

(given—angle (instance—name Anglel)) 

(find—angle (instance—name Angle2)) 

(relate—angle—pairs [Relatel—2]) 

) 80 
(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [Relatel—2]) 

) 

(of SOLUTION 

(given—angle (instance—name Anglel)) 

(find—angle (instance—name Angle3)) 

(relate—angle—pairs [Relatel—3]) 

) 90 

(of SOLUTION 

(given—angle (instance—name Angle3)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [Relatel—3]) 

) 

(of SOLUTION 

(given—angle (instance—name Anglel)) 

(find—angle (instance—name Angle4)) 

(relate—angle—pairs [Relatel—4]) 

) 100 

(of SOLUTION 

(given—angle (instance—name Angle4)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [Relatel—4]) 

) 


71 






(of SOLUTION 

(given—ajigle (instance—name Anglel)) 

(find—angle (instance—name AngleS)) 

(relate— angle—pairs [Relatel —5]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [Relatel—5]) 

) 

(of SOLUTION 

(given—ajigle (instance—name Anglel)) 

(find—angle (instance—name Anglefi)) 

(relate—angle—pairs [Relatel—5] [RelateS—6]) 

) 

;; here is one multiple solution for testing... 


(of SOLUTION 

(given—angle (instance—name Anglel)) 

(find—angle (instance—name Anglefi)) 

(relate—angle—pairs [Relatel—3] [RelateS—6]) 

) 

(of SOLUTION 

(given—angle (instance—name Anglefi)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [Relate2—6] [Relatel—2]) 

) 

(of SOLUTION 

(given—angle (instance—name Anglel)) 

(find—angle (instance—name Angle?)) 

(relate—angle—pairs [Relatel—5] [RelateS—7]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle?)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [RelateS—7] [Relatel—5]) 

) 

(of SOLUTION 







(given—angle (instance-name Anglel)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [Relatel—4] [Relate4—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Anglel)) 

(relate—angle—pairs [Relate4—8] [Relatel—4]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [Relate2—3]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angle2)) 
(relate—angle—pairs [Relate2—3]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (instance—name Angle4)) 

(relate—angle—pairs [Relate2—4]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle4)) 

(find—angle (instance—name Angle2)) 

(relate—angle—pairs [Relate2—4]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (instance—name AngleS)) 
(relate—angle—pairs [Relate2—4] [Relate4—5]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angle2)) 


73 


(relate—angle—pairs [Relate4—5] [Relate2—4]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (instance—name Anglefi)) 
(relate—angle—pairs [Relate2—6]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleG)) 

(find—angle (instance—name Angle2)) 
(relate—angle—pairs [Relate2—6]) 


) 

(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (instance—name Angle?)) 

(relate—angle—pairs [Relate2—6] [RelateG—?]) 

) 

(of SOLUTION 

(given-angle (instance-name Angle?)) 

(find—angle (instance—name Angle2)) 

(relate—angle—pairs [RelateG—7] [Relate2—6]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle2)) 

(find—angle (Instance—name AngleS)) 

(relate—angle—pairs [Relate2—4] [Relate4—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angle2)) 

(relate—angle—pairs [Related—8] [Relate2—4]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angled)) 
(relate—angle—pairs [RelateS—4]) 

) 


180 


190 


200 


210 


74 







(of SOLUTION 

(given—angle (instance—name Angle4)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [RelateS—4]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [RelateS—4] [Relate4—5]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [Relate4—5] [RelateS—4]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Anglefi)) 
(relate—angle—pairs [RelateS—6]) 

) 

(of SOLUTION 

(given—angle (instance—name Anglefi)) 

(find—angle (instance—name AngleS)) 
(relate—angle—pairs [RelateS—6]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angle?)) 
(relate—angle—pairs [RelateS—7]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle?)) 

(find—angle (instance—name AngleS)) 
(relate—angle—pairs [RelateS—?]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 


220 


230 


240 


250 


75 






(find—Eingle (instance—name AngleS)) 

(relate—angle—pairs [RelateS—4] [Related—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name AngleS)) 
(relate—angle—pairs [Related—8] [RelateS—4]) 


) 

(of SOLUTION 

(given—angle (instance—name Angled)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [Related—5]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angled)) 

(relate—angle—pairs [Related—5]) 

) 

(of SOLUTION 

(given—angle (instance—name Angled)) 

(find—angle (instance—name AngleS)) 

(relate—angle—pairs [Related—5] [RelateS—6]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 

(find—angle (instance—name Angled)) 

(relate—angle—pairs [RelateS—6] [Related—5]) 

) 

(of SOLUTION 

(given—angle (instance-name Angled)) 

(find—angle (instance—name Angle?)) 
(relate—angle—pairs [Related—5] [RelateS—7]) 


) 

(of SOLUTION 

(given—angle (instance—name Angle?)) 

(find—angle (instance—name Angled)) 

(relate—angle—pairs [RelateS—?] [Related—5]) 


260 


270 


280 


290 


76 






) 

(of SOLUTION 

(given—angle (instance—name Angle4)) 
(find—angle (instance—name AngleS)) 
(relate—angle—pairs [Relate4—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 
(find—angle (instance—name Angle4)) 
(relate—angle—pairs [Relate4—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 
(find—angle (instance—name Angled)) 
(relate—angle—pairs [RelateS—6]) 

) 

(of SOLUTION 

(given—angle (instance—name Angled)) 
(find—angle (instance—name AngleS)) 
(relate—angle—pairs [RelateS—6]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 
(find—angle (instance—name AngleT)) 
(relate—angle—pairs [RelateS—7]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleT)) 
(find—angle (instance—name AngleS)) 
(relate—angle—pairs [RelateS—7]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 
(find—angle (instance—name AngleS)) 
(relate—angle—pairs [RelateS—8]) 

) 

(of SOLUTION 



(given—ajigle (instance—name AngleS)) 
(find—angle (instance—name Angle5)) 
(relate—angle—pairs [Relate5—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleG)) 
(find—angle (instance—name Angle?)) 
(relate—angle—pairs [RelateG—7]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle?)) 
(find—angle (instance—name Anglefi)) 
(relate—angle—pairs [Relate6—?]) 

) 

(of SOLUTION 

(given—angle (instance—name Anglefi)) 
(find—aoigle (instance—name AngleS)) 
(relate—angle—pairs [RelateS—8]) 


) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 
(find—angle (instance—name Anglefi)) 
(relate—angle—pairs [RelateS—8]) 

) 

(of SOLUTION 

(given—angle (instance—name Angle?)) 
(find—angle (instance—name AngleS)) 
(relate—angle—pairs [Relate?—8]) 

) 

(of SOLUTION 

(given—angle (instance—name AngleS)) 
(find—angle (instance—name Angle?)) 
(relate—angle—pairs [Relate?—8]) 


) 




RULES 


r > t ri r >»> f M M f»f 111 r f > rf M • MI M11 (• n f i»M * I f M M M IMIM rtt »M IM Mt 

(defrule expert—solutions "rule to call the EXPERT print—solutions" 

(declare (auto—focus TRUE)) 

?temp <— (expert—solutions ?given ?find) 370 

= > 

(retract ?temp) 

(p—s ?given ?find) 

) 

(defrule get—expert—solutions "rule to get all the EXPERT solutions" 

(declare (auto—focus TRUE)) 

?temp <— (get—expert—solutions ?given ?find) 

= > 

(retract ?temp) 380 

(copy—all—solutions ?given ?find) 

) 

(defrule expert—get—mag "rule to call the EXPERT get—mag" 

(declare (auto—focus TRUE)) 

?temp <— (expert—gm Tangle) 

= > 

(retract ?temp) 

(bindresult (get—mag Tangle)) 

) 390 

(defrule expert—define—prob "rule reacts and then focuses STUDENT" 

(declare (auto—focus TRUE)) 

(define—problem Tgiven Tmag Tfind) 

=> 

;; change all angle mags back to —1 
(do—for—all—instances ((Tangle ANGLE)) 

(!= —1 (send Tangle get—magnitude)) 

(send Tangle put—magnitude —1) 

) 400 

(dp Tgiven Tmag Tfind) 


79 




(focus STUDENT) 


(defrule expert—gma "get all magnitudes in EXPERT module" 
(declare (auto—focus TRUE)) 

?temp <— (expert—gma) 

= > 

(retract ?temp) 

(gma) 

) 

(defrule expert—relate "get relations between two angles" 
(declare (auto—focus TRUE)) 

?temp <— (expert—relate ?angl ?ang2) 

= > 

(retract ?temp) 

(if (not 

(do—for—instance ((?rel RELATION)) 

(and (members (instance—name ?angl) ?rel:angles) 
(members (instance—name ?ang2) ?rel:angles)) 
(bindresult (send ?rel get—angle—relation) 

(send ?rel get—magnitude—relation)) 

)) 

then (bindresult UNRELATED UNRELATED) 

) 

) 

(defrule expert—mag—relate "get expert magnitude relation" 
(declare (auto—focus TRUE)) 

?temp <— (expert—mag—relate Tangle—rel) 

= > 

(retract Ttemp) 

(do—for—instance ((?rel RELATION)) 

(str—eq ?rel:angle—relation Tangle—rel) 

(bindresult (send Trel get—magnitude—relation)) 

) 


80 



STUDENT CONSTRUCTS 

These are constructs which must be defined for STUDENT module 


FUNCTIONS 




;; Function to define relationship between two angles, 10 

;; — al: the first angle to relate 

;; — a2: the second angle to relate 
(deffunction relate (?al ?a2 ?ajig—rel ?mag—rel) 

(if (do—for—instance ((?inst RELATION)) 

(or (and (str—eq ?al (nth$ 1 ?inst:angles)) 

(str—eq ?a2 (nth$ 2 ?inst;angles))) 

(and (str—eq ?a2 (nth$ 1 ?inst:angles)) 

(str—eq ?al (nth$ 2 ?inst:angles)))) 

(bind ?reln ?inst) 

) 20 

then ;; this relation already exists, so just modify it 
;;(send (instance—name ?reln) put—angle—relation ?ang—rel) 

;;(send (instance—name ?reln) put—magnitude—relation ?mag—rel) 

(modify—instance (instance—name ?reln) 

(angle—relation ?ang—rel) 

(magnitude—relation ?mag—rel) 

) 

else ;; this relation DNE, so create it 
(bind ?reln (make—instance of RELATION 

(angle—relation ?ang—rel) 30 

(magnitude—relation ?mag—rel) 

(angles (instance—name ?al) (instance—name ?a2)) 

) 


) ;; end if 


81 












(if (do—for—instance ((?inst SOLUTION)) 

(and (str—eq ?*find—angle* ?inst:find—angle) 

(str—eq ?*given—angle* ?inst:given—angle) 

) 

(bind ?soln ?inst) 

) 

then ;; modify existing SOLUTION, else no problem defined 
(if (not (members ?reln (send ?soln get—relate—angle—pairs))) 
then ;; this exact relation DNE in SOLUTION, so add it 
(bind $?old—angles (send ?soln get—relate—angle—pairs)) 

(send ?soln put—relate—angle—pairs (appendS ?old—angles ?reln)) 

) 

) 

(run) 

) 


;; shortcut for relate 

;; — nbrl: the angle number of first angle to relate 
;; — nbr2; the angle number of second angle to relate 
(deffunction r (?nbrl ?nbr2 ?ang—rel ?mag—rel) 

(relate (sym—cat "Angle" ?nbrl) 

(sym—cat "Angle" ?nbr2) 

?ang—rel ?mag—rel) 


RULES 




(defrule student—solutions "rule to call the STUDENT print—solutions" 
(declare (auto—focus TRUE)) 

?temp <— (student—solutions ?given ?find) 

= > 

(retract ?temp) 

(p—s ?given ?find) 

) 


82 












(defrule get—student—solution "rule to get the STUDENT solution" 
(declare (auto—focus TRUE)) 

?temp <— (get—student—solution ?given ?find) 

= > 

(retract ?temp) 

(copy—all—solutions ?given ?find) 

) 

(defrule student—relate—angles "rule to call STUDENT relate" 
(declare (auto—focus TRUE)) 

?temp <— (relate ?al ?a2 ?ang—rel ?mag—rel) 

=> 

(retract ?temp) 

(r ?al ?a2 ?ang—rel ?inag—rel) 

) 

(defrule student—get—mag "rule to call the STUDENT get—mag" 
(declare (auto—focus TRUE)) 

?temp <— (student—gm Tangle) 

=> 

(retract ?temp) 

(bindresult (get—mag Tangle)) 

) 

(defrule student—define—prob "rule reacts to focus by EXPERT" 
Ttemp <— (define—problem Tgiven Tmag Tfind) 

= > 

(retract Ttemp) 

;; change all angle mags back to —1 
(do—for—all—instances ((Tangle ANGLE)) 

(!= —1 (send Tangle get—magnitude)) 

(send Tangle put—magnitude —1) 

) 

(dp Tgiven Tmag Tfind) 

(bind Tgiven—angle (sym—cat Angle Tgiven)) 

(bind Tfind—angle (sym—cat Angle Tfind)) 

(if (not (do—for—instance 





((?soln SOLUTION)) 

(and (str—eq ?given—angle ?soln:given—angle) 

(str—eq ?find—angle ?soln:find—angle)) 

(send ?soln put—relate—angle—pairs (createS))) 

) 

then 

(make—instance of SOLUTION 
(given—angle (instance—name ?given—angle)) 

(find—angle (instance—name ?find—angle)) 

) 

) 

) 

(defrule student—gma "get all magnitudes in STUDENt module" 
(declare (auto—focus TRUE)) 

?temp <— (student—gma) 

= > 

(retract ?temp) 

(gma) 


Appendix C. Curtain Interface Tcl/Tk Code 


#procedure to force a variable to an integer angle between 0 and 180 
proc tcLforceAng {name element op} { 
upvar $name x ${name}_old x.old 
if { ($x < 0) 11 ($x > 180) } { 

tcLIEOmsg "Invalid angle magnitude! Must be between 0 and \ 

180 degrees. Changing $x to previous value of $x_old." 
set X $x_old 
} 

set x_old $x 

} ;# end of procedure tcLforceAng 10 

# procedure to display a message for the instructor to read 
proc tcLIEOmsg {msg} { 

set index 0 

while {[winfo exists .instructorSindex]} { incr index } 

toplevel .instructorSindex 

wm title .instructorSindex "Instructor" 

frame .instructorSindex.! —relief raised —borderwidth 4 

pack .instructorSindex.! 

message .instructorSindex.m —width 6i —justify left —text Smsg \ 20 

—relief sunken —borderwidth 4 
pack .instructorSindex.m —in .instructorSindex.! —fill both 
button .instructorSindex.b —text "Go away" —command "destroy \ 

.instructorSindex" 

pack .instructorSindex.b —in .instructorSindex.! 

} 

# procedure to display a message for the student to read 
proc tcLstudent-msg {msg} { 

global curtain-remote curtain-local curtain-remote-display 30 

global curtain-student 
set mindex 0 
set sindex 0 

while {[winfo exists .messageSmindex]} { incr mindex } 
while {[winfo exists .studentSsindex]} { incr sindex } 


85 







toplevel .messageSmindex —screen $curtain_remote_display 
toplevel .student$sindex 
wm title .messageSmindex $curtain_student 
wm title .studentSsindex "Student" 

frame .studentSsindex.f —relief raised —borderwidth 4 40 

pack .studentSsindex.f 

frame .messageSmindex.f —relief raised —borderwidth 4 
pack .messageSmindex.f 

message .messageSmindex.m —width 6i —justify left —text Smsg \ 

—relief sunken 

message .studentSsindex.m —width 6i —justify left —text Smsg \ 

—relief sunken 

pack .messageSmindex.m —in .messageSmindex.f 
pack .studentSsindex.m —in .studentSsindex.f 

button .messageSmindex.b —text "Go away" —command "destroy \ 50 

.messageSmindex" 

button .studentSsindex.b —text "Go away" —command "destroy \ 

.studentSsindex" 

pack .messageSmindex.b —in .messageSmindex.f 
pack .studentSsindex.b —in .studentSsindex.f 
} 

proc tcLtype.message {} { 
toplevel .typemsg 

wm title .typemsg "Enter Message" 60 

wm iconname .typemsg "Message" 

frame .typemsg.top 

frame .typemsg.bottom 

label .typemsg.1 —text \ 

"Please enter the message for the student: " 
entry .typemsg.e —width 100 —relief sunken \ 

—textvariable curtain.stu.msg 

.typemsg.e icursor 0 ;# position insertion cursor at beginning 
.typemsg.e selection range 0 end ;# highlight text for easy deletion 

pack .typemsg.top —side top -padx 3m —pady Im 70 

pack .typemsg.bottom —side bottom —padx 3m —pady Im 
pack .typemsg.1 .typemsg.e —side top —in .typemsg.top 


86 








button .typemsg.ok —text OK —command { 
tcLstudent.msg $curtain_stu_msg 
destroy .typemsg 
} 

button .typemsg.c —text Cancel —command {destroy .typemsg} 
pack .typemsg.ok .typemsg.c —side left —in .typemsg.bottom 
bind .typemsg.e <Return> {focus .typemsg.ok} 

focus .typemsg.e 80 

} 

# procedure to build a prompt to select aji angle 
proc tcLcreate_ajigle_prompt {name title label} { 
global curtain-angle 
toplevel .$name 
wm title .$name Stitfe 
frame .Sname.top 
frame .$name.bottom 

pack .Sname.top —side top —padx 3m —pady Im 90 

pack .Sname.bottom —side bottom —padx 3m —pady Im 

label . Sname. f —text Sfabef 

pack .Sname.f —in .Sname.top 

for {set i 1} {Si < 9} {incr i} { 

radiobutton .Sname.bSi —text "Angle Si" —variable curtain-angle \ 

—value Si 

pack . Sname.bSi —side left —in .Sname.top 
} ;# end of for loop 

button .Sname.ok —text OK —command " destroy .Sname " 

button .Sname.can —text Cancel —command " 100 

set curtain-angle \"\" 
destroy .Sname 

It 

pack .Sname.ok .Sname.can —side left —in .Sname.bottom 
focus .Sname.ok 
tkwait window .Sname 
return Scurtain-angle 

} ;# end of procedure tcLcreate-angle-prompt 


87 





no 


# procedure to prompt for solution, and call CLIPS—solution 
proc tcl.solution {} { 

global curtain_flnd curtain.mag 
trace variable mag w tcLforceAng 
if { $curtain_find != 0 } { 

# create prompt for student solution 
set mag $curtain_mag 
toplevel .get.magnitude 
wm title .get-magnitude "Get Magnitude" 
label .get_magnitude.l —text \ 

"Please enter the magnitude of Angle$curtain_find:" 120 

entry .get.magnitude.e —relief sunken —textvariable curtain_mag 
.get.magnitude.e icursor 0 ;# pos insertion cursor at beginning 
.get.magnitude.e selection range 0 end ;# highlight text 
pack .get-magnitude.1 .get.magnitude.e —side left 
bind .get.magnitude.e <Return> { destroy .get.magnitude } 
focus .get.magnitude.e 
tkwait window .get.magnitude 
set mag Scurtain.mag 

set curtain.mag $mag ;# mag is traced, so set c.mag to valid mag 

if { $mag != "" } { 130 

puts "CLIPS—solution $mag" 
flush stdout 
} 

} else { 

tcl-IEOmsg "No problem to solve! Define a problem first." 

} ;# end of if curtain.find 
} ;# end of procedure tcl.solution 

# procedure to actually make the CLIPS—get—mag call 

proc tcl.get.mag {} { 140 

set angle [tcl.create.angle.prompt get.magnitude "Get Magnitude"\ 

"Please select the angle whose magnitude you require;"] 
if { Sangfe 1= "" } { 
puts "CLIPS—get—mag Sangfe" 
flush stdout 
} 


88 








} ;# end of procedure tcLget_mag 


It procedure to prompt for the definition of a relation 
proc tcl_get_reLdefn {relatel relate2} { 
global curtain.defn 
toplevel .tgrd 

wm title .tgrd "Define Relations" 
frame .tgrd.top 
frame .tgrd.bottom 

pack .tgrd.top —side top —padx 3rti —pady Im 
pack .tgrd.bottom —side bottom —padx 3m —pady Im 
label .tgrd.l —text "Angle$refatel and Angle$re£ate2 are:" 
pack .tgrd.l —in .tgrd.top 
foreach i {congruent supplementary} { 
radiobutton .tgrd.bSi —text $i —variable curtain.defn —value $i 
pack .tgrd.bSi —side left —in .tgrd.top 
} ;# end of for loop 

button .tgrd.prompt —text "Prompt student" —command " 
tcLstudent-msg \"Are AngleSrefatel and Angle$refate2 congruent \ 
or 3upplementary?\" " 

button .tgrd.ok —text OK —command " destroy .tgrd " 
button .tgrd.can —text Cancel —command " set curtain.defn \"\" 

destroy .tgrd " 

pack .tgrd.ok .tgrd.can .tgrd.prompt —side left —in .tgrd.bottom 
tkwait window .tgrd 
return Scurtain.defn 
} ;# end of procedure tcl.get.rel.defn 

# procedure to build a prompt to select a relation 
proc tcl_get_relation {relatel relate2} { 
global curtain-relation 
toplevel .tgr 

wm title .tgr "Select Relation" 
frame .tgr.top 
frame .tgr.bottom 

pack .tgr.top —side top —padx 3m —pady Im 
pack .tgr.bottom —side bottom —padx 3m —pady Im 




label .tgr.l —text "Which defines the relation between \ 

AngleSre^atel and Angle$re^ate2?" 
pack .tgr.l —in .tgr.top 

foreach i {vertical adjacent alternate—interior corresponding} { 
radiobutton .tgr.bSi —text $i —variable \ 
curtain-relation —value $i 

pack .tgr.b$i —side left —in .tgr.top 190 

} ;# end of for loop 

button .tgr.prompt —text "Prompt student" —command " 
tcLstudent.msg \"Define the relationship between Angle$refatel\ 
and Angle$refate2. Are they vertical, adjacent,\ 
alternate—interior, or corresponding angles?\" 

II 

button .tgr.ok —text OK —command " destroy .tgr " 
button .tgr.can —text Cancel —commajid " 

set curtain-relation \"\" 

set curtain-defn \"\" 200 

destroy .tgr " 

pack .tgr.ok .tgr.can .tgr.prompt —side left —in .tgr.bottom 
tkwait window .tgr 
return $curtain_relation 
} ;# end of procedure tcLget-relation 

# procedure to get the angles to relate and call the CLIPS—relate 
proc tcLrelate {} { 

# get the angles to relate 

set relatel [tcl_create-angle_prompt relate-angles "Relate Angles"\ 210 

"Please select the FIRST angle to relate:"] 
if { Srefatel != "" } { 

set relate2 [tcLcreate-angle.prompt relate_angles "Relate Angles "\ 

"Please select the SECOND angle to relate:"] 

# define the relations between the selected angles 
if { $refate2 != "" } { 

set relation [tcLget-relation Srefatel $refate2] 

# call CLIPS—relate function if parms present 
if { Srefation != "" } { 

set relation-defn [tcLget-rel.defn Srefatel $refate2] 220 


90 






if { $refation-defn != "" } { 

puts "CLIPS—relate $refatel $refate2 Srefation $refation_defn" 
flush stdout 

} ;# end of if relation.defn 

} ;# end of if relation 
} ;# end of if relate2 
} ;# end of if relatel 
} ;# end of procedure tcLrelate 

# procedure to call the CLIPS—get—definition 
proc tcl-get.definition {} { 

#get the term to define 

toplevel .get-term 

wm title ,get-term "Which term?" 

frame .get_term.fb 

pack ,get-term.fb —side bottom 

label .get-term.1 —text \ 

"Please select the term to define:" 
pack .get-term.1 

foreach t {supplementary congruent vertical adjacent 
alternate—interior corresponding} { 
button .get-term.b$t —text $t —command " 
puts \"CLIPS—get—definition $t\" 
destroy .get_term 

tl 

pack .get-term.b$t —side left 
} ;# end of for loop 

button .get-term.be —text Cancel —command { destroy .get-terra } 
pack .get-term.be —in .get-term.fb 
} ;# end of procedure tcLget-definition 

# procedure to call the CLIPS—procedure define—problem after querying 

# instructor for the parms 
proc tcl-define-problem {} { 

global curtain-mag curtain-find 
trace variable mag w tcLforceAng 
# create prompt for given angle 


91 







set given [tcLcreate_angle_proinpt given_angle "Given Angle"\ 

"Please select the KNOWN angle for the problem:"] 

if { $given != "" } { 260 

# create prompt for given magnitude 
set mag $curtain_mag 
toplevel .get_magnitude 
wm title .get.magnitude "Get Magnitude" 
label .get_magnitude.l —text \ 

"Please enter the magnitude of Angle$given:" 
entry .get.magnitude.e —relief sunken —textvariable curtain.mag 
.get.magnitude.e icursor 0 ;# pos insertion cursor at beginning 
.get.magnitude.e selection range 0 end ;# highlight text 

pack .get.magnitude.1 .get.magnitude.e —side left 270 

bind .get.magnitude.e <Return> { destroy .get.magnitude } 

focus .get.magnitude.e 

tkwait window .get.magnitude 

set mag Scurtain.mag 

set curtain.mag $mag ;# mag is traced, so set c.mag to valid mag 
if { $mag != "" } { 

# create prompt for find angle 

set find [tcl.create.angle.prompt find.angle "Find Angle"\ 

"Please select the angle whose magnitude must be \ 

found:"] 280 

if { $find != "" } { 

# actually call the CLIPS—function after sending message 

# also bind global variable for use in tcLsolution 
set curtain-find $find 

set msg "Given: magnitude of Angle Sgiven = \ 

$mag, Find: magnitude of Angle $find." 
tcl.student.msg $msg 

puts "CLIPS—define—problem Sgiven $mag Sfind" 
flush stdout 

} ;# end of if find 290 

} ;# end of if mag 
} ;# end of if given 

} ;# end of procedure tcl.define.problem 


92 







It procedure to display instructions to the student 
proc tcLdisplay-instr {} { 

global curtain-remote curtain-local curtain-remote-display 
global curtain-path 

toplevel .stu-instr —screen Scurtaiti-remote-display 
toplevel .instr-instr 
foreach tl {stu-instr instr-instr} { 
wm title .$t^ "General Instructions" 
wm iconname .$t^ "Instructions" 

wm iconbitmap .$t^ 0${curtain-path}/images/parsJlel.icon 
wm geom .$t^ +0+615 
wm minsize .$t^ 680 20 

frame .Stf.bot 

pack .Stf.bot —side bottom —fill both 

message .$tf.m —width 705 —justify left —text "You will be \ 
presented with some geometry problems related to the pairallel \ 
lines figure above. Please answer the questions loudly and \ 
clearly, so the microphone can pick up your responses. The \ 
tutoring system will prompt you with additional instructions \ 
or requests. Good luck!" 

pack ,$tf.m —expand yes —fill both —padx 2m —pady 2m 

} 

button .stu-instr.bot.quit —text "Go Away" —command {destroy \ 
.stu-instr} 

pack .stu-instr.bot.quit 

button .instr-instr.bot.quit —text "Go Away" —command { 
destroy .instr-instr 
} 

pack .instr-instr.bot.quit 

} 

# procedure to display the current student model 
proc tcLdisplay.model {} { 
global curtain-list curtain-student curtain-path 


set index 0 

while {[winfo exists .student.modeLSindex]} { incr index } 
set tl student_model_$index 
toplevel .$t£ 

wm title .$t^ "Model of $curtain_student" 
wm iconname .$t^ Scurtain-student 
wm geom .$tf +0+0 
wm minsize .$tf 40 60 

340 

frame .$tf.bot 

pack .$t^-bot —side bottom —fill both 

set maxx 600 
set maxy 300 
set minx 10 
set miny 10 
set basex 130 
set basey 50 
set deltax 20 
set deltay 50 

set concepts [array names curtain-list] 
image create bitmap .Stf.gfad \ 

-file ${curtain.path}/images/glad.bmp \ 

-maskfile ${curtain_path}/images/face.msk \ 

—background yellow —foreground black 
image create bitmap ,$tf.sad \ 

—file ${curtain-path}/images/sad.bmp \ 

—maskfile ${curtain_path}/image3/face.msk \ 

—background red —foreground black 
canvas .$tf.c -width $maxx -height $maxy —bd 2 —relief sunken 
.$tf.c create text [expr ($maxx - $minx)/2| Sminy \ 

—text "Concept hits and misses" 
foreach concept Sconcepts { 
puts "CLIPS— get—student—concept Sconcept" 
fiush stdout 

#set curtain_list($concept) { — 1 11—1—1—11 —1 —1 —1 —1 —1 —1} 
tkwait variable curtain_list($concept) 


94 





370 


create text $minx $basey —text Sconcept —anchor sw 
set xleft $basex 

foreach mod $curtain_list($concept) { 
if {$mod > 0} { set face sad} else {set face glad} 

.$tf,c create image Sxfeft Sbasey —image .$tf.$face —anchor sw 
incr xleft Sdeftax 
} 

#set basey [expr Sbasey + Sdeftay] 
incr basey Sdeftay 
} 

pack .St^.c —expand yes —fill both —padx 2m —pady 2m 
button -Stf.bot.quit —text "Go Away" —command "destroy .$tf" 380 

pack .St^.bot.quit 

} 

# procedure to update the mastery level required for the student 
proc tcLchange.threshold {} { 
global curtain-threshold 

# create prompt for student solution 

toplevel .get-threshold 390 

wm title .get-threshold "Get Threshold" 
label .get-threshold.l —text \ 

"Please enter the number of correct responses required for mastery:" 
entry .get-threshold.e —relief sunken —textvariable curtain-threshold 
.get-threshold.e icursor 0 ;# pos insertion cursor at beginning 
.get-threshold.e selection range 0 end ;# highlight text 
pack .get-threshold.l .get-threshold.e —side left 
bind .get-threshold.e <Return> { destroy .get_threshold } 
focus .get-threshold.e 

tkwait window .get-threshold 400 

set threshold Scurtain-threshold 

# threshold is traced, so set curtain-threshold to valid threshold 
set curtain-threshold Sthreshofd 

if { Sthreshofd != "" } { 
puts "CLIPS— change—threshold Sthreshofd" 


95 







flush stdout 

} 

} 

# procedure to display a GIF flgure for the student 410 

proc tcl-display.pic {} { 

global curtain_remote curtain-local curtain_remote_display 
global curtain_path 

toplevel .stu-fig —screen $curtain_remote_display 
toplevel .instr.flg 
foreach tl {stu_fig instr.fig} { 
wm title .$t£ "Parellel Lines Diagram" 
wm iconname .$tf "Parallel" 

wm iconbitmap .$tf ®${curtain_path}/image8/paxallel.icon 

wm geom .$tf +0+0 420 

wm minsize .$t£ 680 520 

frame .Stf.bot 

pack .Stf.bot —side bottom —All both 

image create photo .Stf.cimage —format gif —file \ 

$ { curt ain.path } /images / parallel, gif 
canvas .$tf.c —width 691 —height 531 —bd 2 —relief sunken 
.$tf.c create image 10 10 —image .Stf.cimage —anchor nw 

pack .Stf.c —expand yes —fill both —padx 2m —pady 2m 430 

} 

button .stu_fig.bot.quit —text "Go Away" —command {destroy .stu_fig} 
pack .stu_fig.bot.quit 

button .instr_fig.bot.quit —text "Go Away" —command { 
destroy .instr_fig 
} 

pack .in8tr_fig.bot.quit 

} 

# procedure to display main selection menu for the instructor 440 

proc tcLmenu {} { 

global curtain_local curtain-locaLdisplay 


96 





global curtain-remote curtain_remote_display 
global curtain-student 

exec rsh —n $curtain-remote "setenv DISPLAY :0.0; \ 
xhost +$curtain-local" 
tcl-display-pic 
tcl-displayJnstr 

450 

# Send C function call to init CLIPS to stdout 

# (stdout is a pipe to Curtain) 
puts "C-InitClips Scurtain-student" 
flush stdout 

destroy .ok .c .e 

.1 configure —text "Select an action:" 
pack .1 —in .bottom 

menubutton .mbc —menu .mbc.m —text Commands 
menubutton .mbs —menu .mbs.m —text System 

menu .mbc.m 460 

menu .mbs.m 

.mbc.m add command —label "Display current student model" \ 

—command tcLdisplay.model 

.mbc.m add command —label "Change student mastery threshold" \ 

—command tcl.change.threshold 
.mbs.m add command —label "Save and quit" —command { 
puts "CLIPS—quit" 
flush stdout 
exit 

} 470 

.mbs.m add command —label Quit —command exit 
pack .mbs .mbc —in .top —side left 

button .gd —text "Display a definition to the student" \ 

—command {tcl.get-definition} 
button .dp —text "Define a geometry problem" \ 

—command {tcl.define.problem} 
button .ra —text "Relate two angles" —command tcl.relate 
button .ss —text "Suggest a solution" —command tcLsolution 
button .msg —text "Type a message to the student" —command \ 


97 







480 


tcl_type_me8sage 

pack .gd .dp .ra .ss .msg —in .bottom —fill x 
wm geom . —0+25 
} 

# procedure to display prompt for student's machine 
proc tcLget_remote {} { 
global curtain.remote 
global env 

set curtain.remote $env(HOST) 
wm geom . —0+28 490 

.1 configure —text \ 

"Please enter the machine the STUDENT will be working on: " 

.e configure —relief sunken —textvaxiable curtain-remote 

.e icursor 0 ;# position insertion cursor at beginning of entry 

.e selection range 0 end ;# highlight text for easy deletion/mod 

pack .top —side top —padx 3m —pady Im —fill x 

pack .bottom —side bottom —padx 3m —pady Im 

pack .1 .e —side top —in .top 

.ok configure —text OK —command { 

set curtain-local $env(HOST) 500 

set curtain-local-display $env(DISPLAY) 

if {Scurtain-remote == { set curtain-remote $curtain-local } 

set curtain_remote-display ${curtain-remote}:0 
tcLmenu 
} 

pack .ok .c —side left —in .bottom 
bind .e <Return> {focus .ok} 
focus .e 
} 

510 

# main portion of Tcl/Tk; ask for remote machine and call tcLmenu 
set curtain_mag 0 

set curtain-find 0 
set curtain-threshold 1 
array set curtain-list { 
congruent {0} 


98 







supplementary {0} 
vertical {0} 
corresponding {0} 

alternate—interior {0} 520 

adjacent {0} 

} 

set templist [array names env] 

if [expr — 1 < [Isearch —exact Stemp^ist CURTAIN-PATH]] { 
set curtain-path $env(CURTAIN_PATH)/TCL 
} else { 

if [expr —1 < [Isearch —exact Stempfist PWD]] { 
set curtain-path $env(PWD)/TCL 
} else {exit} 

} 530 


wm title . "Curtain ITS" 
wm iconname . "Curtain" 
wm geom . —10+0 
wm minsize . 1 1 

frame .top —relief sunken —borderwidth 4 
frame .bottom —relief sunken —borderwidth 6 
label .1 —text \ 

"Please enter a unique identifier for the STUDENT; " 
entry .e —relief sunken —textvariable curtain_student 540 

pack .top —side top —padx 3m —pady Im 
pack .bottom —side bottom —padx 3m —pady Im 
pack .1 .e —side top —in .top 
button .ok —text OK —command { 
if {$curtain_student != ""} tcLget-remote 
} 

button .c —text Cancel —command exit 
pack .ok .c —side left —in .bottom 
bind .e <Return> {focus .ok} 

focus .e 550 


99 




Bibliography 


1. Anderson, John R., et al. “Intelligent Tutoring Systems,” Science, 525:456-462 (1985). 

2. Beller, Sieghard and H. Ulrich Hoppe. “Deductive Error Reconstruction and Classifi¬ 
cation in a Logic Programming Framework.” Artificial Intelligence in Education, 1993, 
edited by Paul Brna, et al. 433 - 440. Association for the Advancement of Computing 
in Education (AACE), aug 1993. 

3. Burton, Richard R. and John Seely Brown. “An investigation of computer coaching 
for informal learning activities.” Intelligent Tutoring Systems, Computers and People, 
edited by D. Sleeman and J. S. Brown. 79-98. Harcourt Brace Jovanich, 1982. 

4. Carbonaro, A., et al. “Modelling the student in Pitagora 2.0,” User Modeling and 
User-Adapted Interaction, (4):233-251 (1995). 

5. de Barros Costa, Evandro, et al. “Mathema: A Learning Environment Based on 
a Multi-Agent Architecture.” Advances in Artificial Intelligence: Proceedings of the 
12*^ Brazilian Symposium on Aritificial Intelligence, edited by Jacques Wainer, et al. 
Springer-Verlag Berlin Heidelberg, October 1995. 

6. Dean, Thomas, et al. Artificial Intelligence Theory and Practice. The Ben¬ 
jamin/Cummings Publishing Company, Inc., 1995. 

7. Giangrandi, P. and C. Tasso. “Truth maintenance techniques for modelling student’s 
behaviour,” Journal of Artificial Intelligence in Education, 5(2-3):153-202 (1995). 

8. Hartley, J.R. and D.H. Sleeman. “Towards More Intelligent Teaching Systems,” In¬ 
ternational Journal of Man-Machine Studies, 5:215 - 236 (1973). 

9. Holt, Peter, et al. “The State of Student Modelling.” Student Modelling: The Key 
to Individualized Knowledge-Based Instruction 125. NATO Special Programme on Ad¬ 
vanced Educational Technology, edited by Jim E. Greer and Gordon 1. McCalla. 3-35. 
Springer-Verlag, 1994. 

10. Huang, X., et al. “Revising deductive knowledge and stereotypical knowledge in a 
student model,” User Modeling and User-Adapted Interaction, 1:87-115 (1991). 

11. Jr., Freeman A. Kilpatrick. A Generic Intelligent Architecture for Computer-Aided 
Training of Procedural Knowledge. PhD dissertation. Air Force Institute of Technology, 
1996. 

12. Kabrisky, Matthew. “The Promise of an Artificial Intelligence Future.” From IEEE 
meeting in Dayton, OH, 1983. 

13. Kambouri, M., et al. “Knowledge Assessment: tapping human expertise by the 
QUERY routine,” Int J. Humane Computer Studies, .^0:119-151 (1994). 

14. Leman, Stephane, et al. “A Multi-Agent Approach to Model Student Reasoning Pro¬ 
cess.” Proceedings of AI-ED 95 - 7*^ World Conference on Artificial Intelligence in 
Education, edited by Jim Greer. 258-265. Charlottesville, VA, USA: Association for 
the Advancement of Computing in Education, August 1995. 


100 






15. Marcenac, Pierre. “An authoring system for ITS which is based on a generic level of 
tutoring strategies.” 4*^ International Conference on Computers and Learning. 1992. 

16. McCormack, J. S. and J. E. Biegel. “A student model to acquire problem-solving 
strategies.” Proceedings of the Eighth Florida Artificial Intelligence Research Sympo¬ 
sium. FLAIRS-95, edited by J. H. Stewman. 16-20. St. Petersburg, FL , USA: Florida 
AI Res. Soc, April 1995. 

17. Nour, M., et al. “A proposed student model algorithm for an intelligent tutoring 
system.” SICE ’95. Proceedings of the 34*^ SICE Annual Conference.. 1327-1333. 
Soc. Instrum. & Control Eng, 1995. 

18. Ragnemalm, Eva L. “Student diagnosis in practice; bridging a gap,” User Modeling 
and User-Adapted Interaction^ 5(2):93-116 (1995). 

19. Shute, Valerie J. “SMART: Student modeling approach for responsive tutoring,” User 
Modeling and User-Adapted Interaction, 5(l):l-44 (1995). 

20. Shute, Valerie J. and Josepf Psotka. Intelligent Tutoring Systems: Past, Present, 
Future. Technical Report AL/HR-TP-1994-0005, USAF, Armstrong Laboratory, 1994. 

21. Villano, M. “Probabilistic Student Models: Bayesian belief networks and knowledge 
space theory.” Second International Conference Intelligent Tutoring Systems. 491-498. 
1992. 

22. Winston, Patrick Henry. Artificial Intelligence. Addison-Wesley Publishing Company, 
1992. 

23. Yazdani, Masoud. “Intelligent Tutoring Systems: An Overview.” Artificial Intelligence 
and Educationl, edited by Robert W. Lawler and Masoud Yazdani. 183 - 201. Ablex 
Publishing Corporation, 1987. 

24. Ziegler, U. M. “Use of a neural network to diagnose student errors in an intelligent 
tutoring system.” World Congress on Neural Netwroks-San Diego4. 459-464. Hillsdale, 
NJ, USA: Lawrence Erlbaum Associates, June 1994. 


101 


ThompsoniPIII^IIIIIIIIIIIIIIIIIIIIIIIIIIIIII^^ 

jjjjjjllllll^radvmcc-d from Lavinn High School, Lavina, Montana, in May 1984. Cp .June J8. 
IfiSf!, JereiTiy cnlistcri in the Ihs Air Forco. Upon graduation fiom Basic Military Training 
School, Jeremy wa*; sent to Lowry APB, Colorado, where he completeri Logistics Man¬ 
agement training and was stiilioned for bis first assignment as an Inventory Management 
Specialist at RAF Grecnham Common, United Kingdom, Wljile stationed at RAF Green- 
ham CoiTtmoii, .leremy was accepted into the Airman’s Education and Commissioning 
Program to complete Ills Bachelor of Science in Electrical Engineering at the University 
of Missouti-RoUa (UMR). Graduation from UMR led Jeremy to OSicer Tr aining School. 
Jeremy became Second Lieutenant Thompson on September 25,19!)1 and moved to Keesler 
AFEJ to complete Basic Communication-Computer OITicer Training (BCOT). 

UpO'i graduation from BCOT in March, 1992, Ll Thompson was assigned to USSTB.AT- 
COM at Offiitt APB, Ncbraika. His duties there included the hosting and testing of an 
advanced radar model developed by scientists at the Massachusetts Institute of Technol¬ 
ogy Lincoln Laboratory. In May 199r), Lt Thompson entered the Air Force Institute of 
Technology (AFIT) at Wright-Patterson APB, Ohio, to pursue a Master of Science degree 
with a concentration in Artificial Intelligence. Upon gradua,tion from AFIT in December 
1996, Captain Thompson was re-assigned to Air University, Maxwell APB, Alabama. 





REPORT DOCUMENTATION PAGE 


form Approved 
0MB No. 0704-0188 


X 


P'jDhc ’■eocT'^c burae'' 'O'" i.-ne-rticn of :n-^crmatton 'S esti'natec: '.c e./erage ‘ ■'•our DQr 'esocrse. ncioairg tne time ‘cr reviewing instruaicns. searcnirg existing aata sources, 

gathering ana rnamtaming the data needed, and corroieting anc revewing the tcHeaicn 3t inforTiaticn send comments regarding this burden estimate or anv dtner asoea of this 
collection O' inTr^.rmat'cn. ncli.ding suggestions 'or '■educing tr.s ouroer’. t'O //asnipgton -■'eadauarte'S Services, Directorate ror nformation Ooerations ana Peoorts, 12 ■ 5 >ehferson 
Oavis Highwav. Suite 12C4, Arlington. -/A 22202-4302, and to tne O^'^ice of Management ana Sud-je’’. °aoerwcrk Reduction Proiect (Q7C4-0'88), A’ashinaton. DC 20503 

1. AGENCY USE ONLY (Leave blank) 2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 

December 1996 Master’s Thesis 

4. TITLE AND SUBTITLE 

STUDENT MODELING IN AN INTELLIGENT TUTORING SYSTEM 

5. FUNDING NUMBERS 

6. AUTHOR{S) 

Capt Jeremy E. Thompson 

7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Air Force Institute of Technology 

2950 P Street 

WPAFB OH 45433-6583 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

AL/HRTI 

7907 Lindbergh Drive 

Brooks AFB TX 78235 

10. SPONSORING/MONITORING 

AGENCY REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited 

12b. DISTRIBUTION CODE 

13. ABSTRACT (Maximum 200 words) 

This thesis explores a new approach to modeling the student in an intelligent tutoring system (ITS), by providing 
a student model which learns new solutions from the student. A prototype of the new approach is demonstrated 
in the Euclidean geometry domain. Complete C-l—1-, CLIPS, and Tcl/Tk code listings are included in the 
appendices. Adaptable multiple software agents were targeted for implementation, based on current literature. 
However, the student model is found to be maintainable without multiple software agents, while still allowing for 
tracking several possible solution paths when monitoring student solutions, which contradicts previously reported 
research. The student model provides a learning module capable of recognizing new solutions provided by the 
student. These new solutions may then be included in the expert knowledge base. In addition to a learning 
student model, other concepts from the current ITS literature are explored and implemented. Mastery levels 
are implemented to aid in cognitive diagnosis. Symbolic knowledge, procedural skill, and conceptual knowledge, 
are explored and applied to the research. The student model prototype is both a pedagogic-content model and 
a subject-matter model. Additionally, a new division of labor between the student model and the instructor 
module in ITSs is described. 

14. SUBJECT TERMS 

student modeling, intelligent tutoring systems, artificial intelligence 

15. NUMBER OF PAGES 

112 

16. PRICE CODE 

17. SECURITY CLASSIFICATION 

OF REPORT 

UNCLASSIFIED 

18. SECURITY CLASSIFICATION 

OF THIS PAGE 

UNCLASSIFIED 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFIED 

20. LIMITATION OF ABSTRACT 

UL 


Standard Form 298 '8ev 2-S9 

!^resc'ce<3 Dv ''".a 


293--02 


NSM 7540-01-280-5500 





























