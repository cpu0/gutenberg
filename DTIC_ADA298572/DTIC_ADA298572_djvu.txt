m 


REPORT DOCUMENTATION PAGE 


Form Approved 


0MB No. 0704-0188 


Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing instructions, searching existing data 
sources, gathering and maintaining the data needed, and reviewing the collection of information. Send comments regading this burden, to Washington Headquarters Service, 
Directorate for Information Operations and Reports, 1215 Jefferson Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Information and Regulatory 
Affairs, Office of Management and Budget, Washington, DC 20503. 


1. AGENCY USE ONLY (Leave blank) 


2. REPORT DATE 

June 28, 1995 


3. REPORT TYPE AND DATES COVERED 

Final 


4. TITLE AND SUBTITLE: 

Ada Compiler Validation Summary Report, VC# 95062211.11394 
Tartan, Inc. -- Tartan Ada SPARC/68xxx, Version 5.1 


6. AUTHOR(S) 


5. FUNDING NUMBERS 


lABG, Abt. ITE 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Ada Validation Facility 

lABG, Abt. ITE 

Einsteinstrasse 20 

D-85521 Ottobrunn, GERMANY 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 
Ada Joint Program Office, Defense Information System Agency 
Code JEXEV, 701 S. Courthouse Rd., Arlington, VA 
22204-2199 

11. SUPPLEMENTARY NOTES 



8. PERFORMING ORGANIZATION 
REPORT NUMBER 

lABG-VSR 119 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 


19950905 009 


12a. DISTRIBUTION/AVAILABILITY STATEMENT 


I'iiO, UId I l\IDU I IVyiN 


Approved for public reiease; Distribution is unlimited. 


13. ABSTRACT (Maximum 200 words) 

This Ada implementation was tested and determined to pass ACVC 1.11. Testing was completed on 22 June 1995. 
Host Computer System: Sun SPARCstation 5 under SunOS, Release 4.1.4 
Target Computer System: Motorola MVME 134 (MC68020) (bare machine) 


14. SUBJECT TERMS 15. NUMBER OF PAGES 

Ada Programming Language, Ada Compiler Validation Summary Report, Ada Compiler 62 
Validation Capability, Validation Testing, Ada Validation Office, Ada Validation Facility, i6 PRICE 
ANSI/MIL-STD-1815A, Ada Joint Program Office 


OF REPORT 

UNCLASSIFIED 


18. SECURITY CLASSIFICATION 

19. SECURITY CLASSIFICATION 

OF THIS PAGE 

OF ABSTRACT 

UNCLASSIFIED 

UNCLASSIFIED 


UNCLASSIFIED 


NSN 7540-01-280-5500 


























AVF Control Number: lABG-VSR 119 
28 June, 1995 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: 95062211.11394 
Tartan, Inc. 

Tartan Ada SPARC/68xxx Version 5.1 
Sun SPARCsttation 5 => 
Motorola MVME164 (MC68020) 


Prepared By: 
lABG.Abt. ITE 
Einsteinstr, 20 
D-85521 Ottobrunn 
Germany 



Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 1.11. Testing was 
completed on 22 June, 1995. 

Compiler Name and Version: Tartan Ada SPARC/68xxx Version 5.1 

Host Computer System: Sun SPARCstation 5 under SunOS Release 4.1.4 

Target Computer System: Motorola MVME134 (MC68020) (bare machine) 


See section 3.1 for any additional information about the testing environment. 

As a result of this validation effort, Validation Certificate 95062211.11394 js awarded to Tartan, 
Inc. This certificate expires on 31 March 1998. 

This report has been reviewed and is approved. 



lABG, Abt. ITE 
Michael Tonndorf 
Einsteinstr. 20 
D-85521 Ottobrunn 
Germany 



Valj^tiofyOrg^ization 

DirectcyfCortBlitej;4 Software Engineering Division 
Institute for IDsferree Analyses 
Alexandria VA 22311, USA 



Center for Information Management 


Defense Information Systems Agency 


Don Reifer, Director 


Arlington VA 22204, USA 







Declaration of Conformance 


Customer: 

Tartan, Inc. 

Certificate Awardee: 

Tartan, Inc. 

Ada Validation Facility: 

lABG 

ACVC Version: 

l.Il 

Ada Implementation: 

Ada CompilerName and Version: 

Host Computer System: 

Target Computer System: 

Tartan Ada SPARC/68xxx Version 5.1 

SPARCstation 5 under SunOS Release 4.1.4 

Motorola MVME 134 (MC68020) (bare machine) 


Declaration: 

I, the undersigned, declare that I have no knowledge of deliberate deviations from the Ada 
Language Standard ANSI/MIL-STD-1815A ISO 8652-1987, FIPS 119 as tested in this 
validation and documented in the Validation Summary Report. 






TABLE OF CONTENTS 


CHAPTER 1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT. 1-1 

1.2 REFERENCES. 1-2 

1.3 ACVC TEST CLASSES . 1*2 

1.4 DEFINITION OF TERMS . 1-3 


CHAPTER 2 

2.1 WITHDRAWN TESTS . 

2.2 INAPPLICABLE TESTS 

2.3 TEST MODIFICATIONS 


CHAPTER 3 

3.1 TESTING ENVIRONMENT .... 

3.2 SUMMARY OF TEST RESULTS 

3.3 TEST EXECUTION . 


APPENDIX A MACRO PARAMETERS 
APPENDIX B COMPILATION SYSTEM OPTIONS 
APPENDIX C APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada Validation Procedures 
[Pro92] against the Ada Standard [Ada83] using the current Ada Compiler Validation Capability 
(ACVC). This Validation Summary Report (VSR) gives an account of the testing of this Ada 
implementation. For any technical terms used in this report, the reader is referred to [Pro92]. A 
detailed description of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada Certification Body may make 
full and free public disclosure of this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results of this validation apply only 
to the computers, operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not represent or warrant 
that all statements set forth in this report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161, USA 

Questions regarding this report or the validation test results should be directed to the AVF 
which performed this validation or to: 

Ada Validation Organization 
Computer and Software Engineering Division 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311-1772, USA 


1-1 




INTRODUCTION 


1.2 REFERENCES 

[Ada83] Rfiference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, Febmaty 1983 and ISO 8652-1987. 

[Pro92] Ada Compiler Validation Procedures . 

Version 3.1, Ada Joint Program Office, August 1992. 

[UG90] Ada Compiler Validation Capability User's Guide . 

3 April 1990. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC contains a 
collection of test programs structured into six test classes: A, B, C, D, E, and L. The first letter 
of a test name identifies the class to which it belongs. Class A, C, D, and E tests are executable. 
Class B and class L tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a PASSED, FAILED, or 
NOT APPLICABLE message indicating the result when they are executed. Three Ada library 
units, the packages REPORT and SPPRT13,and the procedure CHECK_FILE are used for this 
purpose. The package REPORT also provides a set of identity functions used to defeat some 
compiler optimizations allowed by the Ada Standard that would circumvent a test objective. The 
package SPPRT13 is used by many tests for Chapter 13 of the Ada Standard. The procedure 
CHECK_FiLE is used to check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECK_FILE is checked by 
a set of executable tests, if these units are not operating correctly, validation testing is 
discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B tests are not 
executable. Each test in this class is compiled and the resulting compilation listing is examined 
to verify that all violations of the Ada Standard are detected. Some of the class B tests contain 
legal Ada code which must not be flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects violation of the Ada Standard 
involving multiple, separately compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by implernentation-specific 
values " for example, the largest integer. A list of the values used for this implementation is 
provided in Appendix A. In addition to these anticipated test modifications, additional changes 
may be required to remove unforeseen conflicts between the tests arid 
implementation-dependent characteristics. The modifications required for this implementation 
are described in section 2.3. 


1-2 




INTRODUCTION 


For each Ada implementation, a customized test suite is produced by the AVF. This 
customization consists of making the modifications described in the preceding paragraph, 
removing withdrawn tests (see section 2.1), and possibly removing some inapplicable tests (see 
section 2.2 and [UG90]). 

In order to pass an ACVC an Ada implementation must process each test of the customized test 
suite according to the Ada Standard. 

1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 

to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 

Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary report. 

(ACVC) 

Ada An Ada compiler with its host computer system and its target 

Implementation computer system. 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 

Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organisation 

Compliance of The ability of the implementation to pass an ACVC version, 

an Ada 

Implementation 

Computer System A functional unit, consisting of one or more computers and 

associated software, that uses common storage for all or part 
of a program and also for all or part of the data necessary for 
the execution of the program; executes user-written or user- 
designated programs; performs user-designated data 
manipulation, including arithmetic operations and logic 
operations; and that can execute programs that modify 
themselves during execution. A computer system may be a 
stand-alone unit or may consist of several inter-connected 
units. 


1-3 




INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Fulfillment by a product, process or service of all requirements 
specified. 

An individual or corporate entity \who enters into an agreement 
with an AVF which specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity is 
realised or is attainable on the Ada implementation for which 
validation status is realised. 


A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Crganisation for Standardisation. 

The Ada standard, or Language Reference Manual, published 
as ANSI/MIL-STD-1815A-1983 and ISC 8652-1987. Citations 
from the LRM take the form 
“<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, operating 
systems are predominantly software, but partial or complete 
hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro92]. 

The process of checking the conformity of an Ada corripiler to 
the Ada programming language and of issuing a certificate for 
this implementation. 


1-4 




INTRODUCTION 


Withdrawn 

test 


A test found to be incorrect and not used in conformity testing. 
A test may be incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains erroneous or illegal 
use of the Ada programming language. 


1-5 





CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


The following 104 tests have been withdrawn by the AVO. The rationale for withdrawing each 
test is available from either the AVO or the AVF. The publication date for this list of withdrawn 
tests is November 22,1993. 


B27005A 

C35507L 

C35508M 

C43004A 

C45651A 

A74006A 

C83026A 

C97116A 

CC1223A 

BD1B08A 

CD2A41E 

CD4022D 

CD5111A 

AD7201A 

CD9005A 

CE2119B 

CE3411B 

CE3814A 


E28005C 

C35507N 

C35508N 

C45114A 

C46022A 

C74308A 

B83026B 

C98003B 

BC1226A 

BD2A02A 

CD2A87A 

CD4024B 

CD7004C 

AD7201E 

CD9005B 

CE2205B 

CE3412B 

CE3902B 


B28006C 

C35507O 

C35702A 

C45346A 

B49008A 

B83022B 

C83041A 

BA2011A 

CC1226B 

CD2A21E 

CD2B15C 

CD4024C 

ED7005D 

CD7204B 

CDA201E 

CE2405A 

CE3607B 


C32303A 

C35507P 

C35702B 

C45612A 

B49008B 

B83022H 

B85001L 

CB7001A 

BC3009B 

CD2A23E 

BD3006A 

CD4024D 

CD7005E 

AD7206A 

CE2107I 

CE3111C 

CE3607C 


C34006D 

C35508I 

C35310A 

C45612B 

A54B02A 

B83025B 

C86001F 

CB7001B 

BD1B02B 

CD2A32A 

BD4008A 

CD4031A 

AD7006A 

BD8002A 

CE2117A 

CE3116A 

CE3607D 


C35507K 

C35508J 

B41308B 

C45612C 

C55B06A 

B83025D 

C94021A 

CB7004A 

BD1B06A 

CD2A41A 

CD4022A 

CD4051D 

CD7006E 

BD8004C 

CE2117B 

CE3118A 

CE3812A 


2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant for a given Ada 
implementation. Reasons for a test's inapplicability may be supported by documents issued by 
the ISO and the AJPO known as Ada Commentaries and commonly referenced in the format 
Al-ddddd. For this implementation, the following tests were determined to be inapplicable for the 
reasons indicated; references to Ada Commentaries are included as appropriate. 




IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 


C24113L.Y(14 tests) 
C35706L.Y(14 tests) 
C35708L.Y(14 tests) 
C45241L.Y(14 tests) 
C45421L.Y(14 tests) 
C45524L.Z(15 tests) 
C45641L.Y(14 tests) 


C35705L.Y (14 tests) 
C35707L.Y (14 tests) 
C35802L.Z(15 tests) 
C45321L.Y(14 tests) 
C45521L.Z(15 tests) 
C45621L.Z(15 tests) 
C46012L.Z(15 tests) 


The following 20 tests check for the predefined type LONG_INTEGER; for this 
implementation, there is no such type: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35713B, C45423B, B86001T, and C86006H check for the predefined type 
SHORT_FLOAT; for this implementation, there is no such type. 


C35713D and B86001Z check for a predefined floating-point type with a name other 
than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this implementation, there is 
no such type. 

A35801E checks that FL0AT'F1RST..FL0AT'LAST may be used as a range constraint 
in a floating-point type declaration: for this implementation, that range exceeds 
the range of safe numbers of the largest predefined floating-point type and must be 
rejected. (See section 2.3.) 

C45531 M..P and C45532M..P (8 tests) check fixed-point operations for types hat require 
a SYSTEM.MAX_MANTISSA of 47 or greater; for this implementation, MAX_MANTISSA 
is less than 47. 


C45536A, 046013B, 046031B, C46033B, and C46034B coritain length clauses that 
specify values for 'SMALL that are not powers of two or ten; this implementation does not 
support such values for 'SMALL. 

C45624A..B (2 tests) check that the proper exception is raised if 

MACHlNE_OVERFLOWS is FALSE for floating point types and the results of various 
floating-point operations lie outside the range of the base type; for this implementation, 
MACHINE_OVERFLOWS is TRUE. 

B86001Y uses the name of a predefined fixed-point type other than type DUFIATION; for 
this implementation, there is no such type. 

CA2009A, CA2009C..D (2 tests), CA2009F and BC3009C instantiate generic units before 
their bodies are compiled; this implementation creates a dependence on generic units as 
allowed by AI-00408 & AI-00506 such that the compilation of the generic unit bodies 


2-2 




IMPLEMENTATION DEPENDENCIES 


makes the instantiating units obsolete, (see 2.3.) 

CD1009C checks whether a length clause can specify a non-default size for a 
floating-point type; this implementation does not support such sizes. 


CD2A53A checks operations of a fixed-point type for which a length cl .use specifies a 
power-of-ten TYPE'SMALL; this implementation does not support decimal ‘SMALLs. 
(See section 2.3.) 

CD2A84A, CD2A84E, CD2A841..J (2 tests), and CD2A840 use length clauses to ^ecify 
non-default sizes for access types; this implementation does not support such sizes. 

CD2B15B checks that STORAGE_ERROR is raised when the storage size specified for 
a collection is too small to hold a single value of the designated type; this implementation 
allocates more space than was specified by the length clause, as allowed by AI-00558. 

The following 264 tests check operations on sequential, text, and direct access files; 
this implementation does not support external files: 


CE2102A. 

CE2103C. 

CE2107A. 

CE2110A. 

CE2201A. 

CE2204A. 

CE2401A. 

CE2401H. 

CE2406A 

CE2410A. 

CE3102J. 

CE3107B 

CE3111A. 

CE3115A 

CE3207A 

CE3302A 

CE3402A 

CE3403E. 

CE3405C. 

CE3409A 

CE3410C. 

CE3412A 

CE3602A. 

CE3606A. 

CE3706D 

CE3806A, 

CE3905A, 


C(3) 
•D(2) 
H(8) 
D(4) 
C(3) 
D(4) 
•C (3) 
■L (5) 

•B (2) 
K (2) 

.B(2) 


•F(2) 
•D (2) 

,.E (3) 

•D (4) 
•B (2) 

,.B (2) 
,.C (3) 


CE2102G..H(2) 

CE2102K 

- CE2102N..Y(12) 

CE2104A..D(4) 

CE2105A..B (2) 

CE2106A..B(2) 

CE2107L 

CE2108A..H (8) 

CE2109A..C (3) 

CE2111A..I (9) 

CE2115A..B(2) 

CE2120A..B (2) 

EE2201D..E(2) 

CE2201F..N(9) 

CE2203A 

CE2205A 

CE2206A 

CE2208B 

EE2401D 

CE2401E..F(2) 

EE2401G 

CE2403A 

CE2404A..B (2) 

CE2405B 

CE2407A..B (2) 

CE2408A..B (2) 

CE2409A..B (2) 

CE2411A 

CE3102A..C (3) 

CE3102F..H (3) 

CE3103A 

CE3104A..C (3) 

CE3106A..B (2) 

CE3108A..B(2) 

CE3109A 

CE3110A 

CE3111D..E(2) 

CE3112A..D(4) 

CE3114A..B (2) 

CE3119A 

EE3203A 

EE3204A 

CE3208A 

CE3301A 

EE3301B 

CE3304A 

CE3305A 

CE3401A 

EE3402B 

CE3402C..D (2) 

CE3403A..C (3) 

CE3404B..D (3) 

CE3405A 

EE3405B 

CE3406A..D (4) 

CE3407A..C (3) 

CE3408A..C (3) 

CE3409C..E (3) 

EE3409F 

CE3410A 

EE3410F 

CE3411A 

CE3411C 

EE3412C 

CE3413A..C (3) 

CE3414A 

CE3603A 

CE3604A..B (2) 

CE3605A..E (5) • 

CE3704A..F (6) 

CE3704M..O (3) 

CE3705A..E (5) 

CE3706F..G (2) 

CE3804A..P (16) 

CE3805A..B (2) 

CE3806D..E (2) 

CE3806G..H (2) 

CE3904A..B (2) 

CE3905L 

CE3906A..C (3) 

CE3906E..F (2) 

and CE3107A use an 

illegal file name in 

an attempt to create a 


file and expect NAME_ERROR to be raised; this implementation does not support 
external files and so raises USE_ERROR. (See section 2.3.) 


2-3 





IMPLEMENTATION DEPENDENCIES 


2.3 TEST MODIFICATIONS 


Modifications (see Section 1.3) were required for 112 tests. 

The foilowing 81 tests were split into two or more tests because this implementation did 
not report the violations of the Ada Standard in the way expected by the original tests. 


B22003A 

B33205A 

B37201A 

B38008A 

B38103C 

B48002B 

B49005A 

B4A010C 

B59001C 

B67001D 

B85008G 

B95031A 

BC1206A 

BD4003A 


B24007A 

B35701A 

B37202A 

B38008B 

B38103D 

B48002D 

B490&6A 

B54A20A 

B59001I 

B74103E 

B85008H 

B95074E 

BC2001E 

BD4006A 


B24009A 

B36171A 

B37203A 

B38009A 

B38103E 

B48002E 

B49006B 

B54A25A 

B62006C 

B74104A 

B91004A 

BA1001A 

BC3005B 

BD8003A 


B25002B 

B36201A 

B37302A 

B38009B 

B43202C 

B48002G 

B49007A 

B58002A 

B67001A 

B74307B 

B91005A 

BC1002A 

BD2A06A 


B32201A 

B37101A 

B38003A 

B38103A 

B44002A 

B48003E 

B49007B 

B58002B 

B67001B 

B83E01A 

B95003A- 

BC1109A 

BD2B03A 


B33204A 

B37102A 

B38003B 

B38103B 

B48002A 

B49003A 

B49009A 

B59001A 

B67001C 

B85007C 

B95007B 

BC1109C 

BD2D03A 


E28002B was graded passed by Evaluation and Test Modification as directed by the 
AVO. This test checks that pragmas may have unresolvable arguments, and it includes 
a check that pragma LIST has the required effect; but, for this implementation, pragma 
LIST has no effect if the compilation results in errors or warnings, which is the case when 
the test is processed without modification. This test was also processed with the 
pragmas at lines 46, 58, 70 and 71 commented out so that pragma LIST had effect. 

A35801E was graded inapplicable by Evaluation Modification as directed by the AVO. 
The compiler rejects the use of the range FLOAT‘FIRST..FLOAT'LAST as the range 
constraint of a floating-point type declaration because the bounds lie outside of the range 
of safe numbers (cf. LRM 3.5.7:12). 

Tests C45524A..K (11 tests) were graded passed by Test Modification as directed by the 
AVO. These tests expect that a repeated division will result in zero; but the Ada standard 
only requires that the result lie in the smallest safe interval. Thus, the tests were modified 
to check that the result was within the smaliest safe interval by adding the following code 
after line 141; the modified tests were passed: 


ELSIF VAL <= FSAFE_SMALL 

THEN COMMENT ("UNDERFLOW SEEMS GRADUAL”); 


C83030C and C86007A were graded passed by Test Modification as directed by the 
AVO. These tests were modified by inserting “PRAGMA ELABORATE (REPORT);" 
before the package declarations at lines 13 and 11, respectively. Without the pragma, the 
packages may be elaborated prior to package report's body, and thus the packages calls 


2-4 




IMPLEMENTATION DEPENDENCIES 

to function Report.Ident_lnt at lines 14 and 13, respectively, will raise 
PROGRAM_ERROR. 

B83E01B was graded passed by Evaluation Modification as directed by the AVO. This 
test checks that a generic subprogram’s formal parameter names (i.e. both generic and 
subpiogram formal parameter names) must be distinct; the duplicated names within the 
generic declarations are marked as errors, whereas their recurrences in the subprogram 
bodies are marked as “optional" errors-except for the case at line 122, which is marked 
as an error. This implementation does not additionally flag the errors in the bodies and 
thus the expected error at line 122 is not flagged. The AVO ruled that the 
implementation's behavior was acceptable and that the test need not be split (such a split 
would simply duplicate the case in B83E01A at line 15). 

CA2009A, CA2009C..D (2 tests), CA2009F and BC3009C were graded inapplicable by 
Evaluation Modification as directed by the AVO. These tests instantiate generic units 
before those units' bodies are compiled; this implementation creates dependences as 
allowed by AI-00408 & AI-00506 such that the compilation of the generic unit bodies 
makes the instantiating units obsolete, and the objectives of these tests cannot be met. 

BC3204C and BC3205D were graded passed by Processing Modification as directed by 
the AVO. These tests check that instantiations of generic units with unconstrained types 
as generic actual parameters are illegal if the generic bodies contain uses of the types 
that require a constraint. However, the generic bodies are compiled after the units that 
contain the instantiations, and this implementation creates a dependence of the 
instantiating units on the generic units as allowed by AI-00408 & AI-00506 such that the 
compilation of the generic bodies makes the instantiating units obsolete-no errors are 
detected. The processing of these tests was modified by compiling the separate files in 
the following order (to allow re-compilation of obsolete units), and all intended errors were 
then detected by the compiler; 

BC3204C: CO, Cl, C2, C3M, C4, C5, C6, C3M 

BC3205D: DO, D1M, D2, D1M 

BC3204D and BC3205C were graded passed by Test Modification as directed by the 
AVO. These tests are similar to BC3204C and BC3205D above, except that all 
compilation units are contained in a single compilation. For these two tests, a copy of the 
main procedure (which later units make obsolete) was appended to the tests; all 
expected errors were then detected. 

CD2A53A was graded inapplicable by Evaluation Modification as directed by the AVO. 
The test contains a specification of a power-of-ten value assmall for a fixed-point type. 
The AVO ruled that, under ACVC 1.11, support of decimal smalls may be omitted. 

AD9001B and AD9004A were graded passed by Processing Modification as directed by 
the AVO. These tests check that various subprograms may be interfaced to external 
routines (and hence have no Ada bodies). This implementation requires that a file 
specification exists for the foreign subprogram bodies. The following command was 
issued to the Librarian to inform it that the foreign bodies will be supplied at link time (as 


2-5 




IMPLEMENTATION DEPENDENCIES 

the bodies are not actually needed by the program, this command alone is sufficient): 

interface -sys -L=library ad9001b & ad9004a 

CE2103A, CE2103B, and CE3107A were graded inapplicable by Evaluation Modification 
as directed by the AVO. The tests abort with an unhandled exception when 
USE_ERROR is raised on the attempt to create an external file. This is acceptable 
behavior because this implementation does not support external files (cf. AI-00332). 


2-6 




CHAPTER 3 

PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described adequately by the information 
given in the initial pages of this report. 

For technical information about this Ada implementation, contact; 

Mr Wayne Lieberman 
Ada Business Unit Leader 
Tartan Inc. 

300 Oxford Drive 
Monroeville, PA 15146, USA 
Tel. (412) 856-3600 

For sales information about this Ada implementation, contact: 

Mr. Keith Franz 
Vice President Sales 
Tartan, Inc. 

300 Oxford Drive 
Monroeville, PA 15146, USA 
Tel. (412) 856-3600 

Testing of this Ada implementation was conducted at the customer’s site by a validation team 
from the AVF. 


3-1 




PROCESSING INFORMATION 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test of the customized 
test suite in accordance with the Ada Programming Language Standard, whether the test is 
applicable or inapplicable; otherwise, the Ada Implementation fails the ACVC [Pro92]. 

For all processed tests (inapplicable and applicable), a result was obtained that conforms to the 
Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various categories. All tests were 
processed, except those that were withdrawn because of test errors (item b, see section 2.1), 
those that require a floating-point precision that exceeds the implementation's maximum 
precision (item e; see section 2.2), and those that depend on the support of a file system - if 
none is supported (item d). All tests passed, except those that are listed in sections 2.1 and 2.2 
(counted in items b and f, below). 


Summary of Test Counts 

a 

Total Number of Applicable Tests 

3542 

D 

Total Number of Withdrawn Tests 

104 


Processed Inapplicable Tests 

59 

d 

Non-Processed I/O Tests 

264 

e 

Non Processed Floating Point Precision Tests 

201 

f 

Total Number of Inapplicable Tests (c-i-d+e) 

524 

9 

--- 

Total Number of Tests for ACVC 1.11 (a+b+f) 

4170 


3.3 TEST EXECUTION 

A magnetic data cartridge containing the customized test suite (see section 1.3) was taken 
on-site by the validation team for processing. The contents of the magnetic data cartridge were 
loaded on a computer with an attached tape drive and copied directly onto the host computer 
using networking facilities. 

The tests were compiled and linked on the host computer system, as appropriate. The 
executable images were transferred to the target computer system by the communications link, 
an ethernet interface, and run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the customer and reviewed by the 
validation team. See Appendix B for a complete listing of the processing options for this 


3-2 


















PROCESSING INFORMATION 


implementation. It also indicates the default options. The options invoked explicitly for validation 
testing during this test were for compiling: 

-f forces the compiler to accept an attempt to compile a unit imported from 
another library which is normally prohibited. 

-c suppresses the creation of a registered copy of the source code in the 
library directory for use by the REMAKE and MAKE subcommands. 

-La forces a listing to be produced, default is to only produce a listing when an 
error occurs 

For this validation the default optimization level -Op2 was used. No explicit Linker options were 
set. 

Test output, compiler and linker listings, and job legs were captured on magnetic data cartridge 
and archived at the AVF. The listings examined on-site by the validation team were also 
archived. 


3-3 




APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. The meaning and 
purpose of these parameters are explained in [UG90]. The parameter values are presented in 
two tables. The first table lists the values that are defined in terms of the maximum input-line 
length, which is the value for $MAXJN_LEN - also listed here. These values are expressed 
here as Ada string aggregates, where 

Macro Parameter _Macro Value_ 


$MAX_IN_LEN 

$BIGJD1 

$BIG_ID2 

$BIG_ID3 

$BIG_ID4 

$BIGJNT_LIT 

$BIG_REAL_LiT 

$BIG_STRING1 

$BIG_STRING2 

$BLANKS 


240 

{1..V-1 =>'A', V=>'1') 

(1..V-1 => 'A‘, V=>'2') 

(1 ..V/2 => 'A') & '3' & (1 ..V-1-V/2 => 'A') 
(1 ..V/2 => ’A') & ’4' & (1 ..V-1-V/2 
(1..V-3=>'0') &"298" 

{1..V-5=>’O') & “690.0" 

"" & (1 ..V/2 => 'A') & 

""&(1..V-1-V/2=> 'A')&'1'&"" 
{1..V-20 =>") 


$l LLEG AL_EXTERNAL_FI LE_N AM E1 

“ILLEGAL_EXTERNAL_FILE_NAME1" & (1 ..V => 

$l LLEGAL_EXTERNAL_FI LE_N AM E2 

"ILLEGAL_EXTERNAL_FILE_NAME2" & (1..V => 

$MAX_LENJNT_BASED_LITERAL "2:" & (1 ..V-5 => '0') & "11 

$MAX_LEN_REAL_BASED_LITERAL 

"16:“&(1..V-7=>'0’)&"F.E:" 


$MAX_STRING_LITERAL 


■" & (1 ..V-2 =>’A') & "" 


A-1 




MACRO PARAMETERS 


The following table lists all of the other macro parameters and their respective values. 
Macro Parameter_Macro Value_ 


$ACC_SIZE 

$ALIGNMENT 

$COUNT_LAST 

$DEFAULT_MEM_SIZE 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAM E 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FlELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

$GREATER_THAN_DURATION 


32 

4 

2_147_483_646 

1_000_000 

8 

MC68020 

2#1.0#E-31 

SYSTEM.ADDRESS'(16#F0#) 

SYSTEM .ADDRESS'( 16#F1 #) 

SYSTEM. ADDRESS‘(16#F2#) 

240 

I I 

NO_SUCH_FIXED_TYPE 

NO_SUCH_FLOAT_TYPE 

till 

"CAN NOT_RESTRICT_FI LE_CAPACITY" 
100_000.0 


$GREATER_THAN_DURATION_BASE_LAST 

100_000_000.0 

$G REATER_THAN_FLOAT_BASE_LAST 

3.5E+38 




MACRO PARAMETERS 


$GREATER_THAN_FLOAT_SAFE_LARGE 

1.0E+38 


$GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

1.0E+38 


$HIGH_PRIORlTY 

$INAPPROPRIATE_LlNE_LENGTH 

$INAPPROPRIATE_PAGE_LENGTH 

$INCLUDE_PRAGMA 

$INCLUDE_PRAGMA2 

$INTEGER_FIRST 

$INTEGER_LAST 

$INTEGER_LAST_PLUS_1 

$INTERFACE_LANGUAGE 

$LESS_THAN_DURATION 


200 

-1 

-1 

PRAGMA INCLUDE ("A28006D1.TST") 

PRAGMA INCLUDE ("B28006F1 .TST') 

-2147483648 

2147483647 

2147483648 

C 

-100 000.0 


$LESS_THAN_DURATION_BASE_FIRST 

-100 000 000.0 


$LINE_TERMINATOR 

$L0W_PR10RITY 

$MACHINE_CODE_STATEMENT 

$MACHINE_CODE_TYPE 

$MANTISSA_DOC 

$MAX_DIGITS 

$MAX_INT 

$MAX_INT_PLUS_1 

$MINJNT 

$NAME 


10 

Two_Opnds’(MOVE_L,(lmm,2),(DR,d7)): 

ADDRESS_MODE 

31 

15 

2147483647 

2147483648 

-2147483648 

BYTEJNTEGER 




MACRO PARAMETERS 


$NAME_LIST 

$NEG_BASEDJNT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 


$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

STICK 

$VARIABLE_ADDRESS 

$VAR1ABLE_ADDRESS1 

$VARIABLE_ADDRESS2 


MC68020 

8#777777777776# 

1_000_000 

8 

MC68020 


record 

Operation: lnstruction_Mnemonic: 
Operand_1: Operand; 

Operand_2: Operand; 
end record; 

ONE_OPNDS 

96 

4096 

0.01 

SYSTEM. ADDRESS'(16#1 FF9C#) 
SYSTEM.ADDRESS'(16#1 FFAO#) 
SYSTEM .ADDRESS’{16#1 FFA4#) 





APPENDIX B 

COMPILATION AND LINKER SYSTEM OPTIONS 


The compiler and linker options of this Ada implementation, as described in this Appendix, are 
provided by the customer. Unless specifically noted otherwise, references in this appendix are 
to compiler documentation and not to this report. 


B-1 




USING THE TARTAN ADA COMPILER 


3.2. UNIX COMMAND UNE OPTIONS 

Command line options indicate special actions to be performed by the compiler or special output file 
properties. 

The following UNIX command line options may be specified: 

9x Notifies the compiler that the source file to be compiled contains Ada 9X con¬ 

structs. The option no9x (Ada 83) is the default 

A Generates an assembly code file with interleaved source code. The assenibly code 

file has an extension . s for a body or . ss for a specification. The assembly code 
file is not intended to be input to an assembler, but serves as documentation only. 

a Generates an assembly code file. The assembly code file has an extension . s for 

a body or . s s for a specification (sec. 3.5). The assembly code file is not 
intended to be input to an assembler, but serves as documentation only. In the 
default mode, no assembly code is generated. 

Ba Specifies that the compiler will produce an optimization (. opt) file which con¬ 

tains special optimization information, when the unit being compiled is a body. 
When another unit is compiled which refers to this unit in its context clause, a 
dependency may be created on this unit’s body (in addition to the specification) 
due to the utilization of this optimization information. Also, the compiler will try 
to utilize optimization information from the optimization files of umts named in 
the context clause of the current unit. Dependencies will be created on both the 
specification and the body (if any) of the units from which optimization mfor- 
mation is utilized. This option will allow maximum optimization at the expense 
of increased recompilations when changes are made. 

By default, the compiler will not produce an optimization file for the current umt 
(effectively preventing the creation of dependencies on this body), but will read 
the . opt files of units in the current unit’s compilation closure to obtain infor¬ 
mation which may be used to improve the optimizations performed on the current 
unit. 

Specifies that the compiler will neither produce an optimization (. opt) file when 
the unit being compiled is a body (effectively preventing the creation of depen¬ 
dencies on this body), nor will the compiler attempt to utilize optimization infor¬ 
mation from units named in the context clause of the current umt (preventing the 
possibility of creating a dependency on another body). When compiling an entire 
system, this strategy will lead to minim al dependencies between the compilation 
units in the system. 

By default, the compiler will not produce an optimization file for the current umt, 
but will read the . opt files of units in the current unit’s compilation closure to 
obtain information which may be used to improve the optimizations performed on 
the current unit. 

Controls whether the compiler generates 16-bit instead of 32-bit PC relative ad¬ 
dress modes when addressing objects whose distance from the current location 
carmot be determined at compile time. By using this option, the user asserts that 
the program space for the final program will be small enough for all calls to use 
the 16-bit PC-relative address modes in call instructions. If this assertion is 
incorrect, erroneous code could result. 

Normally, the compiler creates a registered copy of the user’s source code in the 


Bm 


Cs 




COMPE.ATION SYSTEM MANUAL 


library directory for use with the librarian remake^ subcommand. This option 
suppresses the creation of this copy. If this option is specified, it is very important 
to provide AdaScope with the directories in which the source files reside. See the 
section “Locating Source Files’ ’ in the AdaScope ManuaL 

d When compiling a library unit, determines whether the unit is a refinement of its 

previous version and, if so, do not make dependent units obsolete. This check is 
not done by default. A warning message is given if the unit is not a refinement of 
its previous version. The no update option^ can be used in conjunction with this 
option to check for possible refinements without risking a change to the program 
library. 

Stops compilation and produces a listing after n errors are encountered, where n is 
an integer in the range (\.255. The default value for n is 255. 

f Forces the compiler to accept an attempt to compile a unit imported fi:om another 

library, which is normally prohibited. 

g Produces debugging information for AdaScope, the Tartan Ada symbolic debug¬ 

ger. It is not necessary for all object modules to include debugging information to 
obtain a linkable image, but use of this option is encouraged for all compilations. 
No execution-time penalty is incurred with this option. 

i Causes the compiler to omit data segments with the text of enumeration literals. 

This text is normally produced for exported enumeration types to support the text 
attributes (' IMAGE, 'VALUE and 'WIDTH). You should use this option only 
when you can guarantee that no unit that will import the enumeration type will use 
any of its text attributes. However, if you are compiling a unit with an enumera¬ 
tion type that is not visible to other compilation units, this option is not needed. 
The compiler can recognize when the text attributes are not used and will not 
generate the supporting strings. 

K Causes the compiler options specified for this compilation unit to be saved in the 

program library. These options will be used when a subsequent (re)make com¬ 
mand is issued on this unit, unless overridden by compiler options specified on the 
(re)make command line (sec. 1(>.2.5). 

L= [project: ]library Selects the library and optionally the project for this compilation. This option 
takes effect after all commands firom the librarian initialization file^ have been 
executed, thereby possibly oveniding its effects. 

La Always generates a listing. The default is to generate a listing only if a diagnostic 

message is issued. 

ll=/z Specifies the number of lines printed on a page of the listing file, where n is an 

integer in the range 6..9999. The default value for n is 60. 

Ln Never generates a listing. The default is to generate a Listing only if a diagnostic 

message is issued. 

lw=n Specifies the line width used in a listing, where « is an integer in the range 


hjNJX: remakecu 
^UNIX: -n 
^UNK: .adalibrc 


3-4 


V3.1 




USING THE TARTAN ADA COMPILER 


80.. 132. The default value for n is 80.^ 

m=argument Controls the type of messages that will be generated ihe compiler. 

The following arguments can be specified: 

e Reports only errors. 

i Reports errors, warnings, and informational messages. 

The default condition, for which there is no option, is to report errors and warn¬ 
ings. 

Me When package MACHINE_CODE is used, controls whether the compiler attempts 

to alter operand address modes when those address modes are used incorrectly. 
With this option, the compiler does not attempt to fix any machine code insertion 
that has incorrect address modes. An error message is issued for any incorrect 
machine code insertion. By default, when neither Me or Mw is specified, the 
compiler attempts to generate extra instracdons to fix incorrect address modes in 
the array aggregates operand field, 

Mw The compiler attempts to generate extra instructions to fix incorrect address 

modes. A warning message is issued if such a, fixup is required. By default, when 
neither Me or Mw is specified, the compiler attempts to generate extra instructions 
to fix incorrect address modes in the array aggregates operand field. 

n Specifies that the program library will not be updated with the result of this 

compilation. 

no9x Notifies the compiler that the source file to be compiled contains Ada 83 con¬ 

structs. This is the default. 

Oprt Controls the level of optimization performed by the compiler, where n is an 

integer m the range 0..4. However, when the code being compiled contains an 
OPTIMIZE pragma, the pragma takes precedence over the specification of this 
c omm and line option. 

The following optimization levels can be specified: 

n-0 minimum —Perfonns context determination, constant folding, al¬ 

gebraic manipulation, and short circuit analysis. Pragma 
INLINEs are not obeyed. 

n = 1 low —Performs minimum optimizations plus evaluation order 

determination as well as co mm on subexpression elimination and 
equivalence propagation within basic blocks. Again, pragma 
INLINEs are nor obeyed. 

n = 2 standard (default)—Best tradeoff for space/time. Performs low 
optimizations plus flow analysis for common subexpression 
elimination and equivalence propagation across basic blocks, in¬ 
variant hoisting, dead code elimination, assignment killing, 
strength reduction, lifetime analysis for improved register alloca¬ 
tion, tail recursion elimination, interprocedural side-effect 
analysis and some inline expansion. 


^Note that \0 fewer characters than the user specifies on the command line will actually appear on a line in the listing file due to the left 
and right margins and the line numbers. 


v5.1 


3-5 



COMPILATION SYSTEM MANUAL 


/I = 3 time —Performs standard optimizations plus loop unrolling and 

aggressive inline expansion. This optimization level usually 
produces the fastest code; however, optiroization level standard 
may produce faster code under certain circumstances. 

n = 4 5 p( 2 c^^Performs standard optimizations minus any optimiza¬ 
tion that may increase code size. This optimization level usually 
produces the smallest code, however, optimization level 
standard may produce snialler code under certain ciicurnstances. 

p Loads a syntactically correct compilation unit(s) from the source file into the 

program library as a parsed unit(s). Parsed units are, by definition, inconsistent 
This option allows you to load units into the library without regard to correct 
compilation order. The librarian remake subcommand^ is subsequently used to 
compile the units in the correct sequence (sec. 10.2.5.2). 

pr Produces the additional code and data necessary to perfonn profile analysis (see 

AdaTrak Manual), 

REMOTE host Specifies the name of the remote host machine on which the compiler will be 

invoked to perform the current compUation. Section 2.6.4.2 describes the use of 
this option to perform distributed compilation. 

s Examines units for syntax errors, then stops compilation. No semantic checking 

is performed. Nothing is entered in the program library. No library need be 
specified when using this option. 

S [ ACDEILORS Z ] Suppresses the given set of checks: 

A ACCESS^CHECK 

C CONSTRAINT_CHECK 

D DISCRIMINANT_CHECK 

E. ELABORATION_CHECK 

I INDEX_CHECK 

L LENGTH_CHECK 

0 OVERFLOW_CHECK 

R RANGE_CHECK 

S STORAGE_CHECK 

Z "ZERO” DIVISION_CHECK 

The S option has the same effect as an equivalent pragma SUPPRESS applied to 
the source file. If the source program also contains a pragma SUPPRESS, a given 
check is suppressed if either the pragma or the option specifies it; i.e., the effect of 
a pragma SUPPRESS cannot be negated with the command line option. See LRM 
11.7 for further details. Supplying the S option can significantly decrease the size 
and execution time of the compiled code. Examples are: 

SOZ 0VERFL0W_CHECK and “ZERO” DIVISION_CHECK are sup¬ 

pressed. 

S Suppresses all checks. Invoking this option wiU not remove all 

checks if the resulting code without chec^ will be less efficient 

SC Suppresses CONSTRAINT_CHECK, equivalent to SADILR. 

t g t ^processor Specifies the Motorola target processor. 





USING THE TARTAN ADA COMPILER 


The following processors can be specified: 

me 6 8 0 2 0 for all supported boards using the MC6S 20 processor 
me 6 8 0 3 0 for all supported boards using the MC68030 processor 
me 680 40 for all supported boards using the MC68040 processor 
epu32 for all supported boards using the CPU32 processor 

Compilations for a 68xxx processor take place in a specific development environ¬ 
ment called a universe. Tartan supplies three universes for the 68xxx product: 

• 68020/68030 

• 68040 

• CPU32 

When using the librarian (re)make subcommand, the librarian sets the compiler 
target option to me68 020 for the 68020/68030 universe. To override the default 
setting for 68030 specific compilations, you must specify me68030 as an ar¬ 
gument to the (re)make command line option -q "-tgt-mc68030" (sec. 
10.3.27). 

V Display compiler phase names to standard output The compiler displays a short 

description as it progresses through each phase of compilation. 

X Includes cross reference information in the object code file (see AdaRef Manual). 

Note: On UNIX, the output firom the compiler may be redirected using the UNIX redirection facility 
including ‘ & ’ for stderr; for example: 

tadaprocessor tax_spec.ada >& tax__spec.txt 


V5.1 


3-7 




APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation-dependent 
pragmas, to certain machine-dependent conventions as mentioned in Chapter 13 of the Ada 
Standard, and to certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted otherwise, references in this 
Appendix are to compiler documentation and not to this report. Implementation-specific portions 
of the package STANDARD, are outlined below for convenience. 


package STANDARD is 

type BYTE_INTEGER is range -128 .. 127; 

type SHORTJNTEGER is range -32768 .. 32767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 range -16#0.FFF_FFF#E-i-32 .. 

..16#0.FFF_FFF#E+32; 

type LONG FLOAT is digits 15 range -16#0.FFFF_FFFF_FFFF_F8#E+256 

..16#0.FFFF_FFFF_FFFF_F8#E+256; 

type DURATION is delta 0.0001 range -86400.0 .. 86400.0; 

end STANDARD; 


C-1 





APPENDIX F OF THE Ada STANDARD 


APPENDIX F OF MIL-STD-1815A 


This chapter contains the required Appendix F to the LRM, which is Military 
Standard, Ada Programming Language, ANSI/MIL-STD-ISISA. 

4.1. PRAGMAS 

4.1.1. Predefined Pragmas 

The Tartan Ada Compiler supports all of the predefined pragmas described in 
the LRM, Annex B. 

- pragma CONTROLLED (sec. 4.1.1.1) 

- pragma ELABORATE 

- pragma INLINE (sec. 4,1.1.2) 

- pragma INTERFACE (sec. 4.1.1.3) 

- pragma LIST 

- pragma MEMORY„SIZE (sec. 4.1.1.4) 

- pragma OPTIMIZE (sec. 4.1.1.5) 

- pragma PACK (sec. 4.4.6) 
pragma PAGE 

- pragma PRIORITY 

- pragma SHARED (sec. 4.1.1.6) 

- pragma STORAGE_UNIT (sec. 4.1.1.4) 

- pragma SUPPRESS 

~ pragma SYSTEM_NAME (sec. 4.1.1.4) 

The following sections summarize the effects of and restrictions on certain 
predefined pragmas. 

4.1.1.1. Pragma CONTROLLED 

Access collections are not subject to automatic storage reclamation so pragma 
CONTROLLED has no effect. Space deallocated by^ means of 

Unchecked_Deallocation will be reused by the allocation of new objects. 

4.1.1.2. Pragma INLINE 

Pragma INLINE is supported as described in the LRM 6.3.2, with the following 
restrictions and clarifications: 

- The body of the subprogram to be expanded inline must be compiled before 
the unit that calls the subprogram. If the call is compiled prior to the 
subprogram body, inline expansion of that call will not be performed. A 
warning is issued when a call is not inlined because the body has not 
been compiled. 

- If a unit contains a call that results in inlined code, any subsequent 
recompilation of the body of the called subprogram will make the unit 
containing the inlined call obsolete. 

- When inlining across libraries, the body of the subprogram to be inlined 
must be exported from a frozen root library (sec. 10.3.15 and 10.3.19) . 


C-2 




APPENDIX F OF THE Ada STANDARD 

- The optimization level, as set by the compiler command line option or an 
OPTIMIZE pragma, determines whether an attempt is made to obey a pragma 
INLINE (sec. 8.2). If the compilation containing a call to the 
subprogram named in an INLINE pragma is compiled at the minimum or low 
optimization level, (UNIX: -OpO or ^Opl; VMS: /optimize=minimum or 
/optimize=:low) inlining will not be attempted for that call. 

” Inlining may not be performed if the compiler determines that the 
subprogram to be inlined is too complex. Typical examples are 

subprograms that recursively call themselves, or whose objects are 
referenced by enclosing subprograms. 

4.1.1.3. Pragma INTERFACE 

Pragma INTERFACE is supported as described in LRM 13.9. 

The syntax of the pragma is: 

pragma INTERFACE(language_name, subprogram_name); 

The pragma is placed just after the subprogram declaration and will be applied 
to all subprograms declared thus far with the name subprogram_name. 

The pragma associates a particular calling sequence with a subprogram whose 
implementation is provided in the form of an object code module. The 
librarian interface subcommand<All hosts: interface> (sec. 10.3.22) must be 
used to identify the associated object code module. 

The language_name may be Ada, Assembly, or C. Any other language_name will be 
accepted, but ignored, and the default language, Ada, will be used. 

It is almost always necessary to use a pragma LINKAGE_NAME (sec. 4.1.2.1) for 
interfaced subprograms. Without the LINKAGE_NAME pragma, the user^ must 
determine the compressed name the compiler generates and use that name in the 
provided object module. 

An interfaced subprogram cannot have a direct Ada implementation, i.e., a body 
is not allowed for such a subprogram. It is possible to compile an Ada 
subprogram with a different name and then use the librarian interface 
subcommand to reference that subprogram. 

4.1.1.4. Pragmas MEMORY_SIZE, STORAGE_UNIT , and SYSTEM_NAME 

This section details the procedure for compiling one of these pragmas. The 
compilation unit containing the pragma must be compiled into a library that 
contains package System. For most users, the Tartan Ada Standard Packages 
Library will be the library that includes package System. In that case, the 
procedure is as follows: [This procedure will not cause any of the units in the 
Tartan Ada Standard Packages Library to become obsolete.] 

1. Thaw the library tartan:standard_packages. 

2. Compile the pragma into the library tartan: standard_packages. This step 
updates package System. Any unit that depends on System becomes 
obsolete and will require recompilation before it may be used in a 
program. 


C-3 




APPENDIX F OF THE Ada STANDARD 


3. Freeze the library tartan:standard_packages. 

For pragma STORAGE_UNIT, no value other than that already specified by 
System.Storage_Unit {sec. 4.3) is allowed. For pragma SYSTEM__NAME, no value 
other than that already specified by System.System_Name (sec. 4.3) is allowed. 

4.1.1.5. Pragma OPTIMIZE 

Pragma OPTIMIZE is supported as described in the LRM, Annex B with the 
following exceptions: 

- pragma OPTIMIZE is not implemented for the declarative part of a block 

- in the declarative part of bodies, the effect of pragma OPTIMIZE on 
nested subprograms is dependent on its position in the declarative part, 
i.e., the pragma applies to subprograms declared after it. 

The argument applied to pragma OPTIMIZE (space or time) directly corresponds 
to the same argument supplied with the optimization option on the compiler 
command line. For example, specifying 

pragma OPTIMIZE(TIME) 

has the same effect as compiling the subprogram and specifying optimization 
level time (UNIX: -'0p3; VMS: /optimize=time) on the command line. 

When the code being compiled contains an OPTIMIZE pragma and the command line 
option to specify an optimization level is supplied, the pragma takes 
precedence over the command line option. 

4.1.1.6. Pragma SHARED 

Pragma SHARED is supported as described in the LRM, Annex B. 

Users should be aware that one consequence of applying pragma SHARED to a 
variable is to disable compiler optimizations that remove redundant reads 
and/or writes to that variable. Thus pragma SHARED allows the user to write 
loops that poll hardware devices until some change is seen. 

with System; 

package body Device_X is 

Control_Register_For_X : Integer; 

for Control_Register_For_X use at 16#123#; 

pragma SHARED(Control_Register_For_X); 

function Wait_Until_X_Signals return Integer is 

-- return the value of the control register as soon as it becomes 
non-zero 
,T : Integer; 
begin 
loop 

T := Control_Register_For_X; 
exit when T /= 0; 
end loop; 
return T; 

end Wait_Until_X_Signals ; 
end Device_X; 

Figure 4-1: Using pragma SHARED to Keep Redundant Reads 


C-4 



APPENDIX F OF THE Ada STANDARD 


Note that pragma SHARED can be applied only to scalar variables. If the 
object is best described using a structure, one of the following alternatives 
must be used: 

** Compile the code at low optimization levels, causing the compiler not to 
eliminate the redundant reads and writes. Since most applications cannot 
tolerate this kind of loss in performance across the board, it is 
suggested that the critical code be isolated into its own compilation 
unit. 

- Declare the variable as a scalar (or adjacent scalars)’ and use unchecked 
conversion to copy to/from local variables of the proper type just 
after/before read/write operations. 

“ Use non-optimizable procedures that implement a read/write of the object. 
Package Low_Level_IO (LRM 14,6) provides one such set of routines. Other 
high-efficiency routines may be built using package Machine_Code 

- Another method is to create the obvious simple Ada routines, but isolate 
them in a separate package and do not use cross-compilation 
optimizations, such as pragma INLINE. 

Figure 4-2 shows how package Low_Level_IO is used to force the compiler to 
keep redundant reads of a non-scalar object. 

with Low_Level_IO; 
with System; 

package body Device_Y is 

type Y_Regs_Type is 
record 

Control : Integer; 

Input : Integer; 

Output : Integer; 
end record; 

Y : Y_Regs_Type; 
for Y use at 16#246#; 

function Wait_Until_Y_Signals return Integer is 

-- return the value of the control register as soon as it becomes 
-- non-zero 
T : Integer; 
begin 
loop 

Low_Level_IO.Receive_Control (Y.Control' address, T) ; 
exit when T /= 0; 
end loop; 
return T; 

end Wait_Until_Y_Signals; 
end Device_Y; 

Figure 4-2: Using Low_Level_IO to Force Compiler to Keep Redundant Reads 
4.1.2. Implementation-Defined Pragmas 

Implementation-defined pragmas provided by Tartan are described in the 


C-5 





APPENDIX F OF THE Ada STANDARD 


following sections. 

4.1.2.1. Pragma LINKAGE_NAME 

The pragma LINKAGE_NAME associates an Ada entity with a string that is 
meaningful externally; for example, to a linkage editor. It ta’-es the form 

pragma LINKAGE_NAME(name, string-constant) 

The pragma is only allowed in a package specification or in a declarative 
part, or after a library subprogram in a compilation before any subsequent 
compilation unit. 

If the pragma appears in a library package specification the name must denote 
an entity declared earlier in the same package. If the pragma appears in any 
other package specification or in a declarative part, the name must denote an 
entity declared earlier in the same package or declarative part, and must 
denote either a subprogram or an exception. If the pragma appears after a 
given library subprogram, the only name allowed is the name of this 
subprogram. 

The name must be the simple name or operator symbol of an Ada entity. The 
name refers only to the most recently declared entity with the given name, not 
to all of the overloadings of the name. 

The name should denote an entity that has a runtime representation; for 
example, a subprogram, an exception, or an object. If the name denotes an 
entity that has no runtime representation the pragma has no effect; for 
example, named numbers, generic units, and most constants with values Imown at 
compile-time do not have runtime representations. The pragm^ also will have 
no effect if the name is one declared by a renaming declaration. 

The effect of the pragma is to cause the string-constant to be used in the 
generated object code as an external name for the associated Ada entity. It 
is the responsibility of the user to guarantee that this string constant is 
meaningful to the linkage editor and that no illegal linkname clashes 
arise. Names given in the string-constant argument of a pragma LINKAGE.NAME 
are case sensitive. For example, aNy_01d_LINKname is^ not equivalent to 
ANY_OLiD_LINKNAME. Therefore, a misspelled linkname will cause the link to 
fail. 

When determining the maximum allowable length for the external linkage name, 
keep in mind that the compiler will generate names for elaboration flags for 
subprograms simply by appending a five-character suffix to the linkage name. 
Therefore, a linkage name for a subprogram may have five fewer characters than 
the lower limit of other tools that need to process the name (e.g.,_the Tartan 
Linker limits names to 40 characters; therefore, your external linkage name 
should not exceed 35 characters), 

4.1.2.1.1. Calling Ada Subprograms from non-Ada Code 

Pragma LINKAGE_NAME can be used to allow non-Ada code to call an Ada 
subprogram. Calling Ada from non-Ada code is highly dependent on the language 
the call is being made from as well as the compiler for that language. 

First, the Ada subprogram must be given a linkage name so that the non-Ada 
code will be able to call the Ada subprogram. Pragma LINKAGE_NAME is used to 


C-6 







APPENDIX F OF THE Ada STANDARD 


perform this task. Next, an unimplemented subprogram must be defined in the 
non-Ada code. This subprogram must have the same linkage name as specified by 
the pragma LINKAGE_NAME on the Ada subprogram. Calls to this unimplemented 
subprogram will then go to the Ada subprogram if the object file containing 
the Ada subprogram was linked into the application. Note that a conversion 
between th^ object file (file.tof) for the Ada subprogram and the non-Ada 
object file will probably be needed. See the Object File Utj-lities Manual for 
more on object file conversion. 

For the call to be made correctly, you must ensure that the calling convention 
and parameter passing mechanisms of the non-Ada code are compatible with the 
Tartan Ada Compiler (sec. 5.4 and 5.5). 

Pragma LINKAGE_NAME can also be applied to an Ada object or exception. This 
allows non-Ada code to refer to the Ada entity. In doing so, you should be 
aware of the Ada rules governing implicit initialization of objects (Ada LRM 
3.2.1 and 3.3) and the Tartan Ada Compiler’s data representation conventions 
(sec. 5.1). 

4.1.2.2. Pragma FOREIGN_BODY 

In addition to pragma INTERFACE, Tartan Ada supplies pragma_FOREIGN^BODY as a 
way to access entities defined in programs written in other languages. Use of 
the pragma FOREIGN_BODY dictates that all subprograms and objects in the 
package are provided by means of a foreign object module. Unlike pragma 
INTERFACE, pragma FOREIGN_BODY allows access to objects as well as 
subprograms. 

The pragma is of the form: 

pragma FOREIGN_BODY (language_name [, elaboration_routine_name] ) 

A single such pragma may appear in any non-generic library package, and must 
appear in the visible part of the package before any declarations. The pragma 
is only permitted when the declarations in the visible and private parts of 
the package consist of subprogram declarations, number declarations, and 
object declarations with no explicit initialization and with a subtype given 
by a simple type mark. Use clauses and other pragmas may also appear in the 
package specification. If any of these restrictions are violated, the pragma 
is ignored and a warning is generated. Note in particular that types, 
exceptions, packages, and generic units may not be declared in the package. 

The language_name argument is a string intended to identify the language 
processor used to create the foreign module. It is treated as a comment by 
the compiler. 

The optional elaboration_routine_name argiiment is a string giving the linkage 
name of a routine to initialize the package. The routine specified will be 
called for the elaboration of this package body. It must be a global routine 
in the object module provided by the user. 

The programmer must ensure that the calling convention and data representation 
of the foreign body subprograms and elaboration routine are compatible with 
those used by the Tartan Ada Compiler (sec. 5.4). 

To successfully link a px-ogram including a foreign body, the object module for 
that body must be provided to the library using the librarian foreign 


C-7 





APPENDIX F OF THE Ada STANDARD 


subconunand<UNIX; foreign; VMS: foreign> (sec. 2.3.3 and 10.3.18). 

All entities declared by the package must be supplied by the foreign object 
module- Pragma LINKAGE_NAME will usually have to be used to ensure agreement 
between the linkage names used by the Tartan Ada Compiler and the foreign 
language processor. 

The foreign body is entirely responsible for initializing objects declared in 
a package utilizing pragma FOREIGN^BODY. In particular, the user should be 
aware that the implicit initializations described in LRM 3.2.1 are not done by 
the compiler. {These implicit initializations are associated with objects of 
access types, certain record types and composite types containing components 
of the preceding kinds of types.) 

The user may choose to override the pragma FOREIGN_BODY and compile a 
corresponding package body written in Ada. In this case the pragma is ignored 
(in particular the specified elaboration routine is not called), and no 
librarian foreign subcommand is required or allowed. This capability is 
useful for rapid prototyping, where an Ada package may serve to provide a 
simulated response for the functionality that a foreign body may eventually 
produce. It also allows the user to replace a foreign body with an Ada body 
without recompiling the specification. 

If only subprograms are declared in the package specification it is more 
portable to use pragma INTERFACE on each of the subprograms instead of pragma 
FOREIGN_BODY on the package. 

In the following example, we want to call a function plmn which computes 
polynomials and is written in C. 

package Math_Functions is 

pragma FOREIGN_BODY("C"); 

function Polynomial(X:Integer) return Integer; 

— Ada spec matching the C routine 
pragma LINKAGE_NAME(Polynomial, "plmn"); 

— force compiler to use name plmn when referring to this function 


-- Note: The linkage name "plmn" may need to be "_plinn" , 
if the C compiler produces leading underscores 
for external symbols, 
end Math_Functions; 

with Math_Functions; use Math_Functions; 
procedure Main is 

X:Integer := Polynomial(lO); 

-- will generate a call to plmn 
begin ... 
end Main; 

To compile, link and run the above program, you must: 

1. Compile Math_Functions. 

2. Compile Main. 

3. Provide the object module (for example, math.tof) containing the 
compiled "C* code for plmn, converted to Tartan Object File Format 


C-8 




APPENDIX F OF THE Ada STANDARD 


(TOFF); if the module is written in assembly code, for example, using 
the lEFE-to-TOFF utility (Object File Utilities Manual, ch. 4). 

4. Issue the command: 

UNIX: 

adalibprocessor foreign math_functions math.tof 


VMS: 


al68 foreign math_functions math.tof 
5. Issue the command: 

UNIX: 

adalibprocessor link main 


VMS: 


al68 link main 

Without step 4, an attempt to link will produce an error message informing you 
of a missing package body for Math_Functions. 

4.1.2.3. Pragma UNCHECKED_NO_STATE_WRITTEN and 

• Pragma UNCHECKED_NO_STATE_WRITTEN_OR_READ 

The pragmas UNCHECKED_NO_STATE_WRITTEN and UNCHECKED_NO_STATE_WRITTEN_OR_READ 
take the form: 

pragma UNCHECKED_NO_STATE_WRITTEN(name [, name...] ) 
pragma UNCHECKED_NO_STATE_WRITTEN_OR_READ(name [, name..,]) 

Each name must be the simple name of an Ada subprogram declared in the 
declarative part or package specification where the pragma appears. The name 
refers only to the most recently declared subprogram with the given name, not 
to all of the overloadings of the name. 

The pragma UNCHECKED_NO_STATE_WRITTEN notifies the compiler that the named 
subprogram has no side effects on any objects outside the subprogram. 
Assignment to in out or out parameters is not considered a side effect. 
Function results are also not considered to be side effects. Calling another 
subprogram is considered to be a side effect, unless the called subprogram is 
also named in either a pragma UNCHECKED_NO_STATE_WRITTEN or pragma 
UNCHECKED_NO_STATE_WRITTEN_OR_READ. 

This pragma permits the compiler to improve the optimization performed near 
calls to the named subprogram without introducing a dependency on the body of 
the subprogram. In effect, global side effect analysis is achieved without 
creating additional dependencies which may require recompilation. 

Any function which writes only to its result, or any subprogram which writes 
only to its in out or out parameters is an excellent candidate for this 

pragma. 


C-9 




APPENDIX F OF THE Ada STANDAFID 


The pragma UNCHECKED_NO_STATE_WRITTEN_OR_READ indicates that the named 
subprogram behaves strictly as a mathematically pure function. In essence, 
this statement means that the subprogram will always return the same result 
when called with identical parameters. The named subprogram must follow all 
of the rules for an UNCHECKED_NO_STATE_WRITTEN subprogram. In addition,^ the 
named subpr'^gram may not read the value of any variable not contained within 
its own scope. in and in out parameters, and objects declared as constants 
may be read freely. Called subprograms must themselves be 

NO_STATE_WRITTEN_OR_READ. 

The compiler may choose to make common subexpressions of the"results of calls 
to the named subprogram. It may also remove such calls entirely when the 
result of the subprogram is not used; calls may also be loop-invariant 
hoisted. 

Subprograms which are likely candidates for this pragma include math package 
subprograms, matrix math subprograms, trigonometric functions, etc. 

Caution: 

Pragmas UNCHECKED_NO_STATE„WRITTEN and UNCHECKED_NO__STATE_WRITTEN_OR_READ are 
strictly assertive in nature and are entirely unchecked. The compiler will 
not notify you if the body of the subprogram does not meet the reguirements of 
the pragma. When one of these pragmas is incorrectly applied to a subprogram 
which does not meet its requirements, the behavior of your program is 
undefined and may be unpredictable. 

4.2. IMPLEMENTATION-DEPENDENT ATTRIBUTES 

4.2.1. 'Exception_Address 

The attribute 'Exception_Address used with a prefix that denotes an exception 
yields the storage address associated with the exception. The value of this 
attribute is of the type Address defined in the package System. 

4.3. SPECIFICATION OF THE PACKAGE System 

The parameter values specified for the 68xxx target in package System {LRM 
13.7.1 and Annex C) are: 


package System is 

type Address is new Integer; 


type Name xs 

System_Name 

Storage_Unit 

Memory__Size 

Max_Int 

Min_Int 

Max_Digits 


(MC68020); 

constant Name := MC68020; 


constant 

constant 

constant 

constant 

constant 


8 ; 

1 _ 000 _ 000 ; 
2_147_483_647; 
-Max^Int - 1; 
15; 


Max_Mantissa : constant := 31; 

Fine_Delta : constant := 2#1.0#e-31; 

Tick : constant := 0.01; 

subtype Priority is Integer range 10 .. 200; 
Default_Priority : constant Priority := Priority'First; 
Runtime_Error : exception; 
end System; 


C-10 




APPENDIX F OF THE Ada STANDARD 


4.4. RESTRICTIONS ON REPRESENTATION CLAUSES 

The following sections explain the basic restrictions for representation 
specifications followed by additional restrictions applying to specific kinds 
of clauses. 

4.4.1. Basic Restriction 

The basic restriction on representation specifications (LRM 13.1) is that they 
itiay be given only for types declared in terms of a type definition, excluding 
a Generic_Type_Definition (LRM 12.1) and a Private_Type_Definition (LRM 7.4). 
Any representation clause in violation of these rules is not obeyed by the 
compiler; an error message is issued. 

Further restrictions are explained in the following sections. Any 

representation clauses violating those restrictions cause compilation to stop 
and a diagnostic message to be issued. 

4.4.2. Length Clauses 

Length clauses (LRM 13.2) are, in general, supported. The following sections 
detail use and restrictions. 

4.4.2.1. Size Specifications for Types 

The rules and restrictions for size specifications applied to types of various 
classes are described below. 

The following principle rules apply: 

1. The size is specified in bits and must be given by a static expression. 

2. The specified size is taken as a mandate to store objects of the type in 
the given size wherever feasible. No attempt is made to store values of 
the type in a smaller size, even if possible. The following rules apply 
with regard to feasibility: 

“ An object that is not a component of a composite object is 
allocated with a size and alignment that is referable on the target 
machine (i.e., no attempt is made to create objects of 

non-referable size on the stack). If such stack compression is 
desired, it can be achieved by the user by combining multiple stack 
variables in a composite object; for example: 

type My_Enum is (A, B); 
for My_Enum'Size use 1; 

V, W : My_Enum; -- will occupy two storage 
-- units on the stack 
-- (if allocated at all) 
type Rec is record 
V, W : My_Enum; 
end record; 
pragma PACK(Rec); 

O : Rec; -- will occupy one storage unit 

- A formal parameter of the type is sized according to calling 
conventions rather than size specifications of the type. 


C-11 




APPENDIX F OF THE Ada STANDARD 

Appropriate size conversions upon parameter passing take place 
automatically and are transparent to the user. 

- Adjacent bits to an object that is a component of a composite 
object, but whose size is non-referable, may be affected by 
assignments to the object, unless these bits are occupied by other 
components of the composite object (i.e., whenever possible, a 
component of non-referable size is made referable). 

In all cases, the compiler generates correct code for all operations on 
objects of the type, even if they are stored ' wihh differing 
representational sizes in different contexts. 

Note: A size specification cannot be used to force a certain size in 

value operations of the type; for example: 

type My_Int is range 0..65535; 
for My_Int‘Size use 16; -- o.k. 

A, B : My_Int; 

...A + B... -- this operation will generally be 
— executed on 32-bit values 

3. A size specification for a type specifies the size for objects of this 
type and of all its subtypes. For components of composite types, whose 
subtype would allow a shorter representation of the component, no 
attempt is made to take advantage of such shorter representations. 

For example, consider the following: 

type My_Int is range 0..2**17-1; 
for My_Int’Size use 17; -- (1) 
subtype Small_My__Int is My_Int range 0..255; 
type R is record 

X : Small_My_Int; 

end record; 

The component R.X will occupy 17 bits even though it can be represented 
in 8 bits. If a pragma PACK(R) is added, R.X will still be allocated in 
17 bits. 

In contrast, for types without a size specification, such components may 
be represented in a lesser number of bits than the number of bits 
required to represent all values of the type. In the example above, if 
the size specification at (1) is removed, R.X will be represented in 32 
bits (the size of My_Int) . However, a pragma PACK(R) will now cause R.X 
to be allocated in 8 bits. 

Size specifications for access types must coincide with the default size 
chosen by the compiler for the type. 

Size specifications are not supported for floating-point types or task types. 

No useful effect can be achieved by using size specifications for access, 
floating-point, or task types. 


C-12 




APPENDIX F OF THE Ada STANDARD 


4.4.2.2. Size Specification for Scalar Types 

The specified size must accommodate all possible values of the type including 
the value 0 (zero), even if 0 is not in the range of the values of the type. 
For numeric types with negative values, the number of bits must account for 
the sign bit. Biased representation is not attempted. Thus, 

type My_Int is range 100..101; 

requires at least 7 bits, although it has only two values, while 
type My_Int is range -101..-100; 
requires 8 bits to account for the sign bit. 

A size specification for a fixed-point type does not affect the accuracy of 
operations on the type. Such influence should be exerted via the 
Accuracy_Definition of the type (LRM 3.5.9). 

A size specification for a scalar type may not specify a size larger than the 
largest operation size supported by the target architecture for the respective 
class of values of the type. 

4.4.2.3. Size Specification for Array Types 

A size specification for an array type must be large enough to accommodate all 
components of the array under the densest packing strategy. Any alignment 
constraints on the component type (sec. 4.4.7) must be met. 

The size of the component type cannot be influenced by a length clause for an 
array. Within the limits of representing all possible values of the component 
subtype (but not necessarily of its type), the representation of components 
may, however, be reduced to the minimum number of bits, unless the component 
type carries a size specification. 

If there is a size specification for the component type, but not for the array 
type, the component size is rounded up to a referable size, unless pragma PACK 
is given. This rule applies even to boolean types or other types that require 
only a single bit for the representation of all values. 

4.4.2.4. Size Specification for Record Types 

A size specification for a record type does not influence the default type 
mapping of a record type. The size must be at least as large as the number of 
bits determined by type mapping. Influence over packing of components can be 
exerted by means of (partial) record representation clauses or by pragma PACK. 

Neither the size of component types, nor the representation of component 
subtypes can be influenced by a length clause for a record. 

The only implementation-dependent components allocated by Tartan Ada in 
records contain either dope information for arrays whose bounds depend on 
discriminants of the record or relative offsets of components within a record 
layout for record components of dynamic size. These implementation-dependent 
components cannot be named or sized by the user. 

A size specification cannot be applied to a record type with components of 


C-13 



APPENDIX F OF THE Ada STANDARD 


dynamically determined size. 

Note: Size specifications for records can be used only to widen the 

representation accomplished by padding at the beginning or end of the record. 
Any narrowing of the representation over default type mapping must be 
accomplished by representation clauses or pragma PACK. 

4.4.2.5. Specification of Collection Sizes 

The specification of a collection size causes the collection to be allocated 
with the specified size. It is expressed in storage units and need not be 
static; refer to package System for the meaning of storage units. 

Any attempt to allocate more objects than the collection can hold causes a 
Storage_Error exception to be raised. Dynamically sized records or arrays may 
carry hidden administrative storage requirements that must be accounted for as 
part of the collection size. Moreover, alignment constraints on the type of 
the allocated objects may make it impossible to use all memory locations, of 
the allocated collection. No matter what the requested object size, the 
allocator must allocate a minimum of 2 words per object. This lower limit is 
necessary for administrative overhead in the allocator. For example, a 
request of 5 words results in an allocation of 5 words; a request of 1 (one) 
word results in an allocation of 2 words. 

In the absence of a specification of a collection size, the collection is 
extended automatically if more objects are allocated than possible in the 
collection originally allocated with the compiler-established default size. 
In this case, Storage_Error is raised only when the available target memory is 
exhausted. If a collection size of zero is specified, no access collection is 
allocated. 

Collection sizes may not be specified for an access type whose designated type 
is a task type. 

4.4.2.6. Specification of Task Activation Size 

The specification of a task activation size causes the task activation to be 
allocated with the specified size. It is expressed in storage units; refer to 
package System for the meaning of storage units. 

Any attempt to exceed the activation size during execution causes a 
Storage_Error exception to be raised. Unlike collections, there is no 

extension of task activations. 

4.4.2.7. Specification of 'Small 
Only powers of 2 are allowed for 'Small. 

The length' of the representation may be affected by this 
size specification is also given for the type, the size 
precedence; it must then be possible to accommodate 
'Small within the specified size. 

4.4.3. Enumeration Representation Clauses 

For enumeration representation clauses (LRM 13.3), the following restrictions 
apply: 


specification. If a 
specification takes 
the specification of 


C-14 




APPENDIX F OF THE Ada STANDARD 

- The internal codes specified for the literals of the enumeration type may 
be any integer value between Integer'First and Integer’Last. It is 
strongly advised that you do not provide a representation clause that 
merely duplicates the default mapping of enumeration types which assigns 
consecutive numbers in ascending order starting with 0 (zero). 
Unnecessary runtime cost is incurred by such duplication. It should be 
noted chat the use of attributes on enumeration types with user-specified 
encodings is costly at runtime. 

- Array types, whose index type is an enumeration type with non-contiguous 
value encodings, consist of a contiguous sequence of components. 
Indexing into the array involves a runtime translation of the index value 
into the corresponding position value of the enumeration type. 

4.4.4. Record Representation Clauses 

The alignment clause of record representation clauses (LRM 13.4) is observed 
for library-level record objects. 


The alignment clause has no effect on objects not defined on a library level 
(e.g., subprogram locals). The value given in the alignment clause is in 
addressable units and is restricted to the powers of two in the range of 

0 15 . . . ^ 
2 ..2 . The specified alignment becomes the minimum alignment of the record 
type, unless the minimum alignment of the record forced by the component 
allocation is already more stringent than the value specified by the alignment 
clause. 


only for 
Not all 
of variant 
is statically 


The component clauses of record representation clauses are allowed 
components and discriminants of statically determinable size, 
components need to be present. Component clauses for components 
parts are allowed only if the size of the record type 
determinable for every variant. 

The size specified for each component must be sufficient to allocate all 
possible values of the component subtype, but not necessarily the component 
type. The location specified must be compatible with any alignment 
constraints of the component type; an alignment constraint on a component type 
may cause an implicit alignment constraint on the record type itself. 

The numbering of the bits within the component clause is left-to-right in 
accordance with the 68K Bit Field Data type. For example, the following 
component clause defines a 2-bit wide field that starts at offset 0 in the 
record: 

component-name at 0 range 0..1; 

The field will be placed in the two most significant (leftmost) bits of the 
first byte of the record. 

If some, but not all, discriminants and components of a record type are 
described by a component clause, the discriminants and components without 
component clauses are allocated after those with component clauses; no attempt 
is made to utilize gaps left by the user-provided allocation. 


4.4.5. Address clauses 


C-15 




APPENDIX F OF THE Ada STANDARD 


Address clauses (LRM 13.5) are supported with the following restrictions: 

“ When applied to an object, an address clause becomes a linker directive 
to allocate the object at the given address. For any object not declared 
immediately within a top-level library package, the address clause is 
meaningless. 

- Address clauses applied to local packages are not supported by Tartan 
Ada. Address clauses applied to library packages are prohibited by the 
syntax; therefore, an address clause can be applied to a package only if 
it is a body stub. 

- Address clauses applied to subprograms and tasks are implemented 
according to the LRM rules. When applied to an entry, the specified 
value identifies an interrupt in a manner customary for the target. 
Immediately after a task is created, a runtime call is made for each of 
its entries having an address clause, establishing the proper binding 
between the entry and the interrupt. 

- A specified address must be an Ada static expression, as defined in LRM 

4.9. 

- Address clauses which are applied to objects, subprograms, packages, or 
task units specify virtual addresses. 

- The range of System.Address is -16#8000_0000#..16#7fff_ffff#. To 

represent a machine virtual address in the range 

16#0000_0000#..16#7fff_ffff#, use the corresponding System.Address. To 
represent a machine virtual address greater than System.Address 
16#7fff_ffff#, use the negated radix-complement of the desired machine 
virtual address. For example, to express machine virtual address 
16#C000_0000#, use 16#CO0O_OOO0#-2**32. 

Note: Creating an overlay of two objects by means of address clauses is 
possible with Tartan Ada. However, such overlays (which are considered 
erroneous by the Ada LRM 13.5(8)) will not be recognized by the compiler 
as an aliasing that prevents certain optimizations. Therefore, problems 
may arise if. reading and writing of the two overlaid objects are 
intermingled. For example, if variables A and B are overlaid by means 
of address clauses, the Ada code sequence: 

A := 5; 

B := 7; 

if A = 5 then raise Surprise; end if; 

may well raise the exception Surprise, since the compiler believes the 
value of A to be 5 even after the assignment to B. 

4.4.6. Pragma PACK 

Pragma PACK (LRM 13.1) is supported. For details, refer to the followxng 
sections. 

4.4.6.1. Pragma PACK for Arrays 

If pragma PACK is applied to an array, the densest possible representation is 
chosen. For details of packing, refer to the explanation of size 


C-16 





APPENDIX F OF THE Ada STANDARD 


specifications for arrays (sec. 4.4.2.3). 

If, in addition, a length clause is applied to the array type, the pragma has 
no effect, since such a length clause already uniquely determines the array 
packing method. 

If a length clause is applied to the component type, the array is packed 
densely, observing the component's length clause. Note that the component 
length clause may have the effect of preventing the compiler from^ packing as 
densely as would be the default if pragma PACK were applied with no length 
clause given for the component type. 

4.4.6.2. The Predefined Type String 

Package Standard applies pragma PACK to the type String. However, when 
applied to character arrays, this pragma cannot be used to achieve denser 
packing than is the default for the target: 1 character per 8-bit word. 

4.4.6.3. Pragma PACK for Records 

If pragma PACK is applied to a record, the densest possible representation is 
chosen that is compatible with the sizes and alignment constraints of the 
individual component types. Pragma PACK has an effect only if^ the sizes of 
some component types are specified explicitly by size specifications and are 
non-referable. In the absence of pragma PACK, such components generally 
consume a referable amount of space. 

It should be noted that the default type mapping for records maps components 
of boolean or other types that require only a single bit to a single bit in 
the record layout, if there are multiple such components in a record. 
Otherwise, it allocates a referable amount of storage to the component. 

If pragma PACK is applied to a record for which a record representation clause 
has been given detailing the allocation of some but not all components, the 
pragma PACK affects only the components whose allocation has not^ been 
detailed. Moreover, the strategy of not utilizing gaps between explicitly 
allocated components still applies. 

4.4.7. Minimal Alignment for Types 

Certain alignment properties of values of certain types are enforced by the 
type mapping rules. Any representation specification that cannot be satisfied 
within these constraints is not obeyed by the compiler and is appropriately 
diagnosed. 

Alignment constraints are caused by properties of the target architecture, 
most notably by the capability to extract non-aligned component values from 
composite values in a reasonably efficient manner. Typically, restrictions 
exist that make extraction of values that cross certain address boundaries 
very expensive, especially in contexts involving array indexing. Peirmitting 
data layouts that require such complicated extractions may impact code quality 
on a broader scale than merely in the local context of such extractions. 

Instead of describing the precise algorithm of establishing the minimal 
alignment of types, we provide the general rule that is being enforced by the 
alignment rules: 


C-17 




APPENDIX F OF THE Ada STANDARD 


- No object of scalar type {including components or subcomponents of a 
composite type) may span a target-dependent address boundary that would 
mandate an extraction of the object's value to be performed by two or 
more extractions. 

4.5. IMPLEMENTATION-GENERATED COMPONENTS IN RECORDS 

The only implementation-dependent components allocated by Tartan Ada in 
records are fields containing either dope information for arrays whose bounds 
depend on discriminants of the record or relative offsets of components within 
a record layout for record components of dynamic size.-- These components 
cannot be named by the user. 

4.6. INTERPRETATION OF EXPRESSIONS APPEARING IN ADDRESS CLAUSES 

Section 13.5.1 of the LRM describes a syntax for associating interrupts with 
task entries. Tartan Ada implements the address clause 

for ToEntry use at intID; 

by associating the interrupt specified by intID with the ToEntry entry of the 
task containing this address clause. The interpretation of intID is 

implementation dependent. 

The Motorola 68xxx specification provides 256 interrupts that may be 
associated with task entries. These interrupts are identified by an integer 
in the range 0..255, corresponding to the interrupt vector numbers in section 
9,2 of the MC68040 32-Bit Microprocessor User's Manual. When you specify an 
interrupt address clause/ the intID argument is interpreted as follows. 

> If the argument is in the range 0..255/ a full support interrupt 
association is made between the interrupt specified by the argument and 
the task entry. That is, the runtimes make no assumptions about the task 
in question. This method is the slower. 

- If the argument is in the range 256..511, a fast interrupt association is 
made between the interrupt number (argument-256) and the task entry. 
This method provides faster execution because the runtimes can depend 
upon the assumptions previously described. 

For ■ the difference between full support and fast interrupt handling, refer to 
section 9.5.13. 

4.7. RESTRICTIONS ON UNCHECKED CONVERSIONS 

Tartan supports Unchecked_Conversion as documented in Section 13.10^ of the 
LRM. The sizes need not be the same, nor need they be known at compile time. 
The only exception is unconstrained array types or access to unconstrained 
array types which may not be used as the target of an Unchecked_Conversion. 

If the value in the source is wider than that in the target, the source value 
will be truncated. If narrower, it will be zero-extended. Calls on 
instantiations of Unchecked_Conversion are made inline automatically. 

4.8. IMPLEMENTATION-DEPENDENT ASPECTS OF INPUT-OUTPUT PACKAGES 

Tartan Ada supplies the predefined input/output packages Direct^IO, 



APPENDIX F OF THE Ada STANDARD 


Sequential_IO, Text_IO, and Low_Level_IO as required by Chapter 14. 
However, since the target computer is used in embedded applications lacking 
both standard I/O devices and file systems, the functionality of Direct_IO, 
Sequential_IO, and Text_IO is limited. 

Direct_IC and Seq'uential_IO raise Use_Error if a file open or file access is 
attempted. Text_IO is supported to Current_Output and from Current_Input. A 
routine that takes explicit file names raises Use^Error. 

4.9. OTHER IMPLEMENTATION CHARACTERISTICS 

The following information is supplied in addition to that required by Appendix 
F to MIL-STD-1815A. 

4.9.1. Definition of a Main Program 

Any Ada library subprogram unit may be designated the main program for 
purposes of linking (using the Ada librarian's link subcommand) provided that 
the subprogram has no parameters. 

Tasks initiated in imported library units follow the same rules for 
termination as other tasks (described in LRM 9.4 (6-10)). Specifically, these 
tasks are not terminated simply because the main program has terminated. 
Terminate alternatives in selective wait statements in library tasks are 
therefore strongly recommended. 

4.9.2. No Use of Numeric_Error 

No predefined operations will raise the exception Numeric_Error. The Tartan 
Ada Compiler raises the predefined exception Constraint^Error in situations 
where, according to the Ada LRM, the predefined exception Numeric^Error should 
be raised. 

This change in the compiler has been made in accordance with the approved Ada 
Interpretation AI-00387. "An Ada program is portable if any handler intended 
to process Numeric_Error provides a choice for Constraint_Error and processes 
it in a similar manner.'’ 

If this procedure has been followed, you will not experience any change in 
program behavior because of this change in the compilation system. 

4.9.3. Implementation of Generic Units 

All instantiations of generic units, except the predefined generic 
Unchecked_Conversion and Unchecked_Deallocation subprograms, are implemented 
by code duplications. No attempt at sharing code by multiple instantiations 
is made in this release of Tartan Ada. 

Tartan Ada enforces the restriction that the body of a generic unit^ must be 
compiled before the unit can be instantiated. It does not impose the 
restriction that the specification and body of a generic unit must be provided 
as part of the same compilation. A recompilation of the body of a generic 
unit will cause any units that instantiated this generic unit to become 
obsolete. 

4.9.4. Implementation-Defined Characteristics in Package Standard 


C-19 




APPENDIX F OF THE Ada STANDARD 

The implementation-dependent characteristics in package Standard (Annex C) 
are: 

package Standard is 

type Byte_Integer is range -128 .. 127; 

type Short_Integer is range -32768 32767; 

type Integer is range -2_147_483_648 .. 2_147_483_647; 

type Float is digits 6 range -16#0.FFFFFF#E+32 .. 16#0.FFFFFF#E+32; 

type Long_Float is digits 15 range - 16#0 .FFFFFFFFFFFFF8#E+256 ./ 

16#0.FFFFFFFFFFFFF8#E+256 ; 

type Duration is delta 0.0001 range -86400.0 .. 86400.0; 
end Standard; 

4.9.5. Attributes of Type Duration 

The type Duration is defined with the following characteristics: 


1 

Attribute | 

Value 

1 

1 

Duration'Delta | 

1 

0.0001 

sec 

1 

1 

Duration'Small ] 

1 

-5 

6.103516E 

sec 

1 

Duration'First | 

1 

-86400.0 

sec 

1 

Duration'Last | 

1 

86400.0 

sec 


4.9.6. Values of Integer Attributes 

Tartan Ada supports the predefined integer types Integer, Short_Integer and 
Byte_Integer. The range bounds of these predefined types are: 


C-20 












APPENDIX F OF THE Ada STANDARD 


Attribute 

Value 

Integer'First 

1 

1 

-2**31 

Integer'Last 

2**3i-i 

Short_Integer'First 

-2**15 

Short_Integer'Last 

2**15-1 

Byte_Integer'First 

-128 

Byte^Integer'Last 

127 


The range bounds for subtypes declared in package Text_IO are: 


! 

Attribute | 

1 

Value 

Count'First 

0 

Count'Last 

Integer'Last - 1 

Positive_Count'First 

1 

Positive_Count'Last 

1 

1 Integer'Last - 1 

1 

i-- _ - _ 

C-21 





















APPENDIX F OF THE Ada STANDARD 


Field'First 

1 

1 0 

1 

1 

1 

1 

Field'Last 

1 

1 

240 1 

1 


The range bounds for subtypes declared in packages Direct_IO'are: 


Attribute 

Value 

Count’First 

0 

Count'Last 

Integer'Last 

Positive Count'First 

1 

Positive_Count'Last 

Count’Last 


4.9.7. Values of Floating-Point Attributes 

Tartan Ada supports the predefined floating-point types Float and Long_Float. 


Attribute 

1 

1 

1 

Value for Float 

Digits 

1 

1 

1 

6 

Mantissa 

1 

1 

1 

21 

Emax 

1 

1 

1 

84 


C-22 
























APPENDIX F OF THE Ada STANDARD 


- i 

Epsilon 

t 

16#0.1000_00#E-4 


(approximately 9.53674E-07) 

Small 

16#0.8000_00#E~21 


(approximately 2.58494E-26) 

Large 

16#0.FFFF_F8#E+21 


(approximately 1.93428E+25) 

Safe_Emax 

126 

Safe Small 

16#0.2000_000#E-31 


(approximately 5,87747E-39) 

Safe Large 

16#0.3FFF_FE0#E+32 


(approximately 8.50706E+37) 

First 

-16#0.FFFFFF#E+32 


(approximately -3.40282E+38) 

Last 

16#0.FFFFFF#E+32 


(approximately 3.40282E+38) 

Machine_Radix 

1 

1 2 

1 

Machine_Mantissa 

1 

1 24 

1 

Machine_Emax 

1 

1 128 

1 

1 Machine_Emin 

1 

-125 

- - 1 


C-23 

















APPENDIX F OF THE Ada STANDARD 


I 

Machine_Rounds | true 


Machine_Overflows | true 

i 


Attribute 

1 

Value for Long_Float | 

1 

_ __ _ _ __ 1 

1 

Digits 1 

1 

1 

15 i 

1 

Mantissa 

1 

51 1 

Emax 

1 

204 

Epsilon 

16#0.4000_0000_0000_000#E-12 


(approximately 8.8817841970013E-16) 

Small 

16#0.8000_0000_0000_000#E-51 


(approxiiaately 1.9446922743316E-62) 

Large 

16#0.FFFF_FFFF_FFFF_E00#E+51 


(approximately 2,5711008708143E+61) 

Safe_Emax 

1022 

Safe_Small 

16#0.2000_0000_0000_000#E-255 


(approximately 1.1125369292536E-308) 

Safe_Large 

16#0.3FFF_FFFF_FFFF_F80#E+256 

1 

1 

1 (approximately 4.4942328371557E+307) 

1 _ 



C-24 






















APPENDIX F OF THE Ada STANDARD 


- - - 1 

First 

-16#0.FFFFFFFFFFFFF8#E+256 
(approximately -1.79769313486232E+308) 

Last 

16#0.FFFFFFFFFFFFF8#E+256 
(approximately 1.79769313486232E+308) 

Machine_Radix 

2 

Machine_Manti s -a 

53 

1 

Machine Emax 

1 

1024 

1 

Machine_Emin j 

-1021 

Machine_Rounds 

true 

Machine_Overflows 

1 

1 true 

1 


4.10. SUPPORT FOR PACKAGE Machine_Code 

Package Machine„Code provides the programmer with an interface to request the 
generation of any instruction that is available on^ the MC68020, 
MC68881/MC68882, MC68030, MC68040 or CPU32 processors. The implementation of 

package Machine_Code is similar to that described in section 13.8 of the Ada 
LRM, with several added features. The Ada specifications for the Tartan Ada 
standard packages are located online in the directory: 

UNIX: /installation_directory/68xxx/version/std_packages/src 
VMS: [installation_directory.68xxx.version.std_packages.src] 

4.10.1. Basic Information 

As required by LRM, section 13.8, a routine which contains machine code 
inserts may not have any other kind of statement, and may not contain an 
exception handler. The only allowed declarative item is a use clause. 
Comments and pragmas are allowed as usual. 

4.10.2. Instructions 

A machine code insert has the form Type__Mark'Record_Aggregate, where the type 


C-25 













APPENDIX F OF THE Ada STANDARD 

must be one of the records defined in package Machine_Code. Package 
Machine_Code defines seven types of records. Each has an opcode and zero to 6 
operands. These records are adequate for the expression of all instructions 
provided by the 68xxx. 

4.10.3. Operr.ids and Address Modes 

An operand consists of a record aggregate which holds all the information to 
specify it to the compiler. All operands have an address mode and one or more 
other pieces of information. The operands correspond exactly to the operands 
of the instruction being generated. 

Each operand in a machine code insert must have an Address_Mode. The address 
modes provided in package Machine_Code provide access to all address modes 
supported by the 68xxx. 

In addition, package Machine_Code supplies the address modes Symbolic^Address 
and Symbolic__Value which allow the user to refer to Ada objects by specifying 
object'Address as the value for the operand. Any Ada object^ which has the 
'Address attribute may be used in a symbolic operand. Symbolic_Address should 
be used when the operand is a true address (for example, a branch target). 
Symbolic_Value should be used when the operand is actually a value (for 
example, one of the source operands of an ADD instruction). 

When an Ada object is used as a source operand in an instruction (that is, one 
from which a value is read), the compiler will generate code which fetches the 
value of the Ada object. When an Ada object is used as the destination 
operand of an instruction, the compiler will generate code which uses the 
address of the Ada object as the destination of the instruction. 

4.10.4. Examples 

The implementation of package Machine_Code makes it possible to specify both 
simple machine code inserts such as: 

Two„Opnds'(MOVEQ, (Imm, 3), (DR, DO)) 

and more complex inserts such as 

Two_Opnds ' (ADDI_„L, 

(Imm, 10), 

(Symbolic^Value, Array_Var(X, Y, 27)'Address)) 

In the first example, the compiler will emit the instruction MOVEQ 3, DO. In 
the second example, the compiler will first emit whatever instructions are 
needed to form the address of ArraY_Var(X, Y, 27) and then emit the ADDI_L 
instruction. The various error checks specified in the LRM will be performed 
on all compiler-generated code unless they are suppressed by the programmer 
(either through pragma SUPPRESS, or through command qualifiers). 

4.10.5. Incorrect Operands 

Under some circumstances, the compiler attempts to correct incorrect operands. 
Three modes of operation are supplied for package Machine_Code to determine 
whether corrections are attempted and how much information about the necessary 
corrections is provided to the user. 


C-26 





APPENDIX F OF THE Ada STANDARD 

The compiler command line options for the three modes of operation are: 



UNIX 

1 

1 VMS 

1 

- 

Me 


1 

1 fixup=none 

1 


Mw 


1 fixup=warn 

1 



no option [default] I fixup=quiet [default] 

I 


In the Me or fixup=none mode, the specification of incorrect operands for an 
instruction is considered to be a fatal error. In this mode, the compiler 
will not generate any extra instructions to help you to make a machine code 
insertion. Note that it is still legal to use 'Address constructs as long as 
the object which is used meets the requirements of the instruction. 

In the default or fixup=qniet mode, if you specify incorrect operands for an 
instruction, the compiler will do its best to correct the machine code to 
provide the desired effect. For example, although it is illegal to use an 
address register as the destination of an ADDI instruction, the compiler will 
accept it and try to generate correct code. In this case, the compiler will 
load the value found in the address register indicated into a data register, 
use the data register in the ADDI instruction, and then store from that data 
register back to the desired address register. 

Two_Opnds'(ADDI_L, (Imm, 3), (AR, Al)) 
will produce a code sequence such as: 

mov.l al,dO 

addi.l #3,d0 

mov.l dO, al 

In the Mw or fixup=warn mode, the compiler will perform the same level of 
correction as in the default or fixup=quiet mode. However, a warning message 
is issued stating that the machine code insert required additional machine 
instructions to make its operands legal. 

4.10.6. Assumptions Made in Correcting Operands 

When compiling in the UNIX default or Mw modes, or in the VMS fixup=quiet or 
fixup=warn modes, the compiler attempts to emit additional code to move ''the 
right bits'' from an incorrect operand to a place which is a legal operand for 
the requested instruction. The compiler makes certain basic assumptions when 
performing these corrections. This section explains the assumptions the 
compiler makes and their implications for the generated code. Note that if 
you want a correction which is different from that performed by the compiler. 


C-27 











APPENDIX F OF THE Ada STANDARD 


you must make explicit machine code insertions to perform it. 

For source and source/destination operands: 

- Symbolic^Address means that the address specified by the 'Address 
expression is used as the source bits. When the Ada object specified by 
the 'Address instruction is bound to a register, this will^^cause a 
compile-time error message because it is not possible to ''take the 
address'' of a register. 

- Symbolic_Value means that the value found at the address specified by the 
'Address expression will be used as the source bits. An Ada object which 
is bound to a register is correct here, because the contents of a 
270 g’ister can be expressed on the 68xxx. Any other non-register means 
that the value found at the address specified by the operand will be used 
as the source bits. 

For destination operands: 

- Symbolic_Address means that the desired destination for the operation is 
the address specified by the 'Address expression. An Ada object which is 
bound to a register is correct here; a register is a legal destination on 
the 68XXX. 

- Symbolic^Value means that the desired destination for the operations is 
found by fetching 32 bits from the address specified by the 'Address 
expression, and storing the result to the address represented by the 
fetched bits. This is equivalent to applying one extra indirection to 
the address used in the Symbolic_Address case. 


- All other operands are interpreted as directly specifying the destination 
for the operation. 

4.10.7. Register Usage 

The compiler may need several registers to generate code for operand 
corrections in machine code inserts. If you use all the registers, 
corrections will not be possible. In general, when more registers are 
available to the compiler it is able to generate better code. 

Since the compiler may need to allocate registers as temporary storage in 
machine code routines, there are some restrictions placed on your register 
usage. The compiler will automatically free all registers which are volatile 
across a call for your use (that is DO, Dl, AO, Al, FpO, Fpl). 

If you reference any other register, the compiler will reserve it for your use 
until the end of the machine code routine. The compiler will not save the 
register automatically if this routine is inline expanded. This means that 
the first reference to a register which is not volatile across calls should be 
an instruction which saves its value in a safe place. 

The value of the register should be restored at the end of the machine code 
routine. This rule will help ensure correct operation of your machine code 
insert even if it is inline explained in another routine. However, the 
compiler will save the register automatically in the prolog code for the 
routine and restore it in the epilog code for the routine if the routine is 
not inline expanded. 


C-28 





APPENDIX F OF THE Ada STANDARD 


4.10.8. Data Directives 

Four special instructions are included in package Machine_Code to allow the 
user to place data into the code stream. These four instructions are DATA8, 
DATA16, DATA32 and DATA64. Each of these instructions can have from 1 to 6 
operands. 

DATA8 and DATA16 are used to place 8-bit and 16-bit integer data items into 
the code stream. 

DATA3 2 is used to place 32-bit data into the code stream. The value of an 
integer, a floating-point literal, or the address of a label or a routine are 
the legal operands (i.e. operands whose address mode is either Imm, 
Float_Lit_Single, or Symbolic_Address of an Ada object). 

<< LI >> 

Three_Opnds' (DATA32, (S:imibolic_Address , Ll'Address), 

(Float_Lit„Fingle, 2.0), 

(Imm, 99)); 

will produce a code sequence such as: 

LI: .long LI 

.long 1073741824. | 0.2el 

.long 99 

DATA64 is used to place a 64-bit data into the code stream. The only legal 
operand is a floating literal (i.e operand whose address mode is 
Float_Lit_Single or Float__Lit_Double) . 

4.10.9. Inline Expansion 

Routines which contain machine code inserts may be inline expanded into the 
bodies of other routines. This may happen under programmer control through 
the use of pragma INLINE, or with the optimization levels standard and 
time(UNIX: -Op2 and -Op3; VMS: /optimize=standard and /optimize=time) when the 
compiler selects the inline optimization as an appropriate action for the 
given situation. The compiler will treat the machine code insert as if it 
were a call. Volatile registers will be saved and restored around it and 
similar optimizing steps will be taken. 

4.10.10. Unsafe Assumptions 

There are a variety of assumptions which should not be made when writing 
machine code inserts. Violation of these assximptions may result in the 
generation of code which does not assemble or which may not function 
correctly. 

- Do not assume that a machine code insert routine has its own set of local 
registers. This may not be true if the routine is inline expanded into 
another routine. Explicitly save and restore any registers which are not 
volatile across calls. If you wish to guarantee that a routine will 
never be inline expanded, you should use an Ada separate body for the 
routine or compile at an optimization level lower than the default. Then 
make sure there is no pragma INLINE for the routine. 

Values should not be assigned to the frame pointer register in the middle 


C-29 




APPENDIX F OF THE Ada STANDARD 


of a machine code insert routine, even if your code saves and restores 
the contents of the register. A dangerous situation can arise if an 
exception is propagated through the procedure frame, or if a machine code 
insert references a variable that uses a frame pointer in the address 
formula. 

- Do not assume that the 'Address on Symbolic_Address or Symbolic_Value 
operands means that you are getting an Address to operate on. The 
Address- or Value-ness of an operand is determined by your choice of 
Symbolic_Address or Symbolic_Value. This means that to add the contents 
of X to DO, you should write 

Two_Opnds'{ADD_L, (Symbolic_Value, X’Address), (DR, DO)); 
but to add the address of X to DO, you should write 

Two__Opnds'(ADD_L, (Symbolic_Address, X'Address), (DR, DO))/ 

- The compiler will not generate call site code for you if you emit a call 
instruction. You must save and restore any volatile registers (DO, Dl, 
AO, Al, FpO, Fpl) which currently have values in them. If the routine 
you call has out parameters, a large function return result, or an 
unconstrained result, it is your responsibility to emit the necessary 
instructions to deal with these constructs as the compiler expects. In 
other words, when you emit a call, you must follow the linkage 
conventions of the routine you are calling. For further details on call 
site code, see sections 5.4, 5.5, and 5.6. 

- Do not attempt to move multiple Ada objects with a single long 
instruction such as MOVE. Although the objects may be contiguous under 
the current circumstances, there is no guarantee that later changes will 
permit them to remain contiguous. If the objects are parameters, it is 
virtually certain that they will not be contiguous if the routine is 
inline expanded into the body of another routine. In the case of locals, 
globals, and own variables, the compiler does not guarantee that^ objects 
which are declared textually ''next'' to each other will be contiguous in 
memory. If the source code is changed such that it declares additional 
objects, this may change the storage allocation such that objects which 
were previously adjacent are no longer adjacent. 

4.10.11. Limitations 

- The current implementation of the compiler is unable to fully support 
automatic correction of certain kinds of operands. In particular, the 
compiler assumes that the size of a data object is the same as the number 
of bits which is operated on by the instruction chosen in the machine 
code insert. This means that in the insert; 

Two_Opnds'(ADD_B, (Symbolic_Value, Integer_Variable'Address), (DR, DO)) 

the compiler will assume that Integer__Variable is 8 bits wide, when in 
fact it is stored in 32 bits of memory. 

Mote that the use of X'Address in a machine code insert does not 
guarantee that X will be bound to memory. This is a result of the use of 
'Address to provide a ''typeless'' method for naming Ada objects in 
machine code inserts. For example, it is legal to say (Symbolic_Value, 


C-30 




APPENDIX F OF THE Ada STANDARD 


X’Address) in an insert even when X is found in a register. 

- Absolute Short Address Mode with a symbolic operand is not supported. 
For example, the following operand is illegal: 


(A^^-^Short, Some_Variable'Address) 

- In Address Modes in which two displacements are allowed only base 
displacement can be represented by a symbolic address. Outer 
displacement must be an integer. For example, this operand is legal: 


(MEMP0ST2, BD_MEMP0ST2 => Some_Routine’Address, — base Displacement 


AN__MEMP0ST2 => 
XN_MEMP0ST2 => 
XN_SIZE_MEMP0ST2 => 
SCALE_MEMP0ST2 => 
OD MEMP0ST2 => 


AO, 

DO, 

LONG, 

ONE, 

16) -- outer Displacement 


while the following operand is 


illegal: 


(MEMP0ST2, BD_MEMPOST2 
AN_MEMPOST2 
XN_MEMP0ST2 
XN_SIZE_MEMPOST2 
SCALE_MEMPOST2 
OD_MEMPOST2 


=> Routine_l'Address, 
=> AO, 

=> DO, 

=> LONG, 

=> ONE, 

=> Routine_2'Address) 


--base displacement 


—outer Displacement 


- PC-relative Address Modes with a suppressed base register field can 
sometimes be handled incorrectly by the current implementation of the 
compiler. 


- Extended-precision floating-point literals are not supported. 


4.10.12. Address_Mode Usage 

- Addressing modes that accept 16 or 32-bit displacements are represented 
by two entries in package Machine_Code's Address_Mode enumeration: one 
that accepts an integer, and one that accepts a symbolic address. For 
example. Memory Indirect Pre-Indexed addressing mode is represented by 
MEMPRE and MEMPRE2 Address Modes. 

- DARI (Data or Address Register Indirect) Address_Mode is provided 
exclusively for use with operands five and six of the CAS2 instruction. 

- ARIDX (Address Register Indirect with Index and Displacement) 

Address_Mode represents both the 8-bit displacement and the base 
displacement sub-modes of the Address Register Indirect with Index 
addressing mode. The compiler will pick the most economical form. 

- PCIDX (Program Counter Indirect with Index and Displacement) Address_Mode 
represents both the 8-bit displacement and the base displacement 
sub-modes of the Program Counter Indirect with Index addressing mode. 
The compiler will pick the most economical form. 


4.10.13. Instruction_Mnemonic Usage 

- Instruction_Mnemonic names in package Machine_Code are formed by 


C-31 




APPENDIX F OF THE Ada STANDARD 


concatenating the base instruction name with a suffix representing the 
size of the instruction. For example, CMP_B, CMP_W, and CMP_L are 
package Machine_Code entries for the 68xxx CMP instruction. If the 
instruction exists in a single size only, it is represented by two 
entries in package Machine_Code: one with and one without a suffix. For 
example, the 68xxx LEA instruction is represented by ~EA and LEA_L. 
Unsized instructions are represented by their base names with no suffix. 

~ For instructions that operate on control registers the control register 
operand needs to be explicitly supplied in the machine code insert; 

Two_Opnds'(AMDITOCCR, (Imm, 3), (CR, CCR)); 

- For Conditional Branch, Branch Always, and Branch to Subroutine 
instructions an unsized entry (for example, BEQ) lets the compiler pick 
the instruction of the optimal size. 

” BSRNORET and JSRNORET mnemonics are aliases for BSR and JSR respectively. 
Use them when a called routine is known to never return. 

~ The digit in the mnemonics of the Co-Processor instructions (cp*) 
indicates the number of optional co-processor defined extension words. 

- When using MC68881/MC68882 unary instructions which operate on a single 
floating-point register, the register operand needs to be supplied as 
both the source and the destination operand: 

Two^Opnds‘(FCOSH_X, (FPR, FPl), (FPR, FPl)); 

The FTST instruction is the exception to this rule: 

One_Opnds'(FTST_X, (FPR, FPl)); 

- When using CPU32 Table Lookup and Interpolation instructions, the Dn 
register-pair operand needs to be supplied as two separate operands of 
the machine-code insert. For example, 

Three_Opnds' (TBLS_L, (DR, DO), (DR, Dl), (DR, D7)); 
will emit the TBLS.L D0:D1,D7 instruction. 

- MC68881/MC68882 instruction Move System Control Register, FMOVE is 
represented by several individual instructions, each of which requires an 
explicit control register operand: 

Two__Opnds ' (FMOVETOFPCR, (DR, DO), (CR, FPCR) ) ; 

- FSINCOS instruction returns the sine in its second operand and the cosine 
in its third operand. 

- MC68881/MC68882 Move Multiple Data Registers, FMOVEM^X and Move Multiple 
Control Registers, FMOVEM_L instructions, expect the register mask 
operand to be represented by an integer literal: 

Two^Opnds'(FMOVEM^X, (Imm, 3), (ARI, AO)); 


4.10.14. Example 



APPENDIX F OF THE Ada STANDARD 


with Machine_Code; use Machine_Code; 
with System; use System; 

procedure SinCos(Source 
Sin 
Cos 

begin 

Compute sine and cosine of Source and return them in 
— parameters Sin and CoS; respectively 

Three_Opnds' (FSINCOS_D, {Symbolic_Value, Source’Address) , 

(FPR, FPO), 

(FPR, FPl)); 

Two_Opnds'{FMOVE_D, (FPR, FPO), (Symbolic_Address, Sin’Address)); 
Two_Opnds’{FMOVE_D, (FPR, FPl), (Symbolic_Address, Cos'Address)); 

end SinCos; 

Assembly code output: 

. data 

.globl _aOfsincos 
. text 

__aOf sincos: 

link a6,#0 

clrl a7@~ 

fsincosd a6@(8:w),fpl:fpC 
fmoved fpO,a6@(16:w) 
fmoved fpl,a6@(24:w) 

unlk a6 


I Total bytes of code in the above routine =28 
. text 


in Long_Float; 
out Long_Float; 
out Long_Float) is 


. even 

I Total bytes of code = 28 
I Total bytes of data = 0 

4.11. INLINE GUIDELINES 


The following discussion on inlining is based on the next two examples. From 
these sample programs, general rules, procedures, and cautions are 
illustrated. 


Consider a package that contains a subprogram that is to be inlined. 


package In_Pack is 

procedure I_Will_Be_Inlined; 
pragma INLINE(I_Will_Be_Inlined); 
end In_Pack; 


C-33 





APPENDIX F OF THE Ada STANDARD 

Consider a procedure that calls the inlined subprogram in the previous 
package. 

with In_Pack; use In_Pack; 
procedure Uses_Inlined__Subp is 
begin 

I_Will_Be„Inlined; 
end Uses_Inlined_Subp; 

After the package specification for In_Pack has been compiled, it is possible 
to compile the unit Uses_Inlined_Subp that calls’ the subprogram 

I_Will_Be_Inlined. However, because the body of the subprogram is ^ not yet 
available, the generated code will not contain an inlined version of the 
subprogram. The generated code will use an out of line call to 

I__Will_Be_Inlined. The compiler will issue warning message number 2429 to 
inform you that the call was not inlined when Uses_Inlined_Subp was compiled. 

If In_Pack is used across libraries, it can be exported from the root library 
after you have compiled the package specification. Note that if only the 

specification is exported, there will be no inlined calls to In^Pack in all 

units within libraries that import In_Pack. If only the .specification is 
exported, all calls that appear in other libraries will be out of line calls. 

The compiler will issue warning message number 2429 to indicate that the call 

was not inlined. 


There is no warning at link-time that subprograms have not been inlined. 

If the body for package In_Pack has been compiled before the call to 
I_Will_Be_Inlined is compiled, the compiler will inline the subprogram. In 
the example above, if the body of IN_PACK has been compiled before 

Uses_Inlined_Subp, the call will be inlined when Uses—Inlined_Subp is 

compiled. 

Having an inlined call to a subprogram makes a unit dependent on the unit that 
contains the body of the subprogram. In the example, once Uses_Inlined_Subp 
has been compiled with an inlined call to i_Will_Be_Inlined, the unit 
Uses_Inlined_Subp will have a dependency on the package body In_Pack. Thus, 
if the body for package body In_Pack is recompiled, Uses_Inlined_Subp will 
become obsolete, and must be recompiled before it can be lirked. 

It is possible to export the body for a library unit. If the body for package 
In_Pack is marked as exported in the root library using the Ada librarian 
subcommand export compilation unit, other libraries that import package 
In_Pack will be able to compile inlined calls across library units. 

At optimization levels lower than the default, the compiler will not inline 
calls, even when pragma INLINE has been used and the body of the subprogram is 
in the library prior to the unit that makes the call. Lower optimization 
]_ 0 vels avoid any changes in the flow of the code that cause movement of code 
sequences, as happens in a pragma INLINE. When compiling^ at a low 
optimization level, you will not be warned that inlining is not being 
performed. 


C-34 




