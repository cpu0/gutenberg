A UNIFIED DATA FLOW MODEL FOR 
FAULT TOLERANT COMPUTERS 


N 8 4 - 2 2 
N 84 - 


2 SO 

O O q 0 


Final Report 


T . R . Rao 

V . V . Ramanamurthy 
Abbas Youssefi 

University of Southwestern Louisiana 
Lafayette , Louisiana 

and 

E. M. Eavl 

University of Texas at Arlington 
Ar llngt on , Texas 


April 25, 1984 


This report is supported by researob grant NAG - 1 - 271 


I. INTRODUCTION 


We have used the Dataflow Simulation System (DPSS) at USL 
as the medium on whioh we have produced a functional simulation 
of SIFT. DFSS is written in PL/ I and is supported by MULTICS. 
Within the. simulation, all the interprooessor communication, 
fault simulation, system state data, and monitoring were 
implemented in dataflow and supported direotly by DFSS. The 
actual processor level computation was oarried out by the SIFT 
oode in PASCAL. The interface between DFSS in PL/ I and the SIFT 
oode in PASCAL was supported under a mechanism in. DFSS called a ■< 
Node Realization Module (NRM) . 

There were several reasons for making these choices for 
this initial simulation. The first reason was that these ohoioes 
allowed us to effectively use' the SIFT oode that was available. 
Also, DFSS supported the addition of appropriate monitoring and 
fault simulation meohanlsms. Another reason involved the faot 
that this preliminary simulation should point out some of the 
limitations of the current, dataflow simulator and provide useful 
information in designing the new dataflow simulator in PASCAL. 
The primary reason for using dataflow only at the highest levels 
of SIFT was related to the way interprooessor communication took 
place in the last version of SIFT. Virtually any procedural 
process' oan be simulated in dataflow on DFSS. However, as a 
system simulation medium, dataflow worked best in dealing with 
parallel , asyohronous , nnmnmTit noting processes . 


This report, is divided into three seotions and eaoh of 
these seotions describes different phases of the simulation of 
SIFT on DFSS. Seotion II outlines briefly the changes that 
have been made to the SIFT oode so that the program oould be run 
on the PASCAL oompiler at USL. Seotion Iir gives the interface 
mechanism between the SIFT oode in PASCAL and the PL/ I program. 
This is neoessary to include SIFT oode as a node within the 
dataflow graph. In seotion IV the simulation of a single 
processor on the DFSS is described with the basic structure of 
the node. This seotion also describes an approaoh to the 
simulation of the oomplete system with n (n=5) processors. The 
interprocess oommunioation buffers are oonourrent aooess files 
with eaoh of the processors having aocess to them as required by 
the operating system. This is achieved by means of the a PL/ I 
interface program. The details are given in the speoific 

seotion. 

IL. SIEI PASCAL CODE 

Some funotiofcs in SIFT oode were realized in the 
assembly language of BDZ 930. In order to obtain the same hind of 
aoouraoy of numerical values oomputed by these functions', they 
were translated into PL/I. PL/ 1 was used mainly to utilize the 
range of options available in obtaining the required aoouraoy. 

The language dependent routines BAND (bitwise 'and') and 

BOR (bitwise 'or') were written in PL/I. To use these PL/1 

« 

routines the statements oontaihing the aotual functions were 
modified. 


- 2 - 


For example: 


(framecount mod schedstvp+1] ) 
was changed to 

mod( f rameoount , scheds [ vp+ 1 ] ) ; 


(eofbit band dbx*8) 
was changed to 
band( eofbit ,dbx* 8) ; 

Another ohange was made to the oode. All the looatlon 
dependent variables were made independent of the system . The 
'at' oonstruot used in the original oode was not present in 
either version of PASCAL oompilers available at USL. So these 
variables were made independent of the looations in memory. In 
fact, beoause of the virtual memory system on MULTICS, no 
construct forcing statio memory location is available. This 
problem is overoome simply by removing the 'at' {looation} from 
the variable declaration part. 

For example: dbfile at dbloo : integer; 

is ohanged to 
dbfile : integer; 

The system dependent routine 'gprooessor' is not neoessary 
beoause the processor id oould be initialzed at the beginning of 
the prooess. The new version of the SIFT oode is in Appendix - 
I. . 


- 3 - 



III. imBEACE PROGRAM 


In order to realize the node realization module as 
described in [13, we used a PL/ I program which called the SIFT 
oode as a subroutine and there should be a oorrespondance between 
the two. While passing the parameters of type array or structure 
(record), a pointer to an array or a structure was passed. An 
array or a structure of same type was declared in the PL/I 
program with a pointer. This pointer was then equated to the 
external pointer (PASCAL pointer). 

An example to refleot the parameter passing mechanism is t 
given : 

PASCAL declaration : dffile : array(0: 1023) of integer; 

dfptrpas : 

PL/I declaration : dol dfile(0: 1023) fixed bin(35) based(dfptr) ; 

dfptr =■ dfptrpas; 

With the above statement, any reference to the PL/I array 
element was reflected in the corresponding PASCAL array. All the 
other simple variables were external .This program is in Appendix 
- II. 

This PL/ I program also realized the interprooessor 
oommunloation through a prooedure whioh was oalled whenever the 
transaction pointer in the "broadcast” or “stobroadoast ” routine 
of the SIFT oode was set. The interprooessor buffers were 
concurrent aooess files and these could be aooessed and oheoked 
after every subframe. 


{ 


- 4 - 



11 . SIMU LA TION QZ SIEE ON DFSS 

Each individual processor node within the dataflow graph of 
complete system is given in figure 1. The dataflow program to 
realize this basio node is given in Appendix - III. With each of 
these nodes representing a processor, oomplete simulation with n 
(5) processors was attempted. Eaoh processor was supposed to 
execute the current sohedule : oompute, broadcast, and vote 

according to sohedule and assume that the other processors are 
also doing the same thing. The behavior of a processor is not 
immediatly changed if oommunioation breaks down or computation ! 
faults ooour. The only ohanges in the behavior of the processor, 
oaused by failures in interprooessor oommunioation, are long 
term. If failures take plaoe, eventually a reconfiguration will 
ooour. ~ 

The error buffer data and the data buffer values could be 
examined through the PL/ 1 interface program at the end. of every 
subframe . 

The details of the scheduling tables oould not be worked 
out as expected due. to the faot that these were wirtten in 
assembly language of BDX 930. In effect, the bottleneck in . 
implementing the simulation was the scheduling tables. 

\ 



- 5 - 



ON DATA FLOW SIMULATOR 


The major responsibility of the research team at the 
University of Texas at Arlington was the design of a data flow 
language and a data flow simulator for this language written in 
Pascal for VAX/780 system. 

DFDLS (pronounced as daffodils) is such a data flow 
simulator written in Pascal and at present is available on DEC 20 
system. It will be available on VAX/780 soon. Simulation of 
computer systems, both hardware and software, can be performed 
using data flow concepts. For an introduction to data flow, the 
reader is referred to ktt . 

The major features of DFDLS are given below. 


1. Tokens on data flow arcs can be structured data items. 
Existing data flow computers and languages permit only 
elementary data types like integer, real and characters. 
DFDLS allows all the Pascal data types. At this time, 
record data types are not processed, but will be included 
soon . 

2. Firing set semantics can be specified in DFDLS. In the 
basic data flow, a node is enabled for execution only when 
all input arcs contain tokens and no tokens are present on 
the output arcs. This firing semantics are extended in 
DFDLS by describing alternate firing sets. Each set defines 
the mandatory input values required for the node to 
execute. 

3. Nodes in DFDLS can be data flow subgraphs. In most of 
the existing data flow systems only primitive functions 
such as ADD two numbers are permitted. In our system, a 
node can be a primitive function defined by the system, a 
data flow subgraph or a Pascal procedure provided by the 
user. These Pascal procedures are linked dynamically by the 
runtime environment. 

4. The input language is very simple. DFDLS interprets 
simulation models expressed in our textual language. There 
is a one-to-one correspondence between the data flow graphs 



and the textual representation. Thus, data flow graphs can 
be translated directly into the input language. This also 
provides for graphical interface that can be designed at a 
later date. 

5. Block structures and Recursion: The present 
implementation of DFDLS permits a restricted block 
structure in that, all names must be unique. Recursion is 
not allowed. However, we are in the process of extending 
DFDLS to allow more general nesting of blocks and 
recursion. Because of our data structures and modular 
design of DFDLS, this addition is straight forward. 
Separate descriptor tables and node tables will be created 
for each block and display stack will be used to implement 
recursion and static scopes. 

A complete description of DFDLS and a detailed outline of the 
design can be found in . 

We made every attempt to complete the design and testing of 
DFDLS on VAX/780 before the end of 1983. However, due to 
unforeseen problems, we are only able to complete the design and 
test DFDLS on DEC 20. We would like to describe briefly.the 
technical problems faced by the. research team at UTA. 

Due to the policies of the board of Regents of the state of 
Texas, the acquisition of VAX was delayed by several months. The 
hardware had arrived at UTA in December 1983. We are awaiting the 
installation of a new air-conditioning equipment before bringing 
up the VAX system. 

The unversi ty and the department of Computer Science and 
Engineering have seen significant increases in the enrollment. 
The computing facilities are not adequate to handle the increase, 
resulting in severe restrictions on the use of disk space, access 
to terminals and in general, degraded response time. 



The current version of DFDLS is being implemented on DEC 
20/60 computer system, awaiting the arrival of VAX 780. Although 
most of the code for DFDLS is written in Pascal and thus 
portable, the section that dynamically links user supplied Pascal 
procedures with the runtime environment of DFDLS is very machine 
dependent and must be rewritten for VAX. 

During the execution of a data flow program, the function of 
a data flow node can be realized by invoking either system 
provided Pascal procedures (Library functions) or user provided 
procedures. This facility enables us to add reliability 
calculations to the simulator. There is no easy way of linking 
programs dynamically on DEC 2060 system. Several alternatives 
have been considered and discarded due to the complexity of 
impl ementat i on . 

A dynamic linker could be' written with DFDLS to interface 
with the standard DEC linker provided. This requires significant 
amount of code in Macro-assember for DEC 2060. Since DFDLS will 
be transported to VAX, this solution was discarded. Pascal 
procedures could be added to the DFDLS and the entire system 
could be recompiled and. linked for each run. This solution was 
not entertained because of the inefficiency. 

Our next choice was to have the NRM (node realization module) 
to invoke the user supplied procedure as a separate task with the 
data space mapped into the data space of DFDLS. It was hoped that 
this option would allow access to parameters similar to call by 



reference technique. However, two problems exist with this 
method. Sharing of data space is not possible because the 
sub-process < correspond! ng to the user supplied procedures) would 
overlay the DFDLS space resulting in the destruction of crucial 
data belonging to the simulator. The second problem arises from 
the fact that in order to invoke sub-tasks, it is necessary to 
make user procedures as independent programs. This would require 
that the user write programs instead of procedures to link with 
the runtime environment of DFDLS. 

Despite of the restrictions imposed by the last solution, we 
have decided to pursue this approach in implementing DFDLS on DEC 
2060. We will relax these restriction in VAX 780 implementation. 
In the present solution to the linking problem, user supplied 
Pascal procedures are made into complete programs and DFDLS will 
communicate with these programs through standard disk files. The 
parameters are written into files and read from files by both 
user programs and DFDLS. 


2. REPORT ON RELIABILITY MODELS FOR DATA FLOW 


The research team at UTA has also attempted to develop 
reliability models for data flow graphs, so that the reliability 
of computer systems modeled as data flow graphs can be predicted. 
To our knowledge there exists no published reliability studies of 
data flow systems. A survey of related models can be found in 
[ 3] . 

A recursive algorithmic method can be used to determine the 
reliability of a data flow graph. The reliability of the output 
from a node depends on the reliabilities of the inputs to the 
node and the reliability of the node itself. 


1 


2 


N 


— V — V V 

NODE 


V 

0 


R< 0) = gC f< Rl, R2 RN) , Rnode > <1> 


FIG. 1 


RELIABILITY OF A DATA FLOW NODE 



Here f i s a combi nator i al -function describing the input 
configuration of the node, R1 , R2 , RN are the 
reliabilities of the inputs and Rnode is the reliability of the 
node. The node in the above calculation can be a subgraph, thus 
providing for a recursive definition. 

2.1 Our Approach: 

We have developed a method that combines Markov processes 
with the recursive algorithmic method described above. A path 
from an input of a data flow graph to an output of the data flow 
graph is defined as the alternating sequence of arcs and nodes, 
al , nl, a2, n2, ...., ao, where al is the input arc and ao is the 
output arc. The reliability of the path can be determined using 
Markov methods. 

A significant structural property of a data flow system is 
its capability for parallel processing with split and merge of 
job streams at various levels. This leads to multiple parallel 
paths between an input to the data flow graph and an output from 
the data flow graph. The parallel paths need not be independent. 
The dependencies will be handled by the algorithmic method. 

For example, let there be M parallel paths between a given 

input and output of the system. Let R be the overall reliability 

/ 

of the output with respect to the given inputyi which is to be 
determined. Also, suppose R1 , R2, . . . . , RM be the correspond^ ng 
reliabilities of the M parallel paths, obtained using Markov 
methods. Then R is given by 



R 


9 ( R1 , R2 , 


, RM ) 


< 2 ) 


\ 

where q is the function describing the i n ter-re i at i onsh i ps 

y 

between the parallel paths. 

The reliability measure of the entire system can be obtained 
by calculating the reliabilities of all outputs from the system 
with respect to every input to the system. We are currently 
working with this method and developing the algorithms required 
to compute the i n ter-re 1 at i onsh i ps between the parallel paths. ■ 


3. RERERENCES 




C13. Rao/ T .. R and Myers L» foreman# "A Unified Data Flow Model 
for Fault Tolerant Computers"# Memorandum #3 01/03/1983. 


C 2 3 . Treleaven, P.C., Brownbr i dge , D.R. and Hopkins, R.P. "Data 
Driven and Demand Driven Computer Arch i tecture “ , ACM Computing 
Surveys, March 1982. 

C 3 ] . Kav i , K.M. “Data Flow Models For Fault Tolerant Computers" , 
Interim Progress Report for NASA Grant NAG-1-271, UTA Tech Rept. 
CSE 33—3 , Nov . 1 983 . 


I 


i 


> 









Appena i x 




ogram news i ft ( input, output* datafileOi ); 
xport c 1 dc k, d f p trpas $ 
procedure band (var a* b integer) 

procedure bor( var a* b integer) 

net 


e x terna 1 » * ) 
e x terna 1 » * ) 


maxtime=71; 
ma x data = 101 5, 
ma x trans=1023> 
maxdb=l27, 
d b s i ze=128; 
eof bit=32768, 
ma x p r oc essors=7i 

maxstate= 128 , 

ma x f rame=7; 

maxsubframe=2i, 

maxreconfig=1791, 

ma x b inf =200, 

tpba5e-=:B96; 

magi c=769; 

tpc lock=1019; 

tas ks=l2; 

ma x b uf §=1 19; 

tentrysi ze= 133, (* 5 


(* max skew allowed in clock task «) 

(«• highest address m the datafile *■> 

(•* highest address m the trans. file *) 

Ot highest address in a databuffer *■> 

(■> size of a databuffer •») 

(•* end of file bit for transaction «•) 

(■* highest processor number less 1 ») 

Ot largest number of items in a statevector -*) 
(it Maximum frames in a cycle. #■) 

(■* last subframe in a frame #) 

(# Number of elements in reconfig schedules ■>) 
(at maximum for table which tasks broadcast *) 
(it minimum value of the transaction pointer ■>) 
(* 2*tpbase-1023 *> 

(* clock in datafile. •») 

(it number of tasks in the system *) 

(it maximum number of buffers ■*) 
maxstate; *> (it size of a task entry it) 


ttsize=s 1729i ( ittentrys i ze it <tasks + i>;#> ( » size of the task table. #> 


(it The following constants define scheduling masks 


datamask=4097; 
e x tendmas k=8192, 
contmas k=4096, 
suspmas k=204B, 


(it Data portion of a schedule entry *•) 

(tt Extended task entry *) 

(it Continue prior execution only ■*) 

(# Task may be suspended at clock tick it) 


(it the following 


are constants 


to be used when refering to buffers. -*> 


er rerr=33; 

gexecreconf=34; 

qexecmemory=35; 

expected=36; 

lock=37, 

ndr=38, 


xreset=39, 

(* The q series is the 1553a input value. The a, b, and c series 
are the values re-broadcast as part of interactive consistency, 
corresponding to the 1st, 2nd and 3rd input processors. * > 


( a note — for phase 2 the q buffers have been eliminated, data is 
now input into a, b or c buffers for p's 1,2 and 3 respectively ■»> 


astar t=40, 

aalpha*=40, abeta=41« acmdalt=42; acmdhead=43i ad i stanc e=44, 
ag 1 ideslope=45, alocali zer=46, ap=47; aphi=48; aphitrn=49, 

apsi=50, aq=51» ar=52; aradius=53; arturn=54; atheta=55, 

a u=56; ax3=57i axcntr=58; ay3=59; ay cntr=60; 

a last= 60 ; 


balpha=61, bbeta=62; bcmdalt=63, bcmdhead=64, b d i stanc e=65. 



b g 1 i d es lope=66i b local i zer=67; bp=68; bphi=69; bphitrn=70; 

bpsi=71. bq=72, br=73; bradius=74; brturn=75; btheta=76; 
bu=77/ bx3=78> bxcntr=79, by3=80; bycntr=Sl; 

calpha=82< cbeta=83; ccmdalt=84; ccmdhead=85, c d i stanc e=86< 
eg 1 ides lope=37. c local i zer=B8; cp=89, cphi=90# cphitrn=91; 
cpsi=92; cq=93/ cr=94; cradius=95; crturn=96; ctheta=97i 
cu=98; cx3=99; cxcntr=100; cy3=101; cycntr=102; 

(* The o series are the 1553a output values «■) 

ostart=103; must correspond to first of o series *) 

qcmdail=103, qcmdele=104; qcmdrud=105, qcmdthr=106, 
qdely=107i qdelz=108; qpitmo=109; qlatmo=110; qreconf=lll. 
olast=lli; must correspond to last of o series 

osynch=l 12, 

(* Internal values. *> 

phin=113; psin=114; rn=115j 

qx = 116; qy = 117; qz=118; timer=119; 

<* 1553a values. #-) 

appnum = 16< (»timer-ostart + l; •*) 

onum = 103; (-s-ostar t< -* ) (■> beginning of saved region *•> 

num!553a=21< (*alast-astart+l« *> (■* number of items to read ■*) 

onumi553a=9, <-*olast-ostart+l/ -*) (•* number of items to write •*> 

bas 1553a=936, ( #tp base+a start; ■»■) (•* first input location ») 

masl553a=255; (*16#00FF*, •*) (* status bits *> 

outl553a=9; (-a-olast-ostart+l; ■*) < * number of items to transmit «•) 
obas 1 553a=999, (-fttpbase + ostar t; •«■ ) (*• first output location -*) 
sa0=0; (-* subaddress 0*> 

sal=32» ( •*■ subaddress 1 -* ) 

rec 1553a=1024. ( * Receive ■>) 

tral553a=0; («■ Transmit *) 

rtl=2048; (■* remote terminal 1 ■») 

sba s 1 553a=1008i ( *tp base+osync h < * ) (•* synch word *■) 

the following constants are to be used when refering to tasks ■* ) 

nullt=l, (■* the null task *•> 


(•> the following constants specify 
cf loc=16#3400; 

»•* g f r 1 c = 1 6#3800; 
sfc lc = 16#3S01; 
dbloc=16#3802; 

(•> stac k 1 oc = 16#5000< 
tloc = 16#5500; 

(•> numloc=16#6B36; 

C-* pidloc=16#6837; 
i-* vir 1 oc = 16#6S38; 

<■* pvl oc = 16#6840i 
( J * bloc = 16#68CO; 

' * sloc=16#6DOO; 
i* dfloc =1687400; 

<-» pf loc=16#77F8; 


address of some preinited tables 

Address of transaction file * ) 
Address of global framecount *) 
Address of subframe count*) 
Address of dbad. *> 

"Exec Stack" location - siftih *) 
Address of tt. •*) 

Address of numworking *> 

Address of pid. ■>) 

Address of virtno. >) 

Address of post vote buffer •*) 
Address of bt ■> > 

Address of scheds. *) 

Address of datafile. * ) 

Address of pideof. -*) 



»• tploc=16#77F9; 

' > s 1 51 oc = 16#77F9; 

'> elk 1 oc=16#77FB; 
i-» c!51oc=16#77FD; 

a 1 51 oc=16#77FF; 

•. > i 1 oc = 16#7SOO/ 

<•» dest=16#8000; 
type 

data = file of integer; 
dfindex=0. maxdata/ 
db index =0. . maxdb; 
tpindex=0. maxtrans; 
processor^. . maxprocessors; 
buffer=0. maxbufs/ 


Address of trans pointer ■*) 
Address of sta!553a •* ) 
Address of real time clock •*) 
Address of cmd!553a ■* ) 
Address of adrl553a #) 
Address of buffer info.*) 
eofbit bor loc zero #) 


<# data file *) 

(«■ data buffer *> 
(■»• transaction file •» ) 

(» processor •>) 

(* one for each buffer. ■*) 


task=0 tasks; (* one for each task «■) 

b uf mt=array Cbuf f er 1 of integer/ 
pr oc int=array Cproc essor 3 of integer/ 

proc boo l=array [processor] of boolean; (■* beware addr •*) 
bufrec=record dbx - integer/ ad. procmt end; (* beware addr * ) 
d f t y pe=array Cdf ind e x 1 of integer; 
tf ty pe=array C tp mde x 3 of integer/ 
statevector=array CO. maxstatel of integer/ 

schedcall = (taskternunationi clockinterrupt / systemstartup); 
dfptrty = ''dftype; 
task entry =record 

status schedcall; (*■ cause of the last pause •>) 

bufs integer/ («• ptr to list of bufs broadcasted. #) 

errors. integer/ (# Number of task overrun errors #) 

stkptr integer; ( last stack pointer *) 

state statevector/ («• stack for task * ) 


end / 


var 

datafileOl . data/ 
dfptrpas dfptrty; 
datafile : dftype/ 

transfile . tftype; 

transptr integer; (* transaction pointer *) 

pideof integer/ (* processor ID discrete (read) •») 

(* end of file discrete (write) *) 
scheds : arrayCO . ma xreconf i g 3 of integer; 

(•* Precomputed schedules f orr ec onf l g ura 1 1 on *) 
postvote bufint; <* post vote buffer #) 

dbad procmt; (* index to start of data buffer for each proct 

bt array C b uf f er 3 of bufrecz (* where and who broadcast mg* > 

tt • arrayCtaskl of taskentry/ (* Task Table ») 

binf • arrayCO. maxbinfl of integer; (* bufs where' 7 •*) 

clock integer; (■* real time clock (read/write)*) 

cikl integer; <•* used to prevent optimization *) 

adrl553a integer; (4 1553a address register -*> 

cmdl553a ; integer/ (* 1553a command register -*> 

stal553a integer/ <# 1553a status register •*) 

p id • integer/ (» Ky processor number <) 

numworking integer; Number of working processors *) 

virtno . procmt; < * Virtual processor numbers. * ) 

gframe . integer/ <■* global frame count ■») 

sfcount ; integer; <* sub frame count «■) 


{./. p4deec var •*> 



• votecnt, vtime/ wtime/ delta: integer; 


working- procbool; <* 

pi V/ errors’ procmt; (# 

pi/ p2< p3i p4< p5< vl< v2» v3i v4» v5: integer; 

taskid task; (# 

taskbits: integer; (# 

lastconfig: integer; (* 

pc 1 oc ki cc 1 oc k> b c 1 oc k< ac loc k , (■* 

tp, vp< cptr. (* 

tp i / vp i / cp tr i / (# 

framecount. integer; (* 

sk eu. proc l nt; 

teatime- integer/ (# 


Working processors ->) 
voting *) 

<* more voting #) 

Number of currently running task *) 
Control bits associated with task *) 
The last configuration *) 
globals for clock synchronization *) 
schedule pointers as above. -*) 
start of schedule pointers. -*) 

The current frame count •*) 

For timing the clktask *) 


lines# pages/ pagelimit/ reason- integer; 
fatal: boolean/ 

hit true/ errtr/ vottr/ rectr: boolean/ 


runid 
minutes 
ts k st 
ts k f n 
hlttb 
err tr b 
vottrb 
rec trb 


integer/ 

integer/ 

integer; 

integer/ 

boolean; 

boolean; 

boolean/ 

boolean/ 


sk arrayCO. 8013 of integer; 
skptr integer/ 


stop: integer; 


1 > include 'p4dec con'; 

'.nclude ' p4dec glo'/ 
include 'p4dec. var ' / ■«■) 

(•-►procedure gprocessor; * ) 

{* Set the current processor as a number between 0 and ma xpr oc esors. •> ) 
<-*beg in*) 

(■> pid .= ((pideof div 4000B ) band 16#0F)-1*> 

(■'►end/ gprocessor *> 

function band(a/ b. integer): integer/ 

cegin band := a + b ; end; 

function bor(a/b : integer) integer/ 

oegin bor : = a - b/ end; 

procedure dbaddrs; 

(* calculate the index of the start of each of the databuffers. 

This is harder than it seems because it is a function of the 
processor number. *) 

var 

i / ad: integer/ 
begin 

ad . = 0; 

for i : = 0 to pid-1 do 



begin 

dbadCil : = ad> wr i te 1 n ( ' dbad C i 3= ' , dbad C i 3 ) i 
ad .= ad+dbsi ze, wr iteln ( 'ad = ', ad); 
end ; 

•for 1 = pid + 1 to maxprocessors do 

begin 

dbadCil : = ad , ur i te In ( 'dbad C i 3 , dbadCi3); 

ad : = ad+dbs i z e; wr i te In ( 'ad = ', ad); 
end ; 

dbadCpid] .= ad; (* there isn't really one, but #) 

and; < •* dbaddrs > ) 


procedure work , 

< -a- At startup, identify which processors are nominally working a ) 

var 

i integer; 

oagin 

for i = 0 to maxprocessors do da taf i 1 e C dbad C l 3 3 = -1, 

wr i te In < ' dbad C l 3 = ' , d bad C i 3 ) ; 

( ■* uia 1 1 ( 1 ) , * ) 

dataf i 1 e CB963 .= pid, 
transf l leE7693 .=32768; 

transptr = 896 ; (*■ initiate the broadcast. #) 

' ua 1 1 ( 1 ) , # ) 

numwork ing • = 1, 

for i : = O to maxprocessors do 
if dataf i 1 e Cdbad C i 3 3 = l then 

begin war k ing C i 3 := true; numworking := numworking + 1; 
end 

else workingCil = false; 
war k mg Cp id 3 = true; <* I'm working *) 

end; (# work #) 


procedure synch, 
const 

value = 43690; 

var 

i i j integer; 

cegin (# At startup synchronize the processors *■) 
i • = 7, 

while not work ing Ci 3 do i := l-l , 

<* l points to the highest working processor #) 
j . = dbad C i 3; 
dataf i 1 e C j 3 = O, 

if i = pid then 
begin 

< * wai t ( 1 ) ; * ) 

dataf i 1 e C8963 .= value; 
transf i leC7693 := 32768; 
transptr . = 896; 
while pideof-CO do, 
end 



'• else while dataf i le C j ]<>va 1 ue do; 
and'; (a- synch #) 


procedure fail; 

<* All returned values are wrong, so report all processors involved. 
This could be failed inline/ but it would take too much room. The 
minor additional time that it takes to call the subroutine is 
probably worthwhile a) 

cag in 

errorsCpl3 = error s C p 1 3 + 1 / 
errorstp23 ■ = errorsCp23+l; 
errorsCp33 = errorsEp33+l; 
errors[p4] = error sCp43+l; 
errorsCp53 • = errorsCp53+l; 
faif errtr then pause (43868)-»-) 
end/ (•»■ Pail * ) 


procedure err(p integer)/ 

(a Record an error for processor p. *> 

h a g i n 

errorstp] := errorsCp3+l/ 

(-> if errtr then pause < 43869 )-* ) 
and; ( + err •*) 


function vo t e5< d ef au 1 t : integ er ) ■ integer/ 

(*■ This is the five way voter. It assumes that VI V5 is 
initialized with the 5 values to be voted/ and PI . . P5 
has the corresponding processors. Default is returned in the 
case that there is no majority value. The procedure is basically 
a simple IF tree (pruned where possible) to achieve the quickest 
possible vote *) 
beg in 

if vl = v2 then 

if vl = v3 then 

begin vote5 = vl; 

if vl O v4 then err<p4)z if vl <> v5 then err(p5); 
end 

else if v2 = v4 then 

begin err(p3); if vl <> v5 then err(p5)/ vote5 ; = vl; 
end 

else if vl = v5 then 

begin err(p3); err(p4); vote5 := vl; 
end 

else if v3 = v4 then 
if v3 = v5 then 

begin err(pl). err(p2); vote5 = v3; 
end 


else 



begin fail* vote5 := default/ 
end 

else 

begin fail; vote5 := default; 
end 

else if vl = v3 then 
if vl = v4 then 

begin err(p2)/ if vl <> v5 then err<p5); 
end 

else if vl = v5 then 

begin err(p2); err<p4>; vote5 := vl; 
end 

else if v2 = v4 then 
if v2 = v5 then 

begin err(pl); err(p3); vote5 := v2; 
end 
else 

begin fail/ vote5 .= default/ 
end 

else 

begin fail; vote5 := default/ 
end 

else if v4 = v5 then 
if v2 = v4 then 

begin err(pi)/ if v2 O v3 then err(p3); 
end 

else if vl = v5 then 

begin err(p2); err<p3); vote5 = vl/ 
end 

else if v3 = v5 then 

begin err(pl); err(p2)/ vote5 := v3/ 
end 

else 

begin fail; vote5 := default/ 
end 

else if v2 = vS then 
if v2 = v3 then 

begin err(pl); err(p4) f voteS := v2/ 
end 

else 

begin fail/ vote5 = default; 
end 

else if v2 = v3 then 
if v2 = v4 then 

begin err(pl); err<p5>; voteS := v2/ 
end 

else 

begin fail; vote5 : = default/ 
end 

else 

begin fail/ vote5 := default; 
end / 

nd ; ( * vote5 # > 


voteS : = vl; 


vote5 • = v2z 


unction vote3(default- integer)' integer; 

<» This is the 3 wag voter. It assumes that Vl . V3 contains 



the 3 values to be voted) and that PI . . P3 contains the 
processors. •*) 

• begin 

if vl = v2 then 
begin 

if vlOv3 then err<p3); 

vote3 : = vl ; 

end 

else if vl = v3 then 

begin err(p2); vote3 = vl< 
end 

else if v2 = v3 then 

begin err(pl). vote3 = v2; 
end 
else 

begin err(pl); err(p2); err(p3); 
vote3 : = default, 
end . 

end. <■* vote3 #) 


procedure votetb buff er; default integer); 

va r 

i» j, k : integer, 
begin 

vtime : = clock. 

(# vote buffer b This involves either five way or three way voting. * ) 
< * if vottr then pause ( 16#ABC2) . •» ) 

j • = 0; i . = 0; 
repeat 

k : = btCbl. ad C i 3 » 
if k >= O then 
begin 
J : = J + l' 
pC j3 • = i. 

vC j3 • = dataf ileCk3 
end. 
i ' = i+i ; 

until <j=5> or ( i>maxprocessors ) ; 
if j < 3 then 

postvoteCbl = vC13 
else 

begin 

vl .= vC13; v2 : = vC23; v3 .= vC33» 
pi “ p C 1 3; p 2 = p C 2 3 i p3 ! = p C 3 3 ; 
if j<5 then 

postvoteCb3 vote3 ( d e f au 1 t ) 

else 

begin 

v4 .= vC43; v5 : = vC53» 
p4 : = pC43. p5 : = p C 5 3 ; 
postvoteCb3 .= vo te5 ( d e f au 1 t ) 
end ; 

end . 

dataf i leC tp base+b 3 := postvoteCb3; 

•and; <* vote *■) 


function getvote(b - buffer) : integer ; 

<•*■ this phase two module lets us remove the postvote declaration 
from the applications task module *■) 
o a g i n 

getvote = postvoteCbD/ 
end/ (* getvote *) 


procedure broadcast < b • buff er ) » 

(* Broadcast buffer b. This is provided for applications tasks/ and 
those executive tasks that don't do it themselves. Note - this 
routine does not wait for completion before or after. If that 
is required (for timing reasons) call wa i tbroadcast. •*) 

var 

dbx/tp integer/ 
begin 

dbx .= btCbl.dbx; tp .= dbx+tpbase; 
transf 1 leC2*tp-10233 := b or < eof b 1 1/ db x#8 ) ; 
transptr := tpz <# initiate the broadcast. •* ) 

rewrite(datafileOl); 
dataf ileOl''- = b; 
put(datafileOi); 
end/ (•* broadcast *-) 


procedure stobroadcast ( b, v. integer); 

( * Store v in buffer b and broadcast it *) 

var 

dbxz tp- integer; 
begin 

dbx = btCbl dbx; tp = dbx+tpbase; dataf 1 leCtp 3 = v; 

transf i leC2»tp-10231 := b or ( eof b i t, d b x*8 ) ; 
transptr .= tp; <# initiate the broadcast. * ) 

end/ (•* stobroadcast *> 


procedure waitbroadcast; 
begin 

(* Wait for a broadcast operation to complete. *■> 
while pideof<0 do; 
end; ( * waitbroadcast *■) 



c^oc ed ur e vschedule; 

Vote those items scheduled for this moment. #) 

/ar 

k : integer; 
o eg in 

k = sc h ed s C vp 3 ; 
while k>0 do 
begin 

if ( band ( k> extendmask ) >= 0 then begin vate(kz-l)/ vp = vp + 1 end 
else if (framecount mod scheds Cvp+1 3+1 > = schedsCvp+23 then 
begin 

vote(band(kj datamask)/-l); 
vp : = vp+3 
end ; 

k = schedsCvp3 
end ; ( ■* while «■ ) 

if k >= 0 then vp • = vp+1; 
end/ (*■ vschedule *) 


procedure copschedule. 

<# Copy buffers scheduled for this moment. *> 

var 

c / k : integer/ 

b « g i n 

c • = schedsCcptrl; 
while c >= O do 
begin 

if (framecount mod schedsCcptr+23 ) = schedsCcptr+33 then 
p os tvote C band ( sc h ed s Cep tr+1 3# datamas k > 3 .= postvoteCcl; 
cptr = cptr+4; 
c : = schedsCcptr 3 
end ; 

if c >= O then cptr := cptr+lz 
end/ (•* copschedule #•) 


procedure tschedule; 

(•* Find the next task to schedule ■*) 

var 

tk» more: integer/ 
begin 

more .= 0; tk = schedsCtp3; 
while more =* 0 do 

if tk = 0 then more • = 1 
else if tk = -1 then more = 1 

else if band ( t k/ e x tendmask ) = 0 then more .= 1 

else if (framecount mod sc h ed s C tp+1 3+1 ) = schedsCtp+23 

then more = 3 

else begin tp := tp+3; tk := schedsCtp3 end/ 
if tk <= 0 then begin taskid := nullt/ taskbits := 0 end 
else 

begin 

taskid := band ( t k / datamas k ) ; 


taskbits = tk-taskid. 

(•> if the repeat loop gets executed more than once/ more should be 3. 
repeat 

tp = tp+more 
until schedsltp3 = 0/ 
end ; 

if tk >= 0 then tp . = tp+1 
end/ ( * tschedule * ) 


procedure bui ldtask ( taskname: integer); 

<* Initialize a task table entry *) 
o eg m 

reimt(ttCtaskname3. stkptr/ttCtasknamel. state);*) 
ttCtasknamel status = task termina t l on 
end/ <* buildtask *) 


function scheduler (retl/ ret 2/ oldpc • integer; 

cause schedcall/ state integer ). integer; 

•.'ar 

x • integer; 

begin (* See large comment in file SCHED. BDX * > 

tskfn = clock; 
ttCtaskid], stkptr : = state; 
if causeOtas k terminat i on then 
begin 

if ( task i dOnul 1 1 ) then 
if taskid-OO then 

if band < suspmaski taskb its ) = 0 then 
begin 

(* pause ( 16#55Q0 bor taskid);*) 

ttCtask id 3. errors = ttCtask id 3. errors+1/ 

build task( task id) 

end 

else rt C tas k id 3 . status := c loc k interrupt/ 
if sfcount >= maxsubframe then 
begin 

if framecount >= maxframe then framecount := 0 
else framecount = f ramec ount+1 ; 
gframe : == gframe+1; 

sfcount := 0; vp := vpi; cptr = cptri; tp = tpi 
end 

else sfcount := sfcount+i; 
vschedule. 

( * copse hedule; * ) 

tschedule/ ( * changes taskid and taskbits * ) 

end 
else 

begin taskid ;= nullt; taskbits = 0/ 
end ; 

tskst = clock; 

scheduler = ttCtaskidl stkptr; 



a ? ‘-d, <-<■ scheduler * ) 


"* function nu 1 1 tas k • integ er ; #) 

(* This is the task that wastes time It never terminates In * 
the final system the nulltask will be the diagnostic task. * ) 

' ■+ begin*) 

>.-» while true do _loop forever_ #) 

i* end, *> 


function errtask' integer, 

( * Compute and broadcast a word with bits 7 through 0 
indicating whether processors 8 through 1 have 
failed (1) or are ok (0). •»■) 

const 

threshold = 3, 

var 

err, i: integer, 

begin 

err - 0, i . = maxprocessors, 
repeat 

err .= err *2, 

if (not uiorkingCil) or ( er r ors C l 3>thr eshol d ) then err .= err + 1; 
errorsCil = 0; 
i . = l-l 
until i<10, 

stobroadcast ( errerr, err); 
errtask . = 0, 
and, (•* errtask *> 


function gexectask integer; 

(* Compare values from the errtasks Those that are reported 
by two or more processors (other than itself) for more than 
one frame, are considered bad. The rest are considered good. 
The report consists of a word, bits 7 through 0 of which 
represent processors 8 through 1. (1 failed, 0 working. )*•) 

var 

procs - procbool; err, i, j, count, reconf: integer; 

begin 

i . = 0; 

repeat 

count = 0; j =0; 
r ep eat 

if workingCjl then 
begin 

err .= btCerrerrl adCj3; 
if iOj then 

if workingCil then 

if odd ( dataf l 1 e Cerr 3 ) then count := count+1; 
da taf i 1 eterr 3 := dataf i 1 e C err 3 div 2 
end; 



j •= j+i 

until j>maxprocessors; 
if workingCi3 then 

if countM then procsCi3 := false 
else procsCi] = true 
else procsCi] = false/ 
i = l+l / 

until i>maxprocessors; 
reconf : = 0; 
i . = maxprocessors; 
repeat 

reconf = reconf#2; 

if not procsCi] then reconf = reconf+li 
i = i-1 
until i<0; 

stobroadcast(gexecreconf / band(reconfi post voteCgexec memory]) )/ 
uta i tbroadcasti 

stobroadcast( ge x ecmemor y / reconf >i 
gexectask • = O 
and; (# gexectask *) 


procedure clrbufs; 

(■* Set the buffer table so that no assumptions are made about what 
processor is computing the value. * ) 

>-ar 

i< j . integer. 

begin 

l : * 0; 

r ep eat 

J • = 0; 

repeat btCil adCj] .= -1; j = j+1 until j>maxprocessors. 
l • = l+l 

until i>maxbufs. 
and. ( clrbufs •» ) 


ovccedure neuivc ( s : integer ) ; 

(* S points to the vote and copy schedules Copy them into 
the real schedules. *) 
oeg in 

s : = 5+3; vp i =5/ 
while schedsCsl >= 0 do s := s+1. 
cptri : = s+i 
end/ (# newvc *) 


procedure recbuf s ( s, p . integ er ) . 

<•* s points to the task schedule corresponding to real processor p. 
Figure out what buffers are computed. *•) 


war 



b» t> i- integer; 
begin 

s ; = s+3; 

while schedsCs30-l do 

if schedsCs3 = 0 then s = s+1 
else 

begin 

t = band ( sch ed s C s 3 / datamas k ) ; 
i = ttCtl.bufs; b = binfCi], 
t ' = d b a d C p 3 ; 
while b>0 do 
begin 

with btCb3 do adtp3 = t+dbx; 
l : = i + l< b • — b inf C l 3; 
end; 

if ( band ( sc heds C s 3 » e x tendmas k ) ) OO then s := s+3 
else s : = s+1/ 
end / 

end; (# recbufs ■>) 


function xrecf Creconf : integer): integer; 

var 

i< s. nw. integeri 

begin (■+ See big comment in file RECF BDX *) 

b c 1 oc k : =c 1 oc k ; 

( -> disable/*) 

nw . = -1; i = O; s = reconfz 
rep eat 

if odd(s) then work mg!Zi 3 = false 

else 

begin 

workingCi3 = true; 
nw . = nw+1 ; 
virtnoCnwl := i 
end; 

s : = s d i v 2/ 
i • = i+l ; 

until i>maxpracessors; 
if lastconf lgOreconf then 
begin 

<■» if rectr then pause < 16#ABC4 );* ) 
lastconf ig .= reconf; 
dataf i le C tpbase+qrec onf 3 .= reconf/ 
s . = 0; 

<*if nw>5 then nw := 5; phase 1-*) 

while schedsCs3<>nw do s = s + s c h ed s C s+23; 

clrbufs; i : = 0/ 

tp i : =0/ 

repeat 

recbufs(s/ virtnoCi3)z 
if virtnoCi3 = pid then tpi .= s+3; 
s .= s+schedsCs+23; 
i : = i+l 
until i>nw; 

».* if tpi=0 then pause ( 16#ABC5 );* ) 
newvc ( s ) / 



numwor k ing = nw+1; 
sfcount := maxsubframe+1; 
framecount .= maxframe+1 
end; 

clock =b clock, 
x r e c f : = 0 
end ; 


function recftask. integer. 

(# The reconfiguration task calls xrecf to do the real work. ■*) 
Degin 

recftask .= xrecf (postvoteCgexecreconf ] ) 
and; (* recftask ■») 


function elk task: integer; 

const 

max skew = 40. 
commdelay = 24; 

dest = 32768. ( * Destination 0 * ) 

var 

i< num, sum. term, x integer, 
d e 1 ta. ep s 1 1 on : integer; 

unseen: arrayEO ma x proc essor s 3 of boolean; 

wkset integer; 

begin 

■'■^disable; * ) 

for i •= maxprocessors downto 0 do data f l leC d bad C i 3 3 = 0; (* dp ■*> 

bclock : = clock; (# begin time ■*> 

wkset : = O. 

transf i leCmag ic 3 := dest; (•* once is enough *) 
unseentpidl . = false; 
for i = maxprocessors downto 0 do 
begin 

skewC i 3 • = O. 

while (band ( c loc k. 32) )<> 0 do ; 

while (band (clkl.32>)= 0 do ; (■* whoa mule ■*> 

teatime- =clock; 
if i = pid then 

repeat (•» the Broadcast *> 

if pideof>0 then 
begin 

datafileCtpbase3: =clock; 

transptr: =tpbase» 

end; 

until c loc k-teat ime > maxtime 

else 

begin 

unseenCil .= true; 
x : =dbad C i 3; 

pclock := datafileCxl; 



repeat 

cclock := datafileCxl; 
aclock: =clock; 
if cclock O pclock then 
begin 

skewCi3: = cclock + commdelay - aclock; 

unseenCil. =false; 

repeat 

until clock - teatime > maxtime; 
end ; 

until c 1 oc k-tea t ime 5 maxtime 
end ; 

end . 

(# Calculate the clock correction #) 
ersab le, *) 

sum . = 0; num . = 0; 
for i . = 0 to maxprocessors do 
begin 

uikset : = 2-»u;kset; 
skCskptr+i3 = skeuCiD; 
if uorkingCi] then 
begin 

wkset = wkset+l; 
term : = skew! i ] , 
if term > maxskeu then 
begin 

term • = maxskeu; 
reason = reason+1/ 
end, 

if term £ -maxskeu then 
begin 

term = -maxskeu;, 
reason := reason+1, 
end ; 

if unseenCil then 
begin 

term = O, 
fatal . = true; 
reason . = bor < reas on, 1024 ) ; 
end , 

sum = sum+term; 
num = num+1; 
end 
end ; 

delta = (sum div num), 

(* lets wait for the 1.6 msec interrupt *) 
repeat 

cclock - = band ( c lac k, 1023) , 
until (cclock > 512 + maxskeu;) OR (cclock < 271), 

cclock := delta+clock, 

clock := cclock; (# Adjust the clock value, 

pclock : = clock; 

epsilon .= pc loc k-c c loc k, 

if (epsilon > 2) or (epsilon < -2) then 



reason .= bor (reason/ 2048) . 


sk Cskptr+p id3 = 43680+pid. 
s k C s k p tr+maxpr oc essor s 3 = wkset; 

skCskptr+83 = gframe. 

sktskptr+93 = p ost vot e C g e x ecr ec on f 3 ; 
skCskptr+103 = p os tvot e [ g e x ecmemor y 3 ; 
skCskptr+113 = bclock; 
sk Cskptr+123 = delta; 
skCskptr+133 := rumd; 
skCskptr+143 .= pages; 
skCskptr+153 = reason; 
skptr = skptr+16; 

1 ines : = 1 mes+i. 

if fatal then stop : =stop + l; 

if hlttrue then 

(■»if stop=3 then pause ( 16#555 );■<*■ ) 
if lines > 48 then 
beg in 

lines ■ = 1 ; 
pages = pages+1. 
if hlttrue then 
begin 

(# if reason > 16#FF then pause ( 16#333) . *> 

(•»• if pages > pagelimit then pause ( 16#444) ; ■#•) 
end . 

skptr =0 

end; <•* if lines > 48 ■*) 

c 1 k task . = 0; 

(■* enable dp *) 
end; (■* clktask ■*) 


< ■* The following routines have to do with system initialization. * ) 
1 *.) 


procedure initialize; 

( * initialize the processor numbers and pointers and errors ■>) 

var 

i i j.reconf. integer; 
begin 

skptr = 0; lines = 1; pages := 1# 
reason = 0; fatal •= false; stop:=0; 

if (minutes > 1354) or (minutes < 1) then 
minutes : = 1354; 

pagelimit := 24*mmutes+ ( (6*mmutes ) div 31); 

skC8003 = pagelimit. skC8013 := runid; 

votecnt . = 0; 

errtr .= errtrb; vottr .= vottrb; rectr := rectrb; 
h lttrue . =h 1 ttb. 

(* gprocessor ;*) dbaddrs. work, synch; 



•taskbits := 0; lastconfig := 0; reconf = 0/ gframe .= -1; 
tas kid .= 0; sfcount := -1; fraisecount .= 0> clock = 0; 
for l := 0 to maxbufs do p ostvot e C i 3 := 0 > 
for i = 0 to tasks do 

begin bui ldtask ( i > # ttCil errors := 0 
end; 

for i . = maxprocessors dounto 0 do 
begin 

errors C i 1 • = Oi 
reconf : = reconf*2; 

if not ujorkingCil then reconf = reconf+1 
end# 

it appinit;-*) 
i > ic init. *■> 

postvoteCgexecmemary 3 := reconfi 

i .= xrecf (reconf ) ; 

end; 

begin 

read(pid); 

>ur ite In ( p i d > / 
rewritetdatafileOl); 
dataf i le01 y ' : = pid» 
put (dataf i 1 eOl > ; 

■Jriteln(pid)/ 

doaddrs; 

>iior k> 
synch/ 
initialize; 
end. 



Appendix - II 



si f tpl 


proc /' 


! 


dc l 

sys i n 

file; 




dc l 

sysp r i nt 

file; 




del 

news i ft 

• entry 

options 

(variable); 

del 

df i le <0:1 01 5) 

fixed 

bin <35) based (dfptr); 

del 

dfpt r 

pt r ; 




del 

dfpt rpas 

pt r e 

x terna l 

static; 

* 

del 

elk 

fixed 

bin external static; 

del 

transfile(0:1Q15) 

fixed 

b i n < 3 5 ) 

based (transptr); 

dc l 

transptrpas 

ptr external 

static; 


del. 

transptr 

ptr; 




del 

pideo f 

fixed 

b i n ( 3 5 ) 

ex terna l 

static; 

dc l 

scheds.pl <0:1 791 ) 

fixed 

b i n < 3 5 ) 

e xternal 

s t.a 1 1 c ; 

dc l 

sxhedspt r pa s 

Pt r 

external 

static; 


dc l 

schedsptr 

ptr; 




dc l 

postvote.pl <0:1 19) 

fixed 

b in( 35) 

based (postptr); 

dc l 

postptr 

ptr; 




dc l 

pos tp t rpas 

ptr ex terna l 

static; 


del 

dbad.p l <0 : 7 ) 

fixed 

b i n ( 3 5 ) 

based(dbaaptr); 

del 

dbadp t r 

ptr; 




del 

dbadpt rpas 

ptr external 

static; 


del 

bmf.pl (0:2 00) 

fixed 

b i n ( 3 5 ) 

based(bin 

f p t r ) ; 

del 

b i nf p t r 

ptr;. 




del 

binfptrpas 

ptr external 

static; 


dc l 

clock 

f i xed 

bin( 35) 

external 

static; 

del 

adrl 553a 

fixed 

bin (35) 

external 

static; 

del 

cmdl 553a 

f i x e d 

bin( 35) 

external 

static; 

del 

stal 553a 

f i xed 

bin<35) 

external 

static; 

dc l 

p id 

fixed 

bin(35) 

externa l 

static; 

dc l 

numworking 

fixed 

bi n ( 3 5 ) 

external 

static; 

del 

virtno<0:7) 

fixed 

b i n < 3 5 ) 

external 

static; 

dc l 

virtnoptrpas 

ptr external 

static; 


dc l 

virtnoptr 

ptr; 



- 

dc l 

gf rame 

ptr external 

static; 


dc l 

s f count 

fixed 

b in< 35) 

external 

static; 

del 

vote c n t 

fixed 

b i n < 3 5 ) 

external 

static; 

dc l 

v ti me 

fixed 

b i n ( 3 5 ) 

external 

static/* 

dc l 

wt i me 

fixed 

b i n < 3 5 ) 

external 

static? 

dc l 

del ta 

fixed 

b i n ( 3 5 ) 

e x terna l 

static; 

del 

worki ng<Q-: 7 ) 

fixed 

b i n < 3 5 ) 

based (worki ngptr) 

del 

wor k i n gp t r 

ptr7 




dc l 

workptrpas 

ptr external 

static; 


dc l 

P-pl 

f i xed 

bin (35) based ( p p t r ) ; 

dc l 

pptrpas 

ptr externa l 

static; 

" 

dc l 

PPtr 

ptr; 




del 

v.pl < 0 : 7 ) 

f i xed 

b i n < 3 5 ) 

ba sed (vpt r ) ; 

dc l 

vpas 

ptr external 

static; 


dc l 

vpt r 

ptr ; 




del 

errors (0: 7) 

fixed 

b i n < 3 5 ) 

based (errorptr); 

del 

errorpas 

ptr external 

static; 

' 

del 

error pt c 

ptr ; 

t 



dc l 

Pi 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

p2 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

p3 

fixed 

b i n < 3 5 ) 

external 

static; 

dc l 

P3 

fixed 

b i n < 3 5 ) 

e xternal 

static-; , 

dc l 

p4 

fixed 

b i n < 3 5 ) 

external 

Static; ’ 

dc l 

p5 

fixed 

b i n < 3 5 ) 

external 

static; 

dc l 

v 1 

fixed 

b i n ( 3 5 ) 

ex ternal 

static; - 


N * >« %» >• 



dc l 

v2 

f i x e d 

b i n ( i 5 ) 

external 

static; 

del 

v3 

fixed 

b i n( 35 ) 

external 

static; 

dc l 

v4 

fixed bin(35) 

external 

static; 

dc l 

v 5 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

tas k i d.o 1(0:12) 

fixed 

b i n ( 3 5 ) 

based (taskidptr) 

del 

task i dpas 

ptr external 

static; 


del 

task i dptr 

ptr; 




dc l 

skew.pl (0:7) 

fixed 

b i n ( 3 5 ) 

ba sed ( ske wo t r ) ; 

del 

s kewp t r 

Ptr; 




del 

s ke wp t rpa s 

ptr external 

static; 


dc l 

sk.pl 

f i xed. 

b i n ( 3 5 ) 

based (skptr); 

dc l 

skpt r 

pt r? 




del 

skpt rpas 

ptr e x te rna l 

static; 


del 

t as k b i t s 

fixed 

b i n ( 3 5 ) 

ex ternal 

static; 

dc l 

l a s t c o n f i g 

fixed 

b i n ( 3 5 ) 

ex terna l 

s ta t i c ; 

dc l 

pc l o c k 

f i xed 

b i n ( 3 5 ) 

external 

static; 

dc l 

c c l oc k 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

beloe k 

fixed 

bi n( 35 ) 

external 

static; 

del 

a c lock 

f i xed 

b i n ( 3 5 > 

external 

static; 

del 

tp 

fi xed 

b i n ( 3 5 ) 

external 

static; 

del 

vp 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

cpt r l 

fixed 

bi n( 3 5 ) 

external 

static; 

dc l 

tp i 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

vp i 

fixed 

b i n ( 3 5 ) 

ex terna l 

static; 

del 

cptr i 

fixed 

bi n( 35) 

ex terna l 

static; 

del 

framecount 

fixed 

b i n (3 5 ) 

external 

static? 

dc l 

tea t i me 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

lines 

fixed 

b i n ( 3 5 ) 

external 

static; 

dc l 

pages 

f i xed 

b i n ( 3 5 ) 

ex terna l 

static; 

del 

page l i mi t 

fixed 

b i n ( 3 5 ) 

external 

static; 

dc l 

reason 

fixed 

b i n ( 3 5) 

external 

static; 

del 

fatal 

bit ex 

t e rna l 

static; 


del 

h It t r ue 

bit ex terna l 

static; 


del 

errtr, 

bit external 

static? 


del 

vo tt r 

bit external 

static; 


dc l 

rectr j 

bit ex 

terna l 

static? 


dc l 

runid 

fixed 

b i n ( 3 5 ) 

external 

static; 

del 

minutes 

f i xed 

b i n ( 3 5 ) 

external 

static; 

dc l 

t sk s t 

f i xed 

b i n ( 3 5 ) 

ex terna l 

static; 

dc l 

t sk f n 

fixed 

b i n ( 3 5 ) 

ex ternal 

static; 

dc l 

h It tb 

f ixed 

bin< 35) 

external 

static; 

dc l 

errtrb 

fixed 

b i n ( 3 5 ) 

external 

static; 

dc l 

wot t r b 

f i xed 

b i n ( 3 5) 

external 

static; 

dc l 

rectrb 

fi xed 

b i n ( 3 5 ) 

ex ternal 

static; 

dc l 

stop 

fixed 

b i n ( 3 5 ) 

ex ternal 

static; 





bor : proc (a/b) returns (fixed bin(35)) 


del a 
del b 
del c 
del tempi 
del temp2 
del i 

tempi = subs t r ( un spec (a) / 21 ) ; 
temp2 = s ubs t r ( un spe c (b) / 2 1 ) ; 

do i * 1 to 16? ; ’ 

if sub s t r C t emp 1 * i * 1 ) = ” 1 *’ b I subs t r ( temp2 / i /I ) = "1"b 
then subs t r ( c* i /I ) = "1"b? 
end/ 

retu rn (fixed ( c) ) i 
end /* bor */1 

band : proc(a/b) returns (fixed bin(35)); 

dc l a 
del b 
del c 
del tempi 
dc l t emp2 
del i 

tempt - subs t r ( un spec ( a) r 21 ) ; 
temp2. = subst r (unspec (b) # 2T) ; 

do i * 1 to 16J \ 

if subs t rs( t empl / i # 1 ) = "1-"b & subst r ( temp2/ i / 1 ) = "1"b 
then subs t r ( c# i / 1 ) = " 1 ’* b ; 
end# 

return (fixed ( c> ) i 
end /*■ band */l 


fixed bm(35); 
fixed bin(35K 

/ bit (16) ini t(" GOOQQOOOQOOQQOOO"b); 
bit (16); 
bit (16); 
fixed b i n i- 


fixed bin(35); 

fixed bm(35); * 

bit (16) init("OQOOGOOOQ3QOO30O"b); 
bit ( 16 ) ; 
bit (16) ; 
fixed bin; 



df pt r = dfptrpasJ 
transptr = transptrpas; 
schedsptr = s ched spt r pas/ 
postptr = postptrpas; 
dbadptr = dbadptrpas; 
binfptr = binfptrpas; 
workingptr = workptrpasJ 
pp tr = pp t rpa s; 
vptr = vpasJ 
errprptr = errorpas; 
taskidptr - taskidpas/ 
skeuptr=skewptrpas; 
skptr - skptrpas; 

/ * call newsift/*/ 

put skip list ("clock ="/clock) ; 

put skip listC'dfile - " * dfptr -> d f i l e ( 0 ) *df o t r -> dfile(128)) 
end; - 


\ 



'00 


er >di 


» * , 


Hi 


/ 



