AFIT/GCS/ENG/93M-01 


AD-A252 515 



Reproduced From 
Best Available Copy 


OBJECT-ORIENTED DATABASE 
ACCESS FROM ADA 


THESIS 

Li Chou 
Lt Col, ROCAF 

AFIT/GCS/ENG/93M-01 


DT1C ' 

S ELECTE m 
APR 0 519931 | 

E 


08 4 02 ooa 


93-06837 

■INUSU\^ 


Approved for public release; distribution unlimited 

oiOOOOW 105 












Table of Contents 


Page 

List of Figures. 6 

List of Tables. 7 

Acknowledgements. 8 

Abstract. 9 

I. Introduction. 1-1 

1.1 Background. 1-1 

1.2 Problem Statement.... 1-3 

1.3 Research Objectives. 1-3 

1.4 Approach. 1-3 

1.5 Materials and Equipment... 1-4 

1.6 Document Summary.. . 1-4 

II. Literature Review . 2-1 

2.1 Overview. 2-1 

2.2 Overview of ObjectStore. 2-1 

2.3 Programming Language and DBMS. 2-3 

2.3.1 Data persistence. 2-3 

2.3.2 Programming Language Interface to DBMSs. 2-7 

23.3 Approaches to the interface. 2-7 

2.4 Ada and C/C++ Communication. 2-9 

2.4.1 Information Hiding. 2-9 

2.4.2 Overloading... 2-10 

2.4.3 Polymorphism. 2-10 

2.5 Interface Programming from Verdix Ada. 2-11 






























Page 


2.5.1 Create Parallel Data Types. 2-11 

2.5.2 Declare External Subprograms. 2-12 

2.5.3 Accessing C++ and ObjcctStore’s Extended Functions . . . 2-13 

2.5.4 Ada bindiug to X window. 2-14 

2.6 Summary. 2-16 

III. Design and Implementation. 3-1 

3.1 Overview.... . 3-1 

3.2 The Prototype of Ada/ObjectStore. 3-1 

3.2.1 Ada/ObjectStore interface. 3-1 

3.2.2 Compare Ada/ObjectStore and ObjectStore. 3-3 

3.3 Implementation Issues. 3-5 

3.3.1 C Library Interface. 3-6 

3.3.2 Types in the Interface. 3-7 

3.4 Implementation Ada/ObjectStore Facilities. 3-11 

3.5 Testing of Ada/ObjectStore. 3-14 

3.5.1 Testing Ada/ObjectStore functionality. 3-14 

3.5.2 Performance Testing. 3-14 

3.6 Summary. 3-16 

IV. Results Analysis . 4-1 

4.1 Overview. 4-1 

4.2 Performance Comparison of Ada/ObjectStore and ObjectStore .... 4-1 

4.3 Problems Encountered. 4-6 

4.3.1 Debugger. 4-6 

4.3.2 Understanding ObjectStore. 4-7 

4.3.3 Interface Limitations. 4-7 

4.4 Summary... 4-8 


3 






























V. Conclusions and Recommendations. 5-1 

6.1 Overview..... 5-1 

5.2 Summary of Research. 5-1 

5.3 Conclusions. 5-1 

5.3.1 Data Persistence. 5-2 

5.3.2 Reliability, Maintenance, and Efficiency.. 5-2 

5.3.3 Data Abstraction. 5-2 

5.4 Recommendations for Future Research... 5-3 

5.4.1 Transparency.. . 5-3 

5.4.2 Exception Handling. 5-3 

5.4.3 Version Management.. 5-3 

5.4.4 Variant Records. 5-4 

5.5 Summary. 5-4 

Appendix A. Raw Performance Test Results. A-l 

Appendix B. Test Programs .. B-l 

B.l Test Program: adaobj.mk (for adaobj.a). B-2 

B.2 Test Program: adaobj.a. B-3 

B.3 Test Program: adacol.mk (for adacol.a) . .. B-9 

B.4 Test Program: adacol.a. B-10 

B.5 Test Program: adaobj.mk (for adaobj.c). B-17 

B.6 Test Program: adaobj.c. B-19 

B.7 Test Program: adacol.mk (for adacol.c). B-25 

B.8 Test Program: adacol.e. B-27 

B.9 Test Program: purobj.a. B-33 

B.10 Test Program: purobj.c. B-38 

B.ll Test Program: hellojost.mk (for hellojost.a). B-44 






























B.12 Test Program: hello-ost.a. ii-45 

B.13 Test Program: hello.D8t.mk (for hello.ost.c). B-47 

B. 14 Test Program: hello.ost.c.. B-48 

Appendix C. Interface Programs . C-l 

C. l Interface Program: Makefile. C-2 

C.2 Interface Program: os.types.a. C-3 

C.3 Interface Program: os.typ.b.a. C-4 

C.4 Interface Program: ostore.a. C-5 

C.5 Interface Program: ostorei>.a. C-8 

C.6 Interface Program: ostore.g.a. C-14 

C.7 Interface Program: ostorgJb.a. C-15 

C.8 Interface Program: os-coll.a. C-17 

C.9 Interface Program: osjcoll.b.a. C-20 

C.10 Interface Program: os^cur.a.. . C-34 

C.ll Interface Program: osjcur-b.a. C-35 

C.12 Interface Program: except.a.. C-39 

C.13 Interface Program: except J>.a. C-40 


Bibliography 


BIB-1 



























List of Figures 

Figure Page 

2.1. Example? for the function name encoding scheme. 2-15 

2.2. Application Program Configuration Using the SAIC Binding. 2-16 

3.1. Object access. 3-2 

3.2. Manual schema generation. 3-3 


6 








memmsssmsmaasa 


/ 




List of Tables 

Tkble Page 

1.1. DBMS Support of Engineering Design Tool Characteristics . . .. 1-2 

2.1. The parallel data types between Verdbc Ada and traditional C. 2-12 

2.2. The function name and parameter encoding scheme. 2-13 

3.1. Fundamental data types of C/C++, ObjectStore, and Ada. 3-4 

3.2. Functions of Ada/ObjectStore and their equivalent functions in ObjectStore C++ 

library . 3-6 

3.3. Functions of ObjectStore C++ library (mangled name) and the same functions in 

C library . .. 3-7 

3.4. The data type and alignment size using in Ada and C/C++. 3-lf 

4.1. Benchmark performance results for hellojost.a and hellojost.c. 4-1 

4.2. Benchmark performance results for hello-ost.a and hello.ost.c (C++ mangling in¬ 
terface) . 4-2 

4.3. Benchmark performance jults for hello-ost.a accessing C++ and C library inter¬ 
face .. 4-2 

4.4. Benchmark performance results for adaobj.a and adaobj.c. 4-3 

4.5. Benchmark performance results for adacol.a and adacol.c. 4-3 

4.6. Benchmark performance results for purobj.a and purobj.c. 4-4 

4.7. Benchmark performance results for adaobj.a and purobj.a. 4-4 

4.8. Benchmark performance results for adaobj.c and purobj.c. 4-5 

4.9. Comparison of fiie size written in Ada and C (static binding). 4-6 


7 


1 






















Acknowledgements 

Many persons helped ire go through studying here. It is hard to name all of them, but I must 
mention Maj. Mark A. Roth. I owe him much for his advise and patience in helping me through 
this difficult time. If I am a dragon, I could be swimming in shallow water; language barrier 
constrains my entire space. Without Maj. Roth's endless advise and patient communication-a 
real life example of interfacing in languages, I would probably pack my luggage and return to my 
domicile before I could finish my thesis. 

It is exciting to count the days preparing to go back home. For the 21 months I stay, I need 
to thank all my friends here; I need to thank my wife Susan (Fen-Ming) and my children Amy 
(Chia-Hui), Jenny (Chia-June), and Charlie (Chia-Chun), Without their support, I could not have 
completed this work. 

Li Chou 


8 




AFIT/GCS/ENG/93M-01 


Abstract 

Ada embodies many modern software engineering principles, namely, modifiability, efficiency, 
reliability, and understandability. Its powerful data abstraction allows programmers to easily model 
objects in the real world. However, Ada does not provide data management facilities as a database 
management system (DBMS) does. A DBMS provides long term storage. It provides a convenient 
and efficient environment to manipulate data. Currently, with Ada, access to a DBMS is typically 
done through the use of a language extension and a preprocessor to convert the extensions to 
library calls appropriate for the DBMS. These systems currently support relational DBMS’s and 
some variant of the SQL data manipulation language. However, the data structures in traditional 
DBMS and in Ada are very different and cause limitations that affect Ada’s ability to access 
traditional DBMS for more complex applications, such as computer-aided engineering design. 

Now, object-oriented design (OOD) is a new way of thinking about problems using mod¬ 
els organized around real-world concepts. Currently, the OOD methodology has been imple¬ 
mented in object-oriented programming languages (OOPL) and object-oriented database systems 
(OODBMS). They provide the same methodology to handle objects. An OODBMS includes most 
benefits of a relational DBMS and, in addition, provides the capability to manipulate complex, 
heterogeneous data. ObjectStore is an OODBMS. An interface from Ada to ObjectStore could 
fulfill the requirements for complex applications. 

To approach this research, first, the parallel data types in C and in Ada were implemented. 
Then the interface functions were implemented according to the functions described in the Object- 
Store Reference Manual. For reasons of simplicity, the interface is done via the ObjectStore C li¬ 
brary. Performance testing is accomplished by comparing the differences between Ada/ObjectStore 
and C/ObjectStore. 

Ada/ObjectStore performed better in CPU time than C/ObjectStore. However, there is not 
much difference between Ada/ObjectStore and C/ObjectStore. The main factors that affect the re¬ 
sult of performance still depend on the two languages own abilities. It is clear that Ada/ObjectStore 
provides the capability of data persistence to Ada. This result favorably affects program length, 
program development time, program maintainability, and application reliability. 






OBJECT-ORIENTED DATABASE ACCESS FROM ADA 


I. Introduction 

1.1 Background 

Historically, persistence of data was accomplished through file systems. File systems provide 
data storage required by the application programmer to manage data, but wi*h file systems it is 
difficult to support data consistency, concurrency, and sharing work between applications. 

Unlike file systems, database management systems (DBMS) provide an environment which is 
both convenient and efficient for computer applications to manipulate data. Database management 
systems not only support data storage, but also maintain data protection. DBMS protect data 
against inconsistency through concurrency control and recovery methods in spite of multiple users 
and system failures. In addition, DBMS provide services for data sharing, security, and query. 

However, the relational database management system (RDBMS), currently the DBMS of the 
choice, has many shortcomings. In particular, it has deficiencies for complex design and engineer¬ 
ing applications. The object-oriented DBMS (OODBMS) is a new generation of DBMS which 
incorporates the object-oriented programming paradigm into a database system. It retains the ca¬ 
pabilities of traditional DBMSs; plus, it supports complex data types, multiple versions, and long 
transactions. Thble 1.1 is a good summary comparing RDBMS and OODBMS suppert of several 
characteristics of engineering design tools. From this table it is evident that a good OODBMS can 
potentially provide the database support necessary for a complex application (11). 

Ada is the standard US DoD programming language. Access to a DBMS from Ada is typically 

i 

done through language extension and a preprocessor to convert the extensions to library calls 
appropriate for the DBMS. These systems currently support RDBMSs and some variant of the 
SQL data manipulation language. Current OODBMSs are written primarily for the C or C++ 
language. Ada can interface with C via the Ada interface facility pragma INTERFACE. The pragma 
INTERFACE specifies the other language and informs the compiler that an object module will be 
supplied for the corresponding subprogram (1). AFIT has an OODBMS, ObjectStore, an OODBMS 
from Object Design, Inc., and several Ada compilers. This thesis demonstrates that Ada can access 
an OODBMS that provides extended capabilities for Ada that has object management facilities. 






1-2 








































" -V MS* 




— — - —. i'i ,,..W .ijh , .. i fc, ' i,. >.r - W i ril i',1 ^..—n .j,—,j^ .~ .. V ' t . fc- ...U.,—' V i H - v . -i. 1 -..,^,, 


l.t Problem Statement 

Currency, Ad* can interface with RDBMS, such aa the Ada embedded statements of the 
ORACLE RDBMS (Ada/OCI). RDBMS that provides tue ability to mode) information organized 
as records has widely been implemented in Management Information Systems (MIS) applications. 
However, the RDBMS has its limitations for more complex applications, such as computer-aided 
engineering design. Object-oriented concepts hare been implemented increasingly in the field of 
software engineering. OODBMS, one of implementations using an object-oriented model, includes 
most of the benefits of RDBMS. In addition, it has the ability to manipulate complex, heterogeneous 
data. Current OODBMS such as ObjectStore are written in C or C++. These OODBMSs are 
tightly bound with C or C-t +. To extend Ada’s capability in area of complex, data-intensive 
applications, there must be a way that Ada can interface with OODBMS. 


l.S Research Objectives 

The primary purpose of this thesis is to demonstrate that an Ada binding to ObjectStore can 
be accomplished, and that the interface functionality is similar to the existing C/C++ binding to 
ObjectStore. Furthermore, the performance of the Ada interface should approach the performance 
of the C/C++ Interface. 

Ada is a very powerful programming language and was designed for problem domains needing 
a software-intensive system. It requires efficiency, reliability, and maintainability. An Ada interface 
to ObjectStore should not lose these good abilities. Also this thesis should identify any possible 
limitations related to the interface. 

t.4 Approach 

This thesis effort resulted in the development of an ObjectStore binding for Ada. ObjectStore 
is written for C/C++. The basic approach employed in this effort consisted of the following: 

• Created parallel data types of Ada and ObjectStore. In order to safely convert data that cross 
the interface, parallel data type needed to be created first. Ada supports scalar, composite, 
access, private and subtypes, and derived types. A type declared in Ada should have a parallel 
data type implemented in ObjectStore. 

• Implemented interface functions. A series of predefined pragma INTERFACE and pragma 
IVTERFACEJIAMEs were established to link to the ObjectStore function’s. Several interface 
packages were implemented according to the classification of the ObjectStore functions. 


1*3 







W?T. 




• Implemented test programs using implemented interface packages. The test program verified 
the functionality of the new implemented interface functions. Before a test program was 
compiled, a database schema was implemented. Binding to the ObjcctStore library was 
accomplished at compile time by the Ada linking facility. 

1.5 Materials and Equipment 

This research effort utilizes ObjectStore, version 1.2 and development facilities on a Sun 
Sparc II workstation. Vcrdix Ada, version 6.0, is used to compile Ada programs and the Ada to 
ObjectStore interface programs. 

1.6 Document Summary 

Chapter 1 describes properties of ObjectStore and describes ObjectStore’s abilities in sup¬ 
port of computer-aided design applications. Furthermore, this chapter describes data persistence, 
and how a programming language that can extend its capability of handling persistent data 
through a database. This chapter also describes previous research in interface programming from 
Ada. Chapter 3 summarizes the prototype of Ada/ObjectStore designed by Object Design, Inc. 
(18), and present a design of Ada/ObjectStore via the ObjectStore C library. A comparison of 
Ada/ObjectStore and C/ObjectStore performance after Ada has extended the ability of data per¬ 
sistence is described in chapter 4. This chapter also discusses some problems encountered in the 
effort of implementating the Ada/ObjectStore interface. Chapter 5 includes conclusionc reached 
regarding the objectives of this thesis and recommendations for further research. 






II. Literature Review 


t.l Overview 

In order to begin developing a set of interface programs written in Ada that provide access 
to ObjectStore, an OODBMS product written in C/C++, we need to Irnow some concepts and 
techniques related with this topic. One key area is to compare intercommunication characteristics 
of Ada and C/C++. To achieve this requirement, a review of some features of Ada and C/C++ 
was conducted. These features are abstract data type, data persistence, and current examples of 
Ada bindings, including X windows and ORACLE. 

S.t Overview of ObjectStore 

ObjectStore, developed by Object Design, Inc., is an object-oriented database management 
system (OODBMS). It provides a tightly integrated language interface with the features of data 
management found in traditional DBMS. ObjectStore was designed to provide a unified program¬ 
ming interface for both persistent and transient data. 

OODBMS contain capabilities of data management as with traditional DBMS. In addition, 
OODBMS more directly integrates with an object-oriented programming environment. Therefore, 
the advantage of the OODBMS over the traditional DBMS is that it provides both data persis¬ 
tence and expressibility (19). In a traditional DBMS, transient data are stored in variables in the 
programming language, and persistent data are stored in the database. Programmers explicitly 
convert data between transient and persistent states. However, object instances in an OODBMS 
application are either persistent or transient. The persistent data in ObjectStore is provided by 
overloading the C/C++ ’s memory allocation operator. TYansient data is provided with the ordi¬ 
nary operators of C/C++. ObjectStore provides not only persistent and transient data, but, for 
more efficient data handling, it provides the developer with a single view of memory by dividing the 
memory space into program memory and database memory. Persistent data stored in ObjectStore 
are handled by C/C++ programs exactly the same way as transient (non-persistent) data are (17). 

ObjectStore is an object oriented database management system. It provides the data query 
and management capabilities of a traditional database. In addition to the capabilities of a tra¬ 
ditional database, it provides the flexibility and power of the C++ object-oriented programming 
language and the versioning mechanism to support creation and manipulation of alternative ob¬ 
ject versions. The versioning mechanism enhances parallel work on shared data (17). To group 
objects together, ObjectStore provides collections which provide a convenient means of storing and 
manipulating objects. This feature is not supported by C++ and most DBMSs (14). Collections 




U ' * 

iieAoMig.A* 3SnUfcv -^ - <a».Saafe- *a a&a&to- A :&&£&&& 5tfc^ac&wi^i^K^fa6arfi»afeS^a^j^Sj^«8fc&t£afiBa^^^/.;.■» ^■■.-^i-.ta 


are abstract structures which resemble arrays in traditional programming languages or tablr in 
relational DBMS. ObjectStore collections provide a variety of behaviors, including ordered or un¬ 
ordered collections (lists), and collections that either do or don’t allow duplicates (bags or sets). 
These are commonly used to model one-tomany and many-to-many relationships. They also pro¬ 
vide a domain for iteration and for the execution of queries (17). 

ObjectStore’s unique Virtual Memory Mapping Architecture (VMMA) achieves its perfor¬ 
mance by using memory mapping, caching, and clustering techniques to optimize data access. The 
key features of ObjectStore’s virtual memory mapping architecture allows persistent data to be 
handled exactly the same way as transient data, minimizing overhead of retrieving and manipu¬ 
lating large amounts of data, and managing versioned data in a way that does not slow access to 
non-versioned data. In addition, ObjectStore performs effective associative access and optimizing 
of queries. These techniques formulate efficient retrieval strategies and minimize the number of 
objects examined in response to a query (17). 

ObjectStore applications require three auxiliary processes for their execution: the ObjectStore 
Server, the Directory Manager, and the Cache Manager. These processes are started automatically 
when an ObjectStore application starts. Most users never have to worry about starting or stopping 
them. The Server handles all storage and retrieval of persietent data. The Directory Manager 
manages a hierarchy of ObjectStore directories by storing its information in a directory database. 
The Cache Manager manages an application’s data mapped or waiting to be mapped into virtual 
memory (17). 

There are four approaches to using ObjectStore: (17) 

1. the C library interface, 

2. the C-H- library interface without class templates, 

3. the C++ library interface with class templates, and 

4. the C-H- library interface with class templates and the ObjectStore DML. 

The C++ library interfaces involved in application systems depend on the compiler used. For the 
C++ library interface without class templates, the compiler used is based on AT&T’s cfront. For 
the C++ library interface with class templates, the C++ compiler used should include the ANSI 
Draft Standard. The Object Design C++ compiler supports class templates and ObjectStore’s 
DML, which provides clarity and convenience to access database. Furthermore, the Object Design 
C++ compiler allows applications that mix these approaches freely; a program could perform some 
queries using the DML and some queries using the C++ library interface. 


2-2 





t.S Programming Language and DBMS 

For a long time, programming language designers have tried to find out an effective way of 
handling long term storage. Data, if required to survive a program activation, needs to be stored in 
a file or a DBMS. However, the data structures in traditional DBMS and in programming languages 
are very different. The traditional DBMS only supports limited data types, but most programming 
languages support complete data type systems. Now, object-oriented design (OOD) is a new way 
of thinking about problems using models that are organized around real-world concepts. Currently, 
the OOD methodology has been implemented in programming languages (OOPL) and database 
systems (OODBMS). Because they provide the same methodology to handle objects, they provide 
an advantage for data persistence. The following describes the characteristics of data persistence, 
defines persistent programming languages, and why we need programming languages that interface 
to a DBMS. 

t.S.l Data persistence. Persistence is the ability of the programmers to have their data 
survive the execution of a process in order to eventually reuse it in another process. Persistence 
should be orthogonal to type. The user should not have to explicitly copy data to make it persistent. 

Booch (7) defines persistence as follows: 

Persistence is the property of an object through which its existence transients time 
(i.e. the object continues to exist after its creator ceases to exist) and/or space (i.e. the 
object’s location moves from the address space in which it was created). 

Persistent data should have the following properties (2): 

1. Persistence independence: the persistence of a data object is independent of how the program 
manipulates that data object. Conversely, a fragment of program is expressed independently 
of the persistence of data it manipulated. For example, it should be possible to call a procedure 
with either persistent or transient objects as parameters. 

2. Persistence data type orthogonality: persistence should be a property of arbitrary values and 
not limited to certain types. All values should have the same rights to persistence. 

3. Persistence transparency: persistence is transparent when the programmer is not aware of 
how the data maps between memory and storage. 

Harper, in “Modules and Persistence in Standard ML” (10:26-27), pointed out that the most 
general notion of persistence, called object persistence, consists of viewing all objects as prin ting ; n 
persistent storage, with transient storage serving only as a cache for quick access. Each object is 


2-3 




identified by a persistent identifier, or PID, which is the address of that object in persistent storage. 
The heap is garbage collected as usual so that only accessible objects are preserved. The garbage 
collector is for efficiency, which depends on what algorithm is used. In order to ensure that all 
accesses to persistent data are type safe, each object must have its type associated with it. Some 
sort of run-time type checking must be involved. A persistent environment must associate the type 
of a structure with the object in persistent storage. 

Cardelli (8:37-39) classified persistence strategies and sketched three different persistence 
models. These correspond to three different semantics for intern-extern. Extern is defined as 
the operation that copy objects from transient to persistent memory, and Intern is a symmetrical 
operation for those objects. These strategies are the fetch-store, load-dump, and lock-commit 
model. Cockshott (3:236) gave a similar but more detailed view of addressing mechanisms for 
persistent objects. The following is a summary of some of the categories: 

• The Fetch-Store Model 

This model is backup storage for transient objects. The association between internal and 
external objects is mediated by handles. Extern makes a copy of a transient object in per¬ 
sistent storage, associating it with a handle. Many calls to extern on the same object and 
different handles will make many independent copies. Calls of extern on two objects which 
share a substructure will duplicate the substructure. Intern has the same functions but op¬ 
posite direction, copying objects from persistent storage to transient storage. Sharing is only 
preserved within persistent objects. 

• Core Dumping, or session persistent 

A simple way of providing persistence is to make PIDs machine addresses and dump the whole 
core at ihe end of a session and reload it at the start of the next session. This is a simple 
technique and this gives us very efficient use of disk storage, as data is held in contiguous 
storage. Garbage collection and space recovery is simple too. However, the shortcoming is 

i 

that it will not be able to hold a collection of data that is larger than its RAM since they 
assume that the whole collection of data is loaded into RAM at the start of each session. 
Another considerable cost is the time required to startup and close down. The user must wait 
for the wheile image to swap in or out at the start or finish of the session. 

• Use of Virtual Memory, paged or segmented. 

This technique is to make* the PIDs virtual addresses in a paged or segmented store. It is not 
necessary to dump or reload the entire image. Instead, it can be done incrementally, a page 
or segment at a time as needed. Implementations of virtual memory are transparent to users. 





It allows multiple users running programs concurrently. Each program is given the illusion 
that it is using physical memory alone. However, it will work with degraded performance. 

• Multiple Address Space Models 

In this implementation, the PID is charged according to which address space the object 
contained is currently residing in. If it is resident in RAM, the PIDs are converted to RAM 
addresses. If it is on disk, the PIDs are represented as disk addresses. A search is made of 
a memory resident table called the PIDLAM. This table holds a two way mapping between 
PIDs and local addresses. These are disk addresses and RAM addresses respectively. Every 
object that was brought in from disk in this session must have sin entry in the PIDLAM. The 
drawback of this technique, however, is that a complex body of software is needed to manage 
the PIDLAM. Any algorithm used is not just for simplicity. The current PS-Algol uses this 
technique. 

• Associative PID Addressing & Paged Virtual Memory 

This puts another level of addressing above virtual memory. The PIDs here are names of 
objects rather than addresses. A combination of associative memory hardware and firmware 
maps these names onto paged virtual memory. 

2.3.1.1 Persistent Programming Language*. A persistent programming language is a 
programming language that provides the ability of data persistence. There are several approaches 
to providing persistent data services: files, special hardware devices, and databases (19). Most 
programming languages do not provide tbi ability. Atkinson pointed out that in any program 
written with a non-persistent programming language, there is usually a considerable amount of code, 
typically 30% of the total, concerned with transferring data to and from files or a DBMS (2). Much 
space and time is taken up by code to perform translations between the program’s data and the form 
used for the long term storage medium. Therefore, the main advantage of persistent programming 
languages is quite clear. That is, it favorably affects program length, program development time 
and program maintainability. To discuss persistent programming languages, we need to look at 
what languages should provide and what abilities are required for persistence. 

• Data type completeness: 

The basic requirements for data persistence are persistence independence and data type or¬ 
thogonality. However, a complete type system should have a method that stores persistent 
types, such as a schema generator that generates a schema in a DBMS. More specifically, 
data persistence in programming languages is achieved through data type persistence. The 
persistent data type works with a data type checking algorithm (data type checking will be 


2-5 








mentioned later) to protect data across the boundary between storages and application pro¬ 
grams. Both languages, Ada and C, provide base data types and abstract data types, except 
inheritance. Both provide data type completeness, and, in some cases, Ada is better than 
C in data abstraction. Unfortunately, as with most programming languages, they do not 
orovide any way to store data types. 

• Memory allocation and deallocation: 

Ada and C provide three kinds of memory allocation: static (global), automatic (stack), and 
dynamic (heap). Static and automatic memory normally is allocated at block entry. Dynamic 
memory is explicitly allocated memory. In Ada memory deallocation works automatically. 
However, in C deallocation is done explicitly. Garbage collection, or memory deallocation, is 
a factor of performance for languages. 

• Type checking: 

It is dangerous to allow languages without a strong type checking mechanism to handle 
persistent d?\ta. Languages must provide type checking mechanism to protect against a system 
crash during run time. Because many objects are transferred between the disk and memory 
while the system is running, any type mismatch will cause the system to exit abnormally, or 
even worse, cause some erroneous data to be stored. Languages should provide a method of 
storing and retrieving persistent data as well as a description of its type and a method of 
type checking. Type checking is another weak point of C. Ada provides strong type checking 
to prevent run time errors. Moreover, Ada’s exception facility provides a more elaborate way 
to handle errors at run time. C does not have those benefits. 

• Persistence through reachability or declaration: 

Persistent programming languages provide the ability of data persistence through reachability 
or declaration. Programmers need to understand how data persistence is provided by the 
language they use. 

- Persistence through reachability: 

This approach has one or more persistent database roots and makes every object that 
is reachable from these persistent. This was the approach used in one of the earliest 
persistent programming languages, PS-ALGOL (2) 

- Persistent through declaration: 

This approach is to declare data structures that are persistent. For example, to declare 
a structure PERSON that is persistent, all objects created for PERSON are persistent. 
Languages may provide a different operation for allocating persistent or transient ob- 


2-6 












jects, like ObjectStore does (17). Besides the fact that objects can be declared to be 
persistent, classes can be declared to be persistent, too. Classic-Ada provides persistence 
by declaring classes to be persistent (22). However, the persistence ability in Classic-Ada 
has limitations; all objects under the class declared persistent must be persistent. 


• Memory management: 

Memory is used to temporarily store a program and its data. Programming languages provide 
a uniform memory system. That is data is uniformly distributed in the memory regardless of 
its properties. All addresses of pointers are memory addresses. However, for persistent data, 
PIDs representing addresses of objects on disk arc required. Also new operators are required 
to enable them to dereference PIDs. Languages, for example PS-Algol (3:243) use multiple 
address spaces, separate the memory so it is persistent and transient. All persistent objects 
are stored in the side of persistent memory, and all transient objects are stored in the side 
of transient memory. Other languages such as LISP and PROLOG (23) are implemented in 
a different way: Persistent Memory. A persistent memory system that is based on uniform 
memory abstraction eliminates the distinction between the computational (transient) and 
long-term storages (persistent). The uniform memory abstraction is that a processor views 
memory as a set of variable-sized blocks or objects interconnected by pointers. All objects 
that are in the transitive closure of the persistent root are persistent, and vice versa for 
transient objects. 


t.S.t Programming Language Interface to DBMSs. Ada, a procedural programming 
language, is based on constructs such as loops, branches, and if/then pairs. These programming 
languages provide good performance in computations, but in the case of intensive interrelated data 
retrieval and manipulate, they provide data store and query facilities which are far behind those of 
a DBMS. A DBMS provides cc mrrency control, and failure recovery for data that it stores. Also 
a DBMS supports a transaction mechanism to ensure that the persistent value including updates 
produced by transactions are executed to completion. However, programming languages alone do 
not provide recovery algorithms that acts on persistent values. Persistent programming languages 
have gained the advantage of simplicity and maintainability (2). But, to obtain the best advantage, 
allowing a program language access to a database is an advantageous approach. 


2.3.9 Approaches to the interface. A programming language interface to a DBMS can be 
accomplished by two methods-loosely coupled or tightly coupled. The following discusses the two 
methods and their trade offs. 


2-7 






am^mmmmmssss massmB 


13.3.1 Loosely Coupled - ORACLE and Ada. ORACLE is a Relational Database 
Management System (RDBMS) and can be accessed and manipulated by an application program 
written in Ada. ORACLE provides a set of host language calls that pan be included in application 
programs. An Ada program that embeds these calls is known as an Ada/OCI program (16). 

Ada/OCI provides a direct interface to the ORACLE RDBMS. The SQL of ORACLE is a 
non-procedural language. That is, most statements are executed independently of the preceding or 
following statement (16). Ada is a procedural language and it has limitations on data management. 
However, under Ada/OCI construction, programmers cam write software that combines the advan¬ 
tage of SQL and Ada. The basic structure consists of several statements. For example, a program 
establishes communication with the ORACLE RDBMS by issuing the LOGON call. Communication 
takes piace via the Logon Data Area that is defined within the user program, and the EXECUTE- 
SQL call executes a specified SQL statement. 

ORACLE fetches and stores data objects into and out of the user program by directly access¬ 
ing the data via its actual address. Because of this requirement, if the data in Ada accomplish this 
accessing, all scalar objects are represented as record types with a single component of the scalar 
type. For example, the type used to represent short integer (16-bit) to ORACLE for database 
operations is defined as follows (16): 

type oracls.short.integer is record 
int : short.integer; 
end record; 

ORACLE performs data conversions for data types provided by the user program. On retrieval 
operations, ORACLE converts from the internal format of the data as stored in tb database to an 
external format as defined by the user program. On storage operations, ORACLE converts from 
external to internal data types. ORACLE may store characters in ASCII strings and numbers in a 
variable length scaled integer format. 

The disadvantage of OCI/Ada is they are loosely coupled. Rumbaugh pointed out (19) 
that this scenario is unattractive and the fundamental problem is twofold. The problem of this 
implementation is that they are totally different languages. The interface is through a set of 
language calls which are implemented by ORACLE. Moreover, ORACLE does not provide the 
complete capability of data persistence. The programmer must explicitly convert data between 
persistent and transient formats. This conversion causes inconvenience for application developers. 

1.3.3.2 Tightly Coupled • ObjectStore and C/C++. Section 2.2 shows ObjectStore 
ii a tightly integrated language interface for the features of data management. ObjectStore was 







designed to provide a unified programming interface to both persistent and transient data. Data 
that are allocated in persistent memory with an overloaded C++ new operator are persistent. 
Otherwise, they are transient. Programmers handle the persistent and transient data with no 
difference. Because the capability of complete data persistence is achieved, the explicit I/O and 
data conversion are not required. Furthermore, ObjectStore provides some advantageous abilities 
for manipulating data. For example, the collection provides the ability to handle aggregate data 
structure, and it allows application programs to be developed more simply and readily maintainable. 

2-4 Ada and C/C++ Communication 

Ada, from several points of view, provides data abstraction. Ada’s package can define a set 
of values or data structures and 0 . set of operations that manipulate the data structure it defines. 
A package consists of two parts: package specification and body. The specification contains the 
declarations of types, objects, and subprograms and acts as an interface between the package and 
client programs. The package body contains the actual code for the subprograms declared in the 
specification. Data declared in the specification is accessible from the external world, but data 
contained in the body is hidden from the outside. However, a current shortage in Ada’s data 
abstraction is that it doesn’t support inheritance. 

Although Ada is not truly an OOPL, Ada does support some of the major concepts of 
the object-oriented philosophy in the area of data abstraction, namely overloading, encapsulation 
(packages), information hiding (private types and package bodies). These features make Ada a 
quite suitable OOPL. The following discusses those features in Ada and compare those features to 
C. 

2.41 Information Hiding. The information-hiding feature of abstract data typing means 
that objects have a ‘'public” interface. However, the representations and implementations of these 
interfaces are “private”. The abstraction mechanism that enforces the access «*nd update of objects 
with user-defined types is encapsulated. Hence, it can only be performed through the interface 
operations defined for the particular type. Ada provides information hiding. For example, a data 
structure, stack, is defined to “private”. The type name of stack will be allowed to export from a 
package, but its internal structure is invisible to the user program. Also Ada provides a greater 
degree of information hiding or encapsulation. Fox example, the stack can be completely concealed 
in the package body. Because of encapsulation, only one stack is required. The programs will 
be simplified when the encapsulated stack is used. C does not support information hiding and 
encapsulation. 


2-9 






t.j.8 Overloading. Overloading allows operations with the same name but different se¬ 
mantics and implementations, to be invoked for objects of different types. This is one of the most 
powerful and useful concepts of object orientation. The common examples are overloading oper¬ 
ators and overloading names. In almost all languages, the arithmetic operators “+”, “-” and 
ate used to add, subtract, or multiply integers or floating-point numbers. These operators work 
even though the underlying machine implementations of integer and floating-point arithmetic are 
quite different. The compiler generates object code to invoke the appropriate implementation based 
on the kind of the operands. Ada and C support overloading operators, but only Ada supports 
overloading names. Names, in any language, are used to denote entities. Ada is good for large scale 
systems in which the name space may contain more than hundreds of names. In order to avoid 
problems using names already defined, Ada allows the overloading of certain names. This facility 
is specially useful for subprograms and enumeration literals. One exception is that object names 
cannot be overloaded. One example of overloading a subprogram’s name, CLEAR, is as follows: 


procedure CLEAR (TEE-VALUES : in out VALUES); 
procedure CLEAR (THE.MATRIX : in out MATRIX); 

8-4-S Polymorphism. Polymorphism generally represents the qua'ity or state of being able 
to assume different forms. When applied to programming languages, it indicates that the same 
language construct cam assume different types or manipulate objects of different types. Fairbrairn 
(3:70) pointed out that with polymorphism the function works just as well whether the type is, for 
example, int or char. The idea is to replace the irrelevant details with a type-variable that can be 
filled in later. Overloading is analogous to polymorphism, such as an overloading operator, 
enn apply to different types of objects in which base types are INTEGER or FLOAT. To maximize 
the re-usage of software, it is important to be abie to parameterize software components so that the 
same blueprint can be used in type-safe fashion for different applications. Ada’s generics support 
parametric polymorphism. In contrast, C has no parametric facilities. The common practice is to 
use the C preprocessor (a macro expander) to duplicate text with suitable replacement in order 
to simulate generic instantiation (21). This mechanism is purely lexical: there are no syntax or 
semantic checks attached to the macro definition nor to each of its expansions. Another way is using 
“void*” as a parameter. Because the object is typed as “void*”, a cast is necessary when using 
it. The weak type checking of C makes programmers responsible for types matching in application 
programs, and this will cause the most common type of run-time errors. 


M 


2-10 






£.5 Interface Programming from Verdix Ada 

The main issue of binding between Ada and C is to match parameters. Objects that can be 
matched in these two languages are based on their type systems. Fortunately, types in Ada and C 
can be manipulated to match. C functions act like functions or procedures in Ada depending on 
whether or not they return a value. The following are basic concepts to accomplish the interface. 

£.5.1 Create Parallel Data Types. The VADS Programmer’s Guide points out that the 
first step in creating an Ada interface to a subprogram in C is to “create parallel data types” (24). 
The parallel type, or data structure does not mean the type’s name are identical in Ada and C, but 
the composition, length, and alignment of the component of that type are required to be identical, 
from the programmer’s guide of Verdix Ada, two basic approaches are available for creating parallel 
data types: 

1. using parallel data types known by the programmer from reading the vendor’s documentation, 
and 

2. using Ada representation specifications. 

Ada representation clauses allow the Ada programmer to define an exact duplicate of the physical 
layout of any data type in another language once it is known. For example, the type INTEGER in 
Ada corresponds to the type int in C; the type SHORT. INTEGER is equivalent to the the type short 
in C. Both Int and ahort represent a 16 bit integer. Table 2.1 shows some base types that parallel 
between Verdix Ada and traditional C. Ada allows type specifications that are largely independent 
of the implementation. For example, the type SHORT.INTEGER in Ada can be defined to equal 
the type uaaignsd ahort in C. Type, storage, record layout, and alignment can all be controlled. 
When the underlying representation of a type has no analogue in Ada’s language, the data type 
can be defined by the programmer using Ada representation specifications and UNCHECKED. 
CONVERSIONS. For example, the type char is used both to represent a character or a byte 
integer value. There is no exact Ada analogue to this behavior, but the generic function UNCHECKED. 
CONVERSION offers a method for controlled easing of type conversions: Ada’s TINT INTEGER can be 
used for numeric representations and type CHARACTER can represent a character value (24). One 
thing that is important when using the parallel data types is that the PRAGMA INTERFACE permits 
only 32-bit or 64-bit scalar values to be passed. Consequently, when you pass INTEGER you can 
pass it by parallel INTEGER variables in C. But, when you pass SHORT-INTEGER variables to a C 
function, you must pass them by address. System address is a predefined attribute in Ada. The 
value of this attribute is defined in the package SYSTEM. 


2-11 





TYaditJonal C 

Verdix Ada 

int 

INTEGER 

long 

INTEGER 

short 

SHORTJNTEGER 

char 

CHARACTER 

TINY JNTEGER 

float 

SHORT JFLOAT 

double 

FLOAT 


Tkble 2.1. The parallel data types between Verdix Ada and traditional C 

In compound typ:s, such as ARRAY or RECORD, the same approach can be taken. Both C 
and Ada associate the label of compound types with a base address and offsets provide access 
to individual components of these types. For the Ada programmer, as long as the compound 
types are composed of equivalent simple data types, the offsets will be calculated similarly and the 
structure of compound types will be identical. Verdix recommends that the SYSTEM. ADDRESS of the 
first element of an Ada array be sent to pass the array to C. For record types, the pointer which 
contains the ADDRESS of the first element is the best way to send the record to C. Pointers and 
address types are implementation specified. Ada’s host conventions usually allows the use of Ada 
pointer and address types parallel to their C counterparts. If for some reason, host conventions are 
not followed, representation specifications can be used to fit the size and range of the data type 
(24). 

String types in Ada and C are different. A C string is simply a pointer that points to the first 
character. The string is terminated by a null character. In another words, there is no explicit length 
for C to etore. In Ada, however, a string is represented by a pointer to an unconstrained array of 
charactc :» and it needs an explicit length provided by its attribute, LENGTH. An Ada subprogram 
that calls a C function passing a string as a parameter should be prepared to make the necessary 
conversions. 

&.5.X Declare External Svbprogmms. After parallel types have been designed, interface 
packages need to be implemented to access progr- ms written in C. Ada provides an ability of 
interface to other languages. A subprogram written in C can be called from an Ada program 
provided that all communication is achieved via parameters and function results (1). This is 
accomplished by a predefined PRAGMA ZNTERFACEJUKE to establish a link from the Ada procedure 
or function name to the corresponding procedure or function written in C The Verdix PRAGMA 
INTERFACE allows Ada programs to call subroutines defined in C with: 

pragma 1NTERFACE.HAME (Ada_subprogram_nams, subprogram.link.name); 


2-12 





Encoding Scheme 

Types 

Encoded Symbols 

Basic Types 

void 

V 


char 

c 


short 

s 


int 

i 


long 

1 


float 

f 


double 

d 


long double 

r 

e 

Type Modifiers 

Unsigned 

U 


const 

c 


volatile 

V 


signed 

s 

Standard Modifiers 

pointer * 

p 


reference it 

R 


array 

[10JA10. 


function 

F 


ptr to member 

S::*M1S 


Table 2.2. The function name and parameter encoding scheme 


The subprogram linkman* argument map be formed from a string literal, a constant string 
object, or a catenation of these operands. C, unlike Ada, is case sensitive, so subprogram link. 
T»»— in pragma INTERFACE must be same as the case of the function written in C. A pragma is 
allowed at the place of declaration, and must apply after Ada_subprogram_naa* used in its pragma 
XITERFACEJtAME has been declared. The Ada compiler handles parameter pushing and target 
language compiler naming conventions and checks to make sure the parameters are allowed in the 
target language. 


t.S.3 Accessing C++ and ObjectStore’s Extended Functions. C++ is an extension of the 
C language, implemented not only to add object-oriented capabilities but also to redress some of 
the weaknesses of the C language. Many features are added such as, inline expansion of subrou¬ 
tines, overloading of functions, ind function prototypes (19). It was originally implemented as a 
preprocessor that translates C++ into standard C. After the functions cf C++ are translated to 
C, Ada can access the intermediate C functions as described above. In Type-safe Linkage for 
C++” (4) an encoding scheme for functions written in C++ that can be linked by C is presented. 
The encodirg scheme is designed so that it is easy to determine, if a name is an encoded name. 
What name the user wrote, what class (if any) the function is a member of, and what the types of 
arguments are in the function. The types are encoded as in Table 2.2. 


2-13 







f|RM 


i(S ; !AHi.MUJJ; ; '«W- l 4 


W r ’ T ^^W^i ' w> M'PyM 


For a global function, the name is encoded by appending _F followed by the signature. Figure 
2.1(a) shows an example. For a member function in a class, first, the class name that contains 
this member function is appended to a number which represents the length of the class name. The 
encoded class name then is appended by the member function name and two underlines. The design 
decision to involve a length is to avoid terminators. Both the class name and user defined type name 
require their length in the encoding scheme. Figure 2.1(b) shows how to encode record::update(int). 

The ObjectStore function are exactly C++’s syntax, so it should be the same as C++. This 
can be encoded and then access provided to those encoded functions from Ada. Rosenberg (18) 
designed a prototype of Ada/ObjectStore, which is an interface that allows applications written in 
Ada to access ObjectStore. The interface of Ada/ObjectStore is actually done by accessing C++ 
encoded (mangled) names which are kept in ObjectStore’s library. One example, database::get 11- 
databases, is shown in the Figure 2.1(c). The length in here shows that it can be used to repr lent 
the length of a user defined type name. 

i 

1 

2.5.4 Ada binding to X window. Ada binding to X windows is a good example ft • Ada 
programs accessing C functions. The X window systemdeveloped in the mid 1980s, chang d the 
way that user interfaces were developed. The X window system, or X, is a high perform am <:, de¬ 
vice independent, network transparent window system that allows for the development of portable 
graphical user interfaces (20). X windows manages what is seen on the display screen. The pro¬ 
grammer is not constrained by any particular policy. As a result, X provides mechanism rather 
than policy (12). But the X window system was implemented in the C language. Therefore, there 
was no way for Ada to access X windows. Recognising the benefits of the X window system, some 
members of Ada community began working on ways to access the X window system from Ada. 
One successful method is by way of a binding. 

Under a Software Technology for Adaptable System foundation contract, in 1987 the Science 
Applications International Corporation (SAIC) developed Ada bindings to Xlib, which is written in 
C. The actual Ada interface is accomplished through the use of Ada pragma interface statements. 
A pragma conveys information to the compiler. The name of interface after pragma means the 
Ada compiler allows subprograms written in another language (7). The configuration of the SAIC 
binding shows in Figure 2.2 (13). 

Some functions are missing from the SAIC binding because of the shortcomings of interface. 
One shortcoming is the procedure variables required as parameters to function calls (23). A few 
Xlib functions require procedure variables as parameters to function calls. Ada does not directly 


2-14 






print (int, char, doable) 

!U_J 

print_Ficd 


(a) 


record::update(int) 

t —■rn S 

update_6recordFi 


(b) 


database::get ^all-databases 


statP void get-alLdatabaaes(int, database**, int&) 



get_all .databases _8databaseSFiPP8databaseRi 


- (&) A global function. - 

(b) A member function in a class. 

(c) A ObiectStore member function in the class of database and a ObjectStore defined 
type, database. 


Figure 2.1. Examples for the function name encoding scheme 


2-15 




Figure 2.2. Application Program Configuration Using the SA2C Binding 

support procedure variables. Another one is tho representation of event types as enumerated types. 
In the C version the events are represented as integers with a large block of consecutive integers, 
beginning with zero, reserved by the X Consortium for future use. X was designed to be easily 
extensible. But, by using enumerated types for event types, adding new events is nontrivial because 
the programmer n< eds to ensure the position in the enumerated type declaration matches the event 
numbers used in the C code. Enumeration types for events limit the extensibility of Ada/X (23). 


t.6 Summary 

OODBMS is a new generation database system. Because traditional DBMSs have proven 
inadequate in some applications, the OODBMS is designed to widen the applications of database 
technology. The ObjectStore is currently one of the commercial OODBMSs available. It combines 
the paradigms of object oriented programming language, C/C++, and capabilities of DBMS. Ada 
bindings to C have been implemented in some applications. One milestone is Ada bindings to X 
windows. For Ada bindings to a database, the important factor in this effort is how Ada deals with 
persistent data. Some features of persistent data, type systems in different languages have been 
examined. The purpose of this thesis is to design an Ada binding to ObjectStore to extend Ada’s 
capabilities in the area of OODBMS. 





















III. Design and Implementation 

S.l Overview 

To design of an interface between Ada and ObjectStore the designers require a good under¬ 
standing of the two languages and their capabilities as related to the interface. Based on these 
requirements chapter 2 described programming language interface to a DBMS, Ada and C/C++ 
communication, and interface programming from Verdix Ada. In this chapter, the design is then 
compared to different models and the best model is chosen to accomplish the task. Finally, the 
implementation follows the design paradigm to approach functional completeness. For performance 
measurement, the code is instrumented with timing commands where appropriate. Testing is then 
accomplished to verify functionality as compared to the ObjectStore. 

3.3 The Prototype of Ada/ObjectStore 

The prototype of Ada/Objects tore implemented by Object Design, Inc. is a high level design 
providing to basic interface facilities to Ada. The Ada/ObjectStore interface should be complete 
and transparent. Performance is an another important factor for evaluating the interface and it 
should be as close as C/C++ accessing ObjectStore. Completeness requires that all functionality 
in ObjectStore should ideally be accessible from Ada. Transparency should be provided so that 
an Ada programmer would not need any knowledge of C or ObjectStore’s native facilities in using 
the Ada/ObjectStore interface. Finally, we desire the performance of the Ada/ObjectStore inter¬ 
face to be as fast as the performance of the ObjectStore C/C++ interface. That is, it provides 
near virtual memory access speed to persistent Ada instances. The following is a summary of 
Ada/ObjectS tore( 18). 

3.1.1 Ada/ObjectStore interface. Object Design Inc. provided a prototype interface be¬ 
tween ObjectStore and Ada. This interface is based on the interface facilities supported by Verdix- 
Ada. These are PRAGMA INTERFACE, PRAGMA INTERFACE-NAME, PRAGMA LINK.VITH, and PRAGMA 
INLINE. Object Design considered the following options in designing the interface (18): 

1. Object access 

This would provide Ada abstract types for objects actually represented and accessed in 
C/C++. Each object in Ada would have one counterpart in C/C++ stored in the Ob¬ 
jectStore database. The Ada type would have no Ada level functionality at all, but would 
uniquely identify a persistent C/C++ object. All functions affecting persistent objects would 
be written in C/C++, not in Ada, using the existing interface (see Figure 3.1). Ada sim- 


3-1 


w ^fg gm rm 

‘~ L Lii* i 


* m ■ li flWjf . WftUuWWW W ' ^ 11 'K , • 








Persistent 

objects 


Ads programs ObjectStorc 

Figure 3.1. Object accesa 


Transient 

objects 


ply handles the OID of associated ObjectStore objects via the interface from C/C++. The 
disadvantage of this simple interface is that this would not provide transparency for Ada 
programmers. ObjectStore has a characteristic that treats transient and persistent data in 
the same way. In this option, Ada programmers lose this characteristic because when they 
want to deal with persistent data they must send da*a to C/C++ to store in a database. 
Furthermore, this option implies a rigorously separating persistence store for objects from 
the Ada code and data space. Therefore, this option needs a large number of foreign func¬ 
tion calls between Ada and C/C++. These calls will affect performance and may prohibit 
applications. 

2. Basic persistent Ada instances (Manual schema generation) 

This approach directly represents Ada objects in the ObjectStore database. In this approach, 
Ada programmers have the same capabilities as ObjectStore programmers in manipulating 
both transient and persistent data (see Figure 3.2). The basic requirement of this interfade 
is to provide a set of Ada declarations for the kernel functions of the ObjectStore Iibrarjf 
interface, which has functionalities of ObjectStore dealing with persistent data. In this apj 
proach, transparency to Ada programmers is achieved. The Ada programmers may apply 
these kernel functions without knowledge of the C language. However, because of the lack of 
a preprocessor to generate the schema transferring data types from Ada to ObjectStore, they 
will have to separately specify C descriptions of the Ada types. A C/C++ macro facility can 
be provided to ease these definitions. 

3. Advanced persistent Ada instances (Automatic schema generation) 

This option gives total transparency to Ada programmers. The manual schema as described 


3-2 






Ada programs Objects tore 

Figure 3.2. Manual schema generation 


above needs to separately specify C/C++ descriptions of Ada types in a C/C++ macro 
language. This option provides a preprocessor to pane Ada type definitions and build Ob- 
jcctStore compilation schemas directly. This is feasible because the ObjectStore type system 
is available at run time and is general enough to represent virtually any type. 

! . 

3.2.2 Compare Ada/ObjectSiort and GojeciSiore. The Ada/ObjectStore interface pro¬ 
vides several of Ada’s portable types related to ObjectStore (a list of the most fundamental types 

i 

is in Ihble 3.1) and some of the kernel functions. Table 3.2 showe those functions that parallel 
to ObjectStore’sj functions in C/C++ library. The functions in Ada/ObjectStore dealing with the 
database are enough to manipulate persistent data. For efficiency, Ada/ObjectStore provides an 
interface to C++. An example of the function “DATABASE.CREATE” is as follows: 


function c.database.create(PATH: ADDRESS; 

MODE: B.MODE; 

OVERWRITE: OS.BOOLEAN) return DATABASE; 

pragma INTERFACE(C, c_database_create); 
pragma INTERFACE_NAME(c_database_create, 

C.SOBP.PREPIX A M create__8databaseSFPCciT2"); 


function DATABASE_CREATE(PATB: STRING; 

MODE: O.MODE :* 8#664A; 

OVERWRITE: BOOLEAN :* FALSE) return DATABASE is 

begin 

return 

c.database.create(c_ada_to_c(PATH(PATH*FIRST)'ADDRESS, 

PATH’LENGTH), MODE, B.TO.OSB(OVERWRITE)); end 


3-3 








C/C++ 

OBJECTSTORE TYPES 

ADA TV^ES 

unsigned char 

os_unsignedJi'.t8 

UNSIGNED-TINY JNTEGER 

signed char 

osjsignedint8 

TINY-INTEGER 

unsigned short 

os_unsigned_intl6 

UNSIGNED-SHORT-INTEGER 

short 

osJntl6 

SHORTJNTEGER 

unsigned int 

os.unsignedint32 

UNSIGNED-INTEGER 

int 

osJnt32 

INTEGER 

int 

os-boolean 

BOOLEAN 


Table 3.1. Fundamental data types of C/C++, ObjectStore, and Ada 


DATABASE.CREATE; 

pragma INLINE(DATABASE_CREATE); 

The “create_5databaseSFPCciT2” is a C++ mangled name. The function c_ada_tojc pro¬ 
vides the facility of transferring a string in Ada to C++. 

ObjectStore’s C/C++ library interface allows access to many of ObjectStore’s features di¬ 
rectly from C/C++ programs. These features include (17): 

• databases and segments, 

• roots, 

• transactions, 

• references, 

• collections, 

• queries, and 

• versions. 

Ada/ObjectStore provides basic functions of databases, roots, and transactions. Segments, 
references, collections, queries, and versions are not provided. 

Because Verdix Ada has pragma intsrfacs-nams and interface C options that allow C 
functions to be called from Ada, if necessary, it should be not difficult to implement an interface 
that parallels what ObjectStore has. But, it will have some limitations such as relationships which 
relies heavily on the syntax and semantics of C++. Some features of ObjectStore’s interface are 
missed in the prototype of Ada/ObjectStore. These features are mentioned as follows: 

• Collections: 

A collection is an object that serves to group together other objects. Collections in Object- 

Store provide a convenient means of storing and manipulating groups of objects. With this 


\ 


3 -l 






facility, objects in the same class are transparent to programmers. We can use linked lists in 
Ada data structures to implement the same functionality as the collections have, but it will 
be complicated. Collections hide a detailed mechanism that manipulates groups of objects 
from programmers. 

• Version management: 

Version management has very important facilities especially for computer-aided design (CAD) 
applications. These applications support cooperative work by a number oi engineers on the 
same design. Currently, Ada/ObjectStore does not provide version management facilities. 
That means Ada/ObjectStore is not currently good in CAD applications, or other applications 
which need to check out data for extended periods of time. Version management .eeds two 
classes of functions, configurations and workspaces. 

• Exceptions: 

Ada/ObjectStore provides an exception handling facility to report errors that arise. They 
apply an interface that maps each predefined ObjectStore exception to an associated Ada 
exception. They are implemented through a routine that utilizes a hash table to determine 
the Ada exception associated with the signaled ObjectStore exception. It then calls an Ada 
routine which raises the exception. Ada/ObjectStore’s packages except.a and except.b.a 
(see Appendix C.12and C. 13) provide this one-to-one mapping. For example, the parameter 
ERR. in the procedure of OS.ADAJEXCEPTION will return an integer that maps to an 
exception in ObjectStore. An corresponding exception will be raised in this package, if it 
happens. However, except.a and except.b.a only define one exception for the purpose of 
demonstrating that it is possible to convey an error message to Ada when an error is arisen 
in ObjectStore. For practical application and functional completeness of Ada/ObjectStore, 
except.a and except.b.a are needed to implement all exceptions that ObjectStore has. 

S.S Implementation Issues 

Because ObjectStore provides four kinds of interface approaches as described at Section 2.2, 
which one will be used must be decided first. Then, what types defined in Ada and their counter¬ 
parts in C need to be considered. Finally, an interface is designed and it contains Ada’s subprograms 
to link to their parallel functions in ObjectStore. The following discusses the decision that was made 
to use the C library interface, compares the type system in the interface, and then describes how 
Ada/ObjectStore facilities were implemented. 





Ada/ObjectStore Functions 

ObjectStore Functions 
(C++ Library) 

DATABASE-ROOT-GET.VALUE 

database joot::get.value 

DATABASE-ROOT-SET.VALUE 

database-root::8et-value 

PERSISTENT-NEW 

void*::operator new 

DATABASE.CREATE 

database::create 

DATABASE-LOOKUP 

database-lookup 

DATABASE-OPEN 

database-open 

TRANSACTION-GET-CURRENT 

transaction-getjeurrent 

TRANSACTION-BEGIN 

transactionubegin 

TRANSACTION-COMMIT 

transaction-commit 


Table 3.2. Functions of Ada/ObjectStore and their equivalent functions in ObjectStore C++ 
library 


S.S.l C Library Interface. Clearly, only two kinds of interfaces, C and C++, are con¬ 
cerned. Using C++ library interface with class template DML or the C++ library interface with 
class templates will be complex because of the need to encode class names in the mangled C names. 
Furthermore, the DML can not be used in the interface unless a preprocessor is implemented. To 
implement the class template and the preprocessor in the interface will be more complicated than 
the C/C++ library interface. The decision to use the C library interface is based on: 

1. The syntax of languages: 

Because both Ada and C are not OOPL, they do not provide the concept of class. Also, the 
syntax and object defined in Ada and C are almost same. Most functions in the C library 
can be exactly replicated in Ada. For example, a function to create a database root designed 
in Ada “function DATABASE-CREATE-ROOT(DB : DATABASE; NAME : string) return 
DATABASEJtOOT;” is exactly the same as “database-root * database jcreate.root(databa8e 
*db, char *narue)” in the C library. The interface in Ada is done by directly putting database. 
create-root in a statement pragma IVTERFACEJfAMK. However, the same function in C++ is 
a member function defined in class database, which is “ database-root * create-root(char 
•name)”. Because, in this case, it is in the class of database, the parameter of database 
is not required. This is also part of the distinct syntax in C++, which provides facilities 
pointing to member functions. This is quite different in comparison to C and Ada. 

2. The Complexity of Ada/ObjectStore Interface: 

Because C++ was designed using a preprocessor to convert C++ programs to standard C 
before they are compiled, all C++ functions, as in Table 3.2, can be represented by their 
mangled names as shown in Table 3.3. The interface of Ada to C++ library is actually done 






ObjectStore Functions 

C++ Library (mangled name) 

ObjectStore Functions 
C Library 

get.value_13databasejootFP5.Pvts 

database joot-get.value 

set.value_13databasejootFPvP5J > vts 

database joot-set.v&lue 

nw_FUiP8databaseP5-PvtsiPv 

objectstore_alloc 

create_8databaseSFPCciT2 

database .create 

lookup_£databaseSFPCci 

database-lookup 

open_SdatabaseSFPCciT2 

database jopen 

get -current-! ltransactionSFv 

transaction-get current 

begin_l ltransactionSF2 1 transaction Jype_enum 

transaction .begin 

commit_lltransactionSFP 11 transaction 

transaction jcommit 


Thble 3.3. Functions of ObjectStore C++ library (mangled name) and the same functions in C 
library 


by the mangled name, which is put in the statement pragma INTERFACE-NAME. Table 3.3 also 
shows the same function of each C++ mangled name and its corresponding function in C. It 
is obvious that the C++ mangled name is more complicated than the name in the C library. 

The main concern of this thesis is to implement an interface from Ada to access ObjectStore. 
That means the goal of this design is to prove that the interface, Ada/ObjectStore, could be done 
and the performance is not greatly altered. The interface of Ada/ObjectStore can be done by using 
ObjectStore C and C++ library, but it will increase the complexity if the C++ library is used. So 
the design decision to interface Ada/ObjectStore was decided using C library functions. 

S.S.t Types in the Interface. Ada/ObjectStore provides persistent objects for Ada. How¬ 
ever, types written for the schema must be based on parallel types between Ada and ObjectStore. 
For this reason, types defined in Ada are matched to C in a manually constructed C macro. To 
implement an interface, types defined in the interface should be considered first. 

Ada is a strongly typed language. That means objects of a given type may take on only those 
values that are appropriate to the type. In addition, the only operations that may be applied to 
an object are those that are defined for its type. Ada piWdes a more advantageous type system 
than C. Private type ability is an ixample. For interfacing with another language, representation 
clauses can be used to specify the mapping between types. Section 2.5.1 has discussed the concept 
of creating parallel data types between Ada and C. Scalar, composite, and access type have been 
mentioned. Tables 2.1 and 3.1 show scalar types in C and their counterpart types in Ada. 

Now, about implementation issues, because the main purpose of involving ObjectStore fa to 
provide data persistence for Ada, a detailed observation needs to be done in which the types in C 


3-7 










can map types defined in Ada. One fundamental concept is that all types declared in the interface 
map through their base type that is a predefined physical layout. That means an abstract type 
defined, for example AGE, in Ada it it base type is short-integer, the interface type in C must 
be short because the physical layout in both types, short-integer in Ada and short in C, are 
represented in 16 bits. Nothing needs to be done with abstract type AGE. Another example for 
using a representative clause is as follows: 

type TEMPERATURE is range -100 .. 130; 

for TEMPERATURE'SIZE use 8*BITS; 

As a resuit of this declaration, every object of type TEMPERATURE will occupy no greater than 
8 bits of storage. For physical alignment, if the user uses such a specification, a sign char should 
be used in C because of 8 bits of storage. A representative clause provides efficient feature for 
Ada. However, representation specifications are implementation dependent; a given compiler must 
process the semantics of each clause correctly. Otherwise, the clause will have no effect (6:324). 
The programmer must bear in mind that he must implement the same size (or storage) of type in 
C to correspond to the size declared using representation specification in Ada. It is complicated 
and unwise tc define a type if its size is not 8, 16, 32, or 64 bits. 

A floating type can be assigned and described in terms of attributes called precision and range. 
The precision describes the number of significant decimal places that a floating value carries. The 
range describes the limits of the largest and smallest positive floating value that can be represented 
in a variable of that type. The floating types in Ada include the type float. An implementation 
may also have predefined types such as short-float, which has less precision than float. Ada 
provides an explicit mechanism to define a precision floating type. By default, a 32-bit word 
represents the type short-float, and 64-bit for type float. This corresponds to the type float 
and double, respectively, in C. The number of decimal digits of significance in C is 6 and 15 digits 
for float and double, respectively. This is the same as in Ada. The programmer needs to notice 
that a floating type declared in Ada and its corresponding type in C have the same storage size, 
32 or 64 bits, for example. For the significant digits of the floating types, Ada provides an ability 
to define the number of decimal digits of significance but the number of decimal digits must be set 
equal or less than the maximum digits supported by the Ada compiler and machine used. C does 
not provide this ability so that the number of decimal digits that are always given by the maximum 
digits supported by the C compiler and machine used. Because the Verdix Ada and traditional C 
compiler provide the same maximum decimal digits and the interface is implemented in the same 
computer, the floating type defined in Ada will not lose its accuracy when it interface with float and 
double in C, respectively. One release note from Verdix Ada (24) pointed but that the programmer 





need beware of passing floating point parameters from Ada to C using pragma INTERFACE. It does 
not work correctly in some cases when there are more than six words of parameters. 

The fixed point type in Ada provides an absolute accuracy. There is no similar type provided 
in C. The implementation of the interface for the fixed point type in Ada has the same concern 
as the floating types-accuracy. The Verdix Ada provides 32-bit storage size for the fixed type and 
its maximum decimal digits is 3 (24). It should be no problem that define a float type in C to 
receive and store the fixed type from Ada. 

For predefined type and subtype one needs to trace its parent type (base type) to implement 
a corre ponding type in C. The range constraint of scalar types in Ada provides a better practice 
for defining explicitly the bounds of its types. The Ada compiler then chooses the appropriate 
underlying representation. However, in the interface, the base types are more interesting than each 
of these constrained types; the Ada programmer may design an abstract data type to map to the 
real world, but he must put a corresponding type in C to store the value from Ada applications. 

The compound type in Ada requires an access type to point to it in the interface so that 
objects of the compound type crossing the interface boundary is accomplished via the access type. A 
parallel data structure must declare and strictly demand a physical alignment to the corresponding 
type in Ada. That means the storage size of each component in C needs to align in Ada. 

The enumeration type is like the mutual properties of scalar and compound type. It is 
constructed in a similar way in Ada and C, using a variable that presents an offset from that 
enumeration type. If programmers declare an enumeration type in Ada and store it as an int in 
C, there is no difference in using an enumeration type than using a scalar type in the interface. 
There are two possible implementation methods: one is using Ada’s attribute POS to convert the 
enumeration variable to an integer before it is sent to C, anotner one is to directly send to C 
as an enumeration ype. Both ways work fine. However, the disadvantage for the former one is 
that the programmer needs to do conversion task, and an extra integer variable is required. The 
disadvantage for the latter is that the enumeration type must be known in the interface package, 
by declaration or by using the with clause. Moreover, the Ada compiler will generate a warning 
message, as follows, if the latter one is used. 

wanting: RM 13.9(4): discrete type arguments to *C' must be 32 bits wide. 

Boolean in Ada is a predefined enumeration type. To implement a corresponding type in C 
is the same as the enumeration type described above. 

Ibble 3.4 summarizes all types in Ada and their counterpart types in C. 

3-9 

\ i 





Size 

ADA TYPES (Verdbc Ada) 

C (Traditional C) 

8 bits 

CHARACTER 

char 

8 'its 

TINYJNTEGER 

signed char 

T bits 

SHORTJNTEGER 

short 

\umm 

POSITIVE 

int 

J2 bits 

NATURAL 

int 

32 bits 

INTEGER 

int 

32 bits 

SHORT-FLOAT (floating point) 

float 

84 bits 


double 

32 bits 

FIXED JOINT-TYPE 

float 

32 bits 

ENUMERATION TYPES 

int 

32 bits 

BOOLEAN 

int 

H 

ARRAY TYPES 
(Interface by the address 
of the first element) 

array types 

■M 

STRING TYPES 
(Interface by the address 
of the first character) 

char* 


RECORD TYPES 
(Interface by access types) 

struct 

| 32 bits 

ACCESS TYPES ~1 

pointer 


t sizes of the the elements must be the same in both Ada and C 


Table 3.4. The data type and alignment size using in Ada and C/C++ 


3-10 





















































3-4 Implementation Ada/ObjectStore Facilities 

Verdix Ada »hows how to create parallel data types and declare external subprograms. The 
prototype of Ada/ObjectStore, a high level view, then shows how to design a simple and effi¬ 
cient model: basic persistent Ada instances (manual schema generation). This work continues the 
approach of manual schema generation from the prototype of Ada/ObjectStore and expands its ca¬ 
pabilities. Another concept of Ada/ObjectStore designed is that all PRAGMA INTERFACE statements 
are put in the package body. As we know the Ada package, one of the fundamental program units, 
permits a user to encapsulate a group of logically related entities. As such, they directly support 
the software principles of data abstraction and information hiding. The specification of packages 
forms the programmer’s contract with the package client. A client never needs to see the package 
bod; \nd does not need to know how the functions work. Some functions in ObjectStore need to be 
handled before being called from Ada because of incompatible parameters, such as STRING type. 
In these cases, an intermediate subprogram is needed. However, most functions in ObjectStore can 
be directly called from Ada using PRAGMA INTERFACE without special handling. Ada/ObjectStore 
follows Ada’s software design principles that enforces a clean interface of a package specification 
to clients; all PRAGMA INTERFACE statements are collected in the package body even without an 
intermediate subprogram. 

After the functions of ObjectStore were analyzed, there are some new operations and types 
that need to be addressed. Those are described as follows: 

• New types from the ObjectStore: 

The new types from ObjectStore, such as os.eollactlon* or oa.cursor* which are pointer 
types, are implemented the same as Ada/ObjectStore: all types of pointers in ObjectStore 
are handled in Ada as a new integer. Persistent objects are manipulated by ObjectStore. Ada 
acts like a temporary holder that receives the pointer from and sends it back to ObjectStore. 
Therefore, these types are declared as a user defined type and its base type is integer. For 
example OS.COLEECTION is defined as follows: 

type 0STORE.OPAQUE is nav INTEGER; 
typs 03.COLLECTI0N is nsv 0STORE.OPAQUE; 

• Procedure variables: 

Ada does not support procedure variables (23). It is difficult for Ada is to simulate a parallel 
function in which C can combine procedure variables and a bit-wise operator in a simple 
statement. However, for this simple statement, Ada needs a lot of works to simulate it. Fbr 


3-11 





"*' '^K: 


BiW; 


example, in the function OS-COLLECTION-CHANGE_BEHAVIOR, one of its parameters is BEHAVIOR 
and its type is 0S.UNSIGNED.IHT32. In C, it is defined a type as follow: 

typsdsf enum oa.collsction.behavior { 

os_collection_maintain_cursorial, 
os_collection_allow_duplicatss=*l«l, 
os.collection_signal_duplicates=l«2, 
os_collection_allow_nulls=l<<3, 
os_collsction_maintain_order*i«4, 

> os.collsction.behavior; 

When the BEHAVIOR is sent to ObjectStore, it is simple to use randomly combined variables 
in the parameter list to compute a 0S_UNSIGNED_INT32’s value, such as: 

os.collection.change.behavior(os.coll, 

os.collsction.maintain.cursors I 
os_collection_allov_duplicates I 
os.collaction.maintain.order ) 

Fortunately, in this special case each procedure produces a value that is power of 2, and the 
bit-or operation then is fundamentally the same as the add operation. Two ways can be used 
to simulate this behavior in Ada: 

1. Declaring global constants: 


KAINTAIN.CURSORS 

ALLOWJDUPLICATES 

SIGNAL.DUPLICATES 

ALLOW.HULLS 

KAIHTAULORDER 


: constant 0S_tJNSIGNED_INT32 
: constant 0S_UWSIGN£D_INT32 
: constant 0S.UHSIC-NED.IHT32 
: constant 0S.UNSIGNED.INT32 
: constant 0S_UNSIGNED_INT32 


:■ 1 ; 
» 2 ; 
- 4 ; 

* 8 ; 
■ 16; 


The advantage of this way is that when the value i f BEHAVIOR is sent to ObjectStore it 
is easy to perform a bit-or operation by adding constant integer variables. The above 
function could be simulated as follows: 


os_coll#ction_change.behavior(OS.COLL, 

MAIHTAIN.CURSORS ♦ 

ALLOV.DOPLICATES ♦ 

MAINTAIH.ORDER ) 

However, the disadvantage of this way is the value of BEHAVIOR in Ada received from 
ObjectStore. The value shown to the user is just an integer such as, for example, 1. This 
is an unfriendly user interface. The interface should provide a friendly user interface so 
that the value shown to user should be an enumeration value such as, for example, 
KA1HTAIH.CURS0RS. Ada does not allow a type overloading in the same scope. In t his 


3-12 








case, if HAIHTAIH.CURSORS is declared as constant 0SJJWSIGNZD_IHT32, Ada does not 
allow it to be declared as a value in an enumeration type in the same scope. 

2. Declaring an enumeration type: 

type OS.COLLECTION.BEHAVIOR is (HAINTAIN.CURSORS, 

ALLOW.DUPLICATES, 

SIGHAL.DUPLICATES, 

ALLOW.HULLS, 

MAINTAIN.OPDER); 

To implement in this way, an additional subprogram is needed to parse an input string 
and then to compute the result of BEHAVIOR before it is sent to ObjectStore. The same 
function simulated to C is as follows: 

os_collection_change_behavior(OS.COLL, 

"HAIHTAIH.CURSORS 
ALLOW.DUPLICATES 
KAINTAIN.ORDER" ) 

The disadvantage of this method is that it involves another subprogram and surely takes 
more time. However, the advantage is that when the value of BEHAVIOR in Ada is received 
from ObjectStore, it can be easily transferred to a meaningful word such as, for example, 
an enumeration value-MAINTAIN.CURSORS. 

User-defined enumeration types help to make programs more readable, understandable, 
and maintainable. The maintainability of software written in Ada is one positive aspect 
in comparison to C. Considering the benefits of user-defined enumeration types, declaring 
an enumeration type is a better approach than the declaring global constants. 

• Naming convention: 

In order to implement the same functionality that ObjectStore has from Ada, the subpro¬ 
gram’s name in Ada should be exactly the same as in the ObjectStore. For example, the func¬ 
tion os„collection_create in ObjectStore is implemented in the function 0S.C0LLECTX0N. 
CREATE in Ada. The only difference is that the former is in lowercase, but the latter is in 
uppercase. 

After these consideration mentioned above have been done, the functions in the Ada/ObjectStore 
corresponding to the ObjectStore are implemented readily, mapping functions in ObjectStore with 
Ada subprograms. 






8.5 Testing of Ada/ObjectStore 


The purpose of the testing is to check the execution of the software against the requirements 
in the specifications of Objectstore Reference Manual. Testing is done by a group of functions that 
have been implemented. 

8.5.1 Testing Ada/ObjectStors functionality. Testing of Ada/ObjectStore is based on 
subprograms implemented. However, test programs are designed from a simple program which 
works correctly and then inserts a new subprogram when possible in a suitable position. A software 
testing method is used: white box testing that requires execution each statement at least once. All 
results are compared in compliance with the ObjectStore Reference Manual. 

8.5.2 Performance Testing. Cattel points out that “The most accurate measure of perfor¬ 
mance for engineering appHcations would be to run an actual application, representing the data in 
the manner best suited to each potential DBMS.” (9:364) He summarizes the three most important 
measures of performance in an object-oriented DBMS as: 

• Lookup and Retrieval. Look up and retrieve an object given its identifier. 

• Traversal. Find all objects in the hierarchy of a selected object. 

• Insert. Insert objects and their relationships to other objects. 

Berre and Anderson's HyperModel benchmark (5) presents a similar approach to performance 
measurement. In addition to the operations proposed by Cattel, the HyperModel benchmark 
includes: 

. • Sequential Scan. Visit each object in the database sequentially. 

I • Closure Operations. Perform operations on all objects reachable by a certain relationship 
1 from a specified object. 

1 • Open-and-Close. Time to open and close the database. 

\ We want to compare the performance of Ada/ObjectStore to ObjectStore. The Sim operating 
system provides profiling options which are implemented by the compiler. This profiling provides 
detailed timing and usage statistics from processes specified by the user. A program (Command- 
Stats.c) (11:28) is written for gathering statistics. CommandStats makes calls to the Unix functions 
getrusage and gettiaeof day and calculates processing time. Time is measured in CPU, user, and 
elapsed time. The CPU time is the total amount of time spent executing in system mode. The 
user time is the total amount of time spent executing in user mode. The elapsed time is the total 






amount of time spent executing a process. Two CommandStats are needed in a testing program, 
and they are put before and after the module which is measured. Because CommandStats.c is a 
C program, it can directly be used in testing program written in C. However, a testing program 
written in Ada can not directly call CommandStats.c. An interface package, statis.ada,a and a C 
program, stat.c, are required to perform the job of accessing CommandStats.c 

Performance testing compares the differences in access time between programs written in 
Ada/ObjectStore and ObjectStore that access the same ObjectStore database. The two programs 
are designed to correspond to each other as closely as possible. For example, the test sequence in 
Ada/ObjectStore is to call 0S.CURS0R.CRE1TE and at same place in the test sequence for ObjectStore 
a corresponding function os.cuxsor.create is used. 

The performance comparisons are conducted using these guidelines as mentioned. One ex¬ 
ception is that the Closure Operations in the HyperModel benchmark are not measured because 
the ObjectStore C library interface does not provide the capability of relationships. Also, because 
the performance compares the difference between Ada/ObjectStore and ObjectStore C library in¬ 
terface, a complicated data model is not involved currently in this performance testing. Two kinds 
of simple objects were created to collect statistical data. They are classified in two test groups. 

1. A single object: 

A single integer “count” is stored in ObjectStore. Three test programs were implemented; 
two of them are written in Ada accessing C library and C++ library (mangled name), and 
the third is written in C. The test programs, hellojost.a(c) in different directories provide the 
performance testing for accessing this integer “count”. (Appendix B.14 and B.12) 

2. A compound object: 

Two record data structures LINK-NOTE and N0TE.C0L, which contain 10S and 104 bytes respec¬ 
tively, were implemented. The database bnots.db was created to store 10,000 LINK-NOTEs 
for Ada/ObjectStore test programs and the database cn'ts.db was create to store 10,000 
KOTE-'DLs for Ada/ObjectStore collection test programs. The data structure for LINK-NOTE 
is declared as follows: 

struct link.not* 

< 


1st 

priority; 

/* 

4 bytss */ 

char 

naas[20]; 

/* 

20 bytss */ 

char 

not#[80]; 

/* 

80 bytss */ 

struct 

link.noto *n«rt; 

/* 

4 bytss */ 


}; 



mem 

isai** A.««urt 


The data structure for HOTE.COL is almost the same as LINK-NOTE except the field snoxt. 
The member of struct *next is no longer needed because of the ObjectStore collection that 
already provides facilities to manipulate its elements. The same structures were defined in 
Ada as follows: 


type LINK.NOTE; . 

type LINK.NOTE.PTR ia access LINK.NOTE; 

type LINK.NOTE is 

record 

priority: integer; 
name : stringfl..20); 

note : stringd. .80); 

next : link_.note.ptr; 

end record; 

Two test programs, adaobj. a and adaob j. c, also perform the job of testing basic functions 
for Ada and C respectively (Appendix B.2 and B.6). The extended functions “collection” is tested 
by adacol. a and adacol. c (Appendix B.4 and E.8). The performance is measured in the area of 
initializing, lookup and retrieval, sequential scan, and opening and closing a database. 

• Initializing a database. The function initial-db inserts 10,000 objects in the database. 

• Opening and closing a database. The function DATABASE_0FEN_CL0SE measures the time 
required to open and close a database 10 times. 

• Look up and retrieve an object from the database. The function DATA-RETRIEVE searches the 
database until it finds the specified object and then displays it. 

• Sequential scan. The DATA-SCAN procedure finds the database root and then gets objects one 
by one in the database and displays them. 

In order to observe the performance change after both Ada and C added the facility of 
data persistence, program purobj .a and purobj .c were implemented for Ada and C, respectively 
(Appendix B.9 and B.10). The two programs are the same as adaobj. a and adaobj. c except that 
all functions calling the database are removed. That means all objects created are transient only. 


3.6 Summary 

The Ada language provides abilities to interface different languages. The Ada compiler 
gives a specific and detailed method to implement variables and subprograms in the interface. 
Ada/ObjectStore is a milestone for Ada accessing a database. We can expand its functions and 
implement those functions in a set of abstract modules, which is Ada’s package. The abstract 


3-16 




module Is used as an interface layer between the application module, which is Ada programs, and 
the concrete module, which is pure ObjectStore functions. Ada programmers create Ada programs 
as they used to be. They don’t need to know how the persistent data are handled by a concrete 
module. The collection facilities in Ada/ObjectStore enhance a programmer’s designing abilities 
and, at the same time, the maintainability is accomplished in short and simple statements. The 
testing of Ada/ObjectStore is done by functionality and performance. After the testing, we can 
compare the difference between Ada/ObjectStore and ObjectStore using the C library interface. 


3-17 





IV. Results Analysis 


4-1 Overview 

The primary objective of this thesis is to show that an interface of Ada and ObjectStore 
can provide almost the same functionality and performance as ObjectStore. The database was 
designed in the same way as in ObjectStore and it is described in Section 3.5.2. Because all objects 
are stored into ObjectStore, not Ada, so as long as an object has crossed the boundary of interface 
into ObjectStore, it is handled by ObjectStore. Performance is the vital factor in judging the 
difference between Ada/ObjectStore and ObjectStore. However, because the performance does not 
measure the efficiency of ObjectStore itself in managing objects, two simple objects are required to 
be created and stored in these tested databases. This chapter points out the different performances 
for Ada and C in manipulating the database. 

4-S Performance Comparison of Ada/ObjectStore and ObjectStore 

The results of the performance testing where a single integer is stored in ObjectStore are 
shown in Tables 4.1 and 4.2. IVom these results, some conclusions can be drawn. Ifeble 4.1 and 
Ihble 4.2 show that when manipulating a single integer, if the integer was retrieved and modified 
once, Ada/ObjectStore’s performance is much slower than C/ObjectStore’s. However, if it runs 100 
times, Ada/ObjectStore’s performance is close to C/ObjectStore’s. Table 4.3 shows the difference 
between two Ada/ObjectStore programs, that one run using the C++ mangled interface is better 
than one run using the C library interface. However, the difference in performance between these 
two programs decreases when they run 100 times. 

The results of the performance for testing a database created by ObjectStore using a linked list 
and ObjectStore using collections are shown in Table 4.4 and 4.5. From the testing results of initial¬ 
ization and opening and dosing a database, Ada seems doing a better job on dynamic storage allo- 


Criteria Tested 

Resource 

Measured 

Application Programs 

Percent 

Change 

hellojost.a 

hellojoet.c 

Run Once 

User time (seconds) 

0.032 

0.038 

-15.8 


CPU time (seconds) 

0.345 

0.108 

+219.4 


Elapsed time (seconds) 

0.778 

0.332 

+134.3 


Page Faults without I/O 

215.883 

142.000 

+52.0 

Run 100 Times 

User time (seconds) 

0.680 

0.635 

+7.1 


CPU time (seconds) 

1.853 

1.522 

+21.7 


Elapsed time (seconds) 

13.611 

12.666 

+7.5 


Page Faults without I/O 

1007.333 

939.167 

+7.3 


Table 4.1. Benchmark performance results for hellojost.a and hello_oet.c 






Criteria Tested 

Resource 

Measured 

Application Programs 

Percent 

Change 

hellojost.a 

hello„o3t.c 

Run Once 

User time (seconds) 

0.043 

0.038 

+13.2 


CPU time (seconds) 

0.195 

0.108 

+80.6 


Elapsed time (seconds) 

0.579 

0.332 

+74.4 


Page Faults without I/O 

211.000 

142.000 

+48.6 

Run 100 Times 

User time (seconds) 

0.677 

0.635 

+6.6 


CPU time (seconds) 

1.713 

1.522 

+12.5 


Elapsed time (seconds) 

13.275 

12.666 

+4.8 


Page Faults without I/O 

1003.000 

939.167 

+6.8 


Tkble 4.2. 


Benchmark performance results for hellos » 
interface) 


and hellojost.c (C++ mangling 


Criteria Tested 

Resource 

Measured 

Application 

Programs 

Percent 

Change 

hello.o8t.a 

hellojDst.a 

C)++ Library 

C Library 

Run Once 

User time (seconds) 

0.043 

0.032 

+34.4 


CPU time (seconds) 

0.195 

0.345 

-43.5 


Elapsed time (seconds) 

0.579 

0.778 

-25.6 


Page Faults without I/O 

211.000 

215.883 

-2.3 

Run 100 Times 

User time (seconds) 

0.677 

0.680 

-0.4 


CPU time (seconds) 

1.713 

1.353 

-7.6 


Elapsed time (seconds) 

13.275 

13.611 

-2.5 


Page Faults without I/O 

1003.000 

1007.333 

-0.4 


Table 4.3. Benchmark performance results for hello jjst.a accessing C++ and C library interface 


4-2 






Table 4.4. Benchmark performance results for adaobj.a and adaobj.c 


ritena Tested 


Resource 

Measured 


Application Programs 


acol.a 


Percent 

Change 


Initiahze 
(10,000 
Objects 
inserted 


Open ic Close 


Look up/Retrieve 


User time (seconds) 

CPU time (seconds) 
Elapsed time (seconds) 
Page Faults without I/O 


User time (seconds) 
CPU time (seconds) 
Elapsed time (seconds) 
Page Faults without I/O 


User time (seconds) 
CPU time (seconds) 
Elapsed time (seconds) 
Page Faults without I/O 


Sequential 
Scan (Without 
Output To 
Screen 




77 

25 

67 


347.000 


0.076 

0.06 

0.289 

60.000 


277 

202 

476 

286 


191.779 

299.833 


0.113 

0.033 


2.633 

0.419 

7.464 

360.000 



299.500 


0.106 

0.026 

0.133 

34.000 



Table 4.5. Benchmark performance results for adacol.a and adacolc 


4-3 





























































Criteria Tested 

Resource 

Application Programs 

Percent 


Measured 

purobj.a 

purobj.c 

Change 

Initialize 

User time (seconds) 

0.267 

0.195 

+36.9 

(10,000 

CPU time (seconds) 

0.147 

0.218 

-32.6 

Objects 

Elapsed time (seconds) 

0.414 

0.412 

+0.5 

inserted ) 

Page Faults without I/O 

0.000 

0.000 

0.0 

Look up/Retrieve 

User time (seconds) 

0.007 

0.005 

+40.0 


CPU time (seconds) 

0.005 

0.005 

0.0 


Elapsed time (seconds) 

0.012 

0.011 

+9.1 


Page Faults without I/O 

0.000 

0.000 

0.0 

Sequential 

User time (seconds) 

4.267 

1.397 

+205.4 

Scan (With Output 

CPU time (seconds) 

34.394 

9.206 

+273.6 

to Screen) 

Elapsed time (seconds) 

335.349 

141.660 

+136.7 


Page Faults without I/O 

295.500 

306.000 

-3.4 

Sequential 

User time (seconds) 

0.015 

0.015 

0.0 

Scan (Without 

CPU time (seconds) 

0.033 

0.038 

-13.2 

Output To 

Elapsed time (seconds) 

0.050 

0.053 

-5.7 

Screen) 

Page Faults without I/O 

294.000 

295.000 

-0.3 


Table 4.6. Benchmark performance results for purobj.a and purobj.c 


Criteria Tested 

Resource 

Application Programs 

Percent 


Measured 

adaobj.a 

purobj.a 

Change 

Initialize 

User time (seconds) 

1.233 

r 0.267 

+361.8 

(10,000 

CPU time (seconds) 

0.321 

0.147 

+118.4 

Objects 

Elapsed time (seconds) 

6.502 

0.414 

+1470.5 

inserted ) 

Page Faults without I/O 

290.500 

0.000 

0.0 

Look up/Retrieve 

User time (seconds) 

0.023 

0.007 

+228.6 


CPU time (seconds) 

0.068 

0.005 

+1260.0 


Elapsed time (seconds) 

0.095 

0.012 

+691.7 


Page Faults without I/O 

134.500 

0.000 

0.0 

Sequential 

User time (seconds) 

4.200 

4.267 

-1.6 

Scan (With Output 

CPU time (seconds) 

30.295 

34.394 

-11.9 

to Screen) 

Elapsed time (seconds) 

181.928 

335.349 

-45.7 

■ 

■Page Faults witbout I/O 

265.667 

295.500 

-10.1 

Sequential 

User time (seconds) 

0.046 

0.015 

+206.7 

Scan (Without 

CPU time (seconds) 

0.146 

0.033 

+342.4 

Output To 

Elapsed time (seconds) 

0.195 

0.050 

+290.0 

Screen) 

Page fruits without I/O 

265.000 

294.000 

-9.9 


Table 4.7. Benchmark performance results for adaobj.a and purobj.a 







Criteria Tested 

Resource 

Measured 

Application Programs 

Percent 

Change 

adaobj.c 

purobj.c 

Initialize 

User time (seconds) 

0.966 

0.195 

+395.4 

(10,000 

CPU time (seconds) 

0.330 

0.218 

+51.4 

Objects 

Elapsed time (seconds) 

4.760 

0.412 

+1055.3 

inserted ) 

Page Faults without I/O 

319.000 

319.000 

0.0 

Look up/Retrieve 

User time (seconds) 

0.013 

0.005 

+160.0 


CPU time (seconds) 

0.083 

0.006 

+1560.0 


Elapsed time (seconds) 

0.097 

0.011 

+781.7 


Page Faults without I/O 

134.000 

0.000 

0.0 

Sequential 

User tin; (second;) 

0.611 

1.397 

-54.1 

Scan (With Output 

CPU time (seconds) 

14.576 

9.206 

+58.3 

to Screen) 

Elapsed im (seconds) 

144.643 

141.660 

+2.1 


Page Faults without I/O 

267.875 

306.000 

-12.5 

Sequential 

User time (seconds) 

0.029 

0.015 

-80.7 

Scan (Without 

CPU time (seconds) 

0.175 

0.038 

+360.5 

Output To 

Elapsed time (seconds) 

0.203 

0,053 

-61.7 

Screen) 

Page Emits without I/O 

265.375 

295.000 

-10.0 


Table 4.8. Benchmark performance results for adaobj.c and purobj.c 


cation and handling a pointer; the CPU time of Ada/ObjectStore is faster than C/ObjectStore. The 
sequential scan consistently shows that moving a pointer along the linked list of Ada/ObjectStore 
is indeed faster than what C/ObjectS?tore does. The performance that varies most significantly 
in both Tables is in sequential scan. CPU time and User time of Ada/ObjectStore are over 2 
times slower than that of C/ObjectStore. In the testing subprogram of sequential scan, timing 
is measured from traversing the link list and printing every note when it is traversed. In order 
to find out why the performance varies so significantly, a small change in testing subprogram of 
sequential scan was made. The testing only let processes traverse notes, but '’.very note traversed 
does not have to be printed out to the rcreen. The results of the performance tests are shown in 
Tbble 4.4 and Table 4.5. It shows the performance is not much different between Ada/ObjectStore 
and C/ObjectStore. The main actors affecting the result of performance still depends on the two 
languages’ own abilities. The performance of TEXT-10 in Ada is slower than the performance of 
printf in C. 

Tables 4.6 - 4.8 show the different performance of Ada and C in manipulating transient and 
persistent data. Thble 4.6 shows the test of a transient object only. Ada still does well in storage 
allocation. The pointer moving along the linked list is good, too. Consistently this shows that 
Ada is indeed good at handling the pointer moving. Both Ada and C performances decrease in 
order to provide data persistence. However, Tbble 4.7 and Table 4.8 show that the performance 
degradation is not much different between Ada and C when accessing ObjectStore. 


4-5 






Table 4.9. Comparison of file size written in Ada and C (static binding) 


Space usage is worthy of some examination. Source programs, executable programs and 
databases are observed. As we understand, source files are heavily dependent on the programming 
behavior of programmers. The size of executable programs are dependent on compilers used. Due 
to compiler limitations, we needed to use static binding when performing the link. Table 4.9 shows 
that both application programs’ sizes and executable programs’ sizes in Ada are larger than C’s. 
Strong type checking and the interface programs added overhead can probably explain this. 


4-3 Problems Encountered 

One of the objectives was to expand ObjectStore functions in Ada/ObjectStore as much 
as possible. Some difficulties arose because of the quite different syntax of the two languages. 
Most problems are categorized by understanding ObjectStore C library functions, limitations of 
the interface between Ada and C, and losing the ability of the programming tool-the debugger. 

4.3.1 Debugger. Most programs have errors in syntax and semantics. Ada is a strongly 
typed language. It can find syntactic problems at compile time. However, at run time, semantic 
errors need a debugger to trace out. The debugger can detect and report on a wide variety of 
problems, including variables that are used before they are set and after, and arguments in functions 
changed after functions are called. Verdix has a debugger, a.db, but it seems that it can not debug 
programs written in Ada/ObjectStore. When the debugger was executed, it would stop at statement 
“DATABASE-OPEN” and give an error message as follows: 

*'Segmentation fault'* 1/0 error: trying to read u.u_code [Onix errao: 5] 

—> Segmentation Violation (SIQSEQV) code: 2S5 (u.code: -1) 

All the Ada/ObjectStore programs I wrote are small test programs. Usually they are not 
over 300 lines. However, in a practical application system, programs are commonly over several 


4-6 




thousand lines. Without a debugger, a big obstacle lays in the way of developing a system using 
Ada/Ob jectS tore. 


4-S.S Understanding Oj jectS tort. ObjectStore’s documentation mainly describes C++ 
library functions, sad some of them have examples shown in the User Guide. C library functions 
are listed in the Reference Manual and the reader is referred to see the C++ analogous functions 
for detailed information. Theoretically, C++ and C are analogous. However, there are some cases 
where C is not quite compatible with C++ (11:41). Casting is used heavily in C, but not in C++ 
because C++ has a stronger type checking ability. OS-CURSOR is another example. In the C++ 
library, OS-CURSOR is declared a class and a constructor OS.CURSOR. To create a OS-CURSOR 
is to initialize the class OS-CURSOR with thejrequired argument, OS.COLLECTION. An example 
is “os.cursor cur(osjcollection) \ There are no pointer values returned. However, OS-CURSOR. 

I 

CREATE in the C library has quite a different syntax in which it will simply return a pointer that 
points to one element associated with its collection. 

i 

Databaaa.craata and databaaa J.ookup do not work with static binding. To remedy this, a 
program was implemented to perform only one job, creating a dat;. base. After the program created 
the database, the performance testing was then continued. 

Error messages indicated what errors occurred, but the specific information related to the 

j 

error is not fully explained. As previously stated, database.create does not wor 1 ; in static binding; 
the error message indicates “some kinds of initialization needed to be done”, but it does not show 
what kinds of initialization and how to initialise. 


4-9.3 Interface Limitations. Besides the limitation of Ada/C interface for handling pro¬ 
cedure variables, the Query facility in ObjectStore has a pre-analyzed query. To use this facility, 
it requires three steps (17:150): 


1. analysis of the query expression, 

2. binding of the free variable and function references in the query, and 

3. actual interpretation of the bound query 

The problem happens at the oa_keyword-arg_liat* when processes go to the actual interpretation 
of the bound query. The function os.boundjquery takes two arguments: a pre-analyzed query, and 
a keyword_arg list. It is defined as follows: 

•xtsrn os_bound_qu«ry* os_bound_qrery_create( 
os.coll.qnery*,/* the query to bind */ 


4-7 





os.ksyvord_arg_list* 

/* th« argument list with binding for fres vars */ 

); 

The os.keyword-arg-list is expressed in the following form: 

C 

ksyvord_arg-exprsssion, 

•••» 

•••» 

keyword.arg-exprsssion 

) 

Decause the arguments, consisting by keyword.args of keyword-argJist is not fixed, to simulate 
the same functionality in Ada may be complicated and inefficient. 

4-4 Summary 

Performance tests were performed for two kinds of areas using the Ada/ObjectStore and 
the functions of ObjectStore C library. A simple data structure was implemented to measure the 
performance. The result shows that there is not much difference when comparing the two languages 
that interface with ObjectStore; the difference still depends on the languages own properties. Some 
problems were encountered in the interfacing limitation that exists between the two language. Some 
problems were related to inadequacies in ObjectStore documentation. These difficulties affect the 
effort of implementing Ada/ObjectStore functions. 


4-8 




/ 







■. _jtf£j«iv it.Xy tities lai. >ibU.-r k ■» 



V. Conclusions and Recommendations 

5.1 Overview 

This chapter summarizes the activities in Ada accessing the ObjectStore database manage¬ 
ment system. Most basic and collection functions of the ObjectStore were implemented in several 
packages written in Ada, called Ada/ObjectStore. The functionality of Ada/ObjectStore are ana¬ 
lyzed. Some advantages and disadvantage are discussed in the conclusions. Finally, recommenda¬ 
tions are presented for future research to complete the interface. 

5,t Summary of Research 

In the activities of this thesis, the ObjectStore functions were first familiarized. Secondly, 
parallel data types in Verdix Ada and in ObjectStore were examined. Finally, the initial pro¬ 
totype Ada/ObjectStore created by Object Design, Inc., was extended by using functions in the 
ObjectStore C library. 

The packages of Ada/ObjectStore are implemented in a corresponding way to the functions in 
the ObjectStore C library. Most functions in the ObjectStore C library can be directly accessed from 
Ada without any change, but some of them require an intermediate level to handle incompatible 
types. However, the limitation of the interface implemented from Ada to C still strictly depends on 
the both languages’ properties. For example, C provides procedure variables and shift operators, 
but Ada does not. C provides simple bitwise binary logical operators, but standard Ada does 
neither. Verdix Ada provides a bitwise function in a package, but it is implementation-defined and 
its binary operations are limited by Ada’s syntax can not be expressed as simply as C does. 

To compare the performance of Ada/ObjectStore with C/ObjectStore, several test programs 
were written in Ada and in C. Timing routines were instrumented in the code to measure the time 
required to access the ObjectStore commands called from Ada and C. The test programs designed 
were based on testing database functionality. 


5.3 Conclusions 

The objectives of this thesis were to implement an interface that has functional completeness. 
Moreover, the performance of Ada/ObjectStore should not be much different than C/ObjectStore. 
Some problems arose and these problems may affect functional completeness. The following dis¬ 
cussion points out the advantages and disadvantages of this interface. 





S.S.l Data Persistence. The objective of data persistence is achieved in the interface. As 
described in Chapter 2, Ada does not support data persistence. However, ObjectStore, a DBMS 
using a C/C++ library interface, provides the ability to handle persistent data. Ada/ObjectStore 
accesses the database, v.hich is managed by the ObjectStore, in exactly the same way as the 
C/ObjectStore does; the subprogram in the programming language can handle persistent and 
transient data without difference. All persistent data are managed by ObjectStore, which provides 
data management abilities. 

Data persistence gives Ada programmers great benefits. First, they do not need to write 
program I/O statements. Second, they do not need to write a lot of statements for mapping 
values between transient and persistent data. Third, because program sizes are decreased, software 
productivity and maintainability are increased. 

S.S.l Reliability, Maintenance, and Efficiency. The Ada reference manual (1) points out 
“Ada was designed with three overriding concerns: program reliability and maintenance, program¬ 
ming as a human activity, and efficiency”. 

Ada is a strongly typed language. This is based on the design goal “program reliability and 
maintenance” (1). In order to achieve the reliability of the interface, certain rules must apply to 
ensure type safety that are described in section 3.3.2. For example, all variables need to be explicitly 
declared and their type specified. The compilers can then check to see that operations on these 
variables are compatible with the properties of their type. Because variables are safely manipulated 
in Ada, program reliability is maintained. 

Ada is proud of the standard coding format and this is acknowledged by all who have ever 
seen the Ada program. In contrast, C/C++ features ease of writing rather than ease of reading. 
The data persistence, which allows programming in clarity and simplicity, increases the advantages 
of the maintenance of the Ada programs. 

To achieve efficiency, Ada was constructed and carefully examined in the light of present 
implementation techniques. Any proposed construct whose implementation was unclear or that 
required excessive machine resources was rejected (I). This can be demonstrated from Table 4.4 in 
which the CPU time of Ada is faster than that of C. However, in order to add the ability of data 
persistence, which is provided by a database, some trade offs in efficiency must be faced. But the 
efficiency in Ada is not much worse than in C when they access ObjectStore. 

S.S.S Data Abstraction. Ada is not truly an OOPL, but the Ada contains most OOPL con¬ 
cepts, namely the encapsulation (package), information hiding (private types and package bodies), 


5-2 




and concurrent processing (task). In the interface, any type declared in Ada can be implemented 
with a corresponding base type in C. The Ada programmer has almost no limit to model the 
real world objects using Ada’s data abstraction. Information hiding is achieved via private types. 
Because data type is needed to be persistent in ObjectStore, the data type defined in Ada must 
be converted to an os.typespec before it can accompany its object stored to and retrieved from 
ObjectStore. The pragma INTERFACE statement for accessing os.typespec is allowed at the place 
after the data type are fully defined, and, if a private data type is defined, the pragma INTERFACE 
must appear in the same package specification after the type is fully declared. 

5.4 Recommendations for Future Research 

This thesis extended the prototype of the Ada/Objectbtore, extending its functional complete¬ 
ness. But the goal was not completely achieved. Most functions of collection in the ObjectStore 
C library can be accessed by the Ads. now, but still a lot of works need to be done. These are the 
transparent interface to Ada programmers, exception handling, and version management. 

5-4-1 Transparency. Ada/ObjectStore is not completely transparent to Ada program¬ 
mers. In on er to generate a parallel data structure in the ObjectStore a manual schema must be 
generated; a C macro facility is currently provided. Moreover, an INTERFACE call must be put in the 
main procedure before calling any function that is associated with os.typespec. The query facility 
of Ada/ObjectStore is another example. The query string, for example “strcmp(name,“Mike") == 
0)” for queryring a string type or “age == 35” for querying a scalar type, is still the C language’s 
syntax, “strcmp” and “==” in this example. To achieve the transparency, some intermediate 
subprogram needs to be created and act as preprocessor or translator. 

5-4-2 Exception Handling. Both Ada and the ObjectStore C library provide abilities 
for handling exceptions. The exception facility is very important for dealing with terrors or other 
exceptional situations during program execution. An exception can be raised by a raise statement 
or operations that propagate the exception. When an exception arises, control can be transferred 
to a user-provided exception handler. The interface of declaring exceptions is not completely 
implemented. 1 

5-4-3 Version Management. Version management is very important in the area of 
computer-aided design applications today. These applications need to increasingly support co¬ 
operative work by a number of engineers on the same design. Ada/ObjectStore does not yet 


5-3 







provide version management facilities. That means Ada/ObjectStore is not currently good in CAD 
applications or other applications that need data checked out for extended periods of time. 

5-4-4 Variant Records. Ada contains most of the concepts of the object oriented phi¬ 
losophy as described in 5.3.3. These features make Ada very close to an OOPL. However, the 
only major object oriented concepts not supported by Ada are dynamic binding and inheritance 
(15). Rumbaugh (19) and Leopold (15) pointed out that using variant records, Ada can have the 
ability of single inheritance. A variant record is a record structure and contains a discriminant that 
distinguishes the alternate forms of the record. C does not provide variant records in the si me way. 
However, the union type in C can perform the same capability in Ada. Therefore, the ability of 
variant records should be maintained in this interface. 

5.5 Summary 

Although Ada/ObjectStore is not completely implemented, the results that what have been 
developed are satisfactory. The performance of Ada/ObjectStore does not differ much with respect 
to C/ObjectStore, but the enhancement of abilities to manipulate persistent data is a great advan¬ 
tage for Ada. Many problems remain. Some of them are the completeness of functionality, and 
some are limitations of the languages. Ada has been acknowledged as a good language in maintain¬ 
ability. Binding to the OODBMS gives Ada great potential in the development and maintenance 
of complex, data intensive, engineering applications. 


5-4 






Appendix A. Raw Performance Test Results 

Test Program: hello_ost.a (C library interface) 



User 

CPU 

Elapsed 

Page Faults 

Disk Blocks 

Command 

Time 

Time 

Time 

K5S3S21 

I 

I 

K23 

mm\ 

Run Once 

0.030 

0.360 

0.786 

0 

mam i 

0 

o 


0.040 

0.370 

0.768 

0 

B9 

0 



0.040 

0.290 

0.728 

0 

214 

m 

o 


0.030 

0.380 

0.816 


213 

n 



0.040 

0.320 

0.800 

0 

flHIE31 

0 

o 


0.010 

0.350 

0.767 

0 

■9 

0 

BaBy *1 

Run 100 

0.700 

1.820 

mm 

0 

■ I Okfc 

D 

M BT1 

Times 

0.580 

1.860 

13.940 

0 

9 

n 

0 


0.700 

1.970 

14.480 

0 

1005 

0 

0 


0.660 

1.830 

13.652 

0 

1017 

0 

0 


0.710 

1.790 

13.764 

0 

1006 

n 

0 


0.730 

1.670 

13.892 

0 

1006 

El 



Teat Program: hello_ost.a (C++ library interface) 



User 

CPU 

Elapsed 

Page Faults 

Disk Blocks j 

Command 

Time 

Time 

Time 


WJOJfSM 

la 

mam 

Run Once 

0.040 

0-210 

HEXMI 

0 

W 1! 




0.020 

0-180 

0.585 

0 


n 



0.060 

0.250 

0.776 

0 

209 

0 



0.040 

0.190 

0.523 


209 

0 



0.050 

0.190 

0.475 

0 

209 

0 



0.050 

0.150 

0.482 

G 

209 

0 

0 

Run 100 

0.700 

1.650 

11.893 

0 

Mfm 

B1 

0 

Times 

0.640 

1.710 


0 

mm 

E1 



0.730 

1.680 


0 

H 

H 



0.730 

1.680 

8 . S 


mm 

0 



0.590 

1.830 


13 

mm3 .1 

0 

IpKp 


0.670 

1.730 


■H 

1001 

■3 

mm 


Test Program: hello_ost.c 



User 

CPU 

Elapsed 


Disk Blocks 

Command 

Time 

Time 

Time 

niinii 

1 

i 

El 

WKHEM 

Run Once 

0.040 

0.130 



■R9 

0 

MR 


0.030 

0.110 

0.313 

0 


0 

iilpli 


0.030 

0.140 

0.289 

0 

142 

0 

1 


0.060 

0.100 

0.298 


142 

m 



0.040 

0.070 

0.331 

; il 

142 

0 



0.030 

0.100 

0.319 

■n 

142 

0 

_oj 

Run 100 

0.710 

1.390 

11.416 

0 

950 


§H1 

Times 

0.580 

1.620 

13.762 

0 


n 

mm 


0.480 

1.660 

13.826 

0 



m.: 


0.600 

1.670 

14.624 



u 



0.630 

1.480 

12.356 

0 


El 

1J 


0.660 

1.530 

11.884 

igglgg^jl 

947 

El 

Ml 


A-l 





































































Test Program: adaobj.a 


Command 


Initialize 

( 10,000 

Objects 

inserted) 


Open & 
Close 


Elapsed 

Time 


Page Faults | Disk Blocks 


Lookup/ 

0.020 

0.080 


Retrieve 

0.020 

0.070 

0.095 


0.030 

0.060 

0.097 


0.020 

0.070 

0.100 


0.040 

0.050 

0.095 


0.010 

0.080 

0.094 

Sequential 

4.150 

32.730 

185.071 

Scan (With 

3.940 

29.450 

184.750 

Output 

4.270 

29.570 

185.649 

to Screen) 

4.220 

29.490 

190.724 


4.530 

29.700 

187.444 


4.090 

30.830 

157.928 

Sequential 

0.040 

0.140 

■jinn] 

Scan (Without 

0.070 

0.200 

0.264 

Output 

0.040 

0.140 

0.180 

to Screen) 

0.010 

0.170 

0.184 


0.060 

0.120 

0.181 


0.050 

0.140 

0.191 


0.040 

0.140 

0.185 


0.030 

0.150 

0.184 


291 
291 

291 

292 0 

293 0 
291 


60 0 
60 0 
60 0 
60 
60 
60 
60 
60 


134 
134 
134 
134 I 0 
134 I 0 
134 


0 

265 I 0 
















































Test Program: adaobj.c 



User 

CPU 

Elapsed 

Page Faults 

Dis 

Ic Blocks 

Command 

Time 

Time 

Time 

with I/O 

nnKii 

III 

Out 

Initialize 

0.960 

0.270 


0 

mmm 

0 

0 

(10,000 

0.980 

0.350 

4.518 

0 

■1 

0 

mam 

Objects 

0.980 

0.380 

5.783 

HI 

319 

m 

0 

inserted) 

0.970 

0.230 

4.344 

mm 

319 

0 

0 


0.950 

0.260 

5.102 

no 

319 

0 



0.980 

0.220 

4.331 

0 

319 

0 

H 


0.970 

0.680 

4.845 

0 

319 

0 

mm 


0.940 

0.250 

4.280 

nags! 

319 

0 

mt 

Open k 

0.040 

0.130 


■m 

60 

0 

0 

Close 

0.060 

0.060 



60 

0 

0 


0.040 

0.160 

0.271 

0 

60 

0 

0 


0.060 

0.160 



60 

0 

■ 


0.070 

0.130 


o 

60 

0 



0.070 

0.070 



60 

0 

mm i 


0.070 

0.120 


n 

60 

0 

0 


0.060 

0.120 



60 

0 

0 

Lookup/ 

0.000 

0.090 


0 

134 



Retrieve 

0.010 

0.080 

0.095 

0 

134 


1 


0.010 

0.090 

0.097 


134 

Bp 

mm 


0.000 

0.090 

0.100 


134 


0 


0.020 

0.070 

0.095 

0 

134 

B 

0 


0.010 

0.080 

0.093 

0 

134 

B 



0.030 

0.070 

0.105 

0 

134 

B 



0.020 

0.090 

0.102 


134 

B 

BK 

Sequential 

0.620 

14.520 

162.831 

0 

265 

HI 


Scan (With 

0.550 

13.850 

151.141 

0 

269 

0 


Output 

0.720 

13.260 

170.305 


268 

0 


to Screen) 

0.640 

16.480 

148.934 

0 

268 

0 



0.550 

14.280 

149.505 


268 

0 

HI" 


0.750 

13.300 

109.313 

0 

268 

0 

o 


0.750 

17.070 

113.976 


268 

0 



0.550 

13.850 

151.141 

0 

269 

0 

0 

Sequential 

0.030 


0.174 

i BJ 


0 

0 

Scan (Without 

0.020 


0.218 

^■1 


0 

0 

Output 

0.050 


0.214 

0 

■ 1 

0 

0 

to Screen) 

0.040 



0 

265 

0 

0 


0.010 


0.200 

He 

265 

0 

mm 


0.020 


0.215 


265 

0 

mt 


0.030 



<f§ -" ;, 5 

265 

0 

BE 


0.030 


0.195 


265 

0 

H 









































































































Test Program: adacol.c 


























































Test Program: purobj.a 


Command 

User 

Time 

CPU 

Time 

Elapsed 

Time 

. Page Faults 

Disk Blocks 


cma 

m 

(■KgSi 

Initialize 

0.260 

Km 

0.408 

1 0 

mmmm 


t o 

(10,000 

0.300 

0.110 

0.410 

t*'"' 



HI 

Objects 

0.280 

0.140 

0.419 


. 


0 

inserted) 

0.270 

0.140 

0.417 

■ ^ 

■ 

E 

mm 


0.230 

0.180 

0.417 






0.260 

0.160 

0.424 



E 

■o 

Lookup & 

0.010 

0.010 


0 

0 

n 

ol 

Retrieve 

0.010 

0.000 

0.015 

0 

0 

K 

■ 


0.000 

0.010 

0.011 

0 

0 

B 



0.010 

0.000 

0.011 

0 

0 

B 



0.010 

0.000 

0.012 

c 

0 

B 

\ • jn 


0.000 

0.010 

0.011 

MmmM 

0 

H 


Sequential 

3.730 

37.324 

337.607 

0 

296 

n 

■H 

Scan (With 

4.190 

27.853 

314.580 

0 

296 

B 


Output 

4.330 

27.003 

426.015 

0 

296 

B 

0 

to Screen) 

3.460 

48.485 

355.470 

0 

295 

B 

0 


5.061 

32.873 

338.379 

0 

295 

B 

■1 


4.830 

32.823 

240.044 

0 

295 

1 

mm 

Sequential 

0.010 

0.060 


0 

294 

0 

0 

Scan (Without 

0.020 

0.020 

0.042 


294 

0 

0 

Output 

0.020 

0.040 

0.059 


294 

0 

0 

to Screen) 

0.010 

0.030 

0.043 


294 

0 

HI 


0.020 

0.020 

0.042 

Sg ■ -P 

294 

n 

HI 


0.010 

0.030 

0.043 

HHE 

294 

H 

_oJ 


A-6 









































Test Program: purobj.c 


















































Appendix B. Test Programs 





B.l Test Program: adaobj.mk (for adaobj,a) 

include ((DS_ROOTDIR)/etc/ost>re.lib.mk 

LDLIE3 ■ -los -lose -loscol 

LIB.PATH * /tmp_mnt/home/cub2/lehou/dosork/osfilec 

OS_COMPILATION_SCHEMA_DB_PATH = /lchou/test/aenote.csdb 

OS.APPLICATION_SCHEMA.DB_PATH = /lchou/tefj/aenote.asdb 

ElCUTABLE ■ adaobj 

OBJECTS ■ .os.schema.o adaobj.o atatis.o ConmandStats.o 
SCHEMA.SQURCE = adaobj.cc 
CPPFLAGS ■ -gx -I.. 

SCHEMA > schema.adaobj 

adaobj: ((OBJECTS) 

a.make -L .. STATIS.ADA -t atatis.ada.a 
a.make -L .. adaobj -f adaobj.a 
mv a.out adaobj 
$(0S_R00TDIR)/lib/patch adaobj 

CommandStats.o: CommandStata.c 
cc ((CPPFLAGS) ((CFLAGS) -c CommandStats.c 

atatis.o: statis.c 

ec $(CPPFLAGS) ((CFLAGS) -c statis.c 
clean_obj: 

osrm -f ((OS_COHPILATION_SCHEMA_DB_PATH) 
osrm -f |(OS_APPLICATION_SCHEMA_DB_PATH) 
rm -f $(EXCUTABLE) ((OBJECTS) ((SCHEMA) 

include ../ada_new.mk 


B-2 







wmiMi- *mm*W*i* ftiiup ; jgg 'f.w 


w *mrn*m immgif*^mm*m. 


B.t Teat Program: adaobj.a 

with OS.TYPES; use OS.TYPES; 
with OSTORE; use OSTORE; 
with OSTORE.GENERICS; 
with TEXT.IO; use TEXT.IO; 
with LANGUAGE; use LANGUAGE; 
with STATIS.AOA; 

procedure ADAOBJ is 

pragma LINK.WITHC'-Bstatic .os.schema.o ../libosada.a adaobj .0 statis 0 
CommandStats.o -L/usr/local/objectstore/sun4/lib -los -lose"); 
subtype NOTE.STRING is STRING(1..20); 
type LINK.NOTE; 

type LINK.NCTE.PTR is access LINK.NOTE; 

type LINK.NOTE is 

record 

priority: INTEGER; 
name : NOTE.STRING; 

note : stringd..80); 

next : link.note.ptr; 
end record; 

package INT.IO is new integer.io(INTEGER); 
use INT.IO; 

subtype CHOICE.TYPE is integer range 0 .. S; 
package CHOICE.IO is new integer.io(CHOICE.TYPE); 

function c.link.note.typespec return OS.TYPESPEC; 
pragma INTERFACE(C, c.link.notj.typespec); 
pragma INTERFACE_NAME(c_link.note_typespec, 

C.SUBP.PREFIX k "c_link_note_typeapec"); 
package PERS.NOTE is new OSTORE.OENERICS(LINK.NOTE, LINK.NOTE.PTR, 

. ..-. c.link.note.typespec); 




ROOT : DATABASE.ROOT; 

OB : DATABASE; 

TX : TRANSACTION; 

N.IN : INTEGER; 



HTCHOICE : CHOICE.TYPE; 

V \ .. A' 


— 

\ , 

i 

procedure STRCPY(NAME : out string; 

NOTE.NAME : in string) is 

LEN : natural NOTE.NAME'LENGTH; 

begin 

i 

fi 

NAME(1.. LEN) NOTE.NAME(1..LEN) ; 

end STRCPY; 

\ 

! 

f 

{ ! i 

B-3 

' /'• 

i i 
t 

f , 

• > .. v , : j ... ! 

. r' ■ t ' .. A N • • /. j , . 

V. ' . 

l 1 i 

i;ir 

■v" ; ' '■ 1 

‘ ' !j 









function DATABASE_R£TRIEVE(NUMBER : integer; 

HEAD : LINK.NOTE.PTR) return LINK.NOTE.PTR is 

TEMP : LINK.NOTE.PTR; 
begin 

TEMP :« HEAD; 

while (NUMBER /= TEMP.PRIORITY) and then (TEMP /= NULL) 
loop 

TEMP :» TEMP.NEXT; 
end loop; 
return TEMP; 
end DATABASE.RETRIEVE; 


function INSERTOfEAD : LINK.NOTE.PTR; 

N : LINK.NOTE.PTR) return LINK.NOTE.PTR is 

begin 

N.NEXT := HEAD; 
return N; 
end INSERT; 

procedure DISPLAY_NOTE(N : LINK.NOTE.PTR) ia 
begin 

put(N.PRIORITY); 

put.lineC » t N.NAME); 
put.line(N.NOTE); 
new.line; 
end DISPLAY.NOTE; 


procedure TRAVERSE(HEAD : LINK.NOTE.PTR; 

10 : integer) ie 

TEMP : LINK.NOTE.PTR; 
begin 

TEMP HEAD; 
while TEMP /■ null loop 
if 10 /= 0 then 

DISPLAY.NOTE(TEMP); 
end if; 

TEMP :■ TEMP.NEXT; 
end loop; 
end TRAVERSE; 


procedure DATA.SCAN is 
HEAD : LINK.NOTE.PTR; 
begin 

DB :■ DATABASE_OPEN("/lchou/test/abnote,db", FALSE, 8#664#); 
TX :• TRANSACTION.BEGIN; 

HOOT :■ DATABASE.ROOT.FIND("ahead", DB); 

HEAD PERS.NQTE.DATABASE_ROQT_GET_VALUE(ROOT); 


B-4 






— start time 

STATIS.ADA.COMMANDSTATS(1); 
TRAVERSE(HEAD,1); 

— stop tins 

STATIS.ADA.COMKANDSTATS(0); 
TRANSACTION.COMMIT(TX); 
DATABASE.CLOSE(DB); 
and DATA.SCAN; 


procedure DATA.SCAN.NIO is 
HEAD : LINK.NOTE.PTR; 
begin 

DB :« DATABASE.OPENO'/lchou/test/abnote.db", FALSE, 8*664#); 
TX :* TRANSACTION.BEGIN; 

ROOT :=> DATABASE.ROOT.FIND("ahead", DB); 

HEAD :* PERS.NOTE.DATABASE.ROOT.GET.VALUE(ROOT); 

— start time 

STATIS.ADA.COMMANDSTATS(1); 

TRAVERSE(HEAD,0); 

— stop time 

STATIS.ADA.COMMANDSTATS(0); 

TRANSACTION.COMMIT(TX); 

DATABASE.CLOSE(DB); 
end DATA.SCAN.NIO; 


PROCEDURE DATA.RETRIEVE is 
INPUT.NUMBER : integer; 

BASIC.NOTE, 

HEAD : LINK.NOTE.PTR; 

begin 

put.lineO'Retrive a record, the priority is 5000"); 
INPUT.NUMBER :*> 5000; 

DB :» DATABASE_OPEN("/lchou/test/abnote.db", FALSE, 8*664#); 
TX TRANSACTION.BEGIN; 

ROOT :» DATABASE.ROOT.FIND("ahead", DB); 

HEAD PERS.NOTE.DATABASE.ROOT.GET.VALUE(ROOT); 

— start time 

STATIS.ADA.COHHANDSTATS(1); 

BASIC.NOTE DATABASE.RETRIEVE(INPUT.NUMBER, HEAD); 
DISPLAY.NOTE(BASIC.NOTE); 

— stop time 

STATIS.ADA.COMMANDSTATS(O); 

TRANSACTION.COKMIT(TX); 

DATABASE.CLOSE(DB); 
end data.retrieve; 


procedure DATABASL'.OPEN.CLOSE is 
HEAD ; LINK.NOTE.PTR; 







«*yyt.i3iiwi »* : > ■ ftiatititotviminifuf AJiAfcto 










COUNT : integer; 

begin 

COUNT := 1; 

— start time 

STATIS.ADA.COMMANDSTATS(1); 

repeat opening and closing a database 10 times 
while count <* 10 loop 

DB :- DATABASE.OPEN("/lchou/test/abnote.db", FALSE, 8#664*); 
TI TRANSACTION.BEGIN; 

BOOT :« DATABASE.ROOT.FIND("ahead", DB); 

HEAD := PERS_NOTE.DATABASE_ROOT_CET.VALUE(ROOT); 
TRANSACTION.COHMIT(TX); 

DATABASE.CLOSE(DB); 

COUNT := COUNT + 1; 
end loop; 

— stop time 

STATIS.ADA.COMMANDSTATS(0); 
end DATABASE.OPEN.CLOSE; 


procedure INITIAL.DB is 
BASIC.NOTE, 

HEAD : LINK.NOTE.PTR; 

COUNTER : integer : = l; 
begin 

DB :■ DATABASE.OPEN("/lchou/test/abnote.db", FALSE, 8#664#); 

— start time 

STATIS.ADA.COMMANDSTATS(1); 

TX :« TRANSACTION.BEGIN; 

ROOT :■ DATABASE_ROOT.FIND("ahead", DB); 
if invalid(ROOT) then 

ROOT :« DATABASE_CREATE_ROOT(DB, "ahead"); 

HEAD := PERS.NOTE.DATABASE.ROOT.GET_ VALUE(ROOT); 
for COUNTER in 1 .. 10000 loop 

BASIC.NOTE :*> PERS.NOTE.PERSISTENT.NEV(DB); 
case (COUNTER mod 10) is 
when 0 ■> 

BASIC.NOTE.PRIORITY :« counter ; 

STRCPY(BASIC.NOTE.NAME ."Danile"); 

STRCPY(BASIC.NOTE.NOTE ,"you need meet your friend tomorrow"); 
when 1 ■> 

BASIC.NOTE.PRIORITY counter ; 

STRCPY(BASIC.NOTE.NAME ."Susan"); 

STRCPY(BASIC.NOTE.NOTE ,"you need meet Course commitee at 9:00"); 
when 2 ■> 

BASIC.NOTE.PRIORITY :<* counter ; 

STRCPY(BASIC.NOTE.NAME ,"Li"); 








STRCPY(BASIC.NOTE.NOTE ."Enjoy the silent night in Lab"); 
when 3 => 

BASIC.NOTE.PRIORITY := counter ; 

STRCPY(BASIC.NOTE.NAME ."Chars"); 

STRCPY(BASIC.NOTE.NOTE ."You may meet me at 11:00"); 

when 4 “> 

BASIC.NOTE.PRIORITY :» counter ; 

STRCPY(BASIC.NOTE.NAME ."Mike"); 

STRCPY(BASIC.NOTE.NOTE ."We have an appointment vith principle"); 
when 5 ■> 

BASIC.NOTE.PRIORITY := counter ; 

STRCPY(BASIC.NOTE.NAME ,"Coan"); 

STRCPY(BASIC.NOTE.NOTE ,"Ve found a book you lost"); 

when 6 *■> 

BASIC.NOTE.PRIORITY := counter ; 

STRCPY(BASIC.NOTE.NAME ."Nancy"); 

STRCPY(BASIC.NOTE.NOTE ."Study Chapter 10 of OS"); 

when 7 »> 

BASIC.NOTE.PRIORITY :«* counter ; 

STRCPY(BASIC.NOTE.NAME ,"Petrie"); 

STRCPY(BASIC.NOTE.NOTE ."Please collect class addresses."); 
when 8 => 

BASIC.NOTE.PRIORITY :« counter ; 

STRCPY(BASIC.NOTE.NAME ."Jenny"); 

STRCPY(BASIC.NOTE.NOTE ."Happy New Year"); 

when 9 *> 

BASIC.NOTE.PRIORITY :* counter ; 

STRCPY(BASIC.NOTE.NAME ,"Amy"); 

STRCPY(BASIC.NOTE.NOTE ."Merry Christmas"); 

when others *> null; 
end case; 

HEAD INSERT(HEAD, BASIC.NOTE); 

end loop; 

PERS.NOTE.DATABASE.ROOT.SET.VALUE(ROOT, HEAD); 

else 

put.line("DATABASE abnote.db already exist !!, osrm it !!!"); 
end if; 

TRANSACnON.COKMIT(TX); 

DATABASE.CLOSE(DB); 

— stop time 

STATIS.ADA.COKMANDSTATS(0); 
end INITIAL.DB; 


B-7 




begin — NOTE 

INIT.ADA.INTERFACE; 
loop 
loop 
begin 

put.lineC 1 ** TESTING MENU **"); 

put.lineC 0. INITIAL DATABASE : ABNOTE.DB"); 

put.lineC 1 1. TESTING THE OPENING(CLOSING) DATABASE"); 

put.lineC 1 2. TESTING THE LOOKUP AND RETRIEVE"); 

put.line(" 3. TESTING THE SEQUENTIAL SCANING"); 

put.lineC' 4. TESTING THE SEQUENTIAL SCANING (WITHOUT OUTPUT)"); 

put.lineC 1 6. BYE !!"); 

PUT("INPUT -> "); 
cboice.io. get (MYCHOICE); 
text.io.skip.line; 
exit; 
exception 

when data.error I constraint.error «> 
text.io.skip.line; 

text.io.put.lineC'Your choice must be between 0 and 5"); 
text.io.new.line; 

end; 

end loop; 

— do different tasks from here 

case MYCHOICE is 
when 0 *> 

INITIAL.DB; 
when 1 «=> 

DATABASE.OPEN.CLOSE; 
when 2 *> 

DATA.RETRIEVE; 

when 3 => _ 

DATA.SCAN; 
when 4 => 

DATA.SCAN.NIO; 
when 5 »> 
exit; 

when others *> null; 
end case; 
end loop; 
end ADAOBJ; 






B.S Test Program: adacol.mk (for adacol.a) 

Include f(OS_ROOTDIR)/etc/oatore.lib.mk 
LDLIBS » -loa -loac -loacol 

LIB_PATH ® /tmp_mnt/home/cub2/lcliou/dovork/osfilec 
OS.COMPILATION_SCHEMA_DB.PATH « /lchou/teat/aenote.esdb 
OS_APPLICATION.SCHEMA.DB.PATH « /lchou/test/acnote.aadb 
ElCUTABLE * adacol 

OBJECTS = .oa.achema.o adacol.o atatia.o Commandstata.o 
SCHEMA.SOURCE * adacol.cc 
CPPFLAGS = -gx -1.. 

SCHEMA * achema.adacol 

adacol: $(OBJECTS) 

a.make -L .. STATIS.ADA -f atatia.ada.a 
a.make -L .. adacol -f adacol.a 
mv a.out adacol 
$(0S.R00TDIR)/lib/patch adacol 

CommandStata.o: CommandStata.c 

cc $(CPPFLAGS) $(CFLAGS) -c ComaandStata.c 

atatia.o: atatia.c 

cc $(CPPFLAGS) l(CFLAGS) -c atatia.c 

clean_col: 

oarm -f KOS.COMPILATIOH.SCHEKA.DB.PATH) 
oarm -f $(OS_APPLICATION_SCHEMA_DB_PATH) 
zm -f $(EXCUTABLE) l(OBJECTS) $(SCHEMA) 


include ../ada.new.mk 






B.4 Test Program: adacol.a 


with OS.TYPES; use OS.TYPES; 
with OSTORE; use OSTORE; 
with OSTORE.GENERICS; 
with OS.COLLECTION.PKG; 
with OS.CURSOR.PKG; 
with TEXT.IO; use TEXT.IO; 
with LANGUAGE; use LANGUAGE; 
with STATIS.ADA; 

procedure ADACOL is 

pragma LINK_WITH("-Bstatic .os.schema.o ../libosada.a adacol.o static.o 
CommandStats.o -L/usr/local/objectstore/sun4/lib -los -lose -loscol"); 
subtype NOTE.STRING is STRING(1..20); 
type NOTE.COL; 

type NOTE.COL.PTR is access N0TE_C0L; 

type N0TE_C0L is 

record 

priority: INTEGER; 
name : NOTE.STRING; 

note : string(l..80); 

next : note.col.ptr; 
end record; 

package INT.IO is new integer_io(INTEGER); 
use INT.IO; 

subtype CHOICE.TYPE is integer range 0 .. 6; 
package CHOICE.IQ is new integer_io<CHOICE_TYPE); 

function c_note_col_typespec return OS.TYPESPEC; 
pragma INTERFACED, c.note.col.typespec); 
pragma INTERFACE_NAME(c_note..col_typespec, 

C.SUBP.PREFIX k “c.note.col.typespec"); \ 

package PERS.NOTE is new OSTORE.GENERICS(NOTE.COL, NOTE.COL.PTR, x 

c_note_eol_typespec); 


— os.collection’s type 

function c.os.collection.typespee return OS.TTPESPEC; 
pragma INTERFACE(C, c_os_collection_typespec); 
pragma INTERFACE_NAME(c_os_collection_typespec, 

C.SUBP.PREFIX k "c.os.collection.typespee"); 


package COLL.NOTES is new OSTORE.GENERICS(U.TYPE ■> NOTE.COL, 

U.TYPEPTR “> NOTE.COL.PTR, 
GET.US.TYPESPEC ■> c.cs.collection.typespec); 


B-10 







package OS.COLL is new OS.COLLECTION.PKG(U.TYPE =■> NOTE.COL, 

U.TYPEPTR «> NOTE.COL.PTR, 
GET.OS.TYPESPEC *>c_os_collection_typespec) 

package OS.CURSORS is new OS.CURSOR.PKG(U.TYPE => NOTE.COL, 

U.TYPEPTR »> NOTE.COL.PTR); 


ROOT : DATABASE.ROOT; 

DB : DATABASE; 

TX : TRANSACTION; 

N.IN : INTEGER; 

MYCHOICE : CHOICE.TYPE; 


procedure STRCPY(NAME : out string; 

NOTE.NAME : in string) is 
LEN ; natural NOTE.NAME'LENGTH; 
begin 

NAME(i.. LEN) NOTE.NAME(1..LEN); 
end STRCPY; 


procedure DISPLAY_NOTE(N : NOTE.COL.PTR) is 
begin 

put(N.PRIORITY); 

put.lineC " ft N.NAME); 
put.line(N.NOTE); 
new.line; 
end DISPLAY.NOTE; 


procedure DATA.SCAN is 
HEAD ; OS.COLLECTION; 

P ; NOTE.COL.PTR; 

COR : OS.CORSOR; 

begin 

DB :* DATABASE_OPEN("/lchou/test/acnote.db". FALSE, 8#664#); 
IX TRANSACTION.BEGIN; 

ROOT :■ DATABASE.ROOT.FIND("ahead", DB); 

HEAD :» COLL.NOTES.DATABASE_ROOT_GET_VALUE(RQOT); 

— start time 

STATIS.ADA.COMMANDSTATS(1); 

— iteration 

CUR :» OS.CURSORS.OS.CURSOR.CREATE(HEAD); 

P NOTE.COL.PTR(OS.CURSORS.OS.CURSOR.FIRST(COR)); 

while (OS.CURSORS.OS.CURSOR.MORE(CUR)) loop 
DISPLAY.NOTE(P); 

P:“OS.CURSORS.OS.CORSOR.NEXT(CUR); 


B-ll 







•nd loop; 

OS.CUBSORS.OS.CURSOR.DELETE(CUR); 
— stop time 

STATIS.ADA.COHMANDSTATS(0); 

TRANSACTION.COMMIT(TX); 

DATABASE.CLOSE(D8); 
and DATA.SCAN; 


procedure DATA.SCAN.NIO is 
HEAD : QS.COLLECTIQN; 

P : NOTE_COL_PTR; 

COR : OS.CORSOR; 

begin 

DB DATABASE_OPEN("/lchou/teat/acnote.db", FALSE, 8*664#); 

TX :■ TRANSACTION.BEGIN; 

ROOT DATABASE.ROOT.FINDCahead", DB); 

HEAD :» COLL.NOTES.DATABASE.ROOT.GET.VALUE(ROOT); 

— start time 

STATIS.ADA.COHMANDSTATS(1); 

— iteration 

COR :« OS_CORSORS.OS_CORSOR_CREATE(HEAD); 

P NOTE_COL_PTR(OS.CURSORS.OS_CURSOR_FIRST(COR)); 

while (OS.CURSORS.OS_CURSOR_MORE(CUR)) loop 
P:=0S_CURS0RS.OS.CURSOR.NEXT(COR); 
end loop; 

OS.CORSORS.OS_CORSOR_DELETE(COR); 

— atop time 

STATIS.ADA.COHMANDSTATS(0); 

TRANSACTION.COMMIT(TX); 

DATABASE.CLO SE(DB); 
end DATA.SCAN.NIO; 


PROCEDURE DATA.RETRIEVE ia 

INPUT.STRING : STRING(1 .. 130) :»(others => * *); 

QUERIED.NOTE, 

BEAD : OS.COLLECTION; 

P : NOTE.COL.PTR; 

COR : OS.CORSOR; 

begin 

put_line("Retrive a record, tb# priority ia 8000"); 

DB :« DATABASE_OPEN("/lchou/teat/acnote.db", FALSE, 8*664#); 
TX TRANSACTION.BEGIN; 

ROOT :« DATABASE.ROOT.FINDCahead", DB); 

HEAD :» COLL.NOTES.DATABASE.ROOT.GET.VALUE(ROOT); 

— start time 

STATIS.ADA.COHMANDSTATS(1); 






STRCPY(INPUT.STRING, "priority == 5000"); 

QUERIEDJJOTE := OS.C0LL.OS_COLL£CTION_QUERY(HEAD,"note.col*" 
,INPUT.STRING,DB); 

— iteration 

CUR :« OS.CURSORS.OS.CURSOR.CREATE(qUERIED.NOTE); 

P :« NOTE_COL_PTR(OS_CURSQRS.OS.CURSOR.FIRST(CUR)); 
while (OS.CURSORS.0S_CURS0R_M0RE{CUR)) loop 
DISPLiY.NOTE(P); 

P:*OS_CURSORS.QS.CURSOR.NEXT(CUR); 
end loop; 

OS.CURSORS.OS.CURSOR.DELETE(CUR); 

— atop time 

STATIS.ADA.COMMANDSTATS(0); 

TRANSACTION.COMMIT(TX); 

DATABASE.CLOSE(DB); 
end data.retrieve; 


procedure DATABASE.OPEN.CLOSE is 
HF.in : OS.COLLECTION; 

COUNT : integer; 

begin 

COUNT 1; 

— atart time 

STATIS.ADA.COMMANDSTATS(1); 

— repeat opening and doaing a database 10 times 
while count <= 10 loop 

DB DATABASE_OPEN("/lchoo/teat/acnote.db", FALSE, 8#664#); 
TX TRANSACTION.BEGIN; 

ROOT :« DATABASE_ROOT.FIND("ahead", DB); 

HEAD COLL.NOTES.DATABASE_ROOT_GET_VALUE(ROOT); 

TRANSACfION.COHMIT(TX); 

DATABASE.CLOSE(DB); 

COUNT :» COUNT + 1; 
end loop; 

— atop time 

STATIS.ADA.COMMANDSTATS(0); 
end DATABASE.OPEN.aOSE; 


procedure 1NITIAL.DB ia 
BASIC.NOTE : NOTE.COL.PTR; 

HEAD : OS.COLLECTION; 

COUNTER : integer := 1; 
begin 

DB DATABASE.OPEN("/lchou/test/acnote.db", FALSE, 8*664#); 

— start time 

STATIS.ADA.COMMANDSTATS(1); 

TX TRANSACTION.BEGIN; 


B-13 





ROOT := DATABASE.ROOT.FINDC'ahead", DB); 
if invalid(ROOT) then 

ROOT :» DATABASE_CR£ATE_ROOT(DB, "ahead"); 

HEAD OS.COLL.OS.COLLECTIQN.CREATE(DB, 

"maintain.cursors | maintain_order",10); 
for COUNTER in 1 .. lOOOO loop 

BASIC.NOTE :* PERS.NOTE.PERSISTENT_KEW(DB); 
case (COUNTER mod 10) is 
when 0 »> 

BASIC_NCTE.PRIORITY :» counter • 

STRCPY(BASIC.NOTE.NAME ."Danila"); 

STRCPY(BASIC.NOTE.NOTE ."you need meet your friend tomorrow"); 
vhen 1 *> 

BASIC.NOTE.PRIORITY :« counter ; 

STRCPY(BASIC.NOTE.NAME ."Susan"); 

STRCPY(BASIC.NOTE.NOTE ."you need meet Course commitee at 9:00"); 
vhen 2 »> 

BASIC.NOTE.PRIORITY := counter ; 

STRCPY(BASIC.NOTE.NAME ."Li"); 

STRCPY (BASIC.NOTE j. NOTE ."Enjoy the silent night in Lab"); 

vhen 3 => i 

BASIC.NOTE.PRIORITY :* counter ; 

STRCPY(BASIC.NOTE.NAME ."Chars"); 

STRCPY(BASIC.NOTE1NOTE ."You may meet me at 11:00"); 

vhen 4 => j 

BASIC.NOTE.PRIORITY :- counter ; 

STRCPY(BASIC.NOTE;NAME ."Mike"); 

STRCPY(BASIC.NOTEiNOTE ,"We have an appointment vith principle"); 

j 

vhen S ■»> 

BASIC.NOTE.PRIORITY :=» counter ; 

STRCPY(BASIC.NOTE.NAME ."Coan"); 

STRCPY(BASIC.NOTE.NOTE ,"We found a book you lost"); 
vhen 6 *> 

BASIC.NOTE.PRIORITY :« counter ; 

STRCPY(BASIC.NOTE.NAME ."Nancy"); 

STRCPY(BASIC.NOTE.NOTE ."Study Chapter 10 of OS"); 

vhen 7 ■> 

BASIC.NOTE.PRIORITY :- counter ; 

STRCPY(BASIC.NOTE.NAME ."Patric"); 

STRCPY(BASIC.NOTE.NOTE ."Please collect class addresses."); 
vhen 8 »> 

BASIC.NOTE.PRIORITY :- counter ; 

STRCPY(BASIC.NOTE.NAME ."Jenny"); 


B-14 






STRCPY(BASIC.NCTE.NOTE ."Happy New Year"); 
when 9 => 

BASIC.NOTE.PRIORITY := counter ; 

STRCPY(BASIC.NOTE.NAME ,"Amy"); 

STRCPY(BASIC.NOTE.NOTE ."Merry Christmas"); 

when others •*> null; 
end case; 

0S_C0LL.OS.COLLECTION.INSERT(HEAD, BASIC.NOTE); 
end loop; 

COLL.NOTES.DATABASE.ROOT.SET.VALUE(ROOT, HEAD); 

else 

put.line("DATABASE acnote.db already exist !!, osrm it !!!"); 
end if; 

TRANSACTION.COMMIT(TX); 

DATABASE.CLOSE(DB); 

— atop time 

STATIS.ADA.COMMANDSTATS(0); 


end INITIAL.DB; 


begin — NOTE 

INIT.ADA.INTERFACE; 

OS.COLL.OS.COLLECTION.INITIALIZE; 


loop 

loop 

begin 

put.lineC** 
put.lineC 0. 
put_line(" 1. 
put.lineC 2. 
put.lineC 3. 
put_line(" 4. 
put.lineC' 5. 
PUT("INPUT -> 


TESTING MENU **"); 

INITIAL DATABASE : ACNOTE.DB"); 

TESTING THE OPENING(CLOSING) DATABASE"); 

TESTING THE LOOKUP AND RETRIEVE"); 

TESTING THE SEQUENTIAL SCANING"); 

TESTING THE SEQUENTIAL SCANING (WITHOUT OUTPUT)") 
BYE !!"); 

"); 


choice.io.get(MYCHOICE); 
text.io.akip.line; 


exit; 


exception 

when data_error I constraint.erroi. ■> 


end; 

end loop; 


text.io.akip.line; 

text.io.put.lineCYour choice must be between 0 and 5"); 
text.io.new.line; 


— do different tasks from here 


case MYCHOICE is 
when 0 “> 


B-15 








INITIAL.DB; 
when 1 => 

DATABASE.QPEN.CLOSE 
when 2 => 

DATA.RETRIEVE; 
when 3 => 

DATA.SCAN; 
when 4 *> 

DATA.SCAN.NIO; 
when 6 *=> 
exit; 

when others => null; 
end case; 
end loop; 
end ADACOL; 





B.5 Test Program: adaobj.mk (for adaobj.c) 

include KOS_ROOTDIR)/etc/ostore.lib.mk 
OS.COHPIUTION_SCHEHA_DB.PATH* /$(USER)/test/bnote.csdb 
OS.APPLICATION_SCHEMA_DB.PATB* /$(USER)/test/bnote.a«db 
LDLIBS * -los -lose 

SOURCES * adaobj.c CommandStats.c skza_adao.ee ct.bnote.c 

OBJECTS * adaobj.o CommandStats.o skm_adao.o ct.bnots.o 

EXECUTABLES * adaobj ct.bnote 
CPPFLAGS • -IKOS.ROOTDIR)/include 
CFLAGS ■ -gx 
CC ■ cc 

LIB.PATB ■ -L/usr/local/objectstore/sun4/lib 
all: $(EXECUTABLES) 

adaobj: adaobj.o CommandStats.o schema.standin.Adao 
KOS.PRELINK) .os_schema.cc \ 

KOS.COMPIUTION_SCHEMA_DB.PATH) KOS.APPLICATION_SCHEHA_DB.PATH) \ 
adaobj.o $(LDLIBS) 

OSCC -c .os_schema.cc 

I(LINK.c) -o adaobj -Bstatic adaobj.o \ 

CommandStats.o .os_schema.o f(LDLIBS) 

KOS.POSTLINK) adaobj 

Ct.bnote: ct.bnote.o schema_standin_Adao 
KOS.PRELINK) .os_schema.cc \ 

KOS_COMPILATION_SCHEMA_DB_PATH) $(OS_APPLICATION_SCHEMA_DB_PATH) \ 
ct.bnote.o 0(LDLIBS) 

OSCC -c .os_schema.cc 

KLINK.c) -o ct.bnote ct.bnote.o .os.schema.n KLDLIBS) 

KOS.POSTLINK) ct.bnote 

adaobj.o: adaobj.c 

KCG) $(CPPFLAGS) t(CFLAGS) -c adaobj.c 

CommandStats.o: Commandstata.c 
KCC) $(CPPFLAGS) $(CFLAGS) -c CommandStats.c 

schema.standin.Adao: skm_adao.cc 
OSCC KCPPFLAGS) -batch.schema KOS.COKPIUTION.SCHEMA.DB.PATH) ska_adao.ee 
touch schema.standin.Adao 

clean: 

osrm -f KOS.COMPIUTION.SCHEKA_DB.PATH) 
osrm -f KOS.APPLICATION_SCHEMA_DB.PATH) 
ra ~f t(EXECUTABLES) K08JECTS) scheaa.standin.Adao 

depend: .depend.B 

.depend.B: 

oanakedep .depend.B KCPPFUGS) -files l(SOURCES) 


B-17 









include .depend.B 










B.6 Test Program: adaobj.c 


/* file : adaobj.c program - main file 
ObjectStore C library 
implemented by Li Chou, is Jan 1993. 

*/ 

•include <stdio.h> 

•include <ostore/ostore.h> 

•include <stringa.h> 

•include <sya/time.h> 

•include <sya/reaource.h> 

•include "adaobj.h" 


extern FILE *basic_file; 

void initial.dbO; 

void database.open.closeO; 

void data.retrieveQ; 

void data.scanO; 

void data_acan_nio(); 

struct link_note *datnbane_retriev«Q; 

void display_note(); 

void traverseO; 

void exit(); 

/* global timing variables for CommandStats — Jacobs 18/09/91 */ 
static struct timeval elapsed; 
static struct rueage exec; 
database *db; 
database.root *root; 

/* allocat os.typeapec */ 
os.typespec *note_pad_type; 


main() 

{ 

char choose; 


start.objectstoreO; 

note_pad_type ■ alloc_typespecClink_note",0); 


/*— main loop — 
drive manual 

— choose input by user */ 
while (1) { 


printfC** Testing Menu **\n"); 
printfC 0. Initial database : bnota.db\n"); 
printfC 1. Testing the opening(closing) database\n H ); 
printfC 2. Testing the lookup and retrieve\n"); 
printfC 3. Testing the sequential scaning\n n ); 


/■ 


B-19 







printf(" 4. Tasting the sequential acaning (without output to acreen)\n"); 
printf(" S. Byo H\n‘‘); 
printf("Input -> "); 
while (scanf("Xc" , tchoose) *=1) { 
if (chooae <= ’5’ k* choose >= ’O') 
break; 

> 

it (choose =■ ’6’) exit(i); 

switch (choose) { 
case *0’ : 
initial.dbO; 
break; 
case *1’ : 

database.open.closeO; 
break; 
case ’2> : 

data_retrieve(); 
break; 
case *3* : 
data_scan(); 
break; 
case *4’ : 

data_scan_nio(); 
break; 

> 

> 

> 

void database.open.closeO 

struct link.note *head; 

1st count; 

count " 1; 

/* Start time commandstat */ 

Commandstats(l, stdout, kelapsed, texec); 

/* repeat opening and closing a database 10 times */ 
while (count <*> 10) { 

db « databaae_lookup_open("/lchou/test/bnote.db", 0, 0664); 
0S_BEGIN.TX)I(txl,0,transaction.update) { 
root ■ database.root.findCahead", db); 
head « database_root_get_value(root, note.pad.type); 

> OS.END.TXN(txl); 
database.close(db); 

♦♦count; 

> 

/• Stop time conanandstat */ 

CommandStats(0, stdout, telapaed, texec); 


B-20 








^4'f , <^rT-nW~Tfi , & - - -1 - •' >y ir l iSfiV^H^frrMr < 4*ri- -^-r- -ftV'rVt“' A r• • ti^‘gr w flri , --^‘^ : - w 't^. 


▼old d*ta_r«triev«() 

< 

int input.number; 

struct linb.note abaslc.noto, ahead; 


printf("Retrive a record, the priority is 6000V&"); 

/a if (scanf("Xd", hinput.number) “ i) */ 
input.number * 5000; 

db ■ databas«_lookup_open("/lchou/teat/bnote.db", 0, 0664); 
OS_BEGIK_TXN(txl,0,transaction.update) { 
root ■ database_root_find("ahead", db); 
bead ■ databaae.root.get.value(root, note.pad.type); 

/a Start time commandstat •/ 

Commandstata(l, stdout, Jtelapsed, Jtexec); 
basic.note * database.retrieve(input.number, bead); 
display_note(basic_note); 

/a Stop time commandstat a/ 

CommandStats(0, stdout, Jtelapsed, fcexee); 

> 0S.END.1XR(txl); 
database.close(db); 

> 

void data_scan() < 
struct link.note ahead; 

db « databaee_lookup_open("/lchou/teat/bnote.db", 0, 0664); 
0S_BE0IN_TXN(txl,0.transaction.update) { 

root ■ database.root_find("ahead", db); 

head ■ databaae.root.get.value(root, note.pad.type); 

/• Start time commandstat •/ 

CommandStats(l, stdout, Jtelapsed, Jtexec); 
traverse(head,1); 

/* Stop time commandstat */ 

ComaandStats(0, stdout, Jtelapsed, Jtexec); 

> OS.END.TXN(txl); 
database.close(db); 

> 

void data_acan_nio() { 
struct link.note ahead; 
void traverse O; 

db ■ database_lookup_open("/lchou/test/bnote.db", 0, 0664); 
0S_BEGIH_TXN(txl,0,transaction_update) { 

root » database.root.find("ahead", db); 

head ■ database.root.get.value(root, note_pad_type); 

/a Start time commandstat a/ 

CoamandStatsd, stdout, Jtelapsed, Jtexec); 
traverse(head,0); 








1 -i, -11..1 U JS(» jf" w WII 






'■ ll y-r k-l- jAp J~ '. \ 




/* Stop tine comm&ndstat *•/ 
CommandStats(0, stdout, fcelapsed, fcexec); 
> OS_END_TZN(txi); 
databcse.close(db);} 


/* retrieve a note */ 

struct link.note *database_rotrieve(numb, link.hcad) 
int numb; 

struct link_note *link_heau; 

{ 

struct link.note *tenp; 
temp o link.head; 

utile ((numb !“ temp -> priority ) kb (temp != NULL)){ 
temp “ temp-> next; 

> 

return temp; 

} 


A Print out to the specified stream this note */ 
void display.note(n) 
struct link.note *n; 

i 

printf("priority (Xd) name Xs \n", n->priority, n->name); 

printf("note Xs\n", n -> note); 

} 

/* Insert a node */ 
struct link.note *insert(p, q) 
struct link_note *p; 
struct link.note *q; 

< 

q -> next* p; 
return q; 

> 

/* Sequencial leaning */ 
void traverso(anote,io) 

VOTE anote; 
int io; 

{ 

VOTE temp; 

teap ■ anote; 
while (teap !■ BULL) { 
if (io !■ 0) { 

display.note(temp); 


B-22 











tamp * tamp -> nart; 


void initial.dbO 

{ 

/a global timing variable* for ComsandStat* — Jacob* 18/09/91 */ 
static struct timeval elapsed; 
static struct rusags axec; 
database *db; 
database.root *root; 
struct link.note ahead, abasic.note; 
int counter; 

di> ■ databasa_lookup_open("/lchou/tast/bnota.db M , 0, 0664); 

/a Start time commandstat a/ 

CommandStatsCl, stdout, fcelapsed, fcexec); 

OS.BEGIN.TXNCtrl,0,transaetion.update) { 
root ■ databasa_root_find("ahead", db); 
if (!root) { 

root ■ database_create_root(db, "ahead"); 

> 

else 

{ 

printf("The database exist !! osra it first !!l\n"); 
exit(); 

> 

head <• databasa.root .get .value (root, note.pad.type); 
for (counter ■ 1; counter <■ 10000; a+counter){ 

basic_note * (struct link.note*) objectstore.alloc(note.pad.type, 1, db); 
switch (counter - ((int)(counter/10)) a 10) { 
case 0 : 

basic.note -> priority ■ counter ; 

Strepy(basic.note -> name ,"Danila"); 

strcpy(basic_note -> note ,"you need meet your friend tomorrow"); 
break; l 

case 1 ; 1 

basiejnote -> priority » counter ; 
strepy (basic.', • -> name ,"Susan"); 
strcpy(basic_note -> note ,"you need meet Course commitee at 9:00”); 
break; 

case 2: 

basic_note -> priority ■ counter ; 
strepy(baaic_note -> name ,"Li"); 

strepy(basic.note -> note ."Enjoy the silent night in Lab"); 
break; 

cane 3 : 

basic.note -> priority ■ counter ; 


B-23 









>1? 


iuj.i'leaiini'<*Lli+ iaiiS&Stievi :"Uo'WSliSaIa^4svi?Jf 




8trcpy(basic_note -> name ,"Chars"); 

atrcpy(basic_note -> note ,"You may meet me at 11:00"); 
break; 
case 4 : 

baaic_note -> priority * counter ; 
atrcpy(basic_note -> name ."Mike"); 

■trcpy(baaic_note -> note ,"We have an appointment with principle"); 

break; 
caae 6 : 

basic.note -> priority * counter ; 
atrcpy(baaic_note -> name ,"Coan"); 
atrcpy(baaic_note -> note ,"We found a book you loat"); 
break; 
caae 6 : 

baaic.note -> priority ° counter ; 
atrcpy(basic_note -> name ."Nancy"); 
atrcpy(baaic_note -> note ."Study Chapter 10 of OS"); 

break; 
caae 7 : 

baaic.note -> priority = counter ; 
atrcpy(basic.note -> name ."Patric"); 

atrcpy(bnaic_note -> note ."Please collect class addresses."); 
break; 
caae 8 : 

basic_note -> priority = counter ; 
atrcpy(baaic_note -> name ."Jenny"); 
atrcpy(basic_note -> note ."Happy New Year"); 
break; 
caae 9 : 

baaic.note -> priority = counter ; 
atrcpy(basic_note -> name ."Amy"); 
atrcpy(baaic_note -> note ."Kerry Chriatmaa"); 

break; 

> 

head ■ insert(head, besic.note); 

> 

database_root_aet_valu*(root, head, note_pad_type); 

> OS_END.TXN(txl); 
database.close(db); 

/* Stop time commandatat */ 

CommandStats(0, atdout, kelapaed, ftesec); 


B-24 





B.7 Test Program: adacol.mk (for adacol.c) 

include $(OS_ROOTDIR)/etc/oatore.lib.ok 
OS_COHPILATION_SCHEMi_D3_PATH= /$ (USER) /teat/cnote. ccdb 
OS_APPLICATION_SCHEMA_DB_PATH= /$(USER)/test/cnote.asdb 
LDLIBS * -los -lose -loacol 

SOURCES *> adacol.c CommandStats.c ako_adac.ee ct.cnote.c 

OBJECTS ■ adacol.o ComnandStata.o skm_adac.o ct.cntoe.o 

EXECUTABLES ■ adacol ct.cnote 

CPPFLAGS » -I$(OS_ROOTDIR)/include 

CFLAGS » -gx 

CC * cc 

LIB.PATH * -L/uar/local/object8tore/sun4/lib 
all: t(EXECUTABLES) 

adacol: adacol.o CommandStata.o schema.atandin.Adacol 

t(OS.PRELINK) .oa_schema.ee \ 

$(OS_COHPILATION_SCHEMA_ 1 )B_PATH) KOS.APPLICATION.SCHEHA.DB.PATH) \ 
adacol.o $(LDLIBS) 

OSCC -c .os_schema.ee 

$(LINK.c) -o adacol -Bstatic adacol.o CommandStats.o .os.schema.o \ 

$(LDLIBS) 

$(OS.POSTLINK) adacol 

ct.cnote: ct.cnote.o schema.standin.Adacol 
$(OS_PRELINK) .oa_schema.cc \ 

$(OS.COMPILATION_SCHEMA_DB.PATH) $(OS_APPLICATION_SCHEMA_DB_PATH) \ 
ct.cnote.o l(LDLIBS) 

OSCC -c .os_schema.cc 

t(LINK.c) -o ct.cnote ct.cnote.o .os.schema.o $(LDLIBS) 

$(OS.POSTLIHK) ct.cnote 

ct.cnote.o: ct.cnote.c 

$(CC) $(CPPFLAGS) $(CFLAGS) -c ct.cnote.c 

adacol.o: adacol.c 

t(CC) $(CPPFLAGS) $(CFLAGS) -c adacol.c 

CommandStats.o: CommandStats.c 

t(CC) f(CPPFLAGS) $(CFLAGS) -c CommandStats.c 

achema.standin.Adacol: skm_adac.cc 

OSCC f(CPPFLAGS) -batch.schema KOS.COMPILATION.SCHEMA.DB.PATH) \ 
skm_adac.cc 

touch schema_standin_Adacol 
clean: 

osxa -f $ (0S.C0MPILATI0H_SCh7MA_DB.PATH) 
osra -t % (OS.APPLICATTON.SCHLMA.DB.PATH) 
xa -f $(EXECUTABLES) I(OBJECTS) schema_standin_Adacol 


B-25 






depend: .depend.C 


.depend.C: 

oan&kedep .depend.C l(CPPFLAGS) -files $ (SOURCES) 


include .depend.C 





B.8 Test Program: adacol.c 

/* file : adacol.c program - maim file 

ObjectStore C library - collection functions 
implemented by Li Chou, in Jan 1993. 

*/ 


•include 

•include 

•include 

•include 

•include 

•include 


<stdio.h> 
<ostore/ostore.h> 
<ostore/coll.h> 
<stringe.h> 
<sys/time.l' , > 
<sys/resource.h> 


•include "adacol.h" 


extern FILE *basic_file; 
void initial.colO; 
void database_open_close(); 
void data_retrieve(); 
void data_scan(); 
void data.scan.nioO; 
void display_note(); 

void exitO; 

/* global timing variables for CommandStats — Jacobs 18/09/91 */ 
static struct timeval elapsed; 
static struct runage exec; 
database *db; 
database_root *root; 
os.typespec *note_type, *os_coll_type; 

main() 

< 

char choose; 

start.objectstoreO; 
os_collection_initialixeO; 

/* allocat os.typespec */ 
note.type ■ alloc.typespec("note.col ,, ,0}; 
os.coll.type ■ alloc_typespec("os_collection",0); 

/*— main loop — 
drive manual 

— choose input by user */ 
while (1) { 

printf("** Testing Mean **\n"); 

printf(" 0. Initial database : cnote.dbW); 

printf(" 1. Testing the opening(closlmg) database\n"); 


B-27 





/ 



printfC 2. Testing tha lookup and retrieve\n"); 
printfC 3. Testing the sequential scaning\n"); 

printfC 4. Testing the sequential scaning (without output to screen)\n’’); 
printfC 6. Bye !!\n"); 
printfC Input 

while (scanfCXc" , kchoose) ««=1) { 
if (choose <= *5’ kk choose >® *0') 
break; 

> 

if (choose ■» *5’) exit(i); 

switch (choose) { 
case 'O' : 

initial.colO; 
break; 
case '1* : 

database_open_close(); 
break; 
case *2» : 

data.retrieveO; 
break; 
case *3* : 
data.scanO; 
break; 
case *4’ 

data_scan„nio(); 

break; 

> 

> 


void database_open_close() 

{ 

os.collection *bead; 
int count; 

count K 1; 

/* Start tine conmandstat */ 

Conmandstats(l, stdout, kelapsed, Jtexec); 

/* repeat opening and closing a database 10 tines */ 
while (count <» 10) { 

db • databaae_lookup_open("/lchou/tect/cnote.db", 0, 0664); 
0S_BEGIN_TXH(txl,0,transaction_update) { 
root ■ database_root_find("ahead H , db); 

head ■ (os.collection*) database_root_get_value(root, os_coll_type); 
} 0S_END_TXN(txl); 
databaae.close(db); 

♦♦count; 

> 

/* Stop tine conmandstat */ 




B-28 






CommandStats(0, stdout, Relapsad, Razee); 

> 

woiH d»ta.retriev*() 

oa.collaction ahead, *queried.note; 
os.cursor *cur; 
struct note_col *p; 
char *input_atring; 

printf("Retrive a record, the priority ia 6000\n">; 

/* if (acanf("Xd", Rinput.number) *= 1) */ 

db * database.lookup.openC'/lchou/test/cnote.db", 0, 0664); 

OS.BEGIN.TXN(tzl,0,transaction.updat*) { 
root * database.root.findC'ahead", db); 

head * (oa.collaction*) database.root.get.value(root, oa.coll.type); 

/* Start time commandstat */ 

CommandstatsCi, stdout, Relapsed, Razee); 
atrcpy(input_atring,"priority «* 6000"); 

queried_note * oa_collection_query(head, "note.eol*", input.atring, 
db.O ,0); 

cur » oa.curaor.create(queried_note, 0); 
for (p * (struct note.eol*) os.cursor.first(cur); os_cursor_more(cur); 
p * (struct note.eol*) os.cursor_nezt(cur)) 
display.not*(p) ; 

os.cursor.delete(cur); 

/* Stop time commandstat */ 

CommandStats(0, stdout. Relapsed, Razee); 

> OS.EHD.TXN(tzl); 
database.close(db); 

> .:___ 1 _____;____ 


▼oid data_scan() 

os.collection ahead; 
os.cursor *cur; 
struct note.eol *p; 

db * databas*_lookup_opnn("/lchou/t*st/cnot*.db", 0, 0664); 

0S.BEGIH.TXN(tzl,0,transaction_updat*) { 

root * database.root.findC'ahead", db); 

head » (os.collection*) database.root.get.value(root, os.coll.type); 

/* Start time commandstat */ 

Commandstats(1, stdout, Relapsed, Rezec); 
cur - os.cursor.create(head, 0); 

for (p » (struct note.eol*) os.cursor.first(cur); os.cursorjaore(cur); 
p » (struct note.eol*) os.cursor.next(cur)) 
display.not*(p) ; 


ii- 29 












os.cursor.delete(cur); 

/* Stop time commandstat */ 

Commandstat a(0, stdout, kelapsed, Jtexec); 

> OS.END.TXN(txl); 
database.clone(db); 

> 

void data.scan.nioO 

os.collection ahead; 
os.cursor *cur; 
struct note.col *p; 

db * database_lookup_open("/lchou/test/cnote.db", 0, 0664); 
OS_BEGIN_TXN(txl,0,transaction.update) { 

root « database_root_find("ahead", db); 

head » (os.collection*) databaae_root_get_value(root, os.coll.type); 

/* Start time commandstat */ 

CommandStated, stdout, Jtelapsed, Jtexec); 
cur ■ os_cursor_create(head, 0); 

for (p M (struct note.col*) os_curaor_first(cur); os.cursor.more(cur); 
p ■ (struct note.col*) os.cursor.next(cur)); 

os.cursor.delete(cur); 

/* Stop time commandstat */ 

Commandstat s(0, stdout, Jtelapsed, Jtexec); 

> OS.END.TXN(txl); 
database.close(db); 

} 

/* Print out to the specified stream this note */ 
void display.note(n) 
struct note.col *n; 

{ 

printf("priority (Xd) name Xs \n", n->priority, n->name); 
printfC'note Xs\n", n -> note); 

> 

void initial.colO { 

struct note.col *head, *basic_note; 
int counter; 

db ■ database_lookup_open("/lchou/test/cnote.db", 0, 0664); 

/* Start time commandstat */ 

CommandStatsd, stdout, Jtelapsed, Jtexec); 

0S.BEGIN.TXH(tx1,0,trans acticn_updat e) { 
root ■ database_root_find("ahead", db); 
if Oroot) { 

root « database.create_root(db, "ahead"); 
head ■ os_collection_create(db. 


B-30 







•-W ¥»-,* vjjft. 


os.collection.maintaln.cursor# I 
os.collection.maintain.order, 10,0,0); 
database_root_set_valu#(root, head, os.coll.type); 

> 

•Is* 

{ 

printfCThe database exist II osrm it first !!!\n"); 
exitO; 


head “ datab»se.root_get_value(root, os.coll.type); 
for (counter « lj counter <■ 10000; ♦♦counter){ 

basic.note * (struct note.col*) object.store_allcc(note_type, 1, db); 
switch (counter - ((int)(counter/10)) * 10) { 

case 0 : 

basic.note -> priority ■ counter ; 
strcpy(basic.note -> name ."Danile"); 

strcpy(basic_note -> note ,"you need meet your friend tomorrow"); 

break; 

case 1 ; 

basic.note -> priority “ counter ; 
strcpy(basio_note -> name ,"Susan"); 

strcpy(baaic_note -> not# ,"you need meet Course commite# at 9:00"); 

break; 

case 2: 

basic.note -> priority * counter ; 
strcpy(basic_not# -> name ,"Li">; 

strcpy(baaic_note -> not# ."Enjoy the silent night in Lab"); 
break; 

case 3 : 

basic.note -> priority « counter ; 
strcpy(basic.note -> name ."Chars"); 

strcpy(basic_note «■> note ."You may meet me at 11:00");- 

break; 

case 4 : 

basic_note -> priority ■ counter ; 

*trcpy(basic.note -> name ."Mike"); 

strcpy(baaic_note -> note ,"We have an appointment vith principle"); 
break; 
case 5 : 

basie.note -> priority ■ counter ; 
atrcpy(basic_note -> name ,"Coan"); 
strcpy(basic.note -> note ,"We found t book you lost"); 
break; 
case 6 : 

basie.note -> priority ■ counter ; 
strcpy(basic_note -> name ,"Haney"); 


B-31 






( \ 








«5£|PWWT?|R^PPSPW^ 


strcpy(basic_not* -> not* ."Study Chapter 10 of OS"); 
br*ak; 
cas* 7 : 

basic.not* -> priority * counter j 
strcpy(basic.not* -> nam* ."Patric"); 

•trcpy(basic_not* -> not* ,"Pitas* collect class addr*ss*s. H ); 
br*ak; 
cac* 8 : 

basic.not* -> priority * counter ; j 

strcpy<basic_not* -> nan* ,"J*nny M ); ■ 

strcpy(basic.not* -> not* ,"Happy N*v Y*ar"); 

br*ak; : 

cass 9 : 

basic.not* -> priority * counter ; j 

strcpy(basic_not* -> nam* ,"Amy"); 

strcpy(basic.not* -> not* ."Harry Christmas"); 

br*ak; 

} 

os_coll*ction_ins*rt(h*ad, basic.not*); 

> 

} OS.EHD.TXN(txi); . j 

databa*«_clos*(db); 

/* Stop tim* comirandstat •/ 

CommandStats(0, stdout, t*laps«d, ft«x*c); 

> 

! 


B-32 







B.9 Test Program: purobj.a 


— a pur* Ada program which without accaasing DBMS 
with TEXT.IO; uac TEXT.IO; 
with STATIS.ADA; 

procadura PTOOBJ ia 

pragma LINK.WITB("-Batatic atatia.o CoaaandStata.o"); 
aubtypa NOTE.STRING ia STRIK<Kl. .20); 
typa LIMK.rOTE; 

typa LINK.NOTE.PTR ia accaaa LINK.NOTE; 
typa LINK.NOTE io 
r a cord 

priority: INTEGER; 
nama : NOTE.STRING; 

aota : atringCl..80); 

mart : link.nota.ptr; 
and racord; 

packaga INI.10 la naw intager.io(INTEGER); 
us* INT.IO; 

aubtypa CEOICE.TTPE ia intagar rang* 0 .. 6; 
packaga CHOICE.IO la naw int*g*r.io(CHOICE_TTPE); 

HEAD : LIMK.HOTE_.PTB; 

N.IN : INTEGER; 

MYCHOICE : CHOICE.TYPE; 


procadura STRCPY(NAME : out atring; 

NOTE.NAHE : in atring) ia 
LEN : natural :« NOTE.NAME’LENGTH; 
bagin 

NAKECi.. LEN) :■ NOTE.NAMEU. .LEN); 
and STRCPY; 


function DATABASE.RETRIEVE(NUMBER : intagar; 

HEAD : LINK.NOTE.PTR) raturn LINK.NOTE.PTR ia 

TEMP : LINK.NOTE.PTR; 
bagin 

TEMP :• HEAD; 

whil* (NUMBER /• TFMP.PRIORITY) and than (TEMP /- NULL) 
loop 

TEMP :• TEMP.NEXT; 
and loop; 
raturn TEMP; 
and DATABASE.RETRIEVE; 







function INSERT(HEAD : LINK.NOTE.PTR; 

N : LINK.NOTE.PTR) return LINK.NOTE.PTR in 

begin 

H irrT'*’ • — ft? * n . 

> i1C*A A • *UM4W| 

return N; 
end INSERT; 

procedure DISPLAY_NOTE(N : LINK.NOTE.PTR) ie 

begin 

put(R.PRIORITY); 

put_line(" " It N.NAME); 
put.line(N.NOTE); 
new.line; 
end DISPLAY.NOTE; 


procedure TRAVERSECHEAD r LINK.NOTE.PTR; 

10 : integer) ie 

TEMP : LINK.NOTE.PTR; 
begin 

TEHP HEAD; 
while "TMP /• null loop 
if /»0 then 

JISPUY.NOTECTEMP); 
end if; 

TEMP TEMP.NEXT; 
end loop; 
end TRAVERSE; 


procedure DATA. "CAN.IOCHEAD : LINK.NOTE.PTR) ie 
begin 

— etnrt time 

STATIS.ADA.COMMANDSTATS(i); 

TRAVERSECHEAD,1); 

— etop time 

STATIS.ADA.COMMANDSTATS(0); 
end DATA.SCAN.IO; 


procedure DATA.SCAN(HEAD : LINK.NOTE.PTR) ie 


begin 

— start time 


STATIS.ADA.COMMANDSTATS(1); 
TRAVERSECHEAD,0); 


— etop time 

STATIS.ADA.COMMANDSTATS(0); 
end DATA.SCAN; 


B-34 








«<n 




PROCEDURE DATA_RETRIEVE(TEMP : LINK.NOTE.PTR) is 
INPUT.NUKBER : integer; 

BASIC.NOTE : LINK.NOTE.PTR; 
begin 

put.line("Retrive a record, the priority is 5000"); 
INPUT.NUMBER :■ 5000; 

— start tine 

STATIS.ADA.COKKANDSTATS(1); 

BASIC.NOTE :« DATABASE_RETRIEVE(INPUT_NUMBER, TEMP); 
DISPLAY.NOTE(BAStC.NOTE); 

— stop time 

STATIS.ADA.COMMANDSTATS(0); 
end dats.retrieve; 


function INITIAL.DB return LINX.NOTE.PTR is 
HEAD, 

BASIC.NOTE : LINK.NOTE.PTR; 

COUNTER : integer :* 1; 
begin 

— start time 

STATIS.ADA.COMMANDSTATS(1); 

for COUNTER in 1 .. 10000 loop 
BASIC.NOTE new LINK.NOTE; 
case (COUNTER mod 10) is 
when 0 •> 

BASIC.NOTE.PRIORITY :* counter ; 

STRCPY(BASIC.NOTE.NAME ,"Penile"); 

STRCPY(BASIC_NQTE.NOTE ,"you need meet your friend tomorrow"); 

when 1 ■> .—. '...-. 

BASIC.NOTE.PRIORITY :« counter ; 

STRCPY(BASIC.NOTE.NAME ."Susan"); 

STRCPY(BASIC.NOTE.NOTE ."you need meet Course commitee at 9:00"); 
when 2 *> 

BASIC.NOTE.PRIORITY counter ; 

STRCPY(BASIC.NOTE.NAME ,"Li"); 

STRCPY(BASIC.NOTE.NOTE ."Enjoy the silent night in Lab"); 
when 3 *> 

BASIC.NOTE.PRIORITY :■ counter ; 

STRCPY(BASIC.NOTE.NAME ."Chars"); 

STRCPY(BASIC.NOTE.NOTE ."You may meet me at 11:00"); 

when 4 ■> 

BASIC.NOTE.PRIORITY counter ; 


B-35 





STRCPY(BASIC_NOTE.NAME ."Mike"); 

STRCPY(BASIC.NOTE.NOTE ,"We have an appointment with principle"); 
when 5 *■> 

BASIC.NOTE.PRIORITY counter ; 

STRCPY(BASIC_NOTE.NAME ,"Coan"); 

STRCPY(BASIC.NOTE.NOTE ,"We found a book you loet"); 

when 6 »> 

BASIC.NOTE.PRIORITY counter ; 

STRCPY(BASIC.NOTE.NAME ."Nancy"); 

STRCPY(BASIC.NOTE.NOTE ,"Study Chapter 10 of OS"); 

when 7 *> 

BASIC.NOTE.PRIORITY :■ counter ; 

STRCPY(BASIC.NOTE.NAME ."Patric"); 

STRCPY(BASIC.NOTE.NOTE ."Please collect class addresses."); 
when 8 *> 

BASIC.NOTE.PRIORITY :■ counter ; 

STRCPY(BASIC.NOTE.NAME ."Jenny"); 

STRCPY(BASIC.NOTE.NOTE ."Happy New Year"); 

when 9 »> 

BASIC.NOTE.PRIORITY :« counter ; 

STRCPY(BASIC.NOTE.NAME ."Amy"); 

STRCPY(BASIC.NOTE.NOTE ."Merry Christmas"); 

when others => null; 
end case; 

HEAD :« INSERT(HEAD, BASIC.NOTE); 
end loop; 

— stop time 

STATIS.ADA.COMMANDSTATS(0); 
return HEAD; 
end INITIAL.DB; 


begin — NOTE 
loop 
loop 
begin 

pat.lineC'e* TESTING MENU **"); 
put_line(" 0. INITIAL DATABASE; TRANSIENT ONLY"); 
put_line(" 1. TESTING TEE LOOKUP AND RETRIEVE"); 
put_line(" 2. TESTING THE SEQUENTIAL SCANING W I/O "); 
put.line(" 3. TESTING THE SEQUENTIAL SCANING WITHOUT I/O"); 
put_line(" 4. BYE !!"); 

PUT("INPUT -> "); 
choice.io.get(MYCHOICE); 
text.io.skip.line; 











I 

I 

I 



exception 

vhen data.error | censtraint.error ■> 
text.io.skip.line; 

text.io.put.line("Your choice must be between 0 an ' 5") 
text.io.new.line; 

end; 

end loop; 

— do different tasks from here 

case MYCHOICE is 
vhen 0 c > 

HEAD :» INITIAL.DB; 
vhen 1 *> 

DATA.RETRII’VEOIJLD); 
vhen 2 ■> 

DATA.SCAN.IO(HEAD); 
vhen 3 *> 

DATA.SCAN(EEAD); 
vhen 4 ■> 
exit; 

vhen others •> null; 
end case; 
end loop; 
end PUROBJ; 


B-37 










B.IO Test Program: pvrobj.c 


/* C purobj.c program - main file 
1 pore C program but perform the same functionality of 
adaobj.c except no persistent objects 

*/ 

•include <stdio.h> 

•include <strings.h> 

•include <sys/time.h> 

•include <sya/resource.h> 

•include "purobj.h" 


extern FILE *basic_file; 

HOTE initial.dbO; 
void data_retrieve(); 
void data_scan_io(); 
void data_scan(); 

HOTE database.retrieveO; 
void display_note(); 
void traverse<); 
void exitO; 
int is.emptyO; 

I 

/* global timing variables for CommandStats — Jacobs 18/09/91 */ 
static struct timeval elapsed; 
static struct rusage exec ; 1 
main() 

char choose; 
static NOTE head; 

head • HULL; 

/*— main loop — 
drive manual 

— choose input by user */ 
while (1) { 

printfC’** Testing Menu **\n"); 
printfC" 0. Initial database : transient only\n"); 
printfC' 1. Testing the lookup and retri&ve\n"); 
printfC 2. Testing the sequential scaning i/o\n"); 
printfC 3. Testing the sequential scaning without i/o\n"); 
printfC 4. Bye !!\n"); 
printf("Input -> "); 
while (scanfCXc" , Jtchoose) »«1) { 
if (choose <= ’4* kk choose >■ ’O’) 
break; 

> 

if (choose “ *4’) exit(l); 


■c' 


B-38 



•witch (choose) { 
cas« *0* : 

head * initial.dbO; 
break; 
case *1’ : 

data_retrieve(head); 
break; 
case *2* : 

data.sean.io(head); 
break; 
case *3* : 

data.scan(head); 
break; 


> 

} 

} 

int is_empty(teiBp) 

VOTE temp; 

{ 

int empty; 
if (temp mm HULL) 
empty ■ 1; 

else 

empty » 0; 

return empty; 

> 

▼old data_rBtrieve(temp) 

HOTE temp; 

{ 

int input .number; 

HOTE basic_note; 

printf("Retrive a record, the priority is 5000\n”); 

/* if (scanf("Yd", kiuput.number) *■ 1) */ 
if (is_empty(temp)) 

printf("\nXs\n","... LINK LIST IS EMPTY ..."); 

'lse { 

input.number » 5000; 

/* Start time commandstat */ 

CommandStatsd, stdout, fcelapsed, fcexec); 
basic.note ■ database_retrieve(input_number, temp); 
display jiote(basic_nots); 

/* Stop time commandstat */ 

CommandStats(0, stdout, telapsed, kexec); 

> 






void data_scan_io(temp) 

NOTE tamp; 

{ 

if (is.emptyCtemp)) 

printf("\nXs\n","... LINK LIST IS EMPTY 

alsa 

< 

/* Start Sima commandstat */ 
ComaandStatsd, stdout, ielapsad, fcexec); 
traversaCtamp,1); 

/* Stop tima commandstat */ 
CommandSt&ts(0, stdout, telapsod, ftexec); 

} 

} 

void data.scan(tamp) 

NOTE tamp; 

{ 

if (ia_ampty(tamp)) 

printf("\nXs\a’V\.. LINK LIST IS EMPTY 

alaa 

/* Stait tima commandstat */ 
ComaandStatsd, stdout, bclapaed, ftaxec); 
traveiae(tamp.O); 

/a Stop time commandstat */ 
ComnandStats(0, stdout, ftalapsad, fcexec); 

} 


/•* ratriava a note */ 

NOTE databaae_retrieve(numb, anota) 
int numb; 

NOTE anota; 

i 

NOTE tamp; 
tamp ■ anota; 

vMla ((numb !■ tamp -> priority ) U (tamp !■ NULL)) 
tamp ■ tamp-> next; 

return tamp; 

> 


B-40 



\ 


/* Print oat to the specified stream this note */ 
void display.note(n) 

NOTE n; 

printf("priority (Xd) name X? \n". n->priority, n->name)j 
printf("note Xs\n", n -> note); 

y 

/* Insert a node */ 

NOTE insert(p, q) 

NOTE p; 

NOTE q; 

q -> next* p; 
return q; 

} 


/* Sequencial scaning */ 
void traverse(anote,io) 

NOTE nnote; 
int io; 

NOTE temp; 

temp ■ anote; 
while (temp !* NULL) < 
if (io > 0) { 

display_note(temp); 

> 

temp ■ temp -> next; 

> 

> 

NOTE init!ial_db() 

{ j 

/* global timing variables for CommandStats — Jacobs 18/09/91 */ 
NOTE head. basic_note; 
int | counter; 

head ■ NULL; 

/* Start time comnandstat */ 

CsaaandStatad, stdout, ielapsed, ftexec); 
for (ebunter * 1; countor <* 10000; ++counter){ 
baeic.note * (NOTE) malloc(sizeof(struct link.note)); 
svitch (counter - ((int)(counter/10)) * 10) < 
case 0 : 

basic_note -> priority ■ counter ; 


B-41 






strep/; not a -> name , "Demile'); 

strcpyCbusic.note -> note ."you need meet your friend tomorrow"); 
break; 
case 1 ; 

basic_note -> priority * counter ; 
strcpy(baaic_note -> name ."Susan"); 

strcpy(basic_note -> note ."you need meet Course commitee at 9:00"); 

break; 

case 2: 

basiejaote -> priority * counter ; 
strcpy(basic_note -> name ,"Li"); 

strcpy(basic_note -> note ."Enjoy the silent night in Lab">; 
break; 


case 3 : 

basic_note -> priority « counter ; 

strcpy(basic_note -> name ."Chars"); 

strepy(basic.note -> note ."You may meet me at 11:00"); 

break; 
case 4 : 

basic.note -> priority « counter ; 
strepy(baaio.note -> name ."Hike"); 

etrepy(basic.note -> note ,"We have an appointment with principle"); 

break; 
case 6 : 

basic.note -> priority * counter ; 
strepy(basic.note -> name ,"Coan"); 

strcpy(basic_note -> note ,"l'e found a book you lost"); 
break; 

case 6 : 


basic.note -> priority * counter ; 
strepy(basic.note -> name ,"Haney"); 
strcpy(basic_note -> note ."Study Chapter 10 of OS"); 
break; 
case 7 : 

basic.note -> priority * counter ; 

strepy (basic..note -> name ."Patric"); i 

strepy(basic.note -> note ."Please collect class addresses."); 
break; 1 

case 8 : 1 

basic.note -> priority ■ counter ; 1 

strcpy(basic_note -> name ."Jenny"); 1 

strepy(basic.note -> note ."Happy Hew Year"); \ 

break; 
case 9 : 

basic.note -> priority « counter ; 
strcpyCoasic.note -> name ."Amy"); 
strcpy(baaic_note -> note ."Merry Christmas"); 

break; 

> 










«n*l' 1 '»-<*» ill L iijiii.iijJiiiiJi.iu.ii^l.Llfp iiii.uii m ii ;! |j|i.piiiii. .k.| II 


*; -sfey v M&e fe‘?-v 






B.ll Tr»t Program: hello.out.mk (for hello.ost.a) 

lneluda |(0S_R00TDIR)/atc/o8tore,lib.ink 

OS.COMPIUTION.SCflEKA.DB.PiTH - /lchou/hallo.cedb 
OS.APPLICATION_SCHEMA_DB.PATH - /lchou/hallo.aadb 
SCHEMA.SOURCE - hallo_oa.ee 
LDLIB5 ■ -loa -lose 
CPPFUGS - -gx -I.. 

ElCUTABLE ■ hallo.oat 

OBJECTS * .oa.schama.o hallo.oat.o 

hallo.ost: .os.achema.o 

a.maka -L .. ha io.oat -f hallo.oat.a 

bv a. out hello.oat 

K03.R0OTDIR)/lib/patch hello.oat 


lneluda ../ada.nk 


B-44 




B.lt Test Program: kello.ost.a 

with OS.TYPES; use OS.TYPES; 
with OSTORE; use OSTORE; 
with PERS.SCALARS; 
with STATIS.ADA; 
with TEXT.10; use TEXT.IO; 

procedure hello.ost is 

pragma LINK.WITHO’-Bstatie .os.sehema.o . ./libosada.a statia.o CommandStats.o 
-L/usr/local/objectstore/sua4/lib -loa -lose"); 
package INT.IO is new integer.io(INTEGER); 
use INT.IO; 

— add check the performance 

package time.io ia new fixed.io(duration); 
use Time.io; 

A.Number : Integer; 

Count : Integer; 

The.Choice : Character; 

ROOT: DATABASE.ROOT; 

IP: PERS.SCALARS.INTEGER.PTR; 

DB: DATABASE; 

TX: TRANSACTION; 
begin 

put(" The numbers loop to perform -> "); 
get(A_number); 

-- start time 

STATIS.ADA.COMMANDSTATS(1); 

INIT.ADA.INTERFACE; 

DB DATABASE.OPEN("/lchou/ada.db", FALSE, 8#664#); 

for Count in 1 .. A.number loop 

TX TRANSACTION.BEGIN; 

ROOT :» DATABASE.ROOT.FIND("counter", DB); 
if invalid(ROOT) then 

ROOT :■ DATABASE.CREATE.RO0T(DB, "counter"); 

IP :■ PERS.SCALARS.PERS.INTEGER.PERSISTENT.NEW(DB); 

PERS.SCALARS. PERS.INTEGER. DATABASE.ROOT.SET.VALOE (ROOT, IP); 
end if; 

IP :■ PERS.SCALARS.PERS.INTEGER.DATABASE.ROOT.GET.VALOE(ROOT); 

IP.all :■ IP.all ♦ 1; 

put_line("Eello World!"); 

put("Program run now is "); 

put(IP.all); 

put.line(" times."); 

put("Program run from this exaction is"); 

put(Count); 

put.line(" times."); 

TRANSACTION.COMMIKTX); 
and loop; 






wrrn^m sgpBfPWWg^g 1 W ffl IM y j CTPy'" ggww^y ? 

—ij&a!&ir'ns ■?-*• - ..'^ifcAi-^--.^ ■--i-v*'— -;■&•&•■*,-£■: w’ 


» Wff f 4 jl-lllllff^ 




— stop time 

STATIS.ADA.CQMMANDSTATS(0); 

put("*»* For performing "); 
put(A_niuuber,l); 
put_line(" times ***"); 
nev.line; 











B.1S Test Program: hello.ost.mk (for hello.ost.c) 

include ${QS_ROOTDIR)/etc/oBtore.lib.mk 
OS.COHPILATION.SCHEHA.DB.PATH* /|(USER)/helloc. coap.schema 
OS_APPLICATION_SCHEMA_DB_PATH a /$(USER)/helloc. app.scheaa 
LOLIBS ” -los -lose 

SOURCES * hello2at.c ComaandStats.c Bcheaa.cc 

OBJECTS ■ hello2at.o hello2atb.o CommandStatB.o schema.o 

EXECUTABLES * hello2at hello2atb 

CPPFLAGS - -I$(0S_R00TDIR)/include 

CFLAGS - -g 

CC « cc 

LIB.PATH * -L/uar/loeal/objectstore/sun4/ltb 

all: $(EXECUTABLES) 

*•# using static binding *## 

hello2at: hello2at.o ComaandStats.o scheaa_standin_B 
t(OS.PRELINX) .os_scheaa.ee \ 

$(OS_COMPILATIOH_SCHEMA_DB_PATH) $(OS_APPI'TATION.SCHEMl.DB.PATH) \ 
hello2at.o ((LDL1BS) 

OSCC -e .os_seheaa.ee 

l(LlNK.c) -o hello2at -Bstatic hello2at.o CommandStats.o .os.scheaa.o \ 
l(LDLIBS) 

KOS.POSTLIKK) hello2at 

hello2at.o: hello2at.c 

#(CC) |(CPPFLAGS) l(CFLAGS) -c hello2at.c 

CommandStats.o: ComaandStats.c 

cc $(CPPFLAGS) $(CFLAGS) -c CoaaandStats.c 

schema.standin.B: scheaa.cc 

OSCC t(CPPFLAGS) -batch.schema $(OS_COMPILATIOH_SCHEHA_DB_PATH) scheaa.cc 
touch schema_standin_B _ 

clean: 

osra -f $(OS_COMPILATIOH_SCHEMA_DB_PATH) 

rm -f $(EXECUTABLES) I(OBJECTS) schema.standin_B 

depend: .depend_B 

.depend.B: 

osaakedep .depend.B I(CPPFLAGS) -files t(SOURCES) 
include .depend_B 


B-47 








B.14 Test Program: hello.ost.c 

♦include <stdio.h> 

♦include <ostore/ostore.h> 

♦include <sys/time,h> 

♦include <sys/resource.h> 

/• global tiaing variables for CommandStats — Jacobs 18/09/91 */ 
static struct timeval elapsed; 
static struct rusage exec; 

main( ) 

database *dbl; 

database.root *count.root; 

int *countp, counter, i; 

extern double get_clock( ); 

double start.time, calculation_time; 

start.objectstoreO; 

printf(" lie numbers loop to perform -> "); 
if (scanfC'Xd", ^counter) «“ 1) { 

/* Start time commandstat */ 

CommandStats (1, stdout, Jtelapeed, Rexec); 
dbi * database_lookup_open<"/lchou/dbl", 0, 0664); 
for (i ■ 1; i <= counter; •*•+!) { 

OS.BEGIH.TXH(txl,0.transactien.update) { 
count_root * database.root.findCcount", dbl); 
countp “ (int *)database_root_get_value(count_root, 0); 

printf("Hello, world.\n"); 

printf("Program run Xd times\n", ++*countp); 

printf("Run from this execution Xd timea\n", i); 

> OS.END.TXN(txl); 

> 

/* Stop time commandstat */ 

CommandStats(0, stdout, Relapsed, Rexec); 
printf(" for performing Xd times \n", counter); 

> 

> 


B-48 







Appendix C. Interface Programs 










C.l Interface Program: Makefile 

include $(OS.RCOTDIR)/etc/ostore.lib.mi 

SOURCES ■ glue.cc glue_pti.cc 
OBJECTS ■ glue.o glue.pti.o 

# set CC to jour C++ compiler command 

# unset TFLAGS (+0STD is an OSCC flag to allow only standard C++) 
TFLAGS* 

CC*0SCC 
CPPFUGS = -gx 
CFLAGS ■ -g 

CDEPEND * -IKOS.ROOTDIR)/include 
all: libosada.a ada.objects 
clean: 

osrm -f ${OS_COHPILATION_SCHEMA_DB_PATH} 
rm -f ${EXECUTABLES> KOBJECTS} echeaa.standin 

glue.o: glue.cc 

${CC} KCPPFLAGS) $(TFLAGS) -c glue.cc 

glue.pti.o: glue_pti.cc 

$(CC) KCPPFLAGS) KTFLAGS) -c glue_pti.cc 

libosada.a: glue.o glue.pti.o 
ar rc libosada.a glue.o glue.pti.o 
ranlib libosada.a 

ada_objects: 

a.make OS.TYPES -f os.types.a os.typ.b.a 

a. make OS.EICEPTIONS -f except.a except.b.a 

a. make OSTORE -f ostore.a ostore.b.a 

a. make OSTOAE.GENERICS -f ostore.g.a ostorg.b.a 

a.make OS_CnLLECTION_PKG -f os.coll.a os.coll.b.a 

a.make OS.CURSOR.PKG -f os.cur.a os.cur.b.a 

a. make PERS.SCALARS -f pscalr.a 

.depend: 

osmakedep .depend $(CDEPEND) -files KSOURCES) 
include .depend 


C-2 






C.2 Interface Program: oa.types.a 


--Definitions for objectstore’s portable types 

with UNSIGNED.TYPES; 
package OS.TYPES is 

subtype 0S.UNSIGNED.INT8 is UNSIGNED.TYPES.UNSIGNED.TINY.INTEGER; 
subtype 0S.SIGNED.INT8 is TINY.INTEGER; 

subtype 0S.UNSIGNED.INT16 is UNSIGNED.TYPES.UNSIGNED.SHORT.INTEGER; 
subtype 0S.INT16 is SHORT.INTEGER; 

subtype 0S.UNSIGNED.INT32 is UNSIGNED.TYPES.UNSIGNED.INTEGER; 
subtype 0S.INT32 is INTEGER; 
subtype 0S.B00LEAN is INTEGER; 

subtype OS.UNIXTIME.T is UNSIGNED.TYPES.UNSIGNED.INTEGER; 
subtype OS.COMPARE.RESULT is INTEGER; 
subtype OS.BITF is UNSIGNED.TYPES.UNSIGNED.INTEGER; 
type OSTORE.OPiqUE is private; 

type OS.STRING is new STRINGCi..150); 

type 0S.C0LLECTI0N.BEHAVI0R is (MAINTAIN.CURSORS, ALLOW.DUPLICATES, 
SIGNAL.DUPLICATES, ALLOW.NULLS, MAINTAIN.ORDER); 
for OS.COLLECriON.BESAVIOR’SIZE use 32; 
function valid(OBJ: OSTORE.OPAQUE) return BOOLEAN; 
function invalid(OBJ: OSTORE.OPAQUE) return BOOLEAN; 

private 

type OSTORE.OPAQUE is new INTEGER; 


end OS.TYPES; 


C-3 






C.S Interface Program: os.typ.b.a 


— Implementation for oa types 
package body OS.TYPES is 

function valid(0BJ: OSTORE.OPAQUE) return BOOLEAN is 
begin 

return OBJ /■ 0; 
end valid; 

pragma INLINE(valid); 

function invalid(OBJ: OSTORE.OPAQUE) return BOOLEAN is 
begin 

return OBJ * 0; 

end invalid; 

pragma INLINE(invalid); 

end OS.TYPES; 


C-4 






C-4 Interface Program: os tore, a 


— Basis interface to ObjectStors from ths Ada programming language 

— Prototype design and implementation by Dave Rocenberg cf Object 

— Design, Inc. 

—Functions are extended and binding is changed to C library interface 
—by Li Chou. Nov, 1992. 


with SYSTEM; use SYSTEM; 
with OS.TYPES; use OS.TYPES; 
p'.wxage OSTORE is 

— Public Types 

type STRPTR is access STRING; 
type DATABASE is new CSTORE.OPAQUE; 
type DATABASE.ROOT is new OSTORE.OPAQUE; 

—collections 

type CS.COLLECTION is new OSTORE.OPAQUE; 
type OS_COLL_REP_DSCPR is new OSTORE.OPAQUE; 
type OS.CURSOR is new OSTORE.OPAQUE; 
type SEGMENT is new OSTORE.OPAQUE; 
type OS.TYPESPEC is new OSTORE.OPAQUE; 

— transactions 

type TRANSACTION is new OSTORE.OPAQUE; 
type CONFIGURATION is new OSTORE.OPAQUE; 
type TRANSACTION.TYPE is (NONE, UPDATE, PEAD.OHLY); 
for TRANSACTION.TYPE 1 SIZE use 32; 

for TRANSACTION.TYPE use (NONE ■> 0, UPDATE «> 1, PEAD.ONLY «> 2); 

type REFERENCE is private; 

subtype U.MODE is 0S.INT32 range 0 .. 8#777i; 

— Database Operations 

procedure DATABASi'._CLOSE(DB: DATABASE); 

— Raise ERR.DATABASE.EZISTS 

function DATABASE.CREATE(PATE: STRING; MODE: U.MODE 8#664#; 

OVERWRITE: BOOLEAN FALSE) return DATABASE; 

— Raise ERR.DATABASE.NOT.FOUND 

function DATABA5E.L00XUF(PATH: STRING; MODE: UJIODE :■ 0) return DATABASE 

— Raise ERR.DATABASE.NOT.FOUND 

function DATABASE.OPEN(PATH: STRING; READ.ONLY: BOOLEAN :■ FALSE; 

MODE: UJtODE 0) return DATABASE; 

— function DATABASE.GET.TRA9SIENTJ3ATABASE return DATABASE; 

— function DATABASE.OF(LOC: ADDRESS) return DATABASE; 






— Objectstore Operations 

procedure INIT.ADA.INTERFACE; 

procedure START.OBJECTSTORE; 


function OBJECTSTORE.IS.PERSISTENTCLOC: ADDRESS) return BOOLEAN; 
procedure OBJECTSTORE.CHHOD(PATH: STRING; MODE: NATURAL); 
procedure OBJECTSTORE„SET_BUFFER_SIZE(BYTES: POSITIVE); 


— Transaction Operations 

function TRANSACTION.GET.CURRENT ref'xn TRANSACTION; 

procedure TRANSACTION_ABORT(TX: TRANSACTION := TRANSACTION.GET.CURRENT); 

function TRANSACTION.GET.MAX.RETRIES return 0S.INT32; 

procedure TRANSACTION.SET.MAX.RETRIES(COUNT: NATURAL :- 10); 

function TRAKSACTION_TOP_L£VEL(TX: TRANSACTION :» TRANSACTION_GET_CURRENT) 
return BOOLEAN; 

function TRANSACTION_GET_TYPE(TI: TRANSACTION := TRANSACTION_GET_CURRENT) 
return TRANSACTION.TYPE; 

procedure TRANSACTION_COMMIT(TX: TRANSACTION :* TRANSACTION_GET_CURRENT); 
procedure TRANSACTIOH.ABORT.TOP.LEVEL; 

function TRANSACTinN_BEGIN(T.TYPE: TRANSACTION.TTPZ :- UPDATE) 
return TRANSACTION; 

— transaction.get.parent is not provided in C library 

— function TRANSACTION_GET_PARENT(TX: TRANSACTION :- TRANSACTION.GET.CURRENT) 

return TRANSACTION; 

— Utility functions 

function B_TO_OSB(V: BOOLEAN) return OS.BOOLEAN; 


— Database Root Operations 

— Returns null if root not found! 

function DATABASE.ROOT.FIHD(NAME: STRING; DB: DATABASE) 
return DATABASE.ROOT; 

— Raise ERR.ROOT.EZISTS and ERR.DATABASE.NOT.F0UND 








function DATABASE.CH£ATE_R00T(DB: DATABASE; NAME: STRING) 
return DATABASE.ROOT; 

function DAT ABASE.ROOT.GET.NAME (ROOT: DATABASE.ROOT) return STRING 


function ALLOC.TYPESPEC(NAME: STRING) return OS.TYPESPEC ; 


private 

type REFERENCE ia 
record 

SEGID: 0S.INT32; 
OFFSET: 0S.INT32; 
WORDO: 0S.INT32; 
WORD1: 0S.INT32; 
W0RD2: 0S..INT32; 
end record; 


end OSTORE; 


C-7 





C.5 Interface Program: ostore.b.a 


—Body implementation for a prototype ObjeccStore/Ada interface 
—Design and implementation by Dave Rosenberg, Object Design, Inc, 

—performed tinder contract to PRC, Dec-Jan, 1991-92. 

—Functions are extended and binding is changed to C library interface 
—by Li Chou. Nov, 1992. 

with SYSTEM; use SYSTEM; 
with LANGUAGE; use LANGUAGE; 
with (^EXCEPTIONS; 
with C.Strings; 
with A.Strings; 
package body OSTORE is 

—Utility C string conversion 

function c_ada_to_c(S: SYSTEM.ADDRESS; L:INTEGER) return SYSTEM.ADDRESS; 
pragma INTERFACE(C, c_ada_to_c); 

pragma INTERFACE_NAKE(c_ada_to_c, C.SUBP.PREFIX * "e.ada.to.c"); 


—DATABASE.OPEN 

function c_database_open(PATH: ADDRESS; OVERWRITE: 0S.B00LEAN; 

MODE: U.MODE) return DATABASE; 
pragma INTERFACED, c.database.open); 
pragma INTERFACE_NAME(c_database_open, 

C_SUBP_PREFIX k "database.lookup.open"); 

function DATABASE.OPEN(PATH: STRING; READ.ONLY: BOOLEAN :* FALSE; 
MODE: U.MODE :■ 0) return DATABASE is 

begin 

return c_database_open(c_ada_to_c(PATH(PATH , FIRST)’ADDRESS, 

PATH’LENGTH), B.TO.OSB(READ.ONLY), MODE); 

end DATABASE.OPEN; 

pragma INLINE(DATABASE.OPEN); 


—DATABASE.CLOSE 

procedure c_database_close(D8 : DATABASE); 
pragma INTERFACE(C, c.database.close); 
pragma INTERFACE.NAME(c_database_close, 

C.SUBP.PREFIX k "database.close"); 

procedure DATABASE.CLOSE(DB : DATABASE) is 
begin 

c.database.close(DB); 
end DATABASE.CLOSE; 
pragma INLINE(DATABASE.CLOSE); 


—DATABASE.CREATE 

function c_database_create(PATH: ADDRESS; MODE: U.MODE; 
OVERWRITE: 0S.B00LEAH) return DATABASE; 


C-8 







pragma INTERFACECC, c.databaaa.craata); 
pragma INTERFACE_NAME(c_databaaa_eraata, 

C.SUBP.PREFIX A "databaaa.eraata"); 


function D1TABASE_CREAYE(PATH: STRIKO; MODE: U.MODE 8*664»; 
OVERWRITE: BOOLEAN FALSE) raturn DATABASE la 
bagin 

raturn c_databasa_crnata(c_ada_to_c(PATH(PATH’FIBST)'ADDRESS, 

PATH’LENGTH), MODE, B.TO.OSB(OVERWRITE)); 

and DATABASE.CPEATE; 

pragma INLINE(DATABASE.CREATE); 


—DATABASE. LOCKUP 

function c.databag«_lookup(P*''H: ADDRESS; MODE: U.MODE) raturn DATABASE; 
pragma INTERFACE(C, e.databaaa.lookup); 
pragma INTERFACE_NAME(e_dataV .lor' up, 

C.SUBP.PREFIX k "databaaa.lookup"); 

function DATABASE.LGOKUPCPATH: STRING; MODE: U.MODE :• 0) raturn DATABASE is 
bagin 

raturn c.databaaa.lookup(c.ada.to.c(PATH(PATH»FIRST)'ADDRESS,PATH'LENGTH), 

MODE); 

and DATABASE.LOOKUP; 

pragma INLINE(DATABAr-E.LOOKUP); 


—Initialisation 

procadura c.init.ada.intarfaca; 

pragma INTERFACE(C, c.init.ada.intarfaca); 

pragma IMTERFACE.NAMECc.init.ada.intarfaca, 

C.SUBP.PREFIX k "c.init.ada.intarfaca"); 
procadura IMIT.ADA.INTERFACE is 
bagin 

c.init.ada.intarfaca; 

and IMIT.ADA.INTERFACE; 

pragma INLINECINIT.ADA.INTERFACE); 


—Initiallsation 

procadura c.start.objactstora; 

pragma INTERFACE(C, c.start.objactstora); 

pragma IMTERFACE_MAME(c_start_objactstora, 

C.SUBP.PREFIX k "start.objactstora"); 
procadura START.OBJECTSTORE is 
bagin 

c.start.objactstora; 

and START.OBJECTSTORE; 

pragma INLINE(START. OBJECTSTORE); 


-Transaction gat currant 









function c.transaction. «•* _current r*tum TRANSACTION; 
pragma INTERFACED, c.tranaaction.get.eurrent); 
pragma INTERFACE_NAKE(c_tranaaction..get_current, 

C.SUBP.PREFIX ft ”transaetior._get_current’'); 
function TR.ANSACTION_GET_CURR.ENT return TRANSACTION la 
begin 

return c.tranaaction.get.eurrent; 

end TRANSACTION.GET.CURRENT; 

pragma INLINE(TRANSACTION_GET_CURREirr); 


—Transaction begin 

function c_tranaaetlonJbegin(T: TRANSACTION.TYPE) return TRANSACTION; 
pragma INTERFACED, c.tranaaction.begin); 
pragma INTERFACE.NAME(c_transaction_begin, 

C.SUBP.PREFIX k "tranaaction.begin"); 
function TRANSACTION.BEGIN(T.TYPE: TRANSACTION.TYPE :■ UPDATE) 
return TRANSACTION ia 
begin 

return c.tranaaction.begin(T.TYPE); 

end TRAN5ACTI0N.BEGIN; 

pragma INLINE(TRANSACTION.BEGIN); 


--Transaction commit 

procedure c_tranaaction_commit(T: TRANSACTION); 
pragma INTERFACED, c.tranaaction.commit); 
pragma INTERFACE_NAME<c_tranaaction_commit, 

C.SUBP.PREFIX ft "tranaaction_commit M ); 
procadure TPANSACTION.COMMIT(TX: TRANSACTION :■ TRANSACTION.GET.CURRENT) ia 
begin 

c.traneaction.commit(TX); 

end TRAN3ACTI0N.C0HMIT; 

pragma INLINE(TRANSACTION.COMHIT); 


procedure c_tranaaction_abort_top_level; 

pragma INTERFACED, c.tranaaction.abort.top.level); 

pragma INTERFACE_NANE(c.tranaaction.abort_top.leval, 

C.SUBP.PREFIX ft "tranaactlon.abort.top.level"); 
proeedura TRANSACTION.ABORT.TOP.LEVEL la 
begin 

c.traneaction.abort.top.level; 

end TRANSACTION.ABORT.TOP.LEVEL; 

pragma INLINE(TRANSACTION.ABORT.TOP.LEVEL); 


procedure c_tranaactlon.abort(T: TRANSACTION); 
pragma INTERFACED, t_tranaaction_abort); 
pragma IHTERFACE_NAME(c_tranaaction_abort, 

C.SUBP.PREFIX ft "tranaaction.abort"); 

procedure TRANS ACTION. ABORT (TX: TRANSACTION :«* TRANSACTION.GET.CURRENT) ia 

begin 










c.tranaaction.abort(TX); 

end TRANSACTION.ABORT; 

pragma INLINE(TRANSACTION.ABORT); 



function c_transaetion_get_type(T: TRANSACTION) return TRANSACTION.TYPE; 
pragma INTERFACED, c_transaction.get.type); 
pragma INTERFACE_NAME(c_transaction_get_type, 

C.SUBP.PREFIX k "transaction_get_type M ); 
function TRANSACTION_GET_TYPE(TX: TRANSACTION :« TRANSACTION.GET.CURRENT) 
return TRANSACTION.TYPE is 

begin 

return c.transaction.get.type(TX); 
end TRANSACTION.GET.TYPE; 
pragma INLINE(TRANSACTION_GET_TYPE); 


function c.trsnsaction.get.maz.retries return 0S.INT32; 
pragma INTERFACED, c.trcnsaetion.get.max.retries); 
pragma INTERFACE_NAME(c_transaction_get_mar_retries, 

C.SOBP.PREFIX k H transaction_get_max_retries"); 
function TRANSACTION.GET.MAX.RETRIES return 0S.INT32 is 
begin 

return c_transcction_get_max_retries; 
end TRANSACTION.GET.MAX.RETRIES; 
pragma INLINE(TRANSACTIQN_GET_MAX_R£TRIES); 


procedure c.transaction.set.max.retriesD : NATURAL); 
pragma INTERFACED, c.transaction.set.maz.retries); 
pragma INTERFACE_NAME(c_transaction_set_mar_retries, 

C.SOBP.PREFIX k "transaction.setjnax.retries"); 
procedure TRANSACTION.SET.MAX.RETRIES(COUNT: NATURAL iO) is 
begin 

— e_transaetion_set_mar_retries(COUNT); .. 

end TRANSACnON.SET.MAX.RETRIES; 

pragma INLINE(TRANSACTION.SET.MAX.RETRIES); 


function c.transaction.top.leveKT: TRANSACTION) return BOOLEAN; 
pragma INTERFACED, c_transactlon_top_Xevel); 
pragma INTERFACE.NAME(c.trans action.top.level, 

C.SUBP.PREFIX k "transaction.top.level"); 
function TRANSACTION.TOP.LEVEL(TX: TRANSACTION TRANSACTION.GET.CORRENT) 
return BOOLEAN is 

begin 

return c.transaction_top_level(TX); 
end TRANSACTION.TOP.LEVEL; 
pragma INLINE(TRANSACTION.TOP.LEVEL); 


'Utility functions 


C-ll 













function B_T0_0SB(V: BOOLEAN) ratura OS.BOOLEAN is 
begin 
if V then 
return 1; 

else 

return 0; 

end if; 

end B.TO.OSB; 

pragma INLINE(B.TOJ)SB); 

function 0SB_T0_B(I: integer) return BOOLEAN is 
begin 

if 1 > 0 then 
return true; 
else 

return false; 

end if; 

end OSB.TO.B; 

pragma INLINE(OSB.TO.B); 


—DATABASE ROOT FUNCTIONS 


—DATABASE ROOT FIND 

function c_database_root_find( A: ADDRESS; D: DATABASE) 
return DATABASE_ROOT; 

pragma INTERFACED, c.database.root.find); 
pragma INTERFACE_NAME(c_database_root_find, 

C.SUBP.PREFIX k "database.root.find"); 
function DATABASE_ROOT_FIND(NAME: STRING; DB: DATABASE) 
return DATABASE.ROOT is 
begin 

return c.database.root.find(c_ada_to_c(NAME(NAME’FIRST)’ADDRESS, 

NAME’LENGTH), DB); 

end DATABASE_ROOT_FIND; 

pragma INLINE(DATABASE.ROOT_FIND); 


—DATABASE CREATE ROOT 

function c_database_create_root(D: DATABASE; A: ADDRESS) 
return DATABASE.ROOT; 

pragma INTERFACE(C, c.database.ereate.root); 
pragma INTERFACE_NAME(c_database_create_root, 

C.SUBP.PREFIX k "database_create_root"); 
function DATABASE.CREATE.R30T(DB; DATABASE; NAME: STRING) 
return DATABASE.ROOT is 
begin 

return c_database_create_root(DB, 

e.ada.to.e(SAKE(NIKE’FIRST)’ADDRESS, NAME’LENGTH)); 

end DATABASE.CREATE.ROOT; 


C-12 










f 


pragma IHLINECDATABASE.CREATE.ROOT) j 
—DATABASE.ROOT.GET.NAKE 

function c_databass_root_get_name(R : DATABASE.ROOT) ratura SYSTEM.ADDRESS; 
pragma INTERFACED, c.databaae.root.get.name); 
pragma INTERFACE_NAME(c_database_root_get_name, 

C.SUBP.PREFIX t "database.root.get.name"); 


function DATABASE_ROOT_GET_NAME(ROOT : DATABASE.ROOT) ratnrn STRING ia 
ROOT.ADDRESS : SYSTEM.ADDRESS; 

R00T.NAME : A.STRINGS.A.STRING; 

NAME : STRINGd. .254) :-(others »> » »); 

LEN : natural :« 0; 

begin 

ROOT.ADDRESS :■c_database.root_gat.nama(ROOT); 

ROOT.NAME :■ C_Strings.COSVERT.C.TO.ACC.atring».to.c(ROOT.ADDRESS)) ; 
LEN :■ ROOT.NAME.S'LENGTH; 

NAME(1.. LEN) :■ ROOT.NAME.S(l..LEN); 
return NAME(1.. LEN); 
and DATABASE.ROOT_GET.NAME; 


— create new oa.types 

function C_ALLOC_TYPESPEC(A: address; I: integer) return OS.TYPESPEC; 
pragma INTERFACE(C, c.alloc.typespec); 
pragma INTERFACE.HAME(c.alloc.typespec , 

C.SUBP.PREFIX ft "alloc.typespec"); 

function ALLOC.TYPESPEC(NAME: STRING) return OS.TYPESPEC is 
begin 

return C.ALLOC.TYPESPEC(c.ada.to.c(NAME(SAME»FIRST)’ADDRESS. NAME*LENGTH),0) 
end ALLOC.TYPESPEC; 
pragma IHLINE(AUOC.TYPESPEC); 

end OSTORE; 


C-13 









C.6 Interface Program: ostore.g.a 


— Basic interface to ObjactStore from tha Ada programming language 
-- Prototype design and implementation by Dave Rosenberg of Object 

— Design, Inc. This file provides suitable generic definitons. 

—Functions are extended and binding is changed to C library interface 
—by Li Chou. Nov, 1992. 


with 0S_TYPES; use OS.TYPES; 
with OSTORE; use OSTORE; 
with SYSTEM; use SYSTEM; 
generic 

type U.TYPE is private; 
type U.TYPEPTR is access U.TYPE; 
with function GET_03_TYPESPEC return OS_TYPESPEC; 
package OSTORE.GENERICS is 

— Database Roots 

function DATABASE_ROOT_GET_YAL0E(ROOT: DATABASE.ROOT) return U.TYPEPTR; 

— for collections -by Li Chou 92-11-06 

function DATABASE_ROOT_GET_VALOE(ROOT: DATABASE.ROOT) return 0S.C0LLECTI0N; 

procedure DATABASE_R00T_SET_VALUE(R00T: DATABASE.ROOT; VALUE: U.TYPEPTR); 

—for collecitons -by Li Chou 92-11-06 

procedure DATABASE.ROOT.SET.VALUE(ROOT: DATABASE.ROOT; VALUE: 

OS.COLLECTION); 

— Persistent Allocation 

function PERSISTENT.NEVCDB: DATABASE) return U.TYPEPTR; 
end OSTORE.GENERICS; 


C-14 





C. 7 Interface Program: os , org.l.a 

—Ada implementation for generic components of the ObjectStore interface 

with 0STORE; nse OSTORE; 
with SYSTEM; use SfSTEM; 
with LANGUAGE; use LANGUAGE; 
with OS.TYPES; use OS.TYPES; 
with 0S.EXCEPTI0NS; 

package body OSTORE.GENERICS is 

EXCEPTION.INI : OS.EXCEPTIONS.OS.EXCEPTION.INDEX; 

--DATABASE ROOT GET VALUE 

— for os.collaction. Li Chou 92-11-06 

function c.database.root.get.value(R: DATABASE.ROOT; T: OS .TYPESPEC) 
return OS.COLLECTION; 

function c_database_root_get_value(R: DATABASE.ROOT; T: OS.TYPESPEC) 
return U.TYPEPTR; 

pragma INTERFACE(C, c„dstabase_root_get_value); 
pragma INTERFACE_NAME(c.database_root_get_value, 

C.SUBP.PREFIX A "database.rjot.get.value"); 
function DATABASE.ROOT.GET.VALUE(ROOT: DATABASE.ROOT) 
return U.TYPEPTR is 
begin 

return c.database.root.get.value(ROOT,GET.OS.TYPESPEC); 
end DATABASE.ROOT.GET.VALUE; 
pragma INLINE(DATABASE.ROOT.GET.VALUE); 

— for collections -by Li Chou 92-11-06 

function DATABASE.ROOT.GET.VALUE(ROOT: DATABASE.ROOT) return OS.COLLECTION is 
begin 

return c.database.root_get_value(ROOT,GET.OS.TYPESPEC); 
end DATABASE.ROOT.GET.VALUE; 

--DATABASE ROOT SET VALUE 

—for collecitons -by Li Chou 92-11-06 

procedure c_database_root_set_vtlue(R: DATABASE.ROOT; V: OS.COLLECTION; 

T: OS.TYPESPEC); 

procedure c.databasejroot.set.value(R: DATABASE.ROOT; V: U.TYPEPTR; 

T: OS.TTPESPEC); 

pragma INTERFACED, c.database.root.set.value); 
pragma INTERFACE.NAMECc.database.root.set.value, 

C.SUBP.PREFIX ft "database.root.set.value"); 
procedure DATABASE.ROOT.SET.VALUE(ROOT: DATABASE.ROOT; VALUE: U.TYPEPTR) is 
begin 

e.database.root.set.value(ROOT, VALUE, GET.OS.TYPESPEC); 

end DATABASE.ROOT.SET.VALUE; 

pragma HLINE(DATABASE_ROOT_SET.VALUE); 


C-15 


/ 


I 




mrnmBmzmmGTmssixiES&mmszmm m &m &SBmiBBa msBB i i « > arnm m 


—for collecitona -by Li Chou 92-11-06 

procedure DATABASE_R00T_SET_VALUE(R0QT: DATAj 3 ASE.ROQT; VALUE: 0S.C0LLECTI0N) is 
begin 

c_database_root_set_value(RQOT, VALUE, GET.OS.TYPESPEC); 
end DATABASE_R00T_SET_VALUE; 

— Persistent new 

function c.persistent_new(T: OS.TYPESPEC; N: 0S.INT32; DB: DATABASE) 
return U.TYPEPTR; 

pragma INTERFACE(C, c.persistent.new); 
pragma INTERFACE.NAMECc.porsistent.new, 

C.SUBP.PREFIX k "objsctstore.allec"); 
function PERSISTENT.NEVKDB: DATABASE) return U.TYPEPTR is 
begin 

return c_persistent_new(GET_OS_TYPESPEC, 1, DB); 

end PERSISTENT.NEW; 

pragma INLINE(PERSISTEHT.NEW); 

end OSTQRE.GENERICS; 





C.8 Interface Program: os.coll.a 


— Buie collection interface to ObjectStore frost the Ida programming 

— language prototype implesientation by Li Cbou 


with SYSTEM; nee SYSTEM; 
with OSTQRE; use OSTORE; 
with OS.TYPES; use OS.TYPES; 
generic 

type U_TYPE is private; 

type U.TYPEPTR is access O..TYPE; 

with function GET.OS.TYPESPEC return OS.TYPESPEC; 

package OS.COLLECTION.PKG is 


FUNCTION 0S_C0LLECTI0N_CEANGE_BEBAVI0R(0S_C0L 

BEEV 
VERIFY 
RETURN 05_ 


: OS.COLLECTION; 

: STRING; 

: BOOLEAN :-TRUE) 
COLLECTION; 


— Collection Operations 

-- parameters of os.coll.rep.descriptor and int (retain policy descriptor) 

— are not allowed in this function 


— create collection with behavior 

— 92-11-16 

function OS_COLLECTION_CREATE(DB 

BEEV 

SIZE 

RETAIN 


DATABASE; 

STRING; 

0S.INT32 :» 0; 
BOOLEAN:- false 


> return OS.COLLECTION; 


function OS_COLLECTIOH_CREATE(DB ; DATABASE; 

SIZE : 0S.INT32 0 

) return OS.COLLECTION; 


procedure OS.COLLECTION.DELETECOS.COL : OS.COLLECTION); 

function OS_COLLECTION_CARDINALITY(OS_COL : OS.COLLECTION) return 

0S.UNSIGNED.INT32; 


procedure OS_COLLECTIOH_CLEAR(OS.COL : OS.COLLECTION); 

function OS.COLLECTION.CONTAINSCOS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) return BOOLEAN; 

procedure OS.COLLECTION_COPY(OS_COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION); 

function OS_COLLECTION.COUNT(OS_COL : OS.COLLECTION; 


C-17 








VALUE 


: U.TYPEPTR) return 0S.UNSIGNED.INT32; 


procedure 0S_C0LLKCTI0N_DIFfERENCE(0S_C0L_A : OS.COLLECTION; 

0S_C0L_B : OS.COLLECTION); 

function OS.COLLECTiON.EHPTYCOS.COL : OS.COLLECTION) return BOOLEAN; 

function OS_COLLECTION_EQUAL<OS_COL_A : OS.COLLECTION; 

03.C0L.B : OS.COLLECTION) return BOOLEAN; 

function OS_COLLECTION_GET_FEHAVIOR(OS.COL : OS.COLLECTION) 

return 0S.UNSIGNED.INT32; 

function OS_COLLECTION_GREATER_TEAN(OS_COL_A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN; 

function OS.COLLECTION.GREATER.TEAN.OR.EQUAL ( 

OS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN; 

— oa.collections 

procedure OS.COLLECTION.INITIALIZE; 

— the functions of insert 

procedure OS_COLLECTION_INSERT(OS_COl : OS.COLLECTION; 

VALUE ; U.TYPEPTR) ; 

procedure OS.COLLECTION.INSERT_FIRST(OS_COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) ; 

procedure OS_COLLECTION_INSERT_LAST(OS_COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) ; 

procedure OS_COLLECTION_INTERSECT(OS_COL_A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION); 

function OS.COLLECTION.LESS.THANCOS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN; 

function OS_COLLECTION_L£SS_THAN_OR_EQUAL(OS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) 
return BOO. TAN; 

function OS.COLLECTTON_NOT.EJ)UAL(OS.COL_A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN 

— the functions of remove 

function OS.COLLECTION_REMOVE(OS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) return BOOLEAN; 

function OS_COLLECTION_REKOVE_FIBST(OS.COL : OS.COLLECTION) return U.TYPEPTR; 











/ 


function 0S_«)LLECTI0N_REK0VE_LAST(0S_C0L : OS.COLLECTION) r«Mra U.TYPEPTR; 

function OS_COLLECTION_ONLY(QS_COL : OS.COLLECTION) return U F YPEPTR; 

function OS.COLLECTION.ORDERED.EQUAL(OS.COL.A : OS.COLLECTION. 

0S.C0L.B : OS.COLLECTION) 
return BOOLEAN; 

— the functions of pick 

function OS.COLLECTICN.PICK(OS.COL : OS.COLLECTION) return U.TYPEPTR ; 

function 0S_C0LLECTI0N_QUERY(0S_C0L : OS.COLLECTION; 

ELEMENT.TYPE : STRING; 

EXPRESS.STRING : STRING; 

DB : DATABASE) RETURN OS.COLLECTION; 

function OS.COLLECTION.QUERY.EXISTSCOS.COL : OS.COLLECTION; 

ELEMENT.TYPE : STRING; 

EXPRESS.STRING : STRING; 

DB : DATABASE) RETURN BOOLEAN; 


function OS.COLLECTION.QUERY.PICK(OS.COL : OS.COLLECTION; 

ELEMENT.TYPE s STRING; 

EXPRESS.STRING : STRING; 

DB ; DATABASE) RETURN U.TYPEPTR; 

procedure OS.COLLECTION.UNIONCOS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION); 

end OS.COLLECTION.PKG; 



C-19 


/ ' 

/ 








C.9 Interface Program: os.colLb.a 

— Basic collection interface to ObjactStore from the Ada programming 

— language prototype implementation by Li Chou 

with UNSIGNED.TYPES; use UNSIGNED. i?E3; 
with LANGUAGE; use LANGUAGE; 
with OSTORE; use OSTORE; 
with OS.TYPES; use OS.TYPES; 
with SYSTEM; use SYSTEM; 

— library provide by VERDIX ADA. 
with A.STRING3; 

package body OS.COLLECTION PKG is 

SUBTYPE Uppercase.Character IS CHARACTER RANGE *1* .. ’Z ; 

SUBTYPE Lowercase.Charactor IS CHARACTER RANGE 'a' .. 

FUNCTION Is.Alphabetic (The.Character : IN Character) RETURN BOOLEAN IS 

BEGIN 

IF The .Character IN Uppercase. Ch.vcrcti'r THEN 
RETURN TRUE; 

ELSIF Tho.Character IN Lowercase.Character THEN 
RETURN TRUE; 

ELSE 

RETURN FALSE; 

END IF; 

END Is_Alphabetic; 

— Collection Operations 

— parameters of os.coll.rep.descriptor and int (retain policy descriptor) 

— are not allowed in this function 

— create collection with behavior 

— 92-11-16 

function ADA_0S_B5HAVI0R(BEHV : STRING) return 0S.UNSIGNED.INT32 is 
position_counter : natural :* 1; 
behavior.counter : natural; 
os.string.length : natu.al := 0; 
os.behavior ; os_uraigned.int32 := 0; 

temp.string ; striugCl..30); 
temp.behavior ; os_cc)lection_behavior; 
begin 

os.string.length :■ £shy*length; 
while position_counter <* os.string.length loop 
if Is_Alphabetic(behv(position_counter)) then 
temp.stringd. .30) :«(others »> • ’); 
behavior.counter :■ 1; 

while P0SITI0N.C0UNTER <* OS.STRING.LENGTH and then 
BEHV(POSITION.COUNTER) /« » * 
loop 



C-20 



\ 





/ 








TEMP.STRING(BEHAVIOR.COUNTER) :* BEHV(PCSITIQN_CQUNTER); 
POSITION.COUNTER :* POSITION.COUNTER + 1; 

BEHAVIOR.COUNTER :» BEHAVIOR.COUNTER + 1; 

•nd loop; — get behavior 

TEMP.BEHAVIOR OS.COLLECTION.BEHAVIOR'VALUECTEMP.STRING 
(1..temp.atring*length)); 
if temp.behavior in oa.collection.behavior then 
oa.behavior :■ oa.behavior + 2 ** 

os.collection.behavior’poaDemp.behavior); 

end if; 

— get ride of symbol *|* and apace 
else 

position.counter :■ poaition.counter + 1 ; 
and if; 
and loop; 

return oa.behavior; 
and ADA.OS.BEHAVIOR; 

FUNCTION C_0S_C0LLECTT0N_CHANGE_BEHAVI0R(0S_C0L : OS.COLLECTION; 

BEHAVIOR : OS.UNSIGNED.INT32; 

VERIFY : 0S.B00LEAN) RETURN OS.COLLECTION; 

PRAGMA INTERFACED, c.oa.collection.change.behavior); 

PRAGMA INTERFACE_NAME(c.oa_collection_changa_behavior, 

C.SUBP.PREFIX ft "oa.collaction.change.behavior"); 

FUNCTION OS_CCLLECTION_CHANGE_BEHAVXOR(OS_COL : OS.COLLECTION; 

BEHV : STRING; 

VERIFY : BOOLEAN :=TRUE) RETURN 

OS.COLLECTION IS 

COLL.BHV : 0S.UNSIGNED.INT32 :«0; 

BEGIN 

if BEHV'length /«■ 0 then 

COLL.BHV :■ ADA_OS_BEHAVIOR(BEHV(i..BEHV’length)); 
and if; 

RETURN C_OS_COLLECTION_CEANGE_BEHAVIOR(OS_COL,COLL_BHV,B_TO_OSB(VERIFY)) 
END OS.COLLECTION.CHANGE.BEHAVIOR; 

PRAGMA INLINE(OS.COLLECTION.CHANGE.BEHAVIOR); 

function C.OS_COLLECTION_CREATE(DB : DATABASE; 

BEHAVIOR : 0S.UNSIGNED.INT32; 

SIZE : 0S.IHT32; 

DESCRIPTOR :0S.INT32; 

RETAIN : OS.BOOLEAN) ratum OS.COLLECTION; 

pragma INTERFACED, c.oa.collection.create); 
pragma IHTERFACE_NAME(-:_o8_collection_create, 

C.SUBP.PREFIX ft "oa_collection_create"); 

function OS.COLLECTION.CREATE(DB : DATABASE; 


C*21 




SIZE 


: 0S_INT32 :- 0) return OS.COLLECTION is 


— behavor bitwise operation 

— os_collection_allow_nuHs => 1 

— os_collection_allov_duplicates => 2 

— os.collection.signal.duplicates => 4 

— os_collection_maintain_order => 8 

— os.collection.maintain.cursors => 16 


— this sample default that the behavor is maintain.order and cursors (24) 

C0LL.BHV : 0SJJNSIGNED.INT32 :- 24; 

RETAIN : BOOLEAN:- false; 

begin 

return C_OS_COLLECTION.CREATE(DB,COLL_BHV,SIZE,0,B.TO_OSB(RETJ.IN)); 
end OS.COLLECTION.CREATE; 
pragma INLINE(OS.COLLECflON.CREATE); 


— create collection with behavior 

— 92-11-16 

function OS_COLLECTION_CREATE(DB : DATABASE; 

BEHV : STRING; 

SIZE : 0S.INT32 := 0; 

RETAIN : BOOLEAN:- false) return 

OS.COLLECTION is 

COLL.BHV : OS_ONSIGNED_INT32 0; 
begin 

if BEHV’length /= 0 then 

COLL.BHV :- ADA_0S_BEHAVI0R(BEHV(1..BEHV’length)); 
end if; 

return C_OS_COLLECTION_CREATE(DB,COLL.BHV,SIZE,0,B.TO.OSB(RETAIN)); 
eci OS.COLLECTION.CREATE; 

procedure C_0S_C0LLECTI0N_DELETE(0S_C0L : OS.COLLECTION); 
pragma INTERFACED, c.os.collection.delete); 
pragma INTERFACE_NAHE(c_os_collection_delete, 

C.SOBP.PREFIX A "os.collection.delete"); 

procedure OS_COLLECTIQN_DELETE(OS_COL : OS.COLLECTION) is 
begin 

C.OS.COLLECTION.DELETE(OS.COL); 
end OS.COLLECTION.DELETE; 

function c_os_collection_cardinality(OS_COL : OS.COLLECTION) return 

OS.ONSIGNED.INT32; 

pragma INTERFACE(C, c.os.collrction.cardinality); 
pra'jiua INTERFACE_NAME(c.os.collection.cardinality, 

C.SOBP.PREFIX A "os.collection, cardinality"); 

function OS.COLLECTION.CARDINALITY(0S.C0L : OS.COLLECTION ) return 

OS.ONSIGNED.INT32 is 











R"‘^ L --* , ' iai ~'~* ' ^ '~‘ -^- -i “-' -^■■'4^- > : ‘--* i . ^ -- '- - -* : j aSiigjMfaliat •’[ '" : ' ,J '-- ^I' ■ - ■ iYi ■ ' * - '■’■'‘f■ f - |, ' ; •■ • 



b*gin 

raturn c.oa.collaction.cardinalityCOS.COL); 
and OS.COLLECTION.CARDINALITY; 
pragma INLINECOS.CULLECTIOH.CJRDINALITY); 

procadura C_0S_C0LLECTIQN_CLEARC03_C0L : 03.COLLECTION); 
pragma INTERFACE(C, c.oa.collaction.claar); 
pragma INTERFACE.NAKECe.oa.collaction.elaar, 

C.SUBP.PREFIX 4 "oa.collactlon.claar"); 

procadura OS.COLLECTIGN.CLEiRCOS.COL : OS.COLLECTION) la 
bagin 

C_OS_C.>LLECTION_CLEAR(OS.COL); 
and 0S.C0LLECTI0N.CLEAR; 

-- oa.collaction.containa 

function C.OS.COLLECTION.CONYAINS(OS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) raturn BOOLEAN; 

pragma INTERFACECC, c.oa.collaction.contains); 
pragma INTERFACE.NAMECc.oo.collaction.containa, 

C.SUBP.PREFIX ft M oa.coI3actlon_containa M ); 

function OS.COLLECTION.CONTAINS(OS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR ) raturn BOOLEAN is 

bagin 

raturn C.OS.COLLECTION.CONTAINS(OS.COL, VALUE); 
and OS.COLLECTION.CONTAINS; 
pragma INLINE(OS.COLLECTION.CONTAINS); 

procadura C.OS.COLLECTION.CCPYCOS.COL.A : OS.COLLECTION; 

0S.C0L.B : OS.COLLECTION); 

pragma INTERFACECC, c.oa.collactlon.copy); 
pragma INTERFACE_MAME(c.oa_collaction_copy, 

C.SUBP.PREFIX k "oa.collaction.copy"); 

procadura OS.COLLECTION.COPT(03_COL.A : OS.COILECTXON; 

OS.COL.B ; OS.COLLECriOS) ia 

bagin 

C.OS.COLLECTIO».COPY(03.COL.A,OS.COL.B); 
and OS.COLLECTION.COPY; 
pragma INLINE(OS.COLLECTION.COPT); 

function C.OS.COLLECTION.COUNT(OS.COL : OS.COLLECTION; 

VALUE ; U.TYPEPTR) raturn OS.UNSIGNED.INT33; 

pragma INTERFACECC, c.da.collactlon.count); 
pragma INTERFACE_NlMS(c_oa_collactlon_count, 

C.SUBP.PREFIX k "oa.collaction.count"); 
function OS.COLLECTION.CCUNT(0S_C0L s OS.COLLECTION; 

VALUE s U.TYPEPTR) raturn 0S.UNSIGNED.INT32 la 


C-23 


) 











-a v .. -*13 


begin 

return c_os_collection_count(OS_COL,VALUE); 
end 0S.C0LLECT10N.C0UNT; 
pragma INLINEDS.COLLECTION.COUNT); 

procedure C.OS.CGLLECTION.DIFFERENCEDS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION); 

pragma INTERFACED, e.os.collsction.difference); 
pragma INTERFACE_NAME(c_os_collection_differ«nce, 

C.SUEP.PREFIX ft "oa.colleetion.difference"); 


procedure OS.COLLECTION.DIFFERENCE(OS_COL_A : OS.COLLECTION: 

OS.COL.B : OS.COLLECTION) is 

begin 

C.OS.COLLECTION.DIFFERENCE(OS.COL.A,OS.COL.B); 
end OS.COLLECTION.DIFFERENCE; 
pragma INLINE(OS.COLLECTION.DIFFERENCE); 


— os.collectlon.empty 

function C.OS.COLLECTION.EKPTYCOS.COL : OS.COLLECTION) return BOOLEAN; 

pragma INTERFACED, c.os.collection.empty); 
pragma INTERFACE_NAME(c_oa_coIlection_empty, 

C.SUBP.PREFIX k "os.collection.empty"); 


function OS.COLLECTION.EMPTY(OS.COL : OS.COLLECTION) return BOOLEAN is 
begin 

return C.OS.COLLECTION_EMPTT(OS_COL); 
end OS.COLLECTION.EMPTY; 
pragma INLINE(OS.COLLECTION.EMPTY); 


-- os.collection.equtl 

function C_0S_C0LLECTI0N_EqUAL(0S_C0L_A : OS.COLLECTION; 

OS.COLL.B : OS.COLLECTION) return BOOLEAN; 

pragma INTERFACED, c.os.eollection.equal); 
pragma XNTERFACE.NAXECc.os.collection.equal, 

C.SUBP.PREFIX k "os.collection.equal"); 


function OS_COLLECTION_EQUAL(OS_COL_A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN is • 

begin 

return C.OS.COLLECTION.EQUAL(OS.COL.A, OS.COL.B); 
end OS.COLLECTION.EQUAL; 
pragma INLINE(OS.COLLECTION.EQUAL); 


C-24 


' . i 



/ 







y y w A- i Mg ^vjlPg ii 


— oe.collection.g'St.behavior 

function c_os_collectian_get_behavior(OS_COL : OS.COLLECTION 

) return 0S.UNSIGNED.INT32; 
pragma INTERFACED, c.oa.collection.get.behavior); 
pragma INTERFACE_NAM£(c_os_collection_get_behavior, 

C.SUBP.PREFIX k "oB.collection.get.behavior"); 

Sanction OS.COLLECTION_GET_BEHAVIORDS.COL : OS.COLLECTION 

) return 0S.UNSIGNED.INT32 is 

begin 

return c.os.collection.get.behaviorDS.COL); 
end OS.COLLECTION.GET.BEHAVIOR; 
pragma INLINEDS.COLLECTION.GET.BEHAVIOR); 

— os.collection.greater.than 

function C.OS.COLLECTIQN.GREATER.THANDS.COL.A : OS.COLLECTION; 

OS.COLL.B : OS.COLLECTION) return BOOLEAN; 

pragmr INTERFACE(C, c.os.collection.greater.than); 
pragma INTERFACE_NAME(c_ 08 .colloction_greater_tban, 

C.SOBP.PREFIX k "oa.collection.greater.than"); 


function OS.COLLECTION.GREATER.THAN(OS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN is 

begin 

return C.OS.COLLECTION.GREATER.TEAH(OS.COL.A, OS.COL.B); 
end OS.COLLECTION.GREATER.THAN; 
pragma INLINE(0S_C0LLECTI0N_GREATER_T1AN); 

— OB.collection.greater.than.or.eqcal 

function C.OS.COLLECTION.GREATER.THAN.OR.EQUALCOS.COL.A : OS.COLLECTION; 

OS.COLL.B : OS.COLLECTION) return BOOLEAN; 

pragma INTERFACED, c.OB.collection.greater.than.cr.equal); 
pragma INTERFACE_NAME(c_OB_collection_greater_tban_or_equal, 

C.SOBP.PREFIX k "oe.collection.greater.than.or.equal"); 


function OS.COLLECTION_GREATER.THAN_OR.EQOAL(OS_COL.A ; OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN ia 

begin 

return C_OS_COLLECTION_GREATER_THAH_OR_EQUALDS_COL_A,OS.COL.B); 
end OS.COLLECTION.GREATER.THAN.OR.EQUAL; 
pragma INLIHE(OS.COLLECTION.GREATER.THAN.OR.EQOAL); 

— implemented by Li Chou. 92-11-04 

— oa.collectione 

procedure C.OS.COLLECTION.INITIALIZE; 
pragma INTERFACED, c_oa_collection_initialize); 
pragma IHTRRFACE_NAME(c_oe_eollection_iaitialize, 



C_SUBP.PREFIX * "os.eollection.initialize"); 
procedure OS.COLLECTION.INITIALIZE is 
begin 

C.OS.COLLECTION.INITIALIZE; 
end OS.COLLECTION.INITIALIZE; 
pragma INLINE(OS.COLLECTION.INITIALIZE); 


— tha functions of insert 

procedure C_OS_COLLECTION_INSERT(OS_COL : OS.COLLECTION; 

VALUE : U.TYPEPTR); 
pragma INTERFACE(C, c.os.collection.insert); 
pragma INTERFACE.NAMECc.os.collection.inBert, 

C.SUBP.PREFIX k "os.collection.insert"); 

procedure 0S_C0LLECTI0N_INSERT(0S_C0L : OS.COLLECTION; 

VALUE : U.TYPEPTR) is 

begin 

C_OS_COLLECTION_INSERT(US_COL.VALUE); 
end OS.COLLECTION.INSERT; 
pragma INLINE(OS.COLLECTION.INSERT); 

— OS.COLLECTION.INSERT.FIRST 

procedure C.OS.COLLECTION_INSERT.FIRST(OS.COL : OS.COLLECTION; 

VALUE U.TYPEPTR); 

pragma INTERFACED, c.os.collection.insert_first); 
pragma INTERFACE_NAME(c_os_collection_insert_first, 

C.SUEP.PREFIX k "os.collection.insert.first"); 

procedure OS.COLLECTION_INSERT_FIRSTCOS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) is 

begin 

C_nS_COLLECTION_INSERT_FIRST(OS_COL,VALUE); 

end OS.COLLECTION.INSERT.FIRST; -__ 

pragma INLINE(OS.COLLECTION.INSERT.FIRST); 


— os.collection.insert.last 

procedure C_OS_COLLECTION.INSERT_LAST(OS_COL : OS.COLLECTION; 

VALUE : U.TYPEPTR); 

pragma INTERFACE(C, c_os_eollection_insert_last); 
pragma INTERFACE.NAMECc.os.collection.insert.last, 

C.SUEP.PREFIX k "os.collection.insert.last"); 

procedure OS.COLLECTION_INSERT_LASTCOS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) is 

begin 

C_OS.COLLECTION.IHSERT_LASTCOS.COL,VALUE); 










•nd OS.COLLECTION.INSERT.LAST; 

pragma INLINE(OS_COLL£CTION_INSERT_LAST); 


procedure C_OS_COLLECTION_INTERSECT(OS_COL_A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION); 

pragma INTERFACED, c.oa.collection.intersect); 
pragma INTERFACE_NAME(c_oe_collaction_interseet, 

C.SUBP.PREFIX A "oa_eollaction_intaraaet"); 


procadura OS.COLLECTXON.INTERSECTDS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) ia 

begin 

C_OS_COLLECTION_INTERSECT(OS_COL_A,OS.COL.B); 
and OS.COLLECTION.INTERSECT; 
pragma INLINE(OS_COLLECTION_INTERSECT); 

— oa.collaction_leaa.than 

function C_OS_COLLECTION_LES3_THAN(OS_COL_A : OS.COLLECTION; 

OS.COLL.B : OS.COLLECTION) return BOOLEAN; 

pragma INTERFACE(C, c.oa.collection.lesa.than); 
pragma INTERFACE_NAME(c_o8.collection_leas_than, 

C.SOBP.PREFIX k "o8.collaction_la8B.than"); 


function OS.COLLECTION.LESS.THAN(OS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN ia 

begin 

return C_OS.COLLECTION_LESS.THAN(OS.COL.A,OS.COL.B); 
end OS.COLLECTION.LESS.THAN; 
pragma INLINECOS.COLLECTION.LESS.THAN); 

— os_collection_lass_than_or_equal 

function C_OS_COLLECTION_LESS_THAN_OR_EqtJAL(OS_COL_A ; OS.COLLECTION; 

OS.COLL.B : OS.COLLECTION) return BOOLEAN; 

pragma INTERFACE(C, c.oe.ccllection.leaa.than.or.equal); 
pragma INTERFACE.NAMECc.OB.collection.lass.than.or.equal, 

C.SUEP.PREFIX k "oa.collectiou.leaa.than.or.equal"); 


function OS.COLLECnON.LESS.THAN.OR.EQOAL(OS.COL.A ; OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN ia 

begin 

return C_03_COLLECTION.LESS_THAN_OR.EOOAL(OS_COL_A,OS.COL.B); 
end OS.COLLECnON.LESS.THAN.OR.EQUAL; 
pragma INLINE(OS_COLLECnON.LESS.THAN.OR.EQUAL); 




C-27 






— os.collection.not.equal 

function C_OS_COLLECTION_NOT_EQUAL(OS_COL_A : OS.COLLECTION; 

OS.COLL.B : OS.COLLECTION) return BOOLEAN; 

pragma INTERFACECC, c_oa_collaction_not_equal); 
pragma INTERFACE.NAMECc.os.colleetion.not.equal, 

C.SUBP.PREFIX k "os_coll«ction_not_«qual"); 


function OS.COLLECTION.NOT.EQUAL(OS.COL.A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) return BOOLEAN is 

begin 

return C.OS.COLLECnON.NOT.EQOAL(OS.COL.A,OS.COL.B); 
end OS.CCLLECTION.NOT.EqUAL; 
pragma INLINECOS.COLLECTION.NOT.EQUAL); 

~ the functions of remove 


function C_OS_COLLECTION_REMOVE<OS_COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) return BOOLEAN; 
pragma INTERFACECC, c.os.collection.removr); 
pragma IHTERFACE_NAME(c_os_collection_remove, 

C.SUBP.PREFIX k "os_collection_remove"); 

function OS.COLLECTION.REMOVECOS.COL : OS.COLLECTION; 

VALUE : U.TYPEPTR) return BOOLEAN is 

begin 

return C_OS.COLLECTION_REMOVECOS.COL,VALUE); 
end OS.COLLECTION.REHOVE; 
pragma INLINE(OS.COLLECTION.REHOVE); 

— OS.COLLECTION.REMOVE.FIRST 

function C.OS.COLLECTION.REIOVE.FIRSTCOS.COL : OS.COLLECTION) return U.TYPEPTR; 

pragma INTERFACECC, c_os_collection_remove_first); 
pragma INTERFACE_NAME(c_os_collection_remove_first, 

C.SUBP.PREFIX A "os.collection.remove.first"); 

function OS.COLLECTION.REMOVE.FIRSTCOS.COL : OS.COLLECTION) return U.TYPEPTR is 
begin 

return C_OS_COLLECTION_REMOVE_FIRST (CS.COL); 
end OS.COLLECTION.REMOVE.FIRST; 
pragma INLINE(OS.COLLECTIONJIEMOVE.FIRST); 


— OS.COLLECTION.REMOVE.LAST 

function C_OS.COLLECTIQN_REMOVE.LAST(OS.COL : OS.COLLECTION) return U.TYPEPTR; 


C-28 



pragma INTERFACED, c_ 08 _collaction_ramov#.laat); 
pragma INTERFACE_NAME(c_os_coll#ction_renova_last, 

C.SOBP.PREFIX ft "os.collaction.ramova.last"); 

function OS_COLLECT10N_REMOVE_LASTDS_COL : OS.COLLECTIQN} ratum O.TYPEPTR is 
bagin 

ratum C_OS_COLLECTION_REHOVE_LASTDS_COL); 
and OS.COLLECTION_REMOVE.UST; 
pragma INLINE(QS_C0LLECTI0N_REM0VE_LAST); 


— 0S.C0LLECTI0N.0NLT 

function C_OS.COLLECTION.ONLT(OS.COL : 0S.C0LLECTI0N) ratum O.TYPEPTR; 

pragma INTERFACED, c_os_collection„only); 
pragma INTERFACE_NAHE(c_os_collaction_only, 

C.SUBP.PREFIX A "os.collaction.only"); 


function 0S_C0LLECTI0N.0NLY(0S.C0L : OsJcOLLECTIOH) ratum O.TYPEPTR is 
bagin 

ratum C.OS.COLLECTION.ONLY(OS.COL); 
and OS.COLLECnON.ONLY; 


— OS.COLLECnON.ORDERED.EtJOAL 

function C.OS.COLLECTION.ORDERED.EQOAL(OS.COL.A j OS.COLLECTION; 

OS.COLL.B : OS.COLLECTIOH) ratum BOOLEAN; 

pragma INTER7ACE(C, e_os_eollactioa_ordarad_aqu&l); 
pragma XSTERFACE_NAME(c_os_collsction.brdarad_aqual, 

C.SOBP.PREFIX ft "os_collaction_ordarod_aqual"); 

function OS.COLLECTION.ORDERED.EQOALDS boL.A : OS.COLLECTION; 

0S.C0L.B : OS.COLLECTION) ratum BOOLEAN is 

bagin 

ratum C_OS_COlLECnON_ORDERED_EQOAL<OS_COL_A, OS.COL.B); 


and OS.COLLECnON.ORDERED.EtJOAL; 


pragma IHLINEDS.COLLECriON.ORDERED.EQOAL); 


— tha functions of pick 


— OS.COLLECnON.PICK 

function C_OS.COLLECTION_PICX(OS_COL : OS.COLLECnON) ratum O.TYPEPTR; 


pragma INTERFACED, c.os.collaction.pick); 
pragma INTERFACE_NAME(c_os.collaction_pick, 

C.SOBP.PREFIX ft "os.collaction.pick"); 

function 0S.C0LLECn0N.PICK<0S_C0L : OS.COLLECTION) ratum O.TYP E PTR is 
bagin 

ratum C.OS.COLLECTION.PICK(OS.COL); 
and OS.COLLECTION_PICX; 


C-29 





./V' /■■>" 




pragma INLINE(OS.COLLECTION.PICK); 


FUNCTION C_OS_COLLECTIQN_QUERY(OS_COL : 

ELEMENT : 
EXPRESSION : 
DB : 
FILE.NAME : 
LINE.NUMBER: 


OS_COLLECTION; 
SYSTEM.ADDRESS; 
SYSTEM.ADDRESS; 
DATABASE; 

0S.INT32; 

0S.UNSIGNED.INT32) 


RETURN OS.COLLECTION; 


PRAGMA INTERFACED, c.oa.collection.quary); 

PRAGMA INTERFACE_NAME(c_oa_coll«ction_qu«ry, 

C.SUBP.PREFIX ft “oa.collaction.quary"); 

FUNCTION OS.COLLECTION.QUERY(CS.COL : 

ELEHENT.TYPE : 

EXPRESS.STP.INO : 

DB : 

— THIS SAMPLE DEFAULT THAT THE FILE NAME AND LINE NUMBER ARE 0 
-- FILE.NAME s INTEGER 0; 

— LINE.NUMBER ; 0S.UNSIGN.INT32 :» 0; 

ELEMENT.ADDRESS : SYSTEM.ADDRESS 

A.STRINGS.TO_C(A.STRINGS .T0_A(ELEMEHT_TYPE(1..ELEKENT.TTPE»LEHGTH))); 
EXPRESSION.ADDRESS ; SYSTEM.ADDRESS :« 

A.STRINGS.TO.C(A.STRINGS.T0.A<EXPR£SS.STRING(1..EXPRESS.STRING'LENGTH)) ); 

BEGIN 

RETURN C.OS.COLLECTION.qUERY 

(OS.COL,ELEMENT.ADDRESS,EXPRESSION.ADDRESS,DB,0,0); 

END OS.COLLECTION.QUERY; 

PRAGMA INLINE(OS.COLLECTION.QUERY); 


OS.COLLECTION; 

STRING; 

STRING; 

DATABASE) RETURN OS.COLLECTION IS 


FUNCTION C.OS.COLLECTION.QUERY.EXISTB(OS.COL : 

ELEMENT : 
EXPRESSION : 
DB : 

FILE.NAME : 
LINE.NUMBER: 
RETURN BOOLEAN; 


OS.COLLECTION; 
SYSTEM.ADDRESS; 
SYSTEM.ADDRESS; 
DATABASE; 

0S.INT32; 

0S.UHSIGNED.INT32) 


PRAGMA INTERFACED, C.OS.COLLECTION.QUERY.EXISTS); 

PRAGMA INTERFACE_NAHE(C.OS.COLLECTION_QUERY_EXISTS, 

C.SUBP.PREFIX ft "oa.collaction.qoary.axiats"); 


FUNCTION OS.COLLECTION.QUERY.EXISTS(OS.COL : OS.COLLECTION; 

ELEMENT.TYPE : STRING; 

EXPRESS.STRING : STRING; 

DB ; DATABASE) RETURN BOOLEAN IS 






C-30 




— THIS SAMPLE DEFAULT THAT THE FILE NAME AND LINE NUMBER ARE 0 

— FILE.NAME : INTEGER 0; 

— LINE.NUHBER : 0S_UNSIGN_INT32 0; 

ELEMENT.ADDRESS : SYSTEM.ADDRESS 

A.STRINGS.TO.C(A.STRINGS.TO.A(ELEHENT.TYPE(1..ELEHENT.TYPE’LENGTH))); 
EXPRESSION.ADDRESS : SYS/EM.ADDRESS :■ 

A.STRINGS.TO.C(A.STRINGS.T0_A(E1PRESS_STRING(1..EXPRESS.STRING’LENGTH))) 

BEGIN 

RETURN C.OS.CQLLECTION.QUERY.EXISTS 

(OS.COL.ELEMENT.ADDRESS,EXPRESSION.ADDRESS,DB,0,0); 

END OS.COLLECTION.QUERY.EXISTS; 

PRAGMA INLINE(OS.COLLECTION.QUERY.EXISTS); 


FUNCTION C_OS.COLLECTION_qUERY.PICK(OS.COL : 

ELEMENT 
EXPRESSION : 
OB 

FILE.NAME : 
LINE.NUHBER: 


OS.COLLECTION; 
SYSTEM.ADDRESS; 
SYSTEM.ADDRESS; 
DATABASE; 

0S.INT32; 

0S_UNSIGNED_INT32) 


RETURN U.TYPEPTR; 


PRAGMA INTERFACE(C, C.OS.COLLECnON.QUERY.PICK); 

PRAGMA INTERFACE.NAME CC.OS.COLLECTION.QUERY.PICK, 

C.SUBP.PREFIX k "os_coll*ction_query_pick M ); 

FUNCTION OS_COLLECTION_qUERY_PICX(OS_COL : OS.COLLECTION; 

ELEMENT.TYPE : STRING; 

EXPRESS.STRING : STRING; 

DB : DATABASE) RETURN U.TYPEPTR IS 

— THIS SAMPLE DEFAULT THAT THE FILE NAME AND LINE NUMBER ARE 0 

— FILE.NAME : INTEGER :» 0; 

— LINE.NUHBER : 0S.UNSIGN.INT32 0; 

ELEMENT.ADDRESS : SYSTEM.ADDRESS 

A.STRINGS.TO.C(A.STRINGS.TO.A(EIEMENT.TYPE(1..ELEHENT.TYPE'LENGTH))); 
EXPRESSION.ADDRESS : SYSTEM.ADDRESS ;• 

A.mI'RINGS . TO.C (A.STRINGS. TO.A(EXPRESS.STRINGCl.. EXPRESS.STRING * LENGTH) ) ); 


BEGIN 

RETURN C_OS.CCLLECTTON_qUERT.PICK 

(OS.COL,ELEMENT.ADDRESS,EXPRESSION.ADDRESS ,DB,0,0); 
END OS_COLLECTTON.qUERY.PICK; 

PRAGMA INLINECOS_COLLECTTON.qUERY.PICK); 


C-31 





procedure C_0S_C0LLECTI0N.UNI0N(0S_C0L_A : OS.COLLECTION; 

OS_COL_B : OS.COLLECTION); 

pragma INTERFACED, c.os.eollection.union); 
pragma INTERFACE.NAHE (c.os.eollection.union, 

C.SUBP.PREFIX ft "os_collection_union"); 


procedure OS_COLLECTION_UNION(OS_CO:._A : OS.COLLECTION; 

OS.COL.B : OS.COLLECTION) is 

begin 

C.OS.COLLECTIOH.UNIONCOS.CCL.A,OS.COL.B); 
end OS.COLLECTION.UNION; 
pragma IIXINE(OS.COLLECTION.UNIQN); 


— oe.cursora 


function C_OS_CURSQR_CREATE(OS_COLL : OS.COLLECTIOH; B:OS.BOOLEAH) 

return OS.CURSOR; 
pragma INTERFACED, c.oa.curaor.create); 
pragma INTERFACE_NAHE(c_oe_cursor_create, 

C.SUBP.PREFIX k "os.cursor.create"); 

function OS.CURSOR.CREATEDS.COLL : OS.COLLECTIOH) return OS.CORSOR is 

UPDATED : boolean :» false; 

begin 

return C_OS.CURSOR_CREATE(OS.COLL, B.TO.CSB(UPDATED)); 
end OS.CURSOR.CREATE; 
pragma IHLINE(OS.CURSOR.CREATE); 

procedure C_OS_CURSOR.DELETE(OS.CUR : OS.CURSOR); 
pragma INTERFACED, c.os.cursor.delete); 
pragma INTERFACE_NAME(c_os.cursor.delete, 

C.SUBP.PREFIX k "os.cursor.delete"); 
procedure OS.CURSOR.DELETECOS.CUR : OS.CURSOR) is 
begin 

C.OS.CURSOR.DELETE(OS.CUR); 
end OS.CURSOR.DELETE; 
pragma INLINE(OS.CURSOR.DELETE); 


function C_OS_CURSOR_FIRST(OS.CUR ; OS.CURSOR) return U.TTPEPTR; 
pragma IHTERFACE(C, c.os.cursor.first); 
pragma INTERFACE_NAME(c_os_cursor.first, 

C.SUBP.PREFIX k "os.cursor.first"); 
function 0S_CURS0R_FIRST(0S_CUR : OS.CURSOR) return U.TTPEPTR is 
begin 

return C_OS_CURSOR_FIRST(OS_CUR); 
end OS.CURSOR.FIRST; 


C-32 










\ 


j.ragma INLINE(OS.CORSOR.FIRST); 


function C.OS.CORSOR.KQRECOS.CUR : OS.CURSOR) return BOOLEAN; 
pragma INTERFACED, c_oe_cursor_nsore); 
pragma INTERFACE_NANE(c_oe_cur»or_more, 

C.SOBP.PREFIX k M oa_cursor_more"); 
function 0S_CURS0R_M0R£(0S_CUR : OS.CORSOR) roturn boolean id 
begin 

return C.OS.CORSOR.MORECOS.COR); 
end OS.CORSOR.MORE; 
pragma INLINE(OS.CURSOR.HORE); 


function C_0S_C0RS0R_NEXT(0S_CUR : OS.CURSOR) return U.TYPEPTR; 
pragma IRTERFACE(C, c_oe.cursor.next); 
pragma INTERFAC£_NAMS(e_os_cursor_nert, 

C.SUBP.PREFIX It "os.cursor .next"); 

function OS_CURSOR_NEXT(OS_OTR : OS.CORSOR) return O.TYPEPTR is 
begin 

return C.OS_CURSOR.NEXT(OS.CUR); 
end OS_CURSOn_NEXT; 
pragma INLINECOS.CORSOR.NEXT); 

end OS_COLLECTION.PKa; 






C.10 Interface Program: os.cur. a 


— Basic cursor interface to ObjectStore from the Ada programming 

— language prototype implementation by Li Chou 


with OSTORE; use OSTORE; 
with OS.TYPES; use OS.TYPES; 
generic 

typa U.TYPE is private; 

typa U.TYPEPTR is accass U.TYPE; 

package OS.CURSOR.PKG is 
— cursor's functions 

function OS.CURSOR.CREATRCOS.COLL : OS.COLLECTIDH; 

UPDATED : BOOLEAN :» falsa ) return OS.CURSOR; 

procedure OS_CURSOR_COPY(OS_CUR_A : OS.CURSOR; 

OS.CUR.B : OS.CURSOR); 


procedure OS_CURSOR_DELETE(OS_CUR : OS.CURSOR); 

function 0S_CURS0R_FIRST(0S_CUR : OS.CURSOR) return U.TYPEPTR; 

procedure OS_CURSOR_INSERT_AFTER<OS.COL : OS.CURSOR; 

VALUE s U.TYPEPTR); 

procedure OS.CURSOR.INSERT.BEFORE(OS.COL : OS.CURSOR; 

VALUE : U.TYPEPTR); 

function OS_CURSOR_LAST(OS_CUR : OS.CURSOR) return U.TYPEPTR; 
function OS_CURSOR_hORE(OS_CUR : OS.CURSOR) return BOOLEAN; 
function OS_CURSOR_NEXT(OS_CUR : OS.CURSOR) return U.TYPEPTR; 
function 0S_CURS0R_NULL(0S_CUR : OS.CURSOR) return boolean; 
function OS.CURSOR.PREVIOUS(OS.CUR : OS.CURSOR) return U.TYPEPTR; 
procedure OS_CURSOR.REHOVE_AT(OS_CUR : OS.CURSOR); 
function OS_CURSOR_RETRIEYE(OS_CUR : OS.CURSOR) return U.TYPEPTR; 
function OS_CURSOR_VALID(OS_CUR : OS.CURSOR) return boolean; 
end OS.CURSOR.PKO; 


C-34 










C.ll Interface Program: os.cur.b.a 

-- Basic collection interface to ObjectStore from the Ida programming 
-- language prototype implementation by Li Chou 

with LANGUAGE; use LANGUAGE; 
with OSTORE; use 0STORE; 
with OS.TYPES; use OS.TYPES; 

package body OS.CURSOR.PKG is 



procedure C_0S_CURS0R_C0PY<0S_CUR_A : OS.CURSOR; 

OS.CUR.B ; OS.CURSOR); 
pragma INTERFACECC, c_os_cursor_copy); 
pragma INTERFACE_NAME(c_os_cursor_copy, 

C.SUBP.PREFIX k "os.cursor.copy"); 
procedure 0S_CURS0R_C0PY(0S_CUR_A : OS.CURSOR; 

OS.CUR.B : OS.CURSOR) is 

begin 

C_OS.CURSOR.COPY(OS.CUR.A, OS.CUR.B); 
end 0S.CURS0R.C0PY; 
pragma IHLINE(OS.CURSOR.COPY); 


procedure C_OS_CURSOR_DELETE(OS_CUR : OS.CURSOR); 
pragma INTERFACECC, c.os.cursor.delete); 
pragma INTERFACE.MAMECc.os.curser.delete, 

C.SUBP.PREFIX A "os.cursor.delete"); 
procedure OS_CURSOR_DELETE(OS_CUR : OS.CURSOR) is 
begin 

C.OS.CURSOR J5ELETE(OS.CUR); 
end OS.CURSOR.DELETE; 











pragma INLINE(OS.CURSOR.DELETE); 


function C_OS.CURSOR_FIRSTDS.CUR : OS.CURSOR) return U.TYPEPTR; 
pragma INTERFACED, c_oa_cursor_first); 
pragma INTERFACE_NAKE(c_os_cursor_firat, 

C_S03P.PREFIX * "oa.curaor.first”); 
function OS.CURSOR.FIRSTDS.CUR : OS.CURSOR) return U.TYPEPTR ia 
begin 

return C.OS.CURSOR.FIRST(OS.CUR); 
end OS.CURSOR.FIRST; 
pragma INLINE(OS.CURSOR.FIRST); 


procedure C.OS.CURSOR.INSERT.AFTER(OS.COL : OS.CURSOR; 

VALUE : U.TYPEPTR); 

pragma INTERFACED, c.oa.curaor.inaert.after); 
pragma INTERFACE_NAHE(c_oa_curcor.insert.after, 

C.SUBP.PREFIX k "oa.curaor.inaert.after"); 

procedure OS_CURSOR_INSERT.AFTER(OS.COL : OS.CURSOR; 

VALUE : U.TYPEPTR) ia 

begin 

C_OS_CURSOR_INSERT_AFT£R(OS_COL,VALUE); 
end OS.CURSOR.INSERT.AFTER; 
pragma INLINE(OS.CURSOR.INSERT.AFTER); 


procedure C_0S_CURS0R_INSERT.BEF0REC0S.C0L : OS.CURSOR; 

VALUE : U.TYPEPTR); 

pragma INTERFACED, c.oa.curaor.inaert.before); 
pragma INTERFACE_HAME(c_oa_cursor_insert.before, 

C.SUBP.PREFIX k "os.curaor.inaert.before"); 

procedure OS.CURSOR_INSERT_BEFORECCS.COL : OS.CURSOR; 

VALUE : U.TYPEPTR) ia 

begin 

C.OS.CURSOR.INSERT.BEFOREDS.COL, VALUE); 
end OS.CURSOR.INSERT.BEFORE; 
pragma INLINE(OS_CURSOR_INSERT_BEFORE); 


function C_03_CURS0R_LAST(0S_CUR : OS.CURSOR) return U.TYPEPTR; 
pragma IHTERFACECC, c.os.curaor.last); 
pragma INTERFACE_NAME(c_oa_cursor_laat, 

C.SUBP.PREFIX k "oa.curaor.laat"); 
function OS.CURSOR.LASTCOS.CUR : OS.CURSOR) return U.TYPEPTR ia 
begin 

return C.OS.CURSOR.LAST(OS.CUR); 
end OS.CURSOR.LAST; 
pragma INLINE(OS.CURSOR.UST); 


C-36 



iv2t£.> t ,-.v> ■. ** jc-u - »*A. -v 















.C-■ - ^wdiauiiCwJtafc;*i4ifc^a<*?«3*Ab5P 


function C_0S_CURSCR_H0RE(0S_CUR : OS.CURSOR) return BOOLEAN; 
pragma INTERPACE(C, c_oa.cursor.mora); 
pragma INTERFACE_NAME(c_oa_curaor_mort, 

C.SUBP.PREFIX ft "oa.curaor.mora"); 
function OS.CURSOR.MORE(OS.CUR : OS.CURSOR) ratum boolaan ia 
bagin 

raturn C_OS_CURSOR_KORE(OS.CUR)j 
and OS.CURSOR.KORE; 
pragma INLINE(OS_CURSOR_KORE); 


function C_OS_CURSOR_NEXT(OS_CUR : OS.CURSOR) raturn U.TYPEPTR; 
pragma INTERFACED, c.os.curaor.naxt); 
pragma INTERFACE_NAME(c_OB_curaor_ntxt, 

C.SUBP.PREFIX k "oe.curaor.nart"); 


function OS_CURSOR.NEXKOS.CUR : 
bagin 

ratum C.OS.CURSOR.NEXT(OS.CUR); 
and OS.CURSOR.NEXT; 
pragma INLINE(OS.CURSOR.NEXT); 


OS.CURSOR) ratum U.TYPEPTR la 


function C.OS.CURSOR.NULL(OS.CUR : OS.CURSOR) ratum BOOLEAN; 
pragma INTERFACED, c.oa.curaor.null); 
pragma INTERFACE_NAME(c_oa_curaor_null, 

C.SUBP.PREPIX k "oa.curaor.null"); 
function OS.CURSOR.NULL(OS.CUR : OS.CURSOR) ratum boolaan ia 
bagin 

ratum C_0S_CURS0R.NULL(03_CUR); 
and OS.CURSOR.NULL; 
pragma INLINE(OS.CURSOR.NULL); 


function C.OS.CURSOR.PREVIOUS(OS.CUR ; OS.CURSOR) ratum U.TYPEPTR; 
pragma INTERFACE(C, c.oa.curaor.prarioua); 
pragma INTERFACE_NAME(c.oa_curaor.prtrloua, 

C.SUBP.PREPIX ft "oa.curaor.prayioua"); 
function 0S.CUR3CR.PREVI0US(OS.CUR : OS.CURSOR) ratum U.TYPEPTR ia 
bagin 

ratum C.OS.CURSOR.PREVIOUS(OS.CUR); 
and OS.CURSOR.PREVIOUS; 
pragma INLINE(OS.CURSOR.PREVIOUS); 


proeadura C.OS.CURSOR.REMOVE.AT(OS..CUR i OS.CURSOR); 
pragma INTERPACE(C, c.oa.curaor.ramova.at); 
pragma INTERFACE_NAME(c_oa.curaor.raaova.at, 

C.SUBP.PREPIX ft "oa.curaor.remova.at”); 
















^Lyir.i« V,v ~-V I 




•W * " I| '»-I'»ili« 

'.•':X-~ fV>l(iv, AixZifF.'s 


A t* &&SW&A5 i$Ae - 


«WP!PipjPJPW!P«PP*P!H! 


procedure OS.CURSOR.REHOVE.AT(OS.CUR : OS.CURSOR) is 

begin 

C.OS.CURSOR.REMOVE.ATDS.aft)i 
•ad OS.arRSOR_REMOVE.AT; 
pragma INLINE(OS_CURSOR_R£MOVE_AT); 


function C.OS.CURSOR.RETTIEVEDS.CUR ; OS.CURSOR) return U.TTPEPTR; 
pragma INTERFACED, c.oa.cureor.retrieve); 
pragma INTERFACE.NAKECc.os.curuor.retrieve, 

C.SUBP.PREFIX * "os.curaor.retrieve"); 
function O5_CURS0R_RETRXEYE(OS_CJR : OS.CURSOR) return U.TYPEPTR is 
begin 

return C.OS.CURSOR.RmiEVE(OS.CUR); 
end OS.CURSOR.RETRIEVE; 
pragma INLINE (OS.CURSQR.RETRIi'VE); 


function C.OS.CURSOR.VALIO(OS.CUR : OS.CURSOR) return BOOLEAN; 
pragma INTERFACED, c.oa.curaor.valid); 
pragma INTERFACE.NAMEfc.oa.curaor.valid, 

C.SUBP.PREFIX A "oe.cureor.valid"); 
function OS.CURSOR.VALID(03.CUR : OS.CURSOR) return boolean ia 
begin 

return C.OS.CURSOR.VALID(OS.CUR); 
end OS.CURSOR.VALID; 
pragma INLINE(OS.CURSOR.VALID); 

•nd OS.CURSOR.PKO; 




C-38 



/ 





C.lt Interface Program: except.a 
—Erceptions tor ObjectStere/Ada interface. 

— Buie interface to ObjectStore from tha Ada programming language 

— Prototype design and implamantation by Dava Rosenberg of Object 

— Design, Inc. 

with SYSTEM; use SYSTEM; 
with LANGUAGE; use LANGUAGE; 
with OS.TYPES; usa OS.TYPES; 
package OS.EXCEPTIONS is 

LAST.EXCEPTION: constant INTEGER :« 0; 

subtype OS.EXCEPTION.INDEX is 0S.INT32 range 0 .. LAST.EXCEPTION; 
procedure OS.ADA.EXCEPTJONCERR: OS.EICEPTION.INDEI); 
pragma EXTERNAL_NAME(OS_ADA_EXCEPTION, 

C.SUBP.PREFIX * "os.ada.exception"); 

ERR_ADDRESS.SPACE.FULL: EXCEPTION; 


end OS.EXCEPTIONS; 


C-39 











■ in- .pjFjiwpm 1 


*mm>*im**w ' . ' . ' ^ u r i .j B8pppfw iww ^p yp, . _. 




C.1S Interface Program: except.b.a 
—Exceptions for ObjectStore/Ada interface. 

— Basic interface to ObjectStore from the Ada programming language 

— Prototype design and implementation by Dave Rosenberg of Object 

— Design, Inc. 

package body OS.EXCEPTIONS is 

procedure OS_ADA_EXCEPTION(ERR: OS.EXCEPTION.IKDEX) is 
begin 

case ERR is 

when 0 «> raise ERR.ADDRESS_SPACE.FULL; 
when others •> null; 
end case; 

end OS.ADA.EXCEPTION; 
end OS.EXCEPTIONS; 


C-40 





Bibliography 

1. Ada Joint Porgram Office, DoD. Ada Reference Manual, ANJI/MIL-STD-1815A, January 
1983. 

2. Atkinson, M. P., et al. “An Approach to Persistent Programming,” The Computer Journal, 
£d(4):360-365 (1983). 

3. Atkinson, M. P., et al. Data Types and Persistence. Berlin: Springer-Verlag, 1988. 

4. AT&T. Unix System V AT&T C++ Language System, 1989. selected Code 307-144. 

5. Berre, Arne J. and T. Lougenia Anderson. “The HyperModel Benchmark for Evaluating 
Object-Oriented Databases.” Object-Oriented Databases with Applications to CASE, Networks, 
and VLSI CAD chapter 5, 75-91, Englewood Cliffs, NJ: Prentice-Hall, Inc., 1991. 

6. Booch, Grady. Software Engineering with Ada. Benjamin/Cummings Publishing Company, 
Inc., 1986. 

7. Booch, Grady. Object Oriented Design with applications. Benjamin/Cummings Publishing 
Company, Inc., 1991. 

8. Cardelli, Luca and David MacQueen. “Persistence and Type Abstraction.” Data Types and 
Persistence edited by M. P. Atkinson, et al., Berlin: Springer-Verlag, 1988. 

9. Cattel, R.G.G. “Object-Oriented DBMS Performance Measurement.” Proceedings of the 2nd 
Workshop on OODBS. 364-367. 1988. 

10. Harper, Robert. “Modules and Persistence in Standart ML.” Data Types and Persistence 
edited by M. P. Atkinson, et al., Berlin: Springer-Verlag, 1988. 

11. Jacobs, Captain Timothy M. An Object-Oriented Database Implementation of The Magic 
VSLI Layout Design System. MS thesis, School of Engineering, Air Force Institute of Tech¬ 
nology, Wright-Patterson AFB OH, December 1991. 

12. Johnson, Eric F. and Kevin Reichard. “The X window Application Programming,” Portland: 
MIS Press (1989). 

13. Klabunde, Gary Wayne. An Animated Graphical Postprocessor for the Saber Wargame. MS 
thesis, AFIT/GCS/ENG/91D-10, School of Engineering, Air Force Institute of Technology, 
Wright-Patterson AFB OH, December 1991. 

14. Lamb, Charles, et al. “The ObjectStore Database System,” Communications of the ACM, 
34(10):5O-64 (1989). 

15. Leopold, Vince. “Object-Oriented Programming in Ada, A Viable Method,” IEEE, NAECON 
89’, 2:549-552 (1989). 

16. Neville, Donna and Dit Morse. Pro*Ada User’s Guide. Oracle Corporation, November 1986. 

17. Object Design, Inc., Burlington, Massachusetts. ObjectStore User Guide (1.1 Edition), 1991. 

18. Rosenberg, Dave. ObjectStore and Ada. Object Design, Inc., Burlington, Massachusetts, 
January 1992. 

19. Rumbaugh, James, et al. Object-Oriented Modeling and Design. Prentice Hall, 1991. 

20. Scheifler, Robert W. and Gettys Jim. “The X window system,” ACM Transaction on Graphics, 
5:79-109 (April 1986). 

21. Schonberg, Edmond. “Contrasts : Ada 9X and C++,” CrossTalk (September 1992). 


BIB-1 










*z2U&isJv£a j& « ; •■ « ' . ■ '■ .'az*&iitkl ii«5s3 


22. Thatte, Satish. “Persistent Memory: Merging Al-knowledge and Databases.” Readings in 
Object Oriented Database Systems edited by Stanley B. Zdonik and David Maier, 242-250, 
Morgan Kaufmann Publishers, 1990. 

23. Unisys Corporation, 12010 Sunrise Valley Drive. Ada Interfaces to X Window System , March 
1989. Contract No. F19628-88-D-0031. 

24. Verdix Corporation. Verdix Ada Development System, 1991. 



BIB-2 



Vita 


Lt Col Li Chou (ROCAF, Taiwan) was born on 28 October 1957 in I-Lan, Taiwan, Republic 
of China. He graduated from high school in I-Lan in June, 1975. He then entered the National 
Defense Medical Center from which he graduated in 1980 with a Bachelor Degree in Pharmacy 
and a commission as a Lieutenant in the Republic of China Air Force (ROCAF). His first duty 
assignment was at the Fifth Medical Corps, Tau-Yan, Taiwan as a pharmacy officer. In early 1983 
he transferred to the 816th Regional Hospital as a pharmacy officer. He received his promotion to 
Captain in August, 1983. In the middle of 1984 he relocated to the Surgeon General, Headquarters, 
ROCAF, and joined the Medical Administration Staff. While there, he entered Central University 
for a training course in Computer Science in August, 1987. He got his promotion to Major during his 
training, in January 1988. He entered the School of Engineering, Air Force Institute of Technology 
in May, 1991. During his staying here, he received his promotion to Lt Col in January, 1992. 


Permanent address: 4F, No. 15-2, Ln 89, Shih-Tong Rd, 
Shih-Ling, Taipei, Taiwan, R.O.C. 


VITA-1 





REPORT DOCUMENTATION PAGE 


Form Approved 
OMB No. 0704-0188 


l 


Public reporting burden tor this collection of information estimated to average t hour per response, including the time for reviewing instructions, searching existing data sources, 
gathering and maintaining the data needed, and completing and reviewing the collection of information Send comments regarding this burden estimate or any other aspect of this 
collection of information, including suggestions for r«»ducing this burden to Washington He'douarters Services. Directorate for information Operations and Repons. 12 IS lefferson 
Davis Highway, Suite 12C4. Arlington, va 22202-4302. ard to the Office of Management and Budget. Paperwork Reduction Project (0704-0188). Washington. DC 20503 

1. AGENCY USE ONLY (Leave blank) 2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 

March 1993 Master’s Thesis 

4. TITLE AND SUBTITLE 

O IJECT-ORIENTED DATABASE ACCESS FROM ADA 

5. FUNDING NUMBERS 

6. AUTHOR(S) 

Li Chou 

7. PERFORMING ORGANIZATION NAM£(S) AND ADDRESS(ES) 

Air Force Institute of Technology, WPAFB OH 45433-6583 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

AFIT/GCS/ENG/93M-01 

9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Capt Phil Lienert 

ASD/RWWW Wright-Patterson AFB, OH 45433 x53969 

Mr. Joseph V. Giordano 

Rome Laboratory RL/C3AB, Griffiss AFB, NY 13441-5700 (DSN) 587-2805 

10. SPONSORING/MONITORING 

AGENCY REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

12a. DISTRIBUTION /AVAILABILITY STATEMENT 

Distribution Unlimited 

12b. DISTRIBUTION CODE 

13. ABSTRACT (Maximum 200 words) 

Ada embodies many modern software engineering principles, namely, modifiability, efficiency, reliability, and 
cnderstandability. Its powerful data abstraction allows programmers to easily model objects in the real world. 

A database management system (DBMS) provides long term storage. It provides a convenient and efficient 
environment to manipulate data. Currently, with Ada access to a DBMS is typically done through the use of 
a language extension and a preprocessor to convert the extensions to library calls appropriate for the DBMS. 
However, these systems are limited on more complex applications, such as computer-aided engineering design. 
Object-oriented design (OOD) is a new way of thinking about problems using models organized around real- 
woild concepts. Object-oriented database management systems (OODBMS), include most benefits of relational 
DBMS (RDBMS) and, in addition, provide the capability to manipulate complex, heterogeneous data. Ob- 
jectSiore is an OODBMS. This thesis describes an interface from Ada to ObjectStore which could fulfill the 
requirements of complex applications. Our Ada/ObjectStore interface performed better in CPU time than the 
supplied C/ObjectStore interface. However, overall there is not much difference between Ada/ObjectStore and 
C/ObjectStore. It is clear that Ada/ObjectStore provides the capability of data persistence to Ada. This 
result favorably affects program length, program development time, program maintainability, and application 
reliability. 

14. SUBJECT TERMS 

Ada, C, Object-oriented database management system, ObjectStore 

15. NUMBER OF PA6ES 

fSg 

16. PRICE CODE 

17. SECURITY CLASSIFICATION 

OF REPORT 

UNCLASSIFIED 

18. SECURITY CLASSIFICATION 

OF THIS PAGE 

UNCLASSIFIED 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFIED 

20. LIMITATION OF ABSTRACT 

UL 


NSN 7540-01-280-5500 Standard Form 298 (Rev 2-89) . 


Prnentwd by ANSI Std 239-18 


298-102 

























GENERAL INSTRUCTIONS FOR COMPLETING SF 298 


The Report Documentation Page (RDP) is used in announcing and cataloging reports. It is important 
that this information be consistent with the rest of the report, particularly the cover and title page. 
Instructions for filling in each block of the form follow It is important to stay within the lines to meet 
optical scanning requirements. 


Block 1. Agency Use Only (Lea\’e blank) . 

Block 2. Report Date . Full publication date 
including day, month, and year, if available (e.g. 1 
Jan 88). Must cite at least the year. 

Block 3. Type of Report and Dates Covered . 
State whether report is interim, final, etc. If 
applicable, enter inclusive report dates (e.g. 10 
Jun 87 - 30 Jun 88). 

Block 4. Title and Subtitle . A title is taken from 
the part of the report that provides the most 
meaningful and complete information. When a 
report is prepared in more than one volume, 
repeat the primary title, add volume number, and 
include subtitle for the specific volume. On 
classified documents enter the title classification 
in parentheses. 

Block 5. Funding Numbers . To include contract 
and grant numbers; may include program 
element number(s), project number(s), task 
number(s), and work unit number(s). Use the 
following labels: 


C - 

Contract 

PR - 

Project 

G - 

Grant 

TA - 

Task 

PE - 

Program 

WU - 

Work Unit 


Element 


Accession No. 


Block 6. Author(s) . Name(s) of person(s) 
responsible for writing the report, performing 
the research, or credited with the content of the 
report. If editor or compiler, this should follow 
the name(s). 

Block 7. Performing Organization Name(s) and 
Address(es) . Self-explanatory. 

\ 

Blpck 8. Performing Organization Report 
Nuimber . Enter the unioue alphanumeric report 
number(s) assigned by the organization 
performing the report. 


Soonsormg/Monitonnq Ag 
Jress(es) . Self-explanatory. 


Block 9 


Block 10. Sponsorinq/Monitorinq Agency 
Report Number . (If known) 

Block 11. Supplementary Notes . Enter 
information not included elsewhere such as: 
Prepared in cooperation with...; Trans, of...; To be 
published in.... When a report is revised, include 
a statement whether the new report supersedes 
or supplements the older report. 


♦ ij S GPO 1990-0 273.271 


Block 12a. Distribution/Availabilitv Statement . 
Denotes public availability or limitations. Cite any 
availability to the public. Enter additional 
limitations or special markings in all capitals (e.g. 
NOFORN, REL, ITAR). 


See DoDD 5230.24, "Distribution 
Statements on Technical 
Documents." 

See authorities. 

See Handbook NHB 2200.2. 

Leave blank. 


DOE 

NASA 

NTIS 


Block 12b. Distribution Code. 


- Leave blank. 


NASA- 
NTIS - 


Enter DOE distribution categories 
from the Standard Distribution for 
Unclassified Scientific and Technical 
Reports. 

Leave blank. 

Leave blank. 


Block 13. Abstract . Include a brief (Maximum 
20O words) factual summary of the most 
significant information contained in the report. 


Block 14. Subject Terms . Keywords or phrases 
identifying major subjects in the report. 

Block 15. Number of Pages . Enter the total 
number of pages. 

Block 16. Price Code . Enter appropriate price 
code (NTIS only). 


Blocks 17.-19. Security Classifications . Se!f- 
explanatory. Enter U.5. Security Classification in 
accordance with U.S. Security Regulations (i.e., 
UNCLASSIFIED). If form contains classified 
information, stamp classification on the top and 
bottom of the page. 

Block 20. Limitation of Abstract , ‘ihis block must 
be completed to assign a limitation to the 
abstract. Enter either UL (unlimited) or SAR (same 
as report). An entry in this block is necessary if 
the abstract is to be limited. If blank, the abstract 
is assumed to be unlimited. 

Standard Form 298 Back (Rev. 2-89) 


















