S05I9SDA 



SOFTWARE ENGINEERING IN Ada 

Presented by: Capt David Vega 

3390th Technical Training Group 
Keesler Air Force Base, MS 

Sponsored by: Ada Joint Program Office (OSD) 

Organized by: Herbert E. Cohen 

US Army Materiel Systems 
Analysis Activity 
Aberdeen Proving Ground, 

Maryland 

1 BTIC qVAUTY IKSPECTE© ^ 


U. S. ARMY MATERIEL SYSTEMS ANALYSIS ACTIVITY 

AKROEtN nO/ING GROUND, MARYLAND 





DKClilMEI NOTICI 



THIS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FURNISHED TO DTIC CONTAINH) 
A SIGNinCANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 






la. REPORT security CLASSIFICATION 

lassifled 


URiTY CLASSIFICATION AUTHORITY 


2b. DECLASSIFICATION/OOWNGRAOING SCHEDULE 


4 PERFORMING ORGANIZATION REPORT NUMBER(S) 


REPORT OOCUMENTATtON PAGE 


lb RESTRICTIVE MARKINGS 


formAppwtd 
OMB No. 0704-C1BB 


3. DISTRIBUTION/AVAILABILITY OF REPORT 

Unlimited 


5. MONITORING ORGANIZATION REPORT NUM6ER(S) 


Ba. NAME OF PERFORMING ORGANIZATION 

«AMSAA 


6c ADDRESS {City. Start, snttllBCodo) 

.'f,Aberdeen Proving Ground, MD 21005-5071 


7a. NAME OF MONITORING ORGANIZATION 

Same as 6 


7b. ADDRESS (CMy, Start, and Z'P Cede; 


6a NAME OF FUNDING/SPONSORING 
ORGANIZATION 

Ada Joint Program Office (OSD) 


8c ADDRESS (C/ty. Statt.snd Z/PCodtJ 

The Pentagon 

Washington, D.C. 20301-3081 


11 title (includa Soturrty a»uifk»tion) 

Software Engineering In Ada (u). 


RSONAL AUTHOR(S) 

ohen (Organizer) 


PE OF REPORT 

' Final 


16. supplementary NOTATION 


13b TIME COVERED 
FROM_TO 


8b. OFFICE SYMBOL I 9. PROCUREMENT INSTRUMENT IDENTIFICATION NUMBER 
(If applkablo) I 


10 SOURCE OF FUNDING NUMBERS 


PROGRAM 


1 PROJECT 

TASK 

INO. 

NO. 



14. DATE OF REPORT (Ytar,Month,Day) IIS. PACE COUNT 

88/03/22 I 331 


COSATI CODES 


CROUP SUB-GROUP 


IB. SUBJECT TERMS (ContJnwt on rtvtnt if nteotsoiy and kfontify by bfotk numbtr) 
Fundeaentals in Ada, types, control structures, sub 
programs, packages, exceptions, generics, tasks, 
program design 


19. ABSTRACT (Cantimio on rtvtnt if notosury and idonOfy by bSock numbor) 

Provides a detailed course in Software Engineering in Ada. 


95-01574 


DTTC QUALITY INSPECTBD ft 


20. DISTRIBUTION/availability OF ABSTRACT 21. ABSTRACT SECURITY CLASSIFICATION 

. JI ^classified/unlimited □ SAME as rpt. □ OTIC users Unclassified 
T HpiMrOF RESPONSIBLE INDIVIDUAL . 22b. TELEPHONE (McJwdt A/ta CodtJ | ZeT*OFFICE SYMBOL 

^Herbert F. Cohen 


DD Form 1473, JUN 86 


301) 278-2785/6577 


PrtvJO(Mt<S'tionfar*obsoJttt. SECt 




SECURITY CLASSIFICATION OF THIS 

Unclassified 





































ACKNOWLEDGEMENTS 


! would like to take this opportunity in behalf of the Ada Joint Program 
Office (OSD) and the US Army Materiel Systems Analysis Activity (AMSAA) to 
express my deep appreciation to CPT David Vega of the 3390th Technical 
Training Group, Keesler Air Force Base, Mississippi for arr outstanding lecture 
series in software engineering. Mr. Lou Puckett of the 3300th Technical 
Training Wing and CPT William Frey of the 3390th Technical Training Group at 
Kessler AFB provided invaluable assistance in coordinating this program'for 
which I am also deeply indebted. The producer/director of the video production, 
Mr. Jim Blum of DetZ, 1365 AV at Keesler AFB, did an outstanding professional 
job. 


The road to final production of these tapes was long and hard but it 
could not have been achieved without the support pf two distinguished officers 
from the Ada Joint Program Office (OSD). My very sincere appreciation is 
extended to LTC(P) David Taylor and MAJ Allen Kopp (AF) of the AJPO (OSD) for 
their support and wish them the very best in their future assignments. 


Herbert E. Cohen 

US Army Materiel Systems Analysis 
Activity 

Aberdeen Proving Ground, MD 


AooeBSlOKI fop ’’n 

HTIS OBAkl 
PTIC TM 
Unannounoed 
Justlfloatio 

□ 

□ 


Rw 

Dlstj;’ibutlon/ 

availability Codes 

list 

Avail 

Speo 

and/or 1 

Lai. 






REQUEST FOR VIDEO TAPES AND TEXT 


1. DOD and other government agencies may obtain copies of tapes and text 
through the nearest local Training and Audio Visual Support Center. 

2. Reference tapes by SAV PIN# 505195. 

3. Army/Navy and other government agencies should request tapes by writing: 

Department of the An:\y 

US Army Visual Information Center 

Joint Visual Information Activity 

ATTN: ASNV-OJVP-CM 

Tobyhanna Army Depot, PA 18466-5102 

. . " PHONE: - f7uj-^90-7063 

•‘4. Air Forcr activities* can request, tapes by writing: 

‘ AFCVIL ' 

1352nd AVS/OOSQ 
Bldg 1248 

Norton AFB. CA 92409-5996 

5. Tapes will be tn standard DOD 3/4 Inch video cassette; however, 1/2 Inch 
VHS formats may also be available on request. 

6. The general public can obtain tapes at minimal cost. In any of the formats 
specified above, by writing to: 

National Audio Visual Center 
GSA 

ATTN: Order Section 
Washington, DC 20409 

7. For additional information, contact: 

Ada Joint Program Office 
Rm 3E114 
The Pentagon 

Washington, DC 20301-3081 

PHONE: (202) 694-0210 
AUTOVON 224-0210 


or 


01 rector 

US Army Materiel Systems Analysis Activity 
ATTN: AMXSY-MP (Herbert Cohen) 

Aberdeen Proving Ground, MD 21005-5071 


PHONE: (301) 278-2785/6577 
AUTOVON 298-2785/6577 



LECTURER 


CRT David Vega 

3390th Technical Training Group 
Keesler Air Force Base, MS 





TEXT 


Text No. 1. Fundamentals of Ada Programming/Software Engineering 
(Note-tasking Guide) • 90P-890 

Text No. 2. Fundamentals of Ada Programming/Software Engineering 
(Study Guide/Workbook) - 90P-893 

Text No. 3. Object Oriented Design • 90P-886 


I 





HANDOUT 90P-890 



October 1987 



USAKTFX'HNICAL TRAINING SCHOOL 
339<I I'ichnical Trainiii}! (»roup 

I Keesler Air Force Base, Mississippi 39S34>5UOU 


Authorizod for ATC Course Use 

DO NOT USE ON THE JOB 


ATC rvm ai4 JAn M 


aaiTiAHa arc 


tTAMOAMP CaVtMMIT 



339() Ti.'chnical 1'rjinin|! Group 
Kcolcr AFU. Mississippi 395.^5000 



HO 90P-H'iKl 
K30AR49241XM 
WOST4924 020 
IX'cenibcr l‘J87 

NOTK-TAKINC; (iUIDK 
PbiluMtphy 


The philosophy ol' the Win)! emerges from a liccp ciwcuni Uv iiKlivuiual Air Ttircc nivn anil women anil the neevJ to pros iJe hi^'h 
ly trained and motivated penurnncl to austain the mission of the Air Force We helieve the uhilitics. worth, scll-respect. and die 
nity of c&ch student must be fully i«co||ni/«tl. We helieve each must he peovided the ofponunity to pursue and master an occu- 
' pational specialty to the full extent of the iiKlividual's capabilities and aspirations for the immediate and continuing heiietit of the 
individual, the Air Foroe. DOD. and the country. To these ends, we provide opporiunilies for individual development ul initi.il 
technical proficiencies, on>thc-job training in ehallengin]! job assignnK'nis. and follow-on growth us supers isors in support oi 
this individual development, and to facilitate maximum growth of its siudcnls. the Wing encourages and supports the piotession- 
a> development of its faculty and administrators, and actively pnanotes inmoalion through research ami the sharing of concepi > 
and material with other cducutiunul institutions. 

Contents 

Chapivr f Ilk Pnvi' 


I Fcndainentals of Ada Systems 


Soltwarc liiiginccring . I I 

Ada language Features. . . . I -'' 

Ad.i Piograiii Library . .I O' 

Simple Control Structures.. . . .l-,^2 



.■! Control Structures 

Scmeiured Programming . 

Sequential . 

Conditional . 

Ilcraiive . 


'-I 

30 

3-5 

3-7 


4 Subprograms 

Purpose . 4-1 

Procedures.— 4-1 

FutK'tions . 4-h 


5 . Packages 

Purpose . 5-1 

Specification . .5-4 

Bmly . 5-5 

Private Tyjitfs. 5-7 

Applications ol Packages ... . ..5-11 




I 














































6. Except itms 

Purpose .. 

Oeoienng Exceptions 
Exception Handlers . 
Kitising Exceptions .. 
Pntpugulion. 




6-4 

(>-4 


65 


7. Qenerics 

Purpuec . 

Generic Dcclaniiiuns. 

Generic Intaanlialions. 

Generic Panimeicrs . 

Generic Ktmtiiil Purameters 
Generic Bodies. 


7-1 I 

7-4 . .-! 

7-i 

'■5 • i 

7-7 

7.d ' 


Tasks 

Purpose . 

Independent Tusks.... 
Coinmunicutinp Tasks 
Taskin)! SiuieiiKnts .. 


M-t 

h-i 

8-5 

M-ll 





















student Notes: 



FUNDAMENTALS OF Ada SYSTEMS 


e Software Engineering 

• Ada Language Features 

e Program Library 

e Simple Control Structures 

« Simple Input/Output 

e Host Computer Operations 


F-1 


SOFTWARE ENGINEERING 
THE CRITICALITY OF SOFTWARE 



Hardware is no longer tne dominant factor in the 
hardware/software relationship 

~ Cost 

Technology 

The demand for software is rising exponentially 
The cost of software is rising exponentially 
Software maintenance is the dominant software activity 
Systems are getting more complex 
Life and property are dependent on software 


F-2 


CHARACTERISTICS OF C'D SOFTWARE 

• Expensive 

• Incorrect 

• Unreliable 

• Difficult to predict 

• Unmaintainable 

4 

— • Not reusable 

CiO 

FurMtamontats of Ada Systems VI 




student Notvt; 


FACTORS AFFECTING DOD SOFTWARE 

• Ifinorancs ot lit* cycle inipiications 

p 4 • Lack of standards 

• lack ol methodologies 

• Inadequate support tools 

• Management 

• Software professionats 


CHARACTERISTICS OF DOD 
SOFTWARE REQUIREMENTS 

• Large 

• Complex 

• Long lived 

• High reliapility 

• Time constraints 
a Sue constraints 


THE FUNDAMENTAL PROBLEM 

• Cur inability to manage the COMPLEXITV ot our software 
lyatams (G. Booch) 

• Lack ol a discipiiiad, anginaering approach 


1 *2 Fundaimintala of Ada Systama 






Studcmt Notes: 



SOFTWARE ENGINEERING 

THE ESTABLISHMENT AND APPLICATION OF SOUND ENGINEERING «> 


• Environments 


3 


• Tools 


• Methodologies 
• Models 


• ■Principles-' 



F-7 


SOFTWARE ENGINEERING 


COMBINED WITH 

(• 


• Standards 
• Guidelines 


• Practices 


F-6 


SOFTWARE ENGINEERING 

TO SUPPORT COMPUTING WHICH IS - > 

• Understandable 
• Efiicient 

• Reliable and Mfe F>s 

• Modifiable 
• Correct 

THROUGHOUT THE LIFE CYCLE OF A SYSTEM 

• (C. McKay, 1985) 

Fundementala of Ada Systems 1 *3 





PURPOSES 


• Create iottwaresystemsaccorgmg lugoodengmeeriti;; n, 

• Manage elements within the software life cycle 



CONCEPTS 

• OirtvethewchNecliireofeonwaresyttemi 

• Speoty modules of the lysiem 



) '4 Fundamwntale of Ada Systwne 



Slud«nt NotM: 


MECHANISMS 

• Tools tor; 

Willing operating sysleins 
— Tuning software 
— Prototyping 

• Techniques tor; 

— Managing projects 
— Systems analysis 
— Systems design 

• Standards tor; 

— Coding 

Metrics 

— Human and machine intertacing 


NOTATION 

• Languages tor writing linguistic models 

• Documentation 


USAGE 


• Embedded systems 

• Data processing 

• Control 

• Expeit systems 

• Research and development 

• Decision support 

• Intormation management 


Funttamontals of Ada Syatama 1 >5 




Stufitnt NoMt; 


f-16 


CONTENT AREAS 

• Communication skills 

• Sottwira devalopmant and avolution processes 

• Probitm analysis and specification 

• Syslam design 

• Data Engineerlno 

• SofOmre generation 

• System quality 

• F^roject mamgen^st'it 

• Software engnitiuring protects 

SEI. June 1996 



PROGRAMMING LANGUAGES AND 
SOFTWARE ENGINEERING 


F.17 


A programm.og language i! i software engineering tool 

A programming language EXPRESSES ana EXECUTES design 
meinodoiogies 



The quality of a programming language loi software engineering 
is deierminaO by how well it supports a design metfiodology and 
its underlying models, principles, end concepts 


TRADITIONAL PROGRAMMING LANGUAGES 
AND 

SOFTWARE ENGINEERING 


WmeraMmliii^ UnfwavM , #nfiiw««d 


• Have iMhatf Itw iMMy to 





O Ui 0 L « N a S 



INVWlONMaNTB 

TOOLS 

cONceers 

pnwciWLes 

KrODILS 

MtTHOOOLOOieS 




1 -6 PundanwftMla of Ada 8yata«na 




8tud«nt NotM: 


Ada 

AND 

SOFTWARE ENGINEERING 


Ad* * Wto NMlf ''wiflfMMrad** to oii|iport 
OOdWOfO OftJIIIOOftfbQ 


* «o*o«oo wm mm oomod to , pilndpiM. 
owd loodolo to oiippoft nWtodoUgloo 


lor o o t t woio owplwoiliiB lunonUy 

0<MHoOIO 


s 

c 

p 


tanoaros tools 

^ CONCtRTS 

0 I 0 L I R C S PRmciRLeS 
- . ^ ^ „ MODELS 

H A C T I C E S METHOOOLOCK 


T 

O 

O 

L 


PRINCIPLES OF SOFTWARE 
ENGINEERING 


• Abstriction 

0 Modularity 

e Loculization 

• Information hiding 

• Completeness 

• Confirmability 

• Uniformity 

(Ross. Goodenough, Irvine. 1975) 

ABSTRACTION 

• The process of separating out the important parts of something 
while ignoring the inessential details 

• Separates the 'what' from the 'how 

• Reduces the level of complexity 

• There are levels of abstraction within a system 


Fundanwntals of Ada Systoms 




8tud«nt Notts: 


MODULARITY 


F-22 

t 

s 

t 


F-23 


t 

F-24 


Purposeful structuring of a system into parts which work 
together 

Each part performs some smaller task of the overall system 

Can concentrate and develop parts independently as long as 
interlacet are defined and shared 

Can develop Merarehles of management and implementation 


LOCALIZATION- 

Putting things that logically belong tugeiner Vn'tne Sdi". 
physical place 

• . » * • 

INFORMATION HIDING • 

Puts a wall around localiaed details 

Prevents reliance upon details and causes locus ot auentio!' lu 
interfaces and logical properties 


COMPLETENESS 

Ensuring all important parts are present 
Nothing left out 

CONRRMABILITY 

Oeveioping parts that can be ettectivety tested 

UNIFORMITY 


• No unnecessary dINerences across a system 


1 -8 Purtdamerttala ol Ada Syatame 



Ada LANGUAGE FEATURES 
DATA TYPING 


SttJd«nt Not««; 


• imposition of struetiiro on data vaiuas 
manipuiatad by a programming ianguaga 


MIMpaY 


noiooioiiiaiet 



iiiaafiotiieii 

bitUWHTHW 

iioiaiioiiitM 

biiitaioieiiei 

> 

W ...... 

. . - i - ■ ■ 

no . •‘•v • i 

000 i V 

111 .V. 


' *»••••• 

111 . 


MXAOi (MamvK. amoLi NUMan. 

*«mnifr') 


ratSON (NAME X BWTHOATC X SEX. 



a A data type defines a set of values that objects of the type may 
assume and the set of operations that may manipulate them 


TYPE 

VALUES 

OPERATIONS 

AGE.TYPE 

Positive, Exact Numbers 

+ . *... 

PER50N_TYPE 

Names x Birthdates 

Examine Name ol Person. 


xSex 

Examine Sex. Assignment. 


DESIRABLE REASONS TO TYPE DATA 

• Factoriation of Properties, Maintainability 
a Reliability 

a Abstraction. Information Hiding 
(Rationale for the Design of the Ada Programming Language) 


Fundamantals of Ada Systams 








•tutfvnt Not**: 


STRONG TYPING 


• Ada ii a strongly typfd language 

• All objects must be declared to be of a particular type 

• Oifterent types may not be implicitly mixed 

• Operabona on a type muai preaerve that type (remain within set 
otviluea) 

MY.AQE PERSON-ILLEGAL 


TYPE DECLARATION 

F-29 • Creates a type name 

• Specifies the set ot values and set oi opeiiitions lui iiit type 

type TYPE NAME is |"set ot values ana opeotion.. | 


TYPE DECLARATION 


TYPE 

VALUES i 

; OPERATIONS 

AGE.TYPE 

0.1. 2. ..130 

Those applicable to in 
teger values 

MONEY.fyPE 

Real values between 

Those applicable to 


0.0 and 100.0 

real values 


MAXJ^GE; constant >130 

type A6E_TYPE is range 0.. MAXIMUM_AGE 


1*10 Fundamwnuila of Ada Syatoma 




ttudant NotM: 



OBJECT DECLARATION 


• An instance of a given type 

• A name for a storage location whose structure is that defined for 
the type 

MY AGE : AGE.TYPE: 

YOUR AGE ; AGE.TYPE: 

NO MONEY ; constant MONEY TYPE :« 0.0; 


- - A simple program that adds three 

- - ages together 


procedure AD0_A6ES_T06ETHER is 



MAX AGE ; constant :« 130; 
type AGE TYPE is range 0 .. MAX.AGE; 
JOHNS AGE : AGE TYPE 10; 

MARYS'AGE : AGE.TYPE 40; 

JANS AGE : AGE.TYPE 20; 

TOTAL : AGE.TYPE 0; 


beg i n 

TOTAL ;« JOHNS AGE + MARYS AGE + JANS.AGE; 
end ADO AGES.TOGETHER: 


F-32 


CLASSES OF Ada TYPES 

• Scalar 

• Discrete 

• IntegerTypes 

• Enumerated Types 

• Real 

• Fixed Point 

• Floatingpoint 

# 

PunPemenials of Ada Systems 1*11 







StiNttnt Notts: 


•o 

• Composite 

• Array 

• Record 

• Access 

• Privtie - t 

• Prhote 

• Umiteii 

• Tuk 


SYSTEMS ENQINEERINQ 


F-35 


9 Analyze problem 

• Break into solvable parts 

• irnpiemem pans 

• Tnt parts 

• Inteorate pans to form total lysterri 

• Test total system 



REQUIREMENTS FOR EFFECTIVE 
SYSTEMS ENQINEERINQ 

• AWtity to express architecture 

• Ability to define and enlorcemteileoes 

e AbUity to create Independent components 

• Ability to separate architectural issues from implementation issues 



1*12 Pundamontaleof AOatyatoms 




ttud«nt Not**: 



PROGRAM UNITS 


• Components ol Ada which together form « working Ada software 
system 

• Express the architecture of a system 

• Define and enforce interfaces 


PROGRAM UNITS 


SUBPftOQRAMS Wofkkig Bompowntt 




Bwtoniie ■ rt teiwi In 
pnr i Mil wttte MlMr 
pfografn unlle 


wiwiwiffGffi fvr 

ooSicUne mmmim 
toeallMr ifite leeieal 
Hniu 


F-38 


PROGRAM UNITS 


• Canewt ot two parte; 



■OOY: OaNnaa Ww 
I al 


# 




'Rscr 


F-39 


Fundamantala of Ada Systams 1*13 




•tud««n NoMt: 


F-40 


PROGRAM UNITS 


• Th# HMctltulion 01 ihi proonm unti it ihr only mams oi 
eonnocting progriiti unili 

• Tho tntofitci It iniorctd 

• Tha body ol i prooriin unii it not tccitsibK to otnti piognm umit 

• Th*ft it a cioar ditlinciion biiwttn arcnittciun md 
wnpiamtntation 



• t 


ABSTRACT ACTIONS 
* 

• Mnarfn Pom* diaerott activity 


I'-41 


F-42 



*i»P iC<Hm«I .1 
CWVWO 
Mttii I, 


DISCRETE COMPONENTS 

• AHow a tytlant to bt compoaad ol black boxtt 

• ProvMa dMr, undcratandabta lunctioni 

• Black bORtt can b« mori atlictivtiy validtitd and vaniitd 

• l>rtviltni aerou wglnMnno diicipnnti 





M 4 IKundamantala of Ada Syalama 





SttMdtnt Notts; 





ADCUsiiUlBEffi 

. GEtJ^UMBER (FIFSJ) ■*. . 

-ADD (FIRST, 1?eCONO..TOrA;;j, •". 

oeCtAt rraTAL) ‘ • 


F-43 


SUBPROGRAMS 



• A program unit that performs a particular action 

Procedures 
»• Functions 

• Contains an inttrface (pvameter part) mechanisffl to pass data to 
and from the subprogram 

• The basic discrete component which acts Hke a black box 

• Gives ability to express abstract actions 


F-4a 


SUBPROGRAM STRUCTURE 





Fundamentals of Ada Systems 1 <15 





student NoMm: 


F-46 




proctdurt ADO.NUMBERS is 


F-48 


Loci I 

Dtclarationi]^ 


MAX.NUM : csnstani 40; 

typa NUMBER.TYPE is ranpe 0 MAX NUM; 

NUMBER.1. NUMBER.2. NUM8ER.3. 

TOTAL : NUMBER.TYPE 0; 


btQin 


Executable 

Pert 


NUMBER.1 1; 

NUM3ER.2 :•> NUMBER.! -f 1; 

NUMBER.3 NUMBER.2 1 . 

TOTAL • NUMBER.! NUMBER.? NUMBER.3. 

end AOO.NUMBERS; 


MB Fundamantalaof AdaSyatama 




Stuctant NetM: 



procedure ADD^NUMBERS is 


MAX.NUM ; constant :» 40; 

type NUMBER^TYPE is range 0 .. MAX.NUM: 

NUMBER.I. NUMBER_2. ttUMBER.3, 

TOTAL : HUMBER.TYPE 0; 
procedure INCREMENT 

(A.NUMBER : in out NUMBER.TYPE) 


beg i n 


is separate; 


INCREMENT (NUMBER.I): 

NUMBER_2 NUMBER.I; 

INCREMENT (NUMBER.2): 

NUMBER.3 NUMBER_2: 

INCREMENT (NUMBER.3): 

TOTAL NUMBER.I NUMBER.2 -t- NUMBER.3; 

end AOO.NUMBERS; 



separate (AOO.NUMBERS) 

procedure INCREMENT 

(A.NUMBER : in out NUMBER.TYPE) Is 

beg i n 

A.NUMBER A.NUMBER +1; 
end INCREMENT; 


with TEXT.IO: 

procedure SAY.HI is 
MAX.NAME.LENGTH ; constant 80; 
subtype NAME.TYPE is STRING 
(1..MAX.NAME.LENGTH); 

YOUR.NAME : NAME.TYPE (others -> ’ ' ); 

NAME.LENGTH : NATURAL 0; 


beg I n 



TEXT.10.PUT.LINE(“What is your name?-): 
TEXT.I0.GET.LINE(Y0UR.NAME. NAME.IENGTH): 
TEXT.IO.PUT(-HI-): 

TEXT.IO.PUT.LINE(Y0UR.NAME(1..NAME.LENGTH)): 
TEXT.IO.PUT.L'NECHave^a nice day!!-); 

end SAY.H! ; 


Fundamwitais of Ada Ryatoms 




Student Notts: 


F-52 


SOFTWARE COMPONENTS 

« Logically and physically selt-conUined sottware resources 

• Sirnilar in benefit to hardware components 

• Provide a convenient mechanism for implementing a reusable 
program 



F-53 


PACKAGES 

• Pfoprwn unlto that allow ua to collact logically ralatad aiililiaa 
In ona pl iyalcal placa 

• Allow tha Oafinitlon of rauaaMa aollwara componantt/ 
r aao u fcaa 

• A tundamantal laatura of Ada which allow a chanpa of mind- 

oat 

• An arahH ac f wa-ortanlad faalura 



PACKAGES 

• Alaca a “wall" around raaourcaa 

• Eaport raaourcaa to uaara of a package 

• May eantain loeal r a aourcaa hidOan from iha uaar of a 






1-18 Fundomtntalt of Ada Syatofna 







Studtnt NotM: 



• 0«flnM rMOwrcM • OaflitM InptMMHMaUon 

•waUabt* 10 uMr #1 noourcM 

of Um ye fcoQt • CeoloiM total woaufoai 

• ViatOla to uaar • MIddan (rotn uaar 



F-55 


package CONSTANTS is 

PI ; constant 3.14159 
e : constant ;* 2.71828 ; 



nd CONSTANTS: 


F-56 


with CONSTANTS: 
procedure SOME.PROGRAM is 

MY.VALUE : FLOAT 2 * CONSTANTS.PI ; 

begin 

null: 

- end SOME.PROGRAM; 

with CONSTANTS; 

procedure ANOTHER.PROGRAM is 

ANOTHER.VALUE ; FLOAT 2 * CONSTANTS.PI; 

begin 


null; 



ANOTHER.PROGRAM: 


F-57 


Funilfiinontals of Ads Systsms 1*19 








etudant Notes: 


package ROBOT CONTROt is 
type SPEED is range 0 .103 
type DISTANCE is range 0 500 

type DEGREES is range 0 359. 

procedure 60 FORWARD 
(HOW. FAST : in SPEED; 

MOW.FAR :in DISTANCE): 
procedure REVERSE 

(HOW^FAST ; in SPEED; 

HOW..FAR : in DISTANCE) . 
procedure TURN (HOW_MUCH:in DEGREES); 
end ROBQT.CONTROL: 




with ROBOT CONTROL; 
procedure 00.A.SQUARE is 

begin . ’ 

ROBOT.CONTROL.60.FORWARD(HOW FAST - 

HOW. FAR 

R080T.C0NTR0L TURNlSC'i; 

ROBOT,CONTROL. 60.FORWARCii too -2a) 
ROBQT.CONTROL TURN090); 

ROBOT.CONTROL. 60. FORWARD (100 20).- 
ROBOT,CONTROL.TURN( 90): 

ROBOT.CONTROL.60.F0RWARD( 100. 20) ’ 
ROBQT.CONTROL . TURN(90) •. 
end 00..A.S0UARE; 




package body ROBQT.CONTROL is 

procedure CLEAR.PORT is 
begin 


end CLEAR.PORT. 
procedure GO.FORWARD 
(HOW..FAST : in SPEED, 
HOW.FAR : in DISTANCE) is 
begin 


end GO.FORWARD; 


procedure REVERSE (HOW.FAST 


beg i n 


HOW. FAR 


in SPEED; 
in DISTANCE) is 


end REVERSE; 

procedure TURN (KOW.MUCH in DEGREES) is 
begin 


end TURN, 
end ROBQT.CONTROL 


Fundomonuilii of Ada Systama 



StuciMit Note*: 


ptekage NUMBERS it 

MAX.NUM : constant 40; 

type NUMBER.TYPE is range 0..MAX.NUM; 

procedure INCREMENT 

(A.NUMBER ; in out NUMBER.TYPE); 

end NUMBERS; 


wi t h NUMBERS •• 7 . *’ • : . 

pro.ce'‘dure’ A.OD.NUMB^S is 

NUMBER.I, NUMBER.2, NUMBER_3. 

■ TOTAL : NUMBERS.NUMBER.TYJ>E 0: 

use NUMBERS; 

beg i n 

NUMBERS.INCREMENT (NUMBER.1); 

NUMBER.2 :• NUMBER.1; 

NUMBERS.INCREMENT (NUM6ER.2); 

NUMBER.3 NUMBER_2; 

NUMBERS.INCREMENT (NUMBER.3); 

TOTAL NUMBER.1 NUMBER.2 4 NUMBER.3; 

end AOO.NUMBERS; 


SOFTWARE REUSABILITY 


• Studies show that between 50% and 75% o1 code within a system 
is duplicated 

• Treats software systems as a collection of potentially reusable 
components 

» Must be a goal throughout the life cycle 


Fundamonuile of Ada Syatama 




•UMlMtNOtM) 


OINIRICt 

• Ttwp toH t«r • ■utpwiriw t 

• Tattorifeto (panmttMlaMl) 




F-es 


pwmiMW MTIOm JWAP (im. MOHT i M mil WTIMP) to 
Tm^ I MTIMR I* LVTt 

LIFT I* MOHTi 


MOHT !■ TIMFl 
PNi INTtOIMWAPl 




F-66 


IMtTANTlATION 



1 -sa PundarntnUiiP of Ado tyolonio 


















Student Ndtes: 


with GENERIC.INTE6ER_SWAP; 
procedure SWAP.VALUES is 

MAX.CCUNT : constant 200: 
type COUNT is range 0..MAX.COUNT; 
procedure INTEGER.SWAP 

is new GENERiC.INTEGER.SWAP (INTEGER): 
procedure COUNT.SWAP 

is new GENERIC.INTEGER.SWAP (COUNT); 

iNTEGER.1 : INTEGER 10; F-67 

INTEGER.2 ; INTEGER ;« 20: 

COUNT.1 : COUNT 100: 

C0UNT_2 : COUNT 50: 

begin 

INTEGER.SWAP (INTEGER.I, INTE6ER_2): 

COUNT.SWAP (COUNT.1. COUNT.2); 
end SWAP.VALUES: 




' ^ 
I / 

I / 


I 


N * 

N I 

;; 

t \ 

w' I 

. • • eJ 


trp«ANV.MTEGCR.TmienMpt> •: 

proevdut* OIWIWtLWTiaiHJWAt* (LEFT, » go 

RIGHT: m out AHY.IHTEGER.TYPE); 
proetdw* aENERIC.INTEOERJMrAP (LEFT. mOHT: In out 
ANY.INTEaER.TYPE) to 
TEMP: ANY.INTEOER.TYPe :■ LEFT; 
bagin 

left ;« RIOHTi 
RIGHT :• TEMP; 

«Ml GENERICJNTEOER3WAP: 


gener i c 

type ELEMENT.TYPE it privatt; 
procedure GENERIC.8WAP 

(LEFT, RIGHT ; in out ELEMENT.TYPE); 
procedure GENERIC.SWiAP 

(LEFT. RIGHT ; in out ELEMENT.TYPE) is 

TEMP ; ELEMENT.TYPE LEFT; 
begin 

LEFT RIGHT: 

RIGHT TEMP; 

end GENERIC.SWAP; 


Fundamontale of Ada Systeme 1 <23 







Studant Notas: 


F-70 


with GENERIC.SWAP; 
procedure SWAP.THIN6S is 
MAX_C0UNT; constant100; 
type COUNT 

is range - MAX.COUNT .. MAX.COUNT; 

type COLORS is (RED, BLUE. GREEN): 

type REAL is digitt 10; 

procedure SWAP.COUNT 

is new 6ENERIC.SWAP (COUNT): 
procedure SWAP.COLORS 

is new GENERIC.SWAP (COLORS) 
procedure SWAP.REAL 

is new GENERIC.SWAP (REAL) 

COUNT.1 : COUNT 5; 

COUNT_2 ; COUNT ;= 10: 



COLOR.1 ; COLORS RED; 

COLOR.2 ; COLORS ;* BLUE; 

REAL.1 : REAL :* 20.0; 

REAL.2 : REAL 40.0: 

begin 

SWAP.COUNT (COUNT.1. COUNT.2); 
SWAP.COLORS (COLOR.1. COLOR.2): 
SWAP.REAL (REAL.1. REAL.2): 

end SWAP.THINGS; 



1 -24 Fundamontals of Ada Syatama 


Student Notts: 


Ada PROGRAM LIBRARY 


t A record ol all the separately compiled program units that make up 
a program 

• Central lacility for the development ol Ada systems 


SEPARATE COMPILATION 


• Piegrwn unite iMy to* M p w tely oowpited 



SEPARATE COMPILATION 


• A pmgwn unit's spsditeution muy tu oompIteU uspumtety teom 
Ha body 

• RouIIxm not only oicgIcoldN t Ino U onbotwoon t fo t iiltec tu roond 
bnplomontetlo n , but aloo • p b y tool dtetinctlon 



Fundamtntals of Ada Systoma 1«2S 




student Notes: 


SEPARATE COMPILATION 

f :.74 * AHowt development ol independent lotinare components 

e Currently we ell Put ioM tite human eHoM going into software ihs 
disposable 

• Separate compilation mows ui to reuse components and kMp our 
Investment 


SOFTWARE COMPONENTS 


eoMa>OMeN'rs LienAnv 



INDEPENDENT COMPILATION 


F-7e 


e Widdyuaed 

e Motkiles have no way ul sharing hnowledge ol properties defined in 
other modules 

e uin tower level ol complle-time checking of consistency beiwnn 
Wilts than Is possible within a single compilation unit 



1 -M Fundementels of Ada Syeteme 


Student Not**: 


SEF^ARATE COMPILATION 

F-77 

• Uses the program library to perform the same level of checking 
between units whether compiM in one compilabon unit or many 

• Resolves safety wifh reasons for compiling In parts 


. Ada COMPILATION MOO'EL . ; ; 



COMPILATION UNIT 

• A Ada presram la a eo>a c Men el coi i iohed"" 

unNa aubahittad to Un eampHar eaparalaly 



FundamanUils of Ad* System* i -27 




8tud«nt NotM: 


F-80 


OOMntAnOMtMIT eOMATWN UNIT OOMMATION UMT 

: D: 3 c 3 


% 



Mb program 


F-81 


CONTEXT CLAUSE 


• • pi cHI — wi m>ll»d Hhmy unite iwmM In (hte 

ooutelte U n n unit 

wMh UiaflAIIVJINtT_NAIfE| 




F-82 


UBRARY UNITS 

• Subprogram (ttdtration (ipicNici^ 

• Pickage dodiratlon (specHication) 

• G«n«ricdtciaratiOfl(S|»citication) 

• Generic in«tinti«Pon 

• ^bprogram body (specification and body) 



1 -28 Pundamontalo of Ada Syotams 





StudMttNotM: 


proc»dur« PRiNT.MY.NAME; 



owkagc TESt.0MRATION8 te 
type TCST-SCOffES la iMipa 0..100: 
pr w dMW SWAP (PIRST, SECOND: In mil TETLSCOlieS); 
hMietlon SBCONQJ&OfieATei (PlftST, SECOND: In TESI.SOOIIES) 
ratum SOOLEAN: 
and TEST.OPERATIONS; 



wM) PraNXJiY.NAaiE. TESX.OPEItATIONS: 
pronaitiiri TEST.DtEN la 

•DLTEST ; TEST_OPEfMTK)N8. TESTJKOflES :■ 10; 
VOURJEST : TCSX.OPEflATK)NS. TEST.tCOflES :» I; 

feafin 


' HHNTJIVJIAME: 

TESTJDPBUTIONS. SWAP (MXJTEST, VOURJEST); 
and TtSTJUSSR; 



Fundamontals of Ada Systems 






Stud»mNet*«: 


F-66 


SECONDARY UNITS 

• Library unit bod/ 

— Subprogram body 

— Package body 

• Subunit 



1 

i 


prooMfim l»raMt.MY.IIAME to 
b*«ln - pmNT.MY.NAM£ 


•nd PIIINT.MY.NAMEi 


F-87 





package body TEST.OPERATIONS is 
procedure SWAP 

(FIRST.SECOND ; in out TEST.SCORES) is 
TEMP : TEST.SCORES: 
begin •• SWAP 
TEMP :• FIRST; 

FIRST SECOND; 

MB SECOND TEMP; 

and SWAP: 

m • 

function SECOND.IS. 6 REATER 

(FIRST. SECOND ; in TEST.SCORES) 
return BOOLEAN is 
begin •• SECOND.IS.GREATER 
return SECOND>FlRST; 
end SECOND.IS.GREATER; 
end T 4 EST.OPERATIONS; 


1 *30 Fundamontala of Ada Syatoma 



PROGRAM UBRARY 


StudMit NotM; 


UMARV UNITS 


SICONOARV UNITS 


mt.OWUTIOM 


CTOTjeoWItj 


^T««T.U■^I^I 






SUBUNITS 


CKoeadura COUNTING it 
typ* SMAUJilUMBERS is iwigt 1..10: 

VALUE; BMALUIUMBERS; 

INCREMENT (NUMBER: In out BMALLJtUMBERS) 
la aaao w ta; 

booln « COUNTING 
VALUE:* 1; 

INCREMENT (VALUE): 


and COUNTING; 


|fam Ubfanr 




SUBUNITS 


Visibility rulM for tha subunit «ni Um sam« 
the code wbb embedded ee before 


(COUNTING) 

a INCREMENT (NUMBER: In 


0iitSMALtJ«UMBBRB)ls 


Begin - BCRBOBIT 
MJMBERio NUMBER 4 1; 
rttd INCREMENT: 



Fundamentels of Ada Systems 1*31 






ttudttnt Notti: 


F-92 


f-93 


CONTROL ITflUCTURES 

% 

• Control llovir ol tMCuUMi Mouinco ol stitiminti 

• Mint inttmal io 0 ic of i prognm unit 


ASSIQNImSNT tTATEMfNt 

• • • 

proctOurt CALCULATE.TOTALS 11 ' 

MAX.VALUE : coniiant ;• 1000, 
lypt VALUES ll rtngi p. MAX.VALUE;. 


VALUE.1, VALUE.2. VALUE.3 ; VALUES - 10 
VALUE.4, VALUE.5. VALUE.0 ' VALUES .» 0. 

btgln 



VALUE.4 : 20; 

VALUE.5 - VALUE.4 + 10, 

VALUE .6 (VALUE.5 ^ 2) ’ VALUE.1; 
VALUE .6 VALUE .6 + VALUE.1 ‘ VALUE.2, 


•nd CALCULATE.TOTALS. 


pickigt NUMIER 8 It 

■ 1 

MAX.NUM : coniiani 40: 

lypt NUMBER.TYPE it rangi 0 MAX.NUM; 

proctduri INCREMENT 

(A.NUMBER in out NUMBER.TYPE): 

tnd NUMBERS; 

ib 


1<32 Pundomontait of Ado tyotomo 




Student Not**: 


PROCEDURE CALL 


with NUMBERS, 
procedure TOTAL.VALUES is 


MY.VALUE ; NUMBERS NUMBER.TYPE 0; 

YOUR.VALUE : NUMBERS.NUMBER.TYPE 4; 
use NUMBERS; 


begin * 

MY.VALUE- :• MY.VALUE 1: 

. NUMBERS'..iNCREMENT'{MYlVACiJE) 
•-YGrUR.VALUE*j^-:-10-. . ; 

NUMBERS^ I C.. 

• * • * * • 

imi TbTALvktwTS,' . ' ' • 



F-95 


package body NUMBERS it 
procedure INCREMENT 

(A.NUMBER in ohjI HUMBER.TYPE) it F-96 

begin 

A.NUMBER :« A.NUMBER * 
end INCREMENT; 
sod NUMBERS; 


IF STATEMENT 



H OONOmON IhM 
STATIMENT; 

STATEMerr; 
STATlMEir: 
•ntf IN 


F^9? 


Fund*m«ntail« e( Ad* Systems 1 *33 





ttud«n! 


^•98 


•vim NUMBERS 
proddur* C0UN7_UP \t 

HY.NUMBER NUMBERS NUMBER. TYPE 10 
YOUR.NUMBER NUMBERS.NUMBER.TYPE - 0 
UM NUMBERS. 

iMOin 

NUMBERS INCREMENT (MY.NUMBER). 
ifMY.NUMBER * 11 men 
Y0yR.NUM8ER - S; 
wdM; 

NUMBERS.INCREMENT (YOUR.NUMBER). 
ifYOUR_NUM6ER - othen 
NUMBERS.INCREMENT (VOUR.NUMBER) 
NUMBERS INCREMENT (MY.NUMBER). 
end If, 

end COUNT.UP: 



I 



IF STATEMENT 


F.99 


I 


IfTHE.SKY.IS BLUE then 
THERE.ARE.no .CLOUDS 
elu 

THERE.ARE.CLOUDS. 
THE.SKY.IS.NOT.BLUE, 
end it; 


It THF.SKY.IS.BLUE then 
THwRE.ARE.NO.CLOUDS 


•iiif THE.SKYjS.REOmen 
iT.IS.MORNINii. 
IT.IS.EVENINQ: 


eisilTHE.$KY.IS.6REEN then 
WE.HAVE.PROBLEMS. 


•lie 

WHO.CARES; 
end It 


LOOP STATEMENT 


F 100 


wim NUMBERS; 
procedure COUNT.UP It 
MY.NUMBER; NUMBER8.NUMBER TYPE i- 0; 
useNUMFcRS; 
begin 
loop 

NUMBERS INCREMENT (MY.NUMBER). 

exit when MY. NUMBER - NUMBERS MAX.NUM. 
MfKt loop: 
end COUNT.UP; 




1 >34 Pundamontale ol Ada Syatama 



INPUT/OUTPUT 

TEXTJO 


Studvnt Notes: 


• A predefined psckige that provides input and output facilities tor 
textual (human readable) objects 

• Contains I/O facilities for atrings and characters and generic 
facilities tor integers, enumerated, fixed and floating point tj/pn 


TEXTLIO 

TEXTJO . M m layMt apwMloM 



liMfw, StMtni point, SBod potm 


F-102 


GENERIC TEXTJO 



Fundantentels of Ada Systems 1 >35 











Studant NotM: 


STRING I/O 


with TEXT.IO; 

procidun OUTPUT.TEXT Is 

MAX.LENGTH : constint 20, 

subtype LINE.TYPE is STRING(1 MAX.LENGTH): 

MY.LINE : LINE.TYPE (Others -> ■#’). 

F-KM begin 

TIXT.IO.PUTCMI THERE,*): 

TEXT.IO.PUTC •): 

TEXT.10.PUT(‘WELCOME TO Ads’); 
TEXT.IO.NEW.LINE; 

TEXT_IO.PUT(MY.LINE); 

TEXT.IO.NEW.LINE; 

end OUTPUT.TEXT; 

HI THERE. WELCOME TO Ads 

####«############### 


STRING I/O 


F-105 


with TEXT.10; 

procedure OUTPUT.TEXT Is 
MAX.LENGTH : constsnt 20; 
subtype LINE.TYPE is STRING (I . MAX.LENGTH) 
MY.LINE ; t.lNE.TYPE :• (Others -> '#') 


begin 

TEXT.10.PUT.LINE ('HI THERE. ") ; 

TEXT.10.PUT.LINE (’WELCOME TO AdS’); 
TEXT.10.PUT.LINE (MY.LINE); 

end OUTPUT.TEXT; 

HI THERE 
WELCOME TO Adi 


STRING yO 


f-106 


picksge LINE.PACKAQE Is 

MAX.LENGTH ; constsnt 20; 

sublype LINE.TYPE Is STRING (1 MAX.LENGTH) 

4 

end LINE.PACKAGE, 


1 -36 Fundomantaio of Ada tyatams 




Studwit NoIm: 



STRING I/O 


with TEXT.IO, LINE.PACKAGE: 
procidure ECHO.NAME is 

NAME : LINE.PACKA6E. LI NE.TYPE :- (Othm->'*): F*107 

beg i n 

TEXT.IO.PUT CtMtAT IS YOUR NAME?'): 

TEXT.IO.GET (NAME); 

TEXT.IO.PUT ('HI'); 

TEXT.IO.PUT.LINE (NAME); 

end ECHO.NAME; 


CHARACTERJO 



with TEXT.IO, LINE.PACKAGE; 

procedure ECHO.NAMES Is 

NAME : LINE.PACKAGE. LI NE.TYPE :« (others *> ' ‘ ; 
ANSWER ; CHARACTER H’; 


TEXT.IO.PUT ('WHAT IS YOUR NAME?'); 
TEXT.IO.GET (NAME); 

TEXT.IO.PUT ('HI'); 

TEXT.IO.PUT.LINE (NAME); 

TEXT.IO.PUT ('MORE NAMES?(Y TO CONTINUE):'); 
TEXT.IO.GET (ANSWER); 

TEXT.IO.SKIP.LINE; 

exit when ANSWER /-’Y‘ or ANSWER/- ‘y‘; 
end loop; 
end ECHO.NAMES; 



pHfidanMMitale of Ada Syatame 1 *37 






•tuflivnt Notat: 


GENERIC I/O 


with TEXT.10, LINE.PACKAGE, NUMBERS: 


procidurt ECHO.AQE it 

packagt NUMBER.IO it ntw TEXT.IO INTEGER.tO 
(NUMBERS.NUMBER.TYPE); 

NAME : LINE.PACKAGE.LINE.TYPE - 
(olhtrt ‘ •): ■ • 

AGE ; NUMBERS.NUMBER.TYPE . :* Or 

bag in " 

TEXT.10.PUT ('^AT IS YOUR NAME: ”); 
TEXT.IO.GET (NAME); 

TEXT.10.PUT ("HOW OLD ARE YOU’ 

NUMBER.IO.GET (AGE); - - 

TEXT.10.PUT (NAME): 

TEXT.10.PUT (-. YOU ARE *); 

NUMBER.10.PUT (AGE); 

TEXT.10.PUT.LINE (' YEARS OLD“); 

and ECHO.AQE: 


1 <38 Fundamantalii of Ada Byatama 



t$iid«nt Noitt: 


BASIC ADA TYPES 


• Purpose of Typing * B-1 

• Type DedanitioM 

• Object Dederttiofis 

• Ctesses of Basic Ada Types 



TYPING 


• A type defines a set of values and a set of operations applicable to 
those values for objects of that type 


B-2 


PURPOSE OF TYPING 

I 


• Toimpoaeitnidureondatafor 

MFactoriiatlon of Prepertles, Mainldiiibliity 
••Reliability 

••Abstraction, Hiding of Imptementation Details 



Basic Ada Typaa 2*1 



Studmt Notes: 


STRONG TYPING 

•d 

• Evtoobjsct must haves specified type IS sut>c 

• Csnnot mix objects of different types without explicit conversion 


TYPE DECLARATIONS 

• Construct used to define a new type 

• Cmtes a new type name which is !-t from othe: r; p i tuimes 

• Form 

type TYPF^NAME is [CLASS OF TYPE); 





2-2 Basie Ada Types 


< 


TYPE DECLARATIONS 


type COUNT is fange 0.. SOO; -- hitager type 
type SCALE HI LOW. MEDIUM. HIGH); — enumeratsd type 
type WEIGHT is digits 10 range 0.0 ..1000.0; — fioatingp^type 
^CUHREItTia(bBiO.062Sian9e0.0.. 100.0; — fixed point type 

type CHARACTER.COUNT N array (CHARACTER) of COUNT: - - array type 
type CLASSIFY is record —record type 
VALUE; WEIGHT; 

CATEGORY: SCALE; 
end record; 







8tud«nt Not««: 


OBJECT DECLARATIONS 


• An instance of • type 

• Reserves storage with the stnictura defined by tlM type 

• Fonn 

OBJECT.NAME: TYPE.NAME:- iNITIAL.VALUE: 


B-7 


OBJECT DECLARATIONS 


T0TAI.,.C0UNT 

COUNT 

0; 

RATING 

SCALE 

LOW; 

SMALLEST.WEIGHT 

WEIGHT ;« 

0.0; 

LINE^CURRENT 

CURRENT ;- 

0.0: 

HOW.MANY 

CHARACTER.COUNT 

(others • > 0) 

VALUE_CLASSIFICATION : 

CLASSIFY 

(0.0. Low); 


FORMS 


VARIASLE 

TOTAL.COUNT : COUNT 0; B-9 

CONSTANT 

SMALLEST^WEIGHT : constant WEIGHT 0.0; 

NAMED NUMBER 

MAXIMUM_C0UNT ; < constant 100; 


Baeie Ada Typas 2>3 







8tud«nt Noi*«: 


wllhTEXT lO; 

procedure TOTAL^NUMBERS is 
NUMBER.TO.GET : constant;« 5; 




B-10 


B-11 


B-12 


MAXIMUM NUMBERS; constant » 10. 

type NUMBERS it range 0 . MAXIMUM NUMBERS ’ NUMBER TO GET. 
subtype INPUT.NUMBERS Is NUMBERS range 0 MAXIMUM.'NUMBERS. 

A-NUMBER: INPUT NUMBERS;» 0; 

TOTAL ; NUMBERS :«0: 

packige NUMBER.IO is new TEXT_IO.INTEGER_IO( NUMBERS), 
begin 

tor TOTAL LOOP ml. NUMBER TO GET loop 
TEXT lO.PUTrNumber-)“); 

NUMBER I0.GET(A NUMBER): 

TOTAL TOTAL + i_NUL BER: 
end loop, 

TEXT 10 PUTHoui ol numbers it ’); 

NUMBERJO PUT( TOTAL); 

end TOTAL.NUMBERS; 

ADA TYPES 

• SCALAR tingle values 

•• DISCRETE — exact values 
— INTEGER 

ENUMERATED 

•• REAL — approximate values 

FIXED Point ~ absolute 
o— FLOATING Point — relative 

• COMPOSITE — multiple values 

— ARRAY -> homogeneous (components have tame type) 

•• RECORD — heterogeneous (components may have 
ditterent types) 

• ACCESS—dynamic varlablM 

• PRIVATE/LIMITED—abstract data types 

• TASK—designate tasks 

SCALAR TYPES 



2<4 Basie Ada Typos 


• Objects contain a single value 
o Values are ordersd 




DISCRETE INTEGER 



• FORM 

typ« IDENTIFIER is range LOWER.BOUND.. UPPER.BOUND: 

• EXAMPLE 

MINTAGE: omstint0; 

MAXIAGE : oonsUntISO; 

type A6E.TYPE ii range MIN.A6E.. MAX_A6E: 

SET OF VALUES: 

(0.1.2. ...150) 


StMdent NotM: 


B-13 


with TEXT JO; 

procedure AVERAQE_NUMBERS is 


NUMBER_TO.GET; constant ;• 5; 



MAXIMUM NUMBERS; constant10; 

type NUMBERS is range 0.. MAXIMUM NUMBERS * NUMBER TO GET: 
subtype INPUT.NUMBERS is NUMBERS range 0.. MAXIMUMJnumBERS; 

type NUMBER.COUNT is range 0.. NUMBER.TO.GET; 


A NUMBER : INPUT NUMBERS 0; 

TOTAL : NUMBERS 0; 

HOW MANY NUMBERS : NUMBER COUNT :-0; 


B-14 


package NUMBER 10 is new TEXT iO.INTEGER IO( NUMBERS); 
package COUNTJO is iwwTEXTJO.INTEGER.KK NUMBER.COUNT); 

begin 


, TEXT IO.PUT(*How many numbers do you have •>*): 

COUNT lO.GET (HOW MANY NUMBERS): 
forTOTiL LOOPinI .rHOW MANY NUMBERS loop 
TEXT lOTPUrctliimber •> 

NUMSER I0.GET(A NUMBER); 

TOTALTOTAL ^ A.NUMBER; 
end loop; 

TEXT lO.PUTC^otalofAumbersis*): 

NUMBER IO.PUT(TOTAL); 

TEXT_I0.NEW_UNE(2); 

TEXT IO.PUT(‘The average of the numbers is”); , 

NUMgER.IO.PUT( TOTAL / NUMBERS(HOW_MANY_NUMBERS)); 



endAVERAGE.NUMBERS; 


Basic Ada Typos 2*5 







Student NotM: 


DISCRETE ENUMERATED 


B-15 


• Enabtt direct representation ot non>integer values 

• Example, security ctassos 

UNCLASSIFIED. CONFIDENTIAL. SECRET, TOPJECRET 

type SECURITY^TYPE Is (UNCLASSIFIED. CONFIDENTIAL.-' 
SECRn.TOP.SECRET); 



8-16 


procedure CONTROL ACCESS is 

type SECURITY TYPE is (UNCLASSIFIED. CONFIDENTIAL. SECRET. 
TOP.SECRET);" 

procedure fiET_CLASS(.SECURITY^LEVEt: out SECURITY TYPE) is 

separate; 

procedure ENABLE.CONFIDENTIAL ACCESS is separate,, 
procedure ENABLE SECRET ACCESS is separate; 
procedure ENABLEjOP.SECRET^ACCESS is separate: 


SECURITY^CLASS r SECURITY.TYPE » SECURITY.TYPETIRST; 
begin 

GET_CIASS( SECURITY_ClASS ); 

if SECURITY_CLASS ••= TOP-SECRET then 

ENABLE TOP SECRET ACCESS: 

ENABLE SECRET ACCESS; 

ENABLE-CONFIDENTIAL.ACCESS; 

eWf SECURITY-CLASS • SECRET then 

ENABLE SECRET ACCESS; 

ENABLE'CONRDENTIAL-ACCESS; 

elsif SECURITY-CLASS - CONFIDENTIAL then 

ENABLE.CONRDENTIAL-ACCESS; 

end if; 



end CONTROL-ACCESS; 


2-6 


Basic Ada Typds 



Stuctont Not**: 



REAL 


• Provide ipproxlmiitlons for real numbers 

• Two wiyi of handling error bounds 

<M RoaUnoF'oitrt—relative error bound 
M Fixed Point—absolute error bound ' 

• Model Womber»:9hfelrnplerr»entatloa^ndependentocp?3iw • 

w - Safe Numbers' givejmpfe'fnMtetion^deQend*"^ _ 


FLOATING POINT TYPES 



• Error bound between numbers is expressed as relativn to the 
position of ttw number over the entire range of values 

• Accuracy is specified in terms of the number of significant digits 
required 


* 




S-f8 


FLOATING POINT TYPES 


• Form 

type TYP£_NAME is digits 10 (range 0.0.. 100.0]; 
type REAL is digits IS range >100.0.. 100.0: 



B-19 


Basic Ada Types 


2-7 



Studvnt NoIm; 


with TEXT 10; 

procedure AVERAGE.NUMBERS is 

NUMBER_TO_GET : constant - 5. 

MAXIMUM.NUMBERS constant10 0. 
type NUMBERS is digits 10 range 0.0.. 
MAXIMUM NUMBERS * NUMBER.TO.GET; 



B-20 


auMype INPUT NUMBERS it NUMBERS range 0.0.. 
MAXIMUM.NUMBERS; 

type NUMBER.COUNT is nnge 0.. NUMBER_TC_GET; 


A NUMBER ; INPUT NUMBERS 0.0; 
TOTAL : NUMBERS 0 0 
HOW MANY NUMBERS : NUMBER COUNT -0: 


package NUMBER 10 is new TEXT !0 . FLOAT I0( NUMBERS): 
package COUNT.IO is new TEXT_l5.INTE6Efl‘.IC( NUMBER^COUNT ). 


begin 


TEXT IO.PUT('How many numbers do you have •' *). 

COUNT I0.6ET (HOW MANY NUMBERS ); 

(or TOTAL LOOP ml ~HOW MANY NUMBERS loop 
TEXT lO.PUTi'Number •> ’). 

NUMBER I0.GET(A NUMBER); 

TOTAL TOTAL A.NUMBER; 
end loop: 

TEXT lO.PUTCTotal of numbers IS’); 

NUMBER 10 PUT(TOTAL) 

TEXT_IO.NEW_LINE(2). 

TEXT 10 PUT( "The average ot the numbers is"). 

NUMBER.IO PUT( TOTAL / NUMBERS(HOW_MANY_NUMBERS)); 



endAVERAQE.NUMBERS 


FIXED POINT TYPES 

• Error bound between numbers it expressed as a Itxed value 
between any two numbers 

• Accuracy is specified in terms of the delta (change) required 


■4—i--i ♦ ! i-i r 1-t f- I—f—r 



2-8 Bieic Ada Types 





RXED POINT TYPES 


StudMit NotM: 



type TYPE.NAME is delta 1.0/8 range O.C.. 1000.0; 
type FIXED„TYPE is delta 1.0/10 range 0.0.. 1000.0; 


B-22 


with TEXT 10; 

procedure'AVERAGE.NUMBEfiS is 
NUMBER.TO.GET: consUnt;« 5; 
MAXIMUM.NUMBERS: consunt10.0; 
EIGHTS; constant 1.0/8; 



type NUMBERS is delta EIGHTHS range O.C.. 
M/iXIMUM NUMBERS * NUMBER.TO.GET; 

subtype INPUT NUMBERS is NUMBERS range 0.0.. 
fMXIMUM^NUMBERS; 

type NUMBER.COUNT is range 0.. NUMBER JO.GET; 


B-23 


A NUMBER ; INPUT NUMBERS :* 0.0; 
T5TAL : NUMBERS .* 0.0; 
HOW MANY NUMBERS ; NUMBER COUNT 0: 


p.?ckage NUMBER 10 is 
new TEXT^ I0.FIXE0_I0( NUMBERS); 
package COU^^T 10 is 

new TEXT jO.iNTEGtR IO( NUMdER_COUNT); 


begin 



TEXT 10 PUT('1tnwinanynurnbersdoyouhave->*); 

COUNT !O.GET(HOW MANY NUMBERS); 
lorTOTk LOOP ini ..~HOW MANY NUMBER:, luop 
TEXT IOTPUTrNuimb€r->^; 

NUMBER I0.GET(A NUMBER); 

TOTAL; - TOTAL + A„NUMBER; 
end loop; 

TEXT IO.PUT(*Tot«l of numbers is *): 

NUMBER 10.PUT( TOTAL): 

TEXT„I0.NEW_LINE(2); 

TEXT lO PUTHhe average of the numbers is"); 

NUMBER 10. PUT 

(NUMBERSITOTAL / NUMBERS(HOW,MANY.NUMBERS})). 
end.WERAGE.NUMBERS; 


Basic Ada Typaa 2*9 



8tud*ntNolM: 


COMPOSITE TYPES 


• Objactt may conuin multiple values 

• TwokinPs 

•• Arrays - values Itive ume type 
•• Records - values rttay have ditterent types 


ARRAYS 


In declaration must specify 
•e The type ol the uimponentg 
— The type of the index 


NUMBER Of TILES: consunt; - 7; 

type TILE~NUMBER is ranpe 1.. NUMBER OF TILES; 

type LETTER is (A.BX.O,E.F.G.H.I,J.K.L.M.N.O. 

P.Q.R.S.T.U.V.W.W.X.Y;t.«LANK); 
type RACK is array (TILE.P* !MBER) Of LETTER: 

MY^RACXtRACK> (A.J.B,BLANK,K,5,S); 




ARRAY INDEXING 


• To retarmee a particulaf component of an array must specify index 


2*10 Basic Adi Typen 


MY.RACKO) 


BLANK; 


MY.RACK(6..7} (A.B); 


MY RACK (4) 


:• MY RACK (6). 




ttudMit Notts: 



package SAMPLER is 

BANDWIDTH: constant: - TOO: 

t/pe FREQUENCIES is range -BANDWIDTH.. BANDWIDTH; 

MAX MAGNITUDE: constant10; 

type MAGNITUDE is range 0.. MAX.MAGNITUDE; 

type SPECTRUM is array( mEQUENCIES) ol MAGNITUDE: 


B-27 


function HIGH FREQUENCY 
(A.SPECTRQm ; SPECTRUM) rstiin» FREQUENCIES: 

end SAMPLER: 


package body SAI.4PLER is 

function HIGH_PREQUENCY (A.SPECTRUM: SPECTRUM) return FREQUENCIES is 

HIGH MAGNITUDE; MAGNITUDEMAGNITUDE'HRST; 

HIGHIST.FREQUENCY : FREQUENCIESA.SPECTRUM'FIRST; 

begin 



tor FREQUENCY in A.SPECTRUM* RANGE loop 

H HIGH MAGNITUDE < A SPECTRUM(FREQUENCY) then 
HIGH'MAGNITUOE A* SPECTRUM(FREQUENCY): 
Hl6HfST,FREQUENCY:S FREQUENCY; 
end If; 
end loop: 


return HIGHEST^FREQUENCY; 
end HIGH-FREQUENCY; 
end SAMPLER; 


UNCONSTRAINED ARRAYS 


• Give the ability to declare varying sized obfectsirom the same array 
type declaration. 


typa STRING is array (POSITIVE range <>) M CHARACTER: 


MAX TEXT LINE;constant80; 
subtype TE)^ is STRING (1 ..MAX TEXT LINE): 

SMALL TEXT SIZE: ccftstantiO; 

subtype'SHORT TEXT is STRING (1 ..SMAU TEXT-SiZE): 

SHORT line’ : SHORT TEXT; 

LONG LINE : TEXT:' 

LINE" : STRING (1 . . 12); 



6-29 


BmIc Ada Typts 2*11 



•tudvnt Notts: 


BiO 


B-31 


pickigt SAMPLER is 

BANOWlOTHconilsnl" 100, 

SMALL; constant10: 

MEDIUM : constant: •- 50: 

type FREQUENCIES is range -BANOWIOTH . BANDWIDTH; 

MAX MAGNITUDE constant 10. 

type MAGNITUDE is range 0.. MAX.MAGNITUDE: ' 

type SPECTRUM Is array! FREQUENCIES range <> ) of MAGNITUDE; 

subtype SMALL SPECTRUM is SPECTRUM(-SMALL..SMALL). -' 
subtype MEDIUM SPECTRUM is SPECTRUM(-MEDIUM..MEDIUM); 
subtype FULL.SKCTRUM is 8PECTRUM(>BANDWIDTH. .BANDWIDTH); 

function HIGH FREQUENCY - 

(AJPECTRUM; SPECTRUM) return FREQUENCIES: . 
end SAMPLER; 


with SAMPLER; 
procedure FIND.HIGHEST II 

SHORT RANGE ; SAMPLER.SMALL SPECTRUM - (others - )S); 

FULL (UNGE ■ SAMPLER.FULL SKCTRUM ' (Others -) 1). 

HIGHEST : SAMPLER.FREQUf)4CIES SAMPLER.FREQUENCIES'FIRST; 
SHORT HIGH;SAMPLER.FREQUENCIES SAMPCER.FREOUENCIES'FIRST. 
FULL HIGH ; SAMPLER.FREQUENCIES SAMPLER.FREQUENCIES'FIRST; 



begin 

SHORT HIGH SAMPLER.HIGH FREQUENCY!SHORT RANGE). 
FULL HIGH SAMPLER.HIQH.FREQUENCY( FULL.RANGE). 


If HIGHEST 
HIGHEST 

end if; 

if HIGHEST 
HIGHEST 

end if : 


SHORT HIGH then 
SH0RT>IGH . 

FULL_HIGH then 
FULL.HIGH 


end FIND_HIGM£ST. 



MULTI DIMENSIONAL ARRAYS 


B-3? 


package GAME .PIECES is 

NUMBER OF TILES; consunt; - 7; 

type TILEInUMBER is range 1.. NUMBER.OF.TILES; 

NUMBER OF SQUARES; constant: - 15. 

type SQUARES is range 1.. NUMBER.OF.SQUARES. 

type TILES is (A. B. C. D. E. F. Q, H. I. J. K. L.M. N. 0. P, Q. R. S. T, 

U.V.W.X Y.Z, BLANK, empty I 

type RACK is array (TILE NUMBER) Of TILES, 
type BOARD is array (SQUARES. SQUARES) ot TILES, 
end GAME. PIECES; 



2-12 Basic Ada Typos 






student Noim: 


(Kickage FORMAT is 

pfocedura ADD DOLLAR SIGN (A STRING; in out STRING): B-33 

(Wd FORMAT; 


■'packagebodyrdRMA^is.' • . . ir. • . 

procedure • * oyTSTWIttllis 

DOLURi CHARACTER . • — 


begin 

A STRING!A STRING‘FIRST-t-1 ..A STRING'LAST):- 
A STRING!A STRING'FIRST ..A STRING'LASM ); 
AJTRING! A.^ING'FIRST)DOLLAR; 

endAOO.OOLLAR.SIGN; 

end FORMAT; 


with FORMAT. TEXTJO: 

procedure FORMAT^NUMBER is 

MAX LENGTH;constant:-80: 

subt^ NUMBER STRING is STRING!!..MAX LENGTH); 

A.NUMBER.STRiNG; NUMBER.STRING!'^ra - > ” 

LENGTH: NATURAL :-0; B*35 

begin 

TEXT lO.GET LINE! A NUMBER STRING. LENGTH): 

FORMAT.AOO'dollar SIGN (A NUMBER STRING!!..LEN6TH-t>1)); 

TEXTjO.PUrrA.NUMBER.STRING); 

end FORMAT_NUM6ER; 


Basic Ado Ty|i«s 2-13 


Student NotM: 


RECORDS 

• Components may have different types 

• Form 



NUMBER OF DAYS IN MONTH; constant := 31; 

8 35 type DAY-TYPE IS range! ..NUMBER OF DAYS IN MONTH, 

type MONTH TYPE is (JAN. FEB. MAR. APR, MAY. JUN. JUL. 

AUG. SEP. OCT. NOV. DEC); 

LAST DAY ON EARTH; constant2085; 

type YWRJYPE is range 1.. LAST_DAY_ON_EARTH; 

type DATE is record 
DAY : DAY TYPE. 

MONTH MONTH TYPE; 

YEAR : YEAR.TYPE, 
end record. 


B-37 


• Components are referenced using "dot notation” 


TODAY.DAY 

TODAY.MONTH 

TODAY.YEAR 


TODAY 


3 


JUN 

1987 



TODAY: DATE; 
TOMORROW;DATE; 
•YESTERDAY DATE; 


begin 

TODAY.DAY:-3: 

TODAY.MONTH:-JUN; 

TODAY.YEAR:- 1987; 

YCSTERDAY.DAY: - TODAY.DAY -1: 
YESTIRDAY.MONTHTODAY.MDNTH: 
YESTERDAY. YEARTODAY.YEAR; 




2-14 Baafe Ada Typos 


TOMORROWTODAY; 

TOMORROW.DAYTOMJRROW.OAY 41, 
TODAY:- (4. JUN, 1987 ); 







Stii0*nt Notts: 



OTHER RECORD FORMS 


B>39 

• Discrlminatsd 
t Vsiisnt 


OTHER ADA TYPES 



• Accesstypss 

ttEquivilem to dynunic wisMss tn other tanouages 
MUsed to dynamicsily sllocftt/deailocite storage at run time 

• TasKTypes-Designate tasks 

• Private Types ~ AtKtract data types 


B-40 


* X 





Basic Ada Types 2-18 



Student MotM: 



CONTROL STRUCTURES 


C-1 

• Strudurtd Progiimffling 

• SaqiMMiil 

• Conditionil 

• Itfritive 


STRUCTURED FROQRAMMINQ 



• A mtthodoiooied styH tor conttructino programi by eonmciing 
«Mli undontood conttrucu called control cinicturei 

• Three ditterent control itniCtureeariAiifticient tor writing any logic 
(BohA/4acopini ‘$4) 

••Sequence ( <i.'(eciitible stitamants 

••Oecleion diuie (it then elie) 

•• Iteration construct (While or until) 


C-2 



C-3 


Coituoi Strueturaa 3*1 




student Notes: 


BCNE^TS 


• UndersUndability 
e Modifdibility 
e Rtliibility 


SEQUENTIAL STATEMENTS 


• /tusignmtnt :» 

• Null null; 

e Block Statsmsnt 


BLOCK STATEMENT 


• Loaliztsdfdarations and/or sftKU 
e fonn 

dactire 

— tocNdadantivepart - OPTIONAL 
099111 

““ atannifniB 


end; 


3*2 Control Structures 





student Notes: 




with TEXT_I0: 
procedureFILL USTi.« 

MAX NUMBER; conilint100: 

type NUMBERS is range 1.. MAX NUMBER; 

package NUMBER JO it new TEXfjO.INTEGERJO( NUMBERS): 

UST SIZE:oomtant;-1000; 

typellST INDEX TYPE it range 1..UST SIZE; 

package INDEXjB is newTEXTJO.INTEGERJOl UST.INDEX.IYPE); 

t^ LIST.TYPE is amy( USTJNOEX.TYPE range <> ) of NUMBERS; 

LOWER BOUND, _• - 

v UPPER jOUND: USTJNDEX^TYTE:?«.LIST 

■heoifi . ‘ t ''v.';"~ t- - 

INDEX lO.erriLOWER BOUND): ^ - 

‘lNDEX3D.G£T(tfPf:r.l;pUND); : * ' 

declare 

LIST.OF.NUMBERS: LlST_rVPE( LOWER.BOUNO .. UPPER.BOUNO); 
begin 

for LIST ITEM in LIST OF NUMBERS‘RANGE loop 
NUMBER JO.SET( LfSTjOF.NUMBERSfLIST.ITEM)); 
end loop; 

for LIST ITEM in LIST OF NUMBERS'RANGE loop 
NUMBERJO.PUTf lTST j)F.NUMBERS(LISTJTEM)): 
endloop; 


end: -block statement 


end FILL.LIST; 


C-7 



Control Structures 3*3 




student Notes: 


C-8 


With TEXT JO; 
proctdura FILL_LIST is 



MAX NUMBER: constant -100; 

type NUMBERS Is ninos 1.. MAX NUMBER: 

package NUMBER JO is new TEXfJO. INTEGER J0( NUMBERS): 

LIST SIZE; constant1000; 

type LIST INDEX TYPUsnogt 1.. LIST SIZE; 

pickaoe INOEXjS is newTEXT.IO.INTEGlR.IOI LIST_INDEX_TYPE); 

type LIST.TYPE isarray( U8T.INDEX.TYPE range <>) of NUMBERS; 


LOWER BOUND. 

UPPERjtoUND; USTJNDEX_TYPELIST_INDEX.TYPE’FIRST; 


begin 

loop 

begin 

INDEX I0.6ET( LOWER BOUND); 
INDEXJ0.6n( UPPERjBOUND); 

exit; 


exception 

when others - > TEXTJO.PUT_LINEnilegal bounds, try again*); 
end; 


end loop, 


declare 

LIST.pF.NUMBERS: LIST.TYPE( LOWER.BOUND.. UPPERJOUN 



begin 

tor LIST ITEM in LIST OF NUMBERS'RANGE loop 
NUMBER JO.QHI LIST_5 f.NUMBERS(LISTJTEM) 
end loop; 


lor LIST ITEM in LIST OF NUMBERS'RANGE loop 
NUMBERJO.PUTI LrST_bF_NUMBERS(LIST_ITEM)); 
end loop; 


k 


end; -block suiemeni 
end FILL_LIST; 


3^ Control Structuros 


CONDITIONAL 


StiidMIt NoIm; 


C-9 

• Change control flow bucd on the value of in Mpmsion 

• Ifitatement 

• Caae statement 


IF STATEMENT 



N CONDITION tlwn 


•ndH; 

M ITEM < UST (CHECK) thwi 
TEMP :« ITEM: 
item :• UST (CHECK); 
UST (CHECK) ;• TfMP; 
•ftOH: 


C*10 


IF • THEN • ELSE 



N CONDITION tiMn 


•nri N; 

H rma « UST fCNECK) Him 
TEMP:- ITEM; 

rrSMi* LIST (CHECK); 
UST (CHECK) :r TEMP; 

•IM 

CHECK CHECK ♦ 1; 
POUND ;• FALSE: 

•nd H; 


C-11 


Control Structures 3<5 





StiKtontNotM*. 


JF - THEN - ELSIF - THEN 


mrM 



It CONDITION tlMf) 
IbtoM CONDITION thaii 


M ■ LOVILfmOfrnTY tt^tn 

•eUPRtOmTY.rUAO <L0W); 
fMMTEJJMIUIIEttAaE; 

■Mf MOSAGE K HIOHJNUOfllTY than 
ROUTEJNGKJaESSAGEi 
MCNRMENTJNGHXOUNT 


FULL IF STATEMENT 


H CONOmON tiMH 
.. MatwiMnU 


{r 

[*“. 


CONDITION tlwn'l 
■tatamcnu J 


• • lUltMMMU . 
nd It; 


CASE STAI’EMENT 



cam b 1 SC»ETE.EXPIiesSlON N 
«NimVALML 1 aO • • alalMiiwiN 
wNmi VALUC.2 •> • > 


• AIMmMlv* iiHWl tot nwluaNy 
meliMlw* and aahauaUaa 


y-i Control StrwoUiro* 











Studvnt NotM: 



CASE STATEMENT 


6ET_C0L0R (USER.COLOR): 
cueUSER.COLORis 

when RED -> INCREMENT COUNT ( PRIMARY.COLOR ); 

NUMSER.RECEIVEO NUMBER.RECEIVED -fl: 

when BLUE «> INCREMENT COUNT ( PRIMARY.COLOR ): 

NUMBER.RECEIVED NUMBER.RECEIVEC f1; 

when YELLOW •> INCREMENT COUNT ( PRIMARY_COLOR ): 

NUMBER.RECEIVEO NUMBER^RECEIVEO '•■1 ; 

when others -> INCREMENT.COURT ( SECONDARY^COLOR ); 

end case; 


C-tS 


case USER.COLOR is 



whM RED I BLUE I YELLOW-> 

INCREMEliT COUNT (PRIMARY.COLOR); 
NUMBER.RfCEIVEO :• NUMBER.RECEIVED ft; 

when others «> INCREMENT.COUNT (SECONDARY.COLOR); 


C'tS 


end case; 


ITERATIVE STATEMENT 


• NmHoii to ^Mloniwd Ming Um AM* toep wlitoh nn ba 
ttowMWI tor ANtoamt ktoba al toairtng 



•A8ICLOOP 


toop 

Mid toop; 


toop 

tAMPUXmC: 

UfDATEJTOTALS; 
«nd toop; 


Cotitrol Strueturws 3-7 




•tud«ntNetM: 


EXIT STATEMENTS 

• latM Siw tlNWffllMl •MIMIIII 0 kM^ 

• May have miMt^ aiH auitJiMnM 


Imp 

•AM^LLLIM; 
MAbATUOTALt; 
•■N WIIM AMWMIO; 
•••a ^ 


WHILE LOOP 


* laiaW ft Ha ItomliM 

'wMla OONOrriOlf IMP 

■ • • •UMMtMM 

* • 

wHN* Ml AOUNO Imp, 

MAIICHJ.IST (ITIM, UlT,.AOUnO|; 
ITBM !■ ITIM ♦«} 

HiS Imp; 


FOR LOOP 


• OifliNto llirtlion 

for LOOP.PARAMETER in OiSCRETE.RANQE loop 
> - lUtafninti 
wdloofi; 

fir COLOR m COLOR tYPf loop 
COLOR lO.PUT(CdLOR); 

NCXTjS.NE\^-LINE: 

wtfio^: 

(or INDEX in UST RANOE loop 
. TOTALTOTAL 4 UiT (INDEX): 

Mid loop; 


3»9 Control ttruoiuroo 




(•» MM an w iMI 
mH IwIim OONDITIONl; 
I- •M^Mwnlil 
Ml lMp( 







StiNtont N9tM 


SUBPROGRAMS 


• Modularity 

• Atntnction 

• intormitkMi Hiding 

FORMS 

• rtroctduf«> r ■ ' V- ." 

Abittactic£«n . . ' ' 

Invoked by a procedure call 

• Functions* 

- Returns a tingle value 

- An expression 

PROCEDURE PARTS 


S-1 


S*2 


Procedures are divided into two parts: 

• Specification 

- Defines interfaces 

• Body 

- Oefiries Impienwntation details 



Subprogremii 4>1 






I 




S 4 


SPICI^ICATIONS — DECLARATIONS 


• SpMifiMmcprocMurtncme 

• Uu()i ut pMkagu and lor tpacitymo vitibility witn ambaoatd 
procadumt 



^aamplf; 


prooidiira MASSIVE RETALIATION: \ Procatfurt 
preoadure ENABLE JCM; / Ooctarations 

preeadun ANSWER^PHONF la - ipacilicition part ot procadura 
bagin 

- implimaniaiion daiaiia 
and ANSWER PHONE. 


S-5 


5-6 


PROCEDURE ROOIE8 

• Procadura bodiataraiurtharbrokan down mio two parts 

• DacHraiiva Pan 

• Oadaraitami local to that procadura 

• latwNn *ir and’Oapin* 

• iMcuuOlaPirt 

- Conuina avacutabta ilatamatfii 

- Following 'Oagm* and through ‘and' 


PROCEDURES 


procadura STUfPjT ta 
> daotara coma ctuH-Dadarativa Part 

bagin 

- do aoina atuH - EaacuUibla Part 
and STUN IT; 

i 


4-2 iMbprogirama 



Studmt NoIm: 



PARAMETERLESS PROCEDURES 

• No information passed to or from the procedure 

• All information used is purely local 


withTEXTJOi 

procedure'3iSPLAY_MENU is 


S-7 


begin 

TEXT lO.PUTnil ENTER AN ITEir): 
TEXT'IO.NEW LINE: 

TEXTlO.PUTf(2) RETRIEVE AN ITEIT): 
TEXT'lO.NEW LINE: 
text' lO.PUTfiai CLEAR AU ITEM*); 
TEXT'lO.NEW LINE: 
end DISPLAY MENU: 


PROCEDURE CALLS 


• Invokes execution of corresponding procedure 



• Passes control to cMied procedure 

• Control passed back upon completion of execution 


with TEXT 10; 
withOISPLAY.MENU; 
procedure PROCESS ITEM is 
MAX OPTIONS: constam3; 
type OPTIONS is range 1.. MAX OPTIONS: 

CHOICE; OPTIONS: 

package CHOICE JO is newTEXTJO.INTEGERjO(OPTIONS): S-8 

begin 

DISPLAY MENU:-Controlpassed to DISPLAY MENU 
CHOICE ro.GET (CHOICE): 
case CHOICE is 

when1->_ • 


when2-> 

wlten3«> 


end case: 

endPROCESS.ITEM; 



4 


Subprograms 4-3 





•tud*nt Net**: 


PARAMETERS 

• A way to pass information to and from procedures 

• Enforcis S.f. principle of localuaiwn 

• Two kinds of subprogram parameters 

> FORMAL 
- ACTUAL 


FORMAL PARAMETERS 


• Defined in procedure ipecHicaiion 

• Octinas object names and types to be used locally In procedure 

procedure MASSIVE.RETALIATION (CODE; in STRING); 


ACTUAL PARAMETERS 


• Declared in calling program unit 

• Types of actual and formal parameters must be compatible 

with MASSiVE.RETALIATION, 
procedure RE^ONSE is 
MAX ECM LEVEL:constant>5; 
typelCM LEVEL TYPE is range 1..MAX ECM LEVEL. 

MV CODE: conettfit STRING; - -BLASTEM'; ~ 

my"LEVEL:ECM LEVEL TYPE3: 

procedure ENABlT ECM (lEVEL: in ECM.LEVEL.TYPE) Is separate: 

begin , 


MASSIVE.RETALIATKM (MY.COOE); 


ENA8LE.ECM(MY.LEVEL); 

« 

end RESPONSE; 


Suttprograma 




Studefit NoIm: 



PARAMETEn MODES 


• Procedure formal paraiKSters have l<trMii)9v«blt modes 

- if>~-actut! parsmeiera tend Mcrmation to the calted 
procedure (treated sa constar.t) 

- out—actual urametere receive informilion front the called 
procGdura (can only be updated) 

- in out^ctual pammelera eend and recefs^e totormaiion from 
the cailad proo^ure (‘^ted aa objectfi) 

- If no mode ia stated in the (ormal part, then V la used «s 
the default 


S-12 


wlthTEXT^IO: 
procedure"PUT_N_GET is 

MAX_INT; consunt;« 100; 

type MY INT is range 1 ..MAX INT; 

packagelNT^IO is new TEXT,J0 .INTEGER.IO(MYJNT): 

INT^I, INTJ: MY^INTMY_INTTIRST; 



procedure EXCHANGE (FIRST. SECOND; in out MY INT) is 
TEMP :MYJNT:-FIRST; 
begin 

FIRST;-SECOND: 

SECOND; TEMP; 
end EXCHANGE; 


begin 

INT I0.GET(INT 1): 
INTJO.GET(INTJ): 

EXCHANGE! INTJ. INTJ); 

INT I0.PUT(INT 1): 
IMTjO.PUT(INTJ); 

endPUT.N_6ET: 



Subprograms 4>5 



3tudtnt Notts: 


S-13 


S-14 


FUNCTIONS 



• Differtnt than proctdures 

- Return a single va**ie 

- Must have a return statement (optional with procedures) 
> Called as an expression 

• Only has "In* inodes ^ 

t Same as procedures 

- Has s speciticadon arid a body * * 

- Enforces S.E. principles • - 


STRUCTURE • 


• Specification 

- Defines interlaces 

function END_OF_FILE return BOOLEAN: 

t Body 

- Implementation details 

- Must have a return statement 

function END_OF_FILE return BOOLEAN is 



begin 


if_then 

return TRUE; 
else 

return FALSE: 
end if; 

endENO OFJILE: 



4-6 Subprograms 






Studtnt Notes; 


PARAMETERLIKSS FUNCTiONS 


• AH information niwded is local tri *\;i\ function 


S‘15 

hiiictlon HCSTILE Tstum BOOLEAN; 
function WEAPON.ARMED rstum BOOLEAN; 
fimction NUMOtR.BOGEYS rstum BOGEY.COUNT; 


. - FUNCTION CALLS 

'• • OaiTedas-an•_C!?: .t 


BOGErS NUMBER BOGEYS; 
if HOSTILE than 
If WEAPON ARMED then 
FIRE.WEAPON; 
end if ; 
andit; 


FUNCTION PARAMETERS 

• Can only be of mode‘'in' 


AMRAAM: WEAPON TYPE; 

CLOSEST BOGEY: BiOGEY TYPE: S-17 

function HOSTILE (BOGEVTbOGEY TYPE) return BOOLEAN is separate: 
function WEAPON ARMED 

(WEAPON ;/n WEAPON .TYPE) rstum BOOLEAN is Mpsrate: 
begin 


H HOSTILE (CLOSEST BOQEV) tfM 
H WEAPON ARMED (AMRAAM) then 
FIRE.WEAPON(AMRAAM); 
etidif; 
end It; 


Subprograms 4>7 




student Notes; 


PACKAGES 


• Allow the spscif ication o) groups of logially rstatad sntitist 

e S(mpNforn>~;ollictionofdiN(NGikriti^ 

e Gsnsnl forn>-~g(oups Of raPtrid sntititt mduditio subprograms 
which can ba calM from ouUide tha paekaga whUa Imar datalls 
remain concealed and protected 



P-2 


STRUCTURING TOOL 


• Packages allow us to parbdon up the solution space into logically p .3 

distinct, self-contained components 

• A different structuring capability from the traditional use of itosting 
and independent compilation 

• Diflerent topology 


Packao*' 5*f 














ttU0MltNolM: 



• fsmm MuenT sumiT usnueiMK. 
mtmmtm okm. um laemzAiMH 



• PicUQW pro^ a tictmy tor pfpflfwsing towird IN de v U p p mtn t 

i (rf I reusable icmwarecomporkantximkistfy 

• Ditterent approach front current practice « 

t# 



Paekagee S*3 




itu<J«nt Netott: 


PACKAGE STRUCTURE 

• VttiMt put - PadUQ* Spttificition 
pari ■> Paetagt Bod, 

-SwmillinM Optional 

~ Sopuuily CompUMblo 

PtCMK mCfflMTioM 

« mn DRinULMMi If M MU w mt rMMK 





p.12 


pacMot aaATWX-PACKASE ii 

ACCUBACY ; canaUnl 15. 

MAXJiMTriULSiZE: conatam: - 10. 

lypt REAL la OigiU ACCUnACY; 
typa MATRIX INDEX TYPE «ranot 1 .. MAX MATRIX SIZE. 
typiMATRIXjLEMENTP.TYPE la array (MATRIX INDEX TYPErui«a<>. 
.aiATRIXJNOEX.TYREiinpa <> )olREAL. 

MATRULTVI^I MZE: MATRIXJNDElLTm • 2) N racord 
ILIMMITS: MATR4XJLEMENTt.TYPE( 1.. SIZE. 1.. SIZE): 
and raadrdf 

iMtOtlon ADO (EIR8T, SECOND: MATRIX.TYPE) ralum MATRIX-TYPE: 


MflCIlon SUBTRACT (FIRST, SECOND: MATRIX-TYPE) nium MATRIX.TYPE; 


lun^ MULTIPLY (FIRST, SECOND: MATRIX.TVPE) return MATRIX.TYPE. 
andMATRIX.PACXA6E, 





«i«iMATIUX_PACKAGE: 
jf«Ci*in iJSER ili 


MYJUTWX IIATROLFACOGE.MATJIOLTYPEO); 
YOUfLMATRIX :|MTRIXjPACICA6E.liMiTR0LTY?E(3); 
ANCTHERJAATmX: MATRIX.JMCMff .MArfUX.TYPE(3): 


IggHl 

YOUfLUATHIX aSMENfS :» (0«w»->->2.6)): 
ANOTHBLiM7IIIX.ELEIKNTS :• (Mim - > (OMn-> 4.0)); 

||Y.JMYfW( :« l(U1IIOCPACKAGe.AOO (VOUR-MATRIX. ANOTHEILMATIIIX): 

ANOTHDLMATfUX MATRULPACKAGE.MULTIPkY (MY-MATRIX. MYJ4ATIUX); 



P-13 


PACKAGE BODY 


• ItflMdMlCOnUlftf 

- BodiM of unMi OkM In YpMifiaO^ 

--Any oftwr tfKiaralioni Hiodid (liim Iff iM 



flNMtolU Kot««; 


P 15 


»Mliag« k(4y MATK1S.PACKA0C HI 

iMMUon AGO (riMT. SICCMC t4ATRIX.TYrE) rMurn MATRdlTYPE « 
IfMPJMTRm; WATRMLTYPSiFtRCT.SIZE) 
l^gtn 

Hw MMlLt m FIKST EUMENTS'llAiMEd) looff 
lor MOCX^ m FIRST ElfMeilTt‘RANtt(F) H)op 
TEMPJlUTrjXELEIIEIITfMINOE]Lt.lNOE)L2) > 

FWST.EUIIEMTSltNDEX.1. iNDCXJ) 
KCONOELEMENTSdNOEX.!. MOEX-2) 

OHilOOO; 

CMIOip; 

Mlwo TSMPJMTMX; 
mi too . 



mmm IUITRACT t FMUT. Mt C ORO: MATROCryPC I Mum MATRULlVFf » 
YSMP .MATRIX: MAVRlX.TYn(nRr.llZE), 


lor MOCX. t« FIRST ELEMCNTtRANGEn) Mo 
lor MOOLI m FMST llEMEIITt‘11^12) Mo 
TIMPJMTRIX IIEMCIITMMOOLI.MOEXJ) • 


FIRST ELEMENTSimOOLI lliOE)L2) 
SkCOM) EUMENTSIINOCX-I IIIOEX-2) 

oNdMo. 


MmuT^ MATRIX 
OMSUOTRACT. 


OMIM MIILTIPIY (FMr. SECOND MATRULTYFt) toMm IMTr4X.TYfC « 


TIMPJMATRIX MATRIX.TYOflOmST SI2EI. 
SUM REAL -00. 





Mr MOOLI • FMr EtiMCNTSHANQCd I MO 
Mr MOOLI 01FMT .ELEMOfTt flAlMCa) Moo 
SUM •0 0. 

Mr MOOD M FMT EiaffUTtHAIlOEa) Moo 
SUM -SUM • 

FMT ELIMilfTMMOEX.t MOEX.3 ‘ 
KCONO ELEMENTSiMOfX J) MOfX-2) 

•NO MOO. 

TEMrMATRIXEUcMENTI<MOOLI.MOOL2l - SUM 


MMmTBMJMTIIIX. 

OMMUITTRIV. 

iMMATIIOLMCMif. 


s-e PoBiMgoo 




StudMitNoiM; 


PRIVATE TYPES 

P-16 

• AHowttoMirAionotpofwwIuiibstfaditiaM 

• OtUnid in the priwM portion ol til pMkaptipMilki^ 




• PrivUi 

—PrvwPiopoiiliOM:* - /« 

—Pniim MPpioii— iRnUiiipwimn »icHc<loi 


iMhlll fensniLMlHNS • 


Kpo m M KWI iiKil ..MMLMMKR: 


OMMiMM IMI AJIM«: in MMHK); 


•iiO MSKINJIOIIMS: 


P-lt 



StutfsntNcMM: 


P 19 


P-20 


P-21 


pacMpt tody BASKIN. ROBeiNS IS 

NUMBEfLHOLOER NUMBERS > NUMBERS flAST. 

prOMdura 6ET.NUMBER i NEX'T..NUMBER out NUMBERS ) is 

'nScTJIUMBER - NUMBER.HOll;)ER. 
NUMBEfLHOLOER NUMBEfLHOLOER * 1. 
todOrjIUMBER. 

iiMaion NOW.SEflVING raiilfn NUMBERS if Mtorilc 
pratodiira SERVE ( AJMMBER : M NUMBERS) s itoanti. 
•idBABKINJIOBBINS; 


M«i BASKiN.ROBSlNS: UM BASKIN .ROBBINS 
prootdyri CC.CREAM it 

YOURJiUMSER: BASKIN.ROBBlNS.NUMBERS 

tapm 

BASKMUIOSBINS GET-NUMBER( YOUR.NUMBER S 
Mop 

M VOURJftMBER • NOW-SERVING Olto 

BASMLMBBWS SERVE! VOURJIUMBER). 

•nt. 

tod it: 

•to loop. 

oto ICE-CREAM. 

todiBASlONJIOBBlNS. 
pwcodito CLXREAM « 

VOURJIUMBER BASKIN-ROSBINS NUMBERS 



IASXNLMBBWS GET JRMBER! YOUR-NUMBERI 


BABWN-ROBBNIt KRVli VOURJIUMBER I 

•to; 

VOUILNUMBERVOUfURJMBER • 1. 

•tod; 

•to loop 
•to ICE-CREAM; 




S-B Pacliag«s 







BtudmrtNotM: 


m 

ptckao* BASKIHLAOMINS it 
lyptNUmCRSitpitMii: 

praoidiin QETJNMIBERi NEXTJNJMBER: out NUUaERS): 

iMiclioa IKMVJIERVIIIG lotuni 

prooM (AJIUMKR: to NUMKRS): 

pnvni 

MAXJNJMBEII : COOtoMt100: 

(ypo NUMIEftS to IMOO 0.. MAILNUlia^ 

mOMSKIILRQIIINS: 


«i» SASMIUIQIIINIS: UOtMSniLtoCM^ 

prooiduralCLXREMlto 
YOUfLNUMKA: IMWHJIOWWff.WUMeCRS; 


NYlHjajIUMKR « NOlllLSRVRKtoM 

i.mtoccfniW'Mrw k 


wdN: 


«to ICE-CREAM: 




Student NotM: 


P-24 


P-25 


packigc BASKIN.ROBBINS is 
type NUMBERS IS limiled private. 


procedure 6ET.NUMBER( NEXT.NUMBER out NUMBERS) 
(unction NOW_SERVIN6 return NUMBERS 
function 1S.EQUAL (LEFT. RIGHT; NUMBERS) return BOOLEAN: 
procedure SERVE (AJfUMBER: in NUMBERS): 

privMe 

MAX.NUMBER: constant: - 100: 
type NUMBERS is nnge 0.. MAX.NUMBER: 

endBASKtN_R06BINS. 


wtnBASXtN-ROBBINS: 
procedure ICE. CREAM is 

YOUR.NUMBER BASKIN ROBBINS NUMBERS 

procedure GOTO DO is separate. 

beyin 

BASKIN.R06BINS GETJtUMBERI YOUR.NUMBER): 



loop 

If BASKIN.ROBBINS IS.EOUAL( YOUR-NUMBER 

BASKIN ROBBINS NOW.SERVING ) inen 


BASKIN ROBBINS SERVE! YOUR-NUMBER). 
ein; 

eiae 


GOTO DO. 
ant. 


•rBN: 
end loop: 
•ndtCE-CREAM: 


tb 


5-10 Packagts 





Student Notes: 



APPLICATIONS OF PACKAGES 


e Namsd collections of entities P-26 

e Groups of related subprograms 
e Encapsulatsd data types 


NAMED COLLECTION OF ENTITIES 


package METRIC.CONVERSIONS is 

CN_PER_INCH : constant :■ 2.54; 
CM.PER_FOOT : constant :»12’CM.PER.INCH; 
CM.PER_VARD : constant3*CM.PER_F00T; 
!(M.PER_MILE : constant :«1.609.344; 

end MnRIC.CONVERSIONS; 

(0 


GROUPS OF RELATED SUBPROGRAMS 


e Visible declarations of extsrrwIiyusaNe subprograms 
• Hidden implernentation/shared mtsmai entities 


ENCAPSULATED DATA TYPES 


• Define abstract data typu 
e Privirta/lifnited prNite types 



Pacheges S*1i 



Studtnti Motet; 


EXCEPTIONS 


• Purpou 

• DidirlnsExosptiomi 

• Exctptlon Hinditn 

• RfiMng Exeiptioiii 

• PraptgiUon 


E-1 


REUABIUTY 


• AerlllcMilimtntotrinivmittkmc^ E-2 

• AtradWoftilpraUMnifit 

• Lift and proptf^dtptndMtolltrara 

ERRORS HAVE OCCURRED. DO OCCUR. AND 
WILL CONTINUE TO OCCUR! 



Excopttont ••I 



StudMrt NotM: 


UNDERSTANDABILITY 


• Much of the cede «»ritten/rwd deals with abnormal circumstances. 

• To grasp the meaning of a section ot code, a maintenance 
programmer must sort through the abnormal to find the mam 
meaning. 

• Ttiidltional languages lack the ability to deal with normal and 
abnormal as distinet futuras. 


DEFINITION 


E-5 


• An "exception” is the name attached to a particular exceptional 
situation, user-defined or predefined. 


• When the particular situation occurs, the exception is said to be 


"raised." 

• The response to the raised exception is called the excepbo 
"handler.' 



PREDERNED EXCEPTION 


E-6 


PACKAaE.8TAIilOARD 

• NUME»ICJERR0H 

• COKSTRAINT^ERROR 

• RViOlWyyLERROP. 

• tTORASEJRVIOR 

• TASKIIMLERROR 


• TeXT_K> 

• OATA_ERROR 

• USE.ERROR 

• NAIi£.iRROR 

• STATUSORROR . 

• MODEJRROR 
e ERD.ERROR 

• LAVOUT.ERROR 

• UEyiCE.ERRUR 


6-2 Exeoptjosia 



StiMtoni NoIm: 



DECLARATION 

An txciption CM be dcdircd in my dcciantivt ptrt 
« lollowe tN lame vWWMIy ruiw « any other dfdifil^ 


• Form 


OUT-OF-tiMiTS ; except len: 
RANGE.EfIROIt : exception; 
8TACK.0VERFL0W : exception; 



ptckage INTEGER.STACK ii 

MAX.KUMBER COnitint :• 10.000; _ 

type NUMBERS it range .MAX.NUMBER .. MAX.MUMBER; 
type STACK-TYPE it private; 

procedure PUSH (A-NUMBER : in •von ■ 

ON : in out STACK.TYPE): 

(A.NUM8ER : out NUMBERS; 

OPF.OF : in out STACK.TYPE); 
except Ion; 
exception; 


procedure POP 


STACK.0VERFL0W 

STACK-UNOERFLOMT 

private 


end INTEOER-STACK: 


FRAME 

• Conatniet uaod to eapture oxeepMoni and dMiare oxeopiion 
handlers 



edian eaciption.Bheiee 0 dtsaiilidi^^ 
•oquonodjiLattlMiants 


excatNKMichoico:;* axceplioiuianwi others 



student NotM; 


EXCEPTIOK HANDLER 


•D 


• Optloftti part ol I Irame that can contain responses to exceptions 
raised in the frame 


E*to begin 

-statements 

MCSptiOfl 

when DATAJRROR - > - statements 
when CONSTRAINT^RROR - > - sUtements 
e-hen others - > - statements 
and; 


PROCESS 


EH 


E-12 


• When an exception is raised within a frame, processing 
immediately suspended. 



• What happens next depends on the presence or ePsenct of an 
appropriate exception handler. 


- Handle exception within an exception handier 

- Profwgate exception 


fUUSlHO AN UCEPIKM 


• Can be raised impiicilly by the run time system 

• Can be raised explicitly by use of the raise sursmeni 

raise EXCEPTI0N_NAME 



d-4 Eaeapltena 



StudMit Notes: 


pickagi SIMPLE.STACK it 

type STACK.TYPE is limited private: 
subtype ELEMENT.TYPE is CHARACTER: 

procedure PUSH (A.VALUE ; in ELEMENT.TYPE: 

A.STACK : in out 8TACK.TYPE); 

procedure POP (A.VALUE : out ELEMENT.TYPE: 

A.8TACK : in out 8TACK.TYPE): 

8TACK.0VERFLQMi. STACK.UNDERFLQW : exception: 

private 

MAXIMUM.SIZE : CONSTANT SO; 

type STACK.SIZE Is range 1 .. MAXIMUM SIZE; 

type LIST.TYPE it array (STACK-SIZE) of 

ELEMENT.TYPE: 

type STACK.TYPE is 
record 

LIST ; LIST.TYPE: 

CURRENT.POSITION ; STACK.SIZE t; 
end record; 

end SIMPLE.STACK; 


package body SIMPLE.STACK is 

procedure POP (A.VALUE : out ELEMENT.TYPE; 

A.STACK : in out STACK.TYPE) is 

beg i n 

A.STACK.CURRENT.POSITION :• 

A.STACK.CURRENT.POSITION • t; 

A.VALUE A.STACK.LIST (A.STACK.CURRENT.POSITION); 
except ion 

wlian CONSTRAINT.ERROR » 
raise STACK.UNOERFLOW: 
end POP: 

procedure PUSH (A.VALUE ; in ELEMENT.TYPE; 

A.STACK : in out STACK.TVPE) is 


boo in 

A.STACK.LIST (A.STACK.CURRENT.POSITION) A.VALUE; 

A.STACK.CURRENT.POSITION 

A.STACK.CURRENT.POSITION 41; 


except ion 

when CONSTRAINT.ERROR •> 
raise STACK.OVERFLOiN: 

end PUSH; 


Excoptiont 6*5 



E-15 


Student Notes: 


with TEXT.IO. SIMPLE.STACK; 
proctdurt STACK.USER is 

packagt COUNT.10 is new TEXT.iO.INTEGER.10 

(LONG.INTEGER) : 

MY.STACK : SIMPLE.STACK.STACK.TYPE; 

COUNTER : LONG.INTEGER 0; 

bap in 

loop 

SIMPLE.STACK.PUSH (‘i’, MY.STACK); 
COUNTER COUNTER 1; 

•nd loop: 

except ion 

when SIMPLE.STACK.STACK-OVERFLOW -> 
TEXT.IO.PUT CPuihed *) ; 

COUNT-10.PUT (COUNTER); 

TEXT.IO.PUT.LINE (* times'). 

end STACK.USER: 


64 Exesptlons 




GENERICS 







Purpose 

Generic Declaration^ 
Generic Instantiations 
Generic Parameters 


G-1 


GOALS AND PRINCIPLES OF SOFTWARE 
ENGINEERING SUPPORTED BY GENERICS 



• Reliability 

• Understandability 

• Modifiability 

• Efficient 


• Modularity 

• AMraction 

• Localization 

• information Hiding 


' 6*2 


Wiwt M Software Reusability? 

Wtiy la fleusafaity i mportant? 

Who should be concerned with Reusability? 


6-3 



Qeneries 7-1 



Studtnt NotM: 


G-4 


procedure OUP JCATION is 


A 


type PERSON is 
lypeTAPli is .. 
ty^COUNT is.. 
typeKAME is... 


pnsceduri SWAP-PEOPLE (LEFT. RIGHT: in out PERSONS) is 
TEMP :PERSON:-LEFT; 
begin 

LEFT :• RIGHT; 

RIGHTTEMP; 
endSWAP-PEOPLE; 

procMKife SWAP.TAGLES (LEFT, RIGHT: in out TABLE) is 
TEMP :TA8LE ;-LEFT; 
begin 

LEFT ;• RIGHT; 

RIGHT - TEMP; 
end SWAP-TABLES; 

procedure SWAP-COUNTS (LEFT. RIGHT ; in out COUNT) Is 


procbduri SWAP-NAMES (LEFT. RIGHT ; m out NAME) is 
begin 


end DUPLICATION. 



generic 

type SWAP-TYPE is pnvate. 

procedure GENERIC-SWAP (LEFT. RIGHT : in out SWAP-TYPE); 

( 1.5 procedure GENERIC-SWAP (LEFT, RIGHT ; in out SWAP.TYPE) is 

TEMP :SWAP-TYPE: - LEFT; 

begin 

LEFT RIGHT; 

RIGHT:-TEMP; 
end GENERIILSWAP; 



7-2 


Gonnrics 



student Notes; 


with GENEAIC^WAP; 
proesdure NOOUPLICATION is 

typt PERSON is... 

TABLE is... 

^ COUNT a ... 
typsNAME it... 

procwlurt SWAP-PEOPLE it tmi GENERIC-SWAP (SWAP-TYPE - > 

PERSON)' 

pracMiura SWAP-TABLES it Otw QEHERICJSWAP (SWApItYPE - > 

TABLE): 

proewtur* SWAP-COUNTS is tmrn GENERiCjSWAP (SWAP-TYPE - > 

COUNT): 

praettiun SWAP-NAMES it mu GENERIC-SWAP (SWAP-TYPE -> 

NAME); 

begin 

end NON.DUPLICATION: 



G-7 



DEFtNmON 


G-8 

• A generic is a template tor a program unit. 

« 

• Instantiation gives us an actual program unit from that template. 


Generic« 7>3 








Student Notes; 


GENERIC DECLARATIONS 



• Two Classes 
—Generic Subprograms 
genertc 

—GENERIC FORMAL PARAMETERS 
procedure (function)... 

~ Generic Ptckages 

generic 

~ GENERIC FORMAL PARAMETERS 
package. . . 


G-10 



GENERIC INSTANTIATION 


• Creates an actual instance of a generic unit 

• 'fills In' the generic formal parameter with an actual parameter 


GENERIC PARAMETERS 


• Type 

G-11 e Value 

• Object 

• Subprogram 



7-4 Generics 



Student Notes; 


MATCHING RULES 


type IDENTIFIER is digits <>: 

type IDENTIFIER is deluo; 

typ« ICENTIRER is nnge <>; 

typetDENTIRERislo): 

type IDENTIFIER is vny 
|INDEX_TYPE) of 
COMPONENT.TYPE; 

type IDENTIFIER is irrjy 
(INDEX_TYP£ range <>) of 
COMPONENT.TYPE; 


Any floating point type 
Any fiud point type 
Anyintegriypt 
Any discieia type 

Any constrained array type onth ume 

INOEX>TYPEand 

COMPONENT.TYPE 

Any unconstrained array type with 
tame INOEX„TYPE and 
COMPONENT.TYPE 


G-12 


MATCHING RULES (Continued) 


type IDENTIFIER is UXtSS 
NAME; 


type IDENTIFIER is private; 

type IDENTIFIER is limited 
private: 

OBJECT; in TYPE.NAME; 


OBJECT: in out TYPE_NAM£; 


with procedure NAME 
(PARAMETERS) 
(isolisDEFAULTJiAMEl: 

with function NAME 
(PARAMETERS) 

(is <> I is DEFAULTJfAME): 


Any access type that designates 
same NAME t^ (subject to 
constraint rule) 

Any type except a limited type 

Any type 


Value or obiect that is of same 
typeasTYPE_NAME 

Object that is ot same type as 
TYPE.NAME 

Procedure that conforms to 
parameter numbtr and types 


Function that conforms to 
parameter number and types and 
hu same result type 


G-13 


Generics 


7-5 




student Notes: 


gene r ic 

type ELEMENT.TYPE is private 
S12E_OF-STACK : in POSITIVE; 


package BO'JNDEO-GENERIC-STACK 

type STACK.TYPE it limited p 
procedure PUSH (AN.ELEMENT : 

ON : in out 
procedure POP (AN.ELEMENT 
OFF.OF : in 

privatc 

type STACK-COUNT is range 0 
type STACK-ELEMENTS is array 

0 I 

type STACK-TYPE is 
record 

TOP . STACK-COUNT :* 
BOTTOM : STACK-COUNT 
LIST STACK.ELEMENTS 
end record 

end BOUNOEO.GENER1C.STACK; 


I s 

rIva t e. 

in ELEMENT-TYPE; 
STACK.TYPE ) . 

; out ELEMENT.TYPE 
out STACK.TYPE); 


SIZE-OF.STACK . 
(STACK.COUNT ) 
ELEMENT-TYPE 


0 
1 : 


7*6 Generics 




Studant Notts: 



G-15 


with B 0 UNDED_ 6 ENERIC_STACK 
proctdura DEMO.STACK is 
LENGTH : constant : • 80 : 
subtype NAME-TYPE is STRING (t LENGTH); 

Dickaoe NAME-STACK is new BOUNDED-GENERIC-STACK 

(ELEMENT-TYPE -> NAME.TYPE. 
SIZ£-OF_STACK »> 1001: 

STACK-OF-NAMES : NAME-STACK STACK-TYPE: 

begin 

tnb OEMQ-STACK; 



6-16 


GENERIC BODIES 


• Generic Formal Parameters 

• Writing Generic Bodies 


GENERIC FORMAL PARAMETERS 


iTescribes two things: 

• Matching requirements tor actual parameters 

• Operations that can be assumed within the generic body 



Canaries 7-7 






5)?iid«nt Not»t; 


•O 



flsnufic 

lype iNTEGER.TYPC isranje <>; 
procedure NEXT (ANY.INTEGER : m out INTEGER-TYPE); 

procsdure NEXT (ANY.INTEGER : m out INTEGER-TYPE) s 
bedin 

ANYJNTEGER ■ ANY.INTEGER + 1: 
exception 

when CONSTRAINT.ERROR - • - 
ANYJNTEGER - INTEGER.TYPE'FIRST: 
end NEXT 



G-T9 


generic 

lype mSCRETE-TYPE »(<>): 

procwturi NEXT (ANY J)ISCRETE.VALUE: in out OiSCRETE-TYPE); 

procedure NEX)' (ANYJ)tSCRETE.VALUE: In out OISCRETE.TYPE) N 
begin 

-"+‘’NOT AVAILABLE 

ANYJ>ISCRETE_VALUE DISCRETE-TYPE SUCC (ANY.DISCRETE-VALUE): 
exception 

wiien CONSTRAINT.ERROR - > 

ANY-DISCRETE_VALUE « DISCRETE-TYPE'FIRST; 
end NEXT 



G-20 



7-8 Oenorict 






Stuctcnt N 0 tM: 



GENERIC BODY 


6*21 


• Defines implementition of the generic unit 

• Can use operations available from the generic formal parameters 



USING FORMAL TYPE 
PARAMETERS 

Specify which operations are available for the type 


6-23 


mOMPTtin STRING; 
type ANY-INTEGER-TYPE it range • - ; 
procedure GET.VAIJDJNTEGER (AN.INTEGER out ANYJNIEGER.TYPE); 




Generics 7*9 


Student Notes: 


6-24 


wilhTEXT_lO, _ 

procedure GET.VALID. INrEGER (AN. INTEGER ooi ANY. INTEGER.TYPEl is 


package INTJO is new TEXT.IO (NTEGER-^IO (ANY .INTEGER.TYPE; 

begin 

loop 

begin 

TEXTJO.PUT(PROWPT): 

SNTJO.QET (AN.INTEGER); 
exit: 

exception 
when others > 

TEXT.IO.SKtP-LINE; 

TEXT.IO.PUT.LINE ('••INVAllD'-) 
end: 

end loop: 

end 6ET.VUID. INTEGER 


0 

generic 

SIZE in NATURAL, 
type ELEMENTS is private 
package STACKS is 

lype STACK TYPE is Imined pnvjie 

procedure PUSH (STACK in out STACK 'YPt 
value in ElFMENTSi 

procedure POP (STACK moul STACK TvPi 
VALUE ouiElEMENTSi 


G-25 


private 

Stack siredelermmen dv 
-• generic value parameier 
type NUMBER..OF.ELEMENTS is range 0 SIZE 
type ELEMENT .ARRAY is array (NUMBER.OE ELEMENTSi 

ol ELEMENTS 

iypeSTACIL.TYP£is 

record 

DATA ELEMENTJERRAY 
TOP NUMBER.OF.ELEMENTS 0 
end record, 
end STACKS, 



7-10 Generics 






student Notat: 


generic 

type ELEMENTS is private: 
type INDEX «(<>); 

type ARRAV.TYPE is array (INDEX) of ELEMENT: 

with function ’<' (LER. RIGHT: ELEMENT) rtium BOOLEAN: 

procedure SORT (LIST: in out ARRAY.TYPE); 

procedure SORT (LIST; in out ARRAY.TYPE) is 

TEMP: ELEMENT; ‘>■26 

begin - SORT 

tor OUTER in INDEX'tirst..lNOEX‘pred(INDEX'last) loop 
for INNER tn INOEX'succ(OUTER)..INOEX'last loop 
if LIST(INNER) < LIST(OUTER) then 
TEMP ; - LIST(INNER): 

LIST(iNNER)UST(OUTER): 

LIST(OUTER)TEMP, 
end if. 
end loop: 
end loop: 
end SORT: 


Genorics 


7-11 




Studftnt Notes', 

TASKS 

•o 

• Purpose 

• indepenPeni Tasks lA 

• CofTimumcatiriQ Tasks 

• TaskinQ Statements 


i 

j 


TASKS 



. - A tMk ta ari anlUy tn«« oparata* In 
parallal with othar antitiaa 

. - TaaWnp may ba Wnpiarrianlad on 
•. Sinpla Procaaaom 

• . MultH>rocoaaem 

• . Mulli<ompuUm 


T-2 



TASKS 


• Important aspect ot embedded systems 

• Netjlected in most Unguaoes currently in pi oduction use 

—lack ot confidence in control of parallelism 
— Low level feature 

• Need an implemenlation independent model 

• Ada draws up operating system features into the language 


•€ 

Tasks 8-1 



Student Notes: 


ADA TASKING MODEL 



T-4 


(Communicating r.ci.uentia! Processes) 

• Petri Net Graphs 

- Used as a tool to explain tasking model 

• Parallel Independent Processes 

- 'Simple” form of tasking model 

• Communicating Sequential Processes 

- 'Fu<l” Ada tasking model 


( 



T-5 


PETRI NET GRAPHS 
ei Ti ea n w Tj m t4 

oiorotai 

P5 


( 


PETRI NET TRANSITION RULE 


T-6 



Take one token from each of the enabled transition’s input places; 
deposit one token in each of the transition s output places 


i 


8-2 Tasks 



Studtnt Notts: 


CONCURRED. •ETRI NETS 
• IwS Ml th« Mm €4 • fork, to crool* • not* 
t l ir o oS of oonirol 



• tor 0 smsoot to OMf, R ohmI lolum bock to om 

ifwwi nifwi 



PARALLEL INDEPENDENT PROCESSES 

• No eomwomtoHoo, fio wiiRo r rom 

• Pronoi tliot otoite oltiofo NMot woil tor oN tw oomp t oto 




T-7 




Tasks 8*3 




Student Notes: 



procedure MAIN is 

task Ti, 

■>>kT2; 


T-10 


task body Ti is 
begin 
null: 
endTI. 

task body T2 is 
begin 
null: 
endT2: 

begin 

null: 

end MAIN. 



with TEXT JO; useTEXT.lO. 
procedure TASK-EXAMPLES is 

task PLAIN; 

task WITH.L0CAL_DECLARATI0NS; 

task body PLAIN is 
begin 
null: 

end PLAIN; 

taSK body WiTn.LOCAL_UeCLAKATiONS is 
FORE^R; constant STRING ;* ’forever'; 
begin 
loop 

PUT.LINE ('This task puts this message out"); 

PUT (FOREVER); 

NEW.LINE; 
end loop. 

end WITH-LOCAL-DECLARATIONS: 
begin 

— both tasks activated here 

null, 

— This subprogram does not terminate execution until 
all dependent tasks are ready to terminate 

end TASK-EXAMPLES. 


T-12 



procedure MONITOR-GATE is 

tesk WATCH-HEAT-SENSOR: 
task WATCH-SOUND-SENSOR: 

procedure SOUND-ALARM is separate: 
task body WATCH.HEAT.SENSOR is separate: 
task body WATCH.SOUNO.SENSOR is separate; 

begin 

— tasks are activated 

null. 

end MONITOR.GATE; 


8-4 Tasks 





ttiMtont Netta: 





separate (MONITOR-GATE) 

\aSK bofly WATCH.HEAT.SENSOR (S 

lunctloft OfTECT.HEAT return BOOtEAN ts sepiritt. 


begin 

loop 

WO^CT-HEATthen 
SOUNOJtlARM; 
ind it; 
end loop; 

end WATCH-HEAT-SENSOR; 


M3 

.1 


j 


sepirete (MONITOR-GATE) 

task body WATCH.SOUNO-SENSOR » 

function OETECT-SOUND return BOOLEAN isMbStste, 


begin 
. loop 

i< DETECT-SOUND then 
SOUND-ALARM, 


end It; 


end loop: 

end WATCH-SOUND-SENSOR. 



COMMUNICATING TASKS 


• Ada Tasking Model 

• Rendezvous 

• Task Entries 

• Communication Process 



To»ke «*5 




student Notes: 



T.16 


( 


TASK COMMUNICATION 


Ada Tasking Model: 
Communicating Sequential Processes 


T-17 



I 

I 


RENDEZVOUS 

Task A; Taak B; 



RENDEZVOUS 


e The process in which two parallel tasks synchronize and optionally 
communicate 

• A rendezvous is the interaction that occurs between two parallel 
tasks when one task has called an entry of the other task and a 
corresponding accept statement is being executed by the other 
task on behalf of the calling 'ask 


9 


8'6 Tasks 









Student Notts: 


RENDEZVOUS 

OaOMt In th« «p*cWc«tlon o< • task 

Dalin* th« eammunkatien pallia to a laak 

Aro eallad troin outakta a laak whan tha collar ariahaa to 
eommunicato with a taak 


T-19 



TASK ENTRIES 


task PRINTER_CHANNELiS 
entry PRINT (JOB; in LISTING.TYPE); 
end PRINTER_CHANNEL; 

task Cl OCK is 

entrySET.TIME (CURRENT.inTIME); 
entry GIVE,TIME (CURRENT: out TIME); 
end CLOCK: 



task LAUNCH.BOMBERS is 
entry LAUNCH, 

entry FAIL.SAFE (CODE; in PASSWORD), 
ends LAUNCH.BOMBERS; 


COMMUNICATING WITH A TASK 


Tasks are communicated with through their entries using an entry 
call 

PRINTER.CHANNEL.PRINT (MYJOB); 

CLOCK.SET.TIMEIMEW.TIME); 

CLOCK.GtVE_TlME{THE.TIME); 

LAUNGH_BOMBERS.LAUNCH; 


T-21 




Student Notes: 


ENTRY CALL 



T-22 


e Places an entry can on the queue associated with the entry of a task 
e Does not immediately start a rendezvous 


ACCEPT STATEMENT 


7-23 



e Occurs in a task body 

• Corresponds to task entries 

• Specifies actions tc Is peiformed dcri:.|; 



RENDEZVOUS 


T-24 



When an entry has been called and the corresponding accept statement 
is reached, rendezvous occurs 

- Rendezvous is the execution of the sequence of statements following 
the "do” and continuing to the "end" 

After rendezvous is completed, the two tasks execute in parallel again 


8-8 Tasks 



student Notes; 


ACCEPT STATEMENT 



Syntax 


accepLStatetnent 
accept entry_simple_name 
sequence_of_statetnents 
end (entry.simple_namell; 


((entry .index)) !formal_partl (do 


Examples 


accept PRINT (JOB: in LISTING.TYPE) do 
...••sequence of statements 
end; 


accept SET.TIME (CURRENT; in TIME) do 
.-sequence of statements 
end; 


accept LAUNCH; 


T-25 ‘ . 


( 


task CHANNEL.IO is 
entry' PRINT (JOB; in LISTING.TYPS); 
end CHANMELJO; 

functior, FREE return BOOLEAN is separate, 

procedure SEND (JOB.TO.PRINT: in LISTING.TYPE) is separate. 



task Codv CHANfiEL.IO is 
L0CA._C0PY; LlSTlNG.TYPE. 

Pegm 

loop 

accept PRINT (JOB in LISTING_TYPE) do 
LOCAL_COPY :*= JOB; 
end; 
loop 

exit when FREE; 
end loop; 

SEND (LOCAL_COPY): 
end loop; 

end CHANNEL.IO; 
begin --main program 

CHAMNELJO.PRINT (MYJ03). 


T-26 



Tasks 8-9 




I 


Student Notes: 



T.27 



procedure C0''*IT_D0WN is 

task SEQUENCER IS 
entry ONE; 
entry TWO; 
entry THREE; 
end SEQUENCER; 

procedure DO.NOTHING is 
begin 

tor INDEX in 0.. 10.000 loop 

null; 

end loop; 

end DO.NOTHING; 

task body SEQUENCER is 
begin 

accept ONE; DO.NOTHING; 
accept TWO; DO.NOTHING. 
accept THREE; 
end SEQUENCER; 
beoin .-COUNT.DOWN 
SEQUENCER.ONE; 
SEQUENCER.TWO. 
SEQUPNCER THREE; 
end COUNT.OOWN; 



a-10 Tasks 




Studtnt Notes; 


TASKING STATEMENTS 


• Delay Statement 

• Select Statement 

• Abort Statement 



T-28 


DELAY STATEMENT 


delay.statemeni delay simple.expression: 

• Suspenos further execution of the task for at least the time interval 
specified 

• Simple expression must be of the predefined fixed point type 
DURATION 

SECONDS: DURATION; 

delay DURATION (3.0 • SECONDS); 


1-29 



procedure V.OuITOh is 

tass CHECK.RADIATICN.LEVEL; 

function {.'UT_0F_LIM!TS return BOOLEAN is separate; 

procedure SOUND_ALARM is separate. 

task body CHECK.RADIATION..LEVEL is 
begin 
Ibop 

lfOUT.OF_LIMITSthen 

SOUNOJtLARM; 

else T-30 ,. 

delay 5.0; 
end If; 
end lobp; 

end CH£CK_RADlATION.LEVEL; 


begin 

null; 

end MONITOR. 


Tasks 8*11 



Student Notes: 



Student Notes: 


SELECT STATEMENT 


T-31 • Allows for choosing between multiple entries for renosjvous 

• Allows for choosing the semantics of an entry call 

selecLstatement:: > selective.wait i 

conditionaLentry.calt i 
timed_enttv_cail 



task BANKJELLER is 

entry MAKE.DEPOSIT (AMOUNT : in FLOAT); 
entry MAKE_WITHDRAWAL (DESIRED ; in FLOAT, 

AMOUNT ■ out FLOAT). 

end EANK.TELLER; 


{ 


task body SAMK.TELLER is 

begin 

loop 

select 

accept MAKE.DEPOSIT (AMOUNT: in FLOAT) do 
end. 


T-33 


or 

accept MAKE.WITHDRAWAL (DESIRED: in FLOAT; 

AMOUNT tout FLOAT) do 

end; 

end select; 
end loop, 

end BAr;K_TELLER: 

I 


8-12 Tosks 




SELECTIVE WAIT.V.MTH ELSE 


loo? 

*2CC??' MAK'.0EP0SIT (AMOUNT : in FLOAT) do 
end; 

°'accep: MAK£.ORIV£.UP,Oe?OSIT (AMOUNT in FLOAT) do 


end, 

eisd 

OO.FILING; 
end select, 
end loop. 



selective wait VrlTH GUARDS 


loco 

select 

when BANKING.HOURS - > 

accept MAKE.DEPOSIT (A.',10UNT; m FLOAT) do 

end. 

Of 

when DRIVE UP HOURS-> 

accept MAKE.ORIVE.UP.OEPOSIT (AMOUNT ; m FLOAT) do 

end; 

ei?e 

DO.FiLlHo, 
end select, 
end loop. 


T-36 


Tasks 8-13 


Student Notes: 


SELECTIVE WAIT WITH A DELAY 


lOOD 

selec* 

when BANKING.KOURS » > 

accepl MAKE.DEPOSIT (AMOUNT m FLOAT) Cc 

end: 

or 

when 0RIVE.UP.H0URS-> 

accept MAKE.DRIVE.UP.DEPOSIT (AMOUNT: in FLOAT) do 

end: 

or 

delay DURATION (2.0 * HOURS): 

TAKE_A_BREA<: 
erd select: 
end loop: 


SELECTIVE WAIT WITH TERMIN’ATE 


leer 

select 

accept l•lAKl._L/cPCSl i (Ai\>jJN i, iti: cvAi j oo 


Of 


end, 

t 

accept MAKE-DRiVE.UP,DE?OSIT (AMOUItT . in FLOAT) 

do 


end: 

or 

' termna's. 
end select, 
end loop: 


CONDITIONAL ENTRY CALL 


Tasks 


condrttonal_entry_call = 
select 

entry.caii.siateinenl 
(seqcef'ce.oLstaiements) 

else V 

sequence ol.statements 
end select, 



Studtnt Notts: 


sdsct 

BANK_TELLER. M AKE>D£P0S1T (20.00); 
else 

GIVE,UP; 
end SELECT; 



T.40 


TIMED ENTRY CALL 


timc'J„entry„cail 

sese:: 

entfv-call.statement 
(seouence.of.statempnts ] 
Cr 

delay .citsrnative 
end select: 



select 

BANILTELL£R.MAXE..DEPOSIT(1_000.00); 

or T*42-. 

delay DURATION (10.0 * MINUTES); 

TAKE_A.HIKE: 
e;id select; 



Task 


8-15 



Student Notes: 


ABORT STATEMENT 


* atjon.statemeni* aboa task_narr,e |, task.narr.e 

« Causes a task and all dependent tasks to tecone ACNO'^f'AL thus 
preventing any further rendewous with the tar^ 

• An abnormal task becomes completed in ceaam circumstances 

— accept statement 

— select statement 

— delay statement 
—entry call 

"" dCtaVBiinQ 

<• Cel'inc an ABNORMAL task or it a can nas be*n nv:? to ir. emi; 
and IS queued raises the exception TASKING_Er.P.3R 


ADORT ST>-.Tf:.VcfJT 


"A., .-.oort it.-teiner.: should oe used on.y m sx: :.. ',:;. severe situstlor,.: 
recutfir.g uficunditional termination” 


STUDY GUIDE/WORKBOOK 


E30AR4924 004 
E40ST4924 020 
90P 893 


T«chnicot Training 


FUNDAMENTALS OF Ada PROGRAMMING/ 
SOFTWARE ENGINEERING 


DECEMBER 1987 



USAF TECHNICAL TRAINING SCHOOL 
3390th Technical Training Group 
Kecsier Air Force Base, Mississippi 


OttignAd For ATC Cowrot list 


Alt 


DO MOT USf DM TNff JOB 


Coam-Conp Syitens Advancvd Training Olvlalen 
Ktaalar Air Fore* Baaai Mltaiaalppl 39S34-SOOO 


Philoanphy 


HO C30AR4924 004 
E40ST4924 020 
1 Oct 1987 



The philosophy of the wing emerges from a deep concern for indivldusl Air 
Force men and women and Che need to provide highly trained and motivated per¬ 
sonnel to sustain the mission of the Air Force. We believe the abilities, 
worth, self-respect, and dignity of each student must be fully recognised. We 
believe each must be provided the opportunity to pursue and master an occupa¬ 
tional specialty to the full extent of the Individual's capabilities and aspi¬ 
rations, for the imaiedlate and continuing benefit of the individual, the Air 
Force, DoD and the country. To these ends, «#e provide opportunities for indi¬ 
vidual development of initial technical proficiencies, on-che-joh training in 
challenging Job assignments, and follow**on growth as supervisors. In support 
of this individual development, and to facilitate maximum growth of its stu¬ 
dents, the wing encourages and supports the professional development of its 
faculty and administrators, and actively promotes innovation through research 
and the sharing of concepts and material with other educational inacltutions. 


CONTBHTS 

Chapter Title 

1 Introduction . . . 

2 Training Evaluation and Feedback System . 

3 Fundamentals of Ada Systems . , 

4 Basic Ada Types . 

3 Control Structures . ,.... 

6 Subprograms . 

7 Packages . 

8 Exceptions . 

9 Generics . 

10 Tasks . 

11 Program Design Using Ada . . 

Appendix A: Software Engineering Standards . 
Appendix B: Ado Glossary ... . 


Page 

1-1 



3 - 1 

4- 1 
3-1 
b-1 

7 - 1 

8- 1 ; \ 

9-1 

10-1 
U-1 
A-1 
B-l 
















Chapter 1 
ORIENTATION 


WELCOME 

Welcome to the Fundamcntala of 
Ada Prograaming/Softwarc Engineering 
course. This class will give you 
knowledge of the fundamentals of 
engineering good Ada systems. It's 
a challenging class with time split 
between lecture and hands on exer¬ 
cises. It is our intention to make 
this course as informative and int¬ 
eresting as possible: however, ve 
cannot accomplish this without your 
assistance. You are encouraged to 
participate in discussions and con¬ 
tribute as-much as possible to en¬ 
hance your learning and make the 
course more meaningful and enjoy¬ 
able. 

In this chapter, we will cover 
the student Ciiti-^ue program, energy 
conservation, fraud, waste and 
abuse, administrative policies, and- 
a course overview . 

STUDENT CRITIQUE PROGRAM 

To critique something is to 
express your opinion about the sub¬ 
ject. The Student Critique Program 
exists for all ATC MTT Courses and 
at all Technical Training Centers 
because we are Interested in your 
welfare and the effectiveness of our 
training. The purpose of Che pro¬ 
gram is based upon the assumption 
that whatever bothers or distracts 
you trill adversely affect your 
learning. 

Although critiques are admin¬ 
istered sc Che end of Che course, 
you may critique training at any 
cine during this course of instruc¬ 
tion. Critique forms (ATC Form 736) 


are readily accessible in every 
classroom. Should you recognize a 
problem or a deficiency, do not 
hesitate to critique it. Likewise, 
you may submit critiques recognizing 
outstanding units of instruction, 
instructors, facilities, equipment, 
etc. We do ask you to critique 
training and facilities on a sepa¬ 
rate form. Your critique will be 
given careful consideration; it will 
provide us with valuable ideas which 
may improve training, as well as 
facilities and services. 

Your sincere cooperation in the 
Critique Program can be beneficial 
to all students that follow you. 

All critiques can be submitted 
without fear of reprisal or prej¬ 
udice. 

FRAUD, WASTE AND ABUSE (FWAA) 

The Air Force policy on fraud, 
waste and abuse is to use all avail¬ 
able means to prevent, detect, cor¬ 
rect and discipline, as warranted, 
perpetrators involved in FU&A. 

Definitions 

1. FRAUD: Intentional mis¬ 
leading or deceitful conduct that 
deprives the Government of its re¬ 
sources or rights. 

2. WASTE: Extravagant, care¬ 
less or needless expand1cures of 
Government resources from improper 
or deficient practices, systems, 
controls or decisions. 

3. ABUSE: Intentional wrong¬ 
ful or improper use of Government 


l-l 



rtfourcts, i.e. misuie of rank, po- 
tition or authority. 

Any Person who knows of fraud, 
waste or abuse has a duty to report 
it to his or her supervisor, »nn- 
mander, Inspector general. Air 
Force Audit Agency (AFAA), AFOSI, 
the security police or ocher proper 
authority. Each member of the Air 
Force, military or civilian, has the 
right to file a disclosure without 
fear of reprisal. The following are 
examples of FW&A chat students 
should avoid: 

1. Abusing equipment, whether 
intentional or not. 

2. Wrongful destruction of 
student literature. 

3. Willful waste of Janitorial 
supplies. 

4. Facilities abuse. 

5. Unauthorized use of Govern¬ 
ment telephone services. 

6. Intentional lack of person¬ 
al commitment in doing a duty or 
task for which a salary is being 
paid. 

7. Intentional practice to 
avoid making corrections to known 
deficiencies in order to prevent 
fraud, waste and abus?. 

8. Waste/unauthorized distri¬ 
bution of Government supplies. 

ADMINISTRATIVE POLICIES 

INSTRUCTCR:_ 

Duty hours sre to dur¬ 

ing this course. Ten minute brwaks 
sre provided each hour with one hour 
for iMWh. 

You are asked to reschedule 


any appolntmants during the Length 
of this course. If an appointment 
cannot be rescheduled, inform the 
instructor as toon as possible. If 
you miss s portion of a class It is 
your rsspc'*sibi U ty to make srranee- 
ments with the instructor Co lind 
out what material was missed and hov 
It can be made- op. If for any rei- 
son you mias more than 10 percent of 
the class time you can be reiruvcd 
from training and asked to resched¬ 
ule. 

A dess leader will be ap¬ 
pointed by the Instructor during the 
first hour of class. The class 
leader acts as your reprosentativc 
and is tasked with the fnlloving 
responsibilities: 

1. Assist the instructor in 
maintaining order at all times dur¬ 
ing the class period. 

2. Supervise classroom clean¬ 
up. 

3. Assume control of the class 
in the absence of th.: instructor, ot 
as directed. 

4. Act as spokesman for the 
class in any matter which the class 
members deem necessary, usually mat¬ 
ters which require supervisory at¬ 
tention. 

5. Encourage military students 
In the class to raaintain high stan¬ 
dards IAW AFR 31-10. 

FacilltieH Available 

Room . firu'ik Are.i 

Room ______ Female Latrine 

Room _ Hale Latrine 

Room _ Administration Offices 

Phone Number _ _ 


1-2 



couisK omvxcv 

Unit 1: Introduction 

Unit 2; Tr.;nlnR Evaluation feed¬ 
back Syscea 

Unit 3: Fundaaentala of Ada Syateaa 
Unit 4: Basic Ada Types 
Unit 5; Control Sttucturea 
Unit 6.f SuBptfl«I»*» 


Unit 7: Packages 
Unit 8: Exceptions 
Unit 9: Generics 
Unit 10: Tasks 

Unit 11: Program Design Using Ada 
Unit 12: Develop Software Using Ada 



1-3 





CIU7TER 2 


TBE miNlMC EVALDATION rBBDBACR STSTBM 


OBJECTIVE 

Using the studsnt handout as a 
rafarancs, brlafly dascrlba cha 
purpoaa of eha training avaluation 
pregran. 

XKROOUCTIOM 

* < 

• ^ 

The training avaluation faad~ 
back system is a useful tool to keep 
our courses up to data with the re- 
quirenants of the Air Force. 

IHPOKKATION 

PURPOSE OF EVALUATION 

The purpose of the training 
evaluation program is to obtain the 
information necessary to determine 
the: 

1. Ability of graduates to 
perform their assigned task to the 
level of proficiency specified in 
the applicable training standard. 

2. Extent to which skills ac¬ 
quired in training are used by scrad- 
uotes in the field. 

3. Extent to which knowledge 
attained in training is retained by 
graduates in the field. 

U, Need for revisions In the 
training standards and courses to 
improve trsining effectiveness and 
responsiveness to the needs of the 
using eemends* 


The evaluation includes the 
colleetion» collation, analysis, and 
incerprttatlon of feedback infor¬ 
mation to aseass the effectiveness 
of training and the extent to which 
course greduates aatlsfy field per¬ 
formance requirements. 

BESPOMSIBILITIES 

Commands conducting formal 
courses arc required to conduct 
evaluations to datermine the ade¬ 
quacy end relevance of training and 
to make revisions as needed. 

Using cosnands are required to 
psrticlpate in the evaluation pro¬ 
gram by furnishing information to 
representatives of tr^iining activ¬ 
ities during: 

1. Field vishUs ^ 

2. Completing and returning 
field survey questionnairea 

3. Completing, Training Quality 
Reports to Identify training defi¬ 
ciencies and reconimc:\ding changes 
to training atandaru tasks, knowl¬ 
edge or proficiency levels that are 
not meeting command requirements. 

SUKMAXy 

The program provides a means 
whtreby supervisors and graduates 
can htlp training activiciss develop 
mnd conduct training programs that 
are best suited to their needs. 


2-1 



Chapter 3 

FUMDAHEMTALS OF Ada SYSTEMS 


OBJECTIVE 

Glvtn « simple program speclfl- 
caclon, scudenc Instruccinnsl nace- 
rials, and scudenc noces, engineer a 
program in Ada chac correccly iaple- 
aencs Che problca. Program ausc 
conform Co course sofeware engineer¬ 
ing scandards*/ViraKrucCor may pro- 
vice up Cd 4 assises. 

INTRODUCTION 

You may have heard Che claim 
thac "Ada is jusc another program¬ 
ming language." Well, chac depends 
on your point of view. Any program¬ 
ming language is a cool co cransform 
a sofeware design into che actual 
machine language Instructions chac 
a computer performs. Ir. that re¬ 
spect, Ada is another computer lan- 
£'!•“'£“ I jusr. Of a hand shovel and 
diesel powered shovel are both cools 
CO dig a basement. However, when 
digging a basement, you should 
choose the cool Chat best supports 
Che job. Vhen developing sofeware, 
you should choose Che cool chac besc 
supports che goals and principles of 
software engineering. 

INFOIWATION 

SOFTWARE ENGINEKRIHG 

Uh.nt is software engineering? 
For chu purposes of chis course, we 
vlvw it as an orderly appiicacton of 
cools CO develop sofeware chac is 
reliable, maintainAbie, efficient, 
and understandable. Using chis def¬ 
inition, a programming language is 
just one of n number of cools chac 
is used when called for In applying 
some methodology to develop soft¬ 
ware . 


We can identity a number of 
principles co keep In mind while 
developing sofeware chut supports 
Che goals of reliable, maintainable, 
efficient, and understandablt soft¬ 
ware. These principles ere: 

0 Abetrecclon - Considering 
only the imporcent features 
at chis level and ignoring 
che unimportant details. 

o Information Hiding - Kaking 
underlyini< details inacces¬ 
sible. 

o .. Modularity - Breaking up a 
large system into manageable 
pieces. 

f> Local liar Ion - Physically 
grouping together 10 j;lcaily 
related enticivs. 

o Completeness - Ensuring that 
all required features are 
present. 

o Confirmability - Ensuring 
that the system can be test¬ 
ed CO aske Rure it's com¬ 
plete and meets the require¬ 
ments. 

0 Uniformity - Ensuring that 
there are no unnecessary 
differences In notation 
chac can bu.confusing. 

Throughout che course we will 
relate che features of Ada to chose 
goals and prineiplts of software 
engineering. 

Ada LANGUAGE FEATURES 

Anyone who has looked through 


3-1 



th« Ad* r«f*rtnc* mnnu*! can ttill 
you that Ad* It * complex lanautK*. 
The features of A<U are lnc«;;r3ted—■ 
in other words, to write cvuii a «ttn- 
pli' Ada prouram, you need at least a 
shallow knowledge cf a •'.Mtnb-” of 
language fcatureb. 

Dae* Typing 

One of these features Is Ada** 
use of strong data typing. Strong 
typing means that, every object 
(variables snd constants are ob¬ 
jects) has to be associated with 
some type. This type defines the 
set of 'v«liies*'and the set of oper- 
etions for that objpct. Ado also 
doesn't allow you to mix apples and 
oranges; if yoi: hav« cwo objects of 
different cyp«», you can't Inpliclt- 
ly mix them in an operation. In 
other languages, you muy declare an 
object to be an integer, character, 
etc. i>,:.s is similar to declaring 
an object In Ada, although Ada 
takes this one step further in that 
it allows you to declare your own 
distinct types. This helps you 
ms.'el th-f data s:"i!*r’Tu r.* rhn rrtj 
world problem. 

Prugr«m Units 

Pros » units are structures 
used to V, up largu software 

systems int smaller, mure mnuigw- 
a’rVw purcs. An Ada ,nro.*,rnm s'ru»>;lJ. 
ch.srcfor3 use prri'jr-tm Ui'its to b:-'')’?". 
ths code up easily uta.-.d- 

ablii segments. tach program unit 
has two parts: a specification and a 
body. The >vclf lent ion is th»* 
logical view cf this prugc.in unit 
which defines tlio Interface to other 
program units (Ahstrscclon). The 
body defines how the details uf Che 
program unit are InplemenrtU. These 
details chat are in Che body are 
in.nccesaible to ocher program units 
(Information Hiding). The sep.nr*- 
cion of spcctficncion «nj. body nl- 
Inw you Co view these pcuu.rnm uuica 


more like black boxes with the com- 
municscien regulrtments specified 
by eh* specificstion. 

There sre four different kinds 
nf program units Chat .an use to 
break up our system. Tho.?« are: 

0 Subprogr.ams - Program units 
Chat perform an operation or 
ealcul.acion. 

o Packages - Program units 
chst sllow you to group to¬ 
gether logically ralated 
entities. 

o Canaries - Program units 
that ganeralixe subprogrsets 
or packages. 

o Tasks - Program units that 
run In parallel with other 
program units. 

In class, we'll explore each 
of these different program units. 

Program Structuru 

An Ada proyirom is simply a main 
subprogram. The body to this main 
subprogram contains two parts: the 
declsrntivc part and the executable 
part. The declarucive part is where 
we declare our types, objects, or 
even other progrun uttits. The oxe- 
cutable par: cor.tai'.t'j tr.^* statements 
to bv port or"..':d dari:.,; . A 

‘..imple Ada proeiam wiuld the:'. ioeV. 
like this: 

procedure MAIN Is 
~ Deular.iClve Part 

begin 

null; . — Executable Part 

snd MAIN; 

The declar.nclvti and executable parts 
nr* separated by the word 'begin'. 


3-2 



Everything to the right of e double 
dash * —' would be e cootmenc. Ue'll 
add Bore to this basic structure 
later in class. 

PKOGnAM LIHPAR'; 

The concepc of a progran li¬ 
brary is very important in Ada. The 
program library is sinply a collec¬ 
tion of information on all compila¬ 
tion units, or program parts, that 
have been compiled into a library. 
This is important in Ada because the 
language allows you to separately 
compile parts of the system that are 
ir different files. When compiling 
a prej|sTj»'n ur.:t, thy compiler hss 
access to a record of everything 

else that has been compiled to 
this point. This powerful feature 
enables the compiler to enforce its 
visibility and strong typing rules 
across program unit boundaries. 

SIMPLE COjrrv'OL STF'JCTUPRS 

Ada has a of control 

structures. Dtrlug chi;: lecture, 

we'll cover some simple control 

structures such as assignment, if, 
and loop acacemencs. These will al¬ 
low you to begin writing simple Ada 
programs. 

SIMPLE IhKirr/Ol.’TVUT 

When l„io'--.ir.^ a: tlK 
gu4g-:-, you have to V-.ecp in mind th-: 
application for which it was de- 
sian»*rt; embedded computr-r systerus. 
These arc systems whore the computer 
is only 3 s'.'iall part tli it controls 
the rest of tlie system, such as the 
computer that controls tli>i ignition 
system in, your car. These embedded 
systems typically have small memory 
space and unique input/output re¬ 
quirements. because of these re¬ 
quirements, the lan<<uag«; designers 
chose not to make texCvial input/ 
output ir.ti'lnslr to Ada. This way, 
tho-.-,' cinhyodeJ systems proi^rains that 


don't require Input or output of 
text don't have to suffer with the 
overhead of these routines. 

For programs that need text 
Input/output, there is a predefined 
package In the Ada program library 
that cencaina a set of input/output 
routines. The routines In this 
package TEXT^IO are only accessible 
CO those pr'ograms that explicitly 
tie into this package. In class, 
you'll sec how we do this. 

SUHMAW 

Ada is a language designed for 
engineering softwar- systems. It 
directly support*; thi.: goals and 
principles identified for software 
engineering. It's a complex lan¬ 
guage with many integrated fea¬ 
tures—features that you will find 
very useful by the end of the 
course. 


EXKir.ISF. 3-1 

Note: Some of the material needed 

to answer the following questions is 
only covered in Che lecture. 

1. What is "abstraction"? 


2. W'iiar, is "iufcum.'line. I,id. 


3. Mame the twi p.irt.‘< of a 
unit. 

4. Typos and oh,i-cts arv docl.irod 

in the _ part of a 

program unit body. 

5. What is a package? 

6. How do Ri'uo'rlr program unit.*! aid 
In reus:»bi IV ty 


3-3 




' EXAMPLE 3-1 


—XXSXXZXXSXXSXSStXSXXSXXSXXXXXXXXSXXEXXXSXSXXXXXXXZXXXXXXXXSXXZXXZXXZXSXZ: 
—X X 
•—X Abccracc: This program computaa cha araa of a crtangla. It- ftrat X 
•‘-X pronpca you for tha langth of tha baaa and tha htlght of Z 
'•% Cha trlangla, than princa out tha araa* X 
••••X X 
—S Author; John Dot X 
“■“#0 

—X Data; 19 Or.c S7 “ 
~X X 


mb 


with TEXT_10; 

procadura"COMPUTE_AR£AjOF^TRlANGLC la 

MAXIMUM LENGTH : conatant ;- 50; 

0NE_HAL? ; constant ;■ 0.5; 

MAXTmI'M_AREA* : constant ;■ ONK HALF * 

(M.\XIMUM_LENCTH * MAXIMUM_LESGTH); 


typo LENC7H_TY?E Is range 0 .. M/JCIMUM^LENCTH; 

type AReA_TYPS U digits 10 range C.O .. MAXIMUM_AREA; 


LK.iCT-'. OF BASK 

ksight" 

A?.£A 

ANSWER 


LENGTH TYFC 

lsn-tk'tyfe 

CHARACTER 


- 0 ; 

■ 0 ; 

- C.r; 
■ 'Y*; 


package AREA TO is new TEXT 10.FLOAT 1J( AREA TYPE ); 
prickip-i LEN.iTk^IO i.-; nev TEXT'iO- n>TEGER_I0( LENCTHJTYPE ); 


(or. next par.c) 





begin — COMPUTE^AREAJOFJTRIANGLE 


(# 


iR EETW 


TEXT__IO.Pl’T_L INK ("This progriita enlculatis the tree of a”); 
TEX7'”10 .P’JT"’l 1NK( ■* triangle given the length of ita baa«“V 
LTNS(" h,\6 its height. 

TKKI^IO.NK.^LINK;;!); 

TEXT 10.PLTC"F.NTK-; THE LESCTH OF THF. BASE (MUST RE AN INTECT 
LENGTH 10.PUT( LEfJGTK TYPE’FIRST); 

TEXT lO.PL'TC- AND”); *“ 

LENGTH lO.PUK LENGTH TYPE'LAST ); 

TEXT 10.P*JT(“: •*); “ 

LENOTK_,IC.CF.T( LENGTH_OF_BASE >; 

TEXT lO.Pi;7("rSTER THE HEIGHT (JWST BE AN INTEGER EKTWKSN”) 
LF.NGYK I*.'.P11T( LENGTH TYPE’FIRST); 

TKKT^^lO.ri'TC” AN'!”); 

l.KNGTti IC.FJTl LKST'K Ty:'£’LA?T ); 

TEXT lo.t'i’xr; ”); 

UNGTH lO.GETC HEIGHT ); 


AREA :■ OSE_HALF * ARtA^TYPEf LENCTH__OF_BASE) * AR'A__7YHK( HK'CHT,'; 
TFXT 10.NEW LINE; 

TEXT”io.P’-’TT"THK area vTF THE TRIANGLE IS: “); 

ARl'.-i_r.\?VT( ); 

TEXT 10.NEW LINK; 

TEXf'lO.PUTr’DO YOU WANT' TO TRY ANOTHriR? U OK N)">; 

TEXT"I0.GET( answer ); 

exit when ANSWER ■ *N' or ANS'WEX • 'n'; 


end loop; 

ess,' COV.PUT'i_A:-'.KAj)?__Tc' lANKl.E; 


3 -^ 


ntuill 3-2 


1. Log on to tho coBputtr viKh your eorroet user non** 

2. Enttr th« progron below using the editor. 

3* Conpile using the Ads compiler. 

4. Mske sny corrections needed to fin errors. 

5. Eun your progrem. 

6. When you have finished, call the Instructor to evaluate your prograa. 


•XtXXXkXXXZXXSXZXXXXXXXXXXXZZXXXSXXZXZXXXXXXXXZXZZXSXZ2XtXXXXXXXXXXZ2X:;Zl 


—X 
—X 
—X 
—X 

—x 

—X 
—X 
—X 


Abstract s This program computes all of the prime numbers up to some X 

value MAXIMUM NUMBERS. X 

X 

Author: John Dee t 

Date: 16 Sep 87 


—xxxzxxxxxzxzxxxxxxxxxxxzxzzxxzxxxxxxxxzxxxxxxzxzxxxzxxxxxxxxxxxzxxxxxxxxx 


with TEXT^IO; 
procedure*"SIEVE la 

HAX1MUK_NUHBERS : constant SUO; 

type NUMBER TYPE la range 1 .. (MAXIMUM NUMBERS MAXIMUM NUMBERS/2); 
subtype PRIME RANSE Is NUMBER TYPE range {..MAXIMUM NUMBER; 
type BOOLEANJuiRAY_TYPE la array (PRIME^RANUE) of BOOLEAN; 

NUMBER : NUMBER TYPE NUMBER TYPE*FIRST; 

PRIMES : BOOLEiJ?.ARRAY_TYPE :-*"(oCherB •> TRUE); 


package INT_10 Is new T£X:__IO.lNTEGER_lO (NUMBER^TYPE); 
begin 

for COUNTER In NUMHER^TYPE r.mue 2..PRIMES'LAST / 2 loop 
NUMBER ;■ COUNTER” COUNTER; 

while NUMBER <- PRIMES'LAST and PRIMES (COUNTER) loop 
PRIMES (NUMBER) FALSE; 

anUi'^AeiH snwa'UkwIh y wwUUaulVf 

end loop; — while NUH 

end loop; — for COUNTER 


TEXT 10.PUT ("The primf numhvrs from I to 
INT To.PUT (PRIMES'LAST); 

TEXT 10.PUT LINE <" ere;"); 
for TnDEX in PRIMES'RANGE loop 
if PRIMES (INDEX) then 
INT^IO.PUT (INDEX); 
nnd if; 

nnd loop; — for INDEX 

TEXT 10.NEW LINE; 
end SIEVE; ” 


3 -() 


); 



ChaptaT 4 
lASie Ada TTPBS 


outcnvi 

Glvtn a aiapla preiraa apael** 
fieacion, an IneoapUca Ada pretraa, 
■eudant Inaeruetienal •aearialtt ^nd 
atttdant nocaa, add tha eetraet 
typaa-ebjaeca to tba prograa to cor- 
ractly laplaotnt tha problaa* Fro* 
graa ouat eenfero to eouraa aeftwara 
onglnaaring atandarda. Inatruetor 
■ay prorlda up to 3 aaaiata* 

iimtowcnoN 

Uhat pur peat dots It aorva to 
aay that a varlablt is of a eartain 
typo, or class of objacts? Ftrat» 
It tolls tho coapllar how to traat a 
strlos of bits. For txaapls, adding 
two Intagors is dlfforont froa add* . 
log two floating point numbers. 

• - • • But data typing helps software 
onglnaars also. It allows then to 
assign logical propartlas 

data abstraction can greatly In¬ 
crease the understandability of a 
program. For example, if we need to 
keep track of the days of the week, 
it is much more understandable to 
refer to the days as MONDAY, TUES¬ 
DAY, WEDNESDAY, etc. as opposed to 
nuabecK iiuui 1 to 7 (u; It 0 to 
6 ?). 

I1IFOBMA.TXON 

I 

SnOHG TIFmC 

in the last chapter, we de¬ 
fined strong typing to ■ean that 
every object has an asaoclatad type; 
this type defines the set of values 
and act of operations available for 


objects of that type. Also, we 
can't inplicitly mix objacts of dif¬ 
ferent types. Ada supplies some 
predefined types such as INTEGER, 
CHABACTBR, and FLOAT, but more Im¬ 
portantly, It gives us the capabil- 
• • Ity* to declare new data types to 
medal our own abstractions. 

Type Baelmratioms 

sod objoct dsclsratlons 
can be declared in the declarative 
part of any program unit: 

procedure MAIN is 
— Declarative part 

type AIRCRAFT is (B1,BS2.F16); 

begin 

null; 

and MAIN; 

In the above example, the type 
declaration begins with: 

typrATRCRAFT is .... 

ALL new type dcclarstions begin this 
way, with the word 'type' followed 
by the type name followed by the 
word 'is'. Whatever comes after the 
word 'is* defines what class of type 
wi nre dcrlirlrg. 

Object Declarations 

The above type declaration 
only defines the characteristics for 
objects of that type—the set of 
values (Bl, 152, F16) and a set of 
operatlona. In order to gdt any use 
from a type declaration, we need to 
declare an object of that type: 


A-1 




a 




proetdurt N41N !• 

Daelaraelvc part 

typa AIUCRAFT la (Bl.lS2,ri6): 
PUNE t AIRCBAFT; 

bagin 
nullt 
and MAIN; 

Nev va hava an objaet eallad PUNE 
nhoaa valua can ba 11» BS2« or F14. 
Tha oparactona wa can parfom on 
PUNE ara ehaaa avallabla for tha 
elaaa of anunaration typaa which 
wa'll dlaeuaa In elaaa* 

CLAIBBt OP rmts 

Tha typat wa can daelara In 
Ada fall Into on* of tha following 
elaaaas: aealar, eonpoaita, aeeaaa, 
prlvata, or taak. 

Bealar Tppaa 

Tha objaeta of a aealar type 
only contain ona valua at a tlna. 
Type AIRCRAFT In tha pravlous ax* 

anpla la a aealar typa baeaoaa at 

any point In tlna PUNE can contain 
only ona of tha valuaa B1 • BS2 or 
F16. 

Ua can brack the elaaa of aea¬ 
lar typaa Into Integer, anunera* 
tlon, floating point, and fixed 
point typaa, which wa'll cover dur¬ 
ing elaaa. 

Oonpoalto Ippaa 

Unlike objacta of a aealar 
type that can only contain one val¬ 
ua, objacta of a conpoalta typa can 
contain eolloetiona of vnluaa. Go** 
poalco typaa ean bo arroya, whora 
all of the eenponanta In the eol- 
laetion ara of tha aano typa, and 
raeorda, where the eenponanta ean ba 
of dlffaront typaa. 


Othar Typaa 

Tha ether kinda of typea wa 
ean daelara In Ada arat 

o Aeeaaa Typaa: Tha objaeta ara 
polntara to other objaeta. 

0 Prlvata Typeai The eperatiena 
on objacta of tha typa are only 
thoae that ara explicitly 
atatad. 

o Taak Typaa: Tha objacta dafina 
a parallel preeaoa. 

SamABT 

The atrong typing rulaa in Ada 
require that every object be aaae- 
elated with a type. The type de- 
flnaa tha aet of valuaa and the aet 
of eperatiena available to the ob¬ 
jacta of tha type. Ada allowa you 
to daelara your own typea to aat up 
abatraetiona of the real world and 
naka the aelution wore undaratand- 
abla. 

BEBBCllB A-t 

Note: Bona of tha aatarial noadad 
to anawar the following quaationa la ^ 
only covered in tha laetura. 

1. Dafina atrong typing. 


2. The two kinda of conposice typaa 

are and . 

3. A type definea a eat of 

and a aet of . 

4. Uhat la the difference batwaan a 
cenatrainad and an unconatralnad 
array? 


5. An array ia a collection of 

objacta while a 
record ia a collection of 
objaeta. 


4-2 






!• Add tiM C 7 P« md «bj«et daelaratloM th«c at* eallad for In eha folloving 
progran ahall: 

pMaadaia iUYJU08BD_CAK la 

~ Daelara an iatagar typa eallad Y8AKS that rangas fron 1900 to 2500* 


- Daelara a tjpa MMd CAK MAISS that eentaina tha valuaa DODGE, POKD, 
ronXAC, PI.TN00TH, MBICimT add OBVT. 


Daelara a typa nanad COLOtS that haa tha valuaa RED, SILVER, ILUE, BLACK, 
and YELLOW. 


~ Daelara a record typa called CARS with the following eonponanta: YEAR of 
type TEARS, COLOR of typa COLORS, and MAKE of typa CAR^HAKES. 



^ Declare an itrray typa nanad USCO^CAR_LOTS that can contain 50 clenanta of 
typa CARS. *” ” 


— Declare an object naMd DAMS_USED_CARS of tha typa USED_CAR_L0TS. 


bngln 

■nils 

aia BUY A USED CAR; 




4-3 





4-1 


izxzxxxnxzxxxxxxxmxxxutKnmxmmsxxxssstmsxsxnuzxzxxxxtxxx 


Abstracti 


Author: 

Data: 


This profrau eoaputas tha avaraga of atudant'a tost 
■coras for an anti^* class* Bach atudant has thraa tast 
seeras and tha nuabar of atudants la glvan by tha nunbar 
daelaraclon* Tha avarcga is tha total avaraga of all 
tasts by all studants* 



with TEXT 10; 

proeadura~AVIBAGB.8C0U8 Is 

MAX SCORE t constant :■ 100*0; 

NUlffER OP STUDENTS t constant :• 10; 
NUMSEITop'"^tests : constant t- 3*0; 


typa TBST_SC0RE_TYPE Is digits 3 rsnga 0.0 ** MAX.SCORE; 

typa STUOBNT.TYPE is ranga 1 ** NUHIER.OP_STUDENTS: 

type SGOEES.EBCORO is 
racord " 

PIRST TEST : TEST ECORE TYPE; 

SECOND TEST : TEST*SCORE'TTFE; 

TH1RD_TEST : TEST“8C0RE”tYPE; 
and racord; “ "* 

typa 8C0RE_LIST_TYPC is array( STUDENT_TYPE ) of SCORES RECORD; 


SCORES : SCORE.LISTjrYPE :• ( others -> ( 0*U, 0.0, 0*0 ) ): 
INDIVIDUAL AVERAOE, 

TOTAL^AVBSACE : TEST^SCOREJTYPB :• 0.0; 


paekago STUDENT 10 is now TEXT XO.XNTIGtR X0( STUDENT TYPE); 
paekago SOORB.XO ia oow TEXT_xV*PIAAT.XO('‘TSST^ieORB.Tm ); 

(Gontinuad on noat page) 


4-4 




btfln — AVEIA6E_SC0tBS 



for STUDENT In SCOUS'RANGE loop 


Cot toot dou 


TEXT 10.PUT("STUDENT HUMBER; *); 

STUDENT X0.PUT( STUDENT ); 

TEXT XOTnEW UNE(2); 

TEXT**X0.PUT7"PIRST TEST SCORE} "); 

SCORE XO.GET( 8CbRES(STUDENT).FIRST TEST ); 
TEXT To.PUTC"SECOND TEST SCORE: "){* 

SCORE X0.6ET( 8C0RES(STUDENT).SECOND TEST ); 
TEXT To.PUTC"THIRD TEST SCORE} *); ~ 
scon X0.6ET( SG0R18( STUDENT) .THIRD TEST ); 

textJTo.hsh.linec 3): " 

ond loop; 


for STUDENT In SCORES*RANGE loop 


CoBputo ovoroge 



INDIVIDUAL AVERAGE :• 8C0RES(8TUDENT) .FIRST TEST/NUHBER OF TESTS 
8C0US(STUDENT).SECOND TEST/HUHBBR OF TESTS * ^ . 

SCORESCSTUDENT).THIRD TEST/NUHBER OF TESTS; 

TOTAL AVERAGE }- TOTAL AVUIAGE * XNDIVTOUAL AVERAGE/ 

TEST scon TyPE(SCOUS*LENGTH); " 

TEXT X0.roT("81WENT NUMBER: *); 

STUDENT XO.PUTC STUDENT ); 

TEXT X0TpUT("AVERAGE XS: "); 
scon XO.PUT(INDIVIDUAL AVERAGE); 

TEXT_7o.NEHJLINE(2); “ 

ond loop; 


TEXT 10.PUT("CLASS AVERAGE XS *); — Print ovorogo 

SCORE XO.PUT( TOTAL AVERAGE ); 

TEXT To.NEV LINE; ~ 


ond AVERAGE SCORES; 



OwptM S 

oomoL snwMiv 


OftlKTIfl 

Giv«n • prograa •pacifica¬ 
tion, an Ineoaplata Ada prograa, 
•tudant Inatruecional aacarlala, and 
•endont noCM, vao the appropriato 
control atruetnraa to eorroctly 1»- 
plonont the problon* Progran noat 
eoafom to eouraa aoftwara anglnaar- 
log atandarda* Inatruetor nay pro- 
aide up to 2 aaalata. 


IRtOODCnOM 

Control atructurcs , or atata- 
•onta, daflna tha flou of control in 
tha axacutabla part of our progran 
units* Thaac daflna tha stops tha 
progran unit goaa through to gat Its 
job dona* Of all tha control atrue- 
turaa available, ua can break than 
up Into chraa ganaral catagorlaa: 
saguantial, conditional, and Itera¬ 
tive* 

nranmoM 

ggqoiiinAL ooRRoi. s t gu CT umt 

Sequential atatananta era par- 
fornad ona after anothar. Three 
sequential atatananta that ue'll 
talk about In class are tha aaslgn- 
nant, null, and block atatananta* 

Tha rvaIgniMnt aiatanant alnply 
assigns a value to an object* It 
sounds slnpla, but there's a catch: 
tha objaeta on both aides of tha 
aaslgnnaat atatonant have to ba tha 
sane type* (Rananbar strong typ¬ 
ing?) 

Tha null statanont does nothing. 
Just Ilka a page that says ’‘THIS 
PAGE INTeNTIONALLY UFT ILAMK", a 
null statenent can add to the read¬ 


ability of a progran. It*a uaaful 
in atrueturas such as a case stata- 
nant uhare you want to do nothing 
for a apaeifte path of control* 

Tha block atatonant Is nuch norc 
oxciting* It sllowa us to localise 
daelarationa, kind of Ilka creating 
a little daclaratlva part within rhe 
aaquonea of atatananta of our axa- 
Ctttabla part* The block atatanant 
also lets us locslisa tha handling 
of certain conditions that occur 
during tha progran*s execution, as 
we'll aaa In a later unit on excep¬ 
tions. 

OORDmOHAL OOHTIOL STtOCTUIES 

Thera are two kinda of condi¬ 
tional control atrueturas: tha if 
atatonant and the case ststanant* 
both of these statanants branch to a 
sequence of statanants based on tha 
value of sona condition. 

Tha if atatanant branches on a 
boolean (TRUE or PALSS) condition* 
If Che condition Is- true, the an- 
cloaad statanants will ba executed. 

If STOP LIGHT • RED then 
STOP “ 

WAIT; 

GO; 

and if; 

The if statenent can also have an 
'else* and/or 'alslf’ part to fur¬ 
ther daflna the flow of control, as 
wa'll aaa In class* 

The ease statenent branches 
based upon tha value of sona dia- 
crate object* Instead of having 
just two alternatives, as with tha 
if statanant, tha case statanont can 
branch to a nunber of placet baaed 


5-1 


on the value of chat discrete ob¬ 
ject. 



type LIGHT Is (RED, YELLOW, GMaiM); 
STHMIGHT ! UGHT OOSK; 


Uc can change the characteris¬ 
tics of the loop by adding an Itera¬ 
tion achene. A 'for* loop goes 
through the loop once for every val¬ 
ue In a given range. 


begin 

• ee 

CMe SIOPJLIOfl' is 
utan GKBQl -> 
lOEP QOOC; 
OBlSyMS; 
ehan nD^> 

SIDP; 

UfOT; 

00 ; 

uhM YniXW»> 
GDJASIES; 
end ceae; 


for INDEX in 1..10 loo\* 

PUT_LINB<"Hello!"); 
end loop; 

This for loop would print "Hello!” 
ten tlMs. A 'for' loop should be 
used whenever you know how aany 
tlMS you want to go through the 
loop. 


A 'while' loop lets you go 
through the loo' while some condi¬ 
tion is true. 



ITBEATXTB CONIBOL STtllCTDKBS 

Iterative control structures, or 
loops, are all based on one struc¬ 
ture in Ada: the basic loop. This 
loop is structured to loop forever. 

loop 

DO SQfemiNG; 
oTscxeiHDBjLSE: 

•If you weit to oclt ftxn the loop: 
•tit; 
end loop; 

We can exit from this basic loop 
only through an exit statcnenc, as 
shown above. 


while STATUS •RUNNING loop 
CHECK TEMPERATURE; 
CKECk“fUEL_FLOW; 
end loop; 

This loop would execute until STATUS 
is no longer equal to RUNNING. 

SIMIARY 

Ada, like other languages, pro¬ 
vides the three classical kinds of 
control structures: sequential, con¬ 
ditional, and Iterative. With these 
classes of statements, all algo¬ 
rithms ran be writ tun. 





:ill S-1 


1. Coapltt* th« following oubproiram. 


—zzxzxxzzzzzxzxzzzxzzxxxuxuzszxxsxxnmxmxxuzxsxzxzxzxxxxxzxuxxxxxs 
—z 

•^X Abatraett Ihia oxarciaa roqulraa you to ontar tba eoda to parfora 
—Z tha aetiona daaeribad in tha eoMonta balow* 

—Z 

—Z Authort Max Prograauar 

—Z 

—X Datat 19 Oct 67 

—Z 

—zzzzzzzzxzzzxzxzzxxxxxxxzzxzxxzxxnzzxzxzzzzzxzxxzxxxxxxxxzxxxzxxzxxxzzz: 


•q 


with TEXT 10: 

procuduro*'C0IITE0Ljr0URSELP la 


MAX NUMBERS t 


taut SOO; 


typa NUMBERS la raaga 0..MAXJiUHBERS; 

eypa COLORS la ( RED. WHITE. BLUE. CREEN ); 

typa ABlATjnrPE la array ( COLORS ) af NUMBERS; 


MY ARR > ARRAY TYPE t* ( 2.46.12.38 ); 
TOTAL > NUMBERS i- 0; 



1 


1 

! 


paekaga NUM_10 la aav TEXT_IO.IMTEGBR_IO( NUMBERS ); 
bagia — CONTROLjrOURSELF 

Add tha eoaponanta of tha array toRathar and put tha raaulc in TOTAL 

— If TOTAL ia batwaan 1 and SO than add S to tha TOTAL 

Xf TOTAL la battfoan 91 and 200 than add 10 to tha TOTAL 

— Xf TOTAL la batwaan 290 and 300 than aubtraet 10 fron tha TOTAL 

— Xf TOTAL ia anything alaa than aat TOTAL to aaro 

— Print out tha raault 
and CONtROLjroURSELF; 




Ctepter § 

fOBHOQIMtS 

MJWnfl tht MbprogrM i« iaplasantad. 


Given a progran apaeiflea* 
tlon, atudanc Inatmctional aatarl- 
ala» and atudant netati uta aukpro- 
grans to eorraetlj laplaaane tlia 
pteblaa. Prograa aase eenfoca to 
eoursa aoftwara anglnaarlng atao- 
dards. Instructor asp provido up to 
3 asaista. 

xmoooenoM 

Subprograas ara tha prlaary 
aaaaa of daflnlng abatraec aetiona 
chat taka placa In our apatan* For 
axaapla« vWan wa call tte addition 
rotttlna to add two nuabara, ua doa*t 
eeneam ouroalvaa with etia ataps 
chat taka place to add tha nuabara— 
only that tha raault la eorract* 
Tha saaa appllaa to routlnoa that wa 
daslgttt ooaaona who uaaa that row- 
tins can eoneantraca on what tha 
funetloo doaa rachar than how It 
works. 

Subprograas aid our daslgn of* 
fort In that wa can break up tha 
largo systaa late aaallor, aoro un* 
darstandabla places and use subpro- 
grass to laplananc aoaa of tha 
places. 

nraMTioM 

Thera ara two foras of subpro* 
grans In Ada: precaduras and func- 
Cions. Procoduras ara uaad to in¬ 
voke aoaa action. while functions 
are osod to eoaputa a valuo* 


loth procoduras and functions 
have two parts: tha apaclflcation 
which tails HHAT tha subprogran 
does, and the body that calls HOH 


Specif leaden: 

pBQcadura FRDirjirjWC; 
lodyt 

TBCMD; — to gain aesaaa to 

— tapuc/Queput loudnaa 
pCQoaduia FUNTJinMIC la 
— Daelacatlva hin 
taigiA 

— iaacutabla Part 
ncr ID.IUlCJoa"); ' 
mi imrjtfJMC; 

Aa shewn above, tha body la also 
divided Into two parts: tha daelar- 
ativa part where wa can daelara lo¬ 
cal typos, variables, or progran 
units; and tha axacucabla part where 
wa define tha ataps to bo onacutad 
whan tha procadura la called. 

If wa had a progran that needed 
this routine, wa could call It fron 
Chat progran:' 

with FRDirjirjwc: 
pcoooduca Htni is 

bagin —HUM 

PUNT nr m€i — OUl to pnoadm 
and PUNT nr WVC; 


PAIAHITBI3 

With tha pravieua procadura, wa 
couldn’t tall It which naan to 
print—it would always print “Joa*. 
in order to eeanunieata with this 
procadura, we need to sat up parana- 
ters to pass data to it: 

proeadiffa FIONrjtfJifMKIMC : In SHINS); 


6-1 




Now when wo coll tho proeoduroi wo 
wuit oloo past a valuo to It of typo 
STRING to aacch this paramtor NAME. 
Tho body would look llko: 

with TESCT 10; 

pcocodun^PRlNr NT NMEdWC : in 

SDUNB) la 

bi|ln 

ma io.iur(N/»c}: 

Fiokjffjwc: 

To call chla procoduro froa our aain 
pregraa: 

with nUMT NT NM; 

pcooodumMUila 

bagln oMON 

. FRINTMT NMCCJoa"); 

print« rtt»«"SaUy"); 

•idmn?;** 

In elaas you'll aoo tho differ* 
ont Bodoa allowed for paraaotora to 
paaa data Into or out froa a aubpro* 
gran. 

fUMCIlOMS 

Aa we aald oatilor, a procedure 
porforaa aoao abatract action, while 
a function eoaputoa a valuo. He 
reflect thla in tho ayntax by adding 
a 'return* clauao to the end of the 
apeclflcation Indicating the type of 
value returned: 

function OmE (MMER : INSCEIO 

letum INIBC231: 

When we call thla function. It will 
return the coaputed value to the 
point where it waa called. There¬ 
fore, we can only call a function aa 
part of an expraaaion. We can keep 
track of the reault by aaaigning 
to a variable t 


wich OOUBl; 
pcoeadum OCUIHJE^R la 

■SUl t INIBGBl; 

bifln —OOUBUE n 
RSULT DOUUKS): 

^ RSIIJ haa a valua of 10. 
owi iailLE_IT; 

tBMAlT 

Subpregraaa provide a tool for 
defining functional abetractlbna of 
our ayatea. Lika other prograa 
«mlta, we can aeparate the WHAT 
(Specification) froa the HOW (body). 
Ada glvea ua two forma of aubpro- 
graaa, procedurea and funeciona to 
repreaent actlona or caleulactona. 


niBCISE 6-1 

Note: Soae of the aaterial needed 

to anawer the following queationa ia 
only covered in the Lecture. - 

1. What are the three aodea for 
procedure paraaetera? 


2. The only aodo allowed for func¬ 
tion paraaetera la . 

3. Define: 

a. Actual Paraaetera 


b. Poraal Paraaetera 


A. How do aubprograas aupport ab¬ 
ac ract ion? 


3. How do aubprograaa aupport modu¬ 
larity? 


6-2 



miCTn *-2 

1. Mwrltt tht aubprograa btlon InCo on* ■aln lubproftMi and thrta aabaddad 
aubprograaa* Uaa aubunlta to placa tha aubprograaa in a aaparaca flla. 

2. Tha aaln aubprograa will alaply call the firat aubprograa co proapt for 
and gat the naaa* Tha aaeond aubprograa will count the nuabar of 'S'a in tha 
naaa. Tha third aubprograa will echo the naae back to the uaar« 

3. In the body of tha aaln prograa» call tha aubprograaa in the order Hated 
above to get a naae, count the nuaber of *S*a, and print echo back the naaa 
and nuaber of *8*a* 


—xzxzzzzznzxmxmxxzxzxzzmxzmzxzzzxxxxxzsmxzxzxxxxnxxxxxzznzxzz 

—z X 

counta the nuaber of upper X 
naaa aa well ae the nuaber X 

Z 
Z 
X 

z 
z 

X 

—zzxzxzzxzzzxzzzxxzzzzzzzzxzzzzzzzxxxzxzxzzxzzzzxxxxxzxzxzzxzzxzxzxzzxzxzz 


— z 

Abatract: 

Thla prograa made In a naae. 

— z 


caae 'S'a, and eehoa back the 

— z 
—z 


of 'S'a In the naae. 

— X 

Author: 

Sleepy 

••A 

— X 
— X 

Date: 

14 Jan 76 


with TEXT^IO; 
proeedure~BC110jNAME la 

HAX LENGTH : eonatant :• 80; 


aubtype LINEJTYPE la STRING( 1 • .NAX_LEIIGTH); 

type NAME TYPE la record 

CHARACTERS : LINE TYPE; 

UNGTH : NATURAL; 
end record; 


~ Make your declaratlona here 
begin 


— Make your aubprograa ealla bare 
end ECHO NAME; 


6-3 


BAWII ^1 

xxixxxxxxxxinxixuzinxaiixxxtxtttzunxxizuxxxxxxtiunntxxttxxiixx 

—» 

—X Abstract: This prograa laplcMnts cha faaous Huapty Duapty 
-"■X algoritha. 

—X 

■-^X Author: Sneasy 

—X 

—X Data: 1 Sap SO 

—X 

SZXXZZXXZZXXXZXXXXXXXZZXXUXXXX3EXXZmmXXXZXXXmXXXXXXXXXXXXXXXXXXXXX 

proeadura NOTHBKjBOOSt la 

MAX 106 HBADBDMBSS : constant :■ lOj 
NASOotir*: constant :* SO; 

MAirvOKSES : constant :■ SO; 


type BGG_HEAD Is range l.*HAX^EOGJHEAODEDNESS; Dagrst of agghaadsdnass 
type MEN is range l..NAXJ(BN; 

type HORSES Is range U.MAX^IIORSESi 


HUMPTY OUMPTY : EGG HEAD :- 7: 

ALL KlUCS HEN : HElT :• IS; 

ALL^CINGQKH^BS ‘ HORSES :- IS; 

m 

procedure SATjONJfAU ( PERSON : in out EGC^HEAO ); 

procedure'HAOJSREAT.PALL ( PERSON : in out BGG_HEA0 >; 

procedure GETJOFFJIALL ( PERSON : in out ECC_HEA0 ); 

function CAN PUT TOGETHER AGAIN ( PERSON : in EGG HEAD; 

“ " “ HOH MANY : in MEnT 

HOITHANY : in CiORSBS ) 
return SOOLSAN; 

-xxzxxzzzxzxzzzzzxxzxzxxxxxxxzzzzxzxxxxxnzxxzzzxxzzzzzxxxxzxxzxzxxxxxxxzx 

-X 

-X Abstract: This subpragraa sits a person on a wall. 

*X Author: Sneasy 

-X 

-X Date: 1 Sop 80 


proeadura SATjDNJIALL ( PERSON : to oat 
begin — SATjQNJfALL 


fOC^NBAD > is 


end SATJONJWALL; 


aeMMMMMM 










--mxmzmuunzxmxmmmmmxmxmsmmxmuxmumxnx 

—X Abstracti Ibis aubproiraa glvaa you a graat fall. 

—X 

~Z Author t Dopoy 

—X 

—Z Data: 1 Sap 80 

~XXXXXfXX«?X«««« ««« ”8««g«XXXXXIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
proeadura gADJBtlAT^rALL ( nUOtl t la out gOGjBAD ) is 
baglB — lADjBIIATJPALL 


and HADJElIAT^FALLi 

—xzxzzxzxzxxxzxxxxxxzzxxxxzxxxxxxxxxxxxxxxxnxxnsxxxxzxxxzxxxxzzzxxzxxzzz 
— y " 
—Z Abstract: This aubprograa gats a parson off of tba wall. Z 

~“Z * 
->Z Author: Slaapy * 
"-Z * 
—Z Data: 2 Sap 80 ^ 

H jjrrrrrrrri l XWttttMMtm gTXXXMXXXXXtXXXXXXXXXXXXZXXZXZUXnZZZnXZZXZZZ 
procadura GETJDFPJIALL ( PERSON : in out BGCJIEAD ) is saparata; 


-Z Abstract: This funetlon datoralaas if a paraon can ba put bach 
.g togathart gluan a nuabar of HIN and HOMES. 

-Z 

-Z Author: Saaasy 

-Z 


~Z Data: 


1 Sop 80 


—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzxxzzzxzzzzzzzzzxzzzzzzzzzzxzzzzzzzzzzzzzzzzz 

' inctlon GAN PUT TOGETHER AGAIN ( PERSON : la EGG HEAD; 

~ • " HOW HAHY : In HEN; 

H0W'*‘MANY : in HOMES ) 
racum 800L8AN la saparata; 

—zzzzzzzzzzzmznxzzzzzzz notherjcoose xzzzzzzzzzzzzzzzzzzzzzzxzzzzzxzzzz 

bagln MOTHIRJOOOSE 

SAT OH HALL ( UMPTTMHPTY ); 

HAOngXlAT PALL ( WNPTfiMMm l{ 

If tSM Piff lOCI t Ti m AfiAHl ( ■ONPTTJMMPTY» ALLJtlHGSJIXN. 

• ^ ALL RINGS HOMES ) than 

GET OfP HALL ( HOMPTTJDOHPTT ); ^ 

and lf7 

and HOTHERJBOOSE; 


6*5 



omemi 

Glvwi • procvM •p«cifieaeiont 
•tttdant iMtruetioMl Mtarlala, and 
•tttdanK DOtat» uaa paekagac to cor* 
netly laplaMnt cha problaa*. Fra- 
graa wiac eoafen to eoaraa aafniara 
aaglsaarlag aeaadarda. Xaacraator 
■ay provlda up to 3 aotiatt* 

xmoBucnn 

A paelMga la ona of tKa atoat 
powarful tooLa in tha Ada languaga* 
It allotia ua to daflna a aora aaan* 
Ingfttl atruetura to our aoftaara* A 
paekaga la daflnad aa a collaeetoa 
of logically ralatad ancltiaa, aueh 
aa typaa or aubprograaa. Thia tool 
allova ua to diraetly laploaant 
priaeiplaa of aoftwara anginaaring 
aueh aa aodularicyt loealltatlon, 
abattaetloa and Inferaation hiding. 

oraMinw 

A paekaga ia lika eho ochar 
program unite in that Ic eonalata of 
a apacificacion and a body. Tha 
apaelfleation glvaa tha logical viaw 
of UHAT ia in tha paekaga while tha 
body dafinaa HOW thaaa faaturaa ara 
iaplananted. Thia aaparation of 
apacificacion and body (tha WHAT 
from tha MOW) ia tha kay to engi> 
naaring undaratandabla and naintain** 
abla coda. 

graczncATioM 

The apacificacion of a paekaga 


■ay ba placed in ita own file and 
eanpilad all by itaalf* Inaida tha 
apacificacion wa declare tha typaa 
and pregraa unit apaelf Icationa of 
tha antitiaa wa wane to anport to 
other pragrana. 

paehiigi munnOHJPS la 

type anus ia («, OPF); 
type OIMB. ia canga 2..a0: 

type TV ia 
laeaid 

IV SDOUS : smtlS :• QfF; 
tToMIICL : OMNCL :• 2; 

■id nMord; 

proMdura TIM CN(sa : in out IV); 
pnaadma lUMCmSD t in out T*); 
ptooadura gST OtMiBUSbT : in out TV; 

~ ID t in CHMMUM 
proQidtfa MRTJMHNiUSBr t in out TV)^ 

«d luvisiaNacis; 

In thia package» wa ara nodaling a 
talaviaion. Our TV.ia dafinad aa 
having a TV STATUS and a currant 
TVjCHAMNEL. What can wa do with 
thTa TV? Wa can turn it on. turn it 
off. or changa the channal. In thia 
aingla package, wa have dafinad our 
logical view of a talaviaion aat. 
Tha package allows us to iaplanent 
object abstraction by grouping tha 
type TV and all of ita oparationa 
together in one paekaga. 

Ha can now uaa thia TV oodal in 
pregrana no may writet 



mth nuinsioi ans; 
pnotkn imcjaijras i» 

MirjSGNr t m^Sl(M8IS.1V; 

piooidiin IMQi TV Is Mpmea; 

ftmetlon ISJTCRTS cvcutn lOQUiW 

!■ apmc*; 

b«ln ^wanjOiJNm 
mr IS SfOQS IflOD 

iBroia{aEis.iTOj»Maj(HT_aaw 

•Ml loap; - — — 

waxxvii 

md UXKJ^SPOiaS: 

Th« 'irst lint of our progroo it • 
"conttxc clauM*** It givat ua te- 
eats CO avaryehlng that it daclarad 
In cha packaga apaclflcatlon. No> 
tiea how avarywhara wa rafar to any~ 
thing out of tha packaga, wa prafaca 
it with tha naM of tha packaga: 

KY^SONY : TBLBVXSlON.SRS.TVi 

Thia halpa out cha aaincananca pro- 
graaBar locaca whara typa TV is lo- 
eacad* 

iOOT 

Tha apacificacion gava ut tha 
logical view of what wus in tha 
package. Tha body daflnaa the !•- 
plaaantation details of what ia dc> 
dared in the packaga specification. 

When a main prograa uses a 
packaga, it only has acceaa to 
things declared in the packaga 
specification. Tharafora, anything 
defined in tha packaga body chat 
ian'c daclarad in tha spacification 
is hidden free tha asin prograa. 
This eoneape directly iaplaasnts ths 
principle of inforaation hiding* 
Thia tends to asks prograaa acre 
aodifiabla because changes to tha 


iaplaaentacion details (body) won't 
affset other prograaa, as long as 
tha intarfara (apacificacion) ra** 

aalns cha aaaw. 

paciwgc body TILEVISIOMJCR is 

pcooadun lUMJlKSEr : in out TV) is 

bagln —TUMCN 
Sr.TV SSOIB :• OM; 
and TIMToNi 


pcooadun TUIMJfr(Sr : in out TV) is 

tagln — TUMJfT 

SET.TV SEAIUS OFF; 
and TIMTopT; 


prooaduca SET CHMIKUSKT 

ID : 

: in out TV; 

In QWtCL) ia 

bagln — SerOMICL 
SET.TVJSMMSL :• Tt)( 
and SCr^Mm.; 



preoaduca MSCT OMIMEL 

(S^ : In out TV) is 

bagin — NQCr.OMNCL 
Zr.TV OMtB. :• SR.TV OMItCL * 1; 
and NScTawWL; 

and TBjeVISKXt.St'ni; 


PklVATE TYPES 

If we look back at our package 
spacification, you'll notice that 
prograaa that use this packaga have 
access to the details of type TV. 
In Many cases wa way not want this* 
To support cha principle of inforas- 
tion hiding, wa would like tha abil¬ 
ity to hide the iaplaeantation. of 
this typa as wall, Ada allows us to 
hide these details through tha use 
of a prlvsta typa: 


7-2 



firiiii vwimyMi t* 

t!m omm. <• mm s*«ni 

typt IV ti 1MM4 pciwifeil 

pnoidtm imyiKar I til M TV)t 

IwiMliw t ti> mt tV)t 

pwPi^rt «rJmiliB4«r i la «ut W; 

« I in OMMA)} 

I—NDqjmiMUffr t m nut iv)i 

prtvMi 

typn naiB la («, air)t 

typiWla 

TCoairi 

IV fDoui I maiB t« owt 
iToMML t CMMB. {• l\ 
and naoidt 

and mviSUNJCnt 

Now ochor progroM can only aceoot 
anyehinf In cha VXIUU pare of tlia 
paekagai chat part pafora tha word 
prlwatoi tatwaon eha word prlwoea 
and eha and of eha paehaia tpaaifl> 
enelofi la eha prlaaea pare whara wa 
dafina eha full eypa daelaraeion* 

Vhon anoehar pragraa uaaa chia 
paekaia, eha only allowad oparaelona 
for eypa TV ara ehoaa also dattnad 
in eha paekaga apaeifleaeiont 
TURN ON, TURN OPF, fIT.CIUNNIL, 
NtXT^^eiUNNBL. Ha ean'e avan aaalgn 
ona 'objaee of eypa TV to anoehar. 


•y Mking typa TV privaba, wa dany I 
oehar pragraa uniea eha ability to ! 
aaaaaa tha aaapanonea af a TV* 
ba chaaa eaapenonti aay ahaaga* 

■ 0 , oehar prograa uniea won't ha 
affantad baeauaa thay ara otill ] 

foraad to aanipulaea tha TV only 
through tha aparationa liaead in tha 
paehaga apaaifiaaeion* 

tnaida tha paakaga Rady howov 
at, tha aadar haa full aaaaaa to , , 
gVUYTNXIlO dafinad In tha apaaifiea- 
eian, ineluding priuata cypaa. 

Tharatara ha can rafar eo tha eanpo- 
nanea of ohjaata of typa TV* In 
oaaanea, our paehaga body would ra* 

Min eha aoM aa It wai whan typa TV 
waan'e privata* 


' gQMIRiy 

Paekagaa ara a vary powarful 
tool Chat diraeely aupporc nany af 
eha prlneiplaa of aofewara anginaar- 
in|. Tha apaeifleation providaa eha 
abacrael viaw of eha eollaetion of 
raaoureaa, whole cha body hidaa eh|^ ’ 
dataila of chair iaplananeaeion* 
ean uaa eha paakaga eo break up 
aofewara ayatoa into logically ra- 
latad, locallead routinai* Thia 
* added faacura allowa ua eo dafina 
now eypac of abacraceion, aueh aa 
objaee abatraecioni that aren't 
available in languagaa whara a aub- 
prograu la tha priaary acrueturing 
cool. 


1-3 






Bncui 7-1 

1* Modify tha following prograo no ehat all Cho eonncanc, typo and aubpregraa 
doelaraciono arc In a aaparatoly eoopllod paekaga. Tha oaln aubpregraa ahould 
daclaro tha array objaet and aaka ealla to tha routlnOa In tha paekaga. 


—zzzmzxzzxxzzzxmuzzzxzzzxxzxzzzxmzzzxxzzxxxxxxxxxxzzTzxzxzxxzxxxxT; 

“Z 



Abacract: 


Authort 


This prograa gats a word froa tha kayboard, Invarts tha 
eharaetars in tha word, and prints It back out In its 
Invarcad fora. 

Joa Dynaalta 



Data: 


4 Jul 83 


—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzzzzuzzzzzzxzxzzzzzzzzzzzxxzzxzxx 


with TEXT 10; 
p r o e oda r a ^ IliVEkT^AMAY la 

MAX HUM : coaataat 5; 


aabtypa C APIT ALS is CHAltACTCK^ra^a 'A* 


typa mm ITEMS is ra^a 1..MAX 
typa CAP^ARR la array ( NUH^tTEMS ) of CAPITALS; 


WORD : CAP.ARR; 

proesdura CET WORD ( NEW WORD 
hogia “ “* 


out CAP ARR ) is 


lor INDEX in NEW WORD*RANGE loop 

TEXTJO.PUTj '^INPirr^A^CAPlTAl. LETTER 


TEXno.CETI 
ad loop; 

GCTJfORO; 


NEUJII0R0( INDEX) ); 


); 


proesdura INVERT WORD ( BACK WORDS : in out CAP ARR ) Is 
TEMP WORD i CAT ARR; ~ “ 

haglo ” ” 

for INDEX la rovaraa BACK WORDS*RANGE loop 
TEHPJWORD( BACKJfOROS'lJST - INDEX *l ) BACKJtfOKDSIINDEX); 

BACK WoE6s TEMP WORD; 
sad 1I*7ERT_W0RD; ” 


proesdura PRINT WORD ( FOR WORD : la CAP MIR ) is 
hagln "" 

for INDEX la FOR WORD*RANGE Isoi 


Xor INDEX la FOR WORD'RANGE ISOp 
TEXT_IO.PUT( «JRJW0RD( INDEX ) ); 
sad iMp; " 

sad PRINT^WORO; 

bseto — INVERT^ARRAY 


GET II0RD( WORD }; 

inYErt word( word ); 

PRINTJ0ORD( WORD ); 
sad INVERT ARRAY; 


7-4 








7-1 


-zxzzmzxmxxxzzzmxsxzzxzxzzxzzxmxxxzxmxxxmxxzxxzxxxxzxxzzxxzxz 


Abteraeet 


Autbortt 


Dat«i 


Ihi* package eontalna trig fuaetiona that Mork on the 
praAafinad typo FLOAT. It ceocalna tho traditional trig 
funetlona, are trig fuactiOBa. and hyparbolic trig 
fuaecioaa. 


—X 

—xxnxxxxxxxxxxxxxxzxxxxxxxxxxxxxxxxxxzxxxzxxxxxxxxxzxxzzzzzzzzzzzuxxxxz: 


V A IMITAKIA 
T C tlCKLIX 

16 JULY 1982 


AFATL lOLtM AFB FL 325A2 
UlAFA 


package TKTGJLIB la 

function 8Xil(X s FLOAT) return FLOAT; 
function COS(X t FLOAT) return FLOAT; 
function TAN(X t FLOAT) ratum FLOAT; 
function COT(X t FLOAT) return FLOAT; 


function A81N(X t 
function ACOS(X t 
function ATAN(X : 
function ATAN2(V. 


FLOAT) ratum FLOAT; 
FLOAT) ratum FLOAT; 
FLOAT) return FLOAT; 

U i FLOAT) mturn FLOAT; 


function 8INH(X t FLOAT) ratum FLOAT; 
function COSH(X t FLOAT) ratum FLOAT; 
function TAMKX t FLOAT) ratum FLOAT; 


and TtlG LIB; 


package body TK1GJ.IB ia 

function SIN(X t FLOAT) raturn FLOAT la aaparata; 

function COS(X i FLOAT) return FLOAT la aaparata; 

futjctlon TAN(X t FLOAT) return FLOAT la aaparata; 

function COT(X t FLOAT) return FLOAT la aaparata; 

function ASXN(X ; FLOAT) ratum FLOAT ia separata; 

function AC08(X t FLOAT) ratum FLOAT is aaparata; 

function ATANCX i FLOAT) return FLOAT is aaparata; 

funetlan ATAII2(V. U t FLOAT) ratum FLOAT is aaparata; 
function SXmKX t FLOAT) ratum FLOAT is aaparata; 

function 008II(X t FLOAT) ratum FLOAT is separata; 

function TAMN(X i FLOAT) ratum FLOAT Is aaparata; 

end TEIG LIB; 


7-5 




—IMMIill!I!iII!t!li!ini!I PRELlMlHAIty VEftSXON 111 ! 111111111111II1111111 

-zxzzzzzzzzzzmzzzzzzzzzzxzzzuuzxmzzzzzzzzzzzzzzxuzznzzzzxuzuztzz 


~z 

—Z Abstract: 

—Z 

—z 
~z 
~z 
— z 
—z 
— z 

—Z Authors: U A WHITAKER APATL EGLZN API PL 32S42 
~Z 

—z 
—z 
— z 

—zzzzzzzzzzzzzzuzzzzzzzzzzzzzzzzzzzzznzznuzzxzzzzzzzzzxzzxzzzzzzzzzzzz 


The following routine is coded with reference to the 
slgorithas and coeficients given in "Software Manual for 
the Elesientry Punetions" by Hilliaa J* Cody, Jr. and 
Willian Waite, Prentice Hail, 1980* This particular 
version is stripped to «rork with FLOAT and INTEGER and 
uses a Bantissa repreaented as a FLOAT. A oore general 
fomilatlon uses MANTISSA^TYPE, etc* 


Data: 


H A WHITAKER 
T C EICHOLTZ 

16 JULY 1982 


APATL EGLIN API 
U8AFA 


separate (TRIG LIB) 

with CORE PUN(?flONS; 

function Tin(X : FLOAT) return FLOAT is 


Cl 

C2 

SGN, Y 
N 

XN 

Xl, t2 
RESULT 
TMAX 


BETA 

EPSILOH : 


constant FLOAT 
constant FLOAT 
FLOAT; 

INTEGER; 

FLOAT; 


3.14062S: 

9.6765 $&897 93E-4 



FLOAT; 

FLOAT; 

FLOAT :• FL0AT(1NTEGER(C0R£ FUNCTIONS.PI * 

CORE FUNCT10NS.TW(F>^(C0RE FUNCTIONS.IT/2))); 

FLOAT :• CORErFUNC71CNS.GONVE»TO'~FLOAT(CORE FUNCTIONS.IBETA) 
FLOAT CORT^FUHCYIONS.BETA *«~l-XZ>RE FUNCTIONS. IT/2V; 


begin ~ SIN 


if X < CORE FUNCTIONS.ZERO then 
SGN 

Y -X; 
else 

SGN 

Y 

end if; 


-ODRE^FUNCTIONS . ONE; 


- CORE FUNCTIONS.ONE; 
X; 


N :« INTBGCR(Y * CORE FUNCTIONS.ONE OVER PI); 
XN CORE FUNCTIONS.TI^OKVCRT TO FL0Xr(N)T 
If N ood 2“/“ 0 then "" ”” 

SGN -SGN; 
end if; 


XI CORE FUNCTIONS.TRUNCATE!abs\X)); 

X2 abs(lf) - XI; 

F :• C(XI - XH*Cl) + X2) - XN*C2; 
if abs(F) < CORE FUNCTIONS.EPSILON then 
RESULT r- F; “ 

^Ise 

C *- F * F; _ 

RESULT F 4 F*C0RE FUNCTIONS.R(C); 
end if; 

return (SGN * RESULT); 


end SIN; 


7-6 


MM *< M M MM M •« M »•»« M M 


=i 


?-2 

1ZZZZXXZZZUZZZXXXZZZZXZZZZZZSSZZZX»XXUSXX»ZSZXXXXXZXZZZZZZZXZZXXZZZ 

Abatraet: This paekaft dafinaa a rational nuabar cyp«i The 
following routinaa ara providad to work with thaaa 
rational nunbars: 

NUMERATOR OP - Raturna tha nuaarator of tha nuabar 
OENONINA'^ OF Ratuma tha danoalnator of tha nuabar 
make ~ Hakaa a rational nuabar froa intagara 

- Adda rational nuabara 

• Sttbtracta rational nuabara 

- Hultlpliaa rational nuabara 

*/” * Mvldaa rational nuabara 

DISPLAY * Diaplapa a rational nuabar to tarainal 

Author! Mua Surra 


Data: 23 Nov 8S 

izzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxzxzzzzzzzzzzzxzzzxzzzzzzzzzzzzzzz 

packaga RATIOKAL_NONBERS ia 

MAX VALUES t eonatant INTEGER*LAST; 


typa VALUES ia range -MAX VALUES .. MAX VALUES; 
aubtypa POSITIVCJTALUES it VALUES ranga~l .. HAXJ/ALUES; 

tppa NUMBER TYPE ia prlvata; 


function NUMERAfOR_OF( A_NUMBER t NUMBBKJTYFE) raturn POSITIVE^VALUES; 

function DENONINATORJOF ( AJNUNBER ! NUHBERJTYPE ) raturn VALUES; 

function Make ( TOP : VALUES; 

BOTTOM : POSITIVEJVALUES ) raturn NUHBER_TYFE; 

function < LEFT, RIGHT : HUMBER_,TYPE ) raturn NUMBEK_TYPE; 

function ( LEFT, RIGHT : NUHBERJTYPE ) raturn NUHBER.TYPE; 

function/*" < LEFT, RIGHT : NUMBER^TYPE ) return NUHBER_TYPE; 

function "/" ( LEFT, RIGHT : NUHBERJTYPE ) raturn NUHBERJTYPE; 

proeadura DISPLAY ( A^NUHSER t NUMBERjTYPE ); 

prlvata 


typa NUMIBRjrTPX ia 
record “ 

NUMERATOR t VALUES: 
DENONINATOR I POSITIVE^VALUES; 
and record; ^ 


and RATIONAL NUMBERS; 


7-7 








with mt XO; 

p«ekag« RAT10NAL_in)MlERS 1« 
psekagt VALUE_IO Is nsw TEXT_I0.INTB6EE_X0( VALUES )i 
—ZZZZZZZZZZZZXZXnZXXXZXZZEZZZXZZEZXnZEXXZX7»ZXXXEZXXZXZXZX%XZEXXEE»ZXX 

—z z 

—'Z Abstract: This function returns tha nuacrator of ths rational Z 

—Z nuabor* Z 

—Z X 

—Z Author: Nua Burrs Z 

~Z Data: 25 Nov 65 Z 

—Z Z 

—zzzzzzzzzzzzzzzzzzzzsuzzzzzzzzxzzszzzmzzzzzzxzuzzzxzzzzzzzzzzzzzzzzzz 

function NUMERATOR_OF (A_IIUHBER : NUHBERJTYPE) return FOSITIVEJTALUES it 

bsgln —> NUMERATORjOF 

return A NUMBER.NUMERATOR; 
and NUMERATORjOF; 

—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 


—z z 

—Z Abstract: This function returns tha danoalnator of tha rational Z 

—-Z nuabar. Z 

-Z Z 

—Z Author: Nun l4urrs Z 

—Z Data: 25 Nov 85 Z 

~Z Z 


—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

function DENOKXMATOR_OF (A_NUMBER : NUMBER^TYFE) return VALUES Is 


begin -> DENOMINATOR OF 

return A NUMBER.OENOMINATOR; 
and DENOMINATOR^OF; 

—zzzzzzzzzzzzzzzzzzzzzxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 


~Z 2 
-"Z Abstract: This function takas a VAUIES and a POSITIVE_VALUES and Z 
->Z creates a rational nuabar out of them. Z 
—Z Z 
~*Z Author: Nun Burrs Z 
•*-Z Data: 25 Nov 85 Z 
—X Z 


->zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxzzzzzzzzzzzzzzzzzzzzzzzzz 

a 

function MAKE (TOP : VALUES; 

BOTTOM I FOSXTXVEJVALUES) return NUKBERjnPE is 

begin HAKE 

return ( TOP, BOTTOM ); 
and MAKE; 

7-e 

(# 





~%xzxzxzxzzxxzzxxzzxxzzzzxzxzszzzxzxzzxzxzszzxzxzzzxxxnxnxxsx»zz»zxzxx 

—'Z Abstractt This function adds two rational nuabars* Z 

•~Z Author: Nun burrs Z 

^ZZZZZZZZZZZZXZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ 

function "4'* (LEFT , RICHT : MIHBER TYPE) ratum NUMBER TYPE Is 
bagln •“ ” 

ratum (( UPT.NUHERATOR * RIGHT.DBNOMINATOR) •f 

(RIGKT.NUMBRATOR * UPT.DBMONINATOR), 

LEFT.DENOHIHATOR * RIGHT.DENOMINATOR); 

and *4"; 

zzxzzzzzzzzzxzzzzzzzzzxnzxzzzzzzzzznzzzzzzzzzzzzzzzzzzzzzzzzzzxzzzzzzzz 

Z Abstract: This function subtracts rational nunbars* Z 

*-Z Author: Nun Burrs Z 

—zzzSlzzzzxzzzzzzxzzzzzzzzzzxuzzuzzzzzzzzuzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

function (LEFT , RIGHT : NUMBER TYPE) raturn NUMBER TYPE Is 
bagln — ” 

raturn LEFT 4 (-RIGHT.NUMERATOR.RIGHT.DBNOHINATOR); 
and ; 

—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

—Z Abstract: This function nuLtlpllas rational nunbars. Z 

—Z Author: Nun Burrs Z 

—Z Data: 25 Nov 85 Z 

—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxzz 

function (LEFT , RIGHT : NUMBER TYPE) raturn NUMBER TYPE is 
bagln — “ “ 

ratum (LEFT.NUMERATOR * RIGHT.NUMERATOR. 

LEFT.DENOMINATOR * RIGHT.DENOMINATOR); 

and * : 


—zuzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzmzzzzzzxzzzzxzzzzzzzzzzzzzzzzzzzzzzzzz 

—Z Abstract: This function divides rational nunbars. X 

—Z Author: Nun Burrs Z 

—X Date: 25 Nov 85 Z 

—zzzzzzzzzzzzzzzzzzzzzzzzxzzzzzzzzzzzzzzzzzzzxzzzzzzzzzzzxzzzzzxzzzzzzzzzz 

function "r (LEFT , RIGHT : NUMBER TYPE) return NUMBER TYPE Is 
begin — 

raturn (LEFT.NUMERATOR * RIGHT.DENOMINATOR, 

LEFT.DENOMINATOR * RIGHT.NUMERATOR}; 

and "/••; 

—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxxzzzzzzzxzzzxzzzzzzzzzzzzzzzzzzzzzzzz 

—Z Abstract: This displays a rational nunber to the taralnal. Z 

—Z Author: Nun Burrs Z 

—Z Date: 25 Nov 85 Z 

—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

E rocedura DI8PUY ( A NUMBER t nunbar type ) Is 
sgin — DIBPUY ” ” 

VALUE IO.PUT( A NUNBBE.NUMEIATOR ); 

TEXT To.put(7'7; 

VALUE XO.PUT( A NUMBER.DENOMINATOR ); 

TEXT_TO.NEH_LXlff; 

and DISPUY; 

and RATIONAL_NUMBERS: — body 


ChMCcr 8 


nc EP i i c w 


OUKTIfE 

Glvan ■ prograa ■paelfieaeloii, 
•tudcnt Instrucclonal Mtcrlals, and 
•tudant notas, add axeaptlona to 
eorractly iaplnaant tha program. 
Prograa autt eenfora to eeoraa aoft* 
vara anglnaariag atandarda. In- 
atruetor maj previda up to 4 aa- .. 
alaca. 

nmaoDcnoH 

tfhan working with anbaddad eo*- 
putar oyatana, rallablllty of our 
aoftwara la a najor eonearn. Soft- 
wara la a vital conponant control¬ 
ling aircraft or nlaallaa wboaa 
failure can hava dlaaatroua raaulta* 

In ordar to deal with arror eondi- 
tlona, Ada daflnoa aonathlng called 
an axcaptlon. An axcaptlon la tha 
nana of a condition that la unuaual 
(an error). We can than apeclfy, 
via an exception handler, what ac- 
tlona wa want to taka whan thla con¬ 
dition oeeurt. 

monuTiaH 

There are a nunber of predefined 
exceptIona In Ada. Theac are ratacd 
autonatlcaily whenever the aeaociat- 
ad condition occura during the exe¬ 
cution of the program. Sone exaai- 
plea are CONSTflAlNT__ERROR (Ralaed 
when a conatralnt la violated, auch 
aa whan you aaalgn a value that la 
out of range to a variable), STORr 
AGE^ERROR (Ralaed when there la not 
enough nenory left to continue axe- 
eutl on) or DATA^ERROR (Ralaed within 
TIXT^IO wheneveT you GET a bad Input 
value). TO define what action 
■hould be taken when theae eondl- 
tlona occur, you can define an ex¬ 
ception handler. 


■AHDLIIIG BXCRPnORS 

Whan laplanented, an exception 
handler aunt be placed at tha e^ of 
tha aequenea of atetenanta In a 
fraua. A frana can be thought of aa 
any bagln-end block, auch aa a 
prograu unit or block atateaent. 
Tha ayntax of an exception handler 
la alullar to a caaa atatauant and 
looka Ilka thla: 

with TBCT JO; 

pnooaduawlESniC la 

MX t conatint :• 100; 

type SOMES la taige 0'..MX; 

Mr SCORE : SCORES; 

padiaga SCDR ID la new 

iBcr_io.iNiBaRjo(sooRs): 

begin — lESHNC 

TEXT lO.FUlCatter teat acota: '‘); 

8C0K lOUZRW SCORE); 

Nf^sdOE f MirJcORE * 2; 

iNcaptian 

whan 1EXMO.M&ygaiOR -> 

TEX^I0.nn( “Invalid ontry." 4 
“ TTy again.*); 

what OK>TRADir EKDR >> 

tvjcnii :• MNC; 

and TBTINB; 

In thla exanple, if the person en¬ 
tering data St the keyboard antare a 
'b* t^n asked for a test score, we 
hava an error condition named by 
DATAJIRROR. Wa say that the excep¬ 
tion DATAJIRROR la ralaed and wa go 
to the aMociatad. exception handler 
to find out what action to take. In 
this case, the neasaga to try again 
will he printed. 


8-1 




LlktwlaCi If th« Miltiplleation 
rasulcs In an anatiar ouc of cha 
ranga for SCORES (abova 100), CON¬ 
STRAINT ERROR alii ba ralaad and 
MY_SC0RE will bt aaslgnad HAX. 

If althar axeaption la ralaad, 
onea tha acataaanta In cha axeaption 
handlar ara flniahad, control paaa** 
aa out of tha frana—jrou DO NOT ra- 
c rn to tha point whara tha axeap¬ 
tion uan raiaad. You can ba era- 
atlva with block atataoMnta to 
localise axeaptlons, as fou'll aaa 
in tha laccura* 

ont OBTIMD ncmtoiis 

Tha axcapciona in Cha axaapla 
abova wara. pradafinad in cha lan- 
fuaga. Tha Ada coapilar Inaarcad 
object coda into Cha prograa to taac 
for Cha eondltiona and raise cha 
axeapeion* Ada also gives you cha 
eapabillcy to define your own axeap- 
tiona. 

Tha declaration of an exception 
looks a loc like an object declara¬ 
tion* Raasebar though chat an ax- 
eapclon is not an objaec that tfa can 


assign a value to, it Just naaes 
aoM condition. See figure S-1. 

Unlike predefined axcapciona 
whara cha cods was autoaatically 
inaartad Co cast for tha error eon- 
dicion, user defined axcapciona ra- 
gulra cha prograeaer to write tha 
code to Case for cha condition and 
raioa tha axeapeion. 

SOMttlT 

Exeapttona can be powerful tools 
in handling error conditions that 
occur during cha axaeuclon of a pro- 
gran. iy using axeapeion handlers, 
you can write coda that will never 
quit abnornally, unlase a hardware 
error kills cha sain processor! 
Inacead you can retry tha operation 
that cauaa tha error, try a diffcr¬ 
ane algorlchn, restart the systan, 
or whatever action is neeaasary in 
those cireunacancaa. Ada cherafore 
allows you to build In rallability 
by letting cha progrannar, not cha 
operettng systan, decide what action 
to taka in cha event of an error 
eondiilon. 


with GIVE ESCIRA INSimCnCN; 
proosdura''lESriFC Is 

HAX : eonscane 100; 

PASSING : oonatant 70; 


type SOORES is ransa 0..NAX; 

subtype FAlLING.SQa^S U SOOKKS r.vige 0..PASSIN0; 

MY Sem : SOOKiiS: 

FAILlNS : exoapeion; 

package SG0fC_lO la naw INIBGER_in(S0CRES); 
bsgln 


1EXT lO.FUrC’Bttar cast saortt **): 

soa r iD.cp <MY sowE);_ 

if NrSOOB in TRXLDG ECOnB dan 
lAa RULDC; ^ 
end if; 

SMoaption 

whn IBCr IO.DgIA_l!WR >> 

TEXT tO.Rnv*Invalid entry. Plaaaa try aK.iln."); 
whBi FAIIJfC •>> _ 

TEXT tO.lvrC'SCudane faiiliat”); 

GIVTSCIRA INSTRUCnON; 
anl TESTING; ~ 

Figure N*!. Uber Dsflnud Dtcaptluna 
N>2 








PltST^MUMBER, 

SBCOlS MUtCBER. 

TOTAL liliaBR } RUmER TTPBi 


pcekaRc NUKBER^IO !■ now TCXT_10.I1I7RGER_I0(NIIHBER_TYPE>; 

begin — ADD_NUMBERS 

NimiER 10.GET(FIRST NUMSER); 

NUMBER~10.GET(SECOND NUMBER); 

TOTAlJkUMBBR t- FZR8T_NUHBER ♦ SECOND^NUHBER; 

•ttd ADD NUMBERS; 


B-3 


wurntM *-1 


imz»»zxzmxsxzzxxxxx»xxnxmmxxnxxx»sxuM»sxxxxxsx»sxxxm: 
z 

Abttraet: This p«ek«f« laplMtntt an aircraft auto pilot. 

The packaia eontaina procoduraa to: 

- Oat tha currant altltuda 

- Dlaangaga tha auto pilot 


—X 
—X 
— X 

—Z Author: 

>-Z Data: 

—Z 

*^Z Propagatad Bseaptiona: 

—X 
—X 
-X 
-X 


T* Ounn 
X2 Jon 88 


ZHPOT ItROR - Miaad ahan Incorract altltuda read 
TOO^^lfrOH^ERROR - Ralaad ahan altltuda too high 
TOO^LOWJeRROR - Ralaad ahan altltuda too loa 


•^xxxxxxxxzxxxxxxxxxxxxxxxxxxxxxxxzxxxxxnxzxxxxxxzxxxxxxxzzxxxxxxxxxxxxxz 


fackaga AUTO_PXLOT_PACKAGE in 


HAX ALTITUDE : caaotaat :• 100 000; 
NIITsaPE altitude : eoaaeaat :- 1 CRJO; 
NAX^SAPE^ALTITUDE : eoaataat :- 80 000; 


tppa ALTITUOEJTTPE ia rai^a 0..HAX_ALT1TUDE; 

■ahtffa TOO^LOV ia ALTITUDE^TYPE cai^a 0..HIN_SAPEJ1LTITUDB; 

aabCfga TOO.IIGH ia au.TITU0EjrYPE ra^a NAX_BAPEJU.TITUDB..HAX_ALTITUDE; 


pcacaduca GET( ALT : out ALTITUDE TYPE ); 
praeodara D1SEIIGAGE_AUTO_PZLOT; ** 


~ othar aubprogaua daelarad hara 

— thaaa aubprogrua will taat for and 
ralaa axeaptiona daelarad below whan 
" and whara appropriate 


IRPUT ERROR : anoptiw 

TOO USb ERROR : aacaptiou 
TOoThIGH^BRROR : aaeuptiou 

oad AUTO PILOT PACKAGE; 


8"A 









Mt AUTOJPILOT.PACKAOI is 

—xxzzuxuzxzzxxuzxxnxuxmuxxzuxxmxxzzzxzznsxxxxxxzxxxxvuxzzsxu 
~x S 

~X Abstract: This procsdurs gats ths altitude froa ths sansoc> 

—X 

—X Author: T. Gunn 

—X 

—X Dots: 23 Jua AS 

—X 

—X Propsgatad ixeaptlMis: 

—X XHrarjUIOg • lalaad uhan ineorraet altitude read 

->X TOO hTgH BggOt - lalaad vhon altitude too high 

—X too'*LOV ULiOR - lalaad whan altitude too low 

—X " " 

—xxxxxzxzxxxxxxxzxxxxxxxxxxxxxxxxxnuxxxzxxzzxxxxxxxxxxxzxzzzzxzzxxxxxxx 

proeadare GET (ALT : out ALTITUOEjrYPB) Is 
TEHPJILTITUDE : ALTITUOE_TYPE 0; 
h^U — GET 

Cods hare to get TEMP_ALTITUOE froa sensor 
— INPUT^BIROR is raised~of incorrect type of data is received 

if TEHP ALTITUDE in TOO LOW thsa 
taiae^OO LOW ERROR; 
aloif TEMP ALTITUDE la TOOJilGH thna 
raiae TOO HIGH BUOR; 
aad if; 

ALT :• TBKP ALTITUDE; 
end GET; 


md AUTO PILOT PACKAGE; 




--smmmxxmmnmxxssmuimmmnsmmsxssmsxmmxnm] 

—X J 

—X Abscrtctt This precsdars is ths sutopilet thst flits ths sircrsft* 

—X Author: T* Ounn 

—X Dstt: 23 Aug 88 

—X 

—XXXXXXXXXXttXXXXXXXXXXXXXXXXXXXXXXXXXXXXXUXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 

«lth AOTO PILOT PACKAGE,TEXT 10; 
pftMtesTAUTOjFlLOT ia 

MAXJTEXES : otMtMC i- 3: 

ALTITUDE : AtTtO^PXLOT.PACEAGB.ALTtTtmjrXPE :• 0: 

btgia 

for I la l..MAXjrEIE8 laap — Got ths sltituds 

bsgla 

AUTO_PILOT_PACKAGE.GBT( ALTITUDE ); 

aaitT "* 

axcaptioo 

atasa AUTO PILOT PACKAGE.INPUT ERKOK •> 

if i-S**ehaa — Msa of thrts trios 

caisti 

aad if: 

aad; — Block stattatnt 
aad iaop; 


— Ths asst of AUTO PILOT will bs hsrs 


aaeaptlsa 

ahaa AUTO_PILOT_PACKAGE.INPUT_ERROR •> 

AUTO PILOT.DISENGAGE AUTO PILOT; 

TEXr'lO.PUTC" ***** UISEICaCIHC AUTO PILOT ***** "); 
TEXT"I0.PUT(" altimeter failed ">; 

whoa AUTO^PILOT_PACKACE.TOO_HIGH_ERROR •> 

AUTO PILOT PACKAGE.DISENGAGE AUTO PILOT; 

text" 10 .pure* ***** disengagTng iSrro pilot ***** "); 

TEXI^IO.PUTC ALTITUDE TOO HIGH TO USE AUTO PILOT'*); 
ataa AUTO_PILOT_PACKA6E.TQOJJOHjnBDK •> 

AUTO PILOT PACKAGE.DISENGAGE AUTO PILOT; 

TEXf^o.ptffC" *••** disengagTng Affro pilot •*•*• "); 
TEXtIxO.PUTC altitude too LOH to use auto PILOT); 

sad AUTO^PILUT; 

8-8 





oiJicnvis 

1. Clvvn • program apaelftea- 
tloB» a ganarle, ttudont laacrue- 
tioaal Batarlala, and atudant noeaa» 
eorraetly Inatantiata a ganarle eo 
aolva tha problaa. rcogram aiiat 
conform to eomraa aoftm^ra onglnaar* 
log atandarda* Inatrvetor may pro* 
ride up to 2 aaaiaea. 

2. Given a program apaelflea* 
tlon, a ganarle daelaratlon, an in* 
complaco ganarle body, atudant in* 
atruetional natariala, and atudant 
notes, eomplata ttia ganarle body to 
eorraetly aolva tha problaa. Program 
must conform to course aofttrara an* 
glnaaring standards. Inatruetor may 
provide up to 4 aaslats. 

imooocnoii 

Generics. Tha marc mention of 
tha uord makaa otharvlsa gallant 
progranaars tremble. But Ada ganar* 
les arc nothing to be afraid of* 
Ones you ,undaraeand the algnificanea 
of atrong typing, the concept of a 
gancrle program unit is simplified** 
even natural. 

A ganarle prograa unit simply 
makas a subprogram or package more 
general so we can reuse It In dif* 
farent applications. In order to 
mors clearly see «hy va need ganar* 
les, lac's imagine the Ada language 
without generic prograa unita. 



Vhac if we took away the ganar* 
le ZIITBGEB_I0 package and replacad 
it with a 'nea*generie variety. Af* 
tar all, don't wa have Aen*ganaric 
packages for Input/output of types 


CHABACTSR and STRING? Why can't we 
do tha aams for input/output of in* 
tegara? Lat's call our now package 
NBWjnXT^XO and declare in it a POT 
routine for integer a chat looks 
like this} 

pscesduR lUKnm t In mtUDO; 

tf wa have an object of type IRTE* 
GIR, wa can than eall this proeadura 
to print it out: 

mch NV IBCr K); 
pccesdusa PRMJRMERS is 

NUMR : INIBGBt :■ 22; 

bagla -*fR]NniMns 
MBtf1EXM0.FUKtlMQ0i 
and mnOMBSi 

So far, this works fine. But 
as wa want to do more in our 
PRXNT^NUNBERS program, wa may have 

to print out numbers of different 

types: 

with IOMBCr_10; 
pCOOsduM FRTffJIMBe is 

type SCORES la iwge 0 .. 100; 
cy^ UMCn is VMigt 0 .. 36; 

MMOt : INCECat :• 22; 

SCORE : SCORES :■ 8); 

SDE : laciH 9- 2S; 

bsgln — nONrjIMERS 

NBitBerjo.foKiiMnOi 

NBMnrjO.IUK8QO«); —lUapdl 
l8irBCrjO.nmSI0G); —XUa^! 

and PRWrjItonS; 

Kemember our strong typing rules! 



TImm rultt don't nllow uo to alx 
applot and oranftai or INTIontai 
•COIlIS» iUID LENGTHS for that aattor. 
Sineo our PUT routlno has its ITEM 
paraMttr doelarod to bo of eh# pro- 
dafinad typa ZNTEGCEi wa can't pans 
It an objoet of typa SCORES or 
LENGTH* Without gonorlea mo would 
hawa to daelara thraa PUT proeaduraa 
In our NIHjrEXT^XO paekaiat 

proQBdura lUKUn t In DOBBOt 
pNoadun lUKXm t In BOBS)} 
pcooBura fUKlOM t In UNnOt 

In fact* ovary tlwo wa doelarod a 
now Intagor typo* and wa noao to 
print out a valua of that typa, wa 
would hava to daelara a now proea- 
dura. 


This oolutlon obvloualy la un- 
aatisfactory, Wa hava thraa PUT 
proeaduraa that do aaaetly tha aana 
thing, yot boeauaa of our otrong 
typing rulas, all thraa nuot ba 
wrlttan. Also, typaa SCORES and 
LENGTH would hava to bo vlslbla in 
paekago NEHJTBXT^IO, which would, 
whan you think about It, rasult in 
forbidding you froo daelarlng now 
uaar doflnad typaa that naad to ba 
PUT or GET. Wouldn't It bo nlca if 
wa could Juot taka ona of thaao PUT 
routlnas and waka it gonaral anough 
so chat wa don't hava to rowrlto It 
two wort cloaal 

GBIOUIC DECLAIATZONS 

Wall, that's oxactly what go- 
narle prograo units do. Whan wo 
coapila a gonaric daelaration, wo 
don't dafina what typo that routina 
will work wlch--wa just dafina a 
taaplata. Wa dafina tha algorithn, 
but loavo a 'duaiqr' naan In plaeo of 
tha typa naaa wa want tha routlno to 
work wlthi 

ganarlB 

typa MM is nogo Oi 
proeateo niTCrnM t in MM); 


Nara wo'va daflnad a plaoa holdar 
oallod NUN to bo cha nano of tha 
typa of itaa wa can pass to thia 
proeodura, Wa call this plaea hold- 
or a gonarle foroal paranstor. Now, 
whan wa noad to print out an intagar 
valua, wa can taka this taaplata and 
fill It in by opacifying what typa 
wo want to taka tha plaea of NUN* 
Ha do this through a ganarie Instan¬ 
tiation* 


onnic IMTAMTUnOH 

Ones a ganarie routlno is eosi- 
pllad, wa can aaka usa of that gan- 
oral routina in dlffarone parts of 
our prograo or ovon In dtffaront 
prograna. Wa Just haw to tall tha 
eoopllar what typa wa want to natch 
up with tha plaea holdar nans wa da¬ 
flnad whan wa daclarad cha ganarie. 
If wo again want to print out nun- 
bars as in our pravious axanpla, wa 
can uaa our ganarie PUT routina chat 
wa had daflnad abovo, and instantl- 
ata It for our typaa INTEGER, 
UNCTH, and SCORES: 

with ivrt 

pnwadurs PRlNTJIIHas is ' 

typo SGUNES is BMia 0 ** 100; 
typa UNnH la rsnso 0 », 3b; 






MMO : meaBt 22; 
aOOB : SOQRES :> HU; 
sns < liNGIN 23; 


pruoodun NJT MIBOS is 

MW yimOREGOO; 
pneaduia PUT SOCKS U 

now PUltSCOCS): 
pcneoduco fUT UNQIMS is 

now WKUMBDOt 

bagin —PRINMIMaB 
PUT nnBBKNMai); 
iurjaQBs(sooK)i 
fur iBOMKsni); 

«id PRDir NMBS; 


9-2 






Lofleally, ch« s«n«rle inacan- 
tlation la slallar le daelartl^( a 
braad aav aubprograa. Tha diffar- 
anea ia that wa don't hava to ra<- 
vrlta any of tha algorltha for tha 
rotttloa* With ena llna, tha inatan* 
tlation. «a can aaeaya fron writing 
■any lieaa of tha aubprograa body. 

•awin 


aueh thnt you nuat ba vary apoelfle 
la paaaing paranatara of tha aorraet 
typa whan calling a aubprograa. Tha 
rulaa don't allow you to paas a rou~^ 
tlna a 8C0RF. whan it la looking for 
an INTBCEK. Ganartc program ualta 
alnply taka that aubprograa or pack*- 
aga and aaka it noro ganaral ao that 
«M don't hava to rawrita that plaea 
of coda nany tinea. 


dda'a atrong typing rulaa ara 


Glvan tha following ganarle function, fill In tha naln procadura which will 
Inatantlata it, ao wall aa I/O for tha array coaponant typa. It will than aaka 
a call to tha fuoetion and print out tha raaulta. 

--xzinzzmzmKzxixsznxxzzzmuzmznznxzmzzzsxnxzzssxztzmszxzk 
—t z 

~Z Abatraet: Z 

—Z Z 

—Z Author: Z 

-~Z Onto: Z 

—z z 

—zzzzzzxzzzzzzzzzzzzzzzzznzznzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

foaarle 

typo ZNDEXjrrPE la ( O }; 
typo IRT nPE la KMga <>: 

typo AEEjnrPC la array < INDCXJfYPE ) of INT^TYPEs 
faaetian GREATEST VALUE < LIST > ARE TYPE ) ratura INT TYPE; 


fuaetlou GKEATEST^VALUE ( LIST : AERJTYPE ) ratura INTJTYPE 1» 
TBMP_IIIT : IHT_TYPE IHTjrYPE'FIRST; 

basin 

for I la UST'IAMQS loop 
if UfTCl) > tniP INT dm 
TSHt ZNT t* LZit(x;i 
«al U; 

and loop: 

racara TEMP.INT; 
and GREATEST VALUE; 






•nxsiusnuixiis»iiu»isixssimmumisiimtimtmm»s«xnmt 

X > 


—X Abtkvacci X 

—X X 

•-X Auction X 

•-X Docti X 


—X X 

—UXXXXUXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 

wltll TEXT IO,OMUTCIT.VAt 4 )lt 

p t oooAuro iLMH ia 


Daelara iiaaAaA tff» tiara 


fla«a 

— Haka naaAaC inatanciaklana tiara 


— Daelara naadatf objaeta tiara 


hagia 


«» Fill array and Chan call funeclan 
— Frlnc auc ctia raauUa af eha funeclan eall 

aaA MAiNt 


OniMIC MDIIS 

lo far ua'va aaan hov ca In- 
Btanclaca a ganaric prairaa untti 
For ctia raaalndar of cha etiapcar, 
ua'll look ac urtclng Ctia bodlaa of 
a ganaric. 

Lac'a eanaldar a ganaric fune- 
cion cliac eoMpukai cha avaraga of 
cue floacing painc nuahara* ic aay 
laafc Uha chiai 

— Qracie Ipaaifiaaciani 
ganarle 

cypa Wmm IM ilgica 0| 
ftBKCian AfIMI (FllVr, 

■DM I MMNM) 


— Onwrle lodyi 
fimeclan AFBMI (Fll«r» 

■DM t PCMIXC) 
latiim lOCMM la 

Cagin 

mum (Fimr a MDN;) / 2.0| 
ini /mMli 

Wlian inacanclacad* wa eon legteatly 
Chink af all inatanraa af aur ganor* 
la paraaacar NtMMgl in cha body are 
tapiaaaA by ctw ypa Asm ttiac m 
iaacuniiacaA ic wick* UtMaibar, aur 
ganarla fartul paFAMCar NIMIIRI ii 
Juac a plaea tiaidor for cha noM af 
ctia cypa m paaa whan wa Inacanciaca 
Cha ganarte* 


<»»4 


mum tfyNMMi 







G«Mrle roFMil P«r«Mt«ra 

In o?d«r CO calculact chc avar- 
ag« of two floating point nuabart, 
wa had to uac opcratlona such at- 
addltion and dlviaion. Whlla chaaa 
art natural oparatlona for floating 
point tfpaa. It aakaa no aansa at 
all to odd and divide noMt echar 
typaa, such ao typa CHAKACTPft. 
Thara ahovld ba aoaa way wa can pra** 
want thla ganarie function Iron ba- 
Ing Inatanclatad for CHAKACltM to 
ooforea our llnitad aat of opora- 
ciona alloHod by tha typa daflnltlon 
of onunaratlon typaa Ilka CHAKAGTER. 
Ada liandlaa thla by daflnlng differ¬ 
ent claaaea of gatiarlc foraal type 
paranatara. 

Ada allowa ua to act up gauarie 
fomal paranatara that will natch 
the following elaaaaa of typaa: 

0 All typaa 

0 All but llnitad private typaa 
o All dlaerata typea 
0 All Intagar typaa 
o All floating point typaa 
o All flxad point typaa 
0 Array typaa 
0 Aceoaa typaa 


The language also defines generic 
fomal paraneters Co pass values, 
objects, and even aubprograns to a 
generic. These concepts will be 
covered in the lecture. 

Conorlc Fomal Typo Pnromtors 

A generic fornal type parnaacar 
actually defines two things: 1) 
Tha types tha conpller will allow us 
CO loatontlato tha gonarlc with and 


2) Tha operations that can be par- 
fomad on that typa within the body 
of tha generic progran unit. 

There's-kind of a trade-off be¬ 
tween Che types wa allow to natch 
during Instantiation and the opera¬ 
tions that are allowed in Cite body 
of tha ganarie. Tha nere types wa 
allow to Instantiaia the generic 
with ( 1 . 0 . the aore ganaraX It la) 
the nora restricted wa are Inside 
tha ganarie as to what we can do to 
objaeta of that type. Tha only pre¬ 
defined operations available Inside 
the generic on an object of a ganar¬ 
ie forual type paraaetcr arc those 
that are prodefined for ALL types 
that can possibly be satehud In an 
Instantiation of the generic. For 
exaaple. If we set up a generic for¬ 
nal paranacer to match all discrete 
types (intagar and onuaaraclon 
types), we are prevented from using 
any addition or nultlplication op¬ 
erations, since those are not opera¬ 
tions defined for ALL dlscreca 
types, specifically onuneratlon 
types. 

SWMART 

Generic progran units are in¬ 
valuable in building up libraries of 
reusable code. Fortunately, uti¬ 
lizing existing generic program 
units in your progran through an 
Inatantlation is not very diffi¬ 
cult—just pick the right generic 
and pass it the right paraneters to 
instantiate it. Writing a generic 
is norc Involved in that you have to 
decide what operationa are needed in 
the algorlthn and how general you 
want the generic tc be when setting 
up the generic formal paramatara. 


9-5 




1. This simple function cakes in two object of the pre*^eflned INTBGSR type 
and does a floating point division on Chen, which returns a value of the pre¬ 
defined type FLOAT* Your job is to modify this function so it will take in two 
objaets of any integer type and return a value of any floating point type you 
choose* (i*e* make it a generic with two generic formal parameters) 

2* After the generic is written write a main procedure which tests it using 
user defined integer and floating point typos* 


—zzmzzzzzxzzxzzzxmxzzmzzzmmxznxzmzzxzxzxzzxzxxzxxzzzzzzzxzzzz 


—z z 

—Z Abstract t Z 

—z z 

—Z Author: Z 

—Z Date: Z 

—z z 


—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

famecion IKT_D1VISI0H ( INTI,INTI t INTF.CSR > return FLOAT la 

bogin 


raemm FLOAT(lNTl) / FL0AT(1NT2); 




->zuxzzxxxxxxzxzuzzzxzzm%unzxzxx»uxnTzzxuxxxzzxxxzxxxzx»»zzx{Xx 

—Z Abstractt This ganarle packaga lapltManta an aaaoelativa cable with 
—Z an abstract state MChins. The package has the felloving 

*~Z subprof raas t 

<»Z ZM8BZT Fiaees a key and Its asseciaced value Into 

—Z the table 

—Z BBTKICVE - Istrlevas the value associatad vith the 

«-Z given key 

—Z Ganarle Pavaneterst 
—Z SIZE * The else of the table 

«~Z KST - The type tor the key 

—Z VAU7E * The type for the associated values 

—X Author: Jisaiy Key 


Date: 


7 Mar 87 


~Z Propagated Exceptions: 

•~Z TAlLE^XSJPULh *> Kaised vhen the INSERT operation tries 

*>Z ~ ^ to place an association in a full table. 

—Z XTEM_NOT_.POUNO « lalsed vhen the key is not in the table 

•^‘Z " *' during the RETRIEVE operation. 

—Z 

—zzzzzzzzzzzzzzznzzzzzzznzzzzzuzzuzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 

generic 

SIZE : POSITIVE :• 100; 
type KEY is private: 
type VALUE is private; 
package TASLE^NAXER ie 

procedure INSERT (KEY ITEM : KEY; 

A VALUE : VALUE); 

function RETRIEVE (KEY ITEM : KEY) return VALUE; 


TABLE IS PULL 
ITEM not'"POUND 


: exception; 
: exception; 


end TABLEJIAKER; 


(Continued on next page) 


9-7 


MMMMMMMMMMMMXMMMMMMMMetMM 



paekai* body TABU.MOCtt it 

typo PAll ii roeord 
A UY I KIY; 

xfiLVAUIt I VALUIt 

ond roeord; 

typo COUNT io rongo 0»*IXXt; 

« 

Ottbtypo XNDBX to COUNT rongo l..tXXBt 
typo TABUJJIIAY io array (XNDIX) of fAlR; 


A TAiU t TAILS ASRAYi 

CUUtBNT.XNDIX t COUNT"*t* COUNT* rXSSTt 

—xxzssxxzxxxxs»z»xxzxzxxxxxxzxxsxzsu%xxxnssxnsxsxsxxx»zxsrixxs»xsux 


—X X 

~X Abstract: This procadura plaeaa a boy and Ito aaaoeiatad value into X 

*-X the tabla. X 

~X X 

—X Author: Jlnoy Key X 

—X X 

~X Data: 7 Mar g7 X 

—X X 

—X Propagatad Ixeaptionst X 

~X TABLE_1S_PULL - Saiaad whan tha INSSKT operation triaa X 

—X ~ to place an association in a full tabla. X 

—X X 

—xxxxxxxxxxxxxxxxxxxxxxxxxxxxxsxxxxxxxzxzxxxsxxxxxxxxzxxxxxxxxxxxxzxxxxxxx 

procedure XN8BRT (KEY XTEH i in KEY; 

A vIlUC : in VALUE) ia 


begin ~ INSERT 

if CURRENT INDEX • SIZE than 
raisa TABLE^IS.PULL; 
and if; — — 

CURRENT INDEX t- CURRENT INDEX a 1; 
A_TABLETCURUNT_INDEX) t- (KEY^ITKN.AJVALUE); 

and INSERT; 

— (Continued so next page) — 


9-8 




—zxzxzzzxsuxxxxxzxzxzzsxxuzxxmzmuxzzuuzzzxnxxzzxxznzzzzxxxzxxxx 
—z z 

<—Z Abstract t This function meums the vslus assoeistsd with ehs given Z 

—Z ksy. Z 

~Z Z 

—Z Author: Jisxy Ksy Z 

—Z Z 

—Z Dsts: 7 Hsr 87 Z 

—Z Z 

—Z Frepagstsd Exceptlens: Z 

—Z XTEIMIOT^FOUND - Islsed uhen the key Is net In the table Z 

—Z " ^ during the EBTEXEVB operation. Z 

—Z Z 

—zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxzzzzzzzzzzzzzzzzzzxzzzzzz 

function KETKIBVB (KEy_ITBM x KEY) return VALUE Is 
begin — RETRIEVE 

•^Search table backwards linearly, 
for THIS INDEX in reverse 1IIDBX*PIRST..CURRENT INDEX loop 
if A TABLE(THIS_INDEX).A KEY • KEY ITEM then' 
re?urn A_TABU( THIS^INDEX) . ITS.VALUE; 
end If; ' "" 

end loop; 

raise 1TEM_,N0T_P0UND; 
end RETRIEVE; 
end TABLE MAKER; 


(Continued on next page) 





—X X 
—X Abteraett Thlt prograa MnipulatM tYm teiMrie TAIL^NAXIR 4teUre< X 
—X previously* It inicsocueot cue tsblos, a Might tsbla X 
—X and an aoeunt cabin* X 
—X X 
—X Aueheri Jinny Kay X 
*-X Oacai 9 Mar •? X 
—X X 
~xxxxxxxxxxxxx2xxxxnxxxxxxxxxxxmxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxsxxxx 


Wich TAIU NAKIK.TIXT XOi 
proeadura TaU.lNfTlICtS is 


MAX AMOUNT 

nmQuxgiit 

NXiraXOMT 

najCstkino 


t 

I 

i 

I 


eonatanC !■ 1 OOOJKlO.Ot 
eonacanc t* kobt 
eanatanc t« it 
eonacanc 20t 


aubcypa NAME it •erlni<i..HA]^tTKlMC); 

type HKIGKT la range MXN_HEtOKT..HAX_KKlCHTi — inehaa 

type DOLLAR is tfifica A range O.O..MAXJU«OUNT( 


MOV TALL t HKXCHT; 
AHOtfNT i DOLUR; 


package HEIOHT TAILS is naw TABU MAKKRCKEY •> NAHS* 

“ VALUE •> HEIGHT)i 

package AMOUNT TABU ia nav TABU NAKBR(Kn •> MANX, 

* VALUE •> DOLLAR. 

EIXE •> 200); 


begin — TAIU.INSTANCEE 

HEIGHT TABU.INSERTrClySe 
AMOUNf^ABLI. IN8ERT( ’‘Bonnie 


■* bV)i 

lO^OOO.O); 


HOW TALL >• HEICHT TABU. RETR1EVE< "Clyde 
ANdU)lT AMOUNT^TABLE.RETRIEVE "Bonnie 

exeepcion 

whan HBXGHT TABU.TABU 18 fUU -> 

HXT XO*EttC("llaiihc clbXT ia ftilir)t 
whan aRbUNT TABU.TABU Xi BULL *> 

TEXT XO*Puc("Anouoc table ia full!”); 

. whan HClGHT TABU.XTEM NOT POUND •> 

TEXT XO.Puc(”IISXOHT not Tound in Haight cablai"); 
whan AnoUNTjrAIU.TTEN^NOT POUND •> 
TBXT^IO.r^C("Anount not Tound in ABOune tablet"); 

end TABU.XNSTANCE8; 


■); 


9-10 





Omko* to 


um 

OIJICnVI uniea. On* dllff*?*nc« bctuctn task* 


6iv«n a profraa apaelfleaeiony 
an IneoapltKc pragraat atudane in- 
acrsiecional MCariala, and at«adant 
Botae* add cask* to aarraetly iaplc* 
■ant tha pregraa* Frot'** ■vat can* 
fan ce eouraa aoftwara aaginaariag 
ataadarda* Xutnctor aay proalda 
up to S aaalata. 

nramocnoe 

U* can dafimt an Ada caak a* a 
prograa unit chat logically aMcueo* 
in parallal with echar prograa 
unit*. A kay word in that: dafini- 
cion ia "logically"; a prograa with 
Ada Caaka can not only run on aulcl- 
pla procaator aaehinaa, hue it can 
run on a aaehina with a aingl* pro- 
caaaor aa wall* In thia caaa« ch* 
axaeucion of a caak in aoaahow in- 
corlaavod with cha axaeucion of tha 
aaia prograa and ethor caaka; Mny 
of cha daeiaion* a* to how thia ia 
dona ia loft up to ch* oaaq»il*r iar> 
plaaoncacion. Frograaning with 
caaka can charofora b* practy 
crieky, aapaeially if cha caaka nuat 
eonaunlcac* with aaeh ochar a groat 
doal. 

In chia ehapeor wo' 11 glv* you 
Juat a briaf coat* of what caak* 
look Ilka and how they work. 

iNFonunoN 

tPKincAnoM 

A caak ia lika any ochar prograa 
aaic la that it has tha aaaa two 
parta* a apaeifieacion and a body* 
that echar prograa unit* have. Aa 
you alghc axpocc* cha apaeifieacion 
dafinaa cha conunicaCion intarfaea 
batwaon Cha caak and ocher prograa 


end oChar prograa unica ia chat a 
Caak cannot ba a library unit; it 1* 
ALWAYS in tha deelaratlve part of 
aoochar prograa unit. 

A aiapla took that goaa off on 
ita own and doaaa't talk with othar 
pragma unit* can hawo a aiapla 
apaeifiefiCion: 

took CNSCK^SSNSOkS; 

If* on cha other hand* wa needed to 
eoanunicaca with a Caak. we ean do 
ao through aatriaa defined in cha 
tank apeeifieatlon: 

tarii Ai;ruCIBl la 

•ary WtDOC (moir : out WOIKU); 

■Id AUUCUR; 

In thia caae* wo initiate eoaauniea- 
cion with chia tank by iaauing an 
entry call. Thia entry call ean he 
given Iroa any aoouanea of acaca- 
nonea of any othar prograa unit 
whar* entry iEAOlNC ia viaiblo. Tha 
entry call would look like chi* (aa- 
auaing that ALTITUDE ia a variable 
of the aubeype POSITIVE): 

ALTIMETER.READING(ALTITUDE); 

When thia line ia reached in a ae- 
auenee of atacenenca. the prograa 
unit will wait until ch* ALTIMETER 
teak ia ready to accept eoaauniea- 
cion chrough the READING entry. 

NOT 

The body of a Caak contain* tho 
aoRuoneo of atacenenca to b* par- 
forned by tha taak. The ayntax ia 
very aiailar to the ayntax of ocher 
prograa unit bodiaa: 


10-1 



tMk body Amwmi 1* 

U)QyLjamiE : NOUMAL t- O; 

bofln 

loop 

• -** Forfora otatMntt to chock 

• — air pnouio and omputo 

. ~ IDGALjamUE. 

RAOfNB 

(HBUKT t out NOURAL) do 

mair t- ucNjaimis; 

and laADDC; 
and laopi 
and AUDCnR; 

Whan ALTIHETER roaehaa tha aceopt 
BCatoaant, it walta until toot othar 
profrao unit ealla tha READING antry 
boforo it aovoa on* Onca aoaaona 
ealla tha entry* tha atataaanta ln» 
aide the accept atatcaent are exe*' 
cuted and we aay the two taBxa are 
in vaadaseoua. Thla tera Juat naaea 
the Ilfetiae of taak ecaaunieation* 

TASEING 8TATIMBIRS 

Ue aald in the previoua example 
chat with the accept atatcaent for 
the READING entry* taak AkTlHBTBR 
would wait until an entry call la 
wade to the entry. Thia la not a 
good aituation to be in if the taak 
ahould be off doing aoae critical 


work. For example* in tha ALTIMETER 
taak* we probably wouldn't want to 
Juat wait around at the accept 
atatamont for another program unit 
to inquire about the altitude* Thia 
would be like a nawaatand owner net 
Belling today*a papara until yeater- 
day*e ware all aold out* Ideally, 
if nobody la waiting to get tha al¬ 
titude* the tank ahould go back and 
compute an updated value* 

Ada allowa thia capability 
through varioua forma of tha amioct 
atatamant* The aelaet atatament 
allowa a taak to aelaet between ae- 
eapting an entry or performing aeme 
other action* Your inatructor will 
be covering the dataila during the 
lecture* 

80MIART 

Ada taaka allow multiple threada 
of control to be eet up in e pro¬ 
gram. Thia can make tha aoftware 
more efficient if working with mul¬ 
tiple proceaaora* Even with aingla 
precaaaor maehinea* taaka are a good 
tool to break up the solution to be 
more undoratandable* Real world 
proceaaea that operate in parallel 
can be coded with taaka to reflect 
Chat parallel nature in the software 
solution* 


EXERCISE 10-t 


1. In the following program write Che task specification for QUEUE_,TASK (the 
taak body in provided)* Make sure you include the required entrTea to PUT 
a value into she queue and TAKE a value off of the queue* 

2* Modify the select statement of the task body to do the following: 

e) The task will attempt to rendasvous with a caller, but only if it 
can do oo immodiacely. If no iamedlata randaavous is possible, 
it will axacuce an also part* which prints out an appropriate 

massage to the terminal. 

b) Tha task will wait for a caller* but it will wait no longer Chan 
60 seconds* If 60 seconds elapse and rendeavous does not occur* 
print out an appropriate message to the terminal. 


10-2 




3. 1h« Min tubproftM should Mho calls to eha task sncriss» Msks tha antry 

calls to do aach tha fellowingt 

a) Tha task Mkat tha call, but vithdxaua it if randaavous doss not 
ocur vlthln tha 60 aaconda (tlMd antry calDt 

b) Tha cask will attanpt an antry call* but ulthdraua Ic if the 
randaavous is not inB«diataly posalbla (eondtctenal antry call)* 
If no randosvoua can occur* it axacutas tha alaa part of tha 
atatSMat* which prints out an appropriate naasaga. 


—uzzzuzxzxzzuzmzz»uzxxumxxmmxxmxxn»»mxxxuxxxxxxxxxzz 


—z X 
~Z Abstract: This progran plaeaa valuaa into a queue and ratriavaa X 
~Z thau iatar* Z 
~X X 
—-X Author: Andrew Asynchronous X 
—X X 
-~X Data: 20 Oct 86 X 
—X X 


—XXXXXXXXXZXZZXXZXXXXXXZZZXXXZXZXXZXXXXZXXXZXXXXZXXXXZXXZZXZZXXXXXXXXXZXXZ 

procedure START_QUEUBJTASK is 

MIN_^NUNBER : constant :• 0; 

MAX^NUMSER : constant 10 000; 


tyH NUMBERS la range H!N_HUKBSR..MAX NUMBER; 


A_NUNBER : NUMBERS :• HIN_NUNBER; 


— Write qUEUE_TASK specification here. 


(Continued on next page) 


10-3 




-s 

—X Abstract s 


Author: 
Data: 


Thla.taak ia tha IfplOMntatlon of tha Au*tt** It haa 
cha followlnt antriaat 

PUT - Plata a valua into tha front of tha ^uaua* 
TAKE - Ratriava a aalua frea tha raar of tha quaua. 

Andraw Asynchronous 
20 Oct 86 


—xzxxzxxzzxznzxxzzzxmzmzzzxzxxzumixmzxxxxxuxxmuuxxxxxxxxxxx 


task body QUZUBJTASK is 
SIZE : constant 10; 


aubtypa THE GOUMT la NUMIEES ranfa 0..8IZE; 
Sttbtypa xmiZ la MONIIM ranga l*«flSZ| 
type SPACE is array (ZNOtX) of MMBIISt 


typo QUEUE TYPE ia raeord 
SUPPER SPACE} 

HEAD t INDEX !• 1; 

TAIL INDEX :• 1; - 

COUNT : m.OOUNT 0; 

and raeord; * 


Next valua to ba ranovad. 
Naxt avallabla slot* 


QUEUE : QUEUS.TYPC: 
basin — QUEUEJTASK 
loop 

salact 

whan QUEUE.COUNT /• SIZE -> 
aceapt Put(THE NUMBER : in NUMBERS) do 
QUEUE.BUPFBRTQUEUE.TAIL) }• THE NUMBER} 
one Put; ** 

QUEUE.TAIL :• QUEUE.TAIL I; 

QUEUE.COUNT :• QUEUE.COUNT * 1; 

or 

whan QUEUE.COUNT /• 0 -> 

aceapt Taka(THE NUMBER : out NUMBERS) do 
THE NUMBER z^^QUEUK.BUFFERCQUEUE.HEAD); 
and Take; 

QUEUE.HEAD QUEUE.HEAD * 1; 

QUEUE.COUNT QUEUE.COUNT - 1; 

or 

taralnatc; 
and salact; 

and loop; 


and QUIUEJIASR; 

—ZZZZZZZZZZZZZZZZZZZXZZZSZX STARTjqUEUEJTASK ZZSZZZXZZZZZZZXXZZZZXZXXZZZZZZZZ 
basin —STARTJQUEUSJTASK 
■"* Make calls to cask, 
and START QUEUE TASK; 

lO-A 


MMM 



■umi i»-i 


—uuxmxuxzxmzzumnxuxmxxsnmsxxxxsnsxxxxxzsxxxxuxzxxxxxxx 

—X 

■»Z Abstract I 
—X 
—X 
—X 
—X 

—X Authort 
<—X Dacat 
—X 


This prograu eounca cha nuubar of aach characcar fro* 
•crlnga chat havo boon antarad fro* tha keyboard, tha 
tocal count ia tha total of aach characcar alnec tha 
start of tha progra*. 

Oount Chars 
20 Oct 85 


«ith TEXT XOt 
pc*aod*r*'?rA8K_KXANPLB ia 

MAX mm t eouataat t« 100; 

CHaIuCTERS in line I eo*ata*t t- 20; 


oubtypo CliAXS_Tq.COUNT is CHAIACTBE raago 'a*..'a*; 
typo COUNT.NUH is ra^a O..HAX_Nim; 

typo CIIAR.OOUNT is array ( CHARSJR}_C0UNT ) of COUNT^NUH; 
auheypa LINE is 8TRIN6(1..CIIARACTBRS_1N_LINE>: 


NY LINE : LINE; 

CHAR t CHARACTEK t- *Y*: 
LAST ! NATURAL 0;. 


task COUNT CHARS la 
aacry SEND LINE ( A LINE : i* LINE ); 

OBtry PRINT COUNT; * 
and COUNT.CHARS; 

paekaga COUNT^IO is aav TEXT_I0,INTE6ER_I0(C0Uirr.NUH}; 


(Gonciaued on neat paga) 


10-5 






--nxxxmxxxxnxxxsxssxxx%xxsxsxsxxmmnumznmuxxmuxmxxxmx 

X 

—X Abstractt This task counts ths nunbor of osch chsrsetor In the X 

~X string posssd in and Mintalna tha running total until X 

—X told to print it out* Tha antrias to ths task arat X 

—X SEND LINE - Call to giva task tha string to count X 

^X PEINT^COUNT - Call to print out nuabar of aach X 

•^X ~ eharaecar ceuntad X 

•>X Authors Count Chara X 

X Data: 20 Oct 85 X 

—XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXUXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 

tank body COUNT.CHAK8 is 

LOCAL LINE t UNE; 

COUNTER : GHARjCOUNT :• ( otbata •> 0 ); 

bagin — COUHT.CHARS 

loop 

a^act 

aecapt SEND LINE ( A LINE : in LINE ) do 
LOCAL LITTE A lT^; 


for 1 in LOCAL LINE*RANGE loop 
if LOCAL LINBd) la CHARS TO COUNT than 
COUNTESd) s- COUHTERdT ♦“l; 
a«l ifs 
and loop; 


or 


accapt PRINT^COUNT; 

TEXT^IO.PUT LINEd THE COUNT OF THE CHARACTERS IS •> "); 
for T in COUNTER'RANGE loop 
TEXT lO.PUTC* NUMBER OF "); 

TEXt"lO.PUT(I); 
text”"I 0.PUT("'S 
COUiff 10. PUT( C0UNTCR( I)); 

TEXTJiO.NEWSLINE; 
and loop: 


or 


camlaaca; 

and anlonc: 
and loop; 

and COUNT^CHARS; 

(Continuod on naxt page) 






%4****i4* 


TASK rjCAPerS 


i>fc5+♦444i444ii444♦♦4*♦♦»444i*»^**^ 


tafia -* lAtKjaUHni 

Imp 

wa io,m Lim(* wm or to ao oubacius •> *): 

wet xo««n UMi( NT.uK.utr )t 

OMis^wD UKdir u«i)s 

wet w too vim to coHnmi (t or o) t *); 

tBnTto.omoMi)! 

tiajio.iKxrjms 

MU Otaa ( out • *R* or OUt • 'a* )t 
Mi loop; 

^mrjciAM.niinjoooirr; 

oai TAUJBANrU: 


10-7 



1. « problM •pseiflea- 
tiont studvnt InstruetioMtl Mt«rl- 
«l«v and studant aetaa, atudant 
taana will daralop a eaaplata infor* 
■al atratagf for tha prablaa. la- 
atruotor wmf prevlda up to 3 as- 
aiata. 

2. Qlvan a problaa apaelTioa- 
tion* iaferaal atratagjTt atudaat 
laatnietioaal aatariala« and atudaat 
aotaai atudaat taaaa aill aorractly 
foraallia tha Inf anal atratafy* 
laatruetor aay prorida up to 4 aa- 
alata. 

3* Givan a problaa apaeifiea- 
tion, an ebjaet oriantad daaipn, 
atudaat Inatruetlonal aatarlala* and 
atudant aotaa« atudrat taaaa all) 
eorraetly traaafora an abjaet ori¬ 
antad daalfft Into Ada hrosraa Saai^a 
Lanfuaga. lha daal^i languaga auat 
eenfora to oouraa aoftaara anginaar- 
iag atandarda. Inatruotor aay pro- 
vlda up to 4 aaalata. 

lIlMlUUCXXQi 

Aa tha aaylng goaa» thora la 
aora than oaa way to akin a oat. 
Ihara la alao aort than ana way to 
daalgn ooftwara. lhaaa aatheda aay 
vary onywhara froa wary atrueturad 
full llfa^ycla aathodologlaa with 
autooatad toola» to what oau boat ba 
daaoribad aa *ad hao* oodii« ar 


Aa ona wlaa aan oiioa aaldt no 
ana tool la alwaya baot; wa ahould 
uoa tha baat tool for tha Job at 
hand. Seftwara oontlnuaa to grew 
aora and aora eoaplax aa wa taekla 
largar projaota. Toola that daal 


11 



with thla coaplaxlty ara avelving 
aloo. In oldar languagaa, tha 
prlaary oonatruet for atrueturlng 
prograaa la tha oubpregraa. Ihla 
laada tha aeftwara daalgnara to 
atruatiKO tha aoftwara baoad on tha 
fUnotioaa to ba parfomad Jn tha 
ayataa. Ada haa othar toola baaldaa 
ottbprograaa to aid In dealing with 
the ooaplamlty of aoftwara. Raokag- 
aa and taaka oan ba uaad to glwa a 
aora organlaad and toidaratandabla 
layout to tha ooda. Ualng . thaaa 
toola( wa aro no longer egnatrained 
Into atrueturlng our aoftwara baaed 
on fwetloni wa new oan break It up 
ualng abjoata or overall preeaaaaa 
la the ayataa aa tha atrueturlng 
orl.tarla. 


moauxTCM ^ 

Object Oriantad Daalgn (000) la 
ana daalgn tool that haa baooaa pop¬ 
ular with Ada. Aa Ita naoa lopllaai 
OOD broaka tha aoftwara up Into tha 
abatraet objoata that axlat In tho 
ayataa. It utlllaaa tha paokaga 
otruetura aa tha aaln building bloek 
of tha dnal^. Tha eomaratona of 
OOD la that a paokaga groupo togath- 
ar tha daflaltlen of tha olaaa of 
objaata with tha oparetlena that eon 
ba parforaad on objaeta of thla 
olaaa. 



OOD lie ns 

a 

The otapa In Objoot Oriantad 
Daalgn vary oonawhat* dapandlng on 
who you talk to and whan. Sena er- 
ganlaatlena uoa a vary general ap¬ 
proach with only a few atapa while 
ethara uaa on approach that trlaa to 
provide aora guidance by breaking 
down tha aajor atapa into aora de¬ 
tail o Thera ara arguaanta on both 

WW 


11-1 


•id«a of tho iMuo t ask your in- 
atruetor if you vant a aora datailad 
diaeuaaion. lha ganaral atapa to 
OOOt adaptad froa Grady Boooh in tha 
aaeond adition of hia book Softuara 
Ihginaarina with AdOt arat 

1. Idantify tha objaeta that 
axiat in tha ayataa and thair 
oharaetariatiea. 

2* Idantify tha oparationa that 
ara parforaad on thoaa ob- 
^ta« 

3* Eatabliah tha viaibility of 
aaeh objact in ralation to 
tha othara. 

4* latabliah tha intarfaoa of 
aaoh objaet. 

3* laplaaant aaeh ebjaet. 

000 ia an itaratiaa preeaaa. Firat 
parFom tha aboaa atapa at tha hifh- 
aat laaal of abotraetion« anooapaaa* 
lag tha antira ayataa. In otdar to 
parfon tha final atap of iaplaaant- 
iag tha ob3aata« it'a Ukaly that 
you'll taaaa to rapaat tha atapa on 
tha next lowar laaal of abatraetioa. 
Ihia will i da n ti f y aaoondary ob^aota 
that ara aaadad ia tha ay^a. but 
that didn't ahow up in your oonaid- 
aration of tha ovarall preoaaa. 
Aapaat tha atapa for aaoh laval of 
abatraotion uatil aaeh ebjaet ia 
aiapla anaugh to ba aaaily undar- 
atoed and iaplaaantad. 

lharo ara a faa aaya to idantify 
the objaeta and oparationa in tha 
ayatar* The and produet of tha 
anolyaia of tha problaa ahould giaa 


you a atarting point. Tour inatrue- 
tor will ahow you ona vay of identi¬ 
fying tha objecta and operations 
that aakea uae of a written para¬ 
graph that defines what the aystea 
will de<. 

W—AWT 

Adat with faaturea aueh aa paok- 
agaat ganerioa and taaka* haa added 

atrueturing eapabilitioa orar tradi¬ 
tional languagaa. Those added eapa- 
bilitiaa raguire the uaa of differ¬ 
ent daai^ aathoda if they ara to be 
used to their full advantage. Ob¬ 
ject Oriented fieaign atteapts to 
uae acre of the features of Ads and 
result in a daaiffi that produoes 
aore uaderatandable and- aaintain- 
^le oade. 

Ssvelop an Object Oriented Sa- 
ai^ for a aystea that will emnt 
the ehange in your pookst. four 
aeltttion ahauld uae the fo) lowing 
atapa aa its algorithm 

1. Zero out tha oeuntar for tha 
total value of the ehange. 

2. (While tha poeket ia net 
eapty) take a coin out of tha 
poeket. 

3* Oateraine the value of tha 
eein. 

4* Add tha '«lue of the coin to 
the total value. 

3. finally* display tha total 
value after the poeket ia eap t y. 


11-2 



SoftiMN tafliiMrlAg Standards: 
flllllMiaifTAI.8 or Ada SYSTEHS 


a. Typa all Ada raaarvtd words (UM 2.9) In lower case. 

b. User defined nanea/ldenctfiers should be typed in all upper case; l.e. 
AllCIAPT. However, nany aiitonated tools and tone authors of Ada textboehs 
sutfast eapltallalas only the first latter of user defined naaas/identifiers; 
i.a. Aircraft* This ia acceptable but not as readable. 

e. Osn the anbeddcd underscore to separate nulciple-word identifiers; 
1.0. KT^AtRCIUUnvrYrB. Also, use anbaddod underscores to add readability to 
nunbera;*~i.e. IJOOOJMO.OO. 

d. Preparly aligned code to ouch nore readable. Try Indenting two or 
three spaces for each level. In addition, align begins and ends with their 
appropriate parent. 

a. Add bleak linos to aid roadability. Use blank lines to set logically 
related rode apart. Specifically, upacing will depend on what's best to nake 
your prograa easier to reed. Sone hints would be to add spaces to offset 
aubprograns end their associated begin, declarations, loop structures, if 
stateoenta, etc. 

f. Identify the nanw of the eubprogran or package with it's end 
atataswnt; l.e.: end MY^PttOGlUH;. In addition, it's a good practice to 
associate the aubprograa naiuB with its begin atateaent; l.e.: 

bagia — KYjPROGkAH. Hotiee you asist type in the *<-<>* first since this i 
only a e naaa n t to help the ■sintanance prograaMr. 

I < iudent levels 2 Or 3 tpacus 


~ Abstract: OMsuent lines outlining the purpose 
of the prograe unit. 

~ Author: Nsue of pragraesMr 

— Date: hate prograu unit was wrltt.4u. 


with TEXT lO; ~ context clauses 
procedure"C001gG_POIMAT_0CN(MSTgATX0N is 

Declare naued euabarv 

NAXJIAUIC : coostanc :• lOjDOO.O; Align throughout to 

UX^LIHXT : coMtoat :• S;*" taiprove roadohlUty. 

Boclaro your woriouo typoo 

typo PIXtO nPt la delta 0.01 range 0.0 .. MAX VALUE; 
typa LOOPType ia rsMt 1 .. UXIPJLINIT; ** 

— Group objoct doclaratlona in oeo location, ono to a line 
NY nXEO, 

HIV rtXBO NUNtBR, 

YuUir_yUl£V_MIHBI>:K : ri<K0_TYl»K :• 11,01; 

poekege HY^KlXCO 10 la new TEXT tU.KIXKl) lu (KtXEll TYPE); 






bttgln — CODING_POIUUT_DBMONSTIUTrON 
HY riXED !- 10.0; 

mT^PIXBD^KUMBER MY^PIXBO ♦ YOUR^PtXBDJtUNBER; 

for tNDEX in LOOP TYPE loop **> noclet thn blank 1tnen added 

MY FIXED (pTfixED ♦ 0.01; — to group th* 'for' atattoont 

and loop; — and loprovo roadability 

if NY^FIXED - YOUR^FIXED^NUMBER than 
K oarlaa of;”* ** 

atatOMOta if tlia; 

above uaa true; — Uaa blank llnaa to 

alaa group any related coda. 

~ A aarlea of; 

— etatoaMnta If Che; 

~ above waa falae; 
end If; 

HY KIXKU tO.PUT (NY FIXKD); 
and C<JuINGJ7<)AMA r_»KM(i1TsTRAT (ON; 

g. Yen, doeuaMntation ta a naeeaaary evil. Much of our coda today la not 
docuiaenced wail and la a nighcaara to aaintain. Doeuaencatlon up front adda 

to program raadabilityt underatandabllicyt aalntalnability.need we aay 

•ore. 


h« Aa a •Iniaua, wa will expect your code to be coanented aa outlined 
below. Other eoaaenta ahould be added at your (or the Inatnetora) diacreclon 
to enhance underatandabllity of your cede: 


•• Abatractt Coaaent llnee eatlining the purpuat* 
of the progrna unit. 

Author: Naae of prograaaer 

~ Data: Deta prograa unit won written. 


procedure (XXnMRIfTATION la 
begin — OOCUmilTATlUN 
CODE.STATBNEirr; 
loop 

if MO OOCUNBNTATION Chen — what wll.l happen if atedenta 

llffnilCTOt Via nor accept; — doa*t do e wa a nt their code 
nilOllir WILL ■BMJBEICISE; — la explained here 
ownL^tf IS lldtr; 
ealct 
end if; 

end loop; 

end DOCIMBNTATION; 


A-2 




■ASIC Ada TTPU 


a. When praeeteal, organlta eh« daelacaclva ragton of a aubprograa or a 
packago apacifteaclon aa followa: 

NAKED NUMBERS 

TYPES 

OBJECT DECUKATtONS 

TCXT^XO INSTANTIATIONS 

b. Saparata logical groupinga of eppaa by a blank llaa. 

e* Daclaratlofia of raeotda aboald follow thia foraac: 

typo KY^PEtSONNEL^FILE la 
roeoTd * 

•••«. varloua record tlalda 

and record; 

d. Uaa Raoaa chat are daaerlpClva In nature to enhance prograa 
teadabllicy. Put aooa thought Into thla. A aeanlngful naac will greatly 
enhance the aalntenanee prograaaer'a Job. 

a. Don't forget to uae aeanlngfol object naaea elan. Your code will be 
Judged for a great part at how readable It la. Your Inatruetor will probably 
highlight aablgulciea wherever poaalble. 

f. Alwaya uae 'naaed nuabera* when placing range conetratnta to your 
cypea. Thla will add a degree of underetandablllty and aodlflabtllty to your 
code by allalnatlng thoae "MAGIC NUMBERS" we're uaed to ualng. (BiteepClena| 
are allowed whan range of 'O' or '1* are uaed) 

g. Aa a general rule, objaeta ahould be InitialIted when declared alnce 
Che language doaa not lapllcltly do ao. 


— Abatract: Coaaent Itnea outlining Che purpoae 

— of the prograa unit. 

— Author: Naae of progreaaer 

— Date: Date prograa unit wan written. 


procedure DBNOJTTP ING^STANDAROS la 

MAXJSIZE conatanc :• 100; — N a aed nuaber 

type NBtjDF^lTEMS la range 1 .. MAXJSIZE; 

type AIRCRAFT la (PIONTgR, BOMBER, TANRER. NOME); 
type CARS U (FOaO, LINCOLN, NnCURY, NONE); 

type BOATS la (ROH. MOTOR, PADDLE, HQNB); 

type BASE AIRCRAFT la array (NBR OF ITEMS) of AIRCRAFT: 

type LOT ]!aRS la array (NBR oOTIHS) of CARS; 

type MARTNA^BDATS la array (NBin>0’^'<^> o' BOATS; 

— (Continued on neat page) 




typs VRANSPORTATXON^FILE !• 
r«eord “* 

LAND : CARS :• FORD; 

SEA t BOATS t« ROW; 

AIR : AIRCRAFT t- FICHTCR ; 

•nd record; 


THE AIRCRAFT 

tuTcar 

tbe'^boat 

TRANS HISTORY 


: BASEJIIRCRAFT t* < otherii •> NONE ) 

X LOT CARS t* ( others •> NONE ) 

t NARTnA BOATS f < ethers -> NONE } 

t TIANSFORTATXONJPXLE i 


begin — DENOjrrPlNC^STANDAROS 


• • • 


•nd DBMOjrrPINC^STANOAROS; 



oomok mucnmts 


•• Avoid 'HAKD COOING* th« loop parittMCor •poelftetelen. Tho u«* of 
•tcrlbtttoft <#ill grtocly onhonuo iMtnt«iio>ihtHty of your co<lo» 

t>« lo a *for loop* atata«ane, uao h aitaninNfal nuott by which eo Intlax ch« 
loop, tingla ehmraettr imms aro paniittod aa cha indax but arc dlaeouragad 
aod ara aot aecaptabla during ehia eourau: 

Ihla la aot goodt 

for t In I •• 3 loop 
• •• 

and loop; 

Ibla la OKt 

for 1 In riGHTCR .. TANKER loop 
• 0 • 

and loop; 

But this is bat tor: 

for AlgCRAPT lo AlECRArrjryn* rango loop 
• • 0 

and loop; 

c. gcruecurlng caao ocataoooca Is laportant for anhsnelng roadability of 
your eodo: 

caao THB^AlRARArr la 

whan PIGHTSR 
00 A ggqUENCK; 

(iPjrrAttHENTS; 

whan iOHiKR •> 

OOJl^SKqUKNCr:; 

OKJWATEHKNTS; 

whan TANKER •> 
no A ggqUKNCK; 

OP^CTATimKNTS; 

whan NON£ •> 
axle; 

and caao; 



I 


A-l 





tSIPtOeiAMS 


•t Now, organise Cha doclaraelvo rogion of prograo units containing 
anbaddod aubprograna as follows: 

NAMKD NUMBERS 
TYPES 

OBJECT DECLARATIONS 

SUBPROGRAM SPECIFICATIONS (whon aaadad) 

TEXT 10 INSTANTIATIONS 
SUBPROGRAM BODIES 

b. Bewovar, aa a ganaral rulo, don't oabod aubprograM. Eabaddad 
aubprograoa ahould ba ua^ whan chair uclllcy la only applieabla to cha local 
coda. Onea awbadded, cha aubprograa la noc rauaaabla* If you do awbad 
aubprograaa, group cha aubprograa apaelfleatlena togachar, chan placa Cha 
aubprograa bodlas aftar any I/O Inacantlatlona. This will add to prograa 
raadablliey and undaratandablllcy. 

c* Whan aubpregraas ara not aabaddad, eoapila aubprograa apaclfleaclon 
and body to aaparata fllas. 

d. Whan prudent Co do ac, uaa NAHED_N0TATI0N for paraaacars whan calling 
aubprograas to aid undaratandablllcy andluCura aodlflabllity: 


~ Abatraec: Coamwnc linos •tutlining Cha purpose 
of cha prograa unit. 

—* Author: Naaa of prograaaar 

Data: Data prograa unit was wrlctan* 


procedure STACK^UTILITIBS is 

INDEX SIZE : conaeanc ZO; 

MAX_MUM__or_ITENS : constant 50; 

type ITEMS la range 0 .. MAXIMUM OP^ITENS; 
cypa STACKS la arrsy(INDEX) o? ITiM;~ 

THE STACK : STACKS ( others •> 0 ); 

THB^ITEM : ITEMS :■ 0; 

procadura PUSH ( STACK : In out STACKS; 

ITEM i In ITEMS ); 

procadura POP ( STACK i la o«ic STACKS; 

tTEN t owe ITBNS ); 

package ITEMS^tO is new INTEGBR^IO (ITlPtS); 

~ (Continued on next page) 

A-A 





Abstract t CMatant Hass AUtlinlHg the 
*- purpose of the pregrsai unit. 


proesdurs PUSH ( ITACK t in out STACKS: 

ITIH I In tttHS ) is 

••• — Leesl doelsrstlons for PUSH 

begin — PUSH 

••• — Cods for proesdurs PUSH 

SBd PUSH; 


— Abstrseti CosMsnt linss outlining tbs 
purpess of ths progrsa unit. 


proesdurs POP ( STACK t In out STACKS; 

(TEH t out ITCMS } Is 

••• toesl dselsrstions for POP 

bsgln — POP 

— Cods Cor proesdurs POP 

snd POP; 

bsgin — STACK^UTtLXTXKS 

POP ( STACK •> THE STACK, — proesdurs esll using nsnsd 
ITEM ■> THITiTBH 5 ; *** netstion for psrsostsrs. 

snd STAeK.OTXLXTXBS; 



I 



M 


A-/ 



FACXAflBS 


a. Coapilc tha paekaga apaelfteation and tha paekaga body In aaparaca 
filaa* 

b. Do not 'uaa* any packaga *wlchad in* to your progran. Tbta will halp 
in tracing prograa raaoureaa. Tha 'uaa* clauaa with TEXT^IO ia aceaptabla. 

e. Aa a ganaral rula, don't daelara objactt in packaga apuctfIcatlona. 
Thaaa bacoaa global and can cauaa problana whan aortf than ona progran unit 
aceaaaas tha packaga* Nanad nunbara or constant objacta ara pamlttad tinea 
Chair valua can't change. 

d. Only 'with' packages and aubpregrana «ihara Chair utilicy ia naadad; 
i.a. you probably don't noad TBXT^IO for tha packaga spoeifieation but nay 
naod it for tha package body (so Mly 'with' it inco tha body). This ia in 
kaaping with tha principle of LOCALIZATION. 

a* Organiae tha package apuclfleation as follows: 


Abstract: Connant Haas outlining tha purpose of 
^ each of tha progran units In the package. 

— Author: Nana of progrannar 

— Data: Data progran unit was written. 


with .... ^ context clauses 
package PACKAGE CONTENTS is 
NAMED NUNIEKT 
TTPES 

8UBPK0GKAM SPECXFlCATlONSand PACKAGEjCOHTENTS; 

a* Organise cha package body as follows: 

with TEXT to, ..... And other contaxt clauses naadud 
package body PACKAUEJCONTBNTS is 

~ local declarations needed hy body aubprngr.ins 
— Including any TEXT 10 Instantiations. 


— Abstract: connent lines outlining cha 

— purpose of the progran unit. 

~ Author: Nane of progrannar (if different fron author 
of the package) 

~ Data: Date progran unit was written. 


LOCAL SUIPROGKAHS (NOT DKCUMSO IN PACXACE SPECIPtCATXON) 


~ Abscraett Geonenc linna outlining the 
purpose of cha progran ealt. 

SUBPROGIUH BODIES TO COKNESPUND IfXTH THE PACXACE SPECIFICATIUN 
and PACKAGE^CUNTEMTS; 


A-8 














9 


ncsrttoHS 


•* iKctptlon h«ndl«ra ar* daatgncd eo handlv •rmnaoua condUlonst 
MOT uaa •xevpcion handlart with tt*«r-dtfin*d axcaptlonv. or prodoflnod^^ ' 

•xeaptloiM CO toko cho ploeo of ehoeka (for sltuoelona chat will occur 
ooraallj) Chat should bo handled by cho prograa’s exocucablt codt. 

b. Qoo a block atacoaonc to localIxo an oxcopclon «ihon approprlaca. 
RoMubor thought ovoruao of block otatoiaanca can cauao eonfuaton In coda 
roadability. tf you find this oltuaClont it aay bo boctor tn eroaco a 
aubprograa for that ooecion of coda* 

a 

e. If a aubprogran is in a paekago, and tf that aubprogran propagatos a 
usor^«flnod oxeopt on, tho nano of that oxeoptlon will bo declarod in tho 
packago opacification; and cho aubprogran docuaontation will outline tho 
conditiona which would roault in propagation of tho oxcoption. This allowa 
tho uaor of tho packago to corroctly writo tho nain progran to provide for the 
orronooua altuatlon if it oceura. If a aubprogran raiaea a pradofinod error, 
that should also bo addroaauti in tho aubprogran docunontatlon chat appoara in 
tha packago specifteatton. 

d. Always align tho roaorvod word oxeopeton with its 'begin* and *ond'. 

0 . Don't roly on, or ovoruao 'othora* as a noana of handling oxeopciont. 


- - -- -- - - - - ■ ■ mmM I _ 

Vv — Abstract t Coaaa a nt linos, outlining tho purpose of 

— each aubprogran in tho packago. 

— Author: Mono of progrannor 

•• Date: Data progran unit was written. 

— Propagated Excoptlons: nuse specify any oxcoptlona (i.o.; 

STACKJOVERFLOW) that will bo propogotod by 
" a aubprogran. 


packago STACK.PACRAGC is 

typo ITEMS is range 0 .. MAX MIHJOF^ITEHS; 
typo STACKS is array(INDEX) o7 ITEN;~ 

procodura PUSH ( STACK : in cnit STACKS; 

ITEM I tn ITEMS ); 
procodura POP ( STACK : in out STACKS; 

ITEM I out ITEMS ); 


tIACKjniDKIPLM, 
tTAaQBVnPLOU i oxcoption; 

and STACX^PACKAGE; 



o 






paeUgt body STACK.PACKAGt Is 



— AbscrAcet CoiMonc llnoi oucLtntng tho purpooo of 

— tho progran unit. 

** PropagHCod Excopcloiia: muat opacify any axetptlona (l.a.; 

STACKjOVERFLOtf) that «1I1 ba propagatad by 

— chia Tubprograa. 


proeodura PUSH ( STACK : In out STACKS; 

tTEM I In ZTIMS ) la 

bagln — PUSH 

it SOME CONDITION than — aoaa aaguanea of acataaanta 
ralaa STACK OVBRPLOW; — Chat aay ralaa STACKJDVISFLOW 
and If; *" 

oxcaptlon 

tfhan STACK OVERFLOW •> 
ralaa STACKJOVBRFLOU; 

and PUSH; 



— Abacraet! Coamane Unas outlining tl«a p*irp«taa of 
tha program unit* 

* Propagatad Exeaptlonai auat apaeif) any axeaptlona (l.a*; 
~ STACK.UNOBRFLOW) that will ba propagatad by 

<— this Tubprograa. 


proeadura POP ( STACK t in out STACKS; 

XTBN : out ITEMS ) ia 

bagin ~ POP 

if SOME CONDITION than — aoaa auquanea of otataaanta 

rnlsT STACK_UNI)ERFLOV; — that nay rnlar STACK^UNDERFLOW 
on«l If; ” 

axcaptton 

whan STACK.UNOBKFLOW •> 

RAISF. nTacKjuwtarflow; 

and ST^K_PACKA1:H; 



A-10 




ICS 


•. Th« fonac for a ganerle unle/apaetfteatlon should ba as follows: 


-*• Abstract: Ooaiaaat Unas outlining tha purpoaa of tha 

~ prograo unit* 

Author: Haas of tha protraaoar. 

~ Data: Data pragraa unit was writtan. 

— Fropagatad Bseaptloasi ssut apaelfy any axcaptlons that 
—> will bs propagatad by this aubprograa. 


ganarle 

VAUTB PAIAHCTBR t In SOHB TYK; 

typa ^MSIIAL PUKPOSI Is Soaa ganarle typo daelaratlon 

with proeaduTa NBKD MSOOtCE (VAUIC t In CltNgRAL PURPOSE): 
proeadura 6BNeRlC.8TAI<ffAR0S (SOMEjOUBCT : In out (ffNBRAL_PURPOS&}; 

proeodura GBNERICjrTANOAROS (SOHBJDBJRCT : In out GENERAL-PURPOSE) is 

— local doelaratlona 

bagln — 6GNBRIC-,STAN0ARDS 

•••; — ao^uonca of atataaanta chat 
•••; naad tha abova ganarle paraaotars 

axeaption 

whan (soaa condition) •> 

••••: — aoaa aatuanea of atataaants 
••••; — CO handla tha condition 

and GBNBRXC-STANDAROS: 

b. Place ganarle Inatanciatlons within tha doclaratlva raglon at 
a loeatlun that still .'illows you to group •>hju<:t ducliratlonx. 

e. Inntantlata a ganurtc unit an follows: 


— Abstract: Conaant linos outlining tha purposa of 

— tha prograa unit* 

**• Author: Haas of progrs a aar 

— Data: Data prograa unit waa writtan. 

— Propagatad Ixeapclonai ausc opacify any axcaptlons that 

will ba propagatad by this subprograa. 


with TEXT 10, GBNUIC STANDARDS, A PK; 
aaA TKCT^O; “ . 

pmeadara^teND-IHSTANTUTrON U 

— Nhatovar. 


(Conclnuad on next pngw) **- 
A-ll 


typa NATCHINC TYPE is 
typa AjBBNEKArjTYPB Is 







\I1E NATCH, 

nonspecific : AjSENERALJTYPli ?; 

package HATCH 10 It nev INTBGBR 10 (HATCHING TYPE); 

use hatch“io; ” ~ 

procedure GENERIC INSTANCE Is new GENERIC STANDARDS 
~ ( VALUE PARAMETER -> ~THE HATCH; 

GENERAL PURPOSE -> A GENERAL TYPE; 
NEED.RESOURCE •> aSe*LIKESeOCDURE}; 

begin — DEMO INSTANTIATION 


• ••» 

GENERIC.INSTANCECNON-SPECIFIC); — Procedure cell to tnstanClaced 

— procedure 

cxeepclon 

when (soite condition) -> 

— tome sequence oP statesiettCs 
to handle the condition 

end DEMO INSTANTIATION; 


A-12 







TMU 


•* It la baac to uaa antrlaa to eoMunleata «rtch eaaka Co avoid 
uao of Klobal objacta. 

b. Loeaea eaak apoelfteatlona aftar loeallaad aubprograaa (If any)« 
a* Group taak apaelfleaeloao eogathor whan doelarlng aora than ona taak. 



— Abatraeti CoaMnt llnoa outlining cha purpoaa of 

tha progran unit 
Authort Nana of progrannar 

— Gatat Oata program unit uaa writtan. 

— Propagatad Kaeapttonai nuat apaetfy any oaeapttona that 

— will ba propagatad by thla aubprograa* 


preeadura MAIN la 

—. Nanad nunbar daflnltlona 
Local typo daflnltlona 
—> Local object daflnltlona 
Any X/0 inatantiotlona 

taak SOieSN^CONTROL la 
antry SIEZE; 
antry BZLEASBt 
and SCRElNjCOKTROLi 

taak PKIMT la 
entry PRXNTli 
and PRINT; 



— Abatract; Connant llnaa outlining tha purpoaa of 
**-> tha progran unit. . 

— Propagated Rxcaptlona: nuat apactfy any axcaptluna that 

— ulll ha prupagata«l by thla aubprogram. 


taak body SCREBN^CONTROL la 

bagIn — 8CRKBN_C0NTRUL 
... — SaioB ooda 

oolaet 

acGOpt IXBZI; 

• *. —' Nora coda If ranulrad 

accept RELEASE; 

• • • 

and aalact; 
and SCREEN CONTROL; 


•o 


*■ k 







— Abstract t CoBMfit lines outlining tho purpose of the 

— progran unit* 

Propagated Exceptions: oust specify any exceptions 
that will be propagated by this aubprogran. 


task body PRINT Is 

begin — PRINT 

• •* — Sana code 

aalaet 

aeeapt PRINTI.; 

• • • 

and aalaet; 
and PRIirr; 

bagln — HAIN 

PRINT.PRINTI; 

axeaptlon 


whan SOKEJCONOITION -> 

• •• 


and MAIN; 


A-U 




A|i{iMitfU B 
Atfa GLOSSARY 


Abitractlon ~ A principle of Sofiwere Engineerinp. AbNiraction in the pntcciiii of extnaing esKential informiiion relMinf to a 
problem while filtering out the unnecemry (lower level) dctaiK that tend to cloud our undentunding of the problem. 


§P 


Aeem Type -* An accMx type it uted in conjunction with the 'allocutur' xtaicnient to dynantiwully create objects donig 
execution. Keyword: wwat. 

Aecaea Vnliit - An aoceu value provkkt the location of, or ’poiniv to*, an object which hat been created by the evaluation of an 
■llocaiar. Keyword: access. 

Accamcy CawAniat - An accuracy conatnint tpccirm the relative or abitolute error bound of values of a real type. Keyword: 
Mta.tMtits. 

Ada - The new High Order Language deve l oped under the iponaanhip of the United States Department of Defenra (DOD) to . 
obtaf t the banana of language oemmonaiity aerou a wide variety of computer HyatemK. Ada hat been designated by the 
DOD aa the official language for all Omirc etiibaddad computer application programs. 

Ada Campilar Valuation Capability (ACVC) - An integrated set of tatts. pruceilun»i. software tools, documentation ' 
developed by SofTech, Inc. for conducting validation tests of Ada cuinpilen. The ACVC will be uted by the Ada . 
Validation Otganizaiion (AVO) to perform formal Ada valtdaiHin teus. 

Ada latagralad EnvIrenoMnt (AIE) - The Ada language implementation system, being developed by Iniermetrict. Inc., under 
contract to the U.S. Air Force, to enable the development of prstgrams written in the Ada Language for military computer 
eyttema. {SaaAPSE) 

Ada I ing i iag e Syatem (ALS) - The Ada language implementaiHtn system, developed by SolTech. Inc., under contract to the 
U.S. Army, that will enable programs in the Ada language for cxecutHtn on advanced, embedded miliury target computer 
tystems. The ALS reprerants the first full Ada Programming Suppon Environntent (APSE) lu he supplied to the DOD. (See 
APSE^ 

Adn Joint Program Office (AJPO) ** The DOD office rcspoiuihle fur the encouragement and cunintl of (he development of the 
Ada language and iu implementation in DOD computer systems. ...l 


Ada PrograouBing Support Envlroo ma nt (APSEl - A full Ada programming envinmmeni that enables programmen tMnik 
programt in the Ada language, uxing a Handanl set of devcinpment Hwls, that can be executed on wide variety of target 
compuicrt. The Ada language system is a friendly, efficient, flexiblu. purtahle, easy to use programming environment. 

Ada Software Engineering Education and TralnUg Tacit Taom (ASEEI) - The purptsse of the ASEbT is to provide a 
dauiled and organixed approach to the tusk of identifying the Ada education and training needs uf the DOD community, 
including methodologies and materials lu fill those needs. 

Ada Validation Organiution (AVO) - The component of the AJPO responsible for conducting lormul Ada compiler 
validation lesu and for encouraging the coiTvct implemcntution ul the Ada language. 

Aggregate - An aggregate is a written ftirm denoting a compiMiic value. An array aggreguic dentMcs a value of an array type; a 
record aggregate denotes a value of a record type. The components of un aggivguie mu> be spccilicd using either positional 
or named a.ssocialiun. 

Allocator - The alhKulor siaiement creates a new object id a type designated by un access type, and returns un access value 
daaignating the locution of the created ubjcx'i. 


Aa ro a t a r • An aaeaator compilation unit of a cumpilaliun unit cunvMly being ctimpilcd is u memher of the foUowing set: ■ 

a. A unit mentioned in a iWrb clause ofihecumpilittion unit eunvMly being Mimpileil'. 

b. An outer textually-ncxted unit cimiuining the unit currontly being compiled. if ihui unit is u subunit; 

c. The tpeciflcation part of a aubprogrum or package body currently being ciNiipiled; 

d. One of the units mentioned in u with clause of the unccsior conipiluiion undefined in purts (hi und (e) above; and 
c. Package STANDARD 

In short, it is any compilaiitm unit which is made visible to u cimipilaiion unit currently being compiled, not iiKluding the 
unit currently being compiled itself. 

Attribute - An ■tirihuic is a predefined churucicnsiic penummg i«i the ildiniiion ol u type or ;m object 

Body - A body is k program unit defining the esccutable portion or implcnwntaiion of u subprogram, package, or task. 

B-l 




Body Stub - A body stub is a replucetnent I'ur a btKiy that is compiled sepuraiely in a subunit. 

Code Generator - The component of a compiler buck end that generates the machine language for a specified target computer. 
Typically, a separate code generator is required for each type of target ctunputcr. 

^^ollcction - A collection is the entire set of allocated objects designated by an access type. 

VPwnpilation Unit - A compilation unit is a pnigram unit which can he compiled independently from any other text. It is 
optionally preceded by a context clau.se naming other compilation units upon which it may depend. A compilation unit may 
be the specification or the body of a subprogram or package. 

Compiler A compiler is a computer program that can translate source programs wrinen in a High Order Language (such as 
Ada) into machine language programs that can be executed on specified target computers. 

Compiler Back End The portion of the compiler that contains the compoiwnis which depend upon the characteristics of the 
target computer, and therefore niuat be designed specifically for.each target computer. (See Otde Centruior) 

Compiler Front End - See Machine Independent Portion. 

Complete program - A program with no unmolvod external reference is a complete program. 

Compictenan > A principle of Software Engineering. Completeness refers to the properties of modules with a system, i.e., the 
module should be small enough to be understood as a whole, and its interfaces should he clearly defined and strictly 
enforced. If these conditions are met. it is a trivial matter to ensure that no details arc missing from the nuxlule in question. 

Component - A component is an object that is a pan of a larger composite object or a value that is a pan of a larger composite 
value. An indexed component is a name containing expnmsions dcmNing indices, and names a nunponcnt.ln an array or an 
entry in a family of entries. A selected component is the Mlcntifier of the component prefixed by the name of the entity of 
which it is a component (such as a record type). 

Composite type — An object of a composite type is comprised of one or nwHe components. There arc two kinds of composite 
type: arrays and records. All of the components of an array are of the same subtype; individual components can be selected 
by their indices. The components of a record may be of different types: individual components can be selected by their 
identifiers. 

^^^onfirmability - A principle of Software Engineering. Ctmfimiability refers to the organi/.ation of a system, insofar as it it 
organized in such a fa.shion as to promote the ell'icicni and reliable testing of the system. 

Coaatant ^ See Objea. 

% 

Coostraint A constraint determines a subset of the legal values of a type. A value within that subset is said to satisfy the 
constraint. 

Context Clause - A context clause identifies additional library units upon which u following compilation unit may depend. 


( 


Cross Compiler - A compiler that is able to generate machine code for a computer system other than the computer system 
luting the compiler. 

Declarative Part - A declarative part is a sequence of declarations and related information such as subprogram bodies and 
representation specifications that apply over a region of a progruin text. 

Delimiter — A separator, such as a comma, semicolon, colon, or parenthesis is called a delimiter. 

Derived Type - A derived type is a type whose operations and set of values are taken from those of an existing 'parent' type. 
Objects of a derived type arc not compatible with objects ol die parent type. 

Discrete Type - The set of values a-ssociuted with a discrete type is an ordered set of distinct, exact values. Discrete types and 
values may i'je used as anay or entry indices, loop control parameters, and as chtikcs in case staiciiKnis and record variants. 
All integer and enumeration types are discrete. 

Dbciimiaant - A discriminant is a specially designated component of a ivconJ which allows the structure of a record to lake on 
a variety of different form.s. The variations of the record may depend on the value of the discriminant. 

Discriminant Constraint - A discriminant cimsiraini specifics a value for each discriminant component in a discriminated 
record type or object. 

DOD - The United Slates Department of Defense. 

kEfliciency - A goal of Software Engineering. Efncieney refers to the optimal uw: of available resources, which, in a 

f computational environment, appear primarily as time and space reMHirces. 


B-2 



Elaboration ** The clutKtraiiun ul Ucvlanitum in ihc pnicem by which ihc declaration achieves its ciTcot (such as the allocution of 
memory to an object dcclaratiim): this process occursdurin||t the ciccution phase. 

Embedded Computer *' A computer that is included within. a.s an inieitral pan. a larger operational system or item of 
equipment. An embedded computer is typically a small, dedicated, special purpose machine designed to pert'orm 
ftinctions (often control functional of a larger system. Esamplcs are computers in industrial rob«>tics equipment, navflH) 
tyetems, and process control devices. 

Entity ~ Anything that may he referred to hy name is an Ada entity: ohjccls, types, values and all pntgrani units arc all entities. 

Entry '■* Entries are communications paths between tasks. Entries within a task are called just as subprograms are called (from 
ouaide the tuk containing the entry) and ntty have parameters associated with them. At least one matching accept 
•tatement appears in (be task body for each entry declared in the task speciricatinn. 

tnnmwtinn Type An enumeration type deicribca a aet of discrete values which are ipecined in the type declaration. These 
values muat be either valid kkntirMra or character literals. 

Evaluathm and Validatkm (E A V) Tmm - The E A V team is responsible for developing (he techniques and tools which will < 
provide a capability to perform a aaaas m em of APSEa and determine conlurmanccitf APSEs to the Common APSE Interface • 
Set (CAIS). 

Exception - An exception names an event that causes normal program execution to lerminaic. Users can define exceptions " 
meaningful to their application, detect the occurrence of the exception condition, and handle the exception by executing a 
section of program text in response. (See Exception HtmUler) 

Exception Handler An exception handler is that port of a program that will he executed when an exception condition occurs. 

If no exception handler is previded and an exception condition occurs, the program will he abnormally terminated. 

Exprasrion Any entity that has a value (including a function call) is ctmsidcred to he an expression. The term is most often 
applied to formulas that have a numeric or logical value. 

Generic Unit - A generic unit is a non-execuuible template for a subprogram or a package. A generic unit can accept matching 
parameters that are either types, objects, and/ur subpnqjtraiiis. as specified in the generic formal pan An executable 
instance of this generic template can be created by the pruces.s of generic instantiation. 

High Order Lanfuage (HOD - A prugniniming language that enables a pnigramnKr to write computer i 

English'like, readable form, rather than in a complex machine language. Ada. COBOL, and FORTRAN are examples of 
high order languages. 

Hoat Computer - A computer system upon which u programming envinmmeni is installed to enable the cITicient development 
of programs to be executed on specified target computers, liosi computers are typically large; llcxiblc. multiprogramming 
computers. 

Index Constraint - An index constraint specifics the upper and lower hounds for each index range ol an array type. 

Indexed Component - An indexed component nanres a cimiponcnt in a array or an entry in a family ot task entries. 

Information Hiding - A principle of S«ifiware Engineering. Information hiding refers to the pnKX'ss of making certain 
implementation details inaccessible, while allowing the interlace to remain visible. Its puqiose. allied with the principle of- 
obstraction, is to prevent highdcvcl decisions from being based on low>lcvcl charaeicristics. 

Instantiation -* The process of causing an executable pnigniin unit to he created fmm a generic template by supplying a 
matching actual parameter for each generic formal paranwicr that appears in the foniial part of the generic unit. 

Intagar Type - An integer type is a discrete type whose values represent all integer numbers within a specilied range. 

KAPSE Inttrfbcc Twmi (KIT) A team uf military and IX>I> ciuNractor personnel, the KIT was twganixed hy the AJPO to 
identify, examine, and set standaidi.^aition policies for Kernel Ada Proganiming Suppon Environment (KAPSEl interfaces. ■ 
The KIT is responsible for defining a standard set of KAPSh intcrtaccs to ensure the intcropcnihility of data and the 
innsportability of tools between confiimiing APSEs. (Sec KAPSK\ 

Kernel Ada ProgramminK Support Environment (KAPSE) - A core gniup of pnigrams that | .ovidcs basic functions in 
suppon of the balance of the Ada Programming Support Envintmiwni. and pcnniis the transfer ot the APSE to different host 
computer systems without modification to the KAPSE package bodies. 

KAPSE Interlace Team from Industry and Academia (KITIA) - 'I1tc counterpan to the KIT fnmi industry an 

Ltcsical Unit - A lexical unit (or lexical element) is an idcniilicr. a number, a eharavler or stnng literal, a 
comment. Basically, it is the smallest mcaninglul unit in Ihc Ada language. 




B-J 



Library Unit - A library unit iN a sepuratcly cnmpilabic member ul a pmpnint library - either the devlaraiion of a generic unit, 
package or subprogram, a Kubpntgram-body. or an iiistaniiaiinn or a generic unit. Within a given pmgran, library, the names 
of all library units must be distinct ideminers. 

Limited Type " A limited type is a type for which no predefined operations are implicitly declared. A private type may be 
limited by the inclusion of the reserved word ’’limited" in the type declaration. All task types are limited. 

iLiteral - A literal states a value literally, that is, hy means of letters and digits. A literal is either a numeric, enumeration, 
string or character literal. 

Localization - A principle of Software Engineering. Localization refers to the gntuping of logically related entities in the ume 
physical module, thereby localizing possible error. 

Machine Language - 'The binary language used to communicate with a ctmiputcr system. Each c'omputcr uses its own. unique 
machine language. 

Main Program - The subprogram (usually a parameterless procedure) which initially executes in an Ada system. 

Mininul Ada Programming Support Environment (MAPSE) A minimal griMip of software tools sulTicient to enable 
programmers to develop programs in Ada. 

MI (Machine Independent Portion) - The pan of a compiler that ctmiains components which are independent of the 
chamcteristics of the target computer, and so cun be used in commtui l«tr ntany different target computers - often culled the 
compiler "front end". 

Model Number - A model number is an exactly rcprc-scntablc value of a floating point type. Arithmetic operations on flouting 
point numbers are defined in terms of operations on the imidcl numbers of the type. 'These operations will he the same on all 
implementations of Ads. 

Modinability - A goal of Software Engineering. Modifiability refers u> a process of contn>lled change, whether in response to 
an error or a change in requirements, in which introduced changes do not increa.se the complexity of the system. 
Preservation of the original design structure should be an important consideration in achieving modifiability. 

Modularity ~ A principle of Software Engineering. Modularity can he defined as a purp«>seful structuring of resources. The 
ideal nuxlule is small, has a single purpose, and has a wcll-dcrme J interface. 



Name - A name is a symbol that stands fur an entity; the name denotes the entity. 

Named Asiociation A named association specifics the asstx'iatitin of an item with one or more positions in a list, by naming 
the positions. 

Object - An object contains a value. A program creates an object by clahoraling an object declaration or hy evaluating an 
allocator. In either case, a type is specified for the object, and the iihjcci can contain values only of that specified type. An 
object can be either a variable or a constant. 


Object Program - The machine language output of a compiler when a .source program is input. 



Operation - An operation is an elementary action directly associated with one or more types. The operation is cither implicitly 
declared along with the type declaration, or it is an explicitly declared siihprogrum that has a parameter or result of the type. 

Operator - An operator is an operation that hxs one or two operands. A unary operator is written before a single operand; a 
binary operator is written between two operands. This mitation. called "infix" notation, is a special kind of function call. 

Overloading - Overloading allows operators, subprograms. Nlcnlifiers. and literals to have more than one meaning at different 
points within the program text. An overloaded <ipcrator «ir subprogram is one which a u.scr has defined to have a different 
meaning depending upon the type of parameter it can aece|N. allowing the definition of several subprograms with the same 
name. Aw* overloaded cnumeraiion literal is an identifier tiut appears in the definition of more than one enumeration type. 
Ada uses type information to select the eiitreel literal or suhprogrant. 

Package - A package is a separately compilable program unit (consisting of a spevificaiion and a body I that nwy contain related 
types, objects, and .subprograms that operate on ohjccls of types defined in ihc sanx* package spccii'icaiion. The visible pah 
of a package (the part of the specification that appears hefurc the reserved word "privalc*) defines names that may be 
referenced external to the package hy nx'ans ol a context clause; the private part vonlains intcnuil declarations of types, 
objects, and program units that are hiikicn from Ihc user. The htnly of a package contains the implementations of 
subprograms which have been specified in the visible part of the package. 

Parameter A parameter is asstxiated with a subprogram, task entry, or generic unit and is used to communicate with the 
corresponding program unit body. A formal parameter is an itleniilicr used lo denote ihe paraineicr within the subprogram 
body, task body, or generig unit body. An uctual parameter is Ihe entity asMX'iateil w ih the corresponding formal parameter 


B-4 






«t invocation or instantiation time. The mule of a panuneier ^pevi^le^ whether the usstwiateti purameter ntay be used for 
input, output, or both. The awiociatiun of uctual panimeterN with lomtul purameicrt can be specified by named association, 
by positional association, or by a combination of thetie methods. 

Program Design Language (PDL) - An hnglishdike anificial lunpuugc. sonKtimes called pscudo^'ode. um 
the design of program unit bodie.N. The PDL used in the design of the Ada Lungutige System < ALSi uses 
to thoK in the Ada language, thereby facilitating the traasition to final impicmentaliun. 

PoaiUonal Asaodation “ A positional association specifics the association of an item with a pusiiiun in a list, by using the same 
poeition in the list. 

Pragma - A pragma is an instruction to the compiler to perform actions outside the scope of program logic, such as interfaces 
with other languages or compiler optimization. 

Private Type - A private type is a type which may be used ouuidc the package in which it is declared without knowing its . 
internal data stnictutc. A private type, which may only be declared in a package, is known i«nly hy its discriminants (if any) , 
and by the set of operations defln^ for it (in the same package specificalion). The only implicitly defined operations ' 
applicable to a private type are the lesu for equality and inequality and the assignment operation, unless the type is limited., 
in which case no operations are implicitly defined. 

Procedure - (SkeSubiprogram) 


d in docui 
constructs 


s iiiffiar'^- ' 


Program - A program is a collection of one or nuirc compilation units which huve all been compiled relative to each other. One 
of these compilation units must be a subpnigrum designated as the main pnigram. which invokes other subprograms that are 
declared in other compilation units. 

Program Unit - A program unit is a generic unit, a package, a subprogram, tir u tusk unit. 

Programming Environment ~ An integrated collection of programs that provide a wide vancty of program development, 
configuration management, project control, and maintenance functions. The Ada Programming Suppnn Environment 
(APSE) IS an example of a specialized programming environment. 

Program Library <- The compilation units that make up a program belong to a program library . A Tihrary unit' fi 
piogram library may be specified in a context clause at the start uf antHhcr compilation unit. 

Qualified Expreaaion - A qualified expression funher specifics the type of an expression hy preceding the expressio 

indication of iu type or subtype. Qualification is neccs.sary when, in its absence, the expression is ambigiKius (perhaps as a 
insult of overloading). 

Range - A range is a contiguous set uf values of a scalar type. A lungc is specified hy giving the low er and upper bounds of the 
set of values. 



Range Constraint - A range constraint of a type specifics a range, and iherchy determines the set ol values applicable to the 
type or subtype. 


Real Type - A real type is a type whose values rvpivsem appnixiiiiaiiims to the real numbers. ITtcrc are two kinds: fixed point 
types are specified with absolute precision hy specifying a maxiinuin interval iilella) between values of the type: flttating 
point types arc specified with Tclalive precision expressed as a number of signilkani decimal digits. 

Rchottability - The capability of a prsigrainming environment, such as an APSIv. to he nmvcil to a dilYereni host computer 
without major modification. Rehoslahility is achieved by the ciuKcniraiion ol all host ilepciulcncics in the KAPSE and in 
the runtime support libraries. (See Rtmiime SttttfHMi Lihrurirs) 

RdinbilR; This goal of Software Engineering refers u> the ability of a system to operate without human imcrventkm for kmg . 
periods of time. Rcliebility must he a prime conskleielHW eariy in the design: it may not he added at a later time. 

Renaming Declaration - A renaming declaration declares another name for an entity. ' - 

Rendezvous - A rendezvous is the interaction that twcurs between two parallel tasks when one task has called an entry of the 
other task, and a corresponding atvepi siaicincnt is being executed hy tlic mher ask on behalf of the calling task. 

Representation Clause — A representation clause optionnlly specifies the iimicriying representation and/or addresses for data 
and program units. 


ReUrgetability - The capability of a programming cnvinwincnt. such as an APSE, to he made to produce pni| 
different target envinmmcnis without major nuHlil'ieaiion. Kctargeiahiliiy is enhanced by designing its basic func 
as machine independent as possible. 




IS for 

V. 


B-S 


Runtime Support LIbrar)' (RSL) - The component of a compiler hack enU that provider the additional auppon functions 
required for the execution of programs on a specified target computer. Since each type of target computer requires its own 
supporting functions, a unique runtime support library is required forcach type of target computer. 

^alar Type - A scaliT type is a type whose values have no components. Integer, real and enumeration types are scalar. 

B Further, the values of a scalar type are ordered. 

Scope - The scope of a declaration is that region of text over which the declaration has effect. 

Selected Component •* A selected component it composed of the name of the component, preceded by the name of the structure 
of which it is a component. Selected components are used to denote record components, task entries, and objects designated 
by access values. 

Software Engineering - The methods and techniques used in the development of efTicient, reliable. and maintainable computer 
software. 

Software Portability - The capability of a program to be moved between different computer systems without modification. 
SoftwaR portability is one of the major goals of the Ada language implementation. 

Source Program ~ A program written in a high order language (such as Ada) for input to a compiler. (See Objtct Program) 

Statement - A sutemeni specifies one or more actions to he performed during the execution of a program. 

Static Expression - A static expression is an expression whose value dues noi depend on the execution of ihe program in which 
it is contained. 


Steelman — The DOD document that specifies the technical and qualitative requirements for the Ada language. 

Stoneman -* The DOD document that specifies the technical and qualitative requirements lor impiementating an APSE. 

Subprogram - A subprogram is an executable program unit that may have parameters for communication between the 
subprogram and its invoking program unit. A subprogram declaration specifics the name of the suhpnigram and lists its 
formal parameters. The body of a subprogram specifies its execution. A suhprognim can he cither a prowdure. which 
performs a sequence of statements and is invoked hy a pnK*cdure call siaiciiK'ni. or n tunciitm. which returns a value (called 

, the result), and so a function call is not a taiemcnt, hut an expression. T he subprogram call specifies the actual parameters 

^ that are to be associated with the formal parameters. 

subtype - A subtype of a type (called the parent type) characicri/es a subset of the values of the type. The hounds of the subset 
are deicnnined by the constraint on the type. The set of operations applicahic to a subtype arc the same as that applicable to 
the parent type. Ohjerts of a subtype are compatible with ohjccls of the parent type. 

Software Life Cycle - The span of lime over which a software system is in existence, siuning with its first conception, and 
ending with its last use. The software life cycle is usually divided into phases, such us Analysis. Requirements Definition. 
Design, Code, Validation, and Operation and Muinlenanec. 

Target Computer - A computer, usually citihedded in an operatiiwal sysicni. that is designated to receive programs in its 
native machine language from one or more host computers. Target computers are typieully small. special>purpose 
machines. 

Task - A task is a pmgram unit that operates in parallel with other program units. It consists of a task specification (which 
specifies the name of the task and the names and formal parameters of its cntriesi. and a (ask Nk 1>. which defines its 
execution. 

Task Type *- A task type declaration is a type dcelaratiim similar in form to a task specification that permits Ihe subsequent 
declaration of any number of identical task units. A value of a task type dosignuies a task. All tusk types are limited types. 

Type - A type characlerixeii a set of values and a set of tipuratians applicable to those values. A type definiiion is a language 
construct that defircs a type. A particular type is cither an access type, an array type, a private type, a reawd type, a scalar 
type, or a ta.sk type. 

UndersUindability - This goal of Softwan; Engineering must be met in mder for any of Ihe other goals to be achieved. The 
undcrstandahiliiy of a system is a mensiire of how wcN it irflcrts n natural view of the world. 

Uniformity - A principle of Software Engineering that refers to the consistency of notation within a given system. In order to 
be understandable, modules should he free fntm unnecessary differences. 




A use clause is a context clause that allows direct reference to declarations that appear in the visible pans of 
packages named in a with clause. 


Ixe Clause - 



Varlut Part » A variant part of a racord specinm altamaitw iminl vompuneniK. dependint on u diacriminani of the racofd. 
Bach value of the discriminant eiublixhex a particular altetnativc uf the variani pan. 

Visibility - At a given point in the program text, the declantinn »l' an entity ix directly visible il it can be reterence^v its 
simple name. The declaration is ’visible by aclecttun” is it can be referenced in a named association or as a 
component. - ■ 

With Claaoe - A with clause is a contest clause that allows rvl'crancc (hy espanded namet to declarations that appear in the 
visible parts of named pKkages. A with clause also allows direct lelervnce to other named library units, such as generic 
uniu and subprograms. 





STUDENT KAMOOUT 


T*chnicol Training 


B30AR4916 003 
t30AR4924 004 
E30AR4924 003 
B40ST4916 003 
B40ST4924 020 
B40ST4924 021 
SOP 886 


OBJECT OEZEHTED DESIGN 



USAF TECHNICAL TRAINING SCHOOL 
5390th TtchnicBl Tnining Group 
Keesler Air Foret Bau, Mississippi 


D«sisii*4 F»r ATC C«urt« Us« 


PCL - N/A 








3300 TBCBMICAL TKAIRIHG ftINC 
3390 TBCMICAL TEAIHIMG 6100P 
KBE8LBE AIE POECB BABB, NXBSIBBIPPX 


PHILOSOPBT ; 

Tb« philosophy of tho viof osotB** froa o doop eoDcoro for iodivid- 
uol Air Fore* boo ead woB*n aod tho nood to prooido highly trcinod 
and Botivatod poraonnol to suatoin tha Biaaion of tha Air Perea. 
Wo boliovo tho obilitioa, worth, oolf-^roapoet, and disoity of aach 
acudant. Buat ba fully raeegnitad; wo baliave oaeh suae ba providad 
tho opportunity for tho purauit and waatary of an occupational 
apocialty to tha full oxtant of hia or hor capabilitiaa and aapira- 
tiona. and la of iBwadiata and eontinuinc bonofit to tha individ¬ 
ual t 
oppo 
prof 
and 
dova 
wing 
f aeu 
thro 
otha 


tha Air Forca, and tha country. To thasa onda, «a provide 
rtunitiaa for individual dovolopnant of initial technical 
ieiaoeioa, oo~tha-job training in challenging job aaaignnanta, 
follow-on growth aa auporviaora. In aupport of this individual 
lopment, and to facilitate BaxiBUB growth of ita atudanta, tho 
oneouragoa and aupporta tho profaaaional dovolopmant of ita 
Ity and adminiatratora, and actively pronotaa innovation 
ugh roaoarch and tho sharing of concopcs and Batorials with 
r educational, institutions. 


Suparsodos ATC 90? 886. June 1986 




1 


3000 


PRELIMINARY DESIGN 



SOFTWARE LIFE CYaE 




DETAILED DESIGN 


m 


CD 


O 

sz 

o 

_o 

Ll. 

E 

o 

cn 

O 

L- 

o. 



cn 

.•MM 

L_ 

o 

# M* 

-4-J 

Cl 

k. 

u 

cn 

(D 

c::i 


o 

-I—» 

o 

Q 















PROBLEMS WTH TRADITIONAL DESIGN 




PROBLEMS WITH TRADITIONAL DESIGN 






(M 


7 


2195 



TIME RAMIFICATIONS 



8 










m 

o 



^ iz; 

I—I 

O ^ 

CO 


K o 
w & 


E-h 


cn 

c 


o 

c 


a> 


cn 
a^.b 

D 

-O 

0 i3 

“O 


c 

0) 

CL 

cn 

CO 


c 

o 


CD 


Q) O 

E " 

.— to 

^ 2 

o i: 

>' ^ r- 

•■^ c E 

O.^i^ 

•pr CO CO 
° <U >s 
IS T) CO 


>N 

-4-» 

Id 

15 

L. 

CO 

(D 

CO 

D 

0 

L. 

o 

0 

Q 


CO 

L. 

o 

L- 

0 

-»-^ 

o 


0 

o 

c 

o 

o 

CO 

0 

CO 

Q 

0 

L- 

o 



9 


be identified 

Increases integration time 



CO ^ 
^ Iz; 

o o 


c 

o 


H 

<I 

Q 


fe <1 



<3 :2i 

2 o 

2 Q 



c 

CJ> 

C7>. 

‘co 

C 

0) 

• MM 

-♦-» 

T) 

o 


“O 

_D 

“o 


> 

O 

-+-J 

c 

<D 

Q- 

4 MM 

-M 

L. 

o 

CL 

cn 

^ >> 

CO 

o ^ 

• MM 

^ D 

<U 

^ (D 

E 

^ o 

• 

-M 

^ c 


E 

.±f 0) 

i! c 

U) 

C'O 

o *co 

E E 

o <l> 

O rn 

h— "O 

0.52 




10 







K 

Dh 


CJ 

a 

w 

K 


CO 


E- 

CO 

w 

o 

Q 

W 


w 

o 


Dh Csh 
JD W 
Pi 
O W 

D ffi 
Pi H 
E-* 

CO 

^ w 

S5 CD 
CO o 
W K 
Q Ph 


LU 

_l 


CD 

< 

Q 


bJ 


;< 

LiJ '■^ DQ 
^ —J . 1 C 
QC CD y r“ 
LJ •< CJ “b 

9 =j lZ S 

2: LU 1j_ O 
=) DC LU 2 


0000 



I 

I 





12 






14 







CO 

>s 

-2 

o 

“O 

o o 



“O sz 
(D T) 


C O 


. 9 - 

’o 

.2 

*"U 




Entrenchment in functional 
methodologies 




16 


L. 











“O 

CD 

C 

* 4 - 

CD 

XI 


CD 

5 

(/) 

• 

o 

q: 


"o 

D 

CO 

D 

CO 

# MW 

c 

*C0 i- 
Q) CD 

X X 

cn 5 

o ^ 

“O ^ 




c 

CO 

I- o 
0 c 
0 - o 


I I 


0 

0 ^ 
^ JH 

O 

8 ^ 


c 

*co 

0 

X 


o 
c 

4-^ CO 

CO ir! 


o •- 


CO o X 

,5^ ^ O 
0^ o o 

1 


17 


lysis or a design tha 



PROBLEMS WITH TRADITIONAL DESIGN 






CD 

-Q ^ 
(- -Q 


0) 

E 

0 


3 
C 

-n 

- ^ 

^ "o 
O y 

^ JZ 

^ a-» 

X) 


o .b 


CO 

0 

> 


0 

c 

9 o 
c 

O L- 
N 0 


P D 
-S C 

W» • — 

o ^ 
^ 0 

(f) T) 


D. 

cr 

0 

“O 
C Q) 

•—* -M 

CO o 

±i T? 

CO O 
0 > 
^ >N 

C 

a 

-O ^ 
0 

L- ^ 

•§ ° 

.2 o 

o 






18 




m 

m 

w 

o 

o 

Ph 

:zi 

o 


m 

w 

Q 


C 

S 

Q 

O 

H 

W 


= CO 

O 0 

I c £ 
0 0*0. 

<D P>'t:: 


^ o o 
O 

Is^i 

? i ° 

o > ^ 
o _£ 
o o 
a: (0 .= 


Pi 

P 

H 

O 

w 

I—• 

p 

o 


X) O 

§1 
w ^.2 
C O .'t: 

F ^ ^ 

£ S- ^ 

Q- CL 

^ D CO cr 

cn CO 
— 0)0 
o 

= -M 

3 c 

o o « 

c D E 
0 3 = 

-*-» CO 

15:2 

(/) -D 5 


P 

3 

H 

W 

Q 


19 


system functio 














m 

CO 

w 

CJ 

o 

K 

Cl. 

IZi 

CJ) 


CO 

w 

Q 

Ci5 

o 

CO 

hJ 

o 

o 

Q 

W 

<: 

o 

c 


o 

•o 

> 

# 

XJ 

.E E 

o 

o ^ 

-I—^ 

.t: c 

.> 0) 

o E 

D CL 
"O jO 
p 0) 

(D "O 

O o 

cltd 

E c: 

^ a 

1 


c 

0 ) 

E 


> 

c 

0 


o 

CL 

Ql 

3 

CO 

(D 


D 

CL 


E 

CD 

•4-^ 

CO 

>N 

£ £ W 
CD CD “o 

CO CO ^ 

^ >N c 
00 00 o 

8 

•l-i § 

O n 

C O 2 

E O ^ 
=s .PLVi= 
o ^ c. 
0^0 
O CL O 

* * * 


2! 




USING A LANGUAGE DURING DESIGN 





O' 

c 

o 

(D 

x: 

o« 

•O 

0 

-M 

o 


E 




CO 

< 



(/) 


0 

0 > 
0 0 0 
i- O -T 

o o I 
^ t: ^ 

o X 

if) Sz 


* * * 



c 

o 

o 

-M 0 

O 

c ^ 

-I-# 

o O 

“O 




0 

^ C 

□n.E 
o ^ 
=3 3 

^ O 
£ 15 
O L. 
— -♦-» 
— 0 

? 

o § 

5o 

"S 

D 
0 


I 





22 




• 

» 

V 


C 


* 

• 


o 

c 

« 


cn 

cn 

<* 

bJO 

CD 

o 

’cn 

CD 

ID 


• rH 

13 

o 


OQ 

CT 

cn 

o 

• 

0) 

C 


Q 


i- 

# 

CuO 

(h 

a) 

x: 

•4—^ 

_Q3 

O. 


♦ rH 

S— 

£ 


Jh 

o cn 

o 



w .E 

o 


Q 

'w ^ 
o ^ 

(D 

cn 


cd 

x: o 

D 


t:! 

Q- D 

C~ L- 

£= O 


< 


.R o 

• 

Ld cn 

CJ ’f-' 

« 


1 

1 




23 




PROGRAM DESIGN IN Ada 





SOFTWARE ENGINEERING 










OOTEE _ STMTAX 

PURPOSE SYMTAE FUMCTIOR DATA 


M 

W 



X 




o 

H H 

H 

« 

H 

■ 

X 

< 

*■* 

H < 

u 


o 

X H 

X 

M 

< 

H < 

X 

M 

•c 

X a 


X 

H 

M 

M 

X 

(A 

ki «• 

X 

e 

•» 

M -O 

H 

u 

< 

M < 

X 




o 

u 

X 

X 

M 

H . 

X 

N 

9 U 

W 

H X 

X 

O H 

< 

9 X 

o 

X W 

X 

H X 

o 

X H 


a 



a 

X X 

X X 

o a 

V) 


X 

M X 

X 


X 

X X 

9 a 

H 

M 

U X 

M X 

U 

« X 

X X 

W H 

< 

H M 

a a 

X X 

X 

X X 

X X 

a 9 

H 

X CO 

M H 

X 

X 

X X 

a X 

a X 

O 

o 

K W 9 

X H 

u 

X M 

XXX 



tf H 

M 9 X 

N4 >« 

X 

M X 

X M H 

X 

X 

W 

H w 

H ^ 

M 

X X 

XXX 

X a 

9 

a X 

a a o 

a X 




26 



H«Bt STWTAX 



< 



H W 

< 


< M 

H 

>• 

a a 

< 

a 

B 

a 

< 

H H 


H 

U U 

M M 

<<1 Z 

a B 

H a 

hI m 

at at 

< a» 

<\ 

H H 

B >• 

a z 

m w 

M e 

o 

a 

X 

u 

a 

a» 


m 

< 

H 

■ 

U 

z 

z 

o 

u 


\ 


at <' 
ta H 
H Z: 

S> X 

o m 


« 

M 

m 

M 

u 

« 

Ai 


H 

CA 

O 

a» 

at 


H 

U 

<< 


o 

u 

z 

M 

M 

B 


M 

•4 

< 

U 

*4 

at 

B 

a 

-w 

u 

o 


•o 

o 

4) 


« 

« fl 



4i 

a 


e 

« 

a 



A 

a > 

n 


« e 

» 

a 

* 

a «i 

« *» 

•H 

M 

•tea 

W 'M 

M 

^ a 


a a 0 M 

u a 

w a 

M 

a 0 M « 

0 a 

w u 

a « 

m 0 

9 • 

n u 


ja .(4 u 


«M M V 


a 

B 

•4 

M 
M Ot 


et 

•< 


M 


o 

X M 
O H 
H < 
M p4 
(d H 

a X 


td 

> 

M 

iJ 


>4 

M 

> 

H 

>4 


27 







OUTER _IWRER SYNTAX 


m 

M m 



At 



« w 



A* 



Oi A •»« 4J 



H 



b. P «• A 






W h«*»4 



< 



W <0 W A 



H 



A *0 B A 


< 




aw-' a A 9 



P b At «l 



K A A A w 


< 

e A M 



W ttu A w A a 


Q 

A u b a 



A b W a b 



X V b tt) 



S A W A O 0 



< b A b 



A ^ A *B U 



« 






A 









A 

•a 


tt 



A 



« 



•»4 






A 

A 


• b 



b 



O 




.. 


M 



a 

i 


t> 



fl A ‘ 


X 

1 ^ • 

e 


e b 

9 » 

O 

0 X 

« 

« 

•b A 


M 

- I e 

M 

A 

MBA 

4 

H 

A « A 

M 

it4 

a b tb At ■ 


U 

M • 


« 

A b ■ A M 


X 

* a ■ • A 

■A 


u e b ab A 


a 

a A-.A b M 

e 

b 

K 9 A A b 


ht 

• • b b O A 

A 

O 

A A b A1 a 



M 

< 


2 


9* 


u 

V 


H 

(A 

o 

At 

S) 

At 


tJi H 
< M 

m us 

e Q 

S 

H at 
U At 
K Ul 
9 Q 
Oh X 


M H 
O A> 
W W U 
«J K « 
M U < 
< M |h 

H W 
W H bi 

A o e 


•< 

W X 

o 

M M 
X -H 

w o •< 

M td H 
M H X 
w u ta 
O C 9 X 

Af (d 

P < «l 
td H A* 
•d S 

M >« M 
<< tJ 
H tJ <d 
M 9 O 
e Ik A« 



hi 

> 

M 

•a 


•I 

u 

> 

Id 

■i 



28 



Level 1; (User Contract) 


1. CPCI Organiaing Syntax 
package - 

-- Intended State Machine: 

■*** Transition Functions: 

• • • 

—* State Data: 

a a a 

end - ; 

2. Functional Specification 

e • 8 • » 

-- <Receive AUTODIN Setaants> 

3. CPC Designations 
procedure 

with - ; use - ; 

4. Coanented Abstract Declarations of State Data 
e.g. . 

— AAAA : ABSTRACT^FILE; 

— XXXX : STACK; 


29 




Ltvl 2; (b«sign Parc* and Ralacienahipa) 


1. CPC Organiaing Syntax 

paekata body - . and - ; 

procadura - (....) ^ aaparata ; 

proeadura - (.«..) ^ ...... baiin .... and - i 

task « antry - (....) ; .... and - ; 

tajijK body * ... • and * ; 

aeeapt - (....) jlo.. . and - ; 

2. CPC Structurini Syntax (aintl* laval) 

bag in ... and ; 


if . than .... < alaa > .... and i f ; 

caaa .^ .... whan .... ■> .... and caaa ; 

for . loop .. and loop j 

whila .... loop *.. and Ioc p 

loop . < axit vhan > ...» and loop ; 

3, Intandad Function Ce««aneary 
a.g., 


u. 


**-<Sand naaaaga to U8ar> 
Fu nc tional Aba tra ction 
a.g. , 

SORT (ACTABLE); 

GET HEAD <A LIST); 



1 







30 

















5 


Procedural Calls to Lower Units 


e.g. , 

MRX__RECEIVING (A_AUTORECS) ; 

6. Data A bst ractions and Anonym o us Data stru ct ures 
e.g., 

package - ij;^ new STRING^FACILITY (type name} ; 
(string, stack, queue, sequence, set, list) 



Level 3 ; (Deteiled Design, Independent of Terget) 


1. Pete Teste end Operetions 
Logical expressions (end, or, xor) 

Relational expressions (■, /■, <, <■, >, >■) 
Hunerieal expressions 

o adding (4>, &) 

o unary i*, not) 

o multiplying (*,' /, mod, rem) 

o exponentiation (**) 

Set membership expressions (in, not in) 

2. Data Definition 

Predefined Ada data types (INTEGER, UOOLEAN, 
CHARACTER, FLOAT) 

enumerated types ( type - ijs (“,“,*) ;) 
array types ( type - ^ array ( i .,.) £f - ;) 
record types ( type - ^ record .... end record ;) 

3. Predefined Array Attributes 
First 

Last 

Length 

Range 


32 








L«v«I 4 ; (Detailed, Concrete Detignt, Fully Targeted 
to Ada) 

1. Exception Handling 

exception 

when 

raiae 

2;_ Data Refineiaent 


subtype 
derived type 
access type 

constant 

delta 

digits 

range 

rename s 

all 

array slice 

3. Tasking Refinements 

terminate 

select 

abort 

delay 

4« Representation Specification 

for 

use 

at 

5. Pragmas (Special Directives) 




33 




proe«dur« . (.: in; ..: oat) is 

bogin 

* « • s 

•nd .; 



34 







proceduTt GET_TEXT (A_MESSAGE : in STRING) is 

— <Build AREA^froa in’eoaiag Mssssgc> 

begin 

t • • • 

end GET TEXT; 


3 5 





procadurs GET_TEXT (A_MESSAGE : in STRING) is 
--<Build AREA iron ineoning Mssssgs> 

typn TEXT is array (1..100) of CHARACTER; 
AREA : TEXT; 
bagin 

and GET TEXT; 



procedure GBT_TEXT (A^KESSAGE : in STRING) ia 
'*-<Build AREA from incoming Measage> 

tppe TEXT ia arrnp (1..100) of CHARACTER; 
AREA : TEXT; 

begin 

for 

a a a * 

loop 

end loop; 

e e e a 

end GET TEXT; 


37 


procadur* CET^TEXT (A_MESSAGE : in STRING) it 
--<Build AREA’^fron incoming M«ss«g*> 

type TEXT ia array (1..100) of CHARACTER; 

AREA : TEXT; 
bagin 
for 

INDEX in AREA'RANGE 

loop 

***<Mova pataaga into AREA, blank faod$> 

if 

CD —<.> 

than 

a a a a 

alaa 

a a a a 

and if; 
and loop; 

a • a a 

and GET TEXT; 




proe«dar« GBT^TEXT (A_MBS8ACE : ia STRING) it 
—<Build ARBA'^from InTeaing ' 

cyp« TEXT la array (l.aoo) of CHARACTER; 

AREA : TEXT; 
bagia 
for 

INDEX in AREA*RANGE 

loop 

•'«<Movo nataaga into AREA, .blank lint faa4a> 
if 

CO •■*<lina land eharacttr> 
than 

AREA (INDEX) ; 

alaa 

AREA (INDEX) :• MESSAGE (INDEX); 
and if; 
and loop; 
and GET TEXT; 


39 




ARCHITECTURAL DESIGN 




CO 

'o 

o 

£-• 

00 

ti 

Sh 

S 

a 

5 
u 

CO 

6 

(U 

in 

CO 

CD 

cd 

-I-) 

o 

CO 

cd 

tj 






(0 


CO 

E 

o 


O >s 
CO 

o o 
10-0 
O -Q 

‘a.*^ 

i^o 


o.- 

<0 o 


o 

CO 

O 

w. 

Ql 

o.y 

^.'t: 
O o 

o 

CO 

JD 

Q. 0 

o 

o 

3 

0 Q. 

□l 

h- 

CO 

CO (n 

1 

1 

I 

1 







40 




<9 






OH X 
H- 3 
tn o 

c 

— UJ 

•• o 

LJ < 
O (/) 
< (/) 
tn LJ 

(/) 2 

UJ W 


UJ 

9 

u < 
o cn 
< cn 
c/o u 
cn 2 
LJ D 

^i> 
d UJ 

UJ UJ 

cn OH 

P 0) 

V. i_ 

3 3 
TJ -O 
0) O 
O O 

2 8 

CL O. 


41 













ARCHITECTURAL DESIGN 




o 

o 

£-> 

lao 

a 


m 

CO 


O >v 

CXJ 

.2 2 

‘-M 

^■o 

P O 

I i§ 

O 

^ o •4-' 

o o*~ ’~ 

i_ k_.t c: 
Q. O O 3 
i3 Q. a> jQ 
3 0) Q. 3 

CO CO cn CO 


44 





§2 

<D (D 

« S 

.2 « 

O 

? z 
£ 2 

^ CO 

1-s 

•* liJ 

U o 

9 < 

< (/) 

CO (/) 
CO Uj 

u 2 

MM «iM» 

-S W' 

u 
IxJ o 

rS ^ 

53^ 

□ o 

o Oi 


UJ O 

9 < 
92. ^ 

to UJ 
UJ ^ 

2 W 

'^UJ 

UJ o 

9 < 

CO 


0) 

Q> 



UJ 2 

w. 

3 

TJ 

0} 

4. 

3 

■o 

4) 



5y‘ §• 

P 3 ^ 

O 

O 


Q. 

uJ O in 

2 

Q. 

S 

Q. 

’o» 

c? 

O 

O 

c:> q: c 
0) 




43 













03 

o 



LlJ 

O 

< 

in 

CO 

LlI 




O T3 

k. d) 


o o 
Q- O 


^ 1:^ 
03 CL 


R ^ 

h— O 

CO 
- CO 
<D LlI UJ 

O 2 

< . 

(O : 

CO to 
LlI L: 


0 

C73 

o 

03 

03 

0 


03 


II 


CM 


ro 


a> 

0 

JQ 



UJ 

O 

< 

CO 

CO 

LU 

tJ 

o 

TD 

C 

0 


47 








4S 






DETAILED DESIGN 








0 0 D 



/ 

r 


SI 













S3 


PROBLEM SPACE 



34 






THE TOPOLOGY OF PROGRAMMING 
LANGUAGES AFFECTS THE DESIGN 



56 


Generally action oriented rather than 
architecture oriented 




57 


1954 - 1958 

FORTRAN I ALGOL 58 

FLOWMATIC IPL V 







TOPOLOGY OF SECOND 
AND THIRD GENERATION 
LANGUAGES 



58 










Oi 

E-* 

O 

< 

§ 

CJ 


Q 

W 

o 

Q 

W 

m 

w 


(/) 
1 — 
uj 5 

< 


Q ^ Q CD 

> > Zj 

_j 3 < Ld 

u I 

Soo^ ^ 

J _1 O CL X 
* * * * * 


-Q 

E 

0 

CO 

CO 

O 

>N 


59 









* 


• 



CO 



:zi 

0) 

CL 


• 

o 

O 

• ^ 


i» 

CO 

a! 



w 

CP 



Q 

c 

*c 

0) 

0) 

c 

*S^ 

CP 


■ Q 

W 

• 

• •MM 

X 

• 

H . 

w 

c 

u 

£ 

o 

c c ^ 

.2 -2 

n ^ O 

O P J2 


S 

-M 

M— 

i ^ -2 a 

w o ^ o 


o 

O 

CO 

ja o o 
< = 2 ^ 


E—i 

CO 

* * * * 


O 

o 



w 

CL 

CL 


•' 


D 




CO 


• 

o 

1 


• 







62 






iz: 



CO 

o 



c 

DO 



"o 

piJ 



*E 

Q 



CO !□ 

Q 



^ X 
Q. O 

W 

• • 

CO 


-l-> 

c 

.E >^ 
c to 

iz. 

c 

(D 

"O 

D 

o 

•Q 

< 

^ CD 
UJ c 
CO § 

S 

O 

-+-* 

cn 

CO 

c 

# 

-C 

H- 

c p 

U. V- 

o 0 ) 
0) > 
^ o 


CD 

* 

* ■«• 

O 

1 



w 



3 




o 






63 





Criteria for Decomposing a System 


0 ) 



64 


Object Oriented Design 

Each module in the system denotes an 
object or class of objects from problem 
space 





#■ 



<9 


o 

w o 


Q 

Q 


o 


< 

o 


W PL 

w 


CL 
C 

<ij 

05 

H 
E-i IZ 
u w 

w 

»-3 

PQ 

O 


cn 

<D 


o 

*0) 

-M 

“O 

c 

o 

cn 

- 4 -» 

o 

CD 

• 

JD 

O 

>N 

H— 

• ■ ■ 

c 

(D 

“D 


cn 

c 

o 


0 

Cl 

O 

“O 

c 

0-4-^ 

§1 

£0 

O JC 

o 
o o 

i- 0) 

o ^ 

0) 


o. 

(D 

in' L- 

O 0 

'o'o 

S 3 

°.i 

S’o 

o — 
o P 


c 3 
Q) CT 
"D P 


^ r~ 

0 C 

I t • — 

C >N 
0 

x:-Q 

i-j ♦— 

in 

^■> 

•-= cn . 
-Q.-ti b 
o_ 0) 

-M LJ .— 

cn c-Q 

LU O O 


cn 


o 

0 

o 

o 

o 

0 

-M 

c 

0 

E 

_0 

CL 


65 







ENERIC PKG 






cd 

<3 

d 

Q 

O 

O 

bC 

d 

CO 

CO 

CD 

Sh 

cx 

P=3 


CD 

-M 

O 

> 

» 

L. 

Q. 


CO 

0 

o 

c 

o 

■4-J 

CO 


“O 

<D 

o 

c 

0 ) 

■a 


CO 

0 

Ol 

0 

-♦-» 

o 

> 


0 Q. 

O “O 
CO ^ 

^ p 

0 .E 

O o 


0 

2 ^ CL 

9 >> 


O 


0 


o 

CL O 

>s.^ 

“O — 

0 ns 
-M 0 

O .i:! 

C c 

0 .E 

“D — 

« o 

D 0) 
CO "o 

o 

.Si, ^ 

O u 

^ 2 

X 

CO 0 
0 

in -C 
in o 

5 Ic 

O ^ 


CO 

o 

0 

S' 

o 

H- 

o 

in 

0 

E 

o 

c 

CO 

o 

0 

> 

L. 

0 

in 

in 

_0 

X) 

o 

‘i- 

o 

> 


“D 

0 

C 

0 

X) 

’o 

u 

9 

4-» 

o 

CO 

CO 

• mmm 

>s 

•4-f 

• 

-Q 

*(0 


* 



68 









(9 






package 1NTEGER_STACK is 




O 

o 

•M 

CO 

01 

u 

o 

UJ 


— <D 


c 

o 

CO 

0 ) 

c 

V- 

0 

TD 

0 

CJ> 

O 

u 


0 

o 


o _ 

OLD 
0 


I I 
i I 


o 

> 

‘C 

a 

“O 

0 


.52 

o 

.< 


^5 

0 

Q. 


• - o 

01 ^ 
LU p 

o U) 

C O 

.. c 


LU 


X 

cn 

X 

CL 

0 

u 

D 

"O 

0 

CJ 

o 

u 

Q. 


O 

..i< 

S 3 

O 

LU t; 

i 


3 .. 

OLu 

•• o 
2 uJ 

LU t 

3 *^ 

0. 

o 

a. 

0 

U 

Z3 

■D 

0 

O 

O 

V. 

Q. 


0 

O 

> 

*c 

Q. 


.52 

o 


c 

o 

5 2 ? 

c 2 
( 1 ) ■‘~ 
P "O 

Q-hT 
C 0 ) 
i TJ 

I I 








70 


end INTEGER_STACK; 






• m 



o 



01 

LU 

3 o =>, 

V I— 

o 0 ) 

J UJ ^ 

XJ 

<u 
o 
o 


«* • «» 


0 ) 

01 

13 


^ ^ ti: 

9 W 

^ ^ s 

22I 



Q- - 


..ot: 



to CO a. 


C Z)Z> o 
0 > 0 . 0 . 0 . 
0 ) 
jO 


a: 

LU 

ui 

o 

i< 

(/) 

■o 

c 

0 ) 



71 








paekag* is 

Cjgs MUHliai is raags 0 .. 99; 

gr0ss4sra TAKl (A^HOHIIt : mC ■OHBIlt); 
grsesBsrs tlBVI (iuHBBR : ia ■ONIBtt); 

(sactioa HOU^tBBVlMG catara HUNBIEt; 

sad ■_&: 

gackaga kady B^t is 

SCBV_A_HAT1C : MUMBBBB i; 

yracsdars TAKB (A^MUMBBt : aat RUNBBBB) is 

kagia 

A^BUMBBB :• BBBV_A_NATIC; 

siBV_A__MATIC ;• BBBV^A^NATIC ♦ 1; 
sal TAKiT " 

treesdars SBBVB (RUMBIB : ia RUHBBRB) is sayarst* 
laacciaa ROII^SBBVIRG ratara ROMBBIB is ssysrsts; 
sad B t; 








«itk IJL^i 

mmm • 

fr«c«4««« ICB^CRBAM i« 
TOOI^IUMBBE : BOMBB 
B«gi« 

TAKB (YOUB.IOHBBt)i 

l«ap 



if lOV^tBlVlIG • TOOt_IUMBBB thmn 
BBIVI (TOat.VOHBli); 

«sit; 

••4 if; 

•b 4 lo«pi 
••4 ICB CtBAM; 



73 




witk l_t; 

••• » 

XGI^CIIAM is 
TOUl^fVlIXIK : lOMBIttt 
ksgis 

TAKI (TOOt^RUmtl); 

l««f 

if low^titviae • toot iiuNiit tgsa 
tltfl (TOOt^lDMllt); 

•sit; 

«!•• 

TOOI^IIOlIilt s- TOOt RUMBII - 15 
. ••4 if; “ • 

•s4 l««|»; 

«s4 tCB_CUAM; 


p«ekat* 

tjf* NUHSIRS is priests; 

proc«4«r« TAKI (A.MUMIIK : omt MOMBBtS) 
proc«4«r« fltVB (loMlBl : Im BOMBBBB); 
fsaetioB ROW^SBBVIIC tmfvm HUMBBBS; 

priests 

Cpps BUMBBBt is ffSBt* 0 .. 99; 
stt4 B t; 


75 



vith l^R; 

a«« B^ti 

proc«4«r« ICB^CRBAM is 

TOUI^^IOMBBI t laMBttSs 
hmgin 

TAKB (YOUt^ROHBIR); 
loss 

If M0U_8BtVll6 - TOUR^HUMBBE thsm 
SIRVI (TOOR^HOKBBR); 
ssiCi 

slss 

TOUR HUMBRR HOfl SRRVX1I6: 
ss4 if; "* 

ss4 lost; 

sa4 let CRBAH; 






pack«g« B_R la 




tjpa NUMBBRS is liaic«4 privata; 


proea4ar« TARR (A_IIQMBIR : oat BOMBIRS); 
proesAara SBRVl (HOMBRR : ia lUMBBRS); 
laaecioa NOW SERVING ratara HOHBBRS; 
fuactioa "•""(LEFT, RIGHT : la NUMBERS) 
ratara BOOLEAN; 

Futtceioa CLOSE^EMOUGH (A^NUMBER : ia NUMBERS) 
ratara BOOLEAN; 


priaata 


typa NUMBBRS ia raaga 0 .. 99; 


aa4 B R; 




77 




with 

tts« 

Frpe«4«rtt XGI^GRBAM is 

TOU&^IUMBIt : NOMBIRt; 
precsRsrs 60_T0_DQ is sss«rsts; 
bsgls 

TAKE (tOUR HUMBER); 
if N0H_BERV1HC - YOUR^MUMBER thss 
SERVE (YOUR^HUMBRR); 
slsif GL08E_BH0U6R (YOUR^HUMBBR) Cbss 

wbils MOH^SERVIHG /• YOUR^HUMBER loof 

anil; “ — wale your turn 

ss4 Isop; 

SERVE (YOUR^MUMBER); 

slss 

CO_TO_Dq; 

ss4 if; 

sn4 ICE CREAM; 





78 








cn 





no 

o 

0 

0 


O) 

0 


c 

o 

In' 





Vi^ 

o 



o 


-M 

CO 

0 

c 




0 

f" 

o 



a> 

0 

c 

• •mm 


E 

E 

*o 

c 

0 

"5 

c 

o 

o 

CO 

(D 

O 

E. 

o 

c 

m 

0 

M— 

O 

CO 

c 

o 

0 

o. 

o 

M— 

Q. 

<D 

c 

n 

0 

o 3 
.3i, 3 

o 

0 

0 

c 

jC 


N 

XI XJ 

Cl 

# W 


Q. 


o *c 

O 

r* 

0 


“o 

>>ti 

>N 

CO 

c 

0 

o 

0 

> 

0 

O 

E 

L. 

o 

Li. 

itr O 
"c .— 

CD 0 

M— 

# w 

c 

0 

Iq 

o 

-i-» 

0 

LU 

o 

O 

O 


1 

1 

• 

CH 

K) 

1 


I 



79 


objects 

Implement the objects and operations 





•0 













COUNTING LEAVES 




II 



u. 

o 


cn 

cn 

{/) 

8b 

iij or 

ijJ t: 

cn CD 


LU 


(/) 



I 


I 



LU 
LU LU 

y ^ 

OH 1 “ 
GQ 


ffl 
3 
U) 

t' 

LU ^ 




O 

OH 


m (/) 

LU LU 

l2 

_J U 

lJlJ 

qq 

OH OH 
lU LU 
CD CD 





82 




Keep a pile of the ports of the tree that have not yet 





in 



-o '• 
c c 
o Q? 

j) £ 

*5- m-t 



o o 







84 


Once the pile is empty, display the count of the leaves. 






















Keep ajjilfi of the ports of the tree that have not yet 



•o 


88 





89 





Keep a pile of the parts of the tree that have not yet 
been counted. Initially , get a tree and put it on the 
empty pile; the count of the leaves' is initiollv set to 


•o 





90 





CO 

iz: 

o 


5 

o 

Q 

5z: 

CO 

o 

•—3 

m 

o 


LU 

Ul 

O' 

m 


O 

(i: 

tjj 

bJ 

Q1 

m 

in 

iZ 

Ui 


Ul 

Ul 

oc 


gy| 

^ 05 ! 

—, 5 o t 
o 55 H= (/^ 


o 

u! 

< 

Ul 




91 


IS.EMPTY SEHLTaZERO 

PUTLINITIAL INCREMENT 

TAKE-DFF DISPLAY 

PUT 





bJ 

LkJ 

QC 

H* 

m 

3 

(/) 

hJ 

o 

•k 

LJ 

Ui 

GO 


C/1 


U. 

iS 


I I 
-< Ijj 




ui 5 o 


LJ 

LJ 

0^ 


j ri 


O iii 


< 
5 ! 

^ o 

01 a: 


a. 

CO 


W 

O 

S3 

H 

D 

O 

o 


o 

o 

lJ 

< 

Ul 


o 

^ fc 

LJ Z 
M Ul 

d 2 
2 uj 

til 

CO ^ 


LJ 


tJ 0- 


ti 

=5 



Oh 


92 


V. 




TAKE-OFF DISPLAY 

PUT 




TREE„PACKAGE 


V. 







iz; 

o 

o 


o 

o 


o 

q: tr 
UJ z 



cn^Ci 





Q. 



9 } 


PUT 
































ackage COUNTER_PACKAGE is 





0 

O 

> 


u 

a. 

q: 

LJ 


o 

o 

c 


“O p^. 
0 


c: 3 
— O 
« O 


UJ 

CL 

OiC 

LJ ^ 

fc U 

5 0- 

o q: 
^ ui 
3 h- 
O Z 

— O 
•• O 

q: ^ 

U 3 
_r * ^ 

2 QC 

8 y 


UJ 

CL 

2 ; 


5 

CL 
QC CO 
UJ 


i s 


Q ^ M 


O 

O 

0 

CL 

>v 


0 

u 

3 

•o 

0 

O 

o 

u 

CL 


0 0 
u u 


3 

O 


3 

X> 


0 0 

o u 

S 2 

(L CL 


I 


0 

"o 

> 




LJ 





T3 

C 

0 


95 



package TREE J*ACKAGE is 

type TREEJYPE is private; 

procedure GELINITIAL (TREE : out TREEJYPE); 


#0 


5 | 

UJ CD 




• «UJ 
LJ CL 

Q- n uj 

V UJ UJ 
H,UJ Qd 

Lu'cc H- 
LJ i— 

QC -M D 

O • • 

oog 

c z 

u H X 
UJ h o 


90 


9 


3 


.2 

u 

iiri 

SjS 

LU 0> 
O 

IZ o 

^ o. 



Ld *• 5 3 
UJ Ld O O 

H or 3 C c 
= k-ql *ri’“ 

Q. ^ ^ •• 

3 •§ IdZ 
O o liJo 
I K 

.S .£ 




£ £ 

3 3 

‘O XI 

o a> 

u o 

s s 

^ ^ Q- Q. 


Ld 


« 

L. 

3 

*o 

a> 

o 

8 

o. 


o 

“S 

> 


A 

Vii*' 


97 


end PILEJ^ACKAGE; 





with COUNTER_PACKAGE. PILEJ^ACKAGE, TREEJ»ACKAGE 
use COUNTER.PACKAGE. PILELPACKAGE. TREELPACKAGE 
procedure COUNT_LEAVES_ON_BINAR\LTREE is 



uj .. UJ 

m 


S ' I bJ 
U LJ 
fc Lj q: 

2 q: H 

O h- .. UJ 

o •• UJ y 9" 

o u UJ ^ t 
w K ^ ^1 uJ 

8 S ! 3 " 

aiip 









^ UJ 

UJ d —* E 
d . • CL Q_ 

CL . U- 

iruj|fc a a 

H u 2 Q- a: -i, 

fcfc 8 ,S&|;j 

< < ui ^ a ^ 

b: t= ci c 
c ■” 

*CP O CL M ^ “ 

0 ) 

JD 


O ^ 

O LU 
uJ Ul 

51 

K 9 


ui ^nr 

K y =! 

t ^ CL 
CD CL • 
3 • UJ 

C/1 UJ UJ 
. I UJ q: 

t QC 

ui l- CD 

y m D 

,Z> in 
iij to uJ 


U t- t 
m 0 - =» 3 

S c/> 


99 


end if; 
end loop; 

DISPLAY (LEAILCOUNT); 

end COUNLLEAVES_ON.BINARY_TREE; 




fo 



CO 

£ 

D 


O 

^ 0) 
W . 
_ L. 

O JZ 

o . 
^ 0) 
(U (0 
CO d) 

0) I 

5 a> 
cr£ 

(U 

-o 
o •- 


C <D 
O CO 



H CL 
&) O 
m o 

<o 


I 


0 ) 




-M 0 ) 

o o 

0 ) o 

1 q Q- 

o « 

!B i? 

C 

0 ) o 

2 ^ 


T 3 

c 

o 




a» 

*•6 

T 3 

Q 


“O 

0 ) 

“O 




o> 

c 

CO 

3 




0 ) 


CO 

c 

o 


0 ) 


LU 



0 0 
x: c^ 

-M O 

0 3 
^ o> 

J 


0 




o 

0 

3 

cO 

o .2. 

Of' 

c 

_o 

* 4:3 X) 


p .0 

0 

0 0 

H- 

0 

0 

0 c 

0 

x: 0 

L. 

3 

CL 

O 

0 

> 

9mmm 

0 p 
DC ^ 

o 

* * 


tn 


o 

5 


^ z; 

0 ^ 

•;r 

■S N 

O 'Jz: 

—. o 

O £ 

c 

§ s 

«« 
w © 

^ 2 

l» 

0 o 


o 

0 ^ 

3 s 

r" Q» 

o 

S "O 

o c 

O O 


I 


I 




100 





OBJECT OtZBMTID DBBZ6E 


1 .0 D«fla« th« problca 

1.1 State th« probltB to be aolvad in a aingla aantanea 
PURPOSE: 

- To gain a eloar, anifiad undaratanding of the problem 
by all Intereated partiea 

* Ansvers the question: ** tfbat are we trying to do? ** 
GUXOELIHES: 

- Write a singlet clear and eenelse sentence 

- Ensure It Is grammatically correct 

** All problems can bo stated In a single sentence 

1.2 Gather, organiset and analyse information about the 
problem 

PURPOSE: 

* To ga:her all Itformatlon pertinent to understanding 
and solving the problem 

GUIDELINES: 

> Gather all pertinent Information 

* Can use formal analysis tools 

- Include all levels of detail 

Organize information into logical groupings 

2.0 Develop an Informal Strategy 

2.1 Establish an appropriate perspective for the strategy 
PURPOSE: 

- Gives a starting point for the informal strategy 

2.2 Write a solution to the problem in a single paragraph 
PURPOSE: 


. 101 




- Btca^lish** a plan of attack 

* Brlngi out an appropriate leva! of abstraction for 
solution 

- Unifiat problem undoracaading 
GUIDELINES: 

- Use 7 plus or minus 2 santaness (Hrair limit) 

- Write simple I clear and concise sentences 

- Grammatically correct 

~ Place emphasis on writing a coherent paragraph, not 
just the objects and operations 

o Use a uniform level of abstraction 

- Use language appropriate for the level of abstraction 
and viewpoint 

- The informal strategy should be a complete solution 
to the probleni 

■* Should be a description of solution, not necessavily 
an algorithm 

- Doesn't have to be a prise winning novel 
3.0 Formalise the strategy 

3.1 Identify Objects of Interest and their attributes 
PURPOSE: 

- To determine the abstract objects in the problem 

** To determine the characteristics of the abstract 
objects 

** To determine sets of values 

3.1.1 Underline all nouns, pronouns and noun clauses 
(with modifying adjectives) in the paragraph 

PURPOSE: 

-* To create a list of all potential objects 
GUIDELINES: 



4 




102 





V 




- A noun Claus* ia a elauaa that acts as 
a noun; i.*.t count ot th« Itavas 

^ 'Jndsrlina all nouns 

3.1.2 Plaes saeh uniqu* noun, pronoun or noun clauss 
in chs colunn lab*l*d OBJECT 

PURPOSE: 

- To soparat* poeontial abstract objoets 

3.1.3 Idantifp all nouns r*f*rring to th* san* object 

PURPOSE: 

'' To uncluttsr th* nan* spac* 

3.1.4 Datarmin* th* spac* of each object and writs it 
in a colunn labalad SPACE 

PURPOSE: 

> Datarnination of objects of interest 

GUIDELINES: 

- Soluticn spa.ee if needed to solve problen 

- Problen space if needed to describe problen, 
but not to solve it 

3.1.5 List appropriate attributes of th* objects 

PURPOSE: 

• Oetcraina characteristics of abstract 
objects 

GUIDELINES: 

- Fron sdjectives 

- Fron gathered infornation 

3.1.6 Select an Ada identifier for each object in the 
solution space 

3.1.7 Group objects that are of th* sane 

typo 

PURPOSE: 


103 




* To viaualiso eho OwrueturaL oquivalonc* of 
liailar objaeta 

- To facllicaCa eha dafinitioa of typos 

> To track abstn^ct objects latar 

3.2 IdaoCify Operations on Cba objects 
PURPOSE: 

*> To determine sets of operations 

3.3.1 Underline all rerba» verb phrases snd 
predicates in the informal strategy 

PURPOSE: 

- Determine potential abstract operations 

'SUIDELIMES: 

- Predicate indicates some sort of test 
followed by a nhango in control; usually 
a form of the verb "to be" 

- Also underline adverbs 

~ Adverbs nay be separated from verbs 

3.2.2 Place eeeh unique verb* verb phrase or predicate 
in a column labeled OPERATION 

PURPOSE: 

Separate potential operations 

3.2.3 Identify all verbs, verb phrases and predicates 
referring to the same operation 

PURPOSE: 

** To unelutter the operation<'space 

3.2.4 Determine the space of each operation and write 
it in a column labeled SPACE 

PURPOSE: 

** Identification of abstract operations 

3.2.5 Determine the object operated on by each 


104 




opvratioo and writ* it io eoluan labalad OBJECT 

PURPOSE: 

* Dacaraina what objaet la baing oparatad on for 
aach oparatlon 

> To aaaoeiata oparationa latar with typaa 

- To adhara to traditional daaign prineiplaa of 
coupling and eohaaion 

6D1DBI.IHBS: 

All oparationa oparata on ona objaet 

• Por an oparatlon to oparata on an objaet, tha 
oparation muat ba awara of tha objaet'• 
underlying rapraaantation 

3.2.6 Identify other objaeta aaaoeiatad with tha 
operation 

PURPOSE: 

- To use ia defining paraaaterc 

- To uaa in dafining intarfaeas 

3.2.7 Select an Ada identifier for each oparation and 
write it in a eoluan labeled IDBHTIPIBR 

PURPOSE: 

- To foraaliae tha abatraet oparationa 
3.3 Eatabliah intarfaeaa aaong tha objaeta 
PURPOSE: 

- To dacaraina abatraet data typaa 

* To eatabliah aofewara raaourcea 

•* To dataraine eoapilation dapandanciaa 

• To preeiaaly define intarfaeaa between raaoureaa 

3.3,1 Croup objaeta with oparationa together in ona 
plate 


103 


PURPOSE: 





'io r'itwalisc logical abaeract data typaa 
** To aaso traaaitioo to program uaita 
3.3.2 Attoeiato a naao with aaeh grouping 
PURPOSE: 

* To foraaliaa data cjpoa 

* To oaao traasitloa to program uaita 
3»3.3 Dafiao typaa for aaeh groapiag 
PURPOSE: 

- Dotormioatioa of abatraet data typaa 



3.3.4 Traaaform aaeh groapiag into ita appropriate 
prograp uait aymbol 

PURPOSE: 

• To viaualiaa aoftwara raaoureaa 

• To yiaualiaa the iatarfacaa batwaan aoftwara 

raaoureaa '' * 

3.3.3 Show aceaaa naada batwaan program uaita 
GUIDELISES: 

- Ba aura to uaa aaaoeiatad objacta aa kaya 
3.3.6 Davalop Ada POL for the Booch’’ 0 ‘'graaa 
PURPOSE: 

> Foraaliaa the aoftwara ayatam 

> Make uaa of the Ada eoapilar aa a tool 
GUIDELINES: 

~ Bo aura to uaa aaaoeiatad objeeta aa kaya for 
dotarminiag paramatara 

3.4 Implamoat the Objaeta and Oparationa 




106 






107 




GHT AILERON 



LEFT AILERON 






The flignt surface control system operates the left 





o 


L. 

• 

P 

c 


o 

o 

tJ3 

c 

o 

O 

£ 

L. 

o 

’*U 


“O 

L. 

c 

0) 

o 

“a 

-o 

c 

3 

3 

o 

TJ 

c 

E 

o 

o 

u 


o 

p 


L. 


03 

> 


0) 

0) 

(D 

O 

m 

u 

C 

(D 

o 


V. 

O 


u 

-M 

o 

c 

o 

-M 

o 




c 

V. 

o 

k. 

m 

£ 

C 


O 

L. 

*5 

J) 

0) 

• tmm 


□ 




0) 




.2 



c 




o 

? a. 


rtif 

c 

J) 

o 

<D - 

-c c -c 

O -S 

O i. ;ti 

• mm 

m 

Ql 

3 

0) 

CO 

> 


• • 0) Q- 
ms 

c o ^ 

CO 

c 

c 

0) 

0) 

3^0) 
2 -c 03 

o 

a > 

"o 


S .2* i; 

o 

# « 

CO 

o w. 0) 

0) 

c 

o 

> 

= 2 o 
o -C c 

■O 

3 

O 

Q. 

L- -•-» -M 

J= 

E 

C 

<D 

^ c o 
5 o o 

E c o 

o 

«i CIb 
0) 

o 

o 

•4-* 

’Sb 


o o ^ 


0) 



It: 

•22 

§ § ® 

• 

c 

Q. 

3 

c 

o 

O 

(U 

o o •- 
ie " 

03 O ^ 

o 

0) 

k. 

• iMB 

T3 

k- 

O 

4-* 

O 

> 

_Q) 

L.. 

• AM 

0) 2 

•o 

<D 

'XD 

0 ) x: E 

c 

o 

<0 

1 

CO ® 
"O -ti ^ 

•4-i 

c 


0) 

c o o 
o > 

3 

o 

CO 

4-/ 

o 


Q. Q- ® 

E 

> 

«4— 

3 .-ti ±5 

o 

‘Qb 



109 


controller gets yaw amount and direction. If the yaw 
direction is left, it pivots the rudder left the yaw amount; 
otherwise, it pivots the rudder right the yaw amount. 




The fliQht surface control system operates the left 
aileron , right aileron , elevotor and rudder for an aircraft . 
The aileron controller gets roll omount and direction . 

If the roll direction is left, then it pivots the left oileron 


i J 

c 

o 

•o 


£ .-a 

4) a 


2 o 


o o 
> H 

CL <D 

."til 5 


-Ml 
. 0) 
Q- .2 


£ 

.2 o 

O -Ml 

9> C 


“D O 

-c E 

o o 


c 

3 

^ o 
^ o 

O 


c cl £ 

E JS 

o P L. 

0^5 

i+j TJ 

C P 


^ £ 
3 ^ 

o CO 

* A 


o ,> 
o *i\ 


0)1 cn 


CO ^ 


0) 0) V. 


-C -C 0) 

C 

-M -M =; 

o 

(0 (0 P 

1m 

-M -M H 

$ 9 c 

o 

0) 

o 

c 

CL Q. O 

*“5 






110 


so 

O Q£ 

gyoc 

_i 3 p a: 
tZ Q Sj Q 

UJ 21 ^ 3 
^ U 


O ^ 
^ q: 


o 

isl 

ill 

2 - 15 

r^i P P 


— O O □ 11 

< OS q:\ijj q. q.\ 


cn(rtv)tnQ.i/)tnp(otoin(n(/) 


c 

P 9 
^ o h 

0) k- ® k. 

•M Q) «*= o 

W o 5 


^ >s-5a. <»> p o 

^ (n ^ "ti 5^*o Vz w. 


§1 

o g 

c E 


vC- Qi © ^ u JS >7; 
^ u. © k. o O u 


E S §0 

a 8 S £ 

£ ^ E 3 

^ o o ; 

: 5 -c jc 

7 ? Q> -M -M 

£ .-ti © ‘5L*5-,*e 


111 


rudder controller S RUDDERJCONTROLLER 

yaw amount S YAVILAMOUNT 

yaw...direction S YAVILDIRECTION 





CO 

H 

O 

w 

•-a 

m 

o 


o 

01 

liJ 






112 



The flight surface control system operotes the left 
aileron, right aileron, elevator and rudder for an aircrait. 


( 


c 

o 

U-» 

o 


"O 

c 

o 

c 

3 

o 

E 

o 

“o 

u 

(0 

•M 

V 

Ol 

L. 

"o 

-M 

c 

o 

o 

c 

o 

L. 

Q) 

• W 

o 

Q) 


0) 

c -I 

2 ^ 

u «) 


® c 


I 


0) 


(0 

o 

> 

*04 


3 

o 

E 

o 

“5 

L. 

0) 


1 

j) *5- 

*5 CO 

^ o 
-c oi 
Of' _ 
•c jg 

2 o 


c 

0) 


0) 


c 

o 
■o 

c 
o 

.521 « 
o o 

*3 

2 O' 

g .S’ 

‘•o 0) 


o ^ 
^ -o 
c 
d 


o 


o 

c 

o 

•O 


2 

(D 


0) 

0) 


CO 

•-» 

O 

> 

QJ 


C 

o 

o 

L.' 

o 

«4-» 

o 

> 

-2 

0) 

0) 


o 
. o 

•M U. 

c 




0 



T5 



“O 


0 

3 

Q 

0 

L. 

3 


0 

0 

c 

0 

1= 

C 

o 

o 

-M 

o 
• * 

• 

-M 

c 

3 

0 

c 

O 

w. 

3 

E 

■o 

o 

o 

JC 

E 


CJ o 

Q. “q 

o 

Q. 

0 

•4^ 

0 

x: 

-M 

*5. 

0 

-M 

r-l 


o 

>v 

0) 


r §ir 


o 

E 

o 

1 

0) 


TD 

C 

o 


§1 

L. 

o 

o 

> 

0) 

0) 


3 W 

I .1 

O Q| 


O 

■o 


o 

> 

-2 

0) 

0) 

-«-» 

(0 

o 

> 

*Ql 


♦ 

c 

o 

'■4^ 

o 

0) 


c 

o 

-M 

c 

3 

o 

E 

o 

o 

>% 

CO 

Q> 

O) 


• 

c 

3 

O 

E 

o 

o 

0) 


^1 

L. 

0) 

“O 

o 

3 

L. 

0) 


CO 

-M 

o 

> 

'qi 


0) 

CO 


0 

Q 


= o 


c 

o 

o 


o 

0 

u 


/ 


113 


otherwise, it pivots the rudder right the yaw amount. 




OPERATION SPACE OBJECT 





OPERATION OBJECT 



(ASSOCIATED OBJECTS) 




OPERATION SPACE IDENTIFIER 


#1 


z 

□ te te CL 11 te 

ooi2a.a.ooi2a.Q.ooiQcuQ. 


a.t/)(Ai/nrnn(/)i/)U)(r>tni/>(n(/nnt/> 




c 

a o 
□ -o 


c 

a o 

3 -o 


2 •? 


o ^ VI {n Mcn ^ v\ in 

oj2i3«ooj3^ □§oj3j3«oo 

0) » .2; 0) v ^ .c v o) ^ .2! .> 

o C7) o^.Q- a CL Qi q).S 2 a a q) o>.S a a 





117 


ELEVATORi::ONTROLLER 

AlT.RR ON CONTROLLER RUDDERXJONTROLLER 



ROLUOIOUNT ROLLPIRECTION 



118 









119 




AMOUNT TYPE DIRECTIONIJYPE 



a Q 



110 





o 

0^ a 


K 




Q. § 
Q P 


Q. a. 


Q. O 

33 

o p 


Q. Q. 


I- 

tzg 

yi. 

Sb 


Ql cl 


O 

% 0^4 

> w 

a a 

^ Q 


121 


































package PITCH_PACKAGE is 





224 


end PITCKPACKAGE; 







t 


k 







<n 

9mm 

LU 

i 

o 

JlU S 

m 



UJ 

tzd o> 

Q.C 1 . O 

£00 

W O 

B: 3 Q. 



CO 

UJ 

I 

I 

UJ 

a> 

CL 

>N 


UJ < z 


• « 

U 

0 


$ 


Q. 

3 

0 

3 


0 

0 

0 


<: 




u. 

a:' 

Ol 

E 


S 

D 

XI 

£ 

"D 


1 

0 ) 

Q) 

0 ) 

n 

0 

p 

U 

0 

0 

UJ 

i. 

u 

> 

*c 

Q. 

• TO 

Q. 

Q. 

* ^ 
c 

0 ) 


125 


package ROLL_PACKAGE is 


F 



o o o 

Ljl=i=0 
HO O CD 
U UJ e 
^ ^ C 

$ Q Q 3 

-w r- Q> 



0 } 

O 

> 

•c 

Q. 


UJ 

I 

i 

o 

oc 

•o 

c 

Q> 



r 

i 







• % 


» 










\ 



f 








LlI 

i 

O 

1 

o 

cr 

u 


0 ) 

rn 


. - (0 O 
^ D Q. 



• tk 


LU 






« 


127 


end AILERONJ='ACKAGE; 




procedure FLiGHT_SURFACE.CONTROL is 
task AILERONXONTROLLER; 


a: .• 

dy 

od 

go 

0.0 


CO 

IjO 

UJQl 


CO CO 

o o 


# * 

..ft .. 

® o ij 

S o 2 

0^0 

0) CO Q) 

. CO CO €0 

C0*“ (0 
~Ql — 

Kill a: 

yjy 

—I O _i 

0^0 

I— z I— 
20Z 

zpa! 

ob<jJ 

y 

>N 

“O “U -O 

o o o 

JQ ^ ^ 

V» 

CO CO CO 

o o o 


*& 

0 ) 



128 


end FIJGH'LSURFACEXONTROL; 




with EL£VATOR_PACKAGE, PITCH.PACKAGE; 
use ELEVATOR-PACKAGE, PUCKPACKAGE; 

separate ( FLIGHX.SURFACEPONTROL ) 

task body ELEVATOR-CONTROLLER is 


• * 

LlI 

rCL 


pO o 

^ Pi s 

< O UJ 


>-2 
Z H- 

qIgluj 


o 

li 

• * CD 


c 9- 
•— o 
O' o 

Q> ^ 

n 


DC 

2 Ld O 

y 3 S 

^ X _l 
Q O LJ 

I h; 

S 0 . 0 . 

I 

O .'t: 


iMwciim? <9)0 -OTW kotii naaNNa4 


PIVOIDOWN (ELEVATOR, 
end if; 
end loop; 

end ELEVATOR-CONTROLLER; 




