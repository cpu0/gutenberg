-o£ 

30 8 3 J / o 

(NASA-CR-187 248) RESEARCH AND DEVELOPMENT N91-12720 

FOR ONBOARD NAVIGATION { GNAV ) GROUND RASED 
EXPERT/TRAINER SYSTEM: ONAV ENTRY EXPERT 

SYSTEM CODE (LinCom Corp- ) 181 p CSCL 148 Unci as 

G 3/14 0303270 

Research and Development for Onboard 

Navigation (ONAV) 

Ground Based Expert/Trainer System 

ONAV Entr y Expert System Code 


Daniel C. Bochsler 

LinCom Corporation 


January 28, 1988 


Cooperative Agreement NCC 9-16 
Research Activity No. AI.8 


Research Institute for Computing and Information Systems 
University of Houston - Clear Lake 




TECHNICAL REPORT 



The 

RICIS 

Concept 


The University of Houston-Clear Lake established the Research Institute for 
Computing and Information systems in 1986 to encourage NASA Johnson Space 
Center and local industry to actively support research in the computing and 
information sciences. As part of this endeavor, UH-Clear Lake proposed a 
partnership with JSC to jointly define and manage an integrated program of research 
in advanced data processing technology needed for JSC's main missions, including 
administrative, engineering and science responsibilities. JSC agreed and entered into 
a three-year cooperative agreement with UH-Clear Lake beginning in May, 1986, to 
jointly plan and execute such research through RICIS. Additionally, under 
Cooperative Agreement NCC 9-16, computing and educational facilities are shared 
by the two institutions to conduct the research. 

The mission of RICIS is to conduct, coordinate and disseminate research on 
computing and information systems among researchers, sponsors and users from 
UH-Clear Lake, NASA/JSC, and other research organizations. Within UH-Gear 
Lake, the mission is being implemented through interdisciplinary involvement of 
faculty and students from each of the four schools: Business, Education, Human 
Sciences and Humanities, and Natural and Applied Sciences. 

Other research organizations are involved via the “gateway” concept. UH-Clear 
Lake establishes relationships with other universities and research organizations, 
having common research interests, to provide additional sources of expertise to 
conduct needed research. 

A major role of RICIS is to find the best match of sponsors, researchers and 
research objectives to advance knowledge in the computing and information 
sciences. Working jointly with NASA/JSC, RICIS advises on research needs, 
recommends principals for conducting the research, provides technical and 
administrative support to coordinate the research, and integrates technical results 
into the cooperative goals of UH-Clear Lake and NASA /JSC. 


Research and Development for 
Onboard Navigation (ONAV) 
Ground Based Expert/Trainer System 

ONAV Entry Expert System Code 


Preface 


This research was conducted under the auspices of the Research Institute for 
Computing and Information Systems by LinCom Corporation under the direction of 
Daniel C. Bocshsler. Terry Feagin, Professor of Computer Science at the University 
of Houston - Clear Lake, served as the technical representative for RICIS. 

Funding has been provided by the Mission Planning and Analysis Division, 
NASA/JSC through Cooperative Agreement NCC 9-16 between NASA Johnson 
Space Center and the University of Houston - Clear Lake. The NASA Technical 
Monitor for this activity was Robert Savely, Head, Artificial Intelligence Section, 
Technology Development and Applications Branch, NASA/JSC. 

The views and conclusions contained in this report are those of the author and 
should not be interpreted as representative of the official policies, either express or 
implied, of NASA or the United States Government. 


Research and Development for Onboard Navigation (ONAV) 
Ground Based Expert/Trainer System 


ONAV ENTRY EXPERT SYSTEM CODE 
(Deliverable C) 


Prepared For: 

Dr. Terry Feagin 

Research Institute for Computing and Information Systems 
University of Houston - Clear Lake 


Prepared By: 

Daniel C. Bochsler 
LinCom Corporation 
18100 Upper Bay Road, Suite 208 
Houston, Texas 77058 


Performed Under: 

Project No. AI.8 

Cooperation Agreement no. NCC9-16 
Subcontract No. 005 


January 28, 1988 


EXPERT SYSTEM CODE FOR THE ONBOARD NAVIGATION (ONAV) 
CONSOLE EXPERT/TRAINER SYSTEM 


ENTRY PHASE 


January 1988 


LinCom Corporation 
Houston Texas 


TABLE OF CONTENTS 


Section Page 

1 SUMMARY 1-1 


2 INTRODUCTION 2-1 

2.1 Purpose 2-1 

2.2 Rule Organization Overview 2-1 

3 SOURCE CODE LISTINGS 3-1 

3.1 Initial Conditions 3-2 

3.2 Telemetry Status 3-9 

3.3 Runway Status 3-11 

3.4 Inertial Measurement Units 3-16 

3.5 State Vectors 3-55 

3.6 Three-String State Vectors ? -66 

3.7 Drag Altitude 3-72 

3.8 Tactical Air Navigation 3-77 

3.9 Baro Altitude 3-118 

3.10 Microwave Scan Beam Landing System . 3-127 

3.11 High Speed Trajectory Determinator . 3-145 

3.12 Control Flow 3-150 

3.13 Operator Input 3-153 

3.14 Output Management 3-158 

3.15 Data Tables 3-164 

4 REFERENCES 4-1 


ii 


PRECEDING PAGE BLANK NOT FILMED 


section 1 


SUMMARY 


This document provides the user with a listing of the 
rules for the ENTRY phase of the Onboard Navigation 
Console Expert/Trainer system. Included is an overview 
group of rules into which the program is divided. 


expert 
(ONAV) 
of each 


1 


1 


Section 2 


INTRODUCTION 


2 . 1 PURPOSE 

Tha„ purpose of this document is to present a complete^ listing 'of 
the expert system rules for the Entry phase of the ONAV expert 
system. These source listings appear in the same format as 
utilized and required by the CLIPS-— (C Language Integrated 
Production System) expert system shell which is the basis for 
the ONAV entry system. 

\ 

2.2 RULE ORGANIZATION OVERVIEW 

Figure 2.2-1 gives a schematic overview '’of how the rules are 
organized. These groups result from a partitioning of the rules 
according to the overall function which a given set of rules 
performs. This partitioning was established and maintained 
according to that established in the knowledge specification 
document ■ * [ 1"1 . 

In addition, four other groups of rules are specified _ in this 
document. The four groups (control flow, operator inputs, output 
management, and data tables) perform functions that affect all 
the other functional rule groups. As the name implies; 1) control 
flow ensures that the rule groups are executed ih the order 
required for proper operation; 2) operator input rules control 
the introduction into the CLIPS fact base of vari ou s kinds of 
data required by the expert system; 3) output (m anagement rules 
control the updating of the ONAV expert system user display 
screen during execution of the system; and 4 ) data tables are 
static information utilized by many different rule sets gathered 
in one convenient place. 


( i 




/i 






i . 

/ ' 4 - 




2 


1 


Figure 2.2-1: ONAV Entry Expert System Rule Organization 



Management 











Section 3 


SOURCE CODE LISTINGS 


The following sections provide lists of the Entry ONAV expert system 
source code in the CLIPS format. 


3 


1 



3 . 1 Initial Conditions 


; ; *************************************************************************** 
/ '; ; GROUP 

;; Initial Conditions (3.1) 

} i 

/ / This group handles some global types 

; / of info used by many rules sections 

;; (e.g., engaged system, system availability 

;; wrong atmosphere, wrong major mode, etc.). 

/ / CONTROL FACTS 

// (sub-phase init ?) 

/ / CONTAINING GROUP 

; / Entry 

} r 

^. *************************************************************************** 


r f r 


FACTS 


(def facts monitoring-init-phases 


(first-sub-phase init 


These facts list the sequence of 
sub phases in the monitoring phase 
of the init rules 
monitoring status) 

There is only 1 subphase 


(deffacts init-phase-facts 


(engaged-system none) 

( system- available none) 

) 


/This fact indicates which 
/system pass or bfs is the 
/proper source of information 


/default is set to none 


(deffacts string-phases 
( first-sub-phase 
( first-sub-phase 

) 


string monitoring commfault) 
string analysis clear) 


(deffacts initial-strings 


( prev-string-cf 

pass 

1 

off) 

( prev-string-cf 

pass 

2 

off) 

( prev-string-cf 

pass 

3 

off) 

( prev-string-c f 

pass 

4 

off) 

(prev-string-cf 

bfs 

1 

off) 

(prev-string-cf 

bfs 

2 

off) 

(prev-string-cf 

bfs 

3 

off) 

( prev-string-cf 

bfs 

4 

off) 


(def rule engaged-system-is-bf s 


i f 
r r 
r r 
r t 

t f 


IF 

BFS engage is on 

THEN 

BFS is the engaged system 

END 


3 

PRECEDING PAGE BLANK NOT FILMED 



(sub-phase init status) 
(bfs-engage on) 

?x <- (engaged-system ~bfs) 

= > 

(retract ?x) 

(assert (engaged-system bfs))) 


(defrule engaged-system-is-pass 


BFS engage is off 

PASS is the engaged system 


(sub-phase init status) 
(bfs-engage off) 

?x <- (engaged-system ~pass) 

= > 

(retract ?x) 

(assert (engaged-system pass))) 


IF 

THEN 

END 


; ; Note: The following 3 availability rules were implemented 
; ; with the assumption that CLIPS would ensure that 

; ; two duplicate facts are not allowed to reside in 

/ ; the fact base. These rules will cause duplicate 

;; facts to be generated; therefore, proper operation 

; ; depends upon the above stated feature of CLIPS to 

;; be active .( i . e. , check-facts function is assumed to 

be "on" . ) 

( defrule system- availability-bf s-only 


the BFS is engaged 

THEN 

the BFS is the only system available 

(sub-phase init status) 

(engaged-system bfs) 

?x <- ( system- available ~bfs) 

=> 

(retract ?x) 

(assert ( system- available bfs))) 


( defrule system- availability-pass-only 


the BFS is not engaged 
the BFS is no go 

THEN 

the PASS is the only system available 


4 



(sub-phase init status) 

(not (engaged-system bfs)) 
(bfs-status no-go) 

?x <- (system-available ~pass) 

=> 

(retract ?x) 

(assert ( system- available pass))) 


( def rule system- availability-both 


the BFS is not engaged 
the BFS is Go 

both systems are available 

(sub-phase init status) 

(not (engaged-system bfs)) 
(bfs-status go) 

=> 

(assert ( system- available bfs)) 
(assert ( system- available pass))) 


IF 


THEN 


(def rule wrong-atmosphere 


For the engaged system 

The ONAV operator desired atmosphere model 

is not the same as the downlisted model 

Notify operator that crew has incorrect atmosphere 
selected 

Recommend call to crew to select the desired atmosphere 

(sub-phase init status) 

(engaged-system ?sys) 

( atmosphere desired ?model ) 

(atmosphere ?sys ~?model) 

=> 

(assert (status-light drag 0 atmos)) 

(if (eq ?model nominal) then 
(bind ?item 37) 

else (if (eq ?model cold) then 
(bind ?item 38) 

else 

(bind ?item 39) ) ) 

(assert (recommend drag atmos off-nominal alt 

"Need to select the " ?model " atmosphere by ITEM " 
?item " on SPEC 51"))) 


IF 


THEN 


END 


(def rule right-atmosphere 


IF 


5 




The desired atmosphere is the same as the downiisted 
atmosphere 

THEN 

Notify operator that correct atmosphere is selected 

(sub-phase init status) 

(engaged-system ?sys) 

( atmosphere desired ?model ) 

(atmosphere ?sys ?model) 

= > 

(assert (status-light drag 0 blank))) 


(defrule wrong-major-mode 


For the available systems, 
the major mode is not 304 

Notify the operator that the (system) is in the wrong 
major mode. 

Recommend call to crew to select major mode 304 in 
the (system). 

(sub-phase init status) 

( system- available ?sys) 

(major-mode ?sys ~304) 

=> 

(assert (recommend three-state wrong-majormode off-nominal alt 
" wrong" " major mode in " ?sys 
" ; Recommend crew call to select mm304"))) 


IF 


THEN 




; ; ; GROUP String Commfaults 

f i 

; ; This group notifies the operator when commfaults occur or clear up 

;; on entire strings. 

I CONTROL FACTS 
; (sub-phase string ?) 

• • ; CONTAINING GROUP 
; ; Entry 




(defrule commfault-string-pass 


A string is commfaulted in the PASS AND 
The string was not previously commfaulted 

THEN 

Notify the operator that the string is commfaulted 

END 

(sub-phase string commfault) 


6 



( string-commf ault pass ?string on) 

?x <- (prev-string-cf pass ?string off) 

= > 

(retract ’x) 

(assert (prev-string-cf pass ?string on)) 

(assert (event three-state off-nominal alt 

"Commfault string " ?string " in the PASS"))) 


(defrule commf ault-string-bf s 


A string is commfaulted in the BFS AND 
The string was not previously commfaulted 

Notify the operator that the string is commfaulted 


(sub-phase string commfault) 

( string-commf ault bfs ?string on) 

?x <- (prev-string-cf bfs ?string off) 

=> 

(retract ?x) 

(assert (prev-string-cf bfs ?string on)) 

(assert (event three-state off-nominal alt 

"Commfault string " ?string " in the BFS"))) 


IF 


THEN 

END 


(defrule clear-string-pass 


A string is not commfaulted in the PASS AND 
The string was previously commfaulted 

Notify the operator that the commfault is clear 


(sub-phase string clear) 

(string-commf ault pass ?string off) 

?x <- (prev-string-cf pass ?string on) 

-> 

(retract ?x) 

(assert (prev-string-cf pass ?string off)) 

(assert (event three-state off-nominal alt 

"Commfault on string " ?string " has cleared in the PASS' 1 ))) 


IF 


THEN 

END 


(defrule clear-string-bf s 

A string is not commfaulted in the BFS AND 
The string was previously commfaulted 

Notify the operator that the commfault is clear 
(sub- phase string clear) 


IF 

THEN 

END 


7 


(string-commfault bfs ?string off) 

?x <- (prev-string-cf bfs ?string on) 

=> 

(retract ?x) 

(assert (prev-string-cf bfs ?string off)) 

(assert (event three-state off-nominal alt 

"Commfault on string " ?string " has cleared in the BFS"))) 



3 . 2 


Telemetry Status 


3 


9 


r r 


r t 

; ; 'Telemetry Status Rules (3.2) 


/ ! 

; i No rules specified at this time pending further details 

/ r 


i f 


3.3 


Runway Status 


3 


11 



. ***************************************************************************** 


;;; GROUP Landing Site Checks (3.3) 

/ } 

i ; This group determines whether or not the correct runway is selected 

;i in the onboard systems, and determines what action is needed when the 

;; wrong runway is selected. 

■ ■ ; CONTROL FACTS 
; (sub-phase runway ?) 

• ; CONTAINING GROUP 
,• ,■ Entry 




(def facts monitoring-runway-phases These facts define the runway 

,• sub-phases in the monitoring phase 
(first-sub-phase runway monitoring check) 

; There is only 1 sub-phase: "check" 


) 


(def facts initial-runway-facts 


( runway-status 
( runway- status 
( runway- status 


pass unknown) ; 
bfs unknown) ; 
ground unknown ) 


) 


These facts represent assumptions 
about the runways before any data 
is received. 

Don't know if right rw in the pass 

Don't know if right rw in the bfs 

Don't know if right rw in the ground 


(def rule desired-runway- from-operator 


The operator entered the desired runway slot 
number 

Conclude the desired runway has that slot 
number 


(sub-phase runway check) 

?x <-( runway desired ?) 

?y <- (operator-input runway ?slot) 
=> 

(retract ?x ?y) 

(assert (runway desired ?slot))) 


IF 


THEN 


END 


(defrule onboard- runway-correct 


For the available system 

The selected runway in an onboard system is the same as 
the desired runway AND 

The runway status of that system was previously unknown or no-go 


12 



THEN 

Conclude that the runway status of the onboard system is go 
Notify the operator 

END 

(sub-phase runway check) 

( system- available ?sys) 

(runway desired ?slot) 

(runway ?sys ?slot) 

?x <- (runway-status ?sys go) 

=> 

(retract ?x) 

(assert (runway-status ?sys go)) 

(assert (status-light runway ?sys go)) 

(assert (event site nominal alt 

"The " ?sys " has the correct runway selected" ) ) ) 


( defrule onboard-runway-incorrect 


For the available systems 

The system runway (slot) is not the same as the 
desired runway (slot) 

Notify operator that the system has selected the 
wrong runway . 

Recommend call to crew to select proper runway. 

(sub-phase runway check) 

( system- available ?sys) 

(runway desired ?desired-slot ) 

(runway ?sys ?actual-slot&~?desired-slot) 

(same-area ?desired-slot ?actual-slot) 

?x < — ( runway- status ?sys ?status) 

=> 

(if (neq ?status no-go) 
then 

(retract ?x) 

(assert (runway-status ?sys no-go))) 

(if (> ?actual-slot ?desired-slot) 
then 

(bind ?item 3) 

(bind ?name "primary") 

else 

(bind ?item 4) 

(bind ?name "secondary")) 

(assert (status-light runway ?sys no-go)) 

(assert (recommend site ?sys off-nominal alt 

"Need to select the " ?name " runway in the " ?sys 
" by ITEM " ?item " on SPEC 50"))) 


IF 


THEN 


END 


(defrule onboard-area-incorrect 


/ } 
f f 


IF 


For the available systems 


13 



The selected runway in an onboard system is different from 
the desired runway AND 

The selected runway is not in the same area as the 
desired runway 

Notify the operator that the correct area must be selected 


(sub-phase runway check) 

(system- available ?sys) 

(runway desired ?desired-slot ) 

(runway ?sys ?actual-slot&~?desired-slot ) 

(not (same-area ?desired-slot ? actual-slot ) ) 

(same-area ?desired-slot ?other-slot) 

?x <- (runway-status ?sys ?status) 

= > 

(if (neq ?status no-go) 
then 

(retract ?x) 

(assert (runway-status ?sys no-go))) 

(assert (status-light runway ?sys no-go)) 

(if (> ?desired-slot ?other-slot) 
then 

(bind ?area (/ ?desired-slot 2)) 

(assert (recommend site ?sys off-nominal alt 

"Need to select runway " =( lookup-rw-name ?desired-slot) 
" in the " ?sys " by ITEM 41 +" ?area 
" followed by ITEM 4 on SPEC 50")) 

else 

(bind ?area (/ (+ ?desired-slot 1) 2)) 

(assert (recommend site ?sys off-nominal alt 

"Need to select runway " =( lookup-rw-name ?desired-slot) 
" in the " ?sys " by ITEM 41 +" ?area 
" on SPEC 50" ) ) ) ) 


f r 
t / 

/ r 

THEN 

; ; END 


(defrule ground-runway-incorrect 


The GND runway (name) is not the same as the desired 
runway ( name ) 

Notify operator that the selected GND runway is 
in error. 

Recommend call to GDO to have trajectory change the 
GND runway 


(sub-phase runway check) 

(runway desired ?desired-slot&~unknown) 

(runway ground ?actual-slot&~?desired-slot ) 

?x <- (runway-status ground ?status) 

=> 

(if (neq ?status no-go) 
then 

(retract ?x) 

(assert (runway-status ground no-go))) 
(assert (status-light runway ground no-go)) 
(assert (recommend site ground off-nominal alt 


IF 


THEN 


END 


14 


GDO needs to select runway " 

( lookup-rw-name ?desired-slot ) ) ) ) 


15 



3.4 Inertial Measurement Units 


3 


16 




; ; ; GROUP 

/ ; Inertial Measurement Units (3.4) 

f i 

; ; This group watches the IMUs for failures and determines 

;; the cause of those failures. This group also determines 

i ; which IMUs should be used at any given time. 

; ; ; CONTROL FACTS 
; (sub-phase imu ?) 

• ; CONTAINING GROUP 
; ; Entry 

t i 

***********************★***********★*★★*★★★**★★★★★★******★*★★*****★■*•******•**★ 


Iff 


FACTS 


(deffacts monitoring-imu-phases ; Defines the sequence of 


; sub-phases in the monitoring 
; phase of the IMU section. 


( first-sub-phase 

imu 

monitoring pass 

-availability ) 

; The first sub-phase is 
PASS availability. 

( next-sub-phase 

imu 

pass-availability 

bfs-availability) 

; After PASS availability comes 
; BFS availability. 

( next-sub-phase 

imu 

bfs-availability 

error-detection ) 

; After BFS availability comes 
; error detection . 

( next-sub-phase 

imu 

error-detection 

error-isolation ) 

After error detection comes 
error isolation. 

( next-sub-phase 

imu 

error-isolation 

error-magnitude) 

; After error isolation comes 
; error magnitude determination 

( next-sub-phase 

imu 

error-magnitude 

failure-prediction ) 


; After error magnitude comes 
; failure prediction. 

) ; Failure prediction is the last 

; IMU sub-phase in monitoring 
; phase. 


(deffacts analysis-imu-phases 
(first-sub-phase imu 
(next-sub-phase imu 

) 


,■ Defines sequence of sub-phase 
; in the analysis phase of the 
,■ IMU section . 

analysis pass-recommendation) 

,• The first sub-phase is 
PASS recommendations, 
pass-recommendation bf s-recommendation ) 

; After PASS recommendations 
,• comes BFS recommendations. 

,• BFS recommendations is the 
last IMU sub-phase in the 
; analysis phase. 


(deffacts initial-imu-facts 


These facts represent assumptions 


17 


( imu- avail-output pass 1 avail) 
(imu- avail-output pass 2 avail) 

( imu- avail-output pass 3 avail) 
(imu- avail-output bfs 1 avail) 

( imu- avail-output bfs 2 avail) 

( imu-avail-output bfs 3 avail) 
(good-imus 3) 

(prev-bfs-imu 0) 

( is-imu-valid 1 vel valid) 

( is-imu-valid 2 vel valid) 
(is-imu-valid 3 vel valid) 
(is-imu-valid 1 att valid) 
(is-imu-valid 2 att valid) 
(is-imu-valid 3 att valid) 
(is-imu-valid 1 acc invalid) 
(is-imu-valid 2 acc invalid) 
(is-imu-valid 3 acc invalid) 
(imu-quality 1 good) 

(imu-quality 2 good) 

(imu-quality 3 good) 

(imu-vel 1 under) 

(imu-vel 2 under) 

(imu-vel 3 under) 

(imu-att 1 under) 

(imu-att 2 under) 

(imu-att 3 under) 

(imu- acc 1 under) 

(imu- acc 2 under) 

(imu- acc 3 under) 

(imu-rm-prediction none) 

(initial-misalignment 1 unknown) 

(initial-misalignment 2 unknown) 

(initial-misalignment 3 unknown) 

) 


,• about the IMUs before any data is 
,■ received 

; IMU 1 is available in the PASS 

; IMU 2 is available in the PASS 

i IMU 3 is available in the PASS 

; IMU 1 is available in the BFS 

; IMU 2 is available in the BFS 

; IMU 3 is available in the BFS 

; There are three good IMUs 
; The BFS has been mid-value selecting 
; IMU 1 is producing valid velocity data 

; IMU 2 is producing valid velocity data 

; IMU 3 is producing valid velocity data 

; IMU 1 is producing valid attitude data 

IMU 2 is producing valid attitude data 
; IMU 3 is producing valid attitude data 

; IMU 1 is producing valid ACC data 

; IMU 2 is producing valid ACC data 

; IMU 3 is producing valid ACC data 

; IMU 1 has no problems 
; IMU 2 has no problems 
; IMU 3 has no problems 
; IMU 1 velocity compared to other IMUs 
; is within limits 

; IMU 2 velocity compared to other IMUs 
; is within limits 

; IMU 3 velocity compared to other IMUs 
; is within limits 

; IMU 1 attitude compared to other IMUs 
,■ is within limits 

; IMU 2 attitude compared to other IMUs 
,• is within limits 

; IMU 3 attitude compared to other IMUs 
; is within limits 

; IMU 1 ACC data compared to other IMUs 
; is within limits 

i IMU 2 ACC data compared to other IMUs 
; is within limits 

; IMU 3 ACC data compared to other IMUs 
; is within limits 

; IMU RM is not predicted to fail any 
; current candidates. 

; The initial misalignment for IMU 1 
; is unknown 

; The initial misalignment for IMU 2 
; is unknown 

; The initial misalignment for IMU 3 
; is unknown 




- — t f f 

r — : f r 


GROUP 

PASS IMU Availability (3. 4. 1.1) 


This group determines which IMUs are available in the PASS, and why 
the unavailable ones are unavailable. 



CONTROL FACTS 


18 


; (sub-phase imu pass-availability) 

CONTAINING GROUP 

; ; Inertial Measurement Units 

r f 

; ; ***************************************************************************** 
(defrule imu-commf ault-pass 


The PASS is engaged 

An IMU was not previously commfaulted in the PASS AND 
The commfault flag for that IMU is on in the PASS 

Notify operator that an IMU is commfaulted (unless the whole 
string is commfaulted) . 

Conclude the IMU is unavailable to the PASS due to 
a commfault. 

Conclude no IMU RM prediction 


(sub-phase imu pass-availability) 

(engaged-system pass) 

?x <- ( imu-avail-output pass ?imu "commfault) 
(imu- flag pass commfault ?imu on) 
(string-commfault pass ?imu ?string-flag) 

?y <- ( imu-rm-prediction $?) 

=> 

(if (eq ?string-flag off) 
then 

(assert (event pass- imu off-nominal alt 

"Commfault IMU " ?imu " in PASS"))) 

(retract ?x) 

(assert (imu-avail-output pass ?imu commfault)) 
(retract ?y) 

(assert (imu-rm-prediction none))) 


IF 


THEN 


END 


(defrule imu-comf-clear-pass-1 


The PASS is engaged 

An IMU has been unavailable to the PASS due to commfault 

The commfault flag for that IMU is off in the PASS 

The fail flag or deselect flag for that IMU is on in the PASS 

Notify operator that the commfault has cleared 
(unless it was a string commfault) 

Conclude the IMU is unavailable to the PASS due to failure 
or deselect, whichever flag is on 
Conclude no IMU RM prediction 


(sub-phase imu pass-availability) 
(engaged-system pass) 

?x <- (imu-avail-output pass ?imu commfault) 
(imu- flag pass commfault ?imu off) 

(imu-flag pass ?flag&fail | deselect ?imu on) 
(prev-string-cf pass ?imu ?string-flag) 


IF 


THEN 


END 


19 


?y <- ( imu-rm-prediction $?) 

=> 

(if (eq ?string-flag off) 
then 

(assert (event pass-imu off-nominal alt 

"Commfault clear on IMU " ?imu " in PASS"))) 

(retract ?x) 

(assert ( imu-avail-output pass ?imu ?flag) ) 

(retract ?y) 

(assert (imu-rm-prediction none))) 


(defrule imu-comf-clear-pass-2 


The PASS is engaged 

An IMU has been unavailable to the PASS due to commfault 
The commfault flag for that IMU is off in the PASS 
The fail flag for that IMU is off in the PASS 
The deselect flag for that IMU is off in the PASS 

Notify operator that the commfault has cleared 
(unless it was a string commfault) 

Conclude the IMU is now available to the PASS 
Conclude no IMU RM prediction 


(sub-phase imu pass-availability) 

(engaged-system pass) 

?x <- (imu-avail-output pass ?imu commfault) 

(imu-flag pass commfault ?imu off) 

(imu-flag pass fail ?imu off) 

(imu-flag pass deselect ?imu off) 

(prev-string-cf pass ?imu ?string-flag) 

?y <- (imu-rm-prediction $?) 

=> 

(if (eq ?string-flag off) 
then 

(assert (event pass-imu off-nominal alt 

"Commfault clear on IMU " ?imu " in PASS"))) 

(retract ?x) 

(assert (imu-avail-output pass ?imu avail)) 

(retract ?y) 

(assert (imu-rm-prediction none))) 


IF 


THEN 


END 


(defrule imu-failed-pass 


The PASS is engaged 

An IMU has been available to the PASS 

The fail flag for that IMU is on in the PASS 

THEN 

Notify operator of IMU failure 

Conclude the IMU is unavailable to the PASS due to failure 
Conclude no IMU RM prediction 


20 



/ f 


END 


(sub-phase imu pass-availability) 

(engaged-system pass) 

?x <- ( imu-avail-output pass ?imu avail) 

(imu-flag pass fail ?imu on) 

?y <- ( imu-rm-prediction $?) 

=> 

(assert (event pass-imu off-nominal alt "RM failed IMU " ?imu)) 
(retract ?x) 

(assert (imu-avail-output pass ?imu fail)) 

(retract ?y) 

(assert (imu-rm-prediction none))) 


(defrule imu-deselected-pass 


The PASS is engaged 

An IMU has been available to the PASS 

The deselect flag for that IMU is on in the PASS 

Notify operator of crew deselection 

Conclude the IMU is unavailable to the PASS due to deselect 
Conclude no IMU RM prediction 


(sub-phase imu pass-availability) 

(engaged-system pass) 

?x <- (imu-avail-output pass ?imu avail) 

(imu-flag pass deselect ?imu on) 

?y <- (imu-rm-prediction $?) 

= > 

(assert (event pass-imu off-nominal alt "Crew deselected IMU " ?imu) ) 
(retract ?x) 

(assert (imu-avail-output pass ?imu deselect)) 

(retract ?y) 

(assert (imu-rm-prediction none))) 


IF 


THEN 


END 


(defrule imu-reselected-pass 


The PASS is engaged 

An IMU has been unavailable to the PASS due to failure 
or deselect 

The fail flag for that IMU is off in the PASS 
The deselect flag for that IMU is off in the PASS 

THEN 

Notify operator of crew reselection. 

Conclude the IMU is now available to the PASS. 

Conclude no IMU RM prediction 

END 

(sub-phase imu pass-availability) 

(engaged- system pass) 


21 



?x <- ( imu-avail-output pass ?imu fail | deselect ) 

(imu-flag pass fail ?imu off) 

(imu-flag pass deselect ?irau off) 

?y <- ( imu-rm-prediction $?) 

-> 

(assert (event pass-imu off-nominal alt "Crew reselected IMU " ’imu)) 
(retract ?x) 

(assert (imu-avail-output pass ?imu avail)) 

(retract ?y) 

(assert (imu-rm-prediction none))) 


(defrule three-good-imus 


The PASS is engaged 

All 3 IMUs are not commfaulted in the PASS 
All 3 IMUs are good 

Conclude that there are 3 good IMUs in the PASS 


(sub-phase imu pass-availability) 
(engaged-system pass) 


?x <- (good-imus 

3) 



( imu-avail-output 

pass 

i 

~commfault ) 

( imu-avail-output 

pass 

2 

~commfault ) 

( imu-avail-output 

pass 

3 

~commfault ) 


(imu-quality 1 good) 
(imu-quality 2 good) 
(imu-quality 3 good) 

= > 

(retract ?x) 

(assert (good-imus 3))) 


IF 

THEN 

END 


(defrule two-good-imus 


The PASS is engaged 

IMU A is not commfaulted in the PASS 
IMU A is good 

IMU B is not commfaulted in the PASS 
IMU B is good 

IMU C is commfaulted in the PASS or suspect 
Conclude we have 2 good IMUs in the PASS 


(sub-phase imu pass-availability) 

(engaged- system pass) 

?x <- (good-imus ~2) 

(imu-avail-output pass ?imu-a ~commfault) 
(imu-quality ?imu-a good) 

(imu-avail-output pass ?imu-b&~?imu-a ~commfault) 
(imu-quality ?imu-b good) 


IF 


THEN 

END 


22 


(or ( imu-avail-outgut pass ?imu-a&~?imu-b commfault) 
(imu-quality ?imu-a&~?imu-b ~good) ) 

= > 

(retract ?x) 

(assert (good-imus 2))) 


(defrule one-good-imu 


The PASS is engaged 

IMU A is not commfaulted in the PASS 
IMU A is good 

IMU B is commfaulted in the PASS or suspect 
IMU C is commfaulted in the PASS or suspect 

Conclude we have 1 good IMU in the PASS 


(sub-phase imu pass-availability) 

(engaged-system pass) 

?x <- (good-imus 1) 

(imu-avail-output pass ?imu-a ~commfault) 

(imu-quality ?imu~a good) 

(or (imu-avail-output pass ?imu-b&~?imu-a commfault) 

(imu-quality ?imu-b&~?imu-a ~good)) 

(or (imu-avail-output pass ~?imu-a&~?imu-b commfault) 

(imu-quality ?imu-a&~?imu-b ~good) ) 

=> 

(retract ?x) 

(assert (good-imus 1))) 


IF 


THEN 

END 


(defrule no-good- imus 


The PASS is engaged 

All 3 IMUs are commfaulted in the PASS or suspect 

Conclude we have no good IMUs in the PASS 
Notify operator of no good IMU's in the PASS 


(sub-phase imu pass-availability) 
(engaged-system pass) 

?x <- (good-imus ~0) 

(or (imu-avail-output_ pass 1 commfault) 

(imu-quality 1 ~good)) 

(or ( imu-avail-output_ pass 2 commfault) 

(imu-quality 2 ~good) ) 

(or ( imu-avail-output_ pass 3 commfault) 

(imu-quality 3 ~good)) 

= > 

(retract ?x) 

(assert (good-imus 0)) 

(assert (event pass-imu off-nominal alt 


r r 

f f 
r t 
/ r 
i r 

} i 

f t 


IF 


THEN 


END 


23 


WARNING — WE HAVE NO GOOD IMUS IN THE PASS''))) 


; GROUP 

BFS IMU Availability (3. 4. 1.2) 

This group determines which IMUs are available in the BFS. It also 
determines why the unavailable IMUs are unavailable. 

; CONTROL FACTS 

(sub-phase imu bfs-availability ) 

i CONTAINING GROUP 

Inertial Measurement Units 

***************************************************************************** 


w(defrule imu-commfault-bf s 


The BFS is available 

An IMU was not previously commfaulted in the BFS 
The commfault flag for that IMU is on in the BFS 

Notify operator of IMU commfault (unless the whole string 
is commfaulted). 

Conclude the IMU is not available to the BFS due to commfault. 


(sub-phase imu bfs-availability) 

(system-available bfs) 

?x <- ( imu-avail-output bfs ?imu ~commfault) 
(imu-flag bfs commfault ?imu on) 

(string-commfault bfs ?imu ?string-flag) 

=> 

(if (eq ?string-flag off) 
then 

(assert (event bfs-imu off-nominal alt 

"Commfault IMU " ?imu " in the BFS"))) 

(retract ?x) 

(assert (imu-avail-output bfs ?imu commfault))) 


IF 


THEN 


END 


_( def rule imu-comf-clear-bf s-not-engaged 


The BFS is available 

The BFS is engaged 

An IMU was unavailable to the BFS due to commfault 

The commfault flag for that IMU is off in the BFS 

THEN 

Notify operator that commfault has been cleared (unless the 
whole string was commfaulted). 

Conclude the IMU is available to the BFS (if the fail flag is 
off) or unavailable due to failure (if the fail flag 
is on ) . 


24 


END 

(sub-phase imu bfs-availability ) 

(system- available bfs) 

(engaged-system ~bfs) 

?x <- ( imu-avail-output bfs ?imu commfault) 
(imu- flag bfs commfault ?imu off) 

(imu-flag bfs fail ?imu ?fail-flag) 
(prev-string-cf bfs ?imu ?string-flag) 

= > 


(if (eq ?string-flag off) 
then 

(assert (event bfs-imu off-nominal alt 



"Commfault on IMU " 

?imu 

" cleared in BFS"))) 

(retract ?x) 

(if (eq ?fail- 

flag off) 



then 




(assert 

( imu-avail-output 

bfs 

?imu avail ) ) 

else 


( assert 

( imu-avail-output 

bfs 

?imu fail ) ) ) ) 


( defrule imu-comf-clear-bf s-engaged-partl 


The BFS is engaged 

An IMU has been unavailable to the BFS due to commfault 
The commfault flag for that IMU is off in the BFS 
The fail flag or deselect flag for that IMU is 
on in the BFS 

Notify operator that the commfault has cleared 
(unless it was a string commfault) 

Conclude the IMU is unavailable to the BFS due to 
failure or deselect, whichever flag is on 

(sub-phase imu bfs-availability) 

(engaged-system bfs) 

?x <- (imu-avail-output bfs ?imu commfault) 

(imu-flag bfs commfault ?imu off) 

(imu-flag bfs ?flag&fail | deselect ?imu on) 

(prev-string-cf bfs ?imu ?string-flag) 

=> 

(if (eq ?string-flag off) 
then 

(assert (event bfs-imu off-nominal alt 
"Commfault on IMU " ?imu " cleared in BFS"))) 

(retract ?x) 

(if (eq ?flag fail) 

then (assert (imu-avail-output bfs ?imu fail)) 
else (assert (imu-avail-output bfs ?imu deselect)))) 


IF 


THEN 


( defrule imu-comf-clear-bf s-engaged-part2 


/ } 
f f 


IF 


The BFS is engaged 


25 



; ; An IMU has been unavailable to the BFS due to commfault 

;; The commfault flag for that IMU is off in the BFS 

;; The fail flag for that IMU is off in the BFS 

i ; The deselect flag for that IMU is off in the BFS 

; ; THEN 

/' ; Notify the operator that the commfault has cleared 

;; (unless it was a string commfault) 

; i Conclude the IMU is now available to the BFS 

(sub-phase imu bfs availability) 

(engaged-system bfs) 

?x <- (imu-avail-output bfs ?imu commfault) 

(imu-flag bfs commfault ?imu off) 

(imu-flag bfs fail ?imu off) 

(imu-flag bfs deselect ?imu off) 

(prev-string-cf bfs ?imu ?string-f lag) 

=> 

(if (eq ?string-flag off) 

then (assert (event bfs-imu off-nominal alt 

"Commfault on IMU " ?imu " cleared in BFS"))) 

(retract ?x) 

(assert (imu-avail-output bfs ?imu avail))) 


(defrule imu-failed-bf s 


BFS is available 

An IMU was available to the BFS 

The fail flag for that IMU is on in the BFS 

Notify operator of IMU failure in the BFS 

Conclude the IMU is unavailable to the BFS due to failure 


(sub-phase imu bfs-availability) 

(system- avail able bfs) 

?x <- (imu-avail-output bfs ?imu avail) 

(imu-flag bfs fail ?imu on) 

=> 

(assert (event bfs-imu off-nominal alt "IMU " ?imu " failed in BFS")) 
(retract ?x) 

(assert (imu-avail-output bfs ?imu fail))) 


i i 
/ } 
r r 
i r 
/ r 

i t 

i t 
r i 


IF 


THEN 


END 


( defrule imu-deselected-bf s-l-not-engaged 


The BFS is not engaged 

The BFS is available 

The BFS was mid-value-selecting IMUs 

All IMU commfault flags are off in the BFS 

All IMU fail flags are off in the BFS 

The BFS is prime selecting an IMU 

THEN 

Notify operator that BFS has changed IMU status due to 
a crew action. 


26 


END 


t f 


f / 
t f 


Notify the operator that BFS is now prime selecting an 
IMU 


(sub-phase imu bfs-availability) 
(engaged-system ~bfs) 

( system- available bfs) 

?x <- (prev-bf s-imu 0) 

(bfs-imu ?new-imu&~0) 


( imu-flag 

bfs 

commfault 1 

off) 

( imu-flag 

bfs 

commfault 2 

off) 

( imu-flag 

bfs 

commfault 3 

off) 

( imu-flag 

bfs 

fail 1 

off ) 


( imu-flag 

bfs 

fail 2 

off) 


( imu-flag 
= > 

bfs 

fail 3 

off) 


/ 

(assert 

( event 

bfs-imu 

off-nominal 


"Crew deslected an IMU in the BFS")) 

(assert (event bfs-imu off-nominal alt "BFS is now on IMU " ?new-imu) ) 
(retract ?x) 

(assert (prev-bfs-imu ?new-imu) ) ) 


( defrule imu-deselected-bf s-2-not-engaged 


The BFS is available 

The BFS is not engaged 

The BFS was prime selecting an IMU 

The commfault flag for that IMU is off in the BFS 

The fail flag for that IMU is off in the BFS 

The BFS is now prime selecting a different IMU 

Notify operator the formerly selected IMU has been deselected. 
Notify operator that BFS is now prime selecting a different 
IMU 


(sub-phase imu bfs-availability) 

(engaged-system ~bfs) 

( system- available bfs) 

?x <- ( prev-bf s-imu_ ?imu&~0) 

(bfs-imu ?new-imu&~?imu) 

(imu-flag bfs commfault ?imu off) 

(imu- flag bfs fail ?imu off) 

=> 

(assert (event bfs-imu off-nominal alt 

"Crew deselected IMU " ?imu " in the BFS")) 

(assert (event bfs-imu off-nominal alt "BFS is now on IMU " ?new-imu)) 
(retract ?x) 

(assert (prev-bfs-imu ?new-imu) ) ) 


/ / 
i f 

i r 
} / 
/ r 
r r 
i r 

} t 

i r 

f f 
} f 

} i 


IF 


THEN 


END 


( defrule imu-deselected-bf s-engaged 


/ / 
r I 


IF 


The BFS is available 


27 



; ; The BFS is engaged 

; i An IMU has been available to the BFS 

; ; The deselect flag for that IMU is on in the BFS 

; ; THEN 

;; Notify operator of crew deselection in the BFS 

; ; Conclude the IMU is unavailable to the BFS 

; ; due to deselection 

(sub-phase imu bfs-availability ) 

( system- available bfs) 

(engaged-system bfs) 

?x <- ( imu- avail-output bfs ?imu avail) 

(imu- flag bfs deselect ?imu on) 

= > 

(assert (event bfs-imu off-nominal alt 

"Crew deselected IMU " ?imu " in the BFS")) 
(retract ?x) 

(assert ( imu- avail-output bfs ?imu deselect))) 


( def rule imu-reselect-bf s-engaged 


The BFS is engaged 

An IMU has been unavailable to the BFS due to 
failure or deselect 

The fail flag for that IMU is off in the BFS 
The deselect flag for that IMU is off in the BFS 

THEN 

Notify operator of crew reselection 
Conclude the IMU is now available to the BFS 


(sub-phase imu bfs-availability) 

(engaged-system bfs) 

?x <- ( imu-avail-output bfs ?imu fail | deselect ) 
(imu-flag bfs fail ?imu off) 

(imu-flag bfs deselect ?imu off) 

=> 

(assert (event bfs-imu off-nominal alt 

"Crew reselected IMU " ?imu " in the BFS")) 
(retract ?x) 

(assert (imu-avail-output bfs ?imu avail))) 


(defrule imu-change-bf s 


f f 

i r 

r t 
r f 

/ i 
r f 

/ f 
/ f 
r f 


IF 


THEN 

END 


The BFS is available 

The fail flag or commfault flag for an IMU is on in the BFS 
That IMU was the prime selected IMU or the BFS was 
mid-value selecting 

Notify operator of a change in BFS IMU status due to 
commfault or failure. 


(sub-phase imu bfs-availability) 


28 


( system- available bfs) 

?x <- ( prev-bfs-imu~ ?imu-a) 

(bfs-imu ?new-imu&~?imu-a) 

(imu-flag bfs commfault | fail ?imu-b on) 

(test (|1 (= ?imu-a 0) 

(= ?imu-a ?imu-b))) 

=> 

(assert (event bfs-imu off-nominal alt "BFS is now on IMU " ?new-imu)) 
(retract ?x) 

(assert ( prev-bfs-imu ?new-imu) ) ) 


;; ***************************************************************************** 
; / ; GROUP 

; ; Error Detection ( 3 . 4 . 2 . 1 ) 

/ f 

; ; This group determines when an IMU error exists . 

■ • / CONTROL FACTS 

; (sub- phase imu error-detection) 

/ ; / CONTAINING GROUP 
; Inertial Measurement Units 

/ t 

;; ***************************************************************************** 
(defrule valid-velocity 


The PASS is engaged 
An IMU is not commfaulted 

That IMU is good or is suspect due to drift 

THEN 

Conclude that velocity comparisons with that IMU are valid. 

END 

(sub-phase imu error-detection) 

(engaged-system pass) 

?x <- (is-imu-valid ?imu vel ^invalid) 

( imu- avail-output pass ?imu ~commfault) 

(imu-quality ?imu good | drift) 

=> 

(retract ?x) 

(assert (is-imu-valid ?imu vel valid))) 


(defrule invalid-velocity 


i r 

i f 

/ r 

} i 

i r 
f i 


IF 

THEN 

END 


The PASS is engaged 

An IMU is commfaulted or is suspect due to anything but drift 
Conclude that velocity comparisons with that IMU are invalid. 


(sub-phase imu error-detection) 


(engaged-system pass) 

?x < — ( is-imu-valid ?imu vel valid) 

(or ( imu-avail-output pass ?imu commfault) 
(imu-quality ?imu ~good&~drift) ) 

=> 

(retract ?x) 

(assert (is-imu-valid ?imu vel invalid))) 


(defrule valid-attitude 


The PASS is engaged 
An IMU is not commfaulted 

That IMU is good or is suspect due to accelerometer bias 
Conclude that attitude comparisons with that IMU are valid. 


(sub-phase imu error-detection) 
(engaged-system pass) 

?x <- (is-imu-valid ?imu att ^invalid) 
(imu-avail-output pass ?imu ~commfault) 
(imu-quality ?imu good | bias) 

=> 

(retract ?x) 

(assert (is-imu-valid ?imu att valid))) 


IF 

THEN 

END 


(defrule invalid-attitude 


The PASS is engaged 

An IMU is commfaulted or is suspect due to anything but bias 
Conclude that attitude comparisons with that IMU are invalid. 


(sub-phase imu error-detection) 

(engaged- system pass) 

?x <- (is-imu-valid ?imu att valid) 

(or (imu-avail-output pass ?imu commfault) 
(imu-quality ?imu ~good&~bias ) ) 

=> 

(retract ?x) 

(assert (is-imu-valid ?imu att invalid))) 


IF 

THEN 

END 


( defrule valid-to-use-acc-comparison 


The PASS is engaged 

The ACC delta-t > 30 seconds 

THEN 


30 



; ; Valid to use ACC comparison 

/’ i 

(sub-phase imu error-detection) 
(engaged-system pass) 
(acc-delta-time ?t&:(> ?t 30.0)) 

?xl <- ( is-imu-valid 1 acc invalid) 
?x2 <- (is-imu-valid 2 acc invalid) 
?x3 <- (is-imu-valid 3 acc invalid) 

=■> 

(retract ?xl ?x2 ?x3 ) 

(assert (is-imu-valid 1 acc valid)) 
(assert (is-imu-valid 2 acc valid)) 
(assert (is-imu-valid 3 acc valid))) 


(defrule valid-acc 


The PASS is engaged 
An IMU is not commfaulted 

That IMU is good or is suspect due to resolver 
Conclude that ACC comparisons with that IMU are valid. 


(sub-phase imu error-detection) 
(engaged-system pass) 

?x <- (is-imu-valid ?imu acc ^invalid) 

( imu- avail-output pass ?imu ~commfault) 
(imu-quality ?imu good | resolver ) 

=> 

(retract ?x) 

(assert (is-imu-valid ?imu acc valid))) 


IF 

THEN 

END 


(defrule invalid-acc 


The PASS is engaged 

An IMU is commfaulted or is suspect due to anything but resolver 
Conclude that ACC comparisons with that IMU are invalid. 


(sub-phase imu error-detection) 
(engaged-system pass) 

?x <- (is-imu-valid ?imu acc valid) 

(or (imu-avail-output pass ?imu commfault) 
(imu-quality ?imu good&~resolver ) ) 

=> 

(retract ?x) 

(assert (is-imu-valid ?imu acc invalid))) 


IF 

THEN 

END 


/ f 

; ; ERROR DETECTION - Velocity Comparisons 

f f 


31 


(defrule velocity-comparison-1 


The PASS is engaged 
IMU A is not commfaulted 
IMU B velocity is valid 

Velocity comparison A-B is different from IMU A's earlier 
velocity comparison status 
IMU C velocity is invalid 

Change IMU A's velocity comparison status to current A-B 
comparison status. 


(sub-phase imu error-detection) 

(engaged-system pass) 

?x <- ( imu-vel ?imu-a Pstatus) 

( imu-avail-output pass ?imu-a ~commfault) 
(lrus-in-pair ?pair-l ?imu-a ?imu-b) 

( is-imu-valid ?imu-b vel valid) 

( rel-imu-comp ?pair-l __vel ?status-l&~?status) 
(lrus-in-pair ?pair-2&~?pair-l ?imu-a ?imu-c) 
(is-imu-valid ?imu-c vel invalid) 

= > 

(retract ?x) 

(assert (imu-vel ?imu-a ?status-l))) 


(defrule velocity-comparison- 2 


The PASS is engaged 
IMU A is not commfaulted 
IMU B velocity is valid 

Velocity comparison A-B is some status (call it status-1) 
IMU C velocity is valid 

Velocity comparison A-C is some status (call it status-2) 
The smaller of status-1 and status-2 is different from 
IMU A ' s earlier velocity comparison status 

Change IMU A's velocity comparison status to the smaller 
of status-1 and status-2. 


(sub-phase imu error-detection) 

(engaged-system pass) 

?x <- (imu-vel ?imu-a Pstatus) 

(imu-avail-output pass Pimu-a ~commfault) 

(lrus-in-pair ?pair-l ?imu-a ?imu-b) 

(is-imu-valid ?imu-b vel valid) 

(rel-imu-comp Ppair-1 ~vel ?status-l) 

(lrus-in-pair Ppair-2&~?pair-l ?imu-a ?imu-c) 
(is-imu-valid ?imu-c vel valid) 

(rel-imu-comp ?pair-2 vel ?status-2) 

(min-miscompare Pstatus-1 Pstatus-2 ?new-status& Pstatus) 
= > 

(retract ?x) 




32 




(assert ( imu-vel ?imu-a ?new-status ) ) ) 


/ t 

; ; ERROR DETECTION - Attitude Comparisons 
/ i 


(defrule attitude-comparison- 1 


l f 
/ / 
/ / 
/ i 

f f 
f r 

f f 

f i 

r f 
r t 
i r 


IF 


THEN 

END 


The PASS is engaged 
IMU A is not commfaulted 
IMU B attitude is valid 

Attitude comparison A-B is different from IMU A's earlier 
attitude comparison status 
IMU C attitude is invalid 

Change IMU A's attitude comparison status to current A-B 
comparison status. 


(sub-phase imu error-detection) 

(engaged-system pass) 

?x <- (imu-att ?imu-a Pstatus) 

( imu- avail-output pass ?imu-a ~commfault) 
(lrus-in-pair ?pair-l ?imu-a ?imu-b) 

( is-imu-valid ?imu-b att valid) 

(rel-imu-comp ?pair-l _att ?status-l&~?status) 
(lrus-in-pair ?pair-2s~?pair-l ?imu-a ?imu-c) 
(is-imu-valid ?imu-c att invalid) 

=> 


(retract ?x) 

(assert (imu-att ?imu-a ?status-l))) 


(defrule attitude-comparison-2 


The PASS is engaged 
IMU A is not commfaulted 
IMU B attitude is valid 

Attitude comparison A-B is some status (call it status-1) 
IMU C attitude is valid 

Attitude comparison A-C is some status (call it status-2) 
The smaller of status-1 and status-2 is different from 
IMU A ' s earlier attitude comparison status 

Change IMU A's attitude comparison status to the smaller of 
status-1 and status-2 


(sub-phase imu error-detection) 
(engaged-system pass) 

?x <- (imu-att ?imu-a Pstatus) 

( imu-avail-output pass Pimu-a ~commfault) 
(lrus-in-pair ?pair-l Pimu-a Pimu-b) 
(is-imu-valid ?imu-b att valid) 


IF 


THEN 


END 



(rel-imu-comp ?pair-l _att ?status-l) 

(lrus-in-pair 7 pair-2& ?pair-l ?imu-a ?imu-c) 
(is-imu-valid ?imu-c att valid) 

(rel-imu-comp ?pair-2 att ?status-2) 

(min-miscompare ?status-l ?status-2 ?new-status& ?status) 
=> 

(retract ?x) 

(assert ( imu-att ?imu-a ?new-status) ) ) 


; ERROR DETECTION - ACC Comparisons 

i r 


(defrule acc-comparison-1 


The PASS is engaged 
IMU A is not commfaulted 
IMU B ACC is valid 

Worst axis ACC comparison A-B is different from IMU A's 
earlier ACC comparison status 
IMU C ACC is invalid 

Change IMU A's ACC comparison status to current A-B 
comparison status. 


(sub-phase imu error-detection) 

(engaged-system pass) 

?x <- (imu-acc ?imu-a ?status) 

( imu-avail-output pass ?imu-a ~commfault) 
(lrus-in-pair ?pair-l ?imu-a ?imu-b) 

(is-imu-valid ?imu-b acc valid) 

(rel-imu-acc ?pair-l worst-axis ?status-l&~?status ) 
(lrus-in-pair ?pair-2&~?pair-l ?imu-a ?imu-c) 
(is-imu-valid ?imu-c acc invalid) 

=> 

(retract ?x) 

(assert (imu-acc ?imu-a ?status-l))) 


IF 


THEN 


END 


(defrule acc-comparison-2 


IF 


THEN 


The PASS is engaged 
IMU A is not commfaulted 
IMU B ACC is valid 

Worst axis ACC comparison A-B is some status (call it 
status-1) 

IMU C ACC is valid 

Worst axis ACC comparison A-C is some status (call it 
status-2 ) 

The smaller of status-1 and status-2 is different from 
IMU A ' s earlier ACC comparison status 

Change IMU A's ACC comparison status to the smaller of status-1 


34 




/ t 


END 


and status-2 


(sub-phase imu error-detection) 

(engaged-system pass) 

?x <- (imu-acc ?imu-a ?status) 

( imu- avail-output pass ?imu-a commfault) 

(lrus-in-pair ?pair-l ?imu-a ?imu-b) 

( is-imu-valid ?imu-b acc valid) 

(rel-imu-acc ?pair-l worst-axis ?status-l) 

(lrus-in-pair ?pair-2&~?pair-l ?imu-a ?imu-c) 
(is-imu-valid ?imu-c acc valid) 

(rel-imu-acc ?pair-2 worst-axis ?status-2) 

(min-mi scompare ?status-l ?status-2 ?new-status&~?status) 
=> 

(retract ?x) 

(assert (imu-acc ?imu-a ?new-status ) ) ) 


(defrule worst-comparison 


The PASS is engaged 

Exactly 2 good IMUs are available 

Those 2 IMUs disagree in any way 

Conclude that 2-level isolation must be used to determine 
which of the 2 IMUs has a problem 


( sub-phase imu error-detection ) 

(engaged-system pass) 

(good- imu s 2) 

( imu- avail-output pass ?imu-a __ commfault) 

( imu- avail-output pass ?imu-b&~?imu-a ~commfault) 
(lrus-in-pair ?pair ?imu-a ?imu-b) 

(imu-quality ?imu-a good) 

( imu- qua 1 i ty ? imu-b good ) 


( rel-imu-comp 

?pair 

vel 

?sl) 

( rel-imu-comp 

?pair 

att 

?s2) 

(max-mi scompare ?sl 

?s2 

?s3) 

(rel-imu-acc 

?pair 

worst- 

■axis ?s4) 


( max-mi scompare ?s3 ?s4 under) 

= > 

(assert (isolate ?pair))) 





f r 
f } } 
t r 


GROUP 

Error Isolation (3. 4. 2. 2) 


When an IMU error has been detected, this group determines which IMU 
has the problem, and what the problem is. 


;;; CONTROL FACTS 

; (sub-phase IMU error-isolation) 


I f 


35 


; ; ; CONTAINING GROUP 
i ; Inertial Measurement Units 

f r 

ERROR ISOLATION - 3 level 


~ (defrule three-level-component-isolation 


The PASS is engaged 
There are 3 good IMUs 

An IMU disagrees with the other 2 IMUs 

Use the fault matrix to determine the problem with the IMU 
Notify operator of an IMU problem 


(sub-phase imu error-isolation) 

(engaged-system pass) 

(good-imus 3) 

(imu-vel ?imu ?vel) 

(imu-att ?imu ?att) 

(imu-acc ?imu ?acc) 

(fault-matrix ?vel ?att _?acc ?fault) 

?x <- (imu-quality ?imu ~?fault) 

= > 

(if (eq ?fault suspect) 
then 

(assert (event pass-imu off-nominal alt 

"IMU " ?imu " has an undiagnosable problem")) 

else 

(if (eq ?fault good) 
then 

(assert (event pass-imu off-nominal alt 
"IMU " ?imu " is good")) 

else 

(assert (event pass-imu off-nominal alt 

"IMU " ?imu " has a " ?fault " error")))) 

(retract ?x) 

(assert (imu-quality ?imu ?fault))) 


ERROR ISOLATION - 2 level 


(defrule two-level-gnd-comparison 


The PASS is engaged 
HSTD is good 

An error between IMUs A and B has been detected at the 2 
level 

Worst axis GND-IMUA comparison is some status (call it 
status-a ) 

Worst axis GND-IMUB comparison is some status (call it 




36 


THEN 


t ( 
t f 

i t 
i r 


END 


status-b) 

GND-IMU comparison has not yet voted 

When status-a = status-b, vote 0 for both IMUs . 

Otherwise, vote 1 for the IMU with the larger difference, and 
0 for the other IMU. 


(sub-phase imu error-isolation) 
(engaged-system pass) 

( hstd good ) 

(isolate 7 pair) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
(gnd-imu ?imu-a worst-axis ?status-a) 
(gnd-imu ?imu-b worst-axis ?status-b) 
(not (imu-vote gnd $?)) 

=> 

(bind ?vote-a 0) 

(bind ?vote-b 0) 

(if (neq ?status-a ?status-b) 

then 

(if (neq ?status-a under) 
then 

(bind ?vote-a 1) 

else 

(bind ?vote-b 1))) 

(assert (imu-vote gnd ?vote-a ?imu-a)) 
(assert (imu-vote gnd ?vote-b ?imu-b))) 


(defrule two-level-gnd-cant-vote 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

The HSTD is not good 

GND-IMU comparison has not voted yet 

Vote 0 for IMUs A and B 


(sub-phase imu error-isolation) 
(engaged-system pass) 

(isolate ?pair) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
(hstd ~good) 

(not (imu-vote gnd $?)) 

=> 

(assert (imu-vote gnd 0 ?imu-a)) 
(assert (imu-vote gnd 0 ?imu-b) ) ) 


IF 


THEN 

END 


(defrule two- level-state-comparison 


IF 


37 



/ / 
} r 

i } 

f f 
} t 
/ / 
/ / 
/ / 
} } 
f r 
i f 
r f 

} t 

r t 

i } 


THEN 


END 


The PASS is engaged 

The HSTD is good 

3-state nav is active 

An error between IMUs A and B has been detected at the 2 
level 

Worst axis GND-state-A comparison is some status 
(call it status-a) 

Worst axis GND-state-B comparison is some status 
(call it status-b) 

GND-state comparison has not voted yet 

When status-a = status-b, vote 0 for both IMUs. 

Otherwise, vote 2 for the IMU with the larger difference, and 
0 for the other IMU. 


(sub-phase imu error-isolation) 
(engaged-system pass) 

( hstd good ) 

(nav-3-state on) 

(isolate ?pair) 

( lrus-in-pair ?pair ?imu-a ?imu-b) 
(gnd-3state ?imu-a worst-axis ?status-a) 
(gnd-3state ?imu-b worst-axis ?status-b) 
(not (imu-vote state $?)) 

=> 

(bind ?vote-a 0) 

(bind ?vote-b 0) 

(if (neq ?status-a ?status-b) 
then 

(if (neq ?status-a under) 
then 

(bind ?vote-a 2) 

else 

(bind ?vote-b 2))) 

(assert (imu-vote state ?vote-a ?imu-a)) 
(assert (imu-vote state ?vote-b ?imu-b))) 


( defrule two-level-state-cant-vote 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

The HSTD is not good OR 3-state nav is inactive 
GND-state comparison has not voted yet 

Vote 0 for IMUs A and B 


(sub-phase imu error-isolation) 
(engaged-system pass) 

(isolate ?pair) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
(or (hstd ~good) 

(nav-3-state off)) 

(not (imu-vote state $?)) 


/ r 
t f 


IF 


THEN 

END 


38 


=> 

(assert ( imu-vote state 0 ?imu-a)) 
(assert (imu-vote state 0 ?imu-b) ) ) 


( defrule two-level-acc-comparison 


f f 

f f 

i i 

r f 
r f 
r f 
f f 
} f 

f f 
r i 

f r 
t / 

i i 

i i 

/ t 


IF 

The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

IMU A is the reference for ACC comparisons 

X-axis ACC comparions A-B is some status (call it status-x) 

Y-axis ACC comparions A-B is some status (call it status-y) 

Z-axis ACC comparions A-B is some status (call it status-z) 

ACC comparison has not voted yet 

THEN 

If status-x, status-y, and status-z indicate the error lies 
in the x-y plane or z-axis of IMU A, vote 1 for 
IMU A; otherwise, vote 0 for IMU A. 

Vote 0 for IMU B. 

END 


(sub-phase imu error-isolation) 
(engaged-system pass) 

(isolate ?pair) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
?imu-a) 

?pair x 
?pair y 
?pair z 


( ref-imu-acc 
( rel-imu-acc 
( rel-imu-acc 
( rel-imu-acc 


( not 
=> 


( imu-vote acc 


?status-x) 
?status-y ) 
?status-z ) 
$?)) 


(bind ?vote-a 0) 

(if (neq ( | | (neq ?status-x under) (neq 
(neq ?status~z under)) 

then 

(bind ?vote-a 1)) 

(assert (imu-vote acc ?vote-a ?imu-a) ) 
(assert (imu-vote acc 0 ?imu-b) ) ) 


?status-y 


under) ) 


(defrule two-level-acc-cant-vote 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

Neither A nor B is the ACC reference IMU 
Acc comparison has not voted yet 

Vote 0 for both IMUs A and B. 


(sub-phase imu error-isolation) 
(engaged-system pass) 


IF 


THEN 

END 


AND 

AND 

AND 


3:) 


(isolate ?pair) 

(excluded-lru ’pair ?imu-c) 
(ref-imu-acc ?imu-c) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
( not ( imu-vote acc $ ? ) ) 

=> 

(assert (imu-vote acc 0 ?imu-a)) 
(assert (imu-vote acc 0 ?imu-b))) 


ZZ (defrule partial-imu-velocity 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

IMU C velocity is valid 

IMU A's velocity comparisons with IMUs B and C is some 
status (call it status-a) 

IMU B's velocity comparisons with IMUs A and C is some 
status (call it status-b) 

Partial IMU velocity comparison has not voted yet 

When status-a = status-b, vote 0 for both IMUs A and B. 

Otherwise, vote 1 for the IMU with the larger difference, and 
0 for the other IMU. 


(sub-phase imu error-isolation) 

(engaged-system pass) 

(isolate ?pair) 

(excluded-lru ?pair ?imu-c) 

(is-imu-valid ?imu-c vel valid) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 

(imu-vel ?imu-a ?status-a) 

(imu- vel ?imu-b ?status-b) 

(not (imu-vote partial-imu-vel $?)) 

=> 

(bind ?vote-a 0) 

(bind ?vote-b 0) 

(if (neq ?status-a ?status-b) 
then 

(if (neq ?status-a under) 
then 

(bind ?vote-a 1) 

else 

(bind ?vote-b 1))) 

(assert (imu-vote partial-imu-vel ?vote-a ?imu-a)) 
(assert (imu-vote partial-imu-vel ?vote-b ?imu-b))) 


t / 
t } 
t / 
f f 
f } 

i i 

} r 
} } 
} r 

t } 
r } 
f f 
f f 
/ r 
i t 


IF 


THEN 


END 


(defrule partial-imu-attitude 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 


40 


THEN 


END 


level 

IMU C attitude is valid 

IMU A's attitude comparisons with IMUs B and C is some 
status (call it status-a) 

IMU B's attitude comparisons with IMUs A and C is some 
status (call it status-b) 

Partial IMU attitude comparison has not voted yet 

When status-a = status-b, vote 0 for both IMUs A and B. 

Otherwise, vote 1 for the IMU with the larger difference, and 
0 for the other IMU. 


(sub-phase imu error-isolation) 

(engaged-system pass) 

(isolate ?pair) 

(excluded-lru ?pair ?imu-c) 

( is-imu-valid ?imu-c att valid) 

( lrus-in-pair ?pair ?imu-a ?imu-b) 

(imu-att ?imu-a ?status-a) 

(imu-att ?imu-b ?status-b) 

(not (imu-vote partial-imu-att $?)) 

= > 

(bind ? vote- a 0) 

(bind ?vote-b 0) 

(if (neq ?status-a ?status-b) 
then 

(if (neq ?status-a under) 
then 

(bind ?vote-a 1) 

else 

(bind ?vote-b 1))) 

(assert (imu-vote partial-imu-att ?vote-a ?imu-a)) 
(assert (imu-vote partial-imu-att ?vote-b ?imu-b) ) ) 


(defrule partial-imu-acc 


/ i 
f / 

i f 
} r 
} r 
r f 
I t 
r } 
f i 
} } 
r f 

i i 
i } 
i } 

r t 


IF 


THEN 


END 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

IMU C ACC is valid 

IMU A's ACC comparisons with IMUs B and C is some 
status (call it status-a) 

IMU B's ACC comparisons with IMUs A and C is some 
status (call it status-b) 

Partial IMU acceleration comparison has not voted yet 

When status-a = status-b, vote 0 for both IMUs. 

Otherwise, vote 1 for the IMU with the larger difference, and 
0 for the other IMU. 


(sub-phase imu error-isolation) 
(engaged- system pass) 

(isolate ?pair) 

(excluded-lru ?pair ?imu-c) 


41 


(is-imu-valid ?imu-c acc valid) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 

(imu-acc ?imu-a ?status-a) 

(imu-acc ?imu-b ?status-b) 

(not (imu-vote partial-imu-acc $?)) 

= > 

(bind ?vote-a 0) 

(bind ?vote-b 0) 

(if (neq ?status-a ?status-b) 
then 

(if (neq ?status-a under) 
then 

(bind ?vote-a 1) 

else 

(bind ?vote-b 1))) 

(assert (imu-vote partial-imu-acc ?vote-a ?imu-a)) 
(assert (imu-vote partial-imu-acc ?vote-b ?imu-b) ) ) 


(defrule partial-imu-cant-vote 


i r 
f i 

f } 

f f 

r } 
r f 

r f 

i } 

r } 


IF 

The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

IMU C is invalid in velocity, attitude, and ACC AND 
Partial IMU comparison has not voted yet 

THEN 

Vote 0 for IMUs A and B. 

END 


(sub-phase imu error-isolation) 
(engaged-system pass) 

(isolate ?pair) 

(excluded-lru ?pair ?imu-c) 

?imu-c vel invalid) 
?imu-c att invalid) 
?imu-c acc invalid) 
?pair ?imu-a ?imu-b) 
partial-imu $?)) 


( is-imu-valid 
( is-imu-valid 
(is-imu-valid 
(lrus-in-pair 
( not ( imu-vote 


= > 


(assert (imu-vote partial-imu 0 ?imu-a)) 
(assert (imu-vote partial-imu 0 ?imu-b) ) ) 


(defrule two-level-vote-count 


The PASS is engaged 

GND-IMU comparison rules have cast vl votes for an IMU AND 
GND-state comparison rules have cast v2 votes for that IMU AND 
ACC comparison rules have cast v3 votes for that IMU AND 
Partial IMU vel comparison rules have cast v4 votes for that IMU 

Partial IMU att comparison rules have cast v5 votes for that IMU 

Partial IMU acc comparison rules have cast v6 votes for that IMU 

THEN 


42 



Compute vote total for the IMU as vl+v2+v3+v4+v5+v6 . 

END 


(sub-phase imu error-isolation) 
(engaged-system pass) 


( imu-vote 

gnd ?vl ?imu) 



( imu-vote 

state ?v2 ?imu) 



( imu-vote 

acc ?v3 ?imu) 



( imu-vote 

partial- imu-vel 

?v4 

?imu) 

( imu-vote 

partial- imu-att 

?v5 

?imu) 

( imu-vote 

partial-imu-acc 

?v6 

?imu) 


=> 

(bind ? total ( + ?vl ?v2 ?v3 ?v4 ?v5 ?v6 ) ) 

(assert ( imu -vote total ?total ?imu) ) ) 


(defrule two-level-imu-isolation 


The PASS is engaged 

Votes for IMU A exceeded votes for IMU B by 2 or more 
Conclude IMU A has an error. 


(sub-phase imu error-isolation) 
(engaged-system pass) 

(imu-vote total ?vote-a ?imu-a)_ 
(imu-vote total ?vote-b ?imu-b&~?imu-a) 
(test (>= (- ?vote-a ?vote-b) 2)) 

?x <- (imu-quality ?imu-a $?) 

=> 

(retract ?x) 

(assert (imu-quality ?imu-a suspect))) 


IF 


THEN 

END 


(defrule two-level-component-isolation 


The PASS is engaged 

An error between IMUs A and B has been detected at the 2 
level 

IMU A is the one with the problem 

Use the fault matrix to determine the problem with IMU A. 
Notify operator of the problem. 

Clear the miscompare indications for IMU B. 


(sub-phase imu error-isolation) 
(engaged- system pass) 

?y <- (isolate ?pair) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
?x <- (imu-quality ?imu-a suspect) 
(imu-vel ?imu-a ?vel) 

(imu-att ?imu-a ?att) 


IF 


THEN 


END 


43 




(imu-acc ? imu-a ?acc) 

(fault-matrix ^vel ?att ?acc ?fault) 


?fl 

<- 

( imu-vel 

?imu-b 

?vel ) 

?f 2 

<- 

( imu-att 

?imu-b 

?att ) 

?f3 

<- 

( imu-acc 

?imu-b 

?acc) 


=> 

(if (eq ?fault suspect) 
then 

(assert (event pass-imu off-nominal alt 

"IMU " ?imu-a " has an undiagnosable problem")) 

else 

(if (eq ?fault good) 
then 

(assert (event pass-imu off-nominal alt 
"IMU " ?imu-a " is good")) 

else 

(assert (event pass-imu off-nominal alt 

"IMU " ?imu-a " has a " ?fault " error")))) 


( retract 
( assert 

?x) 

(imu-quality ?imu-a ?fault) ) 

( retract 
(assert 

?fl) 

( imu-vel 

?imu-b 

under) ) 

( retract 
(assert 

? f 2 ) 

( imu-att 

?imu-b 

under) ) 

(retract 
( assert 

?f 3 ) 

( imu-acc 

?imu-b 

under) ) 

(retract 

?y) ) 




(defrule two-level-cant-isolate 


The PASS is engaged 

Votes for IMU A did not exceed votes for IMU B by 2 or more 
Votes for IMU B did not exceed votes for IMU A by 2 or more 

Notify operator that the IMU error cannot be isolated. 


(sub-phase imu error-isolation) 

(engaged-system pass) 

?x <- (isolate ?pair) 

(imu-vote total ?vote-a ?imu-a)_ 

(imu-vote total ?vote-b ?imu-b&~?imu-a) 

(test (< (- ?vote-a ?vote-b) 2)) 

( test ( < ( - ?vote-b ?vote-a ) 2 ) ) 

=> 

(assert (event pass-imu off-nominal alt 

"Cannot isolate problem to IMU " ?imu-a " or " ?imu-b) ) 
(retract ?x)) 


IF 


THEN 

END 


(defrule two-level-vote-cleanup 

(sub-phase imu error-isolation) 
(not (isolate $?)) 

?x <- (imu-vote $?) 


44 



=> 

(retract ?x) ) 


(defrule change- imu-quality 


The PASS is engaged 

An IMU was previously diagnosed as having a problem 
That IMU's comparisons now indicate a different diagnosis 
The new indicated diagnosis is a bias, resolver, or drift, 
or no problem at all 

Update the IMU's quality rating to reflect the new diagnosis. 
Notify the operator of the new diagnosis. 


(sub-phase imu error-isolation) 
(engaged-system pass) 

(good-imus ~3) 

(not (isolate $?)) 

?x <- (imu-quality ?imu ?quality) 


( imu-vel 

?imu 

?vel ) 



( imu-att 

?imu 

?att ) 



( imu-acc 

?imu 

?acc ) 



( fault-matrix ?vel ?att ?acc 

Pfault&~?quality ) 

( test ( 

II (eq 

?fault 

bias ) 


(eq 

?f ault 

resolver) 


(eq 

?fault 

drift) 


= > 

(if (eq 

(eq 

?fault 

good ) ) ) 


?fault 

good ) 



then 

( assert 

( event 

pass-imu 

nominal alt 



"IMU " ? 

’imu " is 

good" ) ) 

else 

( assert 

( event 

pass-imu 

off-nominal alt 


"IMU " ?imu " has a " ?fault " error"))) 

(retract ?x) 

(assert (imu-quality ?imu ?fault))) 


IF 


THEN 


END 


(defrule imu-status-lj ght 

(sub-phase imu error-isolation) 

( imu-avail-output ?system ?imu ?availability ) 
(imu-quality ?imu Pquality) 

=> 


(if 

(eq Psystem pass) 


then 

(bind Psubsys 

pass-imu) 


else 

(bind Psubsys 

bfs-imu) ) 

(if 

(eq Pavailability 

avail) 


then 

(bind Pstatus 

? quality ) 


else 

(bind Pstatus 

Pavailability) ) 

(assert (status-light 

Psubsys Pimu Pstatus))) 






; / ; GROUP 

; ; IMU Error Magnitude (3.4. 2. 3) 

i i 

;; This group determines the magnitude of an error on an IMU; i.e., how 

;; much bias, how much drift, how big a resolver error. 

; ; ; CONTROL FACTS 

; (sub-phase imu error-magnitude) 

• ■ ,- CONTAINING GROUP 

,• ,- Inertial Measurement Units 

/ f 

(defrule bias-magnitude 


The PASS is engaged 

IMU A has an accelerometer bias 

IMU B velocity is valid 

IMU C velocity is invalid or IMU A-C compare has a smaller 
difference than the IMU A-B comparison 

Compute the magnitude of the bias using the A-B 
pairwise velocity comparison. 

Notify operator of the magnitude of the bias. 


(sub-phase imu error-magnitude) 

(engaged-system pass) 

(imu-quality ?imu-a bias) 

(lrus-in-pair ?pair-ab ~?imu-a ?imu-b) 

(lrus-in-pair ?pair-ac&~?pair-ab ?imu-a ?imu-c) 

(is-imu-valid ?imu-b vel valid) 

(or (is-imu-valid ?imu-c vel ~valid) 

(test (< (vel-diff ?pair-ac) 

(vel-diff ?pair-ab))) ) 

= > 

(assert (event pass-imu off-nominal alt 

"Bias on IMU " ?imu-a " is " =(bias (vel-diff ?pair-ab)) 
" micro-gs"))) 


IF 


THEN 


END 


(defrule resolver-magnitude 


The PASS is engaged 

IMU A has a resolver error 

IMU B attitude is valid 

IMU C attitude is invalid or IMU A-C compare has 
a smaller difference than the IMU A-B comparison 

THEN 


46 


Compute the magnitude of the resolver error using the A-B 
pairwise attitude comparison. 

Notify operator of the magnitude of the resolver error. 

END 

(sub-phase imu error-magnitude) 

(engaged-system pass) 

(imu-quality ?imu-a resolver) 

(lrus-in-pair ?pair-ab ~?imu-a ?imu-b) 

(lrus-in-pair ?pair-ac& ?pair-ab ?imu-a ?imu-c) 

( is-imu-valid ?imu-b att valid) 

(or (is-imu-valid ?imu-c att ~valid) 

(test (< (att-diff ?pair-ac) 

(att-diff ?pair-ab)))) 

=> 

(assert (event pass-imu off-nominal alt 

"Resolver error on IMU " ?imu-a " is " 

=(resolver (att-diff ?pair-ab)) " degrees"))) 


(defrule initial-misalignment 


The PASS is engaged 

The initial misalignment for IMU A is unknown 
IMU B attitude is valid 

IMU C attitude is invalid or IMU A-C has a lower difference 
than The IMU A-B comparison 

Compute the misalignment of IMU A using the A-B 
pairwise attitude comparison. 

Save the computed misalignment for later drift calculations. 


(sub-phase imu error-magnitude) 

(engaged-system pass) 

?x <- (initial-misalignment ?imu-a unknown) 

(lrus-in-pair ?pair-ab ~?imu-a ?imu-b) 

(lrus-in-pair ?pair-ac&~?pair-ab ?imu-a ?imu-c) 
(is-imu-valid ?imu-b att valid) 

(or (is-imu-valid ?imu-c att ~valid) 

(test (< (att-diff ?pair-ac) 

(att-diff ?pair-ab))) ) 

(current- time ?time) 

=> 

(bind ?resolver (resolver (att-diff ?pair-ab) ) ) 

(retract ?x) 

(assert (initial-misalignment ?imu-a ?resolver ?time) ) ) 


IF 


THEN 


END 


(defrule drift-magnitude 


The PASS is engaged 
IMU A has a drift 

The initial misalignment of IMU A is known 


47 



f f 

i i 
f i 

f f 
t r 
/ f 
/ / 
r } 
/ f 


THEN 


END 


IMU B attitude is valid 

IMU C attitude is invalid or IMU A-C compare has a 
smaller difference than IMU A-B compare 

Compute the magnitude of the drift using the A-B 
pairwise attitude comparison and 
the initial misalignment of A. 

Notify operator of the magnitude of the drift. 


(sub-phase imu error-magnitude) 

(engaged-system pass) 

(imu-quality ?imu-a drift) 

(lrus-in-pair ?pair-ab _?imu-a ?imu-b) 

(lrus-in-pair ?pair~ac& ?pair-ab ?imu-a ?imu-c) 

(is-imu-valid ?imu-b att valid) 

(or (is-imu-valid ?imu-c att ~valid) 

(test (< (att-diff ?pair-ac) 

(att-diff ?pair-ab) ) ) ) 

(current-time ?time) 

(initial-misalignment ?imu-a ?resolver-0 ?time-0) 

=> 

(bind ?resolver (resolver (att-diff ?pair-ab))) 

(bind ?drift (drift ?resolver ?resolver-0 ?time ?time-0)) 
(assert (event pass-imu off-nominal alt 

"Drift on IMU " ?imu-a " is " ?drift " deg/hr" ) ) ) 


; GROUP 

; ; IMU Failure Prediction ( 3 . 4 . 2 . 4 ) 

} r 

; ; This group tries to predict whether IMU RM will take any action on an 

; ; IMU error 

• ; CONTROL FACTS 

; (sub-phase imu failure-prediction) 

; CONTAINING GROUP 
; ; Inertial Measurement Units 

} f 

( def rule three-level- failure-prediction 


Onboard IMU RM is at the 3 level 

Exactly two pairwise differences exceed the fail threshold in 
either velocity or attitude 
A failure has not yet been predicted 

Predict RM will fail the IMU common to the two pairs that 
exceed the threshold and notify the operator. 


(sub-phase imu failure-prediction) 
(imu-sfc 111) 

(rel-imu-comp ?pair-l ?comp over) 


IF 


THEN 


END 


43 


( rel-imu-comp ?pair-2&~?pair-l ~?comp over) 
(rel-imu-comp ?pair-3&~?pair-l&~?pair-2 ?comp ~over) 
(common-lru ?pair-l ?pair-2 ?imu) 

?x <- ( imu-rm-prediction ~fail) 

=> 

(assert (event pass-imu off-nominal alt 

"Predict RM will fail IMU " ?imu) ) 

(retract ?x) 

(assert (imu-rm-prediction fail))) 


(defrule three-level-no-failure-prediction 


Onboard IMU RM is at the 3 level 

All 3 pairwise differences in velocity or attitude exceed the 
fail threshold 

A failure has not yet been predicted 
Predict IMU RM will not take any action. 


(sub-phase imu failure-prediction) 
(imu-sfc 111) 

(rel-imu-comp p-1-2 ?comp over) 
(rel-imu-comp p-1-3 ?comp over) 
(rel-imu-comp p-2-3 ?comp over) 

?x < — (imu-rm-prediction none) 

=> 

(assert (event pass-imu off-nominal alt 
"RM will not fail any IMUs")) 
(retract ?x) 

(assert (imu-rm-prediction inaction))) 


IF 


THEN 

END 


(defrule two-level-failure-prediction 


Onboard IMU RM is at the 2 level 
IMU A is available but not good 
IMU B is available and good 

IMUs A and B differ in velocity or attitude by more than 
some threshold 

A failure has not yet been predicted 

Predict an RM action, and indicate IMU A is the one that needs 
to be failed. 


(sub-phase imu failure-prediction) 

(imu-sfc Oil | 101 | 110) 

( imu- avail-output pass ?imu-a avail) 
(imu-quality ?imu-a ~good) 

( imu- avail-output pass ?imu-b&~?imu-a avail) 


IF 


THEN 


END 



(imu-quality ?imu-b good) 

(lrus-in-pair ?pair ?imu-a ?imu-b) 
(rel-imu-comp ?pair ?comp over) 

?x <- (imu-rm-prediction fail) 

=> 

(assert (event pass-imu off-nominal alt 
"RM needs to fail IMU " ?imu-a)) 
(retract ?x) 

(assert (imu-rm-prediction fail))) 


; / ***************************************************************************** 
; ; ; GROUP 

; ; PASS IMU Recommendations ( 3 . 4 . 3 . 1 ) 

f f 

;; Given the current state of IMUs, this group determines what actions are 

;; required in the PASS. 

• ,• ; CONTROL FACTS 

; (sub-phase imu pass-recommendation) 

; ; ; CONTAINING GROUP 
; ; Inertial Measurement Units 

/ r 

( def rule reselect-imu-with-one-or-three-state-nav 


An IMU is unavailable to the PASS due to deselection 
That IMU is good 

Recommend that IMU be reselected (after O-delta-state if 
3-state nav is still active) . 


(sub-phase imu pass-recommendation) 

( imu- avail-output pass ?imu deselect) 

(imu-quality ?imu good) 

(nav-3-state ?nav-flag) 

=> 

(if (eq ?nav-flag on) 
then 

(assert (recommend pass-imu reselect-imu off-nominal alt 

"After zero delta state, OK to reselect IMU " ?imu)) 

else 

(assert (recommend pass-imu reselect-imu off-nominal alt 
"OK to reselect IMU " ?imu)))) 


IF 


THEN 


END 


(def rule help-imu-dilemma 


IMU RM is in dilemma 

IMU A is available to the PASS and good 
IMU B is available to the PASS and not good 


50 



THEN 

Recommend deselecting IMU B. 

END 

(sub-phase imu pass-recommendation ) 

(imu- dilemma on) 

( imu- avail-output pass ?imu-a avail) 

(imu-quality ?imu-a good) 

( imu- avail-output pass ?imu-b avail) 

(imu-quality ?imu-b ~good) 

= > 

(assert (recommend pass-imu help-imii-dilemma off-nominal alt 
"Resolve IMU dilemma by deselecting IMU " ?imu-b))) 


(defrule cant-help-imu-dilemma 


/ / 


r i 


i / 


IMU RM is in dilemma 

IMU A is available to the PASS 

IMU B is available to the PASS 

Either A and B are both good or A and B are both not good 

THEN 

Notify operator that dilemma cannot be resolved. 

END 


(sub-phase imu pass-recommendation) 
(imu-dilemma on) 

( imu- avail-output pass ?imu-a ~avail) 
( imu- avail-output pass ?imu-b&~?imu-a 


(or 


( not 
=> 


( and 

(imu-quality ?imu-a good) 
(imu-quality ?imu-b good)) 

( and 

(imu-quality ?imu-a ~good) 
(imu-quality ?imu-b ~good))) 
(cant-help-imu-dilemma) ) 


avail ) 


( assert ( cant-help-imu-dilemma ) ) 

(assert (event pass-imu off-nominal alt 

"IMU RM DILEMMA. Don't know which IMU is best."))) 


(defrule end -imu-dilemma 

(sub-phase imu pass-recommendation) 
?x <- (cant-help-imu-dilemma) 

( imu-dilemma of f ) 

=> 

(retract ?x)) 


(defrule incorrect-imu-failure 


IMU A is unavailable to the PASS due to failure 
IMU A is good 






IMU B is available to the PASS 
IMU B is not good 

Notify operator of incorrect RM isolation and recommend 
switching to IMU A. 


(sub-phase imu pass-recommendation) 

(imu- avail-output pass ?imu-a fail) 

(imu-quality ?imu-a good) 

(imu- avail-output pass ?imu-b avail) 

(imu-quality ?imu~b ~good) 

=> 

(assert (recommend pass-imu incorrect-imu-failure off-nominal alt 
"RM failed the wrong IMU; Reselect IMU " ?imu-a 
" and deselect IMU " ?imu-b) ) ) 


THEN 


END 


(defrule deselect-commfaulted-imu 


An IMU is unavailable to the PASS due to commfault 
That IMU has not been deselected 

Recommend deselecting the IMU. 


(sub-phase imu pass-recommendation) 

(imu- avail-output pass ?imu commfault) 

(imu-flag pass deselect ?imu off) 

=> 

(assert (recommend pass-imu deselect-commfaulted-imu off-nominal alt 
"Need to deselect IMU " ?imu))) 


IF 

THEN 

END 


;; ***************************************************************************** 
; ; ; GROUP 

; ; BFS IMU Recommendations ( 3 . 4 . 3 . 2 ) 

} i 

;; Given the current state of IMUs, this group determines what actions 

; ; are required in the BFS . 

CONTROL FACTS 

; (sub-phase imu bfs-recommendation) 

• ; ; CONTAINING GROUP 
; ; Inertial Measurement Units 

/ r 

* * ***************************************************************************** 
(defrule deselect-imu-in-bf s 
; ; IF 

A is not available to the PASS 
A is available to the BFS 
B is available to the BFS 


IMU 

IMU 

IMU 


/ f 


52 




/ / 


THEN 


IMU B is good 

Recommend deselecting IMU A in the BFS. 


} t 

; ; END 

(sub-phase imu bfs- recommendation) 

( imu- avail-output pass ?imu ~avail) 

?x <- (imu- avail-output bfs ?imu ^avail) 

( imu- avail-output bfs ?other-imu&~?imu avail) 

(imu-quality ?other-imu good) 

=> 

(assert (recommend bfs-imu deselect-imu-in-bf s off-nominal alt 
"Recommend deselecting IMU " ?imu " in the BFS"))) 


(defrule no-bfs-imus 


The BFS is on IMU A 

IMU A is unavailable to the PASS 

Neither IMUs B nor C is good and available to the BFS 
Notify operator of IMU shortage in the BFS. 


(sub-phase imu bfs-recommendation) 

(bfs-imu ?imu-a) 

( imu- avail-output pass ?imu-a ~avail) 
(lrus-in-pair ? ?imu-a ?imu-b)~ 
(lrus-in-pair ? ?imu-a ?imu-c&~?imu-b) 
(test (< ?imu-b ?imu-c)) 

( imu- avail-output bfs~ ?imu-b ~avail) 
(imu-quality ?imu-b ~good) 

(imu- avail-output bfs~ ?imu-c ~avail) 
(imu-quality ?imu-c ~good) 

= > 

(assert (event bfs-imu off-nominal alt 
"The BFS is on IMU " ?imu-a 
" and has no other IMUs available" ) ) ) 


IF 

THEN 

END 


(defrule change-bf s-imu-1 


f / 
/ f 

i } 

f i 

i } 
i } 

t t 

i } 

r f 
/ } 
r i 


IF 


THEN 

END 


The BFS is on IMU A 

IMU A is not good 

IMU A is available to the PASS 

IMU B is available to the BFS 

IMU B is good 

Either IMU C is unavailable to the BFS or has a higher number 
than IMU B 

Recommend deselect/reselect IMU A to put the BFS on IMU B. 


53 


(sub-phase imu bfs-recommendation) 

(bfs-imu ?imu-a) 

(imu-quality ?imu-a '’good) 

( imu- avail-output pass ?imu-a_ avail) 

( imu- avail-output bfs ?imu-b&~?imu-a avail) 

(imu-quality ?imu-b good) 

(or ( imu-avail-output bfs ~?imu-a&~?imu-b ~avail) 

(and (imu-quality ?imu-c&~?imu-b&~?imu-a good) 
(imu-avail-output bfs ?imu-c avail) 

(test (< ?imu-b ?imu-c)))) 

=> 

(assert (recommend bfs-imu change-bfs-imu off-nominal alt 
"Recommend deselect-reselect IMU " ?imu-a 
" in the BFS to get it on IMU " ?imu-b) ) ) 


(defrule change-bfs-imu-2 
; ; IF 

f f 
f f 
f f 
t } 

THEN 

r i 

■ ; END 

(sub- phase imu bfs-recommendation) 

(bfs-imu ?imu-a) 

(imu-quality ?imu-a ~good) 

(imu-avail-output bfs ?imu-b&~?imu-a avail) 

(imu-quality ?imu-b good) 

(imu-avail-output bfs~ ?imu-c&~?imu-a&~?imu-b avail) 
(imu-quality ?imu-c ~good) 

(test (< ?imu-c ?imu-b) ) 

=> 

(assert (recommend bfs-imu change-bfs-imu off-nominal alt 
"Recommend deselect-reselect IMUs " ?imu-a " and " 
?imu-c " in the BFS to get it on IMU " ?imu-b) ) ) 


The BFS is on IMU A 
IMU A is not good 

IMU B is available to the BFS and is good 
IMU C is available to the BFS but is not good 

IMU C has a lower number than IMU B 

Recommend deselect/reselect IMUs A and C to put the BFS 
on IMU B. 


54 



3 . 5 State Vectors 



3 


55 




; GROUP (3.5) 

State Vector. 

This group watches the PASS and BFS state vectors. 

; CONTROL FACTS 

(sub-phase state ?) 

; CONTAINING GROUP 
Entry 

***************************************************************************** 


; ; ; FACTS 

(def facts monitoring-state-phases ; These facts define the sequence of 

; sub-phases in the monitoring phase 
; of state vectors 

(first-sub-phase state monitoring quality) 

; The only sub-phase is quality checks 

) 


(deffacts analysis-state-phases ; These facts define the sequence of 

; sub-phases in the analysis phase of 
; state vectors 

(first-sub-phase state analysis delta-state) 

; The first sub-phase is delta-state 
; recommendations 
(next-sub-phase state delta-state bfs-transfer ) 

; The last sub-phase is BFS transfer 
; recommendations 


( 


deffacts last-state-report 


( last-state-report-with-hstd pass unknown 


Initializes facts which 
contain the times when the 
state errors were reported 
and the status that was 
reported. The initial 
0 . 0 ) 


; status is set to "unknown" 
; so the status will be 
,■ reported as soon as it is 
known . 

(last-state-report-with-hstd bfs unknown 0.0) 

( last-state-report-no-hstd unknown 0.0) 

(previous-pass-bfs x unknown) 

(previous-pass-bfs y unknown) 

(previous-pass-bfs z unknown) 


) 




; ; ; GROUP (3.5.1) 

; ; State Error Status 


56 


This group reports the quality of the PASS and 
BFS state vectors 

CONTROL FACTS 

(sub-phase state quality) 

CONTAINING GROUP 
State Vectors 

• * ***************************************************************************** 


(defrule state-error-change 


For the available system 
The HSTD is good AND 

The PASS or BFS worst axis error is different from what 
it was on the previous cycle 

Record the new worst axis status 


(sub-phase state quality) 

( hstd good ) 

( system- available ?system) 

(gnd-state Psystem worst-axis Pstatus) 

Px <- ( last-state-report-with-hstd Psystem ~?status ?) 

=> 

(if (eq Pstatus over) 
then 

(assert (status-light state Psystem no-go)) 

else 

(assert (status-light state Psystem go))) 

(retract Px) 

(assert (last-state-report-with-hstd Psystem Pstatus 0.0))) 


IF 


THEN 

END 


( defrule state-report-state-error 


For the available system 
The HSTD is good AND 

More than 60 seconds has elapsed since the last report 

Report the error on every axis whose status is the same 
as the worst axis 


(sub- phase state quality) 

( hstd good ) 

( system- available Psystem) 

Px <- (last-state-report-with-hstd Psystem Pstatus Plast-time) 


(gnd-state 

Psystem 

u ?u) 


(gnd-state 

Psystem 

v ?v ) 


(gnd-state 

Psystem 

w ?w) 


(gnd-state 

Psystem 

udot 

Pudot) 

(gnd-state 

Psystem 

vdot 

? vdot ) 

(gnd-state 

Psystem 

wdot 

Pwdot ) 


IF 


THEN 


END 


57 


(current-time ?time) 

(test (>= ?time (+ ?last-time 60.0))) 


(eq Pstatus 
then 

under) 

( assert 

(event state nominal alt 


The " Psystem " nav state is go" ) ) 

else 


(if (eq 

?u Pstatus) 


then 

(bind ?e (state-error Psystem u) ) 

(assert (event state nominal alt 

"The " Psystem " U error is " Pe " feet"))) 

(if (eq ?v Pstatus) 
then 

(bind Pe (state-error Psystem v)) 

(assert (event state nominal alt 

"The " Psystem " V error is " Pe " feet"))) 

(if (eq ?w Pstatus) 
then 

(bind Pe (state-error Psystem w) ) 

(assert (event state nominal alt 

"The " Psystem " W error is " Pe " feet"))) 

(if (eq Pudot Pstatus) 
then 

(bind Pe (state-error Psystem udot) ) 

(assert (event state nominal alt 

"The " Psystem " UDOT error is " Pe " feet/sec"))) 
(if (eq Pvdot Pstatus) 
then 

(bind Pe (state-error Psystem vdot)) 

(assert (event state nominal alt 

"The " Psystem " VDOT error is " Pe " feet/sec"))) 
(if (eq Pwdot Pstatus) 
then 

(bind Pe (state-error Psystem wdot)) 

(assert (event state nominal alt 

"The " Psystem " WDOT error is " Pe " feet/sec")))) 

(retract Px) 

(assert ( last-state- report-with-hstd Psystem Pstatus Ptime) ) ) 


( def rule state-pass-bf s-timing-problem 


The HSTD is not good AND 

Both systems are available AND 

The delta time is greater than 0.003 seconds 

Report that there is a timing problem between 
the PASS and BFS 


(sub-phase state quality) 
(hstd ~good) 
(system-available pass) 

( system- avail able bfs) 
(pass-bfs-delta-time over) 
= > 


f f 
f / 


IF 


THEN 


END 


58 




(assert (event state off-nominal alt 

"There is a timing problem between PASS and BFS" ) ) ) 


(defrule state-pass-bf s-error-change 


Both systems are available AND 

There is no timing problem between the PASS and the BFS AND 
The HSTD is not good AND 

The PASS-BFS worst axis error is different from what 
it was on the previous cycle 

Record the new worst axis status 


(sub-phase state quality) 

( system- available pass) 

( system- available bfs) 

(pass-bfs-delta-time under) 

(hstd ~good) 

(pass-bfs worst-axis ?status) 

?x <- ( last-state-report-no-hstd ~?status ?) 

=> 

(retract ?x) 

(assert (last-state-report-no-hstd Pstatus 0.0))) 


IF 


THEN 

END 


( defrule state-report-pass-bf s-error 


/ t 

i i 

/ r 

f i 

f r 

/ f 

i /' 

f r 

f } 

i } 


IF 


THEN 

END 


Both systems are available AND 

There is no timing problem between the PASS and the BFS AND 
The HSTD is not good AND 

More than 60 seconds has elapsed since the last report 
of PASS-BFS errors 

Report the error on every axis whose status is the same 
as the worst axis 


(sub-phase state quality) 

(hstd ~good) 

( system- available pass) 

( system- available bfs) 
(pass-bfs-delta-time under) 

?a <- (last-state-report-no-hstd 
(pass-bfs x ?x) 

y ?y) 

z ?z ) 

xdot ?xdot ) 
ydot ?ydot) 
zdot ?zdot) 

(current-time ?time) 

(test (>- ?time (+ ?last-time 60.0))) 


bfs Pstatus 


(pass-bfs 

(pass-bfs 

(pass-bfs 

(pass-bfs 

(pass-bfs 


= > 

(if (eq Pstatus under) 
then 


Plast-time ) 


5 !) 


(assert (event state nominal alt 

"The" " PASS and BFS are tracking")) 

else 

(if (eq ?x Pstatus) 
then 

(bind ?e (pass-bfs x)) 

(assert (event state nominal alt 
"PASS-BFS X is " ?e " feet"))) 

(if (eq ?y Pstatus) 
then 

(bind Pe (pass-bfs y)) 

(assert (event state nominal alt 
"PASS-BFS Y is " Pe " feet"))) 

(if (eq ?z Pstatus) 
then 

(bind Pe (pass-bfs z)) 

(assert (event state nominal alt 
"PASS-BFS Z is " Pe " feet"))) 

(if (eq Pxdot Pstatus) 
then 

(bind Pe (pass-bfs xdot)) 

(assert (event state nominal alt 

"PASS-BFS XDOT is " Pe " feet/sec"))) 
(if (eq Pydot Pstatus) 
then 

(bind Pe (pass-bfs ydot)) 

(assert (event state nominal alt 

"PASS-BFS YDOT is " Pe " feet/sec"))) 
(if (eq Pzdot Pstatus) 
then 

(bind Pe (pass-bfs zdot)) 

(assert (event state nominal alt 

"PASS-BFS ZDOT is " Pe " feet/sec")))) 

(retract Pa) 

(assert ( last-state-report-no-hstd bfs Pstatus Ptime))) 


; GROUP (3.5.2) 

Delta State Update 

This group determines whether or not a delta state update is 
needed . 

; CONTROL FACTS 

(sub-phase state delta-state) 

; CONTAINING GROUP 
State Vectors 

***************************************************************************** 


(defrule state-need-delta-state 


The HSTD is good AND 
For the engaged system the 

GND-system shows the system is above the update limits 


GO 



THEN 

Request a delta-state update. 

END 

(sub-phase state delta-state) 

( hstd good ) 

(engaged-system ?system) 

(gnd-state ?system worst-axis over) 

(gnd-state ?system worst-velocity ?velocity) 

= > 

(if (|| (eq ?velocity under) (eq Pvelocity zero)) 
then 

(bind ?update-type position-only) 

else 

(bind ?update-type position-and-velocity) ) 
(assert (need-delta-state ?update-type) ) ) 


( def rule state-ok- f or-delta- state 


f } 

i f 

} i 

r / 
/ / 
t i 
r } 


IF 

The HSTD is good AND 
A delta state is needed 

Ground and engaged system runway are the same 

THEN 

Recommend a delta state update 

END 

(sub-phase state delta-state) 

(hstd good) 

(need-delta-state ?update-type) 

(engaged-system ?system) 

(runway ground Prunway) 

(runway ? system Prunway) 

=> 

(assert (recommend state update-xfer off-nominal alt 
"We need a " Pupdate-type 
" update to the " Psystem))) 


(def rule state-not-ok-for-delta-state 


The HSTD is good AND 
A delta state is needed 

Ground and engaged system runway are not the same 

Notify the operator that a delta is needed but 
there is a runway mismatch. 


(sub-phase state delta-state) 

( hstd good ) 

(need-delta-state Pupdate-type) 
(engaged-system Psystem) 

(runway ground ? runway a) 

(runway Psystem ?runwayb&~Prunwaya) 


IF 


THEN 


END 


61 



=> 

(assert (recommend state update-xfer off-nominal alt 

"We need a " ?update-type " update to the " ?system 
" but there is a mismatch in runways ground = " 
?runwaya " " ? system " = " ?runwayb) ) ) 


(defrule state-inhibit- filter-processing 
For the engaged system 

A position and/or velocity delta state is needed AND 
The drag, TACAN, and/or ADTA flags are not inhibited. 

Notify the operator that (sensor) is not inhibited 
and need to be inhibited before the delta state, 
(include item entries) 

NOTE: item entries are as follows: 

Specification number: BFS=50 PASS=51 
TACAN inhibit item 20 

Drag inhibit item 23 

ADTA inhibit item 26 

END 

(sub-phase state delta-state) 

( hstd good ) 

(need-delta-state ?update-type) 

(engaged-system ?system) 

(aif ?system tacan ?status-tacan) 

(aif ?system baro ?status-baro) 

(aif Psystem drag ?status-drag) 

= > 

(if (eq Psystem pass) 
then 

(bind Pspec 51) 
else 

(bind Pspec 50)) 

(if (neq Pstatus-tacan inhibit) 
then 

(assert (event state update-xfer off-nominal alt 
"need to inhibit tacan in the " Psystem 
" to perform a " Pupdate-type "delta state by " 
"executing an item 20 of spec " Pspec))) 

(if (neq Pstatus-baro inhibit) 

then 

(assert (event state update-xfer off-nominal alt 
"need to inhibit baro in the " Psystem 
" to perform a " Pupdate-type "delta state by " 
"executing an item 26 of spec " Pspec))) 

(if (neq Pstatus-drag inhibit) 

then 

(assert (event state update-xfer off-nominal alt 
"need to inhibit drag in the " Psystem 
" to perform a " Pupdate-type "delta state by " 
"executing an item 23 of spec " Pspec)))) 



62 



(defrule state-delta- state-is-in-bf s 


BFS is engaged AND 
Delta-state is in progress AND 

Ground-system errors previously not close to zero AND 
Ground-system errors are now close to zero 

Report that state update is in 


(sub-phase state delta-state) 

(engaged-system bfs) 

?x <- (need-delta-state ?update-type) 

(gnd-state bfs worst-axis ?near-zero) 

(test (< ?near-zero 200)) 

= > 

(assert (event state update-xfer nominal alt 

"delta state " ?update-type " occurred in the bfs")) 
(retract ?x)) 


. ^. ***************************************************************************** 

■ ■ ; GROUP (3.5.3) 

; ; BFS Transfer 

f l 

;; This group checks to see if a transfer to the BFS is needed. 

• ; CONTROL FACTS 

; (sub-phase state bf s-transfer ) 

• ; CONTAINING GROUP 

; ; State Vectors 

r r 

(defrule state-need-transfer 


The HSTD is good AND 

Both systems are available AND 

GND-BFS shows the BFS state is above the update limits AND 
Either the PASS state error is good OR 

The PASS state error status is suspect and the PASS-BFS 
status is suspect or bad AND 
No timing error exist between the PASS-BFS 

Recommend a transfer to the BFS 


(sub-phase state bf s-transfer ) 

( hstd good ) 

( system- available pass) 

(system- available bfs) 

(gnd-state bfs worst-axis over) 
(gnd-state pass worst-axis ?status-a) 
(pass-bfs worst-axis ?status-b) 
(pass-bfs-delta-time under) 


IF 


THEN 

END 


IF 

THEN 

END 


63 



(or (or (test (eq ?status-a zero)) 

(test (eq ?status-a under))) 

(and (test (eq ?status-a suspect)) 

(or (test (eq ?status-b suspect)) 

(test (eq ?status-b over))))) 

=> 

(assert (recommend state bfs-transfer off-nominal alt 
"We" " need a transfer to the BFS" ) ) ) 


defrule state-transfer-in 


PASS-BFS position differences are now close to zero AND 
PASS-BFS position differences were not close to zero previously 

Report that the transfer is in 


(sub-phase state bfs-transfer) 

(pass-bfs x zero) 

(pass-bfs y zero) 

(pass-bfs z zero) 

(previous-pass-bfs x ~zero&_unknown ) 

(previous-pass-bfs y __zero&~unknown) 

(previous-pass-bfs z ~zero&~unknown) 

(not (transfer-occurred)) 

=> 

(assert (event state nominal alt "BFS" " transfer is in")) 
(assert (transfer-occurred))) 




IF 


THEN 

END 


( defrule state-previous-pass-bf s-error-update 


/ / 
/ f 
/ i 
} / 


t / 
t f 


IF 

THEN 

END 


PASS-BFS position differences are different from what 
it was on the previous cycle 

Update the previous PASS-BFS error differences 


(sub-phase state bfs-transfer) 
(pass-bfs x ?x-error) 

(pass-bfs y ?y-error) 

(pass-bfs z ?z-error) 

?x <- (previous-pass-bfs x ~?x-error) 
?y <- (previous-pass-bfs y ~?y-error) 
?z <- (previous-pass-bfs z ~?z-error) 
=> 


(retract ?x ?y ?z) 

(assert (previous-pass-bfs 
(assert (previous-pass-bfs 
(assert (previous-pass-bfs 


x ?x-error) ) 
y ?y-error) ) 
z ?z-error))) 


(defrule 


state-transfer-cleanup 


64 





(sub-phase state bf s-transfer ) 
?x <- (transfer-occurred) 
(pass-bfs x|y|z ~zero) 

=> 

(retract ?x)) 



3 . 6 Three-String State Vectors 


3 


66 


; ; ; GROUP 

; ; Three State Nav (3.6) 

i } 

; ; This section performs checks on the 3-string state vectors, determining 

;; the quality of each vector. It also detects delta-state updates. 

■ / / CONTROL FACTS 

(sub- phase three-state three-state) 

• ; / CONTAINING GROUP 
; ; Entry 

i i 


; ; ; FACTS 


(def facts monitoring- 3 state-phases 


(first-sub-phase three-state 


) 


(deffacts initial-3state-facts 


(state-quality 1 unknown) 
(state-quality 2 unknown) 
(state-quality 3 unknown) 
(nav-3-state on) 

) 


; These facts define the sequence of 
; subphases within the monitoring phase 
; of 3-state nav. 
monitoring three-state) 

,• There is only 1 subphase, called 
; three-state . 


,- These facts represent assumptions 
; about 3-state nav before any data is 
; received . 

; quality of state vector 1 is unknown. 

quality of state vector 2 is unknown. 

; quality of state vector 3 is unknown. 

; 3-state nav is active 


(defrule end-3-state-nav 


3-state nav is active 

A MSBLS measurement has been processed 
Conclude 3-state nav is no longer active 


(sub-phase three-state three-state) 

?x <- (nav-3-state on) 

(filter-flag pass mlsr | mlsa | mlse process) 
= > 

(retract ?x) 

(assert (nav-3-state off))) 


IF 


THEN 

END 


(defrule gnd-to-state-comparison 


IF 


67 



THEN 

END 


3-state nav is active 
The HSTD is good 

A state vector previously had a certain quality rating 
Comparison with the ground indicates a different quality 

Change that state vector's rating to the quality indicated 
by the ground comparison 


(sub-phase three-state three-state) 

(nav-3-state on) 

(hstd good) 

(gnd-3state ?id worst-axis ^status) 

(quality-table ?status equality) 

?x <- (state-quality ?id ~?quality) 

=> 

(assert (status-light three-state ?id equality)) 
(retract ex) 

(assert (state-quality eid equality))) 


( def rule state-to-state-comparison-1 


3-state nav is active 
all 3 IMU's are available 
The hstd is not good 

State A previously had a certain quality rating 
Comparison with states B and C indicates a different 
quality 

Change the quality rating of state A to that indicated by 
comparisons with states B and C. 


(sub-phase three-state three-state) 

(nav-3-state on) 

( good-imus 3 ) 

(hstd ~good) 

(lrus-in-pair epair-ab eimu-a eimu-b) 

(state-state ?pair-ab worst-axis ?status-ab) 
(lrus-in-pair ?pair-ac ?imu-a ?imu-c&~?imu-b) 
(state-state ?pair-ac worst-axis ?status-ac) 
(min-miscompare ?status-ab ?status-ac ?status) 
(quality-table ?status ?quality) 

?x <- (state-quality ?imu-a ~?quality) 

=> 

(assert (status-light three-state ?imu-a ?quality) ) 
(retract ?x) 

(assert (state-quality ?imu-a ?quality))) 


IF 


THEN 


END 


(def rule state-to-state-comparison-2 
IF 


f f 

r r 


3-state nav is active 


68 



2 IMU's are not commfaulted 
The hstd is not good 

State A previously had same rating as State B 
I MU A previously had same rating as IMU B 
State A comparison with State B has a different 
rating 

Change the quality rating of both states A and B 
Notify the operator of inability to tell which 
state is going bad 


(sub-phase three-state three-state) 

(nav-3-state on) 

(good-imus 2) 

(hstd good) 

?x <- (state-quality ?imu-a ~?quality) 

?y <- (state-quality ?imu-b&~?imu-a ?quality) 

(imu-quality ?imu-a ?imu-quality ) 

(imu-quality ?imu-b ? imu-quality ) 

( lrus-in-pair ?pair-ab ?imu-a ?imu-b) 

(state-state ?pair-ab worst-axis ?status-ab) 
(quality-table ?status-ab ?new-quality&~?quality ) 

«> 

(assert (status-light three-state ?imu-a ?new-quality) ) 
(assert (status-light three-state ?imu-b ?new-quality) ) 
(retract ?x ?y) 

(assert (state-quality ?imu-a ?new-quality) ) 

(assert (state-quality ?imu-b ?new-quality) ) 

(assert (event three-state off-nominal alt 

"Unable to isolate which state is going bad, " 
"state " ?imu-a 11 or state " ?imu-b))) 


/ I 
t f 

l i 

f f 

r t 

THEN 

/' / 
i r 

• • END 


(defrule state-to-state-comparison-3 


3-state nav is active 
2 IMU ' s are not commfaulted 
The hstd is not good 

State A previously had same rating as State B 
IMU A previously had a better rating than IMU B 
State A comparison with State B has a different 
rating 

Change State B's quality rating to the new one 
Leave State A's quality rating as it was 


(sub-phase three-state three-state) 
(nav-3-state on) 

(good-imus 2) 

( hstd ~good ) 

(state-quality ?imu-a ?quality) 

?x <- (state-quality ?imu-b& ?imu-a ?quality) 
(imu-quality ?imu-a ?quality-imua) 

(imu-quality ?imu-b ?quality-imub) 


IF 


THEN 


END 


63 


(or (and 
( and 


(test 
(test 
( test 
( test 


(eq 
( neq 
(ec 
( 




?quality-imua good)) 

?quality-imub good))) 

?quality-imua suspect)) 

(eq ?quality-imub bad) 

(eq ?quality-imub unknown))))) 

( lrus-in-pair ?pair-ab ?imu-a ?imu-b) 

(state-state ?pair-ab worst-axis ?status-ab) 
(quality-table ?status-ab ?new-quality&~?quality ) 

= > 

(assert (status-light three-state ?imu~b ?new-quality ) ) 
(retract ?x) 

(assert (state-quality ?imu-b ?new-quality ) ) ) 


(defrule state-to-state-comparison-4 
; ; IF 

/ f 

i i 

/ t 

r t 

l i 

THEN 

f r 

■ ■ END 

(sub-phase three-state three-state) 

(nav-3-state on) 

(good-imus 2) 

( hstd ~good ) 

(state-quality ?imu-a ?quality) 

?x <- (state-quality ?imu-bSt~?imu-a ?quality) 
(lrus-in-pair ?pair-ab ?imu-a ?imu-b) 

(state-state ?pair-ab worst-axis ?status-ab) 
(quality-table ?status-ab ?new-quality&~?quality ) 

=> 

(assert (status-light three-state ?imu-b ?new-quality) ) 
(retract ?x) 

(assert (state-quality ?imu-b ?new-quality ) ) ) 


3-state nav is active 
2 IMU ' s are not commfaulted 
The hstd is not good 

State A previously had same rating as State B 
State A comparison with State B has a different 
rating 

Change State B's quality rating to the new one 
Leave State A's quality rating as it was 


( defrule zero-delta-state-occurred 


3-state nav is active 

A non-zero delta state has not been recommended 
All three pairwise state differences go to zero 

Notify operator that zero-delta-state occurred 


(sub-phase three-state three-state) 
(nav- 3-state on) 

(not (need-delta-state $?)) 

(not (delta-state-occurred)) 


IF 


THEN 

END 


70 


(state-state p-1-2 worst-axis zero) 
(state-state p-1-3 worst-axis zero) 
(state-state p-2-3 worst-axis zero) 

= > 

(assert (event three-state off-nominal alt 

"The " "crew did a zero-delta-state")) 
( assert ( delta-state-occurred ) ) ) 


(defrule delta-state-occurred 


3-state nav is active 

A non-zero delta-state has been recommended 
All three pairwise state differences go to zero 

Notify operator that delta state has been performed 

(sub-phase three-state three-state) 

(nav- 3-state on) 

?x <- (need-delta-state $?) 

(not (delta-state-occurred) ) 

(state-state p-1-2 worst-axis zero) 

(state-state p-1-3 worst-axis zero) 

(state-state p-2-3 worst-axis zero) 

= > 

(assert (event three-state nominal alt 

"Delta-state " "is in the PASS")) 

(assert (delta-state-occurred)) 

(retract ?x) ) 


/ / 
i i 

t } 
t i 

/ i 

t f 


IF 


THEN 


(defrule delta-state-cleanup 

(sub-phase three-state three-state) 
?x <- (delta-state-occurred) 
(state-state ? ? ~zero) 

=> 

(retract ?x) ) 



3 . 7 Drag Altitude 


3 


72 




; ; ; GROUP 

; Drag Altitude (3.7) 

t r 

;; This group monitors drag altitude and recommends (output) 

;; a setting for the drag AIF switch. 

; CONTROL FACTS 

(sub-phase drag ?) 

• ; ; CONTAINING GROUP 
Entry 


t ;***************************************************************************** 


; ; ; FACTS 


(deffacts monitoring-drag-phases / These facts define the sequence of 

; sub-phases within the monitoring 
; phase of drag 

(first-sub-phase drag monitoring watch-flags) 

,■ The first sub-phase watches for change 
; in the value of flag parameters 


(deffacts analysis-drag-phases 


( first-sub-phase drag 


analysis 


) 


These facts define the sequence of 
sub-phases within the analysis phase 
of drag 

recommendation ) 

There is only one sub-phase : recom- 


(def facts initial-drag-facts 

(prev-filter-flag pass 
(prev-filter-flag bfs 

) 


drag 

drag 


; These facts represent assumptions 
; about drag before any data is received 
process ) 

; drag is being processed in the PASS 
process) 

; drag is being processed in the BFS 


.***************************************************************************** 

f 

; ; GROUP 

Drag Flag Status (3.7.1) 

/ 

; This group watches for changes in the drag filter flag 

■ ; CONTROL FACTS 

(sub-phase drag watch- flags) 

; CONTAINING GROUP 
Drag Altitude 

/ 


(defrule drag-filter-flag-changed 


73 



For available systems 

The current value of the drag filter flag is anything but 
off AND 

The value of the flag is different from its previous value 

Conclude that the value has changed 

Notify the operator if the new value is "process" 


(sub-phase drag watch-flags) 

(system-available ?sys) 

(filter-flag ^sys drag ?flag&~off)~ 

?x <- ( prev-f ilter-flag ?sys drag ~?flag) 

=> 

(retract ?x) 

(assert ( prev-f ilter-flag ?sys drag ?flag)) 

(if (eq ?flag process) 
then 

(assert (event drag nominal alt "Processing" " drag")))) 


IF 


THEN 


END 


( def rule drag-end-drag-processing 


For available systems 

The current value of the drag filter flag is off AND 

The previous value is not off AND 

Either 

The altitude is less than 85.2 kft OR 
Baro is being processed 

Conclude drag processing has ended 


(sub-phase drag watch-flags) 

(system-available ?sys) 

(filter-flag ?sys drag off) 

?x <- (prev-f ilter-flag ?sys drag ~off) 

(altitude ?alt) 

(or (test (< ?alt 85200)) 

(filter-flag ?sys baro process | edit ) ) 

«> 

(retract ?x) 

(assert (prev-f ilter-flag ?sys drag off)) 

(assert (event drag nominal alt 

"Processing" " of drag has stopped in " ?sys))) 


IF 


THEN 

END 




; GROUP 

Drag Recommendations (3.7.2) 


This group determines a recommended setting for the drag altitude 
AIF switch 


; ; ; CONTROL FACTS 

; (sub-phase drag recommendation) 


74 



End of Document 


Drag is being forced 

The altitude is less than 85.2 kft 

THEN 

Recommend drag be inhibited 

END 

(sub-phase drag recommendation) 

( system- available ?sys) 

(aif ?sys drag force) 

(altitude ?alt) 

(test (<= ?alt 85200)) 

= > 

(assert (recommend drag inhibit-drag off-nominal alt 

"We" " are below 85.2 kft; Recommend inhibiting drag in the " ?sys)) 


7G 


PRECEDING PAGE BLANK NOT FILMED 


3.8 


Tactical Air Navigation 



; GROUP 

TACAN (3.8) 

This group watches the TACAN systems to determine whether 
TACAN data is useable, which LRUs are good, and which 
ground station should be used. 

; CONTROL FACTS 

(sub-phase tacan ?) 

; CONTAINING GROUP 
Entry 


; ; i FACTS 

(deffacts monitoring-tacan-phases These facts define the 

,■ sequence of sub-phases in the 
; monitoring phase of TACAN 
(first-sub-phase tacan monitoring configuration) 

First is a check of the 
; onboard configuration 

(next-sub-phase tacan configuration availability) 

; Then comes a check for LRU 
; availability 

(next-sub-phase tacan availability quality-rating) 

; Then comes a check on quality 
(next-sub-phase tacan quality-rating quality) 


( next-sub-phase 

tacan 

quality 

watch- flags) 

) 



; Last is a flag-status check 

(deffacts analysis-tacan- 

-phases 


; These facts define the 
; sequence of sub-phases in the 
analysis phase of TACAN 

( first-sub-phase 

tacan 

analysis 

toggle) 




First is a check to see if 
; a toggle is necessary 

( next-sub-phase 

tacan 

toggle deselect) 




; Next is a check to see which 
; LRUs need to be deselected 

( next-sub-phase 

tacan 

deselect 

clean-up) 




Next is a fact-base clean-up 

( next-sub-phase 

tacan 

clean-up 

reselect) 




; Next is a check to see which 
,• LRUs need to be reselected 

( next-sub-phase 

tacan 

reselect 

aif -change) 


) 


; Last is a determination of 
the best AIF setting 


(deffacts initial-tacan-facts 


( tacan-status pass 1 
(tacan-status pass 1 


range avail) 
bearing avail) 


These facts represent 
; assumptions about TACAN 
before any data is received 
LRU 1 range available in PASS 
LRU 1 bear available in PASS 


( tacan-status 

pass 

2 

range 

avail) 

LRU 

2 

range 

available in 

PASS 

( tacan-status 

pass 

2 

bearing avail) 

LRU 

2 

bear 

available in 

PASS 

(tacan-status 

pass 

3 

range 

avail) 

LRU 

3 

range 

available in 

PASS 

(tacan-status 

pass 

3 

bearing avail) 

LRU 

3 

bear 

available in 

PASS 

( tacan-status 

bfs 

1 

range 

avail ) 

LRU 

1 

range 

available in 

BFS 

( tacan-status 

bfs 

1 

bearing 

avail) 

; LRU 

1 

bear 

available in 

BFS 

( tacan-status 

bfs 

2 

range 

avail) 

; LRU 

2 

range 

available in 

BFS 

( tacan-status 

bfs 

2 

bearing 

avail ) 

; LRU 

2 

bear 

available in 

BFS 

( tacan-status 

bfs 

3 

range 

avail ) 

; LRU 

3 

range 

available in 

BFS 

( tacan-status 

bfs 

3 

bearing 

avail) 

; LRU 

3 

bear 

available in 

BFS 


1 

1 

2 

2 

3 

3 


range none) 
bearing none) 
range none) 
bearing none) 
range none) 
bearing none) 
-999) 

-999) 

-999) 
range off) 
bearing off) 


1 

2 

3 


( tacan-lru-quality 
( tacan-lru-quality 
( tacan-lru-quality 
( tacan-lru-quality 
( tacan-lru-quality 
( tacan-lru-quality 
( prev-tacan-channel 
( prev-tacan-channel 
( prev-tacan-channel 
( prev-tacan-lock 
( prev-tacan-lock 
( prev-filter-flag 
(prev-filter-flag 
( prev-filter-flag 
(prev-filter-flag 
(prev-data-good pass 
(prev-data-good pass 
(prev-data-good bfs 
(prev-data-good bfs 
( last-tacan-quality 
( last-tacan-quality 
( last-tacan-quality 
( last-tacan-quality 
( last-tacan-quality 
( last-tacan-quality 
(selected-channel 0) 
(error-before-tacan unknown) 


pass 

pass 

bfs 

bfs 


tacr 

tacb 

tacr 

tacb 


off) 

off) 

off) 

off) 


tacr 

tacb 

tacr 

tacb 


1 

1 

2 

2 

3 

3 


off) 

off) 

off) 

off) 


range unknown ) 
bearing unknown) 
range unknown ) 
bearing unknown) 
range unknown ) 
bearing unknown) 


( selected-tacan range no-go) 

( selected- tacan bearing no-go) 


no rating yet on LRU 1 range 
no rating yet on LRU 1 bearing 
no rating yet on LRU 2 range 
no rating yet on LRU 2 bearing 
no rating yet on LRU 3 range 
no rating yet on LRU 3 bearing 
LRU 1 channel number not known 
LRU 2 channel number not known 
LRU 3 channel number not known 
no range locked on yet 
no bearing locked on yet 
PASS is not processing range 
PASS is not processing bearing 
BFS is not processing range 
BFS is not processing bearing 
range data-good off in PASS 
bearing data-good off in PASS 
range data-good off in BFS 
bearing data-good off in BFS 
LRU 1 previous range quality 
;LRU 1 previous bearing uality 
LRU 2 previous range quality 
;LRU 2 previous bearing uality 
LRU 3 previous range quality 
;LRU 3 previous bearing uality 
Actual TACAN channel unknown 
Status of the state error 
before TACAN processing is 
unknown 

Selected range is not yet good 
Selected brng is not yet good 


************★****★*★****★****★*★★**★*****★★*★★*★*★★**★★***★★*■***★************ 

; GROUP (3.8.1) 

TACAN Channel Configuration 

This group makes sure all LRUs are tuned to the correct channel. 

! CONTROL FACTS 

(sub-phase tacan configuration) 

; CONTAINING GROUP 
TACAN 

***************************************************************************** 


79 


(defrule tacan-skip-tacan 


The wrong runway is selected in the engaged system 
Disable the rest of the TACAN checks 


?x <- (sub-phase tacan configuration) 
(runway desired ?slot) 
(engaged-systern_?sys ) 

(runway ?sys ?slot) 

=> 

(retract ?x) ) 


/ t 

r i 
i r 
r i 
i r 


IF 

THEN 

END 


(defrule tacan-channel-changed 


/ / 
f f 


f f 
/ f 
f f 


IF 

THEN 

END 


All LRUs are tuned to a different channel than before 
Notify operator of the change in selected channel 


(sub-phase tacan configuration) 
(tacan-channel 1 ?channel) 
(tacan-channel 2 ?channel) 
(tacan-channel 3 ?channel) 

?x <- (selected-channel ~?channel 
= > 


) 


( assert ( tacan-status-changed ) ) 

(retract ?x) 

(assert (selected-channel ?channel)) 

(assert (event tacan nominal alt 

"TACAN is now on channel " ?channel))) 


( defrule tacan-toggle-tacan-due-to-wrong-channel 


IF 


THEN 

END 


For the engaged system 

The selected channel is not the desired channel 
The selected channel is in the correct area of the 
site table 

Recommend toggle TACAN to get to the desired channel 
Indicate that tacan is no-go for the engaged system 


(sub-phase tacan configuration) 

(engaged-system ?sys) 

(selected-channel ?channel& 0) 

( desired-channel ?desired&~?channel ) 
(desired-tacan ?slot) 

(same-area ?slot ?other-slot) 

(test (= ?channel ( lookup-tacan ?other-slot) ) ) 
=> 

(assert (status-light tacan ?sys no-go)) 


80 


(assert ( recommend tacan toggle-tacan off-nominal alt 

"Need to toggle TACAN to get on channel " ?desired))) 


(defrule tacan-gpc-mode 


f t 
t / 
f f 
r / 
f } 

/ i 

f f 


/ / 
r i 


IF 


THEN 

END 


For the engaged system 

The selected channel is not the desired channel 
The selected channel it not in the correct area of the 
site table 

Recommend the TACANs be put in GPC mode 

Indicate that TACAN is no-go for the engaged system 


(sub-phase tacan configuration) 

(engaged-system ?sys) 

(selected-channel ?channel&~0) 

(desired-channel ?desired&~?channel ) 

(desired-tacan ?slot) 

(same-area ?slot ?other-slot) 

(test (! (= ?channel ( lookup-tacan Pother- s lot ))) ) 

= > 

(assert (status-light tacan ?sys no-go)) 

(assert (recommend tacan gpc-mode off-nominal alt 
"Need" " to put the TACANs in GPC mode"))) 


(defrule tacan-fix-lru-channel 


For the engaged system 

One LRU is not tuned to the desired channel 

At least one other LRU is tuned to the desired channel 

Recommend the mis-tuned LRU be put in GPC mode 
Indicate that TACAN is no-go for the engaged system 


(sub-phase tacan configuration) 

(engaged-system ?sys) 

(desired-channel Pchannel) 

(tacan-channel ?lru~a ~?channel) 

(tacan-channel ?lru-b Pchannel) 

=> 

(assert (status-light tacan ?sys no-go)) 

(assert (recommend tacan gpc-mode off-nominal alt 
"Need to put TACAN " ?lru-a " in GPC mode"))) 


IF 


THEN 


END 


(defrule tacan-config-is-good 


For the engaged system 

All three LRUs are tuned to the desired channel 

THEN 


81 



The TACAN configuration is good 

END 

(sub-phase tacan configuration) 
(engaged-system ?sys) 

(desired-channel ?channel) 

( tacan-channel 1 ?channel) 

(tacan-channel 2 ?channel) 

(tacan-channel 3 ?channel) 

= > 

(assert (status-light tacan ?sys go))) 




; ; ; GROUP 

;; TACAN Availability (3.8.2) 

f / 

; ; This group determines which LRUs are available in the engaged system. 

;; It also determines why the unavailable LRUs are unavailable. 

■ ■ ; CONTROL FACTS 

; (sub-phase tacan availability) 


; ; ; CONTAINING GROUP 
/ ; TACAN 




(defrule tacan-commf ault 


For the engaged system 

A TACAN LRU was not previously commfaulted or powered down 
The commfault flag for that LRU is now on 

Notify the operator that the LRU is commfaulted (unless the 
whole string is down) 

Conclude that range and bearing from the LRU are no longer 
available due to commfault 


(sub-phase tacan availability) 

(engaged- system ?sys) 

?x <- ( tacan-status ?sys ?lru range ~commfault&~power-of f ) 

?y <- (tacan-status ?sys ?lru bearing ~commfault&~power-of f ) 
(tacan-flag ?sys commfault ?lru on) 

(string-commfault ?sys ?lru ?string-flag) 

= > 

(if (eq ?string-flag off) 

then 

(assert (event tacan off-nominal alt 

"Commfault TACAN " ?lru " in the " ?sys))) 
(assert (status-light tacr ?lru commfault)) 

(assert (status-light tacb ?lru commfault)) 

(assert ( tacan-status-changed) ) 

(retract ?x) 

(retract ?y) 

(assert (tacan-status ?sys ?lru range commfault)) 


IF 


THEN 


END 


82 


(assert ( tacan-status ?sys ?lru bearing commfault ) ) ) 


(defrule tacan-coirunf ault-clear 


For the engaged system 

A TACAN LRU was previously commfaulted 
The commfault flag for that LRU is now off 

Notify the operator that the commfault has cleared 
(unless) the whole string was down) 

Conclude that the LRU has the status indicated by the 
fail and deselect indicators 


(sub-phase tacan availability) 

(engaged-system ?sys) 

?x <- (tacan-status ?sys ?lru range commfault) 

?y <- (tacan-status ?sys ?lru bearing commfault) 

(tacan-flag ?sys commfault ?lru off) 

(tacan-flag ?sys deselect ?lru ?desel-flag) 

( tacan-fail-f lag ?lru range ?range-fail) 

(tacan-f ail-flag ?lru bearing ?bearing-fail ) 

(prev-string-cf ?sys ?lru ?string-f lag) 

(tacan-lru-quality ?lru range ?range-status ) 
(tacan-lru-quality ?lru bearing ?bearing-status) 

=> 

(if (eq ?string-flag off) 
then 

(assert (event tacan off-nominal alt 

"Commfault clear on TACAN " ?lru " in the " ?sys))) 
(assert ( tacan-status-changed) ) 

(retract ?x) 

(retract ?y) 

(if (eq ?desel-flag on) 
then 

(assert (status-light tacr ?lru deselect)) 

(assert (status-light tacb ?lru deselect)) 

(assert (tacan-status ?sys ?lru range deselect)) 
(assert (tacan-status ?sys ?lru bearing deselect)) 

else 



(if 

(eq ?range- 

•fail on) 






then 







( assert 

( status-light 

tacr 

?lru 

fail) ) 



(assert 

(tacan-status 

?sys 

?lru 

range fail)) 

— 


else 







( assert 

( status-light 

tacr 

?lru 

?range-status ) ) 



( assert 

( tacan-status 

?sys 

?lru 

range avail))) 


(if 

(eq ?bearing-fail on) 






then 







( assert 

( status-light 

tacb 

?lru 

fail) ) 



( assert 

( tacan-status 

?sys 

?lru 

bearing fail)) 



else 





— 


( assert 

( status-light 

tacb 

?lru 

?bearing-status 



( assert 

( tacan-status 

?sys 

?lru 

bearing avail) 



83 



(defrule tacan-deselect 


For the engaged system 

A TACAN LRU has been available in either range 
or bearing 

The deselect flag for that LRU is on 

Notify the operator of crew deselection 
Conclude the LRU is unavailable in range and 
bearing due to deselection 


(sub-phase tacan availability) 

(engaged-system ?sys) 

?x <- ( tacan-status ?sys ?lru range ?range-status ) 

?y <- (tacan-status ?sys ?lru bearing ?bearing-status ) 

(test (|| ( eq ?range-status avail) (eq ?bearing-status avail))) 

(tacan-flag ?sys deselect ?lru on) 

=> 

(assert (event tacan off-nominal alt 

"Crew deselected TACAN " ?lru " in the " ?sys)) 

(assert (status-light tacr ?lru deselect)) 

(assert (status-light tacb ?lru deselect)) 

(assert (tacan-status-changed)) 

(retract ?x) 

(retract ?y) 

(assert (tacan-status ?sys ?lru range deselect)) 

(assert (tacan-status ?sys ?lru bearing deselect))) 


(defrule tacan-power-of f 


For the engaged system 

A TACAN LRU was previously powered on 

The power indicator for that LRU is now off 

Notify the operator that the LRU has lost power 
Conclude the LRU is not available due to loss of power 


(sub-phase tacan availability) 

(engaged-system ?sys) 

?x <- (tacan-status ?sys ?lru range ~power-off) 

?y <- (tacan-status ?sys ?lru bearing ~power-off) 
(tacan-flag ?sys power ?lru off) 

=> 

(assert (event tacan off-nominal alt 
"TACAN " ?lru " has lost power")) 

(assert (status-light tacr ?lru off)) 

(assert (status-light tacb ?lru off)) 

(assert (tacan-status-changed)) 

(retract ?x) 

(retract ?y) 

(assert (tacan-status ?sys ?lru range power-off)) 
(assert (tacan-status ?sys ?lru bearing power-off))) 




84 



(defrule tacan-power-on 


For the engaged system 
A TACAN LRU was previously powered off 
The power indicator for that LRU is now on 

Notify the operator that the LRU has been powered on 
Conclude the LRU has the status indicated by the fail 
and deselect indicators 


(sub-phase tacan availability) 

(engaged-system ?sys) 

?x <- ( tacan-status ?sys ?lru range power-off) 

?y <- (tacan-status ?sys ?lru bearing power-off) 

(tacan-flag system power ?lru on) 

(tacan-flag ?sys deselect ?lru ?desel-flag) 

(tacan-fail-flag ?lru range ?range-fail) 

(tacan-f ail-flag ?lru bearing ?bearing-fail ) 
(tacan-lru-quality ?lru range ?range-status ) 

( tacan-lru-quality ?lru bearing ?bearing-status) 

= > 

(assert (event tacan off-nominal alt 

"TACAN " ?lru " has been powered on")) 

(assert ( tacan-status-changed ) ) 

(retract ?x) 

(retract ?y) 

(if (eq ?desel-flag on) 
then 

(assert (status-light tacr ?lru deselect)) 

(assert (status-light tacb ?lru deselect)) 

(assert (tacan-status ?sys ?lru range deselect)) 
(assert (tacan-status ?sys ?lru bearing deselect)) 

else 

(if (eq ?range-fail on) 
then 



( assert 

( status-light 

tacr 

?lru 

fail) ) 


( assert 

else 

(tacan-status 

?sys 

?lru 

range fail)) 


( assert 

( status-light 

tacr 

?lru 

?range-status ) ) 


(assert (tacan-status 
(if (eq ?bearing-fail on) 
then 

?sys 

?lru 

range avail))) 


(assert 

( status-light 

tacb 

?lru 

fail) ) 


(assert 

else 

(tacan-status 

?sys 

?lru 

bearing fail)) 


(assert 

( status-light 

tacb 

?lru 

?bearing-status ) ) 


( assert 

( tacan-status 

?sys 

?lru 

bearing avail ) ) ) ) ) 


(defrule tacan-failed 


For the engaged system 
A TACAN LRU measurement was available 
The fail flag for that measurement is on 




85 



/ / 
} f 

i i 


f r 


END 


Notify the operator of the failure 

Conclude that the measurement is no longer available 
due to failure 


(sub-phase tacan availability) 

(engaged-system ?sys) 

?x <- ( tacan-status ?sys ?lru ?measurement avail) 

( tacan-f ail-flag ?lru ?measurement on) 

(measurement-name ?name&tacr | tacb ?measurement ) 

= > 

(assert (event tacan off-nominal alt 

"TACAN " ?lru " " ?measurement " failed by RM" ) ) 
(assert (status-light ?name ?lru fail)) 

(assert ( tacan-status-changed ) ) 

(retract ?x) 

(assert (tacan-status ?sys ?lru ?measurement fail))) 


(defrule tacan-reselected 


For the engaged system 

A TACAN LRU has been unavailable due to 
failure or deselect 
The deselect flag for that LRU is off 
Both fail flags for that LRU are off 

Notify the operator of crew reselection 
Conclude the LRU is now available in range and 
bearing 


(sub-phase tacan availability) 

(engaged-system ?sys) 

?x <- (tacan-status ?sys ?lru range ?range-status) 

?y <- (tacan-status ?sys ?lru bearing ?bearing-status) 
(test (|| (eq ?range-status fail) 

(eq ?bearing-status fail) 

(eq ?range-status deselect) 

(eq ?bearing-status deselect))) 

(tacan-flag ?sys deselect ?lru off) 

( tacan-fail-f lag ?lru range off) 

( tacan-fail-f lag ?lru bearing off) 

(tacan-lru-quality ?lru range ?range-quality ) 
(tacan-lru-quality ?lru bearing ? bearing-quality ) 

=> 

(assert (event tacan off-nominal alt 


"Crew reselected 

TACAN 

" ?lru 

" in the " ?sys ) ) 

( assert 

( status-light 

tacr 

?lru 

?range-quality ) ) 

(assert 

( status-light 

tacb 

?lru 

?bearing-quality ) ) 

( assert 

( tacan-status- 

-changed ) ) 


(retract 

?x) 




( retract 

? y) 




( assert 

(tacan-status 

?sys 

?lru 

range avail)) 

(assert 

( tacan-status 

?sys 

?lru 

bearing avail ) ) ) 


IF 


THEN 


END 


f i 


86 


(defrule tacan-locked 


/ f 


f f 

I f 

i r 

f f 

i f 

/' r 


IF 

For the engaged system 

No LRUs were previously locked on 

An LRU is locked on a measurement 

THEN 

Notify the operator that TACAN is locking on 

END 

(sub-phase tacan availability) 

?x <- ( prev-tacan-lock ?measurement off) 

(tacan-lock ?lru ?measurement on) 

= > 

(assert (event tacan nominal alt 

"TACAN " ?lru " is locking onto " Pmeasurement ) ) 
(assert ( tacan-status-changed ) ) 

(retract ?x) 

(assert (prev-tacan-lock Pmeasurement on))) 


(defrule tacan-no-locked 


An LRU was previously locked on a measurement 
No LRU is locked on a measurement 

Nofity the operator that TACAN lost lock 


(sub-phase tacan availability) 

?x <- (prev-tacan-lock ?measurement on) 
(tacan-lock 1 ?measurement off) 

(tacan-lock 2 ?measurement off) 

(tacan-lock 3 ?measurement off) 

=> 

(assert (event tacan nominal alt 

"TACAN lost lock on " ?measurement ) ) 

( assert ( tacan-status-changed ) ) 

(retract ?x) 

(assert (prev-tacan-lock ?measurement off))) 


j ji<• **k1:i(i'ic&1c1ci<ic1t1''kic‘kj('k'k-k'k'kic'ki('k'k'k'k'ki('kiticit'k'k'k'k'k’k'k'k-k-k'k'k'k'k'k'k’k'k'k'k'k'k'k'k'k’k'k'k'k'k'k’k'k'k'k'k’k'k'k'k 

■ ; ; GROUP 

; ; TACAN LRU Quality (3.8.3) 

/ r 

; ; This group checks LRU measurement errors to determine which LRUs 

,■ ; have a problem and what the problem is . 

CONTROL FACTS 

; (sub-phase tacan quality) 

• ; CONTAINING GROUP 

; ; TACAN 


IF 

THEN 

END 


87 


(defrule tacan-cone-of-confusion-on-ignore-bearing 


In the cone of confusion 
THEN 

Ignore bearing measurements 

(declare (salience 10)) 

(sub-phase tacan quality-rating) 

(cone on) 

(assert (temporary-rating 1 bearing none)) 

(assert (temporary-rating 2 bearing none)) 

(assert (temporary-rating 3 bearing none))) 


( defrule tacan-no-quality-due-to-channel-change 


; ; An LRU is tuned to a different channel than it was previously 

; ; THEN 

; ; That LRU has no quality rating for range or bearing 

(declare (salience 10)) 

(sub-phase tacan quality-rating) 

( tacan-channel ?lru ?channel) 

?x <- (prev-tacan-channel ?lru ~?channel) 

= > 

(retract ?x) 

(assert (temporary-rating ?lru bearing none)) 

(assert (temporary-rating ?lru range none)) 

(assert (prev-tacan-channel ?lru Pchannel))) 


( defrule tacan-use-gnd-minus-ob-errors 


; ; The HSTD is good 

; ; THEN 

; i The selected errors for each measurement are the 

; ; GND-Onboard errors 

(declare (salience 9)) 

(sub-phase tacan quality-rating) 

(hstd good) 

(tacan-error ?lru ?measurement slope ?status-s) 

(tacan-error ?lru ?measurement bias ?status-b) 

(tacan-error ?lru ?measurement noise ?status-n) 

=> 

(assert ( selected-tacan-error ?lru ?measurement slope ?status-s)) 
(assert (selected-tacan-error ?lru ?measurement bias ?status-b)) 
(assert (selected-tacan-error ?lru ?measurement noise ?status-n))) 


( defrule tacan-use- relative-errors 



IF 


The HSTD is not good 


; ; THEN 

i ; The selected errors for each measurement are the relative 

; ; errors 

(declare (salience 9)) 

(sub-phase tacan quality-rating) 

(hstd ~good) 

(rel-tac ?pair-a ?measurement ?error ?status-a) 

(rel-tac ?pair-b& ?pair-a ?measurement ?error ?status-b) 
(common-lru ?pair-a ?pair-b ?lru) 

(min-miscompare ?status-a ?status-b ^best-status) 

(not ( selected-tacan-error ?lru ?measurement ?error ?)) 

=> 

(assert (selected-tacan-error ?lru ?measurement ?error 

?best-status) ) ) 


( defrule tacan-no-quality-rating-part-1 


i ; The hstd is good 

; ; For the engaged system 

; ; A TACAN LRU is commfaulted or unlocked in the measurement 

; ; THEN 

; ; Set temporary rating to NONE 

(declare (salience 8)) 

(sub-phase tacan quality-rating) 

(hstd good) 

(engaged- system ?sys) 

(or ( tacan-status ?sys ?lru ?measurement commfault) 

(tacan-lock ?lru ?measurement off)) 

(not (temporary-rating ?lru ?measurement ?)) 

=> 

(assert (temporary-rating ?lru ?measurement none))) 


( defrule tacan-no-quality-rating-part-2 


The HSTD is not good 
For the engaged system 

A measurement from LRU A is commfaulted or unlocked 

The same measurement from LRU B is commfaulted or unlocked 

THEN 

Set temporary rating to none 

(declare (salience 8)) 

(sub-phase tacan quality-rating) 

(engaged- system ?sys) 

(hstd ~good) 

(or (tacan-status ?sys ?lru-a ?measurement commfault) 
(tacan-lock ?lru-a ?measurement off)) 

(or (tacan-status ?sys ?lru-b&~?lru-a ?measurement commfault) 
(tacan-lock ?lru-b&~?lru-a ?measurement off)) 


89 

C-A 



( lrus-in-pair ?pair ?lru-a ?lru-b) 

(excluded-lru ?pair ?lru-desired ) 

(not (temporary-rating ?lru-desired ?measurement ?)) 

(assert (temporary-rating ?lru-desired ?measurement none))) 


( def rule tacan-temporary-quality-for-noise-bias-slope 
; ; IF 

; ; An LRU has a particular rating based on considering 

; ; selected errors of noise, bias, and slope 

; ; THEN 

; ; Conclude that the LRU has that rating 

(declare (salience 7)) 

(sub-phase tacan quality-rating) 

( selected-tacan-error ?lru ?measurement slope ?s-quality) 
(selected-tacan-error ?lru ?measurement bias ?b-quality) 
(selected-tacan-error ?lru ?measurement noise ?n-quality) 

(not (temporary-rating ?lru ?measurement ?)) 

( tacan-quality ?s-quality ?b-quality ?n-quality ?total-quality ) 

= > 

(assert (temporary-rating ?lru ?measurement ?total-quality ) ) ) 


( def rule tacan-determine-lru-rating-part-1 


; ; HSTD is good 

; ; THEN 

; ; Measurement rating = temporary rating 

/ Potential dilemma flag = off 

(declare (salience 6)) 

(sub-phase tacan quality) 

(hstd good) 

?x <- (temporary-rating ?lru ?measurement Prating) 

=> 

(retract ?x) 

(assert ( tacan-lru-quality ?lru Pmeasurement Prating)) 
(assert (potential-dilemma-flag Plru Pmeasurement off))) 


f } 


( def rule tacan-determine-lru-rating-part-2 


For the engaged system 
The HSTD is not good 

All three measurements available and locked 

THEN 

A's measurement rating = better rating (of good, 
suspect, or bad) between temporary ratings for 
AB and AC ' s relative errors 
Potential dilemma flag - off 

(declare (salience 6)) 


90 


(sub-phase tacan quality) 

(engaged-system ?sys) 

(hstd ~good) 

(tacan-status ?sys ?lru-a ?measurement avail) 

(tacan-lock ?lru-a ?measurement on) 

(tacan-status ?sys ?lru-b&~?lru-a ?measurement avail) 
(tacan-lock ?lru-b ?measurement on^ 

(tacan-status ?sys ?lru-c&~?lru-b& ?lru-a ?measurement avail) 
(tacan-lock ?lru-c ?measurement on) 

( lrus-in-pair ?pair-ab ?lru-a ?lru-b) 

(lrus-in-pair ?pair-ac ?lru-a ?lru-c) 

(temporary-rating ?lru-b ?measurement ?rating-b) 
(temporary-rating ?lru-c ?measurement ?rating-c) 

(min-compare ?rating-b ?rating-c ?best) 

(not (potential-dilemma-flag ?lru-a ?measurement ?)) 

?x <- ( tacan-lru-quality ?lru-a ?measurement ?) 

(retract ?x) 

(assert (tacan-lru-quality ?lru-a ?measurement ?best)) 

(assert (potential-dilemma-flag ?lru-a ?measurement off))) 


( def rule tacan-determine-lru-rating-part-3 


For the engaged system 
The HSTD is not good 

Two measurements are available and locked 
Both measurement ' s previous ratings are equal 

THEN 

Measurement rating for both measurements = temporary 
rating for their relative error 
Set potential dilemma flag to ON 

END 

(declare (salience 6)) 

(sub-phase tacan quality) 

(hstd ~good) 

(engaged- system ?sys) 

(tacan-status ?sys ?lru-a ?measurement avail) 

(tacan-lock ?lru-a ?measurement on) 

(tacan-status ?sys ?lru-b&~?lru-a ?measurement avail) 

(tacan-lock ?lru-b ?measurement on) 

(or (tacan-status ?sys ?lru-c&~?lru-b&~?lru-a ?measurement ~avail) 
(tacan-lock ?lru-c&~?lru-b&~?lru-a ?measurement off)) 

?x <- (tacan-lru-quality ?lru-a ?measurement ?rating-a) 

?y <- (tacan-lru-quality ?lru-b ?measurement ?rating-a) 

(not (potential-dilemma-flag ?lru-a ?measurement ?)) 

(not (potential-dilemma-flag ?lru-b ?measurement ?)) 
(temporary-rating ?lru-a ?measurement ?trating-a) 

(temporary-rating ?lru-b ?measurement ?trating-b) 

(retract ?x ?y) 

(assert (tacan-lru-quality ?lru-a ?measurement ?trating-a)) 

(assert (tacan-lru-quality ?lru-b ?measurement ?trating-b)) 

(assert (potential-dilemma-flag ?lru-a ?measurement on)) 

(assert (potential-dilemma-flag ?lru-b ?measurement on))) 


91 


( def rule tacan-determine-lru-rating-part-4 


i For the engaged system 

; The HSTD is not good 

; Two measurements (A + B) are available and locked 

; Measurement A previous rating is better than 

i measurement B previous rating 

; THEN 

; Set measurement A rating = previous measurement A 

; rating 

; Set measurement B rating = temporary rating for the 

; AB relative error 

; Set potential dilemma flag to OFF 

; END 

(declare (salience 6)) 

(sub- phase tacan quality) 

(hstd ~good) 

(engaged-system ?sys) 

(tacan-status ?sys ?lru-a ?measurement avail) 

(tacan-lock ?lru-a ?measurement on) 

(tacan-status ?sys ?lru-b&~?lru-a ?measurement avail) 

(tacan-lock ?lru-b ?measurement on) 

(or (tacan-status ?sys ?lru-c&~?lru-b&~?lru-a ?measurement 'avail ) 
(tacan-lock ?lru-c& ?lru-b& ?lru-a ?measurement off)) 

( tacan-lru-quality ?lru-a ?measurement ?rating-a) 

?x <- (tacan-lru-quality ?lru-b ?measurement ?rating-b) 
(min-miscompare ?rating-a ?rating-b ?rating-a) 

(not (potential-dilemma-flag ?lru-a ?measurement ?)) 

(not (potential-dilemma-flag ?lru-b ?measurement ?)) 
(temporary-rating ?lru-b ?measurement ?status-rel) 

> 

(retract ?x) 

(assert (tacan-lru-quality ?lru-b ?measurement ?status-rel) ) 
(assert ( potential-dilemma- flag ?lru-a Pmeasurement off)) 

(assert (potential-dilemma-flag ?lru-b ?measurement off))) 


( def rule tacan-determine-lru-rating-part-5 


For the engaged system 
The HSTD is not good 

Only measurement A is available and locked 
Measurement A's previous rating = none 
A ' s raw data noise (spread) is greater than 1/2 
RM threshold 

THEN 

A's measurement rating for = Noise 
Set potential dilemma flag to OFF 

END 

(declare (salience 6)) 

(sub-phase tacan quality) 

(hstd ~good) 

(engaged-system ?sys) 


92 



( tacan-status ^sys ?lru-a ?measurement avail) 

(tacan-lock ?lru-a ?measurement on) 

(or (tacan-status ?sys ?lru-b&~?lru-a ?measurement ~avail) 
(tacan-lock ?lru-b&~?lru-a~?measurement off)) 

(or (tacan-status ?sys ?lru-c& ?lru-b&~?lru-a ?measurement ~avail) 
(tacan-lock ?lru-c& ?lru-b& ?lru-a ?measurement off)) 

?x <- ( tacan-lru-quality ?lru-a ?measurement none) 

(selected-error ?lru-a ?measureraent noise o50|over) 

(retract ?x) 

(assert (tacan-lru-quality ?lru-a ?measurement noise)) 

(assert ( potential-dilemma-flag ?lru-a ?measurement off))) 


( defrule tacan-quality-rating-change 


A measurement rating has changed 

THEN 

Notify the operator of the change and potential 
dilemma condition based on the potential 
dilemma flag status 

END 

(declare (salience 5)) 

(sub-phase tacan quality) 

?x <- ( last-tacan-quality ?lru-a ?measurement ?old) 
(tacan-lru-quality ?lru-a ?measurement ?new&~?old) 
(potential-dilemma-flag ?lru-a ?measurement ?flag) 
(measurement-name ?name&tacr | tacb ?measurement) 

(retract ?x) 

(assert (last-tacan-quality ?lru-a ?measurement ?new) ) 
(assert (event tacan off-nominal alt 
"Tacan " ?lru-a ?measurement 

" quality has changed from 11 ?old " to " ?new) ) 
(assert (status-light ?name ?lru-a ?new) ) 

(if (eq ?flag on) 
then 

(assert (event tacan off-nominal alt 

"ONAV can't determine which TACAN LRU" 

" caused the TACAN " ?lru-a " " 
?measurement " quality change" ) ) ) ) 


(defrule tacan-dilemma-cleanup 

(declare (salience 4)) 

(sub-phase tacan clean-up) 

?x <- (potential-dilemma-flag ? ? ?) 


=> 


(retract ?x)) 


i f 


93 


( def rule tacan-temporary- rating-cleanup 

(declare (salience 4)) 

(sub-phase tacan clean-up) 

?x <- (temporary-rating ? ? ?) 


= > 


(retract ?x)) 


;; ***************************************************************************** 
• ; GROUP 

; ; TACAN Filter Flag Changes (3.8.4) 

/ f 

; ; This group watches for changes in the TACAN data-good flags and 

;; filter flags. 

■ ■ ; CONTROL FACTS 

; (sub-phase tacan watch-flags) 

CONTAINING GROUP 
; ; TACAN 




(def rule tacan- filter- flag-changed 


For the engaged system 

The current value of a TACAN filter flag is anything but 
off AND 

The value of the flag is different from its previous value 
Note the new value 

Notify the operator if the new value is "process" 


(sub-phase tacan watch-flags) 

(engaged-system ?sys) 

(filter-flag ?sys ?meas&tacr | tacb ?flag&~off) 

?x <- ( prev-f ilter-f lag ?sys ?meas ~?flag) 
(measurement-name ?meas ?measurement ) 

=> 

(retract ?x) 

(assert ( prev-f ilter-f lag ?sys ?meas ?flag)) 

(if (eq ?flag process) 
then 

(assert (event tacan nominal alt 

"Processing TACAN " Pmeasurement ) ) ) ) 


IF 


THEN 


END 


( def rule tacan-end-measurement-processing 


For the engaged system 

The current value of a TACAN filter flag is off AND 
The previous value is not off AND 


94 



Either 

The corresponding data good flag is off OR 
MSBLS is being processed 

Conclude and indicate that the processing of 
TACAN measurement has ended 


(sub-phase tacan watch-flags) 

(engaged-system ?sys) 

(filter-flag ?sys ?meas&tacr | tacb off) 

?x <- (prev-filter-flag ?sys ?meas ~off) 
(measurement-name ?meas ?measurement ) 

(or (data-good ?sys ?meas off) 

(filter-flag ?sys mlsr ] mlsa | mlse process | edit ) ) 

=> 

(retract ?x) 

(assert (prev-filter-flag ?sys ?meas off)) 

(assert (event tacan nominal alt 

"TACAN " ?measurement " processing turned off " )) 
(assert (status-light ?meas 1 off)) 

(assert (status-light ?meas 2 off)) 

(assert (status-light ?meas 3 off))) 


THEN 


END 


(defrule tacan-data-good- flag-changed 


t r 

t i 
r i 
/' / 
i r 
f i 
f r 


IF 


THEN 

END 


For the engaged system 

The current value of a TACAN data-good flag is different from 
its previous value 

Notify the operator of the new value 


(sub-phase tacan watch-flags) 

(engaged- system ?sys) 

(data-good ?sys ?meass.tacr | tacb ?flag) 

?x <- (prev-data-good ?sys ?meas ~?flag) 

(measurement-name ?meas ?measurement ) 

=> 

(retract ?x) 

(assert (prev-data-good ?sys ?meas ?flag)) 

(assert (event tacan nominal alt 

"TACAN " ?measurement " data-good flag is " ?flag))) 


(defrule tacan-dilemma-occurred 


For the engaged system 

TACAN dilemma flag is on for either measurement 

THEN 

Warn the operator that a TACAN dilemma ocurred 

END 

(sub-phase tacan watch-flags) 

(engaged-system ?sys) 


95 


( tacan-dilemma ?measurement on) 

= > 

(assert (event tacan off-nominal alt 

"TACAN " ?measurement " is in dilemma"))) 


;;***************************************************************************** 
; ; ; GROUP 

; ; Toggle Tacan Recommendations (3.8.5) 

/ / 

; ; This group determines whether or not the TACAN ground station has 

; ; a problem. If so, and if a backup is available, then toggling 

; ; is recommended . 

; ; ; CONTROL FACTS 
; (sub-phase tacan toggle) 

/ ; ; CONTAINING GROUP 
/ ; TACAN 

f f 


( def rule tacan-gnd-station-problem-1 


For the engaged system 

At least 2 LRUs are locked onto the same measurement AND 
All locked LRUs are exhibiting the same problem 

Conclude the ground station has a problem and a toggle 
is needed 


(sub-phase tacan toggle) 

(engaged-system ?sys) 

(tacan-lock ?lru-a Pmeasurement on) 

(tacan-lru-quality ?lru-a ?measurement ?status&noise | bias) 
(tacan-lock ?lru-b&~?lru-a ?measurement on) 

(tacan-lru-quality ?lru-b ?measurement ?status) 

(or (tacan-lock ?lru-c ?measurement off) 

( tacan-status ?sys ?lru-c&~?lru-a&~?lru-b ?measurement ~avail) 
(and (tacan-lock ?lru-c&~?lru-bs~?lru-a Pmeasurement on) 
(tacan-status ?sys ?lru-c Pmeasurement avail) 
(tacan-lru-quality ?lru-c ?measurement ?status))) 

=> 

(assert (event tacan off-nominal alt 

"All locked TACAN LRUs have a " Pmeasurement 
" " Pstatus)) 

( assert ( need-a-toggle ) ) ) 


IF 


THEN 


END 


( defrule tacan-gnd-station-problem-2 


For the engaged system 
Only 1 LRU is available AND 


96 


That LRU is locked AND 
That LRU has an error 

Notify the operator that the ground station has a problem 
Conclude a toggle is needed 


(sub- phase tacan toggle) 

(engaged-system ?sys) 

( tacan-status ?sys ?lru-a ?measurement avail) 

(tacan-lock ?lru-a ?measurement on) 

(tacan-lru-quality ?lru-a ?measurement ?status&noise | bias ) 
(tacan-status ?sys ?lru-b _?measurement avail) 
(tacan-status ?sys ?lru-c& ?lru-b ?measurement ~avail) 

=> 

(assert (event tacan off-nominal alt 

"locked LRU has a " ? measurement " " ?status)) 
(assert ( need-a-toggle) ) ) 


THEN 


END 


( defrule tacan-one-locked-at-130k 


Only one LRU is locked AND 
That LRU has an error AND 

The altitude is less than 130 kft and greater than 5 kft 

Notify the operator that the ground station has a problem 
Conclude a toggle is needed 


(sub-phase tacan toggle) 

(tacan-lock ?lru-a ?measurement on) 

(tacan-lru-quality ?lru-a ?measurement ?status&noise [bias) 
(tacan-lock ?lru-b ~?measurement off) 

(tacan-lock ?lru-c&~?lru-b ?measurement off) 

(altitude ?alt) 

(test (< ?alt 130000) ) 

(test (> ?alt 5000) ) 

=> 

(assert (event tacan off-nominal alt 

"locked LRU has a " ?measurement " " ?status 
" at altitude less than 130k ft")) 

(assert (need-a-toggle))) 


IF 


THEN 


END 


( defrule tacan-none-locked-at-130k 


No LRUs are locked AND 

The altitude is less than 130 kft and greater than 5 kft 

THEN 

Notify the operator that the ground station has a problem 
Conclude a toggle is needed 

END 

(sub-phase tacan toggle) 

(tacan-lock 1 ?measurement off) 


97 



(tacan-lock 2 ?measurement off) 

(tacan-lock 3 ?measurement off) 

(altitude ?alt) 

(test (< ?alt 130000) ) 

(test (> ?alt 5000) ) 

= > 

(assert (event tacan off-nominal alt 

"No LRU's are locked in " ?measurement 
" at altitude less than 130k ft")) 

( assert ( need-a-toggle) ) ) 


(defrule tacan-do-a-toggle 


A toggle is needed AND 
Toggle capability is available 

Request a toggle 


?x <- (need-a-toggle) 

(toggle-available yes) 

(desired-tacan ?current-slot ) 

(same-area ?current-slot ?new-slot) 

= > 

(bind ?channel (lookup-tacan ?new-slot)) 

(retract ?x) 

(assert (recommend tacan toggle off-nominal alt 
"Need" " to toggle TACAN to " ?channel 
" please confirm" ) ) ) 


IF 

THEN 

END 


(defrule tacan-dont-do-a-toggle 


A toggle is needed AND 

Toggle capability is not available 

Don ' t do the toggle 


?x <- (need-a-toggle) 

(toggle- available no) 

= > 

(retract ?x) ) 

■ ; ; GROUP 

;; LRU's for Deselect (3. 8. 6.1) 

/ f 

; ; This group looks at problems with the LRUs to determine which 

; ; ones might need to be deselected . 

■ ; / CONTROL FACTS 

; (sub-phase tacan deselect) 


IF 

THEN 

END 


98 


; / ; CONTAINING GROUP 
;; Deselect TACAN LRU 

} r 

• * **************★*★★*★**★***★* ★***★******★****★***★★****★*★*★***★************** 
( defrule tacan-kill-old-suggestion 


TACAN status has changed AND 

Part of an old deselect suggestion still exists 
Remove that part of the deselect suggestion 


(declare (salience 10)) 
(sub-phase tacan deselect) 

( tacan-status-changed ) 

?x <- (suggested-deselect $?) 
=> 

(retract ?x) ) 


IF 

THEN 

END 


(defrule tacan-dsel-prep-done 


TACAN status has changed AND 
No previous deselect suggestion exists 

Remove the note about the TACAN status changing 


(declare (salience 10)) 
(sub-phase tacan deselect) 

?x <- (tacan-status-changed) 
(not (suggested-deselect $?)) 
=> 

(retract ?x)) 


IF 


THEN 

END 


(defrule tacan-dilemma 


For the engaged system 
TACAN RM is in dilemma AND 
One LRU is known to be bad AND 
Another LRU is known to be good 

THEN 

Try deselecting the bad LRU 

END 

(sub-phase tacan deselect) 

(engaged-system ?sys) 

(tacan-dilemma Pmeasurement on) 

(tacan-status ?sys ?lru-a Pmeasurement avail) 
(tacan-lru-quality ?lru-a Pmeasurement noise | bias) 
(tacan-status ?sys ?lru-b&~?lru-a Rmeasurement avail) 
(tacan-lru-quality ?lru-b Pmeasurement good) 

=> 

(assert ( need-to-deselect ?lru-a) ) ) 




(defrule tacan-two-against-one 


Two LRUs have a problem AND 
The third LRU is good AND 

The problem with the two bad LRUs is such that TACAN RM 
may fail the good LRU 

Try deselecting the two bad LRUs 


(sub-phase tacan deselect) 

( tacan-lru-quality ?lru-a _?measurement bias) 
(tacan-lru-quality ?lru-b&~?lru-a ?measurement bias) 
(tacan-lru-quality ?lru-c ?measurement good) 
(lrus-in-pair ?pair ?lru-a ?lru-b) 

(rel-tac ?pair ?measurement bias under) 

=> 

(assert ( need-to-deselect ?lru-a)) 

(assert (need-to-deselect ?lru-b) ) ) 


IF 


THEN 

END 


(defrule tacan-not-2-locked 


For the engaged system 
2 LRUs are not locked AND 
1 LRU is locked AND 
The data good flag is off AND 

The altitude is less than 130 kft and greater than 5 kft 
Try deselecting the 2 unlocked LRUs 


(sub-phase tacan deselect) 

(engaged-system ?sys) 

(tacan-lock ?lru-a ~?measurement off) 
(tacan-lock ?lru-b&~?lru-a ?measurement off) 
(tacan-lock ?lru-c ?measurement on) 
(tacan-lru-quality ?lru-c ?measurement good) 
(measurement-name ?meas&tacr | tacb ?measurement ) 
(data-good ?sys ?meas off) 

(altitude ?alt) 

(test ( < ?alt 130000) ) 

(test (> ?alt 5000) ) 

= > 

(assert (need-to-deselect ?lru-a)) 

(assert (need-to-deselect ?lru-b))) 


IF 


THEN 

END 


(defrule tacan-noisy-lru 


r f 

/' i 

f r 


IF 

THEN 


An LRU has excessive noise 


100 



Try deselecting that LRU 

END 

(sub-phase tacan deselect) 

( tacan-lru-quality ?lru Pmeasurement noise) 
=> 

(assert ( need-to-deselect ?lru))) 


(defrule tacan-rm-failed-wrong-lru 


For the engaged system 
One LRU has a problem AND 
Another LRU is good AND 
TACAN RM has failed the good one 

Try deselecting the bad one 


(sub-phase tacan deselect) 

(engaged-system ?sys) 

(tacan-lru-quality ?lru-a ?measurement bias | noise) 

( tacan-status ?sys ?lru-b&~?lru-a ?measurement fail) 
(tacan-lru-quality ?lru-b ?measurement good) 

=> 

(assert (need-to-deselect ?lru-a))) 


IF 


THEN 

END 


(defrule tacan-deselect-the-lru-due-to-no-go 


/ f 

} t 
/ / 
/ t 

f r 

/ i 


/ r 


IF 

The selected measurement from RM is not good 
enough to go for tacan 

Deselecting an LRU will remedy the situation 

THEN 

Recommend deselection of the LRU 

END 

(sub-phase tacan deselect) 

(tacan-error ?lru-a ?measurement raw over) 
(tacan-lock ?lru-a ?measurement on) 

(tacan-error ?lrub& ?lru-a ?measurement raw under) 
(tacan-lock ?lru-b ?measurement on) 

(not (need-to-deselect ?lru-a)) 

=> 

(assert (need-to-deselect ?lru-a))) 




; ; ; GROUP 

;; Deselect Configurations (3. 8. 6. 2) 

/ / 

; ; This group takes the initial suggestions from the previous group 

;; and determines which deselect combinations should be tried. Each 


10.1 


;; combination is proposed as a separate configuration. There are 

;; up to seven possible combinations. 

CONTROL FACTS 

; (sub-phase tacan deselect) 

; ; ; CONTAINING GROUP 
i ; Deselect TACAN LRU 

t f 

} * ***************************************************************************** 


( def rule tacan-try-zero-deselects 


r f 

f f 

i } 

f } 
} f 

i f 


IF 

THEN 

END 


Any LRUs have been proposed for deselection 

Propose a configuration where no LRUs are deselected 

(i.e. the onboard configuration is left like it is) 


(sub-phase tacan deselect) 

( need- to-deselect $ ? ) 

= > 

(bind Pconfig (gensym)) 

(assert (number-deselected Pconfig 0)) 

(assert (possible-tacan-configuration Pconfig 1 off)) 

(assert (possible-tacan-configuration Pconfig 2 off)) 

(assert (possible-tacan-configuration Pconfig 3 off))) 


(def rule tacan-try-one-deselect 


f f 

f r 

f f 
i t 
} f 

f i 


IF 

THEN 

END 


An LRU has been proposed for deselection 

Propose a configuration where that LRU is the only one 
deselected 


(sub-phase tacan deselect) 

(need-to-deselect ?lru-a) 

(lrus-in-pair ? ?lru-a ?lru-b)~ 

(lrus-in-pair ? ?lru-a ?lru-c&~?lru-b) 

=> 

(bind Pconfig (gensym)) 

(assert (number-deselected Pconfig 1)) 

(assert (possible-tacan-configuration Pconfig ?lru-a on)) 

(assert (possible-tacan-configuration Pconfig ?lru-b off)) 

(assert (possible-tacan-configuration Pconfig ?lru-c off))) 


(def rule tacan-try-two-deselects 


For the engaged system 

An LRU has been proposed for deselection AND 

Another LRU is not commfaulted, deselected, or powered off 

THEN 

Propose a configuration where both LRUs are deselected 


102 


END 


(sub-phase tacan deselect) 

(engaged-system ?sys) 

(need-to-deselect ?lru-a) 

(lrus-in-pair ? ?lru-a ?lru-b)~ 

( lrus-in-pair ? ?lru-a ?lru-c&~?lru-b) 

( tacan-status ?sys ?lru-b range ~commfault& deselect &~power-of f ) 
=> 

(bind ?config (gensym)) 

(assert (number-deselected ?config 2)) 

(assert (possible-tacan-configuration Pconfig ?lru-a on)) 

(assert (possible-tacan-configuration ?config ?lru-b on)) 

(assert (possible-tacan-configuration ?config ?lru-c off))) 


(defrule tacan-eliminate-duplicate-conf igurations 


Two proposed configurations are identical 
Eliminate one of the proposed configurations 


(declare (salience 5)) 

(sub-phase tacan deselect) 

?xl <- (possible-tacan-configuration ?config-a 1 ?dsel-l) 

?x2 <- (possible-tacan-configuration ?config-a 2 ?dsel-2) 

?x3 <- (possible-tacan-configuration ?config-a 3 ?dsel-3) 

?x4 <- (number-deselected ?config-a $?) 

(possible-tacan-configuration ?config-b&~?config-a 1 ?dsel-l) 
(possible-tacan-configuration ?config-b 2 ?dsel-2) 
(possible-tacan-configuration ?config-b 3 ?dsel-3) 

= > 

(retract ?xl ?x2 ?x3 ?x4)) 


IF 

THEN 

END 


;;***************************************************************************** 
; ■ ; GROUP 

;; Predict Availability and Configuration Data (3. 8. 6. 3 & 3. 8.6.4) 

f f 

; ; This group of rules predicts how TACAN RM will respond to a proposed 

;; deselection configuration. This prediction consists of the bias 

;; and noise on the selected range and bearing measurements, the range 

;; and bearing data good flags, and the range and bearing dilemma 

; ; indicators. 

/ ; ; CONTROL FACTS 

; (sub-phase tacan deselect) 

; ; CONTAINING GROUP 
; ; Deselect TACAN LRU 

/ i 

(defrule tacan-predict-available 


103 


For the engaged system 

An LRU is not deselected in a proposed configuration AND 
That LRU is available in the real world 

Predict that the LRU will be available in the proposed 
configuration 


(sub-phase tacan deselect) 

(engaged-system ?sys) 

( possible-tacan-conf iguration ^config ?lru off) 

( tacan-status ?sys ?lru ?measurement avail) 

= > 

(assert ( predicted-tacan status ?config ?lru ?measurement avail))) 


IF 


THEN 


END 


(defrule tacan-predict-not-available-1 


t f 

i f 
r i 

i f 

f i 
f i 


IF 

An LRU is deselected in a proposed configuration 

THEN 

Predict that the LRU will not be available in the proposed 
configuration 

END 

(sub-phase tacan deselect) 

(possible-tacan-conf iguration Pconfig ?lru on) 

=> 

(assert (predicted-tacan status Pconfig ?lru range not-avail)) 

(assert (predicted-tacan status ?config ?lru bearing not-avail))) 


(defrule tacan-predict-not-available-2 


r f 
r i 

i f 

} f 

t r 
} i 

f i 


IF 

THEN 

END 


For the engaged system 

An LRU is not available in the real world 

Predict that the LRU will not be available in any proposed 
configuration 


(sub-phase tacan deselect) 

(engaged- system ?sys) 

(possible-tacan-conf iguration Pconfig ?lru ?) 

(tacan-status ?sys ?lru Pmeasurement "avail ) 

=> 

( assert 

(predicted-tacan status Pconfig ?lru Pmeasurement not-avail))) 


( defrule tacan-predict-data-good-two-locked 


f i 
i f 


IF 


Two LRUs are available in a proposed configuration AND 


104 



7 t 

t i 
f r 
} } 
} } 


THEN 

END 


Both LRUs are currently locked onto a measurement 

Predict the data good flag for that measurement will be 
on in the proposed configuration 


(sub-phase tacan deselect) 
(predicted-tacan status ?config 
(predicted-tacan status ?config 
(tacan-lock ?lru-a ?measurement 
(tacan-lock ?lru-b ?measurement 
= > 


?lru-a ^’measurement avail) 
?lru-b&~?lru-a Pmeasurement avail) 
on) 
on) 


(assert (predicted-tacan data-good ?config ?measurement on))) 


( def rule tacan-predict-data-good-one-locked 


7 t 

i i 

i j 
7 7 


f 7 
7 7 
7 i 
t 7 


IF 


THEN 

END 


At least one LRU is available in a proposed configuration AND 
That LRU is locked onto a measurement AND 
The two-lock flag for that measurement is off 

Predict the data good flag for that measurement will be 
on in the proposed configuration 


(sub-phase tacan deselect) 

(predicted-tacan status Pconfig ?lru Pmeasurement avail) 
(tacan-lock ?lru Pmeasurement on) 

(two- lock- flag Pmeasurement off) 

=> 

(assert (predicted-tacan data-good Pconfig Pmeasurement on))) 


( def rule tacan-predict-data-good-one-avail 


/ 7 
7 7 
7 7 
7 7 
7 7 
7 7 
7 7 


IF 

THEN 

END 


Only one LRU is available in a proposed configuration AND 
That LRU is locked onto a measurement 

Predict the data good flag for that measurement will be 
on in the proposed configuration 


(sub-phase tacan deselect) 
(predicted-tacan status ?config 
(predicted-tacan status ?config 
(predicted-tacan status ?config 

(tacan-lock ?lru-a Pmeasurement 
=> 


?lru-a Pmeasurement 
?lru-b _?measurement 
?lru-c&~?lru-b 

Pmeasurement 

on) 


avail ) 
not-avail ) 

not-avail ) 


(assert (predicted-tacan data-good ?config Pmeasurement on))) 


(def rule tacan-predict-data-good-of f 


7 7 


IF 


105 



THEN 


f r 

} i 

r } 


No rule has predicted the data good flag for a measurement 
will be on in a proposed configuration 


END 


Predict the data good flag for that measurement will be off 
in the proposed configuration 


(declare (salience -1)) 

(sub-phase tacan deselect) 

(predicted-tacan status Pconfig ? ?measurement ?) 

(not (predicted-tacan data-good ?config ?measurement ?)) 

= > 

(assert (predicted-tacan data-good ?config ?measurement off))) 


(defrule tacan-predict-dilemma 


Exactly two LRUs are available and locked for a measurement 
in a proposed configuration AND 
The relative bias between the two LRUs exceeds the RM 
threshold 

Predict that RM will declare a dilemma in the proposed 
configuration 


(sub-phase tacan deselect) 

(predicted-tacan status Pconfig ?lru-a ?measurement avail) 
(tacan-lock ?lru-a Pmeasurement on) 

(predicted-tacan status Pconfig ?lru-b&~?lru-a ?measurement avail) 
(tacan-lock ?lru-b Pmeasurement on) 

(lrus-in-pair ?pair ?lru-a ?lru-b) 

(excluded-lru ?pair ?lru-c) 

(or (predicted-tacan status ?config ?lru-c Pmeasurement not-avail 
(tacan-lock ?lru-c ?measurement off)) 

( tacan-relative-dif ference ?pair ?measurement bias over) 

=> 

(assert (predicted-tacan dilemma ?config ?measurement on))) 


f f 
f l 

r f 
/ r 
} t 

r r 
i f 
/ / 


IF 


THEN 


END 


( defrule tacan-predict-no-dilemma 


/ r 
} } 
! i 
} } 
} i 
f f 
i f 


IF 

THEN 

END 


No rule has yet predicted that RM will declare a dilemma 
in a proposed configuration 

Predict that RM will not declare a dilemma in the proposed 
configuration 


(declare (salience -1)) 

(sub-phase tacan deselect) 

(predicted-tacan status ?config ? ?measurement ?) 

(not (predicted-tacan dilemma ?config ?measurement ?)) 

=> 

(assert (predicted-tacan dilemma ?config ?measurement off))) 


10(i 


( def rule tacan-predict-error-l-level 


f I 
f f 
r f 
i r 


i r 
f i 
} r 
f r 
f r 


IF 


THEN 

END 


The data good flag is on for a measurement in a proposed 
configuration AND 

One LRU is available and locked AND 

The other two LRUs are either unavailable or unlocked 

Predict the selected measurement bias and noise is the 
same as that of the available LRU 


(sub-phase tacan deselect) 

( predicted-tacan data-good ?config ?measurement on) 
(predicted-tacan status ?config ?lru-a ’measurement 
(tacan-lock ?lru-a ?measurement on) 

(lrus-in-pair ? ?lru-a ?lru-b)_ 

(lrus-in-pair ? ?lru-a ?lru-c&~?lru-b) 

(or (predicted-tacan status ?config ?lru-b 
(tacan-lock ?lru-b ?measurement off)) 

(or (predicted-tacan status ?config ?lru-c 
(tacan-lock ?lru-c ?measurement off)) 

= > 


avail ) 


Pmeasurement avail) 
?measurement ~avail) 


(bind ?bias (tacan-error ?lru-a ?measurement bias)) 

(assert (predicted-tacan bias Pconfig ?measurement ?bias)) 
(bind ?noise (tacan-error ?lru-a Pmeasurement noise)) 

(assert (predicted-tacan noise ?config ?measurement ?noise))) 


( defrule tacan-predict-error-2-level 


The data good flag is on for a measurement in a proposed 
configuration AND 

Two LRU's are available and locked AND 

The other LRU is either unavailable or unlocked 

Predict the selected measurement bias and noise is the 
average of the available LRUs 


(sub-phase tacan deselect) 

(predicted-tacan data-good Pconfig Pmeasurement on) 

(predicted-tacan status Pconfig ?lru-a Pmeasurement avail) 
(tacan-lock ?lru-a Pmeasurement on) 

(predicted-tacan status Pconfig ?lru-b&~?lru-a Pmeasurement avail) 
(tacan-lock ?lru-b Pmeasurement on) 

(lrus-in-pair ?pair ?lru-a ?lru-b) 

(excluded-lru ?pair ?lru-c) 

(or ( predicted-tacan status Pconfig ?lru-c Pmeasurement avail) 
(tacan-lock ?lru-c Pmeasurement off)) 

= > 

(bind ?bias-a (tacan-error ?lru-a Pmeasurement bias)) 

(bind ?bias-b (tacan-error ?lru-b Pmeasurement bias)) 

(bind ?bias (/ (+ ?bias-a ?bias-b) 2.0)) 

(assert (predicted-tacan bias Pconfig Pmeasurement ?bias)) 

(bind ?noise-a (tacan-error ?lru-a Pmeasurement noise)) 


IF 


THEN 


END 


107 


(bind ?noise-b ( tacan-error ?lru-b ?measurement noise)) 

(bind ?noise (/ ( sqrt (+ (* ^noise-a ?noise-a) 

(* ?noise-b ?noise-b))) 2.0)) 

(assert ( predicted-tacan noise ?config Pmeasurement ?noise))) 


( def rule tacan-predict-error-3-level 


t f 

r f 
f } 
/ f 

r f 

r f 


f / 
r f 


IF 


THEN 

END 


The data good flag is on for a measurement in a proposed 
configuration AND 

All LRUs are available and locked for that measurement 

Predict the selected measurement bias and noise is the 
same as what is currently being selected by RM. 


(sub-phase tacan deselect) 
(predicted-tacan data-good ?config 
(predicted-tacan status ?config 1 
(tacan-lock 1 Pmeasurement on) 
(predicted-tacan status ?config 2 
(tacan-lock 2 ?measurement on) 
(predicted-tacan status Pconfig 3 
(tacan-lock 3 Pmeasurement on) 

=> 


Pmeasurement 

on ) 

Pmeasurement 

avail ) 

Pmeasurement 

avail ) 

Pmeasurement 

avail ) 


(bind ?bias (tacan-error 0 ?measurement bias)) 

(assert (predicted-tacan bias ?config Pmeasurement ?bias)) 
(bind ?noise (tacan-error 0 Pmeasurement noise)) 

(assert (predicted-tacan noise Pconfig Pmeasurement ?noise))) 


/ GROUP 

Choose Best Configuration (3. 8. 6. 5) 

This group of rules compares proposed configurations and chooses 
the one that should give the best performance 

} CONTROL FACTS 

(sub-phase tacan deselect) 

; CONTAINING GROUP 

Deselect TACAN LRU 

(def rule tacan-dont-want-dilemma 


/ t 
/ / 
f t 

i f 
r / 
I f 


IF 

THEN 

END 


A proposed configuration will result in a dilemma in either 
measurement 

Veto that configuration 


(sub-phase tacan deselect) 


108 


( predicted- tacan dilemma Pconfig Pmeasurement on) 
=> 

(assert (vetoed Pconfig))) 


(defrule tacan-need-range-data 


A proposed configuration does not have range data 

THEN 

Veto that configuration 

END 

(sub-phase tacan deselect) 

(predicted- tacan data-good Pconfig range off) 

= > 

(assert (vetoed Pconfig))) 


(defrule tacan-dont-have-bearing 


A proposed configuration does not have bearing data 

THEN 

Assume the crosstrack state error under the proposed 
configuration will be the same as the current 
crosstrack state error 

END 

(sub- phase tacan deselect) 

( predicted- tacan data-good Pconfig bearing off) 

=> 

(bind Pbearing-bias (/ (state-error pass w) 200.0)) 

(assert (predicted-tacan bias Pconfig bearing Pbearing-bias)) 
(assert (predicted-tacan noise Pconfig bearing 0.0))) 


(defrule tacan-predict-state-ef feet 


f / 

f i 
r r 
f i 
i r 
i f 


IF 

THEN 

END 


A configuration has not been vetoed 

Predict the effect of the proposed configuration on the 
state error 


(sub-phase tacan deselect) 

(predicted-tacan bias Pconfig range Prange-bias) 
(predicted-tacan noise Pconfig range Prange-noise) 
(predicted-tacan bias Pconfig bearing Pbearing-bias) 
(predicted-tacan noise Pconfig bearing Pbearing-noise) 
(number-deselected Pconfig ?n-desel) 

(not (vetoed Pconfig)) 

= > 

(bind Pel Prange-bias) 

(bind Pe2 Prange-noise) 

(bind Pe3 (* 200.0 Pbearing-bias)) 




(bind 

?e4 ( * 

200.0 

?bearing-noise) ) 

(bind 

?e5 ( * 

5000.0 

?n-desel) ) 


(bind 

’effect 

( sqrt 

(+ (* ?el 

?el) 




(* ?e2 

?e2) 




(* ?e3 

?e3) 




( * ?e4 

?e4 ) ) ) ) 

(bind 

?ef feet 

(+ ?effect ?e5) ) 



(assert ( predicted-tacan state-effect ?config ?effect))) 


(defrule tacan- pick- smallest- state-effect 


r t 

i } 

} r 

} i 
r i 
f f 


IF 

THEN 

END 


One configuration has a smaller predicted state error 
than another 

Veto the configuration with the larger state error 


(sub-phase tacan deselect) 

(predicted-tacan state-effect ?config-a ?effect-a) 
(predicted-tacan state-effect ?config-b ?effect-b) 
(test (< ?effect-a ?effect-b) ) 

=> 

(assert (vetoed ?config-b))) 


(defrule tacan-select-a-configuration 


f f 
f } 
r r 
i f 

t } 


IF 

THEN 


All configurations that are going to be vetoed have been 
vetoed 

Select the only one left as the chosen configuration 


(declare (salience -2)) 

(sub-phase tacan deselect) 

(predicted-tacan state-effect ?config $?) 
(not (vetoed ?config)) 

= > 

(assert (chosen-configuration ?config))) 


(defrule tacan-confirm-a-deselect 


An LRU is deselected in the chosen configuration 
Confirm the deselect suggestion 


(sub-phase tacan deselect) 

(chosen-configuration ?config) 

(possible-tacan-conf iguration ?config ?lru on) 
= > 

(assert ( suggested-deselect ?lru confirmed))) 


i } 
i f 
} r 
r i 
} r 


IF 

THEN 

END 


110 





(defrule tacan-deny-a-deselect 


The initial deselect determination suggested deselecting 
an LRU AND 

That LRU is not deselected in the chosen configuration 
Deny the deselect suggestion 


(sub-phase tacan deselect) 

(chosen-configuration Pconfig) 

(possible-tacan-configuration Pconfig ?lru off) 
(need-to-deselect ?lru) 

= > 

(assert ( suggested-deselect ?lru denied))) 


IF 


THEN 

END 


( defrule tacan-deselect-conf irmed 


A deselect suggestion has been confirmed 
Send the recommendation to the operator 


(declare (salience 1)) 

(sub-phase tacan deselect) 

(suggested-deselect ?lru confirmed) 

= > 

(assert (recommend tacan deselect-tacan off-nominal alt 
"Need to deselect TACAN LRU 11 ?lru))) 


THEN 

END 


(defrule tacan-deselect-shortcut 


An LRU has been suggested for deselection AND 
That suggestion has already been confirmed or denied 

Withdraw the suggestion 


(sub-phase tacan clean-up) 

?x <- (need-to-deselect ?lru) 
(suggested-deselect ?lru $?) 
=> 

(retract ?x)) 


/ f 
} f 

i i 

f f 

} f 
f t 


IF 


THEN 

END 


(defrule tacan-deselect-cleanup 


All work on all deselects has been completed AND 
A temporary fact generated during the deselect determination 


111 





/ / 
f f 
f f 

r f 


THEN 

END 


still exists 
Remove the fact 


(sub-phase tacan clean-up) 

?x <- (possible-tacan-configuration | 
number-deselected | 
predicted-tacan | 
vetoed | 

chosen-configuration $?) 

=> 

(retract ?x) ) 


^. ******************************************************************** 
J GROUP 

; ; Reselect TACAN LRU (3.8.7) 

f f 

; ; This group determines when to recommend reselected a TACAN LRU 

; ; ; CONTROL FACTS 

; (sub-phase tacan reselect) 


; ; i CONTAINING GROUP 
; ; TACAN 


: — / i 


(defrule tacan-reselect-a-tacan 


For the engaged system 

A TACAN LRU is unavailable in a measurement due to 
RM-declared failure or deselect AND 
The LRU is locked and good in range AND 
The LRU is locked and good in bearing 

Recommend reselecting the LRU 


(sub-phase tacan reselect) 

(engaged-system ?sys) 

( tacan-status ?sys ?lru ?measurement fail | deselect ) 
(tacan-lock ?lru range on) 

( tacan-lru-quality ?lru range good) 

(tacan-lock ?lru bearing on) 

(tacan-lru-quality ?lru bearing good) 

=> 

(assert (recommend tacan reselect-tacan off-nominal alt 
"Need to reselect TACAN LRU " ?lru " in the " ?sys))) 


IF 


THEN 

END 


f l 




f t 

: — 7 r i 
/ i 


GROUP 

TACAN AIF Determination (3.8.8) 


112 



; ; This group of rules determines when the TACAN AIF switch should be 

; changed, and what the new value should be. 

• ■ ; CONTROL FACTS 

; (sub-phase tacan aif-change) 

;;; CONTAINING GROUP 
; ; TACAN 


t f 


( def rule tacan-selected-tacan-is-acceptable 


IF 


THEN 

END 


For the engaged system 

The selected measurement was previously no-go 
The measurement error from every available and locked LRU 
is less than the corresponding state error AND 

Change the selected measurement to "go" 


; sub-phase tacan aif-change) 
; engaged- system ?sys) 

’x <- ( selected-tacan 
or (and 


or ( and 


( and 


?measurement no-go) 
error 1 ?measurement 
lock 1 


( tacan 
( tacan 
( tacan-status 
(tacan-lock 1 
( tacan-status 
(tacan-error 2 
(tacan-lock 2 
( tacan-status 
(tacan-lock 2 
(tacan-status 
( tacan-error 3 
(tacan-lock 3 
(tacan-status 
(tacan-lock 3 
( taean-sta tus 


raw 

Pmeasurement on) 

?sys 1 Pmeasurement 
?measurement off) 
?sys 1 ?measurement 
?measurement raw 
Pmeasurement on) 

?sys 2 ?measurement 
?measurement off) 
?sys 2 Pmeasurement 
Pmeasurement raw 
?measurement on) 

?sys 3 Pmeasurement 
?measurement off) 




under) 

avail ) ) 

~avail ) ) 
under) 

avail ) ) 

~avail ) ) 
under ) 

avail ) ) 

~avail ) ) 


=> 


(retract ?x) 

(assert (selected-tacan ?measurement go))) 


( def rule tacan-selected-tacan-is-unacceptable 


For the engaged system 

The selected TACAN measurement was previously "go" AND 
The error from any available and locked LRU is unacceptable 

THEN 

Change the selected measurement to "no-go" 

END 

(sub-phase tacan aif-change) 

(engaged-system ?sys) 

?x <- (selected-tacan ?measurement go) 

(tacan-error ?lru Pmeasurement raw over) 


113 


(tacan-lock ?lru ?measurement on) 

( tacan-status ?sys ?lru ?measurement avail) 

= > 

(retract ?x) 

(assert (selected-tacan ?measurement no-go))) 


(defrule tacan-to-auto 


The pass is engaged 

Range and bearing data good flags are on AND 
No toggle has been requested AND 
No TACAN deselects have been recommended AND 
No delta-state is in work AND 

Selected range and bearing errors are acceptable AND 
Range and bearing edit ratios are less than 1 AND 
TACAN is currently inhibited 

Recommend that TACAN go to AUTO mode 


(sub-phase tacan aif-change) 

(engaged-system pass) 

(data-good pass tacr on) 

(data-good pass tacb on) 

(not ( need-a- toggle ) ) 

(not ( suggested-deselect ? confirmed)) 

(not (need-delta-state $?)) 

(selected-tacan range go) 

(selected-tacan bearing go) 

(edit-ratio pass tacr under) 

(edit-ratio pass tacb under) 

(aif pass tacan inhibit) 

= > 

(assert (recommend tacan tacan-to-auto nominal alt 
"TACAN" " is good and can be placed in AUTO"))) 


( defrule tacan-to-auto-no-bearing 


The pass is engaged 

Range data-good is on AND 

Bearing data-good is off AND 

No toggle has been requested AND 

No TACAN deselects have been requested AND 

No delta state is in work AND 

Selected range error is acceptable AND 

Range edit ratio is less than 1 AND 

TACAN is currently inhibited 

Recommend TACAN be put in AUTO 


(sub-phase tacan aif-change) 
(engaged-system pass) 
(data-good pass tacr on) 


114 






(data-good pass tacb off) 

(not (need-a-toggle) ) 

(not (suggested-deselect ? confirmed)) 

(not (need-delta-state $?)) 

( selected- tacan range go) 

(edit-ratio pass tacr under) 

(aif pass tacan inhibit) 

= > 

(assert (recommend tacan tacan-to-auto nominal alt 
"TACAN" " is good and can be placed in AUTO" ) ) ) 


(defrule tacan-to-auto-end- force 


The pass is engaged 
TACAN is being forced AND 

Range and bearing edit ratios are less than 1 

THEN 

Recommend TACAN be put in auto 

END 

(sub-phase tacan aif-change) 

(engaged-system pass) 

(aif pass tacan force) 

(edit-ratio pass tacr under) 

(edit-ratio pass tacb under) 

=> 

(assert (recommend tacan end- force nominal alt 
"TACAN" " should be returned to AUTO"))) 


(defrule tacan-auto-after-update 


r r 

i i 
i f 
r r 
/' / 
/ / 
/ r 

i i 
/ i 

f } 

i } 

t f 


IF 


THEN 

END 


For the engaged system 

Range and bearing data-good flags are on AND 
No toggle has been requested AND 
No TACAN deselects have been requested AND 
A delta-state is in work AND 

Selected range and bearing errors are acceptable AND 
TACAN is currently inhibited 

Recommend TACAN be put in AUTO after the delta-state 
is complete 


(sub-phase tacan aif-change) 
(engaged-system ?sys) 

(data-good ?sys tacr on) 

(data-good ?sys tacb on) 

(not (need-a-toggle)) 

(not (suggested-deselect ? confirmed)) 
(need-delta-state $?) 

(selected-tacan range go) 
(selected-tacan bearing go) 

(aif ?sys tacan inhibit) 

=> 


115 



(assert (recommend tacan auto-after-update nominal alt 
"TACAN is good and can be put in AUTO after the " 
"delta-state is complete"))) 


defrule tacan-inhibit-bad-tacan 


The pass is engaged 
No delta-state is in work AND 
State error is good or suspect AND 
TACAN is not inhibited AND 

Range edit ratio is greater than 1 
OR 

( Bearing edit ratio is greater than 1 

while vehicle is not in the cone of confusion 

) 

Recommend TACAN be inhibited 


(sub-phase tacan aif-change) 

(engaged-system pass) 

(not (need-delta-state $?))_ 

(gnd-state pass worst-axis ~over) 

(aif pass tacan 'inhibit) 

(or (edit-ratio pass tacr over) 

(and (edit-ratio pass tacb over) 

(cone off) ) ) 

=> 

(assert (recommend tacan inhibit-bad-tacan off-nominal alt 
"TACAN" " should be inhibited"))) 


IF 


THEN 

END 


( defrule tacan-error-bef ore-tacan 


For the engaged system 

At least one LRU is locked in range AND 
Neither range nor bearing is being processed AND 
The status of the state error is different from 
what it was on the previous cycle 

Note the current status of the state error 


(sub-phase tacan aif-change) 
(engaged-system ?sys) 

(prev-tacan-lock range on) 

(filter-flag ?sys tacr 2P rocess ) 
(filter-flag ?sys tacb 'process) 
(gnd-state ?sys worst-axis ?status) 

?x <- (error-bef ore-tacan ~?status) 

=> 

(retract ?x) 

(assert (error-before-tacan Rstatus))) 


IF 


THEN 

END 


116 



(defrule tacan-error-after-tacan 


For the engaged system 
TACAN is being processed AND 

The state error is worse now than before TACAN was processed 
Recommend TACAN be inhibited 


(sub-phase tacan aif-change) 

(engaged-system ?sys) 

(error-before-tacan ?before) 

(filter-flag ?sys tacr | tacb process) 

(gnd-state ?sys worst-axis Rafter&~Rbefore) 

( max-mi scompare ?before Rafter Rafter) 

= > 

(assert (recommend tacan inhibit-bad-tacan off-nominal alt 
"TACAN made the state error worse. It needs to be " 
"inhibited" ) ) ) 


IF 

THEN 

END 


defrule tacan-to-force 


The pass is engaged 

Range and bearing data-good flags are on AND 
No toggle has been requested AND 
No TACAN deselects have been requested AND 
No delta-state is in work AND 

Selected range and bearing errors are acceptable AND 
Either range or bearing edit ratio is greater than 1 AND 
TACAN is not being forced 

Recommend forcing TACAN 


(sub-phase tacan aif-change) 

(engaged-system pass) 

(data-good pass tacr on) 

(data-good pass tacb on) 

(gnd-state pass worst-axis over) 

(not (need-a-toggle) ) 

(not ( suggested-deselect R confirmed)) 

(not (need-delta-state $R)) 

( selected- tacan range go) 

( selected-tacan bearing go) 

(edit-ratio pass tacrjtacb over) 

(aif pass tacan ~force) 

=> 

(assert (recommend tacan force-tacan off-nominal alt 
"TACAN" " is good and should be forced"))) 


IF 


THEN 

END 


117 




3 . 9 Baro Altitude 



3 


118 


*****x********x******************:fc*********;k*x***** ************************** 


GROUP 

Baro Altitude (3.9) 

This group checks baro altitude/ and recommends (output) 
a setting for the baro AIF switch. 

CONTROL FACTS 

(sub-phase baro ?) 

CONTAINING GROUP 
Entry 




i f r 


FACTS 


(deffacts monitoring-baro-phases ,■ These facts define the sequence of 

; sub-phases within the monitoring 
; phase of baro 

(first-sub-phase baro monitoring quality) 

t First sub-phase is quality checks 
(next-sub-phase baro quality flag-status) 

; Then comes flag status 


) 


(deffacts analysis-baro-phases 


(first-sub-phase baro analysis 


) 


These facts define the sequence of 
sub-phases within the analysis 
phase of baro 
recommendation ) 

The only sub-phase is recommendation 


(deffacts initial-baro-facts 
(baro- status unknown) 
(prev-filter-flag pass 

(prev-f ilter-f lag bfs 

) 


; These facts represent assumptions 
; about baro before any data is received 
; The quality of baro measurements is 
,• unknown 
baro off) 

; Baro is not being processed in the 
; PASS 
baro off) 

; Baro is not being processed in the BFS 


. .***************************************************************************** 
l / 

; ■ ; GROUP 

;; Baro Measurement Quality (3.9.1) 

f } 

; This group of rules determines whether or not baro alitude measurements 
;; are good. If they are bad, the rules attempt to determine the reason. 

• ■ ; CONTROL FACTS 
; (sub-phase baro quality) 

; CONTAINING GROUP 


110 



; ; Baro Altitude 

/ i 

( defrule baro-ok-to-perform-baro-checks 

Mach is greater than 5 OR 
in mach jump region 

Do not perform any baro checking 


?x <-( sub-phase baro quality) 

(or (mach- jump on) 

(mach-number ?n&:(> ?n 5.0))) 

= > 

(retract ?x)) 


IF 

THEN 

END 


(defrule baro-is-good-bf s 


For the bfs system 
The HSTD is good 

Baro was previously not known to be good 
|delta-sel| <= |delta-z| + 500 

Baro is good 


(sub-phase baro quality) 

(hstd good) 

?x <- (baro-status good) 

(baro-gnh ?delta-sel) 

(engaged-system bfs) 

(test (<= (abs ?delta-sel) 

(+ (abs (state-error bfs u)) 500.0))) 

=> 

(assert (status-light baro 0 good)) 

(retract ?x) 

(assert (baro-status good))) 


IF 


THEN 

END 


(defrule baro-is-bad-bf s 


For the bfs system 
The HSTD is good 

Baro was previously good or unknown 
|delta-sel| > |delta-z| + 500 

THEN 

Baro is bad 

END 

(sub-phase baro quality) 

( hstd good ) 

?x <- (baro-status ?prev-status&good | unknown) 
(baro-gnh ?delta-sel) 


120 




(engaged-system bfs) 

(test (> (abs ?delta-sel) 

(+ (abs (state-error bfs u)) 500.0))) 

=> 

(assert (status-light baro 0 bad)) 

(if (eq ?prev-status good) 
then 

(assert (event baro off-nominal mach "Air" " data is bad"))) 
(retract ?x) 

(assert (baro-status bad))) 


(defrule baro-is-good-pass 


For the pass system 
The HSTD is good 

Baro was previously not known to be good 
jdelta-selj <- |delta-z| + 500 

Baro is good 


(sub-phase baro quality) 

(hstd good) 

?x <- (baro-status ~good) 

(delta-z ?delta-z) 

(baro-gnh ?delta-sel) 

(engaged-system pass) 

(test (<= (abs ?delta-sel) 

(+ (abs ?delta-z) 500.0))) 

=> 

(assert (status-light baro 0 good)) 
(retract ?x) 

(assert (baro-status good))) 


IF 


THEN 

END 


(defrule baro-is-bad-pass 


For the pass system 
The HSTD is good 

Baro was previously good or unknown 
|delta-sel| > | delta-z | + 500 

Baro is bad 


(sub-phase baro quality) 

( hstd good ) 

?x <- (baro-status ?prev-status&good | unknown) 
(delta-z ?delta-z) 

(baro-gnh ?delta-sel) 

(engaged-system pass) 

(test (> (abs ?delta-sel) 

(+ (abs ?delta-z) 500.0))) 

=> 

(assert (status-light baro 0 bad)) 


IF 


THEN 

END 


121 



(if (eq ?prev-status good) 
then 

(assert (event baro off-nominal mach "Air" " data is bad"))) 
(retract ?x) 

(assert (baro-status bad))) 


(defrule baro-roll-reversal 


Baro is bad 

The vehicle is executing a roll-reversal 
Baro is bad because of roll-reversal 


(sub-phase baro quality) 

?x <- (baro-status bad) 

(roll-rate high) 

=> 

(assert (status-light baro 0 roll)) 

(assert (event baro off-nominal mach 

"Air" " data is bad due to roll reversal")) 

(retract ?x) 

(assert (baro-status roll-reversal))) 


IF 

THEN 

END 


(defrule baro-crew-call 


HSTD is not good 
ADTA is crew call 


(sub-phase baro quality) 

(hstd ~good) 

(not (ADTA crew-call)) 

=> 

(assert (ADTA crew-call)) 

(assert (status-light baro 0 crew)) 

(assert (event baro off-nominal mach 

"Air" " data is crew call"))) 


THEN 

END 


(defrule baro-not-crew-call 


HSTD is good 

ADTA is not crew call 


(sub-phase baro quality) 
(hstd good) 

?x <- (ADTA crew-call) 

=> 


/ / 
f t 

i r 
i f 
i r 


IF 

THEN 

END 


122 


(retract ? x) 

(assert (status-light baro 0 blank)) 

(assert (event baro off-nominal mach 

"Air" " data is not crew call"))) 

/ / / GROUP 

; ; Baro Flag Status (3.9.2) 

f r 

;i This group watches for changes in the baro altitude filter flag. It 

; ; also watches to see if the change is caused by entering or leaving 

;; the Mach jump region. 

• ; / CONTROL FACTS 

; (sub-phase baro flag-status) 

• ■ CONTAINING GROUP 

; / Baro Altitude 

} / 

( t 

l • BARO FLAG STATUS 


(defrule baro-enter-mach- jump 


The vehicle was not previously in the mach jump region 
The vehicle is now in the mach jump region 

Notify the operator that the mach jump region has been entered 


(sub-phase baro flag-status) 

(not ( in-mac h- jump) ) 

(mach- jump on) 

=> 

( assert ( in-mach- j ump ) ) 

(assert (event baro nominal mach "Entering" " Mach jump region"))) 


IF 


THEN 

END 


(defrule baro- leave-mach- jump 


The vehicle was previously in the mach jump region 
The vehicle is now out of the mach jump region 

Notify the operator that the mach jump region has been exited 


(sub-phase baro flag-status) 

?x <- ( in-mach- jump) 

(mach-jump off) 

=> 

(retract ?x) 

(assert (event baro nominal mach "Leaving" " Mach jump region"))) 


IF 

THEN 

END 


123 



( defrule baro-f ilter-f lag-changed 


/ i 

f i 
f i 
f i 

i / 

f t 

f r 
} r 


IF 


THEN 

END 


For the engaged system 

The current value of the baro filter flag 
is different from its previous value 

Conclude that the value has changed 
Notify the operator of the new value 


(sub-phase baro flag-status) 

(engaged-system ?sys) 

(filter-flag ?sys baro ?flag) 

?x <- ( prev-f ilter-f lag ?sys baro ?flag) 

= > 

(retract ?x) 

(assert (prev-f ilter-flag ?sys baro ?flag) ) 
(assert (event baro nominal mach "air data status is 
?flag ) ) ) 




; ; ; GROUP 

; ; Baro Recommendations - Ground Available (3.9.3) 

/ i 

; ; This group recommends a setting for the AIF switch when the ground 

;; state is available. 

• ; CONTROL FACTS 

; (sub-phase baro recommendation) 


; ; ; CONTAINING GROUP 
; ; Baro Altitude 




(defrule baro-to-auto 


For the pass system 
Baro is good 

The baro edit ratio is less than 1 
Baro is inhibited 

Baro is go for nav 


(sub-phase baro recommendation) 

(baro-status good) 

(engaged-system pass) 

(edit-ratio pass baro under) 

(aif pass baro inhibit) 

=> 

(assert (recommend baro baro-to-auto nominal mach 
"Air" " data is go for nav" ) ) ) 


IF 

THEN 

END 


124 



(defrule baro- to- force 


For the pass system 
Baro is good 

The baro edit ratio is greater than 1 
Baro is not being forced 

Recommend forcing baro 


(sub-phase baro recommendation) 

(baro-status good) 

(engaged-system pass) 

(edit-ratio pass ~baro over) 

(aif pass baro force) 

= > 

(assert (recommend baro baro-to-force off-nominal mach 
"Need" " to force air data to nav" ) ) ) 


IF 

THEN 

END 


(defrule baro-end-force 


For the pass system 
Baro is good 

The baro edit ratio is less than 1 
Baro is being forced 

Recommend returning baro to auto 


(sub-phase baro recommendation) 

(baro-status good) 

(engaged-system pass) 

(edit-ratio pass baro under) 

(aif pass baro force) 

=> 

(assert (recommend baro end-baro- force off-nominal mach 
"Need" " to return air data to auto for nav"))) 


IF 


THEN 

END 


(defrule baro-to-inhibit 


For engaged system 
Baro is bad 

The vehicle is not in the Mach jump region 
Baro is not inhibited 

Recommend that baro be inhibited 


(sub-phase baro recommendation) 
(baro-status ~good&~unknown) 
(mach- jump off) 

(engaged-system ?sys) 

(aif ?sys baro inhibit) 


IF 


THEN 

END 


125 


=> 

(assert (recommend baro inhibit-baro off-nominal mach 
"Air" " data is no-go and should be inhibited" ) ) ) 


126 




3 . 10 Microwave Scan Beam Landing System 


3 


127 



/ / ; GROUP 

; ; MSBLS (3.10) 

i t 

;; This group monitors MSBLS data, recommends (output) which 

;; of the three LRUs should be used, and whether MSBLS 

; ; should be used or not . 

/ '; i CONTROL FACTS 
; (sub-phase msbls ?) 

; ; ; CONTAINING GROUP 
; ; Entry 

( f 


; ; ; FACTS 


(def facts monitoring-msbls-phases ; Defines the sequence of 


; sub-phases in the monitoring 
; phase of the MSLBS section. 


( first-sub-phase 

msbls 

monitoring availability) 

; First sub-phase is a check 
; for LRU availability 

( next-sub-phase 

msbls 

availability lockon) 

; Then comes a check for 

lock 

( next-sub-phase 

msbls 

lockon quality) 

; Then comes LRU quality 

check 

( next-sub-phase 

msbls 

quality watch-flags) 



; Last is a flag-status check 


) 


(def facts analysis-msbls-phases ; These facts define the 

,■ sequence of sub-phases in the 
analysis phase of MSBLS 

(first-sub-phase msbls analysis recommendation) 

; First is recommendations 
; based on LRU quality 

(next-sub-phase msbls recommendation watch-state) 

; Last is recommendation based 
; on effects on state error 

) 


( 


deffacts initial-msbls-facts 


(msbls-status 1 avail) 
(msbls-status 2 avail) 
(msbls-status 3 avail) 
(msbls-num- avail 3) 
(msbls-num-locked range 0) 
(msbls-num-locked azimuth 0) 
(msbls-num-locked elevation 
( last-msbls-report 1 range 


( last-msbls-report 1 range 


; These facts represent assumptions 
; about MSBLS before any data is 
; received 

,• LRU 1 is available 

; LRU 2 is available 

,- LRU 3 is available 

; All 3 LRUs are available 

,• No LRUs are locked in range 
; No LRUs are locked in azimuth 
0) ; No LRUs locked in elevation 

bias unknown) 

,• Do not know if LRU 1 range 
,• has a bias 
noise unknown) 


128 


( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 
( last-msbls-report 


( last-msbls-report 


( last-msbls-report 


(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
(msbls-lru-quality 
( error-before-msbls 


,• Do not know if LRU 
,• has a noise 

1 azimuth bias unknown) 

; Do not know if LRU 
; has a bias 

1 azimuth noise unknown) 

Do not know if LRU 
; has a noise 

1 elevation bias unknown) 

; Do not know if LRU 
; has a bias 

1 elevation noise unknown) 

Do not know if LRU 
; has a noise 

2 range bias unknown) 

; Do not know if LRU 
has a bias 

2 range noise unknown) 

; Do not know if LRU 
has a noise 

2 azimuth bias unknown) 

; Do not know if LRU 
; has a bias 

2 azimuth noise unknown) 

; Do not know if LRU 
; has a noise 

2 elevation bias unknown) 

; Do not know if LRU 
; has a bias 

2 elevation noise unknown) 

; Do not know if LRU 
; has a noise 

3 range bias unknown) 

Do not know if LRU 
,• has a bias 

3 range noise unknown) 

; Do not know if LRU 
has a noise 

3 azimuth bias unknown) 

; Do not know if LRU 
; has a bias 

3 azimuth noise unknown) 

; Do not know if LRU 
; has a noise 
unknown ) 

; Do not know if LRU 
; has a bias 
unknown) 

; Do not know if LRU 
has a noise 
; no rating on LRU 1 
; no rating on LRU 1 
; no rating on LRU 1 
; no rating on LRU 2 
; no rating on LRU 2 
; no rating on LRU 2 
; no rating on LRU 3 
no rating on LRU 3 
; no rating on LRU 3 
; state error before 


3 elevation bias 


3 elevation noise 


1 range none) 

1 azimuth none) 

1 elevation none) 

2 range none) 

2 azimuth none) 

2 elevation none) 

3 range none) 

3 azimuth none) 

3 elevation none) 
under) 


1 range 
1 azimuth 
1 azimuth 
1 elevation 

1 elevation 

2 range 
2 range 

2 azimuth 
2 azimuth 
2 elevation 

2 elevation 

3 range 
3 range 

3 azimuth 
3 azimuth 
3 elevation 

3 elevation 

range 

azimuth 

elevation 

range 

azimuth 

elevation 

range 

azimuth 

elevation 

MSBLS 


) 


(prev-filter-flag pass mlsr off) 
(prev- filter- flag pass mlsa off) 
(prev-filter-flag pass mlse off) 
(prev-data-good pass mlsr off) 
(prev-data-good pass mlsa off) 
(prev-data-good pass mlse off) 


; is within limits 
; not processing range 
; not processing azimuth 
; not processing elevation 
; range data-good is off 
; azimuth data-good is off 
; elevation data-good is off 




GROUP (3.10.1) 

MSBLS Availability 

This group determines which LRUs are available. It also determines 
why the unavailable LRUs are unavailable. 


; ; ; CONTROL FACTS 

; (sub- phase msbls availability) 

/ ; ; CONTAINING GROUP 
/ i MSBLS 


f f 


(defrule msbls-commf ault 


t f 

r } 
i r 

t f 

i t 

i t 
f t 

i r 
i r 


IF 


THEN 


END 


A MSBLS LRU was not previously commfaulted AND 

The LRU is powered on AND 

The commfault flag for that LRU is now on 

Notify the operator that the LRU is commfaulted (unless 
the whole string is down) 

Conclude the LRU is no longer available due to commfault 


(sub-phase msbls availability) 

?x <- (msbls-status ?lru avail | fail) 
(msbls-flag commfault ?lru 
(string-commfault pass ?lru 


=> 


(if (eq 

?string-flag 

off) 

then 




(assert (event 

msbls 

(assert 

( status-light 

mlsr 

( assert 

( status-light 

mlsa 

(assert 

( status-light 

mlse 

( retract 

?x) 


(assert 

(msbls-status 

?lru 


on) 

?string-flag) 


off-nominal alt "Commfault MSBLS 
?lru commfault)) 

?lru commfault) ) 

?lru commfault) ) 

commfault) ) ) 


?lru) ) ) 


(defrule msbls-commf ault-clear 


A MSBLS LRU was previously commfaulted AND 
The commfault flag for that LRU is now off 


130 



THEN 


Notify the operator that the commfault has cleared (unless 
the whole string was down) 

Conclude the LRU has the status indicated by the fail flag 

END 

(sub-phase msbls availability) 

?x <- (msbls-status ?lru commfault) 

(msbls-flag commfault ?lru off) 

(msbls-flag fail ?lru range ?flagr) 

(msbls-flag fail ?lru azimuth ?flaga) 

(msbls-flag fail ?lru elevation ?flage) 

(prev-string-cf pass ?lru ?string-flag) 

(msbls-lru-quality ?lru range ?range-status ) 

(msbls-lru-quality ?lru azimuth ?azimuth-status) 
(msbls-lru-quality ?lru elevation ?elevation-status ) 

= > 

(if (eq ?string-flag off) 
then 

(assert (event msbls off-nominal alt 

"Commfault clear on MSBLS " ?lru))) 

(retract ?x) 

(if (|| (eq ?flagr on) 

(eq ?flaga on) 

(eq ?flage on) ) 

then 

(assert (status-light mlsr ?lru fail)) 

(assert (status-light mlsa ?lru fail)) 

(assert (status-light mlse ?lru fail)) 

(assert (msbls-status ?lru fail)) 

else 

(assert (status-light mlsr ?lru ?range-status) ) 

(assert (status-light mlsa ?lru ?azimuth-status) ) 
(assert (status-light mlse ?lru Pelevation-status) ) 
(assert (msbls-status ?lru avail)))) 


(defrule msbls-failed 


A MSBLS LRU was previously available AND 
The fail flag for that LRU is now on 

Notify the operator of the LRU failure 

Conclude the LRU is no longer available due to RM failure 


(sub-phase msbls availability) 

?x <- (msbls-status ?lru avail) 

(msbls-flag fail ?lru range | azimuth | elevation on) 
=> 

(assert (event msbls off-nominal alt 

"MSBLS " ?lru " has been failed by RM" ) ) 
(assert (status-light mlsr ?lru fail)) 

(assert (status-light mlsa ?lru fail)) 

(assert (status-light mlse ?lru fail)) 

(retract ?x) 

(assert (msbls-status ?lru fail))) 



131 


(defrule msbls-power-of f 


r i 
t f 

r i 
i r 
f r 

} i 

f r 


IF 

A MSBLS LRU was previously powered on AND 
The power indicator for that LRU is now off 

THEN 

Notify the operator that the LRU has lost power 
Conclude the LRU is not available due to loss of power 

END 


(sub-phase msbls availability) 

?x <- (msbls-status ?lru ~power-off) 
(msbls-flag power ?lru off) 

=> 


assert (event msbls off-nominal alt 


"MSBLS " ?lru " 
(assert (status-light 
(assert (status-light 
(assert (status-light 
(retract ?x) 

(assert (msbls-status 


has been powered off")) 
mlsr ?lru off)) 
mlsa ?lru off)) 
mlse ?lru off)) 

'’lru power-off))) 


(defrule msbls-power-on 


A MSBLS LRU was previously powered off AND 
The power indicator for that LRU is now on 

THEN 

Notify the operator that the LRU has been powered on 
Conclude the LRU has the status indicated by the fail flag 

END 

(sub-phase msbls availability) 

?x <- (msbls-status ?lru power-off) 

(msbls-flag power ?lru on) 

(msbls-flag fail ?lru range ?flagr) 

(msbls-flag fail ?lru azimuth ?flaga) 

(msbls-flag fail ?lru elevation ?flage) 

(msbls-lru-quality ?lru range ?range-status) 

(msbls-lru-quality ?lru azimuth ?azimuth-status) 
(msbls-lru-quality ?lru elevation ?elevation-status) 

=> 

(assert (event msbls off-nominal alt 

"MSBLS " ?lru " has been powered on" ) ) 


(retract ?x) 

(if (|| (eq ? 

(eq ? 
(eq ? 

flagr on) 
flaga on) 
flage on) ) 




then 

( assert 

( status-light 

mlsr 

?lru 

fail) ) 

( assert 

( status-light 

mlsa 

?lru 

fail) ) 

( assert 

( status-light 

mlse 

?lru 

fail) ) 

( assert 

(msbls-status 

?lru 

fail) 

) 

else 

( assert 

( status-light 

mlsr 

?lru 

?range-status ) ) 

( assert 

( status-light 

mlsa 

?lru 

?azimuth-status ) ) 


132 



(assert (status-light mlse ?lru ?elevation-status ) ) 
(assert (msbls-status ?lru avail)))) 


(defrule three-msbls-avail 


All MSBLS LRUs are available 
The number of available LRUs is 3 


(sub-phase msbls availability) 
?x <- (msbls-num- avail ~3) 
(msbls-status 1 avail) 
(msbls-status 2 avail) 
(msbls-status 3 avail) 

=> 

(retract ?x) 

(assert (msbls-num-avail 3))) 


f r 
f f 

i r 
} r 

f i 


IF 

THEN 

END 


(defrule two-msbls-avail 


MSBLS LRU A is available AND 
MSBLS LRU B is available AND 
MSBLS LRU C is not available 

The number of available LRUs is 2 


(sub-phase msbls availability) 

?x <- (msbls-num-avail ~2) 
(msbls-status ?lru-a _avail) 
(msbls-status ?lru-b&~?lru-a avail) 
(msbls-status ?lru-c avail) 

=> 

(retract ?x) 

(assert (msbls-num-avail 2))) 


f / 

f i 
i } 
i i 

t f 
t } 

i } 


IF 


THEN 

END 


(defrule one-msbls-avail 


MSBLS LRU A is available AND 
MSBLS LRU B is not available AND 
MSBLS LRU C is not available 

THEN 

The number of available LRUs is 1 

END 

(sub-phase msbls availability) 

?x <- (msbls-num-avail ~1) 

(msbls-status ?lru-a avail) 
(msbls-status ?lru-b ~~avail)~ 
(msbls-status ?lru-c&~?lru-b ~avail) 


133 





=> 

(retract ?x) 

(assert (msbls-num-avail 1))) 


(defrule no-msbls-avail 


/ f 
f f 
t } 


f l 
i f 


IF 

All MSBLS LRUs are unavailable 

THEN 

The number of available LRUs is 0 

END 

(sub-phase msbls availability) 

?x <- (msbls-num- avail ~0) 

(msbls-status 1 ~avail) 

(msbls-status 2 ~avail ) 

(msbls-status 3 ~avail) 

= > 

(retract ?x) 

(assert (msbls-num-avail 0))) 


; GROUP (3.10.2) 

MSBLS Lockon Status 

This group determines how many LRUs are locked onto range, azimuth, 
and elevation . 

; CONTROL FACTS 

(sub-phase msbls lockon) 

; CONTAINING GROUP 
MSBLS 


(defrule check-channel 


At least one MSBLS LRU is available AND 

No LRU is locked on one of the measurements AND 

The vehicle is below 13000 feet 

THEN 

Ask that the MSBLS channel be verified 

END 

(sub-phase rnsbls^ lockon) 

(msbls-num-avail ~0) 

(msbls-lock 1 ?measurement off) 

(msbls-lock 2 ?measurement off) 

(msbls-lock 3 ?measurement off) 

(runway pass ?runway) 

(alitutde ?alt) 

(test (< ?alt 13000)) 

=> 


134 


(assert (recommend msbls check-channel off-nominal alt 

"Need to verify MS LBS channel is " = ( lookup-msbls ?runway)))) 


defrule three-msbls-locked 


All LRUs are available AND 

All LRUs are locked on a measurement 

The number locked for that measurement is 3 
If the number locked was previously 0, then notify the 
operator that MSBLS is locking on 


(sub-phase msbls lockon) 

(msbls-num- avail 3) 

?x <- (msbls-num-locked ?measurement ?old-number&~3 ) 
(msbls-lock 1 ?measurement on) 

(msbls-lock 2 ?measurement on) 

(msbls-lock 3 ?measurement on) 

=> 

(if (= 0 ?old-number) 

then 

(assert (event msbls nominal alt 

"MSLBS is locking onto " ?measurement ) ) ) 

(retract ?x) 

(assert (msbls-num-locked ?measurement 3))) 


IF 


THEN 


END 


(defrule two-msbls-locked 


LRU A is locked on a measurement AND 
LRU B is locked on the same measurement AND 
LRU C is not lock on the measurement 
or not available 

The number of LRUs locked on that measurement is 2 
If the number locked was previously 0, then notify the 
operator that MSBLS is locking on 


(sub-phase msbls lockon) 

?x <- (msbls-num-locked ?measurement ?old-number&~2 ) 
(msbls-lock ?lru-a ~?measurement on) 

(msbls-lock ?lru-b&~?lru-a ?measurement on) 

(or (msbls-lock ?lru-c ?measurement off) 

(msbls-num- avail 2)) 

=> 

(if (= 0 ?old-number) 

then 

(assert (event msbls nominal alt 

"MSLBS is locking onto " ?measurement) ) ) 

(retract ?x) 

(assert (msbls-num-locked ?measurement 2))) 


IF 


THEN 


END 


135 




(defrule one-msbls-locked 


f f 
f f 

r f 

/ t 

I f 
i f 
i / 

i r 
r r 


IF 


THEN 


END 


LRU A is locked on a measurement AND 
LRU B is not locked on the measurement AND 
LRU C is not locked on the measurement 

The number of LRUs locked on that measurement is 1 
IF the number locked previously was 0, then notify the 
operator that MSBLS is locking on 


(sub- phase msbls lockon) 

?x <- (msbls-num-locked ?measurement ?old-number&~l ) 
(msbls-lock ?lru-a Rmeasurement on) 

(msbls-lock ?lru-b ~?measurement off) 

(msbls-lock ?lru-c&~?lru-b ?measurement off) 

-> 

(if (= 0 ?old-number) 

then 

(assert (event msbls nominal alt 

"MSLBS is locking onto " ?measurement ) ) ) 

(retract ?x) 

(assert (msbls-num-locked ?measurement 1))) 


(defrule no-msbls- locked 


At least 1 LRU is available 
No LRU is locked on a measurement 

The number of LRUs locked for that measurement is 0 
Notify the operator that MSBLS lost lock 


(sub-phase msbls lockon) 

?x <- (msbls-num-locked ?measurement ~0) 
(msbls-num- avail ?num) 

( test ( >= ?num 1 ) ) 

(msbls-lock 1 Pmeasurement off) 

(msbls-lock 2 ?measurement off) 

(msbls-lock 3 ?measurement off) 

=> 

(assert (event msbls nominal alt 

"MSLBS lost lock in " Rmeasurement ) ) 

(retract ?x) 

(assert (msbls-num-locked ?measurement 0))) 


. ^***************************************************************************** 

/;/ GROUP (3.10.3) 

; ; MSBLS Error Checks 

/ } 

; ; This group check measurement errors and determines the quality of 

the three LRUs. 


} f 

} t 

i f 

r r 
r t 
i f 
} r 


IF 


THEN 


END 


13G 


/ / 


; ; ; CONTROL FACTS 

,• (sub-phase msbls quality) 

/ / ; CONTAINING GROUP 
i ; MSBLS 

f r 

(defrule initial-msbls-check 


The no quality statement has yet been made about a 
measurement AND 

The measurement bias is within tolerance AND 
The measurement noise is within tolerance 

The report that the measurement is good 


(declare (salience 10)) 

(sub-phase msbls quality) 

?x <- ( last-msbls-report ?lru ?measurement bias unknown) 

?y <- (last-msbls-report ?lru Pmeasurement noise unknown) 
(msbls-error ?lru ?measurement bias under) 

(msbls-error ?lru ?measurement noise under) 

= > 

(assert (event msbls nominal alt 

"MSBLS " ?lru " " Pmeasurement " is good" ) ) 

(retract ?x) 

(retract ?y) 

(assert (last-msbls-report ?lru Pmeasurement bias under)) 

(assert (last-msbls-report ?lru Pmeasurement noise under))) 


IF 

THEN 

END 


(defrule msbls-error-change 


Either the noise or bias on a measurement has a different 
status than it did previously 

Notify the operator of the new status 


(sub-phase msbls quality) 

?x <- (last-msbls-report ?lru Pmeasurement ?error 

?old-status) 

(msbls-error ?lru Pmeasurement ?error ?status& ?old-status) 
(units ?measurement ?units) 

=> 

(if (! (eq Pstatus under)) 
then 

(bind ?a (msbls-error ?lru Pmeasurement Perror) ) 
(assert (event msbls off-nominal alt 

"MSBLS " Plru " " Pmeasurement " has a " Perror 
" of " Pa Punits)) 

else 

(if (! (eq Pold-status unknown)) 
then 


IF 

THEN 

END 


137 




?error 


(assert (event msbls off-nominal alt 

"MSBLS " ?lru " " ?measurement " " 

" has cleared up")))) 

(retract ?x) 

(assert ( last-msbls-report ?lru ?measurement ?error ’status))) 


(defrule msbls-lru-quality-1 


A MSBLS LRU is unavailable or unlocked in a measurement 
That LRU has no quality rating for that measurement 


(sub-phase msbls quality) 

’x <- (msbls-lru-quality Plru ?measurement ~none) 

(or (msbls-status ?lru avail) 

(msbls-lock ?lru ?measurement off )) 
(measurement-name Pname&mlsr | mlsa | mlse Pmeasurement ) 

=> 

(assert (status-light ?name ?lru none)) 

(retract ?x) 

(assert (msbls-lru-quality ?lru Pmeasurement none))) 


IF 

THEN 

END 


(defrule msbls-lru-quality-2 


A MSBLS LRU is available AND 

The LRU is locked on a measurement AND 

The noise and bias ratings on the measurement indicate 

a quality rating different from the one previously 
given to the LRU 

THEN 

Note the new quality rating for the LRU 

END 

(sub-phase msbls quality) 

(msbls-status Plru avail) 

(msbls-lock Plru Pmeasurement on) 

(msbls-error Plru Pmeasurement bias Pbias) 

(msbls-error Plru Pmeasurement noise Pnoise) 

(msbls-quality Pbias Pnoise Pquality) 

Px <- (msbls-lru-quality Plru Pmeasurement ~Pquality) 
(measurement-name Pname&mlsr | mlsa | mlse Pmeasurement) 

=> 

(assert (status-light Pname Plru Pquality)) 

(retract Px) 

(assert (msbls-lru-quality Plru Pmeasurement Pquality))) 




;;; GROUP (3.10.4) 

; ; MSBLS Flag Monitoring 


138 


; This group watches for changes in the MSBLS data good flags and 

; ; filter flags . 

/ ; ; CONTROL FACTS 

; (sub-phase msbls watch-flags) 

• ; CONTAINING GROUP 
; / MSBLS 

/ f 

( defrule msbls-f ilter-f lag-changed 


The value of the MSBLS filter flag is different from 
its previous value 

Conclude that the value has changed 

Notify the operator if the new value is "process" 


(sub-phase msbls watch-flags} 

(filter-flag pass ?meas&mlsr |mlsa |mlse ?flag&~off) 
?x <- (prev-f ilter-f lag pass ?meas ~?flag) 
(measurement-name ?meas Pmeasurement ) 

= > 

(retract ?x) 

(assert (prev-f ilter-flag pass ?meas ?flag)) 

(if (eq ?flag process) 
then 

(assert (event msbls nominal alt 
" MSBLS " Pmeasurement 
" filter flag changed to the " 

?flag " position ")))) 


IF 


THEN 


END 


(defrule msbls-data-good- flag-changed 


r f 
i r 
r / 
r f 
r } 
f i 


IF 

The current value of a MSBLS data-good flag is different from 
its previous value 

THEN 

Notify the operator of the new value 

END 

(sub-phase msbls watch-flags) 

(data-good pass ?meas&mlsr | mlsa | mlse ?flag) 

?x <- ( prev-data-good pass ?meas ?flag) 

(measurement- name ?meas ?measurement ) 

=> 

(retract ?x) 

(assert (prev-data-good pass ?meas ?flag)) 

(assert (event msbls nominal alt 

"MSBLS " Pmeasurement " data-good flag is " ?flag))) 


(defrule msbls-dilemma 



; ; MSBLS dilemma flag is on for any measurement 

; ; THEN 

,• ; Warn the operator 

; / END 

(sub-phase msbls watch-flags) 

(msbls-di lemma ?measurement on) 

= > 

(assert (event msbls off-nominal alt 

"MSBLS " ?measurement " is in dilemma" ) ) ) 

f f 

GROUP (3.10.5) 

; MSBLS Recommendations 

/ r 

; ; This group determines what actions need to be taken on the MSBLS 

;; to keep it from corrupting the nav state. 

/ • ; CONTROL FACTS 

,■ (sub-phase msbls recommendation) 

/ ; ; CONTAINING GROUP 
; ; MSBLS 

i f 

t f 

( def rule three-level-msbls-deselect-1 


3 LRUs are available AND 
2 LRUs are locked on AND 
1 LRU is bad 

Recommend deselecting the bad LRU 


(sub-phase msbls recommendation) 

(msbls-num-avail 3) 

(msbls-num-locked ?measurement 2) 

(msbls-lru-quality ?lru-a ?measurement bad) 

(msbls-lru-quality ?lru-b ?measurement good) 

=> 

(assert (recommend msbls deselect-msbls-lru off-nominal alt 

"Need to power off MSBLS " ?lru-a " due to bad " ?measurement) ) ) 


IF 

THEN 

END 


( def rule three-level-msbls-f orce-tacan-1 

3 LRUs are available AND 
2 LRUs are locked on AND 
2 LRUs are bad in the same measurement 

Recommend forcing TACAN 
(sub-phase msbls recommendation) 


IF 

THEN 

END 


140 



(msbls-num-avail 3) 

(msbls-num-locked ?measurement 2) 

(msbls-lru-quality ?lru-a ^’measurement bad) 
(msbls-lru-quality ?lru-b&~lru-a ?measurement bad) 

= > 

(assert (recommend msbls force-tacan off-nominal alt 

"Need to force TACAN because of two bad MSBLS LRUs"))) 


(defrule three-level-msbls-rm-fail 


3 LRUs are available AND 
3 LRUs are locked on AND 
1 LRU is bad 

Recommend deselecting (for a noise problem) or waiting for 
RM isolation (for a bias problem) 


(sub-phase msbls recommendation) 

(msbls-num-avail 3) 

(msbls-num-locked ?measurement 3) 

(msbls-lru-quality ?lru-a ?measurement bad) 

(msbls-error ?lru-a Rmeasurement bias ?bias) 

(msbls-lru-quality ?lru-b __?measurement good) 

(msbls-lru-quality ?lru-c&~lru-b Rmeasurement good) 

=> 

(if (eq ?bias over) 
then 

(assert (recommend msbls msbls-rm-fail off-nominal alt 
"RM should fail MSBLS " ?lru-a " due to " 
Rmeasurement " bias")) 

else 

(assert (recommend msbls deselect-msbls off-nominal alt 
"Need to power off MSBLS " ?lru-a " due to " 
?measurement " noise" ) ) ) ) 


IF 


THEN 


END 


( defrule three-level-msbls-deselect-2 


3 LRUs are available AND 
3 LRUs are locked on AND 
2 LRUs are bad in the same measurement 

Recommend deselecting the bad LRUs 


(sub-phase msbls recommendation) 

(msbls-num-avail 3) 

(msbls-num-locked Rmeasurement 3) 

(msbls-lru-quality ?lru-a ~?measurement bad) 

(msbls-lru-quality ?lru-b&~lru-a ?measurement bad) 
(msbls-lru-quality ?lru-c Rmeasurement good) 

= > 

(assert (recommend msbls deselect-msbls-lru off-nominal alt 
"Need to power off MSBLS " ?lru-a " and " 

14 ! 


IF 

THEN 

END 



?lru-b " due to bad " ?measurement ) ) ) 


( def rule three-level-msbls- f orce-tacan-2 


3 LRUs are available AND 
3 LRUs are locked on AND 
3 LRUs are bad on the same measurement 

Recommend forcing TACAN 


(sub-phase msbls recommendation) 

(msbls-num-avail 3) 

(msbls-num- locked ?measurement 3) 

(msbls-lru-lock 1 ^measurement bad) 

(msbls-lru-lock 2 ?measurement bad) 

(msbls-lru-lock 3 ?measurement bad) 

= > 

(assert (recommend msbls force-tacan off-nominal alt 
"Need to force TACAN due to bad " ?measurement 
" in all MSBLS LRUs"))) 


IF 


THEN 

END 


( def rule two-level-msbls-deselect 


2 LRUs are available AND 
2 LRUs are locked on AND 
1 LRU is bad 

Recommend deselecting the bad LRU 


(sub-phase msbls recommendation) 

(msbls-num-avail 2) 

(msbls-num-locked ?measurement 2) 

(msbls-lru-quality ?lru-a ?measurement bad) 

(msbls-lru-quality ?lru-b ?measurement good) 

=> 

(assert (recommend msbls deselect-msbls-lru off-nominal alt 

"Need to power off MSBLS " ?lru-a " due to bad " ?measurement ) ) ) 


IF 

THEN 

END 


(defrule two-level-msbls- force-tacan 


2 LRUs are available AND 
2 LRUs are locked on AND 
2 LRUs are bad in the same measurement 

THEN 

Recommend forcing TACAN 

END 

(sub-phase msbls recommendation) 
(msbls-num-avail 2) 


142 



(msbls-num- locked ’’measurement 2) 

(msbls-lru-quality ?lru-a ?measurement bad) 
(msbls-lru-quality ?lru-b&~lru-a ?measurement bad) 

=> 

(assert (recommend msbls force-tacan off-nominal alt 

"Need to force TACAN due to bad MSBLS " ’measurement) ) ) 


( def rule one-level-msbls-force-tacan 


1 LRU is available AND 
1 LRU is locked on AND 
1 LRU is bad 

Recommend forcing TACAN 


(sub-phase msbls recommendation) 

(msbls-num- avail 1) 

(msbls-num-locked ?measurement 1) 

(msbls-lru-quality ?lru ?measurement bad) 

=> 

(assert (recommend msbls force-tacan off-nominal alt 

"Need to force TACAN due to bad MSBLS " ?measurement ) ) ) 


IF 


THEN 

END 


(defrule do-not- force-tacan 


Forcing TACAN is recommended AND 
TACAN is no go 

Cancel force TACAN recommendation AND 
Recommend powering off MSBLS 


(sub-phase msbls recommendation) 

?x <- (recommend msbls force-tacan off-nominal alt $?) 

( selected-tacan Rmeasurement no-go) 

=> 

(retract ?x) 

(assert (recommend msbls do-not-force-tacan off-nominal alt 

"Need to power off MSBLS because TACAN is no-go in " ?measurement ) ) ) 


. .***************************************************************************** 
t / 

• ■ ; GROUP (3.10.6) 

;; Effect of MSBLS on State Errors 

f t 

; ; This group checks to see if MSBLS processing makes the state error 

; ; worse . 


IF 


THEN 


END 




; ; ; CONTROL FACTS 

; (sub-phase msbls watch-state) 

//; CONTAINING GROUP 

f f 

r f 

(defrule error-before-msbls 


At least 1 lru is locked on range AND 
No MSBLS is being processed 

Remember the current worst-axis state error 


(sub-phase msbls watch-state) 
(msbls-num- locked range ~0) 
(filter-flag pass mlsr ^process) 
(filter-flag pass mlsa ^process) 
(filter-flag pass mlse process) 
(gnd-state pass worst-axis ?status) 

?x <- (error-before-msbls ~?status) 

=> 

(retract ?x) 

(assert (error-before-msbls Pstatus))) 


IF 


THEN 

END 


(defrule error-after-msbls 


MSBLS is being processed AND 

The state error is worse than before MSBLS was processed 
Recommend forcing TACAN 


(sub-phase msbls watch-state) 

(error-before-msbls ? before) 

(filter-flag pass mlsr | mlsa | mlse process) 

(gnd-state pass worst-axis ?after&~?before) 

(max-miscompare Pbefore Pafter Pafter) 

=> 

(assert (recommend msbls force- tacan off-nominal alt 

"Need to force TACAN because MSBLS is causing error growth"))) 


f i 
} r 

f } 

} r 
r r 
f r 


IF 


THEN 

END 


144 






3 


145 


***************************************************************************** 


GROUP (3.11) 

HSTD monitoring 

These rules have the task of determining the status of the HSTD state 
vector. THESE RULES DEPEND PRIMARILY ON OPERATOR INPUT. The rules 
can detect when the filter is stopped, and they can detect some 
situations where the filter is not converged. In addition, the 
operator can indicate when the filter is bad. The operator must 
specify when the filter is good; the rules never do that automatically. 


/ r 


CONTROL FACTS 
none 


f r 


f r 
r r 


CONTAINING GROUP 
Entry 




; ; ; FACTS 

(def facts monitoring-hstd-phases ; These facts list the sequence of 

; sub-phases in the monitoring phase 
; of the hstd rules . 

(first-sub-phase hstd monitoring status) 

There is only 1 sub-phase: hstd-status 


'(deffacts initial-hstd-facts 


(hstd stopped) 
(restart-time 0.0) 


; These facts represent assumptions 
; about the HSTD vector prior to 
; receiving any data . 

; The filter is not running 
; Time of last restart not yet known 


def rule hstd-start 


The HSTD has not been running AND 
The 'stopped' indicator is off 

Conclude the HSTD is running but has not converged 


(sub-phase hstd status) 

?x <- (hstd stopped) 

(hstd-stop-flag off) 

= > 

(assert (status-light state ground bad)) 
(retract ?x) 

(assert (hstd bad))) 


IF 


THEN 

END 


146 


(defrule hstd-bad 


; The HSTD was good AND 

; The operator entered the HSTD-bad indicator 

; THEN 

; Conclude the HSTD is bad (not converged) 

; END 

(sub-phase hstd status) 

?x <- (hstd good) 

?y <- (operator-input hstd bad) 

= > 

(assert (status-light state ground bad)) 
(retract ?x) 

(retract ?y) 

(assert (hstd bad))) 


(defrule hstd-good 


The HSTD was bad AND 

The operator entered the HSTD-good indicator AND 
At least 10 seconds have elapsed since the last restart 

Conclude the HSTD is good 


(sub-phase hstd status) 

?x <- (hstd bad) 

?y <- (operator-input hstd good) 
(restart-time ?restart-time) 

(current-time ?time) 

(test (>= (- ?time ?restart-time) 10.0)) 

=> 

(assert (status-light state ground good)) 
(retract ?x) 

(retract ?y) 

(assert (hstd good))) 


IF 

THEN 

END 


(defrule hstd-stopped 


The HSTD was running AND 
The stopped indicator is on 

Conclude the HSTD has been stopped 


(sub-phase hstd status) 

?x <- (hstd 'stopped) 

(hstd-stop-flag on) 

=> 

(assert (status-light state ground stopped)) 
(retract ?x) 

(assert (hstd stopped))) 


IF 

THEN 

END 


147 




(defrule hstd-editing 


The HSTD was good AND 

Less that 3 stations are being processed AND 
A given station is not being excluded AND 
There is data coming from that station AND 
At least one good measurement of a given type was 
available from that station AND 
All of the measurements of that type from that station 
were edited by the filter 

Conclude the HSTD is bad 


(sub-phase hstd status) 

?x <- (hstd good) 

(or (exclude ?station-l on) 

(tracking-avail ~?station-l 0)) 

(exclude ?station-2& ?station-l off) 
(tracking-avail ?station-2 ~0) 
(tracking-good ?station-2 ?meas ?num-good) 
(test (>= ?num-good 1)) 

(tracking-edit ?station-2 ?meas ?num-good) 
= > 

(assert (status-light state ground bad)) 
(retract ?x) 

(assert (hstd bad))) 


IF 


THEN 

END 


(defrule hstd-prop 


The HSTD was good AND 
The prop flag is on 

Conclude the HSTD is bad 


(sub-phase hstd status) 

?x <- (hstd good) 

(hstd-prop- flag on) 

«> 

(assert (status-light state ground bad)) 
(retract ?x) 

(assert (hstd bad))) 


IF 

THEN 

END 


(defrule hstd-covariance 


t r 

t f 

t i 
i f 
i / 


IF 


THEN 


The HSTD was good AND 

The RSS position or velocity covariance diagonals are 
too large 


148 




Conclude the HSTD is bad 

END 

(sub-phase hstd status) 

?x <- (hstd good) 

(hstd-covariance ? over) 

=> 

(assert (status-light state ground bad)) 
(retract ?x) 

(assert (hstd bad))) 


(defrule hstd-restart 


r r 
r t 
r t 


r i 

t / 

f t 
i f 


IF 

The HSTD is available AND 
The HSTD restart flag is on 

THEN 

Conclude the HSTD is bad 

Record the current time as the time of the last restart 

END 


(sub-phase hstd status) 
(hstd-status available) 

?x <- (hstd ?) 

(hstd-restart- flag on) 

?y <- (restart-time ?restart-time) 
(current-time ? times ?restart-time) 
=> 


( assert 
(retract 
( assert 
(retract 
( assert 


( status-light 
?x) 

(hstd bad) ) 

?y> 

( restart-time 


state ground bad)) 


?time) ) ) 


14U 




3.12 Control Flow 


3 


150 


, . ic'k'k'k'kif'kic'k'k'k'k'k'k'k'k'ki'C'kir'kit'k'kir'k'k'kit'k'K'k'k'k'k'k'k'k^'kii-k-k'kitic'ki^'^'k'k'k'k 
/ / 

; ; GROUP 

; ; Control (no reference number) 

r f 

; ; This group handles initial start up of rule 

; / execution, and controls the phasing of rule 

; ; groups . 

■ ; CONTROL FACTS 
; ; none 

• CONTAINING GROUP 
; ; Entry 

/ / 

/ / 

; ; ,• Facts 

(deffacts control-initial-phase 
(phase fact-assertion) 

) 


(deffacts control-phases 

(next-phase fact-assertion monitoring) 
monitoring analysis) 
analysis output) 
output fact-assertion) 

) 


( next-phase 
(next-phase 
( next-phase 


(defrule control-kickoff 

(phase fact-assertion) 

=> 

(call (operator-input)) 
(call (check-facts off)) 
(call (fact-assertion)) 
(call (display-time)) 
(call (check-facts on))) 


(defrule control-change-phases 

(declare (salience -1000)) 

(next-phase ?current-phase ?next-phase) 
(not (end-of-data $?)) 

?x <- (phase ?current-phase) 

=> 

(retract ?x) 

(assert (phase ?next-phase) ) ) 


(defrule control-end-of-cycle 

(declare (salience -999)) 
(single step) 

(phase output) 

=> 


151 


(halt) ) 


(defrule control-kickoff-subphase 
(declare (salience 100)) 

(phase ^phase) 

(first-sub-phase ?module ?phase ?subphase) 
= > 

(assert (sub-phase ?module Psubphase))) 


(defrule control-next-subphase 

(declare (salience -100)) 

?x <- (sub-phase Pmodule Pcurrent) 
(next-sub-phase Pmodule Pcurrent ?next) 
= > 

(retract ?x) 

(assert (sub-phase Pmodule ?next))) 


(defrule control-last-subphase 

(declare (salience -200)) 
?x <- (sub-phase $?) 

=> 

(retract ?x) ) 


152 



3 


153 


.I**************************************************************************** 


; ; ,- GROUP Operator Inputs 

/ t 

; ; This group takes the following operator inputs and makes appropriate 

; ; adjustments to the fact base; 

; ; stop 

; ; subsystem 

; ; delta-state 

; ; bfs-no-go 

; ; runway 

; toggle-tacan 

,■ The hstd status is handled by the hstd rules because proper handling 
;; involves coordination with other hstd flags (see hstd.r). 

• ; ; CONTROL FACTS 
; (phase fact-assertion) 

■ ; CONTAINING GROUP 
; ; Entry 

} f 
/ f 


(defrule operator-stop 


The operator issued the stop command 

THEN 

Retract the operator ' s command 
Halt CLIPS 

ENDIF 

(phase fact-assertion) 

?x <- (operator-input stop) 

=> 

(retract ?x) 

(halt) ) 


(defrule operator-subsystem 


The operator commanded a new subsystem window 

THEN 

Retract the operator ' s command 

Reconfigure the screen to show the commanded subsystem 

ENDIF 

(phase fact-assertion) 

?x <- (operator-input subsystem ?number) 

=> 

(retract ?x) 

(call (select-subsystem ?number))) 


154 




(defrule operator-delta-state 


The operator issued a delta-state command (position-only, 
posit ion-and-velocity , or none) AND 
No delta-state was in work previously 

Retract the operator ' s command 

If the command was anything but "none", note that a delta-state 
is in work and note the type of delta-state 


fact-assertion ) 

?x <- (operator-input delta-state ?type) 

(not (need-delta-state $?)) 

= > 

(retract ?x) 

(call (update-configuration delta-state ?type) ) 
(if ( ! (eq ?type none)) 
then 

(assert (need-delta-state ?type)))) 


IF 

THEN 

ENDIF 

(phase 


( defrule operator-changed-delta-state 


The operator issued a delta-state command (position-only, 
posi t ion-and-velocity , or none) AND 

A delta-state was already in work 

Retract the operator ' s command 

If the command was anything but "none", change the type 
of delta-state in work; otherwise, note that no 
delta-state is in work. 


fact-assertion ) 

?x <- (operator-input delta-state ?type) 

?y <- (need-delta-state $?) 

=> 

(retract ?x ?y) 

(call (update-configuration delta-state ?type)) 
(if (! (eq ?type none)) 
then 

(assert (need-delta-state ?type)))) 


IF 

THEN 

ENDIF 

(phase 


(defrule operator-bf s-no-go 


The operator issued the BFS-NO-GO command 

THEN 

Retract the operator ' s command 
Change the BFS status to no-go 

ENDIF 


155 



(phase fact-assertion) 

?x <- (operator-input bfs-no-go) 

?y <- (bfs-status $?) 

= > 

(call (update-configuration bfs no-go)) 
(retract ?x ?y) 

(assert (bfs-status no-go))) 


( def rule operator-runway-selection 


/ r 
/ / 
r f 

i / 


f / 
/' / 


IF 

The operator has completed a runway selection 

THEN 

Change the desired runway to the specified slot 
Change the desired TACAN to the primary slot in the same 
area as the runway 

(phase fact-assertion) 

?x <- (operator-input runway ?rw-slot) 

?a <- (runway desired $?) 

?b <- (desired-tacan $?) 

?c <- (desired-channel $?) 

= > 

(retract ?x) 

(if (&& (>= ?rw-slot 1) (<= ?rw-slot 30)) 

then 

(retract ?a ?b ?c) 

(bind ?name ( lookup-rw-name ?rw-slot)) 

(bind ?area (trunc (/ (+ ?rw-slot 1) 2))) 

(bind ?tac-slot (- (* ?area 2) 1)) 

(bind ?channel ( lookup-tacan ?tac-slot)) 

(assert (runway desired ?rw-slot)) 

(assert (desired-tacan ?tac-slot)) 

(assert (desired-channel ?channel)) 

(call (update-configuration runway ?name) ) 

(call (update-configuration tacan ?channel)) 

else 

(assert (event site nominal alt 

"There is no runway slot " ?rw-slot "in the table")))) 


(def rule operator-toggle-tacan 


i 


r f 

} f 


r r 




IF 

THEN 


ENDIF 


The operator issued the TOGGLE command AND 
Toggle capability is available 

Retract the operator ' s command 

Change the desired TACAN to the other station in the 
current area 


(phase fact-assertion) 

?x <- (operator-input toggle-tacan) 
(toggle- available yes) 

?y <- (desired-tacan ?current-slot ) 


15G 


(same-area ?current-slot ?other-slot) 

?z <- (desired-channel $?) 

= > 

(bind ?channel ( lookup-tacan ?other-slot) ) 
(call (update-configuration tacan ?channel)) 
(retract ?x ?y ?z) 

(assert ( desired-tacan ?other-slot ) ) 

(assert (desired-channel ?channel ) ) ) 


(defrule operator-cant-toggle 


The operator issued the TOGGLE command AND 
Toggle capability is not available 

THEN 

Retract the operator ' s command 

Inform the operator that toggle is not available 

END IF 

(phase fact-assertion) 

?x <- (operator-input toggle-tacan) 

(toggle-available no) 

= > 

(retract ?x) 

(assert (event tacan nominal alt 

"No " "toggle capability at this landing site"))) 


157 





3.14 Output Management 


3 


158 




r t 

; ; } GROUP Output Management 

f r 

; ; These groups determine what needs to be displayed and how it is 

; ; to be displayed. 

/ f 

/ ; ; CONTROL FACTS 
; (phase output) 

/ / / CONTAINING GROUP 
; ; Entry 

/ f 
t f 

f f 
t f 

; ; ; GROUP Event Management 

t f 

; ; This group manages the transmission of event notices to the message 

,• ,• windows . An event notice is received as a fact with the following 

; ; form: 

;; (event ?subsystem ?mode ?tag $?text) 

,■ ,• where Psubsystem = the name of the subsystem generating the event 

,■ ; ?mode = nominal or off-nominal 

;; ?tag = alt, mach, or none 

;; $?text = the text of the message 

■ ■ ; CONTROL FACTS 

(phase output) 

■ ; ; CONTAINING GROUP 
; ; Output Management 

r r 
/ r 


(defrule output-event 


f f 
f / 

f t 

/ f 

i i 
i f 


IF 

THEN 

END 


An event needs to be printed 

Print it on the main message window and the appropriate 
subsystem window 


?x <- (event ?subsystem ?mode ?tag $?text) 
(phase output) 

=> 


(bind ?n 1) 

(bind ?1 (length $?text)) 

(while (<= ?n ?1) 

(bind ?a (nth ?n $?text)) 

(if (numberp ?a) 
then 

(call (format message 

else 


(call (format 
( bind ?n ( + ?n 1 ) ) ) 
(call (format message "%n 


message 


rr 


)) 


"%g" 

"%s" 


?a) ) 
?a))) 


15,4 


(call (message main ?mode event ?tag) ) 

(call (message ?subsystem ?mode event ?tag) ) 
(retract ?x) ) 


. wicicjcie^lc^jcicIcIc'kic'k'k'k'k'k'kic'k'k'k'k'k'k'k'k'k-k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'k'kicicif'tcif'k'X'k'kic'kic'kic 
f r 

r t 

_ ; ; GROUP Recommendation Management 

/' / 

; This group of rules handles the printout of recommendations at regular 
; i intervals . Recommendations are sent to this group from other rules 

— ;/ in the form of a fact: 

} i 

;; (recommend ?subsystem ?id ?mode ?tag $?text) 

i r 

~ ; ; where ?subsystem = the name of the subsystem generating the event 

,• ; ?id « name of the recommendation (to distinguish it from other 

;; recommendations). 

,■ ; ?mode = nominal or off-nominal 

; ; ?tag = alt, mach, or none 

; ; $?text = the text of the message 

f r 

~~ ; ; The recommendation rules also keep an internal record of active 
; ; recommendations using facts of the following form: 

r f 

_ (active-message ?subsystem ?id ?a ?b ?time $?text) 

/ f 

; ; where ? subsystem = same as recommendation subsystem 

; ,• ?id = same as recommendation id 

— ;; ?a = message number on main message window 

; ; ?b = message number on subsystem message window 

v ; ?time = time the recommendation was last checked 
_ ; ; $?text = the text of the message 

/ f 

;; For a recommendation to remain active, the rule that asserts it must 
,• / re-assert it on every cycle. If a recommendation is not asserted on 
w ,• ; a given cycle, then it is assumed to no longer be active. 

; CONTROL FACTS 
; (phase output) 

— / ■ CONTAINING GROUP 

; ; Output Management 

f t 

. .*************^**********************^**************************************** 
r f 

_ (defrule output- recommendation 

?x <- (recommend ?subsystem ?id ?mode ?tag $?text) 

(not (active-message ?subsystem ?id ? ? ? $?text)) 

(current-time ?time) 

■*-' (phase output) 

=> 

(bind ?n 1) 

__ (bind ?1 (length $?text)) 

(while (<= ?n ?1) 

(bind ?a (nth ?n $?text)) 

(if (numberp ?a) 

— then 

(call (format message "%g" ?a)) 


160 



else 


(call (format message "%s" ?a))) 

(bind ?n (+ ?n 1) ) ) 

(call (format message "%n")) 

(bind ?a (message main ?mode recommend ?tag)) 

(bind ?b (message ?subsystem ?mode recommend ?tag)) 

(retract ?x) 

(assert (active-message ?subsystem ?id ?a ?b ?time $?text))) 


( defrule output-hold-recommendation 

?x <- (active-message ?subsystem ?id ?a ?b ?last-time $?text) 
?y <- (recommend ?subsystem ?id ? ? $?text) 

(current-time ?time) 

(test (> ?time ?last-time)) 

(phase output) 

=> 

(retract ?x) 

(retract ?y) 

(assert (active-message ?subsystem ?id ?a ?b ?time $?text))) 


( defrule output-end-recommendation 

?x <- (active-message ?subsystem ?id ?a ?b ?last-time $?text) 
(not (recommend ?subsystem ?id ? ? $?text)) 

(current-time ?time) 

(test (> ?time ?last-time)) 

(phase output) 

= > 

(call (erase-msg ?a)) 

(call (erase-msg ?b)) 

(retract ?x) ) 


/ f 

; ; ; GROUP Status Light Management 

i f 

;; These rules control updates to the status lights. Statuses are 

;; determined by other rules and are sent to this group as facts: 

r f 

;; (status-light ?id ?sub-id ?value) 

/ f 

;; where ?id is a subsystem identifier, ?sub-id is an LRU number or 

;; component identifier, and ?value is the value to be displayed. 

; ; ; CONTROL FACTS 
; (phase output) 

; ; ; CONTAINING GROUP 
; ; Output Management 

/ f 
f / 

(def facts output-light-locations ; These facts define the locatio 

; (line and column number) for each 
; of the subsystems and LRUs 


161 


(light-location runway pass 1 10) 
(light-location runway bfs 1 15) 
(light-location runway ground 1 20) 
(light-location tacan pass 2 10) 
(light-location tacan bfs 2 15) 
(light-location state pass 3 10) 
(light-location state bfs 3 15) 
(light-location state ground 3 20) 
(light-location three-state 1 6 10) 
(light-location three-state 2 6 15) 
(light-location three-state 3 6 20) 
(light-location pass-imu 1 7 10) 
(light-location pass-imu 27 15) 
(light-location pass-imu 3 7 20) 
(light-location bfs-imu 1 8 10) 
(light-location bfs-imu 2 8 15) 
(light-location bfs-imu 3 8 20) 
(light-location drag 0 9 10) 
(light-location tacr 1 10 10) 
(light-location tacr 2 10 15) 
(light-location tacr 3 10 20) 
(light-location tacb 1 11 10) 
(light-location tacb 2 11 15) 
(light-location tacb 3 11 20) 
(light-location tacb cone 11 0) 
(light-location baro 0 12 10) 
(light-location mlsr 1 13 10) 
(light-location mlsr 2 13 15) 
(light-location mlsr 3 13 20) 
(light-location mlsa 1 14 10) 
(light-location mlsa 2 14 15) 
(light-location mlsa 3 14 20) 
(light-location mlse 1 15 10) 
(light-location mlse 2 15 15) 
(light-location mlse 3 15 20) 
(light-location tlm 0 16 10) 


(def facts output-display-values ; These facts define the display values 

; for all of the possible values of 

; the status lights 

(display-value unknown " " normal) 

(display-value blank " " normal) 

(display-value none " " normal) 

(display-value go " GO " normal) 

(display-value good "GOOD" normal) 

(display-value high "HIGH" normal) 

(display-value low "LOW " normal) 

(display-value no-go "NOGO" blink) 

(display-value bias "BIAS" blink) 

(display-value resolver "RSLV" blink) 

(display-value drift "DRFT" blink) 

(display-value velocity "VEL " blink) 

(display-value attitude "ATTD" blink) 

(display-value suspect "SPOT" blink) 

(display-value timing "TIME" blink) 

(display-value noise "NOIS" blink) 


162 


) 


( display-value 
( display-value 
(display-value 
(display-value 
( display- value 
( display-value 
( display-value 
( display-value 
( display-value 
(display-value 


atmos "ATMS" 
mach "MACH" 
roll "ROLL" 
cone "CONE" 
commfault "COMF 
fail "FAIL" 
deselect "DSEL" 
off "OFF " 
bad "BAD " 
stopped "STOP" 


blink) 

blink) 

blink) 

blink) 

" inverse) 
inverse) 
inverse) 
inverse) 
inverse) 
inverse) 


( def rule output-update-status-light 

?x <- (status-light ?id ?sub-id ?value) 
(display-value ?value ?word ?mode) 
(light-location ?id ?sub-id ?row ?column) 
(phase output) 

= > 

(retract ?x) 

(call (status-light ?row ?column ?mode ?word))) 


163 


3.15 Data Tables 


3 


164 


; ; GROUP 

;; Data Tables (no reference number) 

/ f 

; CONTROL FACTS 
; ; None 

f r 

; / ; CONTAINING GROUP 
,• ; Entry 

i f 

/ i 


; Common-lru is used to determine the lru that is common to two pairs 
; (common-lru ?pair-l ?pair-2 ?lru-id) 

(def facts tables-common-lru 


(common-lru 

p-1-2 

P-1-3 

1) 

(common-lru 

P-1-3 

p-1-2 

1) 

(common-lru 

p-2-3 

p-1-2 

2) 

(common-lru 

p-1-2 

p-2-3 

2) 

(common-lru 

P-1-3 

p-2-3 

3) 

(common-lru 

p-2-3 

P-1-3 

3) 


,■ Excluded-lru is used to determine which lru is excluded from a pair 
(excluded-lru ?pair ?lru-id) 

(def facts tables-excluded-lru 


(excluded-lru 

p-1-2 

3) 

(excluded-lru 

P-1-3 

2) 

(excluded-lru 

p-2-3 

1) 


; Lrus-in-pair is used to determine which lrus are included 
; (lrus-in-pair ?pair ?lru-a ?lru-b) 

; Note that if ?pair is the only bound variable, then there 


( 


deffacts tables-lrus-in-pair 


( lrus-in-pair 

p-1-2 

1 

2) 

(lrus-in-pair 

p-1-2 

2 

1) 

( lrus-in-pair 

P-1-3 

1 

3) 

( lrus-in-pair 

P-1-3 

3 

1) 

(lrus-in-pair 

p-2-3 

2 

3) 

(lrus-in-pair 

p-2-3 

3 

2) 


) 


in a pair 

are two matches . 


; Min-miscompare is used to determine the "smaller" of two miscomparison 
; ratings, where the ratings are defined to be "zero", "under", "o50", 

; and "over", in that order. 

; (min-miscompare ?status-l ?status-2 ?min-status) 

(deffacts tables-min-miscompare 


165 


) 


(min-mi scompare 

zero 

zero 

zero 

) 

(min-miscompare 

under 

zero 

zero 

) 

(min-miscompare 

o50 

zero 

zero 

) 

(min-miscompare 

over 

zero 

zero 

) 

( min-miscompare 

zero 

under 

zero 

) 

(min-miscompare 

under 

under 

under) 

( min-miscompare 

o50 

under 

under) 

( min-miscompare 

over 

under 

under) 

(min-miscompare 

zero 

o50 

zero 

) 

(min-miscompare 

under 

o50 

under) 

(min-miscompare 

o50 

o50 

o50 

) 

(min-miscompare 

over 

o50 

o50 

) 

(min-miscompare 

zero 

over 

zero 

) 

( min-miscompare 

under 

over 

under) 

(min-miscompare 

o50 

over 

o50 

) 

(min-miscompare 

over 

over 

over 

) 


; Max-mi scompare is used to determine the "larger" of two miscomparison 
; ratings, where the ratings are defined to be "zero", "under", "o50", 

; and "over", in that order. 

; (max-miscompare ?status-l ?status-2 ?max-status) 

(def facts tables-max-miscompare 


( max-miscompare 

zero 

zero 

zero 

) 

(max-miscompare 

under 

zero 

under) 

( max-miscompare 

o50 

zero 

o50 

) 

(max-miscompare 

over 

zero 

over 

) 

( max-miscompare 

zero 

under 

under) 

(max-miscompare 

under 

under 

under ) 

( max-miscompare 

o50 

under 

o50 

) 

( max-miscompare 

over 

under 

over 

) 

( max-miscompare 

zero 

o50 

o50 

) 

(max-miscompare 

under 

o50 

o50 

) 

( max-miscompare 

o50 

o50 

o50 

) 

( max-miscompare 

over 

o50 

over 

) 

( max-miscompare 

zero 

over 

over 

) 

( max-miscompare 

under 

over 

over 

) 

( max-miscompare 

o50 

over 

over 

) 

( max-miscompare 

over 

over 

over 

) 


Fault matrix is used to determine the IMU component that has failed 
based on which algorithms (velocity, attitude, or ACC) are indicating 
a miscomparison with other IMUs. 

(fault-matrix ?vel-status ?att-status ?acc-status ?fault) 
where each status is under, o50, or over,- and ? fault is as follows: 


good 

bias 

resolver 

drift 

velocity 

attitude 

suspect 


(deffacts tables- fault-matrix 


no fault 

accelerometer bias or scale factor error 
resolver error 
gyro drift 

undiagnosable velocity problem 
undiagnosable attitude problem 
undiagnosable problem 


166 




( fault-matrix 

under 

under 

under 

good ) 

( fault-matrix 

o50 

under 

under 

velocity) 

( fault-matrix 

over 

under 

under 

velocity) 

( fault-matrix 

under 

o50 

under 

attitude) 

( fault-matrix 

under 

over 

under 

attitude) 

( fault-matrix 

under 

under 

o50 

attitude) 

( fault-matrix 

under 

under 

over 

attitude) 

( fault-matrix 

o50 

o50 

under 

resolver) 

( fault-matrix 

over 

o50 

under 

resolver) 

( fault-matrix 

o50 

over 

under 

resolver) 

( fault-matrix 

over 

over 

under 

resolver) 

( fault-matrix 

o50 

under 

o50 

bias ) 

( fault-matrix 

over 

under 

o50 

bias ) 

( fault-matrix 

o50 

under 

over 

bias ) 

( fault-matrix 

over 

under 

over 

bias ) 

( fault-matrix 

under 

o50 

o50 

drift ) 

( fault-matrix 

under 

over 

o50 

drift ) 

( fault-matrix 

under 

o50 

over 

drift ) 

( fault-matrix 

under 

over 

over 

drift ) 

( fault-matrix 

o50 

o50 

o50 

suspect ) 

( fault-matrix 

over 

o50 

o50 

suspect ) 

( fault-matrix 

o50 

over 

o50 

suspect ) 

( fault-matrix 

over 

over 

o50 

suspect ) 

( fault-matrix 

o50 

o50 

over 

suspect ) 

( fault-matrix 

over 

o50 

over 

suspect ) 

( fault-matrix 

o50 

over 

over 

suspect ) 

( fault-matrix 

over 

over 

over 

suspect ) 


; quality-table is used to determine the quality of a state 
,■ vector (good , suspect, or bad) based on a comparison with 
; another state vector or the ground (zero, under, o50, or over) 
(def facts tables-quality-table 

(quality-table zero good) 
under good ) 
o50 suspect) 
over bad ) 

) 


( quality-table 
( quality-table 
( quality-table 


,- tacan-quality is used to determine the quality of a tacan lru based on 
,- comparisons with the ground or other lrus. 

; (tacan-quality ?slope ?bias ?noise ?quality) 

,• where ?slope and ?noise are under or over,- ?bias is under, o50, or over,- 


,- and quality is good, 
(def facts tables-tacan- 

bias, 

■quality 

timing, 

or noise. 

( tacan-quality 

under 

under 

under 

good) 

( tacan-quality 

under 

under 

over 

noise) 

( tacan-quality 

under 

o50 

under 

bias) 

( tacan-quality 

under 

o50 

over 

noise) 

( tacan-quality 

under 

over 

under 

bias) 

( tacan-quality 

under 

over 

over 

noise) 

( tacan-quality 

over 

under 

under 

timing) 

( tacan-quality 

over 

under 

over 

noise) 

( tacan-quality 

over 

o50 

under 

timing) 


167 




(tacan-quality 

over 

o50 

over 

noise) 

( tacan-quality 

over 

over 

under 

timing) 

( tacan-quality 

over 

over 

over 

noise) 


; msbls-quality is used to determine the quality of a msbls lru based on 
; comparisons with the ground or other lrus. 

; (msbls-quality ?bias ?noise ?quality) 

; where ?bias and ?noise are under, o50, or over; and quality is good or bad 


(def facts tables-msbls- 
( msbls-quality 

-quality 

under 

under 

good) 

(msbls-quality 

under 

o50 

good) 

(msbls-quality 

under 

over 

bad ) 

(msbls-quality 

o50 

under 

good) 

( msbls-quality 

o50 

o50 

good) 

( msbls-quality 

o50 

over 

bad ) 

( msbls-quality 

over 

under 

bad ) 

(msbls-quality 

over 

o50 

bad ) 

(msbls-quality 

over 

over 

bad ) 


) 


,• measurement-name is used to connect the 4-character measurement name used by 
; filter flags and data good flags with the TACAN and MSBLS measurement type 


(def facts tables-measurement- names 

(measurement- name 

tacr 

range ) 

(measurement-name 

tacb 

bearing) 

(measurement-name 

mlsr 

range ) 

(meas ur emen t- name 

mlsa 

azimuth) 

(measurement-name 

mlse 

elevation) 


) 


feet) 
bearing degrees) 
azimuth degrees) 
elevation degrees ) 


,• "units" is used to determine the unit name to print out for a given 
; measurement 
(def facts tables-units 
(units range 
(units 
(units 
(units 
(units 
(units 
(units 
(units 
(units 
(units 
(units 

) 


drag 

tacr 

baro 

mlsr 

tacb 

mlsa 

mlse 


feet) 
feet) 
feet) 
feet) 
degrees) 
degrees) 
degrees ) 


168 


; ; same-area is used to determine which slot is in the same area as a 

; ; given slot 

(deffacts tables-same-area 


( same-area 

1 

2) 

( same-area 

2 

1) 

( same-area 

3 

4) 

( same- area 

4 

3) 

(same-area 

5 

6) 

( same-area 

6 

5) 

( same-area 

7 

8) 

( same-area 

8 

7) 

( same-area 

9 

10) 

(same-area 

10 

19) 

(same-area 

11 

12) 

( same-area 

12 

11) 

( same-area 

13 

14) 

( same-area 

14 

13) 

( same-area 

15 

16) 

( same-area 

16 

15) 

( same-area 

17 

18) 

( same-area 

18 

17) 

( same-area 

19 

20) 

( same-area 

20 

19) 

( same-area 

21 

22) 

( same-area 

22 

21) 

( same-area 

23 

24) 

( same- area 

24 

23) 

( same-area 

25 

26) 

( same-area 

26 

25) 

( same-area 

27 

28) 

( same-area 

28 

27) 

( same-area 

29 

30) 

( same-area 

30 

29) 


16 H 



Section 4 


REFERENCES 


1) "Knowledge Requirements For the Onboard Navigation (ONAV) 
Console Expert/Trainer System, "Mission Support Directorate, 
Mission Planning & Analysis Division, NASA Johnson Space 
Center, ENTRY phase specifications. Baseline Version 1.0, 
October 1987, JSC internal Note #JSC-22657. 


4 


1 


End of Document 


