The 

MDL 
Programming Language 

S. W. Galley and Greg Pfister 



Laboratory for Computer Science 

Massachusetts Institute of Technology 

Cambrid 5 e Massachusetts 02139 



The MDL Programming Language 



Abstract 



The MDI. programming language began existence in late 1970 (under the name Muddle) as a 
SHCCW0T m I iJp (Moon.* 1974)* a candidate vehicle for the Dynamic Modeling System, and a possible 
base for implementation of Planner (lie will, I960). The original design goals included an 
interactive initiated environment for programming, debugging, loading, and editing: ease in 
learning and uses facilities for structured, modular, shared programs: extensibility of syntax, data 
types and operator*! data-type checking for debugging and optional data-type declarations for 
compiled efficiency: associative storage, coroutining, and graphics. Along the way to reaching those 
goals, it developed flexible input/output (including the ARPA Network), and flexible interrupt and 
signal handling. It now serves as a base for software prototyping, research, development, education, 
and implementation of the majority of programs at MIT-DMS: a library of sharable modules, a 
coherent ll*er interface, special research projects, autonomous daemons, etc 

This document was originally intended to be a simple low-level introduction to MDL. It has. 
however, acqiiirrd a case of elephantiasis and now amounts to a discursive description of the whole 
interpreter, .in realized in MDL release numbers 55 (ITS version) and 105 (Tenex and Tops-20 
versions). (Significant changes from the previous edition are marked in the margin.) A low-level 
introduction inaj still be had by restricting one's attention to specially-marked sections only. The 
scope of ihe document is confined as much as possible to the interpreter itself. Other adjuncts 
(compiler, assembler, pre-loaded user programs, library) are mentioned as little as possible, despite 
their value in promoting the language seen by a user from "basic survival" to "comfortable living". 
Indeed. MDI cimM not' fulfill the above design goals without the compiler, assembler, structure 
editor, control-stack printer, context printer, pretty-printer, dynamic loader, and library system - all 
of which are nm pari of the interpreter but programs written in MDL and symbiotic with one 
another. Further information on these adjuncts can be found in Lebling's (1979) document. 



KEY WORDS: MDL 

Muddle 

Programming Languages 



(c) Copyright 1979 Massachusetts Institute of Technology. All rights reserved. 






The MDL Programming Language 



Acknowledgements 



I was no! a member of the original group which labored for two years in the design and initial 
implementation of Muddle; I hat group was composed principally of Gerald Sussman, Carl Hewitt, 
Chris Reeve. Dave Crcssey. and later Bruce Daniels. I would therefore like to take this opportunity 
to thank my Muddle mentors, chiefly Chris Reeve and Bruce Daniels, for remaining civil through 
several months of verbal badgering. I believe that I learned more than "just another programming 
lan^ua^c" in learning Muddle, and I am grateful for this opportunity to pass on some of that 
knowledge. What I cannot pass on is the knowledge gained by using Muddle as a system; that I can 
only ask you to share. 

For editing the content of this document and correcting some misconceptions, I would like to thank 
Chris Reeve. Bruce Daniels and especially Gerald Sussman, one of whose good ideas I finally did use- 
Greg Pf ister 
December 15. 1972 

Since Greg left the fold. I have taken up the banner and updated his document. The main sources 
for small revisions have been the on-line file of changes to MDL. for which credit goes to Neal 
Ryan as well as Reeve and Daniels, and the set of on-line abstracts for interpreter Subroutines, 
contributed by unnamed members of the Programming Technology Division. Some new sections 
were written almost entirely by others: Dave Lebling wrote chapter 14 and appendix 3. Jim Michener 
section 14.3. Reeve chapter 19 and appendix 1, Daniels and Reeve appendix 2. Brian Berkowitz 
section 22.7, Tak To section 17.2.2. and Ryan section 17.1.3. Sue Pitkin did the tedious task 
of marking phrases in the manuscript for indexing. Pitts Jarvis and Jack Haverty advised on the 
use of PUB and the XGP. Many PTD people commented helpfully on a draft version. 

My last has been to impose some uniformity and structure on these diverse sources (so that the 
result sounds less like a dozen hackers typing at a dozen terminals for a dozen days) and to enjoy 
some of the richness of MDL from the inside. I especially thank Chris Reeve ("the oracle") for the 
patience to answer questions and resolve doubts, as he no doubt has done innumerable times before. 

S. W. Galley 
May 23. 1979 



This work was supported by the Advanced Research Projects Agency of the Department of Defense 
and was monitored by the Office of Naval Research under contract N00014-75-C-0661. 

This document was prepared using the PUB system (originally from the Stanford Artificial 
Intelligence Laboratory) and printed on the Xerox Graphics Printer of the MAT, Artificial 
Intelligence Laboratory. 



The MDL Programming Language 



Foreword 

Trying to explain MDL to an un initiate is somewhat like trying to untie a Cordian knot. Whatever 
topic one chooses to discuss first, full discussion of it appears to imply discussion of everything 
else. What follows is a discursive presentation of MDL in an order apparently requiring the fewest 
forward references. It is not perfect in that regard; however, if you are patient and willing to 
accept a few. staled things as "magic" until they can be explained better, you will probably not have 
too many problems understanding what is going on. 

There arc no "practice problems": you are assumed to be learning MDL for some purpose, and your 
work ill achieving that purpose will be more useful and motivated than artificial problems. In 
several cases, the examples contain illustrations of important points which are not covered in the 
text. Ignore examples ai your peril. 

This document docs not assume knowledge of any specific programming language on the your part. 
However, "computational literacy" is assumed: you should have written at least one program before. 
Also, very little familiarity is assumed with the interactive time-sharing operating systems under 
which MDL runs -- ITS. Tenex. and Tops-20 - namely just file and user naming conventions. 









Notation: 

Sections marked [IJ are recommended for an uninitiate's first reading, in lieu of a separate 
introduction or primer for MDL. [On first reading, text within brackets like these should be 
ignored.] 

Most specifically indicated examples herein are composed of pairs of lines. The first line of a pair, 
the Input always ends in S (which is how the ASCII character ESC is represented, and which always 
represents it). The second line is the result of MDL's groveling over the first. If you were to type 
all the first lines at MDL. it would respond with all the second lines. (More exactly, the "first line" 
is one or more objects in MDL followed by S, and the "second line" is everything up to the next 
"first line".) 

Anything which is written in the MDL language or which is typed on a computer terminal appears 
herein in a gothic font, as in ROOT. A metasyntactic variable - something to be replaced in actual 
use by something else -- appears as rjcfficffi* in an italic font: often the variable will have both a 
meaning and a data type (as here), but sometimes one of those will be omitted, for obvious reasons. 



idicates that something uninteresting has been omitted. The character 



An ellipsis (...) indicates that something uninteresting has been omitted. The character means 
that the following character is to be "controllified": it is usually typed by holding down a terminal's 
CTRL key and striking the other key. 



The MDL Programming Language 



List of Chapters 






Page 


Name 


16 


1. Basic Interaction 


20 


2. Read. Evaluate and Print 


27 


3. Riiilr-in Functions 


30 


4. Values of Atoms 


35 


5. Simple Functions 


43 


6. Data Types 


52 


7. Structured Objects 


71 


8. Truth 


78 


9. Functions 


89 


10. Looping 


98 


II. Input/Output 


IIG 


12. Locatives 


120 


13. Association (Properties) 


124 


14. Data-type Declarations 


138 


15. Lexical Blocking 


146 


16. Errors. Frames, etc. 


152 


17. Macro-operations 


159 


18. Machine Words and Bits 


163 


19. Compiled Programs 


169 


20. Coroutines 


177 


21. Interrupts 


192 


22- Storage Management 


201 


23. MDL as a System Process 


204 


24. Efficiency and Tastefulness 



p 



The MDL Programming Language 
List of Sections 



Page Section 

16 Chapter 1. Basic Interaction 

16 I.I Loading MDL [I] 

16 1.2 Typing [I] 

18 1.3 Loading a File [I] 

18 1.4 Error* -- Simple Considerations [1] 

20 Chapicr 2. (tend. Evaluate, and Prim 

20 '21 Crucial [I] 

20 2.2 Philosophy (TYPE*) [i] 

21 2.3 Example (TYPE FIX) [I] 

22 2.1 Example (TYPE TL0A1) [I] 

22 2.5 Example {TYPE atom, pname) [I] 

22 2.6 Fife*. FLOAT*, and ATOM* versus READ: Specifics 

22 2.6.1 READ and FIXcd-pnint Numbers 

23 2.6.2 READ and PRINT versus FLOATing-point Numbers 

24 2-63 RFAO and I'HAMEs 
24 2.0.3.1 Non-PHAHEs 

24 2-F..3.2 Examples 

25 2.6.3.3 \ (Backslash) in ATOMs 

26 2.63.1 Examples of Awful ATOMs 

27 Chapter 3. Ilnilt-in Functions 
27 3.1 Representation [IJ 

27 3.2 Evaluation [I] 

28 3.3 Built-in Functions (TYPE SUBR, TYPE FSUBR) [1] 

28 3.4 Examples (+ and FIX; Arithmetic) [IJ 

29 3.5 Arithmetic: Details 

30 Chapter I Values of Atoms 
30 4.1 General [I] 

30 4-2 Global Values 

30 4.2.1 SETG[I] 

31 4.2 2 GVAL[1] 

31 4.2.3 Note on SUBRs and FSUBRs 

32 4.2.4 GUNAS5XGN 
32 4.3 Loral Values 
32 4.3.1 SCI [I] 

32 4.3.2 IVAL[I] 

33 4.3.3 UHASSIGN 
33 4.4 VALUE 

List of Sections 







The MDL Programming Language 



35 Chapter 5. Simple Functions 

35 5.1 General [I] 

35 5.2 Representation [I] 

36 5.3 Application of FUNCTIONS: Binding [I] 

39 5.4 Defining FUNCTIONS (FUNCTION and DEFINE) [I] 

40 5.5 Examples (Comments) [I] 

43 Chapter 6. Data Types 

43 6.1 General [1] 

43 6.2 Printed Representation [I] 

44 6.3 SUBRs Related to TYPEs 
44 6.3.1 TYPE (I) 

44 6.3.2 PRIMTYPE [I] 

45 6.3.3 TYPEPRIH [1] 

45 6.3. -I CHTYPE [1] 

46 6.4 More SUBRs Related to TYPEs 
46 6.4.1 ALLTYPES 

46 6.4.2 VALID-TYPE? 

46 6.4.3 NEWTYPE 

48 6.4.4 PRINTTYPE, EVALTYPE and APPLYTYPE 

52 Chapter 7. Structured Objects 

52 7.1 Manipulation 

52 7.1.1 LENGTH [I] 

52 7.1.2 NTH [I] 

52 7.1.3 REST [J] 

53 7.1.4 PUT [I] 
53 7.1.5 GET 

53 7.1.6 APPLYrng a FIX [I] 

54 7.1.7 SUBSTRUC 

54 7.2 Representation of Basic Structures 

54 7.2.1 LIST [I] 

54 7.2.2 VECTOR [I] 

54 7.2.3 UVECTOR [IJ 

55 7.2.4 STRING [I] 
55 7.2.5 BYTES 

55 7.2.G IFHPLATE 

55 7.3 Evaluation of Basic Structures [1] 

55 7.4 Examples [I] 

56 7.5 General inn of Basic Structures 
56 7.5.1 Direci Representation [I] 

56 7.5.2 QUOTE [I] 

57 7.5.3 LIST. VECTOR, UVECTOR. and STRING (the SUBRi) [1] 

57 7.5.1 HIST. IVECTOR. IUVECTOR. and ISTRING [1] 

58 7.5.5 FORM and IFORH 

List of Sections 



8 



The MDL Programming Language 



59 7.6 Unique Properties of Primitive TYPEs 

59 7.6.1 LIST (the PRIMTYPE)[1] 

59 7.6.1.1 PUTREST [1] 

59 7.6.1.2 CONS 

60 7.G.2 "Array" PRIHTYPEs [I] 
60 7.6.2.1 BACK [I] 

60 7.6.2.2 TOP [I] 

60 7.6.3 "Vector" PRIMTYPEs 

60 7.6.3.1 GROW 

6! 7.6.3.2 SORT 

63 7.G.I VECTOR (the PRIHTYPE) [1] 

63 7.6.5 UVECT0R One PRIHTYPE) [1] 

63 7.6.5.1 UTYPE[I] 

64 7.6.5.2 CIIUTYPE [I] 

64 7.6.6 STRING (the PRIHTYPE) and CHARACTER [I] 

65 7.C.G.1 ASCII [I] 
65 7.G.6.2 PARSE [I] 
65 ".6.6.3 LPARSE [I] 
65 7.6.6.4 UNPARSE [I] 

65 7.6.7 BYTES 

66 7.6.8 TEMPLATE 
66 7.7 SEGMENTS [1] 

66 7.7.1 Representation [1] 

67 7.7.2 Evaluation [1] 

67 7.7.3 Examples [1] 

68 7.7.4 Note on Efficiency [1] 

69 7.7.5 SEGMENTS ill FORM* [I] 
69 7.8 Self-referencing Structures 

69 7.8.1 Self-subset 

70 7.8.2 Self-element 

71 Chapter 8. Truth 

71 8.1 Truth Values [I] 

71 8.2 Predicates [I) 

71 8.2.1 Arithmetic [1] 

72 8.2.2 Equality and Membership [1] 
7$ 8.2.3 Boolean Operators [I] 

74 8.2.4 Object Properties [I] 

75 8.3 COND [I] 

75 8.3.1 Examples [I] 

76 8.4 Shortcuts with Conditionals 

76 8.4.1 AND and OR as Short CONDs 

77 8.4.2 Embedded Unconditional* 

78 Chapter 9. Functions 

List of Sections 



The MDL Programming Language 



78 9.1 "OPTIONAL" [I] 

79 9.2 TUPLES 

79 9.2.1 "TUPLE" and TUPLE ((he TVPE) [I] 

80 9.3.2 TOPI C (ihc SUDR) and ITUPLE 

81 9.3 "AUX" [I] 

82 !M QUOTEd arguments 

82 9.5 "ARGS" 

83 9.P "CALL" 

83 97 FVAL and "BIND" 

84 9.7.1 Local Values versus ENVIRONMENT* 

84 9.8 ACTIVATION. "NAME". "ACT", AGAIN, and RETURN [1] 

8G 9.9 Argument List Summary 

88 9.10 APPI Y [I] 

88 9.1 1 CLOSURE 

89 Chapter 10. I nnping 

89 101 PROG and REPEAT [I] 

89 I0.I.1 Itasic EVALuation [I] 

90 10.1.2 AC.AIN and RETURN in PROG and REPEAT [1] 

90 10.1.3 Examples [l] 

91 10.2 I1APF and MAPR: Basics [I] 

92 10.2.1 MAPr [I] 
92 10.2.2 MAPR [I] 

92 10.2.3 Fxauiples [1] 

94 10.3 More on MAPF and MAPR 

94 10.3.1 MAPRET 

95 10.12 MAPSTOP 
95 10.3.3 MAPl.f AVE 

95 10.3.4 Only two arguments 

96 10.3.5 STACKFORM 
9G |0.4 HO and TAG 

97 10.5 Looping versus Recursion 

98 Chapter II. Input/Output 
98 III Cnnvminn I/O 

98 ll.LI Input 

99 II.LI.l RCA0 

99 ll. 1 .1.2 REAI1CIIR 

W ILL! 3 NtXICHR 

99 11.1.2 Oulput 

99 U.l.2.1 print 

99 11.1.2.2 PR1N1 

100 11.1.2.3 PRINC 

100 II. 1.2.4 TERPRI 

100 11.1.2.5 CRLF 



List of Sections 



10 



The MDL Programming Language 



100 IM.16 FLATSIZE 

101 112 CHANHFI (the TYPE) 

101 11.21 OPEN 

102 1125 OPEN-NR 

102 112.3 CHANNEL (lite 5UBR) 

103 11.2.1 FILE-EXISTS? 
103 11.2.5 CLOSE 

163 M.2.6 CHANLIST 

103 11.2.7 IHCIIAN and OUTCHAN 

104 11.2.8 Contents of CHANNELS 

104 11.2.8.1 Output CHANNELS 

105 11.2.8 2 Input CHANNELS 

105 113 rnd-of-Filc "Routine" 

10ft u.J Imaged I/O 

10G U.M input 

106 11.41. 1 REAOB 

106 11.1.1.2 RF.ADSTR1NG 

106 11.4.2 Output 

106 M.4.2.1 PRIHTB 

106 11.4.2.2 PRINTSTRING 

107 11.1.2.3 IMAGE 
107 11.5 Dumped I/O 

107 11.5.1 Output: GC-DUHP 

107 11-5.2 Input: GC-REA0 

108 11-6 SAVf Files 

108 11.6.1 SAVE 

109 11.6.2 RFSTORE 

10f» 11.7 Other I/O Functions 

10H 11-7.1 IOAD 

110 11.7.2 FLOAD 
HO 11.7.3 SNAHE 
HO 117.4 ACCESS 

110 11-7.5 FILE-LENGTH 

111 11.7.6 FILECOPY 

111 11.7.7 RESET 
HI 11.7.8 BUI OUT 
HI 11.7.0 RENAME 

112 11.8 Terminal CHANNELS 

113 11-8.1 FCHOPAIR 
113 11.8-2 TTYfcCHO 
U3 11.8.3 IV! 

113 11.0 Internal CHANNEL* 

114 11.10 The "NET* Device: the ARPA Network 
U5 II.IM NETSTA1E 

115 11.10.2 NETACC 



List of Sections 



The MDL Programming Language u 



U5 II. 10.3 NETS 

116 Chapter 12. Locatives 

116 12.1 Obtaining Locatives 

116 12.1-1 LLOC 

117 12-1.2 GLOC 
117 I2.L3 AT 

117 12.1.4 GETPland GETL 

117 12.2 LOCATIVE? 

118 123 Using Locatives 
118 12.3.1 IN 

118 12.3.2 SETLOC 

119 12.4 Note on Locatives 

120 Chapter 13. Association (Properties) 
120 13.1 Associative Storage 

120 13.1.1 PUTPROP 

120 13.1.2 PUT 

120 13.1.3 Removing Associations 

121 13.2 Associative Retrieval 
121 13.2.1 GETPR0P 

121 13.2.2 GET 

121 13.3 Examples of Association 

123 13.4 Examining Associations 

124 Chapter 14. Hata-type Declarations 

125 14.1 Patterns 
128 14.2 Examples 

130 14.3 The 0ECL Syntax 

131 14.4 Good DECLs 
131 14.5 Global DECLs 

131 14.5.1 GDECL and MANIFEST 

132 14.5.2 MANITEST? and UNMANIFEST 

132 14.5.3 GBOUN0? 

133 14.6 NEWTYPE (again) 

134 147 Controlling DECL Checking 
134 |4.7.| DECL-CHECK 

134 117.2 SPECIAL-CHECK and SPECIAL-MODE 

134 14.7,3 GET-DECL and PUT-DECL 

135 14.7.4 DECL? 

135 H.8 OFFSET 

136 H.9 The RSUBR DECL 



138 Chapter 15. Lexical Blocking 
138 15.1 Basic Considerations 



List of Sections 



12 The MDL Programming Language 



139 15.2 0BLISTs 

139 15.2.1 OBLIST Names 

140 15.2.2 MOBLIST 
MO 15.2.3 OBLIST? 

140 15.3 READ and OBLISTs 

141 15.4 PRINT and OBLISTs 

141 15.5 Initial State 

142 I5.fi BLOCK and ENDBLOCK 

142 15.7 SUBRs Associated with Lexical Blocking 

142 15.7.1 READ (again) 

143 15.7.2 PARSE and LPARSE (again) 
143 15.7.3 LOOKUP 

143 15.7.4 ATOM 

143 15.7.5 REMOVE 

143 15.7.6 INSERT 

144 15.7.7 PNAHE 
144 15.7.8 SPNAHE 

144 15.8 Example: Another Solution lo the INC Problem 

146 Chapter 1G. Errors, Frames, etc 

146 1G.I LISTEN 

147 16.2 ERROR 

147 16.3 FRAME (the TYPE) 

148 16.3.1 ARGS 
148 16.3.2 FUNCT 

148 16.3.3 FRAME (the SUBR) 

148 16.3.4 Examples 

148 16.4 ERRET 

150 16.5 RETRY 

150 16.6 UNWIND 

150 16.7 Control-C TG) 

151 16.8 Coiitrol-S(~S) 

151 16.9 OVERFLOW 

152 Chapter 17. Macro-operations 
152 17.1 READ Macros 

152 17.1.1 % and %X 

153 17.1.2 LINK 

153 17.1.3 Program-defined Macro-characters 

153 17.I.3.I REAO (finally) 

155 17.1.3.2 Examples 

156 17.1.3.3 PARSE and LPARSE (finally) 
156 17.2 EVAL Macros 

156 17.2.1 DEFMAC and EXPAND 

157 17.2.2 Example 

List of Sections 



The MDL Programming Language 



159 Chapter 18. Machine Words and Bits 

159 18.1 WORIls 

160 18.2 BITS 

160 18.3 GETBITS 

161 18.4 PUTBITS 

161 18.5 Bitwise Boolean Operations 

162 18.6 Bitwise Shifting Operations 

163 Chapter 19. Compiled Programs 
163 19.1 RSUBR (the TYPE) " 

163 19.2 The Reference Vector 

164 19.3 RSUBR Linking 

164 19.4 Pure and Impure Code 

165 19.5 TYPE-C and TYPE-W 

165 19.6 RSUBR (the SUBR) 

166 19.7 RSUBR-ENTRY 

166 19.8 RSUBRs in Files 

167 19.9 Fixups 

169 Chapter 20. Coroutines 

169 20.1 PROCESS (the TYPE) 

170 20.2 STATE of a PROCESS 
170 20.3 PROCESS (the SUBR) 

170 20.4 RESUME 

171 20.5 Switching PROCESSes 

171 20.5.1 Starting Up a New PROCESS 

171 20.5.2 Top-level Return 

172 20.5.3 Symmetric RESUMEing 

173 20.6 Example 

173 20.7 Oilier Coroutining Features 

173 20.7.1 BREAK-5EQ 

174 20.7.2 MAIN 
'74 20.7.3 ME 

174 20.7.4 RESUMER 

174 20.7.5 SUICIDE 

175 20.7.G 1STEP 
175 20.7.7 FREE-RUN 

175 20.8 SncaUncss with PROCESSes 

176 20.9 Final Notes 

177 Chapter 21. Interrupts 

177 21. 1 Definitions of Terms 

178 21.2 EVENT 

179 21.3 HANDLER (the SUBR) 
179 21.4 OFF 



IS 



List of Sections 



14 The MDL Programming Language 



180 21.5 IHEAOER and HANDLER (the TYPEs) 

180 21.5.1 IHEAOER 

181 21.5.2 HANDLER 

181 21.6 Other SUBRs 

182 21.7 Priorities and Interrupt Levels 

182 21.7.1 Interrupt Processing 

183 21.7.2 INT-LEVEL 

183 21.7.3 DISMISS 

184 21.8 Specific Interrupts 

184 21.8.1 "CHAR" received 

185 21.8.2 "CHAR" wanted 

185 21.8.3 "CHAR" for new line 

186 21.8.4 "GC" 

186 21.8.5 "DIVERT-AGC" 

187 21.8.6 "CLOCK" 
187 21.8.7 "BLOCKED" 
187 21.8.8 "UNBLOCKED" 

187 21.8.9 "READ" and "WRITE" 

188 21.8.10 "SYS0OWN" 

188 21.8.11 "ERROR" 

189 21.8.12 "IPC" 

189 21.8.13 "INFERIOR" 

189 2I.8.M "RUNT" and "REALT" 

189 21.8.15 "Dangerous" Interrupts 

190 21.9 User-Defined Interrupts (INTERRUPT) 

191 21.10 Waiting for Interrupts 
191 21.10.1 HANG 

191 21-10.2 SLEEP 

192 Chapter 22. Storage Management 

192 22.1 Movable Garbage-collected Storage 

193 22.1.1 Stacks and Other Internal Vectors 

194 22.2 Immovable Storage 

194 22.2.1 Garbage-collected: FREEZE 

194 22.2.2 Non-garbage-collected: STORAGE (the PRIMTYPE) 

194 22.3 Other Storage 

195 22.4 Garbage Collection: Details 

195 22.5 GC 

196 22.6 BLOAT 

198 22.7 BLOAT-STAT 

199 22.8 GC-HON 

199 22.9 Related Subroutines 

199 22.9.1 SUBSTITUTE 

199 22.9.2 PURIFY 



List of Sections 



The MDL Programming Language 15 

201 Chapter '?.".. MDL as a System Process 
201 23.1 Tlrtfc 

201 23.2 Names 

202 23.3 EXiM 

202 23 4 Inter-proress Conimunicatioii 

202 23-1.1 SEND and SEN0-WAIT 

203 23.4.2 The "IPC" Interrupi 
203 23.4.3 IPC-OFF 

203 23.1.4 IPC-ON 

203 23.4. 5 DEMSIG 

204 Chapter 21 Efficiency and Tastcfulness 
201 24.1 Efficiency 

205 24.1.1 Example 

207 24.2 Creating a LIST in Forward Order 

208 24.3 Read-only Free Variables 
208 24.4 Global and Loral Values 

208 24.5 Making Offsets for Arrays 

209 24.G Tables' 
209 24.7 Nesting 

211 Appendix I. A Look Inside 

225 Appendix 2. Predefined Subroutines 

258 Appendix 3. Predefined Types 

260 Appendix 4. Error Messages 

265 Appendix 5. Initial Settings 

266 References 

267 Topic Index 
271 Name Index 



List of Sections 



l6 The MDL Programming Language 



Chapter 1. Basic Interaction 

The purpose nf this chapter is io provide you with (hat minimal amount of information needed to 
experiment with MDL while reading this document. It is strongly recommended that you do 
experiment, especially upon reaching chapter 5 (Simple Functions). 



I.I. Loading M DL [I] 

First, catch your rabbit. Somehow get the interpreter running - the program in the file SYS:TS MDL 
in the ITS version or SYS:MDl.SAV in the Tenex version or SYS:MDL.EXE in the Tops-20 version. 
The interpreter will first type out some news relating to MDL. if any. then type 

I.ISUN1HG-A1-UVEL 1 PROCESS \ 

and thru wait for you lo type something. 

The program which you are now running is an interpreter for the language MDL. AH it knows how 
to do is iniciptet MDL expressions. There is no special "command language"; you communicate 
with the program - make it do things for you -- by actually typing legal MDL expressions, which it 
then interprets. Fvrrything you can do at a terminal can be done in a program, and vice versa, in 
exactly the same way. 

The program will he referred to as just "MDL" (or "the interpreter") from here on. There is no 
ambiguity, since the program is just an incarnation of the concept "MDL". 



1.2. T yping [1] 

Typing a character at MDL normally just causes that character to be echoed (printed on your 
terminal) and remembered in a buffer. The only characters for which this is normally not true act 
as follows: 

Typing S (ESC) causes MDL to echo dollar-sign and causes the contents of the buffer (the characters 

1 . 1.2 Basic Interaction 



The MDL Programming Language .* 

which you've typed) to be interpreted as an expression^) in MDL. When Ihis interpretation is done 
the result will be printed and MDL will wait for more typing. ESC will be represented by the elyph 
£ in this document. 

Typing the rubout character (DEL in the ITS and Tops-20 versions, comrol-A it* the Tenex version) 
causes the last character in the buffer -- the one most recently typed -- to be thrown away (deleted). 
If you now immediately type another rubout. once again the last character is deleted - namely the 
second most recently typed. Etc. The character deleted is echoed, so you can see what you're doing. 
On some "display" lerminals. rubout will "echo" by causing the deleted character to disappear. If no 
characters are in the buffer, rubout echoes as carriage-return line-feed. 

Typing "<? (control-atsign) deletes everything you have typed since the last S, and prints a carriage- 
return line-feed. ■ 

Typing *D (coutrol-D) causes the current input buffer to be typed back out at you. This allows you 
to see what you really have, without the confusing re-echoed characters produced by rubout. 

Typing *t (control-L) produces Hie same effect as typing ~D, except that, if your terminal is a 
display" terminal (for example. IMLAC. ARDS. Datapoint). it first clears the screen. 




<ERRET T>S 

(This is discussed more fully far below, in section 16.4.) 

Typing *S (contrnl-S) causes MDL to throw awa^ what it is currently doing and return to a normal 
listen. ng state. (In the Tenex and Tops-20 versions, "0 also should have the same effect.) ~S is 
generally most useful for aborting infinite loops and similar terrible things. A S destroys whatever 
is going on. and so it is nm reversible. 

Most expressions in MDL include 'brackets" (generically meant) that must be correctly paired and 
nested. If you end your typing with the pair of characters IS (exclamation-point ESC), all currently 
unpaired brackets (hut not double-quotes, which bracket strings of characters) will automatically be 
paired and interpretation will start. Without the !, MDL will just sit there waiting for you to pair 
them. If you have improperly nested parentheses, brackets, etc.. within the expression you typed an 
error will occur, and MDL will tell you what is wrong. 

Once the brackets are properly paired. MDL will immediately echo carriage-return and line-feed, and 
the next thing it prints will be (he result of the evaluation. Thus, if a plain $ is not so echoed, you 

1-2 Basic Interaction 



18 The MDL Programming Language 



have some expression unclosed. In thai case, if you have not typed any characters beyond the S, 
you can usually rub out the S and other characters back to the beginning of the unclosed expression. 
Otherwise, what you have typed is beyond the help of rubout and *@; if you want to abort it, use 

MDL accepts and distinguishes between upper and lower case. All 'built-in functions" must be 
referenced in upper case. 



1.3. Loading a File [I] 

If you have a program in MDL that you have written as an ASCII file on some device, you can 
"load" it by typing 

<FLOAD tile>S 

where file is the name of the file, in standard operating-system syntax, enclosed in "s (double- 
quotes). Omitted parts of the file name are taken by default from the file name "DSK: INPUT >■ 
(in the ITS version) or "DSK: INPUT. MUD" (in the Tenex and Tops-20 versions) in the current disk 
directory. 

Once you type S, MDL will process the text in the file (including FLOAOs) exactly as if you had 
typed it on a terminal and followed it with i, except that "values" produced by the computations 
are not printed. When MDL is finished processing the file, it will print "DONE". 

When MDL starts running, it will FLOAD the file "MUDDLE INIT" (ITS version) or "MUDDLE. INIT* 
(Tenex and Tops-20 versions), if it exists. 



1.4. Errors - Simple Considerations [I] 

When MDL decides for some reason that something is wrong, the standard sequence of evaluation is 
interrupted and an error function is called. This produces the following terminal output: 

•ERROR* 

oft en-hyphenated-reason 

function-in- which-error -occurred 

LISTENING-AT-LEVEL integer PROCESS integer 

You can now interact with MDL as usual, typing expressions and having them evaluated. There 
exist facilities (built-in functions) allowing you to find out what went wrong, restart, or abandon 
whatever was going on. In particular, you can recover from an error - that is, undo everything but 



1-2 • 1-4 Basic Interaction 



The MDL Programming Language jg 



side effects ami return lo (he initial typing phase ~ by typing the following first line, to which 
MDL will respond With the second line: 

CERRET>$ 

LISTENING-AT-LEVEL 1 PROCESS 1 

If you type the following first line while still in the error state (before <ERRET». MDL will print. *& 
shown, the arguments (or "parameters" or "inputs" or "independent variables") which gave 
indigestion to the unhappy function: 

<ARGS <FRAME <fRAME»>S 

[ Arguments to unhappy function ] 

This will be explained by and by. 



1-4 Basic Interaction 



20 The MDL Programming Language 



Chapter 2. Read, Evaluate, and Print 



2.1. General [1] 

Once you type S and .nil brackets are correctly paired and nested, the current contents of the input 
buffer go through processing by three functions successively: first READ, which passes its output to 
EVAL ("evaluate"), which passes its output to PRINT, whose output is typed on the terminal. 

[Actually, the sequence is more like READ. CRLF, EVAL, PRIN1. CRLF (explained in chapter II); 
MDL gives you a carriage-return line-feed when the READ is complete, that is. when all brackets are 
paired] 

Functionally. 

READ: printable representations -•> MDL objects 

■ 

LVAL: MDL objects »> MDL objects 

PRINT: MDL objects --> printable representations 

That is. READ lakes ASCII text, such as is typed in at a terminal, and creates the MDL objects 
represented by that text. PRINT takes MDL objects, creates ASCII text representations of them, and 
types them out. EVAL, which is the really important one, performs transformations on MDL 
objects. 



2.2. Philosophy (TYPCs) [I] 

In a general sense, when you are interacting with MDL. you are dealing with a world inhabited only 
by a particular set of objects: MDL objects. 

MDL objects are best considered as abstract entities with abstract properties. The properties of a 
particular MDL object depend upon the class of MDL objects to which it belongs. This class is the 

2 • 2-2 Read, Evaluate, and Print 



The MDL Programming Language 



21 



TYPE of the MDL object. Every MDL object has a TYPE, and every TYPE has its own peculiarities. 
There are many different TYPEs in MDL: they will gradually be introduced below, but in the 
meantime here is a representative sample: SUBR (the TYPE of READ, EVAL and PRINT). FSUBR, LIST, 
VECTOR, FORM, FUNCTION, etc. Since every object has a TYPE, one often abbreviates "an object of 
TYPE type" by saying "a type". 

The laws of the MDL world are defined by EVAL. In a very real sense, EVAL is the only MDL object 
which "acts", which "docs something". In "acting", EVAL is always "following the directions" of some 
MDL object. Every MDL object should be looked upon as supplying a set of directions to EVAL; 
what these directions are depends heavily on the TYPE of the MDL object. 

Since EVAL is so ever-present, an abbreviation is in order: "evaluates to something" or "EVALs to 
something" should be taken as an abbreviation for "when given to EVAL, causes EVAL to return 

something". 

As abstract entities. MDL objects are. of course, not "visible". There is, however, a standard way of 
representing abstract MDL objects in the real world. The standard way of representing any given 
TYPE of MDL object will be given below when the TYPE is introduced. These standard 
representations are what READ understands, and what PRINT produces. 



:s 
d 

L 



2.3. Example (TYPE FIX) [I] 

IS 

1 

The following has occurred: 

First. READ recognized the character 1 as the representation for an object of TYPE FIX, in particular 
the one which corresponds to the integer one. (FIX means integer, because the decimal point is 
understood always to be in a fixed position: at the right-hand end.) READ built the MDL object 
corresponding to the decimal representation typed, and returned it 

Then EVAL noted that its input was of TYPE FIX. An object of TYPE FIX evaluates to itself, so 
EVAL returned its input undisturbed. 

Then PRINT saw that its input was of TYPE FIX, and printed on the terminal the decimal character 
representation of the corresponding integer. 



2.2 - 2.3 



Read, Evaluate, and Print 



22 



The MDL Programming Language 



2.4. Example (TYPE FLOAT) NT 

1.05 
1.0 

What went on was entirely analogous to the preceding example, except that the MDL object was of 
TYPE FLOAT. (FIOAT means a real number (of limited precision), because the decimal point can float 
around to any convenient position: an internal exponent part tells where it "really" belongs.) 



2.5. Example (TYPE ATOM, PNAME) f 11 

GEORGES 
GEORGE 

This time a lot more happened. 

READ noted that what was typed had no special meaning, and therefore assumed that it was the 
representation of an identifier, that is, an object of TYPE ATOM. ("Atom' means more or less 
indivisible.) READ therefore attempted to look up the representation in a table it keeps for such 
purposes [a 1 1ST of OBLISTs. available as the local value of the ATOM 08LIST]. If READ finds an 
ATOM in its table corresponding to the representation, that ATOM is returned as READ's value. If READ 
fails in looking up. it creates a new ATOM, puts it in the table with the representation read [INSERT 
into <1 .OBLIST> usually], and returns the new ATOM. Nothing which could in any way be 
referenced as a legal "value" is attached to the new ATOM. The initially-typed representation of an 
ATOM becomes its PNAME, meaning its name for PRINT. One often abbreviates "object of TYPE ATOM 
with PNAME name" by saying "ATOM name", 

EVAL, given an ATOM, returned just that ATOM. 

PRINT, given an ATOM, typed out its PNAME. 

At the end of this chapter, the question "what is a legal PNAME" will be considered. Further on. the 
methods used to attach values to ATOMs will be described. 



2.6. FIXes. FLOATs, and ATOMs versus READ: Specifics 

2.6.1. READ and FlXed-point Numbers 

READ considers any grouping of characters which are solely digits to be a FIX, and the radix of the 



2.4 - 2-6.1 



Read. Evaluate, and Print 



The MDL Programming Language 



2S 




aSuS"** '" l>r ° d " Ce a "* ° u,side """ r " ge ' *" overflow error wi " ' occur (unle " ix is 



The radix used by READ and PRINT is changeable by Che user: however, there are two formats for 
represent,....,,* of FIXes which cause READ to use a specified radix independent of the current one. 
The*e are a^ follows: 

(I) If a group of digits is immediate], followed by a period (.), READ interprets that group as 
the deeunal representation of a FIX. For example. 10. is always interpreted by READ as the 
decimal representation of ten. 

(21 If a group of digits is immediately enclosed on both sides by asterisks (•). READ interprets 
that group as the octal representation of a FIX. For example. «10» is always interpreted by 
READ as the octal representation of eight. 



2.6.2. READ and PRINT versus FLOATing-poiiit Numbers 

PRINT can produce, and READ can understand, two different formats for objects of TYPE FLOAT 
used fm , 1 dCC ""- ,| -|" ,i " , c " ou ' i01 '- 'I" ««»»■ l« Scientific" notation. Decimal radix is always 

used for representations of floats. * 

^Ci TSZ f T, a FL °f T C ° nSiSti ° f a " arbitraril > ,0 "S *""* <* digits containing one 

wi 1, X , f ? b> ' * JMSt 0,ie ** REA0 " m inake a FL0AT out of any such object, 

will, a limn of precision of one pari in 2 to the 27th power. 

Scientific" natation consists of: 

(ii a number, 

(2) immediately followed by E or e (upper or lower case letter E). 

(3) immediately followed by an exponent. 

Wh^iL"«Zv W "J S "■■ " bUr "" y '°" S **« ° f *»* wiIh ° r w ""°"' » decimal point (see 
"mm be - o - '" *?**. ' " P '° "" "*"' W °" h ° f FIX - Tllis "<»"">" "presents the 
a id f L " ''°" e '" P0,V " ° f ""' N0IB ' f "*< ■" U " ,ber " »« above would b > "«'f be a FIX. 

e ul w . IhnJ'rTv t " P04l " V . ft a " d ' f "" reiU " is Wilhi " "'« »"° wtd ""S* ° f «*«■ then the 
FLOAT) " a '" P " EAD U " d " i,a,,dS 10E1 " 100 < a «»■ »«« 10E-1 as 1. 0000000 (a 

r r adw') ar T| S '"" ,SS ,'! i '" de FL ° AT Wl ' iCl ' "" be l,a " dled wiII,out overflow is 1.7014U8E+38 (decimal 
radix). The smalles.-magnitude FLOAT which can be handled without underflow is .14693679E-38. 



2.6.1 - 2.6.2 



Read, Evaluate, and Print 



* 4 The MDL Programming Language 

2.6.3. READ and PNAMEs 

The question "what is a legal PNAME?" is actually not a reasonable one to ask: any_ non-empty string 
of arbitrary characters can be the PNAME of an ATOM. However, some PNAMEs are easier to type to 
REAP than others. Bui even the question "what are easily typed PNAMEs?" is not too reasonable, 
because: REAP decides thai a group of characters is a PNAME by default : if ii can't possibly be 
anything else, it's a PNAME. So. the rules governing the specification of PNAMEs are messy, and best 
expressed in terms nf what is not a PNAHE. For simplicity, you can just consider any uninterrupted 
group of upper- and lower-case letters and (customarily} hyphens to be a PNAME; that will always 
work. If you are neither a perfectionist nor a masochist, skip to the next chapter. 

2.6.3.1. Non-PNAMEs 

A group of characters is ucm a PNAHE if: 

(1) It represents a FLOAT or a FIX, as described above » that is, it is composed wholly of digits, 
or digits and a single . (period), or digits and a . and the letter E or e (with optional minus 
signs in the right places). 

(2) It begins with a . (period). 

(3) h contains « if typed interactively .- any of the characters which have special interactive 
effects: "9. "D, *L, "G, ~S. rt 0, S (ESC), rubout. 

(4) It contains a format character - space, carriage-return. linefeed, form-feed, horizontal tab, 
vertical lab. 

(5) It contains a , (comma) or a * (number sign) or a ■ (single quote) or a ; (semicolon) or a X 
(percent sign). 

(6) It contains any variety of bracket -- ( or ) or [ or ] or < or > or ( or } or " . 

In addition, the character \ (backslash) has a special interpretation, as mentioned below. Also, the 
pair of characters !- (exclamation-point hyphen) has an extremely special interpretation, which you 
will reach at chapter 15. 

The characters mentioned in cases 4 through 6 are "separators" •- that is, they signal to READ that 
whatever it was that the preceding characters represented, it's done now. They can also indicate the 
start of a new object's representation (all the opening "brackets" do just that). 

2.6.3.2. Examples 

The following examples are not in the "standard format" of "line typed in$ result printed", because 
they are not. in some cases, complete objects: hence. READ would continue waiting for the brackets to 

2.6.3 - 2.6.3.2 Readt Evaluate, and Print 



The MDL Programming Language 



25 



be closed. In other cases. they will produce errors during EVALuation if other -- currently irrelevant 
.- Gondii inns are not met. Instead, liic right-hand column will be used to state just what READ 
thought the input in the left-hand column really was. 



ABCS 
ahcS 



an ATOM of PNAME ABC 
an ATOM of PNAME abc 



ARBITRARILY-LONG-PNAMES an ATOM of PNAME ARBITRARILY-LONG-PNAME 

1.2345S a FLOAT, PRINTed as 1 .2345000 

1-2.345S an ATOM of PNAME 1.2.345 



A.or.BS 
.A.or.BS 

MORE THAN ONES 
ab(cdS 

12345A34S 
2.6.3.3. \ (Backslash) in ATOMs 



an ATOM of PNAME A.or.B 

not an ATOM, but (as explained later) a FORM containing 
an ATOM of PNAME A.or.B 

three ATOMs. with PNAMEs MORE, and THAN, and ONE 

an ATOM of PNAME ab, followed by the start of something 
else (The something else will contain an ATOM of PNAME 
beginning cd. ) 

an ATOM of PNAME 12345A34 (If the A had been an E, the 
object would have been a FLOAT. ) 



If you have a arrange, uncontrollable compulsion lo have what were referred to as "separators" above 
as part of Hie- PNAMFs of your ATOMs. you can do so by preceding them with the character \ 
(backslash). \ will also magically lurn an otherwise normal FIX or FLOAT into an ATOM if it appears 
amongst the digits. In fact, backslash in from of any character changes it from something special 
to jiim another character" (including the character \). It is an escape character. 

When PRINT confronts an ATOM which had to be backslashed in order to be an ATOM, it will 
dutifully type out the required \s. They will not, however, necessarily be where you typed them; 
they will instead he at those positions which will cause READ the least grief. For example, PRINT will 
type out a PNAME which consists wholly of digits by first typing a \ and then typing the digits - no 
matter where you originally typed the \ (or \s). 



2.6.3.2 - 2.6.3.3 



Read. Evaluate, and Print 



_ 



26 The MDL Programming Language 



2.6.3.4. Examples of Awful ATOMs 

The following examples illustrate ihc amount of insanity that can be perpetrated by using \. The 
format of the examples is again non-standard, this time not because anything is unfinished or in 
error, but because commenting is needed: PRINT doesn't do it full justice. 

a\ one\ and\ o\ twoS one ATOM, whose PNAHE has four spaces in it 

1234\56789$ an ATOM of PNAME 123456789, which PRINTS as 

\1234 56789 

123\ S an ATOM of PNAME 123space. which PRINTS as \123\ , 

with a space on the end 

\\S an ATOM whose PNAME is a single backslash 






2.6.3.4 Read. Evaluate, and Print 



The MDL Programming Language 27 



Chapter 3. Built-in Functions 



3.1. Repr esentation fJJ 

Up to this point, all the objects we have been concerned with have had no internal structure 
discernible in MDL. While the characteristics of objects with internal structure differ greatly, the 
way READ and PRINT handle them is uniform, to wit: 

READ, when applied to the representation of a structured object, builds and returns an object of 
the indicated TYPE with elements formed by applying READ to each of their representations in 
turn. 

PRINT, when applied to a structured object, produces a representation of the object, with its 
elements represented as PRINT applied to each of them iu turn. 

A MDL object which is used to represent the application of a function to its arguments is an object 
of TYPE FORM. Its printed representation is 

< func arg-I arg-2 . .. arg-N > 

where tut\c is an objpet which designates the function to be applied, and arg-1 through arg-N are 
objects which designate the arguments or "actual parameters" or "inputs". A FORM is just a 
structured object which is stored and can be manipulated like a LIST (its "primitive type" is LIST - 
chapter 6). The application of the function to (he arguments is done by EVAL. The usual meaning 
of "function" (uncapitalized) in this document will be anything applicable to arguments. 



3.2. Eval uation^ 

EVAL applied to a FORM acts as if following these directions: 

First, examine the tunc (first element) of the FORM. If it is an ATOM, look at its "value" (global or 
local, in that order - see next chapter). If it is not an ATOM, EVAL it and look at the result of the 

3-3-2 Built-in Functions 



The MDL Programming Language 

evaluation If what you arc looking a! is „oi something which can be applied to arguments. 
complain (via the ERROR function). Otherwise, inspect what you are looking at and follow its 
direction* ... evaluating or not evaluating the arguments (chapters 9 and 19) and then "apply the 
function - that is. EVAL the body of (he object gotten from tune. 



3.3. Built-in Functions (TYPE 5UBR, TYPE FSUBR) f I] 

The built-in functions of MDL come in two varieties: those which have all their arguments EVALed 
before operating on them (TYPE SUBR. for "subroutine', pronounced "subber") and those which have 
none of their argument* EVALed (TYPE FSUBR. historically from Lisp (Moon. 1974). pronounced 

effsiiliher ). Collectively tl.cy will be called F/SUBRs. although that term is not meaningful to the 
interpreter. See appendix 2 for a listing of all F/SUBRs and short descriptions. The term 

Subroutine w.ll be used herein to mean boll. F/SUBRs and compiled user programs (RSUBRs and 
RSUBR-CNTRYs- chapter 19). 5 

Unless otherwise .staled, everv MDL built-in Subroutine mentioned is of TYPE SUBR. Also, when it 
.* stated that an argument of a SUBR must be of a particular TYPE, note that this means that EVAL 
of what is there must he of the particular TYPE. 

Another convenient abbreviation which will be used is "the SUBR pname' in place of 'the SUBR which 
is initially the Value' of the ATOM of PNAME pname'. The FSUBR pname' will be used with a similar 
meaning. 



3.4. Examples (+ and FIX; Arithmetic! fl] 
<+ Z 4 6>S 

The SUBR * adds numbers. Most of the usual arithmetic functions are MDL SUBRs: + - « / 
MIN MAX. MOD. SIN, COS. ATAN. SORT, LOG. EXP, ABS. (See appendix 2 for short descriptions 
of these.) All except MOO. which wants FIXes. are indifferent as to whether their arguments are 
FLOAT or FIX or a .u.xtnre. In the last case, they exhibit "contagious FLOATing": one argument of 
TYPE FLOAT forces the result to be of TYPE FLOAT. 

<FIX 1.0>$ 

1 

The SUBR FIX explicitly returns a FIXcd-poiut number corresponding to a FLOATing-point number 
FLOAT does the opposite. 



FLOAT does the opposite 

<+ 5 <* 2 3»S 



32 _ 3 - 4 Built-in Functions 



The MDL Programming Language 



29 



11 

<SQRT <* <« 3 3> <* 4 4>»$ 

5.0 

<- 5 3 2>$ 



<- 5>S 

-5 

<MIN 1 2.0>$ 

1.0 

</ 11 7 Z.0>% 

0.5 



Note this last result: the division of two FIXes gives a FIX with truncation, not rounding, of the 
remainder: Hie intermediate result remains a FIX until a FLOAT argument is encountered. 



3.5. Arithmetic: Details. 



- A 



/. MIN, and MAX all take any number of arguments, doing the operation with the first 
argument and the second, then with that result and the third argument, etc. If called with no 
arguments, each returns the identity for its operation (0, 0, 1, 1, the greatest FLOAT, and the 
least FLOAT , respectively): if called with one argument, each acts as if the identity and the argument 
had been supplied, They all will cause an overflow or underflow error if any result, intermediate or 
final, is too large or too small for the machine's capacity. (That error can be disabled, if necessary 
- section IG.9). 



One arithmetic function that always requires some discussion is the pseudo-random-nuinber 
generator. MDI s is named RANDOM, and it always returns a FIX. uniformly distributed over the 
whole range of FIXes. If RANDOM is never called with arguments, it always returns the exact same 
sequence of numbers, for convenience in debugging. "Debugged" programs should give RANDOM two 
arguments on the first call, which become the seeds for a new sequence. Popular choices of new 
seeds are the numbers given by TIME (which see), possibly with bits modified (chapter 18). Example 
("pick a number from one to ten"): 

<+ 1 <M0D <RAND0M> 10»S 



3.4 - 3.5 



Built-in Functions 



1 



30 The MDL Programming Language 



Chapter 4. Values of Atoms 



4.1. General [1] 



There are two kinds of "value" which can be attached to an ATOM. An ATOM can have either, both, or 
neither. Thev interact in no way (except that alternately referring to one and then the other is 
inefficient*. TliCW two values are referred to as the local value and the global value of an ATOM. 
The terms "local" and "global" arc relative to PROCESSes (chapter 20). not functions or programs. 
The SUBRs which reference the local and global values of an ATOM, and some of the characteristic* 
of local versus global values, follow. 



4.2. Glob al V alues 

4.2-1. SETG[I] 

A global value can be assigned to an ATOM by the SUBR SETG ("set global"), as in 

<SE1G filom any> 

where Mom must EVAL to an ATOM, and any can EVAL to anything. EVAL of the second argument 
becomes the global value of EVAL of the first argument. The value returned by the SETG is its 
second argument, namely the new global value of atom. 

Examples: 

<SETG FOO <SETG BAR 500»S 
500 

The above made the global values of both the ATOM FOO and the ATOM BAR equal to the FIXed-point 
number 500. 

<SETG BAR T00>$ 

4 - 4.2-1 Values of Atoms 



The MDL Programming Language 



SI 



FOO 
That made the global value of the ATOM BAR equal to the ATOM FOO. 

4-2.2. GVAL[I] 

The SUBR GVAL ("global value") is used to reference the global value of an ATOM. 

<GVAL atom> 

returns as a value the global value of atom. If atom does not evaluate to an ATOM, or if the ATOM to 
which it evaluates has no global value, an error occurs. 

GVAL applied to an ATOM anywhere, in any PROCESS, in any function, will return the same value. 
Any 5ETG anywhere changes the global value for everybody. Global values are context-independent. 

REAO understands Hie character . (comma) as an abbreviation for an application of GVAL to 
whatever follows it. PRINT always translates an application of GVAL into the comma format. The 
following are absolutely equivalent: 

.atom CGVAL atom> 

Assuming the examples in section 4.2.1 were carried out in the order given, the following will 
evaluate as indicated: 

.roos 

500 

<GVAL F00>S 

500 

.BARS 

FOO 

..BARS 

500 

4.2.3. Note on SUBRs and FSUBRs 

The initial GVAls of the ATOMs used to refer to MDL "built-in - Subroutines are the SUBRs and FSUBRs 
which actually get applied when those ATOMs are referenced. If you don't like the way those 
supplied routines work, you are perfectly free to SETG the ATOMs to your own versions. 



4.2.1 - 4.2.3 



Values of Atoms 



The MDL Programming Language 



4.2-4. GUNASSIGN 

<GUNASSIGN atomy 

(-glob.il ...assign") causes atom to have no assigned global value, whether or not it had one 
previously. The storage used for the global value can become free for other uses. 



4.3. Local Values, 

4.3.1. SET [I] 

The SUBR SET is used to assign a local value to an ATOM. Applications of SET are of the form 

<SET atom any> 
SET returns EVAL of any just like SETG. 
Examples: 

<SET BAR <SET FOO 100»S 
100 

Both BAR and FOO have been given local values equal to ihe FlXed-point number 100. 

<5ET FOO BAR>S 

BAR 

FOO has been given the local value BAR. 

Note tha. neither of the above did anything to any global values FOO and BAR might have had. 

4-3.2. LVAL [1] 

The SUBR used m extract the local value of an ATOM is named LVAL- As witt i GVAL. READ 
understands an abbreviation for an application of LVAL: the character . (period), and PRINT 
produces it. The following two representations are equivalent, and when EVAL operates on the 
corresponding MDL object, it returns the current local value of atom-. 

<LVAL atom> -Worn 



4.24 - 4-3-2 Values of Atoms 






The MDL Programming Language 



33 



The local value of an ATOM is unique within a PROCESS. SETting an ATOM in one PROCESS has no 
effect on its LVAL in another PROCESS, because each PROCESS has its own "control stack" (chapters 
20 and 22). 

Assume a_H of the previous examples in this chapter have been done. Then the following evaluate as 
indicated: 

.BARS 

100 

<LVAL BAR>$ 

100 

.FOOS 

BAR 

, -FOOS 

FOO 



4.3.3. UNASSIGN 

<UNASSIGN Mom> 
causes Mom to have no assigned local value, whether or not it had one previously. 



.0 
T 



4.4. VALUE 

VALUE is a SUBR which takes an ATOM as an argument, and then: 

(1) if the ATOM has an LVAL, returns the LVAL; 

(2) if the ATOM has no LVAL but has a GVAL, returns the GVAL; 

(3) if the ATOM has neither a GVAL nor an LVAL, calls the ERROR function. 

This order of seeking a value is the opposite of that used when an ATOM is the first element of a 
FORM. The latter will be called the C/LVAL. even though that name is not used in MDL. 

Example: 

<UNASSIGN A>S 

A 

<SETG A 1>$ 

1 

<VALUE A>S 

1 

<SET A 2>S 



is 



4.3.2 - 4.4 



Values of Atoms 



34 



The MDL Programming Language 



<VALUE A>S 

2 

.AS 

1 



4.4 



Values of Atoms 



The MDL Programming Language 



35 



Chapter 5. Simple Functions 



5.1. Cenrrnl [I] 

The MDL equivalent of a "program" (uncoinpiled) is an object of TYPE FUNCTION. Actually, full- 
blown "programs" arc usually composed of sets of FUNCTIONS, with most FUNCTIONS In the set acting 

as "subprograms", 

A FUNCTION may be considered to be a SUBR or FSUBR which you yourself define. It is "run" by 
using a TORH in apply it to arguments (for example, function arg-1 arg-2 ... >). and it always 
"returns'' a single object, which is used as the value of the FORM that applied it. The single object 
may be ignored by whatever "ran" the FUNCTION - equivalent to "returning no value" -- or it may be 
a structured objcci containing many objects -equivalent to "returning many values". MDL is an 
"applicative" language, in contrast to "imperative" languages like Fortran. In MDL it is impossible 
to return values through arguments in the normal case: they can be returned only as the value of the 
FORM itself, or as side effects to structured objects or global values. 

In this Chapter a simple subset of the FUNCTIONS you can write is presented, namely FUNCTIONS 
which "act lil.e" SUBRs with a fixed number of arguments. While this class corresponds to about 90Z 
of the rUNCTIONs ever written, you won't be able to do very much with them until you read further 
and learn nmrc about MDL's control and manipulatory machinery. However, all that machinery is 
just a bunch of SUHRs and FSUBRs. and you already know how to "use" them: you just need to be told 
what they do. Once you have FUNCTIONS under your belt, you can immediately make use of 
everything presented from this point on in this document. In fact, we recommend that you do so. 



5.2. Representation [I] 

A FUNCTION is just another data object in MDL, of TYPE FUNCTION. It can be manipulated like any 
other data object. PRINT represents a FUNCTION like this: 

"FUNCTION {elements) 



5-5,2 



Simple Functions 



The MDL Programming Language 

that j». a number Sign, the ATOM FUNCTION, a left parenthesis, each of the elements of ihe 
FUNCTION, and a right parenthesis. Since PRINT represents FUNCTIONS like this, you can type them 
in to REAR this way. (But there are a few TYPEs for which that implication is false.) 

The elements of a FUNCTION can be "any number of anything*-; however, when you use a FUNCTION 
(apply it with a FORM). EVAL will complain if the FUNCTION does not look like 

'FUNCTION (act atom argumentsMst dec! body) 

where *et and dec' are optional (section 9.8 and chapter 14); body is at least one MDL object ~ any 
old MDI. object: and. in this simple case, arguments is 

( any number of ATOMs ) 

that is. something RFAD and PRINTed as: left parenthesis, any number - including zero - of ATOMs 
right parenthesis. (This is actually a normal MDL object of TYPE LIST, containing only ATOMs.) 

Thus, these niNCTIONs will cause errors - but only when used: 

"FUNCTION () -. no argument LIST or body 

'FUNCTION ((1) 2 7.3) - non-ATOM in argument LIST 

'FUNCTION ((A B C D)) - nobody 

"FUNCTION (<♦ 1 2> a C) -- no argument LIST 

These FUNCTIONS will never cause errors because of format: 

"FUNCTION (() 1 Z 3 4 5) 

"FUNCTION ((A) A) 

'FUNCTION <<)<)<)()()<)()()> 

FUNCTION ((A B C D EE F G H HIYA) <+ .A .HIYA>) 

"FUNCTION {(0) <SETG C <* .Q ,C» <♦ <M0D ,C 3> ,Q» 

and the last two actually do something which might be useful. (The first three are rather 
pathological, hut legal.) . 



§J^AgPJL^ a -iJP-»_P-f J UNCTION*; Binding \l) 
FUNCTIONS. like SUBRs and FSUBRs. are applied using FORHs. So, 
<*FUNCT10N {(X) <* .X .X>) 5>S 

applied the indicated FUNCTION to 5 and returned 25. 

5,2 " ** Simple Functions 












t! 






The MDL Programming Language «* 

What F.VAL does when applying a FUNCTION is the following: 

(1) Create a "world" in which the ATOMs of (he argument LIST have been SET to the value* 
applied to the FUNCTION, and all other ATOMs have their original values. This is called 
"binding". 

- In the above, this is a "world" in which X is SET to 5. 

(2) In that new "world", evaluate all the objects in the body of the FUNCTION, one after the 
other, frnni first to last. 

-- In the above, this means evaluate <• .X .X> in a "world" where X is SET to 5. 

(3) Throw away the "world" created, and restore the LVAU of all ATOMs bound in this 
application of the FUNCTION to their originals (if any). This is called "unbinding". 

-- In I he above, this simply gives X back the local value, if any. that it had before binding. 

(4) Return as a value the la^ value obtained when the FUNCTION'S body was evaluated in step 

- In the above, this means return 25 as the value. 

The "worW mentioned abovr is actually an object of TYPE ENVIRONMENT. The fact that such 
world, are separate from the FUNCTIONS which cause their generation means that all MDL 
FUNCTION^ can be used recursively. — 

The only thing that is at all troublesome in this sequence is the effect of creating these new 
worlds . in particular, the fact that the previous world is completely restored. This means that if 
ins.de a FUNCTION, you SET one of its argument ATOMs to something, that new LVAL will not be 
remembered when FVAL leaves the FUNCTION. However, if you SET an ATOM which is not Tn~the 
argument LIST (or 5ETG an^ ATOM) the new local (or global) value will be remembered. Examples: 

<SET X 0>$ 



^FUNCTION ((X) <SET X <- .X .X») 5>i 

25 

.XI 





5,3 Simple Functions 






The MDL Programming Language 



On the oihrr hand. 

<SET Y 0>S 



OFUNCTION ((X) <SET Y <» .X .X») 5)$ 

25 

.YJ 

25 

By using PRINT as a SUBR, we can "see" thai an argument's LVAL really is changed while EVALuating 
the body of a FUNCTION: * 

<5ET X 5>S 
5 

<#FUNCTI0N ((X) <PRINT .X> < + .X 10» 3>S 

3 13 

-XS 

5 

The first number after the application FORH was typed out by the PRINT; the second is the value of 

the application. 

Remembering thai LVAL* of ATOMs not in argument LIST* are not changed, we can reference them 
within FUNCTION*, at in b 

<SET Z 100>i 

100 

^FUNCTION <<Y) </ .Z .Y>) 5>$ 

20 

ATOMs used like I or Y in the above examples are referred to a* "free variables". The use of free 
variables, while often quite convenient, is rather dangerous unless you know exactly how a 
FUNCTION will alwajs be used; if a FUNCTION containing free variables is used within a FUNCTION 
Within a riiHCTlOM within . . .. one of those FUNCTION* might just happen to use your free variable 
In its argument LIST, binding it to some unknown value and possibly causing your use of it to be 
erroneous. Plentr note that "dangerous", as used above, really means that it may be effectively 
impossible (I) for other people to use your FUNCTIONS, and (2) for you to use your FUNCTION* a 
month (two weeks?) later. 






5,3 Simple Functions 






e 



B 



The MDL Programiiiiiig Language 3g 

5.4. Def i!ii_iig_KlNCTION s (FUNCTION and DEFINE) N1 

Obviously, typing FUNCTION (...) all the time is neither reasonable nor adequate for many 
purposes. Normally, you just want a FUNCTION to be the GVAL of some ATOM - the way SUBRs and 
FSUBRs nre -- so you can use it repeatedly (and recursively). Note that you generally do not want a 
FUNCTION to be the LVAL of an ATOM; ihis has the same problems as free variables. (Of course, there 
are always cases where you arc being clever and want the ATOM to be re-bound ) 

One way to "name" a FUNCTION is 

<SETG SQUARE ^FUNCTION ((X) <« .X .X>)>S 
((FUNCTION ((X) <* .X -X>) 



So that 



<SQUARE 5>J 

25 

<SQUARC 100>S 

10000 

Another way. which is somewhat cleaner in its typing: 

<SETG SQUARE FUNCTION (X) <« .X .X>»S 
^FUNCTION ((X) <■ .X .X>) 

FUNCTION is an r5U0R which simply makes a FUNCTION out of its arguments and returns the created 

FUNCTION . 

This, however, is generally the best way: 

<DEFIME SQUARE (X) <* .X .X»J 

SQUARE 

.SQUARES 

'FUNCTION ((X) <* .X .X>) 

The last two lines immediately above are just to prove that DEFINE did the "right thing". 

DEFINE Is a.. FSUBR which SFTGs EVAL of its first argument to the FUNCTION it makes from the rest 
w It* arguments, and then returns EVAL of its first argument. DEFINE obviously requires the least 

nFpVIS-** ""' aUme motl,ndi ' *" ri is " b " r from tl,al standpoint. However, the real reason for using 

"tFiNE is the following: If EVAL of DEFINE's first argument already has a GVAL. DEFINE produces an 

ror. This helps io keep you from accidently redefining things - like MDL SUBRs and FSUBRs. The 

G constructions should be used only when you really do want to redefine something. DEFINE will 

oe used in i he rc*t of this document. 

5 * Simple Functions 



The MDL Programming Language 

[Actually if i« " absolutely necessary to use DEFINE to 'redefine- things, there is a "switch" which 
can be used: if .he LVAL of the ATOM REDEFINE is T (or anything not of TYPE FALSE). DEFINE Will 
produce no errors. The normal stale can be restored by evaluating <SET REDEFINE <». See 
chapter 8.] 



5.5. Examples (Comments) II] 

Using SQUARE as defined above: 

(DEFINE IIYPOT (5I0E-1 SIDE-Z) 

;"This is a comment. This FUNCTION finds the 
length of the hypotenuse of a right triangle 
of sides SIDE-1 and SIDE-Z." 
<SQRT < + <SQ11ARE .SI0E-1> <SQUARE .SIDE-2»»S 
HYPO! 

<HYPOT 3 4>S 
5.0 

Note that rarriarr-rcturn*. linefeeds, labs. etc. are just separators, like spaces. A comment is ajjx 
single MDL object which follows a ; (semicolon). A comment can appear between any two MDL 
obiccts. A comment is totally ignored by EVAL but remembered and associated by READ with the 
place in ihr FUNCTION (or any other structured object) where it appeared. (This will become clearer 
after chapter 13.) The "s (double-quotes) serve to make everything between them a single MDL 
object. wI.om? TYPE is STRIMG (chapter 7). (SQRT is the SUBR which returns the square root of its 
argument. It always returns a FLOAT.) 

A whimsical FUNCTION: 

CDEFINE ONE (THETA) -."This FUNCTION always returns 1." 
<+ <S0UARE <SIN .THETA» 
(SQUARE <C0S .THETA»»$ 
ONE 

<ONE 5>I 
0.99999994 
<ONE O.Z3>J 
0.99999999 

ONE always returns (approximately) one. since the sum of the squares of sin(x) and cos(x) is unity 
for any x. (SIN and COS always return FLOATs, and each takes its argument in radians. ATAN 
(arctangent) returns its value in radians. Any other trigonometric function can be compounded 
from these three.) 







5.4 . 5.5 Simple Functions 






ge The MDL Programming Language ^j 

MDL doesn't have a general "lo (he power" SUBR, so let's define one using LOG and EXP (log base e, 
and e to a power, respectively: again, they return FLOATs). 

<DEFINE " (NUM PWR) <EXP <- .PWR <L0G .NUH»»S 

<«• 2 2>S 

4.000000) 
<*• 5 3>S 
125.00000 
<•* 25 0.5>S 
5.0000001 

Two FUNCTIONS which use a single global variable (Since the GVAL is used, it cannot be rebound.): 

<0EFINE START {) <SETG GV 0»X 

START 

<DEFINE STEP () <5ETG GV <+ ,GV 1>»S 

STEP 

<START>S 



<STEP>S 

1 

<S1EP>S 

2 

<5TEP>S 

3 

START and STEP lake no arguments, so their argument LISTs are empty. 
An interesting, hut pathological, FUNCTION: 

<DEFINE INC (ATM) <SET .ATM <+ ..ATM 1>»J 

INC 

<SET A 0>$ 



<INC A>$ 

1 

<INC A>S 

2 

.AS 

2 

INC takes an ATOM as an argument, and SETs that ATOM to its current LVAL plus 1. Note that inside 
INC. the ATOM ATM is SET to the ATOM which is its argument: thus ..ATM returns the LVAL of the 
grgument. However, there is a problem: 

5-5 Simple Functions 



42 



The MDL Programming Language 



<SET ATM 0>S 



<INC ATH>S 

"ERROR* 

ARG-WRONG-TYPE 

+ 

LI5TENIHG-AT-LEVEL 2 PROCESS 1 
<ARGS <FRAME <FRAHE»>S 
[ATM 1] 



The error occurred because .ATM was ATM, the argument to INC. and thus . .ATM was ATM also. We 
really want the outermost . in ..ATM to be done in the "world" (ENVIRONMENT) which existed just 
^efor^ INC was entered » and this definition of INC does both applications of LVAL in its own 
Techniques for doing INC "correctly* will be covered below. Read on. 



world 









T 
k 



5.5 



Simple Functions 






The MDL Programming Language 



43 



Chapter 6. Data Types 



6.1. General [I] 

A MDL object^ consists of two pans: its TYPE and its "data part" (appendix 1). The interpretation of 
the "data part" nf .in object depends of course on its TYPE. The structural organization of an object, 
that is. the way it is organized in storage, is referred to as its "primitive type". While there are 
many different TYPES of objects in MDL, there are fewer primitive types. 

All structured objects in MDL are ordered sequences of elements. As such, there are SUBRs which 
operate on all of them uniformly, as ordered sequences. On the other hand, the reason for having 
different primitive types of structured objects is that there are useful qualities of structured objects 
which are mutually incompatible. There are. therefore, SUBRs which do not work on all structured 
objects: these SUBRs exist to take full advantage of those mutually incompatible qualities. The 
inost-commnnly-nsed primitive types of structured objects are discussed in chapter 7, along with 
those special SUBRs operating on them. 



It is yery easy to make a new MDL object that differs from an old one only in TYPE, as long as the 
primitive type is unchanged. It is relatively difficult to make a new structured object that differs 
from an old one in primitive type, even if it has the same elements. 



Before talking any more about structured objects, some information needs to be given about TYPE* 
in general. 



6.2. Printed Representation [I] 

There are many TYPEs for which MDL has no specific representation. There aren't enough different 
kinds of brackets. The representation used for TYPEs without any special representation is 

ttypp represent Ation-3s-if-it-were-its-primitive-type 
READ will understand that format for any_ TYPE, and PRINT will use it by default. This 



6-6.2 



Data Types 



44 The MDL Programming Language 



representational format will be referred to below as "i notation". It was used above to represent 
FUNCTIONS. 



6.3. SUBRs Related to TYPEs 

6.3.1. TYPE [I] 

<TYPE any> 

returns an ATOM whose PNAME corresponds to the TYPE of any. There is no TYPE "TYPE". To type a 
TYPE (aren't homonyms wonderful?), just type the appropriate ATOM, like FIX or FLOAT or ATOM etc. 
However, in this document we will use the convention that a inetasyntactic variable can have type 
for a "data type": for example. foo:type means that the TYPE of foo is ATOM, but the ATOM must be 
something that the SUBR TYPE can return. 



Examples: 



<TYPE m 

FIX 

<TYPE 1.0>$ 

FLOAT 

<TYPE +>S 

ATOM 

<TYPE . + >$ 

SUBR . 

<TYPE GEORGE>S 

ATOM 



6.3.2. PRIM1YPE [I] 

< PRIMTYPE any) 



evaluates to the primitive type of any. The PRIMTYPE of any is an ATOM which also represents a 
TYPE. The way an object can be manipulated depends solely upon its PRIMTYPE; the way it is 
evaluated depends upon its TYPE. 



Examples: 



^PRIMTYPE 1>$ 

UORD 

<PRIMTYPE 1.0>J 



6.2 - 6.35 Data Type* 



g e 



The MDL Programming Language 



45 



nt 



WORD 

<PRIMTYPE .+>$ 

WORD 

<PRIMTYPE GE0RGE>$ 

ATOM 



6.3.3. TYPEPRIH[1] 

<TYPEPRIM lype> 
returns lt,« PR1MTYPE of an object w|, 0S e TYPE is tyP& . type is, as usual, an ATOH used to designate « 



TYPE. 



Examples: 



<TYPEPRIM FIX>$ 

WORD 

<TYPEPRIH FLOATH 

WORD 

<TYPEPRIM SUBR>S 

WORD 

<TYPEPRIM ATOH>$ 

ATOH 

<TYPEPRIM F0RH>S 

LIST 



J 



is 



6.3.4. CHTYPE [Ij 

<CHTYPE any type> 
Tchange type") returns a new object that has TYPE type and the same "data part" as any (appendix 

<CHTYPE (* 2 2) F0RM>$ 
<+ 2 2> 

alsoTo ' " ge " era,ed ' 7 tl,P PRIMTYPE ° f 3ny h not ,l,e 5amc « < he TYPEPRIM of lype. An error will 

Stjsrsis tt chty : e is da,,gerous a,,d/or "-■» f - »■£* ««£! 

a 5UBR. Unfortunately, there are few useful examples we can do at this point 

S2S?wi2? ,0 * r« AT ° r ViW m5a pr ° dUCe5 ' in gCneral - nonsense ' 5ince the bil for ™" for 
and FLOATS are different. The SUBRs FIX and FLOAT convert between those formats. Useful 



6-3.2 - 6.3.4 



Data Types 



46 The MDL Programming Language 

obscurity: because of their internal representations on Hie PDP-iQ. <CHTYPE <HAX> FIX> gives the 
least possible FIX, ami analogously for MIN.] 

Passing note: "* noialion" is just an instruction to READ saying "READ the representation of the 
PRIMTYPE normally anil (literally) CHTYPE it to the specified TYPE". [Or. if the PRIMTYPE is 
TEMPLATE, "apply the GVAL of the TYPE name (which should be a TEMPLATE constructor) to the given 
elements of the PRIMTYPE TEMPLATE as arguments."] 






6.4. More SUBRs Related to TYPEs 

6.4.1. ALLTYPE5 

<ALLTYPES> 

returns a VECIOR (chapter 7) containing just those ATOHs which can currently be returned by TYPE 
or PRIMTYPE. This is the very "TYPE vector" (section 22.1) that the interpreter uses: look, but don't 
touch. No examples; try it. or see appendix 3. 

6.4.2. VALID-TYPE? 

<VALID-TYPE? afom> 

returns JFAL5E ( ) if Mom is not the name of a TYPE, and the same object that <TYPE-C atom> 
(section 19.5) returns if it is. 

6.4.1 NEWTYPC 

MDL is a type-extensible language, in the sense that the programmer can invent new TYPEs and use 
them in every way that the predefined TYPEs can be used. A program-defined TYPE is called a 
NEWTYPE- New PRIMTYPEs cannot be invented except by changing the interpreter: thus the TYPEPRIM 
of a NEWTYPE must he chosen from those already available. But the name of a NEWTYPE (an ATOM of 
course) can be rlmsen freely - so long as it does not conflict with an existing TYPE name. More 
importantly, the program that defines a NEWTYPE can be included in a set of programs for 
manipulating objects of the NEWTYPE in ways that are more meaningful than the predefined SUBRs 
of MDL. 

Typically an object of a NEWTYPE is a structure that is a model of some entity in the real world - or 
whatever world the program is concerned with - and the elements of the structure are models of 
parts or aspects of I lie real-world entity. A NEWTYPE definition is a convenient way of formalizing 

6.3.4 - 6.4.3 Data Type* 



-j age 



the 



the 
E is 

iven 



The MDL Programming Language 



47 



TYPE 
lon't 



tom> 






I use 
ed a 
PRIM 
<Mof 
vlore 
for 
UBRs 



- or 

Is of 
zing 



this correspondence, of writing it down for all to see and use rather than keeping it in your head. 
If the defining set of programs provides functions for manipulating the NEWTYPE objects in all 
ways thai arc meaningful fnr the intended uses of the NEWTYPE. then any other program that wants 
to use the HEW TYPE can call the manipulation functions for all its needs, and it need never know or 
care about the interna! details of the NEWTYPE objects. This technique is a standard way of 
providing modularity and abstraction. 

For example. suppose you wanted to deal with airline schedules. If you were to construct a set of 
programs that define and manipulate a NEWTYPE called FLIGHT, then you could make that set into a 
standard package of programs and call on it to handle all information pertaining to scheduled 
airline flight*. Since all FLIGHT* would have the same quantity of information (more or less) and 
you would want quick access to individual elements, you would not want the TYPEPRIM to be LIST. 
Since the elements would be of various TYPEs. you would not want the TYPEPRIM to be UVECTOR » 
nor its variations STRING or BYTES. The natural choice would be a TYPEPRIM of VECTOR (although 
you could gain spare and lose time with TEMPLATE instead}. 

Now. the individual elements of a FLIGHT would, no doubt, have TYPEs and meanings that don't 
change. The elements of a FLIGHT might be airline code, flight number, originating-airporl code, 
list of intermediate stops, destination-airport code, type of aircraft, days of operation, etc. Each and 
every FLIGHT would have the airline code for its first element (say), the flight number for its second, 
and so on. It is natural to invent names (ATOMs) for these elements and always refer to the elements 
by name. Fnr example, you could <SETG AIRLINE 1> or <SETG AIRLINE <OFFSET 1 FLIGHT» - 
and in either case <MANIF£ST AIRLINF> so the compiler can generate more efficient code. Then, if 
the local value of F were a FLIGHT, <AIRLIHE ,F> would return the airline code, and <AIRLINE .F 
AA> would set the airline code to AA. Once that is done, you can forget about which element comes 
first: all you nerd to know arc the names of the offsets. 

The next step is 10 notice that, outside the package of FLIGHT functions, no one needs to know 
whether AIRLINE is just an offset or in fact a function of some kind. For example, the scheduled 
duration of a flight might not be explicitly stored in a FLIGHT, just the scheduled times of 
departure and arrival. But. if the package had the proper DURATION function for calculating the 
duration, then (he call DURATION .F> could return the duration, no matter how it is found. In this 
way the internal details of the package are conveniently hidden from view and abstracted away. 

The form of NEWTYPE definition allows for the TYPEs of all components of a NEWTYPE to be declared 
(chapter IP. for use both by a programmer while debugging programs that use the NEWTYPE and by 

nputvo 1 ^'" f ° r K cncr * lin S f * sfor codc - U is v «y convenient to have the type declaration in the 
tWTYPfc definition itself, rather than replicating it everywhere the NEWTYPE is used. (If you think 
this declaration might be obtrusive while debugging the programs in the NEWTYPE package, when 
'"consistent improvements are being made to various programs, you can either disassociate any 
aeclarat.on from the NEWTYPE or turn off MDL type-checking completely. Actually this declaration 
'5 typically more useful to a programmer during development than it is to the compiler.) 

< NEWTYPE atom type> 



ype* 



6.4.3 



Data Types 



48 



The MDL Programming Language 






returns atom, after musing it to become the representation of a brand-new TYPE whose PRIMTYPE is 
<TYPEPRIM t\pr>. What NEWTYPE actually does is make atom a legal argument to CHTYPE and 
TYPEPR1M. (Note that names of new TYPEs can be blocked lexically to prevent collision with other 
names, just like any other ATOM* -- chapter 15.) Objects of a NEWTYPE-created TYPE can be generated 
by creating an object of the appropriate PRIMTYPE and using CHTYPE. They will be PRINTed 
(initiallyl. and can he directly typed in. by the me of "# notation" as described above. EVAL of any 
object whose TYPE was created by NEWTYPE is initially the object itself, and, initially, you cannot 
APPLY something nf a generated TYPE to arguments. But see below. 






Examples: 



<NEWTYPE GARGLE FIX>S 

GARGLE 

<TYPEPRIM GARGLE>S 

WORD 

<SET A <CHTYPE 1 GARGLE»S 

*GARGLE "000000000001" 

<5ET B 4GARGLE 100>S 

'GARGLE *000000000144« 

<TYPE .R>S 

GARGLE 

<PR1HTYPE -B>S 

WORD 



6.4.4. PRINTTYPE. EVALTYPE and APPLYTYPE 

<PR1NTTYPE type how> 

<EVALTYPE type how> 

<APPLYTYPE type how> 

all return type, after specifying how MDL is to deal with it. 

These three SUBRs can be u<ed to make newly-generated TYPEs behave in arbitrary ways, or to 
change (he characteristics of standard MDL TYPEs. PRINTTYPE tells MDL how to print type. 
EVALTYPE how to evaluate it. and APPLYTYPE how to apply it in a FORM. 

how can be cither a TYPE or something that can be applied to arguments. 

If how is a TYPE, MDL will treat type just like the TYPE given as how. how must have the same 
TYPEPR1M as type. 



If how is applicable, it will be used in the following way: 

6.4.3 • 6.4.4 



Data Types 



a g* 



The MDL I'mgraininint; Language 



49 



E is 

and 
her 
ited 
Ted 
iny 
not 



For PRINTIYPE. *>« *mM lake one argument: ,|„ object being output, how should output 
something Without roniMUlng <PRINl- it ylc>: its result is ignored. (Note: how cannot use an output 

SUBR on hows own i >pes endless recursion will re OUTCHAN is bound during the application to 

the CHANNEL in use. or in a pseudo-internal channel for FLATSIZE - chapter II ) If howh the SUBR 
PRINT, type will receive no special treatment in printing, that is, it will be printed as it was in an 
initial MUL or immediately after its defining NEWTYPE. 

For EVALTYPE. hpw should tale one argument: the object being evaluated. The value returned by 
how will be used as EVAL of the object. If how is the SUBR EVAL. type will receive no special 

treat iiicm: in evaluation. r 

For APHYTYPE how should lake at least one argument. The first argument will be the object being 
applied: the res, will he the objects i, was given as arguments. The result returned by how will be 
used as he r«ul. of the application. If how j $ lhe SUBR APPLY, lype will receive no special 
treatment In application to arguments. c«-'*» 

ILive t J'r^ " SiVC " W" ST* ,hat j$ if h ° W iS ° miUed ' il retUr » S *• «"«««> 

;r«;:;;ri„in;, Y ipe;;u:: app,,cablc **■* or e * ' false » if *»• * ■***<■* - *-J 

Unfortunately, these examples are fully undefendable only after you have read through chapter 11. 

<DEFINE ROMAN-PRINT (NUMB) 
<COND (<0R <L=? .NUMB 0> <G? .NUMB 3999» 
<PRINC <CHTYPE .NUMB TIME))) 
(T 

<RCPR1NT </ .NUMB I000> ( ![!\M]> 
<RCPRINT </ .NUMB 100> '![!\C !\D !\M]> 
<RCPRINT </ .NUMB 10> '![!\X !\l '\C]> 
<RCPRINT .NUMB 

ROHAN-PRINT 



![!\I !\V !\X]>)»S 



<0EriNC RCPRJNT (MOON V) 
<5E7 MOON <M0D .HODN 10» 



<COND (<==? 
(<«? 
(< = = ? 
(<«? 
(< = = ? 
(<==? 
(< = = ? 
(< = = ? 
(< = = ? 



<PRINC <Z 
<PRINC <1 



.MODN)) 

.MO0N> <PRINC <1 
.MOON) <PRINC <1 
.MODN) <PRINC <1 
■MOON) <PRINC <1 
-MODN) <PRINC <2 
.MODN) <PRINC <2 
.MOON) <PRINC <2 
-MOON) 

.V» 

.V)) 



.V)>) 

.V» <PRINC <1 

.V» <PRINC <1 

.V)> <PR1NC <2 

.V))) 

•V)> <PRINC <1 

-V)> <PRINC <1 



.V))) 

•V)) <PRINC <1 .V)>) 
-V))) 

.V») 

.V)> <PRINC <1 .V») 



pes 



6.4.4 



Data Types 



50 The MDL Programming Language 



<PRINC <1 .V» 

<PR1NC <1 .V») 

(< = = ? 9 .H0DN> <PRINC <1 .V» <PRINC <3 .V»)»S 
RCPRINT 

<PRINTTYPE TIME FIX> ;'fairly harmless but necessary here's 

TIME 

<PRINTTYPE FIX ,R0MAN-PRINT> ;'hee heei'S 

rix 

<+ 2 2>S 
IV 

1984S 

MCMLXXXIV 

<PRINTTYPE FIX ,PRINT>S 

FIX 

<NEWFYPE GRITCH LIST> ;'a new TYPE of PRIMTYPE LIST'S 

GRITCH 

<EVALTYPE GRITCH>S 

•TALSE () 

<EVALTYPE GRIICH LIST> devaluated like a LIST'S 

GRITCH 

<EVALTYPE GRITCH>S 

LIST 

(*GR1TCM (A <♦ 1 t 3> KSET A 'ABC'» ;'Type in one.'S 

#GRITCH (A 6 !\A l\B !\C) 

<NEWTYPE HARRY VECTOR) ;'a new TYPE of PRIMTYPE VECTOR'S 
HARRY 

<EVALTYPE HARRY 'FUNCTION ((X) <1 .X»> 

; n When a HARRY is EVALed, return its first element. "S 
HARRY 
-HARRY [1 2 3 4]S 

1 

<NEWTYPE WINNER LIST> ;'a TYPE with funny application's 

WINNER 

<APPLYTYPE WINNER>S 

("FALSE ( ) 

<APPLYTYPE WINNER <FUNCTI0N (W 'TUPLE' T) ( ! .V !.T)»S 

WINNER 

<APPLYTYPE WINNER>S 

FUNCTION ((W "TUPLE' T) ( ! .W !.T)) 

<»-WlNNER (A B C) <+ 1 2> q>S 

(A B C 3 q) 



6.4.4 Dau Type* 






:« 



The MDL Programming Language 



51 



The following sequence makes MDL look just like Lisp. (This example is understandable only if 
you know Lisp (Moon. 1974); it is included only because it is so beautiful.) 



CEVALTYPE LIST FORM>X 

LIST 

<EVALTYPE ATOH ,LVAL>$ 

ATOM 



So now: 



(♦ 1 2)$ 

3 

(SET 'A 5)S 

5 

AS 

5 

To complete the job. of course, we would have to do some SETG's: car is I, cdr is f REST, and 
lambda is .FUNCTION. If you really do this example, you should "undo" it before continuing: 

<EVALTYPE "ATOM ,EVAL>S 

ATOM 

<EVALTYPE LIST ,EVAL>4 

LIST 



6.4.4 



Data Types 



52 



The MDL Programming Language 



Chapter 7. Structured Objects 



This chapter discusses structured objects in general and the five basic structured PRIHTYPEs. [We 
defer detailed discussion of the structured PRIHTYPEs TUPLE (section 9.2) and STORAGE (section 
22.2.2).] 



7.1. Manipulation 

The following SUBRs operate uniformly on all structured objects and generate an error if not 
applied to a structured object. Hereafter, structured represents a structured object 



7.1.1. LENGTH [1] 

< LENGTH structured> 
evaluates to the number of elements in structured. 

7.1.2. NTH [1] 

<NTH structured fix> 

evaluates to the fixih element of structured. An error occurs if fix is less than 1 or greater than 
< LENGTH structured>. fix is optional. 1 by default. 

7.1.3. REST [1] 

<REST structured fix> 
evaluates (o structured without its first fix elements, fix is optional, 1 by default 
Obscure but important side effect: REST actually returns structured "CHTYPEd" (but not through 



7 - 7.1 J 



Structured Objects 



The MDL Programming Language 



53 



applicaiion nf CHTYPE) lo its PRIMTYPE. For example, REST of a FORM is a LIST. REST with an 
explicit second argument of lias no effect except for this TYPE change. 



/e 
>n 



7.1.4. PUT [I] 

<PUT structured fix anything-lega!> 

first makes anythin?~lepal the ffxth element of structured, then evaluates to structured, anythtng-tegal 
is anything which can legally be an element of structured, often, this is synonymous with "any MDL 
object", but sec below. An error occurs if fix is less than 1 or greater than <IENGTH structured>. 
(PUT is actually more general than this -- chapter 13.) 



7.1.5. GET 



ot 



<GET structured (ix> 

evaluates the same as <NTH structured fix>. It is more genera] than NTH, however (chapter 13), and 
is included here only for symmetry with PUT. 



in 



7.1.8. APPLYing a FIX [I] 

EVAL understands the application of an object of TYPE FIX as a "shorthand" call to NTH or PUT, 
depending on whether it is given one or two arguments, respectively [unless the APPLYTYPE of FIX is 
changed]. That is, EVAL considers the following two to be identical: 

<fix structurcd> 
<NTH structured fix> 

and these: 

<tix structured object > 
<PUT structured fix object> 

[However, the compiler (Lebling. 1979) cannot generate efficient code from the longer forms unless 
't is sure that ff* is a FIX (section 9.10). The two constructs are not identical even to EVAL, if the 
order of evaluation is significant: for example, these two: 

<NTH .X <LENGTH <SET X .Y>» «LENGTH <SET X .Y» .X> 
are nm identical.] 



rh 



7.1.3-7.1.6 



Structured Objects 



54 



The MDL Programming Language 



7.1,7. SUBSTRUC 

SUBSTRUC ("substructure") facilitates f he construction of structures thai are composed of sub-parts of 
existing structure*. A special case of [his would be a "substring" function. 

<SUBSTRUC from:$tructured resl:fix amounttfix to:siructurea"> 

copies the first amount elements of <RE5T from rest> into another object and returns the latter. All 
arguments arc optional except from, which must be of PRIHTYPE LIST, VECTOR, TUPLE (treated like 
a VECTOR). STRING, BYTES, or UVECTOR. rest is by default, and amount is all the elements by 
default, to. if given, receives the copied elements, starting at its beginning; il must be an object 
whose TYPE is the PRIHTYPE of from (a VECTOR if from is a TUPLE). If to is not given, a new object is 
returned, nf TYPE < PRIHTYPE from> (a VECTOR if from is a TUPLE), which never shares with from. 
The copying is done in one fell swoop, not an element at a time. Note: due to an implementation 
restriction, if from is of PRIHTYPE LIST, it must not share any elements with to. 



7.2. Rep resentation of B asic Structures 

7.2.1. LIST [1] 

( element- 1 element-2 etement-N ) 

represents a LIST of N elements. 

7.2.2. VECTOR [I] 

[ clement- 1 elcment-2 element-N ] 

represents a VECTOR of N elements. [A TUPLE is just like a VECTOR, but it lives on the control stack.] 

7.2.3. UVECTOR [1] 

![ clement- 1 element-2 ... element-N !] 

represents a UVECTOR (uniform vector) of N elements. The second ! (exclamation-point) is optional 
for input. [A STORAGE is an archaic kind of UVECTOR that is not garbage-collected.] 



7.1.7 -7.2.S 



Structured Objects 



lage 



The MDL Programming Language 



55 



5 of 



AH 

like 

by 

jeci 

:t is 

rorru 

tion 



7.2.4. STRING [I] 

"characters" 

represents a STRING of ASCII text. A STRING containing the character - (double-quote) is 
represented by placing a \ (backslash) before the double-quote inside the STRING. A \ in a STRING 
is represented by two consecutive backslashes. 

7.2.5. BYTES 

Mn {element- I element-2 ... element-N} 
represents a string of N uniformly-sized bytes of size n bits. 

7.2.6. TEMPLA1E 

{ element- 1 element-2 ... element-N ) 

JS 3 TEMPLATE ° f "**"*"* w *« 0U 'P«<. not input - when input, a * and a TYPE must 



ck.] 






7.3. Evaluation »f Basic Structures fl] 

EVAL of a STRING [or BYTES or TEMPLATE] is just the original object. 

«*lTZTl 'fVAlT T E* V ! CT0RS * "^ UVECT0Ri: " *»««" a new object with 
constructing a structure. However, see section 7.7. 



>nal 



ecu 






L4. Example [i] 



(1 2 <♦ 3 4>)S 
(1 Z 7) 

<SET F00 [5 <- 3> <TYPE "A8C">]>S 
[5 -3 STRING] 
<Z -FOO>S 



7.2.4 - 7.4 



Structured Objects 



56 The MDL Programming Language 



-3 

<TYPE <3 .F00>>i 

ATOM 

<SET BAR ![("meow") (.F00)]>$ 

![("moow") ([5 -3 STRING])!] 

(LENGTH .BAR>$ 

2 

<REST <1 <2 -BAR>»S 

[-3 STRING] 

[<5U85TRUC <1 <2 .BAR» 2>]S 

[[5 -3]] 

<PUT .KOO 1 SNEAKY> ;"Watch out for .BAR !"S 

[SNEAKY -3 STRING] 

.OARS 

([("meow") ([SNEAKY -3 STRING])!] 
<SET FOO <REST <1 <1 .BAR» 2»$ 

"ow" 

.BARS 

![("meoW) ([SNFAKY -3 STRING])!] 



7.5. Generatio n of Hasic Structures 

Since LISTs. VECTORS. UVECTORs. and STRING* [and BYTESes] are all generated in a fairly uniform 
manner, methods of generating them will be covered together here. [TEMPLATE* cannol be generated 
by the interpreter itself: see I.ebling (1979).] 



7.5.1. Direct Representation [I] 

Since EVAL of a LIST, VECTOR, or UVECTOR is a new LIST, VECTOR, or UVECTOR with elements which 
are EVAL of the original elements, simply evaluating a representation of the object you want will 
generate it. (Care must be taken when representing a UVECTOR that all elements have the same 
TYPE.) This method of generation was exclusively used in the examples of section 7.4. Note that 
new STRIHGs [and BYTESes] will not be generated in this manner, since the contents of a STRING are 
not interpreted or copied by EVAL. The same is true of any other TYPE whose TYPEPRIM happens to 
be LIST, VFCTOR. or UVECTOR [again, assuming it neither has been EVALTYPEd nor has a built-in 
EVALTYPE, as do FORM and SEGMENT]. 



7.5.2. QUOTE [1] 

QUOTE is an FSUBR of one argument which returns its argument unevaluated. READ and PRINT 

7.4 - 7.5.2 Structured Object* 






lage 



The MDL Programming Language 



57 



understand ll.e character ' (single-quote) as an abbreviation for a call to QUOTE, the way period and 
comma work for LVAL and GVAL. Examples: 

<+ I 2H 

3 

•< + 1 2>S 

<♦ 1 Z> 

Any LIST. VECTOR, or UVECTOR in a program il.at is constant and need not have its elements 
evaluated should be represented directly and inside a call to QUOTE. This technique prevents the 
structure from being copied end, time that portion of the program is executed. Examples hereafter 
will adhere to tins diciuin. (Note: one should never modify a QUOTEd object. The compiler will one 
day put it In read-only (pure) storage.) 

7.5.3. LIST, VECTOR, UVECTOR, and STRING (the SUBRs) [I J 

Each of .he SUBRs LIST. VECTOR. UVECTOR. and STRING takes any number of arguments and 
returns an object of the appropriate TYPE whose elements are EVAL of its arguments. There are 
limitations on what the arguments to UVECTOR and STRING may EVAL to. due to the nature of the 
objects generated. Sec sections 7.6.5 and 7.G.6. 

LIST VECTOR, and UVECTOR are generally used only in special cases, since Direct Representation 
usually produces exactly (he same effect (in the absence of errors), and the intention is more 

7 7? CTOT.r ^" tC: ^ " L " a UST ' <LI5T ' " L> " ,ak " a C ° P * ° f * L WhCrMi ( ! " L > d ° eSn,I = SeC " Cti0 " 

i-i.\ STRING, on the other hand, produces effects very different from literal STRINGS. 
Examples: 

<LIST 1 <+ Z 3> ABOi 
(1 5 ABC) 
(1 <+ I 3> ADC)$ 
(1 5 ABC) 

<STRING "A" <Z "QWERT"> <REST "ABC"> "heUo'W 

"AWBChcllo" 

"A <+ 2 3> (5)"S 

"A <+ Z 3> (5)" 






7 -5.4. ILIST. IVECTOR. IUVECTOR. and ISTRING [I] 

Each of Ihe SUBRs XUST| JVECT0R( IUVECT0R( and ISTRING nmpiidt . ^ .. terated . ^ 
»ws and returns an object of the obvious TYPE. The format of an application of any of them is 



< IthinQ number-of -element s;fix expressiomany > 

7.5.2 - 7.5.4 



Structured Objects 



58 The MDL Programming Language 



where Ithinc js one of TLIST, IVECTOR, IUVECTOR, or ISTRING. An object of LENGTH number-of- 
e/ements is generated, wlio.se elements are EVAL of expression. 

expression is optional. When it is not specified, HIST, IVECTOR, and IUVECTOR return objects 
filled with objects of TYPE L05E (PRIHTYPE WORD) as place holders, a TYPE which can be passed 
around and have ils TYPE checked, but otherwise is an illegal argument. If expression is not 
specified in ISTRING. yon gel a STRING made up of ^@ characters. 






When expression is supplied as an argument, it is re-EVALuated each time a new element is 
generated. (Actually, EVAL of expression is re-EVALuated, since all of these are SUBRs.) See the last 
example for how this argument may be used. 

[Ry the way. in a construe! like <IUVECTOR 9 ' .X>, even if the LVAL of X evaluates to itself, so that 
the ' could be omitted without changing the result, the compiler is much happier with the ' in 
place.] 

IUVECTOR and ISTRING again have limitations on what expression may EVAL to; again, see sections 
7.6.5 and 7.G.6. 



Examples: 



<ILIST 5 6>S 
(66666) 
<IVECTOR 2>i 

[''LOSE "000000000000" #L0SE *000000000000»] 

<SET A 0>S 



OUVECTOR 9 *<5ET A <+ .A 1»>$ 

![1 2 3 4 5 6 7 8 9!] 



7.5.5. FORM and I FORM 



Sometimes the need arises m create a FORM without EVALing it or making it the body of a FUNCTION. 
In such cases the SUBRs FORM and IFORM ("implicit form") can be used (or QUOTE can be used). They 
are entirely an a logons to LIST and ILIST. Example: 



<DEFINE INC-FORM (A) 

<FORM SET .A <F0RM + 1 <F0RM LVAL .A»»S 
INC-FORM 
< INC-FORM F00>S 
<SET F00 <+ 1 .FOO>> 



7.5.4 - 7.5.5 Structured Objects 



uage 



The MDL Programming Language 



59 



■r-of- 



7.6. Unique Propertie s of Primitive TYPEs 



ijecti 

assed 
. not 



nt is 
; last 



that 
1 in 



tions 



7.6.1. LIST One PRIMTYPE) [I] 

An object of PRIMTYPE LIST may be considered as a 'pointer chain" (appendix 1). Any MDL object 
may be an clement of a PRIMTYPE LIST. It is easy to add and remove elements of a PRIMTYPE 
LIST, but the higher N is. the longer it takes to refer to the Nth element. The SUBRs which work 
only on objects of PRIMTYPE LIST are these: 

7.6-l.L PUTREST [I] 

<PUTREST head:prrmtype-list taihprimtype-list> 

changes he*d <n that <RE5T head) is tail (actually <CHTYPE tail LIST», then evaluates to head. Note 
thai this actually changes head: it also changes anything having head as an element or a value. For 
example: 

<SET BOW [<SET ARF (B W)>]>i 

[(8 W)] 

<PUTREST .ARF '(3 4)>S 

(B 3 4) 

.BOWS 

[(B 3 4)] 

PUTREST is probably most often used to splice lists together. For example, given that .L is of 
PRIMTYPE LIST, to leave the first m elements of it intact and take out the next n elements of it. 
<PUTREST <REST .L <- m 1» <RE5T .L <+ m n>». Specifically, 

<SET NUMS (12 3 4 5 6 7 8 9)>S 

(12 3 4 5 6 7 8 9) 

<PU1REST <REST .NUMS 3> <REST .NUMS 7»S 

(4 8 9) 

-NUMSS 

(12 3 4 6 9) 



7-6.L2. CONS 

<CONS new fist> 

(construct") adds new in U ie front of list, without copying list, and returns the resulting LIST. 
Keiercnces to list arc not affected. 

D^f» Ua , , !" g <C0N5 -E * LIST> i5 e( l»>va!eul to evaluating (.E I.LIST) (section 7.7) but is less 
Knrrerable lo the compiler (Lebling. 1979).] 



7.6 - 7.6.1.2 



Structured Objects 



60 



The MDL Programming Language 



7.6.2. "Array" PRIMTYPEs [I] 

VECTORS. UvrCTORs, and STRINGs [and BYTESes and TEMPLATES] may be considered as "arrays" 
(appendis 1). It is easy to refer to the Nth element irrespective of how large N is. and it is 
relatively difficult to add and delete elements. The following SUBRs can be used only with an object 
of PRIMTYPE VECTOR, "VECTOR, or STRING [or BYTES or TEMPLATE]. (In this section array represents 
an object of such a PRIMTYPE.) 

7.6.2.1. BACK [I] 

<BACK array fix> 

This is the opposite of REST. It evaluates to array, with fix elements put back onto its front end, 
and Changed to its PRIMTYPE. fix is optional. 1 by default. If fix is greater than the number of 
elements which have been RESTcd off, an error occurs. Examplr. 

<SET ZOP <RE5T '![1 2 3 4] 3»i 

<BACK .ZOP 2>$ 

![2 3 4!] 

<SET S <REST "Right is might." 15»S 

■ ■ 

<BACK .S 6>S 
"might." 

7.6.2.2. TOP [I] 

<T0P array) 

"BACKs up all the way" - that is. evaluates to array, with all the elements which have been RESTed 
off put back onto it. and changed to its PRIMTYPE. Example: 

<T0P .Z0P>S 
![1 Z 3 4!] 



7.6.3. "Vector* PRIMTYPEs 

7.6.3.1. GROW 

<GR0W vu end.fix begdix> 

adds/removes elements to/from either or both ends of vu, and returns the entire (TOPped) resultant 
object, vu can be of PRIMTYPE VECTOR or UVECTOR. end specifies a lower bound for the number of 



7,6-2-7.6.3.1 



Structured Object* 



guage * i"|, e MDL Programming Language 



61 



rrayj" 



object 
esenu 



elements m be added 10 the end of via beg specifies the same for the beginning. A negative fix 
specifics removal of elements, 
ayj" J 

it is The number nf element* added to each respective end is end or beg increased to an integral multiple 

>j«t of X, where A is 32 for PRIMTYPE VECTOR and 64 for PRIHTYPE UVECTOR (1 produces 32 or 64; -1 

produces 01. The elements added will be LOSE* if vu is of PRIHTYPE VECTOR, and "empty" whatever- 
,hey-are\s if vu is of PRIMTYPE UVECTOR. An -empty" object of PRIMTYPE WORD contains zero. An 
-empty" object of any other PRIMTYPE has zero in its "value word" (appendix 1) and is not safe to 
play with: il should be replaced via PUT. 

Note that, if elements are added to the beginning of vu, previously-existing references to vu will 
have to use TOP n r BACK to get at the added elements, 
t end, 

aer of Caution : GROW is a very, expensive operation; it requires a garbage collection (section 22.4) every 

time it -s used. It should be reserved for very, special circumstances, such as where the pattern of 
shared elements is terribly important. 

Example: 

<SET A M[13>$ 

<GROW .A 1>S 

•[0 00000000000000000000 

oooooooooooooooooooooo 

000000 000000000 00000 II] 






ESTed 



.AS 



7.6.3.2. SORT 

VltJT c V, l l 5 ° rl PRIMTYPES VECT0R ' UVECT0R and TUPLE *•*"■ ■» ^ works most 
Tnv rvpl y ! c T keyi "' ° f PRIHTVPE W0RD ' AT0M or STRING - However - «he k«y« ™V be of 
rZ a ? Wi " Mi " WOrk " S0RTac,s on «"«Weng(h records which consist of one or more 

cont.gunus elements in the structure being sorted. One element in the record is declared to be the 

structure is wrtcd^ *"** °* ** m ° Ml s!ruclurM can be rearranged based on how the main 

<SORT pred si II off s2 12 s3 13 ... s/V W> 
where: 

P^o* is either (see chapter 8 for information about predicates); 

PRIMTYPC WORD, STRING or ATOM; and a radix-exchange sort is used; or 

7.6.3.1 • 7.6.3.2 Structured Objects 



62 



The MDL Programming Language 



(2) something applicable to two sort keys which returns TYPE FALSE if the first is not bigger 
rhan the second, in which case a shell sort is used. For example ,G? sorts numbers in ascending 
order. , L? in descending order. Note: if your pred is buggy, the SORT may never terminate. 

si . . . sN arc the (PRIMTYPE) VECTORS, UVECTORs or TUPLES being sorted, and si contains the sort 
keys: 

II ... IN are the corresponding lengths of sort records (optional, one by default); and 

off is the offset from Mart of record to sort key (optional, zero by default). 

SORT returns the sorted si as a value. 

Note: the SUBR SORT calls the RSUBR (chapter 19) SORTX; if the RSUBR must be loaded, you may see 
some output from the loader on your terminal. 

Examples: 

<S0RT <> <SET A UUVECTOR 500 '(RANDOM))))* 

sorts a UVECTOR of random integers. 

<SET V [1 HONEY 2 SHOW 3 READY 4 GO])S 

<SORT <) .V 2 m 

[4 GO 1 MONEY 3 READY 2 SHOW] 

<SORT ,L? .V 2)$ 

[4 GO 3 READY 2 SHOW 1 HONEY] 

.VS 

[4 GO 3 READY 2 SHOW 1 MONEY] 

<SORT <> ![2 1 4 3 6 5 8 7] 1 .V)S 

\[\ 2 3 4 5 6 7 8!] 

.VS 

[GO 4 READY 3 SHOW 2 MONEY 1] 

The first sort was based on the ATOMs' PHAHEs. considering records to be two elements. The second 
one sorted based on the FIXcs. The third interchanged pairs of elements of each of its structured 
arguments. 



7.&3.2 



Structured Objects 



The MDL Programming Language 



63 



7.6.4. VECTOR (the PRIMTYPC} [I] 

Any MDL object may be an element of a PRIMTYPE VECTOR. A PRIMTYPE VECTOR takes two words 
of storage more than an equivalent PRIMTYPE LIST, but takes it all in a contiguous chunk, whereas 
a PRIMTYPE LIST may be physically spread out in storage (appendix 1). There are no SUBRs or 
FSUBRs which operate only on PRIMTYPE VECTOR. 

7.6.5. UVECTOR (the PRIMTYPE) [I] 

The difference between PRIMTYPEs UVECTOR and VECTOR is that every element of a PRIMTYPE 

^no^T^jJ "I"'"' TYPE - A PRIMTrPE UVECT0R lakes »PP«>ximately half the storage of 
a PRIMTYPE VECTOR or PRIMTYPE LIST and. like a PRIMTYPE VECTOR, takes it in a contiguous chunk 
(appendix II. 6 

[Note: due to an implementation restriction (appendix J), PRIMTYPE STRINGS. BYTESes, LOCDs 

„ S JCC($ °" ,,,e COnlrel 5Uck fcha P' er 221 "^ not be elements of PRIMTYPE 

UVEC TORS. J 

The "same TYPE" jfMta causes an equivalent restriction to apply to EVAL of the arguments to 
either of the SUBRs UVECTOR or IUVECT0R. Note (hat attempting to say 

■[1 .A!] 

UVFCinrn^M '° i ; rm, ! 1CC ? err ° r ' Si "" y ° U ' n atlem P tin S t0 P« ■ ™™ «d a FIX into the same 
uvtLiOK. uii the other hand. 

<UVECTOR 1 .A> 
is legal, and will EVAL to the appropriate UVECTOR without error if .A EVALs to a TYPE FIX. 
The following SUBRs work on PRIMTYPE UVECTORs alone. 
7-6.5.1. UTYPE [I] 

<UTYPE phmtype-uvector> 

("uniform type") evaluates to the TYPE of every element in it, argument Example: 

<UTYPE '![A C]>S 

ATOM 



7.6.4 - 7.6,5.1 



Structured Objects 



64 The MDL Programming Language 

7.6.5.2. CHUTYPC [I] 

<CHUTYPE uv:prtmtype-uvector type) 

("change uniform type") changes the UTYPE of uv to type, simultaneously changing the TYPE of all 
elements of uv. and returns the new, changed, uv. This works only when the PRIMTYPE of the 
elements of uv can remain the same through the whole procedure. (Exception: a uv of UTYPE LOSE 
can be CHUTYPEd to any type (legal in a UVECTOR of course); the resulting elements are "empty", as 
for GROW.) 

CHUTYPE actually changes uv; hence aH references to that object will reflect the change. This is 
quite different from CHTYPE. 

Examples: 

<SET LOST <IUVECTOR 2»S 

![*10SF "000000000000* #L0SE "000000000000"! ] 

•CUTYPE .LOST>S 

LOSE 

<CHUTYPC .LOST TORrDS 

![<> <>!] 

.LOST 

<CIIUTYPE .LOST LIST>$ 

7.6.6. STRING (the PRIMTYPE) and CHARACTER [I] 

The best mental image of a PRIMTYPE STRING is a PRIMTYPE UVECTOR of CHARACTER* - where 
CHARACTER is the MDL TYPE for a single ASCII character. The representation of a CHARACTER, by 
the way. is 

! \tny-ASCII-character 

That is. the characters !\ (cxclainaiion-point backslash) preceding a single ASCII character 
represent the corresponding object of TYPE CHARACTER (PRIMTYPE WORD). (The characters I" 
(exclamation-point double-quote) preceding a character are also acceptable for inputting a 
CHARACTER, for historical reasons.) 

The SUBR ISTRING will produce an error if you give it an argument that produces a non- A 

CHARACTER. STRING can take either CHARACTERS or STRINGS. 36 

sn 

There are no SURRs which uniquely manipulate PRIMTYPE STRINGS, but some are particularly useful 
in connection with them: 

7.6.5.2 - 7.6.6 Structured Object* 



:::ge 



The MDL Programming Language 



65 



fall 

the 

LOSE 
■ 
. as 



15 is 



here 
.by 



xter 
I ■ 

% a 



ion- 



eful 



7.6.6.1. ASCII [I] 

<ASCII iix'0r-character> 



If its argument is of TYPE FIX, ASCII evaluates ,o the CHARACTER with the 7-bit ASCII code of it. 
argumciii. Example: <ASCII 65> evaluates to !\A. 

if ,„ argument U -of TYPE CHARACTER. ASCII evaluates to the FlXed-point number which is its 
arguments 7-bit ASCII code. Example: (ASCII !\2> evaluates to 90. 

[Ac.ua.ly. a FIX can be CHTYPEd to a CHARACTER (or vice versa) directly, but ASCII checks in the 
former ra<e that the riX is within the permissible range.] 



7.6.6.2. PARSE [I] 



< PARSE steitw r*tffxm> 



ltZ^lZl[ S Tr'T T"^ a,g ° ril,,m f ° r COnVerlh,g ASCU "Potations to MDL 
objects and returns the QrM object created. The remainder of string, after the first object 
represented, is ignored, rsdlx (optional, ten by default) is 

trgunients.] 



representee. ,s .gnored. rsdlx (optional, ten by default) is used for converting any FIXes that occur 
[See also sections 15.7.2 and 17.1,3 for additional arguments.] 

7.6.6.3. LPARSC [I] 



^2'JSS^Sf W MRSE <ab ° Ve) ' ""•" " liI " par " S ^millsMn Saai return, a 

7.6.6.4. UNPARSE [I J 

<UNPARSC »>>• rsoflrrfix) 

rTrc^tM?''" '," "* arR ""' C, " PRIWT ' S al S 0ri,,ll,, for »n»frtln B MDL objects to ASCII 
SETS STR,T"V STRING W " iC " C °" ,ai " S "' e CHARACTER5 «" "•"""'.v. typed out 
«eo„ IZ "\ munTr^ T*JP, "' "* ^^ «*l»««»» PRINT adds to 

7.6.7. BYTES 

^6 bi^L\ P ui B r YTE A 5 r!vTr^ iMg . %?*!***** ^ The **"* "" be «* si " b « we *" ■ "d 

STRING o 1 f, " i,n,,,ar '" 50me Wa > S ! ° a UVECT0R of FIX « -nd in *°™ ways to , 

'RING of non-seven-b.t bytes. The elements of a BYTES are always of TYPE FIX 



jects 



7.6.6.1 - 7,6.7 



Structured Objects 



66 



The MDL Programming Language 



The SUBRs BYTES and IBYTES are similar 10 STRING and ISTRING, respectively, except that each of 
the former rakes a first argument giving Hie size of the bytes in the generated BYTES. BYTES take* ; 
one required argument which is a FIX specifying a byte size and any number of PRIMTYPE WORDs. 
It returns an object nf TYPE BYTES with that byte size containing the objects as elements. These 
objects will be ANDBed will, the appropriate mask of 1-bits to fit in the byte size. IBYTES takes two 
required FIXrs and one optional argument. It uses the first FIX to specify the byte size and the 
second to specify the number of elements. The third argument is repeatedly evaluated to generate 
FIXes that become elements of the BYTES (if it is omitted, bytes filled with zeros are generated). The 
analog to UTYPE is BYTE-SIZE. Examples: 



<BYTCS 3 <+ 2 2> < 
*3 (4 1 7} 
<SET A 0>$ 


-m 






<TBYTES 3 9 '<SET 
#3(1234567 
<IBYTES 3 4>S 
•3(0 0} 
<BYTE-SIZE <BYTE5 
I 


A <+ .A 
1} 

1»S 


!>»$ 


7.6.8. TEMPLATE 







A TEMPLATE is similar to a PL/I "structure" of one level: the elements are packed together and 
reduced in size to save storage space, while an auxiliary internal data structure describes the 
packing formal and the elements' real TYPEs (appendix I). The interpreter itself is not able to create 
objects of PRIMTYPE TEMPLATE (Lebling. 1979): however, it can apply the standard built-in 
Subroutines to them, with the same effects as with other "arrays". 



7.7. SEGMENTS [1] 

Objects of TYPE SEGMENT (whose TYPEPRIH is LIST) look very much like FORMS. SEGMENTS, however, 
undergo a non-standard evaluation designed to ease the construction of structured objects from 
elements of other structured objects. 



7.7.1. Representation [1] 

The representation of an object of TYPE SEGMENT is the following: 
!< tunc nrg-1 nrg-2 ... arg-N !> 



7.6.7 - 7.7.1 



Structured Objects 



The MDI. Programming Language 



67 






where the second ! (cxclainaiion-poim) is optional, and func and arg-1 through arg-N are any legal 
constituents of a TORM (thai is, anything). The pointed brackets can be implicit, as in the period 
and comma notation for L\Ml and GVAL. 

AH of the following are SEGMENTS: 

!<3 .F00> I.FOO i.FOO 

7.7.2. Evaluation [I] 

A SEGMENT is cvMuaied in exactly the same manner as a FORM, with the following three exceptions: 

(1) It had better be done inside an EVAL of a structure: otherwise an error occurs. (See special 

raw of FORM* in section 7.7.5.) 

(2) ll had belter EVAL to a structured object; otherwise an error occurs. 

(3) What actually gets inserted into the structure being built are the elements of the structure 

returned hy the FORM-lifce evaluation. 

7.7.3. Examples [I] 

<SET ZOP •![£ 3 4 ]>j 

![Z 3 1!] 

<SET ARF (B 3 4)>J 

(B 3 4) 

( -ARF ! .ZOPJS 

(IB 3 4) 2 3 4) 

![!.ZOP KREST .ARF>!]i 

![2 3 4 3 4!] 

<SET S "STRUNG. ■>$ 

"STRUNG." 

(!.S)S 

(!\S !\T !\R !\U !\N !\G !\.) 

<SET NIL ()>S 
() 

[f.NILjS 
[] 



7.7.1 - 7.7.5 



Structured Object* 



68 



The MDL Programming Language 



7.7.4. Note on Efficiency [I] 

Most of Hip cases in which it is possible lo use SEGMENT* require EVAL to generate an entire new 
object. Naturally, litis uses up both storage and time. However, there is one case which it is 
possible to handle without copying, and EVAL uses it. When the structure being built is a PRIMTYPE 
LIST, and the segment value of a PRIMTYPE LIST is the last (rightmost) element being concatenated, 
that last PRIMTYPE LIST is not copied. This case is similar to CONS and is the principle reason why 
PRIMTYPE LISTs have their structures more easily varied than PRIMTYPE VECTOR or UVECTOR. 

Examples: 

.ARFS 
(B 3 4) 

This does not copy ARF : 

(I 2 ! .ARFJS 
(1 2 B 3 4) 

These do: 



(1 !.ARF 2) 

(1 B34Z} 

[1 2 I.ARF] 

[1 2 B 3 4] 

(1 2 I.ARF KREST '(!)>) ;"still not last elenenfS 

(1 2 B 3 4) 



;"not last element's 
;-not PRIMTYPE LIST 1 * 



Note the following, which occurs because copying does not. take place 



<5ET DOG (A !.ARF)>S 
(A D 3 4) 

<PUT .ARF 1 "BOWOW) J 

("BOWOW 3 4) 

.DOGS 

(A "BOWOW 3 4) 

<PUT .DOG 3 "W0OF")S 

(A "BOWOW "WOOF" 4) 

-ARFS 

("BOWOW "WOOf" 4) 



Since ARF was not copied, it was literally part of DOG. Hence, when an element of ARF was changed, 
DOG was changed. Similarly, when an element of DOG which ARF shared was changed. ARF was 
changed loo. 



7.7.4 



Structured Objects 




The MDL Programming Language 



is 

PE 



7.7.5. SEGMENTS in FORM* [i] 

When a SEGMENT appears as an element of a FORM, the effect is approximately the same as if the 
elements of EVAL of the SEGMENT were in the FORM. Example: 

<S£T A '![1 2 3 4]>i 
![1 2 3 4!] 
<+ !.A 5>* 
15 



Note: the elements of the structure segment-evaluated in a FORM are not re-evaluated if the thing 
being applied \s a SURR. Thus if .A were (1 2 <+ 3 4> 5), the above example would produce an 
error: you can't add up FORMs. 

You could perform the same summation of 5 and the elements of A by using 

<EVAL <CH1YPE (+ ! .A 5) F0RH» 

(Note that CVAL must be explicitly called as a SUBR; if it were not so called, you would just get the 
FORM <* 1 2 3 4 5> - not its "value",) However, the latter is more expensive both in time and in 
storage: when you use the SEGMENT directly in the FORM, a new FORM is, in fact, regenerated as it is 
in the latter case. (The elements are put on "the control stack' with the other arguments.) 






jed, 

,vas 



7.8. Self-referencing Structures 

It is possible for a structured object to "contain" itself, cither as a subset or as an element, as an 
element of a siructured element, etc. Such an object cannot be PRINTed, because recursion begins 
and never terminates. Warning: if you try the examples in this section with a live MDL. be sure 
you know how to use *S (section 1.2) to save PRINT from endless agony. (Certain constructs with 
ATOHs can give PRINT similar trouble: see chapters 12 and 15.) 

7.8.1. Self-subset 

<PUTREST hcad:primtype-list tail:primtype-tisr> 

If head is a subset of tail, that is. if <REST tail fix> is the same object as <REST head 0> for some fix, 
then both head and tail will be "circular" (and thus self-referencing) after the PUTREST. Example: 

<SET WALTZ {1 2 3)>S 

(I 2 3) 

<PUTREST CREST .WALTZ 2> .WALTZ>J 

(3 1 2 3 1 2 3 1 2 3 1 2 3 ... 



... 



7.7.5 - 7.8.1 



Structured Objects 



70 



The MDL Programming Language 



7.8.2. Self-element 

<PUT si .-structured ft* s2:structured> 

If 5/ ii the same object as $2. then it will "contain" itself (and thus be self-referencing) after the 
PUT. Examples: 



<SET S <l 1ST 1 2 3» 

(1 2 3) 

<PUT .5 3 .S>S 

(1 ? (1 2 (1 2 (1 Z 

<5ET U ![![]]>$ 

<PUT .U 1 .U>S 

1C tc t[ icicvt — 



'or VECTOR'S 



Test your reaction lime or your terminal** bracket-maker. Amaze your friends. 



7.8.2 



Structured Objects 



The MDL Programming Language 



71 



Chapter 8. TrutH 



8.1. Trutli Values [I] 

MDL represents "false" tvilli an object of a particular TYPE: TYPE FALSE (unsurprisingly). TYPE 
FALSE is structured: its PRIMTYPE is LIST. Thus, you can give reasons or excuses by making them 
elements of a FALSE. <Again. EVA Ling a FALSE neither copies it nor EVALs its elements, so it is not 
necessary to QUOTE a FALSE appearing in a program.) Objects of TYPE FALSE are represented in "# 
notation": 

••FALSE hst-ot-its-elements 
The empty FORM evaluates to the empty FALSE: 

OS 

#FALSE ( ) 

Anything which is not FALSE, is. reasonably enough, true. In this document the "data type" false- 
or-any in mctasy ntact ic variables means that the only significant attribute of the object in that 
context is whether its TYPE is FALSE or not. 



8.2. Predicates \\\ 

There are numerous MDL F/SUBRs which can return a FALSE or a true. See appendix 2 to find 
them all. Most return cither 'FALSE () or the ATOM with PNAME T. (The latter is for historical 
reasons, namely Lisp (Moon. 1974).) Some predicates which are meaningful now are described next. 



8.2.1. Arithmetic [I] 

<0? fix-or-float> 
evaluates to T only if its argument is identically equal to or 0.0. 

8- 8.2.1 



Truth 



72 The MDL Programming Language 

<1? ffX-Or-//03t> 

evaluates 10 I only if its argument is identically equal to 1 or 1.0. 
<G? n:/ix~or~fto*it m:fix-or-tloat> 

evaluates lo T only if n is algebraically greater than m. L=? is the Boolean complement of G?; thai 
is. it is T only if n is not algebraically greater than m. 

<L? n:fi*-or-flo*t m:fix-or-//o*t> 

evaluates to T only if n is algebraically less than m. G*7 is the Boolean complement of L?. 

8.2.2. Equality and Membership [1] 

evaluates to T only if el Is (he same ob ject as e2 (appendix 1). Two objects that look the same 
when PRINTcd may not be = = 7. Two FIXcs of the same "value" are "the same object"; ao are two 
FLOATs of exactly the same "value". Empty objects of PRIMTYPE LIST (and no other structured 
PRIMTYPE) are = = ? if their TYPEs are the same. Example: 

<*>=? <SET X -RANDOM STRING"> <T0P <REST .X 6>»S 
T 

< = = 7 .X "RANDOM SIRING" >S 
'FALSE ( ) 

N==? is the Boolean complement of s«7. 

< = ? el:*ny e2:/tny> 

evaluates to T if t> ] and e 2 have the same TYPE and are structurally equal — that is, they "look the 
same", their primed representations are the same. *? is much slower than bb?. e? should be used 
only when its characteristics are necessary: they are not in any comparisons of unstructured objects. 
= =? ami ■? always return the same value for FIXcs, FLOATs. ATOMs. etc. (Mnemonically. =s? tests for 
"more equality" than =7; in fact, it tests for actual physical Identity.) 

Example, illustrating non-copying of a SEGMENT in Direct Representation of a LIST: 

<SEI A '( 1 2 3)>S 

(1 2 3) 

<==? .A ( ' .A)>S 

T 

< B «? .A <SET B <LIST » ,A»>i 

8.2.1 - 8.2.2 Truth 



The MDL Programming Language 



73 



("FALSE ( ) 
<■? .A .B>i 

T 

N=? is llie Boolean complement of a?. 

<HEMBER Ob,cct:any structurcd> 

run-, down structured from first to last element, comparing each element of structured with object. 
If it finds .tii clement of structured which is =? to object, it returns <REST structured i> (which is of 
TYPE <PRTMTYPC ;tructurcd>\. where the (fl)tli element of structured is =? to object. Thai is. the 
first element of what it returns is the first clement of structured that is =? to object. 

If no element of structured is =? to object. MEMBER returns fFALSE ( ). 

The search is more efficient if structured is of PRIMTYPE VECTOR (or UVECTOR. if possible) than if it 
is of PRIMTYPF LIST. As usual. iT structured is constant, it should be QUOTEd. 

If object and structured are of PRIMTYPE STRING [or BYTES]. MEMBER does a substring search. 
Example: 

<MEMBER "PART" "SUM OF PARTS">S 

"PARTS" 

<HEMQ objechsny *tructurcd> ("member quick") is exactly the same as MEMBER, except that the 
comparison lest is = = ? . 

CSTRCOMP si sS> 

("string comparison") can he given either two STRINGS or two ATOMs as arguments. In the latter case 
the PNAMCs arc UWd It actually isn't a predicate, since it can return three possible values: if si is 
-T to s ^» i if si sorts alphabetically after s2i and -1 if si sort* alphabetically before s2. 
Alphabetically" means, in this case, according to the numeric order of ASCII, with the standard 
alphabetizing rules. 

[A predicate suitable fnr an ascending SORT (which see) is <G? <STRCOMP .ARG1 .ARG2> 0>.] 



8.2.3. Boolean Operators [I] 

<MOT e:falsc-or-Any> 
evaluates to T only if c evaluates to a FALSE, and to eTALSE ( ) otherwise. 

<ANO el c2 ... e/V> 

8.2-2 - 8.2.3 



Truth 



74 



The MDL Programming Language 



AND is an FSUIIR. Ii evaluates its arguments from first to fail as they appear in the FORM. As soon 
as one of (hem evaluate* to a FALSE, h returns that FALSE, ignoring any remaining argument!. If 
none of I hem evaluate 10 FALSE, it returns EVAL of its last argument. <AND> returns T. AND? is the 
SUBR equivalent to AND. that is. all its arguments are evaluated before any of them is tested. 

<OR el e2 eN> 

OR is an FSUBR. It evaluates its argument* from first lo last as they appear in the FORM. As soon 
as one of litem evaluates to a non-FALSE. OR returns that non-FALSE value, ignoring any remaining 
argumeulv If this nevrr occurs, il returns the last FALSE it saw. <0R> returns *»FALSE (). OR? Is 
the SUBR equivalent to OR. 

8.2.4. Object Properties (I) 

<TYPE? Any type- J ... type-N> 

evaluates to type-, only If < = = ? typo-, <TVPE any» Is true. It is faster and gives more information 
than ORing tests for each TYPE. If the lest fails for all type-is. TYPE? returns #FAL5E (). 

(APPLICABLE? e> 

evaluates to T only if e is of a TYPE that can legally be applied to arguments in a FORM. lhat Is. be 
(EVAL of) the first element of a FORM being evaluated (appendix 3). 

< MONAD? e> 

evaluates to #FALSF ( ) only if NTH and REST (with non-zero second argument) can be performed on 
its argument Without error. An unstructured or empty structured object will cause MONAD? to return 

<STRUCTURtO? ff> 

evaluates to T only if e is a structured object. It is ium the inverse of MONAD?, since each returns 
if its argument is an ruipty structure. 

<EMPTY? structured} 

evaluates to T only rf its argument, which must be a structured object, has no elements. 
< LENGTH? structured /,x> 

evaluates to <LCNGTIl ,:t,uclured> only if that is less than or equal to fir, otherwise, it evaluates t< 
#FALSE ( ) . Mrieiiioiiically. you can think of the first two letters of LENGTH? as signifying the "less 
than or equal to" sense of the test. 



8.2.3 - 8.2.4 



Truth 



The MDL Programming Language 



75 



This SU8R was invented lo use on Hits, because MDL can determine their lengths only by stepping 
along the list, counting the elements. If a program needs to know only how the length compares 
with a given number. LENGTH? will tell without necessarily stepping all the way to the end of the 
list, in contrast to LENGTH. 

[If structured is a circular PRIMTYPE LIST, LENGTH? will return a value, whereas LENGTH will execute 
forever. To see if you can do <REST structured <+ 1 fix» without error, do the test <NOT <LENGTH7 
structured fix > > - ] 



8.3. COND [I] 

The MDL Subroutine which is most used for varying evaluation depending on a truth value is the 
FSUBR COND ("conditional"). A call to CONO has this format: 

<COND clause- 1 Jtst clause-NJfst> 

where N is ai least one. 

COND always returns the result of the last, evaluation it performs. The following rules determine the 
order of evaluations performed. 

(1) Evaluate the first element of each clause (from first to last) until either a non-FALSE object 
results or the clauses are exhausted. 

(2) If a non-FALSE object is found in (I), immediately evaluate the remaining elements (if any) 
of that clause and ignore any remaining clauses. 

In other words. COND goes walking down its clauses. EVALing the first element of each clause, looking 
for a non-FALSE result. As soon as it finds a non-FALSE. it forgets about all the other clauses and 
evaluates, in order, the other elements of the current clause and returns the last thing it evaluates. 
If It can't find a non-FALSE. it returns the last FALSE it saw. 



8-3.1. Examples [IJ 



<SET F '(1)>S 

(1) 

<COND (<EMPTY? ,F> EMP) <<l? <LENGTH .F» ONE)>S 

ONE 

<SET F < )>S 

() 

<COND (<EHPTY? .F> EMP) (<1? <LENGTH .F» ONE)>S 

EMP 



8.2.4 - 8.J.1 



Truth 



76 



The MDL Programming Language 




<SET F *(1 Z 3)>S 

(I 2 3) 

<COND (<EMPTY? .F> EMP) (<17 <LENGTH .F» ONE)>S 

'FALSE () 

<COND <<LENGTH? .F Z> SHALL) (BIG)>J 

BIG 

CDEFINE FACT (H) ;"the standard recursive factorial* 

<COND (<0? .N> 1) 

(ELSE <- -N <FACT <- .H 1>»)»S 
FACT 

<FACT 5>S 
120 



8.4. Shortcuts willi Conditionals 

8.4.1. ANO and OR as Short COMOs 

Since AND and OR are FSUBRs. ihcy can be used as miniature CONDs. A construct of the form 

<ANO pre-conditions action(s)> 



<OR prc-exdusions *elion(s)> 

will allow #ction<s) lo be evaluated only if all the pre- conditions are true or only If all the pro- 
oxclusians are fsKe. respectively. By nesting and using both AND and OR, fairly powerful constructs 
can be made. Of course, if nction(s) are more than one thing, you must be careful that none but the 
last returns false or true, respectively. Watch out especially for TERPRI (chapter 11). Examples: 

<AND <ASSIGNED? FLAG> -FLAG <FCN .ARG» 

applies FCN only if someone else has SET FLAG to true. (ASSIGNED? is true if its argument ATOM has 
an LVAL.) No error can occur in the testing of FLAG because of the order of evaluation. 

<AND <SET C <OPEN "READ" "A FILE"» <LOAD .C> <CLOSE -C» 

effectively FLOADs the file (chapter II) without the possibility of getting an error if the file cannot 
be opened. 



8.3.1 - ZAA 



Truth 



The MDI. Programming Language 
8.4.2. Embedded Unconditional* 

n.v„ «.««„>. b«,„« ,„ o„ ly LIST ,.e„, e „, ,. „ AND ,h., returns a FALSE for «h.7.7 Ex"npi« 

<CON0 (<07 .N> <F0 .N>) 

(<1? -N> <F1 .N>) 
(<AND <SET N <« 2 <FIX </ .N Z»» 

: "Round .N down to evon number." 
<») 
(<LENGTH? .VEC -N> '[]) 
(T <REST .VEC <♦ 1 .N>>)> 

o ifrr Ann f ™*"-ple can be combined.) Of course, you must be careful that no 

eood ^r. frr, 1 a «: ss ,o a fal5e: . most subr °" ,i »" <*• »•» -'-„ . false w.,,.ou, a V e ry 

Iwr^U^'^Jl,'^^^ '"h "" ,iMg WUH " " CW C ° ND *** " ,e ««-n<"«'on.I part. A. least 

n.s meihni dor, .mi make ihe code appear lo a human reader as though it does loineihinz other 

than what It really does. The above example could be done this way: something other 



<CON0 (<0? .N> <F0 .N>) 

(<1? .N> <F1 .N>) 
<T 

<SET N <* 2 <FIX </ .N Z»» 
<COND (<LENGTH? .VEC .N> '£]) 

(T <REST .VEC <♦ 1 ,N»)>)> 



842 Truth 



78 



The MDL Programming Language 



Chapter 9. Functions 



This chapter could he named "fun and games with argument LIST*". lis purpose is to explain the 
more complicated thing* which can be done with FUNCTIONS, and this involves, basically, explaining 
all the various tnl.cn* which can appear in the argument LIST of a FUNCTION. Topics are covered 
in what bt approximately ^n nrrirr or increasing complexity. This order has little to do with the 
order in which tokens can actually appear in an argument LIST, so what an argument LIST "looks 
like" overall gets rather lost in the shuffle. To alleviate this problem, section 9.9 is a summary of 
everything that can go into an argument LIST, in the correct order. If you find yourself getting 
lost, please refer in thai summary. 






9.1. "OPTIONAL" [II 

MDL provides veiy convenient means for allowing optional arguments. The STRING "OPTIONAL" 
(or "OPT" -• they're totally equivalent) in the argument LIST allows the specification of optional 
argument* Willi values to he assigned by default. The syntax of the "OPTIONAL" part of the 
argument LISI is as follows: 

"OPTIONAL" M J al-2 ... xt-N 

First, there is the SIRING "OPTIONAL". Then there is any number of either ATOMs or two-element 
LISTs. intermixed, one per optional argument. The first element of each two-element LIST must be 
an ATOM; this is the dummy variable. The second element is an arbitrary MDL expression. If there 
are required argument*, they must come before the "OPTIONAL". 

When EVAL is binding the variables of a FUNCTION and sees "OPTIONAL", the following happens: 

IT an explicit argument was given in the position of an optional one. the explicit argument is 
bound to the corresponding dummy AIOM. 

If there is no explicit argumenl and the ATOM stands alone, that is. it is not the first element of 
a two-i'lrment LIST . that ATOM becomes "bound", but no local value is assigned to it [see belowL 
A local value can be assigned to it by using SET. 









9- 9.1 



Functions 



The MD1. Programming Language 79 

If there is no explicit argument and Hie ATOM is the first element of a two-element LIST, the 
MDL expression in the LIST with the ATOM is evaluated and bound to the ATOM. 

[Until an ATOM is Assigned, any attempt to reference its LVAL will produce an error. The predicate 
SUBRs BOUND' and ASSIGNED? can be used to check for such situations. BOUND? returns T if its 
argument is currently bound via an argument LIST or has ever been SET while not bound via an 
argument LIST. The latter kind of binding is railed "top-level binding", because it is done outside 
all active argumeni-LIST binding. ASSIGNED? will return #FALSE () if its argument is either 
U II assigned nr unbound. By the way. there are two predicates for global values similar to BOUND? 
and ASSIGNED?, namely GBOUND? and GASSIGNED?. Each returns T only if its argument, which (as 
in BOUND' and ASSIGNED?) must be an ATOM, has a global value "slot" (chapter 22) or a global value, 
respectively.) 

Example: 

<DEFINE INC1 <A "OPTIONAL- (N 1)) <SET .A <♦ ..A .N>»S 

INC1 

<SET B 0>S 



<rNCl B>S 

1 

<INC1 B 5>J 

6 

Here we defined another (not quite working) increment FUNCTION. It now takes an optional 
argument specifying how much to increment the ATOM it is given. If not given, the increment is X. 
Now. 1 is a pretty simple MDL expression: there is no reason why the optional argument cannot be 
complicated -- for example, a call to a FUNCTION which reads a file on an I/O device. 



9.2. TUPLES 

9.2.1. "TUPLE - and TUPLE (the TYPE) [IJ 

There are also times when you want to be able to have an arbitrary number of arguments. You can 
always do this hy defining the FUNCTION as having a structure as its argument, with the arbitrary 
number of arguments as elements of the structure. This can. however, lead to inelegant-looking; 
FORMs and extra garbage to be collected. The STRING "TUPLE" appearing in the argument LIST 
allows you to avoid that. It must follow explicit and optional dummy arguments (if there are any 
of either) and must be followed by an ATOM. 

The effect of "TUPLE" appearing in an argument LIST is the following: any arguments lefi In the 

9.1 - 9.2.1 Function* 



The MDL Programming Language 



lTZu af l C % S Vll r r y '"V^!' Cit a " d °P Iional »rgumeni». -re EVALed and made sequential elements of 
an object of TYPE and PR1MTYPE TUPLE. The TUPLE is then bound to the ATM ? following -TUpIe- 



An object of TYPF. TUPLE 




SSPKS-* a " APPLICflBLE obJC " "" ic " "" **«' - ;= «-*» * «•«£■• ™7i ^2K 



good 
Example 



CDEFINE NTMARG (N "TUPLE" T) 

;"Get all but first argument Into T." 
<COHD (< = =? 1 ,N> 1) 

;"If N is 1, return 1st org. i.e., .n. 
I.e.. 1. Note that <J? .N> would be 
true even if . n were 1.0." 
(<L? <LENGTH .T> <SET N <- .N 1»> 
(•FALSE ("DUMMY")) 

: "Check to seo if there is an Nth arg, 
and make N a good index into T while 
you 're at it. 

If there isn't an Nth arg, complain." 
(ELSE <N1H .T .N>)» 



retuC^'rCm nf ft, V. y " ° f , ? r * ument »- IU fir " -rgument must be of TYPE FIX. It 

"DUMMY-r (The f L SF t^TT*. « h " a " N "' ***** If fl doesn't, it returns #FALSE 
FAISF „i'rnun n " flbso,u ' e,y ««**«ry in the las. clause. If the Nth argument is a 

FALSE, .he COH0 Will rem, lh*t FALSE.) Exercise for the reader: NTHARG will generation error if 
its first argun.cn. b no, FIX. Where and why? (How about <NTHARG 1 .5 2 3> nrTxil 

9-2.2. TUPLE (the SUBR) and ITUPLE 

These SUOns arc the uttte as VECTOR and IVECTOR, except that they build TUPLES (thai | s vectors on 
the -on.ro srncU. They can be used only a. top level in an "OPTIONAL- list or "AUX" I st ( s« 
below). The clear »dv«„t«g« of TUPLE and ITUPLE ("implicit tuple") is in Morage-manaecment 
efficiency. They produce no garbage, since they are flushed automatically upon function return 

•« " 9 - 22 Function* 



The MDI Programming Language 01 

Examples: 

<DEFINE F (A B "AUX" (C <ITUPLE 10 3>)) ...> 
creates a 10-clciitciil TUPLE and SETs C to it. 

<DEFINE H (-OPTIONAL" (A <ITUPLE 10 '<I>>) 

"AUX- (B <TUPLE I.A 1 2 3>)> 
. . -> 

These are valid uses of TUPLE and ITUPLE. However, the following is not. a valid use of TUPLE, 
because it is not called at top level of the ■AUX": 

<DEFINE NO (A B "AUX- (C <REST <TUPLE !.A»)> ...> 

However, the desired effect could be achieved by 

<DEFINE OK (A B "AUX" (D <TUPLE ! .A>> (C <REST .D>)) ...> 

9.3. "AUX" Ml 

-AUX- (or "EXTRA" -- they're toially equivalent) are STRINGS which, placed in an argument LIST, 
serve to dynamically allocate temporary variables for the use of a Function. 

-AUX- iiiiim appear in the argument LIST after any information about explicit arguments. It is 
followed by ATOM* or two-clement LISTs as if it were "OPTIONAL". ATOMs in the two-element LISTs 
are bound to CVAL of the second clement in the LIST. Atoms not in such LISTs are initially 
unassjqneil : they are explicitly given "no" i.VAi. . 

All binding specified in an argument LIST is done sequentially from first to last, so initialization 
expressions for "AUX" (or "OPTIONAL") can refer to objects which have just been bound. For 
example, this works: 

<DEFINE AUXEX ("TUPLE" T 

-AUX" (A <LENGTH .T>) (B <« 2 .A>)) 
![.A .B]>S 
AUXEX 

< AUXEX 1 Z "FOO">i 
!C3 G!] 



9-2-2 - 9-3 Functions 



82 The MDL Programming Language 

9.4. QUOTCd arguments 

If an ATOM in an argument LIST which is to be bound lo a required or optional argument is 
surrounded by a call lo QUOTE, that ATOM is bound to the unevaluated argument. Example: 

(DEFINE 02 (A 'B) ( -A .B)>$ 

02 

<Q2 <♦ 1 2> <♦ 1 2»S 

(3 <* I ?>) 

It is noi often appropriate for a function to lake its arguments unevaluated. because such a practice 
makes it le*s modular and harder to maintain: it and the programs that call it tend to need to know 
more about each other, and a change in its argument structure would tend to require more changes 
in the programs thai call it. And. since few functions, in practice, do take unevaluated arguments. 
users tend to a-.su in e that no functions do (except FSUBRs of course), and confusion inevitably 
results. 



0.5. "ARGS" 



The indicator "ARCS" can appear in an argument LIST with precisely the same syntax as "TUPLE". 
However. "ARGS" causes the ATOM following it to be bound to a LIST of the remaining unevaluated 
arguments. 

"ARGS" does not cat!** any copying to take place. It simply gives you 

<REST jpptiCJition:form fhti 

with an appropriate />*. The TYPE change to LIST is a result of the REST. Since the LIST shares 
all its elements with the original FORM. PUTs into the LIST will change the calling program, 
however dangerous that may be. 












Examples: 



<0CFINE QIT (N "ARGS" L) <.N .L»S 

OIT 

<QIT 2 <+ 3 A> <LENGTH ,QALL> F00>S 

< LENGTH ,QALL> 

(DEFINE FUNCTl ("ARGS" ARGL-AND-BODY) 

<CHTYPE .ARGL-AND-BOOY FUNCTI0N>>S 
FUNCTl 

<rUMCTl (A D) <♦ .A -B»S 
'FUNCTION ((A B) <* .A .B>) 



9.4 - 9.5 Functions 






The MDL Programming Language _ 

The last example is a perfectly valid equivalent of the FSUBR FUNCTION. 



9.6. "CALL 



7n fow.*?v7 at™ - *" ****?* ARGSV If " a PP«» *» »" argument LIST, it must be 
fo lo wed by *n ATOM and must be the only thing used to gather arguments. -CALL- causes the ATOM 
wh.ch follows .. to become bound to the actual FORM that is being evaluated - that is. you get the 

cba^/ca. l/ng codf "'" "" *** * * F0 "" "** "* "" » "»* PUT * «• *« «C W*U 
done 1 "" ***"* " " CatCh " 22 f ° r ar S u '»">t manipulation. If you can't do it with -CALL-, it can't be 



9.7. EVAL an d "BIN D" 

Obtaining ....evaluated arguments, for example, via QUOTE and -ARCS", very often implies that you 
wish to evaluate them at some point. You can do this by explicitly calling EVAL. which is a SUBR. 
exam p le. 

<SET F •<* 1 2»S 
<+ I 2> 
<EVAL -F>$ 
3 

IwwSJ™?!! ", *T" ri ar S"" ,e,,t ' of TYPE ENVIRONMENT (or others, see section 20.8). An 
ENVIRONMENT co„MM.ba i ,caI.y of a state of ATOM bindings: it is the "world- mentioned in chapter 5. 
„ r l;|" Cr ^Hiding changes .he ENVIRONMENT, if you wish to use EVAL within a FUNCTION, you 
probably wan, to get hold of the environment which existed before that FUNCTION'S binding took 

orov , J^Tr ,0r RIND *"- WhiC " mU$t ' if i! h USCd ' be ***** «»"■* in "" argument E LIST. 
? .i llu l< - ST? 1 . S . , b '" dS "^ ATOM i,,,l,,ediale, y Allowing it to the ENVIRONMENT existing 

at call tune - that is. just before any binding is done for its FUNCTION. Example: 

<SET A 0>S 


<DEFINE WRONG ( 'B "AUX" (A 1)) <EVAL .B»i 

WRONG 

<WR0NG .A>S 

1 

<0EFINE RIGHT ("BIND- E 'B "AUX" (A I)) <£VAL .B E»S 
RIGHT 



95 " 9 - 7 Functions 



The MDL Programming Language 

<RIGHT .A>S 


9.7J. Local Values versus ENVIRONMENTS 

SET. LVAL. VALUE. BOUND?. ASSIGNED?, and UMASSIGN all take a final optional argument which 
has not previously hern mriil ioncd: an ENVIRONMENT (or other TYPE*, see section 20.8). If this 
argument is given, the SET or LVAL is done in the ENVIRONMENT specified. LVAL cannot be 
abbreviated by . (period) if it is given an explicit second argument. 

This feature is just what it needed lo cure the INC bug mentioned in chapter 5. A "correct" INC can 
be defined as follow.: 

<DCFINE INC ("BIND" OUTER ATM) 

<SEI .AIM <♦ 1 <LVAL .ATM .0UTER>> .OUTER» 



9.8. ACTIVATION. " NAME". "ACT". AGAIN . and RETURN fl) 

EVALuaiion of a FUNCTION, after the argument LIST has been taken care of. normally consists of 
EVALuat lug each of the objects in the body in the order given, and returning the value of the last 
thing EVAI ed. If you want to vary this sequence, you need to know, at least, where the FUNCTION 
begins. Actually. EVAL normally hasn't the foggiest idea of where its current FUNCTION began. 
"Whcrc'd 1 start" information is bundled up with a TYPE called ACTIVATION. In "normal" FUNCTION 
EVALuaiion. ACTIVATION* arc not generated: one can be generated, and bound to an ATOM, in either 
of the two following ways: 

(1) Put an ATOM i tediately before the argument LIST. The ACTIVATION of the Function will 

be bound to that ATOM. 

(2) As the Inst thing hi the argument LIST, insert cither of the STRINGS "NAME" or "ACT" and 
follow it with an ATOM. The ATOM will be bound to the ACTIVATION of the Function. 

In this document "Function" (capitalized) will designate anything that can generate an ACTIVATION; 
besides TYPE FUNCUON. this class includes the FSUBRs PROG. BIND, and REPEAT, yet to be 
discussed. 



Each ACTIVATION refers explicitly to a particular evaluation of a Function. For example, if a 
recursive FUNCTION generates an ACTIVATION, a new ACTIVATION referring explicitly to each 
recursion step is generated on every recursion. 

Like TUPLEs. ACTIVATIONS are held in a control stack. Unlike TUPLES, there is no wax to get a copy 

9.7 - 98 Functions 












The MDL Programming Language 85 

of an ACTIVATION wliicli can usefully be returned as a value. (This is a consequence of the fact that 
ACTIVATION* refer to evaluations; when the evaluation is finished, the ACTIVATION no longer exists.) 
ACTIVATION* can be tested, like TUPLE*, by LEGAL? for legality. They are used by the SUBRs AGAIN 
and RETURN. 

AGAIN can take one argument: an ACTIVATION. It means "start doing this again", where "this" is 
specified by the ACTIVATION. Specifically. AGAIN causes EVAL to return to where It started working; 
on the body of the Function in the evaluation specified by the ACTIVATION. The evaluation is not 
redone completely: In particular, no re-binding (of arguments. "AUX" variables, etc) is done. 

RETURN can take two arguments: an arbitrary expression and an ACTIVATION, in thai order. It 
causes the Function evaluation whose ACTIVATION it is given to terminate and return EVAL of 
RETURN'S first argument. That is. RETURN means "quit doing this and return that", where "this" is the 
ACTIVATION — its second argument — and "that" is the expression — its firs! argument. Example: 

<DEFINE MY+ ("TUPLE" T "AUX" (M 0) "NAME" NM) 

<COND (<EHPTY? .T> <RETURN .M .NM>)> 

<SET M <♦ .H <1 .T>» 

<SET T <REST .T» 

<AGAIN .NM»S 
MY+ 

<HY* 1 3 <LENGTH "FOO"»S 
7 

<MY*>S 


Note: suppose an ACTIVATION of one Function (call it Fl) is passed to another Function (call it F2) — 
for example, via an application of F2 within Fl with FI's ACTIVATION ai an argument. If F2 
RETURNS to FI's ACTIVATION. F2 and Fl terminate immediately, and Fl_ returns the RETURN'S first 
argument. This technique is suitable for error exits. AGAIN can clearly pull a similar trick. In the 
following example. Fl computes ihc sum of F2 applied to each of its arguments; F2 computes the 
product of the elements of its structured argument, but it aborts if it finds an element that is not a 
number. 

<DEFINE Fl ACT ("TUPLE" T -AUX" (Tl .T)) 
<C0ND (<N0T <EMPTY? .Tl» 

<PUT .Tl 1 <F2 <1 .Tl> .ACT» 
<SET Tl <REST .Tl» 
<AGAIN .ACT>) 
(ELSE <+ ! .T>)»S 
Fl 



9.8 Functions 



The MDL Programming Language 



<DEFINE F2 <S A "AUX" (SI .S)) 

<REPEAT HY-ACT ((PRO 1)) 

<CONO (<NOT <EHPTY? .Sl» 

<COND (<NOT <TYPE? <1 .Sl> FIX FLOAT» 

<RETURH 'FALSE ("NON-NUMBER") -A» 
(ELSE <SET PRO <• -PRO <1 .Sl»»> 
<SET SI <REST -Sl») 
(ELSE <RETURN .PRD>)>»S 
F2 

<F1 '(1 2) '(3 4)>S 

14 

<F1 '(T 2) '(3 4)>S 

#FALSE ( "NON-NUMBER" > 



9.9. Argument List Summary 

The Following is a listing of all the various tokens which can appear In the argument LIST of a 
FUNCTION, in the nrdcr in which they can occur. Short descriptions of their effects are included. 
All of litem arc notional « thai is. any of them (in any position) can be left out or included — but 
the order in which ihey appear must be that of this list. "QUOTEd ATOM", "matching object", and "2- 
list" are defined below. 

(I) "BIND" 

imist be followed by an ATOM. It binds that ATOM to the ENVIRONMENT which existed 
when the FUNCTION was applied. 









(2) ATOMs and QUOTEd ATOMs (any number) 

are required arguments. QUOTEd ATOMs are bound to the matching object. ATOMs are 
bound lo EVAL of the matching object in the ENVIRONMENT existing when the FUNCTION 
was applied. 

(3) "OPTIONAL" or "OP1" (they're equivalent) 

is followed by any number of ATOMs. QUOTEd ATOMs. or 2- lists. These are optional 
arguments. If a matching object exists, an ATOM — either standing alone or the first 
element of a 2-list - is bound to EVAL of the object, performed in the ENVIRONMENT 
existing when the FUNCTION was applied. A QUOTEd ATOM - alone or in a 2-list - is 
bound to the matching object itself. If no such object exists. ATOMs and QUOTEd ATOMs 
arc lert unbound, and the first clement of each 2-list Is bound to EVAL of the 
corresponding second element. (This EVAL is done in the new ENVIRONMENT of the 
Function as it is being constructed.) 

9.8 - 9.9 Functions 



The MDL Programming Language 87 

- 

(4) "ARGS" (and not_ "TUPLE") 

11111*1 be followed by an ATOM. The ATOM is bound lo a LIST of all the remaining 
arguments, iinevaluat cd. (If there are no more arguments, the LIST is empty.) This 
LIST Is actual!? a REST of the FORM applying the FUNCTION. If "ARGS" appears in the 

argument list, "tuple" should not appear. 

(4) "TUPLE" fa lid pjjt "ARGS") 

IIIUSI be followed by an ATOM. The ATOM is bound to a TUPLE ("VECTOR on the control 
stack") of all the remaining arguments, evaluaied in the environment existing when the 
niNCTIOH was applied. (If no arguments remain, the TUPLE is empty.) If "TUPLE" 
appear* in the argument LIST. "ARGS" should not appear. 

(5) "AUX" or "EXTRA" (ihcy'rc equivalent) 

is followed by any number of ATOMs or 2-Hsts. These are auxiliary variables, bound 
away from the previous environment for the use of this Function. ATOMs are bound in 
the ENVIRONMENT of the? Function, but they are unassigned: the first element of each 2- 
lisl is both bound and assigned to EVAL of the corresponding second element. (This 
EVAL is done in the new ENVIRONMENT of the Function as it is being constructed.) 

(6) "NAME" or "ACT" (they're equivalent) 

must be foljowcd by an ATOM. The ATOM is bound to the ACTIVATION of the current 
evaluation nf the Function. 

A LSO -- in place of sections (2) (3) and (4). you can have 

(2-3-4) "CALl " 

which must he followed by an ATOM. The ATOM is bound lo the FORM which caused 
application of this FUNCTION. 

The special terms used above mean this: 

"QUOTEd ATOM" -- a two-clement FORM whose first element is the ATOM QUOTE, and whose second 
elemeni is any ATOM. (Can be typed -- and will be PRINTcd -- as 'atom,) 

'•Matching object" - that elemeni of a FORM whose position in the FORM matches the position of a 
required or nption.il argument in an argument LIST. 

"2-list" -- n two-element LIST whose first elemeni is an ATOM (or QUOTEd ATOM; see below) and whose 
second clement can he anything but a SEGMENT. EVAL of the second element is assigned to a new 
binding nf the first clement (the ATOM) an the "value by default" in "OPTIONAL" or the "initial value" 
in "AUX". In the case of "OPTIONAL", the first element of a 2-list can be a QUOTEd ATOM; in this 
case, an argument which is supplied is not EVALed. but if it is not supplied the second element of 
the LIST i_s EVALed and assigned to the ATOM. 

99 Functions 



88 The MDL Programming Language 

9.10. APPLY fll 

Occasionally ilirrc is a valid reason for the first element of a FORM not to be an ATOM- For example, 
the objrci in be applied to arguments may be chosen at run time, or it may depend on the 
arguments in M>iitC way. While EVAL is perfectly happy in this case to EVALuate the first element 
and go on from there, the compiler (I.cbling. 1979) can generate more efficient code if it knows 
whether the result of the evaluation will (I) always be of TYPE FIX. <2) always be an applicable non- 
FIX object that evaluates all its arguments, or (3) neither. The easiest way to tell the compiler if (1) 
or (2) is true is to use the ATOM HTII (section 7.1.2) or PUT (section 7.1.4) in case (I) or APPLY in case (2) 
as the first element of the rORH. {Note: case (1) can compile into in-line code, but case (2) compiles 
into a Fall}' mediated call into the interpreter.) 

<APPLY ob/ect *r$-t ... ar$-N> 

evaluates object and nil the argr/S and then applies the former to all the latter. An error occurs if 
object evaluates to something not applicable, or to an FSUBR, or to a FUNCTION (or user Subroutine — 
chapter 10) with -ARCS" or "CALL" or OUOTEd arguments. 

Example: 

<APPLY <NTM .ANALYZERS 

<LENGTH <MEM0 <TYPE .ARG> .ARGTYPES>» 
.ARG> 

calls a function to analyze .ARG. Which function is called depends on the TYPE of the argument; 
this represents the idea of a dispatch table. 



9.11. CLOSUR E 

<CLOSURE function ai ... a/V> 

where function is a FUNCTION, and si through aN are any number of ATOMs. returns an object of 
TYPE CLOSURE. This can be applied like any other function, but. whenever it is applied, the ATOMs 
given in the call to CLOSURE are first bound to the VALUES they had when the CLOSURE was 
generated, then the function is applied as normal. This is a "poor man's funarg". 

A CLOSURE is useful when a FUNCTION must have state information remembered between calls to it. 
especially in these two cases: when the LVALs of external state ATOMs might be compromised by other 
program*., or when more than one distinct sequence of calls are active concurrently. Example of the 
latter: each object of a structured NEWTYPE might have an associated CLOSURE that coughs up one 
element at a time, remembering between calls how far it got. Often only one ATOM will be included 
in the CLOSURE, with a value in the CLOSURE that is a structure containing all the relevant 
informal ion. 

9-10 - 9.11 Functions 






The MDL Programming Language go 



Chapter 10. Looping 

10.1. PROG ami REPEAT HI 

PROG and REPEAT arc almost identical FSUBRs which make it possible to vary the order of EVALuation 
arbitrarily -- that is. to have "jumps". The syntax of PROG ("program") is 

<PROG flc/.-flfom suyJisi body> 

where 

«/ is an opiional ATOM, which is bound to the ACTIVATION of the PROG. 

*uv is a LIST which looks exactly like that pan of a FUNCTION'S argument LIST which follows 
an "AiiX", and serves exactly the same purpose. It is not optional. If you need no temporary 
variables or "ACT", make it (). 

body is a non-ZCTO number of arbitrary MDL expressions. 

The syntax of REPEAT is identical, except that, of course. REPEAT is the first element of the FORM. 
not PROG. 

10.1.1. Basic EVALuation [I] 

Upon entering a PROG, an ACTIVATION is always generated. If there is an ATOM in the right place. 
the ACIIVAI10N 1* also bound to thai ATOM. The variables in the mux (if any) are then bound as 
indicated in the rfu*. AH of the expressions in body are then EVALuated in their order of occurrence. 
If nothing untoward happens, you leave the PROG upon evaluating the last expression in body, 
returning the value of that laM expression. 

PROG thus provides a way to package together a group of things you wish to do, in a somewhat more 
limited way than can be done with a FUNCTION. But PROGs are generally used for their other 
properties. 

10 - 10.1.1 Looping 



r 



90 The MDL Programming Language 

REPEAT acts in nil way* exactly like a PROG whose last expression is <AGAIN> . The only way to leave 
a REPEAT is to explicitly use RETURN (or GO with a TAG - section 10.4). 

10.1.2. AGAIN and RETURN in PROG and REPEAT [1] 

Within a PROG or REPEAT, you always have a defined ACTIVATION, whether you bind it to an ATOM 
or not. [In fact the interpreter binds it to the ATOM LPR0G\ I -INTERRUPTS ("last PROG"). The FSU8R 
BIND is Identical tn PROG except that BIND does not bind that ATOM, so that AGAIN and RETURN with 
no ACTIVATION argument will not refer to it. This feature could be useful within MACROs.] 

If AGAIN is used with no arguments, it uses the ACTIVATION of the closest surrounding PROG or 
REPEAT with hi J.he curre nt function (an error occurs if there is none) and re-starts the PROG or 
REPEAT without rebindlng the #ux variables, just the way it works In a FUNCTION. With an 
argument, it can of course re-start any Function (PROG or REPEAT or FUNCTION) within which it is 
embedded at run lime. 

As With AGAIN, if RETURN is given no ACTIVATION argument, it uses the ACTIVATION of the closest 
surrounding PROG or REPEAT within the current function and causes that PROG or REPEAT to 
terminate and return RETURN'S first argument. If RETURN is given no arguments, it causes the 
closest surrounding PROG or REPEAT to return the ATOM T. Also like AGAIN, it can. with an 
ACTIVATION argument, terminate any Function within which it is embedded at run time. 

10.1.3. Examples [I) 

Examples oT the use of PROG arc difficult to find, since it is almost never necessary, and it slows 
down the interpreter (chapter 2-1). PROG can be useful as a point of return from the middle of a 
computation, or inside a COND (which see), but we won't exemplify these uses. Instead, what follows 
is an example of a typically poor use of PROG which has been observed among Lisp (Moon. 1974) 
programmers using MDL. Then, the same thing is done using REPEAT. In both cases, the example 
FUNCTION just adds up all its arguments and returns the sum. (The SUBR GO is discussed in section 
10.4.) 

;"l_isp sty!*" 

<DEFINE MY+ ("TUPLE" TUP) 
<PROG (SUM) 

<SET SUM 0> 
LP <CON0 (<EMPTY? .TUP> <RETURN -SUM>)> 

<SET SUM <+ .SUM <1 .TUP>» 
<SET TUP <REST .TUP» 
<GO LP>» 



10.1.1 - 10.1.3 Looping 









The MD1. Programming Language 91 

;"MDL style" 

<DCFINC MY* ("TUPLE" TUP) 
<REPEAT ((SUM 0)) 

<C0ND (<EHPTY? .TUP> <RETURN .SUM>)> 
<SET SUM <*■ .SUM <1 .TUP» 
<SET TUP <REST .TUP»» 

Of course, neither of the above is optimal MDL code for this problem, since MY+ can be written 
using SEGMENT evaluation as 

(DEFINE MY* ("TUPLE" TUP) <♦ !.TUP>> 

There arc. of course, lots of problems which can't be handled so simply, and lot* of uses for REPEAT. 



10.2. MAPF and MAPR; Basics Til 

MAPF ("map f ir.M") and MAPR ("map rest") are two SUBRs which take care of a majority of cases which 
require loops over data. The basic idea is the following: 

Suppose you have a LIST (or other structure) of data, and you want to apply a particular function 
to each element. That is exactly what MAPF does: you give it the function and the structure, and it 
applies the function to each clement of the structure, starling with the first. 

On the. other hand. Ml p pose you want to change each element of a structure according to a 
particular algorithm. This can he done only with great pain using MAPF. since you don't have easy 
access io the structure inside the function: you have only the structure's elements. MAPR solves the 
problem by applying a function to RESTs of a structure: first to <REST structure 0> r then to 
<REST structure l>, etc. Thus, the function can change the structure by changing its argument, 
for example, by a <PUI argument 1 iomcth,ns> . It can even PUT a new element farther down the 
structure, which will be seen by the function on subsequent applications. 

Now suppose, in addition to applying a function to a structure, you want to record the results - the 
values returned by the function - in another structure. Both MAPF and MAPR can do this: they both 
take an additional function as an argument, and. when the looping is over, apply the additional 
function m all the results, and then return the result of that application. Thus, if the additional 
function is .LIST, you gel a LIST of the previous results: if it is .VECTOR, you get a VECTOR of 
results: etc. 

Finally, it might he the case that you really want to loop a function over more than one structure 
simultaneously. For instance, consider creating a LIST whose elements are the element-by-element 
sum of the contents of two other LISTs. Both MAPF and MAPR allow this; you can. in fact, give each 
of them any number of structures full of arguments for your looping function. 

10.1.3 - 10.2 Looping 






92 The MDL Programming Language 

This was all mentioned because MAPF and MAPR appear to be complex when seen baldly, due 10 ihe 
fact that the argument descriptions must take into account the general case. Simpler, degenerate 
cases arc usually tlic ones used. 

10.2. 1. MAPF [I] 

<HAPF fin/tit loop/ si s2 ... sN> 
where (after argument evaluation) 

(mult is something applicable that evaluates all its arguments, or a FALSE; 

loopf is something applicable to /v arguments that evaluates all its arguments; and 

si through sN arc structured objects (any TYPE) 
does the following: 

(1) First, it applies loopf lo N arguments: the first element of each of the structures. Then it 
REST* r.-irh of the structures, and docs the application again. looping until any of the structures 
runs nut of dements. Each of Ihe values returned by loop/ is recorded in a TUPLE. 

(2) Then, it applies 'mall to all (he recorded values simultaneously, and returns the result of that 
application. If tm.iif is a FALSE, the recorded values are "thrown away" (actually never recorded 
in the first place) and the MAPF returns only the last value returned by loop/. If any of the si 
structures is duply, *o that loopf is never invoked. flnaif is applied to no arguments; if finalf is a 
FALSE. MAPF returns #FAL5E (). 

10.2.2. MAPR [1] 

<MAPR flnslf loopf si s2 ... sN> 

acts just like MAPF, but. instead of applying loopf to NTHs of the structures - that is. <NTH si 1>, 
<NTH si 2>. etc. -- it applies it to RESTs of the structures - that is. <REST si 0>. <REST si 1>, etc 

10.2.3. Examples [I] 

Make the element-wise sum of two LISTs: 

<MAPF .LIST .* '(1 2 3 4) '{10 11 12 13)>S 
(11 13 15 17} 

10.2 - 10.2.3 Looping- 






The MD1. Programming Language 93 

Change a UVFCTOR to contain double its values: 

<SET UV ' ([5 6 7 8 9]>S 
l[5 G 7 8 9! 3 
<MAPR <> 

'FUNCTION ((L) <PUT .L 1 <* <1 .L> 2») 
-UV>S 

It 10 12 14 16 1ST ] 

Create a STRING from CHARACTERS: 

<MAPF .STRING 1 '["MODELING" "DEVELOPMENT" -LIBRARY"1>S 
"MDL" 

Sum the squares of (he elements of a UVECTOR: 

<MAPF .♦ ^FUNCTION ((N) <■ .N .N>) '![3 4 ]>S 
25 

A parallel Assignment FUNCTION {Note thai ihe arguments lo MAPF are of different lengths.): 

<DEFINF PSET ("TUPLE" TUP) 
<MAPF <> 

.SET 

.TUP 

<REST .TUP </ <LENGTH .TUP> 2»»S 
PSET 

<P5ET A B C 1 2 3>i 
3 

.AS 
1 

.BS 
2 

-C$ 
3 

Note: it is easy to forge! lhat tlnntf must evaluate its arguments, which precludes the use of an 
FSUBR. It is primarily for this reason thai the SUBRs AND? and OR? were invented. As an example, 
the predicate =? could have been defined this way: 



10.2.3 Looping 




94 The MDL Programming Language 

<DEFINE =? (A B) 

<COND (<MONAD? .A> <==7 .A .B>) 
(<AND <NOI <HONAD? .B» 

<==? <TYPE .A> <TYPE -B» 
< = =? <LENGTH .A> <LENGTH .B>» 
<HAPF .AND? . = ? .A .B>)» 

[By (lie way. the following ihowi how to construct a value that has the same TYPE as an argument. 

<DEFIHC MAP-NOT (S) 
<COHD (<MFMQ <PR1HTYPE .S> ''[LIST VECTOR UVECTOR STRING3> 
<CHTYPE <MAPF ,<PRIMTYPE -S> .NOT -S> 
<TYPE -S»)» 

If work* hccause the ATOM* Thai name the common STRUCTURED PRIMTYPEs (LIST. VECTOR. 
UVECTOR and STRING) have as GVALs the corresponding SUBRs lo build objects of those TYPEs.J 

10.3. More on MAPF and MAPR 



10.3.1. HAPRfcl 

MAPRET is a SUBR ihal enable* the loopf being used In a HAPR or MAPF (and lexically Within it. that is, 
not separated from it hy a function call) to return from zero to any number of values as opposed to 
just one. For example, suppose a MAPF of the following form is used: 

<MAPF .LI5T <FUNCTI0N (E) ..-> ...> 

Now suppose that the programmer wants to add no elements to the final LIST on some calls to the 
FUNCTION and add many on other calls to the FUNCTION. To accomplish this, the FUNCTION simply 
calls MAPRET with the elements it wants added to the LIST. More generally. MAPRET causes its 
argument.', to he added to the final TUPLE of arguments to which the tinalf will be applied. 

Warning: MAPRET i* guaranteed to work only if it is called from an explicit FUNCTION which is the 
second argument to a MAPF or MAPR. In other words, the second argument to MAPF or MAPR must be 
^FUNCTION ( . . . ) or <FUHCTI0N ...> if MAPRET is to be used. 

Example: the following returns a LIST of all the ATOMs in an OBLIST (chapter 15): 

<DEFINE ATOMS (Oil) 
<MAPF .LIST 

<FUNCTI0N (8KT) <MAPRET ! -BKT» 
.0B>> 

10.2.3 - 10.3.1 Looping 






The MDL Programming Language 



95 



10.3.2. MAPS TOP 



MAPSTOP is the same as MAPRET. except thai, after adding its arguments, if any. to the final TUPLE. 
it forces llic application of flnslt to occur, whether or not the structured objects have run out of 
elements, Example! the following copies the first ten (or all) elements of Its argument into a LIST: 



<DEFINE FIRST-1EN (STRUC "AUX" (I 10)) 
<MAPF .LIST 

<FUNCriON (E) 

<COH0 (<0? <SET I <- .1 1>» <MAPST0P .E>)> 
.E> 
-STRUC>> 



10.3.3. MAPLEAVE 



MAPLCAVC is analogous to RETURN, except that it works in (lexically within) MAPF or MAPR instead of 
PROG or REPI AT. It Mushes the accumulated TUPLE of results and returns its argument (optional, T 
by default) as the value of the MAPF or MAPR. (it finds the MAPF/R that should return in the current 
binding of the ATOM LMAP\ --INTERRUPTS ("last map").) Example: the following finds and returns 
the first imn-jrcro element of its argument, or #FALSE ( ) if there is none: 



<0EFINE FIRST-NO (STRUC) 
<MAPF <> 

<FUNCTION (X) 

<COMD (<N==? .X 0> <MAPLEAVE .X>)>> 
,STRUC>> 



10.3. -I. Only two arguments 

If MAPF or MAPR is given only two arguments, the iteration function loopf is applied to no arguments 
each rime, and the looping continues indefinitely until a MAPLEAVE or HAPSTOP is invoked 
Example: the following return* a LIST of the integers from one less than its argument to zero, 

<0EFINE LNUM <N> 

<MAPF .LIST 

<FUNCTI0N ( ) 

<CON0 (<0? <SET N <- .N 1>» <MAPST0P 0>) 
(ELSE -N)»» 

One principle use of this form of MAPF/R involves processing input characters, in cases where you 
don t know how many characters are going to arrive. The example below demonstrates this, using 
SUBRs wh.ch are more fully explained in chapter II. Another example can be found in chapter 13. 



10.3.2 - 10.3.4 



Looping 



96 The MDL Programming Language 

Example: the following rilNCTION reads characters from the current input channel until an S (ESC) 
ii read, mid then returns tvhat was read as one STRING. (The SUBR READCHR reads one character from 
the input channel and returns it. NEXTCHR returns the next CHARACTER which READCHR will return — 
chapter II.) 

<OEFINE RDSTR ( ) 
<MAPF .STRING 

<FUNCTION () <COND (<NOT <<*«? <NEXTCHR> <ASCII 27>» 

<REAOCHR>) 
(T 
<MAPSTOP>)»>>S 
RDSTR 

<PROG () <READCHR> .-Flush the ESC ending this input. - 

<RDSTR»S 
ABC1Z3<* 3 4>S"ABC123<+ 3 4>" 

10.3.5. STACKFORH 

The FSUBR STACKTORH is archaic, due to improvements in the implementation of MAPF/R. and it 
should noi be used in new programs. 

<STACKFORM function *r g pred> 

is exactly equivalent to 

<MAPF /unction 

<FUHCTI0N () <C0ND (prcd arg) (T <MAPST0P>>»> 

In fact MAPF/R is more powerful, because MAPRET. MAPSTOP. and MAPLEAVE provide flexibility not 
available with STACKfORM. 



10.4. GO and TAG 

GO is provided in MDL for penple who can't recover from a youthful experience with Basic. Fortran. 
PL/I. etc. The SUBR* previously described in this chapter are much more tasteful for making good, 
clean, "structured" programs. GO just bnlUxcs things. 

GO is a SUBR which allows you to break the normal order of evaluation and re-start just before any 
top-level expression in a PROG or REPEAT. It can take two TYPEs of arguments: ATOM or TAG. 



10.3.4 - 10.4 Looping 









The MDL Pmcfraintiiiiig Language 

Civr„ .-.„ AIOM. GO searches the body of the immediately surrounding PROG or REPEAT Within the 
current runcn.„, »,„.i*g after «». for an occurrence of that ATOM a, the top J.v.| of ^x fThU 
search ,s nffrcve.y a MCHQ.J If I. doesn't find the ATOM, an error occurs. If it does •v«T«tion \l 
resumed at the expression following the ATOM. evaluation is 

™?cTwo\Jd teTSZLT a " U ri " Ur r S ° bJCC ' S ° f TYPE TAG - T " iS SUBR Iak « °" e •rg4.m«U S ,. ATOM 
To aUow v« n ?n T "^'T f ° r * G °- A " 0bjCCl ° f TYPE TAG comai " i ^ff-icn, information 
to a low you to GO to any top-level position in a PROG or REPEAT from within any function called 

^ ooAr 'VJl* '"' d !" C ." f . a ' ,y PR ° G ° r REPEAI ■*■* «"«« *«■ Also like ACTIVATIONS. TAG- 



.urn a Oonr „~ ornr«T . . -—.-"■ ......... _-,, cu /uu . rtiao llkf fttllUATIONS. TAG; 



10.5. Lo opin g versu s Re cursion 

^".^n^XwuL^Z , b ° """' TSSTS' <*™P*>« of "pure Lisp" (Moon. ,974, or 
!, 7 I ' ' ImplMncnl any repetitive algorilhu. using recursion. The advantage 

e,i, ,i»a \7!'"lf '" "? '"*""'"' '•" '"" *»— ° ¥W '"""'•"• is ''»« '"« overhead of c»" s is 

« i " « i"rr; " s tt (i * y - hlss " '"*" l, * if * pr " ,,td "*«■> ■■* * »«« *m** 

reoeH on is ^ „ , 'T T* ^ "" d '""" """ e diffiCU " '° »»«nt«il.. A program whose 
'he ob c" , one si 1 . I ^ Y" UC ' , ' r ; d ""^ <f ° r CXi "" ple - " W,,k " , 8 * "«" '° visi. each monad in 
' evcls~ '"" S f ° r COV "'" B ""' "'""'" ° f "" "«"=.ure and recursion ,o change 



l "- 4 ■ ,0S Looping 






The MDL Programming Language 



Chapter 11. Input/Output 

The MDI interpreter ran transmit infonnatinu between an object in MDL and an external device 
in three ways. Historically, the first way was to convert an object into a siring of characters, or 
vice versa. The transformation is nearly one-to-one (although some MDL objects, for example 
TUPLES, cannot be input in this way) and is similar in style to Fortran's formatted I/O. It is what 
READ and PRINT do. and it is the normal method for terminal I/O. 

The second way is used fnr the contents of MDL objects rather than the objects themselves. Here 
an imag e nf numhrrs or characters within an object is transmitted, similar in style to Fortran's 

uiiformniu.i I/O 

The third way is to dump an object in a clever format so that it can be reproduced exactly when 
input the next time. Exact reproduction means that any sharing between structures or self- 
reference is preserved: only the garbage collector itself can do I/O in this way. 



II. I. C onversion I/O 

All conversinn-l/O SUflRs in MDL take an optional argument which directs their attention to a 
specific I/O channel. This section will describe SUBRs without their optional arguments. In this 
situation, ihcy all refer to a particular channel by default, initially the terminal running the MDL. 
When given xn optional argument, that argument follows any arguments indicated here. Some of 
these SUDRs also have additional optional arguments, relevant to conversion, discussion of which will 
be deferred until later. 

1144. Input 

All of the following input Subroutines, when directed at a terminal, hang until S (ESC) is typed and 
allow normal use of rubout. *D, **L and "*0. 






II - 11-1-1 Input/Output 









The MDL Programming Language 99 

11.1.1.1. READ 

<READ> 

This returns the rnrire MDL object whose character representation is next in the input stream. 
Successive <RLAD>s return successive objects. This is precisely the SUBR READ mentioned in chapter 
2. See also sections 11.3. 15.7.1. and 17.1.3 for optional arguments, 

11.1.1.2. RFAtiCilR 

<REAOCHR> 

<"re.iri character") returns the next CHARACTER in the input stream. Successive <READCHR>s return 
successive CHARACTERS. 

11.1.1.3. HEXTCHR 

<NEXTCHR> 

("next character") returns the CHARACTER which READCHR will return the next time READCHR is called. 
Multiple <NEXTCHR>s. with no input operations between them, all return the same thing. 

11.1.2. Output 

If an object 1o be output requires (or can tolerate) separators within it (for example, between the 
elements in a structured object or after (lie TYPE name in "# notation"), these conversion-output 
SUBR* will use a carriagc-retuni/line.fccd separator to prevent overflowing a line. Overflow is 
detected in advance from elements of the CHANNEL in use (section 11.2.8). 

11.1.2.1. PRINT 

< PRINT any> 

This outputs, in order. 

(1) a carriage-return line-feed. 

(2) the character representation of EVAL of its argument (PRINT is a SUBR). and 

(3) a space 

and then returns EVAL of its argument. This is precisely the SUBR PRINT mentioned in chapter 2. 

H.l.2.2. PRIN1 

<prini *«>■> 

outputs just the representation of. and returns. EVAL of any. 

li.1.1.1 - 11.1.2.2 Input/Output 



100 The MDL Programming Language 

11. 1.2.3. PR1HC 

<PRINC *ny> 

<"*priul characters'") acts exactly like PR1N1, except that 

(1) if its argument is a STRING or a CHARACTER, it suppresses the surrounding "s or initial !\ 
respectively: or. 

(2) if its argument is an ATOM, it suppresses any \s or 08LIST trailers (chapter 15) which would 
otherwise lie necessary. 

If PRINC's argument is a structure containing STRINGS. CHARACTERS, or ATOMs. the service mentioned 
will be done for all of them. Ditto for the ATOM used to name the TYPE in "4 notation". 

11.1.2.4. TERPRI 

<TERPRI> 
("terminate printing") outputs a carriage-return line-feed and then returns #FALSE ( )! 

1 1. 1.2.5. CRLF 

<CRLF> 
("carriage-return line-feed") outputs a carriage-return line-feed and then returns T. 

11.1.2.6. FLATSIZE 

<FIATSIZF any max;fix radix;fix> 

docs not actually cause any output to occur and does not take a CHANNEL argument. Instead, It 
compares m*v with the number of characters PRIN1 would take to print any. If max is less than the 
number of characters needed (including the case where any is self-referencing). FLATSIZE returns 
#FALSE ( ); otherwise, it returns the number of characters needed to PRIN1 any. radix (optional, ten 
by default) is used for converting any Fixes that occur. 

This SUBR is especially useful in conjunction with (section 11.2.8) those elements of a CHANNEL 
which specify the number of characters per output line and the current position on an output line. 



1. 1.2.3 - 11.1.2.6 Input/Output 



The MDL Program mi tig Language 



101 



11.2. CHANNE L ( t h e TYP E) 

I/O channels arc dynamically assigned in MDL. and are represented by an object of TYPE CHANNEL, 
which is of PRIMTYPE VECTOR. The formal of a CHANNEL will be explained later, in section 
' 1 .' B First, how in generate and use them. 

II 2.1. OPEN 

<0PCN mode fite-spsc> 
OP 

<OPF.N mode namel name? device dir> 

OPEN is a SUOR Wllldl creates and returns a CHANNEL. All Its arguments must be of TYPE STRING, 
and .VM arc optional. The preceding statement is false when the device is "INT" or "NET"; see 
sections 11,9 ami 11.10. If the attempted opening of an operating-system I/O channel fails. OPEN 
returns #FAI SE {rc*<on:strin$ file-spec :string status:fir) . where the reason and the status are 
supplied by the Operating system, and the file-spec is the standard name of the file (after any name 
transformations by the operating system) that MDL was trying to open. 

The choice of mode is usually determined by which SUBRs will be used on the CHANNEL, and whether 
or not the device is a terminal. The following table tells which SUBRs can be used with which modes, 
where OK indicates an allowed use: 



"READ" "PRINT" "READ8 1 
OK OK 

OK 

OK 



"PRINTB" mode /SUBRs 
"PRINTO" 

REAO REAOCHR NEXTCHR REAOSTRING FILECOPY FILE-LENGTH 

LOAD 
PRINT PRINI PRINC IMAGE CRLF TERPRI FILECOPY 

PRINTSTRING BUFOUT NETS RENAME 
READB GC-REAO 
PRINTB GC-DUMP 
OK OK OK ACCESS 

OK OK OK OK RESET 

OK OK ECHOPAIR 

OK TTYECHO TYI 

* PRINTing (or PRINling) an RSUBR (chapter 19) on a "PRINTB" or "PRINTO" CHANNEL has special 
effects. 



OK* 



OK 
OK 
OK 



"PRINTB" difTrrs from "PRINTO" in that the latter mode is used to update a "OSK" file without 
copying it. "READB" and "PRINTB" are not used with terminals. "REAO* is the mode used by 
default. 



11.2- 1L2.1 



Input/Output 



102 The MDL Programming Language 

The next one lo four argument % 10 OPEN apecify the file involved. If only one STRING is used, it 
can contain Ihe ml Ire specification, according to standard operating-system syntax. Otherwise, the 
string(s) nre interpreted as follows: 

njirnei is the firM file name, that pari to the left of the space <in the ITS version) or period (in the 
Tenex and Tops-20 versions). The name used by default is <VALUE NM1>, if any. otherwise 
"INPUT. 

n*mtr2 is the second file nauic. that part to the right of the space (ITS) or period (Tenex and Tops- 
20). The name used by default Is <VALUE NM2>. if any. otherwise ">" (ITS) or "HUD" and highest 
version number (Tenex) or generation number (Tops-20). 

device is the device name. The name used by default is <VALUE DEV>, if any. otherwise "DSK" . 
(Devices about which MDL has no special knowledge arc assumed to behave like "DSK".) 

dir is ihe disk-directory name. The name used by default is < VALUE SNM>, if any. otherwise the 
""working-directory" name as defined by the operating system. 

Examples: 

<OPEN "PR INI- "TPL:"> opens a conversion-output CHANNEL to the TPL device. 

<OPEN "PRINT "DUMMY" "NAMES" "TPL" > does the same. 

<0PEN "PRINT" -TPL"> open* a CHANNEL to the file DSK:TPL > (ITS version) or DSK:TPL.MUD 
(Tenex and Tops-20 versions). 

<OPEN "READ" TOO" ">" "DSK" "GUEST"> opens a conversion-input CHANNEL to the given file. 
<OPEN "READ" "GUEST ;F00"> docs the same in the ITS version. 

11.2.2. OPEN-NR 

OPEN-NR is the same as OPEN, except that the date and time of last reference of the opened file are 
not changed. 

11.23. CHANNEL (the SUBR) 

CHANNEL is called exactly like OPEN, but it always returns an unopened CHANNEL, which can later be 
opened by RESfcl (below) just as if it had once been open. 



11.2.1 - 11.2.3 Input/Output 



The MDl- Prog ra nulling Language 103 

11.2.4. FILE-FXISTS? 

FILE-EXISTS? tests for the exigence of a file without creating a CHANNEL, which occupies about a 
hundred machine words of storage. It takes file-name arguments just like OPEN (but no mode 
argument) and rrliirns either T or *FAL5E (reason:strmg status:fix) , where the reason and the status 
are supplied by the operating system. The date and time of last reference of the file are not 
changed. 

11.2.5. CLOSE 

<CL0SE ch*nnel> 

closes channel and rciurus its argument, with its "state" changed to "closed". If channel is for output, 
all buffered OUtpni is written OUt first. No harm is done if channel is already CLOSEd. 

11.2.6. CHANt.IST 

<CUANLIST> 

returns a L 1ST whose elements are all the currently open CHANNELS. The first two elements are 
usually .INCHAN and .OUTCHAN (see below). A CHANNEL not referenced by anything except 
<CHANLIST> will be CLOSEd during garbage collection. 

11.2.7. INCHAN and OUTCHAN 

The channel used by default for input SUBRs is the local value of the ATOM INCHAN. The channel 
used by default for output SUBRs is the local value of the ATOM OUTCHAN. 

You can direct I/O to a CHANNEL by SETting INCHAN or OUTCHAN (remembering their old values 
somewhere). Pr by giving the SURR you wish to use an argument of TYPE CHANNEL. (These actually 
have the same effect, because READ binds INCHAN to an explicit argument, and PRINT binds OUTCHAN 
similarly. Thus the CHANNEL being used is available for READ macros (section 17.1) and PRINTTYPEs 
(section 6.4. »U 

By the way. a gnod trick for playing with INCHAN and OUTCHAN within a function is to use the ATOMs 
INCHAN and OUTCHAN as "AUX" variables, rc-binding their local values to the CHANNEL you wani. 
When you Iravp. of course, the old LVALs arc restored (which is the whole point). The ATOMs must be 
declared SPECIAL (chapter 14) for this trick to compile correctly. 

INCHAN and OUTCHAN also have global values, initially the CHANNEL* directed at the terminal running 
MDL. Initially, INCHAH's and OUTCHAN's local and global values are the same. 

U.2.4 - 11.2-7 Input/Output 



104 

The MDL Programming Language 

11.2.8. Content* of channels 

The content* of an object of TYPE CHANNEL are referred lo by the I/O SUBRs each lime such a SUBR 
is used- If you change the contents of a CHANNEL (for example, with PUT), the next use of that 
CHANNEL will be changed appropriately. Some elements of CHANNELS, however, should be played with 
seldom, if ever, and only at your peril. These are marked below with an e (asterisk). Caveat user. 

There follows fl table of ihr contents of a CHANNEL, the TYPE of each element, and an interpretation. 
The format used is the following; 

element -nuntben type interpretation 

11.2.8.1. Output CHANNELS 

The contents of a CHANNEL used for output are as follows: 
transcript ehanucKs) (see below) 

device-dependent information 

Channel number (ITS) or JFN (Tenex and Tops-20). for internal or closed 

uinilc 

firsr file name argument 

second file name argument 

device name argument 

directory name argument 

real first file name 

real second file name 

real device name 

real directory name 

various status bits 

PDP-10 instruction used to do one I/O operation 

number of characters per line of output 

current character position on a line 

number of lines per page 

current line number on a page 

access pointer for f ile-oricnted devices 

radix for FIX conversion 

sink for an inierual CHANNEL 

N.B.: The elements of a CHANNEL below number 1 are usually invisible but are obtainable via <NTH 
<TOP eh*nnr-t> /.'*>. for .some appropriate fix. 

The transcript-channel* slot has this meaning: if this slot contains a LIST of CHANNEU. then 
anything .upnt or output on the original CHANNEL is output on these CHANNEL*. Caution: do not use 
a CHANNEL as its own transcript channel: you probably won't live to tell about It 

112.8- II.2.8.I Input/Output 



-I: 


LIST 


• 0: 


vanes 


* 1: 


FIX 


* 2: 


STRING 


* 3: 


STRING 


• 4: 


STRING 


* 5: 


STRING 


• 6: 


STRING 


• 7: 


STRING 


* 8: 


STRING 


• D: 


STRING 


'10: 


STRING 


ell: 


FIX 


el2: 


FIX 


13: 


FIX 


14: 


FIX 


15: 


FIX 


16: 


FIX 


17: 


FIX 


18: 


FIX 


19: 


FIX 






The MI)i Programming Language 



X05 



11.2-8.2- Input CHANNEL* 

The contents of die element* up 10 number 12 of a CHANNEL used for input are Hie same as ihat for 
oiilpui. The remaining elements are as follows ((same) indicates that the use is the same as that for 
output): 



13: varies 
•Mt FIX 
'15: FIX 

16: LIST 

17: FIX 

18: FIX 

19: STRING 



object evaluated when end of file is reached 
nne "look-ahead" character, used by READ 

PUP-io instruction executed waiting for input 
quriic of buffers for input from a terminal 
acce.ss pointer for f ile-orientrd devices (same) 
radix for FIX conversion (same) 
buffer for input or source for internal CHANNEL 



f 






11.3. End-of-Fik- "Kouiinc" 

As mentioned above, an explicit CHANNEL is the first optional argument of all SUBRs used for 
conversion I/O. The second optional argument for conversion- Input SUBRs is an "end-of-f lie 
routine" -- thai is. something for the input SUBR to EVAL and return, if it reaches the end of the file 
it is rending. A typical cnd-or-file argument is a QUOTEd FORM which applies a function of your*. 
The value of ibis argument used by default is a call to ERROR. Note: the CHANNEL has been CLOSEd 
by the time this argument is evaluated. 

Example: ihr following FUNCTION counts the occurrences of a character in a file, according to lis 
arguments The file name*, device, and directory are optional, with the usual names used by default. 

<DCriNE COUNT-CIIAR 

(CHAR "TUPLE- FILE "AUX" (CNT 0) ( CHN <0PEN -READ" !.FILE>>) 

<C0ND (.CHN ;-If CHN 1s FALSE, bad OPEN: return the FALSE 

so result con be tested by another FUNCTION." 
<REPEAT ( ) 

<AND < = = ? .CHAR <READCHR .CHN *<RETURN»> 

<SEI CNT <♦ 1 .CNT>>» 

;"Until EOF. keep reading and testing a character at a time." 

-CNT ;"Then return the count. ")>> 



11.2.8.2 - 11.3 



Input/Output 



106 The MDL Programming Language 

11.4. Imaged I/O 

11.4. 1. Input 
11*4,1.1. REAOB 

<RCADB htifrerwector-or-storage channel eof:any> 

The channel IUUM he npen in "RE ADR" mode. READS will read as many 36-bit binary words as 
necewnry in fill the buffer fwhosc UTYPE must be of PRIMTYPE WORD), unless it hits the end of file. 
READO returns rlic number of words actually read, as a FIXed-point number. This will normally be 
the length nf thr buffer, unless the end of file was read, in which case it will be less, and only the 
beginning nf buffer will have been filled (SUB5TRUC may help). An attempt to READS again, after 
buffer is not filled, will evaluate the rnd-of-file routine cot. which is optional, a call to ERROR by 
default. 

11.4.1.2. READSTR1NG 

<REAfl.STRlNG buffer string channel stOp:ftx-or-stnng eof> 

is the STRING aiming to READS, where buffer and eat are as in READB, and channel is any input 
CHANNEL (.IMCHAN by default), stop tells when to stop inputting: if a FIX, read this many 
CHARACTER* (fill up buffer by default): if a STRING, stop reading if any CHARACTER in this STRING is 
read (don't include tills CHARACTER in final STRING). 

1 1.4.2. Output 

11.4.2.1. PRINTS 

^PRINTS buffcrwector-or-storare channel) 

This call writes the entire contents of the buffer into the specified channel open in "PRINTS" or 
"PRINTO" mode. It returns ljuffer. 

11.4.2.2. PRINISTR1NG 

<PRTNTSTRING buftenslring channel count ;ftx> 

is analognus to READSTR1NG. It output* buffer on channel, either the whole thing or the first count 
characters, and returns the number of characters output. 



11.4 - 11.4.2-2 Input/Output 






The MDL Programming Language I07 

11.4.2.3. IMAGE 

<IMAGC fix <hnnnel> 

is a rather spccial-purpose SU8R. When any conversion-output routine outputs an ASCII control 
character (with special exception* like carriage-return*, line-feeds, etc.). it actually outputs two 
characters: ' (circumflex), followed by the upper-case character which has been control-shifted. 
IMAGE, nn Hie other hand, always outputs Hie real thing: that ASCII character whose ASCII 7-bit 
code is hx. It is guaranteed not to give any gratuitous line-feeds or such, channel is optional. 
.OUTCHAN by default, and its slots for current character position (number 14) and current line 
number (Ifi) are imt updated. IMAGE returns fix. 



11.5. Dump e d I/O 

II. 5.1. Output: GC-DUMP 

<GC-DUMP jny printb:eh*nnel-or-ff,lse> 

dumps any on pnnlb in a clever format so that GC-READ (below) can reproduce any exactly. Including 
sharing. mny cannot live nn the control stack, nor can it be of PRIMTYPE PROCESS or LOCO or ASOC 
(which see), smy is returned as a value. 

If prfntb is a CHANNEL, it must be open in "PRINTS- or -PRINTO" mode- If printb is a FALSE. 
GC-DUMP instead returns a UVECTOR (of UTYPE PRIMTYPE WORO) that contains what it would have 
output nn n CHANNEL. This UVECTOR can be PRINTBed anywhere you desire, but. if it is changed in 
any w av. GC-RCAD Will not be able to input it. Probably the only reason to get it is to check it* 
length before output. 

Except for the miniature garbage collection required. GC-OUMP is about twice as fast as PRINT, but 
the •moum of external storage used is two or three times as much. 

11.5.2. Input: GC-READ 

<GC-RCAD re>adb:eh#nnel eof:any> 

returns «i IC object from the channel, which must be open in -READS- mode. The file must have been 
produced by GC-DUMP. eof is optional. GC-READ is about ten times faster than READ. 



11.4.2.3 - 11.5.2 Input/Output 



108 The MDL Programming Language 

11.6. SAVE Files 

The entire Male of MDI. can he saved away in a Tile for later restoration: this is done wiih the SUBRs 
SAVE ami RESTORE. This is a very tlifferent form of I/O from any mentioned up to now; the file 
used contains an actual image of your MDL address space and is not. in general, "legible" to other 
MDL routine*. RESTORrhig a SAVE file is much faster than rc-READing the objects it contains. 

Since a SAVE file docs not contain all extant MDL objects, only the impure and PURIFYed (section 
22.0.2) ones, a Change to Hie interpreter has the result of making all previous SAVE files unusable. 
To prevent error* Troni arising from this, the interpreter has a release number, which is incremented 
whenever change* are installed. The current release number is printed out on initially starting up 
the program and is available as the GVAL of the ATOM HUDDLE. This release number is written out 
as the very first pan of each SAVE file. If RESTORE attempts to re-load a SAVE file whose release 
number is not rhc same as the interpreter being used, an error is produced. If desired, the release 
number of a SAVE file can be obtained by doing a READ of that file. Only that initial READ will 
work: the rest of the file is not ASCII. 

11.6. 1 SAVE 

<SAVE file- spectrins fic7;ra/se-or-any> 

or 

<SAVF. nsmeJ name? device dir gc?:fslse-or-*ny> 

saves the entire Mate of your MDL away in the file specified by its arguments, and then returns 
"SAVED". All STRING arguments are optional, with "MUDDLE - , "SAVE", "DSK" . and <VALUE SNM> 
used by default. f r* is optional and. ir supplied and of TYPE FALSE, causes no garbage collection to 
occur before SAVE'ing. (FSAVE is an alias for SAVE that may be seen in old programs.) 

If. after restoring. RESTORE finds that <VALUE SNM> is the null STRING {""). it will ask the operating 
system for the name or the "working directory" and call SNAME with the result. This mechanism is 
handy for "public" SAVE files, which should not point the user at a particular disk directory. 

In the ITS version, the file is actually written with the name _MUDS_ > and renamed to the 
argument's) only when complete, to prevent losing a previous SAVE file if a crash occurs. In the 
Tenex and Tops-20 versions, version/generation numbers provide the same safety. 

Example: 



1 1.6 - 11.6.1 Input/Output 



The MDL Programming Language 



109 



<DEFINE SAVE-IT ("OPTIONAL" 

(FILE '("PUBLIC" "SAVE" "DSK" "GUEST")) 
"AUX" (SNM "")) 
<SETUP> 

<COND (< = ? "SAVEO" <SAVE ! .FILE» : "See below." 
<CLEANUP> 
"Saved.") 
(T 
<CRLF> 

<PRINC "Amazing program at your service. "> 
<CRLF> 
<START-RUNNING>)» 



11.6.2. RESTORE 

<RESTORE /i/e-r.pec> 
or 

<RESTORE name/ n»me2 device dirt 

replaces (lie entire current Male of your MDL with that SAVEd in the file specified. All arguments 
are optional, with the same values used by default as by SAVE. 

RESTORE completely replace* Hie contents of the MDL. including the state of execution existing 
when the SAVE was done and the state of all open I/O CHANNELS. If a file which was open when the 
SAVE was done docs not exist when the RESTORE is done, a message 10 thai effect will appear on the 
terminal. 

A RESTORE never returns (unless it gets an error): it causes a SAVE done some time ago to return 
■gain (this time with the value "RESTORED"), even if the SAVE was done in the midst of running a 
program. In the latter case, the program will continue its execution upon RESTOREation. 



11.7. Oth er I /O Functions 

11.7.1. LOAD 

<LOAD input -.channel look-up) 
eventually returns "DONE". First, however, it REAOs and EVALs every MDL object in the file pointed 



11.6.1 - U.7J 



Input/Output 



no 



The MDL Programming Language 



10 by input, and Mien CLOSE* input. Any occurrences of rubout. "©, *0, "L. etc. in the file are 
given no special meaning: iliey are simply ATOM constituents. 

look-up is optional, used 10 specify a LIST of OBLISTs for the READ. .OBLIST is used by default 
(chapter 15). 

11.7.2. FLOAD 

<FLOAD Me -spec look-up) 

or 

<FLOAD naniel name2 device dtr look-up) 

('file load") acts juM like LOAD, except ihat it takes arguments (with values used by default) like 
OPEN. OPCNs (he CHANNEL itself for reading, and CLOSEs the CHANNEL when done, look-up is optional. 
as hi LOAD. If the OPEN fails, an error occurs, giving ihe reason for failure. 

11.7.3. SNAIIE 

<SNAMf etrin$"> ("system name", a handover from ITS) is identical in effect with <SETG SNM string), 
that is. it causes string 10 become the dtr argument used by default by all SUBRs which want file 
specifications (in the absence of a local value for SNM). SNAME returns its argument. 

<SNAHE> is Identical in effect with <GVAL SNM>, that is. it returns the current dir used by default. 

11.7.4. ACCESS 

< ACCESS channel /;*-> 

returns eh*nn*t, after making the next character or binary word (depending on the mode of channel. 
which should noi he "PRINT") which will be input from or output to channel the (fix*l)st one from 
the beginning of the file, channel must be open to a randomly accessible device ("DSK". "USR", 
etc.). A fi- of positions channel at ihe beginning of the file. 

11.7.5. FILE-LENGTH 

<FILE-LENGTH input .channel) 
returns a FIX. ihe length of the file open on input. This information is supplied by the operating 



11.7.1 - 11.7.5 



Input/Output 



The M1>1- IVograi 



mi; Language 



111 



system, and ii may not be available, for example, with ilie "NET" device (section 11.10). If input's 
mode is "READ", the length is in characters (rounded up to a multiple of five); if "READB", in 
binary word*. If ACCESS is applied to input and this length or more, then the next input operation 
will detect the end of file. 

11.7.6. FILECOPY 

<FILECOPY fnpotxtUUUmt output:ch*nnel> 

copies characters from input to output until the end of file on input (thus closing input) and returns 
the number of characters copied. Both arguments are optional, with . INCHAN and .OUTCHAN used by 
default, respectively. The operation is essentially a READSIRING - PRINTSTRING loop. Neither 
CHANNEL need he freshly OPENcd. and output need not be immediately CLOSEd. Restriction: internally 
a <FILE-LINGTH input* is done, which must succeed: thus FILECOPY might lose if input is a "NET- 
CHANNEL. 

11.7.7. RESEI 

<RESET chAnnet> 

returns chniMcL after "resetting" It. Resetting a CHANNEL is like OPENing it afresh, with only the file- 
name slots preserved. For an input CHANNEL, this means emptying all input buffers and. if it is a 
CHANNEL to a file, doing an ACCESS to on it. For an output CHANNEL, this means returning to the 
beginning of the file -- which implies, if the mode is not "PRINTO", destroying any output done to 
it so far. If the opening fails (for example, if the mode slot of channel says input, and if the file 
specified in its real-name slots does not exist). RESET (like OPEN) returns eTALSE (reasontstring file- 
Spcc:stnns. sfatus:lix ) . 

H.7.8. BUFOUT 

CBUTOUT output;channe/> 

causes all internal MUL buffers for output to be written out and returns its argument. This is 
helpful if the operating system or MDL is flaky and you want to attempt to minimize your losses. 
The output may be padded with up to four extra spaces, if output's mode is "PRINT". 

11.7.9. RENAME 

RENAME is for renaming and deleting files. It takes three kinds of arguments: 

(a) two file names, in either single- or multi-STRING format, separated by the ATOM TO, 

(b) one file name in either format, or 



11.7,5 - 11.7,9 



Input/Output 



112 The ,\»t>L Programming Language 

(c) :« CHANNEL and a Me name in either format (only in the ITS version). 

Omiitrd .';lr-n.iinr pari- use me same values by default as does OPEN. If the operation is successful. 
RENAHt rtiuriu I. otherwise "FALSE ('Onson^trins status-Jix). 

In case (ai » lie file specified by the first argument is renamed to the second argument. For example: 

<RFNAME "FCO 3" TO "BAR"> : -Rename F00 3 to BAR >." 

In case (bl ilie single file name specifics a file to be deleted. For example: 

< RENAME "FOO FOO OSK;HARRY;"> ;"Delete file FOO FOO from 

HARRY'S directory." 

In ease (c) rhc CHANNEL must be open in either "PRINT" or "PRINTS" mode, and a ren-me while open 
for Writing is attempted. The real-name slots in the CHANNEL are updated to reflect any successful 
change. 



U.S. Tcriuiii.il CHANNELS 

MDL behave* Hie the ITS version nf the text editor Teco with respect to typing In carriage-return, 
in ibal ii .ititniu.'tt ic.illy adds a line-feed. In order to type in a lone carriage-return, a carriage-return 
follow, .. by a rnbnni must be typed. Also PRINT. PRIN1 and PRINC do not automatically add a line- 
feed when a carriage-return is output. This enables overstriking on a terminal that lacks 
backspacing capability, Ii also means that what goes on a terminal and what goes in a file are 
more likely In look ibe same. 

In the ITS version. MIH.'s primary terminal output channel (usually .OUTCHAN) is normally not in 
"display" nio.ie. except when PRINCiug a STRING. Thus errors will rarely occur when a user is 
lyp*'**; '" '*•*! containing display-mode control codes. 

In the ITS version. MDI. can Marl up without a terminal, give control of the terminal away to an 
inferior npetatiug-sysie m pioeess or get it back while running. Doing a RESET on either of the 
terminal rimiineb ntuscs MDL to find out if it now has the terminal; if it does, the terminal is 
rcopeiud and the current screen size and device parameters are updated. If it doesn't have the 
teriiiin.il. an internal flag is set. causing ouiput to the terminal to be ignored and attempted input 
J roin i he lern.inal in make the opera. ing-system process go to sleep. 

In the . .'S vr. mi. the. arv some p., .iliarities associated with pseudo-terminals ("STY" and "STn" 
devices). If the aiANNC L given to Rf/DCIIR is open in "READ" mode to a pseudo-terminal, and if no 
input is nv...;abh-. R! AUCHK ..turns -., TYPl FIX. If the CHANNEL given to REAOSTRIKG is open in 
"READ" nmiic to a psvndo-iii niinal. re.'.ding *no stops if and when no more characters are available, 
that is. when RCADtHR won In return -1. 



.1.7.9 - 11.8 Input/Output 



The MDL Programming Language 



113 



11.8.1. ECIIOPAIR 

<ECHOPAIR tcrminal-mxhannel tcrmin*l-outxhanneI> 

returns us firM argument, aftr/ making ihc iwo CHANNEL* "know about each other" so that ruboul. 
*3. T) nml "I »l| U" nun*t-tn will cauw il.p appropriate output on terminal-out, 

11.8.2. TTYrCIIO 

<TTYECHO leruttruit -input xiumnol pred> 

turns the echoing of typed characters on channel off or on. according to whether or not pred is of 
TYPE t- AI.SC. anil return* channel. It is useful in conjunction with TYI (below) for a program that 
wants In tin vh.irnctt'i input and echoing in its own fashion. 

11.8.3. IY1 

< TYI terminal- input :ch*nnet> 

returns one CHAKACII R from channel (optional. . INC HAN by default) when it Is typed, rather than 
after i (ESC. is typed, as is the case with READCHR. The following example echos input characters 
as their ASCII values, until a carriage-return is typed: 

•REPEAT <(F0O CTTYECHO . INCHAN <»)) 

<AHD < = =? 13 <PRINC s'ASCII <TYI .INCHAN>»> 
<RCTURN <TTYECHO -INCHAN T»» 



11.9. Iiitrrn.il CHANM.Ls 

If the dextec sprv.ficd in an OPEN is "INT", a CHANNEL is created which does not refer to any I/O 
device outside MDL. In this case, the ninde must be "READ" or "PRINT", and there is another 
argument, which must |,r> a function. 

For a "REAP" CHANNEL, Hie function must take no arguments. Whenever a CHARACTER is desired 
from this CHANNEL, the function will he applied to no arguments and must return a CHARACTER. 
This will occur once per call to READCHR using this CHANNEL, and several limes per call to READ. In 
the ITS version. i lie function can signal that its "end-of-file" has been reached by returning <CHTYPE 
•777777000003- CHARAC1FR> (-1 in left half. couirol-C in right), which is the standard ITS end-of- 
filc signal. In the Tencx and Tops-20 versions, the function should return either that or <CHTYPE 
"777777000032- CHARACTrR> (-1 and romrol-ZL the latter being their standard cnd-of-fi!e signal. 



II.8.1 - 11.9 



Input/Output 



11*1 The MDL Programming Language 

For a "PR I •' i " ( iiai.'NI t . ilip runclioii until lake one argument, which will be a CHARACTER. It can 
dispose of its art; u incut in any way it pleases. The value returned by the function is ignored. 

Example: <OPTM "PRINT- "INT:" .FCN> opens an internal output CHANNEL with .FCN as it* 
etiaracler-ynlihler. 



11.10. T he m tii I- Device: the ARPA Net work 

The "NET" ilrvicr [a different in many ways from conventional devices. In the ITS version, it is 
the only device besides "INI" thai doc* noi take all strings as its arguments to OPEN, and it must 
take an audit ional optional argument 10 specify the byte size of the socket. The format of a call to 
open a network iwktfi is 

«:OP('N tnot/e:xtring loc*l-soeket:fix /arcisn-saekct&x "NET" foreign-host :fix byte-sizodix> 

where: 

mode is the mode of the desired CHANNEL. This must be either -READ". "PRINT", "READB" or 
"PRINTB". 

Iocs' -cachet is the Incal socket number. If it is -1, the operating system will generate a unique 
local socket number. If it is not. in the Teuex and Tops-20 versions, the socket number is 
"fork-relative". 

foreign •■ochet is the foreign socket number. If it is -1, this is an OPEN for "listening". 

foreign -hor-l i*. the foreign Iiom number, If it is an OPEN for listening, this argument is ignored. 

fci/»'--«,v? i* the optional byte size. For "READ" or "PRINT" this must be either 7 (used by 
default) or R. For "RtADB" or "PRINTB", it can be any integer from 1 to 36 (used by default). 

In the Tciirx and Tnp\-20 versions. OPEN can instead be given a STRING argument of the form 
"NET: . . .". In tlii*. taw the local socket number can be "directory-relative". 

Like any olhci OPEN, cither a CHAf.NEL nr a FALSE is relumed. Once open, a network CHANNEL can 
be used like any nlher CHANNEL, except that FILE-LENGTH, ACCESS. RENAME, etc.. cannot be done. 
The "argument firM-nainr. second-name, and directory-name slots in the CHANNEL are used for local 
socket, foreign sot- 1 ei. and foreign host (as specified in the call to OPEN), respectively. The 
corresponding "real" '■Inf. are used somewhat differently. If a channel Is OPENed with local socket 
-1. the "real" first-name slot will contain the unique socket number generated by the operating 
system. If a listening socket is OPENrd, the foreign socket and host numbers of the answering host 
are More*! in I lit "real" seomd-nauie and directory-name slots of the CHANNEL when the Request For 
Connection is received. 

11.9 - 1 1.10 Input/Output 



The MDI Programming Language 



115 



An imerriipl (chapter 21) can be associated with a "NET--device CHANNEL, so that a program will 
know Ibai ilic CIIANnTL lias or needs data, according to its mode. 

There also exist several special-purpose SUBRs for the -NET* device. These are described next. 

II. 10-1- NClSTAII 

<NETSTATE netwarAxti*nn*t> 

return-, n IIVt.ClOK of Hirer FlXrv The first is the state of the connection, the second is a code 
specifying why ji connection was closed, and Hie last is the number of bits available on the 
connection for input. The meaning of the state and close codes are installation-dependent and so 
are ur>l iiirliulnl here. 

II. 10.2. KETACC 

' Mb I ACC nrtv.-0'h;thfinncl> 

accepts a mniireiinii to a socket that is open for listening and returns its argument. It will return a 
FALSE if Ihc couiicclinn (s hi the wrong state. 

11.10.3. NETS 

<tll- IS nrl .vOtl.:itmnnrl> 

returns it-, argument, after forcing any system-buffered network output to be sent. ITS normally 
does this every half Mvnnd anyway. Tenex and Tops-20 do not do it unless and until NETS is called. 
NETS is similar to BUKOUT for normal CHANNELS, except that even operating-syitem buffers are 
emptied now 



1M0 - 11.10.3 



Input/Output 



116 






The MDL Programming Language 



Chapter 12. Locatives 



There is i 
correspond 



MIX 



a facility for 

pointer*" In ouctn 



obtaining and working directly wiih objects which roughly 
My language or "Ivals - in BCPL or PAL. In MDL. these are 
gener.c-.lly h.mv„ as loca. ivrs (fro,,, "location") and are of several TYPE*, as mentioned below. 
re-eooyi *" ,, ' ov,<l * **«"«« ■"««* f°r altering structures: direct replacement as opposed to 



Locatives ^ny, refer .o element* in structures. It is not possible to obtain a locaiivc to something 
(for exa.np.e. a„ A fOfll which Is „n, par, of any structure. It is possible to obtain a locative to any 
element hi any structured object in MDL - ever 
ATOMs. structurings which arc normally "hidden". 



to associations (chapter 13) and to the values of 



In the following, the object occupying the structured position to which you have obtained 
w.n be referred to as the object pointed to by the locative. 



locative 



12.1. Obi 



an 



ing Locatives 



12.1.1. LIOC 



<1 LOC s!o„, «•«-> 



is not 



returns a ....alive (TYPE LOCD. "locative to iDentifier") to the LVAL of a,o« in env. If ,/o, 

an cr.m occurs. C nv i* optional. With the current ENVIRONMENT used by default The 
vv 7,, L'.!:. OC !\ ""' rpC ". llci " 2l fl ""fc fcbindines of atom. That is. IN (sec below) of 



locative inn 
that Inrat 



ZtLT: v'',r V 'T'", ""* "" ,e ! " i,,S mU if *'° m is abound to something else: SETLOC (sec 

below) w.l, affeei only that particular binding of atom. 



becomr'nn, T Tl.T 7 " *** "" ** a " y a,rCmpI IO USC a ,OC *' iv * «• ™ LVAL which has 

be used ,o hvH a LOCD .s vahd. Caution: <S£T A <LLOC A» creates a self-referen. 
PRINT very unhappy. 



ice and can make 



12 - 12.1.1 



Locativ 



es 





The MUL Programming Language 



117 



12.1.2- GLOC 

<CLOC Atom pred"> 

returns .1 wcatlve (TYPE LOCO) to the GVAL of atom. If atom has no GVAL slot, an error occurs, unless 
pred (option*!) is given and not FALSE, in which case a slot Is created (chapter 22). Caution: <SETG 
A <GLOC A>> creates a self-reference and can make PRINT very unhappy. 



12.1.3. AI 



<AI "•Irnctiirrd N;li*-ar-Qtfr.ct> 



returns a locative |o ilic .V1I1 clciueut in structured. N is optional. 1 by default. The exact TYPE of 
the locative returned depends on the PRIHTYPE of structured: LOCL for LIST. LOCV for VECTOR. LOCU 
for UVI.CIOK. IOCS for SIRING, LOCB for BYTES. LOCT for TEHPLATE. and LOCA for TUPLE. If N is 
greater It mil <LEHC.1H s!ruclured> or less ihan 1, or an OFFSET with a Pattern that doesn't match 
structured, an crmr occurs. The locative is unaffected by applications of REST. BACK. TOP. GROW, 
etc. to '-t/uctur-J. 

12.1.4. GCTPi and GETL 

<GE1PI. item:any indiratOr:any del 'ault :any> 

returns a locative iTYPE LOCAS) to the association of item under indicator. (See chapter 13 for 
Information atmui assn. iaiiout.) If no such association exists. GETPL returns EVAL of default, default 
is optional. *f AlSfc" ( ) hy clrfauli. 

GETPL corresponds tn GCTPROP amongst the association machinery. There also exists GETL. which 
corresponds in GET. returning either a LOCAS or a locative to the indicatorth clement of a structured 
item. GETL i> like Al if item is a structure and indicator is a FIX or OFFSET, and like GETPL if not. 



12.2. LO CA I IVt? 

This SURR is n predicate that tells whether or not its argument is a locative. It is cheaper than 
<HEMQ <PKIHIYPr *'•> ■ ! [ LOCD LOCI ...]>. 



12.1.2 - 12.2 



Locatives 



118 



12.3. Usi n g L ocal i ves 



The MDL Programming Language 






The following i wo SUBRs provide (he means for working with locaiives. They are independent of 
the specific TYPE of the locative. The notation locative indicates anything which could be returned 
by LLOC. GLOC. AT. GETPL or GETL. 

12.3.1. IN 

<IH loeative> 

returns the object to which locative points. The only way you can get an error using IN is when 
locative pniiils lu ail LVAL which has become unbound from an ATOH . This is the same as the 
problem in referencing TUPLES as mentioned in section 9.2. and it can be avoided by fir*t testing 
<LEGAL? locd>. 



Example: 



<SCT A 1>* 

J 

<IN <LLOC A>>S 

1 



12.3.2. SETLOC 

<SETLOC locative *ny> 

returns any. after having made any the contents of that position in a structure pointed to by 
locative. The structure itself is not otherwise disturbed. An error occurs if locative is to a non- 
LEGAL? LVAL or if you try |o pin an object of the wrong TYPE into a PRIMTYPE UVECTOR, STRING, 
BYTES, or TEMPLATE. 



Example: 



<5ET A (I 
(1 2 3) 

<SCTLOC <AT 
HI 

.Ai 

(1 HI 3) 



Z 3)>S 



.A 2> HI>S 



12.3 - 12.3.2 



Locative* 



The MDL Programming Language 



119 



12.4. Note nn Local ives 

Von may have noticed lhai locatives are. strictly spcaLing. unnecessary: you can do everything 
locative* allow by appropriate use of. for example. SET, LVAL. PUT, NTH. etc. What locatives 
provide is generality. 



Basically, how you obtained a locative is irrelevant to SETLOC and IN; thus the same program can 
play with C.VALv LVALs. objects in explicit structures, etc.. without being bothered by what function 
should use to do so. This is particularly true with respect to locatives to LVALs: the fact that they 
of changes in binding can save a lot of fooling around with EVAL and 



are independent 
ENVIRONMENTS. 



12-4 



Locatives 



120 



The MDL Programming Language 



Chapter 13. Association (Properties) 

There is an "associative* 1 data storage and retrieval system embedded in MDL which .Hows the 
construe. , on of data structures with arbitrary selectors. It is used via the SUBRs described in (his 
chapter. 



13.1. As s ocia tive Storace 

IS.I.I. PU1PK0P 

< PUTPROP item:any indicator ;pny v*lue:any> 
("put property-) returns item, having associated value with item under the indicator indicator. 



13.1.2. PUT 



<PUT item;*ny trtdie*tor:#ny value:any> 



is identical to Pill PROP, except that, if item is structured and indicator is of TYPE FIX or OFFSET, it 
does <SETLOC <AT item indic*1or> v«bc>. In other words, an element with an integral selector is 
stored In .he Structure itself, instead of in association space. PUT (like AT) will get an error if 
indicator is nui of range: PUTPROP will not. 



13.1.3. Kcmoviug Associations 



If PUTPROP K used without. i,s «*» argument, it removes any association existing between its item 
argument and ft* indicator argument. If an association did exist, using PUTPROP in this way returns 
the value which was associated. If no association existed, it returns #FALSE ( ) . 



PUT. with arguments which refer to association, can be used in the 



same w 



my. 



13 - 13.1.3 



Association (Properties) 



The MDI Programming language 



121 



If cillicr it*m or indicator cease to exist (that is. no one was pointing to them, so they were garbage- 
collecu-iO. and no locatives to (he association exist, then the association between them ceases to exist 
<is gnrbage-cnllecU'il). 



13.2. As soc in i i vc , U c ! r lev a I 

13.2-1- GETPROP 

<GCTPROP iten>:any indicator ;*ny exp:any> 

<"get property"! returns the value associated with item under indicator, if any. If there is no such 
association. GETPROP returns EVAL of e*p (that is. exp gets EVALed both at call lime and later). 

evp Is optional. If not given. GETPROP returns #TALSE ( ) if it cannot return a value. 

Note: item and indicator in GETPROP inust be the same MDL objects used lo establish the association; 
that is. they iniisi be ==? to the objects used by PUTPROP or PUT. 

IS.2.2. GET 

<Gfc I itcm&ny indie afor:any exp:any> 

is the inverse of PUT, using NTH or GETPROP depending on the test outlined in section 13.1.2. exp Is 
optional and used as in GETPROP. 



13.3. Exam | t ips of Association 

<SET L '(123 4)>S 

(17 3 1) 

<PU1 .L fOO "L Is a list.">S 

(12 3 4) 

<GET .L FOO>S 

■I. is n list." 

<PUIPHOP .L 3 *![41>S 

(12 3 4) 

<GCTPROP .L 3>I 

IC413 

<GET .L 3>S 
3 



13.1,3 - 13.3 



Association (Properties) 



122 The MDL Programming Language 

<SET N 0>S 



<PUT .a .L -list on o zero">S 



<CET .N '<1 2 3 4)>» 

rTALSE () 

The Ihm example failed because READ generated a new LIST — not the one which is L'a LVAL . 
However. 

<GET -L>S 
"list on a zero" 

works because <==? .N 0> is true. 

To associate something with the Nih p ositio n in a structure, as opposed to its Nth element, associate 
it with <REST structure /V-i>, as in the following: 

<PU1 <RIS1 .L 2> PERCENT 0.3>» 

(3 1) 

<CCT <2 -L> PERCEMT>S 

■T Al SE ( ) 

<GET <RtSI .L 2> PERCENT)! 

0.30000000 

Remember rnmmrnis? 

<SET H MIABC ;"third clement" E]>S 

![ABC0 EI 3 

<GF1 <RtST .M 2> COMHENT>* 

"third elcmont" 

The ' in the <SET N ... > is to keep EVAL from generating a new UVECTOR ("Direct 
Representation"), which would not have the comment on it (and which would be a needless 
duplicate). A "top-level" comment -- one altached to the entire object returned by READ — is PUT on 
the CHANNEL in use. since there is no position in any structure for it. If no top-level comment 
follows ilic object. RTA0 remove* the value (<PUT channel C0MMENT>); so anybody that wants to see a 
top-level comment must look for it after each READ. 

If you need io have a structure With selectors in more than one dimension (for example, a sparse 
matrix thai iloM imi deserve to be linearized), associations can be cascaded to achieve the desired 
result. In effeel an extra level of association maps two indicators into one. For example, to 
associate iv.'ur with item under indicator- I and ind/c^!or-2 simultaneously: 

<PU1PK0P Indicator- 1 rndiCatOr-2 T> 

13.3 Association (Properties) 



The MDL Programming Language 



123 



<PLI1PR0P item <CtTPL indicAtar-1 indicator-?) v*tu€> 



13.4. Ex amining Asso ciations 

Associations (created by PUT and PUTPROP) arc chained together in a doubly-linked list, internal to 
MDI- The order of association* in the chain is their order of creation, newest first. There are 
several SIIRtU for examining the chain of associations. ASSOCIATIONS returns the first association 
in the chain, or »FALSE () if there are none. NEXT takes an association as an argument and returns 
the next association in the chain, or rFALSE () if there are no more. ITEM, INDICATOR and AVALUE 
all lakr an association as an argument and return the item, indicator and value, respectively. 
Associations print as; 

r*ASOC {item indicator f*/ue) 

(sic: only one S). Example: the following gathers all the existing associations into a LIST. 

<PROG ((A <ASSOCIATIONS>)) 
<COND (<NOT .A> *()) 

(1 ( -A KHAPF .LTST 

<FUNCTION () <COND (<SET A <NEXT .A» .A) 
(T <MAPSTOP>)>»))» 



13.3 - 13.4 



Association (Properties) 



IM The MDL Programming Language 



Chapter 14. Data-type Declarations 

In Mm . ii is possible 10 declare (lie permissible range of "types" and/or structures that an ATOH's 
value* or a function's arguments or value may have. This is done using a special TYPE, the DECL 
("declaration"). A DECL ii of PRIMTYPE LIST but has a complicated internal structure. OECLs are 
used hy fhe Interpreter to find TYPE errors in function calling and by the compiler to generate more 
efficient code. 

There arc iwo kinds of DECL*. The first kind of OECL is the most common. It is called the ATOM 
DECL and is used most commonly to specify the type/structure of the LVALs of the ATOMs in the 
argument I 1ST of a FUNCTION or *u* LIST of a PROG or REPEAT. This DECL has the form: 

"DECL {ttomfJlGl Pattern ...) 

Where the pairing of a LIST nf AlOHs and a "Pattern" can be repeated indefinitely. This declares the 
ATOMs in a b$l lo l»c nf the type/structure specified in Hie following Pattern. The special ATOM 
VALUE, if it appears, declare* the result of a FUNCTION call or PROG or REPEAT evaluation to satisfy 
the Pattern specified. An AlOM DECL Is useful in only one place: immediately following the 
argument LIST of a FUNCTION. PKOG or REPEAT. It normally includes ATOMs in the argument LIST 
and ATOMs whose LVALs are otherwise used in the Function body. 

The second kind or DFCI is rarely seen by the casual MDL user, except in appendix 2. It is called 
the RSUBR DECL . It is used to specify the type/slructurc of the arguments and result of an RSU8R or 
RSUBR-ENTRY (chapter 19). Il is of the following form: 

-THCL ("VALUE" Pattern Pattern ...) 

where I ho STRING "VALUE" precedes the specification of the type/structure of the value of (he call to 
the RSUHR. and the remaining Patterns specify the arguments lo the RSUBR in order. The full 
specification of ihe KSUBR DECL will he given in section 14.9. The RSUBR DECL is useful in only 
one place: as an element of an RSUBR or RSUBR-ENTRY. 



14 Dala-type Declarations 






The MDL Programming language 125 

M.I- Patterns 

The simplest possible Pattern is lo say that a value is exactly some other object, by giving that 
object. OUOTTd. For example, to declare that a variable is a particular ATOM: 

"DECL ((X) -T) 

declares HtNl -X is always the ATOM T. When variables are DECLcd as "being" some other object In 
this way. ihe lest used is =?, and not = *?. The distinction is usually not important, since ATOMs. 
which are most commonly used in this construction, are " = ? to each other if =? anyway. 

It is more common to want to specify that a value must be of a given TYPE. This is done with the 
simplest non-specific Pattern, a TYPE name. For example. 

"DECL ((X) TIX (Y) FLOAT) 

declares -X to be of TYPE FIX. and .Y of TYPE FLOAT. In addition to the names of all of the built- 
in and created TYPEs. such as FIX. FLOAT and LIST, a few -compound" type names are allowed: 

ANY allows any TYPF. 

STRUCTURED allows any structured TYPE, such as LIST. VECTOR. FALSE. CHANNEL, ett 
(appendix 3). 

LOCATIVE allows any locative TYPE, such as are returned by LLOC. GLOC. AT. and so on 
(chapter 12). 

APPLICAIil b allows any applicable TYPE, such as FUNCTION. SUBR. FIX (!). etc. (appendix 3). 

Any other ATOM can be used to stand for a more complex construct, if an association is 
established on that ATOM and the ATOM OECL. A common example is to <PUT NUMBER DECL 
•<0R FIX FI.0A1 >>(*ee below), so that NUMBER can be used as a "compound type name". 

The single TYPE name can be generalized slightly, allowing anything of a given PRIMTYPE. using 
the following consiinct ion: 

<*DECL ((X) <PRIMTYPE WORD> (Y) <PRiMTYPE LIST>) 

This construction consists of a iwo-elemcnt FORM, where the first element is the ATOM PRIMTYPE. 
and the second the name of a primitive type. 

The next step is to specify the elements of a structure. This is done in the simplest way as follows: 
< structured:! ypc Pattern Pattern ...> 

H.I Data-type Declarations 



'26 The MDL Programming Language 

where Ilicrc is a ouc-io-onc correspondence between the Pattern* and the elements of the structure. 
For example: 

■■DECL ((X) <VECTOR FIX FLOAT>) 

declares . X to be a VECTOR having at^ least two elements, the first of which is a FIX and the second a 
FLOAT. It is often convenient to allow additional elements, so that only the elements being used in 
the local neighborhood of the DECL need to be declared. To disallow additional elements, ■ SEGMENT 
is used Instead of ., roRM <the "c.xcl-cd" brackets make it look more emphatic). For example: 

'DECL ((X) KVECTOR FIX FLOAT>) 

declares .X to be a VECTOR having exactly two elements, the first of which is a FIX and the second a 
FLOAT . Note i linT the Pattrrn"- given for elements can be any legal Pattern: 

fDECL ((X) <VECTOR <VECTOR FIX FLOAT>> (Y) «PRIMTYPE LIST> LIST>) 

declares .X in he a VECTOR containing another VECTOR of at least two elements, and .Y to be of 
PRIMTYPE LIST, containing a LIST. In the case of a BYTES, the individual elements cannot be 
declared (they must be FIXes anyway), only the size and number of the bytes: 

#DfcCL <<B) <BYTES 7 3>) 

declares . B to be a BYTES with BYTE-SIZE 7 and at least three elements. 

It is possible to say that some number of elements of a structure satisfy a given Pattern (or 
sequence of Patterns). This is called an "NTH construction'. 

f number:(ix Pattern Pattern . . . T, 

states that the sequence of Patterns which is REST of the VECTOR is repeated the number of limes 
given. For example: 

fDECL (<X) <VEC10R [3 FIX] FLOAT> (Y) <LIST [3 FIX FL0AT1>) 

-X is declared to contain three TIXcs and a FLOAT, perhaps followed by other elements. .Y is 
declared to repeat the sequence FIX-FLOAT three times. Note that there may be more repetitions of 
the sequence in .¥ (bin not in .X): the DECL specifies only the first six elements. 

For indefinite repetition, the same construction is used. but. instead of the number of repetitions of 
the sequence or Patterns, the ATOM REST is given. This allows any number of repetitions, from zero 

on up. For example: 

-DECL ((X) <VECTOR [REST FIX]> (Y) <LIST [3 FIX] [REST FIX]> 

M.I Data-type Declarations 






The MDL Programming Language 



127 



A "RES1 * -niiMriirtloii'* can contain any niiinbcr of Patterns, jus! like an NTH construction: 

fDCCL ((X> <VCCTOR [REST FIX FLOAT LISTp) 

declare iliai -X is a VtCiOR wherein Hie sequence f IX-FLOAT-LIST repeats indefinitely. It docs not 
declare Ilia! <lEIir,lll .X> is an even multiple of three: the VECTOR can end at any point. 

A variation on REST i* OPT (or OPTIONAL), which is similar to REST except that the construction is 
scanned once at most instead of Indefinitely, and further undeclared elements can follow. For 

example: 

-(tin ((x) <vrcioR [opt rix]>) 

declares lh.il -X is n VECTOR which is empty or whose first element is a FIX. Only a REST 
construct Inn can follow an "OPT construction . 

Note that the III M cniiMriiciinn must always be the last element of the structure declaration, since it 
gives a I'atU-t u for the rest of Hie structure- Thus, the REST construction is different from all others 
in that it has ,111 unlimited range. No mailer how many times the Pattern it gives is RESTcd off of 
the slrintiiie. thp remainder of the structure still has that Pattern. 

This exhausts the pnsMUIe single Patterns that can be given in a declaration. However, there is also 
a com pound Pattern defined. It allows specification of several possible Patterns for one value: 

<OR Pattern Pattern ... > 

Any non-compoiiiul Pattern can be included as one of the elements of the compound Pattern. 
Finally, compound Patterns can be usrri as Patterns for elements of structures, and so on. 

"DECL ((X) <0R FIX FLOAT> 

(Y) <0R TIX <UVECTOR [REST <0R FIX FLOAT>J>>) 

The OR ConMruclinn can be extended to any level of ridiculousness, but the higher the level of 
complexity and compounded nc»* the less likely the compiler will find the OECL useful. 

At Hie highest level, any Pattern at top level in an ATOM DECL can be enclosed in the construction 
< ••ppcit>lt\ ;aIoiii Pattern > 

which explicitly ilt-clares the specialty of the ATOM(s) in the preceding LIST, specially can be either 
SPECIAL or IIHSPECIAL. Specially is important only when the program is to be compiled. The word 
cornea from the coil t ml stack, which is called "special" in Lisp (Moon. 1971) because the garbage 
collector Tinds objects on it and modifies their internal pointers when storage is compacted. (An 
Internal stack is used within ihe inirrpreter and is not accessible to programs - section 22.1.) In 



14.1 



Data-type Declarations 



128 



The MDL Programming Language 



an interpreted program all local values arc initially SPECIAL, because all bindings are put on the 
control Mad (hill sec SPCCIAI -MODE below). When the program is compiled, only values declared 
SPECIAI (which may or may not he the declaration used by default) remain in bindings on the 
control Miick, AN others are taken care of simply hy storing objects on the control stack: the ATOM* 
Involved arc not needed and are not created on loading. So. a program that SET* an ATOM's local 
value for another program In pick up must declare that ATOM to be SPECIAL. If it doesn't, the ATOM's 
binding will go away during compiling, and the program that needs to refer to the ATOM will either 
get a no-value error or refer 10 nn erroneous binding. Usually only ATOMs which have the opposiic 
specialty from that of the current SPECIAL-MODE are explicitly declared. The usual SPECIAL-MODE is 
UNSPECIAt.. so typically only SPECIAL declarations use this construction: 

pPECL ((ACT) <SPECIAL ACTIVATIOH>) 

explicitly declare* AC] to he SPECIAL. 

Mow well-written, modular programs gel all their information from their arguments and from 
GVAL*. ..ml thus they rarely use SPECIAL ATOMs. except perhaps for ACTIVATIONS and the ATOMs 
whose IVAIs MTU uses by default: INCH AN, OUTCIIAN. OBLIST. DEV. SNM. NM1. NM2 . OUTCIIAN is 
a special case: the compiler thinks thai all conversion-output SUBRs arc called will, an explicit 
CHANNEL argument, whether or not the program being compiled thinks so- For example. <CRLF> is 
compilr.i *s | hough |, wcrc < C rlf .0UTCI1AH>. So you may use (or see) the binding (OUTCHAN 
.OUTCIIAN) in Bit argument I 1ST. however odd that may appear, because that - coupled with the 
usual (INSPECIAL declaration by default - makes only one reference to the current binding of 
OUTCHAN ami Muffs the result in a slot on the stack for use within the Function. 



14.2. li.yai i iph-s 

"HI CI ((0) <0R Vr.CTOH CHANHEL>) 

declares .0 to be cither a VECTOR or a CHANNEL. 

i 

'DfcCL ((P H S) <PR1I1TYPE LIST>) 
declares .P. .0. -R. and -S all to be of PRIMTYPE LIST. 

rWECl (U) <F0ltM [3 ANYJ>) 
declares .T to he a rORM whose length is at least three, containing objects of any old TYPE. 

-'DECL ((LL) «PRIHTYPE LIST> [4 <LIST fREST FIX]>3>) 

declares LI to be of PRIMTYPE LIST, and to have at least four elements, each of which are LISTs of 
unspecified length (possibly empty) containing Fixes. 



14.1 - 14.2 



Data-type Declarations 






The Mill I»r«uj ramming I attguage 



129 



-niri ((W) <vrcton nx atom characters 

declare*- .W 10 lit- a vrCTOR with at least lnrv« elements. Those elements are. in order, of TYPE FIX. 
ATOM, ami riiARAi'll R. 

"PI 1 I ((I") <L1SI AIOM [REST FL0A1]>) 

declares .ill !>■» he a I 1S1 wh"«c fir*i clement is nil ATOM and the rest of whose elements are FLOATs. 
It al*« *»)"* thai .1 II i* ai lp.ni nne element lontj. 

"WCL ((TOO) <IISI [RCST M TIX]>) 

declare* .1 OO to !»*• a I I S I u Imsc nihl-pnsiiinnril elements are the AIOM T and whose even-positioned 
element* are 1 IXe*. 

CrtAPR •• > 

<l (INCIIOH (X) 

♦DT.CL ((X) <VECT0R tl FIX]>) 
<PIH -X I 0>> 

.1 oo> 

declare*- .X in he a VLT10R inntaliiliig at le.isi one TIX. The more restrictive [REST FIX] would take 
excemve «ht-tlnn; limp hy ihr intci prefer, because the RFST of the VECTOR would be checked on 
each item linn «f l|»r 11 APR . In this rase h"ih HFCI * are equally powerful, because checking flic firs! 
element «•! all I hi* Rl St* "f a tiriirtiire eventually checks all the eleinents. Also, since the FUNCTION 
refer* only in the I hr*l i-h'iin-iil of X. Mils is as much declaration as the compiler can effectively use. 
<lf this VI CIOR .ilwav- I'Mii.iins only rjxes. it should he a UVFCTOR instead, for space efficiency. 
Then .1 IRIS I I 1X1 in . | would make the interpreter check only the UTYPE. If the FIXcs cover a 
.small nnii-ncgailvc railj-e. then a UYILS hiiglil he even better, with a DECL of <BYTES n 0>. ) 

sOI I INI TACI (N) 

■ oiri ((N) clIHSPf.CJAl FTX» 

CCONII (<0» .H> 1) (USE <" .H <FACT <- .N !>>>)>> 

declares f n 10 he of TYPr f TX and UHSPCCIAI.. This specially declaration ensures that, independent 
of SPEC 1 Al -HOI il iltttlng romp ili 111-. .H pets compiled into a fast control-stack reference. 

< PROG ( ( I ( ) ) 

• nrci (<i vAiur > ciiHSPECiAt <list [rest fix]>> 

(N) CIINSPI CIAL HX>) 

<co»n (<o? .n> <return .l>)> 

<SCT L (<♦ .N <1 .L>> • .L)> 
<Sl I N <- .N !>>> 



14.2 



Data-type Declarations 



130 



The MDL Programming Language 



^^rX^L^r'^^^^^^J^^' - "- - 



14.3. Tl.c nr.CI Syinax 






MDL 



dec! 

declprs 

atllst 

pattern 

pat 

unit 



struc 
bstruc 



opt 



'Iirci {doclprs) 

(iiLlisl) pattern | doclprs doclprs 
Mom | atom atllst 

PBt I <UHSPECIAL pat> | <SPECIAL pat> 
unit | <OR unit ... unit> 

tyro I <rfiIHTYPE rype> | *tom \ •any 

\ ANY | STRUCTURED | LOCATIVE | APPLICABLE 
<struc olts> | «OR struc ... struO olts> 
K*lruc clts> | <«0R struc ... struc> clts> 

I <bstruc ff*> I <bstruc //* /,» 

I KbstrtiC ftjr fix> 

structurc<t-typc | <PRIMTYPE structured- typc> 
BY1ES | <PRIHTYPC 0YTES> 

pal | pat eits 

I [tin pat ... pat] 

I [fin pat .. . pat] elts 

[opt pat ... pat } | [REST pat ... pat] 
I Lopt pat ... pa t3 [REST pat ... pat] 

OPT | OPTIONAL 



M.2 - H.S 



Data-type Declarations 






The M ni. Programming Language 



131 



1-4. 4. C.nml OCCLs 

There are some rule* nf thumb concerning "good" DECLs. A "good" DECL is one Hut is minimally 
offensive io the OECL-chccking mechanism and the compiler, but ihat gives the maximum amount 
of Informal ion. Ii is simple to stale what gives offense to the compiler and DECL-chcckiiig 
mechanism: complexity. For example, a large compound DECL like: 

*DCCL ((X) <0R FIX LIST "VECTOR FALSE>) 




Another situation to he avoided is tlir ordinary large DCCL, even if it is perfectly straightforward. 
If you have created a structure which has a very specific DECL and is used all over your code, it 
might he better as a NFWTYPE (sec below). The advantage of a NEWTYPE over a large explicit DECL is 
twofold. First, the entire structure must be checked only when it is created, that is. CHTYPEd from 
its PR1M1YPF. As a full DFCL. it is checked completely on entering each function and on each 
reassignment nf ATOIls DECled to be it. Second, the amount of storage saved in the DECL* of 
FUNCTIONS and sn on ts | ar ge. not to mention the effort of typing in and keeping up to date several 
instance* of H.r full DCCL. 



M.5. Gioh.ii nrcis 



14.5.1. GDECI. and MANIFEST 

There are two ways to declare GVALs for the DECL-checking mechanism. These are through the 
FSUOR GDECL ("global declaration") and the SUBR MANIFEST. 

<GDFCL rtomsJ/st Pattern > 

GDECL allows the type/structure of global values to be declared in much the same way as local 
values. Example: 

<GDECL (X) FIX (Y) <LIST FIX» 

declares . X to be a FIX. and ,Y to be a LIST containing at least one FIX. 

(MANIFEST Mom Mom ...> 

14.4 - 14.5.1 Data-type Declarations 



The MDL Programming Language 

MANIFEST rakes a* argument* ATOMs whose GVALs are declared to be constants. It is used mow 
commonly lo indicate thai ecrlain ATOM* are the names of offsets in structures. For example: 

<SE1G X 1> 
<HANIFEST X> 

allows the compiler to confidently opcn-compilc applications of X (getting the first element of a 
structure), knowing thai .X will not change. Any sort of object can be a MANIFEST value: if it does 
not get en.bvd.tcd in the compiled code, it is included in the RSUBR's "reference vector", for fast 
access. However, as a general rule, structured objects should not be made MANIFEST: the SETG will 
survive u. .he compiled version (for the use of new uncompilcd programs), but uses of GVAL will 
instead refer to a di-.in.cr eopy of the object in each RSUBR that does a GVAL. A structured object 
&hould Mislead be GOECLed. ^ 

An Attempt 10 SCTfi a MANIFEST AIOM will cause an error, unless either: 

(1) the AIOM was previously globally iinassigiied: 

(2) the old value is ==? to the new value: or 

(3) .REOCriNE Is not FALSE. 

14.5.2. MANIFEST? and UNMANIFEST 

<HAH1FES1? *tOm> 
returns T if Mom is MANIFEST. eTALSE ( ) otherwise. 

<UHMAN1FES1 atom atom ...> 
removes the MANIFEST of the global value of each of its arguments so that the value can be changed. 

14.5.3. GBOUND? 

<r,nomm? */on»> 

£ta^r«? b f °"";fV C, " r " S T ? *'° m " a% a E'obal value slot (that is. if it has ever been SETGed. 
MANIFEST. GDECLccl. or GLOCed (chapter 121 with a true second argument). rFALSE ( ) otherwise. 



1*1.5.1 - 14.5.3 Data-type Declarations 



The MDI. Programming Language 



133 



M.6. NrWTYPC (aci iii) 

NEWTYPE give* tlit- programmer another way to DECL objects. The third (and optional) argument of 
NEWTYPE is a Ol'OTTd Pattern. If given, it will be saved as the value of an association (chapter 13) 
using the name of the NEWTYPE as the item and the ATOM DCCL as the indicator, and it will be used to 
check any object that is about to be ClITYPEd to the NEWTYPE. For example: 

OJCWTYPE COMPLEX-NUMBER VECTOR '«PRIMTYPE VECTOR> FLOAT FLOAT» 

creates a new TYPE , with its first two elements declared to be FLOATs. If later someone types: 

fCOHPl EX-NUMBER [1.0 2 J 

an error will result (the second element is not a FL0A1). The Pattern can be replaced by doing 
another NEWTYPE for the same TYPE, or by putting a new value in the association. Further 
examples: 

<NEWTYPE FOO LIST '<<PRIMTYPE LIST> FIX FLOAT [REST ATOrl]>> 

causes TOOs tn contain a fix and a FLOAT and any number of ATOMs, 

<HEWIYPE BAR LIST> 

<SET A JRAR ('BAR () 1 1.2 GRITCH)> 

<NEWTYPE BAR LIST *<<PRIMTYPE LIST> BAR [REST FIX FLOAT ATOMJ>> 

This is nn example or a recursively DECLed TYPE. Note that <1 .A> does not satisfy the DECL, 
because it is empty, but it was CHTYPFd before the DECL was associated with BAR. Now. even 
<CHTYPE <1 .A> <TYPE <1 . A>» will cause an error. 

In each of n.rse examples, .he «PRTMTYPE ...> ...> construction was used, in order to permit 
CHTYPEuig an object into Itself. See what happens otherwise: 

< NEWTYPE OOPS LIST *<LIST ATOM FL0AT»S 

OOPS 

<SET A CCHTYPE (E 2.71828) OOPS»S 

''OOPS <E 2.71628) 

Now <CHTYPC .A OOPS> will cause an error. Unfortunately, you must 

<CIITYPE <CMTYPE .A LIST> OOPS>S 
-OOPS (F 2.71878) 



H.G 



Data-type Declaration* 



r 



134 The MDL Programming Language 

14.7. Con trolline PECL Ch cckin e 

There nrr several SlIRRs and FSUBRs in MDL that are used to control and interacl with the DECL- 
checkiug mechanism. 

14.7.1. DFCL-ClirCK 

This entire i-"inpli'.\ checking mechanism can gel in the way during debugging. As a result, the 
most commonly used OCCL-oricutcd SUBR is DECL-CHECK. It is used to enable and disable the entire 
DECt. -check mi;; mechanism. 

<DECL-CIIECK f*lse~or-sny> 

If its single argiiuirni is nou-FALSE. DECL checking Is turned on: if it Is FALSE. DECL checking Is 
turned off. The previous stale i* relumed as a value. If no argument is given. DECL-CHECK returns 
the current state. In an initial MDL DECL checking is on. 

When DEC I checking is on. the PECL nr an ATOM is checked each time it is SET. the arguments and 
results ««f rails to FUNCTION*. RSUBRs. and R5UBR-ENTRY* are checked, and the values returned by 
PROG and REPEAT are checked. The same is done for SETGs and. in particular, attempts to change 
MANIFEST global values. Attempts to CIITYPE an object to a NEWTYPE (if the NEWTYPE has the 
optional PECL) are also checked. When DECL checking is off. none of these checks is performed. 

14.7.2. SPICIAI -CHECK ami SPECIAL-MODE 

<SPECIAL-CMECK fa'r.e-or-any> 

controls whether r»r not SPrCIAL checking is performed at run time by the interpreter. It is initially 
off. Failure in declare an ATOM to he SPECIAL when it should be will produce buggy compiled code. 

<SPrCIAL-UODE spedflly:Mom> 

sets the declaration u*ed by default (for ATOMs not declared either way) and returns the previous such 
declaration, nr the current such declaration if no argument is given. The initial declaration used by 
default is UMSPECIAI . 

14.7.3. GCT-DECL and PUT-DECL 

GET-DECL and PUI-IHCL are used to examine and change the current DECL (of either the global or 
the local value) nf mi ATOH . 

<GEl-nrci iocd> 

1-1.7 - 14.7.3 Data-type Declarations 



The Mill. Programming Language 

&£!£"£ 225.* ""■ n " ,crwiw ' FALSE ( » — — *»* *• **•• - «— — - 

<PROG (X) 

?0£CL <(X) <OR FIX FLOAT>) 

<GET-DECL <LLOC X» 
> 

would return <OK I IX FLOAT* as the reM.li of il.e application of GEI-DECL. Note that becaus* of 

SI'S w^S "wf^CS? M,Utt i F AI0H Ccing c " , " i "* d '— be ES^SiSS^ 
K^u^ ESS y IC " i,,E fir " wit " B0UN07 ' or GB0UN0? * or by giv ' ng 

^c^»rT,rd OI |f7l^v^, ;,m ; ,, " l f* "" ? ,0ba ' "° l *" d !, ' e V3,UC to """"ST. then ,|,e ATOM MANIFEST J. 
returned, ir il.e value l.e.ng examined i* „ot DCCLcd. fFALSE ( ) U returned. 

<PUT-f»FCL loed P.*ttcrn> 

;;;;"^;"' ,r ,hc ™ Cl for «* v * h " *"° «•<«".» /«* If <DECL-CHE«> is true, the current value 
'"' , ' fV " CW Paltm - WT-DCCL U normally used in debugging, to change the DEC. of "« 

14.7.4. 0ECL7 

<DFCL? .my P*tte> rn > 
specifically checks My against Pattern. For example: 
<DFCL7 '[1 2 3] '<VECTOR CREST FXX1»S 

<DCCL? '[1 2.0 3.0] ^VECTOR CREST FIX1»* 
''I ALSC < ) 



H.8. orrsrr 

" "n°b7r SE A,? SSSTSLiT? hS " Pa " Wn - ? — * ""* W «" d " a » APPLICABLE rather than a 

offSeu uto mcu Tr , .; p"*"'" ,'° ipccify ,,,e typc of 1,ruc,ure ,,,a ' j,i FIX a PP ,j « «* 

eventuAl'lv No hrln ,i p ,„ T P"*" 1 * " ca » mafcc debugging considerably easier they will 
emuall) aHo help the compiler generate more efficient code. 

14.7.3 - 14.8 Data-type Declarations 



I3G 



The MDL Programming Language 



V5JSXS2J2E " IW ° ar S"" u -" 14 - a F *X »»d * Pattern, and return* -" object of TYPE and 

PRIMTYPC orrsCT . An orrsCT. like a FIX. ...ay be given a, an argument 10 NTH or PUT and may be 
*ppi.r«i in argument*. The only difference is that the STRUCTURED argument must match the 
Pattern contained in I he OFFSET, or an error will result. Thus: 

<SETG TOO <0rFSET i '(channel fix>»s 
x<orrsFT 1 '(CHANNEL FIX» 
<F00 ,JHCHAH>S 

1 

<roo <ROOT>>S 

"ERROR- 

ARG-VRONG-TYPfc 

NTH 

I I5IEHING-AT-LCVCL 2 PROCESS 1 

lotet ul.cn the compile gels around to undemanding OFFSET*, it will not do the right thine with 
■ em unless they are MANIFEST. Since there's no good reason not to MANIFEST them, this isn't a 



Note: 

tl 

problem. 



The SUDR INDEX, given an OFFSET, returns its FIX: 



< INDEX .fOO>S 
1 



r,.Vvv n'rVsr r/- ?f" r ,f T "'"".'L'iv •*"*** Pan " ,,: ™T-DECL of an OFFSET and a Pattern returns 
a new orrsf 1 with .he Mine INDEX as tI.c argument, but with a new Pattern: 



<GET-riECL .FOO>S 
<CIIANNEL FIX> 

<PUl-orci .100 onLisr>s 

X<Of FSt I I OBLISI> 
.FOOi 

•/<orrsci i '<ciianhei. fix>> 



Aii OFFSET is not a siruciured object, as Ihis example should make clear. 



M.9. Th e RSUHR DFCl 

Tnd vaiT rTfi! ! , * l,n,l * r r « n ,, ' c r AT0M °ECL. except that the declarations are of argument positions 



M.8 - 14-9 



Data-type Declarations 



The MDI. Programming I angiiagc |jy 

The simplest RSURK DECL is for an RSUBR or RSUGR-ENTRY (chapter 19) which has all of its 
arguments evaluated and returns a DECLcd value. For example: 

*»DCCL ("VALUE" FIX FIX FLOAT) 

declares that there are two arguments, a FIX and a FLOAT, and a result which is a FIX. While the 
STRING "VALUE" is uol enmf rained lo appear at the from of the DECL. it does appear there by 
custom. It nrcd IIOI appear at all. if the result is not to be declared, but (again by custom) in this 
case it is usually clcclarrri ANY. 

If any arguments are optional, the STRING "OPTIONAL" (or "OPT") is placed before the Pattern for 
the first optional argument: 

1T1ECL ("VALUE" FIX FIX "OPTIONAL" FLOAT) 

If any of the arguments is not ;n be evaluated, it is preceded by the STRING "QUOTE" : 

''DECL ("VALUE" FIX "QUOTE" FORM) 

declares one argument, which is not EVALcd. 

If the argument* are to be evaluated and gathered into a TUPLE, the Pattern for it is preceded by 

the STRING "TUPLE": 

•DECL ("VALUE" FIX "TUPLE" <TUPLE [REST FIX]>) 

If the argument* arc to he uuevaliiafeU and gathered into a LIST, or if the calling FORM is the only 
argument , the Pattern is preceded by the appropriate STRING: 

^DECL ("VALUE" FIX "ARGS" LIST) 

'Orel (-VALur- nx -cail- <prihtype list>) 

In every case the special indicator STRING is followed by a Pattern which describes the argument, 
even though it may sometimes produce fairly ludicrous results, since the Pattern for "TUPLE" always 
must be a TIJIM E ; for "ARGS". a LIST; and for "CALL", a FORH or SEGMENT. 




14.9 Data-type Declarations 



138 



The MDL Programming Language 



r 



Chapter 15- L«xtMj Blocking 

Lcxic.il. or sialic. binding la another means of prcveniing identifier collisions in MDL. (The first 
was dynamic binding - binding and ENVIRONMENTS.) By using a subset of the MDL lexical 
blocking facilities. Hie "block structure" of such languages as Algol. PL/I. SAIL, etc., can be 
simulated, should you wish to do so. 



15.1. Italic Considerations 

Since what follows appears to be rather complex, a short discussion of the basic problem left* 
blocking M*lv«a ami MDL's basic solution will be given fir*l. 



ATOMs arc identifier*. It is thus essential that whenever you type an ATOM. READ should respond 

]V J,;?."'"?"' ,t,pmiricr > n " ***** IO designate. The problem is that ii is unreasonable to expect 
the PNAUCs of all ATOMs lo he unique. When you use an ATOM A in a program, do you mean 
you typed two minutes ago. the A you used in another one of your programs, or the A used by 



library program? 



P' 

be A 
by some 



Dynamic binding (p lulling down of LVALs) solves many such problems. However, there are some 
which If uncs no. jnjvc - Mich as slate variables (whether impure or pure). Major problems with a 
system having only dynamic blocking usually arise only when attempts are made lo share large 
numbers of significant programs among many people. 

The solution used in MDL is basically as follows: READ must maintain at least one table of ATOM* to 
guarantee any uniqueness.. So. MDL allows many such tables and makes It easy for the user to 
specify which one is Wanted Such a table is an object of TYPE OBUST ("object list"). All the 
complication which follows arises nut of a desire to provide a powerful, easily used method of 
working with OGl IS Is. with reasonable values used by default. 






15 - 15.1 



Lexical Blocking 






-!- 



The MOI. Programming language 



139 



15.2. OflLIST* 



A.i OBLIST is of I'RIMTYPE UVfcClOR Will. UTYPE LIST; the LIST* hold ATOM*. fThe ATOM* are ordered 
by * ™ ' ,i*? tl,,,W °'! U,Cir PMA " EW eaC '' LIST " " »«»*"* bucket.) What follow* is information 



about OIH.ISU as such. 



15.2.1. OOLISI Nanus 

Every normally constituted 0IU1.ST ha* a name. The name of an OBLIST is an ATOM associated wiih 
the OBLI5T under the indicator OBLIST. Thus. 

<GCIPKOP ol*l,r.t 0DL1ST> 



<C,CT oblir.l 0IIL1ST> 
returns the name «»f o6/*s/. 

«; , ";'"' y - C \" y " an,e ° f a " 0BLIST "» -»ociated with it* OBLIST. again under the indicator 
OBLIST, so that 

<GCTPROP ohlist-n*nie:*tom OBLIST> 



<GC1 ohhst-n*me:.->tOrn 0D[ I5T> 
returns the 0BL1SI whose name i* oblist-ntrrxj. 



Since _ there is nothing M , C elal about ,he association of OBLIST* and their name*, the name of an 
OBLISI can he changed hy use of PUIPROP, both on the OBLIST and it* name. It i* not wise to 
change ,| 1P OBLIST association without changing il.r name association, since you are likely to 
confuse RCAD .ind PRINT terribly. * * 

Von can nlso use PHI or PUIPROP to remove the association between an OBLIST and its n 




«.ne as if they were in no OBLIST - which is defeating the purpose of this whole exercise. 



15.2 - 15.2-1 



Lexical Blockii 



>ff 



The MDL Programming Language 

15.2.2- MOBL1S1 

<HODLIST Mom f,*> 



eta 



r.»ake ol.lKi-l crrn.es and return, . new OBLIST. containing no ATOM*, whose name is Mtom. unU, 
I here alrca.lv exists *„ ODLISI of that name, in which case il returns the existing OBLIST. (i* is the 
size of H.rnni KT created - the number of hashing buckets. Ox is optional (ignored if the OBLIST 
already exists) 13 by defaul,. If specified. (I* should be a prime number, since that allows the 
liasliing to worl better. 

15.2-3. OBLlSIf 

<OBLISI? Mom> 
returns *FMSE ( ) if alom is not in any OBLIST. If *tom is in an OBLIST. it returns thai OBLIST. 

15.3. RE AD ajlil OSl 1ST* 

READ cm he explicitly told to look Op an ATOM in a particular OBLIST by giving the ATOM a trailer . 
A "Her coi.mM* of .he characters !- (cxclamation-poim dash) following ihe ATOM. i.ninediaTcW 
followed l.y ihe name nf the OBLIST. For example. 

A! -OB 
specifier the m.inue ATOM of PHAME A which is in the OBLIST whose name is the ATOM OB. 

Note tl.a, the name of ,„ c OBLIST must follow the I- with no separators (like space, tab. carriage- 
l-M 2* " * "**"* UWd by ******* <SCC!i0 " 15 ' 5 » wl,ich ,V P" out a,,d ** *yP^ in a* 

Trailers can he used recursively: 
B!-A«-OB 

SSSST ".^ ! ,nin " C V !^ PMAMr B WUicU '* Ul l,,C ° BLIST Wl,OSe " a " ,e «• »'* «»'"«' ATOM of 
PHAME A w.uch b in .he OBLIST whose name is 08. (Whew!) The repetition is terminated via the 
look-up anil iiiMTtiou described below. 

!h a ,"pMA«r Wi "' * £l2 P,MHC !? " OI f0 "" d '" " ,C ° BLIST «NW by a trailer, a new ATOM with 
that pnahe is created and inserted into thai OBLIST. 

If an OBLIST whose name is given in a trailer docs not exist. READ creates one. of length 13 buckets. 

15.2.2 - 15.3 Lexical Blocking 






The MI>I. Programming Language 



MI 



If rrailer nniatmn .s „o, „scd ,,j lc normal- cave), and for an ATOM that terminates a trailer. READ 
looks i.p tl.r PM«ir of ,l,r AIOH in a LIST of OBLIST*. Hie LVAL of Il.c ATOM OBLIST by default. This 
look-up MOTtt Willi <1 .0BI1ST> ami continue* Until .OBLIST is exhausted. If the ATOM is not 
found. REAP usually Inserts il inio <1 .OBLIST>. (H is possible to force READ IO use a different 
clement of Hie LIST of OBLISTs for new insertions. If the ATOM DEFAULT is in that LIST, the 
OBLIST following i|,.,r ATOM will be used.) 



15.4. Pit INI and OCI 151*. 



When PRINT i*. given an ATOM to output, it outputs a* little of the trailer as is necessary to specify 
the ATOM uniquely to READ. That is. if ,|,e ATOM is the firM ATOM of that PNAME which READ would 
find in it* normal look-up in Hie current .OBLIST, 



the name of the OBLIST is recursively PR J N led. 



10 trailer is output. Otherwise. • - is output and 



Warning: there are objure cases, which do not occur in normal practice, for which the PRINT trailer 
recursion doe* not terminate. For Instance, if an ATOM must have a trailer printed, and the name of 
the OBI 1ST is .in ATOM in that very same OBLIST, death. Any similar circular 



PRINT a hernia. 



case will also 



give 



15.5. Iuiti.i1 State 



In an in Mini Mill. .0CL1S1 cm 



us iwo OHUSIi. <1 -OBLIST> initially contains no ATOMs. and <2 
.OBLIST> contains all ihe ATOMs whose GVALs are SUBRs or FSUBRs. as well as OBLIST. DEFAULT T 
etc. Ii is difficult io lose trad, of the latter: the specific trailer ! -scptrafor will always cause 

HttTwUST " ,;,! 0n ' ISI * '" :,d( ' i ' i0n • " ,C SUDR RO ° T - Wl ' ich ***** "° **«■■■*■ » lw »r* returns 



The name nf <noor> is root; this atom is 

it not Tor the use of \-st>p*r*tar. The 
INITIAL!- ). 



il <ROOT> and would cause infinite PRINT recursion were 
name of the initial <1 .OBLIST> is INITIAL (really 



The ATOM OBLIST also has n r.VAL . .OBLIST is initially the same as .OBLIST: however. OBLIST is 
not affected hy the SLiilRs used to manipulate the OBLIST structure. It is instead used only when 
errors occur. ' 



is checked to sec if it is "reasonable" -- that 



is. contains 



In the case nf nil erinr. the current -OBLIST 

nothing or the wrong TYPI . (It is reasonable, but not standard, for .OBLIST to be a single OBLIST 
T Of Mum.) If it Js reasonable, that value stays current. Otherwise. OBLIST is SET to 
hat changes made to the OBLISTs on .OBLIST - for example, new ATOMs added - 
.ORI.IST is unreasonable. OBLIST is SET and SETGed to its initial value. <ERRET> 
(section 10. It always ASMIIIies that .OBLIST is unreasonable. 



-OBLIST. Note 
remain. If even 



15.3 - 15.5 



Lexical Blockin 



S 



142 



The MDL Programming Language 



Three oilier OBLlSIs exist in a virgin MDL: their names and purposes are as follows: 

ERRORS!- remains ATOtb whose PNAMEs arc used as error messages. It is relumed by <ERRORS>. 
ised by the interrupt system (section 21.5-1). It is returned by 



IN It until' IS ' - I* 
<INTERRUPIS>. 



HUIHil I !- i-. u^efl infrequently by the interpreter when loading compiled programs to fix up 
reference* to locations, within the interpreter. 

The pre-loading nf compiled programs may create other OBLISTs in an initialized MDL (Lebling. 
1979). 



15.6. H I OCk ami IN hill OCK 

These SUBRs arc analogous to bcein and end in Algol, etc. in the way they manipulate static 
blocking (ami in mi nthrr way). 

<ELOCK lcok-upJiat-ot-obtists> 

returns its argument after "pushing" the current LVAL of the ATOM OBLIST and making its argument 
the current LVAL. Vnn usually waul <ROOT> to be an element of look-up. normally its lasl. 

<EW>BLOCK> 

"pops" the LVAL of the ATOM 0ULIS1 and return! the resultant LIST of OBLISTs. 

Note that this "pushing" and "popping" of .OBLIST is entirely independent of functional 
application, binding, cic. 



15.7. SUiiRs Associat ed with Lexical Blocking 



15.7.1. RtAO (again) 

<REAO channel cof-routinc look~up> 

This is a fuller call lo READ, look-up is an OBLIST or a LIST of them, used as slated in section 15.3 
to look up AlOMs and Insert them in OULlSTs. If it is not specified. .OBLIST is used. See also 
sections II.I.I.l. 11.3. and 17.1.3 for oilier arguments. 



15.5 - 15.7.1 



Lexical Blocking 




The MOL Program tiling Language ,._ 

15.7.2. PARSE ami LPARSE (again) 

{PARSE ---trine r*dix;lix look-up> 

a* was previously mentioned, applies READs algorithm to siring and returns the first MDL object 
resulting. Till* include* loofc.ng up prospective ATOMs on look-up, if given, or .OBLIST. LPARSE can 
be called in the nam* way. See aKo sections 7.G.6.2 and 17.1.3 for other arguments. 

15.7.3. IOOKUP 

< LOOKUP ttrins obthjt) 



-'false cT. A ir°V/" r ^^ !V3&. I,,e 0BL1ST •*"* if thm is mh " AI0M = <"»«~* 

one OOLIST 



•*".'" J " " ••«"- — *«*-» riii m U n; oincrwise. i< returns 

If *///«« would PARSE into an AlOM anyway. LOOKUP is faster, although it looks in only 
instead of a LIST of iliem. * ' 



in: 



I5.7.-L ATOM 

<ATOH •:/*-/«.:> 

OoTisT " ttd tCt '"" S " Spa " fcing " PW A10M ° f PNAHE ■**« **** » guaranteed not to be on 
An AlOM which la hoi on any OBLISI is PRXNTcd with a trailer of ! -#FALSE (). 

15.7.5. REMOVE 

< REMOVE tlr/ns oblisl> 

£^«.«™™t* oT*c frm " ob "" ""' rc,ur,,i "' a ' aiom - ,r ,,,cre u n ° ,uch atoh - 

<REKOVC *tom> 

S«5u!'. ta 0ULIS1 * if " is °" °" e * n re,urH1 " om if " was on an 08LIST; ° ,h " wi « » 



I5.7.G. INSERT 

< INSERT strin£-or-*tom obhst> 



15.7.2 - I5.7.G 



Lexical Block In 



B 



I -1-1 



The MDL Programming Language 



create* an ATOM or PUAftT ttrtng, inserts it into oblist and returns it. If there is already au ATOM with 
lite same PNAMF a-, stain in oblist, an error occurs. The standard way to avoid the error and always 
get your .-.ton is 

<OR < LOOKUP ffrinc obtist> <INSERT strins ob/ist» 

As with REMOVE. INSERT can also tale au ATOM as its first argument; this ATOM must not be on any 
OBLIST -- it miiM have hrcn REMOVEd. or just created by ATOM — else an error occurs. The OBLIST 
argument i* never optional. If you would like the new ATOM to live in the OBLIST thai READ would 
have chosen, yon can <PARSE strins> instead. 

15.7.7. PNAMt 

< PNAME *tom> 

returns a SIRING (newly created) which is Mom's PNAME ("printed name"). If trailers are not needed. 
PNAME is much faster than UNPARSE on atom. (In fact UNPARSE has to go all the way through the 
PRINT algorithm twice , the first time to see how long a STRING is needed.) 

15.7.8. SPHAME 

SPNAMT CMiarrtl printed name") is Identical to PNAHE. except that the STRING it returns shares 
storage with .•Ion, (appendix It. which is more efficient if the STRING will not be modified. PUTting 
into such a STRING will cause ait error. 



15.8. Example: Another Solution to the INC Problem 

What follows is an example of the way OBLISTs are "normally" used to provide "externally 
available" ATOM* and "local" ATOMs which are not so readily available externally. Lcbling (1979) 
describes a systematic way lo accomplish the same thing and more. 

<MOBLlSI 1NC0 1> 

; "Create fin OBLIST to hold your external symbols. 
Its name is IHCO! -INITIAL! - ." 

XNCI-IIICO 

;"Put your external symbols Into that OBLIST. 
If you have many, just write thorn successively." 



15.7.6- 15.8 



Lexical Blocking 



The MDL l*rngramuiiiig Language 1,4c 

<BLOCK (<MOBLIST INCI!-INCO 1> <GET INCO OBLISr> <R0OT>)> 

;"Crcale a local OBLIST. neroinn It INCI'-INCO. and set up .OBLIST for 
reading in your program. The OBLIST INCO is included 1n the BLOCK so 
that as your external symbols are used, they will be found in the 
right place. Mote that the ATOM INCO is not In any OBLIST of the 
BLOCK; therefore, trailer notation of !-INCOwill not work within th« 
current BLOCK -FNDBLOCK pair." 

OEFIIJE IMC ;"INC is round in the IMCO OBLIST." 

(A) ;-A is not found and is therefore put into IMCI by READ." 

ITnTCL ((VALUE A) <OR FIX FIOAT>> 

<SET .A <♦ ..A 1>» ;"A11 other ATOMs are found in the ROOT." 

<ENnDLOCK> 

This example is. rather trivial, hut it contains all Hie issues, of which there are three. 

The fir»l Idea iv ihai you should create two OBLISTs. one to hold ATOHs which are to be known to 
other users (INCO). and l he oilier to hold internal ATOMs which are not normally of interest to others 
(INCI). The «-a«.r aim** ha* one AI0J1 in each category. 

Second. INCO is explicitly used without trailers so thai surrounding BLOCKS and ENDBLOCKs will have 
an effect on it. Thin INCO will be in the OBLIST desired by the user: IMC will be in IMCO. and the 
user can refer 10 it by saying INC!-INCO; IMCI will also be in INCO, and can be referred to in the 
same way: finally. A is really A! -INCI ! -IMCO. The point of all this is to structure the nesting of 
OBLIST*. B 

Finally, if for some reason (like saving storage space) you wish to throw INCI away, you can follow 
the EMDBLOCK with 

CKEHOVE "IMCI- <CET INCO OBLIST» 

and thus remove all references to it. The ability to do such pruning is one reason for structuring 
OBLIST references. 

Note that, even after removing INCI. you can "get A hack" - that is. be able to type it in - by 
saying something of the form 

<lH.SrRl <I <1 ,IHC!-INCO» <1 .OBLIST» 

thereby grabbing A out of the structure of INC and re-inserting it into an OBLIST. However, this 
resurrects the name collision caused by <INC!-INCO A>. 



15.8 Lexical Blocking 



146 



The MDL Programming Language 



Chapter 16. Errors, Frames, etc. 



16.1. LISTEN 



This SUBR takes any number of arguments. II first checks the LVALs of INCHAN, OUTCHAN, and 
OBLIST for rcasouability and terminal usability. In each case, if the value is unreasonable, the ATOM 
is rebound to the corresponding GVAL. if reasonable, or to an invented reasonable value. LISTEN 
then does <TTYECHO -INCHAN T> and <ECHOPAIR -INCHAN .OUTCHAN>. Next. It PRINTS Its 
arguments, then PRINTs 

LISTENING-AT-LEVEL / PROCESS p 

where / is an integer (FIX) which is incremented each time LISTEN is called recursively, and p is an 
integer identifying the PROCESS (chapter 20) in which the LISTEN was EVALed. LISTEN then does 
<APPLY <VALUE REP». if there is one. and if it is APPLICABLE. If not. it applies the SUBR REP 
(without making a new FRAME - see below). This SUBR drops into an infinite READ-EVAL-PRINT loop, 
which can be left via ERRET (section I6.4L 

The standard LISTEN loop has two features for getting a handle on objects that you have typed in 
and MDL has typed OUT. If the ATOM L-INS has a local value that is a LIST, LISTEN will keep 
recent inputs (what READ returns) in it. most recent first. Similarly, if the ATOM L-OUTS has a local 
value that is a LIST. LISTEN will keep recent outputs (what EVAL returns) in it. most recent first. 
The keeping is done before the PRINTing. so that ~5 docs not defeat its purpose. The user can 
decide how much to keep around by setting the length of each LIST. Even if L-OUTS is not used, 
the atom LAST-OUT is always SET to the last object returned by EVAL in the standard LISTEN loop. 
Example: 






<SET L-INS (NEWEST NEWER NEW)>S 

(NEWEST NEWER NEW) 

-l-INSS 

(.L-INS NEWEST NEWER) 

<SET FOO 69>S 

69 

<SET FIXIT <2 .L-INS» 
<SET FOO 69> 



;"grab the last InpufS 



IS - 16,1 



Errors. Frames, etc 



^ 






The MDI. Programming Language 



147 






.L-INSi 

(.1.-1 MS <SCI riXIT <2 .L-INS» <SET FOO 69>) 
<PUI .1 1XII 3 105>X 
<SEI FOO 105> 
<CVA1 .FIXIT>S 

I Ob 

.L-IHSS 

(.L-IMS <EVAL -FIXIT> <PUT .FIXIT 3 I05» 

-FOOS 

105 



16.?. f-'RROR 



This SURR is :!.. s. 



.mi«T i, i miV. .'. S n"I a \ L l STEN ' t ' XCt ' ,,, ,,,: " <0 h e<" era, » ■« i»icrrup« (chapter 21). if enabled, 
and (?) ii prink trror" hefnre PRJNTing lu argument* 

wrouc 'rvrrf'iri I FRROR 'T* ?" a, ' O, " a,0,, * co,,di,io » < for "■•«** «- foments are of the 
wrong TYI r.i. ii ,..||s CRROR with ai icavi two arguments, including: 

(1) .„ AlOH wlimc f-NAHC describe* the problem, normally from the OCLIST ERRORS! - (appendix 

(?) I lie ATOM ihai names I he SUBR or FSUBR. and 
(31 any other iufoi ni.il inn of iuicicsl. 

^LlTi-V ^ 11 ' * wl, l alpvrr " ,P "" '" ERRQR "inrm . Exception: a few (for example DEFINE) will 
t*kt f.ml.er nenr-n .ha. depends n„ .he value returned. Tim non-standard action is specified in the 
error message (fiisi ERROR argument). P 



16.3. FRAM E Mhc TVrr j 

taSm^J! »««£',£"£! °" " T'™'* C °" ,ro1 "«* < cI "P'" 20) -Lencvcr a SUBR. FSUBR. 

"Subron,?' Jm ," ' Y <rl, 7' Cr ' 9> i% ***** m,w ° b J rc,s »™ "«•>" colicctive.y called 

„ , "' ' ,■' " to " ,a "" ■■•fnrii.ai.o,. describing what was applied, plus a TUPLE whose elements 

evJ^', u r,. V S " brf "" i " p a IM>"cU. If any of the Subroutine's arguments are to be 

evaluated, ihry w,l| have hern by the lime the FRAME is generated. 

A FRAME is an anomalous TYPE in the following ways: 

(1) II cannot |, r typed i, u i, caM ( ,e 5C „ Prfl , cd oll | y by applying a Subroutine. 

(2) It dors no. lypc .,„! in any standard format, but rather as #FRAHE followed by the PHAME of 
the Subroutine applied. ' 



16-1 • 16.3 



Errors. Frames, eic- 



The MDL Programming Language 
lfi.3.1. ARCS 

<abcs frame) 

CarguniemO nnnu law argument TUPLE or frame. 

IS-3.2- FUNCT 

<FUnCT //.•.-,.;-> 
Cfu..clio„-) rrn.rn, ,| ir ATOM who** C/LVAL U being applied in /ram*. 

16.3.3. FRAME (tl.c SURR) 
< FRAME ftamc> 

Bwar-SSaSSsF ««- 

16.3. 4. Examples 

rSSZJS? K "" C " '" "'"'- V °" "" " OW ' y " C " tMMt LISTEN lo °P '"•> f« '■"»«» EVALed. 

<rUHCT <rRAME>>S 
TRROR 

<I-UNCI <fRAIlfc <FRAHE»>S 

"c-''*i l >c-of-thc-Subr0utine-\Yhich-c*llcd-EPRQR;*tQm 
<ARGS <FRAHE <FRAHE>»S 

Wie- fl r i:( ,mw/<-/ -H w -S u/)rou ,/ TO . wWrt . ri|//eid . fff/?w . Mff 

16.4. ER^CT 

<ERRET mny tr.„. «> 

saKSsrws=sa»^ssrassattta , SK! 

16 3 * " ,6 ' 4 Error*. Frame., etc 



The Mill- I*rng ramming Language 



149 



any. Additional side effects ihai would have happened in the absence of 
happened. 



an error may not have 



LISTEH Cn " d a^i:l " ,,< ■" , IO ERRET H °P ,io ''" 1 - b y default the FRAME of the last invocation of ERROR or 



RFI H railed with no arguments, it drops yon all the way down to the bottom of the control 
Is .'ccc >«ivr P LISTEN IO ° P " a " d """" "* LISTEN - Al "**** LIS ™^"'« ensures «».« 



If ERRI is railed with no 

stacl- 

MDL it rcccp 



Examples: 

<* 3 <♦ a 1>>S 

•ERROR" 

ARG-UHOIIG-IYPE 



i TSTrrnuG-Ai-icvFL t process i 

<ARGS < FRAME <rRAME>»S 

[«. I J 

XT 5>S ;'Th1s causes the ♦ to return 5.- 

:"finally returned by the ■■ 



1! 



Note that when yn» are in a call to ERROR, the most recent set of bindings is still in effect This 
means thai yo„ can examine values of dummy variables while still in the error state. For example. 

(DEFINE F (A "AUX" (0 "a string")) 

'DECL {(VALUE) LIST (A) STRUCTURED <B) STRING) 
<.D <REST .A 2>) ;-Return this LIST.* >S 

<F '(1)>S 

-I RROR" 

oui -or -hounds 

REST 

LISTENING-AT-LCVEL 2 PROCESS 1 
-AS 

(1) 

-BS 

"a string" 

<ERRCT •(&)> : "Hake the REST return (5)."S 
("a string- (5)) 



1G.-1 



Errors. Frames, etc 



150 



The MDL Programming Language 



IS.5. RMRV 

< RE TRY fi*n>e> 



16.6. UHWIHD 

±± vzgzzte r sks • r^o^ry^r 1 rs a if s EVAL 

argument is CVAl.r.1. its value is ieiiorerl •,,„! M.. .,« t , " ,e «>"»«»> stack, (he second 

•r^m^^w^^^ini^t^SSS^t "oii-local return Is completed. The second 

facility is ..sefn. for riew.iT u A^lu t P r " CI " «»'«« «l»c call lo UNWIMD was made. This 

tempo ary cK^,m7E^ "" '" i " CO " ii ""' 1 «*« •"- for closing 

user'attempts to ^t^^^^^^ ^^ ^ " *" "" ~* " ^ 
coerxHE CLEAN AC! ("AUX" (C <0PfeH -read- -a file->» 

*DECL (<C) <0R CHANNEL FAL5E> .. ) 
< COHO < . C 

<UNWIND <PR0G () ... <CL0SE .C» 
<CL0SE -C»)» 



16.7. C oiltrnl.C: <*G) 



Typin S control^ (-R. <ASCII 7» a, MDL causes it to act just as if an 
whatever u,,. Purr ,.,.!y heiug dfinc . Vou can then examine t. e ta lues 

^ZtlZESSfi ™V '° T I,rS,,me, " (W, ' iC " » , « nw ««>- R "RY a FRA 
stack, or flush everything by applying ERRET to no arguments. 



error had occurred in 

of variables as above. 

FRAME lower on the control 



16.5 - 167 



Errors. Frames, etc 



^ 



The MDL Programming Language 



151 



16.8. Comml-S ("SI 

TlOlZ* ?££?*? rS ' <ASCI1 19>1 - " , MDL ""*" H IO "°P w »'» is '-PPenine and return to the 
FRAME -LERR\ !- INTERRUPTS, returning ihe ATOM T. «„ ,he Tenex and Topslo version*. ~0 a |» 
has the same effect,) 



16.9 O VERfLO W 

<OVtRH.OW t#lsc-or-jiny> 



S£ t ?*°" e Crr - r "«' C ^! b \£2 bh * numcric overfJow and underflow caused by the arithmetic 
SUBR* (♦. -. -. /). The SUDR OVERFLOW tales one argument: if it i, of TYPE FALSE 

rlJJ«Fmu 7 T* ■?e«« b ?? ° ,hwW * M th »7 " e «»»led. The initial state is enabled 

P « 1' "V 7 LSE (> ' ref ' eC,in S «■" P" vi0Ui «»«*■ Calling it with no argument 

returns the current Male. ■ 



16.8 - 1G.9 



Errors. Frames, etc 



152 



r 



The MDL Programming Language 



Chapter 17. Macro -operations 



17.1. READ Macros 



17.1. 1. % and XX 

ev.lu.Hon is .td b read to .11 Z \\ "'!""""'' «**« following .he X. T„e r«ul. of ,1,., 



Example: 



<DCriNC SETUP () <SET A 0»S 
SETUP 

<OEFIME NXT () <SET A <♦ .A 1 >»S 
NXT 

t%%<SETUf>> X<NXT> X<NXT> <XX<SETUP>) X<NXT>]S 



17 - 17.1.1 



Macro-operations 






— 






The MOL Programming Language l 53 

17.1-2. LINK 

<LINK exp&ny string obhst> 

creates an object «f TYPE LINK. PRIHTYPE ATOM. A LINK looks vaguely like an ATOM; it has a 
PNAMC (Hip <ti,n ;: argument), resides in an ODLIST (the oDhst argument) and has a "value" (the exp 
argument). A t ink lias the Strange property that, whenever it is encountered by READ (that is. its 
PNAMfc is read, Ja«1 like an ATOM, possibly with 0UL1ST trailers). READ substitutes the LINK'* "value" 
For I he LINK Immediately, The effect of READing a LINK"* PNAME is exactly the same as the effect of 
reading its "value". 

The on is/ argument is optional. <1 .OBLIST> by default. LINK returns its first argument. The 
LINK is crci ltd via INSERT, so an error results if there is already an ATOM or LINK in oblist with the 
same PNAIIf . 

The primary iim- of LINK* is in interactive work With MDL: expressions which are commonly used, 
b.n amioyingly long t» ty,, c . can be "linked" to PNAMEs which are shorter. The standard example is 
the following: 

CLINK 'cERRET> "~E" <ROOT>> 

which link- the ATOM of PNAME ~E in the ROOT OBLIST to the expression <ERRET>. 

17.1.3. PrniM.ini-ih'fiiicd Macro-characters 

During REAPing from an input CHANNEL or PARSEing a STRING, any character can be made to have 
a Special meaning. A character can cause an arbitrary routine to be invoked, which can then return 
any number of elements In be put into the object being built by READ. PARSE, or LPARSE. 
Translation of characters is also possible. This facility was designed for those persons who want to 
use Mni REAP 10 do large pans of their input but have to modify its actions for some areas: for 
example, otic might want to treat left and right parentheses as tokens, rather than a* delimiter* 
indicating a LIST. 

17.1.3.1. reap (finally) 

Associated will. RrAD is an ATOM. RCAD-TAQLE ! - , whose local value. If any. must be a VECTOR of 
elements, one for each character up to and including all characters to be treated specially. Each 
elemeni Indicate*, if not 0. the action to be taken upon READ's encounter with that character. A 
similar VECTOR. I he local value of PARSE-TABLE!-, if any. is used to find the action to take for 
characters encountered when PARSE or LPARSE is applied to a STRING. 

These tables can have up to 25G elements, one for each ASCII character and one for each possible 
cxcIamaiion-poini/ASClI-char.icter pair. In MDL. the exclamation-point is used as a method of 



17.1.2- 17.1.3.1 M 



acro-operations 




154 



Tlie MDL Programming Language 



expanding the ASC:il character set. and an cxclaiuatiou-poiut/charactcr pair is treated M one logical 
character when lini reading a SIRING. 

The clrimiH corresponding tn a character it <NTH table <♦ 1 <ASCII eh*r>» . The element 
corresponding 10 .in eKeJaiwnion-noJiitMSCU-cliaracter pair is <nth table o 139 <ascii co#r>>>. 
The tabic can In- slimier than 25G element*, in which case it is treated as if it were 25B long with 
element* beyond ii % actual length. 

All element or Ihe talllr-t iiium salisTy one of the following DECL Patterns: 

■0 indicates ihat im special action is to be taken when this character is encountered. 




CHAR AC II K indicates that the encountered character is to he translated into the given CHARACTER 
Whenever it appear*.. except when as an object of TYPE CHARACTER, or in a STRING, or 

immediately fallowing a \. 

FIX indiiaics thai ihr rharaucr is to be given the same treatment as the character with the 
ASCII value of the MX. This allows you to cause other characters to be treated in the same 
way as A-Z fur example. The -same exceptions apply as for a CHARACTER. 

<L 7S1 I ix> Indicate* the tame thing, except that the character docs not by itself cause a break. 
Therefore, if j| occurs when reading an ATOM or number, it will be treated as part of that ATOM 
or number. 

APPI 1CAIU I (m nnc argil men ft indicates that the character is to be a break character. Whenever 
it is encAtiuteird. the reading of ihe current object is finished, and the corresponding element 
of ihe table is APPLYcd "» the ASCII CHARACTER. (If READ is called during Ihe application, the 
cnd-nf-file slnr of ihr CIIANUCI temporarily contains a special kind of ACTIVATION (TYPE 
RrAliA) *n thai rinl-nr-nie can he signalled properly to The original READ. Isn't that 
wonder f It 1?) The value returned is lakru lo be what was read, unless an object of TYPE SPLICE 
is returned, ll so. the elements of this object, which is of PRIMTYPE LIST, are spliced in at the 
point whne Mill, is reading. An empty SPLICE allows one to return nothing. If a structured 
object is inn (Ming built, and a SPLICf is returned, elements after the first will be ignored. A 
SPLICE dining rending is similar to a SEGMENT during evaluating, except that, in some sense, a 
SI't ICC says "expand mc". whereas the structure containing a SEGMENT says T will expand you". 

<l 1S1 APPI li AM fr> indicates the same thing, except that the character does not by itself cause 
a break. Therefore, if ii occurs when reading an ATOM or number, it will be treated as part of 
thai ATOti or uiimhcr. 



READ tal.es an additional optional argument, which is what to use instead of the local value of the 
ATOM RCAD-TABLE as the VECTOR of read-macro characters. If this argument is supplied. READ-TABLE 
is rebound to it within the call to READ. READ lakes from zero to four arguments. The fullest call to 
READ is thus: 



17.1.3,1 



Macro-operations 






T- 



The MUL Programming Language 



155 



<READ channel cof-routino look-up rcad-tablewcctor> 
The oihei arguments arc explained in sections ll.l.I.I. \\.%. and 15.7.1. 

ERROR »nd L1S1EW rebind RFAD-1ABLE lo the GVAL of READ-TABLE, if »ny. else UNASSIGN it 
17.1.3.2. Examples 

Examples of each nf the different kinds of entries in macro tables: 
<SET RCAD-TABLE <IVECTOR 256 0>>S 

<PUT -READ-TABLE <♦ 1 <ASCII ! \a>> !\A> 

: "CHARACTER: translate a to A.-S 
T--.J 
..bet 
Abe 

<PU1 .READ-TABLE <+ 1 <ASCII !\%» <ASCII ! \A» 

;"F1X: make % Just a normal ASCII character. "S 

AXBC$ 

A\JCBC 

<PUT .RCAD-TABLE <+ 1 <ASCII !\.» (<ASCII !\.>)> 
;"<L1ST fIX>: make coma no longer a break 

character, but still special if at a break. "S 

A.P5- 
A\,B 
["That was an A I Oil wiLh PHAHE A.B ." 

• .Bi 

.0 

-."That was the TORM <GUAL B> ." 

<PUT -READ-TABLE <+ 1 <ASCII !\:» 

TUHCTION ((X) <LIST COLON <READ»)> 

;"APPI ICABLE: make n new thing like ( < and [ ."$ 

B:AS 

B 

<COl Oil A) 

: : :FOOS 

(COLON (COLON (COLON F00)>) 



I7.I.3.I - 17.1.3.2 



Macro- op era I ions 



156 



The MDL Programming Language 



r 



<PUT .IICAD- TABLE <♦ 1 (ASCII ,\-» 

(•'MIMCMOW ((X) <LIST COLON <RCAD»))> 

: "now S -S APPLICABLt>: " ke ° bOV0 ' bUt "" • br« fc 
I ...1 
U:A5. 
U:A 

;"Th«i w.is .in ATOM." 

: ::TOOS 

(COION (COION (COLON TOO))) 

17.1.3.3. PARSL and LPARSE (finally) 






I* !lic fnllrsr 
arguments ll 



off f PARSE h give,, a STWNG .0 pl^Z^^m^l^fl^ I!*** "*" ""^ «STcd 
thai «.» |( II(P w „ /*/*>arg..,„c. , I* given ,o parse PAP«?^ r c °' ,,,d f ° ,he STR1MG wJ "»» 
call tn PARM . Fin.illv PARSf n.. ,,L, , PARSE, PARSE-TABLE is rebound lo it within that 

*cct,o„s 7.G.C.2a„d 15.7.2. C b * ms paried - 0,, '« -rgument* are described in 

tlie object*, crc.-iicd. 



trie* lo parse the whole STRING, returning a LIST of 



&Z&£VAL£facxju 



17.2.1. DEFMACand IXI'AHIi 

|S?!i^S: ftSCT ^',:'J -»»; ««. ««"««. ■"«««. o f .„.„„, . 
Pth«r APPL1CABI , ivk) „ „, si , 1|;lp e tmrm '""""PE LIST .„d in fac. h„ . FUNCTION (or 



17.1.3.2 - 17.2.1 



Macro-operat ions 



= 



The M 1)1 Program III J tig language i 5 y 

EVAled iwirr. The fir*t rVAL causes the MACRO's clement lo be applied to the MACRO"* arguments. 
Whatever thai application return* (usually another FORM) is also EVALed. The result of the second 
EVALiiaimn .s the result of applying the MACRO. EXPAND is used lo perform the first EVAL without 
the set-mid. 

To avoid complications, the first EVAL (by EXPAND, to create the object to be EVALed the second time 
around) .* done In a mp-hiel environment. The remit of this policy is that two syntactically 
identical invocations or a MACRO always return the same expansion to be EVALed in the second step. 
The rim TVAI generate* two extra TRAMCs: one for a call to EXPAND, and one for a call to EVAL the 
MACRO application in a lop-level environment. 

Example: 

< OFF MAC INC (AIM -OPTIONAL" (N 1)) 

-['ECL ((VALUE) FORM (ATM) ATOM (N) <0R FIX FLOAT>) 

<TORM SET .ATM <FORH + <FORM LVAL .ATM> .N>>>$ 
INC. 
, IHCS 

M1ACRO ('FUNCTION ((ATM "OPTIONAL" (N I)) ...)) 
<SCI X 1>S 

1 

<IHC X>i 
2 

-X$ 
7 

<EXPAI1D '<1HC x»i 
<SET X <+ .X 1» 

Perhaps the inirmioii |« dearer if PARSE and % arc used: 

<DEfHAC IHC (ATM "OPTIONAL" (N 1)) 

futrcL (...) 

<l'AUSt " , <SLT '/..ATM <* '/..ATM X.H»"» 

MACROS really exhibit their advantages when they are compiled. The compiler will simply cause the 

«. r ™ " ,:, " n " '" nfC " r (vla ZXPMt ™ a,,d compile the result. The single element of a compiled 
MACRO is an RSUIIR or RSUIJR-l NIRY. 

17-2.2. Example 

Suppose you want to change the following simple FUNCTION to a MACRO: 

<ninnr dourie (X) #decl ((x) fix) <* .x .x» 

17.2.1 - 17.2.2 Macro-operations 



158 



The MDL Programming Language 



You may be tempted m write! 

COEFMAC DOUBLE (X) -DECL ((X) FIX) <FORH * .X .X» 
Till* MACRO wort*. Inn only when tl.c argument doe* not use le.nporary binding*. Consider 

<nrriur iripie (Y) <♦ .y <double .y»> 

l'!; i> ,' , " JC, l " '- .JW««1. il.e mp-ievrl binding of Y i* used, not the binding just created by the 
SOSTt ™ C ""'i;"^;"» *f "•'* FUMC1I0M would probably fail, because the compiler probably 
would have „o top.irvcl binding for Y. Well, how about X 

<OEFNAC DOUBLE CX) CFORH ♦ .X .X» ;The OECL has to O o.- 

r^ul.'!.v^hM ,, 7 r m " "l* VS?: 1 * rUNCTI0N ' bpcaU5C »« lo "S" ** «•« Tgument evaluated and the 
result e%a1u.-ii.-d again. And 1RJPIE works. Bui now consider 

■<OEFTHE JHC-AWD-DOUBLE (Y) CDOUBLE <SET Y <♦ 1 .Y»» 
You i>iijr||f hope 1h.11 

<iNc-Arjn-nouCLE i> -> <double <set y <♦ i i»> 

-> <DOUBLC 2> 
-> <♦ 2 2> 
-> A 

But. when nOlWI V. is applied to thai TORN, the argument is QUOTEd. »: 

<1NC-AND-U0UBLE 1> -> <DOUBLE <SET Y <♦ 1 .Y»> 

-> <TORH * <SET Y <♦ I .Y>> <s E T Y <1 .Y>>> 
-> <* 2 3> 
-> S 

cfwraimn i* none exactly once, say by FORM: 

<PCFHAC DOUBLE ('ANY) 

<TORH PROG ((X .ANY)) #DECL ((X) FIX) •<♦ .X .X>» 

As a bonus, the DECL can once more be used. 

F UNCUOHv |t„, ,he effort may be worthwhile if the compiled program must be speedy. 






17.2,2 



Macro-operations 




The MDI Programming Language 



159 



Chapter 18. Machine Words and Bits 

^ N lP^ 1 , f ;^ C ^' y A f w^ , ^ l n,, ? ^ ""'"^n'reed machine words and blis involves two data TYPE*: 
WORD a „d BITS A WORD is M.nply an nnlu.erpre.ed machine word, while a BITS is a "pointer" to a 
„Ved"^-ha I >^cr , iI. l ;. ,, " <>pcra,iug on WORDs is usually done only when compiled programs are 



18.1. W ORD* 

A WORD in MI>L is a IU>rMO machine word of 30 bits. A WORD always PRINT* in "# format", and it. 
contents are a I way A pruned in octal ihcncc preceded and followed by *). Examples: 



"WORD 

"WORD "000000000000 1 



:"all os*i 



-WORD "?000" 

-WORD -000000002000- 



;"ono bit 1"S 



''WORD "S25253 525852" 

-WORD 'b?b2S?b?i,R5?* 



-.-every other bit 1"S 



^l/c^rT, "^TV?' " " "'? "" Pr ' ,MIV '' E " "*• FL0AT - CHARACTER. .„d ...y o.h.r TYPE 
winch can f.c It* dala uiio one m.ichine word. 

A WORDc.n.M.n, hr.-,,, ;1 ^ Mmrlll 1o #> ._ or indeed any SUBRs except for CHTYPE . GET8ITS. PUTBITS 
^^hL^'i lip " ,a,l, | 1 * f '"'" io '»- •->" 'o be described below. Thus any ariU.metic bit 

o"ck o wZ u . y C " IVPr,,, P * W0RD '• riX - d °i»g «'•< arithmetic, and then CHTYPEing 

wm . !^ n IIm ' PVPr - b " nW»«P«l-ti»» can be done without CHTYPEing the thing to be played 

same TYPE as ihe nngjnnl object or can be CHTYPEd to it. 



18- IS.I 



Machine Words and Bits 



'60 The MDL Programming Language 

18-2. BIT S 

An object »f TYPE BITS i* of PRIMTYPE UORD , and PRINTS just like a WORD. The internal form of a 
BITS is precisely 1I1.11 of a 1'DIMO "byte pointer", which is. in fad. jnsl what a BITS is. 

For purposes «>f explaining what a HITS is. assume iliai the bits in a WORD are numbered from rjght 
to left, wild (lie rightmost bit numbered and the leftmost numbered 35. as in 

3a 34 13 ...no 

(This is iint tlic "standard" ordering! (lie "standard" one goes from left lo right.) 

A BITS is innsi conveniently created via ihc subr bits: 

<BIIS tV'dtfttfi* ri ; :ht-e(ia:e:fix> 

returns a It I IS which "points in" n set of hits width wide, wilh rightmost bit right-edge. Both 
arguments mnsi lie of type fix, and the second is optional. by default. 

Examples: I he indicated ap|>licaiinn nf BITS returns an object of TYPE BITS which points lo the 
indicated set of hits in a WOiiO: 

<BITS 7> 35 ... 7 .. . 

<BITS A 18> 35 ... ZZ 21 ZO 10 IB 17 ... 

<BI IS 36> 35 ... 



18.3. GE1BI1S 

<r,CT(lirS tron,:primly>pe~worf1 Mt> 

where fror.. is an object of PRIIITYPK WORD, returns a new object whose TYPE is WORD. This object is 
constructed in llic following way: the set of bits in from pointed to by bits is copied into the new 
object, r Isj hi-ail justed, that is. lined up against the right end (bit number 0) of the new object. All 
those hits nf the new object which are not copied arc set to zero. In other words. GET8ITS takes bits 
from an arbitrary place in from and puts them at the right end of a new object. The from argument 
to GETBITS is nOI affected. 

Examples: 

1S.2 - 183 Machine Words and Bits 



The MDL Programming Language 



161 



(GETUI1S 'WORD '777777777777" <BITS 3»S 
'WORD "000000000007* 

<GI "TI1ITS *01?3-15f.70123» <BITS G 1B»S 
-WORD "000000000045* 



18.-1. phi hi is 



<PUiniTS tOW/nityptfWOrd Oils frOMJfir/ml ype-word> 



where to and from are of PRTMTYPE UORO. reiurn* a eofi* of to. modified as follows: the set of bits 
in to Which arc P«'mcd I" •> oif are replaced by u,e appropriate number of rightmost bits copied 
from from <«,.i,o„ a |. by default*. In Other words: PUIBITS takes bits from the right end of from 
and Miam thru. ,„.n an arbitrary position in a copy of to. None of the arguments to PUTBITS is 



affected. 



Examples: 



O'UIUIIS -WORD "777777777777- <B1TS 

rWORD "777777777007" 

<I*UIBITS 'WORD "6GG777000U1" <BITS 

'■woe 1 1 «f.f.G77f»3001 1 ]• 

<HUI0I1S iUORO »76M3210;oS4* <BITS 18>>S 

'WORD "7G543Z0Q00QQ* 



G 3»$ 

5 15> #W0RD M23*>S 



i^JLJL'A v ii>? _M o 1 Ira n_p per a ( i o n s 



WW "hi h . , " T\ ™' *"" r ° VB r " k " «*»"» of PRIMTVPE WORD and returns a 

cxclus isc ",. "> 'i^, 000 ^ ? "" d ' h,C, " ViVC "° r " *"'«*'« "«"• « "equivalence" (inverse of 

Wumoni u ' Ji«« y, t°/ «* ^"'"CMU. EacI ' < 3 *« *»* »»"'b" of arguments. If „o 

ow' "?' £**": ■? W0R1) Wt . ,h *" bi,s off (0RD *" d * 0RB > « on (ANDB and EQVB) is returned- If 



only one argument is given, it is returned unchanged but cilTYPEd to a 
arguments are given, the operator is applied to the first two. then appli 
"urd. etc. lie s„re not to confuse AND and OR with AHDB and ORB. 



WORD. If more than two 
pplied to that result and the 



18.3 - 18.5 



Machine Words and Bits 



The MDL Programming Language 
18.6. Hiftvi^c -Shifting Opcr.ilioiis 

<LSII fiOHKprimty pe-wor<f wnot/flfeff#> 

<l SH H 0>* 

"WORD -00000000 1000* 
<LSII -6>4 

"WORD -000000000000" 

<ROT fr<M»!Or«tf 1 > 1W --iv©rrf *moont*lx> 

ss^r s.r^'tsi::^^:;^,^ n ; ,mb " of wu ■*-•"* b * -«— ^od 

back i„ fll ,,„ nlIlf . r . „ ^ i0uiif «< J-gr*^ "™I . ' fPC IS S '' ifICd ° UI a ' on< - <» d «* P"< 

'■" rfghl. Kxamplr*: ' " '" ^0,a,,0,, ,s IO " ,e ,ef " « -"«*"" " nrg-liv*. rotation |?S 

<KO! 8 6>S 

(•WORD "000000001000- 

<rot n -cos 

"WORD -100000000000* 






Machine Words and Bits 



J 



The MDL Programming Language 16S 



Chapter 19- Compiled Programs 



19.1. RSUBR ( 1 1. c_TY PE) 

RSUBRs <~rrlnr.-ii.ililr subroutines") are machine-language programs written to run in the MDL 
environment. They are usually produced by the MDL assembler (often from output produced by the 
compiler) although this is not necessary. All RSUBRs have two components: the "reference vector" 
and the "code vector . In sonic cases the code vector is in pure storage. There is also a set of 
"fixups" associated with every RSUBR, although it may not be available in the running MDL 



19.2. The Refere nce Vector 

An RSUBR is basically a VECTOR thai has been CHTYPEd to TYPE RSUBR via the SUBR RSUBR (see 
below). This cs-VCClOR is the reference vector. The first three elements of the reference vector have 
predefined meanings: 

The first clement is of TYPE CODE or PCOOE and is the impure or pure code vector respectively. 
The second clement is an ATOM and specifics the name of the RSUBR. 

The third element is of TYPE DECL and declares the type/structure of the RSUBR's arguments and 
result. 

The rest of the elements of the reference vector arc objects in garbage-collected storage that the 
RSUBR needs in reference and any impure slots that the RSUBR needs to use. 

When the RSUBR is running, one of the PDP-10 accumulators (with symbolic name R) is always 
pointing to the reference vector, to permit rapid access to the various elements. 



19 - 19.2 Compiled Programs 






16* 



The MDL Programming Language 






10.3. RSUBR Unking 



". .1.0 Imrrprcc, f„ .hcK/SUBR iViJ^^"* ■"■"'»««»• OIUO) polm. direcNy . „., ™£ 

19.4. Pure and Imp.,,,. /"»,.- 

The first plemoiit of ;l i> rsuit ;, ,i 

i?r; ,E r c,oR ' and ^^t;Sm^S5 c t, e or ; coDE - ivpe code * - 

like a MMlrf.nl livrciOR. it W »| be moved aro „d bV , , . k " 2* "** VCC, ° r is s, °«* J"* 

code I. pejHlrerf ,« lie Ior.n.ion-i„«..si,ive The Zt S ^^ co,,cc,or - Therefore, all RSUBR 

"" s RSUBR «««*■ TH. PC00E pri„, s ourl: S * PCC,f,C5 in ° ff "' i "'° "" block of code J h £ 



X<PC0DE numtatrlng offset Ji,> 



19J - 19.4 



Compiled Programs 




The MDl. Program 



ig Language 



165 



where n.mtr names Ihe eniry in ilie user's pure-RSUBR table, and offset Is the offset. (Obviously. 
PCODE i* fll**» ''<<-' name of a SUBR, which generates a pure code vector.) Pure RSUBRs may also move 
around, but only by being Included in MDL's page map at different places. Once again M can be 
used exactly a* hrfnie to do location-independent address referencing. Individual pure code vectors 
can be "unmapped" 'iu.irl.rd as being lint in primary storage but in their original pure-code disk 
files* if the space in storage allocated for pure code is exhausted. An unmapped RSUBR is mapped in 
at;ain whenever needed. All pure RSUBRs arc unmapped before a SAVE file is written, so that the 
code is not duplicated on disk. A purified RSUBR must use RGLOC ("relative GLOC") instead of GLOC. 
RGLOC produces objects of TYPE LOCR insiead of LOCD. 



12.5.. TYPpi? and TYPE-W 

In order m handle user IJCWTYPfs reasonably, the internal TYPE codes for iliem have to be able to be 
different from onr MDL run to another, Therefore, references to the TYPE codes must be in the 
reference vector rather than the code vector. To help handle this problem, two TYPEs exist. TYPE-C 
("type code") and TYPE-W ("type word"), both of PRIMTYPE WORD. They print as: 

X<IYP1--C />p<> primtyp#:*tor*> 
%<TYPE-W type pru»typc:AtOM> 

The SUDR TYPH-C produces an internal TYPE code for the type, and TYPE-W produces a prototype 
"TYPE word" (appendix I) for an object or that TYPE. The primtypo argument is optional, included 
only as a check against the call to NEWTYPE. TYPE-W can alio take a third argument, of PRIMTYPE 
WORD, whose rit.'hi half is included in the generated "TYPE word". If type is not a valid TYPE, a 
NEWTYPr is automatically done. 

To be complete, a similar SUBR and TYPE should be mentioned here. 

<PRIHIYPr-C tipr> 

produces an internal "storage allocation code" (appendix 1) for the type. The value is of TYPE 
PRIMTYPC-C. PR1HTYPE WORD. In almost all cases the SUBR TYPEPRIM gives just as much 
Information, except in the case of TEMPLATES: all TYPEs of TEMPLATE* have the same TYPEPRIM. but 
they all have different PR1M1YPE-C*. 



19-6. R SUBR (the SUBR) 

<RSUuR [rode n*me decf ret ret ...]> 
CHTYPEs its argument to an RSUBR, after checking it for legality. RSUBR is rarely called other than 



19.4 - 19-6 



Compiled Programs 



re 



166 

The MDL Programming Language 

<SET FIXIT <CHTVPE .name VECTOR»S 

- . - (changes to .FIXIT) 

<SETG name <RSUBR ,FIXIT»$ 
"RSUBR [ . . . J 



19.7. RSU BR-ENTRV 

E^bT " aV - """' ""* POi '" S - A » "«B R - EN T R V ca „ b , , pplicd IO lrgumenIJ exac „ y , ifce 

<RSU 8R -EN1RY lr s „ b r-o,-„ om „„,«,.„,„„ decl} „„„,,„> 

<ENTRY-LOC r SU 6r-e/tfry> 
("entry location") returns ,he offset into Ihe RSUBR of this entry. 



19.8. RStinR* j„ FiiPs 

An NBIN file contains a mixture of .trn , 

portion U MgnaUcu to READ by Z XJ^JSSSL^ ""2 "^ *■" * U " ° f * *"■* 
incorrectly assume .ha, i, cuds S^S5m2t?2S '"*'" ° f M NBIN file ° n ITS "*V 

a text editor. An RSUBR is writ^i N Q L r ' rn ^"^ *" NBIN fi,e « n »« b * edited with 
RSUBRs in NBIN files are no, purif ed c'.her * e '" g PW "* - °" * "«»TB- CHANNEL. The 



19.6 - 19.8 



Compiled Programs 



J 




The MDL Programming Language 



167 



An FBIH file is aciually pari of a triad of files. The F8IN file(s) itself is ihe impure part of a 
collection of purified RSUBR*. It is simply ASCII and can be edited at will. (Exception: in the ITS 
and Tops-20 versions, the first object in the file should not be removed or changed in any way. lest 
a "grim reaper" program for FBIH files think that the oilier files in the triad are obsolete and delete 
(hem.) The pure code itself resides (in the ITS and Tops-20 versions) In a special large file that 
contains all . in i«-nily.ii*ed pure code, or (in (he Ten ex version) in a file in a special disk directory 
with first name ihe same as the name argument to PCODE for the RSUBR. The pure-code file is page- 
mapped directly into MDL storage in readonly mode. It can be unmapped when Ihe pure storage 
must be reclaimed, and it can be mapped at a different storage address when pure storage must be 
compacted. There is also a "fixup" file (see below) or portion of a file associated with Ihe FBIN to 
round out the triad. 



An initial MDL can have pure RSUBRs in it that were "loaded" during the initialization procedure. 
The files are not page-mapped in until they are actually needed. The "loading" has other side 
effects, such as the creation of OBLISTs (chapter 15). Exactly what is pre-loaded is outside the *cope 
of this document. 



19.9. Fi Mills 

The purpose of "fixups" is to correct references in the RSU8R to parts of the interpreter that change 
from one release of MDL to ihe next. The reason the fixups contain a release number is so that 
they can lie completely ignored when an RSUBR is loaded into the same release of MDL as that from 
which it was last written out. 

There are three forms of fixups. corresponding to the three kinds of RSUBR files. ASCII RSUBRs. 
found in BINARY files, have ASCII fixups. The fixups are contained in a LIST that has the 
following format: 



{MOL-releA?c:fix 

r\ame:atom v*lue;(ix (use:ftx use:fix 
nxmc;*tom vslue.-fix (use.fix uamttht 

■ --) 



..) 



The fixups in NBJN files and the fixup files associated with FBIN files are in a fast internal format 
that looks like a UVfcCTOR of PRIMTYPE WORDs. 

Fixups arc usually discarded after they are used during (he loading procedure. However, if. while 
reading a niNARY or NBIN file ihe ATOM KEEP-FIXUPS! - has a non-FALSE LVAL. the fixups will be 
kepi. v ,a an Association between the RSUBR and the ATOM RSUBR. It should be noted that, besides 
correcting ihe code, the fixups themselves are correcied when KEEP-FIXUPS is bound and true. Also, 
the assembler and compiler make the same association when they first create an RSUBR. so that it 
can be written oin with its fixups. 



198 - 19.9 



Compiled Programs 



168 



The MDL Programming: Language 



K^SrvSrS'*"*' 5 ^* c=f K ass 

or ?L " ' CX ' 5 '* " ,C MXUP file '* USfd IO crM,c a new copy of ,he file from an old 



19.9 



Compiled Programs 







The MDL Programming Language 



169 



Chapter 20. Coroutines 



This Chapter purports Co explain the coroutine primitives of MDL. It does make some attempt to 
explain coroutine* as such, but only as required to specify the primitives. If you are unfamiliar 
with the basic concepts, confusion will probably reign. 

A coroutine in MDL is Implemented by an object of TYPE PROCESS. In this manual, this use of the 
word process" is distinguished by capitalization from its normal use of denoting an operating- 
system process (which various systems call a process, job. fork. task. etc.). 

MDL's built-in coroutine primitives do not include a "time-sharing system". Only one PROCESS is 
ever running ai a time, and control js passed back and forth between PROCESSes on a coroutine-like 
basis. The primitives are sufficient, however, to allow the writing of a "time-sharing system" in 
MDL . with the additional use of the MDL interrupt primitives. This has. In fact, been done. 



20.1. PRO CESS (the TYPE) 

A PROCESS is an object which contains the "current stale" of a computation. This Includes the 
LVALs of ATONs ("bindings"), "depth" of functional application, and "position" within the application 
of each applied function. Some of the things which are not_ part of any specific PROCESS are the 
GVALs of ATOMs. associations (ASOCsl. and the contents of OBLISTs. GVALs (with OBLISTs) are a chief 
means of communication and sharing between PROCESSes (all PROCESSes can refer to the SUBR which 
is the GVAL of ♦. for instance). Note thai an LVAL in one PROCESS cannot easily be directly 
referenced from another PROCESS. 

A PROCESS PRIHTs as 'PROCESS p. where p is a FIX which uniquely identifies the PROCESS; p is the 
"PROCESS number" typed out by LISTEN. A PROCESS cannot be read in by READ. 

The term "run a PROCESS" will be used below to mean "perform some computation, using the 
PROCESS to record the intermediate states of that computation". 

N.B.: A PROCESS is a rather large object: creating one will often cause a garbage collection. 



20 - 20.1 



Coroutine 




170 

The MDL Programming Language 

20.2. STATF of a PROCESS 

<STATE process) 

returns an ATOM <i„ the ROOT OBLIST) whirl, | IU <|,.. ., - 

which STATE can re and ,heir n^ing". ^ .oil"'' "' "" " R ° CESS «"»■* Th < "°«* 

RUNAH.C ble) _ „.,. ... : . | 

RUNNING .. „.«.„ „ .„,„„„, rumi . , g iha( fc |( did [he appiJM(jon ^ ^ 

RESUMABtE - „,„„. „„ „„„ ru „. „ „ oi curmi[iy r|iniij|g and ^ ^^ ^_ n 

OEAD - p, 0f „ s „„ „„„ ru „. b ,„ „ ca „ m run jgajm u ^ . (crminaied . 

h« not been Implemented.) ""flocked (terminal ,nput -rrivedX (The STATE BLOCKEO 

20.3. PROCFStt (.i.„ c.. Rff j 

<PR0CESS stArter^pp/icxbt^ 

SSSS/ST"- * "" PR ° CESS -' *" =81 "» "< - 3TATE of ,he re.urned PROCESS U 

^^n^AZ^%^^^^Z^^ *—• ** **, U used both ln 
value. ,ha, PROCESS becomes DEAD *■*■** if ,h. s^,er of . PROCESS ever re.urn, " 

20-1. RESIIHF 

<RE5UME rctv*i:*ny proccss> 



20.2 - 20.4 _ 

Coroutines 






The MUL Programming Language , 7 I 



L 



The process argument ro RESUME is optional, by defauti the last PROCESS, if any. lo RESUME th. 
PROCESS in which this RESUME is applied. If and when the current PROCESS is later RESUMEd bi 
another PROCFSS. that RESUME'S rctvsl is returned as the value of this RESUME. 



20.5. Switching PRO CESSet 

20.5.1. Starting Up a New PROCESS 

Let us say thai we are running in some PROCESS, and that this original PROCESS is the GVAL of PO . 
Somewhere, we have evaluated 

<SETG PI <PR0CESS ,SIARTER» 

where .STARTER is some appropriate function. Now.in^, we evaluate 

<RESUME -A ,P1> 

and the following happens: 

(I) In ^PO the arguments of the RESUME are evaluated: that is. we get that LVAL of A which is 
current in . PO and the GVAL of PI . 

60 The S1AIE of .po is changed (o RESUMABLE and . PO is "frozen" right where it is. In Che 

middle of the RESUME. 

<3> The STATr of .PI is changed to RUNNING, and .STARTER is applied to . PO's LVAL of A in 
j_Pl. .PI now continues on its way, evaluating the bodv of -STARTFR. 



atever it 



I he a in the RESUME could have been anything, of course. The important point is that, wh 
is. it is evaluated in .PO. 

What happens next depends, of course, on what .STARTER does. 
20.5.2. Top-level Return 

reVur'.'A ! n J f, .*" y aSM "" e ,,,a ' ' STARTER aoM ■•**«* relating to PROCESSes. but instead simply 
reiurns a value -- say sfarwtf, What happens when .STARTER returns is this: 

(1) The STATE of ,P1 ii changed to DEAD. ,P1 can never again be RESUMEd. 

201-20.5.2 Coroutines 



The MDL Programming Language 

M*.*" PR ° CESS '° R " UME '" U f ° U " d - — * • P0 - «- <« STATE is changed «„ 

Sn^SC '* " '^ '" - P ° " '" C """' •" "•' ° ri * ln " RESUME - — ■>• ~»«l»«« where i, 

AH in ,11. IH . „ wpJ « cw looh , Ju „ Mt ,„ elabora[c yerjjon of app|yjng stari£r (o ^ ^ ^ 

20.5.3. Symmetric RESUMEing 

^TSSrSE^*"" *"" '" - PI '" C f °" OWi "« " *— * -*■» '» STARTER or „ something 

< RESUME .BAR .P0> 
This is what happens: 

(1) The arguments of I he RESUME are evaluated in ^Pl. 

SsSlI. STATE ° f •" " C " a " SCd '° ""UMABLE. and ,P, is -frozen" right in ,he middie of «he 

K resume u sr iiSKiAs^ r f r is — - - — - 
™: ^.^r'.a^rrjtr.;- r t, do --^ resuhe ■* •"> *■ •« ■— *»■ 

.PI b.rk a,.ai„, e.c. ad nauVc,,, « ,h" v^ v ,l".lnV d "" "°" "S^'" """"' • P °- W " ich "" RESUME 

^"-<«*««^.».m,^^^^ " «-« *- - 

20.6. Examplr 



I 



20.5.2 - 20.6 



Coroutines 



The MDL Programming Language 



17S 



;-Intllally, we are in LISTEN in some PROCESS." 

<DEFINE SUH3 (A) 

#DECL <(A) <0R FIX FLOAT>) 
<REPEAT ((S -A)) 

#OECL ((S) <OR FIX FLOAT>) 
<SET S <♦ .S <RESUME "GOT I">» 
<SET S <+ .S <RESUME "GOT 2">» 
<SET S <RESUME .S»»S 

SUM3 

;"SUM3. used as the startup function of another PROCESS, 

nets RfcSUMEd with numbers. It returns the sum of the last 



throe numbers it was 
<SETG SUMUP <PROCESS 
(•PROCESS 2 
;"Now wo start SUMUP 
<RESUME 5 ,SUMUP>S 
-GOT 1" 

<RESUME 1 ,SUMUP>$ 
■GOT 2" 
<RESUME 2 .SUMUP>S 

B 



given every third RESUME." 
.5UM3>>S 

and give SUM3 its three numbers." 



Jusi as a note, by taking advantage of MDL's order of evaluation. SUM3 could have been written mk 

<DEFINE SUM3 (A) 

<REPFAT (<5 -A)) 

#OECL ((A S) <0R FIX FLOAT>) 

<5ET S <RESUME <* .S <RESUME "GOT 1"> <RESUME "GOT 2"»»» 



20.7. Other Coroiilinine Features 



20.7.1. BREAK-SEQ 

<BREAK-SCQ *ny process) 

("break evaluation sequence") returns process, which must be RESUHABLE, after having modified it 
so that when it is next RESUMEd. it will first evaluate any and t hen do an absolutely normal RESUME; 
the value returned by any is thrown away, and the value given by the RESUME is used normally. 

If a PROCESS is BREAK-SEQed more than once between RESUMES. aU of the snys BREAK-SEQed onto it 
will be remembered and evaluated when the RESUME is finally done. The anys will be evaluated in 



20.6 - 20.7.1 



Coroutines 



174 



TheMDL Programming Language 



"last-in first-nut" order. The FRAME generated by EVALing more Ihan one *ny will have as its FUNCT 
the dummy ATOM BREAKER. 

20.7.2. MAIN 

When you Initially siart up MDL. the PROCESS in which you are running is slightly "special" In 
these two ways: 

(1) Any attempt to cause it to become DEAD will be met with an error. 

(2) <MAIN> always returns that PROCESS. 

The PROCESS number of <MAIN> is always 1 . The initial GVAL of THIS-PROCESS is what MAIN always 
returns. •'PROCESS 1 . 



20.7.3. ME 



<ME> 



returns the PROCESS in which it is evaluated. The LVAL of THIS-PROCESS in a RUNABLE (new) 
PROCESS is what ME always returns. 

20.7.4. RESUMER 

<RESUMER process > 

returns the PROCESS which last RESUMEd process. If no PROCESS has ever RESUMEd process, it returns 
#FALSE ( ) . process is optional. <ME> by default. Note that <MAIN> does not ever have any resumer. 
Example: 

<PROG (<R <RESUMER>)) ;"not effective in <MAIN>" 

*"0ECL ((R) <OR PROCESS FALSE>) 
<AND .R 

<«? <STATE -R> RESUMA8LE> 

<RESUME T -R>>> 



20.7.5. SUICIOE 

<SUICIDC r«/vj» process) 



20.7.1 - 20.7.5 



Coroutines 



The MDL Programming Language 



175 



acts juil like RESUME, bill clobbers the PROCESS (which cannot be <MAIN» in which it is evaluated to 
the STATE DEAD. 

20.7.6. 1STEP 

< 1STEP process) 

returns process, after putting it inio "single-step mode'. 

A PROCESS in singlr-stcp mode, whenever RESUMEd. runs only until an application of EVAL in it 
begin* or finishes. At that point in time, the PROCESS (hat did the 1STEP is RESUMEd. with a retvsl 
which la n TUPLE. If an application of EVAL just began, the TUPLE contains the atom EVLIN and 
the arguments to EVAL. If an application of EVAL just finished, the TUPLE contains the ATOM 
EVLOUT and the result of the evaluation. 

process will remain in single-step mode until FREE-RUN (below) is applied to it. Until then, it will 
stop before and after each EVAL in it. Exception: if it is RESUMEd from an EVLIN break with a retval 
of TYPE DISMISS (PRIM1YPE ATOM), it will leave single-step mode only until the current call to 
EVAL is about to return. Thus lower-level EVALs are skipped over without leaving the mode. The 
usefulness of this mode In debugging is obvious. 

20.7.7. FREE-RUN 

<FREE-RUN process) 

takes its argument out of single-step mode. Only the PROCESS that put process into single-step 
mode can take it out of the model if another PROCESS tries, FREE-RUN returns a FALSE. 



20.3. Snrakincss with PROCESScs 

FRAMEs. ENVIRONMENT*. TAGs. and ACTIVATIONS are specific to the PROCESS which created them, and 
each "knows its own father". Any SUBR which takes these objects as arguments can take one which 
was generated by any PROCESS , no matter where the SUBR is really applied. This provides a rather 
sneaky means of crossing between PROCESScs. The various cases are as follows: 

GO. RETURN. AGAIN, and ERRET. given arguments which lie in another PROCESS, each effectively 
"restarts" the PROCESS of its argument and acts as if it were evaluated over there. If the PROCESS In 
which ir was executed is later RESUMEd. il returns a value just like RESUME! 

SET, UNASSIGN. BOUND?. ASSIGNED?. LVAL, VALUE, and LLOC, given optional ENVIRONMENT 



20.7,5 - 20.8 



Coroutines 



176 

The MDL Programming Language 
argument* which /i c in another photcm 

Pta« .p« iriod . " S • '" ««. c„„. „c, «« ,„. ENVIRONMENT wh.ch -fcurrcnTin «£ 

«~. -I™"-. » — . « 0, „„ lppropr ^ le ^rrarxwE: 355 

If EVAL I» applied 
evaluation In pj fa 




2Q.9. Final m„.„, 
0) A 






J) A RESUMABLE PROCESS 

•^"•-^n^ENTof^pHpc^J^S" «v 1R 0NM EN r in . ny , pplicaIion . The 

C3) Bugs in iiitiiii-pRocFSS „r«-. . 



20.8 - 20.9 

Coroutine* 



The MDL Programming Language 



177 



Chapter 21. Interrupts 



The MDL intcrrupl-haudling facilities provide ilic ability to say the following: whenever 'this 
event" occurs. stop whatever is bring done at the time and perform "this action - : when "this action" 
is finished, continue with whatever was originally being done. "This event" can be things like the 
typing of a character at a terminal, a tittle interval ending, a PROCESS becoming blocked, or a 
program-defined and -generated "event". "This action" is the application of a specified APPLICABLE 
object to argument* provided by the MDL interrupt system. The sets of events and actions can be 
changed in extremely flexible ways, which accounts for both the variety of SUBRs and argument*. 
and the rich interweaving of the topics in this chapter. Interrupt handling is a kind of parallel 
processing: a program can he divided into a "main-level" part and one or more interrupt handlers 
that execute only when conditions are ripe. 



21. 1. Defin it ions of Terms 

An interrup t is not an object in MDL. but rather a class of events, for example, "tick*" of a clock, 
garbage collections, the typing of a character at a terminal, etc. 

An interrupt is said occur when one of the events in Its class take* place. 

An external Interrupt is one whose occurrences arc signaled to MDL by the operating system, for 
example, "ticks" of a clock. An internal interrupt fs one whose occurrences are detected by MDL 
itself, for example, garbage collections. MDL can arrange for the operating system not to signal 
occurrences of an external interrupt to it; then, as far as MDL is concerned, that interrupt doc* not 
occur. 

Each interrupt has a name which is either a STRING (for example. "GC", "CHAR". -WRITE") or an 
ATOM with thai PNAME in a special OBLIST. named INTERRUPTS!- . (This OBLIST is returned by 
<INTERRUP1S>.) Certain names must always be further specified by a CHANNEL or a LOCATIVE to 
tell whic h interrupt by that name is meant. 

When an interrupt occurs, the interpreter looks for an association on the interrupts name. If there 
is an association, its AVALUE should be an IHEADER, which heads a list of actions to be performed. 
In each IHEADER is the name of the interrupt with which the IHEADER is or was associated. 



21 - 21.1 



Interrupts 



178 



The MDL Programming Language 



«'„",,? ncr f«r. r IT. '■ ""V"" * * di " bled - " "" IHEA0ER b «"">"« • «■«■ none of 
IHEADrR ,c ,. n „r. ,i '„ "''"""l" "' ""^ '" -*** " iS "•"tlmeTS.** ,o disable ,„ 
*1* T' r ZZT ', BOCl " ,8n Wi,h *■ "«Pf« »•"•« M better than long. 

rhT££Z££V \ lfi&£i " "**'"'" '""• • "*'«* >P«'fi« «he interrupt"* ■ impM1 .„«-. 
tower , »r"rVl »^m,Hr S '"-'""n""'' "•"^'-•nnuered, interrupt win „,„„,, „,e processing of , 
lower pnortly u,„.,llrr.u„,„bered> tuterrup, u„,i| ,|« Mgh-prtorHjp inlerrup. has been handled. 

mSuM Z~'l ? '"°""" y "" P ' y ' "" ° f HflN ° LERl - ,T " is "*« * "•» • M» LIST.) E«" 




21.?. EVENT 

<CVCMT /Mm* priority whrch> 

SSShSS 'SSStlTmml^T^S r\XS"i The — • ""» "' " ATO " '« «•« 

<INTERRUPTS> If 11,,°,? S J RI " G - '/ " ,J " SIRING. EVEN! does a LOOKUP or INSERT in 
...e given "fo,;,^ """ ""^ '* '" IHEA0ER '"«'»'«' "«* —• "ENT jus, returns i,. ignoring 

which in ii si be given only for certain names: 




^^JTi^-mySSS!"^ n" d °'" y ," """V* " REA ° - ( " R ""' -I^ERRUPTS, or 
usage b >•(in■erprefed,;rnL;T„; S rL,i n ( s:cUon C V,%V PeC ' f, " " ^ " "< *"»«»~" '" 

If .he interrupt i, eternal. MDL arrange, for the operating system to sign., it, occurrences. 

ilA ' 2 ' 2 Interrupts 



The MDL programming Language 



179 



■Ml- HANDLER (the SUBR) 

< HANDLER ihetxfer applicable process} 

creates a HANDLER. adds It to the from of invader's HANDLER list (first action to be performed), and 
returns it .is n value. *pplicahlc may be any APPLICABLE object that takes the proper number of 
arguments- <Nonc of the arguments can be QUOTEd: they must all be evaluated at call time-) process 
U the PROCESS in which the handler will be applied, by default whatever PROCESS was running when 
the interrupt occurred. 

The value returned by the handler Is ignored, unless it is of TYPE DISMISS (PRIMTYPE ATOM), in 
which case none of the remaining actions in the list will be performed. 

The processing of an Interrupt** actions can terminate prematurely if a handler calls the SUBR 
DISMISS (sec below). 



21.4. OFF 



<OFF iheadr-r> 



removes the association between iheader and the name of its interrupt, and then disables iheader and 
returns it. (An error occurs if there is no association.) If the interrupt is external. MDL arranges For 
the operating system 1101 to signal its occurrences. 

<OFF name wluch> 

finds the IHEADtR associated with name and proceeds as above, returning the IHEADER. which must 
be given only for certain names, as for EVENT. Caution: if you <OFF "CHAR* ,INCHAN>, MDL will 
become deaf. 

<OFF handler > 



returns handler after removing it from its list of actions. There is no effect on any other HANDLER* 
in the list. 

Now that you know how to remove IHEADERs and HANDLERS from their normal places, you need to 
know how to put them back: 

<EVENT ihcadcr> 

If /header was previously disabled or disassociated from its name. EVENT will associate and enable it. 

< HANDLER iheader handler} 

21.3 - 21.4 Interrupts 



The MDL Programming Language 

If rwirf/cr was previously removed from its list. HANDLER will add it to the front of Jfttfatfrr*. IUl of 
actions. Nolo that process cannot be specified. 



21.5. IHEADER and HANDLER (the TYPEs) 

Both n.ese TYPEs are of PRIMTYPE VECTOR, but they do not PRINT that way. sine* they -re seif- 
refereiicing. Instead ihey PRINT as 7 

*/> pe mor.t -inter er-ting-eiement 

The contents of !HEADERs and HANDLERS can be changed by PUT. and the new values will then 
determine (he behavior of MDL. 

Before describing die elements of these TYPEs in detail, here are a picture and a Pattern, both 
purporting m show how diey look: 

'IHEADER [nnmn:oton or which 
disabled? 

"" " > 'HANDLER [*--- > CHANDLER [CHANDLER f 1 

priority] < > + „ 

applicable | applicable 

process] < ♦ process] 

< IHEADER <0R ATOM CHANNEL LOCATIVE> 
COR "'LOSE '#LOSE -1> 
CHANDLER HANDLER <0R HANDLER IHEADER> APPLICABLE PROCESS> 

2L5.I. IHEADER 

The elements of an IHEADER are as follows: 

01 "'"READ- or'-WRITE"? 10 "' " CHANNEL " "" "*'"' h • CHAR "- or LOCATIVE If the name is 

(2) non-Tern if and only if disabled 

(3) first HANDLER, if any. else a zero-length HANDLER 

(4) priority 

If yon lose track of an IHEADER. you can get it via the association: 

For -CHAR" interrupts. <GET channel INTERRUPT returns the IHEADER or #FALSE ( ) if there is 



T 



21.4 - 21.5.1 



Interrupts 















The MDL Programming Language 181 

no association: <EVENT "CHAR" ch*nnel> returns the IHEADER. creating il if there is no 
association. 

For "READ" interrupts. <GET locat>ve READ* -INTERRUPTS> returns the IHEADER or #FALSE () if 
there is no association: <CVENT "READ" localive> returns the IHEADER. creating it if there is 
no association. 

For "WRITE" interrupt*. <GET locative WRITE! -INTERRUPTS> returns the IHEADER or #FAL5E () 
if theic is no association! <tVENT "WRITE" locative> returns the IHEADER. creating it if there 
is no association. 

Otherwise, the IHEADER is PUT on the name ATOM with the indicator INTERRUPT. Thus, for 
example, <GCI CLOCKt -INTERRUPTS INTERRUPT> returns the IHEADER for the clock interrupt or 
• FALSE ( ) if their is no association: <EVENT "CLOCK" 0> returns the IHEADER. creating it if 
there is no association. 

21.5.2. HANDIER 

A HANOLER specifies a particular action for a particular interrupt. The elements of a HANDLER are as 
follows: 

(1) iicm HANDLER if any. else a zero-length HANDLER 

(2) previous HANDLER or the IIIEADCR (Thus the HANDLERS of a given interrupt form a "doubly- 
linkcd list" chaining between each other and back to the IHEADER.) 

(3) handler to be applied (anything APPLICABLE that evaluates its arguments — the application 
is done not by APPLY but by RUNINT. which can take a PROCESS argument: see next line) 

(4) PROCESS in which the handler will be applied, or ^PROCESS 0, meaning whatever PROCESS 
was running when the interrupt occurred (In the former case. RUNINT is applied to the handler 
and its arguments in the currently running PROCESS, which causes an APPLY in the PROCESS 
stored in the HANDLER, which PROCESS must be RESUMABLE. The running PROCESS becomes 
RE5UMABLE, and the stored PROCESS becomes RUNNING, but no other PROCESS variables (for 
example RESUMCR) are changed.) 



21.6. Other SUBRs 

<ON nflmo ppplicfblc priority;tix process which) 
is equivalent to 

21.5.1 - 21.6 Interrupts 



1S2 



The MDL Programming Language 



<HANDLfcR <EVFNT n*me priority which> 
applicable proccss> 




ON is a combination of EVENT and HANDLER: it creates (or finds) (he IHEADER. associates and enables 
.t. adds a HANDLER in the front of the list (first to be performed), and returns the HANDLER. 

<DISADLE theadcr> 

is effeoivcly <PUT iherter 2 # L0 SE -1>. Actually the TYPE LOSE is unimportant, but the -I 
signifies thai ihcpder is disabled. 

<FNABI £ ihe*fter> 

is effectively <PUT ihetder 2 #LOSE 0>. Actually the TYPE LOSE is unimportant, but the 
signifies thai ihe^der is enabled. 



21.7. Priorities and Interrupt Levels 

At any given time there is a defined interrupt level. This is a FIX which determines which 
interrupt- can really interrupt- - that is. cause (he current processing to be suspended while their 
want- are satisfied. Normal, noii-intcrrupt programs operate at an interrupt level of (zero). An 
interrupt is processed at an interrupt level equal to the interrupts priority. 



at 
ch 



21.7.1. Interrupt Processing 

Interrupts "actually" occur only at well-defined points in time: during a call to a Subroutine, or 
critical places Within Subroutines (for example, during each iteration of MAPF on a LIST, whi 
.nay be circular), or while a PROCESS is "BLOCKED- (sec below). No interrupts can occur during 
garbage collerlinn. B 

What actually happens when an enabled interrupt occurs is that the priority of the interrupt i* 
compared with Hie current interrupt level, and the following is done: 

If the priority is greater than the current interrupt level, the current processing is "frozen in its 
tracts and processing of the action(s) specified for that interrupt begin*. 

If the priority is less ihau or equal to the current interrupt level, the interrupt occurrence is queued 
•MM h h ° CCUrrCd " SaVCd awa * for P ro «»i"S when the interrupt level becomes low 

When the processing of an Interrupt'* action* is completed. MDL usually (I) "act* a* if the 



21.6-21.7,1 



Interrupt* 



The MDL Programming Language 



183 



previously-existing interrupt level is restored, and processing continues on what was left off 
(perhaps for no time duration): and (2) "acts as if" any queued interrupt occurrences actually 



recti 



rred right f lien, in their original order of occurrence. 



21-7.2. INT-LEVEL 

The SUBR INT-LEVEL is used to examine and change the current interrupt level directly. 

<INT-LEVEL> 
simply returns the current interrupt level. 

<TNT-LCVCL f/x> 

changes the interrupt level lo its argument and returns the previously -existing interrupt level. 

If INT-LEVEL lowers the interrupt level, it docs not "really" return until all queued occurrences of 
interrupts of priority higher than the target priority have been processed. 

Setting the INT- LEVEL extremely high {for example. <INT-LEVEL <CHTYPE <MIN> FIX») effectively 
disables all interrupts (hut occurrences of enabled Interrupts will still be queued). 

If LISTEN or ERROR is called when the INT-LEVEL is not rero. then the typeout will be 

LISTEMING-AT-LEVEL / PROCESS p INT-LEVEL / 

21.7.3. DISMISS 

DISMISS permits a handler to return an arbitrary value for an arbitrary ACTIVATION at an arbitrary 
interrupt level. The call is as follows: 

<DISM1SS valuc:any activation int- level -Jtx> 

where only the value is required. If activation is omitted, return is to the place interrupted from, and 
value is ignored. If mt -level is omitted, the INT-LEVEL prior to the current interrupt Is restored. 



21.7.1 - 21.7.3 



Interrupts 



184 



The MDL Programming Language 



21.8. -Specific Interrupts 

SrSL^ M ° f ,h *«*««*«rt*J« of P-r.icular "built-in" MDL interrupts follow. Each is named by 
its STRING name, Lxpeci this list to be incomplete yesterday. 



"CHAR" is currently the i 
These different ways will 



n\t emnplex 

be described 
ic words that arrive or depart ai 
a person or another processor. Eacli 



built-in interrupt, because it serves duty in several ways. 

in several different sections. All ways are concerned with 
unpredictable times, because MDL is 
-CHAR- IHEAOER has a CHANNEL for the 



the CHANNEL tells what kinds of "CHAR" 



characters or mach 

communicating wltl 

element that names the interrupt, and the mode of 

interrupts occur in he handled through that IHEADER. 

fl) If the CHANNEL is for input. -CHAR- occurs every time an "interesting" character (see below* 
rJZ?^' 1 fr0 "' " ,e C,,ANMEL '» "•*» terminal, or any character is received from the 
CIWNHl L s pseudo-terminal, or a character or word is received from the CHANNEL'* Network 
M»CkM, or ...deed (ill the ITS version) the operating system generates an interrupt for any 
reason. r J 

('->> If the CHAHNFL is Tor output to a pseudo-terminal or Network socket. "CHAR 

time a Character or word is wanted. 
(3) If .he CHANNEL is for output to a terminal. "CHAR" occurs every time a line-feed character i 



ery 



it or (in the ITS version) the operati 
the terminal. 



itpi 



is 



ng system generates a screen-full interrupt for 



21.8.1. "CHAR" received 



CHARAr d TFB lut u'i 'T" f^™" '""""P 1 °" a real '"-ninal mus, take two arguments: the 

CHARACTER which was typed, and the CHANNEL on which it was typed. 

lit the ITS version, the -interesting" characters are those "enabled for interrupts" on a real terminal 
namely ** through ~G. ~K through -_. and DEL (that is. ASCII codes 0-7. 13-37. and 177 octal). 



in the enrx and Tops-20 versions. ,he operating system can be told which characters typed on a 
terminal should cause this interrupt to occur, by calling the SUBR ACTIVATE-CHARS with a STRING 
axgUUleni containing those characters (no more than six. all with ASCII codes less than 33 octal). If 
ca led will, no argument. ACTIVATE -CHARS returns a STRING containing the characters that currently 
Interrupt. Initially, only ~G. ~s. and ~0 interrupt. 

An initial MDL already has "CHAR- enabled on .INCHAN with priority 8 (eight), the SUBR QUITTER 
for a handler, ro run in -PROCESS (the running PROCESS); this is how - G and ~S are processed. In 
HAumcn' PVCry " r a ,WW C " AHNCL *« 0PENcd in " READ " '»ode to a terminal, a similar IHEAOER and 

rHFAnF^' , 7,'l^m , c d "'"', tfM "*" CHANNEL au, °'" a "«»y* These automatically-generated 
IHEADERs and HANDLERS use the standard machinery, and they can be OISABLEd or OFFed at will. 
Uowcvcr the IHCADCR for . INCHAN should not be OFFed: MDL knows that i is typed only by an 



21-8 - 21.8.1 



Interrupts 






The MDL Programming Language 



185 



^NCHaIT; ""■ ftt,IOWi "« Cnm "'* e iv *" »'«»£' «• be primed ou, whenever a ~Y is lype d on 

<SET H <HANDIFR <GET .INCIIAN INTERRUPT> 
"FUNCTION ((CHAR CHAN) 

*OECL ((VALUE) ANY (CHAR) CHARACTER (CHAN) CHANNEL) 
<AND <*=? .CHAR «\*Y> 

<PRINC - [Some of my best friends are *Ys,l -»)>>s 
'HANDLER *FUNCTION ((CHAR CHAN) ...) ' 

<+ 2 "Y [Some of my best friends are "Ys.] 2>S 

<OFF .B>J 

(•HANDLER #FUNCIION (...) 

dcJicrf "a V'ln'u"'" T' "'*?■ b S ai5 ° cia,cd wil " a » j »P"« CHANNEL open to a Network socket ("NET- 
dev.ce). A handle, gets applied to a NETSTATE array (which sec) and the CHANNEL. 

InouT TWfot! '"ends). An .nterrupt occur* when a character is available For 

hand er C cr V, I >! 1 ?? " P "'^ ** ""* W »* " "»>-"»">■»■ ""errupts. except that a 

5^J5lCK£S — areU " ,e,U ' '"' CHANNEL - P ~*~ te * «« -^available in the 

CHANNEL. 01 "" f ' aVOr ° f ,TS C,,a " ne, lm * m,|>t ' a ha,,d,Cr *«• W"«« «• «* SBC argument, the 
21.8.2. -CHAR- wanted 

dev"icc) AR A \"' Cl ' Upl ea " *• •f 0Bfat « l witU an °"<P»< CHANNEL open to a Network socket ("NET" 
dev.ee). A handler gets apphed to a NETSTATE array (which see) and the CHANNEL. 

"«ds a c a netcr /and M.r n *i ,• An mterrupt occurs when the program at the other end 

21.8.3. -CHAR" for new line 

A handler for u ouipu, "CHAR- interrupt on a real terminal must lake one or two arguments (using 



21.8.1 -21.8.3 



Interrupts 



IS6 



The MDL Programming Language 



"OPTIONAL" nr "TUPLE"): if iwn arguments are supplied by the interrupt system, (hey are the line 
number (FIX) and tike CHANNEL, respectively, and the interrupt is for a line-feed: if only one 
argil in rill is supplied (only in rl.r ITS version), it Is the CHANNEL, and the interrupt is for a full 
terminal screen. Note: the supplied line number comes from the CHANNEL, and it may not be 
accurate if the program alters it in subtle ways, for example, via IMAGE calls or special control 
characters. (The program can compensate by PUTting the proper line number into the CHANNEL.) 

21.8.4. "GC" 

"GC" occurs just after * v *ry garbage collection. Enabling this interrupt is the only way a program 
can know that a garbage collection has occurred. A handler for "GC" takes three arguments. The 
is a n OAT indicating the number of seconds the garbage collection took. The second argument 
FIX indicating the cause of flic garbage collection, as follows (chapter 22): 



first 
is a 



0. Program called GC . 

1. Movable storage was exhausted. 

2. Control stack overflowed. 

3. Top-level LVALs overflowed. 

4. GVAL vector overflowed. 

5. TYPE S'cctor overflowed. 

6. Immovable garbage-collected storage was exhausted. 

7. Internal slack overflowed. 

8. Both control and internal stacks overflowed (rare). 

9. Pure storage was exhausted. 

10. Second, exhaustive garbage collection occurred. 

The third argument is an ATOM indicating what initiated the garbage collection: GC-READ. BLOAT. 
GROW. LIST. VECTOR, SET. SETG. FREEZE. GC. NEWTYPE. PURIFY. PURE-PAGE-LOADER (pure 
storage was exhausted), or INTERRUPT-IIANDLER (stack overflow, unfortunately). 

21.8.5. "OIVrRT-AGC" 

"DIVERT -AGC" ("Automatic Garbage Collection") occurs just before a deferrable garbage collection 
that is needed because of exhausted movable garbage-collected storage. Enabling this interrupt Is 
the only way a program can know that a garbage collection is about to occur. A handler takes two 
arguments: a FIX telling the number of machine words needed and an ATOM telling what initiated 
the garbage collection (see above). If it wishes, a handler can try to prevent a garbage collection by 
calling BLOAT with the TIX argument. If the pending request for garbage-collected storage cannot 
then be satisfied, a garbage collection occurs anyway. AGC-FLAG is SET to T while the handler is 
running, so that new storage requests do not try to cause a garbage collection. 



21.8.3 - 21.8.5 



Interrupts 



•j-|tc MDI. Programming Language 



187 



21-8.6. -CLOCK" 

-CLOCK", when enabled, occurs every half second (the ITS "slow-clock" tick). It Is not available In 
.) lC Tencx nnd Tops-20 versions. It wants handlers which take no arguments. Example: 

<0N "CLOCK" <FUNCTION () <PRINC "TICK "» 1> 

21-8.7- "BLOCKFD" 

"BLOCKED" occurs whenever ai%y_ PROCESS (not only the PROCESS which may be in a HANDLER) starts 
wailing for term trial input: that is. an occurrence indicates that somewhere, somebody did a READ, 
READCMR. NFXiCllR. 1YI. etc. to a terminal. A handler for a "BLOCKED" interrupt should take one 
argument, namely the- PROCESS which started waiting (which will also be the PROCESS in which the 
handler runs, if no specific one is in the HANDLER). 

Example: the following will cause MDL to acquire a * prompting character. 

<OH "BLOCKED" ^FUNCTION ((IGNORE) <PRINC !\">) 5> 

21.8.8. "UNBLOCKED" 

"UNBLOCKED" occur* whenever a S (ESC) is typed on a terminal if a program was hanging and 
waiting for input, or when a TYI call (which see) is satisfied. A handler takes one argument: the 
CHANNEL via which the S or character is input. 

21.8.9. "READ" and "WRIIE" 

"READ" and "WRITE" are associated with read or write references to MDL objects. These interrupts 
are often called "monitors", and enabling the interrupt is often called "monitoring" the associated 
object. A "read reference" to an ATOH's local value includes applying BOUND? or ASSIGNED? to the 
ATOM; similarly for a global value and GASSIGNED?. If the INT-LEVEL is too high when "READ" or 
"WRITE" occurs, an error occurs, because occurrences of these interrupts cannot be queued. 

Monitors are set up with FVFHT or OH. using a locative to the object being monitored as the extra 
which argument, just av a CHANNEL is given for "CHAR". A handler for "READ" takes two arguments: 
the locative and the FRAME of the function application that makes the reference. A handler for 
"WRITE" lakes three arguments: the locative, the new value, and the FRAME. For example: 

<SET A ( 1 2 3)>S 
(1 2 3) 

<SET B <AT .A 2>>S 
K'LOCL Z 



21.8.6 - 21-8.9 



Interrupts 






'*** The MDL Programming Language 

<ON "WRITE- CFUNCTION (OBO VAL FRM) 

*OECL (<VALUE VAL) ANY (OBJ) LOCATIVE (FRM) FRAME) 





<CRLF> 






< PR INC 


"Program changed ■> 




<PR1N1 


.OBJ> 




<PRINC 


■ to "> 




<PRIN1 


-VAL> 




(PR INC 


- via "> 




< PR I N 1 


-FRM> 




<CRLF>> 






1 -B>S 




-HANOI FR 'FUNCTION (...) 




<1 .A 10>* 






( 10 2 3) 






<2 .A 20>S 






Program changed 


*LOCL 2 to 20 via fFRAME PUT 




( 10 20 3) 






<OFF "WRITE" .B>S 




'IHLADER #LOCL 


20 


21.8.10. 


"SYSDOWN" 





"SYSDOWN- occur* when a system-going-down or system-revived signal is received from ITS. It is 
J not available in the Tenex and Tops-20 versions. If no IHEAOER is associated and enabled, m 

warning is primed on (he terminal. A handler takes one argument: a FIX giving the number of 
thirtieth* of a secnuri until the shutdown (-1 for a reprieve). 

21.8.11. -ERROR" 

In an effort in simplify error handling by programs. MDL has a facility allowing errors to be 
handled like Interrupt*. SETGillg ERROR to a user function is a distasteful method, not safe if any 
bugs are around. All "TRR0R" interrupt wants a handler that takes any number of arguments, via 
"TUPLE". When an error occurs, handlers are applied to the FRAME of the ERROR call and the TUPLE 
of ERROR arguments, If a given handler "takes care of the error", it can ERRET with a value from the 
ERROR FRAME, after having done <INT-LEVEL 0>. If no handler takes care of the error, it falls Into 
the normal ERROR. 

If an error occurs at an IHT-LEVEL greaier than or equal to that of the "ERROR- interrupt, real 
ERROR will be called, became "ERROR" interrupts cannot be queued. 



21.8.9 - 21.8.11 Interrupts 






The MDI. Programming Language 



189 



21-8.12. -IPC- 

^US^S^JSKi rc " ivcd on "" ,TS ,pc devi " (chapI " 23 >- " is no ' """ b,e '- 

21. 8.13. "INFERIOR" 

^SnZ^SrSZST, "" inrCri °/ .' TS P"^ h,,em, P 14 t,,e MDL P">~" ■ h «W« available in 

ImL L. i . .7 P ^ A ' m,dICr " k " ° ne "S^cnu a FIX between and 7 inclusive, 

telling which inferior process is interrupting. 

21.8.14. -R1IN1" and "RFAI.T" 

These are not available in the Tencx and Tops-20 versions. 

7SSSm^»!S^!li n ?'" r \~ N " C ° ndi ° f MDL """'"S «""■ 'CPU <"»e> after calling 
l~n"T n * * " C '' re ' Ur " S ,W **«»•"*• -^ »»ndler takes no arguments. If runtime! 

£cu « « r ^AlSr 7* tT."' rC '" rm a FIX ' '" e " UmbCr ° f rU,Mh " e SCCO " dS ,Cft U,,,i ' ,hP ■«««'™Pt 
occurs, or *FAl sr ( ) if the interrupt Is noi going to occur. 







argument, or 'FALSE ( ) if REALTIHER has not been called. 



21. 8.15. "Dangerou*." Interrupt* 




that was being executed at the time. 



aV^.LT''" ! f M ? L ,fi " '° " lMl ilt ' e * Uy Wi1h a " ,/0 *«* A handler must take two 
error a ""-ccelcmem FALSE like one that OPEN might return, and the CHANNEL that got the 

im^ru'J.'T h,U " ,r,,p,i ihm,,d »*?« occur ' ■■ '«* '» <»« Tenex and Tops-20 versions, these 
uterrupts «|way* (CO to the superior operating-syslen. process instead of to MDL. In the ITS 
version, if and when a dangerous" interrupt docs occur: 



21.8.12 -21- 8.15 



Interrupts 



TheMDL Programming Language 

If no IHEADFR is associated will, the inicrrupi. then ihe interrupt goes to the superior 
opei aii ng-sy stem process. 

If an IIIEAOER is associated but disabled, the error DANGER0U5-INTERRUPT-N0T-HANDLED occur* 

(FILC-SYSTEM-ERROR for "IOC"). 
If an IHKADFR i 5 associated And enabled, but the INT-LEVEL Is loo high, the error ATTEHPT-TO- 

DEFER-UNDEFERABLE- INTERRUPT occurs. 

21.9. User.D efiHwl_l_iiicrrii|>t^ (INTERRUPT) 

If the i"trrr„p, „.-, lllP K | vrn ,„ EVENT or 0N i$ y^ onc of „,,. 4Ulldard p rcde fi„ ed interrupts of MDL. 
they w.N gleefully create an ATOM in <INTERRUPTS> and an associated IHEAOER anyway, making the 
assumption lhai you are setting up a "program-defined" interrupt. 

Program-denned interrupt* are made to occur by applying the SUBR INTERRUPT, as in 
< INTERRUPT name *rgj ... j,rgN> 

where n*me U a STRING. ATOM or IIIEAOER, and argi through argN are the arguments wanted by the 
handlers Tor the interrupt. 

-PA, l «?rT,?V PCCmCd hy INTERRUPT *» WWWi* INTERRUPT returns T : otherwise it returns 
i-ALifc . r ) - All the usual priority and queucing rules hold, so that even if INTERRUPT returns T, It 
is possible l hat nothing "really happened" (yet). 

INTERRUPT can also |, C ,,scd to cause "artificial" occurrences of standard predefined MDL interrupts. 

Making a program-defined interrupt occur is similar to calling a handler directly, but there are 
differences. The value returned by a handler is ignored, so side effects must be used in order to 
Communicate information bach ro the caller, other than whether any handler ran or will run. One 
good use for a pro C ra„,.riefined interrupt is to use the priority and qucueing machinery of INT- 
i „"! cn 'l 1 /" 1 ,,,c "'cution of functions that must not run concurrently. For example, if m 

CHAR handler jiiM deposits characters in a buffer, then a function to process the buffered 
chancers should probably run at a higher priority level - to prevent unpredictable changes to the 
ourter during the processing - and it is natural to invoke the processing with INTERRUPT. 

In more exotic applications. INTERRUPT can signal a condition to be handled by an unknown 
number or Independent and nameless- functions. The functions are -nameless- because the caller 
doesil t know the., names, only the name of the interrupt. This programming style is modular and 
evem-dr.ven ,nd .. |» one way of implementing "heuristic" algorithms. In addition, each HANDLER 
has a PROCESS in which to run its handler, and so the different handlers for a given condition can 
RESUME different environments quite easily, with less explicit control than when using 

*'-8.»5 - 21-9 Interrupts 






The MOL Programming Language 



191 



21.10. Wailing for Interrupt* 



21.10.1. HANG 



<IIANG pred> 



suspend* execui.nn. Interrupt inly, without consuming any CPU time, potentially forever. HANG is 
handy for a program that cannot do anything until an interrupt occurs. If the optional prod is 
given, it ,s evaluated vvcry rime an interrupt occurs and is dismissed back into the HANG: if the 
result of evaluation is not FALSE. HANG unhangs and return* it as a value. If pred is not eiven. 
there had better be a named ACTIVATION somewhere to which a handler can return 



21. 10,2. SL1.LP 



<SLEEP timc:f$x-or -float pred> 

suspends exeeutio... intrrruptibly. without consuming any CPU lime, for lime seconds, where limo is 
non-negative, ami thru relums T. prcd is the same as for HANG. 



21.10 - 21.10.2 



Interrupts 



192 

The MDL Programming Language 



Chapter 22. Storage Management 

VrZr*"'", 1 tUU *! , " P,CT CO,nM i0 ,a,e '» »»•»* document is that, except for special case*. MDL 
S^ei{Sir3^r;i?? Vf " J affCC ' S CfficiC " C y (cU >?« r 2-1). This chapter gives some 

The MDI. adrtrr<* space hi divided into five parts, which are usually called 

(1) movable garbage-collected space. 

(2) immovable -.pace (both garbage-collected and not). 

(3) user puip/paqr space, 

{1) pUre-RSIIBR mapping space, and 

(5) Internal Mirage, 

nelV/'cLT.^I Tuir" """' '" C l,ig ' ,C " ;,,,C, IOWCS ' *«*««»« '<» *** "ddress space, and its sire 
«£ III .k ™ •».. r IT"; T " P m " er SpaC " "" Vafy in Si " «*"*»«« loth, needs of the 
•n^elei?,^^ ^7, .? "'* ,,,Icr P'«w ■"«*"« * contiguous set of addresses for each space. 

«<t™ rlw IZ prari,,all > f J IK "P " " pw ob i«» •« created and as disk files are mapped in. The 
aeon taken when a space hrrnmes full varies, as discussed below. F 



22.1. Moya blc Cnrha ge-cnllpcled Storage 

T Z VrlZTc'S l lV S ''''T y " y MDL P ," S "" M " ° bUi " Cd fr °' n " P°" of fr « «"••«• """aged by 

le'tauT'Tun" "the" 'C T l—^'ZT '"•'"•" " " ! "" """"•«" •%«*«* which 1. used by 
"mVZrt .. ,o 1 ' »"«»"««.«'« .n.rk-sw„p- one. because each I. .n independent module that 

It.nptX , sl'u '" ',"" ? !*T"" * ,0 "«' fr °'" «"»» •»•* *■""! B"ba g e coHec.ion. For 
simplicity. ,l„ s doc em .peak* „f -.he" garbage collector, which I,., two algorithm.. 

22 ' 22 -' Storage Management 






I 



The MDL Prograi 



■< Language 



19J 



The garbage collector examine* ihe storage pool and marks all the objects there, separating them 
into twn elates: I hose which cannot possibly be referenced by a program, and those which can. 
The "copying" algorithm then copies the latter into one compact section of the pool, and the 
remainder or the pool is made available for newly constructed objects- The "mark-sweep" algorithm, 
instead, puts all objects in the former class (garbage) into "free lists", where the object-construction 
SUBRs can find ihrni and rc-nse their storage. 

If the rcqueM for more storage still cannot be satisfied from reclaimed storage, the garbage collector 
will attempt to obtain more total storage from the operating system under which MDL runs. (Also, 
if there is a gross superfluity of storage space, the garbage collector will politely return some 
storage to the operating system.) Only when the total system resources are exhausted will you 
finally lose. 



si "forget about" an object, that is. lose all possible means of referencing it. lis 
automatically reclaimed. "Object" in this context includes that stack-structured 



Thus, if you j 
storage area is 
storage space used in PROCFSSes for functional application 



22.1.1. Sta*ks ami Other Internal Vectors 

Control stacks are used in MDL to control the changes in environment caused by calling and 
binding. Each active PR0CC5S has its own control stack. On this stack are stored LVALs for ATOMs; 
PRIMTYPE TUPLE*, which arc otherwise like VECTORs; PRIMTYPE FRAMES, which are generated by 
calling Subroutines: and ACTIVATION*, which are generated by calling FUNCTIONS with named 
ACTIVATIONS. PROG, and REPEAT. TAG and LLOC can make TAGs and LOCDs (respectively) that refer to 
a specific place on a specific control stack. (LEGAL? returns T if and only if the portion of the 
control stack In which its argument is found or to which its argument refers is still active, or if its 
argument doesn't care about the control *tack. The garbage collector may change a non-LEGAL? 
object to TYPE ILLEGAL before reclaiming it.) As the word "stack" implies, things can be put on it 
and removed from It at only one end. called the top. It has a maximum size (or depth), and 
attempting 10 put ton many things on it will cause overflow. A stack is stored like a VECTOR, and 
it must be GROWu if and when it overflows. 

A control stack is actually two stacks in one. One section is used for "top-lever LVALs — those SET 
While the AlOH is not hound by any active Function's argument LIST or Subroutine's SPECIAL 
binding -- and the other section is used for everything else. Either section can overflow, of course- 
The top-lcvel-LVAL section is below the other one. so that a top-level LVAL will be found only If the 
ATOM is not currently bound elsewhere, namely in the other section. 

MDL also has an Internal stack, used for calling and temporary storage within the interpreter and 
compiled program*. It mo is stored like a VECTOR and can overflow. There are other internal 
vectors that can overflow: the "global vector" holds pairs ("slots") of ATOMs and corresponding GVALs 
("globally bound" or GROUND? means that the ATOM in question Is in this vector, whether or not it 
currently has a global value), and the "TYPE vector" holds TYPE names (predefined and NEWTYPEs) and 
how they arc to be treated. 



22.1 - 22.1.1 



Storage Management 



194 



The MDL Programming Language 



r 



22.2. Iminnv.-iblc Storage 

22.2.1. Carbagr-cnllrcted: FREEZE 

bei^r„,ov';, i ; , v C , i r ,,,nM , a " C "" V, ,C " " d * hu ** in 8 RSUBRs. you may need to prevent an object from 

STRING BYTEs'n Xp'lf ^.TSXff """ ■*■» ™" «*■"»« "• of PRIMTVPE VECTOR. ivECTOR. 

' •" BYT ES or TUPLE. It cnp.es .1* argument into non-moving Garbage-collected soace FHFF7F 

returns ,I.c copy CMTYPEd ,n its PRIMTVPE. except in the case of/Wp^K.^^^" 

22.2.2. Noil -garbage-collected! storage (Hie PR!mtype( 

S." i a b I waU°L r: ! t ! N , , y ,t , S, ° KAGt , •" r "" y I frD "" UVECT0R Wh ° SC UTYPE »• of WWTYPE WORD, but 
of FRFFtV , i / i r: U,,,, " , S impr " al <° MDL and thus is never garbage-collectible. The us* 

of FREEZE ,s always preferable, except when for historical reason* a STORAGE is necessary. 

22.3. Other Storage 

size I v ,lV, ,' in " '. ,>,f r W V ' C, ° r - Thii ipaCC h " ,e "X^ 1 vulnerable to being compressed 

in size by the long-term growil, of other spaces. S cumpressca 

Jb.rable HEFtZ? b0 '" pMrC * nd hn "" rC "■"* T "< "—prcier program itse.f is pure and 
an i ... tial MDL. along with thcir OBLIST buckets (LISTs) and GVAL slots (a pure extension of the 



22.2 - 22.3 



Storage Management 



The MDL Programming Language 



195 



92.4. Garbage Cnllrclion: Details 

When cither of ihe garbage-collected spaces (movable or immovable) becomes Full. MDL goes 
through the following procedure: 



ERT-AGC" interrupt occurs if the garbage collection can be deferred temporarily by 
itudaries between storage spaces slightly. The interrupt handler may postpone a garbage 

V IlinvilM' llfVli lliLir K", itself will) S rill (n RI HOT fUftr,K,,\ 



(I) A "DIVERT-AGC" 

shifting boi 

colicction by moving boundaries itself with a call to BLOAT (below). 



(2) The garbage collector begins execution. The "copying" algorithm creates an inferior operating- 
system process (named ACC in the ITS version) whose address space is used to hold the new copies of 
noil 'garbage object*. MIH. gains access to the inferior's address space through two pages ("frontier" 
and "window") in its internal space that xre shared with the Inferior. If the garbage colicction 
occurred because movable garbage-collected space was exhausted, then the "mark-sweep" algorithm 
might be used instead (see below), and no inferior process is created. 

(3) The garbage collector marks all ohjecis that can possibly be referenced hereafter. It begins with 
the <MAIN> PROCESS and the currently running PROCESS <ME>, considered as vectors containing the 
control stacks. ol» ject pointers in live registers, etc. Every object in these "PROCESS vectors" is 
marked "accessible", ami every element of these objects (bindings, etc.). and so on recursively. The 
"copying" algoriihm moves nbjecis into the inferior process's address space as it marks them. 

(4) If the garbage collection is "exhaustive" -- which is possible only in the "copying" algorithm - 
then both the chain of associations and top-level local/global bindings are examined thoroughly, 
which takes more time but is more likely to uncover garbage therein. In a normal garbage 
collection these constructs aie not treated specially. 

(5) Finally, the "mark-swrrp" algorithm sweeps through the storage space, adding unmarked objects 
to the internal Tree lists for later re-use. The "copying" algorithm maps the inferior process's 
address space into MDL's own, replacing old garbagey storage with the new compact storage, and 
the inferior process is destroyed. 



22.5. GC 



<GC nun:fix cvh?;false~or-any ms-rrC(j.*/»V> 



causes the garbage collector to run and returns the total number of words of storage reclaimed. All 
of its arguments are optional: if they are not supplied, a call to GC simply causes 
garbage collection. 



a copying 



If mm is explicitly supplied as an argument, a garbage-collection parameter is changed permanently 
before the garbage collector runs, min is the smallest number of words of "free" (unclaimed. 



224 - 225 



Storage Management 



196 



The MDL Programming; Language 



"Tl/trl tl*t 'r OV "" e P^^Tl 1 '?? storage the garbage collector will be «tisfied with 
Zl .. Z. ' ." T.!** ""' C ' '"A"'"* « »« 8I92 *ort»- »f «»>«■ 'o.al amount of reclaimed 



available fm use 
hav 

storage is les* tl 




U^U^^n^-Z^y^ 7 "-rl-Mveep- algorithm should be used hereafter for every 

IweL" ' ni™ 7 . J2? Pi i,l?0n """ * l,icd - Civi "g ° f « *«-fr*«7 »'«ns never to use the -.nark- 

: ■ 2K2Sj ;,:; s con , ; ig H , ? <M|N> f ix> means «*«*■* ■«»*** »• »* i«. **. -marl 

3^*1^|^J^^2? r * b 5' ."■" P roc " ior *«• 'hat. the "copying- algorithm, but it never 
rarely changes, but objects are creaicd and thrown away continuously. 



22.6, BLOAT 




necessary.) 



A call to Bl OAT lonls like this: 

< BLOAT fre s/A Id S lb typ sto pslk 

min plrf p& //j p f yp j mp pur dpzlk dslK> 

7ouZu!l" Sm " n,S " "" firi ' HM ab ° Ve '" FIX> ° P,i0,,aI <° hy ***"** * nd "»»«<* *■ 



22.5 - 22.6 



Storage Management 



The MDL Programming Language 



197 



frtfi number of words of free movable storage desired (for LIST*. VECTORS. ATOMs. eic.) 

elk: number of words of free control-slack space desired (for functional applications and 

binding of atoms) 

Id: number of new top-level LVALs for which to leave space (SETs of ATOMs which are nol 
currently bound) 

glbi number of new GVALs for which lo leave space (in the global vector) 

fyp: number <»f new TYPE definitions for which to leave space (in the TYPE vector) 

s/o: number of words or immovable garbage-collected storage desired 

patta number of words Of free inicrnal-siack space desired (for REAOing large STRINGS, and 
calling routine* within ihc interpreter and compiled programs) 

Arguments on the second line above are also FIX and optional, but they set earbage-collection 
parameters permanently, as follow*: 

mirr. as for GC 

plch number of slois for LVALs added when the space for top-level LVALs is expanded (initially 

pglb: number of slots for GVALs added when the global vector is grown (initially 64) 

pt>p: number of slots for TYPCs added when the TYPE vector is grown (initially 32) 

"npt number of words of immovable garbage-collected storage added when it is expanded 
(initially 1024) 

pun number of words reserved for pure compiled programs, if possible (initially 0) 

dp-.th: most desirable site for the internal stack, lo prevent repeated shrinking and GROWing 
(initially 512) * s 

dslh: most desirable sire for (he control stack (initially 4096) 

BLOAT returns the actual number of words or free movable garbage-collected storage available when 
it is done. 



22.6 



Storage Management 



The MDL Programming Language 
22.7. 3L OA r-S T A T 
8L0AT-STAT call be used with BLOAT to -fune" the garbage collector to particular proeram 

■ '.■. |tlll ■...■■.■ . r r * 

<UL0AT-S1*AT l#r>slt'-??njveclor> 

l[\lVJ^ '" " :l ' i,,rrttmi " io » *1»UI '».e stale of storage Of MDL. The argument should be a 

n?,rA, F,' 1 ' ? ?" d UTYPE FIX " If BL0AT -S7AT does no. get an argument, it will provide its 
own UVCcroR. I he ii.fnrtn.inoh returned is as follows: the first S elements indicate the number of 
garbage cnHrrnnii. thai arc attributable to certain causes, and the other 19 give information about 
certain areas of Morale. In detail: 

I. number of garbage collections caused by exhaustion of movable garbage-collected storage 
Z. dnro by ovcrflnu nf control :,m,i - s > 

3. ditto l>v overflow nf tnp-lcvel-LVAl section of control stacfc(s) 

4. ditto by OS" erf low nf glnu.il vector 
3. ditto by overflow nf IVPC vector 

G. diiro iiy exhausfinn of Immovable garbage-collected storage 

7. ditto by overflow of internal stack 

8. ditto by overflow of both Macks at the same lime (rare) 

9. number of words of movable storage 

10. number of words nf movable storage used since last BLOAT-STAT 

II. maximum number of word", of movable storage ever existing 

12. number of worrit of movable storage used since MDL began running 

13. maximum *i/c of control stack 

14. number of word-, on control stack in use 

15. maxim n m size of control »ack(s» ever reached 

16. number or slot* ror top. level lval* 

17. number of top-level LVAIs existing 

18. number of *|u|« f ( , r GVALs in global vector 

19. number nf gvals exist Ins 

20. number of slots for rYpr\ | n type vector 

21. number of TYPEs existing 

22. number of words nf immovable garbage-collected storage 

23. number of words of Immovable storage unused 

24. si/.e of largest unused contiguous immovable-storage block 

25. number nf words on internal slack 

26. number of words on internal Mack in use 

27. maximum sire of internal stack ever reached 



- 2 - 7 Storage Management 



The MDI. Pi >',. i .1 in in i m; Language 



199 



22-8. GC-HON 

<GC-r»ON prcd> 

rgarhn C r-collrctnr u.omior") determines whether or not the interpreter will hereafter print 
Information on the terminal when a garbage collection start* and finishes, according to whether or 
not .is argument -s true. || returns the previous state- Calling it with no argument returns the 
current stale, riic initial state is false. 

When typing is enabled, the "copying" garbage collector prints, when it starts: 

GIN reason subr~lrn»l~cauGed:atom 
and. when it finishes: 

GOUT seconds- needed 

The "mark-sweep" garbage collector prints MSGIN and MSGOUT instead of GIN and GOUT. 

22.9. R elated S iilirim i i n^ 

Two SUBRs. described next, use only part of the garbage-collector algorithm, in order to find all 
Pointer* to an object. fiC-DIJMP and GC-READ. as their names imply, also use part in order to 
translate between MDI. objects and binary representations thereof. 

22.9.1. SUBSTITUTE 

SUBSTITUTE new.vny otd:any> 

returns old, after causing a miniature garbage collection to occur, during which all references to old 
arc changed so as to refer to new. Neither argument can be of PRIMTYPE STRING or BYTES or LOCD 
or live on I I he mm ml stack, unless both are of the same PRIMTYPE. One TYPE name cannot be 
substituted for another. One of the few legitimate uses for it is to substitute the "right" ATOM for 
the wrong one. after OBI ISTs have been in the wrong state. This is more or less the way ATOMs are 
• "purified. It is also useful for Unlinking RSUBRs. SUBSTITUTE returns old as a favor: unless you 
nang onto old at that point, it will be garbage. 



22.9.2. PURIFY 

<PURIFY any-l 



any-N> 



22.8 - 22.9.2 



Storage Management 



The MDL Programming Language 

ZelZlJ!? h?^." 5 """"'- •"? CaUSi " S 3 mi " i » ,u " 8«*»»ge collection thai results in all the 

b«w«? « * « k ° r bC ° f PRIMTYPE PROCESS or LOCO or ASOC . Sharine 

RESTOREd 7 mi "W™ P We "» »««'* «««« after a SAVE, if and when the SAVE n,e £ 



22.9.2 



Storage Management 



The MDL Programming Language 



201 



Chapter- 23. MDL as a System Process 

fa£^MS£^ considered as executing in an operating-system process, and interaction. 

between MDL .md o.l.cr operating-system processes. See also section 21.8.13 



23.1. TIME 

TIME takes a 

the number 

inacl.inc-lcvcl debugging to examine the * 

(say. DDT> plant a breakpoint in the code for TIME. 



nf Z . < ?"" ,C " ,S ' lCU T cva,UJ,tpd but *•">«*■ *»«* returns a FLOAT giving 
-...,.? CPU ume the MDL process has used so far. TIME is often used in 

,n,g to examine the values of its arguments, by having MDLs superior process 
for TIME. 



23.2. Nainr* 

<UNAME> 



■e in the ITS vers.on and the logged-in directory in the Tenex and Tops-20 versions. 



<XUHAME> 



variable in the ITS version aud identical to <UNAME> in the Tenex and Tops-20 versions. 



<»1NAMF.> 



belong IO r ; Sa^SV? " CTNM " a,Ue * " ,C Te ' ieX a " d T ° PS - 20 ****"*• The characte, 

<ASCH -137-> ■ ,c - Panting subset of ASCII, namely those between <ASCII «40*> an 



rol 

ers 

d 



<XJNAME> 



23 - 23.2 



MDL as a System Process 



202 



The MDL Programming Language 



23.3. Exit s 

< LOGOUT > 

re^ur..^ if ,' r..M,„ng 6i»w„ed or as a daemon. If it succeeds, it of 

returns. If ii cloos nor. n returns #FALSE {). 



course never 



<0UIT> 



causes Mill. 



to slop running. In an orderly manner. In the ITS version, it is equivalent to 

and cc Vurll ^ZfT **"** *"* T ° P5 - 2 ° V " Si °"*- H U •W-S to a 

and conirnl paste* lo ihe superior process. 

<VALRr_T »teins-or-fhr> 



control-C signal. 



&h7SSi"J TZSZZfZ """"."■ ,f " d0Ci re,ur "- " ,e va,u ' is '™ lse «>• » *« 



23.4. Inicr-proccss Coiiimnni 



r .11 ion 



All of the SUBRs hi this section are available only in the ITS version. 

Mteftto m^SS^i C , 0m,m "! ica,ion "' "«"* '« l«*fH as an I/O device by ITS but not 

proces es by nc IT n'f «> Hil" '\" CV " ° PENcd * »'"»» MDL to communicate with other ITS 

23.4.1. SEND and SEND-VAIT 

<SEND olhrrnl othcrnZ body type mynimel mynsme2> 



23.2 - 23.4.1 



MDL as a System Process 



The MDL Programming Language 20J 

<SENO-WAII Othcrnl olherng body typo mynamel myn*meZ> 

boil. smcl am IPC ,.,e«agc 10 any process ll.a. is listening for it as othernl othernZ. body must be 
either a STRING, or.-, UVF C10R of objects of PRIMTVPE WORD, type is a,, optional FIX. by default 
which .s pan of ,he Information the other guy receives. The last two arguments are from whom the 
message is to be «nt. These are optional, and <UNAME> and <JNAHE> respectively are used by 
default. SFND return* a TALSF if no one is listening, while SEND-WAIT hangs until someone wants if. 
Both return T if .someone accepts the message. 

23.4.2. The -IPC" Interrupt 

When your MDL process receives an IPC message. -IPC- occurs (chapter 21). A handler is called 
with cither four or mn arguments gleaned from the received message, body. type, othernl. and 

t^>'ZfX£?*' 4 ' ™ e ' a,,d myn *«** are supp,icd °" ly if tUey arc ,l0 ' ■"* *"*"* 

Ipnrr^ 3 .'"" 1 ^" "*"*** r ° f tb * " IPC " i»««rupt. with a handler named IPC-HANDLER and in the 
PROCESS Mot. The handler pr.nl, out on the terminal the body, whom it is from, the type if not 0, 
and whom lr is lo If no, <UNAME> <0NAME>. If the type is 1 and the body is a STRING, then, after 
the message Information is printed out. the STRING is PARSEd and EUALuated. 

23.4.3. IPC-OFF 

<IPC-OFF> slops all listening on the IPC device. 

23.4.4. IPC-ON 

< I PC -ON mynpmrl mynamc2> 

£<MM» %re* wT ""' iCC " """""" my "' me! - " "° "*—— '" Provided. ii„ening u 

oihunahe> CJNAMO. When a message arrives. ■ IPC" occurs. 

MDL is initially listening as <UNAME> <JNAME> with the built-in HANDLER set up on the -IPC" 
interrupt with a priority of I . 



23.4.5. DEMSIG 

<DCM5IG d**omon:string> 

"ow a n , re!uin. (d T r i t r C, ,! > '" T I*" !!2 ,PC t?** tU * 1 "" dae, "°" named ^ i,s "Ifu.nent «houId run 
»«w. it reiuins T if the daemon exists. #FALSE () otherwise. 

23.4.1 - 23.4.5 MDL as a System Process 



204 



The MDL Programming Language 



Chapter 24. Efficiency and Tasteful 



ness 



24.1. F.ffici 



rue ■> 



Zu*^!?;J7 "'^ 1w L rt "* ram » rfW^eirt by thinking hard about what they really make the 
interpreter ■& a„d mafclttg ,„,,„ Uo le „. Sonu? gui(Ie , i( , CSi f„ ordrr of decreaiing J^JJJ m * k * th ' 

(1) Free slnrngr is expensive. 

(2) Calling function* is expensive. 

<3> PROG and REPEAT are expensive, except when compiled. 

Explanation: 
- a , v (0 ..._ if _ . * *./ , y ' " ,P " ,aI ,'* evaluated, it creates a new one-element LIST: it is too 



and for 



2L!!t? « ■ l " IPa I " CVer " rfr " ar >" Siven (a) MUX- in FUNCTIONS: <b> the fact that FUNCTIONS can 
a hnma,, *"""' '° **»* """"*> " CCdcd for *«■■* "»»** «P «• interacting with 

I^^nI r « R f|f.r M ^ ^ " Vr *" iib,C W " C " " ,C n0rnWl f,0W ° f comro1 can be c "> *"*" by unusual 
condition*, so roa, „,e program want, to RETURN before reaching the end of the PROG. Of course! 



24 - 24.1 



Efficiency and Tastefulness 






The MDL Programming Language 



205 



nested CONIM can accomplish the same end. but deep nesting may tend to make the program 
unreadable. For example: 



<PR0C- (UUP) 

<OR <SFT TFMP <OK-F0R-STEP-l?>> 

<RETURN .TEMP>> 
<STEP-I> 
<0R <SET TEMP <0K-F0R-STEP-2?» 

<RETUHN .IEHP» 
<SlEP-2» 



could instead be written 



<C0ND <<OK-F0R-STEP-l?> 
<STCP-1> 

<C0ND (<0K-F0R-STEP-2?> 
<STEP-2>)>)> 



By the way. REPEAT is faster than GO in a PROG. The <G0 x> FORM has to be separately interpreted. 
right? Iii fact, if yon organize thing* properly you very seldom need a GO; using GO is generally 
considered "had style", but in some cases it's needed. Very few. 



In in 
form 



whicl 



any cases, a REPEAT can be replaced with a MAPF or MAPR, or an ILIST. IVECTOR. etc of the 

<ILIST .N '<5ET X <♦ .X 1» 

i generates an M-elemcul t.IST of successive numbers starting at X+l. 

Whether a program i* interpreted or compiled, the first two considerations mentioned above hold: 
garbage collection and function calling remain expensive. Garbage collection is. clearly, exactly the 
same. Function calling is relatively more expensive. However, the compiler careth not whether you 
use REPEAT. GO. PROG. ILIST. MAPF . or whatnot: it all gets compiled into practically the same 
thing. However, the REPEAT or PROG will be slower if it has an ACTIVATION that is SPECIAL or used 
other than hy RETURN or AGAIN. 



24.1.1. Example 

There follow* an example of a FUNCTION that does many things wrong. It is accompanied by 
commentary, and two better versions of the same thing. (This function actually occurred in 
practice. Needless to say. names arc withheld to protect the guilty.) 

Blunt comment: this l« terrible. Its purpose is to output the characters needed by a graphics 



24.1 -24.1.1 



Efficiency and Tastefulness 



206 



The MOL Programming Language 



-re returned |„ n | T.ST by £ f.n.Cin" tra^S "** "V" 1 "* T " C "'"" ch ""'<" «* each line 

<DEFINE PLOTVDSK (X Y CHN "AUX- L LIST) 

<CO»D <<NOT < = 3? < SET I < LENGTH . X »<L£NGTH . Y> » 

<ERROR -LENGTHS NOT EQUAL">)> 
<SET LIST (29)> 
<REPEAT ((N 1>) 

<SET LIST CI.LIST J < TRANS <-N .X> <.N .Y»» 

<REPEAT ((N 1) (LI <LENGTH .LIST>)> 
<PRINC <ASCII <.N .LIST» .CHN> 
<COND (<G? <SET N <+ .N I» . L l> 
<RETURN -DONE->)> » 

Com moil ts: 

ft) LIS, „ «,,„, ,„„„„„,„,, „ ccesiary „ „ juM crMtcd ^^ i|fn iirown ^ 

hZSZS" " " ' '- UST ' <TMH5 -^Safite .... previous «„„ cmt „, LIST ev „ y ,„„ „ 

(3) Indexing do,,.,, ,iic Ptemeilll of LISI as in < n i jcti i„l.. i 

-•> or <„...> 1% ,,„, lvnr ,„ ^i,' ' 'Sr'' 'f .'- LIST is long. <3 

Even T ,„, lmtnHm wwe „„, „,_„ * fc , |ic comp <- wou > £ J^^^S^ •*■* 

M) Th. v.rtabl, CHN ccc„» ry if OU.CHAN is bound ■„ lh . argumen, CHANNEL. 

- ERR C,S OBL.S, <„ on. is propria,,, IO LSEK^^tt.S-«-^ 
So. do it Mils way: 



24.1.1 



Efficiency and Tasteful 



"CSS 



The MDI. Progr.iiiiM.iiic Language 

207 

<0FFlNf PiOTVDSK (X Y OUTCHAN) 

">tCL ((OIITCIIAN) <SPECJAL CHANNELS 

<COND « H0 T <«? LENGTH .X> < LE NGTH , Y >» 

<rni N c S 5r W<W8,4> * plotvdsk>,> 

<REPfAT (J 

<COND <<EMPTY? .X> <R£TURN "OONE->» 
<REPEAT ((OL <TRAMS <1 .X> <1 .Y»)) 
<PRINC <ASCII <1 .0L>» 
<CON0 «EMPTY? <SEI OL <RESI .0L»> 
<RETURN>)>> 
<5ET X <REST .X» 

<SET Y <REST .Y»» 

<OEFINE PLOTVOSK (X Y OUTCHAN) 

"»ICL ((OUTCHAN) <SPECIAL CHANNELS 

<COND (<NOT < fi=? <LENGTH .X> <LENGTH .Y»> 

<PRINC < ^;j R ^« TOR -«NGTHS.DIFFER..ERRORS PLOTVDS K »> 
<MAPF <> 

'FUNCTION ((XE YE) 

<«APF <> FUNCTION «T, < PRINC <A S CII .T») ORANS .XE .YE»> 

• Y> 
"DONE"> 

24.2. Cre a Ij ygj, jj s iMFOfWid Owfa- 

li you iiiiim rrr.ur the clement* n f -> i »t • 

sees ,:\& s : ywru: cS£r? a — - " mut-aS 



411 ' 2CS Efficiency and Tastefulneu 



208 

The MDL Programming Language 



<«PEAT ((FIRST (T» (LAST .FIRST, .. , 

*0ECL ((VALUE FIRST LAST) LIST . . . , 

<SET LAST <R ESr <PUTREST .LAST < .NEW,»> 
<RETURN <REST .FIR S T» 

^,,r:js;srt»- r: ,: ; ;«~ :; «.^ !t ._ r ,, : . ( _„ 

2_4.3. Rp.Tl-n.,i r f.y rr y lr j I | 1 , ll 

I" Ihr in.rrprrrrr the ««,,,„,« .X X X X < . 
?4-5. Making Offwc for Array , 

.... -a .... nsvcs Wje'bSSbSsSkS 

24-2-24.5 Ff ,. . 

Efficiency and Tastefulne** 



The MOl. Programming Language 



209 



interpreter and ll.c compiler will be happier with <SETG n*me offsat> rather than <DEFINE 
("TUPLE" T) <offset !,T>>. 



nmmc 



'24.6. Tables 



There are several ways 
be searched. Umurpri* 
the nature of the (names a 



i MOL to store a table, thai is. a collection of (names and) values that will 
gly. choosing the best way is often dictated by the size of the table and/or 
d> values. 



For ■ Mlinll table, the ii.m.r* and values can be put in (separate) structures -- the choice of LIST or 
array being determined by volatility and limiiability - which are searched using MEMQ or MEMBER. 
This method i, very space-efficient. If the table gets larger, and if the elements are completely 
orderahlr. a (uniform) vector can be used, kept sorted, and searched with a binary search 



For 
bes 



a lar C e table, where reasonably efficient searches are required, a hashing scheme Is probably 
t. Two methods arc available in MDL: associations and OBLISTs. 

in the firM method. PUTPROP and GETPROP are used, which are very fast. The number of hashing 
duckets .s f.xcd. Duplicates are eliminated by «7 testing. If it is necessary to use =? testing, or to 
find all the entries in the table, yon can duplicate the table in a LIST or array, to be used only for 



those purposes 



In the second 



.c.hnd. INSERT and LOOKUP on a specially-built OBLIST are used. (If the name* are 
not STRINGS, they can he converted to STRINGS using UNPARSE. which takes a little time.) The 

IIIh ' MAOvm" 8 l ".' ClC,i "" " e cl,OWn f ° r b " f ■«**"** Duplicates are eliminated by -? 

testing. MAI'f/R can be used to find all the entries in the table. 



2-1.7. Nesting 

The beauty of deeply. nested control structures in a single FUNCTION is definitely in the eye of the 
beholder (PPRINT. a pre-loaded RSUBR. finds them trying. However, the compiler often produce, 
better code from them.) If you don't like excessive nesting, then you will agree that 



<SFT X . . .> 
<C0ND (<0? .X> 



-.) ...> 



looks better than 



<COND (<0? <SET X ...>> ...) ...> 



and that 



2-1.5 - 24.7 



Efficiency and Tastefulness 



210 



TheMDL Programming Language 



<REPEAT ... 

<CONI> ... 

( -- - <RETURN ...>>> 



. . .> 



looks better than 



<REPEAT ... 

<COND . . . 

( - . - <RETURN . . .>) 
(ELSE ...)> 
. ..> 



Vou „„ „ „., „ a ,„ rr „r ,„c choice*. Nes.ing „ *,i„ . nd .„ bmtl ,„,„ ^ 



The MDL Programming Language 



211 



Appendix 1. A Look Inside 

Tills appendix tells about flic mapping between MDL objects and PDP-IO storage -- in other words, 
tl.e way tiling* look "on tlir inside". None or this information is essential to knowing how »o 
program in MDL. but it doe* give some reasons for capabilities and restrictions that otherwise you 
have to memorize. The notation and terminology get a Utile awkward in this discussion, because we 
are ill a twilight /n., c between the worlds of MDL objects and of bit patterns. In general the words 
and phrases appearing in diagrams refer to bit patterns not MDL objects- A lower-case word (like 
"tuple") refers to the storage occupied by an object of the corresponding PRIMTYPE (like TUPLE). 

First some terminology nerds discussion. The sine qua non of any MDL object is a pair of 36-bit 
computer words, In general, lists consist of pairs chained together by pointers (addresses), and 
vectors consist of contiguous blocks of pairs. ==? essentially tests two pairs to see whether they 
contain the same hit patterns. 

The firM (lower-.ldtlressed) word of a pair is called the TYPE word , because it contains a numeric 
TYPE cod e that represents the object's TYPE. The second (higher-addressed) word of a pair is called 
the value word , because it contains (part of or the beginning of) the "data part" of the object. The 
TYPE word (and sometime* the value word) is considered to be made of a left half and a right half. 
We will picture a pair like this: 

I fYPF | | 

• | 

I value I 



where a vertical bar in ihe middle of a word means the word's halves are used Independently. You 
can see il.at the TYPE code is confined to the left half of the TYPE word. (Half-)words are sometimes 
subdivided Into fields appropriate for the context: fields are also pictured as separated by vertical 
bars. The right hair of n,e 1YPF word is used for different purposes depending on the TYPE of the 
object and actual location of Die value. 

Actually the 18-hit TYPI field is further decoded. The high-order (leftmost) bit is the mark bit. used 
exclusively by the garbage collector when it runs. The next two bits are monitor bits, used to cause 
READ" and "URITE" interrupts on read and write references to the pair. The next bit is used to 
differentiate between list elements and vector dope words. The next bit is unused but could be used 
in the future for an "execute" monitor. The remaining 13 bits specify the actual TYPE code. What 
chtype does is to copy the pair and put a new TYPE code in the new pair. 

Each data TYPE (predefined and (UWTYPEs) must belong to one of about 25 "storage allocation 
classes" (roughly corresponding to MDL PRIMTYPEs). These classes are characterized primarily by 
which the garbage collector treats them. Some of these classes will now be described. 



c 
(he in 



liter 



Appendix 



212 

The MDL Programming Language 

"One Word" 



I FIX | o I 

J i 

105 i 



"Two Word" 



re 



LIST | o | 
I 



I ° I pointer 



'wo N Word' 



(LENGTH! K ft-If ,|,a, mm he • « ,VJ «?i ■ i«l«ClionJ Th. number of pair* in the block 

PRIMTYPE VECTOR FxZp.r? ** * T " W-4 ' A " "*"""' TYPEl in < his "*" •« of 



I VECTOR | o I 

' | 

I -2*lennth | pointer 



where length is I lie LENGTH of Ibe 



SS-'S'S NT^^I'^n'^^^r ~ " "" «~"» - - — C,H. e,™ 



Appendix 1 









The MDl- Programming language 



2IS 



"N Wort!" 

This class is lilt" s.iiue as ilic previous our. except that ihe block contains objects all of the same 
TYPE wiilmtii individual TYPE words. The TYPE code for all the elements is in vector dope words, 
which are HI addresses just larger than the block itself. Thus, any object that carries information in 
its TYPE word cannot go in the block: PRIMTYPEs STRING, BYTES, TUPLE (and the corresponding 
locatives LOCS. I.QCB. LOCA). FRAME, and LOCD. All external TYPEs in this class are of PRIHTYPE 
UVEC I OK . Example: 



LIVE CI OR 



- length 



pointer 



where length is ihe LENGTH nf the UVECTOR and pointer points to the beginning of the UVECTOR. 

"Byte String" and "Character String" 

These two elates are almost identical nytc strings are byte pointers to strings of arbitrary-size 
bytes. PRIHTYPE BYTES is the only member of (his class. Character strings are byte pointers to 
strings nf ASCII characters. PRIM type STRING is the only member of this class. Both of these 
classes consiM of a Inigth and a PIHMO byte pointer. In the case of character strings, the byte-size 
field in ihe byte pointer H always seven hits per byte (hence five bytes per word). Example: 

I STRING | length | 

I bylc-pointor | 

where length Is the LENGTH of the STRING (in bytes) and byte-pointer points to a byte just before 
the beginning of the string (an ILDB instruction is needed to gel the first byte). A newly -created 
STRING always has •010700" in the left half of byte-pointer. Unless the string was created by 
SPNAMC, byto-pnintor points to a uvector. where the elements (characters) of the STRING are stored, 
packed together five to a word. 

"Frame" 

This class gives the user program a handle on its control and variable-reference structures. All 
external TYnrs in this class are of PRIHTYPE FRAME. Three numbers are needed 10 designate a frame: 
a unique 18-bit Identifying number, a pointer to the frame's storage on a control stack, and a 
pointer to the PROCESS associated with the frame. Example: 



Appendix 1 






?M The MDL Programming Language 



1 FRAME |PROCESS-potnter| 

I - - I 

I unique-id | frane-pointer | 



where PROcrsS-nointer points to the dope words of a PROCESS vector, and unique-id i» used For 
Validating (testing LEGAL?) the frane-pointer, which points to a frame for some Subroutine call 
on the roniml stack. 

"Tuple" 

A tuple pointer is a counting poiuicr to a vector on the control stack. It may be a pointer 10 the 
arguments to a Subroutine or a pointer generated by the "TUPLE - declaration in a FUNCTION. Like 
object*. In iIip prrvintis Has*, these objects contain a unique identifying number used for validation. 
PRIMTYPE TUPLE is Ihe only member of till* clasi. Example: 

I TUPLE | unique-Id | 

I - I 

I -ZMenrjth | pointer | 



Other Storage Clav-.es 

The rest of the storage classes include strictly internal TYPEs and pointers to special kinds of lists 
and vectors like locatives. ATOM* and ASOCs. A pair for any LOCATIVE except a LOCD looks like a 
pair for the roriespondinr; structure, except of course that the TYPE is different. A LOCO pair looks 
like a tuple pair and needs a word and a half for its value; the unique-id refers to a binding on the 
control siacl. nr to the "global stack" if zero. Thus LOCOs are in a sense "stack objects* and are more 
restricted than oilier locatives. 

An OFFSFT is stored with the INOr.X in the right half of the value word and the Pattern in the left 
half. Since the Pailern can be either an ATOM or a FORM, the left half actually points to a pair, 
which points to the actual Pattern. The Pattern ANY is recognized as a special case: the left-half 
pointer is zero, and no pair is used- Thus, if you're making the production version of your program 
and want in save some storage, you can do something like <SETG FOO <PUT-OECL , FOO ANY>> for 
all OFFSETS. 



Appendix I 



The MDL Programming Language 



215 



Basic Data Structures 



Lists 



List clcmci 
terminated 
like I Ills: 



its arc pair* linked together by the right halves of their first words. The list is 
iiy a rero in the right half of the last pair. For example the LIST (12 3) would look 



| LIS! | I 



>| FIX I — 
I I 



>| FIX | >| FIX | | 

I I I I 

12 1 I3| 



The use of pointers m tie together elements explains why new elements can be added easily to a list, 
how sharing and circularity wnrk. etc. The links go in only one direction through the list, which is 
why a list cannot be BACKcd or TOPped: there's no way to find the RESTed elements. 

Since somr MDI. values require a word and a half for the value in the pair, they do not fit directly 
into list elements. This problem is solved by having "deferred pointers". Instead of putting the 
datum directly into the list element, a pointer to another pair is used as the value with the special 
internal TYPC DCFLR, and Ihc real datum is put in the deferred pair. For example the LIST (1 
-he 1 la" 3) would look like this: 



1 LIST 

I " - - 



>[ FIX | — 

I I 

I 1 I 



>|DEFER| >| FIX | 1 

| | ( | 

I I 3 I 

I 

I 
I 

ISTRING1 5|<- 

1 I 

(byto-pntrl 



Appendix I 



216 



Vector* 



The MDL Programming Language 



A vecior is a block of contiguous words. More than one pair can poini to the block, possibly at 
different places in the block: this is how sharing occurs among vectors. Pointers that are different 
arise from REST or GROW/BACK operations. The block is Followed by two "dope words", at addresses 
just larger than the largest address in the block. Dope words have the following format: 



typo 



Qrow 



length 



gc 



The various fields have the following meanings: 

typo -- The fourih bit from the left (the "vector bit". 40000 octal) is always one. to distinguish these 
vecior dope words from a TYPE/value pair. 

If the l.igh-ordrr bit is zero, then the vector is a "VECTOR, and the remaining bits specify the 
uniform TYPf of The elements. CHUTYPE just puts a new TYPE code in this field. Each element 
is limited to a one-wurd value: clearly PRIMTYPE STRINGS and BYTE5es and stack objects can't 
go in uniform vectors. 

If the high-order bit is one and the TYPE bits are zero, then this is a regular VECTOR. 

If the high-order bit is one and the TYPE bits are not all zero, then this is either an ATOM, m 
PROCESS. .111 ASOC. or a TEMPLATE. The special internal format of these objects will 
described a little laier in this appendix. 



be 



length - The tilglt-nnlci bit is the mark bit. used by the garbage collector. The rest of this field 
specifics the number of words in the block, including the dope words. This differs from the 
length given in pairs pointing to this vector, since such pairs may be the result of REST 
oper.it ions. 

grow - This is actually two nine-bit fields, specifying either growth or shrinkage at both the high 
and low ends of the vector. The fields are usually set only when a stack must be grown or 
shrunk. 

gc - This is used by the garbage collector to specify where this vector is moving during 
compaction. 

Examples (numbers in octal): the VECTOR £1 -bye- 3] looks like: 

Appendix 1 






The MDI. Prograi 



mi; Language 



217 



| VfcCTOR | | 
) | 

I -6 | --- 



1 fix 1 I 


1 * 1 


I STRING | 


3 I 


1 byte pointer | 


1 FIX | | 


■ 3 1 


1 -140000 | 


I 


1 10 1 I 



TheUVEClOR ![-! 7 -4 !] looks like: 






I UVCCTOR | | 
| - | 

I -3 | — 



1 



-1 

7 



-A 



I 40000+FIX | | 



I I 



A loin* 



lnternnlly Ainmv are special vecior-likc object.. An atom contains a value cell (the first two word* 

MiPrrt «V. t'J, ",' w,ie,,ever «•■ e )obal or Io «' *•*« of the ATOM is referenced and is not already 

"•ere), an OBLIST pointer, and a prim name (PNAME). in the following format: 



Appendix 



218 The MDL Programming Language 

I type | bindid | 

I po lntor-to-valuo | 

| pointer-to-OBLIST | 

I print-name | 

/ / 

/ / 

I (ASCII with NUL padding on end)| 

I ATOM | valid-type | 

I I 

I longth | gc I 

If the typo firld corresponds to TYPE UNBOUND, (hen Che ATOM is locally and globally unbound. 
(This is tlif f err lit from a pair, where llic same TYPE UNBOUND is used to mean unasstgncd.) If it 
corresponds in TYPE LOCI (an internal TYPE), then the value cell points either to the global Mack, if 
bindid Is jcio. 01 in a local control stack, if bindid is non-zero. The btndid field is used lo verify 
whether the local value pointed to by the value cell is valid in Ihe current environment. The 
po in tor- to-OBLI.SI is either a counting pointer lo an oblist (uvector). a positive offset into the 
"transfer vector" (for pure ATOMs). or zero, meaning that this ATOM is not on an OBLIST. The valid- 
type field tells Whether or not the ATOM represents a TYPE and if so the code for that TYPE; grow 
values arc never needed for atoms. 

Associations 

Associations are also special vector-like objects. The first six words of the block contain TYPE/value 
pairs for the ITEM. INDICATOR and AVALUE of ihe ASOC . The next word contains forward and 
backward pointers in the chain for that bucket of the association hash table. The last word 
contains forward and backward pointers in the chain of all the associations. 




Appendix 



The MDI. Programming Language 



219 




I bucket-chain pointers 

I association-chain pointers 



ASOC 



12 octal 



o 
QC 



PROCESS** 

A PROCESS vector looks exactly like a vector of TYPE/value pairs. It is different only in that the 
garbage collector treats ii differently from a normal vector, and it contains extremely volatile 
Information when the process is running. 

Template* 

In a template, the number in the typo field (left half of first dope word) identifies to which "storage 
allocation class" fills TEMPLATE belongs, and il is used to find PDP-IO instructions in internal tables 
(frozen ll vectors) for performing LENGTH, NTH, and PUT operations on any object of this TYPE. 
The programs to build these tables are not part of the interpreter, but the interpreter docs know how 
to use them properly. The compiler can put these instructions directly in compiled programs if a 
TEMPLATE is never RCSTcd: otherwise il must lei the interpreter discover the appropriate instruction. 
The value word of a template pair contains, not a counting pointer, but the number of elements 
that have been RESIrri off in the left half and a pointer to the first dope word in (he right half. 



Appendix 1 



220 



The MDL Programming Language 



The Co ntrol Slack 

Accumulators with symbolic names AB. TB. and TP are all pointers into the RUNNING PROCESS'S 
control Mack. AB ( argil in en I base") is a pointer to the arguments to the Subroutine now being run. 
It is set up by | he Subroutine-call mediator, and its old value is always restored after a mediated 
Subroutine call return*. TB ("temporaries base") points to the frame for the running Subroutine and 
also serve* as a stack base pointer. The TB pointer is really all that is necessary to return from a 
Subroutine -- given a value to return, for example by ERRET - since the frame specifies the entire 
state of the calling routine. TP ("temporaries pointer") is the actual stack pointer and always points 
to the current rnp nf the control stack. 

While were on the subject of accumulators, we might a* well be complete. Each accumulator 
contain* the value word of a pair, the corresponding TYPE words residing in the RUNNING PROCESS 
vector. When a PROCfSS is not RUNNING (or when the garbage collector is running), the accumulator 
contents are stored mi the vecior. so that the objects they point to look like elements of the PROCESS 
and thus are not garbage-collectible. 

Accumulator* A, B. C. D. C and are used almost entirely as scratch accumulators, and they are 
not saved nr restored across .Subroutine calls. Or course the interrupt machinery always saves these 
and all other accumulators. A and B are used to return a pair as the value of a Subroutine call. 
Other than that special feature, they are just like the other scratch accumulators. 

M and R are used in running RSUBRs. H is always set up to point to the start of the RSUBR's code, 
wh.ch is actually just a uniform vector of instructions. All jumps and other references to the code 
use M as an index register. This makes the code location-insensitive, which is necessary because the 
code ..vector w.ll move around. R is set up to point to the vector of objects needed by the RSUBR . 
I Ins accumulator is necessary because objects in garbage-collected space can move around, but the 
pointers to them in the reference vector are always at the same place relative to Its beginning. 

FRM is the Internal frame pointer, used in compiled code to keep track of pending Subroutine calls 
when the control stack is heavily used. P is the ii.ternal-stack pointer, used primarily for internal 
calls in the interpreter. 



One or the „,cest features of the MDL environment is the uniformity of the calling and returning 
sequence A4I Subroutines - boll, built-in F/SUBRs and compiled RSUBR( -ENTRY)s - are called in 
exactly the same way and return the same way. Arguments are always passed on the control stac 
and result* always end up in the same accumulators. For efficiency reasons, a lot of internal call 
Within the interpreter circumvent the calling sequence. However, all calls made by the interpret* 
when running user programs go through the standard calling sequence. 



k 
lis 
reter 



A Subroutine call is Initialed by one of three UUOs (PDP-10 instructions executed by software 
rather than hardware). MCALL ("MDL call") is used when the number of arguments is known at 
assemble or compile time, and this number is less than 1G. QCALL ("quick call") may be used if. in 
addition, an RSUBR( -ENTRY) is being called that can be called "quickly" by virtue of its having 



Appendix 1 



The MD1. Programming Language 221 

special information in If* reference vector. ACALL ("accumulator call") is used otherwise. The 
general method of calling a Subroutine is to PUSH (a PDP-IO instruction) pairs representing the 
arguments onto the control slack via TP and then either (I) MCALL or QCALL or (2) put the number of 
arguments into an accumulator and ACALL. Upon return the object returned by the Subroutine will 
be in accumulators a and R. and the arguments will have been POPped off the control stack. 

The call mediator Hores the contents of P and TP and the address of the calling instruction in the 
current frame (pointed to by TQ). It also stores MDL's "binding pointer" to the topmost binding in 
the control stack. (The bindings arc linked together through the control stack so that searching 
through them is more efficient than looking at every object on the stack.) This frame now specifies 
the entire slate of the caller when the call occurred. The mediator then builds a new frame on the 
control stack and stores a pointer back to the caller's frame (the current contents of TB). a pointer to 
the Subroutine bring called, and the new contents of AB , which is a counting pointer to the 
argument* and is, computed from the information in the MCALL or OCALL instruction or the ACALL 
accumulator. TB is then set up to point to the new frame, and its left half is incremented by one. 
making a new unique* id. The mediator then transfers control to the Subroutine. 

A control .stack frame has seven words as shown: 



1 


EN1RY | called-addr 


1 


1 


unique- id I prev frame 


1 


I 


argument pointer 


1 


1 


saved binding pointer 


1 


1 


saved P 


I 


1 


saved TP 


1 


' 


saved calling address 


1 



The fir*t three words are set up during the call in the Subroutine. The rest are filled in when this 
routine calls mini her Subroutine. The left half of TB is incremented every time a Subroutine call 
occurs and is used as the unique-id for the frame, stored in frame and tuple pairs as mentioned 
before. Obviously this id Is not strictly unique, since each 256K calls It wraps around to zero. The 
right half nf IB Is always Irft pointing one word past the savcd-calling-address word in the Frame. 
TP is also left pointing at that word, since that is the top of the control stack at Subroutine entry. 
The argument'* to the called Subroutine are below the frame on the control stack (at lower storage 
addresses), and the temporaries for the called Subroutine arc above the frame (at higher storage 
addresses). These arguments and temporaries arc just pairs stored on the control stack while needed; 
they are all that remain of UNSPECIAL values in compiled programs. 

Appendix I 



222 



The MDL Programming Language 



The following figure shows what (he control stack might look like after several Subroutine calls. 



1 
1 
1 


arqs for 


SI 


1 
1 
1 


1 


frame for 


51 


1 


1 
1 
1 


temps for 


SI 


1 1 
1 | 

1 | 


1 
1 

1 


arys for 


S2 


1 1 

1 1 
1 1 


1 


framo for 


SZ 


1 --- 


1 
1 
1 


temps for 


SZ 


1 | 

1 I 

1 1 


1 


arfix for 


S3 


1 1 


1 


frame for 


S3 


| 


1 






1 


1 
1 

1 


temps for 


S3 


1 

1 
1 






(top) 



execution 



The above figure show* the frames all linked together through the control slack (the "■ 
path >. *o that ■( |s easy to return to the caller of a given Subroutine (ERRET or RETRY). 

Subroutine exit is accomplished simply by the call mediator, which loads the right half of TB from 
the prcvou* frn.no pointer restores the "binding pointer". P. and TP. and transfer* control back to 
Hie instruction following the saved calling address. 



Appendix 1 



The Mf>I- Programming Language 



22J 



Variable Uindincs 

All local AIOM value* are kepi on the control stack of the PROCESS to which they are local. As 
described before, the atom contains a word that points to the value on the control stack. The 
pointer is actually to a six-word "binding block" on the control stack. Binding blocks have the 
following format: 




| DIND or UBIND | prev 

pointer to ATOM 



value 
pa \r 



docl I unique-Id 

previous-binding 



where: 

BIND mmns this is a binding for a SPECIAL ATOM (the only kind used by compiled programs), 
and UBIND mean* this is a binding for an UNSPECIAL ATOM - for SPECIAL checking by the 
interpreter: 

prev points to the closest previous binding block for any ATOM (the "access path" — UNWIND 
object* arc a I <.o linked in this chain): 

docl points to a DECL associated with this binding, for SET(LOC) to check; 

un «qiio-id is used for validation of this block: and 

previous- bind inn. points to the closest previous binding for this ATOM (used in unbinding). 

Bindings are generated by an internal subroutine called SPECBIND (name comes from SPECIAL). The 
caller to SPF.CBINU PUStfef consecutive sis-word blocks onto the control stack via TP before calling 
SPECBIND. The first word of each block contains the TYPE code for ATOM in its left half and all 
ones in its right half. SPFCBIND uses this bit pattern to identify the binding blocks. SPECBIND's 
caller aKo rill* in the nrxi three words and leaves the last two words empty. SPECBIND fills in the 
rest and leaves the "binding pointer" pointing at the topmost binding on the control stack. 
SPECBIND also stoic-, a pointer to the current binding in the value cell of the atom. 



L 



Appendix I 



22-1 



The MDL Programming Language 



SW ^.^J^^ezst •sr.sr ac,di,ion " , prob,c "' s *»— «» *•» "»»- 

•pp«r in.,,, I ™ "C i»J «•»«««* facing «|| corraM local value cells of .torn, .o 

an ATW, LVAL , never , C Z ' a """ S (T " C S '""" •»-*"«'«•<* «"« when 

.he control Mart and llukro m, ,1 , r „, . ' " mro " m '"'> A »P««' block is bull, on 
>n»ir„,„„en, .,,l ic "- a ,d , ,1 ' ", 7. b, i"""B l "«* _«''■»'• This block Is called a "skip block" or 
beco.ne Z!XJ?^^!!XZ2Z. *"" """ '° "" '"" «*— «* ca„sin B "searches ,. 



Appendix I 



w> 



The MDL Programming Language 



225 



Appendix 2. Predefined Subroutines 

The following is a very brief description of all the primitive* (F/SUBRs) currently available in 
MDL. Ihrse descriptions are in no way to be considered a definition of the effects or values 
produce! by the primitive. Tl.ey just try to be as complete and as accurate as is possible in m 
smgle-Matenicnt description. However, because of the complexity of most primitives, many 
important assumptions and restrictions have been omitted. Even though all primitives return a 
value, some descriptions mention only tl.c side effects produced by a primitive, because these 
primitive, are most ortcn used for this effect rather than the value. 

A description is given in this format: 

name ( urguntrntx ) 

deel 
English description 

This format is intended to look like a FUNCTION definition, omitting the call to DEFINE and all 
internal variables and code. The wm? is just the ATOM that is used to refer to the primitive. The 
names nf the rrpumentr. are intended to be mnemonic or suggestive of their meanings. The ded is a 
FUNCTION-style Dfft (chapter N) for the primitive. In some cases the DECL may look unusual, 
because it is Intended to convey information to a person about the uses of arguments, not to convey 
information to the MDL interpreter or compiler. For example. <0R FALSE ANY> is functionally 
equivalent to ANY. hut it indicates that only the -truth" of the argument is significant. Indeed. Hie 
roPT ...1 construction is often used illegally, with other elements following it: be warned that 
MDL would not accept it. An argument is included in the same LIST with VALUE (the value of the 
primitive) only if the argument is actually returned by the primitive as a value. In other words. 
*OECL ((VALUE ARG ) ...) implies < = « ? .VALUE .ARG>. 



* ("TUPLE" TAC10RS) 
#DECL ((VALUE) <0R TIX FLOAT> 

(FACTORS) <TUPLfc CREST <0R FIX FLOAT>]>) 
multiplies all arguments together (arithmetic) 

+ ("TUPLE- TERMS) 
'DECL ((VALUE) <0R FIX FLOAT> 

(TERMS) <TUPLE [REST <0R FIX FLOAT>J>) 
adds all arguments together (arithmetic) 



Appendix 2 



22G 



The MDL Programming Language 



- ("OPTIONAI" MINUEND "TUPLE" SUBTRAHENDS) 
<*DECL ((VALUE) <OR FIX FLOAT> 

(MINUEND) <OR riX ELOAT> 

(SllflTRAIirNnS) <TUPLE [REST <OR FIX FLOAT>]>) 

subtracts other arguments from first argument (arithmetic) 

/ ("OPTIONAL" DIVIDEND "TUPLE" DIVISORS) 
#DECL ((VAIUF) <OR TIX FLOAT> 

(D1VIDIHD) <OR FIX l-LOAT> 

(DIVISORS) <HIPLE [REST <OR FIX FL0AT>1.» 
div.dcs first argument by other arguments (arithmetic) 

0? (NUMBL-R) 
#DECL ((VALUD <OR 'T 'CFALSE ()> 
(NUMBER) <OR FIX FL0AT>) 

tells whether a mini her is 7cro (predicate) 

1? (NUMBER) 
*DECL ((VALUD <0H 'T * #FALSE ()> 
(NIIMRIR) <0R FIX FL0AT>) 
tells Whether a number is one (predicate) 

1STEP (PROCESS) 

#DECL ((VALtlt PROrESS) PROCESS) 
causes a PROCESS lo enter single-slcp lllode 

= =? (OB,irCT-l OBJECT-?) 
*0ECL ((VALUF) <OR T '#FALSE ()> 
(OBJECT-1 OBJECT-2) ANY) 
tells whether two objects are "exactly" equal (predicate) 

-? (OBJECT- I OBJECT-?) 
#DECL ((VALUE) <OR "T '#FALSE ( )> 
(OBJECT-] OBJECT-2) ANY) 
tells whether two objects are "structurally- equal (predicate) 

ABS (NUMBER) 
*DECL ((VALUE) <OR TIX ELOAT> 

(NUMBER) <OR FIX FIOAT>) 
returns absolute value of a number (arithmetic) 

ACCESS (CHANNEL ACCESS-POINTER) 
#DECL ((VALUF CHANNEL) CHANNEL 
(ACCESS-POINTER) FIX) 
sets access pointer for next I/O transfer via a CHANNEL 

Appendix 2 



The MDI. Programming Language 



227 



ACTIVATE-CIIARS ("OPTIONAL" STRING) 

#DECL ((VA1.UC SIRING) STRING) 
sets or retui n» interiupt characters for terminal typing (Tcnex md Tops-20 versions only) 

AGAIN ("OPTIONAL" (ACTIVATION .LPROGN (-INTERRUPTS)) 
#DCCL ( < VAUir ) ANY 

( ACTT VAT TON) ACTIVATION) 
resumes execution at the given ACTIVATION 

ALLTYPrS ( ) 

#DECL ((VAUir) <VEC10R [REST AT0M1>) 
returns ihe VECIOR of all type names 

AND ("ARCS" ARGS) 
*DECL ((VALUl) <OR FALSE ANY> 
(ARGS) LIST) 
computes logical "anil" of (ruth-values, evaluated by the Subroutine 

AND? ("TUPLE" TUPLE) 
#DECL ((VALUE) <0R FALSE ANY> 
(TUPLE) TUPLE) 
computes logical "and" or truth-values, evaluated at call time 

ANDB ("TUPLE" WORDS) 
#DECL ( (VAI UE) WORD 

(WOltns) OUPLG [REST <PRIMTYPE W0RD>3>) 
computes bitwise "and" of machine words 

AppLiCAoir? (oiurcT) 

*DECL ((VAIUl) <0R 'T ' #f ALSE ( )> 
(OBJECT) ANY) 
tells whether argument is applicable (predicate) 

APPLY (APPLICABLE "TUPLE" ARGUMENTS) 
#DECL ((VALUE) ANY 

(APPLICABLE) APPLICABLE (ARGUMENT5) TUPLE) 
applies first argument to the other arguments 

APPLYTYPE (TYPE "OPTIONAL" HOW) 
#DECL ((VALUE) <OR ATOM APPLICABLE '('FALSE ()> 
(TYPE) ATOM (MOW) <0R ATOM APPLICABLE>) 
specifies or returns how a data type is applied 



Appendix 2 



228 The MDL Progr amming Language 

ARCS (CAIL) 
#DECL ((VALUE) TUPLE 

(CALL) <0R FRAME ENVIRONMENT ACTIVATION PROCESS>) 
returns ^ re; mucins of a given iin-rcliirncd Subrouline call 

ASCII (COHL-OR-CHARACTER) 
#OECL ((VALUE) <0R CHARACTER FIX> 

(CODE-OR-CNARACTER) <0R TIX CHARACTER^ 
returns CIIARACIFR with given ASCII code or vice versa 

ASSIGNED? (ATOM "OPTIONAL" ENV) 
• DECL ((VAIUF.) <0R *T 'rfTALSE ()> 

(A10M) ATOM (FHV) <0R TRAME ENVIRONMENT ACTIVATION PROCESS>) 
tells whether ail ATOM lias a local value (predicate) 

ASSOCIATIONS ( ) 

*DECL ((VAIUI ) <OR ASOC • #FA1 SE ( )>) 
returns il,c flrM object in ihe association chain 

AT (STRUCTURCO "OPTIONAL" (N 1)) 
*DECL ((VAIUI) L0CA1IVE 

(STRUCTURED) STRUCTURED (N) <0R FIX OFFSET>) 
returns a locative In the Nth clement of a structure 

ATAN (NUtmtR) 
*DECL ((VALUE) FLOAT 

(NUMBER) <0R FIX FLOAT>) 
returns arc UingcM of a number (arithmetic) 

ATOM ( THAME ) 
#DECl ((VALUE) ATOM 

(1»NAMI ) SIRING) 
creates an ATOM with a given name 

AVALUr ( ASSOC I AT ION ) 
#DECL ((VAI III ) ANY 

(ASSOCIA1IOH) ASOC) 
returns the "value" field of an association 



Appendix 2 




Tbe MDL Programming Language 



229 



BACK (STKUCTURE "OPTIONAL" N) 
#DECL {(VALUE) <0R VECTOR TUPLE UVECTOR STORAGE STRING BYTES TEMPLATE> 

(N) rix 

(STRUCTURE ) <OR <PRIHTYPE VECTOR) <PRIMTYPE TUPLE> 

<PRIMTYPE UVECTOR> <PRIMTYPE STORAGE) 
<PRIMTYPE STRING> <PRIMTYPE BYTES> 
<PRIMTYPE TEMPLATE») 
replaces some element* removed from a non-list structure by RESTlng and changes to primitive data 
lyi>e 

BIND ("Alir.S" ARRS) 
#DECL ((VALUb) ANY 

(ARGS) <LIST [OPT ATOM] LIST [OPT OECL] ANY>) 
executes sequential expressions without providing a bound ACTIVATION 

BITS (WIDIH "OPTIONAL" (RIGHT-EDGE 0)) 
#DECL ((VALUE) BITS 

(WIUTH RIGIIT-EDGE) FIX) 
creates a hit mask for PUT 111 IS and GETBITS 

BLOAT ("OPTIONAL" 

(TPrE 0) (STACK 0) (LOCALS 0) ( GLOBALS 0) (TYPES 0) (STORAGE 0) (P-STACK 0) 
M1N GROW-IOCAL GROW-GLOHAL GROW-TYPE GROW-STORAGE PURE P-STACK-SIZE STACK-SIZE) 
#DECL ((VALUE) FIX 

(TREC STACK LOCALS GLOBALS TYPES STORAGE P-STACK MIN GROW-LOCAL GROW-GLOBAL 
GROW-TYPE GROW-STORAGE PURE P-STACK-SIZE STACK-SIZE) FIX) 
allocates extra storage temporarily 

BLOAT-STAT ("OPTIONAL" STATS) 
#DECL ((VAIlir) <UVECTOR \_27 riX]> 
(51ATS) <UVECT0R [2? ANYJ>) 
gis'es garbage-collector and storage statistics 

BLOCK (lOOK-HP) 

*DECL( (VALUE IOOK-UP) <OR OBLIST <L1ST [REST <0R OBLIST 'DEFAULT>T>>) 
SETS OBLIST for looking Up ATOMs during READing and PARSEing 

BOUND? (AIOM "OPTIONAL" ENV) 
*DECL ((VALUE) <OR 'I ''FALSE ()> 

(ATOM) ATOM (ENV) <OR FRAME ENVIRONMENT ACTIVATION PROCESS>) 
tells whether an ATOM is locally bound (predicate) 



Appendix 2 



T 



230 The MDL Programming Language 

BREAK-SEQ (OBJrCT PROCESS) 
«*DECL ((VAitll- PROCESS) PROCESS 
(OBJECT ) ANY) 
modifies execution sequence of another PROCESS 

BUFOUT ("OPUONAI" (CHANNEL .OUTCHAN)) 

#DECL ((VALUE CHANNEL) CHANNEL) 
write* OKI -ill internal MDL buffer* for an output CHANNEL 

BYTE-SIZE (BY1LS) 
#DECL ((VALUE) FIX 

(BYTES) BYTES) 
returns M7C of bytes in a byte-string 

BYTES (SIZE "TUPLE" ELEMENTS) 
#0ECL ((VALUE } BYTES 

(STZE) flX (ELEMENTS) <TUPL£ [REST FIX]>) 
creates a byte-Mring from explicit arguments 

CHANLIST ( ) 

#DECL ((VAIUK) <LTS1 [HFST CHANNCL]>) 
return* a LIST of currently open I/O CHANNEL* 

CHANNEL ("OPTIONAL" (MODE "READ") "TUPLE" FILE-NAME) 
#DECL ((VAIUE) CHANNEL 

(MODE) STRING (FILE-NAME) TUPLE) 
creates nn unopened I/O CHANNEL 

CHTYPE (OBJECT IYPE) 
#DECL ((VALUE) ANY 

(OBJECT) ANY (TYPE) ATOM) 
makes a new pair with a given data type from an old one 

CHUTYPE (UVECTOR TYPE) 
#DECL ((VAIUE UVECTOR) <PRIMTYPE UVECT0R> 
(TYPE) ATOM) 
change* the data type of the element* of a uniform vector 

CLOSE (CHANNEL) 

#0ECL ((VAIUF CHANNEL) CHANNEL) 
close* an I/O CHANNEL 



Appendix 2 



The MDL Programming Language 



2Si 



CLOSURE (FUNCTION "TUPLE" VARIABLES) 
#OECL ((VALUE) CLOSURE 

(niHCTION) rUNCTION (VARIABLES) <TUPLE [REST ATOMI>) 
"binds" * lif free variables of a FUNCTION lo current values 

COND ("ARGS" CLAUSES) 
#DECL ((VAKIL) ANY 

(CLAUSES) <MST <LIST <0R FALSE ANY>> [REST <LIST <OR FALSE ANY»3>> 
evaluates conditions anil selected expression 

CONS (NEW-F.I CHtNT LIST) 
#DECL ((VALUE) I 1ST 

(NEW-ELEMENT) ANY (LIST) LIST) 
add* an clement to the from of a LIST 

COS (NUMBER) 
#DECL ((VALUE) FLOAT 

(NUMBER) <0R TIX FLOAT>) 
returns rnsinp nf a iiinuhrr (arithmetic) 

CRLF ("OPTIONAL" (CHANNEL .OUTCHAN)) 
#DECL ((VAIUI) M 

(CHANNEL) CHANNEL) 
prints a carriage-return and line-feed via an output CHANNEL 

OECL-CIIECK ("OPTIONAL" SWITCH) 
#DECL ((VA1UF) <0R *T ''FALSE ()> 
(SWITCH) <OR FALSE ANY>) 
enables or disables type-declaration checking 

DECL? (OBJECT PA11ERN) 
#DECL ((VALUE) <OR 'T « 'FALSE ( >> 

(OBJECT) ANY (PATTERN) <0R ATOM FORM>) 
tells whether an olijrrt matches a type declaration (predicate) 

OEFINE ('NAME "ARGS" ARGS) 
*DECL ((VALUE) ATOM 

(NAME) ANY (ARGS) <LIST [OPT ATOM] LIST [OPT DECL] ANY>) 
sets the global value of an ATOM lo a FUNCTION 

OEFMAC ( 'NAME "ARCS" ARGS) 
#DECl (<VAI 1*1 > ATOM 

(NAME) ANY (ARGS) <LIST [OPT ATOM] LIST [OPT DECL] ANY> ) 
sets the global value of an ATOM to a MACRO 



Appendix 2 



232 The MDL Programming Language 

DEMSIO (NAME) 
*DECl ((VAIIII) <0R 'T ''FALSE ( )> 
(NAME) SIRING) 
signal* an ITS daemon 

DISAFUt ( 1N1F KRtlPl ) 
#DECL ((VALUE INIERRUPT) IHEADER) 

disable* an interrupt 

DISMISS (VAI -OPIIONAL" ACTIVATION INT-LEVEL) 
#DECL ((VALUE VAL ) ANY 

(AC1IVATION) ACTIVATION (INT-LEVEL) FIX) 
dismisses an interrupt occurrence 

ECHOPA1R ( IN OUT) 
(fOECL ((VAtUl IN) CHANNEL 
(OH I ) CI I AUNT I ) 
coordinate* I/O CHANNEL* for echoing characters on rubout 

EMPTY? (ODOECT) 
*DECL ((VA1HF) <OR 'T 'TALSE ()> 
(OBJECT) STRUCTURED) 
tells whether a Mmcliire has zero elements (predicate) 



ENABLE ( INlr.RKUPI ) 

*DECL ((VALUE INIERRUPT) IHEADER) 
enable* an interrupt 

ENDBLOCK ( ) 

#DECL ((VALUE) <OR OBLIST <LIST [REST <OR OBLIST *DEFAULT>]») 
restores the .OBLIST thai existed before corresponding call lo BLOCK 

ENTRY-LOC (FNTRY) 
#DECL ((VALUE) FIX 

(ENTRY) RSUBR-ENTRY) 
returns the off*el in the code vector of an RSUBR-ENTRY 

EQVB ( "TUPLE" WORDS) 
#OECL ((VALUE) WORD 

(WORDS) <TUPLE TREST <PRIMTYPE WORD>]>) 
computes bitwise "equivalence" of machine words 












Appendix 2 



The MDL Programming Language 2SS 

ERRET ("OPTIONAL" UAL (FRAME .LERR\ "-INTERRUPTS)) 
#DECL ((VALUE) ANY 

(VAl ) ANY (FRAME) FRAME) 
continues rvnlii.it inn from the Jam ERROR or LISTEN or from a given FRAME 

ERROR ("TUPLE" INFO) 
#DECL ( (VAl UE) ANY 

(INFO) TUPLE) 
Mops and inform* usei nf an error 

ERRORS ( ) 

<*DECL ((VA1UF) OBI 1ST) 
returns 1 he OBLIST where error messages are located 

EVAL (ANY "OPTIONAL" CNV) 
*DECL ( (VALUE ) ANY 

(EHV) <0R FRAME ENVIRONMENT ACTIVATION PROCESS>) 
evaluates an expression in a given environment 

EVALTYPE (TYPE "OPTIONAL" HOW) 
#DECL ((VALUE) <OR ATOM APPLICABLE ' #FALSE ( )> 
(TYPE) ATOM (HOW) <0R ATOM APPLICABLE>) 
specifies or return* how a data type is evaluated 

EVENT (NAME "OPTIONAL" PRIORITY WHICH) 
#DECL ((VAIUE) IHF.ADER 

(NAME) <0R SIRING ATOM IUEADER> (PRIORITY) FIX (WHICH) <OR CHANNEL LOCATIVE>) 
sets up an inicrriipi 

EXP (NUMBER) 
#DECL ((VALUE) Fl OAT 

(NUMBER) <OR FIX FLOAT >) 
returns "c" to the power of a number (arithmetic) 

EXPAND (ANY) 
#DECL ((VALUE) ANY 
(ANY) ANY) 
evaluates its argument (only once if a MACRO is involved) in the top-level environment 

FILE-EXISTS? ("TUPLE" FILE-NAME) 
*DECL ((VALUE) <OR *T <FALSE STRING FIX» 
(FILE-NAME) TUPLC) 
tests for existence of a file (predicate) 



Appendix 2 



r 



2'i-i The MDL Programming Language 

FILE-LENGTH (INCH) 
#DECL ((VAllir ) I IX 

(INCH) CHANNEL) 
return* the syMcni-providcd length of a file open on an input CHANNEL 

FILECOPY ("OPTIONAL" (INCH .INCHAN) (OUCH .OUTCHAN)) 
#OECL ( (VALUE) FIX 

( INCH OUCH) CHANNEL) 
copies Characters from one CHANNEL to another until end-of-file on the input CHANNEL 

FIX (MUMUER) 
#DECL ((VALUE) FIX 

(NUMBER) <OR TLOAT FIX>) 
returns integer pari of a number (arithmetic) 

FLATSIZE (ANY MAX "OPTIONAL" (RADIX 10)) 
#0ECL ((VAlUr.) <OR TIX '4TALSE ( )> 
(ANY) ANY (HAX RADIX) FIX) 
returns numlu-r nf characters needed (o PRINI an object, if not greater than given maximum 

FLOAD ("TUPLE" F] I X.-NAHr-AND-LOOK-UP ) 
#DECL ((VAtm>) '"HONE" 

(FILE-HAME-AH0-LOOK-UP) TUPLE) 
reads and evaluates all objects in a file 

FLOAT (NUMHLR) 
#DECL ((VALUE) FLOAT 

< minor. R) <or fix float>) 

returns floating-point value of a number (arithmetic) 

FORM ("TUPLE" ELEMENTS) 
#DECL ( (VAI UL ) FORM 

(ELFHFNTS) TUPLE) 
creates a FORM from explicit arguments 

FRAME ("OPTIONAL" (FRAME -LERR\ I - INTERRUPTS) ) 
#DECL ( (VALUE) I RAHF 

(FRAME) <OR FRAME ENVIRONMENT ACTIVATION PR0CESS>) 
returns a previous Subroutine call 

FREE-RUN (PROCrSS) 
#DECL ((VALUE) <OR PROCESS ■ /FALSE ( )> 
(PROCESS) PROCESS) 
causes a PROCESS to leave single-step mode 

Appendix 2 




The MDL Programming Language 2S5 

FREEZE (SlKUCIItltt ) 
#DECL ((VAIIN ) <0R VECIOR UVECTOR STRING BYTES> 

(STRUCTURE) <0R <PRIMTYPE VECTOR> <PRIMTYPE TUPLE> <PRIMTYPE UVECTOR> 
<PR1MTYPE STRINO <PRIMTYPE BYTES») 
makes copy of argument in non-moving garbage-collected space 

FUNCT (TRAMD 
#DECL ( (VAI UE > AIOM 

(IRAMh) <0R tRAHF ENVIRONMENT ACTIVATION PROCESS>) 
returns Subroutine name of a given previous Subroutine call 

FUNCTION ("ARCS" ARGS) 
#DECL ((VAlUb) FUNCTION 

(ARCS) <LIST tOPT ATOM} LIST [OPT DECLJ ANY>) 
creates a rUNCTlON 

G=? (NUNHlR-1 NUMBER-Z) 
#DECL ((VALUE) <0R 'T '#FALSE ()> 

(NUHBFR-1 NUHBCR-2) <0R FIX FLOAT>) 
tells whnbrr first argument is greater than or equal to second (predicate) 

G? ( NUMBER- 1 HUHBER-2) 
#OECl ((VAMID <0R 'T 'tfFALSE ( )> 

(NUtmiR-l NUMBER-2) <0R FIX FLOAT>) 
lells whether first argument is greater than second (predicate) 

GASSICNm? (ATOM) 
*DECL { (VALUE) <OR 'T '4FALSE ( )> 
(ATOM) ATOM) 
tells whether an AIOM has a global value (predicate) 

GBOUNH? (AIOM) 
#DECL ((VALUE) <0R 'T '*FALSE ( )> 
(ATOM) ATOM) 
tells whether mi ATOM ever hail a global value (predicate) 

GC ("OPTIONAL" MIN (EXHAUSTIVE? <>) MS-FREQ) 
#DECL ((VAIUE) FIX 

(MIN MS-IRIO) flX (EXHAUSTIVE?) <0R FALSE ANY>) 
causes a gatbage collection and changes garbage-collection parameters 

GC-DUMP (ANY PR1NIIJ) 
#DECL ((VAMJF) <0R ANY UJVCCTOR <PRIMTYPE UORO»> 
(ANY) ANY (PHINTB) <0R CHANNEL FALSE>) 
dumps aii object so that it can be reproduced exactly 

Appendix 2 



236 



The MDL Programming Language 



Appendix 2 









GC-MON ("OPTIONAL" SWITCH) 
*DECL ((VAIUE) <OR 'T »#rALSE ()> 
(SWI ICI1) <OR FALSE ANY>) 
turns garbayernlleclin,, moniioriiig of f or on 

GC-REAfl (RCAnn "OPTIONAL" (EOF-ROUTINE '<ERROR . >n 
*DECL <(VAIIIK) ANY 

(RfADG) CHANNEL (EOF-ROUTINE) ANY) 
inputs an Object lli.ii WW previously GC-DUHPed 

GDECL ("ARCS" ARG5) 
*DECL ( (VALUE) AMY 

d-rl, | . <A " CS > , <lISI l R "T <LIST [REST AT0M1> <0R ATOM FORM>]» 

declares the type/structure or the global value of atoms 

GET (HEM INOICAIOR "OPTIONAL" (IF-NONE <>)) 
'DECL ((VALUE) ANY " 

does NTHoVgETPROp" STfl, ' CI " RCD ^ (INDICATOR) <0R FIX OFFSET ANY> C XF-NONE, AHY, 

GET-DECl (ATOH-OR-OrFSEl) 
#DECL ((VAIIIF) <OR ATOM FORM '#FALSE ( )> 
(ATOH-OR-OFFSET) <OR LOCD OKFSET>) 
gets Hie type declaration for an ATOMs value or an OFFSET 

GETBIT5 (FROM FlfcLD) 

#DECL ((VALUE) WORD 

n^.ffS,? <P»I«TYPE WORD> <PRIMTYPE STORAGE» (FIELD) BITS, 
returns a lui field of ,-, machine word or STORAGE address 

GETL (ITEM INDICATOR "OPTIONAL" (IF-NONE <») 
#DECL ((VALUE) <0R LOCATIVE LOCAS ANY> 

doesATo/GETPL <0R STRUCIURED AN " CINDICATOR) <0R FIX OFFSET ANY> (IF-NONE, ANY, 

GETPL (ITEM INDICATOR "OPTIONAL" (IF-NONE Oil 
*DECL ((VALUE) <OR LOCAS ANY> 

(HEM INDICATOR IF-NONE) ANY) 
returns a locative to an association 

GETPROP (ITFM INDICATOR "OPTIONAL" (IF-NONE Oil 
#DECL ((VALUE) ANY 

(ITEM INDICATOR IF-NONE) ANY) 
returns the value associated with an item under an indicator 












The MDL Programming Language H7 

GLOC (ATOM -OPTIONAL" (MAKE-SLOT <>)) 
*OECL ((VALUE) LOCD 

(ATOM) ATOM (MAKE-SLOT) <0R FALSE ANY>) 
returns a local ivc to the global-value cell of an ATOM 

GO (LABEL) 
#OECL ((VALUE) ANY 

(LABEL) <0R ATOM TAG>) 
goes to a label and continues evaluation from there 

GROW (U/VECTOR END BEG) 
#OECL ((VALUE) <0R <PRIMTYPE VECTOR> <PRIMTYPE UVECTOR» 

(U/VECTOR) <0R <PRIMTYPE VECTOR> <PRIMTYPE UVECTOR» (END BEG) FIX) 
increases lite *ize of a vector or uniform vector 

GUNASSIGH (ATOM) 

#DECL ((VALUE ATOM) ATOM) 
causes an ATOM 10 have no global value 

GVAL (AlOM) 
#OECL ((VALUE) ANY 
(ATOM) ATOM) 
returns the global value of an ATOM 

HANDLER ( IHEADER HANDLER "OPTIONAL" (PROCESS ^PROCESS 0)) 
#0ECL ((VALUE) HANDLER 

(IIIEADER) IHEADER (HANDLER) <OR HANDLER APPLICABLE> (PROCESS) PROCESS) 

creates an Interrupt handler 

HANG ("OPTIONAL" (UNHANG <>)) 
#DECL ((VALUE) ANY 

(UNHANG) ANY) 
does nothing, intcrruptibly. potentially forever 

IBYTES (SIZE LENGTH "OPTIONAL" (ELEMENT 0)) 
#DECL ((VALUE) BYTES 

(SIZE LENGTH) FIX (ELEMENT) ANY) 
creates a bytc-siriug from implicit arguments 

IFORM (LENGTH "OPTIONAL" (ELEMENT r*L0SE 0)) 
#DECL ((VALUE) FORM 

(LENGTH) FIX (ELEMENT) ANY) 
creates a FORM from implicit arguments 



Appendix 2 



238 The MDL Programming Language 

ILIST (LENGTH "OPTIONAL" (ELEHENT 'LOSE 0)) 
#DECL ((VALUE) LIST 

(I I HGHI) FIX (ELEHENT) ANY) 
create* a LIST from implicit arguments 

IMAGE (CODE "OPTIONAL" (CHANNEL .OUTCHAN)) 
#OECL ((VALUE CODE) FIX 

(CHANNEL) CHANNEL) 
sends an image-mode character via an output CHANNEL 

IN (POINTER) 
#DECL ((VALUE) ANY 

(POINTER) LOCATIVE) 
returns Ihe object pointed lo by a locative 

INDEX (OFFSET) 
#DECL ((VALUE) FIX 

(OFFSET) OFFSET) 
fetches the integral part of an OFFSET 

INDICATOR (ASSOCIATION) 
#DECL ((VAlUt ) ANY 

(ASSOCIATION) ASOC) 
returns the "indicator'' field of an association 

INSERT (PNAME OBI IS!) 
#DECL ((VALUE) ATOM 

(PNAME) <OR ATOM STRING> (OBLIST) OBLIST) 
adds an ATOM to an OBLIST 

INT-LEVEL ("OPTIONAL" NEW-INT-LEVEL) 
#DECL ((VALUE) FIX 

(NEU-1NT-LEVEL) FIX) 
returns and/or sets current interrupt level 

INTERRUPT (NAME "TUPLE" HANDLER-ARGS) 
#DECL ((VALUE) <OR 'T • #FALSE ( )> 

(NAME) <0R STRING ATOM IHEADER> (HANDLER-ARGS) TUPLE) 
causes an interrupt to occur 

INTERRUPTS ( ) 

#DECL ((VALUE) OBLIST) 
returns the OBLIST on which interrupt names are kept 



Appendix 2 






The MDL Programming Language 



239 



IPC-HANhl I R (nOHY TYPE OTHFR-NAME-1 OTHER-NAME-Z 

"OPTIONAL" (MY-NAME-1 <UNAME>) (MY-NAME-2 <ONAME>)) 
#DECL ((VALUE) 'T 

(nOUY) <OR STRING UVCCTOR> (TYPE) FIX 

(OlHUs-NAMr -1 OTHER-NAME-? MY-NAME-1 MY-NAME-Z) STRING) 
is ChC built-in handler for "IPC" (ITS version only) 

iPC-orr ( ) 

*DECL ( (VA1 Hi ) * 1 ) 
stop* nil listening on ihr IPC; device (ITS version only) 

IPC-ON ("OPITONAI" (MY-NAME-1 <UNAME>) (MY-NAME-Z <JNAME>)) 
#DECL ((VAMll ) 'T 

(MY-NAHF.-l MY-HAHE-Z) STRING) 
HstCIM on ilir ll'f: device (ITS version only) 

ISTORAGE (LEHGIH "OPTIONAL" (ELEMENT #LOSE 0)) 
#DECL ((VALUE) STORAGE 

(ICNGTII) TIX (CLCHENT) ANY) 
creates a non-ynrliage-collcctctl STORAGE from implicit arguments (archaic) 

[STRING (LENGTH "OPTIONAL" (ELEMENT ! \~9 ) ) 
#OECL ((VAIUI ) STRING 

(LENGTH) FIX (EltMENT) ANY) 
creates a character-siring From implicit arguments 

ITEM (ASSOCIATION) 
*DECL ((VAIUF ) AHY 

(ASSOCIATION) ASOC) 
retUrm the "item" fit-Ill of an association 

ITUPLE ( LENGTH "OPTIONAL - (ELEMENT #LOSE 0)) 
#DECL ((VALUE) TUPLE 

(LENGTH) FIX (ELEMENT) ANY) 
creates a TUPI F from implicit argument* 

IUVECTOR (LENGTH "OPTIONAL" (ELEMENT #LOSE 0)) 
#DECL ((VAIUE) UVECTOR 

(IENG1H) i IX (CLEMENT) ANY) 
creates a UVECIOR from implicii argumenls 

IVECTOR (LENGTH "OPTIONAL" (ELEMENT #L0SE 0)) 
#DECL ((VAl HI ) VF.CtOK 

(LENGTH) FIX (ELEMENT) ANY) 
creates a VECTOR from implicit arguments 



Appendix 2 



2-10 The MDL Programming Language 

JNAME ( ) 

*DECl ((VALUE ) SIRING) 
return* ihc "Job name" nf MFH.'s process 

L=? ( NUMBER- 1 NUMBER-2) 
■•OECL ((VALUE) <OR 'T ' * FALSE ()> 

(NUMRfR-1 NUMBER-?) <0R FIX FL0AT>) 
tells whrthrr first argument h> less than or equal to second (predicate) 

L? (NUMOIR-l NHMBfR-Z) 
*DECI. (( VAI.UK ) <OR 'I ''FALSE ()> 

(NIIMBER-l NUMBER- 2) <0R FIX FL0AT>) 
tells whcihrr first argument is less than second (predicate) 

LEGAL? (S1ACK-OBJLCT) 
#DECL ((VALUE) <OR 'T ''FALSE ( )> 
(STACK-OBJECT) ANY) 
tells whether argument (whirh might live on the control stack) is still legal (predicate) 

LENGTH (OBJECT) 
#DECL ((VALUE) nx 

(OBJI CT) STRUCTURED) 
returns the numlier nf elements in a structure 

LENGTH? (OBJCCt MAX) 
#DECL ((VAIIU) <OR FIX ''FALSE ( )> 

(OBJECT) S1RUC1URLD (HAX) FIX) 
tells whether length nf .structure is less than or equal lo an integer (predicate) 

LINK (EXI'K I'NAIir "OPTIONAL" (OBLIST <1 .0BLIST>)) 
#DECL ((VALUE EXPR) ANY 

(PHArlE) STRING (OBLIST) OBLIST) 
creates a symbolic I INK to any expression for READing 

LIST ("TUPLE" ELEMENTS) 
'DECL ((VALUE) LIST 

(ri rurNTS) tuple) 

creates a I 1ST from explicit arguments 

LISTEN ("TUPLE" INFO) 
*DECL ((VALUE) ANY 

(INfO) TUPLE) 
stops and informs user thai MDL is listening 



Appendix 2 






r 



The MDI. Programming Language 



241 



LLOC (ATOM -OPTIONAL" ENV) 
#DECL ((VALUE) LOCD 

(ENV) <OR FRAME ENVIRONMENT ACTIVATION PROCESS>) 
returns :i locative to the local-value cell of an ATOM 

LOAD (CHANNEL "0P1 IONAL" (LOOK-UP .OBLIST)) 
#OECL ((VALUE) ' -DONE" 

(LOOK-UP) <OR OBLIST <LIST [REST <0R OBLIST 'DEFAULT>1») 
reads and evaluates all objects via an input CHANNEL 

LOCATIVE? (OBJECT) 
ifDECL ((VALUE) <OR 'T ' #FALSE ( )> 
(OBJECT) ANY) 
tells whether an object is a locative (predicate) 

LOG (NUMBER) 
#DECL ((VALUE) TLOAT 

(NUMBER) <OR FIX FLOAT>) 
returns natural logarithm of a number (arithmetic) 

LOGOUT ( ) 

#DECL ((VALUE) * *FALSE ()) 
logs oiii of the operating system (useful for background processes) 

LOOKUP (PNAME OBLIST) 
#DECL ((VALUE) <OR ATOM ' #FALSE ( )> 

(PNAME) STRING (OBLIST) OBLIST) 
returns an ATOM found on a given OBLIST 

LPARSE (-OPTIONAL" 

(STRING .PARSE-STRING) (RADIX 10) (LOOK-UP .OBLIST) PARSE-TABLE LOOK-AHEAD) 
#DECL ((VALUE) LIST 

(STRING) STRING (RADIX) FIX (PARSE-TABLE) VECTOR (LOOK-AHEAD) CHARACTER 
(LOOK-UP) <OR OBLIST <LIST [REST <OR OBLIST *DEFAULT>1») 

returns a LIST or the objects parsed from a STRING (sections 7.6.6.3. 15.7.2. 17.13) 

LSH (WORD AMOUNT) 
#DECL ((VALUE) WORD 

(WORD) <PRIMTYPE WORD> (AMOUNT) FIX) 
shifts bit.* in a machine word 

LVAL (ATOM "OPTIONAL" ENV) 
#DECL ((VALUE) ANY 

(ENV) <OR FRAME ENVIRONMENT ACTIVATION PROCESS>) 
returns the local value of an ATOM 



Appendix 2 



242 



The MDL Programming Language 






MAIN <) 

#OECL ((VALUE) PROCESS) 
returns #PROCESS 1 (t!ic main PROCESS) 

MANIFEST ("TUPLE" ATOMS) 
#DECL ((VALUE) 'T 

(ATOMS) < TUPLE [REST ATOM]>) 
declares the global values or ATOM.-, to be constant 

MANIFEST? (ATOM) 
#DECL ((VALUC) <OR 'T ' #FALSE ()> 
(ATOM) ATOM) 
tells whether the global value of an ATOM is constant (predicate) 

MAPF (FINAL-rCM LOOP-FCN "TUPLE" STRUCTURES) 
#OECL ((VALUE) ANY 

(FINAL-FCN) <0R APPLICABLE FALSE> (LOOP-FCN) APPLICABLE 
(STRUCTURES) <TUPLE [REST STRUCTURED }>) 

maps function iimn elements of structures 

MAPLEAVE ("OPTIONAL" (VAL T)) 
#OECL ( 

(VAl) ANY) 
leaves the most recent MAPF/R with a value 

MAPR (FINAL-FCN LOOP-FCN "TUPLE" STRUCTURES) 
#DECL ((VAl UE) ANY 

(FINAL-FCN) <0R APPLICABLE FALSE> (LOOP-FCN) APPLICABLE 
(STRUCTURES) <TUPLE [REST STRUCTURED ]>) 

■naps riiuclion onto RESTs of structures 

MAPRET ("TUPLE" ELEMENTS) 
#DECL ( 

(ELCHENTS) TUPLE) 
returns a variable number of objects to the current MAPF/R 

MAPSTOP ("TUPLE" ELEMENTS) 
*DECL ( 

(ELEMENTS) TUPLE) 
MAPRETs. then stops looping of MAPF/R and causes application 

MAX ("TUPLE" NUMBERS) 
#DECL ((VALUE) <0R FIX FLOAT> 

(NUMBERS) <TUPLE [REST <0R FIX FLOAT>]>) 
returns the greatest of its arguments (arithmetic) 






Appendix 2 



The MD1. Programming Language 



245 



ME ( ) 

#DFCI ((VAIIir) PROCESS) 
return* (lie currrut PROCESS 

MEMBCR (OBJCCT STRUCTURE) 
#DECL ((VAHIf) <0R 51RUCTIIRE0 ''FALSE ()> 

(OBJECT) ANY (STRUCTURE) STRUCTURED) 
fells whether an object is "structurally" equal to some element of a structure (predicate) 

MEMO (OB.UCT S1RUCTURF) 
#DECL ((VALUE) <0R STRUCTURED ''FALSE ()> 

(OBJECT) ANY (STRUCTURE) STRUCTURED) 
tells whether mi object is "exactly" equal to some element of a structure (predicate) 

HIN (■'TUPLE" NUMBERS) 
*DECL ((VALUE) <0R FIX FL0AT> 

(NUMBERS) < TUPLE TRCST < R FIX FL0AT>]>) 
returns the IcnM of Its argument* (arithmetic) 

MOBLIST (NAME "OPTIONAL" (LENGTH 13)) 
#DECL ( (VAI nr) onusT 

(NAME) ATOM (LENGTH) FIX) 
creatrs or pets an OBLIST 

MOO (NllMUMt MODUIUS) 
*DECL ((VALUE) FIX 

(NUMBER MODULUS) FIX) 
returns number-theoretic remainder (fixcd-poiiU residue) (arithmetic) 

MONAD? (OBJECT) 
#OECL ((VALUE) <OR 'T ''FALSE ()> 
(OBJECT) ANY) 
tells whether an object is eft her unstructured or an empty structure (predicate) 

N==? (OBJECT-1 OBJCCT-2) 
#DECL ((VAUir) <OR 'T "'FALSE ( )> 
(OBJECT -I OBJECT-?) ANY) 
fells whether I WO objects arc NOT "exactly" equal (predicate) 

N=? (OBJIC1-) OBJFCT-2) 
*DECL ((VALUE) <0R 'T '•'FALSE ( )> 
(OBOECT-l OBJECT-2) ANY) 
fells whether two objects arc NOT "structurally" equal (predicate) 



Appendix 2 



The MDL Programming Language 

NETACC (CHANHhL) 
#DECL ((VALUE) <OR CHANNEL 'ffALSE ( )> 
(CIIANNLL) CHANNEL) 
accepts a nctwnrL rnunrci ion 

NETS (CHANNEL) 

fDECL ((VAlUr CIIANNFL) CHANNEL) 
forces operating-system nei work- CHANNEL buffer (o be sent 

NETSTATE (CHANNEL) 
#OFCl ((VAIIII.) <UVrCTOR FIX FIX FIX> 
(CHANNEL) CHANNFL) 
returns Mate Information for a network CHANNEL 

NEWTY1T (HFV-7YPI Oin-TVfr "OPTIONAL- PATTERN) 
*DECL ((VAIUl NEW-TYPE) ATOM 

(OLO-TYPC) A10H (PATTERN) <0R ATOM FORM>) 
define* a new cl.ua type 

NEXT (ASSOCIATION) 
*OECL ((VALUE) <OR ASOC '#FALSE ()> 
(AS.SOriAIION) ASOC) 
returns the next object in the association chain 

NEXTCIIR ("OPTIONAL" (CHANNEL .INCHAN) (EOF-ROUTINE '<ERRQR >)) 

#DECL ((VAIUF) <OH CHARACTER FIX> 

(CHANNFL) CHANNEL (FOF-ROUTINE) ANY) 
return* the character that will next be read via an input CHANNEL 

NOT (OB.1ICT) 
*OECL ((VAIIJF) <OR 'T ' if FALSE ()> 
(OBJECT) <OR FALSE ANY>) 
computes logical ~noi" of a trutti-valuc 

NTH (STRUCTURED "OPTIONAL" N) 
<*DECL ((VALUE) ANY 

(N) <OR TIX OFFSET>) 
ferclies the Nilt rlenirm of A structure 

OBLI5T? (ATOM) 
#DECL ((VAIIJf) <OR OHLIST *#FALSE ()> 
(A10H) ATOM) 
rerun. i an ATOM's OBLIST or false if none (predicate) 







Appendix 2 






The MOl Programming Language 



245 



OFF (INURRUPT "OPTIONAL" WHICH) 
#DECL ((VA1UI) <OR HANDIER I HEADER '*FALSE ( )> 

(INTERRUPT) <0R HANDLER IHEADER STRING ATOM> (WHICH) <OR CHANNEL LOCATIVE>) 
removes an inlennpt HANOI ER or destroys an interrupt 

OFFSET (N RATTI UN) 
#OECI ((VA)Ut) OFFSET 

(N) FIX (PA1TERN) <0R ATOM FORH>) 
creates an iniegrr Willi attached type declaration 

ON (NAME APPLICABLE PRIORITY "OPTIONAL" (PROCESS 0) WHICH) 
#OCCL ((VALUE) HANDLER 

(NAME) COR STRING ATOM> (APPLICABLE) APPLICABLE (PRIORITY) FIX 
(PROCESS) <OR FIX PROCtSS> (WHICH) <OR CHANNEL LOCATIVE>) 

turns on an iuirtriipl and creaies an interrupt HANDLER 

OPEN ("OPTIONAL" ("ODE "READ") "TUPLE" FILE-NAME) 
#DECL ((VAUIl) <OR CHANNLL < FALSE STRING STRING FIX>> 
(NODE) STRING (FILE-NAME) TUPLE) 
creates and opens an I/O CHANNEL 

OPEN-NR ("OPUONAL" (MODE "READ") "1IIPLE" FILE-NAME) 
*DECL ((VALUE) <OR CHANNEL <FALSE STRING STRING FIX>> 
(MODD SIRING (FILE-NAME) TUPLE) 
creates and opens nn I/O CHANNEL without changing file's reference date 

OR ("ARC5" ARGS) 
*DECL ((VA1UC) <OR FALSE ANY> 
(ARGS) LIST ) 
computes logical Inclusive "or" of truth-values, evaluated by the Subroutine 

OR? ("TOPIC" TUPLE) 

#DECL ((VAIU1 ) <OR FALSE ANY> 
(TUPLE) TUPLE) 
computes logical inclusive "or" of truth-values, evaluated at call time 

ORB ("TUPLE" WORDS) 
#OECL ((VALUE) WORD 

(WORDS) <TUPLE (REST <PRIMTYPE WORO>]>) 
computes bitwise inclusive "or" of machine words 

OVERFLOW (-OPTIONAL" SWITCH) 
«»DECL ((VALUE) <OR *T ' #FALSE ()> 
(SWITCH) <OR ANY FALSE>) 
enables or disables overflow error (arithmetic) 



Appendix 2 



■ 



246 The MDL Programming Language 



PARSE ("OPTIONAL" 

(5IRING .CARSE-STRIHG) (RADIX 10) (LOOK-UP .OBLIST) PARSE-TABLE LOOK-AHEAD) 
'DECL ( (VAI UC ) ANY 

(STRING) SIRING (RADTX) FIX (PARSE-TABLE) VECTOR (LOOK-AHEAD) CHARACTER 
(LOOk-UP) <OH OBLIST <LIST [REST <OR OBLIST 'DEFAULT>]») 
parses a STRING iinn .in object (sections 7.6.6.2. 15.7.2. 17.1.3) 



PCODE (NAME OI-ISU) 
0DECL ((VAIUE) PCODE 

(NANF) SIRING (OFFSET) FIX) 
creates pointer to pure RSURR code 

PNAME (ATOM) 
*DECl ( (VAI UC) STRING 
(AIOM) ATOM) 
returns ihe prim-name of an ATOM as a disiiuct copy 

PRIMTYPE (05.HC1) 
#DECL ( (VAI HI ) AIOM 
(OBJECT ) ANY) 
returns (he primitive data type of an object 

PRIMTYPt-C ( TYPI^ ) 
#OECL ((VALUE) PRIMTYPE-C 
(TYPE) ATOM) 
gels a "storage allocai ion code" for a data type 

PRIN1 (OBJECT "OPTIONAL" (CHANNEL -OUTCHAN)) 
*DECL ((VAVtJE OBJECT) ANY 

(ctiANtjrt ) channtl) 

prints an object via an output CHANNEL 

PRINC (OIIJCCT "OPTIONAL" (CHANNEL .OUTCHAN)) 

*dfci ((VAiitr or..irci ) any 
(CHANNEL) CHANNEL} 
prims an Object via an oulpiil CHANNEL wilhoul STRING or CHARACTER brackets or ATOM trailers 

PRINT (On.lECT "0P1 IOUAt " (CHANNEL .OUTCHAN)) 
#DECL ((VALUE OBJECT) ANY 
(CHANNEL) CHANNEL) 
prints an object via an output CHANNEL between new-line and space 






Appendix 2 










The MDI. Programming Language 247 

PRINTB (BUFFCR CHANNEL) 
#DECL ((VALUE BUFFER) «0R UVECTOR STORAGE> [REST <PRIMTYPE W0RD>1> 
(CHANNEL) CHANNEL) 
writes biliary til format Ion via an output CHANNEL 

PRINTS1RING (BUFfER "OP1 IONAL" (CHANNEL -OUTCHAN) (COUNT <LENGTH .BUFFER>)) 
#OECL ((VALUE COUNT) FIX 

(BUFFER) STRING (CHANNEL) CHANNEL) 
writes contents of a SIRING via an output CHANNEL 

PRINTTYPE (TYPE "OPTIONAL" HOW) 
#DECL ((VALUE) <OR ATOM APPLICABLE ''FALSE ( )> 
(TYPE) ATOM (HOW) <0R ATOM APPLICABLE>) 
specifies or returns how a data type is printed 

PROCESS (STARTUP) 
#DECL ((VAIUE) PROCESS 

(STARTUP) APPLICABLE) 
creates a new PROCESS with given startup function 

PROG ("ARGS" ARGS) 
#DECL ((VALUE) ANY 

(ARGS) <LIST [OPT ATOM] LIST [OPT DECLl ANY» 
executes sequential expressions 

PURIFY ("TUPLE" TUPLE) 
#DECL ((VALUE) ANY 

(TUPLE) TUPLE) 
purifies objects for sharing by different operating-system processes 

PUT (ITEH INDICATOR "OPTIONAL" VAL) 
#OECL ( (VALUF) ANY 

(ITEM) <OR STRUCTURED ANY> (INDICATOR) <OR FIX OFFSET ANY> (VAL) ANY) 
stores into structure or doe» PUTPROP 

PUT-DECL (IDENTIFIER PATTERN) 
#DECL ((VALUE IDENTIFIER) <OR LOCO OFFSET> 
(PATTERN) <0R ATOM FORM>) 
changes the type declaration for an ATOM's value or an OFFSET 

PUTBITS (TO FIELO "OPTIONAL" (FROM 0)) 
#DECL ((VALUE) <PRIMTYPE WORD> 

(TO FROM) <PRIMTYPE W0RD> (FIELD) BITS) 
sets a bit field in .1 machine word 

Appendix 2 






248 The MDL Programming Language 

PUTPROP (ITEM INDICATOR -OPTIONAL" VAL) 
ZDECL ((VALUE) ANY 

(I MM INDICATOR VAL) ANY) 
(dis)associates a value with an item under an Indicator 

PUTREST (HEAD TAIL) 
*DECL ((VALUE HEAD) <PRIHTYPE LIST> 
(TAIL) <PRIHIYPE LIST>) 
replaces the rest of a list 

OUIT () 

#DECL ((VALUE) '/FALSE ()) 
exits from MDL gracefully 

QUITTER (WAS-TYPCO CHANNEL) 
#DECL ((VALUE WAS-TYPEO) CHARACTER 
(CHANNEL) CHANNEL) 
is Hie interrupt handler for ~G and ~S quit features 

QUOTE (-ARGS- ARGS) 
#DECL ((VALUE) ANY 
(ARGS) LIST) 
returns the first argument unevaluated 






RANDOM (-OPTIONAL- SEEO-1 SEEO-2) 
#DECL ((VALUE) FIX 

(SEED-1 SEED-Z) FIX) 
generates a uniform pseudo-random integer (arithmetic) 

READ ("OPTIONAL" 

(CHANNEL -INCHAN) (EOF-ROUTINE '<ERROR ...» (LOOK-UP .OBLIST) READ-TABLE) 
#DECL ((VALUE) ANY 

(CHANNEL) CHANNEL (EOF-ROUTINE) ANY (READ-TA8LE) VECTOR 
(LOOK-UP) <OR OBLIST <LIST [REST <OR OBLIST *DEFAULT>3>>) 
reads one object via an input CHANNEL (sections Il.l.l.l, IL3. IS.7.1. 17.1.3) 

READB (BUTTER CHANNEL "OPTIONAL- (EOF-ROUTINE '<ERROR ...>)) 
#DECL ((VALUE) FIX 

(BUFFER) «OR UVECTOR STORAGE> [REST <PRIMTYPE WORD>]> 

(CHANNEL) CHANNEL (EOF-ROUTINE) ANY) 
reads binary information via an input CHANNEL 



Appendix 2 



r 






L 



The MDL Programming Language 249 

READCHR ("OPTIONAL" (CHANNEL .INCI1AN) (EOF-ROUTINE '<ERROR ...>)) 
#DECL ((VALUE) <0R CHARACTER FIX> 

(CHANNEL) CHANNEL (EOF-ROUTINE) AMY) 
reads one character via an input CHANNEL 

REAOSTRING (BUFFER "OPTIONAL" (CHANNEL . INCHAN) (STOP <LENGTH .BUFFER>) 

(EOF-ROUTINE '<ERROR ..->)) 
*OECL ((VALUE) FIX 

(BUFFER) STRING (CHANNEL) CHANNEL (STOP) <OR FIX STRING> (EOF-ROUTINE) ANY) 
reads Into a STRING via an input CHANNEL 

REALTIMER ("OPTIONAL" INTERVAL) 
#DECL ((VALUE) <OR FIX FLOAT '#FALSE ( )> 
(INTERVAL) <OR FIX FLOAT>) 
sets or fetches interval for reai-linie interrupts (ITS version only) 

REMOVE (PNAHE "OPTIONAL" OBLIST) 
#DECL ((VALUE) <OR ATOM '#FALSE ()> 

(PNAHE) <OR ATOM STRING> (OBLIST) OBLIST) 
removes an AlOM from an OBLIST 

RENAME ("TUPLE" FILE-HAME/S) 
#DECL ((VALUE) <OR 'T <FALSE STRING FIX» 

(FILE-HAME/S) <TUPLE <OR STRING CHANNEL») 
renames or deletes a disk file 

REP {) 

#DECL ((VALUE) ANY) 
is the btiill-in function for READ-EVAL-PRINT loop 

REPEAT (-ARGS- ARGS) 
#DECL ((VALUE) ANY 

(ARGS) <LIST [OPT ATOM] LIST COPT OECL] ANY» 
executes sequential expressions repeatedly 

RESET (CHANNEL) 
#DECL ((VALUE) <OR CHANNEL <FALSE STRING STRING FIX» 
(CHANNEL) CHANNEL) 
reopens an I/O CHANNE-L at its beginning 

REST (STRUCTURED "OPTIONAL" (N 1)) 
#OECL ((VALUE) STRUCTURED 
(N) FIX) 
removes the first N elements from a structure and changes to primitive data type 

Appendix 2 



250 



The MDL Programming Language 



RESTORE ("OPTIONAL- NAME-1 NAME-3 NAME-3 NAHE-4) 
#DECL ((VALUE) '-REST0RE0" 

(NAHE-1 NAHE-2 NAME-3 NAME -A ) STRING) 
restores MDL'* stale from a file 

RESUME (VAL "OPTIONAL- (PROCESS <RESUMER>)) 
#DECL ((VALUE) ANY 

(VAL) ANY (PROCESS) PROCESS) 
transfers execution to another PROCESS 



" 



RESUHER ("OPTIONAL" (PROCESS <ME>)) 
#DECL ((VALUE) <0R PROCESS ''FALSE ( )> 
(PROCESS) PROCESS) 
returns the PROCESS that last resumed the given PROCESS 

RETRY ("OPTIONAL" FRAME) 
#DECL ( 

(FRAME) FRAME) 
retries a previous Subroutine call, usually from the error level 

RETURN ("OPTIONAL- (VAL T) (ACTIVATION .LPR0G\ ! -INTERRUPTS) ) 
#DECL ( (VALUE) ANY 

(VAL) ANY (ACTIVATION) ACTIVATION) 
leaves a PROG/REPEAT with a value 

RGLOC (ATOM "OPTIONAL" (MAKE-5LOT <>)) 
#DECL ((VALUE) LOCR 

(ATOM) ATOM (MAKE-SLOT) <0R FALSE ANY>) 
returns a locative to the global-value cell of an ATOM for pure-program use 

ROOT ( ) 

#0ECL ((VALUE) OSLIST) 
returns the OBLIST containing names of primitives 






ROT (WORD AMOUNT) 
#DECL ((VALUE) WORD 

(WORD) <PR1MTYPE WORD> (AMOUNT) FIX) 
rotates bits in a machine word 






RSU8R (CANDIDATE) 
#DECL ((VALUE) RSUBR 

(CANDIDATE) <VECT0R <0R CODE PC0DE> ATOM DECL [REST ANY1>) 
creates an RSUBR 






Appendix 2 



The MDL Programming Language 



251 



RSUBR-EN1RY (CANDIDATE OFFSET) 
#DECL ((VALUE) RSUBR-ENTRY 

(CANDIDATE) <VCCTOR <0R ATOM RSUBR> ATOH DECL> (OFF5ET) FIX) 
adds an entry point to ait RSURR 

RSUBR-LINk ("OPTIONAL" SWITCH) 
#DECL ((VAIIID <OR "T ' ("FALSE ()> 
(SWITCH) <0R FALSE ANY> ) 
enable* or disable, ilie automatic RSUBR linking feature 

RUNINT ("HUM I" 1I1PI E ) 
#DECL ((VALUE) ANY 

(IUTLE) TUPLE) 
applies intrrriipl liaudler (for internal use only) 

RUNTIMER ("OPTIONAL" IN1ERVAL) 
#DECL ((VALUE) <0R FIX FLOAT ' rFALSE ( )> 
(INTERVAL) <OR FIX FLOAT>) 
set* or Fetches interval For run>time interrupt (ITS version only) 

SAVE ( "TUPLE" FILE-NAME-AND-GC?) 
#OECL ((VAIUC) '"SAVED" 

(FII t-NAHr-ANTt-GC?) <TUPLE (OPT STRING] [OPT STRING] 

(OPT STRING] (OPT STRING] £OPT <0R FALSE ANY>]>) 
writes the entire Mate of MDL to a file 

SEND (OlHER-HAMt-1 01HCR-NAME-? BODY 

"OPTIONAL" (TYPE 0) (MY-NAME-1 <UNAME>) (MY-NAME-2 <JNAME>)) 
#OECL ((VALUE) <OR *T ( #FALSE ()> 

(OTIirR-NAMF-1 OTIIER-NAME-2 MY-NAME-1 MY-NAME-2) STRING (TYPE) FIX 
(BODY) <OR STRING STORAGE <UVECTOR [REST <PRIMTYPE WORO>]») 
sends an 1 PC message (ITS version only) 

SENO-WATT (OTHI R-MAMr-l OTHCR-NAME-2 BODY 

"OP1IONAI" (TYPE 0) (MY-NAME-1 <UNAME>) (MY-NAME-2 <0NAME>)) 
*DECL ((VALUE) 'T 

(OTIII -R-HAHE-1 OTIIER-NAME-2 MY-NAME-1 MY-NAME-2) STRING (TYPE) FIX 
(BODY) <OR STRING STORAGE <UVECTOR [REST CPRIMTYPE WORD>]») 
sends an IPC HteiUge ami wails for it to be received (ITS version only) 

SET (ATOH LVAL "OPTIONAL" ENV) 
*DECL ((VA1UF LVAI. ) ANY 

(ATOM) A10M (ENV) <OR FRAME ENVIRONMENT ACTIVATION PROCESS>) 
changes the local value of an ATOM 



Appendix 2 



SORT (PKID KFY-S1HUC "OPTIONAL" (RECORD-LENGTH 1) (KEY-OFFSET 0) 

"TUPLE" OTHER-SI RUCS-AND-RECORD-LENGTHS) 
#DECL ((VALUE KEY-5TRUC) <OR <PRIMTYPE VECTOR> <PRIMTYPE TUPLE> <PRIMTYPE UVECTOR>> 
(PREDl <OR TALSE APPLICABLE> (RECORD-LENGTH KEY-OFFSET) FIX 
( 01 UhR-S I RHCS-ANU-Rt CORD-LENGTHS) 

<TUPLE [REST <0R <PRTHTYPE VECTOR> <PRIMTYPE TUPLE> <PRIMTYPE UVECTOR>> FIX]>) 
sorts elements nf a structure anil rearranges other structures 

SPECIAL-CHECK ("OPTIONAL" SWITCH) 

#DECL ((VALUE) <0R 'T *#FALSE ( )> 
(SWITCH) <0R ANY TALSE>) 
turns interpreter sprcial-cherL iug on or off 

SPECIAL-MODE ("OPTIONAL" SWITCH) 
#DECL ((VAIUE) <OR 'SPFCIAL 'UNSPECIAL> 

(SWITCH) <0R 'SPECIAL »UNSPECIAL>) 
sets specialty declaration used by default 






252 The MDL Programming Language 

SETG (ATOM GVAL ) 
#DECL ((VAIIIt GVAL) ANY 
(ATOM) ATOM) 
changes the global value of an ATOM 

SETLOC (POINlrR OBJF.CT ) 
#DECL ((VAIUE OBJECT) ANY 
(POINTER) LOCATIVE) 
changes the contents pointed to by a locative 

SIN (NUMBER) 
#OECL ((VAIUE) FLOAT 

( Nullum) <OR fIX ILOAT>) 
returns sine of a number (arithmetic) 

SLEEP (<OR TIX TLOAT> "OPTIONAL" (UNHANG <>)) 
'OECL ( (VAI HI ) ANY 

(UNHANG) ANY) 
does nothing, inienupiihly. the given number of seconds 

SNAHE ("OPTIONAL" DIRFCTORY) 

#DECL ((VALUE DIRECTORY) STRING) 
sets or reiiiMis die dircciory name used by default for new I/O CHANNELS 









Appendix 2 



The MDL Programming Language 25S 

SPNAME (ATOM) 
#DECL ((VALUE) STRING 
(AlOH) ATOM) 
returns lite print-name of an ATOH by sharing it 

SORT (NUMBER) 
*DECL ((VA1 HE) FIOA1 

(HUMIUR) <OR FIX FLOAT>) 
returns squaic tool of a number (arithmetic) 

SOUOTA (SYMIIOI ) 
#DECL ((VALUE) <OR HX ''FALSE ( )> 
(SYMBOL) <PR1MTYPE WORO>) 
gets the address of au inicrual interpreter symbol (for internal use only) 

STACKFORM ("ARCS" ARCS) 
#DECL ((VALUE) ANY 
(ARCS) LIST) 
applies n fuuriioii to slacked arguments (archaic) 

STATE (PROCESS) 
*DECL ( (VALUE) ATOH 

(PROCESS) PROCESS) 
returns a PROCESS'S current stale 

STRCOMP (STRING-! STRING-2) 
#OECL ((VAUI1 ) <OR 'I '0 '-I> 

(STRIIJG-1 STRING-2) <0R ATOM STRING>> 
compares two chai aricr-Mrings or iwo print-names 

STRING ("TUPLE" Ht-HtNIS) 
#DECL ((VALUE) STRING 

(CLCMENTS) <TUPLE [REST <OR STRING CHARACTER>1>) 
creates a clmr.it tcr-string front explicit arguments 

STRUCTUREO? (OBJECT) 
#DECL ((VAIUE) <OR 'T ' 'FALSE ()> 
(OR.1FCT ) ANY) 
tells whether an object is structured (predicate) 

SUBSTITUTE (Nrw OtD) 
#DECL ((VAIUE 01 D) ANY 
(NEW) ANY) 
substitutes one object for another in Ihe entire address space 

Appendix 2 



254 The MDL Programming Language 

SUBSTRUC (TROH "OPTIONAL" (REST 0) (AMOUNT <- <LENGTH .080ECT> .REST>) TO) 
<*DECL ((VAIUL lO> <OK I 1ST VECTOR UVECTOR STRING BYTES> 

(FROM) <OR <PRIHTYPE LIST> <PRIHTYPE VECT0R> <PR1MTYPE TUPLE> 

<PRIMTYPE UVECT0R> <PRIMTYPE STRING> <PRIMTYPE BYTES>> 
(REST AMOUNT) TIX) 

copies (pari of) a structure Info anoihcr 

SUICIDE (UAL "OPTIONAL" (PROCESS <RESUMER>)) 
(■DECL ( (VA1 Ur ) ANY 

(UAL) ANY (PROCESS) PROCESS) 
causes the current PROCESS io die and resumes another 

TAG (LABI I) 
#DECL ((VALUE) TAG 

(LABEL) ATOM) 
creates a TAG for use by GO 

TERPRI ("OPTIONAL" (CHANNEL .OUTCHAN)) 
#DECL ((VALUE) ' *FALSE () 
(CHANNEL) CHANNEL) 
prints a carriagcrelum and linefeed via an output CHANNEL 

TIME ("TUPLE" IGNORED) 
• DECL ((VAUJI) riOAT 

(IGNORFD) TUPLE) 
returns the elapsed execution time in seconds 

TOP (SIRUCTURF) 
#DECL ((VALUE) <OR VEC10R TUPLE UVECTOR STORAGE STRING BYTES TEMPLATE> 
(STRUCTURE) <OR <PRIMTYPE VECTOR> <PRIHTYPE TUPLE> 

<PRIMTYPE UVECTOR> <PRIMTYPE ST0RAGE> 

<PRIHTYPE STRING> <PRIMTYPE BYTES> <PRIMTYPE TEMPLATE>>) 
replaces all elements removed from a non-list structure by RESTing and changes to primitive data 
type 

TTYECHO (CHANNEL SUI1CH) 
#D£CL ((VALUE CHANNEL) CHANNEL 
(SWITCH) <OR FALSE ANY>) 
turns echoing (of characters typed on a terminal) on or off 

TUPLE ("HIPLE" ELFHENTS) 
*DECL ((VALUE) TUPLE 

(ELIrirHTS) TUPLE) 
creates a TUPLE from rxplicit arguments 

Appendix 2 



" 












The M1)L I'm,; i .iiiniHMi; Language 



TYI ("0P1I0NAL" CHANNEL) 
#OECL ((VALUE) CHARACTER 
(CHANNEL) CHANNEL) 
inputs a CHARACTER from a terminal immediately 

TYPE (OO.irCT) 
#DECL ((VALUE) AIOH 
(OB0EC1 ) ANY) 

return* the? data typ* off an object 

TYPE-C (TYPE -OP110HAL- PR1MTYPE) 
JDECL ((VALUE) IYPE-C 

(TYPE PRIMTYPE) ATOM) 
makes a data-type ctndc for pure-program use 

TYPE-W (TYPE "OPTIONAL" PRIMTYPE RIGHT-HALF) 
#DECL ((VALUE) TYPE-W 

(TYPr PRIM1YPE) ATOM (RIGHT-HALF) <PRIMTYPE WOR0>) 
makes a data-type machine word for pure-program use 

TYPE? (OBJECT TUPLE" TYPES) 
#DECL ((VALUE) <OR ATOM '('FALSE ()> 

(OBJEC1) ANY (1YPES) <TUPLE ATOM [REST ATOM]>) 
tells whether an object** data type is one of the given types (predicate) 

TYPEPR1M (TYPD 
#DECL ((VALUE) AlOM 
(TYPE) ATOM) 
returns a daia type's primitive type 

UNAME ( ) 

*DECL ((VALUE) STRING) 
returns the "user name" of MDI.'s process 

UNASSIGN (ATOM "OPTIONAL" ENV) 
*DECL ((VALUE ATOM) ATOM 

(riJV) <OR TRAME ENVIRONMENT ACTIVATION PROCESS>) 
causes ail AlOM in have no local value 

UNMANITEST ("TUPLE" ATOMS) 
-OECL ((VALUE) 'T 

(AlOMS) <TUPLE [REST ATOMJ>) 
declares llie global values of ATOMs not to be constants 




Appendix 2 



256 The MOL Programming Language 

UNPARSE (OB.1ECT "OPIJONAL" RADIX) 
#DECL ((VALUE) SIRING 

(OBJECT) ANY (RADIX) FIX) 
creates a STRING representation of an objccl 

UNWINO ('NORMAL "CLEAN-UP) 
#OECL ((VALUE) ANY 

(NORMAL CLEAN-UP) ANY) 
specific* clr.ining-up during unn-local return 

UTYPE (UVLCTOR) 
#DECL ( (VAI HI ) AIOH 

(UVF.CIOK) <PRIM1YPE UVECTOR>) 
returns the dam type of all element* of a uniform vector 

uvecior ("TUPLE" CLEMENTS) 

#OECL ((VALUt ) UVECIOR 

(ELEMENTS) TUPLE) 
create* a UVECIOR from explicit arguments 

VALID-TVPE? (TYPE) 
#OECL ((VALUE) <0R TYPE-C '#FALSE ( )> 
(TYPD ATOM) 
tell* whether an ATOM i* tbf name of a type (predicate) 

VALRET (MESSAGE) 
*OECL ((VAIUE) '*rALSC () 

(MESSAGE) <OR STRING FIX>) 
passes a inev-aye to the superior operating-system process 

VALUE (ATOM "OPTIONAL" ENV) 
#DECL ((VALUE) ANY 

(ATOM) ATOM (ENV) <0R FRAME ENVIRONMENT ACTIVATION PROCESS>) 
returns the local or el">e the global value of an ATOM 

VECTOR ("TUPLE" ELEMENTS) 
#DECL ((VALUE) VECTOR 

(ELEMENTS) TUPLE) 
create* a VI CIOH from explicit arguments 

XONAME ( ) 

*DECL ((VALUE) STRING) 
returns the "intendrd job name" of MDL's process 



Appendix 2 



' 






The MD1. Programming Language 



257 



XORB ("TUPLE" WORDS) 
#DECL ( (VALUE) WORD 

(WORDS) OUPIE [REST <PRIHTYPE WORD>]>) 
compnicv bitwise exclusive "or" of machine words 

XUNAME ( ) 

#DECL ((VALUE) STRING) 
returns the "Intended u*er name" of Mill's process 



Appendix 2 



258 



The MDL Programming Language 



Appendix 3. Predefined Types 

On the** iwn page* i* B 'able showing each of MDL's predefined TYPEs. il$ primitive lype if 
different, an. I various HaRM S for STRUCTURED. E for EVALTYPE not QUOTE, and A for APPLICABLE. 

X means Mia! an object of (hat TYPE carina l be CHTYPEd to and hence cannot be READ in (if 
attempted, a CAN'T-CHTYPf- INTO error is usual). 

B meant Ihal an nlijeci of that TYPE cannot be READ in (if attempted, a STORAGE-TYPES-DIFFER 
error is uMial)< Hiat instead ii i» built by the interpreter or CHTYPEd to by a program, and that its 
PRINTerl representation mates it look as though its TYPEPRIM were different. 

•A means that an object of that TYPE is PRINTed using % notation and can be READ in only that way. 



TYPE 


TYPEPRIH 


S 


: a 


ACTIVATION 


1 RAW 




X 


ASOC 






B 


ATOM 








BITS 


WORT) 






BYTES 




S 




CHANNEL 


VECTOR 


s 


X 


CHARACTER 


WORD 






CLOSURE 


LIST 


s 


A 


CODE 


UVI ClOR 


s 




OECL 


LIST 


s 




DISMISS 


ATOM 






ENVIRONMENT 


1 RAIU 




B 


FALSE 


i IS1 


s 




FIX 


WORD 




A 


FLOAT 


WORD 






FORM 


LIST 


s 


E 


FRAME 






B 


rsuBR 


WORD 




A X 


FUNCTION 


LIST 


s 


A 


HANOLFR 


VECTOR 


s 


X 


IHEADER 


VECTOR 


5 


X 


ILLEGAL 


WORD 




X 


INTERNA! 


INTERNAL 


TYPE 


X 


LINK 


ATOM 




X 


LIST 




s 


E 


LOCA 






B 



comments 



sic: only one S 



can be relumed by interrupt handler 



"interrupt header" 

Garbage collector may put this on nou-LEGAL? object. 

should not be seen by programs 

for terminal shorthand 

locative to TUPLE 

Appendix 3 






The MDI. Prograimiiiii 


LOCAS 




LOCB 




LOCO 




LOCL 




LOCR 




LOCS 




LOCT 




LOCU 




LOCV 




LOSE 


WORD 


MACRO 


1 IS1 


OBLIST 


UVECTOR 


OFFSET 


OFFSET 


PCODE 


WORD 


PRIHTYPE-C 


WORD 


PROCESS 




QUICK-ENTRY 


VECTOR 


QUICK-KSUUR 


VECIOR 


READA 


FRAME 


RSUBR 


VFCTOR 


RSUBR-f-NTRY 


VFCIOR 


SEGMENT 


LIST 


SPLICE 


LIST 


STORAGE 




STRING 




SUBR 


WORD 


TAG 


VECTOR 


TEMPLATE 




TIME 


WORD 


TUPLE 




TYPE-C 


WORD 


TYPE-W 


WORD 


UNBOUND 


WORD 


UVECTOR 




VECTOR 




WORD 





ling Language 



259 



S 

s 

S E 
S 

s 
s 

s 
s 



X 
A X 

% 

'A 

B 
A X 

A X/B 

X 
A X/B 

A X 



A X 
X 

8 

B 

X 
X 
X 



locative lo ASOC 
locative to BYTES 

locative io C/LVAL 

locative fo LIST 

locative to GVAL in pure program 

locative to STRING 

locative to TEMPLATE 

locative to UVECTOR 

locative to VECTOR 

a place holder 



"pure code" 
'primtype code" 



S E 
S E 



an RSUBR-ENTRY that has been QCALLed and RSUBR- 

LINKed 
an RSUBR that lias been QCALLed and RSUBR-LINKed 
in eof slot during recursive READ via READ-TABLE 
if code vector is pure/impure, respectively 



for returning many things via READ-TABLE 
If possible, use FREEZE SUBR Instead. 



for non-local GOs 

The interpreter itself can't build one. See Lcbling (1979). 

used internally to identify FRAMEs 

vector on the control stack 

"type code" 

"type word" 

value of una&signed but bound ATOM, as seen by locatives 

"uniform vector" 



Appendix 3 



260 



The MDL Programming Language 



Appendix 4. Error Messages 



' 



This i\ a list nf all error-naming ATOM* initially in the ERRORS OBLIST. in the left-hand column, 
and appropriate example* or elucidations, where necessary, in the right-hand column. 






ACCESS-FAILURE 

ALREADY -PF r I NED- ERRET -NON-FALSE- TO-REDEFINE 
APPLY-OR-STACKFORM-OF-FSUBR 

ARC-WRONG- TYPE 
ARGUMENT -OUT- OF -RANGE 

ATOM-AI READY-THERE 

ATOM-HOT- 1 YPr-NAME-OR-SPECIAL-SYNBOL 

AlOM-ON-IUiJ f Ht N I -OIIL 1ST 

ATTEMPT -TO-BREAK-OWN-SEQUENCE 

AT TEMPT- TO- CHANGE -MAN IF EST- VARIABLE 

ATTEMPT- TO-CLOSE-TTY- CHANNEL 

ATTEMPT- lO-PM I R-UNDt FFRABLE-INTERRUPT 

AT TEMPT -TO-GROW- VECTOR- TOO-MUCH 
AT TEMP I - (O-MUNG-AIOHS-PNAME 
ATTEMPT -IO-MUNG- PURE -STRUCTURE 
ATTEMPT-TO-SUICIDE -TO-SELF 
BAD -ARGUMENT-LIST 
BAD -ASCI I -CHARACTER 



BAD-BYTES-DECL 

BAD-CHANNEL 

BAD-CLAUSE 

BAD-DrC! ARAT ION -LIST 

BAD-OLTAUI 1 -01U 1ST -SPECIF ICATION 

BAD-EH1RY-BL0CK 

BAD-EHVIROHMENT 
BAD-F1XUPS 
BAD-FUNARG 
BAD-GC-READ-FILE 



ACCESS, RESTORE (Tenex and Tops-20 
versions only) 

First argument to APPLY. STACKFORH. 
MAPF/R doesn't EVAL all its arguments. 

<ASCII 999>S Second argument to HTH 

or REST too big or small. 

<INSERT "T" <ROOT»S <LINK 'T "T" 

<ROOT>>S 

OECL problem 

INSERT. LINK. REMOVE 
<BREAK-SEQ T <ME»S 

<CL0SE ,INCHAN>S 

"Undeferable" interrupt (e.g. "ERROR") 

while INT-LEVEL is too high to handle it 

GROW argument greater than <« 16 1024> 

<PUT <SPNAME T> 1 !\T>S 

attempt to write into pure page 

<SUICIDE <HE»S 

<G0ECL ("HI") STRINOS 

A character with wrong byte size or 

ASCII code more than 177 octal has been 

read (how?). 



Argument to COND Is non-LIST or empty 

LIST. 

DECL ill bad form 

bad use of OEFAULT in LIST of OBLISTs 

RSUBR-ENTRY does not point to good 

RSUBR. 






CLOSURE in bad form 



Appendix 4 






The MDL Programming Language 



BAD-INPUT-BUFFER 

BAD-LINK 

BAD-MACRO-TABLE 

BAD-OBLIST-OR-LIST-THEREOF 

BAD-PARSE-SIRING 
BAD-PNAME 

BAD-PRIHTYPEC 

BAD- TEMPLATE -DATA 

BAD-TYPE-CODE 

BAD-TYPE-NAME 

BAD-TYPE -SPECIFICATION 

BAD-USE -OF-BYTE-STRING 

BAD-USE-Or-MACRO 

BAD-USE -Or -SQUIGGLY-BRACKETS 

BAD-VECTOR 

BYTE-SIZE-BAD 

CANT-CHTYPE-INTO 

CANT-F I ND- TEMPLATE 

CANT-OPEH-OUTPUT-FILE 
CANT-RE TRY-ENTRY-GONE 

CANT-SUBSTITUTE-WITH-STRING-OR-TUPLE-AND-OTHER 

CAN\'T-PARSE 

CHANNEL-CLOSED 

C0NTR0L-G7 

C0UNT-GREAUR-1HAN-S1 RING-SIZE 

DANGEROUS- INTERRUPT-NOT -HANDLED 

OATA-CANT-GO-IN-UNirORM-VECTOR 

DATA-CAN\ • T-GO-IN-STORAGE 

DECL-ELEMEN1 -NOT-FORM-OR-ATOM 

DECL-VIOLATION 

DEVICE-OR-SNAHE -DIFFERS 

ELEMENT -TYPE-NOT-ATOM-FORM-OR-VECTOR 

EMPTY-FORM- IN-DECL 

EMPTY-OR/PR IMTYPE-FORM 

EMPTY-STRING 

END-OF-FILE 

ERRET-TYPE-NAHE-DESIRED 

ERROR- IN-COMPILED-CODE 

FILE -NOT-FOUND 

FILE -SYS I EM-ERROR 



(for a CHANNEL) 

<GUNASSIGN <CHTYPE link ATOM>> 

.READ-TABLE or .PARSE-TABLE is not a 

vector. 

Alleged look-up list Is not of TYPE OBLIST 

or LIST. 

non-STRING argument to PARSE 

attempt to output ATOM with missing or 

zero-length PNAHE 



ATOM purports to be a TYPE but isn't. 

DECL problem 

#3S 

(is 

Bad argument to RSUBR-ENTRY 
■NET- CHANNEL 
<CHTYPE 1 SUBR>S 

attempt to GC-READ a structure containing 
a TEMPLATE whose TYPE does not exist 
SAVE 

attempt to RETRY a call to an RSUBR- 
ENTRY whose RSUBR cannot be found 
SUBSTITUTE "T" T>S 
<PARSE *">S <PARSE ■)">$ 
<READ <CLOSE chmnnol»S 
*G 

<PRINTSTRING -■ .OUTCHAN 1 >$ 
(See section 21.8.15.) (ITS version only) 
I [ "STRING- ]S ![<FRAME>1S 
FREEZE ISTORAGE 



RENAME 

DECL problem 

<0R> or <PRIMTYPE> in DECL 
<READSTRING "■>* 



RESTORE 



Appendix 4 



262 



FIRST-ARG-WRONG-TYPE 

FIRST-ELEMENT-OF-VECTOR-NOT-CODE 

FIRST- VECTOR-ELEMENT-NOT-REST-OR-A-FIX 

FRAME -NO- LONGER-EXISTS 

HANDLER- ALRE AD Y-IN-USE 

HAS-EMPTY-BODY 

ILLEGAL 

ILLEGAL- ARGUMENT-BLOCK 

ILLEGAL-FRAME 

ILLEGAL-LOCATIVE 

ILLEGAL-SEGMENT 

ILLEGAL-TENEX-FILE-NAME 

INT-OE VICE -WRONG-TYPE-EVALUATION-RESULT 

INTERNAL-BACK-OR-TOP-OF-A-LIST 
INTERNAL- INTERRUPT 
INTERRUPT-UNAVAILABLE-ON-TENEX 
ITS-CHANNFLS-FXIIAUSTED 

MEANINGLESS- PARAMETER-DECLARATION 

MESSAGC-TOO-BIG 

MUDDLE -VERS IONS-DIFFER 

NEGATIVE -ARGUMENT 

NIL-LIST-OF-OBLISTS 

NO-FIXUP-FILE 

NO- ITS-CHANNELS-FREE 
NO-MORE-PAGES 
NO-PROCESS-TO-RESUME 
NO-ROOM -AVA I I ABLE 

NO-SAV-FILE 

NO-STORAGE 

NON-6-BIT-CHARACTER-IN-FILE-NAME 

NON -APPLICABLE-REP 

NON -APPLICABLE-TYPE 

NON- ATOMIC- ARGUMENT 

NON-ATOMIC-OBLIST-NAME 

NON-DSK-DCVICE 

NON-EVALUATEABI F-TYPE 

NON-EXISTENT- TAG 

NON-STRUCTURE0-ARG-TO-INTERNAL-PUT-RE5T-NTH- 



The MDL Programming Language 



RSUBR in bad form. 

*DECL ((X) <LIST [F001>) 

(unused) 

<#FUNCTION ((X)> 1>* 

attempt to PRINT a TUPLE that no longer 
exists 



Third and later arguments to MAPF/R 

not STRUCTURED. 

(Tenex and Tops-20 versions only) 

function for "INT" input CHANNEL 

returned non-CHARACTER. 

in compiled code 

(unused) 

(Tenex and Tops-20 versions only) 

Interpreter couldn't open an ITS I/O 

channel. 

bad object in argument LIST of Function 

IPC (ITS version only) 

RESTORE (version ■ release) 

<SET OBLIST •()> TS 

MDL couldn't find fixup file (section 

19.9). 

IPC-ON (ITS version only) 

for pure-code mapping 

<OR <RESUMER> <RESUME»$ 

MDL couldn't allocate a page to map In 

pure code. 

MDL couldn't find pure-code file (section 

19.9). 

No free storage available for GROW. 

<VALUE REP> not APPLICABLE 



TI-3S 
(unused) 
(unused) 
(unused) 
TOP-OR-BACK in compiled code 






Appendix 4 



The MDL Programming Language 




NON-TYPE-FOR-PRIMTYPE-ARG 
NOT-A-TTY-TYPC -CHANNEL 
NOT-HANUI FD 
NOT-IN-ARG-LIST 

NOT-IN-MAP-rilNCT ION 

NOT-IN-PROG 

NTH -BY- A- NEGATIVE -NUMBER 

NTH-REST -PUT -OUT -Or -RANGE 

NULL-SIRING 

NUMBER -OUT -OF -RANGE 

ON-AN-ORL 1ST -ALREADY 

OUT-OF-BOUNDS 

OVERFLOW 

PDL-OVLRTI OW-BUFFER-EXHAUSTED 

PROCFSS-NOT -Rl SUMABLE 

PROCESS-NOT -RUNABLfc-OR-RESUMABLE 

PURE-LOAD-FAILURE 

READER-SYN1AX-TRROR-ERRET-ANYTHING-T0-GO-ON 

RSUBR-FN1RY-UNLINKLD 

RSUBR-IN-BAD-TORMAI 
RSUBR-LACKS-FIXUPS 

SECOND- ARG-WRONG- TYPE 
STORAGE-TYPES-niFFER 

STRUC TURF. -CON 1 AIN5-UN0UMPABLE -TYPE 

SUBSTITUTE-TYPE-FOR-TYPE 

TEMPLATE -TYPE -NAME -NOT-OF- TYPE-TEMPLATE 



TEMPLATE- I YPE-VIOLAT ION 

THIRD -ARG-WRONG -TYPE 

TOO-FFW-ARGUHI NTS-SUPPI 1ED 

TOO-MANY- ARGS-TO-PR1HIYPE-DECL 

TOO-MANY- ARGS-TO-SPEC I AL-UNSPECIAL-DECL 

TOO-MANY- ARGUMENTS-SUPPLIED 

TOP-LEVEL-hRAME 

TYPE-ALREADY-EXISTS 

TYPE-MISMATCH 

TYPE-UNDrriNEO 

TYPES-DIFFER-IN-SIORAGE-ORJECT 



<PRIMTYPE not-lype> in DECL 

First argumcnl lo OFF not ONcd. 

TUPLE or ITUPLE called outside argument 

LIST. 

MAPRET. MAPLEAVE, MAPSTOP not within 

MAPF/R 

<RETURN>S <AGAIN>S 

in compiled code 

in compiled code 

zero-length STRING 

2E38S 

< INSERT T <ROOT>>S 

<1 *{)>S BLOAT argument too large 

</ I 0>S <■ 1E30 1E30>S 

Slack overflow while trying to expand 

slack: use RETRY. 

use of another PROCESS'S FRAME, etc 

Pure-code file disappeared. 

RSUBR-ENTRY whose RSUBR cannot be 
found 

KEEP-FIXUPS should have been true when 
RSUBR was Input. 

<CHTYPE 1 LIST>S <CHUTYPE M t X ] 

LIST>S 

CGC-DUHP <ME> <>>$ 

SUBSTITUTE SUBR FSUBR>$ 

attempt to GC-READ a structure containing 

a TEMPLATE whose TYPE is defined but Is 

not a TEMPLATE 



<PRIMTYPE any . . .> 
<SPECIAL any .. .> 

<ERRET> <FRAME <FRAME <FRAME»>S 

NEWTYPE 

attempt to make a value violate it* DECL 

ISTORAGE 




Appendix 4 



264 



The MDL Programming Language 



TYPES-DI! I rR-]N-UNirORM-VECTOR 

UNASSIGNin- VARIABLE 

UNATTACIItn-r AIM-NAME -SEPARATOR 

UNBOUND-VARIABLE 

UNMATCIIHl 

UVECTOR-PUT-TYPE-VIOIATION 

VECTOR-l rSS-TflAN-?-CLCMCNTS 

WRONG-Olltl CI IOM-CIIAHNEL 

WRONG -NUMOER-Or- ARGUMENTS 



!CT <>]S 

!-S 

ENOBLOCK With no matching BLOCK 

PUT. SETLOC. SUBSTRUC in compiled 

code 

#OECL ((X) <LIST [REST]>) 

<OPEN "MYFILE->S (Mode missing or 

misspell.) 












Appendix 4 






The MDL Programming Language 

Appendix 5. Initial Settings 

The various switches and useful variables in MDL are initially set up wilh the following values: 

<ACTIVATE-CMARS <STRING <ASCII 7> <ASCII 19> <ASCII 15>» 

;"Tenex and Tops-20 versions only" 
<PECL-CIIECK T> 
<UMA5SIGN <GUNA5SIGN DEV» 
<GC-MOM <>> 

<S1 1 IMCIIAN <SETG INCIIAH <OPEN "READ" -TTY:">» 
CUHASSZGN KEEP-FIXUPS> 
<(INASSIGN <GUHASSIGN NH1» 
<HM ASSIGN <GUN ASSIGN NM2» 

<SM OBI 1ST <SEIG OBLIST (<MOBLIST INITIAL 151 > <ROOT>)» 
<SET 0I1TCHAN <SEIG OUTCHAN <OPEN -PRINT" ■TTY:">» 
<OVCRrLOW T> 
<UNASSJGN REDCriNE> 
<RStlBR-LlUK T> 

<SETG <UNASS1GN SNM> m wor king-director y"> 
<SPCCIAL-CIIECK <» 
<SPrCTAl -HODE UNSPECIAL> 

<SET TII1S-PR0CE5S <SETG 1HIS-PR0CESS <MAIN»> 
<0N "CHAR" .QUITTER 8 , INCHAN> 
<ON -IPC" .IPC-HANDLER 1> ;"ITS version only" 



Appendix 5 



The MDL Programming Language 
References 



Hewitt. Carl Planner; a l.ancwc for Manipulating M odel* and Pfovi„ g Theorems in a Robo t. 
Prnc- International Joint Conference on Artificial Intelligence. May 1969. 

LCb MXT. P I 97 D 9 ; Th e _MJ>L_Pro g ra,n,„in e Environ,,,™,. Laboratory for Computer Science. ■ 

M °W* n * VM A " MACIJSP *">"»« Manual. Laboratory for Computer Science. M.I.T.. April 



References 






The MDL Programming Language 



W7 



Topio Index 



parenthesized words refer to other item* in this index. 



arguments 
arithmetic 

array 

assignment 

binding 

bits 

block 

boolean 

bugs 

call 

change 

character 

circular 

comma 

comments 

comparison 

conditional 



•OPTIONAL" "TUPLE" "ARCS" (parameter) 

♦ - « / ABS EXP LOG SIN COS ATAN HIM MAX RANDOM OT IT «T LT CT L-T 

G=T NmT 

VECTOR UVECTOR TUPLE STRING BYTES TEMPLATE 

SET SETG OEFINE DEFMAC ENVIRONMENT (value parameter binding) 

BOUND? GBOUND? ASSIGNEO? GASSIGNED7 LEGAL? (assignment value parameter) 

WORD BITS PUTBITS GETBITS 8YTES ANDB ORB XORB EQVB LSH ROT 

BIND PROG REPEAT BLOCK ENDBLOCK OBLIST MOBLIST OBLIST? !- 

FALSE COND AND AND? OR OR? NOT (comparison) 

(errors) 

FORM APPLY APPLICABLE? EVAL SEGMENT 

PUT-DECL PUTPROP SET SETG (side effect) 

CHARACTER STRING ASCII PRINC READCHR NEXTCHR FLATSIZE LISTEN PARSE 
LPARSE UNPARSE 

PUTREST PUT LENGTH? FLATSIZE 

GVAL SETG 

; FUNCTION ASSOCIATION 

■ ■? N==? =7 Na? G? L=? L7 G=? 07 I? MAX HIN STRCOMP FLATSIZE LENGTH? 
(boolean) 

COND AND OR (boolean) 



Topic Index 



26S 



The MDL Programming Language 



concatenation 

coroutine 
data type 

decimal 
do 

dump 

errors 

escape 

execute 

exit 

file system 

goto 

graphics 

identifier 

if 

indexing 
input 

integer 

interrupts 

iteration 

leave 



SEGMENT STRING CONS 

PROCESS STATE RESUME SUICIOE RESUMER ME MAIN 8REAJC-SEQ ISTEP FREE-RUN 

TYPE TYPE? PRIMTYPE TYPEPRIH CHTYPE UTYPE CHUTYPE NEWTYPE PRINTTYPE 
APPLYTYPE EVALTYPE ALLTYPES VALI0-TYPE7 

(loops execute call) 

SAVE (output) 

FRAME ARGS FUNCT ERROR ERRORS ERRET RETRY UNWIND 

\ *G ~S *0 

EVAL APPLY QUOTE FSUBR "ARGS" (call) 

RETURN ACTIVATION (goto) 

FILECOPY FILE-LENGTH RENAME OPEN OPEN-NR CHANNEL FILE-EXIST57 NM1 NM2 
OEV SNM SNAME 

GO TAG UNWIND PROG REPEAT AGAIN RETURN ACTIVATION "ACT" (loop*) 

STORAGE IMAGE 

ATOM PNAME SPNAME LINK LOOKUP INSERT REMOVE 08LIST SPECIAL (parameter 
value) 

(conditional) 

NTH OFFSET GET PUT BACK TOP (loops) 

READ RCADCHR NEXTCHR READB REAOSTRING READ-TABLE GC-READ ECHOPAIR 
OPEN ACCESS LOAD FLOAD RESTORE RESET 

fix (arithmetic) 

EVENT HANDLER ON OFF ENABLE DISABLE INT-LEVEL DISMISS INTERRUPT 

(loops) 

(null) 

Topic Index 



The MDL Programming Language 



2«9 



loading 
location 
loops 

macro 

monitor 

multi-processing 

octal 

output 

parameter 

parentheses 

parse 

period 

pointer 

predicate 

primitives 

procedure 

quit 

real 

recursion 

search 

sharing 

side effect 



FLOAD SAVE RESTORE LOAD 
(pointer) 

REPEAT PROG RETURN GO ACTIVATION AGAIN HAPF MAPR ILIST IVECTOR 
IUVECTOR ISTRING I8YTES IFORH 

% %% LINK READ-TABLE PARSE-TABLE DEFHAC EXPAND MACRO 

■READ" "WRITE" 

(coroutine) 



PRINT PRIN1 PRINC PRINTB PRINTSTRING IMAGE GC-DUMP ECHOPAIR FLATSIZE 
SAVE TERPRI CRLF OPEN ACCESS RESET BUFOUT NETS 

FUNCTION ATOM LVAL SET SPECIAL UNSPECIAL (identifier value) 

LIST 

PARSE LPARSE PARSE -TABLE UNPARSE 

LVAL SET READ 

LOCATIVE AT IN SETLOC LIST 

(boolean) 

SUBR FSUBR ROOT GVAL SETG 

FUNCTION DEFINE DEFMAC GVAL CLOSURE 

~G ~S ~0 QUIT VALRET LOGOUT RETURN (loops) 

FLOAT (arithmetic) 

(always assumed and built in) 

MEMO MEMBER *? *=? (comparison) 

SEGMENT GROW SUBSTRUC 

PUT PUTREST SETLOC SUBSTRUC (change) 

Topic Index 



270 

sixbit 

storage 

structure 

subroutine 

temporary 

terminal 

text 

trailer 

true 

tty 

unbinding 
value 



The MDL Programming Language 



JNAME XJNAME SEND SENO-WAIT IPC-ON 

GC BLOAT BLOAT-STAT FREEZE TUPLE "EC" (structure) 

LIST VECTOR UVECTOR STRING BYTES TEMPLATE STRUCTURED? EMPTY? MONAD? 
LENGTH LENGTH? (concatenation) 

(procedure primitive) 

-AUX- BIND PROG REPEAT 

(»y> 

(character) 
!- OBLIST 
(boolean) 

LISTEN *L -G ~« *D rubout ECHOPAIR TTYECHO TYI "BLOCKED- -UNBLOCKED" 
ACTIVATE-CHARS (character) 

(binding) 

I^ GVAL VALUE IN SET SETG ENVIRONMENT ASSIGNED? GASSIGNED7 BOUND? 
GBOUND? -BIND- ACTIVATION "ACT" (parameter) RETURN (quit loops) 



Topic Index 



The MDL Programming Language 



271 



Name Index 






number refer* to a 
an unadorned page 
number refers in a secondary detcriplion. 



An uinlcTM-oreit |>nge 
primary de^crinl ion: 



■ 


Gl 


s 


17 




G7 




MO 


!-#FALSE (> 


1 13 


! . 


G7 20G 


!< 


fifi 20G 


!> 


GG 


!C 


51 


I\ 


Gl 100 


13 


54_ 


m 


2-1 55 100 


">" 


10 > 


"ACT" 


R4 87 


"ARGS" 


fi» 87 


"AUX" 


81 87 103 105 


■BIND- 


S3 8G 


"BLOCKED" 


182 187 


"CALL" 


83 87 


"CHAR" 


18-1 


"CLOCK" 


187 


"DIVFR1-AGC" 


1SG 105 


"OSK- 


10? 108 


"ERROR" 


188 


"CXTRA" 


81 87 


"GC" 


186 


"ILOPR" 


189 


" INFERIOR" 


183 


"INPUT" 


102 


"INT" 


113 


"IOC" 


1ST) 


-IPC" 


189 203 


"MPV" 


189 


"MUD" 


10* 


"MUDDLE" 


108 


"NAME" 


84 87 



■NET" 


114 


"OPT" 


78 86 137 


"OPTIONAL" 


78 81 86 137 


"PARITY" 


189 


■PRINT- 


101 


"PRINTS" 


101 


"PR1NT0" 


101 


"PURE" 


189 


"QUOTE" 


137 


"READ" 


101 105 184 187 211 


"READB" 


101 


"REALT" 


189 


■RUNT" 


189 


"SAVE- 


108 


■STY" 


112 


"SYS0OWN- 


1*3 


•TUPLE" 


79 87 105 IS7 


"UNBLOCKED" 


187 


"VALUE" 


137 


"WRITE" 


187 211 


* 


24 44 46 100 


5 


4 16 98 113 184 185 187 


X 


24 152 


XX 


152 



24 57 
24 54 
24 54 

23 28 151 159 
28 151 

24 31 
28 151 
23 24 32 



Name Index 



>72 



The MDL Programming Language 



0? 



•8 151 



71 



1? 


72 


1STEP 


175 


• 


24 40 


< 


24 


an? 


72 211 
72 93 



21 



AGS 


28 


ACCESS 


101 110 


ACTIVATE-CHAWS 151 


ACTIVATION 


8.1 150 183 193 205 


AGAIN 


85 90 150 175 


AGC-FLAG 


186 


ALLTYPES 


IG 


AND 


73 7G 185 


ANO* 


74 93 


ANOB 


Gfi 161 


ANY 


125 


APPLICABLE 


125 


APPLICABLf ? 


7-1 


APPLY 


■IS 88 


APPLYTYPE 


•1? 


ARGS 


118 I7G 


ASCII 


BJj 


ASOC 


123 IG9 218 


ASSIGNED? 


7G 79 175 187 


ASSOCIATIONS 


123 


AT 


.17 


ATAN 


in 


ATOM 


22 100 143 194 217 


AVAIUE 


123 


BACK 


GO 215 


BINARY 


ICG 


BIND 


84 90 


BITS 


IGO 



N. 



BLOAT 


186 196 




BLOAT-STAT 


198 




BLOCK 


142 145 




BLOCKED 


170 




BOUND? 


79 175 187 




BREAK -SEQ 


173 




BREAKER 


174 




BUFOUT 


101 111 115 




BYTE-SIZE 


66 




BYTES 


55 65 66 213 




CALLER 


164 




CHANLIST 


103 




CHANNEL 
CHARACTER 


65 101 102 103 104 122 
64 100 154 


CHTYPE 


45 211 




CHUTYPE 


64 216 




CLOSE 


103 




CLOSURE 


88 




CODE 


IG-1 




COMMENT 


122 




COND 


75 




CONS 


59 




COS 


40 




CRLF 


100 101 




DEAD 


170 170 




DECL 


124 223 




DECL-CHECK 


134 




DECL? 
DEFAULT 


135 
141 




DEFINE 


39 147 




DEFMAC 


156 




DEMSIG 


203 




DEV 


102 265 




DISABLE 


182 




DISMISS 


175 179 183 




ECHOPAIR 


101 113 146 




EMPTY? 
ENABLE 


74 
182 




ENDBLOCK 


142 MS 




ENTRY-LOC 


166 


• 


ENVIRONMENT 


37 83 84 




EQVB 


16J. 




ne Index 







The MDL Programming Language 



27S 






ERRF.T 


10 MS 175 222 


GCTL 


117 


ERROR 


18 147 183 20G 


GETPL 


117 


ERRORS 


142 I -17 20G 


GETPROP 


121 


EVAL 


20 -18 83 175 


GLOC 


117 165 


EVALTYPE 


•IS 


GO 


96 175 205 


EVENT 


178 179 181 


GROW 


60 186 


EVLIN 


175 


GUNASSIGN 


32 


EVLOUT 


175 


GVAL 


3139 41 117 169 193 194 208 


EXP 


■11 






EXPAND 


157 


HANDLER 


178 179 179 180 185 






HANG 


191 


FALSE 


71 






FBIN 


ir»7 


IBYTES 


66 


FILE-LENGTH 


IIU 110 


IFORM 


58 


FILE-EXISTS? 


ip_2 


IHEADER 


177 180 


FILECOPY 


101 111 


ILIST 


57 205 


FIX 


21 M 23 28 53 135 


ILLEGAL 


193 


FLATSIZE 


100 


IMAGE 


101 107 186 


FLOAD 


18 76 110 150 


IN 


116 118 119 


FLOAT 


22 23 


INCHAN 


103 146 


FORM 


27 33 58 71 


INDEX 


136 


FRAME 


1-17 MS 17G 193 213 


INDICATOR 


123 


FREE-RUN 


17'. 


INIT 


18 


FREEZE 


16-1 I8G 194 


INITIAL 


Ml 265 


FSAVE 


108 


INSERT 


M3 145 


FSUBR 


23 31 39 39 5G 74 74 75 89 90 


INT-LEVEL 


183 




«IG 131 M7 150 


INTERNAL 


258 


FUNCT 


MS I7G 


INTERNAL-TYPE 


258 


function 


27 


INTERRUPT 


181 190 


FUNCTION 


35 39 78 83 84 


INTERRUPT-HANDLER 186 


Function 


84 


INTERRUPTS 


142 177 






IPC-IIANDLER 


203 


G/LVAL 


1 IS 


IPC-OFF 


203 


G«? 


72 


IPC-ON 


203 


G? 


72 


ISTORAGE 


239 


G ASSIGNED? 


79 IS7 


ISTRING 


57 64 


GBOUND? 


79 132 193 


ITEM 


123 


GC 


ISG 195 


ITS 


17 18 102 108 112 US 114 115 


GC-DUMP 


101 107 199 




166 167 184 184 187 188 189 


GC-MON 


199 




189 189 195 202 202 


GC-READ 


101 107 ISG 199 


I TUPLE 


80 


GDECL 


131 


IUVECTOR 


57 


GET 


53 121 


IVECTOR 


57 


GET-DECL 


131 136 




■ 


GETBITS 


inn 







Name Index 



274 



The MDL Programming Language 



JNAME 


701 


MAPF 


91 92 






MAP LEAVE 


95 


KEEP-riXUPS 


167 2G5 


HAPR 


91 92 






MAPRET 


94 


L-INS 


!_«? 


HAPSTOP 


95 


L-OUTS 


MC 


MAX 


28 


L»? 


3 


ME 


174 195 


L? 


72 


MEMBER 


73 


LAST-OUT 


1 IG 


MEMO 


78 


LEGAL? 


HO 85 97 116 118 176 193 214 


MIN 


28 


LCNGTII 


52 75 


HOBLIST 


140 144 


LENGTH? ■ 


74 


MOO 


28 


LERR\ 


1 18 151 


MONAD? 


74 


LINK 


153 


MUDDLE 


18 108 142 


LIST 


54 57 57 59 68 72 186 204 212 








215 


N= = ? 


72 


LISTEN 


I IG 119 IG9 183 


N=? 


75 


LLOC 


11(9 175 193 


NBIN 


166 


LHAP\ 


RS 


NETACC 


115 


LOAD 


101 109 


NETS 


101 115 


LOCA 


117 


NETSTATE 


115 


LOCAS 


117 


NEUTYPE 


46 133 165 186 193 


LOCATIVE 


125 214 


NEXT 


123 


LOCATIVE? 


117 


NEXTCHR 


96 99 101 187 


LOCB 


117 


NH1 


102 265 


LOCD 


116 117 193 214 


NM2 


102 265 


LOCL 


117 


NOT 


73 


LOCR 


m 


NTH 


52 88 


LOCS 


m 






LOCT 


Ul 


OBLIST 


100 139 141 146 169 194 


LOCU 


m 


ODLIST? 


MO 


LOCV 


iJX 


OFF 


179 


LOG 


n 


OFFSET 


135 214 


LOGOUT 


202 


ON 


181 


LOOKUP 


143 


OPEN 


101 105 Ul 113 114 184 


LOSE 


58 61 G4 


OPEN-NR 


102 
127 


LPARSE 


G5 143 153 15G 


OPT 


LPROG\ 


no 


OPTIONAL 


127 


LSH 


IG2 


OR 


74 76 


LVAL 


32 37 I1G 119 !G9 175 193 208 


OR? 


74 93 






ORB 


1GI 


MACRO 


90 15G 


OUTCHAN 


49 103 128 146 


MAIN 


174 174 195 


OVERFLOW 


151 


MANIFEST 


131 






MANIFEST? 


132 


PARSE 


65 143 143 153 156 157 



Name Index 



The MDL Programming Language 



275 



PARSE-STRING 


156 


RESUMABLE 


170 


PARSE-TABLE 


153 


RESUME 


170 173 173 190 


PCODE 


IG'I 


RESUHER 


174 


PNAME 


22 14*1 217 


RETRY 


150 222 


PRIMTYPE 


•14 


RETURN 


85 90 175 


PRIMTYPE-C 


165 


RGLOC 


165 


PRIN1 


on 101 112 


ROOT 


141 145 


PRINC 


100 101 112 


ROT 


162 


PRINT 


20 23 48 99 101 112 141 


RSUBR 


147 163 165 194 


PRINTS 


101 106 


RSUBR-ENTRY 


147 166 


PRINTSTR1NG 


101 106 


RSUBR-LINK 


164 265 


PRINTTYPE 


18 


rubout 


17 98 113 


PROCESS 


146 169 170 190 193 219 


RUNABLE 


170 


PROG 


84 89 204 


RUNINT 


181 


PURE-PAGE-LOADER 186 


RUNNING 


170 


PURIFY 


108 186 194 199 


RUNTIMER 


IR9 


PUT 


53 56 68 88 120 






PUT-DECL 


134 136 


SAVE 


108 108 165 200 


PUTBITS 


161 


SEGMENT 


66 72 154 


PUTPROP 


120 


SEND 


202 


PUTREST 


V.) (i9 


SEND-WAIT 


202 






SET 


32 37 175 186 194 


QUICK-ENTRY 


164 259 


SETG 


30 37 186 194 


QUICK-RSUBR 


164 259 


SETLOC 


116 118 119 


QUIT 


202 


SIN 


40 


QUITTER 


184 


SLEEP 


191 


QUOTE 


56 82 83 


SNAME 


no 






SNM 


102 108 110 265 


RANDOM 


29 


SORT 


61 73 


READ 


20 22 99 101 122 140 142 153 


SORTX 


62 




187 


SPECIAL 


127 156 193 223 


READ-TABLE 


153 


SPECIAL-CHECK 


134 


READA 


154 


SPECIAL-MODE 


128 134 


READ8 


101 106 


SPLICE 


154 


READCHR 


96 99 101 105 112 113 187 


5PNAME 


144 


READSTRING 


101 106 112 


SORT 


40 


REALTIMER 


189 


SQUOTA 


253 


REOEFINE 


40 265 


STACKFORM 


96 


REMOVE 


143 145 


STATE 


170 


RENAME 


101 in 


STORAGE 


194 


REP 


146 


STRCOMP 


73 


REPEAT 


84 89 205 


STRING 


55 57 64 65 100 154 213 


RESET 


101 102 III 112 


STRUCTURED 


125 


REST 


52 56 75 126 219 


STRUCTURED? 


74 


RESTORE 


108 109 


SUBR 


28 31 147 




Na 


me Index 





276 



The MDL Programming Language 



Subroutine 


38 147 






SUBS! iitm 


1*19 


XJNAME 


201 


SUBSTRUC 


51 56 


XORB 


161 


SUICIDE 


17-1 


XUNAME 


201 


T 


71 


C 


24 54 


TAG 


90 193 






TEMPLATE 


55 KG 219 


\ 


25 55 100 154 


Tenex 


17 18 10? 108 113 li-; |M 115 








151 167 178 184 187 188 189 


] 


24 54 




189 180 189 227 






TERPRI 


7g ion ioi 


- 


4 107 


THIS-PROCESS 


174 174 


"9 


17 58 98 113 


TIME 


201 


-D 


17 98 113 


TO 


III 


-G 


17 150 184 


TOP 


60 215 


-L 


17 98 113 


TOPLEVEL 


I 18 


*0 


17 151 


TopS-20 


17 18 102 108 113 114 114 115 


"S 


17 146 151 184 




151 167 178 184 187 188 189 








189 189 189 227 


i 


24 55 


TTYECIIO 


101 113 MR 






TUPLE 


80 SO 193 214 


i 


24 55 


TYI 


101 113 187 187 






TYPE 


20 44 74 91 193 211 218 






TYPE-C 


165 






TYPE-W 


I6r» 






TYPE? 


74 






TYPEPRIH 


45 






UNAME 


20| 






UNASSIGN 


33 175 






UNBOUND 


218 259 






UNMANIFESI 


132 






UNPARSE 


65 144 






UNSPECIAI. 


127 221 223 






UNWIND 


1 50 223 






UTYPE 


63 






UVECTOR 


54 57 57 63 G5 204 213 217 






VALID-TYPE? 


46 






VALRET 


202 






VALUE 


33 124 175 






VECTOR 


54 57 57 63 186 204 212 216 








Name 


Index 





