THE AEROSPACE 

CORPORATION 

El Segundo, California 


AEROSPACE REPORT NO. 
ATR-94(4778)-4 


A Formal Description of the Incremental 
Translation of Stage 4 VHDL into State Deltas 
in SDVS 


30 September 1994 


Prepared by 
I. V. FILIPPENKO 

Trusted Computer Systems Department 
Computer Science and Technology Subdivision 
Computer Systems Division 
Engineering and Technology Group 


Prepared for 

DEPARTMENT OF DEFENSE 
Ft. George G. Meade, MD 20744-6000 


Engineering and Technology Group 


APPROVED FOR PUBLIC RELEASE; ^ 

DISTRIBUTION IS UNLIMITED .. 


19970929 121 





AEROSPACE REPORT NO. 
ATR-94(4778)-4 


A FORMAL DESCRIPTION OF THE INCREMENTAL TRANSLATION 
OF STAGE 4 VHDL INTO STATE DELTAS IN SDVS 


Prepared by 


I. V. FILIPPENKO 

Trusted Computer Systems Department 
Computer Science and Technology Subdivision 
Computer Systems Division 
Engineering and Technology Group 


30 September 1994 


Engineering and Technology Group 


THE AEROSPACE CORPORATION 
El Segundo, CA 90245-4691 


Prepared for 

DEPARTMENT OF DEFENSE 
Ft. George G. Meade, MD 20744-6000 


APPROVED FOR PUBLIC RELEASE; 
DISTRIBUTION IS UNLIMITED 





AEROSPACE REPORT NO. 
ATR-94(4778)-4 


A FORMAL DESCRIPTION OF THE INCREMENTAL TRANSLATION OF 
STAGE 4 VHDL INTO STATE DELTAS IN SDVS 


Prepared by 


I. V. Filippenko 


Approved by 

L. G. Marcus, Principal Investigator D. B. Baker, Director 

Computer Assurance Section Trusted Computer Systems Department 



Abstract 


This report documents a formal semantic specification of Stage 4 VHDL, a subset of the 
VHSIC Hardware Description Language (VHDL), via translation into the temporal logic of 
the State Delta Verification System (SDVS). Stage 4 VHDL is the fifth of successively more 
sophisticated VHDL subsets to be interfaced to SDVS. 

The specification is a continuation-style denotational semantics of Stage 4 VHDL in terms 
of state deltas^ the distinguishing logical formulas used by SDVS to describe state transi¬ 
tions. The semantics is basically specified in two phases. The first phase performs static 
semantic analysis, including type checking and other static error checking, and collects an 
environment for use by the second phase. The second phase performs the actual transla¬ 
tion of the subject Stage 4 VHDL description into state deltas. An abstract syntax tree 
transformation is interposed between the two translation phases. 

The translator specification was, for the most part, written in DL, the semantic metalan¬ 
guage of a denotational semantics specification system called DENOTE. DENOTE enables 
the semantic equations of the specification to be realized both as a printable representation 
(included in this report) and an executable Common Lisp program that constitutes the 
translator’s implementation. However, the second phase semantics of the VHDL simulation 
cycle has a direct operational implementation in the VHDL translator code. 


V 



Acknowledgments 


The author thanks his colleagues in the Computer Assurance Section for their support and 
contributions to the adaptation of SDVS to VHDL. 


VI 



Contents 


Abstract v 

Acknowledgments vi 

1 Introduction 1 

2 History of Our Semantic Approach to VHDL 4 

3 Overview of Stage 4 VHDL 5 

4 Preliminaries 9 

4.1 Environments. 9 

4.2 Continuations. 12 

4.3 Other Notation and Functions... 12 

5 Syntax of Stage 4 VHDL 14 

5.1 Syntactic Domains. 15 

5.2 Syntax Equations. 15 

5.2.1 Concrete Syntax. 16 

5.2.2 Abstract Syntax: Phase 1. 32 

5.2.3 Abstract Syntax: Phase 2. 34 

6 Phase 1: Static Semantic Analysis and Environment Collection 38 

6.1 Overview . 38 

6.2 Descriptors, Types, and Type Modes. 39 

6.2.1 Type and type descriptor predicates. 45 

6.2.2 Additional primitive accessors and predicates... 46 

6.3 Special-Purpose Environment Components and Functions. 49 

6.4 Phase 1 Semantic Domains and Functions. 50 

6.4.1 Phase 1 Semantic Domains. 51 

6.4.2 Phase 1 Semantic Functions. 52 

6.5 Phase 1 Semantic Equations. 55 

vii 




















6.5.1 Stage 4 VHDL Design Files. 55 

6.5.2 Design Units. 57 

6.5.3 Contex Items. 57 

6.5.4 Library Units . 57 

6.5.5 Configuration Declarations .. 58 

6.5.6 Entity Declarations. 60 

6.5.7 Architecture Bodies . 61 

6.5.8 Generic Declarations .. 61 

6.5.9 Port Declarations. 62 

6.5.10 Generic Maps and Port Maps. 63 

6.5.11 Declarations. 66 

6.5.12 Concurrent Statements .. 83 

6.5.13 Sensitivity Lists . 87 

6.5.14 Sequential Statements. 88 

6.5.15 Case Alternatives. 95 

6.5.16 Discrete Ranges . 96 

6.5.17 Waveforms and Transactions. 98 

6.5.18 Expressions. 98 

6.5.19 Primitive Semantic Equations. 105 

7 Interphase Abstract Syntax Tree Transformation 106 

7.1 Interphase Semantic Functions . 106 

7.2 Transformed Abstract Syntax of Names. 107 

7.3 Interphase Semantic Equations. 109 

7.3.1 Stage 4 VHDL Design Files. 109 

7.3.2 Design Units. 109 

7.3.3 Contex Items. 109 

7.3.4 Library Units. 109 

7.3.5 Configuration Declarations . 110 

7.3.6 Entity Declarations. 110 

7.3.7 Architecture Bodies . Ill 

viii 

































7.3.8 Generic Declarations. Ill 

7.3.9 Port Declarations. Ill 

7.3.10 Generic Maps and Port Maps. 112 

7.3.11 Declarations. .. 112 

7.3.12 Concurrent Statements „ .. 113 

7.3.13 Sensitivity Lists . 115 

7.3.14 Sequential Statements. 115 

7.3.15 Case Alternatives. 117 

7.3.16 Discrete Ranges . 117 

7.3.17 Waveforms and Transactions.. . 117 

7.3.18 Expressions .. 117 

8 Phase 2: State Delta Generation 121 

8.1 Phase 2 Semantic Domains and Functions. 121 

8.1.1 Phase 2 Semantic Domains .. 122 

8.1.2 Phase 2 Semantic Functions. 123 

8.2 Phase 2 Execution State. 125 

8.2.1 Unique Name Qualification. 125 

8.2.2 Universe Structure for Unique Dynamic Naming. 125 

8.2.3 Execution Stack. 128 

8.3 Special Functions. 130 

8.3.1 Operational Semantic Functions . 130 

8.3.2 Constructing State Deltas. 131 

8.3.3 Error Reporting . 132 

8.4 Phase 2 Semantic Equations. 133 

8.4.1 Stage 4 VHDL Design Files. 133 

8.4.2 Design Units. 138 

8.4.3 Contex Items. 138 

8.4.4 Library Units. 139 

8.4.5 Configuration Declarations . 139 

8.4.6 Entity Declarations. 140 


IX 
































8.4.7 Architecture Bodies . 140 

8.4.8 Declarations. 140 

8.4.9 Concurrent Statements .. 159 

8.4.10 Sequential Statements .. 160 

8.4.11 Waveforms and Transactions .. 179 

8.4.12 Expressions. 179 

8.4.13 Expression Types. 184 

8.4.14 Primitive Semantic Equations .. 186 

9 Conclusion 1^7' 

References 


X 










1 Introduction 


The State Delta Verification System (SDVS), under development over the course of several 
years at The Aerospace Corporation, is an automated verification system that aids in writing 
and checking proofs that a computer program or (design of a) digital device satisfies a formal 
specification. 

The long-term goal of the SDVS project is to create a production-quality verification system 
that is useful at all levels of the hierarchy of digital computer systems; our aim is to verify 
hardware from gate-level designs to high-level architecture, and to verify software from the 
microcode level to application programs written in high-level programming languages. We 
are currently extending the applicability of SDVS to both lower levels of hardware design 
and higher levels of computer programs. A technical overview of the system is provided by 
[1] and [2], while detailed information on the system may be found in [3] and [4]. 

Several features distinguish SDVS from other verification systems (refer to [5] for a detailed 
discussion). The underlying temporal logic of SDVS, called the state delta logic, has a 
formal model-theoretic semantics. SDVS is equipped with a theorem prover that runs in 
interactive or batch modes; the user supplies high-level proof commands, while many low- 
level proof steps are executed automatically. One of the more distinctive features of SDVS 
is its flexibility — there is a well-defined and relatively straightforward method of adapting 
the system to arbitrary application languages (to date: ISPS, Ada, and VHDL). Further¬ 
more, descriptions in the application languages potentially serve as either specifications or 
implementations in the verification paradigm. Incorporation of a given application language 
is accomplished by translation to the state delta logic via a Common Lisp translator pro¬ 
gram, which is (generally) automatically derived from a formal denotational semantics for 
the application language. 

Prior to 1987 we adapted SDVS to handle a subset of the hardware description language 
ISPS. However, ISPS has serious limitations regarding the specification of hardware at levels 
other than the register transfer level. In fiscal year 1988 we documented a study of some 
of the hardware verification research being conducted outside Aerospace and investigated 
VHDL (VHSIC Hardware Description Language), an IEEE and DoD standard hardware 
description language released in December 1987. We selected VHDL as a possible medium 
for hardware description within SDVS. 

The aim of the ongoing formal hardware verification effort in SDVS is to verify hardware 
descriptions written in VHDL. This choice of hardware description language is particu¬ 
larly well-suited to our overall aim of verifying hardware designs across the spectrum from 
gate-level designs to high-level architectures. Indeed, the primary hardware abstraction in 
VHDL, the design entity, represents any portion of a hardware design that has well-defined 
inputs and outputs and performs a well-defined function. As such, “a design entity may 
represent an entire system, a sub-system, a board, a chip, a macro-cell, a logic gate, or any 
level of abstraction in between” [6]. 

Prerequisites for adapting SDVS to VHDL are (1) to define VHDL semantics formally in 
terms of SDVS’s underlying logic (the state delta logic) and (2) to implement a translator 
from VHDL to the state delta logic. As with the incorporation of Ada into SDVS [7], the 


1 



approach taken with VHDL has been to implement increasingly complex language subsets; 
this has enabled a graded, structured approach to hardware verification. 

In fiscal year 1989 we defined an initial subset of VHDL, called Core VHDL, that cap¬ 
tured the most essential behavioral features of VHDL, including: ENTITY declarations; 
ARCHITECTURE bodies; CONSTANT, VARIABLE, SIGNAL, and PORT declarations; predefined 
types BOOLEAN, BIT, BIT_VECTOR, and INTEGER; variable and signal assignment statements; 
IF, CASE, WAIT, and NULL statements; and concurrent PROCESS statements. We defined both 
the concrete syntax and the abstract syntax for Core VHDL, formally specified its seman¬ 
tics and, on the basis of this semantic definition, implemented a Core-VHDL-to-state-delta 
translator [8]. 

In fiscal year 1990, SDVS was enhanced to provide the capability of verifying hardware 
descriptions written in Core VHDL [9, 10]. In fiscal year 1991, the translator underwent ex¬ 
tensive revision to accommodate a second VHDL subset. Stage 1 VHDL [11], which included: 
WAIT statements in arbitrary contexts; LOOP, WHILE, and EXIT statements; TRANSPORT delay; 
aggregate signal assignments; and a revised translator structure. 

Implemented in fiscal year 1992, Stage 2 VHDL provided a considerably more complex and 
capable VHDL language subset. Stage 2 VHDL extended Stage 1 VHDL with the addition 
of the following VHDL language features: (restricted) design files, declarative parts in 
entity declarations, package STANDARD (containing predefined types BOOLEAN, BIT, INTEGER, 
TIME, CHARACTER, REAL, STRING, and BIT-VECTOR), user-defined packages, USE clauses, array 
type declarations, enumeration types, subprograms (procedures and functions, excluding 
parameters of object class SIGNAL), concurrent signal assignment statements, FOR loops, 
octal and hexadecimal representations of bitstrings, default object class SIGNAL for ports, 
and general expressions of type TIME in AFTER clauses. 

The VHDL language subset implemented in fiscal year 1993, Stage 3 VHDL, extended Stage 
2 VHDL with the addition of subtypes of scalar types, integer type definitions, and type 
conversions between integer types. Furthermore, the capability was added to set “statement 
marks” (in the form of interpreted comments) for sequential statements. Finally, a facility 
for specifying, proving, and invoking the behavior of a VHDL subprogram — VHDL offline 
characterization — was implemented [3]. The SDVS VHDL and Ada translators were 
reengineered to a uniform implementation reflecting language similarities where these exist, 
and optimized for greater space- and time-efficiency. 

Stage 4 VHDL, implemented in fiscal year 1994, comprises a significantly more powerful 
subset of VHDL than did previous stages, in that Stage 4 VHDL admits the structural 
description of hardware in terms of its hierarchical decomposition into connected subcom¬ 
ponents as outbned in [12]. The previous versions of the SDVS VHDL translator handled 
only behavioral (e.g., algorithmic or dataflow) hardware descriptions. Thus, Stage 4 VHDL 
incorporates language constructs such as component declarations, component instantiation 
statements, BLOCK statements, generics, generic maps, port maps, and configuration decla¬ 
rations. 

The purpose of the present report is to provide a formal description of the translation of 
Stage 4 VHDL hardware descriptions into state deltas. This amounts to a formal semantic 
specification of Stage 4 VHDL, presented herein as a continuation-style denotational seman- 


2 



tics [13] for which the state delta language provides the semantic domain. The translation 
basically consists of parsing followed by two semantic analysis phases. 

The first phase receives the abstract syntax tree generated by the Stage 4 VHDL parser for 
a given hardware description, and: 

• performs static semantic analysis, including type checking; 

• collects an environment that associates all names declared in the subject Stage 4 
VHDL hardware description with their attributes; 

• appropriately disambiguates identical names declared in different scopes, as required 
by the static block structure of the hardware description; and 

• for the convenience of the second phase, transforms the abstract syntax tree of the 
subject hardware description. 

Phase 2 receives the transformed abstract syntax tree and the environment constructed by 
Phase 1, and uses these to translate the Stage 4 VHDL hardware description into state 
deltas. This translation is incremental, in the sense that it is driven by symbolic execution 
of the hardware description, producing further state deltas as symbolic execution proceeds. 

The Stage 4 VHDL formal description is an extensive revision and expansion of the formal 
specifications of the Core VHDL, Stage 1 VHDL, Stage 2, and Stage 3 VHDL translators 
[8, 11, 14, 15]. The Stage 4 VHDL translator specification was written in DL, the semantic 
metalanguage of a denotational semantics specification system called DENOTE [16]. DE¬ 
NOTE enables the semantic equations of the specification to be automatically translated 
into both a printable representation (included in this report) and an executable Common 
Lisp program that constitutes the translator’s implementation. 

This report is organized as follows. 

• Our approach to the semantics of Stage 4 VHDL is discussed in Section 2. 

• Section 3 contains an overview of the Stage 4 VHDL subset. 

• Section 4 provides preliminary information (background and notation) on the partic¬ 
ular method of semantic description used. 

• Section 5 lists both the concrete and abstract syntax of Stage 4 VHDL. 

• Section 6 presents the Stage 4 VHDL static semantics. 

• Section 7 presents the interphase abstract syntax tree transformation. 

• Section 8 presents the Stage 4 VHDL dynamic semantics in terms of state deltas. 

• Finally, some concluding remarks are made in Section 9. 


3 




2 History of Our Semantic Approach to VHDL 


The VHDL translator essentially functions as a simulator kernel, maiintaining a clock and 
a list of future events that are defined as state deltas. For Core VHDL (fiscal years 1989 
and 1990), the translator transformed possibly multiple Core VHDL statements: sequential 
statements between WAIT statements within a process were all translated and then composed 
into a single state delta. The translator updated the clock to the next time at which a signal 
driver became active or a process resumed. As the clock advanced, the translator merged 
the composite state deltas into a single state delta that specified the behavior of all processes 
at that point in the execution. 

For Stage 1 VHDL (fiscal year 1991), we re-evaluated the feasibility of using composition 
in the translation of VHDL to state deltas, and concluded that although composition had 
initially seemed viable in the case of Core VHDL, it is impossible in principle to apply 
the technique to more complex VHDL subsets, as the attempt would require the ability to 
compose over sections of VHDL code that would necessitate static proof in SDVS. More 
generally, the ability to compose over arbitrary WAIT-bracketed code in PROCESS statements 
would be tantamount to the automatic construction of correctness proofs without user 
intervention — a theoreticaUy undecidable problem. 

Therefore, we abandoned composition for Stage 1 VHDL and subsequent SDVS VHDL 
subsets. Instead, within a given execution (simulation) cycle, processes are translated se¬ 
quentially, in the order in which they appear in the VHDL description, and the user has 
control over stepping through the sequential statements within each process. Thus, rather 
than trying to have the VHDL translator model the concurrency of the processes, we choose 
to take for granted a certain “metatheorem” about VHDL: that any two sequentializations 
of the processes are equivalent. A brief justification for this point of view is that the problem 
of mutual exclusion is not a concern in VHDL, since 

• all variables are local to the process in which they are declared, and 

• distinct processes modify distinct drivers of a given signal (known as a resolved signal), 
and the ultimate signal value is obtained by application of a user-defined resolution 
function.^ 

A gratifying benefit of the revised translation strategy is that the understandability of the 
resulting proofs has been remarkably improved — the dynamic flow of process execution 
precisely reflects the simulation semantics of VHDL (as defined in the VHDL Language 
Reference Manual [6]), but with the crucial aspect of symbolic execution (use of abstract 
values rather than concrete) thrown in. The current Stage 4 VHDL translator thus functions 
as a “symbolic simulator,” with the effect of being reasonably intuitive as a proof engine. 


^ As of Stage 4 VHDL, however, resolved signals are still disallowed. 




3 Overview of Stage 4 VHDL 


The primary VHDL abstraction for modeling a digital device is the design entity. A design 
entity consists of two parts: an entity declaration and an architecture body. The entity 
declaration provides the “external view” of the device: it defines the interface between 
the design entity and its environment, including the number, direction, and type of ports, 
and corresponds to a symbol in a traditional CAE (Computer-Aided Engineering) design 
methodology. The architecture body provides the “internal view” of the device, describing 
its behavior or structure, and thereby expressing the relationship between its inputs and 
outputs, A given entity declaration may be shared by several design entities, each with a 
different architecture body. 

In Stage 4 VHDL, each architecture body consists of a set of declarations and concurrent 
statements defining the structure or function of the device being modeled. The allowable 
concurrent statements are of four kinds, to be discussed below: PROCESS statements, con¬ 
current signal assignment statements (conditional and selected), BLOCK statements, and 
component instantiation statements. 

The special case of a structural architecture, in particular, corresponds to the CAE notion of 
a schematic. A structural architecture for a design entity is described by declaring internal 
signals and connecting these, as well as the ports of the entity declaration, to the ports 
of various subcomponents declared in component declarations and created by component 
instantiation statements in the architecture body. 

Component declarations provide a “template” mechanism, whereby an architecture body 
containing component instantiations can be analyzed — checked for syntactic and semantic 
correctness — independently of prior analysis of entity declarations for those components. 
This is accomplished by having the instantiations refer not to entity declarations, but to 
component declarations. 

The configuration declaration provides the mechanism whereby architecture bodies are 
paired with entity declarations to configure specific design entities. A configuration dec¬ 
laration is analogous to a “parts list,” describing which part to use for each component 
of a design. (The configuration specification^ an essentiaUy equivalent alternative, is not 
supported by Stage 4 VHDL.) 

A component instantiation statement specifies an instance of a child component occurring 
inside a parent component. At the point of instantiation, only the external view of the 
child component — the names, types, and directions of its ports — is visible; the child 
component’s internal signals are not visible. The component instantiation statement iden¬ 
tifies the child component and specifies which ports or signals in the parent component 
are connected to which ports in the child component. Component instantiation statements 
are transformed, in a manner prescribed by the VHDL LRM [6], to pairs of nested BLOCK 
statements during the elaboration of a VHDL design entity prior to its execution. A BLOCK 
statement provides a block-structured scope with local declarations and a body consisting 
of concurrent statements. Elaboration of a design entity recursively transforms component 
instantiation statements occuring in BLOCK statements until the innermost blocks contain 
only PROCESS and concurrent signal assignment statements. 


5 



A PROCESS statement, the most fundamental kind of concurrent statement in VHDL, is a 
block of sequential zero-time statements that execute sequentially but “instantaneously” in 
zero time [17], and some (possibly none) distinguished sequential WAIT statements whose 
purpose is to suspend process execution and allow time to elapse. 

A process typically schedules future values to appear on data holders called signals, by 
means of sequential signal assignment statements. The execution of a signal assignment 
statement does not immediately update the value of the target signal (the signal assigned 
to); rather, it updates the driver associated with the signal by placing (at least one) new 
transaction, or time-value pair, on the waveform that is the list of such transactions con¬ 
tained in the driver. Each transaction projects that the signal will assume the indicated 
value at the indicated time; the time is computed as the sum of the current clock time of the 
model and the delay specified (explicitly or implicitly) by the signal assignment statement. 

Two types of time delay can be specified by a sequential signal assignment statement, and 
Stage 4 VHDL encompasses both. Inertial delay, the default, models a target signal’s inertia 
that must be overcome in order for the signal to change value; that is, the scheduled new 
value must persist for at least the time period specified by the delay in order actually to 
be attained by the target signal. Transport delay, on the other hand, must be explicitly 
indicated in the signal assignment statement with the reserved word TRANSPORT, and models 
a “wire delay” wherein any pulse of whatever duration is propagated to the target signal 
after the specified delay. 

In lieu of explicit WAITs, a process may have a sensitivity list of signals that activate process 
resumption upon receiving a distinct new value (an event). The sensitivity list impbcitly 
inserts a WAIT statement as the last statement of the process body. 

Concurrent signal assignment statements always represent equivalent PROCESS statements, 
and come in two varieties: conditional signal assignment and selected signal assignment. 
A conditional signal cissignment is equivalent to a process with an embedded IF statement 
whose branches are sequential signal assignments; similarly, a selected signal assignment 
is equivalent to a process with an embedded (possibly degenerate) CASE statement whose 
branches are sequential signal assignments. The VHDL translator syntactically transforms 
concurrent signal assignment statements to their corresponding PROCESS statements before 
translating them into state deltas. , 

Signals act as data pathways between processes. Each process applies operations to values 
being passed through the design entity. We may regard a process ais a program implementing 
an algorithm, and a Stage 4 VHDL description as a collection of independent programs 
running in parallel. 

In full VHDL, a target signal can be assigned to in multiple processes, in which ca.se it 
possesses correspondingly many drivers for updating by the different processes; the value 
taken on by the signal at any particular time is then computed by a user-defined resolution 
function of these drivers. 

Currently Stage 4 VHDL disallows such resolved signals: a signal is not permitted to appear 
as the target of a sequential signal assignment statement in more than one process body; 
equivalently, every signal has a unique driver. Resolved signals and their resolution functions 


6 



will be implemented in a future version of SDVS. 

The Stage 4 VHDL data types are: BOOLEAN, BIT, UNIVERSAL_INTEGER, INTEGER, REAL (pre¬ 
liminary version), TIME (a predefined physical type of INTEGER range), CHARACTER, STRING 
(arrays of characters), BIT.VECTOR (arrays of bits), user-defined enumeration types, user- 
defined array types, subtypes of scalar types, and integer type definitions. Furthermore, 
explicit type conversions between integer types are allowed. The preliminary implemen¬ 
tation allows VHDL descriptions involving type REAL to be parsed and translated, but 
provides no support for reasoning about floating point numbers. 

Concrete and abstract syntaxes for Stage 4 VHDL have been defined — see Section 5 — as 
required, of course, for the implementation of the Stage 4 VHDL translator. The following 
is a convenient synopsis of the Stage 4 VHDL language subset. 

• VHDL design files 

- design units 

• package STANDARD 

- predefined types: BOOLEAN, BIT, INTEGER, TIME, CHARACTER, REAL, STRING, BIT^VECTOR 

- various units of type TIME: FS, PS, NS, US, MS, SEC, MIN, HR 

- restriction: implementation of type REAL is prebminary 

• user-defined packages 

- package declarations 
“ package bodies 

• USE clauses for accessing packages 

• entity declarations 

- entity header: generics, port declarations 

- entity declarative part: other declarations 

• architecture bodies 

• configuration declarations 

- generic maps, port maps 

• object declarations 

- CONSTANT, VARIABLE,SIGNAL 

- octal and hexadecimal representations of bitstrings 

- entity ports of default object class SIGNAL 

• array type declarations 

- arrays (bidirectional; constrained or not) of arbitrary element type 


7 



“ attributes ^low and ’high for lower and upper bounds of an array type (restric¬ 
tion: but not of an object of type array) 

• user-defined enumeration types 

• subtypes of scalar types 

• integer type definitions 

• type conversion 

• signals of arbitrary types 

• subprograms 

- procedures and functions: declarations and bodies 

- restriction: excluding parameters of object class SIGNAL 

• concurrent statements 

- PROCESS statements 

- conditional signal assignments 

- selected signal assignments 

- BLOCK statements 

- component instantiation statements 

• sequential statements 

- null statement: NULL 

- variable assignments (scalar and composite) 

- signal assignments (scalar and composite, inertial or TRANSPORT delay) 

- conditionals: IF, CASE 

- loops: LOOP, WHILE, FOR 

- loop exits: EXIT 

- subprogram calls 

- subprogram return: RETURN 

- process suspension: WAIT 

• operators 

- numeric unary operators: ABS, +, - 

- numeric binary operators: +, /, (exponentiation), MOD (modulus), 

REM (remainder) 

- boolean and bit operators: NOT, AND, HAND, OR, NOR, XOR 

- relational operators: =, /=, <, <=, >, and >= 

- array concatenation operator: k 

- restriction: =, /=, and k are the only Stage 4 VHDL operators defined for user- 
defined array types 


8 


4 Preliminaries 


The purpose of this section is to provide some of the background and notation necessary 
for the research documented in this report. It is assumed that the reader is familiar with 

• the descriptive aspects of the denotational technique for expressing the semantics 
of programming languages (including concepts such as syntax, semantic functions, 
lambda notation, curried function notation, environments, and continuations) as pre¬ 
sented in [13]; and 

• the theory and practice of state deltas [3, 18, 19]. 

Denotational semantic definitions of programming languages consist of two parts: syntax 
and semantics. The syntax part consists of domain equations (equivalent to productions of 
a context-free grammar) that define the syntactic variables (analogous to grammar nonter¬ 
minals) and the (abstract) syntactic elements of the language. The semantic part defines a 
semantic function for each syntactic variable and the definition (by syntactic cases) of these 
functions; it also defines auxiliary functions that are used in the definition of the semantic 
functions. The semantic functions constitute a syntax-directed mapping from the syntactic 
constructs of the language to their corresponding semantics. 

Certain principal notions, among which are environments and continuations^ are central to 
standard denotational semantic definitions of programming languages. 

4.1 Environments 

Environments are functions from identifiers to their “definitions”; these definitions are called 
denotable values. Identifiers that have no corresponding definition are formally bound to 
the special token ^UNBOUND*. The identifiers are names for objects (e.g. constants, 
variables, procedures, and exceptions) in a program written in the language being defined. 
Environments are usually created and modified by the elaboration of declarations in the 
language. 

The domain of environments, Env, is typically 

Env = Id ^ (Dv + *UNBOUND*) 

where Id and Dv are, respectively, the domains of identifiers and denotable values. If r is an 
environment, then r(id) is the value (*UNBOUND* or a Dv-value) bound to the identi¬ 
fier id. The empty environment rO is the environment in which rO(id) = *UNBOUND* 
for every identifier id. In definitions of languages that have block-structured scoping, it 
is necessary to combine two environments that may each associate a denotable value with 
the same identifier. If rl and r2 are environments, then rl[r2] is a combined environment 
defined by 

rl[r2](id) = (r2(id) - *UNBOUND* ^ rl(id), r2(id)) 

where (a —^ b,c) is an abbreviation for if a then b else c. That is, in rl[r2], the r2-value 
of an identifier “overrides” the rl-value of that same identifier, except when its r2-value is 


9 



*UNBOUND*. An environment can be changed by this means. If r is an environment, 
d a value, and id an identifier, then r[d/id] denotes an environment that is the same as r 
except that (r[d/id])(id) = d. 

Tree-Structured Environments 

When the use of the above combination of environments is inconvenient or inappropriate, 
it is sometimes necessary to use a structured collection of environments. A tree-structured 
environment (TSE) is a tree whose nodes are environments and whose edges are labeled by 
identifiers or numerals, called edge labels, where no two edges emanating from a given node 
can have the same label. A path is a list of zero or more edge labels. Such a path denotes 
a sequence of connected edges from the root node to another node of a tree-structured 
environment. A path p can be extendedhy an edge labeled elbl via %(p)(elbl), where 

%(path)(i<l) = append(path,(id)) 

Formally, a TSE can be regarded as a partial function from paths to environments. Thus 
the set of paths in a TSE t is precisely the set of paths p for which t(p) is defined. If t is 
a TSE and p is a path in t, then t(p) denotes the unique environment in t located at the 
end of p. 

If t is a TSE and p is one of its paths, the pair (t,p) can be used to represent the set of 
environments containing aU of the identifier bindings visible at a given point in a Stage 4 
VHDL hardware description, where the identifiers in p are the names of the lexical scopes 
whose local environments are on the path p. At the program point whose identifier bindings 
are represented by (t, (elbli, ..., elbl„)), t((elbli, ..., elbl^)) is the most local set of 
bindings, ..., and t(c) is the most global set of bindings, where e denotes the empty path. 
Thus t(p)(id) is the value bound to id in the most local environment of (t,p). 

Qualified Names 

The same identifier is bound in every component environment of a TSE, although many 
(if not most) of those bindings may be to *UNBOUND*. It is convenient to be able to 
distinguish uniquely an occurrence of an identifier by prefixing to the identifier a represen¬ 
tation of the path that designates the location in the TSE of the environment associated 
with that instance. Such a uniquely distinguished identifier will be called a fully qualified 
name. Thus if t is a TSE, p one of its paths, and id an identifier, then $(p)(id) is id’s fully 
qualified name relative to t(p). If p = (elbli, ..., elbln), then $(p)(id) is represented as 

elbli.elbl 2 .elbl„.id. When p = c (empty path), $(c)(id) is simply represented by 

id. $ is defined by 

$(path)(id) = (path = e ^ id, $(rest(path))(catenate(Iast(path),“.’\id))) 

The function rest returns a list consisting of the first n — 1 elements of an n-element list, 
and catenate is a curried function that concatenates its (variable number of) arguments 
into an atom. 

Identifiers qualified with the full TSE path that locates their associated component envi¬ 
ronment are cumbersome and hard to read. If only those instances of identifiers 7iot bound 
to *UNBOUND* are of interest, then such full name qualification may be unnecessary. 


10 



Often a suffix of this path is sufficient to distinguish uniquely an instance of such an iden¬ 
tifier. An identifier so qualified is said to be uniquely qualified. In the limit, if all identifiers 
not bound to *UNBOUND* were distinct, then no qualification (an empty suffix) would 
be necessary to distinguish them. Given a TSE, it is possible to determine the minimum 
path suffix necessary to distinguish uniquely each identifier instance; this is done in our 
implementation of Stage 4 VHDL. 

Descriptors 

The denotable values to which identifiers are bound in the component environments of a 
TSE are called descriptors, 

A descriptor contains several fields of information, each of which holds an attribute of the 
identifier instance to which the descriptor is bound in a given TSE component environment. 
The number of fields in a descriptor depends on the attributes of its associated identifier, 
but each descriptor always has fields that contain the identifier to which it is bound, the 
identifier instance’s statically uniquely qualified name (see Section 8.2,1), and a tag that 
identifies the kind of descriptor (and hence its remaining fields). 

Descriptors for Stage 4 VHDL are discussed in detail in Section 6.2. 

Tree-Structured Environment Access 

Certain non-*UNBOUND* (i.e., denotable) values of an identifier id in (t,p) can be 
accessed by the functions lookup and lookup-local. These functions are given later in the 
context of semantic equations in which they are used. 

Tree-Structured Environment Modification 

A TSE’s component environments can be modified (in particular, descriptors can be bound 
to unbound identifiers or existing descriptors can be modified) via a function built into 
DENOTE. This function, enter, is used extensively in the DENOTE description of the 
Stage 4 VHDL translator. enter(t)(p)(id)(d), where t is a TSE, p a path in t, id an 
identifier, and d a partial descriptor (containing all its fields except the identifier field), 
yields a TSE that is the same as t except that its component environment t(p) is replaced 
by the environment 

t(p)[dVid], where if d = (qid, tag, ... ), then d’ = (id, qid, tag, ... ). 
Tree-Structured Environment Extension 

One can add additional component environments to a TSE by extending it. If t is a TSE, 
p a path in t, and elbl an edge label, and if %(p)(elbl) is not a path in t, then 

extend(t)(p)(elbl) 

denotes the TSE that is the same as t except that 

(extend(t)(p)(elbl))(%(p)(elbl)) = rO. 

Thus one can extend t along one of its paths p by adding a legally labeled edge onto the 
end of p and placing a node that is the empty environment rO at the end of that extended 
path %(p)(elbl). 


11 



4.2 Continuations 


Continuations are a technical device for capturing the semantics of transfers of control, 
whether they be explicit (gotos, returns from procedures and functions) or implicit (normal 
sequential flow of control to the next program element, abnormal termination of program 
execution). Continuations are functions intended to map the “normal” result of a semantic 
function to some ultimate “final answer” [some final value(s) or an error message]. If the 
semantic function does not produce a normal result, its continuation can be ignored and 
some “abnormal” final answer (such as an error message) can be produced instead. 

For example, in the first phase of our formal description of the Stage 4 VHDL translator, a 
continuation supplied to a semantic function that elaborates declarations normaUy maps a 
new “translation state” to a final answer, but if a declaration iUegally duplicates or conflicts 
with an existing definition, then the continuation is ignored and an error message (such as 
DUPLICATE-DECLARATION) is the resulting final answer. 

The initiation of the second phase of our formal description of the Stage 4 VHDL translator 
assumes that the program has first “passed” the first phase without error. In fact, the 
second phase is used as the continuation for the first. 

4.3 Other Notation and Functions 

Fairly standard lambda notation (see [13]) is used in this report, except that structured 
arguments are permitted in lambda-abstractions. Lambda-abstractions normally have the 
form Ax.body, where body is a lambda-term and x may be free in body. The term 
Ax.Ay.body is printed as Ax,y.body. If x is, for example, a pair, then the components of 
X can be represented in body by the application of projection functions to x. Instead, the 
individual components of x can be bound to variables y and z that appear free in body 
(instead of projection functions applied to x) by using the abstraction A(y,z).body . This 
is defined if and only if the value of x is indeed a pair. This notation will be used only when 
its result is defined. 

A list is represented in the usual way: (x,y,z). Standard Lisp functions are used, but they 
are curried, as in cons(x)(y) and appBnd(x)(y). If x is a nonempty sequence (list), then 
hd(x) denotes its first element and tl(x) the sequence (list) of its remaining components; 
X = cons(hd(x))(tl(x)). 

Some general-purpose functions are second, third, fourth, fifth, sixth, and last, which 
return the second, third, fourth, fifth, sixth, and last elements, respectively, of a list. Ad¬ 
ditionally, we have rest, which returns a list consisting of the first n 1 elements of an 
n-element list, and length, which returns the integer length of a list. 

second(x) = hd(tl(x)) 

third{x) = hd(tl(tl(x))) 

fourth(x) = hd(tl(tl(tl(x)))) 

fifth{x) = hd(tl(tl(tl(tl(x))))) 


12 




sixth(x) = hd(tl(tl(tl(tl(tl(x)))))) 
last(id+) = (null(tl(id+)H hd(id+), last(tl(id+))) 
rest(id''') = (null(tl(id‘*'))—> e, cons(hd(id'*’),rest(tl(id"'’)))) 
length(x) = (null(x)—* 0, l+length(tl(x))) 


13 



5 Syntax of Stage 4 VHDL 


Three Stage 4 VHDL syntaxes are used by the translator: a concrete syntax, which is 
SLR(l) and is used for parsing Stage 4 VHDL hardware descriptions; and two abstract 
syntaxes, which are used, respectively, in Phases 1 and 2 of the semantic definition. The 
concrete syntax is intended to be the ‘"reference” grammar for the Stage 4 VHDL language 
subset. 

In all three syntaxes the syntactic constructs are the members of syntactic domains, which 
are of two kinds: primitive and compound. The primitive syntactic domains are given. 
The compound syntactic domains are functions of the primitive domains; these functional 
dependencies are expressed as a set of syntax equations represented as productions of a 
context-free grammar. Terminals and nonterminals of this grammar range, respectively, 
over the primitive and compound syntactic domains. Only those syntactic domains of the 
abstract syntax that actually appear in a semantic equation will be given explicit names; 
other syntactic domains will be unnamed, as these names are not used in the specification. 

The terminal classes are: identifiers, unsigned decimal numerals, bit literals, character 
literals, bitstrings (binary, octal, and hexadecimal), and strings. The remaining terminal 
symbols serve as reserved words. 

The concrete syntax of Stage 4 VHDL, being SLR(l), is unambiguous. The abstract syn¬ 
taxes are considerably smaller than the concrete syntax, because they are not concerned with 
providing a parsable representation of Stage 4 VHDL, but rather simply provide the min¬ 
imum syntactic information necessary for a syntax-directed semantic specification. Their 
use yields a more compact formal definition. 

The translation of a hardware description (from concrete syntax) to its abstract syntactic 
representation is accomplished by semantic action routines in the Stage 4 VHDL parser. 
This process is straightforward, and a formal specification of how the Phase 1 abstract 
syntax is derived from the concrete syntax is omitted from this report. It is felt that the 
correspondence between the concrete and Phase 1 syntaxes is so close that no such formal 
specification is needed. The derivation of Phase 2 syntactic objects from corresponding 
Phase 1 syntactic objects is explicit in the specification of the interphase abstract syntax 
tree transformation; see Section 7. 

There are some minor variations between the concrete and abstract syntaxes of Stage 4 
VHDL. For example, in the concrete syntax, labels for PROCESS statements and loops (LOOP, 
WHILE, FOR statements) are optional. It was found, however, that the semantics of Stage 
4 VHDL requires that every process and loop have a label. Thus in the abstract syntaxes 
(which drive the semantics), process and loop labels are required. This is enforced by 
having the parser and the constructor of the Phase 1 abstract syntax tree supply a distinct 
system-generated label for each unnamed process and loop. These labels are taken from a 
primitive syntactic domain Sysid of system-generated identifiers, disjoint from the primitive 
syntactic domain Id of identifiers. Similarly, anonymous array types are given distinct 
system-generated names. 

The following subsections present the syntactic domains and equations for Stage 4 VHDL. 


14 



5.1 Syntactic Domains 
Primitive Syntactic Domains 


id : Id 
Sysid 

bit : BitLit 
constant : NumLit 
char : CharLit 

bitstring, octstring, hexstring : BitStr 
string : Str 

Compound Syntactic Domains 

design-file : Design 
design-unit : DUnit 
context-item : CItem 
library-unit : LUnit 
configuration-decl : Conflg 
block-config : BConf 
component-conf ig : CConf 
binding-indication : Bind 
entity-decl : Ent 
architecture-body : Arch 
generic-decl : GDec 
port-decl : PDec 
generic-map-aspect : GMap 
port-map-aspect : PMap 
decl, package-decl, package-body, 

use-clause, component-decl : Dec 
conc-stat : CStat 
seq-stat : SStat 
case-alt : Alt 
discrete-range : Drg 
waveform : Wave 
transaction : Trans 
expr : Expr 
ref : Ref 
unary-op : Uop 
binary-op : Bop 
relational-op : Bop 

5.2 Syntax Equations 


identifiers 

system-generated identifiers (disjoint from Id) 
bit literals 

numeric literals (unsigned decimal numerals) 
character literals 
bitstring Uterals 
string literals 


design files 
design units 
context items 
library units 

configuration declarations 
block configurations 
component configurations 
binding indications 
entity declarations 
architecture bodies 
generic declarations 
port declarations 
generic map aspects 
port map aspects 

declarations 
concurrent statements 
sequential statements 
case alternatives 
discrete ranges 
waveforms 
transactions 
expressions 
references 
unary operators 
binary operators 
relational operators 


In Sections 5.2.1, 5.2.2, and 5.2.3 we present, respectively, the concrete syntax for Stage 
4 VHDL hardware descriptions admissible as input to the SDVS VHDL language parser. 


15 



the syntax of VHDL abstract parse trees generated by the parser for use by Phase 1 of the 
VHDL translator, and the syntax of transformed parse trees produced during Phase 1 for 
use by translator Phase 2. 


5.2.1 Concrete Syntax 

The concrete syntax for Stage 4 VHDL is shown below. 

The productions are numbered for reference purposes. The first production and the nonter¬ 
minal **start** are inserted by the SLR(l) grammar analyzer to facilitate SLR(l) parsing, 
and the (terminal) symbol denotes the beginning or end of a file. Terminal symbols 
appear in uppercase letters, while nonterminal symbols and pseudo-terminals (terminals 
denoting a set of values) are in lowercase; pseudo-terminals are prefixed by a ‘Mot” (.). 


STAGE 4 VHDL CONCRETE SYNTAX 


1 ♦♦steirt** 

*E* design-file ♦£* 

2 design-file 

init design-unit-list 

3 init 


4 design-unit-list 

::= design-unit 

5 1 design-unit-list design-unit 

6 design-unit 

conteit-item-list library-unit 

7 context-item-list 

8 I conteit-item-list context-item 

9 context-item 

use-clause 

10 library-unit 

primary-unit 

11 I secondary-unit 

12 primary-unit 

::= configuration-decl 

13 I package-decl 

14 I entity-decl 

15 secondary-unit 

::= package-body 

16 I earchitecture-body 


16 



17 configuration-dec1 

::= CONFIGURATION .id OF .id IS conf ig-dec 1-part 
block-config END opt-id ; 

18 config-decl-part 

::= config-decl-item-list 

19 config-decl-item-list 

II — 

20 I config-decl-item-list config-decl-item 

21 config-decl-item 

11 = use-clause 

22 block-config 

I 1 = FOR block-spec use-clause-list config-item-list END 
FOR ; 

23 block-spec 

11= .id 

24 config-item-list 

25 I config-item-list config-item 

26 config-item 

I 1 = block-config 

27 I component-config 


28 component-config 



11= FOR 

component-spec 

USE 

binding-indieation ; 



block-config END FOR ; 



29 

1 FOR 

component-spec 

USE 

binding-indication ; 

; END FOR 

30 

1 FOR 

component-spec 

END 

FOR ; 



31 component-spec 

I 1 = instantiation-list i dotted-name 

32 instantiation-list 

I 1 = id-list 

33 I all 

34 I others 

35 binding-indication 

I 1= entity-aspect opt-generic-map-aspect opt-port-map-aspect 

36 entity-aspect 

11 = ENTITY dotted-name ( . id ) 

37 I ENTITY dotted-name 

38 I CONFIGURATION dotted-name 

39 package-decl-list 

40 I package-decl-list package-decl 

41 package-decl 


17 



PACKAGE .id IS package-decl-part END opt-id ; 


42 package-decl-part 

package^decl-item-list 

43 package-decl-item-list 


44 I package-decl-item-list package-decl-item 


45 

46 

47 

48 

49 

50 


package-decl-item 
::= const-decl 
I sig-decl 
I type-decl 
1 subtype-decl 
I subprog-decl 
1 use-clause 


51 opt-id 

52 I .id 


53 package-body-list 

54 I package-body package-body-list 


55 package-body 

::= PACKAGE BODY .id IS package-body-decl-part END 
opt-id ; 

56 package-body-decl-part 

::= package-body-decl-item-list 

57 package-body-decl-item-list 

58 I package-body-decl-item-list package-body-decl-item 


59 

60 
61 
62 

63 

64 


package-body-decl-item 
:const-decl 
I type-decl 
I subtype-decl 
I subprog-decl 
I subprog-body 
I use-clause 


65 use-clause-list 


66 1 use-clause-list use-clause 


67 use-clause 

::= USE dotted-name-list ; 

68 dotted-name-list 

::= dotted-name 

69 1 dotted-name-list , dotted-name 

70 dotted-name 

:.id 


18 




71 

72 


I dotted-name . id 
1 dotted-name . all 


73 all 

::= ALL 

74 others 

::= OTHERS 

75 entity-decl 

:ENTITY .id IS opt-generic-clause opt-port-clause END 
opt-id ; 

76 I ENTITY .id IS opt-generic-clause opt-port-clause 

ent-decl-part END opt-id ; 

77 opt-generic-clause 

78 I generic-clause 

79 opt-port-clause 

80 I port-clause 

81 generic-clause 

: := GENERIC ( generic-list ) ; 

82 generic-list 

generic-decl 

83 I generic-list ; generic-decl 

84 generic-decl 

opt-constant id-list : opt-in type-mark opt-init 

85 I opt-constant id-list : opt-in slice-name opt-init 

86 opt-constcint 

87 I CONSTANT 

88 opt-in 

89 I IN 

90 ent-decl-part 

ent-decl-item-list 


91 ent-decl-item-list 

::= ent-decl-item 

92 I ent-decl-item-list ent-decl-item 


93 

94 

95 

96 

97 

98 

99 


ent-decl-item 

::= const-decl 
I sig-decl 
I type-decl 
I subtype-decl 
I subprog-decl 
I subprog-body 
I use-clause 


19 




100 


architecture-body 

ARCHITECTURE .id OF .id IS arch-dec 1-part BEGIN 
arch-stat-part END opt-id ; 

101 arch-decl-part 

::= arch-decl-item-list 


102 arch-decl-item-list 

; ♦ = 

103 I arch-decl-item-list arch-decl-item 


104 

105 

106 

107 

108 
109 

no 

111 


arch-decl-item 

::= const-decl 
1 sig-decl 
1 type-decl 
I subtype-decl 
1 subprog-decl 
! subprog-body 
! use-clause 
1 component-decl 


112 arch-stat-part 

:conc-stats 


113 port-clause 

PORT ( port-list ) ; 

114 port-list 

::= port-decl 

115 I port-list ; port-decl 

116 port-decl 

opt-signal id-list : opt-mode type-mark opt-init 

117 I opt-signal id-list : opt-mode slice-name opt-init 

118 opt-signal 

119 I SIGNAL 

120 id-list 

::- .id 

121 I id-list , .id 

122 opt-mode 

123 I mode 

124 mode 

: := IN 

125 I OUT 

126 I INOUT 

127 I BUFFER 


128 type-mark 

:dotted-name 


20 




129 

slice-name 




::= type-mark ( discrete-range ) 


130 

discret e-range 




: := range 



131 

range 




::= simple-erpr direction simple-expr 

132 

direction 




: := TO 



133 

1 DDHNTO 



134 

opt-init 



135 

1 := expr 



136 

const-decl 




::= CONSTANT id-list 

: type-mark 

:= expr 

137 

1 CONSTANT id-list 

: slice-name 

:= expr 

138 

var-decl 




VARIABLE id-list 

: type-mark 

opt-init 

139 

1 VARIABLE id-list 

: slice-name 

opt-init 

140 

sig-decl 




SIGNAL id-list : 

type-mark opt-init ; 

141 

1 SIGNAL id-list : 

slice-name 

opt-init ; 

142 

type-decl 




::= enum-type-decl 



143 

1 array-type-decl 



144 

1 integer-type-decl 



145 

enum-type-decl 




::= TYPE .id IS enum 

-type-def ; 


146 

enum-type-def 




::= ( id-list ) 



147 

1 ( char-list ) 



148 

char-list 




:character-literal 



149 

1 char-list , character-literal 


150 

zorray-type-decl 




::= TYPE .id IS array-type-def ; 


151 

airray-type-def 




::= ARRAY ( discrete- 

range ) OF 

type-mark 

152 

integer-type-decl 




::= TYPE .id IS RANGE discrete-range ; 

153 

subtype-decl 




::= SUBTYPE .id IS type-mark opt-constraint 


21 




154 


opt-constraint 

155 I constraint 

156 constraint 

::= range-constraint 

157 range-constraint 

RANGE discrete-range 

158 component-decl 

:COMPONENT .id opt-generic-clause opt-port-clause END 
COFffONENT ; 

159 subprog-decl 

:subprog-spec ; 

160 subprog-spec 

:PROCEDURE .id opt-procedure-formal-part 

161 I FUNCTION .id opt-function-f omal-part RETURN type-mark 

162 opt-procedure-formal-part 

163 I ( procedure-par-spec-list ) 

164 opt-function-formal-part 

165 I ( function-par-spec-list ) 

166 procedure-par-spec-list 

procedure-par-S|>ec 

167 1 procedure-par-spec-list ; procedure-par-spec 

168 function-par-spec-list 

::= function-par-spec 

169 I function-par-spec-list ; function-par-spec 

170 procedure-par-spec 

proc-object-class id-list : procedure-par-mode 
type-mark opt-expr 

171 I id-list : IN type-mark opt-expr 

172 I id-list : OUT type-mark opt-expr 

173 I id-list : INOUT type-mark opt-expr 

174 function-par-spec 

fn-object-class id-list : function-par-mode type-mark 

opt-expr 

175 proc-object-class 

CONSTANT 

176 ! VARIABLE 

177 fn-object-class 

178 I CONSTANT 

179 procedure-par-mode 


22 





180 I IN 

181 I OUT 

182 I INOUT 

183 function-par-mode 

184 I IN 


185 subprog-body 

subprog-spec IS subprog-decl-part BEGIN 
subprog-stat-part END opt-id ; 

186 subprog-decl-part 

::= subprog-decl-item-list 

187 subprog-decl-item-list 

188 I subprog-decl-item-list subprog-decl-item 


189 

190 

191 

192 

193 

194 

195 


subprog-decl-item 
::= const-decl 
I veir-decl 
I type-decl 
I subtype-decl 
I subprog-decl 
1 subprog-body 
I use-clause 


196 subprog-stat-part 

::= seq-stats 

197 conc-stats 

198 I conc-stats conc-stat 

199 conc-stat 

::= block-stat 

200 1 process-stat 

201 I concurrent-sig-assn-stat 

202 I component-instantiation-stat 

203 block-stat 

::= unit-label BLOCK block-header BEGIN block-stat-part 
END BLOCK opt-id ; 

204 I unit-label BLOCK block-header block-decl-part BEGIN 

block-stat-part END BLOCK opt-id ; 

205 block-header 

206 I generic-part 

207 1 port-part 

208 1 generic-part port-part 

209 generic-part 

::= generic-clause 

210 I generic-clause generic-map-aspect ; 


23 




24 




241 concurrent-sig-assn-stat 

::= selected-sig-assn-stat 

242 I conditional”Sig-assn-stat 

243 selected-sig-assn-stat 

::= opt-unit-label WITH expr SELECT target <= 
opt-transport selected-waveforms ; 

244 I .atmark opt-unit-label WITH expr SELECT target <= 

opt-transport selected-waveforms ; 

245 opt-transport 

246 I transport 

247 transport 

::= TRANSPORT 

248 selected-waveforms 

::= selected-waveform 

249 I selected-waveforms , selected-waveform 

250 selected-waveform 

::= waveform WHEN choices 

251 conditional-sig-assn-stat 

::= target <= opt-transport conditional-waveforms waveform 

9 

252 I .atmark target <= opt-transport conditional-waveforms 

waveform ; 

253 I .id : tcirget <= opt-transport conditional-waveforms 

waveform ; 

254 I .atmark .id : target <= opt-transport 

conditional-waveforms waveform ; 

255 conditional-waveforms 

256 I conditional-waveforms conditional-waveform 

257 conditional-waveform 

::= waveform WHEN expr ELSE 

258 waveform 

::= waveform-elt-list 

259 waveform-elt-list 

::= waveform-elt 

260 ! waveform-elt-list , waveform-elt 

261 waveform-elt 

:expr 

262 I expr AFTER expr 

263 component-instantiation-stat 

;.id : name opt-generic-map-aspect opt-port-map-aspect 


25 



264 


opt~generiC”Biap-aspect 


265 

1 generic-map-aspect 

266 

generic-map~aspect 

::= GENERIC MAP ( assoc-list 

267 

opt-port-map-aspect 

268 

1 port-map-aspect 

269 

port-map-aspect 

::= PORT MAP ( assoc-list ) 

270 

assoc-list 

::= assoc-elt 

271 

1 assoc-list , assoc-elt 

272 

assoc-elt 

::= formal-part => actual-part 

273 

formal-part 

formal-designator 

274 

formal-designator 

::= name 

275 

actual-p 2 irt 

::= actual-designator 

276 

actual-designator 
::= erpr 

277 

seq-stats 

278 

1 seq-stats seq-stat 

279 

seq-stat 

::=* null-stat 

280 

1 var-assn-stat 

281 

1 sig-assn-stat 

282 

1 if-stat 

283 

1 case-stat 

284 

1 loop-stat 

285 

1 eiit-stat 

286 

1 return-stat 

287 

1 proc-call-stat 

288 

I wait-stat 

289 

null-stat 

NULL ; 

290 

I .atmark NULL 

291 

var-assn-stat 

: := name := expr ; 

292 

1 . atmark name : - expr ; 


26 



293 sig-assn-stat 

::= target <= opt-transport waveform ; 

294 I .atmeirk tzarget <= opt-trcinsport waveform ; 

295 if-stat 

: := if-head if-tail 

296 I .atmark if-head if-tail 

297 if-head 

::= IF eipr THEN seq-stats 

298 I if-head ELSIF eipr THEN seq-stats 

299 if-tail 

END IF ; 

300 I ELSE seq-stats END IF ; 


301 case-stat 

::= CASE expr IS case-alt-list END CASE ; 

302 I .atmark CASE eipr IS case-alt-list END CASE ; 

303 case-alt-list 

::= case-alt 

304 I case-other-alt 

305 1 case-alt case-alt-list 

306 case-alt 

: WHEN choices => seq-stats 

307 case-other-alt 

::= WHEN OTHERS => seq-stats 

308 choices 

:choice 

309 I choices I choice 

310 choice 

simple-expr 

311 I discrete-range 

312 loop-stat 

simple-loop 

313 I while-loop 

314 I for-loop 

315 simple-loop 

::= opt-unit-label LOOP seq-stats END LOOP opt-id ; 

316 1 .atmark opt-unit-label LOOP seq-stats END LOOP 

opt-id ; 

317 while-loop 

::= opt-unit-label WHILE expr LOOP seq-stats END LOOP 
opt-id ; 

318 I .atmark opt-unit-label WHILE expr LOOP seq-stats END 

LOOP opt-id ; 

319 for-loop 

::= opt-unit-label FOR name IN discrete-range LOOP 


27 



seq-stats END LOOP opt-id ; 

320 I .atmark opt-unit-label FOR neoae IN discrete-range 

LOOP seq-stats END LOOP opt-id ; 

321 exit-stat 

EXIT opt-dotted-name opt-when-cond ; 

322 I .atmaork EXIT opt-dotted-name opt-when-cond ; 

323 opt-dotted-name 

324 I dotted-naime 

325 opt-when-cond 

326 I WHEN expr 

327 proc-call-stat 

::= name ; 

328 I . atmark nauae ; 

329 return-stat 

::= RETURN ; 

330 I .atmark RETURN ; 

331 I RETURN expr ; 

332 I .atmark RETURN expr ; 

333 wait-stat 

::= WAIT opt-sensitivity-clause opt-condition-clause 

opt-timeout-clause ; 

334 1 .atmark WAIT opt-sensitivity-clause 

opt-condition-clause opt-timeout-clause ; 

335 opt-sensitivity-clause 

336 I sensitivity-clause 

337 sensitivity-clause 

ON sensitivity-list 

338 sensitivity-list 

name-list 

339 name-list 

::= name 

340 I name-list , name 

341 opt-condition-clause 

342 I condition-clause 

343 condition-clause 

:UNTIL expr 

344 opt-timeout-clause 

! * = 

345 I timeout-clause 


28 



346 timeout-clause 

: : = FOR expr 

347 expr-list 

::= expr 

348 I eipr-list , eipr 


349 opt-expr 


350 

1 expr 


351 

expr 



rel 


352 

1 rel 

and-expr 

353 

1 rel 

nand-expr 

354 

1 rel 

or-expr 

355 

1 rel 

nor-expr 

356 

1 rel 

xor-expr 


357 rel 

::= simple-expr 

358 I simple-expr relop simple-expr 

359 and-expr 

: := and-pcixt 

360 I and-part and-expr 

361 and-part 

AND rel 

362 nand-expr 

::= nand-part 

363 I nand-part nand-expr 

364 nand-part 

::= NAND rel 

365 or-expr 

::= or-part 

366 I or-p 2 a:t or-expr 

367 or-part 

::= OR rel 

368 nor-expr 

:nor-part 

369 I nor-part nor-expr 

370 nor-part 

::= NOR rel 

371 xor-expr 

::= xor-part 

372 1 xor-part xor-expr 

373 xor-part 

XOR rel 


29 



374 

simple-expr 


: : = 

simple-exprl 

375 

1 

-f simple-exprl 

376 

1 

- simple-exprl 

377 

simple- 

exprl 


: : = 

term 

378 

1 

simple-exprl addop term 

379 

term 



: : = 

factor 

380 

1 

term mulop factor 

381 

factor 



♦ ; ss 

primary 

382 

1 

primary ♦♦ primary 

383 

1 

ABS primary 

384 

1 

NOT primary 

385 

primary 



: : = 

primaryl 

386 

1 

aggregate 

387 

1 

( eipr ) 

388 

primary1 


: : = 

literal 

389 

1 

.atmark 

390 

1 

name 

391 

literal 



: 

boolean-literal 

392 

1 

bit-literal 

393 

1 

character-literal 

394 

1 

numeric-literal 

395 

1 

time-literal 

396 

1 

bitstring-literal 

397 

1 

string-literal 

398 

boolean- 

-literal 


* • sr 

FALSE 

399 

1 

TRUE 

400 

bit-literal 


::= .bit 

401 ch 2 Lracter-literal 

::= .char 

402 nimeric-literal 

: : = . const 2 uit 

403 time-literal 

:opt-time-constant time-unit 

404 opt-time-constant 


30 



405 

1 

.constant 

406 

time-unit 


: : = 

FS 

407 

1 

PS 

408 

1 

NS 

409 

1 

US 

410 

1 

MS 

411 

1 

SEC 

412 

1 

MIN 

413 

1 

HR 

414 

bitstring-literal 


: : = 

.bitstring 

415 

1 

.octstring 

416 

1 

.heistring 

417 

string- 

'literal 


: : = 

.string 

418 

aggregate 


• • =s 

( 2-eipr-list ) 

419 

2-expr- 

■list 


: : = 

expr , expr 

420 

1 

2-expr-list , expr 

421 

target 



• • s 

name 

422 

name 



: : = 

namel 

423 

namel 



: : = 

selector 

424 

1 

namel . selector 

425 

1 

namel ( expr-list 

426 

selector 


: : = 

. id 

427 

relop 


428 

1 

/= 

429 

1 

< 

430 

1 

<= 

431 

1 

> 

432 

1 

>= 

433 

addop 



: : = 

+ 

434 

1 

- 

435 

1 

ft 

436 

mulop 



: : = 

* 

437 

1 

/ 


31 



438 I MOD 

439 1 MM 

5.2.2 Abstract Syntax: Phase 1 

The abstract syntax of Stage 4 VHDL used during Phase 1 translation is shown below. 

The superscript denotes Kleene closure (e.g. “decl*” denotes zero or more occurrences 
of the syntactic object ^‘decl”), and a superscript denotes one or more occurrences. In 
a syntactic clause, subscripts denote (possibly) different objects of the same class. 

As in the concrete syntax, terminal symbols appear in upper case, while all other symbols 
are either nonterminals or pseudo-terminals (id, bitlit, and const amt). 

STAGE 4 VHDL ABSTRACT SYNTAX: PHASE I 


design-file DESIGN-FILE id design-unit+ 

design-unit DESIGN-UNIT context-item* library-unit 

context-item use-clause 

use-clause USE dotted-name"*" 

library-unit primary-unit | secondary-unit 

primary-unit configuration-decl | package-decl | entity-decl 

secondary-unit package-body | architecture-body 

configuration-decl CONFIGURATION idi id2 use-clause* block-config opt-id 
package-decl PACKAGE id decl* opt-id 

entity-decl ENTITY id generic-decl* port-decl* decl* opt-id 

package-body PACKAGEBODY id decl* opt-id 

architecture-body ARCHITECTURE idi id2 decl* conc-stat* opt-id 
opt-block-config c | block-config 

block-config BLOCK-CONFIG id use-clause* component-config* 

component-config COMP-CONFIG component-spec opt-binding-indication opt-block-config 

component-spec id"*" dotted-name 

opt-binding-indication £ | binding-indication 

binding-indication BIND entity-aspect opt-generic-map-aspect opt-port-map-aspect 
entity-aspect BOUND-ENTITY dotted-name opt-id | 

BOUND-CONFIGURATION dotted-name 
opt-generic-map-aspect c | generic-map-aspect 
generic-map-aspect GENERICMAP assoc-elt"*" 
opt-port-map-aspect € \ port-map-aspect 
port-map-aspect PORTMAP assoc-elt"^ 
generic-decl DEC GENERIC id"*" type-mark opt-expr | 

SLCDEC GENERIC id"*" slice-name opt-expr 
port-decl DEC PORT id"*" mode type-mark opt-expr | 

SLCDEC PORT id"*" mode slice-name opt-expr 
mode IN | OUT | INOUT | BUFFER 
atmark AT id 


32 



type-mark dotted-name 
dotted-name id"*" 

slice-name type-mark discrete-range 

discrete-range direction expr^ expr2 
direction ::== TO | DOWNTO 

decl object-decl | type-decl | subtype-decl | package-decl | 

package-body | subprog-decl | subprog-body | use-clause | 
component-decl 

object-decl DEC object-class id+ type-mark opt-expr | 

SLCDEC object-class id+ sbce-name opt-expr 
object-class CONST j VAR | SIG 

type-decl ETDEC id id’^" | ATDEC id discrete-range type-mark | 

ITDEC id discrete-range 

subtype-decl STDEC id type-mark opt-discrete-range 

subprog-decl subprog-spec 

subprog-spec PROCEDURE id proc-par-spec* | 

FUNCTION id func-par-spec* type-mark 
proc-par-spec object-class id"*" proc-par-mode type-mark opt-expr 

func-par-spec object-class id+ func-par-mode type-mark opt-expr 

proc-par-mode IN | OUT | INOUT 
func-par-mode IN 

subprog-body ::= SUBPROGBODY subprog-spec decl* seq-stat* opt-id 
component-decl COMPONENT id generic-decl* port-decl* 
conc-stat ::= block-stat | process-stat | selected-sig-assn-stat | 

conditional-sig-assn-stat | component-instantiation-stat 
block-stat ::= BLOCK id block-header decl* conc-stat* opt-id 
block-header generic-part port-part 

generic-part generic-decl* generic-map-aspect 

port-part port-decl* port-map-aspect 
process-stat PROCESS id ref* decl* seq-stat* opt-id 

selected-sig-assn-stat SEL-SIGASSN atmark delay-type id expr ref selected-waveform^ 
selected-waveform SEL-WAVE waveform discrete-range*^ 

conditional-sig-assn-stat COND-SIGASSN atmark delay-type id ref cond-waveform* waveform 
cond-waveform COND-WAVE waveform expr 

component-instantiation-stat :::= COMPINST id ref opt-generic-map-aspect opt-port-map-aspect 
assoc-elt ref expr 

seq-stat nuU-stat | var-assn-stat | sig-assn-stat | if-stat | case-stat | 
loop-stat 1 while-stat ] for-stat | exit-stat | call-stat | 
return-stat | wait-stat 
null-stat NULL atmark 

var-assn-stat VARASSN atmark ref expr 

sig-assn-stat SIGASSN atmark delay-type ref waveform 

delay-type INERTIAL ] TRANSPORT 
waveform WAVE transaction"*" 
transaction TRANS expr opt-expr 
if-stat IF atmark cond-part"*" else-part 


33 



cond-part expr seq-stat* 

else-part seq-stat* 

case-stat CASE atmark expr case-alt+ 

case-alt CASECHOICE discrete-raiige+ seq-stat* | 

CASEOTHERS seq-stat* 

loop-stat LOOP atmark id seq-stat* opt-id 

while-stat WHILE atmark id expr seq-stat* opt-id 

for-stat FOR atmark id ref discrete-range seq-stat* opt-id 
exit-stat EXIT atmark opt-dotted-name opt-expr 

caU-stat CALL atmark ref 

return-stat RETURN atmark opt-expr 
wait-stat WAIT atmark ref* opt-expr| opt-expr 2 

expr c | bool-lit | bit-lit | num-lit | time-lit | char-lit | 

bitstr-lit I str-lit | ref | positional-aggregate | unary-op expr [ 
binary-op expri expr 2 | relational-op expri expr 2 
bool-lit FALSE | TRUE 

bit-lit :::= BIT bitlit 
num-lit NUM constant 

time-lit TIME constant time-unit 

char-lit CHAR constant 

bitstr-lit BITSTR bit-lit* 

str-lit STR char-lit* 

ref REF name 

name id | name id | name expr* 
positional-aggregate PAGGR expr* 
unary-op NOT | PLUS | NEG | ABS 

binary-op AND | NAND | OR | NOR | XOR | ADD | SUB 1 MUL | DIV | MOD [ 
REM I EXP I CONCAT 

relational-op EQ | NE | LT | LE | GT | GE 
time-unit FS | PS | NS | US | MS | SEC | MIN i HR 
opt-id c | id 

opt-discrete-range c | discrete-range 
opt-dotted-name e \ dotted-name 
opt-expr € \ expr 


5.2.3 Abstract Syntax: Phase 2 

The abstract syntax of Stage 4 VHDL used during Phase 2 translation differs in certain 
respects from that employed by Phase L An abstract syntax transformation is performed 
at the very end of Phase 1, and just prior to the invocation of Phase 2, as described in 
Section 7. 

The most significant transformations of Phase 1 syntax to that of Phase 2 are: (1) the 
''desugaring” (i.e., reduction to more basic constructs) of concurrent signal assignment 
statements (conditional signal assignment and selected signal assignment) into equivalent 


34 




PROCESS statements; (2) the desugaring of component instantiation statements into equiv¬ 
alent pairs of nested BLOCK statements, and (3) the disambiguation of REFs into simple 
references, array references, record field accesses (not fuUy supported by Stage 4 VHDL), 
and subprogram calls. 


STAGE 4 VHDL ABSTRACT SYNTAX: PHASE 2 


design*file DESIGN-FILE id design-unit+ 

design-unit DESIGN-UNIT context-item* library-unit 

context-item use-clause 

use-clause USE dotted-name”^ 

library-unit primary-unit | secondary-unit 

primary-unit configuration-decl | package-decl | entity-decl 

secondary-unit package-body | architecture-body 

configuration-decl CONFIGURATION id^ id 2 use-clause* block-config opt-id 
package-decl PACKAGE id decl* opt-id 

entity-decl ::= ENTITY id decl*i decl *2 decl *3 opt-id phasel-hook 
package-body ::= PACKAGEBODY id decl* opt-id 
architecture-body ARCHITECTURE idi id 2 decl* conc-stat* opt-id 

opt-block-config ::= e \ block-config 

block-config BLOCK-CONFIG id use-clause* component-config* 

component-config COMP-CONFIG component-spec opt-binding-indication opt-block-config 
component-spec id”^ dotted-name 
opt-binding-indication c 1 binding-indication 

binding-indication BIND entity-aspect opt-generic-map-aspect opt-port-map-aspect 
entity-aspect BOUND-ENTITY dotted-name opt-id | 

BOUND-CONFIGURATION dotted-name 
opt-generic-map-aspect ::= c | generic-map-aspect 
generic-map-aspect GENERICMAP assoc-elt”*” 
opt-port-map-aspect e \ port-map-aspect 
port-map-aspect PORTMAP assoc-elf*" 
assoc-elt ref expr 

decl object-decl ] type-decl | subtype-decl | package-decl | package-body | 
subprog-decl [ subprog-body | use-clause | component-decl 
object-decl DEC object-class id"*" type-mark opt-expr | 

SLCDEC object-class id"*" slice-name opt-expr 
object-class CONST I VAR | SIG 
type-mark dotted-name 
dotted-name id+ 
slice-name type-mark discrete-range 

discrete-range direction expri expr 2 
direction TO | DOWNTO 

type-decl ETDEC id id*^ | ATDEC id discrete-range type-mark | 

ITDEC id discrete-range 


35 



subtype-decl STDEC id type-mark opt-discrete-range 

subprog-decl subprog-spec 

subprog-spec PROCEDURE id proc-par-spec* | 

FUNCTION id func-par-spec* type-mark 
proc-par-spec object-class id+ proc-par-mode type-mark opt-expr 
func-par-spec object-class id+ func-par-mode type-mark opt-expr 

proc-par-mode IN | OUT | INOUT 

func-par-mode IN 

subprog-body SUBPROGBODY subprog-spec decl* seq-stat* opt-id 
component-decl COMPONENT id decl*i decl *2 phasel-hook 
conc-stat block-stat | process-stat 

block-stat BLOCK id decl* conc-stat* opt-id phasel-hook 
process-stat PROCESS id decl* seq-stat* opt-id phasel-hook 
seq-stat ::= nuU-stat | var-assn-stat | sig-assn-stat | if-stat | case-stat | 
loop-stat I while-stat | for-stat | exit-stat | call-stat | 
return-stat | wait-stat 
atmark AT id 
nuU-stat NULL atmark 

var-assn-stat VARASSN atmark ref expr 
sig-assn-stat SIGASSN atmark delay-type ref waveform 
delay type INERTIAL | TRANSPORT 

waveform WAVE transaction'^ 
transaction TRANS expr opt-expr 
if-stat IF atmark cond-part'^ else-part 
cond-part ::= expr seq-stat* 
else-part ::= seq-stat* 
case-stat CASE atmark expr case-alt"^ 

case-alt CASECHOICE discrete-range"*" seq-stat* | 

CASEOTHERS seq-stat* 
loop-stat LOOP atmark id seq-stat* opt-id 
while-stat WHILE atmark id expr seq-stat* opt-id 
for-stat FOR atmark id ref discrete-range seq-stat* opt-id 

exit-stat EXIT atmark opt-dotted-name opt-expr 

call-stat CALL atmark ref 

return-stat RETURN atmark opt-expr 
wait-stat WAIT atmark ref* opt-expri opt-expr2 

expr c | bool-lit | bit-lit | num-lit [ time-lit | char-lit | 

enum-lit | bitstr-lit j str-lit | ref | positional-aggregate | 
type-conversion | unary-op expr | binary-op expri expr2 | 
relational-op expri expr2 
bool-lit FALSE 1 TRUE 

bit-lit BIT bitlit 
num-lit NUM constant 

time-lit TIME constant FS 

char-lit CHAR constant 

enum-lit ENUMLIT id 


36 



bitstr-lit ::= BITSTR bit-lit* 
str-lit :;= STR char-lit* 
ref ::= REF modifier"*" 

modifier ::= SREF id"*" id | INDEX expr | SELECTOR id | PARLIST expr* 

positional-aggregate ::= PAGGR expr* 

type-conversion ::= TYPECONV expr type-mark 

unary-op ::= NOT | BNOT | PLUS 1 NEG | ABS | RNEG | RABS 

binary op ::= AND | NAND | OR | NOR | XOR 1 BAND | BNAND | BOR | BNOR | 

BXOR I ADD I SUB 1 MUL | DIV | MOD | REM 1 EXP | RPLUS | RMINUS 
RTIMES I RDIV | REXPT | CONCAT 
relational-op EQ | NE | LT | LE 1 GT | GE | RLT | RLE | RGT j RGE 
opt-id ( \ id 

opt-discrete-range < | discrete-range 
opt-dotted-name ::= f | dotted-name 
opt-expr ::= c | expr 


The occurrences of phasel-hook in the Phase 2 abstract syntax for certain constructs 
point to the Phase 1 abstract syntax for the respective constructs, for the purposes of the 
(experimental) SDVS VHDL Symbolic Execution Trace Window. 


37 




6 Phase 1: Static Semantic Analysis and Environment Col¬ 
lection 

Now that the necessary background has been established, we are ready to examine the 
formal description of the Stage 4 VHDL translator. 

In this section, an overview of Phase 1 and its relation to Phase 2 will be presented, followed 
by detailed discussions of the environment manipulated by the translator and the Phase 1 
semantic domains and function types, and finally the Phase 1 semantic equations themselves. 


6.1 Overview 

A Stage 4 VHDL hardware description is first parsed according to the Stage 4 VHDL 
concrete grammar, producing an abstract syntax tree that serves as the input to Phase 1 
translation. 

Phase 1 of the translation accomplishes the following. 


• Performs static semantic checks to verify that certain conditions are met, including: 

- Objects, subprograms, packages, and process and loop labels must be declared 
prior to use. 

— Identifiers with the same name cannot be declared in the same local context. 

- References to objects and labels must be proper, e.g. scalar objects must not 
be indexed, array references must have the correct number of indices, and EXIT 
statements must reference a loop label. 

- All components of statements and expressions must have the proper type, e.g. 
expressions used as conditions must be boolean, array indices must be of the 
proper type, operators must receive operands of the correct type, procedure and 
function calls must receive actual parameters of the proper type, function calls 
must return a result of a type appropriate for their use in an expression. 

- Sensitivity lists in PROCESS and WAIT statements must contain signal identifiers. 

- The collection of discrete ranges defining a CASE statement alternative must be 
exhaustive and mutually exclusive. 

- The time delays in the AFTER clause of a signal assignment statement must be 
increasing. 

• Creates a new abstract syntax tree — a transformed version of the original abstract 
syntax tree (used by Phase 1) — that will be more conveniently utilized by Phase 2 
of the translation. 

• Creates and manipulates a tree-structured environment (TSE) that, in the absence of 
errors, is provided to Phase 2 of the translation. 


38 



If the VHDL translator completes Phase 1 without error, then it can proceed with Phase 
2, state delta generation. Phase 2 requires two inputs: the transformed abstract syntax 
tree and the tree-structured environment for the hardware description, both constructed by 
Phase 1. 

The tree-structured environment contains a complete record of the name/attribute associ¬ 
ations corresponding to the hardware description’s declarations, and its structure reflects 
that of the description. Referring to this TSE, Phase 2 incrementally generates and (per 
user proof commands) applies state deltas via symbolic execution and the theories built 
into the Simplifier. 


6.2 Descriptors, Types, and Type Modes 

When a declaration of an identifier is processed by Phase 1, that identifier is bound in 
the TSE to a descriptor, a structured object that contains the attributes of the identifier 
instance associated to it by that declaration. 

At the time a descriptor is created and entered into the TSE, its qid field is set to e. 
The value of the qid field is eventually set to the proper statically uniquely qualified narne 
{SUQN), when such a qualified name makes sense; see Section 8.2.1. These updates to the 
qid fields become possible only once the TSE is fully constructed, i.e., at the very end of 
Phase 1 — or in other words, at the very beginning of Phase 2, the phase in which these 
uniquely qualified names are needed. 

Fourteen kinds of descriptor are employed in Phase 1: object, design file, configuration, 
package, entity, architecture, component, block name, process name, loop name, function, 
procedure, enumeration type element, and type. Their structures are as follows: 


object : 


< id, qid, tag, path, exported, type, value, process > 


The id field contains the identifier to which this descriptor is bound, and the qid 
field contains its statically uniquely qualified name (SUQN). The tag field contains 
^OBJECT*. The path field contains the path in the tree-structured environment to 
the component environment in which this instance of the identifier is bound. The ex¬ 
ported field indicates whether the definition of this identifier instance can be exported 
to other environments. A value true (represented by DENOTE symbol tt) indicates 
exportation is permitted, and a value false (represented by DENOTE symbol ff) 
indicates that it is not. This becomes an issue when the declaration whose elabora¬ 
tion created this descriptor was contained in a package specification (exportable) or 
package body (not exportable). 

If the identifier id represents a constant initialized via a static expression, then the 
value field contains the initial value; otherwise it contains *UNDEF* (undefined). 
Array and record references never represent static values in VHDL, so the value field 
of corresponding object descriptors contains *UNDEF*. 


If the identifier id represents a signal, then the label of the first PROCESS statement 
in which id is the target of a signal assignment is entered into the process field, to 


39 



enable the detection of assignments to the signal by multiple processes (disallowed in 
Stage 4 VHDL). 

Finally, the object descriptor’s type field contains the type of the identifier, repre¬ 
sented by a pair < tmode, tdesc >: 


• tmode is the type mode^ itself a pair; 
normally, 

tmode = <object-class, ref-mode>, 
where object-class E {CONST, VAR, SIG} 
and ref-mode E {VAL, REF, OUT}. 

The tmode indicates, first, whether the object is a constant (object-class = 
CONST), variable (object-class = VAR), or signal (object-class = SIG), 
and second, whether the object is read-only (ref-mode = VAL), read-write 
(ref-mode = REF), or write-only (ref-mode = OUT). 

For technical purposes, it is also occasionally convenient for Phase 1 transla¬ 
tion to manipulate ‘'dummy” type modes of the form < DUMMY, VAL >, 

< DUMMY, OBJ >, < DUMMY, ACC >, < DUMMY, AGR >, and 

< DUMMY, TYP >, as well as “path” type modes of the form < PATH,p > 
where p is a path in the TSE. 

• tdesc is the type descriptor (see below). It gives the object’s basic type, irre¬ 
spective of the type mode. 


To introduce a bit more terminology, a type in which the ref-mode is REF or OUT 
will be called a reference type, while one whose ref-mode is VAL will be called a 
value type. A reference type indicates that the associated object can have its value 
altered (by an assignment, say), as opposed to a value type. 

Finally, the type descriptor d tdesc is the basic type of the type < tmode, tdesc > 
of which it is the second component. 


design file : 


< id, qid, ^^DESIGN - FILE*, c > 

The id and qid fields are as above. *DESIGN-FILE* constitutes the tag field, 
and the path field contains e. 


configuration : 

< id,qid,+CONFIGURATION*,entity > 

The id and qid fields are as above. *DESIGN-FILE* constitutes the tag field, 
and the entity field contains the name of the configured entity. 


package : 


< id, qid, *PACKAGE*,path, exported, pbody > 


The id, qid, path, and exported fields are as above. The tag field contains 
^PACKAGE*. If this package has a body, the pbody field contains the trans¬ 
formed abstract syntax tree of the package body; otherwise it contains e. 


entity : 


< id, qid, ♦ENTITY*, path, exported > 


40 



The id, qid, path, and exported fields are as above. *ENTITY* constitutes the 
tag field. 

architecture : 

< id, qid, * ARCHITECTURE*, path, exported > 

The id, qid, path, and exported fields are as above. *ARCHITECTURE* 
constitutes the tag field. 

component : 

< id, qid, ^COMPONENT*, path, exported > 

The id, qid, path, and exported fields are as above. ^COMPONENT* consti¬ 
tutes the tag field. 

block name : 

< id,qid, *BLOCKNAME*,path > 

The id and path fields are as above. The tag field contains *BLOCKNAME* 
(the block label). 


process name : 

< id,qid,*PROCESSNAME*,path > 

The id and path fields are as above. The tag field contains *PROCESSNAME* 
(the process label). 

loop name : 

< id, qid, +LOOPNAME*, path > 

The id, qid, and path fields are as in a process name. The tag field contains 
*LOOPNAME* (the loop label). 

function : 

< id, qid, ♦FUNCTION*, path, exported, signatures, body, characterizations > 


The id, qid, exported, and path fields are as above. The tag field contains 

♦FUNCTION*. 

The signatures field contains a list of signatures, that is, < pars, rtype > pairs; this 
list will be a singleton unless the function is overloaded. The pars field of a signature 
is a list that indicates the names and types of the function’s formal parameters. Each 
list element is a pair, whose first component is the identifier that denotes the formal 
parameter’s name and whose second component is its type. The rtype (result type) 
field of a signature contains the type of the function’s result for these particular 
parameter types; this type is always a value type. 

The body field of a function descriptor contains the transformed abstract syntax 
tree of the function’s body (including its local declarations) if a body exists, and e 
otherwise. The characterizations field of a function descriptor always contains e 
(see procedure descriptors for a description of this field). 

procedure : 

< id, qid, * PROCEDURE*, path, exported, signatures, body, characterizations > 


The id, qid, path, exported, signatures, body, and characterizations fields are 
as in the function descriptor. The tag field contains *PROCEDURE* (procedure). 


41 



Since procedures return no result, all rtype fields in each signature contain the void 
standard value type (see below). 

The characterizations field of a procedure descriptor, unlike that of a function 
descriptor, is potentially nonempty. One of either the body or the characterizations 
must contain c; either a procedure has a body that may be symbolically executed, or 
it has been characterized by a set of state deltas. 

A characterization is a 6-tuple containing the following information: 

• the path to the procedure; 

• the identifier that names the procedure; 

• a list of the identifiers that name the arguments to the procedure; 

• a (possibly empty) precondition that determines under which conditions this 
characterization may be used; 

• a modification list of the names of variables changed by this procedure; and 

• a postcondition that states the effects of the procedure. 

The last three items in the tuple must be given in SDVS internal state delta notation, 
as they form the basis for a state delta that characterizes the actions of the procedure. 

enumeration type element : 

< id,qid, *ENUMELT*,path, exported, type > 

The id field contains the name of an enumeration type element, the tag field is 
*ENUMELT'*', and the type field contains the descriptor of the enumeration type. 

type : 

There are six kinds of type descriptor: those for standard types^ enumeration types, 
array types, subtypes, integer definition types, and record types. Although record 
types are not actually incorporated in the Stage 4 VHDL language subset, the Stage 
4 VHDL translator contains support for their eventual implementation. 

Each type descriptor has an id field (containing the name of that type), a correspond¬ 
ing qid field, a tag field (indicating the kind of type descriptor), path and exported 
fields (that serve the usual purpose), and additional fields that contain information 
appropriate to the type represented by the descriptor. The detailed structures of the 
type descriptors are as follows: 

standard type : 

< id, qid, tag, path, exported > 

Standard types are those considered to be predeclared; they are always ex¬ 
portable. In Stage 4 VHDL, the standard types are boolean, bit, integer, real, 
time, character, bitjvector, and string; they cannot be redeclared. 

The id and tag fields denote the following Stage 4 VHDL standard types: 

id = BOOLEAN, tag = *BOOL* 

id = BIT, tag - *BIT* 


42 



id = UNIVERSAL-INTEGER, tag = *INT* 


id = INTEGER, tag = *INT* 

id = REAL, tag = *REAL* 

id = TIME, tag = *TIME* 

id = BIT-VECTOR, tag = *ARRAYTYPE* 

id = STRING, tag = *ARRAYTYPE* 

For completeness, we also provide void and polymorphic standard types for Stage 
4 VHDL: 

id = VOID, tag = *VOID* 

id = POLY, tag = *POLY* 

Functions are available that look up the type descriptors for the standard types; 
during translation Phase 1, these type descriptors are bound to the type identi¬ 
fiers in the t((STANDARD)) component environment of the TSE t: 

bool-type-desc(t) = t((STANDARD) )(BOOLEAN ) 

bit-type-desc(t) = t((STANDARD) )(BIT ) 

univint-type-desc(t) = t((STANDARD) )(UNIVERSAL_INTEGER ) 

int-type-desc(t) := t((STANDARD) )(INTEGER ) 

real>type-desc(t) = t((STANDARD) )(REAL ) 

time-type-desc(t) = t((STANDARD) )(TIME ) 

void-type-desc(t) = t((STANDARD) )(VOID ) 

poly-type-desc(t) = t((STANDARD) )(POLY ) 

In each of the above cases, the type descriptor has the form: 

< id, £, tag, (STANDARD), tt, lb, ub > 

char-type-desc(t) = t((STANDARD) )(CHARACTER ) 

The type descriptor for the CHARACTER type has the form: 

< CHARACTER, c,*ENUMTYPE*, (STANDARD), tt, (CHAR 0),(CHAR 127), literals > 
bitvector-type-desc(t) = t((STANDARD) )(BIT-.VECTOR ) 


43 



The type descriptor for the BIT-VECTOR type has the form: 

< BIT-VECTOR, e, *ARRAYTYPE*, (STANDARD), tt, TO, (NUM 0), c, bittypedesc > 

string-type-desc(t) = t((STANDARD) )(STRING ) 

The type descriptor for the STRING type has the form: 

< STRING, e,*ARRAYTYPE*, (STANDARD), tt, TO, (NUM 1), t, chartypedesO 
enumeration type : 

< id, qid, *ENUMTYPE+, path, exported, literals > 

The literals field is a nonempty list of identifiers giving the enumeration literals 
(in order) for this type. Both characters and identifiers are admissible enumera¬ 
tion literals in Stage 4 VHDL. 

array type : 

< id, qid, *ARRAYTYPEit, path, exported, direction, lb, ub, elty > 

Every array type has a name; unique names are generated for anonymous ar¬ 
ray types. Arrays in Stage 4 VHDL are one-dimensional^ of index type UNI¬ 
VERSAL-INTEGER. Note that the standard types BIT-VECTOR and 
STRING are array types. 

The direction field contains either TO or DOWNTO, indicating whether the 
indices of the array increase or decrease, respectively. The lb and ub fields 
contain, respectively, abstract syntax trees for expressions that denote the array 
type’s lower and upper bounds. The elty (element type) field contains the de¬ 
scriptor of the type of the array’s elements. The values of the array’s lower and 
upper bounds are not necessarily static; therefore, array bounds-checking gen¬ 
erally cannot be performed in Phase 1, but must be deferred to Phase 2 (“run 
time”), when state deltas are applied (“executed”). 

The following function accepts arguments for the creation of an array type: 

array-type-desc( array-name,qid,path,exported,direction,lower-bound,upper-bound,element-type) 

= <array-name,qid,*ARRAYTYPE* ,path,exported,direction,lower-bound,upper-bound,element-type> 


subtype : 

< id, qid, ^SUBTYPE*, path, exported, lb, ub,basetype > 

The lb and ub fields contain, respectively, abstract syntax trees for expressions 
that denote the subtype’s lower and upper bounds. The basetype field contains 
the descriptor of the subtype’s base type. 

integer definition type : 

< id, qid, *INT-TYPE*, path, exported, lb, ub, parenttype > 

The lb and ub fields contain, respectively, abstract syntax trees for expressions 
that denote the integer definition type’s lower and upper bounds. The parent- 
type field contains the descriptor of the integer definition type’s parent type, 
which is always UNIVERSAL-INTEGER. 


44 



record type : 


< id, qid, *RECORDTYPE+, path, exported, components > 

The components field is a nonempty list of triplets; each triplet represents a 
field of this record type. The first element of each triplet is an identifier that 
is this field’s name. The second element is a descriptor representing this field’s 
basic type. The third element either is empty or contains an abstract syntax 
tree for Phase 2 initialization for components of objects declared to be of this 
record type. As noted above, records are not implemented as part of Stage 4 
VHDL, and record types are included simply in preparation for the anticipated 
implementation of records. 


6.2.1 Type and type descriptor predicates 

Predicates are available for distinguishing specific types and type descriptors: 

is-booIean?(type) = is-boolean-tdesc?(tdesc(type)) 
is-boolean-tdesc?(d) = idf(d)= BOOLEAN 


is-bit?(type) = is-bit-tdesc?(tdesc(type)) 
is.bit<tdesc?(d) = idf(d)=: BIT 


is-integer?(type) = is-integer-tdesc?(tdesc(type)) 
is-integer-tdesc?(d) = tag{d)€ (*INT* *INT_TYPE*) 


is-real?(type) = is-real-tdesc?(tdesc(type)) 


is-real-tdesc?(d) = idf(d)= REAL 


is-time?(type) = is-time-tdesc?(tdesc(type)) 
is-time-tdesc?(d) = idf(d)= TIME 


is-void?(type) = is-void-tdesc?(tdesc(type)) 
is-void-tdesc?(d) = idf(d)= VOID 


is-poly?(type) = is-poIy-tdesc?(tdesc(type)) 


is-poly-tdesc?(d) = idf(d)= POLY 


is-character?(type) = is-character-tdesc?(tdesc(type)) 


45 



is-character-tdesc?(d) = idf(d)= CHARACTER 


is-array?(type) = is-array-tdesc?(tdesc(type)) 
is-array-tdesc?(d) = tag(d)= ^ARRAYTYPE* 

is-record?(type) = is-record-tdesc?(tdesc(type)) 
is-record-tdesc?(d) = tag(d)= *RECORDTYPE* 

is-bitvector?(type) = is-bitvector-tdesc?(tdesc(type)) 

is-bitvector-tdesc?(d) 

= let idf = idf(d) in 

idf = BIT-VECTOR V (consp(idf)A hd(idf)= BIT-VECTOR ) 

is-string?(type) = is-strmg-tdesc?(tdesc(type)) 

is-string-tdesc?(d) 

= let idf = idf(d) in 

idf = STRING V (consp{idf)A hd(idf)= STRING ) 

is-const?(type) = object-class(tmode(type))= CONST 
is-var?(type) = object-dass(tmode(type))= VAR 
is-sig?(type) = object-class(tmode(type))= SIG 


6.2.2 Additional primitive accessors and predicates 

Certain primitive functions can be applied to descriptors. For each kind of descriptor and 
field there exists an access function, ordinarily with the same name as the field (the only 
exception being idf instead of id). When applied to a descriptor of the proper kind, the 
access function extracts the contents of that descriptor’s corresponding field. For example, 
if d is an object descriptor, then tag(d) = ‘‘‘OBJECT*. 

If d is any descriptor, then the fully qualified name of the corresponding identifier instance 
is returned by function namef: 

namef(d) — $(path(d))(idf(d)) 

Defined below are the descriptor component access functions, a few related constructor and 
access functions, and some convenient additional predicates. 


idf(d) = hd(d) 
qid(d) = hd(tl(d)) 


46 



tag(d) = hd(tl(tl(d))) 

path(d) = hd(tl(tl(tl(d)))) 

exported(d) = hd(tl(tl(tl(tl(d))))) 

configured-entity(d) = hd(tl(tl(tl(tl(d))))) 

component-name(d) = hd(tl(tl(tl(tl(tl(d)))))) 

type-tick-low(d) = hd(tl(tl(tl(tl(tl(d)))))) 

type-tick-high(d) =. hd(tl(tl(tl(tl(tl(tl(d))))))) 

base-type(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

parent-type(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

literaJs(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

pbody(d) = hd(tl(tl(tl(tl(tl(d)))))) 

type(d) = hd(tl(tl(tl(tl(tl(d)))))) 

value(d) = hd(tl(tl(tl(tl{tl(tl(d))))))) 

sources(d) = hd{tl(tl(tl(tl(tl(tl(tl(d)))))))) 

signatures(d) = hd(tl(tl(tl(tl(tl(d)))))) 

body(d) = hd(tl(tl(tl{tl(tl(tl(d))))))) 

characterizations(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

direction(d) = hd(tl(tl(tl(tl(tl(d)))))) 

lb(d) = hd(tl(tl(tl(tl(tl(tl(d))))))) 

ub(d) = hd(tl(tl(tl(tl(tl(tl(tl(d)))))))) 

elty(d) = hd(tl(tl(tl(tl(tl(tl(tl(tl(d))))))))) 

components(d) = hd(tl(tl(tl(tl(tl(d)))))) 

mk-real«dotted-name(id*) 

= (null(id*)—► £, 

let first-id = hd(id*) 

and rest-ids = tl(id*) in 
(null(rest-ids)—► first-id, 

catenate(first-id,“. ” ,mk-real-dotted-name(rest-ids)))) 


pars(signature) = hd(signature) 
rtype(signature) = hd(tl(signature)) 


47 



get-base-type(d) = (tag(d)= ^SUBTYPE* base-type(d), d) 


get-parent-type(d) 

= (tag(d)e (*INT_TYPE* *DERIVED-.TYPE*) — parent-type(d), 
error(cat(‘‘Not a derived type: ”)(d))) 

mk-type(tmode){tdesc) = (tmode,tdesc) 
tmode(type) = hd(type) 
tdesc(type) = hd(tl(type)) 

mk-tmode(object-class)(ref*mode) = (object-class,ref-mode) 
object-class(tmode) = hd(tmode) 
ref-mode(tmode) = hd(tl(tmode)) 

is-const?(type) = object-class(tmode(type))= CONST 
is-var?(type) — object-class(tmode(type))= VAR 
is-sig?(type) = object-class(tmode(type))= SIG 

is-readable?(type) = ref-mode(tmode(type))E (VAL REF) 
is-writable?(type) = ref-mode(tmode(type))G (REF OUT) 

is-ref?(expr) =;= consp(expr)A length(expr)= 2 
is-paggr?(expr) = hd(expr)= PAGGR 

is-unary-op?(op) = op 6 (NOT PLUS NEG ABS) 
is-binary-op?(op) 

= op € (AND NAND OR NOR XOR ADD SUB MUL DIV MOD REM EXP CONCAT) 
is-relational-op?(op) = op 6 (EQ NE LT LE GT GE) 


48 



6.3 Special-Purpose Environment Components and Functions 

Certain component environments r of the tree-structured environment (TSE) part of the 
translation state have special identifier-like names that are bound to values specific to that 
environment’s associated program unit (design file, configuration, package, entity, architec¬ 
ture, component, block, process, procedure, function, or loop): 

♦UNIT* : 

r(*UNIT*) contains a tag that identifies what kind of program unit led to the cre¬ 
ation of r. These tags are *DESIGN-FILE* (design file), *PACKAGE* (package), 
♦ENTITY* (entity), *ARCHITECTURE* (architecture), *PROCESS* (pro¬ 
cess), *PROCEDURE* (procedure), *FUNCTION* (function), and *LOOP* 
(loop). These tags are used to locate the innermost instance of a specific kind of 
environment (such as one associated with a process) on the current lookup path in 
the TSE. 

*LAB* : 

When the tag of r(*UNIT*) is *ARCHITECTURE*, the value bound to r(*LAB*) 
contains an identifier list of all the labels of concurrent statements (blocks or processes) 
in the corresponding architecture body. When the tag of r(*UNIT*) is ♦PRO¬ 
CESS*, *PROCEDURE*, *FUNCTION*, or *LOOP*, the value bound to 
r(*LAB*) contains an identifier list of all the loop labels declared in the program 
unit. These lists are used to ensure that the identifiers serving as process and loop 
labels are distinct in (the top-level scope of) each program unit. 

♦USED* : 

The environment corresponding to any program unit admitting USE clauses in its 
declarative part has a *USED* component. In this case, r(*USED*) is a list repre¬ 
senting the set of fuUy qualified names of packages named in USE clauses appearing in 
that declarative part, omitting the qualified names of packages that textually enclose 
those USE clauses. In order to ensure that the TSE used in Phase 2 of the Stage 4 
VHDL translator can remain fixed as that generated by Phase 1, a slight restriction 
is imposed on the concrete syntax of Stage 4 VHDL. This restriction requires that 
all of the USE clauses in a declarative part appear only at the end of that declarative 
part. This will be discussed more fuUy later. 

♦IMPT* : 

Whenever a program unit has a *USED* component, it also has a *IMPT* com¬ 
ponent. r(*IMPT*) is a list of the fully qualified names of those items that can be 
imported into the program unit’s environment by the elaboration of the USE clauses 
in its declarative part. Consequently, no two of these fully qualified names can have 
the same last identifier (unqualified name), nor can the last identifier of any of these 
fuUy qualified names be the same as an identifier whose (local) declaration appears in 
this program unit’s declarative part. 

♦SENS* : 

When the tag of r(*UNIT*) is *PROCESS*, the value bound to r(*SENS*) con- 


49 




tains a list of the transformed abstract syntax trees of the refs appearing in that pro¬ 
cess’ sensitivity list. Phase 1 translation of a WAIT statement occurring in a PROCESS 
statement checks to make sure this *SENS* list is empty; otherwise, the WAIT occurs 
illegally in a process with a sensitivity list. 


Special Phase 1 Functions 

Three special-purpose Phase 1 functions defined by SDVS are set-difference, new-array- 
type-name, and delete-duplicates; these are provided by SDVS because of the difficulty 
of writing their definitions in the DENOTE language (DL). 

Function set-difference returns the set difference of two lists. Function new-array- 
type-name returns a new unique name for an anonymous array type. Function delete- 
duplicates destructively deletes duplicate items from a list. 

Error Reporting 

Phase 1 errors are reported by three SDVS functions: error, which takes a string-valued er¬ 
ror message; error-pp, which takes a string-valued error message and an additional VHDL 
abstract syntax subtree to be pretty-printed; and cat, which makes a string from its (vari¬ 
able number of) arguments, each of which is made into a string. 

6.4 Phase 1 Semantic Domains and Functions 

The formal description of Phase 1 translation consists of semantic domains and semantic 
functions, the latter being functions from syntactic to semantic domains. Compound se¬ 
mantic domains are defined in terms of primitive semantic domains. Similarly, primitive 
semantic functions are unspecified (their definitions being understood implicitly) and the 
remaining semantic functions are defined (by syntactic cases) via semantic equations. 

The principal Phase 1 semantic functions (and corresponding Stage 4 VHDL language con¬ 
structs for which they perform static analysis) are: DFT (design files), DUT (design units), 
CIT (context items), LUT (library-units), CFT (configuration declarations), BCT (block 
configurations), CMT (component configurations), BIT (binding indications), ENT (en¬ 
tity declarations), ART (architecture bodies), GDT (generic declarations), PDT (port 
declarations), GMT (generic maps), PMT (port maps), DT (declarations), CST (con¬ 
current statements), SLT (sensitivity lists), SST (sequential statements), AT (case alter¬ 
natives), DRT (discrete ranges), WT (waveforms), TRT (transactions), MET (reference 
lists), ET and RT (expressions), OTl (unary operators), OT2 (binary and relational 
operators), B (bit literals), and N (numeric literals). 

Each of the principal semantic functions requires an appropriate syntactic argument — an 
abstract syntactic object (tree) generated by the Stage 4 VHDL language parser. Most of 
the semantic functions take (at least) the following additional arguments: 

• a path, indicating the currently visible portion of the (partially constructed) tree- 
structured environment; 


50 




• a continuation, specifying which Phase 1 semantic function to invoke next; and 

• a (partially constructed) TSE, containing the information gathered from declarations 
previously elaborated and checked. 

In the absence of errors, the Phase 1 semantic functions update the TSE. Moreover, ET 
and RT also construct a pair consisting of an expression’s type and its static value. The 
type is either a value type or a reference type; see Section 6.2. Only an expression with a 
reference type may be the target of an assignment operation. 

An expression’s static value is *UNDEF* (‘‘undefined”) unless it is a static expression, in 
which case its static value is determined as follows. A static expression is: 

• a boolean, bit, numeric, or character literal: the static value is the value of the 
corresponding constant; 

• an identifier explicitly declared as a scalar constant and initialized by a static expres¬ 
sion: the static value is the static value of the initialization expression; 

• an operator applied to operands that are static expressions: the static value is deter¬ 
mined by the semantics of the operator and the static value of the operands; 

• a static expression enclosed in parentheses: the static value is the static value of the 
enclosed static expression. 

Note that a subscripted array reference, even if the subscript is a static expression and the 
array was declared as a constant initialized with a list of static expressions, is not a static 
expression. (The same is true for a selected record component.) 


6.4.1 Phase 1 Semantic Domains 


The semantic domains and function types for Phase 1 of the Stage 4 VHDL translator are 
as follows. 

Primitive Semantic Domains 


Bool = 
Bit = 
Char = 
n : N = 

{FALSE, TRUE) 

{0,1} 

{(CHAR 0), ..., (CHAR 127)} 
{0, 1,2,...} 

id ; Id 
Sysid 


t : TEnv 
d : Desc 



boolean constants 
bit constants 

character constants (ASCII-128 representations) 
numeric constants (natural numbers) 

identifiers 

system-generated identifiers (disjoint from Id) 

tree-structured environments (TSEs) 
descriptors (see Section 6.2) 


51 




sd : SD 
Assert 


state deltas 

SDVS Simplifier assertions 


Error error messages 

Compound Semantic Domains 

elbl : Elbl Id + Sysid TSE edge labels 

p, q: Path = Elbl* TSE paths 

qname: Name = Elbl (. Elbl)* qualified names 

d : Dv = Desc denotable values (descriptors) 

r : Env = Id (Dv + {*UNBOUND*}) environments 

Tmode {PATH} X Id* + type modes 

({CONST, VAR, SIG, DUMMY) x 
{VAL, OUT, REF, OBJ, ACC, TYP}) 

: Type = Tmode X Desc types 

e : Value values 

h : CSet = P(Bool) + P(Char) + P/(N) case selection sets [P(») denotes “powerset of” 
+ {INT} + {ENUM} and P/{•) denotes “set of finite subsets of”] 


u : TDc TEnv — ^ Ans declaration & concurrent statement continuations 

c : TSc = TDc sequential statement continuations 

k : TEc = (Type x Value) —^ TSc expression continuations 

h : TMc — (Type* X Value*) ^ TSc reference list continuations 

y : TAc = CSet ^ TSc case alternative continuations 

V : TTc = Type -h* Ans type continuations 

z : Desc — > TDc descriptor continuations 

Ans = (SD + Assert)* + Error final answers 


6.4.2 Phase 1 Semantic Functions 

The semantic functions for Phase 1 of the Stage 4 VHDL translator are as follows. 

DFT : Design —^ Id Ans design file static semantics 

DUT : DUnit* ^ Id —> Path —> Bool ^ TDc —^ TDc design unit static semantics 

CIT : Cltem* ^ Path Bool —^ TDc TDc context item static semantics 

LUT : LUnit Id —> Path Bool ^ TDc ^ TDc library unit static semantics 


CFT : Config ^ Path ^ TDc TDc 

BCT : BConf ^ Id Path ^ TDc ^ TDc 

CMT : CConf Id ^ Path — TDc ^ TDc 

BIT : Bind Id ^ BConf ^ TDc TDc 

ENT : Ent Path TDc ^ TDc 

ART : Arch ^ Path ^ TDc TDc 

GDT : GDec*^ ^ Path Bool -> TDc ^ TDc 

PDT : PDec* ^ Path ^ Bool TDc ^ TDc 

GMT : GMap Id ^ Id Path ^ Path 
^ TDc ^ TDc 

PMT : PMap Id ^ Id — Path ^ Path 
^ TDc TDc 

DT : Dec" Path Bool ^ TDc TDc 

CST : CStat" Path ^ TDc TDc 
SLT : Ref ^ Path TDc ^ TDc 
SST : SStat" ^ Path TSc ^ TSc 
AT : Alt" ^ Type Path —> TAc TSc 

DRT : Drg ^ Type Path TAc ^ TSc 
WT : Wave Path TEc ^ TSc 
TRT : Trans" ^ Path TEc ^ TSc 


MET : 

Ref* ^ Path 

TMc ^ 

TSc 

ET : 

Expr ^ Path 

^ TEc -> 

TSc 

RT : 

Expr ^ Path 

-> TEc 

TSc 

OTl : 

Uop TEc - 

^ TEc 



configuration declaration static semantics 
block configuration static semantics 
component configuration static semantics 
binding indication static semantics 
entity declaration static semantics 
architecture body static semantics 
generic declaration static semantics 
port declaration static semantics 

generic map static semantics 

port map static semantics 
declaration static semantics 
concurrent statement static semantics 
sensitivity fist static semantics 
sequential statement static semantics 
case alternative static semantics 
discrete range static semantics 
waveform static semantics 
transaction static semantics 
reference list static semantics 
expression static semantics 
expression static semantics 
unary operator static semantics 


53 



OT2 : 

Bop TEc —^ (Type x Value) —^ TEc 

binary, relational operator static semantics 

B : 

BitLit —^ Bit 

bit values of bit literals 



(primitive) 

N : 

NumLit N 

integer values of numeric literals 



(primitive) 


54 



6.5 Phase 1 Semantic Equations 
6.5.1 Stage 4 VHDL Design Files 

(DFTl) DFT I DESIGN-FILE id design-unit'*' | (using-configuration) 

= let to = mk-initial-tse() in 
let p = %(e)(id) in 
let ti = enter-standard (to) in 
let t2 = enter-textio(ti) in 

let t3 = enter(t 2 )( 5 )(id)(<£ *DESIGN-FILE* ,e>) in 
let t4 = enter(extend(t3)(£)(id))(p)(*UNIT* )(<e *DESIGN-FILE* >) in 
let ts = enter(t4)(p)(*LAB* )(<£,€>) in 
let to = enter(t5)(p)(*USED* )(<£,£>) in 
let ty — enter(t 6 )(p)(*IMPT* )(<£,£,£>) in 
enter-objects 

((VHDLTIME ,VHDLTIMEJ?REVIOUS )) 

(<£ *OBJECT* ,£,tt, 

((DUMMY ,VAL ),vhdltime-type-desc(to)) *UNDEF* ,£>)(t7)(e)(u) 
where 

u = At.let use-clause = (USE ,((STANDARD ,ALL ))) in 
DT [use-clause ]] (e)(tt)(ui)(t) 

where 

ui = At.DUT [[ design-unit] (using-configuration)(p)(tt)(u2) 

(t) 

where 

U2 = At.phasel-tail(t)(using-configuration)(p)(u3) 
where 

U3 = At.let transformed-abstract-syntax-tree = intermediate-phcise 

(design-file) 
(using-configuration) 
(t) in 

phase 2 
(id) 

(transformed-abstract-syntax-tree)(t) 

(using-configuration) 


enter-standard(t) 

= let ti = enter-package(t)(£)(STANDARD ) in 
let t2 = enter(ti)(e)(*USED’*' )(<e,e>) in 
let ts = enter(t2)(e)(*IMPT'^ )(<£,£,£>) in 
let I4 = enter-standard-predefined(t3)((STANDARD) ) in 
t4 


enter-textio(t) 

= let ti = enter-package(t)(£)(TEXTIO ) in 
let t2 = enter(ti)(e)(*USED* )(<e,e>) in 
let t3 = enter(t2)(e)(*IMPT* )(<£,£,£>) in 
let t4 = enter-textio-predefined(t3)((TEXTIO) ) in 

t 4 

enter-objects(id*) (field-values)(t)(p)(u) 

= (null(id* )—► u(t), 
let id = hd(id*) in 

(t(p)(id)7^ *UNBOUND* error(cat(“Duplicate object declaration: ”)($(p) 

(id))). 

let ti = enter(t)(p)(id)(field-values) in 
enter-objects(tl(id*))(field-vaJues)(ti )(p)(u))) 


55 



phasel-taiI(t)(using-configuration)(p)(u) 

= let ti = update-tse-wrt-component-instantiations(using-configuration)(t) in 
let t2 = update-tse-wrt-configuration(ti )(using-configuration)(p) in 
U(t 2 ) 

intermediate-phase(design-fiIe)(using-conliguration)(t) 

= DFX I design-file J (using-configuration)(t) 

enter-standard-predefined (t)(p) 

= let ti = enter(t)(p)(BOOLEAN )(<£,=*^BOOL* ,(STANDARD) ,tt,FALSE ,TRUE >) in 
let t2 = enter 

(tO(p)(BIT) 

(<£,*BIT* ,(STANDARD) ,tt,mk-bit-simp-symbol( 0 ), 
mk-bit-simp-symbol(l)>) in 

let t3 = enter(t2)(p)(UNIVERSALJNTEGER )(<e ♦INT* ,(STANDARD) ,tt,e,£>) in 
let t4 = enter(t3)(p)(INTEGER)(<e*INT* ,(STANDARD) ,tt,e,£>) in 
let t5 = enter(t4)(p)(REAL )(<£,’^REAL* ,(STANDARD) ,tt,e,£>) in 
let te = enter(t5)(p)(TIME )(<e,*TIME* ,(STANDARD) ,tt,€,£>) in 
let tr = enter(t 6 )(p)(VHDLTIME )(<£ *VHDLTIME* ,(STANDARD) ,tt,£,e>) in 
let tg = enter(t7)(p)(VOID )(<€,*VOID* ,(STANDARD) ,tt,e, 6 :>) in 
let t9 = enter(t 8 )(p)(POLY )(<e *POLY* ,(STANDARD) ,tt,£, 6 >) in 
let tio = enter 

(t 9 )(p)(BIT.VECTOR ) 

(tl(array-type-desc 

(BIT_VECTOR )(£)((STANDARD) )(tt)(TO )((NUM 0 ) )(e) 
(bit-type-desc(t9)))) in 
let til = enter-characters(tio)(p) in 
let ti2 = enter-strmg(tii )(p) in 
ti 2 

enter-textio-predefined(t)(p) = t 

enter-package(t)(p)(id) 

= let pi = %(p)(id) in 

let package-desc = <e,*PACKAGE* ,p,tt,e:> in 
let ti = enter(t)(p)(id)(package-desc) in 
let t2 = enter(extend(ti)(p)(id))(pi)(*UNIT’*')(<£ ^PACKAGE* >) in 
let t3 = enter(t2)(pi )(’*'USED* )(<£,£>) in 
let t4 = enter(t3)(pi)(*IMPT* )(<£,£,£>) in 
t 4 

enter-characters(t)(p) 

= let id^ = gen-characters( 0 )( 127 ) in 

let field-valuesi = <£,*ENUMTYPE* ,p,tt,hd(id‘‘'),last(id‘‘'),id'''> in 
let char-type-desc = cons(CHARACTER ,field-valuesi) in 
let field-values2 = <£,*''ENUMELT* ,p,tt,mk-type((CONST VAL) )(char-type-desc)> in 
en ter-ob jects(id^) (field-values2 )(t)(p)(u) 
where u = Ati .enter(ti)(p)(CHARACTER )(field-valuesi) 

gen-characters(start)(finish) 

= (start = finish —► ((CHAR ,finish)), 

cons((CHAR ,start),gen-characters(startd-l)(finish))) 

enter-string(t)(p) 

= let expr = (NUM 1 ) in 

let string-type-desc = array-type-desc 

(STRING )(£)(p)(U)(TO )(second(EX [ expr ] (p)(t)))(£) 
(char-type-desc(t)) in 
enter(t)(p)(STRING )(tl(string-type-desc)) 


56 



6.5.2 Design Units 

(DUTO) PUT [[e ] (using-configuration)(p)(vis)(u)(t) ^ u(t) 


(DUTl) PUT [[ design-unit design-unit* ]] (using-configuration)(p)(vis)(u)(t) 

= PUT [[ design-unit J (using-configuration)(p)(vis)(ui )(t) 

where uj = At. PUT F design-unit* | (using-configuration){p)(vis)(u)(t) 


(DUT 2 ) PUT J PESIGN-UNIT context-item* library-unit | (using-configuration)(p)(vis)(u)(t) 
= CIT [[ context-item* ]| (p)(vis)(ui )(t) 

where ui = At. LUT If library-unit | (using-configuration)(p)(vis)(u)(t) 


6.5.3 Centex Items 

(CITO) CIT[[£l(p)(vis)(u)(t) =u(t) 


(CITl) CIT [[ context-item context-item* | (p)(vis){u)(t) 

= CIT I context-item | (p)(vis)(ui )(t) 

where ui = At. CIT [context-item* ] (p)(vis)(u)(t) 


(C 1 T 2 ) CIT I USE dotted-name+ | (p)(vis)(u)(t) 
= let decl = context-item in 
PTldecll (p)(vis)(u)(t) 


6.5.4 Library Units 

(LUTI) LUT [CONFIGURATION idi id2 use-clause* block-config opt-id ] (using-coniiguration)(p)(vis){u)(t) 
= u(t) 


(LUT 2 ) LUT [PACKAGE id decl* opt-id ] (using-configuration)(p)(vis)(u)(t) 
= let decl = library-unit in 
PT[decl 1 l(p)(vis)(u)(t) 


(LUTS) LUT [ ENTITY id generic-deci* port-ded* decl* opt-id J (using-configuration)(p)(vis)(u)(t) 
= let entity-decl = library-unit in 
ENT [ entity-decl ]] (p)(u)(t) 


(LUT 4 ) LUT [ PACKAGEBOPY id decl* opt-id J (using-configuration)(p)(vis)(u)(t) 
= let decl = library-unit in 
PT [decl ] (p)(vis)(u)(t) 


(LUTS) LUT [ ARCHITECTURE idi id2 decl* conc-stat* opt-id | (using-configuration)(p)(vis)(u)(t) 
= let architecture-body = library-unit in 

ART [ architecture-body ] (using-configuration)(p)(u)(t) 


57 



6.5.5 Configuration Declarations 

(CFTl) CFT J CONFIGURATION idi id2 use-clause* block-config opt-id | (p)(u)(t) 

= (*~»nuLl(opt-id)A opt-id ^ idi 
—► error 

(cat(“Configuration declaration ”)(idi) 

(“ ended with incorrect identifier: ”)(opt-id)), 
let d = t(p)(id2) in 

(d = ^UNBOUND* V tag(d)^ *^ENTITY* 

—► error 

(cat(“No entity ”)(id2)(“ for configuration declaration ”)(idi)), 

(t(p)(idi)^ ^UNBOUND* 

—► error(cat( “Duplicate configuration declaration: ”)(S(p)(idi))), 
let ti = enter(t)(p)(idi)(<£,*CONFIGURATION* ,p,id2>) in 
let pi = %(p)(idi) 

and p2 = %(p)(id2) in 
let t2 = enter 

(extend(ti)(p)(idi))(pi)(*UNIT* )(<e ^CONFIGURATION* >) in 
let t3 = enter(t2)(pi)(*LAB* )(<£,£>) in 
let t4 = enter(t3)(pi)(*USED* )(<£,£>) in 
let ts = enter(t4)(pi)(*IMPT* )(<£,£,£>) in 
DT I use-clause* | (pi)(tt)(ui)(t5) 
where U] = At. BCT [ block-config ] (idi )(p2 )(u2)(t) 
where U2 = At.u(t)))) 


(BCTl) BCT [ BLOCK-CONFIG id use-clause* component-config* | (configuration-id)(p)(u)(t) 
= let d = t(p)(id) in 

(d == *UNBOUND* V tag(d) 9 .^ *ARCHITECTURE* 

—+ error 

(cat(“In configuration declaration ”)(configuration-id) 

(“the identifier ”)(id) 

(“fails to refer to an architecture of entity ”) 

(last(p))), 

let Pi = %(p)(id) in 
DT [ use-clause* | (p)(tt)(ui )(t) 

where ui = At.CMT | component-config* ]] (configuration-id)(pi )(u)(t)) 


(CMTO) CMT I e J (configuration-id)(p)(u)(t) u(t) 

(CMTl) CMT [[component-config component-config* ] (configuration-id)(p)(u)(t) 

= CMT [[ component-config J (configuration-id)(p)(ui )(t) 

where ui = At. CMT [[component-config* J (configuration-id)(p)(u)(t) 

(CMT2) CMT [[ COMP-CONFIG component-spec opt-binding-indication opt-block-config J (configuration-id)(p)(u)(t) 
= let id'*' = hd(component-spec) 

and component-name = second(component-spec) 
and arch-id = last(p) in 

let d = lookup-desc-for-ref((REF ,component-name))(p)(t) in 
(d = *UNBOUND* V tag(d)y^ *COMPONENT* 

—♦ error 

(cat(“In configuration declaration (configuration-id) 

(“there is no component declaration ”) 

(mk-real-dotted-name(component-name)) 

(“for component instances ”)(id'*') 

(“in architecture body ”)(arch-id)), 


58 



let Pi = %(p)(idf(d)) in 

process-component-spec(id‘^ )(configuration-id)(arch-id)(p)(ui )(t) 
where 

ui = At.(nuU(opt-bmding-indication) 

—► (null(opt-block-config)^ u(t), 
error 

{cat(“Configuration ”)(configuration-id) 

(“has no binding indication for component specification ”) 
(component-spec))), 

let binding-indication = opt-binding-indication in 
BIT 1 binding-indication ]] (configuration-id) 

(opt-block-config)(pi )(u)(t))) 

process-corn ponent-spec(id*)(configuration-id)(arch-id)(p)(u)(t) 

— (null(id*)—u(t), 

let component-id — hd(id*) in 
let d = t(p)(component-id) in 
(d = ^UNBOUND* V tag(d)# *BLOCKNAME* 

—► error 

(cat(“In configuration ”)(configuration-id)(“the label ”)(component-id) 

(“matches no component instantiation statement in architectiore body ”) 
(arch-id)), 

process-component-spec(tl(id*))(configuration-id)(arch-id)(p)(u)(t))) 


(BITl) BIT [ BIND entity-aspect opt-generic-map-aspect opt-port-map-aspect ] 
(configuration-id )(opt-block-config)(p)(u)(t) 

= (hd(entity-aspect)=: BOUND-ENTITY 
—► process-bound-entity 

(entity-zispect)(opt-generic-map-2Lspect)(opt-port-map-aspect) 
(configuration-id )(opt-block-config)(p)(u)(t), 
process-bound-configuration 

(en tity-aspect)(opt-generic-map-aspect) (opt-port-map-aspect) 
(configuration-id)(opt-block-config)(p)(u)(t)) 


process-bound-entity (entity-aspect) 

(opt-generic-map-aspect) (opt-port-map-aspect)(configuration-id)(opt-block-config) 

(p)(u)(t) 

= let dotted-name = second(entity-aspect) 
and opt-id = third(entity-aspect) in 
let real-dotted-name = mk-real-dotted-name(dotted-name) 

and d = lookup-desc-for-ref((REF ,dotted-name))(p)(t) in 
(d = ^UNBOUND* V tag(d)/ ^ENTITY* 

—► error 

(cat(“Configuration declaration ”)(configuration-id) 

(“refers to unknown entity ”)(real-dotted-name)), 
let q = %(path(d))(idf(d)) in 
(opt-generic-map-aspect 

—^ let generic-map-cispect = opt-generic-map-aspect in 

GMT [[ generic-map-aspect | (configuration-id)(CONFIGURATION )(q)(p)(ui )(t), 
(null(third(t(p)(*GENERICS* )))-* ui(t), 
error 

(cat(“Configuration declaration ”)(configuration-id) 

(“requires a generic map for entity aspect ”) 

(entity-aspect)))) 

where 



U] = At.(opt-port-map-aspect 

let port-map-aspect = opt-port-map-aspect in 
PMT [ port-map-aspect J {configuration-id)(CONFIGURATION )(q) 

(P)(u2)(t), 

(null(third(t(p)('*'PORTS* )))—► U2(t), 
error 

(cat(“Configuration declaration ”)(conliguration-id) 

(“requires a port map for entity aspect ”) 

(entity-aspect)))) 

where 

U2 = At.(nuU(opt-id)-+ u(t), 

(null(opt-block-config)—► u(t), 

(opt-id ^ second (opt-block-config) 

—► error 

(cat(“In configuration declaration "’)(configuration-id) 

(“the block specification identifier ”) 

(second (opt-block-config)) 

(“does not match the architecture identifier ”) 

(opt-id)(“of the associated boimd entity ”) 

(entity-aspect)), 

U 3 (t)))) 

where 

U3 = At.let block-config = opt-block-config in 

BCT [[ block-config J (configuration-id)(q)(u)(t)) 

process-bound-configuration(entity-aspect) 

(opt-generic-map-aspect) (opt-port-map-aspect) (configuration-id) (opt-block-config) 

(p)(u)(t) 

= let dotted-name = second(entity-aspect) in 

let real-dotted-name = mk-reai-dotted-name(dotted-name) 

and d = lookup-desc-for-ref((REF ,dotted-name))(p)(t) in 
(d = ^UNBOUND* V tag(d)# ^CONFIGURATION* 
error 

(cat(“Configuration declaration ”)(configuration-id) 

(“refers to unknown configuration ”)(real-dotted-name)), 


6.5.6 Entity Declarations 

(ENTl) ENT [[ ENTITY id generic-decl* port-decl* decl* opt-id J (p)(u)(t) 

= (-'null(opt-id)A opt-id ^ id 
—error 

(cat(“Entity declaration ”)(id) 

(“ ended with incorrect identifier: ”)(opt-id)), 

(t(p)(id)/ ^UNBOUND* 

—error(cat(“Duplicate entity declaration: ”)($(p)(id))), 
let ti = enter(t)(p)(id)(<£,*ENTITY* ,p,ff>) in 
let pi = %(p)(id) in 

let t2 = enter(extend(ti)(p)(id))(pi)(*UNIT* )(<e,*ENTITY* >) in 
let t3 = enter(t2)(pi)(*LAB* )(<e,e>) in 
let t4 = enter(t3)(pi)(*USED* ){<e^e>) in 
let ts = enter(t4)(pi )(*IMPT* )(<e,e,£:>) in 
let te = enter(t4)(pi)(*GENERICS* )(<e,e>) in 
let t? = enter(t4)(pi )(*PORTS* )(<e:,e>) in 
GDT I generic-decl* | (pi )(tt)(ui )(t7) 



where ui = At. PDT [[ port-deel* | (pi)(tt)(u2)(t) 
where U2 = At. DT [ ded* ] (pi )(tt)(u)(t))) 


6.5.7 Architecture Bodies 

(ARTl) ART [ARCHITECTURE idi id2 ded* conc-stat* opt-id ] (usiiig-configuration)(p)(u)(t) 

= (-inull(opt-id)A opt-id idi 
—*■ error 

(cat(“Architecture body ”)(idi) 

(“ ended with incorrect identifier ”)(opt-id)), 
let d = t(p)(id2) in 

(d = ^UNBOUND* V tag(d)# ^ENTITY* 

^ error(cat(“No entity ”)(id2)(“ for architecture body ”)(idi)), 
let Pi = %(p)(id2) in 
(t(Pi)(icli)# ^UNBOUND* 

error(cat(“Duplicate architecture body: ”)(${pi )(idi))), 
let p2 = %(pi)(idi) in 

let ti = enter(t)(pi)(idi)(<e ^ARCHITECTURE* ,pi,fr>) in 
let t2 = enter 

(extend(ti)(pi)(idi))(p2)(*UNIT* )(<£ ^ARCHITECTURE* >) in 
let t3 = eiiter(t2)(p2)(*LAB* )(<e,e>) in 
let t4 = enter(t3)(p2)(*USED* )(<£,£>) in 
let ts = enter(t4)(p2)(*IMPT* )(<£,£,€:>) in 
DTldecl* I(p 2 )(tt)(ui)(t 5 ) 
where 

ui = Ate. CST [ conc-stat* ] (using-configuration)(p2)(u)(t 6 )))) 


6.5.8 Generic Declarations 

(GOTO) GDT I e | (p)(vis)(u)(t) = u(t) 

(GDTl) GDT I generic-decl generic-decl* | (p)(vis)(u)(t) 

= GDT [ generic-decl ] (p)(vis)(ui )(t) 

where ui = At, GDT [generic-decl* ] (p)(vis)(u)(t) 

(GDT2) GDT [ DEC GENERIC id+ type-mark opt-expr ] (p)(vis)(u)(t) 

= lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let type = mk-type((REF VAL) )(d) in 

let generic* = third(t(p)(*GENERICS* )) in 
let generic* = append(id"‘',generic*) in 
(duplicates?(genericj) 

—► error 

(cat(“Duplicate generics declcired in generic clause: ”) 
(generic-decl)), 

let ti = enter(t)(p)(*GENERICS* )((e,genericj)) in 
process-dec(id“^ )(type)(opt-expr)(p)(vis)(u)(ti)) 

(GDT3) GDT If SLCDEC GENERIC id+ slice-name opt-expr ]] (p)(vis)(u)(t) 

= let (type-mark,discrete-range) = slice-name in 
lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let type = mk-type((REF VAL) )(d) in 


61 



let generic* = third(t(p)(*GENERICS* )) in 
let generic* = append(id“‘^,generic*) in 
(duplicates?(generic*) 
error 

(cat(“Duplicate generics declared in generic clause: 

(generic-decl)), 

let ti = enter(t)(p)(*GENERICS* )((£,genericn) in 

process-slcdec 

(id'*" )(type)(discrete-range)(opt-expr)(p)(vis)(u)(ti)) 

6.5.9 Port Declarations 

(PDTO) PDT I £ I (p)(vis)(u)(t) = u(t) 

(PDTl) PDT [ port-decl port-ded* ] (p)(vis)(u)(t) 

= PDT I port-decl ] (p)(vis)(ui )(t) 

where ui = At. PDT | port-decl* ] (p)(vis)(u)(t) 

The elaboration and checking of a sequence of port declarations proceeds from the first to 
the last declaration in the sequence. 

(PDT2) PDT H DEC PORT id'*' mode type-mark opt-expr ] (p)(vis)(u)(t) 

= lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let type = (case mode 

IN - mk-type((SIG VAL) )(d), 

OUT ^ mk-type((SIG OUT) )(d), 

(INOUT ,BUFFER ) -> mk-type((SIG REF) )(d), 

OTHERWISE 
—► error 

(cat(“Illegal mode in port declaration: ”) 

(port-decl))) in 

let port* = third(t(p)(*PORTS* )) in 
let portj = append(id'*',port*) in 
(duplicates?(porti) 

^ error 

(cat(“Duplicate ports declaired in port clause: ”) 

(port-decl)), 

let ti = enter(t)(p)(*PORTS* )((e,portf)) in 
process-dec (id'*' )(type)(opt-expr)(p)(vis)(u)(ti)) 

duplicates?( things) 

= (null(things)—*- fF, 

let first-thing = hd (things) 

and rest-things = tl(things) in 
(first-thing 6 rest-things —+ tt, duplicates?(rest-things))) 

Refer to the discussion following semantic equation DT5 in Section 6.5.11. 

(PDT3) PDT I SLCDEC PORT id'*" mode slice-name opt-expr | (p)(vis)(u)(t) 

= let (type-mark,discrete-range) = slice-name in 
lookup-type(type-mark)(p)(z)(t) 
where 



z = Ad.let type = (case mode 

IN ^ mk-type{(SIG VAL) .)(d), 

OUT mk-type((SIG OUT) )(d), 

(INOUT ,BUFFER ) ^ mk-type((SIG REF) )(d), 
OTHERWISE 
—► error 

(cat(“Illegal mode in port declaration: 
(port-deci))) in 

let port* = third(t(p)(*PORTS* )) in 
let portj = append(id‘*',port*) in 
(duplicates?(port*) 

—► error 

(cat(“Duplicate ports declared in port clause: ”) 
(port-decl)), 

let ti = enter(t)(p)(*PORTS* )((e,port*)) in 
process-slcdec 

(id"*" )(type)(discrete-range)(opt-expr)(p)(vis)(u)(ti)) 


Refer to the discussion following semantic equation DT6 in Section 6.5.11. 


6.5.10 Generic Maps and Port Maps 

(GMTl) GMT JGENERICMAP assoc-elt'*’ J (id)(context)(formals-path)(actuals-path)(u)(t) 
= let formal* = get-refs-identifiers(map-hd(cissoc-elt'^)) 

and actual* — get-refs-identifiers(map-second(assoc-elf*')) 
and formal-generic* = third(t(formals-path)(*GENERICS* )) 
and local-generic* = third(t(actuals-path)(*GENERICS* )) in 
(duplicates?(formar) 

—► error 

(cat( “Duplicate formal parts in association list: ”)(assoc-elf*‘)), 
(context = CONFIGURATION 

—^ check-existence-formals(id)(formal* )(formal-generic* )(m )(t), 
check-formal-local-correspondence 

(id)(formal*)(local-generic*)(ui )(t)) 
where 

ui = At.(context = CONFIGURATION 

—► check-coverage-locals 

(id) (local-gen eric* )(actual*)(u2)(t), 

u(t)) 

where 

U2 = At.type-check-genericmap-elements 

(assoc-elt'*' )(formals-path)(actuals-path)(u)(t)) 

type-check-genericmap-elements(assoc-elt* )(formals-path)(actuals-path)(u)(t) 

= (n ull( assoc-el t * )—► u(t), 

let assoc-elt = hd(assoc-elt*) in 

type-check-genericmap-element(assoc-elt)(formals-path)(actuals-path)(ui )(t) 

where 

ui = At.type-check-genericmap-elements 

(tl(assoc-elt*))(formals-path)(actuals-path)(u)(t)) 

type-check-genericmap-element(assoc-elt)(formals-path)(actuals-path)(u)(t) 

= let expri = hd(assoc-elt) 

and expr2 = second(assoc-elt) in 
ET [expri 1 (formals-path)(ki)(t) 


63 



where 

k] = A(wi ,ei ),t. 

RT [[ expr2 | (actuals-path)(k2 )(t) 
where 

k2 = A(w2,e2),t. 

(inatch-types(tdesc(wi),tdesc(w2))—♦ u(t), 
error 

(cat(“has type mismatch in generic map association element: 
(assoc-elt))) 


(PMTl) PMT I PORTMAP assoc-elt"^ J (id)(context)(formals-path)(actuais-path)(u)(t) 
= let formal* = get-refs-identifiers(map-hd(assoc-elt'^)) 

and actual* = get-refs-identifiers(map-second(assoc-elf*‘)) 
and formal-port* = third(t(formals-path)(’*'PORTS* )) 
and local-port* = third{t(actuals-path)(^PORTS* )) in 
(duplicates?(formaI*) 
error 

(cat( “Duplicate formal parts in association list: ”)(assoc-elf^)), 
(context CONFIGURATION 

—+ check-existence-formcils(id) (formal*) (formal-port *)(ui )(t), 
check-formal-local-correspondence(id)(formal*)(locaJ-port* )(ui )(t)) 
where 

ui = At.(context = CONFIGURATION 

—► check-coverage-locals(id)(local-port* )(actual*)(u2)(t), 

U2(t)) 

where 

U2 = At.check-portmap-elements 

(assoc-elt"*" )(formaIs-path)(actuals-path)(u)(t)) 

check-portmaj>-elements(assoc-elt* )(formals-path)(actuals-path)(u)(t) 

— (null(assoc-elt*)—► u(t), 

let assoc-elt = hd(assoc-elt*) in 

check-portmap-element(assoc-elt)(formals-path)(actuais-path)(ui )(t) 
where 

ui = At.check-portmap-elements 

(tI(assoc-elt*))(formals-path)(actuals-path)(u)(t)) 

check-portmap-element(assoc-elt)(formals-path)(actuaIs-path)(u)(t) 

= let expri = hd(assoc-elt) 

and expr2 = second(assoc-elt) in 
ET [[ expri | (formals-path)(ki )(t) 
where 

ki = A(wi,ei),t. 

ET I expr2 | (actuals-path)(k2 )(t) 
where 

k2 = A(w2,e2),t. 

(-«is-sig?(w2) 

—► error 

(cat( “Non-signal actual ”)(expr2) 

(“in port map element ”)(assoc-elt)), 
read-check-portmap-element(assoc-elt)(wi )(w2)(ui )(t) 
where 

ui = At.write-check-portmap-element 

(assoc-elt)(wi )(w2)(formals-path) 

(actuals-path)(u2 )(t) 

where 

U2 = At.type-check-portmap-element 

(assoc-elt)(tdesc(wi ))(tdesc(w2 ))(u)(l)) 


64 


read-check-portmap-element(assoc-elt)(wi )(w2)(u)(t) 

= (is-readable?(wi) 

—^ (is-readable?(w2^ u(t), 
error 

(cat(“Non-readable actual in port map association element: ”)(assoc-elt))), 

u(t)) 

write-check-portmaj>-element(assoc-elt)(formal-type)(actucd-type)(formal-path)(a.ctual-path)(u)(t) 
~ let actual = second(assoc-elt) in 
(is-writable?(formal-type) 

— (is-writable?(actual-type) 

—►let d = lookup-desc-for-ref(actual)(actual-path)(t) in 
let sources = sources(d) in 
(formal-path G sources —► u(t), 
rest(formal-path)E map-rest(sources) 

—► error(cat(“Resolved signal illegal in Stage 4 VHDL: ”)(namef 

(d))), 

let ti = enter 

(t)(path(d))(idf(d)) 

(<£,* 0 BJECT* ,path(d),exported(d),type(d),value{d), 
cons(formal-path,sources)>) in 

"(ti)). 

error 

(cat(“Non-¥ritable actual ”)(actual) 

(“in port map association element: ”)(assoc-elt))), 

u(t)) 

type-check-portmap-element(assoc-elt)(di )(d2 )(u)(t) 

= (match-types(di,d2)“^ u(f)> 

error(cat(“Type mismatch in port map association element: ”)(assoc-eIt))) 


check-existence-formals(id)(formal* )(compare-form2d*)(u)(t) 

= (null(formal*)^ u(t), 

let first-formal = hd(formal*) in 
(first-formal E compare-formal* 

—► check-existence-formals 

(id)(tl(formal* ))(remove(first-formal)(compare-formal* ))(u)(t), 

error 

(cat(“Statement or configuration declaration 
(“refers to unknown formal ”)(first-formal)))) 

check-formal-local-correspondence(id)(formal*)(locaI*)(u)(t) 

= (null(form2d*) 

—► (null(local*)—► u(t), 
error 

(cat(“Statement ”)(id) 

(“fails to associate actuals with the following formals: ”) 
(local*))), 

let first-formal = hd(formal*) in 
(first-formal E local* 

—► check-formal-local-correspondence 

(id)(tl(formal* ))(remove(first-formal)(local* ))(u)(t), 

error 

(cat(“In statement ”)(id)(“the formal ”)(first-formal) 

(“has no corresponding local ”)))) 


65 


check-coverage-locals(id)(local* )(compare-locaJ* )(u)(t) 

= (nulI(local*u(t), 

let first-local = hd(local*) in 
(first-local G compare-local* 

—check-coverage-loccds 

(id)(tl(locar))(remove(first-local)(compare-local* ))(u)(t), 

error 

(cat(“Configuration decl€Lration ”)(id)(“fails to associate the local ”) 
(first-local)(“as an actual with some formal”)))) 


6.5.11 Declarations 

(DTO) DT I £ J (p)(vis)(u)(t) = u(t) 

(DTI) DT [[ decl decl* ] (p)(vis)(u)(t) 

= DT I decl ] (p)(vis)(ui )(t) 

where ui = At.DT [[decl* | (p)(vis)(u)(t) 

(DT 2 ) DT [[ package-decl package-decl* J (p)(vis)(u)(t) 

= DT [ package-decl ] (p)(vis)(ui )(t) 

where uj = At. DT [[ package-decl* | (p)(vis)(u)(t) 

(DT 3 ) DT I package-body package-body* | (p)(vis)(u)(t) 

= DT I package-body J (p)(vis)(ui )(t) 

where uj = At. DT [ package-body* ] (p)(vis)(u)(t) 

{DT 4 ) DT [[ use-clause use-clause* | (p)(vis)(u)(t) 

= DT [[ use-clause | (p)(vis)(ui )(t) 

where ui = At. DT | use-clause* J (p)(vis)(u)(t) 

The elaboration and checking of a sequence of declarations proceeds from the first to the 
last declaration in the sequence. 

(DT 5 ) DT I DEC object-class id"** type-mark opt-expr | (p)(vis)(u)(t) 

= let q = find-progunit-env(t)(p) in 
let d = t(q)(*UNIT* ) in 
let tg = tag(d) in 
(case object-class 

(CONST ,SYSGEN ) —► lookup-type(type-mark)(p)(z)(t), 

VAR 
(case tg 

(^PACKAGE’*' ,*ENTITY’*' ♦ARCHITECTURE’*' ) 

—► error 

(cat(“Illegal VARIABLE declaration in ”)(tg)(“ context: ”) 

(decl)), 

OTHERWISE ^ lookup-type(type-mark)(p)(z)(t)), 

SIG 

—► (case tg 

(♦PROCESS* ,♦PROCEDURE* ,*FUNCTION* ) 

—► error 

(cat(“Hlegal SIGNAL declaration in ”)(tg)(“ context: ”) 

(decl)), 

OTHERWISE lookup-type(type-mark)(p)(z)(t)), 

OTHERWISE ^ error 

(cat(“Hlegal object class in declaration: ”)(decl))) 

where 

z = Ad.let type = (object-class = CONST —► mk-type((CONST VAL) )(d), 
mk-type(mk-tmode(object-class)(REF ))(d)) in 
process-dec(id'*^ )(type)(opt-expr)(p)(vis)(u)(t) 


66 


find-progunit-env(t)(p) 

= (t(p)(*UNIT* ^UNBOUND* — p, 

(null(p)—► error(“No program unit ??! ”), 
fincl-progunit-env(t)(rest(p)))) 

lookup-type(id* )(p)(z)(t) 

= (nulJ(id*)—► z(void'type-desc(t)), 
name-type(id*)(£)(p)(t)(v) 
where 

V = Aw.(second(tmode(w))= TYP z(tdesc(w)), 

error(cat(“Not a type: ”)(namef(tdesc(w)))))) 

naine-type(name)(w)(p)(t)(v) 

= (null(w) 

let wi =3 lookup2(t)(p)(e)(hd(name)) in 
(wi = ^UNBOUND* 

—^ error 

(cat(“Unbound identifier in auxiliary semantic function NAME-TYPE: ”) 
(${p)(hd(name)))), 
let tm = tmode(wi) 

and d = tdesc(wi) in 

(second(tm)G (OBJ TYP) —► name-type(tl(name))(wi)(p)(t)(v), 
hd(tni)= PATH 

—► (-1 validate-access(name)(wi )(second{tm)) 

—► error(cat(“Illegal access via: ”)(namef(d))), 
name-type(tl(name))(((PATH ,tl(second(tm))),d))(p)(t)(v)), 
error 

(cat(“Shouldn't happen in auxiliary semantic function NAME-TYPE: ”) 

let d = tdesc(w) in 
let tg = tag(d) in 
(null(name) 

^ (tg € (♦PROCEDURE* ♦FUNCTION*) 

—► (null(pars(hd(signatures(d))))—► v(extract-rtype(d)), 

error(cat(“Missing subprogram arguments: ”)(namef(d)))), 
v(w)), 

let X = hd(name) 

and tm = traode(w) in 
(consp(x) 

—► (second(tm)= TYP 
—(null(tl(x)) 

- name-type(tl(name))(((DUMMY ,VAL ),d))(p)(t)(v), 
error 

(cat(“Explicit conversion of multiple expressions to type: ”) 
(namef(d)))), 
list-type(x)(p)(t)(h) 
where 
h = Awl,et. 

((second(tm)= OBJ A is-array?(type(d))) 

V (second(tm)G (REF VAL) A is-array-tdesc?(d)) 

—► (length(x)> 1 

—► error(cat(“Too many array indices for: ”)(namef 

(d))). 

(is-integer-tdesc? (get-base-type{tdesc(hd(wj)))) 

—*■ name-type 

(tl(name)) 

((second(tm)= OBJ 


67 



—► mk-type(tmode(type(d)))(elty(tdesc(type(d)))), 
mk-type(tm)(elty(d))))(p)(t)(v), 
error(cat(“Non-integer array index for: ”)(namef 

(d))))), 

tg e (^PROCEDURE* ♦FUNCTION*) 

—* let rtype = compatible-signatures(wJ)(signatures(d)) in 
(null(rtype) 

—► error 

(cat(“Incompatible par8Lmeter types for: 

(namef(d))), 

name-type(tl(name))(rtype)(p)(t)(v)), 
error(cat(“Cannot have an argument list: ”)(nanief 

(d))))), 

((second(tm)= OBJ A is-record?(type{d))) 

V (second(tm)G (REF VAL) A is-record-tdesc?(d)) 
let di = (second(tm)= OBJ —»■ tdesc(type(d)), d) in 
let d 2 = lookup-record-field(components(di ))(x) in 
(d 2 = ^UNBOUND* —► error(cat(“Unknown record field: ”)(x)), 
let tmm = (second(tm)= OBJ —► tmode(type(d)), tm) in 

name-type(tl(name))(mk-type(tmm)(d 2 ))(p)(t)(v)), 

second(tm)y^ OBJ V second(tin) 7 ^ TYP 

—^ let wi = lookup-local(x)(%(path(d))(idf(d)))(p)(t) in 

(wi = ♦UNBOUND* 

—► error 

(cat(“Unknown identifier in function NAME-TYPE: 

($(%(path(d))(idf(d)))(x))), 

second(tmode(wi ACC —► narae-type(tl(name))(wi )(p)(t)(v), 

hd(tm)= PATH 

(-»null(tl(name))A -ivalidate-access(name)(wi )(second(tm)) 
error(cat(“Illegal access via: ”)(namef(tdesc(wi)))), 
name-type 

(tl(name))(((PATH ,tl(second(tm))),tdesc(wi )))(p)(t) 

(v)), 

error 

(cat(“Shouldn't happen in auxiliary semantic function NAME-TYPE: ”) 

(wi))), 

error(cat(“Illegal access via: ”)(namef(d))))))) 

lookup2(t)(p)(q)(id) 

= let d = t(p)(id) in 
(d = ^UNBOUND* 

(-^null(p)-^ lookup2(t)(rest(p))(cons(last(p),q))(id), ♦UNBOUND* ), 

(case tag(d) 

(♦OBJECT* ,*ENUMELT* ) ((DUMMY ,OBJ ),d), 

(♦PACKAGE* ,*COMPONENT* *PROCESS* *PROCEDURE* ,*FUNCTION* ,*LOOPNAME* , 
♦PROCESSNAME* *BLOCKNAME* ) 

^ ((PATH ,q),d), 

OTHERWISE ((DUMMY ,TYP ),d))) 

validate-access(name)(w)(q) 
r= let tg = tag(tdesc(w)) in 

(tg G (*PROCEDURE* ♦FUNCTION*) 

A (“«null(tl(name))A -^consp(hd(tl(name)))) 

—~'null(q)A hd(name)= hd(q), 
tt) 

list-type{expr* )(p)(t)(vv) 


68 



= (null(expr*)—^ vv(£), 

let expr hd(expr*) in 
ET ([expr] (p)(k)(t) 
where 
k A(w,e),t. 

(second(tinode(w))= ACC 

—► error(cat(“Non-value (an access): ”)(namef(tdesc(w)))(expr)), 
list-type(tl(expr*))(p)(t)(Aw*.vv(cons(w,w*))))) 

lookup-local(id)(definition-path)(occurrence-path)(t) 

= let d = t(definition-path)(id) in 

(d = ^UNBOUND* -- ^UNBOUND* , 
let tg = tag(d) in 

(tg e (*BLOCKNAME* *PROCESSNAME* *LOOPNAME*) ((DUMMY ,ACC ),d), 

(prefix-path(definition-path)(occurrence-path)V exported(d) 

—► (ccLse tg 

(♦OBJECT* *ENUMELT* ) -- ((DUMMY ,OBJ ),d), 

(♦PACKAGE* ♦COMPONENT* *BLOCK* *PROCESS* ♦PROCEDURE* *FUNCTION* ) 
^ ((DUMMY ,ACC ),d), 

OTHERWISE - ((DUMMY ,TYP ),d)), 

♦UNBOUND* ))) 

compatible-signatures(types)(signatures) 

= (null(signatures)—► e, 

let signature = hd(signatures) in 
(compatible-par-types(types)(extract-par-types(pars(signature))) 
rtype(signature), 

compatible-signatures(types)(tl(signatures)))) 

compatible-par-types(actuals)(formals) 

= (length(actuaJs)^ length(formals)—^ if, 
length(actuals)= 0 tt, 
let wi = hd(actuals) 

and W2 = hd(formats) in 
(match-types(tdesc(wi),tdesc(w2)) 

—^ let mi = ref-mode(tmode(wi)) 

and m2 = ref-mode(tmode(w2)) in 

(mi = REF V mi = m2 —► compatible-par-types(tl(actuals))(tl(forma]s)), if), 

ff)) 

extract-par-types(pars) 

(null(pars)-~+ e, cons(second(hd(pars)),extract-par-types(tl(pars)))) 
extract-rtype(d) 

= let signature = hd(signatures(d)) in 
rtype(signature) 

lookup-record-field(comp* )(id) 

= (nulI(comp*)-- ^UNBOUND* , 
let (x,d) = hd(comp*) in 
(x = id —^ d, lookup-record-iield(tl(comp*))(id))) 

process-dec(id'*' )(w)(opt-expr)(p)(vis)(u)(t) 

= (null(opt-expr) 

—► (is-const?(w)^ error(cat(“Uninitialized constant: ”)($(p)(hd(id'‘’)))), 
enter-objects(id+)(<£ ^OBJECT* ,p,vis,w *UNDEF* ,e>)(t)(p)(u)), 
let expr = opt-expr in 


69 



EX [expr I (p)(k)(t) 
where 

k = A(wi,e),t. 

let d = tdesc(w) 

and di = tdesc(wi) in 
(match-types(d,di) 

—► let init-val = ((is-sysgen?(w)V is-const?(w)) 

A -»(is-array?(w)V is-record?(w)) 

=^UNDEF^ ) in 

enter-objects(id'*' )(<e,*OBJECT* ,p, vis,w,init-val,e>)(t)(p)(u), 
error(cat(“Initialization type mismatch: ”)(d){di)))) 

match-types(di ,d2) 

= (case tag(di) 

(*BOOL* ,*BIT* ,*REAL* ,*TIME=^ ,*ENUMTYPE* ) ^ dj = get-base-type(d2), 
(*INT* *INT-TYPE* ) 

—*• is-mteger-tdesc?(get-base-type(d2)) 

A match-integer-types(di )(get-base-type(d2 )), 

*SUBTYPE* -+ match-types(get-base-type(di),get-base-type(d2)), 

*ARRAYTYPE* 

— tag(d2)= ’•'ARRAYTYPE* A match-array-type-names(di jda), 

*RECORDTYPE* 

^ tag(d2)= ^RECORDTYPE* 

A nuil(set-difference(filter-components(type(di )))(filter-components(type(d2)))), 

OTHERWISE ^ match-type-names(idf(di),idf(d2)b 
match-in teger-types(di ,d2) 

= idf(di)= UNIVERSALJNTEGER v idf(d2)= UNIVERSALJNTEGER 

get-base-type(d) = (tag(d)= *SUBTYPE* —► base-type(d), d) 

match-array-type-names(di ,d2) 

= let idfi = hd(di) 

and idfa = hd(d2) in 

(consp(idfi )A consp(idf2)—► match-type-names(hd(idfi ),hd(idf2)), 
consp(idfi)—► match-type-names(hd(idfi ),idf2), 
consp(idf2 )”► match-type-names(idfi ,hd(idf2)), 
match-type-names(idfi ,idf2)) 


match-type-names(idi ,id2) 

= idi = ^ANONYMOUS* V ids = ^ANONYMOUS* 


array-size(d) 

= (ub(d)A lb(d) 

—*• let Ibound = hd(tl(lb(d))) 

and ubound = hd(tl(ub(d))) in 
(ubound—Ibound )-|-l, 

- 1 ) 

filter-components(components) 

= (null(components)— e, 

let component = hd(components) in 
cons((hd(component),second(component)), 
filter-components{tl(components)))) 


70 



An object declaration declares a list of identifiers to be of the type given by the type-mark, 
which must be the name of a type that has already been entered in the visible part of the 
TSE. The identifiers must be distinct. The first of these identifiers is used in error messages. 
If the identifiers are being declared as constants but no initialization expression is present, 
then an UNINITIALIZED-CONSTANT error is reported. If constants are being declared, 
then their type is a value type; variables and signals have reference types. If variables 
or signals are being declared without an initialization expression, then the identifiers are 
entered into the TSE with an undefined initial value *UNDEF* by the function enter- 
objects, whose operation is explained below. If present, the initialization expression is 
checked and its type compared to the value type of the declared identifiers. If these types 
are not equal, then an initialization type mismatch is reported. If the identifiers are being 
declared as constants, they are entered into the TSE with an initial value equal to the 
(static) value of the initialization expression. 

The function enter-objects enters into the TSE a scalar descriptor for each of a list of 
identifiers. Duplicate declarations are detected. The descriptors are created from (1) the 
identifiers and (2) a list of remaining field values input to enter-objects. 

The function name-type returns the type (consisting of a type mode and a type descriptor) 
of a reference (ref). In Phase 1, refs are essentiaDy sequences of identifiers and expression 
lists; refs must begin with an identifier. As name-type processes a ref, it carries along 
(in parameters name and w, respectively) the remainder of the ref to be processed and 
the type to be computed for that portion of the original ref processed thus far. During 
this processing, special type modes that are identifier lists may be used to validate accesses 
to items declared inside packages or subprograms; validate-access checks these accesses. 
The function list-type returns the list of the types of its components; when a list is used 
as an actual parameter list in a subprogram call, compatible-par-types checks whether 
the types of this list’s components are compatible with (not necessarily equal to) the types 
of the corresponding formal parameters of the subprogram. 

(DT 6 ) DT I SLCDEC object-class id"*" slice-name opt-expr ] (p)(vis)(u)(t) 

= let (type-mark,discrete-range) = slice-name in 
let q = find-progunit-env(t)(p) in 
let d = t(q)(*UNIT* ) in 
let tg = tag(d) in 
(case object-class 

(CONST ,SYSGEN ) — lookup-type(type-mark)(p)(z)(t), 

VAR 
—+ (case tg 

(♦PACKAGE* ,*ENTITY* ,♦ARCHITECTURE* ) 

—► error 

(cat(“Illegal VARIABLE declaration in ”)(tg) 

(“ context: ”)(decl)), 

OTHERWISE —► lookup-type(type-mark)(p)(z)(t)), 

SIG 

—+ (case tg 

(♦PROCESS* ♦PROCEDURE* ,*FUNCTION* ) 

—► error 

(cat(“Illegal SIGNAL declaration in ”)(tg)(“ context: ”) 

(decl)), 

OTHERWISE —► lookup-type(type-mark)(p)(z)(t)), 

OTHERWISE 


71 



—*> error(cat(“Illegal object class in declaration: ”)(decl))) 
where 

z = Ad.let type = (object-class = CONST —♦ mk-type((CONST VAL) )(d), 
mk-type(mk-tinode(object-class)(REF ))(d)) in 
process-slcdec(id‘‘' )(type)(discrete-range)(opt-expr)(p)(vis)(Ti)(t) 


process-slcdec(id‘*“ )(w)(discrete-range)(opt-expr)(p)(vis)(u)(t) 

= let d = tdesc(w) in 

(-•is-array?(w)—error(cat(“CanH form slice of non-array type: ’')(d)), 
let (direction,expri ,expr2) = discrete-range in 
RT [ expri J (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT [ expr2 ] (p)(k2)(t) 

where 

k2 = A(w2,e2),t. 

(-i(is-integer-tdesc?(get-base-type(tdesc(wi))) 

A is-integer-tdesc?(get-base-type(tdesc(w2)))) 


—*■ error 

(cat(“Non-integer array bound for: ”)($(p) 

(hd(id+)))), 


let field-values — tl(array-type-desc 

(TEMPJ^AME )(e)(p)(vis) 
(direction) 

((direction = TO 
— (ei = ’♦'UNDEF* 

second ( EX [expri 1 (p)(t)), 
(NUM ,ei)), 

(62 = *UNDEF* 

secondf EX | expr2 1 (p)(t)), 
(NUM ,62)))) 

((direction “ TO 
^ (62 = *UNDEF* 

— secondfEX [ expr2 J (p)(t)), 
(NUM ,62)), 

(ei = ’^UNDEF* 

^ secondf EX [ expn ] (p)(t)), 
(NUM ,ei))))(elty(d))) in 


(null(opt-expr) 

—*■ enter-array-objects 


(id*^)(idf(d))(tmode(w))(field-values)(t)(p)(vis) 

(«). 

check-array-aggregate(opt-expr)(p)(v)(t) 

where 

V = Aw3.(match-types(elty(d),tdesc(w3)) 

—► enter-array-objects 


(id"*')(idf(d))(tniode(w)) 
(field-values)(t)(p)( vis) (u), 


error 

(cat(“Initialization type mismatch for: ”) 

($(p)(hd(id+)))))))) 


enter-array-objects(id*) (array-type-name) (tmode) (field-values) (t)(p)(vis)(u) 
= (null(id*)—► u(t), 

let idi = hd(id*) in 

let id2 = new-array-type-name(array-type-name) in 
let di = cons(id2,field-values) in 


72 



let ti = enter(t)(p)(id2){fieId-vaJues) in 
let new-type = nik-type(tmode)(di) in 
(t(p)(idiM *UNBOUND* 

error(cat(“Duplicate array declaration: ”)($(p)(idi))), 
let d2 = <£,* 0 BJECT* ,p, vis,new-type,*UNDEF* ,£> in 
let t2 = enter(ti)(p)(idi )(d2) in 
enter-array-objects 

(tl(id*))(array-type-name)(tmode)(field-values)(t2)(p)(vis)(u))) 

check-array-aggregate(expr)(p)(v)(t) 

= let (tg,expr+) = expr in 

(tg BITSTR A tg STR 

—► error(cat(“Improper array initialization aggregate: ”)(expr)), 
let expri = hd(expr''‘) in 
RT [expri ] (p)(k)(t) 

where k = A(wi,ei),t.check-exprs(wi)(tl{expr''"))(p)(v)(t)) 

check-exprs(w)(expr*)(p)(v)(t) 

= (null(expr*)—+ v(w), 

let expr = hd(expr*) in 
RT [[expr ] (p)(k)(t) 
where 

k = A(wi,ei),t. 

(wi ^ vf ^ “Nonuniform array aggregate ”, 
check-exprs(w)(tl(expr*))(p)(v)(t))) 

A declaration of a slice of a (previously defined) array type is a special form of object 
declaration for arrays of anonymous type. Because a declaration of a list of identifiers is 
considered to be an abbreviated representation of the sequence of corresponding declarations 
of each of the individual identifiers in the list, the (anonymous) type of each of the declared 
identifiers is distinct. Each of these distinct anonymous array types is given a distinct, 
new, system-generated name in Phase 1 of the Stage 4 VHDL translator (via the function 
new-array-type-name), and corresponding distinct type descriptors are entered into the 
TSE. If present, the initialization part of the declaration is a list of scalar expressions. 

The elaboration and checking of a sbce declaration begins in the same way as for a scalar 
declaration. The slice bound expressions are then evaluated and checked to ensure that 
both are integers. If the initiaUzation part is absent, then descriptors for the declared array 
identifiers, together with the descriptors for the corresponding anonymous array types, are 
entered into the environment by enter-array-objects. 

If the initialization part is present, then it is first processed by check-array-aggregate, 
which invokes check-exprs to ensure that each element of the initialization part has the 
same (value) type; check-aggregate returns this type, which is then compared to the ar¬ 
ray’s declared value type. Finally, enter-array-objects is invoked to enter the descriptors 
for the declared arrays into the environment. 

Refer also semantic equation DT8, shown below. 

(DT 7 ) DT I ETDEC id id+ } (p)(vis)(u)(t) 

= let field-values, = <e,*ENUMTYPE* ,p,vis,mk-enumlit(hd(id‘'’)), 
mk-enunilit(last(id''')),id'''> in 
(check-enum-lits(t)(p)(id)(id‘'’) 


73 



—► enter-objects((id))(field-va]uesi )(t)(p)(ui), 
nil) 

where 

ui Ati.let d = cons (id, field-values 1) in 

let field-values2 = <e,*ENUMELT* ,p,vis, 

mk-type((CONST VAL) )(d)> in 
enter-objects(id‘^) (field-values2 )(ti )(p)(u) 

check-enum-lits(t)(p)(id)(id*) 

= (null(id*)—" tt, 

let idi = hd(id*) in 

(lookup(t)(p)(idi )= ^UNBOUND* —^ check-enum-lits(t)(p)(id)(tl(id*)), 
error 

(cat(“Illegal overloading for enumeration literal: "’)(idi) 

(“ in enumeration type: ”)($(p)(id))))) 

An enumeration type declaration causes corresponding enumeration type descriptors to be 
entered into the TSE. At the same time, descriptors for the individual elements of the 
enumeration type are entered into the TSE; these elements are treated as constants. 

(DT 8 ) DT [ ATDEC id discrete-range type-mark J (p)(vis)(u)(t) 

= lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let (direction,expri ,expr2) = discrete-range in 
let array-type-desc = array-type-desc 

(id) (e) (p) (vis) (direction) 

((direction = TO 

second ( EX [expri | (p)(t)), 
second (EX [ expr2 1 (p)(t)))) 

((direction = TO 
—► second ( EX [ expr2 J (p)(t)), 
second ( EX [ expri J (p)(t))))(d) in 

attributes-low-high 

((id,expri ,expr2,array-type-desc,(UNIVERSAL-INTEGER) ))(p) 

(vis)(u)(t) 

attributes-low-high (id,expri ,expr2,type-desc,attribule-type-mark)(p)(vis)(u)(t) 

= let decli = (DEC ,SYSGEN ,(mk-tick-low(id)),attribute-type-mark,expri) 

and decb = (DEC ,SYSGEN ,(mk-tick-high(id)),attribute-type-mark,expr2) in 

enter-objects((id))(tl(type-desc))(t)(p)(ui) 
where ui = Ati. DT [ dech J (p)(vis)(u2)(ti) 
where U2 = At2. DT [ decb | (p)(vis)(u)(t2) 

mk-tick-low(id) = catenate(id,“^LOW’’) 

mk-tick-high(id) = catenate(id,“’HIGH”) 

An array type declaration causes corresponding array type descriptors to be entered into the 
TSE. The array type attributes 'low and 'high, representing the lower and upper bounds, 
respectively, are declared as system-generated identifiers. 

(DT9) DT [ PACKAGE id decl* opt-id ] (p)(vis)(u)(t) 

= (t(p)(id)^ ’^UNBOUND* 

— error(cat(“Duplicate package declaration: ”)($(p)(id))), 


74 




(^null(opt-id)A opt-id ^ id 
—► error 

(cat(“Package ”)($(p)(id))(“ ended with incorrect identifier: ”) 

(opt-id)), 

let d = <£,*PACKAGE* ,p,vis,£:> in 
let ti = enter(t)(p)(id)(d) in 

let t2 = enter(extend(ti)(p)(id))(%(p)(id))(*UNIT* )(<£,*PACKAGE* >) in 
let t3 = enter(t2)(%(p)(id))(*USED* )(<£,£>) in 
let t4 = enter(t3)(%(p)(id))(*IMPT* )(<e,e,e>) in 
Ul(t 4 ) 

where ui = At.DT [[ decl* J (%(p){id))(tt)(u)(t))) 

(DTIO) DT I PACKAGEBODY id decl* opt-id ] (p)(vis)(u)(t) 

= let d = t(p)(id) in 

(d = *UNBOUND* —► error(cat(“Missing package declaration: ”)($(p) 

(id))), 

tag(d)^ *PACKAGE* —► error(cat(“Not a package declaration: ”)($(p) 

(id))), 

-»null(pbody(d))—► error(cat(“Duplicate package body: ”)($(p)(id))), 

-inull(opt-id)A opt-id ^ id 
—error 

(cat(“Package body ”)($(p)(id))(“ ended with incorrect identifier: ”) 
(opt-id)), 

let q = %(path(d))(id) in 
let ti = enter(t)(q)(*LAB* )(<£,£>) in 
let t2 = enter(ti)(p)(id)(<£,*PACKAGE* ,path(d),exported(d),*BODY* >) in 
DT|[ded* I(q)(ff)(u)(t2)) 


A package is an encapsulated collection of declarations (including other packages) of logi¬ 
cally related entities identified by the package’s name. A package is generally provided in 
two parts: the package declaration and the package body. The package declaration provides 
declarations of those items that are exported {i.e.., made visible) by the package. The package 
body provides the bodies of items whose declarations appear in the package declaration, to¬ 
gether with the declarations and bodies of additional items that support the items exported 
by the package. These latter items are not exported by the package, i.e., they cannot be 
made visible outside the package. In our implementation, the descriptors of exported and 
nonexported items alike are entered into the same local environment. The exported field of 
these descriptors distinguishes between the two kinds of items. If an item can be exported 
by a USE clause, then the exported field of its descriptor contains tt (denoting true; if not, 
then this field contains fF (false). 

The items declared in a package declaration are not directly visible outside the package, but 
they can be accessed by using a dotted name beginning with the package name, provided 
that the package name is visible at the point of access. A descriptor for the package 
declaration is entered into the current environment. In order to encapsulate the items 
within a package, the resulting TSE is then extended along the current path by an edge 
labeled with the package name; the new environment is marked (in its *UNIT* cell) as a 
package environment. Then the constituent declarations of the package are elaborated and 
checked in the new environment. 

The items declared in a package body are not exported from the package and thus must 
not be accessible by an extended name. Therefore the exported field of the descriptors for 
the inaccessible entities must be set to fF, thus marking them as not exportable. 


75 



(DTll) DT I PROCEDURE id proc-par-spec* J (p)(vis)(u)(t) 

= (t(p)(id)^ ^UNBOUND* 

error(cat(“Duplicate procedure declaration for: ”)($(p)(id))), 
let pi ~ %(p)(id) in 

let t, = enter(extend(t)(p)(id))(pi)(*UNIT* )(<£ ^PROCEDURE’^ >) in 
enter-formaJ-pars(*PROCEDURE* )(proc-par~spec*)(ti ){pi )(ui) 
where 

ui = At2.1et formals = let id"*" = colJect-fids(proc-par-spec*) in 
collect*-formal-pars(id’^ )(t2)(pi) in 
let d = <£ ^PROCEDURE* ,p,vis, 

((formals, 

mk-type((CONST VAL) )(void-type-desc(t)))),e,£> in 
u(enter(t2)(p)(id)(d))) 

(DT12) DT [[ FUNCTION id func-par-spec* type-mark ] (p)(vis)(u)(t) 

= (t(p){id)9^ ^UNBOUND* 

—^ error(cat(“Duplicate function declaration for: ”){$(p)(id))), 
let Pi = %(p)(id) in 
lookup-type(type-mark)(p)(z)(t) 
where 

z = Adi.let t] = enter 

(extend(t)(p)(id))(pi)(^UNIT^ )(<£ ^FUNCTION* >) in 
enter-formaJ-pars(*FUNCTION* )(func-par-spec*)(ti)(pi )(ui) 
where 

ui = At2.1et formals = let id"*^ = coUect-fids 

(func-par-spec*) in 
coUect-formal-pars 
(id+)(t2)(pi) in 

let d = <e *FUNCTION* ,p,vis, 

((formals,mk-type((VAR VAL) )(di ))),£,£> in 
u(enter(t2)(p)(id)(d))) 

enter-formal-pars(tg)(par-spec*)(t)(p)(u) 

= (nulJ(par-spec*)—»■ u(t), 

let par-spec = hd(par-spec*) in 
let (object-class,id'*’,mode,type-mark,opt-expr) = par-spec in 
(case tg 

^PROCEDURE* 

—► (case object-class 

(CONST ,VAR ) 

—► (case mode 

(IN ,OUT ,INOUT ) — lookup-type(type-mark)(p)(z)(t), 

OTHERWISE 
—^ error 

(cat(“Illegal mode for procedure peirameters: ”)($(p) 

(hd(id+))))), 

OTHERWISE 

^ error 

(cat(“Unimpleiiiented object class ”)(object-class) 

(“ for procedure parameters: ” )($(p)(hd(id'‘’))))), 

♦FUNCTION* 

—► (case object-class 
CONST 
—(case mode 

IN —lookup-type(type-mark)(p)(z)(t), 

OTHERWISE 
—^ error 


76 



(cat(“Illegal mode for function parameters: ”)($(p) 

(hd(id+))))), 

OTHERWISE 

—* error 

(cat(“Unimplemented object class ”)(object-class) 

(“ for function parameters: ”)($(p)(hd(id'*'))))), 

OTHERWISE ^ error(cat(“Illegal subprogram tag: ”)(tg))) 
where 

z = Ad.let type = (case mode 

IN —► mk-type(mk-tmode(object-class)(VAL ))(d), 

OUT —► mk-type(mk-tmode(object-class)(OUT ))(d), 
OTHERWISE —► mk-type(mk-tmode(object-class)(REF ))(d)) in 
let fv = <e *OBJECT* ,p,tt,type,*UNDEF* ,£> in 
enter-objects(id+ )(fv)(t)(p)(ui) 
where ui = At.enter-formal-pars(tg)(tI(par-spec* ))(t)(p)(u)) 

collect-fids(par-spec*) 

= (null( par-spec * )—► e, 

let par-spec = hd(par-spec*) in 
let (object-classjid'*',mode,type-mark,opt-expr) = par-spec in 
append(id‘*‘ ,coliect-fids(tl(par-spec* )))) 

collect-formal-pars(id* )(t)(p) 

= (null(id*)- e, 

let d = t(p)(hd(id*)) in 

cons((hd(id*),type(d)),collect-formal-pars(tl(id*))(t)(p))) 


Checking a subprogram (procedure or function) declaration first extends the TSE and iden¬ 
tifies the new environment at the end of the extended path (in its *UNIT* cell) as a 
procedure or function environment. Then descriptors for the subprogram’s formal parame¬ 
ters are entered (by enter-formal-pars) into this new environment. Finally, a descriptor 
for the subprogram (with a body field of ff, indicating that no body for this subprogram 
has been encountered) is entered into the environment in which the subprogram is declared 
locaDy. Procedures are always given a void return type. The function enter-formal-pars 
accepts a tag *PROCEDURE* or ^FUNCTION* (procedure or function) to enable 
it to check that the formal parameters are appropriate to the subprogram. For example, 
functions can have only IN parameters. 

(DT 13 ) DT I SUBPROGBODY subprog-spec decl* seq-stat* opt-id J (p)(vis)(u)(t) 

= let (tg,id,par-spec*,type-mark) = subprog-spec in 
let qname = $(p)(id) 
and d = t(p)(id) in 
(d = *UNBOUND* 

—+ let decl = subprog-spec in 
DT [decl I (p)(vis)(ui)(t) 
where 

ui = At.let d = t(p)(id) in 
process-subprog-body 

(t)(p)(id)(d)(decr )(seq-stat*)(u), 

--(tag(d)G (^PROCEDURE* ^FUNCTION*) ) 

error(cat(qname)(“ is not a subprogram specification”)), 

(tg = PROCEDURE A tag(d)= ^FUNCTION* ) 

V (tg = FUNCTION A tag(d)= ^PROCEDURE* ) 

—*• error(cat(“Wrong kind of subprogram body: ”)(qname)), 


77 



->nulJ(body(d))—► error(cat(“Duplicate subprogram body: ”)(qname)), 
-'null(opt-id)A opt-id ^ id 
error 

(cat(“Subprogram body ”)(qname) 

(“ ended with incorrect identifier ”)(opt-id)), 
let formals = let id"^ — coDect-fids(par-spec*) in 

collect-forraal-pars(id"*‘ )(t)(%(p)(id)) in 
(formals ^ pars(hd(signatures(d))) 

—► error 

(cat(“Nonconforming formal parameters for subprogram: ”)(qname)), 
lookup-type(type-mark)(p)(z)(t) 
where 

z = Adi.(di 7^ tdesc(extract-rtype(d)) 

—► error 

(cat(“Unequal result types for subprogram: '’) 

(qname)), 

process-subprog-body(t)(p)(id)(d)(decl* )(seq-stat*)(u)))) 


process-subprog-body(t)(p)(id)(d)(decr )(seq-stat*)(u) 

= let Pi = %(p)(id) in 

let ti = enter(t)(pi)(*LAB'*' )((e,£)) in 
let ts = enter(ti )(pi)(*USED'*' )(<£,£>) in 
let te = enter(t5)(pi)(*IMPT* )(<£,£,£>) in 
let t? = enter 

(t 6 )(p)(id)(<£,tag(d),path(d),exported(d),signatures(d),e,£>) in 
DTldecI* l(pi)(tt)(ui)(t 7 ) 
where ui = At2. SST [[ seg-stat* ]] (pi)(u2)(t2) 
where 

U2 = Ata.let t4 = enter 

(t 3 )(p)(id) 

(<e,tag(d),path(d),exported(d),signatures(d), 

(DXlded* l(pi)(t3),SSX |seq-stat* I (Pi )(t 3 )),e>) in 

u(t4) 


Checking the declaration of a subprogram body first checks whether a declaration for the 
subprogram has already been encountered. If not, then descriptors for the subprogram 
and its formal parameters must be entered into the TSE as above. Otherwise, the declara¬ 
tion part of the subprogram body must be checked for conformity with the corresponding 
information previously entered in the TSE. In Stage 4 VHDL conformity is very strict: 
subprogram types and formal parameter names and types must agree exactly, except that 
formal parameters with no explicit mode are regarded as having been specified with mode 
IN. The subprogram’s body (which consists of local declarations followed by statements) is 
checked by process-subprog-body, where initial entries are made into its environment’s 
*LAB*, *USED*, and *IMPT* cells, and its transformed abstract syntax tree is entered 
into the body field of the subprogram’s descriptor. Note that a dummy value *BODY* is 
temporarily entered in the descriptor’s body field, so that recursive calls of this subprogram 
will not incorrectly indicate that a call is being made to a subprogram for which a body 
has not been supplied (see the Phase 1 semantics of subprogram calls). 

(DT 14 ) DT I USE dotted-name+ } (p)(vis)(u)(t) 

= let pkgs-used-here = thdotted-name"^ )U {hd(dotted-name‘*')} in 
process-use-dause(pkgs-used-here)(p)(vis)(u)(t) 


78 


process-use-dause(dotted-name“*' )(p)(vis)(u)(t) 

= check-pkg-names(dotted-name'*' )(e:){p)(vis)(j)(t) 
where 

j = Apkg-qualified-names. 

let pkg-qnames = remove-enclosing-pkgs(p)(t)(pkg-qucdified-names) in 
let local-pkgs-used = third(t(p)(*USED* )) in 
let ti = enter 

(t)(p)(*USED* ) 

((e,pkg-qnames U local-pkgs-used)) in 
let t2 = let d = t(p)(*IMPT* ) in 
let qname-list = third(d) 

and id-list = fourth(d) in 
import-qualified-names 

(pkg-qnames)(qname-list)(id-list)(p)(ti) in 

U(t 2 ) 

check-pkg-names(dotted-name*)(pkg-quaIified-names)(p)(vis)(j)(t) 

= (null(dotted-name*)—► j(pkg-qualified-names), 
let dn = hd(dotted-name*) in 
let suffix = last(dn) in 
(suffix ^ ALL 

—*> error(cat(“Selected name in USE clause must end with suffix ALL: ”)(dn 
name-type(rest(dn))(£)(p)(t)(v) 
where 

V = Aw.let d = tdesc(w) in 

{tag(d)^ ^PACKAGE* 

—► error(cat(“Non-package name in USE clause: ”)(namef 

(d))). 

check-pkg-names 

(tl(dotted-name*))(cons(%(path(d))(idf(d)),pkg-qualified-names)) 

(p)(vis)(j)(t)))) 

remove-enclosing-pkgs(p)(t)(pkg-set) 

= (null(p)-~^ pkg-set, 

let d = t(p)(*UNIT* ) in 

(d = ’•'UNBOUND* —► remove-enclosing-pkgs(rest(p))(t)(pkg-set), 

(third(d)= *PACKAGE* 

—^ remove-enclosing-pkgs{rest(p))(t)(set-difFerence(pkg-set)((p))), 
remove-enclosing-pkgs(rest(p))(t)(pkg-set)))) 

import-qualified-names(pkg-qualified-names)(item-qu2tlified-names)(ids-used)(p)(t) 

= (pkg-qualified-names = e 

enter(t)(p)(*IMPT* )((e,item-qualified-names,ids-used)), 
let pkg-qn = hd(pkg-qualified-names) in 
let pkg-env = t(pkg-qn) in 

let exported-qnames = export-qualified-names(pkg-env)(£) in 
let local-env = t(p) in 
let (qname*,id*) = import-legal 

(exported-qnames)(item-qualified-names)(ids-used) 
(locaJ-env) in 

import-qualified-names(tl(pkg-qualified-names))(qname* )(id*)(p)(t)) 

import-legal(exported-qnames) (qname-list) (id-list)(env) 

= (null(exported-qnames)—>• (qname-list,id-list), 
let qname = hd(exported-qnames) in 
let id = last(qname) in 

let remaining-exported-qnames = tl(exported-qnames) in 


79 




(id 6 id-list 

—let qn = simple-name-match(id)(qname-list) in 
(null(qn) 

—+ iniport-legal(reinaiiiing-exported“qnames)(qname-list) (id-list )(eiiv), 
import-legal 

(remaining-exported-qnames)(set-difFerence(qname-list)((qn))) 

(id-list)(env)), 
let d = env(id) in 
(d = ^UNBOUND* 

—^ import-legal 

(remaining-exported-qnames)(cons(qname,qname-list)) 

(cons(id,id-list))(env), 

import-legal 

(remaining-exported-qnames)(qname-list)(cons(id,id-list))(eiiv)))) 

simple-name-match(id)(qname*) 

= (null(qname* )-^ £, 

(id = last(hd(qname*))—► hd(qname*), simple-name-match(id)(tl(qname*)))) 

export-qucLlified-names(env) (qualified-names) 

= (null(env)-^ qualified-names, 
let d = hd(env) in 
let id = idf(d) in 
(case id 

(*UNIT* *LAB’^ ,*^USED* ,*IMPT* ) 

—► export-qualified-names(tl(env)) (qualified-names), 

OTHERWISE 

—► (exported(d) 

—^ export-qualified-names(tl(env))(cons(%(path(d))(id),qualified-names)), 
export-qualified-names(tl(env))(qualified-names)))) 

A USE clause is a declaration that makes items declared in a package specification visible 
at the location of the USE clause. Each of the dotted names in a USE clause, neglecting 
the (obligatory) suffix ALL, must denote the name of a package. In essence, a USE clause 
combines the exported environments associated with its named packages both with each 
other and with the local environment (among whose declarations the USE clause appears). 
Such a combination of environments may introduce conflicts, since there may be several 
different declarations of an object of the same name in the packages (as well as one locally). 
Therefore, certain constraints must govern how environments are combined: 

1. If an object x is declared locally, then no declarations of x may be imported to the 
local environment by the USE clause. 

2. If an object x is declared in more than one of the packages named in the USE clause, 
then none of these declarations of x may be imported to the local environment by the 
USE clause, even if x is not declared locally. 

These constraints ensure that (1) no local declaration is masked by an imported one, and 
(2) no duplicate or conflicting declarations are imported. 

USE clauses are treated by process-use-clause, which assumes that all the USE clauses in 
a program unit’s declarative part are located together at the end of that declarative part. 


80 




This restriction on the location and grouping of USE clauses enables a determination of 
those items imported into a local environment to be made once and for all by the time the 
unites declarative part has been processed. This ensures that the list of items imported into 
an environment (stored in its *IMPT* cell) need not vary in Phase 2, thereby ensuring 
that the entire TSE is /ixed throughout Phase 2. If declarations other than USE clauses were 
aUowed to appear between USE clauses, then the set of importable items may change before 
and after such interposed declarations, requiring a dynamic evaluation of the import bst 
during Phase 2. We feel that such generabty is unnecessary, because the names of items 
can always be changed so that their interposed declarations can be moved in front of the 
group of USE clauses. 

First, the list of names appearing in this USE clause (with dupbcates removed) is given to 
process-use-clause. Then these names are checked by check-pkg-names to ensure that 
they denote packages; a bst of fuby quabfied package names is returned. The names of 
packages that enclose packages in this bst are removed by remove-enclosing-packages. 
The (set-theoretic) union of the resulting set of package names (cabed pkg-qnames) and 
the set of names of packages already appearing in USE clauses in this declarative part (stored 
in the *USED* ceb of this environment) is computed (in order to avoid dupbcation); the 
resulting set of package names is entered back into the *USED* ceb. Next, the current set 
of fully quabfied names of items imported into this environment (qname-list) is retrieved 
from its *IMPT* ceb. A separate bst of simple identifiers (id-list) is also maintained in 
the *IMPT* ceb; this bst is used to prevent ibegal importations into the current envi¬ 
ronment. Then pkg-qnames, qname-list, and id-list are passed to import-qualified- 
names, which adds the fuby quabfied names of those items that can be legally imported 
into the local environment by the USE clause being processed. The auxibary functions 
export-qualified-names and import-legal are used by import-qualified-names, 

(DTI 5 ) DT |[ STDEC id type-mark opt-discrete-range J (p)(vis)(u)(t) 

= lookup-type(type-mark)(p)(z)(t) 
where 

z = Ad.let base-type-desc = get-base-type(d) in 
(null(opt-discrete-raiige) 

—+ let field-values = <£:,*SUBTYPE* ,p,vis,type-tick-low(d), 
type-tick-high(d),base-type-desc> in 
attributes{(id,£:,£,d,field-values))(p)(vis)(u)(t), 
let (direction,expri ,expr2) — opt-discrete-range in 
RT ([ expn I (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT llexpr 2 1 (p)(k 2 )(t) 
where 

k 2 = A(w 2 ,e 2 ),t. 

(match-types(tdesc(wi),base-type-desc) 

A match-types(tdesc(W2),base-type-desc) 

—let field-values = <£,*SUBTYPE* ,p,vis, 

(direction = TO 

(ei = *UNDEF* 

—► second 

(EX [expn I 
(p)(t)), 

(NUM ,e,)). 

(62 = ♦UNDEF* 


81 



—second 

(EX [ exprj 1 
(P)(t)). 

(NUM .ej))), 

(direction = TO 
^ (e 2 = *UNDEF* 

—* second 

(EX I expra I 

(p)(t)), 

(NUM ,62)), 

(e, = ♦UNDEF* 

—► second 

(EX [ expri | 

(p){t)), 

(NUM ,ei ))),base-type-desc> in 

attributes 

((id, 

(direction = TO —^ expri, 
expr 2 ), 

(direction = TO ^ expr2, 
expri ),d,field-values))(p) 

(vis)(u)(t), 

error 

(cat(“Range constraint for subtype incompatible with base type: ”) 
(base-type-desc)(tdesc(wi)) 

(tdesc(w2))(decl)))) 

attributes(id, lower-bound,upper-bound,d,field-values)(p)(vis)(u)(t) 

= let decli = (DEC ,SYSGEN ,(mk-tick-low(id)),(idf(d)),lower-bound) 

and decb = (DEC ,SYSGEN ,(mk-tick-high(id)),(idf(d)),upper-bound) in 
enter-objects((id))(field-values)(t)(p)(ui) 
where ui = Ati.DT [decli ] (p)(vis)(u2)(ti) 
where U2 = At2. DT [ decb I (p)(vis)(u)(t2) 


Static semantic analysis of a subtype declaration involves making certain that the lower 
and upper bounds of the range constraint are compatible with the subtype’s base type; 
declaring the ’low and ’high attributes (representing these bounds) as system-generated 
identifiers; and entering a subtype descriptor in the TSE. 

(DT16) DT [[ ITDEC id discrete-range J (p)(vis)(u)(t) 

= let parent-type-desc = univint-type-desc(t) in 
let (direction,expri ,expr2) = discrete-range in 
RT I expn I (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT [expr2 | (p)(k2)(t) 
where 

k 2 - A(w 2 ,e 2 ),t. 

(ei = *UNDEF* V es = *UNDEF* 

—► error 

(cat(“Non-static bound in range constraint: ”) 

(decl)), 

(match-types(tdesc(wi),parent-type-desc) 

A match-types(tdesc(W2),parent-type-desc) 

—► let field-values = <£,*INT_TYPE* ,p,vis, 


82 



(direction = TO 

— (NUM ,ei), 

(NUM ,62)), 

(direction = TO 

— (NUM ,62), 

(NUM ,ei )),parent-type-desc> in 

attributes 

((id,(direction = TO —► exprj, expr2), 

(direction = TO —► expr2, expri ),parent-type-desc,field-values)) 
(p)(vis)(u)(t), 

error 

(cat(“Incompatible range constraint for integer type: ”) 

(tdesc( w 1)) (tdesc( W2)) (decl)))) 


Static semantic analysis of an integer definition type involves making certain that the lower 
and upper bounds of the range constraint are static expressions compatible with the integer 
type’s parent type (UNIVERSAL-INTEGER); declaring the ’low and ’high attributes (rep¬ 
resenting these bounds) as system-generated identifiers; and entering an integer definition 
type descriptor in the TSE. 

(DT 17 ) ^ I COMPONENT id generic-decl* port-decl* ] (p)(vis)(u)(t) 

= let ti = enter(t)(p)(id)(<£ ^COMPONENT* ,p,ff>) in 
let Pi = %(p)(id) in 

let t2 = enter(extend(ti)(p)(id))(pi)(*UNIT* )(<£ ^COMPONENT* >) in 
let ta = enter(t2)(pi)(*LAB* )(<£,€>) in 
let t4 = enter(t3)(pi)(*USED* )(<e,e>) in 
let ts = enter(t4)(pi)(*IMPT* )(<e,e,e>) in 
let te = enter(t4)(pi)(*GENERICS* )(<£,£>) in 
let t? = enter(t4)(pi)(*PORTS* )(<£,£>) in 
GDT [[ generic-decl* J (pi )(vis)(ui )(t7) 
where ui = At.PDT |[ port-decl* ]] (pi )(vis)(u)(t) 


6.5.12 Concurrent Statements 

(CSTO) CST |[ £ J (using-configuration)(p)(u)(t) = u(t) 

(CSTl) CST J conc-stat conc-stat* J (using-configuration)(p)(u)(t) 

= CST J conc-stat ] (using-configuration)(p)(ui )(t) 

where ui = At.CST [ conc-stat* ] (using-configuration)(p)(u)(t) 


Concurrent statements are statically checked in the textual order of their appearance in the 
hardware description. 

(CST2) CST [ BLOCK id block-header decl* conc-stat* opt-id | (using-configuration)(p)(u)(t) 

= let q = find-progunit-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 
(id E labels 

—► error(cat(“Duplicate concurrent statement label: ”)($(q)(id))), 

(-inull(opt-id)A opt-id ^ id 
—^ error 

(cat(“BLOCK statement ”)(id) 

(“ ended with incorrect identifier: ”)(opt-id)), 


83 



let ti = eiiter(t)(q)('*'LAB* )((£,cons(id,labels))) in 
let h = enter(ti)(q)(id)(<£,*BLOCKNAME* ,p,ff>) in 
let Pi = %(p)(id) in 

let t3 = enter(extend(t2)(p)(id))(pi)(*UNIT* )(<e ♦BLOCKS >) in 

let ti = enter(t3)(pi)(*LAB* )(<£,£>) in 
let is = enter{t4)(pi)(’^USED* )(<£,£>) in 
let te = enter(t5)(pi)(*IMPT* )(<£,£,£>) in 
let tr = enter(t 6 )(pi)(*GENERICS* )(<e,e>) in 
let tg = enter(t7)(pi)(*PORTS* )(<e,e>) in 
process-block-header(block-header)(id)(pi )(u2 )(t 8 ) 
where U2 = At. DT |[ ded* ] (pi )(tt)(ui)(t) 
where 

Ui = At. CSX [ conc-stat* J (using-configuration)(pi )(u)(t))) 

process-block-header(block-header)(id)(p)(u)(t) 

= let generic-part = hd(block-header) 

and port-part = second(block-header) in 
process-generic-part(generic-part)(id)(p)(ui )(t) 
where ui = At.process-port-part(port-part)(id)(p)(u)(t) 

process-generic-part (generic-part)(id)(p)(u){t) 

= (null(generic-part)—► u(t), 

let generic-decl* = hd(generic-part) 

and generic-map-aspect = second(generic-part) in 
GDT I generic-decl* J (p)(tt)(ui )(t) 
where 

ui = At.(null(generic-map-aspect)—► u(t), 

GMT I generic-map-aspect | (id)(BLOCK )(p)(p)(u)(t))) 

process-port-part (port-part)(id)(p)(u)(t) 

= (null(port-part)—► u(t), 

let port-ded* = hd(port-part) 

and port-map-aspect = second(port-part) in 
PDT I port-ded* I (p)(tt)(ui )(t) 
where 

ui = At.(null(port-map-aspect)—► u(t), 

PMT I port-map-aspect | (id)(BLOCK )(p)(p)(u)(t))) 


(CST 3 ) CSX I PROCESS id ref* ded* seq-stat* opt-id J (using-configuration)(p)(u)(t) 

= let labels = third(t(p)(*LAB* )) in 
(id G labels 

—► error(cat(“Duplicate concurrent statement label; ”)($(p)(id))), 
let ti = enter(t)(p)('**LAB* )((£,cons(id,labels))) in 
(-nnull(opt-id)A opt-id ^ id 
—► error 

(cat(“PROCESS statement ”)(id) 

(“ ended with incorrect identifier: ”)(opt-id)), 
let t2 - enter(ti)(p)(id)(<£,*PROCESSNAME* ,p,ff,ref*>) in 
let Pi = %(p)(id) in 

let t3 =enter(extend(t2)(p)(id))(pi)(*UNIX* )(<£,*PR 0 CESS* >) in 
let t4 = enter(t3)(pi )(*LAB* )(<£,£>) in 
let ts = enter(t4)(pi)(*USED* )(<£,£>) in 
let te = enter(t5)(pi)(*IMPX* )(<£,£,£>) in 
let t7 = enter(t 6 )(pi)(*SENS^ )(<£,£>) in 
^Iref*l(pi)(u 2 )(t 7 ) 
where U2 = At.DT [ded* | (pi)(tt)(ui )(t) 
where ui = At. SSX [seq-stat* | (pi)(u)(t))) 


84 



find-architecture-env(t)(p) 

= {nuU(p)V tag(t(p)(=^UNIT* ))= *ARCHITECTURE* p, 
find-architecture-env(t)(rest(p))) 


(CST 4 ) CST [[ SEL-SIGASSN atmark delay-type id expr ref selected-waveform^ | 
(using-configuration)(p)(u)(t) 

= let expr* = cons(expr, 

coll ect-expressions-from-selected-waveforms 
(selected-waveform'*")) in 
let ref* = delete-duplicates 

(collect-signals-from-expr-iist(expr*)(t)(p)(€:)) in 
let case-alt"*" = construct-case-alternatives 

(ref)(delay-type)(selected-waveform"*') in 
let case-stat = (CASE ,atmark,expr,case-aJf*") in 
let process-stat — (PROCESS ,id,ref*,e,(case-stat),id) in 
CST [ process-stat | (using-configuration)(p)(u)(t) 

collect-expressions-from-selected-waveforms(selected-waveform*) 

= (null(selected-waveform*)—► e, 

let selected-waveform = hd(selected-waveform*) in 
let waveform — second(selected-waveform) 

and discrete-range■*■ = third(selected-waveform) in 
let transaction-exprs = collect-transaction-expressions(second(waveform)) in 
nconc 

(transaction-exprs, 
cons(second(discrete-range"*"), 
cons( third (discrete-range"*"), 
coUect-expressions-from-selected-waveforms 
(tl(selected- waveform *)))))) 

collect-transaction-expressions(trans*) 

= (null(trans*)—► e, 

let transaction = hd(trans*) in 

cons(second(transaction),collect-transaction-expressions(tl(trans*)))) 

collect-signal s-from-expr-list(expr*)(t)(p)(signal-refs) 

= (null(expr*)—► signal-refs, 
let expr = hd(expr*) in 
coUect-signals-from-expr 

(expr)(t)(p)(collect-signals-from-expr-list(tl(expr*))(t)(p)(signal-refs))) 

collect-signals-from-expr(expr)(t)(p) (signal-refs) 

= (-»consp(expr)—> signal-refs, 
is-ref? (expr) 

—•■let d = lookup-desc-for-ref(expr)(p)(t) in 
(tag(d)= *OBJECT* A is-sig?(type(d)) 

—► cons(expr, 

(consp(second(expr)) 

—► collect-signals-from-expr-list(second(expr))(t)(p)(signaJ-refs), 
collect-signals-from-expr(second(expr))(t)(p)(signal-refs))), 
(consp(second(expr)) 

—+ collect-sign als-from-expr-list(second(expr)) (t) (p) (signal-refs), 
collect-signals-from-expr(second(expr)) (t) (p) (signal-refs))), 
is-paggr?(expr) 

—► collect-signals-from-expr-list(second(expr))(t)(p)(signal-refs), 
is-unary-op?(hd(expr)) 


85 



collect-signals-from-expr(second(expr))(t)(p)(signaJ-refs), 
is-binary-op?(hd(expr))V is-reIational-op?(hd(expr)) 

—* collect-signaJs-from-expr 
(second(expr))(t)(p) 

(collect-signals-from-expr(third(expr))(t)(p)(signal-refs)), 
collect-signals-from-expr-list(expr)(t)(p) (signal-refs)) 


lookup-desc-for-ref(ref)(p)(t) 

= let name = second(ref) in 

let id"*" = (consp(Ia 5 t(name))—► rest(name), name) in 
let q = access{rest(id'*'))(t)(p) in 
lookup-desc-on-path(t)(q)(last(id'*')) 


lookup-desc-on-path(t)(p)(id) 

= let d = t(p)(id) in 

(d = ^UNBOUND* ^ (null{p)^ ♦UNBOUND* , lookup-desc-on-path(t)(rest(p))(id)), d) 


access(id* )(t)(p) 

= (null(id* )—► p, 

let id = hd{id*) in 
let d = lookup(t)(p)(id) in 
(d = ♦UNBOUND* 

—> error 

(cat(“Unbound identifier in auxiliary semantic function ACCESS: ”)(id)), 
access(tl(id* ))(t)(%(path(d))(idf(d))))) 

construct-case-alternatives(ref) (delay-type) (selected-waveform *) 

= (null(selected-waveform*)-^ e, 

let selected-waveform = hd(selected-waveform*) in 
let waveform = second(selected-waveform) 

and discrete-range'*' = third(selected-waveform) in 
let sig-assn-stat = (SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform) in 
let case-alt = (CASECHOICE ,discrete-range'*',(sig-assn-stat)) in 
cons(c 3 ise-alt, 

construct-case-alternatives(ref)(delay-type)(tl(selected-waveform*)))) 


(CST 5 ) CST [ COND-SIGASSN atmark delay-type id ref cond-waveform* waveform | 
(using-configuration) (p)(u)(t) 

= let expr* = nconc 

(collect-expressions-from-conditionaJ-waveforms 
(cond-waveform*), 

collect-transaction-expressions(second(waveform))) in 
let ref* = delete-duplicates 

(colIect-signals-from-expr-iist(expr* )(t)(p)(£)) in 
(null(cond-waveform*) 

—► let sig-assn-stat = (SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform) in 
let process-stat = (PROCESS ,id,ref*,e,(sig-assn-stat),id) in 
CST I process-stat J (using-configuration)(p)(u)(t), 
let cond-part"*" = construct-cond-parts 

(ref)(delay-type)(cond-waveform*) 

and else-part = ((SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform)) in 
let if-stat = (IF ,atmark,cond-parf*",else-part) in 
let process-stat = (PROCESS ,id,ref*,s,(if-stat),id) in 
CST I process-stat ] (using-configuration)(p)(u)(t)) 


86 



collect-expressions-from-conditional-waveforms(cond-waveform*) 

= (null{cond-waveform*)— e, 

let cond-waveform = hd(cond-waveform*) in 
let waveform = second(cond-waveform) 

and condition = third(cond-waveform) in 
let transaction-exprs — collect-transaction-expressions{second(waveform)) in 
nconc 

(transaction-exprs, 

cons(condition, 

collect-expressions-from-conditional-waveforms(tl(cond-waveform*))))) 

construct-cond-parts(ref)(delay-type)(cond-waveform*) 

= (null(cond-waveform*)—e, 

let cond-waveform = hd(cond-waveform*) in 
let waveform = second(cond-waveform) 

and condition = third(cond-waveform) in 
let sig-assn-stat = (SIGASSN ,{AT ,mk-atmark()),delay-type,ref,waveform) in 
let cond-part = (condition,(sig-assn-stat)) in 
cons(cond-part,construct-cond-parts(ref)(delay-type)(tl(cond-waveform*)))) 


(CST 6 ) CSX [ COMPINST id ref opt-generic-map-aspect opt-port-map-aspect ] 
(using-configuration)(p)(u)(t) 

= let d — lookup-desc-for-ref(ref)(p)(t) in 

(d = ^UNBOUND* V tag(d)^ *COMPONENT* 

^ error 

(cat(“No component declaration ”)(“for component instance ”)(id)), 
record-equivalent-nested-block-stat 

(conc-st at) (using-config uration) (p) (u) (t)) 


6.5.13 Sensitivity Lists 

(SLT 0 )^[[£l (p)(u)(t) = u(t) 

(SLTl) SLT [ ref ref* J (p)(u)(t) 

= ^[ref]l(p)(uO(t) 

where ui = At. SLT [ ref* ] (p)(u)(t) 

The refs in the sensitivity list of a PROCESS statement are checked in sequential order. 

(SLT 2 ) SLT I REF name J (p)(u)(t) 

= let expr = ref in 

ET [[ expr | (p)(k)(t) 

where 

k = A(w,e),t. 

let d = tdesc(w) in 
(-iis-sig?(w) 

—► error 

(cat(“Non-signal in process sensitivity list: ”)(ref)), 
let di = lookup(t)(p)(*SENS* ) in 
let ti = enter 

(t)(p)(*SENS* ) 

(< 5 ,(cons(SLjX [ ref | (p)(t),sensitivity(di )))>) in 

u(ti)) 


87 


6.5.14 Sequential Statements 

(SSTO)^Iel(p)(c)(t) = c(t) 


(SSTl) SST [[ seq-stat seq-stat* J (p)(c)(t) 

= SST [ seq-stat ] (p)(ci )(t) 

where Ci = At. SST [[seq-stat* | (p)(c)(t) 


Sequential statements are statically checked in the textual order of their appearance in the 
hardware description, 

(SST 2 ) SST I NULL atmark ] (p)(c)(t) = c(t) 

NULL statements require no checking. 

(SST 3 ) SST J VARASSN atmark ref expr | (p)(c)(t) 

= let expro = ref in 
^ [[expro ] (p)(k)(t) 
where 
k = A(w,e),t. 

let d = tdesc(w) in 
(-'is-var?(w) 

—► error 

(cat(“Illegal target in variable assignment statement: 

(seq-stat)), 
writable?! w) 

error(cat{“Read-only variable: ”)(namef(d))), 

RT Jexpr ] (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

let di = tdesc(wi) in 
(match-types(d,dj)—*> c(t), 

error(cat(“Assignment type mismatch: ”)(d)(di)))) 


find-process-env(t)(p) 

= (null(p)V tag(t(p)(*UNIT* ))= ^PROCESS"*" —► p, find-process-env(t)(rest(p))) 

First the left part of a variable assignment statement is checked, and then the right part. 
The left part must be a variable of reference type (checked by is-var? and is-writable?), 
and the basic types of the left and right parts must be the same, as verified by match-types 
(refer to the definitions following semantic function DT5). 

(SST 4 ) SST I SIGASSN atmark delay-type ref waveform | (p)(c)(t) 

= let expr = ref in 

ET Iexprl(p)(k)(t) 

where 

k = A(w,e),t. 

let d = tdesc(w) 

and q = find-process-env(t)(p) in 
(-'is-sig?(w) 
error 

(cat(“Hlegal target of signal assignment statement: ”) 

(namef(d))), 


88 


-lis-wri t able? (w) —*” 


error 

(cat(“Read-only signal: 


’)(namef 

(d))), 


nuU(q) 

—► error 

(cat(“Sequential signal assignment statement not in a process: 
(seq-stat)), 

let di = lookup-desc-for-ref(ref)(p)(t) in 
let sources = sources(di) in 
(q G sources —► ci(t), 
rest(q)G map-rest(sources) 

— error 

(cat(“Resolved signal illegal in Stage 4 VHDL: ”) 
(namef(di))), 
let ti = enter 


(t)(path(di))(idf(di)) 

(<e,*OBJECT* ,path(di ),exported(di ),type(di), 
vcLlue(di),cons(q,sources)>) in 

Cl(tl)) 


where 

Cl = Ati . WT I waveform ] (p)(ki )(t) 
where 


ki 


A(wi,ei),t. 

let di = tdesc(wi) in 
(match-types(d,dic(t), 
error 

(cat(“Assignment type mismatch: ”) 
(d)(di)))) 


) 


(SST 5 ) SST [[ IF atmark cond-part’*' else-part ] (p)(c)(t) 

= let seq-stat* = else-part in 
check-if(cond-part'^ )(p)(ci )(t) 

where ci = At.(null(seq-stat*)—► c(t), SST [seq-stat* J (p)(c)(t)) 

check-if(cond-part* )(p)(c)(t) 

= (null(cond-part*)—► c(t), 

let (expr,seq-stat*) = hd(cond-part*) in 
EX [expr ] (p)(k)(t) 
where 
k = A(w,e),t. 

(is-boolean?(w) 

—► SST ([ seq-stat* | (p)(ci)(t) 

where Cl = At.check-if(tl(cond-part*))(p)(c)(t), 
error(cat(“Non-boolean condition in IF statement: ”)(tdesc 

(w))))) 

A Stage 4 VHDL IF statement consists of one or more conditional parts (cond-parts) 
followed by a (possibly empty) else-part. Each cond-part consists of a test expression 
followed by sequential statements that are to be executed when the test expression is the 
first to evaluate to true; the sequential statements constituting the else-part are to be 
executed when none of the test expressions is true. 

The cond-parts are first checked, in order, by auxiliary semantic function check-if, after 
which the else-part, if nonempty, is checked by SST. Checking each cond-part involves 
first ascertaining that the basic type of its test expression is boolean, and then invoking 
SST to check its sequential statements. 


89 



(SST 6 ) SST H CASE atmark expr case-alt"^ ] (p)(c)(t) 

= Rj; I expr } (p)(k)(t) 
where 

k = A(w,e),ti. 

let d = get-base-type(tdesc(w)) in 
^ [ case-alt+ ] (d)(p)(y)(t]) 
where 
y — Ah,t2. 

(-icase-type-ok(d) 
error 

(cat(“Illegal CASE selector type: ”)(namef(d)) 
(seq-stat)), 

"icase-coverage(d)(h) 

—► error 

(cat(“Incomplete CASE coverage for type: ”) 
(namef(d))(seq-stat)), 

C(t2)) 

case-type-ok(d) 

= is-boolean-tdesc?(d)V is-bit-tdesc?(d) 
case-coverage(d)(h) 

= (is-booIean-tdesc?(d)A set~card(h)= 2 ) 

V (is-bit-tdesc?(d)A set-card(h)= 2 ) 

set-card(x) = length(x) 


A Stage 4 VHDL CASE statement consists of a selector expression followed by one or more 
case alternatives^ each consisting of sequential statements preceded either by a nonempty 
sequence of discrete ranges or by the reserved word OTHERS. This discrete range sequence 
defines a case selection set for the particular case alternative. 

The Stage 4 VHDL concrete syntax aUows the statements in a case alternative to be preceded 
by a list of discrete ranges and expressions'^ for uniformity, in the Phase 1 abstract syntax 
(generated by the Stage 4 VHDL parser) these expressions are converted into equivalent 
one-element discrete ranges. 

A CASE statement must be checked for the following: 

• The basic type of all the case selection sets (and thus of the expressions that define 
the discrete ranges) must be the same, and must match that of the selector expression. 
In Stage 4 VHDL, the only such bajsic types are BOOLEAN, BIT, INTEGER, and 
enumeration types (including CHARACTER). 

• Every expression of every discrete range in a CASE statement must be static^ i.e., must 
have a value defined by Phase 1. This enables the contents of each case selection set 
to be determined during Phase 1. The OTHERS alternative, if present, defines a case 
selection set that is the complement of the union of the other case selection sets with 
respect to the set of values associated with the basic type. The BOOLEAN basic 
type is associated with the set of truth values {FALSE, TRUE}, the BIT basic type 
with the set of bit values {0, 1}, the INTEGER basic type with the set of integers 
{..., -2, -1, 0, 1, 2, ...}, the CHARACTER basic type with the set {(CHAR 
0), ..., (CHAR 127)} of ASCII-128 character representations, and an arbitrary 
enumeration type with the set of its enumeration literals. 


90 



• The selection sets for each case alternative must be mutually disjoint^ and their union 
must be the set associated with the basic type of the selector expression. The case 
selection subsets defined by the discrete ranges within each case alternative need 
not be disjoint. Note that a CASE statement with a selection expression of basic 
type INTEGER must have an OTHERS alternative, as the set of integers cannot be 
covered by a finite number of case alternatives, each with only a finite number of 
(finite) discrete ranges. 


The basic type of the selector expression is first determined. Then semantic function AT is 
invoked with this basic type to check the case alternatives. Refer to the discussion of AT, 
which returns the union of the case selection sets associated with all of the case alternatives, 
a union that must cover the set associated with the selector expression’s basic type. 

(SST7) SST |[ LOOP atmark id seq-stat* opt-id | (p)(c)(t) 

= let q = find-looplabel-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 
(id 6 labels —► error (cat (“Duplicate loop label: ”)($(q)(id))), 
let ti = enter(t)(q)(*LAB* )((e,cons(id,labels))) in 
(->null(opt-id)A opt-id ^ id 
—► error 

(cat(“Loop ”)(id)(“ ended with incorrect identifier: ”)(opt-id)), 
let t2 = enter(ti)(q)(id)(<e,*LOOPNAME* ,p>) in 
let pi = %(p)(id) in 

let ts = enter(extend(t2)(p)(id))(pi )(*UNIT* )(<£,*LOOP* >) in 
let t4 = enter(t3)(pi)(*LAB* )(<e,e>) in 
let is = enter(t4)(p)(id)(<e,*LOOPNAME* ,p>) in 
let Cl = At. SST [[seq-stat* | (pi)(c)(t) in 

Cl(t 5 ))) 

(SST 8 ) SST [[ WHILE atmark id expr seq-stat* opt-id J (p)(c)(t) 

= let q = find-looplabel-env(t)(p) in 
let labels = third(t(q)(*LAB’*' )) in 
(id € labels —► error(cat(“Duplicate loop label: ”)($(q)(id))), 
let ti = enter(t)(q)(*LAB* )((e,cons(id,labels))) in 
(opt-id ^ £ A opt-id ^ id 
error 

(cat(“Loop ”)(id)(“ ended with incorrect identifier: ”)(opt-id)), 
let t2 = enter(ti)(q)(id)(<£ *LOOPNAME* ,p>) in 
let Pi = %(p)(id) in 

let t3 =enter(extend(t2)(p)(id))(pi)(*UNIT* )(<£ *LOOP* >) in 
let t4 = enter(t3)(pi)(*LAB* )(<£,£>) in 
let is = enter(t4)(p)(id)(<£,*LOOPNAME* ,p>) in 
let Cl = At. SST [[seq-stat* ]| (pi)(c)(t) in 
RT [expr J (pi)(k)(t 5 ) 
where 
k = A(w,e),t. 

(is-boolean?(w)—► ci(t), 
error 

(cat(“Non”boolean condition in WHILE statement: ”) 

(tdesc(w)))))) 

(SST9) SST [[ FOR atmark id ref discrete-range seq-stat* opt-id ]] (p)(c)(t) 

= let q = find-looplabel-env(t)(p) in 
let labels = third(t(q)(*LAB* )) in 


91 


(id € labels error(cat(“Duplicate loop label: ”)($(q)(id))), 

let ti == enter(t)(q)(*LAB* )({£,cons(id,labels))) in 
(^null(opt-id)A opt-id ^ id 
—^ error 

(cat(“Loop ”)(id)(“ ended with incorrect identifier: ”)(opt-id)), 
let t2 = enter(ti)(q)(id)(< 6 ,*LOOPNAME* ,p>) in 
let Pi = %(p)(icl) in 

let t3 =enter(extend(t2)(p)(id))(pi)(*UNIT* )(<e*LOOP* >) in 
let t4 = enter(t3)(pi)('^LAB*'' )(<£,£:>) in 
let ts = enter(t4)(p)(id)(<£,*LOOPNAME* ,p>) in 
let (direction,expri ,expr2 )= discrete-range in 
RT I expn 1 (p)(ki)(t) 
where 

k, = A(wi,ei),t, 

let di = tdesc(wi) in 

RT [[ expr 2 } (p)(k 2 )(t) 
where 

k2 = A(w2,e2),t. 

let d2 = tdesc(w2) in 
(match-types(di ,d2) 

^ let decl = (DEC .CONST , 

(hd(hd(tl(ref)))), 

(hd(dO). 

hd(tl(discrete-range))) in 
DTIdeclI(p,)(tt)(u)(t 5 ), 
error 

(cat{“Bounds type iiiis«atch in FOR statement; ”) 
(seq-stat))) 

where 

U = At6.Cl(t6) 

where ci = Atr. SST IF seq-stat* | (pi)(c)(t 7 ))) 

find-looplabel-env(t)(p) 

= let tg = tag(t(p)(*UNIT* )) in 

(null(p)v tg e (*PROCESS* *PROCEDURE* ^FUNCTION* *LOOP*) — p, 
iind-looplabel-env(t)(rest(p))) 

In Stage 4 VHDL, entering a loop (i.e., a LOOP, WHILE or FOR statement) creates a new com¬ 
ponent environment of the TSE, just as in the case of entering a subprogram (see below). 
The identifier that is the loop’s label must be checked for uniqueness among the identifiers 
used thus far as labels in the innermost enclosing program unit (process, procedure, func¬ 
tion, or loop). If unique, the identifier is appended to the innermost enclosing unit’s label 
identifier list (bound to the special identifier *LAB’^ of the corresponding environment). 

A *LOOPNAME* descriptor is then entered into the current environment. The resulting 
TSE is extended to reflect loop entry; the *UNIT* entry in the extended TSE is set 
to *LOOP* to associate the extended TSE with the loop, and the *LOOPNAME* 
descriptor is also entered into the extended TSE. This latter descriptor is used by EXIT 
statements contained in this loop to validate the visibility of their loop names. 

In the case of a WHILE loop, the basic type of the iteration control expression is checked to 
be BOOLEAN, and the loop body is also checked by SST. 

In the case of a FOR loop, the basic types of the iteration bounds expressions are checked to 
match, the implicit declaration of the iteration parameter is processed by semantic function 


92 


DT, and the loop body is checked with SST. 

(SSTIO) SST [ EXIT atmark opt-dotted-name opt-expr ] (p)(c)(t) 

= (null(find-loop-env(t)(p)) 

—+ error(cat(“EXIT statement not in a loop: )(seq-stat)), 

(null(opt-dotted-naine)-^ Ci(t), 
name-type(opt-dotted-name)(£)(p)(t)(v) 
where 

V = Aw.{tag(tdesc(w))/ *LOOPNAME* 

—♦ error(cat(“Not a loop name: ”)(namef(tdesc(w)))), 
ci(t))) 
where 

Cl = At.(null(opt-expr)—^ c{t), 
let expr = opt-expr in 
RT lexpr ] (p)(k)(t) 
where 
k = A(w,e),t. 

(is-boolean?(w)—t c(t), 
error 

(cat(“Non^boolesm condition in EXIT statement: ”) 

(tdesc(w)))))) 

An EXIT statement must be contained within a loop; otherwise, an error is raised. If an 
exit control expression is present, its basic type is checked; if not BOOLEAN, an error is 
raised. 

(SSTll) SST IT CALL atmark ref] (p)(c)(t) 

= let expr = ref in 
ET llexprl(p)(k)(t) 
where 
k = A(w,e),t. 

(tag(tdesc(w))= *VOID* —► c(t), 
error(cat(“Invalid procedure call: ”)(seq-stat))) 

A procedure caU statement boils down to an expression that is a Stage 4 VHDL name. This 
expression is checked by ET, and must have a VOID basic type. 

(SST12) SST I RETURN atmark opt-expr ] (p)(c)(t) 

= let d = context(t)(p) in 
let tg = tag(d) 

and cname = namef(d) in 
(null(opt-expr) 

^ (tg / ^PROCEDURE* 

—► error 

(cat(“RETURN without expression in context of non-procedure: ”) 
(cname)(seq-stat)), 

c(t)), 

(tg ^ ^FUNCTION* 

—+ error 

(cat(“RETURN with expression in context of non-function: ”) 
(cname)(seq-stat)), 
let expr = opt-expr in 
RT I expr 1 (p)(k)(t) 
where 


93 



k = A(w,e),t. 

(map-match-types(tdesc(w))(extract-rtypes(signatures(d))) 

c(t)> 

error 

(cat(“Incorrect return expression type in function: ”) 
(cname)(seq-stat))))) 


context{t)(path) 

= let d = t(path)(*UNIT* ) in 

(d = ^UNBOUND* —► context(t)(rest(path)), 

(case tag(d) 

(^PROCEDURE* ^FUNCTION**' ^PACKAGE* ) t(rest(path))(last(path)), 
OTHERWISE ^ context(t)(rest(path)))) 

extract-rtypes(signatures) 

= (null(signatures)^ e, 

cons(tdesc(rtype(hd(signatures))),extract-rtypes(tl(signatures)))) 

RETURN statements have two forms, depending on the PROCEDURE or FUNCTION context in 
which they can appear. Auxiliary semantic function context returns the descriptor of the 
smallest subprogram or package enclosing the program text whose local environment is at 
the end of the current path. It is first determined whether the RETURN statement is in the 
proper context. If so, then if the RETURN statement has an expression, its basic type must 
be equal to the basic type of the result type of the function in which it appears. 

(SST13) SST I WAIT atmark ref* opt-expri opt-expr 2 1 (p)(c)(t) 

= let Cl = At.let d = lookup(t)(p)(*SENS* ) in 
(--'nuil(sensitivity(d)) 

—*■ error 

(cat(“WAIT statement ”)(seq-stat) 

(“ illegal in process with sensitivity list: ”) 

(last(p))), 

let C2 = At.(null(opt-expr 2 c(t), 
let expr 2 = opt-expr 2 in 

BX I expr2 I (p)(k2)(t) 

where 

k2 = A(w2,e2),t2. 

(is-time?(w2)-^ c(t2), 
error 

(cat(“Ill-typed timeout clause in WAIT statement: ”) 
(seq-stat)))) in 
(null(opt-expri )—*■ C2(t), 
let expri = opt-expri in 
RT [ expn ] (p)(ki)(t) 
where 

ki ~ A(wi,ei),ti. 

(is-boolean?(wi)—► C 2 (ti), 
error 

(cat(“Non“boolean condition clause in WAIT statement: ”) 
(seq-stat))))) in 

check-wait-refs(seq-stat)(ref*)(p)(ci )(t) 

check-wait-refs(seq-stat)(ref*)(p)(c)(t) 

= (null( I reP ] )-^ c(t), 
let ref = hd(ref*) 

and Cl = At.check-wait-refs(seq-stat)(tl(rer))(p)(c)(t) in 
check-wait-ref(seq-stat) (ref )(p)(ci)(t)) 


94 



check-wait-ref(seq-stat)(ref)(p)(c)(t) 
= let expr = ref in 

ET [ expr I (p)(k)(t) 
where 


k = A(w,e),t. 

let d = tdesc(w) in 

(d = ^UNBOUND* —*■ error(cat(‘'Unbound identifier: ”)(namef 

(d))), 


(is-sig?(w)-» c(t), 
error 

(cat(“Non-signal ”)(ref) 

(“ in sensitivity clause of WAIT statement: '’) 
(seq-stat)))) 


Semantic equation SST13 specifies the static semantics of the WAIT statement, which con¬ 
sists of a sensitivity list ref*, an optional condition opt-expri, and an optional timeout 
expression opt-expr 2 . First, auxiliary semantic function check-wait-refs recursively tra¬ 
verses the sensitivity list, checking that each ref denotes a declared signal. Next, a descriptor 
for the special identifier *SENS* is looked up, and if its sensitivity field is nonempty, then 
the WAIT statement illegally appears inside a PROCESS statement with a sensitivity list. If 
present, the condition is checked to have basic type BOOLEAN. Finally, if present, the 
timeout expression is checked to have basic type TIME. 


6.5.15 Case Alternatives 

(ATO) ^ I £ I (d)(p)(y)(t) = y(emptyset)(t) 

(ATI) AT I case-alt* case-alt ]] (d)(p)(y)(t) 

= AT I case-alt* ] (d)(p)(yi )(t) 
where 
yi = Ahijti. 

AT [ case-alt ] (d)(p)(y 2 )(ti) 
where 
y2 = Ah2,t2. 

(case-overlap(d)((hi ,h 2 )) 

—error 

(cat(“Overlapping case alternatives for type: ”) 
(namef(d))), 

y(case-union(d)((hi ,h 2 )))(t 2 )) 

(AT2) AT I CASECHOICE discrete-range+ seq-stat* } (d)(p)(y)(t) 

= DRT I discrete-range'*’ | (d)(p)(yi )(t) 
where 
yi = Ah,ti. 

SST [ seq-stat* J (p)(c)(ti) 
where c = At 2 .y(h)(t 2 ) 

(ATS) AT I CASEOTHERS seq-stat* ] (d)(p)(y)(t) 

= SST J seq-stat* J (p)(c)(t) 
where 

c = Ati.y((is-boolean-tdesc?(d)—► {FALSE ,TRUE }, 
is-bit-tdesc?(d)—► {0,1}, 
is-integer-tdesc?(d)—► INT , 


95 



is-enumeration-tdesc?(cl)—^ ENUM , 
error 

(cat(“Illegal CASE selector type: ”)(nainef(d))(case-alt)))) 

(ti) 


caLse-overlap(d)(x,y) 

= ((is-integer-tdesc?(d)A (x = INT V y = INT )) 

V (is-enumeration-tdesc?(d)A (x = ENUM V y = ENUM )) 

- fF, 

X n y ^ emptyset) 
case'Union(d)(x,y) 

= (is-integer-tdesc?(d)A (x = INT V y INT ) —^ INT , 

is-enumeration-tdesc?(d)A (x — ENUM V y = ENUM ) ENUM , 
X U y) 


Semantic function AT processes each case alternative in turn, beginning with the last one. 
As the case selection set of each alternative is computed, it is checked for disjointness with 
the union of the selection sets of the preceding alternatives. If disjoint, then the union of 
these two case selection sets is returned; otherwise an error is raised. 

Note that the case selection set of an OTHERS alternative (represented by CASEOTHERS in 
the abstract syntax) is always disjoint from the union of the selection sets of the preceding 
alternatives, because (1) a CASE statement can contain at most one such alternative; (2) if 
such an alternative is present, it must be the laist alternative; and (3) the case selection set 
of an OTHERS alternative is the relative complement of the union of the case selection sets 
of the preceding alternatives. 

AT invokes the semantic function DRT to compute the case selection set defined by the 
sequence of discrete ranges of a particular case alternative. 


6.5.16 Discrete Ranges 

(DRTO) DRT [[ £ I (d)(p)(y)(t) = y(emptyset)(t) 

(DRTl) DRT I discrete-range discrete-range* ] {d)(p)(y)(t) 
= DRT I discrete-range ] (d)(p)(yi )(t) 
where 
yi = Ahi,ti. 

DRT J discrete-range* | (d)(p)(y2)(ti) 
where ya = Ah2,t2.y(hi U h2)(t2) 


A sequence of discrete ranges is processed in order, from left to right. 


(DRT2) DRT [ discrete-range | (d){p)(y)(t) 

= let (direction,expri jexpra) = discrete-range in 
RT lexpn 1 (p)(ki)(t) 
where 


ki = A(wi,ei),ti. 

(-'niatch-types(d,tdesc(wi)) 

—► error(cat(“CASE type mismatch: ”)(d)(tdesc{wi))), 


96 



Appropriate constraints make sure that all simulatedjsignal^ources occur in the same 
simulation cycle as the containing simiilated_explicit_signal_state and that they are legitimate 
sources of the simulated^ignal according to the design source description. 


96a 



ei = *UNDEF* 

error(cat(“Kon-static CASE expression: ”) Jexpri J ), 
M |Iexpr2 1 (p)(k2)(ti) 
where 


k2 


A(w2,e2),t2. 

(-imatch-types(d,tdesc(w2)) 

—error 

(cat(‘‘CASE type fflismatch: 


€2 = *UNDEF* 


”)(d)(tdesc 

(W2))), 


(cat(“Non-static CASE expression: ”) 

I expr2 ] ), 

y(ink-set(d)((direction,ei ,e2)))(t2))) 


mk-set(d)(direction,ei ,62) 

= (case tag(d) 

*BOOL* 

_ (ei = 62 {ei}, 

(direction = TO (ej = FALSE A 62 == TRUE {FALSE ,TRUE }, emptyset), 

(ei = TRUE A 62 = FALSE {TRUE ,FALSE }, emptyset))), 

*BIT* 

—*• (ei = e2 —>■ {ei}, 

(direction = TO — (ei = 0 A 62 = 1 — { 0 > 1 }> emptyset), (ei = 1 A 62 = 0 {L 0 }> emptyset))), 

(*INT* ♦INT-TYPE* ) 

—+ (direction = TO 

—► (ei <62 —► {ei} U mk-set(d)((direction,(ei-f l),e2)), emptyset), 

(ei > 62 {ei} U mk-set(d)((direction,(ei-l),e2)), emptyset)), 

*ENUMTYPE* 

—► (direction = TO —► mk-enum-set(literals(d))(ei )(e2), 
mk-enum-set(reverse(literals(d)))(ei )(e2)), 

OTHERWISEerror(cat(“Illegal CASE expression type tag: ”)(tag(d)))) 


mk-enum-set(id‘*' )(idi )(icl 2 ) 

= let ni = position(idi )(id‘^) 

and n2 — position(id2 )(icl'‘') in 
(n2 < ni -^ £, 

nth-tl(ni)(reverse(nth-tl(length(id+)-(n 2 +l))(reverse(id+))))) 
nth-tl(n)(x) = (n = 0 —► X, nth-tl(n—l)(tl(x))) 
position(a)(x) = position-aux(a)(x)(0) 
position-aux(a)(x)(n) 

= (null(x)—fF, (a = hd(x)—► n, position-aux(a)(tl(x))(H-n))) 
reverse(x) = reverse-aux(x)(£) 

reverse-aux(x)(y) = (null(x)-^ y, reverse-aux(tl(x))(cons(hd(x),y))) 


Semantic function DRT receives a case selector expression’s basic, type from AT. DRT 
detects a mismatch between the basic type of a discrete range and that of the selector 
expression; it also detects the presence of nonstatic expressions in a discrete range. Case 
selection sets are constructed by the function mk-set (“make set”), which takes a type 
descriptor and a pair of translated static expressions that represent a discrete range (that 
the expressions are static is checked in Phase 1) and returns the corresponding set of values. 


97 


6.5.17 Waveforms and Transactions 

(WTl) WT ir WAVE transaction^ ] (p)(k)(t) = TRT [[ transaction+ ] (p)(k)(t) 


(TRTl) TRT [transaction transaction* J (p)(k)(t) 

= TRT I transaction ] (p)(ki)(t) 
where 

ki = A(wi,ei),ti. 

let di = tdesc(wi) in 
(null( transaction *)—+ k((wi ,ei ))(ti), 
let transaction]*" = transaction* in 
TRT I transaction]*" ] (p)(k2)(ti) 
where 

k2 = A(w2,e2),t2. 

let d2 = tdesc(w2) in 
(-•match-types(di,d2) 

—► error 

{cat(“Type mismatch for waveform transactions: ”) 
(transaction)(hd(transaction]*‘))), 
ei ^ *UNDEF* A 62 *UNDEF* 

(ei > e2 
—► error 

(cat(‘'Nonascending times for waveform transactions: ”) 
(transaction)(hd(transaction]*"))), 
k((w2,e2))(t2)), 
k((w2,ei))(t2))) 

(TRT2) TRT |[ TRANS expr opt-expr ]] (p)(k)(t) 

= RT [expr J (p)(ki)(t) 
where 

ki = A(wi,ei),ti. 

(null(opt-expr)-> k((wi,0))(ti), 
let expr2 = opt-expr in 
RT Iexpr2 l(p)(k2)(ti) 
where 

k2 = A(w2,e2),t2. 

(-•is-time?(w2) 

—error 

(cat(“Transaction has ill-typed time expression: ”) 
(tdesc(w2))), 

62 # *UNDEF* 

(e2 < 0 

—error 

(cat(“Transaction has negative time expression: 

(e2)), 

k((wi,e2))(t2)), 

k((wi,e2))(t2))) 


6.5.18 Exp cessions 

(ET0)jETl€]|(p)(k)(t) = k((6,£))(t) 

(ETl) ET [FALSE] (p)(k)(t) = k((mk-type((CONST VAL) )(bool-type-desc(t)),FALSE ))(t) 
(ET2) ET [ TRUE | (p)(k)(t) = k((mk-type((CONST VAL) )(bool-type-desc(t)),TRUE ))(t) 


98 



(ET 3 ) ET I BIT bitlit ] (p)(k)(t) 

k((mk-type((CONST VAL) )(bit-type-desc(t)),B | bitlit ]] ))(t) 

(ET 4 ) ET [ NUM constant ] (p)(k)(t) 

= k((ink-type((CONST VAL) )(int-type-desc(t)),N | constant | ))(t) 


(ET 5 ) ET I TIME constant time-unit J (p)(k)(t) 

= let normalized-constant = (case time-unit 

FS —►MI constant ] , 

PS —► 1000 xN J constant | , 

NS —*■ lOOOOOOxN I constant ] , 

US ^ lOOOOOOOOOxN [ constant ] , 

MS lOOOOOOOOOOOOxN [constant | , 

SEC —lOOOOOOOOOOOOOOOxN [ constant ] , 

MIN -- 60 x( 1000000000000000 xN [[ constant ]] ), 

HR 3600 x( 1000000000000000 xN [ constant J ), 
OTHERWISE 
—► error 

(cat(“Illegal unit name for physical type TIfffi: ”) 
(time-unit))) in 

k((mk-type((CONST VAL) )(time-type-desc(t)),normalized-constant))(t) 


(ET 6 ) ET I CHAR constant | (p)(k)(t) 

= let expr = (CHAR ,constant) in 

let d = lookup(t)((STANDARD) )(expr) in 
k((type(d),idf(d)))(t) 


(ET 7 ) ET I BITSTR bit-lit* 1 (p)(k)(t) 

= let expr* = bit-lit* in 
(null(expr*) 

- k((mk.type((CONST VAL) )(lookup(t)( 5 )(BIT_VECTOR )) ♦UNDEF’*' ))(t), 
list-type(expr* )(p)(t)(vv) 

where vv = Aw*.array-type(BIT-VECTOR )(expr*)(w*)(t)(p)(k)) 

(ET 8 ) ET I STR char-lit* J (p)(k)(t) 

= let expr* = char-lit* in 

(null(expr*)- k((mk-type((CONST VAL) )(lookup(t)(e)(STRING )),^UNDEF* ))(t), 
list-type(expr* )(p)(t)(vv) 

where vv = Aw*.array-type(STRING )(expr*)(w*)(t)(p)(k)) 

array-type( array-type-name) (expr* )(w*)(t)(p)(k) 

= let d = tdesc(hd(w*)) in 
(chk-array-type(d)(tl(w*)) 

—* let array-type-desc = array-type-desc 

(new-array-type-name(array-type-nam€))(e)(p)(tt) 

(TO )((NUM 1 ) )((NUM ,length(w*)))(d) in 
k((mk-type(tmode(hd(w*)))(array-type-desc),*UNDEF* ))(t), 
error(cat(“Array aggregate of inhomogeneous type: ”)(expr*))) 


chk-array-type(d)(w*) 

— (null(w*)—► tt, 

match-types(d)(tdesc(hd(w*)))—► chk-array-type(d)(tl(w*)), 

ff) 


99 


(ET9) ET I REF name } {p)(k)(t) 

= name>type(name)(e)(p)(t)(v) 
where 

V = Aw.let d = tdesc(w) in 

(second(tmode(w))= TYP 

—error (cat (“Wrong context for a type: ” )(namef(d))(expr)), 
tag(d)= ^OBJECT* k((type(d),value(d)))(t), 
tag(d)= *ENUMELT* - k((type(d),idf(d)))(t), 
k((w *UNDEF* ))(t)) 


(ETIO) ET I PAGGR expr* ] (p)(k)(t) 

= (length(expr* )= 1 

—► let expr = hd(expr*) in 
^[expr|(p)(k)(t), 
list-type(expr*)(p)(t)(vv) 

where vv = Aw*.array-type(*ANONYMOUS* )(expr*)(w*){t)(p)(k)) 


(ETll) ET I unary-op expr ] (p)(k)(t) 

= RTIexpri (p)(ki)(t) 

where kj = A(w,e),t.OTl J unary-op J (k){(w,e))(t) 

(ET 12 ) ET [ binary-op expri expr2 1 (p)(k)(t) 

= ^|[expri 1 (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT [[ expr2 1 (p)(k2)(t) 

where k2 = A(w2,e2),t. 

QT 2 [ binary-op ] (k)((wi ,ei ))((w2,e2))(t) 

(ET 13 ) ET I relational-op expri expr2 J (p)(k)(t) 

= ^ I expri I (p)(ki)(t) 
where 

ki = A(wi,ei),t. 

RT I expr 2 ] (p)(k 2 )(t) 
where 

k2 = A(w2,e2),t. 

QT 2 I relational-op | (k)((wi ,ei ))((w2,e2))(t) 


(RTl)RTlexprI(p)(k)(t) 

= ETI expri (p)(ki)(t) 
where 

ki = A(w,e),t. 

let tm = tmode(w) 

and d = tdesc(w) in 
(second(tm)= ACC —► error 

(cat(“Non-value (an access): ”)(expr)), 

second(tm)= OUT 
—► error 

(cat(“Cannot dereference formal OUT parameter: ”)(expr)), 
second(tm)= VAL A is-void-tdesc?(d) 
error(cat(“Void value: ”)(expr)), 

let wi = ((second(tm)= AGR - (DUMMY AGR) , (DUMMY VAL) ),tdesc(w)) in 
k((wi,e))(t)) 


100 



(OTl.l) QTl I unary-op ] (k)(w,e){t) 

= let d = tdesc(w) in 

(match-types(d,argtypesl(unary-op)(d)) 

—► k((restypel(unary-op)(d),resvall(unary-op)(e)(d)))(t), 
error 

(cat (“Argument type mismatch for unary operator: ” )(unary-op)(d))) 


argtypesl (unary-op)(d) 

= (case unary-op 

NOT 

—► (is-boolean-tdesc?(d)V is-bit-tdesc?(d)-^ d, 
argtypesl-error(unary-op)(d)), 

(PLUS ,NEG ,ABS ) 

—^ (is-integer-tdesc?(d)V is-time-tdesc?(d)—► d, 
argtypesl-error(unary-op)(d)), 

OTHERWISE - error 

(cat(“Unrecognized Stage 4 VHDL unary operator: ”)(unary-op))) 


argtypesl-error(unary-op)(d) 

= error (cat (“Unary operator ” )(unary-op)( “ not implemented for type: ”)(d)) 
restypel(unary-op)(d) = nik-type((DUMMY VAL) )(d) 


resvall (unary-op)(e)(d) 

= (e = *UNDEF* -- *UNDEF* , 
(case unary-op 
NOT 

(is-boolean-tdesc?(d)—>■ ->6, 
is-bit-tdesc?(d)—► invert-bit(e), 
*UNDEF* ), 

PLUS ^ e, 

NEG — -e, 

ABS —► abs(e), 

OTHERWISE — *UNDEF* )) 


invert-bit(bitlit) = mk-bit-simp-symbol((-bitlit) 4 -l) 


mk-bit-simp-symbol(bitlit) 

= (case bitlit 

0 ^ (BS 0 1) , 

1 (BS 1 1) , 

OTHERWISE—+error(cat(“Can^t construct simp symbol for bit: ”)(bitlit))) 


(OT 2 . 1 ) OT2 J binary-op J (k)(wi ,ei )(w2,e2)(t) 

= let di = tdesc(wi) 

and d2 = tdesc(w2) in 
(argtypes2(binary-op)((di ,d2)) 

^ k((restype2(binary-op)((di ,d2))(t), 

resval2((di,d2))(binary-op)((ei ,e2))))(t), 

error 

(cat(“Argument type mismatch for binary operator: ”)(binary-op)(di) 


101 



(OT 2 . 2 ) OT 2 I relational-op ] (k)(wi,ei)(w2,e2)(t) 

= let di = tdesc(wi) 

and d 2 = tdesc(w 2 ) in 
(argtypes2(relational-op)((di ,d 2 )) 

- k((mk-type((DUMMY VAL) )(bool-type-desc(t)), 
resvaJ 2 ((di ,d2))(relational-op){(ei ,e2))))(t), 

error 

(cat(“Argument type mismatch for relational operator: ”) 
(relational-op)(di )(d2))) 

argtypes 2 (op)(di,d 2 ) 

= (case op 

(AND ,NAND ,OR ,NOR ,XOR ) 

—*■ (case tag(di) 

*BOOL* —is-boolean-tdesc?(d2 )V argtypes 2 -error(op)(di )(d2), 

*BIT* —is-bit-tdesc?(d2)V argtypes 2 -error(op)(di )(d2), 

OTHERWISE —► argtypes2-error(op)(di ){d 2 )), 

(ADD ,SUB ) 

—► (case tag(di) 

(*INT* *INT.TYPE* ) — match-types(di)(d2)V argtypes 2 -error(op)(di )(d2), 
(*TIME* ,*REAL* ) ^ di = d2 V argtypes 2 -error(op)(di )(d2), 
OTHERWISE ^ argtypes 2 -error(op)(di )(d2)), 

MUL 

—► (case tag(di) 

(♦INT* *INT_TYPE* *REAL* ) 

—► match-types(di)(d2)V is-time-tdesc?(d2), 

♦TIME* 

—is-integer-tdesc?(d2)V is-real-tdesc?(d2 ), 

OTHERWISE argtypes2-error(op)(di)(d2)), 

DIV 

—► (case tag(di) 

(*INT* ,*INTJrYPE* *REAL* ) 

—► match-types(di)(d2)V argtypes 2 -error(op)(di )(d2), 

♦TIME* 

—>■ is-integer-tdesc?(d2 )V is-real-tdesc?(d2), 

OTHERWISE —♦ argtypes 2 -error(op)(di )(d2)), 

(MOD ,REM ) 

—► (case tag(di) 

(*INT* *INT^TYPE* ) 

is-integer-tdesc?(d2)V argtypes 2 -error(op)(di )(d2), 

OTHERWISE —► argtypes2-error(op)(di )(d 2 )), 

EXP 

—♦ (case tag(di) 

(*INT* *INT_TYPE* ♦REAL* ) 

—► is-integer-tdesc?(d2)V argtypes 2 -error(op)(di )(d2), 

OTHERWISE —► argtypes 2 -error(op)(di )(d2)), 

CONCAT 
—► (is-bit-tdesc?(di) 

—► is-bit-tdesc?(d2)V is-bit vector-tdesc?(d2), 

(is-bit-tdesc?(d 2 ) 

—^ is-bit-tdesc?(di )V !s-bitvector-tdesc?(di), 

(is-array-tdesc?(di )A is-array-tdesc?(d2) 

—match-array-type-names(idf(di),idf(d 2 )) 

A raatch-types(elty(di),elty(d2)), 
argtypes 2 -error(op)(di )(d2)))), 

(EQ ,NE ) —► match-types(di ,d2)V argtypes 2 -error(op)(di )(d2), 

(LT ,LE ,GT ,GE ) 


102 



—► (is-scaJar-tdesc?(di )A is-scalar-tdesc?(d 2 ) 

—► match-types(di)(d 2 )V argtypes2-error(op)(di)(d 2 ), 
is-bitvector-tdesc?(di )A is-bitvector-tdesc?(d 2 )—" tt, 
argtypes2-error(op)(di )(d 2 )), 

OTHERWISE ^ error(cat(“Unrecognized Stage 4 VHDL operator: ”)(op))) 
argtypes 2 -error(op)(di )(d2) 

= error(cat(“Operator ”)(op)(“ not implemented for pair of types: ”)(di)(d2)) 

restype2(binary-op)(di ,d 2 )(t) 

— (case binary-op 

(AND ,NAND ,OR ,NOR ,XOR ,ADD ,SUB ,MOD ,REM ,EXP ) ^ mk-type((DUMMY VAL) )(di), 
MUL 

^ (case tag(di) 

(*INT**= *INT_TYPE* ♦REAL* ) mk-type((DUMMY VAL) )(d 2 ), 

♦TIME* - mk-type((DUMMY VAL) )(di), 

OTHERWISE - error(“ShoulcinH happen!”)), 

DIV 

^ (case tag(di) 

(*INT* ,*INT^TYPE* ,*REAL* ).-^ mk-type((DUMMY VAL) )(d 2 ), 

♦TIME* 

(case tag(d 2 ) 

(♦INT* ,*INT_TYPE* ,*REAL* ) — mk-type((DUMMY VAL) )(di), 

♦TIME* mk-type((DUMMY VAL) )(univint-type-desc(t)), 

OTHERWISE-^ error (“Shouldn't happen!”)), 

OTHERWISE error(“Shouldn't happen!”)), 

CONCAT —► mk-type((DUMMY VAL) )(nik-concat-tdesc(di )(d 2 )(t)), 

OTHERWISE 

error(cat(“Unrecognized Stage 4 VHDL binary operator: ”)(binary-op))) 

mk-concat-tdesc(di )(d 2 )(t) 

= (is-bit-tdesc?(di )V is-bitvector-tdesc?(di) 

—► array-type-desc 

(new-array-type-naine(BIT-VECTOR ))(e)(e)(tt)(direction(di ))(lb(di ))(e) 

(bit-type-desc(t)), 
let idfi = idf(di) in 
array-type-desc 

(new-array-type-name((consp(idfi)—► hd(idfi), idfj )))(£)(e:)(tt) 

(direction(di ))(Ib(di ))(e)(elty(di))) 

resvaI2(di ,d 2 )(op)(el,e2) 

= (el = ♦UNDEF* V e2 = ♦UNDEF* ♦UNDEF* , 
let tg = tag(di) in 
(case tg 

♦BOOL* 

(case op 

AND —► el A e2, 

NAND ^ -(el A e2), 

OR el V e2, 

NOR — -(el V e2), 

XOR -- (el = e2 fF, tt), 

EQ — el = e2, 

NE ^ el / e2, 

LT -el A e2, 

LE ^ -el V e2, 

GT — el A -e2, 

GE ^ el V -e2, 


103 



OTHERWISE 

—► error 

(cat(“Unrecognized Stage 4 VHDL ^boolean’ binary operator: ”)(op))), 

*BIT* 

(case op 

AND 

—(el = 1 A e2 = 1 —► mk-bit-simp-symbol(l), ink-bit-simp-symbol(O)), 

NAND 

—+ (el = 0 V e2 = 0 —*■ mk~bit-simp-symbol(l), mk-bit-sinip-symbol(O)), 

OR 

—^ (el = 1 V e2 = 1 —► mk-bit-siinp-symbol(l), mk-bit-simp-synibol(O)), 

NOR 

(el = 0 A e2 = 0 —► mk-bit-simp-symbol(l), mk-bit-simp-symbol(O)), 

XOR —► (el = e2 mk-bit-simp-*symbol(0), mk-bit-simp-symbol(l)), 

EQ ^ el = e2, 

NE ^ el / e2, 

LT — el = 0 A e2 = 1, 

LE el = 0 V e2 = 1, 

GT el = 1 A e2 = 0, 

GE ^ el = 1 V e2 = 0, 

OTHERWISE 

error 

(cat(“Unrecognized Stage 4 VHDL ‘bit’ binary operator: ”)(op))), 

(*INT* *INT-TYPE* *TIME* ) 

>-► (case op 

ADD — eH-e2, 

SUB ^ el--e2, 

MUL — elxe2, 

DIV —»■ (e2 = 0 —► error(“Illegal division by zero!”), 
el/e2), 

MOD —► mod(el,e2), 

REM —> rem(el,e2), 

EXP ^ er e2, 

EQ —► el = e2, 

NE -- el e2, 

LT — el < e2, 

LE — el < e2, 

GT el > e2, 

GE -- el > e2, 

OTHERWISE 

—^ error 

(cat(“Unrecognized Stage 4 VHDL ‘integer’ binary operator: ”)(op))), 
♦REAL* —► error(cat(“Floating point operator not yet implemented: ”)(op)), 
♦ENUMTYPE* 

—+ (case op 

EQ ^ el = e2, 

NE — el 7 ^ e2, 

LT —enum-lt(el)(e2)(literals(di)), 

LE —► enum-le(el)(e2)(literaJs(di)), 

GT —► enuni-lt(e2)(el)(literals(di)), 

GE —► enum-le(e2)(el)(literals(di)), 

OTHERWISE 

—► error 

(cat(“Unrecognized Stage 4 VHDL ‘enumeration type’ binary operator: ”) 

(op))). 

*ARRAYTYPE* *UNDEF* , 

OTHERWISE 


104 



^ error(cat(“Unrecognized Stage 4 VHDL binary operator type: ”)(tg)))) 

enum-lt(el )(e 2 )(enum-lits) 

= let elpos = position(el)(enum-lits) 

and e 2 pos = position(e 2 )(enum-lits) in 
elpos < e 2 pos 

enum-le(el )(e 2 )(enum-lits) 

= let elpos = position(el)(enum-lits) 

and e 2 pos = position(e 2 )(enuin-lits) in 
elpos < e 2 pos 


6.5.19 Primitive Semantic Equations 

(Nl) N [ constant | = constant 


(Bl) B [ bitlit ] = bitlit 


105 



7 Interphase Abstract Syntax Tree Transformation 

Owing to the relative simplicity of the Stage 1 VHDL language subset, Phases 1 and 2 of 
the Stage 1 VHDL translator were able to use the same abstract syntax. 

Stage 2 VHDL was a considerably more sophisticated language subset. Consequently, it 
became convenient to allow Phase 2 of the VHDL translator for Stage 2 VHDL and sub¬ 
sequent stages, in particular Stage 4 VHDL, to employ a diiferent abstract syntax for the 
language than does Phase 1, for reasons discussed below. 

Accordingly, as the final act of Phase 1 translation of a given Stage 4 VHDL hardware 
description, an “interphase” abstract syntax tree transformation is performed that yields a 
new abstract syntax tree (AST) for use by Phase 2. This transformation does not modify 
the original AST. Although the resulting transformed AST may resemble the original in 
many respects, there will also be substantial differences. 

We should recall that in Phase 1, when abstract syntax trees are occasionally injected 
into the TSE, it is their transformed versions that are used; this occurs with array type 
descriptors created by functions process-slcdec and DT8, subprogram descriptors created 
by function process-subprog-body, and *SENS* (sensitivity list) descriptors updated 
with new refs by function SLT2. 


7.1 Interphase Semantic Functions 

The abstract syntax tree transformation is carried out by principal semantic functions DFX 
(design files), DUX (design units), CIX (context items), LUX (library-units), CFX (con¬ 
figuration declarations), BCX (block configurations), CMX (component configurations), 
BIX (binding indications), ENX (entity declarations), ARX (architecture bodies), GDX 
(generic declarations), PDX (port declarations), GMX (generic maps), PMX (port maps), 
DX (declarations), CSX (concurrent statements), SLX (sensitivity lists), SSX (sequen¬ 
tial statements), AX (case alternatives), DRX (discrete ranges), WX (waveforms), TRX 
(transactions), MEX (reference lists), and EX and RX (expressions). These are assisted 
by several important auxiliary semantic functions, most notably the function transform- 
name. 

Following Phase 1 construction of the tree-structured environment (TSE), semantic func¬ 
tion DFX is applied to the original AST to initiate the transformation, which uses (but 
does not modify) the TSE. Once the AST transformation is complete, Phase 1 auxiliary 
semantic function phase2 is invoked with the transformed AST and the TSE as syntactic 
and semantic arguments, respectively, to initiate Phase 2 translation (see Section 8). 

Generally speaking, the AST-transforming semantic functions straightforwardly reconstruct 
their syntactic arguments from their transformed immediate syntactic constituents, with the 
following exceptions: 


• “desugaring” of component instantiation statements into pairs of nested BLOCK state¬ 
ments 


106 



'"desugaring” of concurrent signal assignment statements: 
converting them into equivalent PROCESS statements 


• “desugaring” of sensitivity lists in PROCESS statements: 
converting them into explicit final WAIT statements 

• transformation of PORT declarations into SIGNAL declarations 

• ‘‘desugaring” of secondary units of physical type TIME: 
converting them into the base unit FS {femtoseconds) 

• disambiguation of refs as either array references or subprogram calls 

• overload resolution between BOOLEAN and BIT operators 

• overload resolution between INTEGER and REAL operators 

Listed below are the names of Common Lisp functions, not denotationally defined, that 
assist in the first of these tasks, 

record-equivalent-nested-block-stat 

const ruct-equivalent-nested-block-stat 

update-tse-wrt-component-instantiations 

update-tse-wrt-configuration 

accomplish-generic-and-port-maps 


7.2 Transformed Abstract Syntax of Names 

An important case in point is the translation of names, e,g. refs, which are heavily over¬ 
loaded: the Phase 1 semantic function name-type, which checks them and determines 
their type, is necessarily complex. Given the identical abstract syntax, a Phase 2 semantic 
function for refs would exhibit analogous complexity; instead, it was deemed preferable to 
transform the abstract syntax of refs into a form more suitable for Phase 2. 

Thus, the abstract syntax of refs used in Phase 1 is: 
ref ::= REF name 

name :id | name id I name eipr* 

while the abstract syntax of refs used in Phase 2 is: 


ref ::= REF basic-ref 
basic-ref : :* Modifier 
modifier ; := SREF id'*’ id 
I INDEX expr 
I SELECTOR id 
I PARLIST expr* 


107 



Although not reflected in the syntax shown above, a basic-ref (basic reference) must begin 
with a simple reference SREF id"*' id, which has for convenience been classified with the 
modifiers. The id is the root identifier, and id+ is the TSE access path for this ref. The 
structures following this root basic reference are called modifiers. An INDEX modifier 
denotes an array reference, a SELECTOR modifier denotes a record field access (not used 
in Stage 4 VHDL), and a PARLIST modifier denotes a subprogram call. This linear 
arrangement of a simple reference followed by zero or more modifiers makes the translation 
of refs in Phase 2 relatively straightforward, as the components of a ref are grouped from 
the left and thus a ref can be translated from left to right. 


108 



7.3 Interphase Semantic Equations 

Most of the semantic equations for the interphase abstract syntax tree transformation, being 
straightforward, will be displayed without comment. 


7.3.1 Stage 4 VHDL Design Files 

(DFXl) DFX |[ DESIGN-FILE id design-unit"^ | (using-configuration)(t) 

= let p = %(£)(id) in 

(DESIGN-FILE ,id,DUX [[ design-unitJ (using-configuration)(p)(t)) 


7.3.2 Design Units 

(DUXO) DUX [ £ J (using-configuration)(p)(t) = f 

(DUXl) DUX H design-unit design-unit* | (using-configuration)(p)(t) 

= cons( DUX [[design-unit J (using-configuration)(p)(t), 

DUX I design-unit* | (using-configuration)(p)(t)) 

(DUX2) DUX [ DESIGN-UNIT context-item* library-unit J (using-configuration)(p)(t) 
= (DESIGN-UNIT ,CIX [ context-item* ] (p)(t), 

LUX I library-unit | (using-configuration)(p)(t)) 


7.3.3 Contex Items 

(CIXO) CIX[[eI(p)(t)==£ 

(CIXl) CIX [ context-item context-item* | (p)(t) 

= cons(CIX I context-item | (p)(t),CIX [context-item* | (p)(t)) 

(CIX2) CIX [ USE dotted-name+ ] (p)(t) 

— let decl = context-item in 
M|decll (p)(t) 


7.3.4 Library Units 

(LUXl) LUX [ CONFIGURATION idi id 2 use-clause* block-config opt-id ] (using-configuration)(p)(t) 
= let configuration-decl = library-unit in 
CFX [ configuration-decl J (p)(t) 

(LUX 2 ) LUX [ PACKAGE id decl* opt-id ] (using-configuration)(p)(t) 

= let decl = library-unit in 
DX [ decl I (p)(t) 

(LUX 3 ) LUX [ENTITY id generic-decl* port-decl* decl* opt-id ] (using-configuration)(p)(t) 

= let entity-decl = library-unit in 
ENX [ entity-decl | (p)(t) 

(LUX 4 ) LUX [ PACKAGEBODY id decl* opt-id | (using-configuration)(p)(t) 

= let decl = library-unit in 
DX [ decl I (p)(t) 

(LUX 5 ) LUX [ARCHITECTURE idi id 2 decl* conc-stat* opt-id | (using-configuration)(p)(t) 

= let architecture-body = library-unit in 

ARX [ architecture-body J (using-configuration)(p)(t) 


109 



7.3.5 Configuration Declarations 

(CFXl) CFX ir CONFIGURATION idi id2 use-clause* block-config opt-id ] (p)(t) 
= (CONFIGURATION ,idi,id2,DX |[ use-clause* ] (%(p)(idi))(t), 

BCX [ block-config ] (%(p)(id2))(t),opt-id) 


(BCXl) BCX [[BLOCK-CONFIG id use-clause* component-config* | (p)(t) 
= (BLOCK-CONFIG ,id,DX [[ use-clause* } (p)(t), 
let pi = %(p)(id) in 
CMX [[ component-config* | (pi)(t)) 


(CMXO) CMX I e } (p)(t) = e 

(CMXl) CMX [[ component-config component-config* | (p)(t) 

= consf CMX I component-config ] (p)(t),CMX | component-config* ]] (p)(t)) 

(CMX2) CMX |[ COMP-CONFIG component-spec opt-binding-indication opt-block-config | (p)(t) 
= (null(opt-binding-indication)—> (COMP-CONFIG ,component-spec,£,e), 
let binding-indication = opt-binding-indication 

and component-name = second(component-spec) in 
let d = lookup-desc-for-ref((REF ,component-name))(p)(t) in 
let entity-aspect = second(binding-indication) in 
let pi = (hd(entity-aspect)= BOUND-ENTITY 

*—► let entity-name = last(second(entity-aspect)) in 
let entity-desc = lookup(t)(p)(entity-name) in 
%(path(entity-desc))(entity-name), 
let configuration-desc = lookup 

(t)(P) 

(last(second(entity-aspect))) in 
let entity-name = configured-entity(configuration-desc) in 
let entity-desc = lookup(t)(p)(entity-name) in 
%(path(entity-desc)) (entity-name)) 
and P2 = %(p)(idf(d)) in 

(COMP-CONFIG ,component-spec,BIX [ binding-indication ]] (pi)(p2)(t), 

(null(opt-block-config)—^ e, 
let block-config = opt-block-config in 
BCX I block-config I (pi)(t)))) 

(BIXl) BIX [[ BIND entity-aspect opt-generic-map-aspect opt-port-map-aspect J (pi)(p2)(t) 

= (BIND ,entity-tispect, 

(null(opt-generic-map-aspect)—+ e, 
let generic-map-aspect = opt-generic-map-aspect in 
GMX J generic-map-aspect | (pi)(p2)(t)), 

(null(opt-port-map-aspect)—*• e, 
let port-map-aspect = opt-port-map-aspect in 
PMX [[ port-map-aspect ]| (pi )(p2)(t))) 


7.3.6 Entity Declarations 

(ENXl) ENX I ENTITY id generic-decl’ port-ded* ded* opt-id | (p)(t) 

= insert-phasel-hook 

((ENTITY ,id,GDX [generic-ded* 1 (%(p)(id))(t), 

PDX I port-ded* ] (%(p)(id))(t),DX I ded* 1 (%(p)(id))(t),opt-id)) 
(entity-ded) 


no 



7.3.7 Architecture Bodies 


(ARXl) ARX H ARCHITECTURE idi id 2 ded* conc-stat* opt-id J (using-configuration)(p)(t) 
— let Pi = %(%{p)(id2))(idi) in 

(ARCHITECTURE ,idi ,id2,DX I decl* ] (pi)(t), 

CSX [conc-stat* | (using-configuration)(pi )(t)(tt),opt-id) 


7.3.8 Generic Declarations 

(GDXO) GDX [el (p)(t) = £ 


(GDXl) GDX [[ generic-decl generic-decl* J (p)(t) 

= consf GDX [ generic-decl ] (p)(t),GDX [[ generic-ded* | (p){t)) 


(GDX2) GDX [ DEC GENERIC id"^ type-mark opt-expr ] (p)(t) 
= (DEC ,CONST ,id^,type-mark, 
let expr = opt-expr in 
second(EX [ expr | (p)(t))) 


(GDX3) GDX [ SLCDEC GENERIC id+ slice-name opt-expr ] (p)(t) 
= (SLCDEC ,CONST ,id+, 

let (type-mark,discrete-range) = slice-name in 
(type-mark, DRX | discrete-range ]] (p)(t)), 
let expr = opt-expr in 
secondf EX [ expr | (p)(t))) 


7.3.9 Port Declarations 

(PDXO)PDX[[£l(p)(t) = e 


(PDXl) PDX [ port-ded port-ded* | (p)(t) 

= cons(PDX I port-ded | (p)(t),PDX [ port-ded* | (p)(t)) 


(PDX2) PDX I DEC PORT id+ mode type-mark opt-expr J (p)(t) 
= (DEC ,SIG ,idtype-mark, 
let expr = opt-expr in 
secondf EX [ expr | (p)(t))) 


(PDX3) PDX I SLCDEC PORT id+ mode slice-name opt-expr ] (p)(t) 
= (SLCDEC ,SIG ,id+, 

let (type-mark,discrete-range) = slice-name in 
(type-mark,DRX [ discrete-range | (p)(t)), 
let expr = opt-expr in 
secondf EX [[ expr ] (p)(t))) 


111 



7.3,10 Generic Maps and Port Maps 

(GMXl) GMX I GENERICMAP assoc-elt+ 1 (pi)(p2)(t) 

= (GENERICMAP ,transform-a 5 soc-elts(assoc-elf*’ )(pi )(P 2 )( 0 ) 


(PMXl) PMX ir PORTMAP assoc-elt+ | (pi){p2)(t) 

= (PORTMAP ,transform-assoc-elts(assoc-elt'‘‘)(pi)(p2)(t)) 


transform-assoc-elts(2issoc-elt* )(pi )(p2)(t) 

= (null(assoc-elt*)-+ e, 

let assoc-elt = hd(assoc-elt*) in 
let expri = hd(assoc-elt) 

and expr2 = secoiid(assoc-elt) in 

cons(consfsecond( EX [ expri I (Pi )(t)),second( EX [ expr2 I (p2)(t))), 
t ransfor m- assoc-elts( tl (assoc-el t *)) (p i) (P2) (t))) 


7.3.11 Declarations 

(DX 0 )DXlel(p)(t) = 5 

(DXl) DX I decl decl* 1 (p)(t) = cons(DX [[ decl ] (p)(t),^ I decl* ] (p)(t)) 


(DX2) DX [[ package-deci package-decl* | (p)(t) 

= consf DX [ package~decl | (p)(t),DX [[ package-decP | (p)(t)) 

(DX3) DX I package-body package-body* ]] (p)(t) 

= consf DX I package-body ] (p)(t),DX [[ package-body* J (p)(t)) 


(DX4) DX [[ use-clause use-clause* ] (p)(t) 

= consf DX [[ use-clause ] (p)(t),DX J use-clause* | (p)(t)) 

(DX5) DX J DEC object-class id"*" type-mark opt-expr ]] (p)(t) 

= (DEC ,object-class,id"*’,type-mark, 
let expr = opt-expr in 
second ( EX | expr J (p)(t))) 

(DX6) DX I SLCDEC object-class id"*’ slice-name opt-expr J (p)(t) 
= (SLCDEC ,object-class,id■*', 

let (type-mark,discrete-range) = slice-name in 
(type-mark, DRX [ discrete-range ]) (p)(t)), 
let expr = opt-expr in 
second ( EX [[ expr J (p)(t))) 

(DX 7 ) DX I ETDEC id id'*’ | (p)(t) = (ETDEC ,id,id+) 

(DX8) DX I ATDEC id discrete-range type-mark J (p)(t) 

= (ATDEC .id, DRX [ discrete-range ] (p)(t),type-mark) 

(DX 9 ) DX I PACKAGE id decl* opt-id J (p)(t) 

= (PACKAGE ,id,DX Idecl* } (%(p)(id))(t),opt-id) 


112 



(DXIO) M [ PACKAGEBODY id decP opt-id ] (p)(t) 

= let d = t(p){id) in 

let q = %(path(d))(id) in 
(PACKAGEBODY ,id,DX [ decP } (q)(t),opt-id) 


(DXll) DX I PROCEDURE id proc-par-spec* | (p)(t) 

= let d = t(p)(id) in 

(nulJ(body(d))>-* error(cat(“Missing subprogram body: 
(PROCEDURE ,id,proc-par-spec*)) 


”)(nanief 

(d))). 


(DX12) DX [ FUNCTION id func-par-spec* type-mark J (p)(t) 

= let d = t(p)(id) in 

(null(body(d))—*• error(cat(“Missing subprogram body: 
(FUNCTION ,id,func-par-spec*,type-mark)) 


” )(namef 

(d))), 


(DX13) DX I SUBPROGBODY subprog-spec decl* seq-stat* opt-id ] (p)(t) 

= let (tg,id,par-spec*,type-mark) = subprog-spec in 
let pi = %(p)(id) in 
(SUBPROGBODY , 
let decl = subprog-spec in 

DX I decl 1 (p)(t),DX I decl* 1 (pi )(t),SSX I seq-stat* 1 (pi )(t),opt-id) 


(DX14) DX I USE dotted-name"*" J (p)(t) — (USE ,dotted-name'*') 


(DX15) DX [ STDEC id type-mark opt-discrete-range | (p)(t) 

= (STDEC ,id,type-mark, 

(null(opt-discrete-range)—► e, 

let (direction,expri ,expr 2 ) = opt-discrete-range in 
(direction,second (EX [ expri \ (p)(t)),second(EX [ expr 2 I (p)(t))))) 


(DX16) DX [[ ITDEC id discrete-range J (p)(t) 

= (ITDEC ,id, 

let (direction,expri ,expr 2 )= discrete-range 
(direction,second (EX [[expri 1 (p)(t)),second(EX [[ expr 2 | (p)(t)))) 

(DX17) DX I COMPONENT id generic-decl* port-decl* ] (p)(t) 

= insert-phaisel-hook 

((COMPONENT ,id,GDX I generic-decl* } (p)(t),PDX I port-decl* ] (p)(t))) 
(decl) 


7.3.12 Concurrent Statements 

(CSXO) CSX I e I (using-configuration)(p)(t)(phasel-hook?) = e 


(CSXl) CSX I conc-stat conc-stat* ]] (using-configuration)(p)(t)(phasel-hook?) 
= consf CSX J conc-stat J (using-configuration)(p)(t)(phasel-hook?), 
CSX [ conc-stat* J (using-configuration)(p)(t)(phasel-hook?)) 


113 



(CSX2) CSX [[ BLOCK id block-header decl* conc-stat* opt-id J (using-configuration)(p)(t)(phasel-hook?) 
= let Pi = %(p)(id) 

and generic-part = hd(block-header) 
and port-part = second(block-header) in 
let generic-decl* = (null(generic-part)^ e, hd(generic-part)) 
and generic-map-aspect = (null(generic-part)—^ e, 

second(generic-part)) 

and port-decl* = (null(port-part)—e, hd(port-part)) 
and port-map-aspect = (null(port-part)-—► s, second(port-part)) in 
let transformed-generic-map = (null(generic-map-aspect)—► e, 

GMX [[ generic-map-aspect ]| (pi)(pi)(t)) 
and transformed-port-map = (null(port-map-aspect)—^ e, 

PMX |[ port-map-aspect ]] (pi)(pi)(t)) in 

(phasel-hook? = tt 
—^ insert-phasel-hook 

(accomplish-generic-and-port-maps 

(transformed-generic-map) (transformed-port-map) 

((BLOCK ,id,DX [ded* | (pi)(t), 

CSX Jconc-stat* | (using-configuration)(pi )(t)(phasel-hook?),opt-id))) 
(conc-stat), 

accomplish-generic-and-port-maps 

(transformed-generic-map) (transformed-port-map) 

((BLOCK ,id,DX [ decl* ] (pi)(t), 

CSX [[ conc-stat* | (using-configuration)(pi )(t)(phasel-hook?),opt-id))) 

(CSX3) CSX [[ PROCESS id ref* decl* seq-stat* opt-id ]] (using-configuration)(p)(t)(phasel-hook?) 

= let Pi = %(p)(id) in 
(phasel-hook? = tt 
—insert-phzisel-hook 

((PROCESS ,id,DX [ decl* I (pi)(t), 
let seq-statf = (null(seq-stat*) 

—► ((WAIT ,(AT ,mk-atmark()),ref*,e,e)), 

(null(ref*)—> seq-stat*, 
append 

(seq-stat*, 

((WAIT ,(AT ,mk-atmark()),ref*,£,£))))) in 
SSX I seq-stat I | (pi )(t),opt-id))(conc-stat), 

(PROCESS ,id,[[decl* ]| (pi)(t), 
let seq-stat* = (null(seq-stat*) 

—► ((WAIT ,(AT ,mk-atmark()),ref*,e,e)), 

(null(ref*)^ seq-stat*, 
append 

(seq-stat*, 

((WAIT ,(AT ,mk-atmark()),rer,£,e))))) in 
SSX If seq-statT ]| (pi )(t),opt-id)) 

(CSX4) CSX I SEL-SIGASSN atmark delay-type id expr ref selected-waveform'*’ ] 
(using-configuration)(p)(t)(phasel-hook?) 

= let expr* = cons(expr, 

collect-expressions-from-selected-waveforms 
(selected-waveform**“)) in 
let ref* = delete-duplicates 

(coIlect-signals-from-expr-list(expr*)(t)(p)(£)) in 
let case-alt'*' = construct-case-alternatives 

(ref)(delay-type)(selected-waveform'*') in 
let case-stat = (CASE ,atmark,expr,case-alt'*') in 
let process-stat = (PROCESS ,id,ref*,e,(case-stat),id) in 


114 



insert-phasel-hook 

( CSX J process-stat J (using-configuration)(p)(t)(ff)){conc-stat) 

(CSX 5 ) CSX |[ COND-SIGASSN atmark delay-type id ref cond-waveform* waveform J 
(using-configuration)(p)(t)(phasel-hook?) 

= let expr* = nconc 

(collect-expressions-from-conditional-waveforms 
(cond-waveform*), 

collect-transaction-expressions(second(waveform))) in 
let ref* = delete-duplicates 

(collect-signals-from-expr-list(expr* )(t)(p)(e:)) in 
(null(cond-waveform*) 

—*> let sig-assn-stat — (SIGASSN ,atmark,delay-type,ref,waveform) in 
let process-stat = (PROCESS ,id,ref*,c,(sig-assn-stat),id) in 
insert-phasel-hook 

( CSX [[ process-stat ]] (using-configuration)(p)(t)(fF)) 

(conc-stat), 

let cond-parf^ = construct-cond-parts 

(ref)(delay-type)(cond-waveform*) 

and else-part = ((SIGASSN ,(AT ,mk-atmark()),delay-type,ref,waveform)) in 
let if-stat = (IF ,atmark,cond-part'*',else-part) in 
let process-stat — (PROCESS ,id,ref*,e,(if-stat),id) in 
insert-phasel-hook 

( CSX [[process-stat J (using^configuration)(p)(t)(ff))(conc-stat)) 


(CSX 6 ) CSX [ COMPINST id ref opt-generic-map-aspect opt-port-map-aLspect | 
(using-configuration)(p)(t)(phasel-hook?) 

= let block-stat = construct-equivalent-nested-block-stat 

(conc-stat )(using-configu ration )(last(rest(p))) 
(last(p)) in 

(hd(block-stat)= UNCONFIGURED-COMPONENT 
—insert-phasel-hook (block-stat) (conc-stat), 
insert-phasel-hook 

(CSX ([ block-stat | (using-configuration)(p)(t)(ff))(conc-stat)) 


7.3,13 Sensitivity Lists 

(SLXO) SLX lie I (p)(t) = £ 

(SLXl) SLX [ref ref* ] (p)(t) = cons(SLX [ ref] {p)(t),SLX [ ref* ] (p)(t)) 

(SLX2) SLX I REF name ] (p)(t) 

= let expr = ref in 

second( EX [[ expr ] (p)(t)) 


7.3,14 Sequential Statements 

(SSXl) SSX [[ seq-stat seq-stat* ] (p)(t) 

= cons( SSX [[ seq-stat | (p)(t),SSX [ seq-stat* ] (p)(t)) 

(SSX 2 ) SSX I NULL atmark ] (p)(t) = (NULL ,atmark) 


115 



(SSX3) SSX I VARASSN atmark ref expr ]] (p)(t) 

= (VARASSN ,atmark, 
let expro = ref in 

second(EX [[ expro ] (p)(t)),second{EX [[ expr | (p)(t))) 

(SSX4) SSX |[ SIGASSN atmark delay-type ref waveform ] (p)(t) 

= (SIGASSN ,atmark,delay-type, 
let expr = ref in 

second(EX |[ expr ] (p)(t)),WX [[ waveform ]| (p)(t)) 

(SSX5) SSX [[ IF atmark cond-part'*’ else-part | (p)(t) 

= let seq-stat* = else-part in 

(IF ,atmark,transform-if(cond-parf*‘)(p)(t),SSX j[ seq-stat* ] (p)(t)) 

transform-if(cond-part* )(p)(t) 

= (null(cond-part*)—*■ e, 

let (expr,seq-stat*) = hd(cond-part*) in 
cons((second(EX [[ expr | (p)(t)),SSX [[ seq-stat* ]] (p)(t)), 
transform-if(tl(cond-part*))(p)(t))) 

(SSX6) SSX [[ CASE atmark expr case-alf*" J (p)(t) 

= (CASE ,atmark,second(EX I expr 1 (p)(t)),AX I case-alt+ } (p)(t)) 

(SSX7) SSX [ LOOP atmark id seq-stat* opt-id ] (p)(t) 

= (LOOP , at mark, id, SSX [seq-stat* J (%(p)(id))(t),opt-id) 

(SSX8) SSX [ WHILE atmark id expr seq-stat* opt-id | (p)(t) 

= (WHILE ,atmark,id,second(EX [ expr J (%(p)(id))(t)), 

SSX ir seq-stat* ] (%(p)(id))(t),opt-id) 

(SSX9) SSX [[ FOR atmark id ref discrete-range seq-stat* opt-id ] (p)(t) 

= (FOR ,atmark,id,second(EX [ ref | (%(p)(id))(t)), 

DRX [discrete-range | (%(p)(id))(t),SSX [seq-stat* ] (%(p)(id))(t),opt-id) 

(SSXIO) SSX [ EXIT atmark opt-dotted-name opt-expr ] (p)(t) 

= (EXIT ,atmark,opt-dotted-name, 
let expr = opt-expr in 
secondf EX [ expr | (p)(t))) 

(SSXll) SSX [CALL atmark ref] (p)(t) 

= (CALL ,atmark, 
let expr = ref in 
second(EX [ expr J (p)(t))) 

(SSX12) SSX [ RETURN atmark opt-expr ] (p)(t) 

= (RETURN ,atmark, 
let expr = opt-expr in 
secondf EX [ expr ] (p)(t))) 

(SSX 13) SSX [ WAIT atmark ref* opt-expri opt-expr 2 ] (p)(t) 

= let expri = opt-expri 

and expr 2 = opt-expr 2 in 

(WAIT ,atmark,MEX [ ref* | (p)(t),second(EX [ expri 1 (p)(t)), 
secondf EX [ expr 2 ] (p)(t))) 


116 



7.3.15 Case Alternatives 

(AXO) AXl[5l(p)(t) = e 

(AXl) AX I case-alt case-alt* | (p)(t) 

= cons(AX [case-alt ] (p)(t),AX [ case-alt* J (p)(t)) 

(AX2) AX [[ CASECHOICE discrete-range+ seq-stat* J (p)(t) 

= (CASECHOICE , DRX [ discrete-range"*^ ]| (p)(t),SSX [seq-stat* ] (p)(t)) 

(AX3) AX I CASEOTHERS seq-stat* | (p)(t) == (CASEOTHERS ,SSX [ seq-stat* } (p)(t)) 


7.3.16 Discrete Ranges 

fPRXO) DRX [[ g I(p)(t) rr € 

(DRXl) DRX [ discrete-range discrete-range* ] (p)(t) 

= consf DRX I discrete-range | (p)(t),DRX [[ discrete-range* J (p)(t)) 

(DRX2) DRX I discrete-range | (p)(t) 

= let (direction,expri jexpra) = discrete-range in 

(direction,second(EX [[ exprj J (p)(t)),second (EX [ expr 2 ]] (p)(t))) 


7.3.17 Waveforms and Transactions 

(WXl) WX I WAVE transaction+ J (p)(t) = (WAVE , TRX [ transaction^ | (p)(t)) 

(TRXl) TRX [ transaction transaction* ] (p)(t) 

= (nuli(transaction*)—► ( TRX [ transaction | (p)(t)), 
let transaction^ = transaction* in 
consf TRX I transaction | (p)(t),TRX | transaction]^ ] (p)(t))) 

(TRX2) TRX [ TRANS expr opt-expr ] (p)(t) 

= (TRANS ,second(EX [[ expr ] (p)(t)), 
let expri = opt-expr in 
second(EX [expri 1 (p)(t))) 


7.3.18 Expressions 

(MEXO) MEX [ £ I (p)(t) = e 

(MEXl) MEX [ ref ref* | (p)(t) = cons(second(EX [ ref ]] (p)(t)),MEX [ ref* ] (p)(t)) 
(EXO) EX [ e I (p)(t) = (void-type-desc(t),£) 

(EXl) EX I FALSE ] (p)(t) = (bool-type-desc(t),(FALSE) ) 

(EX2) EX [ TRUE | (p)(t) = (bool-type-desc(t),(TRUE) ) 

(EX3) EX [ BIT bitUt ] (p)(t) = (bit-type-desc(t),(BIT ,bitlit)) 

(EX4) EX [ NUM constant ] (p)(t) = (int-type-desc(t),(NUM ,constant)) 


117 



(EX5) EX [[ TIME constant time-unit ]] (p)(t) 

= let normalized-constant = (case time-unit 

FS —► N [[ constant | , 

PS —*• 1000 xN [[ constant ]) , 

NS —► lOOOOOOxN I constant | , 

US —► lOOOOOOOOOxN | constant | , 

MS lOOOOOOOOOOOOxN [[constant J , 

SEC lOOOOOOOOOOOOOOOxN [[ constant J , 

MIN ^ 60x(1000000000000000xN [[constant J ), 

HR ^ 3600x(1000000000000000xN [[ constant ] ), 
OTHERWISE 

—> error 

(cat(“Illegal imit name for physical type TIME: 
(time-unit))) in 

(time-type-desc(t),(TIME ,normalized-constant,FS )) 

(EX6) EX [[ CHAR constant J (p)(t) 

= let d = lookup(t)((STANDARD) )(expr) in 
(type(d),(CHAR ,constant)) 

(EXT) EX I BITSTR bit-Ht* 1 (p)(t) = (e,(BITSTR ,bit-lit*)) 

(EX8) EX I STR char-lit* ] (p)(t) = (e,(STR ,char-lit*)) 

(EX9) EX [ REF name ]) (p)(t) = transform-name(name)(£)(e)(p)(t) 

transform-name(name)(w)(astS )(p)(t) 

= (null(w) 

—^ let wi = lookup2(t)(p)(e)(hd(name)) in 
(wi = ^UNBOUND* 

—► error 

(cat(“Unbound identifier in auxiliary semantic function TRANSFORM-NAME: ”) 
($(p)(hd(name)))), 

(second(tmode(wi))=: TYP transform-name(tl(name))(wi )(£)(p)(t), 
transform-name 

(tl(name))(wi )(((SREF ,path(tdesc(wi )),idf(tdesc(wi )))))(p)(t))), 
let d = tdesc(w) 

and tm = tmode(w) in 
let tg = tag(d) in 
(null(name) 

—^ (second(tm)= TYP —► transform-name-aux(*CONVERSION* )(d)(astj), 
transform-name-aux(tg)(d)(astJ)), 
let X = hd(name) in 
(consp(x) 

—► let astj = transform-list(x)(p)(t) in 
(second(tm)= TYP 
—+ transform-name 

(tl(name))(w)((TYPECONV ,hd(astr),%(path(d))(idf(d))))(p)(t), 
second(tm)= OBJ A is-array-tdesc?(d) 

—► transform-name 

(tl(name))(mk-type(tm)(elty(d))) 

(nconc(ast;,((INDEX ,hd(astt)))))(p)(t), 

(second(tm)= OBJ A is-array?(type(d))) 

V (second(tm)€ (REF VAL) A is -array-tdesc?(d)) 
transform-name 
(tl(name)) 

((second(tm)= OBJ 


118 



^ mk-type(tmode{type(d)))(elty(tdesc(type(d)))), 
mk-type(tm)(elty(d)))) 

(nconc(ast;,((INDEX ,hd(a5tj)))))(p)(t), 
transform-name 

(tl(name))(extract-rtype(d)) 

(nconc(astJ,((PARLIST ,asti))))(p)(t)), 

((second(tm)= OBJ A is-record?(type(d))) 

V (second(tm)G (REF VAL) A is-record-tdesc?(d)) 
let di = (second(tm)= OBJ —► tdesc(type(d)), d) in 
let d 2 = lookup-record-field(components(di ))(x) in 
transform-name 

(tl(name))(mk-type(tm)(d 2 ))(nconc(astJ,((SELECTOR ,x)))) 
(P)(t), 

second(tm)= OBJ A is-record-tdesc?(d) 

—> let d 2 = lookup-record-field(components(d))(x) in 
transform-name 

(tl(name))(mk-type(tm)(d 2 ))(nconc(astJ,((SELECTOR ,x)))) 
{p)(t)- 

let W] — lookup-local(x)(%(path(d))(idf(d)))(p)(t) in 
(wi ^UNBOUND* 

—> error 

(cat(“Unknown identifier in fimction TRANSFORM-MAME: ”) 
($(%(path(d))(idf(d)))(x))), 
transform-name 

(tl(name))(wi )(((SREF ,path(tdesc(wi )),idf(tdesc(wi )))))(p) 
(t)))))) 

transform-name-aux(tg)(d)(ast) 

= (case tg 

^OBJECT* (second(type(d)),(REF ,ast)), 

^ENUMELT* ^ (second(type(d)),(ENUMLIT ,idf(d))), 
(^PROCEDURE* ^FUNCTION* ) 

—^ (second(rtype(hd(signatures(d)))), 

(REF ,nconc(ast,((PARLIST ,e))))), 

^CONVERSION* (d,ast), 

^PACKAGE* -- (d,(REF ,ast)), 

OTHERWISE ^ (d,(REF ,ast))) 

transform-list(x)(p)(t) 

= (null(x)--^ e, 

let expr = hd(x) in 

cons(second(EX [[ expr | (p)(t)),transform-list(tl(x))(p)(t))) 


The functions transform-name, transferm-name-aux, and transform-list produce the 
linear form of the basic references discussed above. 

(EXIO) EX I PAGGR expr* 1 (p)(t) 

= (length(expr* )= 1 

—^ let expr = hd(expr*) in 
EX [ expr | (p)(t), 

(e,(PAGGR ,ex-paggr(expr*)(p)(t)))) 


(EXll) EX J unary-op expr J (p)(t) 

= let (d,e) = EX | expr | (p)(t) in 


119 



(case unary-op 
PLUS — (d,e), 

NOT — (d,(scalar-op(unary-op){d),e)), 

NEG (d,(sca]ar-op(unary-op)(d),e)), 

ABS —► (d,(scalar-op(unary-op)(d),e)), 

OTHERWISE 
—error 

(cat(“Unrecognized Stage 4 VHDL unary operator: ”)(unary-op))) 

(EX 12 ) EX I binary-op expri expr 2 ] (p)(t) 

= let (di,ei) = EX 1[ expn I (p)(t) in 
let (d 2 ,e 2 ) = EX H expr 2 I (p)(t) in 
(di ,(scalar-op(binary-op)(di), 61 , 62 )) 

(EX13) EX [relational-op expri expr 2 | (p)(t) 

= let (di,ei) = M [expri ] (p)(t) in 
let (d 2 ,e 2 ) = EX [ expr 2 ] (p)(t) in 
(bool-type-desc(t),(scalar-op(relational-op)(di ),ei , 62 )) 
scalar-op(op)(d) 

= (is-bit-tdesc?(d)V is-bitvector-tdesc?(d)—► bits-op(op), 
is-real-tdesc?(d)—► real-op(op), 
op) 

bits-op(op) 

(c 2 ise op 

EQ — EQ , 

NE — NE , 

LT — LT , 

LE - LE , 

GT — GT , 

GE ^ GE , 

NOT -- BNOT , 

AND -- BAND , 

NAND ^ BNAND , 

OR ^ BOR, 

NOR ^ BNOR, 

XOR ^ BXOR , 

OTHERWISE —► error(cat(Undefined bitwise operator: )(op))) 
real-op(op) 

= (case op 

EQ -- EQ , 

NE ^ NE , 

LT - RLT , 

LE — RLE , 

GT ^ RGT, 

GE ^ RGE, 

NEG ^ RNEG, 

ABS ^ RABS , 

ADD - RPLUS , 

SUB ^ RMINUS , 

MUL RTIMES , 

DIV ^ RDIV , 

EXP ^ REXPT , 

OTHERWISE —► error(cat(Undefined ‘real’ operator: )(op))) 

The functions scalar-op, bits-op, and real-op do overload resolution between INTEGER, 
BIT, and REAL operators. 

(RXl) RX [expr ] (p)(t) = EX | expr | (p)(t) 


120 



8 Phase 2: State Delta Generation 


If Phase 1 of the Stage 4 VHDL translator completes without error, then after the interphase 
abstract syntax tree transformation has been accomplished (see Section 7), Phase 2, state 
delta generation, can proceed. Several kinds of checks have already been performed on the 
hardware description in Phase 1, the most significant being the detection of missing prior 
declarations of items such as variables and labels, the improper use of names, and static 
type checking. Thus, these checks do not have to be duplicated in Phase 2. 

Phase 2 receives from Phase 1 the transformed abstract syntax tree (AST) for the hardware 
description, together with the tree-structured environment (TSE) — a complete record of 
the name/attribute associations corresponding to the hardware description’s declarations 
and whose structure reflects that of the description. The TSE remains fixed throughout 
Phase 2. It contains all definitions needed to execute its corresponding Stage 4 VHDL 
hardware description, and Phase 1 has ensured that only that portion of the TSE visible at 
any given textual point of the description can be accessed during Phase 2. With the aid of 
the TSE, Phase 2 incrementally generates SDVS Simplifier assertions and state deltas. 


8.1 Phase 2 Semantic Domains and Functions 

The formal description of Phase 2 translation consists of semantic domains and semantic 
/mictions, the latter being functions from syntactic to semantic domains. Compound se¬ 
mantic domains are defined in terms of primitive semantic domains. Similarly, primitive 
semantic functions are unspecified (their definitions being understood implicitly) and the 
remaining semantic functions are defined (by syntactic cases) via semantic equations. 

The principal Phase 2 semantic functions (and corresponding Stage 4 VHDL language con¬ 
structs to which they assign meanings) are: DF (design files), DU (design units). Cl (con¬ 
text items), LU (bbrary-units), CF (configuration declarations), EN (entity declarations), 
AR (architecture bodies), D (declarations), CS (concurrent statements), SS (sequential 
statements), W (waveforms), TRM and TR (transactions), ME and MR (expression 
lists), E and R (expressions), T (expression types), B (bit literals), and N (numeric liter¬ 
als). 

Each of the principal semantic functions requires an appropriate syntactic argument — an 
abstract syntactic object (tree) produced by the interphase abstract syntax tree transforma¬ 
tion (see Section 7). Most of the semantic functions take (at least) the following additional 
arguments: 

• the tree-structured environment generated in Phase 1; 

• a path, indicating the currently “visible” portion of the TSE; 

• a continuation, specifying which Phase 2 semantic function to invoke next; 

• a universe structure; and 

• an execution stack. 


121 



In the absence of errors, the Phase 2 semantic functions return a list of Simplifier assertions 
and state deltas. Moreover, E and R also return a translated expression and list of guard 
formulas. Guard formulas are inserted in the precondition of generated state deltas to 
ensure that certain conditions are met in the proof in which the state deltas appear. For 
example, if an array name is indexed by an expression, then Phase 2 generates a guard 
formula asserting that the index value is not out of range. 

The execution state manipulated by Phase 2 translation involves two components: a universe 
structure (see Section 8.2.2) and an execution stack (see Section 8.2.3). An analogy with 
conventional denotational semantics can be applied: the execution state corresponds to the 
store, translated expressions and guard formulas correspond to expression values, and state 
delta/assertion lists correspond to non-error final answers. 

When state deltas are generated by a semantic function, the continuation that is input to 
that function plays a sbghtly unconventional role: the result of applying to an execution 
state the continuation, or other continuations derived from the continuation, is appended to 
the postconditions of the generated state deltas. In the absence of errors, the item appended 
represents a list of state deltas. Such a continuation is evaluated and applied only when the 
state delta in whose postcondition it appears is appbed. 

For example, an IF statement having no ELSE part generates two state deltas: one for the 
case in which its condition evaluates to true, the other for the false case. The continuation 
for the true case represents the execution of the body of the IF statement succeeded by 
the execution of the statement following the IF statement. The continuation for the false 
case skips the body, and proceeds directly to the statement following the IF statement. 
Whichever of these two state deltas is applied determines which continuation is evaluated 
and applied to an execution state, and therefore which additional state deltas are subse¬ 
quently generated. 


8.1.1 Phase 2 Semantic Domains 

The semantic domains and function types for Phase 2 of the Stage 4 VHDL translator are 
as follows. 

Primitive Semantic Domains 


Bool = 
Bit = 

Char = 
n : N = 

{FALSE, TRUE} 

{(BS 0 1), (BS 1 1)} 

{(CHAR 0), ..(CHAR 127)} 
{0, 1,2,...} 

id : Id 
Sysid 



Simplifier propositional (boolean) constants 
Simplifier bit constants (length 1 bitstrings) 
Simplifier character constants 
Simplifier natural number constants 

identifiers 

system-generated identifiers (disjoint from Id) 


ast : ASyn 
t : TEnv 
d : Desc 


122 


abstract syntax trees 
tree-structured environments (TSEs) 
descriptors (see Section 6.2) 


V : UStruct 
stk : Stk 

e : TExpr 
trans : TTrans 
f, guard : GForm 

sd : SD 
Assert 

Error 

Compound Semantic Domains 

elbl : Elbl == Id + Sysid 

p, q: Path = Elbl* 

qname: Name Elbl (. Elbl)* 

d : Dv = Desc 

r : Env = Id ^ (Dv + {*UNBOUND*}) 


universe structures (see Section 8.2.2) 
execution stacks (see Section 8.2.3) 

translated expressions 
translated transactions 
lists of guard formulas 

state deltas 

SDVS Simplifier assertions 
error messages 


TSE edge labels 
TSE paths 
qualified names 

denotable values (descriptors) 
environments 


Tmode = {PATH} X Id* + type modes 

({CONST, VAR, SIG, DUMMY) x 
{VAL, OUT, REF, OBJ, ACC, TYP}) 


w : Type = Tmode x Desc 

u : Dc == UStruct ^ Stk Ans 
c : Sc = Dc 

k : Ec = (TExpr X GForm) —^ Sc 
h : Me = (TExpr* x GForm*) Sc 
wave-cont : Wc = (TTrans* x GForm*) ^ Sc 
trans-cont : Tc = (TTrans x GForm) ^ Sc 

Ans = (SD + Assert)* + Error 


types 

declaration Sz concurrent statement continuations 

sequential statement continuations 

expression continuations 

expression list continuations 

waveform continuations 

transaction continuations 

final answers 


8.1.2 Phase 2 Semantic Functions 

The semantic functions for Phase 2 of the Stage 4 VHDL translator are as follows. 

DF : Design —► TEnv ^ Id ^ Ans design file dynamic semantics 

DU : DUnit* —^ Asyn ^ TEnv Path 

Dc —^ Dc design unit dynamic semantics 


123 


Cl : CItem* TEnv Path ^ Dc Dc 

LU : LUnit —^ Asyn ^ TEnv ^ Path 

Dc ^ Dc 

CF : Config TEnv Path Dc Dc 

EN : Ent TEnv ^ Path ^ Dc Dc 

AR : Arch ^ TEnv Path ^ Dc Dc 

D : Dec’^ TEnv —^ Path ^ Dc Dc 

CS : CStaf" —TEnv Path —^ Dc ^ Dc 

SS : SStat* —TEnv —^ Path Sc ^ Sc 

W : Wave TEnv ^ Path Wc ^ Sc 

TRM : Trans* ^ TEnv Path Wc ^ Sc 
TR : Trans ^ TEnv ^ Path Tc ^ Sc 

ME : Expr* —► TEnv —> Path Me -> Sc 
MR : Expr* ^ TEnv —> Path Me Sc 
E : Expr ^ TEnv ^ Path Ec ^ Sc 

R : Expr —> TEnv ^ Path ^ Ec Sc 

T : Expr ^ TEnv ^ Path Desc 

B : BitLit ^ Bit 

N : NumLit ^ N 


context item dynamic semantics 

library unit dynamic semantics 
configuration declaration dynamic semantics 
entity declaration dynamic semantics 
architecture body dynamic semantics 
declaration dynamic semantics 
concurrent statement dynamic semantics 
sequential statement dynamic semantics 
waveform dynamic semantics 
transaction list dynamic semantics 
transaction dynamic semantics 
expression list dynamic semantics {Uvalues) 
expression list dynamic semantics {revalues) 
expression dynamic semantics {l-values) 
expression dynamic semantics (r-t;a/ue5) 
expression types 

bit values of bit literals (primitive) 
integer values of numeric literals (primitive) 


124 



8.2 Phase 2 Execution State 


As mentioned in Section 8.1, the execution state manipulated by Phase 2 translation consists 
of a universe structure and an execution stack. The purpose of this section is to elucidate 
the nature and role of these aspects of the execution state. 


8.2.1 Unique Name Qualification 

Except for quantification, the language of state deltas has no scoping, i.e., it is “flat.” Even 
with quantification, the state deltas generated by the Stage 4 VHDL translator certainly 
do not have a scoping structure that naturally parallels the scopes of their corresponding 
Stage 4 VHDL hardware description. Furthermore, even if there were such a correspondence 
between source (Stage 4 VHDL) and target (state deltas) scopes, it would still be convenient 
to generate unique names for the SDVS user to use in proofs. 

For example, a PROCESS statement may contain a declaration of a variable x of the same 
name as a signal in the enclosing architecture body. The inner instance of x can be distin¬ 
guished from the outer instance by prefixing or qualifying it with the name (user-supplied 
or system-generated) of the process in which the inner instance is declared. We shall call 
such a qualified name, derived from the static structure of the Stage 4 VHDL hardware 
description, a statically uniquely qualified name or SUQN. At the beginning of Phase 2 
translation (after the interphase AST transformation — see Section 7), the SUQN of any 
object (for which such a name makes sense) is recorded in the qid field associated with the 
object in the TSE. 

Another important kind of unique name quaUfication is based on the dynamic execution 
of a Stage 4 VHDL description. A program unit can be reentered, either by repetition or 
recursion, and local declarations in the reentered program will be re-elaborated, creating 
new dynamic instances of entities that cannot be distinguished on the basis of static program 
structure. In this case new names that are distinct dynamic instances of the same statically 
uniquely qualified name are sufficient to enable the SDVS user to distinguish all instances 
of names for use in proofs. The separate dynamic instances of a name are indicated by 
appending !n to it, where n is a dynamic instance index for that name (e.g. a.x, a.x!2, 
a.x!3, ..., where a.xll is simply denoted a.x). These names are called dynamically uniquely 
qualified names (DUQNs). 

Only statically and dynamically uniquely qualified names appear in the state deltats gener¬ 
ated by Phase 2 translation. 


8.2.2 Universe Structure for Unique Dynamic Naming 

Given that there may be several dynamic instances of the same SUQN in a Stage 4 VHDL 
hardware description, Phase 2 translation employs a mechanism called a universe structure 
(together with functions that access and manipulate it) to manage the creation of new 
dynamic instances of each distinct SUQN, as well as to ensure that the correct dynamic 
instance of each SUQN is available at any given time. 



A universe structure consists of four components: 


universe name : 

The name of the current universe. A universe name has the form z\u\n, where z is 
the name of the main program and n is the current universe’s ordinal number (n - 
1 , 2 ,... ). 


universe counter : 

The current universe’s ordinal number. 

universe stack : 

A stack of universe names used to save and restore prior universes in accordance with 
the changes of environment in a Stage 4 VHDL hardware description. 

universe variables : 

The current universe’s environment of statically and dynamically uniquely qualified 
names. This is a list of entries of the form (SUQN, ordinal-number, ordinal- 
stack), one for each distinct SUQN. The ordinal number denotes the most recently 
created dynamic instance of that SUQN. The ordinal stack is a stack of this SUQN’s 
ordinal numbers, whose top element denotes the current dynamic instance of this 
SUQN. This stack is used to save and restore prior dynamic instances of this SUQN in 
accordance with the changes of environment in a Stage 4 VHDL hardware description. 


mk-initial-universe(z) 

= let uname = catenate(z,“\u”,l) in 

make-universe-data{uiiame,l,(uname),((z,l )))) 

make-universe-data(uname,ucounter,ustack,uvars) 

= (uname,ucounter,ustack,uvars) 

universe-name(v) = hd(v) 

universe-counter(v) = second(v) 

universe-stack(v) = third(v) 

universe-vars(v) = fourth(v) 

push-universe(v,z,suqn*) 

= let ucounter = l+universe-counter(v) in 
let uname = catenate(z,“\u”,ucounter) in 
let ustack = cons(uname,universe»stack(v)) in 
make-universe-data 

(uname,ucounter,ustack,push-universe-vars(suqn*,universe-vars(v))) 

push-universe-vars(suqn* ,vars) 

= (null(suqn*)—+ vars, 

let suqn = hd(suqn*) in 
let v = assoc(suqn,vars) in 

(null(v)—► push-uni verse-vars(tl(suqn* ),cons(init-var(suqn),vars)), 
push-universe-vars(tl(suqn*),cons(push-var(v), vars)))) 


126 




push-var(v) 

= let n = next-var(second(v)) in 
(hd(v),n,cons(n,third(v))) 

next-var(n) 

= (numberp(n)—^ n+1, 

(symbolp(!!)—»“ mk-exp2(ADD 
let m = third(n) in 

{nuraberp(m)—► mk-exp2(ADD ,second(n),md-l), 
mk-exp2(ADD ,second(n),mk-exp2(ADD ,m,l))))) 

init-var(suqn) = (suqn,l,(l)) 

pop-universe(v)(suqn*) 

= let ustack = tl(universe-stack(v)) in 
let unaine = hd(ustack) in 
make-universe-data 

(uname,universe-counter(v), ustack, 
pop-universe-vars(suqn*)(universe-vars(v))) 

pop-universe-vars(suqn* ,vars) 

= (null(suqn*)—► vars, 

let suqn = hd(suqn*) in 
let V = assoc(suqn,vars) in 
pop-universe-vars( tl(suqn* ),cons(pop-var(v),vars))) 

pop-var(v) = (hd(v),second(v),tl(third(v))) 

get-qualified-ids(suqn* )(v) 

= (nuil(suqn*)—*■ e, 

cons(qualified-id(hd(suqn* ))(v),get-qualified-ids(tl(suqn* ))(v))) 

qualified-id(suqn)(v) 

= let vars = universe-vars(v) in 

let suqn-triple = ajssoc(suqn,vars) in 
(suqn-triple 

—*> let n = hd(third(suqn-triple)) in 
name-qucilified-id(suqn)(n), 
name-qualified-id(suqn)(l)) 

name-qualified-id (suqn )(n) 

= (new-declarations()—^ (PLACELEMENT ,suqn,n), 

(n = 1 —suqn, catenate(suqn,“!”,n))) 

Currently, the only part of the universe structure that is actually used for dynamic name 
qualification is the universe variables component. Each time a program unit that may 
have a declarative part (packages, entities, architectures, processes, subprogram bodies) is 
entered, the current universe is saved and an updated universe structure is created by push- 
universe. The universe structure’s counter (ordinal) is incremented by one, a corresponding 
new universe name is created, and the old universe name is pushed onto the universe stack. 
In the universe variables component of the universe structure, the triple for each SUQN 
corresponding to each name declared in the unit’s declarative part (except types) is updated: 
the value of its ordinal is incremented by one and this new ordinal value is pushed onto the 
ordinal stack of the SUQN’s triple. Whenever any SUQN needs to be dynamically uniquely 



qualified, the top element of its ordinal stack is used to find the index of the current dynamic 
instance of that SUQN. 

When such a program unit is exited, pop-universe restores the universe name by popping 
it from the universe stack. The ordinal stack of the triple of the SUQN of each (non-type) 
name declared in this unit is popped, restoring the current dynamic qualification of that 
SUQN to a former value. 

The functions get-qualifled-ids, qualified-id, and name-qualified-id accomplish the 
dynamic qualification of SUQNs relative to a universe structure. 


8.2.3 Execution Stack 

The elements of the execution stack are descriptors that contain information to control nor¬ 
mal returns and exits from program units, as well as the undeclaration of objects, packages, 
subprograms, and formal parameters. 

There are several kinds of execution stack descriptors, and more detailed explanations of 
their roles will be provided at the points in the semantics where they are used. For now, we 
note that each descriptor has four components; an identifying tag-, an identifier, identifier 
sequence, or fully qualified name that associates the descriptor with some program unit; a 
path that may replace the current path to effect a change of environment; and a function, 
which may be a continuation or continuation transformer, that will effect a change of control 
and environment corresponding to the descriptor’s purpose. 

stack bottom : 

< *STKBOTTOM*, id, c, c > 

This descriptor is the execution stack “bottom marker,” used to terminate model 
execution and to prevent execution stack underflow. The identifier id is the name of 
the Stage 4 VHDL design file. 

package body exit : 

< *PACKAGE-BODY-EXIT*, id, p, u > 

This descriptor is pushed onto the execution stack just prior to the elaboration of 
a package body. The identifier id is the package name, and u: Dc is a declaration 
continuation that will continue execution (most likely elaboration) at the package 
body’s successor in the environment denoted by p. 

subprogram return : 

< ’►SUBPROGRAM-RETURN’^, id, p, c > 

This descriptor is pushed onto the execution stack after a subprogram (procedure 
or function) is entered, but just before the elaboration of the subprogram’s local 
declarations. The identifier id is the subprogram name, and c: Sc is a continuation 
that will continue execution at the successor of the subprogram call in the environment 
denoted by p. 


128 



loop exit : 


< **^LOOP-EXIT*, id, p, c > 

This descriptor is pushed onto the execution stack when a loop statement (LOOP, 
WHILE, or FOR) is entered. The identifier id is the loop label, and c: Sc is a continuation 
that will continue execution at the loop’s successor in the environment denoted by p. 

block exit : 

< *BLOCK-EXIT*, id, p, c> 

This descriptor is pushed onto the execution stack just before the elaboration of a FOR 
loop’s iteration parameter, which implicitly establishes a block scope. The identifier 
id is the FOR loop label, and c: Sc is a continuation that will continue execution at 
the FOR loop’s successor statement in the environment denoted by p. 

begin marker : 

< *BEGIN*, id, p, c> 

This descriptor is pushed onto the execution stack immediately after the local declara¬ 
tions of a subprogram, or the iteration parameter of a FOR loop, have been elaborated. 

undeclaration : 

< *UNDECLARE*, id+, p, g > 

This descriptor, pushed onto the execution stack when a subprogram is called, enables 
the eventual explicit undeclaration (upon subprogram exit) of the subprogram’s for¬ 
mal parameters and other locally declared objects. The identifier list id"^ names the 
objects to be undeclared, and g: Sc ^ Sc is a continuation transformer which, after 
carrying out the explicit undeclaration specified in g (thereby popping this *UNDE- 
CLARE* descriptor from the execution stack), continues execution by means of its 
continuation argument. 


129 



8.3 Special Functions 


Certain functions appearing in the semantic specification of Phase 2 translation are not 
defined denotationally, for either of two reasons: (1) their denotational description is too 
cumbersome or not well understood, or (2) they are used to construct SDVS-dependent 
representations of expressions or formulas. 

These functions, implemented directly in Common Lisp, are described below. 


8.3.1 Operational Semantic Functions 

To understand Phase 2 translation, it is important to recognize that in defining the seman¬ 
tics of the VHDL simulation cycle, the VHDL translator involves a significant operational 
component. This is to be distinguished from the semantics of sequential statements within 
processes, which the translator defines in a primarily denotational manner. 

We are referring here to our strategy, explained in Section 2, of designing aspects of a 
simulator kernel into the Stage 4 VHDL translator. After application of the state deltas 
specifying the behavior of one execution cycle for the active processes, the translator is 
responsible for: 

• determining the next VHDL clock time at which a driver becomes active or a process 
resumes; 

• advancing the SDVS state to this new time; and 

• generating the state delta that specifies the next sequential statement in the first 
resuming process for the new execution cycle. 

After a given resuming process suspends, its continuation is the textually next resuming 
process. 

It is the internal translator machinery to perform these tasks that is operationally defined 
— much of it embodied in a portion of the translator that is directly coded in Common Lisp, 
rather than described by semantic equations. The names of the Common Lisp functions 
serving this purpose are listed below. 

find-configuration-abstract-syntax 

make-vhdl-process-elaborate 

make-vhdl-begin-model-execution 

make-vhdl-try-resume-next-process 

make-vhdl-process-suspend 

find-signal-structure 

name-driver 


130 



init-scalar-signal 

init-array-signal-to 

init-array-signal-downto 

mk-element-waves-aux 

get-loop-enum-param-vals 

eval-expr 


8.3.2 Constructing State Deltas 

The construction of state deltas is specified via functions mk-sd(z)(pre, comod, mod, 
post) and mk-sd-decl(z)(pre, comod, mod, post), which take five arguments: the 
design file name z (if p is the current path, this is always hd(p)) and representations of 
the precondition, comodification list, modification list, and postcondition of the state delta 
to be constructed. 

These functions are used to represent the construction of state deltas without specifying 
their exact representation, which is SDVS-dependent and not given here. The pre- and 
postconditions of a state delta are lists of formulas, each of which represents a formula 
that is the logical conjunction of the formulas in this list. If the precondition and comod 
list arguments of mk-sd and mk-sd-decl are €, then the precondition and comod list of 
the constructed state delta are (TRUE) and (ALL), respectively. Otherwise, the given 
arguments are used directly in the state delta. The postcondition may contain a state delta, 
which is usually represented as a statement continuation applied to an execution stack. 

mk-sd and mk-sd-decl are almost the same, the only difference being that a state delta 
created by mk-sd-decl is given a special tag that identifies its association with declaration 
elaboration rather than statement execution. 

For technical reasons, the comod list of every state delta is (ALL) and the mod list of every 
state delta must be nonempty. To ensure that a state delta’s mod list is never empty, mk- 
sd(z)( ... ) will always prefix z\pc to its mod list argument, where z\pc is a unique place 
(represented by a system identifier) in which z is the name of the Stage 4 VHDL hardware 
description being translated. This unique place is the name of a program counter whose 
value implicitly changes when any state delta is applied. This program counter place does 
not make any other kind of appearance in a translated Stage 4 VHDL hardware description. 

The notation of state deltas requires that certain symbols sometimes be prefixed to uniquely 
qualified names: the dot (.) and pound {jj) symbols. The functions dot and pound, 
applied to uniquely qualified names, accomplish this. 

dot(placename) — (DOT ,placenaine) 
pound(placename) = (POUND ,placename) 

Finally, the two functions fixed-characterized-sds and subst-vars are employed by the 
Phase 2 semantics of procedure calls to implement the SDVS offline characterization mech¬ 
anism [20, 21], which will be incorporated in Stage 4 VHDL. 


131 



8.3.3 Error Reporting 


The few kinds of errors that can occur in Phase 2 are reported by the functions impl-error 
and execution-error. 

The function impl-error is used, for example, to report invalid arguments passed to the 
low-level utility functions mk-scalar-rel, mk-expl, and mk-exp2, although this should 
never occur. 

The function execution-error is used to report execution errors such as an empty execution 
stack, although again, such errors should never occur if Phase 1 has done its job. 


132 



8.4 Phase 2 Semantic Equations 

This section constitutes the heart of the present report. It documents the semantic equations 
and auxiliary semantic functions in terms of which Phase 2 of the Stage 4 VHDL translator 
— state delta generation — is specified denotationally. 


8.4.1 Stage 4 VHDL Design Files 

(DFl) DF J DESIGN-FILE id design-unit"^ J (t)(using-configuration) 

= let po = %{£)(id) 

and configuration-ast — (null(using-configuration)—*- e, 

find-configuration-abstract-syntax 

(design-unit"*" )(using-configuration)) in 

let V = mk-initial-universe(id) 

and stk = (<*STKBOTTOM* ,id,€,£>) in 
(nik-disjoint(id,(dot(id))), 

mk-cover(dot(id),(catenate(id,“\pc”),VHDLTIME , 

VHDLTIME_PREVIOUS )), 
mk-scalar-decl(VHDLTIME ,(TYPE VHDLTIME) ), 
mk-scalar-decl(VHDLTIME_PREVIOUS ,(TYPE VHDLTIME) ), 
mk-rel(vhdltime-type-desc(t))((EQ ,dot(VHDLTIME ),mk-vhdltime( 0 )( 0 ))), 
mk-rel 

(vhdltime-type-desc(t))((EQ ,dot(VHDLTIME_PREVIOUS ),mk-vhdltinie( 0 )( 0 ))), 
mk-decl-sd(id)(£)(e:)(e)(ui (v)(stk))) 
where 
ui = Av,stk. 

DU [[ design-unit"*" | (configuration-ast)(t)(po)(u 2 )(v)(stk) 
where U 2 = Av,stk.block-exit(v)(stk) 

mk-disjoint(id,lst) = cons(ALLDISJOINT ,cons(id,lst)) 

nik-cover(id,lst) = cons(COVERING ,cons(id,lst)) 

iTik-scalar-decl(placename,place-type) = (DECLARE ,placename,place-type) 

vhdltime-type-desc(t) = t((STANDARD) )(VHDLTIME ) 

mk-rel(d)(op,ei , 62 ) 

= let tg — tag(d) in 
(case tg 

(*BOOL* *BIT* ♦INT* *REAL* ^’^TIME* ^VHDLTIME* ,*ENUMTYPE* *VOID=^ ,*POLY* ) 
—*■ mk-scalar-rel(tg)((op,ei , 62 )), 

^SUBTYPE’*' mk-scalar-rel(tag(base-type(d)))((op,ei , 62 )), 

*INT_TYPE* mk-scalar-rel(tag(parent-type(d)))((op,ei, 62 )), 

*WAVE* ^ (EQ ,ei,e2), 

*ARRAYTYPE* 

—+ (is-bitvector-tdesc?(d) 

(case op 
EQ 

—*- (is-constant-bitvector?(ei )A is-constant-bitvector?(e 2 ) 

- (EQ ,cons(USCONC ,ei),cons(USCONC , 62 )), 
is-constant-bitvector?(e 2 )—*■ (EQ ,ei,cons(USCONC ,€ 2 )), 
is-constant-bitvector?(ei)—► (EQ ,cons(USCONC ,ei),e 2 ), 

(EQ , 61 , 62 )), 

NE 


133 



—^ (is-constant-bitvector?(ei )a is-constant-bitvector?(e2) 

— (NEQ ,cons(USCONC ,ei ),cons(USCONC ,62)), 
is-constant-bitvector?(e2)-^ (NEQ ,ei,cons(USCONC ,62)), 
is-constant-bitvector?(ei)—*■ (NEQ ,cons(USCONC ,ei),e2), 
(NEQ ,61,62)), 

LT 

- (EQ ,(BS ,1,1), 

(is-constant-bitv6ctor?(6i )A is-constant-bitv6ctor?(e2) 

^ (USLSS ,cons(USCONC ,ei),cons(USCONC ,62)), 
is-constant-bitvector?(e2 )—► (USLSS ,ei ,cons(USCONC .62)). 
is-constaiit-bitvector?(ei)—> (USLSS ,cons(USCONC ,61),62), 
(USLSS ,61,62))), 

LE 

(EQ ,(BS ,1,1), 

(is-constant-bitvector?(ei )a is-constant-bitvector?(e2) 

- (USLEQ ,cons(USCONC ,ei),cons(USCONC ,62)), 
is-constant-bitvector?(e2)—► (USLEQ ,ei,cons(USCONC ,62)), 
is-constant-bitvector?(ei)—+ (USLEQ ,cons(USCONC ,ei),62), 
(USLEQ ,61,62))), 

GT 

-(EQ,(BS,1,1), 

(is-constant-bitvector?(6i )a is-constant-bitv6ctor?(e2) 

-- (USGTR ,cons(USCONC ,ei),cons(USCONC ,62)), 
is-constant-bitvector?(e2)—♦ (USGTR ,ei,cons(USCONC ,62)), 
is-constant-bitvector?(ei)—^ (USGTR ,cons(USCONC ,ei),e2), 
(USGTR ,61,62))), 

GE 

-(EQ,(BS,1,1), 

(is-constant-bitvector?(ei )A is-constant-bitvector?(e2) 

(USGEQ ,cons(USCONC ,ei),cons(USCONC ,62)), 
is-constant-bitvector?(e2)—► (USGEQ ,61 ,cons(USCONC ,62)), 
is-constant-bitvector?(ei)—^ (USGEQ ,cons(USCONC ,61),62), 
(USGEQ ,61,62))), 

OTHERWISE —♦ impl-6rror( “Shouldn't happen!”)), 
is-string*tdesc? (d) 

—► (case op 

EQ 

(is-constant-string?(ei )A is-constant-strmg?(e2) 

—+ (EQ ,cons(ACONC ,ei),cons(ACONC ,62)), 
is-constant-string?(e2)—► (EQ ,ei ,cons(ACONC .62)). 
is-constant-string?(ei)—*^ (EQ ,cons(ACONC ,ei),e2), 

(EQ ,61,62)), 

NE 

—► (is-constant-string?(ei )A is-constant-stnng?(e2) 

-- (NEQ ,cons(ACONC ,ei),cons(ACONC ,62)), 
is-constant-string?(e2)^ (NEQ ,ei,cons(ACONC ,62)), 
is-constant-string?(ei)—^ (NEQ ,cons(ACONC ,ei),e2), 

(NEQ ,61,62)), 

OTHERWISE —► impl-error( “Shouldn't happen!”)), 

(case op 

EQ 

—► (dotted-expr-p(e2)—► (EQ ,61,62), impl-error(“Shouldn't happen!”)), 

NE 

—► (dotted-expr-p(e2)—► (NEQ ,61,62), 
impl-error( “Shouldn' t happen! ”)), 

OTHERWISE — irapl-error( “Shouldn't happen!”))), 
♦RECORDTYPE* 


134 



^ (dotted-expr-p(e2)^ (EQ ,ei,62), impl-error(“ShouldnH happen!”)), 
OTHERWISE-^ impl-error(‘‘Shouldn’t happen!”)) 

is-constant-bitvector?(expr*) 

— null(expr*) 

V (consp(expr*) 

A let expri = hd(expr*) in 

consp(expri )A hd(expri )= BS ) 

is-constant-string?(expr*) 

= null{expr*) 

V (consp(expr*) 

A let expri = hd(expr*) in 

consp(expri )A hd(expri)= CHAR ) 

dotted-expr-p(expr) = consp(expr)A hd(expr)= DOT 

mk-sca]ar~rel(type-tag)(reIational-op,el,e 2 ) 

= (case type-tag 

*BOOL* 

—► (case relational-op 

EQ —^ mk-bool-eq(type-tag,el,e 2 ), 

NE —► mk-bool-neq(type-tag,el,e 2 ), 

LT ^ (AND ,(EQ ,el,FALSE ),(EQ ,e 2 ,TRUE )), 

LE — (IMPLIES ,el,e 2 ), 

GT ^ (AND ,(EQ ,el,TRUE ),(EQ ,e 2 ,FALSE )), 

GE -- (IMPLIES ,e 2 ,el), 

OTHERWISE 

impl-error 

(“Unrecognized Stage 4 VHDL BOOLEAN relational operator: "a” 
relational-op)), 

*BIT^ 

—► (case relationaJ-op 

EQ ^ (EQ ,el,e 2 ), 

NE (NEQ ,el,e 2 ), 

LT ^ (EQ ,(USLSS ,el,e 2 ),(BS , 1 , 1 )), 

LE ^ (EQ ,(USLEQ ,el,e 2 ),(BS , 1 , 1 )), 

GT - (EQ ,(USGTR ,el,e 2 ),(BS , 1 , 1 )), 

GE (EQ ,(USGEQ ,el,e 2 ),(BS , 1 , 1 )), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 4 VHDL BIT relational operator: “a”, 
relational-op)), 

(*INT* ,*TIME* ) 

—► (case relational-op 

EQ ^ (EQ ,el,e 2 ), 

NE (NEQ ,el,e 2 ), 

LT ^ (LT ,el,e 2 ), 

LE — (LE ,el,e 2 ), 

GT ^ (GT ,el,e 2 ), 

GE ^ (GE ,el,e 2 ), 

OTHERWISE 
—+ impl-error 

(“Unrecognized Stage 4 VHDL INTEGER relational operator: ~a” 
relational-op)), 

*VHDLTIME* 

—(case relational-op 


135 



EQ — (EQ ,el,e2), 

NE- (NEQ ,el,e2), 

LT - (TIMELT ,el,e2), 

LE (TIMELE ,el,e2), 

GT — (TIMEGT ,el,e2), 

GE ^ (TIMEGE ,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 4 VHDL VHDLTIHE relational operator: “"a”, 
relational-op)), 

*REAL* 

—► (case relational-op 

EQ ^ (EQ ,el,e2), 

NE (NEQ ,el,e2), 

(RLT ,RLE ,RGT ,RGE ) —► (relational-op,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 4 VHDL REAL relational operator: ~a”, 
relational-op)), 

*ENUMTYPE* 

(case relational-op 
EQ ^ (EQ ,el,e2), 

NE - (NEQ ,el,e2), 

LT (ELT ,el,e2), 

LE ^ (ELE ,el,e2), 

GT - (EGT ,el,e2), 

GE ^ (EGE ,el,e2), 

PRED - (EPRED ,el,e2), 

SUCC ^ (ESUCC ,el,e2), 

OTHERWISE 
—► impl-error 

(“Unrecognized Stage 4 VHDL ENUMERATION relational operator: ~a'\ 
relational-op)), 

*VOID* 

(case relational-op 
EQ ^ (EQ ,el,e2), 

NE ^ (NEQ ,el,e2), 

OTHERWISE 
—^ impl-error 

(“Unrecognized Stage 4 VHDL VOID relational operator: ~a”, 
relational-op)), 

*POLY* 

—► (case relational-op 

EQ (EQ ,el,e2), 

NE ^ (NEQ ,el,e2), 

OTHERWISE 
—+ impl-error 

(“Unrecognized Stage 4 VHDL POLYMORPHIC relational operator: ~a”, 
relational-op)), 

OTHERWISEimpl-error(“Unsupported Stage 4 VHDL basic type "a.”,type-tag)) 

mk-bool-eq(type-tag,el ,e2) 

= (type-tag = *BOOL* 

—► (simple-term(el) 

-- (simple-term(e2)^ (EQ ,el,e2), (EQ ,el,(COND ,e2,TRUE ,FALSE ))), 
simple-term(e2)—^ (EQ ,e2,(COND ,el,TRUE ,FALSE )), 

(COND ,el,e2,(NOT ,e2))), 

(EQ ,el,e2)) 


136 



mk-bool-neq(type-tag,el ,e2) 

= (type-tag = *BOOL’*' 

—(simple-term (el) 

—+ (simple-term(e2)^ (NEQ ,el,e2), (NEQ ,el,(COND ,e2,TRUE ,FALSE ))), 
simple-term(e2)--^ (NEQ ,e2,(COND ,el,TRUE ,FALSE )), 

(COND ,el,e2,(NOT ,e2))), 

(NEQ ,el,e2)) 


simple-term( term) 

= let operators = (DOT POUND) in 
-«consp(term)V hd(term)6 operators 


mk-vhdltime(global)(delta) = (VHDLTIME ,global,delta) 


block-exit(v)(stk) 

= let <tg,qname,p,g> = hd(stk) in 
(case tg 

*STKBOTTOM* —*• model-execution-compiete(qname), 

*UNDECLARE* —^ g(Avv,s.biock-exit(vv)(s))(v)(stk), 

(*BLOCK-EXIT* ,♦SUBPROGRAM-RETURN’^ ) ^ g(v)(stk-pop(stk)), 

(♦BEGIN’*' ,^LOOP-EXIT^ ,^PACKAGE-BODY-EXIT^ ) ^ block-exit(v)(stk-pop(stk)), 
OTHERWISE 

impl-error("Unknown execution stack descriptor with tag: ~a’\tg)) 


model-execution-complete(id) 

(mk-sd(id)(£)(e)(e)(((VHDL_MODEL-EXECUTION_COMPLETE ,id)))) 

A Stage 4 VHDL design file has a name id — supplied as an argument to the SDVS 
command vhdltr — and consists of a nonempty sequence of design units. 

The semantics of the design file has two semantic arguments: the TSE t constructed by 
Phase 1, and an identifier using-configuration supplied to the vhdltr command that 
specifies the configuration declaration to be used in configuring the design entity (in the 
absence of such a configuration, this identifier is expected to be none). 

The design file name id denotes a special place, whose value .id is itself a place that will 
represent, at any given point during the translation, the current universe of visible places. 
This name is available to most of the Phase 2 semantic functions as the first edge label in 
the current path. 

Translation of a design file commences by generating some top-level assertions and decla¬ 
rations for the SDVS Simplifier: 


• A disjointness assertion^ required for technical reasons. 

The function mk-disjoint(place-list) generates an SDVS assertion stating that the 
places in place-list are mutually disjoint. 

• A covering assertion that the initial universe of visible places .id consists of certain 
predefined places: the program counter place id\pc as well as the places vhdltime 
and vhdltime_previous. 


137 



The function mk-cover (place, place-list)^ generates an SDVS covering assertion 
that place covers all the places in place-list and that all of the places in place-list 
are mutually disjoint. 

• Declarations of the places vhdltime and vhdltime^previous. The function mk- 
scalar-decl(placename,place-type) (make scalar declaration) generates an SDVS 
declaration of a scalar-value place of the indicated type. 

• Assertions that the places vhdltime and vhdltime_previous have as their initial 
value the time object vhdltime(0,0) of the Simplifier VHDL Time domain. 

The function mk-rel(type-desc)(relation,accessed-place,expression) (make re¬ 
lation) constructs an SDVS typed relation that asserts that the value of a place at 
pre- or postcondition time stands in a certain relation to the value of an expression. 

Then a state delta that defines the execution of the hardware description is generated. The 
application of this state delta leads to further usable state deltas, whose generation in the 
absence of errors is accomplished by continuations. With respect to the TSE t, an initial 
path consisting of the design file’s name, an initial universe, and an initial execution stack 
containing a *STKBOTTOM* descriptor to terminate model execution (see Section 8.2), 
these state deltas symbolically elaborate the design file’s design units. 


8.4.2 Design Units 

(DUO) DU [[ £ J (configuratioii-ast)(t)(p)(u)(v)(stk) = u(v)(stk) 

(DUl) DU H design-unit design-unit* J (configuration-ast)(t)(p)(u)(v)(stk) 

= DU [design-unit | (configuration-ast)(t)(p)(ui )(v)(stk) 
where 

ui = Avi,stki. 

DU [design-unit* J (configuration-ast)(t)(p)(u)(vi )(stki) 

(DU2) DU [ DESIGN-UNIT context-item* Ubrary-unit J (configuration-ast)(t)(p)(u)(v)(stk) 
= Cl [ context-item* ] (t)(rest(p))(ui )(v)(stk) 
where 

ui = Avi ,stki. 

LU [ library-unit ] (configuration-ast)(t)(p)(u)(vi )(stki) 


8.4.3 Contex Items 

(CIO) Cl [ £ J (t)(p)(u)(v)(stk) = u(v)(stk) 

(Cll) Cl [ context-item context-item* | (t)(p)(u)(v)(stk) 

= Cl [ context-item J (t)(p)(ui )(v)(stk) 

where ui = Avi .stki .Cl [ context-item* ]] (t)(p)(u)(vi )(stki) 

(CI2) Cl [ USE dotted-name+ | (t)(p)(u)(v)(stk) 

= let decl = context-item in 
D [ decl I (t)(p)(u)(v)(stk) 


^The function ink-cover has in some instances been superseded by mk-cover-already; it implements 
an experimented new naming scheme for VHDL variables. The scheme is available only when the SDVS 
function iiew-declarations is defined to return non-NIL. In SDVS Version 12, this new scheme is not 
available, so we will not discuss the actions of this function here. 


138 




8.4.4 Library Units 

(LUl) LU [[CONFIGURATION idi id2 use-clause* block-coniig opt-id J (configuration-ast)(t)(p)(u)(v)(stk) 
= let configuration-decl = library-unit in 
CF [[configuration-decl | (t)(p)(u)(v)(stk) 


(LU 2 ) IJJ [ PACKAGE id decl* opt-id ] (configuration-ast)(t)(p)(u)(v)(stk) 
= let decl = library-unit in 
D [decl I (t)(p)(u)(v)(stk) 


(LU 3 ) LU [ ENTITY id decl* declj declj opt-id phasel-hook J (configuration-ast)(t)(p)(u)(v)(stk) 
= (null(configuration-ast) 

—► let entity-decl = library-unit in 

EN [ entity-decl | (t)(p)(u)(v)(stk), 
let configuration-entity-id = get-configuration-entity-id 

(configuration-ast) in 

(id = configuration-entity-id 

let entity-decl = library-unit in 
EN [ entity-decl | (t)(p)(u)(v)(stk), 
u(v)(stk))) 


(LU4) LU [ PACKAGEBODY id decl* opt-id J (configuration-ast)(t)(p)(u)(v)(stk) 

= let decl = library-unit in 
D [decl ] (t)(p)(u)(v)(stk) 

(LU5) IJQ [ ARCHITECTURE idi id2 decl* conc-stat* opt-id | (configuration-ast)(t)(p){u)(v)(stk) 
= (null(configuration-ast) 

—^ let architecture-body = library-unit in 

AR [ architecture-body ] (t)(p){u)(v)(stk), 
let configuration-entity-id = get-configuration-entity-id 

(configuration-ast) 

and configuration-architecture-id = get-configuration-architecture-id 

(configuration-ast) in 

(id2 — configuration-entity-id A idi = configuration-architecture-id 
—► let architecture-body = library-unit in 

AR I architecture-body ] (t)(p)(u)(v)(stk), 
u(v)(stk))) 


get-configuration-entity-id(configuration-ast) = hd(tl(tl(configuration-ast))) 


get-configuration-architecture-id (configuration-ast) 
= hd(tl(hd(tl(tl(tl(tl(configuration-ast))))))) 


8.4.5 Configuration Declarations 

(CFl) CF [CONFIGURATION idi id2 use-clause* block-config opt-id ] (t)(p)(u)(v)(stk) 
= u(v)(stk) 


139 




8.4.6 Entity Declarations 


(ENl) EN I ENTITY id declj declj declj opt-id phasel-hook 1 (t)(p)(u)(v)(stk) 


= let Pi = %(p)(id) in 

D i declj ] (t)(pi)(ui)(v)(stk) 
where 

ui = Avi,stki. 

D [[deci; I (t)(pi)(u 2 ){vi)(stki) 
where U 2 = Av 2 ,stk 2 .D [[ decl^ ] (t)(pi )(u)(v 2 )(stk 2 ) 


Phase 2 translation of an entity declaration effects the elaboration, via semantic function 
D, first of its port declarations, and then of any other declarations local to the entity. The 
interphase abstract syntax tree transformation has arranged for the Phase 2 abstract syntax 
of port declarations to be identical to that for other objects of class SIGNAL. 


8.4.7 Architecture Bodies 

(ARl) AR [ ARCHITECTURE idi id 2 decl* conc-stat* opt-id ] (t)(p)(u)(v)(stk) 

= let Pi = %(%(p)(id 2 ))(idi) in 
D I decl* I (t)(pi)(ui)(v)(stk) 
where 

ui = Avi ,stki, 

CS [ conc-stat* ] (t)(pi )(u 2 )(vi)(stki) 
where 

U 2 = Av 2 ,Stk 2 . 

cons((VHDLJV[ODELJ:LABORATION^COMPLETE ,hd(p)), 
(mk-sd 

(hd(p))(e)(e)(e) 

((make-vhdl-begin-model-execution 

(hd(p))(u)(t)(v 2 )(stk 2 ))))) 


Phase 2 translation of an architecture body first effects the elaboration, via semantic func¬ 
tion D, of the architecture’s local declarations, and then initiates the translation, via se¬ 
mantic function CS, of its concurrent statements (which have been uniformly converted to 
PROCESS statements by the interphase abstract syntax tree transformation at the end of 
Phase 1; see Section 7). The continuation of concurrent statement elaboration returns a 
Simplifier assertion to the effect that the VHDL model’s elaboration is complete, as well 
as a state delta, constructed by special function make-vhdl-begin-model-execution, that 
initiates symbolic execution of the model. 


8.4.8 Declarations 

(DO) Die] (t)(p)(u)(v)(stk) = u(v)(stk) 


(Dl) D I decl decl* ] (t)(p)(u)(v)(stk) 

= D I decl J (t)(p)(ui )(v)(stk) 

where ui = Avi,stki.D [[decl* | (t)(p)(u)(vi )(stki) 


140 



(D2) D I package-decl package-decl* ] (t)(p)(u)(v)(stk) 

= D [ package-decl ] (t)(p)(ui )(v)(stk) 

where Ui = Avi,stki.D [[package-decl* | (t)(p)(u)(vi)(stki) 


(D3) D [[ package-body package-body* ] (t)(p)(u)(v)(stk) 

-El package-body 1 (t)(p)(ui )(v)(stk) 

where Uj = Avi,stki.D [package-body* J (t)(p)(u)(vi )(stki) 


(D4) D [[ use-clause use-clause* | (t)(p)(u)(v)(stk) 

= D I use-clause | (t)(p)(ui )(v)(stk) 

where Ui = Avi,stki.D [use-clause* | (t)(p)(u)(vi )(stki) 


The Phase 2 processing of declarations proceeds sequentially, from first to last. 

(D5) D [ DEC object-class id"*' type-mark opt-expr J (t)(p)(u)(v)(stk) 

= let d = lookup-desc(type-mark)(t)(p) in 
(case tag(d) 

(*BOOL* ♦INT’*' *REAL* *TIME* ,’*'ENUMTYPE* *SUBTYPE* *INT^TYPE* ) 

—► gen-scaJar-decI 

(decl) (object-class) (id"^ )(d){opt-expr)(t)(p)(u)(v)(stk), 

*ARRAYTYPE* 

—^ gen-array-decl 

(decl)(object-class)(id"*" )(d)(direction(d))(real-lb(d)) 

(real-ub(d))(elty(d))(opt-expr)(t){p)(u)(v)(stk), 

*RECORDTYPE* 

—gen-record-decl 

(decl)(object-class)(id'^ )(d)(opt-expr)(t)(p)(u)(v){stk), 

OTHERWISE ^ u(v)(stk)) 


(D6) D [ SLCDEC object-class id"*" slice-name opt-expr J (t)(p)(u)(v)(stk) 

= let d = lookup(t)(p)(hd(id"*')) in 

let anon-array-type-desc = second(type(d)) in 
gen-array-decl 

(decl) (object-class) (id)(anon-array-type-desc) 

(direction (anon-array-type-desc)) (Ib(anon-array-type-desc)) 

(ub(anon-array-type-desc))(elty(anon-array-type-desc))(opt-expr)(t)(p) 

(u)(v)(stk) 


lookup-desc(id* )(t)(p) 

= (null(id*)—+ void-type-desc(t), 

let q = access(rest(id*))(t)(p) in 
lookup-desc-on-path(t)(q)(last(id*))) 

lookup-desc-on-path(t)(p)(id) 

= let d = t(p)(id) in 

(d = ^UNBOUND* —► lookup-desc-on-path(t)(rest(p))(id), d) 

access(id*)(t)(p) 

= (null(id*)^ p, 

let d = lookup(t)(p)(hd(id*)) in 
access(tl(id*))(t)(%(path(d))(idf(d)))) 


141 



gen-sccL]ar-decl(decl)(object-class)(id)(d)(expr)(t)(p)(u)(v)(stk) 

= (null(expr) 

—gen-scalar-decl-id-|-(decl)(object-class)(id'^ )(d)(expr)(t)(p)(u)(v)(stk), 
gen-scaIar-decl-id*(decl)(object-cIass)(id‘*' )(d)(expr)(t)(p)(u)(v)(stk)) 

gen-scalar-decl-id+(decl)(object-class)(id‘^ )(d)(expr)(t)(p)(u)(v)(stk) 

= (object-class = SIG 

—► gen-scalar-signal-decl-id4'(decl)(id'*' )(d)(expr)(t)(p)(u)(v)(stk), 
gen-scalar-nonsignal-decl-id+(decl)(id“*“ )(d)(expr)(t)(p)(u)(v)(stk)) 

gen-scalar-decl-id*(decl)(object-class)(id*)(d)(expr)(t)(p)(u)(v)(stk) 

= (null(id*)—+ u(v)(stk), 
let id+ = (hd(id*)) in 

gen-scalar-decl-id-l-(decl) (object-class) (id )(d)(expr)(t)(p)(ui )(v)(stk) 
where 

uj = Avi ,stki. 

gen-scalar-decl-id * 

(decl)(object-class)(tl(id* ))(d)(expr)(t)(p)(u)(vi )(stki)) 


gen-scalar-nonsignal-decl-id-|-(decl)(id‘'' )(d)(expr)(t)(p)(u)(v)(stk) 
= R I expr 1 (t)(p)(k)(v)(stk) 
where 


k = A(e,f),vj ,stki. 
let z = hd(p) 

and suqn*^ = get-qids(id'*' )(t)(p) in 
let V 2 = push-universe{vi )(z)(suqn‘*‘) in 
let duqn"*" = get-qu 2 dified-ids(suqn'^ )(v 2 ) in 
(mk-decl-sd 
(z)(f)(^)((z)) 

(nconc 

(mk-qual-id-coverings(suqn'*' )(duqn'*‘ )(z)(v)(t), 
mk-scalar-nonsignal-dec-post 

(decl)((duqn+,e,d))(t)(p)(u)(v 2 )(stk)))) 


get-qids{id*)(t)(p) 

= (null(id*)—► e, cons(qid(t(p)(hd(id*))),get-qids(tl(id*))(t)(p))) 

get-qualified-ids(suqn*)(v) 

= (null(suqn*)—► e, 

cons(qualified-id(hd(suqn*))(v),get-quaiified-ids(tl(suqn*))(v))) 

qualified-id(suqn)(v) 

= let vars = universe-vars(v) in 

let suqn-triple = assoc(suqn,vars) in 
(suqn-triple 

—► let n = hd(third(suqn-triple)) in 
name-qualified-id (suqn)(n), 
nanie-qualified-id(suqn)(l)) 

name-qualified-id(suqn)(n) 

= (new-declarations()—► (PLACELEMENT ,suqn,n), 

(n = 1 —► suqn, catenate(suqn,“!”,n))) 

already-qualified-id(suqn)(v) = “inull(assoc(suqn,uni verse-vars(v))) 


142 



qualified-icl-decls(suqn*) 

= (null(suqn*)—e, 

let suqn = hd(suqn*) in 

cons((DECLARE ,suqn,(TYPE ,PLACEARRAY )),quaHfied-id-decls(tI(suqn*)))) 

mk-qual-id-coverings(suqn‘^ )(duqn'*' )(z)(v)(t) 

= (new-declarations() 

— (already-qualified-id(hd(suqn'^ ))(v) 

— (mk-rel(univint-type-desc(t))((EQ ,pound(z),dot(z)))), 
nconc 

((mk-disjoint(z,cons(dot(z),suqn‘^)), 
mk-cover(pound(z),cons(dot(z),suqn‘*' ))),qualified-id-decis(suqn'^))), 
(mk-disjoint(z,cons(dot(z),duqn"*‘ )),mk-cover(pound(z),cons(dot(z),duqn'^)))) 

mk-scaJar-nonsignal-dec-post(decl)(duqn* ,e,d)(t)(p)(u)(v)(stk) 

= let type-spec = mk-type-spec(d)(t)(p) in 
(null(e) 

—► nconc 

(mk-scalar-nonsignal-dec-post-declare(duqn* )(type-spec), 
u(v)(stk)), 

let precondition = mk-constraint-guards((e)){(d))(t)(p)(v)(stk) in 
nconc 

(mk-scalar-nonsignal-dec-post-declare(duqn*)(type-spec), 
ui(v)(stk)) 
where 

ui = Avi ,stki. 

(mk-decl-sd 

(hd(p))(precondition)(e)(duqn*) 

(nconc 

(mk-sccLlar-nonsignal-dec-post-init(duqn* )(e)(d), 
u(v.)(stk.))))) 

mk-type-spec(d)(t)(p) 

= (case tag(d) 

*BOOL* ^ (TYPE BOOLEAN) , 

*BIT* - (TYPE BIT) , 

(*INT* *INT_TYPE* *TIME* ) — (TYPE INTEGER) , 

*REAL* - (TYPE FLOAT) , 

*VHDLTIME* ^ (TYPE VHDLTIME) , 

♦ENUMTYPE* 

— (idf(d)= CHARACTER — (TYPE CHARACTER) , 
cons(TYPE ,cons(ENUMERATION ,Uterals(d)))), 

*SUBTYPE* —► mk-type-spec(base-type(d))(t)(p), 

♦VOID* (TYPE VOID) , 

*POLY* — (TYPE POLYMORPHIC) , 

♦RECORDTYPE* —► cons(TYPE ,cons(RECORD ,record-to-type(components(d))(t)(p))), 
♦ARRAYTYPE* 

—» let expri = lb(d) iu 

R lexpn 1 (t)(p)(ki)(e)(e) 
where 

ki = A(ei ,fi),vi,stki. 

let expr 2 = ub(d) in 
RIexpr 2 ] (t)(p)(k 2 )(vi)(stki) 

where 

k2 - A(e2,f2),V2,Stk2. 
cons(TYPE , 

(ARRAY ,ei,e 2 ,ink-type-spec(elty(d))(t)(p))), 

*WAVE* — (TYPE ,WAVEFORM ,mk-type-spec(hd(type(d)))(t)(p)), 

OTHERWISE impl-error(“Unrecognized Stage 4 VHDL type: "'a”,tag(d))) 


143 



record-to-type(record-components)(t)(p) 

= (null(record-components)—► e, 

let (id,d) = hd(record-components) in 
cons((id,mk-type-spec(d)(t)(p)), 
record-to-type(tl(record-components))(t)(p))) 

mk-scalar-nonsignaJ-dec-post-declare(duqn*) (type-spec) 

= (nuil(duqn*)—► e, 

let duqn = hd(duqn*) in 
cons(mk-scalar-decl(duqn, type-spec), 

nnk-scalar-noiisigiial-dec-post-declare( tl(d uqn *)) (type-spec))) 

mk-scalar-decl(placename,place-type) = (DECLARE ,placename,place-type) 

mk-sc 2 Llar-nonsignaJ-dec-post-init(duqn* )(e)(d) 

= (null(duqn*)—> e, 

let duqn = hd(duqn*) in 
nconc 

(assign(d)((duqii,e)),mk-scalar-nonsignal-dec-post-init(tl(duqn*))(e)(d))) 

assign(d) (target, value) 

= (case tag(d) 

(♦BOOL* ,*BIT* *INT* ,*REAL* ,*TIME* ,*VHDLTIME* ,*ENUMTYPE* ,*WAVE* ,*VOID* , 
♦POLY* ) 

(mk-rel(d)((EQ ,pound(target),value))), 

♦SUBTYPE* —► assign(base-type(d))((target,value)), 

♦INT^TYPE* —► assign(parent-type(d))((target,value)), 

♦ARRAYTYPE* 

(is-bitvector-tdesc?(d) 

(is-constant-bitvector?(value) 

—► (case direction(d) 

TO 

—^ assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 

— assign-array-downto 

(target)(value)(elty(d)) 

(mk-exp2 
(SUB , 

mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)),1))(0), 

OTHERWISEiinpl-error(“Illegal direction: a”,direction 

(d)))> 

(mk-rel(d)((EQ ,pound(target),value)))), 
is-string-tdesc? (d) 

—*• (is-constaiit-string?{ value) 

—► (case direction(d) 

TO 

—► assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 

—► assign-array-downto 

(target)(value)(elty(d)) 

(mk-exp2 
(SUB , 

mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)),1))(0), 

OTHERWISE —► impl-error(“Illegal direction: ~a”,direction 

(d))), 


144 



(mk-rel(d){(EQ ,pound(target),value)))), 

(dotted-expr-p(vajue)^ (mk-rel(d)((EQ ,pound(target),value))), 

(case direction(d) 

TO —♦ assign-array-to(target)(value)(elty(d))((ORIGlN ,target))(0), 

DOWNTO 

—^ assign-array-downto 

(target) (value)(elty(d)) 

(mk-exp2 

(SUB ,mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)), 

1 ))( 0 ), 

OTHERWISE^ impl-error(“Illegal direction: ~a”,directioii(d))))), 
*RECORDTYPE* 

—»■ (dotted-expr-p(value)—assign-record(d)((target,value)), 
assign-record-fields(components(d))(( target, value))), 

OTHERWISE — impl-error(“Unrecognized Stage 4 VHDL type tag: "a” ,tag(d))) 

is-constant-bitvector?(expr*) 

= null(expr*) 

V (consp(expr*) 

A let expri =hd(expr*) in 

consp(expri )A hd(expri)= BS ) 

is-constant-string?(expr*) 

= null(expr*) 

V (consp(expr*) 

A let expri = hd(expr*) in 

consp(expri )A hd(expri)= CHAR ) 

dotted-expr-p(expr) = consp(expr)A hd(expr)= DOT 

assign-array-to( target) (aggregate) (element-type-d esc) (start-index)(m) 

= (null(aggregate)— e, 
nconc 
(assign 

(element-type-desc) 

(((ELEMENT ,target,mk-exp2(ADD ,start-index,m)),hd(aggregate))), 
cissign-array-to 

(target) (tl(aggregate)) (element-type-desc)(start-index)(m-|-l))) 

assign-array-down to(target) (aggregate) (element-type-desc)(start-index)(m) 

= (null( aggregate)— e, 
nconc 
(assign 

(element-type-desc) 

(((ELEMENT ,target,mk-exp2(SUB ,start-index,m)),hd(aggregate))), 
assign-array-downto 

(target) (tl(aggregate))(element-type-desc)(start-index)(m4-l))) 

mk-exp2(binary-op,el ,e2) 

= (case binary-op 

AND — (AND ,el,e2), 

NAND — (NAND ,el,e2), 

OR — (OR ,el,e2), 

NOR — (NOR ,el,e2), 

XOR — (XOR ,el,e2), 

BAND — (USAND ,el,e2), 

BNAND - (USNAND ,el,e2), 


145 



BOR — (USOR ,el,e2), 

BNOR — (USNOR ,el,e2), 

BXOR ^ (USXOR ,el,e2), 

ADD — (PLUS ,el,e2), 

SUB ^ (MINUS ,el,e2), 

MUL (MULT ,el,e2), 

DIV - (DIV ,eLe2), 

MOD ^ (MOD ,el,e2), 

REM ^ (REM ,el,e2), 

EXP ^ (EXPT ,el,e2), 

(RPLUS ,RMINUS .RTIMES ,RDIV ,REXPT ) -* (binary-op,el,e2), 
CONCAT ^ (ACONC ,el.e2), 

OTHERWISE 

—► iinpl-error(“Unrecognized Stage 4 VHDL binary operator: *a”,binary-op)) 

assign-record (d)(target-record,dotted-source-record) 

cons(mk-rel(d)((EQ ,pound(target-record),dotted-source-record)), 
assign-record-au x 

(components(d))(( target-record,second (dotted-sou rce-record)))) 

assign-record-aux(comp*)(target-record,source-record-name) 

= (null(comp*)—* e, 

let (id,d) = hd(comp') in 
nconc 
(assign 

(d) 

((mk-recelt(target<record,id),dot (mk-recelt(source-record-name,id)))), 
assign-record-aux(tl(comp* ))((target-record,source-record-name)))) 

assign-record-fields(comp*)(target-record,source-fields) 

— (null(comp*)—► e, 

let (id,d) = hd(comp*) in 
nconc 

(assign(d)((mk-recelt(target-record,id),second(assoc(id,source-fields)))), 
assign-record-fields( tl (com p*)) ((target- record ,source-field s)))) 

mk-recelt(e)(id) = (RECORD ,e,!d) 


gen-scalar-signaJ-decl-id-|-(decl)(id'’' )(d)(expr)(t)(p)(u)(v)(stk) 

= R [[ expr ]] (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi ,stki. 
let z = hd(p) 

and signal-suqn'*' = get-qids(id'*')(t)(p) in 
let driver-suqn'*’ — name-dnvers(signal-suqn'^) in 
let saqu"*" = append(signal-suqn“*" ,driver-suqn‘^) in 
let V 2 = push-universe(vi )(z)(suqn‘^) in 
let signal-duqn'*' = get-qualified-ids(signal-suqn'*')(v 2 ) 

and driver-duqu"*" = get-qualified-ids(driver-suqn'*‘)(v 2 ) in 
let duqu"*" = append(signal-duqn‘*',driver-duqn'‘’) in 
(mk-decl-sd 

(nconc 

(mk-qual-id-coverings(suqn“*‘ )(duqn'^ )(z)(v)(t), 
mk-scalar-signal-dec-post 

(decl)((duqn‘*' jsignal-duqn'*' ,driver-duqn‘^ ,e,d))(t)(p)(u) 

(V2)(stk)))) 


146 




name-drivers(signal-names) 

= (null(signal-names)—^- e, 

cons(name-driver(hd(signaJ-names)),name-drivers(tl(sigiial-names)))) 


mk-scaIar-signaI-dec-post(decl)(duqn* jSignaJ-duqn* ,driver-duqn* ,e,d)(t)(p)(u)(v)(stk) 
= let sigtype-spec = nik-sigtype-spec(d)(t)(p) 

and waveform-type-spec = (TYPE ,WAVEFORM ,mk-typ€-spec(d)(t)(p)) 
and precondition = mk-constraint-guards((e))((d))(t)(p)(v)(stk) in 
nconc 

(mk-scalar-signal-dec-post-declare 

(signal-duqn*)(driver-duqn*)(sigtype-spec)( waveform-type-spec), 
ui(v)(stk)) 
where 

Ui = Avi ,stki. 

(mk-decl-sd 

(hd(p))(precondition)(£)(duqn*) 

(nconc 

(mk-scaJar-signal-dec-post-init 

(signal-duqn* )(driver-duqn*)(e)(d)(waveform-type-desc(d)), 
u(vi)(stki)))) 


mk-scalar-signa]-dec-post-dedare(signal-duqn*)(driver-duqn*) (sigtype-spec) (waveform-type-spec) 
= (null(signal-duqn*e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(mk-scalar-signal-decl 

((signaJ-duqn,driver-duqn))((sigtype-spec, waveform-type-spec)), 
mk-scalar-signal-dec-post-declare 

(tl(signal-duqn*))(tl(driver-duqn* ))(sigtype-spec)(waveform-type-spec))) 


mk-scalar-signal-decl (signal-name,driver-name)(sigtype-spec, waveform-type-spec) 
= (mk-scalar-decl(sign ad-name,sigtype-spec), 

mk-scalar-decl(driver-name, waveform-type-spec)) 


mk-scalar-signal-fn-decl(signal-name,driver-name) 

= (DECLARE ,signaJ-name,(TYPE ,FN ,(VAL ,dot(driver-name),dot(VHDLTIME )))) 


waveform-type-desc(type-desc) = <WAVEFORM ,£:,*WAVE* ,(STANDARD) ,tt,type-desc> 


mk-scalar-signal-dec-post-init(signal-duqn*)(driver-duqn*)(e)(type-desc)(waveform-type-desc) 
= (null(signal-duqn*)^ e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
let initicd-signal-val = (null(e)-^ eval-expr(dot(signal-duqn)), e) in 
let initial-waveform = init-scalar-signal 

(signal-duqn) (driver-duqn )(type-desc) 

(initial-signal-val) in 


nconc 

(aLSsign( wav eform-type-desc)( (driver-duqn,initial-waveform)), 
mk-scalar-signal-dec-post-init 

(tl(signa]-duqn*))(tl(driver-duqn*))(e)(type-desc)(waveform-type-desc))) 


147 




gen-array-decl(decl) 

(object-class)(id+)(type-desc)(direction)(lower-bound)(upper-bound)(element-type-desc)(expr) 

(t)(p)(«)(v)(stk) 

= (null(expr) 

—♦ gen-array-decUid+ 

(decl)(object-dass)(id‘‘' )(type-desc)(direction)(lower-bound)(upper-bouiid) 
(element-type-desc)(expr)(t)(p)(u)(v)(stk), 
gen-array-ded-id* 

(ded)(object-dass)(id“^)(type-desc)(direction)(lower-bound)(upper-bound) 

(element-type-desc)(expr)(t)(p)(u)(v)(stk)) 

real-lb(d) 

= let bound = lb(d) in 

(is-num-lit?(bound)—► bound, 

(REF ,((SREF ,path(d),mk-tick-low(idf(d)))))) 

real-ub(d) 

= (path(d)= (STANDARD) A idf(d)€ (STRING BIT_VECTOR) — e, 
let bound = ub(d) in 
(is-num-lit? (bound )—► bound, 

(REF ,((SREF ,path(d),mk~tick-high(idf(d))))))) 

mk-tick-low(id) = catenate(id,“’LOW”) 

mk-tick-high (id) = catenate(id,‘') 

gen-array-ded-idd-(ded) 

(object-dass)(id'*' )(type-desc)(direction)(lower-bound)(upper-bound)(element-type-desc)(expr) 

(t)(p)(u)('')(stk) 

= (object-class = SIG 

—► gen-array-signal-decl-id+ 

(decl)(id'*' )(type-desc)(direction)(lower-bound)(upper-bound) 
(element-type-desc)(expr)(t)(p)(u)(v)(stk), 
gen-array-nonsignal-ded-id-f 

(decl)(id'*‘ )(direction)(lower-bound)(upper-bound)(element-type-desc)(expr) 

(t)(p)(u)('')(stk)) 

gen-array-decl-id*(decl) 

(object-dass)(id*)(type-desc)(direction)(lower-bound)(upper-bound)(element-type-desc)(expr) 

(t)(p)(u)(v)(stk) 

= (null(id*)—»■ u(v,stk), 
let id'’' = (hd(id*)) in 
gen-array-ded-id-f 

(decl)(object-class)(id'’' )(type-desc)(direction)(lower-bound)(upper-bound) 
(element-type-desc)(expr)(t)(p)(ui)(v)(stk) 

where 

ui = Avi,stki. 

gen-array-decl-id* 

(decl)(object-class)(tl(id*))(type-desc)(direction)(lower-bound) 
(upper-bound)(element-type-desc)(expr)(t)(p)(u)(vi )(stki)) 


gen-array-nonsignal-decl-id-i-(ded) 

(id'’' )(direction)(expri )(expr2 )(element-type-desc)(expr) 
(t)(p)(u)(v)(stk) 

= R I expr 1 (t)(p)(k)(v)(stk) 
where 


148 



k = A(e,f),vi ,stki. 

Rjexpri I (t)(p)(ki)(vi)(stki) 
where 

ki = A(ei,fi),V2,stk2. 

R [ expr 2 ] (t)(p)(k 2 )(v 2 )(stk 2 ) 
where 

k2 = A(e2,f2),V3,Stk3. 

let z = hcl(p) 

and len = length-expr(expr) 
and suqn^ = get-qids(id'*')(t)(p) in 
let V 4 = push-universe(v 3 )(z)(suqn^) in 
let duqn'*‘ = get-qualilied-ids(suqn"^ ){v 4 ) in 
let gi = (ei A 62 

—^ mk-rel 

(univint-type-desc(t)) 

((LE , 61 , 62 )), 

TRUE ) 

and g 2 = (ei A 62 

—► mk-rel 

(univint-type-desc(t)) 

((GE, 

mk-exp 2 

(ADD ,mk-exp 2 (SUB , 62 , 61 ), 
l),len)), 

TRUE ) in 

(mk-decl-sd 

(z) 

(nconc 

(fl,f 2 ,(gl), 

(len = 0 ^ f, nconc((g2),f))))(£)((2)) 

(nconc 

(mk-qual-id-coverings 

(suqn''’)(duqn''')(z)(v)(t), 

mk-array-nonsigncd-dec-post 

(decl) 

((duqn"*',e,direction ,61 ,e 2 ,element-type-desc)) 
^)(p)(u)(''4)(stk3)))) 


length-expr(expr) 

= (nuU(expr)—*■ 0 , 

hd(expr)G (BITSTR STR PAGGR) —► length(second(expr)), 

1 ) 

mk-array-nonsignal-dec-post (decl) 

(duqn* , 6 ,direction,lower-bound,upper-bound,element-type-desc) 
( 0 (p)(“)('')(stk) 

= let element-type-spec = mk-type-spec(element-type-desc)(t)(p) in 
(null(e) 

--*■ nconc 

(mk-array-nonsignal-dec-post-declare 

(duqn*)(direction)(lower-bound)(upper-bound)(element-type-spec), 
u(v)(stk)), 

nconc 

(mk-array-nonsignal-dec-post-declare 

(duqn* )(direction)(lower-bound)(upper-bound)(element-type-spec), 
ui(v)(stk)) 
where 


149 


Ui = Avi ,stki. 

(mk-ded-sd 

(hd(p))(e)(e)(duqn*) 

(nconc 

((direction = TO 

—► mk-array-nonsignal-dec-post-init-to 

(duqn* )(e) (element-type-desc)(lower-bound), 
mk-array-nonsignal-dec-post-init-downto 

(duqn*)(e)(element-type-desc)( upper-bound)), 
u(vi)(stki))))) 

mk-array-nonsignai-dec-post-declare(duqn* )(direction)(lower-bound) (upper-bound) (element-type-spec) 
= (null(duqn*)—^ e, 

let duqn = hd(duqn*) in 
nconc 

(mk-vhdl-array-decl 

(duqn)(direction)(lower-bound) 

((null(upper-bound) 

—► (lower-bound = 1 (RANGE ,duqn), 

mk-exp2(SUB ,mk-exp2(ADD ,(RANGE ,duqn),lower-bound),!)), 
upper-bound))(element-type-spec), 
mk-array-nonsignal-dec-post-dedare 

(tl(duqn*))(direction)(lower-bound)(upper-bound)(element-type-spec))) 

mk-vhdl-array-decl(id )(direction)(lower-bound )(upper-bound) (element-type-spec) 

= (case second(element-type-spec) 

BIT 

(mk-array-decl(id)(lower-bound)(upper-bound)(element-type-spec), 
mk-bitvec-fn-decl(id) (direction )(lower-bound) (upper-bound)), 

CHARACTER 

(mk-array-decl(id)(lower-bound)(upper-bound)(element-type-spec), 
mk-string-fn-decl(id) (direction) (lower-bound) (upper-bound)), 

OTHERWISE 

—► (mk-array-decl(id) (lower-bound )(upper-bound) (element-type-spec))) 
mk-array-decl(id)(Iower-bound) (upper-bound) (element-type-spec) 

= (DECLARE ,id,(TYPE ,ARRAY ,lower-bound,upper-bound,element-type-spec)) 

mk-bitvec-fn-decl(bitvec-name)(direction)(lower-bound)(upper-bound) 

= let bitvec-elt-names = (direction = TO 

—*■ mk-slice-elt-names-to 

(bitvec-name)(lower-bound) (upper-bound), 
mk-slice-elt-names-downto 

(bitvec-name)(lower-bound)(upper-bound)) in 
(DECLARE ,bitvec-name,(TYPE ,FN ,concatenate-bits(bitvec-elt-names))) 

mk-string-fn-decl(string-name)(direction)(iower-bound)(upper-bound) 

= let string-elt-names = (direction = TO 

—► mk-slice-elt-names-to 

(string-name)(lower-bound)(upper-bound), 

mk-slice-elt-names-downto 

(string-name)(lower-bound)(upper-bound)) in 
(DECLARE ,string-name,(TYPE ,FN ,concatenate-characters(string-elt-names))) 

mk-slice-elt-names-to(slice-name)(lower-bound)(upper-bound) 

= (lower-bound > upper-bound —► £, 

cons(mk-array-elt (slice-name) (lower-bound), 

mk-slice-elt-names-to(slice-name) (lower-bound+1 )(upper-bound))) 


150 



mk-slice-elt-names-downto(slice-narae) (lower-bound) (upper-bound) 

(upper-bound < lower-bound e, 
cons(mk-array-elt(slice-name)(upper-bound), 

mk-slice-elt-names-downto(slice-name)(lower-bound)(upper-bound — 1 ))) 
mk-array-elt(id)(e) = (ELEMENT ,id,e) 

concatenate-bits(bit-names) = cons(USCONC ,mk-dotted-names(bit-names)) 
concatenate-characters(char-names) = cons(ACONC ,mk-dotted-names(char-names)) 
mk-dotted-names(names) 

~ (null(names)—► £, cons(dot(hd(names)),mk-dotted-names(tl(names)))) 

mk-array-nonsignal-dec-post-init-to(duqn* )(e)(element-type-desc) (lower-bound) 

= (null(duqn*)—► e, 
nconc 

(assign-array-to(hd(duqn*))(e)(element-type-desc)(lower-bound)( 0 ), 

mk-array-nonsignal-dec-post-init-to 

(tl(duqn*))(e)(element-type-desc) (lower-bound))) 

mk-array-nonsignal-dec-post-init-downto(duqn* )(€)(element-ty pe-desc)( upper-bound) 
= (null(duqn*)—e, 
nconc 

(assign-array-downto(hd(duqn*))(e)(element-type-desc)(upper-bound)( 0 ), 

mk-array-nonsignal-dec-post-init-downto 

(tl(duqn* ))(e) (element-type-desc)(upper-bound))) 


gen-array-sign aJ-decl-idd-(decl) 

(id"*" )(type-desc)(direction)(expri )(expr 2 )(element-type-desc)(expr) 
(t)(p)(u){v)(stk) 

= R [[ expr I (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi jStki. 

R[expri I (t)(p)(k])(v,)(stki) 
where 

ki = A(ei,fi),V2,stk2. 

R I expr 2 1 (t)(p)(k 2 )(v 2 )(stk 2 ) 

where 

k2 = A(e2,f2),V3,stk3. ■ 
let z = bd(p) 

and len = length-expr(expr) 
and signal-suqn"^ = get-qids(id‘*’)(t)(p) in 
let driver-suqn'*' = name-drivers(signal-suqn"*') in 
let suqn'*' = append(signal-suqn'*" jdriver-suqn"*") in 
let V 4 = push-universe(v 3 )(z)(suqn"*') in 
let signal-duqn"*" = get-qualified-ids 

(signal-suqn^ )('' 4 ) 
and driver-duqn'*’ = get-qualified-ids 

(driver-suqn'^)(v4) in 

let duqu"*" = append 

(sign^d-duqn*^ ,driver-duqn"*^) in 
let gi = (ei A e 2 

—► mk-rel 

(univint-type-desc(t)) 

((LE , 61 , 62 )), 


151 



TRUE ) 

and g2 = (ei A 62 

—+ mk-rel 

(univint-type-desc(t)) 

((GE, 

mk-exp2 

(ADD , 

mk-exp2(SUB ,e 2 ,ei),l),len)), 

TRUE) in 

(mk-decl-sd 

(z) 

(nconc 

(fl,f2,(gl), 

(len = 0 ^ f, nconc(f,(g2)))))(£)((z)) 

(nconc 

(mk>quaI-id-coverings 

(suqn+ Xduqn"^ )(z)(v)(t), 
mk-array-signal-dec-post 
(deci) 

((duqn*^ ,signal-duqn''' ,driver-duqn"*' ,e,type-desc,direction, 
01 ,e 2 ,element-type-desc))(t)(p)(u) 

(V4)(stk3)))) 


mk-array-signaJ-dec-post(decl) 

(duqn* ,signal-duqn* ,driver-duqn* ,e,type-desc, 
direction,lower-bound,upper-bound,element-type-desc) 

(t)(p)(u)('')(stk) 

= let element-sigtype-spec = mk-sigtype-spec(elenieiit-type-desc)(t)(p) 
and element-waveform-type-spec = mk-waveform-type-spec 

{mk-type-spec(element-type-desc)(t)(p)) in 

nconc 

(mk-array-signal-dec-post-declare 

(signal-duqn* )(driver-duqn*) (direction) (lower-bound) (upper-bound) 
(element-sigtype-spec)(element-waveform-type-spec)(tt)(t)(p)(v)(stk), 
ui(v)(stk)) 
where 

ui = Avi ,stki. 

(mk-decl-sd 

(hd(p))(£)(£)(duqn*) 

(nconc 

(mk-array-signal-dec-post-init 

(signal-duqn* )(driver-duqn*)(e)(type-desc){direction) 

(lower-bound) (upper-bound) (element-type-desc) 
(waveform-type-desc(element-type-desc))(t)(p)(v)(stk), 
u(vi)(stki)))) 

mk-waveform-type-spec(type-spec) 

= (case second(type-spec) 

ARRAY --»■ append(rest(type-spec),(mk-waveform-type-spec(last(type-spec)))), 

OTHERWISE ^ (TYPE ,WAVEFORM ,type-spec)) 

mk-array-signal-dec-post-declare(signal-duqn* )(driver-duqn*) (direction) (lower-bound) (upper-bound) 

(element-sigtype-spec) (element-waveform-type-spec) (fn-decls?) 
(t)(p)(v)(stk) 

= (null(signal-duqn*)—► e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 


152 



nconc 


(mk-array-signal-decl 

(signal-duqn)(driver-duqn)(direction)(lower-bound)(upper-bound) 
(eIement-sigtype-spec)(element-waveform-type-spec)(fn-decls?)(t)(p)( v) 

(stk), 

mk-array-signal-dec-post-declare 

(tl(signaJ-duqn* ))(tl{driver-duqn* ))(direction)(lower-bound) 
(upper-boiind)(element-sigtype-spec)(element-waveform-type-spec) 
({n-decls?)(t){p)(v)(stk))) 

mk-array-signal-decl(signal-name)(driver-name)(direction)(lower-bound)(iipper-bound) 

(element-sigtype-spec)(element-waveform-type-spec)(fn-decls?) 

(t)(p)(v)(stk) 

= nconc 

(mk-vhdl-sigarray-decl 

(signal-name)(direction)(lower-bound) 

({null( upper-bound) 

—(lower-bound = 1 —♦ (RANGE ,signal-name), 

mk-exp 2 (SUB ,mk-exp 2 (ADD ,(RANGE ,signal-name),lower-bound),!)), 
upper-bound))(element-sigtype-spec)(fn-decls?), 

(mk-array-decl 

(driver-name) (lower-bound) 

((null(upper-bound) 

^ (lower-bound = 1 —► (RANGE ,driver-name), 

mk-exp 2 (SUB ,mk-exp 2 (ADD ,(RANGE ,driver-name),lower-bound),!)), 
upper-bound)) (element-waveform-type-spec))) 

mk-array-signal-elt-fn-decls(signal-duqn)(driver-duqn)(element-type-desc)(lower-bound)(upper-bound) 

(t)(p)(v)(stk) 

= (is-array-tdesc?(element-type-desc) 

—let signal-elts = mk-slice-elt-names-to 

(signal-duqn)(lower-bound)(upper-bound) 
and driver-elts = mk-slice-elt-names-to 

(driver-duqn)(lower-bound)(upper-bound) in 
let expn = reaJ-lb(element-type-desc) in 
R|expri J (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,fi ),vi ,stki. 

let expr2 = real-ub(element-type-desc) in 
R|expr2 1 (t)(p)(k2)(v])(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 

mk-array-signal-elt-fn-decls-aux 

(signaJ-elts)(driver-elts)(elty(element-type-desc)) 

(ei)(e2)(t)(p)(v2)(stk2), 

let scaiar-signal-elts = mk-slice-elt-names-to 

(signal-duqn) (lower-bound) (upper-bound) 
and scaJar-driver-elts = mk-slice-elt-names-to 

(driver-duqn)(lower-bound)(upper-bound) in 
mk-scalar-signal-fn-decls(scalar-signal-elts,scalar-dri ver-elts)) 

mk-array-signal-elt-fn-decls-aux(signal-duqn* )(driver-duqn*) 

(element-type-desc)(lower-bound)(upper-bound) 

(t)(p)('’)(stk) 

= (null(signal-duqn*)—*■ 6 , 

let signaJ-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 


153 



nconc 

(mk-array-signal-elt-fn-deds 

(signal-duqn)(driver-duqn)(element-type-desc) (lower-bound) (upper-bound) 
(‘■)(p)(v)(stk), 

mk-array-signal-elt-fn-decls-aux 

(tl(signal-duqn*))(tl(driver-duqn*))(element-type-desc)(lower-bound) 

(upper-bound)(t)(p)(v)(stk))) 

mk-scalar-signal-fn-decls(signal-nanies,driver-names) 

= (null(signal-names)—e, 

cons(mk-scalar-signal-fn-decl(hd(signal-names),hd(driver-names)), 

mk-scaJar-signal-fn-decls(tl(signal-names),tl(driver-names)))) 

mk-array-signal-dec-post-init(signaJ-duqn* )(driver-duqn* )(e) 

(type-desc) (direction )(lower-bound) (upper-bound) 
(element-type-desc)(element-waveform-type-desc) 
(t)(p)(v)(stk) 

= (direction = TO 

—^ mk-array-signal-dec-post-init-to 

(signal-duqn*)(driver-duqn*)(e)(type-desc)(lower-bound)(upper-bound) 

(element-type-desc)(element-waveform-type-desc)(t)(p)(v)(stk), 

mk-array-signaJ-dec-post-init-downto 

(signal-duqn*)(driver-duqn* )(e)( type-desc) (lower-bound) (upper-bound) 
(element-type-desc)(element-waveform-type-desc)(t)(p)(v)(stk)) 

mk-array-signal-dec-post-init-to(signal-duqn* )(driver-duqn* )(e) 

(type-desc) (lower-bound)(upper-bound) 
(element-type-desc) (element-waveform-type-desc) 
(t)(p)(v)(stk) 

= (is-array-tdesc?(eleinent-type-desc) 

—► let expr] = real-lb(element-type-desc) in 
R I expri I (t)(p){ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

let expr2 = real-ub(element-type-desc) in 
R [ expra I {t)(p)(k2)(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 

mk-array-signal-dec-post-init-elt-arrays-to 
(signal-duqn* )(driver-duqn* )(e)(type-desc) 

(lower-bound) (upper-bound) (element-type-desc) 
(direction(element-type-desc))(ei )(e2)(t)(p)(v2)(stk2), 
mk-array-signcd-dec-post-init-elt-scalars-to 

(signal-duqn* )(driver-duqn* )(e) (type-desc) (lower-bound) (upper-bound) 
(eIement-type-desc)(element-waveform-type-desc)(t)(p)(v)(stk)) 

mk-array-signal-dec-post-init-downto(signal-duqn* )(driver-duqn* )(e) 

(type-desc) (lower-bound)(upper-bound) 
(element-type-desc)(element-waveform-type-desc) 
(t)(p)(v)(stk) 

= (is-array-tdesc? (element-type-desc) 

—let expri = real-lb(element-type-desc) in 
R lexpn 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,fi),vi,stki. 

let expr2 = real-ub(eleraent-type-desc) in 

R I expra I (t){p)(k2)(vi)(stki) 


154 




where 

k2 = A(e2,f2),V2,Stk2. 

mk-array-signal-dec-post-init>elt-arrays-downto 
(signai-duqn* )(driver-duqn*)(e)(type-desc) 
(lower-bound)(upper-bound)(eleinent-type-desc) 

(direction(element-type-desc))(e] )(e2)(t)(p)(v2)(stk2), 
mk-array-signal-dec-post-init-elt-scalars-downto 

(signal-duqn* )(driver-duqn* )(e)(type-desc)(lower-bound)(upper-bound) 

(element-type-d esc) (element-waveform-type-desc)(t)(p)(v)(stk)) 

mk-array-signal-dec-post-init-elt-arrays-to(signal-duqn* )(driver-duqn* )(e) 

(type-desc) (lower-bound) (upper-bound) 

(elt-type-desc)(elt-direction)(elt-lower-bound)(elt-upper-bound) 

(t)(p)('')(stk) 

= (nul](signal-duqn*)—*^ e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(let signaJ-elts = mk-slice-elt-names-to 

(signal-duqn)(lower-bound)(upper-bound) 
and driver-elts = mk-slice-elt-names-to 

(driver-duqn)(lower-bound)(upper-bound) in 
mk-array-signal-dec-post-init-aux 

(signal-elts)(driver-elts)(e)(elt-type-desc)(elt-direction) 
(elt-lower-bound)(elt-upper-bound)(elty(elt-type-desc)) 
(waveform-type-desc(elty(elt-type-desc)))(t)(p)(v)(stk), 
mk-array-signaJ-dec-post-init-elt-arrays-to 

(tl(signal-duqn*))(tl(driver-duqn*))(tl(e))( type-desc) (lower-bound) 

(upper-bound )(eIt-type-desc)(eIt-direction)(elt-lower-bound) 

(elt-upper-bound)(t)(p)(v)(stk))) 

mk-array-signal-dec-post-init-elt-arrays-downto(signal-duqn*) (driver-duqn* )(e) 

(type-desc)(lower-bound) (upper-bound) 

(elt-type-desc)(elt-direction)(elt-lower-bound)(elt-upper-bound) 

(t)(p)(v)(stk) 

= (null(signal-duqn*)—► e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(let signal-elts = mk-slice-elt-names-downto 

(signal-duqn)(lower-bound) (upper-bound) 
and driver-elts = mk-slice-elt-names-downto 

(driver-duqn)(lower-bound)(upper-bound) in 
mk-array-signal-dec-post-init-aux 

(signal-elts)(driver-elts)(e)(elt-type-desc)(elt-direction) 
(elt-lower-bound)(elt-upper-bound)(elty(elt-type-desc)) 

(wav eform-type-desc(elty(elt-type-desc) ))(t)(p)(v)(stk), 
mk-array-signal-dec-post-init-elt-arrays-downto 

(tl(signal-duqn* ))(tl(driver-duqn* ))(tl(e))(type-desc)(lower-bound) 

(upper-bound )(elt-type-desc)(elt-direction)(elt-lower-bound) 

(elt-upper-bound)(t)(p)(v)(stk))) 

mk-array-signal-dec-post-init-aux(signaJ-duqn* )(driver-duqn*)(e) 

(type-desc) (direction) (lower-bound )(upper-bound) 
(element-type-desc)(element-waveform-type-desc) 

(t)(p)(v)(stk) 

= (null(signal-duqn’)—» e, 


155 



let signal-duqn = h(i(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
nconc 

(mk-array-signal-dec-post-init 

((signal-duqn))((driver-duqn))(hd(e)){type-desc) (direction) 

(lower-bound) (upper-bound) (element-ty pe-desc) (element-waveform-type-desc) 

(t)(p)(v)(stk), 

mk-array-signal-dec-post-init-aux 

(tl(signal-duqn*))(tl(driver-duqn* ))(tl(e))(type-desc)(direction) 
(lower-bound)(upper-bound)(element-type-desc)(element-waveform-type-desc) 
(‘')(p)(v)(stk))) 

mk-array-signa]-dec-post-init-elt-scaJars-to(signal-duqn* )(driver-duqn')(e) 

(type-desc)(lower-bound)(upper-bound) 

(element-type-desc)(element-waveform-type-desc) 

(t)(p)(v)(stk) 

= (null(signal-duqn* )-^ e, 

let signal-duqn = hd(signaJ-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
let initial-waveforms = init-array-signal-to 

(signal-duqn)(driver-duqn)(e)( type-desc) 
(element-type-desc)(lower-bound)(upper-bound) in 

nconc 

(assign-array-to 

(driver-duqn)(initial-waveforms)(element-waveform-type-desc) 

(lower-bound)(0), 

mk-array-signal-dec-post-init-elt-scalars-to 

(tl(signal-duqn*))(tl(driver-duqn* ))(e)(type-desc) (lower-bound) 
(upper-bound)(element-type-desc)(element-waveform-type-desc)(t)(p)(v) 

(stk))) 

mk-array-signal-dec-post-init-elt-scalars-downto(signal-duqn* )(driver-duqn*)(e) 

(type-desc) (lower-bound) (upper-bound) 
(element-type-desc)(element-waveform-type-desc) 
(t){p)(v)(stk) 

= (null(signal-duqn*)—► e, 

let signal-duqn = hd(signal-duqn*) 

and driver-duqn = hd(driver-duqn*) in 
let initial-waveforms = init-array-signaJ-downto 

(signal-duqn)(driver-duqn)(e)(type-desc) 
(element-type-desc)(lower-bound)(upper-bound) in 

nconc 

(assign-array-down to 

(driver-duqn) (ini tial-waveforms)(element-waveform-type-desc) 

(upper-bound) (0), 

mk-array-signal-dec-post-init-elt-scalars-downto 

(tl(signal-duqn*))(tl(driver-duqn*))(e)(type-desc)(lower-bound) 
(upper-bound)(element-ty pe-desc) (element-waveform-type-desc)(t)(p)(v) 

(stk))) 

(D7) D [ ETDEC id id+ J (t)(p)(u)(v)(stk) 

= (mk-decl-sd 

(hd(p))(e)(s)(e) 

(nconc(mk-etdec-post((id))(t)(p),u(v)(stk)))) 

mk-etdec-post(type-mark)(t)(p) 

= let d = lookup-desc(type-mark)(t)(p) in 
mk-enumlit-rels(d)(literals(d)) 


156 



mk-enumlit-rels(d)(id*) 

= (null(tl(id* ))—*■ er, 
let idi = hd(id*) 

and id2 = hd(tl(id’)) in 

cons(mk-rel(d)((PRED ,idi ,id2 )),mk-enumlit-rels(d)(tl(id* )))) 

The translation of an enumeration type declaration emits an SDVS declaration of the enu¬ 
meration type. 

(D8) D [ ATDEC id discrete-range type-mark ] (t)(p)(u)(v)(stk) 

= let (direction,expri ,expr2) = discrete-range in 

let lower-bound = (direction = TO —► expri, expr2) 

and upper-bound — (direction = TO expra, expri) in 
attributes-low-high 

((id,lower-bound,upper-bound,(UNIVERSAL-INTEGER) )){t)(p)(u)(v)(stk) 

attributes-lo w-high(id,lower-bound,upper-bound,attribute-type-mark)(t)(p)(u)(v)(stk) 

= let decli = (DEC ,SYSGEN ,(mk-tick-low(id)),attribute-type-mark,lower-bound) 

and decla = (DEC ,SYSGEN ,(mk-tick-high(id)),attribute-type-mark,upper-bound) in 
let decU = (decli ,decl2) in 
D I decU I (t)(p)(u)(v)(stk) 

mk-tick-low(id) = catenate(id,“'LOW”) 

mk-tick-high(id) = catenate(id,“’HIGH”) 


An array type declaration declares and initializes the ^low and ^high array type attributes. 

(D 9 ) D [ PACKAGE id decl* opt-id | (t)(p)(u)(v)(stk) 

= D [[ decP ] (t)(%(p)(id))(u)(v)(stk) 

The declarations contained within a package are translated as usual, but in the package’s 
context in the TSE, via the extended path %(p)(id). 

(DIO) D I PACKAGEBODY id decl* opt-id J (t)(p)(u)(v)(stk) 

= let pb-exit-desc = <*PACKAGE-BODY-EXIT* ,id,p,Av,s.u(v)(s)> in 
D [decl* J (t)(%(p)(id))(ui)(v)(stk-push(pb-exit-desc)(stk)) 
where ui = Avi ,stki .package-body-exit(vi )(stki) 

package-body-exit(v)(stk) 

= let <tg,qname,p,g> = hd(stk) in 
(case tg 

*STKBOTTOM* model-execution-complete(qname), 

*UNDECLARE* —► g(Avv,s.package-body-exit(vv)(s))(v)(stk), 

(*BEGIN* ) —► package-body-exit(v)(stk-pop(stk)), 

(*PACKAGE-BODY-EXIT* ,*LOOP-EXIT* ,*SUBPROGRAM-RETURN* ) — g(v)(stk-pop(stk)), 
OTHERWISE 

—► impl-error(“Unknown execution stack descriptor with tag: ~a”,tg)) 


The declarations contained in a package body are translated in the package’s context in 
the TSE, via the extended path %(p)(id). A *PACKAGE-BODY-EXIT* descriptor 
is first pushed onto the execution stack to prevent the package’s declarations from being 
unelaborated when the package body is exited. 


157 



(Dll) D [[ PROCEDURE id proc-par-spec* ]] (t)(p)(u)(v)(stk) = u(v)(stk) 

(D12) D ([ FUNCTION id func-par-spec* type-mark ]) (t)(p)(u)(v)(stk) = u(v)(stk) 

(D13) D [ SUBPROGBODY subprog-spec decl* seq-stat* opt-id ] (t)(p)(u)(v)(stk) 
= u(v)(stk) 


Subprogram declarations need no Phase 2 translation, nor do subprogram bodies. 

(D14) D I USE dotted-name'*' J (t)(p)(u)(v)(stk) = u(v)(stk) 

The effect of USE clauses has already been recorded in the TSE during Phase 1; no further 
Phase 2 translation is necessary. 

(D15) D [ STDEC id type-mark opt-discrete-range ]] {t)(p)(u)(v)(stk) 

= let z = hd(p) 

and subtype-desc = lookup-desc-on-path(t)(p)(id) in 
let basetype-desc = bcLse-type(subtype-desc) in 
let expri = type-tick-low(basetype-desc) 

and expr2 = type-tick-low(subtype-desc) 
and expra = type-tick-high(subtype-desc) 
and expr4 = type-tick-high(basetype-desc) in 
R-Hexpri I (t)(p)(kj)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

R [[expr2 I (t)(p)(k2)(vi)(stki) 
where 

k2 = A{e2,f2),V2,Stk2. 

R I expra ] (t)(p)(k3)(v2)(stk2) 

where 

ka = A(e 3 ,f 3 ),V 3 ,stk 3 . 

R Iexpr 4 ] (t)(p)(k 4 )(v 3 )(stk 3 ) 
where 

k4 = A(e4,f4),V4,Stk4. 

(mk-decl-sd 

(z) 

(nconc 

((ei 

—► (mk-rel 

(basetype-desc) 

((LE ,61,62))), 

e), 

(64 

—+ (mk-rel 

(basetype-desc) 

((LE ,63,04))), 

e)))(«)(e) 

(Ul(v4)(stk4))) 

where 

Ui = Av5,stk5. 

attributes-low-high 

((id,expr 2 ,expr 3 , 

(idf(basetype-desc))))(t)(p)(u) 

(V 5 )(stk 5 ) 


158 



The Phase 2 semantics of subtype declarations generates a state delta with guards in the 
precondition to ensure that the subtype range falls within the range of allowable values 
for the subtype’s base type. Assuming this holds, the continuation in the state delta’s 
postcondition performs the Phase 2 processing of declarations and initializations for the 
^low and ^high attributes representing the subtype bounds. 


(D16) D J ITDEC id discrete-range J (t)(p)(u)(v)(stk) 

= let z = hd(p) 

and integer-type-desc = lookup-desc-on-path(t)(p){id) in 
let expri = type-tick-low(integer-type-desc) 

and expr 2 = type-tick-high(integer-type-desc) in 
attributes-low-high 

((id,expri,expr 2 ,(UNIVERSALJNTEGER) ))(t)(p)(u)(v)(stk) 


The Phase 2 semantics of integer type declarations simply processes declarations and ini¬ 
tializations for the ’low and ’high attributes representing the integer type bounds. 

(D17) D I COMPONENT id declj declj phasel-hook J (t)(p)(u)(v)(stk) = u(v)(stk) 


8.4.9 Concurrent Statements 

(CSO) CS [el (t)(p)(u)(v)(stk) = ii(v)(stk) 


CS [ conc-stat conc-stat* J (t)(p)(u)(v)(stk) 

= CS [ conc-stat | (t)(p)(ui )(v)(stk) 

where ui = Av,stk.CS | conc-stat* | (t)(p)(u)(v)(stk) 


A list of concurrent statements is translated in order, from first to last. 


(CS2) CS I BLOCK id decl* conc-stat* opt-id phasel-hook J (t)(p)(u)(v)(stk) 
= let pi = %(p)(id) in 

D [decl* ] (t)(pi)(ui)(v)(stk) 
where ui = Avi ,stki . CS [ conc-stat* | (t)(pi )(u)(vi )(stki) 


(CSS) CS [PROCESS id decl* seq-stat* opt-id phasel-hook ] (t)(p)(u)(v)(stk) 
= let process-qid = qid(lookup(t)(p)(id)) 
and Pi = %(p)(id) in 
(mk-decl-sd 

(hd(p))(£)(£)(£) 

((make-vhdl-process-elaborate 

(process-qid)(t)(pi )(seq-stat*)(ui)(v)(stk)))) 
where ui = Av,stk.D [decl* | (t)(pi)(u)(v)(stk) 


159 



8.4.10 Sequential Statements 

(SSO) ss I e ]! (t)(p)(c)(v)(stk) = c(v)(stk) 


(SSI) ^ J seq-stat seq-stat^ ] (t)(p)(c)(v)(stk) 

= SS [ seq-stat | {t)(p)(ci )(v)(stk) 

where Ci = Av,stk.SS [[ seq-stat* J (t)(p)(c)(v)(stk) 


A list of sequential statements is translated in order, from first to last. 

(552) ^ I NULL atmark ] (t)(p)(c)(v)(stk) 

=r ((EQ ,pound(catenate(hd(p)/‘\pc”)),atmark), 
mk-sd(hd(p))(£)(e)(e)(c(v)(stk))) 

NULL statements have no effect. 

(553) SS [ VARASSN atmark ref expr ] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 

let d = T [[ ref J (t)(p) in 
E [ref J (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,fi),v,stk. 

R I expr 1 (t)(p)(k 2 )(v){stk) 
where 

k 2 = A(e 2 ,f 2 ),v,stk. 

let precondition = nconc 

(mk-constraint-guards 

((e 2 ))((d))(t) 

(p)(v)(stk)Ji,f 2 ) in 

(mk-sd 

(hd(p))(precondition)(£)((ei)) 

(nconc 

(assign(d)((ei ,e 2 )), 
c(v)(stk))))) 

assign(d)( target, value) 

= (case tag(d) 

(♦BOOL* ,*BIT* ,*INT* ,*REAL* ,*TIME* ,*VHDLTIME* ,*ENUMTYPE* ,*WAVE* ,*VOID* , 
♦POLY* ) 

—► (mk-rel(d)((EQ ,pound(target),value))), 

♦SUBTYPE* —♦ assign(base-type(d))((target,value)), 

♦INT^TYPE* —assign(parent-type(d))((target,value)), 

♦ARRAYTYPE* 

—+ (is-bitvector-tdesc?(d) 

(is-constant-bitvector?(vcdue) 

—(case direction(d) 

TO 

—► assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 

assign-array-downto 

(target)(value)(elty(d)) 

(mk-exp2 
(SUB , 


160 



mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)),1))(0), 
OTHERWISE impl-error(“Illegal direction: ~a”,direction 

(d))), 

(mk-reI(d)((EQ ,pound(target),value)))), 
is-string-tdesc?(d) 

—^ (is-constant-string?(v^ue) 

—»• (case direction(d) 

TO 

assign-array-to 

(target)(value)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 
—► assign-array-downto 

(target )(value)(elty(d)) 

(mk-exp2 
(SUB , 

mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)),1))(0), 
OTHERWISEimpl-error(“Illegal direction: ~a”,direction 

(d))), 

(mk-rel(d)((EQ ,pound(target),value)))), 

(dotted-expr-p(value)—► (mk-rel(d)((EQ ,pound(target),value))), 

(case direction(d) 

TO —► aissign-array-to(target)(vaIue)(elty(d))((ORIGIN ,target))(0), 

DOWNTO 

—► assign-array-downto 

(target) (value)(elty(d)) 

(mk-exp2 

(SUB ,mk-exp2(ADD ,(ORIGIN ,target),(RANGE ,target)), 

1 ))( 0 ), 

OTHERWISE —>■ impl-error(“Illegal direction: "'a”,direction(d))))), 

♦RECORDTYPE* 

—+ (dotted-expr-p( value)assign-record (d)(( target, value)), 
assign-record-fields(components(d))((target, value))), 

OTHERWISEiinpl-error(“Unrecognized Stage 4 VHDL type tag: ^a”,tag(d))) 


The translation of a variable assignment statement first translates its left and right parts, 
obtaining translated expressions and guard formulas. Note that the left part is translated 
by E and is therefore not dereferenced (by application of the dot function), as it would be if 
R were used instead. The precondition of the generated state delta consists of the combined 
lists of guard formulas, and its mod list is the translated left part. Its postcondition asserts 
the new value of the left part place, and then asserts succeeding state deltas by appropriately 
using the continuation c. Assignments in Stage 4 VHDL can be scalar or can assign entire 
arrays. Entire array assignments are asserted element by element via auxiliary semantic 
function array-signal-assignment. 

(SS4) ^ I SIGASSN atmark delay-type ref waveform J (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let d = T [ ref | (t)(p) in 
(case tag(d) 

(*BOOL* ,*BIT* ,*INT* ,*REAL* ,*TIME* ,*ENUMTYPE* ,*SUBTYPE* , 
*INT_TYPE* ) 

—► scaJar-signal-assignment 

(seq-stat)(delay-type)(ref)(waveform)(d)(t)(p)(c)(v)(stk), 

*ARRAYTYPE* 

—*• array-signal-assignment 


161 



(atmark)(delay~type)(ref) (waveform) (t)(p)(c)(v)(stk), 

OTHERWISE 

—► impl-error 

(“Signal assignment not implemented for object ”,ref, 

“ of type ”,d))) 

scalar-signal-assignment(seq-stat)(delay-type)(ref)(waveform)(d)(t)(p)(c)(v)(stk) 

=: E [ref] (t)(p)(k)(v)(stk) 
where 

k = A(signal-name,guard),v,stk. 

let driver-name = name-driver(signal-name) in 
W [ waveform J (d)(t)(p)(wave-cont)(v)(stk) 
where 

wave-cont = A(trans*,guard* ),v,stk. 

let all-guards = nconc(guard,guard*) in 
(delay-type = TRANSPORT 
—► (mk-sd 

(hd(p))(all-guards)(e)( (driver-name)) 

(nconc 

(assign 

(waveform-type-desc(d)) 

((driver-name, 

mk-transport-update 

(dot(driver-name))(trans*))), 
c(v)(stk)))), 

let earliest-new-transaction = hd(trans’) in 
(mk-sd 
(hd(p)) 

(cons(mk-preemption 

(dot(driver-name)) 

(earliest-new-transaction),all-guards))(e)( (driver-name)) 

(nconc 

(assign 

(waveform-type-desc(d)) 

((driver-name, 

mk-inertiad-update 

(dot(driver-name))(trans*))), 
c(v)(stk))), 

mk-sd 

(hd(p)) 

(cons(mk-not 

(mk-preemption 

(dot(driver-name)) 

(earliest-new-transaction)), 
all-guards) )(£)( (driver-name)) 

(nconc 

(assign 

(waveform-type-desc(d)) 

((driver-name, 

mk-inertial-update 

(dot(driver-name))(trans*))), 
c(v)(stk))))) 

waveform-type-desc(type-desc) = <WAVEFORM ,£ *WAVE* .(STANDARD) ,tt ,type-desc> 
mk-transport-update(dot-driver)(trans*) 

= cons(TRANSPORT-UPDATE ,cons(dot-driver,trans*)) 


162 



mk-preemption (dot-driver) (transaction) 

= (PREEMPTION ,dot-driver,transaction) 

mk-inertiaJ~update(dot-driver)(trans*) 

= cons(INERTIAL^UPDATE ,cons(dot-driver,trans*)) 

mk-not(e) = (NOT ,e) 


array-signal-assignment(atmark)(delay-type)(ref)(waveform)(t)(p)(c)(v)(stk) 

= let seq-stat"^ = cascade-array-signal-assignment 

(atmark)(delay-type)(ref)(waveform)(t)(p)(c)(v)(stk) in 
SS [[ seq-stat"*" | (t)(p)(c)(v)(stk) 

cascade-array-signal-assignment(atmark) (delay-type)(ref)(agg-wave) (t)(p)(c)(v)(stk) 

let array-refs = mk-array-refs(ref)(t)(p)(c)(v)(stk) 

and element-waves =: mk-element-waves(agg-wave)(t)(p)(c)(v)(stk) in 
mk-scalar-signal-assignments(atmark)(delay-type)(array-refs)(element-waves) 

mk-scalar-signal-assignments(atmark)(deiay-type)(array-refs)(element-waves) 

= (n ull( array-refs )—► £, 

cons((SIGASSN ,atmark,delay-type,hd(array-refs),hd(element-waves)), 
mk-scalar-signal-assignments 

(atmark)(delay-type)(tl(array-refs))(tl(element-waves)))) 

mk-array-refs(ref)(t)(p)(c)(v)(stk) 

= let d = T [ ref I (t)(p) in 
let direction = direction(d) 
and expri = lb(d) 
and expr 2 = ub(d) in 
R[ expri 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

R[expr 2 1 (t)(p)(k 2 )(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 

let sref = hd(second(ref)) 

and indices = (direction = TO 

—► gen-ascending-indices(ei )(e 2 ), 
gen-descending-indices(ei )(e 2 )) in 
mk-array-refs-aux(sref)(indices) 

gen-ascending-indices(min)(max) 

— (min > max —► e, cons(min,gen-ascending-indices(min-fl)(max))) 
gen-descending-indices(min)(max) 

= (max < min —^ e, cons(max,gen-descending-indices(min)(max-l))) 

mk-array-refs-aux(sref )(indices) 

= (null(indices)—► e, 

cons((REF ,(sref,(INDEX ,(NUM ,hd(indices))))), 
mk-array-refs-aux(sref)(tl(indices)))) 

mk-element-waves(agg-wave)(t)(p)(c)(v)(stk) 

= let aggregate-transactions = second(agg-wave) in 

let element-transaction-lists = mk-element-transaction-lists 

(aggregate-transactions)(t)(p)(c)(v)(stk) in 
mk-element-waves-aux(element-transaction-lists) 


163 



mk-element-transaction-lists(aggregate-transactions)(t)(p){c)(v)(stk) 

= (null(aggregate-transactions)— e, 

cons(mk-transaction-list(hd(aggregate-transactions))(t)(p)(c)(v)(stk), 

mk-element-transaction-lists{tI(aggregate-transactions))(t)(p)(c)(v)(stk))) 

mk-transaction~list(agg-trans)(t)(p)(c)(v)(stk) 

= let agg-value-expr = second(agg-trans) 

and time-expr = third(agg-trans) in 
let element-value-exprs = (case hd(agg-value-expr) 

REF 

—♦ mk-array-refs( agg-vzJue-expr) (t) (p) (c) (v) (stk), 

(BITSTR ,STR ,PAGGR ) - hd(tl(agg-value-expr)), 
OTHERWISE 
—impl-error 

(“Illegal aggregate in transaction: ”, 
agg-value-expr)) in 

mk-simultaneous-transactions(eIement-value-exprs)(time-expr) 

mk-simultaneous-transactions(expr*)(time-expr) 

= (null(expr*)— e, 

cons((TRANS ,hd(expr*),tiine-expr), 
mk-simultaneous-transactions(tl(expr*)) (time-expr))) 


(SS5) ^ [ IF atmark cond-parf*" else-part J (t)(p)(c)(v)(stk) 

— cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let seq-stat* = else-part in 
gen-if(cond-parf*' )(seq-stat*)(seq-stat)(t)(p)(c)(v)(stk)) 

gen-if(cond-part*)(seq-stat*)(ifclause)(t)(p)(c)(v)(stk) 

= (null(cond-part*)-^ SS [[ seq-stat* ] (t)(p)(c)(v)(stk), 
let (expr,seq-statf) = hd(cond-part*) in 
R [ expr 1 (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi ,stki. 

(mk-sd 

(hd(p))(cons(e,f))(£)(e) 

(let Cl = Av 2 ,stk 2 .SS [f seq-stat? J (t)(p)(c)(v 2 )(stk 2 ) in 
ci(vi)(stki)), 
mk-sd 

(hd(p))(cons(mk-not(e),f))(e)(e) 

(let C 2 = Av3,stk3. 

gen-if 

(tl(cond-part* ))(seq-stat*)(£)(t)(p)(c)(v3)(stk3) in 
C2(vi)(stki)))) 

The abstract syntax of a Stage 4 VHDL IF statement consists of a finite, nonempty list of 
cond-parts followed by a (possibly empty) else-part. Each cond-part corresponds to an 
IF expr THEN seq-stats or an ELSIF expr THEN seq-stats construct in the concrete 
syntax. Thus each cond-part must be translated into two state deltas: one for the case 
where expr evaluates to true and the other where it evaluates to false. The translation is 
performed by auxiUary semantic function gen-if, which takes as arguments (among others): 
the cond-part bst and the seq-stats comprising the else-part. Successive recursive calls 
of gen-if process the first element of their cond-part list, reducing it to empty. When the 
cond-part list is empty, gen-if produces the translation of the else-part. The function 
mk-not constructs the logical negation of its argument. 


164 



(SS6) ^ I CASE atmark expr case-alf*' J (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 

R [expr I (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

let d = T J expr | (t)(p) in 
gen-case(e)(d)((e,f))(case-alt+)(t)(p)(c)(v)(stk)) 

gen-case(g)(d)(e,f)(case-a]t*)(t)(p)(c)(v)(stk) 

= (null(case-alt*)—♦ e, 

let (h,sd) = gen-alt(g)(d)((e,f))(hd(case-a]t*))(t)(p)(c)(v)(stk) in 
cons(sd,gen-case(append(g,h))(d)((e,f))(t!(case-alt*))(t)(p){c)(v)(stk))) 

gen-alt(g)(d)(e,f)(case-alt)(t)(p)(c)(v)(stk) 

= let ccLse-cdt-tag = hd(case-alt) in 
(case-alt-tag = CASEOTHERS 

let seq-stat* = hd(tl(case-alt)) in 
let Cl = Avi ,stki .SS J seq-stat* ]] (t)(p)(c)(vi )(stki) in 

mk-sd 

(hd(p))(append(f,(mk-not(mk-ors(g)))))(£:)(£:) 

(ci(v)(stk))), 

let (case-set,seq-stat*) = tl(case-alt) in 
let Cl = Avi ,stki .SS I seq-stat* I (t)(p)(c)(vi)(stki) in 
let h = append(f,gen-guard(case-set)(d)(e)(t)(p)) in 
(h,mk-sd(hd(p))(h)(e)(e)(ci(v)(stk)))) 

mk-ors(disjs) 

= (case length(disjs) 

1 hd(disjs), 

2 —mk-or(hd(disjs))(hd(tl(disjs))), 

OTHERWISE - mk-or(hd(disjs))(mk-ors(tl(disjs)))) 

mk-or(el,e2) 

= (null(el)—» e2, 
null(e2)—► el, 
consp(el)A consp(e2) 

^ (hd(el)= OR 

—► (hd(e2)= OR —► cons(OR ,append(tl(el),tl(e2))), append(el,(e2))), 
hd(e2)= OR —*■ nconc((OR ,el),tl(e2)), 

(OR ,el,e2)), 

(OR ,el,e2)) 

gen-guard (discrete-range* )(d)(e)(t)(p) 

= (null(discrete-range*)—► £, 

let (direction,expri ,expr 2 ) = hd(discrete-range*) in 
R [expr, ] (t)(p)(ki)(e)(e) 
where 

ki = A(ei,fi),vi,stki. 

(expri = expr 2 

—►let h = nconc(fi ,(mk-rel(d)((EQ ,e,ei)))) in 
(null(tl(discrete-range*))—► h, 

(cons(OR , 

cons(hd(h),gen-guard(tI (discrete-range* ))(d)(e)(t)(p))))), 
R I expr 2 I (t)(p)(k 2 )(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 


165 



let h = nconc 

(direction = TO 

^ ((AND ,mk-rel(d)((GE ,e,ei)), 
mk-rel(d)((LE ,6,62)))), 
((AND ,mk-rel(d)((LE ,e,ei)), 
mk-rel(d)((GE ,6,62)))))) in 

(cons(OR , 
cons(hd(h), 

gen-guard(tl(discrete-range*))(d)(e)(t)(p)))))) 


The abstract syntax of a CASE statement consists of a selector expression followed by a 
finite, nonempty list of case alternatives. Each case alternative consists of a list of sequential 
statements, preceded either by a nonempty list of discrete ranges (indicated by CASECHOICE) 
or (for the last alternative only) by CASEOTHERS. Each of these discrete range lists represents 
a set of values, called a case selection set. If the selector expression evaluates to one of these 
values, then the corresponding sequential statement list is executed, after which control 
passes to the successor of the CASE statement. CASEOTHERS represents a case selection set 
that is the complement of the union of aU of the other case selection sets relative to the set 
of values in the selector expression’s type. Phase 1 has ensured that no case selection sets 
intersect. 

The Phase 2 translation of a CASE statement first processes its selector expression, obtaining 
a translated expression and a guard formula. The translation is completed by the function 
gen-case, which takes the following arguments: 

• a formula, initially empty, that is the disjunction of formulas representing the case 
selection sets of case alternatives translated so far in this CASE statement — this for¬ 
mula’s negation represents the case selection set indicated by CASEOTHERS (if present) 
in the CASE statement; 

• the basic type of the selector expression (and the case selection set elements); 

• the selector expression’s translation and guard formula; and 

• a list of case alternatives. 

Each successive recursive call to gen-case processes the first element of its case alternative 
list, reducing the list to empty, at which time processing terminates normally. Each case 
alternative is processed by auxiliary semantic function gen-alt, which returns a formula 
representing the case selection set for that alternative and a state delta representing the 
execution of the corresponding sequential statement list. This formula and state delta are 
collected by gen-case; the final result returned by gen-case is a list of state deltas. The 
function gen-guard converts discrete range lists into formulas representing case selection 
sets. The function mk-or(formulai, formula^) constructs the logical disjunction of two 
formulas; if one of the formulas is empty, then mk-or ignores it and returns the nonempty 
one. 

(SS7) SS [ LOOP atmark id seq-stat* opt-id J (t)(p)(c)(v)(stk) 


166 



= let Ip-desc = <*LOOP-EXIT* ,id,p,Av,s.c(v)(s)> in 
let stki = stk-push(lp-desc)(stk) in 
cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
loop-infinite(seq-stat)(id)(seq-stat* )(t)(%(p)(id))(c)(v)(stki)) 

loop-infinite(seq-stat)(id)(seq-stat* )(t)(p)(c)(v)(stk) 

= let Cl = Av,stk. 

SS [seq-stat* J (t)(p)(c2)(v)(stk) 
where 
C2 = Av,stk. 

loop-infinite(seq-stat)(id)(seq-stat*)(t)(p)(c)(v)(stk) in 
(tnk-sd(hd(p))(e)(e)(e)(ci(v)(stk))) 


(SS 8 ) SS [[ WHILE atmark id expr seq-stat* opt-id | (t)(p)(c)(v)(stk) 

= let Ip-desc = <*LOOP“EXIT* ,i<i,P>^v,s.c(v)(s)> in 
let stko = stk-push(lp-desc)(stk) in 
cons((EQ ,pound(catenate(lid(p),“\pc”)),atmark), 
loop-while(seq-stat)(id)(expr) (seq-stat* )(t)(%(p)(id))(c)(v)(stko)) 

loop-while(seq-stat)(id)(expr)(seq-stat* )(t)(p)(c)(v)(stk) 

= R [[ expr I (t)(p)(k){v)(stk) 
where 

k = A(e,f),v,stk. 

let Cl = Av,stk, 

S^ [[ seq-stat* | (t)(p)(c2)(v)(stk) 
where 
C2 = Av,stk. 

loop-while 

(seq-stat) (id)(expr)(seq-stat* )(t)(p)(c)(v) 
(stk) in 

(mk-sd 

(hd(p))(cons(e,f)){e)(e)(ci(v)(stk)), 

mk-sd 

(hd(p))(cons(mk-not(e),f))(e)(e) 

(c(v)(stk-pop(stk)))) 


(SS 9 ) ^ [ FOR atmark id ref discrete-range seq-stat* opt-id ] (t)(p)(c)(v){stk) 

= let d = T I ref | (t)(p) in 

let Ip-desc = <*LOOP-EXIT* ,id,P, 

Av,s-c(v)(s)> in 

let stko = stk-push(lp-desc)(stk) in 
let (direction,expri ,expr2) = discrete-range in 
cons((EQ ,pound(catenate(hd(p),‘Ape”)),atmark), 

R I expn I (t)(p)(k) )(v)(stko) 
where 

ki = A(ei,f|),vi,stki. 

R|expr2 ](t)(p)(k2)(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 

let bk-desc = <*BLOCK-EXIT* ,id,p,Av,s.c(v)(s)> in 
let decl = (DEC ,CONST , 

(last(hd(hd(tl(ref))))), 
(hd(d)),hd(tl(discrete-range))) in 
D|decll(t)(%(p)(id))(u)(v2) 

(stk-push(bk-desc)(stk2)) 


167 


where 
U = Av 3 ,stk 3 . 

let bg-desc = <*BEGIN* ,id,%(p)(id), 

Av,s.ci(v)(s)> in 

(mk-sd 

{hd(p))(nconc(fi,f2))(e)(£) 

((case tag(d) 

*INT* 

—^ let finaJ-iter-val = eval-expr 
(es) in 

loop-for-int 

(seq-stat)(ref)(d) 

(direction) 

(final-iter-vaJ) 

(seq-stat*)(t)(%(p)(id))(ci) 

(va) 

(stk-push(bg-desc)(stk3)), 

*ENUMTYPE* 

—► let initial-iter-val = eval-expr 

(ei) 

and final-iter-val = eval-expr 
(^2) 

and enum-lits = literals 

(d) in 

let parameter-updates = tl(get-loop-enum-param-vals 

(initial-iter-val) 

(final-iter-val) 

(direction) 

(enum-lits)) in 

loop-for-enum 

(seq-stat)(ref)(d) 

(direction) 

(parameter-updates) 

(final-iter-val) 

(seq-stat*)(t)(%(p)(id)) 

(Cl)(v 3 ) 

(stk-push 

(bg-desc)(stk 3 )), 

OTHERWISE 

impl-error 

(“Illegal FOR loop parameter type: “a”, 

d)))) 

where 

Cl = Av 4 ,stk4 . 

block-exit(v4 )(stk4)) 

loop-for-int(seq-stat)(ref)(d)(direction)(final-iter-val)(seq-stat*)(t)(p)(c)(v)(stk) 

= EIrefl(t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

R I ref I (t)(p)(ki)(v)(stk) 
where 

ki = A(ei ,fi ),vi ,stki. 

let Co = AvojStko. 

SS Jseq-stat* ] (t)(p)(ci)(vo)(stko) 

where 

Cl = Av2,stk2. 


168 



(mk-sd 

(hd(p))(£)(e)((e)) 

(cons(mk-rel 

(d) 

((EQ ,pound(e), 

(direction = TO 
mk-exp2(ADD 
mk-exp2(SUB ,ei,l)))), 
loop-for-int 

(seq-stat)(ref)(d)(direction) 

(final-iter-val)(seq-stat* )(t) 

(P)(c)(v2)(stk2)))) in 

(mk-sd 

(hd(p)) 

(cons(mk-rel 

(d) 

(((direction = TO — LE , GE ),ei ,final-iter-val)),fi ))(«)(e)(co(vi )(stki)), 

mk-sd 

(hd(p)) 

(cons(mk-rel 

(d) 

(((direction = TO — GT , LT ),ei ,final-iter-val)),fi ))(e)(e) 

(c(vi)(stki))) 


loop-for-enum(seq-stat)(ref)(d)(direction)(parameter-updates)(iinal-iter-val)(seq-stat*)(t)(p)(c)(v)(stk) 

= E I ref ] (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

R I ref J (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

let Co = Avo,stko. 

SS [[ seq-stat* | (t)(p)(ci)(vo)(stko) 
where 

Cl = Av2,stk2. 

(parameter-updates 
—> (mk-sd 

(hd(p))(e)(e)((e)) 

(cons(mk-rel 

(d) 

((EQ ,pound(e), 
hd (parameter-updates))), 
loop-for-enum 

(seq-stat)(ref)(d) 

(direction) 

(tl(parameter-updates)) 

(iinal-iter-val) (seq-stat*) 

(t)(p)(c)(V2)(stk2)))), 

(mk-sd 

(hd(p))(«)(e)(£) 

(c(v2)(stk2)))) in 

(mk-sd 

(hd(p)) 

(cons(mk-rel 

(d) 

(((direction = TO ^ LE , GE ),ei ,final-iter-val)),fi ))(e)(£)(co(vi )(stki)), 

mk-sd 


169 



{hd(p)) 

(cons(mk-rel 

(d) 

(((direction = TO GT , LT ),ei ,final-iter-val)),fi ))(e)(£) 
(c(vi)(stki))) 


A loop — i.e., a LOOP, WHILE, or FOR statement — has a label (used for leaving that loop 
by means of an EXIT statement) and a body consisting of sequential statements. When a 
loop is entered, a new local environment is created (signified by an extended path in the 
TSE), and a *LOOP-EXIT* descriptor is pushed onto the execution stack, to be used by 
EXIT statements to leave the loop properly. The continuation in the descriptor is that of 
the loop statement itself. 

In the case of a simple LOOP statement, the loop is nonterminating, and a recursive state 
delta is generated by auxiliary semantic function loop-infinite. 

In the case of a WHILE statement, auxiliary semantic function loop-while first processes the 
control expression, yielding its translation and a guard formula, and then uses these items 
to generate two state deltas, one of which is recursive. The recursive state delta represents 
the situation where the control expression is true and the loop’s body is executed; recursion 
stems from the appearance of loop-while in the continuation of the loop body’s translation. 
The execution stack remains unchanged in this case. The other state delta represents the 
case where the loop is exited “naturally” by virtue of its control expression having the value 
false. The postcondition of this state delta is the loop statement’s continuation applied to 
the result of popping the loop statement’s descriptor from the execution stack. 

The case of a FOR statement is analogous to that of the WHILE statement, only more complex 
technically. 

(SSlO) SS J EXIT atmark opt-dotted-name opt-expr ] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let expr = opt-expr in 
R I expr I (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi ,stki. 

let loop-name = (null(opt-dotted-name)—^ e, 
last(opt-dotted-name)) in 
(null(e)—► exit(loop-name)(vi )(stk), 

(mk-sd 

(hd(p))(cons(e,f))(e)(£) 

(ci(vi)(stki) 

where ci = Av2,stk2.exit(loop-name)(v2)(stk2)), 
mk-sd 

(hd(p))(cons(mk-not(e),f))(€)(e) 

(c(vi)(stki))))) 

exit(loop-name)(v)(stk) 

= let <tg,id,p,g> = hd(stk) in 
(case tg 

*LOOP-EXIT* 

—► (-inull(loop-name)A id ^ loop-name —+ exit(Ioop-name)(v)(stk-pop(stk)), 
g(v)(stk-pop(stk))), 

’•‘UNDECLARE* —► g(Avv,s.exit(loop-name)(vv)(s))(v)(stk), 


170 



(*BEGIN* ,*BLOCK-EXIT* ) -- exit(loop-name)(v)(stk-pop(stk)), 
OTHERWISE-^ execution-error("*** EXECUTION ERROR -- ILLEGAL EXIT *♦*”)) 


An EXIT statement: 


• transfers control from the interior of a loop to the immediate successor of that loop, 
provided that the EXIT statement’s condition (if any) is satisfied; and 

• adjusts the state of SDVS to reflect that transfer of control. 


The loop being exited can be named in the EXIT statement; Phase 1 has ensured that an 
appropriate label is used. If a loop is named, then that loop is exited. If no name appears, 
then the smallest loop enclosing the EXIT statement is exited. The EXIT statement may be 
enclosed within a system of nested loops. When the loop statement is exited, these other 
loops must first be exited in the order opposite that in which they were entered. When a 
FOR loop is exited, the effect of its implict local declaration of the iteration parameter is 
reversed by encountering an *UNDECLARE* descriptor on the execution stack. 

The translation of an EXIT statement first processes its control expression (which may be 
empty), resulting in a translated expression and a guard formula. If the control expression 
is nonempty, two state deltas are generated. The first represents the case where the control 
expression has the value true; in this case the exit process proceeds by invoking the semantic 
function exit, which appears in the state delta’s postcondition. The other state delta 
represents the case where the control expression has the value false, whereupon the exit 
does not occur and control passes to the immediate successor of the EXIT statement. If the 
control expression is empty, the exit is unconditional; the second state delta is not even 
generated. 

(SSll) SS [[ CALL atmark ref ]] (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let basic-ref = second (ref) in 
let (tg,q,id) = hd(basic-ref) in 
let d = t(q)(id) in 

let expr* = second(second(bcLsic-ref)) in 
gen-calI(ref)(d)(expr*)(tt)(fF)(t)(p)(c)(v)(stk)) 

gen-call (ref) (d)(expr* )(gen-guards?)(no-unbind?)(t)(p)(c)(v)(stk) 

= let z = hd(p) 

and q = %(path(d))(idf(d)) in 
let (decr,seq-stat*) = body(d) in 
bind-parameters(ref)(d)(expr*) (gen-guards?) (t)(p)(u)(v)(stk) 
where 
u = Avi ,stki. 

let sp-desc = <*SUBPROGRAM.RETURN* ,idf(d),p,Av,s.c(v)(s)> 

and par-desc = <*UNDECLARE* ,colIect-allpars(extract-pars(d)(t)),p, 

Aci ,V 4 ,Stk 4 . 

(mk-sd 

(z)(£)(£)(£) 

(cons((EQ ,pound(catenate(z,“\pc”)), 

(EXITED ,$(path(d))(idf(d)))), 
unbind-parameters 


171 



(ref)(d)(expr*)(no-unbind?)(t)(p)(ci) 
(V 4 )(stk 4 ))), 

mk-sd 

(z) 

(((EQ ,dot(catenate(z/‘\pc”)), 

(EXITED ,$(path(d))(idf(d))))))(e)(£) 
(unbind-parameters 

(ref)(d)(expr*)(no-unbind?)(t)(p)(ci )(v4) 
(stk4)))> in 

let stks = stk-push(par-desc)(stk-push(sp-desc)(stki)) in 
(mk-sd 

(z)(e)(e)(£) 

(cons((EQ ,pound(catenate(z,“\pc”)), 

(AT ,$(path(d))(idf(d)))), 

U 2 (vi)(stk 5 )))) 

where 

U2 = AvejStke- 

(null(characterizations(d)) 

^ D I decl* I (t)(q)(U))(v6)(stk6), 
null(seq-stat*) 

—f gen-characterizations 

(e)(p)(characterizations(d))(c2 )(v6 )(stk6) 
where 

C2 = Av 7 ,stk 7 . 

unbind-parameters 

(ref)(d)(expr*)(no-unbind?)(t)(p)(c3) 

(V 7 )(stk 7 ) 

where C3 = Av8,stk8.block-exit(v8)(stk8), 
impl-error 

(“Offline Characterization not yet implemented 
for procedures with nonempty bodies !”)) 

where 

Ul = Av2,stk2. 

let bg-desc = <*BEGIN* ,idf(d),q,Avv,s.ci (vv)(s)> in 
SS [seq-stat* | (t)(q)(ci)(v2)(stk-push(bg-desc)(stk2)) 
where ci = Av3,stk3.block-exit(v3)(stk3) 

gen-characterizations(sds)(p) (characterizations) (c)(v)(stk) 

= (null(characterizations)—♦ fix-characterized-sds(sds)(c(v)(stk)), 
let (q,id,parnames,pre,mod) = hd(characterizations) in 
let post = sixth(hd(characterizations)) in 
gen-characterizations 

(cons(gen-characterization(hd(p))($(q)(id))(parnames)(pre)(mod)(post)(v),sds)) 

(p)(tl(characterizations))(c)(v)(stk)) 

gen-characterization(z)(qid)(parnames)(pre)(mod)(post)(v) 

= let sd = mk-sd 

(z)(((EQ ,dot(catenate(z,“\pc”)),(AT ,qid))))(£:)(mod) 

(append 

(post,((EQ ,pound(catenate(z,“\pc”)),(EXITED ,qid))))) in 
subst-vars(parnames)(v)(sd) 

bind-parameters(ref)(d)(actuals)(gen-guards?)(t)(p)(u)(v)(stk) 

= let z = hd(p) 

and q — %(path(d))(idf(d)) 
and par-assoc-list = extract-pars(d)(t) in 
(null(par-assoc-list)—u(v)(stk), 


172 



let all-formals = get-qids(collect-allpars(par-assoc-list))(t)(q) 

and to-formals = get-qids(collect-topars(par-assoc-list))(t)(q) 
and type-descriptors = colJect-topars-types(par-assoc-list) 
and from-actuals = collect-fromargs(actuals)(par-assoc-list) in 
let Vo = push-universe(v)(z)(all-forinals) in 
let qual-all-formals = get-qualified-ids(aLll-formals)(vo ) 

and qual-to-formaJs = get-qualified-ids{to-formals)(vo) in 
(mk-decl-sd 

(z)(e)(e)((z)) 

(nconc 

(mk-qual-id-coverings(all-forinals)(qual-cdl-formals)(z)(v)(t), 

mk-par-decls(q)(par-assoc-list)(p)(t)(vo), 

(niill(qual-to-formals)—^ u(vo)(stk), 
let expr* = from-actuals in 
MR I expr* | (t)(p)(h)(vo)(stk) 
where 

h = A(e*,r),vi,stki. 
ui(vi)(stki) 
where 

m = Av2,stk2. 

let precondition = (gen-guards? 

—► nconc 

(mk-constraint-guards 
(e*)( type-descriptors) 

(t)(p)(v2)(stk2),r), 

f) in 

(mk-decl-sd 

(z) (precondition) (e) (qual-to-formals) 

(nconc 

(assign-multiple 

(qual-to-formals)(type-descriptors)(e*), 

U(v2)(stk2))))))))) 

extract-pars(d)(t) 

= let signatures = signatures(d) in 
let signature = hd(signatures) in 
(null(tl(signatures))—► pars(signature), 
extract-poly-pars(pars(signature))(t)) 

extract-poly-pars(par-assoc-list)(t) 

= (null(par-assoc-list)—♦ e, 

let par = hd(par-assoc-list) in 
cons((hd(par),(hd(second(par)),poly-type-desc(t))), 
extract-po]y-pars(tl(par-assoc-list))(t))) 

collect-allpars(par-assoc-list) 

= (null(par-assoc-list)—> e, 

let (id,w) = hd(par-£Lssoc-list) in 
cons(id,collect-allpars(tl(par-assoc-list)))) 

collect-topars(par-assoc-list) 

= (null(par-assoc-list)—► e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w ))6 (REF VAL) 

cons(id,collect-topars(tl(par-assoc-list))), 

collect-topars(tl(par-assoc-list)))) 



collect-fromargs(actuals)(par-assoc-list) 

= (null(par-assoc-list)—*■ e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))G (REF VAL) 

—► cons(hd (actuals),collect-fromargs( tl (actuals)) (tl(par-a5soc-list))), 
collect-fromargs( tl (ac tu als)) (tl (par- assoc-list)))) 

collect-frompars(par-assoc-list)(p) 

= (null(par-assoc-list)—>• e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))€ (REF OUT) 

^ cons((REF ,((SREF ,p,id))), 

collect-frompars(tl(par-assoc-list))(p)), 
collect-from pars( tl (par-assoc-lis t)) (p))) 

collect-toargs(actuals-ids)(par-assoc-list) 

= (null(actuals-ids)—► e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))€ (REF OUT) 

—► cons(hd(actuals-ids),collect-toargs(tl(actuals-ids))(tl(par-assoc-list))), 
collect-toargs(tl(actuals-ids))(tl(par-assoc-list)))) 

collect-topars-types(par-assoc-list) 

= (null(par-assoc-list)—► e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tmode(w))G (REF VAL) 

—► cons(tdesc(w),collect-topars-types(tl(par-assoc-list))), 
collect- topars-ty pes (tl (par- assoc-list)))) 

collect-toargs-ty pes(actuals) (par-assoc-list) (t) (p) 

= (null(actuals)-^ e, 

let (id,w) = hd(par-assoc-list) in 
(ref-mode(tinode(w))6 (REF OUT) 

—^ let expr = hd(actuals) in 
cons(T I expr ]) (t)(p), 

collect-toargs-types(tl(actuals))(tl(par-assoc-list))(t)(p)), 
collect-toargs-types(tl(actuals))(tl(par-assoc-list))(t)(p))) 

collect-guards-for-exprs(expr*)(d*)(t)(p)(v)(stk) 

= MR [ expr* J (t)(p)(h)(v)(stk) 

where h = A(e*,f*),v,stk.mk-constraint-guards(e*)(d*)(t)(p)(v){stk) 

mk-constraint-guards(e* )(d*)(t)(p)(v)(stk) 

= (null(e*)-^ e, 
let e = hd(e*) 

and d = hd(d*) in 

(-(tag(d)e (*INT* *SUBTYPE* ♦INT.TYPE*) ) 

—► mk-constraint-guards(tl(e*))(tl(d*))(t)(p)(v)(stk), 

(tag(d)= *INT* —► mk-constraint-guards(tl(e*))(tl(d*))(t)(p)(v)(stk), 
let dd = (tag(d)= *SUBTYPE* base-type(d), parent-type(d)) 
and expri = type-tick-low(d) 
and expr2 = type-tick-high(d) in 
R, I expr, I (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi),vi,stki. 

Rlexpr2 J (t)(p)(k2)(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 
nconc 

((ei (mk-rel(dd)((LE ,ei,e))), e), 

(e2 —*• (mk-rel(dd)((LE ,0,62))), e), 
mk-constraiiit-guards(tl(e*))(tl(d*))(t)(p)(v)(stk))))) 


174 



mk-par-decls(q)(par-assoc-list)(p)(t)(v) 

= (null(par-assoc-list)—*• e, 

let (id,w) = hd(par-assoc-list) in 

cons((DECLARE ,qualified-id(qid(t(q)(id)))(v),mk-type-spec(tdesc(w))(t)(p)), 
mk-par-decls(q)(tl(par-assoc 4 ist))(p)(t)(v))) 

assign-multiple(duqn* )(type-descriptors)(e*) 

= (null(duqn* e, 

let target = hd(duqn*) 

and d = hd(type-descriptors) 
and source = hd(e*) in 
nconc 

(assign(d)(( target,source)), 

assign-multiple(tl(duqn*))(tl(type-descriptors))(tl(e*)))) 

unbind-parameters(ref)(d)(actuals)(no-unbind?)(t)(p)(c)(v)(stk) 

= let z = hd(p) 

and q = %(path(d))(idf(d)) 
and par-assoc-list = extract-pars(d)(t) in 
let all-formaJs = get-qids(collect-allpars(par-assoc-list))(t)(q) in 
let qual-all-formals = get-quaiified-ids(all-formals)(v) in 
(null(qual-all-forinals) 

—^ (mk-sd 

(c(pop-universe(v)(all-formals))(stk-pop(stk)))), 

(no-unbind? 

^ (mk-sd 

(z) (£)(€: )(cons(z,quaJ-all-formals)) 

(cons(mk-cover-already((dot(z),cons(pound(z),qual-aIl-formaJs)))(t), 
cons(mk-undeclare(qual-aIl-formals), 
c(pop-universe(v)(2dl-formals))(stk-pop(stk)))))), 
let exprj = actuals in 
MR [ exprj ] (t){p)(hi )(v)(stk) 
where 

hi = A(eJ,fn,vi,stki. 

let to-actuals = collect-toargs(underef(et))(p 3 'r- 3 'Ssoc-list) in 
let qual-to-actuals = get-qualified-ids(to-actuals)(vi) in 
(null(qual-to-actuals) 

—^ (mk-sd 

(z)(e)(e)(cons(z,qual-all-formals)) 

(cons(mk-cover-already 

((dot (z),cons( pound (z),qual-all-formals) ))(t), 
cons(mk-undeclare(qual-all-formaIs), 
c(pop-universe(vi )(all-formals))(stk-pop(stki)))))), 
let from-formals = collect-frompars(par-assoc-list)(q) 
and type-descriptors = collect-toargs-types 

(actuals)(par-assoc-list)(t)(p) in 

let exprj = from-formals in 
MR I exprj ] (t)(q)(h2)(vi)(stki) 
where 

h2 •= A(e5,f2),V2,stk2. 

Ui(V2)(stk2) 

where 

Ui = AvsjStka. 

let guard* = nconc 

(collect-guards-for-exprs 

(from-formals) 


175 



(type-descriptors)(t) 

{q)(v 3 )(stk 3 ),ft, 

f2) in 

(mk-sd 

(z)(guard* )(e)(qual-to-actuals) 

(nconc 

(assign-multiple 

(qual-to-actuals) 

(type-descriptors)(eJ), 

U 2 (v 3 )(stk 3 )))) 

where 

U2 = Av4,stk4. 

(mk-sd 

(z)(£)(e) 

(cons(z,qual-all-formals)) 

(cons(mk-cover-aLlready 
((dot(z), 
cons(pound(z), 
qual- all-form aJs)))( t ), 
cons(mk-undecIare 

(quaJ-all-formals), 

c(pop-universe 

(V4) 

(aJl-formals)) 

(stk-pop(stk4))))))))) 

underef(actuals) 

= (null(actuals)—► e, 

let actual = hd(actuals) in 

(dotted-expr-p(actual)—► cons(second(actual),underef(tl(actuals))), 
cons(actual,underef(tl(actuals))))) 

mk-cover-already(id,lst)(t) 

= (new-declarations()—♦ mk-rel(univint-type-desc(t))((EQ ,hd(lst),id)), 
mk-cover(id,lst)) 

mk-undeclare(lst) = cons(UNDECLARE , 1 st) 

Procedure calls in Stage 4 VHDL use call by value-result semantics. The translation of a 
procedure call consists of the following steps: 

• The actual parameters are translated and then gen-call pushes a subprogram return 
descriptor and then a (single) undeclaration descriptor for all of the formal parameters 
onto the execution stack. 

• SDVS declarations of all of the formal parameters are emitted (in bind-parameters). 

• The IN and INOUT formal parameters are bound to their corresponding actual param¬ 
eters by first translating the actual parameters and then in effect assigning them to 
their corresponding formals by emitting appropriate equality relations (as in the trans¬ 
lation of assignment). This is done by auxiliary semantic function bind-parameters. 
In these equality relations, the qualified names of the formal parameters must refer to 
the procedure’s declaration TSE, whereas the qualified names in the actual parame¬ 
ters refer to the procedure’s calling environment. This implements the semantics of 
static binding required by VHDL. 


176 




• The subprogram may have either a specific body or a set of state delta characteriza¬ 
tions, but not both. Different actions are performed in each case. 

1. If the procedure has a body, the procedure’s local declarations and statements 
are translated in the procedure’s declaration environment after first pushing a 
*SUBPROGRAM-RETURN* descriptor on the execution stack. This de¬ 
scriptor will be used to perform a return from the procedure, whether that return 
is explicit via a RETURN statement or implicit via encountering the end of the pro¬ 
cedure’s body. 

2. If the procedure has one or more characterizations, state deltas representing the 
actions of the procedure are produced by the functions gen-characterizations 
and gen-characterization. These two functions use the SDVS functions fixed- 
characterized-sds and subst-vars, part of the implementation of an offline 
characterization mechanism for SDVS [3]. 

• Auxiliary semantic function unbind-parameters is invoked to assign the (final) val¬ 
ues of the INOUT and OUT formal parameters to their corresponding actual parameters 
(which must, of course, have reference types). 


(SS 12 ) SS J RETURN atmark opt-expr ]] (t)(p)(c)(v)(stk) 

= cons{(EQ ,pound(catenate(hd(p),“\pc’’)),atmark), 
let expr = opt-expr in 
R I expr I (t)(p)(k)(v)(stk) 
where 

k = A(e,f),v,stk. 

(nul](e)—► (mk-sd(hd(p))(€:){€:)(e)(returii(v)(stk))), 
let d = context(t)(p) in 
let result-d = tdesc(extract-rtype(d)) in 
let precondition = nconc 

(mk-constraint-guards 

((e))((result-d))(t)(p) 

(v)(stk),f) in 

(mk-sd 

(hd(p))(precondition)(£:) 

((qualified-id(qid(d))(v))) 

(nconc 

(assign(result-d)((qualified-id(qid(d))(v),e)), 

ci(v)(stk) 

where ci = Av,stk.return(v)(stk)))))) 

return(v)(stk) 

= let <tg,qname,p,g> = hd(stk) in 
(case tg 

*UNDECLARE* —*• g(Avv,s.return(vv)(s))(v)(stk), 

(*BLOCK-EXIT* ,*SUBPROGRAM-RETURN* ) - g(v)(stk-pop(stk)), 

(*BEGIN* *LOOP-EXIT* ,*PACKAGE-BODY-EXIT* ) -- return(v)(stk-pop(stk)), 
OTHERWISE 

—+ impl-error(“Bad execution stack descriptor tag in context: ~a”,tg)) 
context(t)(path) 

= let d = t(path)(*UNIT* ) in 

(d = ^UNBOUND* —> context(t)(rest(path)), 

(case tag(d) 

(♦PROCEDURE* ,♦FUNCTION* ,♦PACKAGE* ) t(rest(path))(last(path)), 
OTHERWISE ^ context(t)(rest(path)))) 


177 




extract-rtype(d) 

= let signature = hd(signatures(d)) in 
rtype(signature) 


RETURN statements come in two varieties: with an expression, to effect a return from a 
function, and without an expression, to effect a return from a procedure. If the RETURN is 
from a function, then the expression must first be translated and an assignment of its value 
to the function’s (statically and dynamically uniquely qualified) name must be asserted via 
an equabty relation. Then (no matter whether the RETURN is from a procedure or a function), 
the function return (similar to exit) is invoked to use the topmost ^SUBPROGRAM- 
RETURN* descriptor on the execution stack to return from the subprogram, after first 
effecting exits from intervening loops and effecting necessary undeclarations. The function 
context determines the qualified name of the subprogram from which the return is being 
made. 


(SS13) ^ [[ WAIT atmark ref* opt-expri opt-expr2 | (t)(p)(c)(v)(stk) 

= cons((EQ ,pound(catenate(hd(p),“\pc”)),atmark), 
let Cl = Av,stk. 

(mk-sd 

(hd(p))(e)(£)(£) 

((make-vhdl-try-resume-next-process(hd(p))))) in 
ME [ ref* 1 (t)(p)(h)(v)(stk) 
where 

h = A(e*,r),v,stk. 

let expri = opt-expri in 
R [[ expn ]] {t)(p)(ki )(v)(stk) 
where 

ki = A(ei ,fi),v,stk. 

let expr2 = opt-expr2 in 
R I expr2 ]] (t)(p)(k2)(v)(stk) 
where 

k2 =: A(e2,f2),v,stk. 

let process-id = last(find-process-env 
(t)(p)) in 

let process-qid — qid(lookup 
(t)(p) 

(process-id)) in 

(mk-sd 

(hd(p))(nconc(fi,f2,r))(e)(e) 

((make-vhdl-process-suspend 

(process-qid) 

(get-signals(e*)) 

(ei)(e2)(c)(v)(stk)(c, (v)(stk)))))) 


find-process-env(t)(p) 

= (null(p)V tag(t(p)(*UNIT* ))= ^PROCESS* ^ p, find-process-env(t)(rest(p))) 


get-sign als(signal-names) 

= (null(signal-names)—► e, 

cons(find-signaJ-structure(hd(signal-names)),get-signals(tl(signal-names)))) 


178 



8.4.11 Waveforms and Transactions 

(Wl) W [[ WAVE transaction"*" ] (d)(t)(p)(wave-cont)(v)(stk) 

= TRM [ transaction"^ J (d)(t)(p)(wave-cont){v)(stk) 

(TRMO) TRM [[ e I (d)(t)(p)(wave-cont){v)(stk) = wave“Cont((£:,£))(v)(stk) 

(TRMl) TRM [transaction transaction* | (d)(t)(p)(wave-cont)(v)(stk) 

= TR [ transaction J (d)(t)(p)(trans-cont)(v)(stk) 
where 

trans-cont = A(trans,guard),v,stk. 

TRM [[ transaction* ] (d)(t)(p)(wave-conti)(v)(stk) 
where 

wave-conti = A(trans*,guard*),v,stk. 
wave-con t 

((cons(trans,trans*), 

nconc(guard,guard*)))(v)(stk) 


The transactions in a waveform are translated in order, from left to right. 

(TRl) TR [ TRANS expr opt-expr | (d)(t)(p)(trans-cont)(v)(stk) 

= R I expr 1 (t)(p)(k)(v)(stk) 
where 

k = A(ei ,fi ),v,stk. 

let expr2 = opt-expr in 
R [ exprj J (t)(p)(ki )(v)(stk) 
where 

ki = A(e2 ,f2)>v,stk. 
trans-cont 

((mk-transaction-for-update(ei )(e2), 
nconc 

(mk-constraint~guards 

((e,))((d))(t)(p)(v)(stk),f,,f2))) 

(v)(stk) 

mk-transaction-for-update( transaction-vaJue)(delay-time) 

= let transaction-time = (null(delay-time)--+ mk-add-delay-time( 0 )(l), 

mk-add-delay-time(delay-time)( 0 )) in 
mk-transaction( transaction-time) (transaction-value) 

mk-add-delay-time(global)(delta) 

= (TIMEPLUS ,dot(VHDLTIME ),mk-vhdltime(global)(delta)) 
mk-vhdltime(globaJ)(delta) = (VHDLTIME ,global,delta) 


8.4.12 Expressions 

Two semantic functions, E and R, translate expressions. E obtains the (qualified) place 
name corresponding to a scalar or array. R yields an expression that represents a value 
rather than a reference, 

(MEO) me I e 1 (t)(p)(h)(v)(stk) = h((£,e))(v)(stk) 


179 



(MEl) ME [ ref ref* ] (t)(p)(h)(v)(stk) 

= E [ ref I (t)(p)(k){v)(stk) 
where 

k = A(e,f),vi,stki. 

ME [ref* | (t)(p)(hi)(vi)(stki) 

where hi = A(e*,f*),V2,stk2.h((cons(e,e*),nconc(f,r)))(v2)(stk2) 


(MRO) MR Je I (t)(p)(h)(v)(stk) = h((€:,£))(v)(stk) 

(MRl) MR [expr expr* ] (t)(p)(h)(v)(stk) 

= R I expr 1 (t)(p)(k)(v)(stk) 
where 

k = A(e,f),vi jStki. 

MR I expr* | {t)(p)(hi)(vi)(stki) 
where hi = A(e*,f*),V2,stk2.h((cons(e,e*),nconc(f,f*)))(v2)(stk2) 


The translation of a (possibly empty) multiple expression list yields a list of translated 
expressions and a corresponding list of guard formulas. 

(El) E [ REF modifier+ ] (t)(p)(k)(v)(stk) 

= let basic-ref = modifier'^ in 

let (basic-name,d) = gen-basic-name(basic-ref)(t)(v) in 
gen-name(ref)(basic-name)(£)(d)(tl(basic-ref))(t)(p)(k)(v)(stk) 

gen-basic-name(basic-ref)(t)(v) 

= let (tg,q,id) = hd(basic-ref) in 
let d = t(q)(id) in 
(case tag(d) 

(♦PROCEDURE* *FUNCTION* ) (qualified-id(qid(d))(v),d), 

OTHERWISE -- (qualified-id(qid(d))(v),tdesc(type(d)))) 
gen-name(ref)(e)(f)(d)(ref-tail)(t)(p)(k)(v)(stk) 

= (null(ref-tail)~^ k((e,f))(v)(stk), 
let modifier = hd(ref-tail) in 
let (tgjisp) = modifier in 
(case tg 

INDEX —► gen-array-ref(isp)(e)(f)(d)(t)(p)(c)(v)(stk), 

SELECTOR —► gen-record-ref(isp)(e)(f)(d)(c)(v)(stk), 

PARLIST —► gen-function-call(ref)(isp)(d)(t)(p)(c){v)(stk), 

OTHERWISE 

—> impl-error(“Unrecognized Stage 4 VHDL reference modifier tag: ~a”,tg)) 
where 

c = A(ei ,fi ,di),v,stk. 

gen-name(ref)(ei)(fi)(di)(tl(ref-tail))(t)(p)(k)(v)(stk)) 

gen-array-ref(expr)(e)(f)(d)(t)(p)(c)(v)(stk) 

= R I expr 1 (t)(p)(k)(v)(stk) 
where 

k = A(eo,fo),v,stk. 

c(((ELEMENT ,e,eo), 
nconc 
(f,fo, 

(null(ub(d)) 

—► (mk-rel(univint-type-desc(t))((GE ,eo,(ORIGIN ,e)))), 
(mk-rel(univint-type-desc(t))((GE ,eo, (ORIGIN ,e))), 
mk-rel 

(univint-type-desc(t)) 

((LE ,eo, 

mk-exp 2 (SUB ,mk-exp 2 (ADD ,(ORIGIN ,e),(RANGE ,e)),l)))))), 
elty(d)))(v)(stk) 


180 




gen-record-ref(id)(e)(f)(d)(c)(v)(stk) 

= c((mk-recelt(e,id),f,lookup-record-desc(components(d))(id)))(v)(stk) 

mk-recelt(e)(id) = (RECORD ,e,id) 

lookup-record-desc(comp* )(id) 

= (null(comp*)— ^UNBOUND* , 
let (x,d) = hd(comp*) in 
(x == id —► d, lookup-record-desc(tl(comp*))(id))) 

gen-function>call(ref)(expr* )(d)(t)(p)(c)(v)(stk) 

= declare-function-name(d)(t)(p)(u)(v)(stk) 
where 
u = Av,stk. 

gen-cal](ref)(d)(expr*)(tt)(tt)(t)(p)(ci)(v)(stk) 
where 
Cl = Av,stk. 

c((qualified-id(qid(d))(v),£,tdesc(extract-rtype(d))))(v)(stk) 

declare-function-name(d)(t)(p)(u)(v)(stk) 

= let q = path(d) 

and dd = tdesc(extract-rtype(d)) in 
let z = hd(q) in 

let suqn**^ = get-qids((idf(d)))(t)(q) in 
let vi = push-universe(v)(z)(suqn'^) in 
let duqn‘*‘ = get-qualified-ids(suqn‘*‘)(vi) in 
let dc-desc = <*UNDECLARE* ,idf(d),q, 

Aui ,V2,Stk2. 

undeclare-function-name 

(suqn^ )(duqn‘*’)(z)(t)(ui)(v2)(stk2)> in 

(mk-decl-sd 

(z)(e)(=)((^)) 

(nconc 

(mk-qual-id-coverings(suqn'^ )(duqn^ )(z)(v)(t), 
mk-scalar-nonsignal-dec-post 

(e)((duqii^ ,e:,dd))(t)(q)(u)(vi )(stk-push(dc-desc)(stk))))) 

undeclare-function-name(suqn+ )(duqn+)(z)(t)(u)(v)(stk) 

= (mk-sd 

(z)(e)(e)(cons(z,duqn‘*')) 

(cons(mk-cover-already((dot(z),cons(pound(z),duqn'^ )))(l)i 
cons(mk-undeclare(duqn“*'), 
u(pop-universe(v)(suqn^ ))(stk-pop(stk)))))) 


A reference must begin with at least a basic reference, which contains its root identifier 
and access path. Following its basic reference, a reference has zero or more array index, 
record field selection, or actual parameter list modifiers. The reference itself is translated 
by gen-name; the basic reference is translated by gen-basic-name. The array index and 
record field selection modifiers are translated by gen-array-ref and gen-record-ref. The 
translation of a reference is complicated by the appearance of a parameter list modifier, 
which represents a function call; these are translated by gen-function-call. 

Whenever a function is called (as part of an expression), the name of that function is used 
in the expression to name the value returned by that particular invocation. Because the 


181 




same function can be invoked more than once in the same expression, each corresponding 
instance of the function’s name must be uniquely dynamicaUy qualified, and each of those 
DUQNs must be declared (and later undeclared when they should no longer exist) to SDVS. 
The declaration is performed by function declare-function-name and the undeclaration 
by undeclare-function-name; the invocation of the latter function is encapsulated in an 
undeclaration (’"UNDECLARE*) descriptor pushed onto the execution stack. After a 
new dynamic instance of the function’s name is declared, gen-function-call evaluates the 
actual parameters and then invokes gen-call to finish the translation of this function call. 

(RO) R le 1 (t)(p)(k)(v)(stk) = k((£,e))(v)(stk) 

For technical convenience, expressions can be empty; the translation of an empty expression 
yields empty results. 

(Rl) R 1 FALSE 1 (t)(p)(k)(v)(stk) = k((FALSE ,£))(v)(stk) 

(R 2 ) R I TRUE 1 (t)(p)(k)(v)(stk) = k((TRUE ,e))(v)(stk) 

(R 3 ) R I BIT bitlit 1 (t)(p)(k)(v)(stk) = k((B I bitUt 1 ,£))(v)(stk) 

(R 4 ) R [ NUM constant | (t)(p)(k)(v)(stk) = k((N [[ constant ] ,£))(v)(stk) 

(R 5 ) R I TIME constant FS 1 (t)(pKk)(v)(stk) = k((N ([ constant ] ,£))(v)(stk) 

(R 6 ) R [ CHAR constant J (t)(p)(k)(v)(stk) = k({expr,£))(v)(stk) 


(R 7 ) R I ENUMLIT id ] (t)(p)(k)(v)(stk) = k((id,£))(v)(stk) 

(R 8 ) R I BITSTR bit-lit* ] (t)(p)(k)(v)(stk) 

= let expr* bit-lit* in 

MR If expr* ] (t)(p)(k)(v)(stk) 

(R 9 ) R I STR char-lit* ] (t)(p)(k)(v)(stk) 

= let expr* = char-lit* in 

MR II expr* 1 (t)(p)(k)(v)(stk) 

(RIO) R I REF modifier+ 1 (t)(p)(k)(v)(stk) 

= let ref = expr in 

E|[refl(t)(p)(k:)(v)(stk) 

where ki = A(e,f),vi,stki.k((dot(e),f))(vi)(stki) 

Scalar and array references are first E-translated, yielding an expression and a guard for¬ 
mula. The corresponding R-translation is obtained by applying the dot operation to the 
translated expression. 


182 



(Rll) R I PAGGR expr* ] (t)(p)(k)(v)(stk) = ME I expr* J (t)(p)(k)(v)(stk) 


(R 12 ) R I TYPECONV expr type-mark ]) (t)(p)(k)(v)(stk) 

= let d = lookup-desc(type-mark)(t)(p) in 
R [ expr 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(e,f),v,stk. 

let constraint-guard* = mk-constraint-guards 

((e))((d))(t)(p)(v)(stk) in 
(null(constr«dnt-guard*)—t k((e,f))(v)(stk), 
(mk-sd(hd(p))(constraint-guard*)(£)(e)(k((e,f))(v)(stk)))) 


(R 13 ) R [unary-op expr ] (t)(p)(k)(v)(stk) 

= R [ expr I (t)(p)(ki )(v)(stk) 

where ki = A(e,f),vi ,stki .k((mk-expl(unary-op,e),f))(vi )(stki) 


mk-expl (unary-op,e) 

= (case unary-op 

NOT ^ (NOT ,e), 

BNOT ^ (USNOT ,e), 

PLUS ^ e, 

NEC (MINUS ,e), 

ABS - (ABS ,e), 

(RNEG ,RABS ) —► (unary-op,e), 

OTHERWISE 

impl-error(“Unrecognized Stage 4 VHDL unary operator: "'a”,unary-op)) 


(Rl 4 ) R [ binary-op expri expr2 I (t)(p)(k)(v)(stk) 

= R [ expn I (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi,vi ,stki). 

R [ expr2 1 (t)(p)(k2)(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 

k((mk-exp 2 (binary-op,ei ,e2),nconc(fi ,f2)))(v2)(stk2) 


(R 15 ) R [ relational-op expri expr2 1 (t)(p)(k)(v)(stk) 

= R [ expri 1 (t)(p)(ki)(v)(stk) 
where 

ki = A(ei,fi,vi,stki). 

R [ expr2 I (t)(p)(k2)(vi)(stki) 
where 

k2 = A(e2,f2),V2,Stk2. 

let d = T [ expri | (t)(p) in 
k((mk-rel(d)((relationaI-op,e] ,02 )),nconc(fi ,f2))) 
(V2)(stk2) 


183 



8.4.13 Expression Types 


The function mk-rel (described earlier) requires a type descriptor as its first argument; 
application of the semantic function T determines the type descriptor of an expression as 
follows: 


• if the expression is a constant, its type descriptor is the basic type of that constant; 

• if the expression is a reference, its type descriptor is the basic type of that reference, 
obtained by the function get-type-desc; and 

• if the expression contains operators, its type descriptor is the basic result type of its 
top-level operator (if there is one); 

(TO) T [[ e: ] (t)(p) = void-type-desc(t) 

(Tl) T I FALSE 1 (t)(p) == bool-type-desc{t) 

(T2) T I TRUE 1 (t)(p) = bool-type-desc(t) 

(T3) T [[ BIT bitlit | (t)(p) = bit-type-desc(t) 

{T4) T [[ NUM constant ]] (t)(p) = univint-type-desc(t) 

(T5) T [[ TIME constant FS ]| (t){p) = time-type-desc(t) 

(T6) T [[ CHAR constant J (t)(p) = char-type-desc{t) 

(T7) T I ENUMLIT id ] (t)(p) 

= let d = Iookup-desc-on-path(t)(p)(id) in 
tdesc(type(d)) 

(T8) T I BITSTR bit-lit* ] (t)(p) = bitvector-type-desc(t) 

(T9) T I STR char-lit* ] (t)(p) = string-type-desc(t) 

(TIO) T I REF modifier^ ]| (t)(p) 

= let basic-ref — modifier"*’ in 
get-type-desc(basic-ref)(t)(p) 


get-type-desc(b£Lsic-ref)(t)(p) 

= let (tg,q,id) = hd(basic-ref) in 
let d = t(q)(id) in 
(case tag(d) 

(♦PROCEDURE* *FUNCTION* *PROCESS* ) 

—► process-ref-tail(d)(tl(basic-ref))(t)(p), 

OTHERWISE —process-ref-tail(tdesc(type(d)))(tl(basic-ref))(t)(p)) 


184 



process-ref-tail(d)(ref-tail)(t)(p) 

= (null(ref-tail)—*■ d, 

let modifier = hd(ref-t^) in 
(case hd(modifier) 

INDEX —► process-ref-taxl(elty(d))(tl(ref-tail))(t)(p), 

SELECTOR 
process-ref-tail 

(lookup-record-desc(compon€nts(d))(second(modifier)))(tl(ref-tail)) 

(t){p). 

PARLIST ^ process-ref-tail(tdesc(extract-rtype{d)))(tl{ref-tail))(t)(p), 

OTHERWISE 

—► impl-error 

(“Unrecognized Stage 4 VHDL reference modifier tag: "'a”, 
hd(modifier)))) 


(Til) T I PAGGR expr* ] (t)(p) = void-type-desc(t) 

(T12) T [ TYPECONV expr type-mark ] (t)(p) = lookup-desc(type-mark)(t)(p) 

(T13) T [[ unary-op expr ]] (t)(p) = tdesc(restypel(unary-op)(t)) 

restypel(unary-op)(t) 

= (case unary-op 

NOT —*• (VAL ,booi-type-desc(t)), 

BNOT — (VAL ,bit-type-desc(t)), 

(PLUS ,NEG ,ABS ) — (VAL ,univint-type-desc(t)), 

(RNEG ,RABS ) —► (VAL ,real-type-desc(t)), 

OTHERWISE 

—impl-error(“Unrecognized Stage 4 VHDL unary operator: ~a”,unary-op)) 


(Tl 4 ) T [ binary-op expri expr2 | (t)(p) 

= tdesc(restype 2 (binary-op)((expri ,expr2))(t)(p)) 

restype 2 (binary-op)(expri ,expr2)(t)(p) 

= (case binary-op 

(AND ,NAND ,OR ,NOR ,XOR ) — mk-type((DUMMY VAL) )(booI-type-desc(t)), 

(BAND ,BNAND ,BOR ,BNOR ,BXOR ) ^ mk-type((DUMMY VAL) )(bit-type-desc(t)), 

(ADD ,SUB ,MUL ,DIV ,MOD ,REM ,EXP ) —^ mk-type((DUMMY VAL) )(univint-type-desc(t)), 
(RPLUS ,RMINUS ,RTIMES ,RDIV ,REXPT ) mk-type((DUMMY VAL) )(real-type-desc(t)), 
CONCAT 

-H. let di = T [expri ] (t)(p) 

and d2 — T [ expr2 ] (t)(p) in 
mk-type((DUMMY VAL) )(mk-concat-tdesc(di )(d2)(t)), 

OTHERWISE 

—► impl-error(“Unrecognized Stage 4 VHDL binary operator: “'a”,binary-op)) 

mk-concat-tdesc(di )(d2)(t) 

= (is-bit-tdesc?(di )V is-bitvector-tdesc?(di) 

—► array-type-desc 

(new-array-type-name(BIT^VECTOR ))(e)(£)(tt)(direction(di ))(lb(di ))(e) 

(bit-type-desc(t)), 
let idfi = idf(di) in 
array-type-desc 

(new-array-type-name((consp(idfi )—»• hd(idfi), idfi )))(£:)(e)(tt) 

(direction(di ))(lb(di ))(€:)(elty(di))) 

(Tl 5 ) T [ relational-op expn expr2 J (t)(p) = bool-type-desc(t) 


185 



8.4.14 Primitive Semantic Equations 


The following semantic functions are primitive. 

(Nl) N [[ constant | = constant 


(Bl) B [ bitlit J = mk-bit-siinp-symbol(bitlit) 

mk-bit-simp-symbol(bitlit) 

= (case bitlit 

0 -- (BS 0 1) , 

1 -V (BS 1 1) , 

OTHERWISEimpl-error(“CanH construct simp symbol for bit: "a ”,bitlit)) 


186 



9 Conclusion 


A precise and well-documented formal specification of the Stage 4 VHDL translator has been 
presented in this report. We have completed and exercised a Common Lisp implementation 
of both translation phases described herein. As the SDVS interface to VHDL continues to 
expand and mature, our confidence grows in our language translator semantic specification 
and implementation paradigm. 

Stage 4 VHDL represents a robust subset of the VHSIC Hardware Description Language, 
supporting both behavioral and structural descriptions of digital devices with the inclu¬ 
sion of the following language constructs: design files, design units, configuration decla¬ 
rations, entity declarations, architecture bodies, ports, declarative parts in entity declara¬ 
tions, package STANDARD (containing predefined types BOOLEAN, BIT, UNIVERSAL-INTEGER, 
INTEGER, TIME, CHARACTER, REAL, STRING, and BIT-VECTOR), user-defined packages, USE 
clauses, generics, component declarations, generic and port maps, array type declarations, 
certain predefined attributes, enumeration types, subtypes of scalar types, integer type 
definitions, type conversions, BLOCK statements, PROCESS statements, concurrent signal as¬ 
signment statements, component instantiation statements, subprograms (procedures and 
functions), IF and CASE statements, WHILE and FOR loops, octal and hexadecimal represen¬ 
tations of bitstrings, and general expressions of type TIME in AFTER clauses. 

Much of our work henceforth will focus on applying SDVS and the VHDL translator to 
the formal verification of realistic VHDL hardware descriptions. Indeed, we have already 
made significant steps in this direction in fiscal year 1994. We identified VHDL descriptions 
suitable for a Stage 4 VHDL verification exercise, developed in-house at the National Se¬ 
curity Agency. These specify a set of commercial standard parts, the Am7968/Am7969 
TAXIchip^'^ (Transparent Asynchronous Xmitter-Receiver Interface) Integrated Circuits 
designed by Advanced Micro Devices, Inc. (AMD). The TAXIchip Am7968 Transmit- 
ter/Am7969 Receiver chipset constitutes a general-purpose interface for high-speed serial 
communication between two parallel-data hosts, and is used in a prototype cryptographic 
device currently being built by NS A. 

We wrote formal state delta specifications for simplified versions of these descriptions, as 
well as a specification for a combined system in which the output of the transmitter is 
input to the receiver, and have completed proofs that the descriptions meet several of these 
specifications. 

In fiscal year 1995, we intend to proceed by incrementally incorporating additional features 
of the original TAXIchip descriptions into the simplified descriptions we have produced, 
and by attempting to prove successively more interesting properties of the latter. After 
implementing a few, relatively minor, enhancements to the VHDL translator — principally, 
a subset of the IEEE STD-L0GIC_1164 multivalue logic system — not much additional effort 
will be required to formulate and prove specifications of the TAXIchip VHDL as originally 
given. 


187 



References 


[1] J. V. Cook, I. V. Filippenko, B. H. Levy, L. G. Marcus, and T. K. Menas, '‘Formal 
Computer Verification in the State Delta Verification System (SDVS),” in Proceedings 
of the AIAA Computing in Aerospace Conference^ (Baltimore, Maryland), pp. 77-87, 
American Institute of Aeronautics and Astronautics, October 1991. 

[2] B. Levy, 1. Filippenko, L. Marcus, and T. Menas, “Using the State Delta Verification 
System (SDVS) for Hardware Verification,” in Proceedings of the IFIP TClO/WG 10.2 
International Conference on Theorem Provers in Circuit Design: Theory, Practice and 
Experience: Nijmegen, The Netherlands (ed. V. Stavridou, T. F. Melham, and R. T. 
Boute), pp. 337-360, North-Holland, June 1992. 

[3] L. G. Marcus, “SDVS 13 Users’ Manual,” Technical Report ATR-94(4778)-5, The 
Aerospace Corporation, September 1994. 

[4] T. K. Menas and I. V. Filippenko, “SDVS 13 Tutorial,” Technical Report ATR- 
94(4778)-6, The Aerospace Corporation, September 1994. 

[5] B. H. Levy, “Feasibility of Hardware Verification Using SDVS,” Technical Report ATR- 
88(3778)-9, The Aerospace Corporation, September 1988. 

[6] IEEE, Standard VHDL Language Reference Manual, 1988. IEEE Std. 1076-1987. 

[7] D. F. Martin and J. V. Cook, “Adding Ada Program Verification Capability to the 
State Delta Verification System (SDVS),” in Proceedings of the 11th National Com¬ 
puter Security Conference, National Bureau of Standards/National Computer Security 
Center, October 1988. 

[8] T. Aiken, 1. Filippenko, B. Levy, and D. Martin, “A Formal Description of the In¬ 
cremental Translation of Core VHDL into State Deltas in the State Delta Verifica¬ 
tion System (SDVS),” Technical Report ATR-89(4778)-9, The Aerospace Corporation, 
September 1989. 

[9] 1. V. Filippenko, “Example Proof of a Core VHDL Description in the State Delta 
Verification System (SDVS),” Technical Report ATR-90(5778)-6, The Aerospace Cor¬ 
poration, September 1990. 

[10] 1. V. Filippenko, “Some Examples of Verifying Core VHDL Hardware Descriptions 
Using the State Delta Verification System (SDVS),” Technical Report ATR-91(6778)- 
6, The Aerospace Corporation, September 1991. 

[11] 1. V. Filippenko, “A Formal Description of the Incremental Translation of Stage 1 
VHDL into State Deltas in the State Delta Verification System (SDVS),” Technical 
Report ATR-91(6778)-7, The Aerospace Corporation, September 1991. 

[12] 1. V. Filippenko and L. G. Marcus, “Integrating Structural VHDL Hardware De¬ 
scriptions into the State Delta Verification System (SDVS),” Technical Report ATR- 
92(8180)-!, The Aerospace Corporation, September 1992. 


188 



[13] M. J. C. Gordon, The Denotational Description of Programming Languages: An In¬ 
troduction, (New York: Springer-Verlag, 1979). 

[14] I. V. Filippenko, “A Formal Description of the Incremental Translation of Stage 2 
VHDL into State Deltas in the State Delta Verification System (SDVS),” Technical 
Report ATR-92(2778)-4, The Aerospace Corporation, September 1992. 

[15] I. V. Filippenko, “A Formal Description of the Incremental Translation of Stage 3 
VHDL into State Deltas in SDVS,” Technical Report ATR-93(3778)-2, The Aerospace 
Corporation, September 1993. 

[16] J. V. Cook, “The Language for DENOTE (Denotational Semantics Translation 
Environment),” Technical Report TR-0090(5920-07)-2, The Aerospace Corporation, 
September 1990. 

[17] L. Marcus and B. H. Levy, “Specifying and Proving Core VHDL Descriptions in 
the State Delta Verification System (SDVS),” Technical Report ATR-89(4778)-5, The 
Aerospace Corporation, September 1989. 

[18] L. Marcus, T. Redmond, and S. Shelah, “Completeness of State Deltas,” Technical 
Report ATR-86(8454)-2, The Aerospace Corporation, September 1986. 

[19] T. K. Menas, “The Relation of the Temporal Logic of the State Delta Verification 
System (SDVS) to Classical First-Order Temporal Logic,” Technical Report ATR- 
90(5778)-10, The Aerospace Corporation, September 1990. 

[20] J. E. Doner and J. V. Cook, “Offline Characterization of Procedures in the State 
Delta Verification System (SDVS),” Technical Report ATR-90(8590)-5, The Aerospace 
Corporation, September 1990. 

[21] J. V. Cook and J. E. Doner, “Example Proofs Using Offline Characterization of Proce¬ 
dures in the State Delta Verification System (SDVS),” Technical Report TR-0090(5920- 
07)-3, The Aerospace Corporation, September 1990. 


189 



Index 


access 86, 141 

accom pli sh - gen eri c- an d - p ort - m ap s 107 

already-qualified-id 142 

arl 140 

argtypesl 101 

argtypesl-error 101 

argtypes2 103 

argtypes2-error 103 

array-signal-assignment 163 

array-size 70 

array-type 99 

array-type-desc 44 

artl 61 

arxl 111 

assign 145, 161 

assign-array-downto 145 

assign-array-to 145 

assign-multiple 175 

assign-record 146 

assign-record-aux 146 

assign-record-fields 146 

atO 95 

atl 95 

at2 95 

at3 96 

attributes 82 

attributes-low-high 74, 157 

axO 117 

axl 117 

ax2 117 

ax3 117 

bl 105, 186 

base-type 47 

bctl 58 

bcxl 110 

bind-parameters 173 
bit-type-desc 43 
bitl 59 
bits-op 120 

bitvector-type-desc 44 
bixl 110 
block-exit 137 
body 47 


bool-type-desc 43 

cascade-array-signal-assignment 163 

case-coverage 90 

case-overlap 96 

case-type-ok 90 

case-union 96 

cfl 139 

cftl 58 

cfxl 110 

char-type-desc 43 
characterizations 47 
check-array-aggregate 73 
check-coverage-locals 66 
check-enum-lits 74 
check-existence-formals 65 
check-exprs 73 

check-formal-local-correspondence 66 

check-if 89 

check-pkg-names 79 

check-portmap-element 64 

check-portmap-elements 64 

check-wait-ref 95 

check-wait-refs 94 

chk-array-type 99 

ciO 138 

cil 138 

ci2 138 

citO 57 

citl 57 

cit2 57 

cixO 109 

cixl 109 

cix2 109 

cmtO 58 

cmtl 58 

cmt2 59 

cmxO 110 

cmxl 110 

cmx2 110 

collect-allpars 173 

collect-expressions-from-conditional-waveforms 

87 

collect-expressions-from-selected-waveforms 


190 




85 

collect-fids 77 

collect-formal-pars 77 

collect-fromargs 174 

collect-frompars 174 

collect-guards-for-exprs 174 

coUect-signals-from-expr 86 

coUect-signals-from-expr-list 85 

coUect-toargs 174 

collect-toargs-types 174 

collect-topars 174 

coUect-topars-types 174 

collect-transaction-expressions 85 

compatible-par-types 69 

compatible-signatures 69 

component-name 47 

components 47 

concatenate-bits 151 

concatenate-cbaracters 151 

configured-entity 47 

construct-case-alternatives 86 

construct-cond-parts 87 

construct-equivalent-nested-block-stat 

context 94, 177 

csO 159 

csl 159 

cs2 159 

cs3 159 

cstO 83 

cstl 83 

cst2 84 

cst3 84 

cst4 85 

cst5 87 

cst6 87 

csxO 113 

csxl 113 

csx2 114 

c.sx3 114 

csx4 115 

csx5 115 

csx6 115 

do 140 

dl 140 

dlO 157 

dll 158 


dl2 158 
dl3 158 
dl4 158 
dl5 159 
dl6 159 
dl7 159 
d2 141 
d3 141 
d4 141 
d5 141 
d6 141 
d7 156 
d8 157 
d9 157 

declare-function-name 181 

dfl 133 

dftl 55 

dfxl 109 

direction 47 

dot 131 

dotted-expr-p 135, 145 
drtO 96 
107 drtl 96 
drt2 97 
drxO 117 
drxl 117 
drx2 117 
dtO 66 
dtl 66 
dtlO 75 
dtll 76 
dtl2 76 
dtl3 78 
dtl4 79 
dtl5 82 
dtl6 83 
dtl7 83 
dt2 66 
dt3 66 
dt4 66 
dt5 66 
dt6 72 
dt7 74 
dt8 74 
dt9 75 
duO 138 


191 





dul 138 
du2 138 
duplicates? 62 
dutO 57 
dutl 57 
dut2 57 
duxO 109 
duxl 109 
dux2 109 
dxO 112 
dxl 112 
dxlO 113 
dxll 113 
dxl2 113 
dxl3 113 
dxl4 113 
dxl5 113 
dxl6 113 
dxl7 113 
dx2 112 
dx3 112 
dx4 112 
dx5 112 
dx6 112 
dx7 112 
dx8 112 
dx9 112 
el 180 
elty 47 
enl 140 
entl 61 

enter-array-objects 73 
enter-characters 56 
enter-fonnal-pars 77 
enter-objects 55 
enter-package 56 
enter-standard 55 
enter-standard-predefined 56 
enter-string 56 
enter-textio 55 
enter-textio-predefined 56 
enum-le 105 
enum-lt 105 
enxl 110 
etO 98 
etl 98 


etlO 100 
etll 100 
etl2 100 
etl3 100 
et2 98 
et3 99 
et4 99 
et5 99 
et6 99 
et7 99 
et8 99 
et9 100 
eval-expr 131 
exO 117 
exl 117 
ex10 119 
ex11 120 
exl2 120 
exl3 120 
ex2 117 
ex3 117 
ex4 117 
ex5 118 
ex6 118 
ex7 118 
ex8 118 
ex9 118 
exit 171 

export-qualified-names 80 
exported 47 
extract-par-types 69 
extract-pars 173 
extract-poly-pars 173 
extract-rtype 69, 178 
extract-rtypes 94 
fifth 12 

filter-components 71 
find-architecture-env 85 
find-configuration-abstract-syntax 130 
find-looplabel-env 92 
find-process-env 88, 178 
find-progunit-env 67 
find-signal-structure 130 
fixed-characterized-sds 131 
fourth 12 
gdtO 61 


192 



gdtl 61 

gdt2 61 

gdt3 62 

gdxO 111 

gdxl 111 

gdx2 111 

gdx3 111 

gen-alt 165 

gen-array-decl 148 

gen-array-decl-id* 148 

gen-array-decl-id+ 148 

gen-array-nonsignal-decl-idH- 149 

gen-array-ref 180 

gen-array-signal-decl-id+ 152 

gen-ascending-indices 163 

gen-basic-name 180 

gen-call 172 

gen-case 165 

gen-characterization 172 

gen-characterizations 172 

gen-characters 56 

gen-descending-indices 163 

gen-function-call 181 

gen-guard 166 

gen-if 164 

gen-name 180 

gen-record-ref 181 

gen-scalar-decl 142 

gen-scalar-decl-id* 142 

gen-scalar-decl-id+ 142 

gen-sca]ar-nonsignal-decl-id+ 142 

gen-scalar-signal-decl-id+ 146 

get-base-type 48, 70 

get-configuration-architecture-id 139 

get-configuration-entity-id 139 

get-loop-enum-param-vals 131 

get-parent-type 48 

get-qids 142 

get-qualified-ids 127, 142 
get-signals 178 
get-type-desc 184 
gmtl 63 
gmxl 112 
idf 46 

import-legal 80 
import-qualified-names 79 


init-array-signal-downto 131 
init-array-signal-to 131 
init-scalar-signal 131 
init-var 127 
int-type-desc 43 
intermediate-phase 56 
invert-bit 101 
is-array-tdesc? 46 
is-array? 46 
is-binary-op? 48 
is-bit-tdesc? 45 
is-bit? 45 

is-bitvector-tdesc? 46 
is-bitvector? 46 
is-boolean-tdesc? 45 
is-boolean? 45 
is-character-tdesc? 46 
is-character? 45 
is-const? 46, 48 
is-constant-bitvector? 135, 145 
is-constant-string? 135, 145 
is-integer-tdesc? 45 
is-integer? 45 
is-paggr? 48 
is-poly-tdesc? 45 
is-poly? 45 
is-readable? 48 
is-real-tdesc? 45 
is-real? 45 
is-record-tdesc? 46 
is-record? 46 
is-ref? 48 

is-relational-op? 48 
is-sig? 46, 48 
is-string-tdesc? 46 
is-string? 46 
is-time-tdesc? 45 
is-time? 45 
is-unary-op? 48 
is-var? 46, 48 
is-void-tdesc? 45 
is-void? 45 
is-writable? 48 
last 13 
lb 47 
length 13 


193 




length-expr 149 

list-type 69 

literals 47 

lookup-desc 141 

lookup-desc-for-ref 86 

lookup-desc-on-path 86, 141 

lookup-local 69 

lookup-record-desc 181 

lookup-record-field 69 

lookup-type 67 

lookup2 68 

loop-for-enum 170 

loop-for-int 169 

loop-infinite 167 

loop-while 167 

lul 139 

lu2 139 

lu3 139 

lu4 139 

lu5 139 

lutl 57 

lut2 57 

lut3 57 

lut4 57 

lut5 57 

luxl 109 

lux2 109 

lux3 109 

lux4 109 

lux5 109 

make-universe-data 126 

make-vhdl-begin-model-execution 130 

make-vhdl-process-elaborate 130 

uiake-vhdl-process-suspend 130 

make-vhdl-try-resume-next-process 130 

match-array-type-names 70 

match-integer-types 70 

match-type-names 70 

match-types 70 

meO 179 

mel 180 

mexO 117 

mexl 117 

mk-add-delay-time 179 
mk-array-decl 150 
mk-array-elt 151 


mk-array-nonsignal-dec-post 150 
mk-array-nonsignal-dec-post-declare 150 
mk-array-nonsignal-dec-post-init-downto 151 
mk-array-nonsignal-dec-post-init-to 151 
mk-array-refs 163 
mk-array-refs-aux 163 
mk-array-signal-dec-post 152 
mk-array-signal-dec-post-declare 153 
mk-array-signal-dec-post-init 154 
mk-array-signal-dec-post-init-aux 156 
mk-array-signal-dec-post-init-downto 155 
mk-array-signal-dec-post-init-elt-arrays-downto 

155 

mk-array-signal-dec-post-init-elt-arrays-to 

155 

mk-array-signal-dec-post-init-elt-scalars-downto 

156 

mk-array-signal-dec-post-init-elt-scalars-to 

156 

mk-array-signal-dec-post-init-to 154 
mk-array-signal-decl 153 
mk-array-signal-elt-fn-decls 153 
mk-array-signal-elt-fn-decls-aux 154 
mk-bit-simp-symbol 101, 186 
mk-bitvec-fn-decl 150 
mk-bool-eq 137 
mk-bool-neq 137 
mk-concat-tdesc 103, 185 
mk-constraint-guards 174 
mk-cover 133 
mk-cover-already 176 
mk-disjoint 133 
mk-dotted-names 151 
mk-element-transaction-lists 164 
mk-element-waves 163 
mk-elenient-waves-aux 131 
mk-enum-set 97 
mk-enumlit-rels 157 
mk-etdec-post 156 
mk-expl 183 
mk-exp2 146 
mk-inertial-update 163 
mk-initial-universe 126 
mk-not 163 
mk-or 165 
mk-ors 165 


194 



mk-par-decls 175 
mk-preeniption 163 
mk-qual-id-coverings 143 
mk-real-dotted-name 47 
mk-recelt 146, 181 
mk-rel 135 

mk-scalar-decl 133, 144 
mk-scalar-nonsignal-dec-post 143 
mk-scalar-nonsignal-dec-post-declare 144 
ink-scalar-nonsignal-dec-post-init 144 
mk-scalar-rel 136 
mk-scalar-signal-assignments 163 
mk-scalar-signal-dec-post 147 
mk-scalar-signal-dec-post-dedare 147 
mk-scalar-signal-dec-post-init 147 
mk-scalar-signal-decl 147 
mk-scalar-signal-fn-decl 147 
ink^scalar-signal-fn-decls 154 
mk-set 97 

mk-simultaneous-transactions 164 
mk-slice-elt-names-downto 151 
mk-slice-elt-names-to 150 
ink-string-fn-decl 150 
mk-tick-high 74, 148, 157 
mk-tick-low 74, 148, 157 
mk-tmode 48 

mk-transaction-for-update 179 
mk-transaction-list 164 
mk-transport-update 162 
mk-type 48 
mk-type-spec 143 
mk-nndeclare 176 
mk-vhdl-array-decl 150 
mk-vhdltime 137, 179 
mk-waveform-type-spec 152 
model-execution-complete 137 
mrO 180 
mrl 180 
nl 105 
nl 186 

name-driver 130 
name-drivers 147 
name-qualified-id 127, 142 
name-type 68 
namef 46 
next-var 127 


nth-tl 97 

object-class 48 

otl.Ltex 101 

ot2.1.tex 102 

ot2.2.tex 102 

package-body-exit 157 

parent-type 47 

pars 47 

path 47 

pbody 47 

pdtO 62 

pdtl 62 

pdt2 62 

pdt3 63 

pdxO 111 

pdxl 111 

pdx2 111 

pdx3 111 

phasel-tail 56 

pmtl 64 

pmxl 112 

poly-type-desc 43 

pop-universe 127 

pop-universe-vars 127 

pop-var 127 

position 97 

position-aux 97 

pound 131 

process-block-header 84 
process-bound-configuration 60 
process-bound-entity 60 
process-component-spec 59 
process-dec 70 
process-generic-part 84 
process-port-part 84 
process-ref-tail 185 
process-slcdec 72 
process-subprog-body 78 
process-use-clause 79 
push-universe 126 
push-universe-vars 126 
push-var 127 
qid 46 

qualified-id 127, 142 
qualified-id-decls 143 
rO 182 


195 



rl 182 
rlO 182 
rll 183 
rl2 183 
rl3 183 
rl4 183 
rl5 183 
r2 182 
r3 182 
r4 182 
r5 182 
r6 182 
rl 182 
r8 182 
r9 182 

read-check-portmap*elenient 65 
real-lb 148 
real-op 120 
real-type-desc 43 
real-ub 148 

record-equivalent-nested-block-stat 
record-to-type 144 
ref-mode 48 

remove-enclosing-pkgs 79 
rest 13 

restypel 101, 185 
restype2 103, 185 
res vail 101 
resval2 105 
return 177 
reverse 97 
reverse-aux 97 
rtl 100 
rtype 47 
rxl 120 
scalar-op 120 

scalar-signal-assignment 162 

second 12 

set-card 90 

signatures 47 

simple-name-match 80 

simple-term 137 

sixth 13 

sltO 87 

sltl 87 

slt2 87 


slxO 115 
slxl 115 
slx2 115 
sources 47 
ssO 160 
ssl 160 
sslO 170 
ssll 171 
ssl2 177 
ssl3 178 
ss2 160 
ss3 160 
ss4 162 
ss5 164 
ss6 165 
ss7 167 
ss8 167 
ss9 168 
sstO 88 
sstl 88 

107 sstlO 93 

sstll 93 
sstl2 94 
sstl3 94 
sst2 88 
sst3 88 
sst4 89 
sst5 89 
sst6 90 
sst7 91 
sst8 91 
sst9 92 
ssxl 115 
ssxlO 116 
ssxll 116 
ssxl2 116 
ssxl3 116 
ssx2 115 
ssx3 116 
ssx4 116 
ssx5 116 
ssx6 116 
ssx7 116 
ssx8 116 
ssx9 116 

string-type-desc 44 


196 



subst-vars 131 
to 184 
tl 184 
tlO 184 
til 185 
tl2 185 
tl3 185 
tl4 185 
tl5 185 
t2 184 
t3 184 
t4 184 
t5 184 
t6 184 
t7 184 
t8 184 
t9 184 
tag 47 
tdesc 48 
third 12 

time-type-desc 43 
tmode 48 
trl 179 

transform-assoc-elts 112 

transform-if 116 

transform-list 119 

transform-name 119 

transform-name-aux 119 

trmO 179 

trml 179 

trtl 98 

trt2 98 

trxl 117 

trx2 117 

type 47 

type-check-genericmap-element 64 
type-check-genericmap-elements 63 
type-check-portmap-element 65 
type-tick-high 47 
type-tick-low 47 
ub 47 

unbind-parameters 176 
undeclare-function-name 181 
underef 176 
universe-counter 126 
uni verse-name 126 


universe-stack 126 
universe-vars 126 
univint-type-desc 43 

update-tse-wrt-component-instantiations 107 
update-tse-wrt-configuration 107 
validate-access 68 
value 47 

vhdltime-type-desc 133 
void-type-desc 43 
wl 179 

waveform-type-desc 147, 162 
write-check-portmap-element 65 
wtl 98 
wxl 117 


197 



